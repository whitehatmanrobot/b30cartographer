            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTClipOrigin __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTClipOrigin __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClipOrigin )( 
            IDXTClipOrigin __RPC_FAR * This,
            DXVEC __RPC_FAR *pvecClipOrigin);
        
        END_INTERFACE
    } IDXTClipOriginVtbl;

    interface IDXTClipOrigin
    {
        CONST_VTBL struct IDXTClipOriginVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTClipOrigin_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTClipOrigin_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTClipOrigin_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTClipOrigin_GetClipOrigin(This,pvecClipOrigin)	\
    (This)->lpVtbl -> GetClipOrigin(This,pvecClipOrigin)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTClipOrigin_GetClipOrigin_Proxy( 
    IDXTClipOrigin __RPC_FAR * This,
    DXVEC __RPC_FAR *pvecClipOrigin);


void __RPC_STUB IDXTClipOrigin_GetClipOrigin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTClipOrigin_INTERFACE_DEFINED__ */



#ifndef __DXTRANSPLib_LIBRARY_DEFINED__
#define __DXTRANSPLib_LIBRARY_DEFINED__

/* library DXTRANSPLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_DXTRANSPLib;

EXTERN_C const CLSID CLSID_DXWarp;

#ifdef __cplusplus

class DECLSPEC_UUID("E0EEC500-6798-11d2-A484-00C04F8EFB69")
DXWarp;
#endif

EXTERN_C const CLSID CLSID_DXTLabel;

#ifdef __cplusplus

class DECLSPEC_UUID("54702535-2606-11D1-999C-0000F8756A10")
DXTLabel;
#endif

EXTERN_C const CLSID CLSID_DXRasterizer;

#ifdef __cplusplus

class DECLSPEC_UUID("8652CE55-9E80-11D1-9053-00C04FD9189D")
DXRasterizer;
#endif

EXTERN_C const CLSID CLSID_DX2D;

#ifdef __cplusplus

class DECLSPEC_UUID("473AA80B-4577-11D1-81A8-0000F87557DB")
DX2D;
#endif
#endif /* __DXTRANSPLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HFONT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HFONT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HFONT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HFONT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HFONT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HFONT __RPC_FAR * ); 
void                      __RPC_USER  HFONT_UserFree(     unsigned long __RPC_FAR *, HFONT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\simpsons\dxtranspguid.h ===
//depot/Lab06_N/root/public/internal/mshtml/inc/dxtranspguid.h#1 - add change 5035 (text)

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0285 */
/* Compiler settings for dxtransp.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IDXRasterizer,0x9EA3B635,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTLabel,0xC0C17F0E,0xAE41,0x11d1,0x9A,0x3B,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(IID, IID_IDX2DDebug,0x03BB2457,0xA279,0x11d1,0x81,0xC6,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDX2D,0x9EFD02A9,0xA996,0x11d1,0x81,0xC9,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXGradient2,0xd0ef2a80,0x61dc,0x11d2,0xb2,0xeb,0x00,0xa0,0xc9,0x36,0xb2,0x12);


MIDL_DEFINE_GUID(IID, IID_IDXWarp,0xB7BCEBE0,0x6797,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_IDXTClipOrigin,0xEE1663D8,0x0988,0x4C48,0x9F,0xD6,0xDB,0x44,0x50,0x88,0x56,0x68);


MIDL_DEFINE_GUID(IID, LIBID_DXTRANSPLib,0x527A4DA4,0x7F2C,0x11d2,0xB1,0x2D,0x00,0x00,0xF8,0x1F,0x59,0x95);


MIDL_DEFINE_GUID(CLSID, CLSID_DXWarp,0xE0EEC500,0x6798,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTLabel,0x54702535,0x2606,0x11D1,0x99,0x9C,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_DXRasterizer,0x8652CE55,0x9E80,0x11D1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DX2D,0x473AA80B,0x4577,0x11D1,0x81,0xA8,0x00,0x00,0xF8,0x75,0x57,0xDB);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0285 */
/* Compiler settings for dxtransp.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win64 (32b run,appending), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IDXRasterizer,0x9EA3B635,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTLabel,0xC0C17F0E,0xAE41,0x11d1,0x9A,0x3B,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(IID, IID_IDX2DDebug,0x03BB2457,0xA279,0x11d1,0x81,0xC6,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDX2D,0x9EFD02A9,0xA996,0x11d1,0x81,0xC9,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXGradient2,0xd0ef2a80,0x61dc,0x11d2,0xb2,0xeb,0x00,0xa0,0xc9,0x36,0xb2,0x12);


MIDL_DEFINE_GUID(IID, IID_IDXWarp,0xB7BCEBE0,0x6797,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_IDXTClipOrigin,0xEE1663D8,0x0988,0x4C48,0x9F,0xD6,0xDB,0x44,0x50,0x88,0x56,0x68);


MIDL_DEFINE_GUID(IID, LIBID_DXTRANSPLib,0x527A4DA4,0x7F2C,0x11d2,0xB1,0x2D,0x00,0x00,0xF8,0x1F,0x59,0x95);


MIDL_DEFINE_GUID(CLSID, CLSID_DXWarp,0xE0EEC500,0x6798,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTLabel,0x54702535,0x2606,0x11D1,0x99,0x9C,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_DXRasterizer,0x8652CE55,0x9E80,0x11D1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DX2D,0x473AA80B,0x4577,0x11D1,0x81,0xA8,0x00,0x00,0xF8,0x75,0x57,0xDB);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\simpsons\blt.h ===
#ifndef _Blt_h
#define _Blt_h

// File:	Blt.h
// Author:	Michael Marr    (mikemarr)
//
// Description:
//    These are all of the blt routines that are available.  It is assumed
//  that clipping and parameter checking has already occurred.
//
// History:
// -@- 09/23/97 (mikemarr) copied to DXCConv from d2d\mmimage
// -@- 10/28/97 (mikemarr) added colorfill routines
// -@- 10/28/97 (mikemarr) added HasPixelFn/ColorFillFn arrays


#ifndef _PixInfo_h
#include "PixInfo.h"
#endif

typedef HRESULT (*ColorFillFn)(BYTE *pDstPixels, DWORD nDstPitch, 
						DWORD nWidth, DWORD nHeight, DWORD dwColor);

HRESULT	ColorFill8(		BYTE *pDstPixels, DWORD nDstPitch, 
						DWORD nWidth, DWORD nHeight, DWORD dwColor);
HRESULT	ColorFill16(	BYTE *pDstPixels, DWORD nDstPitch, 
						DWORD nWidth, DWORD nHeight, DWORD dwColor);
HRESULT	ColorFill24(	BYTE *pDstPixels, DWORD nDstPitch, 
						DWORD nWidth, DWORD nHeight, DWORD dwColor);
HRESULT	ColorFill32(	BYTE *pDstPixels, DWORD nDstPitch, 
						DWORD nWidth, DWORD nHeight, DWORD dwColor);

extern ColorFillFn g_rgColorFillFn[5];


typedef HRESULT (*HasPixelFn)(const BYTE *pSrcPixels, DWORD nSrcPitch, DWORD dwPixel, 
						DWORD nSrcWidth, DWORD nHeight, BOOL *pb);

HRESULT HasPixel8(		const BYTE *pSrcPixels, DWORD nSrcPitch, DWORD dwPixel,
						DWORD nSrcWidth, DWORD nHeight, BOOL *pb);
HRESULT HasPixel16(		const BYTE *pSrcPixels, DWORD nSrcPitch, DWORD dwPixel,
						DWORD nSrcWidth, DWORD nHeight, BOOL *pb);
HRESULT HasPixel24(		const BYTE *pSrcPixels, DWORD nSrcPitch, DWORD dwPixel,
						DWORD nSrcWidth, DWORD nHeight, BOOL *pb);
HRESULT HasPixel32(		const BYTE *pSrcPixels, DWORD nSrcPitch, DWORD dwPixel,
						DWORD nSrcWidth, DWORD nHeight, BOOL *pb);

extern HasPixelFn g_rgHasPixelFn[5];


//
// Regular Image Bltting
//
// Notes:
//    Notice we can do subrectangle bltting by adjusting the src & dst
//  pixel pointers before calling these routines.



// straight Blts
HRESULT BltFast(		const BYTE *pSrcPixels, DWORD nSrcPitch,
						BYTE *pDstPixels, DWORD nDstPitch, 
						DWORD nSrcWidth, DWORD nHeight);

HRESULT BltFastMirrorY(	const BYTE *pSrcPixels, DWORD nSrcPitch,
						BYTE *pDstPixels, DWORD nDstPitch, 
						DWORD nSrcWidth, DWORD nHeight);

HRESULT BltFastRGBToRGB(const BYTE *pSrcPixels, DWORD nSrcPitch,
						BYTE *pDstPixels, DWORD nDstPitch, 
						DWORD nWidth, DWORD nHeight,
						const CPixelInfo &pixiSrc, const CPixelInfo &pixiDst);

HRESULT BltFast24To16(	const BYTE *pSrcPixels, DWORD nSrcPitch,
						BYTE *pDstPixels, DWORD nDstPitch, 
						DWORD nWidth, DWORD nHeight,
						const CPixelInfo &pixiSrc, const CPixelInfo &pixiDst);

HRESULT BltFast32To32(	const BYTE *pSrcPixels, DWORD nSrcPitch,
						BYTE *pDstPixels, DWORD nDstPitch, 
						DWORD nWidth, DWORD nHeight,
						const CPixelInfo &pixiSrc, const CPixelInfo &pixiDst);

HRESULT BltFast24To32(	const BYTE *pSrcPixels, DWORD nSrcPitch,
						BYTE *pDstPixels, DWORD nDstPitch, 
						DWORD nWidth, DWORD nHeight,
						const CPixelInfo &pixiSrc, const CPixelInfo &pixiDst);

HRESULT BltFast8To4(	const BYTE *pSrcPixels, DWORD nSrcPitch,
						BYTE *pDstPixels, DWORD nDstPitch,
						DWORD nWidth, DWORD nHeight, DWORD nOffset);

HRESULT BltFast8To2(	const BYTE *pSrcPixels, DWORD nSrcPitch,
						BYTE *pDstPixels, DWORD nDstPitch,
						DWORD nWidth, DWORD nHeight, DWORD nOffset);

HRESULT BltFast8To1(	const BYTE *pSrcPixels, long nSrcPitch,
						BYTE *pDstPixels, long nDstPitch,
						DWORD nWidth, DWORD nHeight, DWORD nOffset);

// color key blt
HRESULT BltFast8CK(		const BYTE *pSrcPixels, DWORD nSrcPitch,
						BYTE *pDstPixels, DWORD nDstPitch, 
						DWORD nSrcWidth, DWORD nHeight, DWORD dwTrans);

// translation Blts
HRESULT BltFast8To8T(	const BYTE *pSrcPixels, long nSrcPitch,
						BYTE *pDstPixels, long nDstPitch,
						DWORD nWidth, DWORD nHeight,
						const BYTE *pIndexMap);
HRESULT BltFast8To16T(	const BYTE *pSrcPixels, long nSrcPitch,
						BYTE *pDstPixels, long nDstPitch,
						DWORD nWidth, DWORD nHeight,
						const BYTE *pIndexMap);
HRESULT BltFast8To24T(	const BYTE *pSrcPixels, long nSrcPitch,
						BYTE *pDstPixels, long nDstPitch,
						DWORD nWidth, DWORD nHeight,
						const BYTE *pIndexMap);
HRESULT BltFast8To32T(	const BYTE *pSrcPixels, long nSrcPitch,
						BYTE *pDstPixels, long nDstPitch,
						DWORD nWidth, DWORD nHeight,
						const BYTE *pIndexMap);

//
// RLE Bltting
// Notes:
//    RLE is assumed to encode transparency as the zeroth index.
//
// straight Blts
HRESULT BltFastRLE8(DWORD nXPos, DWORD nYPos,
					const BYTE *pSrcPixels, long nSrcPitch,
					BYTE *pDstPixels, long nDstPitch,
					const LPRECT prSrcRect);

// translation Blts
HRESULT BltFastRLE8To8T(DWORD nXPos, DWORD nYPos,
						const BYTE *pSrcPixels, long nSrcPitch,
						BYTE *pDstPixels, long nDstPitch,
						const LPRECT prSrcRect, const BYTE *pIndexMap);
HRESULT BltFastRLE8To16T(DWORD nXPos, DWORD nYPos,
						const BYTE *pSrcPixels, long nSrcPitch,
						BYTE *pDstPixels, long nDstPitch,
						const LPRECT prSrcRect, const BYTE *pIndexMap);
HRESULT BltFastRLE8To24T(DWORD nXPos, DWORD nYPos,
						const BYTE *pSrcPixels, long nSrcPitch,
						BYTE *pDstPixels, long nDstPitch,
						const LPRECT prSrcRect, const BYTE *pIndexMap);
HRESULT BltFastRLE8To32T(DWORD nXPos, DWORD nYPos,
						const BYTE *pSrcPixels, long nSrcPitch,
						BYTE *pDstPixels, long nDstPitch,
						const LPRECT prSrcRect, const BYTE *pIndexMap);

// Function: WriteXBitRow
//    These functions pack bytes into bit streams.  Buffers with
//  a bit count <= sizeof(unsigned char) are passed as a buffer 
//  of unsigned char's, buffers with a bit count <= sizeof(unsigned
//  short) are passed as unsigned short, etc.
//void *Write4BitRow(void *pDst, const void *pSrc, unsigned int cCount);
//void *Write2BitRow(void *pDst, const void *pSrc, unsigned int cCount);
//void *Write1BitRow(void *pDst, const void *pSrc, unsigned int cCount);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\simpsons\guids.c ===
#include <objbase.h>
#include <initguid.h>
#include <DDrawEx.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\simpsons\mainfrm.cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "simpsons.h"

#include "MainFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

static UINT indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
	// TODO: add member initialization code here

}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}

	return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CFrameWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\simpsons\mdmutils.h ===
#ifndef _MDMUtils_h
#define _MDMUtils_h

// File:	MDMUtils.h
// Author:	Michael Marr    (mikemarr)
//
// Description:
//     This header contains miscellaneous utility functions.
// 
// History:
// -@- 08/04/95 (mikemarr) - created
// -@- 09/09/97 (mikemarr) - snarfed from d2d\d2dutils\src\mmutils.cpp
// -@- 09/09/97 (mikemarr) - will only create code when in debug mode
// -@- 11/12/97 (mikemarr) - added CopyDWORDAligned

#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <memory.h>

#define nTMPBUFSIZE 1024
extern char g_rgchTmpBuf[nTMPBUFSIZE];

#if defined(_WINDOWS) || defined(WIN32)
	#ifndef _INC_WINDOWS
		#define WIN32_EXTRA_LEAN
		#define WIN32_LEAN_AND_MEAN
		#include <WINDOWS.H>
	#endif
#endif

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif
#ifndef FALSE
#define FALSE false
#endif
#ifndef TRUE
#define TRUE true
#endif
#ifndef IN
#define IN
#endif
#ifndef OUT
#define OUT
#endif
#ifndef INOUT
#define INOUT
#endif

#ifndef BOOL
typedef int BOOL;
typedef BOOL far *LPBOOL;
#endif
#ifndef BYTE
typedef unsigned char BYTE;
typedef BYTE far *LPBYTE;
#endif
#ifndef WORD
typedef unsigned short WORD;
typedef WORD far *LPWORD;
#endif
#ifndef DWORD
typedef unsigned long DWORD;
typedef DWORD far *LPDWORD;
#endif
#ifndef LPVOID
typedef void far *LPVOID;
#endif

#define maskBYTE	0xFF
#define maskWORD	0xFFFF
#define maskDWORD	0xFFFFFFFF

#define maxBYTE		0xFF
#define maxWORD		0xFFFF
#define maxDWORD	0xFFFFFFFF


#define chSPC ' '
#define chTAB '	'
#define chEOL '\0'
#define chNULL '\0'
#define chLINEFEED 0x0D
#define chCARRIAGERETURN 0x0A

#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif

#define MACSTART do {
#define MACEND } while(0)

// Macro: ISWAP
//    This macro swaps two integer registers using 3 xor's.
//  This is unsafe because a & b are not guaranteed to get 2 regs.
#define ISWAP(a,b) MACSTART (a)^=(b); (b)^=(a); (a)^=(b); MACEND

// Macro: PSWAP
//    This macro swaps two pointers in place using 3 xor's.
#define PSWAP(a,b,type) MACSTART \
	a = (type *)(int(a) ^ int(b)); \
	b = (type *)(int(a) ^ int(b)); \
	a = (type *)(int(a) ^ int(b)); \
MACEND

#define MMINITSTRUCT(__s) memset(&(__s), 0, sizeof(__s))

#ifndef ZERO_DXSTRUCT
#define ZERO_DXSTRUCT(__dxstruct) MACSTART \
	MMINITSTRUCT(__dxstruct); (__dxstruct).dwSize = sizeof(__dxstruct); MACEND
#endif
#ifndef INIT_DXSTRUCT
#define INIT_DXSTRUCT(__dxstruct) MACSTART \
	MMINITSTRUCT(__dxstruct); (__dxstruct).dwSize = sizeof(__dxstruct); MACEND
#endif

#ifdef DBG
#define CHECK_HR(__hr) MACSTART if (FAILED(__hr)) { printf("%s(%d): CHECK_HR failed (0x%X)\n", __FILE__, __LINE__, hr); goto e_Exit; } MACEND
#else
#define CHECK_HR(__hr) MACSTART if (FAILED(__hr)) goto e_Exit; MACEND
#endif
#define CHECK_MEM(__p) MACSTART if ((__p) == NULL) { hr = E_OUTOFMEMORY; goto e_Exit; } MACEND

#define INRANGE(x, xmin, xmax) 	(((x) >= (xmin)) && ((x) <= (xmax)))
#define INARRAY(x, xmax) 		(((x) >= 0) && ((x) < (xmax)))

#define SETABS(x)					MACSTART if ((x) < 0) (x) = -(x); MACEND
#define SETMAX(dst, src1, src2)		MACSTART if ((src1) < (src2)) (dst) = (src2); else (dst) = (src1); MACEND
#define SETMIN(dst, src1, src2)		MACSTART if ((src1) > (src2)) (dst) = (src2); else (dst) = (src1); MACEND
#define UPDATEMAX(dst, src)			MACSTART if ((src) > (dst)) (dst) = (src); MACEND
#define UPDATEMIN(dst, src)			MACSTART if ((src) < (dst)) (dst) = (src); MACEND
#define UPDATEMINMAX(xmin, xmax, x) MACSTART if ((x) < (xmin)) (xmin) = (x); else if ((x) > (xmax)) (xmax) = (x); MACEND
#define CLAMPMAX(x, xmax)			MACSTART if ((x) > (xmax)) (x) = (xmax); MACEND
#define CLAMPMIN(x, xmin)			MACSTART if ((x) < (xmin)) (x) = (xmin); MACEND
#define CLAMP(x, xmin, xmax) MACSTART \
	if ((x) > (xmax)) (x) = (xmax); \
	else if ((x) < (xmin)) (x) = (xmin); \
MACEND

//
// BIT MANIPULATION: BitVector
//
// **Hungarian Prefix: bv
typedef unsigned int BitVector;

#define NUMBITS(Type)	(sizeof(Type) << 3)
// Macro: MASKRANGE
//    Create a bit mask in the specified range, where the lo value is inclusive, and the
//  hi value is exclusive.
//  For example, MASKRANGE(8, 16) == 0x0000FF00.
#define MASKRANGE(lo, hi) \
(((((BitVector) ~0) >> (lo)) << ((lo) + (NUMBITS(BitVector) - (hi)))) >> (NUMBITS(BitVector) - (hi)))
#define SETBIT(bv, i) ((bv) |= (((BitVector) 1) << (i)))
#define UNSETBIT(bv, i) ((bv) &= ~(((BitVector) 1) << (i)))
#define SETRANGE(bv, lo, hi) ((bv) |= MASKRANGE(lo, hi))
#define UNSETRANGE(bv, lo, hi) ((bv) &= ~MASKRANGE(lo, hi))

#define SETFLAG(_dwFlags, _flag, _b) MACSTART if (_b) _dwFlags |= _flag; else _dwFlags &= ~_flag; MACEND

//
// DEBUG STUFF
//
#ifndef __AFX_H__
	#ifdef _DEBUG
		void _MMStall(const char *szExp, const char *szFile, int nLine);
		void _MMTrace(const char *szFmt, ...);

		#define MMASSERT(exp)		(void)((exp) || (_MMStall(#exp, __FILE__, __LINE__),0))
		#define MMASSERT_VALID(exp)	MMASSERT(exp)
		#define MMVERIFY(exp)		MMASSERT(exp)
		#define MMDEBUG_ONLY(exp)	(exp)
		#define MMTRACE				::_MMTrace
	#else
//		void _MMIgnore(const char *szFmt, ...) {}
		#define MMASSERT(exp)		((void)0)
		#define MMASSERT_VALID(exp)	((void)0)
		#define MMVERIFY(exp)		((void)(exp))
		#define MMDEBUG_ONLY(exp)	((void)0)
		#define MMTRACE				1 ? (void)0 : ::printf
	#endif
#else
	#define MMASSERT(exp)		ASSERT(exp)
	#define MMASSERT_VALID(exp)	ASSERT_VALID(exp)
	#define MMVERIFY(exp)		VERIFY(exp)
	#define MMDEBUG_ONLY(exp)	DEBUG_ONLY(exp)
	#define MMTRACE				TRACE
#endif

// Macro: MMRELEASE
//    Safe release for COM objects
// ***this code should never change - there is stuff that relies on the pointer being
//    set to NULL after being released
#ifndef MMRELEASE
#define MMRELEASE(_p) MACSTART if ((_p) != NULL) {(_p)->Release(); (_p) = NULL;} MACEND
#endif

#define MMDELETE(__ptr) MACSTART delete (__ptr); (__ptr) = NULL; MACEND
#define MMDELETERG(__ptr) MACSTART delete [] (__ptr); (__ptr) = NULL; MACEND

#define MMSETREF(_pOld, _pNew) MACSTART if (_pOld) (_pOld)->Release(); if ((_pOld) = (_pNew)) (_pOld)->AddRef(); MACEND

#define MAKE_USERERROR(code)	MAKE_HRESULT(1,FACILITY_ITF,code)

#define E_NOTINITIALIZED		MAKE_USERERROR(0xFFFC)
#define E_ALREADYINITIALIZED	MAKE_USERERROR(0xFFFB)
#define E_NOTFOUND				MAKE_USERERROR(0xFFFA)
#define E_INSUFFICIENTDATA		MAKE_USERERROR(0xFFF9)

extern char g_szEOFMessage[];

// Macro for memory mapped file stuff
#define CHECKEOF(__pFilePos, __pFileLimit) MACSTART \
	if ((__pFilePos) >= (__pFileLimit)) { \
		MMTRACE(g_szEOFMessage); \
		return E_UNEXPECTED; \
	} MACEND


void		ZeroDWORDAligned(LPDWORD pdw, DWORD cEntries);
void		CopyDWORDAligned(DWORD *pdwDst, const DWORD *pdwSrc, DWORD cEntries);

inline void
ZeroPointers(void **ppv, DWORD cEntries)
{
	// use a Duff-Marr machine
	void **ppvLimit = ppv;
	ppv += (cEntries & ~0x7);
	switch (cEntries & 0x7) {
	do {
				ppv -= 8;
				ppv[7] = NULL;
		case 7:	ppv[6] = NULL;
		case 6:	ppv[5] = NULL;
		case 5:	ppv[4] = NULL;
		case 4:	ppv[3] = NULL;
		case 3:	ppv[2] = NULL;
		case 2:	ppv[1] = NULL;
		case 1:	ppv[0] = NULL;
		case 0: ;
	} while (ppv != ppvLimit);
	}
}

DWORD		GetClosestMultipleOf4(DWORD n, bool bGreater);
DWORD		GetClosestPowerOf2(DWORD n, bool bGreater);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\simpsons\palmap.cpp ===
// File:    PalMap.cpp
// Author:  Michael Marr    (mikemarr)
//
// History:
// -@- 09/23/97 (mikemarr) copied to DXCConv from d2d\mmimage

#include "stdafx.h"
#include "PalMap.h"
#include "Blt.h"
#include "ddhelper.h"

char gs_szPMPrefix[] = "palette map error";


CPaletteMap::CPaletteMap()
{
    m_rgIndexMap = NULL;
    m_nConvertCode = cvcInvalid;
    m_cSrcBPP = m_cDstBPP = 0;
    m_bIdentity = FALSE;
}

CPaletteMap::~CPaletteMap()
{
    MMDELETE(m_rgIndexMap);
}

// Function: CreateMap
//    This function creates a new mapping from a src palette to a destination color model.
HRESULT
CPaletteMap::CreateMap(BYTE nBPPSrcPixels, BYTE nBPPSrcPalette, LPPALETTEENTRY rgpeSrc, 
                       const CPixelInfo &pixiDst, LPDIRECTDRAWPALETTE pddpDst)
{
    MMTRACE("CPaletteMap::CreateMap\n");
    HRESULT hr;
    PALETTEENTRY rgpeDst[256];
    DWORD dwDstCaps;

    // verify arguments
    if (rgpeSrc == NULL)
        return E_INVALIDARG;

    // delete the old index map, if it exists
    MMDELETE(m_rgIndexMap);

    // store the bit depths for mapping verification
    // REVIEW: perhaps the maps should be created with at least 256 entries always
    m_cSrcBPP = nBPPSrcPixels;
    m_cDstBPP = pixiDst.nBPP;

    // figure out what kind of conversion we are doing
    if ((m_nConvertCode = static_cast<BYTE>(GetConvertCode(m_cSrcBPP, m_cDstBPP))) == cvcInvalid) {
        MMTRACE("%s: can't convert from %d bit to %d bit\n", 
            gs_szPMPrefix, (int) m_cSrcBPP, (int) m_cDstBPP);
        return E_INVALIDARG;
    }

    if (pddpDst == NULL) {
        // destination is RGB
        switch (m_cDstBPP) {
        case 16: return DoPalTo16BitMap(nBPPSrcPalette, pixiDst, rgpeSrc); break;
        case 24: return DoPalTo24BitMap(nBPPSrcPalette, pixiDst, rgpeSrc); break;
        case 32: return DoPalTo32BitMap(nBPPSrcPalette, pixiDst, rgpeSrc); break;
        default:
            return E_INVALIDARG;
            break;
        }
    } else {
        // destination is 8 bit palettized
        hr = E_INVALIDARG;
        if ((m_cDstBPP != 8) ||
            // get the caps
            FAILED(pddpDst->GetCaps(&dwDstCaps)) ||
            // verify we have True Color entries
            (dwDstCaps & DDPCAPS_8BITENTRIES) ||
            // make sure the number of palette entries from the caps is 8 bits
            (!(dwDstCaps & DDPCAPS_8BIT)) ||
            // get the palette entries
            FAILED(hr = pddpDst->GetEntries(0, 0, 1 << m_cDstBPP, rgpeDst)))
        {
            MMTRACE("%s: invalid dst palette for map\n", gs_szPMPrefix);
            return hr;
        }
        // create map for palette to palette
        return DoPalToPalMap(nBPPSrcPalette, m_cDstBPP, rgpeSrc, rgpeDst);
    }
}


HRESULT
CPaletteMap::CreateMap(LPDIRECTDRAWPALETTE pddpSrc, const CPixelInfo &pixiDst, 
                       LPDIRECTDRAWPALETTE pddpDst)
{
//  MMTRACE("CPaletteMap::CreateMap\n");
    PALETTEENTRY rgpeSrc[256];
    BYTE nBPPSrc;
    DWORD dwSrcCaps;

    // sanitize the src palette and get the srcBPP
    HRESULT hr = E_INVALIDARG;
    if ((pddpSrc == NULL) ||
        // get the caps
        FAILED(pddpSrc->GetCaps(&dwSrcCaps)) ||
        // verify we have True Color entries
        (dwSrcCaps & DDPCAPS_8BITENTRIES) ||
        // get the number of palette entries from the caps
        ((nBPPSrc = BYTE(PaletteFlagsToBPP(dwSrcCaps))) == 0) ||
        // get the palette entries
        FAILED(hr = pddpSrc->GetEntries(0, 0, (1 << nBPPSrc), rgpeSrc)))
    {
        MMTRACE("%s: invalid src palette for map\n", gs_szPMPrefix);
        return hr;
    }

    return CreateMap(nBPPSrc, nBPPSrc, rgpeSrc, pixiDst, pddpDst);
}


/*
HRESULT
CPaletteMap::CreateSortedMap(BYTE nBPP, const RGB *rgrgbSrc, BYTE nBPPUsed, DWORD iTransColor, 
                             DWORD dwFlags, LPPALETTEENTRY rgpeDst)
{
    MMTRACE("CPaletteMap::CreateSortedMap\n");
    MMASSERT(nBPP <= nBPPUsed);
    DWORD i, j, imin;

    if ((rgrgbSrc == NULL) || (nBPPUsed > 8))
        return E_INVALIDARG;

    struct {
        DWORD   nPos;
        int     nLuminance;
    } rgSortMap[nMAXPALETTEENTRIES], minLuminance;

    // allocate the index map
    MMDELETE(m_rgIndexMap);

    m_rgIndexMap = (BYTE *) new BYTE[1 << nBPPUsed];
    if (m_rgIndexMap == NULL)
        return E_OUTOFMEMORY;

    m_nConvertCode = GetConvertCode(nBPPUsed, nBPPUsed);
    MMASSERT(m_nConvertCode == cvc8To8);
    m_cSrcBPP = nBPPUsed;
    m_cDstBPP = nBPPUsed;
//  m_pixiDst.Init(nBPPUsed);

    // initialize the sort map (compute luminance values)
    DWORD cMapLength = (1 << nBPP), cTotalEntries = (1 << nBPPUsed);
    for (i = 0; i < cMapLength; i++) {
        const RGB &rgbTmp = rgrgbSrc[i];
        rgSortMap[i].nPos = i;
        rgSortMap[i].nLuminance = nREDWEIGHT * rgbTmp.r + nGREENWEIGHT * rgbTmp.g + 
            nBLUEWEIGHT * rgbTmp.b;
    }

    // if transparency exists, change its luminance to -1 so it will
    // become the zeroth index
    if (dwFlags & flagTRANSPARENT) {
        if (iTransColor > cMapLength)
            return E_INVALIDARG;
        rgSortMap[iTransColor].nLuminance = -1;
    }

    // sort the entries by luminance
    // REVIEW: use naive insertion sort for now
    for (i = 0; i < cMapLength; i++) {
        imin = i;
        minLuminance = rgSortMap[imin];

        for (j = i + 1; j < cMapLength; j++) {
            if (minLuminance.nLuminance > rgSortMap[j].nLuminance) {
                imin = j;
                minLuminance = rgSortMap[imin];
            }
        }
        rgSortMap[imin] = rgSortMap[i];
        rgSortMap[i] = minLuminance;
    }

    // fill in the index map (sorting generates an "inverse" map)
    for (i = 0; i < cMapLength; i++) {
        m_rgIndexMap[rgSortMap[i].nPos] = (BYTE) i;
    }
    for (; i < cTotalEntries; i++)
        m_rgIndexMap[i] = (BYTE) i;


    // sort to a palette entry array based on this mapping
    if (rgpeDst) {
        for (i = 0; i < cMapLength; i++) {
            PALETTEENTRY &pe = rgpeDst[i];
            const RGB &rgb = rgrgbSrc[rgSortMap[i].nPos];
            pe.peRed = rgb.r; pe.peGreen = rgb.g; pe.peBlue = rgb.b; pe.peFlags = 0;
        }
        PALETTEENTRY peZero = {0, 0, 0, 0};
        for (; i < cTotalEntries; i++)
            rgpeDst[i] = peZero;
    }

    return S_OK;
}
*/

HRESULT
CPaletteMap::DoPalTo16BitMap(BYTE cSrcBPP, const CPixelInfo &pixiDst, const PALETTEENTRY *ppeSrc)
{
    MMASSERT(ppeSrc);

    DWORD cEntries = (1 << cSrcBPP);
    MapEntry16 *pIndexMap = new MapEntry16[cEntries];
    if (pIndexMap == NULL)
        return E_OUTOFMEMORY;

    for (DWORD i = 0; i < cEntries; i++) {
        pIndexMap[i] = pixiDst.Pack16(ppeSrc[i]);
    }

    m_rgIndexMap = (BYTE *) pIndexMap;
    return S_OK;
}


HRESULT
CPaletteMap::DoPalTo24BitMap(BYTE cSrcBPP, const CPixelInfo &pixiDst, const PALETTEENTRY *ppeSrc)
{
    MMASSERT(ppeSrc);

    if ((pixiDst.nRedResidual | pixiDst.nGreenResidual | pixiDst.nBlueResidual) != 0)
        return DDERR_INVALIDPIXELFORMAT;

    DWORD cEntries = (1 << cSrcBPP);
    MapEntry24 *pIndexMap = new MapEntry24[cEntries];
    if (pIndexMap == NULL)
        return E_OUTOFMEMORY;

    for (DWORD i = 0; i < cEntries; i++) {
        pIndexMap[i] = pixiDst.Pack(ppeSrc[i]);
    }

    m_rgIndexMap = (BYTE *) pIndexMap;
    return S_OK;
}


HRESULT
CPaletteMap::DoPalTo32BitMap(BYTE cSrcBPP, const CPixelInfo &pixiDst, const PALETTEENTRY *ppeSrc)
{
    // REVIEW: since PALETTEENTRY does not have an alpha field, 
    //  this should be the same as 24 bit
    return DoPalTo24BitMap(cSrcBPP, pixiDst, ppeSrc);
}

// blue is assumed to have a weight of 1.f
#define fSimpleRedWeight 2.1f
#define fSimpleGreenWeight 2.4f
#define fMaxColorDistance ((1.f + fSimpleRedWeight + fSimpleGreenWeight) * float(257 * 256))

static inline float
_ColorDistance(const PALETTEENTRY &pe, BYTE r, BYTE g, BYTE b)
{
    float fTotal, fTmpR, fTmpG, fTmpB;
    fTmpR = (float) (pe.peRed - r);
    fTotal = fSimpleRedWeight * fTmpR * fTmpR;
    fTmpG = (float) (pe.peGreen - g);
    fTotal += fSimpleGreenWeight * fTmpG * fTmpG;
    fTmpB = (float) (pe.peBlue - b);
    // blue is assumed to have a weight of 1.f
    fTotal += fTmpB * fTmpB;

    return fTotal;
}

DWORD
_SimpleFindClosestIndex(const PALETTEENTRY *rgpePalette, DWORD cEntries, BYTE r, BYTE g, BYTE b)
{
    MMASSERT(rgpePalette);
    MMASSERT(cEntries <= nMAXPALETTEENTRIES);

    float fTmp, fMinDistance = fMaxColorDistance;
    DWORD nMinIndex = cEntries;

    for (DWORD i = 0; i < cEntries; i++) {
        const PALETTEENTRY &peTmp = rgpePalette[i];
        if (!(peTmp.peFlags & (PC_RESERVED | PC_EXPLICIT))) {
            if ((fTmp = _ColorDistance(peTmp, r, g, b)) < fMinDistance) {
                // check for exact match
                if (fTmp == 0.f)
                    return i;
                nMinIndex = i;
                fMinDistance = fTmp;
            }
        }
    }
    MMASSERT(nMinIndex < cEntries);
    return nMinIndex;
}


// Function: DoPalToPalMap
//    Compute a mapping from one palette to another and store in the palette map.
HRESULT
CPaletteMap::DoPalToPalMap(BYTE cSrcBPP, BYTE cDstBPP, const PALETTEENTRY *ppeSrc, 
                           const PALETTEENTRY *ppeDst)
{
    MMASSERT(ppeSrc && ppeDst);

    DWORD cSrcEntries = (1 << cSrcBPP), cDstEntries = (1 << cDstBPP);
    m_rgIndexMap = new BYTE[cSrcEntries];
    if (m_rgIndexMap == NULL)
        return E_OUTOFMEMORY;
    for (DWORD i = 0; i < cSrcEntries; i++) {
        const PALETTEENTRY &pe = ppeSrc[i];
        m_rgIndexMap[i] = (BYTE) _SimpleFindClosestIndex(ppeDst, cDstEntries, 
                                    pe.peRed, pe.peGreen, pe.peBlue);
    }

    return S_OK;
}


// Function: GetConvertCode
//    This function computes the index into the function arrays for
//  mapping and color conversion.
int
CPaletteMap::GetConvertCode(DWORD nSrcBPP, DWORD nDstBPP)
{
    int nCode;

    if ((nDstBPP < 8) || (nSrcBPP > 8) || (nSrcBPP < 4)) {
        nCode = cvcInvalid;
    } else {
        nCode = (((nSrcBPP >> 2) - 1) << 2) | ((nDstBPP >> 3) - 1);
    }
    return nCode;   
}


static DWORD
GetColor8To8(DWORD dwSrcColor, const BYTE *pIndexMap)
{
    MMASSERT(dwSrcColor < 256);
    return (DWORD) pIndexMap[dwSrcColor];
}

static DWORD
GetColor8To16(DWORD dwSrcColor, const BYTE *pIndexMap)
{
    MMASSERT(dwSrcColor < 256);
    MapEntry16 *pIndexMap16 = (MapEntry16 *) pIndexMap;
    return (DWORD) pIndexMap16[dwSrcColor];
}

static DWORD
GetColor8To24(DWORD dwSrcColor, const BYTE *pIndexMap)
{
    MMASSERT(dwSrcColor < 256);
    MapEntry24 *pIndexMap24 = (MapEntry24 *) pIndexMap;
    return (DWORD) pIndexMap24[dwSrcColor];
}

static DWORD
GetColor8To32(DWORD dwSrcColor, const BYTE *pIndexMap)
{
    MMASSERT(dwSrcColor < 256);
    MapEntry32 *pIndexMap32 = (MapEntry32 *) pIndexMap;
    return (DWORD) pIndexMap32[dwSrcColor];
}

static GetColorFunction gs_rgGetColorFunctions[cvcNumCodes] = {
    NULL, NULL, NULL, NULL,
    GetColor8To8, GetColor8To16, 
    GetColor8To24, GetColor8To32
};

DWORD
CPaletteMap::GetIndexMapping(DWORD iSrcColor) const
{
    MMASSERT((m_nConvertCode < cvcInvalid) && (gs_rgGetColorFunctions[m_nConvertCode] != NULL));
    return gs_rgGetColorFunctions[m_nConvertCode](iSrcColor, m_rgIndexMap);
}

// Notes:
//    The convert functions also fix the transparency on the destination objects.
//  A better way to do this stuff might be to have Blt functions and then separate
//  convert functions that cleanup the rest of the image after the Blt.
ConvertFunction g_rgConvertFunctions[cvcNumCodes] = {
    NULL, NULL, NULL, NULL,
    BltFast8To8T, BltFast8To16T, 
    BltFast8To24T, BltFast8To32T
};

// Function: BltFast
//    This function takes a src dds and writes a dst dds using the
//  mapping defined by the PaletteMap.  The src and dst can be the
//  same surface.
HRESULT 
CPaletteMap::BltFast(LPDIRECTDRAWSURFACE pddsSrc, LPRECT prSrc, LPDIRECTDRAWSURFACE pddsDst,
                     DWORD nXPos, DWORD nYPos, DWORD dwFlags) const
{
    if (m_rgIndexMap == NULL)
        return E_NOTINITIALIZED;

    // make sure the surfaces are valid
    if (!pddsSrc || !pddsDst) {
        return E_INVALIDARG;
    }

    ConvertFunction pfnConvertFunction;
    HRESULT hr = E_INVALIDARG;
    BOOL bSrcLocked = FALSE, bDstLocked = FALSE;
    DDSURFACEDESC ddsdSrc, ddsdDst;
    INIT_DXSTRUCT(ddsdSrc);
    INIT_DXSTRUCT(ddsdDst);
    long nWidth, nHeight;

    //
    // Lock the surfaces
    //
    if (pddsSrc == pddsDst) {
        // REVIEW: this lock could just lock the minimum rectangle...
        if (FAILED(hr = pddsDst->Lock(NULL, &ddsdDst, DDLOCK_WAIT, NULL))) {
            goto e_Convert;
        }
        bSrcLocked = bDstLocked = TRUE;
        // copy the dst info into the src info
        ddsdSrc = ddsdDst;
    } else {

        // REVIEW: this lock could just lock the minimum rectangle...
        if (FAILED(hr = pddsSrc->Lock(NULL, &ddsdSrc, DDLOCK_WAIT, NULL)))
            goto e_Convert;
        bSrcLocked = TRUE;
        if (FAILED(hr = pddsDst->Lock(NULL, &ddsdDst, DDLOCK_WAIT, NULL)))
            goto e_Convert;
        bDstLocked = TRUE;
    }

    // verify the image information
    if ((ddsdSrc.ddpfPixelFormat.dwRGBBitCount != m_cSrcBPP) ||
        (ddsdDst.ddpfPixelFormat.dwRGBBitCount != m_cDstBPP)) {
        hr = E_INVALIDARG;
        goto e_Convert;
    }

    //
    // clip 
    //
    long nClipWidth, nClipHeight, nLeft, nTop;
    if (prSrc == NULL) {
        nWidth = ddsdSrc.dwWidth;
        nHeight = ddsdSrc.dwHeight;
        nLeft = 0;
        nTop = 0;
    } else {
        nWidth = prSrc->right - prSrc->left;
        nHeight = prSrc->bottom - prSrc->top;
        nLeft = prSrc->left;
        nTop = prSrc->top;
    }
    nClipWidth = long(ddsdDst.dwWidth - nXPos);
    nClipHeight = long(ddsdDst.dwHeight - nYPos);
    UPDATEMAX(nClipWidth, 0);
    UPDATEMAX(nClipHeight, 0);
    UPDATEMAX(nWidth, 0);
    UPDATEMAX(nHeight, 0);
    UPDATEMAX(nLeft, 0);
    UPDATEMAX(nTop, 0);
    UPDATEMIN(nClipWidth, nWidth);
    UPDATEMIN(nClipHeight, nHeight);
    if (((nLeft + nClipWidth) > long(ddsdSrc.dwWidth)) ||
        ((nTop + nClipHeight) > long(ddsdSrc.dwHeight))) {
        hr = E_INVALIDARG;
        goto e_Convert;
    }

    // REVIEW: for now, fail if we are not dealing with at least 8BPP
    if ((ddsdSrc.ddpfPixelFormat.dwRGBBitCount < 8) || (ddsdDst.ddpfPixelFormat.dwRGBBitCount < 8)) {
        hr = E_FAIL;
        goto e_Convert;
    }
        
    nLeft *= (ddsdSrc.ddpfPixelFormat.dwRGBBitCount >> 3);
    nXPos *= (ddsdDst.ddpfPixelFormat.dwRGBBitCount >> 3);

    pfnConvertFunction = g_rgConvertFunctions[m_nConvertCode];
    if (pfnConvertFunction) {
        hr = pfnConvertFunction(
            LPBYTE(ddsdSrc.lpSurface) + nLeft + (nTop * ddsdSrc.lPitch),
            ddsdSrc.lPitch,
            LPBYTE(ddsdDst.lpSurface) + nXPos + (nYPos * ddsdDst.lPitch),
            ddsdDst.lPitch,
            nClipWidth,
            nClipHeight,
            m_rgIndexMap);
    } else {
        hr = E_NOTIMPL;
        goto e_Convert;
    }

e_Convert:
    // unlock the surfaces
    if (pddsSrc == pddsDst) {
        if (bSrcLocked)
            pddsDst->Unlock(ddsdDst.lpSurface);
    } else {
        if (bDstLocked)
            pddsDst->Unlock(ddsdDst.lpSurface);
        if (bSrcLocked)
            pddsSrc->Unlock(ddsdSrc.lpSurface);
    }

    MMASSERT(SUCCEEDED(hr));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\simpsons\mdmutils.cpp ===
// File:	MMUtils.cpp
// Author:	Michael Marr    (mikemarr)
//
// History:
// -@- 04/12/96 (mikemarr) - created
// -@- 11/07/96 (mikemarr) - combined debug stuff
// -@- 09/09/97 (mikemarr) - snarfed from d2d\d2dutils\src\mmutils.cpp
// -@- 09/09/97 (mikemarr) - will only create code when in debug mode
// -@- 11/12/97 (mikemarr) - added CopyDWORDAligned

#include "stdafx.h"
#ifndef _MDMUtils_h
#include "MDMUtils.h"
#endif

char g_rgchTmpBuf[nTMPBUFSIZE];
char g_szEOFMessage[] = "unexpected EOF\n";

void
ZeroDWORDAligned(LPDWORD pdw, DWORD cEntries)
{
	// verify alignment
	MMASSERT(pdw && ((DWORD(pdw) & 0x3) == 0));
	LPDWORD pdwLimit = pdw + cEntries;
	// REVIEW: use Duff-Marr machine
	for (; pdw != pdwLimit; *pdw++ = 0);
}

void
CopyDWORDAligned(DWORD *pdwDst, const DWORD *pdwSrc, DWORD cEntries)
{
	// verify alignment
	MMASSERT(pdwSrc && pdwDst && ((DWORD(pdwSrc) & 0x3) == 0));
	LPDWORD pdwLimit = pdwDst + cEntries;
	// REVIEW: use Duff-Marr machine
	for (; pdwDst != pdwLimit; *pdwDst++ = *pdwSrc++);
}



DWORD
GetClosestMultipleOf4(DWORD n, bool bGreater)
{
	return (n + bGreater * 3) & ~3;
}


DWORD
GetClosestPowerOf2(DWORD n, bool bGreater)
{
	DWORD i = 0;
	for (n >>= 1; n != 0; i++) {
		n >>= 1;
	}
	i += (bGreater && ((n & ~(1 << i)) != 0));

	return (1 << i);
}


//
// Debug Stuff
//
#ifdef _DEBUG
void _MMStall(const char *szExp, const char *szFile, int nLine) {
	sprintf(g_rgchTmpBuf, "error: (%s) in %s at line %d\n", szExp, szFile, nLine);

#ifdef _WINDOWS
	OutputDebugString(g_rgchTmpBuf);
#endif
	fprintf(stderr, "%s", g_rgchTmpBuf);

	// hardcode breakpoint
#if defined(_DEBUG) && defined(_X86_)
	_asm { int 3 };
#else
	exit(1);
#endif
}

void _MMTrace(const char *szFmt, ...)
{
#ifndef _NOT_X86
	_vsnprintf(g_rgchTmpBuf, nTMPBUFSIZE - 1, szFmt, (va_list) (&szFmt+1));

#if defined(_WINDOWS) && defined(_DEBUG)
	OutputDebugString(g_rgchTmpBuf);
#else
	fprintf(stderr, "%s", g_rgchTmpBuf);
#endif
#endif // _NOT_X86
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\simpsons\mainfrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__7CA4916A_71B3_11D1_AA67_00600814AAE9__INCLUDED_)
#define AFX_MAINFRM_H__7CA4916A_71B3_11D1_AA67_00600814AAE9__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CMainFrame : public CFrameWnd
{
protected: // create from serialization only
	CMainFrame();
	DECLARE_DYNCREATE(CMainFrame)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CStatusBar  m_wndStatusBar;
	CToolBar    m_wndToolBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__7CA4916A_71B3_11D1_AA67_00600814AAE9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\simpsons\parse.h ===
#ifndef _Parse_h
#define _Parse_h

// File:    Parse.h
// Author:  Michael Marr    (mikemarr)
//
// History:
// -@- 09/23/97 (mikemarr) copied from projects\vector2d

#include "DXTransP.h"

#define nMAXPOINTS  (1 << 16)
#define nMAXPOLYS   (1 << 14)
#define nMAXBRUSHES (1 << 14)
#define nMAXPENS    16

#define typePOLY    0
#define typeBRUSH   1
#define typePEN     2
#define typeSTOP    4
typedef struct RenderCmd {
    DWORD       nType;
    void *      pvData;
} RenderCmd;

typedef struct BrushInfo {
    DXSAMPLE    Color;
} BrushInfo;

typedef struct PenInfo {
    DXSAMPLE    Color;
    float       fWidth;
    DWORD       dwStyle;
} PenInfo;

typedef struct PolyInfo {
    DXFPOINT *  pPoints;
    BYTE *      pCodes;
    DWORD       cPoints;
    DWORD       dwFlags;
} PolyInfo;

HRESULT     ParseAIFile(const char *szFilename, RenderCmd **ppCmds);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\simpsons\parse.cpp ===
// File:	Parse.cpp
// Author:	Michael Marr    (mikemarr)
//
// History:
// -@- 09/23/97 (mikemarr) copied from projects\vector2d

#include "StdAfx.h"
#include "Parse.h"

#define fGSCALE 1.f

class CAdobeFormatConverter {
public:
					CAdobeFormatConverter();
					~CAdobeFormatConverter() {}
	HRESULT			Parse(const char *pData, DWORD nFileLength, RenderCmd **ppCmds);

private:
	HRESULT			ParseProlog();
	HRESULT			ParseScript();
	HRESULT			ParseSetup();
	HRESULT			ParseObjects();
	HRESULT			ParseCompoundPath();
	HRESULT			ParsePath();
	HRESULT			ParsePaintStyle(const char *&pEnd);
	HRESULT			ParsePathGeometry(const char *pEnd);
	HRESULT			ParseTrailers();

private:
	void			EatLine();
	const char *	FindNextLine(const char *pch);
	const char *	FindLF(const char *pch);
	const char *	FindSpace(const char *pch);

private:
	const char *	m_pData, *m_pLimit;
	float			m_fWidth, m_fHeight;
//	float			m_fMaxHeight;
	bool			m_bNoBrush, m_bNoPen;

	DXFPOINT		m_rgPoints[nMAXPOINTS];
	DXFPOINT *		m_pCurPoint;
	BYTE			m_rgCodes[nMAXPOINTS];
	BYTE *			m_pCurCode;
	RenderCmd		m_rgRenderCmds[nMAXPOLYS];
	RenderCmd *		m_pCurRenderCmd;
	PolyInfo		m_rgPolyInfos[nMAXPOLYS];
	PolyInfo *		m_pCurPolyInfo;
	BrushInfo		m_rgBrushInfos[nMAXBRUSHES];
	BrushInfo *		m_pCurBrushInfo;
	PenInfo			m_rgPenInfos[nMAXPENS];
	PenInfo *		m_pCurPenInfo;
};

inline bool
mmIsSpace(char ch)
{
	return ((ch == ' ') || (ch == chLINEFEED) || (ch == chCARRIAGERETURN));
//	return isspace(ch) != 0;
}

inline bool
mmIsDigit(char ch)
{
	return ((ch >= '0') && (ch <= '9'));
//	return isdigit(ch) != 0;
}

float
mmSimpleAtoF(const char *&pData)
{
	const char *pSrc = pData;

	// eat white space
	while (mmIsSpace(*pSrc)) pSrc++;

	bool bNeg;
	if (*pSrc == '-') {
		bNeg = true;
		pSrc++;
	} else {
		bNeg = false;
	}

	// get digits before the decimal point
	float f;
	if (mmIsDigit(*pSrc)) {
		f = float(*pSrc++ - '0');
		
		while (mmIsDigit(*pSrc))
			f = f * 10.f + float(*pSrc++ - '0');
	} else {
		f = 0.f;
	}
	if (*pSrc == '.') 
		pSrc++;

	// get digits after the decimal point
	float fDec = 0.1f;
	while (mmIsDigit(*pSrc)) {
		f += (float(*pSrc++ - '0') * fDec);
		fDec *= 0.1f;
	}

	// REVIEW: assume no exponent for now

	pData = pSrc;

	return (bNeg ? -f : f);
}


inline const char *
CAdobeFormatConverter::FindLF(const char *pch)
{
	// find the linefeed character
	while ((*pch != chLINEFEED) && (*pch != chCARRIAGERETURN)) pch++;

	MMASSERT(pch <= m_pLimit);

	return pch;
}

inline const char *
CAdobeFormatConverter::FindNextLine(const char *pch)
{
	// find the linefeed character
	while (*pch++ != chLINEFEED);

	// check if there is also carriage return
	if (*pch == chCARRIAGERETURN)
		pch++;

	MMASSERT(pch <= m_pLimit);

	return pch;
}

inline const char *
CAdobeFormatConverter::FindSpace(const char *pch)
{
	// find the linefeed character
	while (!mmIsSpace(*pch)) pch++;

	MMASSERT(pch <= m_pLimit);

	return pch;
}


inline void
CAdobeFormatConverter::EatLine()
{
	m_pData = FindNextLine(m_pData);
}

CAdobeFormatConverter::CAdobeFormatConverter()
{
	m_pData = m_pLimit = NULL;
	m_fWidth = m_fHeight = 0.f;
//	m_fMaxHeight = 0.f;
	m_bNoBrush = m_bNoPen = true;
}


HRESULT
CAdobeFormatConverter::Parse(const char *pData, DWORD nFileLength, RenderCmd **ppCmds)
{
//	MMTRACE("Parse\n");

	HRESULT hr = S_OK;

	if (ppCmds == NULL)
		return E_POINTER;

	if (!pData || !nFileLength)
		return E_INVALIDARG;

	m_pData = pData;
	m_pLimit = pData + nFileLength;

	// intialize command storage stuff
	m_pCurPoint = m_rgPoints;
	m_pCurCode = m_rgCodes;
	m_pCurPolyInfo = m_rgPolyInfos;
	m_pCurRenderCmd = m_rgRenderCmds;
	m_pCurBrushInfo = m_rgBrushInfos;
	m_pCurPenInfo = m_rgPenInfos;

	CHECK_HR(hr = ParseProlog());
	CHECK_HR(hr = ParseScript());

e_Exit:
	// write a stop command to the end
	m_pCurRenderCmd->nType = typeSTOP;
	m_pCurRenderCmd->pvData = NULL;
	*ppCmds = m_rgRenderCmds;

	return hr;
}

HRESULT
CAdobeFormatConverter::ParseProlog()
{
//	MMTRACE("ParseProlog\n");
	const char *szSearch;

	// extract the image dimensions
	float f1, f2;
	// bounding box is supposed to be a required field with the proper numbers
	szSearch = "%%BoundingBox:";
	m_pData = strstr(m_pData, szSearch);
	m_pData = FindSpace(m_pData);

	f1 = mmSimpleAtoF(m_pData);
	f2 = mmSimpleAtoF(m_pData);
	m_fWidth = mmSimpleAtoF(m_pData);
	m_fHeight = mmSimpleAtoF(m_pData);
//	if (sscanf(m_pData, "%f %f %f %f", &f1, &f2, &m_fWidth, &m_fHeight) != 4)
//		return E_FAIL;
	if ((m_fWidth <= 0.f) || (m_fHeight < 0.f))
		return E_FAIL;

//	m_fMaxHeight = float(m_nHeight);

	// search until we find end string
	szSearch = "%%EndProlog";
	m_pData = strstr(m_pData, szSearch);
	if (m_pData == NULL)
		return E_FAIL;

	EatLine();

	return S_OK;
}

HRESULT
CAdobeFormatConverter::ParseScript()
{
//	MMTRACE("ParseScript\n");
	HRESULT hr;

	if (FAILED(hr = ParseSetup()) ||
		FAILED(hr = ParseObjects()) ||
		FAILED(hr = ParseTrailers()))
		return hr;

	return S_OK;
}

HRESULT
CAdobeFormatConverter::ParseSetup()
{
//	MMTRACE("ParseSetup\n");

	const char *szSearch;

	// search until we find end string
	szSearch = "%%EndSetup";
	m_pData = strstr(m_pData, szSearch);
	if (m_pData == NULL)
		return E_FAIL;

	EatLine();

	return S_OK;
}


HRESULT
CAdobeFormatConverter::ParseObjects()
{
//	MMTRACE("ParseObjects\n");
	HRESULT hr = S_OK;

	const char *szPageTrailer = "%%PageTrailer";
	const char *szTrailer = "%%Trailer";
	int cPageTrailer = strlen(szPageTrailer);
	int cTrailer = strlen(szTrailer);

	// process dimensions
/*	const char *pEnd;
	pEnd = FindLF(m_pData);
//	pEnd = strchr(m_pData, '\n');
	if ((pEnd[-1] == 'b') && (pEnd[-2] == 'L')) {
		// get the dimensions out
		int n1, n2, n3, n4, n5, n6, n7, n8;
		if ((sscanf(m_pData, "%d %d %d %d %d %d %d %d %d %d %d",
				&n1, &n2, &n3, &n4, &n5, &n6, &n7, &n8, &m_nWidth, &m_nHeight) != 10) ||
			(m_nWidth <= 0) || (m_nHeight < 0))
		{
			return E_FAIL;
		}
		m_fMaxHeight = float(m_nHeight);
		m_pData = FindNextLine(pEnd);
	}

	pEnd = FindLF(m_pData);
//	pEnd = strchr(m_pData, '\n');
	if ((pEnd[-1] == 'n') && (pEnd[-2] == 'L')) {
		// skip layer information
		m_pData = FindNextLine(pEnd);
	}
*/
	
	for (;;) {
		switch (m_pData[0]) {
		case '%':
			if ((strncmp(m_pData, szPageTrailer, cPageTrailer) == 0) ||
				(strncmp(m_pData, szTrailer, cTrailer) == 0))
			{
				// end of object definitions
				goto e_Exit;
			} else {
				// comment
				EatLine();
			}
			break;
		case '*':
			if (m_pData[1] == 'u')
				CHECK_HR(hr = ParseCompoundPath());
			else {
				hr = E_FAIL;
				goto e_Exit;
			}
			break;
		default:
			CHECK_HR(hr = ParsePath());
			break;
		}
	}

e_Exit:
	if (hr == S_OK)
		EatLine();

	return hr;
}


HRESULT
CAdobeFormatConverter::ParseCompoundPath()
{
//	MMTRACE("ParseCompoundPath\n");
	HRESULT hr = S_OK;

	// remove the "*u"
	MMASSERT((m_pData[0] == '*') && (m_pData[1] == 'u'));
//	if (strncmp(m_pData, "*u", 2) != 0)
//		return E_UNEXPECTED;
	EatLine();

	while (m_pData[0] != '*')
		CHECK_HR(hr = ParsePath());

	// remove the "*U"
	MMASSERT((m_pData[0] == '*') && (m_pData[1] == 'U'));
//	if (strncmp(m_pData, "*U", 2) != 0)
//		return E_UNEXPECTED;
	EatLine();

e_Exit:
	return hr;
}




inline 
UINT GetUInt(const char *pData)
{
	return (UINT) atoi(pData);
}

typedef DWORD FP;
#define nEXPBIAS	127
#define nEXPSHIFTS	23
#define nEXPLSB		(1 << nEXPSHIFTS)
#define maskMANT	(nEXPLSB - 1)
#define FloatToFixed08(nDst, fSrc) MACSTART \
	float fTmp = fSrc; \
	DWORD nRaw = *((FP *) &(fTmp)); \
	if (nRaw < ((nEXPBIAS + 23 - 31) << nEXPSHIFTS)) \
		nDst = 0; \
	else \
		nDst = ((nRaw | nEXPLSB) << 8) >> ((nEXPBIAS + 23) - (nRaw >> nEXPSHIFTS)); \
MACEND

HRESULT
CAdobeFormatConverter::ParsePaintStyle(const char *&pEnd)
{
	HRESULT hr = S_OK;
	BOOL bNotDone = TRUE;
//	int nLineJoin = 1, nLineCap = 1;
	float fLineWidth = 1.f;
	float fGrayFill, fGrayStroke;
	float fCyan, fYellow, fMagenta, fBlack;
	bool bColorFill = false, bGrayFill = false, bGrayStroke = false;

	// parse paint style
	for (; pEnd; pEnd = FindLF(m_pData)) {
		switch(pEnd[-1]) {
			//
			// path attributes
			//
		case 'd':	// process dash
			// REVIEW: skip this for now -- assume NULL pattern
			break;
		case 'j':	// process line join type
			// REVIEW: skip this for now, since it is always 1
//			nLineJoin = mmSimpleAtoI(m_pData);
			break;
		case 'J':	// process line cap type
			// REVIEW: skip this for now, since it is always 1
//			nLineCap = mmSimpleAtoI(m_pData);
			break;
		case 'w':	// process line width
			// REVIEW: skip this for now, since it is always 1.f
//			fLineWidth = mmSimpleAtoF(m_pData);
			break;

			//
			// fill color
			//
		case 'g':	// process gray color for fill
			fGrayFill = mmSimpleAtoF(m_pData);
			bGrayFill = true;
			break;
		case 'k':	// process color
			fCyan = mmSimpleAtoF(m_pData);
			fMagenta = mmSimpleAtoF(m_pData);
			fYellow = mmSimpleAtoF(m_pData);
			fBlack = mmSimpleAtoF(m_pData);
			bColorFill = true;
			break;

			//
			// stroke color
			//
		case 'G':	// process gray color for stroke
			fGrayStroke = mmSimpleAtoF(m_pData);
			bGrayStroke = true;
			break;

		default:
			goto Exit;
			break;
		}
		m_pData = FindNextLine(pEnd);
//		m_pData = pEnd + 1;
	}
Exit:

	// output GDI commands

	//
	// create a brush
	//
	if (bColorFill || bGrayFill) {
		static DWORD nLastRed = 256, nLastGreen = 256, nLastBlue = 256;
		DWORD nTmpRed, nTmpGreen, nTmpBlue;

		if (bColorFill) {
			FloatToFixed08(nTmpRed, fCyan + fBlack); CLAMPMAX(nTmpRed, 255); nTmpRed = 255 - nTmpRed;
			FloatToFixed08(nTmpGreen, fMagenta + fBlack); CLAMPMAX(nTmpGreen, 255); nTmpGreen = 255 - nTmpGreen;
			FloatToFixed08(nTmpBlue, fYellow + fBlack); CLAMPMAX(nTmpBlue, 255); nTmpBlue = 255 - nTmpBlue;
		} else if (bGrayFill) {
			DWORD nTmpGray;
			FloatToFixed08(nTmpGray, fGrayFill); CLAMPMAX(nTmpGray, 255);
			nTmpRed = nTmpGreen = nTmpBlue = nTmpGray;
		}

		if ((nLastRed != nTmpRed) || (nLastGreen != nTmpGreen) || (nLastBlue != nTmpBlue)) {
			// define a new brush
			nLastRed = nTmpRed; nLastGreen = nTmpGreen; nLastBlue = nTmpBlue;
//			fprintf(m_pFile, "\t// select a new brush\n");
//			fprintf(m_pFile, "\tBrush.Color = DXSAMPLE(255, %d, %d, %d);\n", nRed, nGreen, nBlue);
//			fprintf(m_pFile, "\tpDX2D->SetBrush(&Brush);\n\n");
			m_pCurBrushInfo->Color = DXSAMPLE(255, BYTE(nTmpRed), BYTE(nTmpGreen), BYTE(nTmpBlue));
			m_pCurRenderCmd->nType = typeBRUSH;
			m_pCurRenderCmd->pvData = (void *) m_pCurBrushInfo++;
			m_pCurRenderCmd++;
			m_bNoBrush = false;
		}
	}
		
	// create a pen
	if (bGrayStroke) {
		static bool bPenInit = false;
		
		// we only have one pen in the simpsons.ai
		if (!bPenInit) {
//			if ((fGrayStroke != 0.f) || (nLineJoin != 1) || (nLineCap != 1)) {
			if (fGrayStroke != 0.f) {
				MMTRACE("error: can not support pen type\n");
				return E_FAIL;
			}
			bPenInit = true;
//			fprintf(m_pFile, "\t// select a new pen\n");
//			fprintf(m_pFile, "\tPen.Color = DXSAMPLE(255, 0, 0, 0);\n");
//			fprintf(m_pFile, "\tPen.Width = %.2ff;\n", fLineWidth * fGSCALE);
//			fprintf(m_pFile, "\tPen.Style = PS_GEOMETRIC | PS_SOLID | PS_ENDCAP_ROUND | PS_JOIN_ROUND;\n");
//			fprintf(m_pFile, "\tpDX2D->SetPen(&Pen);\n\n");
			// REVIEW: only can make one kind of pen right now
			m_pCurPenInfo->Color = DXSAMPLE(255, 0, 0, 0);
			m_pCurPenInfo->fWidth = fLineWidth * fGSCALE;
			m_pCurPenInfo->dwStyle = PS_GEOMETRIC | PS_SOLID | PS_ENDCAP_ROUND | PS_JOIN_ROUND;
			m_pCurRenderCmd->nType = typePEN;
			m_pCurRenderCmd->pvData = (void *) m_pCurPenInfo++;
			m_pCurRenderCmd++;
			m_bNoPen = false;
		}
	}

	return S_OK;
}

#define GetCoordX(_fX) ((_fX) * fGSCALE)
#define GetCoordY(_fY) ((m_fHeight - (_fY)) * fGSCALE)

HRESULT
CAdobeFormatConverter::ParsePathGeometry(const char *pEnd)
{
	HRESULT hr = S_OK;
//	float fX1, fY1, fXBez1, fYBez1, fXBez2, fYBez2;

	m_pCurPolyInfo->pPoints = m_pCurPoint;
	m_pCurPolyInfo->pCodes = m_pCurCode;

	// parse path geometry
	DWORD cPoints = 0;
	bool bFlatten = false;
	for (; pEnd; pEnd = FindLF(m_pData)) {
		switch(pEnd[-1]) {
		case 'm':
//			fprintf(m_pFile, "\t// define geometry path\n");
//			sscanf(m_pData, "%f %f", &fX1, &fY1);
//			fprintf(m_pFile, "\tppt = rgpt; pb = rgCodes;\n");
//			fprintf(m_pFile, "\tppt->x   = %.2ff; ppt->y   = %.2ff; *pb++ = PT_MOVETO;   ppt++;\n", GetCoordX(fX1), GetCoordY(fY1));
			m_pCurPoint->x = GetCoordX(mmSimpleAtoF(m_pData));
			m_pCurPoint->y = GetCoordY(mmSimpleAtoF(m_pData));
			m_pCurPoint++;
			*m_pCurCode++ = PT_MOVETO;
			cPoints++;
			break;
		case 'L':
		case 'l':
//			sscanf(m_pData, "%f %f", &fX1, &fY1);
//			fprintf(m_pFile, "\tppt->x   = %.2ff; ppt->y   = %.2ff; *pb++ = PT_LINETO;   ppt++;\n", GetCoordX(fX1), GetCoordY(fY1));
			m_pCurPoint->x = GetCoordX(mmSimpleAtoF(m_pData));
			m_pCurPoint->y = GetCoordY(mmSimpleAtoF(m_pData));
			m_pCurPoint++;
			*m_pCurCode++ = PT_LINETO;
			cPoints++;
			break;
		case 'C':
		case 'c':
			bFlatten = true;
			m_pCurPoint[0].x = GetCoordX(mmSimpleAtoF(m_pData));
			m_pCurPoint[0].y = GetCoordY(mmSimpleAtoF(m_pData));
			m_pCurPoint[1].x = GetCoordX(mmSimpleAtoF(m_pData));
			m_pCurPoint[1].y = GetCoordY(mmSimpleAtoF(m_pData));
			m_pCurPoint[2].x = GetCoordX(mmSimpleAtoF(m_pData));
			m_pCurPoint[2].y = GetCoordY(mmSimpleAtoF(m_pData));
			m_pCurPoint += 3;
			m_pCurCode[0] = PT_BEZIERTO; 
			m_pCurCode[1] = PT_BEZIERTO; 
			m_pCurCode[2] = PT_BEZIERTO; 
			m_pCurCode += 3;
			cPoints += 3;
//			sscanf(m_pData, "%f %f %f %f %f %f", &fXBez1, &fYBez1, &fXBez2, &fYBez2, &fX1, &fY1);
//			fprintf(m_pFile, "\tppt[0].x = %.2ff; ppt[0].y = %.2ff; pb[0] = PT_BEZIERTO;\n", GetCoordX(fXBez1), GetCoordY(fYBez1));
//			fprintf(m_pFile, "\tppt[1].x = %.2ff; ppt[1].y = %.2ff; pb[1] = PT_BEZIERTO;\n", GetCoordX(fXBez2), GetCoordY(fYBez2));
//			fprintf(m_pFile, "\tppt[2].x = %.2ff; ppt[2].y = %.2ff; pb[2] = PT_BEZIERTO; ppt += 3; pb += 3;\n", GetCoordX(fX1), GetCoordY(fY1));
			break;
		default:
			goto Exit;
			break;
		}
		// skip the line
		m_pData = FindNextLine(pEnd);
	}
Exit:

	// create the path
//	char *pFillType = (bFlatten ? "0" : "DX2D_NO_FLATTEN");
	if (cPoints) {
		DWORD dwFlags;
		switch(pEnd[-1]) {
		case 'f':		// close path and fill
			if (m_bNoBrush) {
//				fprintf(m_pFile, "\tpDX2D->SetBrush(&Brush);\n"); m_nLines++;
				m_bNoBrush = false;
			}
			if (m_bNoPen == false) {
//				fprintf(m_pFile, "\tpDX2D->SetPen(NULL);\n"); m_nLines++;
				m_bNoPen = true;
			}
			dwFlags = DX2D_FILL;
			break;
		case 'S':		// stroke path
			if (m_bNoPen) { 
//				fprintf(m_pFile, "\tpDX2D->SetPen(&Pen);\n"); m_nLines++;
				m_bNoPen = false;
			}
			if (m_bNoBrush == false) {
//				fprintf(m_pFile, "\tpDX2D->SetBrush(NULL);\n"); m_nLines++;
				m_bNoBrush = true;
			}
			dwFlags = DX2D_STROKE;
			break;
		default:
			MMTRACE("error: unknown render mode -- aborting\n");
			return E_FAIL;
			break;
		}
//		fprintf(m_pFile, "\tpDX2D->AAPolyDraw(rgpt, rgCodes, %d, %s);\n", iPoint, pFillType);
		m_pCurPolyInfo->cPoints = cPoints;
		m_pCurPolyInfo->dwFlags = dwFlags | (bFlatten ? 0 : DX2D_NO_FLATTEN);
		m_pCurRenderCmd->nType = typePOLY;
		m_pCurRenderCmd->pvData = (PolyInfo *) m_pCurPolyInfo++;
		m_pCurRenderCmd++;
		m_pData = FindNextLine(pEnd);
	}

	return S_OK;
}

HRESULT
CAdobeFormatConverter::ParsePath()
{
//	MMTRACE("ParsePath\n");
	HRESULT hr;
	const char *pStart = m_pData, *pEnd = FindLF(m_pData);

	if (FAILED(hr = ParsePaintStyle(pEnd)))
		return hr;

	if (FAILED(hr = ParsePathGeometry(pEnd)))
		return hr;

	// skip it if we don't know how to deal with it
	if (pStart == m_pData) {
//		if ((m_pData[0] != 'L') || (m_pData[1] != 'B')) {
//			MMTRACE("warning: control data of unknown type -- ignoring line\n");
//		}
		m_pData = FindNextLine(pEnd);
	}

	return hr;
}

HRESULT
CAdobeFormatConverter::ParseTrailers()
{
	return S_OK;
}


HRESULT
OpenFileMapping(const char *szFilename, LPHANDLE phMapping, 
				DWORD *pnFileLength)
{
	MMASSERT(szFilename && phMapping && pnFileLength);
	HRESULT hr = S_OK;

	HANDLE hFile = NULL, hMapping = NULL;
	DWORD nFileLength = 0, dwHighSize = 0;

	MMTRACE("Opening File: %s\n", szFilename);

	// open the file
	hFile = CreateFile(szFilename, GENERIC_READ, FILE_SHARE_READ, NULL, 
				OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, 0);

	if ((hFile == NULL) || (hFile == INVALID_HANDLE_VALUE)) {
		MMTRACE("error: file not found - %s\n", szFilename);
		return STG_E_FILENOTFOUND;
	}

	// get the length of the file
	if (((nFileLength = GetFileSize(hFile, &dwHighSize)) == 0xFFFFFFFF) || dwHighSize ||
		// create a file mapping object
		((hMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL)) == NULL))
	{
		MMTRACE("error: creating file mapping\n");
		hr = E_FAIL;
	}

	MMTRACE("\tLength: %d\n", nFileLength);

	if (hFile)
		CloseHandle(hFile);

	*phMapping = hMapping;
	*pnFileLength = nFileLength;

	return hr;
}


#define szDEFFILENAME "\\dtrans\\tools\\simpsons\\simpsons.ai"

HRESULT
ParseAIFile(const char *szFilename, RenderCmd **ppCmds)
{
	HRESULT hr = S_OK;

	static CAdobeFormatConverter afc;
	static RenderCmd s_CmdStop = {typeSTOP, NULL};
	DWORD nStartTick, nEndTick;
	DWORD nFileLength;
	HANDLE hMapping = NULL;
	char *pData = NULL;

	if (szFilename == NULL)
		szFilename = szDEFFILENAME;

	nStartTick = GetTickCount();

	CHECK_HR(hr = OpenFileMapping(szFilename, &hMapping, &nFileLength));

	// create a map view
	if ((pData = (char *) MapViewOfFile(hMapping, FILE_MAP_READ, 0, 0, 0)) == NULL) {
		hr = E_FAIL;
		goto e_Exit;
	}

	CHECK_HR(hr = afc.Parse(pData, nFileLength, ppCmds));

e_Exit:
	if (pData)
		UnmapViewOfFile(pData);

	if (hMapping)
		CloseHandle(hMapping);

	if (FAILED(hr)) {
		// set to the null command list
		*ppCmds = &s_CmdStop;
		MMTRACE("\terror parsing file\n");
	} else {
		nEndTick = GetTickCount();
		sprintf(g_rgchTmpBuf, "\tParse Time: %d\n", nEndTick - nStartTick);
		OutputDebugString(g_rgchTmpBuf);
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\simpsons\pixinfo.cpp ===
// File:	PixInfo.cpp
// Author:	Michael Marr    (mikemarr)

#include "stdafx.h"
#include "PixInfo.h"
#include "DDHelper.h"

static void
_GetShiftMaskInfo(DWORD dwMask, BYTE *pnShiftStart, BYTE *pnLengthResidual)
{
	MMASSERT(pnShiftStart && pnLengthResidual);
	// Note: - DWORD fills with zeros on right shift

	DWORD nShift = 0, nRes = 8;
	if (dwMask) {
		// compute shift
		if ((dwMask & 0xFFFF) == 0) { dwMask >>= 16, nShift += 16; }
		if ((dwMask & 0xFF) == 0) { dwMask >>= 8; nShift += 8; }
		if ((dwMask & 0xF) == 0) { dwMask >>= 4; nShift += 4; }
		if ((dwMask & 0x3) == 0) { dwMask >>= 2; nShift += 2; }
		if ((dwMask & 0x1) == 0) { dwMask >>= 1; nShift++; }
		// compute residual
		if ((dwMask & 0xFF) == 0xFF) { 
			nRes = 0;
		} else {
			if ((dwMask & 0xF) == 0xF) { dwMask >>= 4; nRes -= 4; }
			if ((dwMask & 0x3) == 0x3) { dwMask >>= 2; nRes -= 2; }
			if ((dwMask & 0x1) == 0x1) { nRes--; }
		}
	}
	*pnShiftStart = (BYTE) nShift;
	*pnLengthResidual = (BYTE) (nRes);
}


HRESULT
CPixelInfo::Init(BYTE tnBPP, DWORD dwRedMask, DWORD dwGreenMask,
				 DWORD dwBlueMask, DWORD dwAlphaMask)
{
	nBPP = tnBPP;
	uchFlags = 0;

	if (dwRedMask) {
		uchFlags |= flagPixiRGB;
		_GetShiftMaskInfo(dwRedMask, &nRedShift, &nRedResidual);
		_GetShiftMaskInfo(dwGreenMask, &nGreenShift, &nGreenResidual);
		_GetShiftMaskInfo(dwBlueMask, &nBlueShift, &nBlueResidual);
		_GetShiftMaskInfo(dwAlphaMask, &nAlphaShift, &nAlphaResidual);
		if (dwAlphaMask)
			uchFlags |= flagPixiAlpha;
	} else {
		nRedResidual = nGreenResidual = nBlueResidual = nAlphaResidual = 8;
		nRedShift = nGreenShift = nBlueShift = nAlphaShift = 0;
	}
	iRed = (nRedShift == 0 ? 0 : 2);
	iBlue = 2 - iRed;
	
//	MMTRACE("BPP: %2d   R: %2d %2d   G: %2d %2d   B: %2d %2d   A: %2d %2d\n", nBPP,
//		8 - nRedResidual, nRedShift, 8 - nGreenResidual, nGreenShift, 
//		8 - nBlueResidual, nBlueShift, 8 - nAlphaResidual, nAlphaShift);

	return S_OK;
}

void
CPixelInfo::GetDDPF(DDPIXELFORMAT &ddpf) const
{
	ddpf.dwSize = sizeof(DDPIXELFORMAT);
	ddpf.dwFlags = DDPF_RGB;
	ddpf.dwRGBBitCount = nBPP;
	if (IsRGB()) {
		ddpf.dwRBitMask = ((((DWORD) 0xFF) >> nRedResidual) << nRedShift);
		ddpf.dwGBitMask = ((((DWORD) 0xFF) >> nGreenResidual) << nGreenShift);
		ddpf.dwBBitMask = ((((DWORD) 0xFF) >> nBlueResidual) << nBlueShift);
		ddpf.dwRGBAlphaBitMask = ((((DWORD) 0xFF) >> nAlphaResidual) << nAlphaShift);
		if (HasAlpha())
			ddpf.dwFlags |= DDPF_ALPHAPIXELS;
	} else {
		ddpf.dwFlags |= BPPToPixelFlags(nBPP);
		ddpf.dwRBitMask = ddpf.dwGBitMask = ddpf.dwBBitMask = ddpf.dwRGBAlphaBitMask = 0;
	}
}

BOOL
CPixelInfo::operator==(const CPixelInfo &pixi) const
{
	return ((nBPP == pixi.nBPP) && (!IsRGB() || 
		((nRedShift == pixi.nRedShift) && (nGreenShift == pixi.nGreenShift) &&
		 (nBlueShift == pixi.nBlueShift) && (nAlphaShift == pixi.nAlphaShift))));
}

BOOL
CPixelInfo::operator==(const DDPIXELFORMAT &ddpf) const
{
	return ((nBPP == ddpf.dwRGBBitCount) && ((!IsRGB() && (ddpf.dwRBitMask == 0)) ||
			((ddpf.dwRBitMask == ((DWORD(0xFF) >> nRedResidual) << nRedShift)) &&
			 (ddpf.dwGBitMask == ((DWORD(0xFF) >> nGreenResidual) << nGreenShift)) &&
			 (ddpf.dwBBitMask == ((DWORD(0xFF) >> nBlueResidual) << nBlueShift)) &&
			 (ddpf.dwRGBAlphaBitMask == ((DWORD(0xFF) >> nAlphaResidual) << nAlphaShift)))));
}

DWORD
CPixelInfo::Pack(const BYTE *pPixel) const
{
	MMASSERT(pPixel && (nBPP >= 8));
	if (nBPP == 8)
		return (DWORD) *pPixel;
	if (HasAlpha())
		return Pack(pPixel[0], pPixel[1], pPixel[2], pPixel[3]);
	else
		return Pack(pPixel[0], pPixel[1], pPixel[2]);
}

DWORD
CPixelInfo::Pack(BYTE r, BYTE g, BYTE b) const
{
	// truncate the RGB values to fit in allotted bits
	return (((((DWORD) r) >> nRedResidual) << nRedShift) |
		((((DWORD) g) >> nGreenResidual) << nGreenShift) |
		((((DWORD) b) >> nBlueResidual) << nBlueShift));
}

DWORD
CPixelInfo::Pack(BYTE r, BYTE g, BYTE b, BYTE a) const
{
	// truncate the alpha value to fit in allotted bits
	return (((((DWORD) r) >> nRedResidual) << nRedShift) |
		((((DWORD) g) >> nGreenResidual) << nGreenShift) |
		((((DWORD) b) >> nBlueResidual) << nBlueShift) | 
		((((DWORD) a) >> nAlphaResidual) << nAlphaShift));
}

void
CPixelInfo::UnPack(DWORD dwPixel, BYTE *pR, BYTE *pG, BYTE *pB, BYTE *pA) const
{
	MMASSERT(pR && pG && pB && pA);

	*pR = (BYTE) (((dwPixel >> nRedShift) & (0xFF >> nRedResidual)) << nRedResidual);
	*pG = (BYTE) (((dwPixel >> nGreenShift) & (0xFF >> nGreenResidual)) << nGreenResidual);
	*pB = (BYTE) (((dwPixel >> nBlueShift) & (0xFF >> nBlueResidual)) << nBlueResidual);
	*pA = (BYTE) (((dwPixel >> nAlphaShift) & (0xFF >> nAlphaResidual)) << nAlphaResidual);
}

void
CPixelInfo::UnPack(DWORD dwPixel, BYTE *pR, BYTE *pG, BYTE *pB) const
{
	MMASSERT(pR && pG && pB);

	*pR = (BYTE)(((dwPixel >> nRedShift) & (0xFF >> nRedResidual)) << nRedResidual);
	*pG = (BYTE)(((dwPixel >> nGreenShift) & (0xFF >> nGreenResidual)) << nGreenResidual);
	*pB = (BYTE)(((dwPixel >> nBlueShift) & (0xFF >> nBlueResidual)) << nBlueResidual);
}

DWORD
CPixelInfo::TranslatePack(DWORD dwPix, const CPixelInfo &pixiSrc) const
{
	// REVIEW: this could be optimized by splitting out the cases
	DWORD dwTmp;
	dwTmp = ((((((dwPix >> pixiSrc.nRedShift) & (0xFF >> pixiSrc.nRedResidual)) 
		<< pixiSrc.nRedResidual) >> nRedResidual) << nRedShift) |
	(((((dwPix >> pixiSrc.nGreenShift) & (0xFF >> pixiSrc.nGreenResidual)) 
		<< pixiSrc.nGreenResidual) >> nGreenResidual) << nGreenShift) |
	(((((dwPix >> pixiSrc.nBlueShift) & (0xFF >> pixiSrc.nBlueResidual)) 
		<< pixiSrc.nBlueResidual) >> nBlueResidual) << nBlueShift));
	if (pixiSrc.HasAlpha())
		dwTmp |= (((((dwPix >> pixiSrc.nAlphaShift) & (0xFF >> pixiSrc.nAlphaResidual)) 
					<< pixiSrc.nAlphaResidual) >> nAlphaResidual) << nAlphaShift);
	return dwTmp;
}

WORD
CPixelInfo::Pack16(BYTE r, BYTE g, BYTE b) const
{
	MMASSERT(nBPP == 16);
	return (((((WORD) r) >> nRedResidual) << nRedShift) |
		((((WORD) g) >> nGreenResidual) << nGreenShift) |
		((((WORD) b) >> nBlueResidual) << nBlueShift));
}

WORD
CPixelInfo::Pack16(BYTE r, BYTE g, BYTE b, BYTE a) const
{
	MMASSERT(nBPP == 16);
	return (((((WORD) r) >> nRedResidual) << nRedShift) |
		((((WORD) g) >> nGreenResidual) << nGreenShift) |
		((((WORD) b) >> nBlueResidual) << nBlueShift) | 
		((((WORD) a) >> nAlphaResidual) << nAlphaShift));
}

/*
void
TestPixi()
{
	DDPIXELFORMAT ddpf;
	INIT_DXSTRUCT(ddpf);
	DWORD dwTmp = 0;
	BYTE r = 0, g = 0, b = 0, a = 0;

	MMASSERT(g_pixiPalette8 != g_ddpfBGR332);
	MMASSERT(g_pixiRGB != g_pixiBGR);
	MMASSERT(g_pixiRGB565 != g_ddpfBGR565);
	MMASSERT(g_pixiBGRA5551 == g_ddpfBGRA5551);
	MMASSERT(g_pixiBGRX != g_pixiBGRA);
	MMASSERT(g_pixiBGR != g_pixiBGRX);
	MMASSERT(g_pixiBGRA5551 != g_pixiBGR555);
	MMASSERT(g_pixiBGR332.Pack(0x00, 0xFF, 0x00) == g_ddpfBGR332.dwGBitMask);
	MMASSERT(g_pixiBGRA4444.Pack(0x00, 0x00, 0x00, 0xFF) == g_ddpfBGRA4444.dwRGBAlphaBitMask);
	MMASSERT(g_pixiBGRA5551.TranslatePack(g_pixiBGRA4444.Pack(0, 0, 0, 0xFF), g_pixiBGRA4444) == g_ddpfBGRA5551.dwRGBAlphaBitMask);
	g_pixiRGB.UnPack(g_pixiRGB.Pack(0xFF, 0, 0), &r, &g, &b, &a);
	MMASSERT((r == 0xFF) && (g == 0) && (b == 0) && (a == 0));
	g_pixiBGR332.GetDDPF(ddpf);
	MMASSERT(ddpf == g_ddpfBGR332);
	g_pixiPalette8.GetDDPF(ddpf);
	MMASSERT(ddpf == g_ddpfPalette8);
	g_pixiBGRA4444.GetDDPF(ddpf);
	MMASSERT(g_ddpfBGRA4444 == ddpf);
	g_pixiBGR565.GetDDPF(ddpf);
	MMASSERT(g_ddpfBGR565 == ddpf);
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\simpsons\palmap.h ===
#ifndef _PalMap_h
#define _PalMap_h

// File:	PalMap.h
// Author:	Michael Marr    (mikemarr)
//
// Description:
//    This class helps perform on-the-fly pixel conversions.
// 
// History:
// -@- 11/18/96 (mikemarr) created
// -@- 12/05/96 (mikemarr) modified
//     added code for translating all palettes to 8, 16, 24, and 32 bit;
//     transparency/alpha stuff is not yet implemented
// -@- 06/24/97 (mikemarr) modified
//     removed PixelInfo
// -@- 09/23/97 (mikemarr) copied to DXCConv from d2d\mmimage
//
// Notes:
// REVIEW:
//    I probably will never support a 4 bit mode, since 4 bit stuff might
//  as well be stored as 8 bit since the space savings is small.  However,
//  2 and 1 bit stuff should still be considered, since the space savings
//  could be substantial.  Further, 1 and 2 bit surfaces represent a large
//  class of content - line art, text, FAX, etc.  (2 bits buys BGW +
//  transparency for example).  This type of content tends to be much larger
//  in dimension -- so we need an efficient representation.

#ifndef _PixInfo_h
#include "PixInfo.h"
#endif

typedef WORD MapEntry16;
typedef DWORD MapEntry24;
typedef DWORD MapEntry32;

#define flagTRANSPARENT 0x1
#define flagPALETTIZED  0x2

#define nMAXPALETTEENTRIES 256

typedef enum ConvertCode {
	cvc4To8 = 0, cvc4To16, cvc4To24, cvc4To32,
	cvc8To8, cvc8To16, cvc8To24, cvc8To32,
	cvcInvalid, cvcNumCodes
} ConvertCode;

typedef HRESULT		(*ConvertFunction)(const BYTE *pSrcPixels, long nSrcPitch,
						BYTE *pDstPixels, long nDstPitch,
						DWORD nWidth, DWORD nHeight,
						const BYTE *pIndexMap);
typedef DWORD		(*GetColorFunction)(DWORD dwSrcColor, const BYTE *pIndexMap);

extern ConvertFunction g_rgConvertFunctions[cvcNumCodes];

class CPaletteMap {
public:
					CPaletteMap();
					~CPaletteMap();
	
	HRESULT			CreateMap(BYTE nBPPSrcPixels, BYTE nBPPSrcPalette, LPPALETTEENTRY rgpeSrc, 
					   const CPixelInfo &pixiDst, LPDIRECTDRAWPALETTE pddpDst);
	HRESULT			CreateMap(LPDIRECTDRAWPALETTE pddpSrc, const CPixelInfo &pixiDst,
						LPDIRECTDRAWPALETTE pddpDst);
//	HRESULT			CreateSortedMap(BYTE nBPP, const RGB *rgrgbSrc, BYTE nBPPUsed, DWORD iTransColor, 
//						DWORD dwFlags, LPPALETTEENTRY rgpeDst);


	HRESULT			BltFast(LPDIRECTDRAWSURFACE pddsSrc, LPRECT prSrc, LPDIRECTDRAWSURFACE pddsDst,
						DWORD nXPos, DWORD nYPos, DWORD dwFlags) const;

	// REVIEW: this is not "clip-safe"
	HRESULT			BltFast(const BYTE *pSrcPixels, long nSrcPitch, BYTE *pDstPixels, long nDstPitch,
						DWORD nWidth, DWORD nHeight);
	

	DWORD			GetIndexMapping(DWORD iSrcColor) const;

	DWORD			GetSrcBPP() const	{ return m_cSrcBPP; }
	DWORD			GetDstBPP() const	{ return m_cDstBPP; }
	BOOL			IsIdentity() const	{ return m_bIdentity; }
	
private:	
	HRESULT			DoPalTo16BitMap(BYTE nSrcBPP, const CPixelInfo &pixiDst, 
						const PALETTEENTRY *ppeSrc);
	HRESULT			DoPalTo24BitMap(BYTE nSrcBPP, const CPixelInfo &pixiDst, 
						const PALETTEENTRY *ppeSrc);
	HRESULT			DoPalTo32BitMap(BYTE nSrcBPP, const CPixelInfo &pixiDst, 
						const PALETTEENTRY *ppeSrc);
	HRESULT			DoPalToPalMap(BYTE nSrcBPP, BYTE nDstBPP, const PALETTEENTRY *ppeSrc, 
						const PALETTEENTRY *ppeDst);

	static int		GetConvertCode(DWORD nSrcBPP, DWORD nDstBPP);

private:
	BYTE *			m_rgIndexMap;
	BYTE			m_nConvertCode;
	// REVIEW: we don't need to store the src and dst info ==> implicit in ConvertCode
	BYTE			m_cSrcBPP, m_cDstBPP;
	BYTE			m_bIdentity;
};


inline HRESULT
CPaletteMap::BltFast(const BYTE *pSrcPixels, long nSrcPitch, BYTE *pDstPixels, long nDstPitch,
					 DWORD nWidth, DWORD nHeight)
{
	ConvertFunction pfnConvertFunction = g_rgConvertFunctions[m_nConvertCode];
	if (pfnConvertFunction)
		return pfnConvertFunction(pSrcPixels, nSrcPitch, pDstPixels, nDstPitch, 
					nWidth, nHeight, m_rgIndexMap);
	return E_NOTIMPL;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\simpsons\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by SIMPSONS.RC
//
#define IDR_MAINFRAME				128
#define IDR_SIMPSOTYPE				129
#define IDD_ABOUTBOX				100

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS			1
#define _APS_NEXT_RESOURCE_VALUE	130
#define _APS_NEXT_CONTROL_VALUE		1000
#define _APS_NEXT_SYMED_VALUE		101
#define _APS_NEXT_COMMAND_VALUE		32771
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\simpsons\simpdoc.cpp ===
// SimpDoc.cpp : implementation of the CSimpsonsDoc class
//

#include "stdafx.h"
#include "simpsons.h"
#include "SimpDoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSimpsonsDoc

IMPLEMENT_DYNCREATE(CSimpsonsDoc, CDocument)

BEGIN_MESSAGE_MAP(CSimpsonsDoc, CDocument)
	//{{AFX_MSG_MAP(CSimpsonsDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSimpsonsDoc construction/destruction

CSimpsonsDoc::CSimpsonsDoc()
{
	m_bNoRenderFile = true;
	m_pCmds = NULL;
	m_bNeverRendered = true;
}

CSimpsonsDoc::~CSimpsonsDoc()
{
}

#define szDEFFILENAME "Simpsons.ai"

BOOL 
CSimpsonsDoc::OnNewDocument()
{
	HRESULT hr;

	if (!CDocument::OnNewDocument())
		return FALSE;

	if (m_bNoRenderFile) {
		m_bNoRenderFile = false;
		if (FAILED(hr = ParseAIFile(szDEFFILENAME, &m_pCmds))) {
			strcpy(m_szFileName, "invalid file");
			return TRUE;
		}
		strcpy(m_szFileName, szDEFFILENAME);
		m_bNeverRendered = true;
	}

	return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
// CSimpsonsDoc serialization

void 
CSimpsonsDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		HRESULT hr = S_OK;
		hr = ParseAIFile(ar.m_strFileName, &m_pCmds);
		strcpy(m_szFileName, ar.m_strFileName);
		m_bNoRenderFile = FAILED(hr);
		m_bNeverRendered = true;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CSimpsonsDoc diagnostics

#ifdef _DEBUG
void CSimpsonsDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CSimpsonsDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CSimpsonsDoc commands
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\simpsons\point.h ===
#ifndef _Point_h
#define _Point_h

// File:	Point.h
//
//	Classes to support 2D and 3D affine space
//	D. P. Mitchell  95/06/02.
//
// History:
// -@- 08/01/95 (mikemarr) - unified & cleaned up interface
//                         - added Print and Parse
// -@- 08/01/95 (mikemarr) - define all inlined functions with macros 
// -@- 06/21/96 (mikemarr) - added IsCCW
// -@- 10/29/97 (mikemarr) - changed data to be floats, not vectors
//                         - removed data accessors & made data public
//                         - changed +=, -= operators to return reference
//                         - removed I/O
//                         - added operator const float *
//                         - changed fuzzy equal to be IsEqual, operator == to be exact
//                         - removed macro junk
// -@- 11/04/97 (mikemarr) - added initialization with POINT
// -@- 11/10/97 (mikemarr) - added operator *,/,*=,/=


#ifndef _VecMath_h
#include "VecMath.h"
#endif

// Class:		Point2
// Hungarian:	pnt
class Point2 {
public:
						Point2()					{}
						Point2(float fX, float fY)	: x(fX), y(fY) {}
						Point2(const Vector2 &v)	: x(v.x), y(v.y) {}
						Point2(const POINT &pt)		: x(pt.x + 0.5f), y(pt.y + 0.5f) {}

	// ALGEBRAIC OPERATORS
	friend Point2		operator +(const Point2 &p, const Vector2 &v);
	friend Point2		operator +(const Vector2 &v, const Point2 &p);
	friend Point2		operator -(const Point2 &p, const Vector2 &v);
	friend Point2		operator -(const Vector2 &v, const Point2 &p);
	friend Point2		operator *(const Point2 &p, float a);
	friend Point2		operator *(float a, const Point2 &p);
	friend Point2		operator /(const Point2 &p, float a);
	friend Vector2		operator -(const Point2 &p, const Point2 &q);

	friend Point2 &		operator +=(Point2 &p, const Vector2 &v);
	friend Point2 &		operator -=(Point2 &p, const Vector2 &v);
	friend Point2 &		operator *=(Point2 &p, float a);
	friend Point2 &		operator /=(Point2 &p, float a);

	friend float		operator *(const CoVector2 &cv, const Point2 &p);

	friend int			operator ==(const Point2 &p, const Point2 &q);
	friend int			operator !=(const Point2 &p, const Point2 &q);
	friend int			IsEqual(const Point2 &p, const Point2 &q);

	friend Point2		Lerp(const Point2 &p, const Point2 &q, float t);
	friend bool			IsCCW(const Point2 &p0, const Point2 &p, const Point2 &q);

						operator const float *() const { return &x; }

	float				X() const { return x; }
	float				Y() const { return y; }
	float &				X() { return x; }
	float &				Y() { return y; }
public:
	float				x, y;
};


// Class:		Point3
// Hungarian:	pnt
class Point3 {
public:
						Point3()								{}
						Point3(float fX, float fY, float fZ)	: x(fX), y(fY), z(fZ) {}
						Point3(const Vector3 &v)				: x(v.x), y(v.y), z(v.z) {}
	
	// ALGEBRAIC OPERATORS
	friend Point3		operator +(const Point3 &p, const Vector3 &v);
	friend Point3		operator +(const Vector3 &v, const Point3 &p);
	friend Point3		operator -(const Point3 &p, const Vector3 &v);
	friend Point3		operator -(const Vector3 &v, const Point3 &p);
	friend Vector3		operator -(const Point3 &p, const Point3 &q);
	friend Point3		operator *(const Point3 &p, float a);
	friend Point3		operator *(float a, const Point3 &p);
	friend Point3		operator /(const Point3 &p, float a);

	friend Point3 &		operator +=(Point3 &p, const Vector3 &v);
	friend Point3 &		operator -=(Point3 &p, const Vector3 &v);
	friend Point3 &		operator *=(Point3 &p, float a);
	friend Point3 &		operator /=(Point3 &p, float a);

	friend float		operator *(const CoVector3 &cv, const Point3 &p);

	friend int			operator ==(const Point3 &p, const Point3 &q);
	friend int			operator !=(const Point3 &p, const Point3 &q);
	friend int			IsEqual(const Point3 &p, const Point3 &q);

	friend Point3		Lerp(const Point3 &p, const Point3 &q, float t);
	Point2				Project(DWORD iAxis) const;

						operator const float *() const { return &x; }

	float				X() const { return x; }
	float				Y() const { return y; }
	float				Z() const { return z; }
	float &				X() { return x; }
	float &				Y() { return y; }
	float &				Z() { return z; }
public:
	float				x, y, z;
};

///////////
// Point2
///////////

inline Point2
operator +(const Point2 &p, const Vector2 &v)
{
	return Point2(p.x + v.x, p.y + v.y);
}

inline Point2
operator +(const Vector2 &v, const Point2 &p)
{
	return Point2(p.x + v.x, p.y + v.y);
}

inline Point2
operator -(const Point2 &p, const Vector2 &v)
{
	return Point2(p.x - v.x, p.y - v.y);
}

inline Point2
operator -(const Vector2 &v, const Point2 &p)
{
	return Point2(p.x - v.x, p.y - v.y);
}

inline Vector2
operator -(const Point2 &p, const Point2 &q)
{
	return Vector2(p.x - q.x, p.y - q.y);
}

inline Point2
operator *(float a, const Point2 &p)
{
	return Point2(a*p.x, a*p.y);
}

inline Point2
operator *(const Point2 &p, float a)
{
	return Point2(a*p.x, a*p.y);
}

inline Point2
operator /(const Point2 &p, float a)
{
	MMASSERT(a != 0.f);
	float fTmp = 1.f/a;
	return Point2(p.x * fTmp, p.y * fTmp);
}



inline Point2 &
operator +=(Point2 &p, const Vector2 &v)
{
	p.x += v.x;
	p.y += v.y;
	return p;
}

inline Point2 &
operator -=(Point2 &p, const Vector2 &v)
{
	p.x -= v.x;
	p.y -= v.y;
	return p;
}

inline Point2 &
operator *=(Point2 &p, float a)
{
	p.x *= a;
	p.y *= a;
	return p;
}

inline Point2 &
operator /=(Point2 &p, float a)
{
	MMASSERT(a != 0.f);
	float fTmp = 1.f/a;
	p.x *= fTmp;
	p.y *= fTmp;
	return p;
}


inline int
operator ==(const Point2 &p, const Point2 &q)
{
	return ((p.x == q.x) && (p.y == q.y));
}

inline int
operator !=(const Point2 &p, const Point2 &q)
{
	return ((p.x != q.x) || (p.y != q.y));
}

inline int
IsEqual(const Point2 &p, const Point2 &q)
{
	return (FloatEquals(p.x, q.x) && FloatEquals(p.y, q.y));
}

inline Point2
Lerp(const Point2 &p, const Point2 &q, float t)
{
	return Point2(p.x + (q.x - p.x) * t, p.y + (q.y - p.y) * t);
}


inline bool
IsCCW(const Point2 &p0, const Point2 &p1, const Point2 &p2)
{
#ifdef MIRRORY
	return ((p0.y - p1.y) * (p2.x - p1.x) <= (p0.x - p1.x) * (p2.y - p1.y));
#else
	return ((p0.y - p1.y) * (p2.x - p1.x) >= (p0.x - p1.x) * (p2.y - p1.y));
#endif
}

inline float
operator *(const CoVector2 &cv, const Point2 &p)
{
	return cv.x*p.x + cv.y*p.y;
}


///////////
// Point3
///////////

inline Point3
operator +(const Point3 &p, const Vector3 &v)
{
	return Point3(p.x + v.x, p.y + v.y, p.z + v.z);
}

inline Point3
operator +(const Vector3 &v, const Point3 &p)
{
	return Point3(p.x + v.x, p.y + v.y, p.z + v.z);
}

inline Point3
operator -(const Point3 &p, const Vector3 &v)
{
	return Point3(p.x - v.x, p.y - v.y, p.z - v.z);
}

inline Point3
operator -(const Vector3 &v, const Point3 &p)
{
	return Point3(p.x - v.x, p.y - v.y, p.z - v.z);
}

inline Vector3
operator -(const Point3 &p, const Point3 &q)
{
	return Vector3(p.x - q.x, p.y - q.y, p.z - q.z);
}

inline Point3
operator *(float a, const Point3 &p)
{
	return Point3(a*p.x, a*p.y, a*p.z);
}

inline Point3
operator *(const Point3 &p, float a)
{
	return Point3(a*p.x, a*p.y, a*p.z);
}

inline Point3
operator /(const Point3 &p, float a)
{
	MMASSERT(a != 0.f);
	float fTmp = 1.f/a;
	return Point3(p.x * fTmp, p.y * fTmp, p.z * fTmp);
}

inline Point3 &
operator +=(Point3 &p, const Vector3 &v)
{
	p.x += v.x;
	p.y += v.y;
	p.z += v.z;
	return p;
}

inline Point3 &
operator -=(Point3 &p, const Vector3 &v)
{
	p.x -= v.x;
	p.y -= v.y;
	p.z -= v.z;
	return p;
}

inline Point3 &
operator *=(Point3 &p, float a)
{
	p.x *= a;
	p.y *= a;
	p.z *= a;
	return p;
}

inline Point3 &
operator /=(Point3 &p, float a)
{
	MMASSERT(a != 0.f);
	float fTmp = 1.f/a;
	p.x *= fTmp;
	p.y *= fTmp;
	p.z *= fTmp;
	return p;
}


inline int
operator ==(const Point3 &p, const Point3 &q)
{
	return ((p.x == q.x) && (p.y == q.y) && (p.z == q.z));
}

inline int
operator !=(const Point3 &p, const Point3 &q)
{
	return ((p.x != q.x) || (p.y != q.y) || (p.z != q.z));
}

inline int
IsEqual(const Point3 &p, const Point3 &q)
{
	return (FloatEquals(p.x, q.x) && FloatEquals(p.y, q.y) && FloatEquals(p.z, q.z));
}

inline Point3
Lerp(const Point3 &p, const Point3 &q, float t)
{
	return Point3(p.x + (q.x - p.x) * t, p.y + (q.y - p.y) * t, p.z + (q.z - p.z) * t);
}

inline Point2
Point3::Project(DWORD iAxis) const
{
	switch (iAxis) {
	case 0: return Point2(y, z);
	case 1: return Point2(x, z);
	case 2: return Point2(x, y);
	}
	return Point2(0.f, 0.f);
}

inline float
operator *(const CoVector3 &cv, const Point3 &p)
{
	return cv.x*p.x + cv.y*p.y + cv.z*p.z;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\simpsons\simpsons.h ===
// simpsons.h : main header file for the SIMPSONS application
//

#if !defined(AFX_SIMPSONS_H__7CA49166_71B3_11D1_AA67_00600814AAE9__INCLUDED_)
#define AFX_SIMPSONS_H__7CA49166_71B3_11D1_AA67_00600814AAE9__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CSimponsApp:
// See simpsons.cpp for the implementation of this class
//

class CSimponsApp : public CWinApp
{
public:
	CSimponsApp();
    ~CSimponsApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSimponsApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CSimponsApp)
	afx_msg void OnAppAbout();
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SIMPSONS_H__7CA49166_71B3_11D1_AA67_00600814AAE9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\simpsons\pixinfo.h ===
#ifndef _PixInfo_h
#define _PixInfo_h

// File:	PixInfo.h
// Author:	Michael Marr    (mikemarr)
//
// Description:
//    Store the PixelFormat information in a form that is actually useful
//  to an application.
//
// ***Hungarian: pixi
// 
// History:
// -@- 06/24/97 (mikemarr) created -- snarfed from PalMap.h
// -@- 09/23/97 (mikemarr) moved to DXCConv to do color conversion stuff
// -@- 10/09/97 (mikemarr) - added 8 bit RGB
//                         - added flags
//                         - bug fixes for pixel formats with alpha

#define flagPixiRGB		0x1
#define flagPixiAlpha	0x2

class CPixelInfo {
public:
	HRESULT			Init(BYTE nBPP = 0, DWORD dwRedMask = 0, DWORD dwGreenMask = 0,
						DWORD dwBlueMask = 0, DWORD dwAlphaMask = 0);
	HRESULT			Init(const DDPIXELFORMAT &ddpf) {
						return Init(BYTE(ddpf.dwRGBBitCount), ddpf.dwRBitMask, ddpf.dwGBitMask,
							ddpf.dwBBitMask, ddpf.dwRGBAlphaBitMask); }

					CPixelInfo(BYTE nBPP = 0, DWORD dwRedMask = 0, DWORD dwGreenMask = 0,
						DWORD dwBlueMask = 0, DWORD dwAlphaMask = 0) {
							Init(nBPP, dwRedMask, dwGreenMask, dwBlueMask, dwAlphaMask); }
					CPixelInfo(const DDPIXELFORMAT &ddpf) { Init(ddpf); }
	

	void			GetDDPF(DDPIXELFORMAT &ddpf) const;
	BOOL			IsRGB() const { return uchFlags & flagPixiRGB; }
	BOOL			HasAlpha() const { return uchFlags & flagPixiAlpha; }

	BOOL			operator==(const CPixelInfo &pixi) const;
	BOOL			operator!=(const CPixelInfo &pixi) const { return !(*this == pixi); };
	BOOL			operator==(const DDPIXELFORMAT &ddpf) const;
	BOOL			operator!=(const DDPIXELFORMAT &ddpf) const { return !(*this == ddpf); }

	// generic pack
	DWORD			Pack(const BYTE *pPixels) const;
	DWORD			Pack(BYTE r, BYTE g, BYTE b) const;
	DWORD			Pack(BYTE r, BYTE g, BYTE b, BYTE a) const;
	DWORD			Pack(const PALETTEENTRY &pe) const	{ return Pack(pe.peRed, pe.peGreen, pe.peBlue, pe.peFlags); }
	void			UnPack(DWORD dwPixel, BYTE *pR, BYTE *pG, BYTE *pB, BYTE *pA) const;
	void			UnPack(DWORD dwPixel, BYTE *pR, BYTE *pG, BYTE *pB) const;
	DWORD			TranslatePack(DWORD dwSrcPixel, const CPixelInfo &pixiSrcFmt) const;

	// explicit pack
	WORD			Pack16(BYTE r, BYTE g, BYTE b) const;
	WORD			Pack16(BYTE r, BYTE g, BYTE b, BYTE a) const;
	WORD			Pack16(const PALETTEENTRY &pe) const	{ return Pack16(pe.peRed, pe.peGreen, pe.peBlue); }

public:
	BYTE			nBPP, uchFlags;
	BYTE			nRedShift, nRedResidual;
	BYTE			nGreenShift, nGreenResidual;
	BYTE			nBlueShift, nBlueResidual;
	BYTE			nAlphaShift, nAlphaResidual;
	BYTE			iRed, iBlue;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\simpsons\simpview.cpp ===
// SimpView.cpp : implementation of the CSimpsonsView class
//

#define DISABLE_CROSSDOT

#include "stdafx.h"
#include "simpsons.h"
#include "SimpDoc.h"
#include "SimpView.h"
#include "dxtrans.h"
#include "dxhelper.h"

#include <mmsystem.h>

#define fZOOMFACTOR 0.03f
#define fSCALEMIN 0.4f
#define fSCALEMAX 2.5f

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Flatten to an error of 2/3.  During initial phase, use 18.14 format.

#define TEST_MAGNITUDE_INITIAL    (6 * 0x00002aa0L)

// Error of 2/3.  During normal phase, use 15.17 format.

#define TEST_MAGNITUDE_NORMAL     (TEST_MAGNITUDE_INITIAL << 3)

// 'FIX' is a 28.4 fixed point type:

#define FIX_SCALE 16
typedef LONG FIX;
typedef POINT POINTFIX;
typedef struct _RECTFX
{
    FIX   xLeft;
    FIX   yTop;
    FIX   xRight;
    FIX   yBottom;
} RECTFX, *PRECTFX;

#define MIN(A,B)    ((A) < (B) ?  (A) : (B))
#define MAX(A,B)    ((A) > (B) ?  (A) : (B))
#define ABS(A)      ((A) <  0  ? -(A) : (A))

// Hacky macro which returns the current test case's attribute array

#define ThisTestCase (TC::testCases[m_testCaseNumber])

// Test case combinations
//
// We enumerate every test case in a table so that we can cycle through
// all of them.

namespace TC {
    // Names for each test case attribute
    enum {At_Library, At_Source, At_Destination, At_Aliasing};
    const char *AttributeStr[] = {
        "Library", "Source", "Dest", "Aliasing"
    };
    const int NumAttributes = (sizeof(AttributeStr)/sizeof(AttributeStr[0]));
    typedef int TestCase[NumAttributes];
    
    // For each attribute, names for each option:
    enum {Meta, GDIP, GDI};                           // At_Library
    enum {Native, FromMetafile, CreatePoly, PathAPI}; // At_Source
    enum {Memory, Screen, ToMetafile};                // At_Destination
    enum {Aliased, Antialiased};                      // At_Aliasing

    const char *OptionStr[NumAttributes][4] = {
        "Meta", "GDI+", "GDI", "",
        "Native", "Metafile", "CreatePoly", "PathAPI",
        "Memory", "Screen", "Metafile", "",
        "Aliased", "AA", "", ""
    };

    // Supported options for each library:
    //
    // GDI+:  At_Source      - Native, FromMetafile, PathAPI
    //        At_Destination - Memory, Screen, ToMetafile
    //        At_Aliasing    - Aliased, Antialiased
    //
    // Meta:  At_Source      - Native
    //        At_Destination - Memory, Screen
    //        At_Aliasing    - Antialiased
    //
    // GDI:   At_Source      - PathAPI, CreatePoly, FromMetafile
    //        At_Destination - Memory, Screen, ToMetafile
    //        At_Aliasing    - Aliased
    
    const TestCase testCases[] = {
    //  Library  Source         Destination  Aliasing
        GDIP,    Native,        Memory,      Antialiased,
        GDIP,    Native,        Screen,      Antialiased,
        GDIP,    Native,        Memory,      Aliased,
        GDIP,    Native,        Screen,      Aliased,

        GDIP,    Native,        ToMetafile,  Antialiased,
        GDIP,    FromMetafile,  Memory,      Antialiased,
        
        GDIP,    PathAPI,       Memory,      Antialiased,

        Meta,    Native,        Memory,      Antialiased,
        Meta,    Native,        Screen,      Antialiased,
                               
        GDI,     CreatePoly,    Memory,      Aliased,
        GDI,     CreatePoly,    Screen,      Aliased,

        GDI,     CreatePoly,    ToMetafile,  Aliased,
        GDI,     FromMetafile,  Memory,      Aliased,
        
        GDI,     PathAPI,       Memory,      Aliased,
    };
    const int numTestCases = (sizeof(testCases)/(sizeof(testCases[0])));
};

// Test results, used when we cycle automatically through all test combinations
// Hack: This should be a member of CSimpsonView, but I kept it here to reduce
// compile time when we add a test case.

DWORD timingResults[TC::numTestCases];

// IncrementAttribute(int): Changes the rendering attributes
//   Advances to the next test case which is different in the given
//   attribute. Unless the attribute is TC::At_Library, will only advance to a 
//   case which is identical in all other attributes.
//
//   If there is none, doesn't do anything.
//
// Returns: false if the test case didn't change

bool CSimpsonsView::IncrementAttribute(int attribute) {
    int startValue=m_testCaseNumber;
    int i;

    while (1) {
        // Increment the test case number, with wraparound
        m_testCaseNumber++;
        if (m_testCaseNumber >= TC::numTestCases) m_testCaseNumber = 0;

        // If we've returned to the case we started on, no suitable
        // case was found
        if (m_testCaseNumber == startValue) return false;

        // Continue searching if the attribute for this case is the same
        if (TC::testCases[startValue][attribute] == 
            TC::testCases[m_testCaseNumber][attribute]) continue;

        // If we're incrementing the library attribute, we've found what
        // we need. 
        if (attribute == TC::At_Library) break;

        // Otherwise, we need to continue if this case isn't identical
        // in the other attributes
        
        for (i=0; i<TC::NumAttributes; i++) {
            if (i==attribute) continue;
            if (TC::testCases[startValue][i] !=
                TC::testCases[m_testCaseNumber][i]) break;
        }

        // If all other attributes were identical, end the search
        if (i==TC::NumAttributes) break;
    }
    
    return true;
}

// IncrementTest(): Cycles through the possible combinations of attributes
//   Each call changes one of the test attributes.
//   Returns true when the cycle is done.

bool CSimpsonsView::IncrementTest() {
    UpdateStatusMessage();

    // Store the timing for the current test.
    timingResults[m_testCaseNumber] = m_dwRenderTime;

    m_testCaseNumber++;
    if (m_testCaseNumber == TC::numTestCases) m_testCaseNumber = 0;

    return m_testCaseNumber==0;
}

void CSimpsonsView::PrintTestResults() {
    int i,j;

    printf("\n");
    for (i=0;i<TC::NumAttributes;i++) {
        printf("%-11s", TC::AttributeStr[i]);
    }
    printf("   Time\n\n");

    for (i=0;i<TC::numTestCases;i++) {
        for (j=0;j<TC::NumAttributes;j++) {
            printf("%-11s", TC::OptionStr[j][TC::testCases[i][j]]);
        }
        printf("   %dms\n", timingResults[i]);
    }
    printf("\n");
};

DWORD g_aColors[] =
{
    0xFF000000,
    0xFF0000FF,
    0xFF00FF00,
    0xFF00FFFF,
    0xFFFF0000,
    0xFFFF00FF,
    0xFFFFFF00,
    0xFFFFFFFF,
    0xFFAAAAAA,
    0xFF444444
};
const ULONG NumColors = sizeof(g_aColors) / sizeof(g_aColors[0]);
ULONG g_ulColorIndex = 8;

/**********************************Class***********************************\
* class HFDBASIS32
*
*   Class for HFD vector objects.
*
* Public Interface:
*
*   vInit(p1, p2, p3, p4)       - Re-parameterizes the given control points
*                                 to our initial HFD error basis.
*   vLazyHalveStepSize(cShift)  - Does a lazy shift.  Caller has to remember
*                                 it changes 'cShift' by 2.
*   vSteadyState(cShift)        - Re-parameterizes to our working normal
*                                 error basis.
*
*   vTakeStep()                 - Forward steps to next sub-curve
*   vHalveStepSize()            - Adjusts down (subdivides) the sub-curve
*   vDoubleStepSize()           - Adjusts up the sub-curve
*   lError()                    - Returns error if current sub-curve were
*                                 to be approximated using a straight line
*                                 (value is actually multiplied by 6)
*   fxValue()                   - Returns rounded coordinate of first point in
*                                 current sub-curve.  Must be in steady
*                                 state.
*
* History:
*  10-Nov-1990 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

class HFDBASIS32
{
private:
    LONG  e0;
    LONG  e1;
    LONG  e2;
    LONG  e3;

public:
    VOID  vInit(FIX p1, FIX p2, FIX p3, FIX p4);
    VOID  vLazyHalveStepSize(LONG cShift);
    VOID  vSteadyState(LONG cShift);
    VOID  vHalveStepSize();
    VOID  vDoubleStepSize();
    VOID  vTakeStep();

    LONG  lParentErrorDividedBy4() { return(MAX(ABS(e3), ABS(e2 + e2 - e3))); }
    LONG  lError()                 { return(MAX(ABS(e2), ABS(e3))); }
    FIX   fxValue()                { return((e0 + (1L << 12)) >> 13); }
};

/**********************************Class***********************************\
* class BEZIER32
*
*   Bezier cracker.
*
* A hybrid cubic Bezier curve flattener based on KirkO's error factor.
* Generates line segments fast without using the stack.  Used to flatten
* a path.
*
* For an understanding of the methods used, see:
*
*     Kirk Olynyk, "..."
*     Goossen and Olynyk, "System and Method of Hybrid Forward
*         Differencing to Render Bezier Splines"
*     Lien, Shantz and Vaughan Pratt, "Adaptive Forward Differencing for
*     Rendering Curves and Surfaces", Computer Graphics, July 1987
*     Chang and Shantz, "Rendering Trimmed NURBS with Adaptive Forward
*         Differencing", Computer Graphics, August 1988
*     Foley and Van Dam, "Fundamentals of Interactive Computer Graphics"
*
* This algorithm is protected by U.S. patents 5,363,479 and 5,367,617.
*
* Public Interface:
*
*   vInit(pptfx)                - pptfx points to 4 control points of
*                                 Bezier.  Current point is set to the first
*                                 point after the start-point.
*   BEZIER32(pptfx)             - Constructor with initialization.
*   vGetCurrent(pptfx)          - Returns current polyline point.
*   bCurrentIsEndPoint()        - TRUE if current point is end-point.
*   vNext()                     - Moves to next polyline point.
*
* History:
*  1-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

class BEZIER32
{
public:
    LONG       cSteps;
    HFDBASIS32 x;
    HFDBASIS32 y;
    RECTFX     rcfxBound;

    BOOL bInit(POINTFIX* aptfx, RECTFX*);
    BOOL bNext(POINTFIX* pptfx);
};


#define INLINE inline

INLINE BOOL bIntersect(RECTFX* prcfx1, RECTFX* prcfx2)
{
    BOOL bRet = (prcfx1->yTop <= prcfx2->yBottom &&
                 prcfx1->yBottom >= prcfx2->yTop &&
                 prcfx1->xLeft <= prcfx2->xRight &&
                 prcfx1->xRight >= prcfx2->xLeft);
    return(bRet);
}

INLINE VOID vBoundBox(POINTFIX* aptfx, RECTFX* prcfx)
{
    if (aptfx[0].x >= aptfx[1].x)
        if (aptfx[2].x >= aptfx[3].x)
        {
            prcfx->xLeft  = MIN(aptfx[1].x, aptfx[3].x);
            prcfx->xRight = MAX(aptfx[0].x, aptfx[2].x);
        }
        else
        {
            prcfx->xLeft  = MIN(aptfx[1].x, aptfx[2].x);
            prcfx->xRight = MAX(aptfx[0].x, aptfx[3].x);
        }
    else
        if (aptfx[2].x <= aptfx[3].x)
        {
            prcfx->xLeft  = MIN(aptfx[0].x, aptfx[2].x);
            prcfx->xRight = MAX(aptfx[1].x, aptfx[3].x);
        }
        else
        {
            prcfx->xLeft  = MIN(aptfx[0].x, aptfx[3].x);
            prcfx->xRight = MAX(aptfx[1].x, aptfx[2].x);
        }

    if (aptfx[0].y >= aptfx[1].y)
        if (aptfx[2].y >= aptfx[3].y)
        {
            prcfx->yTop    = MIN(aptfx[1].y, aptfx[3].y);
            prcfx->yBottom = MAX(aptfx[0].y, aptfx[2].y);
        }
        else
        {
            prcfx->yTop    = MIN(aptfx[1].y, aptfx[2].y);
            prcfx->yBottom = MAX(aptfx[0].y, aptfx[3].y);
        }
    else
        if (aptfx[2].y <= aptfx[3].y)
        {
            prcfx->yTop    = MIN(aptfx[0].y, aptfx[2].y);
            prcfx->yBottom = MAX(aptfx[1].y, aptfx[3].y);
        }
        else
        {
            prcfx->yTop    = MIN(aptfx[0].y, aptfx[3].y);
            prcfx->yBottom = MAX(aptfx[1].y, aptfx[2].y);
        }
}

INLINE VOID HFDBASIS32::vInit(FIX p1, FIX p2, FIX p3, FIX p4)
{
// Change basis and convert from 28.4 to 18.14 format:

    e0 = (p1                     ) << 10;
    e1 = (p4 - p1                ) << 10;
    e2 = (3 * (p2 - p3 - p3 + p4)) << 11;
    e3 = (3 * (p1 - p2 - p2 + p3)) << 11;
}

INLINE VOID HFDBASIS32::vLazyHalveStepSize(LONG cShift)
{
    e2 = (e2 + e3) >> 1;
    e1 = (e1 - (e2 >> cShift)) >> 1;
}

INLINE VOID HFDBASIS32::vSteadyState(LONG cShift)
{
// We now convert from 18.14 fixed format to 15.17:

    e0 <<= 3;
    e1 <<= 3;

    register LONG lShift = cShift - 3;

    if (lShift < 0)
    {
        lShift = -lShift;
        e2 <<= lShift;
        e3 <<= lShift;
    }
    else
    {
        e2 >>= lShift;
        e3 >>= lShift;
    }
}

INLINE VOID HFDBASIS32::vHalveStepSize()
{
    e2 = (e2 + e3) >> 3;
    e1 = (e1 - e2) >> 1;
    e3 >>= 2;
}

INLINE VOID HFDBASIS32::vDoubleStepSize()
{
    e1 += e1 + e2;
    e3 <<= 2;
    e2 = (e2 << 3) - e3;
}

INLINE VOID HFDBASIS32::vTakeStep()
{
    e0 += e1;
    register LONG lTemp = e2;
    e1 += lTemp;
    e2 += lTemp - e3;
    e3 = lTemp;
}

typedef struct _BEZIERCONTROLS {
    POINTFIX ptfx[4];
} BEZIERCONTROLS;

BOOL BEZIER32::bInit(
POINTFIX* aptfxBez,     // Pointer to 4 control points
RECTFX* prcfxClip)      // Bound box of visible region (optional)
{
    POINTFIX aptfx[4];
    LONG cShift = 0;    // Keeps track of 'lazy' shifts

    cSteps = 1;         // Number of steps to do before reach end of curve

    vBoundBox(aptfxBez, &rcfxBound);

    *((BEZIERCONTROLS*) aptfx) = *((BEZIERCONTROLS*) aptfxBez);

    {
        register FIX fxOr;
        register FIX fxOffset;

        fxOffset = rcfxBound.xLeft;
        fxOr  = (aptfx[0].x -= fxOffset);
        fxOr |= (aptfx[1].x -= fxOffset);
        fxOr |= (aptfx[2].x -= fxOffset);
        fxOr |= (aptfx[3].x -= fxOffset);

        fxOffset = rcfxBound.yTop;
        fxOr |= (aptfx[0].y -= fxOffset);
        fxOr |= (aptfx[1].y -= fxOffset);
        fxOr |= (aptfx[2].y -= fxOffset);
        fxOr |= (aptfx[3].y -= fxOffset);

    // This 32 bit cracker can only handle points in a 10 bit space:

        if ((fxOr & 0xffffc000) != 0)
            return(FALSE);
    }

    x.vInit(aptfx[0].x, aptfx[1].x, aptfx[2].x, aptfx[3].x);
    y.vInit(aptfx[0].y, aptfx[1].y, aptfx[2].y, aptfx[3].y);

    if (prcfxClip == (RECTFX*) NULL || bIntersect(&rcfxBound, prcfxClip))
    {
        while (TRUE)
        {
            register LONG lTestMagnitude = TEST_MAGNITUDE_INITIAL << cShift;

            if (x.lError() <= lTestMagnitude && y.lError() <= lTestMagnitude)
                break;

            cShift += 2;
            x.vLazyHalveStepSize(cShift);
            y.vLazyHalveStepSize(cShift);
            cSteps <<= 1;
        }
    }

    x.vSteadyState(cShift);
    y.vSteadyState(cShift);

// Note that this handles the case where the initial error for
// the Bezier is already less than TEST_MAGNITUDE_NORMAL:

    x.vTakeStep();
    y.vTakeStep();
    cSteps--;

    return(TRUE);
}

BOOL BEZIER32::bNext(POINTFIX* pptfx)
{
// Return current point:

    pptfx->x = x.fxValue() + rcfxBound.xLeft;
    pptfx->y = y.fxValue() + rcfxBound.yTop;

// If cSteps == 0, that was the end point in the curve!

    if (cSteps == 0)
        return(FALSE);

// Okay, we have to step:

    if (MAX(x.lError(), y.lError()) > TEST_MAGNITUDE_NORMAL)
    {
        x.vHalveStepSize();
        y.vHalveStepSize();
        cSteps <<= 1;
    }

    while (!(cSteps & 1) &&
           x.lParentErrorDividedBy4() <= (TEST_MAGNITUDE_NORMAL >> 2) &&
           y.lParentErrorDividedBy4() <= (TEST_MAGNITUDE_NORMAL >> 2))
    {
        x.vDoubleStepSize();
        y.vDoubleStepSize();
        cSteps >>= 1;
    }

    cSteps--;
    x.vTakeStep();
    y.vTakeStep();

    return(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// CSimpsonsView

IMPLEMENT_DYNCREATE(CSimpsonsView, CView)

BEGIN_MESSAGE_MAP(CSimpsonsView, CView)
    //{{AFX_MSG_MAP(CSimpsonsView)
    ON_WM_SIZE()
    ON_WM_LBUTTONUP()
    ON_WM_LBUTTONDOWN()
    ON_WM_KEYDOWN()
    ON_WM_RBUTTONDOWN()
    ON_WM_MOUSEMOVE()
    ON_WM_MOUSEWHEEL()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSimpsonsView construction/destruction

CSimpsonsView::CSimpsonsView()
: m_sizWin(0, 0)
{
    m_pDD = NULL;
    m_pddsScreen = NULL;
    m_pSurfFactory = NULL;
    m_pDX2D = NULL;
    m_pDX2DScreen = NULL;
    m_pDX2DDebug = NULL;
    m_CycleTests = false;
    m_testCaseNumber = 0;
    m_bIgnoreStroke = m_bIgnoreFill = false;
    m_dwRenderTime = 0;
    m_gpPathArray = NULL;

    m_XForm.SetIdentity();
    m_centerPoint.x = m_centerPoint.y = 0;
    m_lastPoint.x = m_lastPoint.y = 0;
    m_tracking = m_scaling = false;
    m_bLButton = false;
}

CSimpsonsView::~CSimpsonsView()
{
    if (m_gpPathArray) delete [] m_gpPathArray;

    MMRELEASE(m_pDD);
    MMRELEASE(m_pddsScreen);
    MMRELEASE(m_pSurfFactory);
    MMRELEASE(m_pDX2D);
    MMRELEASE(m_pDX2DScreen);
    MMRELEASE(m_pDX2DDebug);
    CoUninitialize();
}


BOOL 
CSimpsonsView::PreCreateWindow(CREATESTRUCT &cs) 
{
    HRESULT hr = S_OK;
    IDXTransformFactory *pTranFact = NULL;
    IDirectDrawFactory *pDDrawFact = NULL;
    IDirectDraw *pDD = NULL;
    
    if (CView::PreCreateWindow(cs) == false)
        return false;

    CHECK_HR(hr = CoInitialize(NULL));
    
    //--- Create the transform factory
    CHECK_HR(hr = ::CoCreateInstance(CLSID_DXTransformFactory, NULL, CLSCTX_INPROC,
                        IID_IDXTransformFactory, (void **) &pTranFact));
    
    CHECK_HR(hr = ::CoCreateInstance(CLSID_DX2D, NULL, CLSCTX_INPROC,
                        IID_IDX2D, (void **) &m_pDX2D));
    
    CHECK_HR(hr = ::CoCreateInstance(CLSID_DX2D, NULL, CLSCTX_INPROC,
                        IID_IDX2D, (void **) &m_pDX2DScreen));

/*  m_pDX2D->QueryInterface(IID_IDX2DDebug, (void **) &m_pDX2DDebug);*/
    
    CHECK_HR(hr = m_pDX2D->SetTransformFactory(pTranFact));
    CHECK_HR(hr = m_pDX2DScreen->SetTransformFactory(pTranFact));
    
    CHECK_HR(hr = pTranFact->QueryInterface(IID_IDXSurfaceFactory, (void **) &m_pSurfFactory));
    
    //--- Create the direct draw object
    CHECK_HR(hr = ::CoCreateInstance(CLSID_DirectDrawFactory, NULL, CLSCTX_INPROC,
                        IID_IDirectDrawFactory, (void **) &pDDrawFact));
    
    CHECK_HR(hr = pDDrawFact->CreateDirectDraw( NULL, m_hWnd, DDSCL_NORMAL, 0, NULL, &pDD));
    CHECK_HR(hr = pDD->QueryInterface( IID_IDirectDraw3, (void **) &m_pDD));
    
    // Create the primary ddraw surface (m_pddsScreen)
    
    DDSURFACEDESC ddsd; 
    ZeroMemory(&ddsd, sizeof(ddsd)); 
    ddsd.dwSize = sizeof(ddsd); 
    ddsd.dwFlags = DDSD_CAPS; 
    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE; 
                     
    CHECK_HR(hr = m_pDD->CreateSurface(&ddsd, &m_pddsScreen, NULL));
    CHECK_HR(hr = m_pDX2DScreen->SetSurface(m_pddsScreen));

e_Exit:
    MMRELEASE(pTranFact);
    MMRELEASE(pDDrawFact);
    MMRELEASE(pDD);
    
    return (hr == S_OK);
}


/////////////////////////////////////////////////////////////////////////////
// CSimpsonsView drawing

void 
CSimpsonsView::OnSize(UINT nType, int cx, int cy) 
{
//  MMTRACE("OnSize\n");
    m_centerPoint.x = cx / 2;
    m_centerPoint.y = cy / 2;
    CView::OnSize(nType, cx, cy);
}

HRESULT
CSimpsonsView::Resize(DWORD nX, DWORD nY)
{
//  MMTRACE("Resize\n");
    HRESULT hr;
    IDirectDrawSurface *pdds = NULL;
    CDXDBnds Bnds;

    MMASSERT(nX && nY);

    // store the new size
    m_sizWin.cx = nX;
    m_sizWin.cy = nY;
    Bnds.SetXYSize(m_sizWin);
    
    CHECK_HR(hr = m_pSurfFactory->CreateSurface(m_pDD, NULL, &DDPF_PMARGB32, &Bnds, 0,
                        NULL, IID_IDXSurface, (void **) &pdds));
    CHECK_HR(hr = m_pDX2D->SetSurface(pdds));

    // render the image to the backbuffer
    CHECK_HR(hr = Render(true));

    // Hack: Get the client rect in screen coordinates. My hacky way of doing
    // this is to get the window rect and adjust it.
    GetWindowRect(&m_clientRectHack);
    
    m_clientRectHack.left  += 2; m_clientRectHack.top    += 2;
    m_clientRectHack.right -= 2; m_clientRectHack.bottom -= 2;
    CHECK_HR(hr = m_pDX2DScreen->SetClipRect(&m_clientRectHack));

e_Exit:
    MMRELEASE(pdds);

    return hr;
}


void 
CSimpsonsView::OnDraw(CDC *pDC)
{
//  MMTRACE("OnDraw\n");

    HRESULT hr;
    HDC hdcSurf = NULL;
    IDirectDrawSurface *pdds = NULL;
    DDSURFACEDESC ddsd;
    RECT rDim;

    UpdateStatusMessage();
    
    // get the size of the invalid area
    GetClientRect(&rDim);
    if ((rDim.left == rDim.right) || (rDim.top == rDim.bottom))
        return;

    CSimpsonsDoc *pDoc = GetDocument();

    // if this is a new document, build the GDI+ path list
    if (pDoc->HasNeverRendered()) BuildGDIPList();
    
    // check if the back buffer has changed size
    if (pDoc->HasNeverRendered() || (rDim.right != m_sizWin.cx) || (rDim.bottom != m_sizWin.cy)) {
        ResetTransform();
        CHECK_HR(hr = Resize(rDim.right, rDim.bottom));
        pDoc->MarkRendered();
    }

    ddsd.dwSize = sizeof(ddsd);

        CHECK_HR(hr = m_pDX2D->GetSurface(IID_IDirectDrawSurface, (void **) &pdds));
        CHECK_HR(hr = pdds->GetSurfaceDesc(&ddsd));
        CHECK_HR(hr = pdds->GetDC(&hdcSurf));
        ::BitBlt(pDC->m_hDC, 0, 0, ddsd.dwWidth, ddsd.dwHeight, hdcSurf, 0, 0, SRCCOPY);

    e_Exit:
        if (hdcSurf) {
            pdds->ReleaseDC( hdcSurf );
        }
        MMRELEASE(pdds);
}

/////////////////////////////////////////////////////////////////////////////
// CSimpsonsView diagnostics

#ifdef _DEBUG
void CSimpsonsView::AssertValid() const
{
    CView::AssertValid();
}

void CSimpsonsView::Dump(CDumpContext& dc) const
{
    CView::Dump(dc);
}

CSimpsonsDoc* CSimpsonsView::GetDocument() // non-debug version is inline
{
    ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CSimpsonsDoc)));
    return (CSimpsonsDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CSimpsonsView message handlers

#include "ddhelper.h"

typedef DWORD FP;
#define nEXPBIAS    127
#define nEXPSHIFTS  23
#define nEXPLSB     (1 << nEXPSHIFTS)
#define maskMANT    (nEXPLSB - 1)
#define FloatToFixedNoScale(nDst, fSrc) MACSTART \
    float fTmp = fSrc; \
    DWORD nRaw = *((FP *) &(fTmp)); \
    if (nRaw < (nEXPBIAS << nEXPSHIFTS)) \
        nDst = 0; \
    else \
        nDst = ((nRaw | nEXPLSB) << 8) >> ((nEXPBIAS + 31) - (nRaw >> nEXPSHIFTS)); \
MACEND

// This routine converts a 'float' to 28.4 fixed point format.

inline FIX
FloatToFix(float f)
{
    FIX i;
    FloatToFixedNoScale(i, f*FIX_SCALE);
    return(i);
}

/*
    Draw a polygon with GDI. This version flattens beziers and packages
    the polygon up into a single polypoly call. (Compare to DrawGDIPolyPathAPI)
*/

void
CSimpsonsView::DrawGDIPoly(HDC hDC, PolyInfo *pPoly)
{
    POINT rgpt[1024];
    DWORD rgcpt[30];
    DWORD cPoints = pPoly->cPoints;
    BEZIER32 bez;
    POINTFIX aptfxBez[4];
    MMASSERT(cPoints);

    DWORD *pcptBuffer;
    POINT *pptBuffer;
    POINT *pptFigure;

    DXFPOINT *pCurPoint = pPoly->pPoints;
    DXFPOINT *pCurPointLimit = pPoly->pPoints + cPoints;
    BYTE *pCurCode = pPoly->pCodes;

    pptBuffer = rgpt;
    pptFigure = rgpt;
    pcptBuffer = rgcpt;

    // In an effort to reduce our per-call overhead, we try to avoid
    // calling GDI's BeginPath/EndPath/FillPath routines, because they
    // just add significant time when the drawing is small.  Instead,
    // we package everything up into PolyPoly calls that will draw
    // immediately.

    while (TRUE)
    {
        if (*pCurCode == PT_BEZIERTO)
        {
            aptfxBez[0].x = FloatToFix((pCurPoint-1)->x);
            aptfxBez[0].y = FloatToFix((pCurPoint-1)->y);
            aptfxBez[1].x = FloatToFix((pCurPoint)->x);
            aptfxBez[1].y = FloatToFix((pCurPoint)->y);
            aptfxBez[2].x = FloatToFix((pCurPoint+1)->x);
            aptfxBez[2].y = FloatToFix((pCurPoint+1)->y);
            aptfxBez[3].x = FloatToFix((pCurPoint+2)->x);
            aptfxBez[3].y = FloatToFix((pCurPoint+2)->y);

            if (bez.bInit(aptfxBez, NULL))
            {
                while (bez.bNext(pptBuffer++))
                    ;
            }

            pCurPoint += 3;
            pCurCode += 3;
        }
        else
        {
            pptBuffer->x = FloatToFix(pCurPoint->x);
            pptBuffer->y = FloatToFix(pCurPoint->y);

            pptBuffer++;
            pCurPoint++;
            pCurCode++;
        }

        if (pCurPoint == pCurPointLimit)
        {
            *pcptBuffer++ = (DWORD)(pptBuffer - pptFigure);
            break;
        }

        if (*pCurCode == PT_MOVETO)
        {
            *pcptBuffer++ = (DWORD)(pptBuffer - pptFigure);
            pptFigure = pptBuffer;
        }
    } 

    if (pPoly->dwFlags & DX2D_FILL)
    {
        if (!m_bNullPenSelected)
        {
            SelectObject(hDC, m_hNullPen);
            m_bNullPenSelected = TRUE;
        }

        PolyPolygon(hDC, rgpt, (INT*) rgcpt, (int) (pcptBuffer - rgcpt));
    }
    else
    {
        if (m_bNullPenSelected)
        {
            SelectObject(hDC, m_hStrokePen);
            m_bNullPenSelected = FALSE;
        }

        PolyPolyline(hDC, rgpt, rgcpt, (DWORD) (pcptBuffer - rgcpt));
    }
}

/*
    Same as DrawGDIPoly, but uses the slow GDI path functions.
*/

void
CSimpsonsView::DrawGDIPolyPathAPI(HDC hDC, PolyInfo *pPoly)
{
    POINTFIX aptfxBez[3];
    POINTFIX pt;

    DXFPOINT *pCurPoint = pPoly->pPoints;
    DXFPOINT *pCurPointLimit = pPoly->pPoints + pPoly->cPoints;
    BYTE *pCurCode = pPoly->pCodes;
    
    BeginPath(hDC);

    while (pCurPoint < pCurPointLimit) {
        switch (*pCurCode) {
        
        case PT_BEZIERTO:
            
            aptfxBez[0].x = FloatToFix((pCurPoint)->x);
            aptfxBez[0].y = FloatToFix((pCurPoint)->y);
            aptfxBez[1].x = FloatToFix((pCurPoint+1)->x);
            aptfxBez[1].y = FloatToFix((pCurPoint+1)->y);
            aptfxBez[2].x = FloatToFix((pCurPoint+2)->x);
            aptfxBez[2].y = FloatToFix((pCurPoint+2)->y);

            PolyBezierTo(hDC, aptfxBez, 3);

            pCurPoint += 3;
            pCurCode += 3;
            break;
        
        case PT_LINETO:
            pt.x = FloatToFix(pCurPoint->x);
            pt.y = FloatToFix(pCurPoint->y);

            PolylineTo(hDC, &pt, 1);

            pCurPoint++;
            pCurCode++;
            break;
        
        case PT_MOVETO:
            MoveToEx(hDC, 
                     FloatToFix(pCurPoint->x), 
                     FloatToFix(pCurPoint->y),
                     NULL);
            pCurPoint++;
            pCurCode++;
            break;
        }
    } 

    EndPath(hDC);

    if (pPoly->dwFlags & DX2D_FILL)
    {
        if (!m_bNullPenSelected)
        {
            SelectObject(hDC, m_hNullPen);
            m_bNullPenSelected = TRUE;
        }
        FillPath(hDC);
    }
    else
    {
        if (m_bNullPenSelected)
        {
            SelectObject(hDC, m_hStrokePen);
            m_bNullPenSelected = FALSE;
        }
        StrokePath(hDC);
    }
}

/*
    Draw the scene using GDI.
*/

void 
CSimpsonsView::DrawAllGDI(HDC hDC)
{
    DWORD nStart, nEnd;

    int dataSource = ThisTestCase[TC::At_Source];

    nStart = timeGetTime();

    HPEN hpenOld;
    HBRUSH hbrushOld;
    HGDIOBJ hBrush;
    
    HDC hdcOutput;

    const RenderCmd *pCurCmd = GetDocument()->GetRenderCommands();

    if (pCurCmd == NULL)
        return;

    PolyInfo *pPoly;
    BrushInfo *pBrush;
    PenInfo *pPen;

    m_hNullPen = (HPEN) GetStockObject(NULL_PEN);
    m_bNullPenSelected = TRUE;

    if (ThisTestCase[TC::At_Destination]==TC::ToMetafile) {
        // Determine the picture frame dimensions. 
        // iWidthMM is the display width in millimeters. 
        // iHeightMM is the display height in millimeters. 
        // iWidthPels is the display width in pixels. 
        // iHeightPels is the display height in pixels 
         
        LONG iWidthMM = GetDeviceCaps(hDC, HORZSIZE); 
        LONG iHeightMM = GetDeviceCaps(hDC, VERTSIZE); 
        LONG iWidthPels = GetDeviceCaps(hDC, HORZRES); 
        LONG iHeightPels = GetDeviceCaps(hDC, VERTRES); 

        // Hack the client rect         
         
        RECT rect={0, 0, 500, 500};
         
        // Convert client coordinates to .01-mm units. 
        // Use iWidthMM, iWidthPels, iHeightMM, and 
        // iHeightPels to determine the number of 
        // .01-millimeter units per pixel in the x- 
        //  and y-directions. 
 
        rect.left = (rect.left * iWidthMM * 100)/iWidthPels; 
        rect.top = (rect.top * iHeightMM * 100)/iHeightPels; 
        rect.right = (rect.right * iWidthMM * 100)/iWidthPels; 
        rect.bottom = (rect.bottom * iHeightMM * 100)/iHeightPels; 
 
        hdcOutput = CreateEnhMetaFile(hDC, "simpgdi.emf", &rect, NULL);
        if (!hdcOutput) { return; }
    } else {
        hdcOutput = hDC;
    }

    if (dataSource==TC::FromMetafile) {
        HENHMETAFILE hemf = GetEnhMetaFile("simpgdi.emf"); 

        if (hemf) {
            RECT rect = {0, 0, 500, 500};
             
            PlayEnhMetaFile(hdcOutput, hemf, &rect);
            DeleteEnhMetaFile(hemf); 
        } else {
            printf("Metafile didn't load!\n");
        }
    } else {
        HGDIOBJ hOldBrush = SelectObject(hdcOutput, GetStockObject(WHITE_BRUSH));
        HGDIOBJ hOldPen = SelectObject(hdcOutput, m_hNullPen);
    
        // Here we set a 1/16th shrinking transform.  We will have to 
        // scale up all the points we give GDI by a factor of 16.
        //
        // We do this because when set in advanced mode, NT's GDI can
        // rasterize with 28.4 precision, and since we have factional
        // coordinates, this will make the result look better on NT.
        //
        // (There will be no difference on Win9x.)
    
        SetGraphicsMode(hdcOutput, GM_ADVANCED);
        SetMapMode(hdcOutput, MM_ANISOTROPIC);
        SetWindowExtEx(hdcOutput, FIX_SCALE, FIX_SCALE, NULL);
        
        for (;pCurCmd->nType != typeSTOP; pCurCmd++) {
            switch (pCurCmd->nType) {
            case typePOLY:
                // draw the polygon
                pPoly = (PolyInfo *) pCurCmd->pvData;
                if (!((m_bIgnoreStroke && (pPoly->dwFlags & DX2D_STROKE)) ||
                        (m_bIgnoreFill && (pPoly->dwFlags & DX2D_FILL))))
                {
                    if (dataSource == TC::PathAPI) {
                        DrawGDIPolyPathAPI(hdcOutput, (PolyInfo *) pCurCmd->pvData);
                    } else {
                        ASSERT(dataSource == TC::CreatePoly);
                        DrawGDIPoly(hdcOutput, (PolyInfo *) pCurCmd->pvData);
                    }
                }
                break;
            case typeBRUSH:
                // select a new brush
                {
                    pBrush = (BrushInfo *) pCurCmd->pvData;
                    DWORD dwColor = pBrush->Color;
                    BYTE r = BYTE(dwColor >> 16);
                    BYTE g = BYTE(dwColor >> 8);
                    BYTE b = BYTE(dwColor);
                    hBrush = CreateSolidBrush(RGB(r,g,b));
                    hbrushOld = (HBRUSH) SelectObject(hdcOutput, hBrush);
                    DeleteObject(hbrushOld);
                }
                break;
            case typePEN: 
                // select a new pen
                {
                    pPen = (PenInfo *) pCurCmd->pvData;
                    DWORD dwColor = pPen->Color;
                    BYTE r = BYTE(dwColor >> 16);
                    BYTE g = BYTE(dwColor >> 8);
                    BYTE b = BYTE(dwColor);
                    hpenOld = m_hStrokePen;
                    m_hStrokePen = CreatePen(PS_SOLID, 
                                             DWORD(pPen->fWidth * FIX_SCALE), 
                                             RGB(r, g, b));
                    if (!m_bNullPenSelected)
                    {
                        SelectObject(hdcOutput, m_hStrokePen);
                    }
                    DeleteObject(hpenOld);
                }
                break;
            }
        }
        
        SetMapMode(hdcOutput, MM_TEXT);
        SetGraphicsMode(hdcOutput, GM_COMPATIBLE);
    
        hbrushOld = (HBRUSH) SelectObject(hdcOutput, hOldBrush);
        hpenOld = (HPEN) SelectObject(hdcOutput, hOldPen);
    
        DeleteObject(hbrushOld);
        DeleteObject(hpenOld);
        DeleteObject(m_hStrokePen);
    }
    
    nEnd = timeGetTime();
    m_dwRenderTime = nEnd-nStart;
    
    if (ThisTestCase[TC::At_Destination]==TC::ToMetafile) {
        DeleteEnhMetaFile(CloseEnhMetaFile(hdcOutput));
    }    
    
}

void
CSimpsonsView::DrawGDIPPoly(Graphics *g, PolyInfo *pPoly, Pen *pen, Brush *brush)
{
    GraphicsPath path(FillModeAlternate);
    
    DXFPOINT *pCurPoint = pPoly->pPoints;
        
    DXFPOINT *pCurPointLimit = pPoly->pPoints + pPoly->cPoints;
    BYTE *pCurCode = pPoly->pCodes;
    
    DXFPOINT currentPosition;

    while (pCurPoint < pCurPointLimit)
    {
        switch (*pCurCode) 
        {
        
        case PT_BEZIERTO:
            path.AddBezier(
                (pCurPoint-1)->x, (pCurPoint-1)->y,
                (pCurPoint)  ->x, (pCurPoint)  ->y,
                (pCurPoint+1)->x, (pCurPoint+1)->y,
                (pCurPoint+2)->x, (pCurPoint+2)->y);

            pCurPoint += 3;
            pCurCode += 3;
            break;

        case PT_MOVETO:
            path.StartFigure();
            pCurPoint++;
            pCurCode++;
            break;
        
        case PT_LINETO:
            path.AddLine(
                (pCurPoint-1)->x, 
                (pCurPoint-1)->y, 
                (pCurPoint)->x,
                (pCurPoint)->y);
            pCurPoint++;
            pCurCode++;
            break;
    
        }
    } 

    if (pPoly->dwFlags & DX2D_FILL)
    {
        g->FillPath(brush, &path);
    }
    else
    {
        g->DrawPath(pen, &path);
    }
}

struct BitmapInfo
{
    BITMAPINFOHEADER    bmiHeader;
    RGBQUAD             bmiColors[256];     // 256 is the maximum palette size
};

/*
    Build an array of GDI+ paths for the current document. 
    This is used as a 'native' data source - so that we don't time path
    creation when rendering. Even in this mode, DrawAllGDIP() still uses the 
    RenderCmd buffer to read pen and brush data.
*/

void 
CSimpsonsView::BuildGDIPList()
{
    // Free the old path array, if any
    if (m_gpPathArray) {
        delete [] m_gpPathArray;
        m_gpPathArray = NULL;
    }

    const RenderCmd *pCmd = GetDocument()->GetRenderCommands();
    const RenderCmd *pCurCmd;

    if (!pCmd) return;
    
    // Count the number of polygons
    int count=0;

    for (pCurCmd=pCmd; pCurCmd->nType != typeSTOP; pCurCmd++) {
        if (pCurCmd->nType == typePOLY) count++;
    }

    m_gpPathArray = new GraphicsPath [count];
    if (!m_gpPathArray) return;

    GraphicsPath *pPath=m_gpPathArray;
    PolyInfo *pPoly;

    // Add each polygon to the path array
    for (pCurCmd=pCmd; pCurCmd->nType != typeSTOP; pCurCmd++) {
        if (pCurCmd->nType==typePOLY) {
            pPoly = (PolyInfo *) pCurCmd->pvData;
    
            DXFPOINT *pCurPoint = pPoly->pPoints;
        
            DXFPOINT *pCurPointLimit = pPoly->pPoints + pPoly->cPoints;
            BYTE *pCurCode = pPoly->pCodes;
    
            DXFPOINT currentPosition;

            while (pCurPoint < pCurPointLimit)
            {
                switch (*pCurCode) {
                
                case PT_BEZIERTO:
                    pPath->AddBezier(
                        (pCurPoint-1)->x, (pCurPoint-1)->y,
                        (pCurPoint)  ->x, (pCurPoint)  ->y,
                        (pCurPoint+1)->x, (pCurPoint+1)->y,
                        (pCurPoint+2)->x, (pCurPoint+2)->y);
        
                    pCurPoint += 3;
                    pCurCode += 3;
                    break;
        
                case PT_MOVETO:
                    pPath->StartFigure();
                    pCurPoint++;
                    pCurCode++;
                    break;
                
                case PT_LINETO:
                    pPath->AddLine(
                        (pCurPoint-1)->x, 
                        (pCurPoint-1)->y, 
                        (pCurPoint)->x,
                        (pCurPoint)->y);
                    pCurPoint++;
                    pCurCode++;
                    break;
            
                }
            } 
            pPath++;
        }
    }
    printf ("BuildGDIPList successful\n");
}

void 
CSimpsonsView::DrawAllGDIP(HDC hDC)
{
    DWORD nStart, nEnd;
    
    // 
    // START TIMING
    // 

    nStart = timeGetTime();
    
    int dataSource = ThisTestCase[TC::At_Source];

    const RenderCmd *pCurCmd = GetDocument()->GetRenderCommands();

    if (pCurCmd == NULL)
        return;

    PolyInfo *pPoly;
    BrushInfo *pBrush;
    PenInfo *pPen;

    GraphicsPath *pPath = NULL;
    
    if (dataSource==TC::Native) {
        pPath = m_gpPathArray;
        if (!pPath) {
            printf("GDI+ Native data is invalid\n");
            return;
        }
    }

    Graphics *gOutput, *g;
    Metafile *recMetafile, *playMetafile;

    g = Graphics::FromHDC(hDC);

    if (ThisTestCase[TC::At_Destination]==TC::ToMetafile) {
        recMetafile = new Metafile(L"simpsons.emf", hDC);
        if (!recMetafile) { delete g; return; }
        gOutput = Graphics::FromImage(recMetafile);
    } else {
        gOutput = g;
    }
    
    if (ThisTestCase[TC::At_Aliasing]==TC::Antialiased) {
        gOutput->SetSmoothingMode(SmoothingModeAntiAlias); 
    } else {
        gOutput->SetSmoothingMode(SmoothingModeNone);
    }

    if (dataSource==TC::FromMetafile) {
        playMetafile = new Metafile(L"simpsons.emf");
        if (playMetafile) {
            GpRectF playbackRect;
            gOutput->GetVisibleClipBounds(&playbackRect);
            gOutput->DrawImage(playMetafile, 0, 0);
        } else {
            printf("Metafile didn't load!\n");
        }
    } else {
    
        Color black(0,0,0);
        Pen currentPen(black, 1);
    
        SolidBrush currentBrush(black);
    
        for (;pCurCmd->nType != typeSTOP; pCurCmd++) {
            switch (pCurCmd->nType) {
            case typePOLY:
                // convert points to fixed point
                
                pPoly = (PolyInfo *) pCurCmd->pvData;
                if (!((m_bIgnoreStroke && (pPoly->dwFlags & DX2D_STROKE)) ||
                        (m_bIgnoreFill && (pPoly->dwFlags & DX2D_FILL))))
                {
                    if (pPath) {
                        // Draw from the pre-created path list
                        if (pPoly->dwFlags & DX2D_FILL)
                        {
                            gOutput->FillPath(&currentBrush, pPath);
                        }
                        else
                        {
                            gOutput->DrawPath(&currentPen, pPath);
                        }
                    } else {
                        ASSERT(dataSource == TC::PathAPI);

                        // Create the path and draw it
                        DrawGDIPPoly(gOutput, (PolyInfo *) pCurCmd->pvData, &currentPen, &currentBrush);
                    }
                }
                
                if(pPath != NULL) pPath++;

                break;
            case typeBRUSH:
                {
                // change brush color
                pBrush = (BrushInfo *) pCurCmd->pvData;
                DWORD dwColor = pBrush->Color;
                BYTE r = BYTE(dwColor >> 16);
                BYTE g = BYTE(dwColor >> 8);
                BYTE b = BYTE(dwColor);
                
                Color c(r,g,b);
                currentBrush.SetColor(c);
                }
                break;
            
            case typePEN: 
    #if 0
                {
                // select a new pen
                pPen = (PenInfo *) pCurCmd->pvData;
                DWORD dwColor = pPen->Color;
                BYTE r = BYTE(dwColor >> 16);
                BYTE g = BYTE(dwColor >> 8);
                BYTE b = BYTE(dwColor);
                
                currentPen.SetPenColor(Color(r,g,b));
                }
    #endif
                break;
    
            }
        }
    }
    
    gOutput->Flush();

    if (ThisTestCase[TC::At_Source]==TC::FromMetafile) {
        delete playMetafile;
    }

    if (ThisTestCase[TC::At_Destination]==TC::ToMetafile) {
        delete gOutput;
        delete recMetafile;
    }
    delete g;
    
    //
    // STOP TIMING
    //

    nEnd = timeGetTime();
    m_dwRenderTime = nEnd-nStart;
}

void
CSimpsonsView::UpdateStatusMessage()
{
    using namespace TC;

    sprintf(g_rgchTmpBuf, "Time: %dms  %s  Src: %s Dst: %s, %s", 
//      GetDocument()->GetFileName(),
        m_dwRenderTime, 
        OptionStr[At_Library][ThisTestCase[At_Library]],
        OptionStr[At_Source][ThisTestCase[At_Source]],
        OptionStr[At_Destination][ThisTestCase[At_Destination]],
        OptionStr[At_Aliasing][ThisTestCase[At_Aliasing]]
    );
//  OutputDebugString(g_rgchTmpBuf);
//  OutputDebugString("\n");

    CFrameWnd *pFrame = GetParentFrame();
    if (pFrame)
        pFrame->SetMessageText(g_rgchTmpBuf);
}

void 
CSimpsonsView::DrawAll(IDX2D *pDX2D)
{
    DWORD nStart, nEnd;

    nStart = timeGetTime();
    
    const RenderCmd *pCurCmd = GetDocument()->GetRenderCommands();

    DXBRUSH Brush;
    DXPEN Pen;

    // intialize Pen and Brush
    Pen.pTexture = NULL;
    Pen.TexturePos.x = 0.f;
    Pen.TexturePos.y = 0.f;
    Brush.pTexture = NULL;
    Brush.TexturePos.x = 0.f;
    Brush.TexturePos.y = 0.f;

    PolyInfo *pPoly;
    BrushInfo *pBrush;
    PenInfo *pPen;

    bool bBrush = false, bPen = false;

    for (;pCurCmd->nType != typeSTOP; pCurCmd++) {
        switch (pCurCmd->nType) {
        case typePOLY:
            pPoly = (PolyInfo *) pCurCmd->pvData;
            if (!((m_bIgnoreStroke && (pPoly->dwFlags & DX2D_STROKE)) ||
                (m_bIgnoreFill && (pPoly->dwFlags & DX2D_FILL))))
            {
                pDX2D->AAPolyDraw(pPoly->pPoints, pPoly->pCodes, pPoly->cPoints, 4, pPoly->dwFlags);
            }
            break;
        case typeBRUSH:
            // select a new brush
            pBrush = (BrushInfo *) pCurCmd->pvData;
            Brush.Color = pBrush->Color;
            pDX2D->SetBrush(&Brush);
            bBrush = true;
            break;
        case typePEN:
            // select a new pen
            pPen = (PenInfo *) pCurCmd->pvData;
            Pen.Color = pPen->Color;
            Pen.Width = pPen->fWidth;
            Pen.Style = pPen->dwStyle;
            pDX2D->SetPen(&Pen);
            bPen = true;
            break;
        }
    }
    nEnd = timeGetTime();
    m_dwRenderTime = nEnd-nStart;
}

HRESULT CSimpsonsView::Render(bool bInvalidate)
{
//  MMTRACE("Render\n");

    RECT rc = {0, 0, 500, 400};
    
    HRESULT hr = S_OK;
    IDirectDrawSurface *pdds = NULL;

    IDXSurface *pDXSurf = NULL;
    HDC screenDC = NULL, drawDC = NULL, memDC = NULL;
    BOOL bFinished = false;

    DWORD executionTime;

    sprintf(g_rgchTmpBuf, "Rendering with %s...", TC::OptionStr[TC::At_Library][ThisTestCase[TC::At_Library]]);
    CFrameWnd *pFrame = GetParentFrame();
    if (pFrame) {
        pFrame->SetMessageText(g_rgchTmpBuf);
    }

    CHECK_HR(hr = m_pDX2D->GetSurface(IID_IDXSurface, (void **) &pDXSurf));
    CHECK_HR(hr = pDXSurf->GetDirectDrawSurface(IID_IDirectDrawSurface, (void **) &pdds));
    
    while (!bFinished) {
        DXFillSurface(pDXSurf, g_aColors[g_ulColorIndex]);
    
        //--- Set alias mode
    //  CHECK_HR(hr = m_pDX2D->_SetDelegateToGDI(m_bAliased));
    
        //--- Set global opacity
    //  CHECK_HR(hr = m_pDX2D->SetGlobalOpacity(1.f));
    
        CHECK_HR(hr = m_pDX2D->SetWorldTransform(&m_XForm));
        
        CDX2DXForm xform;
        xform = m_XForm;
        xform.Translate((REAL)m_clientRectHack.left, (REAL)m_clientRectHack.top);
        
        CHECK_HR(hr = m_pDX2DScreen->SetWorldTransform(&xform));
    
        //--- Get the DC of the DD surface.
        CHECK_HR(hr = pdds->GetDC(&memDC));
    
        // render the scene and compute timing
    
        // Set the timer resolution to 1ms
        if (timeBeginPeriod(1)==TIMERR_NOCANDO) {
            hr = ERROR_INVALID_FUNCTION;
            goto e_Exit;
        }
        
        /*
            For the direct-to-screen cases, we bypass the ddraw surface.
            For repaints to look pretty, though, we copy the result to the ddraw
            surface (after the timer has been turned off.)
        */
    
        drawDC = memDC;
        HBRUSH backgroundBrush;
        
        if (ThisTestCase[TC::At_Destination]==TC::Screen) {
            screenDC = ::GetDC(m_hWnd);
            backgroundBrush = CreateSolidBrush(g_aColors[g_ulColorIndex] & 0xffffff);
            FillRect(screenDC, &rc, backgroundBrush);
            DeleteObject(backgroundBrush);
            drawDC = screenDC;
        }
    
        // The 'DrawAll' routine will actually do the timeGetTime() and store the
        // result in m_dwRenderTime.
    
        switch (ThisTestCase[TC::At_Library]) {
        case TC::GDI:
            DrawAllGDI(drawDC);
            break;
        case TC::Meta:
            if (ThisTestCase[TC::At_Destination]==TC::Screen) {
                DrawAll(m_pDX2DScreen);
            } else {
                DrawAll(m_pDX2D);
            }
            break;
        case TC::GDIP:
            DrawAllGDIP(drawDC);
            break;  
        }

        // !!! Release and re-acquire the DDraw surface DC to work-around
        //     a current limitation in GDI+ where Graphics(hdc) nukes the
        //     hdc of a DDraw surface

        pdds->ReleaseDC(memDC); memDC = NULL;
        CHECK_HR(hr = pdds->GetDC(&memDC));
    
        if (ThisTestCase[TC::At_Destination]==TC::Screen) {
            bInvalidate = false;
            UpdateStatusMessage();
    
            // Copy to from the screen to the ddraw surface, 
            // so that repaints work.
            ::BitBlt(memDC, 0, 0, 500, 400, screenDC, 0, 0, SRCCOPY);
            
        }
        
        timeEndPeriod(1); // Reset the multimedia timer to default resolution
        
        pdds->ReleaseDC(memDC); memDC = NULL;
        
        if (screenDC) {
            ::ReleaseDC(m_hWnd, screenDC);
            screenDC = NULL;
        }
        
        if (m_CycleTests) {
            bFinished = IncrementTest();
        } else {
            bFinished = true;
        }
    
    }
    
e_Exit:
    //--- Clean-up
    if (pdds) {
        if (memDC) 
            pdds->ReleaseDC(memDC);
        MMRELEASE(pdds);
    }
    if (screenDC) {
        ::ReleaseDC(m_hWnd, screenDC);
    }
    MMRELEASE(pDXSurf);
        
    //--- draw
    if (bInvalidate)
        Invalidate();
    
    return hr;
}

void CSimpsonsView::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
    bool bNothing = false;
    float fTheta = 1.f;
    if (nChar == 'G') {
        ToggleGDI();
    } else if (nChar == 'A') {
        bNothing = !IncrementAttribute(TC::At_Aliasing);
    } else if (nChar == 'D') {
        bNothing = !IncrementAttribute(TC::At_Destination);
    } else if (nChar == 'I') {
        IncrementTest();
    } else if ((nChar >= '0') && (nChar <= '9')) {
        g_ulColorIndex = (nChar - '0');
    } else if (nChar == ' ') {
        // Redraw
    } else if (nChar == 'R') {
        ResetTransform();
    } else if (nChar == 'F') {
        ToggleFill();
    } else if (nChar == 'S') {
        ToggleStroke();
    } else if (nChar == 'C') {
        m_CycleTests = true;
        m_testCaseNumber = 0;
        if (m_pDX2DDebug) m_pDX2DDebug->SetDC(NULL);
    } else if (nChar == VK_LEFT) {
        AddRotation(fTheta);
    } else if (nChar == VK_RIGHT) {
        AddRotation(-fTheta);
    } else {
        bNothing = true;
    }

    if (!bNothing)
        Render(true);

    if (m_CycleTests) {
        PrintTestResults();
        m_CycleTests = false;
    }
    
    CView::OnKeyDown(nChar, nRepCnt, nFlags);
}

void
CSimpsonsView::ToggleStroke()
{
    m_bIgnoreStroke ^= 1;
}

void
CSimpsonsView::ToggleFill()
{
    m_bIgnoreFill ^= 1;
}

void
CSimpsonsView::ResetTransform()
{
    m_XForm.SetIdentity();
}

void
CSimpsonsView::AddRotation(float fTheta)
{
    m_XForm.Rotate(fTheta);
}



void
CSimpsonsView::ToggleGDI()
{
    HRESULT hr = S_OK;
    IDXSurface *pdxsRender = NULL;
    IDirectDrawSurface *pddsRender = NULL;
    HDC hDC = NULL;

    IncrementAttribute(TC::At_Library);
    
    if (m_pDX2DDebug) {
        switch (ThisTestCase[TC::At_Library]) {
        case TC::GDI:
        case TC::GDIP:
            CHECK_HR(hr = m_pDX2D->GetSurface(IID_IDXSurface, (void**) &pdxsRender));
            CHECK_HR(hr = pdxsRender->QueryInterface(IID_IDirectDrawSurface, (void **) &pddsRender));
            CHECK_HR(hr = pddsRender->GetDC(&hDC));
            m_pDX2DDebug->SetDC(hDC);
            break;
        
        case TC::Meta:
            m_pDX2DDebug->SetDC(NULL);
            break;
        }
    }

e_Exit:
    if (pddsRender && hDC)
        pddsRender->ReleaseDC(hDC);
    MMRELEASE(pddsRender);
    MMRELEASE(pdxsRender);
}


void 
CSimpsonsView::OnLButtonDown(UINT nFlags, CPoint pt) 
{
    CView::OnLButtonDown(nFlags, pt);
}

 
void 
CSimpsonsView::OnRButtonDown(UINT nFlags, CPoint point) 
{
    CView::OnRButtonDown(nFlags, point);
}


void 
CSimpsonsView::ForceUpdate()
{
    HRESULT hr;
    Render(false);

    HDC hdcSurf = NULL;
    IDirectDrawSurface *pdds = NULL;
    DDSURFACEDESC ddsd;
    CDC *pDC = GetDC();

    ddsd.dwSize = sizeof(ddsd);

    CHECK_HR(hr = m_pDX2D->GetSurface(IID_IDirectDrawSurface, (void **) &pdds));
    CHECK_HR(hr = pdds->GetSurfaceDesc(&ddsd));
    CHECK_HR(hr = pdds->GetDC(&hdcSurf));
    ::BitBlt(pDC->m_hDC, 0, 0, ddsd.dwWidth, ddsd.dwHeight, hdcSurf, 0, 0, SRCCOPY);

    UpdateStatusMessage();

e_Exit:
    if (pdds && hdcSurf)
        pdds->ReleaseDC(hdcSurf);
    MMRELEASE(pdds);
}

void
CSimpsonsView::DoMove(POINT &pt)
{
    if ((m_lastPoint.x != pt.x) && (m_lastPoint.y != pt.y)) {
        float dx = float(pt.x - m_lastPoint.x);
        float dy = float(pt.y - m_lastPoint.y);

        if (m_scaling) {
            float scale = 1.f + dx * fZOOMFACTOR;
            CLAMP(scale, fSCALEMIN, fSCALEMAX);
            m_XForm.Translate(float(-m_centerPoint.x), float(-m_centerPoint.y));
            m_XForm.Scale(scale, scale);
            m_XForm.Translate(float(m_centerPoint.x), float(m_centerPoint.y));
        } else {
            // panning
            m_XForm.Translate(dx, dy);
        }
        
        ForceUpdate();
        m_lastPoint = pt;
    }
}



void 
CSimpsonsView::OnLButtonUp(UINT nFlags, CPoint ptPassed) 
{
    POINT pt;
    GetCursorPos(&pt);
    ScreenToClient(&pt);

    DoMove(pt);

    CView::OnLButtonUp(nFlags, pt);
}


void 
CSimpsonsView::OnMouseMove(UINT nFlagsPassed, CPoint ptPassed)
{
    // get current mouse position
    POINT pt;
    GetCursorPos(&pt);
    ScreenToClient(&pt);

    // check if left mouse button is down
    m_tracking = (GetAsyncKeyState(VK_LBUTTON) && (m_bLButton || IsInside(pt.x, pt.y, m_sizWin)));
    if (m_tracking) {
        if (m_bLButton) {
            DoMove(pt);
        } else {
            m_scaling = ((GetAsyncKeyState(VK_CONTROL) & ~0x1) != 0);
            m_bLButton = true;
            m_centerPoint = pt;
            m_lastPoint = pt;
        }
    }
    m_bLButton = m_tracking;

    CView::OnMouseMove(nFlagsPassed, ptPassed);
}


BOOL 
CSimpsonsView::OnMouseWheel(UINT nFlags, short zDelta, CPoint pt) 
{
    float fDelta = float (zDelta / 1200.f);
    float fScale = 1.f - fDelta;
    CLAMP(fScale, fSCALEMIN, fSCALEMAX);

    m_XForm.Translate(float(-m_centerPoint.x), float(-m_centerPoint.y));
    m_XForm.Scale(fScale, fScale);
    m_XForm.Translate(float(m_centerPoint.x), float(m_centerPoint.y));

    ForceUpdate();

    return CView::OnMouseWheel(nFlags, zDelta, pt);
}

_cdecl
main(INT argc, PCHAR argb[])
{
    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\texttest\afxres.h ===
//
//      Copyright(c) 1996 - 1999. Microsoft Corporation.
//

// afxres.h

#include <windows.h>
#undef _WIN32
#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\simpsons\simpsons.cpp ===
// simpsons.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "simpsons.h"

#include "MainFrm.h"
#include "SimpDoc.h"
#include "SimpView.h"
#include <DXTrans.h>
#include <dxtguid.c>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "../gpinit.inc"

/////////////////////////////////////////////////////////////////////////////
// CSimponsApp

BEGIN_MESSAGE_MAP(CSimponsApp, CWinApp)
    //{{AFX_MSG_MAP(CSimponsApp)
    ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG_MAP
    // Standard file based document commands
    ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
    ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSimponsApp construction

CSimponsApp::CSimponsApp()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
}

CSimponsApp::~CSimponsApp()
{
}


/////////////////////////////////////////////////////////////////////////////
// The one and only CSimponsApp object

CSimponsApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CSimponsApp initialization

BOOL CSimponsApp::InitInstance()
{
    if (!gGdiplusInitHelper.IsValid())
    {
        return FALSE;
    }

    AfxEnableControlContainer();

    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.

#ifdef _AFXDLL
    Enable3dControls();         // Call this when using MFC in a shared DLL
#else
    Enable3dControlsStatic();   // Call this when linking to MFC statically
#endif

    // Change the registry key under which our settings are stored.
    // You should modify this string to be something appropriate
    // such as the name of your company or organization.
    SetRegistryKey(_T("Local AppWizard-Generated Applications"));

    LoadStdProfileSettings();  // Load standard INI file options (including MRU)

    // Register the application's document templates.  Document templates
    //  serve as the connection between documents, frame windows and views.

    CSingleDocTemplate* pDocTemplate;
    pDocTemplate = new CSingleDocTemplate(
        IDR_MAINFRAME,
        RUNTIME_CLASS(CSimpsonsDoc),
        RUNTIME_CLASS(CMainFrame),       // main SDI frame window
        RUNTIME_CLASS(CSimpsonsView));
    AddDocTemplate(pDocTemplate);

    // Parse command line for standard shell commands, DDE, file open
    CCommandLineInfo cmdInfo;
    ParseCommandLine(cmdInfo);

    // Dispatch commands specified on the command line
    if (!ProcessShellCommand(cmdInfo))
        return FALSE;

    // The one and only window has been initialized, so show and update it.
    m_pMainWnd->ShowWindow(SW_SHOW);
    m_pMainWnd->UpdateWindow();

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
    CAboutDlg();

// Dialog Data
    //{{AFX_DATA(CAboutDlg)
    enum { IDD = IDD_ABOUTBOX };
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAboutDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    //{{AFX_MSG(CAboutDlg)
        // No message handlers
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
    //{{AFX_DATA_INIT(CAboutDlg)
    //}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAboutDlg)
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
    //{{AFX_MSG_MAP(CAboutDlg)
        // No message handlers
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CSimponsApp::OnAppAbout()
{
    CAboutDlg aboutDlg;
    aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CSimponsApp commands
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\simpsons\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	simpsons.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\simpsons\simpdoc.h ===
// SimpDoc.h : interface of the CSimpsonsDoc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_SIMPDOC_H__7CA4916C_71B3_11D1_AA67_00600814AAE9__INCLUDED_)
#define AFX_SIMPDOC_H__7CA4916C_71B3_11D1_AA67_00600814AAE9__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "parse.h"

class CSimpsonsDoc : public CDocument
{
protected: // create from serialization only
	CSimpsonsDoc();
	DECLARE_DYNCREATE(CSimpsonsDoc)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSimpsonsDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CSimpsonsDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

private:
	RenderCmd *				m_pCmds;
	bool					m_bNoRenderFile;
	bool					m_bNeverRendered;
	char					m_szFileName[256];

public:
	const RenderCmd *		GetRenderCommands() const { return m_pCmds; }
	void					MarkRendered() { m_bNeverRendered = false; } 
	bool					HasNeverRendered() const { return m_bNeverRendered; }
	const char *			GetFileName() const { return m_szFileName; }


// Generated message map functions
protected:
	//{{AFX_MSG(CSimpsonsDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SIMPDOC_H__7CA4916C_71B3_11D1_AA67_00600814AAE9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\simpsons\simpview.h ===
// SimpView.h : interface of the CSimpsonsView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_SIMPVIEW_H__7CA4916E_71B3_11D1_AA67_00600814AAE9__INCLUDED_)
#define AFX_SIMPVIEW_H__7CA4916E_71B3_11D1_AA67_00600814AAE9__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// GDI+ includes
#include <math.h>
#include <gdiplus.h>

using namespace Gdiplus;

//#include "DXTrans.h"
#include "DXHelper.h"
#include "dxtpriv.h"
#include "Parse.h"

class CSimpsonsView : public CView
{
protected: // create from serialization only
    CSimpsonsView();
    DECLARE_DYNCREATE(CSimpsonsView)

// Attributes
public:
    CSimpsonsDoc* GetDocument();

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CSimpsonsView)
    protected:
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    virtual void OnDraw(CDC* pDC);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CSimpsonsView();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
    //{{AFX_MSG(CSimpsonsView)
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnMouseMove(UINT nFlags, CPoint point);
    afx_msg BOOL OnMouseWheel(UINT nFlags, short zDelta, CPoint pt);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()


private:
    HRESULT                 Render(bool invalidate);
    
    void                    DrawAll(IDX2D *pDX2D);
    
    void                    DrawAllGDI(HDC hDC);
    void                    DrawGDIPoly(HDC hDC, PolyInfo *pPoly);
    void                    DrawGDIPolyPathAPI(HDC hDC, PolyInfo *pPoly);
    void                    DrawAllGDIP(HDC hDC);
    void                    BuildGDIPList();
    void                    DrawGDIPPoly(Graphics *g, PolyInfo *pPoly, Pen *pen, Brush *brush);
    void                    DrawGDIPPolyFromList(Graphics *g, int stroke, GraphicsPath *pPath, Pen *pen, Brush *brush);
    
    void                    UpdateStatusMessage();
    void                    ForceUpdate();

private:
    void                    ToggleGDI();
    void                    ToggleDelegateToGDI();
    void                    ToggleStroke();
    void                    ToggleFill();
    void                    AddRotation(float fTheta);
    void                    ResetTransform();
    bool                    IncrementAttribute(int attribute);
    bool                    IncrementTest();
    void                    PrintTestResults();

    HRESULT                 Resize(DWORD nX, DWORD nY);

    void                    DoMove(POINT &pt);

private:
    IDirectDraw3 *          m_pDD;
    IDirectDrawSurface *    m_pddsScreen;
    IDXSurfaceFactory *     m_pSurfFactory;
    IDX2D *                 m_pDX2D;
    IDX2D *                 m_pDX2DScreen;
    IDX2DDebug *            m_pDX2DDebug;
    CSize                   m_sizWin;
    RECT                    m_clientRectHack; // client rect in screen coords
    GraphicsPath *          m_gpPathArray;

    DWORD                   m_dwRenderTime;

    bool                    m_CycleTests;     // If true, cycle through all tests
    int                     m_testCaseNumber; // Which test case to render
    bool                    m_bIgnoreStroke;
    bool                    m_bIgnoreFill;
        bool                                    m_bNullPenSelected;
        HPEN                                    m_hNullPen;
        HPEN                                    m_hStrokePen;

    //view/tracking parameters
    CDX2DXForm              m_XForm;
    CPoint                  m_centerPoint;
    CPoint                  m_lastPoint;
    bool                    m_tracking;
    bool                    m_scaling;
    bool                    m_bLButton;
};

#ifndef _DEBUG  // debug version in SimpView.cpp
inline CSimpsonsDoc* CSimpsonsView::GetDocument()
   { return (CSimpsonsDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SIMPVIEW_H__7CA4916E_71B3_11D1_AA67_00600814AAE9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\simpsons\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__7CA49168_71B3_11D1_AA67_00600814AAE9__INCLUDED_)
#define AFX_STDAFX_H__7CA49168_71B3_11D1_AA67_00600814AAE9__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include "MDMUtils.h"

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <DDrawEx.h>
#include <DXTrans.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7CA49168_71B3_11D1_AA67_00600814AAE9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\simpsons\vecmath.cpp ===
// File:	VecMath.cpp
// Author:	Michael Marr    (mikemarr)
//
// History:
//  -@- 8/1/95 (mikemarr) added FloatEquals

#include "StdAfx.h"
#include "VecMath.h"

// Function: FloatEquals
//    Peform a "fuzzy" compare of two floating point numbers.  This relies
//  on the IEEE bit representation of floating point numbers.
int 
FloatEquals(float x1, float x2)
{
	#define EXPMASK 		0x7f800000
	#define BITSOFPRECISION 19
	#define MANTBITS 		23
	#define EXPOFFSET		(BITSOFPRECISION<<MANTBITS)
	#define ZEROEPS 		3.8e-6F
	#define TINYEPS         1.E-35F

	if (x1 == x2) return 1;		// quick out on exact match
	
	float flEps;

	if ((x1 == 0.0f) || (x2 == 0.0f)) {
		flEps = ZEROEPS;
	} else {
		float maxX;

		if (x1 > x2) 
			maxX = x1;
		else 
			maxX = x2;

		// grab the exponent of the larger number
		unsigned int uExp = (*((unsigned int *) &maxX) & EXPMASK);
		if (uExp < EXPOFFSET)
			flEps = TINYEPS;
		else {
			uExp -= EXPOFFSET;
			flEps = *((float *) &uExp);
		}
	}
	return (((x1 + flEps) >= x2) && ((x1 - flEps) <= x2));
}

#include <math.h>

float 
Vector2::Norm() const
{
	return (float) sqrt(NormSquared());
}

float 
CoVector2::Norm() const
{
	return (float) sqrt(NormSquared());
}

float 
Vector3::Norm() const
{
	return (float) sqrt(NormSquared());
}

float
CoVector3::Norm() const
{
	return (float) sqrt(NormSquared());
}

// Function: Rotate
//    rotate the vector counterclockwise around the given axis by theta radians
// Preconditions:
//    axis must be UNIT LENGTH
void Vector3::Rotate(const Vector3 &vAxis, float fTheta)
{
	float fCosTheta = float(cos(fTheta)), fSinTheta = float(sin(fTheta));
	
	*this *= fCosTheta;
	*this += (vAxis * (Dot(*this, vAxis) * (1.f - fCosTheta)));
	*this += (Cross(*this, vAxis) * fSinTheta);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\texttest\dspdriver.cpp ===
////    DspDriver.CPP - Display strings with DrawDriverString API
//
//


#include "precomp.hxx"
#include "global.h"



void PaintDrawDriverString(
    HDC      hdc,
    int     *piY,
    RECT    *prc,
    int      iLineHeight) {

    int      icpLineStart;     // First character of line
    int      icpLineEnd;       // End of line (end of buffer or index of CR character)
    HFONT    hFont;
    HFONT    hOldFont;
    LOGFONT  lf;


    BOOL testMetafile = FALSE;


    // Establish available width and height in device coordinates

    int plainTextWidth = prc->right - prc->left;
    int plainTextHeight = prc->bottom - *piY;


    Graphics *g        = NULL;
    Metafile *metafile = NULL;

    if (testMetafile)
    {
        metafile = new Metafile(L"c:\\GdiPlusTest.emf", hdc);
        g = new Graphics(metafile);
    }
    else
    {
        g = new Graphics(hdc);
        g->ResetTransform();
        g->TranslateTransform(REAL(prc->left), REAL(*piY));
        g->SetSmoothingMode(g_SmoothingMode);
    }

    g->SetPageUnit(UnitPixel);
    g->SetTextContrast(g_GammaValue);
    g->SetTextRenderingHint(g_TextMode);

    // Clear the background

    RectF rEntire(0, 0, REAL(plainTextWidth), REAL(plainTextHeight));
    SolidBrush whiteBrush(Color(0xff, 0xff, 0xff));
    g->FillRectangle(g_textBackBrush, rEntire);


    // Apply selected world transform, adjusted to a little away from top
    // left edge.

    g->SetTransform(&g_WorldTransform);
    g->TranslateTransform(
        //REAL(prc->left + plainTextWidth/20),
        //REAL(*piY + plainTextHeight/10),
        REAL(prc->left + plainTextWidth/2),
        REAL(*piY + plainTextHeight/2),
        MatrixOrderAppend);


    Color      grayColor(0xc0, 0xc0, 0xc0);
    SolidBrush grayBrush(grayColor);
    Pen        grayPen(&grayBrush, 1.0);


    // Put some text in the middle

    Color      blackColor(0, 0, 0);
    SolidBrush blackBrush(blackColor);
    Pen        blackPen(&blackBrush, 1.0);

    Font font(&FontFamily(g_style[0].faceName), REAL(g_style[0].emSize), g_style[0].style, g_fontUnit);

    // Prepare array of glyph origins

    PointF *origins;

    if (g_DriverOptions & DriverStringOptionsRealizedAdvance)
    {
        origins = new PointF[1];
        if (!origins)
        {
            return;
        }
        origins[0].X = 0.0;
        origins[0].Y = 0.0;
    }
    else
    {
        origins = new PointF[g_iTextLen];
        if (!origins)
        {
            return;
        }
        origins[0].X = 0.0;
        origins[0].Y = 0.0;

        for (INT i=1; i<g_iTextLen; i++)
        {
            origins[i].X = origins[i-1].X + g_DriverDx;
            origins[i].Y = origins[i-1].Y + g_DriverDy;
        }
    }


    RectF measuredBoundingBox;

    // Change the font size to the pixel height requested in g_DriverPixels,
    // and map to the actual height showing here by adjusting the
    // world transform.

    REAL scale = REAL(font.GetSize() / g_DriverPixels);
    Font scaledFont(&FontFamily(g_style[0].faceName), g_DriverPixels, g_style[0].style, g_fontUnit);

    for(int iRender=0;iRender<g_iNumRenders;iRender++)
    {
        {
            g->DrawDriverString(
                g_wcBuf,
                g_iTextLen,
                &font,
                g_textBrush,
                origins,
                g_DriverOptions,
                &g_DriverTransform
            );
        }
    }

    {
        g->MeasureDriverString(
            g_wcBuf,
            g_iTextLen,
            &font,
            origins,
            g_DriverOptions,
            &g_DriverTransform,
            &measuredBoundingBox
        );
    }

    // Mark the first origin with a cross

    g->DrawLine(&blackPen, origins[0].X,   origins[0].Y-4, origins[0].X,   origins[0].Y+4);
    g->DrawLine(&blackPen, origins[0].X-4, origins[0].Y,   origins[0].X+4, origins[0].Y);

    delete [] origins;

    g->DrawRectangle(
        &Pen(&SolidBrush(Color(0x80,0x80,0x80)), 1.0),
        measuredBoundingBox
    );

    delete g;
    if (metafile) delete metafile;


    if (testMetafile)
    {
        // Playback metafile to screen
        Metafile emfplus(L"c:\\GdiPlusTest.emf");
        Graphics graphPlayback(hdc);
        graphPlayback.ResetTransform();
        graphPlayback.TranslateTransform(REAL(prc->left), REAL(*piY));
        graphPlayback.DrawImage(
            &emfplus,
            REAL(0),
            REAL(0),
            REAL(plainTextWidth),
            REAL(plainTextHeight)
        );
        graphPlayback.Flush();
    }


    *piY += plainTextHeight;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\texttest\dspfamly.cpp ===
////    DspFamly.CPP - Display available font families
//
//


#include "precomp.hxx"
#include "global.h"



void PaintFamilies(
    HDC      hdc,
    int     *piY,
    RECT    *prc,
    int      iLineHeight) {


    // Establish available width and height in device coordinates

    int DrawingWidth = prc->right - prc->left;
    int DrawingHeight = DrawingWidth/2;


    // Establish a Graphics with 0,0 at the top left of the drawing area

    Graphics g(hdc);
    Matrix matrix;

    g.ResetTransform();
    g.TranslateTransform(REAL(prc->left), REAL(*piY));


    // Clear the background

    RectF rEntire(0, 0, REAL(DrawingWidth), REAL(DrawingHeight));
    SolidBrush whiteBrush(Color(0xff, 0xff, 0xff));
    g.FillRectangle(&whiteBrush, rEntire);


    // Leave a little space for right and bottom margins

    DrawingWidth  -= DrawingWidth/40;
    DrawingHeight -= DrawingHeight/40;


    // Display face names sized to fit: allow 1.5 ems vertical x 20 ems horizontal per char.
    // Thus failyCount fonts will take familyCount*30 square ems.

    INT emSize      = (INT)sqrt(DrawingWidth*DrawingHeight/(g_familyCount*30));
    if (emSize < 6)
        emSize = 6; // we need a reasonable lower limit otherwise we may div by zero
    INT columnCount = DrawingWidth / (emSize*15);

    // HFONT hfont = CreateFont(-emSize, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, "Tahoma");
    // HFONT hOldFont = (HFONT) SelectObject(hdc, hfont);

    Color        blackColor(0, 0, 0);
    SolidBrush   blackBrush(blackColor);
    Pen          blackPen(&blackBrush, 1);
    StringFormat format(g_formatFlags);

    for (INT i=0; i<g_familyCount; i++) {

        WCHAR facename[LF_FACESIZE];
        g_families[i].GetFamilyName(facename);

        RectF textRect(
            REAL(emSize*15*(i%columnCount)),
            REAL(emSize*3*(i/columnCount)/2),
            REAL(emSize*15),
            REAL(emSize*3/2));

        g.DrawString(
            facename, -1,
            &Font(&FontFamily(L"Tahoma"),REAL(emSize), 0, UnitWorld),
            textRect,
            &format,
            &blackBrush);

        /*
        TextOutW(
            hdc,
            prc->left + emSize*15*(i%columnCount),
            *piY      + emSize*3*(i/columnCount)/2,
            facename,
            lstrlenW(facename)
        );
        */


        // Do some metric analysis

        #ifdef TEXTV2
        char str[200];

        for (INT style = 0; style < 3; style++)
        {
            if (g_families[i].IsStyleAvailable(style))
            {
                if (g_families[i].GetTypographicDescent(style) >= 0)
                {
                    wsprintf(str, "%S: typo descent(%d) >= 0\n", facename, g_families[i].GetTypographicDescent(style));
                    OutputDebugString(str);
                }

                if (g_families[i].GetTypographicAscent(style) <= 0)
                {
                    wsprintf(str, "%S: typo ascent(%d) <= 0\n", facename, g_families[i].GetTypographicAscent(style));
                    OutputDebugString(str);
                }

                if (g_families[i].GetTypographicAscent(style) > g_families[i].GetCellAscent(style))
                {
                    wsprintf(str, "%S: typo ascent(%d) > cell ascent (%d)\n", facename, g_families[i].GetTypographicAscent(style), g_families[i].GetCellAscent(style));
                    OutputDebugString(str);
                }

                if (-g_families[i].GetTypographicDescent(style) > g_families[i].GetCellDescent(style))
                {
                    wsprintf(str, "%S: -typo descent(%d) > cell descent (%d)\n", facename, -g_families[i].GetTypographicDescent(style), g_families[i].GetCellDescent(style));
                    OutputDebugString(str);
                }
            }
        }
        #endif
    }

    // DeleteObject(SelectObject(hdc, hOldFont));

    *piY += emSize*3*(1+((g_familyCount-1)/columnCount))/2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\simpsons\vecmath.h ===
#ifndef _VecMath_h
#define _VecMath_h

// File:	VecMath.h
//
//	Classes to support 2D and 3D linear vector space and their duals
//	D. P. Mitchell  95/06/02.
//
// History:
// -@- 07/06/95 (mikemarr) - added Print and Read functions
// -@- 08/01/95 (mikemarr) - added fuzzy compare for floats
// -@- 04/15/96 (mikemarr) - changed stdio stuff to don's stream stuff
// -@- 04/18/96 (mikemarr) - added vector.inl to this file
// -@- 06/21/96 (mikemarr) - added +=, etc. operators
// -@- 06/21/96 (mikemarr) - added Rotate
// -@- 10/29/97 (mikemarr) - removed I/O
//                         - changed +=,-=,*=,/= operators to return reference
//                         - added operator const float *
//                         - added Unitize, Perp, NormSquared, SetNorm, Negate
//                         - comments/cleanup
//                         - changed fuzzy equal to be IsEqual, operator == to be exact
//                         - bug fix on Transpose
//                         - changed multiple divides to be 1 divide + multiplies
//                         - assert on divide by zero
// -@- 11/04/97 (mikemarr) - added intialization with SIZE

// Function: FloatEquals
//    Peform a "fuzzy" compare of two floating point numbers.  This relies
//  on the IEEE bit representation of floating point numbers.
int	FloatEquals(float x1, float x2);

class CoVector2;
class CoVector3;
class Vector3;

// Class:		Vector2
// Hungarian:	v
// Description:
//    This class represents a floating point 2D column vector useful for computational
//  geometry calculations.
class  Vector2 {
public:
						Vector2()					{}
						Vector2(float a, float b)	: x(a), y(b) {}
						Vector2(const SIZE &siz)	: x(float(siz.cx)), y(float(siz.cy)) {}

	friend Vector2		operator +(const Vector2 &u, const Vector2 &v);
	friend Vector2		operator -(const Vector2 &u, const Vector2 &v);
	friend Vector2		operator -(const Vector2 &u);
	friend Vector2		operator *(const Vector2 &u, float a);
	friend Vector2		operator *(float a, const Vector2 &u);
	friend Vector2		operator /(const Vector2 &u, float a);
	friend int			operator ==(const Vector2 &u, const Vector2 &v);
	friend int			operator !=(const Vector2 &u, const Vector2 &v);

	friend Vector2 &	operator +=(Vector2 &u, const Vector2 &v);
	friend Vector2 &	operator -=(Vector2 &u, const Vector2 &v);
	friend Vector2 &	operator *=(Vector2 &u, float a);
	friend Vector2 &	operator /=(Vector2 &u, float a);

#ifndef DISABLE_CROSSDOT
	friend float 		Cross(const Vector2 &u, const Vector2 &v);
	friend float 		Dot(const Vector2 &u, const Vector2 &v);
#endif
	friend int			IsEqual(const Vector2 &u, const Vector2 &v);

						operator const float *() const { return &x; }

	CoVector2 			Transpose() const;
	float 				Norm() const;
	float 				NormSquared() const;
	void				SetNorm(float a);
	Vector2  			Unit() const;
	void				Unitize();
	Vector2				Perp() const;	// points to left
	void				Negate();

public:
	float				x, y;
};


// Class:		CoVector2
// Hungarian:	cv
// Description:
//    This class represents a floating point 2D row vector useful for computational
//  geometry calculations.
class  CoVector2 {
public:
						CoVector2()						{}
						CoVector2(float a, float b)		: x(a), y(b) {}
						CoVector2(const SIZE &siz)		: x(float(siz.cx)), y(float(siz.cy)) {}

	friend CoVector2	operator +(const CoVector2 &u, const CoVector2 &v);
	friend CoVector2	operator -(const CoVector2 &u, const CoVector2 &v);
	friend CoVector2	operator -(const CoVector2 &u);
	friend CoVector2	operator *(const CoVector2 &u, float a);
	friend CoVector2	operator *(float a, const CoVector2 &u);
	friend CoVector2	operator /(const CoVector2 &u, float a);
	friend int			operator ==(const CoVector2 &u, const CoVector2 &v);
	friend int			operator !=(const CoVector2 &u, const CoVector2 &v);

	friend CoVector2 &	operator +=(CoVector2 &u, const CoVector2 &v);
	friend CoVector2 &	operator -=(CoVector2 &u, const CoVector2 &v);
	friend CoVector2 &	operator *=(CoVector2 &u, float a);
	friend CoVector2 &	operator /=(CoVector2 &u, float a);

#ifndef DISABLE_CROSSDOT
	friend float		Cross(const CoVector2 &u, const CoVector2 &v);
	friend float		Dot(const CoVector2 &u, const CoVector2 &v);
#endif
	friend int			IsEqual(const CoVector2 &u, const CoVector2 &v);

						operator const float *() const { return &x; }

	Vector2				Transpose() const;
	float				Norm() const;
	float 				NormSquared() const;
	void				SetNorm(float a);
	CoVector2 			Unit() const;
	void		 		Unitize();
	friend float		operator *(const CoVector2 &c, const Vector2 &v);
	CoVector2			Perp() const; 	// points to left
	void				Negate();

public:
	float				x, y;
};


// Class:		Vector3
// Hungarian:	v
// Description:
//    This class represents a floating point 3D column vector useful for computational
//  geometry calculations.
class  Vector3 {
public:
						Vector3()							{}
						Vector3(float a, float b, float c)	: x(a), y(b), z(c) {}

	friend Vector3		operator +(const Vector3 &u, const Vector3 &v);
	friend Vector3		operator -(const Vector3 &u, const Vector3 &v);
	friend Vector3		operator -(const Vector3 &u);
	friend Vector3		operator *(const Vector3 &u, float a);
	friend Vector3		operator *(float a, const Vector3 &u);
	friend Vector3		operator /(const Vector3 &u, float a);
	friend int			operator ==(const Vector3 &u, const Vector3 &v);
	friend int			operator !=(const Vector3 &u, const Vector3 &v);

	friend Vector3 &	operator +=(Vector3 &u, const Vector3 &v);
	friend Vector3 &	operator -=(Vector3 &u, const Vector3 &v);
	friend Vector3 &	operator *=(Vector3 &u, float a);
	friend Vector3 &	operator /=(Vector3 &u, float a);

#ifndef DISABLE_CROSSDOT
	friend Vector3		Cross(const Vector3 &u, const Vector3 &v);
	friend float		Dot(const Vector3 &u, const Vector3 &v);
#endif
	friend int			IsEqual(const Vector3 &u, const Vector3 &v);

						operator const float *() const { return &x; }

	CoVector3			Transpose() const;
	float				Norm() const;
	float 				NormSquared() const;
	void				SetNorm(float a);
	Vector3				Unit() const;
	void		 		Unitize();
	Vector2				Project(DWORD iAxis) const;
	void				Rotate(const Vector3 &vAxis, float fTheta);
	void				Negate();

public:
	float				x, y, z;
};


// Class:		CoVector3
// Hungarian:	cv
// Description:
//    This class represents a floating point 3D row vector useful for computational
//  geometry calculations.
class  CoVector3 {
public:
						CoVector3()								{}
						CoVector3(float a, float b, float c)	: x(a), y(b), z(c) {}

	friend CoVector3	operator +(const CoVector3 &u, const CoVector3 &v);
	friend CoVector3	operator -(const CoVector3 &u, const CoVector3 &v);
	friend CoVector3	operator -(const CoVector3 &u);
	friend CoVector3	operator *(const CoVector3 &u, float a);
	friend CoVector3	operator *(float, const CoVector3 &u);
	friend CoVector3	operator /(const CoVector3 &u, float a);
	friend int			operator ==(const CoVector3 &u, const CoVector3 &v);
	friend int			operator !=(const CoVector3 &u, const CoVector3 &v);

	friend CoVector3 &	operator +=(CoVector3 &u, const CoVector3 &v);
	friend CoVector3 &	operator -=(CoVector3 &u, const CoVector3 &v);
	friend CoVector3 &	operator *=(CoVector3 &u, float a);
	friend CoVector3 &	operator /=(CoVector3 &u, float a);

#ifndef DISABLE_CROSSDOT
	friend CoVector3	Cross(const CoVector3 &u, const CoVector3 &v);
	friend float		Dot(const CoVector3 &u, const CoVector3 &v);
#endif
	friend int			IsEqual(const CoVector3 &u, const CoVector3 &v);

						operator const float *() const { return &x; }

	Vector3				Transpose() const;
	float				Norm() const;
	float 				NormSquared() const;
	void				SetNorm(float a);
	CoVector3			Unit() const;
	void				Unitize();
	friend float		operator *(const CoVector3 &c, const Vector3 &u);	// linear form
	void				Negate();

public:
	float				x, y, z;
};


////////////
// Vector2
////////////

inline Vector2
operator +(const Vector2 &u, const Vector2 &v)
{
	return Vector2(u.x+v.x, u.y+v.y);
}

inline Vector2
operator -(const Vector2 &u, const Vector2 &v)
{
	return Vector2(u.x-v.x, u.y-v.y);
}

inline Vector2
operator -(const Vector2 &v)
{
	return Vector2(-v.x, -v.y);
}

inline Vector2
operator *(float a, const Vector2 &v)
{
	return Vector2(a*v.x, a*v.y);
}

inline Vector2
operator *(const Vector2 &v, float a)
{
	return Vector2(a*v.x, a*v.y);
}

inline Vector2
operator /(const Vector2 &v, float a)
{
	MMASSERT(a != 0.f);
	float fTmp = 1.f/a;
	return Vector2(v.x * fTmp, v.y * fTmp);
}

inline int
operator ==(const Vector2 &u, const Vector2 &v)
{
	return ((u.x == v.x) && (u.y == v.y));
}

inline int
IsEqual(const Vector2 &u, const Vector2 &v)
{
	return (FloatEquals(u.x, v.x) && FloatEquals(u.y, v.y));
}

inline int
operator !=(const Vector2 &u, const Vector2 &v)
{
	return !(u == v);
}

inline Vector2 &
operator +=(Vector2 &u, const Vector2 &v)
{
	u.x += v.x; 
	u.y += v.y;
	return u;
}

inline Vector2 &
operator -=(Vector2 &u, const Vector2 &v)
{
	u.x -= v.x; 
	u.y -= v.y;
	return u;
}

inline Vector2 &
operator *=(Vector2 &u, float a)
{
	u.x *= a;
	u.y *= a;
	return u;
}

inline Vector2 &
operator /=(Vector2 &u, float a)
{
	MMASSERT(a != 0.f);
	float fTmp = 1.f/a;
	u.x *= fTmp;
	u.y *= fTmp;
	return u;
}

#ifndef DISABLE_CROSSDOT
inline float
Cross(const Vector2 &u, const Vector2 &v)
{
	return u.x*v.y - u.y*v.x;
}

inline float
Dot(const Vector2 &u, const Vector2 &v)
{
	return u.x*v.x + u.y*v.y;
}
#endif

inline CoVector2
Vector2::Transpose() const
{
	return CoVector2(x, y);
}

inline Vector2
Vector2::Unit() const
{
	return *this/this->Norm();
}

inline void
Vector2::Unitize()
{
	*this /= this->Norm();
}

inline Vector2
Vector2::Perp() const
{
	return Vector2(-y, x);
}

inline float
Vector2::NormSquared() const
{
	return x*x + y*y;
}

inline void
Vector2::SetNorm(float a)
{
	*this *= (a / Norm());
}

inline void
Vector2::Negate()
{
	x = -x; y = -y;
}



//////////////
// CoVector2
//////////////

inline CoVector2
operator +(const CoVector2 &u, const CoVector2 &v)
{
	return CoVector2(u.x+v.x, u.y+v.y);
}

inline CoVector2
operator -(const CoVector2 &u, const CoVector2 &v)
{
	return CoVector2(u.x-v.x, u.y-v.y);
}

inline CoVector2
operator -(const CoVector2 &v)
{
	return CoVector2(-v.x, -v.y);
}

inline CoVector2
operator *(float a, const CoVector2 &v)
{
	return CoVector2(a*v.x, a*v.y);
}

inline CoVector2
operator *(const CoVector2 &v, float a)
{
	return CoVector2(a*v.x, a*v.y);
}

inline CoVector2
operator /(const CoVector2 &v, float a)
{
	MMASSERT(a != 0.f);
	float fTmp = 1.f/a;
	return CoVector2(v.x * fTmp, v.y * fTmp);
}

inline int
operator ==(const CoVector2 &u, const CoVector2 &v)
{
	return ((u.x == v.x) && (u.y == v.y));
}

inline int
IsEqual(const CoVector2 &u, const CoVector2 &v)
{
	return (FloatEquals(u.x, v.x) && FloatEquals(u.y, v.y));
}

inline int
operator !=(const CoVector2 &u, const CoVector2 &v)
{
	return !(u == v);
}

inline CoVector2 &
operator +=(CoVector2 &u, const CoVector2 &v)
{
	u.x += v.x; 
	u.y += v.y;
	return u;
}

inline CoVector2 &
operator -=(CoVector2 &u, const CoVector2 &v)
{
	u.x -= v.x; 
	u.y -= v.y;
	return u;
}

inline CoVector2 &
operator *=(CoVector2 &u, float a)
{
	u.x *= a;
	u.y *= a;
	return u;
}

inline CoVector2 &
operator /=(CoVector2 &u, float a)
{
	MMASSERT(a != 0.f);
	float fTmp = 1.f/a;
	u.x *= fTmp;
	u.y *= fTmp;
	return u;
}

#ifndef DISABLE_CROSSDOT
inline float
Cross(const CoVector2 &u, const CoVector2 &v)
{
	return u.x*v.y - u.y*v.x;
}

inline float
Dot(const CoVector2 &u, const CoVector2 &v)
{
	return u.x*v.x + u.y*v.y;
}
#endif

inline Vector2
CoVector2::Transpose() const
{
	return Vector2(x, y);
}

inline CoVector2
CoVector2::Unit() const
{
	return *this/this->Norm();
}

inline void
CoVector2::Unitize()
{
	*this /= this->Norm();
}

inline float
operator *(const CoVector2 &c, const Vector2 &v)
{
	return c.x*v.x + c.y*v.y;
}

inline CoVector2
CoVector2::Perp() const
{
	return CoVector2(-y, x);
}

inline float
CoVector2::NormSquared() const
{
	return x*x + y*y;
}

inline void
CoVector2::SetNorm(float a)
{
	*this *= (a / Norm());
}

inline void
CoVector2::Negate()
{
	x = -x; y = -y;
}

////////////
// Vector3
////////////

inline Vector3
operator +(const Vector3 &u, const Vector3 &v)
{
	return Vector3(u.x+v.x, u.y+v.y, u.z+v.z);
}

inline Vector3
operator -(const Vector3 &u, const Vector3 &v)
{
	return Vector3(u.x-v.x, u.y-v.y, u.z-v.z);
}

inline Vector3
operator -(const Vector3 &v)
{
	return Vector3(-v.x, -v.y, -v.z);
}

inline Vector3
operator *(float a, const Vector3 &v)
{
	return Vector3(a*v.x, a*v.y, a*v.z);
}

inline Vector3
operator *(const Vector3 &v, float a)
{
	return Vector3(a*v.x, a*v.y, a*v.z);
}

inline Vector3
operator /(const Vector3 &v, float a)
{
	float fTmp = 1.f / a;
	return Vector3(v.x * fTmp, v.y * fTmp, v.z * fTmp);
}

inline int
operator ==(const Vector3 &u, const Vector3 &v)
{
	return ((u.x == v.x) && (u.y == v.y) && (u.z == v.z));
}

inline int
IsEqual(const Vector3 &u, const Vector3 &v)
{
	return (FloatEquals(u.x, v.x) && FloatEquals(u.y, v.y) && FloatEquals(u.z, v.z));
}

inline int
operator !=(const Vector3 &u, const Vector3 &v)
{
	return !(u == v);
}

inline Vector3 &
operator +=(Vector3 &u, const Vector3 &v)
{
	u.x += v.x; 
	u.y += v.y;
	u.z += v.z;
	return u;
}

inline Vector3 &
operator -=(Vector3 &u, const Vector3 &v)
{
	u.x -= v.x; 
	u.y -= v.y;
	u.z -= v.z;
	return u;
}

inline Vector3 &
operator *=(Vector3 &u, float a)
{
	u.x *= a;
	u.y *= a;
	u.z *= a;
	return u;
}

inline Vector3 &
operator /=(Vector3 &u, float a)
{
	MMASSERT(a != 0.f);
	float fTmp = 1.f/a;
	u.x *= fTmp;
	u.y *= fTmp;
	u.z *= fTmp;
	return u;
}

#ifndef DISABLE_CROSSDOT
inline Vector3
Cross(const Vector3 &u, const Vector3 &v)
{
	return Vector3(u.y*v.z-u.z*v.y, u.z*v.x-u.x*v.z, u.x*v.y-u.y*v.x);
}

inline float
Dot(const Vector3 &u, const Vector3 &v)
{
	return u.x*v.x + u.y*v.y + u.z*v.z;
}
#endif

inline float
operator *(const CoVector3 &c, const Vector3 &v)
{
	return c.x*v.x + c.y*v.y + c.z*v.z;
}

inline CoVector3
Vector3::Transpose() const
{
	return CoVector3(x, y, z);
}

inline Vector3
Vector3::Unit() const
{
	return *this/this->Norm();
}

inline void
Vector3::Unitize()
{
	*this /= this->Norm();
}

inline float
Vector3::NormSquared() const
{
	return x*x + y*y + z*z;
}

inline void
Vector3::SetNorm(float a)
{
	*this *= (a / Norm());
}

inline void
Vector3::Negate()
{
	x = -x; y = -y; z = -z;
}

inline Vector2
Vector3::Project(DWORD iAxis) const
{
	switch (iAxis) {
	case 0: return Vector2(y, z);
	case 1: return Vector2(x, z);
	case 2: return Vector2(x, y);
	}
	return Vector2(0.f, 0.f);
}

//////////////
// CoVector3
//////////////

inline CoVector3
operator +(const CoVector3 &u, const CoVector3 &v)
{
	return CoVector3(u.x+v.x, u.y+v.y, u.z+v.z);
}

inline CoVector3
operator -(const CoVector3 &u, const CoVector3 &v)
{
	return CoVector3(u.x-v.x, u.y-v.y, u.z-v.z);
}

inline CoVector3
operator -(const CoVector3 &v)
{
	return CoVector3(-v.x, -v.y, -v.z);
}

inline CoVector3
operator *(float a, const CoVector3 &v)
{
	return CoVector3(a*v.x, a*v.y, a*v.z);
}

inline CoVector3
operator *(const CoVector3 &v, float a)
{
	return CoVector3(a*v.x, a*v.y, a*v.z);
}

inline CoVector3
operator /(const CoVector3 &v, float a)
{
	MMASSERT(a != 0.f);
	float fTmp = 1.f/a;
	return CoVector3(v.x * fTmp, v.y * fTmp, v.z * fTmp);
}

inline int
operator ==(const CoVector3 &u, const CoVector3 &v)
{
	return ((u.x == v.x) && (u.y == v.y) && (u.z == v.z));
}

inline int
IsEqual(const CoVector3 &u, const CoVector3 &v)
{
	return (FloatEquals(u.x, v.x) && FloatEquals(u.y, v.y) && FloatEquals(u.z, v.z));
}

inline int
operator !=(const CoVector3 &u, const CoVector3 &v)
{
	return !(u == v);
}

inline CoVector3 &
operator +=(CoVector3 &u, const CoVector3 &v)
{
	u.x += v.x; 
	u.y += v.y;
	u.z += v.z;
	return u;
}

inline CoVector3 &
operator -=(CoVector3 &u, const CoVector3 &v)
{
	u.x -= v.x; 
	u.y -= v.y;
	u.z -= v.z;
	return u;
}

inline CoVector3 &
operator *=(CoVector3 &u, float a)
{
	u.x *= a;
	u.y *= a;
	u.z *= a;
	return u;
}

inline CoVector3 &
operator /=(CoVector3 &u, float a)
{
	MMASSERT(a != 0.f);
	float fTmp = 1.f/a;
	u.x *= fTmp;
	u.y *= fTmp;
	u.z *= fTmp;
	return u;
}

#ifndef DISABLE_CROSSDOT
inline CoVector3
Cross(const CoVector3 &u, const CoVector3 &v)
{
	return CoVector3(u.y*v.z-u.z*v.y, u.z*v.x-u.x*v.z, u.x*v.y-u.y*v.x);
}

inline float
Dot(const CoVector3 &u, const CoVector3 &v)
{
	return u.x*v.x + u.y*v.y + u.z*v.z;
}
#endif

inline Vector3
CoVector3::Transpose() const
{
	return Vector3(x, y, z);
}

inline CoVector3
CoVector3::Unit() const
{
	return *this/this->Norm();
}

inline void
CoVector3::Unitize()
{
	*this /= this->Norm();
}

inline float
CoVector3::NormSquared() const
{
	return x*x + y*y + z*z;
}

inline void
CoVector3::SetNorm(float a)
{
	*this *= (a / Norm());
}

inline void
CoVector3::Negate()
{
	x = -x; y = -y; z = -z;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\texttest\debug.cpp ===
#include "precomp.hxx"
#include "global.h"






////    DebugMsg - display a message via OutputDebugString
//
//      DebugMsg formats debug messages, including the file name
//      and line number the message originated form.
//
//      Supports the TRACEMSG and TRACE macros.
//
//      The current timer is adjusted to remove debug message
//      output from timing results.



extern "C" void WINAPIV DebugMsg(char *fmt, ...) {

    va_list vargs;
    char c[200];

//    TIMESUSPEND;

    wsprintfA(c, "%s[%d]                   ", strrchr(DG.psFile, '\\')+1, DG.iLine);
    c[17] = 0;
    OutputDebugStringA(c);

    wsprintfA(c, "%ld:      ", GetCurrentThreadId());
    c[5] = 0;
    OutputDebugStringA(c);

    va_start(vargs, fmt);
    wvsprintfA(c, fmt, vargs);
    OutputDebugStringA(c);

    OutputDebugStringA("\n");

//    TIMERESUME;
}






extern "C" void WINAPIV DebugHr(char *fmt, ...) {

    va_list vargs;
    char c[200];

//    TIMESUSPEND;

    wsprintfA(c, "%s[%d]                   ", strrchr(DG.psFile, '\\')+1, DG.iLine);
    c[17] = 0;
    OutputDebugStringA(c);

    wsprintfA(c, "%ld:      ", GetCurrentThreadId());
    c[5] = 0;
    OutputDebugStringA(c);

    va_start(vargs, fmt);
    wvsprintfA(c, fmt, vargs);
    OutputDebugStringA(c);

    //
    // Parse USP and Win32 Errors
    //

    switch( DG.hrLastError )
    {
    case USP_E_SCRIPT_NOT_IN_FONT:
      lstrcpyA( DG.sLastError , "Selected font doesn't contain requested script\n");
      break;

    default:
      FormatMessageA(
          FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
          NULL, DG.hrLastError, MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
          DG.sLastError, sizeof(DG.sLastError), NULL);
    }

    wsprintfA(c, " -- HRESULT = %x: %s", DG.hrLastError, DG.sLastError);
    OutputDebugStringA(c);

//    TIMERESUME;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\texttest\dspdraws.cpp ===
////    DspDraws.CPP - Display plaintext using DrawString API
//
//


#include "precomp.hxx"
#include "global.h"
#include "gdiplus.h"



/*
REAL GetEmHeightInPoints(
    const Font *font,
    const Graphics *graphics
)
{
    FontFamily family;
    font->GetFamily(&family);

    INT style = font->GetStyle();

    REAL pixelsPerPoint = REAL(graphics->GetDpiY() / 72.0);

    REAL lineSpacingInPixels = font->GetHeight(graphics);

    REAL emHeightInPixels = lineSpacingInPixels * family.GetEmHeight(style)
                                                / family.GetLineSpacing(style);

    REAL emHeightInPoints = emHeightInPixels / pixelsPerPoint;

    return emHeightInPoints;
}
*/




void PaintDrawString(
    HDC      hdc,
    int     *piY,
    RECT    *prc,
    int      iLineHeight) {

    int      icpLineStart;     // First character of line
    int      icpLineEnd;       // End of line (end of buffer or index of CR character)



    // Establish available width and height in device coordinates

    int plainTextWidth = prc->right - prc->left;
    int plainTextHeight = prc->bottom - *piY;


    // Draw a simple figure in the world coordinate system

    Graphics *g = NULL;

    Metafile *metafile = NULL;

    if (g_testMetafile)
    {
        metafile = new Metafile(L"c:\\texttest.emf", hdc);
        g = new Graphics(metafile);
    }
    else
    {
        g = new Graphics(hdc);
    }


    Matrix matrix;


    g->ResetTransform();
    g->SetPageUnit(UnitPixel);
    g->TranslateTransform(REAL(prc->left), REAL(*piY));

    g->SetSmoothingMode(g_SmoothingMode);

    g->SetTextContrast(g_GammaValue);
    g->SetTextRenderingHint(g_TextMode);

    SolidBrush whiteBrush(Color(0xff, 0xff, 0xff));

    Color      grayColor(0xc0, 0xc0, 0xc0);
    SolidBrush grayBrush(grayColor);
    Pen        grayPen(&grayBrush, 1.0);

    Color      blackColor(0, 0, 0);
    SolidBrush blackBrush(blackColor);
    Pen        blackPen(&blackBrush, 1.0);



    // Clear the background

    RectF rEntire(0, 0, REAL(plainTextWidth), REAL(plainTextHeight));
    g->FillRectangle(g_textBackBrush, rEntire);


    // Apply selected world transform, adjusted to middle of the plain text
    // area.

    g->SetTransform(&g_WorldTransform);
    g->TranslateTransform(
        REAL(prc->left + plainTextWidth/2),
        REAL(*piY + plainTextHeight/2),
        MatrixOrderAppend);


    Font font(
        &FontFamily(g_style[0].faceName),
        REAL(g_style[0].emSize),
        g_style[0].style,
        g_fontUnit
    );




    // Put some text in the middle

    RectF textRect(REAL(-25*plainTextWidth/100), REAL(-25*plainTextHeight/100),
                   REAL( 50*plainTextWidth/100), REAL( 50*plainTextHeight/100));


    StringFormat format(g_typographic ? StringFormat::GenericTypographic() : StringFormat::GenericDefault());
    format.SetFormatFlags(g_formatFlags);
    format.SetTrimming(g_lineTrim);
    format.SetAlignment(g_align);
    format.SetLineAlignment(g_lineAlign);
    format.SetHotkeyPrefix(g_hotkey);

    format.SetDigitSubstitution(g_Language, g_DigitSubstituteMode);

    REAL tab[3] = {textRect.Width/4,
                   textRect.Width*3/16,
                   textRect.Width*1/8};

    format.SetTabStops(0.0, sizeof(tab)/sizeof(REAL), tab);


    if (!g_AutoDrive)
    {
        // Display selection region if any

        if (g_iFrom || g_iTo)
        {
            if (g_RangeCount > 0)
            {
                Region regions[MAX_RANGE_COUNT];

                format.SetMeasurableCharacterRanges(g_RangeCount, g_Ranges);
                Status status = g->MeasureCharacterRanges(g_wcBuf, g_iTextLen, &font, textRect, &format, g_RangeCount, regions);

                if (status == Ok)
                {
                    Pen lightGrayPen(&SolidBrush(Color(0x80,0x80,0x80)), 1.0);
                    INT rangeCount = g_RangeCount;
                    Matrix identity;

                    while (rangeCount > 0)
                    {
                        /*INT scanCount = regions[rangeCount - 1].GetRegionScansCount(&identity);
                        RectF *boxes = new RectF[scanCount];

                        regions[rangeCount - 1].GetRegionScans(&identity, boxes, &scanCount);

                        for (INT i = 0; i < scanCount; i++)
                        {
                            g->DrawRectangle(&lightGrayPen, boxes[i]);
                        }

                        delete [] boxes;

                        rangeCount--;
                        */
                        g->FillRegion(&SolidBrush(Color(0xc0,0xc0,0xc0)), &regions[--rangeCount]);
                    }
                }
            }
        }
    }

    if (!g_AutoDrive)
    {
        // Outline the layout rectangle

        g->DrawRectangle(&grayPen, textRect);

        // Measure and outline the text

        RectF boundingBox;
        INT   codepointsFitted;
        INT   linesFilled;

        g->MeasureString(
            g_wcBuf, g_iTextLen, &font, textRect, &format,  // In
            &boundingBox, &codepointsFitted, &linesFilled);  // Out

        Pen lightGrayPen(&SolidBrush(Color(0x80,0x80,0x80)), 1.0);

        g->DrawRectangle(&lightGrayPen, boundingBox);

        // Also draw horizontal and vertical lines away from the rectangle
        // corners - this is to check that line and rectangle drawing coordinates
        // work consistently in a negative x scale (they didn't in GDI: the
        // rectangle and lines differed by one pixel).

        g->DrawLine(
            &lightGrayPen,
            boundingBox.X, boundingBox.Y,
            boundingBox.X-plainTextWidth/20, boundingBox.Y);
        g->DrawLine(
            &lightGrayPen,
            boundingBox.X, boundingBox.Y,
            boundingBox.X, boundingBox.Y-plainTextHeight/20);

        g->DrawLine(
            &lightGrayPen,
            boundingBox.X+boundingBox.Width, boundingBox.Y,
            boundingBox.X+boundingBox.Width+plainTextWidth/20, boundingBox.Y);
        g->DrawLine(
            &lightGrayPen,
            boundingBox.X+boundingBox.Width, boundingBox.Y,
            boundingBox.X+boundingBox.Width, boundingBox.Y-plainTextHeight/20);


        g->DrawLine(
            &lightGrayPen,
            boundingBox.X, boundingBox.Y+boundingBox.Height,
            boundingBox.X-plainTextWidth/20, boundingBox.Y+boundingBox.Height);
        g->DrawLine(
            &lightGrayPen,
            boundingBox.X, boundingBox.Y+boundingBox.Height,
            boundingBox.X, boundingBox.Y+boundingBox.Height+plainTextHeight/20);

        g->DrawLine(
            &lightGrayPen,
            boundingBox.X+boundingBox.Width, boundingBox.Y+boundingBox.Height,
            boundingBox.X+boundingBox.Width+plainTextWidth/20, boundingBox.Y+boundingBox.Height);
        g->DrawLine(
            &lightGrayPen,
            boundingBox.X+boundingBox.Width, boundingBox.Y+boundingBox.Height,
            boundingBox.X+boundingBox.Width, boundingBox.Y+boundingBox.Height+plainTextHeight/20);



        WCHAR metricString[100];
        wsprintfW(metricString, L"Codepoints fitted %d\r\nLines filled %d\r\nRanges %d.", codepointsFitted, linesFilled, g_RangeCount);

        REAL x, y;
        if (g_formatFlags & StringFormatFlagsDirectionVertical)
        {
            if (g_formatFlags & StringFormatFlagsDirectionRightToLeft)
            {
                x = textRect.X;
                y = textRect.Y + textRect.Height/2;
            }
            else
            {
                x = textRect.X + textRect.Width;
                y = textRect.Y + textRect.Height/2;
            }
        }
        else
        {
            x = textRect.X + textRect.Width/2;
            y = textRect.Y + textRect.Height;
        }

        g->DrawString(
            metricString,-1,
            &Font(&FontFamily(L"Tahoma"), 12, NULL, UnitPoint),
            PointF(x, y),
            &format,
            &SolidBrush(Color(0x80,0x80,0x80))
        );

        g->MeasureString(
            metricString,-1,
            &Font(&FontFamily(L"Tahoma"), 12, NULL, UnitPoint),
            PointF(x, y),
            &format,
            &boundingBox
        );

        g->DrawRectangle(&lightGrayPen, boundingBox);
     }


    // Actually draw the text string. We do this last so it appears on top of
    // the construction and measurement lines we have just drawn.

    for(int iRender=0;iRender<g_iNumRenders;iRender++)
    {
        g->DrawString(g_wcBuf, g_iTextLen, &font, textRect, &format, g_textBrush);
    }




/*

    // Test Font from Logfont, and generic layout

    HDC derivedDc = g->GetHDC();

    HFONT hFont = CreateFontW(
        iLineHeight/2,        // height of font
        0,                    // average character width
        0,                    // angle of escapement
        0,                    // base-line orientation angle
        0,                    // font weight
        0,                    // italic attribute option
        1,                    // underline attribute option
        0,                    // strikeout attribute option
        1,                    // character set identifier
        0,                    // output precision
        0,                    // clipping precision
        0,                    // output quality
        0,                    // pitch and family
        g_style[0].faceName   // typeface name
    );

    HFONT hOldFont = (HFONT) SelectObject(hdc, hFont);
    Font fontFromDc(hdc);
    ExtTextOutW(hdc, prc->left, prc->bottom-iLineHeight, 0, NULL, L"By ExtTextOut - AaBbCcDdEeFfGgQq", 32, NULL);
    DeleteObject(SelectObject(hdc, hOldFont));
    g->ReleaseHDC(derivedDc);

    REAL emHeightInPoints = GetEmHeightInPoints(&fontFromDc, &g);


    // Test the easy layout string format

    g->DrawString(
        L"AaBbCcDdEeFfGgQq - DrawString default layout", -1,
        &fontFromDc, //  Font(*FontFamily::GenericMonospace(), 18.0, 0, UnitPoint),
        PointF(0.0, REAL(plainTextHeight/2 - iLineHeight)),
        StringFormat::GenericDefault(),
        &blackBrush
    );


    // Test typographic string format

    g->DrawString(
        L"Typographic layout", -1,
        &Font(FontFamily::GenericSansSerif(), 10),
        PointF(0.0, REAL(plainTextHeight/2 - 2*iLineHeight)),
        StringFormat::GenericTypographic(),
        &blackBrush
    );
*/


    delete g;

    if (metafile)
    {
        delete metafile;
    }

    if (g_testMetafile)
    {
        // Playback metafile to screen
        Metafile emfplus(L"c:\\texttest.emf");
        Graphics graphPlayback(hdc);
        graphPlayback.ResetTransform();
        graphPlayback.TranslateTransform(REAL(prc->left), REAL(*piY));
        graphPlayback.DrawImage(
            &emfplus,
            REAL(0),
            REAL(0),
            REAL(plainTextWidth),
            REAL(plainTextHeight)
        );
        graphPlayback.Flush();
    }

    *piY += plainTextHeight;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\texttest\dspgdi.cpp ===
////    DspGDI.CPP - Display strings with GDI API
//
//


#include "precomp.hxx"
#include "global.h"

void PaintGDI(
    HDC      hdc,
    int     *piY,
    RECT    *prc,
    int      iLineHeight)
{
    HFONT hfont, hfontOld;
    HBRUSH hbrush, hbrushOld;
    HPEN hpen, hpenOld;
    COLORREF color, colorOld;
    
    hfont = CreateFontW(
        -(INT)(g_style[0].emSize + 0.5),
        0,  //  int nWidth,                // average character width
        0,  //  int nEscapement,           // angle of escapement
        0,  //  int nOrientation,          // base-line orientation angle
        g_style[0].style & FontStyleBold ? 700 : 400,
        g_style[0].style & FontStyleItalic ? 1 : 0,
        g_style[0].style & FontStyleUnderline ? 1 : 0,
        g_style[0].style & FontStyleStrikeout ? 1 : 0,
        0,  //  DWORD fdwCharSet,          // character set identifier
        0,  //  DWORD fdwOutputPrecision,  // output precision
        0,  //  DWORD fdwClipPrecision,    // clipping precision
        g_TextMode == 3 ? ANTIALIASED_QUALITY : NONANTIALIASED_QUALITY,  //  DWORD fdwQuality,          // output quality
        0,  //  DWORD fdwPitchAndFamily,   // pitch and family
        g_style[0].faceName
    );

    Color textColor(g_TextColor);

    // Establish available width and height in device coordinates
    int plainTextWidth = prc->right - prc->left;
    int plainTextHeight = prc->bottom - *piY;

	RECT textRect = *prc;

    textRect.top = *piY;
    textRect.left = textRect.left + (plainTextWidth / 4);
    textRect.right = textRect.left + (plainTextWidth / 2);
    textRect.bottom = textRect.top + (plainTextHeight / 3);

    color = RGB(textColor.GetRed(), textColor.GetGreen(), textColor.GetBlue());

    hbrush = (HBRUSH)GetStockObject(HOLLOW_BRUSH);
    hpen = CreatePen(PS_SOLID, 0, color);

    colorOld = SetTextColor(hdc, color);
    hfontOld = (HFONT)SelectObject(hdc, hfont);
    hbrushOld = (HBRUSH)SelectObject(hdc, hbrush);
    hpenOld = (HPEN)SelectObject(hdc, hpen);

    SetBkMode(hdc, TRANSPARENT);

    PatBlt(hdc, prc->left, *piY, prc->right, prc->bottom, WHITENESS);

    for(int iRender=0;iRender<g_iNumRenders;iRender++)
    {
        if (g_UseDrawText)
        {
            int flags = DT_EXPANDTABS | DT_WORDBREAK;

            if (g_formatFlags & StringFormatFlagsNoWrap)
                flags |= DT_SINGLELINE;

            DrawTextW(
                hdc,
                g_wcBuf,
                g_iTextLen,
                &textRect,
                flags
            );
        }
        else
        {
            ExtTextOutW(
                hdc,
                textRect.left,
                textRect.top,
                ETO_CLIPPED,
                &textRect,
                g_wcBuf,
                g_iTextLen,
                NULL);
        }
    }

    Rectangle(hdc, textRect.left, textRect.top, textRect.right, textRect.bottom);

    GdiFlush();

    SetTextColor(hdc, colorOld);
    SelectObject(hdc, hbrushOld);
    SelectObject(hdc, hpenOld);
    SelectObject(hdc, hfontOld);

    DeleteObject(hpen);
    DeleteObject(hfont);

    *piY += (textRect.bottom - textRect.top) + iLineHeight;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\texttest\dspglyph.cpp ===
////    DspDraws.CPP - Display plaintext using DrawString API
//
//


#include "precomp.hxx"
#include "global.h"
#include "gdiplus.h"



void PaintGlyphs(
    HDC      hdc,
    int     *piY,
    RECT    *prc,
    int      iLineHeight) {

    int      icpLineStart;      // First character of line
    int      icpLineEnd;        // End of line (end of buffer or index of CR character)
    HFONT    hFont;
    HFONT    hOldFont;
    LOGFONT  lf;
    INT      row;
    INT      column;



    // Establish available width and height in device coordinates

    int DrawingWidth = prc->right - prc->left;
    int DrawingHeight = prc->bottom - *piY;

    // Establish a Graphics with 0,0 at the top left of the drawing area

    Graphics g(hdc);
    Matrix matrix;

    g.ResetTransform();
    g.SetPageUnit(UnitPixel);
    g.TranslateTransform(REAL(prc->left), REAL(*piY));

    // Clear the background

    RectF rEntire(0, 0, REAL(DrawingWidth), REAL(DrawingHeight));
    SolidBrush whiteBrush(Color(0xff, 0xff, 0xff));
    g.FillRectangle(&whiteBrush, rEntire);


    // Leave a little space for right and bottom margins

    DrawingWidth  -= DrawingWidth/40;
    DrawingHeight -= DrawingHeight/40;


    // Fill in a grid

    SolidBrush grayBrush(Color(0xc0, 0xc0, 0xc0));
    Pen        grayPen(&grayBrush, 2.0);

    SolidBrush darkGrayBrush(Color(0x80, 0x80, 0x80));
    Pen        darkGrayPen(&darkGrayBrush, 2.0);

    Color      blackColor(0, 0, 0);
    SolidBrush blackBrush(blackColor);
    Pen        blackPen(&blackBrush, 2.0);

    for (row = 0; row <= g_GlyphRows; row++)
    {
        g.DrawLine(&grayPen,
            0,              row*(DrawingHeight-1)/g_GlyphRows,
            DrawingWidth-1, row*(DrawingHeight-1)/g_GlyphRows);
    }
    for (column = 0; column <= g_GlyphColumns; column++)
    {
        g.DrawLine(&grayPen,
            column*(DrawingWidth-1)/g_GlyphColumns, 0,
            column*(DrawingWidth-1)/g_GlyphColumns, DrawingHeight-1);
    }


    // Identify cell dimensions

    INT cellHeight = (DrawingHeight-1)/g_GlyphRows;
    INT cellWidth  = (DrawingWidth-1)/g_GlyphColumns;

    Font font(&FontFamily(g_style[0].faceName), REAL(cellHeight)*2/3, 0, UnitWorld);

    REAL zero = 0;

    INT DriverStringFlags = 0;

    if (g_CmapLookup)
    {
        DriverStringFlags |= DriverStringOptionsCmapLookup;
    }
    if (g_VerticalForms)
    {
        DriverStringFlags |= DriverStringOptionsVertical;
    }

    // Loop through each character cell

    for (row = 0; row < g_GlyphRows; row++)
    {
        for (column = 0; column < g_GlyphColumns; column++)
        {
            UINT16 glyphIndex;

            if (g_HorizontalChart)
            {
                glyphIndex = g_GlyphFirst + row*g_GlyphColumns + column;
            }
            else
            {
                glyphIndex = g_GlyphFirst + column*g_GlyphRows + row;
            }

            // Set world transform to apply to individual glyphs (excludes translation)

            g.ResetTransform();
            g.SetTransform(&g_WorldTransform);

            // Translate world transform to centre of glyph cell

            REAL cellOriginX = float(prc->left + column*(DrawingWidth-1)/g_GlyphColumns) + float(cellWidth)/2;
            REAL cellOriginY = float(*piY      + row*(DrawingHeight-1)/g_GlyphRows)      + float(cellHeight)/2;

            g.TranslateTransform(cellOriginX, cellOriginY, MatrixOrderAppend);

            // Get glyph bounding box

            RectF untransformedBoundingBox;     // Without font transform
            RectF transformedBoundingBox;       // With font transform

            g.MeasureDriverString(
                &glyphIndex, 1,
                &font,
                &PointF(0,0),
                DriverStringFlags,
                NULL,
                &untransformedBoundingBox
            );

            g.MeasureDriverString(
                &glyphIndex, 1,
                &font,
                &PointF(0,0),
                DriverStringFlags,
                &g_FontTransform,
                &transformedBoundingBox
            );

            REAL glyphOriginX = - transformedBoundingBox.Width/2 - transformedBoundingBox.X;
            REAL glyphOriginY = - transformedBoundingBox.Height/2 - transformedBoundingBox.Y;

            if (g_ShowCell)
            {
                // Show cell around transformed glyph

                transformedBoundingBox.X = - transformedBoundingBox.Width/2;
                transformedBoundingBox.Y = - transformedBoundingBox.Height/2;
                g.DrawRectangle(&darkGrayPen, transformedBoundingBox);
            }

            // Display the glyph

            g.DrawDriverString(
                &glyphIndex, 1,
                &font,
                &blackBrush,
                &PointF(glyphOriginX, glyphOriginY),
                DriverStringFlags,
                &g_FontTransform
            );

            if (g_ShowCell)
            {
                // Show transformed cell around untransformed glyph

                g.MultiplyTransform(&g_FontTransform);

                glyphOriginX = - untransformedBoundingBox.Width/2 - untransformedBoundingBox.X;
                glyphOriginY = - untransformedBoundingBox.Height/2 - untransformedBoundingBox.Y;

                untransformedBoundingBox.X = - untransformedBoundingBox.Width/2;
                untransformedBoundingBox.Y = - untransformedBoundingBox.Height/2;
                g.DrawRectangle(&darkGrayPen, untransformedBoundingBox);

                // Show baseline

                g.DrawLine(
                    &darkGrayPen,
                    glyphOriginX - cellWidth/20,
                    glyphOriginY,
                    glyphOriginX + untransformedBoundingBox.Width + cellWidth/20 + 1,
                    glyphOriginY
                );
            }

        }
    }


    *piY += DrawingHeight;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\texttest\dsppath.cpp ===
////    DspPath.CPP - Display plaintext using AddString and DrawPath APIs
//
//


#include "precomp.hxx"
#include "global.h"




void PaintPath(
    HDC      hdc,
    int     *piY,
    RECT    *prc,
    int      iLineHeight) {

    int      icpLineStart;     // First character of line
    int      icpLineEnd;       // End of line (end of buffer or index of CR character)
    HFONT    hFont;
    HFONT    hOldFont;
    LOGFONT  lf;


    // Establish available width and height in device coordinates

    int plainTextWidth = prc->right - prc->left;
    int plainTextHeight = prc->bottom - *piY;


    // Draw a simple figure in the world coordinate system

    Graphics g(hdc);
    Matrix matrix;

    g.ResetTransform();
    g.SetPageUnit(UnitPixel);
    g.TranslateTransform(REAL(prc->left), REAL(*piY));

    // Clear the background

    RectF rEntire(0, 0, REAL(plainTextWidth), REAL(plainTextHeight));
    SolidBrush whiteBrush(Color(0xff, 0xff, 0xff));
    g.FillRectangle(&whiteBrush, rEntire);


    // Apply selected world transform, adjusted to middle of the plain text
    // area.

    g.SetTransform(&g_WorldTransform);
    g.TranslateTransform(
        REAL(prc->left + plainTextWidth/2),
        REAL(*piY + plainTextHeight/2),
        MatrixOrderAppend);

    // Put some text in the middle

    RectF textRect(REAL(-25*plainTextWidth/100), REAL(-25*plainTextHeight/100),
                   REAL( 50*plainTextWidth/100), REAL( 50*plainTextHeight/100));



    StringFormat format(g_formatFlags);
    format.SetTrimming(g_lineTrim);
    format.SetAlignment(g_align);
    format.SetLineAlignment(g_lineAlign);
    format.SetHotkeyPrefix(g_hotkey);

    REAL tab[3] = {textRect.Width/4,
                   textRect.Width*3/16,
                   textRect.Width*1/8};

    format.SetTabStops(0.0, sizeof(tab)/sizeof(REAL), tab);

    Color      blackColor(0, 0, 0);
    SolidBrush blackBrush(blackColor);
    Pen        blackPen(&blackBrush, 1.0);
	
	for(int iRender=0;iRender<g_iNumRenders;iRender++)
	{
	    GraphicsPath path;
	
	    path.AddString(
	        g_wcBuf,
	        g_iTextLen,
	       &FontFamily(g_style[0].faceName),
	        g_style[0].style,
	        REAL(g_style[0].emSize * g.GetDpiY() / 72.0),
	       textRect,
	       &format);
	
	    g.DrawPath(&blackPen, &path);
	}

    // Show the text rectangle

	if (!g_AutoDrive)
	{
	    g.DrawRectangle(&blackPen, textRect);
	}

    *piY += plainTextHeight;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\texttest\dspmetric.cpp ===
////    DspMetric.CPP - Display font metrics
//
//


#include "precomp.hxx"
#include "global.h"




void AnnotateHeight(
    Graphics &g,
    Color     c,
    Font     &f,
    REAL      x,
    REAL      y1,
    REAL      y2,
    WCHAR    *id
)
{
    SolidBrush brush(c);
    Pen        pen(&brush, 2.0);

    pen.SetLineCap(LineCapArrowAnchor, LineCapArrowAnchor, DashCapFlat);

    g.DrawLine(&pen, x,y1, x,y2);
    g.DrawString(id,-1, &f, PointF(x,(y1+y2)/2), NULL, &brush);
}




void PaintMetrics(
    HDC      hdc,
    int     *piY,
    RECT    *prc,
    int      iLineHeight) {

    int      icpLineStart;      // First character of line
    int      icpLineEnd;        // End of line (end of buffer or index of CR character)
    HFONT    hFont;
    HFONT    hOldFont;
    LOGFONT  lf;
    INT      row;
    INT      column;



    // Establish available width and height in device coordinates

    int DrawingWidth = prc->right - prc->left;
    int DrawingHeight = prc->bottom - *piY;

    // Establish a Graphics with 0,0 at the top left of the drawing area

    Graphics g(hdc);
    Matrix matrix;

    g.ResetTransform();
    g.SetPageUnit(UnitPixel);
    g.TranslateTransform(REAL(prc->left), REAL(*piY));

    // Clear the background

    RectF rEntire(0, 0, REAL(DrawingWidth), REAL(DrawingHeight));
    SolidBrush whiteBrush(Color(0xff, 0xff, 0xff));
    g.FillRectangle(&whiteBrush, rEntire);


    // Leave a little space for right and bottom margins

    DrawingWidth  -= DrawingWidth/40;
    DrawingHeight -= DrawingHeight/40;

    Color      blackColor(0, 0, 0);
    SolidBrush blackBrush(blackColor);
    Pen        blackPen(&blackBrush, 2.0);

    Color      grayColor(0xc0, 0xc0, 0xc0);
    SolidBrush grayBrush(grayColor);
    Pen        grayPen(&grayBrush, 2.0);


    // Measure the string to see how wide it would be

    FontFamily family(g_style[0].faceName);

    StringFormat format(StringFormat::GenericTypographic());
    format.SetFormatFlags(g_formatFlags | StringFormatFlagsNoWrap | StringFormatFlagsLineLimit);
    format.SetAlignment(g_align);

    RectF bounds;

    // Since we've chosen a size of 1.0 for the font height, MeasureString
    // will return the width as a multiple of the em height in bounds.Width.

    g.MeasureString(
        g_wcBuf,
        g_iTextLen,
        &Font(&family, 1.0, g_style[0].style, UnitWorld),
        PointF(0, 0),
        &format,
        &bounds
    );



    // Establish font metrics


    if (family.IsStyleAvailable(g_style[0].style))
    {
        // Establish line and cell dimensions in  units

        INT emHeight    = family.GetEmHeight(g_style[0].style);
        INT cellAscent  = family.GetCellAscent(g_style[0].style);
        INT cellDescent = family.GetCellDescent(g_style[0].style);
        INT lineSpacing = family.GetLineSpacing(g_style[0].style);

        #if TEXTV2
        INT typoAscent  = family.GetTypographicAscent(g_style[0].style);
        INT typoDescent = family.GetTypographicDescent(g_style[0].style);
        INT typoLineGap = family.GetTypographicLineGap(g_style[0].style);

        if (typoDescent < 0)
        {
            typoDescent = -typoDescent;
        }

        INT typoLineSpacing =   typoAscent + typoDescent + typoLineGap;
        #endif


        INT cellHeight      =   cellAscent + cellDescent;

        // We will display two lines from top of upper cell to bottom of lower
        // cell, with the lines separated by the typographic ascent + descent +
        // line gap.

        INT totalHeightInUnits = lineSpacing + cellHeight;
        REAL scale = REAL(DrawingHeight) / REAL(totalHeightInUnits);

        REAL worldEmHeight = emHeight * scale;



        // Now allow for the width of the string - if it would be wider than
        // the available DrawingWIdth, reduce the font size proportionately.

        if (worldEmHeight * bounds.Width > DrawingWidth)
        {
            REAL reduceBy = DrawingWidth / (worldEmHeight * bounds.Width);

            scale         *= reduceBy;
            worldEmHeight  = emHeight * scale;
        }

        Font font(&family, worldEmHeight, g_style[0].style, UnitWorld);


        // Draw two lines of text

        g.DrawString(
            g_wcBuf,
            g_iTextLen,
            &font,
            RectF(0, 0, REAL(DrawingWidth), REAL(DrawingHeight)),
            &format,
            &blackBrush
        );

        g.DrawString(
            g_wcBuf,
            g_iTextLen,
            &font,
            RectF(0, lineSpacing * scale, REAL(DrawingWidth), REAL(DrawingHeight)),
            &format,
            &grayBrush
        );

        // Draw lines

        REAL y=0;                                              g.DrawLine(&blackPen, 0.0,y, REAL(DrawingWidth-1),y);

        // Draw lines for second row first, in case they're oblitereated by first row.

        y = scale * (lineSpacing);                             g.DrawLine(&grayPen,  0.0,y, REAL(DrawingWidth-1),y);
        y = scale * (lineSpacing + cellAscent);                g.DrawLine(&grayPen,  0.0,y, REAL(DrawingWidth-1),y);
        y = scale * (lineSpacing + cellHeight);                g.DrawLine(&grayPen,  0.0,y, REAL(DrawingWidth-1),y);

        g.DrawLine(&blackPen, 0.0,0.0, REAL(DrawingWidth-1),0.0);
        y = scale * (cellAscent);                              g.DrawLine(&blackPen, 0.0,y, REAL(DrawingWidth-1),y);
        y = scale * (cellHeight);                              g.DrawLine(&blackPen, 0.0,y, REAL(DrawingWidth-1),y);

        // Add construction lines.

        Font  annotationFont(FontFamily::GenericSansSerif(), 10, 0, UnitPoint);
        Color darkGrayColor(0x80, 0x80, 0x80);

        AnnotateHeight(g, darkGrayColor, annotationFont, REAL(DrawingWidth/100.0),    0, scale*cellAscent, L"ascent");
        AnnotateHeight(g, darkGrayColor, annotationFont, REAL(DrawingWidth/100.0),    scale*cellAscent, scale*cellHeight, L"descent");
        AnnotateHeight(g, darkGrayColor, annotationFont, REAL(95*DrawingWidth/100.0), 0, scale*lineSpacing, L"line spacing");
        AnnotateHeight(g, darkGrayColor, annotationFont, REAL(DrawingWidth/10.0),     scale*(cellHeight-emHeight), scale*cellHeight, L"Em Height");


        #if TEXTV2
        y = scale * (cellAscent - typoAscent);                 g.DrawLine(&grayPen,  0.0,y, REAL(DrawingWidth-1),y);
        y = scale * (cellAscent + typoDescent);                g.DrawLine(&grayPen,  0.0,y, REAL(DrawingWidth-1),y);

        y = scale * (lineSpacing + cellAscent - typoAscent);   g.DrawLine(&grayPen,  0.0,y, REAL(DrawingWidth-1),y);
        y = scale * (lineSpacing + cellAscent + typoDescent);  g.DrawLine(&grayPen,  0.0,y, REAL(DrawingWidth-1),y);
        #endif


        // Test font.GetHeight

        REAL fontHeight = font.GetHeight(&g);

        g.DrawLine(&blackPen, REAL(DrawingWidth-1),0.0, REAL(DrawingWidth-1),fontHeight);

    }

    *piY += 41*DrawingHeight/40;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\texttest\dspperf.cpp ===
////    DspPerf.CPP - Test and display performance
//
//


#include "precomp.hxx"
#include "global.h"


#if defined(i386)


double TimeDrawString(
    Graphics  *g,
    RectF     *textRect
)
{
    StringFormat format(g_formatFlags);
    format.SetAlignment(g_align);
    format.SetLineAlignment(g_lineAlign);
    format.SetHotkeyPrefix(g_hotkey);

    REAL tab[3] = {textRect->Width/4,
                   textRect->Width*3/16,
                   textRect->Width*1/8};

    format.SetTabStops(0.0, sizeof(tab)/sizeof(REAL), tab);

    Color      blackColor(0, 0, 0);
    SolidBrush blackBrush(blackColor);
    Pen        blackPen(&blackBrush, 1.0);

    Font font(&FontFamily(g_style[0].faceName), REAL(g_style[0].emSize), g_style[0].style, g_fontUnit);


    // Once to load the cache

    g->DrawString(g_wcBuf, g_iTextLen, &font, *textRect, &format, g_textBrush);

    ShowCursor(FALSE);
    g->Flush(FlushIntentionSync);
    GdiFlush();

    __int64 timeAtStart;
    _asm {
        _emit 0FH
        _emit 31H
        mov dword ptr timeAtStart+4,edx
        mov dword ptr timeAtStart,eax
    }

    // Now paint again repeatedly and measure the time taken

    for (INT i=0; i<g_PerfRepeat; i++)
    {
        g->DrawString(g_wcBuf, g_iTextLen, &font, *textRect, &format, g_textBrush);
    }

    g->Flush(FlushIntentionSync);
    GdiFlush();

    __int64 timeAtEnd;
    _asm {
        _emit 0FH
        _emit 31H
        mov dword ptr timeAtEnd+4,edx
        mov dword ptr timeAtEnd,eax
    }

    ShowCursor(TRUE);

    return (timeAtEnd - timeAtStart) / 1000000.0;
}



double TimeDrawText(
    Graphics *g,
    INT x,
    INT y,
    INT width,
    INT height
)
{
    g->Flush(FlushIntentionSync);   // Th is may not be necessary.
    HDC hdc = g->GetHDC();

    HFONT hfont = CreateFontW(
        -(INT)(g_style[0].emSize + 0.5),
        0,  //  int nWidth,                // average character width
        0,  //  int nEscapement,           // angle of escapement
        0,  //  int nOrientation,          // base-line orientation angle
        g_style[0].style & FontStyleBold ? 700 : 400,
        g_style[0].style & FontStyleItalic ? 1 : 0,
        g_style[0].style & FontStyleUnderline ? 1 : 0,
        g_style[0].style & FontStyleStrikeout ? 1 : 0,
        0,  //  DWORD fdwCharSet,          // character set identifier
        0,  //  DWORD fdwOutputPrecision,  // output precision
        0,  //  DWORD fdwClipPrecision,    // clipping precision
        NONANTIALIASED_QUALITY,  //  DWORD fdwQuality,          // output quality
        0,  //  DWORD fdwPitchAndFamily,   // pitch and family
        g_style[0].faceName
    );
    HFONT hOldFont = (HFONT) SelectObject(hdc, hfont);

    RECT textRECT;
    textRECT.left   = x;
    textRECT.top    = y;
    textRECT.right  = x + width;
    textRECT.bottom = y + height;

    SetBkMode(hdc, TRANSPARENT);

    DrawTextW(
        hdc,
        g_wcBuf,
        g_iTextLen,
        &textRECT,
        DT_EXPANDTABS | DT_WORDBREAK
    );

    ShowCursor(FALSE);
    GdiFlush();

    __int64 timeAtStart;
    _asm {
        _emit 0FH
        _emit 31H
        mov dword ptr timeAtStart+4,edx
        mov dword ptr timeAtStart,eax
    }

    // Now paint again repeatedly and measure the time taken

    for (INT i=0; i<g_PerfRepeat; i++)
    {
        DrawTextW(
            hdc,
            g_wcBuf,
            g_iTextLen,
            &textRECT,
            DT_EXPANDTABS | DT_WORDBREAK
        );
    }

    GdiFlush();

    __int64 timeAtEnd;
    _asm {
        _emit 0FH
        _emit 31H
        mov dword ptr timeAtEnd+4,edx
        mov dword ptr timeAtEnd,eax
    }

    ShowCursor(TRUE);
    DeleteObject(SelectObject(hdc, hOldFont));

    g->ReleaseHDC(hdc);

    return (timeAtEnd - timeAtStart) / 1000000.0;
}


double TimeExtTextOut(
    Graphics *g,
    INT x,
    INT y,
    INT width,
    INT height
)
{
    HDC hdc = g->GetHDC();

    HFONT hfont = CreateFontW(
        -(INT)(g_style[0].emSize + 0.5),
        0,  //  int nWidth,                // average character width
        0,  //  int nEscapement,           // angle of escapement
        0,  //  int nOrientation,          // base-line orientation angle
        g_style[0].style & FontStyleBold ? 700 : 400,
        g_style[0].style & FontStyleItalic ? 1 : 0,
        g_style[0].style & FontStyleUnderline ? 1 : 0,
        g_style[0].style & FontStyleStrikeout ? 1 : 0,
        0,  //  DWORD fdwCharSet,          // character set identifier
        0,  //  DWORD fdwOutputPrecision,  // output precision
        0,  //  DWORD fdwClipPrecision,    // clipping precision
        NONANTIALIASED_QUALITY,  //  DWORD fdwQuality,          // output quality
        0,  //  DWORD fdwPitchAndFamily,   // pitch and family
        g_style[0].faceName
    );
    HFONT hOldFont = (HFONT) SelectObject(hdc, hfont);

    RECT textRECT;
    textRECT.left   = x;
    textRECT.top    = y;
    textRECT.right  = x + width;
    textRECT.bottom = y + height;

    SetBkMode(hdc, TRANSPARENT);

    ExtTextOutW(
        hdc,
        textRECT.left,
        textRECT.top,
        ETO_IGNORELANGUAGE,
        &textRECT,
        g_wcBuf,
        g_iTextLen,
        NULL
    );

    ShowCursor(FALSE);
    GdiFlush();

    __int64 timeAtStart;
    _asm {
        _emit 0FH
        _emit 31H
        mov dword ptr timeAtStart+4,edx
        mov dword ptr timeAtStart,eax
    }

    // Now paint again repeatedly and measure the time taken

    for (INT i=0; i<g_PerfRepeat; i++)
    {
        ExtTextOutW(
            hdc,
            textRECT.left,
            textRECT.top,
            ETO_IGNORELANGUAGE,
            &textRECT,
            g_wcBuf,
            g_iTextLen,
            NULL
        );
    }

    GdiFlush();

    __int64 timeAtEnd;
    _asm {
        _emit 0FH
        _emit 31H
        mov dword ptr timeAtEnd+4,edx
        mov dword ptr timeAtEnd,eax
    }

    ShowCursor(TRUE);
    DeleteObject(SelectObject(hdc, hOldFont));

    g->ReleaseHDC(hdc);

    return (timeAtEnd - timeAtStart) / 1000000.0;
}

#endif // defined(i386)


void PaintPerformance(
    HDC      hdc,
    int     *piY,
    RECT    *prc,
    int      iLineHeight) {

    int      icpLineStart;     // First character of line
    int      icpLineEnd;       // End of line (end of buffer or index of CR character)
    HFONT    hFont;
    HFONT    hOldFont;
    LOGFONT  lf;


    // Establish available width and height in device coordinates

    int plainTextWidth = prc->right - prc->left;
    int plainTextHeight = prc->bottom - *piY;


    // Paint some simple text, and then repaint it several times measuring the
    // time taken.

    Graphics g(hdc);
    Matrix matrix;


    g.ResetTransform();
    g.SetPageUnit(UnitPixel);
    g.TranslateTransform(REAL(prc->left), REAL(*piY));
    g.SetSmoothingMode(g_SmoothingMode);

    g.SetTextContrast(g_GammaValue);
    g.SetTextRenderingHint(g_TextMode);

    // Clear the background

    RectF rEntire(0, 0, REAL(plainTextWidth), REAL(plainTextHeight));
    SolidBrush whiteBrush(Color(0xff, 0xff, 0xff));
    g.FillRectangle(g_textBackBrush, rEntire);


    // Apply selected world transform, adjusted a little from the top left
    // of the available area.

    g.SetTransform(&g_WorldTransform);
    g.TranslateTransform(
        REAL(prc->left + plainTextWidth/20),
        REAL(*piY + plainTextHeight/20),
        MatrixOrderAppend);


#if defined(i386)


    double drawString = TimeDrawString(
        &g,
        &RectF(
            0.0,
            0.0,
            REAL(plainTextWidth*18.0/20.0),
            REAL(plainTextHeight*5.0/20.0)
        )
    );

    double drawText = TimeDrawText(
        &g,
        prc->left + plainTextWidth/20,
        *piY + 6*plainTextHeight/20,
        (18 * plainTextWidth)/20,
        (5 * plainTextHeight)/20
    );

    double extTextOut = TimeExtTextOut(
        &g,
        prc->left + plainTextWidth/20,
        *piY + 12*plainTextHeight/20,
        (18 * plainTextWidth)/20,
        (2 * plainTextHeight)/20
    );

    // Display the time taken

    RectF statisticsRect(
        0.0,
        REAL(plainTextHeight*15.0/20.0),
        REAL(plainTextWidth*18.0/20.0),
        REAL(plainTextHeight*5.0/20.0)
    );

    Font font(&FontFamily(L"Verdana"), 12, 0, UnitPoint);

    char drawStringFormatted[20]; _gcvt(drawString, 10, drawStringFormatted);
    char drawTextFormatted[20];   _gcvt(drawText,   10, drawTextFormatted);
    char extTextOutFormatted[20]; _gcvt(extTextOut, 10, extTextOutFormatted);

    WCHAR str[200];
    wsprintfW(str, L"Time taken to display %d times: DrawString %S, DrawText %S, ExtTextOut %S megaticks\n",
        g_PerfRepeat,
        drawStringFormatted,
        drawTextFormatted,
        extTextOutFormatted
    );
    g.DrawString(str, -1, &font, statisticsRect, NULL, g_textBrush);



#else

    Font font(&FontFamily(L"Verdana"), 12, 0, UnitPoint);
    g.DrawString(L"Perf test available only on i386 Intel architecture", -1, &font, PointF(0.0,0.0), NULL, g_textBrush);

#endif

    *piY += plainTextHeight;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\texttest\dspscaling.cpp ===
////    DspScaling.CPP - DIsplay effect of hinting on text scaling
//
//      Tests for clipping and alignment problems in scaled text
//
//      Fixed pitch font misalignment
//      Leading space alignment
//      Overhang sufficient for italic and other overhanging glyphs
//



#include "precomp.hxx"
#include "global.h"
#include "gdiplus.h"






// Makebitmap

void MakeBitmap(
    IN  INT       width,
    IN  INT       height,
    OUT HBITMAP  *bitmap,
    OUT DWORD   **bits
)
{
    struct {
        BITMAPINFOHEADER  bmih;
        RGBQUAD           rgbquad[2];
    } bmi;

    bmi.bmih.biSize          = sizeof(bmi.bmih);
    bmi.bmih.biWidth         = width;
    bmi.bmih.biHeight        = height;
    bmi.bmih.biPlanes        = 1;
    bmi.bmih.biBitCount      = 32;
    bmi.bmih.biCompression   = BI_RGB;
    bmi.bmih.biSizeImage     = 0;
    bmi.bmih.biXPelsPerMeter = 3780; // 96 dpi
    bmi.bmih.biYPelsPerMeter = 3780; // 96 dpi
    bmi.bmih.biClrUsed       = 0;
    bmi.bmih.biClrImportant  = 0;

    memset(bmi.rgbquad, 0, 2 * sizeof(RGBQUAD));

    *bitmap = CreateDIBSection(
        NULL,
        (BITMAPINFO*)&bmi,
        DIB_RGB_COLORS,
        (void**)bits,
        NULL,
        NULL
    );
    
    
    // Initialise bitmap to white
    
    memset(*bits, 0xFF, width*height*sizeof(DWORD));
}




void PaintStringAsDots(
    HDC      hdc,
    INT      x,
    INT      *y, 
    INT      displayWidth,
    INT      ppem,
    BOOL     useGdi
)
{

    HBITMAP glyphs;
    DWORD *gbits;

    INT height = (ppem * 3) / 2;
    INT width = height * 16;

    MakeBitmap(width, height, &glyphs, &gbits);

    HDC hdcg = CreateCompatibleDC(hdc);

    if (!(glyphs && hdcg))
    {
        return;
    }

    SelectObject(hdcg, glyphs);
    
    if (useGdi) 
    {
        // Output with GDI

        HFONT oldFont = (HFONT)SelectObject(hdcg, CreateFontW(
            -ppem,                 // height of font
            0,                     // average character width
            0,                     // angle of escapement
            0,                     // base-line orientation angle
            g_style[0].style & FontStyleBold ? 700 : 400,  // font weight                
            g_style[0].style & FontStyleItalic ? 1 : 0,    // italic attribute option    
            0,                     // underline attribute option 
            0,                     // strikeout attribute option 
            DEFAULT_CHARSET,       // character set identifier   
            0,                     // output precision           
            0,                     // clipping precision         
            0,                     // output quality             
            0,                     // pitch and family           
            g_style[0].faceName    // typeface name
        ));        
        SetBkMode(hdcg, TRANSPARENT);
        ExtTextOutW(hdcg, 0,0, ETO_IGNORELANGUAGE, NULL, g_wcBuf, g_iTextLen, NULL);
        DeleteObject(SelectObject(hdcg, oldFont));
    }
    else
    {
        // Output with Gdiplus

        Graphics g(hdcg);

        Font(
            &FontFamily(g_style[0].faceName),
            REAL(ppem),
            g_style[0].style,
            UnitPixel
        );

        StringFormat format(g_typographic ? StringFormat::GenericTypographic() : StringFormat::GenericDefault());
        format.SetFormatFlags(g_formatFlags);
        format.SetTrimming(g_lineTrim);
        format.SetAlignment(g_align);
        format.SetLineAlignment(g_lineAlign);
        format.SetHotkeyPrefix(g_hotkey);

        g.DrawString(
            g_wcBuf, 
            g_iTextLen, 
            &Font(
                &FontFamily(g_style[0].faceName),
                REAL(ppem),
                g_style[0].style,
                UnitPixel
            ), 
            RectF(0,0, REAL(width), REAL(height)),
            &format, 
            g_textBrush
        );
    }
    

    // Display scaled bitmap

    StretchBlt(hdc, x, *y, displayWidth, displayWidth/16, hdcg, 0, 0, width, height, SRCCOPY);
    *y += displayWidth/16;

    DeleteObject(hdcg);
    DeleteObject(glyphs);
}






void PaintScaling(
    HDC      hdc,
    int     *piY,
    RECT    *prc,
    int      iLineHeight) {


    // Establish available width and height in device coordinates

    int plainTextWidth = prc->right - prc->left;
    int plainTextHeight = prc->bottom - *piY;

    // Paint eqach resolution first with GDI, then again with GdiPlus
    
    PaintStringAsDots(hdc, prc->left, piY, plainTextWidth, 11, TRUE);  // 96  dpi 8pt
    PaintStringAsDots(hdc, prc->left, piY, plainTextWidth, 11, FALSE); // 96  dpi 8pt
    
    PaintStringAsDots(hdc, prc->left, piY, plainTextWidth, 13, TRUE);  // 120 dpi 8pt
    PaintStringAsDots(hdc, prc->left, piY, plainTextWidth, 13, FALSE); // 120 dpi 8pt
    
    PaintStringAsDots(hdc, prc->left, piY, plainTextWidth, 17, TRUE);  // 150 dpi 8pt
    PaintStringAsDots(hdc, prc->left, piY, plainTextWidth, 17, FALSE); // 150 dpi 8pt
    
    PaintStringAsDots(hdc, prc->left, piY, plainTextWidth, 33, TRUE);  // 300 dpi 8pt
    PaintStringAsDots(hdc, prc->left, piY, plainTextWidth, 33, FALSE); // 300 dpi 8pt
    
    PaintStringAsDots(hdc, prc->left, piY, plainTextWidth, 67, TRUE);  // 600 dpi 8pt
    PaintStringAsDots(hdc, prc->left, piY, plainTextWidth, 67, FALSE); // 600 dpi 8pt
}



void DummyPaintScaling(
    HDC      hdc,
    int     *piY,
    RECT    *prc,
    int      iLineHeight
) 
{
    int      icpLineStart;     // First character of line
    int      icpLineEnd;       // End of line (end of buffer or index of CR character)

    // Establish available width and height in device coordinates

    int plainTextWidth = prc->right - prc->left;
    int plainTextHeight = prc->bottom - *piY;

    Graphics g(hdc);
    Matrix matrix;


    g.ResetTransform();
    g.SetPageUnit(UnitPixel);
    g.TranslateTransform(REAL(prc->left), REAL(*piY));

    g.SetSmoothingMode(g_SmoothingMode);

    g.SetTextContrast(g_GammaValue);
    g.SetTextRenderingHint(g_TextMode);

    SolidBrush whiteBrush(Color(0xff, 0xff, 0xff));

    Color      grayColor(0xc0, 0xc0, 0xc0);
    SolidBrush grayBrush(grayColor);
    Pen        grayPen(&grayBrush, 1.0);

    Color      blackColor(0, 0, 0);
    SolidBrush blackBrush(blackColor);
    Pen        blackPen(&blackBrush, 1.0);



    // Clear the background

    RectF rEntire(0, 0, REAL(plainTextWidth), REAL(plainTextHeight));
    g.FillRectangle(g_textBackBrush, rEntire);


    // Apply selected world transform, adjusted to middle of the plain text
    // area.

    g.SetTransform(&g_WorldTransform);
    g.TranslateTransform(
        REAL(prc->left + plainTextWidth/2),
        REAL(*piY + plainTextHeight/2),
        MatrixOrderAppend);


    // Preset a StringFormat with user settings

    StringFormat format(g_formatFlags);
    format.SetAlignment(g_align);
    format.SetLineAlignment(g_lineAlign);
    format.SetHotkeyPrefix(g_hotkey);

    double columnWidth = 50*plainTextWidth/300;

    REAL tab[3] = {REAL(columnWidth/4),
                   REAL(columnWidth*3/16),
                   REAL(columnWidth*1/8)};

    format.SetTabStops(0.0, sizeof(tab)/sizeof(REAL), tab);


    // Display string at a range of sizes

    double x = -25*plainTextWidth/100;
    double y = -25*plainTextHeight/100;


    for (INT i=6; i<20; i++)
    {
        Font font(
            &FontFamily(g_style[0].faceName),
            REAL(i),
            g_style[0].style,
            g_fontUnit
        );

        REAL cellHeight = font.GetHeight(&g);

        if (y+cellHeight > 25*plainTextHeight/100)
        {
            // Start a new column ...
            y = -25*plainTextWidth/100;
            x += columnWidth;
        }

        RectF textRect(REAL(x), REAL(y), REAL(9*columnWidth/10), cellHeight);
        g.DrawString(g_wcBuf, g_iTextLen, &font, textRect, &format, g_textBrush);


        // Draw formatting rectangle around box

        g.DrawRectangle(&grayPen, textRect);


        y += cellHeight + 5;
    }

    *piY += plainTextHeight;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\texttest\edit.cpp ===
////    TEXTEDIT.C
//
//


#include "precomp.hxx"
#include "global.h"





BOOL EditKeyDown(WCHAR wc) {

    switch(wc) {

        case VK_LEFT:
            if (g_iCurChar) {
                g_iCurChar--;
                if (    g_iCurChar
                    &&  g_wcBuf[g_iCurChar] == 0x000A
                    &&  g_wcBuf[g_iCurChar-1] == 0x000D) {
                    g_iCurChar--;
                }

                // If shift is down, extend selection, else clear it
                if (GetKeyState(VK_SHIFT) >= 0) {
                    g_iFrom = g_iCurChar;
                }
                g_iTo = g_iCurChar;

                InvalidateText();
                g_fUpdateCaret = TRUE;
            }
            break;


        case VK_RIGHT:
            if (g_iCurChar < g_iTextLen) {
                if (    g_iCurChar < g_iTextLen-1
                    &&  g_wcBuf[g_iCurChar] == 0x000D
                    &&  g_wcBuf[g_iCurChar+1] == 0x000A) {
                    g_iCurChar+= 2;
                } else {
                    g_iCurChar++;
                }

                // If shift is down, extend selection, else clear it
                if (GetKeyState(VK_SHIFT) >= 0) {
                    g_iFrom = g_iCurChar;
                }
                g_iTo = g_iCurChar;

                InvalidateText();
                g_fUpdateCaret = TRUE;
            }
            break;


        case VK_HOME:
            // Implemented as - go to start of text
            g_iCurChar = 0;
            g_iFrom    = 0;
            g_iTo      = 0;
            InvalidateText();
            g_fUpdateCaret = TRUE;
            break;


        case VK_END:
            // Implemented as - go to end of text
            g_iCurChar = g_iTextLen;
            g_iFrom    = g_iTextLen;
            g_iTo      = g_iTextLen;
            InvalidateText();
            g_fUpdateCaret = TRUE;
            break;

        case VK_INSERT:
            if (g_RangeCount < MAX_RANGE_COUNT)
            {
                g_Ranges[g_RangeCount].First = g_iFrom;
                g_Ranges[g_RangeCount].Length = g_iTo - g_iFrom;
                g_RangeCount++;
            }
            InvalidateText();
            break;

        case VK_DELETE:
            if (GetKeyState(VK_LSHIFT) & 0x8000)
            {
                g_RangeCount = 0;
            }
            else
            {
                if (g_iFrom != g_iTo) {

                    // Delete selection

                    if (g_iFrom < g_iTo) {
                        TextDelete(g_iFrom, g_iTo-g_iFrom);
                        g_iTo      = g_iFrom;
                        g_iCurChar = g_iFrom;
                    } else {
                        TextDelete(g_iTo, g_iFrom-g_iTo);
                        g_iTo      = g_iTo;
                        g_iCurChar = g_iTo;
                    }

                } else {

                    // Delete character

                    if (g_iCurChar < g_iTextLen) {
                        if (    g_iCurChar < g_iTextLen-1
                            &&  g_wcBuf[g_iCurChar] == 0x000D
                            &&  g_wcBuf[g_iCurChar+1] == 0x000A) {
                            TextDelete(g_iCurChar, 2);
                        } else {
                            TextDelete(g_iCurChar, 1);
                        }
                    }
                }
            }

            InvalidateText();
            g_fUpdateCaret = TRUE;
            break;
    }

    return TRUE;
}






BOOL EditChar(WCHAR wc) {

    switch(wc) {

        case VK_RETURN:
            if (!TextInsert(g_iCurChar, L"\r\n", 2))
                return FALSE;
            InvalidateText();
            g_iCurChar+=2;
            break;


        case VK_BACK:
            if (g_iCurChar) {
                g_iCurChar--;
                if (    g_iCurChar
                    &&  g_wcBuf[g_iCurChar] == 0x000A
                    &&  g_wcBuf[g_iCurChar-1] == 0x000D) {
                    g_iCurChar--;
                    TextDelete(g_iCurChar, 2);
                } else {
                    TextDelete(g_iCurChar, 1);
                }
                InvalidateText();
                g_fUpdateCaret = TRUE;
            }
            break;


        case 1:  // Ctrl/A - select all
            g_iFrom = 0;
            g_iTo = g_iTextLen;
            InvalidateText();
            break;


        default:
            /*
                if(!((wc >= 0x0900 && wc < 0x0d80)
                      || wc == 0x200c
                      || wc == 0x200d)){
                    TranslateCharToUnicode(&wc);
                }
            */

            if (!TextInsert(g_iCurChar, &wc, 1)) {
                return FALSE;
            }


            // If there was a range marked previously, now delete that range

            if (g_iFrom < g_iTo) {
                TextDelete(g_iFrom, g_iTo-g_iFrom);
                g_iTo      = g_iFrom;
                g_iCurChar = g_iFrom+1;
            } else if (g_iTo < g_iFrom) {
                TextDelete(g_iTo, g_iFrom-g_iTo);
                g_iFrom    = g_iTo;
                g_iCurChar = g_iTo+1;
            } else {
                // No prior selected text
                g_iCurChar++;

            }

            InvalidateText();
            g_fUpdateCaret = TRUE;
            break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\texttest\dsplogcl.cpp ===
////    DspLogcl - Display logical text
//
//      Shows logical characters and selection range in backing store order and fixed width.


#include "precomp.hxx"
#include "global.h"






////    DottedLine
//
//      Draws a horizontal or a vertical dotted line
//
//      Not the best algorithm.


void DottedLine(HDC hdc, int x, int y, int dx, int dy) {

    SetPixel(hdc, x, y, 0);

    if (dx) {

        // Horizontal line

        while (dx > 2) {
            x += 3;
            SetPixel(hdc, x, y, 0);
            dx -= 3;
        }
        x += dx;
        SetPixel(hdc, x, y, 0);

    } else {

        // Vertical line

        while (dy > 2) {
            y += 3;
            SetPixel(hdc, x, y, 0);
            dy -= 3;
        }
        y += dy;
        SetPixel(hdc, x, y, 0);
    }
}






////    PaintLogical - show characters in logical sequence
//
//      Display each glyph separately - override the default advance width
//      processing to defeat any overlapping or combining action that the
//      font performs with it's default ABC width.
//
//      To achieve this, we call ScriptGetGlyphABCWidth to obtain the
//      leading side bearing (A), the black box width (B) and the trailing
//      side bearing (C).
//
//      Since we can control only the advance width per glyph, we have to
//      calulate suitable advance widths to override the affect of the
//      ABC values in the font.
//
//      You should never normally need to call ScriptGetGlyphABCWidth.
//
//      PaintLogical has to implement a form of font fallback - Indian and
//      Tamil scripts are not present in Tahoma, so we go
//      directly to Mangal and Latha for characters in those Unicode ranges.


void PaintLogical(
    HDC   hdc,
    int  *piY,
    RECT *prc,
    int   iLineHeight) {

    const int MAXBUF     = 100;
    const int CELLGAP    = 4;      // Pixels between adjacent glyphs

    int   icpLineStart;     // First character of line
    int   icpLineEnd;       // End of line (end of buffer or index of CR character)
    int   icp;
    int   iLen;
    int   iPartLen;         // Part of string in a single font
    int   iPartX;
    int   iPartWidth;
    WORD  wGlyphBuf[MAXBUF];
    int   idx[MAXBUF];      // Force widths so all characters show
    BYTE  bFont[MAXBUF];    // Font used for each character
    ABC   abc[MAXBUF];
    int   iTotX;
    int   ildx;             // Overall line dx, adjusts for 'A' width of leading glyph
    int   iSliderX;
    int   iFont;            // 0 = Tahoma, 1 = Mangal, 2 = Latha
    RECT  rcClear;          // Clear each line before displaying it

    // Selection highlighting

    bool  bHighlight;       // Current state of highlighting in the hdc
    int   iFrom;            // Selection range
    int   iTo;
    DWORD dwOldBkColor=0;
    DWORD dwOldTextColor=0;

    // Item analysis

    SCRIPT_ITEM    items[MAXBUF];
    SCRIPT_CONTROL scriptControl;
    SCRIPT_STATE   scriptState;
    INT            iItem;


#define NUMLOGICALFONTS 4

    SCRIPT_CACHE sc[NUMLOGICALFONTS];
    HFONT        hf[NUMLOGICALFONTS];
    HFONT        hfold;
    HRESULT      hr;

    SCRIPT_FONTPROPERTIES sfp;
    BOOL         bMissing;

    icpLineStart = 0;

    hf[0]    = CreateFontA(iLineHeight*7/10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, "Tahoma");
    hf[1]    = CreateFontA(iLineHeight*7/10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, "Mangal");
    hf[2]    = CreateFontA(iLineHeight*7/10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, "Latha");
    hf[3]    = CreateFontA(iLineHeight*7/20, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, "Tahoma"); // for bidi level digits

    iFont    = 0;
    hfold    = (HFONT) SelectObject(hdc, hf[iFont]);
    ildx     = 0;

    memset(sc, 0, sizeof(sc));
    bHighlight = FALSE;

    INT iSliderHeight = g_fOverrideDx ? iLineHeight * 5 / 10 : 0;
    INT iLevelsHeight = g_fShowLevels ? iLineHeight * 8 / 20 : 0;



    // Display line by line

    while (icpLineStart < g_iTextLen) {


        // Clear line before displaying it

        rcClear        = *prc;
        rcClear.top    = *piY;
        rcClear.bottom = *piY + iLineHeight + iSliderHeight + iLevelsHeight;
        FillRect(hdc, &rcClear, (HBRUSH) GetStockObject(WHITE_BRUSH));


        // Find end of line or end of buffer

        icpLineEnd = icpLineStart;
        while (icpLineEnd < g_iTextLen  &&  g_wcBuf[icpLineEnd] != 0x0D) {
            icpLineEnd++;
        }

        if (icpLineEnd - icpLineStart > MAXBUF) {
            iLen = MAXBUF;
        } else {
            iLen = icpLineEnd - icpLineStart;
        }


        // Obtain item analysis

        scriptControl = g_ScriptControl;
        scriptState   = g_ScriptState;
        ScriptItemize(g_wcBuf+icpLineStart, iLen, MAXBUF, &scriptControl, &scriptState, items, NULL);


        // Determine font and glyph index for each codepoint

        if (iFont != 0) {       // Start with Tahoma
            iFont = 0;
            SelectObject(hdc, hf[0]);
        }

        hr = ScriptGetCMap(hdc, &sc[iFont], g_wcBuf+icpLineStart, iLen, 0, wGlyphBuf);
        if (SUCCEEDED(hr))
        {

            memset(bFont, 0, iLen);

            if (hr != S_OK) {

                // Some characters were not in Tahoma

                sfp.cBytes = sizeof(sfp);
                ScriptGetFontProperties(hdc, &sc[iFont], &sfp);

                bMissing = FALSE;
                for (icp=0; icp<iLen; icp++) {
                    if (wGlyphBuf[icp] == sfp.wgDefault) {
                        bFont[icp] = 1;
                        bMissing = TRUE;
                    }
                }


                // Try other fonts

                while (bMissing  &&  iFont < 2) {
                    iFont++;
                    SelectObject(hdc, hf[iFont]);
                    ScriptGetFontProperties(hdc, &sc[iFont], &sfp);
                    bMissing = FALSE;
                    for (icp=0; icp<iLen; icp++) {
                        if (bFont[icp] == iFont) {
                            ScriptGetCMap(hdc, &sc[iFont], g_wcBuf+icpLineStart+icp, 1, 0, wGlyphBuf+icp);
                            if (wGlyphBuf[icp] == sfp.wgDefault) {
                                bFont[icp] = (BYTE)(iFont+1);
                                bMissing = TRUE;
                            }
                        }
                    }
                }

                if (bMissing) {

                    // Remaining missing characters come from font 0
                    for (icp=0; icp<iLen; icp++) {
                        if (bFont[icp] >= NUMLOGICALFONTS) {
                            bFont[icp] = 0;
                        }
                    }
                }
            }



            // Display each glyphs black box next to the previous. Override the
            // default ABC behaviour.

            idx[0] = 0;

            for (icp=0; icp<iLen; icp++) {

                if (iFont != bFont[icp]) {
                    iFont = bFont[icp];
                    SelectObject(hdc, hf[iFont]);
                }

                ScriptGetGlyphABCWidth(hdc, &sc[iFont], wGlyphBuf[icp], &abc[icp]);

                if (g_wcBuf[icpLineStart+icp] == ' ') {

                    // Treat entire space as black

                    abc[icp].abcB += abc[icp].abcA;   abc[icp].abcA = 0;
                    abc[icp].abcB += abc[icp].abcC;   abc[icp].abcC = 0;

                }

                // Glyph black box width is abc.abcB
                // We'd like the glyph to appear 2 pixels to the right of the
                // previous glyph.
                //
                // The default placement of left edge is abc.abcA.
                //
                // Therefore we need to shift this character to the right by
                // 2 - abc.abcA to get it positioned correctly. We do this by
                // updating the advance width for the previous character.

                if (!icp) {
                    ildx = CELLGAP/2 - abc[icp].abcA;
                } else {
                    idx[icp-1] += CELLGAP - abc[icp].abcA;
                }

                // Now adjust the advance width for this character to take us to
                // the right edge of it's black box.

                idx[icp] = abc[icp].abcB + abc[icp].abcA;
            }


            // Support selection range specified in either direction

            if (g_iFrom <= g_iTo) {
                iFrom = g_iFrom - icpLineStart;
                iTo   = g_iTo   - icpLineStart;
            } else {
                iFrom = g_iTo   - icpLineStart;
                iTo   = g_iFrom - icpLineStart;
            }

            // Display glyphs in their appropriate fonts

            icp = 0;
            iPartX = prc->left+ildx;

            while (icp < iLen) {

                if (iFont != bFont[icp]) {
                    iFont = bFont[icp];
                    SelectObject(hdc, hf[iFont]);
                }


                // Set selection highlighting at start

                if (    icp >= iFrom
                    &&  icp < iTo
                    &&  !bHighlight) {

                    // Turn on highlighting

                    dwOldBkColor   = SetBkColor(hdc,   GetSysColor(COLOR_HIGHLIGHT));
                    dwOldTextColor = SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));
                    bHighlight = TRUE;

                } else if (    (    icp < iFrom
                                ||  icp >= iTo)
                           &&  bHighlight) {

                    // Turn off highlighting

                    SetBkColor(hdc, dwOldBkColor);
                    SetTextColor(hdc, dwOldTextColor);
                    bHighlight = FALSE;
                }


                // Find longest run from a single font, and
                // without change of highlighting

                iPartLen   = 0;
                iPartWidth = 0;

                while (    icp+iPartLen < iLen
                       &&  iFont == bFont[icp+iPartLen]
                       &&  bHighlight == (icp+iPartLen >= iFrom && icp+iPartLen < iTo)) {

                    iPartWidth += idx[icp+iPartLen];
                    iPartLen++;
                }


                // Display single font, single highlighting

                ExtTextOutW(hdc,
                    iPartX,
                    *piY+2,
                    ETO_CLIPPED | ETO_GLYPH_INDEX,
                    prc,
                    wGlyphBuf+icp,
                    iPartLen,
                    idx+icp);

                icp    += iPartLen;
                iPartX += iPartWidth;
            }



            // Mark the cells to make the characters stand out clearly

            MoveToEx(hdc, prc->left, *piY, NULL);
            LineTo(hdc,   prc->left, *piY + iLineHeight*3/4);

            iTotX = 0;

            for (icp=0; icp<iLen; icp++){

                iTotX += abc[icp].abcB + CELLGAP;
                idx[icp] = iTotX;   // Record cell position for mouse hit testing

                DottedLine(hdc, prc->left + iTotX, *piY, 0, iLineHeight*3/4);


                // Add slider for OverridedDx control

                if (g_fOverrideDx) {

                    iSliderX = prc->left + (icp==0 ? idx[0]/2 : (idx[icp-1] + idx[icp])/2);

                    // Draw the axis of the slider

                    DottedLine(hdc, iSliderX, *piY + iLineHeight*35/40, 0, iSliderHeight*35/40);

                    // Draw the knob

                    if (g_iWidthBuf[icpLineStart + icp] < iSliderHeight) {

                        MoveToEx(hdc, iSliderX-2, *piY + iLineHeight*35/40 + iSliderHeight*35/40 - g_iWidthBuf[icpLineStart + icp], NULL);
                        LineTo  (hdc, iSliderX+3, *piY + iLineHeight*35/40 + iSliderHeight*35/40 - g_iWidthBuf[icpLineStart + icp]);

                    } else {

                        MoveToEx(hdc, iSliderX-2, *piY + iLineHeight*35/40, NULL);
                        LineTo  (hdc, iSliderX+3, *piY + iLineHeight*35/40);
                    }
                }
            }

            MoveToEx(hdc, prc->left + iTotX, *piY, NULL);
            LineTo(hdc,   prc->left + iTotX, *piY + iLineHeight*30/40);

            MoveToEx(hdc, prc->left, *piY, NULL);
            LineTo(hdc,   prc->left + iTotX, *piY);
            MoveToEx(hdc, prc->left, *piY + iLineHeight*30/40, NULL);
            LineTo(hdc,   prc->left + iTotX, *piY + iLineHeight*30/40);


            if (g_fShowLevels)
            {
                // Display bidi levels for each codepoint

                iItem = 0;
                iFont = 3;
                SelectObject(hdc, hf[3]);

                for (icp=0; icp<iLen; icp++)
                {
                    if (icp == items[iItem+1].iCharPos)
                    {
                        iItem++;

                        // Draw a vertical line to mark the item boundary
                        MoveToEx(hdc, prc->left + idx[icp-1], *piY + iLineHeight*35/40 + iSliderHeight, NULL);
                        LineTo(  hdc, prc->left + idx[icp-1], *piY + iLineHeight*35/40 + iSliderHeight + iLevelsHeight*35/40);
                    }

                    // Establish where horizontally to display the digit

                    char chDigit = char('0' + items[iItem].a.s.uBidiLevel);
                    int digitWidth;
                    GetCharWidth32A(hdc, chDigit, chDigit, &digitWidth);

                    ExtTextOutA(
                        hdc,
                        prc->left + (icp==0 ? idx[0]/2 : (idx[icp-1] + idx[icp])/2) - digitWidth / 2,
                        *piY + iLineHeight*35/40 + iSliderHeight,
                        0,
                        NULL,
                        &chDigit,
                        1,
                        NULL);
                }
            }


            // Check whether mouse clicks in this line are waiting to be processed

            if (    g_fOverrideDx
                &&  g_fMouseUp  &&  g_iMouseUpY > *piY + iLineHeight*33/40  &&  g_iMouseUpY < *piY + iLineHeight*63/40) {

                // Procss change to DX override slider

                icp = 0;
                while (icp<iLen  &&  prc->left + idx[icp] < g_iMouseUpX) {
                    icp++;
                }

                g_iWidthBuf[icpLineStart+icp] = *piY + 60 - g_iMouseUpY; // Adjust this slider
                InvalidateText();   // Force slider to redraw at new position
                g_fMouseDown = FALSE;
                g_fMouseUp   = FALSE;
                g_iFrom = icpLineStart+icp;
                g_iTo   = icpLineStart+icp;


            } else if (g_fMouseDown  &&  g_iMouseDownY > *piY  &&  g_iMouseDownY < *piY+iLineHeight) {

                // Handle text selection

                // Record char pos at left button down
                // Snap mouse hit to closest character boundary

                if (g_iMouseDownX < prc->left + idx[0]/2) {
                    icp = 0;
                } else {
                    icp = 1;
                    while (    icp < iLen
                           &&  g_iMouseDownX > prc->left + (idx[icp-1] + idx[icp]) / 2) {
                        icp++;
                    }
                }
                g_iFrom = icp + icpLineStart;

                if (g_iFrom < icpLineStart) {
                    g_iFrom = icpLineStart;
                }
                if (g_iFrom > icpLineEnd) {
                    g_iFrom = icpLineEnd;
                }
                g_fMouseDown = FALSE;
            }


            if (g_fMouseUp  &&  g_iMouseUpY > *piY  &&  g_iMouseUpY < *piY+iLineHeight) {

                // Complete selection processing

                if (g_iMouseUpX < prc->left + idx[0]/2) {
                    icp = 0;
                } else {
                    icp = 1;
                    while (    icp < iLen
                           &&  g_iMouseUpX > prc->left + (idx[icp-1] + idx[icp]) / 2) {
                        icp++;
                    }
                }
                g_iTo = icp + icpLineStart;

                if (g_iTo < icpLineStart) {
                    g_iTo = icpLineStart;
                }
                if (g_iTo > icpLineEnd) {
                    g_iTo = icpLineEnd;
                }

                // Caret is where mouse was raised

                g_iCurChar = g_iTo;
                g_iCaretSection = CARET_SECTION_LOGICAL;  // Show caret in logical text
                g_fUpdateCaret = TRUE;

                g_fMouseUp = FALSE;     // Signal that the mouse up is processed

            }

            if (    g_fUpdateCaret
                &&  g_iCurChar >= icpLineStart
                &&  g_iCurChar <= icpLineEnd
                &&  g_iCaretSection == CARET_SECTION_LOGICAL) {

                g_fUpdateCaret = FALSE;
                if (g_iCurChar <= icpLineStart) {
                    ResetCaret(prc->left, *piY, iLineHeight);
                } else {
                    ResetCaret(prc->left + idx[g_iCurChar - icpLineStart - 1], *piY, iLineHeight);
                }
            }


            }
        else {
            // ScriptGetCMap failed - therefore this is not a glyphable font.
            // This could indicate
            //      A printer device font
            //      We're running on FE Win95 which cannot handle glyph indices
            //
            // For the sample app, we know we are using a glyphable Truetype font
            // on a screen DC, so it must mean the sample is running on a Far
            // East version of Windows 95.
            // Theoretically we could go to the trouble of calling
            // WideCharToMultiByte and using the 'A' char interfaces to
            // implement DspLogcl.
            // However this is only a sample program - DspPlain and DspFormt
            // work correctly, but there's no advantage in implementing
            // DspLogcl so well.
            // Display an apology.

            ExtTextOutA(hdc, prc->left+2, *piY+2, ETO_CLIPPED, prc, "Sorry, no logical text display on Far East Windows 95.", 54, NULL);
            icpLineEnd = g_iTextLen;  // Hack to stop display of subsequent lines
        }

        *piY += iLineHeight + iSliderHeight + iLevelsHeight;


        // Advance to next line

        if (g_fPresentation) {
            icpLineStart = g_iTextLen;  // Only show one line in presentation mode

        } else {

            if (icpLineEnd < g_iTextLen) {
                icpLineEnd++;
            }
            if (icpLineEnd < g_iTextLen  &&  g_wcBuf[icpLineEnd] == 0x0A) {
                icpLineEnd++;
            }
            icpLineStart = icpLineEnd;
        }
    }

    SelectObject(hdc, hfold);


    if (bHighlight) {

        // Turn off highlighting

        SetBkColor(hdc, dwOldBkColor);
        SetTextColor(hdc, dwOldTextColor);
        bHighlight = FALSE;
    }


    for (iFont=0; iFont<NUMLOGICALFONTS; iFont++) {
        DeleteObject(hf[iFont]);
        if (sc[iFont]) {
            ScriptFreeCache(&sc[iFont]);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\texttest\global.h ===
////    GLOBAL.H - Global variables for CSSAMP
//
//





////    Constants
//
//


#define APPNAMEA   "TextTest"
#define APPTITLEA  "TextTest - GdipPlus Text support (Text+) Tests"
#define APPNAMEW   L"TextTest"
#define APPTITLEW  L"TextTest - GdipPlus Text support (Text+) Tests"

const int MAX_STYLES = 5;      // Better implementation would use dynamic memory
const int MAX_TEXT   = 10000;  // Fixed buffer size in Unicode characters
const int MAX_AUTO_FONTS = 20; // Maximum number of fonts to sequence through
const int MAX_AUTO_HEIGHTS = 20; // Maximum number of heights to sequence through
const int MAX_RANGE_COUNT = 10; // Maximum number of ranges

const int CARET_SECTION_LOGICAL    = 0;
const int CARET_SECTION_PLAINTEXT  = 1;
const int CARET_SECTION_FORMATTED  = 2;


////    RUN - A run of characters with similar attributes
//
//


struct RUN {
    struct RUN       *pNext;
    int               iLen;
    int               iStyle;       // Index to style sheet (global 'g_style').
    SCRIPT_ANALYSIS   analysis;     // Uniscribe analysis
};






////    STYLE - Text attribute
//


struct STYLE {
    WCHAR  faceName[LF_FACESIZE];
    REAL   emSize;
    INT    style;
    //HFONT         hf;       // Handle to font described by lf
    //SCRIPT_CACHE  sc;       // Uniscribe cache associated with this style
};






////    Global variables
//
//


#ifdef GLOBALS_HERE
#define GLOBAL
#define GLOBALINIT(a) = a
#else
#define GLOBAL extern
#define GLOBALINIT(a)
#endif

// Read these from the settings file (command line) - auto-drive for profiling
GLOBAL  char            g_szProfileName[MAX_PATH];              // Profile File name
GLOBAL  BOOL            g_AutoDrive          GLOBALINIT(FALSE); // Automatically run suite and exit
GLOBAL  int             g_iNumIterations     GLOBALINIT(1);     // Number of test iterations to execute
GLOBAL  int             g_iNumRepaints       GLOBALINIT(1);     // Number of re-paints to execute
GLOBAL  int             g_iNumRenders        GLOBALINIT(1);     // Number of API Render calls to execute
GLOBAL  char            g_szSourceTextFile[MAX_PATH];           // Source Text Filename
GLOBAL  BOOL            g_Offscreen          GLOBALINIT(FALSE); // Use offscreen surface
GLOBAL  ARGB            g_TextColor          GLOBALINIT(0xFF000000); // Text color
GLOBAL  ARGB            g_BackColor          GLOBALINIT(0xFFFFFFFF); // Background color

// Automatic cycling data for font height/face
GLOBAL  BOOL            g_AutoFont           GLOBALINIT(FALSE); // Sequence through fonts
GLOBAL  BOOL            g_AutoHeight         GLOBALINIT(FALSE); // Sequence through all font heights
GLOBAL  int             g_iAutoFonts         GLOBALINIT(0);     // Number of fonts to sequence through
GLOBAL  int             g_iAutoHeights       GLOBALINIT(0);     // Number of heights to sequence through
GLOBAL  TCHAR           g_rgszAutoFontFacenames[MAX_AUTO_FONTS][MAX_PATH]; // Array of auto-font facenames
GLOBAL  int             g_rgiAutoHeights[MAX_AUTO_HEIGHTS];     // Array of auto-height sizes

// These correspond to bits in g_DriverOptions (enumeration)
GLOBAL  BOOL            g_CMapLookup         GLOBALINIT(TRUE);
GLOBAL  BOOL            g_Vertical           GLOBALINIT(FALSE);
GLOBAL  BOOL            g_RealizedAdvance    GLOBALINIT(TRUE);
GLOBAL  BOOL            g_CompensateRes      GLOBALINIT(FALSE);

// These correspond to bits in g_formatFlags
GLOBAL  BOOL            g_NoFitBB            GLOBALINIT(FALSE);
GLOBAL  BOOL            g_NoWrap             GLOBALINIT(FALSE);
GLOBAL  BOOL            g_NoClip             GLOBALINIT(FALSE);

// Initial Font controls
GLOBAL  BOOL            g_FontOverride       GLOBALINIT(FALSE); // Over-ride default font settings
GLOBAL  TCHAR           g_szFaceName[MAX_PATH];                 // Font Face name
GLOBAL  int             g_iFontHeight        GLOBALINIT(8);     // Font Height
GLOBAL  BOOL            g_Bold               GLOBALINIT(FALSE); // Bold flag
GLOBAL  BOOL            g_Italic             GLOBALINIT(FALSE); // Italic flag
GLOBAL  BOOL            g_Underline          GLOBALINIT(FALSE); // Underline
GLOBAL  BOOL            g_Strikeout          GLOBALINIT(FALSE); // Strikeout

GLOBAL  HINSTANCE       g_hInstance          GLOBALINIT(NULL);  // The one and only instance
GLOBAL  char            g_szAppDir[MAX_PATH];                   // Application directory
GLOBAL  HWND            g_hSettingsDlg       GLOBALINIT(NULL);  // Settings panel
GLOBAL  HWND            g_hGlyphSettingsDlg  GLOBALINIT(NULL);  // Settings panel
GLOBAL  HWND            g_hDriverSettingsDlg GLOBALINIT(NULL);  // Settings panel
GLOBAL  HWND            g_hTextWnd           GLOBALINIT(NULL);  // Text display/editing panel
GLOBAL  BOOL            g_bUnicodeWnd        GLOBALINIT(FALSE); // If text window is Unicode
GLOBAL  int             g_iSettingsWidth;
GLOBAL  int             g_iSettingsHeight;
GLOBAL  BOOL            g_fShowLevels        GLOBALINIT(FALSE); // Show bidi levels for each codepoint
GLOBAL  int             g_iMinWidth;                            // Main window minimum size
GLOBAL  int             g_iMinHeight;
GLOBAL  BOOL            g_fPresentation      GLOBALINIT(FALSE); // Hide settings, show text very large
GLOBAL  BOOL            g_ShowLogical        GLOBALINIT(FALSE);
GLOBAL  BOOL            g_ShowGDI            GLOBALINIT(FALSE); // Render text using GDI
GLOBAL  BOOL            g_UseDrawText        GLOBALINIT(TRUE); // Render using DrawText

GLOBAL  BOOL            g_fOverrideDx        GLOBALINIT(FALSE); // Provide UI for changing logical widths

GLOBAL  SCRIPT_CONTROL  g_ScriptControl      GLOBALINIT({0});
GLOBAL  SCRIPT_STATE    g_ScriptState        GLOBALINIT({0});
GLOBAL  BOOL            g_fNullState         GLOBALINIT(FALSE);

GLOBAL  DWORD           g_dwSSAflags         GLOBALINIT(SSA_FALLBACK);

GLOBAL  STYLE           g_style[MAX_STYLES];                    // 0 for plaintext, 1-4 for formatted text

GLOBAL  WCHAR           g_wcBuf[MAX_TEXT];
GLOBAL  int             g_iWidthBuf[MAX_TEXT];

GLOBAL  RUN            *g_pFirstFormatRun    GLOBALINIT(NULL);   // Formatting info

GLOBAL  int             g_iTextLen           GLOBALINIT(0);

GLOBAL  int             g_iCaretX            GLOBALINIT(0);      // Caret position in text window
GLOBAL  int             g_iCaretY            GLOBALINIT(0);      // Caret position in text window
GLOBAL  int             g_iCaretHeight       GLOBALINIT(0);      // Caret height in pixels
GLOBAL  int             g_fUpdateCaret       GLOBALINIT(TRUE);   // Caret requires updating

GLOBAL  int             g_iCaretSection      GLOBALINIT(CARET_SECTION_LOGICAL);  // Whether caret is in logical, plain or formatted text
GLOBAL  int             g_iCurChar           GLOBALINIT(0);      // Caret sits on leading edge of buffer[iCurChar]

GLOBAL  int             g_iMouseDownX        GLOBALINIT(0);
GLOBAL  int             g_iMouseDownY        GLOBALINIT(0);
GLOBAL  BOOL            g_fMouseDown         GLOBALINIT(FALSE);
GLOBAL  int             g_iMouseUpX          GLOBALINIT(0);
GLOBAL  int             g_iMouseUpY          GLOBALINIT(0);
GLOBAL  BOOL            g_fMouseUp           GLOBALINIT(FALSE);

GLOBAL  int             g_iFrom              GLOBALINIT(0);      // Highlight start
GLOBAL  int             g_iTo                GLOBALINIT(0);      // Highlight end


GLOBAL  HFONT           g_hfCaption          GLOBALINIT(NULL);   // Caption font
GLOBAL  int             g_iLogPixelsY        GLOBALINIT(0);

GLOBAL  Matrix          g_WorldTransform;
GLOBAL  Matrix          g_FontTransform;
GLOBAL  Matrix          g_DriverTransform;

GLOBAL  SmoothingMode   g_SmoothingMode         GLOBALINIT(SmoothingModeDefault);

// Font families



    // Enumerate available families

GLOBAL  InstalledFontCollection     g_InstalledFontCollection;
GLOBAL  FontFamily     *g_families;
GLOBAL  INT             g_familyCount;


GLOBAL  BOOL            g_ShowFamilies       GLOBALINIT(FALSE);


// Glyphs

GLOBAL  BOOL            g_ShowGlyphs         GLOBALINIT(FALSE);
GLOBAL  int             g_GlyphRows          GLOBALINIT(16);
GLOBAL  int             g_GlyphColumns       GLOBALINIT(16);
GLOBAL  int             g_GlyphFirst         GLOBALINIT(0);
GLOBAL  BOOL            g_CmapLookup         GLOBALINIT(FALSE);
GLOBAL  BOOL            g_HorizontalChart    GLOBALINIT(FALSE);
GLOBAL  BOOL            g_ShowCell           GLOBALINIT(FALSE);
GLOBAL  BOOL            g_VerticalForms      GLOBALINIT(FALSE);


// Driver string

GLOBAL  BOOL            g_ShowDriver         GLOBALINIT(FALSE);
GLOBAL  INT             g_DriverOptions      GLOBALINIT(  DriverStringOptionsCmapLookup
                                                        | DriverStringOptionsRealizedAdvance);
GLOBAL  REAL            g_DriverDx           GLOBALINIT(15.0);
GLOBAL  REAL            g_DriverDy           GLOBALINIT(0.0);
GLOBAL  REAL            g_DriverPixels       GLOBALINIT(13.0);


// DrawString

GLOBAL  BOOL            g_ShowDrawString     GLOBALINIT(FALSE);
GLOBAL  TextRenderingHint g_TextMode         GLOBALINIT(TextRenderingHintSystemDefault);
GLOBAL  UINT            g_GammaValue         GLOBALINIT(4);
GLOBAL  INT             g_formatFlags        GLOBALINIT(0);
GLOBAL  BOOL            g_typographic        GLOBALINIT(FALSE);
GLOBAL  StringAlignment g_align              GLOBALINIT(StringAlignmentNear);
GLOBAL  HotkeyPrefix    g_hotkey             GLOBALINIT(HotkeyPrefixNone);
GLOBAL  StringAlignment g_lineAlign          GLOBALINIT(StringAlignmentNear);
GLOBAL  StringTrimming  g_lineTrim           GLOBALINIT(StringTrimmingNone);
GLOBAL  Unit            g_fontUnit           GLOBALINIT(UnitPoint);
GLOBAL  Brush *         g_textBrush          GLOBALINIT(NULL);
GLOBAL  Brush *         g_textBackBrush      GLOBALINIT(NULL);
GLOBAL  BOOL            g_testMetafile       GLOBALINIT(FALSE);


// Path

GLOBAL  BOOL            g_ShowPath           GLOBALINIT(FALSE);

// Metrics

GLOBAL BOOL             g_ShowMetric         GLOBALINIT(FALSE);

// Performance

GLOBAL BOOL             g_ShowPerformance    GLOBALINIT(FALSE);
GLOBAL INT              g_PerfRepeat         GLOBALINIT(2000);

// Scaling

GLOBAL BOOL             g_ShowScaling        GLOBALINIT(FALSE);

// String format digit substitution
GLOBAL StringDigitSubstitute   g_DigitSubstituteMode   GLOBALINIT(StringDigitSubstituteUser);
GLOBAL LANGID                  g_Language              GLOBALINIT(LANG_NEUTRAL);

GLOBAL INT              g_RangeCount         GLOBALINIT(0);
GLOBAL CharacterRange   g_Ranges[MAX_RANGE_COUNT];

/* obsolete

GLOBAL  BOOL            g_fFillLines         GLOBALINIT(TRUE);
GLOBAL  BOOL            g_fLogicalOrder      GLOBALINIT(FALSE);
GLOBAL  BOOL            g_fNoGlyphIndex      GLOBALINIT(FALSE);

GLOBAL  BOOL            g_fShowWidths        GLOBALINIT(FALSE);
GLOBAL  BOOL            g_fShowStyles        GLOBALINIT(FALSE);

GLOBAL  BOOL            g_fShowPlainText     GLOBALINIT(TRUE);
GLOBAL  BOOL            g_fShowFancyText     GLOBALINIT(FALSE);

*/

////    Function prototypes
//
//

// DspGDI.cpp
void PaintGDI(
    HDC   hdc,
    int  *piY,
    RECT *prc,
    int   iLineHeight);


// DspFamly.cpp

void PaintFamilies(
    HDC   hdc,
    int  *piY,
    RECT *prc,
    int   iLineHeight);

void InitializeLegacyFamilies();


// DspLogcl.cpp

void PaintLogical(
    HDC   hdc,
    int  *piY,
    RECT *prc,
    int   iLineHeight);


// DspDraws.cpp

void PaintDrawString(
    HDC   hdc,
    int  *piY,
    RECT *prc,
    int   iLineHeight);


// DspDriver.cpp

void PaintDrawDriverString(
    HDC   hdc,
    int  *piY,
    RECT *prc,
    int   iLineHeight);


// DspPerf.cpp

void PaintPerformance(
    HDC   hdc,
    int  *piY,
    RECT *prc,
    int   iLineHeight);


// DspPath.cpp

void PaintPath(
    HDC      hdc,
    int     *piY,
    RECT    *prc,
    int      iLineHeight);


// DspGlyph.cpp

void PaintGlyphs(
    HDC   hdc,
    int  *piY,
    RECT *prc,
    int   iLineHeight);


// DspMetric.cpp

void PaintMetrics(
    HDC   hdc,
    int  *piY,
    RECT *prc,
    int   iLineHeight);


// DspScaling.cpp

void PaintScaling(
    HDC   hdc,
    int  *piY,
    RECT *prc,
    int   iLineHeight);


// Settings.cpp
INT_PTR CALLBACK SettingsDlgProc(
        HWND    hDlg,
        UINT    uMsg,
        WPARAM  wParam,
        LPARAM  lParam);

INT_PTR CALLBACK GlyphSettingsDlgProc(
        HWND    hDlg,
        UINT    uMsg,
        WPARAM  wParam,
        LPARAM  lParam);

INT_PTR CALLBACK DriverSettingsDlgProc(
        HWND    hDlg,
        UINT    uMsg,
        WPARAM  wParam,
        LPARAM  lParam);

void InsertText(HWND hDlg, char *textId);

// ReadSettings.cpp
void ReadProfileInfo(char *szProfileName);

// Text.cpp

void InitText(INT id);

BOOL TextInsert(
    int   iPos,
    PWCH  pwc,
    int   iLen);

BOOL TextDelete(
    int iPos,
    int iLen);



// TextWnd.cpp

HWND CreateTextWindow();

void ResetCaret(int iX, int iY, int iHeight);

LRESULT CALLBACK TextWndProc(
        HWND    hWnd,
        UINT    uMsg,
        WPARAM  wParam,
        LPARAM  lParam);

void InvalidateText();

void PrintPage();

// Edit.cpp

BOOL EditChar(WCHAR wc);
BOOL EditKeyDown(WCHAR wc);
void EditFreeCaches();
void EditInsertUnicode();


// Style.cpp

void SetStyle(
    int     iStyle,
    int     iHeight,
    int     iWeight,
    int     iItalic,
    int     iUnderline,
    int     iStrikeout,
    TCHAR   *pcFaceName);

void InitStyles();

void FreeStyles();

void SetLogFont(
    PLOGFONTA   plf,
    int         iHeight,
    int         iWeight,
    int         iItalic,
    int         iUnderline,
    char       *pcFaceName);

void StyleDeleteRange(
    int     iDelPos,
    int     iDelLen);

void StyleExtendRange(
    int     iExtPos,
    int     iExtLen);

void StyleSetRange(
    int    iSetStyle,
    int    iSetPos,
    int    iSetLen);

BOOL StyleCheckRange();



// Debugging support


#define TRACEMSG(a)   {DG.psFile=__FILE__; DG.iLine=__LINE__; DebugMsg a;}
#define ASSERT(a)     {if (!(a)) TRACEMSG(("Assertion failure: "#a));}
#define ASSERTS(a,b)  {if (!(a)) TRACEMSG(("Assertion failure: "#a" - "#b));}
#define ASSERTHR(a,b) {if (!SUCCEEDED(a)) {DG.psFile=__FILE__; \
                       DG.iLine=__LINE__; DG.hrLastError=a; DebugHr b;}}



///     Debug variables
//


struct DebugGlobals {
    char   *psFile;
    int     iLine;
    HRESULT hrLastError;        // Last hresult from GDI
    CHAR    sLastError[100];    // Last error string
};




///     Debug function prototypes
//


extern "C" void WINAPIV DebugMsg(char *fmt, ...);
extern "C" void WINAPIV DebugHr(char *fmt, ...);

GLOBAL DebugGlobals DG   GLOBALINIT({0});
GLOBAL UINT debug        GLOBALINIT(0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\texttest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by TextTest.rc
//
#define IDD_FORMATTEDTEXT               105
#define IDD_ITEMIZATION                 106
#define ID_INITIAL_TEXT                 110
#define IDD_OBSOLETE                    112
#define ID_MULTILINGUAL_TEXT            120
#define ID_METRICS_TEXT                 130
#define IDC_HORIZ                       1000
#define IDC_VERT                        1001
#define IDC_TRIMMING                    1001
#define IDC_LTR                         1002
#define IDC_RTL                         1003
#define IDC_NEAR                        1004
#define IDC_CENTER                      1005
#define IDC_JUSTIFY                     1006
#define IDC_FAR                         1007
#define IDC_CONTROL_CHARS               1008
#define IDC_NO_GLYPH_INDEX              1009
#define IDC_HIGHLIGHT_FROM              1010
#define IDC_HIGHLIGHT_TO                1011
#define IDC_CODEPOINT                   1012
#define IDC_INSERT_CODEPOINT            1013
#define IDC_LOGICAL_ORDER               1014
#define IDC_LOGICAL                     1018
#define IDC_LOGICAL_WIDTH               1019
#define IDC_GLYPHCELLMETRICS            1019
#define IDC_GLYPHCMAPLOOKUP             1019
#define IDC_LOGICAL_STYLES              1020
#define IDC_GLYPHDESIGNADVANCE          1020
#define IDC_GLYPHVERTICALFORMS          1020
#define IDC_PLAINTEXT                   1021
#define IDC_GLYPHHINTEDADVANCE          1021
#define IDC_GLYPHHORIZONTALCHART        1021
#define IDC_SHOWGLYPHS                  1022
#define IDC_SHOWDRAWSTRING              1023
#define IDC_PLAINTEXT_FONT              1024
#define IDC_PLAINTEXT_SIZE              1025
#define IDC_PLAINTEXT_BOLD              1026
#define IDC_PLAINTEXT_ITALIC            1027
#define IDC_PLAINTEXT_UNDERLINE         1028
#define IDC_PLAINTEXT_CLIP              1029
#define IDC_SHOWFAMILIES                1029
#define IDC_PLAINTEXT_FIT               1030
#define IDC_GLYPHROWS                   1030
#define IDC_PLAINTEXT_STRIKEOUT         1030
#define IDC_PLAINTEXT_DX                1031
#define IDC_GLYPHCOLUMNS                1031
#define IDC_PLAINTEXT_TAB               1032
#define IDC_GLYPHINDEX                  1032
#define IDC_DRIVERORIGINALPIXELS        1032
#define IDC_PLAINTEXT_FALLBACK          1033
#define IDC_SHOWPATH                    1033
#define IDC_PLAINTEXT_LINK              1034
#define IDC_SHOWMETRIC                  1034
#define IDC_PLAINTEXT_HOTKEY            1035
#define IDC_SHOWDRIVER                  1035
#define IDC_PLAINTEXT_PASSWORD          1036
#define IDC_FORMATTED                   1037
#define IDC_FORMAT1                     1038
#define IDC_CONTROL_CONTEXT             1039
#define IDC_LANGUAGE                    1040
#define IDC_LEGACY_BIDI                 1041
#define IDC_OVERRIDE                    1042
#define IDC_DIGIT_SUBSTITUTE            1043
#define IDC_LINEFILL                    1044
#define IDC_ARANUMCONTEXT               1045
#define IDC_APPLYDIGITSUBST             1046
#define IDC_PRESENTATION                1047
#define IDC_SHOWLEVELS                  1048
#define IDC_WORLDTRANSFORM              1052
#define IDC_GLYPHHORIZONTAL             1053
#define IDC_GLYPHVERTICAL               1054
#define IDC_FONTTRANSFORM               1054
#define IDC_GDIGLYPHOUTPUT              1055
#define IDC_UNISCRIBE                   1056
#define IDC_PRINT                       1057
#define IDC_ALIGN                       1058
#define IDC_RENDERER                    1059
#define IDC_NOLINELIMIT                 1059
#define IDC_FONTUNIT                    1060
#define IDC_ALIGNMENT                   1061
#define IDC_FANCY_FONT1                 1062
#define IDC_GLYPHSHOWCELL               1062
#define IDC_FANCY_SIZE1                 1063
#define IDC_FANCY_BOLD1                 1064
#define IDC_FANCY_ITALIC1               1065
#define IDC_RENDER                      1065
#define IDC_FANCY_UNDERLINE1            1066
#define IDC_GDI                         1066
#define IDC_FANCY_FONT2                 1067
#define IDC_FONTSIZE                    1067
#define IDC_FANCY_SIZE2                 1068
#define IDC_FANCY_BOLD2                 1069
#define IDC_FANCY_ITALIC2               1070
#define IDC_FANCY_UNDERLINE2            1071
#define IDC_FANCY_FONT3                 1072
#define IDC_HOTKEY                      1072
#define IDC_FANCY_SIZE3                 1073
#define IDC_LINEALIGN                   1073
#define IDC_FANCY_BOLD3                 1074
#define IDC_DIR                         1074
#define IDC_FANCY_ITALIC3               1075
#define IDC_DRIVERCMAP                  1075
#define IDC_WRAP                        1075
#define IDC_FANCY_UNDERLINE3            1076
#define IDC_DRIVERVERTICAL              1076
#define IDC_HINTED                      1076
#define IDC_NOMINAL                     1076
#define IDC_FANCY_FONT4                 1077
#define IDC_DRIVERREALIZEDADVANCE       1077
#define IDC_METAFILE                    1077
#define IDC_FANCY_SIZE4                 1078
#define IDC_CHECK4                      1078
#define IDC_LIMITSUBPIXEL               1078
#define IDC_CLIP                        1078
#define IDC_FANCY_BOLD4                 1079
#define IDC_DRIVERDX                    1079
#define IDC_FANCY_ITALIC4               1080
#define IDC_DRIVERDY                    1080
#define IDC_FANCY_UNDERLINE4            1081
#define IDC_DRIVERTRANSFORM             1081
#define IDC_FORMAT2                     1087
#define IDC_FORMAT3                     1090
#define IDC_FORMAT4                     1091
#define IDC_TEXTMODE                    1092
#define IDC_GAMMAVALUE                  1093
#define IDC_BRUSHTYPE                   1094
#define IDC_BACKBRUSHTYPE               1094
#define IDC_FOREBRUSHTYPE               1096
#define IDC_CHECK1                      1097
#define IDC_PERFORMANCE                 1097
#define IDC_SHOWSCALING                 1098
#define IDC_ALIGNNEAR                   1099
#define IDC_ALIGNCENTER                 1100
#define IDC_ALIGNFAR                    1101
#define IDC_LINEALIGNNEAR               1102
#define IDC_LINEALIGNCENTER             1103
#define IDC_LINEALIGNFAR                1104
#define IDC_HOTKEYNONE                  1105
#define IDC_HOTKEYSHOW                  1106
#define IDC_HOTKEYHIDE                  1107
#define IDC_NOFITBB                     1110
#define IDC_NUMCTXAR                    1111
#define IDC_NOKASHIDA                   1112
#define IDC_DISPLAYFMT                  1113
#define IDC_NOKERNING                   1114
#define IDC_LEGACYBIDI                  1115
#define IDC_NOCHANGES                   1116
#define IDC_NOFALLBACK                  1117
#define IDC_MEASPACE                    1118
#define IDC_NOWRAP                      1119
#define IDC_LINELIMIT                   1120
#define IDC_NOCLIP                      1121
#define IDC_NOGDI                       1122
#define IDC_FULLIMAGER                  1123
#define IDC_TRIMMINGCHAR                1124
#define IDC_TRIMMINGWORD                1125
#define IDC_TRIMMINGELPSCH              1126
#define IDC_TRIMMINGELPSWD              1127
#define IDC_TRIMMINGELPSURL             1128
#define IDC_DEFAULTFORMAT               1129
#define IDC_TRIMMINGNONE                1130
#define IDC_NOLIGATURE                  1131
#define IDC_TYPOGRAPHICFORMAT           1132
#define IDC_CLR_FOR                     1133
#define IDC_BUTTON2                     1134
#define IDC_CLR_BAC                     1134
#define IDC_SHOWGDI                     1135
#define IDM_EXIT                        40001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        113
#define _APS_NEXT_COMMAND_VALUE         40002
#define _APS_NEXT_CONTROL_VALUE         1135
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\texttest\settings.cpp ===
////    SETTINGS.CPP - Handles settings dialog
//
//


#include "precomp.hxx"
#include "global.h"
#include <stdio.h>
#include <tchar.h>



////    HexToInt - convert hex digit string to int value
//
//      Ignores 'x' in the string so accepts input like '0x0100'.


int HexToInt(char szHex[]) {

    int i;
    int h;
    //int d;

    i = 0;
    h = 0;
    //d = 0;

    while (szHex[i]  &&  szHex[i] != ' ') {

        if (szHex[i] >= '0'  &&  szHex[i] <= '9') {

            h = h*16 + szHex[i] - '0';
            //d = d*10 + szHex[i] - '0';

        } else if (szHex[i] >= 'a'  &&  szHex[i] <= 'f') {

            h = h*16 + 10 + szHex[i] - 'a';

        } else if (szHex[i] >= 'A'  &&  szHex[i] <= 'F') {

            h = h*16 + 10 + szHex[i] - 'A';

        } else if (szHex[i] != ' '  &&  szHex[i] != ','  &&  szHex[i] != 'x'  &&  szHex[i] != 'X') {

            return -1;
        }

        i++;
    }


    return h;
}

VOID GetTextForeGroundBrush(INT_PTR iBrushType)
{

    if (g_textBrush)
    {
        delete g_textBrush;
        g_textBrush = NULL;
    }

    switch(iBrushType)
    {
    case 0: // Solid color
        {
            Color      blackColor(g_TextColor);
            SolidBrush * blackBrush = new SolidBrush(blackColor);
            g_textBrush = (Brush *) blackBrush;
        }

        break;

    #ifndef USE_NEW_APIS3
    // rectangle, triangle and radiant gradient brushes are not available in v1.
        case 1: // RectGradient
            {
                RectF brushRect(0, 0, 32, 32);

                Color colors[5] = {
                        Color(255, 255, 255, 255),
                        Color(255, 255, 0, 0),
                        Color(255, 0, 255, 0),
                        Color(255, 0, 0, 255),
                        Color(255, 0, 0, 0)
                };

                RectangleGradientBrush * rectGrad = new RectangleGradientBrush(brushRect, (Color*) &colors, WrapModeTile);

                g_textBrush = (Brush *) rectGrad;

            }
            break;


        case 2: // RadialGradient
            {
                RectF brushRect;

                Color centerColor(255, 255, 255, 255);
                Color boundaryColor(255, 0, 0, 0);
                brushRect.X = 0;
                brushRect.Y = 0;
                brushRect.Width = 60;
                brushRect.Height = 32;
                PointF center;
                center.X = brushRect.X + brushRect.Width/2;
                center.Y = brushRect.Y + brushRect.Height/2;
                RadialGradientBrush * radGrad = new RadialGradientBrush(brushRect, centerColor,
                                        boundaryColor, WrapModeTile);

                g_textBrush = (Brush *) radGrad;
            }
            break;
        case 3: // TriangleGradient
            {
                PointF points[7];
                points[0].X = 50;
                points[0].Y = 10;
                points[1].X = 200;
                points[1].Y = 20;
                points[2].X = 100;
                points[2].Y = 100;
                points[3].X = 30;
                points[3].Y = 120;

                Color colors[5] = {
                    Color(255, 255, 255, 0),
                    Color(255, 255, 0, 0),
                    Color(255, 0, 255, 0),
                    Color(255, 0, 0, 255),
                    Color(255, 0, 0, 0)
                };

                TriangleGradientBrush * triGrad = new TriangleGradientBrush(points, (Color*) &colors, WrapModeTileFlipXY);

                g_textBrush = (Brush *) triGrad;
            }
            break;
#endif

    case 4: // LineGradient
        {
            RectF lineRect(120, -20, 200, 60);
            Color color1(200, 255, 255, 0);
            Color color2(200, 0, 0, 255);

            LinearGradientBrush *lineGrad = new LinearGradientBrush(
                lineRect,
                color1,
                color2,
                LinearGradientModeForwardDiagonal
            );
            g_textBrush = (Brush *) lineGrad;
        }
    break;
    default: // Solid Color
        {
            Color      blackColor(g_TextColor);
            SolidBrush * blackBrush = new SolidBrush(blackColor);
            g_textBrush = (Brush *) blackBrush;
        }
    break;
    }
}

VOID GetTextRenderingMode(INT_PTR iTextMode)
{
    switch (iTextMode) {
    case 0: g_TextMode = TextRenderingHintSystemDefault;            break;
    case 1: g_TextMode = TextRenderingHintSingleBitPerPixelGridFit; break;
    case 2: g_TextMode = TextRenderingHintSingleBitPerPixel;        break;
    case 3: g_TextMode = TextRenderingHintAntiAliasGridFit;         break;
    case 4: g_TextMode = TextRenderingHintAntiAlias;                break;
    case 5: g_TextMode = TextRenderingHintClearTypeGridFit;         break;

    default:g_TextMode = TextRenderingHintSystemDefault;            break;
    }
}

VOID GetTextBackGroundBrush(INT_PTR iBrushType)
{

    if (g_textBackBrush)
    {
        delete g_textBackBrush;
        g_textBackBrush = NULL;
    }

    switch(iBrushType)
    {
    case 0: // Solid color
        {
            Color      blackColor(g_BackColor);
            SolidBrush * blackBrush = new SolidBrush(blackColor);
            g_textBackBrush = (Brush *) blackBrush;
        }

        break;

    #ifndef USE_NEW_APIS3
    // rectangle, triangle and radiant gradient brushes are not available in v1.
    case 1: // RectGradient
        {
            RectF brushRect(0, 0, 32, 32);

            Color colors[5] = {
                    Color(255, 255, 255, 255),
                    Color(255, 255, 0, 0),
                    Color(255, 0, 255, 0),
                    Color(255, 0, 0, 255),
                    Color(255, 0, 0, 0)
            };

            RectangleGradientBrush * rectGrad = new RectangleGradientBrush(brushRect, (Color*) &colors, WrapModeTile);

            g_textBackBrush = (Brush *) rectGrad;

        }
        break;
    case 2: // RadialGradient
        {
            RectF brushRect;

            Color centerColor(255, 255, 255, 255);
            Color boundaryColor(255, 0, 0, 0);
            brushRect.X = 0;
            brushRect.Y = 0;
            brushRect.Width = 60;
            brushRect.Height = 32;
            PointF center;
            center.X = brushRect.X + brushRect.Width/2;
            center.Y = brushRect.Y + brushRect.Height/2;
            RadialGradientBrush * radGrad = new RadialGradientBrush(brushRect, centerColor,
                                    boundaryColor, WrapModeTile);

            g_textBackBrush = (Brush *) radGrad;
        }
        break;
    case 3: // TriangleGradient
        {
            PointF points[7];
            points[0].X = 50;
            points[0].Y = 10;
            points[1].X = 200;
            points[1].Y = 20;
            points[2].X = 100;
            points[2].Y = 100;
            points[3].X = 30;
            points[3].Y = 120;

            Color colors[5] = {
                Color(255, 255, 255, 0),
                Color(255, 255, 0, 0),
                Color(255, 0, 255, 0),
                Color(255, 0, 0, 255),
                Color(255, 0, 0, 0)
            };

            TriangleGradientBrush * triGrad = new TriangleGradientBrush(points, (Color*) &colors, WrapModeTileFlipXY);

            g_textBackBrush = (Brush *) triGrad;
        }
        break;
#endif
    case 4: // LineGradient
        {
            RectF lineRect(120, -20, 200, 60);
            Color color1(200, 255, 255, 0);
            Color color2(200, 0, 0, 255);

            LinearGradientBrush *lineGrad = new LinearGradientBrush(
                lineRect,
                color1,
                color2,
                LinearGradientModeForwardDiagonal
            );
            g_textBackBrush = (Brush *) lineGrad;
        }
    break;
    default: // Solid Color
        {
            Color      blackColor(g_BackColor);
            SolidBrush * blackBrush = new SolidBrush(blackColor);
            g_textBackBrush = (Brush *) blackBrush;
        }
    break;
    }
}

VOID GetDigitSubstituteMode (HWND hDlg, INT_PTR iDigitSubstituteType)
{
    g_DigitSubstituteMode = (StringDigitSubstitute)iDigitSubstituteType;

    if(g_DigitSubstituteMode == StringDigitSubstituteUser || g_DigitSubstituteMode == StringDigitSubstituteNone)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_LANGUAGE) , FALSE);
    }
    else
    {
        EnableWindow(GetDlgItem(hDlg, IDC_LANGUAGE) , TRUE);
    }
}

BOOL ChangeFont(
    HWND hDlg,
    int iStyle,
    int idFont,
    int idSize,
    int idBold,
    int idItalic,
    int idUnderline,
    int idStrikeout,
    int iCmd,
    int iNotify
)
{
    int   iHeight;
    char sFaceSize[100];
    TCHAR sFaceName[100];
    WPARAM   i;


    // Get size

    if (    iCmd    == idSize
        &&  iNotify == CBN_SELCHANGE)
    {
        i = SendDlgItemMessage(hDlg, idSize, CB_GETCURSEL, 0, 0);
        if (SendDlgItemMessageA(hDlg, idSize, CB_GETLBTEXT, i, (LPARAM)sFaceSize) == CB_ERR) {
            return FALSE;
        }
    }
    else
    {
        if (SendDlgItemMessageA(hDlg, idSize, WM_GETTEXT, sizeof(sFaceSize), (LPARAM)sFaceSize) == CB_ERR)
        {
            return FALSE;
        }
    }

    int pos = atoi(sFaceSize);

    if (iCmd == IDC_PLAINTEXT_SIZE)
    {
        SendDlgItemMessage(hDlg, IDC_FONTSIZE, TBM_SETPOS,   TRUE, pos);
    }

    iHeight = pos;  //  Was for CSSAMP: MulDiv(pos, g_iLogPixelsY, 72);



    // Get facename

    i = SendDlgItemMessage(hDlg, idFont, CB_GETCURSEL, 0, 0);
    if (SendDlgItemMessage(hDlg, idFont, CB_GETLBTEXT, i, (LPARAM)sFaceName) == CB_ERR) {
        return FALSE;
    }


    SetStyle(
        iStyle,
        iHeight,
        IsDlgButtonChecked(hDlg, idBold)      == BST_CHECKED ? 700 : 400,
        IsDlgButtonChecked(hDlg, idItalic)    == BST_CHECKED,
        IsDlgButtonChecked(hDlg, idUnderline) == BST_CHECKED,
        IsDlgButtonChecked(hDlg, idStrikeout) == BST_CHECKED,
        sFaceName);



    InvalidateText();
    return TRUE;
}




// SplitTransform here temporarily for testing purposes



void SplitTransform(
    const Matrix    &matrix,
    PointF          &scale,
    REAL            &rotate,
    REAL            &shear,
    PointF          &translate)
{

    REAL m[6];
    matrix.GetElements(m);

    // m11 = m[0]    m12 = m[1]
    // m21 = m[2]    m22 = m[3]
    //  dx = m[4]     dy = m[5]


    // Extract translation

    translate = PointF(m[4],m[5]);


    //         2           2
    // Use  Sin theta + cos theta = 1 to obtain (absolute value) of
    // the X scale factor. Because we're returning the shear as an X
    // shear, it's a factor of y, so this formula is correct regardless of shear.


    REAL m11Sq = m[0]*m[0];
    REAL m12Sq = m[1]*m[1];

    scale.X = REAL(sqrt(m11Sq + m12Sq));

    // Always treat X scale factor as positive: handle originally negative
    // X scale factors as rotation by 180 degrees and invert Y scale factor.


    if (m[1] >= 0 && m[0] > 0)
    {
        rotate = REAL(atan(m[1]/m[0]));                     // 0-90
    }
    else if (m[0] < 0)
    {
        rotate = REAL(atan(m[1]/m[0]) + 3.14159265358979);  // 90-270
    }
    else if (m[1] < 0 && m[0] > 0)
    {
        rotate = REAL(atan(m[1]/m[0]) + 2*3.14159265358979);// 270-360
    }
    else
    {
        // m[0] == 0

        if (m[1] > 0)
        {
            rotate = REAL(3.14159265358979);                // 90
        }
        else
        {
            rotate = REAL(3*3.14159265358979/2);            // 270
        }
    }


    // y scale factor in terms of x scale factor

    scale.Y = scale.X * (m[0]*m[3] - m[1]*m[2]) / (m11Sq + m12Sq);


    // Shear

    shear = (m[1]*m[3] + m[0]*m[2]) / (m11Sq + m[1]);
}








class TransformControl {
public:
    void init(INT x, INT y, INT width, INT height, INT cellHeight) {
        rect.X      = x;
        rect.Y      = y;
        rect.Width  = width;
        rect.Height = height;
        origin.X    = x + width/2;
        origin.Y    = y + height/2;
        fontCellHeight = cellHeight;
    }
    BOOL inControl(INT x, INT y, Point *point) {
        if (    x >= rect.X
            &&  y >= rect.Y
            &&  x < rect.X + rect.Width
            &&  y < rect.Y + rect.Height + fontCellHeight) {
            if (point)
            {
                // Set point to tenths of the controls 'radius'
                point->X = (x - origin.X) * 200 / rect.Width;
                point->Y = (y - origin.Y) * 200 / rect.Height;
            }
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    void paint(HDC hdc) {
        // Add vertical and horizontal lines

        HPEN hOldPen = (HPEN) SelectObject(hdc, CreatePen(PS_SOLID, 0, COLORREF(0x00C0C0C0)));

        MoveToEx(hdc, rect.X,            origin.Y, NULL);
        LineTo  (hdc, rect.X+rect.Width, origin.Y);

        MoveToEx(hdc, origin.X, rect.Y,            NULL);
        LineTo  (hdc, origin.X, rect.Y+rect.Height);

        DeleteObject(SelectObject(hdc, hOldPen));
    }
    Rect  rect;
    Point origin;
    INT   fontCellHeight;
    enum {
        SampleRectSize = 40
    };
};

class AngleTransformControl : TransformControl {
public:
    void init(INT x, INT y, INT width, INT height, INT cellHeight) {
        TransformControl::init(x, y, width, height, cellHeight);
        angle = 0;
    }
    void mouse(INT x, INT y) {
        Point vector;
        if (inControl(x, y, &vector)) {
            if (vector.Y > 100)
            {
                // Reset
                angle = 0;
            }
            else if (vector.X == 0)  // Convert mouse hit to angle
            {
                // Special case: straight up or straight down
                if (vector.Y < 0)
                {
                    angle = REAL(3.14159265358979*3/2);
                }
                else if (vector.Y == 0)
                {
                    angle = 0;
                }
                else
                {
                    angle = REAL(3.14159265358979/2);
                }
            }
            else
            {
                angle = REAL(atan(REAL(vector.Y)/REAL(vector.X)));
                if (vector.X < 0)
                {
                    angle += REAL(3.14159265358979);
                }
            }
        }
    }
    void paint(HDC hdc) {
        Ellipse(hdc, rect.X, rect.Y, rect.X+rect.Width, rect.Y+rect.Height);
        TransformControl::paint(hdc);
        MoveToEx(hdc, origin.X, origin.Y, NULL);
        Point vector;

        vector.X = INT(cos(angle)*80+0.4999);
        vector.Y = INT(sin(angle)*80+0.4999);
        LineTo(hdc, origin.X+vector.X*rect.Width/200, origin.Y+vector.Y*rect.Height/200);
        SetTextAlign(hdc, TA_CENTER);
        char strKey[50];
        INT strLen = sprintf(strKey, "Rotate %.1f", angle * 180 / 3.14159265358979);
        RECT textRect = {rect.X, rect.Y+rect.Height, rect.X+rect.Width, rect.Y+rect.Height+fontCellHeight};
        ExtTextOutA(hdc, origin.X, rect.Y+rect.Height, ETO_OPAQUE, &textRect, strKey, strLen, NULL);
    }
    REAL getAngle() {
        return REAL(angle * 180 / 3.14159265358979);
    }
    REAL angle;
};

class VectorTransformControl : public TransformControl {
public:
    void init(INT x, INT y, INT width, INT height, INT cellHeight) {
        TransformControl::init(x, y, width, height, cellHeight);
    }
    void paint(HDC hdc) {
        Rectangle(hdc, rect.X, rect.Y, rect.X+rect.Width, rect.Y+rect.Height);
        TransformControl::paint(hdc);
    }
    Point vector;
};

class ScaleTransformControl : public VectorTransformControl {
public:
    void init(INT x, INT y, INT width, INT height, INT cellHeight) {
        TransformControl::init(x, y, width, height, cellHeight);
        vector.X = SampleRectSize;
        vector.Y = SampleRectSize;
    }
    void mouse(INT x, INT y) {
        if (inControl(x, y, &vector)) {
            if (vector.Y > 100)
            {   // Reset
                vector.X = SampleRectSize;
                vector.Y = SampleRectSize;
            }
        }
    }
    void paint(HDC hdc) {
        VectorTransformControl::paint(hdc);
        MoveToEx(hdc, origin.X, origin.Y, NULL);
        LineTo(hdc, origin.X+vector.X*rect.Width/200, origin.Y);
        LineTo(hdc, origin.X+vector.X*rect.Width/200, origin.Y+vector.Y*rect.Height/200);
        LineTo(hdc, origin.X,                         origin.Y+vector.Y*rect.Height/200);
        LineTo(hdc, origin.X, origin.Y);
        SetTextAlign(hdc, TA_CENTER);
        char strKey[50];
        INT strLen = sprintf(strKey, "Scale %.1f,%.1f", REAL(vector.X)/REAL(SampleRectSize), REAL(vector.Y)/REAL(SampleRectSize));
        RECT textRect = {rect.X, rect.Y+rect.Height, rect.X+rect.Width, rect.Y+rect.Height+fontCellHeight};
        ExtTextOutA(hdc, origin.X, rect.Y+rect.Height, ETO_OPAQUE, &textRect, strKey, strLen, NULL);
    }
    REAL getScaleX() {
        REAL  ScaleX = REAL(vector.X)/REAL(SampleRectSize);
        // snap values close to 1.0 and -1.0 to make it easier to test mirror image
        if ((ScaleX > 0.9) && (ScaleX < 1.1))
            ScaleX = 1.0;
        if ((ScaleX < -0.9) && (ScaleX > -1.1))
            ScaleX = -1.0;
        return ScaleX;
    }
    REAL getScaleY() {
        REAL  ScaleY = REAL(vector.Y)/REAL(SampleRectSize);
        // snap values close to 1.0 and -1.0 to make it easier to test mirror image
        if ((ScaleY > 0.9) && (ScaleY < 1.1))
            ScaleY = 1.0;
        if ((ScaleY < -0.9) && (ScaleY > -1.1))
            ScaleY = -1.0;
        return ScaleY;
    }
};

class ShearTransformControl : public VectorTransformControl {
public:
    void init(INT x, INT y, INT width, INT height, INT cellHeight) {
        TransformControl::init(x, y, width, height, cellHeight);
        vector.X = 0;
        vector.Y = 0;
    }
    void mouse(INT x, INT y) {
        if (inControl(x, y, &vector)) {
            if (vector.Y > 100)
            {   // Reset
                vector.X = 0;
                vector.Y = 0;
            }
            else
            {   // Offset so user appears to be dragging 1,1 coordinate
                vector.X -= SampleRectSize;
                vector.Y -= SampleRectSize;
            }
        }
    }
    void paint(HDC hdc) {
        VectorTransformControl::paint(hdc);
        INT vx = vector.X*rect.Width/200;
        INT vy = vector.Y*rect.Height/200;

        MoveToEx(hdc, origin.X,                                origin.Y, NULL);
        LineTo(hdc, origin.X+vx,                               origin.Y+   rect.Height*SampleRectSize/200);
        LineTo(hdc, origin.X+vx+rect.Width*SampleRectSize/200, origin.Y+vy+rect.Height*SampleRectSize/200);
        LineTo(hdc, origin.X+   rect.Width*SampleRectSize/200, origin.Y+vy);
        LineTo(hdc, origin.X,                                  origin.Y);

        SetTextAlign(hdc, TA_CENTER);
        char strKey[50];
        INT strLen = sprintf(strKey, "Shear %.1f,%.1f", REAL(vector.X)/REAL(SampleRectSize), REAL(vector.Y)/REAL(SampleRectSize));
        RECT textRect = {rect.X, rect.Y+rect.Height, rect.X+rect.Width, rect.Y+rect.Height+fontCellHeight};
        ExtTextOutA(hdc, origin.X, rect.Y+rect.Height, ETO_OPAQUE, &textRect, strKey, strLen, NULL);
    }
    REAL getShearX() {
        return REAL(vector.X)/REAL(SampleRectSize);
    }
    REAL getShearY() {
        return REAL(vector.Y)/REAL(SampleRectSize);
    }
};

class TranslateTransformControl : public VectorTransformControl {
public:
    void init(INT x, INT y, INT width, INT height, INT cellHeight) {
        TransformControl::init(x, y, width, height, cellHeight);
        vector.X = 0;
        vector.Y = 0;
    }
    void mouse(INT x, INT y) {
        if (inControl(x, y, &vector)) {
            if (vector.Y > 100)
            {   // Reset
                vector.X = 0;
                vector.Y = 0;
            }
            else
            {   // Offset so user appears to be dragging 1,1 coordinate
                vector.X -= SampleRectSize;
                vector.Y -= SampleRectSize;
            }
        }
    }
    void paint(HDC hdc) {
        VectorTransformControl::paint(hdc);
        MoveToEx(hdc, origin.X+vector.X*rect.Width/200,                  origin.Y+vector.Y*rect.Height/200, NULL);
        LineTo  (hdc, origin.X+(vector.X+SampleRectSize)*rect.Width/200, origin.Y+vector.Y*rect.Height/200);
        LineTo  (hdc, origin.X+(vector.X+SampleRectSize)*rect.Width/200, origin.Y+(vector.Y+SampleRectSize)*rect.Height/200);
        LineTo  (hdc, origin.X+vector.X*rect.Width/200,                  origin.Y+(vector.Y+SampleRectSize)*rect.Height/200);
        LineTo  (hdc, origin.X+vector.X*rect.Width/200,                  origin.Y+vector.Y*rect.Height/200);
        SetTextAlign(hdc, TA_CENTER);
        char strKey[50];
        INT strLen = sprintf(strKey, "Trnslt %.1f,%.1f", REAL(vector.X)/REAL(SampleRectSize), REAL(vector.Y)/REAL(SampleRectSize));
        RECT textRect = {rect.X, rect.Y+rect.Height, rect.X+rect.Width, rect.Y+rect.Height+fontCellHeight};
        ExtTextOutA(hdc, origin.X, rect.Y+rect.Height, ETO_OPAQUE, &textRect, strKey, strLen, NULL);
    }
    REAL getTranslateX() {
        return REAL(vector.X)/REAL(SampleRectSize);
    }
    REAL getTranslateY() {
        return REAL(vector.Y)/REAL(SampleRectSize);
    }
};



class WorldTransformSetting {
public:
    void init           (HWND hDlg, Matrix *matrix);
    void paint          (HWND hWnd);
    void CalculateMatrix();
    void leftButtonDown (HWND hWnd, INT x, INT y);
    void leftButtonUp   (HWND hWnd, INT x, INT y);
    void mouseMove      (HWND hWnd, INT x, INT y);
    static LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

private:
    ScaleTransformControl     scaleControl;
    AngleTransformControl     rotateControl;
    ShearTransformControl     shearControl;
    TranslateTransformControl translateControl;
    INT                       fontCellHeight;
    INT m11X, m11Y, m12X, m12Y, m21X, m21Y, m22X, m22Y, dxX, dxY, dyX, dyY;
    INT rX, rY, sxX, sxY, syX, syY, shX, shY;
    Matrix *TransformMatrix;

    // The controls sit in a grid:
    //
    // ************************
    // *                      *
    // * ****** ****** ****** *
    // * *    * *    * *    * *
    // * *Scl * *Rot * *Shr * *
    // * *    * *    * *    * *
    // * ****** ****** ****** *
    // *                      *
    // * ******  m11  m12   0 *
    // * *    *               *
    // * *xlt *  m21  m22   0 *
    // * *    *               *
    // * ******  d1   d2    1 *
    // *                      *
    // ************************

};

void WorldTransformSetting::init(HWND hWnd, Matrix *matrix) {
    SetWindowLongPtr(hWnd, GWLP_WNDPROC,  (LONG_PTR)this->WndProc);
    SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)this);

    TransformMatrix = matrix;

    RECT rect;
    GetClientRect(hWnd, &rect);
    fontCellHeight = rect.bottom*2/30;

    scaleControl.init    (rect.right/34,    rect.bottom/27,    rect.right*10/34, rect.bottom*10/27, fontCellHeight);
    rotateControl.init   (rect.right*12/34, rect.bottom/27,    rect.right*10/34, rect.bottom*10/27, fontCellHeight);
    shearControl.init    (rect.right*23/34, rect.bottom/27,    rect.right*10/34, rect.bottom*10/27, fontCellHeight);
    translateControl.init(rect.right/34,    rect.bottom*14/27, rect.right*10/34, rect.bottom*10/27, fontCellHeight);
    m11X = rect.right*17/34;  m11Y = rect.bottom*14/27;
    m12X = rect.right*28/34;  m12Y = rect.bottom*14/27;
    m21X = rect.right*17/34;  m21Y = rect.bottom*17/27;
    m22X = rect.right*28/34;  m22Y = rect.bottom*17/27;
    dxX  = rect.right*17/34;  dxY  = rect.bottom*20/27;
    dyX  = rect.right*28/34;  dyY  = rect.bottom*20/27;
    rX   = rect.right*15/34;  rY   = rect.bottom*24/27;
    sxX  = rect.right*20/34;  sxY  = rect.bottom*24/27;
    syX  = rect.right*24/34;  syY  = rect.bottom*24/27;
    shX  = rect.right*30/34;  shY  = rect.bottom*24/27;
    return;
}

void WorldTransformSetting::paint(HWND hWnd) {
    PAINTSTRUCT ps;
    HDC hdc = BeginPaint(hWnd, &ps);

    HFONT hOldFont = (HFONT) SelectObject(hdc, CreateFontA(fontCellHeight,0,0,0,400,0,0,0,0,0,0,0,0,"Tahoma"));

    SetBkColor(hdc, COLORREF(0xC0C0C0));

    scaleControl.paint(hdc);
    rotateControl.paint(hdc);
    shearControl.paint(hdc);
    translateControl.paint(hdc);

    // Write out the matrix

    REAL mv[6];
    g_WorldTransform.GetElements(mv);

    SetTextAlign(hdc, TA_CENTER);
    char strKey[50];
    RECT textRect = {m11X - (m12X-m11X)/2, m11Y, m12X+(m12X-m11X)/2, shY+fontCellHeight};
    ExtTextOutA(hdc, 0, 0, ETO_OPAQUE, &textRect, "", 0, NULL);
    INT strLen;
    strLen = sprintf(strKey, "m11  %.1f", mv[0]); TextOutA(hdc, m11X, m11Y, strKey, strLen);
    strLen = sprintf(strKey, "m12  %.1f", mv[1]); TextOutA(hdc, m12X, m12Y, strKey, strLen);
    strLen = sprintf(strKey, "m21  %.1f", mv[2]); TextOutA(hdc, m21X, m21Y, strKey, strLen);
    strLen = sprintf(strKey, "m22  %.1f", mv[3]); TextOutA(hdc, m22X, m22Y, strKey, strLen);
    strLen = sprintf(strKey, "dx  %.1f",  mv[4]); TextOutA(hdc, dxX,  dxY,  strKey, strLen);
    strLen = sprintf(strKey, "dy  %.1f",  mv[5]); TextOutA(hdc, dyX,  dyY,  strKey, strLen);


    // Show result of Split Transform

    PointF scale;
    REAL   rotate;
    REAL   shear;
    PointF translate;
    SplitTransform(g_WorldTransform, scale, rotate, shear, translate);
    rotate = REAL(rotate * 180 / 3.14159265358979);
    strLen = sprintf(strKey, "r  %.1f", rotate);   TextOutA(hdc, rX,  rY,  strKey, strLen);
    strLen = sprintf(strKey, "sx  %.1f", scale.X); TextOutA(hdc, sxX, sxY, strKey, strLen);
    strLen = sprintf(strKey, "sy  %.1f", scale.Y); TextOutA(hdc, syX, syY, strKey, strLen);
    strLen = sprintf(strKey, "sh  %.1f", shear);   TextOutA(hdc, shX, shY, strKey, strLen);


    DeleteObject(SelectObject(hdc, hOldFont));
    EndPaint(hWnd, &ps);
    InvalidateText();
    return;
}

void WorldTransformSetting::CalculateMatrix() {
    TransformMatrix->Reset();
    TransformMatrix->Rotate(rotateControl.getAngle());
    TransformMatrix->Scale(scaleControl.getScaleX(), scaleControl.getScaleY());
    TransformMatrix->Shear(shearControl.getShearX(), shearControl.getShearY());
    TransformMatrix->Translate(
        translateControl.getTranslateX() * 10,  // * 10 (arbitrary) to make it visible
        translateControl.getTranslateY() * 10);
    return;
}

void WorldTransformSetting::leftButtonDown(HWND hWnd, INT x, INT y) {
    scaleControl.mouse(x,y);
    rotateControl.mouse(x,y);
    shearControl.mouse(x,y);
    translateControl.mouse(x,y);
    CalculateMatrix();
    InvalidateRect(hWnd, NULL, TRUE);
    return;
}

void WorldTransformSetting::leftButtonUp(HWND hWnd, INT x, INT y) {
    scaleControl.mouse(x,y);
    rotateControl.mouse(x,y);
    shearControl.mouse(x,y);
    translateControl.mouse(x,y);
    CalculateMatrix();
    InvalidateRect(hWnd, NULL, TRUE);
    return;
}

void WorldTransformSetting::mouseMove(HWND hWnd, INT x, INT y) {
    scaleControl.mouse(x,y);
    rotateControl.mouse(x,y);
    shearControl.mouse(x,y);
    translateControl.mouse(x,y);
    CalculateMatrix();
    InvalidateRect(hWnd, NULL, TRUE);
    return;
}

LRESULT CALLBACK WorldTransformSetting::WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) {

    HDC hdc;
    WorldTransformSetting *thisSetting = (WorldTransformSetting*)GetWindowLongPtr(hWnd, GWLP_USERDATA);

    switch (message) {

        case WM_LBUTTONDOWN:
            thisSetting->leftButtonDown(hWnd, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_MOUSEMOVE:
            // Treat movement like lbuttonup while lbutton is down,
            // so the selection tracks the cursor movement.
            if (wParam & MK_LBUTTON) {
                thisSetting->mouseMove(hWnd, LOWORD(lParam), HIWORD(lParam));
            }
            break;


        case WM_LBUTTONUP:
            thisSetting->leftButtonUp(hWnd, LOWORD(lParam), HIWORD(lParam));
            break;


        case WM_PAINT:
            thisSetting->paint(hWnd);
            break;

        default:
            return DefWindowProc(hWnd, message, wParam, lParam);
    }

    return 0;
}

WorldTransformSetting worldTransform;
WorldTransformSetting fontTransform;
WorldTransformSetting driverTransform;




const char *szAlignments[] = {
    "AlignNear",
    "AlignCenter",
    "AlignFar"
};

const char *szUnits[] = {
    "UnitWorld",      // 0 -- World coordinate (non-physical unit)
    "UnitNotValid",   // 1 -- UnitDisplay not valid for size units -- device dependent
    "UnitPixel",      // 2 -- Each unit is one device pixel.
    "UnitPoint",      // 3 -- Each unit is a printer's point, or 1/72 inch.
    "UnitInch",       // 4 -- Each unit is 1 inch.
    "UnitDocument",   // 5 -- Each unit is 1/300 inch.
    "UnitMillimeter"  // 6 -- Each unit is 1 millimeter.
};

const char *szForeGroundBrush[] = {
    "Solid",
    "RectGradient",
    "RadialGradient",
    "TriangleGradient",
    "LineGradient"
};

const char *szBackGroundBrush[] = {
    "Solid",
    "RectGradient",
    "RadialGradient",
    "TriangleGradient",
    "LineGradient"
};

const char *szTextMode[] = {
    "SystemDefault",
    "SingleBitPerPixelGridFit",
    "SingleBitPerPixel",
    "AntiAliasGridFit",
    "AntiAlias",
    "ClearTypeGridFit"
};

const char *szUniChar[] = {
    "(File)",
    "(Initial text)",
    "(Multilingual text)",
    "(Metrics text)",
    "200B ZWSP",
    "200C ZWNJ",
    "200D ZWJ",
    "200E LRM",
    "200F RLM",
    "202A LRE",
    "202B RLE",
    "202C PDF",
    "202D LRO",
    "202E RLO",
    "206A ISS",
    "206B ASS",
    "206E NADS",
    "206F NODS",
    "0908 Letter Ii",
    "0915 Letter Ka",
    "093f Vowel I",
    "094D Virama",
};


const char *szRows[] = {
    "1",
    "2",
    "4",
    "8",
    "16",
    "32",
    "64"   // ! Let's hope our friendly client brought his or her magnifying glass ....
};

const char *szDigitSubstitute[] = {
    "StringDigitSubstituteUser",
    "StringDigitSubstituteNone",
    "StringDigitSubstituteNational",
    "StringDigitSubstituteTraditional"
};


// Keep in sync with szLanguage
const LANGID Language[] = {
    MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
    MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
    MAKELANGID(LANG_AFRIKAANS, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_ALBANIAN, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_SAUDI_ARABIA),
    MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_IRAQ),
    MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_EGYPT),
    MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_LIBYA),
    MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_ALGERIA),
    MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_MOROCCO),
    MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_TUNISIA),
    MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_OMAN),
    MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_YEMEN),
    MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_SYRIA),
    MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_JORDAN),
    MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_LEBANON),
    MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_KUWAIT),
    MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_UAE),
    MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_BAHRAIN),
    MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_QATAR),
    MAKELANGID(LANG_ARMENIAN,SUBLANG_NEUTRAL),
    MAKELANGID(LANG_ASSAMESE, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_AZERI, SUBLANG_AZERI_LATIN),
    MAKELANGID(LANG_AZERI, SUBLANG_AZERI_CYRILLIC),
    MAKELANGID(LANG_BASQUE, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_BELARUSIAN, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_BENGALI, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_BULGARIAN, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_CATALAN, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_CHINESE,SUBLANG_CHINESE_TRADITIONAL),
    MAKELANGID(LANG_CHINESE,SUBLANG_CHINESE_SIMPLIFIED),
    MAKELANGID(LANG_CHINESE,SUBLANG_CHINESE_HONGKONG),
    MAKELANGID(LANG_CHINESE,SUBLANG_CHINESE_SINGAPORE),
    MAKELANGID(LANG_CHINESE,SUBLANG_CHINESE_MACAU),
    MAKELANGID(LANG_CROATIAN,SUBLANG_NEUTRAL),
    MAKELANGID(LANG_CZECH, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_DANISH, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_DUTCH, SUBLANG_DUTCH),
    MAKELANGID(LANG_DUTCH, SUBLANG_DUTCH_BELGIAN),
    MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
    MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_UK),
    MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_AUS),
    MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_CAN),
    MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_NZ),
    MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_EIRE),
    MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_SOUTH_AFRICA),
    MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_JAMAICA),
    MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_CARIBBEAN),
    MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_BELIZE),
    MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_TRINIDAD),
    MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_ZIMBABWE),
    MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_PHILIPPINES),
    MAKELANGID(LANG_ESTONIAN,SUBLANG_NEUTRAL),
    MAKELANGID(LANG_FAEROESE, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_FARSI, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_FINNISH, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_FRENCH, SUBLANG_FRENCH),
    MAKELANGID(LANG_FRENCH, ,SUBLANG_FRENCH_BELGIAN),
    MAKELANGID(LANG_FRENCH, ,SUBLANG_FRENCH_CANADIAN),
    MAKELANGID(LANG_FRENCH, ,SUBLANG_FRENCH_SWISS),
    MAKELANGID(LANG_FRENCH, ,SUBLANG_FRENCH_LUXEMBOURG),
    MAKELANGID(LANG_FRENCH, ,SUBLANG_FRENCH_MONACO),
    MAKELANGID(LANG_GEORGIAN,SUBLANG_NEUTRAL),
    MAKELANGID(LANG_GERMAN, SUBLANG_GERMAN),
    MAKELANGID(LANG_GERMAN, SUBLANG_GERMAN_SWISS),
    MAKELANGID(LANG_GERMAN, SUBLANG_GERMAN_AUSTRIAN),
    MAKELANGID(LANG_GERMAN, SUBLANG_GERMAN_LUXEMBOURG),
    MAKELANGID(LANG_GERMAN, SUBLANG_GERMAN_LIECHTENSTEIN),
    MAKELANGID(LANG_GREEK, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_GUJARATI,SUBLANG_NEUTRAL),
    MAKELANGID(LANG_HEBREW, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_HINDI, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_HUNGARIAN, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_ICELANDIC, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_INDONESIAN, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_ITALIAN,SUBLANG_ITALIAN),
    MAKELANGID(LANG_ITALIAN,SUBLANG_ITALIAN_SWISS),
    MAKELANGID(LANG_JAPANESE, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_KANNADA, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_KASHMIRI, SUBLANG_KASHMIRI_SASIA),
    MAKELANGID(LANG_KAZAK, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_KONKANI, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_KOREAN,SUBLANG_KOREAN),
    MAKELANGID(LANG_LATVIAN,SUBLANG_NEUTRAL),
    MAKELANGID(LANG_LITHUANIAN,SUBLANG_LITHUANIAN),
    MAKELANGID(LANG_MACEDONIAN,SUBLANG_NEUTRAL),
    MAKELANGID(LANG_MALAY, SUBLANG_MALAY_MALAYSIA),
    MAKELANGID(LANG_MALAY, SUBLANG_MALAY_BRUNEI_DARUSSALAM),
    MAKELANGID(LANG_MALAYALAM,SUBLANG_NEUTRAL),
    MAKELANGID(LANG_MANIPURI,SUBLANG_NEUTRAL),
    MAKELANGID(LANG_MARATHI,SUBLANG_NEUTRAL),
    MAKELANGID(LANG_NEPALI, SUBLANG_NEPALI_INDIA),
    MAKELANGID(LANG_NORWEGIAN, SUBLANG_NORWEGIAN_BOKMAL),
    MAKELANGID(LANG_NORWEGIAN, SUBLANG_NORWEGIAN_NYNORSK),
    MAKELANGID(LANG_ORIYA, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_POLISH, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_PORTUGUESE, SUBLANG_PORTUGUESE),
    MAKELANGID(LANG_PORTUGUESE, SUBLANG_PORTUGUESE_BRAZILIAN),
    MAKELANGID(LANG_PUNJABI, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_ROMANIAN, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_RUSSIAN, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_SANSKRIT, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_SERBIAN, SUBLANG_SERBIAN_LATIN),
    MAKELANGID(LANG_SERBIAN, SUBLANG_SERBIAN_CYRILLIC),
    MAKELANGID(LANG_SINDHI, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_SLOVAK, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_SLOVENIAN, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_MEXICAN),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_MODERN),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_GUATEMALA),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_COSTA_RICA),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_PANAMA),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_DOMINICAN_REPUBLIC),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_VENEZUELA),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_COLOMBIA),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_PERU),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_ARGENTINA),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_ECUADOR),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_CHILE),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_URUGUAY),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_PARAGUAY),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_BOLIVIA),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_EL_SALVADOR),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_HONDURAS),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_NICARAGUA),
    MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_PUERTO_RICO),
    MAKELANGID(LANG_SWAHILI,SUBLANG_NEUTRAL),
    MAKELANGID(LANG_SWEDISH, SUBLANG_SWEDISH),
    MAKELANGID(LANG_SWEDISH, SUBLANG_SWEDISH_FINLAND),
    MAKELANGID(LANG_TAMIL,SUBLANG_NEUTRAL),
    MAKELANGID(LANG_TATAR, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_TELUGU, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_THAI, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_TURKISH,SUBLANG_NEUTRAL),
    MAKELANGID(LANG_UKRAINIAN, SUBLANG_NEUTRAL),
    MAKELANGID(LANG_URDU, SUBLANG_URDU_PAKISTAN),
    MAKELANGID(LANG_URDU, SUBLANG_URDU_INDIA),
    MAKELANGID(LANG_UZBEK, SUBLANG_UZBEK_LATIN),
    MAKELANGID(LANG_UZBEK, SUBLANG_UZBEK_CYRILLIC),
    MAKELANGID(LANG_VIETNAMESE, SUBLANG_NEUTRAL)
};

const char *szLanguage[] = {
    "Neutral, Neutral",
    "Neutral, Default",
    "Neutral, System default",
    "Afrikaans",
    "Albanian",
    "Arabic, Saudi Arabia",
    "Arabic, Iraq",
    "Arabic, Egypt",
    "Arabic, Libya",
    "Arabic, Algeria",
    "Arabic, Morocco",
    "Arabic, Tunisia",
    "Arabic, Oman",
    "Arabic, Yemen",
    "Arabic, Syria",
    "Arabic, Jordan",
    "Arabic, Lebanon",
    "Arabic, Kuwait",
    "Arabic, UAE",
    "Arabic, Bahrain",
    "Arabic, Qatar",
    "Armenian",
    "Assamese",
    "Azeri, Latin",
    "Azeri, Cyrillic",
    "Basque, ",
    "Belarusian",
    "Bengali",
    "Bulgarian",
    "Catalan",
    "Chinese, Traditional",
    "Chinese, Simplified",
    "Chinese, Hong Kong",
    "Chinese, Singapore",
    "Chinese, Macau",
    "Croatian",
    "Czech",
    "Danish",
    "Dutch",
    "Dutch, Belgian",
    "English, US",
    "English, UK",
    "English, Australia",
    "English, Canada",
    "English, New Zeland",
    "English, Eire",
    "English, South Africa",
    "English, Jamaica",
    "English, Caribbean",
    "English, Belize",
    "English, Trinidad",
    "English, Zimbabwe",
    "English, Philippines",
    "Estonian",
    "Faeroese",
    "Farsi",
    "Finnish",
    "French",
    "French, Belgian",
    "French, Canadian",
    "French, Swiss",
    "French, Luxembourg",
    "French, Monaco",
    "Georgian",
    "German",
    "German, Swiss",
    "German, Austrian",
    "German, Luxembourg",
    "German, Liechtenstein",
    "Greek",
    "Gujarati",
    "Hebrew",
    "Hindi",
    "Hungarian",
    "Icelandic",
    "Indonesian",
    "Italian",
    "Italian, Swiss",
    "Japanese",
    "Kannada",
    "Kashmiri",
    "Kazak",
    "Konkani",
    "Korean",
    "Latvian",
    "Lithuanian",
    "FYRO Macedonian",
    "Malay, Malaysia",
    "MALAY, Brunei darussalam",
    "Malayalam",
    "Manipuri",
    "Marathi",
    "Nepali, India",
    "Norwegian, Bokmal",
    "Norwegian, Nynorsk",
    "Oriya",
    "Polish",
    "Portuguese",
    "Portuguese, Brazilian",
    "Punjabi",
    "Romanian",
    "Russian",
    "Sanskrit",
    "Serbian, Latin",
    "Serbian, Cyrillic",
    "Sindhi",
    "Slovak",
    "Slovenian",
    "Spanish",
    "Spanish, Mexican",
    "Spanish, Modern",
    "Spanish, Guatemala",
    "Spanish, Costa Rica",
    "Spanish, Panama",
    "Spanish, Dominican Republic",
    "Spanish, Venezuela",
    "Spanish, Colombia",
    "Spanish, Peru",
    "Spanish, Argentina",
    "Spanish, Ecuador",
    "Spanish, Chile",
    "Spanish, Uruguay",
    "Spanish, Paraguay",
    "Spanish, Bolivia",
    "Spanish, El Salvador",
    "Spanish, Honduras",
    "Spanish, Nicaragua",
    "Spanish, Puerto Rico",
    "Swahili",
    "Swedish",
    "Swedish, Finland",
    "Tamil",
    "Tatar",
    "Telugu",
    "Thai",
    "Turkish",
    "Ukrainian",
    "Urdu, Pakistan",
    "Urdu, India",
    "Uzbek, Latin",
    "Uzbek, Cyrillic",
    "Vietnamese"
};


const char *szDriverDx[] = {
    "0",
    "10",
    "15",
    "20",
    "25",
    "30",
    "35",
    "40"
};


const char *szDriverPixels[] = {
    "8",
    "9",
    "10",
    "11",
    "12",
    "13",
    "14",
    "16",
    "18",
    "20",
    "24",
    "28",
    "36"
};


const char *szOffsets[] = {
    "0",
    "100",
    "200",
    "300",
    "400",
    "500",
    "600",
    "700",
    "800",
    "900",
    "a00",
    "b00",
    "c00",
    "d00",
    "e00",
    "f00",
    "1000",
    "2000",
    "3000",
    "4000",
    "5000",
    "6000",
    "7000",
    "8000",
    "9000",
    "a000",
    "b000",
    "c000",
    "d000",
    "e000",
    "f000",
};




void ShowSecondaryDialog(HWND hDialog)
{
    RECT rcText;    GetWindowRect(g_hTextWnd, &rcText);
    RECT rcDialog;  GetWindowRect(hDialog,    &rcDialog);

    if (rcText.bottom < rcDialog.bottom)
    {
        SetWindowPos(
            g_hTextWnd,
            NULL,
            0,0,
            g_iMinWidth * 29 / 10, rcDialog.bottom - rcText.top,
            SWP_NOZORDER | SWP_NOMOVE);
    }
    ShowWindow(hDialog, SW_SHOW);
}



void EnableSecondaryDialog(HWND hDlg, INT dialogId, BOOL enable)
{
    if (g_ShowDriver)
    {
        g_ShowDriver = FALSE;
        ShowWindow(g_hDriverSettingsDlg, SW_HIDE);
        SendDlgItemMessage(hDlg, IDC_SHOWDRIVER,  BM_SETCHECK, BST_UNCHECKED, 0);
    }

    if (g_ShowGlyphs)
    {
        g_ShowGlyphs = FALSE;
        ShowWindow(g_hGlyphSettingsDlg, SW_HIDE);
        SendDlgItemMessage(hDlg, IDC_SHOWGLYPHS,  BM_SETCHECK, BST_UNCHECKED, 0);
    }

    if (enable)
    {
        switch (dialogId)
        {
            case IDC_SHOWGLYPHS:  ShowSecondaryDialog(g_hGlyphSettingsDlg);  g_ShowGlyphs = TRUE; break;
            case IDC_SHOWDRIVER:  ShowSecondaryDialog(g_hDriverSettingsDlg); g_ShowDriver = TRUE; break;
        }
    }


    InvalidateText();
}




BOOL FormatFlag(HWND hDlg, INT iCmd, INT flag)
{
    if (IsDlgButtonChecked(hDlg, iCmd))
    {
        g_formatFlags |= flag;
    }
    else
    {
        g_formatFlags &= ~flag;
    }
    SetFocus(g_hTextWnd);
    InvalidateText();
    return TRUE;
}



static COLORREF s_Colors[16];

void InsertText(HWND hDlg, char *textId)
{
    BOOL fLoadTextFile = false;
    char szTextFilename[MAX_PATH];

    if (lstrcmpiA(textId, "(file)") == 0)
    {
        OPENFILENAMEA  ofn = {0};
        char         szSelectedFile[128];

        szSelectedFile[0] = 0;

        ofn.lStructSize     = sizeof(OPENFILENAME);
        ofn.hwndOwner       = hDlg;
        ofn.lpstrFilter     = "Text files\0*.TXT\0";
        ofn.lpstrFile       = szSelectedFile;
        ofn.nMaxFile        = sizeof(szSelectedFile);
        ofn.Flags           = OFN_FILEMUSTEXIST | OFN_LONGNAMES;

        if (GetOpenFileNameA(&ofn))
        {
            fLoadTextFile = true;
            lstrcpyA(szTextFilename, ofn.lpstrFile);
        }
    }
    else if (lstrcmpiA(textId, "(Initial text)") == 0)
    {
        InitText(ID_INITIAL_TEXT);
        InvalidateText();
    }
    else if (lstrcmpiA(textId, "(Multilingual text)") == 0)
    {
        InitText(ID_MULTILINGUAL_TEXT);
        InvalidateText();
    }
    else if (lstrcmpiA(textId, "(Metrics text)") == 0)
    {
        InitText(ID_METRICS_TEXT);
        InvalidateText();
    }
    else
    {
        // Attempt to load this as a file...
        lstrcpyA(szTextFilename, textId);
        fLoadTextFile = true;
    }

    if (fLoadTextFile)
    {
        HANDLE  hf = CreateFileA (szTextFilename,
                                GENERIC_READ,
                                FILE_SHARE_READ,
                                NULL,
                                OPEN_EXISTING,
                                NULL,
                                NULL);

        if (hf != INVALID_HANDLE_VALUE)
        {
            DWORD   charRead;
            BYTE    *fileData = NULL;

            DWORD   fileSize = GetFileSize (hf, NULL);

            if (fileSize > 0)
                fileData = new BYTE [fileSize];

            if (fileData)
            {
                if (ReadFile (hf,
                             fileData,
                             (DWORD)(min (MAX_TEXT * sizeof(WCHAR), fileSize)),
                             &charRead,
                             NULL) != 0)
                {
                    INT c = 0;

                    if (((WCHAR *)fileData)[0] == 0xfeff)
                    {
                        charRead /= sizeof(WCHAR);
                        c += 1;     // strip out Unicode BOM
                    }

                    TextDelete (0, g_iTextLen);
                    TextInsert (0, &((WCHAR *)fileData)[c], charRead - c);
                    InvalidateText();
                }
                delete [] fileData;
            }
            CloseHandle (hf);
        }
    }
}






BOOL Command(HWND hDlg, int iCmd, int iNotify, HWND hItemWnd) {

    char   str[100];
    WCHAR  wc;
    int    i;
    char   hex[] = "0123456789abcdef";


    switch(iCmd) {

    // Font family enumeration

    case IDC_SHOWFAMILIES:
        g_ShowFamilies = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        InvalidateText();
        return TRUE;

    case IDC_PLAINTEXT_FONT:
    case IDC_PLAINTEXT_SIZE:
    case IDC_PLAINTEXT_BOLD:
    case IDC_PLAINTEXT_ITALIC:
    case IDC_PLAINTEXT_UNDERLINE:
    case IDC_PLAINTEXT_STRIKEOUT:

        ChangeFont(
            hDlg,
            0,
            IDC_PLAINTEXT_FONT,
            IDC_PLAINTEXT_SIZE,
            IDC_PLAINTEXT_BOLD,
            IDC_PLAINTEXT_ITALIC,
            IDC_PLAINTEXT_UNDERLINE,
            IDC_PLAINTEXT_STRIKEOUT,
            iCmd,
            iNotify);
        return TRUE;



    // Logical Unicode text

    case IDC_LOGICAL:
        g_ShowLogical = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        InvalidateText();
        return TRUE;

    case IDC_INSERT_CODEPOINT:
        if (GetDlgItemTextA(hDlg, IDC_CODEPOINT, str, sizeof(str)))
        {
            if (str[0] == '(')
            {
                InsertText(hDlg, str);
            }
            else
            {
                wc = (WCHAR)HexToInt(str);
                if (TextInsert(g_iCurChar, &wc, 1)) {
                    g_iCurChar++;
                    InvalidateText();
                }
            }
        }
        return TRUE;

    case IDC_SHOWLEVELS:
        g_fShowLevels = !g_fShowLevels;
        if (g_fShowLevels)
        {
            SetDlgItemTextA(hDlg, IDC_SHOWLEVELS, "Hide levels");
        }
        else
        {
            SetDlgItemTextA(hDlg, IDC_SHOWLEVELS, "Show levels");
        }
        SetFocus(g_hTextWnd);
        InvalidateText();
        return TRUE;



    // Glyph chart using DrawGlyphs

    case IDC_SHOWGLYPHS:
        EnableSecondaryDialog(hDlg, iCmd, IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED);
        return TRUE;


    // Driver strings

    case IDC_SHOWDRIVER:
        EnableSecondaryDialog(hDlg, iCmd, IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED);
        return TRUE;


    // Plain text displayed with DrawString

    case IDC_SHOWDRAWSTRING:
        g_ShowDrawString = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        InvalidateText();
        return TRUE;

    case IDC_SHOWGDI:
        g_ShowGDI = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        InvalidateText();
        return TRUE;


    case IDC_METAFILE:
        g_testMetafile = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        SetFocus(g_hTextWnd);
        InvalidateText();
        return TRUE;


    // StringFormatFlags


    case IDC_DIR:        return FormatFlag(hDlg, iCmd, StringFormatFlagsDirectionRightToLeft);
    case IDC_HORIZ:      return FormatFlag(hDlg, iCmd, StringFormatFlagsDirectionVertical);
    case IDC_NOFITBB:    return FormatFlag(hDlg, iCmd, StringFormatFlagsNoFitBlackBox);
    case IDC_DISPLAYFMT: return FormatFlag(hDlg, iCmd, StringFormatFlagsDisplayFormatControl);
    case IDC_NOFALLBACK: return FormatFlag(hDlg, iCmd, StringFormatFlagsNoFontFallback);
    case IDC_MEASPACE:   return FormatFlag(hDlg, iCmd, StringFormatFlagsMeasureTrailingSpaces);
    case IDC_NOWRAP:     return FormatFlag(hDlg, iCmd, StringFormatFlagsNoWrap);
    case IDC_LINELIMIT:  return FormatFlag(hDlg, iCmd, StringFormatFlagsLineLimit);
    case IDC_NOCLIP:     return FormatFlag(hDlg, iCmd, StringFormatFlagsNoClip);

    // Private, testing, flags

    case IDC_NOGDI:      return FormatFlag(hDlg, iCmd, 0x80000000);
    case IDC_FULLIMAGER: return FormatFlag(hDlg, iCmd, 0x40000000);
    case IDC_NOMINAL:    return FormatFlag(hDlg, iCmd, 0x20000000);



    // String format fields

    case IDC_ALIGNNEAR:   g_align = StringAlignmentNear;   InvalidateText();  return TRUE;
    case IDC_ALIGNCENTER: g_align = StringAlignmentCenter; InvalidateText();  return TRUE;
    case IDC_ALIGNFAR:    g_align = StringAlignmentFar;    InvalidateText();  return TRUE;

    case IDC_LINEALIGNNEAR:   g_lineAlign = StringAlignmentNear;   InvalidateText();  return TRUE;
    case IDC_LINEALIGNCENTER: g_lineAlign = StringAlignmentCenter; InvalidateText();  return TRUE;
    case IDC_LINEALIGNFAR:    g_lineAlign = StringAlignmentFar;    InvalidateText();  return TRUE;

    case IDC_HOTKEYNONE:  g_hotkey = HotkeyPrefixNone;  InvalidateText();  return TRUE;
    case IDC_HOTKEYSHOW:  g_hotkey = HotkeyPrefixShow;  InvalidateText();  return TRUE;
    case IDC_HOTKEYHIDE:  g_hotkey = HotkeyPrefixHide;  InvalidateText();  return TRUE;

    case IDC_TRIMMINGNONE:     g_lineTrim = StringTrimmingNone;               InvalidateText();  return TRUE;
    case IDC_TRIMMINGCHAR:     g_lineTrim = StringTrimmingCharacter;          InvalidateText();  return TRUE;
    case IDC_TRIMMINGWORD:     g_lineTrim = StringTrimmingWord;               InvalidateText();  return TRUE;
    case IDC_TRIMMINGELPSCH:   g_lineTrim = StringTrimmingEllipsisCharacter;  InvalidateText();  return TRUE;
    case IDC_TRIMMINGELPSWD:   g_lineTrim = StringTrimmingEllipsisWord;       InvalidateText();  return TRUE;
    case IDC_TRIMMINGELPSURL:  g_lineTrim = StringTrimmingEllipsisPath;       InvalidateText();  return TRUE;


    case IDC_DEFAULTFORMAT:
        g_typographic = FALSE;
        InvalidateText();
        return TRUE;


    case IDC_TYPOGRAPHICFORMAT:
        g_typographic = TRUE;
        InvalidateText();
        return TRUE;



    case IDC_FONTUNIT:
        g_fontUnit = Unit(SendDlgItemMessage(hDlg, iCmd, CB_GETCURSEL, 0, 0));
        InvalidateText();
        return TRUE;

    case IDC_FOREBRUSHTYPE:
        GetTextForeGroundBrush(SendDlgItemMessage(hDlg, iCmd, CB_GETCURSEL, 0, 0));
        InvalidateText();
        return TRUE;

    case IDC_BACKBRUSHTYPE:
        GetTextBackGroundBrush(SendDlgItemMessage(hDlg, iCmd, CB_GETCURSEL, 0, 0));
        InvalidateText();
        return TRUE;

    case IDC_TEXTMODE:
        GetTextRenderingMode(SendDlgItemMessage(hDlg, iCmd, CB_GETCURSEL, 0, 0));
        InvalidateText();
        return TRUE;

    // String formant digit substitution
    case IDC_DIGIT_SUBSTITUTE:
        GetDigitSubstituteMode(hDlg, SendDlgItemMessage(hDlg, iCmd, CB_GETCURSEL, 0, 0));
        InvalidateText();
        return TRUE;

    case IDC_LANGUAGE:
        g_Language = Language[SendDlgItemMessage(hDlg, iCmd, CB_GETCURSEL, 0, 0)];
        InvalidateText();
        return TRUE;

    // Plain text displayed with paths

    case IDC_SHOWPATH:
        g_ShowPath = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        InvalidateText();
        return TRUE;


    // Font metrics

    case IDC_SHOWMETRIC:
        g_ShowMetric = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        InvalidateText();
        return TRUE;


    // Performance tests

    case IDC_PERFORMANCE:
        g_ShowPerformance = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        InvalidateText();
        return TRUE;


    // Scaling

    case IDC_SHOWSCALING:
        g_ShowScaling = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        InvalidateText();
        return TRUE;


    // Print

    case IDC_PRINT:
        PrintPage();
        return TRUE;

    case IDC_CLR_FOR:
        {
            CHOOSECOLOR cc = {0};
            Color color(g_TextColor);
            cc.lStructSize = sizeof cc;
            cc.lpCustColors = s_Colors;
            cc.rgbResult = RGB(color.GetRed(), color.GetGreen(), color.GetBlue());
            cc.Flags = CC_RGBINIT | CC_ANYCOLOR;
            BOOL bRet = ChooseColor(&cc);
            color.SetFromCOLORREF(cc.rgbResult);
            g_TextColor = color.GetValue();
            GetTextForeGroundBrush(SendDlgItemMessage(hDlg, IDC_FOREBRUSHTYPE, CB_GETCURSEL, 0, 0));
            InvalidateText();
        }
        return TRUE;

    case IDC_CLR_BAC:
        {
            CHOOSECOLOR cc = {0};
            Color color(g_BackColor);
            cc.lStructSize = sizeof cc;
            cc.lpCustColors = s_Colors;
            cc.rgbResult = RGB(color.GetRed(), color.GetGreen(), color.GetBlue());
            cc.Flags = CC_RGBINIT | CC_ANYCOLOR;
            BOOL bRet = ChooseColor(&cc);
            color.SetFromCOLORREF(cc.rgbResult);
            g_BackColor = color.GetValue();
            GetTextBackGroundBrush(SendDlgItemMessage(hDlg, IDC_BACKBRUSHTYPE, CB_GETCURSEL, 0, 0));
            InvalidateText();
        }
        return TRUE;

/* obsolete


    case IDC_PLAINTEXT:
        g_fShowPlainText = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        InvalidateText();
        return TRUE;


    case IDC_LANGUAGE:

        if (iNotify == CBN_SELCHANGE) {
            i = SendMessage(hItemWnd, CB_GETCURSEL, 0, 0);
            if (SendMessage(hItemWnd, CB_GETLBTEXT, i, (LPARAM)str) != CB_ERR) {
                wc = (WCHAR)HexToInt(str);
                g_ScriptControl.uDefaultLanguage = wc;
                InvalidateText();
            }
        } else if (iNotify == CBN_EDITCHANGE) {
            if (SendMessage(hItemWnd, WM_GETTEXT, sizeof(str), (LPARAM)str)) {
                wc = (WCHAR)HexToInt(str);
                g_ScriptControl.uDefaultLanguage = wc;
                InvalidateText();
            }
        }
        return TRUE;

    case IDC_HIGHLIGHT_FROM:
    case IDC_HIGHLIGHT_TO:
        InvalidateText();
        return TRUE;


    case IDC_LINEFILL:
        g_fFillLines = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        InvalidateText();
        return TRUE;

    case IDC_LTR:
        g_ScriptState.uBidiLevel = 0;
        SendDlgItemMessage(hDlg, IDC_LTR, BM_SETSTATE, TRUE, 0);
        SendDlgItemMessage(hDlg, IDC_RTL, BM_SETSTATE, FALSE, 0);
        InvalidateText();
        return TRUE;

    case IDC_RTL:
        g_ScriptState.uBidiLevel = 1;
        SendDlgItemMessage(hDlg, IDC_RTL, BM_SETSTATE, TRUE, 0);
        SendDlgItemMessage(hDlg, IDC_LTR, BM_SETSTATE, FALSE, 0);
        InvalidateText();
        return TRUE;


    case IDC_CONTROL_CONTEXT:
        g_ScriptControl.fContextDigits = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        InvalidateText();
        return TRUE;


    case IDC_DIGIT_SUBSTITUTE:
        g_ScriptState.fDigitSubstitute = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        InvalidateText();
        return TRUE;


    case IDC_ARANUMCONTEXT:
        g_ScriptState.fArabicNumContext = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        InvalidateText();
        return TRUE;


    case IDC_LEGACY_BIDI:
        g_ScriptControl.fLegacyBidiClass = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        InvalidateText();
        return TRUE;


    case IDC_OVERRIDE:
        g_ScriptState.fOverrideDirection = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        InvalidateText();
        return TRUE;


    case IDC_CONTROL_CHARS:
        g_ScriptState.fDisplayZWG = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        InvalidateText();
        return TRUE;


    case IDC_LOGICAL_ORDER:
        g_fLogicalOrder = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        InvalidateText();
        return TRUE;


    case IDC_NO_GLYPH_INDEX:
        g_fNoGlyphIndex = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        InvalidateText();
        return TRUE;


    case IDC_PLAINTEXT_FIT:
        if (IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED) {
            g_dwSSAflags |= SSA_FIT;
        } else {
            g_dwSSAflags &= ~SSA_FIT;
        }
        InvalidateText();
        return TRUE;


    case IDC_PLAINTEXT_CLIP:
        if (IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED) {
            g_dwSSAflags |= SSA_CLIP;
        } else {
            g_dwSSAflags &= ~SSA_CLIP;
        }
        InvalidateText();
        return TRUE;


    case IDC_PLAINTEXT_TAB:
        if (IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED) {
            g_dwSSAflags |= SSA_TAB;
        } else {
            g_dwSSAflags &= ~SSA_TAB;
        }
        InvalidateText();
        return TRUE;


    case IDC_PLAINTEXT_DX:
        g_fOverrideDx = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        memset(g_iWidthBuf, 0, sizeof(int)*g_iTextLen+1);
        InvalidateText();
        return TRUE;


    case IDC_PLAINTEXT_FALLBACK:
        if (IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED) {
            g_dwSSAflags |= SSA_FALLBACK;
        } else {
            g_dwSSAflags &= ~SSA_FALLBACK;
        }
        InvalidateText();
        return TRUE;


    case IDC_PLAINTEXT_LINK:
        if (IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED) {
            g_dwSSAflags |= SSA_LINK;
        } else {
            g_dwSSAflags &= ~SSA_LINK;
        }
        InvalidateText();
        return TRUE;


    case IDC_PLAINTEXT_HOTKEY:
        if (IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED) {
            g_dwSSAflags |= SSA_HOTKEY;
        } else {
            g_dwSSAflags &= ~SSA_HOTKEY;
        }
        InvalidateText();
        return TRUE;


    case IDC_PLAINTEXT_PASSWORD:
        if (IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED) {
            g_dwSSAflags |= SSA_PASSWORD;
        } else {
            g_dwSSAflags &= ~SSA_PASSWORD;
        }
        InvalidateText();
        return TRUE;



    case IDC_FORMATTED:
        g_fShowFancyText = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
        InvalidateText();
        return TRUE;


    case IDC_FANCY_FONT1:
    case IDC_FANCY_SIZE1:
        if (iNotify != CBN_SELCHANGE) {
            return FALSE;
        }
    case IDC_FANCY_BOLD1:
    case IDC_FANCY_ITALIC1:
    case IDC_FANCY_UNDERLINE1:
        ChangeFont(
            hDlg,
            1,
            IDC_FANCY_FONT1,
            IDC_FANCY_SIZE1,
            IDC_FANCY_BOLD1,
            IDC_FANCY_ITALIC1,
            IDC_FANCY_UNDERLINE1);
        return TRUE;


    case IDC_FANCY_FONT2:
    case IDC_FANCY_SIZE2:
        if (iNotify != CBN_SELCHANGE) {
            return FALSE;
        }
    case IDC_FANCY_BOLD2:
    case IDC_FANCY_ITALIC2:
    case IDC_FANCY_UNDERLINE2:
        ChangeFont(
            hDlg,
            2,
            IDC_FANCY_FONT2,
            IDC_FANCY_SIZE2,
            IDC_FANCY_BOLD2,
            IDC_FANCY_ITALIC2,
            IDC_FANCY_UNDERLINE2);
        return TRUE;


    case IDC_FANCY_FONT3:
    case IDC_FANCY_SIZE3:
        if (iNotify != CBN_SELCHANGE) {
            return FALSE;
        }
    case IDC_FANCY_BOLD3:
    case IDC_FANCY_ITALIC3:
    case IDC_FANCY_UNDERLINE3:
        ChangeFont(
            hDlg,
            3,
            IDC_FANCY_FONT3,
            IDC_FANCY_SIZE3,
            IDC_FANCY_BOLD3,
            IDC_FANCY_ITALIC3,
            IDC_FANCY_UNDERLINE3);
        return TRUE;


    case IDC_FANCY_FONT4:
    case IDC_FANCY_SIZE4:
        if (iNotify != CBN_SELCHANGE) {
            return FALSE;
        }
    case IDC_FANCY_BOLD4:
    case IDC_FANCY_ITALIC4:
    case IDC_FANCY_UNDERLINE4:
        ChangeFont(
            hDlg,
            4,
            IDC_FANCY_FONT4,
            IDC_FANCY_SIZE4,
            IDC_FANCY_BOLD4,
            IDC_FANCY_ITALIC4,
            IDC_FANCY_UNDERLINE4);
        return TRUE;


    case IDC_FORMAT1:
    case IDC_FORMAT2:
    case IDC_FORMAT3:
    case IDC_FORMAT4:

        if (g_iTo < g_iFrom) {
            i=g_iTo;  g_iTo=g_iFrom;  g_iFrom=i;
        }

        if (    g_iFrom <  g_iTo
            &&  g_iFrom <  g_iTextLen
            &&  g_iTo   <= g_iTextLen) {

            i=1; // Default
            switch(iCmd) {
                case IDC_FORMAT1:  i=1;  break;
                case IDC_FORMAT2:  i=2;  break;
                case IDC_FORMAT3:  i=3;  break;
                case IDC_FORMAT4:  i=4;  break;
            }
            StyleSetRange(i, g_iFrom, g_iTo-g_iFrom);
            ASSERT(StyleCheckRange());
            InvalidateText();
        }
        return TRUE;


    case IDC_APPLYDIGITSUBST:
        ScriptApplyDigitSubstitution(NULL, &g_ScriptControl, &g_ScriptState);

        SendDlgItemMessage(hDlg, IDC_DIGIT_SUBSTITUTE,  BM_SETCHECK, g_ScriptState.fDigitSubstitute ? BST_CHECKED : BST_UNCHECKED, 0);
        SendDlgItemMessage(hDlg, IDC_CONTROL_CONTEXT,   BM_SETCHECK, g_ScriptControl.fContextDigits ? BST_CHECKED : BST_UNCHECKED, 0);
        str[0] = '0';
        str[1] = 'x';
        str[2] = hex[(g_ScriptControl.uDefaultLanguage & 0xf0) >> 4];
        str[3] = hex[ g_ScriptControl.uDefaultLanguage & 0x0f];
        str[4] = 0;
        SendDlgItemMessage(hDlg, IDC_LANGUAGE,          CB_SELECTSTRING, 0, (LPARAM) str);

        InvalidateText();
        return TRUE;


    case IDC_PRESENTATION:
        g_fPresentation = TRUE;
        ShowWindow(g_hSettingsDlg, SW_HIDE);
        SetFocus(g_hTextWnd);
        InvalidateText();
        return TRUE;



*/


    }  // end switch

    return FALSE;
}





BOOL GetDropListValue(HWND hDlg, INT iCmd, INT iNotify, char *str, INT strlen)
{
    switch (iNotify)
    {
        case CBN_EDITCHANGE:
            return GetDlgItemTextA(hDlg, iCmd, str, strlen);

        case CBN_SELCHANGE:
            return SendDlgItemMessage(
                hDlg,
                iCmd,
                CB_GETLBTEXT,
                SendDlgItemMessage(hDlg, iCmd, CB_GETCURSEL, 0, 0),
                (LPARAM)str
            ) != CB_ERR;
    }

    return FALSE;
}


BOOL DriverSettingsCommand(HWND hDlg, int iCmd, int iNotify, HWND hItemWnd) {

    char   str[100];

    switch(iCmd) {

    // Driver strings

        case IDC_DRIVERCMAP:
            if (IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED)
            {
                g_DriverOptions |= DriverStringOptionsCmapLookup;
            }
            else
            {
                g_DriverOptions &= ~DriverStringOptionsCmapLookup;
            }
            InvalidateText();
            return TRUE;

        case IDC_DRIVERVERTICAL:
            if (IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED)
            {
                g_DriverOptions |= DriverStringOptionsVertical;
            }
            else
            {
                g_DriverOptions &= ~DriverStringOptionsVertical;
            }
            InvalidateText();
            return TRUE;

        case IDC_DRIVERREALIZEDADVANCE:
            if (IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED)
            {
                g_DriverOptions |= DriverStringOptionsRealizedAdvance;
            }
            else
            {
                g_DriverOptions &= ~DriverStringOptionsRealizedAdvance;
            }
            InvalidateText();
            return TRUE;


        case IDC_DRIVERDX:
            if (GetDropListValue(hDlg, iCmd, iNotify, str, sizeof(str)))
            {
                g_DriverDx = REAL(atof(str));
                InvalidateText();
            }
            return TRUE;

        case IDC_DRIVERDY:
            if (GetDropListValue(hDlg, iCmd, iNotify, str, sizeof(str)))
            {
                g_DriverDy = REAL(atof(str));
                InvalidateText();
            }
            return TRUE;

            case IDC_LIMITSUBPIXEL:
                if (IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED)
                {
                    g_DriverOptions |= DriverStringOptionsLimitSubpixel;
                }
                else
                {
                    g_DriverOptions &= ~DriverStringOptionsLimitSubpixel;
                }
                InvalidateText();
                return TRUE;

        case IDC_DRIVERORIGINALPIXELS:
            if (GetDropListValue(hDlg, iCmd, iNotify, str, sizeof(str)))
            {
                g_DriverPixels = REAL(atof(str));
                InvalidateText();
            }
            return TRUE;

    }  // end switch

    return FALSE;
}





BOOL GlyphSettingsCommand(HWND hDlg, int iCmd, int iNotify, HWND hItemWnd) {

    char   str[100];

    switch(iCmd) {

        case IDC_GLYPHCMAPLOOKUP:
            g_CmapLookup = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
            InvalidateText();
            return TRUE;

        case IDC_GLYPHHORIZONTALCHART:
            g_HorizontalChart = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
            InvalidateText();
            return TRUE;

        case IDC_GLYPHSHOWCELL:
            g_ShowCell = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
            InvalidateText();
            return TRUE;

        case IDC_GLYPHVERTICALFORMS:
            g_VerticalForms = IsDlgButtonChecked(hDlg, iCmd) == BST_CHECKED;
            InvalidateText();
            return TRUE;


        case IDC_GLYPHROWS:
            if (GetDropListValue(hDlg, iCmd, iNotify, str, sizeof(str)))
            {
                g_GlyphRows = atoi(str);
                if (g_GlyphRows > 64) g_GlyphRows = 64;
                InvalidateText();
            }
            return TRUE;


        case IDC_GLYPHCOLUMNS:
            if (GetDropListValue(hDlg, iCmd, iNotify, str, sizeof(str)))
            {
                g_GlyphColumns = atoi(str);
                if (g_GlyphColumns > 64) g_GlyphColumns = 64;
                InvalidateText();
            }
            return TRUE;


        case IDC_GLYPHINDEX:
            if (GetDropListValue(hDlg, iCmd, iNotify, str, sizeof(str)))
            {
                g_GlyphFirst = HexToInt(str);
                InvalidateText();
            }
            return TRUE;



    }  // end switch

    return FALSE;
}





int CALLBACK InitOneFace(
    const ENUMLOGFONTEXA   *lpelfe,    // pointer to logical-font data
    const NEWTEXTMETRICEXA *lpntme,    // pointer to physical-font data
    int                     FontType,  // type of font
    LPARAM                  lParam) {  // application-defined data

    if (SendDlgItemMessage(
            (HWND)lParam,
            IDC_PLAINTEXT_FONT,
            CB_FINDSTRINGEXACT,
            0, (LPARAM)lpelfe->elfLogFont.lfFaceName) == CB_ERR) {

        // It's a new font name

        SendDlgItemMessage(
            (HWND)lParam,
            IDC_PLAINTEXT_FONT,
            CB_ADDSTRING,
            0, (LPARAM)lpelfe->elfLogFont.lfFaceName);

/*
        SendDlgItemMessage(
            (HWND)lParam,
            IDC_FANCY_FONT1,
            CB_ADDSTRING,
            0, (LPARAM)lpelfe->elfLogFont.lfFaceName);

        SendDlgItemMessage(
            (HWND)lParam,
            IDC_FANCY_FONT2,
            CB_ADDSTRING,
            0, (LPARAM)lpelfe->elfLogFont.lfFaceName);

        SendDlgItemMessage(
            (HWND)lParam,
            IDC_FANCY_FONT3,
            CB_ADDSTRING,
            0, (LPARAM)lpelfe->elfLogFont.lfFaceName);

        SendDlgItemMessage(
            (HWND)lParam,
            IDC_FANCY_FONT4,
            CB_ADDSTRING,
            0, (LPARAM)lpelfe->elfLogFont.lfFaceName);
*/
    }


    return 1;   // Continue enumeration


    UNREFERENCED_PARAMETER(FontType);
    UNREFERENCED_PARAMETER(lpntme);
}


void InitOneSize(
    HWND   hDlg,
    char  *str) {

    SendDlgItemMessageA(hDlg, IDC_PLAINTEXT_SIZE, CB_ADDSTRING, 0, (LPARAM)str);
/*
    SendDlgItemMessage(hDlg, IDC_FANCY_SIZE1,    CB_ADDSTRING, 0, (LPARAM)str);
    SendDlgItemMessage(hDlg, IDC_FANCY_SIZE2,    CB_ADDSTRING, 0, (LPARAM)str);
    SendDlgItemMessage(hDlg, IDC_FANCY_SIZE3,    CB_ADDSTRING, 0, (LPARAM)str);
    SendDlgItemMessage(hDlg, IDC_FANCY_SIZE4,    CB_ADDSTRING, 0, (LPARAM)str);
*/
}



void InitSelection(HWND hDlg, int idFace, int idSize, TCHAR *sFaceName) {

    INT_PTR     i;

    i = SendDlgItemMessage(hDlg, idFace, CB_FINDSTRINGEXACT, 0, (LPARAM)sFaceName);
    if (i == CB_ERR) {
        SendDlgItemMessage(hDlg, idFace, CB_SETCURSEL, 0, 0);
    } else {
        SendDlgItemMessage(hDlg, idFace, CB_SETCURSEL, i, 0);
    }

    SendDlgItemMessage(hDlg, idSize, CB_SETCURSEL, 2, 0);   // Selection 2 is 8 point
}


void InitFaceLists(HWND hDlg) {

    HDC      hdc;
    LOGFONT lf;

    memset(&lf, 0, sizeof(lf));
    lf.lfCharSet = DEFAULT_CHARSET;
    hdc = GetDC(g_hTextWnd);
    EnumFontFamiliesEx(hdc, &lf, (FONTENUMPROC)InitOneFace, (LPARAM)hDlg, 0);

    // Hard coded addtion of MS Shell Dlg fonts

    SendDlgItemMessage(hDlg, IDC_PLAINTEXT_FONT, CB_ADDSTRING, 0,  (LPARAM)"MS Shell Dlg");
    SendDlgItemMessage(hDlg, IDC_PLAINTEXT_FONT, CB_ADDSTRING, 0,  (LPARAM)"MS Shell Dlg 2");

    ReleaseDC(g_hTextWnd, hdc);


    // Initialise sizes

    InitOneSize(hDlg, "6");
    InitOneSize(hDlg, "7");
    InitOneSize(hDlg, "8");
    InitOneSize(hDlg, "9");
    InitOneSize(hDlg, "10");
    InitOneSize(hDlg, "11");
    InitOneSize(hDlg, "12");
    InitOneSize(hDlg, "13");
    InitOneSize(hDlg, "14");
    InitOneSize(hDlg, "16");
    InitOneSize(hDlg, "18");
    InitOneSize(hDlg, "20");
    InitOneSize(hDlg, "22");
    InitOneSize(hDlg, "24");
    InitOneSize(hDlg, "28");
    InitOneSize(hDlg, "32");
    InitOneSize(hDlg, "36");
    InitOneSize(hDlg, "48");
    InitOneSize(hDlg, "60");
    InitOneSize(hDlg, "72");
    InitOneSize(hDlg, "90");
    InitOneSize(hDlg, "108");
    InitOneSize(hDlg, "144");
    InitOneSize(hDlg, "180");
    InitOneSize(hDlg, "216");
    InitOneSize(hDlg, "252");
    InitOneSize(hDlg, "288");
    InitOneSize(hDlg, "324");
    InitOneSize(hDlg, "360");
    InitOneSize(hDlg, "396");
    InitOneSize(hDlg, "450");
    InitOneSize(hDlg, "504");
    InitOneSize(hDlg, "558");
    InitOneSize(hDlg, "612");
    InitOneSize(hDlg, "666");
    InitOneSize(hDlg, "720");
#define MAXPOINTSIZE 720  // Keep same as point size in the previous line


    // Select standard fonts and sizes


    InitSelection(hDlg, IDC_PLAINTEXT_FONT, IDC_PLAINTEXT_SIZE, _TEXT("Microsoft Sans Serif"));

/*
    InitSelection(hDlg, IDC_FANCY_FONT1,    IDC_FANCY_SIZE1,    "Tahoma");
    InitSelection(hDlg, IDC_FANCY_FONT2,    IDC_FANCY_SIZE2,    "Mangal");
    InitSelection(hDlg, IDC_FANCY_FONT3,    IDC_FANCY_SIZE3,    "Latha");
    InitSelection(hDlg, IDC_FANCY_FONT4,    IDC_FANCY_SIZE4,    "Tahoma");
*/

/*
    ChangeFont(hDlg, 1, IDC_FANCY_FONT1, IDC_FANCY_SIZE1, IDC_FANCY_BOLD1, IDC_FANCY_ITALIC1, IDC_FANCY_UNDERLINE1);
    ChangeFont(hDlg, 2, IDC_FANCY_FONT2, IDC_FANCY_SIZE2, IDC_FANCY_BOLD2, IDC_FANCY_ITALIC2, IDC_FANCY_UNDERLINE2);
    ChangeFont(hDlg, 3, IDC_FANCY_FONT3, IDC_FANCY_SIZE3, IDC_FANCY_BOLD3, IDC_FANCY_ITALIC3, IDC_FANCY_UNDERLINE3);
    ChangeFont(hDlg, 4, IDC_FANCY_FONT4, IDC_FANCY_SIZE4, IDC_FANCY_BOLD4, IDC_FANCY_ITALIC4, IDC_FANCY_UNDERLINE4);
*/
};







void InitDropList(
    HWND          hDlg,
    int           id,
    const char  **strings,
    int           stringCount
)
{
    INT i;
    for (i=0; i<stringCount; i++) {
        SendDlgItemMessageA(hDlg, id, CB_ADDSTRING, 0, (LPARAM)strings[i]);
    }
    SendDlgItemMessage(hDlg, id, CB_SETCURSEL, 0, 0);
}



INT_PTR CALLBACK GlyphSettingsDlgProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:

            for (INT i=0; i < sizeof(szRows)/sizeof(szRows[0]); i++) {
                SendDlgItemMessage(hDlg, IDC_GLYPHROWS, CB_ADDSTRING, 0, (LPARAM)szRows[i]);
                SendDlgItemMessage(hDlg, IDC_GLYPHCOLUMNS, CB_ADDSTRING, 0, (LPARAM)szRows[i]);
            }
            SendDlgItemMessage(hDlg, IDC_GLYPHROWS,    CB_SETCURSEL, 4, 0);
            SendDlgItemMessage(hDlg, IDC_GLYPHCOLUMNS, CB_SETCURSEL, 4, 0);

            InitDropList(hDlg, IDC_GLYPHINDEX, szOffsets, sizeof(szOffsets)/sizeof(szOffsets[0]));

            fontTransform.init(GetDlgItem(hDlg, IDC_FONTTRANSFORM), &g_FontTransform);
            return FALSE;

        case WM_COMMAND:
            GlyphSettingsCommand(hDlg, LOWORD(wParam), HIWORD(wParam), (HWND)lParam);
            return FALSE;
    }

    return FALSE;
}




INT_PTR CALLBACK DriverSettingsDlgProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:

            InitDropList(hDlg, IDC_DRIVERDX, szDriverDx, sizeof(szDriverDx)/sizeof(szDriverDx[0]));
            InitDropList(hDlg, IDC_DRIVERDY, szDriverDx, sizeof(szDriverDx)/sizeof(szDriverDx[0]));
            InitDropList(hDlg, IDC_DRIVERORIGINALPIXELS, szDriverPixels, sizeof(szDriverPixels)/sizeof(szDriverPixels[0]));

            SendDlgItemMessage(hDlg, IDC_DRIVERDX,              CB_SETCURSEL, 2, 0);
            SendDlgItemMessage(hDlg, IDC_DRIVERDY,              CB_SETCURSEL, 0, 0);
            SendDlgItemMessage(hDlg, IDC_DRIVERORIGINALPIXELS,  CB_SETCURSEL, 5, 0);

            driverTransform.init(GetDlgItem(hDlg, IDC_DRIVERTRANSFORM), &g_DriverTransform);

            SendDlgItemMessage(hDlg, IDC_DRIVERCMAP,            BM_SETCHECK, BST_CHECKED, 0);
            SendDlgItemMessage(hDlg, IDC_DRIVERREALIZEDADVANCE, BM_SETCHECK, BST_CHECKED, 0);
            return FALSE;

        case WM_COMMAND:
            DriverSettingsCommand(hDlg, LOWORD(wParam), HIWORD(wParam), (HWND)lParam);
            return FALSE;
    }

    return FALSE;
}




INT_PTR CALLBACK SettingsDlgProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
        int i;


        switch (uMsg)
        {


        case WM_INITDIALOG:

            // Populate the Unicode codepoint combo box

            for (i=0; i<sizeof(szUniChar)/sizeof(szUniChar[0]); i++) {
                SendDlgItemMessageA(hDlg, IDC_CODEPOINT, CB_ADDSTRING, 0, (LPARAM)szUniChar[i]);
            }

/*
            for (i=0; i<sizeof(szLanguage)/sizeof(szLanguage[0]); i++) {
                SendDlgItemMessage(hDlg, IDC_LANGUAGE, CB_ADDSTRING, 0, (LPARAM)szLanguage[i]);
            }

            SendDlgItemMessage(hDlg, IDC_LANGUAGE, CB_SETCURSEL, 0, 0);
*/

            InitDropList(hDlg, IDC_ALIGNMENT, szAlignments, sizeof(szAlignments)/sizeof(szAlignments[0]));
            InitDropList(hDlg, IDC_FONTUNIT, szUnits, sizeof(szUnits)/sizeof(szUnits[0]));
            InitDropList(hDlg, IDC_FOREBRUSHTYPE, szForeGroundBrush, sizeof(szForeGroundBrush)/sizeof(szForeGroundBrush[0]));
            InitDropList(hDlg, IDC_BACKBRUSHTYPE, szBackGroundBrush, sizeof(szBackGroundBrush)/sizeof(szBackGroundBrush[0]));
            InitDropList(hDlg, IDC_TEXTMODE, szTextMode, sizeof(szTextMode)/sizeof(szTextMode[0]));

            InitDropList(hDlg, IDC_DIGIT_SUBSTITUTE, szDigitSubstitute, sizeof(szDigitSubstitute)/sizeof(szDigitSubstitute[0]));
            InitDropList(hDlg, IDC_LANGUAGE,         szLanguage, sizeof(szLanguage)/sizeof(szLanguage[0]));

            GetTextForeGroundBrush(0);
            GetTextBackGroundBrush(0);

            SendDlgItemMessage(hDlg, IDC_FONTUNIT, CB_SETCURSEL, 3, 0);

            //InitDropList(hDlg, IDC_RENDERER, szRenderers, sizeof(szRenderers)/sizeof(szRenderers[0]));

            InitFaceLists(hDlg);


            if (g_ShowFamilies)   SendDlgItemMessage(hDlg, IDC_SHOWFAMILIES,   BM_SETCHECK, BST_CHECKED, 0);
            if (g_ShowLogical)    SendDlgItemMessage(hDlg, IDC_LOGICAL,        BM_SETCHECK, BST_CHECKED, 0);
            if (g_ShowGlyphs)     SendDlgItemMessage(hDlg, IDC_SHOWGLYPHS,     BM_SETCHECK, BST_CHECKED, 0);
            if (g_ShowDrawString) SendDlgItemMessage(hDlg, IDC_SHOWDRAWSTRING, BM_SETCHECK, BST_CHECKED, 0);

            if (g_Bold)      SendDlgItemMessage(hDlg, IDC_PLAINTEXT_BOLD,      BM_SETCHECK, BST_CHECKED, 0);
            if (g_Italic)    SendDlgItemMessage(hDlg, IDC_PLAINTEXT_ITALIC,    BM_SETCHECK, BST_CHECKED, 0);
            if (g_Underline) SendDlgItemMessage(hDlg, IDC_PLAINTEXT_UNDERLINE, BM_SETCHECK, BST_CHECKED, 0);
            if (g_Strikeout) SendDlgItemMessage(hDlg, IDC_PLAINTEXT_STRIKEOUT, BM_SETCHECK, BST_CHECKED, 0);

            SendDlgItemMessage(hDlg, IDC_PLAINTEXT_FONT, CB_SELECTSTRING, -1, (LPARAM)g_szFaceName);

            // Make sure the control shows the proper selection...
            SendDlgItemMessage(hDlg, IDC_TEXTMODE, CB_SETCURSEL, g_TextMode, 0);

/*
            SendDlgItemMessage(hDlg, IDC_LTR,       BM_SETSTATE, TRUE, 0);
            SendDlgItemMessage(hDlg, IDC_HORIZ,     BM_SETSTATE, TRUE, 0);

            SendDlgItemMessage(hDlg, IDC_LOGICAL,   BM_SETCHECK, BST_CHECKED, 0);
            SendDlgItemMessage(hDlg, IDC_PLAINTEXT, BM_SETCHECK, BST_CHECKED, 0);
            SendDlgItemMessage(hDlg, IDC_FORMATTED, BM_SETCHECK, BST_CHECKED, 0);

            SendDlgItemMessage(hDlg, IDC_LINEFILL,  BM_SETCHECK, BST_CHECKED, 0);

            SendDlgItemMessage(hDlg, IDC_PLAINTEXT_FALLBACK, BM_SETCHECK, BST_CHECKED, 0);
*/

            SendDlgItemMessage(hDlg, IDC_FONTSIZE, TBM_SETRANGE, 0,    MAKELONG(1,MAXPOINTSIZE));
            SendDlgItemMessage(hDlg, IDC_FONTSIZE, TBM_SETPOS,   TRUE, g_iFontHeight);

            SendDlgItemMessage(hDlg, IDC_GAMMAVALUE, TBM_SETRANGE, 0,    MAKELONG(0,12));
            SendDlgItemMessage(hDlg, IDC_GAMMAVALUE, TBM_SETPOS,   TRUE, 4);


            worldTransform.init(GetDlgItem(hDlg, IDC_WORLDTRANSFORM), &g_WorldTransform);

            return FALSE;

        case WM_COMMAND:
            Command(hDlg, LOWORD(wParam), HIWORD(wParam), (HWND)lParam);
            return FALSE;

        case WM_NOTIFY:

            /*
                char str[200];
                wsprintf(str, "WM_NOTIFY (hDlg %x, IDC_FONTSIZE %x = wnd %x), hwnd %x, hwndFrom %x, idFrom %x, code %x.\n",
                    hDlg,
                    IDC_FONTSIZE,
                    GetDlgItem(hDlg, IDC_FONTSIZE),
                    wParam,
                    ((NMHDR*)lParam)->hwndFrom,
                    ((NMHDR*)lParam)->idFrom,
                    ((NMHDR*)lParam)->code
                );
                OutputDebugString(str);
            */

            if (    ((NMHDR*)lParam)->idFrom == IDC_GAMMAVALUE
                &&  ((NMHDR*)lParam)->code   == NM_CUSTOMDRAW)
            {
                // Update font size

                g_GammaValue = (UINT)SendDlgItemMessage(hDlg, IDC_GAMMAVALUE, TBM_GETPOS, 0, 0);

                InvalidateText();
            }

            if (    ((NMHDR*)lParam)->idFrom == IDC_FONTSIZE
                &&  ((NMHDR*)lParam)->code   == NM_CUSTOMDRAW)
            {
                // Update font size

                INT pos = (INT)SendDlgItemMessage(hDlg, IDC_FONTSIZE, TBM_GETPOS, 0, 0);

                char str[100];
                wsprintfA(str, "%d", pos);

                /*
                    OutputDebugString("Pos: ");
                    OutputDebugString(str);
                    OutputDebugString("\n");
                */

                SendDlgItemMessageA(hDlg, IDC_PLAINTEXT_SIZE, WM_SETTEXT, 0, (LPARAM)str);

                // Get facename

                UINT_PTR i = SendDlgItemMessage(hDlg, IDC_PLAINTEXT_FONT, CB_GETCURSEL, 0, 0);
                TCHAR sFaceName[100];
                if (SendDlgItemMessage(hDlg, IDC_PLAINTEXT_FONT, CB_GETLBTEXT, i, (LPARAM)sFaceName) == CB_ERR) {
                    return FALSE;
                }


                SetStyle(
                    0,
                    pos,
                    IsDlgButtonChecked(hDlg, IDC_PLAINTEXT_BOLD)      == BST_CHECKED ? 700 : 400,
                    IsDlgButtonChecked(hDlg, IDC_PLAINTEXT_ITALIC)    == BST_CHECKED,
                    IsDlgButtonChecked(hDlg, IDC_PLAINTEXT_UNDERLINE) == BST_CHECKED,
                    IsDlgButtonChecked(hDlg, IDC_PLAINTEXT_STRIKEOUT) == BST_CHECKED,
                    sFaceName
                );
                InvalidateText();
            }
            return FALSE;

        }



        return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\texttest\readprofile.cpp ===
//
// ReadProfile.cpp - Routine to parse a windows Profile file and setup globals
//

#include "precomp.hxx"
#include "global.h"
#include "winspool.h"
#include <Tchar.h>

// Pre-defined section names
#define SECTION_CONTROL      "Control"
#define SECTION_FONT         "Font"
#define SECTION_RENDER       "Render"
#define SECTION_API          "API"
#define SECTION_FONTLIST     "FontList"
#define SECTION_FONTHEIGHT   "FontHeight"
#define SECTION_AUTOFONTS    "AutoFonts"
#define SECTION_AUTOHEIGHTS  "AutoHeights"
#define SECTION_DRIVERSTRING "DriverString"

// Maximum length for a profile value string...
#define PROFILEVALUEMAX 4096

// Enumeration of profile variable types
typedef enum
{
    epitInvalid = 0,              // Invalid value
    epitBool    = 1,              // BOOL value
    epitInt     = 2,              // system integer (32 bits on x86) value
    epitFloat   = 3,              // single-precision floating point value
    epitDouble  = 4,              // double-precision floating point value
    epitString  = 5,              // ANSI string value
    epitAlign   = 6,              // StringAlignment value
    epitColor   = 7               // RGBQUAD color
} PROFILEINFOTYPE;

// profile information structure
typedef struct PROFILEINFO_tag
{
    char szSection[80];     // Section of the profile to read value from
    char szVariable[80];    // Name of the variable
    PROFILEINFOTYPE type;   // Type of the variable
    void *pvVariable;       // void * to the variable (&g_Foo...)
    DWORD dwVariableLength; // size in bytes of the variable (sizeof(g_Foo...))
} PROFILEINFO;

////////////////////////////////////////////////////////////////////////////////////////
// Global profile info structure : Add to this table to get a variable from the .INI
////////////////////////////////////////////////////////////////////////////////////////
PROFILEINFO g_rgProfileInfo[] =
{
    { SECTION_CONTROL,     "AutoDrive",       epitBool,    &g_AutoDrive,         sizeof(g_AutoDrive) },
    { SECTION_CONTROL,     "NumIterations",   epitInt,     &g_iNumIterations,    sizeof(g_iNumIterations) },
    { SECTION_CONTROL,     "NumRepaints",     epitInt,     &g_iNumRepaints,      sizeof(g_iNumRepaints) },
    { SECTION_CONTROL,     "NumRenders",      epitInt,     &g_iNumRenders,       sizeof(g_iNumRenders) },
    { SECTION_CONTROL,     "AutoFonts",       epitBool,    &g_AutoFont,          sizeof(g_AutoFont) },
    { SECTION_CONTROL,     "AutoHeight",      epitBool,    &g_AutoHeight,        sizeof(g_AutoHeight) },
    { SECTION_CONTROL,     "TextFile",        epitString,  &g_szSourceTextFile,  sizeof(g_szSourceTextFile) },
    { SECTION_CONTROL,     "FontOverride",    epitBool,    &g_FontOverride,      sizeof(g_FontOverride) },
    { SECTION_API,         "DrawString",      epitBool,    &g_ShowDrawString,    sizeof(g_ShowDrawString) },
    { SECTION_API,         "ShowDriver",      epitBool,    &g_ShowDriver,        sizeof(g_ShowDriver) },
    { SECTION_API,         "ShowPath",        epitBool,    &g_ShowPath,          sizeof(g_ShowPath) },
    { SECTION_API,         "ShowFamilies",    epitBool,    &g_ShowFamilies,      sizeof(g_ShowFamilies) },
    { SECTION_API,         "ShowGlyphs",      epitBool,    &g_ShowGlyphs,        sizeof(g_ShowGlyphs) },
    { SECTION_API,         "ShowMetric",      epitBool,    &g_ShowMetric,        sizeof(g_ShowMetric) },
    { SECTION_API,         "ShowGDI",         epitBool,    &g_ShowGDI,           sizeof(g_ShowGDI) },
    { SECTION_API,         "UseDrawText",     epitBool,    &g_UseDrawText,       sizeof(g_UseDrawText) },
    { SECTION_FONT,        "FaceName",        epitString,  &g_szFaceName,        sizeof(g_szFaceName) },
    { SECTION_FONT,        "Height",          epitInt,     &g_iFontHeight,       sizeof(g_iFontHeight) },
    { SECTION_FONT,        "Unit",            epitInt,     &g_fontUnit,          sizeof(g_fontUnit) },
    { SECTION_FONT,        "Typographic",     epitBool,    &g_typographic,       sizeof(g_typographic) },
    { SECTION_FONT,        "Bold",            epitBool,    &g_Bold,              sizeof(g_Bold) },
    { SECTION_FONT,        "Italic",          epitBool,    &g_Italic,            sizeof(g_Italic) },
    { SECTION_FONT,        "Underline",       epitBool,    &g_Underline,         sizeof(g_Underline) },
    { SECTION_FONT,        "Strikeout",       epitBool,    &g_Strikeout,         sizeof(g_Strikeout) },
    { SECTION_RENDER,      "TextMode",        epitInt,     &g_TextMode,          sizeof(g_TextMode) },
    { SECTION_RENDER,      "Align",           epitAlign,   &g_align,             sizeof(g_align) },
    { SECTION_RENDER,      "LineAlign",       epitAlign,   &g_lineAlign,         sizeof(g_lineAlign) },
    { SECTION_RENDER,      "HotKey",          epitInt,     &g_hotkey,            sizeof(g_hotkey) },
    { SECTION_RENDER,      "LineTrim",        epitInt,     &g_lineTrim,          sizeof(g_lineTrim) },
    { SECTION_RENDER,      "NoFitBB",         epitBool,    &g_NoFitBB,           sizeof(g_NoFitBB) },
    { SECTION_RENDER,      "NoWrap",          epitBool,    &g_NoWrap,            sizeof(g_NoWrap) },
    { SECTION_RENDER,      "NoClip",          epitBool,    &g_NoClip,            sizeof(g_NoClip) },
    { SECTION_RENDER,      "Offscreen",       epitBool,    &g_Offscreen,         sizeof(g_Offscreen) },
    { SECTION_RENDER,      "TextColor",       epitColor,   &g_TextColor,         sizeof(g_TextColor) },
    { SECTION_RENDER,      "BackColor",       epitColor,   &g_BackColor,         sizeof(g_BackColor) },
    { SECTION_AUTOFONTS,   "NumFonts",        epitInt,     &g_iAutoFonts,        sizeof(g_iAutoFonts) },
    { SECTION_AUTOHEIGHTS, "NumHeights",      epitInt,     &g_iAutoHeights,      sizeof(g_iAutoHeights) },
    { SECTION_DRIVERSTRING,"CMapLookup",      epitBool,    &g_CMapLookup,        sizeof(g_CMapLookup) },
    { SECTION_DRIVERSTRING,"Vertical",        epitBool,    &g_Vertical,          sizeof(g_Vertical) },
    { SECTION_DRIVERSTRING,"RealizedAdvance", epitBool,    &g_RealizedAdvance,   sizeof(g_RealizedAdvance) },
    { SECTION_DRIVERSTRING,"CompensateRes",   epitBool,    &g_CompensateRes,     sizeof(g_CompensateRes) },

    { "INVALID"           "INVALID",       epitInvalid, NULL,                 0 }
};

////////////////////////////////////////////////////////////////////////////////////////
// Routine to read the specified profile file (full-path required) and set the variables
// defined in the above table based on the results.
////////////////////////////////////////////////////////////////////////////////////////

void ReadProfileInfo(char *szProfileFile)
{
    int iProfile =0;
    int iRead = 0;
    char szValue[PROFILEVALUEMAX];

    if (!szProfileFile)
        return;

    // Loop through the table of profile information...
    while(g_rgProfileInfo[iProfile].pvVariable != NULL)
    {
        void *pvValue = g_rgProfileInfo[iProfile].pvVariable;
        DWORD dwValueLength = g_rgProfileInfo[iProfile].dwVariableLength;

        // Read the profile string
        iRead = ::GetPrivateProfileStringA(
            g_rgProfileInfo[iProfile].szSection,
            g_rgProfileInfo[iProfile].szVariable,
            NULL,
            szValue,
            sizeof(szValue),
            szProfileFile);

        if (iRead > 0)
        {
            // Convert the string value to the proper variable type based on
            // the specified type in the table of profile information...
            switch(g_rgProfileInfo[iProfile].type)
            {
                case epitInvalid :
                {
                    ASSERT(0);
                }
                break;

                case epitBool :
                {
                    ASSERT(dwValueLength == sizeof(BOOL));

                    // Only look at the first character for boolean values...
                    if (szValue[0] == 'Y' || szValue[0] == 'y' || szValue[0] == 'T' || szValue[0] == 't' || szValue[0] == '1')
                    {
                        *((BOOL *)pvValue) = true;
                    }
                    else
                    {
                        *((BOOL *)pvValue) = false;
                    }
                }
                break;

                case epitInt :
                {
                    ASSERT(dwValueLength == sizeof(int));

                    // Just use atoi here - strips whitespace and supports negative numbers...
                    int iValue = atoi(szValue);

                    *((int *)pvValue) = iValue;
                }
                break;

                case epitFloat :
                {
                    ASSERT(dwValueLength == sizeof(float));

                    // Just use atof here - strips whitespace...
                    float fltValue = (float)atof(szValue);

                    *((float *)pvValue) = fltValue;
                }
                break;

                case epitDouble :
                {
                    ASSERT(dwValueLength == sizeof(double));

                    // Just use atof here - strips whitespace...
                    double dblValue = atof(szValue);

                    *((double *)pvValue) = dblValue;
                }
                break;

                case epitString :
                {
                    // Just use strncpy. NOTE : Truncates if necessary and does NOT support full UNICODE
                    strncpy((char *)pvValue, szValue, dwValueLength);
                }
                break;

                case epitColor :
                {
                    // We will only handle HEX color values here:
                    int i;
                    ARGB color = 0;

                    for(i=0;i<8;i++)
                    {
                        if (szValue[i] == 0)
							break;
						
						// move along...
                        color <<= 4;

                        if (szValue[i] >= '0' && szValue[i] <= '9')
                        {
                            color += szValue[i] - '0';
                        }
                        else if (szValue[i] >='a' && szValue[i] <= 'f')
                        {
                            color += (szValue[i] - 'a') + 10;
                        }
                        else if (szValue[i] >='A' && szValue[i] <= 'F')
                        {
                            color += (szValue[i] - 'A') + 10;
                        }
                    }

                    *((ARGB *)pvValue) = color;
                }
                break;

                case epitAlign :
                {
                    ASSERT(dwValueLength == sizeof(StringAlignment));

                    switch(szValue[0])
                    {
                        case 'n' :
                        case 'N' :
                        {
                            // Near Alignment (left or top for US English)
                            *((StringAlignment *)pvValue) = StringAlignmentNear;
                        }
                        break;

                        case 'c' :
                        case 'C' :
                        {
                            // Center Alignment
                            *((StringAlignment *)pvValue) = StringAlignmentCenter;
                        }
                        break;

                        case 'F' :
                        case 'f' :
                        {
                            // Far Alignment (right or bottom for US English)
                            *((StringAlignment *)pvValue) = StringAlignmentFar;
                        }
                        break;
                    }
                }
                break;
            }
        }

        iProfile++;
    }

    // Get the enumerated fonts list (if any)
    if (g_AutoFont)
    {
        int iFont = 0;

        if (g_iAutoFonts > MAX_AUTO_FONTS)
            g_iAutoFonts = MAX_AUTO_FONTS;

        for(iFont=0;iFont<g_iAutoFonts;iFont++)
        {
            char szFontIndex[MAX_PATH];
            char szValue[MAX_PATH];

            wsprintfA(szFontIndex, "Font%d", iFont+1);

            // Read the profile string
            ::GetPrivateProfileStringA(
                SECTION_AUTOFONTS,
                szFontIndex,
                NULL,
                szValue,
                sizeof(g_rgszAutoFontFacenames[iFont]),
                szProfileFile);

#ifdef UNICODE
                    MultiByteToWideChar( CP_ACP,
                                         0,
                                         szValue,
                                         -1,
                                         g_rgszAutoFontFacenames[iFont],
                                         lstrlenA(szValue) );
#else
                        strcpy(g_rgszAutoFontFacenames[iFont], szValue);
#endif

        }
    }

    // Get the enumerated font heights (if any)
    if (g_AutoHeight)
    {
        int iHeight = 0;

        if (g_iAutoHeights > MAX_AUTO_HEIGHTS)
            g_iAutoHeights = MAX_AUTO_HEIGHTS;

        for(iHeight=0;iHeight<g_iAutoHeights;iHeight++)
        {
            char szHeightIndex[MAX_PATH];
            char szValue[MAX_PATH];

            wsprintfA(szHeightIndex, "Height%d", iHeight+1);

            // Read the profile string
            ::GetPrivateProfileStringA(
                SECTION_AUTOHEIGHTS,
                szHeightIndex,
                NULL,
                szValue,
                sizeof(szValue),
                szProfileFile);

            g_rgiAutoHeights[iHeight] = atoi(szValue);
        }
    }

    // Combine various booleans into proper bit-flags
    g_DriverOptions =
        (g_CMapLookup      ? DriverStringOptionsCmapLookup           : 0) |
        (g_Vertical        ? DriverStringOptionsVertical             : 0) |
        (g_RealizedAdvance ? DriverStringOptionsRealizedAdvance      : 0)
    ;

    g_formatFlags =
        (g_NoFitBB         ? StringFormatFlagsNoFitBlackBox     : 0) |
        (g_NoWrap          ? StringFormatFlagsNoWrap            : 0) |
        (g_NoClip          ? StringFormatFlagsNoClip            : 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\texttest\style.cpp ===
////    Style - simple character styles for formatted text
//
//      Provides a simple style selection mechanism for demostrating
//      formatted text.


#include "precomp.hxx"
#include "global.h"
#include <tchar.h>






/*
void SetLogFont(
    PLOGFONTA   plf,
    int         iHeight,
    int         iWeight,
    int         iItalic,
    int         iUnderline,
    char       *pcFaceName) {

    memset(plf, 0, sizeof(LOGFONTA));
    plf->lfCharSet        = DEFAULT_CHARSET;
    plf->lfHeight         = iHeight;
    plf->lfWeight         = iWeight;
    plf->lfItalic         = (BYTE) iItalic;
    plf->lfUnderline      = (BYTE) iUnderline;
    lstrcpy(plf->lfFaceName, pcFaceName);
    plf->lfOutPrecision   = OUT_STROKE_PRECIS;
    plf->lfClipPrecision  = CLIP_STROKE_PRECIS;
    plf->lfQuality        = DRAFT_QUALITY;
    plf->lfPitchAndFamily = VARIABLE_PITCH;
    plf->lfEscapement     = 0;
    plf->lfOrientation    = 0;
}
*/





void FreeStyle(int iStyle) {

    /*
    if (g_style[iStyle].hf) {
        DeleteObject(g_style[iStyle].hf);
    }

    if (g_style[iStyle].sc) {
        ScriptFreeCache(&g_style[iStyle].sc);
    }
    */

}






void SetStyle(
    int     iStyle,
    int     iHeight,
    int     iWeight,
    int     iItalic,
    int     iUnderline,
    int     iStrikeout,
    TCHAR   *pcFaceName) {

    LOGFONTA lf;

    FreeStyle(iStyle);

    //SetLogFont(&lf, iHeight, iWeight, iItalic, iUnderline, pcFaceName);
    //g_style[iStyle].hf = CreateFontIndirect(&lf);
    //g_style[iStyle].sc = NULL;

    g_style[iStyle].emSize = REAL(iHeight);
    for (UINT i=0; i<_tcslen(pcFaceName); i++)
    {
        g_style[iStyle].faceName[i] = pcFaceName[i];
    }
    g_style[iStyle].faceName[_tcslen(pcFaceName)] = 0;
    g_style[iStyle].style =
            (iWeight >= 700 ? FontStyleBold      : 0)
        +   (iItalic        ? FontStyleItalic    : 0)
        +   (iUnderline     ? FontStyleUnderline : 0)
        +   (iStrikeout     ? FontStyleStrikeout : 0);
}






void InitStyles() {

    memset(g_style, 0, sizeof(g_style));
}






void FreeStyles() {
    int i;
    for (i=0; i<5; i++) {
        FreeStyle(i);
    }
}





////    StyleCheckRange - dir use in ASSERTs
//
//      Returns TRUE if style length matches text length


BOOL StyleCheckRange() {

    int     iFormatPos;
    RUN    *pFormatRider;

    // Check that style length is same as text length

    pFormatRider = g_pFirstFormatRun;
    iFormatPos = 0;
    while (pFormatRider != NULL) {

        iFormatPos += pFormatRider->iLen;
        pFormatRider = pFormatRider->pNext;
    }

    return iFormatPos == g_iTextLen;
}







/////   Style range manipulation
//
//      StyleDeleteRange
//      StyleExtendRange
//      StyleSetRange
//
//      The style list is a linked list of RUNs (see global.h) that
//      covers the entire text buffer.
//
//      Each run has a length, and a style number (an index to g_Style[])
//      (The analysis field in the run is not used by the style list.)
//
//      StyleDeleteRange and StyleExtendRange are called as part of text
//      insertion/deletion to maintain the style list.
//
//      StyleSetRange is called to change the style of the current selection
//      when the user clicks on one the of the numbered style buttons.






///     StyleDeleteRange - delete range of style information
//
//


void StyleDeleteRange(
    int     iDelPos,
    int     iDelLen) {


    int     iFormatPos;
    RUN    *pFormatRider;
    RUN    *pPrevRun;
    RUN    *pDelRun;            // Run to be deleted


    if (iDelLen <= 0) return;


    // Find first run affected by the deletion

    iFormatPos   = 0;
    pFormatRider = g_pFirstFormatRun;
    pPrevRun = NULL;
    while (iFormatPos + pFormatRider->iLen <= iDelPos) {
        iFormatPos  += pFormatRider->iLen;
        pPrevRun     = pFormatRider;
        pFormatRider = pFormatRider->pNext;
        ASSERT(pFormatRider);
    }



    // Delete from end of first run

    if (iDelPos + iDelLen  >  iFormatPos + pFormatRider->iLen) {

        // Delete all the way from iDelPos to the end of the first affected run

        iDelLen = iDelPos + iDelLen - (iFormatPos + pFormatRider->iLen);    // Amount that will remain to be deleted
        pFormatRider->iLen = iDelPos - iFormatPos;

    } else {

        // Deletion is entirely in the first affected run

        pFormatRider->iLen -= iDelLen;
        iDelLen = 0;
    }


    // First affected run now contains no range to be deleted
    // If it's empty, remove it, otherwise step over it

    if (pFormatRider->iLen == 0) {

        // Remove redundant run

        if (pFormatRider->pNext) {

            // Replace this run by the next one

            pDelRun       = pFormatRider->pNext;
            *pFormatRider = *pDelRun;                 // Copy content of next run over this one
            delete pDelRun;

        } else {

            // No runs following this one

            if (pPrevRun) {

                ASSERT(iDelLen == 0);
                delete pFormatRider;
                pPrevRun->pNext = NULL;

            } else {

                // No runs left at all

                ASSERT(iDelLen == 0);
                delete pFormatRider;
                g_pFirstFormatRun = NULL;
            }
        }

    } else {

        //  Current run now contains no text to be deleted, so advance to next run

        iFormatPos  += pFormatRider->iLen;
        pPrevRun     = pFormatRider;
        pFormatRider = pFormatRider->pNext;
    }


    // Delete from start of any remaining runs

    while (iDelLen > 0) {

        if (pFormatRider->iLen <= iDelLen) {

            // This entire run must go

            ASSERT(pFormatRider->pNext);
            iDelLen -= pFormatRider->iLen;
            pDelRun  = pFormatRider->pNext;
            *pFormatRider = *pDelRun;
            delete pDelRun;

        } else {

            // Last run is deleted in part only

            pFormatRider->iLen -= iDelLen;
            iDelLen = 0;
        }
    }


    // Check whether current run (which immediately follows deletion) can
    // now be collapsed into the previous run

    if (pPrevRun  &&  pFormatRider  &&  pPrevRun->iStyle == pFormatRider->iStyle) {

        pPrevRun->iLen += pFormatRider->iLen;
        pPrevRun->pNext = pFormatRider->pNext;
        delete pFormatRider;
    }
}






///     StyleExtendRange - Extend style immediately preceeding iPos by iLen characters
//
//


void StyleExtendRange(
    int     iExtPos,
    int     iExtLen) {

    int     iFormatPos;
    RUN    *pFormatRider;

    const SCRIPT_ANALYSIS nullAnalysis = {0};


    if (g_pFirstFormatRun == NULL) {

        // Starting from no text at all

        ASSERT(iExtPos == 0);

        g_pFirstFormatRun           = new RUN;
        g_pFirstFormatRun->iLen     = iExtLen;
        g_pFirstFormatRun->iStyle   = 1;
        g_pFirstFormatRun->pNext    = NULL;
        g_pFirstFormatRun->analysis = nullAnalysis;

    } else {

        // Find run containing character immediately prior to iExtPos

        iFormatPos = 0;
        pFormatRider = g_pFirstFormatRun;

        while (iFormatPos + pFormatRider->iLen < iExtPos) {
            iFormatPos += pFormatRider->iLen;
            pFormatRider = pFormatRider->pNext;
        }

        pFormatRider->iLen += iExtLen;

    }
}






////    StyleSetRange - Change style for a given range
//
//


void StyleSetRange(
    int    iSetStyle,
    int    iSetPos,
    int    iSetLen) {

    int     iFormatPos;
    RUN    *pFormatRider;
    RUN    *pNewRun;


    if (iSetLen <= 0) return;


    // Remove existing style for the range

    StyleDeleteRange(iSetPos, iSetLen);


    if (g_pFirstFormatRun == NULL) {

        // Replace style on entire text

        g_pFirstFormatRun = new RUN;
        g_pFirstFormatRun->pNext = NULL;
        g_pFirstFormatRun->iLen = iSetLen;
        g_pFirstFormatRun->iStyle = iSetStyle;

    } else {

        // Find first run affected by the change

        iFormatPos   = 0;
        pFormatRider = g_pFirstFormatRun;
        while (iFormatPos + pFormatRider->iLen < iSetPos) {
            iFormatPos  += pFormatRider->iLen;
            pFormatRider = pFormatRider->pNext;
            ASSERT(pFormatRider);
        }


        // New style starts after beginning of this run or at beginning of next run


        if (pFormatRider->iStyle == iSetStyle) {

            // Already the same style - just increase length

            pFormatRider->iLen += iSetLen;

        } else {

            if (iFormatPos + pFormatRider->iLen > iSetPos) {

                // New style is within this run
                // Split this run around the new run

                pNewRun = new RUN;          // Create second part of existing run
                *pNewRun = *pFormatRider;
                pNewRun->iLen      -= iSetPos - iFormatPos;
                pFormatRider->iLen  = iSetPos - iFormatPos;
                pFormatRider->pNext = pNewRun;

                pNewRun = new RUN;          // Create inserted run
                *pNewRun = *pFormatRider;
                pNewRun->iLen = iSetLen;
                pNewRun->iStyle = iSetStyle;
                pFormatRider->pNext = pNewRun;

            } else {

                // New style is between this run and the next run

                if (    pFormatRider->pNext
                    &&  pFormatRider->pNext->iStyle == iSetStyle) {

                    // New style is same as adjacent following run

                    pFormatRider->pNext->iLen += iSetLen;

                } else {

                    // Create new run between current run and next run

                    pNewRun = new RUN;
                    *pNewRun = *pFormatRider;
                    pNewRun->iStyle = iSetStyle;
                    pNewRun->iLen   = iSetLen;
                    pFormatRider->pNext = pNewRun;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\texttest\text.cpp ===
////    TEXTREP - Text representation
//
//      For this demonstration, text representation is rather simple


#include "precomp.hxx"
#include "global.h"

#include <tchar.h>




////    InitText - Initialise text buffer
//
//

void InitText(INT id) {

    HMODULE    hmod;
    HRSRC      hrsrc;
    HGLOBAL    hglob;
    WCHAR     *pwcIt;  // Initial text
    int        i;


    g_iTextLen = 0;

    hmod       = GetModuleHandle(NULL);
    hrsrc      = FindResource(hmod, MAKEINTRESOURCE(id), _TEXT("INITIALTEXT"));
    hglob      = LoadResource(hmod, hrsrc);
    g_iTextLen = SizeofResource(hmod, hrsrc) - 2;  // Remove leading byte order mark
    pwcIt      = (WCHAR*) LockResource(hglob);

    if (!hmod  ||  !hrsrc  ||  !hglob  ||  !pwcIt  ||  !g_iTextLen) {
        ASSERTS(hmod,    "GetModuleHandle(usptest.exe) failed");
        ASSERTS(hrsrc,   "FindResource(110, INITIALTEXT) failed");
        ASSERTS(hglob,   "LoadResource(110, INITIALTEXT) failed");
        ASSERTS(pwcIt,   "LockResource(110, INITIALTEXT) failed");
        ASSERTS(g_iTextLen, "INITIALTEXT length zero");

        g_iTextLen = 0;
    }

    if (g_iTextLen >= sizeof(g_wcBuf)) {
        g_iTextLen = sizeof(g_wcBuf);
    }

    memcpy(g_wcBuf, pwcIt+1, g_iTextLen);
    g_iTextLen >>= 1;  // Bytes to characters

    // Drop any zero padding

    i = 0;
    while (    (i < g_iTextLen)
           &&  g_wcBuf[i]) {
        i++;
    }
    g_iTextLen = i;


    // Construct initial formatting style run covering the entire text

    StyleExtendRange(0, g_iTextLen);
    ASSERT(StyleCheckRange());
}






////    textDelete - Delete text from buffer
//


BOOL TextDelete(int iPos, int iLen) {

    if (   iPos < 0
        || iLen < 0
        || iPos +iLen > g_iTextLen) {
        return FALSE;
    }


    if (iPos + iLen >= g_iTextLen) {
        g_iTextLen = iPos;
        StyleDeleteRange(iPos, iLen);
        ASSERT(StyleCheckRange());
        return TRUE;
    }


    if (iLen == 0) {
        return TRUE;
    }



    memcpy(g_wcBuf + iPos, g_wcBuf + iPos + iLen, sizeof(WCHAR) * (g_iTextLen - (iPos + iLen)));
    g_iTextLen -= iLen;


    StyleDeleteRange(iPos, iLen);
    ASSERT(StyleCheckRange());

    return TRUE;
}






////    textInsert - Insert new characters in the buffer at the given insertion point
//


BOOL TextInsert(int iPos, PWCH pwc, int iLen) {

    if (   iPos < 0
        || iLen < 0
        || iPos + iLen >= MAX_TEXT
        || iPos > g_iTextLen) {
        return FALSE;
    }


    // Shift text above iPos up the buffer

    if (iPos < g_iTextLen) {
        memmove(g_wcBuf+iPos+iLen, g_wcBuf+iPos, sizeof(WCHAR)*(g_iTextLen-iPos));
    }


    // Copy new text into buffer

    memcpy(g_wcBuf+iPos, pwc, sizeof(WCHAR)*iLen);
    g_iTextLen += iLen;


    // Give the new characters the same style as the original character they follow

    StyleExtendRange(iPos, iLen);
    ASSERT(StyleCheckRange());


    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\warpdemo\resource.h ===
#define IDM_MAINMENU            1000
#define     IDC_TOGGLEMESH      1001
#define     IDC_RESETMESH       1002
#define     IDC_SHRINKTOFIT     1003
#define     IDC_DENSEMESH       1004
#define     IDC_SPARSEMESH      1005
#define     IDC_LIVEFEEDBACK    1006
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\texttest\texttest.cpp ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright  1994-1998  Microsoft Corporation.  All Rights Reserved.
//
// PROGRAM:    CSSAMP
//
// PURPOSE:    Demonstrate and test Uniscribe APIs
//
// PLATFORMS:  Windows 95, 98, NT 4, NT 5.
//


#include "precomp.hxx"

#define GLOBALS_HERE 1
#include "global.h"

#include "..\gpinit.inc"

//#define ICECAP 1 // Since this isn't defined for some reason automatically

#ifdef ICECAP
#include "icecap.h"
#endif // ICECAP


/* Testing

Font* ConstructFontWithCellHeight(
    const WCHAR *familyName,
    INT          style,
    REAL         cellHeight,   // From positive LOGFONT.lfHeight
    Unit         unit
)
{
    // Get the family details so we can do height arithmetic

    const FontFamily family(familyName);
    if (!family.IsStyleAvailable(style))
    {
        return NULL;
    }


    // Convert cell height to em height

    REAL emSize =     cellHeight * family.GetEmHeight(style)
                  /   (   family.GetCellAscent(style)
                       +  family.GetCellDescent(style));

    return new Font(&family, emSize, style, unit);
}



*/



// Check to see if a given pathname contains a path or not...
BOOL HasPath(char *szPathName)
{
    BOOL fResult = false;

    ASSERT(szPathName);

    if (!szPathName)
        return fResult;

    char *p = szPathName;

    while(*p)
    {
        if (*p == '\\')
        {
                // We found a backslash - we have a path
                fResult = true;
                break;
        }
        p++;
    }

    return fResult;
}

// Strip any filename (and final backslash) from a pathname
void StripFilename(char *szPathName)
{
    ASSERT(szPathName);

    if (szPathName)
    {
        char *p = szPathName + (strlen(szPathName)-1);
    
        while(p > szPathName)
        {
            if (*p == '\\')
            {
                    // Terminate the string at the first backslash.
                    *p = 0;
                    break;
            }
            p--;
        }
    }
}



////    Initialise
//


void Initialise()
{
    INITCOMMONCONTROLSEX icce;
    icce.dwSize = sizeof(icce);
    icce.dwICC  = ICC_BAR_CLASSES;

    InitCommonControlsEx(&icce);
    InitStyles();
    InitText(ID_INITIAL_TEXT);

    g_familyCount = g_InstalledFontCollection.GetFamilyCount();
    g_families    = new FontFamily[g_familyCount];
    g_InstalledFontCollection.GetFamilies(g_familyCount, g_families, &g_familyCount);

    // Default values...
    g_szSourceTextFile[0] = 0;
    g_szProfileName[0] = 0;

    // Generate the application base directory...
    GetModuleFileNameA(g_hInstance, g_szAppDir, sizeof(g_szAppDir));
    StripFilename(g_szAppDir);
}


// Parse the command line...
void ParseCommandLine(char *szCmdLine)
{
    char *p = szCmdLine;

    // Look for a -p...
    while(*p)
    {
        switch (*p)
        {
            case '-' :
            case '/' :
            {
                // we have a command, so figure out what it is...
                p++; // next char indicate which command...

                switch(*p)
                {
                    case 'p' :
                    case 'P' :
                    {
                        char szProfileName[MAX_PATH];
                        int i = 0;

                        // Profile filename follows immediately (no spaces)
                        p++; // skip the 'p'

                        while(*p && *p != '\b')
                        {
                            szProfileName[i] = *p;
                            i++;
                            p++;
                        }

                        // Terminate the string...
                        szProfileName[i] = 0;

                        if (strlen(szProfileName) > 0)
                        {
                               if (!HasPath(szProfileName))
                               {
                                   // Look for the profile file in the application directory
                                   wsprintfA(g_szProfileName, "%s\\%s", g_szAppDir, szProfileName);
                               }
                               else
                               {
                                   // Otherwise it already contains a path
                                   strcpy(g_szProfileName, szProfileName);
                               }
                        }
                    }
                    break;
                }
            }
            break;

            default :
            break;
        }

        p++;
    }
}


////    WinMain - Application entry point and dispatch loop
//
//


int APIENTRY WinMain(
    HINSTANCE   hInst,
    HINSTANCE   hPrevInstance,
    char       *pCmdLine,
    int         nCmdShow) {

    MSG         msg;
    HACCEL      hAccelTable;
    RECT        rc;
    RECT        rcMain;
    int iNumRenders = 1;

    if (!gGdiplusInitHelper.IsValid())
    {
        return 0;
    }

    g_hInstance = hInst;  // Global hInstance

#ifdef ICECAP
    // Mark the profile...
    StopProfile(PROFILE_GLOBALLEVEL, PROFILE_CURRENTID);
#endif // ICECAP

    Initialise();

    // Parse the command line...
    ParseCommandLine(pCmdLine);

    // Read the global settings from the profile...
    ReadProfileInfo(g_szProfileName);

    // Over-ride number of renders on initial display...
    iNumRenders = g_iNumRenders;
    g_iNumRenders = 1;

    // It is possible that we want to use a file for the default text, so try to load it
    if (lstrlenA(g_szSourceTextFile) > 0)
    {
        char szFullPathText[MAX_PATH];

        if (!HasPath(g_szSourceTextFile))
        {
            // Look for the source text file in the application directory
            wsprintfA(szFullPathText, "%s\\%s", g_szAppDir, g_szSourceTextFile);
        }
        else
        {
            // Otherwise it contains a path already
            strcpy(szFullPathText, g_szSourceTextFile);
        }

        // This will replace the initial text with the text from the file
        InsertText(NULL, szFullPathText);
    }
     
    // Create main text window

    g_hTextWnd = CreateTextWindow();


    // Add dialog boxes on leading side

    g_hSettingsDlg = CreateDialogA(
        g_hInstance,
        "Settings",
        g_hTextWnd,
        SettingsDlgProc);


    g_hGlyphSettingsDlg = CreateDialogA(
        g_hInstance,
        "GlyphSettings",
        g_hTextWnd,
        GlyphSettingsDlgProc);


    g_hDriverSettingsDlg = CreateDialogA(
        g_hInstance,
        "DriverSettings",
        g_hTextWnd,
        DriverSettingsDlgProc);


    // Establish positon of text surface relative to the dialog

    GetWindowRect(g_hSettingsDlg, &rc);

    g_iSettingsWidth = rc.right - rc.left;
    g_iSettingsHeight = rc.bottom - rc.top;

    // Establish offset from main window to settings dialog

    GetWindowRect(g_hTextWnd, &rcMain);
    g_iMinWidth = rc.right - rcMain.left;
    g_iMinHeight = rc.bottom - rcMain.top;



    // Size main window to include dialog and text surface

    SetWindowPos(
        g_hTextWnd,
        NULL,
        0,0,
        g_iMinWidth * 29 / 10, g_iMinHeight,
        SWP_NOZORDER | SWP_NOMOVE);

    // Position the sub dialogs below the main dialog

    SetWindowPos(
        g_hGlyphSettingsDlg,
        NULL,
        0, rc.bottom-rc.top,
        0,0,
        SWP_NOZORDER | SWP_NOSIZE);

    SetWindowPos(
        g_hDriverSettingsDlg,
        NULL,
        0, rc.bottom-rc.top,
        0,0,
        SWP_NOZORDER | SWP_NOSIZE);

    if (g_FontOverride)
    {
        // Update the styles with the values read from the profile...
        for(int iStyle=0;iStyle<5;iStyle++)
        {
            SetStyle(
                iStyle,
                g_iFontHeight,
                g_Bold ? 700 : 300,
                g_Italic ? 1 : 0,
                g_Underline ? 1 : 0,
                g_Strikeout ? 1 : 0,
                g_szFaceName);
        }
    }

    if (g_AutoDrive)
    {
        int iFont = 0;
        int iHeight = 0;
        int cFonts = 1;
        int cHeights = 1;
        int iIteration = 0;
        int iRepeatPaint = 0;
        int iStyle = 0;

        g_fPresentation = true;

        // Move the settings window out of the way...
        ShowWindow(g_hTextWnd, SW_SHOWNORMAL);
        SetWindowPos(g_hSettingsDlg, HWND_BOTTOM, -g_iSettingsWidth, 0, g_iSettingsWidth, g_iSettingsHeight, SWP_NOREDRAW);
        UpdateWindow(g_hSettingsDlg);

        // Initial Paint to setup font cache...
        InvalidateText();
        UpdateWindow(g_hTextWnd);

        // Reset the render multiplier...
        g_iNumRenders = iNumRenders;

#ifdef ICECAP
        // Start the profiling...
        StartProfile(PROFILE_GLOBALLEVEL, PROFILE_CURRENTID);
#endif // ICECAP

        if (g_AutoFont)
            cFonts = g_iAutoFonts;

        if (g_AutoHeight)
            cHeights = g_iAutoHeights;

        for(iIteration = 0;iIteration < g_iNumIterations; iIteration++)
        {
            for(iFont=0;iFont<cFonts;iFont++)
            {
                for(iHeight=0;iHeight<cHeights;iHeight++)
                {
                    TCHAR szFaceName[MAX_PATH];
                    int iFontHeight = g_iFontHeight;
    
                    if (g_AutoFont)
                    {
                        lstrcpy(szFaceName, g_rgszAutoFontFacenames[iFont]);
                    }
                    else
                    {
                        lstrcpy(szFaceName, g_szFaceName);
                    }
    
                    if (g_AutoHeight)
                        iFontHeight = g_rgiAutoHeights[iHeight];
    
                    // Update the styles with the values read from the profile...
                    for(int iStyle=0;iStyle<5;iStyle++)
                    {
                        SetStyle(
                            iStyle,
                            iFontHeight,
                            g_Bold ? 700 : 300,
                            g_Italic ? 1 : 0,
                            g_Underline ? 1 : 0,
                            g_Strikeout ? 1 : 0,
                            szFaceName);
                    }

                    for(int iPaint=0;iPaint<g_iNumRepaints;iPaint++)
                    {
                        // Force a re-display of the entire text window...
                        InvalidateText();
                        UpdateWindow(g_hTextWnd);
                    }
                }
            }
        }

#ifdef ICECAP
        // Stop the profiling...
        StopProfile(PROFILE_GLOBALLEVEL, PROFILE_CURRENTID);
#endif // ICECAP

        // Trigger application exit
        PostMessage(g_hTextWnd, WM_DESTROY, (WPARAM)0, (LPARAM)0);
    }
    else
    {
        ShowWindow(g_hTextWnd, SW_SHOWNORMAL);

        InvalidateText();
        UpdateWindow(g_hTextWnd);
    }


    // Main message loop

    if (g_bUnicodeWnd) {

        hAccelTable = LoadAcceleratorsW(g_hInstance, APPNAMEW);

        while (GetMessageW(&msg, (HWND) NULL, 0, 0) > 0) {

            if (    !IsDialogMessageW(g_hSettingsDlg, &msg)
                &&  !IsDialogMessageW(g_hGlyphSettingsDlg, &msg)
                &&  !TranslateAcceleratorW(g_hTextWnd, hAccelTable, &msg))
            {
                TranslateMessage(&msg);
                DispatchMessageW(&msg);
            }
        }

    } else {

        hAccelTable = LoadAcceleratorsA(g_hInstance, APPNAMEA);

        while (GetMessageA(&msg, (HWND) NULL, 0, 0) > 0) {

            if (    !IsDialogMessageA(g_hSettingsDlg, &msg)
                &&  !IsDialogMessageA(g_hGlyphSettingsDlg, &msg)
                &&  !TranslateAcceleratorA(g_hTextWnd, hAccelTable, &msg)
                )
            {
                TranslateMessage(&msg);
                DispatchMessageA(&msg);
            }
        }
    }


    FreeStyles();

    delete [] g_families;

    return (int)msg.wParam;

    UNREFERENCED_PARAMETER(hPrevInstance);
    UNREFERENCED_PARAMETER(pCmdLine);
    UNREFERENCED_PARAMETER(nCmdShow);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\texttest\textwnd.cpp ===
////    TEXTWND.CPP
//
//              Maintains the text display panel



#include "precomp.hxx"
#include "global.h"
#include "winspool.h"
#include <Tchar.h>




////    InvalidateText - Force redisplay
//
//

void InvalidateText() {
    RECT rc;
    rc.left   = g_fPresentation ? 0 : g_iSettingsWidth;
    rc.top    = 0;
    rc.right  = 10000;
    rc.bottom = 10000;
    InvalidateRect(g_hTextWnd, &rc, TRUE);
}






////    Header - draw a simple header for each text section
//
//      Used to distinguish logical, plaintext and formatted text sections of
//      text window.
//
//      Advances SEPARATORHEIGHT drawing a horizontal line 2/5ths of the way
//      down, and displays a title below the line.
//
//      At the top of the page displays only the title.

void Header(HDC hdc, char* str, RECT *prc, int *piY) {

    HFONT hf;
    HFONT hfold;
    RECT  rcClear;

    int iLinePos;
    int iTextPos;
    int iFontEmHeight;
    int iHeight;

    int separatorHeight = (prc->bottom - prc->top) / 20;

    iFontEmHeight = separatorHeight*40/100;

    if (*piY <= prc->top)
    {
        // Prepare settings for title only, at top of window
        iLinePos = -1;
        iTextPos = 0;
        iHeight  = separatorHeight*60/100;

    }
    else
    {
        // Prepare settings for 40% white space, a line, 10% whitespace, text and 3% whitespace
        iLinePos = separatorHeight*30/100;
        iTextPos = separatorHeight*40/100;
        iHeight  = separatorHeight;
    }


    rcClear = *prc;
    rcClear.top = *piY;
    rcClear.bottom = *piY + iHeight;
    FillRect(hdc, &rcClear, (HBRUSH) GetStockObject(WHITE_BRUSH));


    if (*piY > prc->top) {

        // Separate from previous output with double pixel line

        MoveToEx(hdc, prc->left,  *piY+iLinePos, NULL);
        LineTo  (hdc, prc->right, *piY+iLinePos);
        MoveToEx(hdc, prc->left,  *piY+iLinePos+1, NULL);
        LineTo  (hdc, prc->right, *piY+iLinePos+1);
    }


    hf = CreateFontA(-iFontEmHeight, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, "Tahoma");
    hfold = (HFONT) SelectObject(hdc, hf);
    ExtTextOutA(hdc, prc->left, *piY + iTextPos, 0, prc, str, strlen(str), NULL);

    *piY += iHeight;

    SelectObject(hdc, hfold);
    DeleteObject(hf);
}






////    ResetCaret - used during paint by each DSP*.CPP
//
//


void ResetCaret(int iX, int iY, int iHeight) {

    g_iCaretX = iX;
    g_iCaretY = iY;

    if (g_iCaretHeight != iHeight) {
        g_iCaretHeight = iHeight;
        HideCaret(g_hTextWnd);
        DestroyCaret();
        CreateCaret(g_hTextWnd, NULL, 0, g_iCaretHeight);
        SetCaretPos(g_iCaretX, g_iCaretY);
        ShowCaret(g_hTextWnd);
    } else {
        SetCaretPos(g_iCaretX, g_iCaretY);
    }
}



/////   PaintDC - display all selected tests, either on screen
//      or on printer.

void PaintDC(HDC hdc, BOOL presentation, RECT &rcText, INT &iY)
{
    int   iPos;
    int   iLineHeight;

    iY = rcText.top;

    if (presentation) {
        iLineHeight = rcText.bottom*9/20;
    } else {
        iLineHeight = 40;
    }


    if (g_ShowGDI) {
        if (!presentation) {
            Header(hdc, "GDI", &rcText, &iY);
        }
        PaintGDI(hdc, &iY, &rcText, iLineHeight);
    }

    if (g_ShowFamilies) {
        if (!presentation) {
            Header(hdc, "Font families", &rcText, &iY);
        }
        PaintFamilies(hdc, &iY, &rcText, iLineHeight);
    }


    if (g_ShowLogical) {
        if (!presentation) {
            Header(hdc, "Logical characters (ScriptGetCmap, ExtTextOut(ETO_GLYPHINDEX))", &rcText, &iY);
        }
        PaintLogical(hdc, &iY, &rcText, iLineHeight);
    }


    if (g_ShowGlyphs) {
        if (!presentation) {
            Header(hdc, "DrawGlyphs", &rcText, &iY);
        }
        PaintGlyphs(hdc, &iY, &rcText, iLineHeight);
    }


    if (g_ShowDrawString) {
        if (!presentation) {
            Header(hdc, "DrawString", &rcText, &iY);
        }
        PaintDrawString(hdc, &iY, &rcText, iLineHeight);
    }


    if (g_ShowDriver) {
        if (!presentation) {
            Header(hdc, "DrawDriverString", &rcText, &iY);
        }
        PaintDrawDriverString(hdc, &iY, &rcText, iLineHeight);
    }


    if (g_ShowPath) {
        if (!presentation) {
            Header(hdc, "Path", &rcText, &iY);
        }
        PaintPath(hdc, &iY, &rcText, iLineHeight);
    }

    if (g_ShowMetric) {
        if (!presentation) {
            Header(hdc, "Metrics", &rcText, &iY);
        }
        PaintMetrics(hdc, &iY, &rcText, iLineHeight);
    }

    if (g_ShowPerformance) {
        if (!presentation) {
            Header(hdc, "Performance", &rcText, &iY);
        }
        PaintPerformance(hdc, &iY, &rcText, iLineHeight);
    }

    if (g_ShowScaling) {
        if (!presentation) {
            Header(hdc, "Scaling", &rcText, &iY);
        }
        PaintScaling(hdc, &iY, &rcText, iLineHeight);
    }


/*
    if (g_fShowFancyText  &&  !presentation) {
        Header(hdc, "Formatted text (ScriptItemize, ScriptLayout, ScriptShape, ScriptPlace, ScriptTextOut)", &rcText, &iY);
        PaintFormattedText(hdc, &iY, &rcText, iLineHeight);
    }
*/

}





////    Paint - redraw part or all of client area
//
//


void PaintWindow(HWND hWnd) {

    PAINTSTRUCT  ps;
    HDC          hdc;
    RECT         rcText;
    RECT         rcClear;
    int          iY;

    hdc = BeginPaint(hWnd, &ps);

    // Remove the settings dialog from the repaint rectangle


    if (ps.fErase) {

        // Clear below the settings dialog

        if (!g_fPresentation) {

            rcClear = ps.rcPaint;
            if (rcClear.right > g_iSettingsWidth) {
                rcClear.right = g_iSettingsWidth;
            }
            if (rcClear.top < g_iSettingsHeight) {
                rcClear.top = g_iSettingsHeight;
            }

            FillRect(ps.hdc, &rcClear, (HBRUSH) GetStockObject(WHITE_BRUSH));
        }
    }


    // Clear top and left margin

    GetClientRect(hWnd, &rcText);

    // Left margin

    rcClear = rcText;
    rcClear.left  = g_fPresentation ? 0 : g_iSettingsWidth;
    rcClear.right = rcClear.left + 10;
    FillRect(ps.hdc, &rcClear, (HBRUSH) GetStockObject(WHITE_BRUSH));


    // Top margin

    rcClear = rcText;
    rcClear.left  = g_fPresentation ? 0 : g_iSettingsWidth;
    rcClear.top = 0;
    rcClear.bottom = 8;
    FillRect(ps.hdc, &rcClear, (HBRUSH) GetStockObject(WHITE_BRUSH));

    rcText.left = g_fPresentation ? 10 : g_iSettingsWidth + 10;
    rcText.top  = 8;


    if (!g_Offscreen)
    {
        PaintDC(hdc, g_fPresentation, rcText, iY);
    }
    else
    {
        // Render everything to an offscreen buffer instead of
        // directly to the display surface...
        HBITMAP hbmpOffscreen = NULL;
        HDC hdcOffscreen = NULL;
        RECT rectOffscreen;

        rectOffscreen.left = 0;
        rectOffscreen.top = 0;
        rectOffscreen.right = rcText.right - rcText.left;
        rectOffscreen.bottom = rcText.bottom - rcText.top;

        hbmpOffscreen = CreateCompatibleBitmap(hdc, rectOffscreen.right, rectOffscreen.bottom);

        if (hbmpOffscreen)
        {
            hdcOffscreen = CreateCompatibleDC(hdc);

            if (hdcOffscreen)
            {
                HBITMAP hbmpOld = (HBITMAP)SelectObject(hdcOffscreen, hbmpOffscreen);

                PaintDC(hdcOffscreen, g_fPresentation, rectOffscreen, iY);

                StretchBlt(
                    hdc,
                    rcText.left,
                    rcText.top,
                    rectOffscreen.right,
                    rectOffscreen.bottom,
                    hdcOffscreen,
                    0,
                    0,
                    rectOffscreen.right,
                    rectOffscreen.bottom,
                    SRCCOPY);

                SelectObject(hdcOffscreen, (HGDIOBJ)hbmpOld);

                DeleteDC(hdcOffscreen);
            }

            DeleteObject(hbmpOffscreen);
        }
    }

    // Clear any remaining space below the text

    if (    ps.fErase
        &&  iY < rcText.bottom) {

        rcClear = rcText;
        rcClear.top = iY;
        FillRect(ps.hdc, &rcClear, (HBRUSH) GetStockObject(WHITE_BRUSH));
    }


    EndPaint(hWnd, &ps);
}



void PrintPage()
{
    PRINTDLG printDialog;

    memset(&printDialog, 0, sizeof(printDialog));

    printDialog.lStructSize = sizeof(printDialog);
    printDialog.Flags = PD_RETURNDC | PD_NOPAGENUMS | PD_NOSELECTION ;

    if (PrintDlg(&printDialog))
    {
        HDC dc = printDialog.hDC;

        if (dc != NULL)
        {
            DOCINFO documentInfo;
            documentInfo.cbSize       = sizeof(documentInfo);
            documentInfo.lpszDocName  = _T("TextTest");
            documentInfo.lpszOutput   = NULL;
            documentInfo.lpszDatatype = NULL;
            documentInfo.fwType       = 0;

            if (StartDoc(dc, &documentInfo))
            {
                if (StartPage(dc) > 0)
                {
                    RECT rcText;
                    INT  iY;

                    rcText.left   = 0;
                    rcText.top    = 0;
                    rcText.right  = GetDeviceCaps(dc, HORZRES);
                    rcText.bottom = GetDeviceCaps(dc, VERTRES);

                    PaintDC(dc, FALSE, rcText, iY);
                    EndPage(dc);
                }

                EndDoc(dc);
            }

            DeleteDC(dc);
        }
    }
}




////    TextWndProc - Main window message handler and dispatcher
//
//


LRESULT CALLBACK TextWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) {

    HDC hdc;

    switch (message) {

        case WM_CREATE:
            hdc = GetDC(hWnd);
            g_iLogPixelsY = GetDeviceCaps(hdc, LOGPIXELSY);
            ReleaseDC(hWnd, hdc);
            break;


        case WM_ERASEBKGND:
            return 0;       // Leave Paint to erase the background


        case WM_CHAR:

            if (!g_bUnicodeWnd) {

                // Convert ANSI keyboard data to Unicode

                int   iCP;

                switch (PRIMARYLANGID(LOWORD(GetKeyboardLayout(NULL)))) {
                    case LANG_ARABIC:   iCP = 1256;   break;
                    case LANG_HEBREW:   iCP = 1255;   break;
                    case LANG_THAI:     iCP =  874;   break;
                    default:            iCP = 1252;   break;
                }

                MultiByteToWideChar(iCP, 0, (char*)&wParam, 1, (WCHAR*)&wParam, 1);
            }

            if (LOWORD(wParam) == 0x1B) {

                // Exit presentation mode

                g_fPresentation = FALSE;
                ShowWindow(g_hSettingsDlg, SW_SHOW);
                UpdateWindow(g_hSettingsDlg);
                InvalidateText();

            } else {

                EditChar(LOWORD(wParam));
            }

            break;


        case WM_KEYDOWN:
            EditKeyDown(LOWORD(wParam));
            break;


        case WM_KEYUP:

            if (wParam != VK_ESCAPE) {
                goto DefaultWindowProcedure;
            }
            // Eat all escape key processing
            break;


        case WM_LBUTTONDOWN:
            g_iMouseDownX = LOWORD(lParam);  // horizontal position of cursor
            g_iMouseDownY = HIWORD(lParam);  // vertical position of cursor
            g_fMouseDown  = TRUE;
            SetFocus(hWnd);
            break;

        case WM_MOUSEMOVE:
            // Treat movement like lbuttonup while lbutton is down,
            // so the selection tracks the cursor movement.
            if (wParam & MK_LBUTTON) {
                g_iMouseUpX = LOWORD(lParam);  // horizontal position of cursor
                g_iMouseUpY = HIWORD(lParam);  // vertical position of cursor
                g_fMouseUp = TRUE;
                InvalidateText();
                SetActiveWindow(hWnd);
            }
            break;


        case WM_LBUTTONUP:
            g_iMouseUpX = LOWORD(lParam);  // horizontal position of cursor
            g_iMouseUpY = HIWORD(lParam);  // vertical position of cursor
            g_fMouseUp = TRUE;
            InvalidateText();
            SetActiveWindow(hWnd);
            break;


        case WM_SETFOCUS:
            CreateCaret(hWnd, NULL, 0, g_iCaretHeight);
            SetCaretPos(g_iCaretX, g_iCaretY);
            ShowCaret(hWnd);
            break;


        case WM_KILLFOCUS:
            DestroyCaret();
            break;


        case WM_GETMINMAXINFO:

            // Don't let text window size drop too low

            ((LPMINMAXINFO)lParam)->ptMinTrackSize.x = g_fPresentation ? 10 : g_iMinWidth;
            ((LPMINMAXINFO)lParam)->ptMinTrackSize.y = g_fPresentation ? 10 : g_iMinHeight;
            return 0;


        case WM_PAINT:
            PaintWindow(hWnd);
            break;

        case WM_DESTROY:
            if (g_textBrush)
                delete g_textBrush;

            if (g_textBackBrush)
                delete g_textBackBrush;

            DestroyWindow(g_hSettingsDlg);
            PostQuitMessage(0);
            return 0;

        default:
        DefaultWindowProcedure:
            if (g_bUnicodeWnd) {
                return DefWindowProcW(hWnd, message, wParam, lParam);
            } else {
                return DefWindowProcA(hWnd, message, wParam, lParam);
            }
    }

    return 0;
}






////    CreateTextWindow - create window class and window
//
//      Attempts to use a Unicode window, if this fails uses an ANSI
//      window.
//
//      For example the Unicode window will succeed on Windows NT and
//      Windows CE, but fail on Windows 9x.


HWND CreateTextWindow() {

    WNDCLASSA  wcA;
    WNDCLASSW  wcW;
    HWND       hWnd;

    // Try registering as a Unicode window

    wcW.style         = CS_HREDRAW | CS_VREDRAW;
    wcW.lpfnWndProc   = TextWndProc;
    wcW.cbClsExtra    = 0;
    wcW.cbWndExtra    = 0;
    wcW.hInstance     = g_hInstance;
    wcW.hIcon         = LoadIconW(g_hInstance, APPNAMEW);
    wcW.hCursor       = LoadCursorW(NULL, (WCHAR*)IDC_ARROW);
    wcW.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
    wcW.lpszMenuName  = APPNAMEW;
    wcW.lpszClassName = APPNAMEW;

    if (RegisterClassW(&wcW)) {

        // Use a Unicode window

        g_bUnicodeWnd = TRUE;

        hWnd  = CreateWindowW(
            APPNAMEW, APPTITLEW,
            WS_OVERLAPPEDWINDOW,
            CW_USEDEFAULT, 0,
            CW_USEDEFAULT, 0,
            NULL, NULL,
            g_hInstance,
            NULL);


        return hWnd;

    } else {

        // Must use an ANSI window.

        wcA.style         = CS_HREDRAW | CS_VREDRAW;
        wcA.lpfnWndProc   = TextWndProc;
        wcA.cbClsExtra    = 0;
        wcA.cbWndExtra    = 0;
        wcA.hInstance     = g_hInstance;
        wcA.hIcon         = LoadIconA(g_hInstance, APPNAMEA);
        wcA.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wcA.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
        wcA.lpszMenuName  = APPNAMEA;
        wcA.lpszClassName = APPNAMEA;

        if (!RegisterClassA(&wcA)) {
            return NULL;
        }

        g_bUnicodeWnd = FALSE;

        hWnd  = CreateWindowA(
            APPNAMEA, APPTITLEA,
            WS_OVERLAPPEDWINDOW,
            CW_USEDEFAULT, 0,
            CW_USEDEFAULT, 0,
            NULL, NULL,
            g_hInstance,
            NULL);
    };


    return hWnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\warpdemo\resample.cxx ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   resample.cxx
*
* Abstract:
*
*   1-dimensional image resampling
*
* Revision History:
*
*   01/18/1999 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hxx"

VOID
Resample1D(
    VOID* src,
    INT srccnt,
    VOID* dst,
    INT dstcnt,
    INT pixstride,
    double* outpos
    )

{
    static double* inpos = NULL;
    static int inposLen = 0;

    // allocate working memory

    if (inposLen < dstcnt+2)
    {
        inposLen = dstcnt+2;

        inpos = (double*) realloc(inpos, inposLen*sizeof(double));

        if (inpos == NULL)
            Error("Out of memory\n");
        
        memset(inpos, 0, inposLen*sizeof(double));
    }

    // we only deal with 32-bit RGB pixel

    if (PIXELSIZE != sizeof(DWORD))
        Error("Resample1D can only handle 32bit pixel\n");

    DWORD* in = (DWORD*) src;
    DWORD* out = (DWORD*) dst;
    pixstride /= sizeof(DWORD);

    INT u, x;
    double accB, intensityB,
           accG, intensityG,
           accR, intensityR;
    double insfac, inseg, outseg;

    for (u=x=0; x < dstcnt; x++)
    {
        while (outpos[u+1] < x)
            u++;

        inpos[x] = u + (x-outpos[u]) / (outpos[u+1] - outpos[u]);
    }

    inpos[dstcnt] = srccnt;
    inseg = 1.0;
    outseg = inpos[1];
    insfac = outseg;
    accB = accG = accR = 0.0;

    for (x=0; x < dstcnt; )
    {
        DWORD pix0 = in[0];
        DWORD pix1;
        double rem;

        if (inseg == 1.0)
        {
            intensityB = (BYTE) (pix0      );
            intensityG = (BYTE) (pix0 >>  8);
            intensityR = (BYTE) (pix0 >> 16);
        }
        else
        {
            pix1 = in[pixstride];
            rem = 1.0 - inseg;

            intensityB = inseg * ((BYTE) (pix0      )) +
                           rem * ((BYTE) (pix1      ));
            intensityG = inseg * ((BYTE) (pix0 >>  8)) +
                           rem * ((BYTE) (pix1 >>  8));
            intensityR = inseg * ((BYTE) (pix0 >> 16)) +
                           rem * ((BYTE) (pix1 >> 16));
        }

        if (inseg < outseg)
        {
            accB += intensityB*inseg;
            accG += intensityG*inseg;
            accR += intensityR*inseg;

            outseg -= inseg;
            inseg = 1.0;
            in += pixstride;
        }
        else
        {
            DWORD r, g, b;

            insfac = 1.0 / insfac;
            b = (DWORD) ((accB + intensityB*outseg) * insfac);
            g = (DWORD) ((accG + intensityG*outseg) * insfac);
            r = (DWORD) ((accR + intensityR*outseg) * insfac);

            *out = ((b & 0xff)      ) |
                   ((g & 0xff) <<  8) |
                   ((r & 0xff) << 16);

            out += pixstride;
            x++;

            accB = accG = accR = 0.0;
            inseg -= outseg;
            outseg = insfac = inpos[x+1] - inpos[x];
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\warpdemo\warpdemo.cxx ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   warpdemo.cxx
*
* Abstract:
*
*   Image warping demo program
*
* Usage:
*   warpdemo bitmapfile
*
*   Keystrokes:
*       SPACE - show/hide mesh
*       r - reset mesh to default
*       1 - restore 1-to-1 scale
*       < - decrease mesh density
*       > - increase mesh density
*       f - toggle realtime feedback
*
* Revision History:
*
*   01/18/1999 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hxx"

CHAR* programName;          // program name
HINSTANCE appInstance;      // handle to the application instance
HWND hwndMain;              // handle to application's main window
SIZE srcSize;               // source bitmap size
PVOID srcBmpData;           // source bitmap data
INT srcStride;              // source scanline stride
SIZE dstSize;               // destination bitmap size
PVOID dstBmpData;           // destination bitmap data
INT dstStride;              // destination scanline stride
SIZE wndSizeExtra;          // extra pixels for window decorations
BOOL isDragging = FALSE;    // used to handle mouse dragging
INT dragRow, dragCol;       // the control knob being dragged
BOOL clearWarpCache;        // is the cached warping result valid?
BOOL liveFeedback = FALSE;  // realtime feedback while dragging mesh?
INT knobSize;               // mesh control point knob size

#define MIN_KNOB_SIZE       4
#define MAX_KNOB_SIZE       7

#define MIN_MESH_GRID       3
#define MAX_MESH_GRID       32
#define DEFAULT_MESH_GRID   9

INT meshGrids = DEFAULT_MESH_GRID;
Mesh* mesh = NULL;
BOOL showMesh = TRUE;

//
// Display an error message dialog and quit
//

VOID
Error(
    const CHAR* fmt,
    ...
    )

{
    va_list arglist;

    va_start(arglist, fmt);
    vfprintf(stderr, fmt, arglist);
    va_end(arglist);

    exit(-1);
}


//
// Create a new mesh object
//

VOID
CreateMesh()
{
    mesh = new Mesh(meshGrids, meshGrids);

    if (mesh == NULL)
        Error("Couldn't create Mesh object\n");

    clearWarpCache = TRUE;
}


//
// Calculate mesh control point knob size based
// on current window width and height and also
// the number of mesh grids.
//

VOID
CalcKnobSize(
    INT width,
    INT height
    )
{
    width /= (meshGrids-1);
    height /= (meshGrids-1);

    knobSize = min(width, height) / 5;

    if (knobSize < MIN_KNOB_SIZE)
        knobSize = MIN_KNOB_SIZE;
    else if (knobSize > MAX_KNOB_SIZE)
        knobSize = MAX_KNOB_SIZE;
}


//
// Perform image warping operation based on current mesh configuration
//

HDC hdcWarp = NULL;
HBITMAP hbmpWarp = NULL;

VOID
DoWarp(
    INT width,
    INT height
    )

{
    // Uncache any previous warping results

    if (hdcWarp)
        DeleteDC(hdcWarp);
    
    if (hbmpWarp)
        DeleteObject(hbmpWarp);

    // Create offscreen DC to cache warping results

    dstSize.cx = width;
    dstSize.cy = height;
    dstStride = ((width * PIXELSIZE) + 3) & ~3;

    BITMAPINFOHEADER header =
    {
        sizeof(header),
        dstSize.cx,
        -dstSize.cy,
        1,
        PIXELSIZE*8,
        BI_RGB,
    };

    hdcWarp = CreateCompatibleDC(NULL);

    hbmpWarp = CreateDIBSection(
                        NULL,
                        (BITMAPINFO*) &header,
                        DIB_RGB_COLORS,
                        &dstBmpData,
                        NULL,
                        0);

    if (!hdcWarp || !hbmpWarp)
        Error("Couldn't create DC to cache warping results\n");

    SelectObject(hdcWarp, hbmpWarp);

    // Horizontal pass

    PVOID tmpBmpData;
    INT x, y;
    double* outpos;

    tmpBmpData = malloc(dstStride*(srcSize.cy + 2));
    outpos = (double*) malloc(sizeof(double) * (max(srcSize.cx, srcSize.cy) + 1));

    if (!tmpBmpData || !outpos)
        Error("Could allocate temporary memory for warping\n");

    MeshIterator* iterator;
    
    iterator = mesh->getYIterator(srcSize.cx, dstSize.cx, srcSize.cy);

    for (y=0; y < srcSize.cy; y++)
    {
        // compute the output position for each 

        iterator->getOutPos(y, outpos);

        // perform 1D resampling

        Resample1D(
            (PBYTE) srcBmpData + y*srcStride,
            srcSize.cx,
            (PBYTE) tmpBmpData + y*dstStride,
            dstSize.cx,
            PIXELSIZE,
            outpos);
    }

    delete iterator;

    // Vertical pass

    iterator = mesh->getXIterator(srcSize.cy, dstSize.cy, dstSize.cx);

    for (x=0; x < dstSize.cx; x++)
    {
        // compute the output position for each 

        iterator->getOutPos(x, outpos);

        // perform 1D resampling

        Resample1D(
            (PBYTE) tmpBmpData + PIXELSIZE*x,
            srcSize.cy,
            (PBYTE) dstBmpData + PIXELSIZE*x,
            dstSize.cy,
            dstStride,
            outpos);
    }

    delete iterator;

    free(tmpBmpData);
    free(outpos);
}


//
// Draw mesh
//

#define MESHCOLOR   RGB(255, 0, 0)

VOID
DrawMesh(
    HDC hdc
    )
{
    static HPEN meshPen = NULL;
    static HBRUSH meshBrush = NULL;

    mesh->setDstSize(dstSize.cx, dstSize.cy);

    // Create the pen to draw the mesh, if necessary

    if (meshPen == NULL)
        meshPen = CreatePen(PS_SOLID, 1, MESHCOLOR);

    SelectObject(hdc, meshPen);

    // Draw horizontal meshes

    INT i, j, rows, cols, pointCount;
    POINT* points;

    rows = mesh->getGridRows();

    for (i=0; i < rows; i++)
    {
        points = mesh->getMeshRowBeziers(i, &pointCount);
        PolyBezier(hdc, points, pointCount);
    }

    // Draw vertical meshes

    cols = mesh->getGridColumns();

    for (i=0; i < cols; i++)
    {
        points = mesh->getMeshColumnBeziers(i, &pointCount);
        PolyBezier(hdc, points, pointCount);
    }

    // Draw knobs

    // Create the brush to draw the mesh if necessary

    if (meshBrush == NULL)
        meshBrush = CreateSolidBrush(MESHCOLOR);

    for (i=0; i < rows; i++)
    {
        points = mesh->getMeshRowPoints(i, &pointCount);

        for (j=0; j < cols; j++)
        {
            RECT rect;

            rect.left = points[j].x - knobSize/2;
            rect.top = points[j].y - knobSize/2;
            rect.right = rect.left + knobSize;
            rect.bottom = rect.top + knobSize;

            FillRect(hdc, &rect, meshBrush);
        }
    }
}


//
// Handle window repaint event
//

VOID
DoPaint(
    HWND hwnd
    )

{
    HDC hdc;
    PAINTSTRUCT ps;
    RECT rect;
    INT width, height;

    // Determine if we need to perform warping operation

    GetClientRect(hwnd, &rect);
    width = rect.right;
    height = rect.bottom;

    if (clearWarpCache ||
        dstSize.cx != width ||
        dstSize.cy != height)
    {
        CalcKnobSize(width, height);

        clearWarpCache = FALSE;
        DoWarp(width, height);
    }

    hdc = BeginPaint(hwnd, &ps);

    if (showMesh)
    {
        // Draw to offscreen DC to reduce flashing

        HDC hdcMem;
        HBITMAP hbmp;

        hdcMem = CreateCompatibleDC(hdc);
        hbmp = CreateCompatibleBitmap(hdc, width, height);
        SelectObject(hdcMem, hbmp);

        BitBlt(hdcMem, 0, 0, width, height, hdcWarp, 0, 0, SRCCOPY);
        DrawMesh(hdcMem);

        // Blt from offscreen memory to window

        BitBlt(hdc, 0, 0, width, height, hdcMem, 0, 0, SRCCOPY);

        DeleteDC(hdcMem);
        DeleteObject(hbmp);
    }
    else
    {
        // Blt cached warping result to window

        BitBlt(hdc, 0, 0, width, height, hdcWarp, 0, 0, SRCCOPY);
    }

    EndPaint(hwnd, &ps);
}


//
// Handle WM_SIZING message
//

BOOL
DoWindowSizing(
    HWND hwnd,
    RECT* rect,
    INT side
    )

{
    INT w = rect->right - rect->left - wndSizeExtra.cx;
    INT h = rect->bottom - rect->top - wndSizeExtra.cy;

    if (w >= srcSize.cx && h >= srcSize.cy)
        return FALSE;

    // Window width is too small

    if (w < srcSize.cx)
    {
        INT dx = srcSize.cx + wndSizeExtra.cx;

        switch (side)
        {
        case WMSZ_LEFT:
        case WMSZ_TOPLEFT:
        case WMSZ_BOTTOMLEFT:
            rect->left = rect->right - dx;
            break;
        
        default:
            rect->right = rect->left + dx;
            break;
        }
    }

    // Window height is too small

    if (h < srcSize.cy)
    {
        INT dy = srcSize.cy + wndSizeExtra.cy;

        switch (side)
        {
        case WMSZ_TOP:
        case WMSZ_TOPLEFT:
        case WMSZ_TOPRIGHT:
            rect->top = rect->bottom - dy;
            break;
        
        default:
            rect->bottom = rect->top + dy;
            break;
        }
    }

    return TRUE;
}


//
// Handle left mouse-down event
//

VOID
DoMouseDown(
    HWND hwnd,
    INT x,
    INT y
    )

{
    // Figure out if the click happened in a mesh control knob

    INT i, j, rows, cols;
    POINT pt;
    RECT rect;

    GetClientRect(hwnd, &rect);
    mesh->setDstSize(rect.right, rect.bottom);

    rows = mesh->getGridRows();
    cols = mesh->getGridColumns();

    for (i=0; i < rows; i++)
        for (j=0; j < cols; j++)
        {
            mesh->getMeshPoint(i, j, &pt);
            pt.x -= knobSize/2;
            pt.y -= knobSize/2;

            if (x >= pt.x && x < pt.x+knobSize &&
                y >= pt.y && y < pt.y+knobSize)
            {
                dragRow = i;
                dragCol = j;
                SetCapture(hwnd);
                isDragging = TRUE;
                return;
            }
        }
}


//
// Handle mouse-move event
//

VOID
DoMouseMove(
    HWND hwnd,
    INT x,
    INT y
    )

{
    // We assume isDragging is true here.

    RECT rect;
    INT w, h;

    GetClientRect(hwnd, &rect);
    w = rect.right;
    h = rect.bottom;

    if (x < 0 || x >= w || y < 0 || y >= h)
        return;

    mesh->setDstSize(w, h);

    if (mesh->setMeshPoint(dragRow, dragCol, x, y))
    {
        if (liveFeedback)
            clearWarpCache = TRUE;

        InvalidateRect(hwnd, NULL, FALSE);
    }
}


//
// Handle menu command
//

VOID
DoCommand(
    HWND hwnd,
    INT command
    )
{
    switch (command)
    {
    case IDC_RESETMESH:

        mesh->initMesh();
        clearWarpCache = TRUE;
        break;

    case IDC_TOGGLEMESH:

        showMesh = !showMesh;
        break;

    case IDC_SHRINKTOFIT:

        SetWindowPos(
            hwnd, NULL, 0, 0, 
            srcSize.cx + wndSizeExtra.cx,
            srcSize.cy + wndSizeExtra.cy,
            SWP_NOOWNERZORDER|SWP_NOMOVE);
        break;

    case IDC_DENSEMESH:

        if (meshGrids >= MAX_MESH_GRID)
            return;
        
        meshGrids++;
        CreateMesh();
        showMesh = TRUE;
        break;

    case IDC_SPARSEMESH:

        if (meshGrids <= MIN_MESH_GRID)
            return;

        meshGrids--;
        CreateMesh();
        showMesh = TRUE;
        break;

    case IDC_LIVEFEEDBACK:

        liveFeedback = !liveFeedback;
        return;

    default:
        return;
    }

    InvalidateRect(hwnd, NULL, FALSE);
}


//
// Handle popup menu
//

VOID
DoPopupMenu(
    HWND hwnd,
    INT x,
    INT y
    )
{
    HMENU menu;
    DWORD result;
    POINT pt;

    GetCursorPos(&pt);
    menu = LoadMenu(appInstance, MAKEINTRESOURCE(IDM_MAINMENU));

    result = TrackPopupMenu(
                GetSubMenu(menu, 0),
                TPM_CENTERALIGN | TPM_TOPALIGN |
                    TPM_NONOTIFY | TPM_RETURNCMD |
                    TPM_RIGHTBUTTON,
                pt.x,
                pt.y,
                0,
                hwnd,
                NULL);

    if (result == 0)
        return;

    DoCommand(hwnd, LOWORD(result));
}


//
// Window callback procedure
//

LRESULT CALLBACK
MyWindowProc(
    HWND    hwnd,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )

{
    INT x, y;

    switch (uMsg)
    {
    case WM_PAINT:

        DoPaint(hwnd);
        break;

    case WM_LBUTTONDOWN:

        if (showMesh)
        {
            x = (SHORT) LOWORD(lParam);
            y = (SHORT) HIWORD(lParam);
            DoMouseDown(hwnd, x, y);
        }
        break;

    case WM_LBUTTONUP:

        if (isDragging)
        {
            ReleaseCapture();
            isDragging = FALSE;

            clearWarpCache = TRUE;
            InvalidateRect(hwnd, NULL, FALSE);
        }
        break;

    case WM_MOUSEMOVE:

        if (isDragging)
        {
            x = (SHORT) LOWORD(lParam);
            y = (SHORT) HIWORD(lParam);
            DoMouseMove(hwnd, x, y);
        }
        break;

    case WM_SIZING:

        if (DoWindowSizing(hwnd, (RECT*) lParam, wParam))
            return TRUE;
        else
            return DefWindowProc(hwnd, uMsg, wParam, lParam);

    case WM_SIZE:

        InvalidateRect(hwnd, NULL, FALSE);
        break;

    case WM_CHAR:

        switch ((CHAR) wParam)
        {
        case 'r':   // reset

            DoCommand(hwnd, IDC_RESETMESH);
            break;

        case ' ':   // show/hide mesh

            DoCommand(hwnd, IDC_TOGGLEMESH);
            break;

        case '1':   // restore 1-to-1 scale

            DoCommand(hwnd, IDC_SHRINKTOFIT);
            break;
        
        case '<':   // decrease mesh density

            DoCommand(hwnd, IDC_SPARSEMESH);
            break;

        case '>':   // increase mesh density

            DoCommand(hwnd, IDC_DENSEMESH);
            break;

        case 'f':   // toggle live feedback

            DoCommand(hwnd, IDC_LIVEFEEDBACK);
            break;
        }

        break;

    case WM_RBUTTONDOWN:

        x = (SHORT) LOWORD(lParam);
        y = (SHORT) HIWORD(lParam);
        DoPopupMenu(hwnd, x, y);
        break;

    case WM_DESTROY:

        PostQuitMessage(0);
        break;

    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0;
}


//
// Create main application window
//

VOID
CreateMainWindow(
    VOID
    )

#define MYWNDCLASSNAME "WarpDemo"

{
    //
    // Register window class if necessary
    //

    static BOOL wndclassRegistered = FALSE;

    if (!wndclassRegistered)
    {
        WNDCLASS wndClass =
        {
            0,
            MyWindowProc,
            0,
            0,
            appInstance,
            LoadIcon(NULL, IDI_APPLICATION),
            LoadCursor(NULL, IDC_ARROW),
            NULL,
            NULL,
            MYWNDCLASSNAME
        };

        RegisterClass(&wndClass);
        wndclassRegistered = TRUE;
    }
    
    wndSizeExtra.cx = 2*GetSystemMetrics(SM_CXSIZEFRAME);
    wndSizeExtra.cy = 2*GetSystemMetrics(SM_CYSIZEFRAME) + GetSystemMetrics(SM_CYCAPTION);

    hwndMain = CreateWindow(
                    MYWNDCLASSNAME,
                    MYWNDCLASSNAME,
                    WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    srcSize.cx + wndSizeExtra.cx,
                    srcSize.cy + wndSizeExtra.cy,
                    NULL,
                    NULL,
                    appInstance,
                    NULL);
}


//
// Map a file into process memory space
//

PVOID
MapFileIntoMemory(
    PCSTR filename,
    DWORD* size
    )

{
    HANDLE filehandle, filemap;
    PVOID fileview = NULL;

    //
    // Open a handle to the specified file
    //

    filehandle = CreateFile(
                        filename,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL||FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL);

    if (filehandle == INVALID_HANDLE_VALUE)
        return NULL;

    //
    // Obtain the file size
    //

    *size = GetFileSize(filehandle, NULL);

    if (*size == 0xFFFFFFFF)
    {
        CloseHandle(filehandle);
        return NULL;
    }

    //
    // Map the file into memory
    //

    filemap = CreateFileMapping(filehandle, NULL, PAGE_READONLY, 0, 0, NULL);

    if (filemap != NULL)
    {
        fileview = MapViewOfFile(filemap, FILE_MAP_READ, 0, 0, 0);
        CloseHandle(filemap);
    }

    CloseHandle(filehandle);
    return fileview;
}


//
// Load source bitmap file
//

VOID
LoadBitmapFile(
    PCSTR filename
    )

{
    BITMAPFILEHEADER* bmpfile;
    BITMAPINFO* bmpinfo;
    PBYTE bmpdata;
    HBITMAP dibSection = NULL;
    DWORD filesize;
    PVOID fileview = NULL;
    HDC hdc = NULL;
    BOOL success = FALSE;

    __try
    {
        //
        // Map the bitmap file into memory
        //

        fileview = MapFileIntoMemory(filename, &filesize);

        if (fileview == NULL)
            __leave;

        bmpfile = (BITMAPFILEHEADER *) fileview;
        bmpinfo = (BITMAPINFO *) ((PBYTE) fileview + sizeof(BITMAPFILEHEADER));
        bmpdata = (PBYTE) fileview + bmpfile->bfOffBits;

        //
        // Check bitmap file header information
        //

        if (bmpfile->bfType != 0x4D42 ||    // 'BM'
            bmpfile->bfSize > filesize ||
            bmpfile->bfOffBits >= bmpfile->bfSize)
        {
            __leave;
        }

        //
        // Allocate memory for source bitmap
        //

        srcSize.cx = bmpinfo->bmiHeader.biWidth;
        srcSize.cy = abs(bmpinfo->bmiHeader.biHeight);
        srcStride = ((srcSize.cx * PIXELSIZE) + 3) & ~3;

        BITMAPINFOHEADER header =
        {
            sizeof(header),
            srcSize.cx,
            -srcSize.cy,
            1,
            PIXELSIZE*8,
            BI_RGB,
        };

        dibSection = CreateDIBSection(
                            NULL,
                            (BITMAPINFO*) &header,
                            DIB_RGB_COLORS,
                            &srcBmpData,
                            NULL,
                            0);

        if (!dibSection)
            __leave;

        //
        // Blt from the bitmap file to the DIB section
        //

        HBITMAP hbmp;

        hdc = CreateCompatibleDC(NULL);
        hbmp = (HBITMAP) SelectObject(hdc, dibSection);

        StretchDIBits(
            hdc,
            0, 0, srcSize.cx, srcSize.cy,
            0, 0, srcSize.cx, srcSize.cy,
            bmpdata,
            bmpinfo,
            DIB_RGB_COLORS,
            SRCCOPY);

        SelectObject(hdc, hbmp);
        success = TRUE;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // AV while reading bitmap file
    }

    if (hdc)
        DeleteDC(hdc);

    if (fileview)
        UnmapViewOfFile(fileview);

    if (!success)
        Error("Failed to read source bitmap\n");
}


//
// Main program entrypoint
//

INT _cdecl
main(
    INT argc,
    CHAR **argv
    )

{
    programName = *argv++;
    argc--;
    appInstance = GetModuleHandle(NULL);

    // Load source bitmap file

    if (argc != 1)
        Error("usage: %s bitmapfile\n", programName);

    LoadBitmapFile(*argv);

    // Initialize mesh configuration

    CreateMesh();

    // Create the main application window

    CreateMainWindow();

    // Main message loop

    MSG msg;

    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return msg.wParam;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\warpdemo\mesh.cxx ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   mesh.cxx
*
* Abstract:
*
*   Implementation of spline meshes
*
* Revision History:
*
*   01/18/1999 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hxx"


//
// Mesh constructor
//

Mesh::Mesh(
    INT gridRows,
    INT gridCols
    )

{
    this->gridRows = gridRows;
    this->gridCols = gridCols;
    ptTemp = NULL;
    ptxTemp1 = ptxTemp2 = NULL;
    dstSize.cx = dstSize.cy = 2;

    mesh = new PointX[gridRows*gridCols];

    if (mesh == NULL)
        Error("Couldn't allocate memory to hold mesh grids\n");

    initMesh();
}

//
// Mesh destructor
//

Mesh::~Mesh()
{
    delete[] mesh;
    delete[] ptTemp;
    delete[] ptxTemp1;
    delete[] ptxTemp2;
}


//
// Initialize mesh configuration
//

VOID
Mesh::initMesh()
{
    PointX* p = mesh;
    double sx = 1.0 / (gridCols-1);
    double sy = 1.0 / (gridRows-1);

    for (INT row=0; row < gridRows; row++)
    {
        double y = row * sy;

        for (INT col=0; col < gridCols; col++)
        {
            p->x = col * sx;
            p->y = y;
            p++;
        }
    }
}


//
// Allocate temporary memory to hold 
//

VOID
Mesh::allocTempPoints()
{
    // Check to see if we have already allocated
    // temporary memory for holding spline and bezier points

    if (ptTemp)
        return;

    INT count = max(gridRows, gridCols);

    ptxTemp1 = new PointX[count];
    ptxTemp2 = new PointX[3*count+1];
    ptTemp = new POINT[3*count+1];

    if (!ptxTemp1 || !ptxTemp2 || !ptTemp)
        Error("Out of memory\n");
}


//
// Convert a spline curve to Bezier segments
//

VOID
Mesh::spline2Bezier(
    const PointX* srcPts,
    PointX* dstPts,
    INT count
    )

{
    const PointX* p;
    PointX tempPts[4];

    // We use the default tension of 0.5

    double a3 = 0.5 / 3;

    *dstPts = *srcPts;

    for (INT i=0; i < count; i++)
    {
        if (i > 1 && i < count-1)
            p = srcPts + (i-1);
        else
        {
            tempPts[0] = srcPts[(i > 0) ? (i-1) : 0];
            tempPts[1] = srcPts[i];
            tempPts[2] = srcPts[(i+1 < count) ? (i+1) : count];
            tempPts[3] = srcPts[(i+2 < count) ? (i+2) : count];
            p = tempPts;
        }

        dstPts[1].x = -a3*p[0].x + p[1].x + a3*p[2].x;
        dstPts[1].y = -a3*p[0].y + p[1].y + a3*p[2].y;
        dstPts[2].x =  a3*p[1].x + p[2].x - a3*p[3].x;
        dstPts[2].y =  a3*p[1].y + p[2].y - a3*p[3].y;
        dstPts[3] = p[2];

        dstPts += 3;
    }
}


//
// Return the beizer control points corresponding to
// the specified row of the mesh.
//

PointX*
Mesh::getMeshRowBeziers(
    INT row,
    INT* pointCount,
    double sx,
    double sy
    )
{
    allocTempPoints();

    PointX* ptx = mesh + indexOf(row);

    for (INT i=0; i < gridCols; i++)
    {
        ptxTemp1[i].x = ptx[i].x * sx;
        ptxTemp1[i].y = ptx[i].y * sy;
    }

    INT segments = gridCols-1;
    spline2Bezier(ptxTemp1, ptxTemp2, segments);

    *pointCount = 3*segments + 1;
    return ptxTemp2;
}

POINT*
Mesh::getMeshRowBeziers(
    INT row,
    INT* pointCount
    )
{
    PointX* ptx;

    ptx = getMeshRowBeziers(row, pointCount, dstSize.cx - 1, dstSize.cy - 1);
    PointX::convertToPOINT(ptx, ptTemp, *pointCount);
    return ptTemp;
}


//
// Return the beizer control points corresponding to
// the specified column of the mesh.
//

PointX*
Mesh::getMeshColumnBeziers(
    INT col,
    INT* pointCount,
    double sx,
    double sy
    )
{
    allocTempPoints();

    INT i, j;

    for (i=0, j=col; i < gridRows; i++, j+=gridCols)
    {
        ptxTemp1[i].x = mesh[j].x * sx;
        ptxTemp1[i].y = mesh[j].y * sy;
    }

    INT segments = gridRows-1;
    spline2Bezier(ptxTemp1, ptxTemp2, segments);

    *pointCount = 3*segments + 1;
    return ptxTemp2;
}

POINT*
Mesh::getMeshColumnBeziers(
    INT col,
    INT* pointCount
    )
{
    PointX* ptx;

    ptx = getMeshColumnBeziers(col, pointCount, dstSize.cx - 1, dstSize.cy - 1);
    PointX::convertToPOINT(ptxTemp2, ptTemp, *pointCount);
    return ptTemp;
}


//
// Return the mesh control points for the specified row
//

POINT*
Mesh::getMeshRowPoints(
    INT row,
    INT* pointCount
    )
{
    allocTempPoints();

    POINT* pt = ptTemp;
    PointX* ptx = mesh + indexOf(row);

    double sx = dstSize.cx - 1;
    double sy = dstSize.cy - 1;

    for (INT j=0; j < gridCols; j++)
    {
        pt[j].x = ROUND2INT(ptx[j].x * sx);
        pt[j].y = ROUND2INT(ptx[j].y * sy);
    }

    return pt;
}


//
// Return the specified mesh control point (given row & column)
//

VOID
Mesh::getMeshPoint(
    INT row,
    INT col,
    POINT* point
    )
{
    INT index = indexOf(row, col);

    point->x = ROUND2INT(mesh[index].x * (dstSize.cx - 1));
    point->y = ROUND2INT(mesh[index].y * (dstSize.cy - 1));
}


//
// Set a mesh control point to the specified values
//

BOOL
Mesh::setMeshPoint(
    INT row,
    INT col,
    INT x,
    INT y
    )
{
    // special case for mesh control points along the border

    if ((row == 0 && y != 0) ||
        (row == gridRows-1 && y != dstSize.cy-1) ||
        (col == 0 && x != 0) ||
        (col == gridCols-1 && x != dstSize.cx-1))
    {
        return FALSE;
    }

    double tx, ty;

    tx = (double) x / (dstSize.cx - 1);
    ty = (double) y / (dstSize.cy - 1);

    // quick test to ensure the mesh control point
    // is well-ordered relative to its four neighbors

    if (col > 0 && tx <= mesh[indexOf(row, col-1)].x ||
        col < gridCols-1 && tx >= mesh[indexOf(row, col+1)].x ||
        row > 0 && ty <= mesh[indexOf(row-1, col)].y ||
        row < gridRows-1 && ty >= mesh[indexOf(row+1, col)].y)
    {
        return FALSE;
    }

    INT index = indexOf(row, col);
    PointX ptx = mesh[index];

    mesh[index].x = tx;
    mesh[index].y = ty;

    // verify the mesh row and mesh column is single-valued

    if (verifyRow(row) && verifyColumn(col))
        return TRUE;

    // if not, reject the mesh control point

    mesh[index] = ptx;
    return FALSE;
}


//
// Verify that the specified mesh row is well-ordered
//

BOOL
Mesh::verifyRow(INT row)
{
    INT count;
    PointX* points = getMeshRowBeziers(row, &count, dstSize.cx, dstSize.cy);

    while (count > 3)
    {
        if (!verifyBezierX(points))
            return FALSE;

        points += 3;
        count -= 3;
    }

    return TRUE;
}

//
// Verify that the specified mesh column is well-ordered
//

BOOL
Mesh::verifyColumn(INT col)
{
    INT count;
    PointX* points = getMeshColumnBeziers(col, &count, dstSize.cx, dstSize.cy);

    while (count > 3)
    {
        if (!verifyBezierY(points))
            return FALSE;

        points += 3;
        count -= 3;
    }

    return TRUE;
}


//
// Check if a Bezier segment is well-ordered in the x-direction
//

BOOL
Mesh::verifyBezierX(
    PointX* pts
    )
{
    double a, b, c, d;

    // get the quadratic equation for x'(t)

    a = 3.0 * (3*pts[1].x + pts[3].x - pts[0].x - 3*pts[2].x);
    b = 6.0 * (pts[0].x - 2*pts[1].x + pts[2].x);
    c = 3.0 * (pts[1].x - pts[0].x);

    // solve t for x'(t) = 0

    d = b*b - 4*a*c;

    if (d <= 0 || a == 0)
        return TRUE;

    // if both solution are between 0 <= t <= 1
    // then the Bezier curve is not well-ordered in x-direction

    double t1, t2;

    d = sqrt(d);
    a = 0.5 / a;

    t1 =  (d - b) * a;
    t2 = -(d + b) * a;
    
    return t1 < 0 || t1 > 1 ||
           t2 < 0 || t2 > 1;
}


//
// Check if a Bezier segment is well-ordered in the y-direction
//

BOOL
Mesh::verifyBezierY(
    PointX* pts
    )
{
    double a, b, c, d;

    // get the quadratic equation for y'(t)

    a = 3.0 * (3*pts[1].y + pts[3].y - pts[0].y - 3*pts[2].y);
    b = 6.0 * (pts[0].y - 2*pts[1].y + pts[2].y);
    c = 3.0 * (pts[1].y - pts[0].y);

    // solve t for y'(t) = 0

    d = b*b - 4*a*c;

    if (d <= 0 || a == 0)
        return TRUE;

    // if both solution are between 0 <= t <= 1
    // then the Bezier curve is not well-ordered in y-direction

    double t1, t2;

    d = sqrt(d);
    a = 0.5 / a;

    t1 =  (d - b) * a;
    t2 = -(d + b) * a;
    
    return t1 < 0 || t1 > 1 ||
           t2 < 0 || t2 > 1;
}


//
// Return a new MeshIterator object so that we can
// step along the y-direction and get the scale factors
// for each scanline.
//

MeshIterator*
Mesh::getYIterator(
    INT srcWidth,
    INT dstWidth,
    INT ySteps
    )
{
    MeshIterator* iterator;
    
    iterator  = new MeshIterator(srcWidth, dstWidth, ySteps, gridCols);

    if (iterator == NULL)
        Error("Out of memory\n");

    PointX* ptx;
    INT count;

    for (INT col=0; col < gridCols; col++)
    {
        ptx = getMeshColumnBeziers(col, &count, dstWidth-1, ySteps-1);

        // swap x and y coordinates

        for (INT i=0; i < count; i++)
        {
            double t = ptx[i].x;
            ptx[i].x = ptx[i].y;
            ptx[i].y = t;
        }

        iterator->addCurve(ptx, count);
    }

    return iterator;
}


//
// Return a new MeshIterator object so that we can
// step along the y-direction and get the scale factors
// for each vertical column of pixels.
//

MeshIterator*
Mesh::getXIterator(
    INT srcHeight,
    INT dstHeight,
    INT xSteps
    )
{
    MeshIterator* iterator;

    iterator  = new MeshIterator(srcHeight, dstHeight, xSteps, gridRows);

    if (iterator == NULL)
        Error("Out of memory\n");

    PointX* ptx;
    INT count;

    for (INT row=0; row < gridRows; row++)
    {
        ptx = getMeshRowBeziers(row, &count, xSteps-1, dstHeight-1);
        iterator->addCurve(ptx, count);
    }

    return iterator;
}


//
// MeshIterator constructor
//

MeshIterator::MeshIterator( 
    INT srcLen,
    INT dstLen,
    INT steps,
    INT maxCurves
    )
{
    if (maxCurves > MAXCURVES)
        Error("Too many curves in MeshIterator constructor\n");

    this->srcLen = srcLen;
    this->dstLen = dstLen;
    this->steps = steps;
    this->maxCurves = maxCurves;
    curveCount = 0;

    for (INT i=0; i < MAXCURVES; i++)
        curves[i] = NULL;
}


//
// MeshIterator - destructor
//

MeshIterator::~MeshIterator()
{
    for (INT i=0; i < MAXCURVES; i++)
        delete curves[i];
}


//
// MeshIterator - add another curve
//

VOID
MeshIterator::addCurve(
    const PointX* pts,
    INT count
    )
{
    if (curveCount == maxCurves)
        Error("Program error in MeshIterator::addCurve\n");
    
    FlatCurve* curve = new FlatCurve(pts, count);

    if (curve == NULL)
        Error("Out of memory\n");
    
    curves[curveCount++] = curve;
}


//
// MeshIterator - get out positions
//

VOID
MeshIterator::getOutPos(
    INT index,
    double* outpos
    )
{
    if (curveCount != maxCurves ||
        index < 0 || index >= steps)
    {
        Error("Program error in MeshIterator::getOutPos\n");
    }

    INT i, j;
    double scale;
    double x = index;

    for (i=0; i < maxCurves; i++)
        stops[i] = curves[i]->getPos(x);

    scale = 1.0 / (srcLen-1);

    for (i=0; i < srcLen; i++)
    {
        j = i * (maxCurves-1) / (srcLen-1);

        INT i0 = (srcLen-1) * j / (maxCurves-1);

        if (i == i0)
            outpos[i] = stops[j];
        else
        {
            INT i1 = (srcLen-1) * (j+1) / (maxCurves-1);

            outpos[i] = stops[j] + (stops[j+1] - stops[j]) * (i-i0) / (i1-i0);
        }
    }

    outpos[srcLen] = dstLen;
}


//
// FlatCurve constructor
//

FlatCurve::FlatCurve(
    const PointX* pts,
    INT count
    )
{
    capacity = elementCount = 0;
    allocIncr = count * 3;
    allocIncr = (allocIncr + 31) & ~31;
    pointArray = NULL;
    lastIndex = 0;

    while (count > 3)
    {
        addBezierFlatten(pts);
        count -= 3;
        pts += 3;
    }
}


//
// FlatCurve destructor
//

FlatCurve::~FlatCurve()
{
    free(pointArray);
}


//
// FlatCurve - add a flattened bezier segment
//

VOID
FlatCurve::addBezierFlatten(
    const PointX* pts
    )
{
    BOOL flatEnough;
    double dx, dy, distSq;
    PointX tempPts[4];

    static const double epsilon = 0.00001;
    static const double flatness = 1;
    static const double flatness2 = flatness*flatness;

    //
    // Determine if the Bezier curve is flat enough
    //
    // Algorithm
    //  Given 3 points (Ax, Ay), (Bx, By), and (Cx, Cy),
    //  the distance from C to line AB is:
    //      dx = Bx - Ax
    //      dy = By - Ay
    //      L = sqrt(dx*dx + dy*dy)
    //      dist = (dy * (Cx - Ax) - dx * (Cy - Ay))/ L
    //

    dx = pts[3].x - pts[0].x;
    dy = pts[3].y - pts[0].y;
    distSq = dx*dx + dy*dy;

    if (distSq < epsilon)
    {
        // if P0 and P3 are too close

        flatEnough = PointX::getSquareDist(pts[0], pts[1]) <= flatness2 &&
                     PointX::getSquareDist(pts[2], pts[3]) <= flatness2;
    }
    else
    {
        // check if P1 is close enough to line P0-P3

        double s;

        s = dy*(pts[1].x - pts[0].x) - dx*(pts[1].y - pts[0].y);
        s *= s;
        distSq *= flatness2;

        if (s > distSq)
            flatEnough = FALSE;
        else
        {
            // check if P2 is close enough to line P0-P3

            s = dy*(pts[2].x - pts[0].x) - dx*(pts[2].y - pts[0].y);
            flatEnough = (s*s <= distSq);
        }
    }

    //
    // If Bezier segment is already flat enough, we're done
    //

    if (flatEnough)
    {
        addLine(pts[0], pts[3]);
        return;
    }

    //
    // Otherwise, we need to subdivide
    //

    tempPts[0] = pts[0];
    tempPts[1].x = (pts[0].x + pts[1].x) * 0.5;
    tempPts[1].y = (pts[0].y + pts[1].y) * 0.5;
    tempPts[2].x = (pts[0].x + pts[2].x) * 0.25 + pts[1].x * 0.5;
    tempPts[2].y = (pts[0].y + pts[2].y) * 0.25 + pts[1].y * 0.5;
    tempPts[3].x = (pts[0].x + pts[3].x) * 0.125 +
                   (pts[1].x + pts[2].x) * 0.375;
    tempPts[3].y = (pts[0].y + pts[3].y) * 0.125 +
                   (pts[1].y + pts[2].y) * 0.375;

    addBezierFlatten(tempPts);

    tempPts[0] = tempPts[3];
    tempPts[1].x = (pts[1].x + pts[3].x) * 0.25 + pts[2].x * 0.5;
    tempPts[1].y = (pts[1].y + pts[3].y) * 0.25 + pts[2].y * 0.5;
    tempPts[2].x = (pts[2].x + pts[3].x) * 0.5;
    tempPts[2].y = (pts[2].y + pts[3].y) * 0.5;
    tempPts[3] = pts[3];

    addBezierFlatten(tempPts);
}


//
// FlatCurve - add a line segment
//

VOID
FlatCurve::addLine(
    const PointX& p1,
    const PointX& p2
    )
{
    // make sure we have enough space

    if (capacity < elementCount+2)
    {
        capacity += allocIncr;
        pointArray = (PointX*) realloc(pointArray, capacity*sizeof(PointX));

        if (pointArray == NULL)
            Error("Out of memory\n");
    }

    // add the first end point of the line, if necessary

    if (elementCount == 0 ||
        p1.x != pointArray[elementCount-1].x ||
        p1.y != pointArray[elementCount-1].y)
    {
        pointArray[elementCount++] = p1;
    }

    // add the second end point

    pointArray[elementCount++] = p2;
}


//
// FlatCurve - calculate the value of the curve at a given position
//

double
FlatCurve::getPos(
    double x
    )
{
    while (lastIndex < elementCount && pointArray[lastIndex].x < x)
        lastIndex++;

    if (lastIndex == elementCount)
        return pointArray[elementCount-1].y;

    if (pointArray[lastIndex].x == x)
        return pointArray[lastIndex].y;

    double x0 = pointArray[lastIndex-1].x;
    double y0 = pointArray[lastIndex-1].y;

    return y0 + (x - x0) * (pointArray[lastIndex].y - y0) /
                           (pointArray[lastIndex].x - x0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\tools\memcounter\memcounter.cpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   IceCAP user counters for GDI+ memory allocations
*
* Abstract:
*
*   This is an IceCAP "user counter" DLL. It exports logging functions which
*   GDI+ will call during memory allocation (if PROFILE_MEMORY_USAGE is
*   true). It also exports query functions for hooking up to IceCAP.
*
* Instructions for use:
*
*   + Build memcounter.dll
*   + Copy memcounter.dll and the icecap.ini file (which is in the same 
*     directory as memcounter.cpp) to the test app directory.
*   + set PROFILE_MEMORY_USAGE=1
*   + Build GDIPLUS.DLL
*   + Instrument it (using "gppick.bat")
*   + Run the test
*   + Afterwards, view the .ICP file that has been generated.
*
*   In the IceCAP viewer, you will need to add columns for 
*   "User counter 1, elapsed inclusive", etc.
*
* Created:
*
*   06/10/2000 agodfrey
*      Created it from the sample code in IceCAP4\Samples\MemTrack.
*
**************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#define DONTUSEICECAPLIB
#include "icecap.h"

// GLOBALS
//
// This is where we will store our counter values.  These could
// just as easily be put in shared memory so you can have another
// process updating them.  They can not be put in the counter
// functions as auto variables, since naked functions don't 
// allow for this.

DWORD g_dwTlsSlot = 0xffffffff;         // TLS Slot, allocated in DllMain
DWORD g_dwTlsIndexSize;                 // 'Pre-computed' slot offset, so we can
                                        // avoid calling TlsGetValue in probes

//
//  Data tracked for each thread.
struct SAllocInfo
{
    COUNTER cntAllocs;                  // Number of allocations made
    COUNTER cntBytes;                   // Bytes (total) allocated
};


const UINT g_uiMaxThreads = 64;         // Max sim. threads tracked
SAllocInfo g_aAllocInfo[g_uiMaxThreads]; // Data tracked
BOOL g_afInUse[g_uiMaxThreads];         // Is a particular data slot used


// FUNCTIONS
//
///////////////////////////////////////////////////////////////
// DllMain
//
// Standard DLL entry point, sets up storage for per-thread 
// counter information.
//
// History:  9-16-98 MHotchin Created
//
///////////////////////////////////////////////////////////////

BOOL
APIENTRY
DllMain(
        HANDLE ,
        DWORD  dwReason,
        LPVOID )
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        g_dwTlsSlot = TlsAlloc();

        memset(g_afInUse, 0, sizeof(g_afInUse));

        if (g_dwTlsSlot == 0xffffffff)
        {
            return FALSE;
        }

        //
        //  Tricky, tricky, tricky...
        //  We can pre-compute where the TLS slot will be, once
        //  we have the index.  The offsets are OS dependent!
        //
        //  This makes the probes much faster, becuase we don't need to
        //  call TlsGetValue().
        if (GetVersion() & 0x80000000)
        {
            //  *** WIN 9x ONLY ***
            g_dwTlsIndexSize = g_dwTlsSlot * sizeof(void *) + 0x88;
        }
        else
        {
            //
            //  *** NT ONLY ***
            g_dwTlsIndexSize = g_dwTlsSlot * sizeof(void *) + 0xe10;
        }

        //
        //  FALL THROUGH
    case DLL_THREAD_ATTACH:
        {
            SAllocInfo *pInfo = NULL;

            //
            //  Locate a data slot for this thread and remeber it's pointer
            //  in the TLS slot.
            for (UINT i = 0; i < g_uiMaxThreads; i++)
            {
                if (!g_afInUse[i])
                {
                    g_afInUse[i] = TRUE;
                    pInfo = &(g_aAllocInfo[i]);
                    memset(pInfo, 0, sizeof(SAllocInfo));

                    break;
                }
            }
            TlsSetValue(g_dwTlsSlot, pInfo);
        }
    break;

    case DLL_PROCESS_DETACH:
        if (g_dwTlsSlot != 0xffffffff)
        {
            TlsFree(g_dwTlsSlot);
            g_dwTlsSlot = 0xffffffff;
        }
        break;

    case DLL_THREAD_DETACH:
        {
            SAllocInfo *pInfo = (SAllocInfo *)TlsGetValue(g_dwTlsSlot);

            if (pInfo != NULL)
            {
                UINT iIndex = pInfo - g_aAllocInfo;

                g_afInUse[iIndex] = FALSE;
            }
        }

    break;
    }

    return TRUE;
}




///////////////////////////////////////////////////////////////
// GetCounterInfo
//
// This is where we define what is counter is, and how it
// behaves.  
//
// History:  9-16-98 MHotchin Created
//           2-26-99 AlonB updated for new USERCOUNTER API
//
///////////////////////////////////////////////////////////////
extern "C" BOOL _stdcall GetCounterInfo(DWORD iCounter, USERCOUNTERINFO *pInfo)

{
    // we only have two counters to set up
    if (iCounter > 1)
        return FALSE;

    pInfo->dwSize = sizeof(USERCOUNTERINFO);
    pInfo->bSynchronized = TRUE;

    if (0 == iCounter)
    {
        // SETUP COUNTER 0
        strcpy(pInfo->szCounterFuncName, "GetCounterOneValue");
        strcpy(pInfo->szName, "Mem Allocs");
        pInfo->ct = MonotonicallyIncreasing;
    }
    else // 1 == iCounter
    {
        // SETUP COUNTER 1
        strcpy(pInfo->szCounterFuncName, "GetCounterTwoValue");
        strcpy(pInfo->szName, "Byte Allocs");
        pInfo->ct = RandomIncreasing;
    }

    // We didn't do anything here that could fail, at least nothing
    // that wouldn't be catistrophic.  So just return TRUE.
    //
    return TRUE;
}

extern  "C" 
VOID _stdcall 
MC_LogAllocation(UINT size)
{
    //
    //  Get data pointer from TLS slot and update counts for this thread.
    if (g_dwTlsSlot != 0xffffffff)
    {
        SAllocInfo *pAllocInfo = (SAllocInfo *)TlsGetValue(g_dwTlsSlot);

        if (pAllocInfo != NULL)
        {
            pAllocInfo->cntAllocs++;
            pAllocInfo->cntBytes += size;
        }
    }
}

extern "C"
BOOL
_stdcall
InitCounters(void)
{

    return TRUE;
}



#define PcTeb                         0x18


//-----------------------------------------------------------------------------
// GetCounterOneValue
//
// Return current value for first counter - number of CRT allocs
//
// History:  9-16-98 MHotchin Created
//
//-----------------------------------------------------------------------------
//
extern "C"
COUNTER
_declspec(naked) _stdcall
GetCounterOneValue(void)
{
    _asm
    {
        mov eax, g_dwTlsIndexSize       // Load TLS slot offset
        add eax, fs:[PcTeb]             // Load pointer to TLS slot
        mov eax, [eax]                  // Load Data pointer from TLS slot
        je NoSample                     // If NULL, skip

        mov edx, dword ptr [eax+0x04]   // High word of # allocs
        mov eax, dword ptr [eax]        // Low word of # allocs

        ret
    NoSample:
        mov eax, 0
        mov edx, 0

        ret
    }
}


//-----------------------------------------------------------------------------
// GetCounterTwoValue
//
//  Return current value of second counter - number of bytes allocated.
//
// History:  9-16-98 MHotchin Created
//
//-----------------------------------------------------------------------------
extern "C"
COUNTER
_declspec(naked) _stdcall
GetCounterTwoValue(void)
{
    _asm
    {
        mov eax, g_dwTlsIndexSize       // Load TLS slot offset
        add eax, fs:[PcTeb]             // Load pointer to TLS slot
        mov eax, [eax]                  // Load Data pointer from TLS slot
        je NoSample                     // If NULL, skip

        mov edx, dword ptr [eax+0x0c]   // High wors of # bytes
        mov eax, dword ptr [eax+0x08]   // Low word of # bytes

        ret
    NoSample:
        mov eax, 0
        mov edx, 0

        ret
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\test\thumbtst\thumbtst.cpp ===
//
// Simple test program for imaging library
//

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windows.h>
#include <objbase.h>
#include <urlmon.h>
#include <commdlg.h>
#include <math.h>

#include <gdiplus.h>
#include <gdiplusflat.h>

using namespace Gdiplus;
#include "../gpinit.inc"

#define     k_DefaultWidth  720
#define     k_DefaultHeight 480
#define     THUMBSIZE       120
#define     MAX_FILENAME    1000

CHAR*       g_pcProgramName = NULL;     // program name
HINSTANCE   g_hAppInstance;             // handle to the application instance
HWND        g_hwndMain;                 // handle to application's main window

int         g_iTotalNumOfImages;
int         lastS;
int         numX;
int         g_iNumFileNames;

Image**     g_ppThumbImages;
CHAR**      g_ppcInputFilenames;
RECT        g_ThumbRect;

BOOL        g_fVerbose = FALSE;
BOOL        g_fHighQualityThumb = FALSE;

#define ERREXIT(args)   { printf args; exit(-1); }
#define VERBOSE(args) printf args

//
// Helper class to convert ANSI strings to Unicode strings
//

inline BOOL
UnicodeToAnsiStr(
    const WCHAR*    unicodeStr,
    CHAR*           ansiStr,
    INT             ansiSize
    )
{
    return WideCharToMultiByte(CP_ACP, 0, unicodeStr, -1, ansiStr, ansiSize,
                               NULL, NULL) > 0;
}

inline BOOL
AnsiToUnicodeStr(
    const CHAR*     ansiStr,
    WCHAR*          unicodeStr,
    INT             unicodeSize
    )
{
    return MultiByteToWideChar(CP_ACP, 0, ansiStr, -1, unicodeStr,
                               unicodeSize) > 0;
}


class UnicodeStrFromAnsi
{
public:

    UnicodeStrFromAnsi(const CHAR* ansiStr)
    {
        if (ansiStr == NULL)
        {
            valid = TRUE;
            unicodeStr = NULL;
        }
        else
        {
            // NOTE: we only handle strings with length < MAX_PATH.

            valid = AnsiToUnicodeStr(ansiStr, buf, MAX_PATH);
            unicodeStr = valid ? buf : NULL;
        }
    }

    BOOL IsValid() const
    {
        return valid;
    }

    operator WCHAR*()
    {
        return unicodeStr;
    }

private:

    BOOL valid;
    WCHAR* unicodeStr;
    WCHAR buf[MAX_PATH];
};

//
// Create thumbnails for the specified list of files
//

VOID
DrawThumbnails(
    const RECT  rect,
    HDC         hdc
    )
{
    if ( (rect.bottom - rect.top <= 0) || (rect.right - rect.left <= 0) )
    {
        return;
    }

    // Figure out how many rows and columns we need to divide in order to put
    // "g_iTotalNumOfImages" images within the fixed size "rect"
    // Basically "iNumColumns" * "iNumRows" should >= "g_iTotalNumOfImages"

    int iWindowWidth = rect.right - rect.left;
    int iWindowHeight = rect.bottom - rect.top;

    int iSum = 1;
    while ( ((iWindowWidth / iSum) * (iWindowHeight / iSum))
            >= g_iTotalNumOfImages )
    {
        iSum++;
    }

    iSum--;

    int iNumColumns = iWindowWidth / iSum;
    int iNumRows = iWindowHeight / iSum;

    lastS = iSum;           // Reset the global
    numX = iNumColumns;     // Reset the global

    Graphics* pGraphics = new Graphics(g_hwndMain);
    
    int x = 0;
    int y = 0;

    for ( int i = 0; i < g_iTotalNumOfImages; i++ )
    {
        if ( NULL == g_ppThumbImages[i] ) 
        {
            // Bad image. But we still leave the position for it so that it can
            // be easily noticed

            x++;
            if (x >= iNumColumns)
            {
                x = 0;
                y++;
            }
            
            continue;
        }
        
        // Copy thumbnail bitmap image data to offscreen memory DC

        int tx;
        int ty;

        SizeF size;
        g_ppThumbImages[i]->GetPhysicalDimension(&size);

        float dAspect = size.Width / size.Height;
        RECT r;

        if ( dAspect > 1 )
        {
            tx = iSum;
            ty = (int)(iSum / dAspect);
            int d = (iSum - ty) / 2;
            r.left = x * iSum;
            r.top = y * iSum + d;
            r.right = x * iSum + tx;
            r.bottom = y * iSum + ty + d;
        }
        else
        {
            ty = iSum;
            tx = (int)(iSum * dAspect);
            int d = (iSum - tx) / 2;
            r.left = x * iSum + d;
            r.top = y * iSum;
            r.right = x * iSum + tx + d;
            r.bottom = y * iSum + ty;
        }
        
        if ( g_fHighQualityThumb == FALSE )
        {
            Rect    dstRect(r.left, r.top, tx, ty);

            pGraphics->DrawImage(g_ppThumbImages[i],
                                 dstRect,
                                 0,
                                 0,
                                 (UINT)g_ppThumbImages[i]->GetWidth(),
                                 (UINT)g_ppThumbImages[i]->GetHeight(),
                                 UnitPixel,
                                 NULL,
                                 NULL,
                                 NULL);
        }
        else
        {
            // Generate high quality thumbnail based on required size

            Bitmap*     dstBmp = new Bitmap(tx, ty, PixelFormat32bppPARGB);
            Graphics*   gdst = new Graphics(dstBmp);

            // Ask the source image for it's size.

            int width = g_ppThumbImages[i]->GetWidth();
            int height = g_ppThumbImages[i]->GetHeight();

            // Compute the optimal scale factor without changing the aspect ratio

            float scalex = (float)width / tx;
            float scaley = (float)height / ty;
            float scale = min(scalex, scaley);

            Rect dstRect(0, 0, tx, ty);

            // Set the resampling quality to the bicubic filter

            gdst->SetInterpolationMode(InterpolationModeHighQualityBicubic);

            // Set the compositing quality to copy source pixels rather than
            // alpha blending. This will preserve any alpha in the source image.

            gdst->SetCompositingMode(CompositingModeSourceCopy);

            ImageAttributes imgAttr;
            imgAttr.SetWrapMode(WrapModeTileFlipXY);

            // Draw the source image onto the destination with the correct scale
            // and quality settings.

            GpStatus status = gdst->DrawImage(g_ppThumbImages[i], 
                                              dstRect, 
                                              0,
                                              0,
                                              INT((tx * scale) + 0.5),
                                              INT((ty * scale) + 0.5),
                                              UnitPixel,
                                              &imgAttr);

            if( status != Ok )
            {
                printf("Error drawing the image\n");
                continue;
            }

            // Draw the result onto the screen

            Rect drawDstRect(r.left, r.top, tx, ty);

            pGraphics->DrawImage(dstBmp,
                                 drawDstRect,
                                 0,
                                 0,
                                 (UINT)dstBmp->GetWidth(),
                                 (UINT)dstBmp->GetHeight(),
                                 UnitPixel,
                                 NULL,
                                 NULL,
                                 NULL);

            delete dstBmp;
            delete gdst;
        }

        x++;
        if (x >= iNumColumns)
        {
            x = 0;
            y++;
        }
    }// Loop through all the thumbnail images to draw

    delete pGraphics;
}

//
// Handle window repaint event
//

VOID
DoPaint(
    HWND hwnd
    )
{
    HDC         hdc;
    PAINTSTRUCT ps;
    RECT        rect;

    hdc =       BeginPaint(hwnd, &ps);

    GetClientRect(hwnd, &rect);

    const RECT  r = {rect.left, rect.top, rect.right, rect.bottom};
    DrawThumbnails(r, hdc);

    EndPaint(hwnd, &ps);
}// DoPaint()

//
// Window callback procedure
//

LRESULT CALLBACK
MyWindowProc(
    HWND    hwnd,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    int index=0;
    
    switch (uMsg)
    {
    case WM_PAINT:
        DoPaint(hwnd);
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    case WM_LBUTTONDBLCLK:
        if (lastS == 0) 
        {
            lastS = 1;
        }
        index = (HIWORD(lParam) / lastS) * numX + (LOWORD(lParam) / lastS);
        
        if (index < g_iNumFileNames) 
        {
            char cmdLine[MAX_FILENAME];
            strcpy(cmdLine, "frametest ");
            strcat(cmdLine, g_ppcInputFilenames[index]);
            WinExec(cmdLine, SW_SHOWNORMAL);
        }
        break;

    case WM_SIZE:
        SendMessage(g_hwndMain, WM_ERASEBKGND, WPARAM(GetDC(g_hwndMain)), NULL);

        InvalidateRect(g_hwndMain, NULL, FALSE);

        break;

    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0;
}


//
// Create main application window
//

#define MYWNDCLASSNAME "ThumbTst"

VOID
CreateMainWindow(
    VOID
    )
{
    // Use a hatch brush as background so that we can get transparent info
    // from the source image

    HBRUSH hBrush = CreateHatchBrush(HS_HORIZONTAL,
                                     RGB(0, 200, 0));

    // Register window class

    WNDCLASS wndClass =
    {
        CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS,
        MyWindowProc,
        0,
        0,
        g_hAppInstance,
        LoadIcon(NULL, IDI_APPLICATION),
        LoadCursor(NULL, IDC_ARROW),
        hBrush,
        NULL,
        MYWNDCLASSNAME
    };

    RegisterClass(&wndClass);

    // Calculate default window size

    INT iWidth = g_ThumbRect.right + 2 * GetSystemMetrics(SM_CXFRAME);

    INT iHeight = g_ThumbRect.bottom
                + 2 * GetSystemMetrics(SM_CYFRAME)
                + GetSystemMetrics(SM_CYCAPTION);

    // Create application window

    g_hwndMain = CreateWindow(MYWNDCLASSNAME,
                              MYWNDCLASSNAME,
                              WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              iWidth,
                              iHeight,
                              NULL,
                              NULL,
                              g_hAppInstance,
                              NULL);
}// CreateMainWindow()

void
DisplayImageInfo(
    Image* pImage
    )
{
    UINT    uiImagePixelFormat = pImage->GetPixelFormat();
    UINT    uiImageFlags = pImage->GetFlags();

    VERBOSE(("Width = %d\n", pImage->GetWidth()));
    VERBOSE(("Width = %d\n", pImage->GetHeight()));

    // Pixel format

    switch ( uiImagePixelFormat )
    {
    case PixelFormat1bppIndexed:
        VERBOSE(("Color depth: 1 BPP INDEXED\n"));

        break;

    case PixelFormat4bppIndexed:
        VERBOSE(("Color depth: 4 BPP INDEXED\n"));

        break;

    case PixelFormat8bppIndexed:
        VERBOSE(("Color depth: 8 BPP INDEXED\n"));

        break;

    case PixelFormat16bppGrayScale:
        VERBOSE(("Color depth: 16 BPP GRAY SCALE\n"));

        break;

    case PixelFormat16bppRGB555:
        VERBOSE(("Color depth: 16 BPP RGB 555\n"));

        break;

    case PixelFormat16bppRGB565:
        VERBOSE(("Color depth: 16 BPP RGB 565\n"));

        break;

    case PixelFormat16bppARGB1555:
        VERBOSE(("Color depth: 16 BPP ARGB 1555\n"));

        break;

    case PixelFormat24bppRGB:
        VERBOSE(("Color depth: 24 BPP RGB\n"));

        break;

    case PixelFormat32bppARGB:
        VERBOSE(("Color depth: 32 BPP ARGB\n"));

        break;

    case PixelFormat32bppPARGB:
        VERBOSE(("Color depth: 32 BPP PARGB\n"));

        break;

    case PixelFormat48bppRGB:
        VERBOSE(("Color depth: 48 BPP PARGB\n"));

    case PixelFormat64bppARGB:
        VERBOSE(("Color depth: 64 BPP ARGB\n"));

        break;

    case PixelFormat64bppPARGB:
        VERBOSE(("Color depth: 64 BPP PARGB\n"));

        break;

    default:
        VERBOSE(("Unknown color depth\n"));
        break;
    }// Color format

    // Physical dimension info

    VERBOSE(("X DPI (dots per inch) = %f\n",pImage->GetHorizontalResolution()));
    VERBOSE(("Y DPI (dots per inch) = %f\n",pImage->GetVerticalResolution()));
    
    // Pixel size

    if ( uiImageFlags & ImageFlagsHasRealPixelSize )
    {
        VERBOSE(("---The pixel size info is from the original image\n"));
    }
    else
    {
        VERBOSE(("---The pixel size info is NOT from the original image\n"));
    }

    // DPI info

    if ( uiImageFlags & ImageFlagsHasRealPixelSize )
    {
        VERBOSE(("---The pixel size info is from the original image\n"));
    }
    else
    {
        VERBOSE(("---The pixel size info is NOT from the original image\n"));
    }

    // Transparency info

    if ( uiImageFlags & ImageFlagsHasAlpha )
    {
        VERBOSE(("This image contains alpha pixels\n"));

        if ( uiImageFlags & ImageFlagsHasTranslucent )
        {
            VERBOSE(("---It has non-0 and 1 alpha pixels (TRANSLUCENT)\n"));
        }
    }
    else
    {
        VERBOSE(("This image does not contain alpha pixels\n"));
    }

    // Display color space

    if ( uiImageFlags & ImageFlagsColorSpaceRGB )
    {
        VERBOSE(("This image is in RGB color space\n"));
    }
    else if ( uiImageFlags & ImageFlagsColorSpaceCMYK )
    {
        VERBOSE(("This image is in CMYK color space\n"));
    }
    else if ( uiImageFlags & ImageFlagsColorSpaceGRAY )
    {
        VERBOSE(("This image is a gray scale image\n"));
    }
    else if ( uiImageFlags & ImageFlagsColorSpaceYCCK )
    {
        VERBOSE(("This image is in YCCK color space\n"));
    }
    else if ( uiImageFlags & ImageFlagsColorSpaceYCBCR )
    {
        VERBOSE(("This image is in YCBCR color space\n"));
    }
}// DisplayImageInfo()

//
// Create thumbnails for the specified list of files
//

VOID
CreateThumbnails(
    CHAR** ppcFilenames
    )
{
    // Generate thumbnails

    UINT    uiTimer;
    if ( g_fVerbose == TRUE )
    {
        uiTimer = GetTickCount();
    }

    g_ppThumbImages = new Image*[g_iTotalNumOfImages];
    Image* pSrcImage = NULL;

    // Loop through all the images and generate thumbnail

    for ( int i = 0; i < g_iTotalNumOfImages; i++ )
    {
        g_ppThumbImages[i] = NULL;
        
        // Get a Unicode file name

        UnicodeStrFromAnsi namestr(ppcFilenames[i]);

        VERBOSE(("Loading - %s\n", ppcFilenames[i]));

        if ( namestr.IsValid() == FALSE )
        {
            VERBOSE(("Couldn't open image file: %s\n", ppcFilenames[i]));
            continue;
        }
        else if ( g_fHighQualityThumb == FALSE )
        {
            pSrcImage = new Image(namestr, TRUE);
        
            if ( (pSrcImage == NULL) || (pSrcImage->GetLastStatus() != Ok) )
            {
                VERBOSE(("Couldn't open image file: %s\n", ppcFilenames[i]));
                if ( pSrcImage != NULL )
                {
                    delete pSrcImage;
                    pSrcImage = NULL;
                }

                continue;
            }

            if ( g_fVerbose == TRUE )
            {
                DisplayImageInfo(pSrcImage);
            }

            // Get build in thumbnail image if there is one. Otherwise, GDI+
            // will generate one for us

            g_ppThumbImages[i] = pSrcImage->GetThumbnailImage(0, 0, NULL, NULL);
            delete pSrcImage;
            pSrcImage = NULL;
        }
        else
        {
            // High quality thumbnail images. We don't generate it here

            g_ppThumbImages[i] = new Image(namestr, TRUE);
            
            if ( g_ppThumbImages[i] == NULL )
            {
                VERBOSE(("Couldn't open image file: %s\n", ppcFilenames[i]));
                continue;
            }

            if ( g_fVerbose == TRUE )
            {
                DisplayImageInfo(g_ppThumbImages[i]);
            }
        }
    }// Loop through all the images

    if ( g_fVerbose == TRUE )
    {
        uiTimer = GetTickCount() - uiTimer;
        VERBOSE(("Generate %d thumbnails in %dmsec\n", g_iTotalNumOfImages,
                uiTimer));
    }
}// CreateThumbnails

void
USAGE()
{
    printf("******************************************************\n");
    printf("Usage: thumbtst [-?] [-v] ImageFileNames\n");
    printf("-v                        Verbose image information output\n");
    printf("-h                        Generate higher quality thumbnail\n");
    printf("-?                        Print this usage message\n");
    printf("ImageFileNames            Files to be opened\n\n");
    printf("Sample usage:\n");
    char myChar = '\\';
    printf("    thumbtst.exe c:%cpublic%c*.jpg\n", myChar, myChar);
}// USAGE()

char html_header[1024] = "<html>\n<head>\n <title>My Fun Photo Album</title>\n</head>\n</html>\0";

void
OutputHTML()
{
    FILE*    hFile = fopen("mytest.html", "w");
    if ( hFile == NULL )
    {
        return;
    }

    fprintf(hFile, "%s", html_header);
    fclose(hFile);
}// OutputHTML()

void
ValidateArguments(
    int   argc,
    char* argv[]
    )
{
    g_pcProgramName = *argv++;
    argc--;
    g_hAppInstance = GetModuleHandle(NULL);

    while ( argc > 0 )
    {
        if ( strcmp(*argv, "-v") == 0 )
        {
            argc--;
            argv++;

            g_fVerbose = TRUE;
        }
        else if ( strcmp(*argv, "-h") == 0 )
        {
            argc--;
            argv++;

            g_fHighQualityThumb = TRUE;
        }
        else if ( strcmp(*argv, "-?") == 0 )
        {
            USAGE();
            exit(1);
        }
        else
        {
            // Get the pointer to image file list

            g_ppcInputFilenames = argv;
            g_iNumFileNames = argc;

            // Total number of images
            // Note: if you do "thumbtst.exe c:\temp\*.jpg", this argc is
            // actually the total number of images in that dir. While in argv,
            // it points to each image under that dir

            g_iTotalNumOfImages = argc;
            
            return;
        }
    }// while (argc > 0 )

    if ( argc == 0 )
    {
        USAGE();
        exit(1);
    }
    
    return;
}// ValidateArguments()

//
// Main program entrypoint
//

INT _cdecl
main(
    INT     argc,
    CHAR**  argv
    )
{
    ValidateArguments(argc, argv);

    g_ThumbRect.left = 0;
    g_ThumbRect.top = 0;
    g_ThumbRect.right = k_DefaultWidth;
    g_ThumbRect.bottom = k_DefaultHeight;

    // Generate thumbnail images and store it in g_ppThumbImages

    CreateThumbnails(g_ppcInputFilenames);

    // Create the main application window

    CreateMainWindow();

//    OutputHTML();

    // Main message loop

    MSG msg;

    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    // Clean up
    // Note: above while loop won't finish until we don't have any messages

    for ( int i = 0; i < g_iTotalNumOfImages; i++ )
    {
        if ( NULL != g_ppThumbImages[i] ) 
        {
            delete g_ppThumbImages[i];
        }
    }

    delete [] g_ppThumbImages;

    return (INT)(msg.wParam);
}// main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\tools\memcounter\memcounter.h ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Memory allocation profiling support
*
* Abstract:
*
*   Declares logging functions used for memory allocation profiling.
*   This is only enabled when PROFILE_MEMORY_USAGE is set.
*   See memcounter.cpp for more details.
*
* Notes:
*
*   I've added calls to MC_LogAllocation to most of our allocation sites.
*   These are the omissions I'm aware of:
*     runtime\debug.cpp - it's chk only.
*     gpmf3216\* - (calls LocalAlloc) I think it's a separate lib.
*     entry\create.cpp - calls GlobalAlloc (a single tiny allocation).
*     imaging\pwc\pwclib - many calls to LocalAlloc.
*     text\uniscribe\usp10\usp_mem.cxx - DBrown says that GDI+ never this
*         allocation code.
*
* Created:
*
*   06/08/2000 agodfrey
*      Created it.
*
**************************************************************************/

#ifndef _PROFILEMEM_H
#define _PROFILEMEM_H

#if PROFILE_MEMORY_USAGE

#ifdef __cplusplus
extern "C" {
#endif

VOID _stdcall MC_LogAllocation(UINT size);

#ifdef __cplusplus
}
#endif

#endif // PROFILE_MEMORY_USAGE

#endif // _PROFILEMEM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\debug.h ===
//
//
//

#define LOGCAT_LOADER 1
#define LOGCAT_CONSTRUCT 2
#define LOGCAT_RUNTIME 4
#define LOGCAT_RESIZE  8
#define LOGCAT_CLIPPING  16

#ifdef _DEBUG
void FAR _cdecl 
TRACE(
	LPTSTR lpszFormat, 
	...);

#else
#define TRACE 0?0:
#endif

// #ifdef _DEBUG
void FAR _cdecl 
EVENTLOG(
	WORD wType, WORD id, WORD cat,
	LPTSTR lpszComponent,
	LPTSTR lpszFormat, 
	...);


/*
#else
#define EVENTLOG 0?0:
#endif
*/

#ifdef _DEBUG
#define ASSERT 0?0:
#else
#define ASSERT 0?0:
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\debug.cpp ===
//
//
//

#include "stdafx.h"
#include "debug.h"
#include "eventlog.h"

#ifdef _DEBUG
// #define _MEM_DEBUG 1

#ifdef _MEM_DEBUG
DWORD   g_dwAlloced=0;
DWORD   g_dwFreed=0;
DWORD   g_dwCurrent=0;
DWORD   g_dwMax=0;
DWORD   g_dwAllocCalls=0;
DWORD   g_dwFreeCalls=0;

void operator delete(void * pData)
{
    LPDWORD pres=(LPDWORD)pData;
    g_dwFreeCalls++;
    if(pData!=NULL)
    {
	    TRACE(TEXT("Free 0x%08x size 0x%08x\n"), pData, *(pres-1));
        g_dwFreed+=*(pres-1);
        g_dwCurrent-=*(pres-1);
        free(pres-1);
    }
}

void * operator new( unsigned int cb )
{
    // void *res = _nh_malloc( cb, 1 );
	TRACE(TEXT("Allocate 0x%08x\n"), cb);
    LPDWORD res=(LPDWORD)malloc( cb+4 );
    *res=cb;
    g_dwAlloced+=cb;
    g_dwCurrent+=cb;
    if(g_dwCurrent > g_dwMax )
        g_dwMax=g_dwCurrent;
    g_dwAllocCalls++;
    if( cb > 0x100 )
    {
        TRACE(TEXT("Thats big! 0x%08x\n"), cb );
    }
    return res+1;
}
#endif


void FAR _cdecl 
TRACE(
	LPTSTR lpszFormat, 
	...) 
{
	TCHAR	szBuf[1024];
	int	cchAdd;

	cchAdd = wvsprintf((LPTSTR)szBuf, lpszFormat, (LPSTR)(&lpszFormat + 1));
	OutputDebugString((LPCTSTR)szBuf);
}

#endif


void FAR _cdecl 
EVENTLOG(
	WORD wType,	WORD cat, WORD id, 
	LPTSTR lpszComponent,
	LPTSTR lpszFormat, 
	...)
{
	TCHAR	szBuf[1024];
	int		cchAdd;

	cchAdd = wvsprintf((LPTSTR)szBuf, lpszFormat, (LPSTR)(&lpszFormat + 1));

    g_EventLog.Log( wType, cat, id, lpszComponent, szBuf );

#ifdef _DEBUG
	OutputDebugString((LPCTSTR)szBuf);
    OutputDebugString(TEXT("\r\n"));
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\dialogrenderer.h ===
// DialogRenderer.h: interface for the CDialogRenderer class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DIALOGRENDERER_H__D363C68F_C6A8_11D2_84D1_00C04FB177B1__INCLUDED_)
#define AFX_DIALOGRENDERER_H__D363C68F_C6A8_11D2_84D1_00C04FB177B1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// #include "win32renderer.h"
#include "fonts.h"

//
// Abstraction of the dialog resource / template code.
//
class CDialogRenderer  
{
public:
	void ResetTemplate();
	CDialogRenderer();
	virtual ~CDialogRenderer();

	//
	// Builds the dialog template header, and allocates space for the items to add
	// the header contains the title, and the fontname, and size.
	//
	void	BuildDialogTemplate( LPCTSTR pszTitle, WORD width, WORD height, DWORD dwStyle, DWORD dwStyleEx, LPCTSTR pszFont, DWORD fontSize, LPCTSTR pszMenu, LPCTSTR pszClass );

	//
	// Position controls on the dialog.
	//
	// By default we use the X and Y maintained by the dialog, using the Indent, NextLine
	// functions to 'move' around the dialog.
	void	AddDialogControl( DWORD dwStyle, SHORT x, SHORT y, 
                           SHORT cx, SHORT cy, WORD id,  
                           LPCTSTR strClassName, LPCTSTR strTitle=NULL, DWORD dwExStyle=0 ) ;

	//
	// For displaying the actual dialog
	//
	DLGTEMPLATE *		GetDlgTemplate() const { return m_pDlg; }
	DWORD				GetTemplateSize() { return m_dwSize; }

protected:
	//
	// The base (or header of the dialog template).
	//
	void				AllocTemplate(DWORD dwNewSize);
	void				SetDlgTemplate( DLGTEMPLATE * p ) { m_pDlg=p; }
	DLGTEMPLATE *		m_pDlg;
	DWORD				m_dwSize;

	//
	// The dialog items are added to the allocated space in a linear DWORD aligned way.
	//
	DLGITEMTEMPLATE *	GetNextDlgItem() { return m_pNextDlgItem; }
	void				SetNextDlgItem( DLGITEMTEMPLATE * p ) { m_pNextDlgItem=(DLGITEMTEMPLATE *)((((((ULONG)(p))+3)>>2)<<2)); }
	DLGITEMTEMPLATE *	m_pNextDlgItem;

};

#endif // !defined(AFX_DIALOGRENDERER_H__D363C68F_C6A8_11D2_84D1_00C04FB177B1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\dialogrenderer.cpp ===
// DialogRenderer.cpp: implementation of the CDialogRenderer class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DialogRenderer.h"
#include "utils.h"


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDialogRenderer::CDialogRenderer()
: m_dwSize(0)
{
	SetDlgTemplate(NULL);
}

CDialogRenderer::~CDialogRenderer()
{
	if(GetDlgTemplate() )
		delete GetDlgTemplate();
}


////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Adds a control onto the dialog
// ensures the control is not too wide for the dialog so far.
//
// Params:
//	ID	the ID to use, if 0, assigns the next free ID.
//
// BUGBUG:
//	Need to move the m_dq processing to the DUMP method
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDialogRenderer::AddDialogControl( 
	DWORD dwStyle, SHORT x, SHORT y, 
    SHORT cx, SHORT cy, WORD id,  
    LPCTSTR strClassName, LPCTSTR strTitle, DWORD dwExStyle ) 
{ 
	DLGTEMPLATE * pDlgTemplate;
	DLGITEMTEMPLATE * pDlgItem;
	TCHAR *	pszText;

	//
	// Ensure we have enough space to place this control.
	//
	
	LPBYTE pTop=(LPBYTE)GetNextDlgItem();
	LPBYTE pBottom=(LPBYTE)GetDlgTemplate();

	DWORD	dwNeeds=sizeof(DLGITEMTEMPLATE)+0x100;
    if( HIWORD(strTitle) )
        dwNeeds+=lstrlen(strTitle)*sizeof(TCHAR);
    if(HIWORD(strClassName) )
        dwNeeds+=lstrlen(strClassName)*sizeof(TCHAR);


	//
	// If we're going to overrun the buffer, reallocate the dilaog again.
	//
	if( m_dwSize-(pTop-pBottom) < dwNeeds )
	{
		AllocTemplate(m_dwSize*2);
	}
	pDlgTemplate=GetDlgTemplate();
	pDlgItem= GetNextDlgItem();

	//
	// Fill the struct with the dlgItem information.
	//
    pDlgItem->style           = dwStyle ; //
    pDlgItem->dwExtendedStyle = dwExStyle; 
    pDlgItem->x               = x; // GetDlgUnitsFromPixelX(x); 
    pDlgItem->y               = y; // GetDlgUnitsFromPixelY(y); 
    pDlgItem->cx              = cx; // GetDlgUnitsFromPixelX(cx); 
    pDlgItem->cy              = cy; // GetDlgUnitsFromPixelY(cy); 
    pDlgItem->id              = id; 

	//
	// Text is copied to end of struct - struct is word aligned.
	//
	pszText = (TCHAR*)(pDlgItem+1);
    if(HIWORD(strClassName) )
    {
        CopyToWideChar( (WCHAR**)&pszText, strClassName ); // Set Class name 
    }
    else
    {
        WORD * pWord=(WORD*)pszText;
        *pWord++=0xffff;
        *pWord++=(WORD)strClassName;
        pszText=(LPTSTR)pWord;
    }

    if(HIWORD(strTitle))
    {
        CopyToWideChar( (WCHAR**)&pszText, strTitle );     // Set Title 
	    pszText++;
    }
    else
    {
        WORD * pWord=(WORD*)pszText;
	    *pWord++ = 0xffff;
	    *pWord++ = (WORD)strTitle;
	    // *pWord++ = 0;
        pszText=(LPTSTR)pWord;
    }

	//
	// Note where the next dialog item starts.
	//
	SetNextDlgItem((DLGITEMTEMPLATE*)pszText);

	//
	// We added a new control!
	//
	GetDlgTemplate()->cdit+=1;
} 


////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Allocates the template of the desired size
// Copies the data down if required
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDialogRenderer::AllocTemplate(DWORD dwNewSize)
{
	if(GetDlgTemplate())
	{
		//
		// Realloc the data.
		//
		LPBYTE pTop=(LPBYTE)GetNextDlgItem();
		LPBYTE pBottom=(LPBYTE)GetDlgTemplate();

		LPBYTE pNew=(LPBYTE)new BYTE[dwNewSize];
		ZeroMemory( pNew, dwNewSize ); 
		CopyMemory( pNew, pBottom, m_dwSize );	// current size
		m_dwSize=dwNewSize;						// new size
		
		SetNextDlgItem( (DLGITEMTEMPLATE*)(pTop-pBottom+pNew) );	// next dialog item
		SetDlgTemplate( (DLGTEMPLATE*)pNew);						// where the template is now.
		delete [] pBottom;						// old Data.
	}
	else
	{
		//
		// First time round
		//
		m_dwSize=dwNewSize;
		LPBYTE pNew= new BYTE[m_dwSize]; 
		ZeroMemory( pNew, m_dwSize ); 
		delete [] GetDlgTemplate();
		SetDlgTemplate( (DLGTEMPLATE*)pNew);
		LPBYTE pb=(LPBYTE)GetDlgTemplate();
		// TRACE(TEXT("DlgTemplate delta 0x%08x\n"),pb-pNew);
	}
}

 

////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Builds a dialog template.
// Uses the supplied Title, Width and Font.
// Defaults to using the Font information from m_font
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDialogRenderer::BuildDialogTemplate( LPCTSTR pszTitle, WORD width, WORD height, DWORD dwStyle, DWORD dwStyleEx, LPCTSTR pszFont, DWORD fontSize, LPCTSTR pszMenu, LPCTSTR pszClass )
{
	//
	// A new dialog is created.
	//
	AllocTemplate(1024);        // some made up initial number.

    //
    // Fill in the DLGTEMPLATE info 
    //
    DLGTEMPLATE* pdt     = GetDlgTemplate(); 

    pdt->style           = dwStyle ;
    pdt->dwExtendedStyle = dwStyleEx; 

    pdt->cdit            = 0;           // Number of controls.
    pdt->x               = 0; 
    pdt->y               = 0;

    pdt->cx              = width;
    pdt->cy              = height;
 
	//
    // Add menu 
	//
    WORD* pw = (WORD*)(pdt+1); 
    if( pszMenu == NULL )
    {
        *pw++ = TEXT('\0');                              // Set Menu array to nothing 
    }
    else
    {
        if(HIWORD( pszMenu ) )
        {
        	CopyToWideChar( (WCHAR**)&pw, pszMenu );
        }
        else
        {
            *pw++ = 0xffff;
            *pw++ = LOWORD(pszMenu );
        }
    }

    //
    // Set Class array to nothing 
    //
    if( pszClass == NULL )
    {
        *pw++ = TEXT('\0');                              // Set Menu array to nothing 
    }
    else
    {
        if(HIWORD( pszClass ) )
        {
        	CopyToWideChar( (WCHAR**)&pw, pszClass );
        }
        else
        {
            *pw++ = 0xffff;
            *pw++ = LOWORD(pszClass );
        }
    }

    //
    // Title.
    //
	CopyToWideChar( (WCHAR**)&pw, pszTitle );

#undef DS_SHELLFONT
#define DS_SHELLFONT        (DS_SETFONT | DS_FIXEDSYS)

    //
    // Font setting
    //
    if( pszFont )
    {
        pdt->style |= DS_SETFONT;
        // | DS_SHELLFONT ;   // DS_SHELLFONT is used just in case is "MS Shell Dlg" - should be set by the RCML file.
		*pw++ = (WORD)fontSize ;                                  // Font Size 
	    CopyToWideChar( (WCHAR**)&pw, pszFont );	// Font Name 
    }

	//
	// Note where the first dialog item goes.
	//
	SetNextDlgItem((DLGITEMTEMPLATE*)pw);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/


#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( rcml )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( rcml ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\dlg.cpp ===
//
// CDlg
// 
// FelixA
//
// Used to be CDialog
//


#include "stdafx.h"
#include "dlg.h"
#include "win32dlg.h"

///////////////////////////////////////////////////////////////////////////////
//
// Sets the lParam to the 'this' pointer
// wraps up PSN_ messages and calls virtual functions
// calls off to your overridable DlgProc
//

BOOL CALLBACK CDlg::BaseDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
	// CDlg * pSV = (CDlg*)GetWindowLong(hDlg,DWL_USER);
	CDlg * pSV = (CDlg*)GetXMLPropertyPage(hDlg);

	switch (uMessage)
	{
		case WM_INITDIALOG:
		{
			pSV=(CDlg*)lParam;
			pSV->SetWindow(hDlg);
			// SetWindowLong(hDlg,DWL_USER,(LPARAM)pSV);
           	SetProp(hDlg, (LPCTSTR)g_atomXMLPropertyPage, (HANDLE)pSV);
			pSV->OnInit();
		}
		break;

		// Override the Do Command to get a nice wrapped up feeling.
		case WM_COMMAND:
			if(pSV)
				if( pSV->DoCommand(LOWORD(wParam),HIWORD(wParam)) == 0 )
					return 0;
		break;

		case WM_NOTIFY:
			if(pSV)
				return pSV->DoNotify((NMHDR FAR *)lParam);
		break;

		case WM_DESTROY:
			if(pSV)
				pSV->Destroy();
		break;
	}

    BOOL theirResult=FALSE;
	if(pSV)
		theirResult = pSV->DlgProc(hDlg,uMessage,wParam,lParam);

    // Now cleanup.
    if(uMessage==WM_DESTROY)
        RemoveProp( hDlg, (LPCTSTR)g_atomXMLPropertyPage);

    return theirResult;
}

///////////////////////////////////////////////////////////////////////////////
//
// You can override this DlgProc if you want to handle specific messages
//
BOOL CALLBACK CDlg::DlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
//
// Below are just default handlers for the virtual functions.
//
int CDlg::DoCommand(WORD wCmdID,WORD hHow)
{
/*
    if( hHow==0)
    {
	    switch( wCmdID )
	    {
		    case IDOK:
		    case IDCANCEL:
			    EndDialog(wCmdID);
		    break;
	    }
    }
*/
	return 1;	// not handled, just did Apply work.
}

void CDlg::OnInit()
{
}

CDlg::CDlg(int DlgID, HWND hWnd, HINSTANCE hInst)
: m_DlgID(DlgID),
  m_hParent(hWnd),
  m_Inst(hInst),
  m_bCreatedModeless(FALSE),
  m_hDlg(0)
{
}

//
//
//
int CDlg::Do()
{
	m_bCreatedModeless=FALSE;
	return DialogBoxParam( m_Inst,  MAKEINTRESOURCE(m_DlgID), m_hParent, (DLGPROC)BaseDlgProc, (LPARAM)this);
}

HWND CDlg::CreateModeless()
{
	if(m_hDlg)
		return m_hDlg;

	HWND hWnd=CreateDialogParam(m_Inst, MAKEINTRESOURCE(m_DlgID), m_hParent, (DLGPROC)BaseDlgProc,  (LPARAM)this);
	if(hWnd)
		m_bCreatedModeless=TRUE;
	return hWnd;
}

int CDlg::DoNotify(NMHDR * pHdr)
{
	return FALSE;
}

void CDlg::Destroy()
{
	if(m_bCreatedModeless)
	{
		if(m_hDlg)
			m_hDlg=NULL;
	}
	else
		m_hDlg=NULL;		// we're closing, so forget this?
}

CDlg::~CDlg()
{
	if(m_hDlg)
	{
		DestroyWindow(m_hDlg);
		m_hDlg=NULL;
	}
}

void CDlg::SetDlgID(UINT id)
{
	m_DlgID=id;
}

void CDlg::SetInstance(HINSTANCE hInst)
{
	m_Inst=hInst;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\edge.cpp ===
// Edge.cpp: implementation of the CEdge class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Edge.h"
#include "debug.h"
#include "persctl.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CEdge::CEdge()
: m_Guide( new CGuide() ), m_Attatched(NULL)
{
	SetGuide(m_Guide);
	m_bDeleteGuide=TRUE;
}

CEdge::~CEdge()
{
	if( m_bDeleteGuide )
		delete m_Guide;
	delete m_Attatched;
	m_Attatched=NULL;
}

CEdge::CEdge( int Position, int Axis, BOOL Flexible, int Offset)
: m_Guide( new CGuide(Position, Axis, Flexible) ), m_Attatched(NULL)
{
	SetOffsetFromGuide(Offset);
	SetGuide(m_Guide);
	m_bDeleteGuide=TRUE;
}

CEdge::CEdge( CGuide * pGuide, int Offset)
: m_Guide(pGuide), m_Attatched(NULL)
{
	SetOffsetFromGuide(Offset);
	SetGuide(m_Guide);
	m_bDeleteGuide=FALSE;
}

//
// Need to take all the attatched components from this guide, and
// add them to the other guide.
//
void	CEdge::SetGuide(CGuide * pGuide)
{ 
	//
	// We still have the same number of controls attatched to this edge
	// remove these controls from the guide.
	//
	if( pGuide != m_Guide )
	{
		TRACE(TEXT("Changing the guide - need to re-attatch?\n"));
		m_Guide->DeAttatch(this);
	}

	m_Guide=pGuide;
	pGuide->Attatch( this );
}

void CEdge::Attatch(CLayoutInfo * pC)
{
	if(m_Attatched==NULL)
		m_Attatched=new CControlList();
	m_Attatched->Append(pC);
}

int CEdge::Attatchment()
{
	CLayoutInfo * pControl;
	int iRet=0;
	int iNumControls=GetControlCount();
    CGuide * pThisGuide = GetGuide();
	while( --iNumControls >= 0)
	{
		pControl = GetControl(iNumControls);
		iRet |= pControl->Attatchment( pThisGuide );
	}
	return iRet;
}

int		CEdge::GetControlCount()
{
	if(m_Attatched)
		return m_Attatched->GetCount(); 
	return 0; 
}

CLayoutInfo	* CEdge::GetControl(int i)
{ 
	return m_Attatched->GetPointer(i); 
}


///////////////////////////////////////////////////////////////////////////////////
//
//
//
//////////////////////////////////////////////////////////////////////////////////
CEdgeCache::CEdgeCache()
{
	m_NumVert=0;
	m_NumHoriz=0;
}

CEdgeCache::~CEdgeCache()
{

}

CEdge *	CEdgeCache::Create(int Position, int Axis, int Flexible, int Offset)
{
	CEdge * pEdge=new CEdge(Position, Axis, Flexible, Offset);
	AddEdge(pEdge);
	return pEdge;
}

CEdge * CEdgeCache::Create( CGuide * pGuide, int Offset )
{
	CEdge * pEdge=new CEdge(pGuide, Offset);
	AddEdge(pEdge);
	return pEdge;
}

BOOL CEdgeCache::AddEdge(CEdge *pEdge)
{
	if( pEdge->IsHorizontal() )
		SetNumHoriz( GetNumHoriz() + 1 );
	else
		SetNumVert( GetNumVert() + 1 );
	return Append( pEdge );
}

/////////////////////////////////////////////////////////////////////////////////
//
//
//
/////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CGuide::CGuide()
 : m_Axis(0), m_Position(0), m_Flexible(FALSE)
{
	m_Attatched=NULL;
}

CGuide::~CGuide()
{
	delete m_Attatched;
	m_Attatched=NULL;
}

CGuide::CGuide(int Position, int Axis, BOOL Flexible)
{
	m_Attatched=NULL;
	SetPosition(Position);
	SetAxis(Axis);
	SetFlexible(Flexible);
}

//
// Guides remember what edges are attatched to them.
//
void CGuide::Attatch(CEdge * pEdge)
{
	if(m_Attatched==NULL)
		m_Attatched=new CEdgeList();
	m_Attatched->Append(pEdge);
}

BOOL CGuide::IsEqual(CGuide *pGuide)
{
	return pGuide == this;
}

void CGuide::Adjust(int adjust)
{
	SetPosition( GetPosition() + adjust );
}

int CGuide::NumAttatchments()
{
	if(m_Attatched==NULL)
		return 0;

	int iRet=0;
	int iCount=0;
	int iNumEdges= m_Attatched->GetCount();
	while( --iNumEdges>=0 )
	{
		CEdge * pEdge= GetEdge(iNumEdges);
		iRet += pEdge->GetControlCount();
	}
	return iRet;
}

#ifdef _DEBUG
//
// Attempts to work out if this is a top/bottom/left/right guide.
//
int CGuide::Attatchment()
{
	if(m_Attatched==NULL)
		return 0;

	int iRet=0;
	int iCount=0;
	int iNumEdges= m_Attatched->GetCount();
	while( --iNumEdges>=0 )
	{
		CEdge * pEdge= GetEdge(iNumEdges);
		iRet |= pEdge->Attatchment();
	}
	return iRet;
}
#endif

CEdge * CGuide::GetEdge(int i)
{
	if(m_Attatched==NULL)
		return NULL;
	return m_Attatched->GetPointer(i);
}

void CGuide::DeAttatch( CEdge * pEdge )
{
	//
	// Go throught the list - null our this edge - it's no longer ours.
	//
	int iCount=m_Attatched->GetCount();
	while (--iCount>=0)
	{
		CEdge * p=GetEdge(iCount);
		if(p==pEdge)
			m_Attatched->Remove(iCount);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\enumcontrols.cpp ===
// EnumControls.cpp: implementation of the CEnumControls class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "EnumControls.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\edge.h ===
// Edge.h: interface for the CEdge class.
//
//////////////////////////////////////////////////////////////////////

// ControlList.h: interface for the CControlList class.
//
//////////////////////////////////////////////////////////////////////

//
// REVIEW : Edge and Guide seem very intertwined - it's just confusing.
//

#if !defined(AFX_CONTROLLIST_H__7FF8C61F_86BC_11D1_96A5_00C04FB177B1__INCLUDED_)
#define AFX_CONTROLLIST_H__7FF8C61F_86BC_11D1_96A5_00C04FB177B1__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "list.h"
class CEdge;

class CControlList;

#endif // !defined(AFX_CONTROLLIST_H__7FF8C61F_86BC_11D1_96A5_00C04FB177B1__INCLUDED_)

//
// Guide Class
// 
#if !defined(AFX_GUIDE_H__B2F750E1_7AF5_11D1_96A4_00C04FB177B1__INCLUDED_)
#define AFX_GUIDE_H__B2F750E1_7AF5_11D1_96A4_00C04FB177B1__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CLayoutInfo;

#undef PROPERTY
#define PROPERTY(type, Name) void Set##Name( type v) { m_##Name=v; } type Get##Name() const {return m_##Name; }


//
// Guides are attributed to a side.
// When you're making an edge, really you should only use the slop
// if you're finding the right type of edge (e.g. right slop for right edges)
// otherwise close packed buttons share the same edge for left and right.
//
#define LEFT_AT 1
#define RIGHT_AT 2
#define TOP_AT 4
#define BOTTOM_AT 8

class CEdgeList;	// defined below.

class CGuide  
{
public:
#ifdef _DEBUG
    int Attatchment();              // once populated
#endif
	int NumAttatchments();          // once populated
	void Adjust(int adjust);
	BOOL IsEqual( CGuide * guide);
	void Attatch( CEdge * Control);
	void DeAttatch( CEdge * Control);
	CGuide();
	CGuide(int Position, int Axis, BOOL Flexible);
	virtual ~CGuide();
	PROPERTY(int, Axis);
	PROPERTY(int, Position);
	PROPERTY(BOOL, Flexible);

	CEdge * GetEdge(int i);

	BOOL IsHorizontal() { return m_Axis & ( BOTTOM_AT | TOP_AT ) ; }
	BOOL IsVertical() { return m_Axis & ( LEFT_AT | RIGHT_AT ) ; }


protected:
	int	m_Axis;
	int m_Position;
	BOOL m_Flexible;

private:
	CEdgeList * m_Attatched;		// list of the controls attatched to this edge.
};

#endif // !defined(AFX_GUIDE_H__B2F750E1_7AF5_11D1_96A4_00C04FB177B1__INCLUDED_)

#if !defined(AFX_EDGE_H__B2F750E2_7AF5_11D1_96A4_00C04FB177B1__INCLUDED_)
#define AFX_EDGE_H__B2F750E2_7AF5_11D1_96A4_00C04FB177B1__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define PROPERTY(type, Name) void Set##Name( type v) { m_##Name=v; } type Get##Name() const {return m_##Name; }

class CEdge  
{
public:
	int Attatchment();
	void Attatch( CLayoutInfo * pC);
	CEdge();
	CEdge(int Position, int Axis, BOOL Flexible, int Offset);
	CEdge( CGuide * pGuide, int Offset);
	virtual ~CEdge();
	PROPERTY(int, OffsetFromGuide);
	int GetAxis() { return m_Guide->GetAxis(); }
	int GetPosition() { return m_Guide->GetPosition() + m_OffsetFromGuide; }
	BOOL GetFlexible() { return m_Guide->GetFlexible(); }
	void SetPosition(int p) { m_Guide->SetPosition(p); }

	CGuide	* GetGuide() { return m_Guide; }
	void	SetGuide(CGuide * pGuide);
	void	SetOffset(int i) { m_OffsetFromGuide = i ; }
	BOOL	IsHorizontal() { return m_Guide->IsHorizontal(); }
	BOOL	IsVertical() { return m_Guide->IsVertical(); }
	int		GetControlCount(); 
	CLayoutInfo	* GetControl(int i);

protected:
	CGuide * m_Guide;
	int		m_OffsetFromGuide;		// how far away we are from the Guide.
	CControlList	* m_Attatched;
	BOOL	m_bDeleteGuide;			// do we clean up the *Guide?
};

class CEdgeList : public _List<CEdge>
{
public:
	CEdgeList() { m_bAutoDelete=FALSE; };
	virtual ~CEdgeList() {};
	CEdge * GetEdge(int i) { return GetPointer(i); }
	int	GetEdgeCount() const { return GetCount(); }
};

#endif // !defined(AFX_EDGE_H__B2F750E2_7AF5_11D1_96A4_00C04FB177B1__INCLUDED_)

// EdgeCache.h: interface for the CEdgeCache class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_EDGECACHE_H__B2F750E3_7AF5_11D1_96A4_00C04FB177B1__INCLUDED_)
#define AFX_EDGECACHE_H__B2F750E3_7AF5_11D1_96A4_00C04FB177B1__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "edge.h"
#include "list.h"

//
// This is infact a list of GUIDEs.
// it returns an Edge which should be bound to the control itself?
//
#define PROPERTY(type, Name) void Set##Name( type v) { m_##Name=v; } type Get##Name() const {return m_##Name; }

class CEdgeCache  : public _List<CEdge>
{
public:
	BOOL AddEdge( CEdge * );
	CEdgeCache();
	virtual ~CEdgeCache();
	CEdge *	Create(int Position, int Axis, int Flexible=FALSE, int Accuracy=0);
	CEdge * Create( CGuide * guide, int Offset);
	CEdge * GetEdge(int i) { return (CEdge *)GetPointer(i); }
	PROPERTY( int, NumVert );
	PROPERTY( int, NumHoriz );

protected:
	//
	// information about the list
	//
	int		m_NumVert;
	int		m_NumHoriz;
};

#endif // !defined(AFX_EDGECACHE_H__B2F750E3_7AF5_11D1_96A4_00C04FB177B1__INCLUDED_)

// Constraint.h: interface for the CConstraint class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CONSTRAINT_H__2DD7C182_88F3_11D1_BF15_0080C74378BF__INCLUDED_)
#define AFX_CONSTRAINT_H__2DD7C182_88F3_11D1_BF15_0080C74378BF__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

typedef struct tagDIMENSION
{
	int Width;
	int Height;
} DIMENSION, * PDIMENSION;

#endif // !defined(AFX_CONSTRAINT_H__2DD7C182_88F3_11D1_BF15_0080C74378BF__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\dlg.h ===
//
// CDlg
//
// FelixA
//
// used to be called CDialog
// 

#ifndef __DIALOGH
#define __DIALOGH

#include "rcml.h"

class CDlg
{
public:
	void SetInstance(HINSTANCE hInst);
	void SetDlgID(UINT id);
	CDlg(int DlgID, HWND hWndParent, HINSTANCE hInst);
	virtual ~CDlg();

    //
    //
    //
	HWND GetWindow() const { return m_hDlg; }
	HWND GetParent() const { return ::GetParent(m_hDlg); }

//	The same name with CWnd::GetDlgItem in MFC
//	HWND GetDlgItem(int iD) const { return ::GetDlgItem(m_hDlg,iD); }
	HINSTANCE GetInstance() const { return m_Inst;}
	BOOL EndDialog(int iRet) { return ::EndDialog(m_hDlg,iRet); }

	// If you want your own dlg proc.
	int Do();
	virtual BOOL CALLBACK DlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
	virtual int DoCommand(WORD wCmdID,WORD hHow);	// return 0 if you handled this.
	virtual void OnInit();
	virtual int DoNotify(NMHDR * pHdr);
	virtual void Destroy();
	HWND CreateModeless();
	static BOOL CALLBACK BaseDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
	void SetWindow(HWND hDlg) { m_hDlg=hDlg; }

private:
	BOOL m_bCreatedModeless;

protected:
	int				m_DlgID;
	HWND			m_hDlg;
	HWND			m_hParent;
	HINSTANCE		m_Inst;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\enumcontrols.h ===
// EnumControls.h: interface for the CEnumControls class.
// simple wrapper around the children of RCML
// relies on the fact that it know what's going on.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ENUMCONTROLS_H__F80CB212_F7A4_4496_B5BA_0C18E69CEEE4__INCLUDED_)
#define AFX_ENUMCONTROLS_H__F80CB212_F7A4_4496_B5BA_0C18E69CEEE4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#include "unknown.h"
#include "xmlnode.h"

template <class interfaceList> 
class CEnumControls  : public _simpleunknown<IEnumUnknown>
{
public:
    CEnumControls<interfaceList>(interfaceList & children ) 
        : m_children(children) { m_uiIndex=0; m_uiCount=children.GetCount(); };

    //  IEnumFORMATETC methods

    STDMETHODIMP Skip(ULONG celt) { return E_NOTIMPL; }

    STDMETHODIMP Reset() { m_uiIndex=0; return S_OK; }

    STDMETHODIMP Clone(IEnumUnknown ** ppenum) { return E_NOTIMPL; }

    STDMETHODIMP Next(ULONG celt, IUnknown * *rgelt, ULONG *pceltFetched)
    {
        UINT    cfetch = 0;
        HRESULT hr = S_FALSE; // assume less numbers

        if (m_uiIndex < m_uiCount)
        {
            cfetch = m_uiCount - m_uiIndex;

            if (cfetch >= celt)
            {
                cfetch = celt;
                hr = S_OK;
            }

            UINT uiPointer=m_uiIndex;

            for( uiPointer=0; uiPointer < cfetch ; uiPointer++)
                rgelt[uiPointer] = m_children.GetPointer(m_uiIndex+uiPointer);

            m_uiIndex += cfetch;
        }

        if (pceltFetched)
            *pceltFetched = cfetch;

        return hr;
    }


private:

    virtual ~CEnumControls() {};


private:
    UINT        m_uiIndex;
    UINT        m_uiCount;
   	interfaceList 	& m_children;
};

#endif // !defined(AFX_ENUMCONTROLS_H__F80CB212_F7A4_4496_B5BA_0C18E69CEEE4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\eventlog.h ===
// EventLog.h: interface for the CEventLog class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_EVENTLOG_H__1D431075_D944_4E1F_9C47_69AA40FE8707__INCLUDED_)
#define AFX_EVENTLOG_H__1D431075_D944_4E1F_9C47_69AA40FE8707__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#undef PROPERTY
#define PROPERTY( type, id ) type Get##id() { return m_##id; } void Set##id(type v) { m_##id=v; }

class CEventLog  
{
public:
	void TurnOn( LPCTSTR pszKey=NULL );
	CEventLog();
	virtual ~CEventLog();
    BOOL    IsOn() { return m_IsOn; }
    BOOL    Log( WORD wType, WORD wCategory, WORD id, LPTSTR lpszComponent, LPTSTR text );
    PROPERTY( WORD, TypeMask);
    PROPERTY( WORD, CategoryMask );
private:
    WORD    m_TypeMask;  // and these with wType and wId
    WORD    m_CategoryMask;    // if non-zero, then log it.
    BOOL    m_IsOn;
    HANDLE	m_hEventLog;
};

#ifndef __EVENTLOG__CPP
// make me external.
extern CEventLog g_EventLog;
#else
CEventLog g_EventLog;
#endif

#endif // !defined(AFX_EVENTLOG_H__1D431075_D944_4E1F_9C47_69AA40FE8707__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\eventlog.cpp ===
// EventLog.cpp: implementation of the CEventLog class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#define __EVENTLOG__CPP
#include "EventLog.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CEventLog::CEventLog()
{
    m_IsOn=FALSE;
    m_hEventLog=NULL;
    m_TypeMask=0xffff;
    m_CategoryMask=0xffff;
}

CEventLog::~CEventLog()
{
    if(m_IsOn)
    	DeregisterEventSource( m_hEventLog );
    m_IsOn=FALSE;
}

void CEventLog::TurnOn(LPCTSTR pszKey)
{
    if( m_hEventLog )
    	DeregisterEventSource( m_hEventLog );

    m_hEventLog = RegisterEventSource( NULL, pszKey?pszKey:TEXT("RCML"));
	ClearEventLog( m_hEventLog, NULL);
    m_IsOn=TRUE;
}

BOOL    CEventLog::Log( WORD wType,	WORD wCategory, WORD id, LPTSTR lpszComponent, LPTSTR text )
{
    if( IsOn() )
    {	
        if(m_hEventLog )
	    {
            if( wType && ((wType & GetTypeMask() ) == 0 ))
                return TRUE;

            if( (wCategory & GetCategoryMask() ) == 0 )
                return TRUE;

		    LPCTSTR	pszLogStrings[2];
		    pszLogStrings[0]=(LPTSTR)lpszComponent;
		    pszLogStrings[1]=(LPTSTR)text;
		    return ReportEvent( m_hEventLog, wType,
			    0,	// made up Category
			    id,	// Event ID??
			    NULL,	// Security
			    2,		// 2 strings to log
			    0,		// No event specific data
			    (LPCTSTR*)&pszLogStrings,	// the strings
			    NULL );		// No Data
        }
	}
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\filestream.h ===
#ifndef _FILESTREAM_HXX
#define _FILESTREAM_HXX

#include <stdio.h>
#include "unknown.h"

class FileStream : public _simpleunknown<IStream>
{
public:
	FileStream() 
	{ 
        hFile = NULL;
        read = true;
        AddRef();
	}

	~FileStream() 
	{ 
		::CloseHandle(hFile);
	}

    bool open(LPTSTR name, bool read = true)
    {
        this->read = read;
        
        if (read)
        {
		    hFile = ::CreateFile( 
                name,
			    GENERIC_READ,
			    FILE_SHARE_READ,
			    NULL,
			    OPEN_EXISTING,
			    FILE_ATTRIBUTE_NORMAL,
			    NULL);
        }
        else
        {
		    hFile = ::CreateFile(
			    name,
			    GENERIC_WRITE,
			    FILE_SHARE_READ,
			    NULL,
			    CREATE_ALWAYS,
			    FILE_ATTRIBUTE_NORMAL,
			    NULL);
        }
        return (hFile == INVALID_HANDLE_VALUE) ? false : true;
    }

    virtual /* [local] */ HRESULT STDMETHODCALLTYPE Read( 
        /* [out] */ void __RPC_FAR *pv,
        /* [in] */ ULONG cb,
        /* [out] */ ULONG __RPC_FAR *pcbRead)
	{	
        if (!read) return E_FAIL;

        DWORD len;
		BOOL rc = ReadFile(
			hFile,	// handle of file to read 
			pv,	// address of buffer that receives data  
			cb,	// number of bytes to read 
			&len,	// address of number of bytes read 
			NULL 	// address of structure for data 
		   );
        if (pcbRead)
            *pcbRead = len;
		return (rc) ? S_OK : E_FAIL;
	}
    
    virtual /* [local] */ HRESULT STDMETHODCALLTYPE Write( 
        /* [size_is][in] */ const void __RPC_FAR *pv,
        /* [in] */ ULONG cb,
        /* [out] */ ULONG __RPC_FAR *pcbWritten)
	{
        if (read) return E_FAIL;

		BOOL rc = WriteFile(
			hFile,	// handle of file to write 
			pv,	// address of buffer that contains data  
			cb,	// number of bytes to write 
			pcbWritten,	// address of number of bytes written 
			NULL 	// address of structure for overlapped I/O  
		   );

		return (rc) ? S_OK : E_FAIL;
	}

    virtual /* [local] */ HRESULT STDMETHODCALLTYPE Seek( 
        /* [in] */ LARGE_INTEGER dlibMove,
        /* [in] */ DWORD dwOrigin,
        /* [out] */ ULARGE_INTEGER __RPC_FAR *plibNewPosition) { return E_FAIL; }
    
    virtual HRESULT STDMETHODCALLTYPE SetSize( 
        /* [in] */ ULARGE_INTEGER libNewSize) { return E_FAIL; }
    
    virtual /* [local] */ HRESULT STDMETHODCALLTYPE CopyTo( 
        /* [unique][in] */ IStream __RPC_FAR *pstm,
        /* [in] */ ULARGE_INTEGER cb,
        /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbRead,
        /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbWritten) { return E_FAIL; }
    
    virtual HRESULT STDMETHODCALLTYPE Commit( 
        /* [in] */ DWORD grfCommitFlags) { return E_FAIL; }
    
    virtual HRESULT STDMETHODCALLTYPE Revert( void) { return E_FAIL; }
    
    virtual HRESULT STDMETHODCALLTYPE LockRegion( 
        /* [in] */ ULARGE_INTEGER libOffset,
        /* [in] */ ULARGE_INTEGER cb,
        /* [in] */ DWORD dwLockType) { return E_FAIL; }
    
    virtual HRESULT STDMETHODCALLTYPE UnlockRegion( 
        /* [in] */ ULARGE_INTEGER libOffset,
        /* [in] */ ULARGE_INTEGER cb,
        /* [in] */ DWORD dwLockType) { return E_FAIL; }
    
    virtual HRESULT STDMETHODCALLTYPE Stat( 
        /* [out] */ STATSTG __RPC_FAR *pstatstg,
        /* [in] */ DWORD grfStatFlag) { return E_FAIL; }
    
    virtual HRESULT STDMETHODCALLTYPE Clone( 
        /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm) { return E_FAIL; }
private:
	HANDLE hFile;
    bool read;
};


class MemoryStream : public _simpleunknown <IStream>
{
public:
	MemoryStream(LPBYTE pData, DWORD dwSize) 
	{ 
        m_pBase=pData;
        m_pData=m_pBase;
        m_dwSize=dwSize;
        m_dwLoc=0;
        read = true;
        AddRef();
	}

	~MemoryStream() 
	{ 

	}

    bool open(LPTSTR name, bool read = true)
    {
        return FALSE;
    }

    virtual /* [local] */ HRESULT STDMETHODCALLTYPE Read( 
        /* [out] */ void __RPC_FAR *pv,
        /* [in] */ ULONG cb,
        /* [out] */ ULONG __RPC_FAR *pcbRead)
	{	
        if (!read) return E_FAIL;

#ifdef _VERY_DEBUG
        TCHAR szText[1024];
        wsprintf(szText,TEXT("Reading %d bytes, we have %d"), cb, m_dwSize-m_dwLoc);
        MessageBox(NULL, szText, TEXT("Reading"), MB_OK);
#endif
        if( m_dwLoc == m_dwSize ) 
            return S_FALSE ;

        ULONG free=m_dwSize-m_dwLoc;
        if( cb > free )
            cb = free;
        *pcbRead=cb;
        CopyMemory( pv, m_pData, cb );
        m_pData+=cb;
        m_dwLoc+=cb;
        return S_OK;
	}
    
    virtual /* [local] */ HRESULT STDMETHODCALLTYPE Write( 
        /* [size_is][in] */ const void __RPC_FAR *pv,
        /* [in] */ ULONG cb,
        /* [out] */ ULONG __RPC_FAR *pcbWritten)
	{
        if (read) return E_FAIL;

        return E_NOTIMPL;
	}

    virtual /* [local] */ HRESULT STDMETHODCALLTYPE Seek( 
        /* [in] */ LARGE_INTEGER dlibMove,
        /* [in] */ DWORD dwOrigin,
        /* [out] */ ULARGE_INTEGER __RPC_FAR *plibNewPosition) { return E_FAIL; }
    
    virtual HRESULT STDMETHODCALLTYPE SetSize( 
        /* [in] */ ULARGE_INTEGER libNewSize) { return E_FAIL; }
    
    virtual /* [local] */ HRESULT STDMETHODCALLTYPE CopyTo( 
        /* [unique][in] */ IStream __RPC_FAR *pstm,
        /* [in] */ ULARGE_INTEGER cb,
        /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbRead,
        /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbWritten) { return E_FAIL; }
    
    virtual HRESULT STDMETHODCALLTYPE Commit( 
        /* [in] */ DWORD grfCommitFlags) { return E_FAIL; }
    
    virtual HRESULT STDMETHODCALLTYPE Revert( void) { return E_FAIL; }
    
    virtual HRESULT STDMETHODCALLTYPE LockRegion( 
        /* [in] */ ULARGE_INTEGER libOffset,
        /* [in] */ ULARGE_INTEGER cb,
        /* [in] */ DWORD dwLockType) { return E_FAIL; }
    
    virtual HRESULT STDMETHODCALLTYPE UnlockRegion( 
        /* [in] */ ULARGE_INTEGER libOffset,
        /* [in] */ ULARGE_INTEGER cb,
        /* [in] */ DWORD dwLockType) { return E_FAIL; }
    
    virtual HRESULT STDMETHODCALLTYPE Stat( 
        /* [out] */ STATSTG __RPC_FAR *pstatstg,
        /* [in] */ DWORD grfStatFlag) { return E_FAIL; }
    
    virtual HRESULT STDMETHODCALLTYPE Clone( 
        /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm) { return E_FAIL; }
private:
	LPBYTE m_pBase;
    LPBYTE m_pData;
    bool read;
    ULONG   m_dwSize;
    ULONG   m_dwLoc;
};

#endif // _FILESTREAM_HXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\fonts.cpp ===
//
// Simple font classes with helper functions.
//
// (C) Microsoft Corp.
// Felix Andrew 1999
//

#include "stdafx.h"
#include "fonts.h"

//////////////////////////////////////////////////////////////////////////////////////////
//
//
//
//////////////////////////////////////////////////////////////////////////////////////////
CQuickFont::CQuickFont(LPTSTR name, DWORD dwSize)
: m_font(NULL), m_dc(NULL)
{
	Init(name, dwSize);
}

//////////////////////////////////////////////////////////////////////////////////////////
//
//
//
//////////////////////////////////////////////////////////////////////////////////////////
CQuickFont::~CQuickFont()
{
	if(m_font)
		DeleteObject(m_font);
	if(m_dc)
		ReleaseDC(NULL, m_dc);
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Creates the font we require
//
//////////////////////////////////////////////////////////////////////////////////////////
void CQuickFont::Init(LPCTSTR name, DWORD dwSize )
{
	Init( name, dwSize, 0, FW_NORMAL );
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Creates the font we require
//
//////////////////////////////////////////////////////////////////////////////////////////
void CQuickFont::Init(LPCTSTR name, DWORD dwSize , DWORD dwStyle, DWORD dwWeight, LOGFONT * pBaseLF )
{
	if(GetFont())
	{
		DeleteObject(GetFont());
		m_font=NULL;
		m_baseUnit=0;
	}

    LOGFONT lf;

	if( ( (name==NULL) || (lstrcmpi(name,TEXT(""))==0) ) && (pBaseLF==NULL) )
		return;

	if(pBaseLF==NULL)
		ZeroMemory( &lf, sizeof(LOGFONT));
	else
		CopyMemory( &lf, pBaseLF, sizeof( LOGFONT ) );

	if( dwWeight )
		lf.lfWeight=dwWeight;

	if( dwStyle & FS_ITALIC )
		lf.lfItalic=TRUE;

	if( name )
		lstrcpy(lf.lfFaceName, name );

	if( dwSize )
	{
		lf.lfHeight = -MulDiv(dwSize, GetDeviceCaps(GetDC(), LOGPIXELSY), 72);
		m_dwSize=dwSize;
	}
	else
	{
		// BUGBUG - size is inherited from the logfont?
	}

	//
	// Select the font into the DC
	//
	m_font=CreateFontIndirect(&lf);

	SelectObject(GetDC(), m_font );
	m_baseUnit=0;
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Gets a screen DC so we can calculate the size of text rendered in this font
//
//////////////////////////////////////////////////////////////////////////////////////////
HDC CQuickFont::GetDC()
{
	if(m_dc==NULL)
		m_dc=::GetDC(NULL);		// VadimG says this is OK
	return m_dc;
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Calculates the height of a piece of text, given the width of the text
// loword is the height
// hi-word is the width
//
//////////////////////////////////////////////////////////////////////////////////////////
SIZE CQuickFont::HowHigh(LPCTSTR text, DWORD dwWidth)
{
	RECT rect={0};
	rect.right=dwWidth;
	rect.bottom=-1;
	DrawText( GetDC(), text, -1, &rect, DT_CALCRECT | DT_WORDBREAK);
	SIZE s;
	s.cx=rect.right;
	s.cy=rect.bottom;
	return s;
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Returns the length of the text, so caller can determin if multi line / single line>
// returns HEIGHT WIDTH
//
//////////////////////////////////////////////////////////////////////////////////////////
SIZE CQuickFont::HowLong( LPCTSTR text )
{
	SIZE size;
	GetTextExtentPoint32( GetDC(), text, lstrlen(text), &size);
	// int width=0;
	// int height=0;
	// GetTextExtentExPoint( GetDC(), text, lstrlen(text), 0, &width, &height, &size );
	return size;
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Taken from NT5 user.
//
//////////////////////////////////////////////////////////////////////////////////////////
DWORD CQuickFont::GetDialogBaseUnits()
{
	if(m_baseUnit)
		return m_baseUnit;
    m_baseUnit = GetDialogBaseUnits( GetDC(), m_font );
    return m_baseUnit;
}

DWORD CQuickFont::GetDialogBaseUnits( HDC hdc, HFONT font )
{
    DWORD baseUnit;
	TEXTMETRIC textMetric;
	SelectObject(hdc, font );
	GetTextMetrics( hdc, &textMetric);

	if( textMetric.tmPitchAndFamily & TMPF_FIXED_PITCH )
	{
        SIZE size;
        static CONST TCHAR wszAvgChars[] = TEXT("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
		int len=(sizeof(wszAvgChars) / sizeof(TCHAR)) - 1;
        /*
         * Change from tmAveCharWidth.  We will calculate a true average
         * as opposed to the one returned by tmAveCharWidth.  This works
         * better when dealing with proportional spaced fonts.
         */
        if (GetTextExtentPoint32(hdc, wszAvgChars,len , &size)) 
		{
            // UserAssert((((size.cx / 26) + 1) / 2) > 0);
			int p1=size.cx/26;
			baseUnit = MAKELONG( ((size.cx / 26) + 1) / 2, size.cy);    // round up
        }
	}
	else
		baseUnit = ::GetDialogBaseUnits();
	return baseUnit;
}

SIZE CQuickFont::GetPixelsFromDlgUnits(SIZE s)
{
	return GetPixelsFromDlgUnits( s, GetDialogBaseUnits() );
}

// Static, takes the base.
SIZE CQuickFont::GetPixelsFromDlgUnits(SIZE s, DWORD nBase)
{
	SIZE r;
	// r.cx= (s.cx * LOWORD(nBase)) / 4;
	// r.cy= (s.cy * HIWORD(nBase)) / 8;
    // USER does below, MSDN does above.
    r.cx = MulDiv( s.cx, LOWORD(nBase), 4);
    r.cy = MulDiv( s.cy, HIWORD(nBase), 8);
	return r;
}

SIZE CQuickFont::GetDlgUnitsFromPixels(SIZE s)
{
    return GetDlgUnitsFromPixels( s, GetDialogBaseUnits() );
}

SIZE CQuickFont::GetDlgUnitsFromPixels(SIZE s, DWORD nBase)
{
    SIZE r;
	// r.cx= s.cx * 4 / LOWORD(nBase) ;
	// r.cy= s.cy * 8 / HIWORD(nBase) ;
    // USER does below, MSDN does above.
    r.cx = MulDiv( s.cx, 4, LOWORD(nBase) );
    r.cy = MulDiv( s.cy, 8, HIWORD(nBase) );
	return r;
}


void CQuickFont::GetLogFont( int cbSize, LOGFONT * pLF )
{
    GetObject( m_font, cbSize, pLF );
}

#ifdef OLD_FONT_CODE
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
CFonts::CFonts()
: m_uiNum(0),
  m_pFonts(NULL)
{
}

CFonts::~CFonts()
{
	Init(0,0);		// deletes and cleans up the fonts.
}

void	CFonts::Init(UINT uiNumFonts, UINT uiType)
{
	//
	// Clean up old fonts.
	//
	if(m_pFonts)
	{
		UINT uiIndex;
		for(uiIndex=0;uiIndex<m_uiNum;uiIndex++)
			if(m_pFonts[uiIndex])
				DeleteObject(m_pFonts[uiIndex]);
		delete [] m_pFonts;
	}

	//
	// Create new fonts.
	//
	if(uiNumFonts)
		m_pFonts=new HFONT[uiNumFonts];
	m_uiNum=uiNumFonts;

	//
	// Zero init them.
	//
	UINT uiIndex;
	for(uiIndex=0;uiIndex<m_uiNum;uiIndex++)
		m_pFonts[uiIndex]=NULL;

	m_uiType=uiType;

}

//
//
//
void	CFonts::CreateFont(UINT uiIndex, LONG lfWeight, BYTE lfItalic, BYTE lfStrike )
{

	switch( m_uiType)
	{
		case ODT_MENU:
		{
			NONCLIENTMETRICS ncm;
			if (SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0))
			{
				LOGFONT	lf;
				CopyMemory(&lf, &(ncm.lfMenuFont), sizeof(ncm.lfMenuFont));
				lf.lfWeight=lfWeight;
				lf.lfItalic=lfItalic;
				lf.lfStrikeOut=lfStrike;
				SetFont( uiIndex, CreateFontIndirect(&lf) );
				return;
			}
		}

		//
		// Not perhaps the above fails - do default.
		//
		default:
		{
			LOGFONT	lf;

			if (SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, 0))
			{
				lf.lfWeight=lfWeight;
				lf.lfItalic=lfItalic;
				lf.lfStrikeOut=lfStrike;
				SetFont( uiIndex, CreateFontIndirect(&lf) );
			}
		}
	}
}

HFONT	CFonts::GetFont(UINT iIndex)
{
	if(iIndex>m_uiNum || !m_pFonts)
		return NULL;
	return m_pFonts[iIndex];
}

void	CFonts::SetFont(UINT uiIndex, HFONT hf)
{
	if(uiIndex>m_uiNum || !m_pFonts)
		return;

	if(m_pFonts[uiIndex])
		DeleteObject(m_pFonts[uiIndex]);

	m_pFonts[uiIndex]=hf;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\image.h ===
// Image.h: interface for the CImage class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_IMAGE_H__7B246736_0174_11D3_A2E6_005004773B15__INCLUDED_)
#define AFX_IMAGE_H__7B246736_0174_11D3_A2E6_005004773B15__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "Win32Dlg.h"

class CImage
{
public:
	CImage();
	virtual ~CImage();
	static BOOL Init();
	static LRESULT CALLBACK ImageWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
	static BOOL bInit;
};

#endif // !defined(AFX_IMAGE_H__7B246736_0174_11D3_A2E6_005004773B15__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\image.cpp ===
// Image.cpp: implementation of the CImage class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Image.h"
#include "utils.h"
#include <vfw.h>

#include "xmlimage.h"

using namespace Gdiplus;

BOOL CImage::bInit;

//////////////////////////////////////////////////////////////////////
// Helper Functions
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
// PaintImage
// Renders the image based on its type.  Returns FALSE for the first
// attempt to paint an image (bDelayPaint is TRUE) 
//////////////////////////////////////////////////////////////////////
BOOL PaintImage(HWND hwnd, HDC hdc)
{
	CXMLImage* pXMLImage = (CXMLImage*)GetXMLControl(hwnd);
	ASSERT(pXMLImage);

	RECT rect;
	pXMLImage->DrawEdge(hdc, &rect);
	if(pXMLImage->DelayPaint())
		return FALSE;

	switch(pXMLImage->m_imageType)
	{
		case CXMLImage::GDIPLUS:
		{
			if (pXMLImage->image.m_pBitmap == NULL)
			{
#ifndef UNICODE
				LPWSTR pUnicodeName = UnicodeStringFromAnsi(pXMLImage->GetFileName());
				pXMLImage->image.m_pBitmap = new Bitmap(pUnicodeName);
				delete pUnicodeName;
#else
				pXMLImage->image.m_pBitmap = new Bitmap(pXMLImage->GetFileName());
#endif
			}
			Graphics *g = Graphics::FromHWND(hwnd);
			g->SetRenderingHint(RenderingHintNone);

			g->DrawImage(pXMLImage->image.m_pBitmap, (float)rect.left, (float)rect.top, (float)rect.right-rect.left, (float)rect.bottom-rect.top);
			delete g;
			break;
		}
		case CXMLImage::MCI:
			{
				if(pXMLImage->image.hwndMCIWindow)
					return TRUE;
				/*
				 * Consider adding image specific styles such as MCIWNDF_NOPLAYBAR (0x02)
				 */
				HWND hwndMCI = MCIWndCreate(hwnd, NULL, 
								MCIWNDF_NOPLAYBAR | WS_VISIBLE | WS_CHILD, 
								(LPCTSTR)(pXMLImage->GetFileName()));
				pXMLImage->image.hwndMCIWindow = hwndMCI;
				SetWindowPos(hwndMCI, NULL, rect.left, rect.top, rect.right-rect.left, rect.bottom - rect.top, SWP_NOZORDER|SWP_NOREDRAW);
		// seems I don't need this:	MCIWndOpen(hwndMCI, (LPCTSTR)(*pXMLImage->GetFileName()), 0);
				MCIWndPlay(hwndMCI);
				break;
			}			
	}
	return TRUE;
}

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CImage::CImage()
{
	Init();
}

CImage::~CImage()
{
}

BOOL CImage::Init()
{
	if (!bInit)
	{
		WNDCLASSEX wc = 
		{
			sizeof(WNDCLASSEX),
			CS_GLOBALCLASS,
			CImage::ImageWindowProc,
			0, 0, 0, 0, 0, 0, 
			NULL,
			TEXT("IMAGE"),
			NULL
		};
		if(!RegisterClassEx(&wc))
		{
			TRACE(TEXT("Can't register Image class"));
			return FALSE;
		}
		bInit = TRUE;
	}
	return TRUE;
}

LRESULT CALLBACK CImage::ImageWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{

    switch (message) {

    case WM_ERASEBKGND:
        return (LONG)TRUE;
		break;

    case WM_PRINTCLIENT:
		if(!PaintImage(hwnd, (HDC)wParam))
		{
			PostMessage(hwnd, message, wParam, lParam);			
		} 
        break;

    case WM_PAINT:
		{
			PAINTSTRUCT ps;
			HDC hdc;

			if ((hdc = (HDC)wParam) == NULL)
				hdc = BeginPaint(hwnd, &ps);
			if(!PaintImage(hwnd, hdc))
			{
				PostMessage(hwnd, message, wParam, lParam);			
			} 
			if (!wParam)
				EndPaint(hwnd, &ps);
		} 
        break;

	case WM_SETTEXT:
		{
#if 0
			/*
			 *	All controls should have this.  Consider creating a base class with a common WindowProc. MCostea.
             *  that would be nice, except we don't own any of the control implementations. Felix.
			 */
			CXMLImage* pXMLImage = (CXMLImage*)GetXMLControl(hwnd);
			pXMLImage->SetText((LPCTSTR)lParam);
	        PaintImage(hwnd, (HDC)NULL);
			goto CallDWP;
#endif
		}
		break;

	default:
// CallDWP:
		return DefWindowProc(hwnd, message, wParam, lParam);
    }
    return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\fonts.h ===
//
//
//

#ifndef _FONTS_H
#define _FONTS_H

class CQuickFont
{
public:
	CQuickFont(): m_font(NULL), m_dc(NULL) { Init(NULL,0); }
	CQuickFont( LPTSTR name, DWORD dwSize);
	virtual ~CQuickFont();

	enum QFS_STYLE
	{
		FS_ITALIC=1,
	};

	//
	//
	//
	HFONT	GetFont() { return m_font; }
	void	Init(LPCTSTR name, DWORD dwSize );
	void	Init(LPCTSTR name, DWORD dwSize, DWORD dwStyle, DWORD dwWeight, LOGFONT * pBaseLF=NULL);

	//
	// Now we have the font, we can get information about how text is rendered using it.
	//

	//
	// MULTILINE - USER
	//
	SIZE	HowHigh( LPCTSTR name, DWORD dwWidth);

	//
	// SINGLE LINE - GDI
	//
	SIZE	HowLong( LPCTSTR text );

	//
	// Returns a dialog mapping from Pixels to DLG units.
	//
	DWORD	        GetDialogBaseUnits();       // calls this static with GetDC and GetFont
	static DWORD	GetDialogBaseUnits(HDC hdc, HFONT hf);

	//
	// Information about the font itself - name, size etc.
	//
	DWORD	GetSize() { return m_dwSize; }

	SIZE	GetDlgUnitsFromPixels( SIZE s );
	SIZE	GetPixelsFromDlgUnits( SIZE s );
	static SIZE	GetDlgUnitsFromPixels( SIZE s, DWORD nBase );   // nBase is GetDialogBaseUnits.
	static SIZE	GetPixelsFromDlgUnits( SIZE s, DWORD nBase );

    void    GetLogFont(int cbSize, LOGFONT * pLF);

private:
	DWORD	m_baseUnit;
	DWORD	m_dwSize;
	HDC		GetDC();
	HFONT	m_font;
	HDC		m_dc;
	// LOGFONT	m_lf;   // this is large and costly.
	CQuickFont( CQuickFont & font ) : m_font(NULL), m_dc(NULL) {};
};

#if 0

class CFonts
{
public:
	CFonts();
	~CFonts();
	void	Init(UINT uiNumFonts, UINT uiType);
	void	CreateFont(UINT uiIndex, LONG lfWeight, BYTE lfItalic=FALSE, BYTE bStrike=FALSE);
	HFONT	GetFont(UINT iIndex);

private:
	UINT	m_uiNum;
	HFONT	* m_pFonts;
	void	SetFont(UINT uiIndex, HFONT hf);
	UINT	m_uiType;	// owner draw types. ODT_MENU WM_MEASUREITEM
};

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\parentinfo.cpp ===
// ParentInfo.cpp: implementation of the CParentInfo class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ParentInfo.h"
#include "debug.h"
#include "persctl.h"
#include "resizedlg.h"
#include "xmldlg.h"

// Too noisy
#ifdef _DEBUG
#define TRACE 0?0:
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CParentInfo::CParentInfo()
{
    m_borders.left = m_borders.right = m_borders.top = m_borders.bottom = 0;

	m_pTopEdge=NULL;
	m_pBottomEdge=NULL;
	m_pLeftEdge=NULL;
	m_pRightEdge=NULL;

	m_pXML=NULL;
}

////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
void CParentInfo::Init(HWND h, CXMLDlg * pXML)
{
	m_hWnd=h;
	m_pXML = pXML;

	DeterminSize();
}

////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
CParentInfo::~CParentInfo()
{

}

////////////////////////////////////////////////////////////////////////////////////////
//
// Frees up memory not needed past the initial processing stage.
//
////////////////////////////////////////////////////////////////////////////////////////
void CParentInfo::Purge()
{
    m_Edges.Purge();
}

////////////////////////////////////////////////////////////////////////////////////////
//
//
// This is the size of the client area of the window
// we don't have to take into account the frame and title bar when positioning
// indside it.
//
////////////////////////////////////////////////////////////////////////////////////////
void CParentInfo::DeterminSize()
{
    DIMENSION d;
    if( GetWindow() == NULL )
    {
        CXMLDlg * pDialog = GetXML();   // BUGBUG should be IRCMLControl ??
        if(pDialog)
        {
            SIZE initSize;
            if( SUCCEEDED( pDialog->get_Width( &initSize.cx ) ))
            {
                if( SUCCEEDED( pDialog->get_Height( &initSize.cy ) ))
                {
        	        // initSize.cx=pDialog->GetWidth();    // currently in DLU's
	                // initSize.cy=pDialog->GetHeight();   // currently in DLU's
                    initSize = pDialog->GetPixelSize( initSize );

                    d.Width=initSize.cx;
                    d.Height=initSize.cy;

                    m_Size.left=0;
                    m_Size.right=d.Width;
                    m_Size.top=0;
                    m_Size.bottom=d.Height;
                }
            }
        }
    }
    else
    {
	    GetClientRect( GetWindow(), &m_Size);
	    RECT r;
	    GetWindowRect( GetWindow(), &r);
	    d.Width= r.right - r.left;
	    d.Height = r.bottom - r.top;
    }

	SetMinimumSize(d);
	TRACE(TEXT("ParentDimensions : %d by %d \n"),
			GetWidth(),
			GetHeight());
}


////////////////////////////////////////////////////////////////////////////////////////
//
// Walks all the edges, finding one that is closest and thus re-usable.
//
////////////////////////////////////////////////////////////////////////////////////////
#define ABS(x) (x<0?-x:x)
CEdge * CParentInfo::AddEdge(int Position, int Axis, BOOL Flexible, int Slop)
{
	int i=0;
	CEdge * pEdge;
	CGuide * pClosest=NULL;
	int closest=0xffff;

	//
	// First see if the edge is what we wanted
	//
	while( pEdge=m_Edges.GetEdge(i++) )
	{
		if(pEdge->GetPosition() == Position )
		{
			if( pEdge->GetAxis() == Axis )
			{
				TRACE(TEXT("Guide REUSE:: %03d, %02d\n"),Position, Axis);
				return pEdge;
			}
		}
	}

	i=0;
	while ( pEdge=m_Edges.GetEdge(i++))
	{
		CGuide * pGuide=pEdge->GetGuide();

		if(pGuide->GetAxis() == Axis )
		{
			// if( pEdge->GetFlexible() == Flexible )
			{
				int distance=Position -pGuide->GetPosition() ;
				if( ABS(distance) <= Slop )
				{
					if( Slop == 0 )
						return pEdge;

					//
					// Within the range, but is it the best?
					//
					if(closest==0xffff)
					{
						closest=distance;
						pClosest=pGuide;
					}
					
					if( ABS(distance)<=ABS(closest) )
					{
						pClosest=pGuide;
						closest=distance;
					}
				}
			}
		}
	}

	if(pClosest)
	{
		//
		// Create a new edge with the same guide, different offset.
		//
		closest = Position - pClosest->GetPosition();
		TRACE(TEXT("Guide CLOSE:: %03d, %02d, closest %d, actual pos %03d\n"),pClosest->GetPosition(), pClosest->GetAxis(), closest, Position);
		return m_Edges.Create( pClosest, closest);
	}

	TRACE(TEXT("Guide NEW  :: %03d, %02d\n"),Position, Axis);
	return m_Edges.Create(Position, Axis, Flexible, 0);
}

////////////////////////////////////////////////////////////////////////////////////////
//
//
////////////////////////////////////////////////////////////////////////////////////////
CEdge & CParentInfo::FindCloseEdge(CEdge & Fixed, int Offset)
{
	int i=0;
	CEdge * pEdge;
	while ( pEdge=m_Edges.GetEdge(i++) )
	{
		if(pEdge->GetAxis() == Fixed.GetAxis() )
		{
			int distance=Fixed.GetPosition() -pEdge->GetPosition() ;
			if( ABS(distance) <= Offset )
			{
				return *pEdge;
			}
		}
	}
	return Fixed;
}

////////////////////////////////////////////////////////////////////////////////////////
//
//
////////////////////////////////////////////////////////////////////////////////////////
CEdge * CParentInfo::AddEdge(CGuide * pGuide, int Offset)
{
	// TRACE("Associating another edge %03d from 0x%08x\n", Offset , Edge);
	return m_Edges.Create( pGuide, Offset);
}

////////////////////////////////////////////////////////////////////////////////////////
//
// BORDERS FOR THE DIALOG - (not for the components).
// Buids some default guides for the borders.
// the borders can move
//
////////////////////////////////////////////////////////////////////////////////////////
void CParentInfo::ConstructBorders()
{
	m_pLeftEdge=AddEdge( GetLeftBorder(), LEFT_AT, FALSE );
	m_pRightEdge=AddEdge( GetWidth() - GetRightBorder(), RIGHT_AT, TRUE );

	m_pTopEdge=AddEdge(  GetTopBorder(), TOP_AT, FALSE );
	m_pBottomEdge=AddEdge( GetHeight() - GetBottomBorder(), BOTTOM_AT, TRUE );
}

////////////////////////////////////////////////////////////////////////////////////////
//
// We know that the left and bottom edges move to follow the dialog
//
////////////////////////////////////////////////////////////////////////////////////////
void CParentInfo::Resize(int width, int height)
{
	m_pRightEdge->SetPosition( width - GetRightBorder() );
	m_pBottomEdge->SetPosition( height - GetBottomBorder() );
}


////////////////////////////////////////////////////////////////////////////////////////
//
// Walks all the edges building an array of the veritcal ones - not sorted
//
////////////////////////////////////////////////////////////////////////////////////////
CEdge ** CParentInfo::GetVerticalEdges()
{
	int iCount=m_Edges.GetNumVert();
	CEdge ** ppEdges= (CEdge**)new (CEdge*[iCount]);
	CEdge * pEdge;
	int i=0,iDest=0;
	while( pEdge = m_Edges.GetEdge(i++) )
	{
		if(pEdge->IsVertical() )
			ppEdges[iDest++] = pEdge;
#ifdef _DEBUG
		if( iDest > iCount )
			TRACE(TEXT("Vertical edge count is off %d vs %d\n"), iDest, iCount);
#endif
	}
	return ppEdges;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// Walks all the edges building an array of the horizontal ones - not sorted
//
//
////////////////////////////////////////////////////////////////////////////////////////
CEdge ** CParentInfo::GetHorizontalEdges()
{
	int iCount=m_Edges.GetNumHoriz();
	CEdge ** ppEdges= new CEdge *[iCount];
	CEdge * pEdge;
	int i=0,iDest=0;
	while( pEdge = m_Edges.GetEdge(i++) )
	{
		if(pEdge->IsHorizontal())
			ppEdges[iDest++] = pEdge;
#ifdef _DEBUG
		if( iDest > iCount )
			TRACE(TEXT("Horiz edge count is off %d vs %d\n"), iDest, iCount);
#endif
	}
	return ppEdges;
}

void CParentInfo::Annotate(HDC hdc)
{
	int i=0;
	CEdge * pEdge;
	int iWidth=GetWidth();
	int iHeight=GetHeight();
	HPEN hpen = CreatePen( PS_SOLID, 1, RGB( 0xff,0x00,0x00) );
	HGDIOBJ holdPen= SelectObject( hdc, hpen);
	while( pEdge=m_Edges.GetEdge(i++) )
	{
		if( pEdge->IsHorizontal() )
		{
			MoveToEx( hdc, 0, pEdge->GetPosition(), NULL );
			LineTo( hdc, iWidth , pEdge->GetPosition() );
		}
		else
		{
			MoveToEx( hdc, pEdge->GetPosition(), 0, NULL );
			LineTo( hdc, pEdge->GetPosition(), iHeight );
		}
	}
	SelectObject(hdc, holdPen);
	DeleteObject(hpen);
}

////////////////////////////////////////////////////////////////////////
//
// Walks all the controls, finds where the borders of the dialog are
//
////////////////////////////////////////////////////////////////////////
void CParentInfo::DeterminBorders(CXMLControlList & controls)
{
    //
    // Find the outer dimentions of the controls.
    //
    CXMLDlg * pDlg = m_pXML;
    RECT bounding;
	int i=0;
	IRCMLControl * pC;
	while( pC=controls.GetPointer(i++) )
	{
        if( i==1 )
        {
            bounding=pDlg->GetPixelLocation(pC);
            continue;
        }

        RECT d=pDlg->GetPixelLocation(pC);
        if( d.left < bounding.left )
            bounding.left = d.left;
        if( d.right > bounding.right )
            bounding.right = d.right;
        if( d.top < bounding.top )
            bounding.top = d.top;
        if( d.bottom > bounding.bottom )
            bounding.bottom = d.bottom;
	}

    //
    // The area not occupied by controls (gutters) around the frame of the dialog
    //
    m_borders.left = bounding.left;
    m_borders.right = m_Size.right - bounding.right;
    m_borders.top = bounding.top;
    m_borders.bottom = m_Size.bottom - bounding.bottom;


    //
    // Now, how big are we?
    //

	ConstructBorders();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\persctl.cpp ===
//
// CLayoutInfo
//
// FelixA
//
// Resize controls

#include "stdafx.h"
#include "persctl.h"
#include "debug.h"
#define ABS(x) (x<0?-x:x)
#define GetWindowStyle(h) GetWindowLong( h, GWL_STYLE)

#include "xmldlg.h"

CLayoutInfo::CLayoutInfo()
	: m_pLeftEdge(NULL), m_pRightEdge(NULL), m_pTopEdge(NULL),
	m_pBottomEdge(NULL), 
	m_RightSlop(3) , m_pControl(NULL)
{
    m_Alignment=0;
    m_Col=0;
    m_ColW=0;
    m_PadBottom=0;
    m_PadLeft=0;
    m_PadRight=0;
    m_PadTop=0;
    m_Row=0;
    m_RowH=0;
}

CLayoutInfo::~CLayoutInfo()
{
}

//
// Returns a bitfield where the guide is attatched.
//
int CLayoutInfo::Attatchment(CGuide * pGuide)
{
	int iRet=0;
	if( pGuide->IsEqual( m_pLeftEdge->GetGuide() ) )
		iRet |= LEFT_AT;
	if( pGuide->IsEqual( m_pRightEdge->GetGuide() ) )
		iRet |= RIGHT_AT;
	if( pGuide->IsEqual( m_pTopEdge->GetGuide() ) )
		iRet |= TOP_AT;
	if( pGuide->IsEqual( m_pBottomEdge->GetGuide() ) )
		iRet |= BOTTOM_AT;
	return iRet;
}

void CLayoutInfo::Init( IRCMLControl * pControl, CParentInfo & pi )
{
    m_pControl = pControl;

    if( m_pControl )
    {
        IRCMLContainer * pContainer;
        if(SUCCEEDED( pControl->get_Container( &pContainer ) ))
        {
            // REVIEW - should be IRCMLForm ?? (maps DLU to pixel locations).
            pContainer->GetPixelLocation( m_pControl, &m_Location );

            BOOL bGrowsWide;
            BOOL bGrowsHigh;

            pControl->get_GrowsWide( &bGrowsWide );
            pControl->get_GrowsTall( &bGrowsHigh );

   	        m_pBottomEdge	= pi.AddEdge( m_Location.bottom, BOTTOM_AT, bGrowsHigh, 0 );
	        m_pTopEdge		= pi.AddEdge( m_Location.top, TOP_AT, bGrowsHigh, 0 );
	        m_pRightEdge	= pi.AddEdge( m_Location.right, RIGHT_AT, bGrowsWide, m_RightSlop );
	        m_pLeftEdge		= pi.AddEdge( m_Location.left, LEFT_AT, bGrowsWide );

 	        m_pRightEdge->Attatch(this);
	        m_pLeftEdge->Attatch(this);
	        m_pTopEdge->Attatch(this);
	        m_pBottomEdge->Attatch(this);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\list.cpp ===
//
// CDPA - array of pointers that grows.
//
// FelixA
//

#include "stdafx.h"
#include "list.h"
#ifndef _DEBUG
#define _MEM_DEBUG 1
#endif

#ifdef _MEM_DEBUG
int g_HeapAllocCount=0;
#endif

#ifdef USEHEAP
/////////////////////////////////////////////////////////////////////////////
// HEAP VERSION HEAP VERSION HEAP VERSION HEAP VERSION HEAP VERSION HEAP VERSION 
//
CDPA::CDPA()
: m_iAllocated(0),
  m_iCurrentTop(0),
  m_pData(NULL),
  m_Heap(NULL)	//Allocate from global heap.
{
}

CDPA::~CDPA()
{
	LPVOID lpV;
	int i=0;
	while( lpV=GetPointer(i++) )
		delete lpV;

	DeleteHeap();
}

void CDPA::DeleteHeap()
{
	if(GetData())
	{
		HeapFree(GetHeap(), 0, GetData());
		HeapDestroy(GetHeap() );
	}
	SetData(NULL);
	SetAllocated(0);
}

/////////////////////////////////////////////////////////////////////////////
//
// Inserts at the end - no mechanism for inserting in the middle.
// Grows the Heap if you add more items than currently have spave for
//

BOOL CDPA::Append(LPVOID lpData)
{
	if(GetNextFree()==GetAllocated())
	{
		int iNewSize = GetAllocated()*2;
        if(iNewSize==0)
            iNewSize=16;
        void FAR * FAR * ppNew;

		if(GetData())
            ppNew = (void FAR * FAR *)HeapReAlloc(GetHeap(), HEAP_ZERO_MEMORY, GetData(), iNewSize * sizeof(LPVOID));
		else
		{
			if(!GetHeap())
            {
				SetHeap(HeapCreate(0, iNewSize*sizeof(LPVOID),0)); // 1/4K heaps, not 16K heaps.
#ifdef _MEM_DEBUG
                g_HeapAllocCount++;
#endif
            }
            ppNew = (void FAR * FAR *)HeapAlloc(GetHeap(), HEAP_ZERO_MEMORY, iNewSize * sizeof(LPVOID));
		}

		if(ppNew)
		{
			SetData(ppNew);
			SetAllocated(iNewSize);
		}
		else
			return FALSE;
	}

	*(GetData()+GetNextFree())=lpData;
	SetNextFree(GetNextFree()+1);
	return TRUE;
}

#else
/////////////////////////////////////////////////////////////////////////////
//
//
CDPA::CDPA()
: m_iAllocated(0),
  m_iCurrentTop(0),
  m_pData(NULL)
{
}

CDPA::~CDPA()
{
	LPVOID lpV;
	int i=0;
	while( lpV=GetPointer(i++) )
		delete lpV;

	DeleteHeap();
}

void CDPA::DeleteHeap()
{
    delete m_pData;
    m_pData=NULL;
	m_iAllocated=0;
}

/////////////////////////////////////////////////////////////////////////////
//
// Inserts at the end - no mechanism for inserting in the middle.
// Grows the Heap if you add more items than currently have spave for
//


BOOL CDPA::Append(LPVOID lpData)
{
	if(GetNextFree()==GetAllocated())
	{
		int iNewSize = GetAllocated()*2;
        if(iNewSize==0)
            iNewSize=8;

        LPVOID * ppNew;

		if( !GetData() )
        {
            ppNew = new LPVOID[ iNewSize * sizeof(LPVOID) ];
        }
        else
        {
            LPVOID * pbOldData=GetData();
            ppNew = new LPVOID[ iNewSize * sizeof(LPVOID) ];
            CopyMemory(ppNew, pbOldData, GetAllocated() * sizeof(LPVOID) );
            delete pbOldData;
        }

		if(ppNew)
		{
			SetData(ppNew);
			SetAllocated(iNewSize);
		}
		else
			return FALSE;
	}

	*(GetData()+GetNextFree())=lpData;
	SetNextFree(GetNextFree()+1);
	return TRUE;
}
#endif

/////////////////////////////////////////////////////////////////////////////
//
// Given the index into the list, returns its value.
//
LPVOID CDPA::GetPointer(int iItem) const
{
	if(GetData())
		if(iItem<GetNextFree())	// mCurrentTop is not active. (zero based index)
			return *(GetData()+iItem);
	return NULL;
}

void CDPA::Remove(int iItem) 
{
	if(GetData())
		if(iItem<GetNextFree())	// mCurrentTop is not active.
			*(GetData()+iItem)=NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\list.h ===
//
// CDPA Class.
// Based on DPA's from the shell
//
// FelixA
//
// 98 extended to be a templated class
//

#ifndef __LISTH
#define __LISTH
// #define USEHEAP 1

class CDPA
{
public:
	CDPA();
	~CDPA();

	BOOL	Append(LPVOID);
	LPVOID	GetPointer(int iItem) const;

	void	DeleteHeap();
	int		GetCount() const { return m_iCurrentTop; }
	void	Remove(int iItem);	// sets this pointer to NULL.
private:
	int GetAllocated() const {return m_iAllocated;}
	void SetAllocated(int i) { m_iAllocated=i; }

	int GetNextFree() const { return m_iCurrentTop; }
	void SetNextFree(int i) { m_iCurrentTop=i; }


	int m_iAllocated; // Number of items in the list.
	int m_iCurrentTop;// Next item to use.
#ifdef USEHEAP
	HANDLE GetHeap() const { return m_Heap; }
	void SetHeap( HANDLE h) { m_Heap = h; }

	void FAR * FAR * GetData() const { return m_pData; };
	void SetData(void FAR * FAR * pD) { m_pData=pD; }

	void FAR * FAR * m_pData;	// Pointer to the pointer array.
	HANDLE m_Heap;	// Handle for the heap we're using.
#else
	LPVOID * GetData() const { return m_pData; };
	void SetData(LPVOID * pD) { m_pData=pD; }
    LPVOID *  m_pData;
#endif
};

template <class T> class _List : public CDPA
{
	typedef CDPA BASECLASS;
public:
	_List() : m_bAutoDelete(TRUE) {};
	_List( const _List<T> & list )
	{
		int ic=list.GetCount();
		for(int i=0;i<ic;i++)
		{
			T * pTemp=new T(*list.GetPointer(i));
			Append(pTemp);
		}
	}

	virtual ~_List() 
	{
        Purge();
	};

	T* GetPointer(int it) const { return (T*)BASECLASS::GetPointer(it); }
	BOOL	Append(T* pt) { return BASECLASS::Append((LPVOID)pt); }

	void	SetAutoDelete(BOOL b) { m_bAutoDelete=b;}

    void    Purge()
    {
   		if( m_bAutoDelete )
		{
			T* lpT;
			int i=0;
			int j=GetCount();
			while( lpT=GetPointer(i++) )
				delete lpT;
		}
		DeleteHeap();
    }

protected:
	BOOL m_bAutoDelete;
};

//
// Calls addref and release on the class T
//
template <class T> class _RefcountList : public CDPA
{
	typedef CDPA BASECLASS;
public:
	_RefcountList() : m_bAutoDelete(TRUE) {};

	_RefcountList( const _List<T> & list )
	{
		int ic=list.GetCount();
		for(int i=0;i<ic;i++)
		{
			T * pTemp=new T(*list.GetPointer(i));
			Append(pTemp);
		}
	}

	virtual ~_RefcountList() 
	{
        Purge();
	};

	T* GetPointer(int it) const { return (T*)BASECLASS::GetPointer(it); }   // doesn't addref.
	BOOL	Append(T* pt) { pt->AddRef(); return BASECLASS::Append((LPVOID)pt); }

	void	SetAutoDelete(BOOL b) { m_bAutoDelete=b;}

    void    Purge()
    {
   		if( m_bAutoDelete )
		{
			T* lpT;
			int i=0;
			int j=GetCount();
			while( lpT=GetPointer(i++) )
                lpT->Release();
		}
		DeleteHeap();
    }

protected:
	BOOL m_bAutoDelete;
};

template <class T> class _ListIterator
{
public:
	_ListIterator(_List<T> &list) : m_list(list), currentIndex(0) { }
	T* GetNext()	{ return m_list.GetPointer(currentIndex++);	}
	_List<T> & GetList()	{ return m_list;	}

protected:
	_List<T> & m_list;
	int currentIndex;	// current index in the list
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\parentinfo.h ===
// ParentInfo.h: interface for the CParentInfo class.
//
// Maintains the information about the edges used by the dialog for its controls.
//
// each control has a CLayoutInfo which relates to it.
// the ResizeControl class exposes the layout information of the control itself.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PARENTINFO_H__CBCB8816_7899_11D1_96A4_00C04FB177B1__INCLUDED_)
#define AFX_PARENTINFO_H__CBCB8816_7899_11D1_96A4_00C04FB177B1__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#include "rcmlpub.h"

#include "edge.h"

#undef PROPERTY
#define PROPERTY(type, Name) void Set##Name( type v) { m_##Name=v; } type Get##Name() const {return m_##Name; }


class CXMLDlg;
typedef _RefcountList<IRCMLControl> CXMLControlList;

//
// Maintains the information about the edges used by the dialog for its controls.
//
class CParentInfo  
{
public:
	CParentInfo();
	virtual ~CParentInfo();

	void DeterminBorders( CXMLControlList & controls);

	void Annotate( HDC hdc );
	CEdge ** GetHorizontalEdges();
	CEdge ** GetVerticalEdges();

	void Resize(int width, int height);

	void	Init(HWND h, CXMLDlg * pXML);
	CXMLDlg * GetXML() { return m_pXML; }

	LONG	GetWidth() const { return m_Size.right-m_Size.left; }
	LONG	GetHeight() const { return m_Size.bottom-m_Size.top; }

	LONG	GetLeft() const { return m_Size.left; }
	LONG	GetTop() const { return m_Size.top; }
	LONG	GetRight() const { return m_Size.right; }
	LONG	GetBottom() const { return m_Size.bottom; }

	void	DeterminSize();
	HWND	GetWindow() const { return m_hWnd;}

	LONG GetRightBorder() { return m_borders.right ; }
	LONG GetLeftBorder() { return m_borders.left ; }
	LONG GetTopBorder() { return m_borders.top ; }
	LONG GetBottomBorder() { return m_borders.bottom ; }

	CEdge	* AddEdge(int Position, int Axis, BOOL Flexible=false, int Offset=0);
	CEdge	* AddEdge(CGuide * pGuide, int Offset=0);

	CEdge *	GetLeftEdge() { return m_pLeftEdge; }
	CEdge *	GetRightEdge() { return m_pRightEdge; }
	CEdge *	GetTopEdge() { return m_pTopEdge; }
	CEdge *	GetBottomEdge() { return m_pBottomEdge; }

	int		GetNumHoriz() const { return m_Edges.GetNumHoriz(); }
	int		GetNumVert() const { return m_Edges.GetNumVert(); }

	PROPERTY( DIMENSION, MinimumSize );

    void    Purge();

private:
	DIMENSION	m_MinimumSize;
	RECT	m_Size;
	HWND	m_hWnd;
	CXMLDlg * m_pXML;

    RECT    m_borders;  // the gutters around the dialog.

	//
	// This is a list of the edges
	//
	CEdgeCache	m_Edges;

	//
	// These are the edges of the parent itself.
	//
	CEdge	*	m_pLeftEdge;
	CEdge	*	m_pRightEdge;
	CEdge	*	m_pTopEdge;
	CEdge	*	m_pBottomEdge;

	void	ConstructBorders();
	CEdge & FindCloseEdge(CEdge & Fixed, int Offset);
};

#endif // !defined(AFX_PARENTINFO_H__CBCB8816_7899_11D1_96A4_00C04FB177B1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\quickref.h ===
//******************************************************************************
//  
// QuickRef.h
//
// Copyright (C) 1994-1997 Microsoft Corporation
// All rights reserved.
//  
//******************************************************************************
 
#ifndef PERFUTIL__QuickRef_H__INCLUDED
#define PERFUTIL__QuickRef_H__INCLUDED

//------------------------------------------------------------------------------
// #pragma TODO("Rip out properties 'i' and 'ic'")
#define NOTHROW

template<class T>
class CQuickRef
{
// Construction
public:
	NOTHROW CQuickRef();
	NOTHROW CQuickRef(T * pI);
	NOTHROW CQuickRef(T * pI, BOOL fAddRef);
	NOTHROW CQuickRef(const CQuickRef<T> & qrSrc);
	~CQuickRef();

// Operations / Overrides
public:
	__declspec(property(get=GetInterface)) T * i;
	__declspec(property(get=GetInterface)) const T * ic;

	void Attach(T * pI);
	NOTHROW T * Detach();

	NOTHROW ULONG AddRef();
	ULONG Release();
	ULONG SafeRelease();

	NOTHROW ULONG AddRef() const;
	ULONG Release() const;
	ULONG SafeRelease() const;

	NOTHROW T * GetInterface();
	NOTHROW const T * GetInterface() const;
	NOTHROW BOOL IsNull() const;

	NOTHROW T * operator->();
	NOTHROW const T * operator->() const;
	NOTHROW T & operator*();

	void operator=(T * pOther);
	void operator=(const CQuickRef<T> & qrSrc);

	T ** operator&();
	//
	// Inline to work around a compiler bug...
	NOTHROW operator T* &() { (void)SafeRelease(); /*lint -e(1536) */ return m_pInterface; }

	NOTHROW bool operator!=(int null) const;
	NOTHROW bool operator==(int null) const;
	
protected:
	NOTHROW operator T*() {return NULL;};

// Implementation / Hidden
private:
	void operator delete(void *);

	
// Data
private:
	mutable T * m_pInterface;
	/*lint --e(770) */  // Lint is loosing it's mind!
};

//
//  Provide an easier name to use for QR smart pointers to a given class,
//  a-la the com IFooPtr stuff.
#define DEFINE_QUICKREF(ClassName) \
typedef CQuickRef<ClassName> ClassName##Ref; \
typedef CQuickRef<const ClassName> ClassName##CRef


#include "QuickRef.inl"

#endif  // PERFUTIL__QuickRef_H__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\quickref.inl ===
//******************************************************************************
//  
// QuickRef.inl
//
// Copyright (C) 1994-1997 Microsoft Corporation
// All rights reserved.
//  
//******************************************************************************

//------------------------------------------------------------------------------
/*lint -e1401 */ //Lint is wrong
template <class T>
CQuickRef< T >::CQuickRef()
{
	m_pInterface = NULL;
}


//------------------------------------------------------------------------------
template <class T>
CQuickRef< T >::CQuickRef(
		T * pI) 
{
	if (pI != NULL)
	{
		(void)pI->AddRef();
	}
	m_pInterface = pI;
};


//------------------------------------------------------------------------------

/*lint -e1541 */  //Lint is wrong
template <class T>
CQuickRef< T >::CQuickRef(
		T * pI,
		BOOL fAddRef)
{
	if (fAddRef)
	{
		ASSERT(pI != NULL);

		(void)pI->AddRef();
	}

	m_pInterface = pI;
}

//------------------------------------------------------------------------------
template <class T>
CQuickRef< T >::CQuickRef(
		const CQuickRef<T> & qrSrc)
{
	m_pInterface = qrSrc.m_pInterface;

	if (m_pInterface != NULL)
	{
		(void)AddRef();
	}
}


//------------------------------------------------------------------------------
template <class T>
ULONG 
CQuickRef< T >::Release()
{
	ASSERT(m_pInterface != NULL);

	ULONG n = (ULONG)m_pInterface->Release();
	m_pInterface = NULL;
	return n;
}


//------------------------------------------------------------------------------
template <class T>
ULONG 
CQuickRef< T >::SafeRelease()
{
	if (m_pInterface != NULL)
	{
		return Release();
	}
	else
	{
		return 0;
	}
}



//------------------------------------------------------------------------------
/*lint -e1540 */ //Lint is wrong
template <class T>
CQuickRef< T >::~CQuickRef()
{
	// This is over-kill, since the object is being destroyed.
	// SafeRelease();

	if (m_pInterface != NULL)
	{
		(void) m_pInterface->Release();
	}

	// DEBUGONLY(m_pInterface = NULL);
}



//------------------------------------------------------------------------------
template <class T>
void 
CQuickRef< T >::Attach(
		T * pI)
{
	(void)SafeRelease();
	m_pInterface = pI;			// Directly attached w/o ref count
}


//------------------------------------------------------------------------------
template <class T>
T * 
CQuickRef< T >::Detach(void)
{
	T * pInterface	= m_pInterface;
	m_pInterface	= NULL;
	return pInterface;
};


//------------------------------------------------------------------------------
template <class T>
ULONG 
CQuickRef< T >::AddRef()
{
	ASSERT(m_pInterface != NULL);
	return (ULONG)m_pInterface->AddRef();
}




//------------------------------------------------------------------------------
template <class T>
ULONG 
CQuickRef< T >::AddRef()
		const
{
	ASSERT(m_pInterface != NULL);
	return (ULONG)m_pInterface->AddRef();
}


//------------------------------------------------------------------------------
template <class T>
ULONG 
CQuickRef< T >::Release()
		const
{
	ASSERT(m_pInterface != NULL);
	ULONG n = (ULONG)m_pInterface->Release();
	m_pInterface = NULL;
	return n;
}


//------------------------------------------------------------------------------
template <class T>
ULONG 
CQuickRef< T >::SafeRelease()
		const
{
	if (m_pInterface != NULL)
	{
		return Release();
	}
	else
	{
		return 0;
	}
}


//------------------------------------------------------------------------------
template <class T>
T * 
CQuickRef< T >::GetInterface()	
{
	return m_pInterface;
};


//------------------------------------------------------------------------------
template <class T>
const T * 
CQuickRef< T >::GetInterface()
		const
{
	return m_pInterface;
}


//------------------------------------------------------------------------------
template <class T>
BOOL 
CQuickRef< T >::IsNull()
		const
{
	return m_pInterface == NULL;
}


//------------------------------------------------------------------------------
template <class T>
T * 
CQuickRef< T >::operator->(void)
{
	ASSERT(m_pInterface != NULL);
	return m_pInterface;
}


//------------------------------------------------------------------------------
template <class T>
const T * 
CQuickRef< T >::operator->(void)
		const
{
	ASSERT(m_pInterface != NULL);
	return m_pInterface;
}


//------------------------------------------------------------------------------
template <class T>
T & 
CQuickRef< T >::operator*(void)
{
	ASSERT(m_pInterface != NULL);
	return *m_pInterface;
}


//------------------------------------------------------------------------------
template <class T>
void 
CQuickRef< T >::operator=(
		T * pOther)
{
	(void)SafeRelease();

	if (pOther != NULL)
	{
		(void) pOther->AddRef();
	}
	m_pInterface = pOther;
}


//------------------------------------------------------------------------------
template<class T>
bool 
CQuickRef< T >::operator!=(
		int n)
		const
{
	ASSERT(n == 0);

	return m_pInterface != NULL;
}


//------------------------------------------------------------------------------
template<class T>
bool 
CQuickRef< T >::operator==(
		int n)
		const
{
	ASSERT(n == 0);

	return m_pInterface == NULL;
}



//------------------------------------------------------------------------------

template <class T>
void
/*lint -e1529 */  // Lint is wrong
CQuickRef< T >::operator=(
		const CQuickRef<T> & pInterface)
{
	/*lint --e(605) --e(58) */ //Lint is wrong
	if (this != &pInterface)
	{
		(void)SafeRelease();
		m_pInterface = pInterface.m_pInterface;

		if (m_pInterface != NULL)
		{
			(void)AddRef();
		}
	}
}




//------------------------------------------------------------------------------
template <class T>
T **
CQuickRef< T >::operator&()
{
	(void)SafeRelease();
	/*lint --e(1536) */ // Exposing low access member
	return &m_pInterface;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\persctl.h ===
//
// CLayoutInfo
//
// FelixA
//
// Resize controls

#ifndef __PERSISTCONTROL
#define __PERSISTCONTROL

class CParentInfo;

#include "edge.h"
interface IRCMLControl;

#undef PROPERTY
#define PROPERTY(type, Name) public: void Set##Name( type v) { m_##Name=v; } type Get##Name() const {return m_##Name; } private: type m_##Name; public:

class CLayoutInfo
{
public:
	int Attatchment( CGuide * pGuide);
	virtual ~CLayoutInfo();
    CLayoutInfo();
    void    Init(IRCMLControl * pControl, CParentInfo & pi );

	//
	// Everything is in dialog units, as that's how we get laid out.
	//
    LONG    GetWidth() { return m_Location.right - m_Location.left; }
    LONG    GetHeight() { return m_Location.bottom - m_Location.top; }

	RECT GetInitialPixelLocation() { return m_Location; }
    IRCMLControl * GetXMLControl() { return m_pControl; }

	PROPERTY( int, Col);	// Which col
	PROPERTY( int, Row);	// Which row
	PROPERTY( int, ColW);	// How many cells wide
	PROPERTY( int, RowH);	// How many cells high
	PROPERTY( int, PadLeft);	// Left inset padding
	PROPERTY( int, PadTop);		// Top padding;
	PROPERTY( int, PadRight);	//
	PROPERTY( int, PadBottom);	//
	PROPERTY( int, Alignment);	// bit fields TOP_AT, BOTTOM_AT, LEFT_AT, RIGHT_AT etc.

private:
	RECT	        m_Location; // Initial size of the control in Pixels.
    IRCMLControl  * m_pControl;
	CEdge	*	    m_pLeftEdge;
	CEdge	*	    m_pRightEdge;
	CEdge	*	    m_pTopEdge;
	CEdge	*	    m_pBottomEdge;

protected:
	int		m_RightSlop;		// ammount we can be off finding the right edge.
};

class CControlList : public _List<CLayoutInfo>
{
public:
	CControlList(){ m_bAutoDelete = FALSE; }
	virtual ~CControlList() {};
	CLayoutInfo * GetControl(int i) { return GetPointer(i); }
	int	GetControlCount() const { return GetCount(); }
};


#undef PROPERTY

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\rcml.h ===
#ifndef __XML2RCDLL_H__
#define __XML2RCDLL_H__

// The following ifdef block is the standard way of creating macros which make exporting 
// from a DLL simpler. All files within this DLL are compiled with the RCMLDLL_EXPORTS
// symbol defined on the command line. this symbol should not be defined on any project
// that uses this DLL. This way any other project whose source files include this file see 
// RCMLDLL_API functions as being imported from a DLL, wheras this DLL sees symbols
// defined with this macro as being exported.
#ifdef RCMLDLL_EXPORTS
#define RCMLDLL_API __declspec(dllexport) 
#else
#define RCMLDLL_API __declspec(dllimport) 
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#define RCMLDialogBoxA(hInstance, lpTemplate, hWndParent, lpDialogFunc) \
RCMLDialogBoxTableA(hInstance, lpTemplate, hWndParent, lpDialogFunc, 0L, 0L)
#define RCMLDialogBoxW(hInstance, lpTemplate, hWndParent, lpDialogFunc) \
RCMLDialogBoxTableW(hInstance, lpTemplate, hWndParent, lpDialogFunc, 0L, 0L)

#ifdef UNICODE
#define RCMLDialogBox  RCMLDialogBoxW
#define RCMLDialogBoxParam  RCMLDialogBoxParamW
#else
#define RCMLDialogBox  RCMLDialogBoxA
#define RCMLDialogBoxParam  RCMLDialogBoxParamA
#endif // !UNICODE

#define RCMLDialogBoxParamA(hInstance, lpTemplate, hWndParent, lpDialogFunc, param) \
RCMLDialogBoxTableA(hInstance, lpTemplate, hWndParent, lpDialogFunc, param, 0L)
#define RCMLDialogBoxParamW(hInstance, lpTemplate, hWndParent, lpDialogFunc, param) \
RCMLDialogBoxTableW(hInstance, lpTemplate, hWndParent, lpDialogFunc, param, 0L)

#ifdef UNICODE
#define RCMLDialogBoxTable  RCMLDialogBoxTableW
#else
#define RCMLDialogBoxTable  RCMLDialogBoxTableA
#endif // !UNICODE

RCMLDLL_API int WINAPI RCMLDialogBoxTableA( HINSTANCE hinst, LPCSTR pszFile, HWND parent, DLGPROC dlgProc, LPARAM dwInitParam, LPCSTR * pszEntities);
RCMLDLL_API int WINAPI RCMLDialogBoxTableW( HINSTANCE hinst, LPCTSTR pszFile, HWND parent, DLGPROC dlgProc, LPARAM dwInitParam,LPCTSTR * pszEntities); 

// Indirect

#define RCMLDialogBoxIndirectA(hInstance, lpTemplate, hWndParent, lpRCMLDialogFunc) \
RCMLDialogBoxIndirectParamA(hInstance, lpTemplate, hWndParent, lpRCMLDialogFunc, 0L)
#define RCMLDialogBoxIndirectW(hInstance, lpTemplate, hWndParent, lpRCMLDialogFunc) \
RCMLDialogBoxIndirectParamW(hInstance, lpTemplate, hWndParent, lpRCMLDialogFunc, 0L)
#ifdef UNICODE
#define RCMLDialogBoxIndirect  RCMLDialogBoxIndirectW
#else
#define RCMLDialogBoxIndirect  RCMLDialogBoxIndirectA
#endif // !UNICODE

#ifdef UNICODE
#define RCMLDialogBoxIndirectParam  RCMLDialogBoxIndirectParamW
#else
#define RCMLDialogBoxIndirectParam  RCMLDialogBoxIndirectParamA
#endif // !UNICODE

RCMLDLL_API int WINAPI RCMLDialogBoxIndirectParamA( HINSTANCE hinst, LPCSTR pszRCML, HWND parent, DLGPROC dlgProc, LPARAM dwInitParam );
RCMLDLL_API int WINAPI RCMLDialogBoxIndirectParamW( HINSTANCE hinst, LPCWSTR pszRCML, HWND parent, DLGPROC dlgProc, LPARAM dwInitParam ); 


//
// Property Sheets
//
#ifndef _PRSHT_H_
#include <prsht.h>
#endif
RCMLDLL_API int WINAPI RCMLPropertySheetA(LPCPROPSHEETHEADERA lppsph); // PropertySheet
RCMLDLL_API int WINAPI RCMLPropertySheetW(LPCPROPSHEETHEADERW lppsph); // PropertySheet
RCMLDLL_API HPROPSHEETPAGE WINAPI RCMLCreatePropertySheetPageA( LPCPROPSHEETPAGEA lppsp );// CreatePropertySheetPageA
RCMLDLL_API HPROPSHEETPAGE WINAPI RCMLCreatePropertySheetPageW( LPCPROPSHEETPAGEW lppsp );// CreatePropertySheetPage

#ifdef UNICODE
#define RCMLCreatePropertySheetPage  RCMLCreatePropertySheetPageW
#define RCMLPropertySheet            RCMLPropertySheetW
#define RCMLCreateDlgTemplate		 RCMLCreateDlgTemplateW
#else
#define RCMLCreatePropertySheetPage  RCMLCreatePropertySheetPageA
#define RCMLPropertySheet            RCMLPropertySheetA
#define RCMLCreateDlgTemplate		 RCMLCreateDlgTemplateA
#endif


//
// CreateDialog wrappers
//
RCMLDLL_API HWND WINAPI RCMLCreateDialogParamTableA( HINSTANCE hinst, LPCSTR pszFile, HWND parent, DLGPROC dlgProc, LPARAM dwInitParam, LPCSTR * pszEntities);
RCMLDLL_API HWND WINAPI RCMLCreateDialogParamTableW( HINSTANCE hinst, LPCTSTR pszFile, HWND parent, DLGPROC dlgProc, LPARAM dwInitParam, LPCTSTR * pszEntities); 

#define RCMLCreateDialogA(hInstance, lpTemplate, hWndParent, lpDialogFunc ) \
RCMLCreateDialogParamTableA(hInstance, lpTemplate, hWndParent, lpDialogFunc, 0L, 0L)

#define RCMLCreateDialogW(hInstance, lpTemplate, hWndParent, lpDialogFunc ) \
RCMLCreateDialogParamTableW(hInstance, lpTemplate, hWndParent, lpDialogFunc, 0L, 0L)

#define RCMLCreateDialogParamA(hInstance, lpTemplate, hWndParent, lpDialogFunc , dwInitParam) \
RCMLCreateDialogParamTableA(hInstance, lpTemplate, hWndParent, lpDialogFunc, dwInitParam, 0L)

#define RCMLCreateDialogParamW(hInstance, lpTemplate, hWndParent, lpDialogFunc , dwInitParam) \
RCMLCreateDialogParamTableW(hInstance, lpTemplate, hWndParent, lpDialogFunc, dwInitParam, 0L)

#ifdef UNICODE
#define RCMLCreateDialog RCMLCreateDialogW
#define RCMLCreateDialogParam RCMLCreateDialogParamW
#define RCMLCreateDialogParamTable RCMLCreateDialogParamTableW
#else
#define RCMLCreateDialog RCMLCreateDialogA
#define RCMLCreateDialogParam RCMLCreateDialogParamA
#define RCMLCreateDialogParamTable RCMLCreateDialogParamTableA
#endif

#ifndef _INC_COMMDLG
#include <commdlg.h>
#endif

BOOL APIENTRY RCMLChooseFontA(LPCHOOSEFONTA);
BOOL APIENTRY RCMLChooseFontW(LPCHOOSEFONTW);
#ifdef UNICODE
#define RCMLChooseFont  RCMLChooseFontW
#else
#define RCMLChooseFont  RCMLChooseFontA
#endif // !UNICODE


//
// end CreateDialog wrappers
//

// flat APIs that map to CWin32Dlg member functions
typedef struct { UINT cbSize; LPVOID rcmlData; LPVOID rcmlDialog; } RCML_HANDLE;

RCMLDLL_API RCML_HANDLE * WINAPI RCMLCreateDialogHandle(void);
RCMLDLL_API void WINAPI RCMLDestroyDialog(RCML_HANDLE * pRCML);

RCMLDLL_API BOOL WINAPI RCMLCreateDlgTemplateA(RCML_HANDLE * pRCML, HINSTANCE h, LPCSTR pszFile, DLGTEMPLATE** pDt);
RCMLDLL_API BOOL WINAPI RCMLCreateDlgTemplateW(RCML_HANDLE * pRCML, HINSTANCE h, LPCWSTR pszFile, DLGTEMPLATE** pDt);

RCMLDLL_API void WINAPI RCMLOnInit(RCML_HANDLE * pRCML, HWND hDlg);
RCMLDLL_API BOOL CALLBACK  WINAPI RCMLCallDlgProc(RCML_HANDLE * pRCML, HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);


//
// External files.
//
RCMLDLL_API void WINAPI RCMLSetKey(HKEY h);

//
// String Table methods.
//
RCMLDLL_API
int
WINAPI
RCMLLoadStringA(
    HWND hWnd,
    UINT uID,
    LPSTR lpBuffer,
    int nBufferMax);

RCMLDLL_API 
int
WINAPI
RCMLLoadStringW(
    HWND hWnd,
    UINT uID,
    LPWSTR lpBuffer,
    int nBufferMax);

#ifdef UNICODE
#define RCMLLoadString  RCMLLoadStringW
#else
#define RCMLLoadString  RCMLLoadStringA
#endif // !UNICODE

RCMLDLL_API
HWND
WINAPI
RCMLGetDlgItem(
    HWND hDlg,
    LPCWSTR pszControlName);

//
// Getting the tree back, UNICODE ONLY.
//
#ifdef _RCML_LOADFILE
#include "rcmlpub.h"

RCMLDLL_API HRESULT WINAPI RCMLLoadFile( LPCWSTR pszRCML, int iPageID, IRCMLNode ** ppRCMLNode );
#endif

#ifdef __cplusplus
}            /* Assume C declarations for C++ */
#endif  /* __cplusplus */


#endif // __XML2RCDLL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\rcmlloader.cpp ===
// RCMLLoader.cpp: implementation of the CRCMLLoader class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "RCMLLoader.h"

#include "xmlbutton.h"
#include "xmldlg.h"
#include "xmlforms.h"
#include "xmlstringtable.h"
#include "xmlitem.h"
#include "xmllayout.h"
#include "xmlformoptions.h"
#include "xmledit.h"
#include "xmlcombo.h"
#include "xmllistbox.h"
#include "xmllog.h"
#include "xmllabel.h"
#include "xmlimage.h"
#include "xmlrect.h"
#include "xmlcaption.h"
#include "xmlslider.h"
#include "xmlscrollbar.h"
#include "xmlspinner.h"
#include "xmlprogress.h"
#include "xmllistview.h"
#include "xmltreeview.h"
#include "xmlpager.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


#define XMLNODE(name, function) { name, CXML##function::newXML##function }

CRCMLLoader::XMLELEMENT_CONSTRUCTOR g_RCMLNS[]=
{

   	//
	// Root node.
	//
	XMLNODE( TEXT("RCML"), RCML ),

	XMLNODE( TEXT("FORM"), Forms ),         // this is a container for the 'pages'
        XMLNODE( TEXT("LOGINFO"), Log ),
	    XMLNODE( TEXT("CAPTION"), Caption ),

	XMLNODE( TEXT("PAGE"), Dlg ),           // you get these from the FORM

   	//
	// High level controls.
	//
	XMLNODE( TEXT("DIALOG"), Dlg ),
	XMLNODE( TEXT("CONTROL"), SimpleControl ),

	//
	// Specializations
	//
	XMLNODE( TEXT("BUTTON"), Button ),

	XMLNODE( TEXT("CHECKBOX"), CheckBox ),

	XMLNODE( TEXT("RADIOBUTTON"), RadioButton ),

	XMLNODE( TEXT("GROUPBOX"), GroupBox ),

  	XMLNODE( TEXT("EDIT"), Edit ),

	XMLNODE( TEXT("COMBOBOX"), Combo ),

	XMLNODE( TEXT("LISTBOX"), ListBox),

	XMLNODE( TEXT("LABEL"), Label ),

	XMLNODE( TEXT("IMAGE"), Image ),

	XMLNODE( TEXT("RECT"), Rect),

	XMLNODE( TEXT("PROGRESS"), Progress),
	    XMLNODE( TEXT("RANGE"), Range ),

	XMLNODE( TEXT("LISTVIEW"), ListView),
    	XMLNODE( TEXT("COLUMN"), Column),
        
	XMLNODE( TEXT("TREEVIEW"), TreeView),

	XMLNODE( TEXT("SCROLLBAR"), ScrollBar ),

	//
	// Common controls.
	//
	XMLNODE( TEXT("SLIDER"), Slider ),
	    // XMLNODE( TEXT("RANGE"), Range ),

	XMLNODE( TEXT("SPINNER"), Spinner ),
	    // XMLNODE( TEXT("RANGE"), Range ),

	//
	// Enhancements.
	//
	XMLNODE( TEXT("RELATIVE"), Location ),
	XMLNODE( TEXT("STYLE"), Style ),
	XMLNODE( TEXT("HELP"), Help ),
	    XMLNODE( TEXT("BALLOON"), Balloon ),
	    XMLNODE( TEXT("TOOLTIP"), Tooltip),

	//
	// Layout stuff.
	//
	XMLNODE( TEXT("LAYOUT"), Layout ),              // holds layout managers
	    XMLNODE( TEXT("WIN32LAYOUT"), Win32Layout ),    // XY and Win32 layout are the same.
	    XMLNODE( TEXT("XYLAYOUT"), Win32Layout ),
	        XMLNODE( TEXT("GRID"), Grid ),

    //
    // String table
    //
	XMLNODE( TEXT("STRINGTABLE"), StringTable ),
	    XMLNODE( TEXT("ITEM"), Item ),

	XMLNODE( TEXT("PAGER"), Pager),
	XMLNODE( TEXT("HEADER"), Header ),
	XMLNODE( TEXT("TAB"), Tab ),

	//
	// End.
	//
	{ NULL, NULL} 
};



CRCMLLoader::XMLELEMENT_CONSTRUCTOR g_Win32NS[] = 
{
    XMLNODE( TEXT("STYLE"), Win32 ),              

    XMLNODE( TEXT("DIALOGSTYLE"), FormOptions ),

    XMLNODE( TEXT("BUTTON"), ButtonStyle ),

    XMLNODE( TEXT("CHECKBOX"), ButtonStyle ),

    XMLNODE( TEXT("RADIOBUTTON"), ButtonStyle ),

    XMLNODE( TEXT("GROUPBOX"), ButtonStyle ),

    XMLNODE( TEXT("EDIT"), EditStyle ),

	XMLNODE( TEXT("LISTBOX"), ListBoxStyle ),

	XMLNODE( TEXT("LABEL"), StaticStyle ),

    XMLNODE( TEXT("IMAGE"), StaticStyle ),

    XMLNODE( TEXT("RECT"), StaticStyle ),

   	XMLNODE( TEXT("LISTVIEW"), ListViewStyle),
        
   	XMLNODE( TEXT("TREEVIEW"), TreeViewStyle ),

    XMLNODE( TEXT("SCROLLBAR"), ScrollBarStyle ),

    XMLNODE( TEXT("TAB"), TabStyle ),

    XMLNODE( TEXT("COMBOBOX"), ComboStyle ),

	//
	// End.
	//
	{ NULL, NULL} 
};

CRCMLLoader::CRCMLLoader()
: BASECLASS()
{
	m_pRCML=NULL;
	m_bPostProcessed=FALSE;
    m_pEntitySet=NULL;
	m_AutoDelete = TRUE;

    RegisterNameSpace( TEXT("urn:schemas-microsoft-com:rcml"), CRCMLLoader::CreateRCMLElement );
    RegisterNameSpace( TEXT("urn:schemas-microsoft-com:rcml:win32"), CRCMLLoader::CreateWin32Element );
}

IRCMLNode * CRCMLLoader::CreateRCMLElement( LPCTSTR pszElement )
{ return CreateElement( g_RCMLNS, pszElement ); }

IRCMLNode * CRCMLLoader::CreateWin32Element( LPCTSTR pszElement )
{ return CreateElement( g_Win32NS, pszElement ); }


IRCMLNode * CRCMLLoader::CreateElement( PXMLELEMENT_CONSTRUCTOR dictionary, LPCTSTR pszElement )
{
	if(dictionary)
	{
		PXMLELEMENT_CONSTRUCTOR pEC=dictionary;
		while( pEC->pwszElement )
		{
			if( lstrcmpi( pszElement , pEC->pwszElement) == 0 )
			{
				CLSPFN pFunc=pEC->pFunc;
                return pFunc();
			}
			pEC++;
		}
#ifdef LOGCAT_LOADER
        EVENTLOG( EVENTLOG_WARNING_TYPE, LOGCAT_LOADER, 1,
            TEXT("XMLLoader"), TEXT("The node '%s' isn't recognized, skipping"), pszElement );
#endif
    }
    return NULL;
}



CRCMLLoader::~CRCMLLoader()
{
	if(m_AutoDelete && m_pRCML)
		m_pRCML->Release();
}


//
// Obtains the head of the RCML file we processed.
//
CXMLRCML * CRCMLLoader::GetHead()
{
    if( m_pRCML==NULL)
    {
        m_pRCML=(CXMLRCML*)GetHeadElement();
        m_pRCML->AddRef();
    }
	return m_pRCML;
}

//
// Walks the list of dialogs, and finds the one with this ID.
// ID of zero means the first one.
//
CXMLDlg * CRCMLLoader::GetDialog(int nID)
{
    CXMLRCML * pRCML=GetHead();
    if(pRCML)
    {
        CXMLForms * pForms=NULL;
        int id=0;
        while( (pForms=pRCML->GetForms(id)))
        {
            int dlgid=0;
            CXMLDlg * pDlg;
            while( (pDlg=pForms->GetDialog(dlgid) ) )
            {
                // Integer only version checks here.
                LPWSTR pID;
                if( SUCCEEDED( pDlg->get_ID( &pID) ))
                    if( (HIWORD(pID)==NULL) && (LOWORD(pID) == nID ) )
                        return pDlg;
                dlgid++;
            }
            id++;
        }
    }
    TRACE(TEXT("Failed to find dialog ID %d\n"),nID);
    return NULL;
}


//
//
//
LPCTSTR CRCMLLoader::DoEntityRef( LPCTSTR pszEntity )
{
    //
    // check the first 2 chars
    //
    if(m_pEntitySet==NULL)
        return pszEntity;

    int ilen=lstrlen(pszEntity);
    if(ilen<2)
        return pszEntity;
    if( *pszEntity==__T('s') || *pszEntity==__T('S')) 
    {
        int i=_ttoi(pszEntity+1);
        if(i==0)
            return pszEntity;
        return m_pEntitySet[i-1];
    }
    return pszEntity;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\rcml.cpp ===
// XML2RCDLL.cpp : Defines the entry point for the DLL application.
//

#include "stdafx.h"
#define RCMLDLL_EXPORTS
#define _RCML_LOADFILE
#include "rcml.h"

#include <ole2.h>
#include "msxml.h"   // make sure these pick up the IE 5 versions
#include "uiparser.h"

#include "stringproperty.h"
#include "rcmlloader.h"
#include "utils.h"
#include "eventlog.h"
#include "renderDlg.h"

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    switch (ul_reason_for_call)
	{
		case DLL_PROCESS_ATTACH:
	        DisableThreadLibraryCalls((HMODULE)hModule);
			break;

		case DLL_PROCESS_DETACH:
			break;
    }
    return TRUE;
}

#ifdef _OLDCODE
void FindPixelFontSize()
{
	CQuickFont f(TEXT("Verdana"), 8 );
	SIZE s={101,209};

	SIZE r;
	
	for(int iSize=1;iSize<10;iSize++)
	{
		f.Init(TEXT("Verdana"), iSize );
		r=f.GetPixelsFromDlgUnits(s);

		if( (s.cx==r.cx) && (s.cy==r.cy) )
		{
			int i=5;
		}
	}
}
#endif

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Holds the external key provided by the application for refering to outside files.
//
HKEY g_ExternalFileKey;

RCMLDLL_API void WINAPI RCMLSetKey(HKEY h)
{
    g_ExternalFileKey=h;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Implementations of dialog box etc.
//
#undef DialogBoxA

int WINAPI RCMLDialogBoxTableA( HINSTANCE hinst, LPCSTR pszFile, HWND parent, DLGPROC dlgProc, LPARAM dwInitParam, LPCSTR * pszEntities)
{
    int retVal;
    int iEntityCount=0;

    if( pszEntities )
    {
        while( pszEntities[iEntityCount] )
            iEntityCount++;
    }

#ifndef UNICODE
	retVal = RCMLDialogBoxTableW(hinst, pszFile, parent, dlgProc, dwInitParam, pszEntities);
#else
    LPCWSTR * pszEntitiesW=NULL;
    if( iEntityCount )
    {
        pszEntitiesW=new LPCWSTR[iEntityCount];
        for(int i=0;i<iEntityCount;i++)
            pszEntitiesW[i]=UnicodeStringFromAnsi(pszEntities[i]);
    }

    //
    // Could be a dlgID or a filename.
    //
    LPWSTR pUnicodeString = (LPWSTR)pszFile;
    if( HIWORD( pszFile ) )
    	pUnicodeString = UnicodeStringFromAnsi(pszFile);
	retVal = RCMLDialogBoxTableW(hinst, pUnicodeString, parent, dlgProc, dwInitParam, pszEntitiesW);
    if( HIWORD( pUnicodeString ) )
	    delete pUnicodeString;

    if( iEntityCount )
    {
        for(int i=0;i<iEntityCount;i++)
            delete (LPWSTR)pszEntitiesW[i];
        delete pszEntitiesW;
    }
#endif
	return retVal;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// To build the RCML tree from any given file we do the following
// an RCMLLoader
//
int WINAPI RCMLDialogBoxTableW( HINSTANCE hinst, LPCTSTR pszFile, HWND parent, DLGPROC dlgProc, LPARAM dwInitParam, LPCTSTR * pszEntities)
{
#ifdef _DICTIONARY_CHECK
    {
        CDictionary testDick;
        UINT id=testDick.GetID( TEXT("Hello") );
        TCHAR szBuf[100];
        for(int i=1; i<100; i++ )
        {
            wsprintf(szBuf,TEXT("%d Number %d"),i,i);
            testDick.GetID( szBuf );
        }

        CStringPropertySection ps;
        TCHAR szBuf2[100];
        for(i=1; i<4; i++ )
        {
            wsprintf(szBuf2,TEXT("%d"),i);
            wsprintf(szBuf,TEXT("%d Number %d"),i,i);
            ps.Set( szBuf2, szBuf );
        }

#if 0
        for(i=1; i<100; i++ )
        {
            wsprintf(szBuf2,TEXT("%d"),i);
            wsprintf(szBuf,TEXT("%d Number %d"),i,i);
            if( lstrcmp( ps.Get( szBuf2), szBuf ) != 0 )
            {
                i=5;
            }
        }
#endif
        return id;
    }
#endif

	CUIParser parser;
    parser.SetEntities( pszEntities );

    //
    // You can't log the loggin information at this stage, only once the LOGINFO element is processed.
    //
    if( HIWORD( pszFile ))
    {
        EVENTLOG( EVENTLOG_INFORMATION_TYPE, LOGCAT_LOADER, 1,
            TEXT("RCMLDialogBoxTableW"), TEXT("Trying to load the supplied file '%s'."), pszFile );
    }
    else
    {
        EVENTLOG( EVENTLOG_INFORMATION_TYPE, LOGCAT_LOADER, 1,
            TEXT("RCMLDialogBoxTableW"), TEXT("Trying to load the supplied resource. HINST=0x%08x, ID=0x%04x (%d)."), hinst, pszFile, pszFile );
    }

	HRESULT hr;
    BOOL    bExternal;
	if( SUCCEEDED( hr=parser.Load(pszFile, hinst, &bExternal ) ) )
	{
        if( HIWORD( pszFile ))
        {
            EVENTLOG( EVENTLOG_INFORMATION_TYPE, LOGCAT_LOADER, 1,
                TEXT("RCMLDialogBoxTableW"), TEXT("Loaded the supplied file '%s'."), pszFile );
        }
        else
        {
            EVENTLOG( EVENTLOG_INFORMATION_TYPE, LOGCAT_LOADER, 1,
                TEXT("RCMLDialogBoxTableW"), TEXT("Loaded the supplied resource. HINST=0x%08x, ID=0x%04x (%d)."), hinst, pszFile, pszFile );
        }

		CXMLDlg * pQs=parser.GetDialog(0);
		if(pQs)
		{
            pQs->SetExternalFileWarning(bExternal);
            EVENTLOG( EVENTLOG_INFORMATION_TYPE, LOGCAT_LOADER | LOGCAT_CONSTRUCT | LOGCAT_RUNTIME , 1,
                TEXT("RCMLDialogBoxTableW"), TEXT("Dialog being displayed : HINST=0x%08x PARENT=0x%08x DLGPROC=0x%08x LPARAM=0x%08x"), hinst, parent, dlgProc, dwInitParam  );

			CRenderXMLDialog renderDialog( hinst, parent, dlgProc, dwInitParam );
			int iRet=renderDialog.Render( pQs );

            EVENTLOG( EVENTLOG_INFORMATION_TYPE, LOGCAT_LOADER | LOGCAT_CONSTRUCT | LOGCAT_RUNTIME , 1,
                TEXT("RCMLDialogBoxTableW"), TEXT("Dialog was displayed, return was %d"), iRet );
            return iRet;
        }
		else
		{
            EVENTLOG( EVENTLOG_ERROR_TYPE, LOGCAT_LOADER, 1,
                TEXT("RCMLDialogBoxTableW"), TEXT("File didn't contain the Dialog/FORM requested") );
		}
	}
	else
	{   
		if(hr==E_FAIL)
		{
            if( HIWORD( pszFile ))
            {
                EVENTLOG( EVENTLOG_ERROR_TYPE, LOGCAT_LOADER, 1,
                    TEXT("RCMLDialogBoxTableW"), TEXT("Cannot open the supplied file '%s'."), pszFile );
            }
            else
            {
                EVENTLOG( EVENTLOG_ERROR_TYPE, LOGCAT_LOADER, 1,
                    TEXT("RCMLDialogBoxTableW"), TEXT("Cannot open the supplied resource. HINST=0x%08x, ID=0x%04x (%d)."), hinst, pszFile, pszFile );
            }
		}
		else
		{
            if( (hr >= XML_E_PARSEERRORBASE) || (hr <=XML_E_LASTERROR) )
            {
                EVENTLOG( EVENTLOG_ERROR_TYPE, LOGCAT_LOADER, 1,
                    TEXT("RCMLDialogBoxTableW"), TEXT("There is an error in your RCML file = 0x%08x. Please open the file using Internet Explorer to find the errors."), hr );
            }
            else
            {
                EVENTLOG( EVENTLOG_ERROR_TYPE, LOGCAT_LOADER, 1,
                    TEXT("RCMLDialogBoxTableW"), TEXT("Your system is not able to support the requirements of this application. Please regsrv32 msxml.dll found in this folder (at your own risk), or upgrade your version of IE5") );
            }
		}
	}
	return -1;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
RCMLDLL_API int WINAPI RCMLDialogBoxIndirectParamA( HINSTANCE hinst, LPCSTR pszRCML, HWND parent, DLGPROC dlgProc, LPARAM dwInitParam )
{
    int retVal;
    int iEntityCount=0;

#if 0
    if( pszEntities )
    {
        while( pszEntities[iEntityCount] )
            iEntityCount++;
    }
#else
    LPCSTR * pszEntities=NULL;
#endif

#ifndef UNICODE
	retVal = RCMLDialogBoxTableW(hinst, pszFile, parent, dlgProc, dwInitParam, pszEntities);
#else
    LPCWSTR * pszEntitiesW=NULL;
    if( iEntityCount )
    {
        pszEntitiesW=new LPCWSTR[iEntityCount];
        for(int i=0;i<iEntityCount;i++)
            pszEntitiesW[i]=UnicodeStringFromAnsi(pszEntities[i]);
    }

    //
    // Could be a dlgID or a filename.
    //
    LPWSTR pUnicodeString = (LPWSTR)pszRCML;
    if( HIWORD( pszRCML ) )
    {
    	pUnicodeString = UnicodeStringFromAnsi(pszRCML);
#if 1
        UINT strLen=lstrlenW(pUnicodeString)+1;
        LPWSTR pLead=new WCHAR[strLen+2];
        CopyMemory( pLead+1, pUnicodeString, strLen*sizeof(WCHAR) );
        *pLead=(WORD)0xfeff;    // UNICODE prefix?
        delete pUnicodeString;
        pUnicodeString=pLead;
#endif
    }

	retVal = RCMLDialogBoxIndirectParamW(hinst, pUnicodeString, parent, dlgProc, dwInitParam);
    if( HIWORD( pUnicodeString ) )
	    delete pUnicodeString;

    if( iEntityCount )
    {
        for(int i=0;i<iEntityCount;i++)
            delete (LPWSTR)pszEntitiesW[i];
        delete pszEntitiesW;
    }
#endif
	return retVal;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// The RCML text in in the pszRCML (indirect data).
//
RCMLDLL_API int WINAPI RCMLDialogBoxIndirectParamW( HINSTANCE hinst, LPCWSTR pszRCML, HWND parent, DLGPROC dlgProc, LPARAM dwInitParam )
{
    if( HIWORD(pszRCML)==NULL)
        return -1;

	CUIParser parser;
    parser.SetEntities( NULL );
	HRESULT hr;


	if( SUCCEEDED( hr=parser.Parse(pszRCML) ) )
	{
        EVENTLOG( EVENTLOG_INFORMATION_TYPE, LOGCAT_LOADER, 1,
            TEXT("RCMLDialogBoxTableW"), TEXT("Loaded the supplied text '%s'."), pszRCML );

		CXMLDlg * pQs=parser.GetDialog(0);
		if(pQs)
		{
            EVENTLOG( EVENTLOG_INFORMATION_TYPE, LOGCAT_LOADER | LOGCAT_CONSTRUCT | LOGCAT_RUNTIME , 1,
                TEXT("RCMLDialogBoxTableW"), TEXT("Dialog being displayed : HINST=0x%08x PARENT=0x%08x DLGPROC=0x%08x LPARAM=0x%08x"), hinst, parent, dlgProc, dwInitParam  );

			CRenderXMLDialog renderDialog( hinst, parent, dlgProc, dwInitParam );
			int iRet=renderDialog.Render( pQs );

            EVENTLOG( EVENTLOG_INFORMATION_TYPE, LOGCAT_LOADER | LOGCAT_CONSTRUCT | LOGCAT_RUNTIME , 1,
                TEXT("RCMLDialogBoxTableW"), TEXT("Dialog was displayed, return was %d"), iRet );
            return iRet;
        }
		else
		{
            EVENTLOG( EVENTLOG_ERROR_TYPE, LOGCAT_LOADER, 1,
                TEXT("RCMLDialogBoxTableW"), TEXT("Text didn't contain the Dialog/FORM requested") );
		}
	}
	else
	{   
		if(hr==E_FAIL)
		{
            EVENTLOG( EVENTLOG_ERROR_TYPE, LOGCAT_LOADER, 1,
                TEXT("RCMLDialogBoxTableW"), TEXT("Cannot open the supplied text '%s'."), pszRCML );
		}
		else
		{
            if( (hr >= XML_E_PARSEERRORBASE) || (hr <=XML_E_LASTERROR) )
            {
                EVENTLOG( EVENTLOG_ERROR_TYPE, LOGCAT_LOADER, 1,
                    TEXT("RCMLDialogBoxTableW"), TEXT("There is an error in your RCML text = 0x%08x. Please open the file using Internet Explorer to find the errors."), hr );
            }
            else
            {
                EVENTLOG( EVENTLOG_ERROR_TYPE, LOGCAT_LOADER, 1,
                    TEXT("RCMLDialogBoxTableW"), TEXT("Your system is not able to support the requirements of this application. Please regsrv32 msxml.dll found in this folder (at your own risk), or upgrade your version of IE5") );
            }
		}
	}
    return -1;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Internal String helper
//
LPCWSTR FindStringTableString( HWND hWnd, UINT uID )
{
    IRCMLControl * pxmlDlg=GetXMLControl(hWnd);
    if(pxmlDlg)
    {
        if(SUCCEEDED( pxmlDlg->IsType(L"DIALOG" )) )
        {
            //
            CXMLDlg * pDlg = (CXMLDlg*)pxmlDlg;
            CXMLStringTable * pStringTable = pDlg->GetStringTable();
            if(pStringTable)
            {
                int iIndex=0;
                CXMLItem * pItem = NULL;
                do
                {
                    if( pItem = pStringTable->GetItem( iIndex++ ) )
                    {
                        if(pItem->GetValue() == uID )
                            return pItem->GetText();
                    }
                } while(pItem);
            }
        }
    }
    return NULL;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// String Table Methods
// LoadString
//
RCMLDLL_API int WINAPI RCMLLoadStringW( HWND hWnd, UINT uID, LPWSTR lpBuffer, int nBufferMax )
{
    // Get XML for this hWnd, get string table, walk table, return string.
    int iTextLen = 0;

    LPCWSTR pText = FindStringTableString( hWnd, uID );

    if(pText)
    {
        if(lpBuffer)
        {
            int cchBufferMax = nBufferMax - 1 ; // account for the NULL
            iTextLen=lstrlen(pText)+1;   
            if( iTextLen > cchBufferMax )
                iTextLen = cchBufferMax;
            lstrcpyn(lpBuffer, pText, iTextLen);
            lpBuffer[iTextLen]=0;
        }
    }
    return iTextLen;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
RCMLDLL_API int WINAPI RCMLLoadStringA( HWND hWnd, UINT uID, LPSTR lpBuffer, int nBufferMax )
{
    // Get XML for this hWnd, get string table, walk table, return string.
    int iTextLen = 0;

    LPCWSTR pText = FindStringTableString( hWnd, uID );

    if(pText)
    {
        if(lpBuffer)
        {
            int cchBufferMax = nBufferMax - 1;  // account for the NULL
            iTextLen=lstrlen(pText);
            if( iTextLen > cchBufferMax )
                iTextLen = cchBufferMax;
            WideCharToMultiByte( CP_ACP, 0,  pText, -1, lpBuffer, nBufferMax, NULL, NULL);
            lpBuffer[iTextLen]=0;
        }
    }
    return iTextLen;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Wrappers for GetDlgItem
//
RCMLDLL_API
HWND
WINAPI
RCMLGetDlgItem(
    HWND hDlg,
    LPCWSTR pszControlName)
{
    HWND hwndRes=NULL;
    if(HIWORD(pszControlName)==NULL)
        return NULL;

    IRCMLControl * pxmlDlg=GetXMLControl(hDlg);
    if(pxmlDlg)
    {
        if(SUCCEEDED( pxmlDlg->IsType(L"DIALOG" )) )
        {
            //
            CXMLDlg * pDlg = (CXMLDlg*)pxmlDlg;
	        IRCMLControl * pControl=NULL;
	        IRCMLControl * pLastControl=NULL;
            IRCMLControlList & children=pDlg->GetChildren();
            int i=0;
            while( pControl=children.GetPointer(i++ ) )
            {
                LPWSTR pID;
                if( SUCCEEDED( pControl->get_ID(&pID) ))
                {
                    if(HIWORD(pID) && (lstrcmpi( pszControlName, pID) == 0) )
                    {
                        HWND hWnd;
                        if( SUCCEEDED ( pControl->get_Window(&hWnd) ))
                            return hWnd;
                    }
                }
	        }
        }
    }
    return hwndRes;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Returns an IRCMLNode to the root of the loaded RCML file.
// the root is the <FORM> element.
// the PARENT may NOT exist.
//
HRESULT WINAPI RCMLLoadFile( LPCWSTR pszRCML, int iPageID, IRCMLNode ** ppRCMLNode )
{
	CUIParser parser;
    parser.SetEntities( NULL );
	HRESULT hr=E_FAIL;
    BOOL bFalse=FALSE;
	if( SUCCEEDED( hr=parser.Load((LPCTSTR)pszRCML, NULL, &bFalse) ) )
	{
#if 0
        // if we want to give back the <FORM>
        CXMLForms * pForms = parser.GetForm();
        if(pForms)
        {
            *ppRCMLNode = pQs;
            pForms->AddRef();
        }
        else
            hr=E_INVALIDARG;
#endif
        // gives back the <PAGE>
		CXMLDlg * pQs=parser.GetDialog(iPageID);
		if(pQs)
        {
            *ppRCMLNode = pQs;
            pQs->AddRef(); // our clients simple Release to free this??
        }
        else
            hr=E_INVALIDARG;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\rcmlloader.h ===
// RCMLLoader.h: interface for the CRCMLLoader class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_RCMLLOADER_H__229F8181_D92F_4313_A9C7_334E7BEE3B3B__INCLUDED_)
#define AFX_RCMLLOADER_H__229F8181_D92F_4313_A9C7_334E7BEE3B3B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// rcmlloader.cpp


#include "xmlnodefactory.h"
#include "xmlrcml.h"        // root node.

class CRCMLLoader : public _XMLDispatcher<IRCMLNode>
{
public:
	typedef _XMLDispatcher<IRCMLNode> BASECLASS;
	CRCMLLoader();
	virtual ~CRCMLLoader();

	CXMLRCML *	GetHead();

    CXMLDlg *   GetDialog(int nID);

    CXMLForms *  GetForm() { return GetHead()?GetHead()->GetForms(0):NULL; }

	void SetAutoDelete(BOOL bVal)	{ m_AutoDelete = bVal;	}

    //
    // Dispatcher cannot do this for us.
    //
    virtual LPCTSTR DoEntityRef(LPCTSTR pszEntity);
    void SetEntities(LPCTSTR * pszEntities) { m_pEntitySet=pszEntities; }

    //
    //
    //
    typedef IRCMLNode * (*CLSPFN)();

    typedef struct _XMLELEMENT_CONSTRUCTOR
    {
	    LPCTSTR	pwszElement;		// the element
	    CLSPFN	pFunc;				// the function to call.
    }XMLELEMENT_CONSTRUCTOR, * PXMLELEMENT_CONSTRUCTOR;


    static IRCMLNode * WINAPI CreateElement( PXMLELEMENT_CONSTRUCTOR dictionary, LPCTSTR pszElement );
    static IRCMLNode * WINAPI CreateRCMLElement( LPCTSTR pszElement );  // { return CreateElement( g_RCMLNS, pszElement ); }
    static IRCMLNode * WINAPI CreateWin32Element( LPCTSTR pszElement ); // { return CreateElement( g_WIN32NS, pszElement ); }

private:
	CXMLRCML	*	m_pRCML;
	BOOL		m_bPostProcessed;
	BOOL		m_AutoDelete;
    LPCTSTR  *  m_pEntitySet;

protected:

};

#endif // !defined(AFX_RCMLLOADER_H__229F8181_D92F_4313_A9C7_334E7BEE3B3B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\rcmlpub.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Tue Jul 25 12:15:53 2000
 */
/* Compiler settings for C:\NT\windows\AdvCore\RCML\RCML\rcml.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __RCMLPub_h__
#define __RCMLPub_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IRCMLResize_FWD_DEFINED__
#define __IRCMLResize_FWD_DEFINED__
typedef interface IRCMLResize IRCMLResize;
#endif 	/* __IRCMLResize_FWD_DEFINED__ */


#ifndef __IRCMLNode_FWD_DEFINED__
#define __IRCMLNode_FWD_DEFINED__
typedef interface IRCMLNode IRCMLNode;
#endif 	/* __IRCMLNode_FWD_DEFINED__ */


#ifndef __IRCMLCSS_FWD_DEFINED__
#define __IRCMLCSS_FWD_DEFINED__
typedef interface IRCMLCSS IRCMLCSS;
#endif 	/* __IRCMLCSS_FWD_DEFINED__ */


#ifndef __IRCMLHelp_FWD_DEFINED__
#define __IRCMLHelp_FWD_DEFINED__
typedef interface IRCMLHelp IRCMLHelp;
#endif 	/* __IRCMLHelp_FWD_DEFINED__ */


#ifndef __IRCMLControl_FWD_DEFINED__
#define __IRCMLControl_FWD_DEFINED__
typedef interface IRCMLControl IRCMLControl;
#endif 	/* __IRCMLControl_FWD_DEFINED__ */


#ifndef __IRCMLContainer_FWD_DEFINED__
#define __IRCMLContainer_FWD_DEFINED__
typedef interface IRCMLContainer IRCMLContainer;
#endif 	/* __IRCMLContainer_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_rcml_0000 */
/* [local] */ 





extern RPC_IF_HANDLE __MIDL_itf_rcml_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rcml_0000_v0_0_s_ifspec;

#ifndef __IRCMLResize_INTERFACE_DEFINED__
#define __IRCMLResize_INTERFACE_DEFINED__

/* interface IRCMLResize */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRCMLResize;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4CB1AC90-853C-4ce2-B013-26D0EE675F78")
    IRCMLResize : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IRCMLResizeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRCMLResize __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRCMLResize __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRCMLResize __RPC_FAR * This);
        
        END_INTERFACE
    } IRCMLResizeVtbl;

    interface IRCMLResize
    {
        CONST_VTBL struct IRCMLResizeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRCMLResize_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRCMLResize_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRCMLResize_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRCMLResize_INTERFACE_DEFINED__ */


#ifndef __IRCMLNode_INTERFACE_DEFINED__
#define __IRCMLNode_INTERFACE_DEFINED__

/* interface IRCMLNode */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRCMLNode;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F825CAF1-DE40-4FCC-B965-933076D7A1C5")
    IRCMLNode : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AttachParent( 
            /* [in] */ IRCMLNode __RPC_FAR *child) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DetachParent( 
            /* [retval][out] */ IRCMLNode __RPC_FAR *__RPC_FAR *child) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptChild( 
            IRCMLNode __RPC_FAR *child) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DoEndChild( 
            IRCMLNode __RPC_FAR *child) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ UINT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InitNode( 
            IRCMLNode __RPC_FAR *parent) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DisplayNode( 
            IRCMLNode __RPC_FAR *parent) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExitNode( 
            IRCMLNode __RPC_FAR *parent,
            /* [in] */ LONG lDialogResult) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Attr( 
            LPCWSTR index,
            /* [retval][out] */ LPWSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Attr( 
            LPCWSTR index,
            /* [in] */ LPCWSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsType( 
            LPCWSTR nodeName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE YesDefault( 
            /* [in] */ LPCWSTR propID,
            /* [in] */ DWORD dwNotPresent,
            /* [in] */ DWORD dwYes,
            /* [retval][out] */ DWORD __RPC_FAR *pdwValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE YesNoDefault( 
            /* [in] */ LPCWSTR propID,
            /* [in] */ DWORD dwNotPresent,
            /* [in] */ DWORD dwNo,
            /* [in] */ DWORD dwYes,
            /* [retval][out] */ DWORD __RPC_FAR *pdwValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ValueOf( 
            /* [in] */ LPCWSTR propID,
            /* [in] */ DWORD dwNotPresent,
            /* [retval][out] */ DWORD __RPC_FAR *pdwValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SignedValueOf( 
            /* [in] */ LPCWSTR propID,
            /* [in] */ int dwNotPresent,
            /* [retval][out] */ int __RPC_FAR *pdwValue) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_StringType( 
            /* [retval][out] */ LPWSTR __RPC_FAR *pStringType) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetChildEnum( 
            /* [retval][out] */ IEnumUnknown __RPC_FAR *__RPC_FAR *pEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetUnknownEnum( 
            /* [retval][out] */ IEnumUnknown __RPC_FAR *__RPC_FAR *pEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRCMLNodeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRCMLNode __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRCMLNode __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRCMLNode __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AttachParent )( 
            IRCMLNode __RPC_FAR * This,
            /* [in] */ IRCMLNode __RPC_FAR *child);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DetachParent )( 
            IRCMLNode __RPC_FAR * This,
            /* [retval][out] */ IRCMLNode __RPC_FAR *__RPC_FAR *child);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AcceptChild )( 
            IRCMLNode __RPC_FAR * This,
            IRCMLNode __RPC_FAR *child);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DoEndChild )( 
            IRCMLNode __RPC_FAR * This,
            IRCMLNode __RPC_FAR *child);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            IRCMLNode __RPC_FAR * This,
            /* [retval][out] */ UINT __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitNode )( 
            IRCMLNode __RPC_FAR * This,
            IRCMLNode __RPC_FAR *parent);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DisplayNode )( 
            IRCMLNode __RPC_FAR * This,
            IRCMLNode __RPC_FAR *parent);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExitNode )( 
            IRCMLNode __RPC_FAR * This,
            IRCMLNode __RPC_FAR *parent,
            /* [in] */ LONG lDialogResult);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Attr )( 
            IRCMLNode __RPC_FAR * This,
            LPCWSTR index,
            /* [retval][out] */ LPWSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Attr )( 
            IRCMLNode __RPC_FAR * This,
            LPCWSTR index,
            /* [in] */ LPCWSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsType )( 
            IRCMLNode __RPC_FAR * This,
            LPCWSTR nodeName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *YesDefault )( 
            IRCMLNode __RPC_FAR * This,
            /* [in] */ LPCWSTR propID,
            /* [in] */ DWORD dwNotPresent,
            /* [in] */ DWORD dwYes,
            /* [retval][out] */ DWORD __RPC_FAR *pdwValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *YesNoDefault )( 
            IRCMLNode __RPC_FAR * This,
            /* [in] */ LPCWSTR propID,
            /* [in] */ DWORD dwNotPresent,
            /* [in] */ DWORD dwNo,
            /* [in] */ DWORD dwYes,
            /* [retval][out] */ DWORD __RPC_FAR *pdwValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ValueOf )( 
            IRCMLNode __RPC_FAR * This,
            /* [in] */ LPCWSTR propID,
            /* [in] */ DWORD dwNotPresent,
            /* [retval][out] */ DWORD __RPC_FAR *pdwValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SignedValueOf )( 
            IRCMLNode __RPC_FAR * This,
            /* [in] */ LPCWSTR propID,
            /* [in] */ int dwNotPresent,
            /* [retval][out] */ int __RPC_FAR *pdwValue);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StringType )( 
            IRCMLNode __RPC_FAR * This,
            /* [retval][out] */ LPWSTR __RPC_FAR *pStringType);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetChildEnum )( 
            IRCMLNode __RPC_FAR * This,
            /* [retval][out] */ IEnumUnknown __RPC_FAR *__RPC_FAR *pEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUnknownEnum )( 
            IRCMLNode __RPC_FAR * This,
            /* [retval][out] */ IEnumUnknown __RPC_FAR *__RPC_FAR *pEnum);
        
        END_INTERFACE
    } IRCMLNodeVtbl;

    interface IRCMLNode
    {
        CONST_VTBL struct IRCMLNodeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRCMLNode_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRCMLNode_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRCMLNode_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRCMLNode_AttachParent(This,child)	\
    (This)->lpVtbl -> AttachParent(This,child)

#define IRCMLNode_DetachParent(This,child)	\
    (This)->lpVtbl -> DetachParent(This,child)

#define IRCMLNode_AcceptChild(This,child)	\
    (This)->lpVtbl -> AcceptChild(This,child)

#define IRCMLNode_DoEndChild(This,child)	\
    (This)->lpVtbl -> DoEndChild(This,child)

#define IRCMLNode_get_Type(This,pVal)	\
    (This)->lpVtbl -> get_Type(This,pVal)

#define IRCMLNode_InitNode(This,parent)	\
    (This)->lpVtbl -> InitNode(This,parent)

#define IRCMLNode_DisplayNode(This,parent)	\
    (This)->lpVtbl -> DisplayNode(This,parent)

#define IRCMLNode_ExitNode(This,parent,lDialogResult)	\
    (This)->lpVtbl -> ExitNode(This,parent,lDialogResult)

#define IRCMLNode_get_Attr(This,index,pVal)	\
    (This)->lpVtbl -> get_Attr(This,index,pVal)

#define IRCMLNode_put_Attr(This,index,newVal)	\
    (This)->lpVtbl -> put_Attr(This,index,newVal)

#define IRCMLNode_IsType(This,nodeName)	\
    (This)->lpVtbl -> IsType(This,nodeName)

#define IRCMLNode_YesDefault(This,propID,dwNotPresent,dwYes,pdwValue)	\
    (This)->lpVtbl -> YesDefault(This,propID,dwNotPresent,dwYes,pdwValue)

#define IRCMLNode_YesNoDefault(This,propID,dwNotPresent,dwNo,dwYes,pdwValue)	\
    (This)->lpVtbl -> YesNoDefault(This,propID,dwNotPresent,dwNo,dwYes,pdwValue)

#define IRCMLNode_ValueOf(This,propID,dwNotPresent,pdwValue)	\
    (This)->lpVtbl -> ValueOf(This,propID,dwNotPresent,pdwValue)

#define IRCMLNode_SignedValueOf(This,propID,dwNotPresent,pdwValue)	\
    (This)->lpVtbl -> SignedValueOf(This,propID,dwNotPresent,pdwValue)

#define IRCMLNode_get_StringType(This,pStringType)	\
    (This)->lpVtbl -> get_StringType(This,pStringType)

#define IRCMLNode_GetChildEnum(This,pEnum)	\
    (This)->lpVtbl -> GetChildEnum(This,pEnum)

#define IRCMLNode_GetUnknownEnum(This,pEnum)	\
    (This)->lpVtbl -> GetUnknownEnum(This,pEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRCMLNode_AttachParent_Proxy( 
    IRCMLNode __RPC_FAR * This,
    /* [in] */ IRCMLNode __RPC_FAR *child);


void __RPC_STUB IRCMLNode_AttachParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRCMLNode_DetachParent_Proxy( 
    IRCMLNode __RPC_FAR * This,
    /* [retval][out] */ IRCMLNode __RPC_FAR *__RPC_FAR *child);


void __RPC_STUB IRCMLNode_DetachParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRCMLNode_AcceptChild_Proxy( 
    IRCMLNode __RPC_FAR * This,
    IRCMLNode __RPC_FAR *child);


void __RPC_STUB IRCMLNode_AcceptChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRCMLNode_DoEndChild_Proxy( 
    IRCMLNode __RPC_FAR * This,
    IRCMLNode __RPC_FAR *child);


void __RPC_STUB IRCMLNode_DoEndChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRCMLNode_get_Type_Proxy( 
    IRCMLNode __RPC_FAR * This,
    /* [retval][out] */ UINT __RPC_FAR *pVal);


void __RPC_STUB IRCMLNode_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRCMLNode_InitNode_Proxy( 
    IRCMLNode __RPC_FAR * This,
    IRCMLNode __RPC_FAR *parent);


void __RPC_STUB IRCMLNode_InitNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRCMLNode_DisplayNode_Proxy( 
    IRCMLNode __RPC_FAR * This,
    IRCMLNode __RPC_FAR *parent);


void __RPC_STUB IRCMLNode_DisplayNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRCMLNode_ExitNode_Proxy( 
    IRCMLNode __RPC_FAR * This,
    IRCMLNode __RPC_FAR *parent,
    /* [in] */ LONG lDialogResult);


void __RPC_STUB IRCMLNode_ExitNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRCMLNode_get_Attr_Proxy( 
    IRCMLNode __RPC_FAR * This,
    LPCWSTR index,
    /* [retval][out] */ LPWSTR __RPC_FAR *pVal);


void __RPC_STUB IRCMLNode_get_Attr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IRCMLNode_put_Attr_Proxy( 
    IRCMLNode __RPC_FAR * This,
    LPCWSTR index,
    /* [in] */ LPCWSTR newVal);


void __RPC_STUB IRCMLNode_put_Attr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRCMLNode_IsType_Proxy( 
    IRCMLNode __RPC_FAR * This,
    LPCWSTR nodeName);


void __RPC_STUB IRCMLNode_IsType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRCMLNode_YesDefault_Proxy( 
    IRCMLNode __RPC_FAR * This,
    /* [in] */ LPCWSTR propID,
    /* [in] */ DWORD dwNotPresent,
    /* [in] */ DWORD dwYes,
    /* [retval][out] */ DWORD __RPC_FAR *pdwValue);


void __RPC_STUB IRCMLNode_YesDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRCMLNode_YesNoDefault_Proxy( 
    IRCMLNode __RPC_FAR * This,
    /* [in] */ LPCWSTR propID,
    /* [in] */ DWORD dwNotPresent,
    /* [in] */ DWORD dwNo,
    /* [in] */ DWORD dwYes,
    /* [retval][out] */ DWORD __RPC_FAR *pdwValue);


void __RPC_STUB IRCMLNode_YesNoDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRCMLNode_ValueOf_Proxy( 
    IRCMLNode __RPC_FAR * This,
    /* [in] */ LPCWSTR propID,
    /* [in] */ DWORD dwNotPresent,
    /* [retval][out] */ DWORD __RPC_FAR *pdwValue);


void __RPC_STUB IRCMLNode_ValueOf_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRCMLNode_SignedValueOf_Proxy( 
    IRCMLNode __RPC_FAR * This,
    /* [in] */ LPCWSTR propID,
    /* [in] */ int dwNotPresent,
    /* [retval][out] */ int __RPC_FAR *pdwValue);


void __RPC_STUB IRCMLNode_SignedValueOf_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLNode_get_StringType_Proxy( 
    IRCMLNode __RPC_FAR * This,
    /* [retval][out] */ LPWSTR __RPC_FAR *pStringType);


void __RPC_STUB IRCMLNode_get_StringType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRCMLNode_GetChildEnum_Proxy( 
    IRCMLNode __RPC_FAR * This,
    /* [retval][out] */ IEnumUnknown __RPC_FAR *__RPC_FAR *pEnum);


void __RPC_STUB IRCMLNode_GetChildEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRCMLNode_GetUnknownEnum_Proxy( 
    IRCMLNode __RPC_FAR * This,
    /* [retval][out] */ IEnumUnknown __RPC_FAR *__RPC_FAR *pEnum);


void __RPC_STUB IRCMLNode_GetUnknownEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRCMLNode_INTERFACE_DEFINED__ */


#ifndef __IRCMLCSS_INTERFACE_DEFINED__
#define __IRCMLCSS_INTERFACE_DEFINED__

/* interface IRCMLCSS */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRCMLCSS;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F5DBF38A-14DE-4f8b-8750-BABA8846E7F2")
    IRCMLCSS : public IRCMLNode
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Font( 
            /* [retval][out] */ HFONT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Brush( 
            /* [retval][out] */ HBRUSH __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Pen( 
            /* [retval][out] */ DWORD __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Color( 
            /* [retval][out] */ COLORREF __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_BkColor( 
            /* [retval][out] */ COLORREF __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DialogStyle( 
            /* [retval][out] */ IRCMLCSS __RPC_FAR *__RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_DialogStyle( 
            /* [in] */ IRCMLCSS __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Visible( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Display( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_BorderWidth( 
            /* [retval][out] */ int __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_BorderStyle( 
            /* [retval][out] */ LPWSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_GrowsWide( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_GrowsTall( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ClipHoriz( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ClipVert( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRCMLCSSVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRCMLCSS __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRCMLCSS __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRCMLCSS __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AttachParent )( 
            IRCMLCSS __RPC_FAR * This,
            /* [in] */ IRCMLNode __RPC_FAR *child);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DetachParent )( 
            IRCMLCSS __RPC_FAR * This,
            /* [retval][out] */ IRCMLNode __RPC_FAR *__RPC_FAR *child);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AcceptChild )( 
            IRCMLCSS __RPC_FAR * This,
            IRCMLNode __RPC_FAR *child);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DoEndChild )( 
            IRCMLCSS __RPC_FAR * This,
            IRCMLNode __RPC_FAR *child);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            IRCMLCSS __RPC_FAR * This,
            /* [retval][out] */ UINT __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitNode )( 
            IRCMLCSS __RPC_FAR * This,
            IRCMLNode __RPC_FAR *parent);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DisplayNode )( 
            IRCMLCSS __RPC_FAR * This,
            IRCMLNode __RPC_FAR *parent);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExitNode )( 
            IRCMLCSS __RPC_FAR * This,
            IRCMLNode __RPC_FAR *parent,
            /* [in] */ LONG lDialogResult);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Attr )( 
            IRCMLCSS __RPC_FAR * This,
            LPCWSTR index,
            /* [retval][out] */ LPWSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Attr )( 
            IRCMLCSS __RPC_FAR * This,
            LPCWSTR index,
            /* [in] */ LPCWSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsType )( 
            IRCMLCSS __RPC_FAR * This,
            LPCWSTR nodeName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *YesDefault )( 
            IRCMLCSS __RPC_FAR * This,
            /* [in] */ LPCWSTR propID,
            /* [in] */ DWORD dwNotPresent,
            /* [in] */ DWORD dwYes,
            /* [retval][out] */ DWORD __RPC_FAR *pdwValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *YesNoDefault )( 
            IRCMLCSS __RPC_FAR * This,
            /* [in] */ LPCWSTR propID,
            /* [in] */ DWORD dwNotPresent,
            /* [in] */ DWORD dwNo,
            /* [in] */ DWORD dwYes,
            /* [retval][out] */ DWORD __RPC_FAR *pdwValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ValueOf )( 
            IRCMLCSS __RPC_FAR * This,
            /* [in] */ LPCWSTR propID,
            /* [in] */ DWORD dwNotPresent,
            /* [retval][out] */ DWORD __RPC_FAR *pdwValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SignedValueOf )( 
            IRCMLCSS __RPC_FAR * This,
            /* [in] */ LPCWSTR propID,
            /* [in] */ int dwNotPresent,
            /* [retval][out] */ int __RPC_FAR *pdwValue);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StringType )( 
            IRCMLCSS __RPC_FAR * This,
            /* [retval][out] */ LPWSTR __RPC_FAR *pStringType);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetChildEnum )( 
            IRCMLCSS __RPC_FAR * This,
            /* [retval][out] */ IEnumUnknown __RPC_FAR *__RPC_FAR *pEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUnknownEnum )( 
            IRCMLCSS __RPC_FAR * This,
            /* [retval][out] */ IEnumUnknown __RPC_FAR *__RPC_FAR *pEnum);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Font )( 
            IRCMLCSS __RPC_FAR * This,
            /* [retval][out] */ HFONT __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Brush )( 
            IRCMLCSS __RPC_FAR * This,
            /* [retval][out] */ HBRUSH __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Pen )( 
            IRCMLCSS __RPC_FAR * This,
            /* [retval][out] */ DWORD __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Color )( 
            IRCMLCSS __RPC_FAR * This,
            /* [retval][out] */ COLORREF __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BkColor )( 
            IRCMLCSS __RPC_FAR * This,
            /* [retval][out] */ COLORREF __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DialogStyle )( 
            IRCMLCSS __RPC_FAR * This,
            /* [retval][out] */ IRCMLCSS __RPC_FAR *__RPC_FAR *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DialogStyle )( 
            IRCMLCSS __RPC_FAR * This,
            /* [in] */ IRCMLCSS __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Visible )( 
            IRCMLCSS __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Display )( 
            IRCMLCSS __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BorderWidth )( 
            IRCMLCSS __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BorderStyle )( 
            IRCMLCSS __RPC_FAR * This,
            /* [retval][out] */ LPWSTR __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GrowsWide )( 
            IRCMLCSS __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GrowsTall )( 
            IRCMLCSS __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ClipHoriz )( 
            IRCMLCSS __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ClipVert )( 
            IRCMLCSS __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        END_INTERFACE
    } IRCMLCSSVtbl;

    interface IRCMLCSS
    {
        CONST_VTBL struct IRCMLCSSVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRCMLCSS_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRCMLCSS_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRCMLCSS_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRCMLCSS_AttachParent(This,child)	\
    (This)->lpVtbl -> AttachParent(This,child)

#define IRCMLCSS_DetachParent(This,child)	\
    (This)->lpVtbl -> DetachParent(This,child)

#define IRCMLCSS_AcceptChild(This,child)	\
    (This)->lpVtbl -> AcceptChild(This,child)

#define IRCMLCSS_DoEndChild(This,child)	\
    (This)->lpVtbl -> DoEndChild(This,child)

#define IRCMLCSS_get_Type(This,pVal)	\
    (This)->lpVtbl -> get_Type(This,pVal)

#define IRCMLCSS_InitNode(This,parent)	\
    (This)->lpVtbl -> InitNode(This,parent)

#define IRCMLCSS_DisplayNode(This,parent)	\
    (This)->lpVtbl -> DisplayNode(This,parent)

#define IRCMLCSS_ExitNode(This,parent,lDialogResult)	\
    (This)->lpVtbl -> ExitNode(This,parent,lDialogResult)

#define IRCMLCSS_get_Attr(This,index,pVal)	\
    (This)->lpVtbl -> get_Attr(This,index,pVal)

#define IRCMLCSS_put_Attr(This,index,newVal)	\
    (This)->lpVtbl -> put_Attr(This,index,newVal)

#define IRCMLCSS_IsType(This,nodeName)	\
    (This)->lpVtbl -> IsType(This,nodeName)

#define IRCMLCSS_YesDefault(This,propID,dwNotPresent,dwYes,pdwValue)	\
    (This)->lpVtbl -> YesDefault(This,propID,dwNotPresent,dwYes,pdwValue)

#define IRCMLCSS_YesNoDefault(This,propID,dwNotPresent,dwNo,dwYes,pdwValue)	\
    (This)->lpVtbl -> YesNoDefault(This,propID,dwNotPresent,dwNo,dwYes,pdwValue)

#define IRCMLCSS_ValueOf(This,propID,dwNotPresent,pdwValue)	\
    (This)->lpVtbl -> ValueOf(This,propID,dwNotPresent,pdwValue)

#define IRCMLCSS_SignedValueOf(This,propID,dwNotPresent,pdwValue)	\
    (This)->lpVtbl -> SignedValueOf(This,propID,dwNotPresent,pdwValue)

#define IRCMLCSS_get_StringType(This,pStringType)	\
    (This)->lpVtbl -> get_StringType(This,pStringType)

#define IRCMLCSS_GetChildEnum(This,pEnum)	\
    (This)->lpVtbl -> GetChildEnum(This,pEnum)

#define IRCMLCSS_GetUnknownEnum(This,pEnum)	\
    (This)->lpVtbl -> GetUnknownEnum(This,pEnum)


#define IRCMLCSS_get_Font(This,pVal)	\
    (This)->lpVtbl -> get_Font(This,pVal)

#define IRCMLCSS_get_Brush(This,pVal)	\
    (This)->lpVtbl -> get_Brush(This,pVal)

#define IRCMLCSS_get_Pen(This,pVal)	\
    (This)->lpVtbl -> get_Pen(This,pVal)

#define IRCMLCSS_get_Color(This,pVal)	\
    (This)->lpVtbl -> get_Color(This,pVal)

#define IRCMLCSS_get_BkColor(This,pVal)	\
    (This)->lpVtbl -> get_BkColor(This,pVal)

#define IRCMLCSS_get_DialogStyle(This,pVal)	\
    (This)->lpVtbl -> get_DialogStyle(This,pVal)

#define IRCMLCSS_put_DialogStyle(This,pVal)	\
    (This)->lpVtbl -> put_DialogStyle(This,pVal)

#define IRCMLCSS_get_Visible(This,pVal)	\
    (This)->lpVtbl -> get_Visible(This,pVal)

#define IRCMLCSS_get_Display(This,pVal)	\
    (This)->lpVtbl -> get_Display(This,pVal)

#define IRCMLCSS_get_BorderWidth(This,pVal)	\
    (This)->lpVtbl -> get_BorderWidth(This,pVal)

#define IRCMLCSS_get_BorderStyle(This,pVal)	\
    (This)->lpVtbl -> get_BorderStyle(This,pVal)

#define IRCMLCSS_get_GrowsWide(This,pVal)	\
    (This)->lpVtbl -> get_GrowsWide(This,pVal)

#define IRCMLCSS_get_GrowsTall(This,pVal)	\
    (This)->lpVtbl -> get_GrowsTall(This,pVal)

#define IRCMLCSS_get_ClipHoriz(This,pVal)	\
    (This)->lpVtbl -> get_ClipHoriz(This,pVal)

#define IRCMLCSS_get_ClipVert(This,pVal)	\
    (This)->lpVtbl -> get_ClipVert(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLCSS_get_Font_Proxy( 
    IRCMLCSS __RPC_FAR * This,
    /* [retval][out] */ HFONT __RPC_FAR *pVal);


void __RPC_STUB IRCMLCSS_get_Font_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLCSS_get_Brush_Proxy( 
    IRCMLCSS __RPC_FAR * This,
    /* [retval][out] */ HBRUSH __RPC_FAR *pVal);


void __RPC_STUB IRCMLCSS_get_Brush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLCSS_get_Pen_Proxy( 
    IRCMLCSS __RPC_FAR * This,
    /* [retval][out] */ DWORD __RPC_FAR *pVal);


void __RPC_STUB IRCMLCSS_get_Pen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLCSS_get_Color_Proxy( 
    IRCMLCSS __RPC_FAR * This,
    /* [retval][out] */ COLORREF __RPC_FAR *pVal);


void __RPC_STUB IRCMLCSS_get_Color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLCSS_get_BkColor_Proxy( 
    IRCMLCSS __RPC_FAR * This,
    /* [retval][out] */ COLORREF __RPC_FAR *pVal);


void __RPC_STUB IRCMLCSS_get_BkColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLCSS_get_DialogStyle_Proxy( 
    IRCMLCSS __RPC_FAR * This,
    /* [retval][out] */ IRCMLCSS __RPC_FAR *__RPC_FAR *pVal);


void __RPC_STUB IRCMLCSS_get_DialogStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IRCMLCSS_put_DialogStyle_Proxy( 
    IRCMLCSS __RPC_FAR * This,
    /* [in] */ IRCMLCSS __RPC_FAR *pVal);


void __RPC_STUB IRCMLCSS_put_DialogStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLCSS_get_Visible_Proxy( 
    IRCMLCSS __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IRCMLCSS_get_Visible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLCSS_get_Display_Proxy( 
    IRCMLCSS __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IRCMLCSS_get_Display_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLCSS_get_BorderWidth_Proxy( 
    IRCMLCSS __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *pVal);


void __RPC_STUB IRCMLCSS_get_BorderWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLCSS_get_BorderStyle_Proxy( 
    IRCMLCSS __RPC_FAR * This,
    /* [retval][out] */ LPWSTR __RPC_FAR *pVal);


void __RPC_STUB IRCMLCSS_get_BorderStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLCSS_get_GrowsWide_Proxy( 
    IRCMLCSS __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IRCMLCSS_get_GrowsWide_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLCSS_get_GrowsTall_Proxy( 
    IRCMLCSS __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IRCMLCSS_get_GrowsTall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLCSS_get_ClipHoriz_Proxy( 
    IRCMLCSS __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IRCMLCSS_get_ClipHoriz_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLCSS_get_ClipVert_Proxy( 
    IRCMLCSS __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IRCMLCSS_get_ClipVert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRCMLCSS_INTERFACE_DEFINED__ */


#ifndef __IRCMLHelp_INTERFACE_DEFINED__
#define __IRCMLHelp_INTERFACE_DEFINED__

/* interface IRCMLHelp */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRCMLHelp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B31FDC6A-9FB2-404e-8762-CC267A95A424")
    IRCMLHelp : public IRCMLNode
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_TooltipText( 
            /* [retval][out] */ LPWSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_BalloonText( 
            /* [retval][out] */ LPWSTR __RPC_FAR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRCMLHelpVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRCMLHelp __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRCMLHelp __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRCMLHelp __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AttachParent )( 
            IRCMLHelp __RPC_FAR * This,
            /* [in] */ IRCMLNode __RPC_FAR *child);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DetachParent )( 
            IRCMLHelp __RPC_FAR * This,
            /* [retval][out] */ IRCMLNode __RPC_FAR *__RPC_FAR *child);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AcceptChild )( 
            IRCMLHelp __RPC_FAR * This,
            IRCMLNode __RPC_FAR *child);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DoEndChild )( 
            IRCMLHelp __RPC_FAR * This,
            IRCMLNode __RPC_FAR *child);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            IRCMLHelp __RPC_FAR * This,
            /* [retval][out] */ UINT __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitNode )( 
            IRCMLHelp __RPC_FAR * This,
            IRCMLNode __RPC_FAR *parent);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DisplayNode )( 
            IRCMLHelp __RPC_FAR * This,
            IRCMLNode __RPC_FAR *parent);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExitNode )( 
            IRCMLHelp __RPC_FAR * This,
            IRCMLNode __RPC_FAR *parent,
            /* [in] */ LONG lDialogResult);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Attr )( 
            IRCMLHelp __RPC_FAR * This,
            LPCWSTR index,
            /* [retval][out] */ LPWSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Attr )( 
            IRCMLHelp __RPC_FAR * This,
            LPCWSTR index,
            /* [in] */ LPCWSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsType )( 
            IRCMLHelp __RPC_FAR * This,
            LPCWSTR nodeName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *YesDefault )( 
            IRCMLHelp __RPC_FAR * This,
            /* [in] */ LPCWSTR propID,
            /* [in] */ DWORD dwNotPresent,
            /* [in] */ DWORD dwYes,
            /* [retval][out] */ DWORD __RPC_FAR *pdwValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *YesNoDefault )( 
            IRCMLHelp __RPC_FAR * This,
            /* [in] */ LPCWSTR propID,
            /* [in] */ DWORD dwNotPresent,
            /* [in] */ DWORD dwNo,
            /* [in] */ DWORD dwYes,
            /* [retval][out] */ DWORD __RPC_FAR *pdwValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ValueOf )( 
            IRCMLHelp __RPC_FAR * This,
            /* [in] */ LPCWSTR propID,
            /* [in] */ DWORD dwNotPresent,
            /* [retval][out] */ DWORD __RPC_FAR *pdwValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SignedValueOf )( 
            IRCMLHelp __RPC_FAR * This,
            /* [in] */ LPCWSTR propID,
            /* [in] */ int dwNotPresent,
            /* [retval][out] */ int __RPC_FAR *pdwValue);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StringType )( 
            IRCMLHelp __RPC_FAR * This,
            /* [retval][out] */ LPWSTR __RPC_FAR *pStringType);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetChildEnum )( 
            IRCMLHelp __RPC_FAR * This,
            /* [retval][out] */ IEnumUnknown __RPC_FAR *__RPC_FAR *pEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUnknownEnum )( 
            IRCMLHelp __RPC_FAR * This,
            /* [retval][out] */ IEnumUnknown __RPC_FAR *__RPC_FAR *pEnum);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TooltipText )( 
            IRCMLHelp __RPC_FAR * This,
            /* [retval][out] */ LPWSTR __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BalloonText )( 
            IRCMLHelp __RPC_FAR * This,
            /* [retval][out] */ LPWSTR __RPC_FAR *pVal);
        
        END_INTERFACE
    } IRCMLHelpVtbl;

    interface IRCMLHelp
    {
        CONST_VTBL struct IRCMLHelpVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRCMLHelp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRCMLHelp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRCMLHelp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRCMLHelp_AttachParent(This,child)	\
    (This)->lpVtbl -> AttachParent(This,child)

#define IRCMLHelp_DetachParent(This,child)	\
    (This)->lpVtbl -> DetachParent(This,child)

#define IRCMLHelp_AcceptChild(This,child)	\
    (This)->lpVtbl -> AcceptChild(This,child)

#define IRCMLHelp_DoEndChild(This,child)	\
    (This)->lpVtbl -> DoEndChild(This,child)

#define IRCMLHelp_get_Type(This,pVal)	\
    (This)->lpVtbl -> get_Type(This,pVal)

#define IRCMLHelp_InitNode(This,parent)	\
    (This)->lpVtbl -> InitNode(This,parent)

#define IRCMLHelp_DisplayNode(This,parent)	\
    (This)->lpVtbl -> DisplayNode(This,parent)

#define IRCMLHelp_ExitNode(This,parent,lDialogResult)	\
    (This)->lpVtbl -> ExitNode(This,parent,lDialogResult)

#define IRCMLHelp_get_Attr(This,index,pVal)	\
    (This)->lpVtbl -> get_Attr(This,index,pVal)

#define IRCMLHelp_put_Attr(This,index,newVal)	\
    (This)->lpVtbl -> put_Attr(This,index,newVal)

#define IRCMLHelp_IsType(This,nodeName)	\
    (This)->lpVtbl -> IsType(This,nodeName)

#define IRCMLHelp_YesDefault(This,propID,dwNotPresent,dwYes,pdwValue)	\
    (This)->lpVtbl -> YesDefault(This,propID,dwNotPresent,dwYes,pdwValue)

#define IRCMLHelp_YesNoDefault(This,propID,dwNotPresent,dwNo,dwYes,pdwValue)	\
    (This)->lpVtbl -> YesNoDefault(This,propID,dwNotPresent,dwNo,dwYes,pdwValue)

#define IRCMLHelp_ValueOf(This,propID,dwNotPresent,pdwValue)	\
    (This)->lpVtbl -> ValueOf(This,propID,dwNotPresent,pdwValue)

#define IRCMLHelp_SignedValueOf(This,propID,dwNotPresent,pdwValue)	\
    (This)->lpVtbl -> SignedValueOf(This,propID,dwNotPresent,pdwValue)

#define IRCMLHelp_get_StringType(This,pStringType)	\
    (This)->lpVtbl -> get_StringType(This,pStringType)

#define IRCMLHelp_GetChildEnum(This,pEnum)	\
    (This)->lpVtbl -> GetChildEnum(This,pEnum)

#define IRCMLHelp_GetUnknownEnum(This,pEnum)	\
    (This)->lpVtbl -> GetUnknownEnum(This,pEnum)


#define IRCMLHelp_get_TooltipText(This,pVal)	\
    (This)->lpVtbl -> get_TooltipText(This,pVal)

#define IRCMLHelp_get_BalloonText(This,pVal)	\
    (This)->lpVtbl -> get_BalloonText(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLHelp_get_TooltipText_Proxy( 
    IRCMLHelp __RPC_FAR * This,
    /* [retval][out] */ LPWSTR __RPC_FAR *pVal);


void __RPC_STUB IRCMLHelp_get_TooltipText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLHelp_get_BalloonText_Proxy( 
    IRCMLHelp __RPC_FAR * This,
    /* [retval][out] */ LPWSTR __RPC_FAR *pVal);


void __RPC_STUB IRCMLHelp_get_BalloonText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRCMLHelp_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_rcml_0212 */
/* [local] */ 

typedef 
enum RELATIVETYPE_ENUM
    {	RELATIVE_TO_NOTHING	= 0,
	RELATIVE_TO_CONTROL	= RELATIVE_TO_NOTHING + 1,
	RELATIVE_TO_PREVIOUS	= RELATIVE_TO_CONTROL + 1,
	RELATIVE_TO_PAGE	= RELATIVE_TO_PREVIOUS + 1
    }	RELATIVETYPE_ENUM;



extern RPC_IF_HANDLE __MIDL_itf_rcml_0212_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rcml_0212_v0_0_s_ifspec;

#ifndef __IRCMLControl_INTERFACE_DEFINED__
#define __IRCMLControl_INTERFACE_DEFINED__

/* interface IRCMLControl */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRCMLControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B943DDF7-21A7-42cb-B696-345AEBC10910")
    IRCMLControl : public IRCMLNode
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Class( 
            /* [retval][out] */ LPWSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Style( 
            /* [retval][out] */ DWORD __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_StyleEx( 
            /* [retval][out] */ DWORD __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Text( 
            /* [retval][out] */ LPWSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnInit( 
            HWND h) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Window( 
            /* [retval][out] */ HWND __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Window( 
            /* [in] */ HWND pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnDestroy( 
            HWND h,
            WORD wLastCommand) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ID( 
            /* [retval][out] */ LPWSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Width( 
            /* [retval][out] */ LONG __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Height( 
            /* [retval][out] */ LONG __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Width( 
            /* [in] */ LONG Val) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Height( 
            /* [in] */ LONG Val) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_X( 
            /* [retval][out] */ LONG __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Y( 
            /* [retval][out] */ LONG __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_X( 
            /* [in] */ LONG Val) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Y( 
            /* [in] */ LONG Val) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_RelativeTo( 
            /* [retval][out] */ IRCMLControl __RPC_FAR *__RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_RelativeTo( 
            /* [in] */ IRCMLControl __RPC_FAR *newVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Location( 
            /* [retval][out] */ RECT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_RelativeLocn( 
            RECT rect,
            /* [retval][out] */ RECT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_RelativeID( 
            /* [retval][out] */ LPWSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_RelativeType( 
            /* [retval][out] */ RELATIVETYPE_ENUM __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Clipped( 
            /* [retval][out] */ SIZE __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_GrowsWide( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_GrowsTall( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Container( 
            /* [retval][out] */ IRCMLContainer __RPC_FAR *__RPC_FAR *pContainer) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Container( 
            /* [in] */ IRCMLContainer __RPC_FAR *pContainer) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CSS( 
            /* [retval][out] */ IRCMLCSS __RPC_FAR *__RPC_FAR *pCSS) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_CSS( 
            /* [in] */ IRCMLCSS __RPC_FAR *pCSS) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Help( 
            /* [retval][out] */ IRCMLHelp __RPC_FAR *__RPC_FAR *pHelp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRCMLControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRCMLControl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRCMLControl __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRCMLControl __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AttachParent )( 
            IRCMLControl __RPC_FAR * This,
            /* [in] */ IRCMLNode __RPC_FAR *child);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DetachParent )( 
            IRCMLControl __RPC_FAR * This,
            /* [retval][out] */ IRCMLNode __RPC_FAR *__RPC_FAR *child);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AcceptChild )( 
            IRCMLControl __RPC_FAR * This,
            IRCMLNode __RPC_FAR *child);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DoEndChild )( 
            IRCMLControl __RPC_FAR * This,
            IRCMLNode __RPC_FAR *child);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            IRCMLControl __RPC_FAR * This,
            /* [retval][out] */ UINT __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitNode )( 
            IRCMLControl __RPC_FAR * This,
            IRCMLNode __RPC_FAR *parent);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DisplayNode )( 
            IRCMLControl __RPC_FAR * This,
            IRCMLNode __RPC_FAR *parent);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExitNode )( 
            IRCMLControl __RPC_FAR * This,
            IRCMLNode __RPC_FAR *parent,
            /* [in] */ LONG lDialogResult);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Attr )( 
            IRCMLControl __RPC_FAR * This,
            LPCWSTR index,
            /* [retval][out] */ LPWSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Attr )( 
            IRCMLControl __RPC_FAR * This,
            LPCWSTR index,
            /* [in] */ LPCWSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsType )( 
            IRCMLControl __RPC_FAR * This,
            LPCWSTR nodeName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *YesDefault )( 
            IRCMLControl __RPC_FAR * This,
            /* [in] */ LPCWSTR propID,
            /* [in] */ DWORD dwNotPresent,
            /* [in] */ DWORD dwYes,
            /* [retval][out] */ DWORD __RPC_FAR *pdwValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *YesNoDefault )( 
            IRCMLControl __RPC_FAR * This,
            /* [in] */ LPCWSTR propID,
            /* [in] */ DWORD dwNotPresent,
            /* [in] */ DWORD dwNo,
            /* [in] */ DWORD dwYes,
            /* [retval][out] */ DWORD __RPC_FAR *pdwValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ValueOf )( 
            IRCMLControl __RPC_FAR * This,
            /* [in] */ LPCWSTR propID,
            /* [in] */ DWORD dwNotPresent,
            /* [retval][out] */ DWORD __RPC_FAR *pdwValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SignedValueOf )( 
            IRCMLControl __RPC_FAR * This,
            /* [in] */ LPCWSTR propID,
            /* [in] */ int dwNotPresent,
            /* [retval][out] */ int __RPC_FAR *pdwValue);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StringType )( 
            IRCMLControl __RPC_FAR * This,
            /* [retval][out] */ LPWSTR __RPC_FAR *pStringType);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetChildEnum )( 
            IRCMLControl __RPC_FAR * This,
            /* [retval][out] */ IEnumUnknown __RPC_FAR *__RPC_FAR *pEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUnknownEnum )( 
            IRCMLControl __RPC_FAR * This,
            /* [retval][out] */ IEnumUnknown __RPC_FAR *__RPC_FAR *pEnum);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IRCMLControl __RPC_FAR * This,
            /* [retval][out] */ LPWSTR __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Style )( 
            IRCMLControl __RPC_FAR * This,
            /* [retval][out] */ DWORD __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StyleEx )( 
            IRCMLControl __RPC_FAR * This,
            /* [retval][out] */ DWORD __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Text )( 
            IRCMLControl __RPC_FAR * This,
            /* [retval][out] */ LPWSTR __RPC_FAR *pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnInit )( 
            IRCMLControl __RPC_FAR * This,
            HWND h);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Window )( 
            IRCMLControl __RPC_FAR * This,
            /* [retval][out] */ HWND __RPC_FAR *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Window )( 
            IRCMLControl __RPC_FAR * This,
            /* [in] */ HWND pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnDestroy )( 
            IRCMLControl __RPC_FAR * This,
            HWND h,
            WORD wLastCommand);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ID )( 
            IRCMLControl __RPC_FAR * This,
            /* [retval][out] */ LPWSTR __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Width )( 
            IRCMLControl __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Height )( 
            IRCMLControl __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Width )( 
            IRCMLControl __RPC_FAR * This,
            /* [in] */ LONG Val);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Height )( 
            IRCMLControl __RPC_FAR * This,
            /* [in] */ LONG Val);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_X )( 
            IRCMLControl __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Y )( 
            IRCMLControl __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_X )( 
            IRCMLControl __RPC_FAR * This,
            /* [in] */ LONG Val);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Y )( 
            IRCMLControl __RPC_FAR * This,
            /* [in] */ LONG Val);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RelativeTo )( 
            IRCMLControl __RPC_FAR * This,
            /* [retval][out] */ IRCMLControl __RPC_FAR *__RPC_FAR *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_RelativeTo )( 
            IRCMLControl __RPC_FAR * This,
            /* [in] */ IRCMLControl __RPC_FAR *newVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Location )( 
            IRCMLControl __RPC_FAR * This,
            /* [retval][out] */ RECT __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RelativeLocn )( 
            IRCMLControl __RPC_FAR * This,
            RECT rect,
            /* [retval][out] */ RECT __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RelativeID )( 
            IRCMLControl __RPC_FAR * This,
            /* [retval][out] */ LPWSTR __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RelativeType )( 
            IRCMLControl __RPC_FAR * This,
            /* [retval][out] */ RELATIVETYPE_ENUM __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Clipped )( 
            IRCMLControl __RPC_FAR * This,
            /* [retval][out] */ SIZE __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GrowsWide )( 
            IRCMLControl __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GrowsTall )( 
            IRCMLControl __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Container )( 
            IRCMLControl __RPC_FAR * This,
            /* [retval][out] */ IRCMLContainer __RPC_FAR *__RPC_FAR *pContainer);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Container )( 
            IRCMLControl __RPC_FAR * This,
            /* [in] */ IRCMLContainer __RPC_FAR *pContainer);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CSS )( 
            IRCMLControl __RPC_FAR * This,
            /* [retval][out] */ IRCMLCSS __RPC_FAR *__RPC_FAR *pCSS);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CSS )( 
            IRCMLControl __RPC_FAR * This,
            /* [in] */ IRCMLCSS __RPC_FAR *pCSS);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Help )( 
            IRCMLControl __RPC_FAR * This,
            /* [retval][out] */ IRCMLHelp __RPC_FAR *__RPC_FAR *pHelp);
        
        END_INTERFACE
    } IRCMLControlVtbl;

    interface IRCMLControl
    {
        CONST_VTBL struct IRCMLControlVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRCMLControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRCMLControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRCMLControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRCMLControl_AttachParent(This,child)	\
    (This)->lpVtbl -> AttachParent(This,child)

#define IRCMLControl_DetachParent(This,child)	\
    (This)->lpVtbl -> DetachParent(This,child)

#define IRCMLControl_AcceptChild(This,child)	\
    (This)->lpVtbl -> AcceptChild(This,child)

#define IRCMLControl_DoEndChild(This,child)	\
    (This)->lpVtbl -> DoEndChild(This,child)

#define IRCMLControl_get_Type(This,pVal)	\
    (This)->lpVtbl -> get_Type(This,pVal)

#define IRCMLControl_InitNode(This,parent)	\
    (This)->lpVtbl -> InitNode(This,parent)

#define IRCMLControl_DisplayNode(This,parent)	\
    (This)->lpVtbl -> DisplayNode(This,parent)

#define IRCMLControl_ExitNode(This,parent,lDialogResult)	\
    (This)->lpVtbl -> ExitNode(This,parent,lDialogResult)

#define IRCMLControl_get_Attr(This,index,pVal)	\
    (This)->lpVtbl -> get_Attr(This,index,pVal)

#define IRCMLControl_put_Attr(This,index,newVal)	\
    (This)->lpVtbl -> put_Attr(This,index,newVal)

#define IRCMLControl_IsType(This,nodeName)	\
    (This)->lpVtbl -> IsType(This,nodeName)

#define IRCMLControl_YesDefault(This,propID,dwNotPresent,dwYes,pdwValue)	\
    (This)->lpVtbl -> YesDefault(This,propID,dwNotPresent,dwYes,pdwValue)

#define IRCMLControl_YesNoDefault(This,propID,dwNotPresent,dwNo,dwYes,pdwValue)	\
    (This)->lpVtbl -> YesNoDefault(This,propID,dwNotPresent,dwNo,dwYes,pdwValue)

#define IRCMLControl_ValueOf(This,propID,dwNotPresent,pdwValue)	\
    (This)->lpVtbl -> ValueOf(This,propID,dwNotPresent,pdwValue)

#define IRCMLControl_SignedValueOf(This,propID,dwNotPresent,pdwValue)	\
    (This)->lpVtbl -> SignedValueOf(This,propID,dwNotPresent,pdwValue)

#define IRCMLControl_get_StringType(This,pStringType)	\
    (This)->lpVtbl -> get_StringType(This,pStringType)

#define IRCMLControl_GetChildEnum(This,pEnum)	\
    (This)->lpVtbl -> GetChildEnum(This,pEnum)

#define IRCMLControl_GetUnknownEnum(This,pEnum)	\
    (This)->lpVtbl -> GetUnknownEnum(This,pEnum)


#define IRCMLControl_get_Class(This,pVal)	\
    (This)->lpVtbl -> get_Class(This,pVal)

#define IRCMLControl_get_Style(This,pVal)	\
    (This)->lpVtbl -> get_Style(This,pVal)

#define IRCMLControl_get_StyleEx(This,pVal)	\
    (This)->lpVtbl -> get_StyleEx(This,pVal)

#define IRCMLControl_get_Text(This,pVal)	\
    (This)->lpVtbl -> get_Text(This,pVal)

#define IRCMLControl_OnInit(This,h)	\
    (This)->lpVtbl -> OnInit(This,h)

#define IRCMLControl_get_Window(This,pVal)	\
    (This)->lpVtbl -> get_Window(This,pVal)

#define IRCMLControl_put_Window(This,pVal)	\
    (This)->lpVtbl -> put_Window(This,pVal)

#define IRCMLControl_OnDestroy(This,h,wLastCommand)	\
    (This)->lpVtbl -> OnDestroy(This,h,wLastCommand)

#define IRCMLControl_get_ID(This,pVal)	\
    (This)->lpVtbl -> get_ID(This,pVal)

#define IRCMLControl_get_Width(This,pVal)	\
    (This)->lpVtbl -> get_Width(This,pVal)

#define IRCMLControl_get_Height(This,pVal)	\
    (This)->lpVtbl -> get_Height(This,pVal)

#define IRCMLControl_put_Width(This,Val)	\
    (This)->lpVtbl -> put_Width(This,Val)

#define IRCMLControl_put_Height(This,Val)	\
    (This)->lpVtbl -> put_Height(This,Val)

#define IRCMLControl_get_X(This,pVal)	\
    (This)->lpVtbl -> get_X(This,pVal)

#define IRCMLControl_get_Y(This,pVal)	\
    (This)->lpVtbl -> get_Y(This,pVal)

#define IRCMLControl_put_X(This,Val)	\
    (This)->lpVtbl -> put_X(This,Val)

#define IRCMLControl_put_Y(This,Val)	\
    (This)->lpVtbl -> put_Y(This,Val)

#define IRCMLControl_get_RelativeTo(This,pVal)	\
    (This)->lpVtbl -> get_RelativeTo(This,pVal)

#define IRCMLControl_put_RelativeTo(This,newVal)	\
    (This)->lpVtbl -> put_RelativeTo(This,newVal)

#define IRCMLControl_get_Location(This,pVal)	\
    (This)->lpVtbl -> get_Location(This,pVal)

#define IRCMLControl_get_RelativeLocn(This,rect,pVal)	\
    (This)->lpVtbl -> get_RelativeLocn(This,rect,pVal)

#define IRCMLControl_get_RelativeID(This,pVal)	\
    (This)->lpVtbl -> get_RelativeID(This,pVal)

#define IRCMLControl_get_RelativeType(This,pVal)	\
    (This)->lpVtbl -> get_RelativeType(This,pVal)

#define IRCMLControl_get_Clipped(This,pVal)	\
    (This)->lpVtbl -> get_Clipped(This,pVal)

#define IRCMLControl_get_GrowsWide(This,pVal)	\
    (This)->lpVtbl -> get_GrowsWide(This,pVal)

#define IRCMLControl_get_GrowsTall(This,pVal)	\
    (This)->lpVtbl -> get_GrowsTall(This,pVal)

#define IRCMLControl_get_Container(This,pContainer)	\
    (This)->lpVtbl -> get_Container(This,pContainer)

#define IRCMLControl_put_Container(This,pContainer)	\
    (This)->lpVtbl -> put_Container(This,pContainer)

#define IRCMLControl_get_CSS(This,pCSS)	\
    (This)->lpVtbl -> get_CSS(This,pCSS)

#define IRCMLControl_put_CSS(This,pCSS)	\
    (This)->lpVtbl -> put_CSS(This,pCSS)

#define IRCMLControl_get_Help(This,pHelp)	\
    (This)->lpVtbl -> get_Help(This,pHelp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_Class_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ LPWSTR __RPC_FAR *pVal);


void __RPC_STUB IRCMLControl_get_Class_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_Style_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ DWORD __RPC_FAR *pVal);


void __RPC_STUB IRCMLControl_get_Style_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_StyleEx_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ DWORD __RPC_FAR *pVal);


void __RPC_STUB IRCMLControl_get_StyleEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_Text_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ LPWSTR __RPC_FAR *pVal);


void __RPC_STUB IRCMLControl_get_Text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRCMLControl_OnInit_Proxy( 
    IRCMLControl __RPC_FAR * This,
    HWND h);


void __RPC_STUB IRCMLControl_OnInit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_Window_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ HWND __RPC_FAR *pVal);


void __RPC_STUB IRCMLControl_get_Window_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IRCMLControl_put_Window_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [in] */ HWND pVal);


void __RPC_STUB IRCMLControl_put_Window_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRCMLControl_OnDestroy_Proxy( 
    IRCMLControl __RPC_FAR * This,
    HWND h,
    WORD wLastCommand);


void __RPC_STUB IRCMLControl_OnDestroy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_ID_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ LPWSTR __RPC_FAR *pVal);


void __RPC_STUB IRCMLControl_get_ID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_Width_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *pVal);


void __RPC_STUB IRCMLControl_get_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_Height_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *pVal);


void __RPC_STUB IRCMLControl_get_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IRCMLControl_put_Width_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [in] */ LONG Val);


void __RPC_STUB IRCMLControl_put_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IRCMLControl_put_Height_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [in] */ LONG Val);


void __RPC_STUB IRCMLControl_put_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_X_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *pVal);


void __RPC_STUB IRCMLControl_get_X_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_Y_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *pVal);


void __RPC_STUB IRCMLControl_get_Y_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IRCMLControl_put_X_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [in] */ LONG Val);


void __RPC_STUB IRCMLControl_put_X_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IRCMLControl_put_Y_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [in] */ LONG Val);


void __RPC_STUB IRCMLControl_put_Y_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_RelativeTo_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ IRCMLControl __RPC_FAR *__RPC_FAR *pVal);


void __RPC_STUB IRCMLControl_get_RelativeTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IRCMLControl_put_RelativeTo_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [in] */ IRCMLControl __RPC_FAR *newVal);


void __RPC_STUB IRCMLControl_put_RelativeTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_Location_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ RECT __RPC_FAR *pVal);


void __RPC_STUB IRCMLControl_get_Location_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_RelativeLocn_Proxy( 
    IRCMLControl __RPC_FAR * This,
    RECT rect,
    /* [retval][out] */ RECT __RPC_FAR *pVal);


void __RPC_STUB IRCMLControl_get_RelativeLocn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_RelativeID_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ LPWSTR __RPC_FAR *pVal);


void __RPC_STUB IRCMLControl_get_RelativeID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_RelativeType_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ RELATIVETYPE_ENUM __RPC_FAR *pVal);


void __RPC_STUB IRCMLControl_get_RelativeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_Clipped_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ SIZE __RPC_FAR *pVal);


void __RPC_STUB IRCMLControl_get_Clipped_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_GrowsWide_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IRCMLControl_get_GrowsWide_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_GrowsTall_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IRCMLControl_get_GrowsTall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_Container_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ IRCMLContainer __RPC_FAR *__RPC_FAR *pContainer);


void __RPC_STUB IRCMLControl_get_Container_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IRCMLControl_put_Container_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [in] */ IRCMLContainer __RPC_FAR *pContainer);


void __RPC_STUB IRCMLControl_put_Container_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_CSS_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ IRCMLCSS __RPC_FAR *__RPC_FAR *pCSS);


void __RPC_STUB IRCMLControl_get_CSS_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IRCMLControl_put_CSS_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [in] */ IRCMLCSS __RPC_FAR *pCSS);


void __RPC_STUB IRCMLControl_put_CSS_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_Help_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ IRCMLHelp __RPC_FAR *__RPC_FAR *pHelp);


void __RPC_STUB IRCMLControl_get_Help_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRCMLControl_INTERFACE_DEFINED__ */


#ifndef __IRCMLContainer_INTERFACE_DEFINED__
#define __IRCMLContainer_INTERFACE_DEFINED__

/* interface IRCMLContainer */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRCMLContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E0868F2A-BC98-4b46-9261-31A168904804")
    IRCMLContainer : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPixelLocation( 
            /* [in] */ IRCMLControl __RPC_FAR *__MIDL_0015,
            /* [retval][out] */ RECT __RPC_FAR *pRect) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRCMLContainerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRCMLContainer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRCMLContainer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRCMLContainer __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPixelLocation )( 
            IRCMLContainer __RPC_FAR * This,
            /* [in] */ IRCMLControl __RPC_FAR *__MIDL_0015,
            /* [retval][out] */ RECT __RPC_FAR *pRect);
        
        END_INTERFACE
    } IRCMLContainerVtbl;

    interface IRCMLContainer
    {
        CONST_VTBL struct IRCMLContainerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRCMLContainer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRCMLContainer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRCMLContainer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRCMLContainer_GetPixelLocation(This,__MIDL_0015,pRect)	\
    (This)->lpVtbl -> GetPixelLocation(This,__MIDL_0015,pRect)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRCMLContainer_GetPixelLocation_Proxy( 
    IRCMLContainer __RPC_FAR * This,
    /* [in] */ IRCMLControl __RPC_FAR *__MIDL_0015,
    /* [retval][out] */ RECT __RPC_FAR *pRect);


void __RPC_STUB IRCMLContainer_GetPixelLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRCMLContainer_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HBRUSH_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HBRUSH __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HBRUSH_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HBRUSH __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HBRUSH_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HBRUSH __RPC_FAR * ); 
void                      __RPC_USER  HBRUSH_UserFree(     unsigned long __RPC_FAR *, HBRUSH __RPC_FAR * ); 

unsigned long             __RPC_USER  HFONT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HFONT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HFONT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HFONT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HFONT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HFONT __RPC_FAR * ); 
void                      __RPC_USER  HFONT_UserFree(     unsigned long __RPC_FAR *, HFONT __RPC_FAR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long __RPC_FAR *, HWND __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\renderdlg.h ===
//
// The implementations of the nodes that make up the tree
//
//////////////////////////////////////////////////////////////////////

#if !defined(__renderDLG_H)
#define __renderDLG_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "xmldlg.h"

class CRenderXMLDialog
{
public:
	CRenderXMLDialog(HINSTANCE hInst, HWND hParent, DLGPROC dlgProc, LPARAM dwInitParam=NULL )
		: m_hInst(hInst), m_hParent(hParent), m_dlgProc(dlgProc), m_dwInitParam(dwInitParam) {};
	virtual ~CRenderXMLDialog();

	BOOL    CreateDlgTemplate( CXMLDlg* pDialog, DLGTEMPLATE** pDt );	// pDt is an out param
	int     Render( CXMLDlg * pDialog );
    HWND    CreateDlg( CXMLDlg * pDialog );

protected:
	HINSTANCE	m_hInst;
	HWND		m_hParent;
	DLGPROC		m_dlgProc;
	LPARAM		m_dwInitParam;
};


#endif // !defined(AFX_XMLDLG_H__CAF7DEF3_DD82_11D2_8BCE_00C04FB177B1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\rcml_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0164 */
/* at Tue Jul 25 12:15:53 2000
 */
/* Compiler settings for C:\NT\windows\AdvCore\RCML\RCML\rcml.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IRCMLResize = {0x4CB1AC90,0x853C,0x4ce2,{0xB0,0x13,0x26,0xD0,0xEE,0x67,0x5F,0x78}};


const IID IID_IRCMLNode = {0xF825CAF1,0xDE40,0x4FCC,{0xB9,0x65,0x93,0x30,0x76,0xD7,0xA1,0xC5}};


const IID IID_IRCMLCSS = {0xF5DBF38A,0x14DE,0x4f8b,{0x87,0x50,0xBA,0xBA,0x88,0x46,0xE7,0xF2}};


const IID IID_IRCMLHelp = {0xB31FDC6A,0x9FB2,0x404e,{0x87,0x62,0xCC,0x26,0x7A,0x95,0xA4,0x24}};


const IID IID_IRCMLControl = {0xB943DDF7,0x21A7,0x42cb,{0xB6,0x96,0x34,0x5A,0xEB,0xC1,0x09,0x10}};


const IID IID_IRCMLContainer = {0xE0868F2A,0xBC98,0x4b46,{0x92,0x61,0x31,0xA1,0x68,0x90,0x48,0x04}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\renderdlg.cpp ===
// XMLDlg.cpp: implementation of the CXMLDlg class.
//
// test files rc2xml.exe-103.xml
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "renderDlg.h"          // this walks the tree
#include "dialogRenderer.h"     // this builds the template
#include "win32dlg.h"           // this is the runtime for the dialog
#include "utils.h"

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
//
// RenderXMLDialog
//
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

CRenderXMLDialog::~CRenderXMLDialog()
{
}

//////////////////////////////////////////////////////////////////////////////
//
// Takes the tree of nodes and walks the visual components to build
// a dialog indirect. Allocates the space into the ppDlgTemplate
//
//////////////////////////////////////////////////////////////////////////////
BOOL CRenderXMLDialog::CreateDlgTemplate( CXMLDlg* pDialog, DLGTEMPLATE** ppDlgTemplate)
{
	IRCMLControlList & controls=pDialog->GetChildren();
	int iCount=controls.GetCount();

	CDialogRenderer dlg;

	BOOL	bPixelPerfect=FALSE;
	DWORD	dwChildStyleBits=0;
	DWORD	dwDialogStyleBits=0;

	CXMLWin32Layout * pLayout=pDialog->GetLayout();
	CXMLGrid * pGrid=NULL;
	if(pLayout)
	{
		pGrid=pLayout->GetGrid();
		bPixelPerfect=pLayout->GetUnits() == CXMLWin32Layout::UNIT_PIXEL;
		if( pGrid && pGrid->GetDisplay() )
			dwDialogStyleBits |= WS_CLIPCHILDREN; //  | WS_CLIPSIBLINGS ;
	}

	DWORD XScale=1;
	DWORD YScale=1;

	if(pGrid && pGrid->GetMap())
	{
		XScale=pGrid->GetX();
		YScale=pGrid->GetY();
	}


    //
	// pixel perfect layout font is Verdana 5 point.
    // Dialog is still in dialog units not in pixels.
    // this is the ONLY place in the system, where we HAVE to get DLU's??
    //

    SIZE dlgSize;
    // dlgSize.cx=pDialog->GetWidth();
    // dlgSize.cy=pDialog->GetHeight();
    // dlgSize=pDialog->GetPixelSize(dlgSize);

    pDialog->get_Width( &dlgSize.cx );
    pDialog->get_Height( &dlgSize.cy );

    LPWSTR pszTitle;
    LPWSTR pszClass;
    DWORD dwStyle;
    DWORD dwStyleEx;
    LPWSTR pszID;

    pDialog->get_Text( & pszTitle );
    pDialog->get_Class( &pszClass );
    pDialog->get_Style( & dwStyle );
    pDialog->get_StyleEx( &dwStyleEx );
    pDialog->get_ID( &pszID );
    
	dlg.BuildDialogTemplate(pszTitle, 
							(WORD)(dlgSize.cx*XScale), 
							(WORD)(dlgSize.cy*YScale), 
							dwStyle | dwDialogStyleBits, 
							dwStyleEx, 
							bPixelPerfect?TEXT("Verdana"):pDialog->GetFont(),
							bPixelPerfect?5:pDialog->GetFontSize(),
                            MAKEINTRESOURCE(pDialog->GetMenuID()),
                            pszClass );

	EVENTLOG( EVENTLOG_INFORMATION_TYPE, LOGCAT_CONSTRUCT, 0,
        TEXT("CRenderXMLDialog"), TEXT("Creating dialog template: %s %d by %d. %03d controls"),
		pszTitle, dlgSize.cx*XScale, dlgSize.cy*YScale, iCount );

	IRCMLControl * pControl;
	RECT location = {0,0,0,0};	/// maybe setup by the dialog?
	for(int i=0;i<iCount;i++)
	{
		pControl=controls.GetPointer(i);

		pControl->get_Location( &location );

        pControl->get_Text( & pszTitle );
        pControl->get_Class( &pszClass );
        pControl->get_Style( & dwStyle );
        pControl->get_StyleEx( &dwStyleEx );
        pControl->get_ID( &pszID );

        DWORD dwID = StringToInt( pszID );

		dlg.AddDialogControl( dwStyle | dwChildStyleBits , 
			(WORD)location.left, (WORD)location.top,
			(WORD)(location.right - location.left), (WORD)(location.bottom - location.top),
			(WORD)dwID, pszClass, pszTitle, dwStyleEx );
	}

	*ppDlgTemplate = (DLGTEMPLATE*)new BYTE[dlg.GetTemplateSize()];
	CopyMemory(*ppDlgTemplate, dlg.GetDlgTemplate(), dlg.GetTemplateSize());

	return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
//
//
//////////////////////////////////////////////////////////////////////////////
HWND CRenderXMLDialog::CreateDlg( CXMLDlg * pDialog )
{
	DLGTEMPLATE* pDt;

	CreateDlgTemplate( pDialog, &pDt );
    
	CWin32Dlg * pHost=new CWin32Dlg(m_hInst, m_hParent, m_dlgProc, m_dwInitParam, pDialog);

    return CreateDialogIndirectParam( m_hInst, pDt, m_hParent, pHost->BaseDlgProc, (LPARAM)(LPVOID)pHost);

    // LEAK - who cleans up pDT??
}


//////////////////////////////////////////////////////////////////////////////
//
//
//
//////////////////////////////////////////////////////////////////////////////
int CRenderXMLDialog::Render( CXMLDlg * pDialog )
{
	DLGTEMPLATE* pDt;
	int retVal;

	CreateDlgTemplate( pDialog, &pDt );
	CWin32Dlg host(m_hInst, m_hParent, m_dlgProc, m_dwInitParam, pDialog);

	BOOL bAttemptShow=TRUE;
	BOOL bInitCommonControls=TRUE;
	while(bAttemptShow)
	{
		retVal = DialogBoxIndirectParam( m_hInst, pDt, m_hParent, host.BaseDlgProc, (LPARAM)(LPVOID)&host );
		if( retVal==-1 )
		{
			DWORD err=GetLastError();
			TRACE(TEXT("There is an error with the dialog 0x%08x\n"), err );
			if( err == ERROR_TLW_WITH_WSCHILD )
			{
				// cannot create a top-level child window.
                EVENTLOG( EVENTLOG_ERROR_TYPE, LOGCAT_RUNTIME , 1,
                    TEXT("Render"), TEXT("Cannot create a top level child window ") );
#if 0
				if( MessageBox( NULL, TEXT(". Click OK to open anyway"), TEXT("Style bit error"), MB_OKCANCEL ) == IDOK )
				{
					pDt->style &= ~WS_CHILDWINDOW;
                    continue;
				}
				else
#endif
					bAttemptShow=FALSE;
			}

            if( err == ERROR_CANNOT_FIND_WND_CLASS )
            {
                EVENTLOG( EVENTLOG_ERROR_TYPE, LOGCAT_RUNTIME , 1,
                    TEXT("Render"), TEXT("This dialog cannot be tested outside of the application which hosts it. Unregistered window class") );
//				MessageBox( NULL, TEXT("."), TEXT("Unregistered classes"), MB_OK );
				bAttemptShow=FALSE;
            }

			//
			// A pure failure can mean this.
			//
			if( err == 0 && bInitCommonControls )
			{
                INITCOMMONCONTROLSEX icc;
                icc.dwSize=sizeof(icc);
                icc.dwICC=ICC_WIN95_CLASSES ;
				InitCommonControlsEx(&icc);
				bInitCommonControls=FALSE;
			}
		}
		else
			bAttemptShow=FALSE;
	}
	delete pDt;
	return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\resizedlg.cpp ===
// ResizeDlg.cpp: implementation of the CResizeDlg class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ResizeDlg.h"
#include "debug.h"
#include "persctl.h"
#include "xmldlg.h"

// Too Noisy.
#ifdef _DEBUG2
#define TRACE 0?0:
#endif

#define GetWindowStyle( h ) GetWindowLong( h, GWL_STYLE)

#define MIN_COL_SPACE 4
#define MIN_ROW_SPACE 4

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CResizeDlg::CResizeDlg(int DlgID, HWND hWndParent, HINSTANCE hInst)
// : BASECLASS(DlgID, hWndParent, hInst)
{
    SetWindow(hWndParent);  // Really??
	SetAnnotate(FALSE);
	SetRowWeight(0);
	SetColWeight(0);
	m_hwndGripper = NULL;
	m_SpecialRow.bSpecial=FALSE;
	m_SpecialCol.bSpecial=FALSE;
	m_pXML=NULL;
	m_Rows=NULL;
	m_Cols=NULL;

    SetControlCount(0);
    m_bExpanded=FALSE;
    m_bInitedResizeData=FALSE;
    m_bDeterminedWeights=FALSE;
    m_bPlacedControls=FALSE;
    m_bWalkControls=FALSE;
    m_bDeterminNumberOfControls=FALSE;
    m_bMapXMLToHwnds=FALSE;
    m_bUserCanResize=FALSE;
    m_bFoundXMLControls=FALSE;
    m_bUserCanMakeWider=FALSE;
    m_bUserCanMakeTaller=FALSE;
    m_FrameHorizPadding=0;    // how much to add to the client area to get the 
    m_FrameVertPadding=0;     // window the right size (menu, caption, border etc).
    m_ControlInfo=NULL;
}

CResizeDlg::~CResizeDlg()
{
	delete [] m_Rows;
	delete [] m_Cols;
    if ( m_ControlInfo )
    {
        for(int i=0;i<m_ControlCount; i++)
            delete m_ControlInfo[i].pLayoutInfo;
        delete m_ControlInfo;
    }
}

//////////////////////////////////////////////////////////////////////
//
//
//
//////////////////////////////////////////////////////////////////////
BOOL CALLBACK CResizeDlg::DlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
	switch( uMessage )
	{
	case WM_NCHITTEST:
		{
            if( m_pXML->GetResizeMode() == 0 )
                return FALSE;

			// call def window proc to see what he wants to do
			LONG lRes= HitTest( DefWindowProc( hDlg, uMessage, wParam, lParam ) );
			if( lRes != (HTERROR-1) )
			{
				SetWindowLong( hDlg, DWL_MSGRESULT,  lRes );
				return TRUE;
			}
		}
		break;

	case WM_INITDIALOG:
		DoInitDialog();
		return TRUE;
		break;

//
// This is for the resizing code.
//
	case WM_WINDOWPOSCHANGING:
        if( m_pXML->GetResizeMode() == 0 )
            return FALSE;

		if( m_bUserCanResize )
			DoChangePos( (WINDOWPOS*)lParam);
		else
		{
			WINDOWPOS * pWindow=(WINDOWPOS*)lParam;
			pWindow->flags |= SWP_NOSIZE;
		}
		break;

	case WM_SIZE:
        if( m_pXML->GetResizeMode() == 0 )
            return FALSE;

		if( m_bUserCanResize )
		{
			// Don't try to re-adjust to the size when initially shown.
			if( wParam == SIZE_RESTORED )
			{
				WINDOWPOS pos={NULL, NULL, 0,0, LOWORD(lParam), HIWORD(lParam), 
					SWP_NOACTIVATE | SWP_NOCOPYBITS | SWP_NOMOVE | SWP_NOOWNERZORDER |
					SWP_NOREDRAW | SWP_NOSENDCHANGING | SWP_NOZORDER };
				DoChangePos( &pos );
				ResizeControls(LOWORD( lParam ) , HIWORD (lParam) );
			}
		}
		break;

	case WM_PAINT:
		Annotate();
		break;
	}
	return FALSE;
}

////////////////////////////////////////////////////////////////////////
//
// Walks all the controls, finds their edges,
// attatches them to their edges/guides.
//
////////////////////////////////////////////////////////////////////////
void CResizeDlg::WalkControls()
{
    if( m_bWalkControls )
        return;

    m_bWalkControls=TRUE;

	m_ParentInfo.Init( GetWindow(), m_pXML );

    //
    // Quick hack.
    //
    m_ControlInfo = new CONTROL_INFO[m_ControlCount];

    IRCMLControlList & controls=m_pXML->GetChildren();
    for(int i=0;i<m_ControlCount; i++)
    {
        m_ControlInfo[i].pControl    = controls.GetPointer(i);
        m_ControlInfo[i].pLayoutInfo = new CLayoutInfo();
        m_ControlInfo[i].pLayoutInfo->Init( m_ControlInfo[i].pControl,
            m_ParentInfo );
    }


	m_ParentInfo.DeterminBorders( m_pXML->GetChildren() );
	FindCommonGuides();
}

////////////////////////////////////////////////////////////////////////
//
// Walk the rows / columns, widening them if the controls are clippe
//
////////////////////////////////////////////////////////////////////////
void CResizeDlg::ExpandIfClipped()
{
    if(m_bExpanded)
        return;
    m_bExpanded=TRUE;

    int xPadding=0;
    int yPadding=0;

    //
    // Check to see if we should be doing clipped work
    //
    if( m_pXML->GetCilppingMode() != 1 )    // ALLOW
    {
	    //
	    // Build an array of the 'overflow' for each colum / row.
	    //
	    int iNumCols=GetNumCols();
	    int iNumRows=GetNumRows();

	    int * ColClipped=(int*)_alloca(sizeof(int)*(iNumCols+1));
	    int * RowClipped=(int*)_alloca(sizeof(int)*(iNumRows+1));

        ZeroMemory( ColClipped, sizeof(int)*(iNumCols+1) );
        ZeroMemory( RowClipped, sizeof(int)*(iNumRows+1) );

	    int i=0;
        IRCMLControlList & controls=m_pXML->GetChildren();
        IRCMLControl * pXMLControl;
	    while( pXMLControl=controls.GetPointer(i++) )
	    {
            IRCMLControl * pMyControlType=pXMLControl;

            CLayoutInfo & resize = GetResizeInformation(pMyControlType);

		    SIZE size;
            pXMLControl->get_Clipped( &size );

		    if( size.cx )
		    {
			    int Col=resize.GetCol();
			    if( ColClipped[Col] < size.cx )
				    ColClipped[Col] = size.cx;
		    }
		    if( size.cy )
		    {
			    int Row=resize.GetRow();
			    if( RowClipped[Row] < size.cy )
				    RowClipped[Row] = size.cy;
		    }
	    }

	    int fi;
	    int iPadding=0;
	    for( fi=0;fi<= iNumCols; fi++)
	    {
		    m_Cols[ fi ].Pos += iPadding;
		    xPadding=iPadding;
	        iPadding+=ColClipped[fi];
	    }

        TRACE(TEXT("CResizeDlg::ExpandIfClipped() x total expansion %d\n"), iPadding);
        if(iPadding)
        {
            EVENTLOG( EVENTLOG_INFORMATION_TYPE, LOGCAT_RESIZE, 1, 
                TEXT("Clipped"), TEXT("Dialog requires an additional %d pixels wider"), iPadding );
        }

	    iPadding=0;
	    for( fi=0;fi<= iNumRows; fi++)
	    {
		    m_Rows[ fi ].Pos += iPadding;
		    yPadding=iPadding;
   		    iPadding+=RowClipped[fi];
	    }
        TRACE(TEXT("CResizeDlg::ExpandIfClipped() y total expansion %d\n"), iPadding);
        if(iPadding)
        {
            EVENTLOG( EVENTLOG_INFORMATION_TYPE, LOGCAT_RESIZE | LOGCAT_CLIPPING, 1,
                TEXT("Clipped"), TEXT("Dialog requires an additional %d pixels height"), iPadding );
        }
    }

	m_InitialDialogSize.cx= m_ParentInfo.GetWidth()+xPadding;
	m_InitialDialogSize.cy= m_ParentInfo.GetHeight()+yPadding;

	LayoutControlsOnGrid( (USHORT)m_InitialDialogSize.cx, (USHORT)m_InitialDialogSize.cy, TRUE);
}

////////////////////////////////////////////////////////////////////////
//
// Walk the rows / columns, widening them if the controls are clipped
// results in Pixels.
//
////////////////////////////////////////////////////////////////////////
SIZE CResizeDlg::GetAdjustedSize()
{
	//
	// Build an array of the 'overflow' for each colum / row.
	//
	DeterminNumberOfControls();
    if( GetControlCount() == 0 )
    {
        SIZE s={0,0};
        return s;
    }
	WalkControls();
	PlaceControls();

    //
    // Check to see if we should be doing clipped work
    //
    if( m_pXML->GetCilppingMode() == 1 )    // ALLOW
    {
        SIZE noChange={0,0};
        return noChange;
    }

	int iNumCols=GetNumCols();
	int iNumRows=GetNumRows();

	int * ColClipped=(int*)_alloca(sizeof(int)*(iNumCols+1));
	int * RowClipped=(int*)_alloca(sizeof(int)*(iNumRows+1));

    ZeroMemory( ColClipped, sizeof(int)*(iNumCols+1) );
    ZeroMemory( RowClipped, sizeof(int)*(iNumRows+1) );

	int i=0;
    IRCMLControlList & controls=m_pXML->GetChildren();
    IRCMLControl * pXMLControl;
	while( pXMLControl=controls.GetPointer(i++) )
	{
        CLayoutInfo & resize = GetResizeInformation(pXMLControl);

		SIZE size;
        pXMLControl->get_Clipped( &size );

        //
        // Should be able to work out columns from the clipped size, NOT from constraints.
        //
		if( size.cx )
		{
			int Col=resize.GetCol();
			if( ColClipped[Col] < size.cx )
				ColClipped[Col] = size.cx;
		}
		if( size.cy )
		{
			int Row=resize.GetRow();
			if( RowClipped[Row] < size.cy )
				RowClipped[Row] = size.cy;
		}
	}


	int fi;
	int xPadding=0;
	for( fi=0;fi< iNumCols; fi++)
		xPadding+=ColClipped[fi];

	int yPadding=0;
	for( fi=0;fi< iNumRows; fi++)
		yPadding+=RowClipped[fi];

    if( xPadding || yPadding)
    {
        EVENTLOG( EVENTLOG_INFORMATION_TYPE, LOGCAT_RESIZE | LOGCAT_CLIPPING, 1, 
            TEXT("Clipped"), TEXT("Dialog needs to be %d by %d pixles bigger"), xPadding, yPadding );
    }

    SIZE s;
    s.cx=xPadding;
    s.cy=yPadding;
    return s;
}

////////////////////////////////////////////////////////////////////////
//
// The dialog size is being changed, distribute the new space amongst the
// controls
//
////////////////////////////////////////////////////////////////////////
void CResizeDlg::ResizeControls(WORD width, WORD height)
{
	if( !m_bUserCanResize )
		return;

	int iSpecialRow = GetNumRows()-1;
	int iSpecialCol = GetNumCols()-1;
	//
	// Add free space
	//
	if( GetColWeight()>0 )
	{
		int FreeW = width - m_Cols[ GetNumCols() ].Pos - m_ParentInfo.GetRightBorder();
		if( FreeW != 0 )
		{
			int iPadding=0;
			int iPad=FreeW/GetColWeight();
            int iNumCols=GetNumCols();
			for( int fi=0;fi<= iNumCols; fi++)
			{
				m_Cols[ fi ].Pos += iPadding;
				if( m_Cols[fi].iFixed>=0 )
					iPadding+=iPad * m_Cols[fi].iWeight;
			}
		}
	}

	//
	// Add free row.
	//
	if( GetRowWeight()>0 )
	{
		int Free = height - m_Rows[ GetNumRows() ].Pos - m_ParentInfo.GetBottomBorder();
		if( Free != 0 )
		{
			int iPadding=0;
			int iPad=Free/GetRowWeight();
            int iNumRows=GetNumRows();
			for( int fi=0;fi<= iNumRows; fi++)
			{
				m_Rows[ fi ].Pos += iPadding;
				if( m_Rows[fi].iFixed>=0)
					iPadding+=iPad * m_Rows[fi].iWeight;
			}
		}
	}

	LayoutControlsOnGrid(width, height, FALSE);
}

////////////////////////////////////////////////////////////////////////////////////////////
//
// if bClipped - ignore their attempts to not size - they were clipped.
//
////////////////////////////////////////////////////////////////////////////////////////////
void CResizeDlg::LayoutControlsOnGrid(WORD width, WORD height, BOOL bClipped)
{
    IRCMLControlList & m_ControlList = m_pXML->GetChildren();

    if( m_ControlList.GetCount()== 0 )
        return;

	int iSpecialRow = GetNumRows()-1;
	int iSpecialCol = GetNumCols()-1;
	//
	// Now setup the information for all of the controls, as to which cell they are in.
	//
	HDWP hdwp = BeginDeferWindowPos( m_ControlList.GetCount() );
	int i=0;
    IRCMLControlList & controls=m_pXML->GetChildren();
    IRCMLControl * pXMLControl;
	while( pXMLControl=controls.GetPointer(i++) )
	{
        IRCMLControl * pMyControlType=pXMLControl;
        CLayoutInfo & resize = GetResizeInformation(pMyControlType);
        HWND hControl;
        pXMLControl->get_Window(&hControl);

        TRACE(TEXT("Control row %d col %d\n"), resize.GetRow(), resize.GetCol() );

		int x=m_Cols[resize.GetCol()].Pos + resize.GetPadLeft();
		int y=m_Rows[resize.GetRow()].Pos + resize.GetPadTop();
		int w,h;

		BOOL bMove=true; BOOL bSize=false;
        BOOL bWider;
        BOOL bTaller;
        pXMLControl->get_GrowsWide( &bWider );
        pXMLControl->get_GrowsTall( &bTaller);
		if( bWider || bClipped )
		{
			w=m_Cols[resize.GetCol()+resize.GetColW()].Pos + resize.GetPadRight() -x;
			bSize=true;
		}
		else
        {
			w=resize.GetWidth(); // pXMLControl->GetWidth();
        }

		if( bTaller || bClipped )
		{
			h=m_Rows[resize.GetRow()+resize.GetRowH()].Pos + resize.GetPadBottom() -y;
			bSize=true;
		}
		else
			h=resize.GetHeight(); // pXMLControl->GetHeight();

		//
		// Here we special case the ComboBox - yuck.
		//
        if( SUCCEEDED( pXMLControl->IsType(L"GROUPBOX") ))
		{
			//
			// Force the width / height.
			//
			w=m_Cols[resize.GetCol()+resize.GetColW()].Pos + resize.GetPadRight() -x;
			h=m_Rows[resize.GetRow()+resize.GetRowH()].Pos + resize.GetPadBottom() -y;
			bSize=true;
		}

        RECT initialLocation = resize.GetInitialPixelLocation();
		//
		// If they are in special row / columns we do something special to them.
		//
		if( m_SpecialCol.bSpecial && ( resize.GetCol() == iSpecialCol ) )
		{
			// alignment issues
			if(m_SpecialCol.iAlignment == -1 )
			{
				y=initialLocation.top; // pC->GetTopGap();
			}
			else
			if(m_SpecialCol.iAlignment == 1 )
			{
				//
				// Right aligned.
				//
				y=initialLocation.top + height - m_SpecialCol.iMax - m_ParentInfo.GetTopBorder();
			}
			else
			{
				//
				// Center aligned
				//
				y=initialLocation.top + ((height - m_SpecialCol.iMax - m_ParentInfo.GetTopBorder())/2);
			}
		}

		if( m_SpecialRow.bSpecial && ( resize.GetRow() == iSpecialRow ) )
		{
			// alignment issues
			if(m_SpecialRow.iAlignment == -1 )
			{
				x=initialLocation.left; // pC->GetLeftGap();
			}
			else
			if(m_SpecialRow.iAlignment == 1 )	// right aligned.
			{
				x=initialLocation.left + width - m_SpecialRow.iMax - m_ParentInfo.GetRightBorder();
			}
			else
			{
				x=initialLocation.left + ((width - m_SpecialRow.iMax - m_ParentInfo.GetRightBorder() ) / 2);
			}
		}
		hdwp = DeferWindowPos( hdwp, hControl, 
            NULL, 
			x, y, w , h,
			(bMove ? 0: SWP_NOMOVE) |	(bSize ? 0: SWP_NOSIZE) | SWP_NOZORDER );
	}
	//
	// Move the gripper
	//
	SetGripperPos(hdwp);

	EndDeferWindowPos( hdwp );
}

////////////////////////////////////////////////////////////////////////
//
// Tries to combine guides to be offsets from other guides.
//
////////////////////////////////////////////////////////////////////////
void CResizeDlg::FindCommonGuides()
{
	CEdge ** ppVert = m_ParentInfo.GetVerticalEdges();
	CEdge ** ppHoriz = m_ParentInfo.GetHorizontalEdges();

	//
	// Work out which guides are used in columns.
	//
	int iCount=m_ParentInfo.GetNumVert();
	Sort(ppVert, iCount );

#ifdef _DEBUG2
	int i;
	TRACE(TEXT("Vertical edge information %d edges\n"), iCount );
	for(i=0;i<iCount;i++)
	{
		CEdge * pEdge=ppVert[i];
		TRACE(TEXT("Edge %02d: Edge@%02d times as 0x%02x, position %08d, Guide@%03d\n"),
			i, pEdge->GetControlCount(), 
			pEdge->GetGuide()->Attatchment(),
			pEdge->GetPosition(),
			pEdge->GetGuide()->NumAttatchments()
			);
	}
#endif

	iCount=m_ParentInfo.GetNumHoriz();
	Sort(ppHoriz, iCount );

#ifdef _DEBUG2
	TRACE(TEXT("Horiz edge information %d edges\n"), iCount );
	for(i=0;i<iCount;i++)
	{
		CEdge * pEdge=ppHoriz[i];
		CGuide * pGuide=pEdge->GetGuide();
		TRACE(TEXT("Edge %02d: Edge@%02d times as 0x%02x, position %08d, Guide@%03d\n"),i,
			pEdge->GetControlCount(), 
			pEdge->Attatchment(),
			pGuide->GetPosition(),
			pEdge->GetGuide()->NumAttatchments()
			);
	}
#endif

	//
	// Determin rows and columns
	//
	DeterminCols( ppVert, m_ParentInfo.GetNumVert() );
	DeterminRows( ppHoriz, m_ParentInfo.GetNumHoriz() );

	delete [] ppVert;
	delete [] ppHoriz;
}

////////////////////////////////////////////////////////////////////////
//
// Sorts an array of edges.
//
////////////////////////////////////////////////////////////////////////
void CResizeDlg::Sort(CEdge * *ppEdges, int iCount)
{
	//
	// sort BB fix later.
	//
	int iInsert=0;
	while ( iInsert < iCount )
	{
		int iSmallest=iInsert;
		for(int iMatch=iInsert; iMatch<iCount; iMatch++)
		{
			if( ppEdges[iMatch]->GetPosition() < ppEdges[iSmallest]->GetPosition() )
				iSmallest=iMatch;
		}
		if( iSmallest > iInsert )
		{
			CEdge * pTemp=ppEdges[iInsert];
			ppEdges[iInsert]=ppEdges[iSmallest];
			ppEdges[iSmallest]=pTemp;
		}
		// TRACE(TEXT("%02d is %08d\n"), iInsert, ppEdges[iInsert]->GetPosition() );
		iInsert++;
	}
}


////////////////////////////////////////////////////////////////////////
//
// State table kinda used to determin when a new col. is needed
// Prev	This	New Col?
// L	L		Yes, on this edge
// L	R		Yes, on this edge
// R	L		Yes, between these two edges
// R	R		Yes if last (no if on same guide)?
//
////////////////////////////////////////////////////////////////////////
void CResizeDlg::DeterminCols(CEdge * * ppEdges, int iCount)
{
	//
	// First pass is just to work out positions of edges,
	// and if those edges constitute Columns.
	//
	int i;
	int iCols=0;
	int iLastGuide;
	int iThisGuide;
    int * iPos = (int*)_alloca(sizeof(int)*iCount);
	iPos[0]=ppEdges[0]->GetPosition();		// we always use the first edge.
	int iLastPos=0;
    int iCurrentPos=0;
	for(i=1; i<iCount;i++)
	{
		iThisGuide=ppEdges[i]->Attatchment() ;
		iLastGuide=ppEdges[i-1]->Attatchment();
        iCurrentPos = ppEdges[i]->GetPosition();
		// TRACE(TEXT("Edge:%02d COL - Attatched as %02d @ %04d\n"), i, iThisGuide, iCurrentPos );

		//
		// Column between these two controls 
		//
		if( (iLastGuide & RIGHT_AT ) && ( iThisGuide & LEFT_AT ) )
		{
            int iPreviousPos = ppEdges[i-1]->GetPosition();
            iCols++;
			iPos[iCols] = iPreviousPos + ((iCurrentPos - iPreviousPos)/2);
			continue;
		}

		//
		// If we're starting another left edge of a control, needs a new guide
		//
		if( (iThisGuide & LEFT_AT ) )
		{
            iCols++;
			iPos[iCols]= iCurrentPos;
			continue;
		}

		//
		// If this is the last right edge
		//
		if( (iThisGuide & RIGHT_AT ) && ((i+1)==iCount) )
		{
            iCols++;
			iPos[iCols] = iCurrentPos ;
			continue;	// just incase you add anytyhing below
		}
	}


	//
	// Second pass is to make up the column information
	// we don't allow narrow colums, that is columns who are <2 appart.
	//
	TRACE(TEXT("Column Widths are ...\n"));
	SetNumCols( iCols );			// 0 through n are USED. Not n-1
	m_Cols = new CHANNEL[iCols+1];
	m_Cols[0].Pos=iPos[0];
	iLastPos=0;
	int iThisCol=1;
	for(int iThisPos=1;iThisPos<=iCols;iThisPos++)
	{
        // if(iThisPos==iCols) // dummy up a last entry.
        //    iPos[iThisPos]=iPos[iLastPos];

		int iWidth=iPos[iThisPos]-iPos[iLastPos];
		if( TRUE || (iWidth >= MIN_COL_SPACE ) )
		{
			m_Cols[iThisCol].Pos = iPos[iThisPos];
			m_Cols[iThisCol].iFixed = -1;
			m_Cols[iThisCol-1].Size = iWidth;
			m_Cols[iThisCol-1].iWeight=0;
			m_Cols[iThisCol-1].iFixed=FALSE;
			/*
			TRACE(TEXT("Col:%02d Width:%03d Pos:%03d\n"),	
				iThisCol-1, 
				m_Cols[iThisCol-1].Size, 
				m_Cols[iThisCol-1].Pos);
			*/
			iLastPos=iThisPos;
			iThisCol++;
		}
		else
		{
			// TRACE(TEXT("Skipping col #%d as it's only %d wide\n"),iThisPos,iWidth);
		}
	}

#ifdef _DEBUG
	if( (iThisCol-1) != iCols )
		TRACE(TEXT("Skipped %d rows\n"),iThisCol-1-iCols);
#endif
	SetNumCols( iThisCol-1 );
}

////////////////////////////////////////////////////////////////////////
//
// State table kinda used to determin when a new col. is needed
// Prev	This	New Col?
// L	L		Yes, on this edge
// L	R		Yes, on this edge
// R	L		Yes, between these two edges
// R	R		Yes if last (no if on same guide)?
//
////////////////////////////////////////////////////////////////////////
void CResizeDlg::DeterminRows(CEdge * * ppEdges, int iCount)
{
	int i;
	int iRows=0;
	int iLastGuide;
	int iThisGuide;
	// int * iPos = new int[iCount];
    int * iPos=(int*)_alloca(sizeof(int)*iCount);

	//
	// brute force, each edge is a row.
	//
    i=0;
	iRows=0;
	iPos[i]=ppEdges[i]->GetPosition();
	int iLastPos=0;
	iThisGuide=ppEdges[i]->Attatchment();   // the first attatchment.
	TRACE(TEXT("Edge:%02d ROW - Attatched as %02d pos:%03d\n"), i, iThisGuide, ppEdges[i]->GetPosition() );
	for(i=1; i<iCount;i++)
	{
        iLastGuide = iThisGuide;
		iThisGuide=ppEdges[i]->Attatchment() ;
		// TRACE(TEXT("Edge:%02d ROW - Attatched as %02d pos:%03d\n"), i, iThisGuide, ppEdges[i]->GetPosition() );

		//
		// row between these two controls 
		//
		if( (iLastGuide & BOTTOM_AT ) && ( iThisGuide & TOP_AT ) )
		{
			iRows++;
			iPos[iRows] = ppEdges[i-1]->GetPosition() + ((ppEdges[i]->GetPosition() - ppEdges[i-1]->GetPosition())/2);
			continue;
		}

		//
		// If we're starting another left edge of a control, needs a new guide
		//
		if( (iThisGuide & TOP_AT ) )
		{
			iRows++;
			iPos[iRows]= ppEdges[i]->GetPosition();
			continue;
		}

		//
		// If this is the last right edge
		//
		if( (iThisGuide & BOTTOM_AT ) && ((i+1)==iCount) )
		{
			iRows++;
			iPos[iRows] = ppEdges[i]->GetPosition() ;
			continue;	// just incase you add anytyhing below
		}
	}

	//
	// Second pass is to make up the column information
	// we don't allow narrow colums, that is columns who are <2 appart.
	//
	TRACE(TEXT("Rowumn Widths are ...\n"));
	SetNumRows( iRows );			// 0 through n are USED. Not n-1
	m_Rows = new CHANNEL[iRows+1];
	m_Rows[0].Pos=iPos[0];
	iLastPos=0;
	int iThisRow=1;
	for(int iThisPos=1;iThisPos<=iRows;iThisPos++)
	{
		int iWidth=iPos[iThisPos]-iPos[iLastPos];
		if( iWidth >= MIN_ROW_SPACE )
		{
			m_Rows[iThisRow].Pos = iPos[iThisPos];
			m_Rows[iThisRow].iFixed = -1;   // place holders for the last row/column
			m_Rows[iThisRow-1].Size = iWidth;
			m_Rows[iThisRow-1].iWeight=0;
			m_Rows[iThisRow-1].iFixed=FALSE;

			// TRACE(TEXT("Row:%2d Height:%3d Pos:%3d\n"),	iThisRow-1, m_Rows[iThisRow-1].Size, m_Rows[iThisRow-1].Pos);

			iLastPos=iThisPos;
			iThisRow++;
		}
		else
		{
			// TRACE(TEXT("Skipping Row #%d as it's only %d wide\n"),iThisPos,iWidth);
		}
	}
#ifdef _DEBUG
	if( (iThisRow-1) != iRows )
		TRACE(TEXT("Skipped %d rows\n"),iThisRow-1-iRows);
#endif
	SetNumRows( iThisRow-1 );
}

////////////////////////////////////////////////////////////////////////
//
// Draws the annotations on the dialog of where the column/rows are
//
////////////////////////////////////////////////////////////////////////
void CResizeDlg::Annotate()
{
	if(GetAnnotate()==FALSE)
		return;

	HDC hdc=GetDC( GetWindow() );
	//
	// Draw all the control edges on the screen.
	//

	//
	// Now show the cols/rows
	//
	int iCount=GetNumRows();
	int i;
	RECT r;
	GetWindowRect( GetWindow(), &r);
	int iWidth=r.right - r.left;
	int iHeight=r.bottom - r.top;

	HPEN hFixedPen = CreatePen( PS_SOLID, 2, RGB( 0x00,0x00,0xff) );
	HPEN hSizePen = CreatePen( PS_SOLID, 2, RGB( 0x00,0xff,0x00) );
	HGDIOBJ holdPen= SelectObject( hdc, hFixedPen);

	//
	// Horizontal lines
	//
	for(i=0;i<=iCount;i++)
	{
		if( m_Rows[i].iFixed >= 0 )
			SelectObject( hdc, hSizePen );
		else
			SelectObject( hdc, hFixedPen );
		MoveToEx( hdc, 0, m_Rows[i].Pos, NULL );
		LineTo( hdc, iWidth , m_Rows[i].Pos );
	}

	//
	// Vertical lines
	//
	iCount = GetNumCols();
	for(i=0;i<=iCount;i++)
	{
		if( m_Cols[i].iFixed >= 0 )
			SelectObject( hdc, hSizePen );
		else
			SelectObject( hdc, hFixedPen );
		MoveToEx( hdc, m_Cols[i].Pos, 0, NULL );
		LineTo( hdc, m_Cols[i].Pos, iHeight );
	}

	SelectObject(hdc, holdPen);
	DeleteObject(hFixedPen);
	DeleteObject(hSizePen);

	ReleaseDC( GetWindow(), hdc );
}

////////////////////////////////////////////////////////////////////////
//
// 
//
////////////////////////////////////////////////////////////////////////
int CResizeDlg::FindRow(int pos)
{
	int i=0;
	while( i<=GetNumRows() )
	{
		if( m_Rows[i].Pos > pos )
			return i-1;
		i++;
	}
	return GetNumRows();
}

////////////////////////////////////////////////////////////////////////
//
// 
//
////////////////////////////////////////////////////////////////////////
int CResizeDlg::FindCol(int pos)
{
	int i=0;
	while( i<=GetNumCols() )
	{
		if( m_Cols[i].Pos > pos )
			return i-1;
		i++;
	}
	return GetNumCols();
}

////////////////////////////////////////////////////////////////////////
//
// Walks the rows/columns and determins if they are resizable.
// this just adds up the information in the col/rows.
// The information is set by ... PlaceControls
//
////////////////////////////////////////////////////////////////////////
void CResizeDlg::DeterminWeights()
{
    if( m_bDeterminedWeights )
        return;
    m_bDeterminedWeights = TRUE;

	if( m_pXML )
	{
		// Two ways to do this, first from the specfied column / row information
		// second from the controls themselves in the control information.
		// return;
		if( m_pXML ->GetResizeMode()== 2 )
		{
			//
			//
			//
			TRACE(TEXT("Columns should be weighted by the individual controls\n"));
		}
	}

    // REVIEW - is this really <=??
    // last column is just a POSITION place holder, the other values are meaningless.
	int iColWeight=0;
	{
		for( int fi=0;fi< GetNumCols(); fi++)
			m_Cols[ fi ].iFixed<0 ? 0: iColWeight+=m_Cols[fi].iWeight;
	}

	int iRowWeight=0;
	{
		for( int fi=0;fi< GetNumRows(); fi++)
			m_Rows[ fi ].iFixed<0 ? 0: iRowWeight+=m_Rows[fi].iWeight;
	}

	SetColWeight(iColWeight);
	SetRowWeight(iRowWeight);

    m_bUserCanMakeWider = iColWeight>0;
    m_bUserCanMakeTaller = iRowWeight>0;
    m_bUserCanResize = m_bUserCanMakeTaller  || m_bUserCanMakeWider;
    TRACE(TEXT("This dialog %s be resized\n"), m_bUserCanResize?TEXT("can"):TEXT("cannot"));
}

////////////////////////////////////////////////////////////////////////
//
// Passed in the current hit test, allows you to override it.
// return HTERROR -1 if we didn't deal with it.
//
////////////////////////////////////////////////////////////////////////
LONG CResizeDlg::HitTest(LONG lCurrent)
{
#define WIDE 1
#define HIGH 2
    int iThisDlg = (m_bUserCanMakeWider ? WIDE : 0) | (m_bUserCanMakeTaller ? HIGH : 0 );

	// TRACE(TEXT("NC Hit Test %d - dlg is %d\n"),lCurrent, iThisDlg);
	switch( lCurrent )
	{
		case HTLEFT: // In the left border of a window 
		case HTRIGHT: // In the rigcase HT border of a window 
			if( iThisDlg & WIDE )
				return lCurrent;	// OK
			return HTNOWHERE;

		case HTTOP: // In the upper horizontal border of a window 
		case HTBOTTOM: // In the lower horizontal border of a window 
			if( iThisDlg==0)
				return HTNOWHERE;
			if( iThisDlg & HIGH ) 
				return lCurrent;	// OK
			return HTNOWHERE;		// Can't make taller

		case HTTOPLEFT: // In the upper-left corner of a window border 
		case HTTOPRIGHT: // In the upper rigcase HT corner of a window border 
			if( iThisDlg==0)
				return HTNOWHERE;

			if( (iThisDlg & (HIGH | WIDE)) == (HIGH | WIDE ))
				return lCurrent;
			if( iThisDlg & HIGH )
				return HTTOP;
			if( lCurrent == HTTOPLEFT )
				return HTLEFT;
			return HTRIGHT;

		case HTGROWBOX: // In a size box (same as case HTSIZE) 
			if( iThisDlg==0)
				return HTNOWHERE;
			if( (iThisDlg & (HIGH | WIDE)) == (HIGH | WIDE ))
				return lCurrent;
			if( iThisDlg & HIGH )
				return HTBOTTOM;
			return HTRIGHT;

		case HTBOTTOMLEFT: // In the lower-left corner of a window border 
		case HTBOTTOMRIGHT: // In the lower-rigcase HT corner of a window border 
			if( iThisDlg==0)
				return HTNOWHERE;
			if( (iThisDlg & (HIGH | WIDE)) == (HIGH | WIDE ))
				return lCurrent;
			if( iThisDlg & HIGH )
				return HTBOTTOM;
			if(lCurrent == HTBOTTOMRIGHT)
				return HTRIGHT;
			return HTLEFT;
	}
	return HTERROR-1;
}

////////////////////////////////////////////////////////////////////////
//
// Determins the location of the controls in the row/col space.
// In addition this finds out if the controls can be made bigger
// smaller
//
////////////////////////////////////////////////////////////////////////
void CResizeDlg::PlaceControls()
{
    if(m_bPlacedControls)
        return;
    m_bPlacedControls=TRUE;

	//
	// Now setup the information for all of the controls, as to which cell they are in.
	//
	int i=0;
    IRCMLControlList & controls=m_pXML->GetChildren();
    IRCMLControl * pXMLControl;
	while( pXMLControl=controls.GetPointer(i++) )
	{
        CLayoutInfo & resize = GetResizeInformation(pXMLControl);

		int Row, Col, RowH, ColW;

		RECT r= resize.GetInitialPixelLocation();

		Row  = FindRow( r.top);
		RowH = FindRow( r.bottom ) - Row +1 ;
		if( RowH + Row > GetNumRows() )
			RowH = GetNumRows() - Row;

		Col  = FindCol( r.left);
		ColW = FindCol( r.right ) - Col + 1;
		if( ColW + Col > GetNumCols() )
			ColW = GetNumCols() - Col;

		resize.SetCol( Col );
		resize.SetRow( Row );
		resize.SetColW( ColW );
		resize.SetRowH( RowH );

		//
		// Now adjust the padding from the edges of the cell.
		//
		resize.SetPadTop   ( r.top    - m_Rows[ Row ].Pos );
		resize.SetPadBottom( r.bottom - m_Rows[ Row + RowH ].Pos );
		resize.SetPadLeft  ( r.left   - m_Cols[ Col ].Pos );
		resize.SetPadRight ( r.right  - m_Cols[ Col + ColW ].Pos  );

		/*
		IF you're worried that you got the dimentions wrong
		TRACE(TEXT("Component %03d [%06d] %s\n pos: l:%03d, r:%03d, t:%03d, b:%03d\nCell: l:%03d, r:%03d, t:%03d, b:%03d\n"),
			i, GetDlgCtrlID( pC->GetControl()),  pC->GetClassName(), r.left, r.right, r.top, r.bottom,
			m_Cols[constraint.GetCol()].Pos + constraint.GetPadLeft(),
			m_Cols[constraint.GetCol()+constraint.GetColW()].Pos + constraint.GetPadRight(),
			m_Rows[constraint.GetRow()].Pos + constraint.GetPadTop(),
			m_Rows[constraint.GetRow()+constraint.GetRowH()].Pos + constraint.GetPadBottom() );
		*/

		/*
		TRACE(TEXT("Component %03d [%06d] %s\n pos: Cell: %03d,%03d by %03d x %03d\n Padding:l:%03d, r:%03d, t:%03d, b:%03d\n"),
			i, GetDlgCtrlID( pC->GetControl()),  pC->GetClassName(), 
			constraint.GetCol(), constraint.GetRow(), constraint.GetColW(), constraint.GetRowH(),
			constraint.GetPadLeft(), constraint.GetPadRight(), constraint.GetPadTop(), constraint.GetPadBottom() );
		*/
        BOOL bWider=FALSE;
        BOOL bTaller=FALSE;
        pXMLControl->get_GrowsWide( &bWider );
        pXMLControl->get_GrowsTall( &bTaller);
		int iRM=m_pXML->GetResizeMode();
		switch(iRM)
		{
		case 0:
			// strange, shouldn't be here!
			break;
		case 1: // Fully automatic
			{
			//
			// Mark each column this control spans as gets wider.
			//
			int iCol=resize.GetCol();
			int ic=resize.GetColW();
			while( ic-- )
			{
				if( bWider == false )
					m_Cols[ iCol+ic ].iFixed-=1;	// can't make wider
				else
				{
					m_Cols[ iCol+ic ].iWeight++;
					m_Cols[ iCol+ic ].iFixed+=2;	// can make wider
				}
			}

			ic=resize.GetRowH();
			int iRow=resize.GetRow();
			while( ic-- )
			{
				if( bTaller == false )
					m_Rows[ iRow+ic ].iFixed-=1;	// can't make wider
				else
				{
					m_Rows[ iRow+ic ].iWeight++;
					m_Rows[ iRow+ic ].iFixed+=2;	// can make wider
				}
			}
			}
			break;

		case 2: // Semi automatic - any resizeable control resizes the dialog.
			{
				//
				// Mark each column this control spans as gets wider.
				//
				int iCol=resize.GetCol();
				int ic=resize.GetColW();
				while( ic-- )
				{
					if( bWider == false )
						m_Cols[ iCol+ic ].iFixed-=0;	// can't make wider
					else
					{
						m_Cols[ iCol+ic ].iWeight++;
						m_Cols[ iCol+ic ].iFixed+=1;	// can make wider
					}
				}

				ic=resize.GetRowH();
				int iRow=resize.GetRow();
				while( ic-- )
				{
					if( bTaller == false )
						m_Rows[ iRow+ic ].iFixed-=0;	// can't make wider
					else
					{
						m_Rows[ iRow+ic ].iWeight++;
						m_Rows[ iRow+ic ].iFixed+=1;	// can make wider
					}
				}
			}
		}
	}
}

////////////////////////////////////////////////////////////////////////
//
// Determins if we can actually change size to that asked for.
// NOTE, for clipped text, the dialog HAS to be allowed to resize.
// even if the dialog is marked 'non-resizing' - so we set SWP_NOSENDCHANGING
//
////////////////////////////////////////////////////////////////////////
void CResizeDlg::DoChangePos(WINDOWPOS * lpwp)
{
	if( (lpwp->flags & SWP_NOSIZE) == FALSE)
	{

        RECT dialogSize;
        GetClientRect(GetWindow(), &dialogSize);

        //
        // If the dialog cannot be resized, prevent the change in that direction.
        //
		if( m_bUserCanMakeTaller==FALSE )
			lpwp->cy=dialogSize.bottom;
		if( m_bUserCanMakeWider==FALSE )
			lpwp->cx=dialogSize.right;

        //
        // Is the user shrinking the dialog below our initial size?
        //
		DIMENSION dMin= m_ParentInfo.GetMinimumSize();
		dMin.Width = m_InitialDialogSize.cx+m_FrameHorizPadding;
		dMin.Height = m_InitialDialogSize.cy+m_FrameVertPadding;
		if( lpwp->cx < dMin.Width )
			lpwp->cx=dMin.Width;
		if( lpwp->cy < dMin.Height )
			lpwp->cy=dMin.Height;
	}
}

////////////////////////////////////////////////////////////////////////
//
// 
//
////////////////////////////////////////////////////////////////////////
void CResizeDlg::DoInitDialog()
{
    if( m_bInitedResizeData )
        return;

    m_bInitedResizeData=TRUE;

    if(m_pXML)
    {
        CXMLWin32Layout * pLayout=m_pXML->GetLayout();
        if(pLayout)
            SetAnnotate(pLayout->GetAnnotate());
    }

	//
	// Determin the number of controls, removes the need for linked lists?
	//
	DeterminNumberOfControls();
	WalkControls();
    if( GetControlCount() == 0 )
        return;
	PlaceControls();

    // Supposedly done onlye once.
   	SpecialRowCol();
	DeterminWeights();

    if( m_pXML->IsVisible() )
    {
        //
        // CLupu says I can just GetWindowRect - GetClientRect to find out
        // how big the frame is. The SystemMetrics require me to know too much.
        //
	    HWND hDlg=GetWindow();
	    RECT frame;
	    RECT client;

	    GetWindowRect( hDlg, &frame);
	    GetClientRect( hDlg, &client);

	    ExpandIfClipped();
	    //
	    // Add the gripper
	    //
	    if( m_bUserCanResize )
	    {
		    AddGripper(); // need to sit on the size meesage too.
		    RECT r;
		    GetWindowRect( hDlg, &r);
		    SetWindowPos(
			    hDlg, NULL, 0,0, r.right - r.left, r.bottom - r.top, 
			    SWP_NOACTIVATE | SWP_NOCOPYBITS | SWP_NOMOVE | SWP_NOOWNERZORDER |
			    SWP_NOREDRAW | SWP_NOZORDER );
	    }

        m_FrameHorizPadding = frame.right - frame.left - client.right;
        m_FrameVertPadding  = frame.bottom - frame.top - client.bottom;

#ifdef _DEBUG3
        RECT r;
        r.left=0;
        r.right=m_pXML->GetWidth();
        r.bottom=m_pXML->GetHeight();
        r.top=0;
        MapDialogRect( GetWindow(), &r);
        DWORD dwBase = GetDialogBaseUnits( );
#endif
	    SetWindowPos( GetWindow(), NULL, 0,0, 
            m_InitialDialogSize.cx + m_FrameHorizPadding, 
            m_InitialDialogSize.cy + m_FrameVertPadding,
		    SWP_NOZORDER | SWP_NOMOVE | SWP_NOSENDCHANGING);    // let this size go through.
        TRACE(TEXT("Setting the dialog to (%d by %d)\n"), m_InitialDialogSize.cx + m_FrameHorizPadding, m_InitialDialogSize.cy + m_FrameVertPadding);
    }

    m_ParentInfo.Purge();
}

//
//
//
void CResizeDlg::AddGripper()
{
    //
    // Prevent the gripper being added if there isn't a resize frame here. WS_RESIZEFRAME
    // e.g. pages of a property sheet.
    //
    HWND hdlg=GetWindow();
    DWORD dwStyle = GetWindowLong( hdlg, GWL_STYLE );
    if( (dwStyle & WS_SIZEBOX ) != WS_SIZEBOX )
    {
        TRACE(TEXT("This dialog doesn't have a resize frame\n"));
        return;
    }

    //
    // 
    //
	int g_cxGrip = GetSystemMetrics( SM_CXVSCROLL );
	int g_cyGrip = GetSystemMetrics( SM_CYHSCROLL );
	RECT rc;
	GetClientRect( GetWindow(), &rc);
	m_hwndGripper = CreateWindow( TEXT("Scrollbar"),
                     NULL,
                     WS_VISIBLE | WS_CHILD | WS_CLIPSIBLINGS |
                       WS_CLIPCHILDREN | SBS_BOTTOMALIGN | SBS_SIZEGRIP |
                       SBS_SIZEBOXBOTTOMRIGHTALIGN,
                     rc.right - g_cxGrip,
                     rc.bottom - g_cyGrip,
                     g_cxGrip,
                     g_cyGrip,
                     GetWindow(),
                     (HMENU)-1,
                     (HINSTANCE)GetWindowLong( GetWindow(), GWL_HINSTANCE ) , // g_hinst,
                     NULL );
}

//
//
//
HDWP CResizeDlg::SetGripperPos(HDWP hdwp)
{
	if( m_hwndGripper == NULL )
		return hdwp;

	int g_cxGrip = GetSystemMetrics( SM_CXVSCROLL );
	int g_cyGrip = GetSystemMetrics( SM_CYHSCROLL );
	RECT rc;
	GetClientRect( GetWindow(), &rc);
	return DeferWindowPos( hdwp, m_hwndGripper, NULL,
             rc.right - g_cxGrip,
             rc.bottom - g_cyGrip,
             g_cxGrip,
             g_cyGrip,
				SWP_NOZORDER | SWP_NOSIZE );
}

void CResizeDlg::DeterminNumberOfControls()
{
    if( m_bDeterminNumberOfControls )
        return;
    m_bDeterminNumberOfControls = TRUE;

    IRCMLControlList & controls=m_pXML->GetChildren();
    m_ControlCount=controls.GetCount();

    TRACE(TEXT("There are %d controls\n"),m_ControlCount);
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Looks for the last row/col being full of buttons.
//
//////////////////////////////////////////////////////////////////////////////////////////
void CResizeDlg::SpecialRowCol()
{
	TRACE(TEXT("There are %d rows, and %d columns\n"), GetNumRows(), GetNumCols() );

	//
	// Walk the controls, find the row/col they are in.
	//
	BOOL bSpecialRow=TRUE;
	BOOL bSpecialCol=TRUE;
	int iNumRows=GetNumRows()-1;
	int iNumCols=GetNumCols()-1;

	//
	// It is a special row if all the heights are the same
	// it is a special col if all the widths are the same
	//
	int iRowHeight=0;
	int iColWidth=0;

	//
	// It's a row/col if there is more than one control there
	//
	int iRowCount=0;
	int iColCount=0;

	//
	// We remember the bounds of the rows/cols
	// left/right is the left of the left button, and the right of the right
	// top/bottom is the top of the topmost, and the bottom of the bottom most.
	//
	RECT	bounds;		// this is the 
	bounds.left=m_ParentInfo.GetWidth();
	bounds.right=0;
	bounds.top=m_ParentInfo.GetHeight();
	bounds.bottom=0;

    //
    // we walk the LayoutInformation to find special rows columns.
    //
    int i=0;
	CLayoutInfo  pC;
    IRCMLControlList & controls=m_pXML->GetChildren();
    IRCMLControl * pControl;
	while( pControl=controls.GetPointer(i++) )
	{
        CLayoutInfo & layout= GetResizeInformation( pControl );

		//
		// Column work (widths same)
		//
		if( bSpecialCol )
		{
			if( ((layout.GetCol() == iNumCols ) || (layout.GetCol() + layout.GetColW() > iNumCols) ))
			{
				if( iColWidth==0 )
					iColWidth=layout.GetWidth();
				if( layout.GetWidth() != iColWidth )
					bSpecialCol=FALSE;
				iColCount++;
			}

			//
			// If this item is wholy in this column
			//
			if( layout.GetCol() == iNumCols )
			{
				RECT r;
                pControl->get_Location(&r); // =layout.GetLocation();
				if( r.top < bounds.top )
					bounds.top = r.top;
				if( r.bottom > bounds.bottom )
					bounds.bottom = r.bottom;
			}
		}

		if( bSpecialRow )
		{
			if( (layout.GetRow() == iNumRows ) || (layout.GetRow() + layout.GetRowH() > iNumRows) )
			{
				if( iRowHeight==0 )
					iRowHeight=layout.GetHeight();
				if( layout.GetHeight() != iRowHeight )
					bSpecialRow=FALSE;
				iRowCount++;
			}

			//
			// If this item is wholy in this row
			//
			if( layout.GetRow() == iNumRows )
			{
				RECT r;
                pControl->get_Location(&r); // =layout.GetLocation();
				if( r.left < bounds.left )
					bounds.left = r.left;
				if( r.right > bounds.right )
					bounds.right = r.right;
			}
		}

		if( (bSpecialCol==FALSE) && ( bSpecialRow==FALSE ) )
			break;
	}

	m_SpecialRow.bSpecial = iRowCount>1?bSpecialRow:FALSE;
	m_SpecialCol.bSpecial = iColCount>1?bSpecialCol:FALSE;

	//
	// Check the row alignment.
	//
	if( m_SpecialRow.bSpecial )
	{
		int lGap = bounds.left - m_ParentInfo.GetLeftBorder();
		int rGap = m_ParentInfo.GetWidth() - m_ParentInfo.GetRightBorder() - bounds.right;
		TRACE(TEXT("Constraits on the special row are: left %d, right %d\n"),bounds.left, bounds.right );
		TRACE(TEXT("Parent info is: left %d, right %d\n"), m_ParentInfo.GetLeftBorder(), m_ParentInfo.GetWidth() - m_ParentInfo.GetRightBorder() );
		TRACE(TEXT("Gaps are: left %d, right %d\n"), lGap, rGap );
		int GapDiff = lGap - rGap;
		m_SpecialRow.bSpecial = TRUE;
		m_SpecialRow.iMin = bounds.left;
		m_SpecialRow.iMax = bounds.right;
		if( GapDiff < -10 ) 
		{
			TRACE(TEXT("Probably a left aligned thing\n"));
			m_SpecialRow.iAlignment = -1;
		}
		else
		if( GapDiff > 10 )
		{
			TRACE(TEXT(" Probably a right aligned thing\n"));
			m_SpecialRow.iAlignment = 1;
		}
		else
		{
			TRACE(TEXT(" Probably a centered thing\n"));
			m_SpecialRow.iAlignment = 0;
		}
		m_SpecialRow.iDiff=GapDiff;
	}

	//
	// Check the Col alignment.
	//
	if( m_SpecialCol.bSpecial  )
	{
		int tGap = bounds.top - m_ParentInfo.GetTopBorder();
		int bGap = m_ParentInfo.GetHeight() - m_ParentInfo.GetBottomBorder() - bounds.bottom;
		TRACE(TEXT("Constraits on the special Col are: top %d, bottom %d\n"),bounds.top, bounds.bottom);
		TRACE(TEXT("Parent info is: top %d, bottom %d\n"), m_ParentInfo.GetTopBorder(), m_ParentInfo.GetHeight() - m_ParentInfo.GetBottomBorder() );
		TRACE(TEXT("Gaps are: top %d, bottom %d\n"), tGap, bGap );
		int GapDiff = tGap - bGap;
		m_SpecialCol.iMin = bounds.top;
		m_SpecialCol.iMax = bounds.bottom;
		if( GapDiff < -10 ) 
		{
			TRACE(TEXT("Probably a left aligned thing\n"));
			m_SpecialCol.iAlignment = -1;
		}
		else
		if( GapDiff > 10 )
		{
			TRACE(TEXT(" Probably a right aligned thing\n"));
			m_SpecialCol.iAlignment = 1;
		}
		else
		{
			TRACE(TEXT(" Probably a centered thing\n"));
			m_SpecialCol.iAlignment = 0;
		}
		m_SpecialCol.iDiff=GapDiff;
	}
}

//
// Map the IRCMLControl to its layout information.
//
CLayoutInfo & CResizeDlg::GetResizeInformation( IRCMLControl * pControl )
{
    for(int i=0;i<m_ControlCount; i++)
    {
        if( m_ControlInfo[i].pControl    == pControl )
            return * m_ControlInfo[i].pLayoutInfo;
    }

    CLayoutInfo * pInfo=NULL;
    return *pInfo;    // hmm - you WILL fault.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\resizedlg.h ===
// ResizeDlg.h: interface for the CResizeDlg class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_RESIZEDLG_H__CBCB8815_7899_11D1_96A4_00C04FB177B1__INCLUDED_)
#define AFX_RESIZEDLG_H__CBCB8815_7899_11D1_96A4_00C04FB177B1__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "dlg.h"
#include "list.h"
#include "parentinfo.h"
#include "persctl.h"

//
// self referencing.
//
class CXMLDlg;

#undef PROPERTY
#define PROPERTY(type, Name) public: void Set##Name( type v) { m_##Name=v; } type Get##Name() const {return m_##Name; } private: type m_##Name; public:


class CResizeDlg // : public CDlg  // called by CWin32Dlg
{
	typedef CDlg BASECLASS;

    typedef struct tagCHANNEL
    {
	    int Pos;
	    int Size;
	    int iFixed;		// if we can't resize this column.
	    int iWeight;	// if we can, this is the weight.
    } CHANNEL, * PCHANNEL;


    typedef struct _tagSPECIAL
    {
	    BOOL	bSpecial;	// is this infact a special row / col
	    int		iMin;		// top or left of the data
	    int		iMax;		// right or bottom of the data
	    int		iAlignment;	// -1 left/top, 0 center, 1 right/bottom
	    int		iDiff;		// difference between iMin and iMax
    } SPECIAL, * PSPECIAL;

public:
	CResizeDlg(int DlgID, HWND hWndParent, HINSTANCE hInst);
	virtual ~CResizeDlg();

	virtual BOOL CALLBACK DlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
	PROPERTY( int, NumCols );
	PROPERTY( int, NumRows );
	PROPERTY( BOOL, Annotate);
	PROPERTY( int, RowWeight);
	PROPERTY( int, ColWeight);
	PROPERTY( int, ControlCount);
	void	DoInitDialog();

	void	SetXMLInfo( CXMLDlg * pXML ) { m_pXML=pXML; }
    SIZE    GetAdjustedSize();
    CParentInfo & GetParentInfo() { return m_ParentInfo; }
    HWND    GetWindow() { return m_hWnd; }
    void    SetWindow( HWND h ) { m_hWnd=h; }

protected:
	void    SpecialRowCol();
	void    DeterminNumberOfControls();
	virtual void	DoChangePos( WINDOWPOS * lpwp);
	int		FindCol(int pos);
	int		FindRow(int pos);
	void	PlaceControls();
	LONG	HitTest(LONG lCurrent);
	virtual void	DeterminWeights();
	void	Annotate();
	void	Sort( CEdge **, int iCount);
	void	WalkControls();
	virtual void	ResizeControls( WORD width, WORD height );
	CParentInfo	    m_ParentInfo;
	CXMLDlg *	    m_pXML;

	// void	MakeAttatchments();
	void	FindBorders();
	void	FindCommonGuides();
	void	DeterminCols( CEdge ** ppEdges, int iCount);
	void	DeterminRows( CEdge ** ppEdges, int iCount);

	CHANNEL	*	m_Rows;
	CHANNEL *	m_Cols;

	virtual void	AddGripper();
	virtual HDWP	SetGripperPos(HDWP hdwp);
	HWND	m_hwndGripper;

	SPECIAL	m_SpecialRow;
	SPECIAL	m_SpecialCol;

	void	LayoutControlsOnGrid(WORD width, WORD height, BOOL bClipped);
	void	ExpandIfClipped();
	SIZE	m_InitialDialogSize;

    struct {
        BOOL    m_bExpanded:1;
        BOOL    m_bInitedResizeData:1;
        BOOL    m_bDeterminedWeights:1;
        BOOL    m_bPlacedControls:1;
        BOOL    m_bDeterminNumberOfControls:1;
        BOOL    m_bWalkControls:1;
        BOOL    m_bMapXMLToHwnds:1;         // have we mapped the HWNDs of visible controls to XML versions.
        BOOL    m_bUserCanResize:1;         // can the user resize this dialogs.
        BOOL    m_bFoundXMLControls:1;      // walked the XML and build a list of controls.
        BOOL    m_bUserCanMakeWider:1;
        BOOL    m_bUserCanMakeTaller:1;
    };
    int m_FrameHorizPadding;    // how much to add to the client area to get the 
    int m_FrameVertPadding;     // window the right size (menu, caption, border etc).

    //
    // Information about the dialog we are resizing.
    //
    HWND    m_hWnd;

    CLayoutInfo & GetResizeInformation( IRCMLControl * pControl );
    typedef struct _CONTROL_INFO
    {
        IRCMLControl * pControl;
        CLayoutInfo  * pLayoutInfo;
    } CONTROL_INFO, * PCONTROL_INFO;
    PCONTROL_INFO m_ControlInfo;

private:

};

#undef PROPERTY
#endif // !defined(AFX_RESIZEDLG_H__CBCB8815_7899_11D1_96A4_00C04FB177B1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resources.rc
//
#define IDI_FILEICON                    101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	XML2RCDLL.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\shlwapi.h ===
/*****************************************************************************\
*                                                                             *
* shlwapi.h - Interface for the Windows light-weight utility APIs             *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* Copyright (c) 1991-1998, Microsoft Corp.      All rights reserved.          *
*                                                                             *
\*****************************************************************************/


#ifndef _INC_SHLWAPI
#define _INC_SHLWAPI

#ifndef NOSHLWAPI

#include <objbase.h>

#ifndef _WINRESRC_
#ifndef _WIN32_IE
#define _WIN32_IE 0x0501
#else
#if (_WIN32_IE < 0x0400) && defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0500)
#error _WIN32_IE setting conflicts with _WIN32_WINNT setting
#endif
#endif
#endif


#ifdef UNIX
typedef interface IInternetSecurityMgrSite IInternetSecurityMgrSite;
typedef interface IInternetSecurityManager IInternetSecurityManager;
typedef interface IInternetHostSecurityManager IInternetHostSecurityManager;
#endif

//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINSHLWAPI
#if !defined(_SHLWAPI_)
#define LWSTDAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define LWSTDAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#define LWSTDAPIV         EXTERN_C DECLSPEC_IMPORT HRESULT STDAPIVCALLTYPE
#define LWSTDAPIV_(type)  EXTERN_C DECLSPEC_IMPORT type STDAPIVCALLTYPE
#else
#define LWSTDAPI          STDAPI
#define LWSTDAPI_(type)   STDAPI_(type)
#define LWSTDAPIV         STDAPIV
#define LWSTDAPIV_(type)  STDAPIV_(type)
#endif
#endif // WINSHLWAPI

#ifdef _WIN32
#include <pshpack1.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Users of this header may define any number of these constants to avoid
// the definitions of each functional group.
//
//    NO_SHLWAPI_STRFCNS    String functions
//    NO_SHLWAPI_PATH       Path functions
//    NO_SHLWAPI_REG        Registry functions
//    NO_SHLWAPI_STREAM     Stream functions
//    NO_SHLWAPI_GDI        GDI helper functions

#ifndef NO_SHLWAPI_STRFCNS
//
//=============== String Routines ===================================
//

LWSTDAPI_(LPSTR)    StrChrA(LPCSTR lpStart, WORD wMatch);
LWSTDAPI_(LPWSTR)   StrChrW(LPCWSTR lpStart, WCHAR wMatch);
LWSTDAPI_(LPSTR)    StrChrIA(LPCSTR lpStart, WORD wMatch);
LWSTDAPI_(LPWSTR)   StrChrIW(LPCWSTR lpStart, WCHAR wMatch);
LWSTDAPI_(int)      StrCmpNA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar);
LWSTDAPI_(int)      StrCmpNW(LPCWSTR lpStr1, LPCWSTR lpStr2, int nChar);
LWSTDAPI_(int)      StrCmpNIA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar);
LWSTDAPI_(int)      StrCmpNIW(LPCWSTR lpStr1, LPCWSTR lpStr2, int nChar);
LWSTDAPI_(int)      StrCSpnA(LPCSTR lpStr, LPCSTR lpSet);
LWSTDAPI_(int)      StrCSpnW(LPCWSTR lpStr, LPCWSTR lpSet);
LWSTDAPI_(int)      StrCSpnIA(LPCSTR lpStr, LPCSTR lpSet);
LWSTDAPI_(int)      StrCSpnIW(LPCWSTR lpStr, LPCWSTR lpSet);
LWSTDAPI_(LPSTR)    StrDupA(LPCSTR lpSrch);
LWSTDAPI_(LPWSTR)   StrDupW(LPCWSTR lpSrch);
LWSTDAPI_(LPSTR)    StrFormatByteSizeA(DWORD dw, LPSTR szBuf, UINT uiBufSize);
LWSTDAPI_(LPSTR)    StrFormatByteSize64A(LONGLONG qdw, LPSTR szBuf, UINT uiBufSize);
LWSTDAPI_(LPWSTR)   StrFormatByteSizeW(LONGLONG qdw, LPWSTR szBuf, UINT uiBufSize);
LWSTDAPI_(LPWSTR)   StrFormatKBSizeW(LONGLONG qdw, LPWSTR szBuf, UINT uiBufSize);
LWSTDAPI_(LPSTR)    StrFormatKBSizeA(LONGLONG qdw, LPSTR szBuf, UINT uiBufSize);
LWSTDAPI_(int)      StrFromTimeIntervalA(LPSTR pszOut, UINT cchMax, DWORD dwTimeMS, int digits);
LWSTDAPI_(int)      StrFromTimeIntervalW(LPWSTR pszOut, UINT cchMax, DWORD dwTimeMS, int digits);
LWSTDAPI_(BOOL)     StrIsIntlEqualA(BOOL fCaseSens, LPCSTR lpString1, LPCSTR lpString2, int nChar);
LWSTDAPI_(BOOL)     StrIsIntlEqualW(BOOL fCaseSens, LPCWSTR lpString1, LPCWSTR lpString2, int nChar);
LWSTDAPI_(LPSTR)    StrNCatA(LPSTR psz1, LPCSTR psz2, int cchMax);
LWSTDAPI_(LPWSTR)   StrNCatW(LPWSTR psz1, LPCWSTR psz2, int cchMax);
LWSTDAPI_(LPSTR)    StrPBrkA(LPCSTR psz, LPCSTR pszSet);
LWSTDAPI_(LPWSTR)   StrPBrkW(LPCWSTR psz, LPCWSTR pszSet);
LWSTDAPI_(LPSTR)    StrRChrA(LPCSTR lpStart, LPCSTR lpEnd, WORD wMatch);
LWSTDAPI_(LPWSTR)   StrRChrW(LPCWSTR lpStart, LPCWSTR lpEnd, WCHAR wMatch);
LWSTDAPI_(LPSTR)    StrRChrIA(LPCSTR lpStart, LPCSTR lpEnd, WORD wMatch);
LWSTDAPI_(LPWSTR)   StrRChrIW(LPCWSTR lpStart, LPCWSTR lpEnd, WCHAR wMatch);
LWSTDAPI_(LPSTR)    StrRStrIA(LPCSTR lpSource, LPCSTR lpLast, LPCSTR lpSrch);
LWSTDAPI_(LPWSTR)   StrRStrIW(LPCWSTR lpSource, LPCWSTR lpLast, LPCWSTR lpSrch);
LWSTDAPI_(int)      StrSpnA(LPCSTR psz, LPCSTR pszSet);
LWSTDAPI_(int)      StrSpnW(LPCWSTR psz, LPCWSTR pszSet);
LWSTDAPI_(LPSTR)    StrStrA(LPCSTR lpFirst, LPCSTR lpSrch);
LWSTDAPI_(LPWSTR)   StrStrW(LPCWSTR lpFirst, LPCWSTR lpSrch);
LWSTDAPI_(LPSTR)    StrStrIA(LPCSTR lpFirst, LPCSTR lpSrch);
LWSTDAPI_(LPWSTR)   StrStrIW(LPCWSTR lpFirst, LPCWSTR lpSrch);
LWSTDAPI_(int)      StrToIntA(LPCSTR lpSrc);
LWSTDAPI_(int)      StrToIntW(LPCWSTR lpSrc);
LWSTDAPI_(BOOL)     StrToIntExA(LPCSTR pszString, DWORD dwFlags, int * piRet);
LWSTDAPI_(BOOL)     StrToIntExW(LPCWSTR pszString, DWORD dwFlags, int * piRet);
LWSTDAPI_(BOOL)     StrTrimA(LPSTR psz, LPCSTR pszTrimChars);
LWSTDAPI_(BOOL)     StrTrimW(LPWSTR psz, LPCWSTR pszTrimChars);

LWSTDAPI_(LPWSTR)   StrCatW(LPWSTR psz1, LPCWSTR psz2);
LWSTDAPI_(int)      StrCmpW(LPCWSTR psz1, LPCWSTR psz2);
LWSTDAPI_(int)      StrCmpIW(LPCWSTR psz1, LPCWSTR psz2);
LWSTDAPI_(LPWSTR)   StrCpyW(LPWSTR psz1, LPCWSTR psz2);
LWSTDAPI_(LPWSTR)   StrCpyNW(LPWSTR psz1, LPCWSTR psz2, int cchMax);

LWSTDAPI_(LPWSTR)   StrCatBuffW(LPWSTR pszDest, LPCWSTR pszSrc, int cchDestBuffSize);
LWSTDAPI_(LPSTR)    StrCatBuffA(LPSTR pszDest, LPCSTR pszSrc, int cchDestBuffSize);

LWSTDAPI_(BOOL)     ChrCmpIA(WORD w1, WORD w2);
LWSTDAPI_(BOOL)     ChrCmpIW(WCHAR w1, WCHAR w2);

LWSTDAPI_(int)      wvnsprintfA(LPSTR lpOut, int cchLimitIn, LPCSTR lpFmt, va_list arglist);
LWSTDAPI_(int)      wvnsprintfW(LPWSTR lpOut, int cchLimitIn, LPCWSTR lpFmt, va_list arglist);
LWSTDAPIV_(int)     wnsprintfA(LPSTR lpOut, int cchLimitIn, LPCSTR lpFmt, ...);
LWSTDAPIV_(int)     wnsprintfW(LPWSTR lpOut, int cchLimitIn, LPCWSTR lpFmt, ...);

#define StrIntlEqNA( s1, s2, nChar) StrIsIntlEqualA( TRUE, s1, s2, nChar)
#define StrIntlEqNW( s1, s2, nChar) StrIsIntlEqualW( TRUE, s1, s2, nChar)
#define StrIntlEqNIA(s1, s2, nChar) StrIsIntlEqualA(FALSE, s1, s2, nChar)
#define StrIntlEqNIW(s1, s2, nChar) StrIsIntlEqualW(FALSE, s1, s2, nChar)

LWSTDAPI StrRetToStrA(struct _STRRET *pstr, const UNALIGNED struct _ITEMIDLIST *pidl, LPSTR *ppsz);
LWSTDAPI StrRetToStrW(struct _STRRET *pstr, const UNALIGNED struct _ITEMIDLIST *pidl, LPWSTR *ppsz);
#ifdef UNICODE
#define StrRetToStr  StrRetToStrW
#else
#define StrRetToStr  StrRetToStrA
#endif // !UNICODE
LWSTDAPI StrRetToBufA(struct _STRRET *pstr, const UNALIGNED struct _ITEMIDLIST *pidl, LPSTR pszBuf, UINT cchBuf);
LWSTDAPI StrRetToBufW(struct _STRRET *pstr, const UNALIGNED struct _ITEMIDLIST *pidl, LPWSTR pszBuf, UINT cchBuf);
#ifdef UNICODE
#define StrRetToBuf  StrRetToBufW
#else
#define StrRetToBuf  StrRetToBufA
#endif // !UNICODE

// helper to duplicate a string using the task allocator

LWSTDAPI SHStrDupA(LPCSTR psz, WCHAR **ppwsz);
LWSTDAPI SHStrDupW(LPCWSTR psz, WCHAR **ppwsz);
#ifdef UNICODE
#define SHStrDup  SHStrDupW
#else
#define SHStrDup  SHStrDupA
#endif // !UNICODE



#ifdef UNICODE
#define StrChr                  StrChrW
#define StrRChr                 StrRChrW
#define StrChrI                 StrChrIW
#define StrRChrI                StrRChrIW
#define StrCmpN                 StrCmpNW
#define StrCmpNI                StrCmpNIW
#define StrStr                  StrStrW
#define StrStrI                 StrStrIW
#define StrDup                  StrDupW
#define StrRStrI                StrRStrIW
#define StrCSpn                 StrCSpnW
#define StrCSpnI                StrCSpnIW
#define StrSpn                  StrSpnW
#define StrToInt                StrToIntW
#define StrPBrk                 StrPBrkW
#define StrToIntEx              StrToIntExW
#define StrFromTimeInterval     StrFromTimeIntervalW
#define StrIntlEqN              StrIntlEqNW
#define StrIntlEqNI             StrIntlEqNIW
#define StrFormatByteSize       StrFormatByteSizeW
#define StrFormatByteSize64     StrFormatByteSizeW
#define StrFormatKBSize         StrFormatKBSizeW
#define StrNCat                 StrNCatW
#define StrTrim                 StrTrimW
#define StrCatBuff              StrCatBuffW
#define ChrCmpI                 ChrCmpIW
#define wvnsprintf              wvnsprintfW
#define wnsprintf               wnsprintfW
#define StrIsIntlEqual          StrIsIntlEqualW


#else
#define StrChr                  StrChrA
#define StrRChr                 StrRChrA
#define StrChrI                 StrChrIA
#define StrRChrI                StrRChrIA
#define StrCmpN                 StrCmpNA
#define StrCmpNI                StrCmpNIA
#define StrStr                  StrStrA
#define StrStrI                 StrStrIA
#define StrDup                  StrDupA
#define StrRStrI                StrRStrIA
#define StrCSpn                 StrCSpnA
#define StrCSpnI                StrCSpnIA
#define StrSpn                  StrSpnA
#define StrToInt                StrToIntA
#define StrPBrk                 StrPBrkA
#define StrToIntEx              StrToIntExA
#define StrFromTimeInterval     StrFromTimeIntervalA
#define StrIntlEqN              StrIntlEqNA
#define StrIntlEqNI             StrIntlEqNIA
#define StrFormatByteSize       StrFormatByteSizeA
#define StrFormatByteSize64     StrFormatByteSize64A
#define StrFormatKBSize         StrFormatKBSizeA
#define StrNCat                 StrNCatA
#define StrTrim                 StrTrimA
#define StrCatBuff              StrCatBuffA
#define ChrCmpI                 ChrCmpIA
#define wvnsprintf              wvnsprintfA
#define wnsprintf               wnsprintfA
#define StrIsIntlEqual          StrIsIntlEqualA
#endif


// Backward compatible to NT's non-standard naming (strictly
// for comctl32)
//
LWSTDAPI_(BOOL)     IntlStrEqWorkerA(BOOL fCaseSens, LPCSTR lpString1, LPCSTR lpString2, int nChar);
LWSTDAPI_(BOOL)     IntlStrEqWorkerW(BOOL fCaseSens, LPCWSTR lpString1, LPCWSTR lpString2, int nChar);

#define IntlStrEqNA( s1, s2, nChar) IntlStrEqWorkerA( TRUE, s1, s2, nChar)
#define IntlStrEqNW( s1, s2, nChar) IntlStrEqWorkerW( TRUE, s1, s2, nChar)
#define IntlStrEqNIA(s1, s2, nChar) IntlStrEqWorkerA(FALSE, s1, s2, nChar)
#define IntlStrEqNIW(s1, s2, nChar) IntlStrEqWorkerW(FALSE, s1, s2, nChar)

#ifdef UNICODE
#define IntlStrEqN              IntlStrEqNW
#define IntlStrEqNI             IntlStrEqNIW
#else
#define IntlStrEqN              IntlStrEqNA
#define IntlStrEqNI             IntlStrEqNIA
#endif

#define SZ_CONTENTTYPE_HTMLA       "text/html"
#define SZ_CONTENTTYPE_HTMLW       L"text/html"
#define SZ_CONTENTTYPE_CDFA        "application/x-cdf"
#define SZ_CONTENTTYPE_CDFW        L"application/x-cdf"

#ifdef UNICODE
#define SZ_CONTENTTYPE_HTML     SZ_CONTENTTYPE_HTMLW
#define SZ_CONTENTTYPE_CDF      SZ_CONTENTTYPE_CDFW
#else
#define SZ_CONTENTTYPE_HTML     SZ_CONTENTTYPE_HTMLA
#define SZ_CONTENTTYPE_CDF      SZ_CONTENTTYPE_CDFA
#endif

#define PathIsHTMLFileA(pszPath)     PathIsContentTypeA(pszPath, SZ_CONTENTTYPE_HTMLA)
#define PathIsHTMLFileW(pszPath)     PathIsContentTypeW(pszPath, SZ_CONTENTTYPE_HTMLW)

// Flags for StrToIntEx
#define STIF_DEFAULT        0x00000000L
#define STIF_SUPPORT_HEX    0x00000001L


#define StrCatA                 lstrcatA
#define StrCmpA                 lstrcmpA
#define StrCmpIA                lstrcmpiA
#define StrCpyA                 lstrcpyA
#define StrCpyNA                lstrcpynA


#define StrToLong               StrToInt
#define StrNCmp                 StrCmpN
#define StrNCmpI                StrCmpNI
#define StrNCpy                 StrCpyN
#define StrCatN                 StrNCat

#ifdef UNICODE
#define StrCat                  StrCatW
#define StrCmp                  StrCmpW
#define StrCmpI                 StrCmpIW
#define StrCpy                  StrCpyW
#define StrCpyN                 StrCpyNW
#define StrCatBuff              StrCatBuffW
#else
#define StrCat                  lstrcatA
#define StrCmp                  lstrcmpA
#define StrCmpI                 lstrcmpiA
#define StrCpy                  lstrcpyA
#define StrCpyN                 lstrcpynA
#define StrCatBuff              StrCatBuffA
#endif


#endif //  NO_SHLWAPI_STRFCNS


#ifndef NO_SHLWAPI_PATH

//
//=============== Path Routines ===================================
//

LWSTDAPI_(LPSTR)  PathAddBackslashA(LPSTR pszPath);
LWSTDAPI_(LPWSTR)  PathAddBackslashW(LPWSTR pszPath);
#ifdef UNICODE
#define PathAddBackslash  PathAddBackslashW
#else
#define PathAddBackslash  PathAddBackslashA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathAddExtensionA(LPSTR pszPath, LPCSTR pszExt);
LWSTDAPI_(BOOL)     PathAddExtensionW(LPWSTR pszPath, LPCWSTR pszExt);
#ifdef UNICODE
#define PathAddExtension  PathAddExtensionW
#else
#define PathAddExtension  PathAddExtensionA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathAppendA(LPSTR pszPath, LPCSTR pMore);
LWSTDAPI_(BOOL)     PathAppendW(LPWSTR pszPath, LPCWSTR pMore);
LWSTDAPI_(LPSTR)  PathBuildRootA(LPSTR pszRoot, int iDrive);
LWSTDAPI_(LPWSTR)  PathBuildRootW(LPWSTR pszRoot, int iDrive);
#ifdef UNICODE
#define PathBuildRoot  PathBuildRootW
#else
#define PathBuildRoot  PathBuildRootA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathCanonicalizeA(LPSTR pszBuf, LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathCanonicalizeW(LPWSTR pszBuf, LPCWSTR pszPath);
LWSTDAPI_(LPSTR)  PathCombineA(LPSTR pszDest, LPCSTR pszDir, LPCSTR pszFile);
LWSTDAPI_(LPWSTR)  PathCombineW(LPWSTR pszDest, LPCWSTR pszDir, LPCWSTR pszFile);
#ifdef UNICODE
#define PathCombine  PathCombineW
#else
#define PathCombine  PathCombineA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathCompactPathA(HDC hDC, LPSTR pszPath, UINT dx);
LWSTDAPI_(BOOL)     PathCompactPathW(HDC hDC, LPWSTR pszPath, UINT dx);
LWSTDAPI_(BOOL)     PathCompactPathExA(LPSTR pszOut, LPCSTR pszSrc, UINT cchMax, DWORD dwFlags);
LWSTDAPI_(BOOL)     PathCompactPathExW(LPWSTR pszOut, LPCWSTR pszSrc, UINT cchMax, DWORD dwFlags);
LWSTDAPI_(int)      PathCommonPrefixA(LPCSTR pszFile1, LPCSTR pszFile2, LPSTR achPath);
LWSTDAPI_(int)      PathCommonPrefixW(LPCWSTR pszFile1, LPCWSTR pszFile2, LPWSTR achPath);
LWSTDAPI_(BOOL)     PathFileExistsA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathFileExistsW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathFileExists  PathFileExistsW
#else
#define PathFileExists  PathFileExistsA
#endif // !UNICODE
LWSTDAPI_(LPSTR)  PathFindExtensionA(LPCSTR pszPath);
LWSTDAPI_(LPWSTR)  PathFindExtensionW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathFindExtension  PathFindExtensionW
#else
#define PathFindExtension  PathFindExtensionA
#endif // !UNICODE
LWSTDAPI_(LPSTR)  PathFindFileNameA(LPCSTR pszPath);
LWSTDAPI_(LPWSTR)  PathFindFileNameW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathFindFileName  PathFindFileNameW
#else
#define PathFindFileName  PathFindFileNameA
#endif // !UNICODE
LWSTDAPI_(LPSTR)  PathFindNextComponentA(LPCSTR pszPath);
LWSTDAPI_(LPWSTR)  PathFindNextComponentW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathFindNextComponent  PathFindNextComponentW
#else
#define PathFindNextComponent  PathFindNextComponentA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathFindOnPathA(LPSTR pszPath, LPCSTR * ppszOtherDirs);
LWSTDAPI_(BOOL)     PathFindOnPathW(LPWSTR pszPath, LPCWSTR * ppszOtherDirs);
LWSTDAPI_(LPSTR)  PathGetArgsA(LPCSTR pszPath);
LWSTDAPI_(LPWSTR)  PathGetArgsW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathGetArgs  PathGetArgsW
#else
#define PathGetArgs  PathGetArgsA
#endif // !UNICODE
LWSTDAPI_(LPCSTR) PathFindSuffixArrayA(LPCSTR pszPath, const LPCSTR *apszSuffix, int iArraySize);
LWSTDAPI_(LPCWSTR) PathFindSuffixArrayW(LPCWSTR pszPath, const LPCWSTR *apszSuffix, int iArraySize);
#ifdef UNICODE
#define PathFindSuffixArray  PathFindSuffixArrayW
#else
#define PathFindSuffixArray  PathFindSuffixArrayA
#endif // !UNICODE
STDAPI_(BOOL)       PathIsLFNFileSpecA(LPCSTR lpName);
STDAPI_(BOOL)       PathIsLFNFileSpecW(LPCWSTR lpName);
#ifdef UNICODE
#define PathIsLFNFileSpec  PathIsLFNFileSpecW
#else
#define PathIsLFNFileSpec  PathIsLFNFileSpecA
#endif // !UNICODE

LWSTDAPI_(UINT)     PathGetCharTypeA(UCHAR ch);
LWSTDAPI_(UINT)     PathGetCharTypeW(WCHAR ch);

// Return flags for PathGetCharType
#define GCT_INVALID             0x0000
#define GCT_LFNCHAR             0x0001
#define GCT_SHORTCHAR           0x0002
#define GCT_WILD                0x0004
#define GCT_SEPARATOR           0x0008

LWSTDAPI_(int)      PathGetDriveNumberA(LPCSTR pszPath);
LWSTDAPI_(int)      PathGetDriveNumberW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathGetDriveNumber  PathGetDriveNumberW
#else
#define PathGetDriveNumber  PathGetDriveNumberA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsDirectoryA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsDirectoryW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsDirectory  PathIsDirectoryW
#else
#define PathIsDirectory  PathIsDirectoryA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsDirectoryEmptyA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsDirectoryEmptyW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsDirectoryEmpty  PathIsDirectoryEmptyW
#else
#define PathIsDirectoryEmpty  PathIsDirectoryEmptyA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsFileSpecA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsFileSpecW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsFileSpec  PathIsFileSpecW
#else
#define PathIsFileSpec  PathIsFileSpecA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsPrefixA(LPCSTR pszPrefix, LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsPrefixW(LPCWSTR pszPrefix, LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsPrefix  PathIsPrefixW
#else
#define PathIsPrefix  PathIsPrefixA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsRelativeA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsRelativeW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsRelative  PathIsRelativeW
#else
#define PathIsRelative  PathIsRelativeA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsRootA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsRootW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsRoot  PathIsRootW
#else
#define PathIsRoot  PathIsRootA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsSameRootA(LPCSTR pszPath1, LPCSTR pszPath2);
LWSTDAPI_(BOOL)     PathIsSameRootW(LPCWSTR pszPath1, LPCWSTR pszPath2);
#ifdef UNICODE
#define PathIsSameRoot  PathIsSameRootW
#else
#define PathIsSameRoot  PathIsSameRootA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsUNCA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsUNCW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsUNC  PathIsUNCW
#else
#define PathIsUNC  PathIsUNCA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsNetworkPathA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsNetworkPathW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsNetworkPath  PathIsNetworkPathW
#else
#define PathIsNetworkPath  PathIsNetworkPathA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsUNCServerA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsUNCServerW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsUNCServer  PathIsUNCServerW
#else
#define PathIsUNCServer  PathIsUNCServerA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsUNCServerShareA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsUNCServerShareW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsUNCServerShare  PathIsUNCServerShareW
#else
#define PathIsUNCServerShare  PathIsUNCServerShareA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsContentTypeA(LPCSTR pszPath, LPCSTR pszContentType);
LWSTDAPI_(BOOL)     PathIsContentTypeW(LPCWSTR pszPath, LPCWSTR pszContentType);
LWSTDAPI_(BOOL)     PathIsURLA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsURLW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsURL  PathIsURLW
#else
#define PathIsURL  PathIsURLA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathMakePrettyA(LPSTR pszPath);
LWSTDAPI_(BOOL)     PathMakePrettyW(LPWSTR pszPath);
LWSTDAPI_(BOOL)     PathMatchSpecA(LPCSTR pszFile, LPCSTR pszSpec);
LWSTDAPI_(BOOL)     PathMatchSpecW(LPCWSTR pszFile, LPCWSTR pszSpec);
LWSTDAPI_(int)      PathParseIconLocationA(LPSTR pszIconFile);
LWSTDAPI_(int)      PathParseIconLocationW(LPWSTR pszIconFile);
LWSTDAPI_(void)     PathQuoteSpacesA(LPSTR lpsz);
LWSTDAPI_(void)     PathQuoteSpacesW(LPWSTR lpsz);
LWSTDAPI_(BOOL)     PathRelativePathToA(LPSTR pszPath, LPCSTR pszFrom, DWORD dwAttrFrom, LPCSTR pszTo, DWORD dwAttrTo);
LWSTDAPI_(BOOL)     PathRelativePathToW(LPWSTR pszPath, LPCWSTR pszFrom, DWORD dwAttrFrom, LPCWSTR pszTo, DWORD dwAttrTo);
LWSTDAPI_(void)     PathRemoveArgsA(LPSTR pszPath);
LWSTDAPI_(void)     PathRemoveArgsW(LPWSTR pszPath);
LWSTDAPI_(LPSTR)  PathRemoveBackslashA(LPSTR pszPath);
LWSTDAPI_(LPWSTR)  PathRemoveBackslashW(LPWSTR pszPath);
#ifdef UNICODE
#define PathRemoveBackslash  PathRemoveBackslashW
#else
#define PathRemoveBackslash  PathRemoveBackslashA
#endif // !UNICODE
LWSTDAPI_(void)     PathRemoveBlanksA(LPSTR pszPath);
LWSTDAPI_(void)     PathRemoveBlanksW(LPWSTR pszPath);
LWSTDAPI_(void)     PathRemoveExtensionA(LPSTR pszPath);
LWSTDAPI_(void)     PathRemoveExtensionW(LPWSTR pszPath);
LWSTDAPI_(BOOL)     PathRemoveFileSpecA(LPSTR pszPath);
LWSTDAPI_(BOOL)     PathRemoveFileSpecW(LPWSTR pszPath);
LWSTDAPI_(BOOL)     PathRenameExtensionA(LPSTR pszPath, LPCSTR pszExt);
LWSTDAPI_(BOOL)     PathRenameExtensionW(LPWSTR pszPath, LPCWSTR pszExt);
LWSTDAPI_(BOOL)     PathSearchAndQualifyA(LPCSTR pszPath, LPSTR pszBuf, UINT cchBuf);
LWSTDAPI_(BOOL)     PathSearchAndQualifyW(LPCWSTR pszPath, LPWSTR pszBuf, UINT cchBuf);
LWSTDAPI_(void)     PathSetDlgItemPathA(HWND hDlg, int id, LPCSTR pszPath);
LWSTDAPI_(void)     PathSetDlgItemPathW(HWND hDlg, int id, LPCWSTR pszPath);
LWSTDAPI_(LPSTR)  PathSkipRootA(LPCSTR pszPath);
LWSTDAPI_(LPWSTR)  PathSkipRootW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathSkipRoot  PathSkipRootW
#else
#define PathSkipRoot  PathSkipRootA
#endif // !UNICODE
LWSTDAPI_(void)     PathStripPathA(LPSTR pszPath);
LWSTDAPI_(void)     PathStripPathW(LPWSTR pszPath);
#ifdef UNICODE
#define PathStripPath  PathStripPathW
#else
#define PathStripPath  PathStripPathA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathStripToRootA(LPSTR pszPath);
LWSTDAPI_(BOOL)     PathStripToRootW(LPWSTR pszPath);
#ifdef UNICODE
#define PathStripToRoot  PathStripToRootW
#else
#define PathStripToRoot  PathStripToRootA
#endif // !UNICODE
LWSTDAPI_(void)     PathUnquoteSpacesA(LPSTR lpsz);
LWSTDAPI_(void)     PathUnquoteSpacesW(LPWSTR lpsz);
LWSTDAPI_(BOOL)     PathMakeSystemFolderA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathMakeSystemFolderW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathMakeSystemFolder  PathMakeSystemFolderW
#else
#define PathMakeSystemFolder  PathMakeSystemFolderA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathUnmakeSystemFolderA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathUnmakeSystemFolderW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathUnmakeSystemFolder  PathUnmakeSystemFolderW
#else
#define PathUnmakeSystemFolder  PathUnmakeSystemFolderA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsSystemFolderA(LPCSTR pszPath, DWORD dwAttrb);
LWSTDAPI_(BOOL)     PathIsSystemFolderW(LPCWSTR pszPath, DWORD dwAttrb);
#ifdef UNICODE
#define PathIsSystemFolder  PathIsSystemFolderW
#else
#define PathIsSystemFolder  PathIsSystemFolderA
#endif // !UNICODE
LWSTDAPI_(void)     PathUndecorateA(LPSTR pszPath);
LWSTDAPI_(void)     PathUndecorateW(LPWSTR pszPath);
#ifdef UNICODE
#define PathUndecorate  PathUndecorateW
#else
#define PathUndecorate  PathUndecorateA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathUnExpandEnvStringsA(LPCSTR pszPath, LPSTR pszBuf, UINT cchBuf);
LWSTDAPI_(BOOL)     PathUnExpandEnvStringsW(LPCWSTR pszPath, LPWSTR pszBuf, UINT cchBuf);
#ifdef UNICODE
#define PathUnExpandEnvStrings  PathUnExpandEnvStringsW
#else
#define PathUnExpandEnvStrings  PathUnExpandEnvStringsA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathUnExpandEnvStringsForUserA(HANDLE hToken, LPCSTR pszPath, LPSTR pszBuf, UINT cchBuf);
LWSTDAPI_(BOOL)     PathUnExpandEnvStringsForUserW(HANDLE hToken, LPCWSTR pszPath, LPWSTR pszBuf, UINT cchBuf);
#ifdef UNICODE
#define PathUnExpandEnvStringsForUser  PathUnExpandEnvStringsForUserW
#else
#define PathUnExpandEnvStringsForUser  PathUnExpandEnvStringsForUserA
#endif // !UNICODE

#ifdef UNICODE
#define PathAppend              PathAppendW
#define PathCanonicalize        PathCanonicalizeW
#define PathCompactPath         PathCompactPathW
#define PathCompactPathEx       PathCompactPathExW
#define PathCommonPrefix        PathCommonPrefixW
#define PathFindOnPath          PathFindOnPathW
#define PathGetCharType         PathGetCharTypeW
#define PathIsContentType       PathIsContentTypeW
#define PathIsHTMLFile          PathIsHTMLFileW
#define PathMakePretty          PathMakePrettyW
#define PathMatchSpec           PathMatchSpecW
#define PathParseIconLocation   PathParseIconLocationW
#define PathQuoteSpaces         PathQuoteSpacesW
#define PathRelativePathTo      PathRelativePathToW
#define PathRemoveArgs          PathRemoveArgsW
#define PathRemoveBlanks        PathRemoveBlanksW
#define PathRemoveExtension     PathRemoveExtensionW
#define PathRemoveFileSpec      PathRemoveFileSpecW
#define PathRenameExtension     PathRenameExtensionW
#define PathSearchAndQualify    PathSearchAndQualifyW
#define PathSetDlgItemPath      PathSetDlgItemPathW
#define PathUnquoteSpaces       PathUnquoteSpacesW
#else
#define PathAppend              PathAppendA
#define PathCanonicalize        PathCanonicalizeA
#define PathCompactPath         PathCompactPathA
#define PathCompactPathEx       PathCompactPathExA
#define PathCommonPrefix        PathCommonPrefixA
#define PathFindOnPath          PathFindOnPathA
#define PathGetCharType         PathGetCharTypeA
#define PathIsContentType       PathIsContentTypeA
#define PathIsHTMLFile          PathIsHTMLFileA
#define PathMakePretty          PathMakePrettyA
#define PathMatchSpec           PathMatchSpecA
#define PathParseIconLocation   PathParseIconLocationA
#define PathQuoteSpaces         PathQuoteSpacesA
#define PathRelativePathTo      PathRelativePathToA
#define PathRemoveArgs          PathRemoveArgsA
#define PathRemoveBlanks        PathRemoveBlanksA
#define PathRemoveExtension     PathRemoveExtensionA
#define PathRemoveFileSpec      PathRemoveFileSpecA
#define PathRenameExtension     PathRenameExtensionA
#define PathSearchAndQualify    PathSearchAndQualifyA
#define PathSetDlgItemPath      PathSetDlgItemPathA
#define PathUnquoteSpaces       PathUnquoteSpacesA
#endif

typedef enum {
    URL_SCHEME_INVALID     = -1,
    URL_SCHEME_UNKNOWN     =  0,
    URL_SCHEME_FTP,
    URL_SCHEME_HTTP,
    URL_SCHEME_GOPHER,
    URL_SCHEME_MAILTO,
    URL_SCHEME_NEWS,
    URL_SCHEME_NNTP,
    URL_SCHEME_TELNET,
    URL_SCHEME_WAIS,
    URL_SCHEME_FILE,
    URL_SCHEME_MK,
    URL_SCHEME_HTTPS,
    URL_SCHEME_SHELL,
    URL_SCHEME_SNEWS,
    URL_SCHEME_LOCAL,
    URL_SCHEME_JAVASCRIPT,
    URL_SCHEME_VBSCRIPT,
    URL_SCHEME_ABOUT,
    URL_SCHEME_RES,
    URL_SCHEME_MAXVALUE
} URL_SCHEME;

typedef enum {
    URL_PART_NONE       = 0,
    URL_PART_SCHEME     = 1,
    URL_PART_HOSTNAME,
    URL_PART_USERNAME,
    URL_PART_PASSWORD,
    URL_PART_PORT,
    URL_PART_QUERY,
} URL_PART;

typedef enum {
    URLIS_URL,
    URLIS_OPAQUE,
    URLIS_NOHISTORY,
    URLIS_FILEURL,
    URLIS_APPLIABLE,
    URLIS_DIRECTORY,
    URLIS_HASQUERY,
} URLIS;

#define URL_UNESCAPE                    0x10000000
#define URL_ESCAPE_UNSAFE               0x20000000
#define URL_PLUGGABLE_PROTOCOL          0x40000000
#define URL_WININET_COMPATIBILITY       0x80000000
#define URL_DONT_ESCAPE_EXTRA_INFO      0x02000000
#define URL_DONT_UNESCAPE_EXTRA_INFO    URL_DONT_ESCAPE_EXTRA_INFO
#define URL_BROWSER_MODE                URL_DONT_ESCAPE_EXTRA_INFO
#define URL_ESCAPE_SPACES_ONLY          0x04000000
#define URL_DONT_SIMPLIFY               0x08000000
#define URL_NO_META                     URL_DONT_SIMPLIFY
#define URL_UNESCAPE_INPLACE            0x00100000
#define URL_CONVERT_IF_DOSPATH          0x00200000
#define URL_UNESCAPE_HIGH_ANSI_ONLY     0x00400000
#define URL_INTERNAL_PATH               0x00800000  // Will escape #'s in paths
#define URL_FILE_USE_PATHURL            0x00010000
#define URL_ESCAPE_PERCENT              0x00001000
#define URL_ESCAPE_SEGMENT_ONLY         0x00002000  // Treat the entire URL param as one URL segment.

#define URL_PARTFLAG_KEEPSCHEME         0x00000001

#define URL_APPLY_DEFAULT               0x00000001
#define URL_APPLY_GUESSSCHEME           0x00000002
#define URL_APPLY_GUESSFILE             0x00000004
#define URL_APPLY_FORCEAPPLY            0x00000008


LWSTDAPI_(int)          UrlCompareA(LPCSTR psz1, LPCSTR psz2, BOOL fIgnoreSlash);
LWSTDAPI_(int)          UrlCompareW(LPCWSTR psz1, LPCWSTR psz2, BOOL fIgnoreSlash);
LWSTDAPI                UrlCombineA(LPCSTR pszBase, LPCSTR pszRelative, LPSTR pszCombined, LPDWORD pcchCombined, DWORD dwFlags);
LWSTDAPI                UrlCombineW(LPCWSTR pszBase, LPCWSTR pszRelative, LPWSTR pszCombined, LPDWORD pcchCombined, DWORD dwFlags);
LWSTDAPI                UrlCanonicalizeA(LPCSTR pszUrl, LPSTR pszCanonicalized, LPDWORD pcchCanonicalized, DWORD dwFlags);
LWSTDAPI                UrlCanonicalizeW(LPCWSTR pszUrl, LPWSTR pszCanonicalized, LPDWORD pcchCanonicalized, DWORD dwFlags);
LWSTDAPI_(BOOL)         UrlIsOpaqueA(LPCSTR pszURL);
LWSTDAPI_(BOOL)         UrlIsOpaqueW(LPCWSTR pszURL);
LWSTDAPI_(BOOL)         UrlIsNoHistoryA(LPCSTR pszURL);
LWSTDAPI_(BOOL)         UrlIsNoHistoryW(LPCWSTR pszURL);
#define                 UrlIsFileUrlA(pszURL) UrlIsA(pszURL, URLIS_FILEURL)
#define                 UrlIsFileUrlW(pszURL) UrlIsW(pszURL, URLIS_FILEURL)
LWSTDAPI_(BOOL)         UrlIsA(LPCSTR pszUrl, URLIS UrlIs);
LWSTDAPI_(BOOL)         UrlIsW(LPCWSTR pszUrl, URLIS UrlIs);
LWSTDAPI_(LPCSTR)       UrlGetLocationA(LPCSTR psz1);
LWSTDAPI_(LPCWSTR)      UrlGetLocationW(LPCWSTR psz1);
LWSTDAPI                UrlUnescapeA(LPSTR pszUrl, LPSTR pszUnescaped, LPDWORD pcchUnescaped, DWORD dwFlags);
LWSTDAPI                UrlUnescapeW(LPWSTR pszUrl, LPWSTR pszUnescaped, LPDWORD pcchUnescaped, DWORD dwFlags);
LWSTDAPI                UrlEscapeA(LPCSTR pszUrl, LPSTR pszEscaped, LPDWORD pcchEscaped, DWORD dwFlags);
LWSTDAPI                UrlEscapeW(LPCWSTR pszUrl, LPWSTR pszEscaped, LPDWORD pcchEscaped, DWORD dwFlags);
LWSTDAPI                UrlCreateFromPathA(LPCSTR pszPath, LPSTR pszUrl, LPDWORD pcchUrl, DWORD dwFlags);
LWSTDAPI                UrlCreateFromPathW(LPCWSTR pszPath, LPWSTR pszUrl, LPDWORD pcchUrl, DWORD dwFlags);
LWSTDAPI                PathCreateFromUrlA(LPCSTR pszUrl, LPSTR pszPath, LPDWORD pcchPath, DWORD dwFlags);
LWSTDAPI                PathCreateFromUrlW(LPCWSTR pszUrl, LPWSTR pszPath, LPDWORD pcchPath, DWORD dwFlags);
LWSTDAPI                UrlHashA(LPCSTR pszUrl, LPBYTE pbHash, DWORD cbHash);
LWSTDAPI                UrlHashW(LPCWSTR pszUrl, LPBYTE pbHash, DWORD cbHash);
LWSTDAPI                UrlGetPartW(LPCWSTR pszIn, LPWSTR pszOut, LPDWORD pcchOut, DWORD dwPart, DWORD dwFlags);
LWSTDAPI                UrlGetPartA(LPCSTR pszIn, LPSTR pszOut, LPDWORD pcchOut, DWORD dwPart, DWORD dwFlags);
LWSTDAPI                UrlApplySchemeA(LPCSTR pszIn, LPSTR pszOut, LPDWORD pcchOut, DWORD dwFlags);
LWSTDAPI                UrlApplySchemeW(LPCWSTR pszIn, LPWSTR pszOut, LPDWORD pcchOut, DWORD dwFlags);
LWSTDAPI                HashData(LPBYTE pbData, DWORD cbData, LPBYTE pbHash, DWORD cbHash);



#ifdef UNICODE
#define UrlCompare              UrlCompareW
#define UrlCombine              UrlCombineW
#define UrlCanonicalize         UrlCanonicalizeW
#define UrlIsOpaque             UrlIsOpaqueW
#define UrlIsFileUrl            UrlIsFileUrlW
#define UrlGetLocation          UrlGetLocationW
#define UrlUnescape             UrlUnescapeW
#define UrlEscape               UrlEscapeW
#define UrlCreateFromPath       UrlCreateFromPathW
#define PathCreateFromUrl       PathCreateFromUrlW
#define UrlHash                 UrlHashW
#define UrlGetPart              UrlGetPartW
#define UrlApplyScheme          UrlApplySchemeW
#define UrlIs                   UrlIsW


#else //!UNICODE
#define UrlCompare              UrlCompareA
#define UrlCombine              UrlCombineA
#define UrlCanonicalize         UrlCanonicalizeA
#define UrlIsOpaque             UrlIsOpaqueA
#define UrlIsFileUrl            UrlIsFileUrlA
#define UrlGetLocation          UrlGetLocationA
#define UrlUnescape             UrlUnescapeA
#define UrlEscape               UrlEscapeA
#define UrlCreateFromPath       UrlCreateFromPathA
#define PathCreateFromUrl       PathCreateFromUrlA
#define UrlHash                 UrlHashA
#define UrlGetPart              UrlGetPartA
#define UrlApplyScheme          UrlApplySchemeA
#define UrlIs                   UrlIsA


#endif //UNICODE

#define UrlEscapeSpaces(pszUrl, pszEscaped, pcchEscaped)        UrlCanonicalize(pszUrl, pszEscaped, pcchEscaped, URL_ESCAPE_SPACES_ONLY |URL_DONT_ESCAPE_EXTRA_INFO )
#define UrlUnescapeInPlace(pszUrl, dwFlags)                     UrlUnescape(pszUrl, NULL, NULL, dwFlags | URL_UNESCAPE_INPLACE)



#endif //  NO_SHLWAPI_PATH



#ifndef NO_SHLWAPI_REG
//
//=============== Registry Routines ===================================
//

// SHDeleteEmptyKey mimics RegDeleteKey as it behaves on NT.
// SHDeleteKey mimics RegDeleteKey as it behaves on Win95.

LWSTDAPI_(DWORD)    SHDeleteEmptyKeyA(HKEY hkey, LPCSTR pszSubKey);
LWSTDAPI_(DWORD)    SHDeleteEmptyKeyW(HKEY hkey, LPCWSTR pszSubKey);
#ifdef UNICODE
#define SHDeleteEmptyKey  SHDeleteEmptyKeyW
#else
#define SHDeleteEmptyKey  SHDeleteEmptyKeyA
#endif // !UNICODE
LWSTDAPI_(DWORD)    SHDeleteKeyA(HKEY hkey, LPCSTR pszSubKey);
LWSTDAPI_(DWORD)    SHDeleteKeyW(HKEY hkey, LPCWSTR pszSubKey);
#ifdef UNICODE
#define SHDeleteKey  SHDeleteKeyW
#else
#define SHDeleteKey  SHDeleteKeyA
#endif // !UNICODE
LWSTDAPI_(HKEY)     SHRegDuplicateHKey(HKEY hkey);


// These functions open the key, get/set/delete the value, then close
// the key.

LWSTDAPI_(DWORD)    SHDeleteValueA(HKEY hkey, LPCSTR pszSubKey, LPCSTR pszValue);
LWSTDAPI_(DWORD)    SHDeleteValueW(HKEY hkey, LPCWSTR pszSubKey, LPCWSTR pszValue);
#ifdef UNICODE
#define SHDeleteValue  SHDeleteValueW
#else
#define SHDeleteValue  SHDeleteValueA
#endif // !UNICODE
LWSTDAPI_(DWORD)    SHGetValueA(HKEY hkey, LPCSTR pszSubKey, LPCSTR pszValue, DWORD *pdwType, void *pvData, DWORD *pcbData);
LWSTDAPI_(DWORD)    SHGetValueW(HKEY hkey, LPCWSTR pszSubKey, LPCWSTR pszValue, DWORD *pdwType, void *pvData, DWORD *pcbData);
#ifdef UNICODE
#define SHGetValue  SHGetValueW
#else
#define SHGetValue  SHGetValueA
#endif // !UNICODE
LWSTDAPI_(DWORD)    SHSetValueA(HKEY hkey, LPCSTR pszSubKey, LPCSTR pszValue, DWORD dwType, LPCVOID pvData, DWORD cbData);
LWSTDAPI_(DWORD)    SHSetValueW(HKEY hkey, LPCWSTR pszSubKey, LPCWSTR pszValue, DWORD dwType, LPCVOID pvData, DWORD cbData);
#ifdef UNICODE
#define SHSetValue  SHSetValueW
#else
#define SHSetValue  SHSetValueA
#endif // !UNICODE

// These functions work just like RegQueryValueEx, except if the
// data type is REG_EXPAND_SZ, then these will go ahead and expand
// out the string.  *pdwType will always be massaged to REG_SZ
// if this happens.  REG_SZ values are also guaranteed to be null
// terminated.

LWSTDAPI_(DWORD)    SHQueryValueExA(HKEY hkey, LPCSTR pszValue, DWORD *pdwReserved, DWORD *pdwType, void *pvData, DWORD *pcbData);
LWSTDAPI_(DWORD)    SHQueryValueExW(HKEY hkey, LPCWSTR pszValue, DWORD *pdwReserved, DWORD *pdwType, void *pvData, DWORD *pcbData);
#ifdef UNICODE
#define SHQueryValueEx  SHQueryValueExW
#else
#define SHQueryValueEx  SHQueryValueExA
#endif // !UNICODE

// Enumeration functions support.

LWSTDAPI_(LONG)     SHEnumKeyExA(HKEY hkey, DWORD dwIndex, LPSTR pszName, LPDWORD pcchName);
LWSTDAPI_(LONG)     SHEnumKeyExW(HKEY hkey, DWORD dwIndex, LPWSTR pszName, LPDWORD pcchName);
LWSTDAPI_(LONG)     SHEnumValueA(HKEY hkey, DWORD dwIndex, LPSTR pszValueName, LPDWORD pcchValueName, LPDWORD pdwType, void *pvData, LPDWORD pcbData);
LWSTDAPI_(LONG)     SHEnumValueW(HKEY hkey, DWORD dwIndex, LPWSTR pszValueName, LPDWORD pcchValueName, LPDWORD pdwType, void *pvData, LPDWORD pcbData);
LWSTDAPI_(LONG)     SHQueryInfoKeyA(HKEY hkey, LPDWORD pcSubKeys, LPDWORD pcchMaxSubKeyLen, LPDWORD pcValues, LPDWORD pcchMaxValueNameLen);
LWSTDAPI_(LONG)     SHQueryInfoKeyW(HKEY hkey, LPDWORD pcSubKeys, LPDWORD pcchMaxSubKeyLen, LPDWORD pcValues, LPDWORD pcchMaxValueNameLen);

// recursive key copy
LWSTDAPI_(DWORD)     SHCopyKeyA(HKEY hkeySrc, LPCSTR   szSrcSubKey, HKEY hkeyDest, DWORD fReserved);
LWSTDAPI_(DWORD)     SHCopyKeyW(HKEY hkeySrc, LPCWSTR wszSrcSubKey, HKEY hkeyDest, DWORD fReserved);

// Getting and setting file system paths with environment variables

LWSTDAPI_(DWORD)    SHRegGetPathA(HKEY hKey, LPCSTR pcszSubKey, LPCSTR pcszValue, LPSTR pszPath, DWORD dwFlags);
LWSTDAPI_(DWORD)    SHRegGetPathW(HKEY hKey, LPCWSTR pcszSubKey, LPCWSTR pcszValue, LPWSTR pszPath, DWORD dwFlags);
LWSTDAPI_(DWORD)    SHRegSetPathA(HKEY hKey, LPCSTR pcszSubKey, LPCSTR pcszValue, LPCSTR pcszPath, DWORD dwFlags);
LWSTDAPI_(DWORD)    SHRegSetPathW(HKEY hKey, LPCWSTR pcszSubKey, LPCWSTR pcszValue, LPCWSTR pcszPath, DWORD dwFlags);

#ifdef UNICODE
#define SHEnumKeyEx           SHEnumKeyExW
#define SHEnumValue           SHEnumValueW
#define SHQueryInfoKey        SHQueryInfoKeyW
#define SHCopyKey             SHCopyKeyW
#define SHRegGetPath          SHRegGetPathW
#define SHRegSetPath          SHRegSetPathW
#else
#define SHEnumKeyEx           SHEnumKeyExA
#define SHEnumValue           SHEnumValueA
#define SHQueryInfoKey        SHQueryInfoKeyA
#define SHCopyKey             SHCopyKeyA
#define SHRegGetPath          SHRegGetPathA
#define SHRegSetPath          SHRegSetPathA
#endif


//////////////////////////////////////////////
// User Specific Registry Access Functions
//////////////////////////////////////////////

//
// Type definitions.
//

typedef enum
{
    SHREGDEL_DEFAULT = 0x00000000,       // Delete's HKCU, or HKLM if HKCU is not found.
    SHREGDEL_HKCU    = 0x00000001,       // Delete HKCU only
    SHREGDEL_HKLM    = 0x00000010,       // Delete HKLM only.
    SHREGDEL_BOTH    = 0x00000011,       // Delete both HKCU and HKLM.
} SHREGDEL_FLAGS;

typedef enum
{
    SHREGENUM_DEFAULT = 0x00000000,       // Enumerates HKCU or HKLM if not found.
    SHREGENUM_HKCU    = 0x00000001,       // Enumerates HKCU only
    SHREGENUM_HKLM    = 0x00000010,       // Enumerates HKLM only.
    SHREGENUM_BOTH    = 0x00000011,       // Enumerates both HKCU and HKLM without duplicates.
                                          // This option is NYI.
} SHREGENUM_FLAGS;

#define     SHREGSET_HKCU           0x00000001       // Write to HKCU if empty.
#define     SHREGSET_FORCE_HKCU     0x00000002       // Write to HKCU.
#define     SHREGSET_HKLM           0x00000004       // Write to HKLM if empty.
#define     SHREGSET_FORCE_HKLM     0x00000008       // Write to HKLM.
#define     SHREGSET_DEFAULT        (SHREGSET_FORCE_HKCU | SHREGSET_HKLM)          // Default is SHREGSET_FORCE_HKCU | SHREGSET_HKLM.

typedef HANDLE HUSKEY;  // HUSKEY is a Handle to a User Specific KEY.
typedef HUSKEY *PHUSKEY;

LWSTDAPI_(LONG)        SHRegCreateUSKeyA(LPCSTR pszPath, REGSAM samDesired, HUSKEY hRelativeUSKey, PHUSKEY phNewUSKey, DWORD dwFlags);
LWSTDAPI_(LONG)        SHRegCreateUSKeyW(LPCWSTR pwzPath, REGSAM samDesired, HUSKEY hRelativeUSKey, PHUSKEY phNewUSKey, DWORD dwFlags);
LWSTDAPI_(LONG)        SHRegOpenUSKeyA(LPCSTR pszPath, REGSAM samDesired, HUSKEY hRelativeUSKey, PHUSKEY phNewUSKey, BOOL fIgnoreHKCU);
LWSTDAPI_(LONG)        SHRegOpenUSKeyW(LPCWSTR pwzPath, REGSAM samDesired, HUSKEY hRelativeUSKey, PHUSKEY phNewUSKey, BOOL fIgnoreHKCU);
LWSTDAPI_(LONG)        SHRegQueryUSValueA(HUSKEY hUSKey, LPCSTR pszValue, LPDWORD pdwType, void *pvData, LPDWORD pcbData, BOOL fIgnoreHKCU, void *pvDefaultData, DWORD dwDefaultDataSize);
LWSTDAPI_(LONG)        SHRegQueryUSValueW(HUSKEY hUSKey, LPCWSTR pwzValue, LPDWORD pdwType, void *pvData, LPDWORD pcbData, BOOL fIgnoreHKCU, void *pvDefaultData, DWORD dwDefaultDataSize);
LWSTDAPI_(LONG)        SHRegWriteUSValueA(HUSKEY hUSKey, LPCSTR pszValue, DWORD dwType, const void *pvData, DWORD cbData, DWORD dwFlags);
LWSTDAPI_(LONG)        SHRegWriteUSValueW(HUSKEY hUSKey, LPCWSTR pwzValue, DWORD dwType, const void *pvData, DWORD cbData, DWORD dwFlags);
LWSTDAPI_(LONG)        SHRegDeleteUSValueA(HUSKEY hUSKey, LPCSTR pszValue, SHREGDEL_FLAGS delRegFlags);
LWSTDAPI_(LONG)        SHRegDeleteEmptyUSKeyW(HUSKEY hUSKey, LPCWSTR pwzSubKey, SHREGDEL_FLAGS delRegFlags);
LWSTDAPI_(LONG)        SHRegDeleteEmptyUSKeyA(HUSKEY hUSKey, LPCSTR pszSubKey, SHREGDEL_FLAGS delRegFlags);
LWSTDAPI_(LONG)        SHRegDeleteUSValueW(HUSKEY hUSKey, LPCWSTR pwzValue, SHREGDEL_FLAGS delRegFlags);
LWSTDAPI_(LONG)        SHRegEnumUSKeyA(HUSKEY hUSKey, DWORD dwIndex, LPSTR pszName, LPDWORD pcchName, SHREGENUM_FLAGS enumRegFlags);
LWSTDAPI_(LONG)        SHRegEnumUSKeyW(HUSKEY hUSKey, DWORD dwIndex, LPWSTR pwzName, LPDWORD pcchName, SHREGENUM_FLAGS enumRegFlags);
LWSTDAPI_(LONG)        SHRegEnumUSValueA(HUSKEY hUSkey, DWORD dwIndex, LPSTR pszValueName, LPDWORD pcchValueName, LPDWORD pdwType, void *pvData, LPDWORD pcbData, SHREGENUM_FLAGS enumRegFlags);
LWSTDAPI_(LONG)        SHRegEnumUSValueW(HUSKEY hUSkey, DWORD dwIndex, LPWSTR pszValueName, LPDWORD pcchValueName, LPDWORD pdwType, void *pvData, LPDWORD pcbData, SHREGENUM_FLAGS enumRegFlags);
LWSTDAPI_(LONG)        SHRegQueryInfoUSKeyA(HUSKEY hUSKey, LPDWORD pcSubKeys, LPDWORD pcchMaxSubKeyLen, LPDWORD pcValues, LPDWORD pcchMaxValueNameLen, SHREGENUM_FLAGS enumRegFlags);
LWSTDAPI_(LONG)        SHRegQueryInfoUSKeyW(HUSKEY hUSKey, LPDWORD pcSubKeys, LPDWORD pcchMaxSubKeyLen, LPDWORD pcValues, LPDWORD pcchMaxValueNameLen, SHREGENUM_FLAGS enumRegFlags);
LWSTDAPI_(LONG)        SHRegCloseUSKey(HUSKEY hUSKey);


// These calls are equal to an SHRegOpenUSKey, SHRegQueryUSValue, and then a SHRegCloseUSKey.
LWSTDAPI_(LONG)        SHRegGetUSValueA(LPCSTR pszSubKey, LPCSTR pszValue, LPDWORD pdwType, void * pvData, LPDWORD pcbData, BOOL fIgnoreHKCU, void *pvDefaultData, DWORD dwDefaultDataSize);
LWSTDAPI_(LONG)        SHRegGetUSValueW(LPCWSTR pwzSubKey, LPCWSTR pwzValue, LPDWORD pdwType, void * pvData, LPDWORD pcbData, BOOL fIgnoreHKCU, void *pvDefaultData, DWORD dwDefaultDataSize);
LWSTDAPI_(LONG)        SHRegSetUSValueA(LPCSTR pszSubKey, LPCSTR pszValue, DWORD dwType, const void *pvData, DWORD cbData, DWORD dwFlags);
LWSTDAPI_(LONG)        SHRegSetUSValueW(LPCWSTR pwzSubKey, LPCWSTR pwzValue, DWORD dwType, const void *pvData, DWORD cbData, DWORD dwFlags);
LWSTDAPI_(int)         SHRegGetIntW(HKEY hk, LPCWSTR pwzKey, int iDefault);

#ifdef UNICODE
#define SHRegCreateUSKey        SHRegCreateUSKeyW
#define SHRegOpenUSKey          SHRegOpenUSKeyW
#define SHRegQueryUSValue       SHRegQueryUSValueW
#define SHRegWriteUSValue       SHRegWriteUSValueW
#define SHRegDeleteUSValue      SHRegDeleteUSValueW
#define SHRegDeleteEmptyUSKey   SHRegDeleteEmptyUSKeyW
#define SHRegEnumUSKey          SHRegEnumUSKeyW
#define SHRegEnumUSValue        SHRegEnumUSValueW
#define SHRegQueryInfoUSKey     SHRegQueryInfoUSKeyW
#define SHRegGetUSValue         SHRegGetUSValueW
#define SHRegSetUSValue         SHRegSetUSValueW
#define SHRegGetInt             SHRegGetIntW
#else
#define SHRegCreateUSKey        SHRegCreateUSKeyA
#define SHRegOpenUSKey          SHRegOpenUSKeyA
#define SHRegQueryUSValue       SHRegQueryUSValueA
#define SHRegWriteUSValue       SHRegWriteUSValueA
#define SHRegDeleteUSValue      SHRegDeleteUSValueA
#define SHRegDeleteEmptyUSKey   SHRegDeleteEmptyUSKeyA
#define SHRegEnumUSKey          SHRegEnumUSKeyA
#define SHRegEnumUSValue        SHRegEnumUSValueA
#define SHRegQueryInfoUSKey     SHRegQueryInfoUSKeyA
#define SHRegGetUSValue         SHRegGetUSValueA
#define SHRegSetUSValue         SHRegSetUSValueA
#endif

LWSTDAPI_(BOOL) SHRegGetBoolUSValueA(LPCSTR pszSubKey, LPCSTR pszValue, BOOL fIgnoreHKCU, BOOL fDefault);
LWSTDAPI_(BOOL) SHRegGetBoolUSValueW(LPCWSTR pszSubKey, LPCWSTR pszValue, BOOL fIgnoreHKCU, BOOL fDefault);

#ifdef UNICODE
#define SHRegGetBoolUSValue SHRegGetBoolUSValueW
#else
#define SHRegGetBoolUSValue SHRegGetBoolUSValueA
#endif

//
//  Association APIs
//
//  these APIs are to assist in accessing the data in HKCR
//  getting the Command strings and exe paths
//  for different verbs and extensions are simplified this way
//

enum {
    ASSOCF_INIT_NOREMAPCLSID           = 0x00000001,  //  do not remap clsids to progids
    ASSOCF_INIT_BYEXENAME              = 0x00000002,  //  executable is being passed in
    ASSOCF_OPEN_BYEXENAME              = 0x00000002,  //  executable is being passed in
    ASSOCF_INIT_DEFAULTTOSTAR          = 0x00000004,  //  treat "*" as the BaseClass
    ASSOCF_INIT_DEFAULTTOFOLDER        = 0x00000008,  //  treat "Folder" as the BaseClass
    ASSOCF_NOUSERSETTINGS              = 0x00000010,  //  dont use HKCU
    ASSOCF_NOTRUNCATE                  = 0x00000020,  //  dont truncate the return string
    ASSOCF_VERIFY                      = 0x00000040,  //  verify data is accurate (DISK HITS)
    ASSOCF_REMAPRUNDLL                 = 0x00000080,  //  actually gets info about rundlls target if applicable
    ASSOCF_NOFIXUPS                    = 0x00000100,  //  attempt to fix errors if found
    ASSOCF_IGNOREBASECLASS             = 0x00000200,  //  dont recurse into the baseclass
};

typedef DWORD ASSOCF;


typedef enum {
    ASSOCSTR_COMMAND      = 1,  //  shell\verb\command string
    ASSOCSTR_EXECUTABLE,        //  the executable part of command string
    ASSOCSTR_FRIENDLYDOCNAME,   //  friendly name of the document type
    ASSOCSTR_FRIENDLYAPPNAME,   //  friendly name of executable
    ASSOCSTR_NOOPEN,            //  noopen value
    ASSOCSTR_SHELLNEWVALUE,     //  query values under the shellnew key
    ASSOCSTR_DDECOMMAND,        //  template for DDE commands
    ASSOCSTR_DDEIFEXEC,         //  DDECOMMAND to use if just create a process
    ASSOCSTR_DDEAPPLICATION,    //  Application name in DDE broadcast
    ASSOCSTR_DDETOPIC,          //  Topic Name in DDE broadcast
    ASSOCSTR_INFOTIP,           //  info tip for an item, or list of properties to create info tip from
    ASSOCSTR_MAX                //  last item in enum...
} ASSOCSTR;

typedef enum {
    ASSOCKEY_SHELLEXECCLASS = 1,  //  the key that should be passed to ShellExec(hkeyClass)
    ASSOCKEY_APP,                 //  the "Application" key for the association
    ASSOCKEY_CLASS,               //  the progid or class key
    ASSOCKEY_BASECLASS,           //  the BaseClass key
    ASSOCKEY_MAX                  //  last item in enum...
} ASSOCKEY;

typedef enum {
    ASSOCDATA_MSIDESCRIPTOR = 1,  //  Component Descriptor to pass to MSI APIs
    ASSOCDATA_NOACTIVATEHANDLER,  //  restrict attempts to activate window
    ASSOCDATA_QUERYCLASSSTORE,    //  should check with the NT Class Store
    ASSOCDATA_HASPERUSERASSOC,    //  defaults to user specified association
    ASSOCDATA_MAX
} ASSOCDATA;

typedef enum {
    ASSOCENUM_NONE
} ASSOCENUM;

#undef INTERFACE
#define INTERFACE IQueryAssociations

DECLARE_INTERFACE_( IQueryAssociations, IUnknown )
{
    // IUnknown methods
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // IAssociations methods
    STDMETHOD (Init)(THIS_ ASSOCF flags, LPCWSTR pszAssoc, HKEY hkProgid, HWND hwnd) PURE;
    STDMETHOD (GetString)(THIS_ ASSOCF flags, ASSOCSTR str, LPCWSTR pszExtra, LPWSTR pszOut, DWORD *pcchOut) PURE;
    STDMETHOD (GetKey)(THIS_ ASSOCF flags, ASSOCKEY key, LPCWSTR pszExtra, HKEY *phkeyOut) PURE;
    STDMETHOD (GetData)(THIS_ ASSOCF flags, ASSOCDATA data, LPCWSTR pszExtra, LPVOID pvOut, DWORD *pcbOut) PURE;
    STDMETHOD (GetEnum)(THIS_ ASSOCF flags, ASSOCENUM assocenum, LPCWSTR pszExtra, REFIID riid, LPVOID *ppvOut) PURE;
};

#define CLSID_QueryAssociations IID_IQueryAssociations


LWSTDAPI AssocCreate(CLSID clsid, REFIID riid, LPVOID *ppv);

//  wrappers for the interface
LWSTDAPI AssocQueryStringA(ASSOCF flags, ASSOCSTR str, LPCSTR pszAssoc, LPCSTR pszExtra, LPSTR pszOut, DWORD *pcchOut);
//  wrappers for the interface
LWSTDAPI AssocQueryStringW(ASSOCF flags, ASSOCSTR str, LPCWSTR pszAssoc, LPCWSTR pszExtra, LPWSTR pszOut, DWORD *pcchOut);
#ifdef UNICODE
#define AssocQueryString  AssocQueryStringW
#else
#define AssocQueryString  AssocQueryStringA
#endif // !UNICODE
LWSTDAPI AssocQueryStringByKeyA(ASSOCF flags, ASSOCSTR str, HKEY hkAssoc, LPCSTR pszExtra, LPSTR pszOut, DWORD *pcchOut);
LWSTDAPI AssocQueryStringByKeyW(ASSOCF flags, ASSOCSTR str, HKEY hkAssoc, LPCWSTR pszExtra, LPWSTR pszOut, DWORD *pcchOut);
#ifdef UNICODE
#define AssocQueryStringByKey  AssocQueryStringByKeyW
#else
#define AssocQueryStringByKey  AssocQueryStringByKeyA
#endif // !UNICODE
LWSTDAPI AssocQueryKeyA(ASSOCF flags, ASSOCKEY key, LPCSTR pszAssoc, LPCSTR pszExtra, HKEY *phkeyOut);
LWSTDAPI AssocQueryKeyW(ASSOCF flags, ASSOCKEY key, LPCWSTR pszAssoc, LPCWSTR pszExtra, HKEY *phkeyOut);
#ifdef UNICODE
#define AssocQueryKey  AssocQueryKeyW
#else
#define AssocQueryKey  AssocQueryKeyA
#endif // !UNICODE



#endif //  NO_SHLWAPI_REG



#ifndef NO_SHLWAPI_STREAM
//
//=============== Stream Routines ===================================
//

LWSTDAPI_(struct IStream *) SHOpenRegStreamA(HKEY hkey, LPCSTR pszSubkey, LPCSTR pszValue, DWORD grfMode);
LWSTDAPI_(struct IStream *) SHOpenRegStreamW(HKEY hkey, LPCWSTR pszSubkey, LPCWSTR pszValue, DWORD grfMode);
#ifdef UNICODE
#define SHOpenRegStream  SHOpenRegStreamW
#else
#define SHOpenRegStream  SHOpenRegStreamA
#endif // !UNICODE
LWSTDAPI_(struct IStream *) SHOpenRegStream2A(HKEY hkey, LPCSTR pszSubkey, LPCSTR pszValue, DWORD grfMode);
LWSTDAPI_(struct IStream *) SHOpenRegStream2W(HKEY hkey, LPCWSTR pszSubkey, LPCWSTR pszValue, DWORD grfMode);
#ifdef UNICODE
#define SHOpenRegStream2  SHOpenRegStream2W
#else
#define SHOpenRegStream2  SHOpenRegStream2A
#endif // !UNICODE
// New code always wants new implementation...
#undef SHOpenRegStream
#define SHOpenRegStream SHOpenRegStream2

LWSTDAPI SHCreateStreamOnFileA(LPCSTR pszFile, DWORD grfMode, struct IStream **ppstm);
LWSTDAPI SHCreateStreamOnFileW(LPCWSTR pszFile, DWORD grfMode, struct IStream **ppstm);
#ifdef UNICODE
#define SHCreateStreamOnFile  SHCreateStreamOnFileW
#else
#define SHCreateStreamOnFile  SHCreateStreamOnFileA
#endif // !UNICODE



#endif // NO_SHLWAPI_STREAM



#if (_WIN32_IE >= 0x0500)

// SHAutoComplete
//      hwndEdit - HWND of editbox, ComboBox or ComboBoxEx.
//      dwFlags - Flags to indicate what to AutoAppend or AutoSuggest for the editbox.
//
// WARNING:
//    Caller needs to have called CoInitialize() or OleInitialize()
//    and cannot call CoUninit/OleUninit until after
//    WM_DESTROY on hwndEdit.
//
//  dwFlags values:
#define SHACF_DEFAULT                   0x00000000  // Currently (SHACF_FILESYSTEM | SHACF_URLALL)
#define SHACF_FILESYSTEM                0x00000001  // This includes the File System as well as the rest of the shell (Desktop\My Computer\Control Panel\)
#define SHACF_URLALL                    (SHACF_URLHISTORY | SHACF_URLMRU)
#define SHACF_URLHISTORY                0x00000002  // URLs in the User's History
#define SHACF_URLMRU                    0x00000004  // URLs in the User's Recently Used list.
#define SHACF_USETAB                    0x00000008  // URLs in the User's Recently Used list.
#define SHACF_FILESYS_ONLY              0x00000010  // Don't AutoComplete non-File System items.

#define SHACF_AUTOSUGGEST_FORCE_ON      0x10000000  // Ignore the registry default and force the feature on.
#define SHACF_AUTOSUGGEST_FORCE_OFF     0x20000000  // Ignore the registry default and force the feature off.
#define SHACF_AUTOAPPEND_FORCE_ON       0x40000000  // Ignore the registry default and force the feature on. (Also know as AutoComplete)
#define SHACF_AUTOAPPEND_FORCE_OFF      0x80000000  // Ignore the registry default and force the feature off. (Also know as AutoComplete)

LWSTDAPI SHAutoComplete(HWND hwndEdit, DWORD dwFlags);

STDAPI SHSetThreadRef(IUnknown *punk);
STDAPI SHGetThreadRef(IUnknown **ppunk);

LWSTDAPI_(BOOL) SHSkipJunction(struct IBindCtx* pbc, const CLSID *pclsid);
#endif

#define CTF_INSIST          0x00000001      // SHCreateThread() dwFlags - call pfnThreadProc synchronously if CreateThread() fails
#define CTF_THREAD_REF      0x00000002      // hold a reference to the creating thread
#define CTF_PROCESS_REF     0x00000004      // hold a reference to the creating process
#define CTF_COINIT          0x00000008      // init COM for the created thread

LWSTDAPI_(BOOL) SHCreateThread(LPTHREAD_START_ROUTINE pfnThreadProc, void *pData, DWORD dwFlags, LPTHREAD_START_ROUTINE pfnCallback);


#ifndef NO_SHLWAPI_GDI
//
//====== GDI helper functions  ================================================
//

LWSTDAPI_(HPALETTE) SHCreateShellPalette(HDC hdc);

#if (_WIN32_IE >= 0x0500)

LWSTDAPI_(void)     ColorRGBToHLS(COLORREF clrRGB, WORD* pwHue, WORD* pwLuminance, WORD* pwSaturation);
LWSTDAPI_(COLORREF) ColorHLSToRGB(WORD wHue, WORD wLuminance, WORD wSaturation);
LWSTDAPI_(COLORREF) ColorAdjustLuma(COLORREF clrRGB, int n, BOOL fScale);


#endif  // _WIN32_IE >= 0x0500

#endif // NO_SHLWAPI_GDI


//
//====== DllGetVersion  =======================================================
//

typedef struct _DLLVERSIONINFO
{
    DWORD cbSize;
    DWORD dwMajorVersion;                   // Major version
    DWORD dwMinorVersion;                   // Minor version
    DWORD dwBuildNumber;                    // Build number
    DWORD dwPlatformID;                     // DLLVER_PLATFORM_*
} DLLVERSIONINFO;

// Platform IDs for DLLVERSIONINFO
#define DLLVER_PLATFORM_WINDOWS         0x00000001      // Windows 95
#define DLLVER_PLATFORM_NT              0x00000002      // Windows NT

#if (_WIN32_IE >= 0x0501)

typedef struct _DLLVERSIONINFO2
{
    DLLVERSIONINFO info1;
    DWORD dwFlags;                          // No flags currently defined
    ULONGLONG ullVersion;                   // Encoded as:
                                            // Major 0xFFFF 0000 0000 0000
                                            // Minor 0x0000 FFFF 0000 0000
                                            // Build 0x0000 0000 FFFF 0000
                                            // QFE   0x0000 0000 0000 FFFF
} DLLVERSIONINFO2;

#define DLLVER_MAJOR_MASK                    0xFFFF000000000000
#define DLLVER_MINOR_MASK                    0x0000FFFF00000000
#define DLLVER_BUILD_MASK                    0x00000000FFFF0000
#define DLLVER_QFE_MASK                      0x000000000000FFFF

#endif

#define MAKEDLLVERULL(major, minor, build, qfe) \
        (((ULONGLONG)(major) << 48) |        \
         ((ULONGLONG)(minor) << 32) |        \
         ((ULONGLONG)(build) << 16) |        \
         ((ULONGLONG)(  qfe) <<  0))

//
// The caller should always GetProcAddress("DllGetVersion"), not
// implicitly link to it.
//

typedef HRESULT (CALLBACK* DLLGETVERSIONPROC)(DLLVERSIONINFO *);

// DllInstall (to be implemented by self-installing DLLs)
STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine);



#ifdef __cplusplus
}
#endif

#ifdef _WIN32
#include <poppack.h>
#endif

#endif


#endif  // _INC_SHLWAPI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\rcml_p.c ===
/* this ALWAYS GENERATED file contains the proxy stub code */


/* File created by MIDL compiler version 5.01.0164 */
/* at Tue Jul 25 12:15:53 2000
 */
/* Compiler settings for C:\NT\windows\AdvCore\RCML\RCML\rcml.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 440
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "RCMLPub.h"

#define TYPE_FORMAT_STRING_SIZE   261                               
#define PROC_FORMAT_STRING_SIZE   223                               

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


/* Standard interface: __MIDL_itf_rcml_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IRCMLResize, ver. 0.0,
   GUID={0x4CB1AC90,0x853C,0x4ce2,{0xB0,0x13,0x26,0xD0,0xEE,0x67,0x5F,0x78}} */


extern const MIDL_STUB_DESC Object_StubDesc;


#pragma code_seg(".orpc")
const CINTERFACE_PROXY_VTABLE(3) _IRCMLResizeProxyVtbl = 
{
    &IID_IRCMLResize,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy
};


static const PRPC_STUB_FUNCTION IRCMLResize_table[] =
{
    0    /* a dummy for an empty interface */
};

const CInterfaceStubVtbl _IRCMLResizeStubVtbl =
{
    &IID_IRCMLResize,
    0,
    3,
    &IRCMLResize_table[-3],
    CStdStubBuffer_METHODS
};


/* Object interface: IRCMLNode, ver. 0.0,
   GUID={0xF825CAF1,0xDE40,0x4FCC,{0xB9,0x65,0x93,0x30,0x76,0xD7,0xA1,0xC5}} */


extern const MIDL_STUB_DESC Object_StubDesc;


#pragma code_seg(".orpc")

/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRCMLNode_AttachParent_Proxy( 
    IRCMLNode __RPC_FAR * This,
    /* [in] */ IRCMLNode __RPC_FAR *child)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      3);
        
        
        
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrInterfacePointerBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                           (unsigned char __RPC_FAR *)child,
                                           (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[2] );
            
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrInterfacePointerMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                                         (unsigned char __RPC_FAR *)child,
                                         (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[2] );
            
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0] );
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLNode_AttachParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    IRCMLNode __RPC_FAR *child;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    child = 0;
    RpcTryFinally
        {
        if ( (_pRpcMessage->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0] );
        
        NdrInterfacePointerUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                       (unsigned char __RPC_FAR * __RPC_FAR *)&child,
                                       (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[2],
                                       (unsigned char)0 );
        
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLNode*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> AttachParent((IRCMLNode *) ((CStdStubBuffer *)This)->pvServerObject,child);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        NdrInterfacePointerFree( &_StubMsg,
                                 (unsigned char __RPC_FAR *)child,
                                 &__MIDL_TypeFormatString.Format[2] );
        
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRCMLNode_DetachParent_Proxy( 
    IRCMLNode __RPC_FAR * This,
    /* [retval][out] */ IRCMLNode __RPC_FAR *__RPC_FAR *child)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    if(child)
        {
        MIDL_memset(
               child,
               0,
               sizeof( IRCMLNode __RPC_FAR *__RPC_FAR * ));
        }
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      4);
        
        
        
        if(!child)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[6] );
            
            NdrPointerUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                  (unsigned char __RPC_FAR * __RPC_FAR *)&child,
                                  (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[20],
                                  (unsigned char)0 );
            
            _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[20],
                         ( void __RPC_FAR * )child);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLNode_DetachParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    IRCMLNode __RPC_FAR *_M0;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    IRCMLNode __RPC_FAR *__RPC_FAR *child;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( IRCMLNode __RPC_FAR *__RPC_FAR * )child = 0;
    RpcTryFinally
        {
        child = &_M0;
        _M0 = 0;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLNode*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> DetachParent((IRCMLNode *) ((CStdStubBuffer *)This)->pvServerObject,child);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 0U + 4U;
        NdrPointerBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                              (unsigned char __RPC_FAR *)child,
                              (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[20] );
        
        _StubMsg.BufferLength += 16;
        
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        NdrPointerMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                            (unsigned char __RPC_FAR *)child,
                            (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[20] );
        
        _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        NdrPointerFree( &_StubMsg,
                        (unsigned char __RPC_FAR *)child,
                        &__MIDL_TypeFormatString.Format[20] );
        
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRCMLNode_AcceptChild_Proxy( 
    IRCMLNode __RPC_FAR * This,
    IRCMLNode __RPC_FAR *child)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      5);
        
        
        
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrInterfacePointerBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                           (unsigned char __RPC_FAR *)child,
                                           (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[2] );
            
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrInterfacePointerMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                                         (unsigned char __RPC_FAR *)child,
                                         (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[2] );
            
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0] );
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLNode_AcceptChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    IRCMLNode __RPC_FAR *child;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    child = 0;
    RpcTryFinally
        {
        if ( (_pRpcMessage->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0] );
        
        NdrInterfacePointerUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                       (unsigned char __RPC_FAR * __RPC_FAR *)&child,
                                       (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[2],
                                       (unsigned char)0 );
        
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLNode*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> AcceptChild((IRCMLNode *) ((CStdStubBuffer *)This)->pvServerObject,child);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        NdrInterfacePointerFree( &_StubMsg,
                                 (unsigned char __RPC_FAR *)child,
                                 &__MIDL_TypeFormatString.Format[2] );
        
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRCMLNode_DoEndChild_Proxy( 
    IRCMLNode __RPC_FAR * This,
    IRCMLNode __RPC_FAR *child)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      6);
        
        
        
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrInterfacePointerBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                           (unsigned char __RPC_FAR *)child,
                                           (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[2] );
            
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrInterfacePointerMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                                         (unsigned char __RPC_FAR *)child,
                                         (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[2] );
            
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0] );
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLNode_DoEndChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    IRCMLNode __RPC_FAR *child;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    child = 0;
    RpcTryFinally
        {
        if ( (_pRpcMessage->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0] );
        
        NdrInterfacePointerUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                       (unsigned char __RPC_FAR * __RPC_FAR *)&child,
                                       (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[2],
                                       (unsigned char)0 );
        
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLNode*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> DoEndChild((IRCMLNode *) ((CStdStubBuffer *)This)->pvServerObject,child);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        NdrInterfacePointerFree( &_StubMsg,
                                 (unsigned char __RPC_FAR *)child,
                                 &__MIDL_TypeFormatString.Format[2] );
        
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRCMLNode_get_Type_Proxy( 
    IRCMLNode __RPC_FAR * This,
    /* [retval][out] */ UINT __RPC_FAR *pVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      7);
        
        
        
        if(!pVal)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[12] );
            
            *pVal = *(( UINT __RPC_FAR * )_StubMsg.Buffer)++;
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[24],
                         ( void __RPC_FAR * )pVal);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLNode_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    UINT _M1;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    UINT __RPC_FAR *pVal;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( UINT __RPC_FAR * )pVal = 0;
    RpcTryFinally
        {
        pVal = &_M1;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLNode*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_Type((IRCMLNode *) ((CStdStubBuffer *)This)->pvServerObject,pVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U + 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( UINT __RPC_FAR * )_StubMsg.Buffer)++ = *pVal;
        
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRCMLNode_InitNode_Proxy( 
    IRCMLNode __RPC_FAR * This,
    IRCMLNode __RPC_FAR *parent)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      8);
        
        
        
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrInterfacePointerBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                           (unsigned char __RPC_FAR *)parent,
                                           (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[2] );
            
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrInterfacePointerMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                                         (unsigned char __RPC_FAR *)parent,
                                         (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[2] );
            
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0] );
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLNode_InitNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    IRCMLNode __RPC_FAR *parent;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    parent = 0;
    RpcTryFinally
        {
        if ( (_pRpcMessage->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0] );
        
        NdrInterfacePointerUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                       (unsigned char __RPC_FAR * __RPC_FAR *)&parent,
                                       (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[2],
                                       (unsigned char)0 );
        
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLNode*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> InitNode((IRCMLNode *) ((CStdStubBuffer *)This)->pvServerObject,parent);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        NdrInterfacePointerFree( &_StubMsg,
                                 (unsigned char __RPC_FAR *)parent,
                                 &__MIDL_TypeFormatString.Format[2] );
        
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRCMLNode_DisplayNode_Proxy( 
    IRCMLNode __RPC_FAR * This,
    IRCMLNode __RPC_FAR *parent)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      9);
        
        
        
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrInterfacePointerBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                           (unsigned char __RPC_FAR *)parent,
                                           (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[2] );
            
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrInterfacePointerMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                                         (unsigned char __RPC_FAR *)parent,
                                         (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[2] );
            
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0] );
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLNode_DisplayNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    IRCMLNode __RPC_FAR *parent;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    parent = 0;
    RpcTryFinally
        {
        if ( (_pRpcMessage->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0] );
        
        NdrInterfacePointerUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                       (unsigned char __RPC_FAR * __RPC_FAR *)&parent,
                                       (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[2],
                                       (unsigned char)0 );
        
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLNode*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> DisplayNode((IRCMLNode *) ((CStdStubBuffer *)This)->pvServerObject,parent);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        NdrInterfacePointerFree( &_StubMsg,
                                 (unsigned char __RPC_FAR *)parent,
                                 &__MIDL_TypeFormatString.Format[2] );
        
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRCMLNode_ExitNode_Proxy( 
    IRCMLNode __RPC_FAR * This,
    IRCMLNode __RPC_FAR *parent,
    /* [in] */ LONG lDialogResult)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      10);
        
        
        
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U + 4U;
            NdrInterfacePointerBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                           (unsigned char __RPC_FAR *)parent,
                                           (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[2] );
            
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrInterfacePointerMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                                         (unsigned char __RPC_FAR *)parent,
                                         (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[2] );
            
            _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            *(( LONG __RPC_FAR * )_StubMsg.Buffer)++ = lDialogResult;
            
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[18] );
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLNode_ExitNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    LONG lDialogResult;
    IRCMLNode __RPC_FAR *parent;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    parent = 0;
    RpcTryFinally
        {
        if ( (_pRpcMessage->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[18] );
        
        NdrInterfacePointerUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                       (unsigned char __RPC_FAR * __RPC_FAR *)&parent,
                                       (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[2],
                                       (unsigned char)0 );
        
        _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        lDialogResult = *(( LONG __RPC_FAR * )_StubMsg.Buffer)++;
        
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLNode*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> ExitNode(
            (IRCMLNode *) ((CStdStubBuffer *)This)->pvServerObject,
            parent,
            lDialogResult);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        NdrInterfacePointerFree( &_StubMsg,
                                 (unsigned char __RPC_FAR *)parent,
                                 &__MIDL_TypeFormatString.Format[2] );
        
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRCMLNode_get_Attr_Proxy( 
    IRCMLNode __RPC_FAR * This,
    LPCWSTR index,
    /* [retval][out] */ LPWSTR __RPC_FAR *pVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    if(pVal)
        {
        *pVal = 0;
        }
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      11);
        
        
        
        if(!index)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        if(!pVal)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 12U;
            NdrConformantStringBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                           (unsigned char __RPC_FAR *)index,
                                           (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[30] );
            
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrConformantStringMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                                         (unsigned char __RPC_FAR *)index,
                                         (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[30] );
            
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[26] );
            
            NdrPointerUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                  (unsigned char __RPC_FAR * __RPC_FAR *)&pVal,
                                  (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[32],
                                  (unsigned char)0 );
            
            _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[32],
                         ( void __RPC_FAR * )pVal);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLNode_get_Attr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    LPWSTR _M6;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    LPCWSTR index;
    LPWSTR __RPC_FAR *pVal;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( LPCWSTR  )index = 0;
    ( LPWSTR __RPC_FAR * )pVal = 0;
    RpcTryFinally
        {
        if ( (_pRpcMessage->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[26] );
        
        NdrConformantStringUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                       (unsigned char __RPC_FAR * __RPC_FAR *)&index,
                                       (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[30],
                                       (unsigned char)0 );
        
        pVal = &_M6;
        _M6 = 0;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLNode*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_Attr(
            (IRCMLNode *) ((CStdStubBuffer *)This)->pvServerObject,
            index,
            pVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 16U + 10U;
        NdrPointerBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                              (unsigned char __RPC_FAR *)pVal,
                              (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[32] );
        
        _StubMsg.BufferLength += 16;
        
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        NdrPointerMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                            (unsigned char __RPC_FAR *)pVal,
                            (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[32] );
        
        _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        NdrPointerFree( &_StubMsg,
                        (unsigned char __RPC_FAR *)pVal,
                        &__MIDL_TypeFormatString.Format[32] );
        
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IRCMLNode_put_Attr_Proxy( 
    IRCMLNode __RPC_FAR * This,
    LPCWSTR index,
    /* [in] */ LPCWSTR newVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      12);
        
        
        
        if(!index)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        if(!newVal)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 12U + 14U;
            NdrConformantStringBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                           (unsigned char __RPC_FAR *)index,
                                           (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[30] );
            
            NdrConformantStringBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                           (unsigned char __RPC_FAR *)newVal,
                                           (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[30] );
            
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrConformantStringMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                                         (unsigned char __RPC_FAR *)index,
                                         (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[30] );
            
            NdrConformantStringMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                                         (unsigned char __RPC_FAR *)newVal,
                                         (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[30] );
            
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[36] );
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLNode_put_Attr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    LPCWSTR index;
    LPCWSTR newVal;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( LPCWSTR  )index = 0;
    ( LPCWSTR  )newVal = 0;
    RpcTryFinally
        {
        if ( (_pRpcMessage->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[36] );
        
        NdrConformantStringUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                       (unsigned char __RPC_FAR * __RPC_FAR *)&index,
                                       (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[30],
                                       (unsigned char)0 );
        
        NdrConformantStringUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                       (unsigned char __RPC_FAR * __RPC_FAR *)&newVal,
                                       (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[30],
                                       (unsigned char)0 );
        
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLNode*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> put_Attr(
            (IRCMLNode *) ((CStdStubBuffer *)This)->pvServerObject,
            index,
            newVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U;
        _StubMsg.BufferLength += 16;
        
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRCMLNode_IsType_Proxy( 
    IRCMLNode __RPC_FAR * This,
    LPCWSTR nodeName)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      13);
        
        
        
        if(!nodeName)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 12U;
            NdrConformantStringBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                           (unsigned char __RPC_FAR *)nodeName,
                                           (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[30] );
            
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrConformantStringMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                                         (unsigned char __RPC_FAR *)nodeName,
                                         (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[30] );
            
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[46] );
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLNode_IsType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    LPCWSTR nodeName;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( LPCWSTR  )nodeName = 0;
    RpcTryFinally
        {
        if ( (_pRpcMessage->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[46] );
        
        NdrConformantStringUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                       (unsigned char __RPC_FAR * __RPC_FAR *)&nodeName,
                                       (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[30],
                                       (unsigned char)0 );
        
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLNode*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> IsType((IRCMLNode *) ((CStdStubBuffer *)This)->pvServerObject,nodeName);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U;
        _StubMsg.BufferLength += 16;
        
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRCMLNode_YesDefault_Proxy( 
    IRCMLNode __RPC_FAR * This,
    /* [in] */ LPCWSTR propID,
    /* [in] */ DWORD dwNotPresent,
    /* [in] */ DWORD dwYes,
    /* [retval][out] */ DWORD __RPC_FAR *pdwValue)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      14);
        
        
        
        if(!propID)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        if(!pdwValue)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 12U + 10U + 7U;
            NdrConformantStringBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                           (unsigned char __RPC_FAR *)propID,
                                           (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[30] );
            
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrConformantStringMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                                         (unsigned char __RPC_FAR *)propID,
                                         (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[30] );
            
            _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            *(( DWORD __RPC_FAR * )_StubMsg.Buffer)++ = dwNotPresent;
            
            *(( DWORD __RPC_FAR * )_StubMsg.Buffer)++ = dwYes;
            
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[52] );
            
            *pdwValue = *(( DWORD __RPC_FAR * )_StubMsg.Buffer)++;
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[24],
                         ( void __RPC_FAR * )pdwValue);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLNode_YesDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    DWORD _M15;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    DWORD dwNotPresent;
    DWORD dwYes;
    DWORD __RPC_FAR *pdwValue;
    LPCWSTR propID;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( LPCWSTR  )propID = 0;
    ( DWORD __RPC_FAR * )pdwValue = 0;
    RpcTryFinally
        {
        if ( (_pRpcMessage->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[52] );
        
        NdrConformantStringUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                       (unsigned char __RPC_FAR * __RPC_FAR *)&propID,
                                       (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[30],
                                       (unsigned char)0 );
        
        _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        dwNotPresent = *(( DWORD __RPC_FAR * )_StubMsg.Buffer)++;
        
        dwYes = *(( DWORD __RPC_FAR * )_StubMsg.Buffer)++;
        
        pdwValue = &_M15;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLNode*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> YesDefault(
              (IRCMLNode *) ((CStdStubBuffer *)This)->pvServerObject,
              propID,
              dwNotPresent,
              dwYes,
              pdwValue);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U + 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( DWORD __RPC_FAR * )_StubMsg.Buffer)++ = *pdwValue;
        
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRCMLNode_YesNoDefault_Proxy( 
    IRCMLNode __RPC_FAR * This,
    /* [in] */ LPCWSTR propID,
    /* [in] */ DWORD dwNotPresent,
    /* [in] */ DWORD dwNo,
    /* [in] */ DWORD dwYes,
    /* [retval][out] */ DWORD __RPC_FAR *pdwValue)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      15);
        
        
        
        if(!propID)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        if(!pdwValue)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 12U + 10U + 7U + 7U;
            NdrConformantStringBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                           (unsigned char __RPC_FAR *)propID,
                                           (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[30] );
            
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrConformantStringMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                                         (unsigned char __RPC_FAR *)propID,
                                         (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[30] );
            
            _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            *(( DWORD __RPC_FAR * )_StubMsg.Buffer)++ = dwNotPresent;
            
            *(( DWORD __RPC_FAR * )_StubMsg.Buffer)++ = dwNo;
            
            *(( DWORD __RPC_FAR * )_StubMsg.Buffer)++ = dwYes;
            
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[66] );
            
            *pdwValue = *(( DWORD __RPC_FAR * )_StubMsg.Buffer)++;
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[24],
                         ( void __RPC_FAR * )pdwValue);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLNode_YesNoDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    DWORD _M18;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    DWORD dwNo;
    DWORD dwNotPresent;
    DWORD dwYes;
    DWORD __RPC_FAR *pdwValue;
    LPCWSTR propID;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( LPCWSTR  )propID = 0;
    ( DWORD __RPC_FAR * )pdwValue = 0;
    RpcTryFinally
        {
        if ( (_pRpcMessage->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[66] );
        
        NdrConformantStringUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                       (unsigned char __RPC_FAR * __RPC_FAR *)&propID,
                                       (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[30],
                                       (unsigned char)0 );
        
        _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        dwNotPresent = *(( DWORD __RPC_FAR * )_StubMsg.Buffer)++;
        
        dwNo = *(( DWORD __RPC_FAR * )_StubMsg.Buffer)++;
        
        dwYes = *(( DWORD __RPC_FAR * )_StubMsg.Buffer)++;
        
        pdwValue = &_M18;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLNode*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> YesNoDefault(
                (IRCMLNode *) ((CStdStubBuffer *)This)->pvServerObject,
                propID,
                dwNotPresent,
                dwNo,
                dwYes,
                pdwValue);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U + 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( DWORD __RPC_FAR * )_StubMsg.Buffer)++ = *pdwValue;
        
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRCMLNode_ValueOf_Proxy( 
    IRCMLNode __RPC_FAR * This,
    /* [in] */ LPCWSTR propID,
    /* [in] */ DWORD dwNotPresent,
    /* [retval][out] */ DWORD __RPC_FAR *pdwValue)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      16);
        
        
        
        if(!propID)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        if(!pdwValue)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 12U + 10U;
            NdrConformantStringBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                           (unsigned char __RPC_FAR *)propID,
                                           (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[30] );
            
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrConformantStringMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                                         (unsigned char __RPC_FAR *)propID,
                                         (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[30] );
            
            _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            *(( DWORD __RPC_FAR * )_StubMsg.Buffer)++ = dwNotPresent;
            
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[82] );
            
            *pdwValue = *(( DWORD __RPC_FAR * )_StubMsg.Buffer)++;
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[24],
                         ( void __RPC_FAR * )pdwValue);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLNode_ValueOf_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    DWORD _M21;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    DWORD dwNotPresent;
    DWORD __RPC_FAR *pdwValue;
    LPCWSTR propID;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( LPCWSTR  )propID = 0;
    ( DWORD __RPC_FAR * )pdwValue = 0;
    RpcTryFinally
        {
        if ( (_pRpcMessage->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[82] );
        
        NdrConformantStringUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                       (unsigned char __RPC_FAR * __RPC_FAR *)&propID,
                                       (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[30],
                                       (unsigned char)0 );
        
        _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        dwNotPresent = *(( DWORD __RPC_FAR * )_StubMsg.Buffer)++;
        
        pdwValue = &_M21;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLNode*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> ValueOf(
           (IRCMLNode *) ((CStdStubBuffer *)This)->pvServerObject,
           propID,
           dwNotPresent,
           pdwValue);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U + 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( DWORD __RPC_FAR * )_StubMsg.Buffer)++ = *pdwValue;
        
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRCMLNode_SignedValueOf_Proxy( 
    IRCMLNode __RPC_FAR * This,
    /* [in] */ LPCWSTR propID,
    /* [in] */ int dwNotPresent,
    /* [retval][out] */ int __RPC_FAR *pdwValue)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      17);
        
        
        
        if(!propID)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        if(!pdwValue)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 12U + 10U;
            NdrConformantStringBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                           (unsigned char __RPC_FAR *)propID,
                                           (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[30] );
            
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrConformantStringMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                                         (unsigned char __RPC_FAR *)propID,
                                         (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[30] );
            
            _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            *(( int __RPC_FAR * )_StubMsg.Buffer)++ = dwNotPresent;
            
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[82] );
            
            *pdwValue = *(( int __RPC_FAR * )_StubMsg.Buffer)++;
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[24],
                         ( void __RPC_FAR * )pdwValue);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLNode_SignedValueOf_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    int _M24;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    int dwNotPresent;
    int __RPC_FAR *pdwValue;
    LPCWSTR propID;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( LPCWSTR  )propID = 0;
    ( int __RPC_FAR * )pdwValue = 0;
    RpcTryFinally
        {
        if ( (_pRpcMessage->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[82] );
        
        NdrConformantStringUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                       (unsigned char __RPC_FAR * __RPC_FAR *)&propID,
                                       (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[30],
                                       (unsigned char)0 );
        
        _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        dwNotPresent = *(( int __RPC_FAR * )_StubMsg.Buffer)++;
        
        pdwValue = &_M24;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLNode*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> SignedValueOf(
                 (IRCMLNode *) ((CStdStubBuffer *)This)->pvServerObject,
                 propID,
                 dwNotPresent,
                 pdwValue);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U + 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( int __RPC_FAR * )_StubMsg.Buffer)++ = *pdwValue;
        
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLNode_get_StringType_Proxy( 
    IRCMLNode __RPC_FAR * This,
    /* [retval][out] */ LPWSTR __RPC_FAR *pStringType)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    if(pStringType)
        {
        *pStringType = 0;
        }
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      18);
        
        
        
        if(!pStringType)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[94] );
            
            NdrPointerUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                  (unsigned char __RPC_FAR * __RPC_FAR *)&pStringType,
                                  (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[32],
                                  (unsigned char)0 );
            
            _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[32],
                         ( void __RPC_FAR * )pStringType);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLNode_get_StringType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    LPWSTR _M27;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    LPWSTR __RPC_FAR *pStringType;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( LPWSTR __RPC_FAR * )pStringType = 0;
    RpcTryFinally
        {
        pStringType = &_M27;
        _M27 = 0;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLNode*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_StringType((IRCMLNode *) ((CStdStubBuffer *)This)->pvServerObject,pStringType);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 16U + 10U;
        NdrPointerBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                              (unsigned char __RPC_FAR *)pStringType,
                              (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[32] );
        
        _StubMsg.BufferLength += 16;
        
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        NdrPointerMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                            (unsigned char __RPC_FAR *)pStringType,
                            (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[32] );
        
        _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        NdrPointerFree( &_StubMsg,
                        (unsigned char __RPC_FAR *)pStringType,
                        &__MIDL_TypeFormatString.Format[32] );
        
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRCMLNode_GetChildEnum_Proxy( 
    IRCMLNode __RPC_FAR * This,
    /* [retval][out] */ IEnumUnknown __RPC_FAR *__RPC_FAR *pEnum)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    if(pEnum)
        {
        MIDL_memset(
               pEnum,
               0,
               sizeof( IEnumUnknown __RPC_FAR *__RPC_FAR * ));
        }
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      19);
        
        
        
        if(!pEnum)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[100] );
            
            NdrPointerUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                  (unsigned char __RPC_FAR * __RPC_FAR *)&pEnum,
                                  (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[40],
                                  (unsigned char)0 );
            
            _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[40],
                         ( void __RPC_FAR * )pEnum);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLNode_GetChildEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    IEnumUnknown __RPC_FAR *_M28;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    IEnumUnknown __RPC_FAR *__RPC_FAR *pEnum;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( IEnumUnknown __RPC_FAR *__RPC_FAR * )pEnum = 0;
    RpcTryFinally
        {
        pEnum = &_M28;
        _M28 = 0;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLNode*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> GetChildEnum((IRCMLNode *) ((CStdStubBuffer *)This)->pvServerObject,pEnum);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 0U + 4U;
        NdrPointerBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                              (unsigned char __RPC_FAR *)pEnum,
                              (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[40] );
        
        _StubMsg.BufferLength += 16;
        
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        NdrPointerMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                            (unsigned char __RPC_FAR *)pEnum,
                            (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[40] );
        
        _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        NdrPointerFree( &_StubMsg,
                        (unsigned char __RPC_FAR *)pEnum,
                        &__MIDL_TypeFormatString.Format[40] );
        
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRCMLNode_GetUnknownEnum_Proxy( 
    IRCMLNode __RPC_FAR * This,
    /* [retval][out] */ IEnumUnknown __RPC_FAR *__RPC_FAR *pEnum)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    if(pEnum)
        {
        MIDL_memset(
               pEnum,
               0,
               sizeof( IEnumUnknown __RPC_FAR *__RPC_FAR * ));
        }
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      20);
        
        
        
        if(!pEnum)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[100] );
            
            NdrPointerUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                  (unsigned char __RPC_FAR * __RPC_FAR *)&pEnum,
                                  (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[40],
                                  (unsigned char)0 );
            
            _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[40],
                         ( void __RPC_FAR * )pEnum);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLNode_GetUnknownEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    IEnumUnknown __RPC_FAR *_M29;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    IEnumUnknown __RPC_FAR *__RPC_FAR *pEnum;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( IEnumUnknown __RPC_FAR *__RPC_FAR * )pEnum = 0;
    RpcTryFinally
        {
        pEnum = &_M29;
        _M29 = 0;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLNode*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> GetUnknownEnum((IRCMLNode *) ((CStdStubBuffer *)This)->pvServerObject,pEnum);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 0U + 4U;
        NdrPointerBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                              (unsigned char __RPC_FAR *)pEnum,
                              (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[40] );
        
        _StubMsg.BufferLength += 16;
        
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        NdrPointerMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                            (unsigned char __RPC_FAR *)pEnum,
                            (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[40] );
        
        _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        NdrPointerFree( &_StubMsg,
                        (unsigned char __RPC_FAR *)pEnum,
                        &__MIDL_TypeFormatString.Format[40] );
        
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}

const CINTERFACE_PROXY_VTABLE(21) _IRCMLNodeProxyVtbl = 
{
    &IID_IRCMLNode,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IRCMLNode_AttachParent_Proxy ,
    IRCMLNode_DetachParent_Proxy ,
    IRCMLNode_AcceptChild_Proxy ,
    IRCMLNode_DoEndChild_Proxy ,
    IRCMLNode_get_Type_Proxy ,
    IRCMLNode_InitNode_Proxy ,
    IRCMLNode_DisplayNode_Proxy ,
    IRCMLNode_ExitNode_Proxy ,
    IRCMLNode_get_Attr_Proxy ,
    IRCMLNode_put_Attr_Proxy ,
    IRCMLNode_IsType_Proxy ,
    IRCMLNode_YesDefault_Proxy ,
    IRCMLNode_YesNoDefault_Proxy ,
    IRCMLNode_ValueOf_Proxy ,
    IRCMLNode_SignedValueOf_Proxy ,
    IRCMLNode_get_StringType_Proxy ,
    IRCMLNode_GetChildEnum_Proxy ,
    IRCMLNode_GetUnknownEnum_Proxy
};


static const PRPC_STUB_FUNCTION IRCMLNode_table[] =
{
    IRCMLNode_AttachParent_Stub,
    IRCMLNode_DetachParent_Stub,
    IRCMLNode_AcceptChild_Stub,
    IRCMLNode_DoEndChild_Stub,
    IRCMLNode_get_Type_Stub,
    IRCMLNode_InitNode_Stub,
    IRCMLNode_DisplayNode_Stub,
    IRCMLNode_ExitNode_Stub,
    IRCMLNode_get_Attr_Stub,
    IRCMLNode_put_Attr_Stub,
    IRCMLNode_IsType_Stub,
    IRCMLNode_YesDefault_Stub,
    IRCMLNode_YesNoDefault_Stub,
    IRCMLNode_ValueOf_Stub,
    IRCMLNode_SignedValueOf_Stub,
    IRCMLNode_get_StringType_Stub,
    IRCMLNode_GetChildEnum_Stub,
    IRCMLNode_GetUnknownEnum_Stub
};

const CInterfaceStubVtbl _IRCMLNodeStubVtbl =
{
    &IID_IRCMLNode,
    0,
    21,
    &IRCMLNode_table[-3],
    CStdStubBuffer_METHODS
};


/* Object interface: IRCMLCSS, ver. 0.0,
   GUID={0xF5DBF38A,0x14DE,0x4f8b,{0x87,0x50,0xBA,0xBA,0x88,0x46,0xE7,0xF2}} */


extern const MIDL_STUB_DESC Object_StubDesc;


#pragma code_seg(".orpc")

/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLCSS_get_Font_Proxy( 
    IRCMLCSS __RPC_FAR * This,
    /* [retval][out] */ HFONT __RPC_FAR *pVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    if(pVal)
        {
        MIDL_memset(
               pVal,
               0,
               sizeof( HFONT  ));
        }
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      21);
        
        
        
        if(!pVal)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[106] );
            
            NdrUserMarshalUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                      (unsigned char __RPC_FAR * __RPC_FAR *)&pVal,
                                      (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[90],
                                      (unsigned char)0 );
            
            _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[62],
                         ( void __RPC_FAR * )pVal);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLCSS_get_Font_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    HFONT _M30;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    HFONT __RPC_FAR *pVal;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( HFONT __RPC_FAR * )pVal = 0;
    RpcTryFinally
        {
        pVal = &_M30;
        MIDL_memset(
               pVal,
               0,
               sizeof( HFONT  ));
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLCSS*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_Font((IRCMLCSS *) ((CStdStubBuffer *)This)->pvServerObject,pVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 8U + 11U;
        NdrUserMarshalBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                  (unsigned char __RPC_FAR *)pVal,
                                  (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[90] );
        
        _StubMsg.BufferLength += 16;
        
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        NdrUserMarshalMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                                (unsigned char __RPC_FAR *)pVal,
                                (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[90] );
        
        _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        NdrPointerFree( &_StubMsg,
                        (unsigned char __RPC_FAR *)pVal,
                        &__MIDL_TypeFormatString.Format[62] );
        
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLCSS_get_Brush_Proxy( 
    IRCMLCSS __RPC_FAR * This,
    /* [retval][out] */ HBRUSH __RPC_FAR *pVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    if(pVal)
        {
        MIDL_memset(
               pVal,
               0,
               sizeof( HBRUSH  ));
        }
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      22);
        
        
        
        if(!pVal)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[112] );
            
            NdrUserMarshalUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                      (unsigned char __RPC_FAR * __RPC_FAR *)&pVal,
                                      (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[104],
                                      (unsigned char)0 );
            
            _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[100],
                         ( void __RPC_FAR * )pVal);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLCSS_get_Brush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    HBRUSH _M31;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    HBRUSH __RPC_FAR *pVal;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( HBRUSH __RPC_FAR * )pVal = 0;
    RpcTryFinally
        {
        pVal = &_M31;
        MIDL_memset(
               pVal,
               0,
               sizeof( HBRUSH  ));
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLCSS*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_Brush((IRCMLCSS *) ((CStdStubBuffer *)This)->pvServerObject,pVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 8U + 11U;
        NdrUserMarshalBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                  (unsigned char __RPC_FAR *)pVal,
                                  (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[104] );
        
        _StubMsg.BufferLength += 16;
        
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        NdrUserMarshalMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                                (unsigned char __RPC_FAR *)pVal,
                                (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[104] );
        
        _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        NdrPointerFree( &_StubMsg,
                        (unsigned char __RPC_FAR *)pVal,
                        &__MIDL_TypeFormatString.Format[100] );
        
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLCSS_get_Pen_Proxy( 
    IRCMLCSS __RPC_FAR * This,
    /* [retval][out] */ DWORD __RPC_FAR *pVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      23);
        
        
        
        if(!pVal)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[12] );
            
            *pVal = *(( DWORD __RPC_FAR * )_StubMsg.Buffer)++;
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[24],
                         ( void __RPC_FAR * )pVal);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLCSS_get_Pen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    DWORD _M32;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    DWORD __RPC_FAR *pVal;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( DWORD __RPC_FAR * )pVal = 0;
    RpcTryFinally
        {
        pVal = &_M32;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLCSS*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_Pen((IRCMLCSS *) ((CStdStubBuffer *)This)->pvServerObject,pVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U + 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( DWORD __RPC_FAR * )_StubMsg.Buffer)++ = *pVal;
        
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLCSS_get_Color_Proxy( 
    IRCMLCSS __RPC_FAR * This,
    /* [retval][out] */ COLORREF __RPC_FAR *pVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      24);
        
        
        
        if(!pVal)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[12] );
            
            *pVal = *(( COLORREF __RPC_FAR * )_StubMsg.Buffer)++;
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[24],
                         ( void __RPC_FAR * )pVal);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLCSS_get_Color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    COLORREF _M33;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    COLORREF __RPC_FAR *pVal;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( COLORREF __RPC_FAR * )pVal = 0;
    RpcTryFinally
        {
        pVal = &_M33;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLCSS*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_Color((IRCMLCSS *) ((CStdStubBuffer *)This)->pvServerObject,pVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U + 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( COLORREF __RPC_FAR * )_StubMsg.Buffer)++ = *pVal;
        
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLCSS_get_BkColor_Proxy( 
    IRCMLCSS __RPC_FAR * This,
    /* [retval][out] */ COLORREF __RPC_FAR *pVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      25);
        
        
        
        if(!pVal)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[12] );
            
            *pVal = *(( COLORREF __RPC_FAR * )_StubMsg.Buffer)++;
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[24],
                         ( void __RPC_FAR * )pVal);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLCSS_get_BkColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    COLORREF _M34;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    COLORREF __RPC_FAR *pVal;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( COLORREF __RPC_FAR * )pVal = 0;
    RpcTryFinally
        {
        pVal = &_M34;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLCSS*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_BkColor((IRCMLCSS *) ((CStdStubBuffer *)This)->pvServerObject,pVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U + 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( COLORREF __RPC_FAR * )_StubMsg.Buffer)++ = *pVal;
        
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLCSS_get_DialogStyle_Proxy( 
    IRCMLCSS __RPC_FAR * This,
    /* [retval][out] */ IRCMLCSS __RPC_FAR *__RPC_FAR *pVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    if(pVal)
        {
        MIDL_memset(
               pVal,
               0,
               sizeof( IRCMLCSS __RPC_FAR *__RPC_FAR * ));
        }
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      26);
        
        
        
        if(!pVal)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[118] );
            
            NdrPointerUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                  (unsigned char __RPC_FAR * __RPC_FAR *)&pVal,
                                  (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[114],
                                  (unsigned char)0 );
            
            _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[114],
                         ( void __RPC_FAR * )pVal);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLCSS_get_DialogStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    IRCMLCSS __RPC_FAR *_M35;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    IRCMLCSS __RPC_FAR *__RPC_FAR *pVal;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( IRCMLCSS __RPC_FAR *__RPC_FAR * )pVal = 0;
    RpcTryFinally
        {
        pVal = &_M35;
        _M35 = 0;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLCSS*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_DialogStyle((IRCMLCSS *) ((CStdStubBuffer *)This)->pvServerObject,pVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 0U + 4U;
        NdrPointerBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                              (unsigned char __RPC_FAR *)pVal,
                              (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[114] );
        
        _StubMsg.BufferLength += 16;
        
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        NdrPointerMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                            (unsigned char __RPC_FAR *)pVal,
                            (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[114] );
        
        _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        NdrPointerFree( &_StubMsg,
                        (unsigned char __RPC_FAR *)pVal,
                        &__MIDL_TypeFormatString.Format[114] );
        
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IRCMLCSS_put_DialogStyle_Proxy( 
    IRCMLCSS __RPC_FAR * This,
    /* [in] */ IRCMLCSS __RPC_FAR *pVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      27);
        
        
        
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrInterfacePointerBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                           (unsigned char __RPC_FAR *)pVal,
                                           (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[118] );
            
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrInterfacePointerMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                                         (unsigned char __RPC_FAR *)pVal,
                                         (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[118] );
            
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[124] );
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLCSS_put_DialogStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    IRCMLCSS __RPC_FAR *pVal;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    pVal = 0;
    RpcTryFinally
        {
        if ( (_pRpcMessage->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[124] );
        
        NdrInterfacePointerUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                       (unsigned char __RPC_FAR * __RPC_FAR *)&pVal,
                                       (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[118],
                                       (unsigned char)0 );
        
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLCSS*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> put_DialogStyle((IRCMLCSS *) ((CStdStubBuffer *)This)->pvServerObject,pVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        NdrInterfacePointerFree( &_StubMsg,
                                 (unsigned char __RPC_FAR *)pVal,
                                 &__MIDL_TypeFormatString.Format[118] );
        
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLCSS_get_Visible_Proxy( 
    IRCMLCSS __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      28);
        
        
        
        if(!pVal)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[12] );
            
            *pVal = *(( BOOL __RPC_FAR * )_StubMsg.Buffer)++;
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[24],
                         ( void __RPC_FAR * )pVal);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLCSS_get_Visible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    BOOL _M36;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    BOOL __RPC_FAR *pVal;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( BOOL __RPC_FAR * )pVal = 0;
    RpcTryFinally
        {
        pVal = &_M36;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLCSS*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_Visible((IRCMLCSS *) ((CStdStubBuffer *)This)->pvServerObject,pVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U + 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( BOOL __RPC_FAR * )_StubMsg.Buffer)++ = *pVal;
        
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLCSS_get_Display_Proxy( 
    IRCMLCSS __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      29);
        
        
        
        if(!pVal)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[12] );
            
            *pVal = *(( BOOL __RPC_FAR * )_StubMsg.Buffer)++;
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[24],
                         ( void __RPC_FAR * )pVal);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLCSS_get_Display_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    BOOL _M37;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    BOOL __RPC_FAR *pVal;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( BOOL __RPC_FAR * )pVal = 0;
    RpcTryFinally
        {
        pVal = &_M37;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLCSS*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_Display((IRCMLCSS *) ((CStdStubBuffer *)This)->pvServerObject,pVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U + 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( BOOL __RPC_FAR * )_StubMsg.Buffer)++ = *pVal;
        
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLCSS_get_BorderWidth_Proxy( 
    IRCMLCSS __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *pVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      30);
        
        
        
        if(!pVal)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[12] );
            
            *pVal = *(( int __RPC_FAR * )_StubMsg.Buffer)++;
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[24],
                         ( void __RPC_FAR * )pVal);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLCSS_get_BorderWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    int _M38;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    int __RPC_FAR *pVal;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( int __RPC_FAR * )pVal = 0;
    RpcTryFinally
        {
        pVal = &_M38;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLCSS*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_BorderWidth((IRCMLCSS *) ((CStdStubBuffer *)This)->pvServerObject,pVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U + 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( int __RPC_FAR * )_StubMsg.Buffer)++ = *pVal;
        
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLCSS_get_BorderStyle_Proxy( 
    IRCMLCSS __RPC_FAR * This,
    /* [retval][out] */ LPWSTR __RPC_FAR *pVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    if(pVal)
        {
        *pVal = 0;
        }
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      31);
        
        
        
        if(!pVal)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[94] );
            
            NdrPointerUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                  (unsigned char __RPC_FAR * __RPC_FAR *)&pVal,
                                  (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[32],
                                  (unsigned char)0 );
            
            _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[32],
                         ( void __RPC_FAR * )pVal);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLCSS_get_BorderStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    LPWSTR _M41;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    LPWSTR __RPC_FAR *pVal;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( LPWSTR __RPC_FAR * )pVal = 0;
    RpcTryFinally
        {
        pVal = &_M41;
        _M41 = 0;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLCSS*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_BorderStyle((IRCMLCSS *) ((CStdStubBuffer *)This)->pvServerObject,pVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 16U + 10U;
        NdrPointerBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                              (unsigned char __RPC_FAR *)pVal,
                              (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[32] );
        
        _StubMsg.BufferLength += 16;
        
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        NdrPointerMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                            (unsigned char __RPC_FAR *)pVal,
                            (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[32] );
        
        _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        NdrPointerFree( &_StubMsg,
                        (unsigned char __RPC_FAR *)pVal,
                        &__MIDL_TypeFormatString.Format[32] );
        
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLCSS_get_GrowsWide_Proxy( 
    IRCMLCSS __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      32);
        
        
        
        if(!pVal)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[12] );
            
            *pVal = *(( BOOL __RPC_FAR * )_StubMsg.Buffer)++;
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[24],
                         ( void __RPC_FAR * )pVal);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLCSS_get_GrowsWide_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    BOOL _M42;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    BOOL __RPC_FAR *pVal;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( BOOL __RPC_FAR * )pVal = 0;
    RpcTryFinally
        {
        pVal = &_M42;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLCSS*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_GrowsWide((IRCMLCSS *) ((CStdStubBuffer *)This)->pvServerObject,pVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U + 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( BOOL __RPC_FAR * )_StubMsg.Buffer)++ = *pVal;
        
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLCSS_get_GrowsTall_Proxy( 
    IRCMLCSS __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      33);
        
        
        
        if(!pVal)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[12] );
            
            *pVal = *(( BOOL __RPC_FAR * )_StubMsg.Buffer)++;
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[24],
                         ( void __RPC_FAR * )pVal);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLCSS_get_GrowsTall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    BOOL _M43;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    BOOL __RPC_FAR *pVal;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( BOOL __RPC_FAR * )pVal = 0;
    RpcTryFinally
        {
        pVal = &_M43;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLCSS*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_GrowsTall((IRCMLCSS *) ((CStdStubBuffer *)This)->pvServerObject,pVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U + 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( BOOL __RPC_FAR * )_StubMsg.Buffer)++ = *pVal;
        
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLCSS_get_ClipHoriz_Proxy( 
    IRCMLCSS __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      34);
        
        
        
        if(!pVal)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[12] );
            
            *pVal = *(( BOOL __RPC_FAR * )_StubMsg.Buffer)++;
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[24],
                         ( void __RPC_FAR * )pVal);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLCSS_get_ClipHoriz_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    BOOL _M44;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    BOOL __RPC_FAR *pVal;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( BOOL __RPC_FAR * )pVal = 0;
    RpcTryFinally
        {
        pVal = &_M44;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLCSS*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_ClipHoriz((IRCMLCSS *) ((CStdStubBuffer *)This)->pvServerObject,pVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U + 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( BOOL __RPC_FAR * )_StubMsg.Buffer)++ = *pVal;
        
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLCSS_get_ClipVert_Proxy( 
    IRCMLCSS __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      35);
        
        
        
        if(!pVal)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[12] );
            
            *pVal = *(( BOOL __RPC_FAR * )_StubMsg.Buffer)++;
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[24],
                         ( void __RPC_FAR * )pVal);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLCSS_get_ClipVert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    BOOL _M45;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    BOOL __RPC_FAR *pVal;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( BOOL __RPC_FAR * )pVal = 0;
    RpcTryFinally
        {
        pVal = &_M45;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLCSS*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_ClipVert((IRCMLCSS *) ((CStdStubBuffer *)This)->pvServerObject,pVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U + 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( BOOL __RPC_FAR * )_StubMsg.Buffer)++ = *pVal;
        
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}

const CINTERFACE_PROXY_VTABLE(36) _IRCMLCSSProxyVtbl = 
{
    &IID_IRCMLCSS,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IRCMLNode_AttachParent_Proxy ,
    IRCMLNode_DetachParent_Proxy ,
    IRCMLNode_AcceptChild_Proxy ,
    IRCMLNode_DoEndChild_Proxy ,
    IRCMLNode_get_Type_Proxy ,
    IRCMLNode_InitNode_Proxy ,
    IRCMLNode_DisplayNode_Proxy ,
    IRCMLNode_ExitNode_Proxy ,
    IRCMLNode_get_Attr_Proxy ,
    IRCMLNode_put_Attr_Proxy ,
    IRCMLNode_IsType_Proxy ,
    IRCMLNode_YesDefault_Proxy ,
    IRCMLNode_YesNoDefault_Proxy ,
    IRCMLNode_ValueOf_Proxy ,
    IRCMLNode_SignedValueOf_Proxy ,
    IRCMLNode_get_StringType_Proxy ,
    IRCMLNode_GetChildEnum_Proxy ,
    IRCMLNode_GetUnknownEnum_Proxy ,
    IRCMLCSS_get_Font_Proxy ,
    IRCMLCSS_get_Brush_Proxy ,
    IRCMLCSS_get_Pen_Proxy ,
    IRCMLCSS_get_Color_Proxy ,
    IRCMLCSS_get_BkColor_Proxy ,
    IRCMLCSS_get_DialogStyle_Proxy ,
    IRCMLCSS_put_DialogStyle_Proxy ,
    IRCMLCSS_get_Visible_Proxy ,
    IRCMLCSS_get_Display_Proxy ,
    IRCMLCSS_get_BorderWidth_Proxy ,
    IRCMLCSS_get_BorderStyle_Proxy ,
    IRCMLCSS_get_GrowsWide_Proxy ,
    IRCMLCSS_get_GrowsTall_Proxy ,
    IRCMLCSS_get_ClipHoriz_Proxy ,
    IRCMLCSS_get_ClipVert_Proxy
};


static const PRPC_STUB_FUNCTION IRCMLCSS_table[] =
{
    IRCMLNode_AttachParent_Stub,
    IRCMLNode_DetachParent_Stub,
    IRCMLNode_AcceptChild_Stub,
    IRCMLNode_DoEndChild_Stub,
    IRCMLNode_get_Type_Stub,
    IRCMLNode_InitNode_Stub,
    IRCMLNode_DisplayNode_Stub,
    IRCMLNode_ExitNode_Stub,
    IRCMLNode_get_Attr_Stub,
    IRCMLNode_put_Attr_Stub,
    IRCMLNode_IsType_Stub,
    IRCMLNode_YesDefault_Stub,
    IRCMLNode_YesNoDefault_Stub,
    IRCMLNode_ValueOf_Stub,
    IRCMLNode_SignedValueOf_Stub,
    IRCMLNode_get_StringType_Stub,
    IRCMLNode_GetChildEnum_Stub,
    IRCMLNode_GetUnknownEnum_Stub,
    IRCMLCSS_get_Font_Stub,
    IRCMLCSS_get_Brush_Stub,
    IRCMLCSS_get_Pen_Stub,
    IRCMLCSS_get_Color_Stub,
    IRCMLCSS_get_BkColor_Stub,
    IRCMLCSS_get_DialogStyle_Stub,
    IRCMLCSS_put_DialogStyle_Stub,
    IRCMLCSS_get_Visible_Stub,
    IRCMLCSS_get_Display_Stub,
    IRCMLCSS_get_BorderWidth_Stub,
    IRCMLCSS_get_BorderStyle_Stub,
    IRCMLCSS_get_GrowsWide_Stub,
    IRCMLCSS_get_GrowsTall_Stub,
    IRCMLCSS_get_ClipHoriz_Stub,
    IRCMLCSS_get_ClipVert_Stub
};

const CInterfaceStubVtbl _IRCMLCSSStubVtbl =
{
    &IID_IRCMLCSS,
    0,
    36,
    &IRCMLCSS_table[-3],
    CStdStubBuffer_METHODS
};


/* Object interface: IRCMLHelp, ver. 0.0,
   GUID={0xB31FDC6A,0x9FB2,0x404e,{0x87,0x62,0xCC,0x26,0x7A,0x95,0xA4,0x24}} */


extern const MIDL_STUB_DESC Object_StubDesc;


#pragma code_seg(".orpc")

/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLHelp_get_TooltipText_Proxy( 
    IRCMLHelp __RPC_FAR * This,
    /* [retval][out] */ LPWSTR __RPC_FAR *pVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    if(pVal)
        {
        *pVal = 0;
        }
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      21);
        
        
        
        if(!pVal)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[94] );
            
            NdrPointerUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                  (unsigned char __RPC_FAR * __RPC_FAR *)&pVal,
                                  (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[32],
                                  (unsigned char)0 );
            
            _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[32],
                         ( void __RPC_FAR * )pVal);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLHelp_get_TooltipText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    LPWSTR _M48;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    LPWSTR __RPC_FAR *pVal;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( LPWSTR __RPC_FAR * )pVal = 0;
    RpcTryFinally
        {
        pVal = &_M48;
        _M48 = 0;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLHelp*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_TooltipText((IRCMLHelp *) ((CStdStubBuffer *)This)->pvServerObject,pVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 16U + 10U;
        NdrPointerBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                              (unsigned char __RPC_FAR *)pVal,
                              (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[32] );
        
        _StubMsg.BufferLength += 16;
        
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        NdrPointerMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                            (unsigned char __RPC_FAR *)pVal,
                            (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[32] );
        
        _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        NdrPointerFree( &_StubMsg,
                        (unsigned char __RPC_FAR *)pVal,
                        &__MIDL_TypeFormatString.Format[32] );
        
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLHelp_get_BalloonText_Proxy( 
    IRCMLHelp __RPC_FAR * This,
    /* [retval][out] */ LPWSTR __RPC_FAR *pVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    if(pVal)
        {
        *pVal = 0;
        }
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      22);
        
        
        
        if(!pVal)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[94] );
            
            NdrPointerUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                  (unsigned char __RPC_FAR * __RPC_FAR *)&pVal,
                                  (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[32],
                                  (unsigned char)0 );
            
            _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[32],
                         ( void __RPC_FAR * )pVal);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLHelp_get_BalloonText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    LPWSTR _M51;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    LPWSTR __RPC_FAR *pVal;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( LPWSTR __RPC_FAR * )pVal = 0;
    RpcTryFinally
        {
        pVal = &_M51;
        _M51 = 0;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLHelp*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_BalloonText((IRCMLHelp *) ((CStdStubBuffer *)This)->pvServerObject,pVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 16U + 10U;
        NdrPointerBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                              (unsigned char __RPC_FAR *)pVal,
                              (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[32] );
        
        _StubMsg.BufferLength += 16;
        
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        NdrPointerMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                            (unsigned char __RPC_FAR *)pVal,
                            (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[32] );
        
        _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        NdrPointerFree( &_StubMsg,
                        (unsigned char __RPC_FAR *)pVal,
                        &__MIDL_TypeFormatString.Format[32] );
        
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}

const CINTERFACE_PROXY_VTABLE(23) _IRCMLHelpProxyVtbl = 
{
    &IID_IRCMLHelp,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IRCMLNode_AttachParent_Proxy ,
    IRCMLNode_DetachParent_Proxy ,
    IRCMLNode_AcceptChild_Proxy ,
    IRCMLNode_DoEndChild_Proxy ,
    IRCMLNode_get_Type_Proxy ,
    IRCMLNode_InitNode_Proxy ,
    IRCMLNode_DisplayNode_Proxy ,
    IRCMLNode_ExitNode_Proxy ,
    IRCMLNode_get_Attr_Proxy ,
    IRCMLNode_put_Attr_Proxy ,
    IRCMLNode_IsType_Proxy ,
    IRCMLNode_YesDefault_Proxy ,
    IRCMLNode_YesNoDefault_Proxy ,
    IRCMLNode_ValueOf_Proxy ,
    IRCMLNode_SignedValueOf_Proxy ,
    IRCMLNode_get_StringType_Proxy ,
    IRCMLNode_GetChildEnum_Proxy ,
    IRCMLNode_GetUnknownEnum_Proxy ,
    IRCMLHelp_get_TooltipText_Proxy ,
    IRCMLHelp_get_BalloonText_Proxy
};


static const PRPC_STUB_FUNCTION IRCMLHelp_table[] =
{
    IRCMLNode_AttachParent_Stub,
    IRCMLNode_DetachParent_Stub,
    IRCMLNode_AcceptChild_Stub,
    IRCMLNode_DoEndChild_Stub,
    IRCMLNode_get_Type_Stub,
    IRCMLNode_InitNode_Stub,
    IRCMLNode_DisplayNode_Stub,
    IRCMLNode_ExitNode_Stub,
    IRCMLNode_get_Attr_Stub,
    IRCMLNode_put_Attr_Stub,
    IRCMLNode_IsType_Stub,
    IRCMLNode_YesDefault_Stub,
    IRCMLNode_YesNoDefault_Stub,
    IRCMLNode_ValueOf_Stub,
    IRCMLNode_SignedValueOf_Stub,
    IRCMLNode_get_StringType_Stub,
    IRCMLNode_GetChildEnum_Stub,
    IRCMLNode_GetUnknownEnum_Stub,
    IRCMLHelp_get_TooltipText_Stub,
    IRCMLHelp_get_BalloonText_Stub
};

const CInterfaceStubVtbl _IRCMLHelpStubVtbl =
{
    &IID_IRCMLHelp,
    0,
    23,
    &IRCMLHelp_table[-3],
    CStdStubBuffer_METHODS
};


/* Standard interface: __MIDL_itf_rcml_0212, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IRCMLControl, ver. 0.0,
   GUID={0xB943DDF7,0x21A7,0x42cb,{0xB6,0x96,0x34,0x5A,0xEB,0xC1,0x09,0x10}} */


extern const MIDL_STUB_DESC Object_StubDesc;


#pragma code_seg(".orpc")

/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_Class_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ LPWSTR __RPC_FAR *pVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    if(pVal)
        {
        *pVal = 0;
        }
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      21);
        
        
        
        if(!pVal)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[94] );
            
            NdrPointerUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                  (unsigned char __RPC_FAR * __RPC_FAR *)&pVal,
                                  (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[32],
                                  (unsigned char)0 );
            
            _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[32],
                         ( void __RPC_FAR * )pVal);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLControl_get_Class_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    LPWSTR _M54;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    LPWSTR __RPC_FAR *pVal;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( LPWSTR __RPC_FAR * )pVal = 0;
    RpcTryFinally
        {
        pVal = &_M54;
        _M54 = 0;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLControl*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_Class((IRCMLControl *) ((CStdStubBuffer *)This)->pvServerObject,pVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 16U + 10U;
        NdrPointerBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                              (unsigned char __RPC_FAR *)pVal,
                              (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[32] );
        
        _StubMsg.BufferLength += 16;
        
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        NdrPointerMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                            (unsigned char __RPC_FAR *)pVal,
                            (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[32] );
        
        _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        NdrPointerFree( &_StubMsg,
                        (unsigned char __RPC_FAR *)pVal,
                        &__MIDL_TypeFormatString.Format[32] );
        
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_Style_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ DWORD __RPC_FAR *pVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      22);
        
        
        
        if(!pVal)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[12] );
            
            *pVal = *(( DWORD __RPC_FAR * )_StubMsg.Buffer)++;
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[24],
                         ( void __RPC_FAR * )pVal);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLControl_get_Style_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    DWORD _M55;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    DWORD __RPC_FAR *pVal;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( DWORD __RPC_FAR * )pVal = 0;
    RpcTryFinally
        {
        pVal = &_M55;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLControl*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_Style((IRCMLControl *) ((CStdStubBuffer *)This)->pvServerObject,pVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U + 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( DWORD __RPC_FAR * )_StubMsg.Buffer)++ = *pVal;
        
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_StyleEx_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ DWORD __RPC_FAR *pVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      23);
        
        
        
        if(!pVal)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[12] );
            
            *pVal = *(( DWORD __RPC_FAR * )_StubMsg.Buffer)++;
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[24],
                         ( void __RPC_FAR * )pVal);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLControl_get_StyleEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    DWORD _M56;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    DWORD __RPC_FAR *pVal;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( DWORD __RPC_FAR * )pVal = 0;
    RpcTryFinally
        {
        pVal = &_M56;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLControl*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_StyleEx((IRCMLControl *) ((CStdStubBuffer *)This)->pvServerObject,pVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U + 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( DWORD __RPC_FAR * )_StubMsg.Buffer)++ = *pVal;
        
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_Text_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ LPWSTR __RPC_FAR *pVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    if(pVal)
        {
        *pVal = 0;
        }
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      24);
        
        
        
        if(!pVal)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[94] );
            
            NdrPointerUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                  (unsigned char __RPC_FAR * __RPC_FAR *)&pVal,
                                  (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[32],
                                  (unsigned char)0 );
            
            _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[32],
                         ( void __RPC_FAR * )pVal);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLControl_get_Text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    LPWSTR _M59;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    LPWSTR __RPC_FAR *pVal;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( LPWSTR __RPC_FAR * )pVal = 0;
    RpcTryFinally
        {
        pVal = &_M59;
        _M59 = 0;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLControl*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_Text((IRCMLControl *) ((CStdStubBuffer *)This)->pvServerObject,pVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 16U + 10U;
        NdrPointerBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                              (unsigned char __RPC_FAR *)pVal,
                              (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[32] );
        
        _StubMsg.BufferLength += 16;
        
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        NdrPointerMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                            (unsigned char __RPC_FAR *)pVal,
                            (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[32] );
        
        _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        NdrPointerFree( &_StubMsg,
                        (unsigned char __RPC_FAR *)pVal,
                        &__MIDL_TypeFormatString.Format[32] );
        
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRCMLControl_OnInit_Proxy( 
    IRCMLControl __RPC_FAR * This,
    HWND h)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      25);
        
        
        
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 8U;
            NdrUserMarshalBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                      (unsigned char __RPC_FAR *)&h,
                                      (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[140] );
            
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrUserMarshalMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                                    (unsigned char __RPC_FAR *)&h,
                                    (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[140] );
            
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[130] );
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLControl_OnInit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    void __RPC_FAR *_p_h;
    HWND h;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    _p_h = &h;
    MIDL_memset(
               _p_h,
               0,
               sizeof( HWND  ));
    RpcTryFinally
        {
        if ( (_pRpcMessage->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[130] );
        
        NdrUserMarshalUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                  (unsigned char __RPC_FAR * __RPC_FAR *)&_p_h,
                                  (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[140],
                                  (unsigned char)0 );
        
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLControl*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> OnInit((IRCMLControl *) ((CStdStubBuffer *)This)->pvServerObject,h);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        NdrUserMarshalFree( &_StubMsg,
                            (unsigned char __RPC_FAR *)&h,
                            &__MIDL_TypeFormatString.Format[140] );
        
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_Window_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ HWND __RPC_FAR *pVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    if(pVal)
        {
        MIDL_memset(
               pVal,
               0,
               sizeof( HWND  ));
        }
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      26);
        
        
        
        if(!pVal)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[136] );
            
            NdrUserMarshalUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                      (unsigned char __RPC_FAR * __RPC_FAR *)&pVal,
                                      (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[154],
                                      (unsigned char)0 );
            
            _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[150],
                         ( void __RPC_FAR * )pVal);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLControl_get_Window_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    HWND _M60;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    HWND __RPC_FAR *pVal;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( HWND __RPC_FAR * )pVal = 0;
    RpcTryFinally
        {
        pVal = &_M60;
        MIDL_memset(
               pVal,
               0,
               sizeof( HWND  ));
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLControl*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_Window((IRCMLControl *) ((CStdStubBuffer *)This)->pvServerObject,pVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 8U + 11U;
        NdrUserMarshalBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                  (unsigned char __RPC_FAR *)pVal,
                                  (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[154] );
        
        _StubMsg.BufferLength += 16;
        
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        NdrUserMarshalMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                                (unsigned char __RPC_FAR *)pVal,
                                (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[154] );
        
        _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        NdrPointerFree( &_StubMsg,
                        (unsigned char __RPC_FAR *)pVal,
                        &__MIDL_TypeFormatString.Format[150] );
        
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IRCMLControl_put_Window_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [in] */ HWND pVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      27);
        
        
        
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 8U;
            NdrUserMarshalBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                      (unsigned char __RPC_FAR *)&pVal,
                                      (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[140] );
            
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrUserMarshalMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                                    (unsigned char __RPC_FAR *)&pVal,
                                    (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[140] );
            
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[130] );
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLControl_put_Window_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    void __RPC_FAR *_p_pVal;
    HWND pVal;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    _p_pVal = &pVal;
    MIDL_memset(
               _p_pVal,
               0,
               sizeof( HWND  ));
    RpcTryFinally
        {
        if ( (_pRpcMessage->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[130] );
        
        NdrUserMarshalUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                  (unsigned char __RPC_FAR * __RPC_FAR *)&_p_pVal,
                                  (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[140],
                                  (unsigned char)0 );
        
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLControl*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> put_Window((IRCMLControl *) ((CStdStubBuffer *)This)->pvServerObject,pVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        NdrUserMarshalFree( &_StubMsg,
                            (unsigned char __RPC_FAR *)&pVal,
                            &__MIDL_TypeFormatString.Format[140] );
        
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRCMLControl_OnDestroy_Proxy( 
    IRCMLControl __RPC_FAR * This,
    HWND h,
    WORD wLastCommand)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      28);
        
        
        
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 8U + 5U;
            NdrUserMarshalBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                      (unsigned char __RPC_FAR *)&h,
                                      (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[140] );
            
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrUserMarshalMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                                    (unsigned char __RPC_FAR *)&h,
                                    (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[140] );
            
            _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 1) & ~ 0x1);
            *(( WORD __RPC_FAR * )_StubMsg.Buffer)++ = wLastCommand;
            
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[142] );
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLControl_OnDestroy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    void __RPC_FAR *_p_h;
    HWND h;
    WORD wLastCommand;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    _p_h = &h;
    MIDL_memset(
               _p_h,
               0,
               sizeof( HWND  ));
    RpcTryFinally
        {
        if ( (_pRpcMessage->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[142] );
        
        NdrUserMarshalUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                  (unsigned char __RPC_FAR * __RPC_FAR *)&_p_h,
                                  (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[140],
                                  (unsigned char)0 );
        
        _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 1) & ~ 0x1);
        wLastCommand = *(( WORD __RPC_FAR * )_StubMsg.Buffer)++;
        
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLControl*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> OnDestroy(
             (IRCMLControl *) ((CStdStubBuffer *)This)->pvServerObject,
             h,
             wLastCommand);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        NdrUserMarshalFree( &_StubMsg,
                            (unsigned char __RPC_FAR *)&h,
                            &__MIDL_TypeFormatString.Format[140] );
        
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_ID_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ LPWSTR __RPC_FAR *pVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    if(pVal)
        {
        *pVal = 0;
        }
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      29);
        
        
        
        if(!pVal)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[94] );
            
            NdrPointerUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                  (unsigned char __RPC_FAR * __RPC_FAR *)&pVal,
                                  (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[32],
                                  (unsigned char)0 );
            
            _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[32],
                         ( void __RPC_FAR * )pVal);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLControl_get_ID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    LPWSTR _M63;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    LPWSTR __RPC_FAR *pVal;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( LPWSTR __RPC_FAR * )pVal = 0;
    RpcTryFinally
        {
        pVal = &_M63;
        _M63 = 0;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLControl*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_ID((IRCMLControl *) ((CStdStubBuffer *)This)->pvServerObject,pVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 16U + 10U;
        NdrPointerBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                              (unsigned char __RPC_FAR *)pVal,
                              (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[32] );
        
        _StubMsg.BufferLength += 16;
        
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        NdrPointerMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                            (unsigned char __RPC_FAR *)pVal,
                            (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[32] );
        
        _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        NdrPointerFree( &_StubMsg,
                        (unsigned char __RPC_FAR *)pVal,
                        &__MIDL_TypeFormatString.Format[32] );
        
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_Width_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *pVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      30);
        
        
        
        if(!pVal)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[12] );
            
            *pVal = *(( LONG __RPC_FAR * )_StubMsg.Buffer)++;
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[24],
                         ( void __RPC_FAR * )pVal);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLControl_get_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    LONG _M64;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    LONG __RPC_FAR *pVal;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( LONG __RPC_FAR * )pVal = 0;
    RpcTryFinally
        {
        pVal = &_M64;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLControl*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_Width((IRCMLControl *) ((CStdStubBuffer *)This)->pvServerObject,pVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U + 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( LONG __RPC_FAR * )_StubMsg.Buffer)++ = *pVal;
        
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_Height_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *pVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      31);
        
        
        
        if(!pVal)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[12] );
            
            *pVal = *(( LONG __RPC_FAR * )_StubMsg.Buffer)++;
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[24],
                         ( void __RPC_FAR * )pVal);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLControl_get_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    LONG _M65;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    LONG __RPC_FAR *pVal;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( LONG __RPC_FAR * )pVal = 0;
    RpcTryFinally
        {
        pVal = &_M65;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLControl*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_Height((IRCMLControl *) ((CStdStubBuffer *)This)->pvServerObject,pVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U + 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( LONG __RPC_FAR * )_StubMsg.Buffer)++ = *pVal;
        
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IRCMLControl_put_Width_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [in] */ LONG Val)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      32);
        
        
        
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 4U;
            NdrProxyGetBuffer(This, &_StubMsg);
            *(( LONG __RPC_FAR * )_StubMsg.Buffer)++ = Val;
            
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[150] );
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLControl_put_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    LONG Val;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    RpcTryFinally
        {
        if ( (_pRpcMessage->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[150] );
        
        Val = *(( LONG __RPC_FAR * )_StubMsg.Buffer)++;
        
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLControl*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> put_Width((IRCMLControl *) ((CStdStubBuffer *)This)->pvServerObject,Val);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IRCMLControl_put_Height_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [in] */ LONG Val)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      33);
        
        
        
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 4U;
            NdrProxyGetBuffer(This, &_StubMsg);
            *(( LONG __RPC_FAR * )_StubMsg.Buffer)++ = Val;
            
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[150] );
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLControl_put_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    LONG Val;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    RpcTryFinally
        {
        if ( (_pRpcMessage->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[150] );
        
        Val = *(( LONG __RPC_FAR * )_StubMsg.Buffer)++;
        
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLControl*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> put_Height((IRCMLControl *) ((CStdStubBuffer *)This)->pvServerObject,Val);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_X_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *pVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      34);
        
        
        
        if(!pVal)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[12] );
            
            *pVal = *(( LONG __RPC_FAR * )_StubMsg.Buffer)++;
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[24],
                         ( void __RPC_FAR * )pVal);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLControl_get_X_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    LONG _M66;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    LONG __RPC_FAR *pVal;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( LONG __RPC_FAR * )pVal = 0;
    RpcTryFinally
        {
        pVal = &_M66;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLControl*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_X((IRCMLControl *) ((CStdStubBuffer *)This)->pvServerObject,pVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U + 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( LONG __RPC_FAR * )_StubMsg.Buffer)++ = *pVal;
        
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_Y_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *pVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      35);
        
        
        
        if(!pVal)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[12] );
            
            *pVal = *(( LONG __RPC_FAR * )_StubMsg.Buffer)++;
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[24],
                         ( void __RPC_FAR * )pVal);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLControl_get_Y_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    LONG _M67;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    LONG __RPC_FAR *pVal;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( LONG __RPC_FAR * )pVal = 0;
    RpcTryFinally
        {
        pVal = &_M67;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLControl*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_Y((IRCMLControl *) ((CStdStubBuffer *)This)->pvServerObject,pVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U + 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( LONG __RPC_FAR * )_StubMsg.Buffer)++ = *pVal;
        
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IRCMLControl_put_X_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [in] */ LONG Val)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      36);
        
        
        
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 4U;
            NdrProxyGetBuffer(This, &_StubMsg);
            *(( LONG __RPC_FAR * )_StubMsg.Buffer)++ = Val;
            
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[150] );
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLControl_put_X_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    LONG Val;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    RpcTryFinally
        {
        if ( (_pRpcMessage->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[150] );
        
        Val = *(( LONG __RPC_FAR * )_StubMsg.Buffer)++;
        
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLControl*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> put_X((IRCMLControl *) ((CStdStubBuffer *)This)->pvServerObject,Val);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IRCMLControl_put_Y_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [in] */ LONG Val)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      37);
        
        
        
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 4U;
            NdrProxyGetBuffer(This, &_StubMsg);
            *(( LONG __RPC_FAR * )_StubMsg.Buffer)++ = Val;
            
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[150] );
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLControl_put_Y_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    LONG Val;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    RpcTryFinally
        {
        if ( (_pRpcMessage->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[150] );
        
        Val = *(( LONG __RPC_FAR * )_StubMsg.Buffer)++;
        
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLControl*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> put_Y((IRCMLControl *) ((CStdStubBuffer *)This)->pvServerObject,Val);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_RelativeTo_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ IRCMLControl __RPC_FAR *__RPC_FAR *pVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    if(pVal)
        {
        MIDL_memset(
               pVal,
               0,
               sizeof( IRCMLControl __RPC_FAR *__RPC_FAR * ));
        }
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      38);
        
        
        
        if(!pVal)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[154] );
            
            NdrPointerUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                  (unsigned char __RPC_FAR * __RPC_FAR *)&pVal,
                                  (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[164],
                                  (unsigned char)0 );
            
            _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[164],
                         ( void __RPC_FAR * )pVal);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLControl_get_RelativeTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    IRCMLControl __RPC_FAR *_M68;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    IRCMLControl __RPC_FAR *__RPC_FAR *pVal;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( IRCMLControl __RPC_FAR *__RPC_FAR * )pVal = 0;
    RpcTryFinally
        {
        pVal = &_M68;
        _M68 = 0;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLControl*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_RelativeTo((IRCMLControl *) ((CStdStubBuffer *)This)->pvServerObject,pVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 0U + 4U;
        NdrPointerBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                              (unsigned char __RPC_FAR *)pVal,
                              (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[164] );
        
        _StubMsg.BufferLength += 16;
        
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        NdrPointerMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                            (unsigned char __RPC_FAR *)pVal,
                            (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[164] );
        
        _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        NdrPointerFree( &_StubMsg,
                        (unsigned char __RPC_FAR *)pVal,
                        &__MIDL_TypeFormatString.Format[164] );
        
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IRCMLControl_put_RelativeTo_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [in] */ IRCMLControl __RPC_FAR *newVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      39);
        
        
        
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrInterfacePointerBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                           (unsigned char __RPC_FAR *)newVal,
                                           (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[168] );
            
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrInterfacePointerMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                                         (unsigned char __RPC_FAR *)newVal,
                                         (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[168] );
            
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[160] );
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLControl_put_RelativeTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    IRCMLControl __RPC_FAR *newVal;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    newVal = 0;
    RpcTryFinally
        {
        if ( (_pRpcMessage->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[160] );
        
        NdrInterfacePointerUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                       (unsigned char __RPC_FAR * __RPC_FAR *)&newVal,
                                       (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[168],
                                       (unsigned char)0 );
        
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLControl*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> put_RelativeTo((IRCMLControl *) ((CStdStubBuffer *)This)->pvServerObject,newVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        NdrInterfacePointerFree( &_StubMsg,
                                 (unsigned char __RPC_FAR *)newVal,
                                 &__MIDL_TypeFormatString.Format[168] );
        
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_Location_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ RECT __RPC_FAR *pVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    if(pVal)
        {
        MIDL_memset(
               pVal,
               0,
               sizeof( RECT  ));
        }
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      40);
        
        
        
        if(!pVal)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[166] );
            
            NdrSimpleStructUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                       (unsigned char __RPC_FAR * __RPC_FAR *)&pVal,
                                       (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[190],
                                       (unsigned char)0 );
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[186],
                         ( void __RPC_FAR * )pVal);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLControl_get_Location_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    RECT _pValM;
    RECT __RPC_FAR *pVal;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( RECT __RPC_FAR * )pVal = 0;
    RpcTryFinally
        {
        pVal = &_pValM;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLControl*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_Location((IRCMLControl *) ((CStdStubBuffer *)This)->pvServerObject,pVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 0U + 11U;
        NdrSimpleStructBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                   (unsigned char __RPC_FAR *)pVal,
                                   (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[190] );
        
        _StubMsg.BufferLength += 16;
        
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        NdrSimpleStructMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                                 (unsigned char __RPC_FAR *)pVal,
                                 (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[190] );
        
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_RelativeLocn_Proxy( 
    IRCMLControl __RPC_FAR * This,
    RECT rect,
    /* [retval][out] */ RECT __RPC_FAR *pVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    if(pVal)
        {
        MIDL_memset(
               pVal,
               0,
               sizeof( RECT  ));
        }
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      41);
        
        
        
        if(!pVal)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrSimpleStructBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                       (unsigned char __RPC_FAR *)&rect,
                                       (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[190] );
            
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrSimpleStructMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                                     (unsigned char __RPC_FAR *)&rect,
                                     (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[190] );
            
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[172] );
            
            NdrSimpleStructUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                       (unsigned char __RPC_FAR * __RPC_FAR *)&pVal,
                                       (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[190],
                                       (unsigned char)0 );
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[186],
                         ( void __RPC_FAR * )pVal);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLControl_get_RelativeLocn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    RECT _pValM;
    void __RPC_FAR *_p_rect;
    RECT __RPC_FAR *pVal;
    RECT rect;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    _p_rect = &rect;
    MIDL_memset(
               _p_rect,
               0,
               sizeof( RECT  ));
    ( RECT __RPC_FAR * )pVal = 0;
    RpcTryFinally
        {
        if ( (_pRpcMessage->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[172] );
        
        NdrSimpleStructUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                   (unsigned char __RPC_FAR * __RPC_FAR *)&_p_rect,
                                   (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[190],
                                   (unsigned char)0 );
        
        pVal = &_pValM;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLControl*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_RelativeLocn(
                    (IRCMLControl *) ((CStdStubBuffer *)This)->pvServerObject,
                    rect,
                    pVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 0U + 11U;
        NdrSimpleStructBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                   (unsigned char __RPC_FAR *)pVal,
                                   (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[190] );
        
        _StubMsg.BufferLength += 16;
        
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        NdrSimpleStructMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                                 (unsigned char __RPC_FAR *)pVal,
                                 (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[190] );
        
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_RelativeID_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ LPWSTR __RPC_FAR *pVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    if(pVal)
        {
        *pVal = 0;
        }
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      42);
        
        
        
        if(!pVal)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[94] );
            
            NdrPointerUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                  (unsigned char __RPC_FAR * __RPC_FAR *)&pVal,
                                  (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[32],
                                  (unsigned char)0 );
            
            _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[32],
                         ( void __RPC_FAR * )pVal);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLControl_get_RelativeID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    LPWSTR _M71;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    LPWSTR __RPC_FAR *pVal;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( LPWSTR __RPC_FAR * )pVal = 0;
    RpcTryFinally
        {
        pVal = &_M71;
        _M71 = 0;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLControl*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_RelativeID((IRCMLControl *) ((CStdStubBuffer *)This)->pvServerObject,pVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 16U + 10U;
        NdrPointerBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                              (unsigned char __RPC_FAR *)pVal,
                              (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[32] );
        
        _StubMsg.BufferLength += 16;
        
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        NdrPointerMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                            (unsigned char __RPC_FAR *)pVal,
                            (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[32] );
        
        _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        NdrPointerFree( &_StubMsg,
                        (unsigned char __RPC_FAR *)pVal,
                        &__MIDL_TypeFormatString.Format[32] );
        
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_RelativeType_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ RELATIVETYPE_ENUM __RPC_FAR *pVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      43);
        
        
        
        if(!pVal)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[182] );
            
            NdrPointerUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                  (unsigned char __RPC_FAR * __RPC_FAR *)&pVal,
                                  (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[200],
                                  (unsigned char)0 );
            
            _StubMsg.Buffer += 2;
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[200],
                         ( void __RPC_FAR * )pVal);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLControl_get_RelativeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    RELATIVETYPE_ENUM _M72;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    RELATIVETYPE_ENUM __RPC_FAR *pVal;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( RELATIVETYPE_ENUM __RPC_FAR * )pVal = 0;
    RpcTryFinally
        {
        pVal = &_M72;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLControl*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_RelativeType((IRCMLControl *) ((CStdStubBuffer *)This)->pvServerObject,pVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 2U + 6U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        NdrPointerMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                            (unsigned char __RPC_FAR *)pVal,
                            (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[200] );
        
        _StubMsg.Buffer += 2;
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_Clipped_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ SIZE __RPC_FAR *pVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    if(pVal)
        {
        MIDL_memset(
               pVal,
               0,
               sizeof( SIZE  ));
        }
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      44);
        
        
        
        if(!pVal)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[188] );
            
            NdrSimpleStructUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                       (unsigned char __RPC_FAR * __RPC_FAR *)&pVal,
                                       (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[208],
                                       (unsigned char)0 );
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[204],
                         ( void __RPC_FAR * )pVal);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLControl_get_Clipped_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    SIZE _pValM;
    SIZE __RPC_FAR *pVal;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( SIZE __RPC_FAR * )pVal = 0;
    RpcTryFinally
        {
        pVal = &_pValM;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLControl*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_Clipped((IRCMLControl *) ((CStdStubBuffer *)This)->pvServerObject,pVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 0U + 11U;
        NdrSimpleStructBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                   (unsigned char __RPC_FAR *)pVal,
                                   (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[208] );
        
        _StubMsg.BufferLength += 16;
        
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        NdrSimpleStructMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                                 (unsigned char __RPC_FAR *)pVal,
                                 (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[208] );
        
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_GrowsWide_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      45);
        
        
        
        if(!pVal)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[12] );
            
            *pVal = *(( BOOL __RPC_FAR * )_StubMsg.Buffer)++;
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[24],
                         ( void __RPC_FAR * )pVal);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLControl_get_GrowsWide_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    BOOL _M73;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    BOOL __RPC_FAR *pVal;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( BOOL __RPC_FAR * )pVal = 0;
    RpcTryFinally
        {
        pVal = &_M73;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLControl*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_GrowsWide((IRCMLControl *) ((CStdStubBuffer *)This)->pvServerObject,pVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U + 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( BOOL __RPC_FAR * )_StubMsg.Buffer)++ = *pVal;
        
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_GrowsTall_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      46);
        
        
        
        if(!pVal)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[12] );
            
            *pVal = *(( BOOL __RPC_FAR * )_StubMsg.Buffer)++;
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[24],
                         ( void __RPC_FAR * )pVal);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLControl_get_GrowsTall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    BOOL _M74;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    BOOL __RPC_FAR *pVal;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( BOOL __RPC_FAR * )pVal = 0;
    RpcTryFinally
        {
        pVal = &_M74;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLControl*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_GrowsTall((IRCMLControl *) ((CStdStubBuffer *)This)->pvServerObject,pVal);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U + 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( BOOL __RPC_FAR * )_StubMsg.Buffer)++ = *pVal;
        
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_Container_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ IRCMLContainer __RPC_FAR *__RPC_FAR *pContainer)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    if(pContainer)
        {
        MIDL_memset(
               pContainer,
               0,
               sizeof( IRCMLContainer __RPC_FAR *__RPC_FAR * ));
        }
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      47);
        
        
        
        if(!pContainer)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[194] );
            
            NdrPointerUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                  (unsigned char __RPC_FAR * __RPC_FAR *)&pContainer,
                                  (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[216],
                                  (unsigned char)0 );
            
            _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[216],
                         ( void __RPC_FAR * )pContainer);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLControl_get_Container_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    IRCMLContainer __RPC_FAR *_M75;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    IRCMLContainer __RPC_FAR *__RPC_FAR *pContainer;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( IRCMLContainer __RPC_FAR *__RPC_FAR * )pContainer = 0;
    RpcTryFinally
        {
        pContainer = &_M75;
        _M75 = 0;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLControl*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_Container((IRCMLControl *) ((CStdStubBuffer *)This)->pvServerObject,pContainer);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 0U + 4U;
        NdrPointerBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                              (unsigned char __RPC_FAR *)pContainer,
                              (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[216] );
        
        _StubMsg.BufferLength += 16;
        
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        NdrPointerMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                            (unsigned char __RPC_FAR *)pContainer,
                            (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[216] );
        
        _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        NdrPointerFree( &_StubMsg,
                        (unsigned char __RPC_FAR *)pContainer,
                        &__MIDL_TypeFormatString.Format[216] );
        
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IRCMLControl_put_Container_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [in] */ IRCMLContainer __RPC_FAR *pContainer)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      48);
        
        
        
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrInterfacePointerBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                           (unsigned char __RPC_FAR *)pContainer,
                                           (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[220] );
            
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrInterfacePointerMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                                         (unsigned char __RPC_FAR *)pContainer,
                                         (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[220] );
            
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[200] );
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLControl_put_Container_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    IRCMLContainer __RPC_FAR *pContainer;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    pContainer = 0;
    RpcTryFinally
        {
        if ( (_pRpcMessage->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[200] );
        
        NdrInterfacePointerUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                       (unsigned char __RPC_FAR * __RPC_FAR *)&pContainer,
                                       (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[220],
                                       (unsigned char)0 );
        
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLControl*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> put_Container((IRCMLControl *) ((CStdStubBuffer *)This)->pvServerObject,pContainer);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        NdrInterfacePointerFree( &_StubMsg,
                                 (unsigned char __RPC_FAR *)pContainer,
                                 &__MIDL_TypeFormatString.Format[220] );
        
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_CSS_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ IRCMLCSS __RPC_FAR *__RPC_FAR *pCSS)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    if(pCSS)
        {
        MIDL_memset(
               pCSS,
               0,
               sizeof( IRCMLCSS __RPC_FAR *__RPC_FAR * ));
        }
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      49);
        
        
        
        if(!pCSS)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[118] );
            
            NdrPointerUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                  (unsigned char __RPC_FAR * __RPC_FAR *)&pCSS,
                                  (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[114],
                                  (unsigned char)0 );
            
            _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[114],
                         ( void __RPC_FAR * )pCSS);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLControl_get_CSS_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    IRCMLCSS __RPC_FAR *_M76;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    IRCMLCSS __RPC_FAR *__RPC_FAR *pCSS;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( IRCMLCSS __RPC_FAR *__RPC_FAR * )pCSS = 0;
    RpcTryFinally
        {
        pCSS = &_M76;
        _M76 = 0;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLControl*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_CSS((IRCMLControl *) ((CStdStubBuffer *)This)->pvServerObject,pCSS);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 0U + 4U;
        NdrPointerBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                              (unsigned char __RPC_FAR *)pCSS,
                              (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[114] );
        
        _StubMsg.BufferLength += 16;
        
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        NdrPointerMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                            (unsigned char __RPC_FAR *)pCSS,
                            (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[114] );
        
        _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        NdrPointerFree( &_StubMsg,
                        (unsigned char __RPC_FAR *)pCSS,
                        &__MIDL_TypeFormatString.Format[114] );
        
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IRCMLControl_put_CSS_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [in] */ IRCMLCSS __RPC_FAR *pCSS)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      50);
        
        
        
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrInterfacePointerBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                           (unsigned char __RPC_FAR *)pCSS,
                                           (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[118] );
            
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrInterfacePointerMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                                         (unsigned char __RPC_FAR *)pCSS,
                                         (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[118] );
            
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[124] );
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLControl_put_CSS_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    IRCMLCSS __RPC_FAR *pCSS;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    pCSS = 0;
    RpcTryFinally
        {
        if ( (_pRpcMessage->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[124] );
        
        NdrInterfacePointerUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                       (unsigned char __RPC_FAR * __RPC_FAR *)&pCSS,
                                       (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[118],
                                       (unsigned char)0 );
        
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLControl*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> put_CSS((IRCMLControl *) ((CStdStubBuffer *)This)->pvServerObject,pCSS);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 4U;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        NdrInterfacePointerFree( &_StubMsg,
                                 (unsigned char __RPC_FAR *)pCSS,
                                 &__MIDL_TypeFormatString.Format[118] );
        
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRCMLControl_get_Help_Proxy( 
    IRCMLControl __RPC_FAR * This,
    /* [retval][out] */ IRCMLHelp __RPC_FAR *__RPC_FAR *pHelp)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    if(pHelp)
        {
        MIDL_memset(
               pHelp,
               0,
               sizeof( IRCMLHelp __RPC_FAR *__RPC_FAR * ));
        }
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      51);
        
        
        
        if(!pHelp)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[206] );
            
            NdrPointerUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                  (unsigned char __RPC_FAR * __RPC_FAR *)&pHelp,
                                  (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[238],
                                  (unsigned char)0 );
            
            _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[238],
                         ( void __RPC_FAR * )pHelp);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLControl_get_Help_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    IRCMLHelp __RPC_FAR *_M77;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    IRCMLHelp __RPC_FAR *__RPC_FAR *pHelp;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    ( IRCMLHelp __RPC_FAR *__RPC_FAR * )pHelp = 0;
    RpcTryFinally
        {
        pHelp = &_M77;
        _M77 = 0;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLControl*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> get_Help((IRCMLControl *) ((CStdStubBuffer *)This)->pvServerObject,pHelp);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 0U + 4U;
        NdrPointerBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                              (unsigned char __RPC_FAR *)pHelp,
                              (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[238] );
        
        _StubMsg.BufferLength += 16;
        
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        NdrPointerMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                            (unsigned char __RPC_FAR *)pHelp,
                            (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[238] );
        
        _StubMsg.Buffer = (unsigned char __RPC_FAR *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        NdrPointerFree( &_StubMsg,
                        (unsigned char __RPC_FAR *)pHelp,
                        &__MIDL_TypeFormatString.Format[238] );
        
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}

const CINTERFACE_PROXY_VTABLE(52) _IRCMLControlProxyVtbl = 
{
    &IID_IRCMLControl,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IRCMLNode_AttachParent_Proxy ,
    IRCMLNode_DetachParent_Proxy ,
    IRCMLNode_AcceptChild_Proxy ,
    IRCMLNode_DoEndChild_Proxy ,
    IRCMLNode_get_Type_Proxy ,
    IRCMLNode_InitNode_Proxy ,
    IRCMLNode_DisplayNode_Proxy ,
    IRCMLNode_ExitNode_Proxy ,
    IRCMLNode_get_Attr_Proxy ,
    IRCMLNode_put_Attr_Proxy ,
    IRCMLNode_IsType_Proxy ,
    IRCMLNode_YesDefault_Proxy ,
    IRCMLNode_YesNoDefault_Proxy ,
    IRCMLNode_ValueOf_Proxy ,
    IRCMLNode_SignedValueOf_Proxy ,
    IRCMLNode_get_StringType_Proxy ,
    IRCMLNode_GetChildEnum_Proxy ,
    IRCMLNode_GetUnknownEnum_Proxy ,
    IRCMLControl_get_Class_Proxy ,
    IRCMLControl_get_Style_Proxy ,
    IRCMLControl_get_StyleEx_Proxy ,
    IRCMLControl_get_Text_Proxy ,
    IRCMLControl_OnInit_Proxy ,
    IRCMLControl_get_Window_Proxy ,
    IRCMLControl_put_Window_Proxy ,
    IRCMLControl_OnDestroy_Proxy ,
    IRCMLControl_get_ID_Proxy ,
    IRCMLControl_get_Width_Proxy ,
    IRCMLControl_get_Height_Proxy ,
    IRCMLControl_put_Width_Proxy ,
    IRCMLControl_put_Height_Proxy ,
    IRCMLControl_get_X_Proxy ,
    IRCMLControl_get_Y_Proxy ,
    IRCMLControl_put_X_Proxy ,
    IRCMLControl_put_Y_Proxy ,
    IRCMLControl_get_RelativeTo_Proxy ,
    IRCMLControl_put_RelativeTo_Proxy ,
    IRCMLControl_get_Location_Proxy ,
    IRCMLControl_get_RelativeLocn_Proxy ,
    IRCMLControl_get_RelativeID_Proxy ,
    IRCMLControl_get_RelativeType_Proxy ,
    IRCMLControl_get_Clipped_Proxy ,
    IRCMLControl_get_GrowsWide_Proxy ,
    IRCMLControl_get_GrowsTall_Proxy ,
    IRCMLControl_get_Container_Proxy ,
    IRCMLControl_put_Container_Proxy ,
    IRCMLControl_get_CSS_Proxy ,
    IRCMLControl_put_CSS_Proxy ,
    IRCMLControl_get_Help_Proxy
};


static const PRPC_STUB_FUNCTION IRCMLControl_table[] =
{
    IRCMLNode_AttachParent_Stub,
    IRCMLNode_DetachParent_Stub,
    IRCMLNode_AcceptChild_Stub,
    IRCMLNode_DoEndChild_Stub,
    IRCMLNode_get_Type_Stub,
    IRCMLNode_InitNode_Stub,
    IRCMLNode_DisplayNode_Stub,
    IRCMLNode_ExitNode_Stub,
    IRCMLNode_get_Attr_Stub,
    IRCMLNode_put_Attr_Stub,
    IRCMLNode_IsType_Stub,
    IRCMLNode_YesDefault_Stub,
    IRCMLNode_YesNoDefault_Stub,
    IRCMLNode_ValueOf_Stub,
    IRCMLNode_SignedValueOf_Stub,
    IRCMLNode_get_StringType_Stub,
    IRCMLNode_GetChildEnum_Stub,
    IRCMLNode_GetUnknownEnum_Stub,
    IRCMLControl_get_Class_Stub,
    IRCMLControl_get_Style_Stub,
    IRCMLControl_get_StyleEx_Stub,
    IRCMLControl_get_Text_Stub,
    IRCMLControl_OnInit_Stub,
    IRCMLControl_get_Window_Stub,
    IRCMLControl_put_Window_Stub,
    IRCMLControl_OnDestroy_Stub,
    IRCMLControl_get_ID_Stub,
    IRCMLControl_get_Width_Stub,
    IRCMLControl_get_Height_Stub,
    IRCMLControl_put_Width_Stub,
    IRCMLControl_put_Height_Stub,
    IRCMLControl_get_X_Stub,
    IRCMLControl_get_Y_Stub,
    IRCMLControl_put_X_Stub,
    IRCMLControl_put_Y_Stub,
    IRCMLControl_get_RelativeTo_Stub,
    IRCMLControl_put_RelativeTo_Stub,
    IRCMLControl_get_Location_Stub,
    IRCMLControl_get_RelativeLocn_Stub,
    IRCMLControl_get_RelativeID_Stub,
    IRCMLControl_get_RelativeType_Stub,
    IRCMLControl_get_Clipped_Stub,
    IRCMLControl_get_GrowsWide_Stub,
    IRCMLControl_get_GrowsTall_Stub,
    IRCMLControl_get_Container_Stub,
    IRCMLControl_put_Container_Stub,
    IRCMLControl_get_CSS_Stub,
    IRCMLControl_put_CSS_Stub,
    IRCMLControl_get_Help_Stub
};

const CInterfaceStubVtbl _IRCMLControlStubVtbl =
{
    &IID_IRCMLControl,
    0,
    52,
    &IRCMLControl_table[-3],
    CStdStubBuffer_METHODS
};


/* Object interface: IRCMLContainer, ver. 0.0,
   GUID={0xE0868F2A,0xBC98,0x4b46,{0x92,0x61,0x31,0xA1,0x68,0x90,0x48,0x04}} */


extern const MIDL_STUB_DESC Object_StubDesc;


#pragma code_seg(".orpc")

/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRCMLContainer_GetPixelLocation_Proxy( 
    IRCMLContainer __RPC_FAR * This,
    /* [in] */ IRCMLControl __RPC_FAR *__MIDL_0015,
    /* [retval][out] */ RECT __RPC_FAR *pRect)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    if(pRect)
        {
        MIDL_memset(
               pRect,
               0,
               sizeof( RECT  ));
        }
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void __RPC_FAR *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      3);
        
        
        
        if(!pRect)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 0U;
            NdrInterfacePointerBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                           (unsigned char __RPC_FAR *)__MIDL_0015,
                                           (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[168] );
            
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrInterfacePointerMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                                         (unsigned char __RPC_FAR *)__MIDL_0015,
                                         (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[168] );
            
            NdrProxySendReceive(This, &_StubMsg);
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[212] );
            
            NdrSimpleStructUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                       (unsigned char __RPC_FAR * __RPC_FAR *)&pRect,
                                       (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[190],
                                       (unsigned char)0 );
            
            _RetVal = *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[186],
                         ( void __RPC_FAR * )pRect);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB IRCMLContainer_GetPixelLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    IRCMLControl __RPC_FAR *__MIDL_0015;
    RECT _pRectM;
    RECT __RPC_FAR *pRect;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    __MIDL_0015 = 0;
    ( RECT __RPC_FAR * )pRect = 0;
    RpcTryFinally
        {
        if ( (_pRpcMessage->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[212] );
        
        NdrInterfacePointerUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                       (unsigned char __RPC_FAR * __RPC_FAR *)&__MIDL_0015,
                                       (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[168],
                                       (unsigned char)0 );
        
        pRect = &_pRectM;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((IRCMLContainer*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> GetPixelLocation(
                    (IRCMLContainer *) ((CStdStubBuffer *)This)->pvServerObject,
                    __MIDL_0015,
                    pRect);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 0U + 11U;
        NdrSimpleStructBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                   (unsigned char __RPC_FAR *)pRect,
                                   (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[190] );
        
        _StubMsg.BufferLength += 16;
        
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        NdrSimpleStructMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                                 (unsigned char __RPC_FAR *)pRect,
                                 (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[190] );
        
        *(( HRESULT __RPC_FAR * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        NdrInterfacePointerFree( &_StubMsg,
                                 (unsigned char __RPC_FAR *)__MIDL_0015,
                                 &__MIDL_TypeFormatString.Format[168] );
        
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)((long)_StubMsg.Buffer - (long)_pRpcMessage->Buffer);
    
}

extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[3];

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x20000, /* Ndr library version */
    0,
    0x50100a4, /* MIDL Version 5.1.164 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    1,  /* Flags */
    0,  /* Reserved3 */
    0,  /* Reserved4 */
    0   /* Reserved5 */
    };

const CINTERFACE_PROXY_VTABLE(4) _IRCMLContainerProxyVtbl = 
{
    &IID_IRCMLContainer,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IRCMLContainer_GetPixelLocation_Proxy
};


static const PRPC_STUB_FUNCTION IRCMLContainer_table[] =
{
    IRCMLContainer_GetPixelLocation_Stub
};

const CInterfaceStubVtbl _IRCMLContainerStubVtbl =
{
    &IID_IRCMLContainer,
    0,
    4,
    &IRCMLContainer_table[-3],
    CStdStubBuffer_METHODS
};

#pragma data_seg(".rdata")

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[3] = 
        {
            
            {
            HFONT_UserSize
            ,HFONT_UserMarshal
            ,HFONT_UserUnmarshal
            ,HFONT_UserFree
            },
            {
            HBRUSH_UserSize
            ,HBRUSH_UserMarshal
            ,HBRUSH_UserUnmarshal
            ,HBRUSH_UserFree
            },
            {
            HWND_UserSize
            ,HWND_UserMarshal
            ,HWND_UserUnmarshal
            ,HWND_UserFree
            }

        };


#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT40_OR_LATER)
#error You need a Windows NT 4.0 or later to run this stub because it uses these features:
#error   [wire_marshal] or [user_marshal] attribute.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {
			
			0x4d,		/* FC_IN_PARAM */
#ifndef _ALPHA_
			0x1,		/* x86, MIPS & PPC Stack size = 1 */
#else
			0x2,		/* Alpha Stack size = 2 */
#endif
/*  2 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */
/*  4 */	0x53,		/* FC_RETURN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */
/*  6 */	
			0x51,		/* FC_OUT_PARAM */
#ifndef _ALPHA_
			0x1,		/* x86, MIPS & PPC Stack size = 1 */
#else
			0x2,		/* Alpha Stack size = 2 */
#endif
/*  8 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */
/* 10 */	0x53,		/* FC_RETURN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */
/* 12 */	
			0x51,		/* FC_OUT_PARAM */
#ifndef _ALPHA_
			0x1,		/* x86, MIPS & PPC Stack size = 1 */
#else
			0x2,		/* Alpha Stack size = 2 */
#endif
/* 14 */	NdrFcShort( 0x18 ),	/* Type Offset=24 */
/* 16 */	0x53,		/* FC_RETURN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */
/* 18 */	
			0x4d,		/* FC_IN_PARAM */
#ifndef _ALPHA_
			0x1,		/* x86, MIPS & PPC Stack size = 1 */
#else
			0x2,		/* Alpha Stack size = 2 */
#endif
/* 20 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */
/* 22 */	0x4e,		/* FC_IN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */
/* 24 */	0x53,		/* FC_RETURN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */
/* 26 */	
			0x4d,		/* FC_IN_PARAM */
#ifndef _ALPHA_
			0x1,		/* x86, MIPS & PPC Stack size = 1 */
#else
			0x2,		/* Alpha Stack size = 2 */
#endif
/* 28 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */
/* 30 */	
			0x51,		/* FC_OUT_PARAM */
#ifndef _ALPHA_
			0x1,		/* x86, MIPS & PPC Stack size = 1 */
#else
			0x2,		/* Alpha Stack size = 2 */
#endif
/* 32 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */
/* 34 */	0x53,		/* FC_RETURN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */
/* 36 */	
			0x4d,		/* FC_IN_PARAM */
#ifndef _ALPHA_
			0x1,		/* x86, MIPS & PPC Stack size = 1 */
#else
			0x2,		/* Alpha Stack size = 2 */
#endif
/* 38 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */
/* 40 */	
			0x4d,		/* FC_IN_PARAM */
#ifndef _ALPHA_
			0x1,		/* x86, MIPS & PPC Stack size = 1 */
#else
			0x2,		/* Alpha Stack size = 2 */
#endif
/* 42 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */
/* 44 */	0x53,		/* FC_RETURN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */
/* 46 */	
			0x4d,		/* FC_IN_PARAM */
#ifndef _ALPHA_
			0x1,		/* x86, MIPS & PPC Stack size = 1 */
#else
			0x2,		/* Alpha Stack size = 2 */
#endif
/* 48 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */
/* 50 */	0x53,		/* FC_RETURN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */
/* 52 */	
			0x4d,		/* FC_IN_PARAM */
#ifndef _ALPHA_
			0x1,		/* x86, MIPS & PPC Stack size = 1 */
#else
			0x2,		/* Alpha Stack size = 2 */
#endif
/* 54 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */
/* 56 */	0x4e,		/* FC_IN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */
/* 58 */	0x4e,		/* FC_IN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */
/* 60 */	
			0x51,		/* FC_OUT_PARAM */
#ifndef _ALPHA_
			0x1,		/* x86, MIPS & PPC Stack size = 1 */
#else
			0x2,		/* Alpha Stack size = 2 */
#endif
/* 62 */	NdrFcShort( 0x18 ),	/* Type Offset=24 */
/* 64 */	0x53,		/* FC_RETURN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */
/* 66 */	
			0x4d,		/* FC_IN_PARAM */
#ifndef _ALPHA_
			0x1,		/* x86, MIPS & PPC Stack size = 1 */
#else
			0x2,		/* Alpha Stack size = 2 */
#endif
/* 68 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */
/* 70 */	0x4e,		/* FC_IN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */
/* 72 */	0x4e,		/* FC_IN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */
/* 74 */	0x4e,		/* FC_IN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */
/* 76 */	
			0x51,		/* FC_OUT_PARAM */
#ifndef _ALPHA_
			0x1,		/* x86, MIPS & PPC Stack size = 1 */
#else
			0x2,		/* Alpha Stack size = 2 */
#endif
/* 78 */	NdrFcShort( 0x18 ),	/* Type Offset=24 */
/* 80 */	0x53,		/* FC_RETURN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */
/* 82 */	
			0x4d,		/* FC_IN_PARAM */
#ifndef _ALPHA_
			0x1,		/* x86, MIPS & PPC Stack size = 1 */
#else
			0x2,		/* Alpha Stack size = 2 */
#endif
/* 84 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */
/* 86 */	0x4e,		/* FC_IN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */
/* 88 */	
			0x51,		/* FC_OUT_PARAM */
#ifndef _ALPHA_
			0x1,		/* x86, MIPS & PPC Stack size = 1 */
#else
			0x2,		/* Alpha Stack size = 2 */
#endif
/* 90 */	NdrFcShort( 0x18 ),	/* Type Offset=24 */
/* 92 */	0x53,		/* FC_RETURN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */
/* 94 */	
			0x51,		/* FC_OUT_PARAM */
#ifndef _ALPHA_
			0x1,		/* x86, MIPS & PPC Stack size = 1 */
#else
			0x2,		/* Alpha Stack size = 2 */
#endif
/* 96 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */
/* 98 */	0x53,		/* FC_RETURN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */
/* 100 */	
			0x51,		/* FC_OUT_PARAM */
#ifndef _ALPHA_
			0x1,		/* x86, MIPS & PPC Stack size = 1 */
#else
			0x2,		/* Alpha Stack size = 2 */
#endif
/* 102 */	NdrFcShort( 0x28 ),	/* Type Offset=40 */
/* 104 */	0x53,		/* FC_RETURN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */
/* 106 */	
			0x51,		/* FC_OUT_PARAM */
#ifndef _ALPHA_
			0x1,		/* x86, MIPS & PPC Stack size = 1 */
#else
			0x2,		/* Alpha Stack size = 2 */
#endif
/* 108 */	NdrFcShort( 0x3e ),	/* Type Offset=62 */
/* 110 */	0x53,		/* FC_RETURN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */
/* 112 */	
			0x51,		/* FC_OUT_PARAM */
#ifndef _ALPHA_
			0x1,		/* x86, MIPS & PPC Stack size = 1 */
#else
			0x2,		/* Alpha Stack size = 2 */
#endif
/* 114 */	NdrFcShort( 0x64 ),	/* Type Offset=100 */
/* 116 */	0x53,		/* FC_RETURN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */
/* 118 */	
			0x51,		/* FC_OUT_PARAM */
#ifndef _ALPHA_
			0x1,		/* x86, MIPS & PPC Stack size = 1 */
#else
			0x2,		/* Alpha Stack size = 2 */
#endif
/* 120 */	NdrFcShort( 0x72 ),	/* Type Offset=114 */
/* 122 */	0x53,		/* FC_RETURN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */
/* 124 */	
			0x4d,		/* FC_IN_PARAM */
#ifndef _ALPHA_
			0x1,		/* x86, MIPS & PPC Stack size = 1 */
#else
			0x2,		/* Alpha Stack size = 2 */
#endif
/* 126 */	NdrFcShort( 0x76 ),	/* Type Offset=118 */
/* 128 */	0x53,		/* FC_RETURN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */
/* 130 */	
			0x4d,		/* FC_IN_PARAM */
#ifndef _ALPHA_
			0x1,		/* x86, MIPS & PPC Stack size = 1 */
#else
			0x2,		/* Alpha Stack size = 2 */
#endif
/* 132 */	NdrFcShort( 0x8c ),	/* Type Offset=140 */
/* 134 */	0x53,		/* FC_RETURN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */
/* 136 */	
			0x51,		/* FC_OUT_PARAM */
#ifndef _ALPHA_
			0x1,		/* x86, MIPS & PPC Stack size = 1 */
#else
			0x2,		/* Alpha Stack size = 2 */
#endif
/* 138 */	NdrFcShort( 0x96 ),	/* Type Offset=150 */
/* 140 */	0x53,		/* FC_RETURN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */
/* 142 */	
			0x4d,		/* FC_IN_PARAM */
#ifndef _ALPHA_
			0x1,		/* x86, MIPS & PPC Stack size = 1 */
#else
			0x2,		/* Alpha Stack size = 2 */
#endif
/* 144 */	NdrFcShort( 0x8c ),	/* Type Offset=140 */
/* 146 */	0x4e,		/* FC_IN_PARAM_BASETYPE */
			0x6,		/* FC_SHORT */
/* 148 */	0x53,		/* FC_RETURN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */
/* 150 */	0x4e,		/* FC_IN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */
/* 152 */	0x53,		/* FC_RETURN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */
/* 154 */	
			0x51,		/* FC_OUT_PARAM */
#ifndef _ALPHA_
			0x1,		/* x86, MIPS & PPC Stack size = 1 */
#else
			0x2,		/* Alpha Stack size = 2 */
#endif
/* 156 */	NdrFcShort( 0xa4 ),	/* Type Offset=164 */
/* 158 */	0x53,		/* FC_RETURN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */
/* 160 */	
			0x4d,		/* FC_IN_PARAM */
#ifndef _ALPHA_
			0x1,		/* x86, MIPS & PPC Stack size = 1 */
#else
			0x2,		/* Alpha Stack size = 2 */
#endif
/* 162 */	NdrFcShort( 0xa8 ),	/* Type Offset=168 */
/* 164 */	0x53,		/* FC_RETURN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */
/* 166 */	
			0x51,		/* FC_OUT_PARAM */
#ifndef _ALPHA_
			0x1,		/* x86, MIPS & PPC Stack size = 1 */
#else
			0x2,		/* Alpha Stack size = 2 */
#endif
/* 168 */	NdrFcShort( 0xba ),	/* Type Offset=186 */
/* 170 */	0x53,		/* FC_RETURN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */
/* 172 */	
			0x4d,		/* FC_IN_PARAM */
#ifndef _ALPHA_
			0x4,		/* x86, MIPS & PPC Stack size = 4 */
#else
			0x4,		/* Alpha Stack size = 4 */
#endif
/* 174 */	NdrFcShort( 0xbe ),	/* Type Offset=190 */
/* 176 */	
			0x51,		/* FC_OUT_PARAM */
#ifndef _ALPHA_
			0x1,		/* x86, MIPS & PPC Stack size = 1 */
#else
			0x2,		/* Alpha Stack size = 2 */
#endif
/* 178 */	NdrFcShort( 0xba ),	/* Type Offset=186 */
/* 180 */	0x53,		/* FC_RETURN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */
/* 182 */	
			0x51,		/* FC_OUT_PARAM */
#ifndef _ALPHA_
			0x1,		/* x86, MIPS & PPC Stack size = 1 */
#else
			0x2,		/* Alpha Stack size = 2 */
#endif
/* 184 */	NdrFcShort( 0xc8 ),	/* Type Offset=200 */
/* 186 */	0x53,		/* FC_RETURN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */
/* 188 */	
			0x51,		/* FC_OUT_PARAM */
#ifndef _ALPHA_
			0x1,		/* x86, MIPS & PPC Stack size = 1 */
#else
			0x2,		/* Alpha Stack size = 2 */
#endif
/* 190 */	NdrFcShort( 0xcc ),	/* Type Offset=204 */
/* 192 */	0x53,		/* FC_RETURN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */
/* 194 */	
			0x51,		/* FC_OUT_PARAM */
#ifndef _ALPHA_
			0x1,		/* x86, MIPS & PPC Stack size = 1 */
#else
			0x2,		/* Alpha Stack size = 2 */
#endif
/* 196 */	NdrFcShort( 0xd8 ),	/* Type Offset=216 */
/* 198 */	0x53,		/* FC_RETURN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */
/* 200 */	
			0x4d,		/* FC_IN_PARAM */
#ifndef _ALPHA_
			0x1,		/* x86, MIPS & PPC Stack size = 1 */
#else
			0x2,		/* Alpha Stack size = 2 */
#endif
/* 202 */	NdrFcShort( 0xdc ),	/* Type Offset=220 */
/* 204 */	0x53,		/* FC_RETURN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */
/* 206 */	
			0x51,		/* FC_OUT_PARAM */
#ifndef _ALPHA_
			0x1,		/* x86, MIPS & PPC Stack size = 1 */
#else
			0x2,		/* Alpha Stack size = 2 */
#endif
/* 208 */	NdrFcShort( 0xee ),	/* Type Offset=238 */
/* 210 */	0x53,		/* FC_RETURN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */
/* 212 */	
			0x4d,		/* FC_IN_PARAM */
#ifndef _ALPHA_
			0x1,		/* x86, MIPS & PPC Stack size = 1 */
#else
			0x2,		/* Alpha Stack size = 2 */
#endif
/* 214 */	NdrFcShort( 0xa8 ),	/* Type Offset=168 */
/* 216 */	
			0x51,		/* FC_OUT_PARAM */
#ifndef _ALPHA_
			0x1,		/* x86, MIPS & PPC Stack size = 1 */
#else
			0x2,		/* Alpha Stack size = 2 */
#endif
/* 218 */	NdrFcShort( 0xba ),	/* Type Offset=186 */
/* 220 */	0x53,		/* FC_RETURN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/*  4 */	NdrFcLong( 0xf825caf1 ),	/* -131740943 */
/*  8 */	NdrFcShort( 0xde40 ),	/* -8640 */
/* 10 */	NdrFcShort( 0x4fcc ),	/* 20428 */
/* 12 */	0xb9,		/* 185 */
			0x65,		/* 101 */
/* 14 */	0x93,		/* 147 */
			0x30,		/* 48 */
/* 16 */	0x76,		/* 118 */
			0xd7,		/* 215 */
/* 18 */	0xa1,		/* 161 */
			0xc5,		/* 197 */
/* 20 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] */
/* 22 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (2) */
/* 24 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 26 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 28 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 30 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 32 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] */
/* 34 */	NdrFcShort( 0x2 ),	/* Offset= 2 (36) */
/* 36 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 38 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 40 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] */
/* 42 */	NdrFcShort( 0x2 ),	/* Offset= 2 (44) */
/* 44 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 46 */	NdrFcLong( 0x100 ),	/* 256 */
/* 50 */	NdrFcShort( 0x0 ),	/* 0 */
/* 52 */	NdrFcShort( 0x0 ),	/* 0 */
/* 54 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 56 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 58 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 60 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 62 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 64 */	NdrFcShort( 0x1a ),	/* Offset= 26 (90) */
/* 66 */	
			0x13, 0x0,	/* FC_OP */
/* 68 */	NdrFcShort( 0x2 ),	/* Offset= 2 (70) */
/* 70 */	
			0x2a,		/* FC_ENCAPSULATED_UNION */
			0x48,		/* 72 */
/* 72 */	NdrFcShort( 0x4 ),	/* 4 */
/* 74 */	NdrFcShort( 0x2 ),	/* 2 */
/* 76 */	NdrFcLong( 0x48746457 ),	/* 1215587415 */
/* 80 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 82 */	NdrFcLong( 0x52746457 ),	/* 1383359575 */
/* 86 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 88 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (87) */
/* 90 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 92 */	NdrFcShort( 0x0 ),	/* 0 */
/* 94 */	NdrFcShort( 0x4 ),	/* 4 */
/* 96 */	NdrFcShort( 0x0 ),	/* 0 */
/* 98 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (66) */
/* 100 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 102 */	NdrFcShort( 0x2 ),	/* Offset= 2 (104) */
/* 104 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 106 */	NdrFcShort( 0x1 ),	/* 1 */
/* 108 */	NdrFcShort( 0x4 ),	/* 4 */
/* 110 */	NdrFcShort( 0x0 ),	/* 0 */
/* 112 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (66) */
/* 114 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] */
/* 116 */	NdrFcShort( 0x2 ),	/* Offset= 2 (118) */
/* 118 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 120 */	NdrFcLong( 0xf5dbf38a ),	/* -170134646 */
/* 124 */	NdrFcShort( 0x14de ),	/* 5342 */
/* 126 */	NdrFcShort( 0x4f8b ),	/* 20363 */
/* 128 */	0x87,		/* 135 */
			0x50,		/* 80 */
/* 130 */	0xba,		/* 186 */
			0xba,		/* 186 */
/* 132 */	0x88,		/* 136 */
			0x46,		/* 70 */
/* 134 */	0xe7,		/* 231 */
			0xf2,		/* 242 */
/* 136 */	
			0x12, 0x0,	/* FC_UP */
/* 138 */	NdrFcShort( 0xffffffbc ),	/* Offset= -68 (70) */
/* 140 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 142 */	NdrFcShort( 0x2 ),	/* 2 */
/* 144 */	NdrFcShort( 0x4 ),	/* 4 */
/* 146 */	NdrFcShort( 0x0 ),	/* 0 */
/* 148 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (136) */
/* 150 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 152 */	NdrFcShort( 0x2 ),	/* Offset= 2 (154) */
/* 154 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 156 */	NdrFcShort( 0x2 ),	/* 2 */
/* 158 */	NdrFcShort( 0x4 ),	/* 4 */
/* 160 */	NdrFcShort( 0x0 ),	/* 0 */
/* 162 */	NdrFcShort( 0xffffffa0 ),	/* Offset= -96 (66) */
/* 164 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] */
/* 166 */	NdrFcShort( 0x2 ),	/* Offset= 2 (168) */
/* 168 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 170 */	NdrFcLong( 0xb943ddf7 ),	/* -1186734601 */
/* 174 */	NdrFcShort( 0x21a7 ),	/* 8615 */
/* 176 */	NdrFcShort( 0x42cb ),	/* 17099 */
/* 178 */	0xb6,		/* 182 */
			0x96,		/* 150 */
/* 180 */	0x34,		/* 52 */
			0x5a,		/* 90 */
/* 182 */	0xeb,		/* 235 */
			0xc1,		/* 193 */
/* 184 */	0x9,		/* 9 */
			0x10,		/* 16 */
/* 186 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 188 */	NdrFcShort( 0x2 ),	/* Offset= 2 (190) */
/* 190 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 192 */	NdrFcShort( 0x10 ),	/* 16 */
/* 194 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 196 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 198 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 200 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 202 */	0xd,		/* FC_ENUM16 */
			0x5c,		/* FC_PAD */
/* 204 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 206 */	NdrFcShort( 0x2 ),	/* Offset= 2 (208) */
/* 208 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 210 */	NdrFcShort( 0x8 ),	/* 8 */
/* 212 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 214 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 216 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] */
/* 218 */	NdrFcShort( 0x2 ),	/* Offset= 2 (220) */
/* 220 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 222 */	NdrFcLong( 0xe0868f2a ),	/* -528052438 */
/* 226 */	NdrFcShort( 0xbc98 ),	/* -17256 */
/* 228 */	NdrFcShort( 0x4b46 ),	/* 19270 */
/* 230 */	0x92,		/* 146 */
			0x61,		/* 97 */
/* 232 */	0x31,		/* 49 */
			0xa1,		/* 161 */
/* 234 */	0x68,		/* 104 */
			0x90,		/* 144 */
/* 236 */	0x48,		/* 72 */
			0x4,		/* 4 */
/* 238 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] */
/* 240 */	NdrFcShort( 0x2 ),	/* Offset= 2 (242) */
/* 242 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 244 */	NdrFcLong( 0xb31fdc6a ),	/* -1289757590 */
/* 248 */	NdrFcShort( 0x9fb2 ),	/* -24654 */
/* 250 */	NdrFcShort( 0x404e ),	/* 16462 */
/* 252 */	0x87,		/* 135 */
			0x62,		/* 98 */
/* 254 */	0xcc,		/* 204 */
			0x26,		/* 38 */
/* 256 */	0x7a,		/* 122 */
			0x95,		/* 149 */
/* 258 */	0xa4,		/* 164 */
			0x24,		/* 36 */

			0x0
        }
    };

const CInterfaceProxyVtbl * _rcml_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IRCMLContainerProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IRCMLHelpProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IRCMLCSSProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IRCMLResizeProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IRCMLNodeProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IRCMLControlProxyVtbl,
    0
};

const CInterfaceStubVtbl * _rcml_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IRCMLContainerStubVtbl,
    ( CInterfaceStubVtbl *) &_IRCMLHelpStubVtbl,
    ( CInterfaceStubVtbl *) &_IRCMLCSSStubVtbl,
    ( CInterfaceStubVtbl *) &_IRCMLResizeStubVtbl,
    ( CInterfaceStubVtbl *) &_IRCMLNodeStubVtbl,
    ( CInterfaceStubVtbl *) &_IRCMLControlStubVtbl,
    0
};

PCInterfaceName const _rcml_InterfaceNamesList[] = 
{
    "IRCMLContainer",
    "IRCMLHelp",
    "IRCMLCSS",
    "IRCMLResize",
    "IRCMLNode",
    "IRCMLControl",
    0
};


#define _rcml_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _rcml, pIID, n)

int __stdcall _rcml_IID_Lookup( const IID * pIID, int * pIndex )
{
    IID_BS_LOOKUP_SETUP

    IID_BS_LOOKUP_INITIAL_TEST( _rcml, 6, 4 )
    IID_BS_LOOKUP_NEXT_TEST( _rcml, 2 )
    IID_BS_LOOKUP_NEXT_TEST( _rcml, 1 )
    IID_BS_LOOKUP_RETURN_RESULT( _rcml, 6, *pIndex )
    
}

const ExtendedProxyFileInfo rcml_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _rcml_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _rcml_StubVtblList,
    (const PCInterfaceName * ) & _rcml_InterfaceNamesList,
    0, // no delegation
    & _rcml_IID_Lookup, 
    6,
    1,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__8100BA70_DE31_11D2_8BCF_00C04FB177B1__INCLUDED_)
#define AFX_STDAFX_H__8100BA70_DE31_11D2_8BCF_00C04FB177B1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// Insert your headers here
// #define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>
#include <tchar.h>
#include <malloc.h>

// #include <crtdbg.h>
#pragma intrinsic( memcpy, memset, memcmp)

// #include <afxole.h>

// TODO: reference additional headers your program requires here

#include "commctrl.h"
#include "debug.h"

#pragma warning( disable : 4273 )

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8100BA70_DE31_11D2_8BCF_00C04FB177B1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\stringproperty.cpp ===
// StringProperty.cpp: implementation of the CStringProperty class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "StringProperty.h"
#include "utils.h"

// According to bounds checker
// This doesn't seem to be cleaned up corretly
CDictionary CStringPropertySection::m_Dictionary; 

CStringPropertySection::CStringPropertySection()
{
    m_UsedItems=0;  // make this an array and re-alloc it
    m_ItemSize=RUN_SIZE;
    m_Items=new LINKSTRING[m_ItemSize];
    m_Dictionary.AddRef();
}

//
// Finds the Value from the KEY, returns NULL if the KEY isn't used.
//
LPWSTR CStringPropertySection::Get(LPCTSTR szPropID)
{
    int iEntry;
	if( Find( szPropID, &iEntry ) )
		return (LPWSTR)m_Items[iEntry].pszValue;
	return NULL;
}

// #define _MEM_DEBUG
#ifdef _MEM_DEBUG
DWORD g_KeyAlloc;
DWORD g_ValueAlloc;
#endif

//
// Associats a value (perhaps new) to a given key.
// we copy the data (pszValue)
//
BOOL CStringPropertySection::Set(LPCTSTR szPropID, LPCTSTR szValue)
{
	if(szValue==NULL)
		szValue=L"";	// slight hack.

    int iEntry;
	if( (Find( szPropID, &iEntry ) == FALSE) )
	{
		if( m_UsedItems == m_ItemSize )
		{
			// re allocate the buffer bigger.
			m_ItemSize*=2;
			PLINKSTRING pNew=new LINKSTRING[m_ItemSize];
			CopyMemory(pNew, m_Items, sizeof(LINKSTRING) * m_UsedItems );
			delete [] m_Items;
			m_Items=pNew;
		}

		iEntry=m_UsedItems++;
		m_Items[iEntry].idKey=m_Dictionary.GetID( szPropID );
	}
	else
    {
		delete m_Items[iEntry].pszValue;
    }

	DWORD dwLen=lstrlen(szValue)+1;
#ifdef _MEM_DEBUG
    g_ValueAlloc+=dwLen;
#endif
	m_Items[iEntry].pszValue=new TCHAR[dwLen];
	CopyMemory( m_Items[iEntry].pszValue, szValue, dwLen*sizeof(TCHAR) );
	return TRUE;
}

//
// Finds a string in the table.
// The KEY of the thing you are finding
// An OUT pointer to the LINKSTRING structure
// which item in the LINKSTRING structure can be used.
//
BOOL CStringPropertySection::Find( LPCTSTR szPropID, int * pEntry)
{
    UINT uiPropID = m_Dictionary.GetID( szPropID ); // this is the ID for this string.
    for(UINT i=0;i<m_UsedItems;i++)
    {
        if( uiPropID == m_Items[i].idKey )
        {
            *pEntry=i;
            return TRUE;
        }
    }
    *pEntry=0;
	return FALSE;
}

CStringPropertySection::~CStringPropertySection()
{
    Purge();
    delete m_Items;
    m_Items=NULL;
    m_Dictionary.Release();
}

void CStringPropertySection::Purge()
{
	for(UINT i=0;i<m_UsedItems;i++)
	{
        m_Items[i].idKey=0;
		delete [] m_Items[i].pszValue;
        m_Items[i].pszValue=NULL;
	}
    m_UsedItems=0;
}

//
// Looks for the existance of a property szPropID
// if present and set to YES, returns dwResult (default of TRUE).
// otherwise returns defValue
//
DWORD CStringPropertySection::YesNo(LPCTSTR szPropID, DWORD dwNotPresent, DWORD dwYes)
{
    return YesNo( szPropID, dwNotPresent, FALSE, dwYes );
}

DWORD CStringPropertySection::YesNo(LPCTSTR szPropID, DWORD dwNotPresent, DWORD dwNo, DWORD dwYes)
{
   	LPCTSTR req=(LPCTSTR)Get(szPropID);
    if( req == NULL )
        return dwNotPresent;

    if( req && lstrcmpi(req,TEXT("YES"))==0)
        return dwYes;
    return dwNo;
}

DWORD   CStringPropertySection::ValueOf(LPCTSTR szPropID, DWORD dwDefault)
{
   	LPCTSTR req=(LPCTSTR)Get(szPropID);
    return req?StringToInt(req):dwDefault;
}



////////////////////////////////////////////////////////////////////////////////////////////////
//
// Dictionary.
// maps strings to UINTS, in a case insensitive manner.
// Like an atom table
// very handy for holding the KEYs in the schema
// LESS handy for holding the values.
//
////////////////////////////////////////////////////////////////////////////////////////////////

CDictionary::CDictionary()
{
	for(int i=0;i<DIC_TABLE_SIZE;i++)
		m_Table[i]=NULL;
    _refcount=0;
}

UINT CDictionary::GetID(LPCTSTR szPropID)
{
    //
    // Hash the string, find the bucket.
    //
	DWORD dwStrLen=lstrlen(szPropID)+1;
	DWORD hash=Hash(szPropID, dwStrLen);

    PLINKDICSTRING * ppFoundPointer = &m_Table[hash];
    PLINKDICSTRING pFound=*ppFoundPointer;
    int iNumber=0+1;
	while( pFound )
	{
        int used=pFound->cbUsed;
        for( int i=0;i<used;i++)
        {
            iNumber++;
		    if( lstrcmpi( pFound->pszKey[i], szPropID) == 0 )
                return pFound->ID[i];
        }

        //
        // If we have space in this run, use it up.
        //
        if( used < DIC_RUN_SIZE )
            break;

        // Next bucket
        ppFoundPointer=&pFound->pNext;
        pFound=*ppFoundPointer;
	}

    if( pFound == NULL )
    {
		pFound = new LINKDICSTRING;
        ZeroMemory( pFound, sizeof(LINKDICSTRING) );
        *ppFoundPointer=pFound;
    }

    //
    // Make the ID out of the bucket we are in, and the item we're adding.
    //
    int iEntry=pFound->cbUsed++;
    pFound->ID[iEntry]=hash<<8 | iNumber;

#ifdef _MEM_DEBUG
    g_ValueAlloc+=dwStrLen;
#endif

	pFound->pszKey[iEntry]=new TCHAR[dwStrLen];
	CopyMemory( pFound->pszKey[iEntry], szPropID, dwStrLen*sizeof(TCHAR) );

    return pFound->ID[iEntry];
}

LPCTSTR CDictionary::GetString(UINT ID)
{
    int iBucket=ID >> 8;
    // for( int iBucket=0;iBucket<DIC_TABLE_SIZE;iBucket++)
    {
        PLINKDICSTRING pLinkString=m_Table[iBucket];
        int i=0;
	    while( pLinkString )
	    {
            int used=pLinkString->cbUsed;
            for( int i=0;i<used;i++)
            {
		        if( pLinkString->ID[i]  == ID )
                    return pLinkString->pszKey[i];
            }

            pLinkString=( pLinkString->pNext );
	    }
    }
	return 0;
}


//
// Case insensitive hash.
//
DWORD CDictionary::Hash( LPCTSTR szString, DWORD dwStrLen )
{
	TCHAR szChar=toupper( *szString );
	return (dwStrLen * szChar) % DIC_TABLE_SIZE;
}


CDictionary::~CDictionary()
{
    Purge();
}

void CDictionary::Purge()
{
	for(int i=0;i<DIC_TABLE_SIZE;i++)
	{
		PLINKDICSTRING pNext;
		PLINKDICSTRING pEntry = m_Table[i];
		while( pEntry )
		{
            for(int ti=0;ti<pEntry->cbUsed;ti++)
            {
                pEntry->ID[ti]=0;
			    delete pEntry->pszKey[ti];
                pEntry->pszKey[ti]=NULL;
            }
			pNext= pEntry->pNext;
            // TRACE(TEXT("Dic @ 0x%08x\n"), pEntry );
			delete pEntry;
			pEntry=pNext;
		}
        m_Table[i]=NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\stringproperty.h ===
// StringProperty.h: interface for the CStringProperty class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_STRINGPROPERTY_H__CE442DDC_8EF3_11D2_84A3_00C04FB177B1__INCLUDED_)
#define AFX_STRINGPROPERTY_H__CE442DDC_8EF3_11D2_84A3_00C04FB177B1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CDictionary
{
public:
	CDictionary();
	virtual ~CDictionary();
	UINT    GetID( LPCTSTR szPropID );
    LPCTSTR GetString( UINT id );

    virtual ULONG STDMETHODCALLTYPE AddRef( void)
    { return InterlockedIncrement(&_refcount); }

    virtual ULONG STDMETHODCALLTYPE Release( void)
    {
        if (InterlockedDecrement(&_refcount) == 0)
        {
            Purge();
            return 0;
        }
        return _refcount;
    }

protected:    
    long _refcount;

protected:
    void    Purge();

#define DIC_RUN_SIZE 7
#define DIC_TABLE_SIZE 5

typedef struct _LINKDICSTRING
{
    int     cbUsed;
	LPTSTR	pszKey[DIC_RUN_SIZE];
	UINT    ID[DIC_RUN_SIZE];
	_LINKDICSTRING * pNext;
} LINKDICSTRING, * PLINKDICSTRING;

	PLINKDICSTRING	m_Table[DIC_TABLE_SIZE];

	DWORD	Hash(LPCTSTR szPropID, DWORD dwStrLen=0);
    BOOL    Set(LPCTSTR szPropID);
};

//
// There are not that many items on each element, so we put them in a linked list.
// COULD be sorted by UINT.
//
class CStringPropertySection
{
public:
	CStringPropertySection();
	virtual ~CStringPropertySection();
	BOOL	Set( LPCTSTR szPropID, LPCTSTR pValue );
	LPWSTR	Get( LPCTSTR szPropID );
    DWORD   YesNo( LPCTSTR szPropID, DWORD dwNotPresent, DWORD dwYes=TRUE);
    DWORD   YesNo( LPCTSTR szPropID, DWORD defNotPresent, DWORD dwNo, DWORD dwYes);
    DWORD   ValueOf( LPCTSTR szPropID, DWORD dwDefault);

protected:
    void    Purge();
    static  CDictionary m_Dictionary;

#define RUN_SIZE 5

typedef struct _LINKSTRING
{
	UINT        idKey;
	LPTSTR	    pszValue;
} LINKSTRING, * PLINKSTRING;

    UINT        m_UsedItems;
    UINT        m_ItemSize;
	PLINKSTRING	m_Items;

	BOOL	Find(LPCTSTR szPropID, int * pEntry );
};

#endif // !defined(AFX_STRINGPROPERTY_H__CE442DDC_8EF3_11D2_84A3_00C04FB177B1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\uiparser.h ===
// UIParser.h: interface for the CUIParser class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UIPARSER_H__CFCA19CA_893E_11D2_8498_00C04FB177B1__INCLUDED_)
#define AFX_UIPARSER_H__CFCA19CA_893E_11D2_8498_00C04FB177B1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "xmlnodefactory.h"
#include "rcmlloader.h"

class CUIParser  : public CRCMLLoader
{
public:
    // Sets External if the file was taken externally.
	HRESULT Load(LPCTSTR fileName, HINSTANCE hInst, BOOL * pbExternal);
    HRESULT Parse(LPCTSTR pszRCML);
	CUIParser();
	virtual ~CUIParser();

};

#endif // !defined(AFX_UIPARSER_H__CFCA19CA_893E_11D2_8498_00C04FB177B1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\unknown.h ===
// copied from ppxml sample

#ifndef _UNKNOWN2_HXX
#define _UNKNOWN2_HXX


template <class implementation, class derivedinterface>
class _simpleobj :  public implementation
{
private:    long _refcount;

public:        
        _simpleobj <implementation, derivedinterface>() 
        { 
            _refcount = 0;
        }

        virtual ~_simpleobj <implementation, derivedinterface>()
        {
        }

        virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void ** ppvObject)
        {
            if (riid == IID_IUnknown)
            {
                *ppvObject = static_cast<IUnknown*>(this);
            }
            else if (riid == __uuidof(derivedinterface))
            {
                *ppvObject = static_cast<derivedinterface*>(this);
            }
            else
            {
                *ppvObject = NULL;
                return E_NOINTERFACE;
            }
            reinterpret_cast<IUnknown*>(*ppvObject)->AddRef();
            return S_OK;
        }
    
        virtual ULONG STDMETHODCALLTYPE AddRef( void)
        {
            return InterlockedIncrement(&_refcount);
        }
    
        virtual ULONG STDMETHODCALLTYPE Release( void)
        {
            if (InterlockedDecrement(&_refcount) == 0)
            {
                delete this;
                return 0;
            }
            return _refcount;
        }
};    

//===========================================================================
// This template implements the IUnknown portion of a given COM interface.

template <class I> class _simpleunknown : public I
{
private:    long _refcount;

public:        
        _simpleunknown <I>() 
        { 
            _refcount = 0;
        }

        virtual ~_simpleunknown <I>()
        {
        }

        virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void ** ppvObject)
        {
            if (riid == IID_IUnknown)
            {
                *ppvObject = static_cast<IUnknown*>(this);
            }
            else if (riid == __uuidof(I))
            {
                *ppvObject = static_cast<I*>(this);
            }
            else
            {
                *ppvObject = NULL;
                return E_NOINTERFACE;
            }
            reinterpret_cast<IUnknown*>(*ppvObject)->AddRef();
            return S_OK;
        }
    
        virtual ULONG STDMETHODCALLTYPE AddRef( void)
        {
            return InterlockedIncrement(&_refcount);
        }
    
        virtual ULONG STDMETHODCALLTYPE Release( void)
        {
            if (InterlockedDecrement(&_refcount) == 0)
            {
                delete this;
                return 0;
            }
            return _refcount;
        }
};    

#endif _UNKNOWN2_HXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\uiparser.cpp ===
// UIParser.cpp: implementation of the CUIParser class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UIParser.h"
#include "FileStream.h"
#include "..\xmllib\xml\tokenizer\parser\xmlparser.hxx"


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUIParser::CUIParser()
{

}

CUIParser::~CUIParser()
{

}

extern HKEY g_ExternalFileKey;

//
// Loads data into RCMLParser (baseclass).
//
HRESULT CUIParser::Load(LPCTSTR fileName, HINSTANCE hInst, BOOL * pbExternal)
{
    // the NON com way of doing it.
    if( pbExternal )
        *pbExternal=FALSE;

#if 1
    TCHAR szExternalFilename[MAX_PATH];
    if( g_ExternalFileKey && (hInst != NULL) )  // if they pass a filename, they don't pass and HINSTANCE?
    {
        //
        // Look for the filename they may wish to load now.
        //
        TCHAR szModuleName[MAX_PATH];
        DWORD dwCopied = GetModuleFileName( hInst, szModuleName, MAX_PATH-8 );
        LPTSTR pszLastSlash=szModuleName;
        LPTSTR pszTemp=szModuleName;
        while( *pszTemp != 0 )
        {
            if( *pszTemp++=='\\')
                pszLastSlash = pszTemp;
        }

        //
        // Open the key for this module
        //
        HKEY hk;
        if( RegOpenKey( g_ExternalFileKey, pszLastSlash, &hk ) == ERROR_SUCCESS )
        {
            // What's the dialog identifier?
            TCHAR szResourceName[MAX_PATH];
            if( HIWORD(fileName) )
                lstrcpy(szResourceName, fileName );
            else
                wsprintf( szResourceName, TEXT("%d"), LOWORD(fileName) );

            // Is there an external file matched against this identifier?
            DWORD dwSize=MAX_PATH;
            DWORD dwType=REG_SZ;
            LONG error; 
            if( (error=RegQueryValueEx( hk, szResourceName, NULL, &dwType, (LPBYTE)szExternalFilename, &dwSize )) == ERROR_SUCCESS )
            {
                //
                // Check that it exists.
                //
                HANDLE hDoesItExist=CreateFile( szExternalFilename, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
                if( hDoesItExist != INVALID_HANDLE_VALUE )
                {
                    CloseHandle( hDoesItExist);
                    fileName=szExternalFilename;
                    if( pbExternal )
                        *pbExternal=TRUE;   // we're taking an external file
                }
            }
            RegCloseKey( hk );
        }
    }

   	HRESULT hr=S_OK;

    if( HIWORD(fileName) )
    {
		FileStream * stream=new FileStream();
		if( stream->open((LPTSTR)fileName) )
		{
            XMLParser xmlParser;
            xmlParser.SetFactory(this);
            xmlParser.SetInput(stream);
            hr=xmlParser.Run(-1);
            stream->Release();
		}
		else
        {
            stream->Release();
			return E_FAIL;
        }
    }
    else
    {
        //
        // Find the resource in the RCML fork of the resource tree, parse it.
        //

        //
        // Hunt for the resource
        //
        HRSRC hRes = NULL;
        OSVERSIONINFOEX VersionInformation;
        VersionInformation.dwOSVersionInfoSize = sizeof( VersionInformation );
        if ( GetVersionEx( (LPOSVERSIONINFO)& VersionInformation ) )
        {
            switch( (VersionInformation.wReserved[1] & 0xff) )
            {
                case 1: // worksta
                    hRes = FindResource( hInst, fileName, TEXT("RCML_Workstation") );
                    break;
                case 2: // domain
                    hRes = FindResource( hInst, fileName, TEXT("RCML_DomainController") );
                    break;
                case 3: // server
                    hRes = FindResource( hInst, fileName, TEXT("RCML_SERVER") );
                    break;
            }
        }

        if( hRes == NULL )
            hRes = FindResource( hInst, fileName, TEXT("RCML") );

        if( hRes != NULL )
        {
            TRACE(TEXT("RCML resource\n"));
            DWORD dwSize = SizeofResource( hInst, hRes );
            HGLOBAL hg=LoadResource(hInst, hRes );
            if( hg )
            {
                LPVOID pData = LockResource( hg );
                Parse((LPCTSTR)pData);
                FreeResource( hg );
            }
        }
    }
	return hr;
#else
	HRESULT hr=E_FAIL;
	if( SUCCEEDED( hr = CoInitialize(NULL) ) )
	{
	    IXMLParser*     xp = NULL;

		if ( SUCCEEDED( hr = CoCreateInstance(CLSID_XMLParser, NULL, CLSCTX_INPROC_SERVER,
                          IID_IXMLParser, (void**)&xp) ) )
		{
			xp->SetFactory( &factory );
            if( HIWORD(fileName) )
            {
			    FileStream * stream=new FileStream();
			    if( stream->open((LPTSTR)fileName) )
			    {
				    xp->SetInput(stream);
				    xp->Run(-1);
			    }
			    else
				    return E_FAIL;
            }
            else
            {
                //
                // Find the resource in the RCML fork of the resource tree, parse it.
                //
                HRSRC hRes = FindResource( hInst, fileName, TEXT("RCML") );
                if( hRes != NULL )
                {
                    TRACE(TEXT("RCML resource\n"));
                    DWORD dwSize = SizeofResource( hInst, hRes );
                    HGLOBAL hg=LoadResource(hInst, hRes );
                    if( hg )
                    {
                        LPVOID pData = LockResource( hg );
                        Parse(pData);
                        FreeResource( hg );
                    }
                }
            }
		}
	}
	return hr;
#endif
}


//
// Called for parsing an in-memory image of the file.
//
HRESULT CUIParser::Parse(LPCTSTR pszRCML)
{
   	HRESULT hr=S_OK;

    if( HIWORD(pszRCML) )
    {
        XMLParser xmlParser;
        xmlParser.SetFactory(this);

        MemoryStream * stream=new MemoryStream( (LPBYTE)pszRCML, lstrlen(pszRCML)*sizeof(TCHAR) );

        xmlParser.SetInput(stream);
        hr=xmlParser.Run(-1);

        stream->Release();
    }
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\utils.h ===
//
// This file will hold various helper functions
//
//	 StringToInt - converts the decimal or hex string passed in to an integer
// 
// History:
//	Created:	MCostea	May 27, 1999
// 
#ifndef __UTILSH
#define __UTILSH

#define StringToInt(psz) StringToIntDef(psz, 0 )

int StringToIntDef(LPCTSTR psz, int Default);
int ReadHexValue(LPCTSTR psz);
void CopyToWideChar( WCHAR** pstrOut, LPCTSTR strIn );
LPWSTR UnicodeStringFromAnsi(LPCSTR pszSource);
LPSTR AnsiStringFromUnicode(LPCWSTR pszSource);

#endif	// __UTILSH
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\utils.cpp ===
#include "stdafx.h"
#include "utils.h"

//
// StringToInt - convert the decimal or hex string passed in to an integer
//       A NULL input will return 0
//		 Overflow is not detected, white spaces not allowed
//
// MCostea May 27, 1999
//
//
int StringToIntDef(LPCTSTR psz, int Default)
{
	int retVal = 0;	// current total
	int c;			// current char

    if( HIWORD( psz ) == NULL )
        return LOWORD(psz);

	if(psz != NULL)
	{
		int sign = 1;

		c = (int)(TCHAR)*psz++;

		switch(c)
		{
		case __T('-'):
			sign = -1;
			break;
		case __T('+'):
			break;
		case __T('0'):
			{
				c = (int)(TCHAR)*psz++;
				if(c == __T('x'))
					return ReadHexValue(psz);					
				else 
					return 0;
			}
			break;
		default:
			if(c >= __T('0') || c <= __T('9'))
				retVal = c -__T('0');
			else 
				return Default;
		}

		while(c = (int)(TCHAR)*psz++)
		{
			c -= __T('0');
			if( c < 0 || c > 9)
				return 	sign*retVal;
			retVal = retVal*10 + c;
		}
		retVal = sign*retVal;
	}
	return retVal;
}


int ReadHexValue(LPCTSTR psz)
{
	int retVal = 0;	// current total
	int c;			// current char
	int digit;

	while(c = (int)(TCHAR)*psz++)
	{
		if(c >= __T('0') && c <= __T('9'))
			digit = c - __T('0');
		else if( c >= __T('a') && c <= __T('f'))
			digit = c - __T('a') + 10;
		else if( c >= __T('A') && c <= __T('F'))
			digit = c - __T('A') + 10;
		retVal = (retVal << 4) + digit;
	}
	return retVal;
}

void CopyToWideChar( WCHAR** pstrOut, LPCTSTR strIn ) 
{ 
	if(strIn==NULL )
	{
	    **pstrOut = 0; 
        *pstrOut +=1;   // move on, we just put a null down.
		return;
	}
    WCHAR* strOut = *pstrOut; 
    DWORD  dwLen = lstrlen( strIn ); 

#ifdef UNICODE // Copy Unicode to Unicode 
    lstrcpy( strOut, strIn ); 
#else         // Copy Ansi to Unicode 
    dwLen = MultiByteToWideChar( CP_ACP, 0, strIn, dwLen, strOut, dwLen ); 
    strOut[dwLen] = 0; // Add the null terminator 
#endif 
    *pstrOut += dwLen+1; 
} 

/*
 * This function allocates the new UNICODE string and copies the content 
 * from the ANSI source.  It's the caller responsability to free the memory
 */
LPWSTR UnicodeStringFromAnsi(LPCSTR pszSource)
{
	DWORD dwOutLen = lstrlenA(pszSource)+1;
	LPWSTR pszUString = new WCHAR[dwOutLen];

    dwOutLen = MultiByteToWideChar( CP_ACP, 0, pszSource, dwOutLen-1, pszUString, dwOutLen ); 
    pszUString[dwOutLen] = 0; // Add the null terminator 
	return pszUString;
}

/*
 * This function allocates the new UNICODE string and copies the content 
 * from the ANSI source.  It's the caller responsability to free the memory
 */
LPSTR AnsiStringFromUnicode(LPCWSTR pszSource)
{
#if 0
	DWORD dwOutLen = lstrlenW(pszSource)+1;
	LPSTR pszUString = new CHAR[dwOutLen];

    dwOutLen = WideCharToMultiByte( CP_ACP, WC_DEFAULTCHAR, pszSource, dwOutLen-1, pszUString, dwOutLen, NULL, NULL ); 
    pszUString[dwOutLen] = 0; // Add the null terminator 

	return pszUString;
#endif

    //
    // Make the short string.
    //
    DWORD nStringLen=WideCharToMultiByte(CP_ACP,0,pszSource,-1, NULL, 0, NULL,NULL);
    LPSTR pString = new CHAR[nStringLen];
    WideCharToMultiByte(CP_ACP, 0,  pszSource, -1, pString, nStringLen, NULL, NULL);
    return pString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\strings.cpp ===
//============================================================================
//
// DBCS and UNICODE aware string routines
//
//
//============================================================================

#include "stdafx.h"
#define _SHLWAPI_
#include <shlwapi.h>

// FA
#define NORM_STOP_ON_NULL   0x10000000
BOOL g_bRunningOnNT=TRUE;

#if 0

#include "priv.h"
#include "ids.h"
#include <winnlsp.h>    // Get private NORM_ flag for StrEqIntl()
#include <shlobj.h>     // STRRET LPCITEMIDLIST
#include <w95wraps.h>

#include <mluisupp.h>
#endif // FA

#define IS_DIGITA(ch)    InRange(ch, '0', '9')
#define IS_DIGITW(ch)    InRange(ch, L'0', L'9')


#define DM_INTERVAL 0

#ifdef UNIX

#ifdef BIG_ENDIAN
#define READNATIVEWORD(x) MAKEWORD(*(char*)(x), *(char*)((char*)(x) + 1))
#else 
#define READNATIVEWORD(x) MAKEWORD(*(char*)((char*)(x) + 1), *(char*)(x))
#endif

#else

#define READNATIVEWORD(x) (*(UNALIGNED WORD *)x)

#endif


__inline BOOL IsAsciiA(char ch)
{
    return !(ch & 0x80);
}

__inline BOOL IsAsciiW(WCHAR ch)
{
    return ch < 128;
}

__inline char Ascii_ToLowerA(char ch)
{
    return (ch >= 'A' && ch <= 'Z') ? (ch - 'A' + 'a') : ch;
}

__inline WCHAR Ascii_ToLowerW(WCHAR ch)
{
    return (ch >= L'A' && ch <= L'Z') ? (ch - L'A' + L'a') : ch;
}

#if 0 // FA
// WARNING: all of these APIs do not setup DS, so you can not access
// any data in the default data seg of this DLL.
//
// do not create any global variables... talk to chrisg if you don't
// understand thid


/*
 * StrEndN - Find the end of a string, but no more than n bytes
 * Assumes   lpStart points to start of null terminated string
 *           nBufSize is the maximum length
 * returns ptr to just after the last byte to be included
 */
LPSTR
lstrfns_StrEndNA(
    LPCSTR lpStart,
    int nBufSize)
{
    LPCSTR lpEnd;

    for (lpEnd = lpStart + nBufSize; *lpStart && lpStart < lpEnd;
         lpStart = AnsiNext(lpStart))
        continue;   /* just getting to the end of the string */

    if (lpStart > lpEnd)
    {
        /* We can only get here if the last byte before lpEnd was a lead byte
        */
        lpStart -= 2;
    }
    return((LPSTR)lpStart);
}


LPWSTR lstrfns_StrEndNW(LPCWSTR lpStart, int nBufSize)
{
    LPCWSTR lpEnd;

    for (lpEnd = lpStart + nBufSize; *lpStart && (lpStart < lpEnd);
         lpStart++)
        continue;   /* just getting to the end of the string */

    return((LPWSTR)lpStart);
}


/*
 * ChrCmp -  Case sensitive character comparison for DBCS
 * Assumes   w1, wMatch are characters to be compared
 * Return    FALSE if they match, TRUE if no match
 */
__inline BOOL ChrCmpA_inline(WORD w1, WORD wMatch)
{
    /* Most of the time this won't match, so test it first for speed.
    */
    if (LOBYTE(w1) == LOBYTE(wMatch))
    {
        if (IsDBCSLeadByte(LOBYTE(w1)))
        {
            return(w1 != wMatch);
        }
        return FALSE;
    }
    return TRUE;
}


__inline BOOL ChrCmpW_inline(WCHAR w1, WCHAR wMatch)
{
    return(!(w1 == wMatch));
}


#endif // FA

/*
 * ChrCmpI - Case insensitive character comparison for DBCS
 * Assumes   w1, wMatch are characters to be compared;
 *           HIBYTE of wMatch is 0 if not a DBC
 * Return    FALSE if match, TRUE if not
 */
LWSTDAPI_(BOOL) ChrCmpIA(WORD w1, WORD wMatch)
{
    char sz1[3], sz2[3];

    if (IsDBCSLeadByte(sz1[0] = LOBYTE(w1)))
    {
        sz1[1] = HIBYTE(w1);
        sz1[2] = '\0';
    }
    else
        sz1[1] = '\0';

#if defined(MWBIG_ENDIAN)
    sz2[0] = LOBYTE(wMatch);
    sz2[1] = HIBYTE(wMatch);
#else
    *(WORD *)sz2 = wMatch;
#endif
    sz2[2] = '\0';
    return lstrcmpiA(sz1, sz2);
}

LWSTDAPI_(BOOL) ChrCmpIW(WCHAR w1, WCHAR wMatch)
{
    WCHAR sz1[2], sz2[2];

    sz1[0] = w1;
    sz1[1] = '\0';
    sz2[0] = wMatch;
    sz2[1] = '\0';

    return StrCmpIW(sz1, sz2);
}

#if 0 // FA

LPWSTR StrCpyW(LPWSTR psz1, LPCWSTR psz2)
{
    LPWSTR psz = psz1;

    ASSERT(psz1);
    ASSERT(psz2);

    while (*psz1++ = *psz2++)
        ;

    return psz;
}

//***   StrCpyNX[AW] -- just like StrCpyN[AW], but returns ptr to EOS
// NOTES
//  do we really need 'A' version?  (for now we do for shell32 on 'old'
//  platforms that we test on but don't ship)
LPSTR StrCpyNXA(LPSTR psz1, LPCSTR psz2, int cchMax)
{
    RIPMSG(cchMax >= 0 && psz1 && IS_VALID_WRITE_BUFFER(psz1, char, cchMax), "StrCpyNXW: Caller passed bad psz1");
    RIPMSG(psz2 && IS_VALID_STRING_PTRA(psz2, -1), "StrCpyNXW: Caller passed bad psz2");

    if (0 < cchMax)
    {
        if (!psz2)
            goto NullItOut;

        // Leave room for the null terminator
        while (0 < --cchMax)
        {
            if ( !(*psz1++ = *psz2++) ) {
                --psz1;
                break;
            }
        }

        if (0 == cchMax)
        {
NullItOut:
            *psz1 = '\0';
        }

        ASSERT(*psz1 == 0);
    }

    return psz1;
}

LPWSTR StrCpyNXW(LPWSTR psz1, LPCWSTR psz2, int cchMax)
{
    RIPMSG(cchMax >= 0 && psz1 && IS_VALID_WRITE_BUFFER(psz1, WCHAR, cchMax), "StrCpyNXW: Caller passed bad psz1");
    RIPMSG(psz2 && IS_VALID_STRING_PTRW(psz2, -1), "StrCpyNXW: Caller passed bad psz2");

    if (0 < cchMax)
    {
        if (!psz2) // a test app passed in a NULL src ptr and we faulted, let's not fault here.
            goto NullItOut;

        // Leave room for the null terminator
        while (0 < --cchMax)
        {
            if ( !(*psz1++ = *psz2++) ) {
                --psz1;
                break;
            }
        }

        if (0 == cchMax)
        {
NullItOut:
            *psz1 = L'\0';
        }

        ASSERT(*psz1 == 0);
    }

    return psz1;
}

LPWSTR StrCpyNW(LPWSTR psz1, LPCWSTR psz2, int cchMax)
{
    StrCpyNXW(psz1, psz2, cchMax);
    return psz1;
}


LPWSTR StrCatW(LPWSTR psz1, LPCWSTR psz2)
{
    LPWSTR psz = psz1;

    ASSERT(psz1);
    ASSERT(psz2);

    while (0 != *psz1)
        psz1++;

    while (*psz1++ = *psz2++)
        ;

    return psz;
}

LWSTDAPI_(LPWSTR) StrCatBuffW(LPWSTR pszDest, LPCWSTR pszSrc, int cchDestBuffSize)
{
    LPWSTR psz;

    ASSERT(pszDest);
    ASSERT(pszSrc);
    ASSERT(cchDestBuffSize >= 0);
    VDATEINPUTBUF(pszDest, TCHAR, cchDestBuffSize);

    psz = pszDest;

    // we walk forward till we find the end of pszDest, subtracting
    // from cchDestBuffSize as we go.
    while (*psz)
    {
        psz++;
        cchDestBuffSize--;
    }

    if (cchDestBuffSize <= 0)
    {
        // check to make sure that the pszDest hadn't already overflowed its buffer!
        ASSERT(cchDestBuffSize == 0);
        return pszDest;
    }

    // call the shlwapi function here because win95 does not have lstrcpynW
    StrCpyNW(psz, pszSrc, cchDestBuffSize);

    return pszDest;
}

 
LWSTDAPI_(LPSTR) StrCatBuffA(LPSTR pszDest, LPCSTR pszSrc, int cchDestBuffSize)
{
    LPSTR psz;
   
    ASSERT(pszDest);
    ASSERT(pszSrc);
    ASSERT(cchDestBuffSize >= 0);
    VDATEINPUTBUF(pszDest, CHAR, cchDestBuffSize);

    psz = pszDest;
    
    // we walk forward till we find the end of pszDest, subtracting
    // from cchDestBuffSize as we go.
    while (*psz)
    {
        psz++;
        cchDestBuffSize--;
    }

    if (cchDestBuffSize <= 0)
    {
        // check to make sure that the pszDest hadn't already overflowed its buffer!
        ASSERT(cchDestBuffSize == 0);
        return pszDest;
    }

    // Let kernel do the work for us. 
    //
    // WARNING: We might generate a truncated DBCS sting becuase kernel's lstrcpynA
    // dosent check for this. Ask me if I care.
    lstrcpynA(psz, pszSrc, cchDestBuffSize);

    return pszDest;
}
   

/* StrNCat(front, back, count) - append count chars of back onto front
 */
LPSTR StrNCatA(LPSTR front, LPCSTR back, int cchMax)
{
    LPSTR start = front;

    while (*front++)
                ;
    front--;

    lstrcpyn(front, back, cchMax);

    return(start);    
}

LPWSTR StrNCatW(LPWSTR front, LPCWSTR back, int cchMax)
{
    LPWSTR start = front;

    while (*front++)
                ;
    front--;

    StrCpyNW(front, back, cchMax);
    
    return(start);    
}

/*
 * StrChr - Find first occurrence of character in string
 * Assumes   lpStart points to start of null terminated string
 *           wMatch  is the character to match
 * returns ptr to the first occurrence of ch in str, NULL if not found.
 */
LPSTR _StrChrA(LPCSTR lpStart, WORD wMatch, BOOL fMBCS)
{
    if (fMBCS) {
        for ( ; *lpStart; lpStart = AnsiNext(lpStart))
        {
            if (!ChrCmpA_inline(READNATIVEWORD(lpStart), wMatch))
                return((LPSTR)lpStart);
        }
    } else {
        for ( ; *lpStart; lpStart++)
        {
            if ((BYTE)*lpStart == LOBYTE(wMatch)) {
                return((LPSTR)lpStart);
            }
        }
    }
    return (NULL);
}

LPSTR StrChrA(LPCSTR lpStart, WORD wMatch)
{
    CPINFO cpinfo;
    return _StrChrA(lpStart, wMatch, GetCPInfo(CP_ACP, &cpinfo) && cpinfo.LeadByte[0]);
}

#ifdef ALIGNMENT_SCENARIO

LPWSTR StrChrSlowW(const UNALIGNED WCHAR *lpStart, WCHAR wMatch)
{
    for ( ; *lpStart; lpStart++)
    {
      if (!ChrCmpW_inline(*lpStart, wMatch))
        {
            return((LPWSTR)lpStart);
        }
    }
}
#endif

LPWSTR StrChrW(LPCWSTR lpStart, WCHAR wMatch)
{
    //
    //  BUGBUG raymondc
    //  Apparently, somebody is passing unaligned strings to StrChrW.
    //  Find out who and make them stop.
    //
    ASSERT(!((ULONG_PTR)lpStart & 1)); // Assert alignedness

#ifdef ALIGNMENT_SCENARIO
    //
    //  Since unaligned strings arrive so rarely, put the slow
    //  version in a separate function so the common case stays
    //  fast.  Believe it or not, we call StrChrW so often that
    //  it is now a performance-sensitive function!
    //
    if ((ULONG_PTR)lpStart & 1)
        return StrChrSlowW(lpStart, wMatch);
#endif

    for ( ; *lpStart; lpStart++)
    {
      if (!ChrCmpW_inline(*lpStart, wMatch))
        {
            return((LPWSTR)lpStart);
        }
    }
    return (NULL);
}

/*
 * StrRChr - Find last occurrence of character in string
 * Assumes   lpStart points to start of string
 *           lpEnd   points to end of string (NOT included in search)
 *           wMatch  is the character to match
 * returns ptr to the last occurrence of ch in str, NULL if not found.
 */
LPSTR StrRChrA(LPCSTR lpStart, LPCSTR lpEnd, WORD wMatch)
{
    LPCSTR lpFound = NULL;

    ASSERT(lpStart);
    ASSERT(!lpEnd || lpEnd <= lpStart + lstrlenA(lpStart));

    if (!lpEnd)
        lpEnd = lpStart + lstrlenA(lpStart);

    for ( ; lpStart < lpEnd; lpStart = AnsiNext(lpStart))
    {
        // (ChrCmp returns FALSE when characters match)

        if (!ChrCmpA_inline(READNATIVEWORD(lpStart), wMatch))
            lpFound = lpStart;
    }
    return ((LPSTR)lpFound);
}

LPWSTR StrRChrW(LPCWSTR lpStart, LPCWSTR lpEnd, WCHAR wMatch)
{
    LPCWSTR lpFound = NULL;

    if (!lpEnd)
        lpEnd = lpStart + lstrlenW(lpStart);

    for ( ; lpStart < lpEnd; lpStart++)
    {
        if (!ChrCmpW_inline(*lpStart, wMatch))
            lpFound = lpStart;
    }
    return ((LPWSTR)lpFound);
}

/*
 * StrChrI - Find first occurrence of character in string, case insensitive
 * Assumes   lpStart points to start of null terminated string
 *           wMatch  is the character to match
 * returns ptr to the first occurrence of ch in str, NULL if not found.
 */
LPSTR StrChrIA(LPCSTR lpStart, WORD wMatch)
{
    wMatch = (UINT)(IsDBCSLeadByte(LOBYTE(wMatch)) ? wMatch : LOBYTE(wMatch));

    for ( ; *lpStart; lpStart = AnsiNext(lpStart))
    {
        if (!ChrCmpIA(READNATIVEWORD(lpStart), wMatch))
            return((LPSTR)lpStart);
    }
    return (NULL);
}

LPWSTR StrChrIW(LPCWSTR lpStart, WCHAR wMatch)
{
    for ( ; *lpStart; lpStart++)
    {
        if (!ChrCmpIW(*lpStart, wMatch))
            return((LPWSTR)lpStart);
    }
    return (NULL);
}

/*
 * StrRChrI - Find last occurrence of character in string, case insensitive
 * Assumes   lpStart points to start of string
 *           lpEnd   points to end of string (NOT included in search)
 *           wMatch  is the character to match
 * returns ptr to the last occurrence of ch in str, NULL if not found.
 */
LPSTR StrRChrIA(LPCSTR lpStart, LPCSTR lpEnd, WORD wMatch)
{
    LPCSTR lpFound = NULL;

    ASSERT(lpStart);
    ASSERT(!lpEnd || lpEnd <= lpStart + lstrlenA(lpStart));

    if (!lpEnd)
        lpEnd = lpStart + lstrlenA(lpStart);

    wMatch = (UINT)(IsDBCSLeadByte(LOBYTE(wMatch)) ? wMatch : LOBYTE(wMatch));

    for ( ; lpStart < lpEnd; lpStart = AnsiNext(lpStart))
    {
        if (!ChrCmpIA(READNATIVEWORD(lpStart), wMatch))
            lpFound = lpStart;
    }
    return ((LPSTR)lpFound);
}


LPWSTR StrRChrIW(LPCWSTR lpStart, LPCWSTR lpEnd, WCHAR wMatch)
{
    LPCWSTR lpFound = NULL;

    if (!lpEnd)
        lpEnd = lpStart + lstrlenW(lpStart);

    for ( ; lpStart < lpEnd; lpStart++)
    {
        if (!ChrCmpIW(*lpStart, wMatch))
            lpFound = lpStart;
    }
    return ((LPWSTR)lpFound);
}


/*----------------------------------------------------------
Purpose: Returns a pointer to the first occurrence of a character
         in psz that belongs to the set of characters in pszSet.
         The search does not include the null terminator.

         If psz contains no characters that are in the set of
         characters in pszSet, this function returns NULL.

         This function is DBCS-safe.

Returns: see above
Cond:    --
*/
LPSTR
WINAPI
StrPBrkA(LPCSTR psz, LPCSTR pszSet)
{
    LPCSTR pszSetT;

    ASSERT(psz);
    ASSERT(pszSet);

    while (*psz)
    {
        for (pszSetT = pszSet; *pszSetT; pszSetT = CharNextA(pszSetT))
        {
            if (*psz == *pszSetT)
            {
                // Found first character that matches
                return (LPSTR)psz;      // Const -> non-const
            }
        }
        psz = CharNextA(psz);
    }

    return NULL;
}


/*----------------------------------------------------------
Purpose: Returns a pointer to the first occurrence of a character
         in psz that belongs to the set of characters in pszSet.
         The search does not include the null terminator.

Returns: see above
Cond:    --
*/
LPWSTR WINAPI StrPBrkW(LPCWSTR psz, LPCWSTR pszSet)
{
    LPCWSTR pszSetT;

    ASSERT(psz);
    ASSERT(pszSet);

    // Go thru the string to be inspected

    while (*psz)
    {
        // Go thru the char set

        for (pszSetT = pszSet; *pszSetT; pszSetT++)
        {
            if (*psz == *pszSetT)
            {
                // Found first character that matches
                return (LPWSTR)psz;     // Const -> non-const
            }
        }
        psz++;
    }

    return NULL;
}


int WINAPI StrToIntA(LPCSTR lpSrc)
{
    int n = 0;
    BOOL bNeg = FALSE;

    if (*lpSrc == '-') {
        bNeg = TRUE;
        lpSrc++;
    }

    while (IS_DIGITA(*lpSrc)) {
        n *= 10;
        n += *lpSrc - '0';
        lpSrc++;
    }
    return bNeg ? -n : n;
}


int WINAPI StrToIntW(LPCWSTR lpSrc)
{
    int n = 0;
    BOOL bNeg = FALSE;

    if (*lpSrc == L'-') {
        bNeg = TRUE;
        lpSrc++;
    }

    while (IS_DIGITW(*lpSrc)) {
        n *= 10;
        n += *lpSrc - L'0';
        lpSrc++;
    }
    return bNeg ? -n : n;
}


/*----------------------------------------------------------
Purpose: Special verion of atoi.  Supports hexadecimal too.

         If this function returns FALSE, *piRet is set to 0.

Returns: TRUE if the string is a number, or contains a partial number
         FALSE if the string is not a number

        dwFlags are STIF_ bitfield
Cond:    --
*/
BOOL WINAPI StrToIntExA(LPCSTR pszString, DWORD dwFlags, int *piRet)
{
    BOOL bRet;
    int n;
    BOOL bNeg = FALSE;
    LPCSTR psz;
    LPCSTR pszAdj;

    // Skip leading whitespace
    //
    for (psz = pszString; *psz == ' ' || *psz == '\n' || *psz == '\t'; psz = CharNextA(psz))
        ;

    // Determine possible explicit signage
    //
    if (*psz == '+' || *psz == '-')
    {
        bNeg = (*psz == '+') ? FALSE : TRUE;
        psz++;
    }

    // Or is this hexadecimal?
    //
    pszAdj = CharNextA(psz);
    if ((STIF_SUPPORT_HEX & dwFlags) &&
        *psz == '0' && (*pszAdj == 'x' || *pszAdj == 'X'))
    {
        // Yes

        // (Never allow negative sign with hexadecimal numbers)
        bNeg = FALSE;
        psz = CharNextA(pszAdj);

        pszAdj = psz;

        // Do the conversion
        //
        for (n = 0; ; psz = CharNextA(psz))
        {
            if (IS_DIGITA(*psz))
                n = 0x10 * n + *psz - '0';
            else
            {
                CHAR ch = *psz;
                int n2;

                if (ch >= 'a')
                    ch -= 'a' - 'A';

                n2 = ch - 'A' + 0xA;
                if (n2 >= 0xA && n2 <= 0xF)
                    n = 0x10 * n + n2;
                else
                    break;
            }
        }

        // Return TRUE if there was at least one digit
        bRet = (psz != pszAdj);
    }
    else
    {
        // No
        pszAdj = psz;

        // Do the conversion
        for (n = 0; IS_DIGITA(*psz); psz = CharNextA(psz))
            n = 10 * n + *psz - '0';

        // Return TRUE if there was at least one digit
        bRet = (psz != pszAdj);
    }

    *piRet = bNeg ? -n : n;

    return bRet;
}


/*----------------------------------------------------------
 Purpose: Wide-char wrapper for StrToIntExA.

 Returns: see StrToIntExA
 Cond:    --
 */
BOOL WINAPI StrToIntExW(
    LPCWSTR   pwszString,
    DWORD     dwFlags,          // STIF_ bitfield
    int FAR * piRet)
{
    // Most strings will simply use this temporary buffer, but AnsiFromUnicode
    // will allocate a buffer if the supplied string is bigger.
    CHAR szBuf[MAX_PATH];

    LPSTR pszString;
    BOOL bRet = AnsiFromUnicode(&pszString, pwszString, szBuf, SIZECHARS(szBuf));

    if (bRet)
    {
        bRet = StrToIntExA(pszString, dwFlags, piRet);
        AnsiFromUnicode(&pszString, NULL, szBuf, 0);
    }
    return bRet;
}


/*----------------------------------------------------------
 Purpose: Returns an integer value specifying the length of
 the substring in psz that consists entirely of
 characters in pszSet.  If psz begins with a character
 not in pszSet, then this function returns 0.

 This is a DBCS-safe version of the CRT strspn().

 Returns: see above
 Cond:    --
 */
int
WINAPI
StrSpnA(
        LPCSTR psz,
        LPCSTR pszSet)
{
    LPCSTR pszT;
    LPCSTR pszSetT;

    // Go thru the string to be inspected

    for (pszT = psz; *pszT; pszT = CharNextA(pszT))
    {
        // Go thru the char set

        for (pszSetT = pszSet; *pszSetT; pszSetT = CharNextA(pszSetT))
        {
            if (*pszSetT == *pszT)
            {
                if ( !IsDBCSLeadByte(*pszSetT) )
                {
                    break;      // Chars match
                }
                else if (pszSetT[1] == pszT[1])
                {
                    break;      // Chars match
                }
            }
        }

        // End of char set?
        if (0 == *pszSetT)
        {
            break;      // Yes, no match on this inspected char
        }
    }

    return (int)(pszT - psz);
}


/*----------------------------------------------------------
 Purpose: Returns an integer value specifying the length of
 the substring in psz that consists entirely of
 characters in pszSet.  If psz begins with a character
 not in pszSet, then this function returns 0.

 This is a DBCS-safe version of the CRT strspn().

 Returns: see above
 Cond:    --
 */
STDAPI_(int) StrSpnW(LPCWSTR psz, LPCWSTR pszSet)
{
    LPCWSTR pszT;
    LPCWSTR pszSetT;

    ASSERT(psz);
    ASSERT(pszSet);

    // Go thru the string to be inspected

    for (pszT = psz; *pszT; pszT++)
    {
        // Go thru the char set

        for (pszSetT = pszSet; *pszSetT != *pszT; pszSetT++)
        {
            if (0 == *pszSetT)
            {
                // Reached end of char set without finding a match
                return (int)(pszT - psz);
            }
        }
    }

    return (int)(pszT - psz);
}


// StrCSpn: return index to first char of lpStr that is present in lpSet.
// Includes the NUL in the comparison; if no lpSet chars are found, returns
// the index to the NUL in lpStr.
// Just like CRT strcspn.
//
int StrCSpnA(LPCSTR lpStr, LPCSTR lpSet)
{
    // nature of the beast: O(lpStr*lpSet) work
    LPCSTR lp = lpStr;
    if (!lpStr || !lpSet)
        return 0;

    while (*lp)
    {
        if (StrChrA(lpSet, READNATIVEWORD(lp)))
            return (int)(lp-lpStr);
        lp = AnsiNext(lp);
    }

    return (int)(lp-lpStr); // ==lstrlen(lpStr)
}

int StrCSpnW(LPCWSTR lpStr, LPCWSTR lpSet)
{
    // nature of the beast: O(lpStr*lpSet) work
    LPCWSTR lp = lpStr;
    if (!lpStr || !lpSet)
        return 0;

    while (*lp)
    {
        if (StrChrW(lpSet, *lp))
            return (int)(lp-lpStr);
        lp++;
    }

    return (int)(lp-lpStr); // ==lstrlen(lpStr)
}

// StrCSpnI: case-insensitive version of StrCSpn.
//
int StrCSpnIA(LPCSTR lpStr, LPCSTR lpSet)
{
    // nature of the beast: O(lpStr*lpSet) work
    LPCSTR lp = lpStr;
    if (!lpStr || !lpSet)
        return 0;

    while (*lp)
    {
        if (StrChrIA(lpSet, READNATIVEWORD(lp)))
            return (int)(lp-lpStr);
        lp = AnsiNext(lp);
    }

    return (int)(lp-lpStr); // ==lstrlen(lpStr)
}

int StrCSpnIW(LPCWSTR lpStr, LPCWSTR lpSet)
{
    // nature of the beast: O(lpStr*lpSet) work
    LPCWSTR lp = lpStr;
    if (!lpStr || !lpSet)
        return 0;

    while (*lp)
    {
        if (StrChrIW(lpSet, *lp))
            return (int)(lp-lpStr);
        lp++;
    }

    return (int)(lp-lpStr); // ==lstrlen(lpStr)
}


/*
 * StrCmpN      - Compare n bytes
 *
 * returns   See lstrcmp return values.
 */
int _StrCmpNA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar, BOOL fMBCS)
{
    LPCSTR lpszEnd = lpStr1 + nChar;
    char sz1[4];
    char sz2[4];

    if (fMBCS) {
        for ( ; (lpszEnd > lpStr1) && (*lpStr1 || *lpStr2); lpStr1 = AnsiNext(lpStr1), lpStr2 = AnsiNext(lpStr2)) {
            WORD w1;
            WORD w2;
    
            // If either pointer is at the null terminator already,
            // we want to copy just one byte to make sure we don't read 
            // past the buffer (might be at a page boundary).
    
            w1 = (*lpStr1) ? READNATIVEWORD(lpStr1) : 0;
            w2 = (*lpStr2) ? READNATIVEWORD(lpStr2) : 0;
    
            // (ChrCmpA returns FALSE if the characters match)
    
            // Do the characters match?
            if (ChrCmpA_inline(w1, w2)) 
            {
                // No; determine the lexical value of the comparison
                // (since ChrCmp just returns true/false).
    
                // Since the character may be a DBCS character; we
                // copy two bytes into each temporary buffer 
                // (in preparation for the lstrcmp call).
    
                (*(WORD *)sz1) = w1;
                (*(WORD *)sz2) = w2;
    
                // Add null terminators to temp buffers
                *AnsiNext(sz1) = 0;
                *AnsiNext(sz2) = 0;
                return lstrcmpA(sz1, sz2);
            }
        }
    } else {
        for ( ; (lpszEnd > lpStr1) && (*lpStr1 || *lpStr2); lpStr1++, lpStr2++) {
            if (*lpStr1 != *lpStr2) {
                // No; determine the lexical value of the comparison
                // (since ChrCmp just returns true/false).
                sz1[0] = *lpStr1;
                sz2[0] = *lpStr2;
                sz1[1] = sz2[1] = '\0';
                return lstrcmpA(sz1, sz2);
            }
        }
    }

    return 0;
}

STDAPI_(int) StrCmpNA(LPCSTR psz1, LPCSTR psz2, int nChar)
{
    CPINFO cpinfo;
    return _StrCmpNA(psz1, psz2, nChar, GetCPInfo(CP_ACP, &cpinfo) && cpinfo.LeadByte[0]);
}
#endif

// cch1 and cch2 are the maximum # of chars to compare

int _StrCmpLocaleW(DWORD dwFlags, LPCWSTR psz1, int cch1, LPCWSTR psz2, int cch2)
{
    int i = CompareStringW(GetThreadLocale(), dwFlags, psz1, cch1, psz2, cch2);
    if (!i)
    {
        i = CompareStringW(LOCALE_SYSTEM_DEFAULT, dwFlags, psz1, cch1, psz2, cch2);
    }
    return i - CSTR_EQUAL;
}

int _StrCmpLocaleA(DWORD dwFlags, LPCSTR psz1, int cch1, LPCSTR psz2, int cch2)
{
    int i = CompareStringA(GetThreadLocale(), dwFlags, psz1, cch1, psz2, cch2);
    if (!i)
    {
        i = CompareStringA(LOCALE_SYSTEM_DEFAULT, dwFlags, psz1, cch1, psz2, cch2);
    }
    return i - CSTR_EQUAL;
}


STDAPI_(int) StrCmpNW(LPCWSTR psz1, LPCWSTR psz2, int nChar)
{
    return _StrCmpLocaleW(NORM_STOP_ON_NULL, psz1, nChar, psz2, nChar);
}

/*
 * Compare n bytes, case insensitive
 *
 * returns   See lstrcmpi return values.
 */

LWSTDAPI_(int) StrCmpNIA(LPCSTR psz1, LPCSTR psz2, int nChar)
{
    if (g_bRunningOnNT)
    {
        return _StrCmpLocaleA(NORM_IGNORECASE | NORM_STOP_ON_NULL,  psz1, nChar, psz2, nChar);
    }
    else
    {
        //  Win95 doesn't support NORM_STOP_ON_NULL
        int i;
        LPCSTR lpszEnd = psz1 + nChar;

        for ( ; (lpszEnd > psz1) && (*psz1 || *psz2); (psz1 = AnsiNext(psz1)), (psz2 = AnsiNext(psz2))) 
        {
            WORD w1, w2;

            // If either pointer is at the null terminator already,
            // we want to copy just one byte to make sure we don't read 
            // past the buffer (might be at a page boundary).

            if (IsAsciiA(*psz1) && IsAsciiA(*psz2))
            {
                i = Ascii_ToLowerA(*psz1) - Ascii_ToLowerA(*psz2);
            }
            else
            {
                w1 = (*psz1) ? READNATIVEWORD(psz1) : 0;
                w2 = (UINT)(IsDBCSLeadByte(*psz2)) ? (UINT)READNATIVEWORD(psz2) : (WORD)(BYTE)(*psz2);

                i = ChrCmpIA(w1, w2);
            }
            if (i)
            {
                if (i < 0)
                    return -1;
                else
                    return 1;
            }
        }
        return 0;
    }
}

LWSTDAPI_(int) StrCmpNIW(LPCWSTR psz1, LPCWSTR psz2, int nChar)
{
    return _StrCmpLocaleW(NORM_IGNORECASE | NORM_STOP_ON_NULL, psz1, nChar, psz2, nChar);
}

#if 0
/*
 * StrRStrI      - Search for last occurrence of a substring
 *
 * Assumes   lpSource points to the null terminated source string
 *           lpLast points to where to search from in the source string
 *           lpLast is not included in the search
 *           lpSrch points to string to search for
 * returns   last occurrence of string if successful; NULL otherwise
 */
LPSTR StrRStrIA(LPCSTR lpSource, LPCSTR lpLast, LPCSTR lpSrch)
{
    LPCSTR lpFound = NULL;
    WORD   wMatch;
    UINT   uLen = 0;
    LPCSTR  lpStart = NULL;
    
    if (!lpLast)
        lpLast = lpSource + lstrlenA(lpSource);

    if (lpSource >= lpLast || *lpSrch == 0)
        return NULL;

    wMatch = READNATIVEWORD(lpSrch);
    wMatch = (UINT)(IsDBCSLeadByte(LOBYTE(wMatch)) ? wMatch : LOBYTE(wMatch));
    
    uLen = lstrlenA(lpSrch);
    lpStart = lpSource;
    while (*lpStart && (lpStart < lpLast))
    {
        if (!ChrCmpIA(READNATIVEWORD(lpStart), wMatch))
        {   
            if (StrCmpNIA(lpStart, lpSrch, uLen) == 0)
                lpFound = lpStart;
        }   
        lpStart = AnsiNext(lpStart);
    }
    
    return((LPSTR)lpFound);
}

LPWSTR StrRStrIW(LPCWSTR lpSource, LPCWSTR lpLast, LPCWSTR lpSrch)
{
    LPCWSTR lpFound = NULL;
    WCHAR   wMatch;
    UINT    uLen = 0;
    LPCWSTR  lpStart = NULL;

    if (!lpLast)
        lpLast = lpSource + lstrlenW(lpSource);

    if (lpSource >= lpLast || *lpSrch == 0)
        return NULL;

    wMatch = *lpSrch;
    uLen = lstrlenW(lpSrch);
    lpStart = lpSource;
    while (*lpStart && (lpStart < lpLast))
    {
        if (!ChrCmpIW(*lpStart, wMatch))
        {   
            if (StrCmpNIW(lpStart, lpSrch, uLen) == 0)
                lpFound = lpStart;
        }   
        lpStart++;
    }
    
    return((LPWSTR)lpFound);
}

/*
 * StrStr      - Search for first occurrence of a substring
 *
 * Assumes   lpSource points to source string
 *           lpSrch points to string to search for
 * returns   first occurrence of string if successful; NULL otherwise
 */
LPSTR StrStrA(LPCSTR lpFirst, LPCSTR lpSrch)
{
    UINT uLen;
    WORD wMatch;
    CPINFO cpinfo;
    BOOL fMBCS = GetCPInfo(CP_ACP, &cpinfo) && cpinfo.LeadByte[0];

    uLen = (UINT)lstrlenA(lpSrch);
    wMatch = READNATIVEWORD(lpSrch);

    for ( ; (lpFirst=_StrChrA(lpFirst, wMatch, fMBCS))!=0 && _StrCmpNA(lpFirst, lpSrch, uLen, fMBCS);
         lpFirst=AnsiNext(lpFirst))
        continue; /* continue until we hit the end of the string or get a match */

    return((LPSTR)lpFirst);
}

LPWSTR StrStrW(LPCWSTR lpFirst, LPCWSTR lpSrch)
{
    UINT uLen = (UINT)lstrlenW(lpSrch);
    WCHAR wMatch = *lpSrch;

    for ( ; (lpFirst=StrChrW(lpFirst, wMatch))!=0 && StrCmpNW(lpFirst, lpSrch, uLen);
         lpFirst++)
        continue; /* continue until we hit the end of the string or get a match */

    return (LPWSTR)lpFirst;
}

/*
 * StrStrI   - Search for first occurrence of a substring, case insensitive
 *
 * Assumes   lpFirst points to source string
 *           lpSrch points to string to search for
 * returns   first occurrence of string if successful; NULL otherwise
 */
LPSTR StrStrIA(LPCSTR lpFirst, LPCSTR lpSrch)
{
    UINT uLen = (UINT)lstrlenA(lpSrch);
    WORD wMatch = READNATIVEWORD(lpSrch);

    for ( ; (lpFirst = StrChrIA(lpFirst, wMatch)) != 0 && StrCmpNIA(lpFirst, lpSrch, uLen);
         lpFirst=AnsiNext(lpFirst))
        continue; /* continue until we hit the end of the string or get a match */

    return (LPSTR)lpFirst;
}

LPWSTR StrStrIW(LPCWSTR lpFirst, LPCWSTR lpSrch)
{
    UINT uLen = (UINT)lstrlenW(lpSrch);
    WCHAR wMatch = *lpSrch;

    for ( ; (lpFirst = StrChrIW(lpFirst, wMatch)) != 0 && StrCmpNIW(lpFirst, lpSrch, uLen);
         lpFirst++)
        continue; /* continue until we hit the end of the string or get a match */

    return (LPWSTR)lpFirst;
}

LPSTR StrDupA(LPCSTR psz)
{
    LPSTR pszRet = (LPSTR)LocalAlloc(LPTR, (lstrlenA(psz) + 1) * sizeof(*pszRet));
    if (pszRet) 
    {
        lstrcpyA(pszRet, psz);
    }
    return pszRet;
}

LPWSTR StrDupW(LPCWSTR psz)
{
    LPWSTR pszRet = (LPWSTR)LocalAlloc(LPTR, (lstrlenW(psz) + 1) * sizeof(*pszRet));
    if (pszRet) 
    {
        StrCpyW(pszRet, psz);
    }
    return pszRet;
}

void _StrOut(LPSTR* ppszBuf, HMODULE hmod, UINT idRes, DWORD* pdwTimeS, int* pdigits, UINT iDiv)
{
    if (*pdigits)
    {
        DWORD dwCur = *pdwTimeS/iDiv;

        if (dwCur || iDiv==1) 
        {
            DWORD dwBase;
            CHAR szBuf[64], szTemplate[64];
            LPSTR pszBuf = szBuf;

            *pdwTimeS -= dwCur*iDiv;
            for (dwBase=1; dwCur/(dwBase*10); dwBase*=10);

            DebugMsg(DM_INTERVAL, TEXT("dwCur, dwBase, *pdwTimeS = %d, %d, %d"), dwCur, dwBase, *pdwTimeS);

            //
            // LATER: We could use atoi if we mathematically trancate
            //  the numbers based on digits.
            //
            for (;dwBase; dwBase/=10, pszBuf++) 
            {
                if (*pdigits) 
                {
                    DWORD i = dwCur/dwBase;
                    dwCur -= i*dwBase;
                    *pszBuf = '0'+(unsigned short)i;
                    (*pdigits)--;
                } 
                else 
                {
                    *pszBuf = '0';
                }
            }
            *pszBuf = '\0';

            LoadStringA(hmod, idRes, szTemplate, ARRAYSIZE(szTemplate));
            wsprintfA(*ppszBuf, szTemplate, szBuf);
            (*ppszBuf) += lstrlenA(*ppszBuf);
        }
    }
}

BOOL _StrFromTimeInterval(LPSTR szBuf, DWORD dwTimeMS, int digits)
{
    DWORD dwTimeS = (dwTimeMS+500)/1000;
    LPSTR pszBuf = szBuf;
    DebugMsg(DM_INTERVAL, TEXT("dwTimeS = %d"), dwTimeS);

    szBuf = '\0';

    _StrOut(&pszBuf, g_hinst, IDS_HOUR, &dwTimeS, &digits, 3600);
    _StrOut(&pszBuf, g_hinst, IDS_MIN, &dwTimeS, &digits, 60);
    _StrOut(&pszBuf, g_hinst, IDS_SEC, &dwTimeS, &digits, 1);

    return TRUE;
}

//
//  This API converts a given time-interval (in msec) into a human readable
// string.
//
// Parameters:
//  pszOut   -- Specifies the string buffer. NULL is valid to query size.
//  cchMax   -- Specifies the size of buffer in char/WCHAR
//  dwTimeMS -- Specifies the time interval in msec
//  digits   -- Specifies the minimum number of digits to be displayed
//
// Returns:
//  Number of characters in the buffer (not including the terminator).
//
// Exmaples:
//  dwTimeMS digits     output
//   34000     3         34 sec
//   34000     2         34 sec
//   34000     1         30 sec
//   74000     3         1 min 14 sec
//   74000     2         1 min 10 sec
//   74000     1         1 min
//
int StrFromTimeIntervalA(LPSTR pszOut, UINT cchMax, DWORD dwTimeMS, int digits)
{
    CHAR szBuf[256];
    int cchRet = 0;
    if (_StrFromTimeInterval(szBuf, dwTimeMS, digits)) 
    {
        if (pszOut) 
        {
            lstrcpynA(pszOut, szBuf, cchMax);
            cchRet = lstrlenA(pszOut);
        }
        else 
        {
            cchRet = lstrlenA(szBuf);
        }
    }
    return cchRet;
}

int StrFromTimeIntervalW(LPWSTR pwszOut, UINT cchMax, DWORD dwTimeMS, int digits)
{
    CHAR szBuf[256];
    int cchRet = 0;
    if (_StrFromTimeInterval(szBuf, dwTimeMS, digits)) 
    {
        // - 1 because MultiByteToWideChar() also counts the NULL termination
        cchRet = MultiByteToWideChar(CP_ACP, 0, szBuf, -1, pwszOut, cchMax) - 1;
    }
    return cchRet;
}

/*
 * IntlStrEq
 *
 * returns TRUE if strings are equal, FALSE if not
 */
BOOL StrIsIntlEqualA(BOOL fCaseSens, LPCSTR lpString1, LPCSTR lpString2, int nChar) 
{
    DWORD dwFlags = fCaseSens ? LOCALE_USE_CP_ACP : (NORM_IGNORECASE | LOCALE_USE_CP_ACP);

    if (g_bRunningOnNT)
    {
        dwFlags |= NORM_STOP_ON_NULL;   // only supported on NT
    }
    else if (nChar != -1)
    {
        // On Win9x we have to do the check manually
        //
        int cch = 0;
        LPCSTR psz1 = lpString1;
        LPCSTR psz2 = lpString2;

        while(*psz1 != 0 && *psz2 != 0 && cch < nChar) 
        {
            psz1 = CharNextA(psz1);
            psz2 = CharNextA(psz2);
            cch = (int) min(psz1 - lpString1, psz2 - lpString2);
        }

        // add one in for terminating '\0'
        cch++;
        if (cch < nChar)
            nChar = cch;
    }
    return 0 == _StrCmpLocaleA(dwFlags, lpString1, nChar, lpString2, nChar);
}

BOOL StrIsIntlEqualW(BOOL fCaseSens, LPCWSTR psz1, LPCWSTR psz2, int nChar) 
{
    return 0 == _StrCmpLocaleW(fCaseSens ? NORM_STOP_ON_NULL : NORM_IGNORECASE | NORM_STOP_ON_NULL, 
        psz1, nChar, psz2, nChar);
}

// This is stolen from shell32 - util.c

#define LODWORD(_qw)    (DWORD)(_qw)

const short c_aOrders[] = {IDS_BYTES, IDS_ORDERKB, IDS_ORDERMB,
                          IDS_ORDERGB, IDS_ORDERTB, IDS_ORDERPB, IDS_ORDEREB};

// takes a DWORD add commas etc to it and puts the result in the buffer
LPWSTR CommifyString(DWORD dw, LPWSTR pszBuf, UINT cchBuf)
{
    WCHAR szNum[30], szSep[5];
    NUMBERFMTW nfmt;

    nfmt.NumDigits = 0;
    nfmt.LeadingZero = 0;
    GetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szSep, ARRAYSIZE(szSep));
    nfmt.Grouping = StrToIntW(szSep);
    GetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szSep, ARRAYSIZE(szSep));
    nfmt.lpDecimalSep = nfmt.lpThousandSep = szSep;
    nfmt.NegativeOrder = 0;

    wnsprintfW(szNum, ARRAYSIZE(szNum), L"%lu", dw);

    if (GetNumberFormatW(LOCALE_USER_DEFAULT, 0, szNum, &nfmt, pszBuf, cchBuf) == 0)
        StrCpyNW(pszBuf, szNum, cchBuf);

    return pszBuf;
}

/* converts numbers into sort formats
 *      532     -> 523 bytes
 *      1340    -> 1.3KB
 *      23506   -> 23.5KB
 *              -> 2.4MB
 *              -> 5.2GB
 */

LPWSTR StrFormatByteSizeW(LONGLONG n, LPWSTR pszBuf, UINT cchBuf)
{
    WCHAR szWholeNum[32], szOrder[32];
    int iOrder;

    // If the size is less than 1024, then the order should be bytes we have nothing
    // more to figure out
    if (n < 1024) 
    {
        wnsprintfW(szWholeNum, ARRAYSIZE(szWholeNum), L"%d", LODWORD(n));
        iOrder = 0;
    }
    else
    {
        UINT uInt, uLen, uDec;
        WCHAR szFormat[8];

        // Find the right order
        for (iOrder = 1; iOrder < ARRAYSIZE(c_aOrders) -1 && n >= 1000L * 1024L; n >>= 10, iOrder++);
            /* do nothing */

        uInt = LODWORD(n >> 10);
        CommifyString(uInt, szWholeNum, ARRAYSIZE(szWholeNum));
        uLen = lstrlenW(szWholeNum);
        if (uLen < 3)
        {
            uDec = LODWORD(n - (LONGLONG)uInt * 1024L) * 1000 / 1024;
            // At this point, uDec should be between 0 and 1000
            // we want get the top one (or two) digits.
            uDec /= 10;
            if (uLen == 2)
                uDec /= 10;

            // Note that we need to set the format before getting the
            // intl char.
            StrCpyW(szFormat, L"%02d");

            szFormat[2] = TEXT('0') + 3 - uLen;
            GetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL,
                           szWholeNum + uLen, ARRAYSIZE(szWholeNum) - uLen);
            uLen = lstrlenW(szWholeNum);
            wnsprintfW(szWholeNum + uLen, ARRAYSIZE(szWholeNum) - uLen, szFormat, uDec);
        }
    }

    MLLoadStringW(c_aOrders[iOrder], szOrder, ARRAYSIZE(szOrder));
    wnsprintfW(pszBuf, cchBuf, szOrder, szWholeNum);
    return pszBuf;
}

// dw - the nubmer to be converted
// pszBuf - buffer for the resulting string
// cchBuf - Max characters in Buffer

LPSTR StrFormatByteSize64A(LONGLONG dw, LPSTR pszBuf, UINT cchBuf)
{
    WCHAR szT[32];

    StrFormatByteSizeW(dw, szT, SIZECHARS(szT));

    SHUnicodeToAnsi(szT, pszBuf, cchBuf);
    return pszBuf;
}

LPSTR StrFormatByteSizeA(DWORD dw, LPSTR pszBuf, UINT cchBuf)
{
    return StrFormatByteSize64A((LONGLONG)dw, pszBuf, cchBuf);
}

LPWSTR StrFormatKBSizeW(LONGLONG n, LPWSTR pszBuf, UINT cchBuf)
{
    static WCHAR s_szOrder[16] = {0};
    WCHAR szNum[64];

    if (s_szOrder[0] == TEXT('\0'))
        LoadStringW(HINST_THISDLL, IDS_ORDERKB, s_szOrder, ARRAYSIZE(s_szOrder));

    CommifyString(LODWORD((n + 1023) / 1024), szNum, ARRAYSIZE(szNum));

    wnsprintfW(pszBuf, cchBuf, s_szOrder, szNum);
    return pszBuf;
}

LPSTR StrFormatKBSizeA(LONGLONG n, LPSTR pszBuf, UINT cchBuf)
{
    WCHAR szNum[64];

    StrFormatKBSizeW(n, szNum, ARRAYSIZE(szNum));

    SHUnicodeToAnsi(szNum, pszBuf, cchBuf);
    return pszBuf;
}

//  Win95 does not support the wide-char version of lstrcmp, lstrcmpi
//  Wrapper for lstrcmpW so it works on Win95

int StrCmpW(LPCWSTR pwsz1, LPCWSTR pwsz2)
{
    return _StrCmpLocaleW(0, pwsz1, -1, pwsz2, -1);
}
#endif

// Wrapper for lstrcmpiW so it works on Win95

LWSTDAPI_(int) StrCmpIW(LPCWSTR pwsz1, LPCWSTR pwsz2)
{
    return _StrCmpLocaleW(NORM_IGNORECASE, pwsz1, -1, pwsz2, -1);
}

#if 0
/*----------------------------------------------------------
Purpose: Trim the string pszTrimMe of any leading or trailing
         characters that are in pszTrimChars.

Returns: TRUE if anything was stripped

*/
STDAPI_(BOOL) StrTrimA(IN OUT LPSTR pszTrimMe, LPCSTR pszTrimChars)
{
    BOOL bRet = FALSE;
    LPSTR psz;
    LPSTR pszStartMeat;
    LPSTR pszMark = NULL;
    
    ASSERT(IS_VALID_STRING_PTRA(pszTrimMe, -1));
    ASSERT(IS_VALID_STRING_PTRA(pszTrimChars, -1));
    
    if (pszTrimMe)
    {
        /* Trim leading characters. */
        
        psz = pszTrimMe;
        
        while (*psz && StrChrA(pszTrimChars, *psz))
            psz = CharNextA(psz);
        
        pszStartMeat = psz;
        
        /* Trim trailing characters. */
        
        // (The old algorithm used to start from the end and go
        // backwards, but that is piggy because DBCS version of
        // CharPrev iterates from the beginning of the string
        // on every call.)
        
        while (*psz)
        {
            if (StrChrA(pszTrimChars, *psz))
            {
                if (!pszMark)
                {
                    pszMark = psz;
                }
            }
            else
            {
                pszMark = NULL;
            }
            psz = CharNextA(psz);
        }
        
        // Any trailing characters to clip?
        if (pszMark)
        {
            // Yes
            *pszMark = '\0';
            bRet = TRUE;
        }
        
        /* Relocate stripped string. */
        
        if (pszStartMeat > pszTrimMe)
        {
            /* (+ 1) for null terminator. */
            MoveMemory(pszTrimMe, pszStartMeat, CbFromCchA(lstrlenA(pszStartMeat) + 1));
            bRet = TRUE;
        }
        else
            ASSERT(pszStartMeat == pszTrimMe);
        
        ASSERT(IS_VALID_STRING_PTRA(pszTrimMe, -1));
    }
    
    return bRet;
}


/*----------------------------------------------------------
Purpose: Trim the string pszTrimMe of any leading or trailing
         characters that are in pszTrimChars.

Returns: TRUE if anything was stripped

*/
STDAPI_(BOOL) StrTrimW(IN OUT LPWSTR  pszTrimMe, LPCWSTR pszTrimChars)
{
    BOOL bRet = FALSE;
    LPWSTR psz;
    LPWSTR pszStartMeat;
    LPWSTR pszMark = NULL;
    
    ASSERT(IS_VALID_STRING_PTRW(pszTrimMe, -1));
    ASSERT(IS_VALID_STRING_PTRW(pszTrimChars, -1));
    
    if (pszTrimMe)
    {
        /* Trim leading characters. */
        
        psz = pszTrimMe;
        
        while (*psz && StrChrW(pszTrimChars, *psz))
            psz++;
        
        pszStartMeat = psz;
        
        /* Trim trailing characters. */
        
        // (The old algorithm used to start from the end and go
        // backwards, but that is piggy because DBCS version of
        // CharPrev iterates from the beginning of the string
        // on every call.)
        
        while (*psz)
        {
            if (StrChrW(pszTrimChars, *psz))
            {
                if (!pszMark)
                {
                    pszMark = psz;
                }
            }
            else
            {
                pszMark = NULL;
            }
            psz++;
        }
        
        // Any trailing characters to clip?
        if (pszMark)
        {
            // Yes
            *pszMark = '\0';
            bRet = TRUE;
        }
        
        /* Relocate stripped string. */
        
        if (pszStartMeat > pszTrimMe)
        {
            /* (+ 1) for null terminator. */
            MoveMemory(pszTrimMe, pszStartMeat, CbFromCchW(lstrlenW(pszStartMeat) + 1));
            bRet = TRUE;
        }
        else
            ASSERT(pszStartMeat == pszTrimMe);
        
        ASSERT(IS_VALID_STRING_PTRW(pszTrimMe, -1));
    }
    
    return bRet;
}


/*----------------------------------------------------------
Purpose: Compare strings using C runtime (ASCII) collation rules.

Returns: < 0 if pch1 <  pch2
         = 0 if pch1 == pch2
         > 0 if pch1 >  pch2
*/
LWSTDAPI_(int) StrCmpNCA(LPCSTR pch1, LPCSTR pch2, int n)
{
    if (n == 0)
        return 0;

    while (--n && *pch1 && *pch1 == *pch2)
    {
        pch1++;
        pch2++;
    }

    return *(unsigned char *)pch1 - *(unsigned char *)pch2;
}

/*----------------------------------------------------------
Purpose: Compare strings using C runtime (ASCII) collation rules.

Returns: < 0 if pch1 <  pch2
         = 0 if pch1 == pch2
         > 0 if pch1 >  pch2

*/
LWSTDAPI_(int) StrCmpNCW(LPCWSTR pch1, LPCWSTR pch2, int n)
{
    if (n == 0)
        return 0;

    while (--n && *pch1 && *pch1 == *pch2)
    {
        pch1++;
        pch2++;
    }

    return *pch1 - *pch2;
}

/*----------------------------------------------------------
Purpose: Compare strings using C runtime (ASCII) collation rules.

Returns: < 0 if pch1 <  pch2
         = 0 if pch1 == pch2
         > 0 if pch1 >  pch2

*/
LWSTDAPI_(int) StrCmpNICA(LPCSTR pch1, LPCSTR pch2, int n)
{
    int ch1, ch2;

    if (n != 0)
    {
        do {

            ch1 = *pch1++;
            if (ch1 >= 'A' && ch1 <= 'Z')
                ch1 += 'a' - 'A';

            ch2 = *pch2++;
            if (ch2 >= 'A' && ch2 <= 'Z')
                ch2 += 'a' - 'A';

        } while ( --n && ch1 && (ch1 == ch2) );

        return ch1 - ch2;
    }
    else
    {
        return 0;
    }
}

/*----------------------------------------------------------
Purpose: Compare strings using C runtime (ASCII) collation rules.

Returns: < 0 if pch1 <  pch2
         = 0 if pch1 == pch2
         > 0 if pch1 >  pch2

*/
LWSTDAPI_(int) StrCmpNICW(LPCWSTR pch1, LPCWSTR pch2, int n)
{
    int ch1, ch2;

    if (n != 0)
    {

        do {

            ch1 = *pch1++;
            if (ch1 >= L'A' && ch1 <= L'Z')
                ch1 += L'a' - L'A';

            ch2 = *pch2++;
            if (ch2 >= L'A' && ch2 <= L'Z')
                ch2 += L'a' - L'A';

        } while ( --n && ch1 && (ch1 == ch2) );

        return ch1 - ch2;
    }
    else
    {
        return 0;
    }
}

/*----------------------------------------------------------
Purpose: Compare strings using C runtime (ASCII) collation rules.

Returns: < 0 if pch1 <  pch2
         = 0 if pch1 == pch2
         > 0 if pch1 >  pch2

*/
LWSTDAPI_(int) StrCmpCA(LPCSTR pch1, LPCSTR pch2)
{
    while (*pch1 && (*pch1 == *pch2))
    {
        ++pch1;
        ++pch2;
    }   

    return *(unsigned char *)pch1 - *(unsigned char *)pch2;
}

/*----------------------------------------------------------
Purpose: Compare strings using C runtime (ASCII) collation rules.

Returns: < 0 if pch1 <  pch2
         = 0 if pch1 == pch2
         > 0 if pch1 >  pch2

*/
LWSTDAPI_(int) StrCmpCW(LPCWSTR pch1, LPCWSTR pch2)
{
    while (*pch1 && (*pch1 == *pch2))
    {
        ++pch1;
        ++pch2;
    }   

    return *pch1 - *pch2;
}

/*----------------------------------------------------------
Purpose: Compare strings using C runtime (ASCII) collation rules.

Returns: < 0 if pch1 <  pch2
         = 0 if pch1 == pch2
         > 0 if pch1 >  pch2

*/
LWSTDAPI_(int) StrCmpICA(LPCSTR pch1, LPCSTR pch2)
{
    int ch1, ch2;

    do {

        ch1 = *pch1++;
        if (ch1 >= 'A' && ch1 <= 'Z')
            ch1 += 'a' - 'A';

        ch2 = *pch2++;
        if (ch2 >= 'A' && ch2 <= 'Z')
            ch2 += 'a' - 'A';

    } while (ch1 && (ch1 == ch2));

    return ch1 - ch2;
}

/*----------------------------------------------------------
Purpose: Compare strings using C runtime (ASCII) collation rules.

Returns: < 0 if pch1 <  pch2
         = 0 if pch1 == pch2
         > 0 if pch1 >  pch2

*/
LWSTDAPI_(int) StrCmpICW(LPCWSTR pch1, LPCWSTR pch2)
{
    int ch1, ch2;

    do {

        ch1 = *pch1++;
        if (ch1 >= L'A' && ch1 <= L'Z')
            ch1 += L'a' - L'A';

        ch2 = *pch2++;
        if (ch2 >= L'A' && ch2 <= L'Z')
            ch2 += L'a' - L'A';

    } while (ch1 && (ch1 == ch2));

    return ch1 - ch2;
}

LWSTDAPI StrRetToStrW(STRRET *psr, LPCITEMIDLIST pidl, WCHAR **ppsz)
{
    HRESULT hres = S_OK;

    switch (psr->uType)
    {
    case STRRET_WSTR:
        *ppsz = psr->pOleStr;
        psr->pOleStr = NULL;   // avoid alias
        hres = *ppsz ? S_OK : E_FAIL;
        break;

    case STRRET_OFFSET:
        hres = SHStrDupA(STRRET_OFFPTR(pidl, psr), ppsz);
        break;

    case STRRET_CSTR:
        hres = SHStrDupA(psr->cStr, ppsz);
        break;

    default:
        *ppsz = NULL;
        hres = E_FAIL;
    }
    return hres;
}

HRESULT DupWideToAnsi(LPCWSTR pwsz, LPSTR *ppsz)
{
    UINT cch = WideCharToMultiByte(CP_ACP, 0, pwsz, -1, NULL, 0, NULL, NULL) + 1;
    *ppsz = CoTaskMemAlloc(cch * sizeof(**ppsz));
    if (*ppsz)
    {
        SHUnicodeToAnsi(pwsz, *ppsz, cch);
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

HRESULT DupAnsiToAnsi(LPCSTR psz, LPSTR *ppsz)
{
    *ppsz = (LPSTR)CoTaskMemAlloc((lstrlenA(psz) + 1) * sizeof(**ppsz));
    if (*ppsz) 
    {
        lstrcpyA(*ppsz, psz);
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

LWSTDAPI StrRetToStrA(STRRET *psr, LPCITEMIDLIST pidl, CHAR **ppsz)
{
    HRESULT hres;
    LPWSTR pwsz;

    switch (psr->uType)
    {
    case STRRET_WSTR:
        hres = DupWideToAnsi(psr->pOleStr, ppsz);
        pwsz = psr->pOleStr;
        psr->pOleStr = NULL;   // avoid alias
        CoTaskMemFree(pwsz);
        break;

    case STRRET_OFFSET:
        hres = DupAnsiToAnsi(STRRET_OFFPTR(pidl, psr), ppsz);
        break;

    case STRRET_CSTR:
        hres = DupAnsiToAnsi(psr->cStr, ppsz);
        break;

    default:
        *ppsz = NULL;
        hres = E_FAIL;
    }
    return hres;
}

STDAPI StrRetToBufA(STRRET *psr, LPCITEMIDLIST pidl, LPSTR pszBuf, UINT cchBuf)
{
    HRESULT hres = E_FAIL;

    switch (psr->uType)
    {
    case STRRET_WSTR:
        {
            LPWSTR pszStr = psr->pOleStr;   // temp copy because SHUnicodeToAnsi may overwrite buffer
            if (pszStr)
            {
                SHUnicodeToAnsi(pszStr, pszBuf, cchBuf);
                CoTaskMemFree(pszStr);
                psr->uType = STRRET_CSTR;   // Make sure no one thinks things are allocated still
                hres = S_OK;
            }
        }
        break;

    case STRRET_CSTR:
        SHAnsiToAnsi(psr->cStr, pszBuf, cchBuf);
        hres = S_OK;
        break;

    case STRRET_OFFSET:
        if (pidl)
        {
            // BUGBUG (DavePl) Alignment problems here
            SHAnsiToAnsi(STRRET_OFFPTR(pidl, psr), pszBuf, cchBuf);
            hres = S_OK;
        }
        break;
    }

    if (FAILED(hres) && cchBuf)
        *pszBuf = 0;

    return hres;
}

STDAPI StrRetToBufW(STRRET *psr, LPCITEMIDLIST pidl, LPWSTR pszBuf, UINT cchBuf)
{
    HRESULT hres = E_FAIL;
    
    switch (psr->uType)
    {
    case STRRET_WSTR:
        {
            LPWSTR pwszTmp = psr->pOleStr;
            if (pwszTmp)
            {
                StrCpyNW(pszBuf, pwszTmp, cchBuf);
                CoTaskMemFree(pwszTmp);
                psr->uType = STRRET_CSTR;   // Make sure no one thinks things are allocated still
                hres = S_OK;
            }
        }
        break;

    case STRRET_CSTR:
        SHAnsiToUnicode(psr->cStr, pszBuf, cchBuf);
        hres = S_OK;
        break;

    case STRRET_OFFSET:
        if (pidl)
        {
            // BUGBUG (DavePl) Alignment problems here

            SHAnsiToUnicode(STRRET_OFFPTR(pidl, psr), pszBuf, cchBuf);
            hres = S_OK;
        }
        break;
    }

    if (FAILED(hres) && cchBuf)
        *pszBuf = 0;

    return hres;
}

// dupe a string using the task allocator for returing from a COM interface
// These functions use SHAlloc, so they cannot go into shlwapi.

STDAPI SHStrDupA(LPCSTR psz, WCHAR **ppwsz)
{
    DWORD cch = MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
    *ppwsz = (WCHAR *)CoTaskMemAlloc((cch + 1) * SIZEOF(WCHAR));
    if (*ppwsz)
    {
        MultiByteToWideChar(CP_ACP, 0, psz, -1, *ppwsz, cch);
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

// dupe a string using the task allocator for returing from a COM interface
// Sometimes, due to structure packing, the pointer we get is not properly
// aligned for Win64, so we have to do UNALIGNED64.

STDAPI SHStrDupW(LPCWSTR psz, WCHAR **ppwsz)
{
    WCHAR *pwsz;
    pwsz = (WCHAR *)CoTaskMemAlloc((lstrlenW(psz) + 1) * SIZEOF(WCHAR));
    
    *((PVOID UNALIGNED64 *) ppwsz) = pwsz;

    if (pwsz)
    {
        StrCpyW(pwsz, psz);
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\win32dlg.h ===
// Win32Dlg.h: interface for the CWin32Dlg class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_WIN32DLG_H__A607404C_E2DA_11D2_8D5B_00A0C9063310__INCLUDED_)
#define AFX_WIN32DLG_H__A607404C_E2DA_11D2_8D5B_00A0C9063310__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "dlg.h"
#include "XMLDlg.h"

/*
 *	This is the notification code
 */
#define NM_BALLOON	0x7abc

class CDlg;


//
// 
//
BOOL CALLBACK DlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
// RCMLControlNode * GetXMLControl(HWND hWnd);
CDlg * GetXMLPropertyPage(HWND hWnd);

extern ATOM	g_atomXMLPropertyPage;

class CWin32Dlg : public CDlg  
{
public:
	typedef CDlg BASECLASS;
	CWin32Dlg(HINSTANCE hInst, HWND hWnd, DLGPROC dlgProc, LPARAM dwInitParam, CXMLDlg * pDialog ); // CXMLResourceStaff * pStaff);
	CWin32Dlg();
	virtual ~CWin32Dlg();

	virtual BOOL CALLBACK DlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
	virtual int DoCommand(WORD wCmdID,WORD hHow);	// return 0 if you handled this.
	virtual void OnInit();
	void OnInit(HWND hDlg);
	virtual int DoNotify(NMHDR * pHdr);
	void DoBalloonNotify(NMHDR * pHdr);
	virtual void Destroy();

	BOOL CreateDlgTemplateA(LPCSTR pszFile, DLGTEMPLATE** pDt);
	BOOL CreateDlgTemplateW(LPCTSTR pszFile, DLGTEMPLATE** pDt);
	BOOL CreateDlgTemplate(int dlgID, DLGTEMPLATE** pDt);
	void	SetLParam(LPARAM lp) { m_dwInitParam=lp; }

    //
    //
    //
    static void ShowBalloonTip(HWND hControl, LPCTSTR pszText);
    static HWND  g_hwndBalloon;
    static HHOOK g_hBalloonHook;
    static HWND  g_hBalloonOwner;		// the window that is associated with the balloon

private:
	BOOL m_bDeleteStaff;

protected:
	LRESULT DoControlColor(IRCMLControl * pControl, HDC hDC, HWND hWndChild, UINT uMessage, WPARAM wParam, LPARAM lParam);
	CXMLDlg	*	m_pxmlDlg;
	CXMLDlg *	GetXMLDlg() { return m_pxmlDlg; }
	DLGPROC		m_dlgProc; 
	LPARAM		m_dwInitParam;
	void		InitPrivate();
    WORD        m_wLastCmd;
};

#ifdef __WIN32DLG_CPP
HWND  CWin32Dlg::g_hwndBalloon;
HHOOK CWin32Dlg::g_hBalloonHook;
HWND  CWin32Dlg::g_hBalloonOwner;		// the window that is associated with the balloon
#endif

#endif // !defined(AFX_WIN32DLG_H__A607404C_E2DA_11D2_8D5B_00A0C9063310__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\win32dlg.cpp ===
// Win32Dlg.cpp: implementation of the CWin32Dlg class.
//
//	LATER: Consider adding a OnDelayedInit() a few seconds after OnInit 
//	to initialize the tooltips and other stuff (maybe the resize manager?)
//
// Deals with the Win32 side of message handling. Code that is renderer
// specific and can't really live in the nodes themselves, e.g.
// how to display a tooltip, when to initialize the RCMLNodes etc.
//
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#define __WIN32DLG_CPP

#include "Win32Dlg.h"

#include "uiparser.h"

#include "stringproperty.h"
#include "rcmlloader.h"
#include "utils.h"
#include "renderDlg.h"

ATOM	g_atomXMLControl;
ATOM	g_atomXMLPropertyPage;

/*
 * LATER consider packing these in a structure or class
 */

//////////////////////////////////////////////////////////////////////
// Some helper functions
//////////////////////////////////////////////////////////////////////

// Atoms are added and removed for each CWin32Dialog - could be issues if more than 64K dialogs
void InitAtom()
{
	if ( g_atomXMLControl == 0 ) 
	{
		g_atomXMLControl = GlobalAddAtom(TEXT("XMLControlPointer"));
		if ( g_atomXMLControl == 0 )
		{
			TRACE(TEXT("Trouble creating atomXMLContro"));
		}

		g_atomXMLPropertyPage = GlobalAddAtom(TEXT("XMLPropertyPage"));
		if ( g_atomXMLPropertyPage == 0 )
		{
			TRACE(TEXT("Trouble creating g_atomXMLPropertyPage"));
		}
	}
    else
    {
        GlobalAddAtom(MAKEINTATOM( g_atomXMLControl ));
        GlobalAddAtom(MAKEINTATOM( g_atomXMLPropertyPage ));
    }

}

void DeleteAtom()
{
	GlobalDeleteAtom(g_atomXMLControl);
	GlobalDeleteAtom(g_atomXMLPropertyPage);
}

//
// Returns an IRCMLControl because it'a a visual node.
//
IRCMLControl * GetXMLControl(HWND hWnd)
{
	IRCMLControl * pxmlControl = (IRCMLControl*)GetProp(hWnd, (LPCTSTR)g_atomXMLControl);
	if(pxmlControl==NULL)
		return NULL;	// items with duplicate ID's - ARGH!
	ASSERT(pxmlControl);
	ASSERT(g_atomXMLControl);

	return pxmlControl; // hash table
}

//
// This should probably validate. FA 01/18/00
//
CDlg * GetXMLPropertyPage(HWND hWnd)
{
	CDlg* pxmlPage = (CDlg* )GetProp(hWnd, (LPCTSTR)g_atomXMLPropertyPage);
	if(pxmlPage==NULL)
		return NULL;	// items with duplicate ID's - ARGH!
	ASSERT(pxmlPage);
	ASSERT(g_atomXMLControl);

	return pxmlPage;
}

/*
 *	This hook will monitor the WM_KILLFOCUS message sent to the
 * window that has the balloon associated, to have it hidden
 */
LRESULT CALLBACK FocusChangedHook(
  int nCode,     // hook code
  WPARAM wParam, // current-process flag
  LPARAM lParam  // address of structure with message data
)
{
	CWPRETSTRUCT* pCW = (CWPRETSTRUCT*)lParam;
    LRESULT	lResult = CallNextHookEx(CWin32Dlg::g_hBalloonHook, nCode, wParam, lParam);

    ASSERT(CWin32Dlg::g_hBalloonHook);
	if(nCode == HC_ACTION)
	{
		/*
		 * If the balloon owner is losing focus, clean up all balloon related stuff
		 * That rely on the fact that balloons are pretty rare and thus is not making
		 * sense to reuse the window or hook.
		 */
		if(pCW->message==WM_KILLFOCUS && pCW->hwnd==CWin32Dlg::g_hBalloonOwner)
		{
            UnhookWindowsHookEx(CWin32Dlg::g_hBalloonHook);
			DestroyWindow(CWin32Dlg::g_hwndBalloon);
			CWin32Dlg::g_hwndBalloon = NULL;
			CWin32Dlg::g_hBalloonHook = NULL;
			CWin32Dlg::g_hBalloonOwner = NULL;
		}
	}
	return lResult;
}
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CWin32Dlg::CWin32Dlg(HINSTANCE hInst, HWND hWnd, DLGPROC dlgProc, LPARAM dwInitParam, CXMLDlg * pDialog ) // CXMLResourceStaff * pStaff)
: CDlg(0, hWnd, hInst),
  m_pxmlDlg(pDialog),
  m_dlgProc(dlgProc),
  m_dwInitParam(dwInitParam)
{
	InitPrivate();
}

CWin32Dlg::CWin32Dlg()
 : BASECLASS(0,0,0), m_dlgProc(NULL), m_pxmlDlg(NULL)
{
	InitPrivate();
}

void CWin32Dlg::InitPrivate()
{
	InitAtom();
	m_bDeleteStaff=FALSE;
}

CWin32Dlg::~CWin32Dlg()
{
	if( m_pxmlDlg && m_bDeleteStaff )
	{
		delete m_pxmlDlg;
		m_pxmlDlg = NULL;
	}

    DeleteAtom();
}

///////////////////////////////////////////////////////////////////////////////
//
// Overrides CDlg::DlgProc to deal with win32 specifics
//
//	LATER: Consider removing the first parameter.  it's actually m_hDlg 
//  inherited from CDlg
// 
BOOL CALLBACK CWin32Dlg::DlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
	CXMLDlg * pxmlDlg = GetXMLDlg();
	LRESULT bOurRet=FALSE;

	switch (uMessage)
	{
		case WM_INITDIALOG:
			m_pxmlDlg=(CXMLDlg*)GetXMLControl(hDlg);
			break;

		case WM_CTLCOLORMSGBOX               :
		case WM_CTLCOLOREDIT                 :
		case WM_CTLCOLORLISTBOX              :
		case WM_CTLCOLORBTN                  :
		case WM_CTLCOLORDLG                  :
		case WM_CTLCOLORSCROLLBAR            :
		case WM_CTLCOLORSTATIC               :
			{
				IRCMLControl * pxmlControl = GetXMLControl((HWND)lParam);
                bOurRet = DoControlColor( pxmlControl, (HDC)wParam, (HWND)lParam, uMessage, wParam, lParam);
			}
			break;

		case WM_PARENTNOTIFY:   // doesn't seem to work. DS_SETFONT
			if (LOWORD(wParam) == WM_DESTROY) 
			{
				HWND hWnd = (HWND)lParam;
				IRCMLControl * pxmlControl = GetXMLControl(hWnd);
				if(pxmlControl)
				{
					pxmlControl->OnDestroy(hWnd, m_wLastCmd);
					RemoveProp(hWnd, (LPCTSTR)g_atomXMLControl);
				}				
			}
			//
			//	LATER: will need to add the dinamic child creation case
			// But that is after the XMLControl tree will be a able to deal with this
			//
			break;

		case WM_CONTEXTMENU:
			{
				HWND hWnd = (HWND)wParam;
				IRCMLControl * pControl = GetXMLControl(hWnd);
				ASSERT(pControl);

				/*
				 * Will do that later
				 */
			}
			break;

		case WM_SETFONT:
			break;

		case WM_MOVE:
		case WM_SIZE:
			/*
			 * We're moving/sizing, the balloon, if visible, should move as well.
			 */
			if(g_hwndBalloon)
			{
				RECT rc;
				GetWindowRect(g_hBalloonOwner, &rc);

				DWORD dwPackedCoords = (DWORD) MAKELONG(rc.left + (rc.right - rc.left) / 2, rc.bottom);
				SendMessage(g_hwndBalloon , TTM_TRACKPOSITION, 0, (LPARAM) dwPackedCoords);
			}
			break;

		case WM_NOTIFY:
				DoNotify((NMHDR FAR *)lParam);
			break;
	}

	if(pxmlDlg )
		bOurRet = pxmlDlg->DlgProc(hDlg,uMessage, wParam, lParam );

	BOOL bTheirRet=FALSE;
	if( m_dlgProc )
	{
		if(uMessage==WM_INITDIALOG)
			lParam = m_dwInitParam;	// need to give them their init param
		bTheirRet= m_dlgProc(hDlg, uMessage, wParam, lParam );
	}

	//
	// Now work out what to return, ours or theirs? Make it look like them?
	//
	return bTheirRet || bOurRet;
}

int CWin32Dlg::DoNotify(NMHDR * pHdr)
{
	switch (pHdr->code)
    {
	case NM_BALLOON:
		DoBalloonNotify(pHdr);
		break;
	default:
		break;
	}
	return FALSE;
}

void CWin32Dlg::DoBalloonNotify(NMHDR * pHdr)
{
	HWND hControl = pHdr->hwndFrom;
	IRCMLControl *pControl = GetXMLControl(hControl);

    IRCMLHelp *pHelp;
    if( SUCCEEDED( pControl->get_Help( &pHelp )))
    {
        LPWSTR pszBalloonText;
        if( SUCCEEDED( pHelp->get_BalloonText( &pszBalloonText )))
        {
            SetFocus(hControl);
            ShowBalloonTip( hControl, pszBalloonText);
        }
        pHelp->Release();
    }
}

void CWin32Dlg::ShowBalloonTip(HWND hControl, LPCTSTR pszText)
{
	TOOLINFO ti;
	ti.cbSize = sizeof(TOOLINFO); 
	ti.uFlags = TTF_IDISHWND | TTF_TRACK; 
	ti.hwnd = hControl;
	ti.uId = (UINT) hControl; 
	ti.hinst = 0; 
	ti.lpszText = (LPTSTR)pszText; 
	ti.lParam = 0;

	if (g_hBalloonOwner)
	{
		/*
		 * If the balloon is already visible, but for another control, move it
		 */
		if(g_hBalloonOwner==hControl)
			return;
		ASSERT(g_hwndBalloon);
		// shall I deltool g_hBalloonOwner? SendMessage(g_hwndBalloon , TTM_DELTOOL, 0, (LPARAM) (LPTOOLINFO) &ti);
	}
	else 
	{
		/*
		 * No balloon window visible, create is needed and show it
		 */
		if (!g_hwndBalloon)
		{
			g_hwndBalloon = CreateWindowEx(0, TOOLTIPS_CLASS, (LPTSTR) NULL, 
							WS_POPUP | TTS_NOPREFIX | 0x40, //TTS_BALLOON, 
							CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, 
							NULL, (HMENU) NULL, NULL, NULL); 
			if (g_hwndBalloon == NULL) 
			{
				TRACE(TEXT("Can't create balloon window"));
				return;
			}
			/*
			 * BUGBUG need to come up with a decent width computation
			 */
			SendMessage(g_hwndBalloon , TTM_SETMAXTIPWIDTH, 0, (LPARAM)200);

			g_hBalloonHook = SetWindowsHookEx(
					WH_CALLWNDPROCRET, 
					FocusChangedHook,
					NULL, 
					GetCurrentThreadId());
			if(g_hBalloonHook == NULL)
			{
				TRACE(TEXT("Can't create balloon hook"));
				DestroyWindow(g_hwndBalloon);
				return;
			}
		}
	}

	SetWindowPos(g_hwndBalloon , HWND_TOPMOST, 0,0,0,0,
				SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
	SendMessage(g_hwndBalloon , TTM_ADDTOOL, 0, (LPARAM) (LPTOOLINFO) &ti);
	
	RECT rc;
	GetWindowRect(hControl, &rc);

	DWORD dwPackedCoords = (DWORD) MAKELONG(rc.left + (rc.right - rc.left) / 2, rc.bottom);
	SendMessage(g_hwndBalloon , TTM_TRACKPOSITION, 0, (LPARAM) dwPackedCoords);
	SendMessage(g_hwndBalloon , TTM_TRACKACTIVATE, (WPARAM)TRUE,(LPARAM)&ti);
	g_hBalloonOwner=hControl;
}

//
// WM_COMMAND processing.
// we pass this WM_COMMAND to the Exit method of the extensions.
//
int CWin32Dlg::DoCommand(WORD wCmdID,WORD hHow)
{
	if( m_dlgProc == NULL )
		return BASECLASS::DoCommand(wCmdID, hHow);
    if( hHow < 2 )
        m_wLastCmd = wCmdID;
	return 1;
}

void CWin32Dlg::OnInit(HWND hDlg)
{
	m_hDlg = hDlg;
	OnInit();
}

//
// Associates a window property g_atomXMLControl for each window to point to
// the XML node. This assumes that the order we create the nodes is the
// order they appear in User.
// Also initializes the nodes themselves.
//
void CWin32Dlg::OnInit()
{
	if(m_pxmlDlg!=NULL)
	{
		IRCMLControlList & controls= m_pxmlDlg->GetChildren();
		int iCount=controls.GetCount();

		SetProp(GetWindow(), (LPCTSTR)g_atomXMLControl, (HANDLE)m_pxmlDlg);

        HWND hFirstChild=::GetWindow(GetWindow(), GW_CHILD);
        int iXMLControl=0;
        while( hFirstChild )
        {
		    IRCMLControl * pControl = controls.GetPointer(iXMLControl++);

	        if( !SetProp(hFirstChild, (LPCTSTR)g_atomXMLControl, (HANDLE)pControl) )
	        {
		        TRACE(TEXT("Set FAILED !!! 0x%08x tp 0x%08x\n"), hFirstChild, pControl );
	        }
            else
	            pControl->OnInit(hFirstChild);
            hFirstChild=::GetWindow( hFirstChild, GW_HWNDNEXT );
        }
		m_pxmlDlg->OnInit( m_hDlg );
	}
}

//
// Walk all the windows, removing properties and notifying the nodes.
//
void CWin32Dlg::Destroy()
{
	CXMLDlg * pxmlDlg = GetXMLDlg();
    if(pxmlDlg==NULL)
        return;
    HWND    hDlg=GetWindow();
    if( hDlg==NULL)
        return;
    SetWindow(NULL);        // pevents baseclass destructor calling destroy on us.

	if(g_hwndBalloon)
	{
		DestroyWindow(g_hwndBalloon);
		g_hBalloonOwner=g_hwndBalloon=NULL;
	}

    // Child cleanup
    // WM_PARENTNOTIFY doesn't seem to work here
    //
    HWND hFirstChild=::GetWindow(hDlg, GW_CHILD);
    while( hFirstChild )
    {   
		IRCMLControl * pxmlControl = GetXMLControl(hFirstChild);
        if( pxmlControl )
        {
            pxmlControl->OnDestroy( hFirstChild, m_wLastCmd ); // tells the XML it's over
            RemoveProp( hFirstChild, (LPCTSTR)g_atomXMLControl);
        }
        hFirstChild=::GetWindow( hFirstChild, GW_HWNDNEXT );
    }

    //
    // Cleanup the dialog last.
    //
	if(pxmlDlg )
	{
		pxmlDlg->OnDestroy(hDlg, m_wLastCmd);   // tells the XML node it's over.
		RemoveProp(hDlg, (LPCTSTR)g_atomXMLControl);
    }

  	BASECLASS::Destroy();
}

//
//
//
BOOL CWin32Dlg::CreateDlgTemplateA(LPCSTR pszFile, DLGTEMPLATE** pDt)
{
#if UNICODE
	BOOL bRetVal;
    if( HIWORD(pszFile) )
    {
	    LPWSTR pUnicodeFileName = UnicodeStringFromAnsi(pszFile);
	    bRetVal = CreateDlgTemplateW(pUnicodeFileName, pDt);
	    delete pUnicodeFileName;
	    return bRetVal;
    }
    else
    {
	    return CreateDlgTemplateW((LPCTSTR)pszFile, pDt);
    }
#else
	return CreateDlgTemplateW(pszFile, pDt);
#endif
}

BOOL CWin32Dlg::CreateDlgTemplateW(LPCTSTR pszFile, DLGTEMPLATE** pDt)
{
	BOOL bRetVal = FALSE;
	CUIParser parser;

	m_bDeleteStaff=TRUE;
	HRESULT hr;
    BOOL bExternal;
	if( SUCCEEDED( hr=parser.Load(pszFile, NULL, &bExternal ) ) )  // Load Logs error results.
	{
		m_pxmlDlg = parser.GetDialog(0);

		if(m_pxmlDlg)
		{
            m_pxmlDlg->SetExternalFileWarning(bExternal);
			CRenderXMLDialog renderDialog(NULL, NULL, NULL);
			renderDialog.CreateDlgTemplate(m_pxmlDlg, pDt);			
			parser.SetAutoDelete(FALSE);
			bRetVal = TRUE;
		}
		else
		{
            EVENTLOG( EVENTLOG_ERROR_TYPE, LOGCAT_RUNTIME , 1,
                TEXT("CreatedDlgTemplate"), TEXT("Failed to find the dialog requested %s"), pszFile );
		}
	}
	return bRetVal;
}

BOOL CWin32Dlg::CreateDlgTemplate(int dlgID, DLGTEMPLATE** pDt) 
{ 
	TRACE(TEXT("CreateDlgTemplate(int dlgID) not implemented"));
	return FALSE;
}


/////////////////////////////////////////////////////////////////////////
//
// Flat API implementation
//
RCML_HANDLE * WINAPI RCMLCreateDialogHandle(void)
{
    RCML_HANDLE * h=new RCML_HANDLE;
    h->cbSize=sizeof(RCML_HANDLE);
    h->rcmlData=new CUIParser();
    h->rcmlDialog=NULL;
	return h;
}

void WINAPI RCMLDestroyDialog(RCML_HANDLE * h)
{
    if(h->cbSize!=sizeof(RCML_HANDLE))
        return;
    if( h->rcmlData )
	    delete (CUIParser*)h->rcmlData;
    h->cbSize=NULL;
    h->rcmlData=NULL;
    h->rcmlDialog=NULL;     // dialog is cleaned up when the rcmlData is destroyed.
    delete h;
}

void WINAPI RCMLOnInit(RCML_HANDLE * h, HWND hDlg)
{
    if(h->cbSize!=sizeof(RCML_HANDLE))
        return;
    if( h->rcmlDialog )
	    ((CWin32Dlg*)h->rcmlDialog)->OnInit(hDlg);

}

BOOL CALLBACK  WINAPI RCMLCallDlgProc(RCML_HANDLE * h, HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    if(h->cbSize!=sizeof(RCML_HANDLE))
        return FALSE;
    if( h->rcmlDialog)
	    return ((CWin32Dlg*)h->rcmlDialog)->DlgProc(hDlg, uMessage, wParam, lParam);
    return FALSE;
}

BOOL WINAPI RCMLCreateDlgTemplateA(RCML_HANDLE * h, HINSTANCE hinst, LPCSTR pszFile, DLGTEMPLATE** pDt)
{
    if(h->cbSize!=sizeof(RCML_HANDLE))
        return FALSE;

    //
    // Could be a dlgID or a filename.
    //
    LPWSTR pUnicodeString = (LPWSTR)pszFile;
    if( HIWORD( pszFile ) )
    	pUnicodeString = UnicodeStringFromAnsi(pszFile);
	BOOL retVal = RCMLCreateDlgTemplateW(h, hinst, pUnicodeString, pDt);
    if( HIWORD( pUnicodeString ) )
	    delete pUnicodeString;

    return retVal;
}

BOOL WINAPI RCMLCreateDlgTemplateW(RCML_HANDLE * h, HINSTANCE hinst, LPCWSTR pszFile, DLGTEMPLATE** pDt)
{
    if( h->rcmlData == NULL )
        h->rcmlData=new CUIParser();

    CUIParser * parser=(CUIParser*)h->rcmlData;

    if(parser)
    {
	    HRESULT hr;
        BOOL bExternal;
	    if( SUCCEEDED( hr=parser->Load(pszFile, hinst, &bExternal ) ) )
	    {
            if( HIWORD( pszFile ))
            {
                EVENTLOG( EVENTLOG_INFORMATION_TYPE, LOGCAT_LOADER, 1,
                    TEXT("RCMLDialogBoxTableW"), TEXT("Loaded the supplied file '%s'."), pszFile );
            }
            else
            {
                EVENTLOG( EVENTLOG_INFORMATION_TYPE, LOGCAT_LOADER, 1,
                    TEXT("RCMLDialogBoxTableW"), TEXT("Loaded the supplied resource. HINST=0x%08x, ID=0x%04x (%d)."), hinst, pszFile, pszFile );
            }

		    CXMLDlg * pQs=parser->GetDialog(0);
            h->rcmlDialog = pQs;
		    if(pQs)
		    {
                pQs->SetExternalFileWarning(bExternal);
			    CRenderXMLDialog  render(hinst, NULL , NULL, NULL );
                render.CreateDlgTemplate( pQs, pDt );
                return TRUE;
            }
		    else
		    {
                EVENTLOG( EVENTLOG_ERROR_TYPE, LOGCAT_LOADER, 1,
                    TEXT("RCMLDialogBoxTableW"), TEXT("File didn't contain the Dialog/FORM requested") );
		    }
	    }
	    else
	    {   
		    if(hr==E_FAIL)
		    {
                if( HIWORD( pszFile ))
                {
                    EVENTLOG( EVENTLOG_ERROR_TYPE, LOGCAT_LOADER, 1,
                        TEXT("RCMLDialogBoxTableW"), TEXT("Cannot open the supplied file '%s'."), pszFile );
                }
                else
                {
                    EVENTLOG( EVENTLOG_ERROR_TYPE, LOGCAT_LOADER, 1,
                        TEXT("RCMLDialogBoxTableW"), TEXT("Cannot open the supplied resource. HINST=0x%08x, ID=0x%04x (%d)."), hinst, pszFile, pszFile );
                }
		    }
		    else
		    {
                if( (hr >= XML_E_PARSEERRORBASE) || (hr <=XML_E_LASTERROR) )
                {
                    EVENTLOG( EVENTLOG_ERROR_TYPE, LOGCAT_LOADER, 1,
                        TEXT("RCMLDialogBoxTableW"), TEXT("There is an error in your RCML file = 0x%08x. Please open the file using Internet Explorer to find the errors."), hr );
                }
                else
                {
                    EVENTLOG( EVENTLOG_ERROR_TYPE, LOGCAT_LOADER, 1,
                        TEXT("RCMLDialogBoxTableW"), TEXT("Your system is not able to support the requirements of this application. Please regsrv32 msxml.dll found in this folder (at your own risk), or upgrade your version of IE5") );
                }
		    }
	    }
	    return FALSE;
    }
    return FALSE;
}

HWND WINAPI RCMLCreateDialogParamTableA( HINSTANCE hinst, LPCSTR pszFile, HWND parent, DLGPROC dlgProc, LPARAM dwInitParam, LPCSTR * pszEntities)
{
    HWND retVal;

#ifndef UNICODE
	retVal = RCMLCreateDialogBoxTableW(hinst, pszFile, parent, dlgProc, dwInitParam, pszEntities);
#else
    int iEntityCount=0;

    if( pszEntities )
    {
        while( pszEntities[iEntityCount] )
            iEntityCount++;
    }
    LPCWSTR * pszEntitiesW=NULL;
    if( iEntityCount )
    {
        pszEntitiesW=new LPCWSTR[iEntityCount];
        for(int i=0;i<iEntityCount;i++)
            pszEntitiesW[i]=UnicodeStringFromAnsi(pszEntities[i]);
    }

    //
    // Could be a dlgID or a filename.
    //
    LPWSTR pUnicodeString = (LPWSTR)pszFile;
    if( HIWORD( pszFile ) )
    	pUnicodeString = UnicodeStringFromAnsi(pszFile);

	retVal = RCMLCreateDialogParamTableW(hinst, pUnicodeString, parent, dlgProc, dwInitParam, pszEntitiesW);

    if( HIWORD( pUnicodeString ) )
	    delete pUnicodeString;

    if( iEntityCount )
    {
        for(int i=0;i<iEntityCount;i++)
            delete (LPWSTR)pszEntitiesW[i];
        delete pszEntitiesW;
    }
#endif
    return retVal;
}

HWND WINAPI RCMLCreateDialogParamTableW( HINSTANCE hinst, LPCTSTR pszFile, HWND parent, DLGPROC dlgProc, LPARAM dwInitParam, LPCTSTR * pszEntities)
{
	CUIParser * pParser= new CUIParser();
    pParser->SetEntities( pszEntities );

	HRESULT hr;
    BOOL bExternal;
	if( SUCCEEDED( hr=pParser->Load(pszFile, hinst, &bExternal ) ) )
	{
		CXMLDlg * pQs=pParser->GetDialog(0);
		if(pQs)
		{
            pQs->SetExternalFileWarning(bExternal);
			CRenderXMLDialog * pR = new CRenderXMLDialog( hinst, parent, dlgProc, dwInitParam );
            return pR->CreateDlg( pQs );
        }
		else
		{
            EVENTLOG( EVENTLOG_ERROR_TYPE, LOGCAT_RUNTIME , 1,
                TEXT("CreatedDlgParam"), TEXT("Failed to find the dialog requested %s"), pszFile );
		}
    }
    return NULL;
}

BOOL WINAPI RCMLChooseFontW(LPCHOOSEFONTW cfw) // ChooseFont
{
#if 0
	CUIParser * pParser= new CUIParser();
    pParser->SetEntities( NULL );

	HRESULT hr;
    BOOL bExternal;
	if( SUCCEEDED( hr=pParser->Load(pszFile, hinst, &bExternal ) ) )
	{
		CXMLDlg * pQs=pParser->GetDialog(0);
		if(pQs)
		{
            // pQs->SetExternalFileWarning(bExternal);
			CRenderXMLDialog renderDialog(NULL, NULL, NULL);
			renderDialog.CreateDlgTemplate(pQs, &lpTemplateName);			
			parser.SetAutoDelete(FALSE);
            return pR->CreateDlg( pQs );
        }
		else
		{
            EVENTLOG( EVENTLOG_ERROR_TYPE, LOGCAT_RUNTIME , 1,
                TEXT("CreatedDlgParam"), TEXT("Failed to find the dialog requested %s"), pszFile );
		}
    }
#endif
    return NULL;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
//
// Deals with setting the colors on the controls themselves.
// this is a complicated windows message, with a combination of asking defWindowProc
// and setting information on the hDC as well as the return result.
//
//////////////////////////////////////////////////////////////////////////////////////////////////
LRESULT CWin32Dlg::DoControlColor(IRCMLControl *pControl, HDC hDC, HWND hWndChild, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
	if(pControl==NULL)
        return 0;

	IRCMLCSS * pxmlStyle;
	if( SUCCEEDED( pControl->get_CSS(&pxmlStyle )))
	{
		//
		// This looks odd because if you just set the text color
		// you still need to return a brush that it can use.
		//
		HBRUSH	currentBrush = NULL;
        HPEN hPen;
		if( SUCCEEDED( pxmlStyle->get_Pen( (DWORD*) &hPen) ) )
		{
			// must call them first.
			currentBrush = (HBRUSH)DefWindowProc( hWndChild, uMessage, wParam, lParam );
            COLORREF textColor;
            pxmlStyle->get_Color(&textColor);
			SetTextColor(hDC, textColor);
		}

        HBRUSH hBrush;
		if( SUCCEEDED( pxmlStyle->get_Brush(&hBrush) ) )
		{
            COLORREF bkColor;
            pxmlStyle->get_BkColor( &bkColor);
			SetBkColor(hDC, bkColor);
            pxmlStyle->Release();
			return (LRESULT)hBrush;
		}

        pxmlStyle->Release();
		return (LRESULT)currentBrush;
	}
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\win32sheet.cpp ===
// Win32Sheet.cpp: implementation of the CWin32Sheet class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Win32Sheet.h"
#include "uiparser.h"
#include "utils.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CWin32Sheet::CWin32Sheet()
{

}

CWin32Sheet::~CWin32Sheet()
{

}

////////////////////////////////////////////////////////////////////////////////
//
// Called for page creation and deletion.
// the lParam is a pointer to our page object.
//
////////////////////////////////////////////////////////////////////////////////
UINT CALLBACK PropSheetPageProcA(
    HWND hwnd,
    UINT uMsg,
    LPPROPSHEETPAGEA ppsp
)
{
	CWin32DlgPage * pClassPage=(CWin32DlgPage*)ppsp->lParam;
	LPCPROPSHEETPAGEA pTheirPage = pClassPage->GetSheetPageA();

	switch( uMsg )
	{
	// case PSPCB_ADDREF: //  Version 5.0. A page is being created. The return value is not used.  
	//	break;

	case PSPCB_CREATE: //  A dialog box for a page is being created. Return nonzero to allow it to be created, or zero to prevent it.  
		if(pTheirPage->dwFlags & PSP_USECALLBACK)
			return pTheirPage->pfnCallback( hwnd, uMsg, (LPPROPSHEETPAGEA)pTheirPage );
		return 1;
		break;

	case PSPCB_RELEASE: //  A page is being destroyed. The return value is ignored.  
		if(pTheirPage->dwFlags & PSP_USECALLBACK)
			return pTheirPage->pfnCallback( hwnd, uMsg, (LPPROPSHEETPAGEA)pTheirPage );
		//
		//
		//
		TRACE(TEXT("Cleaning up our stuff\n"));
		delete pClassPage;				// the wrapper
		ppsp->lParam=NULL;
		delete (LPBYTE)ppsp->pResource;			// the dialog template.
		return 1;
		break;
	}
	return 0;
}

UINT CALLBACK PropSheetPageProcW(
    HWND hwnd,
    UINT uMsg,
    LPPROPSHEETPAGEW ppsp
)
{
	CWin32DlgPage * pClassPage=(CWin32DlgPage*)ppsp->lParam;
	LPCPROPSHEETPAGEW pTheirPage = pClassPage->GetSheetPageW();

    TRACE(TEXT("Page Callback 0x%08x lparam =0x%08x theirs 0x%08x\n"), pClassPage, ppsp, pTheirPage );

	switch( uMsg )
	{
	// case PSPCB_ADDREF: //  Version 5.0. A page is being created. The return value is not used.  
	//	break;

	case PSPCB_CREATE: //  A dialog box for a page is being created. Return nonzero to allow it to be created, or zero to prevent it.  
		if(pTheirPage->dwFlags & PSP_USECALLBACK)
			return pTheirPage->pfnCallback( hwnd, uMsg, (LPPROPSHEETPAGEW)pTheirPage );
		return 1;
		break;

	case PSPCB_RELEASE: //  A page is being destroyed. The return value is ignored.  
		if(pTheirPage->dwFlags & PSP_USECALLBACK)
			return pTheirPage->pfnCallback( hwnd, uMsg, (LPPROPSHEETPAGEW)pTheirPage );
		//
		//
		//
		TRACE(TEXT("Cleaning up our stuff\n"));
		delete pClassPage;				// the wrapper
		ppsp->lParam=NULL;
		delete (LPBYTE)ppsp->pResource;			// the dialog template.
		return 1;
		break;
	}
	return 0;
}

////////////////////////////////////////////////////////////////////////////////////
//
// PropertySheet 
//
// We walk the array of structures, and convert them into an array of
// handles.
//
////////////////////////////////////////////////////////////////////////////////////
int WINAPI RCMLPropertySheetA(LPCPROPSHEETHEADERA lppsph)
{
	//
	// If we are passed HPROPSHEETPAGE array, then we assume they used RCMLCreatePropSheetPage
	// otherwise, remove their DLGProc, add Ours, take their LPARAM and put ours in.
	//

	if(lppsph->dwFlags & PSH_PROPSHEETPAGE)
	{
		// Structures.
		// the cbSize is the size of the structure, we just fix up the dlgProc and lParam
		//

		//
		// This is our copy of their Header - we change it to and array of pages.
		//
		LPPROPSHEETHEADERA  pSheet=(LPPROPSHEETHEADERA)new BYTE[lppsph->dwSize];
		CopyMemory( pSheet, lppsph, lppsph->dwSize );
		pSheet->dwFlags &=~PSH_PROPSHEETPAGE;	// this is now handles.
		pSheet->phpage = new HPROPSHEETPAGE[pSheet->nPages];

		DWORD iPages=0;
		LPCPROPSHEETPAGEA pPage;	// this is the page we are currently working on.
		pPage=lppsph->ppsp;

		for(iPages=0;iPages< lppsph->nPages;iPages++)
		{
			//
			// Returns an HPROPSHEETPAGE for all kinds of pages (indirect etc).
			//
			pSheet->phpage[iPages]=RCMLCreatePropertySheetPageA( pPage );
			pPage = (PROPSHEETPAGEA*)(((LPBYTE)pPage) + pPage->dwSize);
		}
		int iRet = PropertySheetA( pSheet );

		//
		// Our handle cleanup should have already been take care of
		//
		delete [] pSheet->phpage;
		delete [] pSheet;
	}
	else
	{
		//
		// Array of HPROPSHEETPAGEs
		// we assume these were created using RCML
		//
		return PropertySheetA( lppsph );
	}
	return 0;
}

int WINAPI RCMLPropertySheetW(LPCPROPSHEETHEADERW lppsph)
{
	//
	// If we are passed HPROPSHEETPAGE array, then we assume they used RCMLCreatePropSheetPage
	// otherwise, remove their DLGProc, add Ours, take their LPARAM and put ours in.
	//

	if(lppsph->dwFlags & PSH_PROPSHEETPAGE)
	{
		// Structures.
		// the cbSize is the size of the structure, we just fix up the dlgProc and lParam
		//

		//
		// This is our copy of their Header - we change it to and array of pages.
		//
		LPPROPSHEETHEADERW  pSheet=(LPPROPSHEETHEADERW)new BYTE[lppsph->dwSize];
		CopyMemory( pSheet, lppsph, lppsph->dwSize );
		pSheet->dwFlags &=~PSH_PROPSHEETPAGE;	// this is now handles.
		pSheet->phpage = new HPROPSHEETPAGE[pSheet->nPages];

		DWORD iPages=0;
		LPCPROPSHEETPAGEW pPage;	// this is the page we are currently working on.
		pPage=lppsph->ppsp;

		for(iPages=0;iPages< lppsph->nPages;iPages++)
		{
			//
			// Returns an HPROPSHEETPAGE for all kinds of pages (indirect etc).
			//
			pSheet->phpage[iPages]=RCMLCreatePropertySheetPageW( pPage );
			pPage = (PROPSHEETPAGEW*)(((LPBYTE)pPage) + pPage->dwSize);
		}
		int iRet = PropertySheetW( pSheet );

		//
		// Our handle cleanup should have already been take care of
		//
		delete [] pSheet->phpage;
		delete [] pSheet;
	}
	else
	{
		//
		// Array of HPROPSHEETPAGEs
		// we assume these were created using RCML
		//
		return PropertySheetW( lppsph );
	}
	return 0;
}


////////////////////////////////////////////////////////////////////////////////////
//
// CreatePropertySheetPage
//
////////////////////////////////////////////////////////////////////////////////////

HPROPSHEETPAGE WINAPI RCMLCreatePropertySheetPageA( LPCPROPSHEETPAGEA lppsp )
{

#if 0
	HPROPSHEETPAGE retVal;
	PROPSHEETPAGEW ppsW;

	CopyMemory(&ppsW, lppsp, lppsp->dwSize);

	ppsW.pszTemplate = UnicodeStringFromAnsi(lppsp->pszTemplate);

#if (_WIN32_IE >= 0x0500)
	/*
	 * Check for the extra LPCTSTR fields at the end of the structure (_WIN32_IE>0x0500).
	 */
	BOOL bExtra = ((PBYTE)lppsp + lppsp->dwSize) > (PBYTE)(&lppsp->pszHeaderSubTitle);

	if(bExtra)
	{
		ppsW.pszHeaderTitle = UnicodeStringFromAnsi(lppsp->pszHeaderTitle);
		ppsW.pszHeaderSubTitle = UnicodeStringFromAnsi(lppsp->pszHeaderSubTitle);
	}
#endif
	retVal = RCMLCreatePropertySheetPageW(&ppsW);
#if (_WIN32_IE >= 0x0500)
	if(bExtra)
	{
		delete ppsW.pszHeaderTitle;
		delete ppsW.pszHeaderSubTitle;
	}
#endif
	return retVal;
#endif


	if( lppsp->dwFlags & PSP_DLGINDIRECT )
	{
		return CreatePropertySheetPageA(lppsp);
	}

	//
	// Remember their callback, dlgProc and lParam
	//

	PROPSHEETPAGEA Page;
	CopyMemory(&Page, lppsp, lppsp->dwSize);

	//
	// Get the RCML dlg template.
	//
	CWin32DlgPage * pDlgProc=NULL;
	pDlgProc=new CWin32DlgPage(lppsp);
	if( pDlgProc->CreateDlgTemplateA( lppsp->pszTemplate, (DLGTEMPLATE * *)&Page.pResource) )
		Page.dwFlags |= PSP_DLGINDIRECT;

	Page.lParam			 = (LPARAM)pDlgProc;	// the original page information?
	Page.dwFlags		|= PSP_USECALLBACK;		// we need a callback.
	Page.pfnCallback	 = PropSheetPageProcA;

	Page.pfnDlgProc=pDlgProc->PageBaseDlgProc;	// use our dlg proc.

	return CreatePropertySheetPageA(&Page);

}


HPROPSHEETPAGE WINAPI RCMLCreatePropertySheetPageW( LPCPROPSHEETPAGEW lppsp )
{
	if( lppsp->dwFlags & PSP_DLGINDIRECT )
	{
		return CreatePropertySheetPageW(lppsp);
	}

	//
	// Remember their callback, dlgProc and lParam
	//

	PROPSHEETPAGEW Page;
    if( lppsp->dwSize != sizeof(Page) )
    {
        TRACE(TEXT("Crappo!"));
    }
	CopyMemory(&Page, lppsp, lppsp->dwSize);

	//
	// Get the RCML dlg template.
	//
	CWin32DlgPage * pDlgProc=NULL;
	pDlgProc=new CWin32DlgPage(lppsp);

	if( pDlgProc->CreateDlgTemplateW( (LPTSTR)lppsp->pszTemplate, (DLGTEMPLATE * *)&Page.pResource) )
		Page.dwFlags |= PSP_DLGINDIRECT;

	Page.lParam			 = (LPARAM)pDlgProc;	// the original page information?
	Page.dwFlags		|= PSP_USECALLBACK;		// we need a callback.
	Page.pfnCallback	 = PropSheetPageProcW;

	Page.pfnDlgProc=pDlgProc->PageBaseDlgProc;	// use our dlg proc.

	return CreatePropertySheetPageW(&Page);
}


BOOL CWin32DlgPage::DlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
	//
	// Not sure if we really need to do any more processing here? 
	//
	return BASECLASS::DlgProc( hDlg, uMessage, wParam, lParam);
}


BOOL CALLBACK CWin32DlgPage::PageBaseDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
	// CWin32DlgPage * pSV = (CWin32DlgPage*)GetWindowLong(hDlg,DWL_USER);
	CWin32DlgPage * pSV = (CWin32DlgPage*)GetXMLPropertyPage(hDlg);

	switch (uMessage)
	{
		case WM_INITDIALOG:
		{
			LPPROPSHEETPAGEA psp=(LPPROPSHEETPAGEA)lParam;
			pSV=(CWin32DlgPage*)psp->lParam;
			pSV->SetWindow(hDlg);
			// SetWindowLong(hDlg,DWL_USER,(LPARAM)pSV);
        	SetProp(hDlg, (LPCTSTR)g_atomXMLPropertyPage, (HANDLE)pSV);
			pSV->OnInit();
		}
		break;

		// Override the Do Command to get a nice wrapped up feeling.
		case WM_COMMAND:
			if(pSV)
				if( pSV->DoCommand(LOWORD(wParam),HIWORD(wParam)) == 0 )
					return 0;
		break;

		case WM_NOTIFY:
			if(pSV)
				return pSV->DoNotify((NMHDR FAR *)lParam);
		break;

		case WM_DESTROY:
			if(pSV)
				pSV->Destroy();
		break;
	}

    
	if(pSV)
		return pSV->DlgProc(hDlg,uMessage,wParam,lParam);
	else
		return FALSE;
}

CWin32DlgPage::CWin32DlgPage(LPCPROPSHEETPAGEA pPageA):
	m_pPropSheetPageA(NULL), m_pPropSheetPageW(NULL), 
	BASECLASS(pPageA->hInstance, NULL, pPageA->pfnDlgProc, (LPARAM)pPageA, NULL)
{
    m_pPropSheetPageA=(LPPROPSHEETPAGEA)new BYTE[pPageA->dwSize];
    CopyMemory( (LPBYTE)m_pPropSheetPageA, pPageA, pPageA->dwSize);
	SetLParam((LPARAM)m_pPropSheetPageA);
};

CWin32DlgPage::CWin32DlgPage(LPCPROPSHEETPAGEW pPageW):
	m_pPropSheetPageW(NULL), m_pPropSheetPageA(NULL),
	BASECLASS(pPageW->hInstance, NULL, pPageW->pfnDlgProc, (LPARAM)pPageW, NULL)
{
    m_pPropSheetPageW=(LPPROPSHEETPAGEW)new BYTE[pPageW->dwSize];
    CopyMemory( (LPBYTE)m_pPropSheetPageW, pPageW, pPageW->dwSize);
	SetLParam((LPARAM)m_pPropSheetPageW);
};

CWin32DlgPage::~CWin32DlgPage()
{
    delete m_pPropSheetPageA; 
    delete m_pPropSheetPageW; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlbutton.h ===
// XMLButton.h: interface for the CXMLButton class.
//
// All the buttons go in here.
// Button
// CheckBox
// RadioButton
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XMLBUTTON_H__4F2EEA4F_0161_456B_A995_523E4678D60C__INCLUDED_)
#define AFX_XMLBUTTON_H__4F2EEA4F_0161_456B_A995_523E4678D60C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "XMLControl.h"

#undef PROPERTY
#define PROPERTY( type, id ) type Get##id() { Init(); return m_##id; }

/////////////////////////////////////////////////////////////////////////////////
//
// Contains the shared style bits for all buttons
//
/////////////////////////////////////////////////////////////////////////////////
class CXMLButtonStyle : public CXMLControlStyle
{
public:
    CXMLButtonStyle();
	virtual ~CXMLButtonStyle() {};
	typedef CXMLControlStyle BASECLASS;
	XML_CREATE( ButtonStyle );
    UINT    GetBaseStyles() { Init(); return buttonStyle; }
    void    Init();

    PROPERTY(BOOL, MultiLine);

protected:

//  BS_PUSHBUTTON       0x00000000L     // BUTTON
//  BS_DEFPUSHBUTTON    0x00000001L     // WIN32:BUTTON\@DEFPUSH
//  BS_CHECKBOX         0x00000002L     // CHECKBOX\
//  BS_AUTOCHECKBOX     0x00000003L     // CHECKBOX\WIN32:BUTTON\@AUTO
//  BS_RADIOBUTTON      0x00000004L     // RADIOBUTTON
//  BS_3STATE           0x00000005L     // CHECKBOX\@TRISTATE
//  BS_AUTO3STATE       0x00000006L     // CHECKBOX\WIN32:BUTTON\@AUTO CHECKBOX\@TRISTATE
//  BS_GROUPBOX         0x00000007L     // GROUPBOX
//  BS_USERBUTTON       0x00000008L     //
//  BS_AUTORADIOBUTTON  0x00000009L     // RADIOBUTTON\WIN32:BUTTON\@AUTO
//  BS_OWNERDRAW        0x0000000BL     // WIN32:BUTTON\@OWNERDRAW
//  BS_LEFTTEXT         0x00000020L     // WIN32:BUTTON\@LEFTTEXT
//  BS_TEXT             0x00000000L     // 
//  BS_ICON             0x00000040L     // WIN32:BUTTON\@ICON
//  BS_BITMAP           0x00000080L     // WIN32:BUTTON\@BITMAP
//  BS_LEFT             0x00000100L     // BUTTON\STYLE\@TEXT-ALIGN
//  BS_RIGHT            0x00000200L     // BUTTON\STYLE\@TEXT-ALIGN
//  BS_CENTER           0x00000300L     // BUTTON\STYLE\@TEXT-ALIGN
//  BS_TOP              0x00000400L     // BUTTON\STYLE\@TEXT-ALIGN
//  BS_BOTTOM           0x00000800L     // BUTTON\STYLE\@VERTICAL-ALIGN
//  BS_VCENTER          0x00000C00L     // BUTTON\STYLE\@VERTICAL-ALIGN
//  BS_PUSHLIKE         0x00001000L     // WIN32:BUTTON\@PUSHLIKE
//  BS_MULTILINE        0x00002000L     // WIN32:BUTTON\@MULTILINE
//  BS_NOTIFY           0x00004000L     // WIN32:BUTTON\@NOTIFY
//  BS_FLAT             0x00008000L     // WIN32:BUTTON\@FLAT
//  BS_RIGHTBUTTON      BS_LEFTTEXT

    union
    {
        UINT    buttonStyle;
        struct {
            UINT    m_enum:5;
            BOOL    m_LeftText:1;   // 0x0020
            BOOL    m_Icon:1;    
            BOOL    m_Bitmap:1;
            BOOL    m_alignment:4;
            BOOL    m_Pushlike:1;   // 0x1000
            BOOL    m_MultiLine:1;
            BOOL    m_Notify:1;  
            BOOL    m_Flat:1;       // 0x800    
        };
    };
};

//
// Specialized controls
//
class CXMLButton : public _XMLControl<IRCMLControl>
{
public:
	CXMLButton();
	virtual ~CXMLButton() {delete m_pControlStyle; }
	typedef _XMLControl<IRCMLControl> BASECLASS;
	XML_CREATE( Button );
    IMPLEMENTS_RCMLCONTROL_UNKNOWN;

    BOOL GetMultiLine() { if(m_pControlStyle) return m_pControlStyle->GetMultiLine(); return FALSE; }

    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptChild( 
        IRCMLNode __RPC_FAR *child);

    static SIZE CheckClippedConstraint(IRCMLControl * pControl, int padWidth, int padHeight, int DLUMultiLine, BOOL bMultiLine);

protected:
	void Init();
	void CheckClipped();
    CXMLButtonStyle * m_pControlStyle;
    void CheckClippedConstraint(int padWidth, int padHeight, int DLUMultiLine);
};

class CXMLCheckBox : public CXMLButton
{
public:
	CXMLCheckBox();
	virtual ~CXMLCheckBox() {};
	typedef CXMLButton BASECLASS;
	XML_CREATE( CheckBox );

protected:
	void Init();
	void CheckClipped();
};


class CXMLRadioButton : public CXMLButton
{
public:
	CXMLRadioButton();
	virtual ~CXMLRadioButton() {};
	typedef CXMLButton BASECLASS;
	XML_CREATE( RadioButton );

protected:
	void Init();
	void CheckClipped();
};

// This is also a BUTTON.
class CXMLGroupBox : public CXMLButton
{
public:
	CXMLGroupBox();
	virtual ~CXMLGroupBox() {};
	typedef CXMLButton BASECLASS;
	XML_CREATE( GroupBox );

protected:
	void Init();
    void CheckClipped() {}; // can we do anything with group-boxes??
};

#endif // !defined(AFX_XMLBUTTON_H__4F2EEA4F_0161_456B_A995_523E4678D60C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlcaption.h ===
// XMLCaption.h: interface for the CXMLCaption class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XMLCAPTION_H__2E264B68_2B14_4709_B343_C8314FF493C2__INCLUDED_)
#define AFX_XMLCAPTION_H__2E264B68_2B14_4709_B343_C8314FF493C2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "xmlnode.h"

class CXMLCaption : public _XMLNode<IRCMLNode>
{
public:
	CXMLCaption();
	virtual ~CXMLCaption();

	typedef _XMLNode<IRCMLNode> BASECLASS;
	XML_CREATE( Caption );
    IMPLEMENTS_RCMLNODE_UNKNOWN;

	PROPERTY(BOOL, MaximizeButton );
	PROPERTY(BOOL, MinimizeButton );
	PROPERTY(BOOL, CloseButton );

	LPWSTR	GetText() { Init(); return m_Text; }
	LPWSTR	GetIconID() { Init(); return m_IconID; }
	void	SetText(LPWSTR	pszText) { Init(); m_Text = pszText; }
    DWORD   GetStyle(); // min/max/close style bits from caption child.

private:
	void    Init();
    LPWSTR m_Text;
    LPWSTR m_IconID;

    struct
    {
        BOOL    m_MaximizeButton:1;
        BOOL    m_MinimizeButton:1;
        BOOL    m_CloseButton:1;
    };
};

#endif // !defined(AFX_XMLCAPTION_H__2E264B68_2B14_4709_B343_C8314FF493C2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\win32sheet.h ===
// Win32Sheet.h: interface for the CWin32Sheet class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_WIN32SHEET_H__D7019560_1911_11D3_8BF4_00C04FB177B1__INCLUDED_)
#define AFX_WIN32SHEET_H__D7019560_1911_11D3_8BF4_00C04FB177B1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "rcml.h"
#include "win32dlg.h"

//
// More of a struct than a class.
//
class CWin32Sheet 
{
public:
	// CWin32Sheet(LPPROPSHEETPAGEA pPage);
	// CWin32Sheet(LPPROPSHEETPAGEW pPage);
	CWin32Sheet();
	virtual ~CWin32Sheet();
protected:
	LPARAM	m_lParam;
	DLGPROC	m_dlgProc;
	LPFNPSPCALLBACK m_pfnCallback;
};

//
// This handles the dialogProc for the pages, and calls off to the old dlg proc.
// it's the INIT stuff whic is different from CWin32Dlg, we need to pass them
// back their LPARAM in the PROPSHEETPAGE struct rather than just in the LPARAM.
// We could copy and repackage the struct - as it's passed in as const.
// We make a copy of their INIT data, and replace it with ours, this happens in the
// CreatePropertySheetPage.
//
class CWin32DlgPage : public CWin32Dlg
{
public:
	typedef CWin32Dlg BASECLASS ;
	// CWin32Dlg(HINSTANCE hInst, HWND hWnd, DLGPROC dlgProc, LPARAM dwInitParam, CXMLResourceStaff * pStaff);

	CWin32DlgPage(LPCPROPSHEETPAGEA pPageA);// Felix asks MCostea - what's the right way of doing this?
	CWin32DlgPage(LPCPROPSHEETPAGEW pPageW);

	virtual BOOL CALLBACK DlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
	static CALLBACK PageBaseDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);

    virtual ~CWin32DlgPage();

	LPCPROPSHEETPAGEA	GetSheetPageA() { return m_pPropSheetPageA; }
	LPCPROPSHEETPAGEW	GetSheetPageW() { return m_pPropSheetPageW; }
protected:
	LPPROPSHEETPAGEA	m_pPropSheetPageA;	// their complete information.
	LPPROPSHEETPAGEW	m_pPropSheetPageW;	// their complete information.
};

#endif // !defined(AFX_WIN32SHEET_H__D7019560_1911_11D3_8BF4_00C04FB177B1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlcaption.cpp ===
// XMLCaption.cpp: implementation of the CXMLCaption class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "XMLCaption.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CXMLCaption::CXMLCaption()
{
  	NODETYPE = NT_CAPTION;
    m_StringType=L"CAPTION";
}

CXMLCaption::~CXMLCaption()
{

}

void CXMLCaption::Init()
{
   	if(m_bInit)
		return;

    BASECLASS::Init();

    m_Text=(LPWSTR)Get(TEXT("TEXT"));
    if( m_Text==NULL )
        m_Text=TEXT("");
    m_MinimizeButton = YesNo( TEXT("MINIMIZEBOX"),FALSE ); // WS_MINIMIZEBOX
    m_MaximizeButton = YesNo( TEXT("MAXIMIZEBOX"),FALSE ); // WS_MAXIMIZEBOX
    m_CloseButton = YesNo( TEXT("CLOSE"),FALSE );       // WS_SYSMENU

    //
    // This is sneaky, if it's a string, you get a string, if it's a number
    // you get a number.
    //
    DWORD dwValue;
    get_Attr( L"ICONID", &m_IconID );
    if( SUCCEEDED( ValueOf( L"ICONDID", 0, &dwValue )))
        m_IconID = (LPWSTR)dwValue;

    m_bInit=TRUE;
}

#undef PROPERTY
#define PROPERTY(p,id, def) m_Style |= YesNo( id , def )?p:0;

DWORD CXMLCaption::GetStyle()
{
    //
    // Caption child?
    //
    DWORD m_Style=0;
    PROPERTY( WS_MINIMIZEBOX     , TEXT("MINIMIZEBOX") ,       FALSE );
    PROPERTY( WS_MAXIMIZEBOX     , TEXT("MAXIMIZEBOX") ,       FALSE );
    PROPERTY( WS_SYSMENU         , TEXT("CLOSE") ,       TRUE );    // where does this come from?
    return m_Style;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlbutton.cpp ===
// XMLButton.cpp: implementation of the CXMLButton class.
//
// All the buttons go in here.
// Button
// CheckBox
// RadioButton
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "XMLButton.h"
#include "utils.h"
#include "debug.h"
#include "XMLdlg.h"

#define CS(p,id, member, def) member = YesNo( id , def );

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CXMLButtonStyle::CXMLButtonStyle()
{
	m_bInit=FALSE;
	NODETYPE = NT_BUTTONSTYLE;
    m_StringType=L"WIN32:BUTTON";
}

void CXMLButtonStyle::Init()
{
    if(m_bInit)
        return;
    BASECLASS::Init();

    buttonStyle=0;
    CS( BS_LEFTTEXT,    TEXT("LEFTTEXT"),   m_LeftText, FALSE );    // only for check / radio
    CS( BS_FLAT,        TEXT("FLAT"),       m_Flat,     FALSE );
    CS( BS_NOTIFY,      TEXT("NOTIFY"),     m_Notify,   FALSE );
    CS( BS_MULTILINE,   TEXT("MULTILINE"),  m_MultiLine,FALSE );
    CS( BS_ICON,        TEXT("ICON"),       m_Icon,     FALSE );
    CS( BS_BITMAP,      TEXT("BITMAP"),     m_Bitmap,   FALSE );
    CS( BS_PUSHLIKE,    TEXT("PUSHLIKE"),   m_Pushlike, FALSE );

    m_bInit=TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////// B U T T O N ///////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
CXMLButton::CXMLButton()
{
	m_bInit=FALSE;
	NODETYPE = NT_BUTTON;
    m_StringType= L"BUTTON";
    m_pControlStyle=FALSE;
}

//
// Called by ALL button derivitives.
//
void CXMLButton::Init()
{
	if(m_bInit)
		return;
    BASECLASS::Init();

    //
    // All BUTTON types
    //
	m_Class=m_Class?m_Class:(LPWSTR)0x0080; // TEXT("BUTTON");

    if( m_pControlStyle )
        m_Style |= m_pControlStyle->GetBaseStyles();
    else
        m_Style |= 0;       // BUTTONS don't have any defaults set to yes.

    IRCMLCSS * pCSS;
    if( SUCCEEDED( get_CSS( & pCSS ) ))
    {
        LPWSTR res;
        // http://msdn.microsoft.com/workshop/author/dhtml/reference/properties/textAlign.asp#textAlign

        if( SUCCEEDED( pCSS->get_Attr(L"TEXT-ALIGN", &res) ) )
        {
            if( lstrcmpi(res,TEXT("LEFT"))==0 )
            {
                m_Style |=BS_LEFT;
            }
            else if( lstrcmpi(res,TEXT("RIGHT"))==0 )
            {
                m_Style |=BS_RIGHT;
            }
            else if( lstrcmpi(res,TEXT("CENTER"))==0 )
            {
                m_Style |=BS_CENTER;
            }
        }

        // http://msdn.microsoft.com/workshop/author/dhtml/reference/properties/verticalAlign.asp#verticalAlign
        if( SUCCEEDED( pCSS->get_Attr(L"VERTICAL-ALIGN", &res) ) )
        {
            if( lstrcmpi(res,TEXT("TOP"))==0 )
            {
                m_Style |=BS_TOP;
            }
            else if( lstrcmpi(res,TEXT("MIDDLE"))==0 )
            {
                m_Style |=BS_VCENTER;
            }
            else if( lstrcmpi(res,TEXT("BOTTOM"))==0 )
            {
                m_Style |=BS_BOTTOM;
            }
        }
        pCSS->Release();
    }

    //
    // Specific to BUTTON ONLY!
    //
    if( SUCCEEDED( IsType(L"BUTTON")))
    {
	    if( m_Height == 0 )
		    m_Height=14;

	    if( m_Width == 0 )
		    m_Width =50;


        m_Style |= YesNo(TEXT("DEFPUSH"), 0, 0, BS_DEFPUSHBUTTON);

	    m_bInit=TRUE;
    }

}

HRESULT CXMLButton::AcceptChild(IRCMLNode * pChild )
{
    ACCEPTCHILD( L"WIN32:BUTTON", CXMLButtonStyle, m_pControlStyle);
    return BASECLASS::AcceptChild(pChild);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// Calculate the required size for the control.
// this gets a little complicated.
// The text is bounded by some space and then the 'border' for the control
// this is the padding for the control.
//
void CXMLButton::CheckClipped()
{
    CheckClippedConstraint( 20, 8, 14 );
}

void CXMLButton::CheckClippedConstraint( int padWidth, int padHeight, int DLUMultiLine )
{
    m_Clipped = CheckClippedConstraint( this, padWidth, padHeight, DLUMultiLine , GetMultiLine() );
}

//
// padding on the sides, top, and how many DLU's before we're considered multiline.
//
SIZE CXMLButton::CheckClippedConstraint(
    IRCMLControl * pControl, int padWidth, int padHeight, int DLUMultiLine, BOOL bMultiLine )
{
    SIZE clippedSize={0};

    LPWSTR pszText;
    if( FAILED( pControl->get_Attr(L"TEXT", &pszText )))
        return clippedSize;

    IRCMLContainer * pContainer;

    if( FAILED ( pControl->get_Container( &pContainer )))
        return clippedSize;


    //
    // We need our font to be able to work out our required size.
    //
    IRCMLCSS * pStyle ;
    if( FAILED( pControl->get_CSS( &pStyle )))
        return clippedSize;

	//
	// req (Required) size are what we think we need from GDI.
	// cur (Current) sizes are what we find in the RCML file.
	// clipped values are in PIXELS.
	//


    //
    // Find out how big we are in pixels.
    //
    RECT rcmlPixel;
    if( FAILED( pContainer->GetPixelLocation( pControl, &rcmlPixel )))
    {
        pStyle->Release();
        return clippedSize;
    }

    TRACE(TEXT("Checking clipped text on a BUTTON '%s'\n"), pszText );

// REVIEW - implementation specific
	CQuickFont * pfont=((CXMLStyle*)pStyle)->GetQuickFont();    

    // Find out size in DLU - we know DLUs and use them to work out
    // multi-line nature of our controls.
    //
    // Our calculations are in Pixels.
    //
	SIZE curPixelSize;
    curPixelSize.cx = (rcmlPixel.right- rcmlPixel.left );
    curPixelSize.cy = (rcmlPixel.bottom - rcmlPixel.top );

    SIZE curDluSize = pfont->GetDlgUnitsFromPixels( curPixelSize );

    if( curDluSize.cy > DLUMultiLine )
        bMultiLine=TRUE;

	SIZE reqPixelSize	= pfont->HowLong( pszText );
    reqPixelSize.cx += padWidth;  // this is for the frame of the button.
    reqPixelSize.cy += padHeight;  // this is for the frame of the button.


    //
    // We don't care if we're bigger than necessary.
    //
    if( ( reqPixelSize.cx <= curPixelSize.cx ) &&
        ( reqPixelSize.cy <= curPixelSize.cy ) )
    {
        pStyle->Release();
        return clippedSize;
    }


	//
	// see if this is a single line control - find the height using the layout font.
	//
	if( bMultiLine==FALSE )
	{
		if( reqPixelSize.cx > curPixelSize.cx )		// Dont shrink the controls?
		{ 
			clippedSize.cx=reqPixelSize.cx - curPixelSize.cx;
			clippedSize.cy=reqPixelSize.cy - curPixelSize.cy;

			EVENTLOG( EVENTLOG_WARNING_TYPE, LOGCAT_CLIPPING, 0, 
                TEXT("BUTTON"), TEXT("SINGLE line clipped Text: Text=\"%s\". Clipped by (%d,%d)"), 
    			pszText, clippedSize.cx, clippedSize.cy );
		}
	}
	else
	{
		//
		// We suspect this to be a multi line control.
        // we'll just make the control taller to fit then.
		//
		reqPixelSize = pfont->HowHigh( pszText, curPixelSize.cx - padWidth );
        reqPixelSize.cx += padWidth;  // this is for the frame of the button.
        reqPixelSize.cy += padHeight;  // this is for the frame of the button.

		clippedSize.cx=reqPixelSize.cx - curPixelSize.cx;
        if( clippedSize.cx < 0 )
            clippedSize.cx = 0;
		clippedSize.cy=reqPixelSize.cy - curPixelSize.cy;

		EVENTLOG( EVENTLOG_WARNING_TYPE, LOGCAT_CLIPPING, 0,
            TEXT("BUTTON"), TEXT("Multi line clipped Text: Text=\"%s\". Clipped by (%d,%d)"), 
			pszText, clippedSize.cx, clippedSize.cy );
	}

    pStyle->Release();
    return clippedSize;
}

/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////// R A D I O B U T T O N ///////////////////
/////////////////////////////////////////////////////////////////////////////////
CXMLRadioButton::CXMLRadioButton()
{
	NODETYPE = NT_RADIO;
    m_StringType=L"RADIOBUTTON";
}

void CXMLRadioButton::Init()
{
	if(m_bInit)
		return;
    BASECLASS::Init();

    //
    // Specific to RADIOBUTTON
    //
	if( m_Height == 0 )
		m_Height=10;

	if( m_Width == 0 )
		m_Width =50;

    m_Style |= YesNo( TEXT("AUTO"), BS_AUTORADIOBUTTON, BS_RADIOBUTTON, BS_AUTORADIOBUTTON );

	m_bInit=TRUE;
}

//
// Question - can we check to see if the font will fit now?
// single line check first.
//
void CXMLRadioButton::CheckClipped()
{
    CheckClippedConstraint( 10, 0, 14 );
}

/////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////// C H E C K B O X ///////////////////////////
/////////////////////////////////////////////////////////////////////////////////
CXMLCheckBox::CXMLCheckBox()
{
	NODETYPE = NT_CHECKBOX;
    m_StringType=L"CHECKBOX";
}

void CXMLCheckBox::Init()
{
	if(m_bInit)
		return;
    BASECLASS::Init();

    //
    // Specific to CHECKBOX
    //
	if( m_Height == 0 )
		m_Height=10;    // checkbutton default height is 10 not 14!

	if( m_Width == 0 )
		m_Width =50;

	//
	// They may be specifying all the style bits in the STYLE.
	//
    BOOL bAuto = YesNo(TEXT("AUTO"),TRUE);
    BOOL bTriState = YesNo(TEXT("TRISTATE"),FALSE);
    if( bTriState )
        m_Style |= bAuto ? BS_AUTO3STATE : BS_3STATE;
    else
        m_Style |= bAuto ? BS_AUTOCHECKBOX: BS_CHECKBOX;

	m_bInit=TRUE;
}

//
// Question - can we check to see if the font will fit now?
// single line check first.
//
void CXMLCheckBox::CheckClipped()
{
    CheckClippedConstraint( 18, 0, 14 );    // us MSPAINT to find out how much enforced space is needed
}


/////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////// G R O U P B O X ///////////////////////////
/////////////////////////////////////////////////////////////////////////////////
CXMLGroupBox::CXMLGroupBox()
{
    NODETYPE = NT_GROUPBOX;
    m_StringType=L"GROUPBOX";
}

void CXMLGroupBox::Init()
{
	if(m_bInit)
		return;
    BASECLASS::Init();

    //
    // Specific to GROUPBOX
    //
	if( m_Height == 0 )
		m_Height=14;

	if( m_Width == 0 )
		m_Width =50;

	m_Style |= BS_GROUPBOX;

	m_bInit=TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlcombo.cpp ===
// XMLCombo.cpp: implementation of the CXMLCombo class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "XMLCombo.h"
#include "enumcontrols.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

#define CONTROLSTYLE(p,id, member, def) member = YesNo( id , def );

CXMLComboStyle::CXMLComboStyle()
{
	m_bInit=FALSE;
	NODETYPE = NT_COMBOSTYLE;
    m_StringType=L"WIN32:COMBO";
}

void CXMLComboStyle::Init()
{
    if(m_bInit)
        return;
    BASECLASS::Init();

    comboStyle=0;

    // cut/ paste from generator.
    CONTROLSTYLE( CBS_OWNERDRAWFIXED, TEXT("OWNERDRAWFIXED"),       m_OwnerDrawFixed, FALSE );
    CONTROLSTYLE( CBS_OWNERDRAWVARIABLE, TEXT("OWNERDRAWVARIABLE"), m_OwnerDrawVariable, FALSE );
    CONTROLSTYLE( CBS_OEMCONVERT, TEXT("OEMCONVERT"), m_OemConvert, FALSE );
    CONTROLSTYLE( CBS_HASSTRINGS, TEXT("HASSTRINGS"), m_HasStrings, FALSE );
    CONTROLSTYLE( CBS_NOINTEGRALHEIGHT, TEXT("NOINTEGRALHEIGHT"), m_NoIntegralHeight, FALSE );
    CONTROLSTYLE( CBS_DISABLENOSCROLL, TEXT("DISABLENOSCROLL"), m_DisableNoScroll, FALSE );

    m_bInit=TRUE;
}


/////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
CXMLCombo::CXMLCombo()
{
	m_bInit=FALSE;
	NODETYPE = NT_COMBO;
    m_StringType=L"COMBO";
    m_pTextItem=NULL;
    m_pControlStyle=NULL;
}

void CXMLCombo::Init()
{
	if(m_bInit)
		return;
	BASECLASS::Init();

	if( m_Height == 0 )
		m_Height=8;

    if( m_Width == 0 )
    {
        // Bug is that if he adds a button it works fine.
        // m_Width=50;     
        // HMM, should we really default here, or throw an exception??
    }

//
// ComboBox
//
// CBS_SIMPLE            0x0001L     A  // SIZE!="1" READONLY (doesn't matter)
// CBS_DROPDOWN          0x0002L     A  // SIZE="1" READONLY="NO
// CBS_DROPDOWNLIST      0x0003L     A  // SIZE="1" READONLY="YES"
// CBS_OWNERDRAWFIXED    0x0010L     C  // WIN32:COMBOBOX\@OWNERDRAWFIXED
// CBS_OWNERDRAWVARIABLE 0x0020L     C  // WIN32:COMBOBOX\@OWNERDRAWVARIABLE
// CBS_AUTOHSCROLL       0x0040L     S  // STYLE\overflow-y="auto"
// CBS_OEMCONVERT        0x0080L     C  // WIN32:COMBOBOX\OEMCONVERT
// CBS_SORT              0x0100L     A  // SORT="YES"
// CBS_HASSTRINGS        0x0200L     C  // WIN32:COMBOBOX\HASSTRINGS
// CBS_NOINTEGRALHEIGHT  0x0400L     C  // WIN32:COMBOBOX\NOINTEGRALHEIGHT
// CBS_DISABLENOSCROLL   0x0800L     C  // WIN32:COMBOBOX\DISALBENOSCROLL
// CBS_UPPERCASE           0x2000L   S  // STYLE\@text-transform=uppercase
// CBS_LOWERCASE           0x4000L   S  // STYLE\@text-transform=lowercase
//
// http://msdn.microsoft.com/workshop/author/dhtml/reference/objects/SELECT.asp
//

	m_Class=m_Class?m_Class:(LPWSTR)0x0085; // TEXT("COMBOBOX");

    if( m_pControlStyle )
        m_Style |= m_pControlStyle->GetBaseStyles();
    else
        m_Style |= 0; // COMBO's don't have any defaults.

    IRCMLCSS *	pCSS;
    if( SUCCEEDED( get_CSS( &pCSS )))
    {
        LPWSTR res;

        // http://msdn.microsoft.com/workshop/author/dhtml/reference/properties/textAlign.asp#textAlign
        if( SUCCEEDED( pCSS->get_Attr( L"TEXT-TRANSFORM", & res ) ) )
        {
            if( lstrcmpi(res,TEXT("Uppercase"))==0 )
            {
                m_Style |=CBS_UPPERCASE;
            }
            else if( lstrcmpi(res,TEXT("Lowercase"))==0 )
            {
                m_Style |=CBS_LOWERCASE;
            }
        }

        // turn autohscroll OFF with OVERFLOW-X="VISIBLE"
        m_Style |=CBS_AUTOHSCROLL;
        if( SUCCEEDED( pCSS->get_Attr( L"OVERFLOW-X", & res ) ) )
        {
            if( lstrcmpi(res,TEXT("VISIBLE"))==0 )
                m_Style &=~CBS_AUTOHSCROLL;
        }
        pCSS->Release();
    }

    //
    // Attributes.
    //
    BOOL bReadOnly = YesNo(TEXT("READONLY"), FALSE );
    LONG bSize;
    ValueOf( L"SIZE", 1, (DWORD*)&bSize );

    if( bSize < 1 )
    {
        // SIMPLE
        m_Style |= CBS_SIMPLE;
    }
    else
    {
        // COMBO
        if( bReadOnly )
            m_Style |= CBS_DROPDOWNLIST;    // CANNOT type text.
        else
            m_Style |= CBS_DROPDOWN;        // can type text
    }

    m_Style |= YesNo( TEXT("SORT"), CBS_SORT, 0, CBS_SORT );    // default is to sort.

	m_bInit=TRUE;
}

HRESULT CXMLCombo::OnInit(HWND hWnd)
{
    BASECLASS::OnInit(hWnd);
    if(m_pTextItem)
    {
        //
        // Probably need to check for "HASSTRINGs" or equivalent
        //
        int iCount=m_pTextItem->GetCount();
        CXMLItem * pItem;
        int iPosition;
        BOOL bSelected=FALSE;
        for( int i=0;i<iCount;i++)
        {
            pItem=m_pTextItem->GetPointer(i);
    		// iPosition = SendMessage( hWnd, CB_ADDSTRING, 0, (LPARAM)pItem->GetText());
    		iPosition = SendMessage( hWnd, CB_INSERTSTRING, -1, (LPARAM)pItem->GetText());
            if(iPosition != CB_ERR )
            {
                SendMessage( hWnd, CB_SETITEMDATA, iPosition, pItem->GetValue() );
                if( pItem->GetSelected() )
                {
                    SendMessage( hWnd, CB_SETCURSEL, iPosition, NULL );
                    bSelected=TRUE;
                }
            }
        }
        if( bSelected == FALSE) 
    	    SendMessage( hWnd, CB_SETCURSEL, 0, NULL);
    }
   return S_OK;
}

HRESULT CXMLCombo::AcceptChild(IRCMLNode * pChild )
{
    if( SUCCEEDED( pChild->IsType(L"ITEM") ))  // BUGBUG - should be QI
    {
        if(m_pTextItem==NULL)
            m_pTextItem=new CXMLItemList;
        m_pTextItem->Append( (CXMLItem*)pChild );
        return S_OK;
    }
    ACCEPTCHILD( L"WIN32:COMBO", CXMLComboStyle, m_pControlStyle );
    return BASECLASS::AcceptChild(pChild);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// if you ever want to have control containership this will
// have to change a LOT, but for now, it allows me to get at namespace extentions.
//
HRESULT STDMETHODCALLTYPE CXMLCombo::GetChildEnum( 
    IEnumUnknown __RPC_FAR *__RPC_FAR *pEnum)
{
    if( m_pTextItem == NULL )
        return E_FAIL;

    if( pEnum )
    {
        *pEnum = new CEnumControls<CXMLItemList>(*m_pTextItem);
        (*pEnum)->AddRef();
        return S_OK;
    }
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmledit.h ===
// XMLEdit.h: interface for the CXMLEdit class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XMLEDIT_H__6DB81579_3CE6_4AD5_A97E_D947A2A2DFC7__INCLUDED_)
#define AFX_XMLEDIT_H__6DB81579_3CE6_4AD5_A97E_D947A2A2DFC7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "XMLNode.h"
#include "xmlcontrol.h"

class CXMLEditStyle : public CXMLControlStyle
{
public:
    CXMLEditStyle();
	virtual ~CXMLEditStyle() {};
	typedef CXMLControlStyle BASECLASS;
	XML_CREATE( EditStyle );
    UINT    GetBaseStyles() { Init(); return editStyle; }
    void    Init();

protected:

    union
    {
        UINT    editStyle;
        struct {
            UINT    m_pad1:2;       // elsewhere
            BOOL    m_MultiLine:1;  // ES_MULTILINE
            UINT    m_pad2:5;       // elsewhere
            BOOL    m_NoHideSel:1;  // ES_NOHIDESEL
            BOOL    m_pad3:1;
            BOOL    m_OemConvert:1; // ES_OEMCONVERT
            BOOL    m_pad4:1;       // elsewhere
            BOOL    m_WantReturn:1; // ES_WANTRETURN
        };
    };
};

class CXMLEdit : public _XMLControl<IRCMLControl>
{
public:
	CXMLEdit ();
    virtual ~CXMLEdit() {};
	XML_CREATE( Edit );
    typedef _XMLControl<IRCMLControl> BASECLASS;
    IMPLEMENTS_RCMLCONTROL_UNKNOWN;

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnInit( 
        HWND h);    // actually implemented

    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptChild( 
        IRCMLNode __RPC_FAR *child);


protected:
	void            Init();
    BOOL            m_bFile;
    CXMLEditStyle * m_pControlStyle;

};

#endif // !defined(AFX_XMLEDIT_H__6DB81579_3CE6_4AD5_A97E_D947A2A2DFC7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlcontrol.h ===
// XMLControl.h: interface for the CXMLControl class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XMLCONTROL_H__085816B3_9350_4EE4_B82E_2F95ABD7790B__INCLUDED_)
#define AFX_XMLCONTROL_H__085816B3_9350_4EE4_B82E_2F95ABD7790B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "xmlnode.h"    // templated goo
#include "xmlstyle.h"
#include "xmlitem.h"
#include "xmlwin32.h"
#include "xmllocation.h"
#include "xmlhelp.h"

#include "persctl.h"    // resize goo.

//
// Used by all the WIN32:BUTTONSTYLE, WIN32:LABELSTYLE 
//
class CXMLControlStyle : public _XMLNode<IRCMLNode>
{
public:
    CXMLControlStyle() {};

    virtual ~CXMLControlStyle() {};
	typedef _XMLNode<IRCMLNode> BASECLASS;
    IMPLEMENTS_RCMLNODE_UNKNOWN;

    UINT        GetBaseStyles();

protected:
    void		Init() {};
    BOOL		m_bInit;
};


////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// This is the XML representation of the XML control element - that is the CONTROL tag
// this is NOT derived from. The baseclass functionality of each and every control
// is provided by the template _XMLControl<IRCMLControl>
// you'll find some implementations of the baseclass methods in xmlcontrol.cpp
//
IRCMLControl * GetXMLControl(HWND hWnd);

class CXMLSimpleControl: public _XMLControl<IRCMLControl>
{
public:
    CXMLSimpleControl() {};
    virtual ~CXMLSimpleControl() {};
	XML_CREATE( SimpleControl );
    typedef _XMLControl<IRCMLControl> BASECLASS;
    IMPLEMENTS_RCMLCONTROL_UNKNOWN;
};

#endif // !defined(AFX_XMLCONTROL_H__085816B3_9350_4EE4_B82E_2F95ABD7790B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmldlg.h ===
//
// The implementations of the nodes that make up the tree
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XMLDLG_H__CAF7DEF3_DD82_11D2_8BCE_00C04FB177B1__INCLUDED_)
#define AFX_XMLDLG_H__CAF7DEF3_DD82_11D2_8BCE_00C04FB177B1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "XMLControl.h"
#include "xmlstyle.h"
#include "resizedlg.h"
#include "xmllayout.h"
#include "xmlstringtable.h"
#include "xmlformoptions.h"

class CXMLForms;

#undef PROPERTY
#define PROPERTY( type, id ) type Get##id() { Init(); return m_##id; }

//
// An edge - indent from the left, and resize weight.
// used by the resize code
//
class CXMLEdge : public _XMLNode<IRCMLNode>
{
public:
	CXMLEdge();
	virtual ~CXMLEdge();
	typedef _XMLNode<IRCMLNode> BASECLASS;
    IMPLEMENTS_RCMLNODE_UNKNOWN;
   	XML_CREATE( Edge );

	PROPERTY(WORD, Indent );
	PROPERTY(WORD, Weight );
protected:
	void Init();
	WORD	m_Indent;
	WORD	m_Weight;
};
typedef _List<CXMLEdge>	CXMLEdges;

#ifdef _OLDCODE
//
// For some dialogs we present a "Don't show this to me again" checkbox.
// this is the information about the text to display, where in the registry we store it,
// and what is the default value we return to the user.
// Optional tag information.
//
class CXMLOptional : public _XMLNode<IRCMLNode>
{
public:
	CXMLOptional ();
	virtual ~CXMLOptional () {};
	typedef _XMLNode<IRCMLNode> BASECLASS;
    IMPLEMENTS_RCMLNODE_UNKNOWN;

	PROPERTY( DWORD, DefValue );
	LPCTSTR	GetRegistration() { Init(); return m_Registration; }
	LPCTSTR	GetText() { Init(); return m_Text; }

private:
	DWORD	m_DefValue;			// return value to send back.
	LPCTSTR	m_Registration;		// where in the registyr
	LPCTSTR	m_Text;				// text to display to the user.

protected:
	void Init();
};

#endif


//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
//
// For 'legacy' coding reasons, this is the <PAGE> element. It's a child of <FORM>
// this is returned from RCMLLoadFile
//
class CXMLDlg  : public _XMLControl<IRCMLControl>, public IRCMLContainer
{
public:
	HWND GetTooltipWindow();
	typedef _XMLControl<IRCMLControl> BASECLASS;

	CXMLDlg();
	virtual ~CXMLDlg();

    XML_CREATE(Dlg);

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnInit( 
        HWND h);    // actually implemented

    virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CSS( 
        /* [retval][out] */ IRCMLCSS __RPC_FAR *__RPC_FAR *pCSS); // actually implemented

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPixelLocation( 
            /* [in] */ IRCMLControl __RPC_FAR *__MIDL_0015,
            /* [retval][out] */ RECT __RPC_FAR *pRect);

	virtual BOOL CALLBACK DlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
    // Common controls
    static      void InitComctl32(DWORD dwFlags);

    virtual ULONG STDMETHODCALLTYPE AddRef( void)
    { return BASECLASS::AddRef(); }

    virtual ULONG STDMETHODCALLTYPE Release( void)
    { return BASECLASS::Release(); }

    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void ** ppvObject) 
    {   if (riid == IID_IUnknown) 
            *ppvObject = static_cast<IUnknown*>((IRCMLContainer*)this);  
        else if (riid == __uuidof(IRCMLNode))           
            *ppvObject = static_cast<IRCMLNode*>(this); 
        else if (riid == __uuidof(IRCMLContainer))        
            *ppvObject = static_cast<IRCMLContainer*>(this); 
        else if (riid == __uuidof(IRCMLControl))        
            *ppvObject = static_cast<IRCMLControl*>(this); 
        else 
        {
            *ppvObject = NULL; return E_NOINTERFACE; 
        }
        reinterpret_cast<IUnknown*>(*ppvObject)->AddRef(); 
        return S_OK; 
    }

	//
	// Attributes 
	//
	LPCTSTR	GetFont() { Init(); return m_Font; }
	DWORD   GetFontSize() { Init(); return m_FontSize; }

    WORD    GetResizeMode() { InitLayout(); return m_ResizeMode; }
    WORD    GetCilppingMode() { InitLayout(); return m_ClippingMode; }

    void    SetExternalFileWarning(BOOL b ) { m_ExternalFileWarning=b; }
    BOOL    GetExternalFileWarning() { return m_ExternalFileWarning; }

    //
    // Tree building.
    //
    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptChild( 
        IRCMLNode __RPC_FAR *child);

	BOOL				HasChildren()  { return GetChildren().GetCount(); }
	int					GetChildCount() { return GetChildren().GetCount(); }
	IRCMLControlList 	& GetChildren() { return m_Children; }

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetChildEnum( 
        IEnumUnknown __RPC_FAR *__RPC_FAR *pEnum);

#ifdef _OLDCODE
	CXMLStyles			& GetStyles() { return m_Styles; }
	CXMLEdges	*	GetColumns() { return m_pColumns; }
	CXMLEdges	*	GetRows() { return m_pRows; }
#endif

	//
	// Layout
	//
	CXMLWin32Layout * GetLayout() { return m_qrLayout.GetInterface(); }
	void    SetLayout( CXMLWin32Layout *L ) { m_qrLayout=L; }
    BOOL    IsVisible() { return m_bVisible; }

    RECT    GetPixelLocation( IRCMLControl * pControl );
    SIZE    GetPixelSize( SIZE s);
    SIZE    GetDLUSize( SIZE s);


    void    BuildRelationships();
    PROPERTY( UINT, MenuID );

    CXMLStringTable *   GetStringTable() { return m_qrStringTable.GetInterface(); }
    void    SetStringTable( CXMLStringTable * st ) { m_qrStringTable = st; }

    CXMLFormOptions *   GetFormOptions() { return m_qrFormOptions.GetInterface(); }
    void    SetFormOptions( CXMLFormOptions * st ) { m_qrFormOptions = st; }

    CXMLForms *   GetForm() { return m_pForm; }
    void    SetForm( CXMLForms * st ) { m_pForm = st;}

private:
    struct
    {
        BOOL        m_bPostProcessed:1;
        BOOL        m_bInitLayout:1;
        BOOL        m_bInitStyle:1;
        BOOL        m_bVisible:1;
        BOOL		m_bSpecialPainting:1;
        BOOL        m_ExternalFileWarning:1;
        WORD	    m_ResizeMode:2;
        WORD	    m_ClippingMode:2;
    };

	LPWSTR	        m_Font;
	DWORD	        m_FontSize;
    IRCMLControl *  FindControlID(LPCWSTR pIDName);
    UINT            m_MenuID;

    CQuickRef<CXMLStringTable> m_qrStringTable;
    CQuickRef<CXMLFormOptions> m_qrFormOptions;
	CQuickRef<CXMLWin32Layout> m_qrLayout;

    CXMLForms       * m_pForm;
    HWND    m_hTooltip;

protected:
	HWND	    GetWindow() { return m_hWnd; }
	HWND	    m_hWnd;
	void		Init();
    void        InitLayout();   // RESIZEMODE property.
    void        InitStyle();   // RESIZEMODE property.

	IRCMLControlList m_Children;
    DWORD       m_FontBaseMapping;  // how to get from DLU to Pixels.
    void        GetFontMapping();
//	CXMLStyles  m_Styles;

    CXMLLayout  * m_pHoldingLayout; // keep this to delete it.

	CResizeDlg	* m_pResize;
#ifdef _OLDCODE
	CXMLEdges	* m_pColumns;
	CXMLEdges	* m_pRows;
#endif
	//
	// Grid painting
	//
	HBRUSH		m_hGridBrush;
	void		DoAlphaGrid();
	void		DoPaint( HDC hDC);
	BOOL		IsSpecialPainting() {return m_bSpecialPainting; }
	void		SetSpecialPainting( BOOL b) {m_bSpecialPainting=b;}
	void		PaintBrush(HDC hd, int width, int height);
};

typedef _RefcountList<CXMLDlg> CXMLDlgList;

#endif // !defined(AFX_XMLDLG_H__CAF7DEF3_DD82_11D2_8BCE_00C04FB177B1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlcontrol.cpp ===
// XMLControl.cpp: implementation of the CXMLSimpleControl class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "XMLControl.h"
#include "utils.h"
#include "debug.h"
#include "XMLdlg.h"
#include "enumcontrols.h"

// 
#pragma warning( disable : 4273 )   // not all classes need to be exported

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//  Bit                 Value           Element.
//  WS_OVERLAPPED       0x00000000L     WIN32\@Overlapped
//  WS_POPUP            0x80000000L     WIN32\@Popup
//  WS_CHILD            0x40000000L     WIN32\@Child
//  WS_MINIMIZE         0x20000000L     WIN32\@MaximizeButton
//  WS_VISIBLE          0x10000000L     WIN32\@VISIBLE
//  WS_DISABLED         0x08000000L     WIN32\@DISABLED
//  WS_CLIPSIBLINGS     0x04000000L     WIN32\@ClipSiblings
//  WS_CLIPCHILDREN     0x02000000L     WIN32\@ClipChildren
//  WS_MAXIMIZE         0x01000000L     WIN32\@MaximizeButton="YES"
//  WS_CAPTION          0x00C00000L     /* WS_BORDER | WS_DLGFRAME  */
//  WS_BORDER           0x00800000L     WIN32\@BORDER="YES"
//  WS_DLGFRAME         0x00400000L     WIN32\@DLGFRAME="YES"
//  WS_VSCROLL          0x00200000L     WIN32\@VSCROLL="YES"
//  WS_HSCROLL          0x00100000L     WIN32\@HSCROLL="YES"
//  WS_SYSMENU          0x00080000L     WIN32\@SYSMENU="YES"
//  WS_THICKFRAME       0x00040000L     WIN32\@THICKFRAME="YES"   implied from RESIZE="AUTOMATIC"
//  WS_GROUP            0x00020000L     WIN32\@GROUP="YES/NO"
//  WS_TABSTOP          0x00010000L     WIN32\@TABSTOP="YES/NO"
//
//  EX Style
//  WS_EX_DLGMODALFRAME     0x00000001L WIN32\@MODALFRAME
//  WS_EX_NOPARENTNOTIFY    0x00000004L WIN32\@PARENTNOTIFY="NO"
//  WS_EX_TOPMOST           0x00000008L WIN32\@TOPMOST
//  WS_EX_ACCEPTFILES       0x00000010L WIN32\@DROPTARGET
//  WS_EX_TRANSPARENT       0x00000020L WIN32\@TRANSPARENT
// #if(WINVER >= 0x0400)
//  WS_EX_MDICHILD          0x00000040L WIN32\@MDICHILD
//  WS_EX_TOOLWINDOW        0x00000080L WIN32\@TOOLWINDOW="YES"
//  WS_EX_WINDOWEDGE        0x00000100L WIN32\@WINDOWEDGE
//  WS_EX_CLIENTEDGE        0x00000200L WIN32\@CLIENTEDGE (not quite CSS)
//  WS_EX_CONTEXTHELP       0x00000400L WIN32\@ContextHelp="YES" (implied by having HELP?)

//  WS_EX_RIGHT             0x00001000L WIN32\@RIGHT
//  WS_EX_LEFT              0x00000000L WIN32\@LEFT
//  WS_EX_RTLREADING        0x00002000L WIN32\@RTLREADING
//  WS_EX_LTRREADING        0x00000000L WIN32\@LTRREADING
//  WS_EX_LEFTSCROLLBAR     0x00004000L WIN32\@LEFTSCROLLBAR
//  WS_EX_RIGHTSCROLLBAR    0x00000000L WIN32\@RIGHTSCROLLBAR

//  WS_EX_CONTROLPARENT     0x00010000L WIN32\@CONTROLPARENT="YES"
//  WS_EX_STATICEDGE        0x00020000L WIN32\@STATICEDGE
//  WS_EX_APPWINDOW         0x00040000L WIN32\@APPWINDOW

//////////////////////////////////////////////////////////////////////////////
// this should be the templated version. REVIEW
void _XMLControl<IRCMLControl>::Init()
{
	if(m_bInit)
		return;

    LPWSTR pszType;
    get_StringType(&pszType);
	EVENTLOG( EVENTLOG_INFORMATION_TYPE, LOGCAT_CONSTRUCT, 0, 
        TEXT("CXMLSimpleControl::Init()"), TEXT("Initializing control %s"), pszType );

    //
    // Now initialize the children - perhaps we use the return result from
    // this init to say if we should re-init ourselves.
    //
    IRCMLNode * pChild;
    int iChildCount=0;
    while( pChild = m_UnknownChildren.GetPointer(iChildCount++) )
        pChild->InitNode( this );

	//
	// Setup the properties.
	//
	LPWSTR req;

    m_Class     = (LPWSTR)Get(TEXT("CLASS"));  // for <CONTROL @CLASS="foo"/>
    CXMLWin32 * pWin32=m_qrWin32Style.GetInterface();
    if( pWin32 )
    {
        if ( pWin32->GetClass() )
    	    m_Class=(LPWSTR)pWin32->GetClass();
        m_Style=pWin32->GetStyle();
        m_StyleEx=pWin32->GetStyleEx();
    }
    else
    {
	    m_Style=WS_CHILD | WS_VISIBLE  ;  // HMM - is this a good default?
	    m_StyleEx=0;    // HMM - is this a good default?
    }

	if( HIWORD(m_Class) )
		TRACE(TEXT("Wnd class %s\n"),m_Class);

    InitCSS();
    //
    // we need the text to point to something, never NULL.
    //
	req=(LPWSTR)Get(L"TEXT");
    m_Text=req?req:L"";

	DWORD dwID;
    ValueOf( L"ID", -1, &dwID);
    if( dwID != -1 )
	    m_ID = (LPWSTR)dwID;
    else
    {
        m_ID=(LPWSTR)Get( L"ID" );
        if( m_ID==NULL )
            m_ID=(LPWSTR)0xffff;
    }

    //
    // Leave this at zero, then the controls themselves check for zero, and
    // pick the 'default'. Of course this upsets testing, because not all 
    // controls pick defaults, and so they end up with zero sized controls etc.
    //
    ValueOf( L"WIDTH", 0, (LPDWORD)&m_Width  );
    ValueOf( L"HEIGHT", 0, (LPDWORD)&m_Height );
    ValueOf( L"X", 0 , (LPDWORD)&m_X );
    ValueOf( L"Y", 0 , (LPDWORD)&m_Y );

    BOOL bTabIndex=FALSE;
    // these things are TABSTOP by default.
    if(!lstrcmpi( pszType, L"EDIT") |
	   !lstrcmpi( pszType, L"RADIO") | 
	   !lstrcmpi( pszType, L"CHECKBOX") | 
	   !lstrcmpi( pszType, L"GROUPBOX") | 
	   !lstrcmpi( pszType, L"BUTTON") | 
	   !lstrcmpi( pszType, L"COMBO") | 
	   !lstrcmpi( pszType, L"LIST") | 
	   !lstrcmpi( pszType, L"SLIDER") | 
	   !lstrcmpi( pszType, L"LISTVIEW") | 
	   !lstrcmpi( pszType, L"TREEVIEW") |
       !lstrcmpi( pszType, L"TABINDEX") )
    {
        bTabIndex=TRUE;
    }
    else
    {
        BOOL bRes;
        ValueOf( TEXT("TABINDEX"),-1, (LPDWORD)&bRes);
        if( bRes == 0 )
            bTabIndex=TRUE;
    }

    if(bTabIndex)
        m_Style |= WS_TABSTOP;

	m_bInit=TRUE;
}

////////////////////////////////////////////////////////////////////////////////////
//
//
//
////////////////////////////////////////////////////////////////////////////////////
void _XMLControl<IRCMLControl>::InitCSS()
{
    // RESIZING
    BOOL bRes;
    IRCMLCSS *	pStyle=NULL;
    if( FAILED( get_CSS( &pStyle )))
        pStyle=NULL;

    // Just having a style object, doesn't mean that the control 
    // specifies everything. Check to see if those attributes
    // are present in the style object, before asking it.
    // I know, this is annoying.
    if( pStyle )
	{
        LPWSTR pszFill;
        if( m_ResizeSet=SUCCEEDED( pStyle->get_Attr(L"FILL", &pszFill))) 
        {
		    pStyle->get_GrowsWide(&bRes); m_GrowsWide=bRes;
		    pStyle->get_GrowsTall(&bRes); m_GrowsHigh=bRes;
        }
	}
    else
        m_ResizeSet = m_GrowsHigh = m_GrowsWide= FALSE;

    // CLIPPING
    if( pStyle )
	{
        LPWSTR pszClipping;
        if( m_ClippingSet=SUCCEEDED( pStyle->get_Attr(L"CLIPPED", &pszClipping))) 
        {
		    pStyle->get_ClipHoriz(&bRes); m_ClipHoriz=bRes;
		    pStyle->get_ClipVert(&bRes); m_ClipVert=bRes;
        }
	}
    else
        m_ClippingSet = m_ClipHoriz = m_ClipVert= FALSE;

    //
    // <STYLE>
    //
    if( pStyle )
    {
        // @DISPLAY
        pStyle->get_Visible(&bRes);
        if( bRes )
        {
            m_Style |= WS_VISIBLE;
        }
        else
        {
            m_Style &=~WS_VISIBLE;
        }

        //
        // @BORDER
        //
        // we care about INSET OUTSET RIDGE
        LPWSTR pBStyle;
        int BWidth;
        pStyle->get_BorderStyle( &pBStyle);
        pStyle->get_BorderWidth(&BWidth);
        if( lstrcmpi( pBStyle, L"INSET" ) ==0 )
        {
            if( BWidth==1 )
                m_StyleEx |= WS_EX_STATICEDGE;
            else if( BWidth==2)
                m_StyleEx |= WS_EX_CLIENTEDGE;
            else if( BWidth>2)
                m_StyleEx |= WS_EX_CLIENTEDGE | WS_EX_STATICEDGE;

        }
        else if( lstrcmpi( pBStyle, L"OUTSET" ) ==0 )
        {
            if( BWidth== 2 )
                m_StyleEx |= WS_EX_WINDOWEDGE | WS_EX_DLGMODALFRAME;
        }
        else if( lstrcmpi( pBStyle, L"RIDGE" ) ==0 )
        {
            if( BWidth==3 )
                m_StyleEx |= WS_EX_CLIENTEDGE | WS_EX_WINDOWEDGE | WS_EX_DLGMODALFRAME;
        }
        else
        {
        }
    }

    if( pStyle )
    {
        pStyle->Release();
        pStyle=NULL;
    }
}

//////////////////////////////////////////////////////////////////////////////
//
//
//
//////////////////////////////////////////////////////////////////////////////
HRESULT _XMLControl<IRCMLControl>::get_Location(RECT * pRect )
{
    RELATIVETYPE_ENUM relType;
    if( SUCCEEDED ( get_RelativeType( &relType )))
    {
	    if( relType!=RELATIVE_TO_NOTHING )
	    {
            if( m_pLocation.GetInterface() )
            {
		        IRCMLControl * pTo;
                if( SUCCEEDED( get_RelativeTo( & pTo )))
		        {
                    RECT r;
                    pTo->get_Location(&r);          // find the location of the other control
			        r=m_pLocation->GetLocation(r);  // add onto it, any delta desribed by us??
                    pRect->bottom=r.bottom;
                    pRect->top=r.top;
                    pRect->left=r.left;
                    pRect->right=r.right;
                    pTo->Release();
                    return S_OK;
                }
		        else
		        {
			        RECT r; // how does this ever get called?? yes, when relative stuff gets screwed up?
                    r.bottom = pRect->bottom;
                    r.left = pRect->left;
                    r.right = pRect->right;
                    r.top = pRect->top;
                    m_pLocation->GetLocation(r);
                    pRect->bottom=r.bottom;
                    pRect->top=r.top;
                    pRect->left=r.left;
                    pRect->right=r.right;
                    return S_OK;
		        }
            }
            return E_FAIL;
            // ERROR
	    }
    }

    Init(); // force the initialization of m_ stuff - we're not relative to anything.
	pRect->left = m_X;
	pRect->right = pRect->left + m_Width;
	pRect->top = m_Y;
	pRect->bottom = pRect->top + m_Height;

	return S_OK;;
}

//////////////////////////////////////////////////////////////////////////////
//
//
//
//////////////////////////////////////////////////////////////////////////////
#if 0
HRESULT _XMLControl<IRCMLControl>::get_Location(RECT * pCurrRect)
{
	if( IsRelative() )
	{
		IRCMLControl * pTo=GetRelativeTo();
        if( m_pLocation )
        {
		    if( pTo )
		    {
			    return m_pLocation->GetLocation(pTo->GetLocation(currRect));
		    }
		    else
			    return m_pLocation->GetLocation(currRect);
        }
        else
        {
            TRACE(TEXT("No layout element"));// ERROR
        }
	}

	RECT r;
	r.left = GetX();
	r.right = r.left + GetWidth();
	r.top = GetY();
	r.bottom = r.top + GetHeight();
	return r;
}
#endif
/*
 * This guy here is called when the paint is invoked.
 * Will draw the required edges and fill in the passed
 * in rectangle.  That rectangle is control - edges
 */
void _XMLControl<IRCMLControl>::DrawEdge(HDC hdc, LPRECT pInnerRect)
{
#pragma message("------------- Border support lost")
#if 0
	*pInnerRect = GetLocation();
//	CBorder* pBorder;

//	if(m_pStyle && (pBorder=m_pStyle->GetBorder()) != NULL)
//	pBorder->DrawBorder(hdc, pInnerRect);
#else
    pInnerRect=NULL;
#endif
}

//////////////////////////////////////////////////////////////////////////////
//
//
//
//////////////////////////////////////////////////////////////////////////////
HRESULT _XMLControl<IRCMLControl>::get_CSS( IRCMLCSS ** pCss )
{
    if( *pCss=m_qrCSS.GetInterface() )
    {
        (*pCss)->AddRef();
        return S_OK;
    }
    
    //
    // This is for 'cascading' kind of thing. 
    // CXMLDlg can have NULL as a style - this is a class 3 designer - no styles.
    // The layout font is the UI font, and all colors come from the schemes.
    //
    HRESULT hres=E_FAIL;
    *pCss=NULL;
    IRCMLNode * pParent;
    if( SUCCEEDED( hres=DetachParent( &pParent  )))
    {
        IRCMLControl * pControl;
        if( SUCCEEDED( hres=pParent->QueryInterface( __uuidof( IRCMLControl ), (LPVOID*) &pControl )))
        {
            hres=pControl->get_CSS( pCss);
            pControl->Release();
            put_CSS(*pCss);
        }
    }
    if( *pCss == NULL )
        hres=E_FAIL;
    return hres;
}



HRESULT _XMLControl<IRCMLControl>::OnInit( HWND hWnd )
{
    m_hWnd=hWnd;

    //
	// Set the control font
    //
	IRCMLCSS *	pxmlStyle;
    if( SUCCEEDED( get_CSS( &pxmlStyle )))
    {
        HFONT hFont;
		if(  SUCCEEDED( pxmlStyle->get_Font( &hFont ) ) )
			SendMessage(hWnd, WM_SETFONT, (WPARAM)hFont, 0);
        pxmlStyle->Release();
	}

    //
    // Setup the tooltip
    //
    IRCMLHelp * pXMLHelp ;
	if( SUCCEEDED( get_Help( &pXMLHelp ) ) )
	{
        CXMLDlg * pDlg=(CXMLDlg*)GetContainer();
        if( SUCCEEDED( pDlg->IsType( L"PAGE" )))
            CXMLTooltip::AddTooltip( pXMLHelp, pDlg );
        pXMLHelp->Release();
	}

    //
    // Now call all the children.
    //
    IRCMLNode * pChild;
    int iChildCount=0;
    while( pChild = m_UnknownChildren.GetPointer(iChildCount++) )
        pChild->DisplayNode( this );
    return S_OK;
}

//
// hWnd is the control itself.
//
HRESULT _XMLControl<IRCMLControl>::OnDestroy(HWND hWnd, WORD wLastCmd)
{
    // Now call all the children.
    IRCMLNode * pChild;
    int iChildCount=0;
    while( pChild = m_UnknownChildren.GetPointer(iChildCount++) )
        pChild->ExitNode( this , wLastCmd );
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// All controls have some understanding of children, from IRCMLNode
//
HRESULT _XMLControl<IRCMLControl>::AcceptChild( 
    IRCMLNode *pChild)
{
    LPWSTR pType;
    LPWSTR pChildType;
    get_StringType( &pType );
    pChild->get_StringType( &pChildType );

    EVENTLOG( EVENTLOG_INFORMATION_TYPE, LOGCAT_LOADER , 0, 
        TEXT("CXMLSimpleControl::AcceptChild()"), TEXT("%s trying to accept %s"), pType, pChildType );

    if( SUCCEEDED( pChild->IsType( L"RELATIVE" ) ))     // used to be LOCATION
    {   m_pLocation=(CXMLLocation*)pChild; return S_OK; }

    if( SUCCEEDED( pChild->IsType( L"STYLE" ) ))
    {  
        //
        // First we verify that this really is a style node and set it up to be this
        // controls style node.
        //
        IRCMLCSS * pICSS;
        if( !SUCCEEDED( pChild->QueryInterface( __uuidof( IRCMLCSS ), (LPVOID*) & pICSS )))
            return E_INVALIDARG;    // although it smells like a STYLE node, it isn't.

        put_CSS(pICSS);

        //
        // Now we have to set the "Dialog Style" for the style node itself.
        // any property not on the STYLE element, comes from the DIALOGStyle element.
        //
        IRCMLNode * pParent = this;
        while( pParent && ( !SUCCEEDED( pParent->IsType(L"PAGE" ) )))       // WAS DIALOG
        {
            IRCMLNode * parentParent;
            pParent->DetachParent( &parentParent );
            pParent=parentParent;
        }

        if(pParent==NULL)   // pParent should now be the PAGE
            return E_FAIL;  //

        // Get the parent's Style object, and place a reference - is this STRONG or WEAK??
        IRCMLControl * pParentControl;
        if( SUCCEEDED( pParent->QueryInterface( __uuidof( IRCMLControl ), (LPVOID*) &pParentControl )))
        {
            IRCMLCSS * pParentCSS;
            if( SUCCEEDED( pParentControl->get_CSS( &pParentCSS )))
            {
                if( pICSS )
                    pICSS->put_DialogStyle( pParentCSS );
                pParentCSS->Release();
            }
            pParentControl->Release();
        }
        pICSS->Release();
        return S_OK;
    }

    if( SUCCEEDED( pChild->IsType( L"HELP" ) ))
    {
        put_Help( (IRCMLHelp*)pChild); 
        return S_OK;
    }
    
    // given a WIN32:STYLE specific STYLE element.
    if( SUCCEEDED( pChild->IsType( L"WIN32:STYLE" ) ))
    {  
        m_qrWin32Style= (CXMLWin32*)pChild; 
        return S_OK; 
    }
        
    //
    // Put this node in the 'unknown bucket'
    //
    EVENTLOG( EVENTLOG_ERROR_TYPE, LOGCAT_LOADER, 1, 
        TEXT("Parser"), TEXT("The node %s cannot take a %s as a child - putting it in the 'unknown bucket' "), 
        pType, pChildType );
    m_UnknownChildren.Append( pChild );
    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// if you ever want to have control containership this will
// have to change a LOT, but for now, it allows me to get at namespace extentions.
//
#if 0
HRESULT STDMETHODCALLTYPE _XMLControl<IRCMLControl>::GetChildEnum( 
    IEnumUnknown __RPC_FAR *__RPC_FAR *pEnum)
{
    if( pEnum )
    {
        *pEnum = new CEnumControls<CRCMLNodeList>(m_UnknownChildren);
        (*pEnum)->AddRef();
        return S_OK;
    }
    return E_FAIL;
}
#endif

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// if you ever want to have control containership this will
// have to change a LOT, but for now, it allows me to get at namespace extentions.
//
HRESULT STDMETHODCALLTYPE _XMLControl<IRCMLControl>::GetUnknownEnum( 
    IEnumUnknown __RPC_FAR *__RPC_FAR *pEnum)
{
    if( pEnum )
    {
        *pEnum = new CEnumControls<CRCMLNodeList>(m_UnknownChildren);
        (*pEnum)->AddRef();
        return S_OK;
    }
    return E_FAIL;
}










#ifdef _OLD_CODE

/////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// WHAT IS THIS CLASS?,
//
CXMLOptional::CXMLOptional()
{
	m_bInit=FALSE;
	NODETYPE = BASECLASS::NT_OPTIONAL;
    m_StringType=TEXT("OPTIONAL");
}

void CXMLOptional::Init()
{
	if(m_bInit)
		return;
	BASECLASS::Init();

    m_DefValue = ValueOf( TEXT("DEFAULT"), 0 );
	m_Registration=Get(TEXT("ID"));
	m_Text=Get(TEXT("TEXT"));

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlcombo.h ===
// XMLCombo.h: interface for the CXMLCombo class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XMLCOMBO_H__74CEE790_7870_426E_B2E4_9EE0D1A89CE4__INCLUDED_)
#define AFX_XMLCOMBO_H__74CEE790_7870_426E_B2E4_9EE0D1A89CE4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "XMLControl.h"
/////////////////////////////////////////////////////////////////////////////////
//
// Contains the shared style bits for all buttons
//
/////////////////////////////////////////////////////////////////////////////////
class CXMLComboStyle : public CXMLControlStyle
{
public:
    CXMLComboStyle();
	virtual ~CXMLComboStyle() {};
	typedef CXMLControlStyle BASECLASS;
	XML_CREATE( ComboStyle );
    UINT    GetBaseStyles() { Init(); return comboStyle; }
    void    Init();

protected:
//
// ComboBox
//
// CBS_SIMPLE            0x0001L     A  // SIZE!="1" READONLY (doesn't matter)
// CBS_DROPDOWN          0x0002L     A  // SIZE="1" READONLY="NO
// CBS_DROPDOWNLIST      0x0003L     A  // SIZE="1" READONLY="YES"
// CBS_OWNERDRAWFIXED    0x0010L     C  // WIN32:COMBOBOX\@OWNERDRAWFIXED
// CBS_OWNERDRAWVARIABLE 0x0020L     C  // WIN32:COMBOBOX\@OWNERDRAWVARIABLE
// CBS_AUTOHSCROLL       0x0040L     S  // STYLE\overflow-y="auto"
// CBS_OEMCONVERT        0x0080L     C  // WIN32:COMBOBOX\OEMCONVERT
// CBS_SORT              0x0100L     A  // SORT="YES"
// CBS_HASSTRINGS        0x0200L     C  // WIN32:COMBOBOX\HASSTRINGS
// CBS_NOINTEGRALHEIGHT  0x0400L     C  // WIN32:COMBOBOX\NOINTEGRALHEIGHT
// CBS_DISABLENOSCROLL   0x0800L     C  // WIN32:COMBOBOX\DISALBENOSCROLL
// CBS_UPPERCASE           0x2000L   S  // STYLE\@text-transform=uppercase
// CBS_LOWERCASE           0x4000L   S  // STYLE\@text-transform=lowercase
//
// http://msdn.microsoft.com/workshop/author/dhtml/reference/objects/SELECT.asp
//

    union
    {
        UINT    comboStyle;
        struct {
            UINT    m_enum:2;             // type of combo.
            UINT    m_enum2:2;            // not used.
            BOOL    m_OwnerDrawFixed:1;   // 0x0010
            BOOL    m_OwnerDrawVariable:1;// 0x0020
            BOOL    m_enum3:1;            // autovscroll 0x0040
            BOOL    m_OemConvert:1;       // 0x80
            UINT    m_enum4:1;            // short
            BOOL    m_HasStrings:1;       // 0x200
            BOOL    m_NoIntegralHeight:1;  // 0x4000
            BOOL    m_DisableNoScroll:1;    // 0x800
        };
    };
};

class CXMLCombo : public _XMLControl<IRCMLControl>
{
public:
	CXMLCombo();
    virtual ~CXMLCombo() { delete m_pTextItem; delete m_pControlStyle; }
	typedef _XMLControl<IRCMLControl> BASECLASS;

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnInit( 
        HWND h);    // actually implemented

	XML_CREATE( Combo );
    IMPLEMENTS_RCMLCONTROL_UNKNOWN;

    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptChild( 
        IRCMLNode __RPC_FAR *child);

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetChildEnum( 
        IEnumUnknown __RPC_FAR *__RPC_FAR *pEnum);

protected:
	void Init();
    CXMLItemList    * m_pTextItem;
    CXMLComboStyle  * m_pControlStyle;

};


#endif // !defined(AFX_XMLCOMBO_H__74CEE790_7870_426E_B2E4_9EE0D1A89CE4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlformoptions.cpp ===
// XMLFormOptions.cpp: implementation of the CXMLFormOptions class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "XMLFormOptions.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CXMLFormOptions::CXMLFormOptions()
{
  	NODETYPE = NT_FORMOPTIONS;
    m_StringType=L"FORMOPTIONS";
    m_DialogStyle=0;
}

CXMLFormOptions::~CXMLFormOptions()
{

}

#define DLGSTYLE(p,id, member, def) member = YesNo( id , def );

// Not every RCML file has a FORMOPTIONS child, so here's how to get the defaults.
UINT CXMLFormOptions::GetDefaultDialogStyle()
{
    return DS_SETFONT | DS_MODALFRAME ;
}

void CXMLFormOptions::Init()
{
   	if(m_bInit)
		return;
	BASECLASS::Init();

    //
    // Kept in ssync with ResFile.CPP CResFile::DumpDialogStyles
    //
    DLGSTYLE(  DS_ABSALIGN         , TEXT("ABSALIGN"),      m_AbsAlign,         FALSE );
    DLGSTYLE(  DS_SYSMODAL         , TEXT("SYSMODAL"),      m_SysModal,         FALSE );
    DLGSTYLE(  DS_LOCALEDIT        , TEXT("LOCALEDIT"),     m_LocalEdit,        FALSE );  // Local storage.

    DLGSTYLE(  DS_SETFONT          , TEXT("SETFONT"),       m_SetFont,          TRUE );  // User specified font for Dlg controls */
    DLGSTYLE(  DS_MODALFRAME       , TEXT("MODALFRAME"),    m_ModalFrame,       TRUE );  // Can be combined with WS_CAPTION  */
    DLGSTYLE(  DS_NOIDLEMSG        , TEXT("NOIDLEMSG"),     m_NoIdleMessgae,    FALSE );  // IDLE message will not be sent */
    DLGSTYLE(  DS_SETFOREGROUND    , TEXT("SETFOREGROUND"), m_SetForeground,    FALSE );  // not in win3.1 */

    DLGSTYLE(  DS_3DLOOK           , TEXT("DDDLOOK"),       m_3DLook,           FALSE );
    DLGSTYLE(  DS_FIXEDSYS         , TEXT("FIXEDSYS"),      m_FixedSys,         FALSE );
    DLGSTYLE(  DS_NOFAILCREATE     , TEXT("NOFAILCREATE"),  m_NoFailCreate,     FALSE );
    DLGSTYLE(  DS_CONTROL          , TEXT("CONTROL"),       m_Control,          FALSE );
    DLGSTYLE(  DS_CENTER           , TEXT("CENTER"),        m_Center,           FALSE );
    DLGSTYLE(  DS_CENTERMOUSE      , TEXT("CENTERMOUSE"),   m_CenterMouse,      FALSE );
    DLGSTYLE(  DS_CONTEXTHELP      , TEXT("CONTEXTHELP"),   m_ContextHelp,      FALSE );

    m_bInit=TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmledit.cpp ===
// XMLEdit.cpp: implementation of the CXMLEdit class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "XMLEdit.h"
#undef _WIN32_IE
#define _WIN32_IE 0x500
#include "shlwapi.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
#define CONTROLSTYLE(p,id, member, def) member = YesNo( id , def );

CXMLEditStyle::CXMLEditStyle()
{
	m_bInit=FALSE;
	NODETYPE = NT_EDITSTYLE;
    m_StringType=L"WIN32:EDIT";
}

void CXMLEditStyle::Init()
{
    if(m_bInit)
        return;
    BASECLASS::Init();

    editStyle=0;

    CONTROLSTYLE( ES_MULTILINE, TEXT("MULTILINE"), m_MultiLine, FALSE );
    CONTROLSTYLE( ES_NOHIDESEL, TEXT("NOHIDESEL"), m_NoHideSel, FALSE );
    CONTROLSTYLE( ES_OEMCONVERT, TEXT("OEMCONVERT"), m_OemConvert, FALSE );
    CONTROLSTYLE( ES_WANTRETURN, TEXT("WANTRETURN"), m_WantReturn, FALSE );

    m_bInit=TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Edit Control
//
CXMLEdit::CXMLEdit()
{
	m_bInit=FALSE;
	NODETYPE = NT_EDIT;
    m_StringType=TEXT("EDIT");
    m_pControlStyle=FALSE;
    m_bFile=FALSE;
}

//
// HEIGHT : defaults to 14
// PASSWORD
// CLASSIFICATION : UPPERCASE, LOWERCASE, NUMBER, DATE, TIME, FILENAME, URL, EMAILADDRESS
//
// http://msdn.microsoft.com/workshop/author/dhtml/reference/objects/INPUT_password.asp
//  ES_LEFT             0x0000L  *  // STYLE\@TEXT-ALIGN
//  ES_CENTER           0x0001L  *  // STYLE\@TEXT-ALIGN
//  ES_RIGHT            0x0002L  *  // STYLE\@TEXT-ALIGN
//  ES_MULTILINE        0x0004L  *  // WIN32:EDIT MULTILINE="YES"
//  ES_UPPERCASE        0x0008L  *  // STYLE\@text-transform=uppercase
//  ES_LOWERCASE        0x0010L  *  // STYLE\@text-transform=lowercase
//  ES_PASSWORD         0x0020L  *  // CONTENT="PASSWORD"
//  ES_AUTOVSCROLL      0x0040L  *  // STYLE\overflow-x="auto"
//  ES_AUTOHSCROLL      0x0080L  *  // STYLE\overflow-y="auto"
//  ES_NOHIDESEL        0x0100L  *  // WIN32:EDIT\NOHIDESEL
//  ES_OEMCONVERT       0x0400L  *  // WIN32:EDIT\OEMCONVERT
//  ES_READONLY         0x0800L  *  // READONLY="YES"
//  ES_WANTRETURN       0x1000L  *  // WIN32:EDIT\WANTRETURN
//  ES_NUMBER           0x2000L  *  // CONTENT="NUMBER"
//  SETLENGTH                       // MAXLENGTH
//
void CXMLEdit::Init()
{
	if(m_bInit)
		return;
    _XMLControl<IRCMLControl>::Init();

	LPWSTR req;
	m_Class=m_Class?m_Class:(LPWSTR)0x0081; // TEXT("EDIT");

	if( m_Height == 0 )
		m_Height=14;

    if( m_pControlStyle )
        m_Style |= m_pControlStyle->GetBaseStyles();
    else
    {
        m_Style |= 0; // edits don't have any defaults.
        m_StyleEx |= WS_EX_CLIENTEDGE;
    }

    IRCMLCSS * pCSS=NULL;
    if( SUCCEEDED( get_CSS( &pCSS) ))
    {
        LPWSTR res;
        // http://msdn.microsoft.com/workshop/author/dhtml/reference/properties/textAlign.asp#textAlign
        if( SUCCEEDED( pCSS->get_Attr( L"TEXT-ALIGN", &res ) ))
        {
            if( lstrcmpi(res,TEXT("LEFT"))==0 )
            {
                m_Style |=ES_LEFT;
            }
            else if( lstrcmpi(res,TEXT("RIGHT"))==0 )
            {
                m_Style |=ES_RIGHT;
            }
            else if( lstrcmpi(res,TEXT("CENTER"))==0 )
            {
                m_Style |=ES_CENTER;
            }
        }

        // http://msdn.microsoft.com/workshop/author/dhtml/reference/properties/textAlign.asp#textAlign
        if( SUCCEEDED( pCSS->get_Attr( L"TEXT-TRANSFORM", & res ) ))
        {
            if( lstrcmpi(res,TEXT("Uppercase"))==0 )
            {
                m_Style |=ES_UPPERCASE;
            }
            else if( lstrcmpi(res,TEXT("Lowercase"))==0 )
            {
                m_Style |=ES_LOWERCASE;
            }
        }

        m_Style |=ES_AUTOHSCROLL;
        if( SUCCEEDED( pCSS->get_Attr( L"OVERFLOW-X", & res ) ))
        {
            if( lstrcmpi(res,TEXT("VISIBLE"))==0 )
                m_Style &=~ES_AUTOHSCROLL;
        }

        if( SUCCEEDED( pCSS->get_Attr( L"OVERFLOW-Y", & res ) ))
        {
            if( lstrcmpi(res,TEXT("AUTO"))==0 )
                m_Style |= ES_AUTOVSCROLL;
        }
        pCSS->Release();
    }
    else
    {
        // What's the default for the above?
        m_Style |= ES_AUTOHSCROLL | ES_LEFT;
    }

    // CONTENT
    if( SUCCEEDED( get_Attr( L"CONTENT", &req ) ))
    {
		if( lstrcmpi( req, TEXT("NUMBER") )==0 )
		{
			m_Style |= ES_NUMBER;
		}
		else if( lstrcmpi( req, TEXT("FILE") )==0 )
		{
            m_StyleEx |= WS_EX_ACCEPTFILES;
            m_bFile=TRUE;
		}
		else if( lstrcmpi( req, TEXT("PASSWORD") )==0 )
		{
            m_Style |= ES_PASSWORD;
		}
	}

    // READONLY
    DWORD dwRes=0;
    if( SUCCEEDED( YesNoDefault( L"READONLY", 0, 0, ES_READONLY, &dwRes ) ))
        m_Style |= dwRes;

    //
    // Resize information
    //
    if( m_ResizeSet == FALSE )
    {
        m_GrowsWide=TRUE;
        if( m_Style & ES_MULTILINE )
            m_GrowsHigh=TRUE;
    }

	m_bInit=TRUE;
}


//
// Setup the drop-target and auto-complete stuff.
//
HRESULT CXMLEdit::OnInit(HWND hWnd)
{
    BASECLASS::OnInit(hWnd);
    if(m_bFile)
    {
        HMODULE hL=LoadLibrary( TEXT("Shlwapi.dll"));
        if(hL)
        {
            typedef HRESULT  (__stdcall *SHFuncPoint)(HWND hwndEdit, DWORD dwFlags);

            SHFuncPoint pFn=(SHFuncPoint)GetProcAddress( hL, "SHAutoComplete");
            if(pFn)
            {
                CoInitialize(NULL);
                HRESULT hr=pFn( hWnd, SHACF_FILESYSTEM | SHACF_AUTOAPPEND_FORCE_ON | SHACF_AUTOSUGGEST_FORCE_ON ); // SHACF_FILESYS_ONLY); // SHACF_DEFAULT );
                TRACE(TEXT("Auto complete returned 0x%08x\n"), hr );
            }

            FreeLibrary(hL);
        }
    }
    return S_OK;
}


HRESULT CXMLEdit::AcceptChild(IRCMLNode * pChild )
{
    ACCEPTCHILD( L"WIN32:EDIT", CXMLEditStyle, m_pControlStyle );
    return BASECLASS::AcceptChild(pChild);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmldlg.cpp ===
// XMLDlg.cpp: implementation of the CXMLDlg class.
//
// test files rc2xml.exe-103.xml
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "XMLDlg.h"
#include "dialogrenderer.h"
#include "dlg.h"
#include "win32Dlg.h"
#include "xmlforms.h"
#include "EnumControls.h"
#include "utils.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CXMLDlg::CXMLDlg()
{
    // What parts have we initilaized yet?
	m_bInit=FALSE;
    m_bInitLayout=FALSE;
    m_bInitStyle=FALSE;

	NODETYPE = NT_DIALOG;
    m_StringType=L"PAGE";

    // Helper classes/ 
	m_pResize=NULL;
	m_qrLayout=NULL;         // this is the XMLLAYOUT tag as a child of the LAYOUT tag
    m_pHoldingLayout=NULL;  // this is the LAYOUT tag - we need this to clean it up.
    m_qrStringTable=NULL;

	m_hGridBrush=NULL;
	m_ResizeMode=0;
	m_ClippingMode=0;

    m_bVisible=FALSE;
    m_bSpecialPainting=FALSE;
    m_hGridBrush=NULL;

    m_Font=NULL;
    m_FontSize=NULL;
    m_FontBaseMapping=0;

    //
    // Create the XML based resize information.
    //
	m_pResize=new CResizeDlg(0,0, NULL);
	m_pResize->SetXMLInfo( this );
    m_bPostProcessed=FALSE;
    m_qrFormOptions=NULL;
    m_pForm=NULL;
    m_MenuID=0;
    m_hTooltip=NULL;
}

//////////////////////////////////////////////////////////////////////////////
//
//
//
//////////////////////////////////////////////////////////////////////////////
CXMLDlg::~CXMLDlg()
{
	delete m_pResize;
    m_pHoldingLayout->Release();
    m_qrLayout=NULL;
    m_qrStringTable=NULL;
    m_qrFormOptions=NULL;

	if(m_hGridBrush)
		DeleteObject(m_hGridBrush);

  	if (m_hTooltip)
		DestroyWindow(m_hTooltip);

}

//////////////////////////////////////////////////////////////////////////////
//
// Accept Child
// most things can be added as a child.
//
//////////////////////////////////////////////////////////////////////////////
HRESULT CXMLDlg::AcceptChild(IRCMLNode * pChild )
{
    if( SUCCEEDED( pChild->IsType( L"DIALOG" )))
    {
        EVENTLOG( EVENTLOG_WARNING_TYPE, LOGCAT_CLIPPING, LOGCAT_LOADER, 0, 
            TEXT("CXMLDialog"), 
            TEXT("Dialog cannot have a <DIALOG> as a child") );
        return FALSE;
    }

    //
    // Inherits the things CXMLControl likes too, e.g. style, location etc.
    //
    if( SUCCEEDED( pChild->IsType( L"STYLE" )))
        return BASECLASS::AcceptChild(pChild);

    //  Dialogs don't have locations??
    // case NT_LOCATION:
    //    return BASECLASS::AcceptChild(pChild);
    if( SUCCEEDED( pChild->IsType( L"LAYOUT" )))    // a holding element.
    {
        m_pHoldingLayout=(CXMLLayout*)pChild;
        pChild->AddRef();
        return S_OK;
    }

    if( SUCCEEDED( pChild->IsType( L"STRINGTABLE" )))
    {
        SetStringTable( (CXMLStringTable*)pChild);
        return S_OK;
    }

    if( SUCCEEDED( pChild->IsType( L"WIN32LAYOUT" )))
    {
        SetLayout( (CXMLWin32Layout*) pChild );
        return S_OK;
    }
    if( SUCCEEDED( pChild->IsType( L"WIN32" )))
    {
        return BASECLASS::AcceptChild(pChild);
    }

    if( SUCCEEDED( pChild->IsType( L"FORMOPTIONS" )))
    {
        SetFormOptions( (CXMLFormOptions*)pChild);
        return S_OK;
    }

#if 0
    // Dont seem to need this from 7/13/2000
    //
    // An attempt to short circuit the style inheritance, can't
    // be done at graph building time.
    //
    IRCMLControl * pControl=(IRCMLControl*)pChild;
    IRCMLCSS * pControlStyle=pControl->GetCSSStyle();
    if(pControlStyle)
        pControlStyle->SetDialogStyle(this->GetCSSStyle());
#endif

    IRCMLControl * pControl;
    if( SUCCEEDED( pChild->QueryInterface( __uuidof( IRCMLControl ), (LPVOID*)&pControl )))
    {
	    GetChildren().Append( pControl );
        pControl->Release();
        return S_OK;
    }
    // what do we do with unknown children - give them to the baseclass?
    return BASECLASS::AcceptChild(pChild);
}

//////////////////////////////////////////////////////////////////////////////
//
//
//
//////////////////////////////////////////////////////////////////////////////
void CXMLDlg::InitLayout()
{
	if(m_bInitLayout)
		return;

	LPWSTR req;
	//
	// Make this resize;
	//
    if( CXMLForms * pForm = GetForm() )
    {
	    req=pForm->Get(TEXT("RESIZE"));
	    if( req )
	    {
		    m_ResizeMode=0;
		    if(lstrcmpi(req,TEXT("AUTOMATIC"))==0)
			    m_ResizeMode=1;

		    if(lstrcmpi(req,TEXT("DIRECTED"))==0)
			    m_ResizeMode=2;
	    }
        req=pForm->Get(TEXT("CLIPPING"));
        if( req )
        {
            m_ClippingMode=0;   // PREVENT

		    if(lstrcmpi(req,TEXT("ALLOW"))==0)
			    m_ClippingMode=1;   // ALLOW clipping - that is controls will be clipped.

		    if(lstrcmpi(req,TEXT("DIRECTED"))==0)
			    m_ClippingMode=2;   // some controls will be clipped, others not??
        }
    }
    m_bInitLayout=TRUE;
}

//
// We implement this because as the dialog, we're special.
//
HRESULT CXMLDlg::get_CSS(IRCMLCSS ** pVal )
{
	//
	// REVIEW - this should remain null, and take it's information from the above settings
	//
    HRESULT hres;
    if( SUCCEEDED( hres=BASECLASS::get_CSS( pVal )))
        return hres;
    // we have no STYLE element defined in the RCML - see if there is one
    // on the layout ovject we can use.
    IRCMLCSS * pLayoutStyle=NULL;
    if ( CXMLWin32Layout* pLayout=GetLayout() )
    {
        pLayoutStyle=pLayout->GetCSSStyle();
    }
    if( pLayoutStyle == NULL )
    {
        pLayoutStyle=new CXMLStyle();
    }
    put_CSS(pLayoutStyle);


    // Ensure that we inheirt the correct LAYOUT\STYLE attributes, and default those not specified.
    // NOTE we COULD be changing the LAYOUT\STYLE attributes THEMSELVES - is this bad?
    LPWSTR req;
    if( SUCCEEDED( pLayoutStyle->get_Attr( L"FONT-FAMILY", &req )))
    {
	    m_Font=req;
    }
    else
    {
        m_Font=L"MS Shell Dlg";
        pLayoutStyle->put_Attr( L"FONT-FAMILY", m_Font );
    }

    m_FontSize=8;
    pLayoutStyle->ValueOf( L"FONT-SIZE", m_FontSize, &m_FontSize );
    TCHAR szSize[10];wsprintf(szSize,TEXT("%8d"),m_FontSize?m_FontSize:8);
    pLayoutStyle->put_Attr( L"FONT-SIZE", szSize );

    *pVal=pLayoutStyle;
    return S_OK;
}

//
// The style object for the dialog is now 'buried' in the LAYOUT\XYLAYOUT\STYLE element.
//
void CXMLDlg::InitStyle()
{
    IRCMLCSS * pCSS;    // this could be VERY bad?? If we parse the tree wrong.
    get_CSS(&pCSS);
    m_bInitStyle=TRUE;
}


//
// Walks the nodes, and attempts to resolve relationships RELATIVE="YES" RELATIVE="<ID>"
//
void CXMLDlg::BuildRelationships()
{
	if( m_bPostProcessed )
		return ;

    LPWSTR res;
	IRCMLControl * pControl=NULL;
	IRCMLControl * pLastControl=NULL;
	int controlCount = m_Children.GetCount();
	for( int i=0;i<controlCount;i++)
	{
		pControl = m_Children.GetPointer(i);
        RELATIVETYPE_ENUM relType;
        if( SUCCEEDED( pControl->get_RelativeType( &relType )))
        {
		    switch(relType)
            { 
            case CXMLLocation::RELATIVE_TO_NOTHING:
                pControl->put_RelativeTo(NULL);
            break;

           case CXMLLocation::RELATIVE_TO_CONTROL:
                if( SUCCEEDED( pControl->get_RelativeID( &res )))
                {
				    pControl->put_RelativeTo( FindControlID(res));
                    break;
                }
			    // break; <<-- NOTE NOTE NOTE - if we don't find the thing you wanted to be
                // relative to, we'll just go for the last guy.
            case CXMLLocation::RELATIVE_TO_PREVIOUS:
				pControl->put_RelativeTo(pLastControl);
            break;
            case CXMLLocation::RELATIVE_TO_PAGE:
                pControl->put_RelativeTo(this);
            break;
            }
		}
		pLastControl=pControl;
	}

    //
    // Now init the Resize information.
    //
    if( m_pResize )
    {
        CParentInfo & pi = m_pResize->GetParentInfo();
	    for( i=0;i<controlCount;i++)
        {
            // REVIEW BUGBBUG - how to call the controls to do their resize goo?
            // IRCMLControl * pcn=m_Children.GetPointer(i); // WARNING
            // ((CXMLControl*)pcn)->InitResizeInformation(pi);
        }
    }
    m_bPostProcessed=TRUE;
}

//
// Walks all the children (IRCMLControl *) and finds the named one.
//
IRCMLControl * CXMLDlg::FindControlID(LPCWSTR pIDName)
{
	IRCMLControl * pControl=NULL;
    LPWSTR res;
	int controlCount = m_Children.GetCount();
	for( int i=0;i<controlCount;i++)
	{
		pControl = m_Children.GetPointer(i);
        if( SUCCEEDED( pControl->get_ID( &res )))
        {
            // attempting to compare names against names
            // or strings against strings or uints.

            // both strings.
            if( HIWORD(pIDName) && HIWORD(res) && (lstrcmpi(pIDName, res)==0) )
    			return pControl;

            // both uints.
		    if(!HIWORD(pIDName) && !HIWORD(res) )
            {
                if( LOWORD(pIDName) == LOWORD(res) )
			        return pControl;
            }

		    if(HIWORD(pIDName) && !HIWORD(res) )
            {
                WORD wID = StringToIntDef( pIDName, 0 );
                if( wID == LOWORD(res ) )
			        return pControl;
            }

        }
	}
	return NULL;
}


//////////////////////////////////////////////////////////////////////////////
//
//
//
//////////////////////////////////////////////////////////////////////////////
#undef PROPERTY
#define PROPERTY(p,id, def) m_Style |= pNode->YesNo( id , def )?p:0;
void CXMLDlg::Init()
{
	if(m_bInit)
		return;
	BASECLASS::Init();

    m_Style = 0; // Dialog does it's own style processing. StyleEX is still done by control.

	//
	//
	LPWSTR req;

    DWORD iTemp;
    ValueOf( L"ID", 0, &iTemp );
    if( iTemp!=0 )
        m_ID = (LPWSTR)iTemp;
    else
        get_Attr( L"ID", &m_ID);

    ValueOf( L"WIDTH", 100, (ULONG*)&m_Width );
    
    ValueOf( L"HEIGHT", 100, (ULONG*)&m_Height  );

    InitStyle();
    InitLayout();

	if(m_ResizeMode)
		m_Style |= WS_SIZEBOX;	// style bits for resize frame.

    //
    // Dialogs differ from controls here!
    // ResFile.cpp CResFile::DumpDialogStyles
    // 
    if( CXMLWin32 * pNode = m_qrWin32Style.GetInterface() )
    {
        // m_Style=0 - any styles already set need to remain set??
        PROPERTY( WS_POPUP           , TEXT("POPUP") ,             TRUE );     // POPUP
        PROPERTY( WS_CHILD           , TEXT("CHILD") ,             FALSE );
        PROPERTY( WS_MINIMIZE        , TEXT("MAXIMIZEBUTTON") ,    FALSE );
    //    PROPERTY( WS_VISIBLE         , TEXT("VISIBLE") ,           TRUE );     // VISIBLE - CARE?

    //    PROPERTY( WS_DISABLED        , TEXT("DISABLED") ,          FALSE );
        PROPERTY( WS_CLIPSIBLINGS    , TEXT("CLIPSIBLINGS") ,      FALSE );
        PROPERTY( WS_CLIPCHILDREN    , TEXT("CLIPCHILDREN") ,      FALSE );

        PROPERTY( WS_BORDER          , TEXT("BORDER") ,            TRUE );     // BORDER
        PROPERTY( WS_DLGFRAME        , TEXT("DLGFRAME") ,          TRUE );     // DLGFRAME
        PROPERTY( WS_VSCROLL         , TEXT("VSCROLL") ,           FALSE );
        PROPERTY( WS_HSCROLL         , TEXT("HSCROLL") ,           FALSE );

        PROPERTY( WS_SYSMENU         , TEXT("SYSMENU"),            TRUE );     // most dialogs have this.
        PROPERTY( WS_THICKFRAME      , TEXT("THICKFRAME") ,        FALSE );

        PROPERTY( WS_MINIMIZEBOX     , TEXT("MINIMIZEBOX") ,       FALSE );
        PROPERTY( WS_MAXIMIZEBOX     , TEXT("MAXIMIZEBOX") ,       FALSE );
    }
    else
    {
        // Not all RCLM files have WIN32:STYLE as a child of FORM, because of defaults.
        m_Style |= WS_POPUP | WS_BORDER | WS_DLGFRAME | WS_SYSMENU ; 
    }

    //
    // TEXT attribute can be on the FORM itself
    // or on the CAPTION child.
    //

    //
    // The FORM contains the diaog style.
    //
    BOOL bFormOptionsGot=FALSE;
    if( CXMLForms * pForm = GetForm() )
    {
        if( CXMLFormOptions * pFO=pForm->GetFormOptions() )
        {
            m_Style |= pFO->GetDialogStyle() ;
            // m_Style &= ~ WS_CHILD; -- this is OK
            bFormOptionsGot=TRUE;
        }

        CXMLCaption * pCaption= pForm->GetCaption();
        if(pCaption)
        {
            m_Style |= pCaption->GetStyle();   // min/max/close etc.
    	    if( (m_Text==NULL) || (lstrcmpi(m_Text,L"")==0) )
                m_Text=pCaption->GetText();
        }
    }

    if( bFormOptionsGot==FALSE )
        m_Style |= CXMLFormOptions::GetDefaultDialogStyle();
        

    //
    // WIN32:DIALOGSTYLE contains MENUID and CLASS for the dialog.
    //
    if( CXMLFormOptions * pFO=GetFormOptions() )
    {
        m_Style |= pFO->GetDialogStyle() ;
        // m_Style &= ~ WS_CHILD; -- is this OK?

        pFO->ValueOf( L"MENUID", 0, (ULONG*)&m_MenuID );
        if( SUCCEEDED( get_Attr(L"TEXT", &req )))
        {
    	    if( (m_Text==NULL) || (lstrcmpi(m_Text,L"")==0) )
               m_Class=req;
        }
    }

    //
    // Now check to see if we are clipped at all.
    // How can we do this before we have our style object?
    //
    SIZE adjustSize=m_pResize->GetAdjustedSize();
    adjustSize=GetDLUSize(adjustSize);    
    TRACE(TEXT("We're clipped DLU    : %d by %d\n"), adjustSize.cx, adjustSize.cy);

    m_Width += adjustSize.cx;
    m_Height += adjustSize.cy;

	m_bInit=TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
//
//
//////////////////////////////////////////////////////////////////////////////
HRESULT CXMLDlg::OnInit(HWND h)
{
	m_hWnd=h;
    m_bVisible=TRUE;

    m_pResize->SetWindow(h);
   	m_pResize->DlgProc( h, WM_INITDIALOG, 0, 0);

    if( CXMLForms * pForm = GetForm() )
    {
        if( CXMLCaption * pCaption= pForm->GetCaption() )
        {
            //
            // Set the ICON for the dialog/form frame if there is one.
            //
            HINSTANCE hInst=(HINSTANCE)GetWindowLong( h, GWL_HINSTANCE );
            // SM_CXICON and SM_CYICON used for width and height for DEFAULTSIZE ??
            if( HICON icon=(HICON)LoadImage( hInst, pCaption->GetIconID(), IMAGE_ICON, 0, 0, LR_DEFAULTCOLOR | LR_DEFAULTSIZE | LR_SHARED )  )
                SendMessage( h, WM_SETICON, ICON_BIG, (LPARAM)icon );
        }
    }

    //
    // External File Warning
    //
    if( GetExternalFileWarning() )
        CWin32Dlg::ShowBalloonTip( h, TEXT("This is being generated from an external file")); 

	//
	//
	//
	SetSpecialPainting(FALSE);
	if( GetLayout() !=NULL)
	{
		CXMLGrid * pGrid=GetLayout()->GetGrid();
		if(pGrid!=NULL)
			SetSpecialPainting( pGrid->GetDisplay() );

		if( IsSpecialPainting() )
		{
			int width=pGrid->GetX();
			int height=pGrid->GetY();

            SIZE gridSize;
            gridSize.cx=width;
            gridSize.cy=height;
            gridSize=GetPixelSize(gridSize);
            width=gridSize.cx;
            height=gridSize.cy;

			HDC hDC=GetDC( GetWindow() );
			HDC hdcb=CreateCompatibleDC( hDC );

			HBITMAP hbm  = CreateCompatibleBitmap( hDC, 2* width, 2*height );

			HANDLE hCrap=SelectObject( hdcb, hbm );
			PaintBrush( hdcb, width, height );

			m_hGridBrush = CreatePatternBrush( hbm );

			SelectObject( hdcb, hCrap );

			DeleteObject(hbm);

			if( m_hGridBrush==NULL )
				TRACE(TEXT("Failed 0x%08x\n"), GetLastError() );
			DeleteDC(hdcb);
			ReleaseDC( GetWindow(), hDC );
		}
	}
	DoAlphaGrid();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
//
//
//////////////////////////////////////////////////////////////////////////////
void CXMLDlg::PaintBrush(HDC hdcb, int width, int height)
{
	//
	// Paint the stuff in the bitmap now.
	//
	RECT rect;

	rect.left=0; rect.right=rect.left+width*2;
	rect.top=0; rect.bottom=rect.top+height*2;
	FillRect( hdcb, &rect, (HBRUSH) (COLOR_WINDOW+0) );

	rect.left=width; rect.right=rect.left+width;
	rect.top=0; rect.bottom=rect.top+height;
	FillRect( hdcb, &rect, (HBRUSH) (COLOR_WINDOW+1) );

	rect.left=0; rect.right=rect.left+width;
	rect.top=height; rect.bottom=rect.top+height;
	FillRect( hdcb, &rect, (HBRUSH) (COLOR_WINDOW+1) );
}

//////////////////////////////////////////////////////////////////////////////
//
//
//
//////////////////////////////////////////////////////////////////////////////
BOOL CALLBACK CXMLDlg::DlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
	switch( uMessage )
	{
	case WM_PAINT:
	// case WM_ERASEBKGND:
		if(IsSpecialPainting() )
			DoPaint( (HDC)wParam );
		break;
	}
	
	if(m_pResize)
		return m_pResize->DlgProc( hDlg, uMessage, wParam, lParam);

	return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
//
//
//
//////////////////////////////////////////////////////////////////////////////
void CXMLDlg::DoPaint(HDC hDC)
{
	//
	// We should probably cache this.
	//

	BOOL bRelease=FALSE;
	if( hDC==NULL )
	{
		hDC=GetDC( GetWindow() );
		bRelease=TRUE;
	}

	if( m_hGridBrush )
	{
		RECT clientRect;
		GetClientRect( GetWindow(), &clientRect );

		FillRect( hDC, &clientRect, m_hGridBrush );

	}

	if( bRelease )
		ReleaseDC( GetWindow(), hDC );
}

//////////////////////////////////////////////////////////////////////////////
//
//
//
//////////////////////////////////////////////////////////////////////////////
void CXMLDlg::DoAlphaGrid()
{
	//
	// We should probably cache this.
	//
    if( GetLayout() )
    {
	    CXMLGrid * pGrid=GetLayout()->GetGrid();
	    if(pGrid==NULL)
		    return;
	    if(pGrid->GetDisplay() == FALSE)
		    return;
    }
	// Register the window class
	// Create the window
}

void CXMLDlg::GetFontMapping()
{
    if( m_FontBaseMapping==0 )
    {
	    IRCMLCSS *	pxmlStyle;
        if( SUCCEEDED( get_CSS( &pxmlStyle )))
        {
            HFONT hf;

            if( SUCCEEDED( pxmlStyle->get_Font(&hf)))
            {
                HDC hdc = ::GetDC(NULL);		// VadimG says this is OK
                m_FontBaseMapping = CQuickFont::GetDialogBaseUnits( hdc, hf );   
           		ReleaseDC(NULL, hdc);
            }
            pxmlStyle->Release();
        }
    }
}

HRESULT     CXMLDlg::GetPixelLocation( 
            IRCMLControl __RPC_FAR * pControl,
            RECT *pRect)
{
    RECT r=GetPixelLocation(pControl);
    if( pRect )
    {
        CopyMemory( pRect, &r, sizeof(r));
        return S_OK;
    }
    return E_INVALIDARG;
}

////////////////////////////////////////////////////////////////////////////
//
// Uses the dialogs mapping system (DLU or pure pixel) to
// return the location of the control.
//
////////////////////////////////////////////////////////////////////////////
RECT CXMLDlg::GetPixelLocation( IRCMLControl * pControl )
{
    GetFontMapping();
    RECT curLocation;
    pControl->get_Location(&curLocation) ;    // the units in the XML file.

    BOOL bNeedsConvertion=TRUE;
    if(GetLayout() )
    {
        if( GetLayout()->GetUnits() == CXMLWin32Layout::UNIT_PIXEL )
            bNeedsConvertion=FALSE;
    }

    RECT reqPixelSize;
    if( bNeedsConvertion )
    {
        SIZE topleft;
        topleft.cx=curLocation.left;
        topleft.cy=curLocation.top;
        topleft=CQuickFont::GetPixelsFromDlgUnits(topleft, m_FontBaseMapping);

        SIZE bottomright;
        bottomright.cx=curLocation.right;
        bottomright.cy=curLocation.bottom;
        bottomright=CQuickFont::GetPixelsFromDlgUnits(bottomright, m_FontBaseMapping);

        reqPixelSize.left=topleft.cx;
        reqPixelSize.top=topleft.cy;

        reqPixelSize.right=bottomright.cx;
        reqPixelSize.bottom=bottomright.cy;
    }
    else
        reqPixelSize=curLocation;

    //
    // Now apply and scaling metrics.
    //
	CXMLWin32Layout * pLayout=GetLayout();
    if(pLayout==NULL)
        return reqPixelSize;

	CXMLGrid * pGrid=pLayout->GetGrid();

    if(pGrid==NULL)
        return reqPixelSize;

	if(pGrid->GetMap())
	{
		DWORD XScale=pGrid->GetX();
		DWORD YScale=pGrid->GetY();
        reqPixelSize.right*=XScale;
        reqPixelSize.left*=XScale;
        reqPixelSize.top*=YScale;
        reqPixelSize.bottom*=YScale;
	}
    return reqPixelSize;
}

////////////////////////////////////////////////////////////////////////////
//
// Maps a RCML unit into a PixelSize.
//
////////////////////////////////////////////////////////////////////////////
SIZE CXMLDlg::GetPixelSize( SIZE s)
{
    GetFontMapping();
    return CQuickFont::GetPixelsFromDlgUnits(s, m_FontBaseMapping);
}

////////////////////////////////////////////////////////////////////////////
//
// Maps a pixel to DLU - we do actually use DLU here as this is used in the
// dialog template for user.
//
////////////////////////////////////////////////////////////////////////////
SIZE CXMLDlg::GetDLUSize( SIZE s )
{
    GetFontMapping();
    return CQuickFont::GetDlgUnitsFromPixels(s, m_FontBaseMapping);
}


HWND CXMLDlg::GetTooltipWindow()
{
    if(m_hTooltip==NULL)
    {
        CXMLDlg::InitComctl32(ICC_TREEVIEW_CLASSES);
		m_hTooltip = CreateWindowEx(0, TOOLTIPS_CLASS, (LPTSTR) NULL, 
			WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP,
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, 
			CW_USEDEFAULT, NULL, (HMENU) NULL, NULL, NULL); 
		if (m_hTooltip == NULL) 
        {
			TRACE(TEXT("Can't create tooltip window"));
        }
        else
        {
            SetWindowPos(m_hTooltip,
                HWND_TOPMOST,
                0,
                0,
                0,
                0,
                SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
        }

	}
    return m_hTooltip;
}


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
void CXMLDlg::InitComctl32(DWORD dwFlags)
{
	static INITCOMMONCONTROLSEX c;

	if( dwFlags & c.dwICC )
		return;
	c.dwSize	= sizeof(INITCOMMONCONTROLSEX);
	c.dwICC		|= dwFlags;
	if (!InitCommonControlsEx(&c))
	{
		TRACE(TEXT("Can't init common controls."));
		return;
	}
}

HRESULT STDMETHODCALLTYPE CXMLDlg::GetChildEnum( 
    IEnumUnknown __RPC_FAR *__RPC_FAR *pEnum)
{
    if( pEnum )
    {
        *pEnum = new CEnumControls<IRCMLControlList>( GetChildren() );
        (*pEnum)->AddRef();
        return S_OK;
    }
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlformoptions.h ===
// XMLFormOptions.h: interface for the CXMLFormOptions class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XMLFORMOPTIONS_H__3BD1B835_0E09_4E34_9117_03663AFC6C83__INCLUDED_)
#define AFX_XMLFORMOPTIONS_H__3BD1B835_0E09_4E34_9117_03663AFC6C83__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "xmlnode.h"
// #undef PROPERTY
#define PROPERTY( type, id ) type Get##id() { Init(); return m_##id; }

class CXMLFormOptions : public _XMLNode<IRCMLNode>    
{
public:
	CXMLFormOptions();
	virtual ~CXMLFormOptions();

	typedef _XMLNode<IRCMLNode> BASECLASS;
    IMPLEMENTS_RCMLNODE_UNKNOWN;
	XML_CREATE( FormOptions );

	PROPERTY(UINT, DialogStyle);
    static UINT GetDefaultDialogStyle();

private:
	void    Init();
    union
    {
        WORD        m_DialogStyle;
        struct
        {
            BOOL    m_AbsAlign:1;      // 1
            BOOL    m_SysModal:1;        // 2
            BOOL    m_3DLook:1;   // 4
            BOOL    m_FixedSys:1;      // 8

            BOOL    m_NoFailCreate:1;      // 1
            BOOL    m_LocalEdit:1;      // 2
            BOOL    m_SetFont:1;     // 4
            BOOL    m_ModalFrame:1;       // 8

            BOOL    m_NoIdleMessgae:1;     // 1
            BOOL    m_SetForeground:1; // 2
            BOOL    m_Control:1; // 4
            BOOL    m_Center:1;     // 8

            BOOL    m_CenterMouse:1;      // 1
            BOOL    m_ContextHelp:1; // 2
            BOOL    m_unknown1:1;        // 4
            BOOL    m_unknown2:1;        // 8
        };
    };
};

#endif // !defined(AFX_XMLFORMOPTIONS_H__3BD1B835_0E09_4E34_9117_03663AFC6C83__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlforms.cpp ===
// XMLForms.cpp: implementation of the CXMLForms class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "XMLForms.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CXMLForms::CXMLForms()
{
  	NODETYPE = NT_FORMS;
    m_StringType=TEXT("FORM");      // although we call it forms, it really FORM
    m_pFormOptions=NULL;
    m_pCaption=NULL;
}

CXMLForms::~CXMLForms()
{
    if(m_pFormOptions)
        m_pFormOptions->Release();
    if(m_pCaption)
    {
        m_pCaption->Release();
        // m_pCaption=NULL;
    }
}

void CXMLForms::Init()
{
}

HRESULT CXMLForms::AcceptChild(IRCMLNode * pChild )
{
    if( SUCCEEDED( pChild->IsType(L"DIALOG") ) ||
        SUCCEEDED( pChild->IsType(L"PAGE") ) )
    {
        CXMLDlg* pDlg=(CXMLDlg*)pChild;
        pDlg->SetForm(this);
        AppendDialog(pDlg);
        return S_OK;
    }

    ACCEPTCHILD( L"FORMOPTIONS", CXMLFormOptions, m_pFormOptions );
    ACCEPTCHILD( L"CAPTION", CXMLCaption, m_pCaption );

    //
    // For those people who add extra goo to us.
    //
    return BASECLASS::AcceptChild(pChild);
}


CXMLDlg * CXMLForms::GetDialog(int index)
{ 
    CXMLDlg * pDlg= m_DialogList.GetPointer(index); 
    if(pDlg!=NULL)
    {
        pDlg->BuildRelationships();
    }
    else
    {
        // EVENT_LOG goes here.
    }
    return pDlg;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlhelp.h ===
// XMLHelp.h: interface for the CXMLHelp class.
//
// Contains all the elements for the HELP node (TOOLTIP BALLOONTIP HELP)
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XMLHELP_H__4EF48731_FAE7_424A_91EB_C3ED5FF9FDF0__INCLUDED_)
#define AFX_XMLHELP_H__4EF48731_FAE7_424A_91EB_C3ED5FF9FDF0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "xmlnode.h"
#include "xmldlg.h"

class CXMLDlg;  // for the hTooltip window.

class CXMLBalloon : public _XMLNode<IRCMLNode>  
{
public:
	CXMLBalloon();
	virtual ~CXMLBalloon();
	XML_CREATE( Balloon );
    IMPLEMENTS_RCMLNODE_UNKNOWN;
	typedef _XMLNode<IRCMLNode> BASECLASS;

	LPCTSTR GetBalloon() { Init(); return m_Balloon; }

protected:
	void		Init();
	LPCTSTR	    m_Balloon;
};

class CXMLTooltip : public _XMLNode<IRCMLNode>  
{
public:
	BOOL AddTooltip( CXMLDlg * pDlg, HWND hWnd);
	CXMLTooltip();
	virtual ~CXMLTooltip();
	typedef _XMLNode<IRCMLNode> BASECLASS;
	XML_CREATE( Tooltip );

	LPCTSTR GetTooltip() { Init(); return m_Tooltip; }

    IMPLEMENTS_RCMLNODE_UNKNOWN;
    static HRESULT AddTooltip(IRCMLHelp * pHelp, CXMLDlg * pDlg );

protected:
	void		Init();
	LPCTSTR	    m_Tooltip;
};

class CXMLHelp : public _XMLNode<IRCMLHelp>
{
public:
	CXMLHelp();
	virtual ~CXMLHelp();
	typedef _XMLNode<IRCMLHelp> BASECLASS;
	XML_CREATE( Help );
    IMPLEMENTS_RCMLNODE_UNKNOWN;

	CXMLTooltip * GetTooltip() { return m_Tooltip; }
	LPCTSTR GetTooltipString() { Init(); if(m_Tooltip) return m_Tooltip->GetTooltip(); return NULL; }
	LPCTSTR GetBalloonString() { Init(); if(m_Balloon) return m_Balloon->GetBalloon(); return NULL; }
	// LPCTSTR GetContextString() { Init(); return m_Context; }
	PROPERTY( UINT, ContextID );


    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptChild( 
        IRCMLNode __RPC_FAR *child);

    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE get_TooltipText( 
        LPWSTR __RPC_FAR *pVal);
    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE get_BalloonText( 
        LPWSTR __RPC_FAR *pVal);


protected:
	void		Init();
    DWORD           m_ContextID;    // the ID for the context help.
    CXMLBalloon *   m_Balloon;      //
    CXMLTooltip *   m_Tooltip;      //
    BOOL            m_bInit;
};

#endif // !defined(AFX_XMLHELP_H__4EF48731_FAE7_424A_91EB_C3ED5FF9FDF0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlforms.h ===
// XMLForms.h: interface for the CXMLForms class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XMLFORMS_H__AE485127_B844_43CF_BB30_8A7577A97A3F__INCLUDED_)
#define AFX_XMLFORMS_H__AE485127_B844_43CF_BB30_8A7577A97A3F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "xmlnode.h"
#include "xmldlg.h" // CXMLDlg is synonymous with PAGE
#include "xmlcaption.h"

//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
//
// For 'legacy' coding reasons, this is the <FORM> element.
// it contains a bunch of <PAGE> elements (CXMLDlg).
//
// Has 'high level' attributes, RESIZE and CLIPPING is here.
//
class CXMLForms : public _XMLNode<IRCMLNode>  
{
public:
	CXMLForms();
	virtual ~CXMLForms();

	typedef _XMLNode<IRCMLNode>   BASECLASS;
   	XML_CREATE( Forms );
    IMPLEMENTS_RCMLNODE_UNKNOWN;

    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptChild( 
        IRCMLNode __RPC_FAR *child);

    BOOL                AppendDialog( CXMLDlg * pDialog) { return m_DialogList.Append(pDialog); }
    CXMLDlg *           GetDialog(int index);
    //
    // This is the Win32 specific nature of the form (sheet)
    //
    CXMLFormOptions *   GetFormOptions() { return m_pFormOptions; }
    void                SetFormOptions( CXMLFormOptions * st ) { m_pFormOptions = st; }
    CXMLCaption *       GetCaption() { return m_pCaption; }
    LPCTSTR             GetCaptionText() { return Get(TEXT("TEXT")); }

#ifdef _DEBUG
     virtual ULONG STDMETHODCALLTYPE Release( void)
     {
         if(_refcount)
         {
             int i=5;
         }

         return BASECLASS::Release();
     }
#endif

protected:
	void Init();
    CXMLDlgList m_DialogList;
    CXMLFormOptions * m_pFormOptions;
    CXMLCaption * m_pCaption;
};

typedef _RefcountList<CXMLForms> CXMLFormsList;

#endif // !defined(AFX_XMLFORMS_H__AE485127_B844_43CF_BB30_8A7577A97A3F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlhelp.cpp ===
// XMLHelp.cpp: implementation of the CXMLHelp class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "XMLHelp.h"
#include "xmldlg.h"


// CXMLHelp class
//
//////////////////////////////////////////////////////////////////////

CXMLHelp::CXMLHelp()
{
	m_bInit=FALSE;
	NODETYPE = NT_HELP;
    m_StringType=L"HELP";
	m_Tooltip = NULL;
    m_Balloon = NULL;
    // m_Context = NULL;
}

CXMLHelp::~CXMLHelp()
{
    delete m_Tooltip;
    delete m_Balloon;
}


void CXMLHelp::Init()
{
	if(m_bInit)
		return;
    BASECLASS::Init();

    ValueOf(L"CONTEXTID",0, &m_ContextID);

	m_bInit=TRUE;
}

HRESULT CXMLHelp::AcceptChild(IRCMLNode * pChild )
{
    ACCEPTCHILD( L"BALLOON", CXMLBalloon, m_Balloon );
    ACCEPTCHILD( L"TOOLTIP", CXMLTooltip, m_Tooltip );
    return BASECLASS::AcceptChild(pChild);
}


HRESULT CXMLHelp::get_TooltipText( 
        LPWSTR __RPC_FAR *pVal)
{
    HRESULT hr=E_INVALIDARG;
    if(m_Tooltip)
    {
        *pVal=(LPWSTR)GetTooltipString();
        hr=S_OK;
    }
    return hr;
}

HRESULT CXMLHelp::get_BalloonText( 
        LPWSTR __RPC_FAR *pVal)
{
    HRESULT hr=E_INVALIDARG;
    if(m_Balloon)
    {
        *pVal=(LPWSTR)GetBalloonString();
        hr=S_OK;
    }
    return hr;
}



// CXMLBalloon class
//
//////////////////////////////////////////////////////////////////////

CXMLBalloon::CXMLBalloon()
{
	m_bInit=FALSE;
	NODETYPE = NT_BALLOON;
    m_StringType=L"BALLOON";
	m_Balloon = NULL;
}

CXMLBalloon::~CXMLBalloon()
{
}


void CXMLBalloon::Init()
{
	if(m_bInit)
		return;
	BASECLASS::Init();

	m_Balloon = Get(TEXT("TEXT"));

	m_bInit=TRUE;
}

// CXMLTooltip class
//
//////////////////////////////////////////////////////////////////////

CXMLTooltip::CXMLTooltip()
{
	m_bInit=FALSE;
	NODETYPE = NT_TOOLTIP;
    m_StringType=TEXT("TOOLTIP");
	m_Tooltip = NULL;
}

CXMLTooltip::~CXMLTooltip()
{
}


void CXMLTooltip::Init()
{
	if(m_bInit)
		return;
	BASECLASS::Init();

	m_Tooltip = Get(TEXT("TEXT"));

	m_bInit=TRUE;
}

//
// This is kind of strange as it requires the TOOLTIP knowing about the DIALOG.
//
BOOL CXMLTooltip::AddTooltip(CXMLDlg *pDlg, HWND hWnd)
{
    HWND hWndTooltip = pDlg->GetTooltipWindow();
    if( hWndTooltip )
    {
	    TOOLINFO ti;
	    ti.cbSize = sizeof(TOOLINFO); 
	    ti.uFlags = TTF_IDISHWND | TTF_SUBCLASS; 
	    ti.hwnd = 0;
	    ti.uId = (UINT) hWnd; 
	    ti.hinst = 0; 
	    ti.lpszText = (LPTSTR)(GetTooltip()); 
	    SendMessage(hWndTooltip, TTM_ADDTOOL, 0, (LPARAM)&ti);
        return TRUE;
    }
    return FALSE;
}

//
// This is kind of strange as it requires the TOOLTIP knowing about the DIALOG.
//
HRESULT CXMLTooltip::AddTooltip(IRCMLHelp * pHelp, CXMLDlg *pDlg)
{
    HRESULT hr=S_OK;
    HWND hWndTooltip = pDlg->GetTooltipWindow();

    IRCMLNode * pNode;
    if( SUCCEEDED( pHelp->DetachParent( &pNode )))
    {
        IRCMLControl * pControl;
        if( SUCCEEDED( pNode->QueryInterface( __uuidof( IRCMLControl ) , (LPVOID*)&pControl )))
        {
            HWND hWndTool;
            if( SUCCEEDED( pControl->get_Window( &hWndTool )))
            {
                HWND hWnd;
                if( SUCCEEDED( pDlg->get_Window(&hWnd) ) && hWndTooltip )
                {
                    TOOLINFO ti={0};
	                ti.cbSize = sizeof(TOOLINFO); 
                    if( SUCCEEDED( hr=pHelp->get_TooltipText( &ti.lpszText)))
                    {
	                    ti.uFlags = TTF_IDISHWND | TTF_SUBCLASS ; 
	                    ti.hwnd = hWnd;
	                    ti.uId = (UINT) hWndTool;   // the tool window
    	                SendMessage(hWndTooltip, TTM_ADDTOOL, 0, (LPARAM)&ti);
                    }
                }
            }
            pControl->Release();
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlimage.cpp ===
// XMLImage.cpp: implementation of the CXMLImage class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "XMLImage.h"
#include "image.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CXMLImage::CXMLImage()
{
	m_bInit=FALSE;
    NODETYPE = NT_IMAGE;
    m_StringType=L"IMAGE";
	image.m_pBitmap = NULL;
	m_pFileName = NULL;
	bDelayPaint	= TRUE;
    m_pControlStyle=FALSE;
    m_imageType=STATICCONTROL;
}

CXMLImage::~CXMLImage()
{
/* // no need to destory the window: it will get WM_CLOSE and destroy itself 
	if(m_imageType == MCI)
		MCIWndDestroy(image.hwndMCIWindow);
	else 
*/
	if (m_imageType == GDIPLUS)
		delete image.m_pBitmap;
}

void CXMLImage::Init()
{
	if(m_bInit)
		return;
	BASECLASS::Init();

	LPWSTR req;
	m_Class=m_Class?m_Class:TEXT("IMAGE");

    m_imageType = GDIPLUS;
	req=Get(TEXT("CONTENT"));
    if( req == NULL )
    {
        m_Class=(LPWSTR)0x82;   // static
        DWORD dwVal;
        if( SUCCEEDED( ValueOf( L"IMAGEID", 0, &dwVal )))
            m_Text=(LPWSTR)dwVal;    // text is now a DWORD ID.
        else
            get_Attr( L"IMAGEID", &m_Text );
        m_imageType = STATICCONTROL;
    }
	else if(lstrcmpi( req, TEXT("MOVIE")) == 0)
    {
		m_imageType = MCI;  // what's the wndclass for this?
    }
	else if(lstrcmpi( req, TEXT("ANIMATION")) == 0)
    {
		m_imageType = ANIMATE_CONTROL;  // what's the window class for this?
        m_Class=ANIMATE_CLASS;
    }
	else if(lstrcmpi( req, TEXT("PICTURE")) == 0)
    {
		m_imageType = GDIPLUS;
    }
    else if( lstrcmpi( req, TEXT("ICON"))==0 )
    {
        m_Style |= SS_ICON;
        m_Class=(LPWSTR)0x82;   // static
        DWORD dwVal;
        if( SUCCEEDED( ValueOf( L"IMAGEID", 0, &dwVal )))
            m_Text=(LPWSTR)dwVal;    // text is now a DWORD ID.
        else
            get_Attr( L"IMAGEID", &m_Text );
        m_imageType = STATICCONTROL;
    }
    else if( lstrcmpi( req, TEXT("BITMAP"))==0 )
    {
        m_Style |= SS_BITMAP;
        m_Class=(LPWSTR)0x82;   // static
        DWORD dwVal;
        if( SUCCEEDED( ValueOf( L"IMAGEID", 0, &dwVal )))
            m_Text=(LPWSTR)dwVal;    // text is now a DWORD ID.
        else
            get_Attr( L"IMAGEID", &m_Text );
        m_imageType = STATICCONTROL;
    }
    else if( lstrcmpi( req, TEXT("VECTOR"))==0 )
    {
        m_Style |= SS_ENHMETAFILE;
        m_Class=(LPWSTR)0x82;   // static
        DWORD dwVal;
        if( SUCCEEDED( ValueOf( L"IMAGEID", 0, &dwVal )))
            m_Text=(LPWSTR)dwVal;    // text is now a DWORD ID.
        else
            get_Attr( L"IMAGEID", &m_Text );
        m_imageType = STATICCONTROL;
    }

    switch (m_imageType )
    {
        case ANIMATE_CONTROL:
            if( m_pControlStyle )
                m_Style |= m_pControlStyle->GetBaseAnimationStyles();
            DWORD dwYN;
            if( SUCCEEDED( YesNoDefault( L"CENTER", 0, 0, ACS_CENTER , &dwYN )))
                m_Style |= dwYN;
            if( SUCCEEDED( YesNoDefault( L"TRANSPARENT", 0, 0, ACS_TRANSPARENT , &dwYN )))
                m_Style |= dwYN;
            if( SUCCEEDED( YesNoDefault( L"AUTOPLAY", 0, 0, ACS_AUTOPLAY , &dwYN )))
                m_Style |= dwYN;
            break;
        case GDIPLUS:
            break;
        default:
            if( m_pControlStyle )
            {
                m_Style |= m_pControlStyle->GetBaseStyles();
            }
            else
                m_Style |= 0; // statics don't have any defaults.
            break;
    }

    CImage::Init();

	get_Attr( L"FILE", & m_pFileName );

	m_bInit=TRUE;
}


HRESULT CXMLImage::AcceptChild(IRCMLNode * pChild )
{
    ACCEPTCHILD( L"STATICSTYLE", CXMLStaticStyle, m_pControlStyle );
    return BASECLASS::AcceptChild(pChild);
}

HRESULT CXMLImage::OnInit(HWND hWnd )
{
    BASECLASS::OnInit(hWnd);
    switch( m_imageType )
    {
    case ANIMATE_CONTROL:
        {
            if( m_pFileName )
                Animate_Open( hWnd, m_pFileName );
        }
        break;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlimage.h ===
// XMLImage.h: interface for the CXMLImage class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XMLIMAGE_H__CE04F4A2_2AA3_4933_8BDE_955391DB7E37__INCLUDED_)
#define AFX_XMLIMAGE_H__CE04F4A2_2AA3_4933_8BDE_955391DB7E37__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "XMLControl.h"
#include "xmllabel.h"
#include <gdiplus.h>


class CXMLImage : public _XMLControl<IRCMLControl>  
{
public:
	CXMLImage();
	virtual ~CXMLImage();
	typedef _XMLControl<IRCMLControl> BASECLASS;
	XML_CREATE( Image );
    IMPLEMENTS_RCMLCONTROL_UNKNOWN;

	friend BOOL PaintImage(HWND hwnd, HDC hdc);
	LPCTSTR GetFileName() { return m_pFileName;	}
	BOOL DelayPaint() {	BOOL retVal = bDelayPaint;  bDelayPaint = FALSE; return retVal;	}

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnInit( 
        HWND h);    // actually implemented

    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptChild( 
        IRCMLNode __RPC_FAR *child);

protected:
	void Init();
    CXMLStaticStyle * m_pControlStyle;

private:
	LPWSTR	m_pFileName;
	//
	// we want images to paint after all the other controls
	// due to the large load time, so we will repost the first paint message we receive
	BOOL	bDelayPaint;
	//
	// LATER
	// Consider adding other renderes, such as the ANIMATE_CLASS in common controls
	// 
	typedef enum { GDIPLUS, MCI, ANIMATE_CONTROL, STATICCONTROL } IMAGETYPE;
	IMAGETYPE m_imageType;
	union {
		Gdiplus::Bitmap *m_pBitmap;
		HWND	hwndMCIWindow;
	} image;
};


#endif // !defined(AFX_XMLIMAGE_H__CE04F4A2_2AA3_4933_8BDE_955391DB7E37__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlitem.cpp ===
// XMLItem.cpp: implementation of the CXMLItem class.
//
// This is used in both the string table and items in the combo / listbox
// scenarios
//
// For certain things, this is VERY VERY bad, and not the way to
// do this. e.g. a StringTable should really override the add children
// thing and perhaps not carry the weight of all these items, but
// provide a more sophisticated implementation of ID based stuff.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "XMLItem.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CXMLItem::CXMLItem()
{
  	NODETYPE = NT_ITEM;
    m_StringType= L"ITEM";
}

CXMLItem::~CXMLItem()
{

}

void CXMLItem::Init()
{
   	if(m_bInit)
		return;
	BASECLASS::Init();

    get_Attr(L"TEXT",&m_Text);
    DWORD dwValue;
    ValueOf( L"VALUE", 0, &dwValue );
    m_Value=dwValue;

    ValueOf( L"SELECTED", FALSE, &dwValue );
    m_Selected =dwValue;

    ValueOf( L"CHECKED", FALSE, &dwValue );
    m_Checked =dwValue;

    m_bInit=TRUE;
}

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CXMLRange::CXMLRange()
{
  	NODETYPE = NT_RANGE;
    m_StringType=L"RANGE";
}

CXMLRange::~CXMLRange()
{

}

void CXMLRange::Init()
{
   	if(m_bInit)
		return;
	BASECLASS::Init();

    DWORD dwValue;

    ValueOf( L"VALUE", 0, &dwValue );
    m_Value=dwValue;

    ValueOf( L"MIN", FALSE, &dwValue );
    m_Min =dwValue;

    ValueOf( L"MAX", FALSE, &dwValue );
    m_Max =dwValue;

    m_bInit=TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlitem.h ===
// XMLItem.h: interface for the CXMLItem class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XMLITEM_H__6B2A92D0_2768_42A6_8708_AF674E938664__INCLUDED_)
#define AFX_XMLITEM_H__6B2A92D0_2768_42A6_8708_AF674E938664__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "xmlnode.h"

class CXMLItem : public _XMLNode<IRCMLNode>
{
public:
	CXMLItem();
	virtual ~CXMLItem();
	typedef _XMLNode<IRCMLNode> BASECLASS;
    IMPLEMENTS_RCMLNODE_UNKNOWN;
	XML_CREATE( Item );

	PROPERTY(UINT, Value );
    PROPERTY(BOOL, Selected );
    PROPERTY(BOOL, Checked );

	LPCTSTR	GetText() { Init(); return m_Text; }
	void	SetText(LPWSTR	pszText) { Init(); m_Text = pszText; }

private:
	void    Init();
	DWORD   m_Value;
    LPWSTR m_Text;
    struct
    {
        BOOL    m_Selected:1;
        BOOL    m_Checked:1;
    };

};

typedef _RefcountList<CXMLItem> CXMLItemList;


class CXMLRange : public _XMLNode<IRCMLNode>
{
public:
	CXMLRange();
	virtual ~CXMLRange();
	typedef _XMLNode<IRCMLNode> BASECLASS;
    IMPLEMENTS_RCMLNODE_UNKNOWN;
	XML_CREATE( Range );

	PROPERTY(UINT, Value );
    PROPERTY(UINT, Min);
    PROPERTY(UINT, Max );


private:
	void    Init();
	UINT    m_Value;
	UINT    m_Min;
	UINT    m_Max;
};

#endif // !defined(AFX_XMLITEM_H__6B2A92D0_2768_42A6_8708_AF674E938664__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmllayout.cpp ===
// XMLLayout.cpp: implementation of the CXMLLayout class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "XMLLayout.h"
#include "xmlcontrol.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CXMLWin32Layout::CXMLWin32Layout()
{
	m_pGrid=NULL;
    m_Annotate=FALSE;
	NODETYPE = NT_WIN32LAYOUT;
    m_StringType=L"WIN32LAYOUT";
}

CXMLWin32Layout::~CXMLWin32Layout()
{
	delete m_pGrid;
}

void CXMLWin32Layout::Init()
{
	if(m_bInit)
		return;
	BASECLASS::Init();

	LPCTSTR req;

	req=(LPCTSTR)Get(TEXT("UNIT"));
	m_Units=UNIT_DLU;
	if( req )
	{
		if( lstrcmpi( req, TEXT("PX") ) == 0 )
			m_Units=UNIT_PIXEL;
	}

    m_Annotate=YesNo(TEXT("ANNOTATE"),FALSE);

	m_bInit=TRUE;
}


//
// Controls are no longer part of this node.
//
HRESULT CXMLWin32Layout::AcceptChild(IRCMLNode * pChild )
{
    ACCEPTCHILD( L"GRID", CXMLGrid, m_pGrid );
    ACCEPTREFCHILD( L"STYLE", IRCMLCSS, m_qrCSS );
    return BASECLASS::AcceptChild(pChild);
}

/////////////////////////////////////////////////////////////////////////////////
//
//
//
/////////////////////////////////////////////////////////////////////////////////
CXMLGrid::CXMLGrid()
{
  	NODETYPE = NT_GRID;
    m_StringType=L"GRID";
}

CXMLGrid::~CXMLGrid()
{
}

void CXMLGrid::Init()
{
	if(m_bInit)
		return;
	BASECLASS::Init();

    m_Map=YesNo( TEXT("MAP"), FALSE);

    ValueOf( TEXT("X"), 1, &m_X);

    ValueOf( TEXT("Y"), 1, &m_Y);

	m_Display=YesNo(TEXT("DISPLAY"),FALSE);

	m_bInit=TRUE;
}


CXMLLayout::CXMLLayout()
{
  	NODETYPE = NT_LAYOUT;
    m_StringType=L"LAYOUT";
}

CXMLLayout::~CXMLLayout()
{

}

void CXMLLayout::Init()
{
    m_bInit=TRUE;
}

//
// This is just a pass through, up to our parent CXMLDlg
//
HRESULT CXMLLayout::AcceptChild(IRCMLNode * pChild )
{
    if( SUCCEEDED( pChild->IsType(L"WIN32LAYOUT") ))  // BUGBUG - should be QI
    {
        //
        // For this, we ask our parent if they want the children.
        // perhaps we should check what the type is?
        //
        // this doesn't reparent the node in the XML tree, the children are
        // still seen as children of Win32Layout.
        //
        IRCMLNode * pParent;
        if( SUCCEEDED( DetachParent( &pParent )))
            return pParent->AcceptChild( pChild );

        // if( bParent )
        //    ((CXMLControl *)pChild)->SetContainer( (CXMLControl*)GetParent());
    }
    return BASECLASS::AcceptChild(pChild);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmllistbox.cpp ===
// XMLListBox.cpp: implementation of the CXMLListBox class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "XMLListBox.h"
#include "enumcontrols.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
#define CONTROLSTYLE(p,id, member, def) member = YesNo( id , def );

CXMLListBoxStyle::CXMLListBoxStyle()
{
	m_bInit=FALSE;
	NODETYPE = NT_LISTBOXSTYLE;
    m_StringType=L"WIN32:LISTBOX";
}

void CXMLListBoxStyle::Init()
{
    if(m_bInit)
        return;
    BASECLASS::Init();

    listboxStyle=0;

    CONTROLSTYLE( LBS_NOTIFY, TEXT("NOTIFY"),       m_Notify, TRUE );
    CONTROLSTYLE( LBS_NOREDRAW, TEXT("NNOREDRAW"), m_NoRedraw, FALSE );

    CONTROLSTYLE( LBS_OWNERDRAWFIXED, TEXT("OWNERDRAWFIXED"),       m_OwnerDrawFixed, FALSE );
    CONTROLSTYLE( LBS_OWNERDRAWVARIABLE, TEXT("OWNERDRAWVARIABLE"), m_OwnerDrawVariable, FALSE );

    CONTROLSTYLE( LBS_HASSTRINGS, TEXT("HASSTRINGS"), m_HasStrings, FALSE );
    CONTROLSTYLE( LBS_USETABSTOPS, TEXT("TABSTOPS"), m_UseTabstops, FALSE );

    CONTROLSTYLE( LBS_NOINTEGRALHEIGHT, TEXT("NOINTEGRALHEIGHT"), m_NoIntegralHeight, TRUE );
    CONTROLSTYLE( LBS_WANTKEYBOARDINPUT, TEXT("WANTKEYBOARDINPUT"), m_WantKeyboardInput, FALSE );

    CONTROLSTYLE( LBS_DISABLENOSCROLL, TEXT("DISABLENOSCROLL"), m_DisableNoScroll, FALSE );
    CONTROLSTYLE( LBS_NODATA, TEXT("NODATA"), m_NoData, FALSE );


    m_bInit=TRUE;
}


/////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
CXMLListBox::CXMLListBox()
{
	m_bInit=FALSE;
    NODETYPE = NT_LIST;
    m_StringType=L"LISTBOX";
    m_pTextItem=NULL;
    m_pControlStyle=NULL;
}

void CXMLListBox::Init()
{
	if(m_bInit)
		return;
	BASECLASS::Init();

	if( m_Height == 0 )
		m_Height=8;

	m_Class=m_Class?m_Class:(LPWSTR)0x0083; // TEXT("LISTBOX");

    if( m_pControlStyle )
        m_Style |= m_pControlStyle->GetBaseStyles();
    else
        m_Style |= LBS_NOTIFY | LBS_NOINTEGRALHEIGHT;

    //
    // No CSSstyle attributes
    //
    IRCMLCSS * pCSS;
    if( SUCCEEDED( get_CSS(&pCSS) ))
    {
        pCSS->Release();
    }

    //
    // Attributes
    //
    m_Style |= YesNo( TEXT("SORT"), LBS_SORT, 0, LBS_SORT);

    // Is this a SELECTION="MULTIPLE"
    m_Style |= YesNo( TEXT("MULTIPLE"), 0, 0, LBS_MULTIPLESEL);

    m_Style |= YesNo( TEXT("MULTICOLUMN"), 0, 0, LBS_MULTICOLUMN);

    LPCTSTR res=Get(TEXT("SELECTION"));
    if( res )
    {
        if( lstrcmpi(res, TEXT("EXTENDED") ) == 0 )
            m_Style |= LBS_EXTENDEDSEL;
        else  if( lstrcmpi(res, TEXT("NO") ) == 0 )
            m_Style |= LBS_NOSEL;
    }

	m_bInit=TRUE;
}

//
// Fills the listbox with the ITEM found as children of the control.
//
HRESULT CXMLListBox::OnInit(HWND hWnd)
{
    BASECLASS::OnInit(hWnd);
    if(m_pTextItem)
    {
        //
        // Probably need to check for "HASSTRINGs" or equivalent
        //
        int iCount=m_pTextItem->GetCount();
        CXMLItem * pItem;
        int iPosition;
        for( int i=0;i<iCount;i++)
        {
            pItem=m_pTextItem->GetPointer(i);
            iPosition = SendMessage( hWnd, LB_ADDSTRING, 0, (LPARAM)pItem->GetText());
            if(iPosition != CB_ERR )
            {
                SendMessage( hWnd, LB_SETITEMDATA, iPosition, pItem->GetValue() );
                if( pItem->GetSelected() )
                    SendMessage( hWnd, LB_SETSEL, iPosition, NULL );

            }
         }
    	SendMessage( hWnd, LB_SETCURSEL, 0, NULL);
    }
    return S_OK;
}

HRESULT CXMLListBox::AcceptChild(IRCMLNode * pChild )
{
    ACCEPTCHILD( L"WIN32:LISTBOX", CXMLListBoxStyle, m_pControlStyle );
    if( SUCCEEDED( pChild->IsType( L"ITEM" ) ))
    {   
        if(m_pTextItem==NULL)
            m_pTextItem=new CXMLItemList;
        m_pTextItem->Append( (CXMLItem*)pChild );
        return S_OK;
    }
    return BASECLASS::AcceptChild(pChild);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// if you ever want to have control containership this will
// have to change a LOT, but for now, it allows me to get at namespace extentions.
//
HRESULT STDMETHODCALLTYPE CXMLListBox::GetChildEnum( 
    IEnumUnknown __RPC_FAR *__RPC_FAR *pEnum)
{
    if( m_pTextItem == NULL )
        return E_FAIL;

    if( pEnum )
    {
        *pEnum = new CEnumControls<CXMLItemList>(*m_pTextItem);
        (*pEnum)->AddRef();
        return S_OK;
    }
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmllistbox.h ===
// XMLListBox.h: interface for the CXMLListBox class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XMLLISTBOX_H__3F7F8626_9DD6_4092_B4B3_9E3E37AB6102__INCLUDED_)
#define AFX_XMLLISTBOX_H__3F7F8626_9DD6_4092_B4B3_9E3E37AB6102__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "XMLControl.h"

/////////////////////////////////////////////////////////////////////////////////
//
// Contains the shared style bits for all buttons
//
/////////////////////////////////////////////////////////////////////////////////
class CXMLListBoxStyle : public CXMLControlStyle
{
public:
    CXMLListBoxStyle();
	virtual ~CXMLListBoxStyle() {};
	typedef CXMLControlStyle BASECLASS;
	XML_CREATE( ListBoxStyle );
    UINT    GetBaseStyles() { Init(); return listboxStyle; }
    void    Init();

protected:
// http://msdn.microsoft.com/workshop/author/dhtml/reference/objects/SELECT.asp
// LBS_NOTIFY            0x0001L     C  // WIN32:LISTBOX\@NOTIFY
// LBS_SORT              0x0002L     A  // SORT="YES"
// LBS_NOREDRAW          0x0004L     C  // WIN32:LISTBOX\@NOREDRAW
// LBS_MULTIPLESEL       0x0008L     A  // MULTIPLE="YES"
// LBS_OWNERDRAWFIXED    0x0010L     C  // WIN32:COMBOBOX\@OWNERDRAWFIXED
// LBS_OWNERDRAWVARIABLE 0x0020L     C  // WIN32:COMBOBOX\@OWNERDRAWVARIABLE
// LBS_HASSTRINGS        0x0040L     C  // WIN32:COMBOBOX\HASSTRINGS
// LBS_USETABSTOPS       0x0080L     C  // WIN32:COMBOBOX\@USETABSTOPS
// LBS_NOINTEGRALHEIGHT  0x0100L     C  // WIN32:COMBOBOX\@NOINTEGRALHEIGHT
// LBS_MULTICOLUMN       0x0200L     C  // MULTICOLUMN="YES"
// LBS_WANTKEYBOARDINPUT 0x0400L     C  // WIN32:COMBOBOX\@WANTKEYBOARDINPUT
// LBS_EXTENDEDSEL       0x0800L     A  // SELECTION="EXTENDED"
// LBS_DISABLENOSCROLL   0x1000L     C  // WIN32:COMBOBOX\DISALBENOSCROLL
// LBS_NODATA            0x2000L     C  // WIN32:COMBOBOX\@NODATA
// LBS_NOSEL             0x4000L     A  // SELECTION="NO"
    union
    {
        UINT    listboxStyle;
        struct {
            BOOL    m_Notify:1;
            BOOL    m_Sort:1;
            BOOL    m_NoRedraw:1;
            BOOL    m_MiltipleSel:1;

            BOOL    m_OwnerDrawFixed:1;   
            BOOL    m_OwnerDrawVariable:1;
            BOOL    m_HasStrings:1;       
            BOOL    m_UseTabstops:1;

            BOOL    m_NoIntegralHeight:1;
            BOOL    m_MultiColumn:1;
            BOOL    m_WantKeyboardInput:1;
            BOOL    m_ExtendedSel:1;

            BOOL    m_DisableNoScroll:1;
            BOOL    m_NoData:1;
            BOOL    m_NoSel:1;
        };
    };
};


class CXMLListBox : public _XMLControl<IRCMLControl>
{
public:
	CXMLListBox();
    virtual ~CXMLListBox() { delete m_pTextItem; delete m_pControlStyle; }
	typedef _XMLControl<IRCMLControl> BASECLASS;

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnInit( 
        HWND h);    // actually implemented

	XML_CREATE( ListBox );
    IMPLEMENTS_RCMLCONTROL_UNKNOWN;

    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptChild( 
        IRCMLNode __RPC_FAR *child);

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetChildEnum( 
        IEnumUnknown __RPC_FAR *__RPC_FAR *pEnum);

protected:
	void Init();
    CXMLItemList    * m_pTextItem;
    CXMLListBoxStyle * m_pControlStyle;
};

#endif // !defined(AFX_XMLLISTBOX_H__3F7F8626_9DD6_4092_B4B3_9E3E37AB6102__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmllabel.cpp ===
// XMLLabel.cpp: implementation of the CXMLLabel class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "XMLLabel.h"
#include "xmldlg.h"
#include "xmlbutton.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
#define CONTROLSTYLE(p,id, member, def) member = YesNo( id , def );

CXMLStaticStyle::CXMLStaticStyle()
{
	m_bInit=FALSE;
	NODETYPE = NT_STATICSTYLE;
    m_StringType= L"WIN32:LABEL";
}

void CXMLStaticStyle::Init()
{
    if(m_bInit)
        return;
    BASECLASS::Init();

    staticStyle=0;

    CONTROLSTYLE( SS_NOPREFIX,      TEXT("NOPREFIX"),       m_NoPrefix, FALSE );
    CONTROLSTYLE( SS_NOTIFY,        TEXT("NOTIFY"),         m_Notify, FALSE );
    CONTROLSTYLE( SS_CENTERIMAGE,   TEXT("CENTERIMAGE"),    m_CenterImage, FALSE );
    CONTROLSTYLE( SS_RIGHTJUST,     TEXT("RIGHTJUST"),      m_RightJust, FALSE );
    CONTROLSTYLE( SS_REALSIZEIMAGE, TEXT("REALSIZEIMAGE"),  m_RealSizeImage, FALSE );
    CONTROLSTYLE( SS_SUNKEN,        TEXT("SUNKEN"),         m_Sunken, FALSE );
    
    LPCTSTR res=Get(TEXT("ELIPSIS"));
    if( res )
    {
        if( lstrcmpi(res, TEXT("END"))==0)
            staticStyle |= SS_ENDELLIPSIS;
        else if( lstrcmpi(res, TEXT("WORD"))==0)
            staticStyle |= SS_WORDELLIPSIS;
        else if( lstrcmpi(res, TEXT("PATH"))==0)
            staticStyle |= SS_PATHELLIPSIS;
    }

    m_bInit=TRUE;
}

void CXMLStaticStyle::InitAnimation()
{
    if(m_bInit)
        return;
    BASECLASS::Init();

    animationStyle=0;

    if( YesNo( TEXT("TIMER"), FALSE ) )
        animationStyle |= ACS_TIMER;

    m_bInit=TRUE;
}

//
//
//
CXMLLabel::CXMLLabel()
{
	m_bInit=FALSE;
	NODETYPE = NT_STATIC;
    m_StringType=L"LABEL";
    m_pControlStyle=FALSE;
}

CXMLLabel::~CXMLLabel()
{
    delete m_pControlStyle;
}

void CXMLLabel::Init()
{
	if(m_bInit)
		return;
	BASECLASS::Init();

	if( m_Height == 0 )
		m_Height=8;

	if( m_Width == 0 )  // we force a default width here for column production.
		m_Width= 12;

	m_Class=m_Class?m_Class:(LPWSTR)0x0082; // TEXT("STATIC");

    //
    //
    //
    LPWSTR req;
    if( m_pControlStyle )
    {
        m_Style |= m_pControlStyle->GetBaseStyles();
        if( m_pControlStyle->YesNo(TEXT("SIMPLE"),FALSE) )
            m_Style |=SS_SIMPLE;
        else if( m_pControlStyle->YesNo(TEXT("LEFTNOWORDWRAP"),FALSE) )
            m_Style |=SS_LEFTNOWORDWRAP;
        else if( m_pControlStyle->YesNo(TEXT("OWNERDRAW"),FALSE) )
            m_Style |=SS_OWNERDRAW;
    }
    else
        m_Style |= 0; // edits don't have any defaults.
#ifdef _DEBUG
    LPWSTR pszText;
    get_Attr(L"TEXT", &pszText);
    TRACE(TEXT("The lable '%s'\n"), pszText );
#endif
    IRCMLCSS * pCSS;
    if( SUCCEEDED( get_CSS( & pCSS) ))
    {
        // If the above has set us to a specific static type, ignore these.
        if( (m_Style & SS_TYPEMASK) == 0 )
        {
            if(SUCCEEDED( pCSS->get_Attr( L"TEXT-ALIGN" , & req )))
            {
                if( lstrcmpi( req, TEXT("CENTER"))==0 )
                    m_Style |= SS_CENTER;
                else if( lstrcmpi( req, TEXT("RIGHT"))==0 )
                    m_Style |= SS_RIGHT;
                else if( lstrcmpi( req, TEXT("LEFT"))==0 )
                    m_Style |= SS_LEFT;
            }
        }
        pCSS->Release();
    }

    //
    // Hmm, there isn't a style bit for this.
    //
	m_bMultiLine=YesNo( TEXT("MULTILINE"), FALSE );

	//
	// NOTE NOTE NOTE You can call back into us now.
	//
	m_bInit=TRUE;
}

//
// Question - can we check to see if the font will fit now?
// single line check first.
//
void CXMLLabel::CheckClipped()
{
    // If we have ellipsis turned on , we do NOT check this.
    if( m_Style & ( SS_ENDELLIPSIS | SS_WORDELLIPSIS | SS_PATHELLIPSIS ) )
        return;
    if( (m_Style & SS_TYPEMASK ) == SS_LEFTNOWORDWRAP )
        return;
    m_Clipped = CXMLButton::CheckClippedConstraint( this, 0,0, 8, GetMultiLine() );
}


HRESULT CXMLLabel::AcceptChild(IRCMLNode * pChild )
{
    ACCEPTCHILD( L"WIN32:LABEL", CXMLStaticStyle, m_pControlStyle );
    return BASECLASS::AcceptChild(pChild);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmllayout.h ===
// XMLLayout.h: interface for the CXMLLayout class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XMLLAYOUT_H__BD2863A0_0FBE_11D3_8BE9_00C04FB177B1__INCLUDED_)
#define AFX_XMLLAYOUT_H__BD2863A0_0FBE_11D3_8BE9_00C04FB177B1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "xmlnode.h"
#include "xmlstyle.h"
#undef PROPERTY
#define PROPERTY( type, id ) type Get##id() { Init(); return m_##id; }

class CXMLGrid : public _XMLNode<IRCMLNode>
{
public:
	CXMLGrid();
	virtual ~CXMLGrid();
    IMPLEMENTS_RCMLNODE_UNKNOWN;
	typedef _XMLNode<IRCMLNode> BASECLASS;
	XML_CREATE( Grid );

	PROPERTY(DWORD, X );
	PROPERTY(DWORD, Y );
	PROPERTY(BOOL, Map );	// map the X,Y in the layoutPos to grid units.
	PROPERTY(BOOL, Display );
							// grid x=4, y=4 : control x=1,y=2 -> x=4,y=8
private:
	void Init();
	DWORD m_X;
	DWORD m_Y;
	DWORD m_Map;
	BOOL		m_Display;	// do we display the grid - is this a general layout feature?

};

class CXMLWin32Layout : public _XMLNode<IRCMLNode>
{
public:
	CXMLWin32Layout();
	virtual ~CXMLWin32Layout();
    IMPLEMENTS_RCMLNODE_UNKNOWN;
	typedef _XMLNode<IRCMLNode> BASECLASS;
	XML_CREATE( Win32Layout );

	typedef enum LAYOUT_UNIT {
		UNIT_DLU,
		UNIT_PIXEL };

	LAYOUT_UNIT	GetUnits() { Init(); return m_Units; }
    PROPERTY(BOOL, Annotate);

	void        SetGrid( CXMLGrid *G ) { m_pGrid=G; }
	CXMLGrid *	GetGrid() { return m_pGrid; }

    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptChild( 
        IRCMLNode __RPC_FAR *pChild);

    IRCMLCSS * GetCSSStyle() { return m_qrCSS.GetInterface(); }

protected:
	void Init();
	LAYOUT_UNIT	m_Units;
	CXMLGrid  * m_pGrid;

    CQuickRef<IRCMLCSS> m_qrCSS;

    BOOL    m_Annotate; // should we annotate the dialog with the grid lines?
};

class CXMLLayout : public _XMLNode<IRCMLNode>
{
public:
	CXMLLayout();
	virtual ~CXMLLayout();
    IMPLEMENTS_RCMLNODE_UNKNOWN;
	typedef _XMLNode<IRCMLNode> BASECLASS;
 	XML_CREATE( Layout );
    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptChild( 
        IRCMLNode __RPC_FAR *pChild);

protected:
	void Init();

};

#endif // !defined(AFX_XMLWin32Layout_H__BD2863A0_0FBE_11D3_8BE9_00C04FB177B1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmllabel.h ===
// XMLLabel.h: interface for the CXMLLabel class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XMLLABEL_H__1B04CF00_300F_49AA_B7C2_81B8AA050BF4__INCLUDED_)
#define AFX_XMLLABEL_H__1B04CF00_300F_49AA_B7C2_81B8AA050BF4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "XMLControl.h"

/////////////////////////////////////////////////////////////////////////////////
//
// Contains the shared style bits for all STATICs (label, rect, image)
//
/////////////////////////////////////////////////////////////////////////////////
class CXMLStaticStyle : public CXMLControlStyle
{
public:
    CXMLStaticStyle();
	virtual ~CXMLStaticStyle() {};
	typedef CXMLControlStyle BASECLASS;
	XML_CREATE( StaticStyle );
    UINT    GetBaseStyles() { Init(); return staticStyle; }
    UINT    GetBaseAnimationStyles() { InitAnimation(); return animationStyle; }
    void    Init();
    void    InitAnimation();
//////////////////////////////////////////////////////////////////////////////////////////
//
    // http://msdn.microsoft.com/workshop/author/dhtml/reference/objects/LABEL.asp
    // Enumeration
    // SS_LEFT             0x0000L  S       // STYLE\@TEXT-ALIGN 
    // SS_CENTER           0x0001L  S       // STYLE\@TEXT-ALIGN 
    // SS_RIGHT            0x0002L  S       // STYLE\@TEXT-ALIGN
    // SS_ICON             0x0003L          // IMAGE
    // SS_BLACKRECT        0x0004L  C       // RECT\WIN32:STATIC\@TYPE="BLACKRECT"
    // SS_GRAYRECT         0x0005L  C       // RECT\WIN32:STATIC\@TYPE="GRAYRECT"
    // SS_WHITERECT        0x0006L  C       // RECT\WIN32:STATIC\@TYPE="WHITERECT"
    // SS_BLACKFRAME       0x0007L  C       // RECT\WIN32:STATIC\@TYPE="BLACKFRAME"
    // SS_GRAYFRAME        0x0008L  C       // RECT\WIN32:STATIC\@TYPE="GRAYFRAME"
    // SS_WHITEFRAME       0x0009L  C       // RECT\WIN32:STATIC\@TYPE="WHITEFRAME"
    // SS_USERITEM         0x000AL          // ??
    // SS_SIMPLE           0x000BL	C       // WIN32:STATIC\SIMPLE
    // SS_LEFTNOWORDWRAP   0x000CL  C		// WIN32:STATIC\@LEFTNOWORDWRAP
    // SS_OWNERDRAW        0x000DL          // WIN32:STATIC\OWNERDRAW
    // SS_BITMAP           0x000EL          // IMAGE
    // SS_ENHMETAFILE      0x000FL          // IMAGE
    // SS_ETCHEDHORZ       0x0010L          // RECT\WIN32:STATIC\@TYPE="ETCHEDHORZ"
    // SS_ETCHEDVERT       0x0011L          // RECT\WIN32:STATIC\@TYPE="ETCHEDVERT"
    // SS_ETCHEDFRAME      0x0012L		    // RECT\WIN32:STATIC\@TYPE="ETCHEDFRAME"
    // SS_TYPEMASK         0x0000001FL
    // End enumeration.

// http://msdn.microsoft.com/workshop/author/dhtml/reference/objects/IMG.asp

    //  FLAGS - can't find much overlap with HTML.
    //  SS_NOPREFIX         0x00000080L     // WIN32:STATIC\@NOPREFIX=NO /* Don't do "&" character translation */
    //  SS_NOTIFY           0x00000100L     // WIN32:STATIC\NOTIFY
    //  SS_CENTERIMAGE      0x00000200L     // WIN32:STATIC\CENTERIMAGE
    //  SS_RIGHTJUST        0x00000400L     // WIN32:STATIC\@RIGHTJUST
    //  SS_REALSIZEIMAGE    0x00000800L     // WIN32:STATIC\@REALSIZEIMAGE 
    //  SS_SUNKEN           0x00001000L     // WIN32:STATIC\@SUNKEN
    //  Enumeration
    //  SS_ENDELLIPSIS      0x00004000L     // ELIPSIS="END" 
    //  SS_PATHELLIPSIS     0x00008000L     // ELIPSIS="PATH" 
    //  SS_WORDELLIPSIS     0x0000C000L     // ELIPSIS="WORD" 
    //  SS_ELLIPSISMASK     0x0000C000L

protected:
    union
    {
        UINT    staticStyle;
        UINT    animationStyle;
        struct {
            UINT    enum1:5;        // 5 bit enumation
            UINT    enum2:2;        // un-used?!
            BOOL    m_NoPrefix:1;
            BOOL    m_Notify:1;
            BOOL    m_CenterImage:1;
            BOOL    m_RightJust:1;
            BOOL    m_RealSizeImage:1;
            BOOL    m_Sunken:1;
        };
    };
};


class CXMLLabel : public _XMLControl<IRCMLControl>  
{
public:
	CXMLLabel();
	virtual ~CXMLLabel();
   	XML_CREATE( Label );
    IMPLEMENTS_RCMLCONTROL_UNKNOWN;

	typedef _XMLControl<IRCMLControl> BASECLASS;
	BOOL	GetMultiLine() { Init(); return m_bMultiLine; }

    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptChild( 
        IRCMLNode __RPC_FAR *child);

protected:
	void Init();
    CXMLStaticStyle * m_pControlStyle;

	void CheckClipped();
	BOOL	m_bMultiLine;
};

#endif // !defined(AFX_XMLLABEL_H__1B04CF00_300F_49AA_B7C2_81B8AA050BF4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmllistview.cpp ===
// XMLListView.cpp: implementation of the CXMLListView class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "XMLListView.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

#define CONTROLSTYLE(p,id, member, def) member = YesNo( id , def );
#ifndef ListView_SetCheckState
#define ListView_SetCheckState(hwndLV, i, fCheck) \
  ListView_SetItemState(hwndLV, i, INDEXTOSTATEIMAGEMASK((fCheck)?2:1), LVIS_STATEIMAGEMASK)
#endif

CXMLListViewStyle::CXMLListViewStyle()
{
	m_bInit=FALSE;
	NODETYPE = NT_LISTVIEWSTYLE;
    m_StringType= L"WIN32:LISTVIEW";
}

void CXMLListViewStyle::Init()
{
    if(m_bInit)
        return;
    BASECLASS::Init();

    listViewStyle=0;

    CONTROLSTYLE( LVS_OWNERDRAWFIXED,TEXT("OWNERDRAWFIXED"),    m_OwnerDrawFixed, FALSE );
    CONTROLSTYLE( LVS_OWNERDATA,     TEXT("OWNERDATA"),         m_OwnerData,      FALSE );
    CONTROLSTYLE( LVS_SHAREIMAGELISTS,TEXT("SHAREIMAGELISTS"),  m_ShareImageLists,FALSE );
    CONTROLSTYLE( LVS_SHOWSELALWAYS, TEXT("SHOWSELALWAYS"),     m_ShowSelAlways,  FALSE );

    m_bInit=TRUE;
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
CXMLListView::CXMLListView()
{
	m_bInit=FALSE;
	NODETYPE = NT_LISTVIEW;
    m_StringType=L"LISTVIEW";
    m_pControlStyle=NULL;
}

// LVS_ICON                0x0000
// LVS_REPORT              0x0001   @DISPLAY="REPORT"
// LVS_SMALLICON           0x0002   @DISPLAY="SMALLICON"
// LVS_LIST                0x0003   @DISPLAY="LIST"
// LVS_TYPEMASK            0x0003

// LVS_SINGLESEL           0x0004   @SELECTION="SINGLE"
// LVS_SHOWSELALWAYS       0x0008   WIN32:TREEVIEW @SHOWSELALWAYS="YES"

// LVS_SORTASCENDING       0x0010   @SORT="ASCENDING"
// LVS_SORTDESCENDING      0x0020   @SORT="DESCENDING"
// LVS_SHAREIMAGELISTS     0x0040   WIN32:TREEVIEW @SHAREIMAGELIST="YES"
// LVS_NOLABELWRAP         0x0080   @NOLABELWRAP="YES"

// LVS_AUTOARRANGE         0x0100   @AUTOARRANGE="YES"
// LVS_EDITLABELS          0x0200   @EDITLABELS="YES"

// LVS_OWNERDATA           0x1000   WIN32:TREEVIEW @OWNERDATA="YES"
// LVS_NOSCROLL            0x2000   @NOSCROLL="YES"

// LVS_TYPESTYLEMASK       0xfc00

// LVS_ALIGNTOP            0x0000   @ALIGN="TOP"
// LVS_ALIGNLEFT           0x0800   @ALIGN="LEFT"
// LVS_ALIGNMASK           0x0c00

// LVS_OWNERDRAWFIXED      0x0400   WIN32:TREEVIEW @OWNERDRAWFIXED="YES"
// LVS_NOCOLUMNHEADER      0x4000   @NOCOLUMNHEADER="YES"
// LVS_NOSORTHEADER        0x8000   @NOSORTHEADER="YES"
void CXMLListView::Init()
{
	if(m_bInit)
		return;
	BASECLASS::Init();

	if( m_Height == 0 )
		m_Height=8;

	if( m_Width == 0 )
		m_Width=8;

    LPCTSTR req;
    BOOL bHasColumns=m_ColumnList.GetCount()!=0;
    if( bHasColumns )
    {
        m_Style |= LVS_REPORT ;
    }
    else
    if( req= Get(TEXT("DISPLAY")))
    {
        if( lstrcmpi(req,TEXT("REPORT"))==0 )
            m_Style |= LVS_REPORT;
        else if( lstrcmpi(req,TEXT("SMALLICON"))==0 )
            m_Style |= LVS_SMALLICON ;
        else if( lstrcmpi(req,TEXT("LIST"))==0 )
            m_Style |= LVS_LIST ;
    }

    if( req=Get(TEXT("SELECTION")) )
        if( lstrcmpi(req,TEXT("SINGLE"))==0)
            m_Style |= LVS_SINGLESEL;

    if( req= Get(TEXT("SORT")))
    {
        if( lstrcmpi(req,TEXT("ASCENDING"))==0 )
            m_Style |= LVS_SORTASCENDING;
        else if( lstrcmpi(req,TEXT("DESCENDING"))==0 )
            m_Style |= LVS_SORTDESCENDING ;
    }

    m_Style |= YesNo(TEXT("NOLABELWRAP"), 0, 0, LVS_NOLABELWRAP );

    m_Style |= YesNo(TEXT("AUTOARRANGE"), 0, 0, LVS_AUTOARRANGE );

    m_Style |= YesNo(TEXT("EDITLABELS"), 0, 0, LVS_EDITLABELS );

    m_Style |= YesNo(TEXT("NOSCROLL"), 0, 0, LVS_NOSCROLL );

    if( req= Get(TEXT("ALIGN")))
    {
        if( lstrcmpi(req,TEXT("TOP"))==0 )
            m_Style |= LVS_ALIGNTOP;
        else if( lstrcmpi(req,TEXT("LEFT"))==0 )
            m_Style |= LVS_ALIGNLEFT ;
    }

    m_Style |= YesNo(TEXT("NOCOLUMNHEADER"), 0, 0, LVS_NOCOLUMNHEADER );

    m_Style |= YesNo(TEXT("NOSORTHEADER"), 0, 0, LVS_NOSORTHEADER );

    if( m_pControlStyle )
        m_Style |= m_pControlStyle->GetBaseStyles();
    else
        m_Style |= 0; // edits don't have any defaults.

	m_Class=m_Class?m_Class:WC_LISTVIEW;

    //
    // And now for the LVS_EX* stuff .. LVS_EX_CHECKBOXES 
    //
    m_EXStyles=0;
    if ( req = Get(TEXT("CONTENT")) )
    {
        if( lstrcmpi(req,TEXT("CHECKBOXES"))==0 )
            m_EXStyles |= LVS_EX_CHECKBOXES;
    }

	m_bInit=TRUE;
}

//
// We can do columns, colum sizes, sort order I guess?
// how do we add the data to the columns?
//
HRESULT CXMLListView::OnInit(HWND hWnd)
{
    BASECLASS::OnInit(hWnd);

    int iCount=m_ColumnList.GetCount();
    if(iCount==0)
        return S_OK;


#ifdef BROKEN
    IRCMLCSS * pxmlStyle=NULL;
	if( SUCCEEDED( get_CSS(&pxmlStyle) ) )
	{
        if( pxmlStyle->GetColor() != -1 )
            ListView_SetTextColor( hWnd, pxmlStyle->GetColor() );

        if( pxmlStyle->GetBkColor() != -1 )
            ListView_SetTextBkColor( hWnd, pxmlStyle->GetBkColor() );
        pxmlStyle->Release();
	}
#endif

    ListView_SetExtendedListViewStyleEx( hWnd, 0, m_EXStyles );

    CXMLColumn * pItem;
    for( int i=0;i<iCount;i++)
    {
        pItem=m_ColumnList.GetPointer(i);
        LV_COLUMN col={0};
        col.mask = LVCF_FMT | LVCF_ORDER | LVCF_TEXT | LVCF_WIDTH;

        //
        // Set alignments
        //
        switch( pItem->GetAlignment() )
        {
        default:
        case CXMLColumn::COL_ALIGN_LEFT:
            col.fmt |= LVCFMT_LEFT;
            break;
        case CXMLColumn::COL_ALIGN_RIGHT:
            col.fmt |= LVCFMT_RIGHT;
            break;
        case CXMLColumn::COL_ALIGN_CENTER:
            col.fmt |= LVCFMT_CENTER;
            break;
        }

        //
        // Set text, images, width
        //
        col.pszText = (LPTSTR)pItem->GetText();
        if( pItem->GetContainsImages() )
            col.fmt |= LVCFMT_COL_HAS_IMAGES ;
        col.cx = pItem->GetWidth();
        col.iOrder = i;

        //
        // Add the column.
        //
        ListView_InsertColumn( hWnd, i, &col );

        //
        // Add items - either use insert item, or SetItemText!
        //
        if( i==0 )
        {
            CXMLItemList & Items=pItem->GetItems();
            int itemCount=Items.GetCount();
            for( int j=0;j<itemCount;j++)
            {
                CXMLItem * pItem = Items.GetPointer(j);
                LVITEM lvi={0};
                lvi.mask = LVIF_TEXT | LVIF_STATE;
                lvi.iItem = j;
                if( pItem->GetSelected() )  // Only when control has focus do you see this.
                {
                    lvi.stateMask |= LVIS_SELECTED;
                    lvi.state = LVIS_SELECTED;
                }
                lvi.pszText = (LPTSTR)pItem->GetText();
                int iRet=ListView_InsertItem( hWnd, & lvi );
                if( m_EXStyles & LVS_EX_CHECKBOXES )
                    ListView_SetCheckState( hWnd, iRet, pItem->GetChecked() );
            }
        }
        else
        {
            CXMLItemList & Items=pItem->GetItems();
            int itemCount=Items.GetCount();
            for( int j=0;j<itemCount;j++)
            {
                CXMLItem * pItem = Items.GetPointer(j);
                ListView_SetItemText( hWnd, j, i, (LPTSTR)pItem->GetText());
            }
        }

        //
        // Auto size.
        //
        if( col.cx < 0 )
            ListView_SetColumnWidth( hWnd, i, col.cx );
    }
    return S_OK;
}


HRESULT CXMLListView::AcceptChild(IRCMLNode * pChild )
{
    ACCEPTCHILD( L"WIN32:LISTVIEW", CXMLListViewStyle, m_pControlStyle);

    if( SUCCEEDED( pChild->IsType(L"COLUMN") ))  // BUGBUG - should be QI
    {
        m_ColumnList.Append((CXMLColumn*)pChild);
        return S_OK;
    }

    return BASECLASS::AcceptChild(pChild);
}


/////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
CXMLColumn::CXMLColumn()
{
	m_bInit=FALSE;
	NODETYPE = NT_COLUMN;
    m_StringType=L"COLUMN";
}

void CXMLColumn::Init()
{
    if(m_bInit)
        return;
    BASECLASS::Init();

    LPCTSTR req= Get(TEXT("WIDTH"));
    if( req )
    {
        if( lstrcmpi(req, TEXT("CONTENT")) == 0 )
            m_Width = LVSCW_AUTOSIZE;
        else if( lstrcmpi(req, TEXT("FILL")) == 0 )
            m_Width = LVSCW_AUTOSIZE_USEHEADER;
        else
        {
            DWORD dwTemp=50;
            ValueOf( req , dwTemp, & dwTemp );
            m_Width=dwTemp;
        }
    }
    else
        m_Width = 50;


    if( LPCTSTR req=Get(TEXT("ALIGNMENT")) )
    {
        m_Alignment = COL_ALIGN_LEFT;
        if(lstrcmpi(req,TEXT("LEFT"))==0)
            m_Alignment = COL_ALIGN_LEFT;
        else if(lstrcmpi(req,TEXT("RIGHT"))==0)
            m_Alignment = COL_ALIGN_RIGHT;
        else  if(lstrcmpi(req,TEXT("CENTER"))==0)
            m_Alignment = COL_ALIGN_CENTER;
    }

    m_ContainsImages = YesNo( TEXT("IMAGES"), FALSE );

    m_bInit=TRUE;
}

HRESULT CXMLColumn::AcceptChild(IRCMLNode * pChild )
{
    if( SUCCEEDED( pChild->IsType(L"ITEM") ))  // BUGBUG - should be QI
    {
        m_Items.Append( (CXMLItem*) pChild );
        return S_OK;
    }
    return BASECLASS::AcceptChild(pChild);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmllistview.h ===
// XMLListView.h: interface for the CXMLListView class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XMLLISTVIEW_H__C4CD3279_E4B0_4F47_A1F7_C662872DCD1A__INCLUDED_)
#define AFX_XMLLISTVIEW_H__C4CD3279_E4B0_4F47_A1F7_C662872DCD1A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "xmlnode.h"
#include "XMLControl.h"


//
// A column definition.
//
class CXMLColumn : public _XMLNode<IRCMLNode>
{
public:
    CXMLColumn();
    ~CXMLColumn() {};
    IMPLEMENTS_RCMLNODE_UNKNOWN;
	typedef _XMLNode<IRCMLNode> BASECLASS;

	XML_CREATE( Column );
    void    Init();

    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptChild( 
        IRCMLNode __RPC_FAR *child);

    enum COL_ALIGN
    {
        COL_ALIGN_LEFT,
        COL_ALIGN_CENTER,
        COL_ALIGN_RIGHT
    } ;

    PROPERTY( int, Width );
    PROPERTY( int, SortOrder );
    LPWSTR GetText() { Init(); return Get(TEXT("TEXT")); }
    PROPERTY( COL_ALIGN, Alignment );
    PROPERTY( BOOL, ContainsImages );
    CXMLItemList & GetItems() { return m_Items; }

protected:
    int m_Width;
    int m_SortOrder;
    COL_ALIGN m_Alignment;
    BOOL m_ContainsImages;
    CXMLItemList    m_Items;
};

typedef _List<CXMLColumn> CXMLColumnList;

class CXMLListViewStyle : public CXMLControlStyle
{
public:
    CXMLListViewStyle();
	virtual ~CXMLListViewStyle() {};
	typedef CXMLControlStyle BASECLASS;
	XML_CREATE( ListViewStyle );
    UINT    GetBaseStyles() { Init(); return listViewStyle; }
    void    Init();

protected:
// LVS_ICON                0x0000
// LVS_REPORT              0x0001   @DISPLAY="REPORT"
// LVS_SMALLICON           0x0002   @DISPLAY="SMALLICON"
// LVS_LIST                0x0003   @DISPLAY="LIST"
// LVS_TYPEMASK            0x0003

// LVS_SINGLESEL           0x0004   @SELECTION="SINGLE"
// LVS_SHOWSELALWAYS       0x0008   WIN32:TREEVIEW @SHOWSELALWAYS="YES"

// LVS_SORTASCENDING       0x0010   @SORT="ASCENDING"
// LVS_SORTDESCENDING      0x0020   @SORT="DESCENDING"
// LVS_SHAREIMAGELISTS     0x0040   WIN32:TREEVIEW @SHAREIMAGELIST="YES"
// LVS_NOLABELWRAP         0x0080   @NOLABELWRAP="YES"

// LVS_AUTOARRANGE         0x0100   @AUTOARRANGE="YES"
// LVS_EDITLABELS          0x0200   @EDITLABELS="YES"

// LVS_OWNERDATA           0x1000   WIN32:TREEVIEW @OWNERDATA="YES"
// LVS_NOSCROLL            0x2000   @NOSCROLL="YES"

// LVS_TYPESTYLEMASK       0xfc00

// LVS_ALIGNTOP            0x0000   @ALIGN="TOP"
// LVS_ALIGNLEFT           0x0800   @ALIGN="LEFT"
// LVS_ALIGNMASK           0x0c00

// LVS_OWNERDRAWFIXED      0x0400   WIN32:TREEVIEW @OWNERDRAWFIXED="YES"
// LVS_NOCOLUMNHEADER      0x4000   @NOCOLUMNHEADER="YES"
// LVS_NOSORTHEADER        0x8000   @NOSORTHEADER="YES"

    union
    {
        UINT    listViewStyle;
        struct {
            UINT    enum1:3;            // 0x000?
            BOOL    m_ShowSelAlways:1;

            UINT    enum2:2;            // 0x00?0
            BOOL    m_ShareImageLists:1;
            UINT    enum3:1;

            UINT    enum4:2;            // 0x0?00
            BOOL    m_OwnerDrawFixed:1; // 0x0400
            UINT    enum5:1;            // 1 bit nothing

            BOOL    m_OwnerData:1;      // 0x1000
            UINT    enum6:3;           // 1 bit nothing
        };
    };
};


class CXMLListView : public _XMLControl<IRCMLControl>  
{
public:
	CXMLListView();
	virtual ~CXMLListView() {delete m_pControlStyle;}
	typedef _XMLControl<IRCMLControl> BASECLASS;
	XML_CREATE( ListView );
    IMPLEMENTS_RCMLCONTROL_UNKNOWN;

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnInit( 
        HWND h);    // actually implemented

    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptChild( 
        IRCMLNode __RPC_FAR *child);

protected:
	void Init();
    CXMLListViewStyle * m_pControlStyle;
    CXMLColumnList      m_ColumnList;
    DWORD           m_EXStyles;
};

#endif // !defined(AFX_XMLLISTVIEW_H__C4CD3279_E4B0_4F47_A1F7_C662872DCD1A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmllocation.cpp ===
// XMLLocation.cpp: implementation of the CXMLLocation class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "XMLLocation.h"
#include "xmlcontrol.h"
#include "utils.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// XMLLocation goo,
//
CXMLLocation::CXMLLocation()
{
	m_bInit=FALSE;
	NODETYPE = NT_LOCATION;
    m_StringType=L"RELATIVE";
    m_RelativeX=FALSE;
    m_RelativeY=FALSE;
    m_RelativeWidth=FALSE;
    m_RelativeHeight=FALSE;
    m_bCalculated=FALSE;
    m_bInitRelativeTo=FALSE;
}

void CXMLLocation::InitRelativeTo()
{
    if(m_bInitRelativeTo)
        return;

    // Used by BuildRelationShips to work out relative guy - CANNOT call init.
    //
    // Relative to .. defaults to PREVIOUS
    // PAGE makes us INSIDE="YES" default.
    //
	m_RelativeID=0;
	LPCTSTR req=Get(TEXT("TO"));
    if( req==NULL)
    {
        req=TEXT("PREVIOUS");
        Set(TEXT("TO"),req);    // we need to fill the TO attribute in all the time.
    }

	m_Relative=RELATIVE_TO_NOTHING;
    if( lstrcmpi(req,TEXT("PREVIOUS"))==0 )
        m_Relative=RELATIVE_TO_PREVIOUS;
    else
	{
		m_RelativeID=_ttoi(req);
		if(m_RelativeID)
			m_Relative=RELATIVE_TO_CONTROL;
        else
        {
            if(lstrcmpi(req,TEXT("PAGE"))==0)
            {
                m_Relative=RELATIVE_TO_PAGE;
                m_RelativeID=0;
                //
                // we'll assume that INSIDE is now defaulted to TRUE.
                // if they had INSIDE="NO" this overrides us, if they had nothing
                // we get TRUE
                m_bInside=YesNo(TEXT("INSIDE"), TRUE );
            }
        }
	}

    m_bInitRelativeTo=TRUE;
}

//
// Final (we hope) schema.
//

//
// CORNER string 
// RELATIVETO = ordinal/name?
// RELATIVECORNER
// X
// Y
// ALIGN
//
// when ALIGN is used, you can modify the X and Y, but not the corners
//

//
// This is rather strange, as I need to pull out the - and + signs?
//
void CXMLLocation::Init()
{
	if(m_bInit)
		return;
	BASECLASS::Init();


    // Remember LOCATION is a child of the visual elements
    // and thus it is those which are Parent.
    m_Corner = m_RelativeCorner = LC_TOPLEFT;

    m_bInside=YesNo(TEXT("INSIDE"), FALSE );

	LPCTSTR req;
    IRCMLNode * pParent;
    if( SUCCEEDED( DetachParent( &pParent )))
    {
        // force parent to Init
        IRCMLControl * pControl;
        if( SUCCEEDED( pParent->QueryInterface( __uuidof( IRCMLControl ), (LPVOID*)&pControl )))
        {
            LONG lForceInit;
            pControl->get_X(&lForceInit);
            //
            // If they setup a shorthand, don't check the corners.
            //
            BOOL bCheckCorners=TRUE;
            if( req=Get(TEXT("ALIGN")) )
            {
                bCheckCorners=FALSE;
                if(lstrcmpi(req,TEXT("RIGHT"))==0)
                {
                    m_Corner        = LC_TOPLEFT  ;
                    m_RelativeCorner= LC_TOPRIGHT ;
                    m_RelativeX=m_RelativeY=TRUE;
                    pControl->put_X(  3 );
                    pControl->put_Y(  0 );
                }
                else if (lstrcmpi(req,TEXT("LEFT"))==0)
                {
                    m_Corner        = LC_TOPRIGHT ;
                    m_RelativeCorner= LC_TOPLEFT  ;
                    m_RelativeX=m_RelativeY=TRUE;
                    pControl->put_X(  -3 );
                    pControl->put_Y(  0 );
                }
                else if (lstrcmpi(req,TEXT("ABOVE"))==0)
                {
                    m_Corner        = LC_BOTTOMLEFT;
                    m_RelativeCorner= LC_TOPLEFT  ;
                    m_RelativeX=m_RelativeY=TRUE;
                    pControl->put_X(  0 );
                    pControl->put_Y( -3 );
                }
                else if (lstrcmpi(req,TEXT("BELOW"))==0)
                {
                    m_Corner        = LC_TOPLEFT  ;
                    m_RelativeCorner= LC_BOTTOMLEFT;
                    m_RelativeX=m_RelativeY=TRUE;
                    pControl->put_X(  0 );
                    pControl->put_Y(  +3 );
                }
                else if (lstrcmpi(req,TEXT("DROPLEFT"))==0)
                {
                    m_Corner        = LC_TOPLEFT  ;
                    m_RelativeCorner= LC_BOTTOMLEFT;
                    m_RelativeX=m_RelativeY=TRUE;
                    pControl->put_X( -3 );
                    pControl->put_Y( +3 );
                }
                else if (lstrcmpi(req,TEXT("DROPRIGHT"))==0)
                {
                    // Special case DROPRIGHT relative to a PAGE.
                    if( m_Relative==RELATIVE_TO_PAGE )
                    {
                        m_Corner        = LC_TOPLEFT;
                        m_RelativeCorner= LC_TOPLEFT;
                        m_RelativeX=m_RelativeY=TRUE;
                        pControl->put_X(  3 );
                        pControl->put_Y(  3 );
                    }
                    else
                    {
                        m_Corner        = LC_TOPLEFT  ;
                        m_RelativeCorner= LC_BOTTOMLEFT;
                        m_RelativeX=m_RelativeY=TRUE;
                        pControl->put_X(  3 );
                        pControl->put_Y(  3 );
                    }
                }
                else if(lstrcmpi(req,TEXT("TOPRIGHT"))==0)
                {
                    m_Corner        = LC_TOPRIGHT ;
                    m_RelativeCorner= LC_TOPRIGHT ;
                    m_RelativeX=m_RelativeY=TRUE;
                    pControl->put_X( -3 );
                    pControl->put_Y(  3 );
                }
                else if (lstrcmpi(req,TEXT("TOPLEFT"))==0)
                {
                    m_Corner        = LC_TOPLEFT ;
                    m_RelativeCorner= LC_TOPLEFT  ;
                    m_RelativeX=m_RelativeY=TRUE;
                    pControl->put_X( +3 );
                    pControl->put_Y( +3 );
                }
                else if (lstrcmpi(req,TEXT("BOTTOMRIGHT"))==0)
                {
                    m_Corner        = LC_BOTTOMRIGHT;
                    m_RelativeCorner= LC_BOTTOMRIGHT;
                    m_RelativeX=m_RelativeY=TRUE;
                    pControl->put_X( -3 );
                    pControl->put_Y( -3 );
                }
                else if (lstrcmpi(req,TEXT("BOTTOMLEFT"))==0)
                {
                    m_Corner        = LC_BOTTOMLEFT;
                    m_RelativeCorner= LC_BOTTOMLEFT;
                    m_RelativeX=m_RelativeY=TRUE;
                    pControl->put_X( +3 );
                    pControl->put_Y( -3 );
                }
                else
                {
                    bCheckCorners=TRUE;
                }
            }

            //
            // Valid shortcuts prevent CORNER and RELATIVECORNER attributes.
            //
            if(bCheckCorners)
            {
                m_Corner         = WhichCorner( Get(TEXT("CORNER")));
                m_RelativeCorner = WhichCorner( Get(TEXT("RELATIVECORNER")));
            }

            //
            // X & Y override everything that a shortcut can do.
            //
            if( req=Get( TEXT("X" ) ))
            {
                pControl->put_X( StringToInt( req ) );
                m_RelativeX=TRUE;
            }

            if( req=Get( TEXT("Y" ) ))
            {
                pControl->put_Y( StringToInt( req ) );
                m_RelativeY=TRUE;
            }

            //
            // What to do with width and height??
            //
            if( req=Get(TEXT("WIDTH")) )
            {
                if(lstrcmpi(req,TEXT("INHERIT"))==0)
                {
                    m_RelativeWidth=TRUE;
                    pControl->put_Width( StringToInt( req ) );
                }
            }


            if( req=Get(TEXT("HEIGHT")) )
            {
                if(lstrcmpi(req,TEXT("INHERIT"))==0)
                {
                    m_RelativeHeight=TRUE;
                    pControl->put_Height( StringToInt( req ) );
                }
            }

            pControl->Release();
        }
    }
    m_bCalculated=FALSE;
    m_bInit=TRUE;
}

////////////////////////////////////////////////////////////////////////////////////
//
// A rect of the control we are relative to,
// and the absolutes taken from the XML if any
//
////////////////////////////////////////////////////////////////////////////////////
RECT CXMLLocation::GetLocation(RECT r)
{
    if( m_bCalculated)
        return m_calcRect;

    Init();
	// this is the control we're laying out.
    IRCMLNode * pParent;
    if( SUCCEEDED( DetachParent( &pParent )))
    {
        IRCMLControl * pControl;
        if( SUCCEEDED( pParent->QueryInterface( __uuidof(IRCMLControl),(LPVOID*) &pControl )))
        {
            LONG    srcWidth  = r.right-r.left;
            LONG    srcHeight = r.bottom - r.top;

	        POINT p;
            
            pControl->get_X(&p.x);
            pControl->get_Y(&p.y);

            //
            // Src starts out as the top left of the control 
            // we are relative to.
            //
            POINT src;
            src.x=r.left;
            src.y=r.top;

            //
            // Work out which corner we are relative to,
            // rect.left and rec.right is the top left.
            //
            switch( m_RelativeCorner & LCD_SURFACE_MASK )
            {
            case LCD_TOP | LCD_BOTTOM:
                src.y += srcHeight/2;
                break;
            case LCD_TOP:
                break;
            case LCD_BOTTOM:
                src.y += srcHeight;
                break;
            }
    
            switch( m_RelativeCorner & LDC_SIDE_MASK )
            {
            case LCD_LEFT | LCD_RIGHT:
                src.x += srcWidth/2;
                break;
            case LCD_LEFT:
                break;
            case LCD_RIGHT:
                src.x += srcWidth;
                break;
            }

            //
            // src is now the point on the contrl we are relative to.
            // adjust it to be where we want our control.
            //
            src.x += p.x;
            src.y += p.y;

            //
            // Now move this top left, to where on our rect we want it.
            //
            LONG dstWidth;
            pControl->get_Width(&dstWidth);
            LONG dstHeight;
            pControl->get_Height(&dstHeight);
            if( m_RelativeWidth )
                dstWidth=srcWidth;

            if( m_RelativeHeight )
                dstHeight=srcHeight;


            switch( m_Corner & LCD_SURFACE_MASK )
            {
            case LCD_TOP | LCD_BOTTOM:
                src.y -= dstHeight/2;
                break;
            case LCD_TOP:
                break;
            case LCD_BOTTOM:
                src.y -= dstHeight;
                break;
            }
    
            switch( m_Corner & LDC_SIDE_MASK )
            {
            case LCD_LEFT | LCD_RIGHT:
                src.x -= dstWidth/2;
                break;
            case LCD_LEFT:
                break;
            case LCD_RIGHT:
                src.x -= dstWidth;
                break;
            }


            r.left = src.x;
            r.right = r.left +dstWidth;
            r.top= src.y;
            r.bottom = r.top + dstHeight;

            m_bCalculated=TRUE;
            m_calcRect=r;
            pControl->Release();	         
        }
    }
    return r;
}

CXMLLocation::CORNER_ENUM CXMLLocation::WhichCorner(LPCTSTR pszCorner)
{
    if(pszCorner)
    {
//    if( lstrcmpi(pszCorner, TEXT("") ) == 0 ) return LC;
        if( lstrcmpi(pszCorner, TEXT("TOPLEFT") ) == 0 ) return LC_TOPLEFT;
        if( lstrcmpi(pszCorner, TEXT("TOPMIDDLE") ) == 0 ) return LC_TOPMIDDLE;
        if( lstrcmpi(pszCorner, TEXT("TOPRIGHT") ) == 0 ) return LC_TOPRIGHT;
        if( lstrcmpi(pszCorner, TEXT("RIGHTMIDDLE") ) == 0 ) return LC_RIGHTMIDDLE;
        if( lstrcmpi(pszCorner, TEXT("BOTTOMRIGHT") ) == 0 ) return LC_BOTTOMRIGHT;
        if( lstrcmpi(pszCorner, TEXT("BOTTOMMIDDLE") ) == 0 ) return LC_BOTTOMMIDDLE;
        if( lstrcmpi(pszCorner, TEXT("BOTTOMLEFT") ) == 0 ) return LC_BOTTOMLEFT;
        if( lstrcmpi(pszCorner, TEXT("LEFTMIDDLE") ) == 0 ) return LC_LEFTMIDDLE;
        if( lstrcmpi(pszCorner, TEXT("CENTER") ) == 0 ) return LC_CENTER;
    }
    return LC_TOPLEFT;  // DEFAULTs?
//    return LC_UNKNOWN;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmllocation.h ===
// XMLLocation.h: interface for the CXMLLocation class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XMLLOCATION_H__0CF25EAB_395A_4C70_A05A_BB6716531311__INCLUDED_)
#define AFX_XMLLOCATION_H__0CF25EAB_395A_4C70_A05A_BB6716531311__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "xmlnode.h"

class CXMLLocation : public _XMLNode<IRCMLNode>
{
public:
	CXMLLocation();
	virtual ~CXMLLocation() {};
	typedef _XMLNode<IRCMLNode> BASECLASS;
    IMPLEMENTS_RCMLNODE_UNKNOWN;
   	XML_CREATE( Location );

	RECT	GetLocation( RECT rCurrent );

#define LCD_TOP    0x100
#define LCD_BOTTOM 0x200
#define LCD_SURFACE_MASK  0x300

#define LCD_LEFT   0x001
#define LCD_RIGHT  0x002
#define LDC_SIDE_MASK  0x003

    enum CORNER_ENUM
    {
        LC_UNKNOWN=0,
        LC_TOPLEFT          = LCD_TOP    | LCD_LEFT,
        LC_TOPMIDDLE        = LCD_TOP    | LCD_LEFT | LCD_RIGHT,
        LC_TOPRIGHT         = LCD_TOP    | LCD_RIGHT,
        LC_RIGHTMIDDLE      = LCD_RIGHT  | LCD_TOP | LCD_BOTTOM,
        LC_BOTTOMRIGHT      = LCD_BOTTOM | LCD_RIGHT,
        LC_BOTTOMMIDDLE     = LCD_BOTTOM | LCD_LEFT | LCD_RIGHT,
        LC_BOTTOMLEFT       = LCD_BOTTOM | LCD_LEFT,
        LC_LEFTMIDDLE       = LCD_LEFT   | LCD_TOP | LCD_BOTTOM,
        LC_CENTER           = LCD_LEFT   | LCD_RIGHT | LCD_TOP | LCD_BOTTOM,
    } ;

    //
    // NOTE - we use this as a 2 bit UINT.
    //
    enum RELATIVETYPE_ENUM
    {
        RELATIVE_TO_NOTHING=0,
        RELATIVE_TO_CONTROL,
        RELATIVE_TO_PREVIOUS,
        RELATIVE_TO_PAGE,
    };

	PROPERTY(CORNER_ENUM, Corner );
	PROPERTY(CORNER_ENUM, RelativeCorner );


    RELATIVETYPE_ENUM GetRelative () { InitRelativeTo(); return m_Relative; }       // Used by BuildRelationShips to work out relative guy
    WORD GetRelativeID() { InitRelativeTo(); return m_RelativeID; }
	void InitRelativeTo();

    static CORNER_ENUM WhichCorner(LPCTSTR pszString);

protected:
	void Init();
	CORNER_ENUM m_Corner;	// left, right, top, bottom
    CORNER_ENUM m_RelativeCorner;

    //
    // Used to indicate which of this controls
    // values, are offsets, and which are absolutes.
    // 
    struct
    {
        BOOL    m_RelativeX:1;
        BOOL    m_RelativeY:1;
        BOOL    m_RelativeWidth:1;
        BOOL    m_RelativeHeight:1;
        BOOL    m_bCalculated:1;
        RELATIVETYPE_ENUM m_Relative:3;
        BOOL    m_bInside:1;
        BOOL    m_bInitRelativeTo:1;
    };

	WORD		m_RelativeID;       // and is it RELATIVE="<id>"
    RECT        m_calcRect;
};

#endif // !defined(AFX_XMLLOCATION_H__0CF25EAB_395A_4C70_A05A_BB6716531311__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlnode.h ===
// XMLNode.h: interface for the CXMLNode class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XMLNODE_H__A31A1760_7120_40E1_B5F6_3D20962885BA__INCLUDED_)
#define AFX_XMLNODE_H__A31A1760_7120_40E1_B5F6_3D20962885BA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#undef PROPERTY
#define PROPERTY( type, id ) type Get##id() { Init(); return m_##id; }
#define XML_CREATE( name ) static IRCMLNode * newXML##name() { return (IRCMLNode*)new CXML##name(); }

#include "enumcontrols.h"

////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
//
// These templates used derived interfaces. ID1 is the base ...
// these don't declare what they can do, e.g. no public ID3, this is done on the class
// passed in.
//
template <class C> class _partialUnknown : public C
{
public:        
        _partialUnknown () 
        { _refcount = 0; }

        virtual ~_partialUnknown ()
        { }

        virtual ULONG STDMETHODCALLTYPE AddRef( void)
        { return InterlockedIncrement(&_refcount); }
    
        virtual ULONG STDMETHODCALLTYPE Release( void)
        {
            if (InterlockedDecrement(&_refcount) == 0)
            {
                delete this;
                return 0;
            }
            return _refcount;
        }
protected:    
    long _refcount;
};

#if 0
////////////////////////////////////////////////////////////////////////////////////////////////
///// T H I S   I S   H O W   T H E  I N T E R F A C E   I N H E R I T A N C E   L O O K S /////
////////////////////////////////////////////////////////////////////////////////////////////////
                
template <class exposedInterface> class ImpIF1 : public _partialUnknown<exposedInterface>
{
public:
    ImpIF1() {};
    virtual ~ImpIF1() {};

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Get1( void)
    { return E_FAIL; }

};

template <class exposedInterface> class ImpIF2 : public ImpIF1<exposedInterface>
{
public:
    ImpIF2() {};
    virtual ~ImpIF2() {};

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Get2( void)
    { return E_FAIL; }

};

template <class exposedInterface> class ImpIF3 : public ImpIF2<exposedInterface>
{
public:
    ImpIF3() {};
    virtual ~ImpIF3() {};

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Get3( void)
    { return E_FAIL; }

};
////////////////////////////////////////////////////////////////////////////////////////////////
///// T H I S   I S   H O W   T H E  I N T E R F A C E   I N H E R I T A N C E   L O O K S /////
////////////////////////////////////////////////////////////////////////////////////////////////
#endif

#include "RCMLPub.h"    // the .h of the IDL.

#define _COMPROPERTY( type, dataMember ) { Init(); *pVal = m_##dataMember; return S_OK; }
#define _COMPROPERTYPUT( type, dataMember ) { m_##dataMember=Val; return S_OK; }
#include "quickref.h"

//
// This is a list of the IRCMLNode which become children of the IRCMLControl
// and IRCMLNode
//
#include "list.h"
typedef _RefcountList<IRCMLNode>        CRCMLNodeList;       // calls release on the elements.

// Forward references.
class CXMLWin32;
class CParentInfo;
class CLayoutInfo;
class CXMLLocation;

//
// Node types
//
    //
    //  Should this be in the IDL??
    //
  	typedef enum _ENUM_NODETYPE
	{
        NT_RCML,        // main parent.
            NT_LOGINFO,         // LOGINFO

        NT_PLATFORM,    // platform information

        NT_FORMS,       // a container of FORM

		NT_DIALOG,      // a FORM
            NT_CAPTION,         // title, minimize/max/close buttons.
            NT_FORMOPTIONS,     // frame, drop target,

        NT_LAYOUT,          // contains layout managers.
		    NT_WIN32LAYOUT,
                NT_GRID,

		NT_CONTROL,
            NT_WIN32,           // the win32 specific style bits.

		NT_LOCATION,
		NT_STYLE,

		NT_EDIT,
            NT_EDITSTYLE,       // WIN32:EDIT

		NT_BUTTON,
            NT_BUTTONSTYLE,     // WIN32:BUTTON WIN32:CHECKBOX WIN32:RADIBUTTON WIN32:GROUPBOX
		NT_RADIO,
		NT_CHECKBOX,
		NT_GROUPBOX,

		NT_STATIC,
            NT_STATICSTYLE,     // WIN32:IMAGE WIN32:RECT WIN32:LABEL
		NT_IMAGE,

        NT_SCROLLBAR,
            NT_SCROLLBARSTYLE,

		NT_COMBO,
            NT_COMBOSTYLE,      // WIN32:COMBOBOX

		NT_LIST,
            NT_LISTBOXSTYLE,    // WIN32:LISTBOX

		NT_SLIDER,
		NT_SPINNER,
		NT_PROGRESS,
		NT_LISTVIEW,
    		NT_LISTVIEWSTYLE,
            NT_COLUMN,

		NT_TREEVIEW,
    		NT_TREEVIEWSTYLE,

		NT_RECT,

		NT_HELP,
		    NT_BALLOON,
		    NT_TOOLTIP,

		NT_OPTIONAL,

        NT_STRINGTABLE,
            NT_ITEM,

        NT_RANGE,

        NT_PAGER,
        NT_REBAR,
        NT_STATUSBAR,
        NT_ANMATION,        // same as NT_IMAGE??
        NT_HEADER,
        NT_TAB,
            NT_TABSTYLE,
        NT_TOOLBAR

	};

////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
//
// This template is the "Bottom" of the interface inheritance chain (ignoring IUnknown)
// the exposedInterface is the "Top" interface which you're deriving from
//
// it does some 'nice' things like keeping a list of the 'unknown' children, mainly
// for extensibility reasons.
//
#include "stringproperty.h"
template <class exposedInterface> class _XMLNode : 
                                public _partialUnknown<exposedInterface>,
                                public CStringPropertySection
{
public:
    _XMLNode() :
    m_bInit(FALSE) , m_pParent(NULL), m_StringType(TEXT("Un-defined"))
    { //_refcount=1;
    }

    virtual ~_XMLNode() // should only be called from a Release()
    {
        // if(m_pParent) m_pParent->Release(); // weak parent chain.
    };

    //
    // IRCMLNode
    //
        STDMETHOD(DetachParent)(IRCMLNode **pVal)
        { 
            *pVal = m_pParent;
            if( m_pParent==NULL )
                return E_FAIL;
            // m_pParent->AddRef();
            return S_OK;
        }

        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE AttachParent( 
            /* [in] */ IRCMLNode __RPC_FAR *newVal)
        {
            // if(m_pParent) m_pParent->Release();
            m_pParent=newVal;
            // if(m_pParent) m_pParent->AddRef();
            return S_OK;
        }

        //
        // By default we do not add any children.
        //
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptChild( 
            IRCMLNode __RPC_FAR *pChild)
        {
            LPWSTR pType;
            LPWSTR pChildType;
            get_StringType( &pType );
            pChild->get_StringType( &pChildType );

            EVENTLOG( EVENTLOG_ERROR_TYPE, LOGCAT_LOADER , 1, 
                TEXT("Parser"), TEXT("The node %s cannot take a %s as a child"), 
                pType, pChildType );

            m_UnknownChildren.Append( pChild );
            return S_OK;    // we take children.
        }
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DoEndChild( 
            IRCMLNode __RPC_FAR *child)
        {
            return S_OK;
        }
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ UINT __RPC_FAR *pVal)
        {
            *pVal = NODETYPE;
            return S_OK;
        }
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InitNode( 
            IRCMLNode __RPC_FAR *parent)
        {
            return S_OK;
        }
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DisplayNode( 
            IRCMLNode __RPC_FAR *parent)
        {
            return S_OK;
        }
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExitNode( 
            IRCMLNode __RPC_FAR *parent, LONG lDialogResult)
        {
            return S_OK;
        }
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Attr( 
            LPCWSTR index,
            /* [retval][out] */ LPWSTR __RPC_FAR *pVal)
        {
            *pVal = (LPWSTR)CStringPropertySection::Get(index);
            if( *pVal )
                return S_OK;
            return E_INVALIDARG;    // HMM, we don't have this attribute, but is it failure?
        }
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Attr( 
            LPCWSTR index,
            /* [in] */ LPCWSTR newVal)
        {
            CStringPropertySection::Set(index, newVal);
            return S_OK;
        }
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsType( 
            LPCWSTR nodeName)
        {
            if( lstrcmpi(nodeName, m_StringType) == 0 )
                return S_OK;
            return E_FAIL;  // OK, so it's not really a failure REVIEW!
        }
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE YesDefault( 
            /* [in] */ LPCWSTR propID,
            /* [in] */ DWORD dwNotPresent,
            /* [in] */ DWORD dwYes,
            /* [retval][out] */ DWORD __RPC_FAR *pdwValue)
        {
            *pdwValue = CStringPropertySection::YesNo(propID, dwNotPresent, dwYes);
            return S_OK;
        }
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE YesNoDefault( 
            /* [in] */ LPCWSTR propID,
            /* [in] */ DWORD dwNotPresent,
            /* [in] */ DWORD dwNo,
            /* [in] */ DWORD dwYes,
            /* [retval][out] */ DWORD __RPC_FAR *pdwValue)
        {
            *pdwValue = CStringPropertySection::YesNo(propID, dwNotPresent, dwNo, dwYes);
            return S_OK;
        }
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ValueOf( 
            /* [in] */ LPCWSTR propID,
            /* [in] */ DWORD dwNotPresent,
            /* [retval][out] */ DWORD __RPC_FAR *pdwValue)
        {
            *pdwValue = CStringPropertySection::ValueOf(propID, dwNotPresent);
            return S_OK;
        }

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SignedValueOf( 
            /* [in] */ LPCWSTR propID,
            /* [in] */ int dwNotPresent,
            /* [retval][out] */ int __RPC_FAR *pdwValue)
        {
            *pdwValue = CStringPropertySection::ValueOf(propID, dwNotPresent);
            return S_OK;
        }

        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_StringType( 
            /* [retval][out] */ LPWSTR __RPC_FAR *pStringType)
        {
            *pStringType = (LPWSTR)m_StringType;
            return S_OK;
        }

        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetChildEnum( 
            IEnumUnknown __RPC_FAR *__RPC_FAR *pEnum) { return E_NOTIMPL; }

        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetUnknownEnum( 
            IEnumUnknown __RPC_FAR *__RPC_FAR *pEnum)
        {
            if( pEnum )
            {
                *pEnum = new CEnumControls<CRCMLNodeList>(m_UnknownChildren);
                (*pEnum)->AddRef();
                return S_OK;
            }
            return E_FAIL;
        }

	virtual void	Init() {};


private:
	IRCMLNode * m_pParent;

protected:
	BOOL	        m_bInit;
    LPCTSTR         m_StringType;
    _ENUM_NODETYPE  NODETYPE;
   	CRCMLNodeList	  m_UnknownChildren;
};

////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
//
// Implements both the IRCMLControl interface
// and private methods, such as Init
//
#undef PROPERTY
#define PROPERTY( type, id ) type Get##id() { Init(); return m_##id; } void Set##id(type v) { m_##id=v; }

template <class exposedInterface> class _XMLControl : public _XMLNode<exposedInterface>
{
public:
    typedef _XMLNode<exposedInterface> BASECLASS;
    _XMLControl()
    {
	    m_bInit=FALSE;
	    NODETYPE = NT_CONTROL;
        m_StringType= L"CONTROL";

	    m_pLocation=NULL;
	    m_qrRelativeTo=NULL;	// used for relative positioning - done in a second pass after building the tree.
	    m_qrHelp=NULL;
	    m_Clipped.cx=m_Clipped.cy=0;
        m_pContainer=NULL;
        m_qrWin32Style=NULL;

        //
        // Resize information
        //
        m_GrowsWide=FALSE;
        m_GrowsHigh=FALSE;

        m_ClipHoriz=FALSE;
        m_ClipVert=FALSE;

        m_bCheckClipped=FALSE;
        m_ClippingSet=FALSE;

        m_qrCSS=NULL;
    }

    virtual ~_XMLControl()
    {
        m_pContainer=NULL;
        m_qrHelp=NULL;
        m_qrCSS=NULL;
	    m_pLocation=NULL;
        m_qrWin32Style=NULL;
    }
#ifdef _DEBUG
     virtual ULONG STDMETHODCALLTYPE AddRef( void)
     {
         if(_refcount)
         {
             int i=5;
         }

         return BASECLASS::AddRef();
     }
#endif


    // All controls have some understanding of children, from IRCMLNode
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptChild( 
        IRCMLNode __RPC_FAR *pChild); // implemented        

    // IRCMLControl implementations
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Class( 
            /* [retval][out] */ LPWSTR __RPC_FAR *pVal)
            _COMPROPERTY( LPWSTR, Class );
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Style( 
            /* [retval][out] */ DWORD __RPC_FAR *pVal)
            _COMPROPERTY( DWORD, Style );
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_StyleEx( 
            /* [retval][out] */ DWORD __RPC_FAR *pVal)
            _COMPROPERTY( DWORD, StyleEx );
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Text( 
            /* [retval][out] */ LPWSTR __RPC_FAR *pVal)
            _COMPROPERTY( LPCWSTR, Text );
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnInit( 
            HWND h);    // actually implemented
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ID( 
            /* [retval][out] */ LPWSTR __RPC_FAR *pVal)
            _COMPROPERTY( LPWSTR, ID );
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Width( 
            /* [retval][out] */ LONG __RPC_FAR *pVal)
            _COMPROPERTY( LONG, Width );
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Height( 
            /* [retval][out] */ LONG __RPC_FAR *pVal)
            _COMPROPERTY( LONG, Height );

        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Width( 
            /* [in] */ LONG Val)
            _COMPROPERTYPUT( LONG, Width );
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Height( 
            /* [in] */ LONG Val)
            _COMPROPERTYPUT( LONG, Height );
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_X( 
            /* [retval][out] */ LONG __RPC_FAR *pVal)
            _COMPROPERTY( LONG, X );

        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Y( 
            /* [retval][out] */ LONG __RPC_FAR *pVal)
            _COMPROPERTY( LONG, Y );

        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_X( 
            /* [in] */ LONG Val)
            _COMPROPERTYPUT( LONG, X );
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Y( 
            /* [in] */ LONG Val)
            _COMPROPERTYPUT( LONG, Y );
       
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Window( 
            /* [retval][out] */ HWND __RPC_FAR *pVal)
            _COMPROPERTY( HWND , hWnd );

       virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE put_Window( 
            /* [retval][out] */ HWND __RPC_FAR hwnd)
       { m_hWnd = hwnd; return S_OK; }

        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnDestroy( 
            HWND h,
            WORD wLastCommand); // actually implemented
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_RelativeTo( 
            /* [retval][out] */ IRCMLControl __RPC_FAR *__RPC_FAR *pVal)
        {
            *pVal=m_qrRelativeTo.GetInterface();
            if(*pVal)
                (*pVal)->AddRef();
            return S_OK;
        }
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_RelativeTo( 
            /* [in] */ IRCMLControl __RPC_FAR *newVal)
        { 
            m_qrRelativeTo=newVal;
            return S_OK;
        }
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Location( 
            /* [retval][out] */ RECT __RPC_FAR *pVal);
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_RelativeLocn( 
            RECT rect,
            /* [retval][out] */ RECT __RPC_FAR *pVal)
        { return E_FAIL; }
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_RelativeID( 
            /* [retval][out] */ LPWSTR __RPC_FAR *pVal)
        {
            if( m_pLocation.GetInterface() )
                return m_pLocation->get_Attr( L"TO", pVal );
            return E_INVALIDARG;
        }
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_RelativeType( 
            /* [retval][out] */ RELATIVETYPE_ENUM __RPC_FAR *pVal)
        { 
            if( pVal == NULL )
                return E_INVALIDARG;

            if( m_pLocation.GetInterface() )
            {
                *pVal = (RELATIVETYPE_ENUM)m_pLocation->GetRelative();
            }
            else
                * pVal = (RELATIVETYPE_ENUM)CXMLLocation::RELATIVE_TO_NOTHING; 
            return S_OK;
        }
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Clipped( 
            /* [retval][out] */ SIZE __RPC_FAR *pVal)
        { 
            if( m_bCheckClipped==FALSE )
            {
                CheckClipped();
                m_bCheckClipped=TRUE;
            }
            if( pVal )
            {
                CopyMemory( pVal, &m_Clipped, sizeof( SIZE) );
                return S_OK;
            }
            return E_INVALIDARG;
        }
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_GrowsWide( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal)
        {
            if( pVal )
            {
                *pVal = m_GrowsWide;
                return S_OK;
            }
            return E_INVALIDARG;
        }
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_GrowsTall( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal)
        { 
            if( pVal )
            {
                *pVal = m_GrowsHigh;
                return S_OK;
            }
            return E_INVALIDARG;
        }

        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Container( 
            /* [retval][out] */ IRCMLContainer __RPC_FAR * * pContainer)
        {
            HRESULT hres=E_FAIL;
            if(m_pContainer)
            {
                *pContainer = m_pContainer;         // weak reference
                hres=S_OK;
            }
            else
            {
                IRCMLContainer * pTempContainer;
                if( SUCCEEDED( hres=QueryInterface( __uuidof( IRCMLContainer ), (LPVOID*)&pTempContainer)))
                {
                    *pContainer=pTempContainer;
                    m_pContainer=pTempContainer;
                    pTempContainer->Release();      // weak reference
                }
                else
                {
                    IRCMLNode * pNode;
                    if( SUCCEEDED( hres=DetachParent( &pNode )) )
                    {
                        if( SUCCEEDED( hres=pNode->QueryInterface( __uuidof( IRCMLContainer ), (LPVOID*)&pTempContainer)))
                        {
                            *pContainer=pTempContainer;
                            m_pContainer=pTempContainer;
                            pTempContainer->Release();      // weak reference.
                        }
                    }
                }
            }
            return hres;
        }


        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Container( 
            /* [in] */ IRCMLContainer __RPC_FAR *pContainer)
        { 
            m_pContainer=pContainer;
            return S_OK;
        }

        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CSS( 
            /* [retval][out] */ IRCMLCSS __RPC_FAR *__RPC_FAR *pCSS); // actually implemented
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_CSS( 
            /* [in] */ IRCMLCSS __RPC_FAR *pCSS)
        { 
            m_qrCSS=pCSS;
            return S_OK;
        }

        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Help( 
            /* [retval][out] */ IRCMLHelp __RPC_FAR *__RPC_FAR *pHelp)
        {
            if( m_qrHelp.GetInterface()==NULL )
                return E_FAIL;
            *pHelp=m_qrHelp.GetInterface();
            if(*pHelp)
                (*pHelp)->AddRef();
            return S_OK;
        }

        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetUnknownEnum( 
            IEnumUnknown __RPC_FAR *__RPC_FAR *pEnum);

       	void		put_Help( IRCMLHelp *pHelp )	{ m_qrHelp=pHelp; }

protected:
        // Provides global edge drawing for all drived classes
	void		DrawEdge(HDC hdc, LPRECT innerRect);

private:
//
// P R I V A T E   I M P L E M E N T A T I O N   M E T H O D S 
// you REALLY shouldn't call these methods unless you KNOW we created the element.
//

protected:
    // We contain a node, we pass through it's methods
   	CRCMLNodeList	  m_UnknownChildren;    // not sure if it's correct to make the CRCMLNodeList

    //
    // These are all possible children of this control.
    // they should ideally all be Interfaces themselves.
    //
    CQuickRef<CXMLWin32>  m_qrWin32Style;        // WIN32 styles.

    IRCMLContainer  * GetContainer()
    {
        HRESULT hres;
        if(m_pContainer) 
            return m_pContainer; 
        IRCMLContainer * pC; 
        if( SUCCEEDED(hres=get_Container(&pC) ))   // sets m_pContainer
            return pC; 
        return NULL;
    }

    // NOT REFCOUNTED - as that introduces circular references.
    IRCMLContainer * m_pContainer;         // REVIEW can we be contained by a non-visual thing?

	CQuickRef<IRCMLControl> m_qrRelativeTo;
	CQuickRef<CXMLLocation>	m_pLocation;
	CQuickRef<IRCMLHelp> m_qrHelp;

    // We keep a ref to the following pieces of information.
    void    InitCSS();
	CQuickRef<IRCMLCSS> m_qrCSS;

	DWORD		m_Style;        // got from WIN32 element.
	DWORD		m_StyleEx;

	LONG        m_X;
	LONG        m_Y;
	LONG        m_Width;
	LONG        m_Height;

	LPWSTR		m_ID;       // string or value - but always UNICODE.

	LPWSTR		m_Class;
	LPWSTR		m_Text;

	SIZE		m_Clipped; 
    virtual void  CheckClipped() {}; // sets m_Clipped to the amount we're clipped by.

    HWND            m_hWnd;

	virtual void Init();

protected:
	void		InitRelative();	// needed because the relative parenting cannot access all properties.
    struct
    {
        BOOL		m_bInit:1;
        BOOL        m_bCheckClipped:1;
        BOOL        m_GrowsWide:1;
        BOOL        m_GrowsHigh:1;
        BOOL        m_ResizeSet:1;  // the derived controls should NOT set GrowsWide/High, set by CSS.
        BOOL        m_ClippingSet:1;
        BOOL        m_ClipHoriz:1;
        BOOL        m_ClipVert:1;
    };
};

#define IMPLEMENTS_RCMLCONTROL_UNKNOWN \
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void ** ppvObject) \
    {   if (riid == IID_IUnknown) \
            *ppvObject = static_cast<IUnknown*>(this);  \
        else if (riid == __uuidof(IRCMLNode))           \
            *ppvObject = static_cast<IRCMLNode*>(this); \
        else if (riid == __uuidof(IRCMLControl))        \
            *ppvObject = static_cast<IRCMLControl*>(this); \
        else \
            { *ppvObject = NULL; return E_NOINTERFACE; } \
        reinterpret_cast<IUnknown*>(*ppvObject)->AddRef(); \
    return S_OK; }

#define IMPLEMENTS_RCMLNODE_UNKNOWN \
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void ** ppvObject) \
    {   if (riid == IID_IUnknown) \
            *ppvObject = static_cast<IUnknown*>(this);  \
        else if (riid == __uuidof(IRCMLNode))           \
            *ppvObject = static_cast<IRCMLNode*>(this); \
        else \
           { *ppvObject = NULL; return E_NOINTERFACE; } \
        reinterpret_cast<IUnknown*>(*ppvObject)->AddRef(); \
    return S_OK; }

// Just a pure interface, no 'smart' refcounting.
#define ACCEPTCHILD( nodeName, dataType, dataMember ) \
    if( SUCCEEDED( pChild->IsType( nodeName ) )) \
    {   if(pChild) pChild->AddRef(); \
        if(dataMember) dataMember->Release();   \
        dataMember=(dataType *)pChild; \
        return S_OK; }

// Assumes use of CQuickRef for the data member.
#define ACCEPTREFCHILD( nodeName, dataType, dataMember ) \
    if( SUCCEEDED( pChild->IsType( nodeName ) )) \
    {   dataMember=(dataType *)pChild; return S_OK; }


template <class exposedInterface> class _XMLContainer : public _XMLControl<exposedInterface>
{
public:
    _XMLContainer() {};
    virtual ~_XMLContainer() {};

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPixelLocation( 
        /* [in] */ IRCMLControl __RPC_FAR *__MIDL_0015,
        /* [retval][out] */ RECT __RPC_FAR *pRect) = 0;
};

typedef _RefcountList<IRCMLControl> IRCMLControlList;

#undef PROPERTY
#define PROPERTY( type, id ) type Get##id() { Init(); return m_##id; }

#endif // !defined(AFX_XMLNODE_H__A31A1760_7120_40E1_B5F6_3D20962885BA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlnodefactory.cpp ===
// libcmtd.lib 
// 

#include "stdafx.h"
#include "xmlnodefactory.h"

CXMLNodeFactory::CXMLNodeFactory()
{
    errorState = S_OK;
	m_cbXMLFragment=0x20; // 80;   // intial fragment size.
    m_XMLFragment=new TCHAR[m_cbXMLFragment];

    m_cbNSFragment=0x8;     // space so we have a null terminated string as we have no name-space initially.
    m_NSFragment=new TCHAR[m_cbNSFragment];
}

CXMLNodeFactory::~CXMLNodeFactory()
{
	delete m_XMLFragment;
    delete m_NSFragment;
}


/*++

Routine Description:

    Receive event notifications from XML parser

Arguments:

    pSource - Pointer to XML parser object
    iEvt - Specify the event

Return Value:

    S_OK

--*/

HRESULT STDMETHODCALLTYPE
CXMLNodeFactory::NotifyEvent( IXMLNodeSource *pSource, XML_NODEFACTORY_EVENT iEvt)

{
    static LPCTSTR eventstrs[] =
    {
        TEXT("XMLNF_STARTDOCUMENT"),
        TEXT("XMLNF_STARTDTD"),
        TEXT("XMLNF_ENDDTD"),
        TEXT("XMLNF_STARTDTDSUBSET"),
        TEXT("XMLNF_STARTSCHEMA"),
        TEXT("LXMLNF_ENDSCHEMA"),
        TEXT("XMLNF_ENDDTDSUBSET"),
        TEXT("XMLNF_ENDPROLOG"),
        TEXT("XMLNF_ENDENTITY"),
        TEXT("XMLNF_ENDDOCUMENT"),
        TEXT("XMLNF_DATAAVAILABLE"),
    };

    TRACE(TEXT("NotifyEvent: %s\n"), eventstrs[iEvt]);
    if( iEvt == XMLNF_ENDDOCUMENT )
    {
        delete m_XMLFragment;
        m_cbXMLFragment=0;
        m_XMLFragment=NULL;
    }
    return S_OK;
}


/*++

Routine Description:

    Called when XML parser detects an error

Arguments:

    pSource - Pointer to XML parser object
    pNodeInfo
    hrErrorCode

Return Value:

    Error code

--*/
HRESULT STDMETHODCALLTYPE
CXMLNodeFactory::Error( 
	        /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ HRESULT hrErrorCode,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo)
{
    TRACE(TEXT("NodeFactory Error: 0x%x\n"), hrErrorCode);

    return setError(hrErrorCode);
}


/*++

Routine Description:

    Called when a node may contain children

Arguments:

    pSource - Pointer to XML parser object
    pNodeInfo - Current XML node

Return Value:

    S_OK

--*/
HRESULT STDMETHODCALLTYPE
CXMLNodeFactory::BeginChildren( IXMLNodeSource *pSource, XML_NODE_INFO *pNodeInfo )
{
	GetXMLFragment( pNodeInfo );
	SetSource(pSource);
	SetNodeInfo(pNodeInfo);
	SetParentNode(pNodeInfo->pNode);		// ????
	return DoStartChild( m_XMLFragment );
}


/*++

Routine Description:

    Called when all subelements of the current element are complete

Arguments:

    pSource - Pointer to XML parser object
    fEmpty - whether current node was empty
    pNodeInfo - Current XML node

Return Value:

    S_OK if successful, error code otherwise

--*/

HRESULT STDMETHODCALLTYPE
CXMLNodeFactory::EndChildren( IXMLNodeSource *pSource, BOOL fEmpty, XML_NODE_INFO *pNodeInfo )
{
    // TRACE(TEXT("EndChildren\n"));

	GetXMLFragment( pNodeInfo );
	SetSource(pSource);
	SetNodeInfo(pNodeInfo);
	SetParentNode(NULL);
	return DoEndChild(m_XMLFragment);
}


/*++

Routine Description:

    Called when an element is parsed

Arguments:

    pSource - Pointer to XML parser object
    pNodeParent - Pointer to parent node (returned from previous calls)
    cNumRecs - Number of XML_NODE_INFO structures to follow
    pNodeInfo - Pointer to array of XML_NODE_INFO structures

Return Value:

    S_OK if successful, error code otherwise

--*/

HRESULT STDMETHODCALLTYPE
CXMLNodeFactory::CreateNode( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ PVOID pNodeParent,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo)
{
    HRESULT hr = getError();

    XML_NODE_INFO* node;
	XML_NODE_INFO ** pArrayOfNodes = apNodeInfo;
	int iCount=0;
	node = pArrayOfNodes[iCount];

    ASSERT(cNumRecs > 0);

	SetSource( pSource );
	SetParentNode( pNodeParent );
    while (SUCCEEDED(hr) && cNumRecs > 0)
    {
		node = pArrayOfNodes[iCount];
		SetNodeInfo( node );
		if(node->pNode==NULL)
			node->pNode=pNodeParent;
		else
			TRACE(TEXT("Hmm"));

		GetXMLFragment( node );

        switch (node->dwType)
        {
        case XML_ELEMENT:
			DoElement(m_XMLFragment, m_NSFragment);
			pNodeParent=node->pNode;
			break;

        case XML_ATTRIBUTE:
			DoAttribute(m_XMLFragment);
            break;

        case XML_PCDATA:
			DoData(m_XMLFragment);
            break;

		case XML_WHITESPACE:
			break;

        case XML_ENTITYREF:
            //
            //
            //
            TRACE(TEXT("Work out the etity '%s'\n"), m_XMLFragment);
            DoData( DoEntityRef(m_XMLFragment) );
            break;


        case XML_XMLDECL:       // ?xml version ...?
		default:
			TRACE(TEXT("  unhandled create NODE type : %s : %s\n"), typestr(node->dwType),(LPCTSTR)m_XMLFragment);
			break;

        }

        cNumRecs--;
        node++;
		iCount++;
    }

    if (!SUCCEEDED(hr))
        return setError(hr);

	return getError();
}

HRESULT CXMLNodeFactory::DoElement(LPCTSTR text, LPCTSTR ns)
{
	return S_OK;
}

HRESULT CXMLNodeFactory::DoAttribute(LPCTSTR text)
{
	return S_OK;
}

HRESULT CXMLNodeFactory::DoData(LPCTSTR text)
{
	return S_OK;
}

#define _MEM_DEBUG
#ifdef _MEM_DEBUG
DWORD g_xmlSize=0;
#endif
void CXMLNodeFactory::GetXMLFragment( XML_NODE_INFO * node )
{
	/*
	LPTSTR pszBuffer=m_XMLFragment.GetBuffer( node->ulLen );
	CopyMemory(pszBuffer, node->pwcText, (node->ulLen+1)*sizeof(WCHAR));
	m_XMLFragment.ReleaseBuffer(node->ulLen);
	*/

    //
    // Make sure our buffer is big enough for the element name, including namespace prefix.
    //
    int elementStart = node->ulNsPrefixLen ? node->ulNsPrefixLen+1 : 0;
    DWORD cbElement = node->ulLen - elementStart;
	if( m_cbXMLFragment <= cbElement )
	{
		delete m_XMLFragment;
		m_cbXMLFragment=cbElement*2;
		m_XMLFragment=new TCHAR[m_cbXMLFragment];
	}

    //
    // Copy the element and namespace prefix.
    //

#ifndef UNICODE
	WideCharToMultiByte(CP_ACP, 0, &(node->pwcText[elementStart]), cbElement+1, m_XMLFragment, m_cbXMLFragment, NULL, NULL);
#else
	CopyMemory(m_XMLFragment, &(node->pwcText[elementStart]), (cbElement)*sizeof(WCHAR));
#endif
	m_XMLFragment[cbElement]=0;
#ifdef _MEM_DEBUG
    g_xmlSize+=node->ulLen;
#endif

    //
    // get the NameSpace prefix
    //
    if( node->ulNsPrefixLen )
    {
	    if( m_cbNSFragment <= node->ulNsPrefixLen )
	    {
		    delete m_NSFragment;
		    m_cbNSFragment=node->ulNsPrefixLen*2;
		    m_NSFragment=new TCHAR[m_cbNSFragment];
	    }
#ifndef UNICODE
	    WideCharToMultiByte(CP_ACP, 0, node->pwcText, node->ulNsPrefixLen+1, m_NSFragment, m_cbNSFragment, NULL, NULL);
#else
	    CopyMemory(m_NSFragment, node->pwcText, (node->ulNsPrefixLen)*sizeof(WCHAR));
#endif
    }
	m_NSFragment[node->ulNsPrefixLen]=0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlnode.cpp ===
// XMLNode.cpp: implementation of the CXMLNode class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "XMLNode.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmllog.h ===
// XMLLog.h: interface for the CXMLLog class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XMLLOG_H__0E4D27E0_05C4_41AC_95C7_4BAF52CF33C1__INCLUDED_)
#define AFX_XMLLOG_H__0E4D27E0_05C4_41AC_95C7_4BAF52CF33C1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "xmlnode.h"

class CXMLLog : public _XMLNode<IRCMLNode>
{
public:
	CXMLLog();
	virtual ~CXMLLog();
	typedef _XMLNode<IRCMLNode> BASECLASS;
    IMPLEMENTS_RCMLNODE_UNKNOWN;
	XML_CREATE( Log );
    void    Init();

    //
    // specify the 'verbosity' level
    // LOADER="ERRORS" ="WARNING" ="INFORMATION"
    //

    PROPERTY( BOOL, UseEventLog );
    PROPERTY( UINT, Loader );           // XML loader logs processing
    PROPERTY( UINT, Construct );        // logs the building of the dialog
    PROPERTY( UINT, Runtime );          // logs the runtime effort
    PROPERTY( UINT, Resize );           // logs the resize effort
    PROPERTY( UINT, Clipping );           // logs the resize effort

private:
    UINT Kind( LPCTSTR pszKind );

    BOOL    m_UseEventLog;
    UINT    m_Loader;
    UINT    m_Construct;
    UINT    m_Runtime;
    UINT    m_Resize;
    UINT    m_Clipping;
};

#endif // !defined(AFX_XMLLOG_H__0E4D27E0_05C4_41AC_95C7_4BAF52CF33C1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmllog.cpp ===
// XMLLog.cpp: implementation of the CXMLLog class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "XMLLog.h"
#include "eventlog.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CXMLLog::CXMLLog()
{
	m_bInit=FALSE;
	NODETYPE = NT_LOGINFO;
    m_StringType=L"LOGINFO";
}

CXMLLog::~CXMLLog()
{

}

void CXMLLog::Init()
{
    if(m_bInit)
        return;
    BASECLASS::Init();

    m_UseEventLog = YesNo(TEXT("EVENTLOG"),FALSE);

    m_Loader=Kind(Get(TEXT("LOADER")));
    m_Construct=Kind(Get(TEXT("CONSTRUCT")));
    m_Runtime=Kind(Get(TEXT("RUNTIME")));
    m_Resize=Kind(Get(TEXT("RESIZE")));
    m_Clipping=Kind(Get(TEXT("CLIPPING")));

    m_bInit=TRUE;
}

UINT CXMLLog::Kind( LPCTSTR pszKind )
{
    if(pszKind==NULL)
        return 0;
    if( lstrcmpi(pszKind, TEXT("ERROR")) ==0)
        return EVENTLOG_ERROR_TYPE;
    if( lstrcmpi(pszKind, TEXT("WARNING")) ==0)
        return EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE ;
    if( lstrcmpi(pszKind, TEXT("INFORMATION")) ==0)
        return EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlnodefactory.h ===
#ifndef _XML_NODE_FACTORY_H
#define _XML_NODE_FACTORY_H
#include "unknown.h"
#include <ole2.h>
#include "msxml.h"   // make sure these pick up the IE 5 versions
#include "xmlparser.h"

class CXMLNodeFactory : public _simpleunknown <IXMLNodeFactory>
{
public:
	virtual HRESULT DoElement( LPCTSTR text, LPCTSTR nameSpace);
	virtual HRESULT DoAttribute( LPCTSTR text);
	virtual HRESULT DoData( LPCTSTR text);
	virtual HRESULT DoStartChild(LPCTSTR text) {return S_OK;};
	virtual HRESULT DoEndChild(LPCTSTR text) {return S_OK;};
    virtual LPCTSTR DoEntityRef(LPCTSTR text) { return text; }

    CXMLNodeFactory();
    ~CXMLNodeFactory();

	        virtual HRESULT STDMETHODCALLTYPE NotifyEvent( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ XML_NODEFACTORY_EVENT iEvt);
        
        virtual HRESULT STDMETHODCALLTYPE BeginChildren( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo);
        
        virtual HRESULT STDMETHODCALLTYPE EndChildren( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ BOOL fEmpty,
            /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo);
        
        virtual HRESULT STDMETHODCALLTYPE Error( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ HRESULT hrErrorCode,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo);
        
        virtual HRESULT STDMETHODCALLTYPE CreateNode( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ PVOID pNodeParent,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo);


    HRESULT setError(HRESULT err)
    {
        return (errorState = err);
    }

    HRESULT getError()
    {
        return errorState;
    }

	IXMLNodeSource * GetSource() { return m_pSource;}
	PVOID GetParentNode() { return m_pNodeParent; }
	XML_NODE_INFO * GetNodeInfo() { return m_pNode; }

protected:

	// Internal properties while processing CreateNode.
	void SetSource ( IXMLNodeSource * p ) { m_pSource=p;}
	void SetParentNode( PVOID p ) { m_pNodeParent =p;}
	void SetNodeInfo ( XML_NODE_INFO * p ) { m_pNode=p;}
	IXMLNodeSource * m_pSource;
	PVOID			m_pNodeParent;
	XML_NODE_INFO * m_pNode;
	
	//
	// The fragment of XML currently being processed
	//
	void GetXMLFragment( XML_NODE_INFO * p);
	LPTSTR	m_XMLFragment;
	DWORD	m_cbXMLFragment;

    //
    // This is the namespace prefix being used.
    //
    LPTSTR  m_NSFragment;
    DWORD   m_cbNSFragment;


    INT		ignoreLevel;
    HRESULT errorState;

    static LPCTSTR typestr(ULONG type)
    {
        static LPTSTR typestrs[] =
        {
            TEXT("***"),
            TEXT("XML_ELEMENT"),
            TEXT("XML_ATTRIBUTE"),
            TEXT("XML_PI"),
            TEXT("XML_XMLDECL"),
            TEXT("XML_DOCTYPE"),
            TEXT("XML_DTDATTRIBUTE"),
            TEXT("XML_ENTITYDECL"),
            TEXT("XML_ELEMENTDECL"),
            TEXT("XML_ATTLISTDECL"),
            TEXT("XML_NOTATION"),
            TEXT("XML_GROUP"),
            TEXT("XML_INCLUDESECT"),
            TEXT("XML_PCDATA"),
            TEXT("XML_CDATA"),
            TEXT("XML_IGNORESECT"),
            TEXT("XML_COMMENT"),
            TEXT("XML_ENTITYREF"),
            TEXT("XML_WHITESPACE"),
            TEXT("XML_NAME"),
            TEXT("XML_NMTOKEN"),
            TEXT("XML_STRING"),
            TEXT("XML_PEREF"),
            TEXT("XML_MODEL"),
            TEXT("XML_ATTDEF"),
            TEXT("XML_ATTTYPE"),
            TEXT("XML_ATTPRESENCE"),
            TEXT("XML_DTDSUBSET"),
            TEXT("XML_LASTNODETYPE"),
        };

        if (type > sizeof(typestrs) / sizeof(PCSTR))
            type = 0;

        return typestrs[type];
    }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// X M L D I S P A T C H E R /////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Dispatcher.
//
// N is the NodeType
// must support weak refernces to parent nodes : HRESULT DetachParent( N **) and HRESULT AttachParent( N* )
//

template <class N> class  _XMLDispatcher : public CXMLNodeFactory
{
private:
    //
    // This is the function pointer that will produce the element we're looking for, or NULL
    //
    typedef N* (WINAPI * NSGENERATOR)(LPCWSTR pszElementName);      // ONLY UNICODE.

    //
    // a list of URI to Generators for that URI.
    // Registered by the clients.
    //
	typedef struct _URIGENERATOR
	{
		LPCTSTR	pszURI;		                // URI - why do we have this here AND in the class itself?
        NSGENERATOR pNameSpaceGenerator;    // the method which creates these things.
        _URIGENERATOR * pNextURI;
	}URIGENERATOR, * PURIGENERATOR;

    PURIGENERATOR m_pLastURIGen;            // points at the last one in the list.
    PURIGENERATOR m_pURIGen;                // points at the head of the list.
    PURIGENERATOR m_pCurrentDefaultURIGen;  // points at the current default namespace - er??

public:
    //
    // Each time we come across a namespace definition (xmlns or xmlns:<SHORT>)
    // we add one of these to the stack of namespaces. We find the corresponding long form of the
    // URI, in the PURIGENERATOR, and set it up.
    // when we leave a child, we pop these guys off the stack if iDepth is appropriate.
    //
	typedef struct _XMLNAMESPACESTACK
	{
		LPCTSTR	           pszNameSpace;	// shorthand (e.g. WIN32).
		PURIGENERATOR      pURIGen;	        // the class which deals with this namespace (URI).
        N *                pOwningNode;     // which node owns these names spaces.
        _XMLNAMESPACESTACK * pNextNameSpace;
	}XMLNAMESPACESTACK, * PXMLNAMESPACESTACK;
    PXMLNAMESPACESTACK m_pNameSpaceStack;

    void RegisterNameSpace( LPCTSTR pszURI, NSGENERATOR pClass );
    void PushNameSpace( LPCTSTR pszNameSpace, LPCTSTR pszURI, N* pOwningNode );
    void PopNameSpaces(N* pOwningNode);
    PURIGENERATOR FindNameSpace( LPCTSTR pszNameSpace );

public:
	_XMLDispatcher() : iSkipping(0)
	{
        m_Attribute=NULL;
		m_cbAttributeID=0x10;
		m_AttributeID=new TCHAR[m_cbAttributeID];
		m_cbAttributeNS=0x10;
		m_AttributeNS=new TCHAR[m_cbAttributeNS];
        m_Head=NULL;
        m_pCurrentNode=NULL;

        m_pLastURIGen= m_pURIGen= m_pCurrentDefaultURIGen=NULL;

        m_pNameSpaceStack=NULL;
        iDepth=0;
	}

	virtual ~_XMLDispatcher() 
    {
        SetCurrentNode(NULL);
        if(m_Head)
            m_Head->Release();
        m_Head=NULL;
        delete [] m_AttributeID; 
        delete [] m_AttributeNS; 

        // Clean up the URIGENERATORS
        PURIGENERATOR pNameSpaces=m_pURIGen;
        PURIGENERATOR pNextNameSpace;
        while( pNameSpaces )
        {
            pNextNameSpace = pNameSpaces->pNextURI;
            delete (LPTSTR)(pNameSpaces->pszURI);
            delete pNameSpaces;
            pNameSpaces = pNextNameSpace;
        }

        // Cleanup the NAMESPACE stack
        PXMLNAMESPACESTACK pNSStack = m_pNameSpaceStack;
        while( pNSStack )
        {
            PXMLNAMESPACESTACK pNSStackNext =  pNSStack->pNextNameSpace;
            delete (LPWSTR)(pNSStack->pszNameSpace);
            delete pNSStack;
            pNSStack = pNSStackNext;
        }
    };


    //
    // Called with the element name, and the 'abbreviated' namespace.
    //
	virtual HRESULT DoElement( LPCTSTR text, LPCTSTR nameSpace )
	{
#ifdef LOGCAT_LOADER
        EVENTLOG( EVENTLOG_INFORMATION_TYPE, LOGCAT_LOADER, 1,
            TEXT("XMLLoader"), TEXT("Element '%s'"), text);
#endif
        PURIGENERATOR pNSGen = m_pCurrentDefaultURIGen;
		if( iSkipping == 0 )
		{
            if( nameSpace && *nameSpace )
            {
                TRACE( TEXT("Node comes from namespace %s\n"), nameSpace );
                PURIGENERATOR pNS = FindNameSpace(nameSpace);

                if( pNS==FALSE)
                {
                // we didn't find the namespace
#ifdef LOGCAT_LOADER
                    EVENTLOG( EVENTLOG_INFORMATION_TYPE, LOGCAT_LOADER, 1,
                        TEXT("XMLLoader"), TEXT("NameSpace '%s' not known "), nameSpace);
#endif
		            iSkipping++;
		            return S_OK;
                }
                pNSGen =pNS;
            }

            //
            // If we pop a name space, we go looking for the next 'default'
            //
            if( m_pCurrentDefaultURIGen==NULL )
            {
                m_pCurrentDefaultURIGen = FindNameSpace(TEXT(""));
                if( m_pCurrentDefaultURIGen == NULL )
                    m_pCurrentDefaultURIGen = m_pURIGen;
            }

            if( pNSGen == NULL )
                pNSGen = m_pCurrentDefaultURIGen;

			NSGENERATOR pFunc=pNSGen->pNameSpaceGenerator ;
            if( pFunc )
            {
                HRESULT hRes=S_OK;
                N * pNode = pFunc( text );
                if(pNode)
				{
					N * pCurrentNode = GetCurrentNode();	// we're now the parent, this is passed in below
					pNode->AttachParent( pCurrentNode );
                    if( pCurrentNode==NULL)
                    {
                        m_Head=pNode;
                        m_Head->AddRef();
                    }

                    if((pCurrentNode==NULL) || ( SUCCEEDED(pCurrentNode->AcceptChild( pNode ))) )
                    {
						GetNodeInfo()->pNode=pNode;
						SetCurrentNode(pNode);
                    }
                    else
                    {
#ifdef LOGCAT_LOADER
                        EVENTLOG( EVENTLOG_WARNING_TYPE, LOGCAT_LOADER, 1,
                            TEXT("XMLLoader"), TEXT("'%s' isn't recognized child, skipping"), text);
#endif
                        iSkipping=1;
                        // delete pNode; 
                        pNode->Release();   // we punt this node - No one wanted it.
                    }
    				return hRes;
				}
            }
		}
		iSkipping++;
		return S_OK;
	}

    //
    // m_AttributeID is the ID we're GOING to be setting, in the namespace m_AttributeNS.
    //
	virtual HRESULT DoAttribute( LPCTSTR text)
	{ 
		if( iSkipping )
			return S_OK;

		m_Attribute=GetNodeInfo();
		DWORD iLen=lstrlen(text);
		if(iLen >= m_cbAttributeID )
		{
			delete m_AttributeID;
			m_cbAttributeID=iLen*2;
			m_AttributeID=new TCHAR[m_cbAttributeID];
			TRACE(TEXT("New @ID 0x%08x\n"), m_AttributeID);
		}
		lstrcpy(m_AttributeID, text);

        //
        // Store away the namespace for the attribute.
        //
		iLen=lstrlen(m_NSFragment);
		if(iLen >= m_cbAttributeNS )
		{
			delete m_AttributeNS;
			m_cbAttributeNS=iLen*2;
			m_AttributeNS=new TCHAR[m_cbAttributeNS];
		}
		lstrcpy(m_AttributeNS, m_NSFragment);

		m_newAttribute=TRUE;
		return S_OK; 
	}

    //
    // Once we have the 'value' part - this gets called.
    // Set the m_AttributeID in the namespace m_AttributeNS to the value m_XMLFragment
    // special cases for xmlns="<URI>" and xmlns:<shorthand>="<URI>"
    //
	virtual HRESULT DoData( LPCTSTR text)
	{
		if( iSkipping )
			return S_OK; 

		XML_NODE_INFO * pNI = GetNodeInfo();

		if( pNI->pNode != m_Attribute->pNode )
		{
			TRACE(TEXT("The attribute was set for a different node?\n"));
		}

		N * pNode=(N*)pNI->pNode;

        //
        // Name space definitions.
        //
        if( lstrcmpi(m_AttributeID, TEXT("xmlns"))==0 )
        {
            PushNameSpace( TEXT(""), text, pNode ); // is this the default?
            return S_OK;
        }

        if( lstrcmpi(m_AttributeNS, TEXT("xmlns"))==0 )
        {
            PushNameSpace( m_AttributeID, m_XMLFragment, pNode );
            return S_OK;
        }

		if(*m_AttributeID==TEXT('\0'))
		{
			if(pNode)
				pNode->put_Attr( L"BURIEDDATA", text );	// the best we can do.
		}
		else
		{
			if( pNode )
			{
				if( m_newAttribute==FALSE )
				{
					LPWSTR current;
					if( SUCCEEDED( pNode->get_Attr( m_AttributeID, &current )))
					{
						LPTSTR pnew=new TCHAR[lstrlen(current) + lstrlen(text) +1];
						lstrcpy(pnew, current);
						lstrcat(pnew, text);
						pNode->put_Attr( m_AttributeID, pnew );		// deletes old data.
                        delete pnew;
					}
				}
				else
				{
					m_newAttribute=FALSE;
					pNode->put_Attr( m_AttributeID, text );
				}
			}
		}
		return S_OK; 
	}


//////////////////////////////////////////////////////////////////////////////////////////
//
// Called when the node <text> is going to have a child.
// Mainly for information ?
//
// When we find that we're getting the ANSWERS child, we create a new CChoices node
//
//////////////////////////////////////////////////////////////////////////////////////////
	virtual HRESULT DoStartChild(LPCTSTR text)
	{
 		if( iSkipping )
			return S_OK; 
		*m_AttributeID=L'\0';
		return S_OK; 
	}


//
// Called when a node is completed
// text is the type of object created.
//
	virtual HRESULT DoEndChild(LPCTSTR text)
	{
		if( iSkipping )
		{
			iSkipping--;
			return S_OK; 
		}
		*m_AttributeID=L'\0';

		XML_NODE_INFO * pNI = GetNodeInfo();
		IXMLNodeSource * pNS = GetSource();
		N * pNode=(N*)pNI->pNode;
		if( pNode )
        {
            PopNameSpaces(pNode);    // remove any name spaces for this node.
            N * parent;
            if( SUCCEEDED( pNode->DetachParent( & parent ) ))
            {
			    SetCurrentNode(parent);
                if( GetCurrentNode() )
                    GetCurrentNode()->DoEndChild(pNode);
            }
        }
		return S_OK;
	}

    N   *   GetHeadElement() { return m_Head; }

private:
	int	iSkipping;
    int iDepth;         // used for the NAMESPACE stack.

protected:
	void		SetCurrentNode( N * p ) // no addref/release
    { 
        if(p)
            p->AddRef();
        if(m_pCurrentNode)
            m_pCurrentNode->Release();
        m_pCurrentNode=p; 
    }

	N		*	GetCurrentNode() { return m_pCurrentNode; }
	N		*	m_pCurrentNode;
	XML_NODE_INFO	*	m_Attribute;
	LPTSTR				m_AttributeID;
	DWORD				m_cbAttributeID;
	LPTSTR				m_AttributeNS;
	DWORD				m_cbAttributeNS;
	BOOL				m_newAttribute;
    N   *   m_Head;
};

#include "xmlnodefactory.inl"



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlpager.cpp ===
// XMLPager.cpp: implementation of the CXMLPager class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "XMLPager.h"
#include "xmlhelp.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CXMLPager::CXMLPager()
{
	m_bInit=FALSE;
	NODETYPE = NT_PAGER;
    m_StringType=L"PAGER";
}

CXMLPager::~CXMLPager()
{

}

// PGS_VERT                0x00000000
// PGS_HORZ                0x00000001
// PGS_AUTOSCROLL          0x00000002
// PGS_DRAGNDROP           0x00000004

void CXMLPager::Init()
{
	if(m_bInit)
		return;
	BASECLASS::Init();

	CXMLDlg::InitComctl32(ICC_PAGESCROLLER_CLASS);

   	m_Class=m_Class?m_Class:WC_PAGESCROLLER;

    m_Style |= YesNo( TEXT("AUTOSCROLL"), 0,0, PGS_AUTOSCROLL);

    if( LPCTSTR req=Get(TEXT("ORIENTATION")) )
    {
        if( lstrcmpi( req, TEXT("HORIZONTAL")) == 0 )
            m_Style |= PGS_HORZ;
    }

	m_bInit=TRUE;
}

////////////////////////////////////////////
////////////////////////////////////////////
////////////////////////////////////////////

CXMLHeader::CXMLHeader()
{
	m_bInit=FALSE;
	NODETYPE = NT_HEADER;
    m_StringType=L"HEADER";
}

CXMLHeader::~CXMLHeader()
{

}

//  HDS_HORZ                0x0000
//  HDS_BUTTONS             0x0002
//  HDS_HOTTRACK            0x0004
//  HDS_HIDDEN              0x0008
//  HDS_DRAGDROP            0x0040
//  HDS_FULLDRAG            0x0080

void CXMLHeader::Init()
{
	if(m_bInit)
		return;
	BASECLASS::Init();

	CXMLDlg::InitComctl32(ICC_LISTVIEW_CLASSES);

   	m_Class=m_Class?m_Class:WC_HEADER;

    m_Style |= YesNo( TEXT("BUTTONS"), 0,0, HDS_BUTTONS);
    m_Style |= YesNo( TEXT("HOTTRACK"), 0,0, HDS_HOTTRACK);
    m_Style |= YesNo( TEXT("FULLDRAG"), 0,0, HDS_FULLDRAG);

	m_bInit=TRUE;
}

////////////////////////////////////////////
////////////////////////////////////////////
////////////////////////////////////////////
#define CONTROLSTYLE(p,id, member, def) member = YesNo( id , def );

CXMLTabStyle::CXMLTabStyle()
{
	m_bInit=        FALSE;
	NODETYPE =      NT_TABSTYLE;
    m_StringType=   L"WIN32:TAB";
}

void CXMLTabStyle::Init()
{
    if(m_bInit)
        return;
    BASECLASS::Init();

    TabStyle=0;

    CONTROLSTYLE( TCS_FLATBUTTONS, TEXT("FLATBUTTONS"),       m_FlatButtons, FALSE );
    CONTROLSTYLE( TCS_FORCEICONLEFT, TEXT("FORCEICONLEFT"),       m_ForceIconLeft, FALSE );
    CONTROLSTYLE( TCS_FORCELABELLEFT, TEXT("FORCELABELLEFT"),       m_ForceLabelLeft, FALSE );
    CONTROLSTYLE( TCS_FOCUSONBUTTONDOWN, TEXT("FOCUSONBUTTONDOWN"),       m_FocusOnButtonDown, FALSE );
    CONTROLSTYLE( TCS_OWNERDRAWFIXED, TEXT("OWNERDRAWFIXED"),       m_OwnerDrawFixed, FALSE );
    CONTROLSTYLE( TCS_FOCUSNEVER, TEXT("FOCUSNEVER"),       m_FocusNever, FALSE );

    TabStyleEx=0;
    CONTROLSTYLE( TCS_EX_FLATSEPARATORS, TEXT("FLATSEPARATORS"),       m_FlatSeparators, FALSE );
    CONTROLSTYLE( TCS_EX_REGISTERDROP, TEXT("REGISTERDROP"),       m_RegisterDrop, FALSE );
    
    m_bInit=TRUE;
}


CXMLTab::CXMLTab()
{
	m_bInit=FALSE;
	NODETYPE = NT_TAB;
    m_StringType=L"TAB";
    m_pControlStyle=NULL;
}

// TCS_SCROLLOPPOSITE      0x0001   @SHUFFLE="YES" // assumes multiline tab
// TCS_BOTTOM              0x0002   @ALIGN="BOTTOM"
// TCS_RIGHT               0x0002   @ALIGN="RIGHT"
// TCS_MULTISELECT         0x0004   @MULTISELECT="YES" // allow multi-select in button mode
// TCS_FLATBUTTONS         0x0008   WIN32:TAB\@FLATBUTTONS="YES"
// TCS_FORCEICONLEFT       0x0010   WIN32:TAB\@FORCEICONLEFT="YES"
// TCS_FORCELABELLEFT      0x0020   WIN32:TAB\@FORCELABELLEFT="YES"
// TCS_HOTTRACK            0x0040   @HOTTRACK
// TCS_VERTICAL            0x0080   @ORIENTATION="VERTICAL"
// TCS_TABS                0x0000   @STYLE="TABS"
// TCS_BUTTONS             0x0100   @STYLE="BUTTONS"
// TCS_SINGLELINE          0x0000   @MULTILINE="NO"
// TCS_MULTILINE           0x0200   @MULTILINE="YES"
// TCS_RIGHTJUSTIFY        0x0000   @JUSTIFY="RIGHT"
// TCS_FIXEDWIDTH          0x0400   @FIXEDWIDTH="YES"
// TCS_RAGGEDRIGHT         0x0800   @JUSTIFY="LEFT"
// TCS_FOCUSONBUTTONDOWN   0x1000   WIN32:TAB\@FOCUSONBUTTONDOWN="YES"
// TCS_OWNERDRAWFIXED      0x2000   WIN32:TAB\@OWNERDRAWFIXED="YES"
// TCS_TOOLTIPS            0x4000   // implied from HELP\TOOLTIP\TEXT="..."
// TCS_FOCUSNEVER          0x8000   WIN32:TAB\@FOCUSNEVER="YES"
// EX styles for use with TCM_SETEXTENDEDSTYLE
// TCS_EX_FLATSEPARATORS   0x00000001   WIN32:TAB\FLATSEPARATORS="YES"
// TCS_EX_REGISTERDROP     0x00000002   WIN32:TAB\REGISTERDROP="YES"

void CXMLTab::Init()
{
	if(m_bInit)
		return;
	BASECLASS::Init();

	CXMLDlg::InitComctl32(ICC_TAB_CLASSES);

   	m_Class=m_Class?m_Class:WC_TABCONTROL;

    if( m_pControlStyle )
        m_Style |= m_pControlStyle->GetBaseStyles();
    else
        m_Style |= 0;   // any default styles?

    //
    // Attributes
    //
    m_Style |= YesNo( TEXT("SHUFFLE"), 0, 0, TCS_SCROLLOPPOSITE);

    LPCTSTR res=Get(TEXT("ALIGN"));
    if( res )
    {
        if( lstrcmpi(res, TEXT("BOTTOM") ) == 0 )
            m_Style |= TCS_BOTTOM;
        else  if( lstrcmpi(res, TEXT("RIGHT") ) == 0 )
            m_Style |= TCS_RIGHT;
    }

    m_Style |= YesNo( TEXT("MULTISELECT"), 0, 0, TCS_MULTISELECT);
    m_Style |= YesNo( TEXT("HOTTRACK"), 0, 0, TCS_HOTTRACK);

    if( LPCTSTR req=Get(TEXT("ORIENTATION")) )
    {
        if( lstrcmpi( req, TEXT("VERTICAL")) == 0 )
            m_Style |= TCS_VERTICAL;
    }

    if( LPCTSTR req=Get(TEXT("STYLE")) )
    {
        if( lstrcmpi( req, TEXT("TABS")) == 0 )
            m_Style |= TCS_TABS;
        else if( lstrcmpi( req, TEXT("BUTTONS")) == 0 )
            m_Style |= TCS_BUTTONS;
    }

    m_Style |= YesNo( TEXT("MULTILINE"), 0, 0, TCS_MULTILINE);
    
    if( LPCTSTR req=Get(TEXT("JUSTIFY")) )
    {
        if( lstrcmpi( req, TEXT("RIGHT")) == 0 )
            m_Style |= TCS_RIGHTJUSTIFY;
        else if( lstrcmpi( req, TEXT("LEFT")) == 0 )
            m_Style |= TCS_RAGGEDRIGHT;
    }

    m_Style |= YesNo( TEXT("FIXEDWIDTH"), 0, 0, TCS_FIXEDWIDTH);
    
    //
    // Tooltips - not sure if this is correct, but
    //
    IRCMLHelp * pHelp;
    if( SUCCEEDED(get_Help(&pHelp)) )
    {
        LPWSTR lpTip;
        if( SUCCEEDED( pHelp->get_TooltipText(&lpTip) ))
            m_Style |= TCS_TOOLTIPS;
    }
	m_bInit=TRUE;
}


HRESULT CXMLTab::AcceptChild(IRCMLNode * pChild )
{
    ACCEPTCHILD( L"WIN32:TAB", CXMLTabStyle, m_pControlStyle );
    return BASECLASS::AcceptChild(pChild);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlprogress.h ===
// XMLProgress.h: interface for the CXMLProgress class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XMLPROGRESS_H__3F2CD64B_4DA9_4120_8ADD_5DD68B1F2D75__INCLUDED_)
#define AFX_XMLPROGRESS_H__3F2CD64B_4DA9_4120_8ADD_5DD68B1F2D75__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "XMLControl.h"
#include "xmlitem.h"

class CXMLProgress : public _XMLControl<IRCMLControl>  
{
public:
	CXMLProgress();
	virtual ~CXMLProgress() {delete m_pRange; }
	typedef _XMLControl<IRCMLControl> BASECLASS;
	XML_CREATE( Progress );
    IMPLEMENTS_RCMLCONTROL_UNKNOWN;

    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptChild( 
        IRCMLNode __RPC_FAR *child);

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnInit( 
        HWND h);    // actually implemented

protected:
	void Init();
    CXMLRange   * m_pRange;
};

#endif // !defined(AFX_XMLPROGRESS_H__3F2CD64B_4DA9_4120_8ADD_5DD68B1F2D75__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlprogress.cpp ===
// XMLProgress.cpp: implementation of the CXMLProgress class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "XMLProgress.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
CXMLProgress::CXMLProgress()
{
	m_bInit=FALSE;
	NODETYPE = NT_PROGRESS;
    m_StringType=L"PROGRESS";
    m_pRange =NULL;
}

//
//
// PBS_SMOOTH              0x01
// PBS_VERTICAL            0x04
//
void CXMLProgress::Init()
{
	if(m_bInit)
		return;
	BASECLASS::Init();

	CXMLDlg::InitComctl32(ICC_PROGRESS_CLASS);

	m_Class=m_Class?m_Class:PROGRESS_CLASS;

    m_Style |= YesNo( TEXT("SMOOTH"), 0, 0, PBS_SMOOTH);

    if( LPCTSTR req=Get(TEXT("ORIENTATION")) )
    {
        if( lstrcmpi( req, TEXT("VERTICAL")) == 0 )
            m_Style |= PBS_VERTICAL;
    }
	m_bInit=TRUE;
}

HRESULT CXMLProgress::OnInit(HWND hWnd)
{
    BASECLASS::OnInit(hWnd);
	//
	// Set the upper lower and initial values
	// what about page size and all that jazz?
	//
    if( m_pRange )
    {
	    SendMessage(hWnd, PBM_SETRANGE32, m_pRange->GetMin(), m_pRange->GetMax() );
	    SendMessage(hWnd, PBM_SETPOS, m_pRange->GetValue(), 0 );
    }
    return S_OK;
}

HRESULT CXMLProgress::AcceptChild(IRCMLNode * pChild )
{
    ACCEPTCHILD( L"RANGE", CXMLRange, m_pRange );
    return BASECLASS::AcceptChild( pChild );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlparser.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.02.0205 */
/* at Thu Oct 22 17:08:10 1998
 */
/* Compiler settings for xmlparser.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __xmlparser_h__
#define __xmlparser_h__

/* Forward Declarations */ 

#ifndef __IXMLNodeSource_FWD_DEFINED__
#define __IXMLNodeSource_FWD_DEFINED__
typedef interface IXMLNodeSource IXMLNodeSource;
#endif 	/* __IXMLNodeSource_FWD_DEFINED__ */


#ifndef __IXMLParser_FWD_DEFINED__
#define __IXMLParser_FWD_DEFINED__
typedef interface IXMLParser IXMLParser;
#endif 	/* __IXMLParser_FWD_DEFINED__ */


#ifndef __IXMLNodeFactory_FWD_DEFINED__
#define __IXMLNodeFactory_FWD_DEFINED__
typedef interface IXMLNodeFactory IXMLNodeFactory;
#endif 	/* __IXMLNodeFactory_FWD_DEFINED__ */


#ifndef __XMLParser_FWD_DEFINED__
#define __XMLParser_FWD_DEFINED__

#ifdef __cplusplus
typedef class XMLParser XMLParser;
#else
typedef struct XMLParser XMLParser;
#endif /* __cplusplus */

#endif 	/* __XMLParser_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_xmlparser_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//--------------------------------------------------------------------------




typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0001
    {	XML_ELEMENT	= 1,
	XML_ATTRIBUTE	= XML_ELEMENT + 1,
	XML_PI	= XML_ATTRIBUTE + 1,
	XML_XMLDECL	= XML_PI + 1,
	XML_DOCTYPE	= XML_XMLDECL + 1,
	XML_DTDATTRIBUTE	= XML_DOCTYPE + 1,
	XML_ENTITYDECL	= XML_DTDATTRIBUTE + 1,
	XML_ELEMENTDECL	= XML_ENTITYDECL + 1,
	XML_ATTLISTDECL	= XML_ELEMENTDECL + 1,
	XML_NOTATION	= XML_ATTLISTDECL + 1,
	XML_GROUP	= XML_NOTATION + 1,
	XML_INCLUDESECT	= XML_GROUP + 1,
	XML_PCDATA	= XML_INCLUDESECT + 1,
	XML_CDATA	= XML_PCDATA + 1,
	XML_IGNORESECT	= XML_CDATA + 1,
	XML_COMMENT	= XML_IGNORESECT + 1,
	XML_ENTITYREF	= XML_COMMENT + 1,
	XML_WHITESPACE	= XML_ENTITYREF + 1,
	XML_NAME	= XML_WHITESPACE + 1,
	XML_NMTOKEN	= XML_NAME + 1,
	XML_STRING	= XML_NMTOKEN + 1,
	XML_PEREF	= XML_STRING + 1,
	XML_MODEL	= XML_PEREF + 1,
	XML_ATTDEF	= XML_MODEL + 1,
	XML_ATTTYPE	= XML_ATTDEF + 1,
	XML_ATTPRESENCE	= XML_ATTTYPE + 1,
	XML_DTDSUBSET	= XML_ATTPRESENCE + 1,
	XML_LASTNODETYPE	= XML_DTDSUBSET + 1
    }	XML_NODE_TYPE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0002
    {	XML_VERSION	= XML_LASTNODETYPE,
	XML_ENCODING	= XML_VERSION + 1,
	XML_STANDALONE	= XML_ENCODING + 1,
	XML_NS	= XML_STANDALONE + 1,
	XML_XMLSPACE	= XML_NS + 1,
	XML_XMLLANG	= XML_XMLSPACE + 1,
	XML_SYSTEM	= XML_XMLLANG + 1,
	XML_PUBLIC	= XML_SYSTEM + 1,
	XML_NDATA	= XML_PUBLIC + 1,
	XML_AT_CDATA	= XML_NDATA + 1,
	XML_AT_ID	= XML_AT_CDATA + 1,
	XML_AT_IDREF	= XML_AT_ID + 1,
	XML_AT_IDREFS	= XML_AT_IDREF + 1,
	XML_AT_ENTITY	= XML_AT_IDREFS + 1,
	XML_AT_ENTITIES	= XML_AT_ENTITY + 1,
	XML_AT_NMTOKEN	= XML_AT_ENTITIES + 1,
	XML_AT_NMTOKENS	= XML_AT_NMTOKEN + 1,
	XML_AT_NOTATION	= XML_AT_NMTOKENS + 1,
	XML_AT_REQUIRED	= XML_AT_NOTATION + 1,
	XML_AT_IMPLIED	= XML_AT_REQUIRED + 1,
	XML_AT_FIXED	= XML_AT_IMPLIED + 1,
	XML_PENTITYDECL	= XML_AT_FIXED + 1,
	XML_EMPTY	= XML_PENTITYDECL + 1,
	XML_ANY	= XML_EMPTY + 1,
	XML_MIXED	= XML_ANY + 1,
	XML_SEQUENCE	= XML_MIXED + 1,
	XML_CHOICE	= XML_SEQUENCE + 1,
	XML_STAR	= XML_CHOICE + 1,
	XML_PLUS	= XML_STAR + 1,
	XML_QUESTIONMARK	= XML_PLUS + 1,
	XML_LASTSUBNODETYPE	= XML_QUESTIONMARK + 1
    }	XML_NODE_SUBTYPE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0003
    {	XML_E_PARSEERRORBASE	= 0xc00ce500L,
	XML_E_ENDOFINPUT	= XML_E_PARSEERRORBASE,
	XML_E_MISSINGEQUALS	= XML_E_ENDOFINPUT + 1,
	XML_E_MISSINGQUOTE	= XML_E_MISSINGEQUALS + 1,
	XML_E_COMMENTSYNTAX	= XML_E_MISSINGQUOTE + 1,
	XML_E_BADSTARTNAMECHAR	= XML_E_COMMENTSYNTAX + 1,
	XML_E_BADNAMECHAR	= XML_E_BADSTARTNAMECHAR + 1,
	XML_E_BADCHARINSTRING	= XML_E_BADNAMECHAR + 1,
	XML_E_XMLDECLSYNTAX	= XML_E_BADCHARINSTRING + 1,
	XML_E_BADCHARDATA	= XML_E_XMLDECLSYNTAX + 1,
	XML_E_MISSINGWHITESPACE	= XML_E_BADCHARDATA + 1,
	XML_E_EXPECTINGTAGEND	= XML_E_MISSINGWHITESPACE + 1,
	XML_E_BADCHARINDTD	= XML_E_EXPECTINGTAGEND + 1,
	XML_E_BADCHARINDECL	= XML_E_BADCHARINDTD + 1,
	XML_E_MISSINGSEMICOLON	= XML_E_BADCHARINDECL + 1,
	XML_E_BADCHARINENTREF	= XML_E_MISSINGSEMICOLON + 1,
	XML_E_UNBALANCEDPAREN	= XML_E_BADCHARINENTREF + 1,
	XML_E_EXPECTINGOPENBRACKET	= XML_E_UNBALANCEDPAREN + 1,
	XML_E_BADENDCONDSECT	= XML_E_EXPECTINGOPENBRACKET + 1,
	XML_E_INTERNALERROR	= XML_E_BADENDCONDSECT + 1,
	XML_E_UNEXPECTED_WHITESPACE	= XML_E_INTERNALERROR + 1,
	XML_E_INCOMPLETE_ENCODING	= XML_E_UNEXPECTED_WHITESPACE + 1,
	XML_E_BADCHARINMIXEDMODEL	= XML_E_INCOMPLETE_ENCODING + 1,
	XML_E_MISSING_STAR	= XML_E_BADCHARINMIXEDMODEL + 1,
	XML_E_BADCHARINMODEL	= XML_E_MISSING_STAR + 1,
	XML_E_MISSING_PAREN	= XML_E_BADCHARINMODEL + 1,
	XML_E_BADCHARINENUMERATION	= XML_E_MISSING_PAREN + 1,
	XML_E_PIDECLSYNTAX	= XML_E_BADCHARINENUMERATION + 1,
	XML_E_EXPECTINGCLOSEQUOTE	= XML_E_PIDECLSYNTAX + 1,
	XML_E_MULTIPLE_COLONS	= XML_E_EXPECTINGCLOSEQUOTE + 1,
	XML_E_INVALID_DECIMAL	= XML_E_MULTIPLE_COLONS + 1,
	XML_E_INVALID_HEXIDECIMAL	= XML_E_INVALID_DECIMAL + 1,
	XML_E_INVALID_UNICODE	= XML_E_INVALID_HEXIDECIMAL + 1,
	XML_E_TOKEN_ERROR	= XML_E_PARSEERRORBASE + 0x50,
	XML_E_SUSPENDED	= XML_E_TOKEN_ERROR,
	XML_E_STOPPED	= XML_E_SUSPENDED + 1,
	XML_E_UNEXPECTEDENDTAG	= XML_E_STOPPED + 1,
	XML_E_UNCLOSEDTAG	= XML_E_UNEXPECTEDENDTAG + 1,
	XML_E_DUPLICATEATTRIBUTE	= XML_E_UNCLOSEDTAG + 1,
	XML_E_MULTIPLEROOTS	= XML_E_DUPLICATEATTRIBUTE + 1,
	XML_E_INVALIDATROOTLEVEL	= XML_E_MULTIPLEROOTS + 1,
	XML_E_BADXMLDECL	= XML_E_INVALIDATROOTLEVEL + 1,
	XML_E_MISSINGROOT	= XML_E_BADXMLDECL + 1,
	XML_E_UNEXPECTEDEOF	= XML_E_MISSINGROOT + 1,
	XML_E_BADPEREFINSUBSET	= XML_E_UNEXPECTEDEOF + 1,
	XML_E_PE_NESTING	= XML_E_BADPEREFINSUBSET + 1,
	XML_E_INVALID_CDATACLOSINGTAG	= XML_E_PE_NESTING + 1,
	XML_E_UNCLOSEDPI	= XML_E_INVALID_CDATACLOSINGTAG + 1,
	XML_E_UNCLOSEDSTARTTAG	= XML_E_UNCLOSEDPI + 1,
	XML_E_UNCLOSEDENDTAG	= XML_E_UNCLOSEDSTARTTAG + 1,
	XML_E_UNCLOSEDSTRING	= XML_E_UNCLOSEDENDTAG + 1,
	XML_E_UNCLOSEDCOMMENT	= XML_E_UNCLOSEDSTRING + 1,
	XML_E_UNCLOSEDDECL	= XML_E_UNCLOSEDCOMMENT + 1,
	XML_E_UNCLOSEDMARKUPDECL	= XML_E_UNCLOSEDDECL + 1,
	XML_E_UNCLOSEDCDATA	= XML_E_UNCLOSEDMARKUPDECL + 1,
	XML_E_BADDECLNAME	= XML_E_UNCLOSEDCDATA + 1,
	XML_E_BADEXTERNALID	= XML_E_BADDECLNAME + 1,
	XML_E_BADELEMENTINDTD	= XML_E_BADEXTERNALID + 1,
	XML_E_RESERVEDNAMESPACE	= XML_E_BADELEMENTINDTD + 1,
	XML_E_EXPECTING_VERSION	= XML_E_RESERVEDNAMESPACE + 1,
	XML_E_EXPECTING_ENCODING	= XML_E_EXPECTING_VERSION + 1,
	XML_E_EXPECTING_NAME	= XML_E_EXPECTING_ENCODING + 1,
	XML_E_UNEXPECTED_ATTRIBUTE	= XML_E_EXPECTING_NAME + 1,
	XML_E_ENDTAGMISMATCH	= XML_E_UNEXPECTED_ATTRIBUTE + 1,
	XML_E_INVALIDENCODING	= XML_E_ENDTAGMISMATCH + 1,
	XML_E_INVALIDSWITCH	= XML_E_INVALIDENCODING + 1,
	XML_E_EXPECTING_NDATA	= XML_E_INVALIDSWITCH + 1,
	XML_E_INVALID_MODEL	= XML_E_EXPECTING_NDATA + 1,
	XML_E_INVALID_TYPE	= XML_E_INVALID_MODEL + 1,
	XML_E_INVALIDXMLSPACE	= XML_E_INVALID_TYPE + 1,
	XML_E_MULTI_ATTR_VALUE	= XML_E_INVALIDXMLSPACE + 1,
	XML_E_INVALID_PRESENCE	= XML_E_MULTI_ATTR_VALUE + 1,
	XML_E_BADXMLCASE	= XML_E_INVALID_PRESENCE + 1,
	XML_E_CONDSECTINSUBSET	= XML_E_BADXMLCASE + 1,
	XML_E_CDATAINVALID	= XML_E_CONDSECTINSUBSET + 1,
	XML_E_INVALID_STANDALONE	= XML_E_CDATAINVALID + 1,
	XML_E_UNEXPECTED_STANDALONE	= XML_E_INVALID_STANDALONE + 1,
	XML_E_DOCTYPE_IN_DTD	= XML_E_UNEXPECTED_STANDALONE + 1,
	XML_E_MISSING_ENTITY	= XML_E_DOCTYPE_IN_DTD + 1,
	XML_E_ENTITYREF_INNAME	= XML_E_MISSING_ENTITY + 1,
	XML_E_DOCTYPE_OUTSIDE_PROLOG	= XML_E_ENTITYREF_INNAME + 1,
	XML_E_INVALID_VERSION	= XML_E_DOCTYPE_OUTSIDE_PROLOG + 1,
	XML_E_DTDELEMENT_OUTSIDE_DTD	= XML_E_INVALID_VERSION + 1,
	XML_E_DUPLICATEDOCTYPE	= XML_E_DTDELEMENT_OUTSIDE_DTD + 1,
	XML_E_RESOURCE	= XML_E_DUPLICATEDOCTYPE + 1,
	XML_E_LASTERROR	= XML_E_RESOURCE + 1
    }	XML_ERROR_CODE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0004
    {	XMLPARSER_IDLE	= 0,
	XMLPARSER_WAITING	= XMLPARSER_IDLE + 1,
	XMLPARSER_BUSY	= XMLPARSER_WAITING + 1,
	XMLPARSER_ERROR	= XMLPARSER_BUSY + 1,
	XMLPARSER_STOPPED	= XMLPARSER_ERROR + 1,
	XMLPARSER_SUSPENDED	= XMLPARSER_STOPPED + 1
    }	XML_PARSER_STATE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0005
    {	XMLFLAG_FLOATINGAMP	= 1,
	XMLFLAG_SHORTENDTAGS	= 2,
	XMLFLAG_CASEINSENSITIVE	= 4,
	XMLFLAG_NONAMESPACES	= 8,
	XMLFLAG_NOWHITESPACE	= 16,
	XMLFLAG_IE4QUIRKS	= 32,
	XMLFLAG_NODTDNODES	= 64,
	XMLFLAG_IE4COMPATIBILITY	= 255
    }	XML_PARSER_FLAGS;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0006
    {	XMLNF_STARTDOCUMENT	= 0,
	XMLNF_STARTDTD	= XMLNF_STARTDOCUMENT + 1,
	XMLNF_ENDDTD	= XMLNF_STARTDTD + 1,
	XMLNF_STARTDTDSUBSET	= XMLNF_ENDDTD + 1,
	XMLNF_ENDDTDSUBSET	= XMLNF_STARTDTDSUBSET + 1,
	XMLNF_ENDPROLOG	= XMLNF_ENDDTDSUBSET + 1,
	XMLNF_STARTENTITY	= XMLNF_ENDPROLOG + 1,
	XMLNF_ENDENTITY	= XMLNF_STARTENTITY + 1,
	XMLNF_ENDDOCUMENT	= XMLNF_ENDENTITY + 1,
	XMLNF_DATAAVAILABLE	= XMLNF_ENDDOCUMENT + 1
    }	XML_NODEFACTORY_EVENT;

typedef struct  _XML_NODE_INFO
    {
    DWORD dwSize;
    DWORD dwType;
    DWORD dwSubType;
    BOOL fTerminal;
    const WCHAR __RPC_FAR *pwcText;
    ULONG ulLen;
    ULONG ulNsPrefixLen;
    PVOID pNode;
    PVOID pReserved;
    }	XML_NODE_INFO;



extern RPC_IF_HANDLE __MIDL_itf_xmlparser_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_xmlparser_0000_v0_0_s_ifspec;


#ifndef __XMLPSR_LIBRARY_DEFINED__
#define __XMLPSR_LIBRARY_DEFINED__

/* library XMLPSR */
/* [version][lcid][helpstring][uuid] */ 


EXTERN_C const IID LIBID_XMLPSR;

#ifndef __IXMLNodeSource_INTERFACE_DEFINED__
#define __IXMLNodeSource_INTERFACE_DEFINED__

/* interface IXMLNodeSource */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IXMLNodeSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d242361d-51a0-11d2-9caf-0060b0ec3d39")
    IXMLNodeSource : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFactory( 
            /* [in] */ IXMLNodeFactory __RPC_FAR *pNodeFactory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFactory( 
            /* [out] */ IXMLNodeFactory __RPC_FAR *__RPC_FAR *ppNodeFactory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Abort( 
            /* [in] */ BSTR bstrErrorInfo) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetLineNumber( void) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetLinePosition( void) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetAbsolutePosition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLineBuffer( 
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf,
            /* [out] */ ULONG __RPC_FAR *pulLen,
            /* [out] */ ULONG __RPC_FAR *pulStartPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLastError( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrorInfo( 
            /* [out] */ BSTR __RPC_FAR *pbstrErrorInfo) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetFlags( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetURL( 
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLNodeSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLNodeSource __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLNodeSource __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFactory )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [in] */ IXMLNodeFactory __RPC_FAR *pNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFactory )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [out] */ IXMLNodeFactory __RPC_FAR *__RPC_FAR *ppNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Abort )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [in] */ BSTR bstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetLineNumber )( 
            IXMLNodeSource __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetLinePosition )( 
            IXMLNodeSource __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetAbsolutePosition )( 
            IXMLNodeSource __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLineBuffer )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf,
            /* [out] */ ULONG __RPC_FAR *pulLen,
            /* [out] */ ULONG __RPC_FAR *pulStartPos);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastError )( 
            IXMLNodeSource __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetErrorInfo )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetFlags )( 
            IXMLNodeSource __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetURL )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf);
        
        END_INTERFACE
    } IXMLNodeSourceVtbl;

    interface IXMLNodeSource
    {
        CONST_VTBL struct IXMLNodeSourceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLNodeSource_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLNodeSource_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLNodeSource_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLNodeSource_SetFactory(This,pNodeFactory)	\
    (This)->lpVtbl -> SetFactory(This,pNodeFactory)

#define IXMLNodeSource_GetFactory(This,ppNodeFactory)	\
    (This)->lpVtbl -> GetFactory(This,ppNodeFactory)

#define IXMLNodeSource_Abort(This,bstrErrorInfo)	\
    (This)->lpVtbl -> Abort(This,bstrErrorInfo)

#define IXMLNodeSource_GetLineNumber(This)	\
    (This)->lpVtbl -> GetLineNumber(This)

#define IXMLNodeSource_GetLinePosition(This)	\
    (This)->lpVtbl -> GetLinePosition(This)

#define IXMLNodeSource_GetAbsolutePosition(This)	\
    (This)->lpVtbl -> GetAbsolutePosition(This)

#define IXMLNodeSource_GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)	\
    (This)->lpVtbl -> GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)

#define IXMLNodeSource_GetLastError(This)	\
    (This)->lpVtbl -> GetLastError(This)

#define IXMLNodeSource_GetErrorInfo(This,pbstrErrorInfo)	\
    (This)->lpVtbl -> GetErrorInfo(This,pbstrErrorInfo)

#define IXMLNodeSource_GetFlags(This)	\
    (This)->lpVtbl -> GetFlags(This)

#define IXMLNodeSource_GetURL(This,ppwcBuf)	\
    (This)->lpVtbl -> GetURL(This,ppwcBuf)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IXMLNodeSource_SetFactory_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [in] */ IXMLNodeFactory __RPC_FAR *pNodeFactory);


void __RPC_STUB IXMLNodeSource_SetFactory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetFactory_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [out] */ IXMLNodeFactory __RPC_FAR *__RPC_FAR *ppNodeFactory);


void __RPC_STUB IXMLNodeSource_GetFactory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_Abort_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [in] */ BSTR bstrErrorInfo);


void __RPC_STUB IXMLNodeSource_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IXMLNodeSource_GetLineNumber_Proxy( 
    IXMLNodeSource __RPC_FAR * This);


void __RPC_STUB IXMLNodeSource_GetLineNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IXMLNodeSource_GetLinePosition_Proxy( 
    IXMLNodeSource __RPC_FAR * This);


void __RPC_STUB IXMLNodeSource_GetLinePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IXMLNodeSource_GetAbsolutePosition_Proxy( 
    IXMLNodeSource __RPC_FAR * This);


void __RPC_STUB IXMLNodeSource_GetAbsolutePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetLineBuffer_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf,
    /* [out] */ ULONG __RPC_FAR *pulLen,
    /* [out] */ ULONG __RPC_FAR *pulStartPos);


void __RPC_STUB IXMLNodeSource_GetLineBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetLastError_Proxy( 
    IXMLNodeSource __RPC_FAR * This);


void __RPC_STUB IXMLNodeSource_GetLastError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetErrorInfo_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrErrorInfo);


void __RPC_STUB IXMLNodeSource_GetErrorInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IXMLNodeSource_GetFlags_Proxy( 
    IXMLNodeSource __RPC_FAR * This);


void __RPC_STUB IXMLNodeSource_GetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetURL_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf);


void __RPC_STUB IXMLNodeSource_GetURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLNodeSource_INTERFACE_DEFINED__ */


#ifndef __IXMLParser_INTERFACE_DEFINED__
#define __IXMLParser_INTERFACE_DEFINED__

/* interface IXMLParser */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IXMLParser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d242361e-51a0-11d2-9caf-0060b0ec3d39")
    IXMLParser : public IXMLNodeSource
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetURL( 
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
            /* [in] */ BOOL fAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Load( 
            /* [in] */ BOOL fFullyAvailable,
            /* [in] */ IMoniker __RPC_FAR *pimkName,
            /* [in] */ LPBC pibc,
            /* [in] */ DWORD grfMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInput( 
            /* [in] */ IUnknown __RPC_FAR *pStm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PushData( 
            /* [in] */ const char __RPC_FAR *pData,
            /* [in] */ ULONG ulChars,
            /* [in] */ BOOL fLastBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadDTD( 
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadEntity( 
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
            /* [in] */ BOOL fpe) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParseEntity( 
            /* [in] */ const WCHAR __RPC_FAR *pwcText,
            /* [in] */ ULONG ulLen,
            /* [in] */ BOOL fpe) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExpandEntity( 
            /* [in] */ const WCHAR __RPC_FAR *pwcText,
            /* [in] */ ULONG ulLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRoot( 
            /* [in] */ PVOID pRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRoot( 
            /* [in] */ PVOID __RPC_FAR *ppRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Run( 
            /* [in] */ long lChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParserState( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Suspend( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ ULONG iFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSecureBaseURL( 
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSecureBaseURL( 
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLParserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLParser __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFactory )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ IXMLNodeFactory __RPC_FAR *pNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFactory )( 
            IXMLParser __RPC_FAR * This,
            /* [out] */ IXMLNodeFactory __RPC_FAR *__RPC_FAR *ppNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Abort )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ BSTR bstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetLineNumber )( 
            IXMLParser __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetLinePosition )( 
            IXMLParser __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetAbsolutePosition )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLineBuffer )( 
            IXMLParser __RPC_FAR * This,
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf,
            /* [out] */ ULONG __RPC_FAR *pulLen,
            /* [out] */ ULONG __RPC_FAR *pulStartPos);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastError )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetErrorInfo )( 
            IXMLParser __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetFlags )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetURL )( 
            IXMLParser __RPC_FAR * This,
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetURL )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
            /* [in] */ BOOL fAsync);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Load )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ BOOL fFullyAvailable,
            /* [in] */ IMoniker __RPC_FAR *pimkName,
            /* [in] */ LPBC pibc,
            /* [in] */ DWORD grfMode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetInput )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pStm);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PushData )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const char __RPC_FAR *pData,
            /* [in] */ ULONG ulChars,
            /* [in] */ BOOL fLastBuffer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadDTD )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadEntity )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
            /* [in] */ BOOL fpe);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ParseEntity )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwcText,
            /* [in] */ ULONG ulLen,
            /* [in] */ BOOL fpe);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExpandEntity )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwcText,
            /* [in] */ ULONG ulLen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRoot )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ PVOID pRoot);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRoot )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ PVOID __RPC_FAR *ppRoot);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Run )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ long lChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParserState )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Suspend )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFlags )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ ULONG iFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSecureBaseURL )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSecureBaseURL )( 
            IXMLParser __RPC_FAR * This,
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf);
        
        END_INTERFACE
    } IXMLParserVtbl;

    interface IXMLParser
    {
        CONST_VTBL struct IXMLParserVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLParser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLParser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLParser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLParser_SetFactory(This,pNodeFactory)	\
    (This)->lpVtbl -> SetFactory(This,pNodeFactory)

#define IXMLParser_GetFactory(This,ppNodeFactory)	\
    (This)->lpVtbl -> GetFactory(This,ppNodeFactory)

#define IXMLParser_Abort(This,bstrErrorInfo)	\
    (This)->lpVtbl -> Abort(This,bstrErrorInfo)

#define IXMLParser_GetLineNumber(This)	\
    (This)->lpVtbl -> GetLineNumber(This)

#define IXMLParser_GetLinePosition(This)	\
    (This)->lpVtbl -> GetLinePosition(This)

#define IXMLParser_GetAbsolutePosition(This)	\
    (This)->lpVtbl -> GetAbsolutePosition(This)

#define IXMLParser_GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)	\
    (This)->lpVtbl -> GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)

#define IXMLParser_GetLastError(This)	\
    (This)->lpVtbl -> GetLastError(This)

#define IXMLParser_GetErrorInfo(This,pbstrErrorInfo)	\
    (This)->lpVtbl -> GetErrorInfo(This,pbstrErrorInfo)

#define IXMLParser_GetFlags(This)	\
    (This)->lpVtbl -> GetFlags(This)

#define IXMLParser_GetURL(This,ppwcBuf)	\
    (This)->lpVtbl -> GetURL(This,ppwcBuf)


#define IXMLParser_SetURL(This,pszBaseUrl,pszRelativeUrl,fAsync)	\
    (This)->lpVtbl -> SetURL(This,pszBaseUrl,pszRelativeUrl,fAsync)

#define IXMLParser_Load(This,fFullyAvailable,pimkName,pibc,grfMode)	\
    (This)->lpVtbl -> Load(This,fFullyAvailable,pimkName,pibc,grfMode)

#define IXMLParser_SetInput(This,pStm)	\
    (This)->lpVtbl -> SetInput(This,pStm)

#define IXMLParser_PushData(This,pData,ulChars,fLastBuffer)	\
    (This)->lpVtbl -> PushData(This,pData,ulChars,fLastBuffer)

#define IXMLParser_LoadDTD(This,pszBaseUrl,pszRelativeUrl)	\
    (This)->lpVtbl -> LoadDTD(This,pszBaseUrl,pszRelativeUrl)

#define IXMLParser_LoadEntity(This,pszBaseUrl,pszRelativeUrl,fpe)	\
    (This)->lpVtbl -> LoadEntity(This,pszBaseUrl,pszRelativeUrl,fpe)

#define IXMLParser_ParseEntity(This,pwcText,ulLen,fpe)	\
    (This)->lpVtbl -> ParseEntity(This,pwcText,ulLen,fpe)

#define IXMLParser_ExpandEntity(This,pwcText,ulLen)	\
    (This)->lpVtbl -> ExpandEntity(This,pwcText,ulLen)

#define IXMLParser_SetRoot(This,pRoot)	\
    (This)->lpVtbl -> SetRoot(This,pRoot)

#define IXMLParser_GetRoot(This,ppRoot)	\
    (This)->lpVtbl -> GetRoot(This,ppRoot)

#define IXMLParser_Run(This,lChars)	\
    (This)->lpVtbl -> Run(This,lChars)

#define IXMLParser_GetParserState(This)	\
    (This)->lpVtbl -> GetParserState(This)

#define IXMLParser_Suspend(This)	\
    (This)->lpVtbl -> Suspend(This)

#define IXMLParser_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IXMLParser_SetFlags(This,iFlags)	\
    (This)->lpVtbl -> SetFlags(This,iFlags)

#define IXMLParser_SetSecureBaseURL(This,pszBaseUrl)	\
    (This)->lpVtbl -> SetSecureBaseURL(This,pszBaseUrl)

#define IXMLParser_GetSecureBaseURL(This,ppwcBuf)	\
    (This)->lpVtbl -> GetSecureBaseURL(This,ppwcBuf)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IXMLParser_SetURL_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
    /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
    /* [in] */ BOOL fAsync);


void __RPC_STUB IXMLParser_SetURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_Load_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ BOOL fFullyAvailable,
    /* [in] */ IMoniker __RPC_FAR *pimkName,
    /* [in] */ LPBC pibc,
    /* [in] */ DWORD grfMode);


void __RPC_STUB IXMLParser_Load_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_SetInput_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pStm);


void __RPC_STUB IXMLParser_SetInput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_PushData_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const char __RPC_FAR *pData,
    /* [in] */ ULONG ulChars,
    /* [in] */ BOOL fLastBuffer);


void __RPC_STUB IXMLParser_PushData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_LoadDTD_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
    /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl);


void __RPC_STUB IXMLParser_LoadDTD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_LoadEntity_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
    /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
    /* [in] */ BOOL fpe);


void __RPC_STUB IXMLParser_LoadEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_ParseEntity_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwcText,
    /* [in] */ ULONG ulLen,
    /* [in] */ BOOL fpe);


void __RPC_STUB IXMLParser_ParseEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_ExpandEntity_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwcText,
    /* [in] */ ULONG ulLen);


void __RPC_STUB IXMLParser_ExpandEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_SetRoot_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ PVOID pRoot);


void __RPC_STUB IXMLParser_SetRoot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_GetRoot_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ PVOID __RPC_FAR *ppRoot);


void __RPC_STUB IXMLParser_GetRoot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_Run_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ long lChars);


void __RPC_STUB IXMLParser_Run_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_GetParserState_Proxy( 
    IXMLParser __RPC_FAR * This);


void __RPC_STUB IXMLParser_GetParserState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_Suspend_Proxy( 
    IXMLParser __RPC_FAR * This);


void __RPC_STUB IXMLParser_Suspend_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_Reset_Proxy( 
    IXMLParser __RPC_FAR * This);


void __RPC_STUB IXMLParser_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_SetFlags_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ ULONG iFlags);


void __RPC_STUB IXMLParser_SetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_SetSecureBaseURL_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl);


void __RPC_STUB IXMLParser_SetSecureBaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_GetSecureBaseURL_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf);


void __RPC_STUB IXMLParser_GetSecureBaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLParser_INTERFACE_DEFINED__ */


#ifndef __IXMLNodeFactory_INTERFACE_DEFINED__
#define __IXMLNodeFactory_INTERFACE_DEFINED__

/* interface IXMLNodeFactory */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IXMLNodeFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d242361f-51a0-11d2-9caf-0060b0ec3d39")
    IXMLNodeFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NotifyEvent( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ XML_NODEFACTORY_EVENT iEvt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginChildren( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndChildren( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ BOOL fEmpty,
            /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Error( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ HRESULT hrErrorCode,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateNode( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ PVOID pNodeParent,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLNodeFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLNodeFactory __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLNodeFactory __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyEvent )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ XML_NODEFACTORY_EVENT iEvt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginChildren )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndChildren )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ BOOL fEmpty,
            /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Error )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ HRESULT hrErrorCode,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateNode )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ PVOID pNodeParent,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo);
        
        END_INTERFACE
    } IXMLNodeFactoryVtbl;

    interface IXMLNodeFactory
    {
        CONST_VTBL struct IXMLNodeFactoryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLNodeFactory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLNodeFactory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLNodeFactory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLNodeFactory_NotifyEvent(This,pSource,iEvt)	\
    (This)->lpVtbl -> NotifyEvent(This,pSource,iEvt)

#define IXMLNodeFactory_BeginChildren(This,pSource,pNodeInfo)	\
    (This)->lpVtbl -> BeginChildren(This,pSource,pNodeInfo)

#define IXMLNodeFactory_EndChildren(This,pSource,fEmpty,pNodeInfo)	\
    (This)->lpVtbl -> EndChildren(This,pSource,fEmpty,pNodeInfo)

#define IXMLNodeFactory_Error(This,pSource,hrErrorCode,cNumRecs,apNodeInfo)	\
    (This)->lpVtbl -> Error(This,pSource,hrErrorCode,cNumRecs,apNodeInfo)

#define IXMLNodeFactory_CreateNode(This,pSource,pNodeParent,cNumRecs,apNodeInfo)	\
    (This)->lpVtbl -> CreateNode(This,pSource,pNodeParent,cNumRecs,apNodeInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IXMLNodeFactory_NotifyEvent_Proxy( 
    IXMLNodeFactory __RPC_FAR * This,
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ XML_NODEFACTORY_EVENT iEvt);


void __RPC_STUB IXMLNodeFactory_NotifyEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeFactory_BeginChildren_Proxy( 
    IXMLNodeFactory __RPC_FAR * This,
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo);


void __RPC_STUB IXMLNodeFactory_BeginChildren_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeFactory_EndChildren_Proxy( 
    IXMLNodeFactory __RPC_FAR * This,
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ BOOL fEmpty,
    /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo);


void __RPC_STUB IXMLNodeFactory_EndChildren_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeFactory_Error_Proxy( 
    IXMLNodeFactory __RPC_FAR * This,
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ HRESULT hrErrorCode,
    /* [in] */ USHORT cNumRecs,
    /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo);


void __RPC_STUB IXMLNodeFactory_Error_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeFactory_CreateNode_Proxy( 
    IXMLNodeFactory __RPC_FAR * This,
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ PVOID pNodeParent,
    /* [in] */ USHORT cNumRecs,
    /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo);


void __RPC_STUB IXMLNodeFactory_CreateNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLNodeFactory_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_XMLParser;

#ifdef __cplusplus

class DECLSPEC_UUID("d2423620-51a0-11d2-9caf-0060b0ec3d39")
XMLParser;
#endif
#endif /* __XMLPSR_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlrcml.cpp ===
// XMLRCML.cpp: implementation of the CXMLRCML class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "XMLRCML.h"
#include "eventlog.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CXMLRCML::CXMLRCML()
{
  	NODETYPE = NT_RCML;
}

CXMLRCML::~CXMLRCML()
{
    TRACE(TEXT("Deleting all the RCML stuff, forms etc\n"));
}

void CXMLRCML::Init()
{
}

// Takse an optional FORM, which in turn takes DIALOG/PAGE nodes.
HRESULT CXMLRCML::AcceptChild(IRCMLNode * pChild )
{
    if( SUCCEEDED( pChild->IsType(L"FORM") ))
    {
        m_FormsList.Append((CXMLForms*)pChild);
        return S_OK;
    }

    if( SUCCEEDED( pChild->IsType(L"PLATFORM") ))
        return S_OK;

    if( SUCCEEDED( pChild->IsType(L"LOGINFO") ))
    {
        m_qrLog=(CXMLLog*)pChild;
        return S_OK;
    }

    // catchall - optional FORM element - if we have one hand it all the children?
    int iCount=m_FormsList.GetCount();
    if(iCount>0)
    {
        CXMLForms * pForms=m_FormsList.GetPointer( iCount-1 );
        if(pForms)
            return pForms->AcceptChild(pChild );
    }
    return E_FAIL;
}

// We do stuff here because we initialize the LOGINFO immediately - kinda annoying.
/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CXMLRCML::DoEndChild( 
    IRCMLNode __RPC_FAR *pChild)
{
    if( SUCCEEDED( pChild->IsType(L"LOGINFO") ))
    {
        CXMLLog * pLog=(CXMLLog*)pChild;
        pLog->Init();

        WORD catMask=0;
        WORD typeMask=0;

        if( pLog->GetLoader() )
            catMask |= LOGCAT_LOADER;
        if( pLog->GetConstruct() )
            catMask |= LOGCAT_CONSTRUCT;
        if( pLog->GetRuntime() )
            catMask |= LOGCAT_RUNTIME;
        if( pLog->GetResize() )
            catMask |= LOGCAT_RESIZE;
        if( pLog->GetClipping() )
            catMask |= LOGCAT_CLIPPING;

        typeMask |= pLog->GetLoader() |
            pLog->GetConstruct() |
            pLog->GetRuntime() |
            pLog->GetResize() |
            pLog->GetClipping() ;

        if(pLog->GetUseEventLog() && (typeMask || catMask ))
            g_EventLog.TurnOn();

        g_EventLog.SetCategoryMask(catMask);
        g_EventLog.SetTypeMask(typeMask);

        TCHAR szBuffer[1024];
        wsprintf(szBuffer,TEXT("Logging typeMask:0x%04x categoryMask:0x%04x"),
            typeMask, catMask );
        EVENTLOG( EVENTLOG_SUCCESS, catMask, 0, TEXT("RCML Processing"), szBuffer );
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlpager.h ===
// XMLPager.h: interface for the CXMLPager class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XMLPAGER_H__9A5E5001_F5A0_4EA5_8DD5_2E242A7579ED__INCLUDED_)
#define AFX_XMLPAGER_H__9A5E5001_F5A0_4EA5_8DD5_2E242A7579ED__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "xmlcontrol.h"

class CXMLPager  : public _XMLControl<IRCMLControl>
{
public:
	CXMLPager();
	virtual ~CXMLPager();
    typedef _XMLControl<IRCMLControl> BASECLASS;
    IMPLEMENTS_RCMLCONTROL_UNKNOWN;
	XML_CREATE( Pager );

protected:
	void Init();
};

class CXMLHeader  : public _XMLControl<IRCMLControl>
{
public:
	CXMLHeader();
	virtual ~CXMLHeader();
	typedef _XMLControl<IRCMLControl> BASECLASS;
	XML_CREATE( Header );
    IMPLEMENTS_RCMLCONTROL_UNKNOWN;

protected:
	void Init();
};


class CXMLTabStyle : public CXMLControlStyle
{
public:
    CXMLTabStyle();
	virtual ~CXMLTabStyle() {};
	typedef CXMLControlStyle BASECLASS;
	XML_CREATE( TabStyle );
    UINT    GetBaseStyles() { Init(); return TabStyle; }
    UINT    GetBaseStylesEx() { Init(); return TabStyleEx; }
    void    Init();

protected:
// TCS_SCROLLOPPOSITE      0x0001   @SHUFFLE="YES" // assumes multiline tab
// TCS_BOTTOM              0x0002   @ALIGN="BOTTOM"
// TCS_RIGHT               0x0002   @ALIGN="RIGHT"
// TCS_MULTISELECT         0x0004   @MULTISELECT="YES" // allow multi-select in button mode
// TCS_FLATBUTTONS         0x0008   WIN32:TAB\@FLATBUTTONS="YES"

// TCS_FORCEICONLEFT       0x0010   WIN32:TAB\@FORCEICONLEFT="YES"
// TCS_FORCELABELLEFT      0x0020   WIN32:TAB\@FORCELABELLEFT="YES"
// TCS_HOTTRACK            0x0040   @HOTTRACK
// TCS_VERTICAL            0x0080   @ORIENTATION="VERTICAL"

// TCS_TABS                0x0000   @STYLE="TABS"
// TCS_BUTTONS             0x0100   @STYLE="BUTTONS"
// TCS_SINGLELINE          0x0000   @MULTILINE="NO"
// TCS_MULTILINE           0x0200   @MULTILINE="YES"
// TCS_RIGHTJUSTIFY        0x0000   @JUSTIFY="RIGHT"
// TCS_FIXEDWIDTH          0x0400   @WIDTH="FIXED"
// TCS_RAGGEDRIGHT         0x0800   @JUSTIFY="LEFT"

// TCS_FOCUSONBUTTONDOWN   0x1000   WIN32:TAB\@FOCUSONBUTTONDOWN="YES"
// TCS_OWNERDRAWFIXED      0x2000   WIN32:TAB\@OWNERDRAWFIXED="YES"
// TCS_TOOLTIPS            0x4000   // implied from HELP\TOOLTIP\TEXT="..."
// TCS_FOCUSNEVER          0x8000   WIN32:TAB\@FOCUSNEVER="YES"
// EX styles for use with TCM_SETEXTENDEDSTYLE
// TCS_EX_FLATSEPARATORS   0x00000001   WIN32:TAB\FLATSEPARATORS="YES"
// TCS_EX_REGISTERDROP     0x00000002   WIN32:TAB\REGISTERDROP="YES"

    union
    {
        UINT    TabStyle;
        struct {
            UINT    enum1:3;            // 0x000?
            BOOL    m_FlatButtons:1;

            BOOL    m_ForceIconLeft:1;
            BOOL    m_ForceLabelLeft:1;
            UINT    enum2:2;

            UINT    enum3:4;            // 0x0?00

            BOOL    m_FocusOnButtonDown:1;  // 0x1000
            BOOL    m_OwnerDrawFixed:1;     // 0x1000
            UINT    enum4:1;                // 1 bit nothing
            BOOL    m_FocusNever:1;         // 0x1000
        };
    };

    union
    {
        UINT    TabStyleEx;
        struct {
            BOOL    m_FlatSeparators:1;
            BOOL    m_RegisterDrop:1;
        };
    };
};

class CXMLTab : public _XMLControl<IRCMLControl>
{
public:
	CXMLTab();
    virtual ~CXMLTab() { delete m_pControlStyle; };
	typedef _XMLControl<IRCMLControl> BASECLASS;
    IMPLEMENTS_RCMLCONTROL_UNKNOWN;
	XML_CREATE( Tab );

    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptChild( 
        IRCMLNode __RPC_FAR *child);

protected:
	void Init();
    CXMLTabStyle * m_pControlStyle;
};

#endif // !defined(AFX_XMLPAGER_H__9A5E5001_F5A0_4EA5_8DD5_2E242A7579ED__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlnodefactory.inl ===
LPSTR AnsiStringFromUnicode(LPCWSTR pszSource);

template <class N> void _XMLDispatcher<N>::RegisterNameSpace( LPCTSTR pszURI, NSGENERATOR pClass )
{
    if( m_pURIGen == NULL )
        m_pURIGen =new URIGENERATOR;

    TRACE(TEXT("Registering the URI : %s as a namespace\n"), pszURI );

    PURIGENERATOR pFill;
    if(m_pLastURIGen==NULL)
        pFill=m_pLastURIGen=m_pURIGen;
    else
        pFill=m_pLastURIGen->pNextURI=new URIGENERATOR;

    DWORD cbURI=lstrlen(pszURI)+1;
    pFill->pszURI=new TCHAR[cbURI];
    lstrcpy( (LPTSTR)pFill->pszURI,    pszURI );    // copy the URI.
    pFill->pNameSpaceGenerator=pClass;
    pFill->pNextURI=NULL;
    m_pLastURIGen=pFill;
}

//
// Called when we come across an xmlns definition.
// this is an association of a namespace seen in the XML file with a URI.
//
template <class N> void _XMLDispatcher<N>::PushNameSpace( LPCTSTR pszNameSpace, LPCTSTR pszURI, N* pOwningNode )
{
    PXMLNAMESPACESTACK pNewNS = new XMLNAMESPACESTACK;
    pNewNS->pOwningNode = pOwningNode;  // record which node caused these name spaces to be created.

    TRACE(TEXT("Associating %s with the URI %s\n"), pszNameSpace, pszURI );

    //
    // Keep a copy of the shorthand so we can find it when it's used.
    //
    pNewNS->pszNameSpace = new TCHAR[lstrlen(pszNameSpace)+1];
    lstrcpy( (LPTSTR)pNewNS->pszNameSpace , pszNameSpace );
    //
    // Now find the URI
    //
    PURIGENERATOR pNameSpaces=m_pURIGen;
    while( pNameSpaces )
    {
        // we already have this URI.
        if( lstrcmpi( pNameSpaces->pszURI, pszURI ) ==0 )
        {
            pNewNS->pURIGen         = pNameSpaces;
            pNewNS->pNextNameSpace  = m_pNameSpaceStack;
            m_pNameSpaceStack=pNewNS;       // this is a stack.
            if( lstrcmpi(pszNameSpace, TEXT("")) == 0 )
                m_pCurrentDefaultURIGen=pNameSpaces;
            return;
        }
        pNameSpaces = pNameSpaces->pNextURI;
    }

#ifdef LOGCAT_LOADER
    EVENTLOG( EVENTLOG_INFORMATION_TYPE, LOGCAT_LOADER, 1,
        TEXT("XMLLoader"), TEXT("Making a placeholder for URI '%s', namespace '%s'."), pszURI, pszNameSpace);
#endif

    RegisterNameSpace( pszURI, NULL );
    pNewNS->pURIGen        = m_pLastURIGen;     
    pNewNS->pNextNameSpace = m_pNameSpaceStack;
    m_pNameSpaceStack=pNewNS;       // this is a stack.

    if( lstrcmpi(pszNameSpace, TEXT("")) == 0 )
        m_pCurrentDefaultURIGen=pNameSpaces;
}

//
// Called when a use of a namespace (e.g. WIN32: ) is made, to find the thing that handles this.
// we lookup in the stack to see which URI deals with this.
//
template <class N> _XMLDispatcher<N>::PURIGENERATOR _XMLDispatcher<N>::FindNameSpace( LPCTSTR pszNameSpace )
{
    TRACE(TEXT("Finding the namespace %s\n"), pszNameSpace );
    //
    // Now find the URI
    //
    PXMLNAMESPACESTACK pNameSpace = m_pNameSpaceStack;
    while( pNameSpace )
    {
        if( lstrcmpi( pNameSpace->pszNameSpace, pszNameSpace ) ==0 )
        {
            if( pNameSpace->pURIGen->pNameSpaceGenerator )
            {
                TRACE(TEXT("Found URI '%s'\n"), pNameSpace->pURIGen->pszURI);
                return pNameSpace->pURIGen;
            }

#ifdef LOGCAT_LOADER
            EVENTLOG( EVENTLOG_INFORMATION_TYPE, LOGCAT_LOADER, 1,
                TEXT("XMLLoader"), TEXT("No owner for namespace '%s' ('%s') checking registry"), pszNameSpace, pNameSpace->pURIGen->pszURI );
#endif
            // Pluggable generator.
            //
            // check the namespace to URI list
            //
            PXMLNAMESPACESTACK pNameSpaces=m_pNameSpaceStack;
            while( pNameSpaces )
            {
                if( lstrcmpi( pNameSpaces->pszNameSpace, pszNameSpace ) ==0 )
                {
                    //
                    // There is a URI for this namespace, check the registry for an owner.
                    //
                    PURIGENERATOR      pURIGen=pNameSpaces->pURIGen;
                    HKEY hURIGenRoot;
                    if( RegOpenKey( HKEY_LOCAL_MACHINE,
                        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RCML\\Win32Namespaces"),
                        &hURIGenRoot) == ERROR_SUCCESS )
                    {
                        //
                        // We expect to see a DLL and an EntryPoint under the URI for this namespace
                        //
                        HKEY hURIGen;
                        if( RegOpenKey( hURIGenRoot, pURIGen->pszURI, &hURIGen ) == ERROR_SUCCESS )
                        {
#ifdef LOGCAT_LOADER
                            EVENTLOG( EVENTLOG_WARNING_TYPE, LOGCAT_LOADER, 1,
                                TEXT("XMLLoader"), TEXT("This namespace '%s' is a registered extension"), pURIGen->pszURI);
#endif
                            DWORD dwLength=0;
                            DWORD dwType=REG_SZ;
                            if( RegQueryValueEx( hURIGen, TEXT("DLLName") , NULL, &dwType, NULL, &dwLength ) == ERROR_SUCCESS )
                            {
                                LPTSTR pszGenerator=new TCHAR[dwLength];
                                if( RegQueryValueEx( hURIGen, TEXT("DLLName"), NULL, &dwType, (LPBYTE)pszGenerator, &dwLength ) == ERROR_SUCCESS )
                                {
                                    //
                                    // Load library this guy
                                    //
#ifdef LOGCAT_LOADER
                                    EVENTLOG( EVENTLOG_INFORMATION_TYPE, LOGCAT_LOADER, 1,
                                        TEXT("XMLLoader"), TEXT("The DLL '%s' is registered for this namespace"), pszGenerator);
#endif
                                    if( HMODULE hMod = LoadLibrary( pszGenerator ) )
                                    {
                                        // Find the entry point.
                                        DWORD dwEPLength=0;
                                        if( RegQueryValueEx( hURIGen, TEXT("EntryPoint") , NULL, &dwType, NULL, &dwEPLength ) == ERROR_SUCCESS )
                                        {
                                            LPTSTR pszEP=new TCHAR[dwEPLength];
                                            if( RegQueryValueEx( hURIGen, TEXT("EntryPoint"), NULL, &dwType, (LPBYTE)pszEP, &dwEPLength ) == ERROR_SUCCESS )
                                            {
#ifdef LOGCAT_LOADER
                                                EVENTLOG( EVENTLOG_INFORMATION_TYPE, LOGCAT_LOADER, 1,
                                                    TEXT("XMLLoader"), TEXT("The entrypoint is '%s'"), pszEP);
#endif
                                                // GPA is ANSI only!
                                                LPSTR pAnsi = AnsiStringFromUnicode(pszEP);
                                                pNameSpace->pURIGen->pNameSpaceGenerator = (NSGENERATOR)GetProcAddress( hMod, pAnsi );
#ifdef LOGCAT_LOADER
                                                if( pNameSpace->pURIGen->pNameSpaceGenerator == NULL )
                                                {
                                                    EVENTLOG( EVENTLOG_ERROR_TYPE, LOGCAT_LOADER, 1,
                                                        TEXT("XMLLoader"), TEXT("Failed to find the generator '%s' in '%s'"), pszEP, pszGenerator);
                                                }
#endif
                                                delete [] pAnsi;
                                            }
                                            delete pszEP;
                                        }
                                    }
                                    else
                                    {
#ifdef LOGCAT_LOADER
                                        EVENTLOG( EVENTLOG_ERROR_TYPE, LOGCAT_LOADER, 1,
                                            TEXT("XMLLoader"), TEXT("Failed to find the extension '%s'"), pszGenerator);
#endif
                                    }
                                }
                                delete pszGenerator;
                            }
                            RegCloseKey( hURIGen );
                        }
                        RegCloseKey( hURIGenRoot );
                    }
                    TRACE(TEXT("Found URI '%s'\n"), pNameSpace->pURIGen->pszURI);
                    return pNameSpace->pURIGen;
                }
                pNameSpaces=pNameSpaces->pNextNameSpace;
            }
        }
        pNameSpace = pNameSpace->pNextNameSpace;
    }


#ifdef LOGCAT_LOADER
    EVENTLOG( EVENTLOG_INFORMATION_TYPE, LOGCAT_LOADER, 1,
        TEXT("XMLLoader"), TEXT("This namespace ('%s') has no associated xmlns entry in the file checking registry"), pszNameSpace);
#endif
    return NULL;
}


//
// Removes the namespaces of this node.
// m_pNameSpaceStack is a stack of SHORT names to generators for that short name, and
// which node owns them. We're popping all the nodes of the owning Node.
//
template <class N> void _XMLDispatcher<N>::PopNameSpaces(N * pOwningNode)
{
    //
    // Now find the URI
    //
    PXMLNAMESPACESTACK pNameSpace = m_pNameSpaceStack;
    PXMLNAMESPACESTACK * ppLastNameSpace = &m_pNameSpaceStack;
    while( pNameSpace ) // && (pNameSpace != m_pNameSpaceStack) )
    {
        if( pNameSpace->pOwningNode == pOwningNode )
        {
            TRACE(TEXT("Deleting URI '%s' from '%s'\n"),pNameSpace->pszNameSpace,
                pNameSpace->pURIGen->pszURI);

            // we're going to delete this pNameSpace
            *ppLastNameSpace = pNameSpace->pNextNameSpace;
            delete (LPWSTR)(pNameSpace->pszNameSpace);
            delete pNameSpace;

            pNameSpace=*ppLastNameSpace;
            TRACE(TEXT("We had NO default namespace generator any more\n"));
            m_pCurrentDefaultURIGen=NULL;
        }
        else
        {
            return;    // we should never 'jump' more than 1, so if we don't find it at this depth, it isn't here.
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlrect.cpp ===
// XMLRect.cpp: implementation of the CXMLRect class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "XMLRect.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
CXMLRect::CXMLRect()
{
	m_bInit=FALSE;
	NODETYPE = NT_RECT;
    m_StringType=L"RECT";
    m_pControlStyle=NULL;
}


//
// SS_BLACKRECT
// SS_GRAYRECT
// SS_WHITERECT
// 
// SS_BLACKFRAME
// SS_GRAYFRAME
// SS_WHITEFRAME
//
// SS_ETCHEDHORZ
// SS_ETCHEDVERT
// SS_ETCHEDFRAME
//
void CXMLRect::Init()
{
	if(m_bInit)
		return;
	BASECLASS::Init();

	if( m_Height == 0 )
		m_Height=8;

	m_Class=m_Class?m_Class:(LPWSTR)0x0082; // TEXT("STATIC");

    LPCTSTR req;
    if( m_pControlStyle )
    {
        m_Style |= m_pControlStyle->GetBaseStyles();
        if( req=m_pControlStyle->Get(TEXT("TYPE")) )
        {
            if( lstrcmpi( req, TEXT("BLACKRECT"))==0 )
                m_Style |= SS_BLACKRECT;
            else if( lstrcmpi( req, TEXT("GRAYRECT"))==0 )
                m_Style |= SS_GRAYRECT;
            else if( lstrcmpi( req, TEXT("WHITERECT"))==0 )
                m_Style |= SS_WHITERECT;
            else if( lstrcmpi( req, TEXT("BLACKFRAME"))==0 )
                m_Style |= SS_BLACKFRAME;
            else if( lstrcmpi( req, TEXT("GRAYFRAME"))==0 )
                m_Style |= SS_GRAYFRAME;
            else if( lstrcmpi( req, TEXT("WHITEFRAME"))==0 )
                m_Style |= SS_WHITEFRAME;
            else if( lstrcmpi( req, TEXT("ETCHEDHORZ"))==0 )
                m_Style |= SS_ETCHEDHORZ;
            else if( lstrcmpi( req, TEXT("ETCHEDVERT"))==0 )
                m_Style |= SS_ETCHEDVERT;
            else if( lstrcmpi( req, TEXT("ETCHEDFRAME"))==0 )
                m_Style |= SS_ETCHEDFRAME;
        }
    }
    else
        m_Style |= SS_ETCHEDFRAME; // default RECT is an etched frame.


    //
    //
    //
	m_bInit=TRUE;
}

HRESULT CXMLRect::AcceptChild(IRCMLNode * pChild )
{
    ACCEPTCHILD( L"STATICSTYLE", CXMLStaticStyle, m_pControlStyle );
    return BASECLASS::AcceptChild(pChild);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlrcml.h ===
// XMLRCML.h: interface for the CXMLRCML class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XMLRCML_H__CA1F1186_5D1C_4EEF_AD3F_FBFD8BD3DF86__INCLUDED_)
#define AFX_XMLRCML_H__CA1F1186_5D1C_4EEF_AD3F_FBFD8BD3DF86__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "xmlnode.h"
#include "xmlforms.h"
#include "xmllog.h"

class CXMLRCML  : public _XMLNode<IRCMLNode>
{
public:
	CXMLRCML();
	virtual ~CXMLRCML();

    IMPLEMENTS_RCMLNODE_UNKNOWN;
	typedef _XMLNode<IRCMLNode> BASECLASS;
   	XML_CREATE( RCML );

    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptChild( 
        IRCMLNode __RPC_FAR *child);

    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DoEndChild( 
        IRCMLNode __RPC_FAR *child);

    CXMLForms   * GetForms(int nIndex) { return m_FormsList.GetPointer(nIndex); }
    CXMLLog * GetLogging() { return m_qrLog.GetInterface(); } 

protected:
	void Init();

    CXMLFormsList   m_FormsList;
    CQuickRef<CXMLLog>  m_qrLog;
};

#endif // !defined(AFX_XMLRCML_H__CA1F1186_5D1C_4EEF_AD3F_FBFD8BD3DF86__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlscrollbar.h ===
// XMLScrollBar.h: interface for the CXMLScrollBar class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XMLSCROLLBAR_H__20D85B4A_05DB_40DA_B873_E9F099F53343__INCLUDED_)
#define AFX_XMLSCROLLBAR_H__20D85B4A_05DB_40DA_B873_E9F099F53343__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "XMLControl.h"

/////////////////////////////////////////////////////////////////////////////////
//
// Contains the shared style bits for all STATICs (label, rect, image)
//
/////////////////////////////////////////////////////////////////////////////////
class CXMLScrollBarStyle : public CXMLControlStyle
{
public:
    CXMLScrollBarStyle();
	virtual ~CXMLScrollBarStyle() {};
	typedef CXMLControlStyle BASECLASS;
	XML_CREATE( ScrollBarStyle );
    UINT    GetBaseStyles() { Init(); return scrollbarStyle; }
    void    Init();

//////////////////////////////////////////////////////////////////////////////////////////
//
// SBS_HORZ                    0x0000L  A @VERTICAL="NO"
// SBS_VERT                    0x0001L  A @VERTICAL="YES"
// SBS_TOPALIGN                0x0002L  A @ALIGN="TOP"
// SBS_LEFTALIGN               0x0002L  A @ALIGN="LEFT"
// SBS_BOTTOMALIGN             0x0004L  A @ALIGN="BOTOM"
// SBS_RIGHTALIGN              0x0004L  A @ALIGN="RIGHT"
// SBS_SIZEBOXTOPLEFTALIGN     0x0002L    WIN32:SCROLLBAR\@SIZEBOX="YES" the @ALIGN="TOP" or @ALIGN="LEFT"
// SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L    WIN32:SCROLLBAR\@SIZEBOX="YES" the @ALIGN="BOTTOM" or @ALIGN="RIGHT"
// SBS_SIZEBOX                 0x0008L    WIN32:SCROLLBAR\@SIZEBOX="YES"
// SBS_SIZEGRIP                0x0010L    WIN32:SCROLLBAR\@SIZEGRIP="YES"
//
protected:
    union
    {
        UINT    scrollbarStyle;
        struct {
            UINT    enum1:4;        // 5 bit enumation
            BOOL    m_SizeBox:1;
            BOOL    m_SizeGrip:1;
        };
    };
};


class CXMLScrollBar : public _XMLControl<IRCMLControl>  
{
public:
	CXMLScrollBar();
    virtual ~CXMLScrollBar() { delete m_pControlStyle; }
	typedef _XMLControl<IRCMLControl> BASECLASS;
	XML_CREATE( ScrollBar );
    IMPLEMENTS_RCMLCONTROL_UNKNOWN;

    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptChild( 
        IRCMLNode __RPC_FAR *child);

protected:
  	void Init();

    // These seem common enough as to allow them in RCML, rather than
    // WIN32:SLIDER styles.
    union
    {
        UINT    sliderStyle;
        struct {
            BOOL    m_AutoTicks:1;
            BOOL    m_Vertical:1;
            BOOL    m_TopOrLeft:1;
            BOOL    m_Both:1;
            BOOL    m_NoTicks:1;
            BOOL    m_Selection:1;
            BOOL    m_FixedLength:1;    // ??
            BOOL    m_NoThumb:1;        // ??
            BOOL    m_Tooltips:1;       // ?? 
        };
    };
    CXMLScrollBarStyle * m_pControlStyle;

};

#endif // !defined(AFX_XMLSCROLLBAR_H__20D85B4A_05DB_40DA_B873_E9F099F53343__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlrect.h ===
// XMLRect.h: interface for the CXMLRect class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XMLRECT_H__A7191044_880C_4D25_BF06_7025F9A4DCC0__INCLUDED_)
#define AFX_XMLRECT_H__A7191044_880C_4D25_BF06_7025F9A4DCC0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "XMLControl.h"
#include "xmllabel.h"

class CXMLRect : public _XMLControl<IRCMLControl>  
{
public:
	CXMLRect();
    virtual ~CXMLRect() { delete m_pControlStyle; }
   	XML_CREATE( Rect );
    IMPLEMENTS_RCMLCONTROL_UNKNOWN;
	typedef _XMLControl<IRCMLControl> BASECLASS;

    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptChild( 
        IRCMLNode __RPC_FAR *child);

protected:
   	void Init();
    CXMLStaticStyle * m_pControlStyle;

};

#endif // !defined(AFX_XMLRECT_H__A7191044_880C_4D25_BF06_7025F9A4DCC0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlscrollbar.cpp ===
// XMLScrollBar.cpp: implementation of the CXMLScrollBar class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "XMLScrollBar.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
#define CONTROLSTYLE(p,id, member, def) member = YesNo( id , def );

CXMLScrollBarStyle::CXMLScrollBarStyle()
{
	m_bInit=FALSE;
	NODETYPE = NT_SCROLLBARSTYLE;
    m_StringType=L"SCROLLBARSTYLE";
}

void CXMLScrollBarStyle::Init()
{
    if(m_bInit)
        return;
    BASECLASS::Init();

    scrollbarStyle=0;

    CONTROLSTYLE( SBS_SIZEBOX,      TEXT("SIZEBOX"),        m_SizeBox, FALSE );
    CONTROLSTYLE( SBS_SIZEGRIP,     TEXT("SIZEGRIP"),       m_SizeGrip, FALSE );
    
    m_bInit=TRUE;
}


//
//
//
CXMLScrollBar::CXMLScrollBar()
{
	m_bInit=FALSE;
	NODETYPE = NT_SCROLLBAR;
    m_StringType=L"SCROLLBAR";
    m_pControlStyle=NULL;
}

#define CONTROL(p,id, member, def) member = YesNo( id , def );

// SBS_HORZ                    0x0000L
// SBS_VERT                    0x0001L
// SBS_TOPALIGN                0x0002L
// SBS_LEFTALIGN               0x0002L
// SBS_BOTTOMALIGN             0x0004L
// SBS_RIGHTALIGN              0x0004L
// SBS_SIZEBOXTOPLEFTALIGN     0x0002L
// SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L
// SBS_SIZEBOX                 0x0008L
// SBS_SIZEGRIP                0x0010L

void CXMLScrollBar::Init()
{
	if(m_bInit)
		return;
	BASECLASS::Init();

	if( m_Height == 0 )
		m_Height=8;

	m_Class=m_Class?m_Class:(LPWSTR)0x0084;

    if( LPCTSTR req=Get(TEXT("ORIENTATION")) )
    {
        if(lstrcmpi(req,TEXT("VERTICAL"))==0)
            m_Style |= SBS_VERT;
    }

    if( LPCTSTR req=Get(TEXT("ALIGN")) )
    {
        if(lstrcmpi(req,TEXT("TOP"))==0)
            m_Style |= SBS_TOPALIGN;
        else if(lstrcmpi(req,TEXT("BOTTOM"))==0)
            m_Style |= SBS_BOTTOMALIGN;
        else if(lstrcmpi(req,TEXT("LEFT"))==0)
            m_Style |= SBS_LEFTALIGN;
        else if(lstrcmpi(req,TEXT("RIGHT"))==0)
            m_Style |= SBS_RIGHTALIGN;
    }

    if( m_pControlStyle )
        m_Style |= m_pControlStyle->GetBaseStyles();
    else
        m_Style |= 0; // edits don't have any defaults.

	m_bInit=TRUE;
}

HRESULT CXMLScrollBar::AcceptChild(IRCMLNode * pChild )
{
    ACCEPTCHILD( L"SCROLLBARSTYLE", CXMLScrollBarStyle, m_pControlStyle );
    return BASECLASS::AcceptChild(pChild);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlslider.cpp ===
// XMLSlider.cpp: implementation of the CXMLSlider class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "XMLSlider.h"
#include "xmldlg.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
CXMLSlider::CXMLSlider()
{
	m_bInit=FALSE;
	NODETYPE = NT_SLIDER;
    m_StringType=L"SLIDER";
    m_pRange = NULL;
}

//  TBS_AUTOTICKS           0x0001
//  TBS_VERT                0x0002
//  TBS_HORZ                0x0000
//  TBS_TOP                 0x0004
//  TBS_BOTTOM              0x0000
//  TBS_LEFT                0x0004
//  TBS_RIGHT               0x0000
//  TBS_BOTH                0x0008
//  TBS_NOTICKS             0x0010
//  TBS_ENABLESELRANGE      0x0020
//  TBS_FIXEDLENGTH         0x0040
//  TBS_NOTHUMB             0x0080
//  TBS_TOOLTIPS            0x0100

#define CONTROL(p,id, member, def) member = YesNo( id , def );

void CXMLSlider::Init()
{
	if(m_bInit)
		return;
	BASECLASS::Init();

	CXMLDlg::InitComctl32(ICC_BAR_CLASSES);

	if( m_Height == 0 )
		m_Height=8;

	m_Class=m_Class?m_Class:TRACKBAR_CLASS;

    sliderStyle=0;

    LPCTSTR req=Get(TEXT("TICKS"));
    if( req )
    {
        if(lstrcmpi(req,TEXT("LEFT"))==0 )
            m_Style |= TBS_LEFT;
        else if(lstrcmpi(req,TEXT("TOP"))==0 )
            m_Style |= TBS_TOP;
        else if(lstrcmpi(req,TEXT("RIGHT"))==0 )
            m_Style |= TBS_RIGHT;
        else if(lstrcmpi(req,TEXT("BOTTOM"))==0 )
            m_Style |= TBS_BOTTOM;
        else if(lstrcmpi(req,TEXT("BOTH"))==0 )
            m_Style |= TBS_BOTH;
        else if(lstrcmpi(req,TEXT("NONE"))==0 )
        {
            m_Style |= TBS_BOTH;
            m_Style |= TBS_NOTICKS;
        }
    }

    CONTROL( TBS_AUTOTICKS,    TEXT("AUTOTICKS"),      m_AutoTicks, FALSE );
    CONTROL( TBS_VERT,         TEXT("VERTICAL"),       m_Vertical, FALSE );
    CONTROL( TBS_ENABLESELRANGE,TEXT("SELECTION"),     m_Selection, FALSE );
    CONTROL( TBS_FIXEDLENGTH,  TEXT("FIXEDLENGTH"),    m_FixedLength, FALSE );
    CONTROL( TBS_NOTHUMB,      TEXT("NOTHUMB"),        m_NoThumb, FALSE );
    CONTROL( TBS_TOOLTIPS,     TEXT("TOOLTIPS"),       m_Tooltips, FALSE );

    m_Style |= sliderStyle;

	m_bInit=TRUE;
}

HRESULT CXMLSlider::OnInit(HWND hWnd)
{
    BASECLASS::OnInit(hWnd);
    if( m_pRange )
    {
	    //
	    // Set the upper lower and initial values
	    // what about page size and all that jazz?
	    //
	    SendMessage(hWnd, TBM_SETRANGEMIN, FALSE, m_pRange->GetMin() );
	    SendMessage(hWnd, TBM_SETRANGEMAX, FALSE, m_pRange->GetMax() );
	    DWORD dwRange=m_pRange->GetMax() - m_pRange->GetMin();
	    if( dwRange > 20 )
	    {
		    SendMessage(hWnd, TBM_SETTICFREQ, dwRange / 10, 0 );
		    SendMessage(hWnd, TBM_SETPAGESIZE, 0, dwRange/10 );
	    }
	    else
	    {
		    SendMessage(hWnd, TBM_SETTICFREQ, 1, 0 );
		    SendMessage(hWnd, TBM_SETPAGESIZE, 0, 1 );
	    }

	    SendMessage(hWnd, TBM_SETPOS, TRUE, m_pRange->GetValue() );
    }
    return S_OK;
}


HRESULT CXMLSlider::AcceptChild(IRCMLNode * pChild )
{
    ACCEPTCHILD( L"RANGE", CXMLRange, m_pRange );
    return BASECLASS::AcceptChild( pChild );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlslider.h ===
// XMLSlider.h: interface for the CXMLSlider class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XMLSLIDER_H__46B2D9A5_AF6B_44CC_9C53_F8AF811FBB10__INCLUDED_)
#define AFX_XMLSLIDER_H__46B2D9A5_AF6B_44CC_9C53_F8AF811FBB10__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "xmlcontrol.h"
#include "xmlitem.h"

class CXMLSlider : public _XMLControl<IRCMLControl>  
{
public:
	CXMLSlider();
    virtual ~CXMLSlider() { delete m_pRange; }
	typedef _XMLControl<IRCMLControl> BASECLASS;
	XML_CREATE( Slider );
    IMPLEMENTS_RCMLCONTROL_UNKNOWN;

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnInit( 
        HWND h);    // actually implemented

    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptChild( 
        IRCMLNode __RPC_FAR *child);

protected:
	void Init();
    CXMLRange   * m_pRange;    

    // These seem common enough as to allow them in RCML, rather than
    // WIN32:SLIDER styles.
    union
    {
        UINT    sliderStyle;
        struct {
            BOOL    m_AutoTicks:1;
            BOOL    m_Vertical:1;
            BOOL    m_TopOrLeft:1;
            BOOL    m_Both:1;
            BOOL    m_NoTicks:1;
            BOOL    m_Selection:1;
            BOOL    m_FixedLength:1;    // ??
            BOOL    m_NoThumb:1;        // ??
            BOOL    m_Tooltips:1;       // ?? 
        };
    };
};

#endif // !defined(AFX_XMLSLIDER_H__46B2D9A5_AF6B_44CC_9C53_F8AF811FBB10__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlspinner.cpp ===
// XMLSpinner.cpp: implementation of the CXMLSpinner class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "XMLSpinner.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////
//
// Up/Down control.
//
CXMLSpinner::CXMLSpinner()
{
	m_bInit=FALSE;
	NODETYPE = NT_SPINNER;
    m_StringType=L"SPINNER";
    m_pRange= NULL;
}

// UDS_WRAP                0x0001       @WRAP
// UDS_SETBUDDYINT         0x0002       @CONTENT="NUMBER" 
// UDS_ALIGNRIGHT          0x0004       @ALIGN="RIGHT"
// UDS_ALIGNLEFT           0x0008       @ALIGH="LEFT"
// UDS_AUTOBUDDY           0x0010       @BUDDY="AUTO"
// UDS_ARROWKEYS           0x0020       @ARROWKEYS="YES"    default
// UDS_HORZ                0x0040       @HORIZONTAL
// UDS_NOTHOUSANDS         0x0080       @NOTHOUSANDS
// UDS_HOTTRACK            0x0100       @HOTTRACK

void CXMLSpinner::Init()
{
	if(m_bInit)
		return;
	BASECLASS::Init();

	CXMLDlg::InitComctl32(ICC_UPDOWN_CLASS);

	if( m_Height == 0 )
		m_Height=14;

	if( m_Width == 0 )
		m_Width=11;

    LPCTSTR req;

    m_Style |= YesNo( TEXT("WRAP"), 0, 0, UDS_WRAP);

    req=Get(TEXT("CONTENT"));
    if( req && (lstrcmpi( req, TEXT("NUMBER") ) == 0 ))
        m_Style |= UDS_SETBUDDYINT;
       
    if( req=Get(TEXT("ALIGN")) )
    {
        if( lstrcmpi( req, TEXT("LEFT") ) == 0 )
            m_Style |= UDS_ALIGNLEFT;

        if( lstrcmpi( req, TEXT("RIGHT") ) == 0 )
            m_Style |= UDS_ALIGNRIGHT;
    }

    if( req=Get(TEXT("BUDDY")) )
        if( lstrcmpi(req, TEXT("AUTO"))==0 )
            m_Style |= UDS_AUTOBUDDY;

    m_Style |= YesNo( TEXT("ARROWKEYS"), UDS_ARROWKEYS, 0, UDS_ARROWKEYS);

    if( LPCTSTR req=Get(TEXT("ORIENTATION")) )
    {
        if(lstrcmpi(req,TEXT("HORIZONTAL"))==0)
            m_Style |= UDS_HORZ;
    }

    m_Style |= YesNo( TEXT("NOTHOUSANDS"), 0, 0, UDS_NOTHOUSANDS);
    m_Style |= YesNo( TEXT("HOTTRACK"), 0, 0, UDS_HOTTRACK);

	m_Class=m_Class?m_Class:UPDOWN_CLASS;

	m_bInit=TRUE;
}

HRESULT CXMLSpinner::OnInit(HWND hWnd)
{
    BASECLASS::OnInit(hWnd);
    if( m_pRange )
    {
	    //
	    // Set the upper lower and initial values
	    // what about page size and all that jazz?
	    //
	    SendMessage(hWnd, UDM_SETRANGE32, m_pRange->GetMin(), m_pRange->GetMax() );
	    SendMessage(hWnd, UDM_SETPOS, 0, MAKELONG(m_pRange->GetValue(),0) );
    }
    return S_OK;
}

HRESULT CXMLSpinner::AcceptChild(IRCMLNode * pChild )
{
    ACCEPTCHILD( L"RANGE", CXMLRange, m_pRange );
    return BASECLASS::AcceptChild( pChild );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlstringtable.cpp ===
// XMLStringTable.cpp: implementation of the CXMLStringTable class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "XMLStringTable.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CXMLStringTable::CXMLStringTable()
{
  	NODETYPE = NT_STRINGTABLE;
    m_StringType=L"STRINGTABLE";
}

CXMLStringTable::~CXMLStringTable()
{

}

void CXMLStringTable::Init()
{
}

HRESULT CXMLStringTable::AcceptChild(IRCMLNode * pChild )
{
    if( SUCCEEDED( pChild->IsType( L"ITEM" ) ))
    {   AppendItem((CXMLItem*)pChild); return S_OK; }
    return BASECLASS::AcceptChild(pChild);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlspinner.h ===
// XMLSpinner.h: interface for the CXMLSpinner class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XMLSPINNER_H__19B7A23F_F8E5_456E_B8B1_1D90DBD1BB48__INCLUDED_)
#define AFX_XMLSPINNER_H__19B7A23F_F8E5_456E_B8B1_1D90DBD1BB48__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "XMLControl.h"
#include "xmlitem.h"

class CXMLSpinner : public _XMLControl<IRCMLControl>  
{
public:
	CXMLSpinner();
	virtual ~CXMLSpinner() {delete m_pRange; }
	typedef _XMLControl<IRCMLControl> BASECLASS;
	XML_CREATE( Spinner );
    IMPLEMENTS_RCMLCONTROL_UNKNOWN;

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnInit( 
        HWND h);    // actually implemented

    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptChild( 
        IRCMLNode __RPC_FAR *child);

protected:
	void Init();
    CXMLRange   * m_pRange;
};

#endif // !defined(AFX_XMLSPINNER_H__19B7A23F_F8E5_456E_B8B1_1D90DBD1BB48__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmltreeview.h ===
// XMLTreeView.h: interface for the CXMLTreeView class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XMLTREEVIEW_H__326AAFFC_0502_4ADF_8AAE_9F487FBDD217__INCLUDED_)
#define AFX_XMLTREEVIEW_H__326AAFFC_0502_4ADF_8AAE_9F487FBDD217__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "XMLControl.h"

class CXMLTreeViewStyle : public CXMLControlStyle
{
public:
    CXMLTreeViewStyle();
	virtual ~CXMLTreeViewStyle() {};
	typedef CXMLControlStyle BASECLASS;
	XML_CREATE( TreeViewStyle );
    UINT    GetBaseStyles() { Init(); return treeViewStyle; }
    void    Init();

protected:
// TVS_HASBUTTONS          0x0001   @EXPANDBOXES="YES" (or @HASBUTTONS?)
// TVS_HASLINES            0x0002   @LINES="YES"
// TVS_LINESATROOT         0x0004   @LINES="ROOT" (turns on TVS_HASLINES)
// TVS_EDITLABELS          0x0008   @EDITLABELS="YES"
// TVS_DISABLEDRAGDROP     0x0010   @DISABLEDRAGDROP="YES"
// TVS_SHOWSELALWAYS       0x0020   WIN32:TREEVIEW @SHOWSELALWAYS="YES"
// TVS_RTLREADING          0x0040   WIN32:TREEVIEW @RTLREADING="YES"

// TVS_NOTOOLTIPS          0x0080   @TOOLTIPS="NO"
// TVS_CHECKBOXES          0x0100   @CHECBOXES="YES"
// TVS_TRACKSELECT         0x0200   WIN32:TREEVIEW @TRACKSELECT="YES"
// TVS_SINGLEEXPAND        0x0400   @AUTOEXPAND="YES"
// TVS_INFOTIP             0x0800   WIN32:TREEVIEW @INFOTIP="YES"
// TVS_FULLROWSELECT       0x1000   @FULLROWSELECT="YES"
// TVS_NOSCROLL            0x2000   @NOSCROLL="YES"
// TVS_NONEVENHEIGHT       0x4000   WIN32:TREEVIEW @NOEVENHEIGHT="YES"
    union
    {
        UINT    treeViewStyle;
        struct {
            UINT    enum1:5;           // 5 bit nothing
            BOOL    m_ShowSelAlways:1;
            BOOL    m_RTLReading:1;
            UINT    enum2:2;           // 2 bit nothing
            BOOL    m_TrackSelect:1;
            UINT    enum3:1;           // 1 bit nothing
            BOOL    m_InfoTip:1;
            UINT    enum4:2;           // 2 bit nothing
            BOOL    m_NoEvenHeight:1;
        };
    };
};


class CXMLTreeView : public _XMLControl<IRCMLControl>  
{
public:
	CXMLTreeView();
    virtual ~CXMLTreeView() { delete m_pControlStyle; }
	typedef _XMLControl<IRCMLControl> BASECLASS;
	XML_CREATE( TreeView );
    IMPLEMENTS_RCMLCONTROL_UNKNOWN;

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnInit( 
        HWND h);    // actually implemented

    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptChild( 
        IRCMLNode __RPC_FAR *child);

protected:
	void Init();
    CXMLTreeViewStyle * m_pControlStyle;

};

#endif // !defined(AFX_XMLTREEVIEW_H__326AAFFC_0502_4ADF_8AAE_9F487FBDD217__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlstyle.h ===
// XMLStyle.h: interface for the CXMLStyle and CXMLHelp classes
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XMLSTYLE_H__10396EA8_E2E1_11D2_8BD0_00C04FB177B1__INCLUDED_)
#define AFX_XMLSTYLE_H__10396EA8_E2E1_11D2_8BD0_00C04FB177B1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "xmlnode.h"
#include "fonts.h"

#define NUMELEMENTS(a) (sizeof(a)/sizeof(a[0]))

BOOL StringToCOLORREF(LPCTSTR string, COLORREF* pColorRef);

typedef struct _COLOR_MAP
{
	LPTSTR		pszColorName;
	COLORREF	cref;
} COLOR_MAP, * PCOLOR_MAP;

typedef enum BORDERSTYLEENUM {
	DASHED,
	DOTTED,
	GROOVE,
	HIDDEN,
	INSET,
	OUTSET,
	RIDGE,
	SOLID,
};

typedef struct _BORDER_STYLE_MAP
{
	LPTSTR		pszBorderStyle;
	BORDERSTYLEENUM	style;
} BORDER_STYLE_MAP, * PBORDER_STYLE_MAP;

#define BORDERSTYLE(s)	{ TEXT(#s), s }

static BORDER_STYLE_MAP BorderStyleMapArray[] = 
{
	BORDERSTYLE(DASHED),
	BORDERSTYLE(DOTTED),
	BORDERSTYLE(GROOVE),
	BORDERSTYLE(HIDDEN),
	BORDERSTYLE(INSET),
	BORDERSTYLE(OUTSET),
	BORDERSTYLE(RIDGE),
	BORDERSTYLE(SOLID),
};


//////////////////////////////////////////////////////////////////////
// GetStringIndex fills pointerToFoundStruct with a pointer to the structure 
// whose FieldToSearchFor string is the the same with the pattern.  Case insensitive and
// assumes the stringsArray is sorted on FieldToSearchFor
//
//////////////////////////////////////////////////////////////////////
#define  GetStringIndex(Array, FieldToSearchFor, pattern, pointerToFoundStruct)	\
{																\
	int numStrings = sizeof(Array)/sizeof(Array[0]);			\
	int cmp, left = 0, right = numStrings-1, mid;				\
																\
	pointerToFoundStruct = NULL;								\
	while(left<=right)											\
	{															\
		mid = (left+right)/2;									\
		cmp = lstrcmpi(Array[mid].FieldToSearchFor, pattern);	\
		if(cmp<0)												\
			left = mid+1;										\
		else if(cmp>0)											\
			right = mid-1;										\
		else													\
		{														\
			pointerToFoundStruct = &Array[mid];					\
			break;												\
		}														\
	}															\
}																	

#define _COMPROP( dataMember ) { Init(); *pVal=m_##dataMember; return S_OK; }

//
// Uses the CRCMLNodeImp for IRCMLNode methods
//
class CXMLStyle : public _XMLNode<IRCMLCSS>
{
public:
	CXMLStyle();
    CXMLStyle( const CXMLStyle & style )
    { 
        // Review - Don't think this is right.
        m_pDialogStyle=style.m_pDialogStyle;
        // m_hFont=style.m_hFont;
    };

#ifdef _DEBUG
    virtual ULONG STDMETHODCALLTYPE AddRef( void)
    { return BASECLASS::AddRef(); }

    virtual ULONG STDMETHODCALLTYPE Release( void)
    { return BASECLASS::Release(); }
#endif

//    IMPLEMENTS_RCMLNODE_UNKNOWN;
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void ** ppvObject) 
    {   if (riid == IID_IUnknown) 
            *ppvObject = static_cast<IUnknown*>(this);  
        else if (riid == __uuidof(IRCMLNode))           
            *ppvObject = static_cast<IRCMLNode*>(this); 
        else if (riid == __uuidof(IRCMLCSS))        
            *ppvObject = static_cast<IRCMLCSS*>(this); 
        else 
        {
            *ppvObject = NULL; return E_NOINTERFACE; 
        }
        reinterpret_cast<IUnknown*>(*ppvObject)->AddRef(); 
        return S_OK; 
    }

	typedef _XMLNode<IRCMLCSS> BASECLASS;
	XML_CREATE( Style );

	virtual ~CXMLStyle();

        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Font( 
            /* [retval][out] */ HFONT __RPC_FAR *pVal) 
        { 
            Init(); 
            // *pVal = m_hFont->GetFont(); 
            *pVal = m_hFont;
            return S_OK; 
        }
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Brush( 
            /* [retval][out] */ HBRUSH __RPC_FAR *pVal) 
            _COMPROP( hBrush )
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Pen( 
            /* [retval][out] */ DWORD __RPC_FAR *pVal) 
        {
            Init();
            *pVal=(DWORD)m_hPen;
            return S_OK;
        }
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Color( 
            /* [retval][out] */ COLORREF __RPC_FAR *pVal) 
            _COMPROP( crefColor )
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_BkColor( 
            /* [retval][out] */ COLORREF __RPC_FAR *pVal) 
            _COMPROP( crefBackgroundColor )
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_DialogStyle( 
            /* [retval][out] */ IRCMLCSS __RPC_FAR **pVal) 
        {
            *pVal = m_pDialogStyle;
            return S_OK; 
        }

        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE put_DialogStyle( 
              /* [in] */ IRCMLCSS __RPC_FAR *pVal) 
        {
            if(m_pDialogStyle)
                m_pDialogStyle->Release();
            m_pDialogStyle = pVal;
            if(m_pDialogStyle)
                m_pDialogStyle->AddRef();            
            return S_OK; 
        }

        
//	void SetDialogStyle( RCMLCSSStyleNode * pStyle) { m_pDialogStyle=pStyle; }

        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Visible( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) 
            _COMPROP( Visible );

        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Display( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) 
            _COMPROP( Display );
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_BorderWidth( 
            /* [retval][out] */ int __RPC_FAR *pVal) 
            { Init(); *pVal = m_Border.GetWidth(); return S_OK; }
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_BorderStyle( 
            /* [retval][out] */ LPWSTR __RPC_FAR *pVal) 
            { Init(); *pVal= BorderStyleMapArray[m_Border.GetStyle()].pszBorderStyle; 
        return S_OK; }

        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_GrowsWide( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal)
            _COMPROP( GrowsWide);
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_GrowsTall( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal)
            _COMPROP( GrowsHigh);

        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ClipHoriz( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal)
            _COMPROP( ClipHoriz );
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ClipVert( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal)
            _COMPROP( ClipVert );

//	LPCTSTR		GetStyleName() { Init(); return m_StyleName; }
    CQuickFont * GetQuickFont() { Init(); return &m_QuickFont; }

	PROPERTY(BOOL, GrowsWide ); // TRUE means we can grow wider
	PROPERTY(BOOL, GrowsHigh ); // TRUE means we can grow taller
	PROPERTY(BOOL, ClipHoriz ); // TRUE means we CAN be CLIPPED (default is FALSE)
	PROPERTY(BOOL, ClipVert  ); // TRUE means we CAN be CLIPPED (default is FALSE)
	PROPERTY(BOOL, Visible );
	PROPERTY(BOOL, Display );

    //
    // BORDER stuff.
    //
    COLORREF    GetBorderColor() { Init(); return m_Border.GetColor(); }


protected:
	IRCMLCSS  * m_pDialogStyle;	// parent style object.
	void		Init();
	void		InitFontInfo();
	void		InitBorderInfo();
	void		InitColors();

	LPTSTR		m_StyleName;
    CQuickFont  m_QuickFont;
    HFONT       m_hFont;
	HBRUSH		m_hBrush;
	HPEN		m_hPen;

    //
    // Sizing information: "FILL"
    //
    struct
    {
   	    BOOL		m_GrowsWide:1;
        BOOL		m_GrowsHigh:1;
        BOOL        m_bInit:1;
        BOOL        m_Visible:1;
        BOOL        m_Display:1;
        BOOL        m_ClipHoriz:1;
        BOOL        m_ClipVert:1;
    };

	//
	// Properties that make up the Style element.
	//
	// FONT-FAMILY
	// FONT-SIZE
	// FONT-STYLE : normal | italic | oblique - NO BOLD
	// FONT-WEIGHT : normal | bold | bolder | lighter | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900
	// FONT -> family size style weight
	// 

	//
	// ultimately gets put into the CQuickFont - REVIEW _ remove these
	//
	LPCTSTR	m_Font;			// the FONT string.
	LPCTSTR	m_fontFamily;	
	LPCTSTR	m_fontSize;		// this can be relative, hard to work out until runtime, and then you need your parent already.
	LPCTSTR	m_fontStyle;	// GDI style
	LPCTSTR	m_fontWeight;	// BOLD / bloder / lighter are hard.

    //
    // Border
    //
    class CBorder
    {
    public:
        CBorder() : m_Style(0), m_Width(0), m_Color(0) {};
	    CBorder(int style, int width, COLORREF color) : m_Style(style), m_Width(width), m_Color(color) {};
	    void DrawBorder(HDC hdc, LPRECT pRect);
        int  GetWidth() { return m_Width; }
        int  GetColor() { return m_Color; }
        int  GetStyle() { return m_Style; }
        void  SetWidth( int Width ) { m_Width = Width; }
        void  SetColor( int Color ) { m_Color = Color; }
        void  SetStyle( int Style ) { m_Style = Style; }
    private:
	    int				m_Style;    // lookup in BorderStyleMapArray for the style name.
	    int				m_Width;
	    COLORREF		m_Color;
    };
	CBorder m_Border;

	//
	// Color properties
	//
	// BACKGROUND
	// BACKGROUND-COLOR
	// BACKGROUND-IMAGE
	//
	LPCTSTR		m_Background;

	COLORREF	m_crefColor;
	COLORREF	m_crefBackgroundColor;
};

#ifdef _OLD_UNUSED_CODE
class CXMLStyles : 	public _List<CXMLStyle> 
{
public:
	CXMLStyles();
	virtual ~CXMLStyles();
	XML_CREATE( Styles );

	CXMLStyle	*	FindStyle( LPCTSTR ID );
private :
};
#endif

#endif // !defined(AFX_XMLSTYLE_H__10396EA8_E2E1_11D2_8BD0_00C04FB177B1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmltreeview.cpp ===
// XMLTreeView.cpp: implementation of the CXMLTreeView class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "XMLTreeView.h"
#undef _WIN32_IE
#define _WIN32_IE 0x500

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

#define CONTROLSTYLE(p,id, member, def) member = YesNo( id , def );

CXMLTreeViewStyle::CXMLTreeViewStyle()
{
	m_bInit=FALSE;
	NODETYPE = NT_TREEVIEWSTYLE;
    m_StringType=L"WIN32:TREEVIEW";
}

void CXMLTreeViewStyle::Init()
{
    if(m_bInit)
        return;
    BASECLASS::Init();

    treeViewStyle=0;

    CONTROLSTYLE( TVS_SHOWSELALWAYS,   TEXT("SHOWSELALWAYS"), m_ShowSelAlways, FALSE );
    CONTROLSTYLE( TVS_RTLREADING,      TEXT("RTLREADING"),    m_RTLReading,    FALSE );
    CONTROLSTYLE( TVS_TRACKSELECT,     TEXT("TRACKSELECT"),   m_TrackSelect,   FALSE );
    CONTROLSTYLE( TVS_INFOTIP,         TEXT("INFOTIP"),       m_InfoTip,       FALSE );
    CONTROLSTYLE( TVS_NONEVENHEIGHT,   TEXT("NONEVENHEIGHT"), m_NoEvenHeight,  FALSE );

    m_bInit=TRUE;
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
CXMLTreeView::CXMLTreeView()
{
	m_bInit=FALSE;
	NODETYPE = NT_TREEVIEW;
    m_StringType=TEXT("TREEVIEW");
    m_pControlStyle=NULL;
}

// TVS_HASBUTTONS          0x0001   @EXPANDBOXES="YES" (or @HASBUTTONS?)
// TVS_HASLINES            0x0002   @LINES="YES"
// TVS_LINESATROOT         0x0004   @LINES="ROOT" (turns on TVS_HASLINES)
// TVS_EDITLABELS          0x0008   @EDITLABELS="YES"
// TVS_DISABLEDRAGDROP     0x0010   @DISABLEDRAGDROP="YES"
// TVS_SHOWSELALWAYS       0x0020   WIN32:TREEVIEW @SHOWSELALWAYS="YES"
// TVS_RTLREADING          0x0040   WIN32:TREEVIEW @RTLREADING="YES"

// TVS_NOTOOLTIPS          0x0080   @NOTOOLTIPS="YES"
// TVS_CHECKBOXES          0x0100   @CHECBOXES="YES"
// TVS_TRACKSELECT         0x0200   WIN32:TREEVIEW @TRACKSELECT="YES"
// TVS_SINGLEEXPAND        0x0400   @AUTOEXPAND="YES"
// TVS_INFOTIP             0x0800   WIN32:TREEVIEW @INFOTIP="YES"
// TVS_FULLROWSELECT       0x1000   @FULLROWSELECT="YES"
// TVS_NOSCROLL            0x2000   @NOSCROLL="YES"
// TVS_NONEVENHEIGHT       0x4000   WIN32:TREEVIEW @NOEVENHEIGHT="YES"

void CXMLTreeView::Init()
{
	if(m_bInit)
		return;
    BASECLASS::Init();

	if( m_Height == 0 )
		m_Height=8;

	if( m_Width == 0 )
		m_Width=8;

    m_Style |= YesNo( TEXT("EXPANDBOXES"), 0, 0, TVS_HASBUTTONS);

    LPCTSTR req;
    if( req= Get(TEXT("LINES")))
    {
        if( lstrcmpi(req,TEXT("ROOT"))==0 )
            m_Style |= TVS_HASLINES | TVS_LINESATROOT;
        else if( lstrcmpi(req,TEXT("YES"))==0 )
            m_Style |= TVS_HASLINES ;
    }
    
    m_Style |= YesNo( TEXT("EDITLABELS"), 0, 0, TVS_EDITLABELS);
    m_Style |= YesNo( TEXT("DISABLEDRAGDROP"), 0, 0, TVS_DISABLEDRAGDROP);
    m_Style |= YesNo( TEXT("NOTOOLTIPS"), 0, 0, TVS_NOTOOLTIPS);
    m_Style |= YesNo( TEXT("CHECBOXES"), 0, 0, TVS_CHECKBOXES);
    m_Style |= YesNo( TEXT("AUTOEXPAND"), 0, 0, TVS_SINGLEEXPAND);
    m_Style |= YesNo( TEXT("FULLROWSELECT"), 0, 0, TVS_FULLROWSELECT);
    m_Style |= YesNo( TEXT("NOSCROLL"), 0, 0, TVS_NOSCROLL);


    if( m_pControlStyle )
        m_Style |= m_pControlStyle->GetBaseStyles();
    else
        m_Style |= 0; // edits don't have any defaults.

	m_Class=m_Class?m_Class:WC_TREEVIEW;

	m_bInit=TRUE;
}

HRESULT CXMLTreeView::OnInit(HWND hWnd)
{
    BASECLASS::OnInit(hWnd);
	TRACE(TEXT("How do we init the tree view?\n"));
    return S_OK;
}

HRESULT CXMLTreeView::AcceptChild(IRCMLNode * pChild )
{
    ACCEPTCHILD( L"WIN32:TREEVIEW", CXMLTreeViewStyle, m_pControlStyle );
    return BASECLASS::AcceptChild(pChild);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlstringtable.h ===
// XMLStringTable.h: interface for the CXMLStringTable class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XMLSTRINGTABLE_H__5C19CE8A_014F_42BD_9A1F_F5477A7098F7__INCLUDED_)
#define AFX_XMLSTRINGTABLE_H__5C19CE8A_014F_42BD_9A1F_F5477A7098F7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "xmlnode.h"
#include "xmlitem.h"

class CXMLStringTable : public _XMLNode<IRCMLNode>  
{
public:
	CXMLStringTable();
	virtual ~CXMLStringTable();

	XML_CREATE( StringTable );
    IMPLEMENTS_RCMLNODE_UNKNOWN;
	typedef _XMLNode<IRCMLNode> BASECLASS;

    //
    // Returns the text for a particular ID - NULL if it's not there.
    //
	LPCTSTR	GetText(UINT id);

    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptChild( 
        IRCMLNode __RPC_FAR *pChild);

    BOOL    AppendItem( CXMLItem * pItem) { return m_ItemList.Append(pItem); }
    CXMLItem * GetItem(int index) { return m_ItemList.GetPointer(index); }

private:
	void        Init();
    CXMLItemList m_ItemList;
};

#endif // !defined(AFX_XMLSTRINGTABLE_H__5C19CE8A_014F_42BD_9A1F_F5477A7098F7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlwin32.cpp ===
// XMLWin32.cpp: implementation of the CXMLWin32 class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "XMLWin32.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CXMLWin32::CXMLWin32()
{
    NODETYPE = NT_WIN32;
    m_StringType=L"WIN32:STYLE";
}

CXMLWin32::~CXMLWin32()
{

}

#define STYLEEX(p,id, member, def) member = YesNo( id , def );
#define STYLE(p,id, member, def) member = YesNo( id , def );

void CXMLWin32::Init()
{
   	if(m_bInit)
		return;

	BASECLASS::Init();

    //
    // First get the over-riding bits
    //
    ValueOf( L"STYLE", 0, &m_Style );
    ValueOf( L"STYLEEX", 0, &m_StyleEx );
    m_Class     = NULL; // you CAN override the class name here, or on the element itself.

    //
    // Then in combination with the attributes. If you miss one off, or set it to NO
    // it will remove it - regardless of the STYLE WINDOWSTYLE and STYLEEX settings.
    //

    // Quick for loop for the CONTROL styles
    //
    DWORD dwRemainingStyle=0;
    TCHAR szBuffer[10];
    for(int i=0;i<16;i++)
    {
        wsprintf(szBuffer,TEXT("CS_BIT%02d"), i );
        if( YesNo( szBuffer , FALSE ) )
            dwRemainingStyle |= (1 << i );
    }
    m_Style |= dwRemainingStyle;


    //
    // The following table is a cut/PASTE from the generator
    // that way we keep the defaults in line. This is for the controls.
    // the dialog has a different take CARE must be taken.
    //
    STYLE( WS_POPUP           , TEXT("POPUP") ,             m_Popup,        FALSE );
    STYLE( WS_CHILD           , TEXT("CHILD") ,             m_Child,        TRUE );
    STYLE( WS_MINIMIZE        , TEXT("MAXIMIZEBUTTON") ,    m_MaximizeButton,   FALSE );
    STYLE( WS_VISIBLE         , TEXT("VISIBLE") ,           m_Visible,      TRUE );

    STYLE( WS_DISABLED        , TEXT("DISABLED") ,          m_Disabled,     FALSE );
    STYLE( WS_CLIPSIBLINGS    , TEXT("CLIPSIBLINGS") ,      m_ClipSiblings, FALSE ); // CARE?
    STYLE( WS_CLIPCHILDREN    , TEXT("CLIPCHILDREN") ,      m_ClipChildren, FALSE ); // CARE?

    STYLE( WS_BORDER          , TEXT("BORDER") ,            m_Border,       FALSE );
    STYLE( WS_DLGFRAME        , TEXT("DLGFRAME") ,          m_DlgFrame,     FALSE ); // CARE?
    STYLE( WS_VSCROLL         , TEXT("VSCROLL") ,           m_VScroll,      FALSE );
    STYLE( WS_HSCROLL         , TEXT("HSCROLL") ,           m_HScroll,      FALSE );

    STYLE( WS_SYSMENU         , TEXT("SYSMENU"),            m_SysMenu,      FALSE ); // CARE?
    STYLE( WS_THICKFRAME      , TEXT("THICKFRAME") ,        m_ThickFrame,   FALSE ); // CARE?
    STYLE( WS_GROUP           , TEXT("GROUP") ,             m_Group,        FALSE );
    STYLE( WS_TABSTOP         , TEXT("TABSTOP") ,           m_TabStop,      FALSE );


    //
    // EX style bits.
    //
    
    STYLEEX( WS_EX_DLGMODALFRAME     , TEXT("MODALFRAME"),    m_ModalFrame,     FALSE );
    STYLEEX( 0x2                     , TEXT("EXBIT1"),          m_Bit1, FALSE );
    STYLEEX( WS_EX_NOPARENTNOTIFY    , TEXT("NOPARENTNOTIFY"),m_NoParentNotify, FALSE );
    STYLEEX( WS_EX_TOPMOST           , TEXT("TOPMOST"),       m_TopMost,        FALSE );

    STYLEEX( WS_EX_ACCEPTFILES       , TEXT("DROPTARGET"),    m_DropTarget,     FALSE );
    STYLEEX( WS_EX_TRANSPARENT       , TEXT("TRANSPARENT"),   m_Transparent,    FALSE );
    STYLEEX( WS_EX_MDICHILD          , TEXT("MDI"),           m_MDI,            FALSE );
    STYLEEX( WS_EX_TOOLWINDOW        , TEXT("TOOLWINDOW"),    m_ToolWindow,     FALSE );

    STYLEEX( WS_EX_WINDOWEDGE        , TEXT("WINDOWEDGE"),    m_WindowEdge,     FALSE );
    STYLEEX( WS_EX_CLIENTEDGE        , TEXT("CLIENTEDGE"),    m_ClientEdge,     FALSE );
    STYLEEX( WS_EX_CONTEXTHELP       , TEXT("CONTEXTHELP"),   m_ContextHelp,    FALSE );
    STYLEEX( 0x00000800L             , TEXT("EXBIT11"),         m_Bit11,          FALSE );

    STYLEEX( WS_EX_RIGHT             , TEXT("RIGHT"),         m_Right,          FALSE );
    STYLEEX( WS_EX_RTLREADING        , TEXT("RTLREADING"),    m_RTLReading,     FALSE );
    STYLEEX( WS_EX_LEFTSCROLLBAR     , TEXT("LEFTSCROLLBAR"), m_LeftScrollbar,  FALSE );
    STYLEEX( 0x00008000L             , TEXT("EXBIT15"),       m_Bit15,          FALSE );

    STYLEEX( WS_EX_CONTROLPARENT     , TEXT("CONTROLPARENT"), m_ControlParent,  FALSE );
    STYLEEX( WS_EX_STATICEDGE        , TEXT("STATICEDGE"),    m_StaticEdge,     FALSE );
    STYLEEX( WS_EX_APPWINDOW         , TEXT("APPWINDOW"),     m_AppWindow,      FALSE );
    STYLEEX( 0x00080000L             , TEXT("EXBIT19"),       m_Bit19,          FALSE );

    STYLEEX( 0x00100000L             , TEXT("EXBIT20"),       m_Bit20,          FALSE );
    STYLEEX( 0x00200000L             , TEXT("EXBIT21"),       m_Bit21,          FALSE );
    STYLEEX( 0x00400000L             , TEXT("EXBIT22"),       m_Bit22,          FALSE );
    STYLEEX( 0x00800000L             , TEXT("EXBIT23"),       m_Bit23,          FALSE );

    STYLEEX( 0x01000000L             , TEXT("EXBIT24"),       m_Bit24,          FALSE );
    STYLEEX( 0x02000000L             , TEXT("EXBIT25"),       m_Bit25,          FALSE );
    STYLEEX( 0x04000000L             , TEXT("EXBIT26"),       m_Bit26,          FALSE );
    STYLEEX( 0x08000000L             , TEXT("EXBIT27"),       m_Bit27,          FALSE );

    STYLEEX( 0x10000000L             , TEXT("EXBIT28"),       m_Bit28,          FALSE );
    STYLEEX( 0x20000000L             , TEXT("EXBIT29"),       m_Bit29,          FALSE );
    STYLEEX( 0x40000000L             , TEXT("EXBIT30"),       m_Bit30,          FALSE );
    STYLEEX( 0x80000000L             , TEXT("EXBIT31"),       m_Bit31,          FALSE );

    m_bInit=TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlwin32.h ===
// XMLWin32.h: interface for the CXMLWin32 class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XMLWIN32_H__5D544D33_2C2B_4CB1_AC6B_7E6A5BF8D3DF__INCLUDED_)
#define AFX_XMLWIN32_H__5D544D33_2C2B_4CB1_AC6B_7E6A5BF8D3DF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "xmlnode.h"

class CXMLWin32 : public _XMLNode<IRCMLNode>
{
public:
	CXMLWin32();
	virtual ~CXMLWin32();
	typedef _XMLNode<IRCMLNode> BASECLASS;
    IMPLEMENTS_RCMLNODE_UNKNOWN;
	XML_CREATE( Win32 );

	PROPERTY( DWORD, Style );
	PROPERTY( DWORD, StyleEx );

//  WS_OVERLAPPED       0x00000000L     WIN32\@Overlapped
//    PROPERTY( BOOL, Overlapped );
//  WS_POPUP            0x80000000L     WIN32\@Popup
    PROPERTY( BOOL, Popup );
//  WS_CHILD            0x40000000L     WIN32\@Child
    PROPERTY( BOOL, Child );
//  WS_MINIMIZE         0x20000000L     WIN32\@MaximizeButton
    PROPERTY( BOOL, MaximizeButton );
//  WS_VISIBLE          0x10000000L     WIN32\@VISIBLE
    PROPERTY( BOOL, Visible );

//  WS_DISABLED         0x08000000L     WIN32\@DISABLED
    PROPERTY( BOOL, Disabled );
//  WS_CLIPSIBLINGS     0x04000000L     WIN32\@ClipSiblings
    PROPERTY( BOOL, ClipSiblings );
//  WS_CLIPCHILDREN     0x02000000L     WIN32\@ClipChildren
    PROPERTY( BOOL, ClipChildren );

//  WS_BORDER           0x00800000L     WIN32\@BORDER="YES"
    PROPERTY( BOOL, Border );
//  WS_DLGFRAME         0x00400000L     WIN32\@DLGFRAME="YES"
    PROPERTY( BOOL, DlgFrame );
//  WS_VSCROLL          0x00200000L     WIN32\@VSCROLL
    PROPERTY( BOOL, VScroll );
//  WS_HSCROLL          0x00100000L     WIN32\@HSCROLL
    PROPERTY( BOOL, HScroll );

//  WS_SYSMENU          0x00080000L     WIN32\@SYSMENU="YES"
    PROPERTY( BOOL, SysMenu );
//  WS_THICKFRAME       0x00040000L     WIN32\@THICKFRAME="YES"   implied from RESIZE="AUTOMATIC"
    PROPERTY( BOOL, ThickFrame );
//  WS_GROUP            0x00020000L     WIN32\@GROUP
    PROPERTY( BOOL, Group );
//  WS_TABSTOP          0x00010000L     WIN32\@TABSTOP="YES/NO"
    PROPERTY( BOOL, TabStop );

// ------------------------------ WS_EX stuff. -----------------------------
//  WS_EX_DLGMODALFRAME     0x00000001L WIN32\@MODALFRAME="YES"
    PROPERTY( BOOL, ModalFrame );
//  WS_EX_NOPARENTNOTIFY    0x00000004L WIN32\@NOPARENTNOTIFY="NO"
    PROPERTY( BOOL, NoParentNotify );
//  WS_EX_TOPMOST           0x00000008L WIN32\@TOPMOST="YES" (not quite CSS??)
    PROPERTY( BOOL, TopMost );

//  WS_EX_ACCEPTFILES       0x00000010L WIN32\@DROPTARGET="YES"
    PROPERTY( BOOL, DropTarget );
//  WS_EX_TRANSPARENT       0x00000020L WIN32\@TRANSPARENT
    PROPERTY( BOOL, Transparent );
//  WS_EX_MDICHILD          0x00000040L WIN32\@MDICHILD="YES"
    PROPERTY( BOOL, MDI );
//  WS_EX_TOOLWINDOW        0x00000080L WIN32\@TOOLWINDOW="YES"
    PROPERTY( BOOL, ToolWindow );

//  WS_EX_WINDOWEDGE        0x00000100L WIN32\@WINDOWEDGE
    PROPERTY( BOOL, WindowEdge );
//  WS_EX_CLIENTEDGE        0x00000200L WIN32\@CLIENTEDGE (not quite CSS)
    PROPERTY( BOOL, ClientEdge );
//  WS_EX_CONTEXTHELP       0x00000400L WIN32\@ContextHelp="YES" (implied by having HELP?)
    PROPERTY( BOOL, ContextHelp );
//  WS_EX_RIGHT             0x00001000L WIN32\@RIGHT
    PROPERTY( BOOL, Right );
//  WS_EX_RTLREADING        0x00002000L WIN32\@RTLREADING
    PROPERTY( BOOL, RTLReading );
//  WS_EX_LEFTSCROLLBAR     0x00004000L WIN32\@LEFTSCROLLBAR
    PROPERTY( BOOL, LeftScrollbar );

//  WS_EX_CONTROLPARENT     0x00010000L WIN32\@CONTROLPARENT="YES"
    PROPERTY( BOOL, ControlParent );
//  WS_EX_STATICEDGE        0x00020000L WIN32\@STATICEDGE
    PROPERTY( BOOL, StaticEdge );
//  WS_EX_APPWINDOW         0x00040000L WIN32\@APPWINDOW
    PROPERTY( BOOL, AppWindow );

	LPCTSTR	GetClass() { Init(); return m_Class; }

private:
	void    Init();

	LPCTSTR		m_Class;

    union
    {
        DWORD               m_Style;
        union
        {
            WORD            m_wWindowStyle;
            union
            {
                // WORD        m_wCtrlStyle;
                struct
                {
                    int     m_wCtrlStyle:16;

                    BOOL    m_TabStop:1;      // 1
                    BOOL    m_Group:1;        // 2
                    BOOL    m_ThickFrame:1;   // 4
                    BOOL    m_SysMenu:1;      // 8

                    BOOL    m_HScroll:1;      // 1
                    BOOL    m_VScroll:1;      // 2
                    BOOL    m_DlgFrame:1;     // 4
                    BOOL    m_Border:1;       // 8

                    BOOL    m_unknown1:1;     // 1
                    BOOL    m_ClipChildren:1; // 2
                    BOOL    m_ClipSiblings:1; // 4
                    BOOL    m_Disabled:1;     // 8

                    BOOL    m_Visible:1;      // 1
                    BOOL    m_MaximizeButton:1; // 2
                    BOOL    m_Child:1;        // 4
                    BOOL    m_Popup:1;        // 8
                };
            };
        };
    };


    // --- EX stuff ---
    union
    {
        DWORD               m_StyleEx;
        union
        {
            struct
            {
                    BOOL    m_ModalFrame:1;      // 1
                    BOOL    m_Bit1:1;               // 2
                    BOOL    m_NoParentNotify:1;  // 4
                    BOOL    m_TopMost:1;         // 8

                    BOOL    m_DropTarget:1;      // 1
                    BOOL    m_Transparent:1;     // 2
                    BOOL    m_MDI:1;             // 4
                    BOOL    m_ToolWindow:1;      // 8

                    BOOL    m_WindowEdge:1;      // 1
                    BOOL    m_ClientEdge:1;      // 2
                    BOOL    m_ContextHelp:1;     // 4
                    BOOL    m_Bit11:1;              // 8

                    BOOL    m_Right:1;           // 1
                    BOOL    m_RTLReading:1;      // 2
                    BOOL    m_LeftScrollbar:1;   // 4
                    BOOL    m_Bit15:1;             // 8

                    BOOL    m_ControlParent:1;   // 1
                    BOOL    m_StaticEdge:1;      // 2
                    BOOL    m_AppWindow:1;       // 4
                    BOOL    m_Bit19:1;             // 8

                    BOOL    m_Bit20:1;           // 1
                    BOOL    m_Bit21:1;           // 2
                    BOOL    m_Bit22:1;           // 4
                    BOOL    m_Bit23:1;           // 8

                    BOOL    m_Bit24:1;           // 1
                    BOOL    m_Bit25:1;           // 2
                    BOOL    m_Bit26:1;           // 4
                    BOOL    m_Bit27:1;           // 8

                    BOOL    m_Bit28:1;           // 1
                    BOOL    m_Bit29:1;           // 2
                    BOOL    m_Bit30:1;           // 4
                    BOOL    m_Bit31:1;           // 8

            };
        };
    };
};

#endif // !defined(AFX_XMLWIN32_H__5D544D33_2C2B_4CB1_AC6B_7E6A5BF8D3DF__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcml\xmlstyle.cpp ===
// XMLStyle.cpp: implementation of the CXMLStyle class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "XMLStyle.h"
#include "utils.h"

/*
 *	our list 0xRGB, COLORREF 0xBGR, so apply this macro
 */
#define ADJUSTCOLORREF(cr) ((cr & 0xff00) | ( (cr&0xff)<<16) | ( (cr&0xff0000) >> 16)) 

COLOR_MAP ColorMapArray[] = 
{ // http://mscominternal/workshop/design/color/X11_Names.asp
	{ TEXT("AliceBlue")         	, ADJUSTCOLORREF(0x00F0F8FF) },
	{ TEXT("AntiqueWhite")      	, ADJUSTCOLORREF(0x00FAEBD7) }, 
	{ TEXT("Aqua")              	, ADJUSTCOLORREF(0x0000FFFF) }, 
	{ TEXT("Aquamarine")        	, ADJUSTCOLORREF(0x007FFFD4) }, 
	{ TEXT("Azure")             	, ADJUSTCOLORREF(0x00F0FFFF) }, 
	{ TEXT("Beige")             	, ADJUSTCOLORREF(0x00F5F5DC) }, 
	{ TEXT("Bisque")            	, ADJUSTCOLORREF(0x00FFE4C4) }, 
	{ TEXT("Black")             	, ADJUSTCOLORREF(0x00000000) }, 
	{ TEXT("BlanchedAlmond")    	, ADJUSTCOLORREF(0x00FFEBCD) }, 
	{ TEXT("Blue")              	, ADJUSTCOLORREF(0x000000FF) }, 
	{ TEXT("BlueViolet")        	, ADJUSTCOLORREF(0x008A2BE2) }, 
	{ TEXT("Brown")             	, ADJUSTCOLORREF(0x00A52A2A) }, 
	{ TEXT("BurlyWood")         	, ADJUSTCOLORREF(0x00DEB887) }, 
	{ TEXT("CadetBlue")         	, ADJUSTCOLORREF(0x005F9EA0) }, 
	{ TEXT("Chartreuse")        	, ADJUSTCOLORREF(0x007FFF00) }, 
	{ TEXT("Chocolate")         	, ADJUSTCOLORREF(0x00D2691E) }, 
	{ TEXT("Coral")             	, ADJUSTCOLORREF(0x00FF7F50) }, 
	{ TEXT("CornflowerBlue")    	, ADJUSTCOLORREF(0x006495ED) }, 
	{ TEXT("Cornsilk")          	, ADJUSTCOLORREF(0x00FFF8DC) }, 
	{ TEXT("Crimson")           	, ADJUSTCOLORREF(0x00DC143C) }, 
	{ TEXT("Cyan")              	, ADJUSTCOLORREF(0x0000FFFF) }, 
	{ TEXT("DarkBlue")          	, ADJUSTCOLORREF(0x0000008B) }, 
	{ TEXT("DarkCyan")          	, ADJUSTCOLORREF(0x00008B8B) }, 
	{ TEXT("DarkGoldenrod")     	, ADJUSTCOLORREF(0x00B8860B) }, 
	{ TEXT("DarkGray")          	, ADJUSTCOLORREF(0x00A9A9A9) }, 
	{ TEXT("DarkGreen")         	, ADJUSTCOLORREF(0x00006400) }, 
	{ TEXT("DarkKhaki")         	, ADJUSTCOLORREF(0x00BDB76B) }, 
	{ TEXT("DarkMagenta")       	, ADJUSTCOLORREF(0x008B008B) }, 
	{ TEXT("DarkOliveGreen")    	, ADJUSTCOLORREF(0x00556B2F) }, 
	{ TEXT("DarkOrange")        	, ADJUSTCOLORREF(0x00FF8C00) }, 
	{ TEXT("DarkOrchid")        	, ADJUSTCOLORREF(0x009932CC) }, 
	{ TEXT("DarkRed")           	, ADJUSTCOLORREF(0x008B0000) }, 
	{ TEXT("DarkSalmon")        	, ADJUSTCOLORREF(0x00E9967A) }, 
	{ TEXT("DarkSeaGreen")      	, ADJUSTCOLORREF(0x008FBC8F) }, 
	{ TEXT("DarkSlateBlue")     	, ADJUSTCOLORREF(0x00483D8B) }, 
	{ TEXT("DarkSlateGray")     	, ADJUSTCOLORREF(0x002F4F4F) }, 
	{ TEXT("DarkTurquoise")     	, ADJUSTCOLORREF(0x0000CED1) }, 
	{ TEXT("DarkViolet")        	, ADJUSTCOLORREF(0x009400D3) }, 
	{ TEXT("DeepPink")          	, ADJUSTCOLORREF(0x00FF1493) }, 
	{ TEXT("DeepSkyBlue")       	, ADJUSTCOLORREF(0x0000BFFF) }, 
	{ TEXT("DimGray")           	, ADJUSTCOLORREF(0x00696969) }, 
	{ TEXT("DodgerBlue")        	, ADJUSTCOLORREF(0x001E90FF) }, 
	{ TEXT("FireBrick")         	, ADJUSTCOLORREF(0x00B22222) }, 
	{ TEXT("FloralWhite")       	, ADJUSTCOLORREF(0x00FFFAF0) }, 
	{ TEXT("ForestGreen")       	, ADJUSTCOLORREF(0x00228B22) }, 
	{ TEXT("Fuchsia")           	, ADJUSTCOLORREF(0x00FF00FF) }, 
	{ TEXT("Gainsboro")         	, ADJUSTCOLORREF(0x00DCDCDC) }, 
	{ TEXT("GhostWhite")        	, ADJUSTCOLORREF(0x00F8F8FF) }, 
	{ TEXT("Gold")              	, ADJUSTCOLORREF(0x00FFD700) }, 
	{ TEXT("Goldenrod")         	, ADJUSTCOLORREF(0x00DAA520) }, 
	{ TEXT("Gray")              	, ADJUSTCOLORREF(0x00808080) }, 
	{ TEXT("Green")             	, ADJUSTCOLORREF(0x00008000) }, 
	{ TEXT("GreenYellow")       	, ADJUSTCOLORREF(0x00ADFF2F) }, 
	{ TEXT("Honeydew")          	, ADJUSTCOLORREF(0x00F0FFF0) }, 
	{ TEXT("HotPink")           	, ADJUSTCOLORREF(0x00FF69B4) }, 
	{ TEXT("IndianRed")         	, ADJUSTCOLORREF(0x00CD5C5C) }, 
	{ TEXT("Indigo")            	, ADJUSTCOLORREF(0x004B0082) }, 
	{ TEXT("Ivory")             	, ADJUSTCOLORREF(0x00FFFFF0) }, 
	{ TEXT("Khaki")             	, ADJUSTCOLORREF(0x00F0E68C) }, 
	{ TEXT("Lavender")          	, ADJUSTCOLORREF(0x00E6E6FA) }, 
	{ TEXT("LavenderBlush")     	, ADJUSTCOLORREF(0x00FFF0F5) }, 
	{ TEXT("LawnGreen")         	, ADJUSTCOLORREF(0x007CFC00) }, 
	{ TEXT("LemonChiffon")      	, ADJUSTCOLORREF(0x00FFFACD) }, 
	{ TEXT("LightBlue")         	, ADJUSTCOLORREF(0x00ADD8E6) }, 
	{ TEXT("LightCoral")        	, ADJUSTCOLORREF(0x00F08080) }, 
	{ TEXT("LightCyan")         	, ADJUSTCOLORREF(0x00E0FFFF) }, 
	{ TEXT("LightGoldenrodYellow")	, ADJUSTCOLORREF(0x00FAFAD2) }, 
	{ TEXT("LightGreen")        	, ADJUSTCOLORREF(0x0090EE90) }, 
	{ TEXT("LightGrey")         	, ADJUSTCOLORREF(0x00D3D3D3) }, 
	{ TEXT("LightPink")         	, ADJUSTCOLORREF(0x00FFB6C1) }, 
	{ TEXT("LightSalmon")       	, ADJUSTCOLORREF(0x00FFA07A) }, 
	{ TEXT("LightSeaGreen")     	, ADJUSTCOLORREF(0x0020B2AA) }, 
	{ TEXT("LightSkyBlue")      	, ADJUSTCOLORREF(0x0087CEFA) }, 
	{ TEXT("LightSlateGray")    	, ADJUSTCOLORREF(0x00778899) }, 
	{ TEXT("LightSteelBlue")    	, ADJUSTCOLORREF(0x00B0C4DE) }, 
	{ TEXT("LightYellow")       	, ADJUSTCOLORREF(0x00FFFFE0) }, 
	{ TEXT("Lime")              	, ADJUSTCOLORREF(0x0000FF00) }, 
	{ TEXT("LimeGreen")         	, ADJUSTCOLORREF(0x0032CD32) }, 
	{ TEXT("Linen")             	, ADJUSTCOLORREF(0x00FAF0E6) }, 
	{ TEXT("Magenta")           	, ADJUSTCOLORREF(0x00FF00FF) }, 
	{ TEXT("Maroon")            	, ADJUSTCOLORREF(0x00800000) }, 
	{ TEXT("MediumAquamarine")  	, ADJUSTCOLORREF(0x0066CDAA) }, 
	{ TEXT("MediumBlue")        	, ADJUSTCOLORREF(0x000000CD) }, 
	{ TEXT("MediumOrchid")      	, ADJUSTCOLORREF(0x00BA55D3) }, 
	{ TEXT("MediumPurple")      	, ADJUSTCOLORREF(0x009370DB) }, 
	{ TEXT("MediumSeaGreen")    	, ADJUSTCOLORREF(0x003CB371) }, 
	{ TEXT("MediumSlateBlue")   	, ADJUSTCOLORREF(0x007B68EE) }, 
	{ TEXT("MediumSpringGreen") 	, ADJUSTCOLORREF(0x0000FA9A) }, 
	{ TEXT("MediumTurquoise")   	, ADJUSTCOLORREF(0x0048D1CC) }, 
	{ TEXT("MediumVioletRed")   	, ADJUSTCOLORREF(0x00C71585) }, 
	{ TEXT("MidnightBlue")      	, ADJUSTCOLORREF(0x00191970) }, 
	{ TEXT("MintCream")         	, ADJUSTCOLORREF(0x00F5FFFA) }, 
	{ TEXT("MistyRose")         	, ADJUSTCOLORREF(0x00FFE4E1) }, 
	{ TEXT("Moccasin")          	, ADJUSTCOLORREF(0x00FFE4B5) }, 
	{ TEXT("NavajoWhite")       	, ADJUSTCOLORREF(0x00FFDEAD) }, 
	{ TEXT("Navy")              	, ADJUSTCOLORREF(0x00000080) }, 
	{ TEXT("OldLace")           	, ADJUSTCOLORREF(0x00FDF5E6) }, 
	{ TEXT("Olive")             	, ADJUSTCOLORREF(0x00808000) }, 
	{ TEXT("OliveDrab")         	, ADJUSTCOLORREF(0x006B8E23) }, 
	{ TEXT("Orange")            	, ADJUSTCOLORREF(0x00FFA500) }, 
	{ TEXT("OrangeRed")         	, ADJUSTCOLORREF(0x00FF4500) }, 
	{ TEXT("Orchid")            	, ADJUSTCOLORREF(0x00DA70D6) }, 
	{ TEXT("PaleGoldenrod")     	, ADJUSTCOLORREF(0x00EEE8AA) }, 
	{ TEXT("PaleGreen")         	, ADJUSTCOLORREF(0x0098FB98) }, 
	{ TEXT("PaleTurquoise")     	, ADJUSTCOLORREF(0x00AFEEEE) }, 
	{ TEXT("PaleVioletRed")     	, ADJUSTCOLORREF(0x00DB7093) }, 
	{ TEXT("PapayaWhip")        	, ADJUSTCOLORREF(0x00FFEFD5) }, 
	{ TEXT("PeachPuff")         	, ADJUSTCOLORREF(0x00FFDAB9) }, 
	{ TEXT("Peru")              	, ADJUSTCOLORREF(0x00CD853F) }, 
	{ TEXT("Pink")              	, ADJUSTCOLORREF(0x00FFC0CB) }, 
	{ TEXT("Plum")              	, ADJUSTCOLORREF(0x00DDA0DD) }, 
	{ TEXT("PowderBlue")        	, ADJUSTCOLORREF(0x00B0E0E6) }, 
	{ TEXT("Purple")            	, ADJUSTCOLORREF(0x00800080) }, 
	{ TEXT("Red")               	, ADJUSTCOLORREF(0x00FF0000) }, 
	{ TEXT("RosyBrown")         	, ADJUSTCOLORREF(0x00BC8F8F) }, 
	{ TEXT("RoyalBlue")         	, ADJUSTCOLORREF(0x004169E1) }, 
	{ TEXT("SaddleBrown")       	, ADJUSTCOLORREF(0x008B4513) }, 
	{ TEXT("Salmon")            	, ADJUSTCOLORREF(0x00FA8072) }, 
	{ TEXT("SandyBrown")        	, ADJUSTCOLORREF(0x00F4A460) }, 
	{ TEXT("SeaGreen")          	, ADJUSTCOLORREF(0x002E8B57) }, 
	{ TEXT("Seashell")          	, ADJUSTCOLORREF(0x00FFF5EE) }, 
	{ TEXT("Sienna")            	, ADJUSTCOLORREF(0x00A0522D) }, 
	{ TEXT("Silver")            	, ADJUSTCOLORREF(0x00C0C0C0) }, 
	{ TEXT("SkyBlue")           	, ADJUSTCOLORREF(0x0087CEEB) }, 
	{ TEXT("SlateBlue")         	, ADJUSTCOLORREF(0x006A5ACD) }, 
	{ TEXT("SlateGray")         	, ADJUSTCOLORREF(0x00708090) }, 
	{ TEXT("Snow")              	, ADJUSTCOLORREF(0x00FFFAFA) }, 
	{ TEXT("SpringGreen")       	, ADJUSTCOLORREF(0x0000FF7F) }, 
	{ TEXT("SteelBlue")         	, ADJUSTCOLORREF(0x004682B4) }, 
	{ TEXT("Tan")               	, ADJUSTCOLORREF(0x00D2B48C) }, 
	{ TEXT("Teal")              	, ADJUSTCOLORREF(0x00008080) }, 
	{ TEXT("Thistle")           	, ADJUSTCOLORREF(0x00D8BFD8) }, 
	{ TEXT("Tomato")            	, ADJUSTCOLORREF(0x00FF6347) }, 
	{ TEXT("Turquoise")         	, ADJUSTCOLORREF(0x0040E0D0) }, 
	{ TEXT("Violet")            	, ADJUSTCOLORREF(0x00EE82EE) }, 
	{ TEXT("Wheat")             	, ADJUSTCOLORREF(0x00F5DEB3) }, 
	{ TEXT("White")             	, ADJUSTCOLORREF(0x00FFFFFF) }, 
	{ TEXT("WhiteSmoke")        	, ADJUSTCOLORREF(0x00F5F5F5) }, 
	{ TEXT("Yellow")            	, ADJUSTCOLORREF(0x00FFFF00) }, 
	{ TEXT("YellowGreen")       	, ADJUSTCOLORREF(0x009ACD32) }
};

static unsigned Increase ( unsigned x )
{
    x = x * 5 / 3;

    return x > 255 ? 255 : x;
}

static unsigned Decrease ( unsigned x )
{
    return x * 3 / 5;
}

static COLORREF LightenColor ( COLORREF cr )
{
    return
        (Increase( (cr & 0x000000FF) >>  0 ) <<  0) |
        (Increase( (cr & 0x0000FF00) >>  8 ) <<  8) |
        (Increase( (cr & 0x00FF0000) >> 16 ) << 16);
}

static COLORREF DarkenColor ( COLORREF cr )
{
    return
        (Decrease( (cr & 0x000000FF) >>  0 ) <<  0) |
        (Decrease( (cr & 0x0000FF00) >>  8 ) <<  8) |
        (Decrease( (cr & 0x00FF0000) >> 16 ) << 16);
}

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

//
// CSS Styles
//
//
// XMLStyle goo,
//
CXMLStyle::CXMLStyle()
{
	m_bInit=FALSE;
	NODETYPE = NT_STYLE;
    m_StringType = L"STYLE";
	m_hPen=NULL;
	m_hBrush=NULL;
    m_pDialogStyle=NULL;
    m_hFont=NULL;
    m_Display=TRUE;
    m_Visible=TRUE;
    m_ClipHoriz=FALSE;
    m_ClipVert=FALSE;
}

CXMLStyle::~CXMLStyle()
{
	if(m_hPen)
		DeleteObject(m_hPen);
	if(m_hBrush)
		DeleteObject(m_hBrush);
	if(m_pDialogStyle)
        m_pDialogStyle->Release();	// parent style object.

}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//
// FILL and CLIPPED properties 'inherit'.
//
void CXMLStyle::Init()
{
	if(m_bInit)
		return;
    BASECLASS::Init();

	InitFontInfo();
	InitColors();
	InitBorderInfo();

    m_GrowsWide=FALSE;
    m_GrowsHigh=FALSE;

    m_ClipHoriz=FALSE;
    m_ClipVert=FALSE;

	IRCMLCSS * pDlgStyle ;
	if( SUCCEEDED( get_DialogStyle( &pDlgStyle )))
    {
	    if( pDlgStyle && (pDlgStyle!=this) )
	    {
            // we initially just take whatever the FORM has setup.
            BOOL bRet;
            pDlgStyle->get_GrowsWide( &bRet ); m_GrowsWide = bRet;
            pDlgStyle->get_GrowsTall( &bRet); m_GrowsHigh= bRet;

            pDlgStyle->get_ClipVert( &bRet); m_ClipVert= bRet;
            pDlgStyle->get_ClipHoriz( &bRet); m_ClipHoriz= bRet;
	    }
    }

    //
    // FILL style stuff.
    //
   	LPCTSTR req=Get(TEXT("FILL"));
    if(req)
    {
        if( lstrcmpi(req,TEXT("BOTH"))==0 )
        {
            m_GrowsHigh=TRUE;
            m_GrowsWide=TRUE;
        }
        else if ( lstrcmpi(req,TEXT("WIDER"))==0 )
        {
            m_GrowsHigh=FALSE;
            m_GrowsWide=TRUE;
        } else if ( lstrcmpi(req,TEXT("TALLER"))==0 )
        {
            m_GrowsHigh=TRUE;
            m_GrowsWide=FALSE;
        }
    }

    // @CLIPPED
    if( req=Get(TEXT("CLIPPED")) )
    {
        if( lstrcmpi(req,TEXT("BOTH"))==0 )
        {
            m_ClipVert=TRUE;
            m_ClipHoriz=TRUE;
        }
        else if ( lstrcmpi(req,TEXT("WIDER"))==0 )
        {
            m_ClipVert=FALSE;
            m_ClipHoriz=TRUE;
        } else if ( lstrcmpi(req,TEXT("TALLER"))==0 )
        {
            m_ClipVert=TRUE;
            m_ClipHoriz=FALSE;
        }
    }

    m_Display=YesNo( TEXT("DISPLAY"), TRUE, FALSE, TRUE );
    if( req=Get(TEXT("VISIBILITY")))
    {
        if(lstrcmpi(req,TEXT("VISIBLE"))==0 )
            m_Visible=TRUE;
        else
            m_Visible=FALSE;
    }

	m_bInit=TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////////
//
// Font information
//
////////////////////////////////////////////////////////////////////////////////////////////////
void CXMLStyle::InitFontInfo()
{
	LPCTSTR req=NULL;

	m_Font=Get(TEXT("FONT"));
	//
	// Now crack the FONT string into it's FAMILY SIZE STYLE and WEIGHT
	//

	//
	// Now, if they also speicifed FAMIL SIZE STYLE and WEIGHT take those.
	//
	m_fontFamily = Get(TEXT("FONT-FAMILY"));
	m_fontSize=Get(TEXT("FONT-SIZE"));
	m_fontStyle=Get(TEXT("FONT-STYLE"));
	m_fontWeight=Get(TEXT("FONT-WEIGHT"));

	//
	// Get the 'systems' logfont for dialogs?? INHERITANCE of fonts.
	// is there a different logfont per control? I think they may be! 8-(
	//
	IRCMLCSS * pDlgStyle ;
	LOGFONT	lf={0};
    if( SUCCEEDED( get_DialogStyle( &pDlgStyle )))
    {
	    if( pDlgStyle && (pDlgStyle!=this) )
	    {
            HFONT hf;
            if( SUCCEEDED( pDlgStyle->get_Font( &hf ) ))
                GetObject( hf, sizeof(lf), &lf );
	    }
    }

	//
	// Now we have FAMILY SIZE STYLE and WEIGHT, Init the QuickFont
	//
	DWORD	dwSize=0;
	if( m_fontSize )
	{
		LONG dwParentSize=lf.lfHeight;
		if( lstrcmpi( m_fontSize, TEXT("bigger")) == 0 )
		{
			lf.lfHeight=(LONG)(lf.lfHeight*1.2);	// made up scale
		}
		else
		if( lstrcmpi( m_fontSize, TEXT("smaller")) == 0 )
		{
			lf.lfHeight=(LONG)(lf.lfHeight/1.2);	// made up scale
		}
		else
			dwSize=m_fontSize?_ttoi( m_fontSize ):0;
	}

	//
	// Style
	//
	DWORD	dwStyle=0;
	if(m_fontStyle)
		dwStyle|=lstrcmpi(m_fontStyle, TEXT("ITALIC") )==0?CQuickFont::FS_ITALIC:0;

	//
	// Weight
	//
	DWORD	dwWeight;
	if( (m_fontWeight==NULL) || (*m_fontWeight==TEXT('\0')) )
	{
		dwWeight=FW_NORMAL;
	}
	else
	{
		if( lstrcmpi(m_fontWeight, TEXT("BOLD") ) == 0 )
			dwWeight= FW_BOLD;
		else
			dwWeight =_ttoi( m_fontWeight );
	}

	if( pDlgStyle==this )
		m_QuickFont.Init( m_fontFamily, dwSize, dwStyle, dwWeight );	// no base LOGFONT for the dialog
	else
		m_QuickFont.Init( m_fontFamily, dwSize, dwStyle, dwWeight, &lf );
    m_hFont = m_QuickFont.GetFont();
}

////////////////////////////////////////////////////////////////////////////////////////////////
//
// Border information
//
////////////////////////////////////////////////////////////////////////////////////////////////
void CXMLStyle::InitBorderInfo()
{
	LPCTSTR req;
	int width, style;
	COLORREF	cref;
	BORDER_STYLE_MAP* pBorderStyleMap;

	//
	// Get the border information
	//
	req = Get(TEXT("BORDER-STYLE"));
	if(req == NULL)
		return;
	GetStringIndex(BorderStyleMapArray, pszBorderStyle, req , pBorderStyleMap);

	if(pBorderStyleMap !=NULL)
	{
		style = pBorderStyleMap->style;

		req = Get(TEXT("BORDER-WIDTH"));		
		width = req ? _ttoi(req) : 1;
	
		req = Get(TEXT("BORDER-COLOR"));		
		if(req == NULL || !StringToCOLORREF(req, &cref))
		{
			/*
			 * If no border color or a bogus one, use this default
			 */
			cref = GetSysColor(COLOR_BTNTEXT); // 0xffffff;	// white - is this a good default? BUGBUG
		}
        m_Border.SetColor(cref);
        m_Border.SetStyle(style);
        m_Border.SetWidth(width);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////
//
// Color information
//
////////////////////////////////////////////////////////////////////////////////////////////////

void CXMLStyle::InitColors()
{
	LPCTSTR req=NULL;

	m_Background=Get(TEXT("BACKGROUND"));
	//
	// Now crack BACKGROUND into COLOR / IMAGE
	//

	//
	// COLOR
	//
    IRCMLCSS * pDlgStyle;
    get_DialogStyle( &pDlgStyle );

	req=Get(TEXT("COLOR"));
	if( req==NULL || !StringToCOLORREF(req, &m_crefColor))
	{
	    if( pDlgStyle && (pDlgStyle!=this) )
        {
		    pDlgStyle->get_Color(&m_crefColor); 
       		pDlgStyle->get_Pen( (ULONG*)&m_hPen);   // this should be a duplicate BUGBUG
        }
        else
        {
		    m_crefColor	=-1;
		    m_hPen		= NULL;
        }
	}
	else
	{
		m_hPen		= CreatePen( PS_SOLID, 0, m_crefColor );
	}
	
	//
	// Background Color
	//
	req=Get(TEXT("BACKGROUND-COLOR"));
	if( req==NULL || !StringToCOLORREF(req, &m_crefBackgroundColor))
	{
	    if( pDlgStyle && (pDlgStyle!=this) )
        {
		    pDlgStyle->get_BkColor(&m_crefBackgroundColor);
		    pDlgStyle->get_Brush(&m_hBrush); // this should be a duplicate BUGBUG
        }
        else
        {
		    m_crefBackgroundColor=-1;
		    m_hBrush	= NULL;
        }
	}
	else
	{
		m_hBrush	= CreateSolidBrush( m_crefBackgroundColor );
	}
}


#ifdef _OLD_STYLESCODE

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// CXMLStyles
//

CXMLStyles::CXMLStyles()
{
}

CXMLStyles::~CXMLStyles()
{
}

CXMLStyle * CXMLStyles::FindStyle(LPCTSTR ID)
{
	int k=GetCount();
	CXMLStyle * pStyle=NULL;
	for(int i=0;i<k;i++)
	while(i)
	{
		pStyle=GetPointer(i);
		LPCTSTR pszID=pStyle->GetStyleName();
		if(pszID)
		{
			if( lstrcmpi(ID, pszID ) == 0 )
				return pStyle;
		}
	}
	return NULL;
}

#endif

void CXMLStyle::CBorder::DrawBorder(HDC hdc, LPRECT pInnerRect)
{
	/*
	 * Consider creating a cache for brushes used in dialogs
	 */
	if(m_Style!=HIDDEN)
	{
		/*
		 * normal and ridge for now
		 */
		switch(m_Style)
		{
		case SOLID:
			{
				HBRUSH hb = CreateSolidBrush(m_Color);
				FillRect(hdc, pInnerRect, hb);
				DeleteObject(hb);
			}
			break;

		case RIDGE:
			{
				HBRUSH hb1 = CreateSolidBrush(m_Color);
				/*
				 * Create a darker brush and hide the pen
				 */
				HBRUSH hbDarker = CreateSolidBrush(DarkenColor(m_Color));
				HPEN hPen = CreatePen(PS_NULL, 0, 0);
				HPEN hPenSave = (HPEN)SelectObject(hdc, hPen);


				RECT rMid = *pInnerRect;
				RECT rMin = *pInnerRect;
				rMid.left		+= m_Width/2;
				rMid.top		+= m_Width/2;
				rMid.bottom		-= m_Width/2;
				rMid.right		-= m_Width/2;

				rMin.left		+= m_Width;
				rMin.top		+= m_Width;
				rMin.bottom		-= m_Width;
				rMin.right		-= m_Width;

				/*
				 * draw them from left top to right bottom
				 */

				POINT	p[6], *pPoints = p;

				p[0].x = pInnerRect->left;
				p[0].y = pInnerRect->top;

				p[1].x = pInnerRect->left;
				p[1].y = pInnerRect->bottom;

				p[2].x = rMid.left;
				p[2].y = rMid.bottom;

				p[3].x = rMid.left;
				p[3].y = rMid.top;

				p[4].x = rMid.right;
				p[4].y = rMid.top;

				p[5].x = pInnerRect->right;
				p[5].y = pInnerRect->top;

				HBRUSH hbrSave = (HBRUSH)SelectObject(hdc, hb1);				
				Polygon(hdc, pPoints, 6);

				p[0].x = rMin.left;
				p[0].y = rMin.top;

				p[1].x = rMin.left;
				p[1].y = rMin.bottom;

				p[5].x = rMin.right;
				p[5].y = rMin.top;
				
				SelectObject(hdc, hbDarker);
				Polygon(hdc, pPoints, 6);

				p[0].x = rMin.right;
				p[0].y = rMin.bottom;

				p[3].x = rMid.right;
				p[3].y = rMid.bottom;

				SelectObject(hdc, hb1);
				Polygon(hdc, pPoints, 6);

				p[0].x = pInnerRect->right;
				p[0].y = pInnerRect->bottom;

				p[1].x = pInnerRect->left;
				p[1].y = pInnerRect->bottom;

				p[5].x = pInnerRect->right;
				p[5].y = pInnerRect->top;
				
				SelectObject(hdc, hbDarker);
				Polygon(hdc, pPoints, 6);

				SelectObject(hdc, hbrSave);
				SelectObject(hdc, hPenSave);

				DeleteObject(hb1);
				DeleteObject(hbDarker);
				DeleteObject(hPenSave);
			}
			break;
		}
	}
	pInnerRect->left	+= m_Width;
	pInnerRect->top		+= m_Width;
	pInnerRect->bottom	-= m_Width;
	pInnerRect->right	-= m_Width;
}

//////////////////////////////////////////////////////////////////////
// Helper functions
//////////////////////////////////////////////////////////////////////
LPCTSTR ParseDecValue(LPCTSTR p, int* pResult, TCHAR delimiter)
{
	*pResult = 0;
	while(*p)
	{
		if(*p == delimiter)
			return p+1;
		else if(*p>=__T('0') && *p<=__T('9'))
			*pResult = *pResult*10 + *p - __T('0');
		else if(*p != __T(' ') && *p != __T('\t'))
			return NULL;
		p++;
	}
	return NULL;
}

BOOL StringToCOLORREF(LPCTSTR string, COLORREF* pColorRef)
{
	BOOL retval = FALSE;
	PCOLOR_MAP pColorMap;
	GetStringIndex(ColorMapArray, pszColorName, string, pColorMap);

	if (pColorMap  == NULL)
	{
		//
		// This might be a "#RRGGBB" value
		//
		if(*string == __T('#'))
		{
			int hexValue = ReadHexValue(string+1);
			*pColorRef = ADJUSTCOLORREF(hexValue);
			return TRUE;
		}
		else 
		//
		// This might be a "RGB(r, g, b)" value
		//
		if(lstrlen(string) >= 10)
		{
			if(*(string+3) != __T('('))
				goto errExit;
			*((LPTSTR)string+3) = 0;
			BOOL bnotOK = lstrcmpi(string, TEXT("RGB") ) != 0;
			*((LPTSTR)string+3) = __T('(');
			if(bnotOK)
				goto errExit;

			LPCTSTR p = string+4;
			int i=0;
			int R, G, B;
			p = ParseDecValue(p, &R, __T(','));
			if(p)
			{
				p = ParseDecValue(p, &G, __T(','));
				if(p)
				{
					p = ParseDecValue(p, &B, __T(')'));
					if(p)
					{
						*pColorRef = RGB(R, G, B);
						return TRUE;
					}
				}
			}
			goto errExit;
		}
		else 
		{
errExit:
			EVENTLOG( EVENTLOG_INFORMATION_TYPE, LOGCAT_LOADER | LOGCAT_CONSTRUCT, 0, 
                TEXT("Color"), TEXT("unknown color %s"), string);
			TRACE(TEXT("unknown color %s"), string);
		}
	}
	else
	{
		*pColorRef = pColorMap->cref;
		retval = TRUE; 
	}
	return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\appsvcs\appservices.cpp ===
// APPSERVICES.cpp : Defines the entry point for the DLL application.
//

#include "stdafx.h"
#define APPSERVICES_EXPORTS
#include "APPSERVICES.h"
#include "wmi.h"
#include "rcmlpersist.h"

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

    // This is the thing that we export.
    APPSERVICES_API IRCMLNode * WINAPI CreateElement( LPCWSTR pszText )
    {
        return CDWin32NameSpaceLoader::CreateElement( pszText );
    }

#ifdef __cplusplus
}            /* Assume C declarations for C++ */
#endif  /* __cplusplus */


BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    switch (ul_reason_for_call)
	{
		case DLL_PROCESS_ATTACH:
            CoInitialize(NULL);
            return TRUE;

		case DLL_PROCESS_DETACH:
            CoUninitialize();
            return TRUE;

		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
			break;
    }
    return TRUE;
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
//

#define XMLNODE(name, function) { name, CXML##function::newXML##function }

CDWin32NameSpaceLoader::XMLELEMENT_CONSTRUCTOR g_DWin32[]=
{
	XMLNODE( TEXT("PERSIST"), Persist ),

    { TEXT("WMI"), CWMI::newXMLWMI },

	//
	// End.
	//
	{ NULL, NULL} 
};

IRCMLNode * CDWin32NameSpaceLoader::CreateElement( LPCWSTR pszElement )
{
	PXMLELEMENT_CONSTRUCTOR pEC=g_DWin32;
	while( pEC->pwszElement )
	{
		if( lstrcmpi( pszElement , pEC->pwszElement) == 0 )
		{
			CLSPFN pFunc=pEC->pFunc;
            return pFunc();
		}
		pEC++;
	}
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\appsvcs\rcmlpersist.h ===
// RCMLPersist.h: interface for the RCMLPersist class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_RCMLPERSIST_H__50697F94_22C1_425A_BA70_A9EBDDC298C0__INCLUDED_)
#define AFX_RCMLPERSIST_H__50697F94_22C1_425A_BA70_A9EBDDC298C0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "appservices.h"

class CXMLPersist : public CAppServices
{
public:
    CXMLPersist() { m_StringType=L"DWIN32:PERSIST"; }
    virtual ~ CXMLPersist() {};
    static IRCMLNode * newXMLPersist() { return new CXMLPersist; }

    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InitNode( 
        IRCMLNode __RPC_FAR *parent);
    
    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExitNode( 
        IRCMLNode __RPC_FAR *parent, LONG lDialogResult);

};

#endif // !defined(AFX_RCMLPERSIST_H__50697F94_22C1_425A_BA70_A9EBDDC298C0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\appsvcs\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__E2E1B5CD_78D9_4D6B_94C2_6E9CA4579862__INCLUDED_)
#define AFX_STDAFX_H__E2E1B5CD_78D9_4D6B_94C2_6E9CA4579862__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// Insert your headers here
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__E2E1B5CD_78D9_4D6B_94C2_6E9CA4579862__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\appsvcs\unknown.h ===
// copied from ppxml sample

#ifndef _UNKNOWN2_HXX
#define _UNKNOWN2_HXX


template <class implementation, class derivedinterface>
class _simpleobj :  public implementation
{
private:    long _refcount;

public:        
        _simpleobj <implementation, derivedinterface>() 
        { 
            _refcount = 0;
        }

        virtual ~_simpleobj <implementation, derivedinterface>()
        {
        }

        virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void ** ppvObject)
        {
            if (riid == IID_IUnknown)
            {
                *ppvObject = static_cast<IUnknown*>(this);
            }
            else if (riid == __uuidof(derivedinterface))
            {
                *ppvObject = static_cast<derivedinterface*>(this);
            }
            else
            {
                *ppvObject = NULL;
                return E_NOINTERFACE;
            }
            reinterpret_cast<IUnknown*>(*ppvObject)->AddRef();
            return S_OK;
        }
    
        virtual ULONG STDMETHODCALLTYPE AddRef( void)
        {
            return InterlockedIncrement(&_refcount);
        }
    
        virtual ULONG STDMETHODCALLTYPE Release( void)
        {
            if (InterlockedDecrement(&_refcount) == 0)
            {
                delete this;
                return 0;
            }
            return _refcount;
        }
};    

//===========================================================================
// This template implements the IUnknown portion of a given COM interface.

template <class I> class _simpleunknown : public I
{
private:    long _refcount;

public:        
        _simpleunknown <I>() 
        { 
            _refcount = 0;
        }

        virtual ~_simpleunknown <I>()
        {
        }

        virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void ** ppvObject)
        {
            if (riid == IID_IUnknown)
            {
                *ppvObject = static_cast<IUnknown*>(this);
            }
            else if (riid == __uuidof(I))
            {
                *ppvObject = static_cast<I*>(this);
            }
            else
            {
                *ppvObject = NULL;
                return E_NOINTERFACE;
            }
            reinterpret_cast<IUnknown*>(*ppvObject)->AddRef();
            return S_OK;
        }
    
        virtual ULONG STDMETHODCALLTYPE AddRef( void)
        {
            return InterlockedIncrement(&_refcount);
        }
    
        virtual ULONG STDMETHODCALLTYPE Release( void)
        {
            if (InterlockedDecrement(&_refcount) == 0)
            {
                delete this;
                return 0;
            }
            return _refcount;
        }
};    

#endif _UNKNOWN2_HXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\appsvcs\utils.h ===
//
// This file will hold various helper functions
//
//	 StringToInt - converts the decimal or hex string passed in to an integer
// 
// History:
//	Created:	MCostea	May 27, 1999
// 
#ifndef __UTILSH
#define __UTILSH

#define StringToInt(psz) StringToIntDef(psz, 0 )

int StringToIntDef(LPCTSTR psz, int Default);
int ReadHexValue(LPCTSTR psz);
void CopyToWideChar( WCHAR** pstrOut, LPCTSTR strIn );
LPWSTR UnicodeStringFromAnsi(LPCSTR pszSource);
LPSTR AnsiStringFromUnicode(LPCWSTR pszSource);

#endif	// __UTILSH
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\appsvcs\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	APPSERVICES.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\appsvcs\rcmlpersist.cpp ===
// RCMLPersist.cpp: implementation of the RCMLPersist class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "RCMLPersist.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


//
// this is the persitance NODE in the DWIN32 namespace.
//
HRESULT STDMETHODCALLTYPE CXMLPersist::InitNode( 
    IRCMLNode __RPC_FAR *pParent)
{
    if( SUCCEEDED(pParent->IsType(L"EDIT") ))
    {
        LPCTSTR pszApplicationName=Get(TEXT("APPNAME"));
        LPCTSTR pszKeyName=Get(TEXT("KEYNAME"));
        BOOL bSet=FALSE;
        if( pszApplicationName && pszKeyName )
        {
            HKEY hkSoftware;
            if( RegOpenKey( HKEY_CURRENT_USER, TEXT("Software"), &hkSoftware ) == ERROR_SUCCESS )
            {
                HKEY hkApplication;
                if( RegOpenKey( hkSoftware, pszApplicationName, &hkApplication) == ERROR_SUCCESS )
                {
                    DWORD dwSize;
                    DWORD dwType=REG_SZ;
                    if( RegQueryValueEx( hkApplication, pszKeyName, NULL, &dwType, NULL, &dwSize ) == ERROR_SUCCESS )
                    {
                        LPTSTR pszData=new TCHAR[dwSize];
                        if( RegQueryValueEx( hkApplication, pszKeyName, NULL, &dwType, (LPBYTE)pszData, &dwSize ) == ERROR_SUCCESS )
                        {
                            pParent->put_Attr( L"TEXT", pszData );
                            delete pszData ;
                            bSet=TRUE;
                        }
                    }
                    RegCloseKey(hkApplication);
                }
                RegCloseKey(hkSoftware);
            }
        }
        if(bSet==FALSE)
            pParent->put_Attr(L"TEXT", Get(L"TEXT") );
    }
    return S_OK;
}

//
// this is the persitance NODE in the DWIN32 namespace.
// should only really be called if the user clicks OK, rather than cancel??
//
HRESULT STDMETHODCALLTYPE CXMLPersist::ExitNode( 
    IRCMLNode __RPC_FAR *pParent, LONG lDialogResult)
{
    if(lDialogResult != IDOK )
        return S_OK;

    if(SUCCEEDED( pParent->IsType(L"EDIT")))
    {
        LPCTSTR pszApplicationName=Get(TEXT("APPNAME"));
        LPCTSTR pszKeyName=Get(TEXT("KEYNAME"));
        if( pszApplicationName && pszKeyName )
        {
            HKEY hkSoftware;
            if( RegOpenKey( HKEY_CURRENT_USER, TEXT("Software"), &hkSoftware ) == ERROR_SUCCESS )
            {
                HKEY hkApplication;
                if( RegCreateKey( hkSoftware, pszApplicationName, &hkApplication) == ERROR_SUCCESS )
                {
                    IRCMLControl * pControl;
                    if(SUCCEEDED( pParent->QueryInterface( __uuidof( IRCMLControl ), (LPVOID*)&pControl)))
                    {
                        HWND hWnd;
                        if( SUCCEEDED( pControl->get_Window(&hWnd) ))
                        {
                            LPTSTR szString=NULL;
                            DWORD cbNeeded = GetWindowTextLength( hWnd )+1;
                            szString = new TCHAR[cbNeeded];
                            GetWindowText( hWnd, szString, cbNeeded );
                            RegSetValueEx( hkApplication, pszKeyName, NULL, REG_SZ, (LPBYTE) szString, cbNeeded*sizeof(TCHAR) );
                        }
                        pControl->Release();
                    }
                    RegCloseKey(hkApplication);
                }
                RegCloseKey(hkSoftware);
            }
        }
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\appsvcs\stringproperty.cpp ===
// StringProperty.cpp: implementation of the CStringProperty class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "StringProperty.h"
#include "utils.h"

#define TRACE 0?0:

CDictionary CStringPropertySection::m_Dictionary;

CStringPropertySection::CStringPropertySection()
{
    m_UsedItems=0;  // make this an array and re-alloc it - like the CDPA ! Gosh.
    m_ItemSize=RUN_SIZE;
    m_Items=new LINKSTRING[m_ItemSize];
}

//
// Finds the Value from the KEY, returns NULL if the KEY isn't used.
//
LPCTSTR CStringPropertySection::Get(LPCTSTR szPropID)
{
    int iEntry;
	if( Find( szPropID, &iEntry ) )
		return (LPCTSTR)m_Items[iEntry].pszValue;
	return NULL;
}

#define _MEM_DEBUG
#ifdef _MEM_DEBUG
DWORD g_KeyAlloc;
DWORD g_ValueAlloc;
#endif

//
// Associats a value (perhaps new) to a given key.
//
BOOL CStringPropertySection::Set(LPCTSTR szPropID, LPCTSTR szValue)
{
    int iEntry;
	if( Find( szPropID, &iEntry ) == FALSE )
	{
        if( m_UsedItems == m_ItemSize )
        {
            // re allocate the buffer bigger.
            m_ItemSize*=2;
            PLINKSTRING pNew=new LINKSTRING[m_ItemSize];
            CopyMemory(pNew, m_Items, sizeof(LINKSTRING) * m_UsedItems );
            delete m_Items;
            m_Items=pNew;
        }

        iEntry=m_UsedItems++;
		m_Items[iEntry].idKey=m_Dictionary.GetID( szPropID );
	}
	else
    {
		delete m_Items[iEntry].pszValue;
    }

	DWORD dwLen=lstrlen(szValue)+1;
#ifdef _MEM_DEBUG
    g_ValueAlloc+=dwLen;
#endif
	m_Items[iEntry].pszValue=new TCHAR[dwLen];
	CopyMemory( m_Items[iEntry].pszValue, szValue, dwLen*sizeof(TCHAR) );
	return TRUE;
}

//
// Finds a string in the table.
// The KEY of the thing you are finding
// An OUT pointer to the LINKSTRING structure
// which item in the LINKSTRING structure can be used.
//
BOOL CStringPropertySection::Find( LPCTSTR szPropID, int * pEntry)
{
    UINT uiPropID = m_Dictionary.GetID( szPropID ); // this is the ID for this string.
    for(UINT i=0;i<m_UsedItems;i++)
    {
        if( uiPropID == m_Items[i].idKey )
        {
            *pEntry=i;
            return TRUE;
        }
    }
    *pEntry=0;
	return FALSE;
}

CStringPropertySection::~CStringPropertySection()
{
    Purge();
    delete m_Items;
    m_Items=NULL;
}

void CStringPropertySection::Purge()
{
	for(UINT i=0;i<m_UsedItems;i++)
	{
        m_Items[i].idKey=0;
		delete m_Items[i].pszValue;
        m_Items[i].pszValue=NULL;
	}
    m_UsedItems=0;
}

//
// Looks for the existance of a property szPropID
// if present and set to YES, returns dwResult (default of TRUE).
// otherwise returns defValue
//
DWORD CStringPropertySection::YesNo(LPCTSTR szPropID, DWORD dwNotPresent, DWORD dwYes)
{
    return YesNo( szPropID, dwNotPresent, FALSE, dwYes );
}

DWORD CStringPropertySection::YesNo(LPCTSTR szPropID, DWORD dwNotPresent, DWORD dwNo, DWORD dwYes)
{
   	LPCTSTR req=(LPCTSTR)Get(szPropID);
    if( req == NULL )
        return dwNotPresent;

    if( req && lstrcmpi(req,TEXT("YES"))==0)
        return dwYes;
    return dwNo;
}

DWORD   CStringPropertySection::ValueOf(LPCTSTR szPropID, DWORD dwDefault)
{
   	LPCTSTR req=(LPCTSTR)Get(szPropID);
	// return req?_ttoi( req ):dwDefault;
    return req?StringToInt(req):dwDefault;
}



////////////////////////////////////////////////////////////////////////////////////////////////
//
// Dictionary.
// maps strings to UINTS, in a case insensitive manner.
//
////////////////////////////////////////////////////////////////////////////////////////////////

CDictionary::CDictionary()
{
	for(int i=0;i<DIC_TABLE_SIZE;i++)
		m_Table[i]=NULL;
}

UINT CDictionary::GetID(LPCTSTR szPropID)
{
    //
    // Has the string, find the bucket.
    //
	DWORD dwStrLen=lstrlen(szPropID)+1;
	DWORD hash=Hash(szPropID, dwStrLen);

    PLINKDICSTRING * pFoundPointer = &m_Table[hash];
    PLINKDICSTRING pFound=*pFoundPointer;
    int iNumber=0+1;
	while( pFound )
	{
        int used=pFound->cbUsed;
        for( int i=0;i<used;i++)
        {
            iNumber++;
		    if( lstrcmpi( pFound->pszKey[i], szPropID) == 0 )
                return pFound->ID[i];
        }

        //
        // If we have space in this run, use it up.
        //
        if( used < DIC_RUN_SIZE )
            break;

        // Next bucket
        pFoundPointer=&pFound->pNext;
        pFound=*pFoundPointer;
	}

    if( pFound == NULL )
    {
		pFound = new LINKDICSTRING;
        ZeroMemory( pFound, sizeof(LINKDICSTRING) );
        *pFoundPointer=pFound;
        TRACE(TEXT("Dic at 0x%08x\n"), pFound );
    }

    //
    // Make the ID out of the bucket we are in, and the item we're adding.
    //
    int iEntry=pFound->cbUsed++;
    pFound->ID[iEntry]=hash<<8 | iNumber;

#ifdef _MEM_DEBUG
    g_ValueAlloc+=dwStrLen;
#endif

	pFound->pszKey[iEntry]=new TCHAR[dwStrLen];
	CopyMemory( pFound->pszKey[iEntry], szPropID, dwStrLen*sizeof(TCHAR) );

    return pFound->ID[iEntry];
}

LPCTSTR CDictionary::GetString(UINT ID)
{
    int iBucket=ID >> 8;
    // for( int iBucket=0;iBucket<DIC_TABLE_SIZE;iBucket++)
    {
        PLINKDICSTRING pLinkString=m_Table[iBucket];
        int i=0;
	    while( pLinkString )
	    {
            int used=pLinkString->cbUsed;
            for( int i=0;i<used;i++)
            {
		        if( pLinkString->ID[i]  == ID )
                    return pLinkString->pszKey[i];
            }

            pLinkString=( pLinkString->pNext );
	    }
    }
	return 0;
}


//
// Case insensitive hash.
//
DWORD CDictionary::Hash( LPCTSTR szString, DWORD dwStrLen )
{
	TCHAR szChar=toupper( *szString );
	return (dwStrLen * szChar) % DIC_TABLE_SIZE;
}


CDictionary::~CDictionary()
{
    Purge();
}

void CDictionary::Purge()
{
	for(int i=0;i<DIC_TABLE_SIZE;i++)
	{
		PLINKDICSTRING pNext;
		PLINKDICSTRING pEntry = m_Table[i];
		while( pEntry )
		{
            for(int ti=0;ti<pEntry->cbUsed;ti++)
            {
                pEntry->ID[ti]=0;
			    delete pEntry->pszKey[ti];
                pEntry->pszKey[ti]=NULL;
            }
			pNext= pEntry->pNext;
			delete pEntry;
            TRACE(TEXT("Dic @ 0x%08x\n"), pEntry );
			pEntry=pNext;
		}
        m_Table[i]=NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\appsvcs\appservices.h ===
#ifndef __APPSERVICES_H
#define __APPSERVICES_H

// The following ifdef block is the standard way of creating macros which make exporting 
// from a DLL simpler. All files within this DLL are compiled with the APPSERVICES_EXPORTS
// symbol defined on the command line. this symbol should not be defined on any project
// that uses this DLL. This way any other project whose source files include this file see 
// APPSERVICES_API functions as being imported from a DLL, wheras this DLL sees symbols
// defined with this macro as being exported.
#ifdef APPSERVICES_EXPORTS
#define APPSERVICES_API __declspec(dllexport)
#else
#define APPSERVICES_API __declspec(dllimport)
#endif

#include "rcmlpub.h"

#include "stringproperty.h"
#include "unknown.h"

class CDWin32NameSpaceLoader
{
public:
    CDWin32NameSpaceLoader();

    typedef IRCMLNode * (*CLSPFN)();

    typedef struct _XMLELEMENT_CONSTRUCTOR
    {
	    LPCTSTR	pwszElement;		// the element
	    CLSPFN	pFunc;				// the function to call.
    }XMLELEMENT_CONSTRUCTOR, * PXMLELEMENT_CONSTRUCTOR;

    static IRCMLNode * CreateElement( LPCWSTR pszText );
private:
};


class CAppServices : public _simpleunknown<IRCMLNode>, public CStringPropertySection
{
public:
    CAppServices() { m_StringType=L"Uninitialized"; }
    virtual ~CAppServices() {};

         STDMETHOD(DetachParent)(IRCMLNode **pVal)
        { 
            *pVal = m_pParent;
            if( m_pParent==NULL )
                return E_FAIL;
            return S_OK;
        }

        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE AttachParent( 
            /* [in] */ IRCMLNode __RPC_FAR *newVal)
        {
            m_pParent=newVal;
            return S_OK;
        }

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptChild( 
            IRCMLNode __RPC_FAR *pChild)
        {
            LPWSTR pType;
            LPWSTR pChildType;
            get_StringType( &pType );
            pChild->get_StringType( &pChildType );

            return E_INVALIDARG;    // we don't take children.
        }
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DoEndChild( 
            IRCMLNode __RPC_FAR *child)
        {
            return S_OK;
        }
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ UINT __RPC_FAR *pVal)
        {
            *pVal = NODETYPE;
            return S_OK;
        }
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InitNode( 
            IRCMLNode __RPC_FAR *parent)
        {
            return S_OK;
        }
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DisplayNode( 
            IRCMLNode __RPC_FAR *parent)
        {
            return S_OK;
        }
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExitNode( 
            IRCMLNode __RPC_FAR *parent, LONG lDialogResult)
        {
            return S_OK;
        }
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Attr( 
            LPCWSTR index,
            /* [retval][out] */ LPWSTR __RPC_FAR *pVal)
        {
            *pVal = (LPWSTR)CStringPropertySection::Get(index);
            if( *pVal )
                return S_OK;
            return E_INVALIDARG;    // HMM, we don't have this attribute, but is it failure?
        }
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Attr( 
            LPCWSTR index,
            /* [in] */ LPCWSTR newVal)
        {
            CStringPropertySection::Set(index, newVal);
            return S_OK;
        }
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsType( 
            LPCWSTR nodeName)
        {
            if( lstrcmpi(nodeName, m_StringType) == 0 )
                return S_OK;
            return E_FAIL;  // OK, so it's not really a failure REVIEW!
        }
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE YesDefault( 
            /* [in] */ LPCWSTR propID,
            /* [in] */ DWORD dwNotPresent,
            /* [in] */ DWORD dwYes,
            /* [retval][out] */ DWORD __RPC_FAR *pdwValue)
        {
            *pdwValue = CStringPropertySection::YesNo(propID, dwNotPresent, dwYes);
            return S_OK;
        }
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE YesNoDefault( 
            /* [in] */ LPCWSTR propID,
            /* [in] */ DWORD dwNotPresent,
            /* [in] */ DWORD dwNo,
            /* [in] */ DWORD dwYes,
            /* [retval][out] */ DWORD __RPC_FAR *pdwValue)
        {
            *pdwValue = CStringPropertySection::YesNo(propID, dwNotPresent, dwNo, dwYes);
            return S_OK;
        }
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ValueOf( 
            /* [in] */ LPCWSTR propID,
            /* [in] */ DWORD dwNotPresent,
            /* [retval][out] */ DWORD __RPC_FAR *pdwValue)
        {
            *pdwValue = CStringPropertySection::ValueOf(propID, dwNotPresent);
            return S_OK;
        }

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SignedValueOf( 
            /* [in] */ LPCWSTR propID,
            /* [in] */ int dwNotPresent,
            /* [retval][out] */ int __RPC_FAR *pdwValue)
        {
            *pdwValue = CStringPropertySection::ValueOf(propID, dwNotPresent);
            return S_OK;
        }

        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_StringType( 
            /* [retval][out] */ LPWSTR __RPC_FAR *pStringType)
        {
            *pStringType = (LPWSTR)m_StringType;
            return S_OK;
        }

        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetUnknownEnum( 
            /* [retval][out] */ IEnumUnknown __RPC_FAR *__RPC_FAR *pEnum) { return E_NOTIMPL; }

        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetChildEnum( 
            /* [retval][out] */ IEnumUnknown __RPC_FAR *__RPC_FAR *pEnum) { return E_NOTIMPL; }

protected:
    int NODETYPE;
    LPWSTR  m_StringType;

private:
    IRCMLNode * m_pParent;
    CStringPropertySection m_PS;
};


APPSERVICES_API int fnAPPSERVICES(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\appsvcs\stringproperty.h ===
// StringProperty.h: interface for the CStringProperty class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_STRINGPROPERTY_H__CE442DDC_8EF3_11D2_84A3_00C04FB177B1__INCLUDED_)
#define AFX_STRINGPROPERTY_H__CE442DDC_8EF3_11D2_84A3_00C04FB177B1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// Maps an LPCTSTR to a UINT (like ATOMS).
class CDictionary
{
public:
	CDictionary();
	virtual ~CDictionary();
	UINT    GetID( LPCTSTR szPropID );
    LPCTSTR GetString( UINT id );

protected:
    void    Purge();

#define DIC_RUN_SIZE 7
#define DIC_TABLE_SIZE 5

typedef struct _LINKDICSTRING
{
    int     cbUsed;
	LPTSTR	pszKey[DIC_RUN_SIZE];
	UINT    ID[DIC_RUN_SIZE];
	_LINKDICSTRING * pNext;
} LINKDICSTRING, * PLINKDICSTRING;

	PLINKDICSTRING	m_Table[DIC_TABLE_SIZE];

	DWORD	Hash(LPCTSTR szPropID, DWORD dwStrLen=0);
    BOOL    Set(LPCTSTR szPropID);
};

//
// There are not that many items on each element, so we put them in a linked list.
// COULD be sorted by UINT.
//
class CStringPropertySection
{
public:
	CStringPropertySection();
	virtual ~CStringPropertySection();
	BOOL	Set( LPCTSTR szPropID, LPCTSTR pValue );
	LPCTSTR	Get( LPCTSTR szPropID );
    DWORD   YesNo( LPCTSTR szPropID, DWORD dwNotPresent, DWORD dwYes=TRUE);
    DWORD   YesNo( LPCTSTR szPropID, DWORD defNotPresent, DWORD dwNo, DWORD dwYes);
    DWORD   ValueOf( LPCTSTR szPropID, DWORD dwDefault);
    static  CDictionary m_Dictionary;

protected:
    void    Purge();

#define RUN_SIZE 5

typedef struct _LINKSTRING
{
	UINT        idKey;
	LPTSTR	    pszValue;
} LINKSTRING, * PLINKSTRING;

    UINT        m_UsedItems;
    UINT        m_ItemSize;
	PLINKSTRING	m_Items;

	BOOL	Find(LPCTSTR szPropID, int * pEntry );
};

//
// Maps a string to a something.
//
template <class T> class _StringMap
{
public:
#define MAP_RUN_SIZE 5
typedef struct _MAPLINKSTRING
{
	UINT        idKey;
	T *         pValue;
} MAPLINKSTRING, * PLINKSTRING;

	_StringMap()
    {
        m_UsedItems=0;  // make this an array and re-alloc it - like the CDPA ! Gosh.
        m_ItemSize=MAP_RUN_SIZE;
        m_Items=new _MAPLINKSTRING[m_ItemSize];
    }

	virtual ~_StringMap() 
	{
        Purge();
        delete m_Items;
        m_Items=NULL;
	};

	T *     Get( LPCTSTR szPropID )
    {
        int iEntry;
	    if( Find( szPropID, &iEntry ) )
		    return m_Items[iEntry].pValue;
	    return NULL;
    }

	BOOL	Set( LPCTSTR szPropID, T * pValue )
    {
        int iEntry;
	    if( Find( szPropID, &iEntry ) == FALSE )
	    {
            if( m_UsedItems == m_ItemSize )
            {
                // re allocate the buffer bigger.
                m_ItemSize*=2;
                PLINKSTRING pNew=new _MAPLINKSTRING[m_ItemSize];
                CopyMemory(pNew, m_Items, sizeof(_MAPLINKSTRING) * m_UsedItems );
                delete m_Items;
                m_Items=pNew;
            }

            iEntry=m_UsedItems++;
            m_Items[iEntry].idKey=CStringPropertySection::m_Dictionary.GetID( szPropID );
	    }
	    else
        {
		    delete m_Items[iEntry].pValue;
        }

        m_Items[iEntry].pValue=pValue;
	    return TRUE;
    }

private:
    _StringMap( const _StringMap<T> & list ) {};

protected:
    void    Purge()
    {
	    for(UINT i=0;i<m_UsedItems;i++)
	    {
            m_Items[i].idKey=0;
		    delete m_Items[i].pValue;
            m_Items[i].pValue=NULL;
	    }
        m_UsedItems=0;
    }


    UINT        m_UsedItems;
    UINT        m_ItemSize;
	PLINKSTRING	m_Items;

    BOOL	Find(LPCTSTR szPropID, int * pEntry )
    {
        UINT uiPropID = CStringPropertySection::m_Dictionary.GetID( szPropID ); // this is the ID for this string.
        for(UINT i=0;i<m_UsedItems;i++)
        {
            if( uiPropID == m_Items[i].idKey )
            {
                *pEntry=i;
                return TRUE;
            }
        }
        *pEntry=0;
	    return FALSE;
    }
};

#endif // !defined(AFX_STRINGPROPERTY_H__CE442DDC_8EF3_11D2_84A3_00C04FB177B1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\appsvcs\utils.cpp ===
#include "stdafx.h"
#include "utils.h"
#include "tchar.h"

//
// StringToInt - convert the decimal or hex string passed in to an integer
//       A NULL input will return 0
//		 Overflow is not detected, white spaces not allowed
//
// MCostea May 27, 1999
//
//
int StringToIntDef(LPCTSTR psz, int Default)
{
	int retVal = 0;	// current total
	int c;			// current char

	if(psz != NULL)
	{
		int sign = 1;

		c = (int)(TCHAR)*psz++;

		switch(c)
		{
		case __T('-'):
			sign = -1;
			break;
		case __T('+'):
			break;
		case __T('0'):
			{
				c = (int)(TCHAR)*psz++;
				if(c == __T('x'))
					return ReadHexValue(psz);					
				else 
					return 0;
			}
			break;
		default:
			if(c >= __T('0') || c <= __T('9'))
				retVal = c -__T('0');
			else 
				return Default;
		}

		while(c = (int)(TCHAR)*psz++)
		{
			c -= __T('0');
			if( c < 0 || c > 9)
				return 	sign*retVal;
			retVal = retVal*10 + c;
		}
		retVal = sign*retVal;
	}
	return retVal;
}


int ReadHexValue(LPCTSTR psz)
{
	int retVal = 0;	// current total
	int c;			// current char
	int digit;

	while(c = (int)(TCHAR)*psz++)
	{
		if(c >= __T('0') && c <= __T('9'))
			digit = c - __T('0');
		else if( c >= __T('a') && c <= __T('f'))
			digit = c - __T('a') + 10;
		else if( c >= __T('A') && c <= __T('F'))
			digit = c - __T('A') + 10;
		retVal = (retVal << 4) + digit;
	}
	return retVal;
}

void CopyToWideChar( WCHAR** pstrOut, LPCTSTR strIn ) 
{ 
	if(strIn==NULL )
	{
	    **pstrOut = 0; 
        *pstrOut +=1;   // move on, we just put a null down.
		return;
	}
    WCHAR* strOut = *pstrOut; 
    DWORD  dwLen = lstrlen( strIn ); 

#ifdef UNICODE // Copy Unicode to Unicode 
    lstrcpy( strOut, strIn ); 
#else         // Copy Ansi to Unicode 
    dwLen = MultiByteToWideChar( CP_ACP, 0, strIn, dwLen, strOut, dwLen ); 
    strOut[dwLen] = 0; // Add the null terminator 
#endif 
    *pstrOut += dwLen+1; 
} 

/*
 * This function allocates the new UNICODE string and copies the content 
 * from the ANSI source.  It's the caller responsability to free the memory
 */
LPWSTR UnicodeStringFromAnsi(LPCSTR pszSource)
{
	DWORD dwOutLen = lstrlenA(pszSource)+1;
	LPWSTR pszUString = new WCHAR[dwOutLen];

    dwOutLen = MultiByteToWideChar( CP_ACP, 0, pszSource, dwOutLen-1, pszUString, dwOutLen ); 
    pszUString[dwOutLen] = 0; // Add the null terminator 
	return pszUString;
}

/*
 * This function allocates the new UNICODE string and copies the content 
 * from the ANSI source.  It's the caller responsability to free the memory
 */
LPSTR AnsiStringFromUnicode(LPCWSTR pszSource)
{
	DWORD dwOutLen = lstrlenW(pszSource)+1;
	LPSTR pszUString = new CHAR[dwOutLen];

    dwOutLen = WideCharToMultiByte( CP_ACP, WC_DEFAULTCHAR, pszSource, dwOutLen-1, pszUString, dwOutLen, NULL, NULL ); 
    pszUString[dwOutLen] = 0; // Add the null terminator 
	return pszUString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\appservices.cpp ===
// APPSERVICES.cpp : Defines the entry point for the DLL application.
//

#include "stdafx.h"
#define APPSERVICES_EXPORTS
#include "APPSERVICES.h"
#include "elements.h"

HINSTANCE g_hModule;

BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    switch (ul_reason_for_call)
	{
		case DLL_PROCESS_ATTACH:
            CoInitialize(NULL);
			g_hModule=(HINSTANCE)hModule;
            return TRUE;

		case DLL_PROCESS_DETACH:
            CoUninitialize();
            return TRUE;

		case DLL_THREAD_ATTACH:
            break;

		case DLL_THREAD_DETACH:
			break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\appsvcs\wbemcli.h ===
//
//	This file was automatically generated from the IDL files 
//	included with the WBEM SDK in the \include directory.  If you
//  experience problems compiling this file you can re-generate it
//  by running NMAKE (or another MAKE utility) from within the 
//	\include directory.
//
// Copyright 1999 Microsoft Corporation
//
//
//=================================================================

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Thu Aug 19 19:06:34 1999
 */
/* Compiler settings for wbemcli.idl:
    Os (OptLev=s), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wbemcli_h__
#define __wbemcli_h__

/* Forward Declarations */ 

#ifndef __IWbemClassObject_FWD_DEFINED__
#define __IWbemClassObject_FWD_DEFINED__
typedef interface IWbemClassObject IWbemClassObject;
#endif 	/* __IWbemClassObject_FWD_DEFINED__ */


#ifndef __IWbemObjectAccess_FWD_DEFINED__
#define __IWbemObjectAccess_FWD_DEFINED__
typedef interface IWbemObjectAccess IWbemObjectAccess;
#endif 	/* __IWbemObjectAccess_FWD_DEFINED__ */


#ifndef __IWbemQualifierSet_FWD_DEFINED__
#define __IWbemQualifierSet_FWD_DEFINED__
typedef interface IWbemQualifierSet IWbemQualifierSet;
#endif 	/* __IWbemQualifierSet_FWD_DEFINED__ */


#ifndef __IWbemServices_FWD_DEFINED__
#define __IWbemServices_FWD_DEFINED__
typedef interface IWbemServices IWbemServices;
#endif 	/* __IWbemServices_FWD_DEFINED__ */


#ifndef __IWbemLocator_FWD_DEFINED__
#define __IWbemLocator_FWD_DEFINED__
typedef interface IWbemLocator IWbemLocator;
#endif 	/* __IWbemLocator_FWD_DEFINED__ */


#ifndef __IWbemObjectSink_FWD_DEFINED__
#define __IWbemObjectSink_FWD_DEFINED__
typedef interface IWbemObjectSink IWbemObjectSink;
#endif 	/* __IWbemObjectSink_FWD_DEFINED__ */


#ifndef __IEnumWbemClassObject_FWD_DEFINED__
#define __IEnumWbemClassObject_FWD_DEFINED__
typedef interface IEnumWbemClassObject IEnumWbemClassObject;
#endif 	/* __IEnumWbemClassObject_FWD_DEFINED__ */


#ifndef __IWbemCallResult_FWD_DEFINED__
#define __IWbemCallResult_FWD_DEFINED__
typedef interface IWbemCallResult IWbemCallResult;
#endif 	/* __IWbemCallResult_FWD_DEFINED__ */


#ifndef __IWbemContext_FWD_DEFINED__
#define __IWbemContext_FWD_DEFINED__
typedef interface IWbemContext IWbemContext;
#endif 	/* __IWbemContext_FWD_DEFINED__ */


#ifndef __IUnsecuredApartment_FWD_DEFINED__
#define __IUnsecuredApartment_FWD_DEFINED__
typedef interface IUnsecuredApartment IUnsecuredApartment;
#endif 	/* __IUnsecuredApartment_FWD_DEFINED__ */


#ifndef __IWbemStatusCodeText_FWD_DEFINED__
#define __IWbemStatusCodeText_FWD_DEFINED__
typedef interface IWbemStatusCodeText IWbemStatusCodeText;
#endif 	/* __IWbemStatusCodeText_FWD_DEFINED__ */


#ifndef __IWbemBackupRestore_FWD_DEFINED__
#define __IWbemBackupRestore_FWD_DEFINED__
typedef interface IWbemBackupRestore IWbemBackupRestore;
#endif 	/* __IWbemBackupRestore_FWD_DEFINED__ */


#ifndef __IWbemRefresher_FWD_DEFINED__
#define __IWbemRefresher_FWD_DEFINED__
typedef interface IWbemRefresher IWbemRefresher;
#endif 	/* __IWbemRefresher_FWD_DEFINED__ */


#ifndef __IWbemHiPerfEnum_FWD_DEFINED__
#define __IWbemHiPerfEnum_FWD_DEFINED__
typedef interface IWbemHiPerfEnum IWbemHiPerfEnum;
#endif 	/* __IWbemHiPerfEnum_FWD_DEFINED__ */


#ifndef __IWbemConfigureRefresher_FWD_DEFINED__
#define __IWbemConfigureRefresher_FWD_DEFINED__
typedef interface IWbemConfigureRefresher IWbemConfigureRefresher;
#endif 	/* __IWbemConfigureRefresher_FWD_DEFINED__ */


#ifndef __WbemLocator_FWD_DEFINED__
#define __WbemLocator_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemLocator WbemLocator;
#else
typedef struct WbemLocator WbemLocator;
#endif /* __cplusplus */

#endif 	/* __WbemLocator_FWD_DEFINED__ */


#ifndef __WbemContext_FWD_DEFINED__
#define __WbemContext_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemContext WbemContext;
#else
typedef struct WbemContext WbemContext;
#endif /* __cplusplus */

#endif 	/* __WbemContext_FWD_DEFINED__ */


#ifndef __UnsecuredApartment_FWD_DEFINED__
#define __UnsecuredApartment_FWD_DEFINED__

#ifdef __cplusplus
typedef class UnsecuredApartment UnsecuredApartment;
#else
typedef struct UnsecuredApartment UnsecuredApartment;
#endif /* __cplusplus */

#endif 	/* __UnsecuredApartment_FWD_DEFINED__ */


#ifndef __WbemClassObject_FWD_DEFINED__
#define __WbemClassObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemClassObject WbemClassObject;
#else
typedef struct WbemClassObject WbemClassObject;
#endif /* __cplusplus */

#endif 	/* __WbemClassObject_FWD_DEFINED__ */


#ifndef __MofCompiler_FWD_DEFINED__
#define __MofCompiler_FWD_DEFINED__

#ifdef __cplusplus
typedef class MofCompiler MofCompiler;
#else
typedef struct MofCompiler MofCompiler;
#endif /* __cplusplus */

#endif 	/* __MofCompiler_FWD_DEFINED__ */


#ifndef __WbemStatusCodeText_FWD_DEFINED__
#define __WbemStatusCodeText_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemStatusCodeText WbemStatusCodeText;
#else
typedef struct WbemStatusCodeText WbemStatusCodeText;
#endif /* __cplusplus */

#endif 	/* __WbemStatusCodeText_FWD_DEFINED__ */


#ifndef __WbemBackupRestore_FWD_DEFINED__
#define __WbemBackupRestore_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemBackupRestore WbemBackupRestore;
#else
typedef struct WbemBackupRestore WbemBackupRestore;
#endif /* __cplusplus */

#endif 	/* __WbemBackupRestore_FWD_DEFINED__ */


#ifndef __WbemRefresher_FWD_DEFINED__
#define __WbemRefresher_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemRefresher WbemRefresher;
#else
typedef struct WbemRefresher WbemRefresher;
#endif /* __cplusplus */

#endif 	/* __WbemRefresher_FWD_DEFINED__ */


#ifndef __IWbemClassObject_FWD_DEFINED__
#define __IWbemClassObject_FWD_DEFINED__
typedef interface IWbemClassObject IWbemClassObject;
#endif 	/* __IWbemClassObject_FWD_DEFINED__ */


#ifndef __IWbemQualifierSet_FWD_DEFINED__
#define __IWbemQualifierSet_FWD_DEFINED__
typedef interface IWbemQualifierSet IWbemQualifierSet;
#endif 	/* __IWbemQualifierSet_FWD_DEFINED__ */


#ifndef __IWbemLocator_FWD_DEFINED__
#define __IWbemLocator_FWD_DEFINED__
typedef interface IWbemLocator IWbemLocator;
#endif 	/* __IWbemLocator_FWD_DEFINED__ */


#ifndef __IWbemObjectSink_FWD_DEFINED__
#define __IWbemObjectSink_FWD_DEFINED__
typedef interface IWbemObjectSink IWbemObjectSink;
#endif 	/* __IWbemObjectSink_FWD_DEFINED__ */


#ifndef __IEnumWbemClassObject_FWD_DEFINED__
#define __IEnumWbemClassObject_FWD_DEFINED__
typedef interface IEnumWbemClassObject IEnumWbemClassObject;
#endif 	/* __IEnumWbemClassObject_FWD_DEFINED__ */


#ifndef __IWbemContext_FWD_DEFINED__
#define __IWbemContext_FWD_DEFINED__
typedef interface IWbemContext IWbemContext;
#endif 	/* __IWbemContext_FWD_DEFINED__ */


#ifndef __IWbemCallResult_FWD_DEFINED__
#define __IWbemCallResult_FWD_DEFINED__
typedef interface IWbemCallResult IWbemCallResult;
#endif 	/* __IWbemCallResult_FWD_DEFINED__ */


#ifndef __IWbemServices_FWD_DEFINED__
#define __IWbemServices_FWD_DEFINED__
typedef interface IWbemServices IWbemServices;
#endif 	/* __IWbemServices_FWD_DEFINED__ */


#ifndef __IWbemObjectAccess_FWD_DEFINED__
#define __IWbemObjectAccess_FWD_DEFINED__
typedef interface IWbemObjectAccess IWbemObjectAccess;
#endif 	/* __IWbemObjectAccess_FWD_DEFINED__ */


#ifndef __IMofCompiler_FWD_DEFINED__
#define __IMofCompiler_FWD_DEFINED__
typedef interface IMofCompiler IMofCompiler;
#endif 	/* __IMofCompiler_FWD_DEFINED__ */


#ifndef __IUnsecuredApartment_FWD_DEFINED__
#define __IUnsecuredApartment_FWD_DEFINED__
typedef interface IUnsecuredApartment IUnsecuredApartment;
#endif 	/* __IUnsecuredApartment_FWD_DEFINED__ */


#ifndef __IWbemStatusCodeText_FWD_DEFINED__
#define __IWbemStatusCodeText_FWD_DEFINED__
typedef interface IWbemStatusCodeText IWbemStatusCodeText;
#endif 	/* __IWbemStatusCodeText_FWD_DEFINED__ */


#ifndef __IWbemBackupRestore_FWD_DEFINED__
#define __IWbemBackupRestore_FWD_DEFINED__
typedef interface IWbemBackupRestore IWbemBackupRestore;
#endif 	/* __IWbemBackupRestore_FWD_DEFINED__ */


#ifndef __IWbemRefresher_FWD_DEFINED__
#define __IWbemRefresher_FWD_DEFINED__
typedef interface IWbemRefresher IWbemRefresher;
#endif 	/* __IWbemRefresher_FWD_DEFINED__ */


#ifndef __IWbemHiPerfEnum_FWD_DEFINED__
#define __IWbemHiPerfEnum_FWD_DEFINED__
typedef interface IWbemHiPerfEnum IWbemHiPerfEnum;
#endif 	/* __IWbemHiPerfEnum_FWD_DEFINED__ */


#ifndef __IWbemConfigureRefresher_FWD_DEFINED__
#define __IWbemConfigureRefresher_FWD_DEFINED__
typedef interface IWbemConfigureRefresher IWbemConfigureRefresher;
#endif 	/* __IWbemConfigureRefresher_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __WbemClient_v1_LIBRARY_DEFINED__
#define __WbemClient_v1_LIBRARY_DEFINED__

/* library WbemClient_v1 */
/* [uuid] */ 
















typedef /* [v1_enum] */ 
enum tag_WBEM_GENUS_TYPE
    {	WBEM_GENUS_CLASS	= 1,
	WBEM_GENUS_INSTANCE	= 2
    }	WBEM_GENUS_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_CHANGE_FLAG_TYPE
    {	WBEM_FLAG_CREATE_OR_UPDATE	= 0,
	WBEM_FLAG_UPDATE_ONLY	= 0x1,
	WBEM_FLAG_CREATE_ONLY	= 0x2,
	WBEM_FLAG_UPDATE_COMPATIBLE	= 0,
	WBEM_FLAG_UPDATE_SAFE_MODE	= 0x20,
	WBEM_FLAG_UPDATE_FORCE_MODE	= 0x40,
	WBEM_MASK_UPDATE_MODE	= 0x60
    }	WBEM_CHANGE_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_GENERIC_FLAG_TYPE
    {	WBEM_FLAG_RETURN_IMMEDIATELY	= 0x10,
	WBEM_FLAG_RETURN_WBEM_COMPLETE	= 0,
	WBEM_FLAG_BIDIRECTIONAL	= 0,
	WBEM_FLAG_FORWARD_ONLY	= 0x20,
	WBEM_FLAG_NO_ERROR_OBJECT	= 0x40,
	WBEM_FLAG_RETURN_ERROR_OBJECT	= 0,
	WBEM_FLAG_SEND_STATUS	= 0x80,
	WBEM_FLAG_DONT_SEND_STATUS	= 0,
	WBEM_FLAG_ENSURE_LOCATABLE	= 0x100,
	WBEM_FLAG_DIRECT_READ	= 0x200,
	WBEM_FLAG_SEND_ONLY_SELECTED	= 0,
	WBEM_RETURN_WHEN_COMPLETE	= 0,
	WBEM_RETURN_IMMEDIATELY	= 0x10,
	WBEM_MASK_RESERVED_FLAGS	= 0x1f000,
	WBEM_FLAG_USE_AMENDED_QUALIFIERS	= 0x20000
    }	WBEM_GENERIC_FLAG_TYPE;

typedef 
enum tag_WBEM_STATUS_TYPE
    {	WBEM_STATUS_COMPLETE	= 0,
	WBEM_STATUS_REQUIREMENTS	= 1,
	WBEM_STATUS_PROGRESS	= 2
    }	WBEM_STATUS_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_TIMEOUT_TYPE
    {	WBEM_NO_WAIT	= 0,
	WBEM_INFINITE	= 0xffffffff
    }	WBEM_TIMEOUT_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_CONDITION_FLAG_TYPE
    {	WBEM_FLAG_ALWAYS	= 0,
	WBEM_FLAG_ONLY_IF_TRUE	= 0x1,
	WBEM_FLAG_ONLY_IF_FALSE	= 0x2,
	WBEM_FLAG_ONLY_IF_IDENTICAL	= 0x3,
	WBEM_MASK_PRIMARY_CONDITION	= 0x3,
	WBEM_FLAG_KEYS_ONLY	= 0x4,
	WBEM_FLAG_REFS_ONLY	= 0x8,
	WBEM_FLAG_LOCAL_ONLY	= 0x10,
	WBEM_FLAG_PROPAGATED_ONLY	= 0x20,
	WBEM_FLAG_SYSTEM_ONLY	= 0x30,
	WBEM_FLAG_NONSYSTEM_ONLY	= 0x40,
	WBEM_MASK_CONDITION_ORIGIN	= 0x70
    }	WBEM_CONDITION_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_FLAVOR_TYPE
    {	WBEM_FLAVOR_DONT_PROPAGATE	= 0,
	WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE	= 0x1,
	WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS	= 0x2,
	WBEM_FLAVOR_MASK_PROPAGATION	= 0xf,
	WBEM_FLAVOR_OVERRIDABLE	= 0,
	WBEM_FLAVOR_NOT_OVERRIDABLE	= 0x10,
	WBEM_FLAVOR_MASK_PERMISSIONS	= 0x10,
	WBEM_FLAVOR_ORIGIN_LOCAL	= 0,
	WBEM_FLAVOR_ORIGIN_PROPAGATED	= 0x20,
	WBEM_FLAVOR_ORIGIN_SYSTEM	= 0x40,
	WBEM_FLAVOR_MASK_ORIGIN	= 0x60,
	WBEM_FLAVOR_NOT_AMENDED	= 0,
	WBEM_FLAVOR_AMENDED	= 0x80,
	WBEM_FLAVOR_MASK_AMENDED	= 0x80
    }	WBEM_FLAVOR_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_QUERY_FLAG_TYPE
    {	WBEM_FLAG_DEEP	= 0,
	WBEM_FLAG_SHALLOW	= 1,
	WBEM_FLAG_PROTOTYPE	= 2
    }	WBEM_QUERY_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_SECURITY_FLAGS
    {	WBEM_ENABLE	= 1,
	WBEM_METHOD_EXECUTE	= 2,
	WBEM_FULL_WRITE_REP	= 4,
	WBEM_PARTIAL_WRITE_REP	= 8,
	WBEM_WRITE_PROVIDER	= 0x10,
	WBEM_REMOTE_ACCESS	= 0x20
    }	WBEM_SECURITY_FLAGS;

typedef /* [v1_enum] */ 
enum tag_WBEM_LIMITATION_FLAG_TYPE
    {	WBEM_FLAG_EXCLUDE_OBJECT_QUALIFIERS	= 0x10,
	WBEM_FLAG_EXCLUDE_PROPERTY_QUALIFIERS	= 0x20
    }	WBEM_LIMITATION_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_TEXT_FLAG_TYPE
    {	WBEM_FLAG_NO_FLAVORS	= 0x1
    }	WBEM_TEXT_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_COMPARISON_FLAG
    {	WBEM_COMPARISON_INCLUDE_ALL	= 0,
	WBEM_FLAG_IGNORE_QUALIFIERS	= 0x1,
	WBEM_FLAG_IGNORE_OBJECT_SOURCE	= 0x2,
	WBEM_FLAG_IGNORE_DEFAULT_VALUES	= 0x4,
	WBEM_FLAG_IGNORE_CLASS	= 0x8,
	WBEM_FLAG_IGNORE_CASE	= 0x10,
	WBEM_FLAG_IGNORE_FLAVOR	= 0x20
    }	WBEM_COMPARISON_FLAG;

typedef /* [v1_enum] */ 
enum tag_WBEM_LOCKING
    {	WBEM_FLAG_ALLOW_READ	= 0x1
    }	WBEM_LOCKING_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_CONNECT
    {	WBEM_FLAG_CREDENTIALS_SPECIFIED	= 0x1
    }	WBEM_CONNECT_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_CIMTYPE_ENUMERATION
    {	CIM_ILLEGAL	= 0xfff,
	CIM_EMPTY	= 0,
	CIM_SINT8	= 16,
	CIM_UINT8	= 17,
	CIM_SINT16	= 2,
	CIM_UINT16	= 18,
	CIM_SINT32	= 3,
	CIM_UINT32	= 19,
	CIM_SINT64	= 20,
	CIM_UINT64	= 21,
	CIM_REAL32	= 4,
	CIM_REAL64	= 5,
	CIM_BOOLEAN	= 11,
	CIM_STRING	= 8,
	CIM_DATETIME	= 101,
	CIM_REFERENCE	= 102,
	CIM_CHAR16	= 103,
	CIM_OBJECT	= 13,
	CIM_FLAG_ARRAY	= 0x2000
    }	CIMTYPE_ENUMERATION;

typedef /* [v1_enum] */ 
enum tag_WBEM_BACKUP_RESTORE_FLAGS
    {	WBEM_FLAG_BACKUP_RESTORE_DEFAULT	= 0,
	WBEM_FLAG_BACKUP_RESTORE_FORCE_SHUTDOWN	= 1
    }	WBEM_BACKUP_RESTORE_FLAGS;

typedef /* [v1_enum] */ 
enum tag_WBEM_REFRESHER_FLAGS
    {	WBEM_FLAG_REFRESH_AUTO_RECONNECT	= 0,
	WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT	= 1
    }	WBEM_REFRESHER_FLAGS;

typedef long CIMTYPE;

typedef /* [v1_enum] */ 
enum tag_WBEMSTATUS
    {	WBEM_NO_ERROR	= 0,
	WBEM_S_NO_ERROR	= 0,
	WBEM_S_SAME	= 0,
	WBEM_S_FALSE	= 1,
	WBEM_S_ALREADY_EXISTS	= 0x40001,
	WBEM_S_RESET_TO_DEFAULT	= 0x40002,
	WBEM_S_DIFFERENT	= 0x40003,
	WBEM_S_TIMEDOUT	= 0x40004,
	WBEM_S_NO_MORE_DATA	= 0x40005,
	WBEM_S_OPERATION_CANCELLED	= 0x40006,
	WBEM_S_PENDING	= 0x40007,
	WBEM_S_DUPLICATE_OBJECTS	= 0x40008,
	WBEM_S_ACCESS_DENIED	= 0x40009,
	WBEM_S_PARTIAL_RESULTS	= 0x40010,
	WBEM_E_FAILED	= 0x80041001,
	WBEM_E_NOT_FOUND	= 0x80041002,
	WBEM_E_ACCESS_DENIED	= 0x80041003,
	WBEM_E_PROVIDER_FAILURE	= 0x80041004,
	WBEM_E_TYPE_MISMATCH	= 0x80041005,
	WBEM_E_OUT_OF_MEMORY	= 0x80041006,
	WBEM_E_INVALID_CONTEXT	= 0x80041007,
	WBEM_E_INVALID_PARAMETER	= 0x80041008,
	WBEM_E_NOT_AVAILABLE	= 0x80041009,
	WBEM_E_CRITICAL_ERROR	= 0x8004100a,
	WBEM_E_INVALID_STREAM	= 0x8004100b,
	WBEM_E_NOT_SUPPORTED	= 0x8004100c,
	WBEM_E_INVALID_SUPERCLASS	= 0x8004100d,
	WBEM_E_INVALID_NAMESPACE	= 0x8004100e,
	WBEM_E_INVALID_OBJECT	= 0x8004100f,
	WBEM_E_INVALID_CLASS	= 0x80041010,
	WBEM_E_PROVIDER_NOT_FOUND	= 0x80041011,
	WBEM_E_INVALID_PROVIDER_REGISTRATION	= 0x80041012,
	WBEM_E_PROVIDER_LOAD_FAILURE	= 0x80041013,
	WBEM_E_INITIALIZATION_FAILURE	= 0x80041014,
	WBEM_E_TRANSPORT_FAILURE	= 0x80041015,
	WBEM_E_INVALID_OPERATION	= 0x80041016,
	WBEM_E_INVALID_QUERY	= 0x80041017,
	WBEM_E_INVALID_QUERY_TYPE	= 0x80041018,
	WBEM_E_ALREADY_EXISTS	= 0x80041019,
	WBEM_E_OVERRIDE_NOT_ALLOWED	= 0x8004101a,
	WBEM_E_PROPAGATED_QUALIFIER	= 0x8004101b,
	WBEM_E_PROPAGATED_PROPERTY	= 0x8004101c,
	WBEM_E_UNEXPECTED	= 0x8004101d,
	WBEM_E_ILLEGAL_OPERATION	= 0x8004101e,
	WBEM_E_CANNOT_BE_KEY	= 0x8004101f,
	WBEM_E_INCOMPLETE_CLASS	= 0x80041020,
	WBEM_E_INVALID_SYNTAX	= 0x80041021,
	WBEM_E_NONDECORATED_OBJECT	= 0x80041022,
	WBEM_E_READ_ONLY	= 0x80041023,
	WBEM_E_PROVIDER_NOT_CAPABLE	= 0x80041024,
	WBEM_E_CLASS_HAS_CHILDREN	= 0x80041025,
	WBEM_E_CLASS_HAS_INSTANCES	= 0x80041026,
	WBEM_E_QUERY_NOT_IMPLEMENTED	= 0x80041027,
	WBEM_E_ILLEGAL_NULL	= 0x80041028,
	WBEM_E_INVALID_QUALIFIER_TYPE	= 0x80041029,
	WBEM_E_INVALID_PROPERTY_TYPE	= 0x8004102a,
	WBEM_E_VALUE_OUT_OF_RANGE	= 0x8004102b,
	WBEM_E_CANNOT_BE_SINGLETON	= 0x8004102c,
	WBEM_E_INVALID_CIM_TYPE	= 0x8004102d,
	WBEM_E_INVALID_METHOD	= 0x8004102e,
	WBEM_E_INVALID_METHOD_PARAMETERS	= 0x8004102f,
	WBEM_E_SYSTEM_PROPERTY	= 0x80041030,
	WBEM_E_INVALID_PROPERTY	= 0x80041031,
	WBEM_E_CALL_CANCELLED	= 0x80041032,
	WBEM_E_SHUTTING_DOWN	= 0x80041033,
	WBEM_E_PROPAGATED_METHOD	= 0x80041034,
	WBEM_E_UNSUPPORTED_PARAMETER	= 0x80041035,
	WBEM_E_MISSING_PARAMETER_ID	= 0x80041036,
	WBEM_E_INVALID_PARAMETER_ID	= 0x80041037,
	WBEM_E_NONCONSECUTIVE_PARAMETER_IDS	= 0x80041038,
	WBEM_E_PARAMETER_ID_ON_RETVAL	= 0x80041039,
	WBEM_E_INVALID_OBJECT_PATH	= 0x8004103a,
	WBEM_E_OUT_OF_DISK_SPACE	= 0x8004103b,
	WBEM_E_BUFFER_TOO_SMALL	= 0x8004103c,
	WBEM_E_UNSUPPORTED_PUT_EXTENSION	= 0x8004103d,
	WBEM_E_UNKNOWN_OBJECT_TYPE	= 0x8004103e,
	WBEM_E_UNKNOWN_PACKET_TYPE	= 0x8004103f,
	WBEM_E_MARSHAL_VERSION_MISMATCH	= 0x80041040,
	WBEM_E_MARSHAL_INVALID_SIGNATURE	= 0x80041041,
	WBEM_E_INVALID_QUALIFIER	= 0x80041042,
	WBEM_E_INVALID_DUPLICATE_PARAMETER	= 0x80041043,
	WBEM_E_TOO_MUCH_DATA	= 0x80041044,
	WBEM_E_SERVER_TOO_BUSY	= 0x80041045,
	WBEM_E_INVALID_FLAVOR	= 0x80041046,
	WBEM_E_CIRCULAR_REFERENCE	= 0x80041047,
	WBEM_E_UNSUPPORTED_CLASS_UPDATE	= 0x80041048,
	WBEM_E_CANNOT_CHANGE_KEY_INHERITANCE	= 0x80041049,
	WBEM_E_CANNOT_CHANGE_INDEX_INHERITANCE	= 0x80041050,
	WBEM_E_TOO_MANY_PROPERTIES	= 0x80041051,
	WBEM_E_UPDATE_TYPE_MISMATCH	= 0x80041052,
	WBEM_E_UPDATE_OVERRIDE_NOT_ALLOWED	= 0x80041053,
	WBEM_E_UPDATE_PROPAGATED_METHOD	= 0x80041054,
	WBEM_E_METHOD_NOT_IMPLEMENTED	= 0x80041055,
	WBEM_E_METHOD_DISABLED	= 0x80041056,
	WBEM_E_REFRESHER_BUSY	= 0x80041057,
	WBEM_E_UNPARSABLE_QUERY	= 0x80041058,
	WBEM_E_NOT_EVENT_CLASS	= 0x80041059,
	WBEM_E_MISSING_GROUP_WITHIN	= 0x8004105a,
	WBEM_E_MISSING_AGGREGATION_LIST	= 0x8004105b,
	WBEM_E_PROPERTY_NOT_AN_OBJECT	= 0x8004105c,
	WBEM_E_AGGREGATING_BY_OBJECT	= 0x8004105d,
	WBEM_E_UNINTERPRETABLE_PROVIDER_QUERY	= 0x8004105f,
	WBEM_E_BACKUP_RESTORE_WINMGMT_RUNNING	= 0x80041060,
	WBEM_E_QUEUE_OVERFLOW	= 0x80041061,
	WBEM_E_PRIVILEGE_NOT_HELD	= 0x80041062,
	WBEM_E_INVALID_OPERATOR	= 0x80041063,
	WBEM_E_LOCAL_CREDENTIALS	= 0x80041064,
	WBEM_E_CANNOT_BE_ABSTRACT	= 0x80041065,
	WBEM_E_AMENDED_OBJECT	= 0x80041066,
	WBEM_E_CLIENT_TOO_SLOW	= 0x80041067,
	WBEMESS_E_REGISTRATION_TOO_BROAD	= 0x80042001,
	WBEMESS_E_REGISTRATION_TOO_PRECISE	= 0x80042002
    }	WBEMSTATUS;


EXTERN_C const IID LIBID_WbemClient_v1;

#ifndef __IWbemClassObject_INTERFACE_DEFINED__
#define __IWbemClassObject_INTERFACE_DEFINED__

/* interface IWbemClassObject */
/* [uuid][object][restricted][local] */ 


EXTERN_C const IID IID_IWbemClassObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("dc12a681-737f-11cf-884d-00aa004b2e24")
    IWbemClassObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetQualifierSet( 
            /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
            /* [unique][in][out] */ CIMTYPE __RPC_FAR *pType,
            /* [unique][in][out] */ long __RPC_FAR *plFlavor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Put( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT __RPC_FAR *pVal,
            /* [in] */ CIMTYPE Type) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            /* [string][in] */ LPCWSTR wszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNames( 
            /* [string][in] */ LPCWSTR wszQualifierName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT __RPC_FAR *pQualifierVal,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pNames) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginEnumeration( 
            /* [in] */ long lEnumFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR __RPC_FAR *strName,
            /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
            /* [unique][in][out] */ CIMTYPE __RPC_FAR *pType,
            /* [unique][in][out] */ long __RPC_FAR *plFlavor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndEnumeration( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyQualifierSet( 
            /* [string][in] */ LPCWSTR wszProperty,
            /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppCopy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectText( 
            /* [in] */ long lFlags,
            /* [out] */ BSTR __RPC_FAR *pstrObjectText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SpawnDerivedClass( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppNewClass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SpawnInstance( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppNewInstance) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompareTo( 
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject __RPC_FAR *pCompareTo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyOrigin( 
            /* [string][in] */ LPCWSTR wszName,
            /* [out] */ BSTR __RPC_FAR *pstrClassName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InheritsFrom( 
            /* [in] */ LPCWSTR strAncestor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMethod( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppInSignature,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutSignature) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutMethod( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject __RPC_FAR *pInSignature,
            /* [in] */ IWbemClassObject __RPC_FAR *pOutSignature) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteMethod( 
            /* [string][in] */ LPCWSTR wszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginMethodEnumeration( 
            /* [in] */ long lEnumFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NextMethod( 
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR __RPC_FAR *pstrName,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppInSignature,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutSignature) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndMethodEnumeration( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMethodQualifierSet( 
            /* [string][in] */ LPCWSTR wszMethod,
            /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMethodOrigin( 
            /* [string][in] */ LPCWSTR wszMethodName,
            /* [out] */ BSTR __RPC_FAR *pstrClassName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemClassObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemClassObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemClassObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetQualifierSet )( 
            IWbemClassObject __RPC_FAR * This,
            /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IWbemClassObject __RPC_FAR * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
            /* [unique][in][out] */ CIMTYPE __RPC_FAR *pType,
            /* [unique][in][out] */ long __RPC_FAR *plFlavor);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IWbemClassObject __RPC_FAR * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT __RPC_FAR *pVal,
            /* [in] */ CIMTYPE Type);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IWbemClassObject __RPC_FAR * This,
            /* [string][in] */ LPCWSTR wszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNames )( 
            IWbemClassObject __RPC_FAR * This,
            /* [string][in] */ LPCWSTR wszQualifierName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT __RPC_FAR *pQualifierVal,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pNames);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginEnumeration )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ long lEnumFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR __RPC_FAR *strName,
            /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
            /* [unique][in][out] */ CIMTYPE __RPC_FAR *pType,
            /* [unique][in][out] */ long __RPC_FAR *plFlavor);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndEnumeration )( 
            IWbemClassObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyQualifierSet )( 
            IWbemClassObject __RPC_FAR * This,
            /* [string][in] */ LPCWSTR wszProperty,
            /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IWbemClassObject __RPC_FAR * This,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppCopy);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectText )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out] */ BSTR __RPC_FAR *pstrObjectText);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SpawnDerivedClass )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppNewClass);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SpawnInstance )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppNewInstance);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CompareTo )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject __RPC_FAR *pCompareTo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyOrigin )( 
            IWbemClassObject __RPC_FAR * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [out] */ BSTR __RPC_FAR *pstrClassName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InheritsFrom )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ LPCWSTR strAncestor);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMethod )( 
            IWbemClassObject __RPC_FAR * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppInSignature,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutSignature);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutMethod )( 
            IWbemClassObject __RPC_FAR * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject __RPC_FAR *pInSignature,
            /* [in] */ IWbemClassObject __RPC_FAR *pOutSignature);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteMethod )( 
            IWbemClassObject __RPC_FAR * This,
            /* [string][in] */ LPCWSTR wszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginMethodEnumeration )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ long lEnumFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NextMethod )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR __RPC_FAR *pstrName,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppInSignature,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutSignature);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndMethodEnumeration )( 
            IWbemClassObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMethodQualifierSet )( 
            IWbemClassObject __RPC_FAR * This,
            /* [string][in] */ LPCWSTR wszMethod,
            /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMethodOrigin )( 
            IWbemClassObject __RPC_FAR * This,
            /* [string][in] */ LPCWSTR wszMethodName,
            /* [out] */ BSTR __RPC_FAR *pstrClassName);
        
        END_INTERFACE
    } IWbemClassObjectVtbl;

    interface IWbemClassObject
    {
        CONST_VTBL struct IWbemClassObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemClassObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemClassObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemClassObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemClassObject_GetQualifierSet(This,ppQualSet)	\
    (This)->lpVtbl -> GetQualifierSet(This,ppQualSet)

#define IWbemClassObject_Get(This,wszName,lFlags,pVal,pType,plFlavor)	\
    (This)->lpVtbl -> Get(This,wszName,lFlags,pVal,pType,plFlavor)

#define IWbemClassObject_Put(This,wszName,lFlags,pVal,Type)	\
    (This)->lpVtbl -> Put(This,wszName,lFlags,pVal,Type)

#define IWbemClassObject_Delete(This,wszName)	\
    (This)->lpVtbl -> Delete(This,wszName)

#define IWbemClassObject_GetNames(This,wszQualifierName,lFlags,pQualifierVal,pNames)	\
    (This)->lpVtbl -> GetNames(This,wszQualifierName,lFlags,pQualifierVal,pNames)

#define IWbemClassObject_BeginEnumeration(This,lEnumFlags)	\
    (This)->lpVtbl -> BeginEnumeration(This,lEnumFlags)

#define IWbemClassObject_Next(This,lFlags,strName,pVal,pType,plFlavor)	\
    (This)->lpVtbl -> Next(This,lFlags,strName,pVal,pType,plFlavor)

#define IWbemClassObject_EndEnumeration(This)	\
    (This)->lpVtbl -> EndEnumeration(This)

#define IWbemClassObject_GetPropertyQualifierSet(This,wszProperty,ppQualSet)	\
    (This)->lpVtbl -> GetPropertyQualifierSet(This,wszProperty,ppQualSet)

#define IWbemClassObject_Clone(This,ppCopy)	\
    (This)->lpVtbl -> Clone(This,ppCopy)

#define IWbemClassObject_GetObjectText(This,lFlags,pstrObjectText)	\
    (This)->lpVtbl -> GetObjectText(This,lFlags,pstrObjectText)

#define IWbemClassObject_SpawnDerivedClass(This,lFlags,ppNewClass)	\
    (This)->lpVtbl -> SpawnDerivedClass(This,lFlags,ppNewClass)

#define IWbemClassObject_SpawnInstance(This,lFlags,ppNewInstance)	\
    (This)->lpVtbl -> SpawnInstance(This,lFlags,ppNewInstance)

#define IWbemClassObject_CompareTo(This,lFlags,pCompareTo)	\
    (This)->lpVtbl -> CompareTo(This,lFlags,pCompareTo)

#define IWbemClassObject_GetPropertyOrigin(This,wszName,pstrClassName)	\
    (This)->lpVtbl -> GetPropertyOrigin(This,wszName,pstrClassName)

#define IWbemClassObject_InheritsFrom(This,strAncestor)	\
    (This)->lpVtbl -> InheritsFrom(This,strAncestor)

#define IWbemClassObject_GetMethod(This,wszName,lFlags,ppInSignature,ppOutSignature)	\
    (This)->lpVtbl -> GetMethod(This,wszName,lFlags,ppInSignature,ppOutSignature)

#define IWbemClassObject_PutMethod(This,wszName,lFlags,pInSignature,pOutSignature)	\
    (This)->lpVtbl -> PutMethod(This,wszName,lFlags,pInSignature,pOutSignature)

#define IWbemClassObject_DeleteMethod(This,wszName)	\
    (This)->lpVtbl -> DeleteMethod(This,wszName)

#define IWbemClassObject_BeginMethodEnumeration(This,lEnumFlags)	\
    (This)->lpVtbl -> BeginMethodEnumeration(This,lEnumFlags)

#define IWbemClassObject_NextMethod(This,lFlags,pstrName,ppInSignature,ppOutSignature)	\
    (This)->lpVtbl -> NextMethod(This,lFlags,pstrName,ppInSignature,ppOutSignature)

#define IWbemClassObject_EndMethodEnumeration(This)	\
    (This)->lpVtbl -> EndMethodEnumeration(This)

#define IWbemClassObject_GetMethodQualifierSet(This,wszMethod,ppQualSet)	\
    (This)->lpVtbl -> GetMethodQualifierSet(This,wszMethod,ppQualSet)

#define IWbemClassObject_GetMethodOrigin(This,wszMethodName,pstrClassName)	\
    (This)->lpVtbl -> GetMethodOrigin(This,wszMethodName,pstrClassName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemClassObject_GetQualifierSet_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet);


void __RPC_STUB IWbemClassObject_GetQualifierSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_Get_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
    /* [unique][in][out] */ CIMTYPE __RPC_FAR *pType,
    /* [unique][in][out] */ long __RPC_FAR *plFlavor);


void __RPC_STUB IWbemClassObject_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_Put_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [in] */ VARIANT __RPC_FAR *pVal,
    /* [in] */ CIMTYPE Type);


void __RPC_STUB IWbemClassObject_Put_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_Delete_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [string][in] */ LPCWSTR wszName);


void __RPC_STUB IWbemClassObject_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetNames_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [string][in] */ LPCWSTR wszQualifierName,
    /* [in] */ long lFlags,
    /* [in] */ VARIANT __RPC_FAR *pQualifierVal,
    /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pNames);


void __RPC_STUB IWbemClassObject_GetNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_BeginEnumeration_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ long lEnumFlags);


void __RPC_STUB IWbemClassObject_BeginEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_Next_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ BSTR __RPC_FAR *strName,
    /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
    /* [unique][in][out] */ CIMTYPE __RPC_FAR *pType,
    /* [unique][in][out] */ long __RPC_FAR *plFlavor);


void __RPC_STUB IWbemClassObject_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_EndEnumeration_Proxy( 
    IWbemClassObject __RPC_FAR * This);


void __RPC_STUB IWbemClassObject_EndEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetPropertyQualifierSet_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [string][in] */ LPCWSTR wszProperty,
    /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet);


void __RPC_STUB IWbemClassObject_GetPropertyQualifierSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_Clone_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppCopy);


void __RPC_STUB IWbemClassObject_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetObjectText_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [out] */ BSTR __RPC_FAR *pstrObjectText);


void __RPC_STUB IWbemClassObject_GetObjectText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_SpawnDerivedClass_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppNewClass);


void __RPC_STUB IWbemClassObject_SpawnDerivedClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_SpawnInstance_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppNewInstance);


void __RPC_STUB IWbemClassObject_SpawnInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_CompareTo_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [in] */ IWbemClassObject __RPC_FAR *pCompareTo);


void __RPC_STUB IWbemClassObject_CompareTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetPropertyOrigin_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [out] */ BSTR __RPC_FAR *pstrClassName);


void __RPC_STUB IWbemClassObject_GetPropertyOrigin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_InheritsFrom_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ LPCWSTR strAncestor);


void __RPC_STUB IWbemClassObject_InheritsFrom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetMethod_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppInSignature,
    /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutSignature);


void __RPC_STUB IWbemClassObject_GetMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_PutMethod_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemClassObject __RPC_FAR *pInSignature,
    /* [in] */ IWbemClassObject __RPC_FAR *pOutSignature);


void __RPC_STUB IWbemClassObject_PutMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_DeleteMethod_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [string][in] */ LPCWSTR wszName);


void __RPC_STUB IWbemClassObject_DeleteMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_BeginMethodEnumeration_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ long lEnumFlags);


void __RPC_STUB IWbemClassObject_BeginMethodEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_NextMethod_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ BSTR __RPC_FAR *pstrName,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppInSignature,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutSignature);


void __RPC_STUB IWbemClassObject_NextMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_EndMethodEnumeration_Proxy( 
    IWbemClassObject __RPC_FAR * This);


void __RPC_STUB IWbemClassObject_EndMethodEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetMethodQualifierSet_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [string][in] */ LPCWSTR wszMethod,
    /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet);


void __RPC_STUB IWbemClassObject_GetMethodQualifierSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetMethodOrigin_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [string][in] */ LPCWSTR wszMethodName,
    /* [out] */ BSTR __RPC_FAR *pstrClassName);


void __RPC_STUB IWbemClassObject_GetMethodOrigin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemClassObject_INTERFACE_DEFINED__ */


#ifndef __IWbemObjectAccess_INTERFACE_DEFINED__
#define __IWbemObjectAccess_INTERFACE_DEFINED__

/* interface IWbemObjectAccess */
/* [uuid][object][restricted][local] */ 


EXTERN_C const IID IID_IWbemObjectAccess;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("49353c9a-516b-11d1-aea6-00c04fb68820")
    IWbemObjectAccess : public IWbemClassObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropertyHandle( 
            /* [string][in] */ LPCWSTR wszPropertyName,
            /* [out] */ CIMTYPE __RPC_FAR *pType,
            /* [out] */ long __RPC_FAR *plHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WritePropertyValue( 
            /* [in] */ long lHandle,
            /* [in] */ long lNumBytes,
            /* [size_is][in] */ const byte __RPC_FAR *aData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadPropertyValue( 
            /* [in] */ long lHandle,
            /* [in] */ long lBufferSize,
            /* [out] */ long __RPC_FAR *plNumBytes,
            /* [length_is][size_is][out] */ byte __RPC_FAR *aData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadDWORD( 
            /* [in] */ long lHandle,
            /* [out] */ DWORD __RPC_FAR *pdw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteDWORD( 
            /* [in] */ long lHandle,
            /* [in] */ DWORD dw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadQWORD( 
            /* [in] */ long lHandle,
            /* [out] */ unsigned __int64 __RPC_FAR *pqw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteQWORD( 
            /* [in] */ long lHandle,
            /* [in] */ unsigned __int64 pw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyInfoByHandle( 
            /* [in] */ long lHandle,
            /* [out] */ BSTR __RPC_FAR *pstrName,
            /* [out] */ CIMTYPE __RPC_FAR *pType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Lock( 
            /* [in] */ long lFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unlock( 
            /* [in] */ long lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemObjectAccessVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemObjectAccess __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemObjectAccess __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetQualifierSet )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
            /* [unique][in][out] */ CIMTYPE __RPC_FAR *pType,
            /* [unique][in][out] */ long __RPC_FAR *plFlavor);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT __RPC_FAR *pVal,
            /* [in] */ CIMTYPE Type);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [string][in] */ LPCWSTR wszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNames )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [string][in] */ LPCWSTR wszQualifierName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT __RPC_FAR *pQualifierVal,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pNames);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginEnumeration )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lEnumFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR __RPC_FAR *strName,
            /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
            /* [unique][in][out] */ CIMTYPE __RPC_FAR *pType,
            /* [unique][in][out] */ long __RPC_FAR *plFlavor);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndEnumeration )( 
            IWbemObjectAccess __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyQualifierSet )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [string][in] */ LPCWSTR wszProperty,
            /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppCopy);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectText )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out] */ BSTR __RPC_FAR *pstrObjectText);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SpawnDerivedClass )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppNewClass);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SpawnInstance )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppNewInstance);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CompareTo )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject __RPC_FAR *pCompareTo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyOrigin )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [out] */ BSTR __RPC_FAR *pstrClassName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InheritsFrom )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ LPCWSTR strAncestor);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMethod )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppInSignature,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutSignature);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutMethod )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject __RPC_FAR *pInSignature,
            /* [in] */ IWbemClassObject __RPC_FAR *pOutSignature);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteMethod )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [string][in] */ LPCWSTR wszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginMethodEnumeration )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lEnumFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NextMethod )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR __RPC_FAR *pstrName,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppInSignature,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutSignature);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndMethodEnumeration )( 
            IWbemObjectAccess __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMethodQualifierSet )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [string][in] */ LPCWSTR wszMethod,
            /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMethodOrigin )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [string][in] */ LPCWSTR wszMethodName,
            /* [out] */ BSTR __RPC_FAR *pstrClassName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyHandle )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [string][in] */ LPCWSTR wszPropertyName,
            /* [out] */ CIMTYPE __RPC_FAR *pType,
            /* [out] */ long __RPC_FAR *plHandle);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WritePropertyValue )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lHandle,
            /* [in] */ long lNumBytes,
            /* [size_is][in] */ const byte __RPC_FAR *aData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReadPropertyValue )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lHandle,
            /* [in] */ long lBufferSize,
            /* [out] */ long __RPC_FAR *plNumBytes,
            /* [length_is][size_is][out] */ byte __RPC_FAR *aData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReadDWORD )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lHandle,
            /* [out] */ DWORD __RPC_FAR *pdw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteDWORD )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lHandle,
            /* [in] */ DWORD dw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReadQWORD )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lHandle,
            /* [out] */ unsigned __int64 __RPC_FAR *pqw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteQWORD )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lHandle,
            /* [in] */ unsigned __int64 pw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyInfoByHandle )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lHandle,
            /* [out] */ BSTR __RPC_FAR *pstrName,
            /* [out] */ CIMTYPE __RPC_FAR *pType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Lock )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Unlock )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lFlags);
        
        END_INTERFACE
    } IWbemObjectAccessVtbl;

    interface IWbemObjectAccess
    {
        CONST_VTBL struct IWbemObjectAccessVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemObjectAccess_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemObjectAccess_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemObjectAccess_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemObjectAccess_GetQualifierSet(This,ppQualSet)	\
    (This)->lpVtbl -> GetQualifierSet(This,ppQualSet)

#define IWbemObjectAccess_Get(This,wszName,lFlags,pVal,pType,plFlavor)	\
    (This)->lpVtbl -> Get(This,wszName,lFlags,pVal,pType,plFlavor)

#define IWbemObjectAccess_Put(This,wszName,lFlags,pVal,Type)	\
    (This)->lpVtbl -> Put(This,wszName,lFlags,pVal,Type)

#define IWbemObjectAccess_Delete(This,wszName)	\
    (This)->lpVtbl -> Delete(This,wszName)

#define IWbemObjectAccess_GetNames(This,wszQualifierName,lFlags,pQualifierVal,pNames)	\
    (This)->lpVtbl -> GetNames(This,wszQualifierName,lFlags,pQualifierVal,pNames)

#define IWbemObjectAccess_BeginEnumeration(This,lEnumFlags)	\
    (This)->lpVtbl -> BeginEnumeration(This,lEnumFlags)

#define IWbemObjectAccess_Next(This,lFlags,strName,pVal,pType,plFlavor)	\
    (This)->lpVtbl -> Next(This,lFlags,strName,pVal,pType,plFlavor)

#define IWbemObjectAccess_EndEnumeration(This)	\
    (This)->lpVtbl -> EndEnumeration(This)

#define IWbemObjectAccess_GetPropertyQualifierSet(This,wszProperty,ppQualSet)	\
    (This)->lpVtbl -> GetPropertyQualifierSet(This,wszProperty,ppQualSet)

#define IWbemObjectAccess_Clone(This,ppCopy)	\
    (This)->lpVtbl -> Clone(This,ppCopy)

#define IWbemObjectAccess_GetObjectText(This,lFlags,pstrObjectText)	\
    (This)->lpVtbl -> GetObjectText(This,lFlags,pstrObjectText)

#define IWbemObjectAccess_SpawnDerivedClass(This,lFlags,ppNewClass)	\
    (This)->lpVtbl -> SpawnDerivedClass(This,lFlags,ppNewClass)

#define IWbemObjectAccess_SpawnInstance(This,lFlags,ppNewInstance)	\
    (This)->lpVtbl -> SpawnInstance(This,lFlags,ppNewInstance)

#define IWbemObjectAccess_CompareTo(This,lFlags,pCompareTo)	\
    (This)->lpVtbl -> CompareTo(This,lFlags,pCompareTo)

#define IWbemObjectAccess_GetPropertyOrigin(This,wszName,pstrClassName)	\
    (This)->lpVtbl -> GetPropertyOrigin(This,wszName,pstrClassName)

#define IWbemObjectAccess_InheritsFrom(This,strAncestor)	\
    (This)->lpVtbl -> InheritsFrom(This,strAncestor)

#define IWbemObjectAccess_GetMethod(This,wszName,lFlags,ppInSignature,ppOutSignature)	\
    (This)->lpVtbl -> GetMethod(This,wszName,lFlags,ppInSignature,ppOutSignature)

#define IWbemObjectAccess_PutMethod(This,wszName,lFlags,pInSignature,pOutSignature)	\
    (This)->lpVtbl -> PutMethod(This,wszName,lFlags,pInSignature,pOutSignature)

#define IWbemObjectAccess_DeleteMethod(This,wszName)	\
    (This)->lpVtbl -> DeleteMethod(This,wszName)

#define IWbemObjectAccess_BeginMethodEnumeration(This,lEnumFlags)	\
    (This)->lpVtbl -> BeginMethodEnumeration(This,lEnumFlags)

#define IWbemObjectAccess_NextMethod(This,lFlags,pstrName,ppInSignature,ppOutSignature)	\
    (This)->lpVtbl -> NextMethod(This,lFlags,pstrName,ppInSignature,ppOutSignature)

#define IWbemObjectAccess_EndMethodEnumeration(This)	\
    (This)->lpVtbl -> EndMethodEnumeration(This)

#define IWbemObjectAccess_GetMethodQualifierSet(This,wszMethod,ppQualSet)	\
    (This)->lpVtbl -> GetMethodQualifierSet(This,wszMethod,ppQualSet)

#define IWbemObjectAccess_GetMethodOrigin(This,wszMethodName,pstrClassName)	\
    (This)->lpVtbl -> GetMethodOrigin(This,wszMethodName,pstrClassName)


#define IWbemObjectAccess_GetPropertyHandle(This,wszPropertyName,pType,plHandle)	\
    (This)->lpVtbl -> GetPropertyHandle(This,wszPropertyName,pType,plHandle)

#define IWbemObjectAccess_WritePropertyValue(This,lHandle,lNumBytes,aData)	\
    (This)->lpVtbl -> WritePropertyValue(This,lHandle,lNumBytes,aData)

#define IWbemObjectAccess_ReadPropertyValue(This,lHandle,lBufferSize,plNumBytes,aData)	\
    (This)->lpVtbl -> ReadPropertyValue(This,lHandle,lBufferSize,plNumBytes,aData)

#define IWbemObjectAccess_ReadDWORD(This,lHandle,pdw)	\
    (This)->lpVtbl -> ReadDWORD(This,lHandle,pdw)

#define IWbemObjectAccess_WriteDWORD(This,lHandle,dw)	\
    (This)->lpVtbl -> WriteDWORD(This,lHandle,dw)

#define IWbemObjectAccess_ReadQWORD(This,lHandle,pqw)	\
    (This)->lpVtbl -> ReadQWORD(This,lHandle,pqw)

#define IWbemObjectAccess_WriteQWORD(This,lHandle,pw)	\
    (This)->lpVtbl -> WriteQWORD(This,lHandle,pw)

#define IWbemObjectAccess_GetPropertyInfoByHandle(This,lHandle,pstrName,pType)	\
    (This)->lpVtbl -> GetPropertyInfoByHandle(This,lHandle,pstrName,pType)

#define IWbemObjectAccess_Lock(This,lFlags)	\
    (This)->lpVtbl -> Lock(This,lFlags)

#define IWbemObjectAccess_Unlock(This,lFlags)	\
    (This)->lpVtbl -> Unlock(This,lFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemObjectAccess_GetPropertyHandle_Proxy( 
    IWbemObjectAccess __RPC_FAR * This,
    /* [string][in] */ LPCWSTR wszPropertyName,
    /* [out] */ CIMTYPE __RPC_FAR *pType,
    /* [out] */ long __RPC_FAR *plHandle);


void __RPC_STUB IWbemObjectAccess_GetPropertyHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_WritePropertyValue_Proxy( 
    IWbemObjectAccess __RPC_FAR * This,
    /* [in] */ long lHandle,
    /* [in] */ long lNumBytes,
    /* [size_is][in] */ const byte __RPC_FAR *aData);


void __RPC_STUB IWbemObjectAccess_WritePropertyValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_ReadPropertyValue_Proxy( 
    IWbemObjectAccess __RPC_FAR * This,
    /* [in] */ long lHandle,
    /* [in] */ long lBufferSize,
    /* [out] */ long __RPC_FAR *plNumBytes,
    /* [length_is][size_is][out] */ byte __RPC_FAR *aData);


void __RPC_STUB IWbemObjectAccess_ReadPropertyValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_ReadDWORD_Proxy( 
    IWbemObjectAccess __RPC_FAR * This,
    /* [in] */ long lHandle,
    /* [out] */ DWORD __RPC_FAR *pdw);


void __RPC_STUB IWbemObjectAccess_ReadDWORD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_WriteDWORD_Proxy( 
    IWbemObjectAccess __RPC_FAR * This,
    /* [in] */ long lHandle,
    /* [in] */ DWORD dw);


void __RPC_STUB IWbemObjectAccess_WriteDWORD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_ReadQWORD_Proxy( 
    IWbemObjectAccess __RPC_FAR * This,
    /* [in] */ long lHandle,
    /* [out] */ unsigned __int64 __RPC_FAR *pqw);


void __RPC_STUB IWbemObjectAccess_ReadQWORD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_WriteQWORD_Proxy( 
    IWbemObjectAccess __RPC_FAR * This,
    /* [in] */ long lHandle,
    /* [in] */ unsigned __int64 pw);


void __RPC_STUB IWbemObjectAccess_WriteQWORD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_GetPropertyInfoByHandle_Proxy( 
    IWbemObjectAccess __RPC_FAR * This,
    /* [in] */ long lHandle,
    /* [out] */ BSTR __RPC_FAR *pstrName,
    /* [out] */ CIMTYPE __RPC_FAR *pType);


void __RPC_STUB IWbemObjectAccess_GetPropertyInfoByHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_Lock_Proxy( 
    IWbemObjectAccess __RPC_FAR * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemObjectAccess_Lock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_Unlock_Proxy( 
    IWbemObjectAccess __RPC_FAR * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemObjectAccess_Unlock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemObjectAccess_INTERFACE_DEFINED__ */


#ifndef __IWbemQualifierSet_INTERFACE_DEFINED__
#define __IWbemQualifierSet_INTERFACE_DEFINED__

/* interface IWbemQualifierSet */
/* [uuid][local][restricted][object] */ 


EXTERN_C const IID IID_IWbemQualifierSet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("dc12a680-737f-11cf-884d-00aa004b2e24")
    IWbemQualifierSet : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
            /* [unique][in][out] */ long __RPC_FAR *plFlavor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Put( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ VARIANT __RPC_FAR *pVal,
            /* [in] */ long lFlavor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            /* [string][in] */ LPCWSTR wszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNames( 
            /* [in] */ long lFlags,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pNames) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginEnumeration( 
            /* [in] */ long lFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR __RPC_FAR *pstrName,
            /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
            /* [unique][in][out] */ long __RPC_FAR *plFlavor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndEnumeration( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemQualifierSetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemQualifierSet __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemQualifierSet __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemQualifierSet __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IWbemQualifierSet __RPC_FAR * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
            /* [unique][in][out] */ long __RPC_FAR *plFlavor);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IWbemQualifierSet __RPC_FAR * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ VARIANT __RPC_FAR *pVal,
            /* [in] */ long lFlavor);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IWbemQualifierSet __RPC_FAR * This,
            /* [string][in] */ LPCWSTR wszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNames )( 
            IWbemQualifierSet __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pNames);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginEnumeration )( 
            IWbemQualifierSet __RPC_FAR * This,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IWbemQualifierSet __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR __RPC_FAR *pstrName,
            /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
            /* [unique][in][out] */ long __RPC_FAR *plFlavor);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndEnumeration )( 
            IWbemQualifierSet __RPC_FAR * This);
        
        END_INTERFACE
    } IWbemQualifierSetVtbl;

    interface IWbemQualifierSet
    {
        CONST_VTBL struct IWbemQualifierSetVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemQualifierSet_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemQualifierSet_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemQualifierSet_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemQualifierSet_Get(This,wszName,lFlags,pVal,plFlavor)	\
    (This)->lpVtbl -> Get(This,wszName,lFlags,pVal,plFlavor)

#define IWbemQualifierSet_Put(This,wszName,pVal,lFlavor)	\
    (This)->lpVtbl -> Put(This,wszName,pVal,lFlavor)

#define IWbemQualifierSet_Delete(This,wszName)	\
    (This)->lpVtbl -> Delete(This,wszName)

#define IWbemQualifierSet_GetNames(This,lFlags,pNames)	\
    (This)->lpVtbl -> GetNames(This,lFlags,pNames)

#define IWbemQualifierSet_BeginEnumeration(This,lFlags)	\
    (This)->lpVtbl -> BeginEnumeration(This,lFlags)

#define IWbemQualifierSet_Next(This,lFlags,pstrName,pVal,plFlavor)	\
    (This)->lpVtbl -> Next(This,lFlags,pstrName,pVal,plFlavor)

#define IWbemQualifierSet_EndEnumeration(This)	\
    (This)->lpVtbl -> EndEnumeration(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemQualifierSet_Get_Proxy( 
    IWbemQualifierSet __RPC_FAR * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
    /* [unique][in][out] */ long __RPC_FAR *plFlavor);


void __RPC_STUB IWbemQualifierSet_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQualifierSet_Put_Proxy( 
    IWbemQualifierSet __RPC_FAR * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ VARIANT __RPC_FAR *pVal,
    /* [in] */ long lFlavor);


void __RPC_STUB IWbemQualifierSet_Put_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQualifierSet_Delete_Proxy( 
    IWbemQualifierSet __RPC_FAR * This,
    /* [string][in] */ LPCWSTR wszName);


void __RPC_STUB IWbemQualifierSet_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQualifierSet_GetNames_Proxy( 
    IWbemQualifierSet __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pNames);


void __RPC_STUB IWbemQualifierSet_GetNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQualifierSet_BeginEnumeration_Proxy( 
    IWbemQualifierSet __RPC_FAR * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemQualifierSet_BeginEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQualifierSet_Next_Proxy( 
    IWbemQualifierSet __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ BSTR __RPC_FAR *pstrName,
    /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
    /* [unique][in][out] */ long __RPC_FAR *plFlavor);


void __RPC_STUB IWbemQualifierSet_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQualifierSet_EndEnumeration_Proxy( 
    IWbemQualifierSet __RPC_FAR * This);


void __RPC_STUB IWbemQualifierSet_EndEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemQualifierSet_INTERFACE_DEFINED__ */


#ifndef __IWbemServices_INTERFACE_DEFINED__
#define __IWbemServices_INTERFACE_DEFINED__

/* interface IWbemServices */
/* [unique][uuid][restricted][object] */ 


EXTERN_C const IID IID_IWbemServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9556dc99-828c-11cf-a37e-00aa003240c7")
    IWbemServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecMethod( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemServices __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemServices __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenNamespace )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ const BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelAsyncCall )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryObjectSink )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObject )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutClass )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutClassAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteClass )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteClassAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateClassEnum )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateClassEnumAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutInstance )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutInstanceAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteInstance )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteInstanceAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateInstanceEnum )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateInstanceEnumAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecQuery )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecQueryAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecNotificationQuery )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecNotificationQueryAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecMethod )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecMethodAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        END_INTERFACE
    } IWbemServicesVtbl;

    interface IWbemServices
    {
        CONST_VTBL struct IWbemServicesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemServices_OpenNamespace(This,strNamespace,lFlags,pCtx,ppWorkingNamespace,ppResult)	\
    (This)->lpVtbl -> OpenNamespace(This,strNamespace,lFlags,pCtx,ppWorkingNamespace,ppResult)

#define IWbemServices_CancelAsyncCall(This,pSink)	\
    (This)->lpVtbl -> CancelAsyncCall(This,pSink)

#define IWbemServices_QueryObjectSink(This,lFlags,ppResponseHandler)	\
    (This)->lpVtbl -> QueryObjectSink(This,lFlags,ppResponseHandler)

#define IWbemServices_GetObject(This,strObjectPath,lFlags,pCtx,ppObject,ppCallResult)	\
    (This)->lpVtbl -> GetObject(This,strObjectPath,lFlags,pCtx,ppObject,ppCallResult)

#define IWbemServices_GetObjectAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> GetObjectAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)

#define IWbemServices_PutClass(This,pObject,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> PutClass(This,pObject,lFlags,pCtx,ppCallResult)

#define IWbemServices_PutClassAsync(This,pObject,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> PutClassAsync(This,pObject,lFlags,pCtx,pResponseHandler)

#define IWbemServices_DeleteClass(This,strClass,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> DeleteClass(This,strClass,lFlags,pCtx,ppCallResult)

#define IWbemServices_DeleteClassAsync(This,strClass,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> DeleteClassAsync(This,strClass,lFlags,pCtx,pResponseHandler)

#define IWbemServices_CreateClassEnum(This,strSuperclass,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> CreateClassEnum(This,strSuperclass,lFlags,pCtx,ppEnum)

#define IWbemServices_CreateClassEnumAsync(This,strSuperclass,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> CreateClassEnumAsync(This,strSuperclass,lFlags,pCtx,pResponseHandler)

#define IWbemServices_PutInstance(This,pInst,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> PutInstance(This,pInst,lFlags,pCtx,ppCallResult)

#define IWbemServices_PutInstanceAsync(This,pInst,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> PutInstanceAsync(This,pInst,lFlags,pCtx,pResponseHandler)

#define IWbemServices_DeleteInstance(This,strObjectPath,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> DeleteInstance(This,strObjectPath,lFlags,pCtx,ppCallResult)

#define IWbemServices_DeleteInstanceAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> DeleteInstanceAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)

#define IWbemServices_CreateInstanceEnum(This,strClass,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> CreateInstanceEnum(This,strClass,lFlags,pCtx,ppEnum)

#define IWbemServices_CreateInstanceEnumAsync(This,strClass,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> CreateInstanceEnumAsync(This,strClass,lFlags,pCtx,pResponseHandler)

#define IWbemServices_ExecQuery(This,strQueryLanguage,strQuery,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> ExecQuery(This,strQueryLanguage,strQuery,lFlags,pCtx,ppEnum)

#define IWbemServices_ExecQueryAsync(This,strQueryLanguage,strQuery,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> ExecQueryAsync(This,strQueryLanguage,strQuery,lFlags,pCtx,pResponseHandler)

#define IWbemServices_ExecNotificationQuery(This,strQueryLanguage,strQuery,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> ExecNotificationQuery(This,strQueryLanguage,strQuery,lFlags,pCtx,ppEnum)

#define IWbemServices_ExecNotificationQueryAsync(This,strQueryLanguage,strQuery,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> ExecNotificationQueryAsync(This,strQueryLanguage,strQuery,lFlags,pCtx,pResponseHandler)

#define IWbemServices_ExecMethod(This,strObjectPath,strMethodName,lFlags,pCtx,pInParams,ppOutParams,ppCallResult)	\
    (This)->lpVtbl -> ExecMethod(This,strObjectPath,strMethodName,lFlags,pCtx,pInParams,ppOutParams,ppCallResult)

#define IWbemServices_ExecMethodAsync(This,strObjectPath,strMethodName,lFlags,pCtx,pInParams,pResponseHandler)	\
    (This)->lpVtbl -> ExecMethodAsync(This,strObjectPath,strMethodName,lFlags,pCtx,pInParams,pResponseHandler)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemServices_OpenNamespace_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ const BSTR strNamespace,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult);


void __RPC_STUB IWbemServices_OpenNamespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_CancelAsyncCall_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ IWbemObjectSink __RPC_FAR *pSink);


void __RPC_STUB IWbemServices_CancelAsyncCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_QueryObjectSink_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler);


void __RPC_STUB IWbemServices_QueryObjectSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_GetObject_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);


void __RPC_STUB IWbemServices_GetObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_GetObjectAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_GetObjectAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_PutClass_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);


void __RPC_STUB IWbemServices_PutClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_PutClassAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_PutClassAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_DeleteClass_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);


void __RPC_STUB IWbemServices_DeleteClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_DeleteClassAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_DeleteClassAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_CreateClassEnum_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ const BSTR strSuperclass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IWbemServices_CreateClassEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_CreateClassEnumAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ const BSTR strSuperclass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_CreateClassEnumAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_PutInstance_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);


void __RPC_STUB IWbemServices_PutInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_PutInstanceAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_PutInstanceAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_DeleteInstance_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);


void __RPC_STUB IWbemServices_DeleteInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_DeleteInstanceAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_DeleteInstanceAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_CreateInstanceEnum_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IWbemServices_CreateInstanceEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_CreateInstanceEnumAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_CreateInstanceEnumAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_ExecQuery_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IWbemServices_ExecQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_ExecQueryAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_ExecQueryAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_ExecNotificationQuery_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IWbemServices_ExecNotificationQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_ExecNotificationQueryAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_ExecNotificationQueryAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_ExecMethod_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ const BSTR strMethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);


void __RPC_STUB IWbemServices_ExecMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_ExecMethodAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ const BSTR strMethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_ExecMethodAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemServices_INTERFACE_DEFINED__ */


#ifndef __IWbemLocator_INTERFACE_DEFINED__
#define __IWbemLocator_INTERFACE_DEFINED__

/* interface IWbemLocator */
/* [unique][uuid][local][restricted][object] */ 


EXTERN_C const IID IID_IWbemLocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("dc12a687-737f-11cf-884d-00aa004b2e24")
    IWbemLocator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ConnectServer( 
            /* [in] */ const BSTR strNetworkResource,
            /* [in] */ const BSTR strUser,
            /* [in] */ const BSTR strPassword,
            /* [in] */ const BSTR strLocale,
            /* [in] */ long lSecurityFlags,
            /* [in] */ const BSTR strAuthority,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppNamespace) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemLocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemLocator __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemLocator __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemLocator __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConnectServer )( 
            IWbemLocator __RPC_FAR * This,
            /* [in] */ const BSTR strNetworkResource,
            /* [in] */ const BSTR strUser,
            /* [in] */ const BSTR strPassword,
            /* [in] */ const BSTR strLocale,
            /* [in] */ long lSecurityFlags,
            /* [in] */ const BSTR strAuthority,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppNamespace);
        
        END_INTERFACE
    } IWbemLocatorVtbl;

    interface IWbemLocator
    {
        CONST_VTBL struct IWbemLocatorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemLocator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemLocator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemLocator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemLocator_ConnectServer(This,strNetworkResource,strUser,strPassword,strLocale,lSecurityFlags,strAuthority,pCtx,ppNamespace)	\
    (This)->lpVtbl -> ConnectServer(This,strNetworkResource,strUser,strPassword,strLocale,lSecurityFlags,strAuthority,pCtx,ppNamespace)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemLocator_ConnectServer_Proxy( 
    IWbemLocator __RPC_FAR * This,
    /* [in] */ const BSTR strNetworkResource,
    /* [in] */ const BSTR strUser,
    /* [in] */ const BSTR strPassword,
    /* [in] */ const BSTR strLocale,
    /* [in] */ long lSecurityFlags,
    /* [in] */ const BSTR strAuthority,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppNamespace);


void __RPC_STUB IWbemLocator_ConnectServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemLocator_INTERFACE_DEFINED__ */


#ifndef __IWbemObjectSink_INTERFACE_DEFINED__
#define __IWbemObjectSink_INTERFACE_DEFINED__

/* interface IWbemObjectSink */
/* [uuid][restricted][object] */ 


EXTERN_C const IID IID_IWbemObjectSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7c857801-7381-11cf-884d-00aa004b2e24")
    IWbemObjectSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Indicate( 
            /* [in] */ long lObjectCount,
            /* [size_is][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *apObjArray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hResult,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject __RPC_FAR *pObjParam) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemObjectSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemObjectSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemObjectSink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemObjectSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Indicate )( 
            IWbemObjectSink __RPC_FAR * This,
            /* [in] */ long lObjectCount,
            /* [size_is][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *apObjArray);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStatus )( 
            IWbemObjectSink __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hResult,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject __RPC_FAR *pObjParam);
        
        END_INTERFACE
    } IWbemObjectSinkVtbl;

    interface IWbemObjectSink
    {
        CONST_VTBL struct IWbemObjectSinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemObjectSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemObjectSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemObjectSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemObjectSink_Indicate(This,lObjectCount,apObjArray)	\
    (This)->lpVtbl -> Indicate(This,lObjectCount,apObjArray)

#define IWbemObjectSink_SetStatus(This,lFlags,hResult,strParam,pObjParam)	\
    (This)->lpVtbl -> SetStatus(This,lFlags,hResult,strParam,pObjParam)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemObjectSink_Indicate_Proxy( 
    IWbemObjectSink __RPC_FAR * This,
    /* [in] */ long lObjectCount,
    /* [size_is][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *apObjArray);


void __RPC_STUB IWbemObjectSink_Indicate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectSink_SetStatus_Proxy( 
    IWbemObjectSink __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [in] */ HRESULT hResult,
    /* [in] */ BSTR strParam,
    /* [in] */ IWbemClassObject __RPC_FAR *pObjParam);


void __RPC_STUB IWbemObjectSink_SetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemObjectSink_INTERFACE_DEFINED__ */


#ifndef __IEnumWbemClassObject_INTERFACE_DEFINED__
#define __IEnumWbemClassObject_INTERFACE_DEFINED__

/* interface IEnumWbemClassObject */
/* [uuid][restricted][object] */ 


EXTERN_C const IID IID_IEnumWbemClassObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("027947e1-d731-11ce-a357-000000000001")
    IEnumWbemClassObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ long lTimeout,
            /* [in] */ ULONG uCount,
            /* [length_is][size_is][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *apObjects,
            /* [out] */ ULONG __RPC_FAR *puReturned) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NextAsync( 
            /* [in] */ ULONG uCount,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ long lTimeout,
            /* [in] */ ULONG nCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumWbemClassObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumWbemClassObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumWbemClassObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumWbemClassObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumWbemClassObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumWbemClassObject __RPC_FAR * This,
            /* [in] */ long lTimeout,
            /* [in] */ ULONG uCount,
            /* [length_is][size_is][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *apObjects,
            /* [out] */ ULONG __RPC_FAR *puReturned);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NextAsync )( 
            IEnumWbemClassObject __RPC_FAR * This,
            /* [in] */ ULONG uCount,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumWbemClassObject __RPC_FAR * This,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumWbemClassObject __RPC_FAR * This,
            /* [in] */ long lTimeout,
            /* [in] */ ULONG nCount);
        
        END_INTERFACE
    } IEnumWbemClassObjectVtbl;

    interface IEnumWbemClassObject
    {
        CONST_VTBL struct IEnumWbemClassObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumWbemClassObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumWbemClassObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumWbemClassObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumWbemClassObject_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumWbemClassObject_Next(This,lTimeout,uCount,apObjects,puReturned)	\
    (This)->lpVtbl -> Next(This,lTimeout,uCount,apObjects,puReturned)

#define IEnumWbemClassObject_NextAsync(This,uCount,pSink)	\
    (This)->lpVtbl -> NextAsync(This,uCount,pSink)

#define IEnumWbemClassObject_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumWbemClassObject_Skip(This,lTimeout,nCount)	\
    (This)->lpVtbl -> Skip(This,lTimeout,nCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_Reset_Proxy( 
    IEnumWbemClassObject __RPC_FAR * This);


void __RPC_STUB IEnumWbemClassObject_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_Next_Proxy( 
    IEnumWbemClassObject __RPC_FAR * This,
    /* [in] */ long lTimeout,
    /* [in] */ ULONG uCount,
    /* [length_is][size_is][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *apObjects,
    /* [out] */ ULONG __RPC_FAR *puReturned);


void __RPC_STUB IEnumWbemClassObject_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_NextAsync_Proxy( 
    IEnumWbemClassObject __RPC_FAR * This,
    /* [in] */ ULONG uCount,
    /* [in] */ IWbemObjectSink __RPC_FAR *pSink);


void __RPC_STUB IEnumWbemClassObject_NextAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_Clone_Proxy( 
    IEnumWbemClassObject __RPC_FAR * This,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumWbemClassObject_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_Skip_Proxy( 
    IEnumWbemClassObject __RPC_FAR * This,
    /* [in] */ long lTimeout,
    /* [in] */ ULONG nCount);


void __RPC_STUB IEnumWbemClassObject_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumWbemClassObject_INTERFACE_DEFINED__ */


#ifndef __IWbemCallResult_INTERFACE_DEFINED__
#define __IWbemCallResult_INTERFACE_DEFINED__

/* interface IWbemCallResult */
/* [uuid][restricted][object] */ 


EXTERN_C const IID IID_IWbemCallResult;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("44aca675-e8fc-11d0-a07c-00c04fb68820")
    IWbemCallResult : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetResultObject( 
            /* [in] */ long lTimeout,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppResultObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResultString( 
            /* [in] */ long lTimeout,
            /* [out] */ BSTR __RPC_FAR *pstrResultString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResultServices( 
            /* [in] */ long lTimeout,
            /* [out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppServices) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCallStatus( 
            /* [in] */ long lTimeout,
            /* [out] */ long __RPC_FAR *plStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemCallResultVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemCallResult __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemCallResult __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemCallResult __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetResultObject )( 
            IWbemCallResult __RPC_FAR * This,
            /* [in] */ long lTimeout,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppResultObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetResultString )( 
            IWbemCallResult __RPC_FAR * This,
            /* [in] */ long lTimeout,
            /* [out] */ BSTR __RPC_FAR *pstrResultString);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetResultServices )( 
            IWbemCallResult __RPC_FAR * This,
            /* [in] */ long lTimeout,
            /* [out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppServices);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCallStatus )( 
            IWbemCallResult __RPC_FAR * This,
            /* [in] */ long lTimeout,
            /* [out] */ long __RPC_FAR *plStatus);
        
        END_INTERFACE
    } IWbemCallResultVtbl;

    interface IWbemCallResult
    {
        CONST_VTBL struct IWbemCallResultVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemCallResult_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemCallResult_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemCallResult_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemCallResult_GetResultObject(This,lTimeout,ppResultObject)	\
    (This)->lpVtbl -> GetResultObject(This,lTimeout,ppResultObject)

#define IWbemCallResult_GetResultString(This,lTimeout,pstrResultString)	\
    (This)->lpVtbl -> GetResultString(This,lTimeout,pstrResultString)

#define IWbemCallResult_GetResultServices(This,lTimeout,ppServices)	\
    (This)->lpVtbl -> GetResultServices(This,lTimeout,ppServices)

#define IWbemCallResult_GetCallStatus(This,lTimeout,plStatus)	\
    (This)->lpVtbl -> GetCallStatus(This,lTimeout,plStatus)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemCallResult_GetResultObject_Proxy( 
    IWbemCallResult __RPC_FAR * This,
    /* [in] */ long lTimeout,
    /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppResultObject);


void __RPC_STUB IWbemCallResult_GetResultObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemCallResult_GetResultString_Proxy( 
    IWbemCallResult __RPC_FAR * This,
    /* [in] */ long lTimeout,
    /* [out] */ BSTR __RPC_FAR *pstrResultString);


void __RPC_STUB IWbemCallResult_GetResultString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemCallResult_GetResultServices_Proxy( 
    IWbemCallResult __RPC_FAR * This,
    /* [in] */ long lTimeout,
    /* [out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppServices);


void __RPC_STUB IWbemCallResult_GetResultServices_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemCallResult_GetCallStatus_Proxy( 
    IWbemCallResult __RPC_FAR * This,
    /* [in] */ long lTimeout,
    /* [out] */ long __RPC_FAR *plStatus);


void __RPC_STUB IWbemCallResult_GetCallStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemCallResult_INTERFACE_DEFINED__ */


#ifndef __IWbemContext_INTERFACE_DEFINED__
#define __IWbemContext_INTERFACE_DEFINED__

/* interface IWbemContext */
/* [uuid][local][restricted][object] */ 


EXTERN_C const IID IID_IWbemContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("44aca674-e8fc-11d0-a07c-00c04fb68820")
    IWbemContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IWbemContext __RPC_FAR *__RPC_FAR *ppNewCopy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNames( 
            /* [in] */ long lFlags,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pNames) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginEnumeration( 
            /* [in] */ long lFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ long lFlags,
            /* [out] */ BSTR __RPC_FAR *pstrName,
            /* [out] */ VARIANT __RPC_FAR *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndEnumeration( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT __RPC_FAR *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [out] */ VARIANT __RPC_FAR *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteValue( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteAll( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemContext __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IWbemContext __RPC_FAR * This,
            /* [out] */ IWbemContext __RPC_FAR *__RPC_FAR *ppNewCopy);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNames )( 
            IWbemContext __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pNames);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginEnumeration )( 
            IWbemContext __RPC_FAR * This,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IWbemContext __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out] */ BSTR __RPC_FAR *pstrName,
            /* [out] */ VARIANT __RPC_FAR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndEnumeration )( 
            IWbemContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetValue )( 
            IWbemContext __RPC_FAR * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT __RPC_FAR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetValue )( 
            IWbemContext __RPC_FAR * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [out] */ VARIANT __RPC_FAR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteValue )( 
            IWbemContext __RPC_FAR * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteAll )( 
            IWbemContext __RPC_FAR * This);
        
        END_INTERFACE
    } IWbemContextVtbl;

    interface IWbemContext
    {
        CONST_VTBL struct IWbemContextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemContext_Clone(This,ppNewCopy)	\
    (This)->lpVtbl -> Clone(This,ppNewCopy)

#define IWbemContext_GetNames(This,lFlags,pNames)	\
    (This)->lpVtbl -> GetNames(This,lFlags,pNames)

#define IWbemContext_BeginEnumeration(This,lFlags)	\
    (This)->lpVtbl -> BeginEnumeration(This,lFlags)

#define IWbemContext_Next(This,lFlags,pstrName,pValue)	\
    (This)->lpVtbl -> Next(This,lFlags,pstrName,pValue)

#define IWbemContext_EndEnumeration(This)	\
    (This)->lpVtbl -> EndEnumeration(This)

#define IWbemContext_SetValue(This,wszName,lFlags,pValue)	\
    (This)->lpVtbl -> SetValue(This,wszName,lFlags,pValue)

#define IWbemContext_GetValue(This,wszName,lFlags,pValue)	\
    (This)->lpVtbl -> GetValue(This,wszName,lFlags,pValue)

#define IWbemContext_DeleteValue(This,wszName,lFlags)	\
    (This)->lpVtbl -> DeleteValue(This,wszName,lFlags)

#define IWbemContext_DeleteAll(This)	\
    (This)->lpVtbl -> DeleteAll(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemContext_Clone_Proxy( 
    IWbemContext __RPC_FAR * This,
    /* [out] */ IWbemContext __RPC_FAR *__RPC_FAR *ppNewCopy);


void __RPC_STUB IWbemContext_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_GetNames_Proxy( 
    IWbemContext __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pNames);


void __RPC_STUB IWbemContext_GetNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_BeginEnumeration_Proxy( 
    IWbemContext __RPC_FAR * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemContext_BeginEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_Next_Proxy( 
    IWbemContext __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [out] */ BSTR __RPC_FAR *pstrName,
    /* [out] */ VARIANT __RPC_FAR *pValue);


void __RPC_STUB IWbemContext_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_EndEnumeration_Proxy( 
    IWbemContext __RPC_FAR * This);


void __RPC_STUB IWbemContext_EndEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_SetValue_Proxy( 
    IWbemContext __RPC_FAR * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [in] */ VARIANT __RPC_FAR *pValue);


void __RPC_STUB IWbemContext_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_GetValue_Proxy( 
    IWbemContext __RPC_FAR * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [out] */ VARIANT __RPC_FAR *pValue);


void __RPC_STUB IWbemContext_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_DeleteValue_Proxy( 
    IWbemContext __RPC_FAR * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemContext_DeleteValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_DeleteAll_Proxy( 
    IWbemContext __RPC_FAR * This);


void __RPC_STUB IWbemContext_DeleteAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemContext_INTERFACE_DEFINED__ */


#ifndef __IUnsecuredApartment_INTERFACE_DEFINED__
#define __IUnsecuredApartment_INTERFACE_DEFINED__

/* interface IUnsecuredApartment */
/* [object][uuid][restricted] */ 


EXTERN_C const IID IID_IUnsecuredApartment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1cfaba8c-1523-11d1-ad79-00c04fd8fdff")
    IUnsecuredApartment : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateObjectStub( 
            /* [in] */ IUnknown __RPC_FAR *pObject,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppStub) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUnsecuredApartmentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUnsecuredApartment __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUnsecuredApartment __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUnsecuredApartment __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateObjectStub )( 
            IUnsecuredApartment __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pObject,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppStub);
        
        END_INTERFACE
    } IUnsecuredApartmentVtbl;

    interface IUnsecuredApartment
    {
        CONST_VTBL struct IUnsecuredApartmentVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUnsecuredApartment_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUnsecuredApartment_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUnsecuredApartment_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUnsecuredApartment_CreateObjectStub(This,pObject,ppStub)	\
    (This)->lpVtbl -> CreateObjectStub(This,pObject,ppStub)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUnsecuredApartment_CreateObjectStub_Proxy( 
    IUnsecuredApartment __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pObject,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppStub);


void __RPC_STUB IUnsecuredApartment_CreateObjectStub_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUnsecuredApartment_INTERFACE_DEFINED__ */


#ifndef __IWbemStatusCodeText_INTERFACE_DEFINED__
#define __IWbemStatusCodeText_INTERFACE_DEFINED__

/* interface IWbemStatusCodeText */
/* [uuid][object][local] */ 


EXTERN_C const IID IID_IWbemStatusCodeText;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("eb87e1bc-3233-11d2-aec9-00c04fb68820")
    IWbemStatusCodeText : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetErrorCodeText( 
            /* [in] */ HRESULT hRes,
            /* [in] */ LCID LocaleId,
            /* [in] */ long lFlags,
            /* [out] */ BSTR __RPC_FAR *MessageText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFacilityCodeText( 
            /* [in] */ HRESULT hRes,
            /* [in] */ LCID LocaleId,
            /* [in] */ long lFlags,
            /* [out] */ BSTR __RPC_FAR *MessageText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemStatusCodeTextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemStatusCodeText __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemStatusCodeText __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemStatusCodeText __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetErrorCodeText )( 
            IWbemStatusCodeText __RPC_FAR * This,
            /* [in] */ HRESULT hRes,
            /* [in] */ LCID LocaleId,
            /* [in] */ long lFlags,
            /* [out] */ BSTR __RPC_FAR *MessageText);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFacilityCodeText )( 
            IWbemStatusCodeText __RPC_FAR * This,
            /* [in] */ HRESULT hRes,
            /* [in] */ LCID LocaleId,
            /* [in] */ long lFlags,
            /* [out] */ BSTR __RPC_FAR *MessageText);
        
        END_INTERFACE
    } IWbemStatusCodeTextVtbl;

    interface IWbemStatusCodeText
    {
        CONST_VTBL struct IWbemStatusCodeTextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemStatusCodeText_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemStatusCodeText_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemStatusCodeText_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemStatusCodeText_GetErrorCodeText(This,hRes,LocaleId,lFlags,MessageText)	\
    (This)->lpVtbl -> GetErrorCodeText(This,hRes,LocaleId,lFlags,MessageText)

#define IWbemStatusCodeText_GetFacilityCodeText(This,hRes,LocaleId,lFlags,MessageText)	\
    (This)->lpVtbl -> GetFacilityCodeText(This,hRes,LocaleId,lFlags,MessageText)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemStatusCodeText_GetErrorCodeText_Proxy( 
    IWbemStatusCodeText __RPC_FAR * This,
    /* [in] */ HRESULT hRes,
    /* [in] */ LCID LocaleId,
    /* [in] */ long lFlags,
    /* [out] */ BSTR __RPC_FAR *MessageText);


void __RPC_STUB IWbemStatusCodeText_GetErrorCodeText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemStatusCodeText_GetFacilityCodeText_Proxy( 
    IWbemStatusCodeText __RPC_FAR * This,
    /* [in] */ HRESULT hRes,
    /* [in] */ LCID LocaleId,
    /* [in] */ long lFlags,
    /* [out] */ BSTR __RPC_FAR *MessageText);


void __RPC_STUB IWbemStatusCodeText_GetFacilityCodeText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemStatusCodeText_INTERFACE_DEFINED__ */


#ifndef __IWbemBackupRestore_INTERFACE_DEFINED__
#define __IWbemBackupRestore_INTERFACE_DEFINED__

/* interface IWbemBackupRestore */
/* [uuid][restricted][object] */ 


EXTERN_C const IID IID_IWbemBackupRestore;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C49E32C7-BC8B-11d2-85D4-00105A1F8304")
    IWbemBackupRestore : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Backup( 
            /* [string][in] */ LPCWSTR strBackupToFile,
            /* [in] */ long lFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Restore( 
            /* [string][in] */ LPCWSTR strRestoreFromFile,
            /* [in] */ long lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemBackupRestoreVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemBackupRestore __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemBackupRestore __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemBackupRestore __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Backup )( 
            IWbemBackupRestore __RPC_FAR * This,
            /* [string][in] */ LPCWSTR strBackupToFile,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Restore )( 
            IWbemBackupRestore __RPC_FAR * This,
            /* [string][in] */ LPCWSTR strRestoreFromFile,
            /* [in] */ long lFlags);
        
        END_INTERFACE
    } IWbemBackupRestoreVtbl;

    interface IWbemBackupRestore
    {
        CONST_VTBL struct IWbemBackupRestoreVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemBackupRestore_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemBackupRestore_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemBackupRestore_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemBackupRestore_Backup(This,strBackupToFile,lFlags)	\
    (This)->lpVtbl -> Backup(This,strBackupToFile,lFlags)

#define IWbemBackupRestore_Restore(This,strRestoreFromFile,lFlags)	\
    (This)->lpVtbl -> Restore(This,strRestoreFromFile,lFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemBackupRestore_Backup_Proxy( 
    IWbemBackupRestore __RPC_FAR * This,
    /* [string][in] */ LPCWSTR strBackupToFile,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemBackupRestore_Backup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemBackupRestore_Restore_Proxy( 
    IWbemBackupRestore __RPC_FAR * This,
    /* [string][in] */ LPCWSTR strRestoreFromFile,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemBackupRestore_Restore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemBackupRestore_INTERFACE_DEFINED__ */


#ifndef __IWbemRefresher_INTERFACE_DEFINED__
#define __IWbemRefresher_INTERFACE_DEFINED__

/* interface IWbemRefresher */
/* [uuid][object][restricted][local] */ 


EXTERN_C const IID IID_IWbemRefresher;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("49353c99-516b-11d1-aea6-00c04fb68820")
    IWbemRefresher : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Refresh( 
            /* [in] */ long lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemRefresherVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemRefresher __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemRefresher __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemRefresher __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            IWbemRefresher __RPC_FAR * This,
            /* [in] */ long lFlags);
        
        END_INTERFACE
    } IWbemRefresherVtbl;

    interface IWbemRefresher
    {
        CONST_VTBL struct IWbemRefresherVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemRefresher_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemRefresher_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemRefresher_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemRefresher_Refresh(This,lFlags)	\
    (This)->lpVtbl -> Refresh(This,lFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemRefresher_Refresh_Proxy( 
    IWbemRefresher __RPC_FAR * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemRefresher_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemRefresher_INTERFACE_DEFINED__ */


#ifndef __IWbemHiPerfEnum_INTERFACE_DEFINED__
#define __IWbemHiPerfEnum_INTERFACE_DEFINED__

/* interface IWbemHiPerfEnum */
/* [uuid][object][restricted][local] */ 


EXTERN_C const IID IID_IWbemHiPerfEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2705C288-79AE-11d2-B348-00105A1F8177")
    IWbemHiPerfEnum : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddObjects( 
            /* [in] */ long lFlags,
            /* [in] */ ULONG uNumObjects,
            /* [size_is][in] */ long __RPC_FAR *apIds,
            /* [size_is][in] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *apObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveObjects( 
            /* [in] */ long lFlags,
            /* [in] */ ULONG uNumObjects,
            /* [size_is][in] */ long __RPC_FAR *apIds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjects( 
            /* [in] */ long lFlags,
            /* [in] */ ULONG uNumObjects,
            /* [length_is][size_is][out] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *apObj,
            /* [out] */ ULONG __RPC_FAR *puReturned) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAll( 
            /* [in] */ long lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemHiPerfEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemHiPerfEnum __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemHiPerfEnum __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemHiPerfEnum __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddObjects )( 
            IWbemHiPerfEnum __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [in] */ ULONG uNumObjects,
            /* [size_is][in] */ long __RPC_FAR *apIds,
            /* [size_is][in] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *apObj);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveObjects )( 
            IWbemHiPerfEnum __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [in] */ ULONG uNumObjects,
            /* [size_is][in] */ long __RPC_FAR *apIds);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjects )( 
            IWbemHiPerfEnum __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [in] */ ULONG uNumObjects,
            /* [length_is][size_is][out] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *apObj,
            /* [out] */ ULONG __RPC_FAR *puReturned);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveAll )( 
            IWbemHiPerfEnum __RPC_FAR * This,
            /* [in] */ long lFlags);
        
        END_INTERFACE
    } IWbemHiPerfEnumVtbl;

    interface IWbemHiPerfEnum
    {
        CONST_VTBL struct IWbemHiPerfEnumVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemHiPerfEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemHiPerfEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemHiPerfEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemHiPerfEnum_AddObjects(This,lFlags,uNumObjects,apIds,apObj)	\
    (This)->lpVtbl -> AddObjects(This,lFlags,uNumObjects,apIds,apObj)

#define IWbemHiPerfEnum_RemoveObjects(This,lFlags,uNumObjects,apIds)	\
    (This)->lpVtbl -> RemoveObjects(This,lFlags,uNumObjects,apIds)

#define IWbemHiPerfEnum_GetObjects(This,lFlags,uNumObjects,apObj,puReturned)	\
    (This)->lpVtbl -> GetObjects(This,lFlags,uNumObjects,apObj,puReturned)

#define IWbemHiPerfEnum_RemoveAll(This,lFlags)	\
    (This)->lpVtbl -> RemoveAll(This,lFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemHiPerfEnum_AddObjects_Proxy( 
    IWbemHiPerfEnum __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [in] */ ULONG uNumObjects,
    /* [size_is][in] */ long __RPC_FAR *apIds,
    /* [size_is][in] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *apObj);


void __RPC_STUB IWbemHiPerfEnum_AddObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemHiPerfEnum_RemoveObjects_Proxy( 
    IWbemHiPerfEnum __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [in] */ ULONG uNumObjects,
    /* [size_is][in] */ long __RPC_FAR *apIds);


void __RPC_STUB IWbemHiPerfEnum_RemoveObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemHiPerfEnum_GetObjects_Proxy( 
    IWbemHiPerfEnum __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [in] */ ULONG uNumObjects,
    /* [length_is][size_is][out] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *apObj,
    /* [out] */ ULONG __RPC_FAR *puReturned);


void __RPC_STUB IWbemHiPerfEnum_GetObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemHiPerfEnum_RemoveAll_Proxy( 
    IWbemHiPerfEnum __RPC_FAR * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemHiPerfEnum_RemoveAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemHiPerfEnum_INTERFACE_DEFINED__ */


#ifndef __IWbemConfigureRefresher_INTERFACE_DEFINED__
#define __IWbemConfigureRefresher_INTERFACE_DEFINED__

/* interface IWbemConfigureRefresher */
/* [uuid][object][restricted][local] */ 


EXTERN_C const IID IID_IWbemConfigureRefresher;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("49353c92-516b-11d1-aea6-00c04fb68820")
    IWbemConfigureRefresher : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddObjectByPath( 
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [string][in] */ LPCWSTR wszPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pContext,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppRefreshable,
            /* [unique][in][out] */ long __RPC_FAR *plId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddObjectByTemplate( 
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemClassObject __RPC_FAR *pTemplate,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pContext,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppRefreshable,
            /* [unique][in][out] */ long __RPC_FAR *plId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddRefresher( 
            /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ long __RPC_FAR *plId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ long lId,
            /* [in] */ long lFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddEnum( 
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [string][in] */ LPCWSTR wszClassName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pContext,
            /* [out] */ IWbemHiPerfEnum __RPC_FAR *__RPC_FAR *ppEnum,
            /* [unique][in][out] */ long __RPC_FAR *plId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemConfigureRefresherVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemConfigureRefresher __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemConfigureRefresher __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemConfigureRefresher __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddObjectByPath )( 
            IWbemConfigureRefresher __RPC_FAR * This,
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [string][in] */ LPCWSTR wszPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pContext,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppRefreshable,
            /* [unique][in][out] */ long __RPC_FAR *plId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddObjectByTemplate )( 
            IWbemConfigureRefresher __RPC_FAR * This,
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemClassObject __RPC_FAR *pTemplate,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pContext,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppRefreshable,
            /* [unique][in][out] */ long __RPC_FAR *plId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddRefresher )( 
            IWbemConfigureRefresher __RPC_FAR * This,
            /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ long __RPC_FAR *plId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Remove )( 
            IWbemConfigureRefresher __RPC_FAR * This,
            /* [in] */ long lId,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddEnum )( 
            IWbemConfigureRefresher __RPC_FAR * This,
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [string][in] */ LPCWSTR wszClassName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pContext,
            /* [out] */ IWbemHiPerfEnum __RPC_FAR *__RPC_FAR *ppEnum,
            /* [unique][in][out] */ long __RPC_FAR *plId);
        
        END_INTERFACE
    } IWbemConfigureRefresherVtbl;

    interface IWbemConfigureRefresher
    {
        CONST_VTBL struct IWbemConfigureRefresherVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemConfigureRefresher_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemConfigureRefresher_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemConfigureRefresher_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemConfigureRefresher_AddObjectByPath(This,pNamespace,wszPath,lFlags,pContext,ppRefreshable,plId)	\
    (This)->lpVtbl -> AddObjectByPath(This,pNamespace,wszPath,lFlags,pContext,ppRefreshable,plId)

#define IWbemConfigureRefresher_AddObjectByTemplate(This,pNamespace,pTemplate,lFlags,pContext,ppRefreshable,plId)	\
    (This)->lpVtbl -> AddObjectByTemplate(This,pNamespace,pTemplate,lFlags,pContext,ppRefreshable,plId)

#define IWbemConfigureRefresher_AddRefresher(This,pRefresher,lFlags,plId)	\
    (This)->lpVtbl -> AddRefresher(This,pRefresher,lFlags,plId)

#define IWbemConfigureRefresher_Remove(This,lId,lFlags)	\
    (This)->lpVtbl -> Remove(This,lId,lFlags)

#define IWbemConfigureRefresher_AddEnum(This,pNamespace,wszClassName,lFlags,pContext,ppEnum,plId)	\
    (This)->lpVtbl -> AddEnum(This,pNamespace,wszClassName,lFlags,pContext,ppEnum,plId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemConfigureRefresher_AddObjectByPath_Proxy( 
    IWbemConfigureRefresher __RPC_FAR * This,
    /* [in] */ IWbemServices __RPC_FAR *pNamespace,
    /* [string][in] */ LPCWSTR wszPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pContext,
    /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppRefreshable,
    /* [unique][in][out] */ long __RPC_FAR *plId);


void __RPC_STUB IWbemConfigureRefresher_AddObjectByPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemConfigureRefresher_AddObjectByTemplate_Proxy( 
    IWbemConfigureRefresher __RPC_FAR * This,
    /* [in] */ IWbemServices __RPC_FAR *pNamespace,
    /* [in] */ IWbemClassObject __RPC_FAR *pTemplate,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pContext,
    /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppRefreshable,
    /* [unique][in][out] */ long __RPC_FAR *plId);


void __RPC_STUB IWbemConfigureRefresher_AddObjectByTemplate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemConfigureRefresher_AddRefresher_Proxy( 
    IWbemConfigureRefresher __RPC_FAR * This,
    /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ long __RPC_FAR *plId);


void __RPC_STUB IWbemConfigureRefresher_AddRefresher_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemConfigureRefresher_Remove_Proxy( 
    IWbemConfigureRefresher __RPC_FAR * This,
    /* [in] */ long lId,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemConfigureRefresher_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemConfigureRefresher_AddEnum_Proxy( 
    IWbemConfigureRefresher __RPC_FAR * This,
    /* [in] */ IWbemServices __RPC_FAR *pNamespace,
    /* [string][in] */ LPCWSTR wszClassName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pContext,
    /* [out] */ IWbemHiPerfEnum __RPC_FAR *__RPC_FAR *ppEnum,
    /* [unique][in][out] */ long __RPC_FAR *plId);


void __RPC_STUB IWbemConfigureRefresher_AddEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemConfigureRefresher_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_WbemLocator;

#ifdef __cplusplus

class DECLSPEC_UUID("4590f811-1d3a-11d0-891f-00aa004b2e24")
WbemLocator;
#endif

EXTERN_C const CLSID CLSID_WbemContext;

#ifdef __cplusplus

class DECLSPEC_UUID("674B6698-EE92-11d0-AD71-00C04FD8FDFF")
WbemContext;
#endif

EXTERN_C const CLSID CLSID_UnsecuredApartment;

#ifdef __cplusplus

class DECLSPEC_UUID("49bd2028-1523-11d1-ad79-00c04fd8fdff")
UnsecuredApartment;
#endif

EXTERN_C const CLSID CLSID_WbemClassObject;

#ifdef __cplusplus

class DECLSPEC_UUID("9A653086-174F-11d2-B5F9-00104B703EFD")
WbemClassObject;
#endif

EXTERN_C const CLSID CLSID_MofCompiler;

#ifdef __cplusplus

class DECLSPEC_UUID("6daf9757-2e37-11d2-aec9-00c04fb68820")
MofCompiler;
#endif

EXTERN_C const CLSID CLSID_WbemStatusCodeText;

#ifdef __cplusplus

class DECLSPEC_UUID("eb87e1bd-3233-11d2-aec9-00c04fb68820")
WbemStatusCodeText;
#endif

EXTERN_C const CLSID CLSID_WbemBackupRestore;

#ifdef __cplusplus

class DECLSPEC_UUID("C49E32C6-BC8B-11d2-85D4-00105A1F8304")
WbemBackupRestore;
#endif

EXTERN_C const CLSID CLSID_WbemRefresher;

#ifdef __cplusplus

class DECLSPEC_UUID("c71566f2-561e-11d1-ad87-00c04fd8fdff")
WbemRefresher;
#endif
#endif /* __WbemClient_v1_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_wbemcli_0000 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0000_v0_0_s_ifspec;

/* interface __MIDL_itf_wbemcli_0106 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0106_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0106_v0_0_s_ifspec;

/* interface __MIDL_itf_wbemcli_0113 */
/* [local] */ 

typedef struct tag_CompileStatusInfo
    {
    long lPhaseError;
    HRESULT hRes;
    long ObjectNum;
    long FirstLine;
    long LastLine;
    DWORD dwOutFlags;
    }	WBEM_COMPILE_STATUS_INFO;

typedef /* [v1_enum] */ 
enum tag_WBEM_COMPILER_OPTIONS
    {	WBEM_FLAG_CHECK_ONLY	= 0x1,
	WBEM_FLAG_AUTORECOVER	= 0x2,
	WBEM_FLAG_WMI_CHECK	= 0x4,
	WBEM_FLAG_CONSOLE_PRINT	= 0x8,
	WBEM_FLAG_DONT_ADD_TO_LIST	= 0x10,
	WBEM_FLAG_SPLIT_FILES	= 0x20
    }	WBEM_COMPILER_OPTIONS;



extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0113_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0113_v0_0_s_ifspec;

#ifndef __IMofCompiler_INTERFACE_DEFINED__
#define __IMofCompiler_INTERFACE_DEFINED__

/* interface IMofCompiler */
/* [uuid][object][local] */ 


EXTERN_C const IID IID_IMofCompiler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6daf974e-2e37-11d2-aec9-00c04fb68820")
    IMofCompiler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CompileFile( 
            /* [string][in] */ LPWSTR FileName,
            /* [string][in] */ LPWSTR ServerAndNamespace,
            /* [string][in] */ LPWSTR User,
            /* [string][in] */ LPWSTR Authority,
            /* [string][in] */ LPWSTR Password,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompileBuffer( 
            /* [in] */ long BuffSize,
            /* [size_is][in] */ BYTE __RPC_FAR *pBuffer,
            /* [string][in] */ LPWSTR ServerAndNamespace,
            /* [string][in] */ LPWSTR User,
            /* [string][in] */ LPWSTR Authority,
            /* [string][in] */ LPWSTR Password,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateBMOF( 
            /* [string][in] */ LPWSTR TextFileName,
            /* [string][in] */ LPWSTR BMOFFileName,
            /* [string][in] */ LPWSTR ServerAndNamespace,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMofCompilerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMofCompiler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMofCompiler __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMofCompiler __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CompileFile )( 
            IMofCompiler __RPC_FAR * This,
            /* [string][in] */ LPWSTR FileName,
            /* [string][in] */ LPWSTR ServerAndNamespace,
            /* [string][in] */ LPWSTR User,
            /* [string][in] */ LPWSTR Authority,
            /* [string][in] */ LPWSTR Password,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CompileBuffer )( 
            IMofCompiler __RPC_FAR * This,
            /* [in] */ long BuffSize,
            /* [size_is][in] */ BYTE __RPC_FAR *pBuffer,
            /* [string][in] */ LPWSTR ServerAndNamespace,
            /* [string][in] */ LPWSTR User,
            /* [string][in] */ LPWSTR Authority,
            /* [string][in] */ LPWSTR Password,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateBMOF )( 
            IMofCompiler __RPC_FAR * This,
            /* [string][in] */ LPWSTR TextFileName,
            /* [string][in] */ LPWSTR BMOFFileName,
            /* [string][in] */ LPWSTR ServerAndNamespace,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo);
        
        END_INTERFACE
    } IMofCompilerVtbl;

    interface IMofCompiler
    {
        CONST_VTBL struct IMofCompilerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMofCompiler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMofCompiler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMofCompiler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMofCompiler_CompileFile(This,FileName,ServerAndNamespace,User,Authority,Password,lOptionFlags,lClassFlags,lInstanceFlags,pInfo)	\
    (This)->lpVtbl -> CompileFile(This,FileName,ServerAndNamespace,User,Authority,Password,lOptionFlags,lClassFlags,lInstanceFlags,pInfo)

#define IMofCompiler_CompileBuffer(This,BuffSize,pBuffer,ServerAndNamespace,User,Authority,Password,lOptionFlags,lClassFlags,lInstanceFlags,pInfo)	\
    (This)->lpVtbl -> CompileBuffer(This,BuffSize,pBuffer,ServerAndNamespace,User,Authority,Password,lOptionFlags,lClassFlags,lInstanceFlags,pInfo)

#define IMofCompiler_CreateBMOF(This,TextFileName,BMOFFileName,ServerAndNamespace,lOptionFlags,lClassFlags,lInstanceFlags,pInfo)	\
    (This)->lpVtbl -> CreateBMOF(This,TextFileName,BMOFFileName,ServerAndNamespace,lOptionFlags,lClassFlags,lInstanceFlags,pInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMofCompiler_CompileFile_Proxy( 
    IMofCompiler __RPC_FAR * This,
    /* [string][in] */ LPWSTR FileName,
    /* [string][in] */ LPWSTR ServerAndNamespace,
    /* [string][in] */ LPWSTR User,
    /* [string][in] */ LPWSTR Authority,
    /* [string][in] */ LPWSTR Password,
    /* [in] */ LONG lOptionFlags,
    /* [in] */ LONG lClassFlags,
    /* [in] */ LONG lInstanceFlags,
    /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo);


void __RPC_STUB IMofCompiler_CompileFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMofCompiler_CompileBuffer_Proxy( 
    IMofCompiler __RPC_FAR * This,
    /* [in] */ long BuffSize,
    /* [size_is][in] */ BYTE __RPC_FAR *pBuffer,
    /* [string][in] */ LPWSTR ServerAndNamespace,
    /* [string][in] */ LPWSTR User,
    /* [string][in] */ LPWSTR Authority,
    /* [string][in] */ LPWSTR Password,
    /* [in] */ LONG lOptionFlags,
    /* [in] */ LONG lClassFlags,
    /* [in] */ LONG lInstanceFlags,
    /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo);


void __RPC_STUB IMofCompiler_CompileBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMofCompiler_CreateBMOF_Proxy( 
    IMofCompiler __RPC_FAR * This,
    /* [string][in] */ LPWSTR TextFileName,
    /* [string][in] */ LPWSTR BMOFFileName,
    /* [string][in] */ LPWSTR ServerAndNamespace,
    /* [in] */ LONG lOptionFlags,
    /* [in] */ LONG lClassFlags,
    /* [in] */ LONG lInstanceFlags,
    /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo);


void __RPC_STUB IMofCompiler_CreateBMOF_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMofCompiler_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wbemcli_0115 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum tag_WBEM_INFORMATION_FLAG_TYPE
    {	WBEM_FLAG_SHORT_NAME	= 0x1,
	WBEM_FLAG_LONG_NAME	= 0x2
    }	WBEM_INFORMATION_FLAG_TYPE;



extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0115_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0115_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\appsvcs\wmi.h ===
// WMI.h: interface for the CWMI class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_WMI_H__865ED977_E4B8_4954_9437_484C69E407A7__INCLUDED_)
#define AFX_WMI_H__865ED977_E4B8_4954_9437_484C69E407A7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "appservices.h"
#include "wbemcli.h"     // WMI interface declarations

class CWMI  : public CAppServices
{
public:
    CWMI();
    virtual ~CWMI();
    static IRCMLNode * newXMLWMI() { return new CWMI; }

    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InitNode( 
        IRCMLNode __RPC_FAR *parent);

private:
    IWbemClassObject * FindObject( BSTR className );
   	IWbemServices       *   m_pIWbemServices;
   	static IWbemServices *  g_pICIMV2WbemServices;
    static BOOL             g_bInited;
	static IWbemLocator  *  g_pIWbemLocator;
    static _StringMap<IWbemClassObject> g_ClassObjects;
};

#endif // !defined(AFX_WMI_H__865ED977_E4B8_4954_9437_484C69E407A7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\appservices.h ===
#ifndef __APPSERVICES_H
#define __APPSERVICES_H

// The following ifdef block is the standard way of creating macros which make exporting 
// from a DLL simpler. All files within this DLL are compiled with the APPSERVICES_EXPORTS
// symbol defined on the command line. this symbol should not be defined on any project
// that uses this DLL. This way any other project whose source files include this file see 
// APPSERVICES_API functions as being imported from a DLL, wheras this DLL sees symbols
// defined with this macro as being exported.
#ifdef APPSERVICES_EXPORTS
#define APPSERVICES_API __declspec(dllexport)
#else
#define APPSERVICES_API __declspec(dllimport)
#endif

#include "rcmlpub.h"

#include "stringproperty.h"
#include "unknown.h"

#define NEWNODE(name) static IRCMLNode * newXML##name() { return new CXML##name; }
#define XMLNODE(name, function) { name, CXML##function::newXML##function }

extern HINSTANCE g_hModule;


class CAppServices : public _simpleunknown<IRCMLNode>, public CStringPropertySection
{
public:
    CAppServices() { m_StringType=L"Uninitialized"; }
    virtual ~CAppServices() {};

         STDMETHOD(DetachParent)(IRCMLNode **pVal)
        { 
            *pVal = m_pParent;
            if( m_pParent==NULL )
                return E_FAIL;
            return S_OK;
        }

        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE AttachParent( 
            /* [in] */ IRCMLNode __RPC_FAR *newVal)
        {
            m_pParent=newVal;
            return S_OK;
        }

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptChild( 
            IRCMLNode __RPC_FAR *pChild)
        {
            LPWSTR pType;
            LPWSTR pChildType;
            get_StringType( &pType );
            pChild->get_StringType( &pChildType );

            return E_INVALIDARG;    // we don't take children.
        }
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DoEndChild( 
            IRCMLNode __RPC_FAR *child)
        {
            return S_OK;
        }
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ UINT __RPC_FAR *pVal)
        {
            *pVal = NODETYPE;
            return S_OK;
        }
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InitNode( 
            IRCMLNode __RPC_FAR *parent)
        {
            return S_OK;
        }
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DisplayNode( 
            IRCMLNode __RPC_FAR *parent)
        {
            return S_OK;
        }
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExitNode( 
            IRCMLNode __RPC_FAR *parent, LONG lDialogResult)
        {
            return S_OK;
        }
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Attr( 
            LPCWSTR index,
            /* [retval][out] */ LPWSTR __RPC_FAR *pVal)
        {
            *pVal = (LPWSTR)CStringPropertySection::Get(index);
            if( *pVal )
                return S_OK;
            return E_INVALIDARG;    // HMM, we don't have this attribute, but is it failure?
        }
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Attr( 
            LPCWSTR index,
            /* [in] */ LPCWSTR newVal)
        {
            CStringPropertySection::Set(index, newVal);
            return S_OK;
        }
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsType( 
            LPCWSTR nodeName)
        {
            if( lstrcmpi(nodeName, m_StringType) == 0 )
                return S_OK;
            return E_FAIL;  // OK, so it's not really a failure REVIEW!
        }
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE YesDefault( 
            /* [in] */ LPCWSTR propID,
            /* [in] */ DWORD dwNotPresent,
            /* [in] */ DWORD dwYes,
            /* [retval][out] */ DWORD __RPC_FAR *pdwValue)
        {
            *pdwValue = CStringPropertySection::YesNo(propID, dwNotPresent, dwYes);
            return S_OK;
        }
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE YesNoDefault( 
            /* [in] */ LPCWSTR propID,
            /* [in] */ DWORD dwNotPresent,
            /* [in] */ DWORD dwNo,
            /* [in] */ DWORD dwYes,
            /* [retval][out] */ DWORD __RPC_FAR *pdwValue)
        {
            *pdwValue = CStringPropertySection::YesNo(propID, dwNotPresent, dwNo, dwYes);
            return S_OK;
        }
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ValueOf( 
            /* [in] */ LPCWSTR propID,
            /* [in] */ DWORD dwNotPresent,
            /* [retval][out] */ DWORD __RPC_FAR *pdwValue)
        {
            *pdwValue = CStringPropertySection::ValueOf(propID, dwNotPresent);
            return S_OK;
        }

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SignedValueOf( 
            /* [in] */ LPCWSTR propID,
            /* [in] */ int dwNotPresent,
            /* [retval][out] */ int __RPC_FAR *pdwValue)
        {
            *pdwValue = CStringPropertySection::ValueOf(propID, dwNotPresent);
            return S_OK;
        }

        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_StringType( 
            /* [retval][out] */ LPWSTR __RPC_FAR *pStringType)
        {
            *pStringType = (LPWSTR)m_StringType;
            return S_OK;
        }

        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetUnknownEnum( 
            /* [retval][out] */ IEnumUnknown __RPC_FAR *__RPC_FAR *pEnum) { return E_NOTIMPL; }

        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetChildEnum( 
            /* [retval][out] */ IEnumUnknown __RPC_FAR *__RPC_FAR *pEnum) { return E_NOTIMPL; }

protected:
    int NODETYPE;
    LPWSTR  m_StringType;

private:
    IRCMLNode * m_pParent;
    CStringPropertySection m_PS;
};


APPSERVICES_API int fnAPPSERVICES(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\basesapi.cpp ===
// BaseSAPI.cpp: implementation of the CBaseSAPI class.
//
// All speech related classes derive from this.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "BaseSAPI.h"
#include "filestream.h"
#include "debug.h"
#include "utils.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

LONG CBaseSAPI::m_bInited=0;
CComPtr<ISpRecoInstance>		CBaseSAPI::g_cpEngine=NULL;	// Pointer to reco engine interface
CComPtr<ISpVoice>	        	CBaseSAPI::g_cpVoice=NULL;  // Global voice for failure/success
CTunaClient CBaseSAPI::g_Notifications;
CRITICAL_SECTION g_CritSec={0};

CBaseSAPI::CBaseSAPI()
{
	m_bActive=NULL;
    m_cpCmdGrammar=NULL;
    m_cpNumberGrammar=NULL;

	if( InterlockedIncrement( &m_bInited ) == 1 )
    {
        InitializeCriticalSection( & g_CritSec );
    }

    EnterCriticalSection( & g_CritSec );

    if( g_cpEngine == NULL )
    {
        g_Notifications.SetPropertyName("Command Prompts");
        g_Notifications.SetText(L"Please wait ...");
		if( SUCCEEDED( InitSAPI() ))
            g_Notifications.SetText(L"You can now voice command Windows");
        else
            g_Notifications.SetText(L"Please upgrade your system");
    }

    LeaveCriticalSection( & g_CritSec );

    if( g_cpEngine )
    {
	    ISpRecoInstance * pReco=g_cpEngine;
        if(pReco)
	        pReco->AddRef();
    }
}

CBaseSAPI::~CBaseSAPI()
{
    ResetGrammar();

	g_cpEngine.Release();

	if( InterlockedDecrement( &m_bInited ) == 0 )
	{
        g_cpVoice=NULL;
        DeleteCriticalSection( &g_CritSec );
	}

    if( g_cpEngine == NULL )
        CoUninitialize();
}

HRESULT CBaseSAPI::ExitNode(IRCMLNode * parent, LONG lresult)
{
    ResetGrammar();
    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
//
// The base sapi node has provisions for a FAILURE element, and list of SYNONYMs
//
HRESULT STDMETHODCALLTYPE  CBaseSAPI::AcceptChild( 
            IRCMLNode __RPC_FAR *pChild)
{
    LPWSTR pType;
    LPWSTR pChildType;
    get_StringType( &pType );
    pChild->get_StringType( &pChildType );
	if( SUCCEEDED( pChild->IsType( L"CICERO:FAILURE" )))
	{
		m_cpFailure=pChild;
		return S_OK;
	}
    else if( SUCCEEDED( pChild->IsType( L"CICERO:SYNONYM" )))
	{
		m_Synonyms.Append((CXMLSynonym*)pChild);
		return S_OK;
	}
	else if( SUCCEEDED( pChild->IsType( L"CICERO:SUCCESS" )))
	{
		m_cpSuccess=pChild;
		return S_OK;
	}
    return E_INVALIDARG;    // we don't take children.
}

//
// Taken from the SimpleCC.cpp file in the sapi sdk.
//
HRESULT CBaseSAPI::InitSAPI( void )
{
    HRESULT hr = S_OK;

    CoInitialize(NULL);
    //
    // create a recognition engine 
    // CLSID_SpInprocRecoInstance or 
    // CLSID_SpSharedRecoInstance
    //
    if ( SUCCEEDED( hr = g_cpEngine.CoCreateInstance(CLSID_SpSharedRecoInstance) ) )
    {
#ifdef _INPROC
        //
        // We should be able to remove this REVIEW 6/12/00
        //

        CComPtr<ISpAudio> cpAudio;
        // create default audio object
        if ( SUCCEEDED( hr = SpCreateDefaultObjectFromCategoryId(SPCAT_AUDIOIN, &cpAudio) ) )
        {
            hr = g_cpEngine->SetInput(cpAudio, TRUE);
        }
#endif
    }
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
//
// This loads a memory based grammar.
// this will be replaced once SAPI loads from memory.
//
HRESULT CBaseSAPI::LoadCFGFromString( LPCTSTR szRuntimeCFG, LPCTSTR prefix  )
{
    HRESULT hr=S_OK;

// #ifdef DEBUG
    // Need to go via files because of the M2 to M3 changes.
    if( prefix == NULL )
        prefix = TEXT("temp");

    if( prefix )
    {
        //
        // This creates a file for us to look at
        //
	    int i=lstrlen( szRuntimeCFG );
        TCHAR szFile[MAX_PATH];
        wsprintf(szFile,TEXT("c:\\cicerorcml\\%s.xml"),prefix);

	    HANDLE hFile=CreateFile( szFile,
						    GENERIC_WRITE,
						    FILE_SHARE_WRITE,
						    NULL,
						    CREATE_ALWAYS,
						    FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_TEMPORARY,
						    NULL);

	    if( hFile != INVALID_HANDLE_VALUE)
	    {
		    DWORD dwWritten;
		    WriteFile( hFile, szRuntimeCFG, i*sizeof(TCHAR),&dwWritten,NULL);
		    CloseHandle(hFile);
	    }

        LoadCFG( szFile );
    }
// #endif

#if 0
    //
    // From RalphL (SAPI).
    //
    CComPtr<ISpStream> cpSrcStream;
    CComPtr<IStream> cpDestMemStream;
    CComPtr<ISpGrammarCompiler> m_cpCompiler;
    
    _MemoryStream * pMemStream= new _MemoryStream((LPBYTE)szRuntimeCFG, lstrlen(szRuntimeCFG)*sizeof(TCHAR));
    if (SUCCEEDED(hr))
    {
        hr = ::CreateStreamOnHGlobal(NULL, TRUE, &cpDestMemStream);
    }
    if (SUCCEEDED(hr))
    {   // ISpGramCompBackend
        hr = m_cpCompiler.CoCreateInstance(CLSID_SpGrammarCompiler);
    }
    if (SUCCEEDED(hr))
    {
        hr = m_cpCompiler->CompileStream(pMemStream, cpDestMemStream, NULL, NULL, NULL, 0);
    }
    if (SUCCEEDED(hr))
    {
        HGLOBAL hGlobal;
        hr = ::GetHGlobalFromStream(cpDestMemStream, &hGlobal);
        if (SUCCEEDED(hr))
        {
            SPCFGSERIALIZEDHEADER * pBinaryData = (SPCFGSERIALIZEDHEADER * )::GlobalLock(hGlobal);
            if (pBinaryData)
            {
                // hr = LoadCmdFromMemory(pBinaryData, Options);
                // create the command recognition context
                if( SUCCEEDED( hr = GetRecoContext() ))
                {
                    // we use the 'shared' context here.
                    if( SUCCEEDED( hr = m_cpRecoCtxt->CreateGrammar( (DWORD)this, &m_cpCmdGrammar) ))
                    {
                        if( SUCCEEDED( hr = m_cpCmdGrammar->LoadCmdFromMemory( pBinaryData, FALSE ) ))  // is TRUE needed?
                        {
                            // Set rules to active, we are now listening for commands
                            if( SUCCEEDED( hr = SetRuleState(TRUE) ))
                            {
                            }
                            else
                            {
                                // If we failed here, it is OK, we can recover later
                                m_bActive = false;
                                hr = S_OK;
                            }
                        }
                    }
                }
                ::GlobalUnlock(hGlobal);
            }
        }
    }
    delete pMemStream;
#endif
    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
//
// This loads a local grammar.
//
HRESULT CBaseSAPI::LoadCFG( LPCTSTR pszFileName  )
{
	HRESULT hr=E_FAIL;
    if( !g_cpEngine )
        return NULL;

    m_bActive=FALSE; 

    if(m_cpCmdGrammar )
    {
        TRACE(TEXT("This is NOT supposed to happen"));
        m_cpCmdGrammar=NULL;
#ifdef _DEBUG
        _asm int 3;
#endif
    }

    if( SUCCEEDED( hr = GetRecoContext() ))
    {
        if( SUCCEEDED( hr = m_cpRecoCtxt->CreateGrammar( (DWORD)this, &m_cpCmdGrammar) ))
        {
            if( SUCCEEDED( hr = m_cpCmdGrammar->LoadCmdFromFile( pszFileName, SPLO_STATIC ) ))
            {
                // Set rules to active, we are now listening for commands
                if( SUCCEEDED( hr = SetRuleState(TRUE) ))
                {
                }
                else
                {
                    // If we failed here, it is OK, we can recover later
                    m_bActive = false;
                    hr = S_OK;
                }
            }
        }
    }

    if ( FAILED( hr ) )
    {
        // Since we couldn't initialize, we will completely shut down
		// ResetGrammar();
    }

    return ( hr );
}

HRESULT CBaseSAPI::SetRuleState(BOOL bOnOff)
{
    // Set rules to active, we are now listening for commands
    if(m_bActive==bOnOff)
        return S_OK;

    HRESULT hr=S_OK;
    m_bActive=bOnOff;
    if( m_cpCmdGrammar )
    {
        TRACE(TEXT("Turning %s grammars ..."),bOnOff?TEXT("ON "):TEXT("OFF"));
#ifdef _WITH_DICTATION
        m_cpCmdGrammar->SetDictationState(bOnOff?SPRS_ACTIVE:SPRS_INACTIVE);
#endif

        if( m_cpNumberGrammar )
            m_cpNumberGrammar->SetRuleState(
            NULL, 
            NULL, 
            bOnOff?SPRS_ACTIVE:SPRS_INACTIVE);

        hr=m_cpCmdGrammar->SetRuleState(
            NULL, 
            NULL, 
            bOnOff?SPRS_ACTIVE:SPRS_INACTIVE); // ,       // enable the rule
            // FALSE );
        TRACE(TEXT("done\n"));
    }
    return hr;
}

/******************************************************************************
* ResetGrammar   *
*----------------*
*   Description:
*       Called to close down SAPI COM objects we have stored away.
*
******************************************************************************/
void CBaseSAPI::ResetGrammar( void )
{
    if( m_cpCmdGrammar )
        m_cpCmdGrammar.Release();

    if( m_cpRecoCtxt )
    {
        // m_cpRecoCtxt->SetNotifySink(NULL);  
        m_cpRecoCtxt.Release(); // this will release us.
    }
}

/******************************************************************************
* ProcessRecoEvent *
*------------------*
*   Description:
*       Called to when reco event message is sent to main window procedure.
*       In the case of a recognition, it extracts result and calls ExecuteCommand.
*
******************************************************************************/
void CBaseSAPI::ProcessRecoEvent( void )
{
    CSpEvent event;  // Event helper class

    // Loop processing events while there are any in the queue
    while ( S_OK == event.GetFrom(m_cpRecoCtxt) )
    {
        // Look at recognition event only
        if ( SPEI_RECOGNITION == event.eEventId )
        {
            // m_cCmdManager.ExecuteCommand(event.RecoResult());
        }
    }
}

//
// Returne true if it managed to set the text, false otherwise.
//
BOOL CBaseSAPI::SetControlText( LPCWSTR dstrText )
{
	BOOL bRet=TRUE;
	IRCMLNode * pParent;
	if( SUCCEEDED(DetachParent( & pParent )))
	{
		IRCMLControl * pControl;
		if( SUCCEEDED( pParent->QueryInterface( __uuidof( IRCMLControl ) , (LPVOID*)&pControl )))
		{
			HWND hWnd;
			if( SUCCEEDED( pControl->get_Window( &hWnd ))) 
			{
				if( SUCCEEDED(pControl->IsType(L"EDIT") ))
				{
					// SetWindowText( hWnd, dstrText );
                    SendMessage( hWnd, WM_SETTEXT, NULL,(LPARAM)dstrText );
                }
				else if ( SUCCEEDED(pControl->IsType(L"COMBO") ))
				{
					if( SendMessage( hWnd, CB_SELECTSTRING, -1, (LPARAM)dstrText ) == CB_ERR )
                    {
						bRet=FALSE;
                        if( SendMessage( hWnd, WM_SETTEXT, NULL,(LPARAM)dstrText ) )
                            bRet=TRUE;
                    }
                    else
                    {
                        // now fake up the change of selection messages!
                        SendMessage( GetParent( hWnd), WM_COMMAND, MAKEWPARAM( GetDlgCtrlID(hWnd), CBN_SELENDOK ), (LPARAM)hWnd );
                        SendMessage( GetParent( hWnd), WM_COMMAND, MAKEWPARAM( GetDlgCtrlID(hWnd), CBN_SELCHANGE ), (LPARAM)hWnd );
                        SendMessage( GetParent( hWnd), WM_COMMAND, MAKEWPARAM( GetDlgCtrlID(hWnd), CBN_SETFOCUS ), (LPARAM)hWnd );
                    }
				}
				else if ( SUCCEEDED(pControl->IsType(L"LISTBOX") ))
				{
					if( SendMessage( hWnd, LB_SELECTSTRING, -1, (LPARAM)dstrText ) == CB_ERR )
						bRet=FALSE;
                    else
                    {
                        // now fake up the change of selection messages - CHECK THESE!
                        // SendMessage( GetParent( hWnd), WM_COMMAND, MAKEWPARAM( GetDlgCtrlID(hWnd), LBN_SELENDOK ), (LPARAM)hWnd );
                        SendMessage( GetParent( hWnd), WM_COMMAND, MAKEWPARAM( GetDlgCtrlID(hWnd), LBN_SELCHANGE ), (LPARAM)hWnd );
                        SendMessage( GetParent( hWnd), WM_COMMAND, MAKEWPARAM( GetDlgCtrlID(hWnd), LBN_SETFOCUS ), (LPARAM)hWnd );
                    }
				}
			}

			pControl->Release();
		}
	}
	return bRet;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// This will take a string like "&About ..." and return "About"
// or "Try to R&einvest" and return "Reinvest"
//
LPWSTR CBaseSAPI::FindNiceText(LPCWSTR text)
{
    if( text==NULL )
        return NULL;

    LPCWSTR pszLastSpace=text;
    BOOL bFoundAccelorator=FALSE;
    LPCWSTR pszCurrentChar=text;
    while(*pszCurrentChar)
    {
        if( *pszCurrentChar == L'&' )
        {
            bFoundAccelorator=TRUE;
            break;
        }
        if( *pszCurrentChar == L' ' )
            pszLastSpace=pszCurrentChar+1;

        pszCurrentChar++;
    }

    //
    // If we found an &, then we know which word it is on.
    //
    pszCurrentChar = pszLastSpace;
    BOOL bFindingEnd=TRUE;
    UINT iStrLen=0;
    while( bFindingEnd )
    {
        switch (*pszCurrentChar )
        {
            case L' ':
            case L'.':
            case 0:
                bFindingEnd=FALSE;  // we're left pointing at the terminating char.
                break;
            default:
                pszCurrentChar++;
                iStrLen++;
                break;
        }
    };

    LPWSTR pszNewString = new TCHAR[iStrLen+1];

    if( bFoundAccelorator==FALSE )
    {
        ZeroMemory( pszNewString, (iStrLen+1)*sizeof(WCHAR) );
        CopyMemory( pszNewString, pszLastSpace, iStrLen*sizeof(WCHAR));
    }
    else
    {
        // copy, skipping over the & and the ... if present (though they shouldn't be).
        LPWSTR pszDest=pszNewString;
        LPCWSTR pszLastChar=pszCurrentChar;
        pszCurrentChar = pszLastSpace;
        while( pszCurrentChar != pszLastChar )
        {
            if( *pszCurrentChar==L'&' || *pszCurrentChar==L'.' )
            {
            }
            else
                *pszDest++=*pszCurrentChar;
            pszCurrentChar++;
        };
        *pszDest=0;
    }
    return pszNewString;
}

LPWSTR CBaseSAPI::GetRecognizedText(ISpPhrase *pPhrase)
{
    SPPHRASE *pElements;
	LPTSTR pszPropertyName;
	
    // Get the phrase elements, one of which is the rule id we specified in
    // the grammar.  Switch on it to figure out which command was recognized.
    if (SUCCEEDED(pPhrase->GetPhrase(&pElements)))
    {
        CSpDynamicString dstrText;

		BOOL bPropFound=FALSE;
		if( SUCCEEDED( get_Attr(L"PROPNAME", & pszPropertyName) ))
		{
			// find the property name we were looking for.
			if( pElements )
			{
				const SPPHRASEPROPERTY * pProperty=pElements->pProperties;
				while(pProperty)
				{
					if( lstrcmpi( pProperty->pszName, pszPropertyName ) == 0 )
					{
						ULONG FirstElement=pProperty->ulFirstElement;
						if( FirstElement < pElements->Rule.ulCountOfElements )
						{
							dstrText=pElements->pElements[FirstElement].pszDisplayText;
							pProperty=NULL;
							bPropFound=TRUE;
							continue;
						}
					}
					pProperty= pProperty->pNextSibling;
				}
			}
		}

		//
		// Even if they specified a property name, perhaps we ignore it??
		//
		if(bPropFound==FALSE)
			pPhrase->GetText( SP_GETWHOLEPHRASE, SP_GETWHOLEPHRASE, TRUE, &dstrText, NULL);

        LPWSTR pszText = new WCHAR[ lstrlen(dstrText)+1];
        lstrcpy(pszText, dstrText );
        return pszText;
    }
    return NULL;
}

void CBaseSAPI::SayFailure()
{
	if( m_cpFailure )
	{
		LPWSTR pszText;
		if( SUCCEEDED( m_cpFailure->get_Attr( L"TEXT", &pszText )))
		{
            if( GetVoice() )
                g_cpVoice->Speak( pszText, 0, NULL);
		}
	}
}

void CBaseSAPI::SaySuccess()
{
	if( m_cpSuccess )
	{
		LPWSTR pszText;
		if( SUCCEEDED( m_cpSuccess->get_Attr( L"TEXT", &pszText )))
		{
            if( GetVoice() )
                g_cpVoice->Speak( pszText, 0, NULL);
		}
	}
}

LPWSTR CBaseSAPI::GetRecognizedRule(ISpPhrase *pPhrase)
{
    SPPHRASE *pElements;
	LPTSTR pszPropertyName=NULL;

	
    // Get the phrase elements, one of which is the rule id we specified in
    // the grammar.  Switch on it to figure out which command was recognized.
    if (SUCCEEDED(pPhrase->GetPhrase(&pElements)))
    {
#ifdef DEBUG
        CSpDynamicString dstrText;
        pPhrase->GetText(SP_GETWHOLEPHRASE, SP_GETWHOLEPHRASE, TRUE, &dstrText, NULL);
        TRACE(TEXT("I heard %s\n"),dstrText);
#endif

        LPCWSTR pszRuleName;
        //
		// find the property name we were looking for.
        //
		if( pElements )
            pszRuleName = pElements->Rule.pszName;


        LPWSTR pszText = new WCHAR[ lstrlen(pszRuleName)+1];
        lstrcpy(pszText, pszRuleName );
        return pszText;
    }
    return NULL;
}

//
// Non - visible too?
//
BOOL CBaseSAPI::IsEnabled(HWND hWnd)
{
    LONG    style=GetWindowLong( hWnd, GWL_STYLE );
    if( style & WS_DISABLED )
        return FALSE;
    if( style & WS_VISIBLE)
        return TRUE;
    return FALSE;
}


////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
//
// Adds a string to a buffer, allocates the buffer if null.
// and frees the buffer if you append NULL - wow, is that hacky!
//
PSTRINGBUFFER CBaseSAPI::AppendText(PSTRINGBUFFER buffer, LPTSTR pszText)
{
    PSTRINGBUFFER pResult=buffer;
    if(buffer==NULL)
    {
        pResult=new STRINGBUFFER;
        pResult->size=512;
        pResult->pszString = new TCHAR[pResult->size];
        pResult->pszStringEnd = pResult->pszString;
        pResult->used = 0;
    }

    if(pszText)
    {
        UINT cbNewText=lstrlen(pszText);
        // Make sure we the space
        if( pResult->size < pResult->used + cbNewText + 4 )
        {
            LPTSTR pszNewBuffer=new TCHAR[pResult->size * 2];
            CopyMemory( pszNewBuffer, pResult->pszString, pResult->size * sizeof(TCHAR) );
            delete pResult->pszString;
            pResult->pszString = pszNewBuffer;
            pResult->size*=2;
            pResult->pszStringEnd = (pResult->pszString)+pResult->used;
        }
        // append the string.
        CopyMemory( pResult->pszStringEnd, pszText, cbNewText*sizeof(TCHAR));
        pResult->used +=cbNewText;
        pResult->pszStringEnd = (pResult->pszString)+pResult->used;
        *(pResult->pszStringEnd)=NULL;
    }
    else
    {
        delete pResult->pszString;
        delete pResult;
        pResult=NULL;
    }
    return pResult;
}

////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
//
// Returns a good piece of text to use (the ID, the pControl's Text or our Text);
// don't really like all the alloc'ing and freeing here.
//
LPTSTR CBaseSAPI::GetControlText(IRCMLControl *pControl)
{
    TCHAR id[MAX_PATH];
    LPWSTR pszButtonText;
    get_Attr( L"TEXT", &pszButtonText );
    LPWSTR pszShortButtonText=NULL;
    if(pszButtonText==NULL)
    {
    	pControl->get_Attr( L"TEXT", &pszButtonText );
        pszShortButtonText=FindNiceText(pszButtonText);
        pszButtonText=pszShortButtonText;
    }

    if( pszButtonText == NULL )
    {
        LPWSTR pszID;
        LPWSTR pszControlType;
        pControl->get_Attr(L"ID",&pszID);
        pControl->get_StringType( &pszControlType );
        wsprintf(id,TEXT("Control [%s] %s"),pszControlType, pszID);
        pszButtonText = id;
    }

    if( pszButtonText )
    {
        LPTSTR pszText=new TCHAR[lstrlen(pszButtonText)+1];
        lstrcpy(pszText, pszButtonText );
        if(pszShortButtonText)
            delete pszShortButtonText;
        return pszText;
    }

    return NULL;
}

//
// We keep a property on the RCML root node pointing to the context
//
HRESULT CBaseSAPI::GetRecoContext()
{
    if( g_cpEngine == NULL )
        return E_FAIL;

    HRESULT hr=S_OK;

    // get the FORM node - we add information here.
    IRCMLNode * pForm;
    DetachParent(&pForm);
    BOOL bFound=FALSE;
    do
    {
        if( SUCCEEDED( hr=pForm->DetachParent( &pForm )))
        {
            bFound=SUCCEEDED(pForm->IsType( TEXT("FORM" )));
        }
    } while( (bFound== FALSE) && pForm );

    if(pForm == NULL )
        return E_FAIL;

    LPWSTR pszType;
    pForm->get_StringType(&pszType);
    //
    // BUGBUG - this is VERY bad.
    // add a VT_VARIANT property mechanism for containers.
    //
    BOOL bGot=FALSE;

#ifdef _ONE_CONTEXT
    // We do this ONLY ONCE per dialog.
    LPWSTR pszContext;
    if( SUCCEEDED( pForm->get_Attr( TEXT("SAPI:CONTEXT"), &pszContext )))
    {
        ISpRecoContext *pContext=(ISpRecoContext *)StringToIntDef( pszContext, 0 );
        if( pContext )
        {
            m_cpRecoCtxt=pContext;
            bGot=TRUE;
        }
    }
#endif

    if( bGot == FALSE )
    {
        if( SUCCEEDED( hr=g_cpEngine->CreateRecoContext( &m_cpRecoCtxt.p ) ))
        {
            // REVIEW - BIG BIG HACK!
            TCHAR szNumString[128];
            wsprintf( szNumString, TEXT("%d"), m_cpRecoCtxt );
            pForm->put_Attr( TEXT("SAPI:CONTEXT"), szNumString);
            // end hack.
            if( SUCCEEDED(hr = m_cpRecoCtxt->SetNotifySink( this )))   // This add ref's US.
            {
	            // Tell SR what types of events interest us.  Here we only care about command
                // recognition.
                const ULONGLONG ullInterest = 
                              // SPFEI(SPEI_SOUND_START) | SPFEI(SPEI_SOUND_END) |
                              // SPFEI(SPEI_PHRASE_START) | 
                              SPFEI(SPEI_RECOGNITION) |
                              // SPFEI(SPEI_FALSE_RECOGNITION) |
                              // SPFEI(SPEI_HYPOTHESIS) |
                              // SPFEI(SPEI_INTERFERENCE) |
                              // SPFEI(SPEI_REQUEST_UI) | SPFEI(SPEI_RECO_STATE_CHANGE) |
                              // SPFEI(SPEI_PROPERTY_NUM_CHANGE) | SPFEI(SPEI_PROPERTY_STRING_CHANGE)
                              0;
                hr = m_cpRecoCtxt->SetInterest(ullInterest, ullInterest);
            }
        }
    }
    return hr;
}

//
// Called for ALL RULES (as we only have one context)
//
HRESULT STDMETHODCALLTYPE CBaseSAPI::Notify( void)
{ 
#ifdef _ONE_CONTEXT
    // work out which rule caused this thing to fire.
    CSpEvent event;

    if (m_cpRecoCtxt)
    {
        while (event.GetFrom(m_cpRecoCtxt) == S_OK)
        {
            switch (event.eEventId)
            {
				case SPEI_RECOGNITION:
                    {
                        ISpRecoResult * pResult = event.RecoResult();
                        {
                            CBaseSAPI * pBase;
                            if( SUCCEEDED( pResult->GetGrammarId((ULONG*)&pBase)))
                            {
                                ISpPhrase * pPhrase = event.RecoResult();
                                pBase->ExecuteCommand(pPhrase);
                            }
                        }
                    }
					break;
                case SPEI_INTERFERENCE:
                    {
                        g_Notifications.SetText(L"I can't quite hear you");
                    }
                    break;
                case SPEI_FALSE_RECOGNITION:
                    {
                        g_Notifications.SetText(L"I mis-understood you");
                    }
                    break;
			}
		}
	}
#else
    Callback(); 
#endif
    return S_OK; 
}

BOOL CBaseSAPI::NeedsTip()
{
    LPWSTR pszTip;
    if( SUCCEEDED( get_Attr(L"TOOLTIP", &pszTip )))
        return FALSE;
    return TRUE;
}

void CBaseSAPI::LoadNumberGrammar(LPCWSTR pszFile)
{
    // load a specific grammar.
    if( pszFile == NULL )
        pszFile = L"c:\\cicerorcml\\numbers.xml";

    HRESULT hr;
    if( SUCCEEDED( hr = GetRecoContext() ))
    {
        // we use the 'shared' context here.
        if( SUCCEEDED( hr = m_cpRecoCtxt->CreateGrammar( (DWORD)this, &m_cpNumberGrammar) ))
        {
            if( SUCCEEDED( hr = m_cpNumberGrammar->LoadCmdFromFile( pszFile, SPLO_STATIC ) ))  // is TRUE needed?
            {
                m_cpNumberGrammar->SetRuleState(
                NULL, 
                NULL, 
                SPRS_ACTIVE);
            }
        }
    }

}

BOOL CBaseSAPI::GetVoice()
{
    if( g_cpVoice )
        return TRUE;

  	if( SUCCEEDED( g_cpVoice.CoCreateInstance( CLSID_SpVoice ) ))
	{
        return TRUE;
	}
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\appsvcs\wmi.cpp ===
// WMI.cpp: implementation of the CWMI class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "WMI.h"
#include "objbase.h"    // CoSetProxyBlanket _WIN32_DCOM

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

//
// http://wmi
//
IWbemServices * CWMI::g_pICIMV2WbemServices;
BOOL            CWMI::g_bInited;
IWbemLocator     * CWMI::g_pIWbemLocator = NULL;
_StringMap<IWbemClassObject> CWMI::g_ClassObjects;

#define TIMEOUT -1

CWMI::CWMI()
: m_pIWbemServices(NULL)
{
    m_StringType=L"DWIN32:WMI"; 
    HRESULT hres = S_OK;

    if( g_bInited==FALSE )
    {
	    hres = CoInitializeSecurity
		    (NULL, -1, NULL, NULL, 
		    RPC_C_AUTHN_LEVEL_NONE, 
		    RPC_C_IMP_LEVEL_IMPERSONATE, 
		    NULL, 0, 0);
        g_bInited=TRUE;
    }

    if( g_pIWbemLocator == NULL )
    {
	    if(hres = CoCreateInstance(CLSID_WbemLocator,
		    NULL,
		    CLSCTX_INPROC_SERVER,
		    IID_IWbemLocator,
		    (LPVOID *) &g_pIWbemLocator) == S_OK)
        {
    	    BSTR pNamespace = SysAllocString( TEXT("\\\\.\\root\\cimv2") ); 

		    if(g_pIWbemLocator->ConnectServer(pNamespace,
								    NULL,   //using current account for simplicity
								    NULL,	//using current password for simplicity
								    0L,		// locale
								    0L,		// securityFlags
								    NULL,	// authority (domain for NTLM)
								    NULL,	// context
								    &g_pICIMV2WbemServices) == S_OK) 
            {
		        // Switch the security level to IMPERSONATE so that provider(s)
		        // will grant access to system-level objects, and so that
		        // CALL authorization will be used.
		        CoSetProxyBlanket(g_pICIMV2WbemServices,	// proxy
			        RPC_C_AUTHN_WINNT,				// authentication service
			        RPC_C_AUTHZ_NONE, 				// authorization service
			        NULL,							// server principle name
			        RPC_C_AUTHN_LEVEL_CALL,			// authentication level
			        RPC_C_IMP_LEVEL_IMPERSONATE,	// impersonation level
			        NULL,							// identity of the client
			        EOAC_NONE);						// capability flags
            }

            // We keep the WbemLocator around incase other nodes need it?
            SysFreeString( pNamespace );
        }
    }
    else
    {
        DWORD count=   g_pIWbemLocator->AddRef();
        int i=5;
    }
}

CWMI::~CWMI()
{
    if( m_pIWbemServices )
    {
        DWORD count = m_pIWbemServices->Release();
        m_pIWbemServices=NULL;
    }

    if( g_pIWbemLocator )
    {
        DWORD count = g_pIWbemLocator->Release();
        if( count == 0 )
            g_pIWbemLocator=NULL;
    }
}

HRESULT STDMETHODCALLTYPE CWMI::InitNode( 
    IRCMLNode __RPC_FAR *pParent)
{

	// If already connected, release m_pIWbemServices.
	// if (m_pIWbemServices)
    //    m_pIWbemServices->Release();

    //
    // Pick which namespace to use, if we use the default, addref the I default we keep.
    //
	// Using the locator, connect to CIMOM in the given namespace.
    LPCTSTR pszNameSpace=Get(TEXT("NAMESPACE"));
    if(pszNameSpace)
    {
	    BSTR pNamespace = SysAllocString( pszNameSpace ); 

	    if(g_pIWbemLocator->ConnectServer(pNamespace,
							    NULL,   //using current account for simplicity
							    NULL,	//using current password for simplicity
							    0L,		// locale
							    0L,		// securityFlags
							    NULL,	// authority (domain for NTLM)
							    NULL,	// context
							    &m_pIWbemServices) == S_OK) 
	    {	
		    // Switch the security level to IMPERSONATE so that provider(s)
		    // will grant access to system-level objects, and so that
		    // CALL authorization will be used.
		    CoSetProxyBlanket(m_pIWbemServices,	// proxy
			    RPC_C_AUTHN_WINNT,				// authentication service
			    RPC_C_AUTHZ_NONE, 				// authorization service
			    NULL,							// server principle name
			    RPC_C_AUTHN_LEVEL_CALL,			// authentication level
			    RPC_C_IMP_LEVEL_IMPERSONATE,	// impersonation level
			    NULL,							// identity of the client
			    EOAC_NONE);						// capability flags
					       
	    }

	    // Done with pNamespace.
	    SysFreeString(pNamespace);
    }
    else
    {
        //
        // Take a copy of the global Serives.
        //
        DWORD count=g_pICIMV2WbemServices->AddRef();
        m_pIWbemServices=g_pICIMV2WbemServices;
    }

    if( m_pIWbemServices )
    {
        // Looks like you enumerate for Instances, Get returns something else.
	    BSTR className = SysAllocString(Get(TEXT("OBJECT")));
        HRESULT hRes=S_OK;
        IWbemClassObject * pObject=FindObject( className );
        if( pObject )
        {
            BSTR propName = SysAllocString(Get(TEXT("PROPERTY")));
            VARIANT v={0};
            hRes = pObject->Get( propName, 0, &v, NULL, NULL );
            if( SUCCEEDED(hRes) )
            {
                if( SUCCEEDED( VariantChangeType( &v, &v, 0, VT_BSTR ) ) )
                    pParent->put_Attr(L"TEXT", v.bstrVal );

                VariantClear(&v);
            }
	        SysFreeString(propName);
        }
	    SysFreeString(className);
    }
    return S_OK;
}

IWbemClassObject * CWMI::FindObject( BSTR className )
{
    HRESULT hRes=S_OK;

    IWbemClassObject * pObj= g_ClassObjects.Get( className );
    if( pObj )
        return pObj;

    IEnumWbemClassObject * pEnumInstances=NULL;
    if ((hRes = m_pIWbemServices->CreateInstanceEnum(className,
                                                WBEM_FLAG_SHALLOW,
                                                NULL,
                                                &pEnumInstances)) == S_OK)
    {
        IWbemClassObject * pObject=0;
        DWORD uReturned;

        if(hRes = pEnumInstances->Next(TIMEOUT,
                                    1,
                                    &pObject,
                                    &uReturned) == S_OK)
        {
            if( uReturned==1 )
            {
                g_ClassObjects.Set( className, pObject );
                pEnumInstances->Release();
                return pObject; // still has a ref of 1.
            }
            // we bail if it's an enumeration.
        }
        pEnumInstances->Release();
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\date.h ===
// RCMLPersist.h: interface for the RCMLPersist class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DATE_H__50697F94_22C1_425A_BA70_A9EBDDC298C0__INCLUDED_)
#define AFX_DATE_H__50697F94_22C1_425A_BA70_A9EBDDC298C0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "appservices.h"
class CXMLDate : public CAppServices
{
public:
    CXMLDate() { m_StringType=L"CICERO:DATE"; }
    virtual ~ CXMLDate() {};
    NEWNODE( Date );

    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InitNode( 
        IRCMLNode __RPC_FAR *parent);
    
    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExitNode( 
        IRCMLNode __RPC_FAR *parent, LONG lDialogResult);

};

#endif // !defined(AFX_DATE_H__50697F94_22C1_425A_BA70_A9EBDDC298C0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\basesapi.h ===
// BaseSAPI.h: interface for the CBaseSAPI class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_BASESAPI_H__24A1B8CC_6860_4311_92E6_CE5397D11661__INCLUDED_)
#define AFX_BASESAPI_H__24A1B8CC_6860_4311_92E6_CE5397D11661__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000



#include "appservices.h"
#include "xmlfailure.h"
#include "sphelper.h"

#include "xmlsynonym.h"
#include "list.h"

#include "tunaclient.h"

// #define _WITH_DICTATION
// #define _ONE_CONTEXT

typedef struct _tagStringBuffer
{
    UINT    size;           // in chars
    UINT    used;           // in chars
    LPTSTR  pszString;      // start of the string
    LPTSTR  pszStringEnd;   // points to the NULL in the string, so cat'ing is fast
} STRINGBUFFER, * PSTRINGBUFFER;

class CBaseSAPI  : public CAppServices, public ISpNotifySink
{
public:
	void LoadNumberGrammar( LPCWSTR pszFile=NULL );
	LPTSTR GetControlText( IRCMLControl *pControl );
	PSTRINGBUFFER AppendText( PSTRINGBUFFER buffer, LPTSTR pszText);
	CBaseSAPI();
	virtual ~CBaseSAPI();
    typedef CAppServices BASECLASS;

    HRESULT InitSAPI( void );
    void ResetGrammar( void );
    void ProcessRecoEvent( void );

	// IRCMLNode methods Children.
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptChild( 
            IRCMLNode __RPC_FAR *pChild);

    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExitNode( 
        IRCMLNode __RPC_FAR *parent, LONG lDialogResult);

    //
    // Sit on the set to check for us being disabled
    //
    virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Attr( 
        LPCWSTR index,
        /* [in] */ LPCWSTR newVal)
    {
        if( lstrcmpi( index, L"ENABLED")==0)
        {
            if( lstrcmpi( newVal, L"NO") == 0 )
                SetRuleState(FALSE);
            else if( lstrcmpi( newVal, L"YES") == 0 )
                SetRuleState(TRUE);
        }
        return BASECLASS::put_Attr(index, newVal);
    }

    //
    // ISpNotifySink method
    //
    virtual HRESULT STDMETHODCALLTYPE Notify( void) ;
    virtual HRESULT ExecuteCommand( ISpPhrase *pPhrase )=0;

    //
    // I unknown goo
    //
    virtual ULONG STDMETHODCALLTYPE AddRef( void)
    { return BASECLASS::AddRef(); }

    virtual ULONG STDMETHODCALLTYPE Release( void)
    { return BASECLASS::Release(); }

    // 2 interfaces only, ISpNotifySink and IRCMLNode 
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void ** ppvObject) 
    {   if (riid == IID_IUnknown) 
            *ppvObject = static_cast<IUnknown*>((ISpNotifySink*)this);  
        else if (riid == __uuidof(IRCMLNode))           
            *ppvObject = static_cast<IRCMLNode*>(this); 
        else if (riid == __uuidof(ISpNotifySink))           
            *ppvObject = static_cast<ISpNotifySink*>(this); 
        else 
        {
            *ppvObject = NULL; return E_NOINTERFACE; 
        }
        reinterpret_cast<IUnknown*>(*ppvObject)->AddRef(); 
        return S_OK; 
    }

	void SayFailure();
	void SaySuccess();

protected:
	BOOL NeedsTip();
	HRESULT GetRecoContext();
	BOOL IsEnabled(HWND hWnd);
	LPWSTR GetRecognizedRule( ISpPhrase * pPhrase );

    BOOL    GetVoice();
    static CComPtr<ISpVoice>               g_cpVoice;

	LPWSTR GetRecognizedText(ISpPhrase *pPhrase);
	LPWSTR FindNiceText(LPCWSTR text);
	CComPtr<IRCMLNode>		m_cpFailure;
	CComPtr<IRCMLNode>		m_cpSuccess;

	// just one Engine.
	static CComPtr<ISpRecoInstance>		g_cpEngine;				// Pointer to reco engine interface

    // REVIEW - try to get only one Context per dialog
    CComPtr<ISpRecoContext>         m_cpRecoCtxt;			// Pointer to reco context interface

    // Currently we have one grammar per context, which is expensive.
    CComPtr<ISpRecoGrammar>         m_cpCmdGrammar;			// Pointer to grammar interface
    CComPtr<ISpRecoGrammar>         m_cpNumberGrammar;

	BOOL	m_bActive;
	static	LONG	m_bInited;

    virtual void Callback() {}; // calls ExecuteCommand on derived classes

	virtual BOOL SetControlText( LPCWSTR dstrText );

	HRESULT LoadCFG( LPCTSTR pszFileName  );
    HRESULT LoadCFGFromString( LPCTSTR pszCFG, LPCTSTR prefix=NULL );

    _RefcountList<CXMLSynonym>  m_Synonyms;

    HRESULT SetRuleState(BOOL bOnOff);

    // notifications
    static CTunaClient g_Notifications;
};

#endif // !defined(AFX_BASESAPI_H__24A1B8CC_6860_4311_92E6_CE5397D11661__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\date.cpp ===
// RCMLPersist.cpp: implementation of the RCMLPersist class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "date.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


//
// this is the persitance NODE in the DWIN32 namespace.
//
HRESULT STDMETHODCALLTYPE CXMLDate::InitNode( 
    IRCMLNode __RPC_FAR *pParent)
{
    if( SUCCEEDED(pParent->IsType(L"EDIT") ))
    {
        LPCTSTR pszApplicationName=Get(TEXT("APPNAME"));
        LPCTSTR pszKeyName=Get(TEXT("KEYNAME"));
        BOOL bSet=FALSE;
        if( pszApplicationName && pszKeyName )
        {
            HKEY hkSoftware;
            if( RegOpenKey( HKEY_CURRENT_USER, TEXT("Software"), &hkSoftware ) == ERROR_SUCCESS )
            {
                HKEY hkApplication;
                if( RegOpenKey( hkSoftware, pszApplicationName, &hkApplication) == ERROR_SUCCESS )
                {
                    DWORD dwSize;
                    DWORD dwType=REG_SZ;
                    if( RegQueryValueEx( hkApplication, pszKeyName, NULL, &dwType, NULL, &dwSize ) == ERROR_SUCCESS )
                    {
                        LPTSTR pszData=new TCHAR[dwSize];
                        if( RegQueryValueEx( hkApplication, pszKeyName, NULL, &dwType, (LPBYTE)pszData, &dwSize ) == ERROR_SUCCESS )
                        {
                            pParent->put_Attr( L"TEXT", pszData );
                            delete pszData ;
                            bSet=TRUE;
                        }
                    }
                    RegCloseKey(hkApplication);
                }
                RegCloseKey(hkSoftware);
            }
        }
        if(bSet==FALSE)
            pParent->put_Attr(L"TEXT", Get(L"TEXT") );
    }
    return S_OK;
}

//
// this is the persitance NODE in the DWIN32 namespace.
// should only really be called if the user clicks OK, rather than cancel??
//
HRESULT STDMETHODCALLTYPE CXMLDate::ExitNode( 
    IRCMLNode __RPC_FAR *pParent, LONG lDialogResult)
{
    if(lDialogResult != IDOK )
        return S_OK;

    if(SUCCEEDED( pParent->IsType(L"EDIT")))
    {
        LPCTSTR pszApplicationName=Get(TEXT("APPNAME"));
        LPCTSTR pszKeyName=Get(TEXT("KEYNAME"));
        if( pszApplicationName && pszKeyName )
        {
            HKEY hkSoftware;
            if( RegOpenKey( HKEY_CURRENT_USER, TEXT("Software"), &hkSoftware ) == ERROR_SUCCESS )
            {
                HKEY hkApplication;
                if( RegCreateKey( hkSoftware, pszApplicationName, &hkApplication) == ERROR_SUCCESS )
                {
                    IRCMLControl * pControl;
                    if(SUCCEEDED( pParent->QueryInterface( __uuidof( IRCMLControl ), (LPVOID*)&pControl)))
                    {
                        HWND hWnd;
                        if( SUCCEEDED( pControl->get_Window(&hWnd) ))
                        {
                            LPTSTR szString=NULL;
                            DWORD cbNeeded = GetWindowTextLength( hWnd )+1;
                            szString = new TCHAR[cbNeeded];
                            GetWindowText( hWnd, szString, cbNeeded );
                            RegSetValueEx( hkApplication, pszKeyName, NULL, REG_SZ, (LPBYTE) szString, cbNeeded*sizeof(TCHAR) );
                        }
                        pControl->Release();
                    }
                    RegCloseKey(hkApplication);
                }
                RegCloseKey(hkSoftware);
            }
        }
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\list.cpp ===
//
// CDPA - array of pointers that grows.
//
// FelixA
//

#include "stdafx.h"
#include "list.h"
#ifndef _DEBUG
#define _MEM_DEBUG 1
#endif

#ifdef _MEM_DEBUG
int g_HeapAllocCount=0;
#endif

#ifdef USEHEAP
/////////////////////////////////////////////////////////////////////////////
// HEAP VERSION HEAP VERSION HEAP VERSION HEAP VERSION HEAP VERSION HEAP VERSION 
//
CDPA::CDPA()
: m_iAllocated(0),
  m_iCurrentTop(0),
  m_pData(NULL),
  m_Heap(NULL)	//Allocate from global heap.
{
}

CDPA::~CDPA()
{
	LPVOID lpV;
	int i=0;
	while( lpV=GetPointer(i++) )
		delete lpV;

	DeleteHeap();
}

void CDPA::DeleteHeap()
{
	if(GetData())
	{
		HeapFree(GetHeap(), 0, GetData());
		HeapDestroy(GetHeap() );
	}
	SetData(NULL);
	SetAllocated(0);
}

/////////////////////////////////////////////////////////////////////////////
//
// Inserts at the end - no mechanism for inserting in the middle.
// Grows the Heap if you add more items than currently have spave for
//

BOOL CDPA::Append(LPVOID lpData)
{
	if(GetNextFree()==GetAllocated())
	{
		int iNewSize = GetAllocated()*2;
        if(iNewSize==0)
            iNewSize=16;
        void FAR * FAR * ppNew;

		if(GetData())
            ppNew = (void FAR * FAR *)HeapReAlloc(GetHeap(), HEAP_ZERO_MEMORY, GetData(), iNewSize * sizeof(LPVOID));
		else
		{
			if(!GetHeap())
            {
				SetHeap(HeapCreate(0, iNewSize*sizeof(LPVOID),0)); // 1/4K heaps, not 16K heaps.
#ifdef _MEM_DEBUG
                g_HeapAllocCount++;
#endif
            }
            ppNew = (void FAR * FAR *)HeapAlloc(GetHeap(), HEAP_ZERO_MEMORY, iNewSize * sizeof(LPVOID));
		}

		if(ppNew)
		{
			SetData(ppNew);
			SetAllocated(iNewSize);
		}
		else
			return FALSE;
	}

	*(GetData()+GetNextFree())=lpData;
	SetNextFree(GetNextFree()+1);
	return TRUE;
}

#else
/////////////////////////////////////////////////////////////////////////////
//
//
CDPA::CDPA()
: m_iAllocated(0),
  m_iCurrentTop(0),
  m_pData(NULL)
{
}

CDPA::~CDPA()
{
	LPVOID lpV;
	int i=0;
	while( lpV=GetPointer(i++) )
		delete lpV;

	DeleteHeap();
}

void CDPA::DeleteHeap()
{
    delete m_pData;
    m_pData=NULL;
	m_iAllocated=0;
}

/////////////////////////////////////////////////////////////////////////////
//
// Inserts at the end - no mechanism for inserting in the middle.
// Grows the Heap if you add more items than currently have spave for
//


BOOL CDPA::Append(LPVOID lpData)
{
	if(GetNextFree()==GetAllocated())
	{
		int iNewSize = GetAllocated()*2;
        if(iNewSize==0)
            iNewSize=8;

        LPVOID * ppNew;

		if( !GetData() )
        {
            ppNew = new LPVOID[ iNewSize * sizeof(LPVOID) ];
        }
        else
        {
            LPVOID * pbOldData=GetData();
            ppNew = new LPVOID[ iNewSize * sizeof(LPVOID) ];
            CopyMemory(ppNew, pbOldData, GetAllocated() * sizeof(LPVOID) );
            delete pbOldData;
        }

		if(ppNew)
		{
			SetData(ppNew);
			SetAllocated(iNewSize);
		}
		else
			return FALSE;
	}

	*(GetData()+GetNextFree())=lpData;
	SetNextFree(GetNextFree()+1);
	return TRUE;
}
#endif

/////////////////////////////////////////////////////////////////////////////
//
// Given the index into the list, returns its value.
//
LPVOID CDPA::GetPointer(int iItem) const
{
	if(GetData())
		if(iItem<GetNextFree())	// mCurrentTop is not active. (zero based index)
			return *(GetData()+iItem);
	return NULL;
}

void CDPA::Remove(int iItem) 
{
	if(GetData())
		if(iItem<GetNextFree())	// mCurrentTop is not active.
			*(GetData()+iItem)=NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\list.h ===
//
// CDPA Class.
// Based on DPA's from the shell
//
// FelixA
//
// 98 extended to be a templated class
//

#ifndef __LISTH
#define __LISTH
// #define USEHEAP 1

class CDPA
{
public:
	CDPA();
	~CDPA();

	BOOL	Append(LPVOID);
	LPVOID	GetPointer(int iItem) const;

	void	DeleteHeap();
	int		GetCount() const { return m_iCurrentTop; }
	void	Remove(int iItem);	// sets this pointer to NULL.
private:
	int GetAllocated() const {return m_iAllocated;}
	void SetAllocated(int i) { m_iAllocated=i; }

	int GetNextFree() const { return m_iCurrentTop; }
	void SetNextFree(int i) { m_iCurrentTop=i; }


	int m_iAllocated; // Number of items in the list.
	int m_iCurrentTop;// Next item to use.
#ifdef USEHEAP
	HANDLE GetHeap() const { return m_Heap; }
	void SetHeap( HANDLE h) { m_Heap = h; }

	void FAR * FAR * GetData() const { return m_pData; };
	void SetData(void FAR * FAR * pD) { m_pData=pD; }

	void FAR * FAR * m_pData;	// Pointer to the pointer array.
	HANDLE m_Heap;	// Handle for the heap we're using.
#else
	LPVOID * GetData() const { return m_pData; };
	void SetData(LPVOID * pD) { m_pData=pD; }
    LPVOID *  m_pData;
#endif
};

template <class T> class _List : public CDPA
{
	typedef CDPA BASECLASS;
public:
	_List() : m_bAutoDelete(TRUE) {};
	_List( const _List<T> & list )
	{
		int ic=list.GetCount();
		for(int i=0;i<ic;i++)
		{
			T * pTemp=new T(*list.GetPointer(i));
			Append(pTemp);
		}
	}

	virtual ~_List() 
	{
        Purge();
	};

	T* GetPointer(int it) const { return (T*)BASECLASS::GetPointer(it); }
	BOOL	Append(T* pt) { return BASECLASS::Append((LPVOID)pt); }

	void	SetAutoDelete(BOOL b) { m_bAutoDelete=b;}

    void    Purge()
    {
   		if( m_bAutoDelete )
		{
			T* lpT;
			int i=0;
			int j=GetCount();
			while( lpT=GetPointer(i++) )
				delete lpT;
		}
		DeleteHeap();
    }

protected:
	BOOL m_bAutoDelete;
};

//
// Calls addref and release on the class T
//
template <class T> class _RefcountList : public CDPA
{
	typedef CDPA BASECLASS;
public:
	_RefcountList() : m_bAutoDelete(TRUE) {};

	_RefcountList( const _List<T> & list )
	{
		int ic=list.GetCount();
		for(int i=0;i<ic;i++)
		{
			T * pTemp=new T(*list.GetPointer(i));
			Append(pTemp);
		}
	}

	virtual ~_RefcountList() 
	{
        Purge();
	};

	T* GetPointer(int it) const { return (T*)BASECLASS::GetPointer(it); }   // doesn't addref.
	BOOL	Append(T* pt) { pt->AddRef(); return BASECLASS::Append((LPVOID)pt); }

	void	SetAutoDelete(BOOL b) { m_bAutoDelete=b;}

    void    Purge()
    {
   		if( m_bAutoDelete )
		{
			T* lpT;
			int i=0;
			int j=GetCount();
			while( lpT=GetPointer(i++) )
                lpT->Release();
		}
		DeleteHeap();
    }

protected:
	BOOL m_bAutoDelete;
};

template <class T> class _ListIterator
{
public:
	_ListIterator(_List<T> &list) : m_list(list), currentIndex(0) { }
	T* GetNext()	{ return m_list.GetPointer(currentIndex++);	}
	_List<T> & GetList()	{ return m_list;	}

protected:
	_List<T> & m_list;
	int currentIndex;	// current index in the list
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\externalcfg.h ===
// RCMLPersist.h: interface for the RCMLPersist class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_EXTERNAL_H__50697F94_22C1_425A_BA70_A9EBDDC298C0__INCLUDED_)
#define AFX_EXTERNAL_H__50697F94_22C1_425A_BA70_A9EBDDC298C0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


#include "basesapi.h"
#include <sapi.h>

class CXMLExternal : public CBaseSAPI
{
public:
    CXMLExternal() { m_StringType=L"CICERO:EXTERNAL"; }
    virtual ~ CXMLExternal() {};
    NEWNODE( External );

    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InitNode( 
        IRCMLNode __RPC_FAR *parent);
    
	void Callback();
	virtual HRESULT ExecuteCommand( ISpPhrase *pPhrase );

};

#endif // !defined(AFX_EXTERNAL_H__50697F94_22C1_425A_BA70_A9EBDDC298C0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\externalcfg.cpp ===
// RCMLPersist.cpp: implementation of the RCMLPersist class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "externalcfg.h"

#ifdef _OLD_SAPIM2
#define SPDebug_h
#define SPDBG_ASSERT
#endif

#include "sphelper.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

//
// this is the persitance NODE in the DWIN32 namespace.
//
HRESULT STDMETHODCALLTYPE CXMLExternal::InitNode( 
    IRCMLNode __RPC_FAR *pParent)
{
	LPWSTR pszFilename;
	if( SUCCEEDED( get_Attr(L"FILENAME", & pszFilename )))
	{
		return LoadCFG( pszFilename );
	}
    return S_OK;
}

//
//
//
void CXMLExternal::Callback()
{
    CSpEvent event;

    if (m_cpRecoCtxt)
    {
        while (event.GetFrom(m_cpRecoCtxt) == S_OK)
        {
            switch (event.eEventId)
            {
				case SPEI_RECOGNITION:
					ExecuteCommand(event.RecoResult());
					break;
			}
		}
	}
}

HRESULT CXMLExternal::ExecuteCommand( ISpPhrase *pPhrase )
{
	HRESULT hr=S_OK;

    LPWSTR pszRecoText=GetRecognizedText( pPhrase );
    if( pszRecoText )
    {
		if( SetControlText( pszRecoText) == FALSE )
            hr=E_FAIL;
	}
    delete pszRecoText;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\elements.h ===
//
// include the .H's from your element implementations here.
//
#include "APPSERVICES.h"
#include "date.h"
#include "externalcfg.h"
#include "value.h"
#include "xmlvoicecmd.h"
#include "xmlsynonym.h"
#include "xmlcommand.h"

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
//

class CDWin32NameSpaceLoader
{
public:
    CDWin32NameSpaceLoader();

    typedef IRCMLNode * (*CLSPFN)();

    typedef struct _XMLELEMENT_CONSTRUCTOR
    {
	    LPCTSTR	pwszElement;		// the element
	    CLSPFN	pFunc;				// the function to call.
    }XMLELEMENT_CONSTRUCTOR, * PXMLELEMENT_CONSTRUCTOR;

    static IRCMLNode * CreateElement( LPCWSTR pszText );
private:
};

CDWin32NameSpaceLoader::XMLELEMENT_CONSTRUCTOR g_DWin32[]=
{
	XMLNODE( TEXT("VALUE"), Value ),
	XMLNODE( TEXT("DATE"), Date ),
	XMLNODE( TEXT("CFG"), External ),
		XMLNODE( TEXT("FAILURE"), Failure ),
		XMLNODE( TEXT("SUCCESS"), Success ),

	XMLNODE( TEXT("CMD"), VoiceCmd ),
		XMLNODE( TEXT("SYNONYM"), Synonym ),

   	XMLNODE( TEXT("COMMANDING"), Commanding ),
		XMLNODE( TEXT("COMMAND"), Command ),

	//
	// End.
	//
	{ NULL, NULL} 
};

//
// Called by the external entry point to create a node for this name space.
//
IRCMLNode * CDWin32NameSpaceLoader::CreateElement( LPCWSTR pszElement )
{
	PXMLELEMENT_CONSTRUCTOR pEC=g_DWin32;
	while( pEC->pwszElement )
	{
		if( lstrcmpi( pszElement , pEC->pwszElement) == 0 )
		{
			CLSPFN pFunc=pEC->pFunc;
            return pFunc();
		}
		pEC++;
	}
    return NULL;
}

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

	//
    // This is the thing that we export.
	// there is ONE export per namespace
	// the assumption here is that there is ONE DLL per namespace too.
	//
    APPSERVICES_API IRCMLNode * WINAPI CreateElement( LPCWSTR pszText )
    {
        return CDWin32NameSpaceLoader::CreateElement( pszText );
    }

#ifdef __cplusplus
}            /* Assume C declarations for C++ */
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\filestream.h ===
#ifndef _FILESTREAM_HXX
#define _FILESTREAM_HXX

#include <stdio.h>
#include "unknown.h"

class _FileStream : public _simpleunknown<IStream>
{
public:
	_FileStream() 
	{ 
        hFile = NULL;
        read = true;
        AddRef();
	}

	~_FileStream() 
	{ 
		::CloseHandle(hFile);
	}

    bool open(LPTSTR name, bool read = true)
    {
        this->read = read;
        
        if (read)
        {
		    hFile = ::CreateFile( 
                name,
			    GENERIC_READ,
			    FILE_SHARE_READ,
			    NULL,
			    OPEN_EXISTING,
			    FILE_ATTRIBUTE_NORMAL,
			    NULL);
        }
        else
        {
		    hFile = ::CreateFile(
			    name,
			    GENERIC_WRITE,
			    FILE_SHARE_READ,
			    NULL,
			    CREATE_ALWAYS,
			    FILE_ATTRIBUTE_NORMAL,
			    NULL);
        }
        return (hFile == INVALID_HANDLE_VALUE) ? false : true;
    }

    virtual /* [local] */ HRESULT STDMETHODCALLTYPE Read( 
        /* [out] */ void __RPC_FAR *pv,
        /* [in] */ ULONG cb,
        /* [out] */ ULONG __RPC_FAR *pcbRead)
	{	
        if (!read) return E_FAIL;

        DWORD len;
		BOOL rc = ReadFile(
			hFile,	// handle of file to read 
			pv,	// address of buffer that receives data  
			cb,	// number of bytes to read 
			&len,	// address of number of bytes read 
			NULL 	// address of structure for data 
		   );
        if (pcbRead)
            *pcbRead = len;
		return (rc) ? S_OK : E_FAIL;
	}
    
    virtual /* [local] */ HRESULT STDMETHODCALLTYPE Write( 
        /* [size_is][in] */ const void __RPC_FAR *pv,
        /* [in] */ ULONG cb,
        /* [out] */ ULONG __RPC_FAR *pcbWritten)
	{
        if (read) return E_FAIL;

		BOOL rc = WriteFile(
			hFile,	// handle of file to write 
			pv,	// address of buffer that contains data  
			cb,	// number of bytes to write 
			pcbWritten,	// address of number of bytes written 
			NULL 	// address of structure for overlapped I/O  
		   );

		return (rc) ? S_OK : E_FAIL;
	}

    virtual /* [local] */ HRESULT STDMETHODCALLTYPE Seek( 
        /* [in] */ LARGE_INTEGER dlibMove,
        /* [in] */ DWORD dwOrigin,
        /* [out] */ ULARGE_INTEGER __RPC_FAR *plibNewPosition) { return E_FAIL; }
    
    virtual HRESULT STDMETHODCALLTYPE SetSize( 
        /* [in] */ ULARGE_INTEGER libNewSize) { return E_FAIL; }
    
    virtual /* [local] */ HRESULT STDMETHODCALLTYPE CopyTo( 
        /* [unique][in] */ IStream __RPC_FAR *pstm,
        /* [in] */ ULARGE_INTEGER cb,
        /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbRead,
        /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbWritten) { return E_FAIL; }
    
    virtual HRESULT STDMETHODCALLTYPE Commit( 
        /* [in] */ DWORD grfCommitFlags) { return E_FAIL; }
    
    virtual HRESULT STDMETHODCALLTYPE Revert( void) { return E_FAIL; }
    
    virtual HRESULT STDMETHODCALLTYPE LockRegion( 
        /* [in] */ ULARGE_INTEGER libOffset,
        /* [in] */ ULARGE_INTEGER cb,
        /* [in] */ DWORD dwLockType) { return E_FAIL; }
    
    virtual HRESULT STDMETHODCALLTYPE UnlockRegion( 
        /* [in] */ ULARGE_INTEGER libOffset,
        /* [in] */ ULARGE_INTEGER cb,
        /* [in] */ DWORD dwLockType) { return E_FAIL; }
    
    virtual HRESULT STDMETHODCALLTYPE Stat( 
        /* [out] */ STATSTG __RPC_FAR *pstatstg,
        /* [in] */ DWORD grfStatFlag) { return E_FAIL; }
    
    virtual HRESULT STDMETHODCALLTYPE Clone( 
        /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm) { return E_FAIL; }
private:
	HANDLE hFile;
    bool read;
};


class _MemoryStream : public _simpleunknown <IStream>
{
public:
	_MemoryStream(LPBYTE pData, DWORD dwSize) 
	{ 
        m_pBase=pData;
        m_pData=m_pBase;
        m_dwSize=dwSize;
        m_dwLoc=0;
        read = true;
        AddRef();
	}

	~_MemoryStream() 
	{ 

	}

    bool open(LPTSTR name, bool read = true)
    {
        return FALSE;
    }

    virtual /* [local] */ HRESULT STDMETHODCALLTYPE Read( 
        /* [out] */ void __RPC_FAR *pv,
        /* [in] */ ULONG cb,
        /* [out] */ ULONG __RPC_FAR *pcbRead)
	{	
        if (!read) return E_FAIL;

#ifdef _VERY_DEBUG
        TCHAR szText[1024];
        wsprintf(szText,TEXT("Reading %d bytes, we have %d"), cb, m_dwSize-m_dwLoc);
        MessageBox(NULL, szText, TEXT("Reading"), MB_OK);
#endif
        if( m_dwLoc == m_dwSize ) 
            return S_FALSE ;

        ULONG free=m_dwSize-m_dwLoc;
        if( cb > free )
            cb = free;
        *pcbRead=cb;
        CopyMemory( pv, m_pData, cb );
        m_pData+=cb;
        m_dwLoc+=cb;
        return S_OK;
	}
    
    virtual /* [local] */ HRESULT STDMETHODCALLTYPE Write( 
        /* [size_is][in] */ const void __RPC_FAR *pv,
        /* [in] */ ULONG cb,
        /* [out] */ ULONG __RPC_FAR *pcbWritten)
	{
        if (read) return E_FAIL;

        return E_NOTIMPL;
	}

    virtual /* [local] */ HRESULT STDMETHODCALLTYPE Seek( 
        /* [in] */ LARGE_INTEGER dlibMove,
        /* [in] */ DWORD dwOrigin,
        /* [out] */ ULARGE_INTEGER __RPC_FAR *plibNewPosition) { return E_FAIL; }
    
    virtual HRESULT STDMETHODCALLTYPE SetSize( 
        /* [in] */ ULARGE_INTEGER libNewSize) { return E_FAIL; }
    
    virtual /* [local] */ HRESULT STDMETHODCALLTYPE CopyTo( 
        /* [unique][in] */ IStream __RPC_FAR *pstm,
        /* [in] */ ULARGE_INTEGER cb,
        /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbRead,
        /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbWritten) { return E_FAIL; }
    
    virtual HRESULT STDMETHODCALLTYPE Commit( 
        /* [in] */ DWORD grfCommitFlags) { return E_FAIL; }
    
    virtual HRESULT STDMETHODCALLTYPE Revert( void) { return E_FAIL; }
    
    virtual HRESULT STDMETHODCALLTYPE LockRegion( 
        /* [in] */ ULARGE_INTEGER libOffset,
        /* [in] */ ULARGE_INTEGER cb,
        /* [in] */ DWORD dwLockType) { return E_FAIL; }
    
    virtual HRESULT STDMETHODCALLTYPE UnlockRegion( 
        /* [in] */ ULARGE_INTEGER libOffset,
        /* [in] */ ULARGE_INTEGER cb,
        /* [in] */ DWORD dwLockType) { return E_FAIL; }
    
    virtual HRESULT STDMETHODCALLTYPE Stat( 
        /* [out] */ STATSTG __RPC_FAR *pstatstg,
        /* [in] */ DWORD grfStatFlag) { return E_FAIL; }
    
    virtual HRESULT STDMETHODCALLTYPE Clone( 
        /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm) { return E_FAIL; }
private:
	LPBYTE m_pBase;
    LPBYTE m_pData;
    bool read;
    ULONG   m_dwSize;
    ULONG   m_dwLoc;
};

#endif // _FILESTREAM_HXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	APPSERVICES.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\stringproperty.h ===
// StringProperty.h: interface for the CStringProperty class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_STRINGPROPERTY_H__CE442DDC_8EF3_11D2_84A3_00C04FB177B1__INCLUDED_)
#define AFX_STRINGPROPERTY_H__CE442DDC_8EF3_11D2_84A3_00C04FB177B1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// Maps an LPCTSTR to a UINT (like ATOMS).
class CDictionary
{
public:
	CDictionary();
	virtual ~CDictionary();
	UINT    GetID( LPCTSTR szPropID );
    LPCTSTR GetString( UINT id );

protected:
    void    Purge();

#define DIC_RUN_SIZE 7
#define DIC_TABLE_SIZE 5

typedef struct _LINKDICSTRING
{
    int     cbUsed;
	LPTSTR	pszKey[DIC_RUN_SIZE];
	UINT    ID[DIC_RUN_SIZE];
	_LINKDICSTRING * pNext;
} LINKDICSTRING, * PLINKDICSTRING;

	PLINKDICSTRING	m_Table[DIC_TABLE_SIZE];

	DWORD	Hash(LPCTSTR szPropID, DWORD dwStrLen=0);
    BOOL    Set(LPCTSTR szPropID);
};

//
// There are not that many items on each element, so we put them in a linked list.
// COULD be sorted by UINT.
//
class CStringPropertySection
{
public:
	CStringPropertySection();
	virtual ~CStringPropertySection();
	BOOL	Set( LPCTSTR szPropID, LPCTSTR pValue );
	LPCTSTR	Get( LPCTSTR szPropID );
    DWORD   YesNo( LPCTSTR szPropID, DWORD dwNotPresent, DWORD dwYes=TRUE);
    DWORD   YesNo( LPCTSTR szPropID, DWORD defNotPresent, DWORD dwNo, DWORD dwYes);
    DWORD   ValueOf( LPCTSTR szPropID, DWORD dwDefault);
    static  CDictionary m_Dictionary;

protected:
    void    Purge();

#define RUN_SIZE 5

typedef struct _LINKSTRING
{
	UINT        idKey;
	LPTSTR	    pszValue;
} LINKSTRING, * PLINKSTRING;

    UINT        m_UsedItems;
    UINT        m_ItemSize;
	PLINKSTRING	m_Items;

	BOOL	Find(LPCTSTR szPropID, int * pEntry );
};

//
// Maps a string to a something.
//
template <class T> class _StringMap
{
public:
#define MAP_RUN_SIZE 5
typedef struct _MAPLINKSTRING
{
	UINT        idKey;
	T *         pValue;
} MAPLINKSTRING, * PLINKSTRING;

	_StringMap()
    {
        m_UsedItems=0;  // make this an array and re-alloc it - like the CDPA ! Gosh.
        m_ItemSize=MAP_RUN_SIZE;
        m_Items=new _MAPLINKSTRING[m_ItemSize];
    }

	virtual ~_StringMap() 
	{
        Purge();
        delete m_Items;
        m_Items=NULL;
	};

	T *     Get( LPCTSTR szPropID )
    {
        int iEntry;
	    if( Find( szPropID, &iEntry ) )
		    return m_Items[iEntry].pValue;
	    return NULL;
    }

	BOOL	Set( LPCTSTR szPropID, T * pValue )
    {
        int iEntry;
	    if( Find( szPropID, &iEntry ) == FALSE )
	    {
            if( m_UsedItems == m_ItemSize )
            {
                // re allocate the buffer bigger.
                m_ItemSize*=2;
                PLINKSTRING pNew=new _MAPLINKSTRING[m_ItemSize];
                CopyMemory(pNew, m_Items, sizeof(_MAPLINKSTRING) * m_UsedItems );
                delete m_Items;
                m_Items=pNew;
            }

            iEntry=m_UsedItems++;
            m_Items[iEntry].idKey=CStringPropertySection::m_Dictionary.GetID( szPropID );
	    }
	    else
        {
		    delete m_Items[iEntry].pValue;
        }

        m_Items[iEntry].pValue=pValue;
	    return TRUE;
    }

private:
    _StringMap( const _StringMap<T> & list ) {};

protected:
    void    Purge()
    {
	    for(UINT i=0;i<m_UsedItems;i++)
	    {
            m_Items[i].idKey=0;
		    delete m_Items[i].pValue;
            m_Items[i].pValue=NULL;
	    }
        m_UsedItems=0;
    }


    UINT        m_UsedItems;
    UINT        m_ItemSize;
	PLINKSTRING	m_Items;

    BOOL	Find(LPCTSTR szPropID, int * pEntry )
    {
        UINT uiPropID = CStringPropertySection::m_Dictionary.GetID( szPropID ); // this is the ID for this string.
        for(UINT i=0;i<m_UsedItems;i++)
        {
            if( uiPropID == m_Items[i].idKey )
            {
                *pEntry=i;
                return TRUE;
            }
        }
        *pEntry=0;
	    return FALSE;
    }
};

#endif // !defined(AFX_STRINGPROPERTY_H__CE442DDC_8EF3_11D2_84A3_00C04FB177B1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cfg_resources.rc
//
#define IDR_CFG1                        102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        107
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\unknown.h ===
// copied from ppxml sample

#ifndef _UNKNOWN2_HXX
#define _UNKNOWN2_HXX


template <class implementation, class derivedinterface>
class _simpleobj :  public implementation
{
private:    long _refcount;

public:        
        _simpleobj <implementation, derivedinterface>() 
        { 
            _refcount = 0;
        }

        virtual ~_simpleobj <implementation, derivedinterface>()
        {
        }

        virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void ** ppvObject)
        {
            if (riid == IID_IUnknown)
            {
                *ppvObject = static_cast<IUnknown*>(this);
            }
            else if (riid == __uuidof(derivedinterface))
            {
                *ppvObject = static_cast<derivedinterface*>(this);
            }
            else
            {
                *ppvObject = NULL;
                return E_NOINTERFACE;
            }
            reinterpret_cast<IUnknown*>(*ppvObject)->AddRef();
            return S_OK;
        }
    
        virtual ULONG STDMETHODCALLTYPE AddRef( void)
        {
            return InterlockedIncrement(&_refcount);
        }
    
        virtual ULONG STDMETHODCALLTYPE Release( void)
        {
            if (InterlockedDecrement(&_refcount) == 0)
            {
                delete this;
                return 0;
            }
            return _refcount;
        }
};    

//===========================================================================
// This template implements the IUnknown portion of a given COM interface.

template <class I> class _simpleunknown : public I
{
private:    long _refcount;

public:        
        _simpleunknown <I>() 
        { 
            _refcount = 0;
        }

        virtual ~_simpleunknown <I>()
        {
        }

        virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void ** ppvObject)
        {
            if (riid == IID_IUnknown)
            {
                *ppvObject = static_cast<IUnknown*>(this);
            }
            else if (riid == __uuidof(I))
            {
                *ppvObject = static_cast<I*>(this);
            }
            else
            {
                *ppvObject = NULL;
                return E_NOINTERFACE;
            }
            reinterpret_cast<IUnknown*>(*ppvObject)->AddRef();
            return S_OK;
        }
    
        virtual ULONG STDMETHODCALLTYPE AddRef( void)
        {
            return InterlockedIncrement(&_refcount);
        }
    
        virtual ULONG STDMETHODCALLTYPE Release( void)
        {
            if (InterlockedDecrement(&_refcount) == 0)
            {
                delete this;
                return 0;
            }
            return _refcount;
        }
};    

#endif _UNKNOWN2_HXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\utils.cpp ===
#include "stdafx.h"
#include "utils.h"
#include "tchar.h"

//
// StringToInt - convert the decimal or hex string passed in to an integer
//       A NULL input will return 0
//		 Overflow is not detected, white spaces not allowed
//
// MCostea May 27, 1999
//
//
int StringToIntDef(LPCTSTR psz, int Default)
{
	int retVal = 0;	// current total
	int c;			// current char

	if(psz != NULL)
	{
		int sign = 1;

		c = (int)(TCHAR)*psz++;

		switch(c)
		{
		case __T('-'):
			sign = -1;
			break;
		case __T('+'):
			break;
		case __T('0'):
			{
				c = (int)(TCHAR)*psz++;
				if(c == __T('x'))
					return ReadHexValue(psz);					
				else 
					return 0;
			}
			break;
		default:
			if(c >= __T('0') || c <= __T('9'))
				retVal = c -__T('0');
			else 
				return Default;
		}

		while(c = (int)(TCHAR)*psz++)
		{
			c -= __T('0');
			if( c < 0 || c > 9)
				return 	sign*retVal;
			retVal = retVal*10 + c;
		}
		retVal = sign*retVal;
	}
	return retVal;
}


int ReadHexValue(LPCTSTR psz)
{
	int retVal = 0;	// current total
	int c;			// current char
	int digit;

	while(c = (int)(TCHAR)*psz++)
	{
		if(c >= __T('0') && c <= __T('9'))
			digit = c - __T('0');
		else if( c >= __T('a') && c <= __T('f'))
			digit = c - __T('a') + 10;
		else if( c >= __T('A') && c <= __T('F'))
			digit = c - __T('A') + 10;
		retVal = (retVal << 4) + digit;
	}
	return retVal;
}

void CopyToWideChar( WCHAR** pstrOut, LPCTSTR strIn ) 
{ 
	if(strIn==NULL )
	{
	    **pstrOut = 0; 
        *pstrOut +=1;   // move on, we just put a null down.
		return;
	}
    WCHAR* strOut = *pstrOut; 
    DWORD  dwLen = lstrlen( strIn ); 

#ifdef UNICODE // Copy Unicode to Unicode 
    lstrcpy( strOut, strIn ); 
#else         // Copy Ansi to Unicode 
    dwLen = MultiByteToWideChar( CP_ACP, 0, strIn, dwLen, strOut, dwLen ); 
    strOut[dwLen] = 0; // Add the null terminator 
#endif 
    *pstrOut += dwLen+1; 
} 

/*
 * This function allocates the new UNICODE string and copies the content 
 * from the ANSI source.  It's the caller responsability to free the memory
 */
LPWSTR UnicodeStringFromAnsi(LPCSTR pszSource)
{
	DWORD dwOutLen = lstrlenA(pszSource)+1;
	LPWSTR pszUString = new WCHAR[dwOutLen];

    dwOutLen = MultiByteToWideChar( CP_ACP, 0, pszSource, dwOutLen-1, pszUString, dwOutLen ); 
    pszUString[dwOutLen] = 0; // Add the null terminator 
	return pszUString;
}

/*
 * This function allocates the new UNICODE string and copies the content 
 * from the ANSI source.  It's the caller responsability to free the memory
 */
LPSTR AnsiStringFromUnicode(LPCWSTR pszSource)
{
	DWORD dwOutLen = lstrlenW(pszSource)+1;
	LPSTR pszUString = new CHAR[dwOutLen];

    dwOutLen = WideCharToMultiByte( CP_ACP, WC_DEFAULTCHAR, pszSource, dwOutLen-1, pszUString, dwOutLen, NULL, NULL ); 
    pszUString[dwOutLen] = 0; // Add the null terminator 
	return pszUString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\utils.h ===
//
// This file will hold various helper functions
//
//	 StringToInt - converts the decimal or hex string passed in to an integer
// 
// History:
//	Created:	MCostea	May 27, 1999
// 
#ifndef __UTILSH
#define __UTILSH

#define StringToInt(psz) StringToIntDef(psz, 0 )

int StringToIntDef(LPCTSTR psz, int Default);
int ReadHexValue(LPCTSTR psz);
void CopyToWideChar( WCHAR** pstrOut, LPCTSTR strIn );
LPWSTR UnicodeStringFromAnsi(LPCSTR pszSource);
LPSTR AnsiStringFromUnicode(LPCWSTR pszSource);

#endif	// __UTILSH
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__E2E1B5CD_78D9_4D6B_94C2_6E9CA4579862__INCLUDED_)
#define AFX_STDAFX_H__E2E1B5CD_78D9_4D6B_94C2_6E9CA4579862__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// Insert your headers here
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>
#include <commctrl.h>
#include <atlbase.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__E2E1B5CD_78D9_4D6B_94C2_6E9CA4579862__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\stringproperty.cpp ===
// StringProperty.cpp: implementation of the CStringProperty class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "StringProperty.h"
#include "utils.h"

#define TRACE 0?0:

CDictionary CStringPropertySection::m_Dictionary;

CStringPropertySection::CStringPropertySection()
{
    m_UsedItems=0;  // make this an array and re-alloc it - like the CDPA ! Gosh.
    m_ItemSize=RUN_SIZE;
    m_Items=new LINKSTRING[m_ItemSize];
}

//
// Finds the Value from the KEY, returns NULL if the KEY isn't used.
//
LPCTSTR CStringPropertySection::Get(LPCTSTR szPropID)
{
    int iEntry;
	if( Find( szPropID, &iEntry ) )
		return (LPCTSTR)m_Items[iEntry].pszValue;
	return NULL;
}

#define _MEM_DEBUG
#ifdef _MEM_DEBUG
DWORD g_KeyAlloc;
DWORD g_ValueAlloc;
#endif

//
// Associats a value (perhaps new) to a given key.
//
BOOL CStringPropertySection::Set(LPCTSTR szPropID, LPCTSTR szValue)
{
    int iEntry;
	if( Find( szPropID, &iEntry ) == FALSE )
	{
        if( m_UsedItems == m_ItemSize )
        {
            // re allocate the buffer bigger.
            m_ItemSize*=2;
            PLINKSTRING pNew=new LINKSTRING[m_ItemSize];
            CopyMemory(pNew, m_Items, sizeof(LINKSTRING) * m_UsedItems );
            delete m_Items;
            m_Items=pNew;
        }

        iEntry=m_UsedItems++;
		m_Items[iEntry].idKey=m_Dictionary.GetID( szPropID );
	}
	else
    {
		delete m_Items[iEntry].pszValue;
    }

	DWORD dwLen=lstrlen(szValue)+1;
#ifdef _MEM_DEBUG
    g_ValueAlloc+=dwLen;
#endif
	m_Items[iEntry].pszValue=new TCHAR[dwLen];
	CopyMemory( m_Items[iEntry].pszValue, szValue, dwLen*sizeof(TCHAR) );
	return TRUE;
}

//
// Finds a string in the table.
// The KEY of the thing you are finding
// An OUT pointer to the LINKSTRING structure
// which item in the LINKSTRING structure can be used.
//
BOOL CStringPropertySection::Find( LPCTSTR szPropID, int * pEntry)
{
    UINT uiPropID = m_Dictionary.GetID( szPropID ); // this is the ID for this string.
    for(UINT i=0;i<m_UsedItems;i++)
    {
        if( uiPropID == m_Items[i].idKey )
        {
            *pEntry=i;
            return TRUE;
        }
    }
    *pEntry=0;
	return FALSE;
}

CStringPropertySection::~CStringPropertySection()
{
    Purge();
    delete m_Items;
    m_Items=NULL;
}

void CStringPropertySection::Purge()
{
	for(UINT i=0;i<m_UsedItems;i++)
	{
        m_Items[i].idKey=0;
		delete m_Items[i].pszValue;
        m_Items[i].pszValue=NULL;
	}
    m_UsedItems=0;
}

//
// Looks for the existance of a property szPropID
// if present and set to YES, returns dwResult (default of TRUE).
// otherwise returns defValue
//
DWORD CStringPropertySection::YesNo(LPCTSTR szPropID, DWORD dwNotPresent, DWORD dwYes)
{
    return YesNo( szPropID, dwNotPresent, FALSE, dwYes );
}

DWORD CStringPropertySection::YesNo(LPCTSTR szPropID, DWORD dwNotPresent, DWORD dwNo, DWORD dwYes)
{
   	LPCTSTR req=(LPCTSTR)Get(szPropID);
    if( req == NULL )
        return dwNotPresent;

    if( req && lstrcmpi(req,TEXT("YES"))==0)
        return dwYes;
    return dwNo;
}

DWORD   CStringPropertySection::ValueOf(LPCTSTR szPropID, DWORD dwDefault)
{
   	LPCTSTR req=(LPCTSTR)Get(szPropID);
	// return req?_ttoi( req ):dwDefault;
    return req?StringToInt(req):dwDefault;
}



////////////////////////////////////////////////////////////////////////////////////////////////
//
// Dictionary.
// maps strings to UINTS, in a case insensitive manner.
//
////////////////////////////////////////////////////////////////////////////////////////////////

CDictionary::CDictionary()
{
	for(int i=0;i<DIC_TABLE_SIZE;i++)
		m_Table[i]=NULL;
}

UINT CDictionary::GetID(LPCTSTR szPropID)
{
    //
    // Has the string, find the bucket.
    //
	DWORD dwStrLen=lstrlen(szPropID)+1;
	DWORD hash=Hash(szPropID, dwStrLen);

    PLINKDICSTRING * pFoundPointer = &m_Table[hash];
    PLINKDICSTRING pFound=*pFoundPointer;
    int iNumber=0+1;
	while( pFound )
	{
        int used=pFound->cbUsed;
        for( int i=0;i<used;i++)
        {
            iNumber++;
		    if( lstrcmpi( pFound->pszKey[i], szPropID) == 0 )
                return pFound->ID[i];
        }

        //
        // If we have space in this run, use it up.
        //
        if( used < DIC_RUN_SIZE )
            break;

        // Next bucket
        pFoundPointer=&pFound->pNext;
        pFound=*pFoundPointer;
	}

    if( pFound == NULL )
    {
		pFound = new LINKDICSTRING;
        ZeroMemory( pFound, sizeof(LINKDICSTRING) );
        *pFoundPointer=pFound;
        TRACE(TEXT("Dic at 0x%08x\n"), pFound );
    }

    //
    // Make the ID out of the bucket we are in, and the item we're adding.
    //
    int iEntry=pFound->cbUsed++;
    pFound->ID[iEntry]=hash<<8 | iNumber;

#ifdef _MEM_DEBUG
    g_ValueAlloc+=dwStrLen;
#endif

	pFound->pszKey[iEntry]=new TCHAR[dwStrLen];
	CopyMemory( pFound->pszKey[iEntry], szPropID, dwStrLen*sizeof(TCHAR) );

    return pFound->ID[iEntry];
}

LPCTSTR CDictionary::GetString(UINT ID)
{
    int iBucket=ID >> 8;
    // for( int iBucket=0;iBucket<DIC_TABLE_SIZE;iBucket++)
    {
        PLINKDICSTRING pLinkString=m_Table[iBucket];
        int i=0;
	    while( pLinkString )
	    {
            int used=pLinkString->cbUsed;
            for( int i=0;i<used;i++)
            {
		        if( pLinkString->ID[i]  == ID )
                    return pLinkString->pszKey[i];
            }

            pLinkString=( pLinkString->pNext );
	    }
    }
	return 0;
}


//
// Case insensitive hash.
//
DWORD CDictionary::Hash( LPCTSTR szString, DWORD dwStrLen )
{
	TCHAR szChar=toupper( *szString );
	return (dwStrLen * szChar) % DIC_TABLE_SIZE;
}


CDictionary::~CDictionary()
{
    Purge();
}

void CDictionary::Purge()
{
	for(int i=0;i<DIC_TABLE_SIZE;i++)
	{
		PLINKDICSTRING pNext;
		PLINKDICSTRING pEntry = m_Table[i];
		while( pEntry )
		{
            for(int ti=0;ti<pEntry->cbUsed;ti++)
            {
                pEntry->ID[ti]=0;
			    delete pEntry->pszKey[ti];
                pEntry->pszKey[ti]=NULL;
            }
			pNext= pEntry->pNext;
            TRACE(TEXT("Dic @ 0x%08x\n"), pEntry );
			delete pEntry;
			pEntry=pNext;
		}
        m_Table[i]=NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\xmlcommand.cpp ===
// XMLCommand.cpp: implementation of the CXMLCommand class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "XMLCommand.h"
#include "sphelper.h"
#include "debug.h"
#include "utils.h"
extern WCHAR g_szPrefix[];

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CXMLCommand::~CXMLCommand()
{

}

CXMLCommanding::~CXMLCommanding()
{

}

//
//
//
void CXMLCommanding::Callback()
{
    CSpEvent event;

    if (m_cpRecoCtxt)
    {
        while (event.GetFrom(m_cpRecoCtxt) == S_OK)
        {
            switch (event.eEventId)
            {
				case SPEI_RECOGNITION:
                    {
                        HRESULT hr=ExecuteCommand(event.RecoResult());
                    }
					break;
			}
        }
	}
}

//
// These rules fire, let's see what we're supposed to do with them!
// we get the text that the user said, we then find the command (one of our children)
// we then find the ID, and if the parent isn't disabled, we send the message.
//
HRESULT CXMLCommanding::ExecuteCommand( ISpPhrase *pPhrase )
{
	HRESULT hr=S_OK;

    LPWSTR pszSaid = GetRecognizedText( pPhrase );

    int i=0;
    CXMLCommand * pCommand;
    // go through the list of commands, and find the one the user said.
    BOOL bFound=FALSE;
    while( pCommand=m_Commands.GetPointer(i++) )
    {
        LPWSTR pszText;
        if( SUCCEEDED( pCommand->get_Attr( TEXT("TEXT"), &pszText )))
        {
            if( *pszText==L'+' )
                pszText++;

            if( *pszText==L'-' )
                pszText++;

            if( *pszText==L'?' )
                pszText++;

            if(lstrcmpi( pszText, pszSaid ) == 0 )
            {
                LPWSTR pszCommandID;
                bFound=TRUE;
                if( SUCCEEDED( pCommand->get_Attr( TEXT("ID"), &pszCommandID )))
                {
                    UINT uiID=StringToIntDef(pszCommandID,0);
                    if(uiID)
                    {
                    	IRCMLNode * pParent;
	                    if( SUCCEEDED(DetachParent( & pParent )))
	                    {
		                    IRCMLControl * pControl;
		                    if( SUCCEEDED( pParent->QueryInterface( __uuidof( IRCMLControl ) , (LPVOID*)&pControl )))
		                    {
			                    HWND hWnd;
			                    if( SUCCEEDED( pControl->get_Window( &hWnd ))) 
			                    {
                                    if( IsWindow( hWnd ) )
                                    {
                                        if (IsEnabled(hWnd)==FALSE)
                                        {
                                            hr=E_FAIL;
                                            break;
                                        }
    
                                        // See if there is a target child window.
                                        if( TRUE || (GetForegroundWindow() == hWnd ) )
                                        {
                                            HWND hwndFrom=hWnd;
                                            LPWSTR pszTarget;
                                            if( SUCCEEDED( get_Attr( TEXT("TARGET"), &pszTarget )))
                                            {
                                                UINT uiChild = StringToIntDef(pszTarget, 0 );
                                                if(uiChild)
                                                    hWnd=GetDlgItem( hWnd, uiChild );
                                            }

                                            LPWSTR pszFrom;
                                            if( SUCCEEDED( get_Attr( TEXT("FROM"), &pszFrom )))
                                            {
                                                UINT uiChild = StringToIntDef(pszFrom, 0 );
                                                if(uiChild)
                                                    hwndFrom=GetDlgItem( hWnd, uiChild );
                                            }

                                            PostMessage(hWnd, WM_COMMAND, MAKEWPARAM( uiID,0) , (LPARAM)hwndFrom);
                                        }
                                        else
                                        {
                                            TRACE(TEXT("Trying to send a command to a non-foreground window\n"));
                                            hr=E_FAIL;
                                        }
                                    }
                                    else
                                    {
                                        TRACE(TEXT("The window 0x%08x cannot receive commands\n"),hWnd );
                                        hr=E_FAIL;
                                    }
                                }

                                if( SUCCEEDED(pCommand->IsType(L"CICERO:COMMAND" )))
                                {
                                    CXMLCommand * pXMLCommand=(CXMLCommand*)pCommand;
					                if(SUCCEEDED(hr))
                                    {
                                        if( hr!=S_FALSE )
                                        {
                                            pXMLCommand->SaySuccess();
                                        }
                                    }
                                    else
                                    {
                                        pXMLCommand->SayFailure();
                                    }
                                }
                                pControl->Release();
                            }
                        }
                    }
                }
                break;
            }
        }
    }

    if( bFound==FALSE )
    {
        TCHAR szStuff[1024];
        wsprintf(szStuff,TEXT("You said %s"),pszSaid);
        g_Notifications.SetText(szStuff);
    }
    delete pszSaid;
    return hr;
}


////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
//
// The base sapi node has provisions for a FAILURE element, and list of SYNONYMs
//
HRESULT STDMETHODCALLTYPE  CXMLCommanding::AcceptChild( 
            IRCMLNode __RPC_FAR *pChild)
{
    LPWSTR pType;
    LPWSTR pChildType;
    get_StringType( &pType );
    pChild->get_StringType( &pChildType );

    if( SUCCEEDED( pChild->IsType( L"CICERO:COMMAND" )))
	{
		m_Commands.Append((CXMLCommand*)pChild);
		return S_OK;
	}
    return E_INVALIDARG;    // we don't take children.
}


//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Check the type of the control, perhaps the text, and build a CFG accordingly.
//
HRESULT STDMETHODCALLTYPE CXMLCommanding::InitNode( 
    IRCMLNode __RPC_FAR *pParent)
{
	HRESULT hr=S_OK;
    TCHAR temp[1024];
    TCHAR szBuffer[2];
    szBuffer[0]=0xfeff;
    szBuffer[1]=NULL;
    PSTRINGBUFFER pBuffer = AppendText( NULL, szBuffer);

    pBuffer = AppendText(pBuffer, g_szPrefix);
    pBuffer = AppendText(pBuffer, TEXT("<RULE NAME=\"MENU\" TOPLEVEL=\"ACTIVE\">"));
    pBuffer = AppendText(pBuffer, TEXT("<L>"));

    BOOL bAnythingAdded=FALSE;
    int i=0;
    CXMLCommand * pCommand;
    while( pCommand=m_Commands.GetPointer(i++) )
    {
        LPWSTR pszText;
        if( SUCCEEDED( pCommand->get_Attr( TEXT("TEXT"), &pszText )))
        {
            wsprintf(temp,TEXT("<P>%s</P>"),pszText);
            pBuffer = AppendText(pBuffer, temp );
            bAnythingAdded=TRUE;
        }
    }

    pBuffer = AppendText(pBuffer, TEXT("</L>"));
    pBuffer = AppendText(pBuffer, TEXT("</RULE></GRAMMAR>"));

    if( bAnythingAdded )
    {
	    IRCMLControl * pControl;
	    if( SUCCEEDED( pParent->QueryInterface( __uuidof( IRCMLControl ) , (LPVOID*)&pControl )))
	    {
	        LPWSTR pszControlText=GetControlText(pControl);
            hr=LoadCFGFromString( pBuffer->pszString, pszControlText );
            delete pszControlText;
            pControl->Release();
        }
    }

    AppendText(pBuffer,NULL);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\sphelper.h ===
/*******************************************************************************
* SPHelper.h *
*------------*
*   Description:
*       This is the header file for core helper functions implementation.
*-------------------------------------------------------------------------------
*  Created By: EDC                                    Date: 08/14/98
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/
#ifndef SPHelper_h
#define SPHelper_h

#ifndef __sapi_h__
#include <sapi.h>
#endif

#ifndef SPError_h
#include <SPError.h>
#endif

#ifndef SPDebug_h
#include <SPDebug.h>
#endif

#ifndef _INC_LIMITS
#include <limits.h>
#endif

#ifndef _INC_CRTDBG
#include <crtdbg.h>
#endif

#ifndef _INC_MALLOC
#include <malloc.h>
#endif

#ifndef _INC_MMSYSTEM
#include <mmsystem.h>
#endif

#ifndef __comcat_h__
#include <comcat.h>
#endif

//=== Constants ==============================================================
#define sp_countof(x) ((sizeof(x) / sizeof(*(x))))
#define DEF_SPLSTR( s ) { L##s , sp_countof( s ) - 1 }

//
//  String handling and conversion classes
//
/*** SPLSTR
*   This structure is for managing strings with known lengths
*/
struct SPLSTR
{
    WCHAR*  pStr;
    int     Len;
};

//
//  Define a few new ATL OLE2T and W2T to deal with const strings (unicode only)
//  
#ifdef _UNICODE
inline const WCHAR * OLE2T(const WCHAR * lp) { return lp; }
inline const WCHAR * W2T(const WCHAR * lp) { return lp; }
#endif

//
//  Helper template class used to convert WCHAR strings to fixed-size buffers
//
template <const int i = MAX_PATH>
class CSpTcharString
{
#ifdef _UNICODE
private:
    const WCHAR *   m_psz;    
public:
    CSpTcharString(const WCHAR * psz) : m_psz(psz) {}
    operator const WCHAR *() { return m_psz; }
    const WCHAR * operator =(const WCHAR * psz) { m_psz = psz; return psz; } 
#else
private:
    TCHAR   m_aString[i];
public:
    CSpTcharString(const WCHAR * psz)
    {
        ::WideCharToMultiByte(CP_ACP, 0, psz, -1, m_aString, i, NULL, NULL);
    }
    operator const TCHAR *() { return m_aString; }
    const TCHAR * operator =(const WCHAR * psz)
    {
        ::WideCharToMultiByte(CP_ACP, 0, psz, -1, m_aString, i, NULL, NULL);
        return m_aString;
    }
#endif
};

template <const int i = MAX_PATH>
class CSpToAnsiString
{
private:
    CHAR *  m_pStr;
    CHAR    m_aString[i];
public:
    CSpToAnsiString(const WCHAR * psz)
    {
        if (psz)
        {
            m_pStr = m_aString;
            ::WideCharToMultiByte(CP_ACP, 0, psz, -1, m_aString, i, NULL, NULL);
        }
        else
        {
            m_pStr = NULL;
        }
    }
    operator CHAR *() { return m_pStr; }
    CHAR * operator =(const WCHAR * psz)
    {
        if (psz)
        {
            m_pStr = m_aString;
            ::WideCharToMultiByte(CP_ACP, 0, psz, -1, m_aString, i, NULL, NULL);
        }
        else
        {
            m_pStr = NULL;
        }
        return m_pStr;
    }
};

/*** CSpDynamicString helper class
*
*/
class CSpDynamicString 
{
public:
	WCHAR *     m_psz;
	CSpDynamicString()
	{
		m_psz = NULL;
	}
    CSpDynamicString(ULONG cchReserve)
    {
        m_psz = (WCHAR *)::CoTaskMemAlloc(cchReserve * sizeof(WCHAR));
    }
	WCHAR * operator=(const CSpDynamicString& src)
	{
		if (m_psz != src.m_psz)
		{
    		::CoTaskMemFree(m_psz);
			m_psz = src.Copy();
		}
		return m_psz;
	}
	WCHAR * operator=(const WCHAR * pSrc)
	{
        Clear();
        if (pSrc)
        {
            ULONG cbNeeded = (wcslen(pSrc) + 1) * sizeof(WCHAR);
            m_psz = (WCHAR *)::CoTaskMemAlloc(cbNeeded);
            SPDBG_ASSERT(m_psz);
            if (m_psz)
            {
                memcpy(m_psz, pSrc, cbNeeded);    
            }
        }
        return m_psz;
	}

	WCHAR * operator=(const char * pSrc)
	{
        Clear();
        if (pSrc)
        {
            ULONG cbNeeded = (lstrlenA(pSrc) + 1) * sizeof(WCHAR);
            m_psz = (WCHAR *)::CoTaskMemAlloc(cbNeeded);
            SPDBG_ASSERT(m_psz);
            if (m_psz)
            {
                ::MultiByteToWideChar(CP_ACP, 0, pSrc, -1, m_psz, cbNeeded/sizeof(WCHAR));
            }
        }
        return m_psz;
    }

    WCHAR * operator=(REFGUID rguid)
    {
        Clear();
        ::StringFromCLSID(rguid, &m_psz);
        return m_psz;
    }


	/*explicit*/ CSpDynamicString(const WCHAR * pSrc)
	{
		m_psz = NULL;
        operator=(pSrc);
	}
    /*explicit*/ CSpDynamicString(const char * pSrc)
    {
        m_psz = NULL;
        operator=(pSrc);
    }
    /*explicit*/ CSpDynamicString(const CSpDynamicString& src)
	{
		m_psz = src.Copy();
    }
    /*explicit*/ CSpDynamicString(REFGUID rguid)
	{
        ::StringFromCLSID(rguid, &m_psz);
    }


	~CSpDynamicString()
	{
		::CoTaskMemFree(m_psz);
	}
	unsigned int Length() const
	{
		return (m_psz == NULL)? 0 : wcslen(m_psz);
	}

	operator WCHAR * () const
	{
		return m_psz;
	}
	//The assert on operator& usually indicates a bug.  If this is really
	//what is needed, however, take the address of the m_psz member explicitly.
	WCHAR ** operator&()
	{
        SPDBG_ASSERT(m_psz == NULL);
		return &m_psz;
	}

    WCHAR * Append(const WCHAR * pszSrc)
    {
        if (pszSrc)
        {
            ULONG lenSrc = wcslen(pszSrc);
            if (lenSrc)
            {
                ULONG lenMe = Length();
                WCHAR *pszNew = (WCHAR *)::CoTaskMemAlloc((lenMe + lenSrc + 1) * sizeof(WCHAR));
                if (pszNew)
                {
                    if (m_psz)  // Could append to an empty string so check...
                    {
                        if (lenMe)
                        {
                            memcpy(pszNew, m_psz, lenMe * sizeof(WCHAR));
                        }
                        ::CoTaskMemFree(m_psz);
                    }
                    memcpy(pszNew + lenMe, pszSrc, (lenSrc + 1) * sizeof(WCHAR));
                    m_psz = pszNew;
                }
                else
                {
                    SPDBG_ASSERT(FALSE);
                }
            }
        }
        return m_psz;
    }
    WCHAR * Append2(const WCHAR * pszSrc1, const WCHAR * pszSrc2)
    {
        ULONG lenSrc1 = wcslen(pszSrc1);
        ULONG lenSrc2 = wcslen(pszSrc2);
        if (lenSrc1 || lenSrc2)
        {
            ULONG lenMe = Length();
            WCHAR *pszNew = (WCHAR *)::CoTaskMemAlloc((lenMe + lenSrc1 + lenSrc2 + 1) * sizeof(WCHAR));
            if (pszNew)
            {
                if (m_psz)  // Could append to an empty string so check...
                {
                    if (lenMe)
                    {
                        memcpy(pszNew, m_psz, lenMe * sizeof(WCHAR));
                    }
                    ::CoTaskMemFree(m_psz);
                }
                // In both of these cases, we copy the trailing NULL so that we're sure it gets
                // there (if lenSrc2 is 0 then we better copy it from pszSrc1).
                if (lenSrc1)
                {
                    memcpy(pszNew + lenMe, pszSrc1, (lenSrc1 + 1) * sizeof(WCHAR));
                }
                if (lenSrc2)
                {
                    memcpy(pszNew + lenMe + lenSrc1, pszSrc2, (lenSrc2 + 1) * sizeof(WCHAR));
                }
                m_psz = pszNew;
            }
            else
            {
                SPDBG_ASSERT(FALSE);
            }
        }
        return m_psz;

    }
	WCHAR * Copy() const
	{
        if (m_psz)
        {
            CSpDynamicString szNew(m_psz);
            return szNew.Detach();
        }
        return NULL;
    }
	void Attach(WCHAR * pszSrc)
	{
		SPDBG_ASSERT(m_psz == NULL);
		m_psz = pszSrc;
	}
	WCHAR * Detach()
	{
		WCHAR * s = m_psz;
		m_psz = NULL;
		return s;
	}
	void Clear()
	{
		::CoTaskMemFree(m_psz);
		m_psz = NULL;
	}
	bool operator!() const
	{
		return (m_psz == NULL);
	}
    HRESULT CopyToBSTR(BSTR * pbstr)
    {
        if (m_psz)
        {
            *pbstr = ::SysAllocString(m_psz);
            if (*pbstr == NULL)
            {
                return E_OUTOFMEMORY;
            }
        }
        else
        {
            *pbstr = NULL;
        }
        return S_OK;
    }
    void TrimToSize(ULONG ulNumChars)
    {
        SPDBG_ASSERT(m_psz);
        SPDBG_ASSERT(Length() >= ulNumChars);
        m_psz[ulNumChars] = 0;
    }
    WCHAR * Compact()
    {
        if (m_psz)
        {
            ULONG cch = wcslen(m_psz);
            m_psz = (WCHAR *)::CoTaskMemRealloc(m_psz, (cch + 1) * sizeof(WCHAR));
        }
        return m_psz;
    }
    WCHAR * ClearAndGrowTo(ULONG cch)
    {
        if (m_psz)
        {
            Clear();
        }
        m_psz = (WCHAR *)::CoTaskMemAlloc(cch * sizeof(WCHAR));
        return m_psz;
    }
};

// BUGBUG - This class isn't tested and isn't used a whole lot, maybe it should be removed.

#pragma warning(push)
#pragma warning(disable:4100) // unused formal paramater
class CSpFileStream : public IStream
{
private:
    HANDLE      m_hFile;
    ULONG       m_ulRef;
public:
    CSpFileStream(HRESULT * pHR, const TCHAR * pFileName, DWORD dwDesiredAccess = GENERIC_READ, DWORD dwShareMode = FILE_SHARE_READ, DWORD dwCreationDisposition = OPEN_EXISTING)
    {
        m_hFile = ::CreateFile(pFileName, dwDesiredAccess, dwShareMode, NULL, dwCreationDisposition, 0, NULL);
        m_ulRef = 1;
        *pHR = (m_hFile != INVALID_HANDLE_VALUE) ? S_OK : HRESULT_FROM_WIN32(::GetLastError());
    }
    CSpFileStream(HANDLE hFile) : m_hFile(hFile), m_ulRef(1) {}
    ~CSpFileStream()
    {
        if (m_hFile != INVALID_HANDLE_VALUE)
        {
            ::CloseHandle(m_hFile);
            m_hFile = INVALID_HANDLE_VALUE;
        }
    }
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv)
    {
        if (riid == __uuidof(IStream) ||
            riid == IID_ISequentialStream ||
            riid == __uuidof(IUnknown))
        {
            *ppv = (IStream *)this;
            m_ulRef++;
            return S_OK;
        }
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return ++m_ulRef;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        --m_ulRef;
        if (m_ulRef)
        {
            return m_ulRef;
        }
        delete this;
        return 0;
    }
    STDMETHODIMP Read(void * pv, ULONG cb, ULONG * pcbRead)
    {
        ULONG ulRead;
        if (::ReadFile(m_hFile, pv, cb, &ulRead, NULL))
        {
            if (pcbRead) *pcbRead = ulRead;
            return S_OK;
        }
        return HRESULT_FROM_WIN32(::GetLastError());
    }
    STDMETHODIMP Write(const void * pv, ULONG cb, ULONG * pcbWritten)
    {
        ULONG ulWritten;
        if (::WriteFile(m_hFile, pv, cb, &ulWritten, NULL))
        {
            if (pcbWritten) *pcbWritten = ulWritten;
            return S_OK;
        }
        return HRESULT_FROM_WIN32(::GetLastError());
    }

    STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
    {
        long lMoveHigh = dlibMove.HighPart;
        DWORD dwNewPos = ::SetFilePointer(m_hFile, dlibMove.LowPart, &lMoveHigh, dwOrigin);
        if (dwNewPos == 0xFFFFFFFF && ::GetLastError() != NO_ERROR)
        {
            return HRESULT_FROM_WIN32(::GetLastError());
        }
        if (plibNewPosition)
        {
            plibNewPosition->LowPart = dwNewPos;
            plibNewPosition->HighPart = lMoveHigh;
        }
        return S_OK;
    }

    STDMETHODIMP SetSize(ULARGE_INTEGER libNewSize) 
    {
        HRESULT hr = S_OK;
        LARGE_INTEGER Move = {0};
        ULARGE_INTEGER Cur;
        hr = Seek(Move, STREAM_SEEK_CUR, &Cur);
        if (SUCCEEDED(hr))
        {
            LARGE_INTEGER li;
            li.QuadPart = libNewSize.QuadPart;
            hr = Seek(li, STREAM_SEEK_SET, NULL);
            if (SUCCEEDED(hr))
            {
                if (!::SetEndOfFile(m_hFile))
                {
                    hr = HRESULT_FROM_WIN32(::GetLastError());
                }
                li.QuadPart = Cur.QuadPart;
                Seek(li, STREAM_SEEK_SET, NULL);
            }
        }
        return hr;
    }
   
    STDMETHODIMP CopyTo(IStream *pStreamDest, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER __RPC_FAR *pcbWritten)
    {
        // BUGBUG -- For now do it the slacker way!
        void * pData = ::HeapAlloc(::GetProcessHeap(), 0, (DWORD)cb.QuadPart);
        if (pData == NULL) return E_OUTOFMEMORY;
        ULONG cbRead;
        Read(pData, (DWORD)cb.QuadPart, &cbRead);
        if (pcbRead) pcbRead->QuadPart = cbRead;
        ULONG cbWritten;
        pStreamDest->Write(pData, cbRead, &cbWritten);
        if (pcbWritten) pcbWritten->QuadPart = cbWritten;
        ::HeapFree(::GetProcessHeap(), 0, pData);
        return S_OK;
    }
        
    STDMETHODIMP Commit(DWORD grfCommitFlags)
    {
        return S_OK;
    }
        
    STDMETHODIMP Revert(void) 
    {
        return E_NOTIMPL; 
    }
        
    STDMETHODIMP LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType) 
    {
        return E_NOTIMPL;   // BUGBUG -- This could be supported!
    }
    
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
    {
        return E_NOTIMPL; // BUGBUG -- This too!
    }
        
    STDMETHODIMP Stat(STATSTG *pstatstg, DWORD grfStatFlag)
    {
        //
        //  BUGBUG -- This needs to be thought out some more.  Name, etc
        //
        HRESULT hr = S_OK;
        if (grfStatFlag & (~STATFLAG_NONAME))
        {
            hr = E_INVALIDARG;
        }
        else
        {
            //
            //  It is acceptable to simply fill in the size and type fields and zero the rest.
            //  This is what streams created by CreateStreamOnHGlobal return.
            //
            ZeroMemory(pstatstg, sizeof(*pstatstg));
            pstatstg->type = STGTY_STREAM;
            pstatstg->cbSize.LowPart = ::GetFileSize(m_hFile, &(pstatstg->cbSize.HighPart));
        }
        return hr;
    }
        
    STDMETHODIMP Clone(IStream ** ppstm)
    {
        return E_NOTIMPL; // BUGBUG -- This should work just fine!
    }


};
#pragma warning(pop)


//=== Token helpers

inline HRESULT SpGetTokenFromId(
    const WCHAR * pszTokenId, 
    ISpObjectToken ** ppToken,
    BOOL fCreateIfNotExist = FALSE)
{
    SPDBG_FUNC("SpGetTokenFromId");
    HRESULT hr;
    
    CComPtr<ISpObjectToken> cpToken;
    hr = cpToken.CoCreateInstance(CLSID_SpObjectToken);
    
    if (SUCCEEDED(hr))
    {
        hr = cpToken->SetId(NULL, pszTokenId, fCreateIfNotExist);
    }
    
    if (SUCCEEDED(hr))
    {
        *ppToken = cpToken.Detach();
    }
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

inline HRESULT SpGetCategoryFromId(
    const WCHAR * pszCategoryId,
    ISpObjectTokenCategory ** ppCategory,
    BOOL fCreateIfNotExist = FALSE)
{
    SPDBG_FUNC("SpGetCategoryFromId");
    HRESULT hr;
    
    CComPtr<ISpObjectTokenCategory> cpTokenCategory;
    hr = cpTokenCategory.CoCreateInstance(CLSID_SpObjectTokenCategory);
    
    if (SUCCEEDED(hr))
    {
        hr = cpTokenCategory->SetId(pszCategoryId, fCreateIfNotExist);
    }
    
    if (SUCCEEDED(hr))
    {
        *ppCategory = cpTokenCategory.Detach();
    }
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

inline HRESULT SpGetDefaultTokenIdFromCategoryId(
    const WCHAR * pszCategoryId,
    WCHAR ** ppszTokenId)
{
    SPDBG_FUNC("SpGetDefaultTokenFromCategoryId");
    HRESULT hr;

    CComPtr<ISpObjectTokenCategory> cpCategory;
    hr = SpGetCategoryFromId(pszCategoryId, &cpCategory);
    
    if (SUCCEEDED(hr))
    {
        hr = cpCategory->GetDefaultTokenId(ppszTokenId);
    }

    return hr;
}

inline HRESULT SpSetDefaultTokenIdForCategoryId(
    const WCHAR * pszCategoryId,
    const WCHAR * pszTokenId)
{
    SPDBG_FUNC("SpSetDefaultTokenIdForCategoryId");
    HRESULT hr;

    CComPtr<ISpObjectTokenCategory> cpCategory;
    hr = SpGetCategoryFromId(pszCategoryId, &cpCategory);
    
    if (SUCCEEDED(hr))
    {
        hr = cpCategory->SetDefaultTokenId(pszTokenId);
    }

    return hr;
}

inline HRESULT SpGetDefaultTokenFromCategoryId(
    const WCHAR * pszCategoryId,
    ISpObjectToken ** ppToken,
    BOOL fCreateCategoryIfNotExist = TRUE)
{
    SPDBG_FUNC("SpGetDefaultTokenFromCategoryId");
    HRESULT hr;

    CComPtr<ISpObjectTokenCategory> cpCategory;
    hr = SpGetCategoryFromId(pszCategoryId, &cpCategory, fCreateCategoryIfNotExist);

    WCHAR * pszTokenId;
    if (SUCCEEDED(hr))
    {
        hr = cpCategory->GetDefaultTokenId(&pszTokenId);
    }

    if (SUCCEEDED(hr))
    {
        hr = SpGetTokenFromId(pszTokenId, ppToken);
        ::CoTaskMemFree(pszTokenId);
    }

    return hr;
}

inline HRESULT SpSetDefaultTokenForCategoryId(
    const WCHAR * pszCategoryId,
    ISpObjectToken * pToken)
{
    SPDBG_FUNC("SpSetDefaultTokenForCategoryId");
    HRESULT hr;

    WCHAR * pszTokenId;
    hr = pToken->GetId(&pszTokenId);

    if (SUCCEEDED(hr))
    {
        hr = SpSetDefaultTokenIdForCategoryId(pszCategoryId, pszTokenId);
        ::CoTaskMemFree(pszTokenId);
    }

    return hr;
}

inline HRESULT SpSetCommonTokenData(
    ISpObjectToken * pToken,
    const CLSID * pclsid,
    const WCHAR * pszLangIndependentName,
    LANGID langid,
    const WCHAR * pszLangDependentName,
    ISpDataKey ** ppDataKeyAttribs)
{
    SPDBG_FUNC("SpSetCommonTokenData");
    HRESULT hr = S_OK;
    
    // Set the new token's CLSID (if specified)
    if (SUCCEEDED(hr) && pclsid)
    {
        CSpDynamicString dstrClsid;
        hr = StringFromCLSID(*pclsid, &dstrClsid);
    
        if (SUCCEEDED(hr))
        {
            hr = pToken->SetStringValue(SPTOKENVALUE_CLSID, dstrClsid);
        }
    }

    // Set the token's lang independent name
    if (SUCCEEDED(hr) && pszLangIndependentName)
    {
        hr = pToken->SetStringValue(NULL, pszLangIndependentName);
    }

    // Set the token's lang dependent name
    if (SUCCEEDED(hr) && pszLangDependentName)
    {
        USES_CONVERSION;
        
        TCHAR szLangId[10];
        wsprintf(szLangId, _T("%x"), langid);

        hr = pToken->SetStringValue(T2W(szLangId), pszLangDependentName);
    }

    // Open the attributes key if requested
    if (SUCCEEDED(hr) && ppDataKeyAttribs)
    {
        hr = pToken->CreateKey(L"Attributes", ppDataKeyAttribs);
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

inline HRESULT SpCreateNewToken(
    const WCHAR * pszTokenId,
    ISpObjectToken ** ppToken)
{
    SPDBG_FUNC("SpCreateNewToken");
    HRESULT hr;

    // Forcefully create the token
    hr = SpGetTokenFromId(pszTokenId, ppToken, TRUE);
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

inline HRESULT SpCreateNewToken(
    const WCHAR * pszCategoryId,
    const WCHAR * pszTokenKeyName,
    ISpObjectToken ** ppToken)
{
    SPDBG_FUNC("SpCreateNewToken");
    HRESULT hr;

    // Forcefully create the category
    CComPtr<ISpObjectTokenCategory> cpCategory;
    hr = SpGetCategoryFromId(pszCategoryId, &cpCategory, TRUE);

    // Come up with a token key name if one wasn't specified
    CSpDynamicString dstrTokenKeyName;
    if (SUCCEEDED(hr))
    {
        if (pszTokenKeyName == NULL)
        {
            GUID guidTokenKeyName;
            hr = CoCreateGuid(&guidTokenKeyName);

            if (SUCCEEDED(hr))
            {
                hr = StringFromCLSID(guidTokenKeyName, &dstrTokenKeyName);
            }

            if (SUCCEEDED(hr))
            {
                pszTokenKeyName = dstrTokenKeyName;
            }
        }
    }

    // Build the token id
    CSpDynamicString dstrTokenId;
    if (SUCCEEDED(hr))
    {
        dstrTokenId = pszCategoryId;
        dstrTokenId.Append2(L"\\Tokens\\", pszTokenKeyName);
    }

    // Forcefully create the token
    if (SUCCEEDED(hr))
    {
        hr = SpGetTokenFromId(dstrTokenId, ppToken, TRUE);
    }
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

inline HRESULT SpCreateNewTokenEx(
    const WCHAR * pszCategoryId,
    const WCHAR * pszTokenKeyName,
    const CLSID * pclsid,
    const WCHAR * pszLangIndependentName,
    LANGID langid,
    const WCHAR * pszLangDependentName,
    ISpObjectToken ** ppToken,
    ISpDataKey ** ppDataKeyAttribs)
{
    SPDBG_FUNC("SpCreateNewTokenEx");
    HRESULT hr;

    // Create the new token
    hr = SpCreateNewToken(pszCategoryId, pszTokenKeyName, ppToken);

    // Now set the extra data
    if (SUCCEEDED(hr))
    {
        hr = SpSetCommonTokenData(
                    *ppToken, 
                    pclsid, 
                    pszLangIndependentName, 
                    langid, 
                    pszLangDependentName, 
                    ppDataKeyAttribs);
    }
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

inline HRESULT SpCreateNewTokenEx(
    const WCHAR * pszTokenId,
    const CLSID * pclsid,
    const WCHAR * pszLangIndependentName,
    LANGID langid,
    const WCHAR * pszLangDependentName,
    ISpObjectToken ** ppToken,
    ISpDataKey ** ppDataKeyAttribs)
{
    SPDBG_FUNC("SpCreateNewTokenEx");
    HRESULT hr;

    // Create the new token
    hr = SpCreateNewToken(pszTokenId, ppToken);

    // Now set the extra data
    if (SUCCEEDED(hr))
    {
        hr = SpSetCommonTokenData(
                    *ppToken, 
                    pclsid, 
                    pszLangIndependentName, 
                    langid, 
                    pszLangDependentName, 
                    ppDataKeyAttribs);
    }
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

inline HRESULT SpEnumTokens(
    const WCHAR * pszCategoryId, 
    const WCHAR * pszReqAttribs, 
    const WCHAR * pszOptAttribs, 
    IEnumSpObjectTokens ** ppEnum)
{
    SPDBG_FUNC("SpEnumTokens");
    HRESULT hr = S_OK;
    
    CComPtr<ISpObjectTokenCategory> cpCategory;
    hr = SpGetCategoryFromId(pszCategoryId, &cpCategory);
    
    if (SUCCEEDED(hr))
    {
        hr = cpCategory->EnumTokens(
                    pszReqAttribs,
                    pszOptAttribs,
                    ppEnum);
    }
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

inline HRESULT SpFindBestToken(
    const WCHAR * pszCategoryId, 
    const WCHAR * pszReqAttribs, 
    const WCHAR * pszOptAttribs, 
    ISpObjectToken **ppObjectToken)
{
    SPDBG_FUNC("SpFindBestToken");
    HRESULT hr = S_OK;
    
    CComPtr<IEnumSpObjectTokens> cpEnum;
    hr = SpEnumTokens(pszCategoryId, pszReqAttribs, pszOptAttribs, &cpEnum);
    
    if (SUCCEEDED(hr))
    {
        hr = cpEnum->Next(1, ppObjectToken, NULL);
        if (hr == S_FALSE)
        {
            *ppObjectToken = NULL;
            hr = SPERR_NOT_FOUND;
        }
    }

    if (hr != SPERR_NOT_FOUND)
    {
        SPDBG_REPORT_ON_FAIL(hr);
    }
    
    return hr;
}

template<class T>
HRESULT SpCreateObjectFromToken(ISpObjectToken * pToken, T ** ppObject,
                       IUnknown * pUnkOuter = NULL, DWORD dwClsCtxt = CLSCTX_ALL)
{
    SPDBG_FUNC("SpCreateObjectFromToken");
    HRESULT hr;

    hr = pToken->CreateInstance(pUnkOuter, dwClsCtxt, __uuidof(T), (void **)ppObject);
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

template<class T>
HRESULT SpCreateObjectFromTokenId(const WCHAR * pszTokenId, T ** ppObject,
                       IUnknown * pUnkOuter = NULL, DWORD dwClsCtxt = CLSCTX_ALL)
{
    SPDBG_FUNC("SpCreateObjectFromTokenId");
    
    ISpObjectToken * pToken;
    HRESULT hr = SpGetTokenFromId(pszTokenId, &pToken);
    if (SUCCEEDED(hr))
    {
        hr = SpCreateObjectFromToken(pToken, ppObject, pUnkOuter, dwClsCtxt);
        pToken->Release();
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

template<class T>
HRESULT SpCreateDefaultObjectFromCategoryId(const WCHAR * pszCategoryId, T ** ppObject,
                       IUnknown * pUnkOuter = NULL, DWORD dwClsCtxt = CLSCTX_ALL)
{
    SPDBG_FUNC("SpCreateObjectFromTokenId");
    
    ISpObjectToken * pToken;
    HRESULT hr = SpGetDefaultTokenFromCategoryId(pszCategoryId, &pToken);
    if (SUCCEEDED(hr))
    {
        hr = SpCreateObjectFromToken(pToken, ppObject, pUnkOuter, dwClsCtxt);
        pToken->Release();
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

template<class T>
HRESULT SpCreateBestObject(
    const WCHAR * pszCategoryId, 
    const WCHAR * pszReqAttribs, 
    const WCHAR * pszOptAttribs, 
    T ** ppObject,
    IUnknown * pUnkOuter = NULL, 
    DWORD dwClsCtxt = CLSCTX_ALL)
{
    SPDBG_FUNC("SpCreateBestObject");
    HRESULT hr;
    
    CComPtr<ISpObjectToken> cpToken;
    hr = SpFindBestToken(pszCategoryId, pszReqAttribs, pszOptAttribs, &cpToken);

    if (SUCCEEDED(hr))
    {
        hr = SpCreateObjectFromToken(cpToken, ppObject, pUnkOuter, dwClsCtxt);
    }

    if (hr != SPERR_NOT_FOUND)
    {
        SPDBG_REPORT_ON_FAIL(hr);
    }

    return hr;
}

inline HRESULT SpCreatePhoneConverter(
    LANGID langid,
    const WCHAR * pszReqAttribs,
    const WCHAR * pszOptAttribs,
    ISpPhoneConverter ** ppPhoneConverter)
{
    SPDBG_FUNC("SpCreatePhoneConverter");
    HRESULT hr;

    CSpDynamicString dstrReqAttribs;
    if (pszReqAttribs)
    {
        dstrReqAttribs = pszReqAttribs;
        dstrReqAttribs.Append(L";");
    }

    WCHAR szLang[MAX_PATH];
    WCHAR * pszLang = szLang;

    while (langid)
    {
        int nibble = langid % 16;
        *pszLang++ = WCHAR(nibble < 10
            ? L'0' + nibble
            : L'a' + nibble);
        langid >>= 4;
    }
    *pszLang = '\0';
    wcsrev(szLang);

    WCHAR szLangCondition[MAX_PATH];
    wcscpy(szLangCondition, L"Language=");
    wcscat(szLangCondition, szLang);

    dstrReqAttribs.Append(szLangCondition);

    hr = SpCreateBestObject(SPCAT_PHONECONVERTERS, dstrReqAttribs, pszOptAttribs, ppPhoneConverter);

    if (hr != SPERR_NOT_FOUND)
    {
        SPDBG_REPORT_ON_FAIL(hr);
    }

    return hr;
}

template<class T>
T * SpInterlockedExchangePointer(T ** pTarget, void * pNew) // Use VOID for pNew so NULL will work.
{
#ifdef InterlockedExchangePointer
    return (T *) InterlockedExchangePointer(pTarget, (T *)pNew);
#else
    return (T *)::InterlockedExchange((LPLONG)pTarget, (LONG)pNew);
#endif
}

/****************************************************************************
* SpGetUserDefaultUILanguage *
*----------------------------*
*   Description:
*       Returns the default user interface language, using a method 
*       appropriate to the platform (Windows 9x, Windows NT, or Windows 2000)
*
*   Returns:
*       Default UI language
*
********************************************************************* RAL ***/

inline LANGID SpGetUserDefaultUILanguage(void) 
{
    HRESULT hr = S_OK;
    LANGID wUILang = 0;

    OSVERSIONINFO Osv ;
    Osv.dwOSVersionInfoSize = sizeof(Osv) ;
    if(!GetVersionEx(&Osv)) 
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
    }
    // Get the UI language by one of three methods, depending on the system
    // BUGBUG -- What about Windows CE???
    else if(Osv.dwPlatformId != VER_PLATFORM_WIN32_NT) 
    {
        // Case 1: Running on Windows 9x. Get the system UI language from registry:
        CHAR szData[32];
        DWORD dwErr, dwSize = sizeof(szData) ;
        HKEY hKey;

        dwErr = HRESULT_FROM_WIN32(::RegOpenKeyExA(HKEY_USERS, ".Default\\Control Panel\\desktop\\ResourceLocale", 
                                                   0, KEY_READ, &hKey));
        if (SUCCEEDED(hr))
        {
            hr = HRESULT_FROM_WIN32(::RegQueryValueExA(hKey, "", NULL, NULL, (BYTE *)szData, &dwSize)); 
            ::RegCloseKey(hKey) ;
        }
        if (SUCCEEDED(hr))
        {
            // Convert string to number
            wUILang = (LANGID) strtol(szData, NULL, 16) ;
        }
    }
    else if (Osv.dwMajorVersion >= 5.0) 
    {
    // Case 2: Running on Windows 2000 or later. Use GetUserDefaultUILanguage to find 
    // the user's prefered UI language


        HMODULE hMKernel32 = ::LoadLibraryW(L"kernel32.dll") ;
        if (hMKernel32 == NULL)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
        }
        else
        {

#ifdef _WIN32_WCE

            LANGID (WINAPI *pfnGetUserDefaultUILanguage) () = 
                (LANGID (WINAPI *)(void)) 
                    GetProcAddress(hMKernel32, _T("GetUserDefaultUILanguage")) ;

#else
            LANGID (WINAPI *pfnGetUserDefaultUILanguage) () = 
                (LANGID (WINAPI *)(void)) 
                    GetProcAddress(hMKernel32, "GetUserDefaultUILanguage") ;

#endif

            if(NULL != pfnGetUserDefaultUILanguage) 
            {
                wUILang = pfnGetUserDefaultUILanguage() ;
            }
            else
            {   // GetProcAddress failed
                hr = HRESULT_FROM_WIN32(::GetLastError());
            }
            ::FreeLibrary(hMKernel32);
        }
    }
    else {
    // Case 3: Running on Windows NT 4.0 or earlier. Get UI language
    // from locale of .default user in registry:
    // HKEY_USERS\.DEFAULT\Control Panel\International\Locale
        
        WCHAR szData[32]   ;
        DWORD dwSize = sizeof(szData) ;
        HKEY hKey          ;

        hr = HRESULT_FROM_WIN32(::RegOpenKeyExW(HKEY_USERS, L".DEFAULT\\Control Panel\\International", 
                                                0, KEY_READ, &hKey));

        if (SUCCEEDED(hr))
        {
            hr = HRESULT_FROM_WIN32(::RegQueryValueExW(hKey, L"Locale",  NULL, NULL, (BYTE *)szData, &dwSize));
            ::RegCloseKey(hKey);
        }

        if (SUCCEEDED(hr))
        {
            // Convert string to number
            wUILang = (LANGID) wcstol(szData, NULL, 16) ;

            if(0x0401 == wUILang || // Arabic
               0x040d == wUILang || // Hebrew
               0x041e == wUILang    // Thai
               )
            {
                // Special case these to the English UI.
                // These versions of Windows NT 4.0 were enabled only, i.e., the
                // UI was English. However, the registry setting 
                // HKEY_USERS\.DEFAULT\Control Panel\International\Locale was set  
                // to the respective locale for application compatibility.
                wUILang = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US) ;
            }
        }
    }

    return (wUILang ? wUILang : ::GetUserDefaultLangID());    // In failure case, try our best!
}


/****************************************************************************
* SpConvertLanguageId *
*---------------------*
*   Description:
*       Given a language ID in pLangId, this function will convert the ID as follows:
*       0 - Returns the default UI language ID
*       LANG_SYSTEM_DEFAULT - Returns the system default language ID
*       LANG_USER_DEFAULT - Returns the user default language ID
*       Other - Function will not change language ID
*
*   Returns:
*       Converted language ID
*
********************************************************************* RAL ***/

inline LANGID SpConvertLanguageId(LANGID LangId)
{
    switch (LangId)
    {
    case 0:
        return ::SpGetUserDefaultUILanguage();
    case LANG_SYSTEM_DEFAULT:
        return ::GetSystemDefaultLangID();
    case LANG_USER_DEFAULT:
        return ::GetUserDefaultLangID();
    default:
        return LangId;
    }
}


//
//  Simple inline function converts a ulong to a hex string.
//
inline void SpHexFromUlong(WCHAR * psz, ULONG ul)
{
    const static WCHAR szHexChars[] = L"0123456789ABCDEF";
    if (ul == 0)
    {
        psz[0] = L'0';
        psz[1] = 0;
    }
    else
    {
        ULONG ulChars = 1;
        psz[0] = 0;
        while (ul)
        {
            memmove(psz + 1, psz, ulChars * sizeof(WCHAR));
            psz[0] = szHexChars[ul % 16];
            ul /= 16;
            ulChars++;
        }
    }
}


inline HRESULT SpGetDescription(ISpObjectToken * pObjToken, WCHAR ** ppszDescription, LANGID Language = SpGetUserDefaultUILanguage())
{
    WCHAR szLangId[10];
    SpHexFromUlong(szLangId, Language);
    HRESULT hr = pObjToken->GetStringValue(szLangId, ppszDescription);
    if (hr == SPERR_NOT_FOUND)
    {
        hr = pObjToken->GetStringValue(NULL, ppszDescription);
    }
    return hr;
}


inline HRESULT SpSetDescription(ISpObjectToken * pObjToken, const WCHAR * pszDescription, LANGID Language = SpGetUserDefaultUILanguage(), BOOL fSetLangIndependentId = TRUE)
{
    WCHAR szLangId[10];
    SpHexFromUlong(szLangId, Language);
    HRESULT hr = pObjToken->SetStringValue(szLangId, pszDescription);
    if (SUCCEEDED(hr) && fSetLangIndependentId)
    {
        hr = pObjToken->SetStringValue(NULL, pszDescription);
    }
    return hr;
}

/****************************************************************************
* SpConvertStreamFormatEnum *
*---------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

inline HRESULT SpConvertStreamFormatEnum(SPSTREAMFORMAT eFormat, GUID * pFormatId, WAVEFORMATEX ** ppCoMemWaveFormatEx)
{
    HRESULT hr = S_OK;

    if(pFormatId==NULL || ::IsBadWritePtr(pFormatId, sizeof(*pFormatId))
        || ppCoMemWaveFormatEx==NULL || ::IsBadWritePtr(ppCoMemWaveFormatEx, sizeof(*ppCoMemWaveFormatEx)))
    {
        return E_INVALIDARG;
    }

    const GUID * pFmtGuid = &GUID_NULL;     // Assume failure case
    if (eFormat >= SPSF_8kHz8BitMono && eFormat <= SPSF_48kHz16BitStereo)
    {
        WAVEFORMATEX * pwfex = (WAVEFORMATEX *)::CoTaskMemAlloc(sizeof(WAVEFORMATEX));
        *ppCoMemWaveFormatEx = pwfex;
        if (pwfex)
        {
            DWORD dwIndex = eFormat - SPSF_8kHz8BitMono;
            BOOL bIsStereo = dwIndex & 0x1;
            BOOL bIs16 = dwIndex & 0x2;
            DWORD dwKHZ = (dwIndex & 0x1c) >> 2;
            static const DWORD adwKHZ[] = { 8000, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000 };
            pwfex->wFormatTag = WAVE_FORMAT_PCM;
            pwfex->nChannels = pwfex->nBlockAlign = (WORD)(bIsStereo ? 2 : 1);
            pwfex->nSamplesPerSec = adwKHZ[dwKHZ];
            pwfex->wBitsPerSample = 8;
            if (bIs16)
            {
                pwfex->wBitsPerSample *= 2;
                pwfex->nBlockAlign *= 2;
            }
	        pwfex->nAvgBytesPerSec = pwfex->nSamplesPerSec * pwfex->nBlockAlign;
            pwfex->cbSize = 0;
            pFmtGuid = &SPDFID_WaveFormatEx;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        *ppCoMemWaveFormatEx = NULL;
        switch (eFormat)
        {
        case SPSF_NoAssignedFormat:
            break;
        case SPSF_Text:
            pFmtGuid = &SPDFID_Text;
            break;
        default:
            hr = E_INVALIDARG;
            break;
        }
    }
    *pFormatId = *pFmtGuid;
    return hr;
}

class CSpStreamFormat
{
public:
    GUID            m_guidFormatId;
    WAVEFORMATEX  * m_pCoMemWaveFormatEx; 


    static CoMemCopyWFEX(const WAVEFORMATEX * pSrc, WAVEFORMATEX ** ppCoMemWFEX)
    {
        ULONG cb = sizeof(WAVEFORMATEX) + pSrc->cbSize;
        *ppCoMemWFEX = (WAVEFORMATEX *)::CoTaskMemAlloc(cb);
        if (*ppCoMemWFEX)
        {
            memcpy(*ppCoMemWFEX, pSrc, cb);
            return S_OK;
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }


    CSpStreamFormat()
    {
        memset(&m_guidFormatId, 0, sizeof(m_guidFormatId));
        m_pCoMemWaveFormatEx = NULL;
    }

    CSpStreamFormat(SPSTREAMFORMAT eFormat, HRESULT * phr)
    {
        *phr = SpConvertStreamFormatEnum(eFormat, &m_guidFormatId, &m_pCoMemWaveFormatEx);
    }

    CSpStreamFormat(const WAVEFORMATEX * pWaveFormatEx, HRESULT * phr)
    {
        SPDBG_ASSERT(pWaveFormatEx);
        *phr = CoMemCopyWFEX(pWaveFormatEx, &m_pCoMemWaveFormatEx);
        m_guidFormatId = SUCCEEDED(*phr) ? SPDFID_WaveFormatEx : GUID_NULL;
    }

    ~CSpStreamFormat()
    {
        ::CoTaskMemFree(m_pCoMemWaveFormatEx);
    }

    void Clear()
    {
        ::CoTaskMemFree(m_pCoMemWaveFormatEx);
        m_pCoMemWaveFormatEx = NULL;
        memset(&m_guidFormatId, 0, sizeof(m_guidFormatId));
    }

    const GUID & FormatId() const 
    {
        return m_guidFormatId;
    }

    const WAVEFORMATEX * WaveFormatExPtr() const
    {
        return m_pCoMemWaveFormatEx;
    }


    HRESULT AssignFormat(SPSTREAMFORMAT eFormat)
    {
        ::CoTaskMemFree(m_pCoMemWaveFormatEx);    
        return SpConvertStreamFormatEnum(eFormat, &m_guidFormatId, &m_pCoMemWaveFormatEx);
    }

    HRESULT AssignFormat(ISpStreamFormat * pStream)
    {
        ::CoTaskMemFree(m_pCoMemWaveFormatEx);
        m_pCoMemWaveFormatEx = NULL;
        return pStream->GetFormat(&m_guidFormatId, &m_pCoMemWaveFormatEx);
    }

    HRESULT AssignFormat(const WAVEFORMATEX * pWaveFormatEx)
    {
        ::CoTaskMemFree(m_pCoMemWaveFormatEx);
        HRESULT hr = CoMemCopyWFEX(pWaveFormatEx, &m_pCoMemWaveFormatEx);
        m_guidFormatId = SUCCEEDED(hr) ? SPDFID_WaveFormatEx : GUID_NULL;
        return hr;
    }

    HRESULT AssignFormat(REFGUID rguidFormatId, const WAVEFORMATEX * pWaveFormatEx)
    {
        HRESULT hr = S_OK;

        m_guidFormatId = rguidFormatId;
        ::CoTaskMemFree(m_pCoMemWaveFormatEx);
        m_pCoMemWaveFormatEx = NULL;

        if (rguidFormatId == SPDFID_WaveFormatEx)
        {
            if (::IsBadReadPtr(pWaveFormatEx, sizeof(*pWaveFormatEx)))
            {
                hr = E_INVALIDARG;
            }
            else 
            {
                hr = CoMemCopyWFEX(pWaveFormatEx, &m_pCoMemWaveFormatEx);
            }

            if (FAILED(hr))
            {
                m_guidFormatId = GUID_NULL;
            }
        }

        return hr;
    }


    BOOL IsEqual(REFGUID rguidFormatId, const WAVEFORMATEX * pwfex) const
    {
        if (rguidFormatId == m_guidFormatId)
        {
            if (m_pCoMemWaveFormatEx)
            {
                if (pwfex &&
                    pwfex->cbSize == m_pCoMemWaveFormatEx->cbSize &&
                    memcmp(m_pCoMemWaveFormatEx, pwfex, sizeof(WAVEFORMATEX) + pwfex->cbSize) == 0)
                {
                    return TRUE;
                }
            }
            else
            {
                return (pwfex == NULL);
            }
        }
        return FALSE;
    }



    HRESULT ParamValidateAssignFormat(REFGUID rguidFormatId, const WAVEFORMATEX * pWaveFormatEx, BOOL fRequireWaveFormat = FALSE)
    {
        if ((pWaveFormatEx && (::IsBadReadPtr(pWaveFormatEx, sizeof(*pWaveFormatEx)) || rguidFormatId != SPDFID_WaveFormatEx)) ||
            (fRequireWaveFormat && pWaveFormatEx == NULL))
        {
            return E_INVALIDARG;
        }
        return AssignFormat(rguidFormatId, pWaveFormatEx);
    }

    SPSTREAMFORMAT ComputeFormatEnum()
    {
        if (m_guidFormatId == GUID_NULL)
        {
            return SPSF_NoAssignedFormat;
        }
        if (m_guidFormatId == SPDFID_Text)
        {
            return SPSF_Text;
        }
        if (m_guidFormatId != SPDFID_WaveFormatEx)
        {
            return SPSF_NonStandardFormat;
        }
        //
        //  It is a WAVEFORMATEX.  Now determine if it's a standard enum or not.
        //
        DWORD dwIndex = 0;
        if (m_pCoMemWaveFormatEx->wFormatTag != WAVE_FORMAT_PCM)
        {
            return SPSF_ExtendedAudioFormat;
        }
        switch (m_pCoMemWaveFormatEx->nChannels)
        {
        case 1:
            break;
        case 2:
            dwIndex |= 1;
            break;
        default:
            return SPSF_ExtendedAudioFormat;
        }
        switch (m_pCoMemWaveFormatEx->wBitsPerSample)
        {
        case 8:
            break;
        case 16:
            dwIndex |= 2;
            break;
        default:
            return SPSF_ExtendedAudioFormat;
        }
        switch (m_pCoMemWaveFormatEx->nSamplesPerSec)
        {
        case 48000:
            dwIndex += 4;   // Fall through
        case 44100:
            dwIndex += 4;   // Fall through
        case 32000:
            dwIndex += 4;   // Fall through
        case 24000:
            dwIndex += 4;   // Fall through
        case 22050:
            dwIndex += 4;   // Fall through
        case 16000:
            dwIndex += 4;   // Fall through
        case 12000:
            dwIndex += 4;   // Fall through
        case 11025:
            dwIndex += 4;   // Fall through
        case 8000:
            break;
        default:
            return SPSF_ExtendedAudioFormat;
        }
        return static_cast<SPSTREAMFORMAT>(SPSF_8kHz8BitMono + dwIndex);
    }

    void DetachTo(CSpStreamFormat & Other)
    {
        ::CoTaskMemFree(Other.m_pCoMemWaveFormatEx);
        Other.m_guidFormatId = m_guidFormatId;
        Other.m_pCoMemWaveFormatEx = m_pCoMemWaveFormatEx;
        m_pCoMemWaveFormatEx = NULL;
        memset(&m_guidFormatId, 0, sizeof(m_guidFormatId));
    }

    void DetachTo(GUID * pFormatId, WAVEFORMATEX ** ppCoMemWaveFormatEx)
    {
        *pFormatId = m_guidFormatId;
        *ppCoMemWaveFormatEx = m_pCoMemWaveFormatEx;
        m_pCoMemWaveFormatEx = NULL;
        memset(&m_guidFormatId, 0, sizeof(m_guidFormatId));
    }

    HRESULT CopyTo(GUID * pFormatId, WAVEFORMATEX ** ppCoMemWFEX) const
    {
        HRESULT hr = S_OK;
        *pFormatId = m_guidFormatId;
        if (m_pCoMemWaveFormatEx)
        {
            hr = CoMemCopyWFEX(m_pCoMemWaveFormatEx, ppCoMemWFEX);
            if (FAILED(hr))
            {
                memset(pFormatId, 0, sizeof(*pFormatId));
            }
        }
        else
        {
            *ppCoMemWFEX = NULL;
        }
        return hr;
    }

    HRESULT CopyTo(CSpStreamFormat & Other) const
    {
        ::CoTaskMemFree(Other.m_pCoMemWaveFormatEx);
        return CopyTo(&Other.m_guidFormatId, &Other.m_pCoMemWaveFormatEx);
    }
    
    HRESULT AssignFormat(const CSpStreamFormat & Src)
    {
        return Src.CopyTo(*this);
    }


    HRESULT ParamValidateCopyTo(GUID * pFormatId, WAVEFORMATEX ** ppCoMemWFEX) const
    {
        if (::IsBadWritePtr(pFormatId, sizeof(*pFormatId)) ||
            ::IsBadWritePtr(ppCoMemWFEX, sizeof(*ppCoMemWFEX)))
        {
            return E_POINTER;
        }
        return CopyTo(pFormatId, ppCoMemWFEX);
    }

    BOOL operator==(const CSpStreamFormat & Other) const
    {
        return IsEqual(Other.m_guidFormatId, Other.m_pCoMemWaveFormatEx);
    }
    BOOL operator!=(const CSpStreamFormat & Other) const
    {
        return !IsEqual(Other.m_guidFormatId, Other.m_pCoMemWaveFormatEx);
    }

    ULONG SerializeSize() const
    {
        ULONG cb = sizeof(ULONG) + sizeof(m_guidFormatId);
        if (m_pCoMemWaveFormatEx)
        {
            cb += sizeof(WAVEFORMATEX) + m_pCoMemWaveFormatEx->cbSize + 3;  // Add 3 to round up
            cb -= cb % 4;                                                   // Round to DWORD
        }
        return cb;
    }

    ULONG Serialize(BYTE * pBuffer) const
    {
        ULONG cb = SerializeSize();
        *((ULONG *)pBuffer) = cb;
        pBuffer += sizeof(ULONG);
        *((GUID *)pBuffer) = m_guidFormatId;
        if (m_pCoMemWaveFormatEx)
        {
            pBuffer += sizeof(m_guidFormatId);
            memcpy(pBuffer, m_pCoMemWaveFormatEx, sizeof(WAVEFORMATEX) + m_pCoMemWaveFormatEx->cbSize);
        }
        return cb;
    }

    HRESULT Deserialize(const BYTE * pBuffer, ULONG * pcbUsed)
    {
        HRESULT hr = S_OK;
        ::CoTaskMemFree(m_pCoMemWaveFormatEx);
        m_pCoMemWaveFormatEx = NULL;
        *pcbUsed = *((ULONG *)pBuffer);
        pBuffer += sizeof(ULONG);
        m_guidFormatId = *((GUID *)pBuffer);
        if (*pcbUsed > sizeof(GUID) + sizeof(ULONG))
        {
            pBuffer += sizeof(m_guidFormatId);
            hr = CoMemCopyWFEX((const WAVEFORMATEX *)pBuffer, &m_pCoMemWaveFormatEx);
            if (FAILED(hr))
            {
                m_guidFormatId = GUID_NULL;
            }
        }
        return hr;
    }

};


/*
inline BOOL SPGuidToWaveFormatEx(REFGUID rguidFmt, WAVEFORMATEX * pWFEX)
{
    if (!SPIsValidPCMFormat(rguidFmt))
    {
        return FALSE;
    }
    BOOL bIsStereo = rguidFmt.Data1 & 0x1;
    BOOL bIs16 = rguidFmt.Data1 & 0x2;
    DWORD dwKHZ = (rguidFmt.Data1 & 0x1c) >> 2;
    static const DWORD aKHZ[] = { 8000, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000 };
    pWFEX->wFormatTag = WAVE_FORMAT_PCM;
    pWFEX->nChannels = pWFEX->nBlockAlign = bIsStereo ? 2 : 1;
    pWFEX->nSamplesPerSec = aKHZ[dwKHZ];
    pWFEX->wBitsPerSample = 8;
    if (bIs16)
    {
        pWFEX->wBitsPerSample *= 2;
        pWFEX->nBlockAlign *= 2;
    }
	pWFEX->nAvgBytesPerSec = pWFEX->nSamplesPerSec * pWFEX->nBlockAlign;
    pWFEX->cbSize = 0;
    return TRUE;
}
*/




/*****************************************************************************
* SPOpenWavFile *
*---------------*
*   Description:
*       This method 
********************************************************************* RAL ***
inline HRESULT SPOpenWavFile(const WCHAR * pszFileName, ISpWavStream ** ppStream, ULONGLONG ullEventInterest = SPFEI_ALL_EVENTS)
{
    HRESULT hr = ::CoCreateInstance(CLSID_SpWavStream, NULL, CLSCTX_ALL, __uuidof(*ppStream), (void **)ppStream);
    if (SUCCEEDED(hr))
    {
        hr = (*ppStream)->Open(pszFileName, ullEventInterest);
        if (FAILED(hr))
        {
            (*ppStream)->Release();
            *ppStream = NULL;
        }
    }
    return hr;
}

/*****************************************************************************
* SPCreateWavFile *
*-----------------*
*   Description:
*       This method 
********************************************************************* RAL ***
inline HRESULT SPCreateWavFile( const WCHAR * pszFileName, REFGUID rguidFormatId, const WAVEFORMATEX * pWFEX,
                                ISpWavStream ** ppStream, ULONGLONG ullEventInterest = SPFEI_ALL_EVENTS)
{
    HRESULT hr = ::CoCreateInstance(CLSID_SpWavStream, NULL, CLSCTX_ALL, __uuidof(*ppStream), (void **)ppStream);
    if (SUCCEEDED(hr))
    {
        if (SUCCEEDED(hr))
        {
            hr = (*ppStream)->Create(pszFileName, rguidFormatId, pWFEX, ullEventInterest);
        }
        if (FAILED(hr))
        {
            (*ppStream)->Release();
        }
    }
    return hr;
}
*/


// Return the default codepage given a LCID.
// Note some of the newer locales do not have associated Windows codepages.  For these, we return UTF-8.

inline UINT SpCodePageFromLcid(LCID lcid)
{
    char achCodePage[6];

    return (0 != GetLocaleInfoA(lcid, LOCALE_IDEFAULTANSICODEPAGE, achCodePage, sizeof(achCodePage))) ? atoi(achCodePage) : 65001;
}

// This tweaks the ATL conversion macros A2W, W2T, etc., to use a designated codepage

#define USES_CODEPAGE_CONVERSION(cp) USES_CONVERSION; _acp=(cp);


inline HRESULT SPBindToFile( LPCWSTR pFileName, SPFILEMODE eMode, ISpStream ** ppStream,
                            const GUID * pFormatId = NULL, const WAVEFORMATEX * pWaveFormatEx = NULL,
                            ULONGLONG ullEventInterest = SPFEI_ALL_EVENTS)
{
    HRESULT hr = ::CoCreateInstance(CLSID_SpStream, NULL, CLSCTX_ALL, __uuidof(*ppStream), (void **)ppStream);
    if (SUCCEEDED(hr))
    {
        hr = (*ppStream)->BindToFile(pFileName, eMode, pFormatId, pWaveFormatEx, ullEventInterest);
        if (FAILED(hr))
        {
            (*ppStream)->Release();
            *ppStream = NULL;
        }
    }
    return hr;
} /* SPBindToFile */

#ifndef _UNICODE
inline HRESULT SPBindToFile( const TCHAR * pFileName, SPFILEMODE eMode, ISpStream** ppStream, 
                             const GUID * pFormatId = NULL, const WAVEFORMATEX * pWaveFormatEx = NULL,
                             ULONGLONG ullEventInterest = SPFEI_ALL_EVENTS)
{
    WCHAR szWcharFileName[MAX_PATH];
    ::MultiByteToWideChar(CP_ACP, 0, pFileName, -1, szWcharFileName, sp_countof(szWcharFileName));
    return SPBindToFile(szWcharFileName, eMode, ppStream, pFormatId, pWaveFormatEx, ullEventInterest);
}
#endif

/****************************************************************************
* SPCreateStreamOnHGlobal *
*-------------------------*
*   Description:
*       Similar to CreateStreamOnHGlobal Win32 API, but allows a stream to be
*   created 
*
*   Returns:
*
********************************************************************* RAL ***/

inline HRESULT SPCreateStreamOnHGlobal(
                    HGLOBAL hGlobal,            //Memory handle for the stream object
                    BOOL fDeleteOnRelease,      //Whether to free memory when the object is released
                    REFGUID rguidFormatId,      //Format ID for stream
                    const WAVEFORMATEX * pwfex, //WaveFormatEx for stream
                    ISpStream ** ppStream)      //Address of variable to receive ISpStream pointer
{
    HRESULT hr;
    IStream * pMemStream;
    *ppStream = NULL;
    hr = ::CreateStreamOnHGlobal(hGlobal, fDeleteOnRelease, &pMemStream);
    if (SUCCEEDED(hr))
    {
        hr = ::CoCreateInstance(CLSID_SpStream, NULL, CLSCTX_ALL, __uuidof(*ppStream), (void **)ppStream);
        if (SUCCEEDED(hr))
        {
            hr = (*ppStream)->SetBaseStream(pMemStream, rguidFormatId, pwfex);
            if (FAILED(hr))
            {
                (*ppStream)->Release();
                *ppStream = NULL;
            }
        }
        pMemStream->Release();
    }
    return hr;
}

/****************************************************************************
* SPGetHGlobalFromStream *
*------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

inline HRESULT SPGetHGlobalFromStream(ISpStream * pStream, HGLOBAL * phGlobal)
{
    HRESULT hr;
    IStream * pMemStream;
    *phGlobal = NULL;
    hr = pStream->GetBaseStream(&pMemStream);
    if (hr == S_OK)
    {
        hr = ::GetHGlobalFromStream(pMemStream, phGlobal);
        pMemStream->Release();
    }
    else
    {
        if (SUCCEEDED(hr))  // Convert S_FALSE from GetBaseStream into an error for this method
        {
            hr = E_INVALIDARG;
        }
    }
    return hr;
}



inline HRESULT SPGetRelativePath( HMODULE hModule, const TCHAR* pCmnRoot,
                                  const TCHAR* pRelPath, TCHAR* pAbsPath )
{
    HRESULT hr = S_OK;
    TCHAR Buff[MAX_PATH];

    ULONG CmnLen = ::GetModuleFileName( hModule, Buff, sizeof( Buff ) );
    if( !CmnLen )
    {
        hr = HRESULT_FROM_WIN32( ::GetLastError() );
    }
    else
    {
        //--- Get last occurence of common root
        BOOL fRootFound = false;
        size_t Count = _tcslen( pCmnRoot );
        TCHAR *pRoot = _tcsrchr( Buff, '\\' );
        while( --pRoot > Buff )
        {
            if( ( tolower(*pRoot) == tolower(*pCmnRoot) ) &&
                 !_tcsnicmp( pRoot, pCmnRoot, Count ) )
            {
                fRootFound = true;
                break;
            }
        }

        if( fRootFound )
        {
            CmnLen = (pRoot + Count) - Buff;
            _tcsncpy( pAbsPath, Buff, CmnLen );
            pAbsPath[CmnLen++] = '\\';
            pAbsPath[CmnLen]   = 0;
            if( pRelPath )
            {
                _tcscpy( &pAbsPath[CmnLen], pRelPath );
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    return hr;
} /* SPGetRelativePath */


/****************************************************************************
* SpClearEvent *
*--------------*
*   Description:
*       Helper function that can be used by clients that do not use the CSpEvent
*   class.
*
*   Returns:
*
********************************************************************* RAL ***/

inline void SpClearEvent(SPEVENT * pe)
{
    if( pe->elParamType != SPEI_UNDEFINED)
    {
        if( pe->elParamType == SPET_LPARAM_IS_POINTER ||
            pe->elParamType == SPET_LPARAM_IS_STRING)
        {
            ::CoTaskMemFree((void *)pe->lParam);
        }
        else if (pe->elParamType == SPET_LPARAM_IS_TOKEN ||
               pe->elParamType == SPET_LPARAM_IS_OBJECT)
        {
            ((IUnknown*)pe->lParam)->Release();
        }
        memset(pe, 0, sizeof(*pe));
    }
}
/****************************************************************************
* SpInitEvent *
*-------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

inline void SpInitEvent(SPEVENT * pe)
{
    memset(pe, 0, sizeof(*pe));
}

/*** CSpEvent helper class
*
*/
class CSpEvent : public SPEVENT
{
public:
    CSpEvent()
    {
        SpInitEvent(this);
    }
    ~CSpEvent()
    {
        SpClearEvent(this);
    }
    // If you need to take the address of a CSpEvent that is not const, use the AddrOf() method
    // which will do debug checking of parameters.  If you encounter this problem when calling
    // GetEvents from an event source, you may want to use the GetFrom() method of this class.
    const SPEVENT * operator&()
	{
		return this;
	}
    SPEVENT * AddrOf()
    {
        // Note:  This method does not ASSERT since we assume the caller knows what they are doing.
        return this;
    }
    void Clear()
    {
        SpClearEvent(this);
    }
    HRESULT CopyTo(SPEVENT * pDestEvent) const
    {
        memcpy(pDestEvent, this, sizeof(*pDestEvent));
        if ((elParamType == SPET_LPARAM_IS_POINTER) && lParam)
        {
            SPDBG_ASSERT(wParam && (wParam < 0x100000));    // this is too big!
            pDestEvent->lParam = (LPARAM)::CoTaskMemAlloc(wParam);
            if (pDestEvent->lParam)
            {
                memcpy((void *)pDestEvent->lParam, (void *)lParam, wParam);
            }
            else
            {
                pDestEvent->eEventId = SPEI_UNDEFINED;
                return E_OUTOFMEMORY;
            }
        }
        else if (elParamType == SPET_LPARAM_IS_STRING && lParam != NULL)
        {
            pDestEvent->lParam = (LPARAM)::CoTaskMemAlloc((wcslen((WCHAR*)lParam) + 1) * sizeof(WCHAR));
            if (pDestEvent->lParam)
            {
                wcscpy((WCHAR*)pDestEvent->lParam, (WCHAR*)lParam);
            }
            else
            {
                pDestEvent->eEventId = SPEI_UNDEFINED;
                return E_OUTOFMEMORY;
            }
        }
        else if (elParamType == SPET_LPARAM_IS_TOKEN ||
               elParamType == SPET_LPARAM_IS_OBJECT)
        {
            ((IUnknown*)lParam)->AddRef();
        }
        return S_OK;
    }

    HRESULT GetFrom(ISpEventSource * pEventSrc)
    {
        SpClearEvent(this);
        return pEventSrc->GetEvents(1, this, NULL);
    }
    HRESULT CopyFrom(const SPEVENT * pSrcEvent)
    {
        SpClearEvent(this);
        return static_cast<const CSpEvent *>(pSrcEvent)->CopyTo(this);
    }
    void Detach(SPEVENT * pDestEvent = NULL)
    {
        if (pDestEvent)
        {
            memcpy(pDestEvent, this, sizeof(*pDestEvent));
        }
        memset(this, 0, sizeof(*this));
    }

    //
    //  NOTE:  It is OK to call this function with an event that is serialized -- It will return
    //         the size of the serialized data.  It is also OK to call this for events that are
    //         not serialized.
    //
    static ULONG SerializeSize(const SPEVENT *pEvent)
    {
        SPDBG_ASSERT(pEvent->elParamType != SPET_LPARAM_IS_OBJECT);
        ULONG ulSize = sizeof(SPSERIALIZEDEVENT);
        if( ( pEvent->elParamType == SPET_LPARAM_IS_POINTER ) && pEvent->lParam )
        {
            //--- Round up to nearest DWORD multiple
            ulSize += ((pEvent->wParam + 3) / 4) * 4;
        }
        else if ((pEvent->elParamType == SPET_LPARAM_IS_STRING) && pEvent->lParam != NULL)
        {
            //--- Round up to nearest DWORD multiple
            ulSize += (((wcslen((WCHAR*)pEvent->lParam) + 1) * 2 + 3) / 4) * 4;
        }
        else if( pEvent->elParamType == SPET_LPARAM_IS_TOKEN )
        {
            CSpDynamicString dstrObjectId;
            if( ((ISpObjectToken*)(pEvent->lParam))->GetId( &dstrObjectId ) == S_OK )
            {
                ulSize += (dstrObjectId.Length() + 1) * sizeof( WCHAR );
            }
        }
        return ulSize;
    } /* SerializeSize */

    ULONG SerializeSize(void) const
    {
        return SerializeSize(this);
    }
    void Serialize(BYTE * pBuffer) const
    {
        SPDBG_ASSERT(elParamType != SPET_LPARAM_IS_OBJECT);
        SPSERIALIZEDEVENT * pSerEvent = (SPSERIALIZEDEVENT *)pBuffer;
        pSerEvent->eEventId = this->eEventId;
        pSerEvent->elParamType = this->elParamType;
        pSerEvent->ulStreamNum = this->ulStreamNum;
        pSerEvent->ullAudioStreamOffset = this->ullAudioStreamOffset;
        pSerEvent->SerializedwParam = static_cast<ULONG>(this->wParam);
        pSerEvent->SerializedlParam = static_cast<LONG>(this->lParam);
        if (lParam)
        {
            switch(elParamType)
            {
            case SPET_LPARAM_IS_POINTER:
                memcpy(pBuffer + sizeof(*pSerEvent), (void *)lParam, wParam);
                pSerEvent->SerializedlParam = sizeof(*pSerEvent);
                break;

            case SPET_LPARAM_IS_STRING:
                wcscpy((WCHAR *)(pBuffer + sizeof(*this)), (WCHAR*)lParam);
                pSerEvent->SerializedlParam = sizeof(*pSerEvent);
                break;

            case SPET_LPARAM_IS_TOKEN:
                {
                    CSpDynamicString dstrObjectId;
                    if( SUCCEEDED( ((ISpObjectToken*)lParam)->GetId( &dstrObjectId ) ) )
                    {
                        pSerEvent->SerializedwParam = (dstrObjectId.Length() + 1) * sizeof( WCHAR );;
                        memcpy( pBuffer + sizeof(*pSerEvent), (void *)dstrObjectId.m_psz, pSerEvent->SerializedwParam );
                    }
                    pSerEvent->SerializedlParam = sizeof(*pSerEvent);
                }
                break;

            default:
                break;
            }
        }
    }

    HRESULT Deserialize(const BYTE * pBuffer, ULONG * pcbUsed)
    {
        SPDBG_ASSERT(eEventId == SPEI_UNDEFINED);
        HRESULT hr = S_OK;
        const SPSERIALIZEDEVENT * pSerEvent = (SPSERIALIZEDEVENT *)pBuffer;
        this->eEventId = pSerEvent->eEventId;
        this->elParamType = pSerEvent->elParamType;
        this->ulStreamNum = pSerEvent->ulStreamNum;
        this->ullAudioStreamOffset = pSerEvent->ullAudioStreamOffset;
        this->wParam = pSerEvent->SerializedwParam;
        this->lParam = pSerEvent->SerializedlParam;
        if (pSerEvent->SerializedlParam)
        {
            switch (pSerEvent->elParamType)
            {
            case SPET_LPARAM_IS_POINTER:
                {
                    ULONG ulDataOffset = lParam;
                    lParam = (LPARAM)::CoTaskMemAlloc(wParam);
                    if (lParam)
                    {
                        memcpy((void *)lParam, pBuffer + ulDataOffset, wParam);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
                break;

            case SPET_LPARAM_IS_STRING:
                {
                    const WCHAR * psz = (const WCHAR*)(pBuffer + lParam);
                    ULONG cch = wcslen(psz) + 1;

                    lParam = (LPARAM)::CoTaskMemAlloc(cch * sizeof(WCHAR));
                    if (lParam)
                    {
                        wcscpy((WCHAR*)lParam, psz);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
                break;

            case SPET_LPARAM_IS_TOKEN:
                {
                    ULONG ulDataOffset = lParam;
                    hr = SpGetTokenFromId( (const WCHAR*)(pBuffer + ulDataOffset),
                                                  (ISpObjectToken **)&lParam );
                    wParam = 0;
                }
                break;
            }
        }

        if( SUCCEEDED( hr ) && pcbUsed )
        {
            *pcbUsed = SerializeSize();
        }
        return hr;
    }

    //
    //  Helpers for access to events.  Performs run-time checks in debug and casts
    //  data to the appropriate types
    //
    SPPHONEID Phoneme() const 
    {
        SPDBG_ASSERT(eEventId == SPEI_PHONEME);
        return (SPPHONEID)LOWORD(lParam);
    }
    SPVISEMES Viseme() const 
    {
        SPDBG_ASSERT(eEventId == SPEI_VISEME);
        return (SPVISEMES)LOWORD(lParam);
    }
    ULONG InputWordPos() const
    {
        SPDBG_ASSERT(eEventId == SPEI_WORD_BOUNDARY);
        return lParam;
    }
    ULONG InputWordLen() const 
    {
        SPDBG_ASSERT(eEventId == SPEI_WORD_BOUNDARY);
        return wParam;
    }
    ULONG InputSentPos() const
    {
        SPDBG_ASSERT(eEventId == SPEI_SENTENCE_BOUNDARY);
        return lParam;
    }
    ULONG InputSentLen() const 
    {
        SPDBG_ASSERT(eEventId == SPEI_SENTENCE_BOUNDARY);
        return wParam;
    }
    ISpObjectToken * ObjectToken() const
    {
        SPDBG_ASSERT(elParamType == SPET_LPARAM_IS_TOKEN);
        return (ISpObjectToken *)lParam;
    }
    ISpObjectToken * VoiceToken() const     // More explicit check than ObjectToken()
    {
        SPDBG_ASSERT(eEventId == SPEI_VOICE_CHANGE);
        return ObjectToken();
    }
    BOOL PersistVoiceChange() const
    {
        SPDBG_ASSERT(eEventId == SPEI_VOICE_CHANGE);
        return (BOOL)wParam;
    }
    IUnknown * Object() const
    {
        SPDBG_ASSERT(elParamType == SPET_LPARAM_IS_OBJECT);
        return (IUnknown*)lParam;
    }
    ISpRecoResult * RecoResult() const
    {
        SPDBG_ASSERT(eEventId == SPEI_RECOGNITION || eEventId == SPEI_FALSE_RECOGNITION || eEventId == SPEI_HYPOTHESIS);
        return (ISpRecoResult *)Object();
    }
    BOOL IsPaused()
    {
        SPDBG_ASSERT(eEventId == SPEI_RECOGNITION || eEventId == SPEI_SR_BOOKMARK);
        return (wParam & SPREF_AutoPause);
    }
    const WCHAR * String() const
    {
        SPDBG_ASSERT(elParamType == SPET_LPARAM_IS_STRING);
        return (const WCHAR*)lParam;
    }
    const WCHAR * BookmarkName() const
    {
        SPDBG_ASSERT(eEventId == SPEI_TTS_BOOKMARK);
        return String();
    }
    const WCHAR * RequestTypeOfUI() const
    {
        SPDBG_ASSERT(eEventId == SPEI_REQUEST_UI);
        return String();
    }
    SPRECOSTATE RecoState() const
    {
        SPDBG_ASSERT(eEventId == SPEI_RECO_STATE_CHANGE);
        return static_cast<SPRECOSTATE>(wParam);
    }
    const WCHAR * PropertyName() const
    {
        SPDBG_ASSERT((eEventId == SPEI_PROPERTY_NUM_CHANGE && elParamType == SPET_LPARAM_IS_STRING) ||
                     (eEventId == SPEI_PROPERTY_STRING_CHANGE && elParamType == SPET_LPARAM_IS_POINTER));
        // Note: Don't use String() method here since in the case of string attributes, the elParamType
        // field specifies LPARAM_IS_POINTER, but the attribute name IS the first string in this buffer
        return (const WCHAR*)lParam;
    }
    const LONG PropertyNumValue() const 
    {
        SPDBG_ASSERT(eEventId == SPEI_PROPERTY_NUM_CHANGE);
        return static_cast<LONG>(wParam);
    }
    const WCHAR * PropertyStringValue() const
    {
        // Search for the first NULL and return pointer to the char past it.
        SPDBG_ASSERT(eEventId == SPEI_PROPERTY_STRING_CHANGE);
        for (const WCHAR * psz = (const WCHAR *)lParam; *psz; psz++) {}
        return psz + 1;
    }
    SPINTERFERENCE Interference() const
    {
        SPDBG_ASSERT(eEventId == SPEI_INTERFERENCE);
        return static_cast<SPINTERFERENCE>(lParam);
    }
};


class CSpPhrasePtr
{
public:
    SPPHRASE    *   m_pPhrase;
    CSpPhrasePtr() : m_pPhrase(NULL) {}
    CSpPhrasePtr(ISpPhrase * pPhraseObj, HRESULT * phr)
    {
        *phr = pPhraseObj->GetPhrase(&m_pPhrase);
    }
    ~CSpPhrasePtr()
    {
        ::CoTaskMemFree(m_pPhrase);
    }
	//The assert on operator& usually indicates a bug.  If this is really
	//what is needed, however, take the address of the m_pPhrase member explicitly.
	SPPHRASE ** operator&()
	{
        SPDBG_ASSERT(m_pPhrase == NULL);
		return &m_pPhrase;
	}
    operator SPPHRASE *() const
    {
        return m_pPhrase;
    }
	SPPHRASE & operator*() const
	{
		SPDBG_ASSERT(m_pPhrase);
		return *m_pPhrase;
	}
    SPPHRASE * operator->() const
    {
        return m_pPhrase;
    }
	bool operator!() const
	{
		return (m_pPhrase == NULL);
	}
    void Clear()
    {
        if (m_pPhrase)
        {
            ::CoTaskMemFree(m_pPhrase);
            m_pPhrase = NULL;
        }
    }
    HRESULT GetFrom(ISpPhrase * pPhraseObj)
    {
        Clear();
        return pPhraseObj->GetPhrase(&m_pPhrase);
    }
    /*
    const WCHAR * TextValueOfId(ULONG IdProp)
    {
        SPDBG_ASSERT(m_pPhrase);
        SPPROPERTY * pCur = m_pPhrase->pProperties;
        SPPROPERTY * pPastEnd = pCur + m_pPhrase->cProperties;
        while (pCur < pPastEnd)
        {
            if (pCur->ulNameId == IdProp)
            {
                return pCur->pszValue;
            }
            pCur++;
        }
        return NULL;
    }
    HRESULT ElementInfoOfId(const ULONG IdProp, ULONG *pulFirstElement, ULONG *pulCountOfElements)
    {
        SPDBG_ASSERT(m_pPhrase);
        *pulFirstElement = *pulCountOfElements = 0;
        SPPROPERTY * pCur = m_pPhrase->pProperties;
        SPPROPERTY * pPastEnd = pCur + m_pPhrase->cProperties;
        while (pCur < pPastEnd)
        {
            if (pCur->ulNameId == IdProp)
            {
                *pulFirstElement = pCur->ulFirstElement;
                *pulCountOfElements = pCur->ulCountOfElements;
                return S_OK;
            }
            pCur++;
        }
        return E_FAIL;
    }
    */
};


template <class T>
class CSpCoTaskMemPtr
{
public:
    T       * m_pT;
    CSpCoTaskMemPtr() : m_pT(NULL) {}
    CSpCoTaskMemPtr(void * pv) : m_pT((T *)pv) {}
    CSpCoTaskMemPtr(ULONG cElements, HRESULT * phr)
    {
        m_pT = (T *)::CoTaskMemAlloc(cElements * sizeof(T));
        *phr = m_pT ? S_OK : E_OUTOFMEMORY;
    }
    ~CSpCoTaskMemPtr()
    {
        ::CoTaskMemFree(m_pT);
    }
    void Clear()
    {
        if (m_pT)
        {
            ::CoTaskMemFree(m_pT);
            m_pT = NULL;
        }
    }
    HRESULT Alloc(ULONG cArrayElements)
    {
        m_pT = (T *)::CoTaskMemRealloc(m_pT, sizeof(T) * cArrayElements);
        SPDBG_ASSERT(m_pT);
        return (m_pT ? S_OK : E_OUTOFMEMORY);
    }
    void Attach(void * pv)
    {
        Clear();
        m_pT = (T *)pv;
    }
    T * Detatch()
    {
        T * pT = m_pT;
        m_pT = NULL;
        return pT;
    }
    T * operator =(const T & val)
    {
        Clear();
        m_pT = (T *)::CoTaskMemAlloc(sizeof(T));
        SPDBG_ASSERT(m_pT);
        if (m_pT)
        {
            memcpy(m_pT, &val, sizeof(val));
        }
        return m_pT;
    }
	//The assert on operator& usually indicates a bug.  If this is really
	//what is needed, however, take the address of the m_pT member explicitly.
	T ** operator&()
	{
        SPDBG_ASSERT(m_pT == NULL);
		return &m_pT;
	}
    operator T *()
    {
        return m_pT;
    }
	bool operator!() const
	{
		return (m_pT == NULL);
	}
};

#ifndef _WIN32_WCE

//
//  The compiler will automatically throw out the inline functions if _UNICODE is defined and simply
//  directly call the Win32 function.  Unfortunately, this requires two classes since simply defining
//  const m_bUnicodeSupport does not force the functions to be inlined when built with _UNICODE.
//
template <BOOL bUnicodeOnly>
class CSpUnicodeSupportT
{
    BOOL    m_bUnicodeSupport;
public:
    CSpUnicodeSupportT()
    {
        if (!bUnicodeOnly)
        {
            m_bUnicodeSupport = ::IsWindowUnicode(::GetDesktopWindow());
        }
    }
    CSpUnicodeSupportT(BOOL bUnicodeSupport)
    {
        if (bUnicodeOnly)
        {
            SPDBG_ASSERT(bUnicodeSupport);
        }
        else
        {
            m_bUnicodeSupport = bUnicodeSupport;
        }
    }
    BOOL UnicodeSystem(void) const 
    {
        if (bUnicodeOnly)
        {
            return TRUE;
        }
        else
        {
            return m_bUnicodeSupport; 
        }
    }
    HANDLE CreateFile(const WCHAR * lpFileName,      
                      DWORD dwDesiredAccess,       
                      DWORD dwShareMode,           
                      LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                      DWORD dwCreationDisposition, 
                      DWORD dwFlagsAndAttributes,  
                      HANDLE hTemplateFile) const         
    {
        if (UnicodeSystem())
        {
            return ::CreateFileW(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, 
                                 dwFlagsAndAttributes, hTemplateFile);
        }
        else
        {
            return ::CreateFileA(CSpToAnsiString<>(lpFileName), dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, 
                                 dwFlagsAndAttributes, hTemplateFile);
        }
    }
    BOOL DeleteFile(LPCWSTR lpFileName)
    {
        if (UnicodeSystem())
        {
            return ::DeleteFileW(lpFileName);
        }
        else
        {
            return ::DeleteFileA(CSpToAnsiString<>(lpFileName));
        }
    }
    BOOL MoveFile(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
    {
        if (UnicodeSystem())
        {
            return ::MoveFileW(lpExistingFileName, lpNewFileName);
        }
        else
        {
            return ::MoveFileA(CSpToAnsiString<>(lpExistingFileName), CSpToAnsiString<>(lpNewFileName));
        }
    }
    BOOL CreateDirectory(const WCHAR * lpPathName,
                           LPSECURITY_ATTRIBUTES lpSecurityAttributes) const
    {
        if (UnicodeSystem())
        {
            return ::CreateDirectoryW(lpPathName, lpSecurityAttributes);
        }
        else
        {
            return ::CreateDirectoryA(CSpToAnsiString<>(lpPathName), lpSecurityAttributes);
        }
    }
    HANDLE CreateFileMapping(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect,
                             DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, const WCHAR *lpName)
    {
        if (UnicodeSystem())
        {
            return ::CreateFileMappingW(hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, 
                                        dwMaximumSizeLow, lpName);
        }
        else
        {
            return ::CreateFileMappingA(hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, 
                                        dwMaximumSizeLow, CSpToAnsiString<>(lpName));
        }
    }
    LONG RegOpenKeyEx(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult) const
    {
        if (UnicodeSystem())
        {
            return ::RegOpenKeyExW(hKey, lpSubKey, ulOptions, samDesired, phkResult);
        }
        else
        {
            return ::RegOpenKeyExA(hKey, CSpToAnsiString<>(lpSubKey), ulOptions, samDesired, phkResult);
        }
    }
    LONG RegCreateKeyEx(HKEY hk, LPCWSTR lpSubKey, DWORD dwReserved, LPCWSTR lpClass, DWORD dwOptions,
                        REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, 
                        LPDWORD lpdwDisposition) const
    {
        if (UnicodeSystem())
        {
            return ::RegCreateKeyExW(hk, lpSubKey, dwReserved, const_cast<WCHAR *>(lpClass), dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);
        }
        else
        {
            return ::RegCreateKeyExA(hk, CSpToAnsiString<>(lpSubKey), dwReserved, CSpToAnsiString<>(lpClass), dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);
        }
    }
    LONG RegDeleteKey(HKEY hKey, LPCWSTR lpSubKey) const
    {
        if (UnicodeSystem())
        {
            return ::RegDeleteKeyW(hKey, lpSubKey);
        }
        else
        {
            return ::RegDeleteKeyA(hKey, CSpToAnsiString<>(lpSubKey));
        }
    }
    LONG RegDeleteValue(HKEY hKey, LPCWSTR lpSubKey) const
    {
        if (UnicodeSystem())
        {
            return ::RegDeleteValueW(hKey, lpSubKey);
        }
        else
        {
            return ::RegDeleteValueA(hKey, CSpToAnsiString<>(lpSubKey));
        }
    }
    //
    //  Use RegQueryStringValue for strings.  Use this for binary data.
    //
    LONG RegQueryValueEx(HKEY hk, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData) const
    {
        if (UnicodeSystem())
        {
            return ::RegQueryValueExW(hk, lpValueName, NULL, lpType, lpData, lpcbData);
        }
        else
        {
            return ::RegQueryValueExA(hk, CSpToAnsiString<>(lpValueName), NULL, lpType, lpData, lpcbData);
        }
    }
    //
    //  NOTE:  The size parameter is in CHARACTERS!  Even though the registry API sizes are
    //         in bytes, this function uses character counts.
    //
    LONG RegQueryStringValue(HKEY hKey, LPCWSTR lpValueName, LPWSTR lpData, LPDWORD lpcchData) const
    {
        DWORD dwType;
        LONG rr;
        if (UnicodeSystem())
        {
            *lpcchData *= sizeof(WCHAR);
            rr = ::RegQueryValueExW(hKey, lpValueName, NULL, &dwType, (BYTE *)lpData, lpcchData);
            *lpcchData /= sizeof(WCHAR);
        }
        else
        {
            DWORD dwOrigCharCount = *lpcchData;
            char * pszScratch = lpData ? (char *)_alloca(dwOrigCharCount) : NULL;
            rr = ::RegQueryValueExA(hKey, CSpToAnsiString<>(lpValueName), NULL, &dwType, (BYTE *)pszScratch, lpcchData);
            if (lpData)
            {
                if (rr == ERROR_SUCCESS)
                {
                    *lpcchData = ::MultiByteToWideChar(CP_ACP, 0, pszScratch, -1, lpData, dwOrigCharCount);
                    if (*lpcchData == 0)
                    {
                        rr = ::GetLastError();
                        *lpcchData = ::MultiByteToWideChar(CP_ACP, 0, pszScratch, -1, NULL, 0);
                    }
                }
            }
        }
        SPDBG_ASSERT((rr != ERROR_SUCCESS) || (dwType == REG_SZ));
        return rr;
    }
    //
    //  NOTES: Size is in Characters for lpcchName.  Although this function uses RegEnumKeyEx, we chose to simply
    //         implement the ReqEnumKey functionality since the Ex functionality is not used
    //         by most programs (this saves a bunch of string conversion code).
    //
    LONG RegEnumKey(HKEY hk, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcchName) const
    {
        if (UnicodeSystem())
        {
            return ::RegEnumKeyExW(hk, dwIndex, lpName, lpcchName, NULL, NULL, NULL, NULL);
        }
        else
        {
            DWORD dwSize = *lpcchName;
            char * pszScratch = lpName ? (char *)_alloca(dwSize) : NULL;
            LONG rr = ::RegEnumKeyExA(hk, dwIndex, pszScratch, &dwSize, NULL, NULL, NULL, NULL);
            if (lpName)
            {
                if (rr == ERROR_SUCCESS)
                {
                    *lpcchName = ::MultiByteToWideChar(CP_ACP, 0, pszScratch, -1, lpName, *lpcchName);
                    if (*lpcchName == 0)
                    {
                        *lpcchName = ::MultiByteToWideChar(CP_ACP, 0, pszScratch, -1, NULL, 0);
                        rr = ::GetLastError();
                    }
                    *lpcchName *= sizeof(WCHAR);
                }
            }
            else
            {
                *lpcchName = dwSize;
            }
            return rr;
        }
    }
    //
    //  NOTES: Size is in Characters for lpcchName.  Although this function uses RegEnumValue
    //         it will only return the names, not the data.  cbValueName is the count of characters
    //
    LONG RegEnumValueName(HKEY hk, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcchName) const
    {
        if (UnicodeSystem())
        {
            return ::RegEnumValueW(hk, dwIndex, lpName, lpcchName, NULL, NULL, NULL, NULL);
        }
        else
        {
            DWORD dwSize = *lpcchName;
            char * pszScratch = lpName ? (char *)_alloca(dwSize) : NULL;
            LONG rr = ::RegEnumValueA(hk, dwIndex, pszScratch, &dwSize, NULL, NULL, NULL, NULL);
            if (lpName)
            {
                if (rr == ERROR_SUCCESS)
                {
                    *lpcchName = ::MultiByteToWideChar(CP_ACP, 0, pszScratch, -1, lpName, *lpcchName);
                    if (*lpcchName == 0)
                    {
                        *lpcchName = ::MultiByteToWideChar(CP_ACP, 0, pszScratch, -1, NULL, 0);
                        rr = ::GetLastError();
                    }
                    *lpcchName *= sizeof(WCHAR);
                }
            }
            else
            {
                *lpcchName = dwSize;
            }
            return rr;
        }
    }
    //
    //  Don't use this for strings.  Use RegSetStringValue instead.
    //
    LONG RegSetValueEx(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE * lpData, DWORD cbData) const
    {
        if (UnicodeSystem())
        {
            return ::RegSetValueExW(hKey, lpValueName, Reserved, dwType, lpData, cbData);
        }
        else
        {
            return ::RegSetValueExA(hKey, CSpToAnsiString<>(lpValueName), Reserved, dwType, lpData, cbData);
        }
    }
    LONG RegSetStringValue(HKEY hKey, LPCWSTR lpValueName, LPCWSTR lpData) const
    {
        LONG rr;
        DWORD dwSize = (wcslen(lpData)+1) * sizeof(WCHAR);
        if (UnicodeSystem())
        {
            rr = ::RegSetValueExW(hKey, lpValueName, NULL, REG_SZ, (const BYTE *)lpData, dwSize);
        }
        else
        {
            char * pszScratch = (char *)_alloca(dwSize);
            dwSize = ::WideCharToMultiByte(CP_ACP, 0, lpData, -1, pszScratch, dwSize, NULL, NULL);
            rr = ::RegSetValueExA(hKey, CSpToAnsiString<>(lpValueName), NULL, REG_SZ, (BYTE *)pszScratch, dwSize);
        }
        return rr;
    }
    HANDLE CreateEvent(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName) const
    {
        if (UnicodeSystem())
        {
            return ::CreateEventW(lpEventAttributes, bManualReset, bInitialState, lpName);
        }
        else
        {
            return ::CreateEventA(lpEventAttributes, bManualReset, bInitialState, CSpToAnsiString<>(lpName)); 
        }
    }
    HANDLE CreateMutex(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName) const
    {
        if (UnicodeSystem())
        {
            return ::CreateMutexW(lpMutexAttributes, bInitialOwner, lpName);
        }
        else
        {
            return ::CreateMutexA(lpMutexAttributes, bInitialOwner, CSpToAnsiString<>(lpName)); 
        }
    }
    int LoadString(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int nBuffer) const
    {
        if (bUnicodeOnly)   // NOTE:  If the DLL is built ANSI then use ANSI load!
        {
            return ::LoadStringW(hInstance, uID, lpBuffer, nBuffer);
        }
        else
        {
            char * pszScratch = (char *)_alloca(nBuffer * 2);
            int r = ::LoadStringA(hInstance, uID, pszScratch, nBuffer * 2);
            if (r)
            {
                r = ::MultiByteToWideChar(CP_ACP, 0, pszScratch, -1, lpBuffer, nBuffer);
            }
            else
            {
                *lpBuffer = 0;
            }
            return r;
        }
    }
    HMODULE LoadLibraryEx(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)
    {
        if (UnicodeSystem())
        {
            return ::LoadLibraryExW(lpLibFileName, hFile, dwFlags);
        }
        else
        {
            return ::LoadLibraryExA(CSpToAnsiString<>(lpLibFileName), hFile, dwFlags);
        }
    }
    HRSRC FindResourceEx(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage)
    {
        if (UnicodeSystem())
        {
            return ::FindResourceExW(hModule, lpType, lpName, wLanguage);
        }
        else
        {
            return ::FindResourceExA(hModule,
                                     HIWORD(lpType) ? CSpToAnsiString<>(lpType) : (const CHAR *) lpType,
                                     HIWORD(lpName) ? CSpToAnsiString<>(lpName) : (const CHAR *) lpName,
                                     wLanguage);
        }
    }
    DWORD GetModuleFileName(HMODULE hModule, LPWSTR lpFileName, DWORD nSize) const
    {
        if (UnicodeSystem())
        {
            return ::GetModuleFileNameW(hModule, lpFileName, nSize);
        }
        else
        {
            CHAR szFileName[MAX_PATH];
            DWORD r = ::GetModuleFileNameA(hModule, szFileName, sp_countof(szFileName));
            if (r)
            {
                r = ::MultiByteToWideChar(CP_ACP, 0, szFileName, r, lpFileName, nSize - 1);
                lpFileName[r] = 0;
            }
            return r;
        }
    }
    int CompareString(LCID Locale, DWORD dwCmpFlags, LPCWSTR lpString1, int cchCount1, LPCWSTR lpString2, int cchCount2)
    {
        if (UnicodeSystem())
        {
            return ::CompareStringW(Locale, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2);
        }
        else
        {
            return ::CompareStringA(Locale, dwCmpFlags, CSpToAnsiString<>(lpString1), cchCount1, 
                                    CSpToAnsiString<>(lpString2), cchCount2);
        }
    }
    BOOL GetUserName(LPWSTR lpBuffer, LPDWORD pnSize)
    {
        if (UnicodeSystem())
        {
            return ::GetUserNameW(lpBuffer, pnSize);
        }
        else
        {
            DWORD cchWideCharBuff = *pnSize;
            CHAR * psz = (CHAR *)_alloca(cchWideCharBuff * sizeof(CHAR)); 
            BOOL fWorked = ::GetUserNameA(psz, pnSize);
            if (fWorked)
            {
                *pnSize = ::MultiByteToWideChar(CP_ACP, 0, psz, -1, lpBuffer, cchWideCharBuff);
                if (*pnSize == 0)
                {
                    fWorked = FALSE;
                    *pnSize = ::MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
                }
            }
            return fWorked;
        }
    }
#if defined(mmioOpen)
    HMMIO mmioOpen(LPCWSTR szFileName, LPMMIOINFO lpmmioinfo, DWORD dwOpenFlags) const
    {
        if (UnicodeSystem())
        {
            return ::mmioOpenW((WCHAR *)szFileName, lpmmioinfo, dwOpenFlags);
        }
        else
        {
            return ::mmioOpenA(CSpToAnsiString<>(szFileName), lpmmioinfo, dwOpenFlags);
        }
    }
    MMRESULT waveOutGetDevCaps(UINT uDeviceId, LPWAVEOUTCAPSW pwoc, UINT cbwoc) const
    {
        // BUGBUG: SB 16 drivers overwrite the WAVEINCAPS buffer by a DWORD. So they probably do it for
        // WAVEOUTCAPS too
        MMRESULT mmr = MMSYSERR_NOERROR;
        if (UnicodeSystem())
        {
            BYTE *pBuffer = new BYTE[sizeof(WAVEOUTCAPSW) + sizeof(DWORD)];
            WAVEOUTCAPSW *pwocw = reinterpret_cast<WAVEOUTCAPSW *>(pBuffer);
            if (pwocw)
            {
                mmr = ::waveOutGetDevCapsW(uDeviceId, pwocw, cbwoc);
                if (mmr == MMSYSERR_NOERROR)
                {
                    *pwoc = *pwocw;
                }
                delete [] pBuffer;
            }
            else
            {
                mmr = MMSYSERR_ERROR;
            }
        }
        else
        {
            BYTE *pBuffer = new BYTE[sizeof(WAVEOUTCAPSA) + sizeof(DWORD)];
            WAVEOUTCAPSA *pwoca = reinterpret_cast<WAVEOUTCAPSA *>(pBuffer);
            if (pwoca)
            {
                mmr = ::waveOutGetDevCapsA(uDeviceId, pwoca, sizeof(*pwoca));
                if (mmr == MMSYSERR_NOERROR)
                {
                    pwoc->wMid = pwoca->wMid;
                    pwoc->wPid = pwoca->wPid;
                    pwoc->vDriverVersion = pwoca->vDriverVersion;
                    pwoc->dwFormats = pwoca->dwFormats;
                    pwoc->wChannels = pwoca->wChannels;
                    pwoc->wReserved1 = pwoca->wReserved1;
                    pwoc->dwSupport = pwoca->dwSupport;
                    ::MultiByteToWideChar(CP_ACP, 0, pwoca->szPname, -1, pwoc->szPname, sp_countof(pwoc->szPname));
                }
                else
                {
                    mmr = MMSYSERR_ERROR;
                }
            }
            else
            {
                mmr = MMSYSERR_ERROR;
            }
        }
        return mmr;
    }
    MMRESULT waveInGetDevCaps(UINT uDeviceId, LPWAVEINCAPSW pwic, UINT cbwic) const
    {
        // BUGBUG: SB 16 drivers overwrite the WAVEINCAPS buffer by a DWORD
        MMRESULT mmr = MMSYSERR_NOERROR;
        if (UnicodeSystem())
        {
            BYTE *pBuffer = new BYTE[sizeof(WAVEINCAPSW) + sizeof(DWORD)];
            WAVEINCAPSW *pwicw = reinterpret_cast<WAVEINCAPSW *>(pBuffer);
            if (pwicw)
            {
                mmr = ::waveInGetDevCapsW(uDeviceId, pwicw, cbwic);
                if (mmr == MMSYSERR_NOERROR)
                {
                    *pwic = *pwicw;
                }
                delete [] pBuffer;
            }
            else
            {
                mmr = MMSYSERR_ERROR;
            }
        }
        else
        {
            BYTE *pBuffer = new BYTE[sizeof(WAVEINCAPSA) + sizeof(DWORD)];
            WAVEINCAPSA *pwica = reinterpret_cast<WAVEINCAPSA *>(pBuffer);
            if (pwica)
            {
                mmr = ::waveInGetDevCapsA(uDeviceId, pwica, sizeof(*pwica));
                if (mmr == MMSYSERR_NOERROR)
                {
                    pwic->wMid = pwica->wMid;
                    pwic->wPid = pwica->wPid;
                    pwic->vDriverVersion = pwica->vDriverVersion;
                    pwic->dwFormats = pwica->dwFormats;
                    pwic->wChannels = pwica->wChannels;
                    pwic->wReserved1 = pwica->wReserved1;
                    ::MultiByteToWideChar(CP_ACP, 0, pwica->szPname, -1, pwic->szPname, sp_countof(pwic->szPname));
                }
                delete [] pBuffer;
            }
            else
            {
                mmr = MMSYSERR_ERROR;
            }
        }
        return mmr;
    }
#endif  // defined(mmioOpen)
};

#ifdef _UNICODE
typedef CSpUnicodeSupportT<TRUE> CSpUnicodeSupport;
#else
typedef CSpUnicodeSupportT<FALSE> CSpUnicodeSupport;
#endif

#else


class CSpUnicodeSupport
{
public:
    HANDLE CreateFile(const WCHAR * lpFileName,      
                      DWORD dwDesiredAccess,       
                      DWORD dwShareMode,           
                      LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                      DWORD dwCreationDisposition, 
                      DWORD dwFlagsAndAttributes,  
                      HANDLE hTemplateFile) const         
    {
        return ::CreateFileW(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, 
                             dwFlagsAndAttributes, hTemplateFile);
    }
    HANDLE CreateFileForMapping(const WCHAR * lpFileName,      
                                DWORD dwDesiredAccess,       
                                DWORD dwShareMode,           
                                LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                                DWORD dwCreationDisposition, 
                                DWORD dwFlagsAndAttributes,  
                                HANDLE hTemplateFile) const         
    {
        return ::CreateFileForMappingW(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition,
                                       dwFlagsAndAttributes, hTemplateFile);
    }
    BOOL DeleteFile(LPCWSTR lpFileName)
    {
        return ::DeleteFileW(lpFileName);
    }
    BOOL CreateDirectory(const WCHAR * lpPathName,
                           LPSECURITY_ATTRIBUTES lpSecurityAttributes) const
    {
        return ::CreateDirectoryW(lpPathName, lpSecurityAttributes);
    }
    BOOL MoveFile(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
    {
        return ::MoveFileW(lpExistingFileName, lpNewFileName);
    }
    HANDLE CreateFileMapping(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect,
                             DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, const WCHAR *lpName)
    {
        return ::CreateFileMappingW(hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, 
                                    dwMaximumSizeLow, lpName);
    }
    LONG RegOpenKeyEx(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult) const
    {
        return ::RegOpenKeyExW(hKey, lpSubKey, ulOptions, samDesired, phkResult);
    }
    LONG RegCreateKeyEx(HKEY hk, LPCWSTR lpSubKey, DWORD dwReserved, LPCWSTR lpClass, DWORD dwOptions,
                        REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, 
                        LPDWORD lpdwDisposition) const
    {
        return ::RegCreateKeyExW(hk, lpSubKey, dwReserved, (WCHAR *)lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);
    }
    LONG RegDeleteKey(HKEY hKey, LPCWSTR lpSubKey) const
    {
        return ::RegDeleteKeyW(hKey, lpSubKey);
    }
    LONG RegDeleteValue(HKEY hKey, LPCWSTR lpSubKey) const
    {
        return ::RegDeleteValueW(hKey, lpSubKey);
    }
    LONG RegQueryValueEx(HKEY hk, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData) const
    {
        return ::RegQueryValueExW(hk, lpValueName, NULL, lpType, lpData, lpcbData);
    }
    //
    //  NOTE:  The size parameter is in CHARACTERS!  Even though the registry API sizes are
    //         in bytes, this function uses character counts.
    //
    LONG RegQueryStringValue(HKEY hKey, LPCWSTR lpValueName, LPWSTR lpData, LPDWORD lpcchData) const
    {
        DWORD dwType;
        *lpcchData *= sizeof(WCHAR);
        LONG rr = ::RegQueryValueExW(hKey, lpValueName, NULL, &dwType, (BYTE *)lpData, lpcchData);
        *lpcchData /= sizeof(WCHAR);
        return rr;
    }
    //
    //  NOTES: Size is in bytes.  Although this function uses RegEnumKeyEx, we chose to simply
    //         implement the ReqEnumKey functionality since the Ex functionality is not used
    //         by most programs (this saves a bunch of string conversion code).
    //
    LONG RegEnumKey(HKEY hk, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcbName) const
    {
        return ::RegEnumKeyExW(hk, dwIndex, lpName, lpcbName, NULL, NULL, NULL, NULL);
    }
    //
    //  NOTES: Size is in Characters for lpcchName.  Although this function uses RegEnumValue
    //         it will only return the names, not the data.  cbValueName is the count of characters
    //
    LONG RegEnumValueName(HKEY hk, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcchName) const
    {
        return ::RegEnumValueW(hk, dwIndex, lpName, lpcchName, NULL, NULL, NULL, NULL);
    }
    LONG RegSetValueEx(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE * lpData, DWORD cbData) const
    {
            return ::RegSetValueExW(hKey, lpValueName, Reserved, dwType, lpData, cbData);
    }
    LONG RegSetStringValue(HKEY hKey, LPCWSTR lpValueName, LPCWSTR lpData) const
    {
        DWORD dwSize = (wcslen(lpData)+1) * sizeof(WCHAR);
        return ::RegSetValueExW(hKey, lpValueName, NULL, REG_SZ, (const BYTE *)lpData, dwSize);
    }
    HANDLE CreateEvent(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName) const
    {
        return ::CreateEventW(lpEventAttributes, bManualReset, bInitialState, lpName);
    }
    HANDLE CreateMutex(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName) const
    {
        return ::CreateMutexW(lpMutexAttributes, bInitialOwner, lpName);
    }
    int LoadString(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int nBuffer) const
    {
        return ::LoadStringW(hInstance, uID, lpBuffer, nBuffer);
    }
    HMODULE LoadLibrary(LPCWSTR lpLibFileName)
    {
        return ::LoadLibraryW(lpLibFileName);
    }
    HMODULE LoadLibraryEx(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)
    {
        return ::LoadLibraryExW(lpLibFileName, hFile, dwFlags);
    }
    HRSRC FindResource(HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType)
    {
        return ::FindResource(hModule, lpName, lpType);
    }
    DWORD GetModuleFileName(HMODULE hModule, LPWSTR lpFileName, DWORD nSize) const
    {
        return ::GetModuleFileNameW(hModule, lpFileName, nSize);
    }
    int CompareString(LCID Locale, DWORD dwCmpFlags, LPCWSTR lpString1, int cchCount1, LPCWSTR lpString2, int cchCount2)
    {
        return ::CompareStringW(Locale, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2);
    }
#ifndef _WIN32_WCE
    BOOL GetUserName(LPWSTR lpBuffer, LPDWORD nSize)
    {
        return GetUserNameW(lpBuffer, nSize);
    }
#endif
#if defined(mmioOpen)
    HMMIO mmioOpen(LPCWSTR szFileName, LPMMIOINFO lpmmioinfo, DWORD dwOpenFlags) const
    {
        return ::mmioOpenW((WCHAR *)szFileName, lpmmioinfo, dwOpenFlags);
    }
#endif  // defined(mmioOpen)
    MMRESULT waveOutGetDevCaps(UINT uDeviceId, LPWAVEOUTCAPS pwoc, UINT cbwoc) const
    {
        return ::waveOutGetDevCaps(uDeviceId, pwoc, cbwoc);
    }
    MMRESULT waveInGetDevCaps(UINT uDeviceId, LPWAVEINCAPS pwic, UINT cbwic) const
    {
        return ::waveInGetDevCaps(uDeviceId, pwic, cbwic);
    }
};

#endif

#endif /* This must be the last line in the file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\xmlcommand.h ===
// XMLCommand.h: interface for the CXMLCommand class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XMLCOMMAND_H__84E6E7AE_73F5_4E83_8640_43E8D3BE042E__INCLUDED_)
#define AFX_XMLCOMMAND_H__84E6E7AE_73F5_4E83_8640_43E8D3BE042E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "BaseSAPI.h"

class CXMLCommand : public CBaseSAPI  
{
public:
	CXMLCommand() { m_StringType=L"CICERO:COMMAND"; }
	virtual ~CXMLCommand();
    NEWNODE( Command );
    virtual HRESULT ExecuteCommand( ISpPhrase *pPhrase ) { return S_OK; }

};

class CXMLCommanding : public CBaseSAPI  
{
public:
    CXMLCommanding() { m_StringType=L"CICERO:COMMANDING"; }
    virtual ~CXMLCommanding();
    NEWNODE( Commanding );

	// IRCMLNode methods Children.
    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptChild( 
            IRCMLNode __RPC_FAR *pChild);

    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InitNode( 
        IRCMLNode __RPC_FAR *parent);

	void Callback();
	virtual HRESULT ExecuteCommand( ISpPhrase *pPhrase );

protected:
    _RefcountList<CXMLCommand>  m_Commands;
};

#endif // !defined(AFX_XMLCOMMAND_H__84E6E7AE_73F5_4E83_8640_43E8D3BE042E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\value.h ===
// RCMLPersist.h: interface for the RCMLPersist class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_VALUE_H__50697F94_22C1_425A_BA70_A9EBDDC298C0__INCLUDED_)
#define AFX_VALUE_H__50697F94_22C1_425A_BA70_A9EBDDC298C0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "appservices.h"

class CXMLValue : public CAppServices
{
public:
    CXMLValue() { m_StringType=L"CICERO:VALUE"; }
    virtual ~ CXMLValue() {};
    NEWNODE( Value );

    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InitNode( 
        IRCMLNode __RPC_FAR *parent);
    
    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExitNode( 
        IRCMLNode __RPC_FAR *parent, LONG lDialogResult);

};

#endif // !defined(AFX_VALUE_H__50697F94_22C1_425A_BA70_A9EBDDC298C0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\value.cpp ===
// RCMLPersist.cpp: implementation of the RCMLPersist class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "value.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


//
// this is the persitance NODE in the DWIN32 namespace.
//
HRESULT STDMETHODCALLTYPE CXMLValue::InitNode( 
    IRCMLNode __RPC_FAR *pParent)
{
    if( SUCCEEDED(pParent->IsType(L"EDIT") ))
    {
        LPCTSTR pszApplicationName=Get(TEXT("APPNAME"));
        LPCTSTR pszKeyName=Get(TEXT("KEYNAME"));
        BOOL bSet=FALSE;
        if( pszApplicationName && pszKeyName )
        {
            HKEY hkSoftware;
            if( RegOpenKey( HKEY_CURRENT_USER, TEXT("Software"), &hkSoftware ) == ERROR_SUCCESS )
            {
                HKEY hkApplication;
                if( RegOpenKey( hkSoftware, pszApplicationName, &hkApplication) == ERROR_SUCCESS )
                {
                    DWORD dwSize;
                    DWORD dwType=REG_SZ;
                    if( RegQueryValueEx( hkApplication, pszKeyName, NULL, &dwType, NULL, &dwSize ) == ERROR_SUCCESS )
                    {
                        LPTSTR pszData=new TCHAR[dwSize];
                        if( RegQueryValueEx( hkApplication, pszKeyName, NULL, &dwType, (LPBYTE)pszData, &dwSize ) == ERROR_SUCCESS )
                        {
                            pParent->put_Attr( L"TEXT", pszData );
                            delete pszData ;
                            bSet=TRUE;
                        }
                    }
                    RegCloseKey(hkApplication);
                }
                RegCloseKey(hkSoftware);
            }
        }
        if(bSet==FALSE)
            pParent->put_Attr(L"TEXT", Get(L"TEXT") );
    }
    return S_OK;
}

//
// this is the persitance NODE in the DWIN32 namespace.
// should only really be called if the user clicks OK, rather than cancel??
//
HRESULT STDMETHODCALLTYPE CXMLValue::ExitNode( 
    IRCMLNode __RPC_FAR *pParent, LONG lDialogResult)
{
    if(lDialogResult != IDOK )
        return S_OK;

    if(SUCCEEDED( pParent->IsType(L"EDIT")))
    {
        LPCTSTR pszApplicationName=Get(TEXT("APPNAME"));
        LPCTSTR pszKeyName=Get(TEXT("KEYNAME"));
        if( pszApplicationName && pszKeyName )
        {
            HKEY hkSoftware;
            if( RegOpenKey( HKEY_CURRENT_USER, TEXT("Software"), &hkSoftware ) == ERROR_SUCCESS )
            {
                HKEY hkApplication;
                if( RegCreateKey( hkSoftware, pszApplicationName, &hkApplication) == ERROR_SUCCESS )
                {
                    IRCMLControl * pControl;
                    if(SUCCEEDED( pParent->QueryInterface( __uuidof( IRCMLControl ), (LPVOID*)&pControl)))
                    {
                        HWND hWnd;
                        if( SUCCEEDED( pControl->get_Window(&hWnd) ))
                        {
                            LPTSTR szString=NULL;
                            DWORD cbNeeded = GetWindowTextLength( hWnd )+1;
                            szString = new TCHAR[cbNeeded];
                            GetWindowText( hWnd, szString, cbNeeded );
                            RegSetValueEx( hkApplication, pszKeyName, NULL, REG_SZ, (LPBYTE) szString, cbNeeded*sizeof(TCHAR) );
                        }
                        pControl->Release();
                    }
                    RegCloseKey(hkApplication);
                }
                RegCloseKey(hkSoftware);
            }
        }
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\xmlfailure.cpp ===
// XMLFailure.cpp: implementation of the CXMLFailure class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "XMLFailure.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\xmlfailure.h ===
// XMLFailure.h: interface for the CXMLFailure class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XMLFAILURE_H__66188FBE_10A0_4B5E_938B_B12FC3123B43__INCLUDED_)
#define AFX_XMLFAILURE_H__66188FBE_10A0_4B5E_938B_B12FC3123B43__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "APPSERVICES.h"

class CXMLFailure : public CAppServices  
{
public:
	CXMLFailure() { m_StringType=L"CICERO:FAILURE"; }
    virtual ~CXMLFailure() {};
    NEWNODE( Failure );
};

class CXMLSuccess : public CAppServices  
{
public:
	CXMLSuccess() { m_StringType=L"CICERO:SUCCESS"; }
    virtual ~CXMLSuccess() {};
    NEWNODE( Success );
};

#endif // !defined(AFX_XMLFAILURE_H__66188FBE_10A0_4B5E_938B_B12FC3123B43__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\xmlsynonym.cpp ===
// XMLSynonym.cpp: implementation of the CXMLSynonym class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "XMLSynonym.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


CXMLSynonym::~CXMLSynonym()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\xmlsynonym.h ===
// XMLSynonym.h: interface for the CXMLSynonym class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XMLSYNONYM_H__7E3BF020_7BC4_4E12_A82A_5F2B749EC5CC__INCLUDED_)
#define AFX_XMLSYNONYM_H__7E3BF020_7BC4_4E12_A82A_5F2B749EC5CC__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "APPSERVICES.h"

class CXMLSynonym : public CAppServices  
{
public:
	CXMLSynonym() { m_StringType=L"CICERO:SYNONYM"; }
	virtual ~CXMLSynonym();
    NEWNODE( Synonym );
};

#endif // !defined(AFX_XMLSYNONYM_H__7E3BF020_7BC4_4E12_A82A_5F2B749EC5CC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\xmlvoicecmd.cpp ===
// XMLVoiceCmd.cpp: implementation of the CXMLVoiceCmd class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "XMLVoiceCmd.h"
#include "debug.h"

#ifdef _OLD_SAPIM2
#define SPDebug_h
#define SPDBG_ASSERT
#endif
#include "sphelper.h"

// WCHAR g_szPrefix[]=L"<GRAMMAR LANGID=\"1033\">\r\n<DEFINE IDBASE=\"3\">\r\n<ID NAME=\"COMBO\" VAL=\"1\"/>\r\n</DEFINE>\r\n";
WCHAR g_szPrefix[]=L"<GRAMMAR LANGID=\"1033\">\r\n";

// _WITH_DICTATION - BaseSapi.h

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CXMLVoiceCmd::~CXMLVoiceCmd()
{

}

//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Check the type of the control, perhaps the text, and build a CFG accordingly.
//
HRESULT STDMETHODCALLTYPE CXMLVoiceCmd::InitNode( 
    IRCMLNode __RPC_FAR *pParent)
{
	HRESULT hr=S_OK;

	IRCMLControl * pControl;
	if( SUCCEEDED( pParent->QueryInterface( __uuidof( IRCMLControl ) , (LPVOID*)&pControl )))
	{
        if( pControl )
        {
		    if( SUCCEEDED(pControl->IsType(L"BUTTON") ))
                InitButton(pControl);
		    else if ( SUCCEEDED(pControl->IsType(L"CHECKBOX") ))
                InitCheckbox(pControl);
		    else if ( SUCCEEDED(pControl->IsType(L"SLIDER") ))
                InitSlider(pControl);
		    else if ( SUCCEEDED(pControl->IsType(L"RADIOBUTTON") ))
                InitRadioButton(pControl);
		    else if ( SUCCEEDED(pControl->IsType(L"COMBO") ))
                InitCombo(pControl);
		    else if ( SUCCEEDED(pControl->IsType(L"LISTBOX") ))
                InitList(pControl);
		    else if ( SUCCEEDED(pControl->IsType(L"EDIT") ))
                InitEdit(pControl);
            else
            {
                LPWSTR pszType;
                if( SUCCEEDED( pControl->get_StringType( &pszType)))
                {
                    TRACE(TEXT("The node %s doesn't support commanding\n"),pszType);
                }
            }
		    pControl->Release();
        }
	}
    return hr;
}

//
//
//
void CXMLVoiceCmd::Callback()
{
    CSpEvent event;

    if (m_cpRecoCtxt)
    {
        while (event.GetFrom(m_cpRecoCtxt) == S_OK)
        {
            switch (event.eEventId)
            {
				case SPEI_RECOGNITION:
					ExecuteCommand(event.RecoResult());
					break;
			}
		}
	}
}

//
// These rules fire, let's see what we're supposed to do with them!
//
HRESULT CXMLVoiceCmd::ExecuteCommand( ISpPhrase *pPhrase )
{
	HRESULT hr=S_OK;

	IRCMLNode * pParent;
	if( SUCCEEDED(DetachParent( & pParent )))
	{
		IRCMLControl * pControl;
		if( SUCCEEDED( pParent->QueryInterface( __uuidof( IRCMLControl ) , (LPVOID*)&pControl )))
		{
			HWND hWnd;
			if( SUCCEEDED( pControl->get_Window( &hWnd ))) 
        	{
                if( (hWnd == NULL) || (IsWindow(hWnd) == FALSE ) )
                {
                    // lets not even bother trying to execute on this command.
                }
                else
                {
                    HRESULT hr=S_FALSE;
				    switch( m_ControlType )
				    {
				    case CT_BUTTON:
                        hr=ExecuteButton( pPhrase, pControl, hWnd );
					    break;
				    case CT_CHECKBOX:
                        hr=ExecuteCheckbox( pPhrase, pControl, hWnd );
					    break;
				    case CT_SLIDER:
                        hr=ExecuteSlider( pPhrase, pControl, hWnd );
					    break;
				    case CT_RADIOBUTTON:
                        hr=ExecuteRadioButton( pPhrase, pControl, hWnd );
					    break;
				    case CT_COMBO:
                        hr=ExecuteCombo( pPhrase, pControl, hWnd );
					    break;
				    case CT_LIST:
                        hr=ExecuteList( pPhrase, pControl, hWnd );
					    break;
				    case CT_EDIT:
                        hr=ExecuteEdit( pPhrase, pControl, hWnd );
					    break;
				    }
                    if( SUCCEEDED(hr) )
                    {
                        if(hr!=S_FALSE)
                            SaySuccess();
                    }
                    else
                    {
                        SayFailure();
                    }
                }
			}
			pControl->Release();
		}
	}

	//
	// In theory we should be checking what part of the rule fired,up down etc.
	//
#if 0
    SPPHRASE *pElements;
	LPTSTR pszPropertyName;

    // Get the phrase elements, one of which is the rule id we specified in
    // the grammar.  Switch on it to figure out which command was recognized.
    if (SUCCEEDED(pPhrase->GetPhrase(&pElements)))
    {
        CSpDynamicString dstrText;

		BOOL bPropFound=FALSE;
		if( SUCCEEDED( get_Attr(L"PROPNAME", & pszPropertyName) ))
		{
			// find the property name we were looking for.
			if( pElements )
			{
				const SPPHRASEPROPERTY * pProperty=pElements->pProperties;
				while(pProperty)
				{
					if( lstrcmpi( pProperty->pszName, pszPropertyName ) == 0 )
					{
						ULONG FirstElement=pProperty->ulFirstElement;
						if( FirstElement < pElements->Rule.ulCountOfElements )
						{
							dstrText=pElements->pElements[FirstElement].pszDisplayText;
							pProperty=NULL;
							bPropFound=TRUE;
							continue;
						}
					}
					pProperty= pProperty->pNextSibling;
				}


			}
		}

		//
		// Even if they specified a property name, perhaps we ignore it??
		//
		if(bPropFound==FALSE)
			pPhrase->GetText(/* SP_GETWHOLEPHRASE, SP_GETWHOLEPHRASE,*/ TRUE, &dstrText, NULL);

		if( SetControlText( dstrText ) == FALSE )
		{
			if( m_cpFailure )
			{
				LPWSTR pszText;
				if( SUCCEEDED( m_cpFailure->get_Attr( L"TEXT", &pszText )))
				{
					// TUNA the failure text.
					CComPtr<ISpVoice>   m_cpVoice;
				    if( SUCCEEDED( m_cpVoice.CoCreateInstance( CLSID_SpVoice ) ))
					{
						m_cpVoice->Speak( pszText, 0, 0, NULL);
					}
				}
			}
		}
	}
#endif
    return hr;
}

HRESULT CXMLVoiceCmd::LoadCFGResource(LPTSTR *ppCFG, DWORD * pdwSize, LPWSTR pszResourceName)
{
    HRSRC hRes = NULL;

    hRes = FindResource( g_hModule, pszResourceName, TEXT("CFG") );
	*ppCFG=NULL;
    if( hRes != NULL )
    {
        DWORD dwSize = SizeofResource( g_hModule, hRes );
		if(pdwSize)
			*pdwSize=dwSize;
        HGLOBAL hg=LoadResource(g_hModule, hRes );
        if( hg )
        {
            LPVOID pData = LockResource( hg );
			*ppCFG=(LPTSTR)new BYTE[dwSize+2];	// we need to null terminate this string.
			ZeroMemory( *ppCFG, dwSize+2 );
			CopyMemory( *ppCFG, pData, dwSize);
            FreeResource( hg );
			return S_OK;
        }
    }
	return E_FAIL;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//
// The smarts for building a button grammar.
// there is an optional synonym for buttons.
// for some reason, this throws off the grammar sometimes, so we use a different CFG if synonyms present
//
HRESULT CXMLVoiceCmd::InitButton(IRCMLControl *pControl)
{
	m_ControlType=CT_BUTTON;

    HRESULT hr=S_OK;
	LPWSTR pszButtonText=GetControlText(pControl);

	LPWSTR pszSynonym=NULL;
	get_Attr( L"SYNONYM", &pszSynonym);

    if( pszButtonText )
    {
        TCHAR temp[1024];
        TCHAR szBuffer[2];
        szBuffer[0]=0xfeff;
        szBuffer[1]=NULL;
        PSTRINGBUFFER pBuffer = AppendText( NULL, szBuffer);

        pBuffer = AppendText(pBuffer, g_szPrefix);
        pBuffer = AppendText(pBuffer, TEXT("<RULE NAME=\"BUTTON\" TOPLEVEL=\"ACTIVE\">"));
        pBuffer = AppendText(pBuffer, TEXT("<L>"));

        // specifics for the button.
        wsprintf(temp,TEXT("<P>?Click %s</P>"), pszButtonText);
        pBuffer = AppendText(pBuffer, temp);

        if(pszSynonym)
        {
            wsprintf(temp,TEXT("<P>?Click %s</P>"), pszSynonym);
            pBuffer = AppendText(pBuffer, temp);
        }

        pBuffer = AppendText(pBuffer, TEXT("</L>"));
        pBuffer = AppendText(pBuffer, TEXT("</RULE></GRAMMAR>"));

        hr=LoadCFGFromString( pBuffer->pszString, pszButtonText );

        AppendText(pBuffer, NULL );
    }
    delete pszButtonText;
    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//
// The smarts for building a button grammar.
//
HRESULT CXMLVoiceCmd::ExecuteButton( ISpPhrase *pPhrase, IRCMLControl * pControl, HWND hWnd )
{
    if(hWnd == NULL )
        return S_FALSE; // focus lost

    if( IsEnabled( hWnd ) == FALSE )
        return E_FAIL;

//	PostMessage(GetParent(hWnd), WM_COMMAND, MAKEWPARAM( GetDlgCtrlID(hWnd),BN_CLICKED ) , (LPARAM)hWnd);
    PostMessage( hWnd, BM_CLICK, 0, 0);
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//
// The smarts for building a button grammar.
//
HRESULT CXMLVoiceCmd::InitCheckbox(IRCMLControl *pControl)
{
	m_ControlType=CT_CHECKBOX;

    HRESULT hr=S_OK;
	LPWSTR pszSynonym=NULL;
	get_Attr( L"SYNONYM", &pszSynonym);
	LPWSTR pszButtonText=GetControlText(pControl);

    if( pszButtonText )
    {
        TCHAR temp[1024];
        TCHAR szBuffer[2];
        szBuffer[0]=0xfeff;
        szBuffer[1]=NULL;
        PSTRINGBUFFER pBuffer = AppendText( NULL, szBuffer);

        pBuffer = AppendText(pBuffer, g_szPrefix);

            // ON
            pBuffer = AppendText(pBuffer, TEXT("<RULE NAME=\"ON\" TOPLEVEL=\"ACTIVE\">\r\n"));
            pBuffer = AppendText(pBuffer, TEXT("<L>"));
                wsprintf(temp,TEXT("<P>Do %s</P>"), pszButtonText);
                pBuffer = AppendText(pBuffer, temp );
                if(pszSynonym)
                {
                    wsprintf(temp,TEXT("<P>Do %s</P>"), pszSynonym);
                    pBuffer = AppendText(pBuffer, temp );
                }
            pBuffer = AppendText(pBuffer, TEXT("</L></RULE>\r\n"));

            // OFF
            pBuffer = AppendText(pBuffer, TEXT("<RULE NAME=\"OFF\" TOPLEVEL=\"ACTIVE\">\r\n"));
            pBuffer = AppendText(pBuffer, TEXT("<L>"));
                wsprintf(temp,TEXT("<P>Do not %s</P>"), pszButtonText);
                pBuffer = AppendText(pBuffer, temp );
                if(pszSynonym)
                {
                    wsprintf(temp,TEXT("<P>Do not %s</P>"), pszSynonym);
                    pBuffer = AppendText(pBuffer, temp );
                }
            pBuffer = AppendText(pBuffer, TEXT("</L></RULE>\r\n"));

            // TOGGLE
            pBuffer = AppendText(pBuffer, TEXT("<RULE NAME=\"TOGGLE\" TOPLEVEL=\"ACTIVE\">\r\n"));
            pBuffer = AppendText(pBuffer, TEXT("<L>"));
                wsprintf(temp,TEXT("<P>?Toggle %s</P>"), pszButtonText);
                pBuffer = AppendText(pBuffer, temp );
                if(pszSynonym)
                {
                    wsprintf(temp,TEXT("<P>?Toggle %s</P>"), pszSynonym);
                    pBuffer = AppendText(pBuffer, temp );
                }
            pBuffer = AppendText(pBuffer, TEXT("</L></RULE>\r\n"));

        pBuffer = AppendText(pBuffer, TEXT("</GRAMMAR>"));

        hr=LoadCFGFromString( pBuffer->pszString, pszButtonText );

        AppendText(pBuffer, NULL );
    }
    delete pszButtonText;
    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//
// The smarts for building a button grammar.
//
HRESULT CXMLVoiceCmd::ExecuteCheckbox( ISpPhrase *pPhrase, IRCMLControl * pControl, HWND hWnd )
{
    if(hWnd == NULL )
        return S_FALSE; // focus lost

    if( IsEnabled( hWnd ) == FALSE )
        return E_FAIL;

    //
    // Check property name for the executed rule.
    //
    LPWSTR pszRuleID = GetRecognizedRule( pPhrase );
    TRACE(TEXT("==== Recognized a checkbox command - rule ID %s\n"),pszRuleID);
    BOOL bSetTo;
    BOOL bCurrent=SendMessage(hWnd, BM_GETCHECK, 0 , 0) == BST_CHECKED;
    if( lstrcmpi( pszRuleID, TEXT("ON")) == 0)
    {
        bSetTo=TRUE;
    }
    else
    if( lstrcmpi( pszRuleID, TEXT("OFF")) == 0)
    {
        bSetTo=FALSE;
    }
    else
    if( lstrcmpi( pszRuleID, TEXT("TOGGLE")) == 0 )
    {
        bSetTo=!bCurrent;
    }

    if(bSetTo!=bCurrent)
    {
        TRACE(TEXT("Attempting to switch from %s to %s\n"), 
            bCurrent?TEXT("Checked"):TEXT("Un checked"),
            bSetTo?TEXT("Checked"):TEXT("Un checked") );

        PostMessage(hWnd, BM_SETCHECK, bSetTo?BST_CHECKED : BST_UNCHECKED , 0);
    	PostMessage(GetParent(hWnd), WM_COMMAND, MAKEWPARAM( GetDlgCtrlID(hWnd),BN_CLICKED ) , (LPARAM)hWnd);
    }

    delete pszRuleID;
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//
// The smarts for building a button grammar.
//
HRESULT CXMLVoiceCmd::InitRadioButton(IRCMLControl *pControl)
{
	m_ControlType=CT_RADIOBUTTON;

    HRESULT hr=S_OK;
	LPWSTR pszSynonym=NULL;
	get_Attr( L"SYNONYM", &pszSynonym);

	LPWSTR pszButtonText=GetControlText(pControl);

    if( pszButtonText )
    {
        TCHAR temp[1024];
        TCHAR szBuffer[2];
        szBuffer[0]=0xfeff;
        szBuffer[1]=NULL;
        PSTRINGBUFFER pBuffer = AppendText( NULL, szBuffer);

        pBuffer = AppendText(pBuffer, g_szPrefix);

            // ON
            pBuffer = AppendText(pBuffer, TEXT("<RULE NAME=\"ON\" TOPLEVEL=\"ACTIVE\">\r\n"));
            pBuffer = AppendText(pBuffer, TEXT("<L>"));
                wsprintf(temp,TEXT("<P>?Pick %s</P>"), pszButtonText);
                pBuffer = AppendText(pBuffer, temp );
                if(pszSynonym)
                {
                    wsprintf(temp,TEXT("<P>?Pick %s</P>"), pszSynonym);
                    pBuffer = AppendText(pBuffer, temp );
                }
            pBuffer = AppendText(pBuffer, TEXT("</L></RULE>\r\n"));


        pBuffer = AppendText(pBuffer, TEXT("</GRAMMAR>"));

        hr=LoadCFGFromString( pBuffer->pszString, pszButtonText );

        AppendText(pBuffer, NULL );
    }
    delete pszButtonText;
    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//
// The smarts for building a button grammar.
//
HRESULT    CXMLVoiceCmd::ExecuteRadioButton( ISpPhrase *pPhrase, IRCMLControl * pControl, HWND hWnd )
{
    if(hWnd == NULL )
        return S_FALSE; // focus lost

    if( IsEnabled( hWnd ) == FALSE )
        return E_FAIL;

//  	PostMessage(GetParent(hWnd), WM_COMMAND, MAKEWPARAM( GetDlgCtrlID(hWnd),BN_CLICKED ) , (LPARAM)hWnd);
    PostMessage( hWnd, BM_CLICK, 0, 0);
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//
// The smarts for building a button grammar.
//
HRESULT CXMLVoiceCmd::InitSlider(IRCMLControl *pControl)
{
	m_ControlType=CT_SLIDER;

    HRESULT hr=S_OK;
	LPWSTR pszSynonym=NULL;
	get_Attr( L"SYNONYM", &pszSynonym);
	LPWSTR pszButtonText=GetControlText(pControl);

    TCHAR id[MAX_PATH];
    if( pszButtonText==NULL)
    {
        pszButtonText=id;
        LPWSTR pszID;
        pControl->get_Attr(L"ID",&pszID);
        wsprintf(id,TEXT("Slider %s"),pszID);
    }

    BOOL bVert=FALSE;
    LPWSTR pszOrientation;
    if( SUCCEEDED(pControl->get_Attr(TEXT("ORIENTATION"),&pszOrientation)))
    {
        if(lstrcmpi(pszOrientation,TEXT("VERTICAL"))==0)
            bVert=TRUE;
    }

    if( pszButtonText )
    {
        TCHAR temp[1024];
        TCHAR szBuffer[2];
        szBuffer[0]=0xfeff;
        szBuffer[1]=NULL;
        PSTRINGBUFFER pBuffer = AppendText( NULL, szBuffer);

        pBuffer = AppendText(pBuffer, g_szPrefix);

            // ON
            pBuffer = AppendText(pBuffer, TEXT("<RULE NAME=\"ON\" TOPLEVEL=\"ACTIVE\">\r\n"));
            pBuffer = AppendText(pBuffer, TEXT("<L>"));
                wsprintf(temp,TEXT("<P>?Pick %s</P>"), pszButtonText);
                pBuffer = AppendText(pBuffer, temp );
                if(pszSynonym)
                {
                    wsprintf(temp,TEXT("<P>?Pick %s</P>"), pszSynonym);
                    pBuffer = AppendText(pBuffer, temp );
                }
            pBuffer = AppendText(pBuffer, TEXT("</L></RULE>\r\n"));

            pBuffer = AppendText(pBuffer, TEXT("<RULE NAME=\"UP\" TOPLEVEL=\"ACTIVE\">"));

                pBuffer = AppendText(pBuffer, TEXT("<L>"));
                    wsprintf(temp,bVert?TEXT("<P>Up</P>"):TEXT("<P>Right</P>") );
                    pBuffer = AppendText( pBuffer, temp );
                pBuffer = AppendText(pBuffer, TEXT("</L>")); 

            pBuffer = AppendText(pBuffer, TEXT("</RULE>")); 

            pBuffer = AppendText(pBuffer, TEXT("<RULE NAME=\"DOWN\" TOPLEVEL=\"ACTIVE\">"));

                pBuffer = AppendText(pBuffer, TEXT("<L>"));
                    wsprintf(temp,bVert?TEXT("<P>Down</P>"):TEXT("<P>Left</P>") );
                    pBuffer = AppendText( pBuffer, temp );
                pBuffer = AppendText(pBuffer, TEXT("</L>")); 

            pBuffer = AppendText(pBuffer, TEXT("</RULE>")); 

            pBuffer = AppendText(pBuffer, TEXT("<RULE NAME=\"MAX\" TOPLEVEL=\"ACTIVE\">"));

                pBuffer = AppendText(pBuffer, TEXT("<L>"));
                    wsprintf(temp,TEXT("<P>Max</P>") );
                    pBuffer = AppendText( pBuffer, temp );
                pBuffer = AppendText(pBuffer, TEXT("</L>")); 

            pBuffer = AppendText(pBuffer, TEXT("</RULE>")); 

            pBuffer = AppendText(pBuffer, TEXT("<RULE NAME=\"MIN\" TOPLEVEL=\"ACTIVE\">"));

                pBuffer = AppendText(pBuffer, TEXT("<L>"));
                    wsprintf(temp,TEXT("<P>Min</P>") );
                    pBuffer = AppendText( pBuffer, temp );
                pBuffer = AppendText(pBuffer, TEXT("</L>")); 

            pBuffer = AppendText(pBuffer, TEXT("</RULE>")); 


        pBuffer = AppendText(pBuffer, TEXT("</GRAMMAR>"));

        hr=LoadCFGFromString( pBuffer->pszString, pszButtonText );

        AppendText(pBuffer,NULL);
    }
    delete pszButtonText;
    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//
// The smarts for building a button grammar.
// needs to get the properties, for UP DOWN etc.
//
HRESULT CXMLVoiceCmd::ExecuteSlider( ISpPhrase *pPhrase, IRCMLControl * pControl, HWND hWnd )
{
    if(hWnd == NULL )
        return S_FALSE; // focus lost

    if( IsEnabled( hWnd ) == FALSE )
        return E_FAIL;

    LPWSTR pszOrientation;
    BOOL bVert=FALSE;
    if( SUCCEEDED(pControl->get_Attr(TEXT("ORIENTATION"),&pszOrientation)))
    {
        if(lstrcmpi(pszOrientation,TEXT("VERTICAL"))==0)
            bVert=TRUE;
    }


    //
    // Check property name for the executed rule.
    //
    DWORD dwPageSize = SendMessage( hWnd, TBM_GETPAGESIZE, 0, 0);
    if( dwPageSize == 0 )
        dwPageSize =1;      // REVIEW 
    DWORD dwCurPos   = SendMessage( hWnd, TBM_GETPOS, 0, 0 );
    DWORD dwNewPos   = dwCurPos;

    LPWSTR pszRuleID = GetRecognizedRule( pPhrase );
    TRACE(TEXT("==== Recognized a Slider command - rule ID %s\n"),pszRuleID);
    //
    // Vertical MIN at the TOP, MAX at the bottom.
    //
    if( lstrcmpi( pszRuleID, TEXT("UP")) == 0)
    {
        if(bVert)
            dwNewPos -= dwPageSize; // the top is MIN
        else
            dwNewPos += dwPageSize; // right is MAX
    }
    else
    if( lstrcmpi( pszRuleID, TEXT("DOWN")) == 0)
    {
        if(bVert)
            dwNewPos += dwPageSize; // the bottom is MAX
        else
            dwNewPos -= dwPageSize; // left is MIN
    }
    else
    if( lstrcmpi( pszRuleID, TEXT("MIN")) == 0 )
    {
        if(bVert)
            dwNewPos = SendMessage( hWnd, TBM_GETRANGEMAX, 0, 0);
        else
            dwNewPos = SendMessage( hWnd, TBM_GETRANGEMIN, 0, 0);
    }
    else
    if( lstrcmpi( pszRuleID, TEXT("MAX")) == 0 )
    {
        if(bVert)
            dwNewPos = SendMessage( hWnd, TBM_GETRANGEMIN, 0, 0);
        else
            dwNewPos = SendMessage( hWnd, TBM_GETRANGEMAX, 0, 0);
    }

    if(dwNewPos!=dwCurPos)
    {
        PostMessage(hWnd, TBM_SETPOS, TRUE, dwNewPos );
#if 0
        NMHDR notify={0};
        notify.hwndFrom = hWnd;
        notify.idFrom = GetDlgCtrlID(hWnd);
        notify.code = 1;
        PostMessage(GetParent(hWnd), WM_NOTIFY, notify.idFrom, (LPARAM)&notify );
#else
        if(bVert)
            PostMessage( GetParent(hWnd), WM_VSCROLL, MAKEWPARAM(TB_ENDTRACK,0), (LPARAM)hWnd );
        else
            PostMessage( GetParent(hWnd), WM_HSCROLL, MAKEWPARAM(TB_ENDTRACK,0), (LPARAM)hWnd );
#endif

    }

    delete pszRuleID;
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//
// The smarts for building a button grammar.
//
HRESULT CXMLVoiceCmd::InitCombo(IRCMLControl *pControl)
{
	m_ControlType=CT_COMBO;

    TCHAR temp[1024];
    TCHAR szBuffer[2];
    szBuffer[0]=0xfeff;
    szBuffer[1]=NULL;
    PSTRINGBUFFER pBuffer = AppendText( NULL, szBuffer);

    pBuffer = AppendText(pBuffer, g_szPrefix);
    pBuffer = AppendText(pBuffer, TEXT("<RULE NAME=\"COMBO\" TOPLEVEL=\"ACTIVE\">"));
    pBuffer = AppendText(pBuffer, TEXT("<L>"));

    BOOL bNeedsTip=NeedsTip();

    //
    // Now, this enumerates all the unknown children, not
    // just the ones of the visual combo.
    //
    IEnumUnknown * pEnum;
    HRESULT hr;
    UINT    iItemToPick = ((UINT)this) % 3; // hey, most combos/lists have 3 items in them??
    UINT    thisItem = 0;
    if( SUCCEEDED( hr=pControl->GetChildEnum( & pEnum ))) // IEnumXXX
    {
        IUnknown * pUnk;
        ULONG got;
        while( pEnum->Next( 1, &pUnk, &got ) == S_OK )
        {
            if( got )
            {
                IRCMLNode * pNode;
                if( SUCCEEDED( pUnk->QueryInterface( __uuidof(IRCMLNode), (LPVOID*) & pNode )))
                {
                    LPWSTR pszText;
                    if( SUCCEEDED( pNode->get_Attr(L"TEXT", &pszText )))
                    {
                        wsprintf(temp,TEXT("<P>%s</P>"),pszText);
                        pBuffer = AppendText(pBuffer, temp );

                        // REVIEW, we'd like to pick an item randomly
                        // however, IEnum doesn't have a getCount on it, so it's hard.
                        // FA 6/15/00
                        if(bNeedsTip && (thisItem == iItemToPick) )
                        {
                            TCHAR szText[1024];
                            wsprintf(szText,TEXT("Try saying '%s'"),pszText);
                            put_Attr(L"TOOLTIP",szText);
                            bNeedsTip=FALSE;
                        }
                    }
                    pNode->Release();
                }
                thisItem++;
            }
        }
        pEnum->Release();
    }

    pBuffer = AppendText(pBuffer, TEXT("</L>"));
    pBuffer = AppendText(pBuffer, TEXT("</RULE></GRAMMAR>"));

	LPWSTR pszControlText=GetControlText(pControl);
    hr=LoadCFGFromString( pBuffer->pszString, pszControlText );

#ifdef _WITH_DICTATION
    if( m_cpCmdGrammar)
    {
        if( SUCCEEDED( hr = m_cpCmdGrammar->LoadDictation( NULL, SPLO_STATIC ) ))  // is TRUE needed?
        {
            // Set rules to active, we are now listening for commands
            hr = m_cpCmdGrammar->SetDictationState(SPRS_ACTIVE);
        }
    }
#endif

    LPWSTR pszContent;
    if( SUCCEEDED( pControl->get_Attr(L"CONTENT", &pszContent)))
    {
        if(lstrcmpi(pszContent,L"NUMBER")==0)
        {
            LoadNumberGrammar();

        }
    }

    delete pszControlText;
    AppendText(pBuffer,NULL);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Need to see if it's a list selection, or a number
//
DWORD VoiceToNumber(ISpPhrase * pPhrase) ;

HRESULT CXMLVoiceCmd::ExecuteCombo( ISpPhrase *pPhrase, IRCMLControl * pControl, HWND hWnd )
{
    if(hWnd == NULL )
        return S_FALSE; // focus lost

    if( IsEnabled( hWnd ) == FALSE )
        return E_FAIL;

    HRESULT hr=S_OK;
    LPWSTR pszRuleID = GetRecognizedRule( pPhrase );
    TRACE(TEXT("==== Recognized a Combo command - rule ID %s\n"),pszRuleID);
    if( lstrcmpi( pszRuleID, L"GRID_NUMBER" )==0 )
    {
        // get the number.
        DWORD dwValue = VoiceToNumber( pPhrase );
        TCHAR szNumber[12];
        wsprintf(szNumber,TEXT("%d"),dwValue);
		if( SetControlText(szNumber) == FALSE )
            hr=E_FAIL;
    }
    else
    {
        LPWSTR pszRecoText=GetRecognizedText( pPhrase );
        if( pszRecoText )
        {
		    if( SetControlText( pszRecoText) == FALSE )
               hr=E_FAIL;
	    }
        delete pszRecoText;
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//
// The smarts for building a button grammar.
//
HRESULT CXMLVoiceCmd::InitList(IRCMLControl *pControl)
{
	m_ControlType=CT_LIST;

    TCHAR temp[1024];
    TCHAR szBuffer[2];
    szBuffer[0]=0xfeff;
    szBuffer[1]=NULL;
    PSTRINGBUFFER pBuffer = AppendText( NULL, szBuffer);

    pBuffer = AppendText(pBuffer, g_szPrefix);
    pBuffer = AppendText(pBuffer, TEXT("<RULE NAME=\"LIST\" TOPLEVEL=\"ACTIVE\">"));
    pBuffer = AppendText(pBuffer, TEXT("<L>"));


    //
    // Now, this enumerates all the unknown children, not
    // just the ones of the List.
    //
    IEnumUnknown * pEnum;
    HRESULT hr;
    if( SUCCEEDED( hr=pControl->GetChildEnum( & pEnum )))
    {
        IUnknown * pUnk;
        ULONG got;
        while( pEnum->Next( 1, &pUnk, &got ) == S_OK )
        {
            if( got )
            {
                IRCMLNode * pNode;
                if( SUCCEEDED( pUnk->QueryInterface( __uuidof(IRCMLNode), (LPVOID*) & pNode )))
                {
                    LPWSTR pszText;
                    if( SUCCEEDED( pNode->get_Attr(L"TEXT", &pszText )))
                    {
                        wsprintf(temp,TEXT("<P>%s</P>"),pszText);
                        pBuffer = AppendText(pBuffer, temp );
                    }
                    pNode->Release();
                }
            }
        }
        pEnum->Release();
    }

    pBuffer = AppendText(pBuffer, TEXT("</L>"));
    pBuffer = AppendText(pBuffer, TEXT("</RULE></GRAMMAR>"));

	LPWSTR pszControlText=GetControlText(pControl);
    hr=LoadCFGFromString( pBuffer->pszString, pszControlText );

#ifdef _WITH_DICTATION
    if( m_cpCmdGrammar)
    {
        if( SUCCEEDED( hr = m_cpCmdGrammar->LoadDictation( NULL, SPLO_STATIC ) ))  // is TRUE needed?
        {
            // Set rules to active, we are now listening for commands
            hr = m_cpCmdGrammar->SetDictationState(SPRS_ACTIVE);
        }
    }
#endif

    delete pszControlText;
    AppendText(pBuffer,NULL);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//
// The smarts for building a button grammar.
// needs to get the properties, for UP DOWN etc.
//
HRESULT CXMLVoiceCmd::ExecuteList( ISpPhrase *pPhrase, IRCMLControl * pControl, HWND hWnd )
{
    if(hWnd == NULL )
        return S_FALSE; // focus lost

    if( IsEnabled( hWnd ) == FALSE )
        return E_FAIL;

    HRESULT hr=S_OK;
    LPWSTR pszRecoText=GetRecognizedText( pPhrase );
    if( pszRecoText )
    {
		if( SetControlText( pszRecoText) == FALSE )
            hr=E_FAIL;
	}
    delete pszRecoText;
    return hr;
}



//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//
// The smarts for building a button grammar.
//
HRESULT CXMLVoiceCmd::InitEdit(IRCMLControl *pControl)
{
	m_ControlType=CT_EDIT;

    //
    // Check the type of the edit control,
    // string, number, file, date ...??
    //
	HRESULT hr=E_FAIL;
    if( !g_cpEngine )
        return NULL;

    m_bActive=FALSE;

#ifdef _WITH_DICTATION
    if( SUCCEEDED( hr = GetRecoContext() ))
    {
        // we use the 'shared' context here.
        if( SUCCEEDED( hr = m_cpRecoCtxt->CreateGrammar( (DWORD)this, &m_cpCmdGrammar) ))
        {
            if( SUCCEEDED( hr = m_cpCmdGrammar->LoadDictation( NULL, SPLO_STATIC ) ))  // is TRUE needed?
            {
                // Set rules to active, we are now listening for commands
                // hr = m_cpCmdGrammar->SetDictationState(SPRS_ACTIVE);
            }
        }
    }
#endif

    LPWSTR pszContent;
    if( SUCCEEDED( pControl->get_Attr(L"CONTENT", &pszContent)))
    {
        if(lstrcmpi(pszContent,L"NUMBER")==0)
        {
            // load a specific grammar.
            LoadCFG(L"c:\\cicerorcml\\numbers.xml");
        }
    }
    return ( hr );
}

//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//
// The smarts for building a button grammar.
// needs to get the properties, for UP DOWN etc.
//
HRESULT CXMLVoiceCmd::ExecuteEdit( ISpPhrase *pPhrase, IRCMLControl * pControl, HWND hWnd )
{
    if(hWnd == NULL )
        return S_FALSE; // focus lost

    if( IsEnabled( hWnd ) == FALSE )
        return E_FAIL;

    LPWSTR pszRecoText=GetRecognizedText( pPhrase );
    if( pszRecoText )
    {
		if( SetControlText( pszRecoText) == FALSE )
            return E_FAIL;
	}
    delete pszRecoText;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\xmlvoicecmd.h ===
// XMLVoiceCmd.h: interface for the CXMLVoiceCmd class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XMLVOICECMD_H__D06F5ED9_87F1_4D9F_A426_5B02D5ECE454__INCLUDED_)
#define AFX_XMLVOICECMD_H__D06F5ED9_87F1_4D9F_A426_5B02D5ECE454__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "BaseSAPI.h"
#define CICERO_ENABLE(x)  	HRESULT Init##x( IRCMLControl * pControl );     HRESULT Execute##x( ISpPhrase *pPhrase, IRCMLControl * pControl, HWND hwnd );


class CXMLVoiceCmd : public CBaseSAPI  
{
public:
    //
    // Return S_OK to SaySuccess
    // Return E_FAIL to SayFailure
    // return S_FALSE to say NOTHING.
    //
    CICERO_ENABLE(Edit);
	CICERO_ENABLE(Button);
	CICERO_ENABLE(Checkbox);
	CICERO_ENABLE(RadioButton);
	CICERO_ENABLE(Slider);
	CICERO_ENABLE(Combo);
	CICERO_ENABLE(List);

	CXMLVoiceCmd() {  m_StringType=L"CICERO:CMD"; }
	virtual ~CXMLVoiceCmd();
    NEWNODE( VoiceCmd );

    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InitNode( 
        IRCMLNode __RPC_FAR *parent);

	void Callback();
	virtual HRESULT ExecuteCommand( ISpPhrase *pPhrase );


private:
	HRESULT LoadCFGResource( LPTSTR * ppCFG, DWORD * pdwSize, LPWSTR ResourceName);
	enum
	{
		CT_BUTTON,
		CT_CHECKBOX,
		CT_SLIDER,
        CT_RADIOBUTTON,
        CT_COMBO,
        CT_LIST,
        CT_EDIT,
	} m_ControlType;
};

#endif // !defined(AFX_XMLVOICECMD_H__D06F5ED9_87F1_4D9F_A426_5B02D5ECE454__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\rcml\rcmlex\cicero\applaunch\basesapi.cpp ===
// BaseSAPI.cpp: implementation of the CBaseSAPI class.
//
// All speech related classes derive from this.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "BaseSAPI.h"
#include "filestream.h"
// #include "debug.h"
#include "utils.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

LONG CBaseSAPI::m_bInited=0;
CComPtr<ISpRecognizer>		CBaseSAPI::g_cpEngine=NULL;	// Pointer to reco engine interface
CComPtr<ISpVoice>	        	CBaseSAPI::g_cpVoice=NULL;  // Global voice for failure/success
CRITICAL_SECTION g_CritSec={0};

CBaseSAPI::CBaseSAPI()
{
	m_bActive=NULL;
    m_cpCmdGrammar=NULL;
    m_cpNumberGrammar=NULL;
    m_cpDictationGrammar=NULL;

	if( InterlockedIncrement( &m_bInited ) == 1 )
    {
        InitializeCriticalSection( & g_CritSec );
    }

    EnterCriticalSection( & g_CritSec );

    if( g_cpEngine == NULL )
    {
    	if( SUCCEEDED( InitSAPI() ))
        {
            // g_Notifications.SetText(L"You can now voice command Windows");
        }
        else
        {
            // g_Notifications.SetText(L"Please upgrade your system");
        }
    }

    LeaveCriticalSection( & g_CritSec );

    if( g_cpEngine )
    {
	    ISpRecognizer * pReco=g_cpEngine;
        // if(pReco)
	    //    pReco->AddRef();
    }
}

CBaseSAPI::~CBaseSAPI()
{
    ResetGrammar();

	g_cpEngine.Release();

	if( InterlockedDecrement( &m_bInited ) == 0 )
	{
        g_cpVoice=NULL;
        DeleteCriticalSection( &g_CritSec );
	}

/*
    if( g_cpEngine == NULL )
        CoUninitialize();
*/
}

HRESULT CBaseSAPI::ExitNode(IBaseXMLNode * parent, LONG lresult)
{
    ResetGrammar();
    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
//
// The base sapi node has provisions for a FAILURE element, and list of SYNONYMs
//
HRESULT STDMETHODCALLTYPE  CBaseSAPI::AcceptChild( 
            IBaseXMLNode __RPC_FAR *pChild)
{
    LPWSTR pType;
    LPWSTR pChildType;
    get_StringType( &pType );
    pChild->get_StringType( &pChildType );
	if( SUCCEEDED( pChild->IsType( L"CICERO:FAILURE" )))
	{
		m_cpFailure=pChild;
		return S_OK;
	}
    else if( SUCCEEDED( pChild->IsType( L"CICERO:SYNONYM" )))
	{
		// m_Synonyms.Append((CXMLSynonym*)pChild);
		return S_OK;
	}
	else if( SUCCEEDED( pChild->IsType( L"CICERO:SUCCESS" )))
	{
		m_cpSuccess=pChild;
		return S_OK;
	}
    return E_INVALIDARG;    // we don't take children.
}

//
// Taken from the SimpleCC.cpp file in the sapi sdk.
//
HRESULT CBaseSAPI::InitSAPI( void )
{
    HRESULT hr = S_OK;

    CoInitialize(NULL);
    //
    // create a recognition engine 
    // CLSID_SpInprocRecoInstance or 
    // CLSID_SpSharedRecoInstance
    //
    //         hr = m_cpRecognizer.CoCreateInstance(CLSID_SpSharedRecognizer);

    if ( SUCCEEDED( hr = g_cpEngine.CoCreateInstance(CLSID_SpSharedRecognizer) ) )
    {
#ifdef _INPROC
        //
        // We should be able to remove this REVIEW 6/12/00
        //

        CComPtr<ISpAudio> cpAudio;
        // create default audio object
        if ( SUCCEEDED( hr = SpCreateDefaultObjectFromCategoryId(SPCAT_AUDIOIN, &cpAudio) ) )
        {
            hr = g_cpEngine->SetInput(cpAudio, TRUE);
        }
#endif
    }
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
//
// This loads a memory based grammar.
// this will be replaced once SAPI loads from memory.
//
HRESULT CBaseSAPI::LoadCFGFromString( LPCTSTR szRuntimeCFG, LPCTSTR prefix  )
{
    HRESULT hr=S_OK;

// #ifdef DEBUG
    // Need to go via files because of the M2 to M3 changes.
    if( prefix == NULL )
        prefix = TEXT("temp");

    if( prefix )
    {
        //
        // This creates a file for us to look at
        //
	    int i=lstrlen( szRuntimeCFG );
        TCHAR szFile[MAX_PATH];
        wsprintf(szFile,TEXT("c:\\cicerorcml\\%s.xml"),prefix);

	    HANDLE hFile=CreateFile( szFile,
						    GENERIC_WRITE,
						    FILE_SHARE_WRITE,
						    NULL,
						    CREATE_ALWAYS,
						    FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_TEMPORARY,
						    NULL);

	    if( hFile != INVALID_HANDLE_VALUE)
	    {
		    DWORD dwWritten;
		    WriteFile( hFile, szRuntimeCFG, i*sizeof(TCHAR),&dwWritten,NULL);
		    CloseHandle(hFile);
	    }

        LoadCFG( szFile );
    }
// #endif

#if 0
    //
    // From RalphL (SAPI).
    //
    CComPtr<ISpStream> cpSrcStream;
    CComPtr<IStream> cpDestMemStream;
    CComPtr<ISpGrammarCompiler> m_cpCompiler;
    
    _MemoryStream * pMemStream= new _MemoryStream((LPBYTE)szRuntimeCFG, lstrlen(szRuntimeCFG)*sizeof(TCHAR));
    if (SUCCEEDED(hr))
    {
        hr = ::CreateStreamOnHGlobal(NULL, TRUE, &cpDestMemStream);
    }
    if (SUCCEEDED(hr))
    {   // ISpGramCompBackend
        hr = m_cpCompiler.CoCreateInstance(CLSID_SpGrammarCompiler);
    }
    if (SUCCEEDED(hr))
    {
        hr = m_cpCompiler->CompileStream(pMemStream, cpDestMemStream, NULL, NULL, NULL, 0);
    }
    if (SUCCEEDED(hr))
    {
        HGLOBAL hGlobal;
        hr = ::GetHGlobalFromStream(cpDestMemStream, &hGlobal);
        if (SUCCEEDED(hr))
        {
            SPCFGSERIALIZEDHEADER * pBinaryData = (SPCFGSERIALIZEDHEADER * )::GlobalLock(hGlobal);
            if (pBinaryData)
            {
                // hr = LoadCmdFromMemory(pBinaryData, Options);
                // create the command recognition context
                if( SUCCEEDED( hr = GetRecoContext() ))
                {
                    // we use the 'shared' context here.
                    if( SUCCEEDED( hr = m_cpRecoCtxt->CreateGrammar( (DWORD)this, &m_cpCmdGrammar) ))
                    {
                        if( SUCCEEDED( hr = m_cpCmdGrammar->LoadCmdFromMemory( pBinaryData, FALSE ) ))  // is TRUE needed?
                        {
                            // Set rules to active, we are now listening for commands
                            if( SUCCEEDED( hr = SetRuleState(TRUE) ))
                            {
                            }
                            else
                            {
                                // If we failed here, it is OK, we can recover later
                                m_bActive = false;
                                hr = S_OK;
                            }
                        }
                    }
                }
                ::GlobalUnlock(hGlobal);
            }
        }
    }
    delete pMemStream;
#endif
    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
//
// This loads a local grammar.
//
HRESULT CBaseSAPI::LoadCFG( LPCTSTR pszFileName  )
{
	HRESULT hr=E_FAIL;
    if( !g_cpEngine )
        return NULL;

    m_bActive=FALSE; 

    if(m_cpCmdGrammar )
    {
        TRACE(TEXT("This is NOT supposed to happen"));
        m_cpCmdGrammar=NULL;
#ifdef _DEBUG
        _asm int 3;
#endif
    }

    if( SUCCEEDED( hr = GetRecoContext() ))
    {
        if( SUCCEEDED( hr = m_cpRecoCtxt->CreateGrammar( (DWORD)this, &m_cpCmdGrammar) ))
        {
            if( SUCCEEDED( hr = m_cpCmdGrammar->LoadCmdFromFile( pszFileName, SPLO_STATIC )))
            {
                // Set rules to active, we are now listening for commands
#if 0
                if( SUCCEEDED( hr = SetRuleState(TRUE) ))
                {
                }
                else
                {
                    // If we failed here, it is OK, we can recover later
                    m_bActive = false;
                    hr = S_OK;
                }
#endif
            }
        }
    }

    if ( FAILED( hr ) )
    {
        // Since we couldn't initialize, we will completely shut down
		// ResetGrammar();
    }

    return ( hr );
}

HRESULT CBaseSAPI::SetRuleState(BOOL bOnOff)
{
    // Set rules to active, we are now listening for commands
    if(m_bActive==bOnOff)
        return S_OK;

    HRESULT hr=S_OK;
    m_bActive=bOnOff;
    if( m_cpCmdGrammar )
    {
        TRACE(TEXT("Turning %s grammars ..."),bOnOff?TEXT("ON "):TEXT("OFF"));
#ifdef _WITH_DICTATION
        m_cpCmdGrammar->SetDictationState(bOnOff?SPRS_ACTIVE:SPRS_INACTIVE);
#endif

        if( m_cpNumberGrammar )
            m_cpNumberGrammar->SetRuleState(
            NULL, 
            NULL, 
            bOnOff?SPRS_ACTIVE:SPRS_INACTIVE);

        // if( m_cpDictationGrammar )
        hr=m_cpCmdGrammar->SetRuleState(
            NULL, 
            NULL, 
            bOnOff?SPRS_ACTIVE:SPRS_INACTIVE); // ,       // enable the rule
            // FALSE );
        TRACE(TEXT("done\n"));
    }
    return hr;
}

/******************************************************************************
* ResetGrammar   *
*----------------*
*   Description:
*       Called to close down SAPI COM objects we have stored away.
*
******************************************************************************/
void CBaseSAPI::ResetGrammar( void )
{
    if( m_cpCmdGrammar )
        m_cpCmdGrammar.Release();

    if( m_cpDictationGrammar )
        m_cpDictationGrammar.Release();

    if( m_cpRecoCtxt )
    {
        m_cpRecoCtxt->SetNotifySink(NULL);  
        m_cpRecoCtxt.Release(); // this will release us.
    }
}

/******************************************************************************
* ProcessRecoEvent *
*------------------*
*   Description:
*       Called to when reco event message is sent to main window procedure.
*       In the case of a recognition, it extracts result and calls ExecuteCommand.
*
******************************************************************************/
void CBaseSAPI::ProcessRecoEvent( void )
{
    CSpEvent event;  // Event helper class

    // Loop processing events while there are any in the queue
    while ( S_OK == event.GetFrom(m_cpRecoCtxt) )
    {
        // Look at recognition event only
        if ( SPEI_RECOGNITION == event.eEventId )
        {
            // m_cCmdManager.ExecuteCommand(event.RecoResult());
        }
    }
}

//
// Returne true if it managed to set the text, false otherwise.
//
BOOL CBaseSAPI::SetControlText( LPCWSTR dstrText )
{
	return FALSE;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// This will take a string like "&About ..." and return "About"
// or "Try to R&einvest" and return "Reinvest"
//
LPWSTR CBaseSAPI::FindNiceText(LPCWSTR text)
{
    if( text==NULL )
        return NULL;

    LPCWSTR pszLastSpace=text;
    BOOL bFoundAccelorator=FALSE;
    LPCWSTR pszCurrentChar=text;
    while(*pszCurrentChar)
    {
        if( *pszCurrentChar == L'&' )
        {
            bFoundAccelorator=TRUE;
            break;
        }
        if( *pszCurrentChar == L' ' )
            pszLastSpace=pszCurrentChar+1;

        pszCurrentChar++;
    }

    //
    // If we found an &, then we know which word it is on.
    //
    pszCurrentChar = pszLastSpace;
    BOOL bFindingEnd=TRUE;
    UINT iStrLen=0;
    while( bFindingEnd )
    {
        switch (*pszCurrentChar )
        {
            case L' ':
            case L'.':
            case 0:
                bFindingEnd=FALSE;  // we're left pointing at the terminating char.
                break;
            default:
                pszCurrentChar++;
                iStrLen++;
                break;
        }
    };

    LPWSTR pszNewString = new TCHAR[iStrLen+1];

    if( bFoundAccelorator==FALSE )
    {
        ZeroMemory( pszNewString, (iStrLen+1)*sizeof(WCHAR) );
        CopyMemory( pszNewString, pszLastSpace, iStrLen*sizeof(WCHAR));
    }
    else
    {
        // copy, skipping over the & and the ... if present (though they shouldn't be).
        LPWSTR pszDest=pszNewString;
        LPCWSTR pszLastChar=pszCurrentChar;
        pszCurrentChar = pszLastSpace;
        while( pszCurrentChar != pszLastChar )
        {
            if( *pszCurrentChar==L'&' || *pszCurrentChar==L'.' )
            {
            }
            else
                *pszDest++=*pszCurrentChar;
            pszCurrentChar++;
        };
        *pszDest=0;
    }
    return pszNewString;
}

LPWSTR CBaseSAPI::GetRecognizedText(ISpPhrase *pPhrase)
{
    SPPHRASE *pElements;
	LPTSTR pszPropertyName;
	
    // Get the phrase elements, one of which is the rule id we specified in
    // the grammar.  Switch on it to figure out which command was recognized.
    if (SUCCEEDED(pPhrase->GetPhrase(&pElements)))
    {
        CSpDynamicString dstrText;

		BOOL bPropFound=FALSE;
		if( SUCCEEDED( get_Attr(L"PROPNAME", & pszPropertyName) ))
		{
			// find the property name we were looking for.
			if( pElements )
			{
				const SPPHRASEPROPERTY * pProperty=pElements->pProperties;
				while(pProperty)
				{
					if( lstrcmpi( pProperty->pszName, pszPropertyName ) == 0 )
					{
						ULONG FirstElement=pProperty->ulFirstElement;
						if( FirstElement < pElements->Rule.ulCountOfElements )
						{
							dstrText=pElements->pElements[FirstElement].pszDisplayText;
							pProperty=NULL;
							bPropFound=TRUE;
							continue;
						}
					}
					pProperty= pProperty->pNextSibling;
				}
			}
		}

		//
		// Even if they specified a property name, perhaps we ignore it??
		//
		if(bPropFound==FALSE)
			pPhrase->GetText( SP_GETWHOLEPHRASE, SP_GETWHOLEPHRASE, TRUE, &dstrText, NULL);

        LPWSTR pszText = new WCHAR[ lstrlen(dstrText)+1];
        lstrcpy(pszText, dstrText );
        return pszText;
    }
    return NULL;
}

void CBaseSAPI::SayFailure()
{
	if( m_cpFailure )
	{
		LPWSTR pszText;
		if( SUCCEEDED( m_cpFailure->get_Attr( L"TEXT", &pszText )))
		{
            if( GetVoice() )
                g_cpVoice->Speak( pszText, 0, NULL);
		}
	}
}

void CBaseSAPI::SaySuccess()
{
	if( m_cpSuccess )
	{
		LPWSTR pszText;
		if( SUCCEEDED( m_cpSuccess->get_Attr( L"TEXT", &pszText )))
		{
            if( GetVoice() )
                g_cpVoice->Speak( pszText, 0, NULL);
		}
	}
}

LPWSTR CBaseSAPI::GetRecognizedRule(ISpPhrase *pPhrase)
{
    SPPHRASE *pElements;
	LPTSTR pszPropertyName=NULL;

	
    // Get the phrase elements, one of which is the rule id we specified in
    // the grammar.  Switch on it to figure out which command was recognized.
    if (SUCCEEDED(pPhrase->GetPhrase(&pElements)))
    {
#ifdef DEBUG
        CSpDynamicString dstrText;
        pPhrase->GetText(SP_GETWHOLEPHRASE, SP_GETWHOLEPHRASE, TRUE, &dstrText, NULL);
        TRACE(TEXT("I heard %s\n"),dstrText);
#endif

        LPCWSTR pszRuleName;
        //
		// find the property name we were looking for.
        //
		if( pElements )
            pszRuleName = pElements->Rule.pszName;


        LPWSTR pszText = new WCHAR[ lstrlen(pszRuleName)+1];
        lstrcpy(pszText, pszRuleName );
        return pszText;
    }
    return NULL;
}

//
// Non - visible too?
//
BOOL CBaseSAPI::IsEnabled(HWND hWnd)
{
    LONG    style=GetWindowLong( hWnd, GWL_STYLE );
    if( style & WS_DISABLED )
        return FALSE;
    if( style & WS_VISIBLE)
        return TRUE;
    return FALSE;
}




//
// We keep a property on the RCML root node pointing to the context
//
HRESUL