                 &Adapter->LowerMpHandle,
                    &MediaIndex,
                    MediumArray,
                    MediumArraySize,
                    ClientProtocolHandle,
                    Adapter,
                    MpDeviceName,
                    0,
                    NULL);

    if(OpenAdapterStatus == NDIS_STATUS_PENDING)
    {
        NdisWaitEvent(&Adapter->BlockingEvent, 0);
        NdisResetEvent(&Adapter->BlockingEvent);

    } 
    else 
    {
        Adapter->FinalStatus = OpenAdapterStatus;
    }

    if(Adapter->FinalStatus == NDIS_STATUS_SUCCESS)
    {
        Adapter->MediaType = MediumArray[MediaIndex];

        //
        // Take a ref for the open
        //
        REFADD(&Adapter->RefCount, 'NDOP');
        
    }
    else 
    {
        PsDbgOut(DBG_FAILURE,
                 DBG_PROTOCOL,
                 ("[ClBindToLowerMp]: Adapter %08X, binding failed (Status = %08X) \n", 
                  Adapter, 
                  Status));

        *Status = Adapter->FinalStatus;

        PsAdapterWriteEventLog(
            EVENT_PS_BINDING_FAILED,
            0,
            &Adapter->MpDeviceName,
            sizeof(Adapter->FinalStatus),
            &Adapter->FinalStatus);

        PsDeleteDevice();

        REFDEL(&Adapter->RefCount, FALSE, 'NDOP');

        DRIVER_COUNTED_UNBLOCK;

        return;
    }

    //
    // Get the information pertaining to the miniport below us.
    //


    while(1)
   {
	    *Status = GetFrameSize(Adapter);

	    if(*Status != NDIS_STATUS_SUCCESS) 
	    {
	    	if( GetFrameSizeRetryCount == MAX_GET_FRAME_SIZE_RETRY_COUNT)
	      {
	        	goto ErrorCloseOpen;
	      }        	
	    	else
	      {
	    		GetFrameSizeRetryCount++;
	    		DbgPrint("PSCHED: Requery FRAME_SIZE #%d\n",GetFrameSizeRetryCount);
	    		NdisMSleep( WAIT_TIME_FOR_GET_FRAME_SIZE * 1000 * 1000);
		}    		
	    }
	    else
          {
          	break;
	    }
    }
   
    Adapter->RawLinkSpeed = (ULONG)UNSPECIFIED_RATE;
    
    *Status = UpdateAdapterBandwidthParameters(Adapter);
    
    if(*Status != NDIS_STATUS_SUCCESS)
    {
        if(*Status != NDIS_STATUS_ADAPTER_NOT_READY)
        {
            PsDbgOut(DBG_FAILURE, 
                     DBG_PROTOCOL | 
                     DBG_INIT,
                     ("[ClBindToLowerMp]: Adapter %08X, couldn't add pipe %08X\n",
                      Adapter, 
                      Status));
            
            goto ErrorCloseOpen;
        }
        else 
        {
            // The scheduling components have not registered. Let's not call NdisIMInitializeDeviceInstance.
            //
            *Status = NDIS_STATUS_SUCCESS;
            
            Adapter->PsMpState = AdapterStateWaiting;
        }
    	}

    // Let's move the creation of IM device here, to see what happens.
    *Status = PsInitializeDeviceInstance(Adapter);

    if(*Status != NDIS_STATUS_SUCCESS)
    {
    	goto ErrorCloseOpen;
    }

   // Ignore the status
    PsReadMiniportOIDs(Adapter);

    PsUpdateLinkSpeed(Adapter, Adapter->RawLinkSpeed,
                      &Adapter->RemainingBandWidth,
                      &Adapter->LinkSpeed,
                      &Adapter->NonBestEffortLimit,
                      &Adapter->Lock);


// This will repro the NetReady bug anywhere, anytime.
//	NdisMSleep( 5 * 1000 * 1000 );

    REFDEL(&Adapter->RefCount, FALSE, 'NDOP');


    DRIVER_COUNTED_UNBLOCK;

    return;

ErrorCloseOpen:


    // 
    // if we have opened an underlying call manager, close it now.
    //
    
    if(Adapter->MediaType == NdisMediumWan) {

        PS_LOCK(&Adapter->Lock);

        if(Adapter->ShutdownMask & SHUTDOWN_CLOSE_WAN_ADDR_FAMILY){

            Adapter->ShutdownMask &= ~SHUTDOWN_CLOSE_WAN_ADDR_FAMILY;

            PS_UNLOCK(&Adapter->Lock);
            
            PsDbgOut(DBG_TRACE, DBG_WAN | DBG_MINIPORT,
                     ("[ClBindToLowerMp]: Adapter %08X Closing the WAN address family", Adapter));
            
            LocalStatus = NdisClCloseAddressFamily(Adapter->WanCmHandle);
            
        }
        else
        {
            PS_UNLOCK(&Adapter->Lock);
        }
    }

    //
    // Close the open since we opened it above
    //

    if(Adapter->LowerMpHandle) 
    {
        NdisCloseAdapter(&LocalStatus, Adapter->LowerMpHandle);
        
        if(LocalStatus == NDIS_STATUS_PENDING) 
        {
            NdisWaitEvent(&Adapter->BlockingEvent, 0);
            
            NdisResetEvent(&Adapter->BlockingEvent);
        }
       
        REFDEL(&Adapter->RefCount, FALSE, 'NDOP'); 
        
    }

    PsDeleteDevice();

    REFDEL(&Adapter->RefCount, FALSE, 'NDOP');

    DRIVER_COUNTED_UNBLOCK;

    return;

} // ClBindToLowerMp


VOID
LinkSpeedQueryComplete(
    PADAPTER Adapter,
    NDIS_STATUS Status
    )

/*++

Routine Description:

    Completion routine for link speed query during a status indication. Notify
    the scheduling alg. that we have a new adapter

Arguments:

    the usual...

Return Value:

    None

--*/

{
    PsDbgOut(DBG_INFO, 
             DBG_PROTOCOL,
             ("[LinkSpeedQueryComplete]: Adapter %08X, Status %x, Link speed %d\n", 
              Adapter, Status, 
              Adapter->LinkSpeed*100));
    
    if ( !NT_SUCCESS( Status )) 
    {
        Adapter->RawLinkSpeed = (ULONG)UNSPECIFIED_RATE;

        PsAdapterWriteEventLog(
            EVENT_PS_QUERY_OID_GEN_LINK_SPEED,
            0,
            &Adapter->MpDeviceName,
            sizeof(Status),
            &Status);
        
    }
          
    UpdateAdapterBandwidthParameters(Adapter);
}

VOID
PsGetLinkSpeed (
    IN PADAPTER Adapter
)
{
    NDIS_STATUS Status;

    Status = MakeLocalNdisRequest(Adapter,
                                  NULL,
                                  NdisRequestLocalQueryInfo,
                                  OID_GEN_LINK_SPEED,
                                  &Adapter->RawLinkSpeed,
                                  sizeof(Adapter->RawLinkSpeed),
                                  LinkSpeedQueryComplete);
    
    if (Status != NDIS_STATUS_PENDING)
    {
        LinkSpeedQueryComplete(Adapter, Status);
    }
}


NDIS_STATUS
PsReadMiniportOIDs(
    IN  PADAPTER Adapter
    )

/*++

Routine Description:

    Complete the binding on the lower miniport. Initialize the 
    adapter structure, query the MP for certain funtionality and 
    initialize the associated PS miniport device

Arguments:

    see the DDK

Return Values:

    None

--*/

{
    NDIS_STATUS          Status;
    PWSTR                SecondaryName;
    NDIS_HARDWARE_STATUS HwStatus;
    NDIS_MEDIA_STATE     MediaState = 0xFFFFFFFF;
    NDIS_STRING          PsDevName;
    ULONG                MacOptions;
    ULONG                LinkSpeed;

    PsDbgOut(DBG_TRACE, 
             DBG_PROTOCOL, 
             ("[PsReadMiniportOIDs]: Adapter %08X \n", Adapter));


    Status = MakeLocalNdisRequest(Adapter,
                                  NULL,
                                  NdisRequestLocalQueryInfo,
                                  OID_GEN_MEDIA_CONNECT_STATUS,
                                  &MediaState,
                                  sizeof( MediaState ),
                                  NULL);
   
    PsAssert(Status != NDIS_STATUS_INVALID_OID || Status != NDIS_STATUS_NOT_SUPPORTED);

    if(Status == NDIS_STATUS_SUCCESS && MediaState == NdisMediaStateConnected){
    
        Status = MakeLocalNdisRequest(Adapter,
                                      NULL,
                                      NdisRequestLocalQueryInfo,
                                      OID_GEN_LINK_SPEED,
                                      &Adapter->RawLinkSpeed,
                                      sizeof(LinkSpeed),
                                      NULL);
        if(Status != NDIS_STATUS_SUCCESS){ 
            
            PsDbgOut(DBG_INFO, 
                     DBG_PROTOCOL,
                     ("[PsReadMiniportOIDs]: Adapter %08X, Can't get link "
                      "speed - Status %08X\n", Adapter, Status));
            
            Adapter->RawLinkSpeed = (ULONG)UNSPECIFIED_RATE;

            PsAdapterWriteEventLog(
                EVENT_PS_QUERY_OID_GEN_LINK_SPEED,
                0,
                &Adapter->MpDeviceName,
                sizeof(Status),
                &Status);
        }
        
        PsDbgOut(DBG_INFO, 
                 DBG_PROTOCOL, 
                 ("[PsReadMiniportOIDs] Adapter %08X, Link speed %d\n",
                  Adapter, 
                  Adapter->RawLinkSpeed*100));
    } 
    else{

        //
        // We can continue, even though we don't yet have the 
        // link speed. We'll update it later.
        //
        
        Adapter->RawLinkSpeed = (ULONG)UNSPECIFIED_RATE;
        
        PsDbgOut(DBG_INFO, 
                 DBG_PROTOCOL,
                 ("[PsReadMiniportOIDs]: Adapter %08X, Media not connected\n",
                  Adapter));
        
    }
 
    return Status;

} // PsReadMiniportOIDs

VOID
PsUpdateLinkSpeed(
    PADAPTER      Adapter,
    ULONG         RawLinkSpeed,
    PULONG        RemainingBandWidth,
    PULONG        LinkSpeed,
    PULONG        NonBestEffortLimit,
    PPS_SPIN_LOCK Lock
)
{
    ULONG              NewNonBestEffortLimit;

    PS_LOCK(Lock);

    if(RawLinkSpeed == UNSPECIFIED_RATE)
    {

        //
        // It is legit to have an unspecified rate - We pend
        // all finite rate flows till we know the link speed.
        // Indefinite rate flows will be admitted.
        //
        
        *LinkSpeed = UNSPECIFIED_RATE;
        Adapter->PipeHasResources = FALSE;
    }
    else 
    {
        //
        // RawLinkSpeed is in 100 bps units. Convert it to 100 Bytes per second
        // and then into Bytes Per Second.
        //
        *LinkSpeed = RawLinkSpeed / 8;
        *LinkSpeed = (ULONG)(*LinkSpeed * 100); 
        
        PsDbgOut(DBG_TRACE, DBG_PROTOCOL, 
                 ("[PsUpdateLinkSpeed]: Adapter %08X, Link Speed %d \n", 
                  Adapter, *LinkSpeed)); 
        
        Adapter->PipeHasResources = TRUE;
        
        //
        // The NBE is a % of the link speed. If the link speed changes, we need to
        // change this value.
        //
        
        NewNonBestEffortLimit = Adapter->ReservationLimitValue * (*LinkSpeed / 100);
        
        PsDbgOut(DBG_INFO, DBG_PROTOCOL,
                 ("[PsUpdateLinkSpeed]: Adapter %08X, LinkSpeed %d, NBE %d, "
                  " Remaining b/w = %d, New NBE = %d \n",
                  Adapter, *LinkSpeed, *NonBestEffortLimit, 
                  *RemainingBandWidth, NewNonBestEffortLimit));
        
        if(NewNonBestEffortLimit >= *NonBestEffortLimit) {
            
            //
            // The bandwidth has increased - we need not do anything with
            // the flows that have already been created. Also, if RemainingBandWidth < 
            // NonBestEffortLimit, then some of the resources have been allocated to flows
            // that were already created - We need to subtract this from the new 
            // RemainingBandWidth.
            //
            
            *RemainingBandWidth = NewNonBestEffortLimit - (*NonBestEffortLimit - *RemainingBandWidth);
            
            *NonBestEffortLimit = NewNonBestEffortLimit;
        }
        else {
            
            //
            // Sigh. The bandwidth has decreased. We may need to delete some of the flows
            //
            
            if(*RemainingBandWidth == *NonBestEffortLimit) 
            {
                
                //
                // No flows were created as yet - Just update the 2 values
                //
                *NonBestEffortLimit = *RemainingBandWidth = NewNonBestEffortLimit;
            }
            else {
                if((*NonBestEffortLimit - *RemainingBandWidth) <= (NewNonBestEffortLimit)) {
                    
                    //
                    // The flows that were created are under the new limit.
                    //
                    
                    *RemainingBandWidth = NewNonBestEffortLimit - (*NonBestEffortLimit - *RemainingBandWidth);
                    
                    *NonBestEffortLimit = NewNonBestEffortLimit;
                }
                else 
                {
                    *RemainingBandWidth = NewNonBestEffortLimit - (*NonBestEffortLimit - *RemainingBandWidth);
                    *NonBestEffortLimit = NewNonBestEffortLimit;

                    PsAdapterWriteEventLog(
                        EVENT_PS_ADMISSIONCONTROL_OVERFLOW,
                        0,
                        &Adapter->MpDeviceName,
                        0,
                        NULL);
                }
            }
            
        }

    }

    PS_UNLOCK(Lock);
}


NDIS_STATUS
UpdateAdapterBandwidthParameters(
    PADAPTER Adapter
    )

{
    PsUpdateLinkSpeed(Adapter, Adapter->RawLinkSpeed,
                      &Adapter->RemainingBandWidth,
                      &Adapter->LinkSpeed,
                      &Adapter->NonBestEffortLimit,
                      &Adapter->Lock);

    return UpdateSchedulingPipe(Adapter);
}



VOID
ClLowerMpOpenAdapterComplete(
    IN  PADAPTER Adapter,
    IN  NDIS_STATUS Status,
    IN  NDIS_STATUS OpenErrorStatus
    )

/*++

Routine Description:

    Signal that the binding on the lower miniport is complete

Arguments:

    see the DDK

Return Values:

    None

--*/

{

    PsDbgOut(DBG_TRACE, DBG_PROTOCOL, ("[ClLowerMpOpenAdapterComplete]: Adapter %08X\n", 
                                       Adapter));

    //
    // stuff the final status in the Adapter block and signal 
    // the bind handler to continue
    //

    Adapter->FinalStatus = Status;
    NdisSetEvent( &Adapter->BlockingEvent );

} // ClLowerMpOpenAdapterComplete


NDIS_STATUS
GetFrameSize(
    PADAPTER Adapter
    )

/*++

Routine Description:

    This routine queries the underlying adapter to derive the total
    frame size and the header size. (Total = Frame + Header)

Arguments:

    Adapter - pointer to adapter context block

Return Value:

    None

--*/

{
    NDIS_STATUS Status;
    ULONG       i;
    ULONG       FrameSize;            // doesn't include the header

    //
    // max amount of data w/o the MAC header
    //

    Status = MakeLocalNdisRequest(Adapter,
                                  NULL,
                                  NdisRequestLocalQueryInfo,
                                  OID_GEN_MAXIMUM_FRAME_SIZE,
                                  &FrameSize,
                                  sizeof(FrameSize),
                                  NULL);

    if(Status != NDIS_STATUS_SUCCESS){

        PsDbgOut(DBG_FAILURE, 
                 DBG_PROTOCOL,
                 ("[GetFrameSize]: Adapter %08X, Can't get frame size - Status %08X\n",
                 Adapter, 
                 Status));

        PsAdapterWriteEventLog(
            EVENT_PS_QUERY_OID_GEN_MAXIMUM_FRAME_SIZE,
            0,
            &Adapter->MpDeviceName,
            sizeof(Status), 
            &Status);

        return Status;
    }

    //
    // this one includes the header
    //

    Status = MakeLocalNdisRequest(Adapter,
                                  NULL,
                                  NdisRequestLocalQueryInfo,
                                  OID_GEN_MAXIMUM_TOTAL_SIZE,
                                  &Adapter->TotalSize,
                                  sizeof(Adapter->TotalSize),
                                  NULL);

    if(Status != NDIS_STATUS_SUCCESS){

        PsDbgOut(DBG_FAILURE, 
                 DBG_PROTOCOL,
                 ("(%08X) GetFrameSize: Can't get total size - Status %08X\n",
                 Adapter, 
                 Status));

        PsAdapterWriteEventLog(
            EVENT_PS_QUERY_OID_GEN_MAXIMUM_TOTAL_SIZE,
            0,
            &Adapter->MpDeviceName,
            sizeof(Status), 
            &Status);

        return Status;

    }

    //
    // figure the real header size
    //

    Adapter->HeaderSize = Adapter->TotalSize - FrameSize;

    return Status;

}   // GetFrameSize


NDIS_STATUS
GetSchedulerPipeContext(
    PADAPTER Adapter,
    PPS_PIPE_CONTEXT *AdapterPipeContext,
    PPSI_INFO *AdapterPsComponent,
    PULONG  ShutdownMask
    )

/*++

Routine Description:

    Allocate the pipe context area for the scheduler.

Arguments:

    Adapter - pointer to adapter context struct

Return Value:

    NDIS_STATUS_SUCCESS, otherwise appropriate error value

--*/

{
    ULONG            Index = 0;
    PPS_PROFILE      ProfileConfig;
    PPSI_INFO        PsComponent;
    ULONG            ContextLength = 0;
    ULONG            FlowContextLength = 0;
    ULONG            ClassMapContextLength = 0;
    PPS_PIPE_CONTEXT PipeContext, PrevContext;
    ULONG            PacketReservedLength = sizeof(PS_SEND_PACKET_CONTEXT);
    PVOID            PipeCxt;

    //
    // If there is no profile defined for this adapter, use defaults.
    //
    if(FindProfile(&Adapter->ProfileName, &ProfileConfig) == NDIS_STATUS_SUCCESS)
    {
        PsDbgOut(DBG_TRACE, 
                 DBG_PROTOCOL,
                 ("[GetSchedulerPipeContext]: Using %ws profile for adapter "
                  " 0x%x \n", Adapter->ProfileName.Buffer, Adapter));
        //
        // Need to lock here as there could be a race 
        // condition between the RegisterPsComponent
        // Note, however there is no race condition if all 
        // components have registered, so we can release the lock.
        //
        PS_LOCK(&PsProfileLock);
        if(ProfileConfig->UnregisteredAddInCnt != 0)
        {
            PS_UNLOCK(&PsProfileLock);
            PsDbgOut(DBG_TRACE, DBG_PROTOCOL,
                     ("[GetSchedulerPipeContext]: Adapter 0x%x is not ready\n",
                      Adapter));
            return NDIS_STATUS_ADAPTER_NOT_READY;
        }
        PS_UNLOCK(&PsProfileLock);
    }
    else 
    {
        PsDbgOut(DBG_TRACE, 
                 DBG_PROTOCOL,
                 ("[GetSchedulerPipeContext]: Profile not supplied / not found"
                  " using default for adapter 0x%x \n", Adapter));

        ProfileConfig  = &DefaultSchedulerConfig;
    }
    for (Index = 0; Index < ProfileConfig->ComponentCnt; Index++) 
    {
        ContextLength += 
            ProfileConfig->ComponentList[Index]->PipeContextLength;
        FlowContextLength += 
            ProfileConfig->ComponentList[Index]->FlowContextLength;
        ClassMapContextLength +=
            ProfileConfig->ComponentList[Index]->ClassMapContextLength;

        PacketReservedLength += ProfileConfig->ComponentList[Index]->PacketReservedLength;
    }

    Adapter->FlowContextLength = FlowContextLength;
    Adapter->ClassMapContextLength = ClassMapContextLength;
    Adapter->PacketContextLength = PacketReservedLength;

    if(AdapterPipeContext)
    {
        PacketReservedLength = sizeof(PS_SEND_PACKET_CONTEXT);

        PsAllocatePool( PipeContext, ContextLength, PipeContextTag );

        *AdapterPipeContext = PipeContext;

        if ( *AdapterPipeContext == NULL ) {
    
            return NDIS_STATUS_RESOURCES;
        }

        *ShutdownMask |= SHUTDOWN_FREE_PS_CONTEXT;
    
        // Set up the context buffer
    
        PrevContext = NULL;
    
        for (Index = 0; Index < ProfileConfig->ComponentCnt; Index++) 
        {
            PsComponent = ProfileConfig->ComponentList[Index];
     
            PipeContext->NextComponentContext = (PPS_PIPE_CONTEXT)
                ((UINT_PTR)PipeContext + PsComponent->PipeContextLength);
            PipeContext->PrevComponentContext = PrevContext;
    
            if(Index+1 == ProfileConfig->ComponentCnt)
            {
                PipeContext->NextComponent = 0;
            }
            else 
            {
                PipeContext->NextComponent = 
                    ProfileConfig->ComponentList[Index + 1];
            }
    
            if (PsComponent->PacketReservedLength > 0) 
            {
                PipeContext->PacketReservedOffset = PacketReservedLength;
                PacketReservedLength += 
                PsComponent->PacketReservedLength;
            } else 
            {
                PipeContext->PacketReservedOffset = 0;
            }

            PrevContext = PipeContext;
            PipeContext = PipeContext->NextComponentContext;
        }

        *AdapterPsComponent = ProfileConfig->ComponentList[0];
    }
    

    return NDIS_STATUS_SUCCESS;


} // GetSchedulerPipeContext

NDIS_STATUS
UpdateWanSchedulingPipe(PPS_WAN_LINK WanLink)
{
     NDIS_STATUS        Status = NDIS_STATUS_SUCCESS;
     PS_PIPE_PARAMETERS PipeParameters;
     PADAPTER           Adapter = WanLink->Adapter;
 
     // 
     // Initialize pipe parameters.
     // UNSPECIFIED_RATE indicates that the link speed is currently
     // unknown. This is a legitimate initialization value.
     //

     PS_LOCK(&Adapter->Lock);

     PS_LOCK_DPC(&WanLink->Lock);

     PipeParameters.Bandwidth            = WanLink->LinkSpeed;
     PipeParameters.MTUSize              = Adapter->TotalSize;
     PipeParameters.HeaderSize           = Adapter->HeaderSize;
     PipeParameters.Flags                = Adapter->PipeFlags;
     PipeParameters.MaxOutstandingSends  = Adapter->MaxOutstandingSends;
     PipeParameters.SDModeControlledLoad = Adapter->SDModeControlledLoad;
     PipeParameters.SDModeGuaranteed     = Adapter->SDModeGuaranteed;
     PipeParameters.SDModeNetworkControl = Adapter->SDModeNetworkControl;
     PipeParameters.SDModeQualitative    = Adapter->SDModeQualitative;
     PipeParameters.RegistryPath         = &Adapter->RegistryPath;
 
     PS_UNLOCK_DPC(&WanLink->Lock);

     PS_UNLOCK(&Adapter->Lock);
 
     //
     // Initialize the pipe for only the first time
     //
 
     if ( !(WanLink->ShutdownMask & SHUTDOWN_DELETE_PIPE )) {
 
         //
         // Allocate and initialize the context buffer for the scheduler.
         //
 
         Status = GetSchedulerPipeContext( Adapter, 
                                           &WanLink->PsPipeContext, 
                                           &WanLink->PsComponent, 
                                           &WanLink->ShutdownMask );

         if ( !NT_SUCCESS( Status )) 
         {
             return Status;
         }

         WanLink->BestEffortVc.PsPipeContext = WanLink->PsPipeContext;
         WanLink->BestEffortVc.PsComponent   = WanLink->PsComponent;

        // Need to set the pipe's media type here.. //
         PipeParameters.MediaType = NdisMediumWan;
 
         Status = (*WanLink->PsComponent->InitializePipe)(
             Adapter,
             &PipeParameters,
             WanLink->PsPipeContext,
             &PsProcs,
             NULL);
 
         if (NT_SUCCESS(Status))
         {
             WanLink->ShutdownMask |= SHUTDOWN_DELETE_PIPE;
         }
 
     }
     else{
 
         // Pipe's already been initialized. This is a modify
 
         Status = (*WanLink->PsComponent->ModifyPipe)(
             WanLink->PsPipeContext,
             &PipeParameters);
     }
 
     return Status;
  
}



NDIS_STATUS
UpdateSchedulingPipe(
    PADAPTER Adapter
    )

/*++

Routine Description:

    Initialize a scheduling pipe on the adapter. Always called with a LOCK
    held.

Arguments:

    Adapter - pointer to adapter context struct

Return Value:

    NDIS_STATUS_SUCCESS, otherwise appropriate error value

--*/

{
    NDIS_STATUS        Status = NDIS_STATUS_SUCCESS;
    PS_PIPE_PARAMETERS PipeParameters;

    // 
    // Initialize pipe parameters.
    // UNSPECIFIED_RATE indicates that the link speed is currently
    // unknown. This is a legitimate initialization value.
    //
    PS_LOCK(&Adapter->Lock);

    PipeParameters.Bandwidth            = Adapter->LinkSpeed;
    PipeParameters.MTUSize              = Adapter->TotalSize;
    PipeParameters.HeaderSize           = Adapter->HeaderSize;
    PipeParameters.Flags                = Adapter->PipeFlags;
    PipeParameters.MaxOutstandingSends  = Adapter->MaxOutstandingSends;
    PipeParameters.SDModeControlledLoad = Adapter->SDModeControlledLoad;
    PipeParameters.SDModeGuaranteed     = Adapter->SDModeGuaranteed;
    PipeParameters.SDModeNetworkControl = Adapter->SDModeNetworkControl;
    PipeParameters.SDModeQualitative    = Adapter->SDModeQualitative;
    PipeParameters.RegistryPath         = &Adapter->RegistryPath;

    PS_UNLOCK(&Adapter->Lock);

    //
    // Initialize the pipe for only the first time
    //

    if ( !(Adapter->ShutdownMask & SHUTDOWN_DELETE_PIPE )) 
    {

        //
        // We don't run the scheduling components on the Adapter structure for NDISWAN.
        // Each wanlink has its own set of scheduling components. But, we still need to compute the 
        // PacketPool Length and allocate the Packet Pool - Hence we have to call GetSchedulerPipeContext
        //

        if(Adapter->MediaType == NdisMediumWan)
        {
            //
            // Allocate and initialize the context buffer for the scheduler.
            //
    
            Status = GetSchedulerPipeContext( Adapter, 
                                              NULL,
                                              NULL,
                                              NULL);
        }
        else 
        {
            Status = GetSchedulerPipeContext( Adapter, 
                                              &Adapter->PsPipeContext, 
                                              &Adapter->PsComponent, 
                                              &Adapter->ShutdownMask);

        }
    
        if ( !NT_SUCCESS( Status )) 
        {
            return Status;
        }

        if(Adapter->MediaType == NdisMediumWan)
        {

            Adapter->ShutdownMask |= SHUTDOWN_DELETE_PIPE;
            
            PsAssert(!(Adapter->ShutdownMask & SHUTDOWN_FREE_PS_CONTEXT));
            PsAssert(!Adapter->PsPipeContext);
            PsAssert(!Adapter->PsComponent);
            
        }
        else 
        {
            // Need to set the pipe's media type here.. //
            PipeParameters.MediaType = Adapter->MediaType;
        
            Status = (*Adapter->PsComponent->InitializePipe)(
                Adapter,
                &PipeParameters,
                Adapter->PsPipeContext,
                &PsProcs,
                NULL);
            
            if (NT_SUCCESS(Status)) {
                
                Adapter->ShutdownMask |= SHUTDOWN_DELETE_PIPE;
            }
            else 
            {
                return Status;
            }
        }
        

    }
    else
    {
        // Pipe's already been initialized. This is a modify

        if(Adapter->MediaType != NdisMediumWan) 
        {
            Status = (*Adapter->PsComponent->ModifyPipe)(
                            Adapter->PsPipeContext,
                            &PipeParameters);
        }
    }

    return Status;

} // UpdateSchedulingPipe
 

NDIS_STATUS
MpInitialize(
        OUT PNDIS_STATUS    OpenErrorStatus,
        OUT PUINT           SelectedMediumIndex,
        IN  PNDIS_MEDIUM    MediumArray,
        IN  UINT            MediumArraySize,
        IN  NDIS_HANDLE     MiniportAdapterHandle,
        IN  NDIS_HANDLE     WrapperConfigurationContext
        )

/*++

Routine Description:

    Packet scheduler's device initialization routine. The list of media types is
    checked to be sure it is one that we support. If so, match up the name of
    the device being opened with one of the adapters to which we've bound.

Arguments:

    See the DDK...

Return Values:

    None

--*/

{
    PADAPTER        Adapter;
    NDIS_STATUS     Status;
    BOOLEAN         FakingIt           = FALSE;
    NDIS_STRING     MpDeviceName;


    //
    // We're being called to initialize one of our miniport
    // device instances. We triggered this by calling 
    // NdisIMInitializeDeviceInstance when we were asked to 
    // bind to the adapter below us. We provided a pointer
    // to the ADAPTER struct corresponding to the actual 
    // adapter we opened. We can get that back now, with the
    // following call.
    //

    Adapter = NdisIMGetDeviceContext(MiniportAdapterHandle);

    PsStructAssert(Adapter);
    PsDbgOut(DBG_TRACE, DBG_MINIPORT | DBG_INIT, ("[MpInitialize]: Adapter %08X \n", Adapter));
     
    Adapter->ShutdownMask |= SHUTDOWN_MPINIT_CALLED;

    // 
    // We assume that the faster packet APIs will be used, and initialize our per-packet pool. If we don't get a packet-stack,
    // we'll initialize the NDIS packet pool and free the per-packet pool (since the NDIS packet pool will have space for a per-packet
    // pool).
    //
    // We cannot know about the old or new packet stack API at bind time (because even if we did know our position in the packet stack, and 
    // initialized the old APIs, we could get a newly allocated packet from an IM above us which will have room for a packet stack).
    //

    Adapter->SendBlockPool = NdisCreateBlockPool((USHORT)Adapter->PacketContextLength,
                                                 FIELD_OFFSET(PS_SEND_PACKET_CONTEXT, FreeList),
                                                 NDIS_PACKET_POOL_TAG_FOR_PSCHED,
                                                 NULL);
    
    if(!Adapter->SendBlockPool)
    {
        PsDbgOut(DBG_CRITICAL_ERROR,
                 DBG_MINIPORT | DBG_INIT,
                 ("[MpInitialize]: Adapter %08X, Can't allocate packet pool \n",
                 Adapter));

        Status = NDIS_STATUS_RESOURCES;
        
        PsAdapterWriteEventLog(
            EVENT_PS_RESOURCE_POOL,
            0,
            &Adapter->MpDeviceName,
            0,
            NULL);
        
        goto MpInitializeError;
    }

    
    //
    // We can also get the instance name for the corresponding 
    // adapter. This is the name which WMI will be using to 
    // refer to this instance of us. 
    //

    Status = NdisMQueryAdapterInstanceName(&Adapter->WMIInstanceName, MiniportAdapterHandle);

    if(Status != NDIS_STATUS_SUCCESS)
    {
        PsDbgOut(DBG_CRITICAL_ERROR,
                 DBG_MINIPORT | DBG_INIT,
                 ("[MpInitialize]: Adapter %08X, Failed to get WMI instance name.\n",
                 Adapter,
                 Status));

        PsAdapterWriteEventLog(
            EVENT_PS_WMI_INSTANCE_NAME_FAILED,
            0,
            &Adapter->MpDeviceName,
            sizeof(Status), 
            &Status);

        goto MpInitializeError;
    }

    //
    // lookup our media type in the supplied media array
    //
    // if we're NdisMediumWan, then we have to fake out the
    // protocol and pretend that we're NdisMedium802_3, so 
    // fake it for now.
    //

    if(Adapter->MediaType == NdisMediumWan){

        FakingIt = TRUE;
        Adapter->MediaType = NdisMedium802_3;
    }

    for(--MediumArraySize ; MediumArraySize > 0;){

        if(MediumArray[ MediumArraySize ] == Adapter->MediaType){
            break;
        }

        if(MediumArraySize == 0){
            break;
        }

        --MediumArraySize;
    }

    if(MediumArraySize == 0 && MediumArray[ 0 ] != Adapter->MediaType){

        if(FakingIt)
        {
            FakingIt = FALSE;
            Adapter->MediaType = NdisMediumWan;
        }

        PsDbgOut(DBG_CRITICAL_ERROR,
                 DBG_MINIPORT | DBG_INIT,
                 ("[MpInitialize]: Adapter %08X, Unsupported Media \n",
                 Adapter));

        Status =  NDIS_STATUS_UNSUPPORTED_MEDIA;

        goto MpInitializeError;
    }

    if(FakingIt){

        FakingIt = FALSE;
        Adapter->MediaType = NdisMediumWan;
    }

    *SelectedMediumIndex = MediumArraySize;

    //
    // finish the initialization process by set our attributes
    //

    NdisMSetAttributesEx(MiniportAdapterHandle,
                         Adapter,
                         0xFFFF,
                         NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT  |
                         NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT |
                         NDIS_ATTRIBUTE_DESERIALIZE            | 
                         NDIS_ATTRIBUTE_INTERMEDIATE_DRIVER    |
                         NDIS_ATTRIBUTE_NO_HALT_ON_SUSPEND,
                         0);

    //
    // Set the default value for the device state flag as PM capable (for both miniport
    // and protocol). Device is ON by default
    //
    Adapter->MPDeviceState = NdisDeviceStateD0;
    Adapter->PTDeviceState = NdisDeviceStateD0;

    Adapter->PsNdisHandle = MiniportAdapterHandle;

    //
    // We create the b/e VC here (rather than the bind handler) because 
    // this will be called only after all scheduling components have registered.
    // 

    if(Adapter->MediaType != NdisMediumWan) {

        Status = CreateBestEffortVc(Adapter, 
                                    &Adapter->BestEffortVc, 
                                    0);
        
        if(Status != NDIS_STATUS_SUCCESS) 
        {
            PsDbgOut(DBG_CRITICAL_ERROR, DBG_MINIPORT | DBG_INIT,
                     ("[MpInitialize]: Adapter %08X, cannot create b/e VC ! \n", 
                      Adapter));
          
            goto MpInitializeError;
        }
    }

    Adapter->PsMpState = AdapterStateRunning;

    //
    // This is for mpinitialize, will be deref'd on mphalt.
    //
    REFADD(&Adapter->RefCount, 'NDHT');

    PS_LOCK(&AdapterListLock);

    if(WMIInitialized && !Adapter->IfcNotification)
    {
        //
        // WMI has been initialized correctly. i.e we can post events
        // at this point. 
        //

        Adapter->IfcNotification = TRUE;

        PS_UNLOCK(&AdapterListLock);

        TcIndicateInterfaceChange(Adapter, 0, NDIS_STATUS_INTERFACE_UP);
    }
    else 
    {
        //
        // WMI has not been initialized. Since this adapter is already on the 
        // list, the interface up event will be posted when IRP_MN_REGINFO 
        // completes.
        //
        
        PS_UNLOCK(&AdapterListLock);
    }

    NdisSetEvent(&Adapter->MpInitializeEvent);

    return NDIS_STATUS_SUCCESS;

MpInitializeError:
    Adapter->PsNdisHandle = 0;
    NdisSetEvent(&Adapter->MpInitializeEvent);
    return Status;

} // MpInitialize


PADAPTER
FindAdapterByWmiInstanceName(
    USHORT       StringLength,
    PWSTR        StringStart,
    PPS_WAN_LINK *PsWanLink
    )

/*++

Routine Description:

    Find the miniport instance that matches the instance name passed in.

Arguments:

    StringLength - Number of bytes / 2

    StringStart - pointer to a buffer containing a wide string

    PsWanLink - if this is an interface search, then the WAN link
        representing the interface will be returned in this location.
        If it is not an interface search or no matching WanLink is 
        found, NULL will be returned.

    InterfaceSearch - if TRUE, this is a search for an interface. For
        LAN adapters, an interface is equivalent to an adapter. For WAN
        adapters, interfaces are links. Otherwise, it's a search for an 
        adapter.

Return Value:

    pointer to ADAPTER struct, otherwise NULL

--*/

{
    PLIST_ENTRY NextAdapter;
    PLIST_ENTRY NextLink;
    PPS_WAN_LINK WanLink;
    PADAPTER AdapterInList;

    *PsWanLink = NULL;

    PS_LOCK(&AdapterListLock);

    NextAdapter = AdapterList.Flink;

    while(NextAdapter != &AdapterList){

        AdapterInList = CONTAINING_RECORD(NextAdapter, ADAPTER, Linkage);

        PS_LOCK_DPC(&AdapterInList->Lock);

        //
        // If it's closing, blow right by it.
        //

        if(AdapterInList->PsMpState != AdapterStateRunning)
        {
            PS_UNLOCK_DPC(&AdapterInList->Lock);

            NextAdapter = NextAdapter->Flink;

            continue;
        }

        if(AdapterInList->MediaType != NdisMediumWan)
        {

           if(StringLength == AdapterInList->WMIInstanceName.Length){
              
              //
              // At least they are of equal length.
              //

              if(NdisEqualMemory(StringStart,
                                 AdapterInList->WMIInstanceName.Buffer,
                                 StringLength)){
                 
                 REFADD(&AdapterInList->RefCount, 'ADVC');

                 PS_UNLOCK_DPC(&AdapterInList->Lock);

                 PS_UNLOCK(&AdapterListLock);

                 return(AdapterInList);
              }
           }

        }
        else 
        {

           if(AdapterInList->WanBindingState & WAN_ADDR_FAMILY_OPEN)
           {
              //
              // Wan adapters are searched by the name stored with 
              // their links.
              //
              
              NextLink = AdapterInList->WanLinkList.Flink;
              
              while(NextLink != &AdapterInList->WanLinkList){
                 
                 WanLink = CONTAINING_RECORD(NextLink, PS_WAN_LINK, Linkage);
                 
                 if(WanLink->State == WanStateOpen)
                 {
                    
                    if(StringLength == WanLink->InstanceName.Length){
                       
                       //
                       // At least they are of equal length.
                       //
                       
                       if(NdisEqualMemory(StringStart,
                                          WanLink->InstanceName.Buffer,
                                          StringLength)){
                          
                          REFADD(&AdapterInList->RefCount, 'ADVC');
                          REFADD(&WanLink->RefCount, 'WANV');
                          
                          PS_UNLOCK_DPC(&AdapterInList->Lock);
                          PS_UNLOCK(&AdapterListLock);
                          *PsWanLink = WanLink;
                          return(AdapterInList);
                       }
                    }
                 }
                 
                 NextLink = NextLink->Flink;
              }
           }
        }
              
        PS_UNLOCK_DPC(&AdapterInList->Lock);
        NextAdapter = NextAdapter->Flink;
        
    }
    
    PS_UNLOCK(&AdapterListLock);
    return NULL;

} // FindAdapterByWmiInstanceName

VOID
CleanUpAdapter(
    IN PADAPTER Adapter)
{

    NDIS_STATUS Status;

    PsAssert(KeGetCurrentIrql() < DISPATCH_LEVEL);

    TcIndicateInterfaceChange(Adapter, 0, NDIS_STATUS_INTERFACE_DOWN);

    // 
    // Close all the VCs
    //
        
    CloseAllGpcVcs(Adapter);


    // 
    // if we have opened an underlying call manager, close it now.
    //
    
    if(Adapter->MediaType == NdisMediumWan) {

        PS_LOCK(&Adapter->Lock);

        if(Adapter->ShutdownMask & SHUTDOWN_CLOSE_WAN_ADDR_FAMILY){

            Adapter->ShutdownMask &= ~SHUTDOWN_CLOSE_WAN_ADDR_FAMILY;

            PS_UNLOCK(&Adapter->Lock);
            
            PsDbgOut(DBG_TRACE, DBG_WAN | DBG_MINIPORT,
                     ("[CleanupAdapter]: Adapter %08X Closing the WAN address family", Adapter));
            
            Status = NdisClCloseAddressFamily(Adapter->WanCmHandle);
            
        }
        else
        {
            PS_UNLOCK(&Adapter->Lock);
        }
    }
}
    


VOID
ClUnbindFromLowerMp(
        OUT     PNDIS_STATUS  Status,
        IN      NDIS_HANDLE   ProtocolBindingContext,
        IN      NDIS_HANDLE   UnbindContext
        )

/*++

Routine Description:

    Called by NDIS to indicate that an adapter is going away. 
    Since this is an integrated call manager/miniport, we will
    have to close the call manager with the adapter. To do so,
    we must first ask the clients of our call manager part to 
    close us. We will have to pend until then.

    Release our reference
    on the adapter and set the closing flag to true to prevent any further
    references from being obtained.

Arguments:

    See the DDK...

Return Values:

    None

--*/

{
    PADAPTER    Adapter = (PADAPTER)ProtocolBindingContext;
    NDIS_STATUS LocalStatus;
    BOOLEAN     VirtualMp;

    PsDbgOut(DBG_INFO,
             DBG_PROTOCOL | DBG_INIT,
             ("[ClUnbindFromLowerMp]: Adapter %08X, %ws, UnbindContext %x \n",
              Adapter,
              Adapter->MpDeviceName.Buffer,
              UnbindContext));

    PsStructAssert( Adapter );
    PsAssert(!(Adapter->ShutdownMask & SHUTDOWN_UNBIND_CALLED));

    //
    // If the unbind is not happening from the context of the unload, we need to Make sure that 
    // unload waits for this unbind to complete. We do that by setting the DriverUnloadEvent.
    //

    PS_LOCK(&DriverUnloadLock);

    DRIVER_COUNTED_BLOCK;

    PS_UNLOCK(&DriverUnloadLock);

    PS_LOCK(&Adapter->Lock);

    if(Adapter->PsMpState == AdapterStateWaiting) 
    {
        VirtualMp = FALSE;
    }
    else
    {
        VirtualMp = TRUE;
    }

    Adapter->PsMpState = AdapterStateClosing;

    Adapter->ShutdownMask |= SHUTDOWN_UNBIND_CALLED;

    PsAssert(!(Adapter->ShutdownMask & SHUTDOWN_CLEANUP_ADAPTER));

    if(Adapter->PendedNdisRequest)
    {
        PNDIS_REQUEST PendedRequest = (PNDIS_REQUEST)Adapter->PendedNdisRequest;
        Adapter->PendedNdisRequest = NULL;

        ClRequestComplete(Adapter, PendedRequest, NDIS_STATUS_FAILURE);
    }
    
    Adapter->ShutdownMask |= SHUTDOWN_CLEANUP_ADAPTER;

    PS_UNLOCK(&Adapter->Lock);

    CleanUpAdapter(Adapter);
        
    //
    // DeInitialize the device instance if we have been called in the MpInitialize handler.
    //
    if(Adapter->PsNdisHandle) 
    {
        //
        // Either the mpinitialize has happened or its in progress. If it is in progress,
        // we need to Wait till it completes.
        //

        NdisWaitEvent(&Adapter->MpInitializeEvent, 0);

        //
        // The MpInitialize (that we could have been waiting for in the above step) could have failed : 
        // So we need to check this handle again.
        //

        if(Adapter->PsNdisHandle)
        {
        
            *Status = NdisIMDeInitializeDeviceInstance(Adapter->PsNdisHandle);

            PsDbgOut(DBG_INFO,
                     DBG_PROTOCOL | DBG_INIT,
                     ("[ClUnbindFromLowerMp]: Adapter %08X, deiniting device, "
                      "status %x\n", Adapter, *Status));
            goto Done;
        }
    }
    else 
    {
        if(VirtualMp)
        {
            //
            // We have never been called in MpInitialize. Try to cancel the NdisIMInitializeDeviceInstance
            // call.
            //
            
            PsDbgOut(DBG_INFO, 
                     DBG_PROTOCOL | DBG_INIT,
                     ("[ClUnbindFromLowerMp]: Adapter %08X, calling NdisIMCancelDeviceInstance with %ws \n",
                      Adapter, Adapter->UpperBinding.Buffer));
            
            *Status = NdisIMCancelInitializeDeviceInstance(LmDriverHandle, &Adapter->UpperBinding);
            
            if(*Status != NDIS_STATUS_SUCCESS)
            {
                //
                // An mpinitialize is in progress or is going to happen soon. Let's wait for it to
                // complete.
                //
                PsDbgOut(DBG_INFO, 
                         DBG_PROTOCOL | DBG_INIT,
                         ("[ClUnbindFromLowerMp]: Adapter %08X, Waiting for MpInitialize to "
                          "finish (NdisIMCancelDeviceInstance failed) \n", Adapter));
                
                NdisWaitEvent(&Adapter->MpInitializeEvent, 0);
                
                //
                // The MpInitialize (that we could have been waiting for in the above step) could have failed : 
                // So we need to check this handle again.
                //
                
                if(Adapter->PsNdisHandle)
                {
                    *Status = NdisIMDeInitializeDeviceInstance(Adapter->PsNdisHandle);
                    
                    PsDbgOut(DBG_INFO,
                             DBG_PROTOCOL | DBG_INIT,
                             ("[ClUnbindFromLowerMp]: Adapter %08X, deiniting device, "
                              "status %x\n", Adapter, *Status));
                    
                    goto Done;
                }
            }
            else
            {
                //
                // Great. We can be assured that we will never get called in the MpInitializeHandler anymore.
                // Proceed to close the binding below.
                //
            }
        }
    }

    //
    // Close the open. We have to do this only if we don't call NdisIMDeInitializeDeviceInstance. If 
    // we ever call NdisIMDeInitializeDeviceInstance, then we close the open in the MpHalt handler.
    //

    if(Adapter->LowerMpHandle) 
    {
        NdisCloseAdapter(Status, Adapter->LowerMpHandle);

        PsDbgOut(DBG_INFO,
                 DBG_PROTOCOL | DBG_INIT,
                 ("[ClUnbindFromLowerMp]: Adapter %08X, closing adapter, "
                  "status %x\n", Adapter, *Status));

        if (*Status == NDIS_STATUS_PENDING)
        {
            NdisWaitEvent(&Adapter->BlockingEvent, 0);
            NdisResetEvent(&Adapter->BlockingEvent);
        
            *Status = Adapter->FinalStatus;
        }
       
        REFDEL(&Adapter->RefCount, FALSE, 'NDOP'); 

    }
    else 
    {

        PsDbgOut(DBG_CRITICAL_ERROR,
                 DBG_PROTOCOL | DBG_INIT,
                 ("[ClUnbindFromLowerMp]: Adapter %08X, unbind cannot deinit/close adpater \n",
                  Adapter));
        
        *Status = NDIS_STATUS_FAILURE;

        PsAssert(0);

    }

Done:

    PsDbgOut(DBG_INFO,
             DBG_PROTOCOL | DBG_INIT,
             ("[ClUnbindFromLowerMp]: Exiting with Status = %08X \n", *Status));

    DRIVER_COUNTED_UNBLOCK;

} // UnbindAdapter


VOID
DeleteAdapter(
    PVOID    Handle,
    BOOLEAN  AdapterListLocked
    )

/*++

Routine Description:

    Decrement the ref counter associated with this structure. When it goes to
    zero, close the adapter, and delete the memory associated with the struct

Arguments:

    Adapter - pointer to adapter context block

Return Value:

    number of references remaining associated with this structure

--*/

{
    PADAPTER Adapter = (PADAPTER) Handle;

        Adapter->PsMpState = AdapterStateClosed;

        //
        // if we initialized the pipe, tell the scheduler that this pipe is going away
        //
        
        if ( Adapter->MediaType != NdisMediumWan && Adapter->ShutdownMask & SHUTDOWN_DELETE_PIPE ) {
            
            (*Adapter->PsComponent->DeletePipe)( Adapter->PsPipeContext );
        }
        
        if ( Adapter->ShutdownMask & SHUTDOWN_FREE_PS_CONTEXT ) {
            
            PsFreePool(Adapter->PsPipeContext);
        }

        if(Adapter->pDiffServMapping)
        {
            PsFreePool(Adapter->pDiffServMapping);
        }
        
        //
        // return packet pool resources
        //
        
        if(Adapter->SendPacketPool != 0)
        {
           NdisFreePacketPool(Adapter->SendPacketPool);
        }

        if(Adapter->RecvPacketPool != 0)
        {
           NdisFreePacketPool(Adapter->RecvPacketPool);
        }

        if(Adapter->SendBlockPool)
        {
            NdisDestroyBlockPool(Adapter->SendBlockPool);
        }

        
        //
        // free adapter lock from dispatcher DB 
        //
        
        NdisFreeSpinLock(&Adapter->Lock);
        
        //
        // Free various allocations for the adapter, then the adapter
        //
        
        if(Adapter->IpNetAddressList){
            PsFreePool(Adapter->IpNetAddressList);
        }
        
        if(Adapter->IpxNetAddressList){
            PsFreePool(Adapter->IpxNetAddressList);
        }
        
        if(Adapter->MpDeviceName.Buffer) {
            PsFreePool(Adapter->MpDeviceName.Buffer);
        }
        
        if(Adapter->UpperBinding.Buffer) {
            PsFreePool(Adapter->UpperBinding.Buffer);
        }
        
        if(Adapter->RegistryPath.Buffer) {
            PsFreePool(Adapter->RegistryPath.Buffer);
        }
        
        if(Adapter->WMIInstanceName.Buffer) {
            
            //
            // We should not call PsFreePool since this memory is allocated by NDIS
            //
            
            ExFreePool(Adapter->WMIInstanceName.Buffer);
        }

        if(Adapter->ProfileName.Buffer) {
            PsFreePool(Adapter->ProfileName.Buffer);
        }
       
        if(!AdapterListLocked) 
        {
            PS_LOCK(&AdapterListLock);

            RemoveEntryList(&Adapter->Linkage);

            PS_UNLOCK(&AdapterListLock);
        }
        else 
        {
            RemoveEntryList(&Adapter->Linkage);
        }

        NdisSetEvent(&Adapter->RefEvent);

        PsFreePool(Adapter);
        

} 


VOID
ClLowerMpCloseAdapterComplete(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS Status
    )

/*++

Routine Description:

    Completion routine for NdisCloseAdapter. All that should be left is to free
    the pool associated with the structure

Arguments:

    See the DDK...

Return Values:

    None

--*/

{
    PADAPTER Adapter = (PADAPTER)ProtocolBindingContext;

    PsDbgOut(DBG_TRACE, 
             DBG_PROTOCOL, 
             ("[ClLowerMpCloseAdapterComplete]: Adapter %08X \n", Adapter));

    PsStructAssert( Adapter );

    PsAssert(Status == NDIS_STATUS_SUCCESS);

    Adapter->FinalStatus = Status;

    Adapter->LowerMpHandle = 0;

    //
    // Clean up WanLinks. This cannot be done (in CleanUpAdapter) before we call NdisCloseAdapter, because
    // NDIS can unbind us in the middle of an ClStatusIndication, and can cause a race condition. Also, we 
    // can all PsDeleteDevice only after this (because we might want to send some status indications.
    //
        
    AskWanLinksToClose(Adapter);

    PsDeleteDevice();

    NdisSetEvent(&Adapter->BlockingEvent);

} // LowerMpCloseAdapterComplete


VOID
ClUnloadProtocol(
    VOID
    )

/*++

Routine Description:

Arguments:

    None

Return Value:

    None

--*/

{

}


VOID
MpHalt(
        IN      NDIS_HANDLE                             MiniportAdapterContext
        )

/*++

Routine Description:

    This handler is called on Memphis. It indicates that the PS MP is no more
    and we should avoid calling NdisIMDeInitializeDeviceInstance...

Arguments:

    See the DDK...

Return Values:

    None

--*/

{
    PADAPTER Adapter = (PADAPTER)MiniportAdapterContext;
    ULONG Status;

    PsDbgOut(DBG_TRACE, DBG_MINIPORT, ("[MpHalt]: Adapter %08X\n", Adapter));

    PsStructAssert(Adapter);

    PsAssert(!(Adapter->ShutdownMask & SHUTDOWN_MPHALT_CALLED));
    PsAssert(!(Adapter->ShutdownMask & SHUTDOWN_PROTOCOL_UNLOAD));

    PS_LOCK(&Adapter->Lock);

    //
    // If we ever get called in our unbind handler, we should not call
    // NdisImDeInitializeDeviceInstance.
    //

    Adapter->ShutdownMask |= SHUTDOWN_MPHALT_CALLED;

    Adapter->PsMpState = AdapterStateClosing;

    if(!(Adapter->ShutdownMask & SHUTDOWN_CLEANUP_ADAPTER))
    {
        Adapter->ShutdownMask |= SHUTDOWN_CLEANUP_ADAPTER;

        PS_UNLOCK(&Adapter->Lock);

        CleanUpAdapter(Adapter);
    }
    else 
    {
        PS_UNLOCK(&Adapter->Lock);
    }

    //
    // Close the b/e VC in the mphalt call. This prevents us from taking a lock 
    // in the send path. We are assured that we will not get any sends after we
    // get called in the mphalt handler.
    //

    if(Adapter->MediaType != NdisMediumWan)
    {
        PS_LOCK(&Adapter->Lock);

        PS_LOCK_DPC(&Adapter->BestEffortVc.Lock);
    
        InternalCloseCall(&Adapter->BestEffortVc);
    }

    if(Adapter->LowerMpHandle) {

        NdisCloseAdapter(&Status, Adapter->LowerMpHandle);

        if(Status == NDIS_STATUS_PENDING) {
            
            NdisWaitEvent(&Adapter->BlockingEvent, 0);
            NdisResetEvent(&Adapter->BlockingEvent);

            Status = Adapter->FinalStatus;
        }

        REFDEL(&Adapter->RefCount, FALSE, 'NDOP');
    }

    //
    // Deref for the MpInitialize
    //
    REFDEL(&Adapter->RefCount, FALSE, 'NDHT');

}

NDIS_STATUS
MpReset(
        OUT PBOOLEAN     AddressingReset,
        IN  NDIS_HANDLE  MiniportAdapterContext
        )

/*++

Routine Description:



Arguments:

    See the DDK...

Return Values:

    None

--*/

{
    PADAPTER Adapter = (PADAPTER)MiniportAdapterContext;

    PsStructAssert( Adapter );

    PsDbgOut(DBG_TRACE, DBG_MINIPORT, ("[MpReset]: Adapter %08X\n", Adapter));

    *AddressingReset = FALSE;

    return NDIS_STATUS_SUCCESS;
}

HANDLE
GetNdisPipeHandle (
    IN HANDLE PsPipeContext
    )

/*++

Routine Description:

    Return the NDIS handle for the adapter to the requesting scheduling component.

Arguments:

    PsPipeContext - Pipe context

Return Values:

    Adapter NDIS handle.

--*/

{
    return ((PADAPTER)PsPipeContext)->PsNdisHandle;
} // GetNdisPipeHandle




STATIC NDIS_STATUS
FindProfile(
    PNDIS_STRING ProfileName,
    PPS_PROFILE  *Profile
    )

/*++
  Routine Description:

      Find the named profile in the list of profiles

  Arguments

      ProfileName - Name of the profile to look for.

  Return Value:
    NDIS_STATUS_SUCCESS if everything worked ok

e--*/
{
    NDIS_STATUS Status;
    PLIST_ENTRY NextComponent;
    PPS_PROFILE PsiInfo;

    //
    // compare names until we find the right one
    //

    NextComponent = PsProfileList.Flink;
    while ( NextComponent != &PsProfileList ) {

        PsiInfo = CONTAINING_RECORD( NextComponent, PS_PROFILE, Links );

        if ( ProfileName->Length == PsiInfo->ProfileName.Length ) {

            if ( NdisEqualMemory(
                    ProfileName->Buffer,
                    PsiInfo->ProfileName.Buffer,
                    ProfileName->Length )) {

                break;
            }
        }

        NextComponent = NextComponent->Flink;
    }


    if ( NextComponent != &PsProfileList ) {

        *Profile = PsiInfo;
        Status = NDIS_STATUS_SUCCESS;
    } else {

        Status = NDIS_STATUS_FAILURE;
    }

    return Status;
} // FindProfile



NDIS_STATUS
InitializeAdapter(
    PADAPTER Adapter, 
    PVOID BindContext, 
    PNDIS_STRING MpDeviceName, 
    PVOID SystemSpecific1)
{
    NDIS_STATUS LocalStatus;
    PNDIS_STRING PsParamsKey = (PNDIS_STRING) SystemSpecific1;

    NdisZeroMemory(Adapter, sizeof(ADAPTER));

    PS_INIT_SPIN_LOCK(&Adapter->Lock);
    REFINIT(&Adapter->RefCount, Adapter, DeleteAdapter);
    REFADD(&Adapter->RefCount, 'NDOP');
    Adapter->PsMpState            = AdapterStateInitializing;
    Adapter->BindContext          = BindContext;
    Adapter->ShutdownMask         = 0;

    NdisInitializeEvent(&Adapter->BlockingEvent);
    NdisResetEvent(&Adapter->BlockingEvent);

    NdisInitializeEvent(&Adapter->RefEvent);
    NdisResetEvent(&Adapter->RefEvent);

    NdisInitializeEvent(&Adapter->LocalRequestEvent);
    NdisResetEvent(&Adapter->LocalRequestEvent);

    NdisInitializeEvent(&Adapter->MpInitializeEvent);
    NdisResetEvent(&Adapter->MpInitializeEvent);

    //
    // Initialize the Lists that we are maintaining
    //

    InitializeListHead(&Adapter->WanLinkList);
    InitializeListHead(&Adapter->GpcClientVcList);


    //
    // By default, Adapter comes in RSVP mode
    //
    Adapter->AdapterMode = AdapterModeRsvpFlow;

    //
    // add adapter on list of known adapters
    //

    NdisInterlockedInsertTailList(&AdapterList, 
                                  &Adapter->Linkage, 
                                  &AdapterListLock.Lock );

    PsAddDevice();

    //
    // We maintain a list of network addresses enabled on
    // each adapter, for IP and for IPX, separately.
    //

    PsAllocatePool(Adapter->IpNetAddressList,
                   sizeof(NETWORK_ADDRESS_LIST),
                   PsMiscTag);

    if(!Adapter->IpNetAddressList) 
    {
        goto ERROR_RESOURCES;
    }

    Adapter->IpNetAddressList->AddressCount = 0;

    PsAllocatePool(Adapter->IpxNetAddressList,
                   sizeof(NETWORK_ADDRESS_LIST),
                   PsMiscTag);

    if(!Adapter->IpxNetAddressList)
    {
        goto ERROR_RESOURCES;
    }

    Adapter->IpxNetAddressList->AddressCount = 0;


    //
    // Allocate a buffer to hold the name of the underlying 
    // adpater. 
    //

    Adapter->MpDeviceName.Length        = MpDeviceName->Length;
    Adapter->MpDeviceName.MaximumLength = MpDeviceName->MaximumLength;

    PsAllocatePool(Adapter->MpDeviceName.Buffer,
                   MpDeviceName->MaximumLength,
                   PsMiscTag);

    if(Adapter->MpDeviceName.Buffer == NULL) 
    {
        goto ERROR_RESOURCES;
    }
    else
    {

        NdisZeroMemory(
            Adapter->MpDeviceName.Buffer,
            Adapter->MpDeviceName.MaximumLength);

        NdisMoveMemory(
            Adapter->MpDeviceName.Buffer,
            MpDeviceName->Buffer,
            MpDeviceName->Length);
    }

    //
    // Allocate a buffer to hold PsParams Key. This will be
    // used by the adapter to read external scheduling component
    // specific interface parameters when they register.
    //

    Adapter->RegistryPath.Length = PsParamsKey->Length;
    Adapter->RegistryPath.MaximumLength = PsParamsKey->MaximumLength;

    PsAllocatePool(Adapter->RegistryPath.Buffer,
                   Adapter->RegistryPath.MaximumLength,
                   PsMiscTag);

    if(Adapter->RegistryPath.Buffer == NULL)
    {
        goto ERROR_RESOURCES;
    }
    else
    {
        NdisMoveMemory(
            Adapter->RegistryPath.Buffer,
            PsParamsKey->Buffer,
            PsParamsKey->MaximumLength);
    }

    //
    // Read the per adapter registry info
    //

    LocalStatus = PsReadAdapterRegistryDataInit(Adapter,
                                                (PNDIS_STRING)SystemSpecific1);

    LocalStatus = PsReadAdapterRegistryData(Adapter,
                                            &MachineRegistryKey,
                                            (PNDIS_STRING)SystemSpecific1);

    if(LocalStatus != NDIS_STATUS_SUCCESS)
    {
        PsDbgOut(DBG_FAILURE, 
                 DBG_PROTOCOL | DBG_INIT,
                 ("[InitializeAdapter]: Couldn't get registry data %ws (Status = %08X) \n",
                  MpDeviceName->Buffer, LocalStatus));
    }

    return LocalStatus;

ERROR_RESOURCES:
    PsAdapterWriteEventLog(
        (ULONG)EVENT_PS_RESOURCE_POOL,
        0,
        MpDeviceName,
        0,
        NULL);

    return NDIS_STATUS_RESOURCES;
}


NDIS_STATUS
RegisterPsComponent(
    PPSI_INFO PsiComponentInfo,
    ULONG Size,
    PPS_DEBUG_INFO DebugInfo
    )

/*++

Routine Description:

    Called by an external scheduling component to register itself with the PS.
    This function is exported by the PS driver.  At present, all scheduling
    components are internal to the PS, so this entry is not used.

Arguments:

    PsiComponentInfo - pointer to component info

Return Value:

    STATUS_SUCCESS if everything worked ok

--*/

{
    PPSI_INFO comp;
    PLIST_ENTRY NextComponent;
    PPS_PROFILE PsiInfo;
    UINT i;
    PLIST_ENTRY NextAdapter;
    PADAPTER AdapterInList;
    NDIS_STATUS Status;

    //
    // sanitize it somewhat
    //
    if ( Size != sizeof( PSI_INFO )) 
    {
        PsDbgOut(DBG_FAILURE, DBG_PROTOCOL,
                 ("[RegisterPsComponent]: Size mismatch \n"));
        return NDIS_STATUS_FAILURE;
    }

    if(PsiComponentInfo->Version != PS_COMPONENT_CURRENT_VERSION)
    {
        return NDIS_STATUS_FAILURE;
    }   

    if(FindSchedulingComponent(&PsiComponentInfo->ComponentName, &comp) ==
       NDIS_STATUS_FAILURE)
    {
        //
        // This component was not a part of any profile in the registry
        // and hence is likely to be unused. 
        //
        PsDbgOut(DBG_FAILURE, DBG_PROTOCOL,
                 ("[RegisterPsComponent]: Add-in component %ws is not "
                  " a part of any profile \n",
                  PsiComponentInfo->ComponentName.Buffer));
        return NDIS_STATUS_FAILURE;
    }
  

    // Component has registered. See if it requires DEBUG_INFO
    //

    if(DebugInfo)
    {
#if DBG
        DebugInfo->DebugLevel = &DbgTraceLevel;
        DebugInfo->DebugMask  = &DbgTraceMask;
        DebugInfo->LogId      = LogId ++;
        DebugInfo->LogTraceLevel = &LogTraceLevel;
        DebugInfo->LogTraceMask = &LogTraceMask;
        DebugInfo->GetCurrentTime = PsGetCurrentTime;
        DebugInfo->LogString = DbugSchedString;
        DebugInfo->LogSched = DbugSched;
        DebugInfo->LogRec = DbugComponentSpecificRec;
#else
        DebugInfo->DebugLevel = 0;
        DebugInfo->LogId = 0;
        DebugInfo->DebugMask  = 0;
        DebugInfo->LogTraceLevel = 0;
        DebugInfo->LogTraceMask = 0;
        DebugInfo->GetCurrentTime = 0;
        DebugInfo->LogString = 0;
        DebugInfo->LogSched = 0;
        DebugInfo->LogRec = 0;
#endif
    }
    //
    // We need to lock the component as we could get two "RegisterPsComponent"
    // calls for the same component. We don't really need a component level 
    // lock as we can do with PsComponentListLock & this is not a performance
    // critical piece.
    //
    PS_LOCK(&PsComponentListLock);
    if(comp->AddIn == FALSE) 
    {
        //
        // Registering a system component! Bail out
        //
        PS_UNLOCK(&PsComponentListLock);
        PsDbgOut(DBG_FAILURE, DBG_PROTOCOL,
                 ("[RegisterPsComponent]: %ws is already a system"
                  " component \n",
                  PsiComponentInfo->ComponentName.Buffer));
        
        return  NDIS_STATUS_FAILURE;
    }
    
    if(comp->Registered == TRUE)
    {
        //
        // Re-registering a component. 
        //
        PS_UNLOCK(&PsComponentListLock);
        PsDbgOut(DBG_FAILURE, DBG_PROTOCOL,
                 ("[RegisterPsComponent]: %ws already registered\n",
                  PsiComponentInfo->ComponentName.Buffer));
        
        return NDIS_STATUS_FAILURE;
    }
    
    //
    // Update this component in the list.
    //
    //
    // make sure the packet reserved area is sane so our context struct 
    // is aligned
    //
    if ( PsiComponentInfo->PacketReservedLength & 3 ) {
        
        PsiComponentInfo->PacketReservedLength =
            ( PsiComponentInfo->PacketReservedLength & ~3 ) + 4;
    }

    // 
    // Update the component in the list
    //
    comp->PacketReservedLength = PsiComponentInfo->PacketReservedLength;
    comp->PipeContextLength = PsiComponentInfo->PipeContextLength;
    comp->FlowContextLength = PsiComponentInfo->FlowContextLength;
    comp->ClassMapContextLength = PsiComponentInfo->ClassMapContextLength;
    comp->SupportedOidsLength = PsiComponentInfo->SupportedOidsLength;
    comp->SupportedOidList = PsiComponentInfo->SupportedOidList;
    comp->SupportedGuidsLength = PsiComponentInfo->SupportedGuidsLength;
    comp->SupportedGuidList = PsiComponentInfo->SupportedGuidList;
    comp->InitializePipe = PsiComponentInfo->InitializePipe;
    comp->ModifyPipe = PsiComponentInfo->ModifyPipe;
    comp->DeletePipe = PsiComponentInfo->DeletePipe;
    comp->CreateFlow = PsiComponentInfo->CreateFlow;
    comp->ModifyFlow = PsiComponentInfo->ModifyFlow;
    comp->DeleteFlow = PsiComponentInfo->DeleteFlow;
    comp->EmptyFlow = PsiComponentInfo->EmptyFlow;
    comp->SubmitPacket = PsiComponentInfo->SubmitPacket;
    comp->SetInformation = PsiComponentInfo->SetInformation;
    comp->QueryInformation = PsiComponentInfo->QueryInformation;
    comp->CreateClassMap = PsiComponentInfo->CreateClassMap;
    comp->DeleteClassMap = PsiComponentInfo->DeleteClassMap;

    //
    // Right now, only one component uses this...
    // This hack is being made for characterization work
    //
    if (PsiComponentInfo->ReceivePacket) {
        
        TimeStmpRecvPacket      = PsiComponentInfo->ReceivePacket;

    }

    if (PsiComponentInfo->ReceiveIndication) {
        
        TimeStmpRecvIndication  = PsiComponentInfo->ReceiveIndication;

    }

    PS_UNLOCK(&PsComponentListLock);

    PsDbgOut(DBG_TRACE, DBG_PROTOCOL,
             ("[RegisterPsComponent]: Component %ws has "
              "registered \n", 
              PsiComponentInfo->ComponentName.Buffer));
   
    //
    // Update the ProfileList
    //
    NextComponent = PsProfileList.Flink;
    while ( NextComponent != &PsProfileList ) 
    {
        PsiInfo = CONTAINING_RECORD( NextComponent, PS_PROFILE, Links );
        // 
        // We have to worry only about those profiles
        // that have unregistered components.
        //
        PS_LOCK(&PsProfileLock);
        if(PsiInfo->UnregisteredAddInCnt != 0)
        {
            for(i=0; i<PsiInfo->ComponentCnt; i++)
            {
                if(PsiInfo->ComponentList[i] == comp)
                {
                    PsiInfo->UnregisteredAddInCnt --;
                    break;
                }
            }
        }    
        PS_UNLOCK( &PsProfileLock );
        NextComponent = NextComponent->Flink;
    }

    // Need to walk the adapter list & see if we can 
    // service the waiting adapters.
    PS_LOCK(&AdapterListLock);

    NextAdapter = AdapterList.Flink;
    while(NextAdapter != &AdapterList)
    {

        AdapterInList = CONTAINING_RECORD(NextAdapter, ADAPTER, Linkage);

        PS_LOCK(&AdapterInList->Lock);

        //
        // If it's not waiting, we don't care
        //
        if(AdapterInList->PsMpState != AdapterStateWaiting ){

            PS_UNLOCK(&AdapterInList->Lock);
            NextAdapter = NextAdapter->Flink;
            continue;
        }

        //
        // If it is waiting, we can try to build the scheduling pipe.
        //
        PS_UNLOCK(&AdapterInList->Lock);
        PS_UNLOCK(&AdapterListLock);

        Status = UpdateAdapterBandwidthParameters(AdapterInList);

        if(Status == NDIS_STATUS_ADAPTER_NOT_READY)
        {
            PsDbgOut(DBG_TRACE, DBG_PROTOCOL,
                     ("[RegisterPsComponent]: Adapter %08X, Waiting for add-in components to register \n", 
                      AdapterInList));
        }
        else 
        {
            if(Status == NDIS_STATUS_SUCCESS)
            {
                PsDbgOut(DBG_TRACE, DBG_PROTOCOL,
                         ("[RegisterPsComponent]: Adapter %08X, all add-in components have registered \n", 
                          AdapterInList));

                PsInitializeDeviceInstance(AdapterInList);
            }
            else 
            {
                PsDbgOut(DBG_CRITICAL_ERROR, DBG_PROTOCOL,
                         ("[RegisterPsComponent]: Adapter %08X, Failed to update scheduling pipe, Status %08X\n",
                          AdapterInList, Status));

            }
        }
                

        PS_LOCK(&AdapterListLock);
        NextAdapter = NextAdapter->Flink;
    }
    PS_UNLOCK(&AdapterListLock);
    return NDIS_STATUS_SUCCESS;

} // RegisterPsComponent


NDIS_STATUS
FindSchedulingComponent(
    PNDIS_STRING ComponentName,
    PPSI_INFO *Component
    )

/*++

Routine Description:

    Find the named component in the list of external scheduling components

Arguments:

    ComponentName - name of component to look for

Return Value:

    NDIS_STATUS_SUCCESS if everything worked ok

--*/

{
    NDIS_STATUS Status;
    PLIST_ENTRY NextComponent;
    PPSI_INFO PsiInfo;

    //
    // get the list lock and compare names until we find the right one
    //

    PS_LOCK( &PsComponentListLock );

    NextComponent = PsComponentList.Flink;
    while ( NextComponent != &PsComponentList ) {

        PsiInfo = CONTAINING_RECORD( NextComponent, PSI_INFO, Links );

        if ( ComponentName->Length == PsiInfo->ComponentName.Length ) {

            if ( NdisEqualMemory(
                    ComponentName->Buffer,
                    PsiInfo->ComponentName.Buffer,
                    ComponentName->Length )) {

                break;
            }
        }

        NextComponent = NextComponent->Flink;
    }

    PS_UNLOCK( &PsComponentListLock );

    if ( NextComponent != &PsComponentList ) {

        *Component = PsiInfo;
        Status = NDIS_STATUS_SUCCESS;
    } else {

        Status = NDIS_STATUS_FAILURE;
    }

    return Status;
} // FindSchedulingComponent

VOID
CloseAllGpcVcs(
    PADAPTER Adapter
    )

/*++

Routine Description:

    Close all the VCs associated with an adapter

Return Value:

    None

--*/

{
    PGPC_CLIENT_VC Vc;
    PLIST_ENTRY    NextVc;


    //
    // Close all the GPC client VCs.
    //
    PS_LOCK(&Adapter->Lock);

    NextVc = Adapter->GpcClientVcList.Flink;

    while(NextVc != &Adapter->GpcClientVcList)
    {
        Vc = CONTAINING_RECORD(NextVc, GPC_CLIENT_VC, Linkage);

        PsAssert(Vc);

        PS_LOCK_DPC(&Vc->Lock);

        if(Vc->ClVcState == CL_INTERNAL_CLOSE_PENDING || Vc->Flags & INTERNAL_CLOSE_REQUESTED)
        {
            PS_UNLOCK_DPC(&Vc->Lock);

            NextVc = NextVc->Flink;
        }
        else
        {
            InternalCloseCall(Vc);

            PS_LOCK(&Adapter->Lock);

            //
            // Sigh. We can't really get hold to the NextVc in a reliable manner. When we call 
            // InternalCloseCall on the Vc, it releases the Adapter Lock (since it might have to
            // make calls into NDIS). Now, in this window, the next Vc could go away, and we 
            // could point to a stale Vc. So, we start at the head of the list. 
            // Note that this can never lead to a infinite loop, since we don't process the 
            // internal close'd VCs repeatedly.
            //

            NextVc = Adapter->GpcClientVcList.Flink;

        }

    }    

    PS_UNLOCK(&Adapter->Lock);

} // CloseAllGpcVcs

VOID
PsAdapterWriteEventLog(
    IN  NDIS_STATUS  EventCode,
    IN  ULONG        UniqueEventValue,
    IN  PNDIS_STRING DeviceName,
    IN  ULONG        DataSize,
    IN  PVOID        Data       OPTIONAL
    )

{

    //
    // The String List is the device name, and it has a \Device against it.
    //
    PWCHAR StringList[1];
    NDIS_STRING Prefix = NDIS_STRING_CONST("\\Device\\");

    if(DeviceName->Length > Prefix.Length)
    {
        StringList[0] = (PWCHAR) ((PUCHAR) DeviceName->Buffer + Prefix.Length);

        NdisWriteEventLogEntry(PsDriverObject,
                               EventCode,
                               UniqueEventValue,
                               1,
                               &StringList,
                               DataSize,
                               Data);
    }
}

/* end adapter.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\cmvc.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    cmvc.c

Abstract:

Author:
    Charlie Wickham (charlwi)  13-Sep-1996.
    Rajesh Sundaram (rajeshsu) 01-Aug-1998.

Environment:

    Kernel Mode

Revision History:

--*/

#include "psched.h"
#pragma hdrstop

/* External */

/* Static */

/* Forward */

NDIS_STATUS
RemoveDiffservMapping(
    PGPC_CLIENT_VC Vc
);

NDIS_STATUS
ProcessDiffservFlow(
    PGPC_CLIENT_VC Vc,
    PCO_CALL_MANAGER_PARAMETERS CallParameters);

NDIS_STATUS
ValidateCallParameters(
    PGPC_CLIENT_VC              Vc,
    PCO_CALL_MANAGER_PARAMETERS CallParameters
    );

NDIS_STATUS
AcquireFlowResources(
    PGPC_CLIENT_VC              Vc,
    PCO_CALL_MANAGER_PARAMETERS NewCallParams,
    PCO_CALL_MANAGER_PARAMETERS OldCallParams,
    PULONG                      RemainingBandWidthChanged
    );

VOID
ReturnFlowResources(
    PGPC_CLIENT_VC Vc,
    PULONG         RemainingBandWidthChanged
    );

VOID
CancelAcquiredFlowResources(
    PGPC_CLIENT_VC Vc
    );

/* End Forward */

NDIS_STATUS
CmCreateVc(PGPC_CLIENT_VC      *GpcClientVc, 
           PADAPTER             Adapter,
           PPS_WAN_LINK         WanLink,
           PCO_CALL_PARAMETERS  CallParams, 
           GPC_HANDLE           GpcCfInfoHandle, 
           PCF_INFO_QOS         CfInfoPtr,
           GPC_CLIENT_HANDLE    ClientContext)
{

    PGPC_CLIENT_VC Vc;

    *GpcClientVc = NULL;

    PsAllocFromLL(&Vc, &GpcClientVcLL, GpcClientVc);

    if(Vc == NULL)
    {
        return NDIS_STATUS_RESOURCES;
    }

    InitGpcClientVc(Vc, 0, Adapter);
    SetLLTag(Vc, GpcClientVc);

    //
    // Allocate space for the instance name for the Vc. 
    //
    PsAllocatePool(Vc->InstanceName.Buffer,
                   Adapter->WMIInstanceName.Length + VcPrefix.Length + INSTANCE_ID_SIZE,
                   PsMiscTag);

    if(!Vc->InstanceName.Buffer)
    {
        PsFreeToLL(Vc, &GpcClientVcLL, GpcClientVc);
        return NDIS_STATUS_RESOURCES;
    }

    Vc->CfInfoHandle   = GpcCfInfoHandle;
    Vc->CfType         = ClientContext;
    Vc->CfInfoQoS      = CfInfoPtr;
    Vc->CallParameters = CallParams;

    PS_LOCK(&Adapter->Lock);

    if(Adapter->PsMpState == AdapterStateRunning)
    {
        //
        // Insert the Vc in the adapter list
        //
        InsertHeadList(&Adapter->GpcClientVcList, &Vc->Linkage);
        PS_UNLOCK(&Adapter->Lock);
    }
    else 
    {
        PsFreePool(Vc->InstanceName.Buffer);
        PsFreeToLL(Vc, &GpcClientVcLL, GpcClientVc);
        PS_UNLOCK(&Adapter->Lock);
        return GPC_STATUS_NOTREADY;
    }


    if(WanLink) {

        Vc->Flags |= GPC_WANLINK_VC;

        // 
        // We need to link the VC to the WanLink. This has to be done because
        // we have to clean up when we get a NDIS_STATUS_WAN_LINE_DOWN
        //

        Vc->AdapterStats = &WanLink->Stats;
        Vc->WanLink = WanLink;
        Vc->PsPipeContext = WanLink->PsPipeContext;
        Vc->PsComponent   = WanLink->PsComponent;
    }
    else 
    {

        Vc->AdapterStats  = &Adapter->Stats;
        Vc->PsPipeContext = Adapter->PsPipeContext;
        Vc->PsComponent   = Adapter->PsComponent;
    }

    *GpcClientVc = Vc;

    return NDIS_STATUS_SUCCESS;

} // CmCreateVc




BOOLEAN
IsIsslowFlow(
    IN PGPC_CLIENT_VC Vc,
    IN PCO_CALL_PARAMETERS CallParameters
    )
{
    LONG                        ParamsLength;
    LPQOS_OBJECT_HDR            QoSObject;
    PADAPTER                    Adapter = Vc->Adapter;
    PCO_MEDIA_PARAMETERS        CallMgrParams = CallParameters->MediaParameters;
    ULONGLONG                   i,j,k;

    ParamsLength = (LONG)CallMgrParams->MediaSpecific.Length;
    QoSObject = (LPQOS_OBJECT_HDR)CallMgrParams->MediaSpecific.Parameters;

    while(ParamsLength > 0)
    {
        if(QoSObject->ObjectType == QOS_OBJECT_WAN_MEDIA)
        {
            if((Vc->WanLink->LinkSpeed <= Adapter->ISSLOWLinkSpeed) && 
                (CallParameters->CallMgrParameters->Transmit.ServiceType != SERVICETYPE_BESTEFFORT))
            {
                i = (ULONG) Adapter->ISSLOWTokenRate * (ULONG) CallParameters->CallMgrParameters->Transmit.MaxSduSize;
                j = (ULONG) Adapter->ISSLOWPacketSize * (ULONG) CallParameters->CallMgrParameters->Transmit.TokenRate;
                k = (ULONG) Adapter->ISSLOWTokenRate * (ULONG)Adapter->ISSLOWPacketSize;

                if((i+j)<k)
                    return TRUE;
            }

            return FALSE;
        }
        else 
        {
            if( ((LONG)QoSObject->ObjectLength <= 0) ||
                ((LONG)QoSObject->ObjectLength > ParamsLength) )
            {

                return(FALSE);
            }

            ParamsLength -= QoSObject->ObjectLength;
            QoSObject = (LPQOS_OBJECT_HDR)((UINT_PTR)QoSObject + QoSObject->ObjectLength);
        }
    }

    return FALSE;
}






NDIS_STATUS
CmMakeCall(
    IN PGPC_CLIENT_VC Vc
)
{
    ULONG                       CmParamsLength;
    NDIS_STATUS                 Status;
    ULONG                       RemainingBandWidthChanged;
    PADAPTER                    Adapter = Vc->Adapter;
    PCO_CALL_PARAMETERS         CallParameters   = Vc->CallParameters;

    //
    // Validate parameters
    //

    Status = ValidateCallParameters(Vc, CallParameters->CallMgrParameters);

    if(Status != NDIS_STATUS_SUCCESS)
    {
        PsDbgOut(DBG_INFO, 
                 DBG_VC, 
                 ("[CmMakeCall]: Vc %08X, invalid QoS parameters\n", 
                 Vc));

        return Status;
    }

    //
    // make sure we can admit the flow onto our adapter. if this 
    // succeeds, the resources are committed and we'll have to call
    // CancelAcquiredFlowResources to return them.
    //

    Status = AcquireFlowResources(Vc, 
                                  CallParameters->CallMgrParameters, 
                                  NULL,
                                  &RemainingBandWidthChanged);

    if(Status != NDIS_STATUS_SUCCESS)
    {
        PsDbgOut(DBG_INFO, 
                 DBG_VC, 
                 ("[CmMakeCall]: Vc %08X, no flow resc\n", 
                 Vc));

        return Status;
    }

    //
    // In the integrated call manager/miniport model, the activation 
    // is internal. Activating the Vc consists of adding the flow to the 
    // scheduler. If it succeeds, we will later call NdisMCmActivateVc,    
    // just as a courtesy, to notify NDIS.
    //

    if( Adapter->MediaType == NdisMediumWan     && 
        !IsBestEffortVc(Vc)                     &&
        IsIsslowFlow( Vc, CallParameters ) )
    {
        //  Need to do this before we add a flow to the sched components.
        Vc->Flags |= GPC_ISSLOW_FLOW;
    }        


    Status = AddFlowToScheduler(NEW_VC, Vc, CallParameters, 0);

    //  Let's revert it back, to avoid any side effects..
    Vc->Flags = Vc->Flags & ~GPC_ISSLOW_FLOW;
    

    if(Status != NDIS_STATUS_SUCCESS)
    {

        PsDbgOut(DBG_FAILURE,
                 DBG_VC,
                 ("[CmMakeCall]: Vc %08X, AddFlowToScheduler failed %08X\n",
                  Vc,
                  Status));

        CancelAcquiredFlowResources(Vc);

        return(Status);
    }

    //
    //  A flow has been added to psched after this point. So, whenever the Vc goes away, Psched's flow 
    //  has to be removed from an explicit call.
    //

    Vc->bRemoveFlow = TRUE;


    // 
    // If there is an NDIS 5.0, connection oriented driver below us, then
    // we need to call it, with the call parameters, to complete the VC
    // setup. 
    //

    if(Adapter->MediaType == NdisMediumWan &&
       !IsBestEffortVc(Vc))
    {
        Status = WanMakeCall(Vc, CallParameters);

        PsAssert(Status == NDIS_STATUS_PENDING);

        return Status;
    }
    else 
    {
        // 
        // if we made it this far, the MakeCall succeeded!
        //
        Status = ProcessDiffservFlow(Vc, CallParameters->CallMgrParameters);

        if(Status != NDIS_STATUS_SUCCESS) 
        {
            
            PsDbgOut(DBG_FAILURE,
                     DBG_VC,
                     ("[CmMakeCall]: Vc %08X, AddDiffservMapping failed %08X\n", Vc, Status));

            CancelAcquiredFlowResources(Vc);

            return Status;
        }

        if(TRUE == RemainingBandWidthChanged) 
        {
            LONG RemainingBandWidth;

            PS_LOCK(&Adapter->Lock);
                
            RemainingBandWidth = (LONG) Adapter->RemainingBandWidth;
                
            PS_UNLOCK(&Adapter->Lock);
            
            PsTcNotify(Adapter, 0, OID_QOS_REMAINING_BANDWIDTH, &RemainingBandWidth, sizeof(LONG));
        }

        Vc->TokenRateChange = 0;

        return NDIS_STATUS_SUCCESS;
    }
}

VOID
CompleteMakeCall(
    PGPC_CLIENT_VC Vc,
    PCO_CALL_PARAMETERS CallParameters,
    NDIS_STATUS Status
    )
{
    PADAPTER             Adapter  = Vc->Adapter;

    PsAssert(Adapter->MediaType == NdisMediumWan);

    PsAssert(!IsBestEffortVc(Vc));

    if(Status != NDIS_STATUS_SUCCESS) 
    {
        CancelAcquiredFlowResources(Vc);

    }
    else 
    {
        Status = ProcessDiffservFlow(Vc, CallParameters->CallMgrParameters);
        
        if(Status != NDIS_STATUS_SUCCESS) 
        {
            PsDbgOut(DBG_FAILURE,
                     DBG_VC,
                     ("[CompleteMakeCall]: Vc %08X, AddDiffservMapping failed %08X\n", Vc, Status));

            CancelAcquiredFlowResources(Vc);
        }
    }

    Vc->TokenRateChange = 0;

    CmMakeCallComplete(Status, Vc, CallParameters);
}


NDIS_STATUS
CmModifyCall(
    IN  PGPC_CLIENT_VC Vc
    )

/*++

Routine Description:

    Modify the QoS of an existing flow based on the supplied call params.
    First see if the request can be handled locally.

Arguments:

    See the DDK...

Return Values:

    NDIS_STATUS_SUCCESS if everything worked ok.

--*/

{
    NDIS_STATUS         Status;
    ULONG               CmParamsLength;
    PCO_CALL_PARAMETERS CallParameters;
    PADAPTER            Adapter;
    ULONG               RemainingBandWidthChanged;

    Adapter = Vc->Adapter;
    PsStructAssert(Adapter);

    PsAssert(Vc->TokenRateChange == 0);

    //
    // Validate parameters
    //

    CallParameters = Vc->ModifyCallParameters;
    Status = ValidateCallParameters(Vc, CallParameters->CallMgrParameters);

    if(Status != NDIS_STATUS_SUCCESS)
    {
        PsDbgOut(DBG_INFO, 
                 DBG_VC, 
                 ("[CmModifyCallQoS]: Vc %08X, invalid QoS parameters\n", 
                 Vc));

        return Status;
    }

    //
    // make sure we can admit the flow onto our adapter. if this 
    // succeeds, the resources are committed and we'll have to call
    // CancelAcquiredFlowResources to return them.
    //

    Status = AcquireFlowResources(Vc, 
                                  CallParameters->CallMgrParameters,
                                  Vc->CallParameters->CallMgrParameters,
                                  &RemainingBandWidthChanged);


    if(Status != NDIS_STATUS_SUCCESS){

        PsDbgOut(DBG_INFO, 
                 DBG_VC, 
                 ("[CmModifyCallQoS]: Vc %08X, no flow resc\n", 
                 Vc));

        return Status;
    }

    Status = AddFlowToScheduler(MODIFY_VC, Vc, CallParameters, Vc->CallParameters);

    if(Status != NDIS_STATUS_SUCCESS){

        PsDbgOut(DBG_FAILURE,
                 DBG_VC,
                 ("[CmModifyCallQoS]: Vc %08X, failed %08X\n",
                  Vc,
                  Status));

        //
        // Free the copy we made, Cancel the committed resources.
        //

        CancelAcquiredFlowResources(Vc);

        return(Status);
    }

    // 
    // If there is an NDIS 5.0, connection oriented driver below us, then
    // we need to call it, with the call parameters, to complete the VC
    // setup.
    //

    if(Adapter->MediaType == NdisMediumWan){

        Status = WanModifyCall(Vc, CallParameters);

        PsAssert(Status == NDIS_STATUS_PENDING);

        return(Status);
    }
    else
    {

        // 
        // if we made it this far, the ModifyCallQoS succeeded!
        //

        Status = ProcessDiffservFlow(Vc, CallParameters->CallMgrParameters);

        if(Status != NDIS_STATUS_SUCCESS) {
            
            PsDbgOut(DBG_FAILURE,
                     DBG_VC,
                     ("[CmModifyCallQos]: Vc %08X, AddDiffservMapping failed %08X\n", Vc, Status));
       
            //
            // Undo the add flow done above, by reversing the new and old parameters.
            //

            ValidateCallParameters(Vc, Vc->CallParameters->CallMgrParameters);

            AddFlowToScheduler(MODIFY_VC, Vc, Vc->CallParameters, CallParameters);
            
            CancelAcquiredFlowResources(Vc);
            
            return Status;
        }

        if(TRUE == RemainingBandWidthChanged) {

            LONG RemainingBandWidth;

            PS_LOCK(&Adapter->Lock);
                
            RemainingBandWidth = (LONG) Adapter->RemainingBandWidth;
                
            PS_UNLOCK(&Adapter->Lock);
            
            PsTcNotify(Adapter, 0, OID_QOS_REMAINING_BANDWIDTH, &RemainingBandWidth, sizeof(LONG));
        }

        Vc->TokenRateChange = 0;
 
        return(NDIS_STATUS_SUCCESS);
    }
} // CmModifyCallQoS

VOID
ModifyCallComplete(
    PGPC_CLIENT_VC      Vc,
    PCO_CALL_PARAMETERS CallParameters,
    NDIS_STATUS         Status
    )
{
    PADAPTER Adapter = Vc->Adapter;

    PsAssert(Adapter->MediaType == NdisMediumWan);
    PsAssert(!IsBestEffortVc(Vc));

    if(Status != NDIS_STATUS_SUCCESS) {

        //
        // Undo the add flow done above, by reversing the new and old parameters.
        //
        ValidateCallParameters(Vc, Vc->CallParameters->CallMgrParameters);

        Status = AddFlowToScheduler(MODIFY_VC, Vc, Vc->CallParameters, CallParameters);

        CancelAcquiredFlowResources(Vc);
    }
    else {

        Status = ProcessDiffservFlow(Vc, CallParameters->CallMgrParameters);

        if(Status != NDIS_STATUS_SUCCESS) {
            
            PsDbgOut(DBG_FAILURE,
                     DBG_VC,
                     ("[CmModifyCallQos]: Vc %08X, AddDiffservMapping failed %08X\n", Vc, Status));
          
            //
            // Undo the add flow done above, by reversing the new and old parameters.
            //
            ValidateCallParameters(Vc, Vc->CallParameters->CallMgrParameters);

            AddFlowToScheduler(MODIFY_VC, Vc, Vc->CallParameters, CallParameters);

            CancelAcquiredFlowResources(Vc);
        
        }
    }

    Vc->TokenRateChange = 0;

    CmModifyCallComplete(Status, Vc, CallParameters);
}



NDIS_STATUS
CmCloseCall(
    PGPC_CLIENT_VC Vc
    )
{
    NDIS_STATUS   Status;
    PADAPTER      Adapter = Vc->Adapter;
    ULONG         RemainingBandWidthChanged;

    PsStructAssert(Adapter);
    //    
    // 	Here, we used to call RemoveFlowFromScheduler, which used to call "DeleteFlow". Instead, we will
    //  call a new interface "EmptyPacketsFromScheduler", which will call "EmptyFlow" to empty all the
    //  packets queued up in each of the components corresponding to this flow.
	//
	
	EmptyPacketsFromScheduler( Vc );

    RemoveDiffservMapping(Vc);

    ReturnFlowResources(Vc, &RemainingBandWidthChanged);

    if(TRUE == RemainingBandWidthChanged) {

        LONG RemainingBandWidth;

        PS_LOCK(&Adapter->Lock);
                
        RemainingBandWidth = (LONG) Adapter->RemainingBandWidth;
                
        PS_UNLOCK(&Adapter->Lock);
            
        PsTcNotify(Adapter, 0, OID_QOS_REMAINING_BANDWIDTH, &RemainingBandWidth, sizeof(LONG));
    }
    
    if(!IsBestEffortVc(Vc)) 
    {
        CmCloseCallComplete(NDIS_STATUS_SUCCESS, Vc);
    }
    else 
    {
        DerefClVc(Vc);
    }

    return NDIS_STATUS_PENDING;
}


NDIS_STATUS
CmDeleteVc(
    IN PGPC_CLIENT_VC Vc
    )
{

    PsAssert(Vc->RefCount == 0);

    if(Vc->InstanceName.Buffer) {

        PsFreePool(Vc->InstanceName.Buffer);
    }

    if( Vc->bRemoveFlow)
    {
        Vc->bRemoveFlow = FALSE;
        RemoveFlowFromScheduler(Vc);
    }                

    if(Vc->PsFlowContext) {
        
        if(Vc->Adapter->MediaType == NdisMediumWan) {

            if(Vc->PsFlowContext != Vc->WanLink->BestEffortVc.PsFlowContext) {

                PsFreePool(Vc->PsFlowContext);
            }
            else {

                if(Vc == &Vc->WanLink->BestEffortVc) {

                    PsFreePool(Vc->PsFlowContext);
                }
            }
        }
        else {

            if(Vc->PsFlowContext != Vc->Adapter->BestEffortVc.PsFlowContext) {

                PsFreePool(Vc->PsFlowContext);
            }
            else {
            
                if(Vc == &Vc->Adapter->BestEffortVc) {
                    
                    PsFreePool(Vc->PsFlowContext);
                }
            }
        }
    }

    NdisFreeSpinLock(&Vc->Lock);

    NdisFreeSpinLock(&Vc->BytesScheduledLock);

    NdisFreeSpinLock(&Vc->BytesTransmittedLock);

    
    if(Vc->CallParameters){

        PsFreePool(Vc->CallParameters);
        Vc->CallParameters = NULL;
    }


    if(!IsBestEffortVc(Vc))
    {
        PS_LOCK(&Vc->Adapter->Lock);

        RemoveEntryList(&Vc->Linkage);

        PS_UNLOCK(&Vc->Adapter->Lock);

        if(Vc->Flags & GPC_WANLINK_VC) 
        {
            REFDEL(&Vc->WanLink->RefCount, FALSE, 'WANV');
        }

        REFDEL(&Vc->Adapter->RefCount, FALSE, 'ADVC');


        PsFreeToLL(Vc, &GpcClientVcLL, GpcClientVc);
    }
    else 
    {
        PADAPTER Adapter = Vc->Adapter;

        if(Vc->Flags & GPC_WANLINK_VC) 
        {
            REFDEL(&Vc->WanLink->RefCount, FALSE, 'WANV');
        }

        REFDEL(&Adapter->RefCount, FALSE, 'ADVC');
    }

    return(NDIS_STATUS_SUCCESS);

} // CmDeleteVc


VOID
FillInCmParams(
    PCO_CALL_MANAGER_PARAMETERS CmParams,
    SERVICETYPE ServiceType,
    ULONG TokenRate,
    ULONG PeakBandwidth,
    ULONG TokenBucketSize,
    ULONG DSMode,
    ULONG Priority)
{
    PCO_SPECIFIC_PARAMETERS SpecificParameters;
    QOS_SD_MODE * QoSObjectSDMode;
    QOS_PRIORITY * QoSObjectPriority;
    QOS_OBJECT_HDR * QoSObjectHdr;

    CmParams->Transmit.ServiceType = ServiceType;
    CmParams->Transmit.TokenRate = TokenRate;
    CmParams->Transmit.PeakBandwidth = PeakBandwidth;
    CmParams->Transmit.TokenBucketSize = TokenBucketSize;

    CmParams->CallMgrSpecific.ParamType = PARAM_TYPE_GQOS_INFO;
    CmParams->CallMgrSpecific.Length = 0;

    SpecificParameters = 
        (PCO_SPECIFIC_PARAMETERS)&CmParams->CallMgrSpecific.Parameters;

    if(DSMode != QOS_UNSPECIFIED){

        CmParams->CallMgrSpecific.Length += sizeof(QOS_SD_MODE);
        QoSObjectSDMode = (QOS_SD_MODE *)SpecificParameters;
        QoSObjectSDMode->ObjectHdr.ObjectType = QOS_OBJECT_SD_MODE;
        QoSObjectSDMode->ObjectHdr.ObjectLength = sizeof(QOS_SD_MODE);
        QoSObjectSDMode->ShapeDiscardMode = DSMode;
        (QOS_SD_MODE *)SpecificParameters++;
    }

    if(Priority != QOS_UNSPECIFIED){

        CmParams->CallMgrSpecific.Length += sizeof(QOS_PRIORITY);
        QoSObjectPriority = (QOS_PRIORITY *)SpecificParameters;
        QoSObjectPriority->ObjectHdr.ObjectType = QOS_OBJECT_PRIORITY;
        QoSObjectPriority->ObjectHdr.ObjectLength = sizeof(QOS_PRIORITY);
        QoSObjectPriority->SendPriority = (UCHAR)Priority;
        (QOS_PRIORITY *)SpecificParameters++;
    }

    QoSObjectHdr = (QOS_OBJECT_HDR *)SpecificParameters;
    QoSObjectHdr->ObjectType = QOS_OBJECT_END_OF_LIST;
    QoSObjectHdr->ObjectLength = sizeof(QOS_OBJECT_HDR);
}
   

NDIS_STATUS
ValidateCallParameters(
    PGPC_CLIENT_VC              Vc,
    PCO_CALL_MANAGER_PARAMETERS CallParameters
    )
{
    ULONG               TokenRate = CallParameters->Transmit.TokenRate;
    SERVICETYPE         ServiceType = CallParameters->Transmit.ServiceType;
    NDIS_STATUS         Status = NDIS_STATUS_SUCCESS;
    UCHAR               SendPriority;
    ULONG               SDMode;
    ULONG               PeakBandwidth;
    LONG                ParamsLength;
    LPQOS_OBJECT_HDR    QoSObject;
    ULONG               Class;
    ULONG               DSFieldCount;
    LPQOS_DIFFSERV_RULE pDiffServRule;
    ULONG               i;
    ULONG               ShapingRate;

    ParamsLength = (LONG)CallParameters->CallMgrSpecific.Length;
    PeakBandwidth = CallParameters->Transmit.PeakBandwidth;

    //
    // By default, we want to shape to the TokenRate
    //
    Vc->ShapeTokenRate = TokenRate;

    QoSObject = (LPQOS_OBJECT_HDR)CallParameters->CallMgrSpecific.Parameters;

    while(ParamsLength > 0){

        switch(QoSObject->ObjectType){

          case QOS_OBJECT_TRAFFIC_CLASS:

             Class = (((LPQOS_TRAFFIC_CLASS)QoSObject)->TrafficClass);
             
             if(Class > USER_PRIORITY_MAX_VALUE)
             {
                return QOS_STATUS_INVALID_TRAFFIC_CLASS;
             }
             
             break;
             
          case QOS_OBJECT_DS_CLASS:
        
             Class = (((LPQOS_DS_CLASS)QoSObject)->DSField);
           
             if(Class > PREC_MAX_VALUE)
             {
                return QOS_STATUS_INVALID_DS_CLASS;
             }
             
             break;

          case QOS_OBJECT_SHAPING_RATE:

              ShapingRate = (((LPQOS_SHAPING_RATE)QoSObject)->ShapingRate);

              if(ShapingRate == 0 || ShapingRate > TokenRate)
              {
                  return QOS_STATUS_INVALID_SHAPE_RATE;
              }
              else 
              {
                  //
                  // If this QoS object is present, we want to shape to this 
                  // rate.
                  //
                  Vc->ShapeTokenRate = ShapingRate;
              }

              break;

          case QOS_OBJECT_DIFFSERV:

              DSFieldCount = (((LPQOS_DIFFSERV)QoSObject)->DSFieldCount);

              if(!DSFieldCount) {
                  
                  return QOS_STATUS_INVALID_DIFFSERV_FLOW;
              }

              pDiffServRule = ((LPQOS_DIFFSERV_RULE)((LPQOS_DIFFSERV)QoSObject)->DiffservRule);

              for(i=0; i<DSFieldCount; i++, pDiffServRule++) {

                  if(pDiffServRule->InboundDSField               > PREC_MAX_VALUE          ||
                     pDiffServRule->ConformingOutboundDSField    > PREC_MAX_VALUE          ||
                     pDiffServRule->NonConformingOutboundDSField > PREC_MAX_VALUE          ||
                     pDiffServRule->ConformingUserPriority       > USER_PRIORITY_MAX_VALUE ||
                     pDiffServRule->NonConformingUserPriority    > USER_PRIORITY_MAX_VALUE ) {
                      
                      return QOS_STATUS_INVALID_DIFFSERV_FLOW;
                  }
              }

              break;


        case QOS_OBJECT_PRIORITY:

            SendPriority = ((LPQOS_PRIORITY)QoSObject)->SendPriority;

            if((SendPriority < 0) || (SendPriority > 7)){

                // bad priority value - reject

                return(QOS_STATUS_INVALID_QOS_PRIORITY);
            }

            break;

        case QOS_OBJECT_SD_MODE:

            SDMode = ((LPQOS_SD_MODE)QoSObject)->ShapeDiscardMode;

            // 
            // Since SDMode is a ULONG, it can never be < TC_NONCONF_BORROW, which has a value of 0.
            // so, we just check to see if SDMode is > TC_NONCONF_BORROW_PLUS. This covers all cases.
            //

            if(SDMode > TC_NONCONF_BORROW_PLUS){

                // bad shape discard mode - reject

                return(QOS_STATUS_INVALID_SD_MODE);
            }

            if((SDMode > TC_NONCONF_BORROW) && 
               (TokenRate == UNSPECIFIED_RATE)){

                // must have TokenRate specified if any SDMode
                // other than TC_NONCONF_BORROW

                return(QOS_STATUS_INVALID_TOKEN_RATE);
            }

            break;

            // Pass any provider specific objects that we don't recognize

        }

        if(
            ((LONG)QoSObject->ObjectLength <= 0) ||
            ((LONG)QoSObject->ObjectLength > ParamsLength)
          ){

            return(QOS_STATUS_TC_OBJECT_LENGTH_INVALID);
        }

        ParamsLength -= QoSObject->ObjectLength;
        QoSObject = (LPQOS_OBJECT_HDR)((UINT_PTR)QoSObject + 
                                       QoSObject->ObjectLength);

    }

    // 
    // If there is a specified PeakBandwidth, it must be geq to the
    // TokenRate - meaning - there must be a TokenRate specified also.
    // This is reasonable for LAN, although ATM does allow a 
    // PeakBandwidth to be specified with no TokenRate.
    //
    // We also reject a TokenRate of zero. 
    //

    if(PeakBandwidth != UNSPECIFIED_RATE){

        if(TokenRate == UNSPECIFIED_RATE){

            return(QOS_STATUS_INVALID_PEAK_RATE);
        }

        if(TokenRate > PeakBandwidth){

            return(QOS_STATUS_INVALID_PEAK_RATE);
        }
    }

    if(TokenRate == 0){

        return(QOS_STATUS_INVALID_TOKEN_RATE);
    }

    switch(ServiceType){

    case SERVICETYPE_BESTEFFORT:
    case SERVICETYPE_NETWORK_CONTROL:
    case SERVICETYPE_QUALITATIVE:

        break;

    case SERVICETYPE_CONTROLLEDLOAD:
    case SERVICETYPE_GUARANTEED:

        // Must specify a TokenRate for these services

        if(TokenRate == QOS_UNSPECIFIED) {

            return(QOS_STATUS_INVALID_TOKEN_RATE);
        }
        break;

    default:

        return(QOS_STATUS_INVALID_SERVICE_TYPE);
    }
    
    return(Status);
}



NDIS_STATUS
AcquireFlowResources(
    PGPC_CLIENT_VC Vc,
    PCO_CALL_MANAGER_PARAMETERS NewCallParams,
    PCO_CALL_MANAGER_PARAMETERS OldCallParams,
    PULONG RemainingBandWidthChanged
    
    )

/*++

Routine Description:

    See if this adapter can support the requested flow. If it can, 
    NDIS_STATUS_SUCCESS is returned, indicating that the resources
    have been committed.

Arguments:

    Vc - pointer to vc's context block
    NewCallParams - struct describing the flow to add or to modify to.
    OldCallParams - in case of a modify, this describes the old params.
    

Return Value:

    NDIS_STATUS_SUCCESS if everything worked ok

--*/

{
    PADAPTER        Adapter;
    ULONG           OldTokenRate;
    SERVICETYPE     OldServiceType;
    ULONG           NewTokenRate   = NewCallParams->Transmit.TokenRate;
    SERVICETYPE     NewServiceType = NewCallParams->Transmit.ServiceType;
    NDIS_STATUS     Status         = NDIS_STATUS_SUCCESS;
    PULONG          RemainingBandWidth;
    PULONG          NonBestEffortLimit;
    PPS_SPIN_LOCK Lock;

    Adapter = Vc->Adapter;
    PsStructAssert(Adapter);

    *RemainingBandWidthChanged = FALSE;

    if(Adapter->MediaType == NdisMediumWan && (!IsBestEffortVc(Vc))) 
    {
        RemainingBandWidth = &Vc->WanLink->RemainingBandWidth;
        NonBestEffortLimit = &Vc->WanLink->NonBestEffortLimit;
        Lock = &Vc->WanLink->Lock;
        return NDIS_STATUS_SUCCESS;
    }
    else 
    {
        RemainingBandWidth = &Adapter->RemainingBandWidth;
        NonBestEffortLimit = &Adapter->NonBestEffortLimit;
        Lock = &Adapter->Lock;
    }


    if(OldCallParams)
    {
        OldTokenRate = OldCallParams->Transmit.TokenRate;
        OldServiceType = OldCallParams->Transmit.ServiceType;
    }

    //
    // sanity check passed; now see if we have the resouces locally
    //
    // for best-effort flows, the token rate, for the purpose of
    // admission control, is considered to be zero
    //

    if(NewServiceType == SERVICETYPE_BESTEFFORT || NewServiceType == SERVICETYPE_NETWORK_CONTROL ||
       NewServiceType == SERVICETYPE_QUALITATIVE)
    {

        NewTokenRate = 0;
    }

    // 
    // Handle add differently from a modify
    //

    if(!OldCallParams){

        PS_LOCK(Lock);
    
        if((((LONG)(*RemainingBandWidth)) < 0) || (NewTokenRate > *RemainingBandWidth)){

            PS_UNLOCK(Lock);

            return(NDIS_STATUS_RESOURCES);

        }
        else{

            if(NewTokenRate) {
                
                *RemainingBandWidthChanged = TRUE;
            }

            *RemainingBandWidth -= NewTokenRate;

            //
            // Record the change we made, in case we have
            // to cancel the addition.
            //

            Vc->TokenRateChange = NewTokenRate;
            Vc->RemainingBandwidthIncreased = FALSE;

            PsAssert((*RemainingBandWidth <=  *NonBestEffortLimit));

            PS_UNLOCK(Lock);
        }
    }
    else{

        //
        // it's a modify
        // 
        // If the OldServiceType is best-effort, 
        // then the OldTokenRate can be considered
        // to be zero, for the purpose of admission control.
        //

        if(OldServiceType == SERVICETYPE_BESTEFFORT || 
           OldServiceType == SERVICETYPE_NETWORK_CONTROL ||
           OldServiceType == SERVICETYPE_QUALITATIVE)
        {

            OldTokenRate = 0;
        }

        PS_LOCK(Lock);

        if(NewTokenRate != OldTokenRate){

            if((((LONG) *RemainingBandWidth) < 0 )||
               ((NewTokenRate > OldTokenRate) && 
                ((NewTokenRate - OldTokenRate) > 
                 (*RemainingBandWidth)))){
                
                //
                // asked for more and none was available
                //
           
                PS_UNLOCK( Lock );

                return(NDIS_STATUS_RESOURCES);

            }
            else{

                //
                // either asked for less or rate increment was available
                //

                *RemainingBandWidth -= NewTokenRate;
                *RemainingBandWidth += OldTokenRate;

                if((NewTokenRate != 0) || (OldTokenRate != 0)) {

                    *RemainingBandWidthChanged = TRUE;
                }
                   
                //
                // Now we've acquired the resources. If
                // the VC activation fails for any reason,
                // we'll need to return resources. We should
                // return the difference between the old token
                // rate and the new token rate, not the new token
                // rate.
                //

                if(NewTokenRate > OldTokenRate){

                    // Can't use signed ints, cause we'll lose range

                    Vc->TokenRateChange = NewTokenRate - OldTokenRate;
                    Vc->RemainingBandwidthIncreased = FALSE;

                }
                else{

                    Vc->TokenRateChange = OldTokenRate - NewTokenRate;
                    Vc->RemainingBandwidthIncreased = TRUE;
                }

                PS_UNLOCK( Lock );
            }
        }
        else{

            PS_UNLOCK(Lock);
        }

    }

    return Status;

} // AcquireFlowResources

VOID
CancelAcquiredFlowResources(
    PGPC_CLIENT_VC Vc
    )

/*++

Routine Description:

    Called when a modify or add flwo failed, after we did admission control.

Arguments:

    Vc - pointer to client vc's context block

Return Value:

    None

--*/

{
    PADAPTER        Adapter;
    PPS_SPIN_LOCK Lock;
    PULONG RemainingBandWidth;

    Adapter = Vc->Adapter;
    PsStructAssert(Adapter);

    if(Adapter->MediaType == NdisMediumWan && (!IsBestEffortVc(Vc))) 
    {
        Lock = &Vc->WanLink->Lock;
        RemainingBandWidth = &Vc->WanLink->RemainingBandWidth;
        return;
    }
    else 
    {
        Lock = &Adapter->Lock;
        RemainingBandWidth = &Adapter->RemainingBandWidth;
    }

    if(!Vc->TokenRateChange){

        return;
    }

    PS_LOCK( Lock );

    if(Vc->RemainingBandwidthIncreased){

        *RemainingBandWidth -= Vc->TokenRateChange;
    }
    else{

        *RemainingBandWidth += Vc->TokenRateChange;
    }

    // 
    // Now that we have already returned the correct TokenRate, we need to set it to 0
    // so that this is not used in subsequent VC operations.
    //

    Vc->TokenRateChange = 0;

    // PsAssert(Adapter->RemainingBandWidth <= Adapter->NonBestEffortLimit);

    PS_UNLOCK( Lock );

} // CancelAcquiredFlowResources


VOID
ReturnFlowResources(
    PGPC_CLIENT_VC Vc,
    PULONG RemainingBandWidthChanged
    )

/*++

Routine Description:

    Return all the resources acquired for this flow

Arguments:
 
    Vc - pointer to client vc's context block

Return Value:

    None

--*/

{
    PADAPTER                      Adapter;
    PCO_CALL_MANAGER_PARAMETERS   CmParams    = Vc->CallParameters->CallMgrParameters;
    ULONG                         TokenRate   = CmParams->Transmit.TokenRate;
    SERVICETYPE                   ServiceType = CmParams->Transmit.ServiceType;
    PPS_SPIN_LOCK                 Lock;
    PULONG                        RemainingBandWidth;

    Adapter = Vc->Adapter;
    PsStructAssert(Adapter);

    *RemainingBandWidthChanged = FALSE;

    if(Adapter->MediaType == NdisMediumWan && (!IsBestEffortVc(Vc))) 
    {
        RemainingBandWidth = &Vc->WanLink->RemainingBandWidth;
        Lock = &Vc->WanLink->Lock;
        return;
    }
    else 
    {
        RemainingBandWidth = &Adapter->RemainingBandWidth;
        Lock = &Adapter->Lock;
    }

    if (ServiceType == SERVICETYPE_BESTEFFORT      || 
        ServiceType == SERVICETYPE_NETWORK_CONTROL || 
        ServiceType == SERVICETYPE_QUALITATIVE)
    {

        return;

    }

    *RemainingBandWidthChanged = TRUE;

    PsAssert((LONG)TokenRate > 0);

    PS_LOCK( Lock );

    *RemainingBandWidth += TokenRate;

    // PsAssert(Adapter->RemainingBandWidth <= Adapter->NonBestEffortLimit);

    PS_UNLOCK( Lock );

} // ReturnFlowResources


NDIS_STATUS
CreateBestEffortVc(
    PADAPTER Adapter,
    PGPC_CLIENT_VC Vc,
    PPS_WAN_LINK WanLink
    )
{
    PCO_CALL_PARAMETERS         CallParams;
    PCO_CALL_MANAGER_PARAMETERS CallMgrParameters;
    PCO_MEDIA_PARAMETERS        MediaParameters;
    ULONG                       CallParamsLength;
    NDIS_STATUS                 Status;
    int                         i;


    InitGpcClientVc(Vc, GPC_CLIENT_BEST_EFFORT_VC, Adapter);
    SetLLTag(Vc, GpcClientVc);

    //
    //  Invalidate all the port numbers
    for( i = 0; i < PORT_LIST_LEN; i++)
    {
        Vc->SrcPort[i] = 0xffff;
        Vc->DstPort[i] = 0xffff;
    }

    //  Next Insertion will be at index 0
    Vc->NextSlot = 0;
    
    //
    // Allocate the resources for the call manager parameters.
    //

    CallParamsLength = sizeof(CO_CALL_PARAMETERS) +
                       sizeof(CO_CALL_MANAGER_PARAMETERS) +
                       sizeof(QOS_SD_MODE) +
                       sizeof(QOS_OBJECT_HDR) +
                       FIELD_OFFSET(CO_MEDIA_PARAMETERS, MediaSpecific) +
                       FIELD_OFFSET(CO_SPECIFIC_PARAMETERS, Parameters);

    if(Adapter->MediaType == NdisMediumWan) 
    {
        CallParamsLength += sizeof(QOS_WAN_MEDIA);
        Vc->PsPipeContext = WanLink->PsPipeContext;
        Vc->PsComponent   = WanLink->PsComponent;
        Vc->AdapterStats  = &WanLink->Stats;
        Vc->WanLink       = WanLink;
        Vc->Flags        |= GPC_WANLINK_VC;

        if(Adapter->BestEffortLimit != UNSPECIFIED_RATE) 
        {
            //
            // If LBE is specified over WAN, use UBE
            //
                
            PsAdapterWriteEventLog(
                EVENT_PS_WAN_LIMITED_BESTEFFORT,
                0,
                &Adapter->MpDeviceName,
                0,
                NULL);

            Adapter->BestEffortLimit = UNSPECIFIED_RATE;
        }
    }
    else
    {
        Vc->PsPipeContext = Adapter->PsPipeContext;
        Vc->PsComponent   = Adapter->PsComponent;
        Vc->AdapterStats  = &Adapter->Stats;
    }

    PsAllocatePool(CallParams, CallParamsLength, CmParamsTag);

    if(CallParams == NULL)
    {
        return NDIS_STATUS_RESOURCES;
    }

    //
    // build a call params struct describing the flow
    //

    NdisZeroMemory(CallParams, CallParamsLength);

    //
    // Build the Call Manager Parameters.
    //
    CallMgrParameters = (PCO_CALL_MANAGER_PARAMETERS)(CallParams + 1);

    if(Adapter->BestEffortLimit == UNSPECIFIED_RATE)
    {
        FillInCmParams(CallMgrParameters,
                       SERVICETYPE_BESTEFFORT,
                       (ULONG)UNSPECIFIED_RATE,
                       (ULONG)UNSPECIFIED_RATE,
                       Adapter->TotalSize,
                       QOS_UNSPECIFIED,
                       QOS_UNSPECIFIED);
    }
    else 
    {
        // 
        // Limited Best Effort
        //

        PsAssert(Adapter->MediaType != NdisMediumWan);

        if(Adapter->BestEffortLimit >= Adapter->LinkSpeed) {

            // If the specified limit is greater than the link speed,
            // then we should operate in unlimited best-effort mode.
            
            
            PsAdapterWriteEventLog(
                EVENT_PS_BAD_BESTEFFORT_LIMIT,
                0,
                &Adapter->MpDeviceName,
                0,
                NULL);
            
            PsDbgOut(DBG_INFO,
                     DBG_PROTOCOL,
                     ("[CreateBestEffortVc]: b/e limit %d exceeds link speed %d\n",
                      Adapter->BestEffortLimit,
                      Adapter->LinkSpeed));
            
            Adapter->BestEffortLimit = UNSPECIFIED_RATE;

            FillInCmParams(CallMgrParameters,
                           SERVICETYPE_BESTEFFORT,
                           (ULONG)UNSPECIFIED_RATE,
                           (ULONG)UNSPECIFIED_RATE,
                           Adapter->TotalSize,
                           QOS_UNSPECIFIED,
                           QOS_UNSPECIFIED);
            
        }
        else
        {
            FillInCmParams(CallMgrParameters,
                           SERVICETYPE_BESTEFFORT,
                           Adapter->BestEffortLimit,
                           (ULONG)UNSPECIFIED_RATE,
                           Adapter->TotalSize,
                           TC_NONCONF_SHAPE,
                           QOS_UNSPECIFIED);
        }
    }


    //
    // Build the MediaParameters.
    //

    CallParams->MediaParameters = 
                    (PCO_MEDIA_PARAMETERS)(CallMgrParameters + 1);

    MediaParameters = (PCO_MEDIA_PARAMETERS)((PUCHAR)
                            CallMgrParameters +
                            sizeof(CO_CALL_MANAGER_PARAMETERS) +
                            sizeof(QOS_SD_MODE) +
                            sizeof(QOS_OBJECT_HDR));

    MediaParameters->Flags = 0;
    MediaParameters->ReceivePriority = 0;
    MediaParameters->ReceiveSizeHint = 0;
    MediaParameters->MediaSpecific.ParamType = PARAM_TYPE_GQOS_INFO;
    MediaParameters->MediaSpecific.Length = 0;

    CallParams->Flags = 0;
    CallParams->CallMgrParameters = CallMgrParameters;
    CallParams->MediaParameters = (PCO_MEDIA_PARAMETERS)MediaParameters;

    if(Adapter->MediaType == NdisMediumWan) {

        LPQOS_WAN_MEDIA WanMedia;
        MediaParameters->MediaSpecific.Length += sizeof(QOS_WAN_MEDIA);
        WanMedia = (LPQOS_WAN_MEDIA) MediaParameters->MediaSpecific.Parameters;

        NdisZeroMemory(WanMedia, sizeof(QOS_WAN_MEDIA));

        WanMedia->ObjectHdr.ObjectType   = QOS_OBJECT_WAN_MEDIA;
        WanMedia->ObjectHdr.ObjectLength = sizeof(QOS_WAN_MEDIA);

        NdisMoveMemory(&WanMedia->LinkId,
                       &WanLink->OriginalRemoteMacAddress,
                       6);

    }

    Vc->CallParameters = CallParams;

    Status = CmMakeCall(Vc);

    PsAssert(Status != NDIS_STATUS_PENDING);

    if(Status == NDIS_STATUS_SUCCESS)
    {

        REFADD(&Adapter->RefCount, 'ADVC');
        if(Adapter->MediaType == NdisMediumWan)
        {
            REFADD(&WanLink->RefCount, 'WANV');
        }
        //
        // Also save the non conforming value - so that the sequencer can stamp it
        // for non conforming packets. This will not change between reboots & hence
        // need not be done in the ModifyCfInfo
        //
        
        Vc->UserPriorityNonConforming = Adapter->UserServiceTypeNonConforming;
       
        switch(Vc->CallParameters->CallMgrParameters->Transmit.ServiceType)
        {
          case SERVICETYPE_CONTROLLEDLOAD:
              Vc->UserPriorityConforming    = Adapter->UserServiceTypeControlledLoad;
              Vc->IPPrecedenceNonConforming = Adapter->IPServiceTypeControlledLoadNC;
              break;
          case SERVICETYPE_GUARANTEED:
              Vc->UserPriorityConforming    = Adapter->UserServiceTypeGuaranteed;
              Vc->IPPrecedenceNonConforming = Adapter->IPServiceTypeGuaranteedNC;
              break;
          case SERVICETYPE_BESTEFFORT:
              Vc->UserPriorityConforming    = Adapter->UserServiceTypeBestEffort;
              Vc->IPPrecedenceNonConforming = Adapter->IPServiceTypeBestEffortNC;
              break;
          case SERVICETYPE_QUALITATIVE:
              Vc->UserPriorityConforming    = Adapter->UserServiceTypeQualitative;
              Vc->IPPrecedenceNonConforming = Adapter->IPServiceTypeQualitativeNC;
              break;
          case SERVICETYPE_NETWORK_CONTROL:
              Vc->UserPriorityConforming    = Adapter->UserServiceTypeNetworkControl;
              Vc->IPPrecedenceNonConforming = Adapter->IPServiceTypeNetworkControlNC;
              break;
        }
        
        //
        // Transistion to the Call complete state
        //
        
        CallSucceededStateTransition(Vc);

    }

    return Status;
}

NDIS_STATUS
RemoveDiffservMapping(
    PGPC_CLIENT_VC Vc
)
{
    LPQOS_OBJECT_HDR            QoSObject;
    ULONG                       ParamsLength;
    ULONG                       DSFieldCount;
    LPQOS_DIFFSERV_RULE         pDiffServRule;
    ULONG                       i;
    PADAPTER                    Adapter = Vc->Adapter;
    PCO_CALL_MANAGER_PARAMETERS CallParameters = Vc->CallParameters->CallMgrParameters;
    PDIFFSERV_MAPPING           pDiffServMapping;

    ParamsLength = (LONG)CallParameters->CallMgrSpecific.Length;
    
    QoSObject = (LPQOS_OBJECT_HDR)CallParameters->CallMgrSpecific.Parameters;
    
    while(ParamsLength > 0) {

        if(QoSObject->ObjectType == QOS_OBJECT_DIFFSERV) 
        {

            DSFieldCount = (((LPQOS_DIFFSERV)QoSObject)->DSFieldCount);
    
            //
            // Make sure that everything that we are clearing is mapped to the same Vc.
            //

            PS_LOCK(&Adapter->Lock);

            if(Vc->WanLink)
            {
               pDiffServMapping = Vc->WanLink->pDiffServMapping;
            }
            else 
            {
               pDiffServMapping = Vc->Adapter->pDiffServMapping;
            }

            for(i=0, pDiffServRule = ((LPQOS_DIFFSERV_RULE)((LPQOS_DIFFSERV)QoSObject)->DiffservRule);
                i<DSFieldCount; 
                i++, pDiffServRule++) 
            {
                UCHAR tos = pDiffServRule->InboundDSField;
                
                if(pDiffServMapping[tos].Vc == Vc) {
                    
                    pDiffServMapping[tos].Vc = 0;
                }
                else 
                {
                    //
                    // We are trying to remove a codepoint that is mapped to another VC. Ideally, this
                    // should never happen. We still need to check that this is a valid VC (otherwise, if 
                    // a diffserv rule has the same codepoint more than one time, we could still hit this 
                    // assert, because the first codepoint will clear the mapping and the second codepoint 
                    // will see the NULL - so we check if the Vc is non null)
                    //
                   
                    if(pDiffServMapping[tos].Vc)
                    {
                        PsDbgOut(DBG_FAILURE, DBG_VC, 
                                 ("[RemoveDiffservMapping]: Vc %08X, Trying to remove codepoint %d that "
                                  "is mapped to Vc %08X \n", 
                                  Vc, 
                                  pDiffServRule->InboundDSField, 
                                  pDiffServMapping[pDiffServRule->InboundDSField].Vc));
                        
                        PsAssert(0);
                    }
                }
            }

#if DBG
            
            //
            // Make sure that no TOS mapping points to this VC.
            //
            
            for(i=0; i<=PREC_MAX_VALUE; i++) {
                
                PsAssert(pDiffServMapping[i].Vc != Vc);
            }
#endif
            PS_UNLOCK(&Adapter->Lock);

            return NDIS_STATUS_SUCCESS;
        }
        
        ParamsLength -= QoSObject->ObjectLength;
        
        QoSObject = (LPQOS_OBJECT_HDR)((UINT_PTR)QoSObject + 
                                       QoSObject->ObjectLength);
    }
    
    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS
ProcessDiffservFlow(
    PGPC_CLIENT_VC Vc,
    PCO_CALL_MANAGER_PARAMETERS CallParameters)
{
    LPQOS_OBJECT_HDR    QoSObject;
    ULONG               ParamsLength;
    ULONG               DSFieldCount;
    LPQOS_DIFFSERV_RULE pDiffServRule;
    ULONG               i;
    PGPC_CLIENT_VC      CurrentVc;
    PADAPTER            Adapter = Vc->Adapter;
    PDIFFSERV_MAPPING   pDiffServMapping;
    PDIFFSERV_MAPPING   *pD;
    
    ParamsLength = (LONG)CallParameters->CallMgrSpecific.Length;
    QoSObject = (LPQOS_OBJECT_HDR)CallParameters->CallMgrSpecific.Parameters;

    while(ParamsLength > 0) 
    {
        if(QoSObject->ObjectType == QOS_OBJECT_DIFFSERV) 
        {

            //
            // We have found the diffserv QoS object. This could be due to a add or modify of
            // the flow. If this is an add, we are okay. If it is a modify, there are 2 cases.
            // 1. Modify from an RSVP flow to a Diffserv Flow.
            // 2. Modify from a diffserv flow to another diffserv flow.
            //

            DSFieldCount = (((LPQOS_DIFFSERV)QoSObject)->DSFieldCount);

            PS_LOCK(&Adapter->Lock);

            if(Vc->WanLink)
            {
                pDiffServMapping = Vc->WanLink->pDiffServMapping;
                pD = &Vc->WanLink->pDiffServMapping;
            }
            else 
            {
                pDiffServMapping = Vc->Adapter->pDiffServMapping;
                pD = &Vc->Adapter->pDiffServMapping;
            }

            if(pDiffServMapping == 0)
            {
                //
                // To optimize on memory, we allocate the diffserv mapping only when someone creates
                // a Diffserv flow on that adapter or wanlink. 
                // 
                // We could further optimize this by freeing this when the last diffserv flow went 
                // away - For now, we assume that if a Diffserv flow is created on an interface, then the 
                // interface is probably going to be used for Diffserv mode till the next reboot. This is 
                // not such a bad assumption, because the Diffserv mode is meaningful only on routers
                // and we don't expect to switch b/w these modes very often.
                //

                PsAllocatePool(*pD,
                               sizeof(DIFFSERV_MAPPING) * (PREC_MAX_VALUE+1),
                               PsMiscTag);

                if(*pD == 0)
                {
                    PS_UNLOCK(&Adapter->Lock);
                    return NDIS_STATUS_RESOURCES;
                }
                else 
                {
                    NdisZeroMemory(*pD, sizeof(DIFFSERV_MAPPING) * (PREC_MAX_VALUE+1));
                }

                pDiffServMapping = *pD;
            }
            

            //
            // Make sure that everything is either unmapped, or is mapped to the same vc (for modify)
            //
            
            for(i=0, pDiffServRule = ((LPQOS_DIFFSERV_RULE)((LPQOS_DIFFSERV)QoSObject)->DiffservRule);
                i<DSFieldCount; 
                i++, pDiffServRule++) 
            {
                
                uchar tos = pDiffServRule->InboundDSField;
                CurrentVc = pDiffServMapping[tos].Vc;
                
                if(CurrentVc) {
                    
                    if(CurrentVc != Vc) {
                        
                        PS_UNLOCK(&Adapter->Lock);

                        PsDbgOut(DBG_FAILURE, DBG_GPC_QOS, 
                                 ("[ProcessDiffservFlow]: Adapter %08X, Vc%08X: CodePoint %d already "
                                  " mapped to Vc 0x%x \n", 
                                  Adapter, 
                                  Vc, 
                                  pDiffServRule->InboundDSField, 
                                  CurrentVc));
                        
                        return QOS_STATUS_DS_MAPPING_EXISTS;
                    }
                    
                    PsAssert(Vc->ModifyCallParameters);

                }
            }
            

            if(Vc->ModifyCallParameters) {
                
                //
                // for a modify, we need to unmap the ones that are not there in this rule
                //
                
                for(i=0; i<=PREC_MAX_VALUE; i++) {
                    
                    if(pDiffServMapping[i].Vc == Vc) {
                        
                        pDiffServMapping[i].Vc = 0;
                    }
                }
            }
            
            //
            // Map (or re-map)
            //
            
            for(i=0, pDiffServRule = ((LPQOS_DIFFSERV_RULE)((LPQOS_DIFFSERV)QoSObject)->DiffservRule);
                i<DSFieldCount; 
                i++, pDiffServRule++) 
            {
                
                uchar tos = pDiffServRule->InboundDSField;
                
                pDiffServMapping[tos].Vc = Vc;
                
                pDiffServMapping[tos].ConformingOutboundDSField =
                    pDiffServRule->ConformingOutboundDSField << 2;
                
                pDiffServMapping[tos].NonConformingOutboundDSField =
                    pDiffServRule->NonConformingOutboundDSField << 2;
                
                pDiffServMapping[tos].ConformingUserPriority =
                    pDiffServRule->ConformingUserPriority;
                
                pDiffServMapping[tos].NonConformingUserPriority =
                    pDiffServRule->NonConformingUserPriority;
                
            }
       
            PS_UNLOCK(&Adapter->Lock);

            return NDIS_STATUS_SUCCESS;
        }
        
        ParamsLength -= QoSObject->ObjectLength;
        
        QoSObject = (LPQOS_OBJECT_HDR)((UINT_PTR)QoSObject + 
                                       QoSObject->ObjectLength);
    }

    //
    // This is a RSVP flow. If this is a modify, we need to unmap existing diffserv flows, because
    // we could be changing this from a Diffserv Flow to a RSVP flow.
    //

    if(Vc->ModifyCallParameters) 
    {
        //
        // for a modify, we need to unmap the ones that are not there in this rule
        //
       
       PS_LOCK(&Adapter->Lock);
       
       if(Vc->WanLink)
       {
          pDiffServMapping = Vc->WanLink->pDiffServMapping;
       }
       else 
       {
          pDiffServMapping = Vc->Adapter->pDiffServMapping;
       }
       
       if(pDiffServMapping)
       {
          
          for(i=0; i<=PREC_MAX_VALUE; i++) 
          {
             if(pDiffServMapping[i].Vc == Vc) 
             {
                pDiffServMapping[i].Vc = 0;
             }
          }
       }

       PS_UNLOCK(&Adapter->Lock);
    }
    

    return NDIS_STATUS_SUCCESS;
}

/* end cmvc.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\config.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    config.c

Abstract:

    This file contains all routines necessary for the support of dynamic
    configuration.

Author:

    Rajesh Sundaram (rajeshsu)

Environment:

    Kernel Mode

Revision History:

--*/

#include "psched.h"
#pragma hdrstop

//
// Forward declaration for using #pragma

NDIS_STATUS
PsReadAdapterRegistryDataInit(PADAPTER     Adapter,
                              PNDIS_STRING AdapterKey
                              );

NDIS_STATUS
PsReadAdapterRegistryData(PADAPTER     Adapter,
                         PNDIS_STRING MachineKey,
                         PNDIS_STRING AdapterKey);


#pragma alloc_text(PAGE, PsReadAdapterRegistryData)
#pragma alloc_text(PAGE, PsReadAdapterRegistryDataInit)


//
// Local functions used to access the registry.
//

NDIS_STATUS 
PsReadRegistryInt(
    IN NDIS_HANDLE  ConfigHandle,
    IN PNDIS_STRING ValueName,
    IN ULONG        ValueDefault,
    IN OUT PULONG   ValuePtr,
    IN ULONG        ValueMin,
    IN ULONG        ValueMax,
    IN BOOLEAN      Subkey,
    IN PNDIS_STRING SubKeyName,
    IN HANDLE       SubKeyHandle,
    IN BOOLEAN      ZAW
)
{
    PNDIS_CONFIGURATION_PARAMETER ConfigParam;
    NDIS_STATUS                   Status;
    NTSTATUS                      NtStatus;
    ULONG                         Value;

    RTL_QUERY_REGISTRY_TABLE ServiceKeys[] = 
    {
        {NULL,
         0,
         NULL,
         NULL,
         0,
         NULL,
         0},

        {NULL,
         0,
         NULL,
         NULL,
         0,
         NULL,
         0},
        
        {NULL,
         0,
         NULL,
         NULL,
         0,
         NULL,
         0}
    };

    if(Subkey)
    {
        PsDbgOut(DBG_INFO, DBG_INIT | DBG_ZAW,
                 ("[PsReadSingleParameter]: Subkey %ws, Key %ws \n", 
                  SubKeyName->Buffer, ValueName->Buffer));

        NdisReadConfiguration(&Status,
                              &ConfigParam,
                              SubKeyHandle,
                              ValueName,
                              NdisParameterInteger);
    }
    else 
    {
        PsDbgOut(DBG_INFO, DBG_INIT | DBG_ZAW,
                 ("[PsReadSingleParameter]: Subkey NULL, Key %ws \n", ValueName->Buffer));

        NdisReadConfiguration(&Status,
                              &ConfigParam,
                              ConfigHandle,
                              ValueName,
                              NdisParameterInteger);

    }

    if(Status == NDIS_STATUS_SUCCESS)
    {
        *ValuePtr = ConfigParam->ParameterData.IntegerData;

        if(*ValuePtr < ValueMin || *ValuePtr > ValueMax)
        {
            PsDbgOut(DBG_FAILURE, DBG_INIT | DBG_ZAW,
                     ("[PsReadSingleParameter]: Per adapter:  %d does not fall in range (%d - %d) \n",
                      *ValuePtr, ValueMin, ValueMax));

            *ValuePtr = ValueDefault;
        }

        PsDbgOut(DBG_INFO, DBG_INIT | DBG_ZAW,
                 ("\t\t Per adapter: 0x%x \n", *ValuePtr));

        return Status;
    }
    else 
    {
        if(ZAW)
        {
            //
            // See if we can read it from the per machine area. We need to use the RtlAPIs for this.
            //
            if(Subkey)
            {
                ServiceKeys[0].QueryRoutine  = NULL;
                ServiceKeys[0].Flags         = RTL_QUERY_REGISTRY_SUBKEY;
                ServiceKeys[0].Name          = SubKeyName->Buffer;
                ServiceKeys[0].EntryContext  = NULL;
                ServiceKeys[0].DefaultType   = REG_NONE;
                ServiceKeys[0].DefaultData   = NULL;
                ServiceKeys[0].DefaultLength = 0;
                
                ServiceKeys[1].QueryRoutine  = NULL;
                ServiceKeys[1].Flags         = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
                ServiceKeys[1].Name          = ValueName->Buffer;
                ServiceKeys[1].EntryContext  = &Value;
                ServiceKeys[1].DefaultType   = REG_NONE;
                ServiceKeys[1].DefaultData   = NULL;
                ServiceKeys[1].DefaultLength = 0;
            }
            else 
            {
                ServiceKeys[0].QueryRoutine  = NULL;
                ServiceKeys[0].Flags         = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
                ServiceKeys[0].Name          = ValueName->Buffer;
                ServiceKeys[0].EntryContext  = &Value;
                ServiceKeys[0].DefaultType   = REG_NONE;
                ServiceKeys[0].DefaultData   = NULL;
                ServiceKeys[0].DefaultLength = 0;
            }
            
            
            NtStatus = RtlQueryRegistryValues(
                RTL_REGISTRY_ABSOLUTE,
                MachineRegistryKey.Buffer,
                ServiceKeys,
                NULL,
                NULL);
            
            if(NT_SUCCESS(NtStatus))
            {
                *ValuePtr = Value;
                
                if(*ValuePtr < ValueMin || *ValuePtr > ValueMax)
                {
                    PsDbgOut(DBG_FAILURE, DBG_INIT | DBG_ZAW,
                             ("[PsReadSingleParameter]: ZAW %ws %d does not fall in range (%d - %d) \n",
                              ValueName->Buffer, *ValuePtr, ValueMin, ValueMax));

                    *ValuePtr = ValueDefault;
                }
                
                PsDbgOut(DBG_INFO, DBG_INIT | DBG_ZAW, ("\t\tZAW 0x%x \n", *ValuePtr));

                return NDIS_STATUS_SUCCESS;
            }
            else
            {
                *ValuePtr = ValueDefault;
                PsDbgOut(DBG_INFO, DBG_INIT | DBG_ZAW, 
                         ("\t\tNot in ZAW/Adapter, Using default %d \n", *ValuePtr));

                return NtStatus;
            }
        }
        else 
        {
            *ValuePtr = ValueDefault;
            PsDbgOut(DBG_INFO, DBG_INIT | DBG_ZAW, 
                     ("\t\tNot in ZAW/Adapter, Using default %d \n", *ValuePtr));

            return Status;

        }
    }
}


NTSTATUS
PsReadRegistryString(IN NDIS_HANDLE  ConfigHandle,
             IN PNDIS_STRING Key,
             IN PNDIS_STRING Buffer
             )
{
    NDIS_STATUS                   Status;
    PNDIS_CONFIGURATION_PARAMETER ConfigParam;
    
    NdisReadConfiguration(&Status,
                          &ConfigParam,
                          ConfigHandle,
                          Key,
                          NdisParameterMultiString);

    if(Status == NDIS_STATUS_SUCCESS)
    {
        Buffer->Length        = ConfigParam->ParameterData.StringData.Length;
        Buffer->MaximumLength = Buffer->Length + sizeof(WCHAR);

        PsAllocatePool(Buffer->Buffer,
                       Buffer->MaximumLength,
                       PsMiscTag);

        if(Buffer->Buffer)
        {
            RtlCopyUnicodeString(Buffer, &ConfigParam->ParameterData.StringData);
        }

    }

    return Status;
}


STATIC VOID
ReadProfiles(
    NDIS_HANDLE                   ConfigHandle
    )
/*++

Routine Description:
    This routine is used by the driver to read the Profiles key from the
    registry. The profile is a multiple string list of available profiles.
    Each entry on this list identifies another value under Psched\Parameters
    which contains the list of modules that comprise the profile.

Arguments:
    ConfigHandle - Handle to the registry entry

Return Value:
--*/
{
    NDIS_STATUS                   Status;
    PNDIS_CONFIGURATION_PARAMETER pConfigParam;
    PNDIS_CONFIGURATION_PARAMETER pProfileParam;
    PPS_PROFILE                   pProfileInfo;
    PWSTR                         r, p;
    UINT                          i, j, cnt;
    NDIS_STRING                   ProfileKey = NDIS_STRING_CONST("Profiles");
    NDIS_STRING                   StringName;
    BOOLEAN                       StubFlag;
    NDIS_STRING                   StubComponent = NDIS_STRING_CONST("SchedulerStub");

    NdisReadConfiguration( &Status,
                           &pConfigParam,
                           ConfigHandle,
                           &ProfileKey,
                           NdisParameterMultiString);

    if ( NT_SUCCESS( Status ))
    {
        //
        // pConfigParam now contains a list of profiles.
        //
        for (p = pConfigParam->ParameterData.StringData.Buffer, i = 0;
             *p != L'\0';
             i++)
        {

            //
            // Allocate a new PS_PROFILE entry and store it into
            // a global list.
            //

            PsAllocatePool(pProfileInfo, sizeof(PS_PROFILE), ProfileTag);

            if(!pProfileInfo)
            {
                //
                // Don't have to worry about freeing the previous profiles as they will get freed
                // when we clear the PsProfileList.
                //

                PsDbgOut(DBG_CRITICAL_ERROR, DBG_INIT,
                         ("[ReadProfiles]: cannot allocate memory to hold profile \n"));

                break;
            }

            NdisZeroMemory(pProfileInfo, sizeof(PS_PROFILE));
            InsertHeadList( &PsProfileList, &pProfileInfo->Links );

            // Copy the Profile Name
            // 1. Initialize the unicode strings
            // 2. Allocate memory for the string
            // 3. Copy the string over.

            RtlInitUnicodeString(&StringName, p);
            RtlInitUnicodeString(&pProfileInfo->ProfileName, p);
            PsAllocatePool(pProfileInfo->ProfileName.Buffer,
                           pProfileInfo->ProfileName.MaximumLength,
                           ProfileTag);

            if(!pProfileInfo->ProfileName.Buffer)
            {
                //
                // Again, cleanup of the other profils will be done when we clean up the ProfileList
                //

                PsDbgOut(DBG_CRITICAL_ERROR, DBG_INIT,
                         ("[ReadProfiles]: cannot allocate memory to hold profile's name \n"));

                break;
            }

            NdisZeroMemory(pProfileInfo->ProfileName.Buffer,
                           pProfileInfo->ProfileName.MaximumLength);
            RtlCopyUnicodeString(&pProfileInfo->ProfileName, &StringName);


            PsDbgOut(DBG_TRACE,
                     DBG_INIT,
                     ("[ReadProfiles]: Adding profile %ws \n",
                      pProfileInfo->ProfileName.Buffer));

            // The last scheduling component of every profile should
            // be a stub component. If this component is not present
            // in the profile, we have to add it manually.

            StubFlag = FALSE;
            cnt = 0;

            //
            // Each of the name identifies another value under
            // "Psched\Parameters". This value contains the list of
            // components that comprize the profile.
            //

            NdisReadConfiguration( &Status,
                                   &pProfileParam,
                                   ConfigHandle,
                                   &pProfileInfo->ProfileName,
                                   NdisParameterMultiString);
            if(NT_SUCCESS (Status))
            {
                // Read the components and associate with a
                // PSI_INFO.

                NDIS_STRING ComponentName;
                for (r = pProfileParam->ParameterData.StringData.Buffer, j=0;
                     *r != L'\0'; j++)
                {
                    PSI_INFO *PsiComponentInfo = 0;
                    RtlInitUnicodeString(&ComponentName, r);
                    PsDbgOut(DBG_TRACE, DBG_INIT,
                             ("[ReadProfiles]: Adding component %ws to "
                              "Profile %ws \n",
                              ComponentName.Buffer,
                              pProfileInfo->ProfileName.Buffer));

                    if(!StubFlag && (RtlCompareUnicodeString(&ComponentName,
                                                            &StubComponent,
                                                            FALSE)== 0))
                        StubFlag = TRUE;

                    if(cnt == MAX_COMPONENT_PER_PROFILE)
                    {
                        PsDbgOut(DBG_CRITICAL_ERROR,
                                 DBG_INIT,
                                 ("[ReadProfiles]: Profile %ws cannot have "
                                  "more than %d components \n",
                                  pProfileInfo->ProfileName.Buffer,
                                  MAX_COMPONENT_PER_PROFILE));
                    }
                    else
                    {
                        if(FindSchedulingComponent(&ComponentName, &PsiComponentInfo) ==
                           NDIS_STATUS_FAILURE)
                        {
                            //
                            // The component does not exist. Therefore, we
                            // store the unregistered component in the list
                            //

                            PsDbgOut(DBG_TRACE, DBG_INIT,
                                     ("[ReadProfiles]: Adding add-in component"
                                      " %ws to list\n", ComponentName.Buffer));

                            PsAllocatePool(PsiComponentInfo,
                                           sizeof(PSI_INFO),
                                           ComponentTag);

                            if(!PsiComponentInfo)
                            {
                                PsDbgOut(DBG_CRITICAL_ERROR, DBG_INIT,
                                         ("[ReadProfiles]: No memory to store add-in components \n"));

                                break;

                            }

                            pProfileInfo->UnregisteredAddInCnt ++;

                            NdisZeroMemory(PsiComponentInfo, sizeof(PSI_INFO));

                            RtlInitUnicodeString(&PsiComponentInfo->ComponentName, r);

                            PsAllocatePool(
                                PsiComponentInfo->ComponentName.Buffer,
                                ComponentName.MaximumLength,
                                ComponentTag);

                            if(!PsiComponentInfo->ComponentName.Buffer)
                            {
                                PsDbgOut(DBG_CRITICAL_ERROR, DBG_INIT,
                                         ("[ReadProfiles]: No memory to store add-in components \n"));

                                PsFreePool(PsiComponentInfo);

                                break;
                            }

                            RtlCopyUnicodeString(&PsiComponentInfo->ComponentName,
                                                 &ComponentName);

                            PsiComponentInfo->Registered = FALSE;

                            PsiComponentInfo->AddIn = TRUE;

                            InsertHeadList(&PsComponentList, &PsiComponentInfo->Links );
                        }

                        // Add the component to the profile.
                        pProfileInfo->ComponentList[cnt++]=PsiComponentInfo;

                        pProfileInfo->ComponentCnt = cnt;
                    }
                    r = (PWSTR)((PUCHAR)r + ComponentName.Length +
                                sizeof(WCHAR));
                }
            }

            if(!StubFlag)
            {
                PsDbgOut(DBG_INFO, DBG_INIT,
                         ("[ReadProfiles]: Profile %ws should end in a stub "
                          "component. Adding a stub component \n",
                          pProfileInfo->ProfileName.Buffer));

                // Needn't worry about overflow, as we have allocated an
                // extra one for the stub component.

                pProfileInfo->ComponentList[cnt++] = &SchedulerStubInfo;
                pProfileInfo->ComponentCnt = cnt;
            }
            p = (PWSTR)((PUCHAR)p + pProfileInfo->ProfileName.Length
                        + sizeof(WCHAR));
        }
    }
}


NDIS_STATUS
PsReadDriverRegistryDataInit (
    )
/*++

Routine Description:

    This routine is called by the driver to get information from the configuration
    management routines. We read the registry, starting at RegistryPath,
    to get the parameters. If they don't exist, we use the defaults in this module.

Arguments:

    RegistryPath - The name of the driver's node in the registry.

    ConfigurationInfo - A pointer to the configuration information structure.

Return Value:

    Status - STATUS_SUCCESS if everything OK, STATUS_INSUFFICIENT_RESOURCES
            otherwise.

--*/
{
    NDIS_HANDLE  ConfigHandle;
    NDIS_STATUS  Status;
    NDIS_STRING  PSParamsKey        = NDIS_STRING_CONST("PSched\\Parameters");
#if DBG
    ULONG        Size;
    NTSTATUS     NtStatus;

    NDIS_STRING DebugLevelKey       = NDIS_STRING_CONST("DebugLevel");
    NDIS_STRING DebugMaskKey        = NDIS_STRING_CONST("DebugMask");
    NDIS_STRING TraceLogLevelKey    = NDIS_STRING_CONST("TraceLogLevel");
    NDIS_STRING TraceLogMaskKey     = NDIS_STRING_CONST("TraceLogMask");
    NDIS_STRING TraceBufferSizeKey  = NDIS_STRING_CONST("TraceBufferSize");
#endif

    NdisOpenProtocolConfiguration(&Status, &ConfigHandle, &PSParamsKey);

    if(!NT_SUCCESS(Status))
    {
        PsDbgOut(DBG_CRITICAL_ERROR, DBG_INIT,
                 ("[PsReadDriverRegistryDataInit]: cannot read registry \n"));

        return Status;
    }

#if DBG

    PsReadRegistryInt(
        ConfigHandle,
        &DebugLevelKey,
        0,
        &DbgTraceLevel,
        0,
        0xffffffff,
        FALSE,
        NULL,
        NULL,
        FALSE);

    PsReadRegistryInt(
        ConfigHandle,
        &DebugMaskKey,
        0,
        &DbgTraceMask,
        0,
        0xffffffff,
        FALSE,
        NULL,
        NULL,
        FALSE);

    PsReadRegistryInt(
        ConfigHandle,
        &TraceLogLevelKey,
        DBG_VERBOSE,
        &LogTraceLevel,
        0,
        0xffffffff,
        FALSE,
        NULL,
        NULL,
        FALSE);

    PsReadRegistryInt(
        ConfigHandle,
        &TraceLogMaskKey,
        (DBG_INIT  |  DBG_IO  |  DBG_GPC_QOS  | DBG_MINIPORT | DBG_PROTOCOL | 
         DBG_VC    |  DBG_WMI |  DBG_STATE    | DBG_WAN),
        &LogTraceMask,
        0,
        0xffffffff,
        FALSE,
        NULL,
        NULL,
        FALSE);

    PsReadRegistryInt(
        ConfigHandle,
        &TraceBufferSizeKey,
        TRACE_BUFFER_SIZE,
        &Size,
        0,
        0xffffffff,
        FALSE,
        NULL,
        NULL,
        FALSE);

    SchedInitialize(Size);
#endif

    ReadProfiles(ConfigHandle);

    NdisCloseConfiguration( ConfigHandle );

    return STATUS_SUCCESS;
}


NDIS_STATUS
PsReadDriverRegistryData(
    )
{
    ULONG                  TimerResolution;
    ULONG                  desiredResolution;
    NDIS_STRING            PSParamsKey        = NDIS_STRING_CONST("PSched\\Parameters");
    NDIS_STRING            TimerResolutionKey = NDIS_STRING_CONST("TimerResolution");
    NTSTATUS               NtStatus;
    NDIS_HANDLE            ConfigHandle;
    NDIS_STATUS            Status;

    NdisOpenProtocolConfiguration(&Status, &ConfigHandle, &PSParamsKey);

    if(!NT_SUCCESS(Status))
    {
        PsDbgOut(DBG_CRITICAL_ERROR, DBG_INIT,
                 ("[PsReadDriverRegistryData]: cannot read registry \n"));

        return Status;
    }

    NtStatus = PsReadRegistryInt(
        ConfigHandle,
        &TimerResolutionKey,
        TIMER_GRANULARITY,
        &TimerResolution,
        0,
        0xffffffff,
        FALSE,
        NULL,
        NULL,
        TRUE);

    NdisCloseConfiguration(ConfigHandle);

    if(NT_SUCCESS(NtStatus))
    {
        //
        // convert from usecs to 100 nsecs
        //
        TimerResolution *= 10;
       
        if(gTimerSet)
        {
            //
            // We might have to cancel the old timer.
            //

            if(gTimerResolutionActualTime < TimerResolution)
            {
                // 
                // We are moving from a low timer to a high timer. We should always set the high 
                // timer before resetting the low one.
                //
                gTimerResolutionActualTime = ExSetTimerResolution(TimerResolution, TRUE);

                ExSetTimerResolution(0, FALSE);
            }
            else 
            {
                // 
                // Moving from a high timer to a low timer. Let's cancel the high timer first
                //
                ExSetTimerResolution(0, FALSE);

                gTimerResolutionActualTime = ExSetTimerResolution(TimerResolution, TRUE);
            }
        }
        else
        {
            // The Timer has never been set before.

            gTimerResolutionActualTime = ExSetTimerResolution(TimerResolution, TRUE);
            
            gTimerSet = 1;

        }
                
    }
    else 
    {
        // No value was specified in the registry. Let's just keep it at the system's default.
        // But, we need to query this value so that we can respond correctly to OID_QOS_TIMER_RESOLUTION
        //
        if(gTimerSet)
        {
            //
            // Timer was set initially, but now it has been blown away. So, let's get back to the 
            // system default.
            //
            gTimerSet = 0;

            gTimerResolutionActualTime = ExSetTimerResolution(0, FALSE);
        }
        else 
        {
            //
            // Timer has never been set. Let's remember the system defaults.
            //

            gTimerResolutionActualTime = KeQueryTimeIncrement();
        }

    }

    return STATUS_SUCCESS;
}


NDIS_STATUS
PsReadAdapterRegistryDataInit(PADAPTER     Adapter,
                              PNDIS_STRING AdapterKey
                              )
{
    ULONG       DisableDRR, IntermediateSystem;
    NTSTATUS    NtStatus;
    NDIS_HANDLE ConfigHandle, ServiceKeyHandle;
    NDIS_STRING DisableDRRKey          = NDIS_STRING_CONST("DisableDRR");
    NDIS_STRING IntermediateSystemKey  = NDIS_STRING_CONST("IntermediateSystem");
    NDIS_STRING BestEffortLimitKey     = NDIS_STRING_CONST("BestEffortLimit");
    NDIS_STRING ISSLOWTokenRateKey     = NDIS_STRING_CONST("ISSLOWTokenRate");
    NDIS_STRING ISSLOWPacketSizeKey    = NDIS_STRING_CONST("ISSLOWPacketSize");
    NDIS_STRING ISSLOWLinkSpeedKey     = NDIS_STRING_CONST("ISSLOWLinkSpeed");
    NDIS_STRING ISSLOWFragmentSizeKey  = NDIS_STRING_CONST("ISSLOWFragmentSize");
    NDIS_STRING BestEffortKey          = NDIS_STRING_CONST("ServiceTypeBestEffort");
    NDIS_STRING NonConformingKey       = NDIS_STRING_CONST("ServiceTypeNonConforming");
    NDIS_STRING ControlledLoadKey      = NDIS_STRING_CONST("ServiceTypeControlledLoad");
    NDIS_STRING GuaranteedKey          = NDIS_STRING_CONST("ServiceTypeGuaranteed");
    NDIS_STRING QualitativeKey         = NDIS_STRING_CONST("ServiceTypeQualitative");
    NDIS_STRING NetworkControlKey      = NDIS_STRING_CONST("ServiceTypeNetworkControl");
    NDIS_STRING ShapeDiscardModeKey    = NDIS_STRING_CONST("ShapeDiscardMode");
    NDIS_STRING UpperBindingsKey       = NDIS_STRING_CONST("UpperBindings");
    NDIS_STRING ProfileKey             = NDIS_STRING_CONST("Profile");
    NDIS_STATUS Status;

    PAGED_CODE();

    NdisOpenProtocolConfiguration(&Status, &ConfigHandle, AdapterKey);

    if(Status != NDIS_STATUS_SUCCESS)
    {
        PsDbgOut(DBG_FAILURE, DBG_INIT ,
                 ("[PsReadAdapterRegistryDataInit]: Adapter %08X, Could not open config handle \n", 
                  Adapter));

        return Status;
    }


    PsReadRegistryString(
        ConfigHandle,
        &UpperBindingsKey,
        &Adapter->UpperBinding);

    if(!Adapter->UpperBinding.Buffer)
    {
        PsAdapterWriteEventLog(
            (ULONG)EVENT_PS_MISSING_ADAPTER_REGISTRY_DATA,
            0,
            &Adapter->MpDeviceName,
            0,
            NULL);
        
        PsDbgOut(DBG_FAILURE, DBG_PROTOCOL | DBG_INIT,
                 ("[PsReadAdapterRegistryDataInit]: Adapter %08X: Missing UpperBindings key ", Adapter));

        NdisCloseConfiguration(ConfigHandle);
        
        return  NDIS_STATUS_FAILURE;
    }

    PsReadRegistryString(
        ConfigHandle,
        &ProfileKey,
        &Adapter->ProfileName);


    PsReadRegistryInt(
        ConfigHandle,
        &DisableDRRKey,
        0,
        &DisableDRR,
        0,
        0xffffffff,
        FALSE,
        NULL, 
        NULL,
        FALSE);

    PsReadRegistryInt(
        ConfigHandle,
        &IntermediateSystemKey,
        0,
        &IntermediateSystem,
        0,
        0xffffffff,
        FALSE,
        NULL, 
        NULL,
        FALSE);

    PsReadRegistryInt(
        ConfigHandle,
        &BestEffortLimitKey,
        UNSPECIFIED_RATE,
        &Adapter->BestEffortLimit,
        0,
        0xffffffff,
        FALSE,
        NULL, 
        NULL,
        FALSE);

    //
    // Read the ISSLOW related parameters.
    //

    PsReadRegistryInt(
        ConfigHandle,
        &ISSLOWFragmentSizeKey,
        DEFAULT_ISSLOW_FRAGMENT_SIZE,
        &Adapter->ISSLOWFragmentSize,
        0,
        0xffffffff,
        FALSE,
        NULL, 
        NULL,
        FALSE);

    PsReadRegistryInt(
        ConfigHandle,
        &ISSLOWTokenRateKey,
        DEFAULT_ISSLOW_TOKENRATE,
        &Adapter->ISSLOWTokenRate,
        0,
        0xffffffff,
        FALSE,
        NULL, 
        NULL,
        FALSE);

    PsReadRegistryInt(
        ConfigHandle,
        &ISSLOWPacketSizeKey,
        DEFAULT_ISSLOW_PACKETSIZE,
        &Adapter->ISSLOWPacketSize,
        0,
        0xffffffff,
        FALSE,
        NULL, 
        NULL,
        FALSE);

    PsReadRegistryInt(
        ConfigHandle,
        &ISSLOWLinkSpeedKey,
        DEFAULT_ISSLOW_LINKSPEED,
        &Adapter->ISSLOWLinkSpeed,
        0,
        0xffffffff,
        FALSE,
        NULL, 
        NULL,
        FALSE);

    //
    // Read the ShapeDiscardMode for the service types.
    //

    NdisOpenConfigurationKeyByName(&Status,
                                   ConfigHandle,
                                   &ShapeDiscardModeKey,
                                   &ServiceKeyHandle);

    if(!NT_SUCCESS(Status))
    {
        PsDbgOut(DBG_FAILURE, DBG_PROTOCOL | DBG_INIT,
                 ("[PsReadAdapterRegistryDataInit]: Adapter %08X, Using defaults for ShapeDiscardMode"
                  "since key cannot be opened \n", Adapter));

        Adapter->SDModeGuaranteed      = TC_NONCONF_SHAPE;
        Adapter->SDModeControlledLoad  = TC_NONCONF_BORROW;
        Adapter->SDModeQualitative     = TC_NONCONF_BORROW;
        Adapter->SDModeNetworkControl  = TC_NONCONF_BORROW;

    }
    else 
    {

        PsReadRegistryInt(
            ConfigHandle,
            &GuaranteedKey,
            TC_NONCONF_SHAPE,
            &Adapter->SDModeGuaranteed,
            TC_NONCONF_BORROW,
            TC_NONCONF_BORROW_PLUS,
            TRUE,
            &ShapeDiscardModeKey, 
            ServiceKeyHandle,
            FALSE);
    
        PsReadRegistryInt(
            ConfigHandle,
            &ControlledLoadKey,
            TC_NONCONF_BORROW,
            &Adapter->SDModeControlledLoad,
            TC_NONCONF_BORROW,
            TC_NONCONF_BORROW_PLUS,
            TRUE,
            &ShapeDiscardModeKey, 
            ServiceKeyHandle,
            FALSE);
    
        PsReadRegistryInt(
            ConfigHandle,
            &QualitativeKey,
            TC_NONCONF_BORROW,
            &Adapter->SDModeQualitative,
            TC_NONCONF_BORROW,
            TC_NONCONF_BORROW_PLUS,
            TRUE,
            &ShapeDiscardModeKey, 
            ServiceKeyHandle,
            FALSE);

        PsReadRegistryInt(
            ConfigHandle,
            &NetworkControlKey,
            TC_NONCONF_BORROW,
            &Adapter->SDModeNetworkControl,
            TC_NONCONF_BORROW,
            TC_NONCONF_BORROW_PLUS,
            TRUE,
            &ShapeDiscardModeKey, 
            ServiceKeyHandle,
            FALSE);

        NdisCloseConfiguration(ServiceKeyHandle);
    }

    NdisCloseConfiguration(ConfigHandle);
        
    if(DisableDRR)
    {
        Adapter->PipeFlags |= PS_DISABLE_DRR;
    }

    if(IntermediateSystem)
    {
        Adapter->PipeFlags |= PS_INTERMEDIATE_SYS;
    }

    return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
PsReadAdapterRegistryData(PADAPTER     Adapter,
                         PNDIS_STRING MachineKey,
                         PNDIS_STRING AdapterKey)

/*++

Routine Description:

    Obtain the PSched specific info associated with the underlying MP.

Arguments:

    AdapterKey   - location of the per adapter key in the registry
    MachineKey   - location of the per Machine key in the registry
    Adapter      - pointer to the adapter structure

Return Value:

    NDIS_STATUS_SUCCESS if everything worked ok

--*/

{
    NDIS_STRING BestEffortKey          = NDIS_STRING_CONST("ServiceTypeBestEffort");
    NDIS_STRING NonConformingKey       = NDIS_STRING_CONST("ServiceTypeNonConforming");
    NDIS_STRING ControlledLoadKey      = NDIS_STRING_CONST("ServiceTypeControlledLoad");
    NDIS_STRING GuaranteedKey          = NDIS_STRING_CONST("ServiceTypeGuaranteed");
    NDIS_STRING QualitativeKey         = NDIS_STRING_CONST("ServiceTypeQualitative");
    NDIS_STRING NetworkControlKey      = NDIS_STRING_CONST("ServiceTypeNetworkControl");
    NDIS_STRING TcpTrafficKey          = NDIS_STRING_CONST("ServiceTypeTcpTraffic");
    NDIS_STRING MaxOutstandingSendsKey = NDIS_STRING_CONST("MaxOutstandingSends");
    NDIS_STRING NonBestEffortLimitKey  = NDIS_STRING_CONST("NonBestEffortLimit");
    NDIS_STRING DiffservKeyC           = NDIS_STRING_CONST("DiffservByteMappingConforming");
    NDIS_STRING DiffservKeyNC          = NDIS_STRING_CONST("DiffservByteMappingNonConforming");
    NDIS_STRING UserKey                = NDIS_STRING_CONST("UserPriorityMapping");
    NDIS_STATUS Status;
    NDIS_HANDLE SubKeyHandle, ConfigHandle;
    ULONG       Value;

    PAGED_CODE();

    PsDbgOut(DBG_INFO, DBG_INIT | DBG_ZAW,
             ("\n [PsReadAdapterRegistryData]: Adapter %08X (%ws): Reading Registry Data \n", 
              Adapter, Adapter->RegistryPath.Buffer));

    NdisOpenProtocolConfiguration(&Status, &ConfigHandle, &Adapter->RegistryPath);

    if(Status != NDIS_STATUS_SUCCESS)
    {
        PsDbgOut(DBG_FAILURE, DBG_INIT | DBG_ZAW,
                 ("[PsReadAdapterRegistryData]: Adapter %08X, Could not open config handle \n", 
                  Adapter));

        return Status;
    }
    
    PsReadRegistryInt(ConfigHandle,
                        &MaxOutstandingSendsKey,
                        DEFAULT_MAX_OUTSTANDING_SENDS,
                        &Adapter->MaxOutstandingSends,
                        1,
                        0xffffffff,
                        FALSE,
                        NULL,
                        NULL,
                        TRUE);

    PsReadRegistryInt(ConfigHandle,
                        &NonBestEffortLimitKey,
                        RESERVABLE_FRACTION,
                        &Adapter->ReservationLimitValue,
                        0,
                        200,
                        FALSE,
                        NULL,
                        NULL,
                        TRUE);

    //
    // Read the conforming values of DiffservByteMapping.
    //

    NdisOpenConfigurationKeyByName(&Status,
                                   ConfigHandle,
                                   &DiffservKeyC,
                                   &SubKeyHandle);

    if(!NT_SUCCESS(Status))
    {
        PsDbgOut(DBG_FAILURE, DBG_PROTOCOL | DBG_INIT,
                 ("[PsReadAdapterRegistryData]: Adapter %08X, Using defaults for "
                  "DiffservByteMappingConforming since key cannot be opened \n", Adapter));

        Adapter->IPServiceTypeBestEffort       = PS_IP_SERVICETYPE_CONFORMING_BESTEFFORT_DEFAULT;
        Adapter->IPServiceTypeControlledLoad   = PS_IP_SERVICETYPE_CONFORMING_CONTROLLEDLOAD_DEFAULT;
        Adapter->IPServiceTypeGuaranteed       = PS_IP_SERVICETYPE_CONFORMING_GUARANTEED_DEFAULT;
        Adapter->IPServiceTypeQualitative      = PS_IP_SERVICETYPE_CONFORMING_QUALITATIVE_DEFAULT;
        Adapter->IPServiceTypeNetworkControl   = PS_IP_SERVICETYPE_CONFORMING_NETWORK_CONTROL_DEFAULT;
        Adapter->IPServiceTypeTcpTraffic       = PS_IP_SERVICETYPE_CONFORMING_TCPTRAFFIC_DEFAULT;
    }
    else 
    {
        PsReadRegistryInt(ConfigHandle,
                          &TcpTrafficKey,
                          PS_IP_SERVICETYPE_CONFORMING_TCPTRAFFIC_DEFAULT,
                          &Value,
                          0,
                          PREC_MAX_VALUE,
                          TRUE,
                          &DiffservKeyC,
                          SubKeyHandle,
                          TRUE);

        Adapter->IPServiceTypeTcpTraffic = (UCHAR)Value;

        PsReadRegistryInt(ConfigHandle,
                          &BestEffortKey,
                          PS_IP_SERVICETYPE_CONFORMING_BESTEFFORT_DEFAULT,
                          &Value,
                          0,
                          PREC_MAX_VALUE,
                          TRUE,
                          &DiffservKeyC,
                          SubKeyHandle,
                          TRUE);
        
        Adapter->IPServiceTypeBestEffort = (UCHAR)Value;
        
        PsReadRegistryInt(ConfigHandle,
                          &ControlledLoadKey,
                          PS_IP_SERVICETYPE_CONFORMING_CONTROLLEDLOAD_DEFAULT,
                          &Value,
                          0,
                          PREC_MAX_VALUE,
                          TRUE,
                          &DiffservKeyC,
                          SubKeyHandle,
                          TRUE);
        
        Adapter->IPServiceTypeControlledLoad = (UCHAR)Value;
        
        PsReadRegistryInt(ConfigHandle,
                          &GuaranteedKey,
                          PS_IP_SERVICETYPE_CONFORMING_GUARANTEED_DEFAULT,
                          &Value,
                          0,
                          PREC_MAX_VALUE,
                          TRUE,
                          &DiffservKeyC,
                          SubKeyHandle,
                          TRUE);
        
        Adapter->IPServiceTypeGuaranteed = (UCHAR)Value;
        
        PsReadRegistryInt(ConfigHandle,
                          &QualitativeKey,
                          PS_IP_SERVICETYPE_CONFORMING_QUALITATIVE_DEFAULT,
                          &Value,
                          0,
                          PREC_MAX_VALUE,
                          TRUE,
                          &DiffservKeyC,
                          SubKeyHandle,
                          TRUE);
        
        Adapter->IPServiceTypeQualitative    = (UCHAR)Value;
        
        PsReadRegistryInt(ConfigHandle,
                          &NetworkControlKey,
                          PS_IP_SERVICETYPE_CONFORMING_NETWORK_CONTROL_DEFAULT,
                          &Value,
                          0,
                          PREC_MAX_VALUE,
                          TRUE,
                          &DiffservKeyC,
                          SubKeyHandle,
                          TRUE);
        
        Adapter->IPServiceTypeNetworkControl = (UCHAR)Value;
        
        NdisCloseConfiguration(SubKeyHandle);
    }
        
    //
    // Read the non-conforming values of DiffservByteMapping.
    //

    NdisOpenConfigurationKeyByName(&Status,
                                   ConfigHandle,
                                   &DiffservKeyNC,
                                   &SubKeyHandle);

    if(!NT_SUCCESS(Status))
    {
        PsDbgOut(DBG_FAILURE, DBG_PROTOCOL | DBG_INIT,
                 ("[PsReadAdapterRegistryData]: Adapter %08X, Using defaults for "
                  "DiffservByteMappingNonConforming since key cannot be opened \n", Adapter));

        Adapter->IPServiceTypeBestEffortNC     = PS_IP_SERVICETYPE_NONCONFORMING_BESTEFFORT_DEFAULT;
        Adapter->IPServiceTypeControlledLoadNC = PS_IP_SERVICETYPE_NONCONFORMING_CONTROLLEDLOAD_DEFAULT;
        Adapter->IPServiceTypeGuaranteedNC     = PS_IP_SERVICETYPE_NONCONFORMING_GUARANTEED_DEFAULT;
        Adapter->IPServiceTypeQualitativeNC    = PS_IP_SERVICETYPE_NONCONFORMING_QUALITATIVE_DEFAULT;
        Adapter->IPServiceTypeNetworkControlNC = PS_IP_SERVICETYPE_NONCONFORMING_BESTEFFORT_DEFAULT;
        Adapter->IPServiceTypeTcpTrafficNC     = PS_IP_SERVICETYPE_NONCONFORMING_TCPTRAFFIC_DEFAULT;
    }
    else
    {
        PsReadRegistryInt(ConfigHandle,
                          &TcpTrafficKey,
                          PS_IP_SERVICETYPE_NONCONFORMING_TCPTRAFFIC_DEFAULT,
                          &Value,
                          0,
                          PREC_MAX_VALUE,
                          TRUE,
                          &DiffservKeyNC,
                          SubKeyHandle,
                          TRUE);

        Adapter->IPServiceTypeTcpTrafficNC = (UCHAR)Value;

        PsReadRegistryInt(ConfigHandle,
                          &BestEffortKey,
                          PS_IP_SERVICETYPE_NONCONFORMING_BESTEFFORT_DEFAULT,
                          &Value,
                          0,
                          PREC_MAX_VALUE,
                          TRUE,
                          &DiffservKeyNC,
                          SubKeyHandle,
                          TRUE);

        Adapter->IPServiceTypeBestEffortNC = (UCHAR)Value;

        PsReadRegistryInt(ConfigHandle,
                          &ControlledLoadKey,
                          PS_IP_SERVICETYPE_NONCONFORMING_CONTROLLEDLOAD_DEFAULT,
                          &Value,
                          0,
                          PREC_MAX_VALUE,
                          TRUE,
                          &DiffservKeyNC,
                          SubKeyHandle,
                          TRUE);
        
        Adapter->IPServiceTypeControlledLoadNC = (UCHAR)Value;
        
        PsReadRegistryInt(ConfigHandle,
                          &GuaranteedKey,
                          PS_IP_SERVICETYPE_NONCONFORMING_GUARANTEED_DEFAULT,
                          &Value,
                          0,
                          PREC_MAX_VALUE,
                          TRUE,
                          &DiffservKeyNC,
                          SubKeyHandle,
                          TRUE);

        Adapter->IPServiceTypeGuaranteedNC = (UCHAR)Value;

        PsReadRegistryInt(ConfigHandle,
                          &QualitativeKey,
                          PS_IP_SERVICETYPE_NONCONFORMING_QUALITATIVE_DEFAULT,
                          &Value,
                          0,
                          PREC_MAX_VALUE,
                          TRUE,
                          &DiffservKeyNC,
                          SubKeyHandle,
                          TRUE);
        
        Adapter->IPServiceTypeQualitativeNC    = (UCHAR)Value;
                        
        PsReadRegistryInt(ConfigHandle,
                          &NetworkControlKey,
                          PS_IP_SERVICETYPE_NONCONFORMING_NETWORK_CONTROL_DEFAULT,
                          &Value,
                          0,
                          PREC_MAX_VALUE,
                          TRUE,
                          &DiffservKeyNC,
                          SubKeyHandle,
                          TRUE);
        
        Adapter->IPServiceTypeNetworkControlNC = (UCHAR)Value;
        
        NdisCloseConfiguration(SubKeyHandle);
    }

    //
    // Read the 802.1p values. The nonconforming in 802.1p does not depend on the 
    // service type. 
    //

    NdisOpenConfigurationKeyByName(&Status,
                                   ConfigHandle,
                                   &UserKey,
                                   &SubKeyHandle);

    if(!NT_SUCCESS(Status))
    {
        PsDbgOut(DBG_FAILURE, DBG_PROTOCOL | DBG_INIT,
                 ("[PsReadAdapterRegistryData]: Adapter %08X, Using defaults for "
                  "UserPriorityMapping since key cannot be opened \n", Adapter));
        Adapter->UserServiceTypeBestEffort       = PS_USER_SERVICETYPE_BESTEFFORT_DEFAULT;
        Adapter->UserServiceTypeControlledLoad   = PS_USER_SERVICETYPE_CONTROLLEDLOAD_DEFAULT;
        Adapter->UserServiceTypeGuaranteed       = PS_USER_SERVICETYPE_GUARANTEED_DEFAULT;
        Adapter->UserServiceTypeQualitative      = PS_USER_SERVICETYPE_QUALITATIVE_DEFAULT;
        Adapter->UserServiceTypeNetworkControl   = PS_USER_SERVICETYPE_NETWORK_CONTROL_DEFAULT;
        Adapter->UserServiceTypeNonConforming    = PS_USER_SERVICETYPE_NONCONFORMING_DEFAULT;
        Adapter->UserServiceTypeTcpTraffic       = PS_USER_SERVICETYPE_TCPTRAFFIC_DEFAULT;
    }
    else 
    {
        PsReadRegistryInt(ConfigHandle,
                            &TcpTrafficKey,
                            PS_USER_SERVICETYPE_TCPTRAFFIC_DEFAULT,
                            &Value,
                            0,
                            USER_PRIORITY_MAX_VALUE,
                            TRUE,
                            &UserKey,
                            SubKeyHandle,
                            TRUE);

        Adapter->UserServiceTypeTcpTraffic = (UCHAR)Value;

        PsReadRegistryInt(ConfigHandle,
                            &BestEffortKey,
                            PS_USER_SERVICETYPE_BESTEFFORT_DEFAULT,
                            &Value,
                            0,
                            USER_PRIORITY_MAX_VALUE,
                            TRUE,
                            &UserKey,
                            SubKeyHandle,
                            TRUE);

        Adapter->UserServiceTypeBestEffort = (UCHAR)Value;

        PsReadRegistryInt(ConfigHandle,
                            &ControlledLoadKey,
                            PS_USER_SERVICETYPE_CONTROLLEDLOAD_DEFAULT,
                            &Value,
                            0,
                            USER_PRIORITY_MAX_VALUE,
                            TRUE,
                            &UserKey,
                            SubKeyHandle,
                            TRUE);

        Adapter->UserServiceTypeControlledLoad = (UCHAR)Value;
                        
        PsReadRegistryInt(ConfigHandle,
                            &GuaranteedKey,
                            PS_USER_SERVICETYPE_GUARANTEED_DEFAULT,
                            &Value,
                            0,
                            USER_PRIORITY_MAX_VALUE,
                            TRUE,
                            &UserKey,
                            SubKeyHandle,
                            TRUE);

        Adapter->UserServiceTypeGuaranteed = (UCHAR)Value;
                        
        PsReadRegistryInt(ConfigHandle,
                            &QualitativeKey,
                            PS_USER_SERVICETYPE_QUALITATIVE_DEFAULT,
                            &Value,
                            0,
                            USER_PRIORITY_MAX_VALUE,
                            TRUE,
                            &UserKey,
                            SubKeyHandle,
                            TRUE);

        Adapter->UserServiceTypeQualitative    = (UCHAR)Value;
                        
        PsReadRegistryInt(ConfigHandle,
                            &NonConformingKey,
                            PS_USER_SERVICETYPE_NONCONFORMING_DEFAULT,
                            &Value,
                            0,
                            USER_PRIORITY_MAX_VALUE,
                            TRUE,
                            &UserKey,
                            SubKeyHandle,
                            TRUE);

        Adapter->UserServiceTypeNonConforming  = (UCHAR)Value;
                        
        PsReadRegistryInt(ConfigHandle,
                            &NetworkControlKey,
                            PS_USER_SERVICETYPE_NETWORK_CONTROL_DEFAULT,
                            &Value,
                            0,
                            USER_PRIORITY_MAX_VALUE,
                            TRUE,
                            &UserKey,
                            SubKeyHandle,
                            TRUE);

        Adapter->UserServiceTypeNetworkControl = (UCHAR)Value;

        NdisCloseConfiguration(SubKeyHandle);
    }
                        
    //
    // Now, we need to take this number, swap the bits around and put it in the higher order bits.
    // The DSCP codepoint is as follows:
    //
    //      --------------------------------
    // Bits | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
    //      --------------------------------
    //      |           DSCP        |  CU   |
    //      --------------------------------
    //
    // Where DSCP - Differentiated services code point
    //         CU - Currently unused.
    //
    Adapter->IPServiceTypeBestEffort       = Adapter->IPServiceTypeBestEffort       << 2;
    Adapter->IPServiceTypeControlledLoad   = Adapter->IPServiceTypeControlledLoad   << 2;
    Adapter->IPServiceTypeGuaranteed       = Adapter->IPServiceTypeGuaranteed       << 2; 
    Adapter->IPServiceTypeQualitative      = Adapter->IPServiceTypeQualitative      << 2;
    Adapter->IPServiceTypeNetworkControl   = Adapter->IPServiceTypeNetworkControl   << 2;
    Adapter->IPServiceTypeBestEffortNC     = Adapter->IPServiceTypeBestEffortNC     << 2;
    Adapter->IPServiceTypeControlledLoadNC = Adapter->IPServiceTypeControlledLoadNC << 2;
    Adapter->IPServiceTypeGuaranteedNC     = Adapter->IPServiceTypeGuaranteedNC     << 2; 
    Adapter->IPServiceTypeQualitativeNC    = Adapter->IPServiceTypeQualitativeNC    << 2;
    Adapter->IPServiceTypeNetworkControlNC = Adapter->IPServiceTypeNetworkControlNC << 2;
    Adapter->IPServiceTypeTcpTraffic       = Adapter->IPServiceTypeTcpTraffic       << 2;
    Adapter->IPServiceTypeTcpTrafficNC     = Adapter->IPServiceTypeTcpTrafficNC     << 2;

    NdisCloseConfiguration(ConfigHandle);

    return NDIS_STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\adapter.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    adapter.h

Abstract:

    defines for adapter binding/unbinding routines

Author:

    Charlie Wickham (charlwi) 24-Apr-1996

Environment:

    Kernel Mode

Revision History:

--*/

/* External */

/* Static */

/* Prototypes */ 

//
// Protocol functions
//

VOID
CleanUpAdapter(
    IN      PADAPTER     Adapter);

VOID
ClBindToLowerMp(
    OUT     PNDIS_STATUS Status,
    IN      NDIS_HANDLE  BindContext,
    IN      PNDIS_STRING MpDeviceName,
    IN      PVOID        SystemSpecific1,
    IN      PVOID        SystemSpecific2
        );

VOID
ClLowerMpCloseAdapterComplete(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS Status
    );

VOID
ClLowerMpOpenAdapterComplete(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS Status,
    IN  NDIS_STATUS OpenErrorStatus
    );

VOID
ClUnbindFromLowerMp(
    OUT PNDIS_STATUS Status,
    IN  NDIS_HANDLE  ProtocolBindingContext,
    IN  NDIS_HANDLE  UnbindContext
    );

NDIS_STATUS
MpInitialize(
        OUT PNDIS_STATUS OpenErrorStatus,
        OUT PUINT        SelectedMediumIndex,
        IN  PNDIS_MEDIUM MediumArray,
        IN  UINT         MediumArraySize,
        IN  NDIS_HANDLE  MiniportAdapterHandle,
        IN  NDIS_HANDLE  WrapperConfigurationContext
        );

PADAPTER
FindAdapterByWmiInstanceName(
    USHORT   StringLength,
    PWSTR    StringStart,
    PPS_WAN_LINK *WanLink
    );


VOID
DerefAdapter(
    PADAPTER Adapter,
    BOOLEAN  AdapterListLocked);

VOID
CleanupAdapter(
    PADAPTER Adapter
    );


VOID
ClUnloadProtocol(
    VOID
    );

VOID
MpHalt(
        IN      NDIS_HANDLE                             MiniportAdapterContext
        );

NDIS_STATUS
MpReset(
        OUT PBOOLEAN                            AddressingReset,
        IN      NDIS_HANDLE                             MiniportAdapterContext
        );

NDIS_STATUS
UpdateSchedulingPipe(
    PADAPTER Adapter
    );

NDIS_STATUS
UpdateWanSchedulingPipe(PPS_WAN_LINK WanLink);

HANDLE
GetNdisPipeHandle (
    IN HANDLE PsPipeContext
    );

NDIS_STATUS
UpdateAdapterBandwidthParameters(
    PADAPTER Adapter
    );

NDIS_STATUS
FindSchedulingComponent(
    PNDIS_STRING ComponentName,
    PPSI_INFO *Component
    );

VOID 
PsAdapterWriteEventLog(
	IN	NDIS_STATUS	 EventCode,
	IN	ULONG		 UniqueEventValue,
	IN  PNDIS_STRING String,
	IN	ULONG		 DataSize,
	IN	PVOID		 Data		OPTIONAL
    );

VOID
PsGetLinkSpeed(
    IN PADAPTER Adapter
);

VOID
PsUpdateLinkSpeed(
    PADAPTER      Adapter,
    ULONG         RawLinkSpeed,
    PULONG        RemainingBandWidth,
    PULONG        LinkSpeed,
    PULONG        NonBestEffortLimit,
    PPS_SPIN_LOCK Lock
);



/* End Prototypes */

/* end adapter.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\cmvc.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    cmvc.h

Abstract:


Author:

    Rajesh Sundaram (rajeshsu), 1st Aug 1998.

Revision History:

--*/

#ifndef _CMVC_
#define _CMVC_

/* Prototypes */

NDIS_STATUS
CreateBestEffortVc(
    PADAPTER Adapter, 
    PGPC_CLIENT_VC Vc, 
    PPS_WAN_LINK WanLink);

NDIS_STATUS
CmCreateVc(
    PGPC_CLIENT_VC *Vc, 
    PADAPTER Adapter,
    PPS_WAN_LINK WanLink,
    PCO_CALL_PARAMETERS CallParams, 
    GPC_HANDLE GpcCfInfoHandle, 
    PCF_INFO_QOS CfInfoPtr,
    GPC_CLIENT_HANDLE ClientContext);

NDIS_STATUS
CmMakeCall(
    IN  PGPC_CLIENT_VC Vc);

NDIS_STATUS
CmModifyCall(
    IN  PGPC_CLIENT_VC Vc);

NDIS_STATUS
CmCloseCall(
    IN  PGPC_CLIENT_VC Vc);

NDIS_STATUS
CmDeleteVc(
    IN  NDIS_HANDLE ProtocolVcContext
    );

VOID
FillInCmParams(
    PCO_CALL_MANAGER_PARAMETERS CmParams,
    SERVICETYPE                 ServiceType,
    ULONG                       TokenRate,
    ULONG                       PeakBandwidth,
    ULONG                       TokenBucketSize,
    ULONG                       DSMode,
    ULONG                       Priority);


VOID
CompleteMakeCall(
    PGPC_CLIENT_VC Vc,
    PCO_CALL_PARAMETERS CallParameters,
    NDIS_STATUS Status);

VOID
ModifyCallComplete(
    PGPC_CLIENT_VC      Vc,
    PCO_CALL_PARAMETERS CallParameters,
    NDIS_STATUS         Status
    );

/* End Prototypes */

#endif /* _CMVC_ */

/* end cmvc.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\conformr.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    Conformr.h

Abstract:

    Defines for token bucket conformer

Author:


Revision History:

--*/

#ifndef _CONFORMR_H_
#define _CONFORMR_H_

#include "PktSched.h"

VOID
InitializeTbConformer(
    PPSI_INFO Info);

void
UnloadConformr();

#endif /* _CONFORMR_H_ */

/* end Conformr.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\config.h ===
/*++

Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

    config.h

Abstract:

    This file defines all constants and structures necessary for support of
    dynamic configuration.

Author:

    Charlie Wickham (charlwi) 26-Feb-1995

Revision History:

--*/

#include <ndis.h>

#ifndef _CONFIG_
#define _CONFIG_


/* Prototypes */ /* Generated by Emacs 19.17.0 on Thu Mar 09 08:42:15 1995 */

NDIS_STATUS
PsReadDriverRegistryData();

NDIS_STATUS
PsReadDriverRegistryDataInit();

NDIS_STATUS
PsReadAdapterRegistryData(
    IN PADAPTER Adapter,
    IN PNDIS_STRING MachineName,
    IN PNDIS_STRING AdapterName);

NDIS_STATUS
PsReadAdapterRegistryDataInit(
    IN PADAPTER Adapter,
    IN PNDIS_STRING AdapterName);


/* End Prototypes */

#endif /* _CONFIG_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\conformr.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    Conformr.c

Abstract:

    Token Bucket Conformer.  This module is a scheduling component that
    assigns conformance times to packets, based on the token bucket
    algorithm.

Author:
	Intel->YoramB->RajeshSu->SanjayKa.


Environment:

    Kernel Mode

Revision History:

--*/

#include "psched.h"
#pragma hdrstop


#ifdef QUEUE_LIMIT
ULONG gPhysMemSize;     // size of physical memory (in MB), used for shaper queue limit default

#endif // QUEUE_LIMIT


//
// For maintaining shaper Pipe & Flow Stats.
//
#define SHAPER_AVERAGING_ARRAY_SIZE         256
#define SHAPER_FLOW_AVERAGING_ARRAY_SIZE    256



// The conformer's pipe information

typedef struct _TBC_PIPE {

    // ContextInfo -            Generic context info
    // MaxPacket -              Maximum packet size for pipe
    // PsPipeContext -          PS's pipe context value
    // DropPacket -             PS's drop packet routine
    // HeaderLength -           Length of MAC header for this pipe
    // ControlledLoadMode -     Default mode for non-conforming traffic from
    //                          controlled load flows
    // GuaranteedMode -         Default mode for non-conforming traffic from
    //                          guaranteed service flows
    // IntermediateSystem -     TRUE if "IS" mode should be used for implementing discard semantics
    // Stats -                  Per Pipe stats.

    PS_PIPE_CONTEXT ContextInfo;

    PS_CONFORMER_STATS  cStats;
    PS_SHAPER_STATS     sStats;
    PRUNNING_AVERAGE PacketsInShaperAveragingArray;
    ULONG PacketsInShaper;    

    ULONG MaxPacket;
    LIST_ENTRY ActiveFlows;
    ULONG TimerStatus;
    ULONG TimerResolution;
    HANDLE PsPipeContext;
    PPS_PROCS PsProcs;
    ULONG HeaderLength;
    ULONG ControlledLoadMode;
    ULONG GuaranteedMode;
    ULONG NetworkControlMode;
    ULONG Qualitative;
    ULONG IntermediateSystem;

    // Need this to figure out the timer-wheel size //
    NDIS_MEDIUM MediaType;

    // Timer wheel parameters   //
    PVOID                   pTimerWheel;
    ULONG                   TimerWheelShift;
    NDIS_MINIPORT_TIMER     Timer;
    NDIS_SPIN_LOCK          Lock;

    ULONG                   SetSlotValue;
    LARGE_INTEGER           SetTimerValue;
    LARGE_INTEGER           ExecTimerValue;
    ULONG                   ExecSlot;

} TBC_PIPE, *PTBC_PIPE;


#define TIMER_UNINITIALIZED     0
#define TIMER_INACTIVE          1
#define TIMER_SET               2
#define TIMER_PROC_EXECUTING    3

typedef enum _FLOW_STATE {
    TS_FLOW_CREATED = 1,
    TS_FLOW_DELETED
} FLOW_STATE;

// The conformer's flow information

typedef struct _TBC_FLOW {

    // ContextInfo -            Generic context info
    // Lock -                   Protects flow data
    // TokenRate -              TokenRate from generic QoS
    // Capacity -               TokenBucketSize from generic QoS
    // PeakRate -               PeakBandwidth from generic QoS
    // MinPolicedUnit -         MinimumPolicedUnit from generic QoS
    // Mode -                   Flow S/D mode
    // NoConformance -          Indicates whether flow is exempt from conformance algorithm
    // LastConformanceTime -    Absolute tb conformance time of last non-discarded packet
    // PeakConformanceTime -    Earliest time next packet can be sent, based on peak rate
    // LastConformanceCredits - Number of credits at LastConformanceTime
    // PsFlowContext -          PS's flow context value
    // Stats -                  Per flow stats.

    PS_FLOW_CONTEXT ContextInfo;
    NDIS_SPIN_LOCK Lock;
    ULONG Flags;
    LIST_ENTRY Links;
    ULONG Mode;
    ULONG Shape;
    LIST_ENTRY PacketQueue;
    LARGE_INTEGER FlowEligibilityTime;
    ULONG LoopCount;
    ULONG TokenRate;
    ULONG Capacity;
    ULONG PeakRate;
    ULONG MinPolicedUnit;
    ULONG NoConformance;
    LARGE_INTEGER LastConformanceTime;
    LARGE_INTEGER PeakConformanceTime;
    ULONG LastConformanceCredits;
    HANDLE PsFlowContext;
#ifdef QUEUE_LIMIT
    ULONG QueueSize;
    ULONG QueueSizeLimit;
    ULONG DropOverLimitPacketsFromHead;
    ULONG UseDefaultQueueLimit;
#endif // QUEUE_LIMIT   

    PS_CONFORMER_STATS  cStats;
    PS_SHAPER_STATS     sStats;
    ULONG PacketsInShaper;
    PRUNNING_AVERAGE PacketsInShaperAveragingArray;

    FLOW_STATE      State;
} TBC_FLOW, *PTBC_FLOW;


// Macros used during token bucket conformance calculation

#define EARNED_CREDITS(_t,_r) ((ULONG)(( (_t) * (_r) ) / OS_TIME_SCALE))
#define TIME_TO_EARN_CREDITS(_c,_r) (((LONGLONG)(_c) * OS_TIME_SCALE) / (_r) )
#define TIME_TO_SEND(_c,_r) (((LONGLONG)(_c) * OS_TIME_SCALE) / (_r) )

#define PACKET_IS_CONFORMING(_ttime, _curtime, _r) \
    ( ((_ttime).QuadPart - (_curtime).QuadPart) <= (_r) )

#define LOCK_FLOW(_f)   NdisAcquireSpinLock(&(_f)->Lock)
#define UNLOCK_FLOW(_f) NdisReleaseSpinLock(&(_f)->Lock)

#define PacketIsEligible(_pktinfo, _flow, _curtime, _r) \
    ( (_pktinfo)->DelayTime.QuadPart <= ((_curtime).QuadPart + (_r)) )

#define FlowIsEligible(_flow, _curtime, _r) \
    ( (_flow)->FlowEligibilityTime.QuadPart <= ((_curtime).QuadPart  + (_r)) )

#define LOCK_PIPE(_p)   NdisAcquireSpinLock(&(_p)->Lock)
#define UNLOCK_PIPE(_p) NdisReleaseSpinLock(&(_p)->Lock)

//
// Define the maximum number of time for which a packet can live in the shaper. If a packet becomes conformant at 
// a time that is > this value, it gets discarded. This is to prevent apps from queueing up packets in the shaper 
// for a very long time (and exiting immediately causing a bugcheck when the app terminates after 5 min.). Note that
// this applies only to shape mode flows.
//

#define     MAX_TIME_FOR_PACKETS_IN_SHAPER  250000

#define     TIMER_WHEEL_QTY                 8              // in ms //
#define     TIMER_WHEEL_SHIFT               3
#define     MSIN100NS                       10000           // these many ticks are there in 1 ms //

#define     WAN_TIMER_WHEEL_SHIFT           8         // how many TIMER_WHEEL_QTY will it have? //
#define     LAN_TIMER_WHEEL_SHIFT           11         // how many TIMER_WHEEL_QTY will it have? //

#define     DUMMY_SLOT                      (0xffffffff)
#define     DUMMY_TIME                      (0)


/* External */

/* Static */

/* Forward */

NDIS_STATUS
TbcInitializePipe (
    IN HANDLE PsPipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters,
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_PROCS PsProcs,
    IN PPS_UPCALLS Upcalls
    );

NDIS_STATUS
TbcModifyPipe (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters
    );

VOID
TbcDeletePipe (
    IN PPS_PIPE_CONTEXT PipeContext
    );

NDIS_STATUS
TbcCreateFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsFlowContext,
    IN PCO_CALL_PARAMETERS CallParameters,
    IN PPS_FLOW_CONTEXT ComponentFlowContext
    );

NDIS_STATUS
TbcModifyFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PCO_CALL_PARAMETERS CallParameters
    );

VOID
TbcDeleteFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext
    );

VOID
TbcEmptyFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext
    );
    

NDIS_STATUS 
TbcCreateClassMap (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsClassMapContext,
    IN PTC_CLASS_MAP_FLOW ClassMap,
    IN PPS_CLASS_MAP_CONTEXT ComponentClassMapContext);

NDIS_STATUS 
TbcDeleteClassMap (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_CLASS_MAP_CONTEXT ComponentClassMapContext);

BOOLEAN
TbcSubmitPacket (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PPS_CLASS_MAP_CONTEXT ClassMapContext,
    IN PPACKET_INFO_BLOCK PacketInfo
    );


VOID
TbcSetInformation (
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_FLOW_CONTEXT ComponentFlowContext,
    IN NDIS_OID Oid,
    IN ULONG Len,
    IN PVOID Data);


VOID
TbcQueryInformation (
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_FLOW_CONTEXT ComponentFlowContext,
    IN NDIS_OID Oid,
    IN ULONG Len,
    IN PVOID Data,
    IN OUT PULONG BytesWritten,
    IN OUT PULONG BytesNeeded,
    IN OUT PNDIS_STATUS Status);

/* End Forward */


extern VOID
ServiceActiveFlows(
    PVOID SysArg1,
    PVOID Context,
    PVOID SysArg2,
    PVOID SysArg3);


VOID
InitializeTbConformer(
    PPSI_INFO Info)

/*++

Routine Description:

    Initialization routine for token bucket conformer.  This routine just
    fills in the PSI_INFO struct and returns.

Arguments:

    Info - Pointer to component interface info struct

Return Values:

    NDIS_STATUS_SUCCESS

--*/
{
#ifdef QUEUE_LIMIT
    ULONG bytesWritten;
    SYSTEM_BASIC_INFORMATION sbi;
#endif // QUEUE_LIMIT

    Info->PipeContextLength = ((sizeof(TBC_PIPE)+7) & ~7);
    Info->FlowContextLength = ((sizeof(TBC_FLOW)+7) & ~7);
    Info->ClassMapContextLength = sizeof(PS_CLASS_MAP_CONTEXT);
    Info->InitializePipe = TbcInitializePipe;
    Info->ModifyPipe = TbcModifyPipe;
    Info->DeletePipe = TbcDeletePipe;
    Info->CreateFlow = TbcCreateFlow;
    Info->ModifyFlow = TbcModifyFlow;
    Info->DeleteFlow = TbcDeleteFlow;
    Info->EmptyFlow =  TbcEmptyFlow;
    Info->CreateClassMap = TbcCreateClassMap;
    Info->DeleteClassMap = TbcDeleteClassMap;
    Info->SubmitPacket = TbcSubmitPacket;
    Info->ReceivePacket = NULL;
    Info->ReceiveIndication = NULL;
    Info->SetInformation = TbcSetInformation;
    Info->QueryInformation = TbcQueryInformation;

#ifdef QUEUE_LIMIT
    NtQuerySystemInformation(SystemBasicInformation, 
                             &sbi, 
                             sizeof(SYSTEM_BASIC_INFORMATION),
                             &bytesWritten);
    gPhysMemSize = sbi.NumberOfPhysicalPages * sbi.PageSize;
    // convert to MB
    gPhysMemSize >>= 20;
#endif // QUEUE_LIMIT    

} // InitializeTbConformer


//
//  Unload routine: currently does nothing
//
void
UnloadConformr()
{

}






NDIS_STATUS
TbcInitializePipe (
    IN HANDLE PsPipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters,
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_PROCS PsProcs,
    IN PPS_UPCALLS Upcalls
    )

/*++

Routine Description:

    Pipe initialization routine for token bucket conformer.

Arguments:

    PsPipeContext -         PS pipe context value
    PipeParameters -        Pointer to pipe parameters
    ComponentPipeContext -  Pointer to this component's context area
    PsProcs -               PS's support routines
    Upcalls -               Previous component's upcall table

Return Values:

    Status value from next component

--*/
{
    PTBC_PIPE Pipe = (PTBC_PIPE)ComponentPipeContext;
    NDIS_STATUS     Status;
    HANDLE          NdisHandle;
    int             i = 0;
    PLIST_ENTRY     pList = NULL;

    PsDbgOut(DBG_INFO, DBG_SCHED_TBC,
             ("PSCHED: Conformer pipe initialized. Bandwidth = %u\n", PipeParameters->Bandwidth));

    Pipe->MaxPacket = PipeParameters->MTUSize - PipeParameters->HeaderSize;
    Pipe->PsPipeContext = PsPipeContext;
    (*PsProcs->GetTimerInfo)(&Pipe->TimerResolution);
    Pipe->TimerResolution /= 2;
    Pipe->PsProcs = PsProcs;
    Pipe->HeaderLength = PipeParameters->HeaderSize;
    Pipe->ControlledLoadMode = PipeParameters->SDModeControlledLoad;
    Pipe->GuaranteedMode = PipeParameters->SDModeGuaranteed;
    Pipe->NetworkControlMode = PipeParameters->SDModeNetworkControl;
    Pipe->Qualitative = PipeParameters->SDModeQualitative;
    Pipe->IntermediateSystem = (PipeParameters->Flags & PS_INTERMEDIATE_SYS) ? TRUE : FALSE;
    Pipe->MediaType = PipeParameters->MediaType;

    InitializeListHead(&Pipe->ActiveFlows);
    NdisHandle = (*PsProcs->NdisPipeHandle)(PsPipeContext);

    // 1. Initialize the spin lock that protects the timer wheel //
    NdisAllocateSpinLock(&Pipe->Lock);

    // 2. Initialize the timer for the timer wheel //
    if (NdisHandle != NULL) 
    {
        NdisMInitializeTimer(
                &Pipe->Timer,
                NdisHandle,
                ServiceActiveFlows,
                Pipe);
                
        Pipe->TimerStatus = TIMER_INACTIVE;
    }
    else 
    {
        // Why would it come here.... ? //
        Pipe->TimerStatus = TIMER_UNINITIALIZED;
    }

    // Remember what kind of pipe are we installing now.. //
    if( Pipe->MediaType == NdisMediumWan )
        Pipe->TimerWheelShift = WAN_TIMER_WHEEL_SHIFT;
    else
        Pipe->TimerWheelShift = LAN_TIMER_WHEEL_SHIFT;


    // These values should always be initialized    //
    Pipe->pTimerWheel = NULL;
    Pipe->SetSlotValue =            DUMMY_SLOT;
    Pipe->SetTimerValue.QuadPart =  DUMMY_TIME;

    Pipe->cStats.NonconformingPacketsScheduled = 0;
    Pipe->PacketsInShaper = 0;
    Pipe->PacketsInShaperAveragingArray = NULL;

    NdisZeroMemory(&Pipe->sStats, sizeof(PS_SHAPER_STATS));

    Status = CreateAveragingArray(&Pipe->PacketsInShaperAveragingArray,
                                  SHAPER_AVERAGING_ARRAY_SIZE);

    if(Status != NDIS_STATUS_SUCCESS)
    {
        NdisFreeSpinLock( &Pipe->Lock );
        return(Status);
    }

    Status = (*Pipe->ContextInfo.NextComponent->InitializePipe)(
                PsPipeContext,
                PipeParameters,
                Pipe->ContextInfo.NextComponentContext,
                PsProcs,
                Upcalls);

    if (Status != NDIS_STATUS_SUCCESS) 
    {
        DeleteAveragingArray(Pipe->PacketsInShaperAveragingArray);
        NdisFreeSpinLock( &Pipe->Lock );
    }

    return Status;

} // TbcInitializePipe



NDIS_STATUS
TbcModifyPipe (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters
    )

/*++

Routine Description:

    Pipe parameter modification routine for token bucket conformer.

Arguments:

    PipeContext -       Pointer to this component's pipe context area
    PipeParameters -    Pointer to pipe parameters

Return Values:

    Status value from next component

--*/
{
    PTBC_PIPE Pipe = (PTBC_PIPE)PipeContext;
    PTBC_FLOW Flow;
    PLIST_ENTRY Entry;

    PsDbgOut(DBG_INFO, DBG_SCHED_TBC,
             ("PSCHED: Conformer pipe modified. Bandwidth = %u\n", PipeParameters->Bandwidth));

    LOCK_PIPE(Pipe);

    (*Pipe->PsProcs->GetTimerInfo)(&Pipe->TimerResolution);
    Pipe->TimerResolution /= 2;

    UNLOCK_PIPE(Pipe);    

    return (*Pipe->ContextInfo.NextComponent->ModifyPipe)(
                Pipe->ContextInfo.NextComponentContext,
                PipeParameters);

} // TbcModifyPipe



VOID
TbcDeletePipe (
    IN PPS_PIPE_CONTEXT PipeContext
    )

/*++

Routine Description:

    Pipe removal routine for token bucket conformer.

Arguments:

    PipeContext -   Pointer to this component's pipe context area

Return Values:

--*/
{
    PTBC_PIPE Pipe = (PTBC_PIPE)PipeContext;
    BOOLEAN Cancelled;

    if (Pipe->TimerStatus == TIMER_SET) 
    {
        BOOLEAN TimerCancelled;
        NdisMCancelTimer(&Pipe->Timer, &TimerCancelled );

        if( !TimerCancelled )
        {
            //  Need to handle the case where the Timer could not be cancelled. In this case, the DPC could be running,
            //  and we will have to wait here before going further  
        }
        else
        {        
            Pipe->TimerStatus = TIMER_INACTIVE;
        }            
    }

    DeleteAveragingArray(Pipe->PacketsInShaperAveragingArray);

    //  Every pipe does not necessarily have a Timer-wheel now  //
    if( Pipe->pTimerWheel )
        PsFreePool( Pipe->pTimerWheel);
        
    NdisFreeSpinLock(&Pipe->Lock);

    PsDbgOut(DBG_INFO, DBG_SCHED_TBC, ("PSCHED: Conformer pipe deleted\n"));    

    (*Pipe->ContextInfo.NextComponent->DeletePipe)(Pipe->ContextInfo.NextComponentContext);

} // TbcDeletePipe



#ifdef QUEUE_LIMIT
/*
    SetDefaultFlowQueueLimit() - Sets the queue size limit on a flow using a formula based on
                                 the amount of physical memory in the system and the overall
                                 bandwidth of the flow.

        OUT PTS_FLOW Flow                       - Pointer to the flow to set the limit on
        IN PCO_CALL_PARAMETERS CallParameters   - Call parameters containing the flow's 
                                                  bandwidth requirements
*/
static void 
SetDefaultFlowQueueLimit (
    OUT PTS_FLOW Flow,
    IN PCO_CALL_PARAMETERS CallParameters
    )
{
    ULONG FlowBandwidth;  // = either PeakRate or TokenRate+BucketSize

    // determine the "flow bandwidth"
    // if the peak rate is specified, use it as flow b/w
    if (CallParameters->CallMgrParameters->Transmit.PeakBandwidth != QOS_NOT_SPECIFIED)
        FlowBandwidth = CallParameters->CallMgrParameters->Transmit.PeakBandwidth;
    // otherwise use tokenrate + bucket size
    else if (QOS_NOT_SPECIFIED == CallParameters->CallMgrParameters->Transmit.TokenBucketSize)
        FlowBandwidth = CallParameters->CallMgrParameters->Transmit.TokenRate;
    else FlowBandwidth = CallParameters->CallMgrParameters->Transmit.TokenRate +
        CallParameters->CallMgrParameters->Transmit.TokenBucketSize;
    
    // then use it to compute the queue limit (first in time units)
    Flow->QueueSizeLimit = (ULONG)(40.0 * log10(0.2 * gPhysMemSize) / log10(FlowBandwidth));
    // convert time limit to size limit
    Flow->QueueSizeLimit *= FlowBandwidth;
}
#endif // QUEUE_LIMIT



NDIS_STATUS
TbcCreateFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsFlowContext,
    IN PCO_CALL_PARAMETERS CallParameters,
    IN PPS_FLOW_CONTEXT ComponentFlowContext
    )

/*++

Routine Description:

    Flow creation routine for token bucket conformer.

Arguments:

    PipeContext -           Pointer to this component's pipe context area
    PsFlowContext -         PS flow context value
    CallParameters -        Pointer to call parameters for flow
    ComponentFlowContext -  Pointer to this component's flow context area

Return Values:

    Status value from next component

--*/
{
    PTBC_PIPE Pipe = (PTBC_PIPE)PipeContext;
    PTBC_FLOW Flow = (PTBC_FLOW)ComponentFlowContext;
    HANDLE NdisHandle;
    NDIS_STATUS Status;
    ULONG ParamsLength;
    LPQOS_OBJECT_HDR QoSObject;
    LPQOS_SD_MODE ShapeDiscardObject = NULL;
    ULONG Mode;
    ULONG PeakRate;

    ULONG           Slot= 0;
    LARGE_INTEGER   Ms;
    LARGE_INTEGER   TenMs;
    LARGE_INTEGER   CurrentTimeInMs;
    LONGLONG        DeltaTimeInMs;
    PLIST_ENTRY     pList = NULL;
    LARGE_INTEGER   CurrentTime;
    

#ifdef QUEUE_LIMIT
    LPQOS_SHAPER_QUEUE_LIMIT_DROP_MODE ShaperOverLimitDropModeObject = NULL;
    LPQOS_SHAPER_QUEUE_LIMIT ShaperQueueLimitObject = NULL;
#endif // QUEUELIMIT


    if (Pipe->TimerStatus == TIMER_UNINITIALIZED) {
        NdisHandle = (*Pipe->PsProcs->NdisPipeHandle)(Pipe->PsPipeContext);

        if (NdisHandle != NULL) {
            NdisMInitializeTimer(
                    &Pipe->Timer,
                    NdisHandle,
                    ServiceActiveFlows,
                    Pipe);
            Pipe->TimerStatus = TIMER_INACTIVE;
        }
        else {
            return NDIS_STATUS_FAILURE;
        }
    }

    NdisAllocateSpinLock(&Flow->Lock);

    // Get the required values from the flowspec.  We assume here that the PS wrapper
    // has performed the required validity checks:
    //     TokenRate <= PeakRate
    //     TokenRate > 0

    Flow->TokenRate = CallParameters->CallMgrParameters->Transmit.TokenRate;
    Flow->Capacity = CallParameters->CallMgrParameters->Transmit.TokenBucketSize;
    Flow->PeakRate = CallParameters->CallMgrParameters->Transmit.PeakBandwidth;
    Flow->MinPolicedUnit =
        (CallParameters->CallMgrParameters->Transmit.MinimumPolicedSize == QOS_NOT_SPECIFIED) ?
        0 : CallParameters->CallMgrParameters->Transmit.MinimumPolicedSize;

    if (Flow->Capacity == QOS_NOT_SPECIFIED) 
    {
        if( Pipe->MaxPacket > (CallParameters->CallMgrParameters->Transmit.TokenRate / 100) ) 
            Flow->Capacity = Pipe->MaxPacket;
        else
            Flow->Capacity = CallParameters->CallMgrParameters->Transmit.TokenRate / 100;
    }

    // Look for the Shape/Discard object in the call manager specific parameters.
    // If it is found, save the pointer.

    ParamsLength = CallParameters->CallMgrParameters->CallMgrSpecific.Length;
    if (CallParameters->CallMgrParameters->CallMgrSpecific.ParamType == PARAM_TYPE_GQOS_INFO) {

        QoSObject = (LPQOS_OBJECT_HDR)CallParameters->CallMgrParameters->CallMgrSpecific.Parameters;
        while ((ParamsLength > 0) && (QoSObject->ObjectType != QOS_OBJECT_END_OF_LIST)) {
            if (QoSObject->ObjectType == QOS_OBJECT_SD_MODE) {
                ShapeDiscardObject = (LPQOS_SD_MODE)QoSObject;
#ifdef QUEUE_LIMIT
            else if (QoSObject->ObjectType == QOS_OBJECT_SHAPER_QUEUE_DROP_MODE) {
                ShaperOverLimitDropModeObject = (LPQOS_SHAPER_QUEUE_LIMIT_DROP_MODE)QoSObject;
            }
            else if (QoSObject->ObjectType == QOS_OBJECT_SHAPER_QUEUE_LIMIT) {
                ShaperQueueLimitObject = (LPQOS_SHAPER_QUEUE_LIMIT)QoSObject;
            }
#endif // QUEUE_LIMIT                
            }
            ParamsLength -= QoSObject->ObjectLength;
            QoSObject = (LPQOS_OBJECT_HDR)((UINT_PTR)QoSObject + QoSObject->ObjectLength);
        }
    }

    // If no Shape/Discard object was found, set the default value for the
    // "Discard" parameter.  Otherwise set it to the value specified by the
    // object.

    if (ShapeDiscardObject == NULL) {
        switch (CallParameters->CallMgrParameters->Transmit.ServiceType) {
            case SERVICETYPE_CONTROLLEDLOAD:
                Mode = Pipe->ControlledLoadMode;
                break;
            case SERVICETYPE_GUARANTEED:
                Mode = Pipe->GuaranteedMode;
                break;
          case SERVICETYPE_NETWORK_CONTROL:
                Mode = Pipe->NetworkControlMode;
                break;
          case SERVICETYPE_QUALITATIVE:
                Mode = Pipe->Qualitative;
                break;
            default:
                Mode = TC_NONCONF_BORROW;
        }
    }
    else {
        Mode = ShapeDiscardObject->ShapeDiscardMode;
    }

    Flow->Mode = Mode;
    
    Flow->NoConformance = ((Mode == TC_NONCONF_BORROW_PLUS) ||
                           (Flow->TokenRate == QOS_NOT_SPECIFIED));

    PsGetCurrentTime(&Flow->LastConformanceTime);

    Flow->PeakConformanceTime = Flow->LastConformanceTime;
    Flow->LastConformanceCredits = Flow->Capacity;
    Flow->PsFlowContext = PsFlowContext;

    PeakRate = CallParameters->CallMgrParameters->Transmit.PeakBandwidth;
    if (Flow->Mode == TC_NONCONF_SHAPE) {
        Flow->Shape = TRUE;
    } else if ((PeakRate != QOS_NOT_SPECIFIED) &&
               (Flow->Mode != TC_NONCONF_BORROW_PLUS) &&
               !Pipe->IntermediateSystem) {
        Flow->Shape = TRUE;
    } else {
        Flow->Shape = FALSE;
    }


#ifdef QUEUE_LIMIT
    Flow->QueueSize = 0;
    // If the flow is shaped, set the queue limiting params.  If not specified, use defaults
    if (Flow->Shape) {
        // set the drop mode
        if (NULL != ShaperOverLimitDropModeObject) {
            Flow->DropOverLimitPacketsFromHead = (BOOLEAN) ShaperOverLimitDropModeObject->DropMode;
        }
        else {
            // default to this behavior
            Flow->DropOverLimitPacketsFromHead = TRUE;
        }

        // set the queue limit
        if (NULL != ShaperQueueLimitObject) {
            Flow->UseDefaultQueueLimit = FALSE;
            Flow->QueueSizeLimit = ShaperQueueLimitObject->QueueSizeLimit;
        }
        else {
            Flow->UseDefaultQueueLimit = TRUE;
            // default to a size based on the flow's bandwidth and physical memory
            SetDefaultFlowQueueLimit(Flow, CallParameters);
        }
    }
#endif // QUEUE_LIMIT

    InitializeListHead(&Flow->PacketQueue);
    PsGetCurrentTime(&Flow->FlowEligibilityTime);

    Flow->cStats.NonconformingPacketsScheduled = 0;
    Flow->PacketsInShaper = 0;
    Flow->PacketsInShaperAveragingArray = NULL;
    
    NdisZeroMemory(&Flow->sStats, sizeof(PS_SHAPER_STATS));

    Status = CreateAveragingArray(&Flow->PacketsInShaperAveragingArray,
                                                                  SHAPER_FLOW_AVERAGING_ARRAY_SIZE);
    if(Status != NDIS_STATUS_SUCCESS){
        return(Status);
    }

    PsDbgOut(DBG_INFO, DBG_SCHED_TBC, ("PSCHED: Conformer flow %08X (PsFlowContext = %08X) created. Rate = %u\n", 
             Flow,
             Flow->PsFlowContext, 
             Flow->TokenRate));

             
    Status = (*Pipe->ContextInfo.NextComponent->CreateFlow)(
                Pipe->ContextInfo.NextComponentContext,
                PsFlowContext,
                CallParameters,
                Flow->ContextInfo.NextComponentContext);

    LOCK_PIPE( Pipe );
                    
    if (Status != NDIS_STATUS_SUCCESS) 
    {
        NdisFreeSpinLock(&Flow->Lock);
        DeleteAveragingArray(Flow->PacketsInShaperAveragingArray);
    }

    UNLOCK_PIPE( Pipe );

    return Status;

} // TbcCreateFlow



NDIS_STATUS
TbcModifyFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PCO_CALL_PARAMETERS CallParameters
    )

/*++

Routine Description:

    Flow modification routine for token bucket conformer.

Arguments:

    PipeContext -       Pointer to this component's pipe context area
    FlowContext -       Pointer to this component's flow context area
    CallParameters -    Pointer to call parameters for flow

Return Values:

    Status value from next component

--*/
{
    PTBC_PIPE Pipe = (PTBC_PIPE)PipeContext;
    PTBC_FLOW Flow = (PTBC_FLOW)FlowContext;
    ULONG ParamsLength;
    LPQOS_OBJECT_HDR QoSObject;
    LPQOS_SD_MODE ShapeDiscardObject = NULL;
    ULONG Mode;
    ULONG PeakRate;
    LARGE_INTEGER CurrentTime;

#ifdef QUEUE_LIMIT
    LPQOS_SHAPER_QUEUE_LIMIT_DROP_MODE ShaperOverLimitDropModeObject = NULL;
    LPQOS_SHAPER_QUEUE_LIMIT ShaperQueueLimitObject = NULL;
#endif // QUEUE_LIMIT    

    // Look for the Shape/Discard object in the call manager specific parameters.
    // If it is found, save the pointer.

    ParamsLength = CallParameters->CallMgrParameters->CallMgrSpecific.Length;
    if (CallParameters->CallMgrParameters->CallMgrSpecific.ParamType == PARAM_TYPE_GQOS_INFO) {

        QoSObject = (LPQOS_OBJECT_HDR)CallParameters->CallMgrParameters->CallMgrSpecific.Parameters;
        while ((ParamsLength > 0) && (QoSObject->ObjectType != QOS_OBJECT_END_OF_LIST)) {
            if (QoSObject->ObjectType == QOS_OBJECT_SD_MODE) {
                ShapeDiscardObject = (LPQOS_SD_MODE)QoSObject;
#ifdef QUEUE_LIMIT
            else if (QoSObject->ObjectType == QOS_OBJECT_SHAPER_QUEUE_DROP_MODE) {
                ShaperOverLimitDropModeObject = (LPQOS_SHAPER_QUEUE_LIMIT_DROP_MODE)QoSObject;
            }
            else if (QoSObject->ObjectType == QOS_OBJECT_SHAPER_QUEUE_LIMIT) {
                ShaperQueueLimitObject = (LPQOS_SHAPER_QUEUE_LIMIT)QoSObject;
            }
#endif // QUEUE_LIMIT
            }
            ParamsLength -= QoSObject->ObjectLength;
            QoSObject = (LPQOS_OBJECT_HDR)((UINT_PTR)QoSObject + QoSObject->ObjectLength);
        }
    }

    PeakRate = CallParameters->CallMgrParameters->Transmit.PeakBandwidth;

    LOCK_FLOW(Flow);

    //
    // There are basically 2 parameters that have to be corrected in this function:
    // They are (a) LastConformanceTime (b) LastConformanceCredits.
    // (1) If LastConformanceTime is in the future: Goto step(4).
    // (2)	(a) Figure out how many bytes were accumulated between LastConformanceTime and CurrentTime.
    //		(b) If Accumulated Credits is greater than Bucket size, Accumulated Credits = Bucket size.
    //		(c) Set LastConformanceTime to CurrentTime.
    // (3) PeakConformanceTime will not be changed.
    // (4) Change the Flow parameters, as specified in the Modify-call.

    PsGetCurrentTime(&CurrentTime);

    if( Flow->LastConformanceTime.QuadPart < CurrentTime.QuadPart)
    {
	    ULONG	Credits;

	    Credits = Flow->LastConformanceCredits + 
			EARNED_CREDITS( CurrentTime.QuadPart - Flow->LastConformanceTime.QuadPart, Flow->TokenRate);

	    if( Credits > Flow->Capacity)
	        Flow->LastConformanceCredits = Flow->Capacity;
	    else
	        Flow->LastConformanceCredits = Credits;

	    Flow->LastConformanceTime.QuadPart = CurrentTime.QuadPart;	
    }


    if (CallParameters->CallMgrParameters->Transmit.ServiceType != SERVICETYPE_NOCHANGE) {

        // Get the new flowspec values.  Again we assume the PS wrapper has done
        // the required validity checks.

        Flow->TokenRate = CallParameters->CallMgrParameters->Transmit.TokenRate;
        Flow->Capacity = CallParameters->CallMgrParameters->Transmit.TokenBucketSize;
        Flow->PeakRate = CallParameters->CallMgrParameters->Transmit.PeakBandwidth;
        Flow->MinPolicedUnit =
            (CallParameters->CallMgrParameters->Transmit.MinimumPolicedSize == QOS_NOT_SPECIFIED) ?
            0 : CallParameters->CallMgrParameters->Transmit.MinimumPolicedSize;

        if (Flow->Capacity == QOS_NOT_SPECIFIED) 
        {
            if( Pipe->MaxPacket > (CallParameters->CallMgrParameters->Transmit.TokenRate / 100) ) 
                Flow->Capacity = Pipe->MaxPacket;
            else
                Flow->Capacity = CallParameters->CallMgrParameters->Transmit.TokenRate / 100;
        }

        if (ShapeDiscardObject == NULL) {

            // Re-calculate the Shape parameter if the user has never specified
            // a Shape/Discard object.

            switch (CallParameters->CallMgrParameters->Transmit.ServiceType) {
                case SERVICETYPE_CONTROLLEDLOAD:
                    Mode = Pipe->ControlledLoadMode;
                    break;
                case SERVICETYPE_GUARANTEED:
                    Mode = Pipe->GuaranteedMode;
                    break;
              case SERVICETYPE_NETWORK_CONTROL:
                    Mode = Pipe->NetworkControlMode;
                    break;
              case SERVICETYPE_QUALITATIVE:
                    Mode = Pipe->Qualitative;
                    break;
              default:
                    Mode = TC_NONCONF_BORROW;
            }
        }
    }
    else
    {
        // The ServiceType has not changed. We can use the existing mode.

        Mode = Flow->Mode;
    }
        

    if (ShapeDiscardObject != NULL) {
        Mode = ShapeDiscardObject->ShapeDiscardMode;
    }

    Flow->Mode = Mode;
    Flow->NoConformance = ((Mode == TC_NONCONF_BORROW_PLUS) ||
                           (Flow->TokenRate == QOS_NOT_SPECIFIED));

    if (Flow->Mode == TC_NONCONF_SHAPE) {
        Flow->Shape = TRUE;
    } else if ((PeakRate != QOS_NOT_SPECIFIED) &&
               (Flow->Mode != TC_NONCONF_BORROW_PLUS) &&
               !Pipe->IntermediateSystem) {
        Flow->Shape = TRUE;
    } else {
        Flow->Shape = FALSE;
    }                           

 
#ifdef QUEUE_LIMIT
    // If the flow is shaped, check the queue limiting params.  If specified, use
    if (Flow->Shape) {
        // modify drop mode
        if (NULL != ShaperOverLimitDropModeObject) {
            Flow->DropOverLimitPacketsFromHead = (BOOLEAN) ShaperOverLimitDropModeObject->DropMode;
        }

        // modify queue limit
        if (NULL != ShaperQueueLimitObject) {
            Flow->UseDefaultQueueLimit = FALSE;
            Flow->QueueSizeLimit = ShaperQueueLimitObject->QueueSizeLimit;
        }
        // if they haven't overridden the limit, recompute it in case bandwidth req's changed
        else if (Flow->UseDefaultQueueLimit) {
            SetDefaultFlowQueueLimit(Flow, CallParameters);
        }
    }
#endif // QUEUE_LIMIT    

    UNLOCK_FLOW(Flow);

    PsDbgOut(DBG_INFO, DBG_SCHED_TBC, ("PSCHED: Conformer flow %08x (PsFlowContext %08X) modified. Rate = %u\n", 
             Flow, Flow->PsFlowContext, Flow->TokenRate));

    return (*Pipe->ContextInfo.NextComponent->ModifyFlow)(
                Pipe->ContextInfo.NextComponentContext,
                Flow->ContextInfo.NextComponentContext,
                CallParameters);

} // TbcModifyFlow



VOID
TbcDeleteFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext
    )

/*++

Routine Description:

    Flow removal routine for token bucket conformer.

Arguments:

    PipeContext -       Pointer to this component's pipe context area
    FlowContext -       Pointer to this component's flow context area

Return Values:

--*/
{
    PTBC_PIPE Pipe = (PTBC_PIPE)PipeContext;
    PTBC_FLOW Flow = (PTBC_FLOW)FlowContext;
    PPACKET_INFO_BLOCK PacketInfo;
    PNDIS_PACKET Packet;
    LIST_ENTRY DropList;

    PsDbgOut(DBG_INFO, DBG_SCHED_TBC, ("PSCHED: Conformer flow %08X (PS context %08X) deleted\n", 
             Flow, Flow->PsFlowContext));

    NdisFreeSpinLock(&Flow->Lock);

    InitializeListHead(&DropList);

    LOCK_PIPE(Pipe);

    if (!IsListEmpty(&Flow->PacketQueue)) {

        // Remove flow from active list

        RemoveEntryList(&Flow->Links);

        while (!IsListEmpty(&Flow->PacketQueue)) {

            // Drop any packets that remain queued for this flow.

            PacketInfo = (PPACKET_INFO_BLOCK)RemoveHeadList(&Flow->PacketQueue);
            InsertTailList(&DropList, &PacketInfo->SchedulerLinks);

        }
    }

    DeleteAveragingArray(Flow->PacketsInShaperAveragingArray);

    UNLOCK_PIPE(Pipe);

    while (!IsListEmpty(&DropList)) 
    {
        PacketInfo = (PPACKET_INFO_BLOCK)RemoveHeadList(&DropList);
        Packet = PacketInfo->NdisPacket;

        (*Pipe->PsProcs->DropPacket)(Pipe->PsPipeContext, Flow->PsFlowContext, Packet,  NDIS_STATUS_FAILURE);
    }

    (*Pipe->ContextInfo.NextComponent->DeleteFlow)(
                Pipe->ContextInfo.NextComponentContext,
                Flow->ContextInfo.NextComponentContext);

} // TbcDeleteFlow




VOID
TbcEmptyFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext
    )

/*++

Routine Description:

    Flow removal routine for token bucket conformer.

Arguments:

    PipeContext -       Pointer to this component's pipe context area
    FlowContext -       Pointer to this component's flow context area

Return Values:

--*/
{
    PTBC_PIPE Pipe = (PTBC_PIPE)PipeContext;
    PTBC_FLOW Flow = (PTBC_FLOW)FlowContext;
    PPACKET_INFO_BLOCK PacketInfo;
    PNDIS_PACKET Packet;
    LIST_ENTRY DropList;

    PsDbgOut(DBG_INFO, DBG_SCHED_TBC, ("PSCHED: Conformer flow %08X (PS context %08X) emptied\n", 
             Flow, Flow->PsFlowContext));

	InitializeListHead(&DropList);

    LOCK_PIPE(Pipe);

    if (!IsListEmpty(&Flow->PacketQueue)) 
    {
        // Remove flow from active list
        RemoveEntryList(&Flow->Links);

		while (!IsListEmpty(&Flow->PacketQueue)) 
		{
			// Drop any packets that remain queued for this flow.
	        PacketInfo = (PPACKET_INFO_BLOCK)RemoveHeadList(&Flow->PacketQueue);
	        InsertTailList(&DropList, &PacketInfo->SchedulerLinks);
	    }
	}

	Flow->State = TS_FLOW_DELETED;

    UNLOCK_PIPE(Pipe);

    while (!IsListEmpty(&DropList)) 
    {
        PacketInfo = (PPACKET_INFO_BLOCK)RemoveHeadList(&DropList);
        Packet = PacketInfo->NdisPacket;

        (*Pipe->PsProcs->DropPacket)(Pipe->PsPipeContext, Flow->PsFlowContext, Packet,  NDIS_STATUS_FAILURE);
    }

    (*Pipe->ContextInfo.NextComponent->EmptyFlow)(
                Pipe->ContextInfo.NextComponentContext,
                Flow->ContextInfo.NextComponentContext);

} // TbcModifyFlow




static NDIS_STATUS 
TbcCreateClassMap (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsClassMapContext,
    IN PTC_CLASS_MAP_FLOW ClassMap,
    IN PPS_CLASS_MAP_CONTEXT ComponentClassMapContext)
{
    PTBC_PIPE Pipe = (PTBC_PIPE)PipeContext;
    return (*Pipe->ContextInfo.NextComponent->CreateClassMap)(
        Pipe->ContextInfo.NextComponentContext,
        PsClassMapContext,
        ClassMap,
        ComponentClassMapContext->NextComponentContext);
}



static NDIS_STATUS 
TbcDeleteClassMap (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_CLASS_MAP_CONTEXT ComponentClassMapContext)
{
    PTBC_PIPE Pipe = (PTBC_PIPE)PipeContext;
    return (*Pipe->ContextInfo.NextComponent->DeleteClassMap)(
        Pipe->ContextInfo.NextComponentContext,
        ComponentClassMapContext->NextComponentContext);
}


void
InsertFlow( PTBC_PIPE           Pipe,
            PTBC_FLOW           Flow,
            LARGE_INTEGER       CurrentTime,
            PPACKET_INFO_BLOCK  PacketInfo,
            PNDIS_PACKET        Packet,
            ULONG               ExecSlot,
            LARGE_INTEGER       ExecTimeInTenMs)
{
    /* So, the packet is not eligible to be sent out right now, and the pkt-queue is empty.. */

    ULONG           Slot= 0;
    LARGE_INTEGER   Ms;
    LARGE_INTEGER   TenMs;
    LARGE_INTEGER   CurrentTimeInMs;
    LARGE_INTEGER   DeltaTimeInTenMs, CurrentTimeInTenMs;
    PLIST_ENTRY     pList = NULL;
    BOOLEAN         TimerCancelled;

    PsDbgSched(DBG_INFO, 
               DBG_SCHED_SHAPER,
               SHAPER, PKT_ENQUEUE, Flow->PsFlowContext,
               Packet, PacketInfo->PacketLength, 0, 
               CurrentTime.QuadPart,
               PacketInfo->DelayTime.QuadPart,
               Pipe->PacketsInShaper,
               0);

    /* Conf time in ms and 10ms */
    Ms.QuadPart = OS_TIME_TO_MILLISECS( Flow->FlowEligibilityTime.QuadPart );
    TenMs.QuadPart = Ms.QuadPart >> TIMER_WHEEL_SHIFT;

    /* Diff in 10 MS */
    DeltaTimeInTenMs.QuadPart = TenMs.QuadPart - ExecTimeInTenMs.QuadPart;
    

    /* Figure out the Slot for this time.. */
    Slot = (ULONG)( (TenMs.QuadPart) & (( 1 << Pipe->TimerWheelShift) - 1) );

    /* Update the loop count too */
    Flow->LoopCount = (ULONG)( DeltaTimeInTenMs.QuadPart >> Pipe->TimerWheelShift );

    if( Slot == ExecSlot)
        Slot = ( (Slot + 1) & ((1 << Pipe->TimerWheelShift) - 1) );

    pList = (PLIST_ENTRY)( (char*)Pipe->pTimerWheel + ( sizeof(LIST_ENTRY) * Slot) );
        
    /* Need to insert the flow to the timer-wheel in slot's position*/
    InsertTailList(pList, &Flow->Links);
}




VOID
ServiceActiveFlows(
    PVOID SysArg1,
    PVOID Context,
    PVOID SysArg2,
    PVOID SysArg3)

/*++

Routine Description:

    Service the active flow list after a timer expiration.

Arguments:

    Context -       Pointer to pipe context information

Return Values:


--*/
{
    PTBC_PIPE Pipe = (PTBC_PIPE)Context;
    PTBC_FLOW Flow;
    LARGE_INTEGER CurrentTime;
    LONGLONG RelTimeInMillisecs;
    PPACKET_INFO_BLOCK PacketInfo;
    PNDIS_PACKET Packet;
    BOOLEAN DoneWithFlow;

    PLIST_ENTRY CurrentLink;
    PLIST_ENTRY ListHead;
    PLIST_ENTRY ListEnd;

    ULONG           i = 0;
    ULONG           SetSlot= 0;
    ULONG           CurrentSlot = 0;
    
    LARGE_INTEGER   Ms;
    LARGE_INTEGER   TenMs;
    LARGE_INTEGER   CurrentTimeInMs;
    LONGLONG        DeltaTimeInMs;

    LIST_ENTRY SendList;
    LIST_ENTRY FlowList;

    InitializeListHead(&SendList);
    InitializeListHead(&FlowList);

    LOCK_PIPE(Pipe);
    
    PsGetCurrentTime(&CurrentTime);

    /* start from here.. */
    i = SetSlot = Pipe->SetSlotValue;

    Ms.QuadPart = OS_TIME_TO_MILLISECS( CurrentTime.QuadPart);
    TenMs.QuadPart = Ms.QuadPart >> TIMER_WHEEL_SHIFT;

    // Need to make sure that SetTimerValue is lesser than TenMs //
    if( Pipe->SetTimerValue.QuadPart > TenMs.QuadPart)
    {
        // Why is the timer firing earlier than when it is slated to? 
        TenMs.QuadPart = 1;
        NdisMSetTimer(&Pipe->Timer, (UINT)(TenMs.QuadPart << TIMER_WHEEL_SHIFT));
        UNLOCK_PIPE(Pipe);
        return;
    }

    /* run till here.. */
    CurrentSlot = (ULONG)( (TenMs.QuadPart) & ((1 << Pipe->TimerWheelShift) - 1) );

    /* Indicate that the timer is running */
    Pipe->TimerStatus = TIMER_PROC_EXECUTING;
    Pipe->ExecTimerValue.QuadPart = Pipe->SetTimerValue.QuadPart;
    Pipe->ExecSlot = Pipe->SetSlotValue;


    ListHead = (PLIST_ENTRY)((char*)Pipe->pTimerWheel + (sizeof(LIST_ENTRY)* SetSlot ));
    ListEnd = (PLIST_ENTRY)((char*)Pipe->pTimerWheel + (sizeof(LIST_ENTRY)*  CurrentSlot ));

    while(1)
    {
        while( !IsListEmpty( ListHead) )
        {
            CurrentLink = ListHead->Flink;
            Flow = CONTAINING_RECORD(CurrentLink, TBC_FLOW, Links);
            RemoveEntryList(&Flow->Links);

            PsAssert(!IsListEmpty(&Flow->PacketQueue));
            DoneWithFlow = FALSE;

            InitializeListHead( &SendList );

            PacketInfo = (PPACKET_INFO_BLOCK)Flow->PacketQueue.Flink;

            if( Flow->LoopCount > 0 )
            {
                Flow->LoopCount--;
                InsertTailList( &FlowList, &Flow->Links );
                continue;
            }

            while( FlowIsEligible(Flow, CurrentTime, ((TIMER_WHEEL_QTY/2) * MSIN100NS)))
            {
                RemoveEntryList(&PacketInfo->SchedulerLinks);

                Packet = PacketInfo->NdisPacket;

                DoneWithFlow = IsListEmpty(&Flow->PacketQueue);

                Pipe->PacketsInShaper--;
                Flow->PacketsInShaper--;

                if(gEnableAvgStats)
                {
                    Pipe->sStats.AveragePacketsInShaper =
                        RunningAverage(Pipe->PacketsInShaperAveragingArray, 
                                       Pipe->PacketsInShaper);

                    Flow->sStats.AveragePacketsInShaper =
                        RunningAverage(Flow->PacketsInShaperAveragingArray, 
                                       Flow->PacketsInShaper);

                }
                
                PsDbgSched(DBG_INFO,
                           DBG_SCHED_SHAPER,
                           SHAPER, PKT_DEQUEUE, Flow->PsFlowContext,
                           Packet, PacketInfo->PacketLength, 0, 
                           CurrentTime.QuadPart,
                           PacketInfo->DelayTime.QuadPart,
                           Pipe->PacketsInShaper,
                           0);


                InsertTailList( &SendList, &PacketInfo->SchedulerLinks);

                if( !DoneWithFlow)
                {
                    PacketInfo = (PPACKET_INFO_BLOCK)Flow->PacketQueue.Flink;
                    Flow->FlowEligibilityTime.QuadPart = PacketInfo->DelayTime.QuadPart;
                }
                else
                {
                    break;
                }
            }

            if( !DoneWithFlow)
            {
                /* Need to insert in the right place.. */
                InsertFlow( Pipe, Flow, CurrentTime, PacketInfo, Packet, i, Pipe->ExecTimerValue);
            }

            /* send the packet corresponding to this flow here */
            UNLOCK_PIPE(Pipe);
            
            while( !IsListEmpty( &SendList ))
            {
				PPACKET_INFO_BLOCK PacketInfo;

            	PacketInfo = (PPACKET_INFO_BLOCK)RemoveHeadList(&SendList);

	            if (!(*Pipe->ContextInfo.NextComponent->SubmitPacket)(
	                        Pipe->ContextInfo.NextComponentContext,
	                        Flow->ContextInfo.NextComponentContext,
	                        (PacketInfo->ClassMapContext != NULL) ?
	                          ((PPS_CLASS_MAP_CONTEXT)PacketInfo->ClassMapContext)->NextComponentContext: NULL,
	                        PacketInfo)) 
	            {
	                (*Pipe->PsProcs->DropPacket)(	Pipe->PsPipeContext, 
	                								Flow->PsFlowContext, 
	                								PacketInfo->NdisPacket, 
	                								NDIS_STATUS_FAILURE);
	            }
            }

            LOCK_PIPE(Pipe);
        }

        /* Now, we need to re-insert back all the non-zero loop counts into the same buckets (before we move on ) */
        while( !IsListEmpty( &FlowList) )
        {
            CurrentLink = RemoveHeadList( &FlowList );
            InsertTailList(ListHead, CurrentLink);
        }            
        
        /* We have traversed the whole length.. */
        if(ListHead == ListEnd)
            break;

        /* Need to move ListHead to next slot.. */
        i = ( (i+1) & ((1 << Pipe->TimerWheelShift) - 1)  );
        ListHead = (PLIST_ENTRY)((char*)Pipe->pTimerWheel + (sizeof(LIST_ENTRY)* i));

        Pipe->ExecSlot = i;
        Pipe->ExecTimerValue.QuadPart ++;
    }


    //
    //  Need to find the "next non-empty slot" and set the timer. 
    //  If no such slot is found, do not set the timer.
    //

    i = ( CurrentSlot + 1) & ((1 << Pipe->TimerWheelShift) - 1) ;
    
    TenMs.QuadPart = 1;

    while(1)
    {
        ListHead = (PLIST_ENTRY)((char*)Pipe->pTimerWheel + (sizeof(LIST_ENTRY)* i));

        if( !IsListEmpty( ListHead) )
        {
            // found a non-empty slot //
            Pipe->SetSlotValue = i;
            Pipe->SetTimerValue.QuadPart = (Ms.QuadPart >> TIMER_WHEEL_SHIFT) + TenMs.QuadPart;

            Pipe->TimerStatus = TIMER_SET;
    	    NdisMSetTimer(&Pipe->Timer, (UINT)(TenMs.QuadPart << TIMER_WHEEL_SHIFT));

    	    UNLOCK_PIPE(Pipe);
    	    return;
        }

        if( i == CurrentSlot)
            break;

        i = ((i +1) & ((1 << Pipe->TimerWheelShift) - 1) );
        TenMs.QuadPart  = TenMs.QuadPart + 1;
    }

    Pipe->TimerStatus = TIMER_INACTIVE;
    UNLOCK_PIPE(Pipe);
    return;

} // ServiceActiveFlows





BOOLEAN
TbcSubmitPacket (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PPS_CLASS_MAP_CONTEXT ClassMapContext,
    IN PPACKET_INFO_BLOCK PacketInfo
    )

/*++

Routine Description:

    Packet submission routine for token bucket conformer.

Arguments:

    PipeContext -   Pointer to this component's pipe context area
    FlowContext -   Pointer to this component's flow context area
    Packet -        Pointer to packet

Return Values:

    Status value from next component

--*/
{
    PTBC_PIPE Pipe = (PTBC_PIPE)PipeContext;
    PTBC_FLOW Flow = (PTBC_FLOW)FlowContext;
    PNDIS_PACKET Packet = PacketInfo->NdisPacket;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER ConformanceTime;
    LARGE_INTEGER TransmitTime;
    LARGE_INTEGER PeakConformanceTime;
    ULONG Credits;
    ULONG PacketLength;
    BOOLEAN TimerCancelled;
    LONGLONG RelTimeInMillisecs;
    BOOLEAN Status;
#ifdef QUEUE_LIMIT
    PPACKET_INFO_BLOCK PacketToBeDroppedInfo;
#endif // QUEUE_LIMIT


    PsGetCurrentTime(&CurrentTime);


    if (Flow->NoConformance) {

        // The conformance time calculation is not performed for certain types of
        // flows.  If the flow does not have a specified rate, we cannot really do
        // token bucket.  Flows that use the "borrow+" shape/discard mode only use
        // their rate as a relative weight.  For either of these types of flows
        // there is no distinction between conforming and non-conforming traffic.
        // So, we just set the "conformance" time to the current time to insure
        // that all packets will be handled as conforming in subsequent components.

        PacketInfo->ConformanceTime.QuadPart = CurrentTime.QuadPart;

    }
    else {

	// We decided to not use the MinPolicedSize as per WMT request. This makes the overhead
	// calculation complicated and incorrect.
        PacketLength = 	//(PacketInfo->PacketLength < Flow->MinPolicedUnit) ? Flow->MinPolicedUnit : 
			PacketInfo->PacketLength;

        LOCK_FLOW(Flow);

        // Set ConformanceTime to the earliest time at which the packet may
        // possibly go out, based on the token bucket parameters, and Credits
        // to the number of credits available at that time.


        if (CurrentTime.QuadPart > Flow->LastConformanceTime.QuadPart) {

            ConformanceTime = CurrentTime;
            Credits = Flow->LastConformanceCredits +
                      EARNED_CREDITS(
                            CurrentTime.QuadPart - Flow->LastConformanceTime.QuadPart,
                            Flow->TokenRate);
        }
        else {
            ConformanceTime = Flow->LastConformanceTime;
            Credits = Flow->LastConformanceCredits;
        }

        if (Credits > Flow->Capacity) {
            Credits = Flow->Capacity;
        }

        // Now check whether there are enough credits to send the packet at ConformanceTime

        if (Credits < PacketLength) {

            // If there aren't enough credits, update ConformanceTime to the time at which
            // there will be enough credits

            ConformanceTime.QuadPart +=
                (LONGLONG)TIME_TO_EARN_CREDITS(PacketLength - Credits, Flow->TokenRate);


            // Now update Credits to be the number of credits available at ConformanceTime,
            // taking this packet into account.  In this case, the number of credits
            // at ConformanceTime will be zero.

            Credits = 0;

            // If it has to wait to earn credits, it's non-conforming
            Flow->cStats.NonconformingPacketsScheduled ++;
            Pipe->cStats.NonconformingPacketsScheduled ++;
        }
        else {
            // There are enough credits, so the packet can be sent at ConformanceTime.  Update
            // Credits to be the number of credits available at ConformanceTime, taking this
            // packet into account.    
            
            Credits -= PacketLength;
        }

        // Calculate the adjusted conformance time, which is the maximum of the
        // token bucket conformance time and the peak conformance time.  

        if (Flow->PeakRate != QOS_NOT_SPECIFIED) 
        { 
            PeakConformanceTime =   (Flow->PeakConformanceTime.QuadPart < CurrentTime.QuadPart) ?
                                    CurrentTime : Flow->PeakConformanceTime;

            TransmitTime =  (PeakConformanceTime.QuadPart < ConformanceTime.QuadPart) ?
                            ConformanceTime : PeakConformanceTime;

        } else {

            PeakConformanceTime = Flow->LastConformanceTime;
            TransmitTime = ConformanceTime;
        }

        // Perform mode-specific operations.  For discard mode flows, check whether
        // the packet should be dropped.  For all flows, set the packet conformance
        // times based on the pipe/flow mode.  The packet's conformance time is the
        // time at which the packet should be considered conforming.  The delay time
        // is the earliest time at which a packet is eligible for sending.

        // When deciding whether to drop a packet, we consider a packet conforming if
        // its conformance time is within half a clock tick of the current time.

        if (Flow->Mode == TC_NONCONF_DISCARD) {

            if (Pipe->IntermediateSystem) {
                if (!PACKET_IS_CONFORMING(TransmitTime, CurrentTime, Pipe->TimerResolution)) {
                    UNLOCK_FLOW(Flow);


                    PsDbgSched(DBG_TRACE, DBG_SCHED_TBC,
                               TBC_CONFORMER, PKT_DISCARD, Flow->PsFlowContext,
                               Packet, PacketInfo->PacketLength, 0,
                               CurrentTime.QuadPart,
                               TransmitTime.QuadPart, 0, 0);

                    return FALSE;
                }
            } else {
                if (!PACKET_IS_CONFORMING(ConformanceTime, CurrentTime, Pipe->TimerResolution)) {
                    UNLOCK_FLOW(Flow);


                    PsDbgSched(DBG_TRACE, DBG_SCHED_TBC, 
                               TBC_CONFORMER, PKT_DISCARD, Flow->PsFlowContext,
                               Packet, PacketInfo->PacketLength, 0,
                               CurrentTime.QuadPart,
                               ConformanceTime.QuadPart, 0, 0);

                    return FALSE;
                }
            }
        }

        // Update the flow's variables

        if (Flow->PeakRate != QOS_NOT_SPECIFIED) {
            Flow->PeakConformanceTime.QuadPart = 
                PeakConformanceTime.QuadPart + (LONGLONG)TIME_TO_SEND(PacketLength, Flow->PeakRate);
        }
        
        Flow->LastConformanceTime = ConformanceTime;
        Flow->LastConformanceCredits = Credits;
                
        UNLOCK_FLOW(Flow);

        // Set the packet conformance times

        if (Pipe->IntermediateSystem) {

            if (Flow->Mode == TC_NONCONF_SHAPE) {

                // Both conformance times are the adjusted conformance time.

                PacketInfo->ConformanceTime.QuadPart =
                PacketInfo->DelayTime.QuadPart = TransmitTime.QuadPart;

                //
                // If the packet is going to remain for > 5 min, discard it.
                //
                if(TransmitTime.QuadPart > CurrentTime.QuadPart &&
                   OS_TIME_TO_MILLISECS((TransmitTime.QuadPart - CurrentTime.QuadPart)) 
                   > MAX_TIME_FOR_PACKETS_IN_SHAPER)
                {
                    return FALSE;
                }

            } else {

                // Packet's conformance time is the adjusted conformance time,
                // and the delay time is the current time.

                PacketInfo->ConformanceTime.QuadPart = TransmitTime.QuadPart;
                PacketInfo->DelayTime.QuadPart = CurrentTime.QuadPart;
            }
        } else {

            if (Flow->Mode == TC_NONCONF_SHAPE) {

                // Packet's conformance time is the token bucket conformance time,
                // and the delay time is the adjusted conformance time.

                PacketInfo->ConformanceTime.QuadPart = ConformanceTime.QuadPart;
                PacketInfo->DelayTime.QuadPart = TransmitTime.QuadPart;

                //
                // If the packet is going to remain for > 5 min, discard it.
                //
                if(TransmitTime.QuadPart > CurrentTime.QuadPart &&
                   OS_TIME_TO_MILLISECS((TransmitTime.QuadPart - CurrentTime.QuadPart)) 
                   > MAX_TIME_FOR_PACKETS_IN_SHAPER)
                {
                    return FALSE;
                }

            } else {

                // Packet's conformance time is the token bucket conformance time, and
                // the delay time is the peak conformance time.

                PacketInfo->ConformanceTime.QuadPart = ConformanceTime.QuadPart;
                PacketInfo->DelayTime.QuadPart = PeakConformanceTime.QuadPart;
            }
        }
    }

    // Pass the packet on

    PsDbgSched(DBG_INFO, DBG_SCHED_TBC, 
               TBC_CONFORMER, PKT_CONFORMANCE, Flow->PsFlowContext,
               Packet, PacketInfo->PacketLength, 0,
               CurrentTime.QuadPart,
               (Pipe->IntermediateSystem) ? 
               TransmitTime.QuadPart : ConformanceTime.QuadPart, 0, 0);


    if (!Flow->Shape) 
    {
        // No shaping in effect. Pass the packet on.

        /*  Since the packet is not being shaped, it could be non-conformant. So, need to reset it's 802.1p and 
            IP-Precedence values. */

        if( (!Flow->NoConformance)  &&
            !PACKET_IS_CONFORMING(PacketInfo->ConformanceTime, CurrentTime, Pipe->TimerResolution))
        {
            NDIS_PACKET_8021Q_INFO  VlanPriInfo;

            VlanPriInfo.Value = NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, Ieee8021QInfo);
            VlanPriInfo.TagHeader.UserPriority = PacketInfo->UserPriorityNonConforming;
            NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, Ieee8021QInfo) = VlanPriInfo.Value;
            // Reset the TOS byte for IP Packets.
            if(NDIS_GET_PACKET_PROTOCOL_TYPE(Packet) == NDIS_PROTOCOL_ID_TCP_IP) {

                if(!PacketInfo->IPHdr) {

                    PacketInfo->IPHdr = GetIpHeader(PacketInfo->IPHeaderOffset, Packet);
                }
                    
                SET_TOS_XSUM(Packet, 
                             PacketInfo->IPHdr, 
                             PacketInfo->TOSNonConforming);
            }
        }            
            
        return (*Pipe->ContextInfo.NextComponent->SubmitPacket)(
                    Pipe->ContextInfo.NextComponentContext,
                    Flow->ContextInfo.NextComponentContext,
                    (ClassMapContext != NULL) ? ClassMapContext->NextComponentContext : NULL,
                    PacketInfo);
    }

    LOCK_PIPE(Pipe);

    if(Flow->State == TS_FLOW_DELETED) 
	{
        UNLOCK_PIPE(Pipe);
        return FALSE;
    }

    
    /*  At this point, the conf-time of the packet is in TransmitTime 
        and the packetino->DelayTime has this info.
    */

    PacketInfo->FlowContext = FlowContext;

    // If packet queue is not empty just queue the packet regardless of
    // whether it is eligible.  If it is eligible, the timer proc will
    // detect this and send the packet.  If not, it will insert the flow
    // into the correct location in the flow list if necessary.

    if (!IsListEmpty(&Flow->PacketQueue)) 
    {
        PsDbgSched(DBG_INFO, 
                   DBG_SCHED_SHAPER,
                   SHAPER, PKT_ENQUEUE, Flow->PsFlowContext,
                   Packet, PacketInfo->PacketLength, 0, 
                   0,
                   PacketInfo->DelayTime.QuadPart,
                   Pipe->PacketsInShaper,
                   0);

        PacketInfo->ClassMapContext = ClassMapContext;
        InsertTailList(&Flow->PacketQueue, &PacketInfo->SchedulerLinks);
    }
    else if(PacketIsEligible(PacketInfo, Flow, CurrentTime, ((TIMER_WHEEL_QTY/2) * MSIN100NS) ))
    {
            // Packet is eligible, so pass the packet on.
            UNLOCK_PIPE(Pipe);

            PsDbgSched(DBG_INFO, 
                       DBG_SCHED_SHAPER,
                       SHAPER, PKT_DEQUEUE, Flow->PsFlowContext,
                       Packet, PacketInfo->PacketLength, 0, 
                       CurrentTime.QuadPart,
                       PacketInfo->DelayTime.QuadPart,
                       Pipe->PacketsInShaper,
                       0);

            return (*Pipe->ContextInfo.NextComponent->SubmitPacket)(
                        Pipe->ContextInfo.NextComponentContext,
                        Flow->ContextInfo.NextComponentContext,
                        (ClassMapContext != NULL) ? ClassMapContext->NextComponentContext : NULL,
                        PacketInfo);
    }
    else
    {
        //  So, the packet is not eligible to be sent out right now, and the pkt-queue is empty 

        ULONG           Slot= 0;
        LARGE_INTEGER   Ms;
        LARGE_INTEGER   TenMs;
        LARGE_INTEGER   CurrentTimeInMs, CurrentTimeInTenMs;
        LONGLONG        DeltaTimeInMs;
        PLIST_ENTRY     pList = NULL;
        BOOL            Success = FALSE;
        //
        //  The first thing we do here is: If there is no timer allocated for this pipe, allocate one    
        //  The FIRST packet to be shaped on the pipe will take a hit due to this..
        //
        
        if( !Pipe->pTimerWheel )
        {
            ULONG i =0;
            
            PsAllocatePool( Pipe->pTimerWheel, 
                            (sizeof(LIST_ENTRY) << Pipe->TimerWheelShift ), 
                            TimerTag);

            if( !Pipe->pTimerWheel)
            {
                UNLOCK_PIPE(Pipe);

                // If we could not allocate memory for the timer, we are not going to shape the packet  //
                return (*Pipe->ContextInfo.NextComponent->SubmitPacket)(
                        Pipe->ContextInfo.NextComponentContext,
                        Flow->ContextInfo.NextComponentContext,
                        (ClassMapContext != NULL) ? ClassMapContext->NextComponentContext : NULL,
                        PacketInfo);
            }        

            //  Initialize the Timer wheel  //
            pList = (PLIST_ENTRY)(Pipe->pTimerWheel);                    
            for( i = 0; i < (ULONG) (1 << Pipe->TimerWheelShift); i++)
            {
                InitializeListHead( pList );
                pList = (PLIST_ENTRY)((PCHAR)pList + sizeof(LIST_ENTRY));
            }
        }


        Ms.QuadPart= 0;

        PsDbgSched(DBG_INFO, 
                   DBG_SCHED_SHAPER,
                   SHAPER, PKT_ENQUEUE, Flow->PsFlowContext,
                   Packet, PacketInfo->PacketLength, 0, 
                   CurrentTime.QuadPart,
                   PacketInfo->DelayTime.QuadPart,
                   Pipe->PacketsInShaper,
                   0);

        PacketInfo->ClassMapContext = ClassMapContext;
        InsertTailList(&Flow->PacketQueue, &PacketInfo->SchedulerLinks);

        /* update the eligibility timer of the flow.. */
        Flow->FlowEligibilityTime.QuadPart = PacketInfo->DelayTime.QuadPart;

        /* Conf time in ms and 10ms */
        Ms.QuadPart = OS_TIME_TO_MILLISECS( Flow->FlowEligibilityTime.QuadPart );
        TenMs.QuadPart = Ms.QuadPart >> TIMER_WHEEL_SHIFT;

        CurrentTimeInMs.QuadPart = OS_TIME_TO_MILLISECS( CurrentTime.QuadPart);
        CurrentTimeInTenMs.QuadPart = CurrentTimeInMs.QuadPart >> TIMER_WHEEL_SHIFT;

        /* Update the loop count too */
        Flow->LoopCount = (ULONG)( (TenMs.QuadPart - CurrentTimeInTenMs.QuadPart) >> Pipe->TimerWheelShift );

        if( Pipe->TimerStatus == TIMER_INACTIVE)
        {
            /* Figure out the Slot for this time.. */
            Slot = (ULONG)( (TenMs.QuadPart) & ((1 << Pipe->TimerWheelShift) - 1 ) );

            Pipe->SetTimerValue.QuadPart = TenMs.QuadPart - (Flow->LoopCount << Pipe->TimerWheelShift);
            Pipe->SetSlotValue = Slot;

            /* Need to insert the flow to the timer-wheel in slot's position*/
            pList = (PLIST_ENTRY)( (char*)Pipe->pTimerWheel + ( sizeof(LIST_ENTRY) * Slot) );
            InsertTailList(pList, &Flow->Links);

            Pipe->TimerStatus = TIMER_SET;
            NdisMSetTimer(&Pipe->Timer, (UINT)((Pipe->SetTimerValue.QuadPart - CurrentTimeInTenMs.QuadPart) << TIMER_WHEEL_SHIFT) );
        }
        else if( Pipe->TimerStatus == TIMER_SET)
        {
            if( TenMs.QuadPart <= Pipe->SetTimerValue.QuadPart)
            {
                Flow->LoopCount = 0;
                    
                /* Try to cancel the timer and re-set it */
                NdisMCancelTimer( &Pipe->Timer, (PBOOLEAN)&Success );

                if( Success)
                {
                    /* Figure out the Slot for this time.. */
                    Slot = (ULONG)( (TenMs.QuadPart) & ((1 << Pipe->TimerWheelShift) - 1) );

                    // Pipe->SetTimerValue.QuadPart = TenMs.QuadPart - Flow->LoopCount * Pipe->TimerWheelSize ;
                    Pipe->SetTimerValue.QuadPart = TenMs.QuadPart - (Flow->LoopCount << Pipe->TimerWheelShift) ;
                    Pipe->SetSlotValue = Slot;

                    /* Need to insert the flow to the timer-wheel in slot's position*/
                    pList = (PLIST_ENTRY)( (char*)Pipe->pTimerWheel + ( sizeof(LIST_ENTRY) * Slot) );
                    InsertTailList(pList, &Flow->Links);

                    NdisMSetTimer(&Pipe->Timer, (UINT)((Pipe->SetTimerValue.QuadPart - CurrentTimeInTenMs.QuadPart) << TIMER_WHEEL_SHIFT));
                }
                else
                {
                    /* Need to insert the flow to the timer-wheel in slot's position*/
                    pList = (PLIST_ENTRY)( (char*)Pipe->pTimerWheel + ( sizeof(LIST_ENTRY) * Pipe->SetSlotValue) );
                    InsertTailList(pList, &Flow->Links);
                }                
            }
            else
            {
                Flow->LoopCount = (ULONG)( (TenMs.QuadPart - Pipe->SetTimerValue.QuadPart) >> Pipe->TimerWheelShift );

                /* Figure out the Slot for this time.. */
                Slot = (ULONG)( (TenMs.QuadPart) & ((1 << Pipe->TimerWheelShift) - 1) );

                /* Need to insert the flow to the timer-wheel in slot's position*/
                pList = (PLIST_ENTRY)( (char*)Pipe->pTimerWheel + ( sizeof(LIST_ENTRY) * Slot) );
                InsertTailList(pList, &Flow->Links);
            }
        }
        else 
        {
            PsAssert( Pipe->TimerStatus == TIMER_PROC_EXECUTING);

            if( TenMs.QuadPart <= Pipe->ExecTimerValue.QuadPart)
            {
                PsAssert( Flow->LoopCount == 0);        
        
                Slot = (ULONG)((Pipe->ExecSlot + 1) & ((1 << Pipe->TimerWheelShift) - 1) );

                /* Need to insert the flow to the timer-wheel in slot's position*/
                pList = (PLIST_ENTRY)( (char*)Pipe->pTimerWheel + ( sizeof(LIST_ENTRY) * Slot) );
                InsertTailList(pList, &Flow->Links);
            }
            else
            {
                Flow->LoopCount = (ULONG)( (TenMs.QuadPart - Pipe->ExecTimerValue.QuadPart) >> Pipe->TimerWheelShift );

                /* Figure out the Slot for this time.. */
                Slot = (ULONG)( (TenMs.QuadPart) & ((1 << Pipe->TimerWheelShift) - 1) );

                if( Slot == Pipe->ExecSlot)
                    Slot = ( (Slot + 1) & ((1 << Pipe->TimerWheelShift) - 1) );

                /* Need to insert the flow to the timer-wheel in slot's position*/
                pList = (PLIST_ENTRY)( (char*)Pipe->pTimerWheel + ( sizeof(LIST_ENTRY) * Slot) );
                InsertTailList(pList, &Flow->Links);
            }
        }
    }

    Pipe->PacketsInShaper++;
    if(Pipe->PacketsInShaper > Pipe->sStats.MaxPacketsInShaper){
        Pipe->sStats.MaxPacketsInShaper = Pipe->PacketsInShaper;
    }
    
    Flow->PacketsInShaper++;
    if (Flow->PacketsInShaper > Flow->sStats.MaxPacketsInShaper) {
        Flow->sStats.MaxPacketsInShaper = Flow->PacketsInShaper;
    }


    if(gEnableAvgStats)
    {
        Pipe->sStats.AveragePacketsInShaper =
            RunningAverage(Pipe->PacketsInShaperAveragingArray, Pipe->PacketsInShaper);

        Flow->sStats.AveragePacketsInShaper =
            RunningAverage(Flow->PacketsInShaperAveragingArray, Flow->PacketsInShaper);
    }

    UNLOCK_PIPE(Pipe);

    return TRUE;

} // TbcSubmitPacket



VOID
TbcSetInformation (
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_FLOW_CONTEXT ComponentFlowContext,
    IN NDIS_OID Oid,
    IN ULONG Len,
    IN PVOID Data)
{
    PTBC_PIPE Pipe = (PTBC_PIPE)ComponentPipeContext;
    PTBC_FLOW Flow = (PTBC_FLOW)ComponentFlowContext;
  

    switch(Oid) 
    {
      case OID_QOS_STATISTICS_BUFFER:

          if(Flow) 
          {
              NdisZeroMemory(&Flow->cStats, sizeof(PS_CONFORMER_STATS));
              NdisZeroMemory(&Flow->sStats, sizeof(PS_SHAPER_STATS));
          }
          else 
          {  
              NdisZeroMemory(&Pipe->cStats, sizeof(PS_CONFORMER_STATS));
              NdisZeroMemory(&Pipe->sStats, sizeof(PS_SHAPER_STATS));
          }

          break;
      default:
          break;
    }

    (*Pipe->ContextInfo.NextComponent->SetInformation)(
        Pipe->ContextInfo.NextComponentContext,
        (Flow)?Flow->ContextInfo.NextComponentContext:0,
        Oid,
        Len,
        Data);
}


VOID
TbcQueryInformation (
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_FLOW_CONTEXT ComponentFlowContext,
    IN NDIS_OID Oid,
    IN ULONG Len,
    IN PVOID Data,
    IN OUT PULONG BytesWritten,
    IN OUT PULONG BytesNeeded,
    IN OUT PNDIS_STATUS Status)
{
    PTBC_PIPE Pipe = (PTBC_PIPE)ComponentPipeContext;
    PTBC_FLOW Flow = (PTBC_FLOW)ComponentFlowContext;
    ULONG   Size;
    ULONG   cSize, sSize;
    ULONG RemainingLength;

    switch(Oid) 
    {
      case OID_QOS_STATISTICS_BUFFER:

          cSize =   sizeof(PS_CONFORMER_STATS)  +   FIELD_OFFSET(PS_COMPONENT_STATS, Stats);
          sSize =   sizeof(PS_SHAPER_STATS)     +   FIELD_OFFSET(PS_COMPONENT_STATS, Stats);
          Size  =   cSize + sSize;

          if(*Status == NDIS_STATUS_SUCCESS) 
          {
              //
              // The previous component has succeeded - Let us
              // see if we can write the data
              //

              RemainingLength = Len - *BytesWritten;
    
              if(RemainingLength < Size) {

                  *Status = NDIS_STATUS_BUFFER_TOO_SHORT;

                  *BytesNeeded = Size + *BytesWritten;

                  *BytesWritten = 0;

              }
              else {

                  PPS_COMPONENT_STATS Cstats = (PPS_COMPONENT_STATS) Data;

                  *BytesWritten += Size;
                  
                  *BytesNeeded = 0;

                  if(Flow) 
                  {
                      // Per flow stats
                      Cstats->Type = PS_COMPONENT_CONFORMER;
                      Cstats->Length = sizeof(PS_CONFORMER_STATS);
                      
                      NdisMoveMemory(&Cstats->Stats, &Flow->cStats, sizeof(PS_CONFORMER_STATS));

                      // Move the pointer to point after the conf. stats.. //
                      Cstats = (PPS_COMPONENT_STATS)((PUCHAR)Cstats + cSize);

                      Cstats->Type = PS_COMPONENT_SHAPER;
                      Cstats->Length = sizeof(PS_SHAPER_STATS);
                      
                      NdisMoveMemory(&Cstats->Stats, &Flow->sStats, sizeof(PS_SHAPER_STATS));
                      
                      
                  }
                  else 
                  {
                      // Per adapter stats
                      Cstats->Type = PS_COMPONENT_CONFORMER;
                      Cstats->Length = sizeof(PS_CONFORMER_STATS);
                      
                      NdisMoveMemory(&Cstats->Stats, &Pipe->cStats, sizeof(PS_CONFORMER_STATS));

                      // Move the pointer to point after the shaper. stats.. //
                      Cstats = (PPS_COMPONENT_STATS)((PUCHAR)Cstats + cSize);
                      
                      Cstats->Type = PS_COMPONENT_SHAPER;
                      Cstats->Length = sizeof(PS_SHAPER_STATS);
                      
                      NdisMoveMemory(&Cstats->Stats, &Pipe->sStats, sizeof(PS_SHAPER_STATS));
                  }


                  // 
                  // Advance Data so that the next component can update its stats
                  //
                  Data = (PVOID) ((PUCHAR)Data + Size);
              }
          }
          else {

              *BytesNeeded += Size;
              
              *BytesWritten = 0;
          }


          break;
          
      default:

          break;
    }

    (*Pipe->ContextInfo.NextComponent->QueryInformation)(
        Pipe->ContextInfo.NextComponentContext,
        (Flow)?Flow->ContextInfo.NextComponentContext : 0,
        Oid,
        Len,
        Data,
        BytesWritten,
        BytesNeeded,
        Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\debug.h ===
/*++

Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    debug defines shared between the KD extensions and the driver

Author:

    Charlie Wickham (charlwi) 11-May-1995

Revision History:

--*/

#ifndef _DEBUG_
#define _DEBUG_

//
//
// Debug Level and Mask definitions.
//

#define DBG_DEATH               1
#define DBG_CRITICAL_ERROR      2
#define DBG_FAILURE             4
#define DBG_INFO                6
#define DBG_TRACE               8
#define DBG_VERBOSE             10

#define DBG_INIT                0x00000001
#define DBG_MINIPORT            0x00000002
#define DBG_PROTOCOL            0x00000004
#define DBG_SEND                0x00000008
#define DBG_RECEIVE             0x00000010
#define DBG_IO                  0x00000020
#define DBG_MEMORY              0x00000040
#define DBG_CM                  0x00000080
#define DBG_REFCNTS             0x00000100
#define DBG_VC                  0x00000200
#define DBG_GPC_QOS             0x00000400
#define DBG_WAN                 0x00000800
#define DBG_STATE               0x00001000
#define DBG_ROUTINEOIDS         0x00002000
#define DBG_SCHED_TBC           0x00004000
#define DBG_SCHED_SHAPER        0x00008000
#define DBG_SCHED_DRR           0x00010000
#define DBG_WMI                 0x00020000
#define DBG_ZAW                 0x00040000
#define DBG_ALL                 0xFFFFFFFF

//
// these tags are used in Lookaside lists therefore need to be 
// available regardless of the type of build
//

extern ULONG NdisRequestTag;
extern ULONG GpcClientVcTag;
extern ULONG WanLinkTag;
extern ULONG PsMiscTag;
extern ULONG WMITag;
#define NDIS_PACKET_POOL_TAG_FOR_PSCHED 'pPDN'

// We mark all memory allocated via PsAllocateXXX with a signature 
// immediately following allocation, and with another signature 
// immediately preceeding freeing.

#define ALLOCATED_MARK  (UCHAR) 0xDD
#define FREED_MARK      (UCHAR) 0xBB

//
// NT Debugging routines
//


//
// signatures for data structures
//

extern ULONG AdapterTag;
extern ULONG CmParamsTag;
extern ULONG PipeContextTag;
extern ULONG FlowContextTag;
extern ULONG ClassMapContextTag;
extern ULONG ProfileTag;
extern ULONG ComponentTag;
extern ULONG WanTableTag;

#if DBG
extern CHAR VersionNumber[];
extern CHAR VersionHerald[];
extern CHAR VersionTimestamp[];

#define DEBUGCHK    DbgBreakPoint()

#define STATIC

//
// these correspond to DebugLevel and DebugMask in Psched\Parameters
//

extern ULONG DbgTraceLevel;
extern ULONG DbgTraceMask;
extern ULONG LogTraceLevel;
extern ULONG LogTraceMask;
extern ULONG LogId;
extern ULONG DbgTraceControl;

#define PsDbgSched(_DebugLevel, _DebugMask, _r, _s, _t, _u, _v, _w, _x1, _x2, _y, _z){\
    if ((LogTraceLevel >= _DebugLevel) &&          \
        ((_DebugMask) & LogTraceMask)){            \
             DbugSched(_r, _s, _t, _u, _v, _w, (_x1), (_x2), _y, _z);\
    }\
}

#define PsDbgRecv(_DebugLevel, _DebugMask, _event, _action, _a, _p1, _p2) {\
    if ((LogTraceLevel >= _DebugLevel) &&                                  \
        ((_DebugMask) & LogTraceMask)){                                    \
            DbugRecv(_event, _action, _a, _p1, _p2);                       \
    }                                                                      \
}

#define PsDbgSend(_DebugLevel, _DebugMask, _event, _action, _a, _v, _p1, _p2) {\
    if ((LogTraceLevel >= _DebugLevel) &&                                      \
        ((_DebugMask) & LogTraceMask)){                                        \
            DbugSend(_event, _action, _a, _v, _p1, _p2);                       \
    }                                                                          \
}

#define PsDbgOid(_DebugLevel, _DebugMask, Action, Local, PTState, MPState, Adapter, Oid, Status) {\
    if ((LogTraceLevel >= _DebugLevel) &&                                       \
        ((_DebugMask) & LogTraceMask)){                                         \
            DbugOid(Action, Local, PTState, MPState, Adapter, Oid, Status);     \
    }                                                                           \
}

#define PsDbgOut(_DebugLevel, _DebugMask, _Out){   \
    if ((DbgTraceLevel >= _DebugLevel) &&           \
        ((_DebugMask) & DbgTraceMask)){             \
        DbgPrint("PSched: ");                       \
        DbgPrint _Out;                              \
    }                                               \
    if ((LogTraceLevel >= _DebugLevel) &&           \
        ((_DebugMask) & LogTraceMask)){             \
        DbugSchedString _Out;                       \
    }                                               \
}

#define PsDbgOutNoID(_DebugLevel, _DebugMask, _Out) {   \
    if ((DbgTraceLevel >= _DebugLevel) &&           \
        ((_DebugMask) & DbgTraceMask)){             \
        DbgPrint _Out;                              \
    }                                               \
    if ((LogTraceLevel >= _DebugLevel) &&           \
        ((_DebugMask) & LogTraceMask)){             \
        DbugSchedString _Out;                       \
    }                                               \
}

#define PS_LOCK(_s)                                 {               \
    NdisAcquireSpinLock(&((_s)->Lock));                             \
    PsAssert((_s)->LockAcquired == FALSE);                          \
    (_s)->LockAcquired = TRUE;                                      \
    (_s)->LastAcquiredLine = __LINE__;                              \
    strncpy((_s)->LastAcquiredFile, strrchr(__FILE__, '\\')+1, 7);  \
}

#define PS_UNLOCK(_s)                                               \
{                                                                   \
    PsAssert((_s)->LockAcquired == TRUE);                           \
    (_s)->LockAcquired = FALSE;                                     \
    (_s)->LastReleasedLine = __LINE__;                              \
    strncpy((_s)->LastReleasedFile, strrchr(__FILE__, '\\')+1, 7);  \
    NdisReleaseSpinLock(&((_s)->Lock));                             \
}

#define PS_LOCK_DPC(_s) {                                           \
    PsAssert(KeGetCurrentIrql() == DISPATCH_LEVEL);                 \
    NdisDprAcquireSpinLock(&((_s)->Lock));                          \
    PsAssert((_s)->LockAcquired == FALSE);                          \
    (_s)->LockAcquired = TRUE;                                      \
    (_s)->LastAcquiredLine = __LINE__;                              \
    strncpy((_s)->LastAcquiredFile, strrchr(__FILE__, '\\')+1, 7);  \
}

#define PS_UNLOCK_DPC(_s)                                           \
{                                                                   \
    PsAssert(KeGetCurrentIrql() == DISPATCH_LEVEL);                 \
    PsAssert((_s)->LockAcquired == TRUE);                           \
    (_s)->LockAcquired = FALSE;                                     \
    (_s)->LastReleasedLine = __LINE__;                              \
    strncpy((_s)->LastReleasedFile, strrchr(__FILE__, '\\')+1, 7);  \
    NdisDprReleaseSpinLock(&((_s)->Lock));                          \
}

#define PS_INIT_SPIN_LOCK(_s) {                                     \
    (_s)->LockAcquired = FALSE;                                     \
    (_s)->LastAcquiredLine = __LINE__;                              \
    strncpy((_s)->LastAcquiredFile, strrchr(__FILE__, '\\')+1, 7);  \
    NdisAllocateSpinLock(&((_s)->Lock));                            \
}

#define KdPrint( x )    DbgPrint x

#define STRUCT_LLTAG   ULONG LLTag

#define PsStructAssert(_tag) if ((_tag) != NULL && *(PULONG)((PUCHAR)_tag - sizeof(ULONG)) != _tag##Tag) {\
    DbgPrint( "PSched: structure assertion failure for type " #_tag " in file " __FILE__ " line %d\n", __LINE__ );\
    DEBUGCHK;\
    }

#define PsAssert(c)    if (!(c)) {\
    DbgPrint( "PSched: assertion @ line %d in file " __FILE__ " \n", __LINE__ );\
    DEBUGCHK;\
    }

//
// allocate memory from nonpaged pool and set the tag in the checked
// version of the structure
//

#define PsAllocatePool( _addr, _size, _tag )                                  \
{                                                                             \
    PCHAR _Temp;                                                              \
    ULONG _Size = (_size) + 2 * sizeof(ULONG);                                \
    _Temp = ExAllocatePoolWithTag( NonPagedPool, (_Size), (_tag));            \
    if ( _Temp ) {                                                            \
        NdisFillMemory( _Temp, _Size, ALLOCATED_MARK);                        \
        *(PULONG)_Temp = _Size;                                               \
        *(PULONG)(_Temp + sizeof(ULONG)) = _tag;                              \
        (PCHAR)(_addr) = _Temp + 2 * sizeof(ULONG);                           \
    }                                                                         \
    else{                                                                     \
        (PCHAR)(_addr) = _Temp;                                               \
    }                                                                         \
}

#define PsFreePool(_addr)                                                   \
{                                                                           \
    PCHAR _Temp = (PCHAR)(_addr) - 2 * sizeof(ULONG);                       \
    ULONG _Size = *(PULONG)_Temp;                                           \
    NdisFillMemory( _Temp, _Size, FREED_MARK);                              \
    ExFreePool(_Temp);                                                      \
}

//
// structures allocated from lookaside lists don't go through PsAllocateXXX.
// so - if we wanna tag these, we'll have to macro the LL routines.
//

#define PsAllocFromLL(_ptr, _list, _tag) \
    *_ptr = NdisAllocateFromNPagedLookasideList(_list); \
    if(*_ptr != 0) {\
        *_ptr->LLTag = _tag##Tag; \
    }

#define PsFreeToLL(_ptr, _list, _tag) \
    PsAssert(_ptr->LLTag == _tag##Tag); \
    _ptr->LLTag = (ULONG)0; \
    NdisFreeToNPagedLookasideList(_list, _ptr); \

#define CheckLLTag(_ptr, _tag) \
    PsAssert(_ptr->LLTag == _tag##Tag); 

#define SetLLTag(_ptr, _tag) (_ptr)->LLTag = _tag##Tag;

#else // DBG

#define DEBUGCHK
#define PsDbgSched(_DebugLevel, _DebugMask, _r, _s, _t, _u, _v, _w, _x1, _x2, _y, _z)
#define PsDbgRecv(_DebugLevel, _DebugMask, _event, _action, _a, _p1, _p2) 
#define PsDbgSend(_DebugLevel, _DebugMask, _event, _action, _a, _v, _p1, _p2)
#define PsDbgOut(s,t,u)
#define PsDbgOid(p,q,s,t,u,v,w,x,y)
#define PsDbgOutNoID(s,t,u)
#define PsDbg(r, s, t, u)
#define KdPrint( x )
#define STRUCT_LLTAG          /##/
#define PsStructAssert( t )
#define PsAssert(c)
#define PS_LOCK(_s)           NdisAcquireSpinLock(&((_s)->Lock))
#define PS_UNLOCK(_s)         NdisReleaseSpinLock(&((_s)->Lock))
#define PS_LOCK_DPC(_s)       NdisDprAcquireSpinLock(&((_s)->Lock))
#define PS_UNLOCK_DPC(_s)     NdisDprReleaseSpinLock(&((_s)->Lock))
#define PS_INIT_SPIN_LOCK(_s) NdisAllocateSpinLock(&((_s)->Lock))

#define PsAllocatePool( _addr, _size, _tag )                       \
    _addr = ExAllocatePoolWithTag( NonPagedPool, (_size), (_tag)); \
    if ( _addr ) {                                                 \
        NdisZeroMemory( _addr, _size );                            \
    }

#define PsFreePool(_addr)  ExFreePool(_addr)

//
// structures allocated from lookaside lists don't go through PsAllocateXXX.
// so - if we wanna tag these, we'll have to macro the LL routines.
//

#define PsAllocFromLL(_ptr, _list, _tag) \
    *_ptr = (PVOID)NdisAllocateFromNPagedLookasideList(_list); \

#define PsFreeToLL(_ptr, _list, _tag) \
    NdisFreeToNPagedLookasideList(_list, _ptr);

#define CheckLLTag(_ptr, _tag) 
#define SetLLTag(_ptr, _tag)

#define STATIC static

#endif // DBG

#endif /* _DEBUG_ */

/* end debug.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\drrseq.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    DRRSeq.h

Abstract:

    Defines for Priotiry/DRR Sequencer

Author:


Revision History:

--*/

#ifndef _DRRSEQ_H_
#define _DRRSEQ_H_

#include "PktSched.h"

VOID
InitializeDrrSequencer(
    PPSI_INFO Info);

void
UnloadSequencer();

#endif /* _DRRSEQ_H_ */

/* end DRRSeq.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\drrseq.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    DRRSeq.c

Abstract:

    Priority/DRR Sequencer.  This module is a scheduling component that
    determines the order in which submitted packets should be sent.

Author:


Environment:

    Kernel Mode

Revision History:

--*/

#include "psched.h"

#pragma hdrstop

// The sequencer classifies each flow into an internal "priority group" based
// on the flow's service type and conformance status. Within each priority
// group, there may be one or more priority levels or offsets.  The total
// number of internal priority levels is the sum of the priority levels for
// each priority group.  The internal priority assigned to each flow is
// calculated from the priority group and the relative priority within the
// group, which is obtained from the QOS Priority object.  The 802.1 priority,
// is set by the wrapper. The non conforming values are obtained from the 
// packet.
//
// The flows of the following servicetypes have no internal priority.
//     SERVICETYPE_BESTEFFORT
//     SERVICETYPE_NONCONFORMING
//     SERVICETYPE_QUALITATIVE.
// 
// SERVICETYPE_BESTEFFORT is treated as SERVICETYPE_QUALITATIVE in the sequencer, so the no of priority
// groups is 1 less than the no. of servicetypes.

#define RELATIVE_PRIORITIES             8
#define PRIORITY_GROUPS                 (NUM_TC_SERVICETYPES - 1)
#define INTERNAL_PRIORITIES             (((PRIORITY_GROUPS - 2) * RELATIVE_PRIORITIES) + 2)
#define DEFAULT_PRIORITY_OFFSET         3
#define DEFAULT_MIN_QUANTUM             1500

#define PRIORITY_GROUP_NON_CONFORMING   0
#define PRIORITY_GROUP_BEST_EFFORT      1
#define PRIORITY_GROUP_CONTROLLED_LOAD  2
#define PRIORITY_GROUP_GUARANTEED       3
#define PRIORITY_GROUP_NETWORK_CONTROL  4

//
// For maintaining stats
//
#define SEQUENCER_AVERAGING_ARRAY_SIZE      256
#define NETCARD_AVERAGING_ARRAY_SIZE        256
#define SEQUENCER_FLOW_AVERAGING_ARRAY_SIZE     256


// The DRR Sequencer's pipe information

typedef struct _DSEQ_PIPE {

    // ContextInfo -            Generic context info
    // Lock -                   Protects pipe and flow data
    // Flags -                  See below
    // Flows -                  List of all installed flows
    // ActiveFlows -            Lists of flows that are waiting to send packets
    // PriorityLevels -         Number of priority offsets for each priority group
    // StartPriority -          Lowest internal priority value for each priority group
    // ActiveFlowCount -        Number of active flows for each service type
    // MaxOutstandingSends -    Maximum number of outstanding sends
    // OutstandingSends -       Number of outstanding sends
    // PacketsInNetcardAveragingArray
    // PacketsInSequencer -     Current number packets in sequencer
    // PacketsInSequencerAveragingArray
    // Bandwidth -              Link speed
    // MinimumQuantum -         Minimum quantum size for DRR
    // MinimumRate -            Smallest rate currently assigned to a flow
    // TimerResolution -        Timer resolution in OS time units
    // PsFlags -                Flags from pipe parameters
    // PsPipeContext -          PS's pipe context value

    PS_PIPE_CONTEXT ContextInfo;

    PS_DRRSEQ_STATS Stats;
    PRUNNING_AVERAGE PacketsInNetcardAveragingArray;
    ULONG PacketsInSequencer;
    PRUNNING_AVERAGE PacketsInSequencerAveragingArray;

    NDIS_SPIN_LOCK Lock;
    ULONG Flags;
    LIST_ENTRY Flows;
    LIST_ENTRY ActiveFlows[INTERNAL_PRIORITIES];
    ULONG PriorityLevels[PRIORITY_GROUPS];
    ULONG StartPriority[PRIORITY_GROUPS];
    ULONG ActiveFlowCount[PRIORITY_GROUPS];
    ULONG TotalActiveFlows;
    ULONG MaxOutstandingSends;

    ULONG ConfiguredMaxOutstandingSends;
    //  This is added to keep track of what the Registry/User-asked value of MOS is, while we might
    //  have changed MOS to be able to do DRR on this Pipe/WanLink. When we switch back from DRR mode
    //  with MOS=1, we'll use this going forward.

    ULONG IsslowFlowCount;
    //  This is added to keep track of the number of active/current ISSLOW flows. We will do DRR on this
    //  WanLink (if it is a WanLink) only if this count is 0.
    
    ULONG OutstandingSends;
    ULONG Bandwidth;
    ULONG MinimumQuantum;
    ULONG MinimumRate;
    ULONG TimerResolution;
    ULONG PsFlags;
    HANDLE PsPipeContext;
    PPS_PROCS PsProcs;
    PSU_SEND_COMPLETE PreviousUpcallsSendComplete;
    PPS_PIPE_CONTEXT   PreviousUpcallsSendCompletePipeContext;
    
} DSEQ_PIPE, *PDSEQ_PIPE;

// Pipe flag values

#define DSEQ_DEQUEUE            1
#define DSEQ_PASSTHRU           2

typedef enum _FLOW_STATE {
    DRRSEQ_FLOW_CREATED = 1,
    DRRSEQ_FLOW_DELETED
} FLOW_STATE;

// The DRR Sequencer's flow information

typedef struct _DSEQ_FLOW {

    // ContextInfo -            Generic context info
    // ActiveLinks -            Links in active flow list
    // Links -                  Links in installed flow list
    // PacketQueue -            Self-explanatory
    // PacketSendTime -         Send time for current packet
    // LastConformanceTime -    Absolute conformance time of last packet
    // TokenRate -              TokenRate from GQOS
    // UserPriority -           Priority offset assigned by user
    // Priority -               Internal priority
    // PriorityGroup -          Priority group for flow
    // Quantum -                Quantum assigned to flow for DRR
    // DeficitCounter -         Current value of DRR deficit counter
    // Flags -                  See below
    // PsFlowContext -          PS's flow context value
    // BucketSize -             TokenBucketSize from GQOS
    // NumPacketsInSeq -                Number of packets from this flow in the sequencer
    // PacketsInSeqAveragingArray-Data for computing average packets in seq from this flow

    PS_FLOW_CONTEXT ContextInfo;
    LIST_ENTRY ActiveLinks;
    LIST_ENTRY Links;
    LIST_ENTRY PacketQueue;
    LARGE_INTEGER PacketSendTime;
    LARGE_INTEGER LastConformanceTime;
    ULONG TokenRate;
    ULONG UserPriority;
    ULONG Priority;
    ULONG PriorityGroup;
    ULONG Quantum;
    ULONG DeficitCounter;
    ULONG Flags;
    HANDLE PsFlowContext;
    ULONG BucketSize;

    ULONG PacketsInSequencer;
    PS_DRRSEQ_STATS Stats;
    PRUNNING_AVERAGE PacketsInSeqAveragingArray;

    FLOW_STATE  State;
    
} DSEQ_FLOW, *PDSEQ_FLOW;

#define MAX_DEQUEUED_PACKETS            8

//
//  Values for Drr Seq Flow flags: [ Don't know why 1 was not used here]
#define FLOW_USER_PRIORITY              0x00000002
//      GPC_ISSLOW_FLOW                 0x00000040      Indicates that this is an ISSLOW flow. 
//                                                      Make sure not to use the same flag for something else.


// The following macro checks a packet for conformance based on the flow's
// LastPacketTime, the current time, and the timer resolution.

#define PacketIsConforming(_flow, _packetinfo, _curtime, _r)              \
    ( (_flow)->PacketSendTime.QuadPart <= ((_curtime).QuadPart + (_r)) && \
      (_packetinfo)->PacketLength <= (_flow)->BucketSize                  \
    )

#define AdjustLastPacketTime(_flow, _curtime, _r) \
    if ((_curtime).QuadPart > ((_flow)->PacketSendTime.QuadPart + (_r))) \
        if ((_curtime).QuadPart > ((_flow)->LastConformanceTime.QuadPart - (_r))) \
            (_flow)->PacketSendTime = (_flow)->LastConformanceTime; \
        else \
            (_flow)->PacketSendTime = (_curtime);

#define LOCK_PIPE(_p)   NdisAcquireSpinLock(&(_p)->Lock)
#define UNLOCK_PIPE(_p) NdisReleaseSpinLock(&(_p)->Lock)

/* External */

/* Static */

/* Forward */

NDIS_STATUS
DrrSeqInitializePipe (
    IN HANDLE PsPipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters,
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_PROCS PsProcs,
    IN PPS_UPCALLS Upcalls
    );

NDIS_STATUS
DrrSeqModifyPipe (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters
    );

VOID
DrrSeqDeletePipe (
    IN PPS_PIPE_CONTEXT PipeContext
    );

NDIS_STATUS
DrrSeqCreateFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsFlowContext,
    IN PCO_CALL_PARAMETERS CallParameters,
    IN PPS_FLOW_CONTEXT ComponentFlowContext
    );

NDIS_STATUS
DrrSeqModifyFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PCO_CALL_PARAMETERS CallParameters
    );

VOID
DrrSeqDeleteFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext
    );

VOID
DrrSeqEmptyFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext
    );

static NDIS_STATUS 
DrrSeqCreateClassMap (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsClassMapContext,
    IN PTC_CLASS_MAP_FLOW ClassMap,
    IN PPS_CLASS_MAP_CONTEXT ComponentClassMapContext
    );

static NDIS_STATUS 
DrrSeqDeleteClassMap (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_CLASS_MAP_CONTEXT ComponentClassMapContext
    );

BOOLEAN
DrrSeqSubmitPacket (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PPS_CLASS_MAP_CONTEXT ClassMapContext,
    IN PPACKET_INFO_BLOCK PacketInfo
    );

VOID
DrrSeqSendComplete (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PNDIS_PACKET Packet
    );

VOID
DrrSetInformation(
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_FLOW_CONTEXT ComponentFlowContext,
    IN NDIS_OID Oid,
    IN ULONG Len,
    IN PVOID Data);

VOID
DrrQueryInformation (
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_FLOW_CONTEXT ComponentFlowContext,
    IN NDIS_OID Oid,
    IN ULONG Len,
    IN PVOID Data,
    IN OUT PULONG BytesWritten,
    IN OUT PULONG BytesNeeded,
    IN OUT PNDIS_STATUS Status);
VOID
DrrSeqSendComplete (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PNDIS_PACKET Packet
    );

/* End Forward */


VOID
InitializeDrrSequencer(
    PPSI_INFO Info)

/*++

Routine Description:

    Initialization routine for the DRR sequencer.  This routine just
    fills in the PSI_INFO struct and returns.

Arguments:

    Info - Pointer to component interface info struct

Return Values:

    NDIS_STATUS_SUCCESS

--*/
{
    Info->PipeContextLength = ((sizeof(DSEQ_PIPE) + 7) & ~7);
    Info->FlowContextLength = ((sizeof(DSEQ_FLOW) + 7) & ~7);
    Info->ClassMapContextLength = sizeof(PS_CLASS_MAP_CONTEXT);
    Info->InitializePipe = DrrSeqInitializePipe;
    Info->ModifyPipe = DrrSeqModifyPipe;
    Info->DeletePipe = DrrSeqDeletePipe;
    Info->CreateFlow = DrrSeqCreateFlow;
    Info->ModifyFlow = DrrSeqModifyFlow;
    Info->DeleteFlow = DrrSeqDeleteFlow;
    Info->EmptyFlow =  DrrSeqEmptyFlow;
    Info->CreateClassMap = DrrSeqCreateClassMap;
    Info->DeleteClassMap = DrrSeqDeleteClassMap;
    Info->SubmitPacket = DrrSeqSubmitPacket;
    Info->ReceivePacket = NULL;
    Info->ReceiveIndication = NULL;
    Info->SetInformation = DrrSetInformation;
    Info->QueryInformation = DrrQueryInformation;

} // InitializeDrrSequencer



VOID
CleanupDrrSequencer(
    VOID)

/*++

Routine Description:

    Cleanup routine for the DRR sequencer.

Arguments:

Return Values:

    NDIS_STATUS_SUCCESS

--*/
{
} // CleanupDrrSequencer



VOID
AdjustFlowQuanta(
    PDSEQ_PIPE Pipe,
    ULONG MinRate)

/*++

Routine Description:

    Adjust the quantum value for all flows based on the new minimum value.  If MinRate
    is unspecified then a search for the new minimum rate will be performed.

Arguments:

    Pipe -      Pointer to pipe context information
    MinRate -   New value for minimum rate, or GQPS_UNSPECIFIED to force a search

Return Values:


--*/
{
    PDSEQ_FLOW Flow;
    PLIST_ENTRY Entry;

    if (MinRate == QOS_NOT_SPECIFIED) {
        if (Pipe->Bandwidth != 0) {
            MinRate = Pipe->Bandwidth;
        }
        for (Entry = Pipe->Flows.Flink; Entry != &Pipe->Flows; Entry = Entry->Flink) {
            Flow = CONTAINING_RECORD(Entry, DSEQ_FLOW, Links);

            if ((Flow->TokenRate < MinRate) && (Flow->PriorityGroup > PRIORITY_GROUP_BEST_EFFORT) &&
                (Flow->PriorityGroup != PRIORITY_GROUP_NETWORK_CONTROL)) {
                MinRate = Flow->TokenRate;
            }
        }
    }

    for (Entry = Pipe->Flows.Flink; Entry != &Pipe->Flows; Entry = Entry->Flink) {
        Flow = CONTAINING_RECORD(Entry, DSEQ_FLOW, Links);

        if ((Flow->TokenRate == QOS_NOT_SPECIFIED) ||   
            (Flow->PriorityGroup == PRIORITY_GROUP_NETWORK_CONTROL) ||
            (Flow->PriorityGroup <= PRIORITY_GROUP_BEST_EFFORT)) {

            Flow->Quantum = Pipe->MinimumQuantum;
        } else {
            Flow->Quantum = (ULONG)((ULONGLONG)(Flow->TokenRate * Pipe->MinimumQuantum) / MinRate);
        }

        PsAssert((LONG)Flow->Quantum > 0);
    }

    Pipe->MinimumRate = MinRate;
    PsAssert(Pipe->MinimumRate != 0);
            
} // AdjustFlowQuanta



VOID
DequeuePackets(
    PDSEQ_PIPE Pipe)

/*++

Routine Description:

    Select the next packet(s) to send.  The lock must be held upon entry to this
    routine.

Arguments:

    Pipe -       Pointer to pipe context information

Return Values:


--*/
{
    PDSEQ_FLOW Flow;
    LARGE_INTEGER CurrentTime;
    PLIST_ENTRY LowPriorityList = &Pipe->ActiveFlows[0];
    PLIST_ENTRY CurrentLink;
    PPACKET_INFO_BLOCK PacketInfo;
    PNDIS_PACKET Packet;
    ULONG Priority;
    ULONG PriorityGroup;
    PPACKET_INFO_BLOCK PacketsToSend[MAX_DEQUEUED_PACKETS];
    ULONG SendingPriority[MAX_DEQUEUED_PACKETS];
    ULONG PacketSendCount = 0;
    ULONG MaxDequeuedPackets = Pipe->MaxOutstandingSends - Pipe->OutstandingSends;
    ULONG i;

    //  Need to call this to disable the user APCs after this point.
    //  Note that the DDK says it should be called at PASSIVE. But it can very well be
    //  called at DISPATCH.
    KeEnterCriticalRegion();

    Pipe->Flags |= DSEQ_DEQUEUE;

    PsGetCurrentTime(&CurrentTime);

    PsAssert(Pipe->MaxOutstandingSends >= Pipe->OutstandingSends);

    if (MaxDequeuedPackets > MAX_DEQUEUED_PACKETS) {
        MaxDequeuedPackets = MAX_DEQUEUED_PACKETS;
    }

    // First update the conformance status of the flows in the lowest priority list
    CurrentLink = LowPriorityList->Flink;
    while (CurrentLink != LowPriorityList) {
        // Get the flow pointer from the linkage and set new value for CurrentLink

        Flow = CONTAINING_RECORD(CurrentLink, DSEQ_FLOW, ActiveLinks);
        CurrentLink = CurrentLink->Flink;

        // If this flow's priority is higher than the DRR priority, then
        // it is a candidate for a status change.

        if (Flow->Priority > 0) {
            PacketInfo = (PPACKET_INFO_BLOCK)Flow->PacketQueue.Flink;

            if (PacketIsConforming(Flow, PacketInfo, CurrentTime, Pipe->TimerResolution)) {

                // Move flow to higher priority list

                Flow->DeficitCounter = Flow->Quantum;
                RemoveEntryList(&Flow->ActiveLinks);
                InsertTailList(&Pipe->ActiveFlows[Flow->Priority], &Flow->ActiveLinks);
            }
        }
    }

    // Now select the next packet(s) to send
        
    for (PriorityGroup = PRIORITY_GROUPS - 1;
         ((PriorityGroup > 0) && (Pipe->ActiveFlowCount[PriorityGroup] == 0));
         PriorityGroup--) ;

    Priority = Pipe->StartPriority[PriorityGroup] + Pipe->PriorityLevels[PriorityGroup] - 1;

    while ((PacketSendCount < MaxDequeuedPackets) &&
           (Pipe->TotalActiveFlows > 0) &&
           Priority < INTERNAL_PRIORITIES) {

        if (!IsListEmpty(&Pipe->ActiveFlows[Priority])) {

            // Get first flow in the current list, and get a pointer to the info
            // about the first packet

            CurrentLink = Pipe->ActiveFlows[Priority].Flink;
            Flow = CONTAINING_RECORD(CurrentLink, DSEQ_FLOW, ActiveLinks);
            PacketInfo = (PPACKET_INFO_BLOCK)Flow->PacketQueue.Flink;

            if (Pipe->PsFlags & PS_DISABLE_DRR) {

                // DRR is disabled.  Remove the first packet from the queue
                // and send it.

                RemoveEntryList(&PacketInfo->SchedulerLinks);

                Flow->LastConformanceTime.QuadPart = PacketInfo->ConformanceTime.QuadPart;

                if (Priority > 0) {
                    AdjustLastPacketTime(Flow, CurrentTime, Pipe->TimerResolution);
                } else {
                    Flow->PacketSendTime = CurrentTime;
                }

                InterlockedIncrement( &Pipe->OutstandingSends );

                if(Pipe->OutstandingSends > Pipe->Stats.MaxPacketsInNetcard){
                    Pipe->Stats.MaxPacketsInNetcard = Pipe->OutstandingSends;
                }

                if(gEnableAvgStats)
                {
                    //
                    // Track max packets outstanding. This is a measure
                    // of how congested the media gets. Of course, it
                    // will be clipped by the MaxOutstandingSends parameter.
                    // So - for a valid reading, need to set MOS very large.
                    //

                    Pipe->Stats.AveragePacketsInNetcard =
                        RunningAverage(Pipe->PacketsInNetcardAveragingArray,
                                       Pipe->OutstandingSends);
                }
                
                SendingPriority[PacketSendCount] = Priority;
                PacketsToSend[PacketSendCount++] = PacketInfo;

                // For logging purposes...

                PacketInfo->ConformanceTime = Flow->PacketSendTime;

                // If the flow has no more packets to send, remove it from the list.
                // Otherwise move it to the end of the appropriate list, depending on
                // the conformance time of the next packet.

                RemoveEntryList(&Flow->ActiveLinks);

                if (IsListEmpty(&Flow->PacketQueue)) {
                    Pipe->TotalActiveFlows--;
                    Pipe->ActiveFlowCount[Flow->PriorityGroup]--;
                }
                else {
                    PacketInfo = (PPACKET_INFO_BLOCK)Flow->PacketQueue.Flink;
                    Flow->PacketSendTime.QuadPart += 
                        (PacketInfo->ConformanceTime.QuadPart - Flow->LastConformanceTime.QuadPart);
                    if (!PacketIsConforming(Flow, PacketInfo, CurrentTime, Pipe->TimerResolution)) {
                        InsertTailList(LowPriorityList, &Flow->ActiveLinks);
                    } else {
                        InsertTailList(&Pipe->ActiveFlows[Priority], &Flow->ActiveLinks);
                    }
                }
            }
            else if (PacketInfo->PacketLength <= Flow->DeficitCounter) {

                // DRR is being used and the flow has a large enough deficit counter
                // to send the packet.  Remove the packet from the queue and send it.

                RemoveEntryList(&PacketInfo->SchedulerLinks);

                Flow->LastConformanceTime.QuadPart = PacketInfo->ConformanceTime.QuadPart;

                if (Priority > 0) {
                    AdjustLastPacketTime(Flow, CurrentTime, Pipe->TimerResolution);
                } else {
                    Flow->PacketSendTime = CurrentTime;
                }
                Flow->DeficitCounter -= PacketInfo->PacketLength;
                InterlockedIncrement( &Pipe->OutstandingSends );

                if(Pipe->OutstandingSends > Pipe->Stats.MaxPacketsInNetcard){
                    Pipe->Stats.MaxPacketsInNetcard = Pipe->OutstandingSends;
                }


                if(gEnableAvgStats)
                {
                    
                    //
                    // Track max packets outstanding. This is a measure
                    // of how congested the media gets. Of course, it
                    // will be clipped by the MaxOutstandingSends parameter.
                    // So - for a valid reading, need to set MOS very large.
                    //
                    Pipe->Stats.AveragePacketsInNetcard =
                        RunningAverage(Pipe->PacketsInNetcardAveragingArray,
                                       Pipe->OutstandingSends);
                }

                SendingPriority[PacketSendCount] = Priority;
                PacketsToSend[PacketSendCount++] = PacketInfo;

                // For logging purposes...

                PacketInfo->ConformanceTime = Flow->PacketSendTime;

                // If the flow has no more packets to send, remove it from the list.
                // If the flow still has conforming packets to send, leave it at the head
                // of the list.  If the flow has non-conforming packets to send, move it
                // to the lowest priority list.  If we are servicing the zero priority
                // level, then no conformance checking is necessary.

                if (IsListEmpty(&Flow->PacketQueue)) {
                    RemoveEntryList(&Flow->ActiveLinks);
                    Pipe->TotalActiveFlows--;
                    Pipe->ActiveFlowCount[Flow->PriorityGroup]--;
                }
                else {
                    PacketInfo = (PPACKET_INFO_BLOCK)Flow->PacketQueue.Flink;
                    Flow->PacketSendTime.QuadPart += 
                        (PacketInfo->ConformanceTime.QuadPart - Flow->LastConformanceTime.QuadPart);
                    if ((Priority > 0) &&
                        !PacketIsConforming(Flow, PacketInfo, CurrentTime, Pipe->TimerResolution)) {

                        Flow->DeficitCounter = Flow->Quantum;
                        RemoveEntryList(&Flow->ActiveLinks);
                        InsertTailList(LowPriorityList, &Flow->ActiveLinks);
                    }
                }
            }
            else {

                // The packet cannot be sent because the flow's deficit counter
                // is too small.  Place the flow at the end of the same priority
                // queue and increment the flow's deficit counter by its quantum.

                Flow->DeficitCounter += Flow->Quantum;
                RemoveEntryList(&Flow->ActiveLinks);
                InsertTailList(&Pipe->ActiveFlows[Priority], &Flow->ActiveLinks);
            }
        }
        else {
            Priority--;
        }
    }

    //
    // We're gonna send these now, which means they're leaving the
    // sequencer. Update the stats.
    //

    Pipe->PacketsInSequencer -= PacketSendCount;
    Flow->PacketsInSequencer -= PacketSendCount;

    if(gEnableAvgStats)
    {
        Flow->Stats.AveragePacketsInSequencer =
                    RunningAverage(Flow->PacketsInSeqAveragingArray, 
                                               Flow->PacketsInSequencer);
    }

    // Send the next group of packets

    UNLOCK_PIPE(Pipe);
    if (PacketSendCount == 0) {
        PsDbgOut(DBG_CRITICAL_ERROR, DBG_SCHED_DRR, ("PSCHED: No packets selected\n"));
    }
    for (i = 0; i < PacketSendCount; i++) {
        PacketInfo = PacketsToSend[i];
        Flow = (PDSEQ_FLOW)PacketInfo->FlowContext;

        Packet = PacketInfo->NdisPacket;

        //
        // The 802.1 priority is already set by the wrapper. But, if the packet
        // is non-conforming, then we want to reset it. We also want to clear
        // the IP Precedence Bits.
        //
        if ((SendingPriority[i] == 0)) {

            //
            // Non conforming packet!
            //
            NDIS_PACKET_8021Q_INFO    VlanPriInfo;

            VlanPriInfo.Value = NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, Ieee8021QInfo);
            VlanPriInfo.TagHeader.UserPriority = PacketInfo->UserPriorityNonConforming;
            NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, Ieee8021QInfo) = VlanPriInfo.Value;

            Flow->Stats.NonconformingPacketsTransmitted ++;
            Pipe->Stats.NonconformingPacketsTransmitted ++;

            //
            // Reset the TOS byte for IP Packets.
            //
            if(NDIS_GET_PACKET_PROTOCOL_TYPE(Packet) == NDIS_PROTOCOL_ID_TCP_IP) {

                if(!PacketInfo->IPHdr) {

                    PacketInfo->IPHdr = GetIpHeader(PacketInfo->IPHeaderOffset, Packet);
                }
                    
                SET_TOS_XSUM(Packet, 
                             PacketInfo->IPHdr, 
                             PacketInfo->TOSNonConforming);
            }
        }

        PsDbgSched(DBG_INFO, DBG_SCHED_DRR,
                   DRR_SEQUENCER, PKT_DEQUEUE, Flow->PsFlowContext,
                   Packet, PacketInfo->PacketLength, SendingPriority[i],
                   CurrentTime.QuadPart,
                   PacketInfo->ConformanceTime.QuadPart,
                   Pipe->PacketsInSequencer,
                   0);


        if (!(*Pipe->ContextInfo.NextComponent->SubmitPacket)(
                Pipe->ContextInfo.NextComponentContext,
                Flow->ContextInfo.NextComponentContext,
                (PacketInfo->ClassMapContext != NULL) ?
                  ((PPS_CLASS_MAP_CONTEXT)PacketInfo->ClassMapContext)->NextComponentContext : NULL,
                PacketInfo)) {

            (*Pipe->PsProcs->DropPacket)(Pipe->PsPipeContext, Flow->PsFlowContext, Packet, NDIS_STATUS_FAILURE);

        }
    }
    
    LOCK_PIPE(Pipe);

    Pipe->Flags &= ~DSEQ_DEQUEUE;

    //  Re-enable the APCs again.
    KeLeaveCriticalRegion();

} // DequeuePackets



NDIS_STATUS
DrrSeqInitializePipe (
    IN HANDLE PsPipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters,
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_PROCS PsProcs,
    IN PPS_UPCALLS Upcalls
    )

/*++

Routine Description:

    Pipe initialization routine for the DRR sequencer.

Arguments:

    PsPipeContext -         PS pipe context value
    PipeParameters -        Pointer to pipe parameters
    ComponentPipeContext -  Pointer to this component's context area
    PsProcs -               PS's support routines
    Upcalls -               Previous component's upcall table

Return Values:

    Status value from next component

--*/
{
    PDSEQ_PIPE Pipe = (PDSEQ_PIPE)ComponentPipeContext;
    HANDLE NdisHandle;
    ULONG i;
    ULONG PriorityLevel = 0;
    PS_UPCALLS DrrSeqUpcalls;
    NDIS_STATUS Status;

    NdisAllocateSpinLock(&Pipe->Lock);
    Pipe->Flags = 0;

    //
    // Relative Priorities allow us to further subdivide each priority group
    // into sub priorities. This does not exist for NonConforming, BestEffort,
    // and Qualitative.
    //

    Pipe->PriorityLevels[PRIORITY_GROUP_NON_CONFORMING]    = 1;
    Pipe->PriorityLevels[PRIORITY_GROUP_BEST_EFFORT]       = 1;
    Pipe->PriorityLevels[PRIORITY_GROUP_CONTROLLED_LOAD]   = RELATIVE_PRIORITIES;
    Pipe->PriorityLevels[PRIORITY_GROUP_GUARANTEED]        = RELATIVE_PRIORITIES;
    Pipe->PriorityLevels[PRIORITY_GROUP_NETWORK_CONTROL]   = RELATIVE_PRIORITIES;

    InitializeListHead(&Pipe->Flows);
    for (i = 0; i < INTERNAL_PRIORITIES; i++) {
        InitializeListHead(&Pipe->ActiveFlows[i]);
    }
    for (i = 0; i < PRIORITY_GROUPS; i++) {
        Pipe->ActiveFlowCount[i] = 0;
        Pipe->StartPriority[i] = PriorityLevel;
        PriorityLevel += Pipe->PriorityLevels[i];
    }

    Pipe->TotalActiveFlows = 0;
    Pipe->OutstandingSends = 0;
    NdisZeroMemory(&Pipe->Stats, sizeof(PS_DRRSEQ_STATS));
    Pipe->PacketsInSequencer = 0;
    Pipe->PacketsInSequencerAveragingArray = NULL;
    Pipe->PacketsInNetcardAveragingArray = NULL;
    
    Status = CreateAveragingArray(&Pipe->PacketsInSequencerAveragingArray,
                                  SEQUENCER_AVERAGING_ARRAY_SIZE);

    if(Status != NDIS_STATUS_SUCCESS)
    {
        return(Status);
    }

    Status = CreateAveragingArray(&Pipe->PacketsInNetcardAveragingArray,
                                  NETCARD_AVERAGING_ARRAY_SIZE);

    if(Status != NDIS_STATUS_SUCCESS)
    {
        DeleteAveragingArray(Pipe->PacketsInSequencerAveragingArray);

        return(Status);
    }

    Pipe->MinimumQuantum = PipeParameters->MTUSize - PipeParameters->HeaderSize;
    if (Pipe->MinimumQuantum == 0) {
        Pipe->MinimumQuantum = DEFAULT_MIN_QUANTUM;
    }
    Pipe->Bandwidth = PipeParameters->Bandwidth;

    // This will be set to something more realistic when the first flow is created.

    Pipe->MinimumRate = (PipeParameters->Bandwidth > 0) ? PipeParameters->Bandwidth : QOS_NOT_SPECIFIED;
    PsAssert(Pipe->MinimumRate != 0);
    Pipe->PsFlags = PipeParameters->Flags;
    Pipe->IsslowFlowCount = 0;
    Pipe->ConfiguredMaxOutstandingSends = Pipe->MaxOutstandingSends = PipeParameters->MaxOutstandingSends;

    //  Change the MOS if necessary..
    if( ( PipeParameters->MediaType == NdisMediumWan)   &&
        ( Pipe->Bandwidth <= MAX_LINK_SPEED_FOR_DRR) )
    {
        Pipe->MaxOutstandingSends = 1;
    }

    (*PsProcs->GetTimerInfo)(&Pipe->TimerResolution);
    Pipe->TimerResolution /= 2;
    Pipe->PsPipeContext = PsPipeContext;
    Pipe->PsProcs = PsProcs;

    if(Upcalls)
    {
        Pipe->PreviousUpcallsSendComplete = Upcalls->SendComplete;
        Pipe->PreviousUpcallsSendCompletePipeContext = Upcalls->PipeContext;
    }
    else
    {
        Pipe->PreviousUpcallsSendComplete = 0;
        Pipe->PreviousUpcallsSendCompletePipeContext = 0;
    }

    DrrSeqUpcalls.SendComplete = DrrSeqSendComplete;
    DrrSeqUpcalls.PipeContext = ComponentPipeContext;

    /* This put the DrrSeq in the pass-thru mode when the MaxOutStandingSends ==  MAX */
    if( Pipe->MaxOutstandingSends   == 0xffffffff )
        Pipe->Flags |=  DSEQ_PASSTHRU;
    else
        Pipe->Flags &=  ~ DSEQ_PASSTHRU;

    PsDbgOut(DBG_INFO, 
             DBG_SCHED_DRR, 
             ("PSCHED: DrrSeq pipe initialized at %x.\n", 
             &Pipe));

    
    Status = (*Pipe->ContextInfo.NextComponent->InitializePipe)(
                PsPipeContext,
                PipeParameters,
                Pipe->ContextInfo.NextComponentContext,
                PsProcs,
                &DrrSeqUpcalls);
    if (Status != NDIS_STATUS_SUCCESS) 
    {
        NdisFreeSpinLock(&Pipe->Lock);
        DeleteAveragingArray(Pipe->PacketsInSequencerAveragingArray);
        DeleteAveragingArray(Pipe->PacketsInNetcardAveragingArray);
    }

    return Status;
    
} // DrrSeqInitializePipe


// 
//  Unload routine: currently do nothing
//
void
UnloadSequencer()
{

}



NDIS_STATUS
DrrSeqModifyPipe (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters
    )

/*++

Routine Description:

    Pipe parameter modification routine for the DRR sequencer.

Arguments:

    PipeContext -       Pointer to this component's pipe context area
    PipeParameters -    Pointer to pipe parameters

Return Values:

    Status value from next component

--*/
{
    PDSEQ_PIPE Pipe = (PDSEQ_PIPE)PipeContext;
    ULONG MinQuantum = PipeParameters->MTUSize - PipeParameters->HeaderSize;
    BOOLEAN AdjustQuanta = FALSE;
    ULONG MinRate = Pipe->MinimumRate;

    LOCK_PIPE(Pipe);

    (*Pipe->PsProcs->GetTimerInfo)(&Pipe->TimerResolution);
    Pipe->TimerResolution /= 2;

    if ((MinQuantum > 0) && (MinQuantum != Pipe->MinimumQuantum)) {
        Pipe->MinimumQuantum = MinQuantum;
        AdjustQuanta = TRUE;
    }
    
    Pipe->Bandwidth = PipeParameters->Bandwidth;
    Pipe->ConfiguredMaxOutstandingSends = Pipe->MaxOutstandingSends = PipeParameters->MaxOutstandingSends;

    //  Change the MOS if necessary..
    if( ( PipeParameters->MediaType == NdisMediumWan)   &&
        ( Pipe->Bandwidth <= MAX_LINK_SPEED_FOR_DRR) )
    {
        Pipe->MaxOutstandingSends = 1;
    }

    //  This put the DrrSeq in the pass-thru mode when the MaxOutStandingSends ==  MAX 
    if( Pipe->MaxOutstandingSends   == 0xffffffff )
    {
        // Make sure not to do this. It could lead to packets queued up in the sequencer being never sent
        // [ Pipe->Flags |=  DSEQ_PASSTHRU; ] 
    }        
    else
    {
        Pipe->Flags &=  ~ DSEQ_PASSTHRU;
    }        
    
    if (Pipe->MinimumRate > Pipe->Bandwidth) {
        MinRate = QOS_NOT_SPECIFIED;
        AdjustQuanta = TRUE;
    }

    if (AdjustQuanta) {
        AdjustFlowQuanta(Pipe, MinRate);
    }
    UNLOCK_PIPE(Pipe);

    return (*PipeContext->NextComponent->ModifyPipe)(
                PipeContext->NextComponentContext,
                PipeParameters);

} // DrrSeqModifyPipe



VOID
DrrSeqDeletePipe (
    IN PPS_PIPE_CONTEXT PipeContext
    )

/*++

Routine Description:

    Pipe removal routine for token bucket conformer.

Arguments:

    PipeContext -   Pointer to this component's pipe context area

Return Values:

--*/
{
    PDSEQ_PIPE Pipe = (PDSEQ_PIPE)PipeContext;

    DeleteAveragingArray(Pipe->PacketsInSequencerAveragingArray);
    DeleteAveragingArray(Pipe->PacketsInNetcardAveragingArray);

    PsDbgOut(DBG_INFO, DBG_SCHED_DRR, ("PSCHED: DrrSeq pipe deleted\n"));

    PsAssert(Pipe->OutstandingSends == 0);
    NdisFreeSpinLock(&Pipe->Lock);

    (*Pipe->ContextInfo.NextComponent->DeletePipe)(Pipe->ContextInfo.NextComponentContext);

} // DrrSeqDeletePipe



NDIS_STATUS
DrrSeqCreateFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsFlowContext,
    IN PCO_CALL_PARAMETERS CallParameters,
    IN PPS_FLOW_CONTEXT ComponentFlowContext
    )

/*++

Routine Description:

    Flow creation routine for the DRR sequencer.

Arguments:

    PipeContext -           Pointer to this component's pipe context area
    PsFlowContext -         PS flow context value
    CallParameters -        Pointer to call parameters for flow
    ComponentFlowContext -  Pointer to this component's flow context area

Return Values:

    Status value from next component

--*/
{
    PDSEQ_PIPE Pipe = (PDSEQ_PIPE)PipeContext;
    PDSEQ_FLOW Flow = (PDSEQ_FLOW)ComponentFlowContext;
    SERVICETYPE ServiceType;
    ULONG ParamsLength;
    LPQOS_OBJECT_HDR QoSObject;
    ULONG UserPriority;
    ULONG i;
    NDIS_STATUS Status;

    ServiceType = CallParameters->CallMgrParameters->Transmit.ServiceType;
    if ((ServiceType < SERVICETYPE_BESTEFFORT) || (ServiceType > SERVICETYPE_QUALITATIVE)) {
        return NDIS_STATUS_FAILURE;
    }
    Flow->TokenRate = CallParameters->CallMgrParameters->Transmit.TokenRate;
    Flow->BucketSize = CallParameters->CallMgrParameters->Transmit.TokenBucketSize;
    InitializeListHead(&Flow->PacketQueue);
    PsGetCurrentTime(&Flow->PacketSendTime);
    Flow->LastConformanceTime = Flow->PacketSendTime;
    Flow->PsFlowContext = PsFlowContext;
    Flow->State = DRRSEQ_FLOW_CREATED;

    // Set the flow's priority group based on service type.

    switch (ServiceType) {
        case SERVICETYPE_CONTROLLEDLOAD:
            Flow->PriorityGroup = PRIORITY_GROUP_CONTROLLED_LOAD;
            break;
        case SERVICETYPE_GUARANTEED:
            Flow->PriorityGroup = PRIORITY_GROUP_GUARANTEED;
            break;
        case SERVICETYPE_NETWORK_CONTROL:
            Flow->PriorityGroup = PRIORITY_GROUP_NETWORK_CONTROL;
            break;
        case SERVICETYPE_QUALITATIVE:
        default:
            Flow->PriorityGroup = PRIORITY_GROUP_BEST_EFFORT;
    }

    Flow->Flags = 0;

    // Save the flow in a list so that quantum values can be adjusted if
    // a new flow is added with a smaller rate than the existing flows.

    LOCK_PIPE(Pipe);

    InsertTailList(&Pipe->Flows, &Flow->Links);

    // If this flow's rate is smaller than the rate assigned to any existing
    // flow, adjust the other flow's quantum values accordingly.

    if (ServiceType == SERVICETYPE_BESTEFFORT || ServiceType == SERVICETYPE_NETWORK_CONTROL ||
        ServiceType == SERVICETYPE_QUALITATIVE) {
        Flow->Quantum = Pipe->MinimumQuantum;
    }
    else if (Flow->TokenRate < Pipe->MinimumRate) {
        AdjustFlowQuanta(Pipe, Flow->TokenRate);
    }
    else {
        Flow->Quantum = (ULONG)((ULONGLONG)(Flow->TokenRate * Pipe->MinimumQuantum) / Pipe->MinimumRate);
        PsAssert((LONG)Flow->Quantum > 0);
    }
    Flow->DeficitCounter = 0;

    //  If this is a RAS-ISSLOW flow, need to set the MOS back to whatever requested by the user..
    if( ((PGPC_CLIENT_VC)(PsFlowContext))->Flags & GPC_ISSLOW_FLOW)
    {
        Pipe->MaxOutstandingSends = Pipe->ConfiguredMaxOutstandingSends;
        Pipe->IsslowFlowCount++;
        Flow->Flags |= GPC_ISSLOW_FLOW;
    }

    
    UNLOCK_PIPE(Pipe);

    // Now set default values for UserPriority 

    UserPriority = (Pipe->PriorityLevels[Flow->PriorityGroup] - 1) / 2;

    // Look for the priority object and traffic class in the call manager specific parameters

    ParamsLength = CallParameters->CallMgrParameters->CallMgrSpecific.Length;
    if (CallParameters->CallMgrParameters->CallMgrSpecific.ParamType == PARAM_TYPE_GQOS_INFO) {

        QoSObject = (LPQOS_OBJECT_HDR)CallParameters->CallMgrParameters->CallMgrSpecific.Parameters;
        while ((ParamsLength > 0) && (QoSObject->ObjectType != QOS_OBJECT_END_OF_LIST)) {
            if (QoSObject->ObjectType == QOS_OBJECT_PRIORITY) {
                UserPriority = ((LPQOS_PRIORITY)QoSObject)->SendPriority;
                Flow->Flags |= FLOW_USER_PRIORITY;
            }
            ParamsLength -= QoSObject->ObjectLength;
            QoSObject = (LPQOS_OBJECT_HDR)((UINT_PTR)QoSObject + QoSObject->ObjectLength);
        }
    }

    Flow->UserPriority = UserPriority;
    if (UserPriority < Pipe->PriorityLevels[Flow->PriorityGroup]) {
        Flow->Priority = Pipe->StartPriority[Flow->PriorityGroup] + UserPriority;
    }
    else {
        Flow->Priority = Pipe->StartPriority[Flow->PriorityGroup] +
                         Pipe->PriorityLevels[Flow->PriorityGroup] - 1;
    }

    Flow->PacketsInSequencer = 0;
    NdisZeroMemory(&Flow->Stats, sizeof(PS_DRRSEQ_STATS));

    Status = CreateAveragingArray(&Flow->PacketsInSeqAveragingArray,
                                  SEQUENCER_FLOW_AVERAGING_ARRAY_SIZE);

    if(Status != NDIS_STATUS_SUCCESS){
        LOCK_PIPE(Pipe);
        RemoveEntryList(&Flow->Links);
        if(Flow->TokenRate == Pipe->MinimumRate) {
            AdjustFlowQuanta(Pipe, QOS_NOT_SPECIFIED);
        }

        UNLOCK_PIPE(Pipe);
        return(Status);
    }

    PsDbgOut(DBG_INFO, DBG_SCHED_DRR, 
            ("PSCHED: DrrSeq flow created. Quantum = %u, Priority = %u\n", Flow->Quantum, Flow->Priority));


    Status =  (*Pipe->ContextInfo.NextComponent->CreateFlow)(
                Pipe->ContextInfo.NextComponentContext,
                PsFlowContext,
                CallParameters,
                Flow->ContextInfo.NextComponentContext);

    if(Status != NDIS_STATUS_SUCCESS)
    {
        DeleteAveragingArray(Flow->PacketsInSeqAveragingArray);
        LOCK_PIPE(Pipe);
        RemoveEntryList(&Flow->Links);
        if(Flow->TokenRate == Pipe->MinimumRate) {
            AdjustFlowQuanta(Pipe, QOS_NOT_SPECIFIED);
        }

        UNLOCK_PIPE(Pipe);
    }

    return Status;

} // DrrSeqCreateFlow



NDIS_STATUS
DrrSeqModifyFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PCO_CALL_PARAMETERS CallParameters
    )

/*++

Routine Description:

    Flow modification routine for the DRR sequencer.

Arguments:

    PipeContext -       Pointer to this component's pipe context area
    FlowContext -       Pointer to this component's flow context area
    CallParameters -    Pointer to call parameters for flow

Return Values:

    Status value from next component

--*/
{
    PDSEQ_PIPE Pipe = (PDSEQ_PIPE)PipeContext;
    PDSEQ_FLOW Flow = (PDSEQ_FLOW)FlowContext;
    SERVICETYPE ServiceType;
    ULONG TokenRate;
    ULONG ParamsLength;
    LPQOS_OBJECT_HDR QoSObject;
    LPQOS_PRIORITY PriorityObject = NULL;
    ULONG i;
    ULONG OldPriorityGroup;
    ULONG OldRate;
    ULONG OldPriority;
    PPACKET_INFO_BLOCK PacketInfo;
    LARGE_INTEGER CurrentTime;

    ServiceType = CallParameters->CallMgrParameters->Transmit.ServiceType;
    if ((ServiceType != SERVICETYPE_NOCHANGE) && 
        ((ServiceType < SERVICETYPE_BESTEFFORT) || (ServiceType > SERVICETYPE_QUALITATIVE))) {
            return NDIS_STATUS_FAILURE;
    }

    // Look for the priority and traffic class objects in the call manager
    // specific parameters, and save the pointers if found.

    ParamsLength = CallParameters->CallMgrParameters->CallMgrSpecific.Length;
    if (CallParameters->CallMgrParameters->CallMgrSpecific.ParamType == PARAM_TYPE_GQOS_INFO) {

        QoSObject = (LPQOS_OBJECT_HDR)CallParameters->CallMgrParameters->CallMgrSpecific.Parameters;
        while ((ParamsLength > 0) && (QoSObject->ObjectType != QOS_OBJECT_END_OF_LIST)) {
            if (QoSObject->ObjectType == QOS_OBJECT_PRIORITY) {
                PriorityObject = (LPQOS_PRIORITY)QoSObject;
            }
            ParamsLength -= QoSObject->ObjectLength;
            QoSObject = (LPQOS_OBJECT_HDR)((UINT_PTR)QoSObject + QoSObject->ObjectLength);
        }
    }

    LOCK_PIPE(Pipe);

    OldPriorityGroup = Flow->PriorityGroup;
    OldPriority = Flow->Priority;

    if (ServiceType != SERVICETYPE_NOCHANGE) 
    {
        // Set the flow's priority group based on service type.

        switch (ServiceType) {
            case SERVICETYPE_CONTROLLEDLOAD:
                Flow->PriorityGroup = PRIORITY_GROUP_CONTROLLED_LOAD;
                break;
            case SERVICETYPE_GUARANTEED:
                Flow->PriorityGroup = PRIORITY_GROUP_GUARANTEED;
                break;
            case SERVICETYPE_NETWORK_CONTROL:
                Flow->PriorityGroup = PRIORITY_GROUP_NETWORK_CONTROL;
                break;
            case SERVICETYPE_QUALITATIVE:
            default:
                Flow->PriorityGroup = PRIORITY_GROUP_BEST_EFFORT;
        }

        TokenRate = CallParameters->CallMgrParameters->Transmit.TokenRate;

        OldRate = Flow->TokenRate;
        if ((TokenRate != OldRate) || (OldPriorityGroup != Flow->PriorityGroup)) {

            // If this flow's rate is smaller than the rate assigned to any existing
            // flow, adjust the other flows' quantum values accordingly.  If this flow's
            // old rate was equal to the minimum rate, then locate the new minimum rate and
            // adjust the other flows' quantum values accordingly.

            Flow->TokenRate = TokenRate;
            if ((OldRate == Pipe->MinimumRate) && (OldPriorityGroup > PRIORITY_GROUP_BEST_EFFORT) &&
                (OldPriorityGroup != PRIORITY_GROUP_NETWORK_CONTROL)) {
                AdjustFlowQuanta(Pipe, QOS_NOT_SPECIFIED);
            }
            else if (Flow->PriorityGroup <= PRIORITY_GROUP_BEST_EFFORT || Flow->PriorityGroup == PRIORITY_GROUP_NETWORK_CONTROL) {
                Flow->Quantum = Pipe->MinimumQuantum;
            }
            else if (TokenRate < Pipe->MinimumRate) {
                AdjustFlowQuanta(Pipe, TokenRate);
            }
            else {
                PsAssert(Pipe->MinimumRate != 0);
                Flow->Quantum = (ULONG)((ULONGLONG)(TokenRate * Pipe->MinimumQuantum) / Pipe->MinimumRate);
                PsAssert((LONG)Flow->Quantum > 0);
            }

        }

        Flow->BucketSize = CallParameters->CallMgrParameters->Transmit.TokenBucketSize;
    }

    // Now set the new values for UserPriority and Priority

    if (PriorityObject != NULL) {
        Flow->UserPriority = PriorityObject->SendPriority;
        Flow->Flags |= FLOW_USER_PRIORITY;
    }
    else if ((Flow->Flags & FLOW_USER_PRIORITY) == 0) {
        Flow->UserPriority = (Pipe->PriorityLevels[Flow->PriorityGroup] - 1) / 2;
    }

    if (Flow->UserPriority < Pipe->PriorityLevels[Flow->PriorityGroup]) {
        Flow->Priority = Pipe->StartPriority[Flow->PriorityGroup] + Flow->UserPriority;
    }
    else {
        Flow->Priority = Pipe->StartPriority[Flow->PriorityGroup] +
                         Pipe->PriorityLevels[Flow->PriorityGroup] - 1;
    }

    // Move the flow to the proper priority list if necessary

    if ((Flow->Priority != OldPriority) && !IsListEmpty(&Flow->PacketQueue)) {
        Pipe->ActiveFlowCount[OldPriorityGroup]--;
        RemoveEntryList(&Flow->ActiveLinks);
        PacketInfo = (PPACKET_INFO_BLOCK)Flow->PacketQueue.Flink;
        PsGetCurrentTime(&CurrentTime);
        Flow->DeficitCounter = Flow->Quantum;
        Pipe->ActiveFlowCount[Flow->PriorityGroup]++;
        if (!PacketIsConforming(Flow, PacketInfo, CurrentTime, Pipe->TimerResolution)) {
            InsertTailList(&Pipe->ActiveFlows[0], &Flow->ActiveLinks);
        } else {
            InsertTailList(&Pipe->ActiveFlows[Flow->Priority], &Flow->ActiveLinks);
        }
    }

    UNLOCK_PIPE(Pipe);

    PsDbgOut(DBG_INFO, DBG_SCHED_DRR,
            ("PSCHED: DrrSeq flow modified. Quantum = %u, Priority = %u\n", Flow->Quantum, Flow->Priority));


    return (*Pipe->ContextInfo.NextComponent->ModifyFlow)(
                Pipe->ContextInfo.NextComponentContext,
                Flow->ContextInfo.NextComponentContext,
                CallParameters);

} // DrrSeqModifyFlow
VOID
DrrSeqDeleteFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext
    )

/*++

Routine Description:

    Flow removal routine for the DRR sequencer.

Arguments:

    PipeContext -       Pointer to this component's pipe context area
    FlowContext -       Pointer to this component's flow context area

Return Values:

--*/
{
    PDSEQ_PIPE Pipe = (PDSEQ_PIPE)PipeContext;
    PDSEQ_FLOW Flow = (PDSEQ_FLOW)FlowContext;
    PPACKET_INFO_BLOCK PacketInfo;
    PNDIS_PACKET Packet;
    LIST_ENTRY DropList;

    InitializeListHead(&DropList);

    LOCK_PIPE(Pipe);

    if( (Flow->State & DRRSEQ_FLOW_DELETED) != 0)
    {
        UNLOCK_PIPE(Pipe);
        goto DELETE_SEQ_FLOW;
    }        
        
    Flow->State = DRRSEQ_FLOW_DELETED;

    RemoveEntryList(&Flow->Links);

    if (!IsListEmpty(&Flow->PacketQueue)) 
    {
        // Remove flow from active list

        RemoveEntryList(&Flow->ActiveLinks);
        Pipe->ActiveFlowCount[Flow->PriorityGroup]--;
        Pipe->TotalActiveFlows--;

        while (!IsListEmpty(&Flow->PacketQueue)) {

            // Drop any packets that remain queued for this flow.

            PacketInfo = (PPACKET_INFO_BLOCK)RemoveHeadList(&Flow->PacketQueue);
            InsertTailList(&DropList, &PacketInfo->SchedulerLinks);
        }
    }

    if (Flow->TokenRate == Pipe->MinimumRate) {
        AdjustFlowQuanta(Pipe, QOS_NOT_SPECIFIED);
    }

    if( Flow->Flags & GPC_ISSLOW_FLOW)
    {
        // If this is an ISSLOW flow, we have one less now.
        Pipe->IsslowFlowCount--;

        if(Pipe->IsslowFlowCount == 0)
        {
            // If there are no more ISSLOW flows, turn DRR back on.
            Pipe->MaxOutstandingSends = 1;
        }            
    }

    UNLOCK_PIPE(Pipe);

    while (!IsListEmpty(&DropList)) {
        PacketInfo = (PPACKET_INFO_BLOCK)RemoveHeadList(&DropList);
        Packet = PacketInfo->NdisPacket;

        (*Pipe->PsProcs->DropPacket)(Pipe->PsPipeContext, Flow->PsFlowContext,  Packet, NDIS_STATUS_FAILURE);
    }

DELETE_SEQ_FLOW:

    DeleteAveragingArray(Flow->PacketsInSeqAveragingArray);

    PsDbgOut(DBG_INFO, DBG_SCHED_DRR, ("PSCHED: DrrSeq flow deleted\n"));

    (*Pipe->ContextInfo.NextComponent->DeleteFlow)(
                Pipe->ContextInfo.NextComponentContext,
                Flow->ContextInfo.NextComponentContext);
} 




VOID
DrrSeqEmptyFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext
    )

/*++

Routine Description:

    Flow removal routine for the DRR sequencer.

Arguments:

    PipeContext -       Pointer to this component's pipe context area
    FlowContext -       Pointer to this component's flow context area

Return Values:

--*/
{
    PDSEQ_PIPE Pipe = (PDSEQ_PIPE)PipeContext;
    PDSEQ_FLOW Flow = (PDSEQ_FLOW)FlowContext;
    PPACKET_INFO_BLOCK PacketInfo;
    PNDIS_PACKET Packet;
    LIST_ENTRY DropList;

    InitializeListHead(&DropList);

    LOCK_PIPE(Pipe);

    Flow->State = DRRSEQ_FLOW_DELETED;

    RemoveEntryList(&Flow->Links);

    if (!IsListEmpty(&Flow->PacketQueue)) 
    {
        // Remove flow from active list

        RemoveEntryList(&Flow->ActiveLinks);
        Pipe->ActiveFlowCount[Flow->PriorityGroup]--;
        Pipe->TotalActiveFlows--;

        while (!IsListEmpty(&Flow->PacketQueue)) {

            // Drop any packets that remain queued for this flow.

            PacketInfo = (PPACKET_INFO_BLOCK)RemoveHeadList(&Flow->PacketQueue);
            InsertTailList(&DropList, &PacketInfo->SchedulerLinks);
        }
    }

    if (Flow->TokenRate == Pipe->MinimumRate) {
        AdjustFlowQuanta(Pipe, QOS_NOT_SPECIFIED);
    }

    if( Flow->Flags & GPC_ISSLOW_FLOW)
    {
        // If this is an ISSLOW flow, we have one less now.
        Pipe->IsslowFlowCount--;

        if(Pipe->IsslowFlowCount == 0)
        {
            // If there are no more ISSLOW flows, turn DRR back on.
            Pipe->MaxOutstandingSends = 1;
        }            
    }

    UNLOCK_PIPE(Pipe);

    while (!IsListEmpty(&DropList)) {
        PacketInfo = (PPACKET_INFO_BLOCK)RemoveHeadList(&DropList);
        Packet = PacketInfo->NdisPacket;

        (*Pipe->PsProcs->DropPacket)(Pipe->PsPipeContext, Flow->PsFlowContext,  Packet, NDIS_STATUS_FAILURE);
    }

    PsDbgOut(DBG_INFO, DBG_SCHED_DRR, ("PSCHED: DrrSeq flow emptied\n"));

    (*Pipe->ContextInfo.NextComponent->EmptyFlow)(
                Pipe->ContextInfo.NextComponentContext,
                Flow->ContextInfo.NextComponentContext);
} 




static NDIS_STATUS 
DrrSeqCreateClassMap (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsClassMapContext,
    IN PTC_CLASS_MAP_FLOW ClassMap,
    IN PPS_CLASS_MAP_CONTEXT ComponentClassMapContext)
{
    PDSEQ_PIPE Pipe = (PDSEQ_PIPE)PipeContext;
    return (*Pipe->ContextInfo.NextComponent->CreateClassMap)(
        Pipe->ContextInfo.NextComponentContext,
        PsClassMapContext,
        ClassMap,
        ComponentClassMapContext->NextComponentContext);
}



static NDIS_STATUS 
DrrSeqDeleteClassMap (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_CLASS_MAP_CONTEXT ComponentClassMapContext)
{
    PDSEQ_PIPE Pipe = (PDSEQ_PIPE)PipeContext;
    return (*Pipe->ContextInfo.NextComponent->DeleteClassMap)(
        Pipe->ContextInfo.NextComponentContext,
        ComponentClassMapContext->NextComponentContext);
}




BOOLEAN
DrrSeqSubmitPacket (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PPS_CLASS_MAP_CONTEXT ClassMapContext,
    IN PPACKET_INFO_BLOCK PacketInfo
    )

/*++

Routine Description:

    Packet submission routine for the DRR sequencer.

Arguments:

    PipeContext -   Pointer to this component's pipe context area
    FlowContext -   Pointer to this component's flow context area
    Packet -        Pointer to packet

Return Values:

    Always returns TRUE

--*/
{
    PDSEQ_PIPE Pipe =   (PDSEQ_PIPE)PipeContext;
    PDSEQ_FLOW Flow =   (PDSEQ_FLOW)FlowContext;
    LARGE_INTEGER       CurrentTime;
    PNDIS_PACKET Packet = PacketInfo->NdisPacket;
    BOOLEAN FlowInactive;
    PGPC_CLIENT_VC      Vc = Flow->PsFlowContext;

    if(Pipe->Flags & DSEQ_PASSTHRU)
    {
        InterlockedIncrement( &Pipe->OutstandingSends );

        if(Pipe->OutstandingSends > Pipe->Stats.MaxPacketsInNetcard){
            Pipe->Stats.MaxPacketsInNetcard = Pipe->OutstandingSends;
        }


        if(gEnableAvgStats)
        {
            //
            // Track max packets outstanding. This is a measure
            // of how congested the media gets. Of course, it
            // will be clipped by the MaxOutstandingSends parameter.
            // So - for a valid reading, need to set MOS very large.
            //
            Pipe->Stats.AveragePacketsInNetcard =
                RunningAverage(Pipe->PacketsInNetcardAveragingArray,
                               Pipe->OutstandingSends);
        }

        //
        // Note: The 802.1p is already set by the wrapper
        //

        if (!(*Pipe->ContextInfo.NextComponent->SubmitPacket)(
                Pipe->ContextInfo.NextComponentContext,
                Flow->ContextInfo.NextComponentContext,
                (ClassMapContext != NULL) ? ClassMapContext->NextComponentContext : NULL,
                PacketInfo)) {

            (*Pipe->PsProcs->DropPacket)(Pipe->PsPipeContext, Flow->PsFlowContext, Packet, NDIS_STATUS_FAILURE);

        }

        return TRUE;
    }
    

    LOCK_PIPE(Pipe);

    if (Flow->State == DRRSEQ_FLOW_DELETED) 
    {
         UNLOCK_PIPE(Pipe);
         return FALSE;
    }

    //
    // On WanLinks, when we are doing DRR, we need to put a maximum on the queue-limit.
    // NDISWAN has a queue limit of 132KBytes on a modem link; So, we'll limit it to 120
    // packets by default.
    //

    if( ( Pipe->Bandwidth <= MAX_LINK_SPEED_FOR_DRR) &&
        ( Pipe->MaxOutstandingSends == 1) &&
	( Pipe->PacketsInSequencer >= 120) )
    {
	    UNLOCK_PIPE( Pipe);
	    return FALSE;
    }


    //
    //  There is one case where the PIPE might go away because the send-complete happened
    //  on a VC belonging to it before the send returned. So, to prevent that, we add a 
    //  Ref on that VC and take it out just before the send returns.
    //

    //  Add a Ref.
    InterlockedIncrement(&Vc->RefCount);

    PacketInfo->FlowContext = FlowContext;
    PacketInfo->ClassMapContext = ClassMapContext;

    Pipe->PacketsInSequencer++;

    if(Pipe->PacketsInSequencer > Pipe->Stats.MaxPacketsInSequencer){
        Pipe->Stats.MaxPacketsInSequencer = Pipe->PacketsInSequencer;
    }

    Flow->PacketsInSequencer++;
    if (Flow->PacketsInSequencer > Flow->Stats.MaxPacketsInSequencer){
        Flow->Stats.MaxPacketsInSequencer = Flow->PacketsInSequencer;
    }



    if(gEnableAvgStats)
    {
        //
        // Track packets in the sequencer at any time.
        //
        Pipe->Stats.AveragePacketsInSequencer = 
            RunningAverage(Pipe->PacketsInSequencerAveragingArray,
                               Pipe->PacketsInSequencer);

        Flow->Stats.AveragePacketsInSequencer =
            RunningAverage(Flow->PacketsInSeqAveragingArray, Flow->PacketsInSequencer);

    }

    FlowInactive = IsListEmpty(&Flow->PacketQueue);
    InsertTailList(&Flow->PacketQueue, &PacketInfo->SchedulerLinks);

    PsGetCurrentTime(&CurrentTime);

    PsDbgSched(DBG_INFO,
               DBG_SCHED_DRR, 
               DRR_SEQUENCER, PKT_ENQUEUE, Flow->PsFlowContext,
               Packet, PacketInfo->PacketLength, Flow->Priority,
               CurrentTime.QuadPart,
               PacketInfo->ConformanceTime.QuadPart,
               Pipe->PacketsInSequencer,
               0);

    if (FlowInactive) {
        Flow->PacketSendTime.QuadPart += 
            (PacketInfo->ConformanceTime.QuadPart - Flow->LastConformanceTime.QuadPart);

        Flow->DeficitCounter = Flow->Quantum;
        Pipe->TotalActiveFlows++;
        Pipe->ActiveFlowCount[Flow->PriorityGroup]++;
        if (!PacketIsConforming(Flow, PacketInfo, CurrentTime, Pipe->TimerResolution)) {
            InsertTailList(&Pipe->ActiveFlows[0], &Flow->ActiveLinks);
        } else {
            InsertTailList(&Pipe->ActiveFlows[Flow->Priority], &Flow->ActiveLinks);
        }
    }

    while ((Pipe->TotalActiveFlows > 0) &&
           (Pipe->OutstandingSends < Pipe->MaxOutstandingSends) &&
           ((Pipe->Flags & DSEQ_DEQUEUE) == 0)) {

        DequeuePackets(Pipe);
    }

    UNLOCK_PIPE(Pipe);

    //  Take out the ref.
    DerefClVc(Vc);

    return TRUE;

} // DrrSeqSubmitPacket



VOID
DrrSeqSendComplete (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PNDIS_PACKET Packet
    )

/*++

Routine Description:

    Send complete handler for the DRR sequencer.

Arguments:

    PipeContext -       Pointer to this component's pipe context area
    FlowContext -       Pointer to this component's flow context area
    Packet -            Packet that has completed sending

Return Values:

--*/
{
    PDSEQ_PIPE Pipe = (PDSEQ_PIPE)PipeContext;

    InterlockedDecrement( &Pipe->OutstandingSends);

    //  Need to do this only if the sequencer is not in the bypass mode //
    if( (Pipe->Flags & DSEQ_PASSTHRU) == 0)
    {
        LOCK_PIPE(Pipe);
        
        PsAssert((LONG)Pipe->OutstandingSends >= 0);

        while ((Pipe->TotalActiveFlows > 0) &&
               (Pipe->OutstandingSends < Pipe->MaxOutstandingSends) &&
               ((Pipe->Flags & DSEQ_DEQUEUE) == 0)) {

            DequeuePackets(Pipe);
        }

        UNLOCK_PIPE(Pipe);
    }

    //
    // Call the previous upcalls (if any)
    //
    if(Pipe->PreviousUpcallsSendComplete)
    {
        (*Pipe->PreviousUpcallsSendComplete)(Pipe->PreviousUpcallsSendCompletePipeContext, Packet);
    }

} // DrrSeqSendComplete



VOID
DrrSetInformation (
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_FLOW_CONTEXT ComponentFlowContext,
    IN NDIS_OID Oid,
    IN ULONG Len,
    IN PVOID Data)
{
    PDSEQ_PIPE Pipe = (PDSEQ_PIPE)ComponentPipeContext;
    PDSEQ_FLOW Flow = (PDSEQ_FLOW)ComponentFlowContext;

    switch(Oid) 
    {
      case OID_QOS_STATISTICS_BUFFER:
          if(Flow) {
              NdisZeroMemory(&Flow->Stats, sizeof(PS_DRRSEQ_STATS));
          }
          else {
              NdisZeroMemory(&Pipe->Stats, sizeof(PS_DRRSEQ_STATS));
          }
          break;
      default:
          break;
    }
    
    (*Pipe->ContextInfo.NextComponent->SetInformation)(
        Pipe->ContextInfo.NextComponentContext,
        (Flow)?Flow->ContextInfo.NextComponentContext:0,
        Oid,
        Len,
        Data);
}


VOID
DrrQueryInformation (
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_FLOW_CONTEXT ComponentFlowContext,
    IN NDIS_OID Oid,
    IN ULONG Len,
    IN PVOID Data,
    IN OUT PULONG BytesWritten,
    IN OUT PULONG BytesNeeded,
    IN OUT PNDIS_STATUS Status)
{
    PDSEQ_PIPE Pipe = (PDSEQ_PIPE)ComponentPipeContext;
    PDSEQ_FLOW Flow = (PDSEQ_FLOW)ComponentFlowContext;
    PS_COMPONENT_STATS Stats;
    ULONG Size;
    ULONG RemainingLength;

    switch(Oid) 
    {
      case OID_QOS_STATISTICS_BUFFER:

          Size = sizeof(PS_DRRSEQ_STATS) + FIELD_OFFSET(PS_COMPONENT_STATS, Stats);

          if(*Status == NDIS_STATUS_SUCCESS) 
          {
              //
              // The previous component has succeeded - Let us
              // see if we can write the data
              //

              RemainingLength = Len - *BytesWritten;
    
              if(RemainingLength < Size) {

                  *Status = NDIS_STATUS_BUFFER_TOO_SHORT;

                  *BytesNeeded = Size + *BytesWritten;

                  *BytesWritten = 0;

              }
              else {

                  PPS_COMPONENT_STATS Cstats = (PPS_COMPONENT_STATS) Data;

                  *BytesWritten += Size;
                  
                  *BytesNeeded = 0;

                  if(Flow) {

                      Cstats->Type = PS_COMPONENT_DRRSEQ;
                      Cstats->Length = sizeof(PS_DRRSEQ_STATS);
                      NdisMoveMemory(&Cstats->Stats, &Flow->Stats, sizeof(PS_DRRSEQ_STATS));
                  }
                  else {

                      Cstats->Type = PS_COMPONENT_DRRSEQ;
                      Cstats->Length = sizeof(PS_DRRSEQ_STATS);
                      
                      NdisMoveMemory(&Cstats->Stats, &Pipe->Stats, sizeof(PS_DRRSEQ_STATS));

                  }

                  //
                  // Advance Data so that the next component can update its stats
                  //
                  Data = (PVOID) ((PUCHAR)Data + Size);
              }
          }
          else {

              *BytesNeeded += Size;
              
              *BytesWritten = 0;
          }

          break;
          
      default:

          break;
    }

    
    (*Pipe->ContextInfo.NextComponent->QueryInformation)(
        Pipe->ContextInfo.NextComponentContext,
        (Flow)?Flow->ContextInfo.NextComponentContext : 0,
        Oid,
        Len,
        Data,
        BytesWritten,
        BytesNeeded,
        Status);
        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\globals.h ===
/*++

Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

    globals.h

Abstract:

    global defines and definitions

Author:

    Charlie Wickham (charlwi) 19-Apr-1996

Revision History:

--*/

#ifndef _GLOBALS_
#define _GLOBALS_



//
// Macros 
//

#define IsDeviceStateOn(_a) ((_a)->MPDeviceState == NdisDeviceStateD0 && (_a)->PTDeviceState == NdisDeviceStateD0)


#define IsBestEffortVc(_vc)  (_vc->Flags & GPC_CLIENT_BEST_EFFORT_VC)

#define InitGpcClientVc(x, flags, _adapter)            \
    NdisZeroMemory((x), sizeof(GPC_CLIENT_VC));        \
    (x)->Adapter = (_adapter);                         \
    PS_INIT_SPIN_LOCK(&(x)->Lock);                     \
    (x)->RefCount = 1;                                 \
    (x)->ClVcState = CL_CALL_PENDING;                  \
    (x)->Flags = (flags);                              \
    NdisInitializeEvent(&(x)->GpcEvent);               \


// given a pointer to an NDIS_PACKET, return a pointer to PS' protocol
// context area.
//
#define PS_SEND_PACKET_CONTEXT_FROM_PACKET(_pkt)   \
    ((PPS_SEND_PACKET_CONTEXT)((_pkt)->ProtocolReserved))

#define PS_RECV_PACKET_CONTEXT_FROM_PACKET(_pkt)   \
    ((PPS_RECV_PACKET_CONTEXT)((_pkt)->ProtocolReserved))


#define MIN_PACKET_POOL_SIZE            0x000000FF
#define MAX_PACKET_POOL_SIZE            0x0000FFFF-MIN_PACKET_POOL_SIZE

#define DEFAULT_MAX_OUTSTANDING_SENDS   0xFFFFFFFF     /* Just making sure we don't do DRR by default..*/
#define DEFAULT_ISSLOW_TOKENRATE        8192           /* In Bytes per second = 64 Kbps */
#define DEFAULT_ISSLOW_PACKETSIZE       200            /* In Bytes */
#define DEFAULT_ISSLOW_FRAGMENT_SIZE    100            /* In Bytes */
#define DEFAULT_ISSLOW_LINKSPEED        19200          /* In Bytes  per second = 128 Kbps */

#define PS_IP_SERVICETYPE_CONFORMING_BESTEFFORT_DEFAULT          0
#define PS_IP_SERVICETYPE_CONFORMING_CONTROLLEDLOAD_DEFAULT      0x18
#define PS_IP_SERVICETYPE_CONFORMING_GUARANTEED_DEFAULT          0x28
#define PS_IP_SERVICETYPE_CONFORMING_QUALITATIVE_DEFAULT         0
#define PS_IP_SERVICETYPE_CONFORMING_NETWORK_CONTROL_DEFAULT     0x30
#define PS_IP_SERVICETYPE_CONFORMING_TCPTRAFFIC_DEFAULT          0
#define PS_IP_SERVICETYPE_NONCONFORMING_BESTEFFORT_DEFAULT       0
#define PS_IP_SERVICETYPE_NONCONFORMING_CONTROLLEDLOAD_DEFAULT   0
#define PS_IP_SERVICETYPE_NONCONFORMING_GUARANTEED_DEFAULT       0
#define PS_IP_SERVICETYPE_NONCONFORMING_QUALITATIVE_DEFAULT      0
#define PS_IP_SERVICETYPE_NONCONFORMING_NETWORK_CONTROL_DEFAULT  0
#define PS_IP_SERVICETYPE_NONCONFORMING_TCPTRAFFIC_DEFAULT       0

#define PS_IP_DS_CODEPOINT_MASK                    0x03  //
#define PREC_MAX_VALUE                             0x3f  // Range for the prec value.


#define PS_USER_SERVICETYPE_NONCONFORMING_DEFAULT   1
#define PS_USER_SERVICETYPE_BESTEFFORT_DEFAULT      0
#define PS_USER_SERVICETYPE_CONTROLLEDLOAD_DEFAULT  4
#define PS_USER_SERVICETYPE_GUARANTEED_DEFAULT      5
#define PS_USER_SERVICETYPE_QUALITATIVE_DEFAULT     0
#define PS_USER_SERVICETYPE_NETWORK_CONTROL_DEFAULT 7
#define PS_USER_SERVICETYPE_TCPTRAFFIC_DEFAULT      0
#define USER_PRIORITY_MAX_VALUE                     7 // Range (0-7) for 802.1p

#define WAN_TABLE_INITIAL_SIZE                     16
#define WAN_TABLE_INCREMENT                        32
extern PULONG_PTR     g_WanLinkTable;
extern USHORT         g_NextWanIndex;
extern USHORT         g_WanTableSize;


//  Timer Wheel params  //
extern      ULONG               TimerTag;
extern      ULONG               TsTag;


#define INSTANCE_ID_SIZE                (sizeof(WCHAR) * 20)

//
// the TC-API supports the following service types.
//
// SERVICETYPE_BESTEFFORT
// SERVICETYPE_NETWORK_CONTROL
// SERVICETYPE_QUALITATIVE
// SERVICETYPE_CONTROLLEDLOAD
// SERVICETYPE_GUARANTEED
// SERVICETYPE_NONCONFORMING 
//

#define NUM_TC_SERVICETYPES                        6
//
// These are the states for the GPC client's VCs. We need to keep a fair 
// amount of state because we can get closes from the call manager below us, 
// from an unbind, or from the GPC.
//

typedef enum _CL_VC_STATE {
    CL_VC_INITIALIZED = 1,
    CL_CALL_PENDING,
    CL_INTERNAL_CALL_COMPLETE,
    CL_CALL_COMPLETE,
    CL_MODIFY_PENDING,
    CL_GPC_CLOSE_PENDING,
    CL_INTERNAL_CLOSE_PENDING
} CL_VC_STATE;

typedef enum _PS_DEVICE_STATE {
    PS_DEVICE_STATE_READY = 0,
    PS_DEVICE_STATE_ADDING,
    PS_DEVICE_STATE_DELETING
} PS_DEVICE_STATE;


extern  ULONG   CreateDeviceMutex;

//
// Simple Mutual Exclusion constructs used in preference to
// using KeXXX calls since we don't have Mutex calls in NDIS.
// These can only be called at passive IRQL.
//

#define MUX_ACQUIRE_MUTEX(_pMutexCounter)                               \
{                                                                       \
    while (NdisInterlockedIncrement(_pMutexCounter) != 1)               \
    {                                                                   \
        NdisInterlockedDecrement(_pMutexCounter);                       \
        NdisMSleep(10000);                                              \
    }                                                                   \
}

#define MUX_RELEASE_MUTEX(_pMutexCounter)                               \
{                                                                       \
    NdisInterlockedDecrement(_pMutexCounter);                           \
}


//
// CL_VC_STATE is further modified by these flags.
//

// Indicates that the GPC has requested a close, 
// which we will need to complete.

// COMPLETE_GPC_CLOSE      : GPC has requested a close which we will need to 
//                           complete. 
// INTERNAL_CLOSE_REQUESTED: Indicates that an internal close has been 
//                           requested and should be processed upon completion
//                           of the call.

#define GPC_CLOSE_REQUESTED        0x00000001   
#define INTERNAL_CLOSE_REQUESTED   0x00000002   
#define GPC_CLIENT_BEST_EFFORT_VC  0x00000008
#define GPC_MODIFY_REQUESTED       0x00000010  
#define GPC_WANLINK_VC             0x00000020
#define GPC_ISSLOW_FLOW            0x00000040


//
// These are the states for the BE Vc. In addition to keeping the standard
// CL Vc states for this Vc, we also keep some specific state. The BE Vc
// is initially BE_VC_INITIALIZED. It becomes BE_VC_RUNNING after it has 
// successfully been opened. When it is time to shut down the BE Vc, it 
// goes to BE_VC_CLOSING if there are no pending packets, or to 
// BE_WAITING_FOR_PENDING_PACKETS, if there are pending packets.
//

extern PUCHAR GpcVcState[];

//
// The best effort VC structure for each adapter is contained in 
// the adapter structure. Also - each vc points to the adapter 
// with which it is associated. Therefore, pointers to best-effort 
// VCs can be identified beause they are the same address as the
// offset of the best-effort VC in the adapter struct with which
// they are associated.
//


//
// current state of PS's MP device
//
typedef enum _ADAPTER_STATE {
    AdapterStateInitializing = 1,
    AdapterStateRunning,
    AdapterStateWaiting,
    AdapterStateDisabled,
    AdapterStateClosing,
    AdapterStateClosed
} ADAPTER_STATE;

typedef enum _DRIVER_STATE {
    DriverStateLoaded = 1,
    DriverStateUnloading,
    DriverStateUnloaded
} DRIVER_STATE;

typedef enum _ADAPTER_MODE {
    AdapterModeDiffservFlow = 1,
    AdapterModeRsvpFlow
} ADAPTER_MODE;

//
// shutdown mask values
//

#define SHUTDOWN_CLOSE_WAN_ADDR_FAMILY       0x00000002   // Per adapter
#define SHUTDOWN_DELETE_PIPE                 0x00000008   // Per adapter
#define SHUTDOWN_FREE_PS_CONTEXT             0x00000010   // Per adapter
#define SHUTDOWN_UNBIND_CALLED               0x00000020   // Per adapter
#define SHUTDOWN_MPHALT_CALLED               0x00000040   // Per adapter
#define SHUTDOWN_CLEANUP_ADAPTER             0x00000080   // Per adapter
#define SHUTDOWN_PROTOCOL_UNLOAD             0x00000100   // Per adapter
#define SHUTDOWN_BIND_CALLED                 0x00000200   // Per adapter
#define SHUTDOWN_MPINIT_CALLED               0x00000400   // per adapter

#define SHUTDOWN_RELEASE_TIMERQ         0x00010000
#define SHUTDOWN_DEREGISTER_PROTOCOL    0x00040000
#define SHUTDOWN_DELETE_DEVICE          0x00080000
#define SHUTDOWN_DELETE_SYMLINK         0x00100000
#define SHUTDOWN_DEREGISTER_GPC         0x00200000
#define SHUTDOWN_DEREGISTER_MINIPORT    0x00400000

#define LOCKED 0
#define UNLOCKED 1

#define NEW_VC 0
#define MODIFY_VC 1


//
// QOS related
//

#define QOS_UNSPECIFIED (ULONG)-1

//
// bandwidth related
//

#define UNSPECIFIED_RATE                -1 // indefinite bandwidth
#define RESERVABLE_FRACTION         80 // percentage of link speed

//
// state flags for WAN AF bindings
//

#define WAN_ADDR_FAMILY_OPEN            0x00000001

//
// types of VCs. Note that dummy VCs are created to represent WAN links.
// This allows them to be registered with WMI. They are differentiated by
// the VC type.
//

#define VC_FLOW         1
#define VC_WAN_INTFC    2

typedef struct _PS_SPIN_LOCK 
{
    NDIS_SPIN_LOCK Lock;
#if DBG
    LONG  LockAcquired;
    UCHAR LastAcquiredFile[8];
    ULONG LastAcquiredLine;
    UCHAR LastReleasedFile[8];
    ULONG LastReleasedLine;
#endif
} PS_SPIN_LOCK, *PPS_SPIN_LOCK;



#define BEVC_LIST_LEN   3       //  We have these many BEVCs to do DRR.
#define PORT_LIST_LEN   1       //  Each BEVC will store upto these many port numbers.



typedef struct _GPC_CLIENT_VC {

    //
    // LLTag - for tracking allocation from and freeing to LL list.
    //
    // Lock
    //
    // RefCount
    //
    //
    // Linkage - to put on the adapter block list
    //
    // ClVcState
    //
    // Flags - further modify state
    //
    // AdapterBlk - pointer to associated ADAPTER_BLK context
    //
    // CfInfoHandle - handle to CfInfo
    //
    // InstanceName - copy of instance name registered with WMI for this flow
    //
    // CfType - GPC classification family associated with this VC
    //
    // VcHandle - handle to VC created for this flow
    //
    // CallParameters - pointer to call parameters saved while a MakeCall or
    //                  ModifyCallQoS is in progress
    //
    // AdapterStats - pointer to the Adapter Stats (for non WAN links) or 
    //                per WAN stats.

    STRUCT_LLTAG;
    ULONG                   RefCount;
    CL_VC_STATE             ClVcState;
    struct _ADAPTER         *Adapter;
    ULONG                   Flags;
    PS_SPIN_LOCK            Lock;

    LIST_ENTRY              Linkage;
    NDIS_STRING             InstanceName;

    UCHAR                   IPPrecedenceNonConforming;
    UCHAR                   UserPriorityConforming;
    UCHAR                   UserPriorityNonConforming;
    GPC_HANDLE              CfInfoHandle;
    PCF_INFO_QOS            CfInfoQoS;
    PCF_INFO_QOS            ModifyCfInfoQoS;
    GPC_HANDLE              CfType;
    NDIS_HANDLE             NdisWanVcHandle;
    PCO_CALL_PARAMETERS     CallParameters;
    PCO_CALL_PARAMETERS     ModifyCallParameters;
    PPS_ADAPTER_STATS       AdapterStats;
    struct _PS_WAN_LINK     *WanLink;

    //
    // For the Scheduling Components
    //
    PPS_FLOW_CONTEXT        PsFlowContext;
    PS_FLOW_STATS           Stats;
    ULONG                   TokenRateChange;
    ULONG                   RemainingBandwidthIncreased;
    ULONG                   ShapeTokenRate;
    ULONG                   ISSLOWFragmentSize;

    //
    // These are used to optmize the send path. Over non Wan links, these point to
    // Adapter->PsComponent and Adapter->PsPipeContext. Over WanLinks, these point
    // to WanLink->PsComponent and WanLink->PspipeContext.
    //
    PPSI_INFO               PsComponent;
    PPS_PIPE_CONTEXT        PsPipeContext;
    PSU_SEND_COMPLETE       SendComplete;
    PPS_PIPE_CONTEXT        SendCompletePipeContext;
    NDIS_EVENT              GpcEvent;

    //
    //  This flag is added to indicate whether the RemoveFlow() should be called upon ref-count=0 
    //
    BOOL                    bRemoveFlow;

    //  We'll hold on to flows in this array    //
    USHORT                  SrcPort[PORT_LIST_LEN];
    USHORT                  DstPort[PORT_LIST_LEN];
    USHORT                  NextSlot;

} GPC_CLIENT_VC, *PGPC_CLIENT_VC;


typedef struct _DIFFSERV_MAPPING {
    PGPC_CLIENT_VC   Vc;
    UCHAR            ConformingOutboundDSField;
    UCHAR            NonConformingOutboundDSField;
    UCHAR            ConformingUserPriority;
    UCHAR            NonConformingUserPriority;
} DIFFSERV_MAPPING, *PDIFFSERV_MAPPING;


typedef struct _ADAPTER {

    LIST_ENTRY Linkage;

    //
    // MpDeviceName, UpperBinding - unicode device names for 
    // the underlying MP device and the UpperBinding exposed. 
    // The buffers for the strings are allocated with the 
    // adapter and need to be freed with it.
    //
    // ShutdownMask - mask of operations to perform during 
    // unbinding from lower MP
    //

    PS_SPIN_LOCK Lock;
    REF_CNT RefCount;

    NDIS_STRING MpDeviceName;
    NDIS_STRING UpperBinding;
    NDIS_STRING WMIInstanceName;
    NDIS_STRING ProfileName;

    // Points to the "psched\parameter\adapter\...\"
    NDIS_STRING RegistryPath;


    ULONG ShutdownMask;
    PNETWORK_ADDRESS_LIST IpNetAddressList;
    PNETWORK_ADDRESS_LIST IpxNetAddressList;

    //
    // PsMpState - init'ing, running, or closing
    //
    // PsNdisHandle - the handle that identifies the PS device to NDIS
    //
    // BlockingEvent - used to synchronize execution of functions that are
    // awaiting completion
    //
    // FinalStatus - holds status returned in completion routine
    //
    // SendBlockPool    - Pool Handle for per-packet info in the send path
    // SendPacketPool   - Pool handle for NDIS packets in the send path. 
    // RecvPacketPool   - Pool handle for NDIS packets in the recv path. 
    //
    // RawLinkSpeed - link speed as determined by OID_GEN_LINK_SPEED,
    // in 100 bps units.
    //
    // BestEffortLimit - Bps for internal best effort VC; 
    //
    // NonBestEffortLimit - Bps for total non best effort flows;
    //
    // ReservationLimitValue - The % of bandwidth that has to be used for non b/e flows.
    //
    // BestEffortVc - internal best effort VC struct
    //
    // BestEffortVcCreated - set after the VC has been created
    //
    // WanLinkList - list of WAN links on the underlying NDISWAN
    //

    ADAPTER_STATE PsMpState;
    NDIS_HANDLE PsNdisHandle;
    NDIS_EVENT BlockingEvent;
    NDIS_EVENT RefEvent;
    NDIS_EVENT MpInitializeEvent;
    NDIS_EVENT LocalRequestEvent;
    NDIS_STATUS FinalStatus;
    NDIS_HANDLE  SendPacketPool;
    NDIS_HANDLE  RecvPacketPool;
    NDIS_HANDLE  SendBlockPool;  
    ULONG RawLinkSpeed;
    ULONG BestEffortLimit;
    ULONG NonBestEffortLimit;
    ULONG ReservationLimitValue;
    GPC_CLIENT_VC BestEffortVc;
    LIST_ENTRY WanLinkList;

    
    //
    // Scheduler info:
    //
    // PSComponent - pointer to info first scheduling component
    //
    // PSPipeContext - scheduling component's context area for pipe
    //
    // BestEffortPSFlowContext - scheduling component's context area 
    //  for best effort VC
    //
    // FlowContextLength - length of flow context area for scheduler
    //
    // PacketContextLength - length of packet context area
    //
    // SendComplete - scheduler's send completion routine
    //

    PPSI_INFO PsComponent;
    PPS_PIPE_CONTEXT PsPipeContext;
    ULONG PipeContextLength;
    BOOLEAN PipeHasResources;
    ULONG FlowContextLength;
    ULONG PacketContextLength;
    ULONG ClassMapContextLength;

    //
    // Underlying adapter info - handle, type, etc.
    // LowerMPHandle - the binding handle to the underlying MP
    // BindContext - used in BindAdapterHandler 
    // MediaType - self explanatory I would hope
    // LinkSpeed - in 100 bits/sec
    // TotalSize - max # of bytes including the header.
    // RemainingBandWidth - amount of schedulable bytes/second left on this adapter
    // PipeFlags - copy of flags parameter handed to scheduler during pipe initialization
    // HeaderSize - number of bytes in MAC header for this adapter
    // IPHeaderOffset - offset of the IP header - This could be different from HeaderSize because
    //                  the transport could add a LLC/SNAP header.
    // Stats - per adapter stats counters
    // SDModeControlledLoad - Default handling for non-conforming controlled load traffic
    // SDModeGuaranteed - Default handling for non-conforming guaranteed service traffic
    // MaxOutstandingSends - Maximum number of outstanding sends allowed

    NDIS_HANDLE LowerMpHandle;
    NDIS_MEDIUM MediaType;
    NDIS_HANDLE BindContext;
    ULONG LinkSpeed;
    ULONG TotalSize;
    ULONG RemainingBandWidth;
    ULONG PipeFlags;
    ULONG HeaderSize;
    ULONG IPHeaderOffset;
    PS_ADAPTER_STATS Stats;
    ULONG SDModeControlledLoad;
    ULONG SDModeGuaranteed;
    ULONG SDModeNetworkControl;
    ULONG SDModeQualitative;
    ULONG MaxOutstandingSends;

    //
    // WanCmHandle - handle to the WAN call manager, as returned from 
    //              NdisClOpenAddressFamily.
    //

    NDIS_HANDLE WanCmHandle;

    //
    // WanBindingState - state of WAN call manager binding

    ULONG WanBindingState;

    UCHAR IPServiceTypeBestEffort;
    UCHAR IPServiceTypeControlledLoad;
    UCHAR IPServiceTypeGuaranteed;
    UCHAR IPServiceTypeNetworkControl;
    UCHAR IPServiceTypeQualitative;
    UCHAR IPServiceTypeTcpTraffic;
    UCHAR IPServiceTypeBestEffortNC;
    UCHAR IPServiceTypeControlledLoadNC;
    UCHAR IPServiceTypeGuaranteedNC;
    UCHAR IPServiceTypeNetworkControlNC;
    UCHAR IPServiceTypeQualitativeNC;
    UCHAR IPServiceTypeTcpTrafficNC;

    UCHAR UserServiceTypeNonConforming;
    UCHAR UserServiceTypeBestEffort;
    UCHAR UserServiceTypeControlledLoad;
    UCHAR UserServiceTypeGuaranteed;
    UCHAR UserServiceTypeNetworkControl;
    UCHAR UserServiceTypeQualitative;
    UCHAR UserServiceTypeTcpTraffic;

    //
    // No of CfInfos - In the send path, this is used to determine whether we 
    // have to classify the packet or send it over the b/e VC
    //
    ULONG CfInfosInstalled;
    ULONG FlowsInstalled;
    LIST_ENTRY GpcClientVcList;
    ULONG WanLinkCount;

    LARGE_INTEGER VcIndex;

#if DBG
    ULONG GpcNotifyPending;
#endif
    PDIFFSERV_MAPPING pDiffServMapping;
    ADAPTER_MODE AdapterMode;
    ULONG ISSLOWTokenRate;
    ULONG ISSLOWPacketSize;
    ULONG ISSLOWFragmentSize;
    ULONG ISSLOWLinkSpeed;
    BOOLEAN IndicateRcvComplete;
    BOOLEAN IfcNotification;
    BOOLEAN StandingBy;
    ULONG OutstandingNdisRequests;
    NDIS_DEVICE_POWER_STATE MPDeviceState;
    NDIS_DEVICE_POWER_STATE PTDeviceState;
    USHORT ProtocolType;
    struct _PS_NDIS_REQUEST *PendedNdisRequest;
    TC_INTERFACE_ID InterfaceID;

} ADAPTER, *PADAPTER;



//
// Wan links are created when we get a WAN_LINE_UP from an underlying 
// NDISWAN. There may be multiple WAN links per adapter. Each WAN link
// has a single best-effort VC on it and may have any number of additional 
// VCs (one per flow).
//

//
// WAN VC - describes a VC associated with this WAN link
//

typedef enum _WAN_STATE {
    WanStateOpen = 1,
    WanStateClosing
} WAN_STATE;

typedef struct _PS_WAN_LINK 
{
    WAN_STATE               State;
    LIST_ENTRY              Linkage;
    ULONG                   RawLinkSpeed;     // In 100 bps
    ULONG                   LinkSpeed;        // In Bps (Bytes per second)
    UCHAR                   OriginalLocalMacAddress[ARP_802_ADDR_LENGTH];
    UCHAR                   OriginalRemoteMacAddress[ARP_802_ADDR_LENGTH];
    REF_CNT                 RefCount;
    DIAL_USAGE              DialUsage;
    USHORT                  ProtocolType;
    ULONG                   LocalIpAddress;
    ULONG                   RemoteIpAddress;
    ULONG                   LocalIpxAddress;
    ULONG                   RemoteIpxAddress;
    PS_ADAPTER_STATS        Stats;
    PS_SPIN_LOCK            Lock;
    ULONG                   FlowsInstalled;
    NDIS_STRING             InstanceName;
    NDIS_STRING             MpDeviceName;
    PADAPTER                Adapter;
    ULONG                   RemainingBandWidth;
    ULONG                   NonBestEffortLimit;
    PPSI_INFO               PsComponent;
    PPS_PIPE_CONTEXT        PsPipeContext;
    ULONG                   ShutdownMask;
    USHORT                  UniqueIndex;
    ETH_HEADER              SendHeader;
    ETH_HEADER              RecvHeader;
    ADAPTER_MODE            AdapterMode;
    PDIFFSERV_MAPPING       pDiffServMapping;
    ULONG                   CfInfosInstalled;
    TC_INTERFACE_ID         InterfaceID;

    GPC_CLIENT_VC           BestEffortVc;
    GPC_CLIENT_VC           BeVcList[ BEVC_LIST_LEN ];
    int                     NextVc;
    

} PS_WAN_LINK, *PPS_WAN_LINK;
    
//
// our NdisRequest super structure. There are two types of NdisRequests: 
// originated by the upper layer which go straight through to the 
// underlying miniport and originated by the PS. The latter also 
// degenerates into blocking and nonblocking.
//
// Since upper layer NdisRequests are unbundled to MPs, we need to 
// allocate our own structure to rebuild and issue the request to 
// the lower layer. We need some addt'l space to hold pointers to the 
// BytesWritten/BytesRead and BytesNeeded parameters of the original 
// request. These are tagged on at the end so the NdisRequest completion 
// routine can set those values in the NdisRequest originally issued to PS.
//
// There are allocated by NdisAllocateFromNPagedLookasideList, there is a STRUCT_LLTAG.
// LocalRequest means the request was issued by PS and shouldn't be 
// completed to the higher layer. If a LocalCompletion routine is specified, 
// then this is a nonblocking request.
//
// OriginalNdisRequest is used to complete a higher layer CoRequest.
//

typedef VOID (*LOCAL_NDISREQUEST_COMPLETION_FUNCTION)(PADAPTER,
                                                      NDIS_STATUS);
typedef struct _PS_NDIS_REQUEST {
    NDIS_REQUEST ReqBuffer; // Must be first!!!
    STRUCT_LLTAG;
    PULONG BytesReadOrWritten;
    PULONG BytesNeeded;
    BOOLEAN LocalRequest;
    LOCAL_NDISREQUEST_COMPLETION_FUNCTION LocalCompletionFunc;
} PS_NDIS_REQUEST, *PPS_NDIS_REQUEST;


//
// use Generic NdisRequest types to indicate NdisRequests that 
// were originated by PS
//

#define NdisRequestLocalSetInfo     NdisRequestGeneric1
#define NdisRequestLocalQueryInfo   NdisRequestGeneric2

//
// Packet context structure. This area resides at the start of 
// the ProtocolReserved area of each packet
//
// Info - packet info block for this packet. Includes information 
//      potentially needed by the scheduling components: queue links, 
//      conformance time, packet length.
//
// AdapterVCLink - links packet on Adapter VC's list of outstanding 
//      packets. Once a packet is removed from the timer Q for sending, 
//      it is also removed from this list. This list is used to free 
//      packets that are awaiting transmission when the adapter VC is 
//      deactivate. Packets in the process of being transmitted
//      aren't linked since a reference was taken out for each packet 
//      associated with the adapter VC.
//
// The following vars are used only during the sending of a packet:
//
// OriginalPacket - a pointer to the original packet (duh) handed to us by
//      the upper layer.
//
// AdapterVC - pointer back to AdapterVC struct. Used during send completion so
//      completion is propagated to higher layer in the correct manner
//
// SchedulingComponentInfo - Any packet context area required by the scheduling
//     components is stored after the PS's packet context.  If none of the
//     components need additional context area, then this area is not included.
//
// MediaSpecificInfo - used to hold packet priority for MPs that allow packet
//     priority to be specified. Included in the proto reserved area only if
//     the lower MP supports priority queueing. Immediately follows the 
//     packet context struct if included
//
// SubmittedToScheduler - some packets bypass the scheduler. These should not 
//     be submitted to the scheduler's completion routine.
//

typedef struct _PS_SEND_PACKET_CONTEXT
{
    PACKET_INFO_BLOCK Info;
    PNDIS_PACKET      OriginalPacket;
    SINGLE_LIST_ENTRY FreeList;
    PGPC_CLIENT_VC    Vc;
} PS_SEND_PACKET_CONTEXT, *PPS_SEND_PACKET_CONTEXT;

typedef struct _PS_RECV_PACKET_CONTEXT
{
    PNDIS_PACKET OriginalPacket;
} PS_RECV_PACKET_CONTEXT, *PPS_RECV_PACKET_CONTEXT;

// 
//  Ndis requires a minimum of 8 bytes for the MediaSpecific parameters.
//  We'll create a dummy media specific parmeter block:
//

typedef struct _PS_MEDIA_PARAMETERS{

    CO_MEDIA_PARAMETERS StdMediaParameters;
    UCHAR LinkId[6]; // Used by NdisWan
    NDIS_STRING InstanceName; 

} PS_MEDIA_PARAMETERS, *PPS_MEDIA_PARAMETERS;


typedef struct _RUNNING_AVERAGE {
    ULONG *Elements;
    ULONG Index;
    ULONG Sum;
    ULONG Size;    
} RUNNING_AVERAGE, *PRUNNING_AVERAGE;

#if CBQ
//
// Context used by AddCfInfo for "ClassMap" to be sent back 
// to the GPC. 
//
typedef struct _CLASS_MAP_CONTEXT_BLK {
    PADAPTER Adapter;
    PPS_CLASS_MAP_CONTEXT ComponentContext;
    PPS_WAN_LINK WanLink;
} CLASS_MAP_CONTEXT_BLK, *PCLASS_MAP_CONTEXT_BLK;
#endif

typedef struct _PS_INTERFACE_INDEX {
    PADAPTER     Adapter;
    PPS_WAN_LINK WanLink;
} PS_INTERFACE_INDEX_CONTEXT, *PPS_INTERFACE_INDEX_CONTEXT;

//
// define for determing if media is LAN oriented
//

#define NDIS_MEDIA_LAN( _adpt ) (( _adpt )->MediaType == NdisMedium802_3 || \
                                 ( _adpt )->MediaType == NdisMedium802_5 || \
                                 ( _adpt )->MediaType == NdisMediumFddi || \
                                 ( _adpt )->MediaType == NdisMediumDix)



//
// global vars (not based on a device instance)
//

extern ULONG                  InitShutdownMask;
extern ULONG                  AdapterCount;
extern ULONG                  DriverRefCount;
extern BOOLEAN                WMIInitialized;
extern DRIVER_STATE           gDriverState;
extern LIST_ENTRY             AdapterList;
extern LIST_ENTRY             PsComponentList;
extern LIST_ENTRY             PsProfileList;
extern NDIS_HANDLE            ClientProtocolHandle;
extern NDIS_HANDLE            CallMgrProtocolHandle;
extern NDIS_HANDLE            MpWrapperHandle;
extern NDIS_HANDLE            LmDriverHandle;
extern NDIS_HANDLE            PsDeviceHandle;
extern PDRIVER_OBJECT         PsDriverObject;
extern PDEVICE_OBJECT         PsDeviceObject;
extern HANDLE                 PsDeviceHandle;
extern NPAGED_LOOKASIDE_LIST  NdisRequestLL;
extern NPAGED_LOOKASIDE_LIST  AdapterVcLL;
extern NPAGED_LOOKASIDE_LIST  ClientVcLL;
extern NPAGED_LOOKASIDE_LIST  GpcClientVcLL;
extern NDIS_EVENT             DriverUnloadEvent;

extern NDIS_STRING            PsDriverName;
extern NDIS_STRING            PsSymbolicName;
extern NDIS_STRING            PsMpName;
extern NDIS_STRING            WanPrefix;
extern NDIS_STRING            VcPrefix;
extern NDIS_STRING            MachineRegistryKey;

extern PSI_INFO               TbConformerInfo;
extern PSI_INFO               ShaperInfo;
extern PSI_INFO               DrrSequencerInfo;
extern PSI_INFO               SchedulerStubInfo;
extern PSI_INFO               TimeStmpInfo;

extern PS_PROFILE             DefaultSchedulerConfig;

extern PS_PROCS               PsProcs;

extern ULONG                  gEnableAvgStats;
extern ULONG                  gEnableWindowAdjustment;
extern NDIS_STRING            gsEnableWindowAdjustment;

// Global locks

extern PS_SPIN_LOCK AdapterListLock;
extern PS_SPIN_LOCK PsComponentListLock;
extern PS_SPIN_LOCK PsProfileLock;
extern PS_SPIN_LOCK DriverUnloadLock;
    
// Timer

extern ULONG gTimerResolutionActualTime;
extern ULONG gTimerSet;

//
// ZAW
//
extern NDIS_EVENT gZAWEvent;
extern ULONG      gZAWState;
#define ZAW_STATE_READY  0
#define ZAW_STATE_IN_USE 1

// GPC Interface

#define PS_QOS_CF       0x00000001
#define PS_CLASS_MAP_CF 0x00000002
#define GPC_NO_MATCH (ULONG)-1

extern GPC_EXPORTED_CALLS GpcEntries;
extern GPC_HANDLE GpcQosClientHandle;
#if CBQ
extern GPC_HANDLE GpcClassMapClientHandle;
#endif
extern PS_DEVICE_STATE DeviceState;

extern PDRIVER_DISPATCH DispatchTable[IRP_MJ_MAXIMUM_FUNCTION];

//
// NULL Component hacks for now [ShreeM]
//
extern PS_RECEIVE_PACKET       TimeStmpRecvPacket;
extern PS_RECEIVE_INDICATION   TimeStmpRecvIndication;

extern BOOLEAN  TimeStmpReceivePacket();

//
//  This is the RawLinkSpeed below which we trigger DRR
//
#define MAX_LINK_SPEED_FOR_DRR      7075 //( 56.6 * 1000 / 8)  // 56.6 kbps converted to bytes/sec


#endif/* _GLOBALS_ */

/* end globals.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\globals.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    globals.c

Abstract:

    global declarations

Author:

    Charlie Wickham (charlwi)  22-Apr-1996
    Rajesh Sundaram (rajeshsu) 01-Aug-1998.

Environment:

    Kernel Mode

Revision History:

--*/

#include "psched.h"

#pragma hdrstop

#include <ntverp.h>

/* External */

/* Static */

/* Forward */
/* End Forward */

ULONG InitShutdownMask;
ULONG AdapterCount;
ULONG DriverRefCount;
DRIVER_STATE gDriverState;

ULONG gEnableAvgStats = 0;
ULONG gEnableWindowAdjustment = 0;
NDIS_STRING gsEnableWindowAdjustment = NDIS_STRING_CONST("PSCHED");


//
// Lists 
//
LIST_ENTRY AdapterList;                  // List of adapters
LIST_ENTRY PsComponentList;              // List of scheduling components.
LIST_ENTRY PsProfileList;                // List of scheduling profiles.


//
// Locks
//
PS_SPIN_LOCK AdapterListLock;          // Protects AdapterList
PS_SPIN_LOCK PsComponentListLock;      // For PsCompoenentList
PS_SPIN_LOCK PsProfileLock;            // For PsProfileList
PS_SPIN_LOCK DriverUnloadLock;         // to handle unloads, unbinds, etc.

//
//  Mutex Implementation
//
ULONG   CreateDeviceMutex = 0;



//
// Handles
//

NDIS_HANDLE ClientProtocolHandle;     // handle returned by NDIS when registering the Client
NDIS_HANDLE MpWrapperHandle;          // Ndis wrapper handle for MP section
NDIS_HANDLE LmDriverHandle;           // handle returned by NDIS when MP portion registers as LM
NDIS_HANDLE PsDeviceHandle; 


//
// PSDriverObject, PSDeviceObject - pointer to NT driver and device objects
//

PDRIVER_OBJECT PsDriverObject;
PDEVICE_OBJECT PsDeviceObject;

//
// Lookaside Lists
//
NPAGED_LOOKASIDE_LIST NdisRequestLL;  // For Ndis requests
NPAGED_LOOKASIDE_LIST GpcClientVcLL;  // For GPC Client VCs.

//
// Events
//
NDIS_EVENT             DriverUnloadEvent;
NDIS_EVENT             gZAWEvent;
ULONG                  gZAWState = ZAW_STATE_READY;

//
// name constants used during registration/initialization
//
NDIS_STRING PsSymbolicName         = NDIS_STRING_CONST("\\DosDevices\\PSched");
NDIS_STRING PsDriverName           = NDIS_STRING_CONST("\\Device\\PSched");
NDIS_STRING VcPrefix               = NDIS_STRING_CONST( "VC:");
NDIS_STRING WanPrefix              = NDIS_STRING_CONST( "WAN:");
NDIS_STRING MachineRegistryKey     = NDIS_STRING_CONST( "\\Registry\\Machine\\SOFTWARE\\Policies\\Microsoft\\Windows\\PSched");
NDIS_STRING PsMpName;

//
// Default scheduling component info
//

PSI_INFO TbConformerInfo = {
    {0, 0}, TRUE, FALSE,
    PS_COMPONENT_CURRENT_VERSION,
    NDIS_STRING_CONST( "TokenBucketConformer" ),
    0, 0, 0, 0,
    0, NULL, 0, NULL,
    0,0,0,0,0,0,0,0,0,0
};
PSI_INFO ShaperInfo = {
    {0, 0}, TRUE, FALSE,
    PS_COMPONENT_CURRENT_VERSION,
    NDIS_STRING_CONST( "TrafficShaper" ),
    0, 0, 0, 0,
    0, NULL, 0, NULL,
    0,0,0,0,0,0,0,0,0,0
};
PSI_INFO DrrSequencerInfo = {
    {0, 0}, TRUE, FALSE,
    PS_COMPONENT_CURRENT_VERSION,
    NDIS_STRING_CONST( "DRRSequencer" ),
    0, 0, 0, 0,
    0, NULL, 0, NULL,
    0,0,0,0,0,0,0,0,0,0
};
PSI_INFO TimeStmpInfo = {
    {0, 0}, TRUE, FALSE,
    PS_COMPONENT_CURRENT_VERSION,
    NDIS_STRING_CONST( "TimeStmp" ),
    0, 0, 0, 0,
    0, NULL, 0, NULL,
    0,0,0,0,0,0,0,0,0,0
};
PSI_INFO SchedulerStubInfo = {
    {0, 0}, TRUE, FALSE,
    PS_COMPONENT_CURRENT_VERSION,
    NDIS_STRING_CONST( "SchedulerStub" ),
    0, 0, 0, 0,
    0, NULL, 0, NULL,
    0,0,0,0,0,0,0,0,0,0
};

//
// Known component configurations
//
PS_PROFILE DefaultSchedulerConfig = {
    {0, 0},
    0,
    NDIS_STRING_CONST( "DefaultSchedulerConfig" ),
    4,
    {&TbConformerInfo,
     &DrrSequencerInfo,
     &TimeStmpInfo,
     &SchedulerStubInfo
    }
};

//
// PS Procs for scheduler
//

PS_PROCS PsProcs;



// 
// For the logging support
//

PVOID                  SchedTraceThreshContext;
NDIS_SPIN_LOCK         GlobalLoggingLock;
ULONG                  SchedTraceIndex = 0;
ULONG                  SchedBufferSize = 0;
ULONG                  SchedTraced = 0;
UCHAR                  *SchedTraceBuffer = 0;
ULONG                  SchedTraceBytesUnread = 0;
ULONG                  SchedTraceThreshold = 0xffffffff;
SCHEDTRACE_THRESH_PROC SchedTraceThreshProc = NULL;
BOOLEAN                TraceBufferAllocated = FALSE;
BOOLEAN                WMIInitialized = FALSE;


// Timer

ULONG  gTimerResolutionActualTime  = 0;
ULONG  gTimerSet                   = 0;


// GPC VC state machine

#if DBG
PUCHAR GpcVcState[] = {
    "ERROR_STATE",
    "CL_VC_INITIALIZED",
    "CL_CALL_PENDING",
    "CL_INTERNAL_CALL_COMPLETE",
    "CL_CALL_COMPLETE",
    "CL_MODIFY_PENDING",
    "CL_GPC_CLOSE_PENDING",
    "CL_NDIS_CLOSE_PENDING",
    "CL_WAITING_FOR_PENDING_PACKETS"
};
#endif


//
// GPC Interface
//

GPC_EXPORTED_CALLS GpcEntries;
GPC_HANDLE         GpcQosClientHandle;
#if CBQ
GPC_HANDLE         GpcClassMapClientHandle;
#endif
PS_DEVICE_STATE    DeviceState = PS_DEVICE_STATE_READY;

//
// TAGS
//

ULONG NdisRequestTag =           '0CSP';
ULONG GpcClientVcTag =           '1CSP';
ULONG WanLinkTag =               '2CSP';
ULONG PsMiscTag =                '3CSP';
ULONG WanTableTag =              '4CSP';
ULONG WMITag =                   'hCSP';

ULONG AdapterTag =               'aCSP';
ULONG CmParamsTag =              'bCSP';
ULONG PipeContextTag =           'cCSP';
ULONG FlowContextTag =           'dCSP';
ULONG ClassMapContextTag =       'eCSP';
ULONG ProfileTag =               'fCSP';
ULONG ComponentTag =             'gCSP';

ULONG TimerTag  =                'zCSP';
ULONG TsTag =                    'tCSP';

#if DBG

CHAR VersionNumber[] = "0.300";
CHAR VersionHerald[] = "PSched: Packet Scheduler Version %s built on %s\n";
CHAR VersionTimestamp[] = __DATE__ " " __TIME__;

ULONG DbgTraceLevel;
ULONG DbgTraceMask;
ULONG LogTraceLevel;
ULONG LogTraceMask;
ULONG LogId = LAST_LOG_ID;

#endif


//
// NULL Component hacks for now [ShreeM]
//
PS_RECEIVE_PACKET       TimeStmpRecvPacket      = NULL;
PS_RECEIVE_INDICATION   TimeStmpRecvIndication  = NULL;

PULONG_PTR g_WanLinkTable;
USHORT     g_NextWanIndex;
USHORT     g_WanTableSize;

/* end globals.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\gpccm.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    GpcCM.c

Abstract:

    Handlers called by GPC for the ClassMap address family.  

Author:

    Rajesh Sundaram (rajeshsu)   1st Aug, 1998.

Environment:

    Kernel Mode

Revision History:

--*/

#include "psched.h"
#pragma hdrstop

#if CBQ


/*++

Routine Description:

    A new CF_INFO has been added to the GPC database.

Arguments:

    ClientContext -         Client context supplied to GpcRegisterClient
    GpcCfInfoHandle -       GPC's handle to CF_INFO
    CfInfoPtr -             Pointer to the CF_INFO structure
    ClientCfInfoContext -   Location in which to return PS's context for 
                            CF_INFO
Return Value:

    Status

--*/

GPC_STATUS
ClassMapAddCfInfoNotify(
	IN	GPC_CLIENT_HANDLE       ClientContext,
	IN	GPC_HANDLE              GpcCfInfoHandle,
    IN  ULONG                   CfInfoSize,
    IN  PVOID                   CfInfoPtr,
	IN	PGPC_CLIENT_HANDLE      ClientCfInfoContext
	)
{
#if 0
    PCF_INFO_CLASS_MAP     CfInfo; 
    PADAPTER               Adapter;
    PGPC_CLIENT_VC         Vc;
    NDIS_STATUS            Status;
    PPS_WAN_LINK           WanLink = 0;
    PCLASS_MAP_CONTEXT_BLK pClBlk;
    PPS_CLASS_MAP_CONTEXT  ClassMapContext, PrevContext;
    PPSI_INFO              PsComponent, aPsComponent;
    PPS_PIPE_CONTEXT       PipeContext, aPipeContext;

    CfInfo = (PCF_INFO_CLASS_MAP)CfInfoPtr;

    //
    // Verify that the TcObjectsLength is consistent with the
    // CfInfoSize. The CfInfoSize must have been verified during
    // the user/kernel transition. The TcObjectsLength has not.
    // We could bugcheck if we try to search beyond the buffer 
    // passed in.
    //
    if(CfInfoSize < (FIELD_OFFSET(CF_INFO_CLASS_MAP, ClassMapInfo) +
                     FIELD_OFFSET(TC_CLASS_MAP_FLOW, Objects) +
                     CfInfo->ClassMapInfo.ObjectsLength)){

        return(ERROR_TC_OBJECT_LENGTH_INVALID);
    }

    Adapter = FindAdapterByWmiInstanceName((USHORT) CfInfo->InstanceNameLength,
                                           (PWSTR) &CfInfo->InstanceName[0],
                                           &WanLink, 
                                           TRUE);

    if(!Adapter) {
        
        return GPC_STATUS_IGNORED;
    }

    PS_LOCK(&Adapter->Lock);
    
    if(Adapter->PsMpState != AdapterStateRunning) {

        PS_UNLOCK(&Adapter->Lock);
        return NDIS_STATUS_FAILURE;
    }

    PS_UNLOCK(&Adapter->Lock);

    //
    // Create a context which will be passed back to the GPC. We should be using Lookaside Lists if 
    // we port CBQ and if this becomes a frequent operation. This will probably not be as frequent
    // as creating VCs so we should be fine.
    //

    PsAllocatePool(pClBlk,
                   sizeof(CLASS_MAP_CONTEXT_BLK),
                   PsMiscTag);

    if(!pClBlk)
    {
        return NDIS_STATUS_RESOURCES;
    }

    pClBlk->Adapter = Adapter;
    *ClientCfInfoContext = pClBlk;

    if(WanLink)
    {
        PsAssert(Adapter->MediaType == NdisMediumWan);

        PipeContext = aPipeContext   = WanLink->PsPipeContext;
        PsComponent = aPsComponent   = WanLink->PsComponent;

        pClBlk->WanLink = WanLink;

    }
    else 
    {
        PipeContext = aPipeContext    = Adapter->PsPipeContext;
        PsComponent = aPsComponent    = Adapter->PsComponent;
        pClBlk->WanLink = 0;

    }

    //
    // Allocate space for the component's context (class map context)
    // The length of the class map  context buffer for this pipe was 
    // calculated  when the pipe was initialized.
    //
    PsAllocatePool(pClBlk->ComponentContext,
                   Adapter->ClassMapContextLength, 
                   ClassMapContextTag );

    if ( pClBlk->ComponentContext == NULL ) {
       ClientCfInfoContext = 0;
        PsFreePool(pClBlk);
        return NDIS_STATUS_RESOURCES;
    }

    //
    // Set up the context buffer
    //
    ClassMapContext = (PPS_CLASS_MAP_CONTEXT)pClBlk->ComponentContext;
    PrevContext = NULL;

    while (PsComponent != NULL) {

        ClassMapContext->NextComponentContext = (PPS_CLASS_MAP_CONTEXT)
            ((UINT_PTR)ClassMapContext + PsComponent->ClassMapContextLength);
        ClassMapContext->PrevComponentContext = PrevContext;

        PsComponent = PipeContext->NextComponent;
        PipeContext = PipeContext->NextComponentContext;

        PrevContext = ClassMapContext;
        ClassMapContext = ClassMapContext->NextComponentContext;
    }


    Status = (*aPsComponent->CreateClassMap)
        (aPipeContext,
         ClientContext,
         &CfInfo->ClassMapInfo,
         pClBlk->ComponentContext); 

    if(Status == NDIS_STATUS_SUCCESS)
    {
        if(Adapter->MediaType == NdisMediumWan) 
        {
            //
            // To optimize send path
            //
            InterlockedIncrement(&WanLink->CfInfosInstalled);
        }
        else 
        {
            //
            // To optimize send path
            //
            InterlockedIncrement(&Adapter->CfInfosInstalled);
        }
    }

    return Status;
#endif
    return GPC_STATUS_FAILURE;
}

GPC_STATUS
ClassMapModifyCfInfoNotify(
	IN	GPC_CLIENT_HANDLE       ClientContext,
	IN	GPC_CLIENT_HANDLE       ClientCfInfoContext,
    IN  ULONG                   CfInfoSize,
	IN	PVOID                   NewCfInfoPtr
	)
{
    return GPC_STATUS_FAILURE;
}

GPC_STATUS
ClassMapRemoveCfInfoNotify(
    IN	GPC_CLIENT_HANDLE       ClientContext,
	IN	GPC_CLIENT_HANDLE       ClientCfInfoContext
	)
{
#if 0
    PADAPTER               Adapter;
    NDIS_STATUS            Status;
    PCLASS_MAP_CONTEXT_BLK pCmBlk = ClientCfInfoContext;

    Adapter = pCmBlk->Adapter;

    if(Adapter->MediaType == NdisMediumWan) 
    {
        //
        // To optimize send path
        //
        InterlockedDecrement(&WanLink->CfInfosInstalled);

        Status = (*pCmBlk->WanLink->PsComponent->DeleteClassMap)
            (pCmBlk->WanLink->PsPipeContext,
             pCmBlk->ComponentContext);
    }
    else 
    {
        //
        // To Optimize send path
        //
        InterlockedDecrement(&Adapter->CfInfosInstalled);

        Status = (*Adapter->PsComponent->DeleteClassMap)
            (Adapter->PsPipeContext,
             pCmBlk->ComponentContext);
    }
   
    PsFreePool(pCmBlk->ComponentContext);
    PsFreePool(pCmBlk);


    return Status;
#endif
    return GPC_STATUS_FAILURE;
}

VOID
ClassMapAddCfInfoComplete(
	IN	GPC_CLIENT_HANDLE       ClientContext,
	IN	GPC_CLIENT_HANDLE       ClientCfInfoContext,
	IN	GPC_STATUS              Status
	)
{
    //
    // The PS never adds CF_INFO's so this routine should never be called
    //
    DEBUGCHK;
}

VOID
ClassMapModifyCfInfoComplete(
	IN	GPC_CLIENT_HANDLE       ClientContext,
	IN	GPC_CLIENT_HANDLE       ClientCfInfoContext,
	IN	GPC_STATUS              Status
	)
{
}

VOID
ClassMapRemoveCfInfoComplete(
	IN	GPC_CLIENT_HANDLE       ClientContext,
	IN	GPC_CLIENT_HANDLE       ClientCfInfoContext,
	IN	GPC_STATUS              Status
	)
{
}

GPC_STATUS
ClassMapClGetCfInfoName(
    IN  GPC_CLIENT_HANDLE       ClientContext,
    IN  GPC_CLIENT_HANDLE       ClientCfInfoContext,
    OUT PNDIS_STRING            InstanceName
    )
{
    InstanceName->Length = 0;
    return(NDIS_STATUS_SUCCESS);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\gpchndlr.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    GpcHndlr.c

Abstract:

    Handlers called by GPC.  

Author:

    Rajesh Sundaram (rajeshsu) 

Environment:

    Kernel Mode

Revision History:

    One of the initial designs (yoramb/charliew/rajeshsu) consisted of an
    integrated call manager with a seperate packet classifying client. The 
    design used NDIS 5.0 VCs so that they could be managed by WMI.

    The main limitation of the above approach was the fact that NDIS provided 
    mechanisms to manage miniport and VCs - We really needed a way to 
    manage other things (like WanLinks, etc).

--*/

#include "psched.h"
#pragma hdrstop

/* External */

/* Static */


GPC_STATUS
QosAddCfInfoNotify(
        IN      GPC_CLIENT_HANDLE       ClientContext,
        IN      GPC_HANDLE              GpcCfInfoHandle,
        IN      ULONG                   CfInfoSize,
        IN      PVOID                   CfInfoPtr,
        IN      PGPC_CLIENT_HANDLE      ClientCfInfoContext
        )

/*++

Routine Description:

    A new CF_INFO has been added to the GPC database.

Arguments:

    ClientContext       -   Client context supplied to GpcRegisterClient
    GpcCfInfoHandle     -   GPC's handle to CF_INFO
    CfInfoPtr           -   Pointer to the CF_INFO structure
    ClientCfInfoContext -   Location in which to return PS's context for CF_INFO

Return Value:

    Status

--*/

{
    PADAPTER                    Adapter;
    PGPC_CLIENT_VC              Vc;
    PCF_INFO_QOS                CfInfo;
    NDIS_STATUS                 Status;
    ULONG                       CallParamsLength;
    PCO_CALL_PARAMETERS         CallParams = 0;
    PCO_CALL_MANAGER_PARAMETERS CallMgrParams;
    PCO_MEDIA_PARAMETERS        PsMediaParameters;
    LPQOS_PRIORITY              PriorityObject;
    PPS_WAN_LINK                WanLink = 0;
    ULONG                       TcObjAlignedLength;

    CfInfo = (PCF_INFO_QOS)CfInfoPtr;

    //
    // Verify that the TcObjectsLength is consistent with the CfInfoSize. The
    // CfInfoSize must have been verified during the user/kernel transition. 
    // The TcObjectsLength has not. We could bugcheck if we try to search
    // beyond the buffer passed in.
    //

    if(CfInfoSize < (FIELD_OFFSET(CF_INFO_QOS, GenFlow) +
                     FIELD_OFFSET(TC_GEN_FLOW, TcObjects) +
                     CfInfo->GenFlow.TcObjectsLength))        
    {

        PsDbgOut(DBG_FAILURE, DBG_GPC_QOS,
                 ("[QosAddCfInfoNotify]: TcObjectsLength inconsistent with "
                 "CfInfoSize \n"));

        return(QOS_STATUS_TC_OBJECT_LENGTH_INVALID);
    }

    //
    // Using the instance name, we find the adapter or the wanlink. If the adapter or wanlink is not
    // ready to accept VCs, this function will return NULL. Also, if it is ready, it will take a ref 
    // on the Adapter and the WanLink.
    //

    Adapter = FindAdapterByWmiInstanceName((USHORT) CfInfo->InstanceNameLength,
                                           (PWSTR) &CfInfo->InstanceName[0],
                                           &WanLink);
    if(NULL == Adapter) 
    {
        PsAssert(WanLink == NULL);

        PsDbgOut(DBG_FAILURE, DBG_GPC_QOS,
               ("[QosAddCfInfoNotify]: no adapter with instance name %ws\n", 
                CfInfo->InstanceName));

        return GPC_STATUS_IGNORED;
    }

    //
    // We have taken a ref on the adapter or wanlink. so we need to deref if we bail out with error. If 
    // we create the VC, then the adapter and wanlink are deref'd when the VC is deleted.
    //

    do
    {

       //
       // Allocate the resources for the call manager parameters.
       //
       TcObjAlignedLength = ((CfInfo->GenFlow.TcObjectsLength + (sizeof(PVOID)-1)) & ~(sizeof(PVOID)-1));
       
       CallParamsLength = 
          sizeof(CO_CALL_PARAMETERS) +
          FIELD_OFFSET(CO_CALL_MANAGER_PARAMETERS, CallMgrSpecific) +
          FIELD_OFFSET(CO_SPECIFIC_PARAMETERS, Parameters) +
          TcObjAlignedLength +
          FIELD_OFFSET(CO_MEDIA_PARAMETERS, MediaSpecific) +
          FIELD_OFFSET(CO_SPECIFIC_PARAMETERS, Parameters);

       if(Adapter->MediaType == NdisMediumWan) 
       {
          CallParamsLength += sizeof(QOS_WAN_MEDIA);
       }
       else 
       {
          if(!Adapter->PipeHasResources)
          {
             //
             // We don't want to pend GPC client VCs. The reasons are:
             //
             // a. If the cable is never plugged in, we could pend VCs indefinitely.
             //    Waste of system resources.
             //
             // b. There is no clean way for the app to cancel these pended VCs. Since
             //    we have pended the AddCfInfo to the GPC, the GPC cannot call back
             //    and ask us to delete the VC.
             //
             // But, we still need to handle the case where link speed change 
             // might be transient (10/100 case). Also, if we return error, the app
             // might retry causing busy cycles if the media is never connected. 
             // For all this, the app can register for WMI notifications for GUIDs
             // GUID_NDIS_STATUS_MEDIA_(DIS)CONNECT
             //
             //
             // Also, we probably don't want to do this for the b/e VC. Otherwise,
             // how does it work when the user installs psched and the media is 
             // unconnected ? Do we want him to reinstall psched after connecting 
             // the media ? 
             //
             
             PsDbgOut(DBG_FAILURE, DBG_GPC_QOS,
                      ("[QosAddCfInfoNotify]: Adapter %08X is not plugged in \n", Adapter));
             
             Status = NDIS_STATUS_NETWORK_UNREACHABLE;
   
             break;
          }
       }

       PsAllocatePool(CallParams, CallParamsLength, CmParamsTag);

       if(CallParams == NULL) {
          
          PsDbgOut(DBG_FAILURE, DBG_GPC_QOS,
                   ("[QosAddCfInfoNotify]: Adapter %08X, can't allocate call"
                    "params \n", Adapter));
          
          Status =  GPC_STATUS_RESOURCES;

          break;
       }

       Status = CmCreateVc(&Vc, Adapter, WanLink, CallParams, GpcCfInfoHandle, CfInfo, 
                           ClientContext);
    
       if(!NT_SUCCESS(Status)) {
          PsDbgOut(DBG_FAILURE, DBG_GPC_QOS, 
                   ("[QosAddCfInfoNotify]: Adapter %08X, Could not create Vc \n",
                    Adapter));
       
          break;
       }
    
       *ClientCfInfoContext = Vc;

    } while(FALSE);
    

    if(!NT_SUCCESS(Status))
    {
       if(CallParams)
       {
          PsFreePool(CallParams);
       }

       if(WanLink)
       {
          REFDEL(&WanLink->RefCount, FALSE, 'WANV');
       }

       REFDEL(&Adapter->RefCount, FALSE, 'ADVC');

       return Status;

    }

    //
    // Create a call parameters struct for the MakeCall
    //

    CallMgrParams = (PCO_CALL_MANAGER_PARAMETERS)(CallParams + 1);
    CallMgrParams->Transmit = CfInfo->GenFlow.SendingFlowspec;
    CallMgrParams->Receive = CfInfo->GenFlow.ReceivingFlowspec;
    CallMgrParams->CallMgrSpecific.ParamType = PARAM_TYPE_GQOS_INFO;
    CallMgrParams->CallMgrSpecific.Length = CfInfo->GenFlow.TcObjectsLength;

    if(CfInfo->GenFlow.TcObjectsLength > 0){

        NdisMoveMemory(
            &CallMgrParams->CallMgrSpecific.Parameters,
            &CfInfo->GenFlow.TcObjects,
            CfInfo->GenFlow.TcObjectsLength);
    }

    PsMediaParameters = 
            (PCO_MEDIA_PARAMETERS)((PUCHAR)CallMgrParams + 
                FIELD_OFFSET(CO_CALL_MANAGER_PARAMETERS, CallMgrSpecific) +
                FIELD_OFFSET(CO_SPECIFIC_PARAMETERS, Parameters) +
                TcObjAlignedLength);

    PsMediaParameters->Flags = 0;
    PsMediaParameters->ReceivePriority = 0;
    PsMediaParameters->ReceiveSizeHint = CfInfo->GenFlow.SendingFlowspec.MaxSduSize;
    PsMediaParameters->MediaSpecific.ParamType = PARAM_TYPE_GQOS_INFO;
    PsMediaParameters->MediaSpecific.Length = 0;

    //
    // If this flow is being installed on a Wan interface, need to
    // insert the linkId into the media specific fields. This is so that
    // NdisWan will be able to recognize the link over which to install
    // the flow.
    //

    if(WanLink){

        LPQOS_WAN_MEDIA WanMedia;
        PsMediaParameters->MediaSpecific.Length += sizeof(QOS_WAN_MEDIA);
        WanMedia = (LPQOS_WAN_MEDIA) PsMediaParameters->MediaSpecific.Parameters;

        WanMedia->ObjectHdr.ObjectType   = QOS_OBJECT_WAN_MEDIA;
        WanMedia->ObjectHdr.ObjectLength = sizeof(QOS_WAN_MEDIA);

        NdisMoveMemory(&WanMedia->LinkId,
                       WanLink->OriginalRemoteMacAddress,
                       6);
    }

    CallParams->Flags = 0;
    CallParams->CallMgrParameters = CallMgrParams;
    CallParams->MediaParameters = (PCO_MEDIA_PARAMETERS)PsMediaParameters;

    Status = CmMakeCall(Vc);

    if(NDIS_STATUS_PENDING != Status) 
    {
        CmMakeCallComplete(Status, Vc, Vc->CallParameters);
    }

    PsDbgOut(DBG_TRACE,
             DBG_GPC_QOS,
             ("[QosAddCfInfoNotify]: Adapter %08X, Created Vc %08X - returned "
              " PENDING \n", Adapter, Vc));

#if DBG
    NdisInterlockedIncrement(&Adapter->GpcNotifyPending);
#endif

    return GPC_STATUS_PENDING;
}

VOID
SetTOSIEEEValues(PGPC_CLIENT_VC Vc)
{
    ULONG                ServiceType = Vc->CallParameters->CallMgrParameters->Transmit.ServiceType;
    LPQOS_OBJECT_HDR     QoSObject;
    LONG                 ParamsLength;
    LPQOS_TRAFFIC_CLASS  Tc;
    LPQOS_DS_CLASS       Ds;
    PCF_INFO_QOS         CfInfo = (PCF_INFO_QOS) Vc->CfInfoQoS;

    //
    // Set these based on the ServiceType
    //
    switch(ServiceType)
    {
      case SERVICETYPE_CONTROLLEDLOAD:
          Vc->UserPriorityConforming    = Vc->Adapter->UserServiceTypeControlledLoad;
          CfInfo->ToSValue              = Vc->Adapter->IPServiceTypeControlledLoad;
          Vc->IPPrecedenceNonConforming = Vc->Adapter->IPServiceTypeControlledLoadNC;
          break;
      case SERVICETYPE_GUARANTEED:
          Vc->UserPriorityConforming    = Vc->Adapter->UserServiceTypeGuaranteed;
          Vc->IPPrecedenceNonConforming = Vc->Adapter->IPServiceTypeGuaranteedNC;
          CfInfo->ToSValue              = Vc->Adapter->IPServiceTypeGuaranteed;
          break;
      case SERVICETYPE_BESTEFFORT:
          Vc->UserPriorityConforming    = Vc->Adapter->UserServiceTypeBestEffort;
          CfInfo->ToSValue              = Vc->Adapter->IPServiceTypeBestEffort;
          Vc->IPPrecedenceNonConforming = Vc->Adapter->IPServiceTypeBestEffortNC;
          break;
      case SERVICETYPE_QUALITATIVE:
          Vc->UserPriorityConforming    = Vc->Adapter->UserServiceTypeQualitative;
          CfInfo->ToSValue              = Vc->Adapter->IPServiceTypeQualitative;
          Vc->IPPrecedenceNonConforming = Vc->Adapter->IPServiceTypeQualitativeNC;
          break;
      case SERVICETYPE_NETWORK_CONTROL:
          Vc->UserPriorityConforming    = Vc->Adapter->UserServiceTypeNetworkControl;
          CfInfo->ToSValue              = Vc->Adapter->IPServiceTypeNetworkControl;
          Vc->IPPrecedenceNonConforming = Vc->Adapter->IPServiceTypeNetworkControlNC;
          break;
    }
    Vc->UserPriorityNonConforming = Vc->Adapter->UserServiceTypeNonConforming;

    //
    // Walk the QoS objects to see if there is a TCLASS or a DCLASS
    //
    ParamsLength = (LONG)Vc->CallParameters->CallMgrParameters->CallMgrSpecific.Length;
    QoSObject    = (LPQOS_OBJECT_HDR)Vc->CallParameters->CallMgrParameters->CallMgrSpecific.Parameters;

    while(ParamsLength > 0) {

        switch(QoSObject->ObjectType)
        {
             case QOS_OBJECT_TCP_TRAFFIC:

                //
                // This QoS object asks us to override the ServiceType, the TCLASS and the DCLASS markings.
                // so, if we fidn this QoS object, we set the values, and return.
                //

                Vc->UserPriorityConforming    = (UCHAR) Vc->Adapter->UserServiceTypeTcpTraffic;
                CfInfo->ToSValue              = (UCHAR) Vc->Adapter->IPServiceTypeTcpTraffic;
                Vc->IPPrecedenceNonConforming = (UCHAR) Vc->Adapter->IPServiceTypeTcpTrafficNC;
                return;

             case QOS_OBJECT_TRAFFIC_CLASS:
        
                Tc = (LPQOS_TRAFFIC_CLASS)QoSObject;
                Vc->UserPriorityConforming = (UCHAR) Tc->TrafficClass;
                break;

             case QOS_OBJECT_DS_CLASS:
                Ds = (LPQOS_DS_CLASS)QoSObject;
                CfInfo->ToSValue = Ds->DSField << 2;
                break;
        }

        ParamsLength -= QoSObject->ObjectLength;

        QoSObject = (LPQOS_OBJECT_HDR)((UINT_PTR)QoSObject +
                                   QoSObject->ObjectLength);
    }

    return;

}

VOID
CmMakeCallComplete(NDIS_STATUS Status, PGPC_CLIENT_VC Vc,
                   PCO_CALL_PARAMETERS CallParameters)
{
    PADAPTER     Adapter = Vc->Adapter;
    GPC_HANDLE   CfInfo  = Vc->CfInfoHandle;
    PPS_WAN_LINK WanLink = Vc->WanLink;
    ULONG        CurrentFlows;
    LARGE_INTEGER Increment;
    LARGE_INTEGER VcIndex;

    PsAssert(!IsBestEffortVc(Vc));
    
    Increment.QuadPart = 1;

    if(NT_SUCCESS(Status)) 
    {

        // 
        // Create an Instance name for this VC and register with WMI. 
        //
        VcIndex = ExInterlockedAddLargeInteger(&Adapter->VcIndex, Increment, &Adapter->Lock.Lock.SpinLock);

        Status = GenerateInstanceName(&VcPrefix, Vc->Adapter, &VcIndex, &Vc->InstanceName);

        //
        // Transistion from CL_CALL_PENDING to CL_INTERNAL_CALL_COMPLETE
        //

        CallSucceededStateTransition(Vc);


        PS_LOCK(&Vc->Lock);

        SetTOSIEEEValues(Vc);

        PS_UNLOCK(&Vc->Lock);

        if(Adapter->MediaType == NdisMediumWan) {


            //
            // This variable is used to optimize the send path
            //
            InterlockedIncrement(&WanLink->CfInfosInstalled);

            if((Vc->Flags & GPC_ISSLOW_FLOW)) { 

                //
                // Tell NDISWAN about the fragment size
                //
                MakeLocalNdisRequest(Adapter, 
                                     Vc->NdisWanVcHandle,
                                     NdisRequestLocalSetInfo,
                                     OID_QOS_ISSLOW_FRAGMENT_SIZE, 
                                     &Vc->ISSLOWFragmentSize, 
                                     sizeof(ULONG), 
                                     NULL);
            }

            //
            // This is used for OID_QOS_FLOW_COUNT - Better be thread safe
            //

            PS_LOCK(&WanLink->Lock);

            WanLink->FlowsInstalled ++;

            CurrentFlows = WanLink->FlowsInstalled;
            
            PS_UNLOCK(&WanLink->Lock);

            PsTcNotify(Adapter, WanLink, OID_QOS_FLOW_COUNT, &CurrentFlows, sizeof(ULONG));
        }
        else {

            //
            // This variable is used to optimize the send path
            //
            InterlockedIncrement(&Adapter->CfInfosInstalled);

           PS_LOCK(&Adapter->Lock);

           Adapter->FlowsInstalled ++;

           CurrentFlows = Adapter->FlowsInstalled; 

           PS_UNLOCK(&Adapter->Lock);

           PsTcNotify(Adapter, 0, OID_QOS_FLOW_COUNT, &CurrentFlows, sizeof(ULONG));

        }

        //
        // Update Stats 
        //

        InterlockedIncrement(&Vc->AdapterStats->FlowsOpened);
        Vc->AdapterStats->MaxSimultaneousFlows =
            max(Vc->AdapterStats->MaxSimultaneousFlows, CurrentFlows);

        //
        // Notify the GPC
        //
        

        PsDbgOut(DBG_TRACE, 
                 DBG_GPC_QOS, 
                 ("[CmMakeCallComplete]: Adapter %08X, Vc %08X succeeded - "
                  " Notify GPC \n", Adapter, Vc));

        GpcEntries.GpcAddCfInfoNotifyCompleteHandler(GpcQosClientHandle,
                                                     CfInfo,
                                                     Status,
                                                     Vc);

        //
        // Transistion from CL_INTERNAL_CALL_COMPLETE to CL_CALL_COMPLETE
        //

        CallSucceededStateTransition(Vc);


    }
    else {

        PsDbgOut(DBG_FAILURE, 
                 DBG_GPC_QOS,
                 ("[CmMakeCallComplete]: Adapter %08X, Vc %08X, Make Call failed.  Status = %x\n", 
                  Adapter, Vc, Status));

        InterlockedIncrement(&Vc->AdapterStats->FlowsRejected);

        GpcEntries.GpcAddCfInfoNotifyCompleteHandler(GpcQosClientHandle,
                                                     CfInfo,
                                                     Status,
                                                     Vc);

        DerefClVc(Vc);
    }

#if DBG
    NdisInterlockedDecrement(&Adapter->GpcNotifyPending);
#endif

} // CmMakeCallComplete

GPC_STATUS
QosClGetCfInfoName(
    IN  GPC_CLIENT_HANDLE       ClientContext,
    IN  GPC_CLIENT_HANDLE       ClientCfInfoContext,
    OUT PNDIS_STRING            InstanceName
    )

/*++

Routine Description:

    
    The GPC can issue this call to get from us the WMI manageable
    InstanceName which Ndis created for the flow associated with
    the CfInfo struct.

    We guarantee to keep the string buffer around until the CfInfo
    structure is removed.

Arguments:

    ClientContext -         Client context supplied to GpcRegisterClient
    GpcCfInfoHandle -       GPC's handle to CF_INFO
    InstanceName -          We return a pointer to our string.

Return Value:

    Status

--*/

{

    PGPC_CLIENT_VC GpcClientVc = (PGPC_CLIENT_VC)ClientCfInfoContext;
    
    if(GpcClientVc->InstanceName.Buffer){

        InstanceName->Buffer = GpcClientVc->InstanceName.Buffer;
        InstanceName->Length = GpcClientVc->InstanceName.Length;
        InstanceName->MaximumLength =
                        GpcClientVc->InstanceName.MaximumLength;

        return(NDIS_STATUS_SUCCESS);
    }
    else{

        return(NDIS_STATUS_FAILURE);
    }
}


VOID
QosAddCfInfoComplete(
        IN      GPC_CLIENT_HANDLE       ClientContext,
        IN      GPC_CLIENT_HANDLE       ClientCfInfoContext,
        IN      GPC_STATUS              Status
        )

/*++

Routine Description:

    The GPC has completed processing an AddCfInfo request.

Arguments:

    ClientContext -         Client context supplied to GpcRegisterClient
    ClientCfInfoContext -   CfInfo context
    Status -                Final status

Return Value:


--*/

{
    //
    // The PS never adds CF_INFO's so this routine should never be called
    //

    DEBUGCHK;

} // QosAddCfInfoComplete


GPC_STATUS
QosModifyCfInfoNotify(
        IN      GPC_CLIENT_HANDLE       ClientContext,
        IN      GPC_CLIENT_HANDLE       ClientCfInfoContext,
        IN      ULONG                   CfInfoSize,
        IN      PVOID                   NewCfInfoPtr
        )

/*++

Routine Description:

    A CF_INFO is being modified.

Arguments:

    ClientContext -         Client context supplied to GpcRegisterClient
    ClientCfInfoContext -   CfInfo context
    NewCfInfoPtr -          Pointer to proposed CF_INFO content

Return Value:

    Status

--*/

{
    PGPC_CLIENT_VC              GpcClientVc = (PGPC_CLIENT_VC)ClientCfInfoContext;
    PCF_INFO_QOS                NewCfInfo = (PCF_INFO_QOS)NewCfInfoPtr;
    NDIS_STATUS                 Status;
    ULONG                       CallParamsLength;
    PCO_CALL_PARAMETERS         CallParams;
    PCO_CALL_MANAGER_PARAMETERS CallMgrParams;
    PCO_MEDIA_PARAMETERS        PsMediaParameters;
    LPQOS_PRIORITY              PriorityObject;
    PADAPTER                    Adapter;
    ULONG                       TcObjAlignedLength;

    //
    // Do sanity checks
    //

    //
    // Verify that the TcObjectsLength is consistent with the
    // CfInfoSize. The CfInfoSize must have been verified during
    // the user/kernel transition. The TcObjectsLength has not.
    // We could bugcheck if we try to search beyond the buffer
    // passed in.
    //

    if(CfInfoSize < (FIELD_OFFSET(CF_INFO_QOS, GenFlow) +
                     FIELD_OFFSET(TC_GEN_FLOW, TcObjects) +
                     NewCfInfo->GenFlow.TcObjectsLength)){

        PsDbgOut(DBG_FAILURE, DBG_GPC_QOS,
                 ("[QosModifyCfInfoNotify]: TcObjectsLength inconsistent with "
                  "CfInfoSize \n"));

        return(ERROR_TC_OBJECT_LENGTH_INVALID);
    }

    Adapter = GpcClientVc->Adapter;

    PS_LOCK(&Adapter->Lock);

    if(Adapter->PsMpState != AdapterStateRunning) {

        PS_UNLOCK(&Adapter->Lock);

        PsDbgOut(DBG_FAILURE, DBG_GPC_QOS,
                 ("[QosModifyCfInfoNotify]: Adapter %08X closing, cannot accept "
                  "modify request \n", Adapter));

        return GPC_STATUS_NOTREADY;
    }
    PS_UNLOCK(&Adapter->Lock);

    //
    // Allocate the resources for the call manager parameters
    //

    TcObjAlignedLength = ((NewCfInfo->GenFlow.TcObjectsLength + (sizeof(PVOID)-1)) & ~(sizeof(PVOID)-1));
    CallParamsLength =
            sizeof(CO_CALL_PARAMETERS) +
                   FIELD_OFFSET(CO_CALL_MANAGER_PARAMETERS, CallMgrSpecific) +
                   FIELD_OFFSET(CO_SPECIFIC_PARAMETERS, Parameters) +
                   TcObjAlignedLength +
                   FIELD_OFFSET(CO_MEDIA_PARAMETERS, MediaSpecific) +
                   FIELD_OFFSET(CO_SPECIFIC_PARAMETERS, Parameters);

    if(Adapter->MediaType == NdisMediumWan) {

        CallParamsLength += sizeof(QOS_WAN_MEDIA);
    }

    PsAllocatePool( CallParams, CallParamsLength, CmParamsTag );

    if ( CallParams == NULL ) {

        PsDbgOut(DBG_FAILURE, DBG_GPC_QOS,
                 ("[QosModifyCfInfoNotify]: Adapter %08X, can't allocate call params\n"));
        
        return NDIS_STATUS_RESOURCES;
    }

    //
    // Create a call parameters struct for the ModifyCallQoS
    //

    CallMgrParams = (PCO_CALL_MANAGER_PARAMETERS)(CallParams + 1);
    CallMgrParams->Transmit = NewCfInfo->GenFlow.SendingFlowspec;
    CallMgrParams->Receive = NewCfInfo->GenFlow.ReceivingFlowspec;
    CallMgrParams->CallMgrSpecific.ParamType = PARAM_TYPE_GQOS_INFO;
    CallMgrParams->CallMgrSpecific.Length = NewCfInfo->GenFlow.TcObjectsLength;

    if (NewCfInfo->GenFlow.TcObjectsLength > 0) {
        NdisMoveMemory(
            CallMgrParams->CallMgrSpecific.Parameters,
            NewCfInfo->GenFlow.TcObjects,
            NewCfInfo->GenFlow.TcObjectsLength);
    }

    // Ndis requires at least 8 bytes of media specific! Use dummy.

    PsMediaParameters =
            (PCO_MEDIA_PARAMETERS)((PUCHAR)CallMgrParams +
                FIELD_OFFSET(CO_CALL_MANAGER_PARAMETERS, CallMgrSpecific) +
                FIELD_OFFSET(CO_SPECIFIC_PARAMETERS, Parameters) +
                TcObjAlignedLength);

    PsMediaParameters->Flags = 0;
    PsMediaParameters->ReceivePriority = 0;
    PsMediaParameters->ReceiveSizeHint = NewCfInfo->GenFlow.SendingFlowspec.MaxSduSize;
    PsMediaParameters->MediaSpecific.ParamType = PARAM_TYPE_GQOS_INFO;
    PsMediaParameters->MediaSpecific.Length = 0;

    if(Adapter->MediaType == NdisMediumWan) {

        LPQOS_WAN_MEDIA WanMedia;
        PsMediaParameters->MediaSpecific.Length += sizeof(QOS_WAN_MEDIA);
        WanMedia = (LPQOS_WAN_MEDIA) PsMediaParameters->MediaSpecific.Parameters;

        WanMedia->ObjectHdr.ObjectType   = QOS_OBJECT_WAN_MEDIA;
        WanMedia->ObjectHdr.ObjectLength = sizeof(QOS_WAN_MEDIA);

        NdisMoveMemory(&WanMedia->LinkId,
                       GpcClientVc->WanLink->OriginalRemoteMacAddress,
                       6);

    }

    CallParams->Flags = 0;
    CallParams->CallMgrParameters = CallMgrParams;
    CallParams->MediaParameters = (PCO_MEDIA_PARAMETERS)PsMediaParameters;

    GpcClientVc->ModifyCallParameters = CallParams;
    GpcClientVc->ModifyCfInfoQoS = NewCfInfo;

    PS_LOCK(&GpcClientVc->Lock);
    
    switch(GpcClientVc->ClVcState) {

      case CL_INTERNAL_CALL_COMPLETE:

          // CL_INTERNAL_CALL_COMPLETE:
          //      If we are in this state, then probably we have 
          // told the GPC about the Add, & the GPC has turned right
          // back and asked us to modify before we have got a chance
          // to transistion to CL_CALL_COMPLETE.

          //
          // Remember that we have got a modify, we will complete the modify
          // when we transistion to the CL_CALL_COMPLETE state.
          //
          
          GpcClientVc->Flags |= GPC_MODIFY_REQUESTED;
          PS_UNLOCK(&GpcClientVc->Lock);
#if DBG
          NdisInterlockedIncrement(&Adapter->GpcNotifyPending);
#endif
          return NDIS_STATUS_PENDING;

      case CL_CALL_COMPLETE:

          GpcClientVc->ClVcState = CL_MODIFY_PENDING;
          PS_UNLOCK(&GpcClientVc->Lock);
          break;

      default:

          //
          // In general, we expect the call to be in the 
          // CL_CALL_COMPLETE state when a modify request comes
          // in. It could be in the following states as well:
          //
          // CALL_PENDING:
          //      If we are in this state, then we have not 
          // completed the AddCfInfo request from the GPC. This
          // should not happen.
          //
          //
          // GPC_CLOSE_PENDING:
          //      If an InternalCloseCall is requested, we
          //  change to this state before asking the GPC to
          //  close. The GPC could slip in this window and
          //  ask us to modify the call. 
          //
          // MODIFY_PENDING:
          //      We have not told the GPC about the previous modify
          //  request. Therefore, the GPC cannot ask us to modify a 
          //  call if we are in this state.
          //
          
          PsAssert(GpcClientVc->ClVcState != CL_CALL_PENDING);
          PsAssert(GpcClientVc->ClVcState != CL_MODIFY_PENDING);
          PsAssert(GpcClientVc->ClVcState != CL_GPC_CLOSE_PENDING);
          PS_UNLOCK(&GpcClientVc->Lock);

          PsFreePool(CallParams);
          GpcClientVc->ModifyCallParameters = 0;
          GpcClientVc->ModifyCfInfoQoS      = 0;

          PsDbgOut(DBG_FAILURE, DBG_GPC_QOS,
                   ("[QosModifyCfInfoNotify]: Adapter %08X, Vc %08X, State %08X, Flags %08X -"
                    " Not ready to modify flow !\n",
                    Adapter, GpcClientVc, GpcClientVc->ClVcState, GpcClientVc->Flags));
          
          return(GPC_STATUS_NOTREADY);
    }

    //
    // Now issue the ModifyCallQoS to the PS call manager
    //

    Status = CmModifyCall(GpcClientVc);

    if(Status != NDIS_STATUS_PENDING) {
        
        CmModifyCallComplete(Status, GpcClientVc, CallParams);
    }

    PsDbgOut(DBG_TRACE, DBG_GPC_QOS,
             ("[QosModifyCfInfoNotify]: Adapter %08X, Vc %08X, State %08X, Flags %08X -"
              " modify flow returns pending \n",
              Adapter, GpcClientVc, GpcClientVc->ClVcState, GpcClientVc->Flags));
    
#if DBG
    NdisInterlockedIncrement(&Adapter->GpcNotifyPending);
#endif
    return NDIS_STATUS_PENDING;

} // QosModifyCfInfoNotify


VOID
CmModifyCallComplete(
    IN NDIS_STATUS         Status,
    IN PGPC_CLIENT_VC      GpcClientVc,
    IN PCO_CALL_PARAMETERS CallParameters
    )

/*++

Routine Description:

    The call manager has finished processing a ModifyCallQoS request.

Arguments:

    See the DDK

Return Value:

--*/

{
    PADAPTER Adapter = GpcClientVc->Adapter;

    //
    // We call this to change back to the CALL_COMPLETE state.
    // We make the same call whether the modify actually completed
    // or not, since the call remains up.
    //
    // The internal best effort VC is not known by 
    // the GPC and therefore, is never modified by it.
    //

    PsAssert(!IsBestEffortVc(GpcClientVc));


    if(Status != NDIS_STATUS_SUCCESS){

        PsDbgOut(DBG_FAILURE, 
                 DBG_GPC_QOS,
                 ("[CmModifyCallQoSComplete]: Adapter %08X, Vc %08x, modify QoS failed. Status = %x\n", 
                  Adapter, GpcClientVc, Status));

        PsFreePool(GpcClientVc->ModifyCallParameters);
        
        InterlockedIncrement(&GpcClientVc->AdapterStats->FlowModsRejected);

        //
        // Transistion from CL_MODIFY_PENDING to CL_INTERNAL_CALL_COMPLETE
        //
        CallSucceededStateTransition(GpcClientVc);
    }
    else 
    {
        PsDbgOut(DBG_TRACE,
                 DBG_GPC_QOS,
                 ("[CmModifyCallQoSComplete]: Adapter %08X, Vc %08X, modify QoS succeeded. \n",
                  Adapter, GpcClientVc));

        //
        // Tell NDISWAN about the fragment size
        //
        if((Adapter->MediaType == NdisMediumWan) && (GpcClientVc->Flags & GPC_ISSLOW_FLOW)) 
        {
            MakeLocalNdisRequest(Adapter, 
                                 GpcClientVc->NdisWanVcHandle,
                                 NdisRequestLocalSetInfo,
                                 OID_QOS_ISSLOW_FRAGMENT_SIZE, 
                                 &GpcClientVc->ISSLOWFragmentSize, 
                                 sizeof(ULONG), 
                                 NULL);

        }

        //
        // Update Stats 
        //
        InterlockedIncrement(&GpcClientVc->AdapterStats->FlowsModified);

        PsFreePool(GpcClientVc->CallParameters);

        GpcClientVc->CallParameters = CallParameters;
        GpcClientVc->ModifyCallParameters = NULL;
        GpcClientVc->CfInfoQoS       = GpcClientVc->ModifyCfInfoQoS;
        GpcClientVc->ModifyCfInfoQoS = 0;

        //
        // Transistion from CL_MODIFY_PENDING to CL_INTERNAL_CALL_COMPLETE
        //
        CallSucceededStateTransition(GpcClientVc);

        //
        // Mark the TOS Byte for this service type
        //
        PS_LOCK(&GpcClientVc->Lock);

        SetTOSIEEEValues(GpcClientVc);

        PS_UNLOCK(&GpcClientVc->Lock);

    }

    PsAssert(GpcEntries.GpcModifyCfInfoNotifyCompleteHandler);

    GpcEntries.GpcModifyCfInfoNotifyCompleteHandler(GpcQosClientHandle, 
                                                    GpcClientVc->CfInfoHandle, 
                                                    Status);
    //
    // Transistion from CL_INTERNAL_CALL_COMPLETE to CL_CALL_COMPLETE
    //
    CallSucceededStateTransition(GpcClientVc);

#if DBG
    NdisInterlockedDecrement(&Adapter->GpcNotifyPending);
#endif
        
} // ClModifyCallQoSComplete


VOID
QosModifyCfInfoComplete(
        IN      GPC_CLIENT_HANDLE       ClientContext,
        IN      GPC_CLIENT_HANDLE       ClientCfInfoContext,
        IN      GPC_STATUS              Status
        )

/*++

Routine Description:

    The GPC has completed processing an AddCfInfo request.

Arguments:

    ClientContext -         Client context supplied to GpcRegisterClient
    ClientCfInfoContext -   CfInfo context
    Status -                Final status

Return Value:


--*/

{

} // QosModifyCfInfoComplete


GPC_STATUS
QosRemoveCfInfoNotify(
        IN      GPC_CLIENT_HANDLE       ClientContext,
        IN      GPC_CLIENT_HANDLE       ClientCfInfoContext
        )

/*++

Routine Description:

    A CF_INFO is being removed.

Arguments:

    ClientContext -         Client context supplied to GpcRegisterClient
    ClientCfInfoContext -   CfInfo context

Return Value:

    Status

--*/

{
    PGPC_CLIENT_VC Vc = (PGPC_CLIENT_VC)ClientCfInfoContext;
    NDIS_STATUS    Status;
    ULONG          CurrentFlows;
    PADAPTER       Adapter = Vc->Adapter;

    PsAssert(!IsBestEffortVc(Vc));

    PsDbgOut(DBG_TRACE, DBG_GPC_QOS,
             ("[QosRemoveCfInfoNotify]: Adapter %08X, Vc %08X, State %08X,"
              "Flags %08X \n", Adapter, Vc, Vc->ClVcState, Vc->Flags));

    //
    // Check the state of the VC. 
    //

    PS_LOCK(&Vc->Lock);

    switch(Vc->ClVcState){

      case CL_CALL_PENDING:
      case CL_MODIFY_PENDING:
        

          // CL_NDIS_CLOSE_PENDING:
          //
          // The GPC has to close before Ndis closes. So - if we're here, the GPC has already 
          // closed, in which case - it should not be  trying to close again.
          //
          // CL_CALL_PENDING, CL_MODIFY_PENDING:
          //
          // The GPC is asking us to close a VC which we  never told it about. Note that even 
          // though we can change from CL_INTERNAL_CALL_COMPLETE  to CL_MODIFY_PENDING, 
          // the GPC can *never* ask us to close in CL_MODIFY_PENDING because
          // even if the above case happens, we have not completed the modify with the GPC.
          //
          
          PS_UNLOCK(&Vc->Lock);

          PsDbgOut(DBG_FAILURE,
                   DBG_STATE,
                   ("[QosRemoveCfInfoNotify]: bad state %s on VC %x\n",
                    GpcVcState[Vc->ClVcState], Vc));
          
          PsAssert(0);

          return(GPC_STATUS_FAILURE);
          
      case CL_INTERNAL_CALL_COMPLETE:

          //
          // We tell the GPC in the CL_INTERNAL_CALL_COMPLETE state and then transistion 
          // to the CL_CALL_COMPLETE state. However, there is a small window when the GPC 
          // can ask us to delete this VC in the CL_INTERNAL_CALL_COMPLETE state 
          // We wait till we move to CL_CALL_COMPLETE before deleting the Vc.
          //

          Vc->Flags |= GPC_CLOSE_REQUESTED;

          PS_UNLOCK(&Vc->Lock);

#if DBG
          NdisInterlockedIncrement(&Adapter->GpcNotifyPending);
#endif

          return (GPC_STATUS_PENDING);
          
      case CL_CALL_COMPLETE:
          
          //
          // Normal GPC close request. 
          //
          
          Vc->ClVcState = CL_GPC_CLOSE_PENDING;

          Vc->Flags |= GPC_CLOSE_REQUESTED;

          PS_UNLOCK(&Vc->Lock);

          Status = CmCloseCall(Vc);

          PsAssert(Status == NDIS_STATUS_PENDING);

#if DBG
          NdisInterlockedIncrement(&Adapter->GpcNotifyPending);
#endif

          return(GPC_STATUS_PENDING);
          
      case CL_INTERNAL_CLOSE_PENDING:
          
          //
          // We're here cause we were about to initiate a close and we're waiting 
          // for it to complete. It looks like the GPC asked us to close, before
          // we actually asked it to close. First - check that the GPC has not
          // asked us to close prior to this request.
          //
          
          PsAssert(!(Vc->Flags & GPC_CLOSE_REQUESTED));
          
          // 
          // If the GPC is asking us to close, the GPC MUST fail the call when we 
          // ask it to close. So, we'll simply wait here till that happens. Note that
          // we cannot pend this call and complete it later from the Internal Close handler.
          //
          // If we Deref the VC from the Internal Close Complete handler, there could be a race
          // condition and we could be looking at a stale VC pointer. So, the VC MUST be Deref'd
          // from here. We do not have to call CmCloseCall because we called it from the InternalClose
          // handler.
          //

          Vc->Flags |= GPC_CLOSE_REQUESTED;

          PS_UNLOCK(&Vc->Lock);
            
          NdisWaitEvent(&Vc->GpcEvent, 0);

          DerefClVc(Vc);

          return GPC_STATUS_SUCCESS;
          
      default:
          
          PS_UNLOCK(&Vc->Lock);
          
          PsDbgOut(DBG_FAILURE,
                   DBG_STATE,
                   ("[QosRemoveCfInfoNotify]: invalid state %s on VC %x\n",
                    GpcVcState[Vc->ClVcState], Vc));
          
          PsAssert(0);

          return GPC_STATUS_FAILURE;
    }

} // QosRemoveCfInfoNotify



VOID
CmCloseCallComplete(
    IN NDIS_STATUS Status,
    IN PGPC_CLIENT_VC Vc
    )

/*++

Routine Description:

    The call manager has finished processing a CloseCall request.

Arguments:

    See the DDK

Return Value:

--*/

{
    PADAPTER       Adapter = Vc->Adapter;
    NDIS_STATUS    LocalStatus;
    ULONG          CurrentFlows;

    PsAssert(!IsBestEffortVc(Vc)); 

    
    if(Adapter->MediaType == NdisMediumWan) {

        //
        // To optimize send path
        //
        InterlockedDecrement(&Vc->WanLink->CfInfosInstalled);
        
        PS_LOCK(&Vc->WanLink->Lock);
        
        Vc->WanLink->FlowsInstalled --;
        
        CurrentFlows = Vc->WanLink->FlowsInstalled;
        
        PS_UNLOCK(&Vc->WanLink->Lock);
        
        PsTcNotify(Adapter, Vc->WanLink, OID_QOS_FLOW_COUNT, &CurrentFlows, sizeof(ULONG));
        
    }
    else 
    {
        //
        // To optimize send path
        //
        InterlockedDecrement(&Adapter->CfInfosInstalled);

        PS_LOCK(&Adapter->Lock);
        
        Adapter->FlowsInstalled --;
        
        CurrentFlows = Adapter->FlowsInstalled;
        
        PS_UNLOCK(&Adapter->Lock);
        
        PsTcNotify(Adapter, 0, OID_QOS_FLOW_COUNT, &CurrentFlows, sizeof(ULONG));
    }
    
    //
    // Update stats
    //
    
    InterlockedIncrement(&Vc->AdapterStats->FlowsClosed);
    
    Vc->AdapterStats->MaxSimultaneousFlows =
        max(Vc->AdapterStats->MaxSimultaneousFlows, CurrentFlows);
    
    PS_LOCK(&Vc->Lock);

    if(Vc->Flags & INTERNAL_CLOSE_REQUESTED)
    {
        // We have asked to close this call. Let's process the close now.
        // Note that we don't really care if the GPC has asked us to close.
        // 
        // Because - 
        // 1. If we had initiated an internal close after the GPC asks us to close, we ignore the internal close, 
        //    and the above flag will not be set.
        // 2. If the GPC had asked us to close, we have pended it - We will now complete it when the GPC fails our
        //    call to close the Vc.
        //
        
        PS_UNLOCK(&Vc->Lock);
        
        PsDbgOut(DBG_TRACE, DBG_GPC_QOS,
                 ("[CmCloseCallComplete]: Adapter %08X, Vc %08X (State %08X, Flags %08X), "
                  "Internal Close requested \n",
                  Adapter, Vc, Vc->ClVcState, Vc->Flags));

        Status = GpcEntries.GpcRemoveCfInfoHandler(GpcQosClientHandle, Vc->CfInfoHandle);
        
        if(Status != NDIS_STATUS_PENDING) {
            
            QosRemoveCfInfoComplete(NULL, Vc, Status);
        }
        
        return;
    }
    
    PS_UNLOCK(&Vc->Lock);

    //
    // Complete the request with the GPC.
    //
    GpcEntries.GpcRemoveCfInfoNotifyCompleteHandler(GpcQosClientHandle,
                                                    Vc->CfInfoHandle,
                                                    GPC_STATUS_SUCCESS);

#if DBG
    NdisInterlockedDecrement(&Adapter->GpcNotifyPending);
#endif
    DerefClVc(Vc);

    return;
}
       
VOID
DerefClVc(
    PGPC_CLIENT_VC Vc
    )
{
    ULONG RefCount;

    RefCount = InterlockedDecrement(&Vc->RefCount);

    if(!RefCount)
    {
        PsDbgOut(DBG_INFO,
                 DBG_STATE,
                 ("DerefClVc: deref'd to 0. State is %s on VC %x\n",
                 GpcVcState[Vc->ClVcState], Vc));

        if(Vc->NdisWanVcHandle)
        {
            WanCloseCall(Vc);
        }
        else 
        {
            CmDeleteVc(Vc);
        }
        
    }

} // DerefClVc


    
VOID
QosRemoveCfInfoComplete(
        IN      GPC_CLIENT_HANDLE       ClientContext,
        IN      GPC_CLIENT_HANDLE       ClientCfInfoContext,
        IN      GPC_STATUS              Status
        )

/*++

Routine Description:

    The GPC has completed processing an AddCfInfo request.

Arguments:

    ClientContext -         Client context supplied to GpcRegisterClient
    ClientCfInfoContext -   CfInfo context
    Status -                Final status

Return Value:


--*/

{
    PGPC_CLIENT_VC Vc = (PGPC_CLIENT_VC)ClientCfInfoContext;

    PsDbgOut(DBG_TRACE, DBG_GPC_QOS,
             ("[QosRemoveCfInfoComplete]: Adapter %08X, Vc %08X "
              "(State = %08X, Flags = %08X), Status %08X \n", Vc->Adapter, Vc, 
              Vc->ClVcState, Vc->Flags, Status));

    if(Status != NDIS_STATUS_SUCCESS)
    {
        //
        // The GPC has requested a close, which has been pended. Complete that request.
        //
        
        PsDbgOut(DBG_TRACE, 
                 DBG_GPC_QOS,
                 ("[QosRemoveCfInfoComplete]: Vc %08X, completing with GPC \n", Vc));

        NdisSetEvent(&Vc->GpcEvent);
    }
    else {
        DerefClVc(Vc);
    }

} // QosRemoveCfInfoComplete
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\gpchndlr.h ===
/*++

Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

    GpcHndlr.h

Abstract:

    GPC client handler defs

Author:

Revision History:

--*/

#ifndef _GPC_HNDLR_
#define _GPC_HNDLR_

// Prototypes

GPC_STATUS
QosAddCfInfoNotify(
	IN	GPC_CLIENT_HANDLE       ClientContext,
	IN	GPC_HANDLE              GpcCfInfoHandle,
    IN  ULONG                   CfInfoSize,
    IN  PVOID                   CfInfoPtr,
	IN	PGPC_CLIENT_HANDLE      ClientCfInfoContext
	);

GPC_STATUS
QosClGetCfInfoName(
    IN  GPC_CLIENT_HANDLE       ClientContext,
    IN  GPC_CLIENT_HANDLE       ClientCfInfoContext,
    OUT PNDIS_STRING            InstanceName
    );

//
// Internal Completion handlers
//
VOID
CmMakeCallComplete(NDIS_STATUS Status,
                   PGPC_CLIENT_VC Vc, 
                   PCO_CALL_PARAMETERS CallParameters);

VOID
CmModifyCallComplete(
    IN NDIS_STATUS         Status,
    IN PGPC_CLIENT_VC      GpcClientVc,
    IN PCO_CALL_PARAMETERS CallParameters
    );

VOID
CmCloseCallComplete(
    IN NDIS_STATUS Status,
    IN PGPC_CLIENT_VC Vc
    );


VOID
QosAddCfInfoComplete(
	IN	GPC_CLIENT_HANDLE       ClientContext,
	IN	GPC_CLIENT_HANDLE       ClientCfInfoContext,
	IN	GPC_STATUS              Status
	);

GPC_STATUS
QosModifyCfInfoNotify(
	IN	GPC_CLIENT_HANDLE       ClientContext,
	IN	GPC_CLIENT_HANDLE       ClientCfInfoContext,
    IN	ULONG					CfInfoSize,
	IN	GPC_HANDLE              CfInfo
	);

VOID
ClModifyCallQoSComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE ProtocolVcContext,
    IN PCO_CALL_PARAMETERS CallParameters
    );

VOID
QosModifyCfInfoComplete(
	IN	GPC_CLIENT_HANDLE       ClientContext,
	IN	GPC_CLIENT_HANDLE       ClientCfInfoContext,
	IN	GPC_STATUS              Status
	);

GPC_STATUS
QosRemoveCfInfoNotify(
	IN	GPC_CLIENT_HANDLE       ClientContext,
	IN	GPC_CLIENT_HANDLE       ClientCfInfoContext
	);

VOID
ClCloseCallComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE ProtocolVcContext,
    IN PCO_CALL_PARAMETERS CallParameters
    );

VOID
QosRemoveCfInfoComplete(
	IN	GPC_CLIENT_HANDLE       ClientContext,
	IN	GPC_CLIENT_HANDLE       ClientCfInfoContext,
	IN	GPC_STATUS              Status
	);

VOID
DerefClVc(
    IN PGPC_CLIENT_VC Vc);

NDIS_STATUS
CloseCallWithNdis(
    PGPC_CLIENT_VC Vc
    );

NDIS_STATUS
CloseCallWithGpc(
    PGPC_CLIENT_VC Vc
    );

//
// Prototypes for CF_INFO_CLASS_MAP
//
GPC_STATUS
ClassMapAddCfInfoNotify(
	IN	GPC_CLIENT_HANDLE       ClientContext,
	IN	GPC_HANDLE              GpcCfInfoHandle,
    IN  ULONG                   CfInfoSize,
    IN  PVOID                   CfInfoPtr,
	IN	PGPC_CLIENT_HANDLE      ClientCfInfoContext
	);

GPC_STATUS
ClassMapClGetCfInfoName(
    IN  GPC_CLIENT_HANDLE       ClientContext,
    IN  GPC_CLIENT_HANDLE       ClientCfInfoContext,
    OUT PNDIS_STRING            InstanceName
    );

VOID
ClassMapAddCfInfoComplete(
	IN	GPC_CLIENT_HANDLE       ClientContext,
	IN	GPC_CLIENT_HANDLE       ClientCfInfoContext,
	IN	GPC_STATUS              Status
	);

GPC_STATUS
ClassMapModifyCfInfoNotify(
	IN	GPC_CLIENT_HANDLE       ClientContext,
	IN	GPC_CLIENT_HANDLE       ClientCfInfoContext,
    IN	ULONG					CfInfoSize,
	IN	GPC_HANDLE              CfInfo
	);

VOID
ClassMapModifyCfInfoComplete(
	IN	GPC_CLIENT_HANDLE       ClientContext,
	IN	GPC_CLIENT_HANDLE       ClientCfInfoContext,
	IN	GPC_STATUS              Status
	);

GPC_STATUS
ClassMapRemoveCfInfoNotify(
	IN	GPC_CLIENT_HANDLE       ClientContext,
	IN	GPC_CLIENT_HANDLE       ClientCfInfoContext
	);

VOID
ClassMapRemoveCfInfoComplete(
	IN	GPC_CLIENT_HANDLE       ClientContext,
	IN	GPC_CLIENT_HANDLE       ClientCfInfoContext,
	IN	GPC_STATUS              Status
	);

VOID
SetTOSIEEEValues(PGPC_CLIENT_VC Vc);

// End prototypes

#endif // _GPC_HNDLR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\main.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    main.h

Abstract:

    defines for the main driver

Author:

    Rajesh Sundaram (9-17-1998)

Environment:

    Kernel Mode

Revision History:

--*/

/* External */

/* Static */

/* Prototypes */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\osdep.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    osdep.h

Abstract:

    defines for OS specific routines

Author:

    Charlie Wickham (charlwi) 17-Sep-1996

Revision History:

--*/

#ifndef _OSDEP_
#define _OSDEP_

//
// shortest timer period in 100 ns units
//

#define TIMER_GRANULARITY    10000

#endif /* _OSDEP_ */

/* end osdep.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\main.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    main.c

Abstract:

    This is the initialization file for the packet scheduler driver. This driver
    is used to provide Local Traffic Control

Author:

    Charlie Wickham (charlwi)  
    Rajesh Sundaram (rajeshsu) 01-Aug-1998.

Environment:

    Kernel Mode

Revision History:

--*/

#include "psched.h"

#pragma hdrstop

//
// number of characters that are appended to the RegistryPath when constructing
// the miniport device name
//

#define MPNAME_EXTENSION_SIZE   ( 3 * sizeof(WCHAR))

/* External */

/* Static */

/* Forward */ 

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NDIS_STATUS
InitializeNdisWrapper(
    IN PDRIVER_OBJECT DriverObject,
    IN  PUNICODE_STRING RegistryPath
    );

NDIS_STATUS
DoMiniportInit(
    IN PDRIVER_OBJECT DriverObject,
    IN  PUNICODE_STRING RegistryPath
    );

NDIS_STATUS
DoProtocolInit(IN PDRIVER_OBJECT DriverObject, 
               IN  PUNICODE_STRING RegistryPath);

NTSTATUS
RegisterWithGpc();

NDIS_STATUS
InitializeScheduler(VOID);

VOID
InitializationCleanup(ULONG ShutdownMask);

VOID
GetTimerInfo (OUT PULONG TimerResolution);

VOID
PSUnload(IN PDRIVER_OBJECT pDriverObject);

/* End Forward */

#pragma NDIS_INIT_FUNCTION(DriverEntry)
#pragma NDIS_INIT_FUNCTION(InitializeNdisWrapper)
#pragma NDIS_INIT_FUNCTION(DoProtocolInit)
#pragma NDIS_INIT_FUNCTION(DoMiniportInit)



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the NT OS specific driver entry point.  It kicks off initialization
    for the driver.  Currently, it is not PnP aware. Return from this routine
    only after protocol registration, layered miniport registration, and both
    miniport and higher layer protocol initialization has been done.

Arguments:

    DriverObject - NT OS specific Object
    RegistryPath - NT OS specific pointer to registry location for Psched

Return Values:

    STATUS_SUCCESS
    STATUS_FAILURE

--*/
{
    NDIS_STATUS Status;
    NTSTATUS    NtStatus;
    PVOID       DumpData;

#if DBG
    //
    // announce the version
    //
    PsDbgOut(DBG_INFO, DBG_INIT, (VersionHerald, VersionNumber, VersionTimestamp));
#endif

    //
    // store a copy of our driver object. Used by NdisWriteEventLogEntry
    //
    PsDriverObject = DriverObject;

    //
    // Initialize the Driver refcount and DriverState
    //
    gDriverState = DriverStateLoaded;
    PS_INIT_SPIN_LOCK(&DriverUnloadLock);
    NdisInitializeEvent(&DriverUnloadEvent);
    NdisSetEvent(&DriverUnloadEvent);

    NdisInitializeEvent(&gZAWEvent);

    //
    // initialize global data and ndis request lookaside list
    //

    InitializeListHead(&AdapterList);
    PS_INIT_SPIN_LOCK(&AdapterListLock);

    InitializeListHead(&PsComponentList);
    PS_INIT_SPIN_LOCK(&PsComponentListLock);

    InitializeListHead(&PsProfileList);
    PS_INIT_SPIN_LOCK(&PsProfileLock);

    // Initialize scheduling components

    InitializeTbConformer(&TbConformerInfo);
    InitializeDrrSequencer(&DrrSequencerInfo);
    InitializeTimeStmp(&TimeStmpInfo);
    InitializeSchedulerStub(&SchedulerStubInfo);

    //
    // Add these components to the component list
    //

    InsertHeadList(&PsComponentList, &TbConformerInfo.Links );
    InsertHeadList(&PsComponentList, &DrrSequencerInfo.Links );
    InsertHeadList(&PsComponentList, &TimeStmpInfo.Links );
    InsertHeadList(&PsComponentList, &SchedulerStubInfo.Links );

    PsProcs.DropPacket     = DropPacket;
    PsProcs.NdisPipeHandle = GetNdisPipeHandle;
    PsProcs.GetTimerInfo   = GetTimerInfo;

    //
    // init the LLists for NdisRequest, MCM_VC, AND CLIENT_VC structs 
    // as these will be in high demand at times.
    //
    // Lookaside list depth is automatically managed by the executive. 
    //

    NdisInitializeNPagedLookasideList(&NdisRequestLL,
                                      NULL,
                                      NULL,
                                      0,
                                      sizeof(PS_NDIS_REQUEST),
                                      NdisRequestTag,
                                      (USHORT)0);

    NdisInitializeNPagedLookasideList(&GpcClientVcLL,
                                      NULL,
                                      NULL,
                                      0,
                                      sizeof( GPC_CLIENT_VC ),
                                      GpcClientVcTag,
                                      (USHORT)0);

    //
    // get driver wide configuration data from the registry
    //

    Status = PsReadDriverRegistryDataInit();

    if(NT_SUCCESS(Status))
    {
        Status = PsReadDriverRegistryData();

        if(!NT_SUCCESS(Status))
        {
            PsDbgOut(DBG_FAILURE, DBG_INIT, ("DriverEntry: PsReadDriverRegistryData - Status: 0x%x\n",  
                                             Status));
            goto DriverEntryError;
        }
    }
    else
    {
        PsDbgOut(DBG_FAILURE, DBG_INIT, ("DriverEntry: PsReadDriverRegistryDataInit - Status: 0x%x\n", 
                                         Status));
        goto DriverEntryError;
    }

    //
    // Initialize space for WanLinks. Note that we don't need a lock to protect
    // this table - We recognize lineups only on the NDISWAN-IP binding, so we 
    // can use the Adapter lock from the binding for synchronization.
    //

    PsAllocatePool(g_WanLinkTable, 
                   WAN_TABLE_INITIAL_SIZE * sizeof(ULONG_PTR), 
                   WanTableTag);

    if(!g_WanLinkTable)
    {
        PsDbgOut(DBG_CRITICAL_ERROR,
                 DBG_INIT,
                 ("[DriverEntry]: Cannot allocate memory for wanlinks \n"));

        NdisWriteEventLogEntry(PsDriverObject,
                               EVENT_PS_NO_RESOURCES_FOR_INIT,
                               0,
                               0,
                               NULL,
                               0,
                               NULL);

        goto DriverEntryError;
                 
    }
    
    g_WanTableSize = WAN_TABLE_INITIAL_SIZE;

    NdisZeroMemory(g_WanLinkTable, g_WanTableSize * sizeof(ULONG_PTR));

    //
    // The first entry is never used.
    //
    g_WanLinkTable[0] = (ULONG_PTR) -1;

    g_NextWanIndex = 1;



    // 
    // Register with the Generic Packet Classifier 
    //

    NtStatus = RegisterWithGpc();

    if(!NT_SUCCESS(NtStatus))
    {
        PsDbgOut(DBG_CRITICAL_ERROR,
                 DBG_INIT,
                 ("RegisterWithGpc Failed! Status: 0x%x\n", NtStatus));

        DumpData = &NtStatus;
        NdisWriteEventLogEntry(PsDriverObject,
                               EVENT_PS_GPC_REGISTER_FAILED,
                               0,
                               0,
                               NULL,
                               sizeof(NTSTATUS),
                               DumpData);

        goto DriverEntryError;
    }

    InitShutdownMask |= SHUTDOWN_DEREGISTER_GPC;


    //
    // initialize the wrapper with NDIS
    //

    Status = InitializeNdisWrapper( PsDriverObject, RegistryPath );

    if ( !NT_SUCCESS( Status )) {

        PsDbgOut(DBG_FAILURE, DBG_INIT, 
                 ("DriverEntry: InitializeNdisWrapper - Status: 0x%x\n", Status ));

        NdisWriteEventLogEntry(PsDriverObject,
                               EVENT_PS_NO_RESOURCES_FOR_INIT,
                               0,
                               0,
                               NULL,
                               0,
                               NULL);

        goto DriverEntryError;
    }

    //
    // Initialize as a Miniport driver to the transports. 
    //

    Status = DoMiniportInit(PsDriverObject, RegistryPath);

    if (!NT_SUCCESS(Status)){

        PsDbgOut(DBG_CRITICAL_ERROR,
                 DBG_INIT | DBG_MINIPORT,
                 ("DoMiniportInit Failed! Status: 0x%x\n", Status));

        DumpData = &Status;
        NdisWriteEventLogEntry(PsDriverObject,
                               EVENT_PS_REGISTER_MINIPORT_FAILED,
                               0,
                               0,
                               NULL,
                               sizeof( Status ),
                               DumpData);
        //
        // Terminate the wrapper
        //

        NdisTerminateWrapper(MpWrapperHandle, NULL);

        goto DriverEntryError;
    }

    InitShutdownMask |= SHUTDOWN_DEREGISTER_MINIPORT;

    //
    // do Protocol initialize first
    //

    Status = DoProtocolInit( PsDriverObject, RegistryPath );

    if (!NT_SUCCESS(Status)){

        PsDbgOut(DBG_CRITICAL_ERROR,
                 DBG_INIT | DBG_PROTOCOL,
                 ("DoProtocolInit Failed! Status: 0x%x\n", Status));

        DumpData = &Status;
        NdisWriteEventLogEntry(PsDriverObject,
                               EVENT_PS_REGISTER_PROTOCOL_FAILED,
                               0,
                               0,
                               NULL,
                               sizeof( Status ),
                               DumpData);

        NdisTerminateWrapper(MpWrapperHandle, NULL);

        goto DriverEntryError;
    }

    InitShutdownMask |= SHUTDOWN_DEREGISTER_PROTOCOL;

    NdisIMAssociateMiniport(LmDriverHandle, ClientProtocolHandle);

    return (STATUS_SUCCESS);

    //
    // An error occured so we need to cleanup things
    //

DriverEntryError:
    InitializationCleanup(InitShutdownMask);

    return (STATUS_UNSUCCESSFUL);

} // DriverEntry



NDIS_STATUS
InitializeNdisWrapper(
    IN PDRIVER_OBJECT DriverObject,
    IN  PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    Initialize the Ndis wrapper for both the miniport and protocol 
    sections. Since the name in the registry path is the Protocol 
    key (PSched), 'Mp' is appended onto the end to initialize 
    the wrapper for the miniport side of the PS

Arguments:

    DriverObject - pointer to NT driver object
    RegistryPath - pointer to path to driver params in registry 

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_BAD_VERSION
    NDIS_STATUS_FAILURE

--*/

{
    NDIS_STATUS           Status;
    USHORT                MpDeviceNameLength;
    NDIS_PHYSICAL_ADDRESS HighAddress = NDIS_PHYSICAL_ADDRESS_CONST( -1, -1 );
    ULONG                 i;
    PWCHAR                RegistryPathBuffer;

    //
    // NT needs the MP name to be different from the protocol name
    //

    MpDeviceNameLength = RegistryPath->Length + MPNAME_EXTENSION_SIZE;

    PsAllocatePool(RegistryPathBuffer,
                   MpDeviceNameLength,
                   PsMiscTag);

    if ( RegistryPathBuffer == NULL ) {

        PsDbgOut(DBG_CRITICAL_ERROR,
                 DBG_INIT,
                 ("Can't allocate buffer for MP Device Name\n" ));

        return NDIS_STATUS_RESOURCES;
    }

    //
    // max length includes a trailing null, while length is just the string
    //

    PsMpName.MaximumLength = MpDeviceNameLength;
    PsMpName.Length        = PsMpName.MaximumLength - sizeof( WCHAR );
    PsMpName.Buffer        = RegistryPathBuffer;

    NdisMoveMemory(PsMpName.Buffer, 
                   RegistryPath->Buffer, 
                   RegistryPath->Length );

    i = RegistryPath->Length / sizeof( WCHAR );
    RegistryPathBuffer[ i++ ] = L'M';
    RegistryPathBuffer[ i++ ] = L'P';
    RegistryPathBuffer[ i ]   = L'\0';

    NdisMInitializeWrapper(&MpWrapperHandle, 
                           DriverObject, 
                           &PsMpName, 
                           NULL);

    return NDIS_STATUS_SUCCESS;
} // InitializeNdisWrapper


NDIS_STATUS
DoMiniportInit(
    IN PDRIVER_OBJECT DriverObject,
    IN  PUNICODE_STRING RegistryPath
    )

/*++

Routine Name:

    DoMiniportInit

Routine Description:

    This routines registers Psched as a Miniport driver with the NDIS wrapper.

Arguments:

    None

Return Values:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_BAD_VERSION
    NDIS_STATUS_FAILURE

--*/

{
    NDIS_MINIPORT_CHARACTERISTICS MiniportChars;
    NDIS_STATUS                   Status;

    MiniportChars.MajorNdisVersion = 5;
    MiniportChars.MinorNdisVersion = 0;

    MiniportChars.Reserved                = 0;
    MiniportChars.HaltHandler             = MpHalt;
    MiniportChars.InitializeHandler       = MpInitialize;
    MiniportChars.QueryInformationHandler = MpQueryInformation;
    MiniportChars.ResetHandler            = MpReset;
    MiniportChars.SetInformationHandler   = MpSetInformation;
    MiniportChars.TransferDataHandler     = MpTransferData;

    //
    // Unused handlers
    //

    MiniportChars.ReconfigureHandler      = NULL;
    MiniportChars.DisableInterruptHandler = NULL;
    MiniportChars.EnableInterruptHandler  = NULL;
    MiniportChars.HandleInterruptHandler  = NULL;
    MiniportChars.ISRHandler              = NULL;

    //
    // We will disable the check for hang timeout so we do not
    // need a check for hang handler!
    //

    MiniportChars.CheckForHangHandler     = NULL;

    //
    // Ndis 4.0 handlers. No regular send routine since we have a
    // SendPackets handler.
    //

    MiniportChars.ReturnPacketHandler     = MpReturnPacket;
    MiniportChars.SendPacketsHandler      = NULL;
    MiniportChars.AllocateCompleteHandler = NULL;
    MiniportChars.SendHandler             = MpSend;

    //
    // 4.1 handlers
    //

    MiniportChars.CoCreateVcHandler       = NULL;
    MiniportChars.CoDeleteVcHandler       = NULL;
    MiniportChars.CoActivateVcHandler     = NULL;
    MiniportChars.CoDeactivateVcHandler   = NULL;
    MiniportChars.CoSendPacketsHandler    = NULL;
    MiniportChars.CoRequestHandler        = NULL;

    Status = NdisIMRegisterLayeredMiniport(MpWrapperHandle,
                                           &MiniportChars,
                                           sizeof(MiniportChars),
                                           &LmDriverHandle);

    //
    // Hook the unload function
    //

    NdisMRegisterUnloadHandler(MpWrapperHandle, PSUnload);

    return (Status);
} // DoMiniportInit


NDIS_STATUS
DoProtocolInit(
    IN PDRIVER_OBJECT DriverObject,
    IN  PUNICODE_STRING RegistryPath
    )
/*++

Routine Name:

    DoProtocolInit

Routine Description:

    This function registers the PS twice as a protocol - once for the protocol
    section of the LM and the other for the CM section.

Arguments:

    RegistryPath - pointer to our key in the registry

Return Values:

    NDIS_STATUS_BAD_CHARACTERISTICS
    NDIS_STATUS_BAD_VERSION
    NDIS_STATUS_RESOURCES
    NDIS_STATUS_SUCCESS

--*/
{
    NDIS_PROTOCOL_CHARACTERISTICS ProtocolChars;
    NDIS_STATUS                   Status;
    NDIS_STRING                   PsName = NDIS_STRING_CONST( "PSched" );

    //
    // register the client portion of the PS
    //
    NdisZeroMemory(&ProtocolChars, sizeof(NDIS_PROTOCOL_CHARACTERISTICS));
    ProtocolChars.Name.Length = PsName.Length;
    ProtocolChars.Name.Buffer = (PVOID)PsName.Buffer;

    ProtocolChars.MajorNdisVersion = 5;
    ProtocolChars.MinorNdisVersion = 0;

    ProtocolChars.OpenAdapterCompleteHandler  = ClLowerMpOpenAdapterComplete;
    ProtocolChars.CloseAdapterCompleteHandler = ClLowerMpCloseAdapterComplete;
    ProtocolChars.SendCompleteHandler         = ClSendComplete;
    ProtocolChars.TransferDataCompleteHandler = ClTransferDataComplete;
    ProtocolChars.ResetCompleteHandler        = ClResetComplete;
    ProtocolChars.RequestCompleteHandler      = ClRequestComplete;
    ProtocolChars.ReceiveHandler              = ClReceiveIndication;
    ProtocolChars.ReceiveCompleteHandler      = ClReceiveComplete;
    ProtocolChars.StatusHandler               = ClStatusIndication;
    ProtocolChars.StatusCompleteHandler       = ClStatusIndicationComplete;
    ProtocolChars.ReceivePacketHandler        = ClReceivePacket;
    ProtocolChars.BindAdapterHandler          = ClBindToLowerMp;
    ProtocolChars.UnbindAdapterHandler        = ClUnbindFromLowerMp;
    ProtocolChars.UnloadHandler               = ClUnloadProtocol;
    ProtocolChars.CoSendCompleteHandler       = ClCoSendComplete;
    ProtocolChars.CoStatusHandler             = ClCoStatus;
    ProtocolChars.CoReceivePacketHandler      = ClCoReceivePacket;
    ProtocolChars.CoAfRegisterNotifyHandler   = ClCoAfRegisterNotifyHandler;
    ProtocolChars.PnPEventHandler             = ClPnPEventHandler;

    NdisRegisterProtocol(&Status,
                         &ClientProtocolHandle,
                         &ProtocolChars,
                         sizeof(NDIS_PROTOCOL_CHARACTERISTICS) + ProtocolChars.Name.Length);

    return Status;
} // DoProtocolInit


NTSTATUS
RegisterWithGpc(
    )
/*++

Routine Name:

    RegisterWithGpc

Routine Description:

    This function initializes the Gpc and gets its list of entry points. 
    Next, it registers the PS as a client of the GPC and gets a GPC client
    handle. The PS must be a client of the GPC before it can classify packets. 

Arguments:

    GpcHandle - points to the location into which to write the handle which
    the GPC gives out to represent this client.

Return Values:

--*/
{
    NTSTATUS   Status;

    //
    // Function list for CF_INFO_QOS
    //
    GPC_CLIENT_FUNC_LIST GpcQosFuncList = {
        GpcMajorVersion,
        QosAddCfInfoComplete,
        QosAddCfInfoNotify,
        QosModifyCfInfoComplete,
        QosModifyCfInfoNotify,
        QosRemoveCfInfoComplete,
        QosRemoveCfInfoNotify,
        QosClGetCfInfoName
    };

#if CBQ
    //
    // Function List for CF_INFO_CLASS_MAP
    //
    GPC_CLIENT_FUNC_LIST GpcClassMapFuncList = {
        GpcMajorVersion,
        ClassMapAddCfInfoComplete,
        ClassMapAddCfInfoNotify,
        ClassMapModifyCfInfoComplete,
        ClassMapModifyCfInfoNotify,
        ClassMapRemoveCfInfoComplete,
        ClassMapRemoveCfInfoNotify,
        ClassMapClGetCfInfoName
    };
#endif


    Status = GpcInitialize(&GpcEntries);

    if(!NT_SUCCESS(Status))
    {
        return Status;
    }

    PsAssert(GpcEntries.GpcRegisterClientHandler);

    //
    // Register for CF_INFO_QOS
    //
    Status = GpcEntries.GpcRegisterClientHandler(GPC_CF_QOS,
    GPC_FLAGS_FRAGMENT,
    1,
    &GpcQosFuncList,
    (GPC_CLIENT_HANDLE)PS_QOS_CF,
    &GpcQosClientHandle);
        
    if (!NT_SUCCESS(Status))
    {
        GpcQosClientHandle = NULL;
        return Status;
    }

#if CBQ
    //
    // Register for the CF_INFO_CLASS_MAP 
    //
    Status = GpcEntries.GpcRegisterClientHandler(
        GPC_CF_CLASS_MAP,
        GPC_FLAGS_FRAGMENT,
        1,
        &GpcClassMapFuncList,
        (GPC_CLIENT_HANDLE)PS_CLASS_MAP_CF,
        &GpcClassMapClientHandle);
        
    if (!NT_SUCCESS(Status))
    {
        
        GpcClassMapClientHandle = NULL;

        GpcEntries.GpcDeregisterClientHandler(GpcQosClientHandle);

        GpcQosClientHandle = NULL;

        return Status;
    }
#endif

    return Status;
}


VOID
InitializationCleanup(
    ULONG ShutdownMask
    )

/*++

Routine Description:

    This routine is responsible for cleaning up all allocated resources during
    initialization

Arguments:

    ShutdownMask - A Mask that indicates the items that need to be cleaned up.

Return Values:

    None

--*/

{
    NDIS_STATUS Status;
    PPSI_INFO   PsComponent;
    PLIST_ENTRY NextProfile, NextComponent;
    PPS_PROFILE PsProfile;

    //
    // Deregister the protocol; we should have no references that would cause
    // this to pend
    //

    if(ShutdownMask & SHUTDOWN_DEREGISTER_MINIPORT){

        if(LmDriverHandle){

            NdisIMDeregisterLayeredMiniport(LmDriverHandle);
        }
    }
        
    if(ShutdownMask & SHUTDOWN_DEREGISTER_PROTOCOL){

        if(ClientProtocolHandle){

            NdisDeregisterProtocol(&Status, ClientProtocolHandle);

            if(Status != NDIS_STATUS_SUCCESS){

                PsDbgOut(DBG_CRITICAL_ERROR, 
                         DBG_INIT, 
                         ("[InitializationCleanup]: NdisDeregisterProtocol failed - Status 0x%x \n", Status));
            }
        }

    }

    //
    // Deregister with the GPC
    //

    if(ShutdownMask & SHUTDOWN_DEREGISTER_GPC){

        PsAssert(GpcEntries.GpcDeregisterClientHandler);
        Status = GpcEntries.GpcDeregisterClientHandler(GpcQosClientHandle);

        if(Status != GPC_STATUS_SUCCESS){

            PsDbgOut(DBG_CRITICAL_ERROR, 
                     DBG_INIT, 
                     ("[InitializationCleanup]: DeregisterGpc failed - Status %08X\n", 
                      Status));
        }

#if CBQ
        Status = GpcEntries.GpcDeregisterClientHandler(GpcClassMapClientHandle);

        if(Status != GPC_STATUS_SUCCESS) 
        {
            PsDbgOut(DBG_CRITICAL_ERROR, 
                     DBG_INIT, 
                     ("[InitializationCleanup]: DeregisterGpc failed - Status %08X\n", 
                      Status));
        }
#endif
    }
    
    //
    // free the lookaside list resources
    //

    NdisDeleteNPagedLookasideList( &NdisRequestLL );
    NdisDeleteNPagedLookasideList( &GpcClientVcLL );

    //
    // Free up the components
    //

    NextComponent = PsComponentList.Flink;

    while ( NextComponent != &PsComponentList ) {

        PsComponent = CONTAINING_RECORD( NextComponent, PSI_INFO, Links );

        if(PsComponent->AddIn == TRUE) {

            if(PsComponent->ComponentName.Buffer) {

                PsFreePool(PsComponent->ComponentName.Buffer);
            }

            NextComponent = NextComponent->Flink;

            PsFreePool(PsComponent);
        }
        else {

            NextComponent = NextComponent->Flink;
        }
    }

    //
    // Free up the Profiles 
    //

    NextProfile = PsProfileList.Flink;

    while( NextProfile != &PsProfileList) {

        PsProfile = CONTAINING_RECORD(NextProfile, PS_PROFILE, Links);

        if(PsProfile->ProfileName.Buffer) {
            PsFreePool(PsProfile->ProfileName.Buffer);
        }
        
        NextProfile = NextProfile->Flink;
        PsFreePool(PsProfile);

    }

    if(g_WanLinkTable)
    {
        PsFreePool(g_WanLinkTable);
    }

    if(PsMpName.Buffer)
        PsFreePool(PsMpName.Buffer);

    //
    // Free the locks
    //

    NdisFreeSpinLock(&AdapterListLock);
    NdisFreeSpinLock(&DriverUnloadLock);
    NdisFreeSpinLock(&PsComponentListLock);
    NdisFreeSpinLock(&PsProfileLock);

    //
    //  TIMESTMP CLEANUP
    //  1. Get rid of all the TS_ENTRYs. Release all the memory allocated for them.
    //  2. Delete the spin lock.
    //
    UnloadConformr();
    UnloadSequencer();
    UnloadTimeStmp();
    UnloadPsStub();


    // Free the logging stuff //
#if DBG

    SchedDeInitialize();

#endif

} // InitializationCleanup



/*++

Routine Description:

    This routine returns the timer resolution to the requesting scheduling component.

Arguments:

    TimerResolution - Pointer to location in which to return timer resolution.

Return Values:

    None

--*/
VOID
GetTimerInfo (
    OUT PULONG TimerResolution
    )

{
    // *TimerResolution = gTimerResolutionActualTime;
    *TimerResolution = 0;
} // GetTimerInfo



/*++

Routine Description:

    This routine is the driver unload routine.

Arguments:

    pDriverObject - The DriverObject that is being unloaded

Return Values:

    None

--*/

VOID PSUnload(
    IN PDRIVER_OBJECT pDriverObject)
{
    PADAPTER        Adapter;
    PLIST_ENTRY     NextAdapter;
    NDIS_STATUS     Status;

    PsDbgOut(DBG_INFO,
             DBG_INIT,
             ("[PsUnload]: pDriverObject: %x\n", pDriverObject));

    PS_LOCK(&DriverUnloadLock);

    gDriverState = DriverStateUnloading;

    PS_UNLOCK(&DriverUnloadLock);

    //
    // We wait here till all binds are complete. All future binds are rejected
    //
    NdisWaitEvent(&DriverUnloadEvent, 0);

    //
    // we don't have to close opens from the unload handler. Our call
    // to NdisDeRegisterProtocol will not return until it issues unbinds 
    //

    InitializationCleanup( 0xffffffff );

    PsDbgOut(DBG_INFO, DBG_INIT, (" Unloading psched....\n"));
    
    return;
}

/* end main.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\mpvc.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    mpvc.h

Abstract:

    defines for miniport VC handlers

Author:

    Charlie Wickham (charlwi) 13-Sep-1996

Revision History:

--*/

#ifndef _MPVC_
#define _MPVC_

/* Prototypes */

NDIS_STATUS
MpCreateVc(
    IN  NDIS_HANDLE MiniportAdapterContext,
    IN  NDIS_HANDLE NdisVcHandle,
    OUT PNDIS_HANDLE MiniportVcContext
    );

NDIS_STATUS
AddFlowToScheduler(
    IN ULONG                    Operation,
    IN PGPC_CLIENT_VC              Vc,
    IN OUT PCO_CALL_PARAMETERS  NewCallParameters,
    IN OUT PCO_CALL_PARAMETERS  OldCallParameters
    );


NDIS_STATUS
RemoveFlowFromScheduler(
    PGPC_CLIENT_VC Vc
    );

NDIS_STATUS
EmptyPacketsFromScheduler(
    PGPC_CLIENT_VC Vc
    );



NTSTATUS
ModifyBestEffortBandwidth(
    PADAPTER Adapter,
    ULONG BestEffortRate
    );

/* End Prototypes */

#endif /* _MPVC_ */

/* end vc.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\mpvc.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    mpvc.c

Abstract:

    miniport handlers for VC mgmt

Author:

    Charlie Wickham (charlwi)  13-Sep-1996
    Rajesh Sundaram (rajeshsu) 01-Aug-1998.

Environment:

    Kernel Mode

Revision History:

--*/

#include "psched.h"
#pragma hdrstop

/* External */

/* Static */

/* Forward */

NDIS_STATUS
GetSchedulerFlowContext(
    PGPC_CLIENT_VC AdapterVc
    );

NDIS_STATUS
MpDeactivateVc(
    IN  NDIS_HANDLE             MiniportVcContext
    );

HANDLE
GetNdisFlowHandle (
    IN HANDLE PsFlowContext
    );

/* End Forward */


NDIS_STATUS
AddFlowToScheduler(
    IN ULONG Operation,
    IN PGPC_CLIENT_VC Vc,
    IN OUT PCO_CALL_PARAMETERS NewCallParameters,
    IN OUT PCO_CALL_PARAMETERS OldCallParameters
    )

/*++

Routine Description:

    Add the Vc to the scheduler.

Arguments:

    See the DDK...

Return Values:

    None

--*/

{
    PADAPTER                    Adapter = Vc->Adapter;
    NDIS_STATUS                 Status = NDIS_STATUS_SUCCESS;
    PCO_CALL_MANAGER_PARAMETERS NewCmParams;
    PCO_CALL_MANAGER_PARAMETERS OldCmParams;
    SERVICETYPE                 ServiceType;
    ULONG                       ParamsLength;
    LPQOS_OBJECT_HDR            QoSObject;
    ULONG                       OriginalTokenRate;

    CheckLLTag(Vc, GpcClientVc);
    PsStructAssert(Adapter);

    PsDbgOut(DBG_TRACE, 
             DBG_VC, 
             ("(%08X) AddFlowToScheduler\n", 
             Vc));


    NewCmParams = NewCallParameters->CallMgrParameters;
    ServiceType = NewCmParams->Transmit.ServiceType;

    //
    // We might need to change the rate at which the scheduling components shape the packet.
    //
    OriginalTokenRate = NewCmParams->Transmit.TokenRate;
    NewCmParams->Transmit.TokenRate = Vc->ShapeTokenRate;

    //
    // Is this a new VC? or a modification of an existing VC?
    //

    PS_LOCK(&Adapter->Lock);

    if(Operation == NEW_VC){

        PsAssert(!OldCallParameters);

        //
        // New Vc.
        //
        // Check the type of service we're activating. If best 
        // effort and we're limiting total best effort bandwidth,
        // and it's not our internal best effort vc, then we don't 
        // want to add the flow in the scheduler.
        //


        if((ServiceType == SERVICETYPE_BESTEFFORT) &&
           (Adapter->BestEffortLimit != UNSPECIFIED_RATE) &&
           !IsBestEffortVc(Vc)){

            PS_UNLOCK(&Adapter->Lock);

            //
            // Just merge the VC into the internal, existing best 
            // effort VC. The internal best-effort VC is created 
            // internally without calling AddFlowToScheduler.
            //
            // Give this VC the same flow context as our internal. 
            // The scheduler then thinks it is all the same VC
            //

            if(Adapter->MediaType == NdisMediumWan) {

                Vc->PsFlowContext = Vc->WanLink->BestEffortVc.PsFlowContext;

            }
            else {

                Vc->PsFlowContext = Adapter->BestEffortVc.PsFlowContext;
            }

            Status = NDIS_STATUS_SUCCESS;
        }
        else{

            //
            // Need to actually create a new flow in the scheduler.
            // first allocate the flow context buffer
            //

            PS_UNLOCK(&Adapter->Lock);

            Status = GetSchedulerFlowContext(Vc);

            if(Status != NDIS_STATUS_SUCCESS){

                goto Exit;
            }

            Status = (*Vc->PsComponent->CreateFlow)(
                        Vc->PsPipeContext,
                        Vc,
                        NewCallParameters,
                        Vc->PsFlowContext);

        } 
    }
    else{

        //
        // Must be a modify. Check old params.

        OldCmParams = OldCallParameters->CallMgrParameters;

        //
        // If BestEffortLimit != UNSPECIFIED_RATE, then there
        // are two special cases we have to handle:
        //
        // 1. A non-private flow, created for SERVICETYPE_BESTEFFORT
        //      is being modified to a ServiceType other than best-effort.
        //
        // 2. A non-private flow, created for a ServiceType other 
        //      than best-effort, is now being modified to best-effort.
        //
        // In the first case, we have to call the scheduler to 
        // create a flow, since previously the client's flow was
        // just merged with a single best-effort flow.
        //
        // In the second case, we have to close the flow that existed
        // and remap the client's flow to the single best-efort flow,
        // thereby merging the client's flow with the existing b/e
        // flow.
        //

        if((Adapter->BestEffortLimit != UNSPECIFIED_RATE) &&
           (OldCmParams->Transmit.ServiceType == SERVICETYPE_BESTEFFORT) &&
           (NewCmParams->Transmit.ServiceType != SERVICETYPE_BESTEFFORT)){

            //
            // Unmerge
            //

            PS_UNLOCK(&Adapter->Lock);

            Status = GetSchedulerFlowContext(Vc);

            if(Status != NDIS_STATUS_SUCCESS){

                goto Exit;
            }

            Status = (*Vc->PsComponent->CreateFlow)(
                      Vc->PsPipeContext,
                      Vc,
                      NewCallParameters,
                      Vc->PsFlowContext);

        }
        else{

            if((Adapter->BestEffortLimit != UNSPECIFIED_RATE) &&
               (OldCmParams->Transmit.ServiceType != SERVICETYPE_BESTEFFORT) &&
               (NewCmParams->Transmit.ServiceType == SERVICETYPE_BESTEFFORT)){

                // 
                // Merge
                //

                PS_UNLOCK(&Adapter->Lock);

                (*Vc->PsComponent->DeleteFlow)( 
                          Vc->PsPipeContext, 
                          Vc->PsFlowContext);

                Vc->PsFlowContext = Adapter->BestEffortVc.PsFlowContext;

                Status = NDIS_STATUS_SUCCESS;
            }
            else{

                PS_UNLOCK(&Adapter->Lock);

                Status = (*Vc->PsComponent->ModifyFlow)(
                          Vc->PsPipeContext,
                          Vc->PsFlowContext,
                          NewCallParameters);

            }
        }

    } // Modify

Exit:

    //
    // Revert the call parameters.
    //
    NewCmParams->Transmit.TokenRate = OriginalTokenRate;

    return(Status);

} // AddFlowToScheduler 


NDIS_STATUS
GetSchedulerFlowContext(
    PGPC_CLIENT_VC AdapterVc
    )

/*++

Routine Description:

    Allocate the pipe context area for the scheduler.

Arguments:

    AdapterVc- pointer to adapter VC context struct

Return Value:

    NDIS_STATUS_SUCCESS, otherwise appropriate error value

--*/

{
    PADAPTER Adapter = AdapterVc->Adapter;
    NDIS_STATUS Status;
    PPSI_INFO *SchedulerConfig;
    PPSI_INFO PsComponent = AdapterVc->PsComponent;
    ULONG ContextLength = 0;
    ULONG FlowContextLength = 0;
    ULONG Index = 0;
    PPS_PIPE_CONTEXT PipeContext = AdapterVc->PsPipeContext;
    PPS_FLOW_CONTEXT FlowContext;
    PPS_FLOW_CONTEXT PrevContext;

    //
    // The length of the flow context buffer for this pipe was calculated
    // when the pipe was initialized.
    //

    PsAllocatePool(AdapterVc->PsFlowContext, 
                   Adapter->FlowContextLength, 
                   FlowContextTag );

    if ( AdapterVc->PsFlowContext == NULL ) {

        return NDIS_STATUS_RESOURCES;
    }

    // Set up the context buffer

    FlowContext = (PPS_FLOW_CONTEXT)AdapterVc->PsFlowContext;
    PrevContext = NULL;

    while (PsComponent != NULL) {

        FlowContext->NextComponentContext = (PPS_FLOW_CONTEXT)
            ((UINT_PTR)FlowContext + PsComponent->FlowContextLength);
        FlowContext->PrevComponentContext = PrevContext;

        PsComponent = PipeContext->NextComponent;
        PipeContext = PipeContext->NextComponentContext;

        PrevContext = FlowContext;
        FlowContext = FlowContext->NextComponentContext;
    }

    return NDIS_STATUS_SUCCESS;

} // GetSchedulerFlowContext





NDIS_STATUS
EmptyPacketsFromScheduler(
    PGPC_CLIENT_VC Vc    
    )

/*++

Routine Description:

	Cleans up (DROPS) the pending packets on this Vc in each of the components 
	
--*/

{
    PADAPTER Adapter = Vc->Adapter;
    NDIS_STATUS Status;

    CheckLLTag(Vc, GpcClientVc);
    PsStructAssert(Adapter);

    PsDbgOut(DBG_TRACE, 
             DBG_VC, 
             ("(%08X) EmptyPacketsFromScheduler\n", Vc));


    if(Adapter->MediaType == NdisMediumWan) {

        if(Vc->PsFlowContext != Vc->WanLink->BestEffortVc.PsFlowContext){
            
            //
            // Different context - definitely should be removed.
            //
            
            (*Vc->PsComponent->EmptyFlow)(Vc->PsPipeContext, 
                                           Vc->PsFlowContext);
        }
        else {
            
            //
            // Same context. Remove only if it is actually the best-effort
            // VC.
            //
            
            if(Vc == &Vc->WanLink->BestEffortVc){
                
                (*Vc->PsComponent->EmptyFlow)(Vc->PsPipeContext, 
                                               Vc->PsFlowContext);
            }
        }

    }
    else {

        if(Vc->PsFlowContext != Adapter->BestEffortVc.PsFlowContext){
            
            //
            // Different context - definitely should be removed.
            //
            
            (*Vc->PsComponent->EmptyFlow)(Vc->PsPipeContext, 
                                           Vc->PsFlowContext);
        }
        else {
            
            //
            // Same context. Remove only if it is actually the best-effort
            // VC.
            //
            
            if(Vc == &Adapter->BestEffortVc){
                
                (*Vc->PsComponent->EmptyFlow)(Vc->PsPipeContext, 
                                               Vc->PsFlowContext);
            }
        }
    }
        
    return NDIS_STATUS_SUCCESS;

} 




NDIS_STATUS
RemoveFlowFromScheduler(
    PGPC_CLIENT_VC Vc    
    )

/*++

Routine Description:

    Notify the PSA that the flow is going away

Arguments:

    See the DDK...

Return Values:

    None

--*/

{
    PADAPTER Adapter = Vc->Adapter;
    NDIS_STATUS Status;

    CheckLLTag(Vc, GpcClientVc);
    PsStructAssert(Adapter);

    PsDbgOut(DBG_TRACE, 
             DBG_VC, 
             ("(%08X) RemoveFlowFromScheduler\n", Vc));

    //
    // if this is a user vc which is merged into the scheduler's 
    // internal best effort flow, then delete the vc without affecting 
    // the scheduler. if it is not, then remove it from the scheduler
    // and delete the vc.
    //

    if(Adapter->MediaType == NdisMediumWan) {

        if(Vc->PsFlowContext != Vc->WanLink->BestEffortVc.PsFlowContext){
            
            //
            // Different context - definitely should be removed.
            //
            
            (*Vc->PsComponent->DeleteFlow)(Vc->PsPipeContext, 
                                           Vc->PsFlowContext);
        }
        else {
            
            //
            // Same context. Remove only if it is actually the best-effort
            // VC.
            //
            
            if(Vc == &Vc->WanLink->BestEffortVc){
                
                (*Vc->PsComponent->DeleteFlow)(Vc->PsPipeContext, 
                                               Vc->PsFlowContext);
            }
        }

    }
    else {

        if(Vc->PsFlowContext != Adapter->BestEffortVc.PsFlowContext){
            
            //
            // Different context - definitely should be removed.
            //
            
            (*Vc->PsComponent->DeleteFlow)(Vc->PsPipeContext, 
                                           Vc->PsFlowContext);
        }
        else {
            
            //
            // Same context. Remove only if it is actually the best-effort
            // VC.
            //
            
            if(Vc == &Adapter->BestEffortVc){
                
                (*Vc->PsComponent->DeleteFlow)(Vc->PsPipeContext, 
                                               Vc->PsFlowContext);
            }
        }
    }
        
    return NDIS_STATUS_SUCCESS;

} // RemoveFlowFromScheduler


NTSTATUS
ModifyBestEffortBandwidth(
    PADAPTER Adapter,
    ULONG BestEffortRate)
{
    PCO_CALL_PARAMETERS CallParams;
    PCO_CALL_MANAGER_PARAMETERS CallMgrParameters;
    ULONG CallParamsLength;
    PGPC_CLIENT_VC Vc;
    NDIS_STATUS Status;

    PsStructAssert(Adapter);
    Vc = &Adapter->BestEffortVc;
    CheckLLTag(Vc, GpcClientVc);
 
    //
    // This handles a TC API request to modify the default 
    // best-effort bandwidth.  Note that the b/e bandwidth 
    // can only be modified if the PS is in limited b/e mode.
    //
    // Also - note that the b/e bandwidth can only be modified 
    // while the adapter is in the Running state. We do not
    // have to worry about locking the VC since the b/e VC 
    // will not be manipulated while it is in the running state
    // except by this thread.
    //

    PS_LOCK(&Adapter->Lock);
    
    if((Adapter->BestEffortLimit == UNSPECIFIED_RATE))
    {
        PS_UNLOCK(&Adapter->Lock);
        return(STATUS_WMI_NOT_SUPPORTED);
    }

    if((BestEffortRate > Adapter->LinkSpeed) ||
       (BestEffortRate == 0)){

        PS_UNLOCK(&Adapter->Lock);
        return(STATUS_INVALID_PARAMETER);
    }
    else{

        if(Adapter->PsMpState != AdapterStateRunning){

            PS_UNLOCK(&Adapter->Lock);
            return(STATUS_WMI_NOT_SUPPORTED);
        }

        CallParamsLength = sizeof(CO_CALL_PARAMETERS) +
                           sizeof(CO_CALL_MANAGER_PARAMETERS) +
                           sizeof(QOS_SD_MODE) +
                           sizeof(QOS_OBJECT_HDR);

        PsAllocatePool(CallParams, CallParamsLength, CmParamsTag);

        if(CallParams == NULL){

            PS_UNLOCK(&Adapter->Lock);
            PsDbgOut(DBG_FAILURE, DBG_VC,
                    ("ModifyBestEffortBandwidth: can't allocate call parms\n"));

            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        //
        // build a call params struct describing the flow
        //

        CallMgrParameters = (PCO_CALL_MANAGER_PARAMETERS)(CallParams + 1);

        NdisFillMemory(CallParams,
                       CallParamsLength,
                       (UCHAR)QOS_UNSPECIFIED);

        CallParams->Flags = 0;
        CallParams->CallMgrParameters = CallMgrParameters;
        CallParams->MediaParameters = NULL;

        FillInCmParams(CallMgrParameters,
                       SERVICETYPE_BESTEFFORT,
                       BestEffortRate,
                       (ULONG)UNSPECIFIED_RATE,
                       Adapter->TotalSize,
                       TC_NONCONF_SHAPE,
                       QOS_UNSPECIFIED);

        Status = (*Vc->PsComponent->ModifyFlow)(
                  Vc->PsPipeContext,
                  Vc->PsFlowContext,
                  CallParams);

        if(Status == NDIS_STATUS_SUCCESS){

            Adapter->BestEffortLimit = BestEffortRate;
        }

        PS_UNLOCK(&Adapter->Lock);

        PsFreePool(CallParams);

        return(Status);
    }
}
        



/* end mpvc.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\ndisreq.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    ndisreq.c

Abstract:

    routines for passing NdisRequests up and down

Author:

    Charlie Wickham (charlwi)  01-May-1996.
    Rajesh Sundaram (rajeshsu) 01-Aug-1998.

Environment:

    Kernel Mode

Revision History:

--*/

#include "psched.h"

#pragma hdrstop

/* External */

/* Static */


const UCHAR  gDriverDescription[] = " (Microsoft's Packet Scheduler) ";

/* Forward */ /* Generated by Emacs 19.17.0 on Mon May 06 15:54:11 1996 */

VOID
MpQueryPnPCapabilities( 
    IN OUT PPS_NDIS_REQUEST PsReqBuffer,
    IN OUT PADAPTER         pAdapt, 
    OUT PNDIS_STATUS        pStatus
    );

NDIS_STATUS
MakeNdisRequest(
    IN  PADAPTER Adapter,
    IN  NDIS_HANDLE VcHandle,
    IN  NDIS_REQUEST_TYPE RequestType,
    IN  NDIS_OID Oid,
    IN  PVOID InformationBuffer,
    IN  ULONG InformationBufferLength,
    OUT PULONG BytesReadOrWritten,
    OUT PULONG BytesNeeded,
    LOCAL_NDISREQUEST_COMPLETION_FUNCTION CompletionFunc
    );

VOID
ClRequestComplete(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  PNDIS_REQUEST NdisRequest,
    IN  NDIS_STATUS Status
    );

NDIS_STATUS
MakeLocalNdisRequest(
    PADAPTER Adapter,
    NDIS_HANDLE VcHandle,
    NDIS_REQUEST_TYPE RequestType,
    NDIS_OID Oid,
    PVOID Buffer,
    ULONG BufferSize,
    LOCAL_NDISREQUEST_COMPLETION_FUNCTION CompletionFunc OPTIONAL
    );

NDIS_STATUS
RecordNetworkAddressList(
    IN PADAPTER Adapter,
    IN PPS_NDIS_REQUEST PsRequestBuffer
    );

ULONG
GetSizeAddrList(
    IN NETWORK_ADDRESS_LIST UNALIGNED *AddrList
    );

/* End Forward */

NTSTATUS
DoIpIoctl(
          IN  PWCHAR        DriverName,
          IN  DWORD         Ioctl,
          IN  PVOID         pvInArg,
          IN  DWORD         dwInSize,
          IN  PVOID         pvOutArg,
          IN  DWORD         dwOutSize)
/*++
Routine Description:
    Do an IOCTL to the stack. Used for a varity of purposes
--*/
{
    NTSTATUS                status;
    UNICODE_STRING          nameString;
    OBJECT_ATTRIBUTES       Atts;
    IO_STATUS_BLOCK         ioStatusBlock;
    HANDLE                  Handle;
    
    PAGED_CODE();

    RtlInitUnicodeString(&nameString, DriverName);
        
    InitializeObjectAttributes(&Atts,
                               &nameString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
             
   status = ZwCreateFile(&Handle,
                         SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                         &Atts,
                         &ioStatusBlock,
                         NULL,
                         FILE_ATTRIBUTE_NORMAL,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_OPEN_IF,
                         0,
                         NULL,
                         0);

    if (!NT_SUCCESS(status))
    {
        return STATUS_UNSUCCESSFUL;
    }
    
    //
    // Submit the request to the forwarder
    //
        
    status = ZwDeviceIoControlFile(
                      Handle,
                      NULL,
                      NULL,
                      NULL,
                      &ioStatusBlock,
                      Ioctl,
                      pvInArg,
                      dwInSize,
                      pvOutArg,
                      dwOutSize);
                      
    //
    // Close the device.
    //
    
    ZwClose(Handle);
    
    return status;
}

//
// This function uses one of the IP Addresses on the adapter to get the Interface Index of the 
// adapter. This function is called when IP updates the addresses on the interface. It uses this
// address and the IpHlpAPI and obtains the InterfaceID.
//
// For WanLinks, the InterfaceID is a set of 2 ULONGS - One identifies the InterfaceIndex as above
// and the other ULONG is the remote address of the server. 
//
//

VOID SetInterfaceIndex(PNDIS_WORK_ITEM pWorkItem, PVOID pWorkItemContext)
{
    PPS_INTERFACE_INDEX_CONTEXT        pInterfaceContext = (PPS_INTERFACE_INDEX_CONTEXT) pWorkItemContext;
    PTC_INTERFACE_ID                   pInterfaceID;
    IO_STATUS_BLOCK                    IoStatus;
    KEVENT                             LocalEvent;
    PIRP                               Irp;
    IPAddrEntry                        *pIpAddrTbl;
    ULONG                              k, OutBufferSize;
    TCP_REQUEST_QUERY_INFORMATION_EX   trqiInBuf;
    TDIObjectID                        *ID;
    DWORD                              Status, dwInBufLen, dwOutBufLen;
    BYTE                               *Context;
    ULONG                              IpAddr, IpAddrCount;
    INT                                n;
    NETWORK_ADDRESS  UNALIGNED         *pAddr;
    IPSNMPInfo                         IPSnmpInfo;

    PS_LOCK(&pInterfaceContext->Adapter->Lock);

    if(pInterfaceContext->Adapter->MediaType == NdisMediumWan)
    {
        pInterfaceID = &pInterfaceContext->WanLink->InterfaceID;
        pInterfaceID->LinkId = 0;
        IpAddr = pInterfaceContext->WanLink->LocalIpAddress;

        if(pInterfaceContext->WanLink->DialUsage != DU_CALLOUT)
            pInterfaceID->LinkId = pInterfaceContext->WanLink->RemoteIpAddress;
    }
    else 
    {
        pInterfaceID = &pInterfaceContext->Adapter->InterfaceID;
        pInterfaceID->LinkId = 0;
        pAddr = (NETWORK_ADDRESS UNALIGNED *)&pInterfaceContext->Adapter->IpNetAddressList->Address[0];

        for(n=0; n<pInterfaceContext->Adapter->IpNetAddressList->AddressCount; n++)
        {
            NETWORK_ADDRESS_IP UNALIGNED *pIpNetAddr;
    
            if(pAddr->AddressType == NDIS_PROTOCOL_ID_TCP_IP)
            {
                pIpNetAddr = (NETWORK_ADDRESS_IP UNALIGNED *)&pAddr->Address[0];
                IpAddr = pIpNetAddr->in_addr;
                break;
            }
        
            pAddr = (NETWORK_ADDRESS UNALIGNED *)(((PUCHAR)pAddr)
                                       + pAddr->AddressLength
                                       + FIELD_OFFSET(NETWORK_ADDRESS, Address));
        }

        if(n == pInterfaceContext->Adapter->IpNetAddressList->AddressCount)
        {
            PsDbgOut(DBG_FAILURE,
                     DBG_PROTOCOL,
                     ("[SetInterfaceIndex]: No Ip Addresses \n"));
            PS_UNLOCK(&pInterfaceContext->Adapter->Lock);
            goto Done;
        }

    }

    PS_UNLOCK(&pInterfaceContext->Adapter->Lock);

    //
    // Initialize parameters for sending the IO Request
    //

    ID = &(trqiInBuf.ID);
    ID->toi_entity.tei_entity   = CL_NL_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class               = INFO_CLASS_PROTOCOL;
    ID->toi_type                = INFO_TYPE_PROVIDER;
    ID->toi_id                  = IP_MIB_STATS_ID;

    Context = (BYTE *) &(trqiInBuf.Context[0]);
    NdisZeroMemory(Context,CONTEXT_SIZE);

    dwInBufLen = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    dwOutBufLen = sizeof(IPSNMPInfo);

    Status = DoIpIoctl(DD_TCP_DEVICE_NAME,
                       IOCTL_TCP_QUERY_INFORMATION_EX,
                       (PVOID) &trqiInBuf,
                       sizeof(TCP_REQUEST_QUERY_INFORMATION_EX),
                       (PVOID)&IPSnmpInfo,
                       dwOutBufLen);

    if(NT_SUCCESS(Status))
    {

        //
        // Allocate the output buffer and send the I/O request. 
        //

        IpAddrCount = IPSnmpInfo.ipsi_numaddr + 10;
        dwOutBufLen = IpAddrCount * sizeof(IPAddrEntry);
        PsAllocatePool(pIpAddrTbl, dwOutBufLen, PsMiscTag);
    
        if(!pIpAddrTbl)
        {
            PsDbgOut(DBG_FAILURE,
                     DBG_PROTOCOL,
                     ("[SetInterfaceIndex]: Could not allocate memory for %d addresses \n", 
                     IPSnmpInfo.ipsi_numaddr + 10));

            goto Done;
    
        }

        NdisZeroMemory(pIpAddrTbl, dwOutBufLen);
   
        ID->toi_type = INFO_TYPE_PROVIDER;
        ID->toi_id   = IP_MIB_ADDRTABLE_ENTRY_ID;
        RtlZeroMemory(Context, CONTEXT_SIZE); 

        Status = DoIpIoctl(DD_TCP_DEVICE_NAME,
                           IOCTL_TCP_QUERY_INFORMATION_EX,
                           (PVOID) &trqiInBuf,
                           sizeof(TCP_REQUEST_QUERY_INFORMATION_EX),
                           (PVOID)pIpAddrTbl,
                           dwOutBufLen);

        if(!NT_SUCCESS(Status))
        {

            PsDbgOut(DBG_FAILURE,
                     DBG_PROTOCOL,
                     ("[SetInterfaceIndex]: IOCTL_TCP_QUERY_INFORMATION_EX failed with 0x%x \n", Status));
    
            PsFreePool(pIpAddrTbl);
            goto Done;
        }
    }
    else 
    {
        PsDbgOut(DBG_FAILURE,
                 DBG_PROTOCOL,
                 ("[SetInterfaceIndex]: DoIpIoctl failed with 0x%x \n", Status));
        goto Done;

    }
    
    //
    // search for the matching IP address to IpAddr
    // in the table we got back from the stack
    //
    
    for (k = 0; k < IpAddrCount; k++) {
        
        if (pIpAddrTbl[k].iae_addr == IpAddr) {
            
            //
            // found one, get the index
            //

            PS_LOCK(&pInterfaceContext->Adapter->Lock);
            pInterfaceID->InterfaceId = pIpAddrTbl[k].iae_index;
            PS_UNLOCK(&pInterfaceContext->Adapter->Lock);
            break;
        }
    }
    
    PsDbgOut(DBG_INFO,
             DBG_PROTOCOL,
             ("[SetInterfaceIndex]: InterfaceID (0x%x:0x%x) \n", pInterfaceID->InterfaceId, pInterfaceID->LinkId));

    PsFreePool(pIpAddrTbl);

Done:

    if(pInterfaceContext->Adapter->MediaType == NdisMediumWan)
        REFDEL(&pInterfaceContext->WanLink->RefCount, FALSE, 'IOTL');

    REFDEL(&pInterfaceContext->Adapter->RefCount, FALSE, 'IOTL');

    PsFreePool(pWorkItem);
    PsFreePool(pWorkItemContext);

    return;
}

VOID PsScheduleInterfaceIdWorkItem(PADAPTER Adapter, PPS_WAN_LINK WanLink)
{
    PPS_INTERFACE_INDEX_CONTEXT pContext;
    NDIS_STATUS WorkItemStatus;
    PNDIS_WORK_ITEM pWorkItem;

    PsAllocatePool(pContext, sizeof(PS_INTERFACE_INDEX_CONTEXT), PsMiscTag);

    if(pContext)
    {
        PsAllocatePool(pWorkItem, sizeof(NDIS_WORK_ITEM), PsMiscTag);
        if(pWorkItem)
        {
            NdisInitializeWorkItem(pWorkItem, SetInterfaceIndex, pContext);
            pContext->Adapter = Adapter;
            pContext->WanLink = WanLink;

            // 
            // We have to make sure that the adapter and the wanlink are around when the WorkItem fires. 
            // The adapter and wanlink are valid at this point (see below), but there are no guarantees that
            // they will be around when the work item fires.
            //
            // 1. For LAN bindings, this function is called from the ClRequestComplete thread. The NDIS
            //    request has not yet been completed. Hence we can never have an invalid Adapter context here.
            //
            // 2. For WAN links, this function is called from the WAN_LINE_UP thread. Again, the WanLink
            //    cannot be invalid because it is called from the context of the line-up thread.
            //

            if(Adapter)
            {
                REFADD(&Adapter->RefCount, 'IOTL');
            }

            if(WanLink)
            {
                REFADD(&WanLink->RefCount, 'IOTL');
            }

            if((WorkItemStatus = NdisScheduleWorkItem(pWorkItem)) != NDIS_STATUS_SUCCESS)

            {
                PsDbgOut(DBG_TRACE, 
                         DBG_PROTOCOL, 
                         ("[PsScheduleInterfaceIdWorkItem]: Adapter %08X, NdisScheduleWorkItem failed 0x%x\n", 
                          Adapter, WorkItemStatus));

                if(WanLink)
                    REFDEL(&WanLink->RefCount, FALSE, 'IOTL');

                if(Adapter)
                    REFDEL(&Adapter->RefCount, FALSE, 'IOTL');

                PsFreePool(pContext);
                PsFreePool(pWorkItem);
            }
        }
        else 
        {
            PsDbgOut(DBG_TRACE, 
                     DBG_PROTOCOL, 
                     ("[PsScheduleInterfaceIdWorkItem]: Adapter %08X, No memory to allocate Work Item \n", Adapter));

            PsFreePool(pContext);
        }
    }
    else 
    {
      PsDbgOut(DBG_TRACE, 
               DBG_PROTOCOL, 
               ("[PsScheduleInterfaceIdWorkItem]: Adapter %08X, No memory to allocate Work Item context \n", Adapter));
    
    }
}


NDIS_STATUS
MakeNdisRequest(
        IN  PADAPTER                              Adapter,
        IN  NDIS_HANDLE                           VcHandle,
        IN  NDIS_REQUEST_TYPE                     RequestType,
        IN  NDIS_OID                              Oid,
        IN  PVOID                                 InformationBuffer,
        IN  ULONG                                 InformationBufferLength,
        OUT PULONG                                BytesReadOrWritten,
        OUT PULONG                                BytesNeeded,
        IN  LOCAL_NDISREQUEST_COMPLETION_FUNCTION CompletionFunc
        )

/*++

Routine Description:

    common handler for set and query  information, local ndis request, and
    corequest routines. An NDIS_REQUEST is built and issued to the underlying MP

Arguments:

    See the DDK...

    CompletionFunc - pointer to a function that gets called when the request
        completion handler has been called. Only used for local requests.

    RequestType also includes NdisRequestLocal{Set,Query}Info which is used
    to indicate a local request meaning the request is originated by the
    packet scheduler and needs no further completion

Return Values:

    return the value returned to us by the underlying adapter

--*/

{
    PPS_NDIS_REQUEST PsReqBuffer;
    NDIS_STATUS Status;

    PsAllocFromLL(&PsReqBuffer, &NdisRequestLL, NdisRequest);

    if(PsReqBuffer == NULL){
        
        if(RequestType == NdisRequestLocalQueryInfo || RequestType == NdisRequestLocalSetInfo)
        {
            PsFreePool(BytesReadOrWritten);
            PsFreePool(BytesNeeded);
        }

        return NDIS_STATUS_RESOURCES;
    }
    else 
        NdisZeroMemory(&PsReqBuffer->ReqBuffer, sizeof(NDIS_REQUEST));
        

    if(RequestType == NdisRequestSetInformation ||
       RequestType == NdisRequestLocalSetInfo){

        PsReqBuffer->ReqBuffer.RequestType = NdisRequestSetInformation;
        PsReqBuffer->LocalRequest = ( RequestType == NdisRequestLocalSetInfo );
        PsReqBuffer->ReqBuffer.DATA.SET_INFORMATION.Oid = Oid;
        PsReqBuffer->ReqBuffer.DATA.SET_INFORMATION.InformationBuffer = 
                                                        InformationBuffer;
        PsReqBuffer->ReqBuffer.DATA.SET_INFORMATION.InformationBufferLength = 
                                                        InformationBufferLength;

    }
    else{

        PsAssert(RequestType == NdisRequestQueryInformation ||
                 RequestType == NdisRequestLocalQueryInfo ||
                 RequestType == NdisRequestQueryStatistics);

        if(RequestType != NdisRequestQueryStatistics){
            PsReqBuffer->ReqBuffer.RequestType = NdisRequestQueryInformation;
            PsReqBuffer->LocalRequest = 
                        (RequestType == NdisRequestLocalQueryInfo);
        }
        else
        {
            PsReqBuffer->ReqBuffer.RequestType = NdisRequestQueryStatistics;
            PsReqBuffer->LocalRequest = 0;
        }

        PsReqBuffer->ReqBuffer.DATA.QUERY_INFORMATION.Oid = Oid;
        PsReqBuffer->ReqBuffer.DATA.QUERY_INFORMATION.InformationBuffer = 
                                                    InformationBuffer;
        PsReqBuffer->ReqBuffer.DATA.QUERY_INFORMATION.InformationBufferLength =
                                                    InformationBufferLength;

    }

    //
    // store the pointers to BytesReadOrWritten and BytesNeeded so they can be
    // updated in the completion routine if necessary. Save the completion func
    //

    PsReqBuffer->BytesReadOrWritten = BytesReadOrWritten;
    PsReqBuffer->BytesNeeded = BytesNeeded;
    PsReqBuffer->LocalCompletionFunc = CompletionFunc;

    InterlockedIncrement(&Adapter->OutstandingNdisRequests);

    if(!PsReqBuffer->LocalRequest && Adapter->PTDeviceState != NdisDeviceStateD0)
    {
        // It's not a local request, and the device is off. So, we pend this request.

        PsAssert(!VcHandle);

        PsAssert(Adapter->PendedNdisRequest == 0);

        Adapter->PendedNdisRequest = PsReqBuffer;

        return NDIS_STATUS_PENDING;
    }

    if(VcHandle) 
    {
        Status = NdisCoRequest(
                    Adapter->LowerMpHandle,
                    NULL,
                    VcHandle,
                    NULL,
                    (PNDIS_REQUEST) PsReqBuffer);

        if(Status != NDIS_STATUS_PENDING) {

            WanCoRequestComplete(Status, Adapter, NULL, NULL, (PNDIS_REQUEST)PsReqBuffer);

        }
    }
    else 
    {
        NdisRequest(&Status, Adapter->LowerMpHandle, (PNDIS_REQUEST)PsReqBuffer);


        if(Status != NDIS_STATUS_PENDING){
    
            ClRequestComplete((NDIS_HANDLE)Adapter, 
                              (PNDIS_REQUEST)PsReqBuffer, 
                              Status);
    
        }
    }

    return NDIS_STATUS_PENDING;
} // MakeNdisRequest


VOID
ClRequestComplete(
    IN  NDIS_HANDLE     ProtocolBindingContext,
    IN  PNDIS_REQUEST   NdisRequest,
    IN  NDIS_STATUS     Status
    )

/*++

Routine Description:

    Completion routine for NdisRequest. Stuff our block back on the lookaside
    list and call the appropriate completion routine

Arguments:

    See the DDK...

Return Values:

    None

--*/

{
    PADAPTER Adapter = (PADAPTER)ProtocolBindingContext;
    PPS_NDIS_REQUEST PsReqBuffer;
    NDIS_OID Oid;
    ULONG SpaceAvailable;
    PUCHAR DataStart;
    ULONG Len;
    ULONG i;
    PVOID Data;
    NDIS_STATUS OriStatus = Status;

    PsReqBuffer = CONTAINING_RECORD( NdisRequest, PS_NDIS_REQUEST, ReqBuffer );

    PsStructAssert(Adapter);

    switch(NdisRequest->RequestType)
    {
      case NdisRequestQueryInformation:
          *PsReqBuffer->BytesReadOrWritten = PsReqBuffer->ReqBuffer.DATA.QUERY_INFORMATION.BytesWritten;
          *PsReqBuffer->BytesNeeded = PsReqBuffer->ReqBuffer.DATA.QUERY_INFORMATION.BytesNeeded;
          Oid = PsReqBuffer->ReqBuffer.DATA.QUERY_INFORMATION.Oid;
          Len = PsReqBuffer->ReqBuffer.DATA.QUERY_INFORMATION.InformationBufferLength;
          Data = PsReqBuffer->ReqBuffer.DATA.QUERY_INFORMATION.InformationBuffer;

          //
          // Process the Query only OIDs here
          //
          switch(Oid)
          {
            case OID_GEN_MAXIMUM_SEND_PACKETS:
                
                //
                // see if the underlying MP supports NdisSendPackets. 
                // if not, fake it by saying we support one.
                //
          
                if(Status != NDIS_STATUS_SUCCESS)
                {
                    if(Status == NDIS_STATUS_BUFFER_TOO_SHORT ||
                       Status == NDIS_STATUS_INVALID_LENGTH) 
                    {
                        // 
                        // The underlying MP has indicated that the buffer
                        // is too short. We can assume that it supports this
                        // OID.
                    }
                    else 
                    {
                        if(Len >= 1) 
                        {
                            //
                            // The underlying MP does not support NdisSendPackets
                            // We fake it here.
                            //
                            
                            *((PULONG)PsReqBuffer->ReqBuffer.DATA.QUERY_INFORMATION.InformationBuffer)= 1;
                            *PsReqBuffer->BytesNeeded = 0;
                            *PsReqBuffer->BytesReadOrWritten = 1;
                            
                            Status = NDIS_STATUS_SUCCESS;
                        }
                        else 
                        {
                            //
                            // Buffer too short even to fake!
                            //
                            Status = NDIS_STATUS_BUFFER_TOO_SHORT;
                            *PsReqBuffer->BytesNeeded = 1;
                            *PsReqBuffer->BytesReadOrWritten = 0;
                        }
                    }
                }
                break;

            case OID_GEN_MAC_OPTIONS:
          
                //
                // if querying mac options, add full dux option.
                //
                if(Status == NDIS_STATUS_SUCCESS)
                {
                    *((PULONG)PsReqBuffer->
                      ReqBuffer.DATA.QUERY_INFORMATION.InformationBuffer) |=
                        NDIS_MAC_OPTION_FULL_DUPLEX;

                    //
                    // Remove the no-loopback bit from mac-options. In essence we are telling NDIS that we can handle loopback.
                    // We don't, but the interface below us does. If we do not do this, then the loopback processing happens below
                    // us and above us. This is wasteful at best and if netmon is running multiple packets are seen below us.
                    //
                    *(PULONG)Data &= ~NDIS_MAC_OPTION_NO_LOOPBACK;
                }
                break;
                
            case OID_GEN_CO_VENDOR_DESCRIPTION:
                
                //
                // We append some keyword to the end of the Driver
                // Description to indicate that packet scheduler is 
                // installed on this interface.
                //
                // Assume that the Data is a string followed by a 0
                // character, and the 0 is accounted for in the 
                // len.
                //
                
                if(Status == NDIS_STATUS_BUFFER_TOO_SHORT ||
                   Status == NDIS_STATUS_INVALID_LENGTH) 
                {
                    *PsReqBuffer->BytesReadOrWritten = 0;
                    *PsReqBuffer->BytesNeeded += 
                        sizeof(gDriverDescription);
                }
                else 
                {
                    if(Status == NDIS_STATUS_SUCCESS)
                    {
                        //
                        // Setup the data pointer and length to copy the 
                        // descrption into the information buffer 
                        // passed to us.
                        //
                        if(Len >= 
                         NdisRequest->DATA.QUERY_INFORMATION.BytesWritten +
                           sizeof(gDriverDescription))
                        {
                            PCHAR DescStr;
                            LONG Written = (LONG) 
                                NdisRequest->DATA.QUERY_INFORMATION.BytesWritten;
                            int i;
                            
                            
                            //
                            // Copy the original string, excluding the '0' 
                            // character
                            //
                            for(i=0, DescStr = (PCHAR) Data; 
                                (*DescStr != 0) && (i < Written); DescStr++, i++)
                                ;
                            *PsReqBuffer->BytesReadOrWritten = i;
                            
                            //
                            // Append the new string
                            //
                          for(i=0; i < sizeof(gDriverDescription); i++) 
                          {
                              *DescStr++ = gDriverDescription[i];
                          }
                          *PsReqBuffer->BytesReadOrWritten += 
                              sizeof(gDriverDescription);
                          
                          *PsReqBuffer->BytesNeeded = 0;
                        }
                        else
                        {
                            *PsReqBuffer->BytesNeeded =
                                NdisRequest->DATA.QUERY_INFORMATION.BytesWritten +
                                sizeof(gDriverDescription);
                            *PsReqBuffer->BytesReadOrWritten = 0;
                            Status = NDIS_STATUS_BUFFER_TOO_SHORT;
                        }
                    }
                    else {
                        //
                        // Upper layer failed for some reason.
                        // We can still proceed to write the data
                        //
                        if(Len >= sizeof(gDriverDescription))
                        {
                            PCHAR DescStr = (PCHAR) Data;
                            int i;
                            for(i=0; i < sizeof(gDriverDescription); i++) 
                            {
                                *DescStr++ = gDriverDescription[i];
                            }
                            
                            *PsReqBuffer->BytesReadOrWritten =
                                sizeof(gDriverDescription);
                            
                            *PsReqBuffer->BytesNeeded = 0;
                            
                            Status = NDIS_STATUS_SUCCESS;
                        }
                        else {
                            *PsReqBuffer->BytesNeeded = 
                                sizeof(gDriverDescription);
                            *PsReqBuffer->BytesReadOrWritten = 0;
                          Status = NDIS_STATUS_BUFFER_TOO_SHORT;
                        }
                    }
                }
                break;

            case OID_PNP_CAPABILITIES:
                if(Status == NDIS_STATUS_SUCCESS) 
                {
                    MpQueryPnPCapabilities(PsReqBuffer, Adapter, &Status);
                }
                break;
                
            case OID_PNP_QUERY_POWER:
                PsAssert(0);
                break;
                
                
            default:
                break;
          }
          break;

      case NdisRequestSetInformation:
          
          *PsReqBuffer->BytesReadOrWritten = PsReqBuffer->ReqBuffer.DATA.SET_INFORMATION.BytesRead;
          *PsReqBuffer->BytesNeeded = PsReqBuffer->ReqBuffer.DATA.SET_INFORMATION.BytesNeeded;
          Oid = PsReqBuffer->ReqBuffer.DATA.SET_INFORMATION.Oid;
          Len = PsReqBuffer->ReqBuffer.DATA.SET_INFORMATION.InformationBufferLength;
          Data = PsReqBuffer->ReqBuffer.DATA.SET_INFORMATION.InformationBuffer;
          
          //
          // Process the "Set Only" OIDs here
          //
          switch(Oid) 
          {
            case OID_WAN_PROTOCOL_TYPE:
            {
                if(Adapter->MediaType == NdisMediumWan)
                {
                    if (Len > 5) 
                    {
                        Adapter->ProtocolType =
                            (((PUCHAR)Data)[4] << 8) |
                            ((PUCHAR)Data)[5];
                        
                    } 
                }

                break;
            }

            case OID_GEN_TRANSPORT_HEADER_OFFSET:
            {    
                if(Len >= sizeof(TRANSPORT_HEADER_OFFSET) )
                {
                    PTRANSPORT_HEADER_OFFSET pTh = (PTRANSPORT_HEADER_OFFSET) Data;
                
                    if(pTh->ProtocolType == NDIS_PROTOCOL_ID_TCP_IP) 
                    { 
                        Adapter->IPHeaderOffset = pTh->HeaderOffset;
                    }
                }
                else
                {
                    Status = NDIS_STATUS_BUFFER_TOO_SHORT;
                    *PsReqBuffer->BytesReadOrWritten = 0;
                    *PsReqBuffer->BytesNeeded = sizeof(TRANSPORT_HEADER_OFFSET);
                }
                
                break;
            }
            
              

            case OID_GEN_NETWORK_LAYER_ADDRESSES:
                
                //
                // Updated network addresses from a transport. 
                //
                Status = RecordNetworkAddressList(Adapter, PsReqBuffer);

                //
                // Queue a work item to update the Interface ID
                //

                PsScheduleInterfaceIdWorkItem(Adapter, 0);
                
                //
                // Do a status indication to show that the list has
                // changed.
                //
                
                TcIndicateInterfaceChange(Adapter, 0, NDIS_STATUS_INTERFACE_CHANGE);
                
                break;
                
            case OID_PNP_SET_POWER:
                PsAssert(0);
                break;
                
            default:
                break;
          }
          break;

      case NdisRequestLocalQueryInfo:
          break;

      default:

          PsAssert(0);
          break;
    }

#if DBG
    switch(Oid)
    {
      case OID_GEN_MEDIA_CONNECT_STATUS:
          
          PsDbgOid(DBG_TRACE, 
                   DBG_ROUTINEOIDS, 
                   (PsReqBuffer->ReqBuffer.RequestType == NdisRequestSetInformation) 
                   ? TRACE_OID_SET_REQUEST_COMPLETE: TRACE_OID_QUERY_REQUEST_COMPLETE,
                   PsReqBuffer->LocalRequest ? 1:0,
                   Adapter->PTDeviceState,
                   Adapter->MPDeviceState,
                   Adapter,
                   Oid,
                   OriStatus);
          break;
          
      default:
          PsDbgOid(DBG_TRACE, 
                   DBG_PROTOCOL, 
                   (PsReqBuffer->ReqBuffer.RequestType == NdisRequestSetInformation) 
                   ? TRACE_OID_SET_REQUEST_COMPLETE: TRACE_OID_QUERY_REQUEST_COMPLETE,
                   PsReqBuffer->LocalRequest ? 1:0,
                   Adapter->PTDeviceState,
                   Adapter->MPDeviceState,
                   Adapter,
                   Oid,
                   OriStatus);
          break;
    }
#endif

    //
    // if the caller specified a local completion function, then call it now.
    // this function is responsible for completing the original request
    //
    
    if(PsReqBuffer->LocalCompletionFunc){

        (*PsReqBuffer->LocalCompletionFunc)(Adapter, Status);
        PsFreePool(PsReqBuffer->BytesReadOrWritten);
        PsFreePool(PsReqBuffer->BytesNeeded);
    } 
    else{
        
        //
        // if this was a PS originated request and no local completion 
        // function was specified, then set the event to indicate that 
        // the request completed. Note that the event can only be used 
        // at lowered IRQL.
        //
        if(PsReqBuffer->LocalRequest)
        {
            Adapter->FinalStatus = Status;
            NdisSetEvent( &Adapter->LocalRequestEvent);
            PsFreePool(PsReqBuffer->BytesReadOrWritten);
            PsFreePool(PsReqBuffer->BytesNeeded);
        } 
        else{

            Adapter->PendedNdisRequest = 0;

            //
            // if this is not a local request, call the 
            // appropriate NDIS completion routine
            //
            if(NdisRequest->RequestType == NdisRequestSetInformation)
            {
                NdisMSetInformationComplete(Adapter->PsNdisHandle, Status); 
            }
            else 
            {
                NdisMQueryInformationComplete(Adapter->PsNdisHandle, Status);
            }
        }
    }

    InterlockedDecrement(&Adapter->OutstandingNdisRequests);

    //
    // give back our ndis request buffer
    //

    PsFreeToLL(PsReqBuffer, &NdisRequestLL, NdisRequest);

    
} // ClRequestComplete



NDIS_STATUS
MakeLocalNdisRequest(
    PADAPTER Adapter,
    NDIS_HANDLE VcHandle,
    NDIS_REQUEST_TYPE RequestType,
    NDIS_OID Oid,
    PVOID Buffer,
    ULONG BufferSize,
    LOCAL_NDISREQUEST_COMPLETION_FUNCTION CompletionFunc OPTIONAL
    )

/*++

Routine Description:

    Make an NdisRequest to the underlying adapter on behalf of the packet scheduler

Arguments:

    Adapter and Oid should be obvious

    Buffer, BufferSize - pointer to and size of location that receives the info

    CompletionFunc - if non-null, then don't wait on the adapter's event. Used when we're
        running at dispatch level

Return Value:

    Standard NDIS_STATUS from an NdisRequest

--*/

{
    NDIS_STATUS Status;
    PULONG BytesRead, BytesNeeded;

    
    PsAssert(RequestType == NdisRequestLocalQueryInfo || RequestType == NdisRequestLocalSetInfo);

    //
    // Need to allocate space for BytesWritten & BytesNeeded because 
    // we wait only for requests that do not have a Completion Function
    // Hence the Completion function could be writing to a stale stack
    // variable
    //

    PsAllocatePool(BytesNeeded, sizeof(ULONG), PsMiscTag);

    if(!BytesNeeded) 
    {
        return NDIS_STATUS_RESOURCES;
    }

    PsAllocatePool(BytesRead,   sizeof(ULONG), PsMiscTag);

    if(!BytesRead)
    {
        PsFreePool(BytesNeeded);

        return NDIS_STATUS_RESOURCES;
    }

    Status = MakeNdisRequest(Adapter,
                             VcHandle,
                             RequestType,
                             Oid,
                             Buffer,
                             BufferSize,
                             BytesRead,
                             BytesNeeded,
                             CompletionFunc);

    //
    // only wait if no completion function has been specified
    //

    if ( !ARGUMENT_PRESENT( CompletionFunc ) && 
         Status == NDIS_STATUS_PENDING ) {

        NdisWaitEvent( &Adapter->LocalRequestEvent, 0 );
        NdisResetEvent( &Adapter->LocalRequestEvent );
        Status = Adapter->FinalStatus;
    }

    return Status;

} // MakeLocalNdisRequest


NDIS_STATUS
MpQueryInformation(
    IN  NDIS_HANDLE MiniportAdapterContext,
    IN  NDIS_OID    Oid,
    IN  PVOID       InformationBuffer,
    IN  ULONG       InformationBufferLength,
    OUT PULONG      BytesWritten,
    OUT PULONG      BytesNeeded
)
{

    PADAPTER Adapter = (PADAPTER) MiniportAdapterContext;
    PVOID    Data    = InformationBuffer;
    ULONG    Len     = InformationBufferLength;

    PsStructAssert(Adapter);

    PsAssert(Adapter->PsMpState != AdapterStateWaiting);

#if DBG
    switch(Oid)
    {
      case OID_GEN_MEDIA_CONNECT_STATUS:
          
          PsDbgOid(DBG_TRACE, 
                   DBG_ROUTINEOIDS, 
                   TRACE_OID_MP_QUERYINFORMATION,
                   0,
                   Adapter->PTDeviceState,
                   Adapter->MPDeviceState,
                   Adapter,
                   Oid,
                   0);
          break;
          
      default:
          PsDbgOid(DBG_TRACE, 
                   DBG_MINIPORT, 
                   TRACE_OID_MP_QUERYINFORMATION,
                   0,
                   Adapter->PTDeviceState,
                   Adapter->MPDeviceState,
                   Adapter,
                   Oid,
                   0);
          break;
    }
#endif

    if(Oid == OID_PNP_QUERY_POWER)
    {
        return NDIS_STATUS_SUCCESS;
    }

    if (Oid == OID_GEN_SUPPORTED_GUIDS)
    {
        //
        //  Do not forward this OID, otherwise we will end up with multiple
        //  WMI instances of private GUIDs that the underlying miniport
        //  supports.
        //
        return NDIS_STATUS_NOT_SUPPORTED;
    }

    if(Adapter->StandingBy == TRUE                    || 
       Adapter->PsMpState != AdapterStateRunning      ||
       Adapter->MPDeviceState != NdisDeviceStateD0)
    {
        return NDIS_STATUS_FAILURE;
    }

    switch(Oid)
    {
      case OID_GEN_CO_DRIVER_VERSION:
          //
          // The NDIS version in use by the NIC driver. The high byte is
          // the major version number and the low byte is the minor
          // version number. We don't need to pass this down - 
          // Irrespective of what version the driver below  uses, we 
          // need to return the version that we support.
          //
          
          if(Len < sizeof(USHORT)) 
          {
              *BytesNeeded = sizeof(USHORT);
              
              return NDIS_STATUS_BUFFER_TOO_SHORT;
              
          }
          else 
          {
              PUSHORT pData = (PUSHORT) Data;
              
              *pData = 0x0500;
              
              *BytesWritten = sizeof(USHORT);
              
              return NDIS_STATUS_SUCCESS;
          }

          break;
/*
      case OID_GEN_MAC_OPTIONS:
          //
	  // This is to indicate to NDIS that PSched always indicates recv-up in the same context
	  // of its recv-from or at DPC
          //
          
          if(Len < sizeof(ULONG)) 
          {
              *BytesNeeded = sizeof(ULONG);
              
              return NDIS_STATUS_BUFFER_TOO_SHORT;
              
          }
          else 
          {
              PULONG pData = (PULONG) Data;
              
              *pData |=  NDIS_MAC_OPTION_RECEIVE_AT_DPC;
              
              *BytesWritten = sizeof(ULONG);
              
              return NDIS_STATUS_SUCCESS;
          }

          break;

      case OID_GEN_PROTOCOL_OPTIONS:
          //
	  // This is to indicate to NDIS that PSched always sends-down packets in the same context as the
	  // send-from-above came from or at IRQL = DPC
          //
          
          if(Len < sizeof(ULONG)) 
          {
              *BytesNeeded = sizeof(ULONG);
              
              return NDIS_STATUS_BUFFER_TOO_SHORT;
              
          }
          else 
          {
              PULONG pData = (PULONG) Data;
              
              *pData |= NDIS_PROT_OPTION_SEND_RESTRICTED;
              
              *BytesWritten = sizeof(ULONG);
              
              return NDIS_STATUS_SUCCESS;
          }

          break;
*/
    }

    //
    // By default, send other requests down.
    //

    return  MakeNdisRequest(Adapter,
                            NULL,
                            NdisRequestQueryInformation,
                            Oid,
                            Data,
                            Len,
                            BytesWritten,
                            BytesNeeded,
                            NULL);
}
   

NDIS_STATUS
MpSetInformation( 
    IN  NDIS_HANDLE MiniportAdapterContext,
    IN  NDIS_OID    Oid,
    IN  PVOID       InformationBuffer,
    IN  ULONG       InformationBufferLength,
    OUT PULONG      BytesRead,
    OUT PULONG      BytesNeeded
)
{
    PADAPTER    Adapter = (PADAPTER) MiniportAdapterContext;
    NDIS_STATUS Status;

    PsStructAssert(Adapter);
    PsAssert(Adapter->PsMpState != AdapterStateWaiting);

#if DBG
    switch(Oid)
    {
      case OID_GEN_MEDIA_CONNECT_STATUS:
          
          PsDbgOid(DBG_TRACE, 
                   DBG_ROUTINEOIDS, 
                   TRACE_OID_MP_SETINFORMATION,
                   0,
                   Adapter->PTDeviceState,
                   Adapter->MPDeviceState,
                   Adapter,
                   Oid,
                   0);
          break;
          
      default:
          PsDbgOid(DBG_TRACE, 
                   DBG_MINIPORT, 
                   TRACE_OID_MP_SETINFORMATION,
                   0,
                   Adapter->PTDeviceState,
                   Adapter->MPDeviceState,
                   Adapter,
                   Oid,
                   0);
          break;
    }
#endif

    switch(Oid) 
    {
      case OID_PNP_SET_POWER:
          
          //
          // This is not transparent to us - We cannot send it down. 
          // Just succeed it!
          //
          if(InformationBufferLength >= sizeof(NDIS_DEVICE_POWER_STATE))
          {
              NDIS_DEVICE_POWER_STATE NewDeviceState = 
                  (*(PNDIS_DEVICE_POWER_STATE) InformationBuffer);
             
              //
              // If the miniport is transitioning from a low power state to ON (D0), then clear the StandingBy flag
              // All incoming requests will be pended until the physical miniport turns ON.
              //
 
              if(Adapter->MPDeviceState > NdisDeviceStateD0 && NewDeviceState == NdisDeviceStateD0)
              {
                  Adapter->StandingBy = FALSE;
              }

              //
              // Is the miniport transitioning from an On (D0) state to an Low Power State (>D0)
              // If so, then set the StandingBy Flag - (Block all incoming requests)
              //
    
              if(Adapter->MPDeviceState == NdisDeviceStateD0 && NewDeviceState > NdisDeviceStateD0)
              {
                  Adapter->StandingBy = TRUE;
              }

              // update the new device state.
              
              Adapter->MPDeviceState = NewDeviceState;
              Status                 = NDIS_STATUS_SUCCESS;
              *BytesRead             = sizeof(NDIS_DEVICE_POWER_STATE);
              *BytesNeeded           = 0;

              if(IsDeviceStateOn(Adapter) == TRUE)
              {
                  PsGetLinkSpeed(Adapter);
              }
          }
          else
          {
              Status       = NDIS_STATUS_INVALID_LENGTH;
              *BytesRead   = 0;
              *BytesNeeded = sizeof(NDIS_DEVICE_POWER_STATE);
          }
          
          return Status;
    }

    if(Adapter->StandingBy == TRUE                    || 
       Adapter->PsMpState != AdapterStateRunning      ||
       Adapter->MPDeviceState != NdisDeviceStateD0)
    {
        return NDIS_STATUS_FAILURE;
    }

    Status = MakeNdisRequest(Adapter,
                             NULL,
                             NdisRequestSetInformation,
                             Oid,
                             InformationBuffer,
                             InformationBufferLength,
                             BytesRead,
                             BytesNeeded,
                             NULL);

    return Status;
}


NDIS_STATUS
CollectNetworkAddresses(
    IN PADAPTER Adapter,
    IN OUT ULONG    *Len,
    IN PVOID    Data
    )
{
    ULONG                                 RequiredBufferSize = 0;
    ULONG                                 RequiredIpBufferSize;
    ULONG                                 RequiredIpxBufferSize;
    NETWORK_ADDRESS_LIST       UNALIGNED *NetworkAddressList;
    PTC_SUPPORTED_INFO_BUFFER             TcQueryBuffer;
    PADDRESS_LIST_DESCRIPTOR              AddressDescriptorList;
    PUCHAR                                AddressListIndex;
    NDIS_STATUS                           Status;
    NDIS_STRING                           Prefix = NDIS_STRING_CONST("\\Device\\");

    //
    // Ip address list
    //    

    PS_LOCK(&Adapter->Lock);

    if(Adapter->IpNetAddressList){

        RequiredIpBufferSize = GetSizeAddrList(Adapter->IpNetAddressList);

        //
        // Returned buffer size actually includes extra bytes for
        // address count and type. But - when we merge the lists,
        // we'll replace the separate fields. So - subtract them out.
        //

        RequiredIpBufferSize -= FIELD_OFFSET(NETWORK_ADDRESS_LIST, Address);
    }
    else{
    
        RequiredIpBufferSize = 0;
    }

    RequiredBufferSize += RequiredIpBufferSize;

    //
    // Add space for the Ipx address list
    //

    if(Adapter->IpxNetAddressList){
     
        RequiredIpxBufferSize = GetSizeAddrList(Adapter->IpxNetAddressList);

        //
        // Returned buffer size actually includes extra bytes for
        // address count and type. But - when we merge the lists,
        // we'll replace the separate fields. So - subtract them out.
        //

        RequiredIpxBufferSize -= FIELD_OFFSET(NETWORK_ADDRESS_LIST, Address);
    }
    else{

        RequiredIpxBufferSize = 0;
    }

    RequiredBufferSize += RequiredIpxBufferSize;

    //
    // Add space for the address list fields
    //

    RequiredBufferSize += FIELD_OFFSET(NETWORK_ADDRESS_LIST, Address);

    //
    // Add space for TC_SUPPORTED_INFO_BUFFER
    //
    RequiredBufferSize = RequiredBufferSize + 
        FIELD_OFFSET(TC_SUPPORTED_INFO_BUFFER, AddrListDesc) +
        FIELD_OFFSET(ADDRESS_LIST_DESCRIPTOR, AddressList);

    if(*Len > 0){

        NdisZeroMemory(Data, *Len);
    }

    if(*Len >= RequiredBufferSize){

        TcQueryBuffer = (PTC_SUPPORTED_INFO_BUFFER) Data;

        //
        // Fill in the upper binding, after striping the device 
        //
        NdisMoveMemory(TcQueryBuffer->InstanceID,
                       (PUCHAR) Adapter->MpDeviceName.Buffer + 
                       Prefix.Length,
                       Adapter->MpDeviceName.Length - Prefix.Length);
       
        TcQueryBuffer->InstanceIDLength = Adapter->MpDeviceName.Length - Prefix.Length;


        //
        // Fill in the AddressListDescriptor
        //
        AddressDescriptorList = &TcQueryBuffer->AddrListDesc;

        AddressDescriptorList->MediaType = Adapter->MediaType;

        NetworkAddressList = (NETWORK_ADDRESS_LIST UNALIGNED *)
            &AddressDescriptorList->AddressList;

        AddressListIndex = (PUCHAR)&NetworkAddressList->Address;

        if(RequiredIpBufferSize){

            NdisMoveMemory(
                AddressListIndex,
                (PUCHAR)(&Adapter->IpNetAddressList->Address),
                RequiredIpBufferSize
                );

        }

        AddressListIndex += RequiredIpBufferSize;

        if(RequiredIpxBufferSize){

            NdisMoveMemory(
                AddressListIndex,
                (PUCHAR)(&Adapter->IpxNetAddressList->Address),
                RequiredIpxBufferSize
                );
        }

        AddressListIndex += RequiredIpxBufferSize;

        if(RequiredIpBufferSize){

            NetworkAddressList->AddressCount = 
                Adapter->IpNetAddressList->AddressCount;
        }

        if(RequiredIpxBufferSize){

            NetworkAddressList->AddressCount +=
                Adapter->IpxNetAddressList->AddressCount;
        }

        NetworkAddressList->AddressType = 0;

        *Len = RequiredBufferSize;

        Status = NDIS_STATUS_SUCCESS;
    }
    else{

        *Len = RequiredBufferSize;

        Status = NDIS_STATUS_BUFFER_TOO_SHORT;
    }

    PS_UNLOCK(&Adapter->Lock);

    return(Status);
}

NDIS_STATUS
CollectWanNetworkAddresses(
    IN PADAPTER Adapter,
    IN PPS_WAN_LINK WanLink,
    IN OUT ULONG *Len,
    IN PVOID Data
    )
{
    ULONG                                RequiredBufferSize = 0;
    NETWORK_ADDRESS_LIST      UNALIGNED *NetworkAddressList;
    NETWORK_ADDRESS           UNALIGNED *NetworkAddress;
    PTC_SUPPORTED_INFO_BUFFER            TcQueryBuffer;
    PADDRESS_LIST_DESCRIPTOR             AddressDescriptorList;
    NETWORK_ADDRESS_IP        UNALIGNED *pIp;
    NDIS_STATUS                          Status;
    NDIS_STRING                          Prefix = NDIS_STRING_CONST("\\Device\\");

    PsAssert(Adapter->MediaType == NdisMediumWan);

    //
    // Ip address list
    //    

    switch(WanLink->ProtocolType)
    {

      case PROTOCOL_IP:

          if(WanLink->DialUsage == DU_CALLOUT) {

              RequiredBufferSize = FIELD_OFFSET(NETWORK_ADDRESS_LIST, Address) +
                  (FIELD_OFFSET(NETWORK_ADDRESS, Address) + NETWORK_ADDRESS_LENGTH_IP);
          }
          else {

              //
              // Include room for a pair of addresses (one local, one remote). Only for Dial in
              // or router-router links.
              //

              RequiredBufferSize = FIELD_OFFSET(NETWORK_ADDRESS_LIST, Address) +
                  2 * (FIELD_OFFSET(NETWORK_ADDRESS, Address) + 
                       NETWORK_ADDRESS_LENGTH_IP);
          }

          break;

      case PROTOCOL_IPX:
          
          //
          // Not yet supported.
          //

      default:
          
        RequiredBufferSize = 0;
    }    
    
    //
    // Add space for TC_SUPPORTED_INFO_BUFFER
    //

    RequiredBufferSize = RequiredBufferSize + 
        FIELD_OFFSET(TC_SUPPORTED_INFO_BUFFER, AddrListDesc) +
        FIELD_OFFSET(ADDRESS_LIST_DESCRIPTOR, AddressList);

    if(*Len >= RequiredBufferSize) 
    {
        TcQueryBuffer = (PTC_SUPPORTED_INFO_BUFFER) Data;

        //
        // Fill in the device name 
        //
        if(WanLink->MpDeviceName.Length > Prefix.Length)
        {
            NdisMoveMemory(TcQueryBuffer->InstanceID,
                           (PUCHAR) WanLink->MpDeviceName.Buffer + Prefix.Length,
                           WanLink->MpDeviceName.MaximumLength - Prefix.Length);
       
            TcQueryBuffer->InstanceIDLength = WanLink->MpDeviceName.Length - Prefix.Length;
        }
        else
        {
            //
            // We have got a MpDevice name that is less than \Device. What is the point in
            // stripping the \Device from this ??
            //

            PsDbgOut(DBG_FAILURE,
                     DBG_WAN,
                     ("[CollectWanNetworkAddresses]: WanLink %08X, MpDeviceName is too small to strip \\Device \n", 
                      WanLink));

            NdisMoveMemory(TcQueryBuffer->InstanceID,
                           WanLink->MpDeviceName.Buffer,
                           WanLink->MpDeviceName.MaximumLength);

            TcQueryBuffer->InstanceIDLength = WanLink->MpDeviceName.Length;

        }

        //
        // Fill in the AddressListDescriptor
        //
        AddressDescriptorList = &TcQueryBuffer->AddrListDesc;

        AddressDescriptorList->MediaType = NdisMediumWan;

        NetworkAddressList = (NETWORK_ADDRESS_LIST UNALIGNED *)
            &AddressDescriptorList->AddressList;

        NetworkAddress = (NETWORK_ADDRESS UNALIGNED *)&NetworkAddressList->Address;

        switch(WanLink->ProtocolType){

        case PROTOCOL_IP:

            NetworkAddressList->AddressType = NDIS_PROTOCOL_ID_TCP_IP;

            //
            // Fill in the local address
            //
            NetworkAddressList->AddressCount = 1;
            NetworkAddress->AddressType = NDIS_PROTOCOL_ID_TCP_IP;
            NetworkAddress->AddressLength = NETWORK_ADDRESS_LENGTH_IP;
            pIp = (NETWORK_ADDRESS_IP UNALIGNED *)NetworkAddress->Address;
            pIp->in_addr = WanLink->LocalIpAddress;
           
            //
            // Fill in the remote address only for non callout 
            //

            if(WanLink->DialUsage != DU_CALLOUT) {

                NetworkAddressList->AddressCount ++;

                NetworkAddress = (NETWORK_ADDRESS UNALIGNED *)
                    ((PCHAR)NetworkAddress + 
                     (FIELD_OFFSET(NETWORK_ADDRESS,Address)+ NETWORK_ADDRESS_LENGTH_IP));

                NetworkAddress->AddressLength = NETWORK_ADDRESS_LENGTH_IP;
                NetworkAddress->AddressType = NDIS_PROTOCOL_ID_TCP_IP;
                pIp = (NETWORK_ADDRESS_IP UNALIGNED *)NetworkAddress->Address;
                pIp->in_addr = WanLink->RemoteIpAddress;
            }

            break;

        case PROTOCOL_IPX:
        default:

            //
            // Not supported, return zero addresses.
            //

            NetworkAddressList->AddressCount = 0;
        }

        *Len = RequiredBufferSize;

        Status = NDIS_STATUS_SUCCESS;
    }
    else{

        *Len = RequiredBufferSize;

        Status = NDIS_STATUS_BUFFER_TOO_SHORT;
    }

    return(Status);
}

NDIS_STATUS
RecordNetworkAddressList(
    IN PADAPTER Adapter,
    IN PPS_NDIS_REQUEST PsReqBuffer
    )
{
    NETWORK_ADDRESS_LIST  UNALIGNED *AddressList, **pListDestination;
    ULONG NewListSize;
    ULONG OldListSize;

    PS_LOCK(&Adapter->Lock);

    AddressList = (NETWORK_ADDRESS_LIST UNALIGNED *)(PsReqBuffer->ReqBuffer.
                                DATA.SET_INFORMATION.InformationBuffer);

    //
    // Handle special case of a zero count address list. This means
    // that the protocol is clearing the address list.
    //

    if(!AddressList->AddressCount){

        //
        // In this case, we use the top level AddressType to
        // indicate the protocol.
        //

        switch(AddressList->AddressType){

        case NDIS_PROTOCOL_ID_TCP_IP:

            pListDestination = &Adapter->IpNetAddressList;
            break;

        case NDIS_PROTOCOL_ID_IPX:

            pListDestination = &Adapter->IpxNetAddressList;
            break;

        default:

            //
            // Only maintain IP and IPX addresses for now
            //
            PS_UNLOCK(&Adapter->Lock);

            return NDIS_STATUS_NOT_SUPPORTED;
        }

        (*pListDestination)->AddressType = AddressList->AddressType;
        (*pListDestination)->AddressCount = 0;

        PS_UNLOCK(&Adapter->Lock);

        return(NDIS_STATUS_SUCCESS);
    }

    //
    // We can tell from the first address type ifdentifier, whether
    // this buffer carries addresses from the IP transport or the
    // IPX transport.
    //

    switch(AddressList->Address[0].AddressType){

    case NDIS_PROTOCOL_ID_TCP_IP:

        pListDestination = &Adapter->IpNetAddressList;
        break;

    case NDIS_PROTOCOL_ID_IPX:

        pListDestination = &Adapter->IpxNetAddressList;
        break;

    default:

        //
        // Only maintain IP and IPX addresses for now
        //

        PS_UNLOCK(&Adapter->Lock);
        return NDIS_STATUS_NOT_SUPPORTED;
    }

    NewListSize = GetSizeAddrList(AddressList);
    OldListSize = GetSizeAddrList(*pListDestination);

    if(NewListSize > OldListSize){

        // 
        // Then we need a new buffer. Free the old one.
        //
        
        PsFreePool(*pListDestination);

        PsAllocatePool(*pListDestination,
                       NewListSize,
                       PsMiscTag);

        if(0 == *pListDestination)
        {
            PsDbgOut(DBG_CRITICAL_ERROR,
                     DBG_PROTOCOL,
                     ("[RecordNetworkAddressList]: Adapter %08X, "
                      "No room for Network addresses list, failed to allocate %d bytes \n",
                      Adapter, NewListSize));

            PS_UNLOCK(&Adapter->Lock);
            PsAdapterWriteEventLog(
                (ULONG)EVENT_PS_NETWORK_ADDRESS_FAIL,
                0,
                &Adapter->MpDeviceName,
                0,
                NULL);

            return NDIS_STATUS_RESOURCES;
        }
    }

    NdisMoveMemory(*pListDestination,
                   AddressList,
                   NewListSize);

    PS_UNLOCK(&Adapter->Lock);

    return NDIS_STATUS_SUCCESS;
}

ULONG
GetSizeAddrList(
    IN NETWORK_ADDRESS_LIST UNALIGNED *AddrList
    )
{
    NETWORK_ADDRESS UNALIGNED *NextAddress;
    LONG i;
    ULONG ListSize = 0;
    ULONG ElementSize = 0;

    if(!AddrList->AddressCount){

        return(FIELD_OFFSET(NETWORK_ADDRESS_LIST, Address));
    }

    NextAddress = &(AddrList->Address[0]);

    for(i = 0;i < AddrList->AddressCount; i++){

        // 
        // Each address element is the number of bytes
        // indicated by AddressLength plus the size of
        // a NETWORK_ADDRESS structure, minus the one 
        // byte used for the adress array (see struct).
        //

        ElementSize = FIELD_OFFSET(NETWORK_ADDRESS, Address);
        ElementSize += NextAddress->AddressLength;

        ListSize += ElementSize;

        NextAddress = (NETWORK_ADDRESS UNALIGNED *)
                    ((PUCHAR)NextAddress + ElementSize);

        ElementSize = 0;
    }

    //
    // Add the AddressCount size
    //

    ListSize += FIELD_OFFSET(NETWORK_ADDRESS_LIST, Address);

    return(ListSize);
}

VOID
TcIndicateInterfaceChange(
    IN PADAPTER Adapter,
    IN PPS_WAN_LINK WanLink,
    IN NDIS_STATUS Status
    )
{
    ULONG                       AddrLen = 0;
    ULONG                       DataLen;
    PTC_INDICATION_BUFFER       Data;

    PsAssert((Status == NDIS_STATUS_INTERFACE_UP) || (Status == NDIS_STATUS_INTERFACE_DOWN) ||
             (Status == NDIS_STATUS_INTERFACE_CHANGE));

    if(Adapter->MediaType == NdisMediumWan) 
    {

        if(WanLink) {

            CollectWanNetworkAddresses(Adapter, WanLink, &AddrLen, NULL);

            DataLen = AddrLen + FIELD_OFFSET(TC_INDICATION_BUFFER, InfoBuffer);
        
            PsAllocatePool(Data, DataLen, PsMiscTag);
            
            if(Data){
                
                Data->SubCode = 0;
                
                CollectWanNetworkAddresses(Adapter, WanLink, &AddrLen, &Data->InfoBuffer);
            
                PsTcNotify(Adapter, WanLink, Status, Data, DataLen);

                PsFreePool(Data);
            }
        }
        
    }
    else {
        
        
        CollectNetworkAddresses(Adapter, &AddrLen, NULL);
        
        DataLen = AddrLen + FIELD_OFFSET(TC_INDICATION_BUFFER, InfoBuffer);
        
        PsAllocatePool(Data, DataLen, PsMiscTag);
        
        if(Data){
            
            Data->SubCode = 0;
            
            CollectNetworkAddresses(Adapter, &AddrLen, &Data->InfoBuffer);
        
            PsTcNotify(Adapter, 0, Status, Data, DataLen);

            PsFreePool(Data);
        }
    }

    return;
}

VOID
MpQueryPnPCapabilities( 
    IN OUT PPS_NDIS_REQUEST PsReqBuffer,
    IN OUT PADAPTER         pAdapt, 
    OUT PNDIS_STATUS        pStatus
    )

/*++

Routine Description:

        Miniport QueryInfo OID_PNP_CAPAIBILITIES:
        If the Oid == Oid_PNP_CAPABILITIES, InformationBuffer is returned with all the fields
        assigned NdisDeviceStateUnspecified in the NDIS_PM_WAKE_UP_CAPABILITIES structure

        OID_QUERY_POWER_STATE is returned with NDIS_STATUS_SUCCESS and should never be passed below.

Arguments:

        MiniportAdapterContext  Pointer to the adapter structure
        Oid                                             Oid for this query
        InformationBuffer               Buffer for information
        InformationBufferLength Size of this buffer
        BytesWritten                    Specifies how much info is written
        BytesNeeded                             In case the buffer is smaller than what we need, tell them how much is needed

Return Value:

        Return code from the NdisRequest below.

--*/

{

    PNDIS_PNP_CAPABILITIES         pPNPCapabilities;  
    PNDIS_PM_WAKE_UP_CAPABILITIES  pPMstruct;
    
    if (PsReqBuffer->ReqBuffer.DATA.QUERY_INFORMATION.InformationBufferLength 
        >= sizeof(NDIS_PNP_CAPABILITIES) )
    {
        
        pPNPCapabilities  = (PNDIS_PNP_CAPABILITIES)
            (PsReqBuffer->ReqBuffer.DATA.QUERY_INFORMATION.InformationBuffer );
        
        //
        // Setting up the buffer to be returned to the Protocol above the SampleIM
        //
        pPMstruct= &pPNPCapabilities->WakeUpCapabilities;
        
        pPMstruct->MinMagicPacketWakeUp = NdisDeviceStateUnspecified;
        pPMstruct->MinPatternWakeUp     = NdisDeviceStateUnspecified;
        pPMstruct->MinLinkChangeWakeUp  = NdisDeviceStateUnspecified;
        
        *PsReqBuffer->BytesReadOrWritten = sizeof(NDIS_PNP_CAPABILITIES );
        *PsReqBuffer->BytesNeeded        = 0;
        
        
        //
        // Setting our internal flags
        // Default, device is  ON
        //
        
        pAdapt->PTDeviceState = NdisDeviceStateD0;      
        pAdapt->MPDeviceState = NdisDeviceStateD0;      
        
        *pStatus           = NDIS_STATUS_SUCCESS; 

        //
        // We could have received some status indications when we were in DeviceState > D0. 
        // Now is the time to look at them again. 
        //
        PsGetLinkSpeed(pAdapt);
    }
    else 
    {
        *PsReqBuffer->BytesNeeded = sizeof(NDIS_PNP_CAPABILITIES);
        
        *pStatus = NDIS_STATUS_RESOURCES;
    }
    
}


#if DBG
VOID
IndicateLogThreshold(
    IN PVOID Context 
    )
{
    PADAPTER Adapter = (PADAPTER)Context;

    ULONG BytesUnread = SchedtGetBytesUnread();

    NdisMCoIndicateStatus(Adapter->PsNdisHandle,
                          NULL,
                          QOS_STATUS_LOG_THRESHOLD,
                          &BytesUnread,
                          sizeof(ULONG));
}
#endif
/* end ndisreq.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\ndisreq.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    ndisreq.h

Abstract:

    defines for NdisRequest related routines

Author:

    Charlie Wickham (charlwi) 01-May-1996

Revision History:

--*/

#ifndef _NDISREQ_
#define _NDISREQ_

//
// Private OIDs that are used by psched
//

#define NDIS_STATUS_INTERFACE_CHANGE                0xFF000001

#if DBG
#define OID_QOS_LOG_BUFFER_SIZE                     0xFF010100
#define OID_QOS_LOG_THRESHOLD                       0xFF010101
#define OID_QOS_LOG_DATA                            0xFF010102
#define OID_QOS_LOG_MASK                            0xFF010105
#define OID_QOS_LOG_LEVEL                           0xFF010106
#define QOS_STATUS_LOG_THRESHOLD                    0xFF00000A
#endif

#define OID_QOS_MAX_OUTSTANDING_SENDS               0xFF010103
#define OID_QOS_DISABLE_DRR                         0xFF010104

/* Prototypes */ /* Generated by Emacs 19.17.0 on Mon May 06 15:54:14 1996 */

VOID
PsScheduleInterfaceIdWorkItem(
    IN PADAPTER     Adapter,
    IN PPS_WAN_LINK WanLink
    );

VOID
ClRequestComplete(
    IN  NDIS_HANDLE     ProtocolBindingContext,
    IN  PNDIS_REQUEST   NdisRequest,
    IN  NDIS_STATUS     Status
    );

NDIS_STATUS
MakeLocalNdisRequest(
    PADAPTER Adapter,
    NDIS_HANDLE VcHandle,
    NDIS_REQUEST_TYPE RequestType,
    NDIS_OID Oid,
    PVOID Buffer,
    ULONG BufferSize,
    LOCAL_NDISREQUEST_COMPLETION_FUNCTION CompletionFunc OPTIONAL
    );


NDIS_STATUS
MpQueryInformation(
    IN  NDIS_HANDLE MiniportAdapterContext,
    IN  NDIS_OID    Oid,
    IN  PVOID       InformationBuffer,
    IN  ULONG       InformationBufferLength,
    OUT PULONG      BytesWritten,
    OUT PULONG      BytesNeeded
    );


NDIS_STATUS
MpSetInformation( 
    IN  NDIS_HANDLE MiniportAdapterContext,
    IN  NDIS_OID    Oid,
    IN  PVOID       InformationBuffer,
    IN  ULONG       InformationBufferLength,
    OUT PULONG      BytesRead,
    OUT PULONG      BytesNeeded
    );

VOID
TcIndicateInterfaceChange(
    IN PADAPTER Adapter,
    IN PPS_WAN_LINK WanLink,
    IN NDIS_STATUS Status
    );

NDIS_STATUS
CollectWanNetworkAddresses(
    IN PADAPTER Adapter,
    IN PPS_WAN_LINK WanLink,
    IN OUT ULONG *Len,
    IN PVOID Data);


NDIS_STATUS
CollectNetworkAddresses(
    IN PADAPTER Adapter,
    IN OUT ULONG *Len,
    IN PVOID Data
    );

#if DBG
VOID
IndicateLogThreshold(
    IN PVOID Context
    );
#endif
/* End Prototypes */

#endif /* _NDISREQ_ */

/* end ndisreq.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\psched.h ===
/*++

Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

    psched.h

Abstract:



Author:

    Charlie Wickham (charlwi) 22-Apr-1996

Revision History:

--*/

#ifndef _PSCHED_
#define _PSCHED_

#include <ntosp.h>
#include <windef.h>

#include <ndis.h>
#include <zwapi.h>
#include <ndis.h>
#include <ntddndis.h>
#include <wmistr.h>

#include <traffic.h>
#include <tcerror.h>
#include <gpcifc.h>
#include <ntddtc.h>

#include <cxport.h>
#include <ip.h>

#include "osdep.h"
#include "stdlib.h"
#include "stdio.h"
#include "stdarg.h"


typedef unsigned char       BYTE,  *PBYTE;
typedef unsigned long       DWORD, *PDWORD;
#include <llinfo.h>
#include <ddwanarp.h>
#include <ntddip.h>
#include <ipinfo.h>
#include <tdiinfo.h>
#include <ntddtcp.h>
#include "refcnt.h"
#include "ntddpsch.h"
#include "debug.h"      // order dependent
#include "pktsched.h"
#include "globals.h"
#include "main.h"
#include "adapter.h"
#include "ndisreq.h"
#include "send.h"
#include "recv.h"
#include "config.h"
#include "stats.h"
#include "status.h"
#include "mpvc.h"
#include "cmvc.h"
#include "pstub.h"
#include "schedt.h"
#include "Conformr.h"
#include "drrSeq.h"
#include "psstub.h"
#include "gpchndlr.h"
#include "wansup.h"
#include "clstate.h"
#include "wmi.h"
#include "timestmp.h"

/* Prototypes */
/* End Prototypes */

#endif /* _PSCHED_ */

/* end psched.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\psstub.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    PsStub.h

Abstract:

    Defines for scheduling stub

Author:


Revision History:

--*/

#ifndef _PSSTUB_H_
#define _PSSTUB_H_

#include "PktSched.h"

VOID
InitializeSchedulerStub(
    PPSI_INFO Info);

void
UnloadPsStub();

#endif /* _PSSTUB_H_ */

/* end PsStub.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\pstub.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    pstub.c

Abstract:

    Stubs for protocol routines

Author:

    Charlie Wickham (charlwi)  22-Apr-1996
    Rajesh Sundaram (rajeshsu) 01-Aug-1998.

Environment:

    Kernel Mode

Revision History:

--*/

#include "psched.h"

#pragma hdrstop

/* External */

/* Static */

/* Forward */ /* Generated by Emacs 19.17.0 on Wed May 08 10:48:06 1996 */

VOID
ClResetComplete(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS Status
    );

/* End Forward */

NDIS_STATUS
ClPnPEventHandler(
    IN NDIS_HANDLE Handle,
    IN PNET_PNP_EVENT NetPnPEvent
    )
{
    PADAPTER                 Adapter     = (PADAPTER) Handle;
    PNDIS_DEVICE_POWER_STATE DeviceState = (PNDIS_DEVICE_POWER_STATE) (NetPnPEvent->Buffer);
    NDIS_DEVICE_POWER_STATE  PrevDeviceState;
    NDIS_STATUS              PnPStatus, Status;
    ULONG                    Count;

    PnPStatus = NDIS_STATUS_SUCCESS;
    
    switch(NetPnPEvent->NetEvent)
    {
      case NetEventSetPower:

        PsStructAssert(Adapter);
        PrevDeviceState        = Adapter->PTDeviceState;
        Adapter->PTDeviceState = *DeviceState;
        
        //
        // if we are being sent to standby, block outstanding requests and sends
        //

        if(*DeviceState > NdisDeviceStateD0)
        {
            //
            // For state transistion to > D0, we have to pass the request up before doing anything.
            //

            if(Adapter->PsNdisHandle)
            {
                PnPStatus = NdisIMNotifyPnPEvent(Adapter->PsNdisHandle, NetPnPEvent);
            }

            //
            // If the physical miniport is going to standby, fail all incoming requests.
            //

            if(PrevDeviceState == NdisDeviceStateD0)
            {
                Adapter->StandingBy = TRUE;
            }

            // 
            // Wait till Oustanding IO on the binding completes. 
            //
            do
            {
                Status = NdisQueryPendingIOCount(Adapter->LowerMpHandle, &Count);

                if(Status == NDIS_STATUS_SUCCESS && Count != 0)
                {
                    NdisMSleep(10);
                }
                else 
                {
                    break;
                }

            } while(TRUE);

            PsAssert(Adapter->OutstandingNdisRequests == 0);
        }
        else 
        {
            //
            // If the physical miniport is powering up (from low power state to D0), clear the flag.
            //

            if(PrevDeviceState > NdisDeviceStateD0)
            {
                Adapter->StandingBy = FALSE;
            }

            // This is where we originate the pended ndis requests.
            if(Adapter->PendedNdisRequest)
            {
                PNDIS_REQUEST PendedRequest = (PNDIS_REQUEST)Adapter->PendedNdisRequest;
                Adapter->PendedNdisRequest = NULL;

                NdisRequest(&Status, Adapter->LowerMpHandle, PendedRequest);
                if(NDIS_STATUS_PENDING != Status)
                {
                    ClRequestComplete(Adapter, PendedRequest, Status);
                }
            }
    
            // Update link speed.
            if(IsDeviceStateOn(Adapter))
            {
                PsGetLinkSpeed(Adapter);
            }

            //
            // For state transistion to D0, we have to pass the request after doing our work.
            //

            if(Adapter->PsNdisHandle) 
            {
                PnPStatus = NdisIMNotifyPnPEvent(Adapter->PsNdisHandle, NetPnPEvent);
            }

        }

        break;

      case NetEventReconfigure:

        if(Adapter == NULL)
        {
            NdisReEnumerateProtocolBindings(ClientProtocolHandle);
        }
        else 
        {
            //
            // For all other events, pass the request before doing anything.
            //
            if(Adapter->PsNdisHandle)
            {
                PnPStatus = NdisIMNotifyPnPEvent(Adapter->PsNdisHandle, NetPnPEvent);
            }
        }

        break;

      default:    

        //
        // For all other events, pass the request before doing anything.
        //

        if(Adapter && Adapter->PsNdisHandle) 
        {
            PnPStatus = NdisIMNotifyPnPEvent(Adapter->PsNdisHandle, NetPnPEvent);
        }
        break;
    }

    return(PnPStatus);
}

VOID
ClResetComplete(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS Status
    )

/*++

Routine Description:

    Completion routine for NdisReset

Arguments:

    See the DDK...

Return Values:

    None

--*/

{
    PADAPTER Adapter = (PADAPTER)ProtocolBindingContext;

    PsStructAssert( Adapter );

    PsDbgOut(DBG_TRACE, DBG_PROTOCOL, ("(%08X) ClResetComplete: Status = %08x\n",
                                       Adapter, Status));
}

VOID
ClCoStatus(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_HANDLE ProtocolVcContext OPTIONAL,
    IN  NDIS_STATUS GeneralStatus,
    IN  PVOID StatusBuffer,
    IN  UINT StatusBufferSize
    )
{
    PsDbgOut(DBG_TRACE,
             DBG_PROTOCOL,
             ("(%08X) PcStatusIndication: %08X\n",
              ProtocolBindingContext, GeneralStatus));

    return;
}


VOID
ClCoAfRegisterNotifyHandler(
        IN      NDIS_HANDLE                             ProtocolBindingContext,
        IN      PCO_ADDRESS_FAMILY              AddressFamily
        )
{
    PADAPTER Adapter = (PADAPTER)ProtocolBindingContext;

    PsStructAssert( Adapter );

    if(AddressFamily->AddressFamily == CO_ADDRESS_FAMILY_PPP)
    {
        OpenWanAddressFamily(Adapter, AddressFamily);
    }

}

/* end pstub.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\pstub.h ===
/*++

Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

    pstub.h

Abstract:

    defines for protocol stub routines

Author:

    Charlie Wickham (charlwi) 22-Apr-1996

Revision History:

--*/

#ifndef _PSTUB_
#define _PSTUB_

/* Prototypes */ /* Generated by Emacs 19.17.0 on Wed May 08 10:48:08 1996 */

/*++

Routine Description:

    Completion routine for NdisReset
Arguments:

    See the DDK...

Return Values:

    None

--*/

NDIS_STATUS
ClPnPEventHandler(
    IN NDIS_HANDLE Handle,
    IN PNET_PNP_EVENT NetPnPEvent
    );

VOID
ClResetComplete(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS Status
    );

VOID
ClCoStatus(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_HANDLE ProtocolVcContext OPTIONAL,
    IN  NDIS_STATUS GeneralStatus,
    IN  PVOID StatusBuffer,
    IN  UINT StatusBufferSize
    );

VOID
ClCoAfRegisterNotifyHandler(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	PCO_ADDRESS_FAMILY		AddressFamily);

/* End Prototypes */

#endif /* _PSTUB_ */

/* end pstub.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\psstub.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    PsStub.c

Abstract:

    Scheduler stub.  This module is the terminating module in the
    scheduling component stack.  It just forwards packets on to the
    lower MP.

Author:


Environment:

    Kernel Mode

Revision History:

--*/

#include "psched.h"

#pragma hdrstop

// The stub's pipe information

typedef struct _PSSTUB_PIPE 
{
    // ContextInfo -    Generic context info
    // Adapter -        Pointer to adapter struct

    PS_PIPE_CONTEXT         ContextInfo;
    PADAPTER                Adapter;
    PSU_SEND_COMPLETE       SendComplete;
    PPS_PIPE_CONTEXT        SendCompletePipeContext;
    

} PSSTUB_PIPE, *PPSSTUB_PIPE;

// The stub's flow information

typedef struct _PSSTUB_FLOW {

    // ContextInfo -            Generic context info
    // AdapterVc -              Pointer to adapter VC struct

    PS_FLOW_CONTEXT ContextInfo;
    PGPC_CLIENT_VC AdapterVc;
} PSSTUB_FLOW, *PPSSTUB_FLOW;


/* External */

/* Static */

/* Forward */

NDIS_STATUS
PsStubInitializePipe (
    IN HANDLE PsPipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters,
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_PROCS PsProcs,
    IN PPS_UPCALLS Upcalls
    );

NDIS_STATUS
PsStubModifyPipe (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters
    );

VOID
PsStubDeletePipe (
    IN PPS_PIPE_CONTEXT PipeContext
    );

NDIS_STATUS
PsStubCreateFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsFlowContext,
    IN PCO_CALL_PARAMETERS CallParameters,
    IN PPS_FLOW_CONTEXT ComponentFlowContext
    );

NDIS_STATUS
PsStubModifyFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PCO_CALL_PARAMETERS CallParameters
    );

VOID
PsStubDeleteFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext
    );

VOID
PsStubEmptyFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext
    );    

NDIS_STATUS 
PsStubCreateClassMap (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsClassMapContext,
    IN PTC_CLASS_MAP_FLOW ClassMap,
    IN PPS_CLASS_MAP_CONTEXT ComponentClassMapContext);

NDIS_STATUS 
PsStubDeleteClassMap (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_CLASS_MAP_CONTEXT ComponentClassMapContext);

BOOLEAN
PsStubSubmitPacket (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PPS_CLASS_MAP_CONTEXT ClassMapContext,
    IN PPACKET_INFO_BLOCK Packet
    );

VOID
PsStubSetInformation (
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_FLOW_CONTEXT ComponentFlowContext,
    IN NDIS_OID Oid,
    IN ULONG Len,
    IN PVOID Data);

VOID
PsStubQueryInformation (
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_FLOW_CONTEXT ComponentFlowContext,
    IN NDIS_OID Oid,
    IN ULONG Len,
    IN PVOID Data,
    IN OUT PULONG BytesWritten,
    IN OUT PULONG BytesNeeded,
    IN OUT PNDIS_STATUS Status);

/* End Forward */


VOID
InitializeSchedulerStub(
    PPSI_INFO Info)

/*++

Routine Description:

    Initialization routine for the stub.  This routine just
    fills in the PSI_INFO struct and returns.

Arguments:

    Info - Pointer to component interface info struct

Return Values:

    NDIS_STATUS_SUCCESS

--*/
{
    Info->PipeContextLength     = sizeof(PSSTUB_PIPE);
    Info->FlowContextLength     = sizeof(PSSTUB_FLOW);
    Info->ClassMapContextLength = sizeof(PS_CLASS_MAP_CONTEXT);
    Info->InitializePipe        = PsStubInitializePipe;
    Info->ModifyPipe            = PsStubModifyPipe;
    Info->DeletePipe            = PsStubDeletePipe;
    Info->CreateFlow            = PsStubCreateFlow;
    Info->ModifyFlow            = PsStubModifyFlow;
    Info->DeleteFlow            = PsStubDeleteFlow;
    Info->EmptyFlow             = PsStubEmptyFlow;
    Info->CreateClassMap        = PsStubCreateClassMap;
    Info->DeleteClassMap        = PsStubDeleteClassMap;
    Info->SubmitPacket          = PsStubSubmitPacket;
    Info->ReceivePacket         = NULL;
    Info->ReceiveIndication     = NULL;
    Info->SetInformation        = PsStubSetInformation;
    Info->QueryInformation      = PsStubQueryInformation;

} // InitializeSchedulerStub



// 
//  Unload routine: currently do nothing
//
void
UnloadPsStub()
{

}



VOID
CleanupSchedulerStub(
    VOID)

/*++

Routine Description:

    Cleanup routine for stub.

Arguments:

Return Values:

    NDIS_STATUS_SUCCESS

--*/
{
} // CleanupSchedulerStub



NDIS_STATUS
PsStubInitializePipe (
    IN HANDLE              PsPipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters,
    IN PPS_PIPE_CONTEXT    ComponentPipeContext,
    IN PPS_PROCS           PsProcs,
    IN PPS_UPCALLS         Upcalls
    )

/*++

Routine Description:

    Pipe initialization routine for stub.

Arguments:

    PsPipeContext -         PS pipe context value
    PipeParameters -        Pointer to pipe parameters
    ComponentPipeContext -  Pointer to this component's context area
    PsProcs -               PS's support routines
    Upcalls -               Previous component's upcall table

Return Values:

    NDIS_STATUS_SUCCESS

--*/
{
    PPSSTUB_PIPE Pipe = (PPSSTUB_PIPE)ComponentPipeContext;

    Pipe->Adapter = (PADAPTER)PsPipeContext;

    if (Upcalls != NULL) {
        Pipe->SendComplete = Upcalls->SendComplete;
        Pipe->SendCompletePipeContext = Upcalls->PipeContext;
    }
    else {
        Pipe->SendComplete = NULL;
    }

    return NDIS_STATUS_SUCCESS;

} // PsStubInitializePipe



NDIS_STATUS
PsStubModifyPipe (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters
    )

/*++

Routine Description:

    Pipe parameter modification routine for stub.

Arguments:

    PipeContext -       Pointer to this component's pipe context area
    PipeParameters -    Pointer to pipe parameters

Return Values:

    NDIS_STATUS_SUCCESS

--*/
{
    PPSSTUB_PIPE Pipe = (PPSSTUB_PIPE)PipeContext;

    return NDIS_STATUS_SUCCESS;

} // PsStubModifyPipe



VOID
PsStubDeletePipe (
    IN PPS_PIPE_CONTEXT PipeContext
    )

/*++

Routine Description:

    Pipe removal routine for stub.

Arguments:

    PipeContext -   Pointer to this component's pipe context area

Return Values:

--*/
{

} // PsStubDeletePipe



NDIS_STATUS
PsStubCreateFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsFlowContext,
    IN PCO_CALL_PARAMETERS CallParameters,
    IN PPS_FLOW_CONTEXT ComponentFlowContext
    )

/*++

Routine Description:

    Flow creation routine for stub.

Arguments:

    PipeContext -           Pointer to this component's pipe context area
    PsFlowContext -         PS flow context value
    CallParameters -        Pointer to call parameters for flow
    ComponentFlowContext -  Pointer to this component's flow context area

Return Values:

    NDIS_STATUS_SUCCESS

--*/
{
    PPSSTUB_PIPE Pipe = (PPSSTUB_PIPE)PipeContext;
    PPSSTUB_FLOW Flow = (PPSSTUB_FLOW)ComponentFlowContext;

    Flow->AdapterVc = (PGPC_CLIENT_VC)PsFlowContext;

    Flow->AdapterVc->SendComplete            = Pipe->SendComplete;
    Flow->AdapterVc->SendCompletePipeContext = Pipe->SendCompletePipeContext;

    return NDIS_STATUS_SUCCESS;

} // PsStubCreateFlow



NDIS_STATUS
PsStubModifyFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PCO_CALL_PARAMETERS CallParameters
    )

/*++

Routine Description:

    Flow modification routine for stub.

Arguments:

    PipeContext -       Pointer to this component's pipe context area
    FlowContext -       Pointer to this component's flow context area
    CallParameters -    Pointer to call parameters for flow

Return Values:

    NDIS_STATUS_SUCCESS

--*/
{
    return NDIS_STATUS_SUCCESS;

} // PsStubModifyFlow



VOID
PsStubDeleteFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext
    )

/*++

Routine Description:

    Flow removal routine for token bucket conformer.

Arguments:

    PipeContext -       Pointer to this component's pipe context area
    FlowContext -       Pointer to this component's flow context area

Return Values:

--*/
{

} // PsStubDeleteFlow


VOID
PsStubEmptyFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext
    )
{

}


NDIS_STATUS 
PsStubCreateClassMap (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsClassMapContext,
    IN PTC_CLASS_MAP_FLOW ClassMap,
    IN PPS_CLASS_MAP_CONTEXT ComponentClassMapContext)
{
    return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS 
PsStubDeleteClassMap (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_CLASS_MAP_CONTEXT ComponentClassMapContext)
{
    return NDIS_STATUS_SUCCESS;
}


BOOLEAN
PsStubSubmitPacket (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PPS_CLASS_MAP_CONTEXT ClassMapContext,
    IN PPACKET_INFO_BLOCK PacketInfo
    )

/*++

Routine Description:

    Packet submission routine for stub.

Arguments:

    PipeContext -   Pointer to this component's pipe context area
    FlowContext -   Pointer to this component's flow context area
    Packet -        Pointer to packet

Return Values:

    NDIS_ATATUS_SUCCESS

--*/
{
    PPSSTUB_FLOW             Flow = (PPSSTUB_FLOW)FlowContext;
    PGPC_CLIENT_VC           AdapterVc = Flow->AdapterVc;
    PADAPTER                 Adapter = AdapterVc->Adapter;
    PPS_SEND_PACKET_CONTEXT  PktContext;
    LARGE_INTEGER            PacketLength;
    PNDIS_PACKET             Packet = PacketInfo->NdisPacket;

    PktContext            = CONTAINING_RECORD(PacketInfo, PS_SEND_PACKET_CONTEXT, Info);
    PacketLength.QuadPart = (LONGLONG)PktContext->Info.PacketLength;

    //
    // update flow stats
    //

    AdapterVc->Stats.BytesTransmitted.QuadPart += PacketLength.QuadPart;
    
    AdapterVc->Stats.PacketsTransmitted ++;


    if(Adapter->MediaType != NdisMediumWan)
    {
        NdisSendPackets(Adapter->LowerMpHandle, &Packet, 1);
    }
    else{
        
        //
        // If it didn't have a VC, we wouldn't have called
        // through the PS.
        //

        if(AdapterVc->NdisWanVcHandle)
        {
            NdisCoSendPackets(AdapterVc->NdisWanVcHandle,
                              &Packet,
                              1);
        }
        else 
        {
            NdisSendPackets(Adapter->LowerMpHandle,
                            &Packet,
                            1);
        }
    }

    return TRUE;

} // PsStubSubmitPacket


VOID
PsStubSetInformation (
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_FLOW_CONTEXT ComponentFlowContext,
    IN NDIS_OID Oid,
    IN ULONG Len,
    IN PVOID Data)
{
}


VOID
PsStubQueryInformation (
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_FLOW_CONTEXT ComponentFlowContext,
    IN NDIS_OID Oid,
    IN ULONG Len,
    IN PVOID Data,
    IN OUT PULONG BytesWritten,
    IN OUT PULONG BytesNeeded,
    IN OUT PNDIS_STATUS Status)
{
    *Status = NDIS_STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\recv.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    recv.c

Abstract:

    routines to handle receiving data

Author:

    Charlie Wickham (charlwi)  08-May-1996
    Rajesh Sundaram (rajeshsu) 01-Aug-1998.

Environment:

    Kernel Mode

Revision History:

--*/

#include "psched.h"
#pragma hdrstop

/* External */

/* Static */

/* Forward */ /* Generated by Emacs 19.17.0 on Thu May 09 10:34:39 1996 */

INT
ClReceivePacket(
        IN      NDIS_HANDLE                             ProtocolBindingContext,
        IN      PNDIS_PACKET                    Packet
        );

VOID
MpReturnPacket(
        IN      NDIS_HANDLE                             MiniportAdapterContext,
        IN      PNDIS_PACKET                    Packet
        );

VOID
ClReceiveComplete(
        IN      NDIS_HANDLE                             ProtocolBindingContext
        );

NDIS_STATUS
MpTransferData(
        OUT PNDIS_PACKET                        Packet,
        OUT PUINT                                       BytesTransferred,
        IN      NDIS_HANDLE                             MiniportAdapterContext,
        IN      NDIS_HANDLE                             MiniportReceiveContext,
        IN      UINT                                    ByteOffset,
        IN      UINT                                    BytesToTransfer
        );

VOID
ClTransferDataComplete(
    IN  NDIS_HANDLE     ProtocolBindingContext,
    IN  PNDIS_PACKET    pNdisPacket,
    IN  NDIS_STATUS     Status,
    IN  UINT            BytesTransferred
    );

/* End Forward */

VOID
PsAllocateRecvPacket(PNDIS_STATUS  Status,
                     PPNDIS_PACKET Packet,
                     PADAPTER      Adapter)
{

    if(!Adapter->RecvPacketPool)
    {
        PS_LOCK_DPC(&Adapter->Lock);

        if(!Adapter->RecvPacketPool)
        {
            NDIS_HANDLE PoolHandle = (void *) NDIS_PACKET_POOL_TAG_FOR_PSCHED;

            NdisAllocatePacketPoolEx(Status,
                                     &PoolHandle,
                                     MIN_PACKET_POOL_SIZE,
                                     MAX_PACKET_POOL_SIZE,
                                     sizeof(PS_RECV_PACKET_CONTEXT));

            if(*Status != NDIS_STATUS_SUCCESS)
            {
                Adapter->Stats.OutOfPackets ++;
                PS_UNLOCK_DPC(&Adapter->Lock);

                return;
            }

            // 
            // We successfully allocated a packet pool. We can now free the Fixed Size Block pool for the packet-stack API
            //
            Adapter->RecvPacketPool = PoolHandle;

        }

        PS_UNLOCK_DPC(&Adapter->Lock);
    }

    NdisDprAllocatePacket(Status,
                          Packet,
                          Adapter->RecvPacketPool);
    
}


INT
ClReceivePacket(
        IN      NDIS_HANDLE ProtocolBindingContext,
        IN      PNDIS_PACKET MpPacket
        )

/*++

Routine Description:

    Called by the NIC to indicate a data as an NDIS_PACKET. Make a copy of the
    packet struct, switch to miniport mode and continue the packet along its way

Arguments:

    See the DDK...

Return Values:

    None

--*/

{
    PADAPTER                   Adapter = (PADAPTER)ProtocolBindingContext;
    NDIS_STATUS                Status;
    PPS_RECV_PACKET_CONTEXT    ContextArea;
    PNDIS_PACKET               OurPacket;
    BOOLEAN                    Remaining;

    PsStructAssert( Adapter );

    if(!Adapter->PsNdisHandle)
    {
        return 0;
    }

    if(Adapter->MediaType == NdisMediumWan && 
       Adapter->ProtocolType == ARP_ETYPE_IP)
    {
        //
        // Munge s-mac and d-mac so that wanarp is happy.
        //
        PNDIS_BUFFER pNdisBuf;
        UINT         Len;
        PETH_HEADER  pAddr;
        PUSHORT      id;
        PPS_WAN_LINK WanLink;
        
        pNdisBuf = MpPacket->Private.Head;
        NdisQueryBuffer(pNdisBuf, &pAddr, &Len);
        
        if(Len < sizeof(ETH_HEADER))
        {
            return NDIS_STATUS_FAILURE;
        }

        id = (PUSHORT)&pAddr->DestAddr[0];

        PS_LOCK(&Adapter->Lock);

        if((WanLink = (PPS_WAN_LINK)g_WanLinkTable[*id]) == 0)
        {
            PS_UNLOCK(&Adapter->Lock);
            return NDIS_STATUS_FAILURE;
        }

        if(WanLink->State != WanStateOpen)
        {
            PS_UNLOCK(&Adapter->Lock);
            return NDIS_STATUS_FAILURE;
        }

        PS_UNLOCK(&Adapter->Lock);

        NdisMoveMemory(pAddr, 
                       &WanLink->RecvHeader, 
                       FIELD_OFFSET(ETH_HEADER, Type));

    }

    NdisIMGetCurrentPacketStack(MpPacket, &Remaining);

    if(Remaining != 0)
    {
        Status = NDIS_GET_PACKET_STATUS(MpPacket);

        // TimeStamp will always be there; no need to check //
        if (!TimeStmpReceivePacket(   NULL, NULL, NULL, MpPacket, Adapter->MediaType )) 
            PsDbgRecv(DBG_FAILURE, DBG_RECEIVE, CL_RECV_PACKET, OURS, Adapter, MpPacket, 0);

        if (TimeStmpRecvPacket) {
            
            if (!(TimeStmpRecvPacket)(
                                      NULL,
                                      NULL,
                                      NULL,
                                      MpPacket,
                                      Adapter->MediaType
                                      )) {
                
                PsDbgRecv(DBG_FAILURE, DBG_RECEIVE, CL_RECV_PACKET, OURS, Adapter, MpPacket, 0);
            }
            
        }
        
		NdisMIndicateReceivePacket(Adapter->PsNdisHandle, &MpPacket, 1);

		return((Status != NDIS_STATUS_RESOURCES) ? 1 : 0);
    }
    else 
    {

        PsAllocateRecvPacket(&Status, &OurPacket, Adapter);

        if(Status == NDIS_STATUS_SUCCESS)
        {
            PsDbgRecv(DBG_INFO, DBG_RECEIVE, CL_RECV_PACKET, ENTER, Adapter, OurPacket, MpPacket);
            
            //
            // Save Original Packet
            //
            ContextArea = PS_RECV_PACKET_CONTEXT_FROM_PACKET(OurPacket);
            ContextArea->OriginalPacket = MpPacket;
            
    
            OurPacket->Private.Head       = MpPacket->Private.Head;
            OurPacket->Private.Tail       = MpPacket->Private.Tail;
            
            //
            // Get the original packet (it could be the same packet as one received or a different one
            // based on # of layered MPs) and set it on the indicated packet so the OOB stuff is visible
            // correctly at the top.
            //
            NDIS_SET_ORIGINAL_PACKET(OurPacket, NDIS_GET_ORIGINAL_PACKET(MpPacket));
    
            NDIS_SET_PACKET_HEADER_SIZE(OurPacket, NDIS_GET_PACKET_HEADER_SIZE(MpPacket));
            
            //
            // Set Packet Flags
            //
            NdisGetPacketFlags(OurPacket) = NdisGetPacketFlags(MpPacket);
            
            Status = NDIS_GET_PACKET_STATUS(MpPacket);
            
            NDIS_SET_PACKET_STATUS(OurPacket, Status);

            if(!(TimeStmpReceivePacket)(   NULL, NULL, NULL, OurPacket, Adapter->MediaType ))
                PsDbgRecv(DBG_FAILURE, DBG_RECEIVE, CL_RECV_PACKET, OURS, Adapter, OurPacket, OurPacket);
                
            
            if (TimeStmpRecvPacket) {
                
                if (!(TimeStmpRecvPacket)(
                                          NULL,
                                          NULL,
                                          NULL,
                                          OurPacket,
                                          Adapter->MediaType
                                          )) {
                        
                    PsDbgRecv(DBG_FAILURE, DBG_RECEIVE, CL_RECV_PACKET, OURS, Adapter, OurPacket, OurPacket);
                }
                    
            }

            NdisMIndicateReceivePacket(Adapter->PsNdisHandle, &OurPacket, 1);

            if (Status == NDIS_STATUS_RESOURCES)
            {
                NdisDprFreePacket(OurPacket);
            }
            
            return((Status != NDIS_STATUS_RESOURCES) ? 1 : 0);
        }
        else
        {
            
            //
            // out of resources. indicate that we're not hanging onto the packet
            //
            PsDbgRecv(DBG_FAILURE, DBG_RECEIVE, CL_RECV_PACKET, NO_RESOURCES,
                      Adapter, 0, MpPacket);
            
            Adapter->Stats.OutOfPackets ++;
            return 0;
        }
    }

} // ClReceivePacket


VOID
MpReturnPacket(
        IN      NDIS_HANDLE                             MiniportAdapterContext,
        IN      PNDIS_PACKET                    Packet
        )

/*++

Routine Description:

     Potentially return a packet we indicated previously to the
     underlying miniport. It might be one of ours from a ProtocolReceive
     indication, so we disassemble it and return the packet and its
     buffers to their respective S Lists

Arguments:

    See the DDK...

Return Values:

    None

--*/

{
    PADAPTER                Adapter = (PADAPTER)MiniportAdapterContext;
    PPS_RECV_PACKET_CONTEXT PktContext;
    PNDIS_PACKET            MyPacket;
    BOOLEAN                 Remaining;

    PsStructAssert(Adapter);

    NdisIMGetCurrentPacketStack(Packet, &Remaining);

    if(Remaining != 0)
    {
        NdisReturnPackets(&Packet, 1);
    }
    else 
    {

        //
        // see if the OriginalPacket field indicates that this belongs
        // to someone below us and return it now
        //

        PktContext = PS_RECV_PACKET_CONTEXT_FROM_PACKET(Packet);

        MyPacket = PktContext->OriginalPacket;

        PsDbgRecv(DBG_INFO, DBG_RECEIVE, MP_RETURN_PACKET, RETURNING, Adapter, Packet, MyPacket);

        NdisDprFreePacket(Packet);

        NdisReturnPackets(&MyPacket, 1);
    }


} // MpReturnPacket


NDIS_STATUS
ClReceiveIndication(
        IN      NDIS_HANDLE                             ProtocolBindingContext,
        IN      NDIS_HANDLE                             MacReceiveContext,
        IN      PVOID                                   HeaderBuffer,
        IN      UINT                                    HeaderBufferSize,
        IN      PVOID                                   LookAheadBuffer,
        IN      UINT                                    LookAheadBufferSize,
        IN      UINT                                    PacketSize
        )

/*++

 Routine Description:

    Called by NIC to notify protocol of incoming data. Copy the data
    into a cached packet we set up during initialization and indicate
    that packet to the higher layer.

Arguments:

    See the DDK...

Return Values:

    None

--*/

{
    PADAPTER     Adapter = (PADAPTER)ProtocolBindingContext;
    PNDIS_PACKET MyPacket, Packet;
    NDIS_STATUS  Status  = NDIS_STATUS_SUCCESS;

    PsStructAssert(Adapter);

    if(!Adapter->PsNdisHandle)
    {
        Status = NDIS_STATUS_FAILURE;
    }
    else
    {
        do
        {
            //
            // If this was indicated by the miniport below as a packet, then get that packet
            // pointer and indicate it as a packet as well (with appropriate status).
            // This way the OOB stuff is accessible to the transport above us.
            //

            Packet = NdisGetReceivedPacket(Adapter->LowerMpHandle, MacReceiveContext);

            if (Packet != NULL)
            {
                BOOLEAN Remaining;

                //
                // Check if there are any more packet stacks left. If there is need to keep per packet information,
                // then the packet stack (which is returned by the api) can be used to store that
                //
                NdisIMGetCurrentPacketStack(Packet, &Remaining);
                if (Remaining != 0)
                {
                    NDIS_STATUS OldPacketStatus;

                    if(!(TimeStmpReceivePacket)(   NULL, NULL, NULL, Packet, Adapter->MediaType ))
                        PsDbgRecv(DBG_FAILURE, DBG_RECEIVE, CL_RECV_IND, OURS, Adapter, Packet, Packet);
                    
                    if (TimeStmpRecvPacket) {

                        if (!(TimeStmpRecvPacket)(
                                              NULL,
                                              NULL,
                                              NULL,
                                              Packet,
                                              Adapter->MediaType
                                              )) {

                            PsDbgRecv(DBG_FAILURE, DBG_RECEIVE, CL_RECV_IND, OURS, Adapter, Packet, Packet);
                        }

                    }

                    // 
                    // Save the old status, and set packet status to NDIS_STATUS_RESOURCES
                    // because we can't have the protocol above us retain the packet -- it
                    // can go away as soon as we return from this function.
                    //
    
                    OldPacketStatus = NDIS_GET_PACKET_STATUS(Packet);
                    NDIS_SET_PACKET_STATUS(Packet, NDIS_STATUS_RESOURCES);

                    NdisMIndicateReceivePacket(Adapter->PsNdisHandle, &Packet, 1);

                    // 
                    // Restore the old Status
                    //
                    NDIS_SET_PACKET_STATUS(Packet, OldPacketStatus);

                    // Since we had set the packet status to NDIS_STATUS_RESOURCES, our
                    // ReturnPacket handler won't be called for this packet.

                    break;
                }

                //
                // Get a packet off the pool and indicate that up
                //
                PsAllocateRecvPacket(&Status,
                                     &MyPacket,
                                     Adapter);

                if (Status == NDIS_STATUS_SUCCESS)
                {
                    MyPacket->Private.Head = Packet->Private.Head;
                    MyPacket->Private.Tail = Packet->Private.Tail;
				
                    //
                    // Get the original packet (it could be the same packet as one received or
                    // a different one based on # of layered MPs) and set it on the indicated
                    // packet so the OOB stuff is visible  correctly at the top.
                    //
                    NDIS_SET_ORIGINAL_PACKET(MyPacket, NDIS_GET_ORIGINAL_PACKET(Packet));

                    NDIS_SET_PACKET_HEADER_SIZE(MyPacket, HeaderBufferSize);
		
                    //
                    // Set Packet Flags
                    //
                    NdisGetPacketFlags(MyPacket) = NdisGetPacketFlags(Packet);
				
                    //
                    // Make sure the status is set to NDIS_STATUS_RESOURCES.
                    //
                    NDIS_SET_PACKET_STATUS(MyPacket, NDIS_STATUS_RESOURCES);

                    if(!(TimeStmpReceivePacket)(   NULL, NULL, NULL, MyPacket, Adapter->MediaType ))
                        PsDbgRecv(DBG_FAILURE, DBG_RECEIVE, CL_RECV_IND, OURS, Adapter, MyPacket, MyPacket);
		
                    if (TimeStmpRecvPacket) {

                        if (!(TimeStmpRecvPacket)(
                                              NULL,
                                              NULL,
                                              NULL,
                                              MyPacket,
                                              Adapter->MediaType
                                              )) {

                            PsDbgRecv(DBG_FAILURE, DBG_RECEIVE, CL_RECV_IND, OURS, Adapter, MyPacket, MyPacket);
                        }

                    }

                    NdisMIndicateReceivePacket(Adapter->PsNdisHandle, &MyPacket, 1);
		
                    PsAssert (NDIS_GET_PACKET_STATUS(MyPacket) == NDIS_STATUS_RESOURCES);

                    NdisDprFreePacket(MyPacket);

                    break;
                }
            }

            //
            // Fall through if the miniport below us has either not indicated a packet or we
            // could not  allocate one
            //
            Adapter->IndicateRcvComplete = TRUE;

            //
            // If the timestamp driver is present.
            //
            //
            if (TimeStmpRecvIndication) {

                if (!(TimeStmpRecvIndication)(
                                              NULL,
                                              NULL,
                                              NULL,
                                              HeaderBuffer,
                                              HeaderBufferSize,
                                              LookAheadBuffer,
                                              LookAheadBufferSize,
                                              PacketSize,
                                              Adapter->IPHeaderOffset
                                              )) {

                    PsDbgRecv(DBG_FAILURE, DBG_RECEIVE, CL_RECV_IND, OURS, Adapter, (PNDIS_PACKET) LookAheadBuffer, NULL);
                }

            }

            switch (Adapter->MediaType)
            {
              case NdisMedium802_3:
            case NdisMediumWan:


                  NdisMEthIndicateReceive(Adapter->PsNdisHandle,
                                          MacReceiveContext,
                                          HeaderBuffer,
                                          HeaderBufferSize,
                                          LookAheadBuffer,
                                          LookAheadBufferSize,
                                          PacketSize);
                  break;

              case NdisMedium802_5:
                  NdisMTrIndicateReceive(Adapter->PsNdisHandle,
                                         MacReceiveContext,
                                         HeaderBuffer,
                                         HeaderBufferSize,
                                         LookAheadBuffer,
                                         LookAheadBufferSize,
                                         PacketSize);
                  break;

              case NdisMediumFddi:
                  NdisMFddiIndicateReceive(Adapter->PsNdisHandle,
                                           MacReceiveContext,
                                           HeaderBuffer,
                                           HeaderBufferSize,
                                           LookAheadBuffer,
                                           LookAheadBufferSize,
                                           PacketSize);
                  break;

              default:
                  PsAssert (0);
                  Status = NDIS_STATUS_FAILURE;
                  break;
            }

        } while (FALSE);
    }

    return Status;

} // ClReceiveIndication


VOID
ClReceiveComplete(
        IN      NDIS_HANDLE                             ProtocolBindingContext
        )

/*++

Routine Description:

    Called by NIC via NdisIndicateReceiveComplete. Continue this indication
    up to the higher layer

Arguments:

    See the DDK...

Return Values:

    None

--*/

{
    PADAPTER Adapter = (PADAPTER)ProtocolBindingContext;

    PsStructAssert(Adapter);

    PsDbgRecv(DBG_INFO, DBG_RECEIVE, CL_RECV_COMPL, ENTER, Adapter, 0, 0);

    if((Adapter->PsNdisHandle != NULL) && Adapter->IndicateRcvComplete) {

        switch(Adapter->MediaType){

          case NdisMediumWan:
          case NdisMedium802_3:

              NdisMEthIndicateReceiveComplete(Adapter->PsNdisHandle);
              break;

          case NdisMedium802_5:

              NdisMTrIndicateReceiveComplete(Adapter->PsNdisHandle);
              break;

          case NdisMediumFddi:

              NdisMFddiIndicateReceiveComplete(Adapter->PsNdisHandle);
              break;

        default:

            PsAssert(FALSE);
        }
    }
    Adapter->IndicateRcvComplete = FALSE;

}  // ClReceiveComplete


NDIS_STATUS
MpTransferData(
        OUT PNDIS_PACKET Packet,
        OUT PUINT        BytesTransferred,
        IN  NDIS_HANDLE  MiniportAdapterContext,
        IN  NDIS_HANDLE  MiniportReceiveContext,
        IN  UINT         ByteOffset,
        IN  UINT         BytesToTransfer
        )

/*++

Routine Description:



Arguments:

    See the DDK...

Return Values:

    None

--*/

{
    PADAPTER Adapter = (PADAPTER)MiniportAdapterContext;
    NDIS_STATUS Status;

    PsStructAssert(Adapter);

    PsDbgRecv(DBG_INFO, DBG_RECEIVE, MP_XFER_DATA, ENTER, Adapter, 0, 0);

    if(IsDeviceStateOn(Adapter) == FALSE)
    {
        return NDIS_STATUS_FAILURE;
    }

    NdisTransferData(
                &Status,
                Adapter->LowerMpHandle,
                MiniportReceiveContext,
                ByteOffset,
                BytesToTransfer,
                Packet,
                BytesTransferred);

    return Status;

} // MpTransferData


VOID
ClTransferDataComplete(
    IN  NDIS_HANDLE     ProtocolBindingContext,
    IN  PNDIS_PACKET    Packet,
    IN  NDIS_STATUS     Status,
    IN  UINT            BytesTransferred
    )

/*++

Routine Description:

    Completion routine for NdisTransferData

Arguments:

    See the DDK...

Return Values:

    None

--*/

{
    PADAPTER                Adapter = (PADAPTER)ProtocolBindingContext;
    PPS_RECV_PACKET_CONTEXT PktContext;

    PsStructAssert(Adapter);

    PsDbgRecv(DBG_INFO, DBG_RECEIVE, CL_XFER_COMPL, ENTER, Adapter, Packet, 0);

    if(Adapter->PsNdisHandle)
    {
        NdisMTransferDataComplete(
                        Adapter->PsNdisHandle,
                        Packet,
                        Status,
                        BytesTransferred);
    }

} // ClTransferDataComplete

UINT
ClCoReceivePacket(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_HANDLE ProtocolVcContext,
    IN  PNDIS_PACKET Packet
    )
{
    //
    // We don't do anything special in the coreceive path. Just call ClReceivePacket.
    //

    return ClReceivePacket(ProtocolBindingContext, Packet);

} // ClCoReceivePacket

/* end recv.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\recv.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    recv.h

Abstract:

    defines for packet receive routines

Author:

    Charlie Wickham (charlwi) 08-May-1996

Revision History:

--*/

#ifndef _RECV_
#define _RECV_

/* Prototypes */ /* Generated by Emacs 19.17.0 on Thu May 09 10:34:42 1996 */

/*++

Routine Description:

    Called by the NIC to indicate a data as an NDIS_PACKET. Switch to miniport mode
    and continue the packet along its way

Arguments:

    See the DDK...

Return Values:

    None

--*/

INT
ClReceivePacket(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	PNDIS_PACKET			Packet
	);

/*++

Routine Description:



Arguments:

    See the DDK...

Return Values:

    None

--*/

VOID
MpReturnPacket(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	PNDIS_PACKET			Packet
	);

/*++

Routine Description:

    Called by NIC to notify protocol of incoming data

Arguments:

    See the DDK...

Return Values:

    None

--*/

NDIS_STATUS
ClReceiveIndication(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_HANDLE				MacReceiveContext,
	IN	PVOID					HeaderBuffer,
	IN	UINT					HeaderBufferSize,
	IN	PVOID					LookAheadBuffer,
	IN	UINT					LookaheadBufferSize,
	IN	UINT					PacketSize
	);

/*++

Routine Description:

    Called by NIC via NdisIndicateReceiveComplete

Arguments:

    See the DDK...

Return Values:

    None

--*/

VOID
ClReceiveComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext
	);

/*++

Routine Description:



Arguments:

    See the DDK...

Return Values:

    None

--*/

NDIS_STATUS
MpTransferData(
	OUT PNDIS_PACKET			Packet,
	OUT PUINT					BytesTransferred,
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	NDIS_HANDLE				MiniportReceiveContext,
	IN	UINT					ByteOffset,
	IN	UINT					BytesToTransfer
	);

/*++

Routine Description:

    Completion routine for NdisTransferData
Arguments:

    See the DDK...

Return Values:

    None

--*/

VOID
ClTransferDataComplete(
    IN  NDIS_HANDLE     ProtocolBindingContext,
    IN  PNDIS_PACKET    pNdisPacket,
    IN  NDIS_STATUS     Status,
    IN  UINT            BytesTransferred
    );

UINT
ClCoReceivePacket(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_HANDLE ProtocolVcContext,
    IN  PNDIS_PACKET Packet
    );

/* End Prototypes */

#endif /* _RECV_ */

/* end recv.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\refcnt.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    refcnt.c

Abstract:

    This module exports Reference Counting support functions. By 
    including a Reference Count Control Block (REF_CNT) in a
    dynamic type, and using this API, a Reference scheme can be
    implemented for that type.

Author:

    Edward Buchwalter (v-edbuc)    14-Aug-1996

Revision History:

    Shreedhar Madhavapeddi (ShreeM)   16-April-1999 Adapted for NT and GPC by ShreeM\MBert.
    Rajesh Sundaram        (rajeshsu) 05-Aug-1999   Adapted for psched. 
    
--*/

//
// Include Files
//

#include "psched.h"
#pragma hdrstop

#define EXPAND_TAG(t)   ((CHAR *)(&Tag))[0],((CHAR *)(&Tag))[1],((CHAR *)(&Tag))[2],((CHAR *)(&Tag))[3]
VOID
ReferenceInit 
(
    IN PREF_CNT pRefCnt,
    PVOID       InstanceHandle,
    VOID        (*DeleteHandler)( PVOID , BOOLEAN)
)

/*++

Routine Description:

    ReferenceInit initializes and adds one reference to the
    supplied Reference Control Block. If provided, an instance
    handle and delete handler are saved for use by the ReferenceRemove 
    function when all references to the instance are removed.

Arguments:

    pRefCnt - pointer to uninitialized Reference Control Block
    InstanceHandle - handle to the managed instance.
    DeleteHandler - pointer to delete function, NULL is OK.

Return Value:

    The function's value is VOID.

--*/

{
    ASSERT( pRefCnt );

    // Set the reference to 1 and save the instance 
    // handle and the delete handler.

    pRefCnt->Count         = 0;
    pRefCnt->Instance      = InstanceHandle;
    pRefCnt->DeleteHandler = DeleteHandler;
    
#if DBG
    pRefCnt->Sig = REF_SIG;

    RtlZeroMemory(pRefCnt->Tags, sizeof(REF_TAG) * TAG_CNT);
    
    pRefCnt->Tags[0].Tag = 'LTOT';
    
    CTEInitLock(&pRefCnt->Lock);
    
#endif
        
}


#if DBG

VOID
ReferenceAddDbg(PREF_CNT pRefCnt, ULONG Tag)
{
    int             i;
    CTELockHandle   hLock;
    int             TotalPerArray = 0;
    
    ASSERT(pRefCnt->Sig == REF_SIG);
    
    CTEGetLock(&pRefCnt->Lock, &hLock);
    
    for (i = 1; i < TAG_CNT; i++)
    {
        if (pRefCnt->Tags[i].Tag == 0 || pRefCnt->Tags[i].Tag == Tag)
        {
            pRefCnt->Tags[i].Tag = Tag;
            InterlockedIncrement(&pRefCnt->Tags[i].Count);
            break;
        }
    }
    
    ASSERT(i < TAG_CNT);
    
    InterlockedIncrement(&pRefCnt->Tags[0].Count);
    
    InterlockedIncrement(&pRefCnt->Count);
    
    ASSERT(pRefCnt->Tags[0].Count == pRefCnt->Count);

    // sanity check
/*    
    for (i = 1; i < TAG_CNT; i++)
    {
        if (pRefCnt->Tags[i].Tag != 0)
        {
            TotalPerArray += pRefCnt->Tags[i].Count;
            continue;
        }
    }

    ASSERT(TotalPerArray == pRefCnt->Tags[0].Count);
    
    if (TotalPerArray != pRefCnt->Tags[0].Count)
    {
        DbgBreakPoint();
    }        
    

*/    
    CTEFreeLock(&pRefCnt->Lock, hLock);
}

VOID
ReferenceRemoveDbg(PREF_CNT pRefCnt, BOOLEAN LockHeld, ULONG Tag)
{
    int             i;
    CTELockHandle   hLock;
    int             TotalPerArray = 0;
    BOOLEAN         FoundIt = FALSE;
    
    ASSERT(pRefCnt->Sig == REF_SIG);

    CTEGetLock(&pRefCnt->Lock, &hLock);
        
    for (i = 1; i < TAG_CNT; i++)
    {
        if (pRefCnt->Tags[i].Tag == Tag)
        {
            FoundIt = TRUE;
            
            ASSERT(pRefCnt->Tags[i].Count > 0);
            
            InterlockedDecrement(&pRefCnt->Tags[i].Count);
            if (pRefCnt->Tags[i].Count == 0)
                pRefCnt->Tags[i].Tag = Tag; 
            break;
        }
    }

    ASSERT(FoundIt);
  
    ASSERT(pRefCnt->Tags[0].Count > 0);
        
    ASSERT(pRefCnt->Tags[0].Count == pRefCnt->Count);
      
    InterlockedDecrement(&pRefCnt->Tags[0].Count);
    
    if (InterlockedDecrement(&pRefCnt->Count) > 0 )
    {
        CTEFreeLock(&pRefCnt->Lock, hLock);
    } 
    else if (pRefCnt->DeleteHandler)
    {
        CTEFreeLock(&pRefCnt->Lock, hLock);

        (pRefCnt->DeleteHandler)( pRefCnt->Instance, LockHeld );
    }
    else
    {
        CTEFreeLock(&pRefCnt->Lock, hLock);   
    }
        
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\refcnt.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    refcnt.h

Abstract:


Author:

    Edward Buchwalter (v-edbuc)    15-Aug-1996

Revision History:

    Shreedhar Madhavapeddi (ShreeM)   16-April-1999 Adapted for GPC.
    Rajesh Sundaram        (rajeshsu) 05-Aug-1999 Adapted for psched.
    
--*/

#ifndef REFCNT_H
#define REFCNT_H

//
// Reference Count Control Block
//
//  Elements:
//
//  - Count:            number of outstanding references
//  - Instance:      user supplied context 
//  - UserDeleteFunc:   user supplied delete function
//

#define TAG_CNT 10
#define REF_SIG 0x7841eeee

typedef struct
{
    ULONG   Tag;
    LONG    Count;
} REF_TAG;    

typedef struct  reference_count_control
{
    LONG       	  Count;
    PVOID         Instance;
    VOID          (*DeleteHandler)( PVOID, BOOLEAN );
#if DBG    
    int           Sig;
    REF_TAG       Tags[TAG_CNT];
    CTELock       Lock;
#endif     
} REF_CNT, *PREF_CNT;


VOID    
ReferenceInit 
( 
    IN PREF_CNT pRefCnt, 
    PVOID       InstanceHandle, 
    VOID        (*DeleteHandler)( PVOID , BOOLEAN) 
);

#define REFINIT(Rc, I, h) ReferenceInit(Rc, I, h)

#if DBG

VOID ReferenceAddDbg(PREF_CNT pRefCnt, ULONG Tag);
VOID ReferenceRemoveDbg(PREF_CNT pRefCnt, BOOLEAN Locked, ULONG Tag);

#define REFADD(Rc, Tag)               ReferenceAddDbg(Rc, Tag);
#define REFDEL(Rc, LockHeld, Tag)     ReferenceRemoveDbg(Rc, LockHeld, Tag)

#else

#define REFADD(Rc, Tag)  InterlockedIncrement(&(Rc)->Count);
#define REFDEL(Rc, LockHeld, Tag)                             \
   if (InterlockedDecrement(&(Rc)->Count) == 0 )              \
        ((Rc)->DeleteHandler)( (Rc)->Instance , (LockHeld));

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\schedt.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    schedt.h

Abstract:

    defines for psched's tracing support

Author:

    Rajesh Sundaram (rajeshsu)

Revision History:

--*/

#ifndef _SCHEDTRACE_
#define _SCHEDTRACE_


typedef VOID (*SCHEDTRACE_THRESH_PROC)( PVOID Context);

#define TRACE_BUFFER_SIZE 1000 * 1024
#define TRACE_STRING_LENGTH 127
#define MAX_RECORD_DATA 200
#define TRACE_PREAMBLE 0xdeadbeef

// Record types

#define RECORD_TSTRING             1
#define RECORD_RECV                2
#define RECORD_PKT                 3
#define RECORD_SCHED               4
#define RECORD_COMPONENT_SPECIFIC  5
#define RECORD_SEND                6
#define RECORD_OID                 7


// Receive actions (must be kept in sync with kdps)

#define ENTER           (ULONG)1
#define NO_RESOURCES    (ULONG)2
#define LOW_RESOURCES   (ULONG)3
#define INDICATING      (ULONG)4
#define RETURNED        (ULONG)5
#define NOT_OURS        (ULONG)6
#define OURS            (ULONG)7
#define RETURNING       (ULONG)8
#define TRANSFERRING    (ULONG)9
#define NOT_READY       (ULONG)10

// Receive events (must be kept in sync with kdps)

#define CL_RECV_PACKET  (ULONG)1
#define MP_RETURN_PACKET (ULONG)2
#define CL_RECV_IND     (ULONG)3
#define CL_RECV_COMPL   (ULONG)4
#define MP_XFER_DATA    (ULONG)5
#define CL_XFER_COMPL   (ULONG)6

// Send actions 
#define MP_SEND    (ULONG) 1
#define MP_CO_SEND (ULONG) 2
#define DUP_PACKET (ULONG) 3
#define DROP_PACKET (ULONG) 4
#define CL_SEND_COMPLETE (ULONG) 5

// Packet actions (must be kept in sync with kdps)

#define SUBMIT          (ULONG)1
#define SEND            (ULONG)2
#define SEND_COMPLETE   (ULONG)3
#define DROP            (ULONG)4
#define CO_SEND         (ULONG)5

// Scheduler actions (must be kept in sync with kdps)

#define PKT_ENQUEUE     (ULONG)1
#define PKT_DEQUEUE     (ULONG)2
#define PKT_CONFORMANCE (ULONG)3
#define PKT_DISCARD     (ULONG)4

// ID for Scheduler modules
// Note! LAST_LOG_ID should be at the very 
// end. The add-in components use IDs that
// begin from LAST_LOG_ID
#define TBC_CONFORMER   (ULONG)1
#define SHAPER          (ULONG)2
#define DRR_SEQUENCER   (ULONG)3
#define LAST_LOG_ID     (ULONG)4

typedef struct _TraceRecordString {
    LONG            Preamble;
    SHORT           RecordType;
    LARGE_INTEGER   Now;
    UCHAR           StringStart[TRACE_STRING_LENGTH];
} TRACE_RECORD_STRING;

#define TRACE_OID_MP_SETINFORMATION       1
#define TRACE_OID_MP_QUERYINFORMATION     2
#define TRACE_OID_SET_REQUEST_COMPLETE    3
#define TRACE_OID_QUERY_REQUEST_COMPLETE  4

typedef struct _TraceRecordOid {
    LONG            Preamble;
    SHORT           RecordType;
    LARGE_INTEGER   Now;
    ULONG           Oid;
    ULONG           Local; 
    ULONG           Action; 
    ULONG           PTState; 
    ULONG           MPState; 
    PVOID           Adapter;
    ULONG           Status;
} TRACE_RECORD_OID;

typedef struct _TraceRecordRecv{
    LONG            Preamble;
    SHORT           RecordType;
    LARGE_INTEGER   Now;
    ULONG           Event;
    ULONG           Action;
    PVOID           Adapter;
    PNDIS_PACKET    Packet1;
    PNDIS_PACKET    Packet2;
} TRACE_RECORD_RECV;

typedef struct _TraceRecordSend {
    LONG            Preamble;
    SHORT           RecordType;
    LARGE_INTEGER   Now;
    ULONG           Event;
    ULONG           Action;
    PVOID           Adapter;
    PNDIS_PACKET    Packet1;
    PNDIS_PACKET    Packet2;
    PVOID           Vc;
} TRACE_RECORD_SEND;

typedef struct _TraceRecordPkts{
    LONG            Preamble;
    SHORT           RecordType;
    LARGE_INTEGER   Now;
    ULONG           CallingFunction;
    PVOID           VC;
    PNDIS_PACKET    Packet;
    ULONG           PacketLength;
    ULONG           Action;
    LONGLONG        AbsoluteTime;
} TRACE_RECORD_PKT;

typedef struct _TraceRecordSched{
    LONG            Preamble;
    SHORT           RecordType;
    LARGE_INTEGER   Now;
    ULONG           SchedulerComponent;
    ULONG           Action;
    PVOID           VC;
    PNDIS_PACKET    Packet;
    ULONG           PacketLength;
    ULONG           Priority;
    LONGLONG        ArrivalTime;
    LONGLONG        ConformanceTime;
    ULONG           PacketsInComponent;
    ULONG           BytesInComponent;
} TRACE_RECORD_SCHED;
    

typedef struct _TraceRecordComponentSpecific{
    LONG            Preamble;
    SHORT           RecordType;
    LARGE_INTEGER   Now;
    ULONG           SchedulerComponent;
    ULONG           Length;
    UCHAR           Data[MAX_RECORD_DATA];
} TRACE_RECORD_COMPONENT_SPECIFIC;


VOID DbugOid(
    ULONG Action,
    ULONG Local,
    ULONG PTState,
    ULONG MPState,
    PVOID Adapter,
    ULONG Oid,
    ULONG Status
    );

VOID
DbugSchedString(char *format, ...);

VOID
DbugRecv(
    ULONG Event,
    ULONG Action,
    PVOID Adapter,
    PNDIS_PACKET Packet1,
    PNDIS_PACKET Packet2
    );

VOID
DbugSend(
    ULONG Event,
    ULONG Action,
    PVOID Adapter,
    PVOID Vc,
    PNDIS_PACKET Packet1,
    PNDIS_PACKET Packet2
    );

VOID
DbugSchedPkts(
    ULONG CallingFunction,
    PVOID VC,
    PNDIS_PACKET Packet, 
    ULONG Action,
    ULONG PacketLength
    );

VOID
DbugSched(
    ULONG SchedulerComponent,
    ULONG Action,
    PVOID VC,
    PNDIS_PACKET Packet,
    ULONG PacketLength,
    ULONG Priority,
    LONGLONG ArrivalTime,
    LONGLONG ConformanceTime,
    ULONG PacketsInComponent,
    ULONG BytesInComponent
    );

VOID
DbugComponentSpecificRec(
    ULONG SchedulerComponent,
    PVOID Data,
    ULONG Length
    );

VOID
DbugTraceSetThreshold(
    ULONG       Threshold,
    PVOID       Context,
    SCHEDTRACE_THRESH_PROC ThreshProc
    );

VOID
DbugReadTraceBuffer(
    PUCHAR      Buffer,
    ULONG       BytesToRead,
    PULONG      BytesRead
    );

NTSTATUS
WriteRecord(
    UCHAR * Record,
    ULONG   Bytes
    );

VOID
SchedInitialize(ULONG BufferSize);

VOID SchedDeInitialize();

ULONG
SchedtGetBufferSize();

ULONG
SchedtGetBytesUnread();

#endif _SCHEDTRACE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\send.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    send.h

Abstract:

    defines for packet sending routines

Author:

    Charlie Wickham (charlwi) 07-May-1996

Revision History:

--*/

#ifndef _SEND_
#define _SEND_

/* Prototypes */ /* Generated by Emacs 19.17.0 on Tue May 07 11:47:57 1996 */

NDIS_STATUS
DupPacket(
    PADAPTER Adapter,
    PNDIS_PACKET Packet,
    PNDIS_PACKET *DupedPacket,
    PPS_SEND_PACKET_CONTEXT *PktContext
    );

NTSTATUS
MpSend(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	PNDIS_PACKET			Packet,
	IN	UINT					Flags
	);

VOID
ClSendComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	PNDIS_PACKET			Packet,
	IN	NDIS_STATUS				Status
	);

VOID
ClCoSendComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolVcContext,
    IN  PNDIS_PACKET Packet
    );

VOID
CmCoSendComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolVcContext,
    IN  PNDIS_PACKET Packet
    );

VOID
PcCoSendComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolVcContext,
    IN  PNDIS_PACKET Packet
    );

VOID
DropPacket(
    IN HANDLE PipeContext,
    IN HANDLE FlowContext,
    IN PNDIS_PACKET Packet,
    IN NDIS_STATUS Status
    );

PGPC_CLIENT_VC FASTCALL
GetVcByClassifyingPacket(
    PADAPTER Adapter,
    PTC_INTERFACE_ID pInterfaceID,
    PNDIS_PACKET OurPacket
    );

/* End Prototypes */

#endif /* _SEND_ */

/* end send.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\stats.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    stats.c

Abstract:

    routines for PS statistics

Author:

    Yoram Bernet    (yoramb)    23-May-1998
    Rajesh Sundaram (rajeshsu)  01-Aug-1998

Environment:

    Kernel Mode

Revision History:

--*/

#include "psched.h"
#pragma hdrstop

/* External */

/* Static */

/* Forward */

/* End Forward */

NDIS_STATUS
CreateAveragingArray(
    OUT PRUNNING_AVERAGE *RunningAverage,
    IN  ULONG ArraySize
    )
{
    PRUNNING_AVERAGE runningAverage;
    ULONG i;

    PsAllocatePool(runningAverage, 
                   sizeof(RUNNING_AVERAGE), 
                   PsMiscTag); 

    if(!runningAverage)
    {
        *RunningAverage = NULL;
        return(NDIS_STATUS_RESOURCES);
    }

    PsAllocatePool(runningAverage->Elements, 
                   ArraySize * sizeof(ULONG),
                   PsMiscTag);

    if(!runningAverage->Elements)
    {
        PsFreePool(runningAverage);

        *RunningAverage = NULL;

        return(NDIS_STATUS_RESOURCES);
    }

    for(i=0; i < ArraySize; i++){

        runningAverage->Elements[i] = 0;
    }

    runningAverage->Index = 0;
    runningAverage->Sum = 0;
    runningAverage->Size = ArraySize;

    *RunningAverage = runningAverage;
    return(NDIS_STATUS_SUCCESS);
}

ULONG
RunningAverage(
    IN  PRUNNING_AVERAGE RunningAverage,
    IN  ULONG NewValue
    )
{
    ULONG i;

    i = RunningAverage->Index;

    RunningAverage->Sum -= RunningAverage->Elements[i];
    RunningAverage->Sum += NewValue;
    RunningAverage->Elements[i] = NewValue;

    if(++i == RunningAverage->Size){

        i = 0;
    }

    RunningAverage->Index = i;

    return((RunningAverage->Sum)/(RunningAverage->Size));
}

VOID
DeleteAveragingArray(
    PRUNNING_AVERAGE RunningAverage
    )
{
    PsFreePool(RunningAverage->Elements);
    PsFreePool(RunningAverage);
}



/* End stats.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\send.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    send.c

Abstract:

    routines for sending packets

Author:

    Charlie Wickham (charlwi)  07-May-1996
    Yoram Bernet    (yoramb)
    Rajesh Sundaram (rajeshsu) 01-Aug-1998.

Environment:

    Kernel Mode

Revision History:

--*/

#include "psched.h"

#pragma hdrstop

/* External */

/* Static */

/* Forwad */

#define SEND_PACKET_VIA_SCHEDULER(_pktcontext, _vc, _adapter, _ourpacket)     \
{                                                                             \
    PsAssert((_pktcontext)->Vc != 0);                                         \
    (_vc)->Stats.PacketsScheduled++;                                          \
    (_vc)->Stats.BytesScheduled.QuadPart += (_pktcontext)->Info.PacketLength; \
    if(!(*(_vc)->PsComponent->SubmitPacket)(                                  \
              (_vc)->PsPipeContext,                                           \
              (_vc)->PsFlowContext,                                           \
              (_pktcontext)->Info.ClassMapContext,                            \
              &(_pktcontext)->Info)) {                                        \
                                                                              \
          DropPacket((_adapter), (_vc), (_ourpacket), NDIS_STATUS_FAILURE);   \
    }                                                                         \
    return NDIS_STATUS_PENDING;                                               \
}


#define FILL_PKT_FOR_NIC(OPacket, UserC)                                      \
{                                                                             \
    NDIS_PACKET_8021Q_INFO    VlanPriInfo;                                    \
                                                                              \
    VlanPriInfo.Value = NDIS_PER_PACKET_INFO_FROM_PACKET(OPacket, Ieee8021QInfo);\
    VlanPriInfo.TagHeader.UserPriority = (UserC);                             \
    NDIS_PER_PACKET_INFO_FROM_PACKET(OPacket, Ieee8021QInfo) = VlanPriInfo.Value;\
}

#define FILL_PKT_FOR_SCHED(Adapter, PktContext, Vc, OPacket, TOSNC, UserC, UserNC,                   \
                           _IPHdr)                                                                   \
{                                                                                                    \
   ULONG _PacketLength;                                                                              \
   FILL_PKT_FOR_NIC(OPacket, UserC);                                                                 \
   NdisQueryPacket((OPacket), NULL, NULL, NULL, &(_PacketLength));                                   \
   (PktContext)->Info.PacketLength = (_PacketLength) - (Adapter)->HeaderSize;                        \
   (PktContext)->Info.ConformanceTime.QuadPart = 0;                                                  \
   (PktContext)->Info.ClassMapContext = 0;                                                           \
   (PktContext)->Info.UserPriorityNonConforming = (UserNC);                                          \
   (PktContext)->Info.TOSNonConforming          = (TOSNC);                                           \
   (PktContext)->Info.IPHdr                     = (_IPHdr);                                          \
   (PktContext)->Info.IPHeaderOffset            = (Adapter)->IPHeaderOffset;                         \
   (PktContext)->Vc                             = (Vc);                                              \
}

#define SEND_PACKET_OVER_NIC(Adapter, Packet, UserC, Status)                                              \
{                                                                                                         \
   PPS_SEND_PACKET_CONTEXT _PktContext;                                                                   \
   PNDIS_PACKET            _OurPacket;                                                                    \
   if((Status = PsDupPacketNoContext(Adapter, Packet, &_OurPacket, &_PktContext)) == NDIS_STATUS_SUCCESS) \
   {                                                                                                      \
      FILL_PKT_FOR_NIC(_OurPacket, UserC);                                                                \
      NdisSend(&Status, Adapter->LowerMpHandle, _OurPacket);                                              \
      if(Status != NDIS_STATUS_PENDING) {                                                                 \
         if(_PktContext) {                                                                                \
            PsAssert((_PktContext)->Vc == 0);                                                             \
            NdisIMCopySendCompletePerPacketInfo(_PktContext->OriginalPacket, _OurPacket);                 \
            NdisFreePacket(_OurPacket);                                                                   \
         }                                                                                                \
      }                                                                                                   \
   }                                                                                                      \
   return Status;                                                                                         \
}

NDIS_STATUS
PsAllocateAndCopyPacket(
    PADAPTER Adapter,
    PNDIS_PACKET Packet,
    PPNDIS_PACKET OurPacket,
    PPS_SEND_PACKET_CONTEXT *PktContext)
{                             
    PNDIS_PACKET_OOB_DATA        OurOOBData;
    PNDIS_PACKET_OOB_DATA        XportOOBData;
    PMEDIA_SPECIFIC_INFORMATION  OurMediaArea;
    PVOID                        MediaSpecificInfo = NULL;
    UINT                         MediaSpecificInfoSize = 0;
    NDIS_STATUS                  Status;

    //
    // At this point, we know that there are no packet stacks remaining in the packet.
    // we proceed to allocate an NDIS packet using NdisAllocatePacket. Note that here
    // we do not have to allocate our per-packet area, since NdisAllocatePacket already 
    // did this for us.
    //

    if(!Adapter->SendPacketPool)
    {
        PS_LOCK(&Adapter->Lock);

        if(!Adapter->SendPacketPool)
        {
            NDIS_HANDLE PoolHandle = (void *) NDIS_PACKET_POOL_TAG_FOR_PSCHED;

            NdisAllocatePacketPoolEx(&Status,
                                     &PoolHandle,
                                     MIN_PACKET_POOL_SIZE,
                                     MAX_PACKET_POOL_SIZE,
                                     Adapter->PacketContextLength);

            if(Status != NDIS_STATUS_SUCCESS)
            {
                Adapter->Stats.OutOfPackets ++;
                PS_UNLOCK(&Adapter->Lock);

                return Status;
            }

            // 
            // We successfully allocated a packet pool. We can now free the Fixed Size Block pool for the packet-stack API
            //
            Adapter->SendPacketPool = PoolHandle;
        }
        
        PS_UNLOCK(&Adapter->Lock);

    }

    NdisAllocatePacket(&Status,
                       OurPacket,
                       Adapter->SendPacketPool);
    
    
    if(Status != NDIS_STATUS_SUCCESS)
    {
        //
        // mark as out of resources. Ndis will resubmit.
        //
        
        Adapter->Stats.OutOfPackets ++;
        return(NDIS_STATUS_RESOURCES);
    }
    
#if DBG
    PsAssert((*OurPacket)->Private.Head == NULL);

    if(Packet->Private.TotalLength){
        
        PsAssert(Packet->Private.Head);
    }
#endif // DBG

    //
    // chain the buffers from the upper layer packet to the newly allocated packet.
    //
    
    (*OurPacket)->Private.Head = Packet->Private.Head;
    (*OurPacket)->Private.Tail = Packet->Private.Tail;
    
    //
    // Copy the Packet Flags from the Packet to OldPacket. Since we handle loopback in the 
    // QueryInformation handlers, we don't set the NDIS_FLAGS_DONT_LOOPBACK
    //
    
    NdisGetPacketFlags(*OurPacket) = NdisGetPacketFlags(Packet);
    
    //
    // Copy the OOB Offset from the original packet to the new packet.
    //
    XportOOBData = NDIS_OOB_DATA_FROM_PACKET(Packet);
    OurOOBData = NDIS_OOB_DATA_FROM_PACKET(*OurPacket);
    NdisMoveMemory(OurOOBData,
                   XportOOBData,
                   sizeof(NDIS_PACKET_OOB_DATA));
    
    //
    // Copy the per packet info into the new packet
    //
    NdisIMCopySendPerPacketInfo(*OurPacket, Packet);
    
    //
    // Copy the Media specific information
    //
    NDIS_GET_PACKET_MEDIA_SPECIFIC_INFO(Packet,
                                        &MediaSpecificInfo,
                                        &MediaSpecificInfoSize);
    if(MediaSpecificInfo || MediaSpecificInfoSize){
        
        NDIS_SET_PACKET_MEDIA_SPECIFIC_INFO(*OurPacket,
                                            MediaSpecificInfo,
                                            MediaSpecificInfoSize);
    }
    
    //
    // Remember the original packet so that we can complete it properly.
    //
    *PktContext = PS_SEND_PACKET_CONTEXT_FROM_PACKET(*OurPacket);
    (*PktContext)->OriginalPacket = Packet;
    (*PktContext)->Vc = 0;
    (*PktContext)->Info.NdisPacket = *OurPacket;

    return Status;
}
       
NDIS_STATUS
PsDupPacketNoContext(
    PADAPTER Adapter,
    PNDIS_PACKET Packet,
    PPNDIS_PACKET OurPacket,
    PPS_SEND_PACKET_CONTEXT *PktContext)
{                             
    NDIS_STATUS                  Status = NDIS_STATUS_SUCCESS;
    BOOLEAN                      Remaining;
    PNDIS_PACKET_STACK           PacketStack;

    //
    // NDIS provides 2 ways for IMs to indicate packets. If the IM can allocate a packet stack, it should use it as
    // it is the optimal approach. In this case, we do not have to do any per-packet copying since we don't allocate
    // a new packet.
    //

    PacketStack = NdisIMGetCurrentPacketStack(Packet, &Remaining);

    if(Remaining != 0)
    {
       //
       // The packet stack has space only for 2 DWORDs. Since we are using more than 2, we need to allocate our own 
       // memory for the per-packet block. Note that we *DONT* do this when we use the NdisAllocatePacket APIs, because
       // we initialized the packet pool to already include the space for the per-packet region.
       //

       *OurPacket = Packet;
       *PktContext = 0;
       PacketStack->IMReserved[0] = 0;

    }
    else 
    {
        Status = PsAllocateAndCopyPacket(Adapter,
                                         Packet,
                                         OurPacket,
                                         PktContext);
        
    }

    return Status;
}

NDIS_STATUS
PsDupPacketContext(
    PADAPTER Adapter,
    PNDIS_PACKET Packet,
    PPNDIS_PACKET OurPacket,
    PPS_SEND_PACKET_CONTEXT *PktContext)
{                             
    NDIS_STATUS                  Status;
    BOOLEAN                      Remaining;
    PNDIS_PACKET_STACK           PacketStack;

    //
    // NDIS provides 2 ways for IMs to indicate packets. If the IM can allocate a packet stack, it should use it as
    // it is the optimal approach. In this case, we do not have to do any per-packet copying since we don't allocate
    // a new packet.
    //

    PacketStack = NdisIMGetCurrentPacketStack(Packet, &Remaining);

    if(Remaining != 0)
    {
       //
       // The packet stack has space only for 2 DWORDs. Since we are using more than 2, we need to allocate our own 
       // memory for the per-packet block. Note that we *DONT* do this when we use the NdisAllocatePacket APIs, because
       // we initialized the packet pool to already include the space for the per-packet region.
       //

       *OurPacket = Packet;

       *PktContext = (PPS_SEND_PACKET_CONTEXT) (ULONG_PTR)NdisAllocateFromBlockPool(Adapter->SendBlockPool);
       PacketStack->IMReserved[0] = (ULONG_PTR)*PktContext;

       if(!*PktContext)
       {
          Adapter->Stats.OutOfPackets ++;
          return NDIS_STATUS_RESOURCES;
       }
       else {
           (*PktContext)->Info.NdisPacket = Packet;
           (*PktContext)->OriginalPacket = 0;
           return NDIS_STATUS_SUCCESS;
       }
    }
    else 
    {
        Status = PsAllocateAndCopyPacket(Adapter,
                                         Packet,
                                         OurPacket,
                                         PktContext);
    }

    return Status;
}



//
//  Tries to classify this packet based on the port numbers. If not found, will add it to one of the flows (in Round
//  Robin fashion) and returns a pointer to that Vc
//
PGPC_CLIENT_VC
GetVcForPacket( PPS_WAN_LINK    WanLink,
                USHORT          SrcPort,
                USHORT          DstPort)
{
    PGPC_CLIENT_VC  pVc, pVc1;
    int             i, j;


    for( j = 0; j < BEVC_LIST_LEN; j++)
    {
        
        pVc = &WanLink->BeVcList[j];

        //  Let's look at the 2 VCs we have now:
        for( i = 0; i < PORT_LIST_LEN; i++)
        {
            if( (pVc->SrcPort[i] == SrcPort) && (pVc->DstPort[i] == DstPort))
                return pVc;
        }
    }

    //  Did not find in any of the VCs. Need to choose the Next VC for insertion and insert these valuse..
    pVc = &WanLink->BeVcList[WanLink->NextVc];
    WanLink->NextVc = ((WanLink->NextVc + 1) % BEVC_LIST_LEN);

    pVc->SrcPort[pVc->NextSlot] = SrcPort;
    pVc->DstPort[pVc->NextSlot] = DstPort;
    pVc->NextSlot = ((pVc->NextSlot + 1)% PORT_LIST_LEN );
    return pVc;
}



//
//  This routine returns the Src and Dst Port numbers   
BOOLEAN
GetPortNos(
    IN      PNDIS_PACKET        Packet ,
    IN      ULONG               TransportHeaderOffset,
    IN OUT  PUSHORT             pSrcPort,
    IN OUT  PUSHORT             pDstPort
    )
{
    PNDIS_BUFFER    ArpBuf , IpBuf , TcpBuf, UdpBuf, DataBuf;
    ULONG           ArpLen , IpLen , IpHdrLen , TcpLen , UdpLen, DataLen , TotalLen , TcpHeaderOffset;
    
    VOID                *ArpH;
    IPHeader UNALIGNED  *IPH;
    TCPHeader UNALIGNED *TCPH;
    UDPHeader UNALIGNED *UDPH;

    IPAddr              Src, Dst;
    BOOLEAN             bFragment;
    USHORT              SrcPort , DstPort , IPID, FragOffset ,Size;
    PVOID               GeneralVA , Data;
    ULONG               i, Ret;


    IpBuf = NULL;

    // Steps  
    // Parse the IP Packet. 
    // Look for the appropriate ports.
    // Look for the data portion and put in the Time & length there.

    if(1)
    {
        PVOID           pAddr;
    	PNDIS_BUFFER    pNdisBuf1, pNdisBuf2;
    	UINT            Len;

        NdisGetFirstBufferFromPacket(   Packet,
                                        &ArpBuf,
                                        &ArpH,
                                        &ArpLen,
                                        &TotalLen
                                    );

    	pNdisBuf1 = Packet->Private.Head;
    	NdisQueryBuffer(pNdisBuf1, &pAddr, &Len);

    	while(Len <= TransportHeaderOffset) 
	    {

        	TransportHeaderOffset -= Len;
        	NdisGetNextBuffer(pNdisBuf1, &pNdisBuf2);
        	
		    NdisQueryBuffer(pNdisBuf2, &pAddr, &Len);
        	pNdisBuf1 = pNdisBuf2;
    	}

	    /* Buffer Descriptor corresponding to Ip Packet */
	    IpBuf = pNdisBuf1;

        /* Length of this Buffer (IP buffer) */
	    IpLen = Len - TransportHeaderOffset;	

	    /* Starting Virtual Address for this buffer */
	    GeneralVA = pAddr;
	    
	    /* Virtual Address of the IP Header */
	    IPH = (IPHeader *)(((PUCHAR)pAddr) + TransportHeaderOffset);
   }

    if(!IpBuf)
         return FALSE;

    IpHdrLen = ((IPH->iph_verlen & (uchar)~IP_VER_FLAG) << 2);
    
    FragOffset = IPH->iph_offset & IP_OFFSET_MASK;
    FragOffset = net_short(FragOffset) * 8;

    bFragment = (IPH->iph_offset & IP_MF_FLAG) || (FragOffset > 0);

    // Don't want to deal with Fragmented packets right now..//
    if ( bFragment ) 
        return FALSE;


    switch (IPH->iph_protocol) 
    {
        case IPPROTO_TCP :

            if (IPH && ((USHORT)IpLen > IpHdrLen)) 
            {
                // We have more than the IP Header in this MDL //
                TCPH = (TCPHeader *) ((PUCHAR)IPH + IpHdrLen);
                TcpLen = IpLen - IpHdrLen;
                TcpBuf = IpBuf;

            } 
            else 
            {
                // TCP Header is in the next MDL //                
                NdisGetNextBuffer(IpBuf, &TcpBuf);

                if(!TcpBuf) 
                    return FALSE;

                GeneralVA = NULL;
                NdisQueryBuffer(TcpBuf,
                                &GeneralVA,
                                &TcpLen
                                );
            
                TCPH = (TCPHeader *) GeneralVA;
            }

            /* At this point, TcpBuf, TCPH and TcpLen contain the proper values */

            // Get the port numbers out.
            SrcPort = net_short(TCPH->tcp_src);
            DstPort = net_short(TCPH->tcp_dest);

            *pSrcPort = SrcPort;
            *pDstPort = DstPort;

            // If the packet is here, it means: The link on which it is being sent is <= MAX_LINK_SPEED_FOR_DRR.
            // So, it is OK to adjust the Window size if we are on an ICS box.

            if(gEnableWindowAdjustment)
            {
                USHORT _old, _new;
                ULONG _sum;

                _old = (TCPH)->tcp_window;
                _new =  1460*6;

                if( net_short( _old) < _new)
                    return TRUE;

                _new = net_short( _new );
                (TCPH)->tcp_window = _new;
                
                _sum = ((~(TCPH)->tcp_xsum) & 0xffff) + ((~_old) & 0xffff) + _new;
                _sum = (_sum & 0xffff) + (_sum >> 16);
                _sum += (_sum >> 16);
                (TCPH)->tcp_xsum = (ushort) ((~_sum) & 0xffff);
            }
            
            return TRUE;

        case IPPROTO_UDP:
        
            if (IpLen > IpHdrLen)
            {
                // We have more than the IP Header in this MDL //
                UDPH = (UDPHeader *) ((PUCHAR)IPH + IpHdrLen);
                UdpLen = IpLen - IpHdrLen;
                UdpBuf = IpBuf;
            } 
            else 
            {
                // UDP Header is in the next MDL //
                NdisGetNextBuffer(IpBuf, &UdpBuf);

                if(!UdpBuf)
                    return FALSE;

                GeneralVA = NULL;
                NdisQueryBuffer(UdpBuf,
                                &GeneralVA,
                                &UdpLen
                                );

                UDPH = (UDPHeader *) GeneralVA;
            }

             /* At this point, UdpBuf, UDPH and UdpLen contain the proper values */

            SrcPort = net_short(UDPH->uh_src);
            DstPort = net_short(UDPH->uh_dest);

            *pSrcPort = SrcPort;
            *pDstPort = DstPort;

            return TRUE;

        default:
                ;
        
    }

    return FALSE;    
}    
        

//
//  This where we get called for each Send
//


NTSTATUS
MpSend(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  PNDIS_PACKET            TheirPacket,
    IN  UINT                    Flags
    )

/*++

Routine Description:

    Received a xmit request from a legacy transport. 

Arguments:

    See the DDK...

Return Values:

    None

--*/

{
    PADAPTER                 Adapter = (PADAPTER)MiniportAdapterContext;
    NDIS_STATUS              Status;
    PNDIS_PACKET             OurPacket;
    PPS_SEND_PACKET_CONTEXT  PktContext;
    PGPC_CLIENT_VC           BeVc, Vc = NULL;
    PETH_HEADER              pAddr;
    PNDIS_BUFFER             pNdisBuf1;
    UINT                     Len;
    PUSHORT                  id;
    PPS_WAN_LINK             WanLink;

    PsStructAssert(Adapter);

    //
    // If the device is shutting down, we cannot accept any more sends.
    //

    if(IsDeviceStateOn(Adapter) == FALSE)
    {
        return NDIS_STATUS_FAILURE;
    }

    if(Adapter->MediaType == NdisMediumWan)
    {
        if(Adapter->ProtocolType == ARP_ETYPE_IP)
        {
            //
            // We should not be getting non-ip packets in the NDISWAN-IP binding.
            //
            
            PsAssert(NDIS_GET_PACKET_PROTOCOL_TYPE(TheirPacket) == NDIS_PROTOCOL_ID_TCP_IP);

            pNdisBuf1 = TheirPacket->Private.Head;

            NdisQueryBuffer(pNdisBuf1, &pAddr, &Len);

            if(Len < sizeof(ETH_HEADER))
            {
                //
                // Packet is too small. we have to fail this bogus packet.
                //

                return NDIS_STATUS_FAILURE;
            }

            //
            // Get to the wanlink using the remote address from the packet.
            //

            id = (PUSHORT) &pAddr->DestAddr[0];

            PS_LOCK(&Adapter->Lock);

            WanLink = (PPS_WAN_LINK)(g_WanLinkTable[*id]);

            if(WanLink == 0)
            {
                //
                // We received a packet for a wanlink that has already gone down.
                //

                PS_UNLOCK(&Adapter->Lock);

                return NDIS_STATUS_FAILURE;
            }

            if(WanLink->State != WanStateOpen)
            {
                //
                // We received a packet for a wanlink that has already gone down.
                //

                PS_UNLOCK(&Adapter->Lock);

                return NDIS_STATUS_FAILURE;
            }

            //
            // When we get a StatusIndication for a new WAN link, NDISWAN puts context in the remote address
            // When psched intercepts the LineUp, it overwrites NDISWAN's context with its own context. Psched
            // uses this context to get to the WanLink from the packet. (see above)
            //
            // But, when it passes the packet down to NDISWAN, it needs to plumb NDISWAN's context into the packet,
            // so that NDISWAN can see the context that it sent to us, as opposed to the context that we sent up to 
            // wanarp.
            //

            NdisMoveMemory(pAddr, 
                           &WanLink->SendHeader,
                           FIELD_OFFSET(ETH_HEADER, Type));

            //
            // We optimize psched to bypass the scheduling components when there are no flows. There are a set of 
            // scheduling components per WanLink, so to be truly optimal, we need to check the FLowCount on a specific
            // WanLink.
            //

            if( (WanLink->LinkSpeed > MAX_LINK_SPEED_FOR_DRR) && (!WanLink->CfInfosInstalled) )
            {
                // Bypass scheduling components, since there are no flows created on this
                // wanlink. Note that the UserPriority is never used over wanlinks, so we can set it to 0.
               
                PS_UNLOCK(&Adapter->Lock);

                SEND_PACKET_OVER_NIC(Adapter, 
                                    TheirPacket, 
                                    0,
                                    Status);
            }
            //
            //  Now, we are going to do either (1) DiffServ Or (2) IntServ. If the packet does not belong to either 
            //  of these categories, we will just hash it into one of the BeVcs we have and do simple DRR.
            //
            else 
            {
                //
                // There is at least one flow. we need to classify this packet. Since the flow is going 
                // via the scheduling components, we have to allocate memory for the per-packet info 
                // (if the packet-stack APIs are used) or a new packet descriptor, which will include the 
                // per-packet info (if the old NDIS APIs are used) The packet that has been passed to us is 
                // 'TheirPacket'. If the packet-stack APIs are used, then TheirPacket == OurPacket 
                // if the non packet-stack APIs are used, then OurPacket == Newly Allocated Packet. 
                // 
                // In both cases, the code after this point will just use 'OurPacket' and the right thing will happen.
                //

                if((Status = PsDupPacketContext(Adapter, TheirPacket, &OurPacket, &PktContext)) != NDIS_STATUS_SUCCESS)
                {
                    PS_UNLOCK(&Adapter->Lock);
                    
                    return Status;
                }

                // Case 1. DiffServMode //
                if(WanLink->AdapterMode == AdapterModeDiffservFlow)
                {
                    //
                    // If we are in Diffserv mode, we classify the packet based on the DSCP in the IP header.
                    //

                    // Is there atleast ONE DiffServ Flow?
                    if(Adapter->IPHeaderOffset && WanLink->pDiffServMapping)
                    {
                        IPHeader *pIpHdr;
                        UCHAR    tos;
                        
                        pIpHdr = GetIpHeader(Adapter->IPHeaderOffset, OurPacket);
                        tos    = pIpHdr->iph_tos >> 2;
                        
                        if((Vc = WanLink->pDiffServMapping[tos].Vc))
                        {
                            //
                            // We found a VC for this packet.
                            //

                            PsAssert(Vc->Adapter == Adapter);
                            PsAssert(Vc->WanLink == WanLink);
                            
                            InterlockedIncrement(&Vc->RefCount);
                            
                            SET_TOS_XSUM(OurPacket, 
                                         pIpHdr,
                                         (WanLink->pDiffServMapping[tos].ConformingOutboundDSField));
                            
                            FILL_PKT_FOR_SCHED(Adapter, 
                                               PktContext, 
                                               Vc, 
                                               OurPacket, 
                                               (WanLink->pDiffServMapping[tos].NonConformingOutboundDSField),
                                               WanLink->pDiffServMapping[tos].ConformingUserPriority,
                                               WanLink->pDiffServMapping[tos].NonConformingUserPriority,
                                               pIpHdr);
                            
                        }
                        // Could not classify packets to ANY of the DiffServ Flows. So, let's just do DRR across the BeVcs.
                        else 
                        {
                            //
                            // There are Diffserv flows installed, but not for this DSCP. Lets use the BEVCS.
                            //

                            USHORT  SrcPort, DstPort;

                            if( (WanLink->LinkSpeed <= MAX_LINK_SPEED_FOR_DRR)    &&
                                (GetPortNos( TheirPacket, Adapter->IPHeaderOffset, &SrcPort, &DstPort)))
                                Vc = GetVcForPacket( WanLink, SrcPort, DstPort);
                            else                                
                                Vc = &WanLink->BestEffortVc;

                            InterlockedIncrement(&Vc->RefCount);

                            FILL_PKT_FOR_SCHED(Adapter,
                                               PktContext,
                                               Vc,
                                               OurPacket,
                                               Vc->IPPrecedenceNonConforming,
                                               Vc->UserPriorityConforming,
                                               Vc->UserPriorityNonConforming,
                                               pIpHdr);

                        }
                        
                    }
                    // No, there is not One, let's just do DRR across the BeVcs.
                    else 
                    {
                        //
                        // We are in Diffserv mode, but no Diffserv flows are created as yet. Let's use the BEVCS.
                        //
                        USHORT  SrcPort, DstPort;

                        if( (WanLink->LinkSpeed <= MAX_LINK_SPEED_FOR_DRR) &&
                            (GetPortNos( TheirPacket, Adapter->IPHeaderOffset, &SrcPort, &DstPort)))
                            Vc = GetVcForPacket( WanLink, SrcPort, DstPort);
                        else
                            Vc = &WanLink->BestEffortVc;

                        InterlockedIncrement(&Vc->RefCount);

                        FILL_PKT_FOR_SCHED(Adapter,
                                           PktContext,
                                           Vc,
                                           OurPacket,
                                           Vc->IPPrecedenceNonConforming,
                                           Vc->UserPriorityConforming,
                                           Vc->UserPriorityNonConforming,
                                           NULL);
                    }
                    
                    PS_UNLOCK(&Adapter->Lock);
                }
                // Case 2. IntServMode
                else 
                {
                    USHORT  SrcPort=0, DstPort=0;
                    //
                    // We are in RSVP mode, and we need to go to the GPC to classify the packet. 
                    // We already have a pointer to our WanLink. But, the wanlink could go away 
                    // when we release the lock and try to classify the packet. So, we take
                    // a ref on the BestEffortVc for the WanLink.
                    //


                    if( (WanLink->LinkSpeed <= MAX_LINK_SPEED_FOR_DRR)   &&
                        (GetPortNos( TheirPacket, Adapter->IPHeaderOffset, &SrcPort, &DstPort)))                    
                        BeVc = GetVcForPacket( WanLink, SrcPort, DstPort);
                    else
                        BeVc = &WanLink->BestEffortVc;
                    
                    InterlockedIncrement(&BeVc->RefCount);

                    PS_UNLOCK(&Adapter->Lock);

                    if( WanLink->CfInfosInstalled )
                        Vc = GetVcByClassifyingPacket(Adapter,  &WanLink->InterfaceID, OurPacket);

                    if(!Vc)
                    {
                        Vc = BeVc;
                    }
                    else 
                    {
                        DerefClVc(BeVc);
                    }

                    FILL_PKT_FOR_SCHED(Adapter,
                                       PktContext,
                                       Vc,
                                       OurPacket,
                                       Vc->IPPrecedenceNonConforming,
                                       Vc->UserPriorityConforming,
                                       Vc->UserPriorityNonConforming,
                                       NULL);
                }

                //
                // There is at least one flow - We need to send this packet via the scheduling
                // components. 
                //

                if((Vc->ClVcState == CL_CALL_COMPLETE) ||
                   (Vc->ClVcState == CL_MODIFY_PENDING)) 
                {
                    SEND_PACKET_VIA_SCHEDULER(PktContext, Vc, Adapter, OurPacket);
                }
                else
                {
                    //
                    // Deref the ref that was added by the GPC.
                    //
                    
                    DerefClVc(Vc);
                    
                    PsDbgSend(DBG_FAILURE, DBG_SEND, MP_SEND, NOT_READY, Adapter, Vc, TheirPacket, OurPacket);
                    
                    if(PktContext->OriginalPacket)
                    {
                        NdisFreePacket(OurPacket);
                    }
                    else 
                    {
                        NdisFreeToBlockPool((PUCHAR)PktContext);
                    }
                    
                    return(NDIS_STATUS_FAILURE);
                }
            }
        }
        //
        // Forget about it. It's a Non-IP packet
        //
        else 
        {
            //
            // For non IP adapters, we just send over the NIC. Note that we don't create a best effort
            // Vc for such adapters. The only thing that we lose here is the ability to mark 802.1p on
            // such packets (we don't have a Vc, so we cannot supply a UserPriority value to the below
            // macro. But that is okay, since 802.1p is meaningful only in non LAN adapters.
            //

            SEND_PACKET_OVER_NIC(Adapter, 
                                 TheirPacket, 
                                 0, 
                                 Status);
        }
    }
    else 
    {
        //
        // We have received a send at our non WAN binding.
        //

        if(!Adapter->CfInfosInstalled                   &&
           Adapter->BestEffortLimit == UNSPECIFIED_RATE &&
           TsCount == 0 )
        {
            // There is no point in trying to classify if there are no flows installed 

            Vc = &Adapter->BestEffortVc;
            
            PsAssert(Vc->ClVcState == CL_CALL_COMPLETE);

            //
            // Bypass scheduling components.
            //
            SEND_PACKET_OVER_NIC(Adapter, 
                                 TheirPacket, 
                                 Vc->UserPriorityConforming, 
                                 Status);
        }
        else 
        {
            //
            // There is at least one flow, or we are in LimitedBestEffort mode. Let's try to classify the Vc.
            // In this case, the packet will have to go via the scheduling components.
            //
            //
            // Since the flow is going via the scheduling components, we have to allocate the per-packet info.
            // (if the new NDIS APIs are used) or a new packet descriptor, which will include the per-packet info
            // (if the old NDIS APIs are used)
            //

            if(Adapter->AdapterMode == AdapterModeDiffservFlow)
            {
                //
                // We are in the diffserv mode. We don't have to use the GPC to classify packets. 
                // For all IP packets, classify on the TOS byte.
                //

                PS_LOCK(&Adapter->Lock);
        
                if(NDIS_GET_PACKET_PROTOCOL_TYPE(TheirPacket) == NDIS_PROTOCOL_ID_TCP_IP &&
                   Adapter->IPHeaderOffset &&
                   Adapter->pDiffServMapping) 
                {
                    UCHAR    tos;
                    IPHeader *pIpHdr = 0;
        
                    pIpHdr = GetIpHeader(Adapter->IPHeaderOffset, TheirPacket);
                    tos = pIpHdr->iph_tos >> 2;
        
                    if((Vc = Adapter->pDiffServMapping[tos].Vc))
                    {
                        PsAssert(Vc->Adapter == Adapter);
        

                        if((Status = PsDupPacketContext(Adapter, 
                                                        TheirPacket, 
                                                        &OurPacket, 
                                                        &PktContext)) != NDIS_STATUS_SUCCESS)
                        {
                            PS_UNLOCK(&Adapter->Lock);
                            return Status;
                        }
                        
                        InterlockedIncrement(&Vc->RefCount);

                        SET_TOS_XSUM(OurPacket,
                                     pIpHdr, 
                                     (Adapter->pDiffServMapping[tos].ConformingOutboundDSField));

                        FILL_PKT_FOR_SCHED(Adapter, 
                                           PktContext, 
                                           Vc, 
                                           OurPacket, 
                                           (Adapter->pDiffServMapping[tos].NonConformingOutboundDSField),
                                           Adapter->pDiffServMapping[tos].ConformingUserPriority,
                                           Adapter->pDiffServMapping[tos].NonConformingUserPriority,
                                           pIpHdr);
                    }
                    else 
                    {
                        if( ( Adapter->MaxOutstandingSends == 0xffffffff)   &&
                            ( TsCount == 0))
                        {
                            Vc = &Adapter->BestEffortVc;

                            PsAssert(Vc->ClVcState == CL_CALL_COMPLETE);

                            //
                            // Bypass scheduling components.
                            //

                            PS_UNLOCK(&Adapter->Lock);
                            
                            SEND_PACKET_OVER_NIC(Adapter,
                                                 TheirPacket,
                                                 Vc->UserPriorityConforming,
                                                 Status);
                        }
                        
                        Vc = &Adapter->BestEffortVc;
                        
                        if((Status = PsDupPacketContext(Adapter, 
                                                        TheirPacket, 
                                                        &OurPacket, 
                                                        &PktContext)) != NDIS_STATUS_SUCCESS)
                        {
                            PS_UNLOCK(&Adapter->Lock);
                            return Status;
                        }
                        
                        InterlockedIncrement(&Vc->RefCount);

                        FILL_PKT_FOR_SCHED(Adapter,
                                           PktContext,
                                           Vc,
                                           OurPacket,
                                           Vc->IPPrecedenceNonConforming,
                                           Vc->UserPriorityConforming,
                                           Vc->UserPriorityNonConforming,
                                           NULL);


                    }
        
                }
                else 
                {
                    //
                    // We are in Diffserv mode, but there are no DiffServ Vcs, or it's not an IP
                    // packet. Send over the Adapter's BE Vc.
                    //

                    Vc = &Adapter->BestEffortVc;

                    if((Status = PsDupPacketContext(    Adapter, 
                                                        TheirPacket, 
                                                        &OurPacket, 
                                                        &PktContext)) != NDIS_STATUS_SUCCESS)
                    {
                        PS_UNLOCK(&Adapter->Lock);
                        return Status;
                    }

                    InterlockedIncrement(&Vc->RefCount);

                    FILL_PKT_FOR_SCHED(Adapter,
                                       PktContext,
                                       Vc,
                                       OurPacket,
                                       Vc->IPPrecedenceNonConforming,
                                       Vc->UserPriorityConforming,
                                       Vc->UserPriorityNonConforming,
                                       NULL);
                }

                PS_UNLOCK(&Adapter->Lock);
                
            }
            else 
            {
                // We are in RSVP mode. Let's classify with the GPC.

                Vc = GetVcByClassifyingPacket(Adapter, &Adapter->InterfaceID, TheirPacket);

                if( !Vc) 
                {
                    if( (Adapter->MaxOutstandingSends == 0xffffffff)    &&
                        (TsCount == 0))
                    {
                        Vc = &Adapter->BestEffortVc;
                
                        PsAssert(Vc->ClVcState == CL_CALL_COMPLETE);

                        //
                        // Bypass scheduling components.
                        //
                        SEND_PACKET_OVER_NIC(Adapter, 
                                             TheirPacket, 
                                             Vc->UserPriorityConforming, 
                                             Status);
                    }

                    // We will be doing DRR on this adapter; so send pkt on BeVc 
                    Vc = &Adapter->BestEffortVc;

                    InterlockedIncrement(&Vc->RefCount);
                }

                if((Status = PsDupPacketContext(Adapter, TheirPacket, &OurPacket, &PktContext)) != NDIS_STATUS_SUCCESS)
                {
                    return Status;
                }

                FILL_PKT_FOR_SCHED(Adapter,
                                   PktContext,
                                   Vc,
                                   OurPacket,
                                   Vc->IPPrecedenceNonConforming,
                                   Vc->UserPriorityConforming,
                                   Vc->UserPriorityNonConforming,
                                   NULL);

            }

            if((Vc->ClVcState == CL_CALL_COMPLETE) 	||
               (Vc->ClVcState == CL_MODIFY_PENDING)	||
               (Vc->ClVcState == CL_INTERNAL_CALL_COMPLETE)) 
            {
                SEND_PACKET_VIA_SCHEDULER(PktContext, Vc, Adapter, OurPacket);
            }
            else
            {
                //
                // Deref the ref that was added by the GPC.
                //
                
                DerefClVc(Vc);
                
                PsDbgSend(DBG_FAILURE, DBG_SEND, MP_SEND, NOT_READY, Adapter, Vc, TheirPacket, OurPacket);
                
                if(PktContext->OriginalPacket)
                {
                    NdisFreePacket(OurPacket);
                }
                else 
                {
                    NdisFreeToBlockPool((PUCHAR)PktContext);
                }
                
                
                return(NDIS_STATUS_FAILURE);
            }
        }
    } 
}


VOID
ClSendComplete(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNDIS_PACKET            Packet,
    IN  NDIS_STATUS             Status
    )

/*++

Routine Description:

    Completion routine for NdisSendPackets. 
    Does most of the work for cleaning up after a send.

    If necessary, call the PSA's send packet complete function

Arguments:

    See the DDK...

Return Values:

    None

--*/

{
    PGPC_CLIENT_VC          Vc;
    PADAPTER                Adapter = (PADAPTER)ProtocolBindingContext;
    PPS_SEND_PACKET_CONTEXT PktContext;
    PNDIS_PACKET            XportPacket;
    HANDLE                  PoolHandle;

    //
    // Determine if the packet we are completing is the one we allocated. If so, get
    // the original packet from the reserved area and free the allocated packet. If this
    // is the packet that was sent down to us then just complete the packet.
    //

    PoolHandle = NdisGetPoolFromPacket(Packet);

    if(PoolHandle != Adapter->SendPacketPool)
    {
        PNDIS_PACKET_STACK PacketStack;
        BOOLEAN            Remaining;

        PacketStack = NdisIMGetCurrentPacketStack(Packet, &Remaining);

        PsAssert(Remaining != 0);

        PktContext = (PPS_SEND_PACKET_CONTEXT) PacketStack->IMReserved[0];

        if(PktContext != 0)
        {
            //
            // This packet went via the scheduling components.
            //

            PsAssert(PktContext->Vc);
            Vc = PktContext->Vc;
            PsDbgSend(DBG_INFO, DBG_SEND, CL_SEND_COMPLETE, ENTER, Adapter, Vc, Packet, 0);
            PsAssert(Vc->Adapter == Adapter);
            if(Vc->SendComplete)
                (*Vc->SendComplete)(Vc->SendCompletePipeContext, Packet);
            DerefClVc(Vc);
            NdisFreeToBlockPool((PUCHAR)PktContext);
        }

        NdisMSendComplete(Adapter->PsNdisHandle,
                          Packet,
                          Status);
    }
    else 
    {
        //
        // get the pointer to the upper layer's packet. Reinit the packet struct and
        // push it back on the adapter's packet SList. Remove the reference incurred
        // when the packet was handled by MpSend
        //

        PktContext = PS_SEND_PACKET_CONTEXT_FROM_PACKET(Packet);


        //
        // Call the scheduler if necessary
        //
        
        if(PktContext->Vc)
        {
            
            // 
            // Some packets never went through the scheduler.
            //
            Vc = PktContext->Vc;
            
            PsDbgSend(DBG_INFO, DBG_SEND, CL_SEND_COMPLETE, ENTER, Adapter, Vc, Packet, 0);
            
            PsAssert(Vc->Adapter == Adapter);
            
            if(Vc->SendComplete)
            {
                (*Vc->SendComplete)(Vc->SendCompletePipeContext, Packet);
            }
            
            //
            // We have taken a ref on the VCs when we sent the packets
            // through the scheduling components. Now is the time to 
            // Deref them
            //

            DerefClVc(Vc);
        }
        else
        {
            PsDbgSend(DBG_INFO, DBG_SEND, CL_SEND_COMPLETE, ENTER, Adapter, 0, Packet, 0);
        }
        
        XportPacket = PktContext->OriginalPacket;
        
        NdisIMCopySendCompletePerPacketInfo(XportPacket, Packet);
        
        NdisFreePacket(Packet);
        
        NdisMSendComplete(Adapter->PsNdisHandle, 
                          XportPacket,
                          Status);
    }
        
} // ClSendComplete


VOID
DropPacket(
    IN HANDLE PipeContext,
    IN HANDLE FlowContext,
    IN PNDIS_PACKET Packet,
    IN NDIS_STATUS Status
    )

/*++

Routine Description:

    Drop a packet after it was queued by the scheduler.

Arguments:

    PipeContext -       Pipe context (adapter)
    FlowContext -       Flow context (adapter VC)
    Packet -            Packet to drop
    Status -            Return code to return to NDIS
                        
Return Values:          

    None

--*/

{
    PGPC_CLIENT_VC          Vc = (PGPC_CLIENT_VC)FlowContext;
    PADAPTER                Adapter = (PADAPTER)PipeContext;
    PPS_SEND_PACKET_CONTEXT PktContext;
    PNDIS_PACKET            XportPacket;
    HANDLE                  PoolHandle;

    //
    // Determine if the packet we are completing is the one we allocated. If so, get
    // the original packet from the reserved area and free the allocated packet. If this
    // is the packet that was sent down to us then just complete the packet.
    //

    PoolHandle = NdisGetPoolFromPacket(Packet);

    if(PoolHandle != Adapter->SendPacketPool)
    {
        PNDIS_PACKET_STACK PacketStack;
        BOOLEAN            Remaining;

        PacketStack = NdisIMGetCurrentPacketStack(Packet, &Remaining);

        PsAssert(Remaining != 0);

        PktContext = (PPS_SEND_PACKET_CONTEXT) PacketStack->IMReserved[0];

        PsAssert(PktContext != 0);
        PsAssert(Vc == PktContext->Vc);
        PsAssert(Adapter == Vc->Adapter);
        NdisFreeToBlockPool((PUCHAR)PktContext);

        NdisMSendComplete(Adapter->PsNdisHandle,
                          Packet,
                          Status);

    }
    else 
    {    
        PktContext = PS_SEND_PACKET_CONTEXT_FROM_PACKET(Packet);

        PsAssert(PktContext != 0);
        PsAssert(Vc == PktContext->Vc);
        PsAssert(Adapter == Vc->Adapter);

        XportPacket = PktContext->OriginalPacket;

        NdisFreePacket(Packet);

        NdisMSendComplete(Adapter->PsNdisHandle,
                          XportPacket,
                          Status);
    }

    Vc->Stats.DroppedPackets ++;

    PsDbgSend(DBG_INFO, DBG_SEND, DROP_PACKET, ENTER, Adapter, Vc, Packet, 0);

    DerefClVc(Vc);

} // DropPacket


char*
ReturnByteAtOffset( PNDIS_PACKET    pNdisPacket, ULONG  Offset)
{
    PVOID         VA;
    PNDIS_BUFFER  pNdisBuf1, pNdisBuf2;
    UINT          Len;

    pNdisBuf1 = pNdisPacket->Private.Head;
    NdisQueryBuffer(pNdisBuf1, &VA, &Len);

    while(Len <= Offset) 
    {
        Offset -= Len;
        NdisGetNextBuffer(pNdisBuf1, &pNdisBuf2);
        NdisQueryBuffer(pNdisBuf2, &VA, &Len);
        pNdisBuf1 = pNdisBuf2;
    }

    return (char*)(((char*)VA) + Offset);
}


PGPC_CLIENT_VC FASTCALL
GetVcByClassifyingPacket(
    PADAPTER Adapter,
    PTC_INTERFACE_ID pInterfaceID,
    PNDIS_PACKET OurPacket
    )
/*+++


---*/
{
    CLASSIFICATION_HANDLE  ClassificationHandle;
    PGPC_CLIENT_VC         Vc = NULL;
#if CBQ
    PCLASS_MAP_CONTEXT_BLK pClBlk = NULL;
#endif
    NDIS_STATUS            Status;
    ULONG                  ProtocolType;

    //
    // We are in RSVP mode - Use the GPC to classify the packet. If the GPC wants to return a Vc, it will
    // return with a ref. 
    //

    ClassificationHandle = (CLASSIFICATION_HANDLE)
        PtrToUlong(NDIS_PER_PACKET_INFO_FROM_PACKET(OurPacket, ClassificationHandlePacketInfo));

    if (ClassificationHandle)
   {

        PsAssert(GpcEntries.GpcGetCfInfoClientContextHandler);
    
        Vc =  GpcEntries.GpcGetCfInfoClientContextWithRefHandler(GpcQosClientHandle, 
                                                                 ClassificationHandle,
                                                                 FIELD_OFFSET(GPC_CLIENT_VC, RefCount));

#if CBQ
        pClBlk = NULL;
        Status = GpcEntries.GpcGetCfInfoClientContextHandler(GpcClassMapClientHandle,
                                                             ClassificationHandle,
                                                             &pClBlk);
        if(pClBlk) 
        {
            PktContext->Info.ClassMapContext = pClBlk->ComponentContext;
        }
#endif

        //
        // If we got a Vc that was not destined for this adapter, we have to reject it.
        //

        if(Vc)
        {
            if(Vc->Adapter != Adapter)
            {
                DerefClVc(Vc);
            }
            else
                return Vc;
        }
    }

    //        
    // Let's classify this packet since we did not get a Classification ID or a proper Vc.
    //
                                  
    PsAssert(GpcEntries.GpcClassifyPacketHandler);

    switch(NDIS_GET_PACKET_PROTOCOL_TYPE(OurPacket))
    {
        case NDIS_PROTOCOL_ID_TCP_IP:
            ProtocolType = GPC_PROTOCOL_TEMPLATE_IP;
            break;
        case NDIS_PROTOCOL_ID_IPX:
            ProtocolType = GPC_PROTOCOL_TEMPLATE_IPX;
            break;
        default:
            ProtocolType = GPC_PROTOCOL_TEMPLATE_NOT_SPECIFIED;
            break;
    }

    //
    //  If the adapter type is 802.5 (Token Ring), then the MAC header can be of variable size.
    //  The format of the MAC header is as follows:
    //  +---------------------+-------------+----------+-----------
    //  | 2 + 6 (DA) + 6 (SA) | Optional RI | 8 (SNAP) |    IP
    //  +---------------------+-------------+----------+-----------
    //  Optional RI is present if and only if RI bit as part of SA is set.
    //  When RI is present, its length is give by the lower 5 bits of the 15th byte.

    //  1. Get the VA for the 9th and the 15th bytes.
    //  2. If RI if not present, Offset = 14 + 6.
    //  3. If present, Offset = 14 + 6 + RI-Size.

    if(Adapter->MediaType == NdisMedium802_5)
    {
	    PNDIS_BUFFER			pTempNdisBuffer;
	    PUCHAR					pHeaderBuffer;
        ULONG					BufferLength;
	    ULONG					TotalLength;
	    ULONG                   IpOffset;

	    NdisGetFirstBufferFromPacket(   OurPacket, 
                        				&pTempNdisBuffer, 
                        				&pHeaderBuffer,
                        				&BufferLength,
                        				&TotalLength);

        ASSERT( BufferLength >= 15);                        				    

        if( (*(ReturnByteAtOffset(OurPacket, 8)) & 0x80) == 0)
            IpOffset = 14 + 8;
        else
            IpOffset = 14 + 8 + (*(ReturnByteAtOffset(OurPacket, 14)) & 0x1f);

        Status = GpcEntries.GpcClassifyPacketHandler(
                   GpcQosClientHandle,
                   ProtocolType,
                   OurPacket,
                   IpOffset,
                   pInterfaceID,
                   (PGPC_CLIENT_HANDLE)&Vc,
                   &ClassificationHandle);

    }
    else
    {

        Status = GpcEntries.GpcClassifyPacketHandler(
                               GpcQosClientHandle,
                               ProtocolType,
                               OurPacket,
        				//	This is basically to cover up a bug in wandrv.sys, which gives bogus frame header sizes. We look at the
                               //	Ip Header offset supplied by the protocol above for IP packets only, as we are saving only those for the
                               //	time being.
                               ((NDIS_GET_PACKET_PROTOCOL_TYPE(OurPacket) == NDIS_PROTOCOL_ID_TCP_IP) && (Adapter->IPHeaderOffset))
                               		? (Adapter->IPHeaderOffset)
                               		: Adapter->HeaderSize,
                               pInterfaceID,
                               (PGPC_CLIENT_HANDLE)&Vc,
                               &ClassificationHandle);

    }                           

    if(Status == GPC_STATUS_SUCCESS)
    {
        //
        // If we have succeeded, we must get a Classification Handle
        //
        PsAssert(ClassificationHandle != 0);

        //
        // The Classification succeeded. If we found a ClassificationHandle
        // then we must write it in the packet so that anyone below us can use
        // it. The very fact that we are here indicates that we did not start
        // with a Classification handle or we got a bad one. So, we need not 
        // worry about over writing the classification handle in the packet.
        //

        NDIS_PER_PACKET_INFO_FROM_PACKET(OurPacket, ClassificationHandlePacketInfo) = UlongToPtr(ClassificationHandle);
        
        Vc =  GpcEntries.GpcGetCfInfoClientContextWithRefHandler(GpcQosClientHandle, 
                                                                 ClassificationHandle,
                                                                 FIELD_OFFSET(GPC_CLIENT_VC, RefCount));

#if CBQ
        //
        // Get the CBQ class map context & store it in the 
        // packet. No point doing this if the first classification
        // failed.
        //

        pClBlk = NULL;
        Status = GpcEntries.GpcGetCfInfoClientContextHandler(GpcClassMapClientHandle,
                                                             ClassificationHandle,
                                                             &pClBlk);

        if(pClBlk) 
        {
            PktContext->Info.ClassMapContext = pClBlk->ComponentContext;
        }
#endif
    }

    if(Vc && Vc->Adapter != Adapter)
    {
        //
        // We have used the GPC APIs that return a Vc with a ref. We have to deref here, because we got a wrong Vc
        // for this adapter.
        //
        
        DerefClVc(Vc);

        return NULL;
    }

    return Vc;
}

VOID
ClCoSendComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolVcContext,
    IN  PNDIS_PACKET Packet
    )
{
    PGPC_CLIENT_VC          Vc = (PGPC_CLIENT_VC) ProtocolVcContext;

    ClSendComplete(Vc->Adapter,
                   Packet,
                   Status);
} // ClCoSendComplete

/* end send.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\schedt.c ===
/*++
Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    schedt.c

Abstract:
    Psched Tracing support

Author:
    Rajesh Sundaram (rajeshsu) 01-Aug-1998.

Environment:

    Kernel Mode

Revision History:

--*/
#include "psched.h"
#pragma hdrstop

//
// Globals
//

NDIS_SPIN_LOCK         GlobalLoggingLock;
ULONG                  SchedTraceIndex;
ULONG                  SchedBufferSize;
ULONG                  SchedTraced;
UCHAR                  *SchedTraceBuffer;
ULONG                  SchedBufferStart;
ULONG                  SchedTraceBytesUnread;
ULONG                  SchedTraceThreshold;
PVOID                  SchedTraceThreshContext;
SCHEDTRACE_THRESH_PROC SchedTraceThreshProc;
BOOLEAN                TraceBufferAllocated;

VOID
SchedInitialize(
    ULONG BufferSize)
{

    SchedBufferSize = BufferSize;

    TraceBufferAllocated = FALSE;

    PsAllocatePool(SchedTraceBuffer, SchedBufferSize, PsMiscTag);

    if(SchedTraceBuffer){

        TraceBufferAllocated = TRUE;
        NdisAllocateSpinLock(&GlobalLoggingLock);
    }
    else {
    
        TraceBufferAllocated = FALSE;
    }
}

VOID
SchedDeInitialize(
)
{
    if(TraceBufferAllocated) 
    {
        PsFreePool(SchedTraceBuffer);
        
        TraceBufferAllocated = FALSE;
    }
        
    NdisFreeSpinLock(&GlobalLoggingLock);
}


VOID
DbugTraceSetThreshold(
    ULONG       Threshold,
    PVOID       Context,
    SCHEDTRACE_THRESH_PROC ThreshProc)
{
    ULONG bytesToCopyAtEnd;
    ULONG bytesToCopyAtStart;

    NdisAcquireSpinLock(&GlobalLoggingLock);

    SchedTraceThreshProc = ThreshProc;
    SchedTraceThreshold = (Threshold <= SchedBufferSize) ? Threshold : SchedBufferSize;
    SchedTraceThreshContext = Context;

    if ((SchedTraceThreshContext != NULL) && (SchedTraceBytesUnread >= SchedTraceThreshold)) {
        SchedTraceThreshContext = NULL;
        NdisReleaseSpinLock(&GlobalLoggingLock);
        (*ThreshProc)(Context);
    }
    else {
        NdisReleaseSpinLock(&GlobalLoggingLock);
    }
} 


VOID
DbugReadTraceBuffer(
    PUCHAR      Buffer,
    ULONG       BytesToRead,
    PULONG      BytesRead
    )
{
    ULONG bytesToCopyAtEnd;
    ULONG bytesToCopyAtStart;
    ULONG bytesToCopy;
    ULONG startIndex;

    // Copy the most recently added bytes to the user buffer.  If BytesToRead is less than
    // the number of unread bytes in the trace buffer, the older bytes are lost.  This
    // ensures that the last record in the user buffer is complete (as long as the user
    // buffer is big enough to accommodate at least that one record).

    NdisAcquireSpinLock(&GlobalLoggingLock);

    bytesToCopy = (SchedTraceBytesUnread <= BytesToRead) ? SchedTraceBytesUnread : BytesToRead;
    startIndex = (bytesToCopy  > SchedTraceIndex) ?
            SchedTraceIndex + SchedBufferSize - bytesToCopy :
            SchedTraceIndex - bytesToCopy;

    if ((startIndex + bytesToCopy) > SchedBufferSize) {
        bytesToCopyAtEnd = SchedBufferSize - startIndex;
        bytesToCopyAtStart = bytesToCopy - bytesToCopyAtEnd;
        RtlCopyMemory(Buffer, &SchedTraceBuffer[startIndex], bytesToCopyAtEnd);
        RtlCopyMemory(Buffer + bytesToCopyAtEnd, &SchedTraceBuffer[0], bytesToCopyAtStart); 
    }
    else {
        bytesToCopyAtEnd = bytesToCopy;
        RtlCopyMemory(Buffer, &SchedTraceBuffer[startIndex], bytesToCopy);
    }

    SchedTraceBytesUnread = 0;
    *BytesRead = bytesToCopy;
    NdisReleaseSpinLock(&GlobalLoggingLock);

} 


NTSTATUS
WriteRecord(
    UCHAR * Record,
    ULONG   Bytes
    )
{
    ULONG bytesToCopyAtEnd;
    ULONG bytesToCopyAtStart;
    SCHEDTRACE_THRESH_PROC ThreshProc;
    PVOID Context;

    if(!TraceBufferAllocated){

        return(STATUS_UNSUCCESSFUL);
    }

    NdisAcquireSpinLock(&GlobalLoggingLock);

    if((SchedTraceIndex + Bytes) > SchedBufferSize){
        bytesToCopyAtEnd = SchedBufferSize - SchedTraceIndex;
        bytesToCopyAtStart = Bytes - bytesToCopyAtEnd;
        RtlCopyMemory(&SchedTraceBuffer[SchedTraceIndex], Record, bytesToCopyAtEnd);
        RtlCopyMemory(&SchedTraceBuffer[0], (UCHAR *)Record + bytesToCopyAtEnd, bytesToCopyAtStart); 
        SchedTraceIndex = bytesToCopyAtStart;
        SchedTraced += Bytes;
    }
    else{
        bytesToCopyAtEnd = Bytes;
        RtlCopyMemory(&SchedTraceBuffer[SchedTraceIndex], Record, Bytes);
        SchedTraceIndex += Bytes;
        SchedTraced += Bytes;
    }

    SchedTraceBytesUnread += Bytes;
    if (SchedTraceBytesUnread > SchedBufferSize) {
        SchedTraceBytesUnread = SchedBufferSize;
    }

    if ((SchedTraceThreshContext != NULL) && (SchedTraceBytesUnread >= SchedTraceThreshold)) {
        ThreshProc = SchedTraceThreshProc;
        Context = SchedTraceThreshContext;
        SchedTraceThreshContext = NULL;
        NdisReleaseSpinLock(&GlobalLoggingLock);
        (*ThreshProc)(Context);
    }
    else {
        NdisReleaseSpinLock(&GlobalLoggingLock);
    }
    return(STATUS_SUCCESS);
}

#define ClearRecord(x, y) \
            RtlFillMemory(x, y, 0)

VOID
DbugSchedString(char *format, ...)
{
    TRACE_RECORD_STRING record;
    CHAR buffer[TRACE_STRING_LENGTH];
    va_list va;

    va_start(va, format);
    _vsnprintf(buffer, TRACE_STRING_LENGTH-1, format, va);
    va_end(va);

    ClearRecord(&record, sizeof(TRACE_RECORD_STRING));

    record.Preamble = TRACE_PREAMBLE;
    record.RecordType = RECORD_TSTRING;
    PsGetCurrentTime(&record.Now);
    strncpy(record.StringStart, buffer, TRACE_STRING_LENGTH);

    WriteRecord((UCHAR *)&record, sizeof(TRACE_RECORD_STRING));
    return;
}

VOID
DbugRecv(
    ULONG Event,
    ULONG Action,
    PVOID Adapter,
    PNDIS_PACKET Packet1,
    PNDIS_PACKET Packet2
    )
{
    TRACE_RECORD_RECV record;

    ClearRecord(&record, sizeof(TRACE_RECORD_RECV));

    record.Preamble = TRACE_PREAMBLE;
    record.RecordType = RECORD_RECV;
    PsGetCurrentTime(&record.Now);
    record.Event = Event;
    record.Action = Action;
    record.Adapter = Adapter;
    record.Packet1 = Packet1;
    record.Packet2 = Packet2;

    WriteRecord((UCHAR *)&record, sizeof(TRACE_RECORD_RECV));
}

VOID
DbugSend(
    ULONG Event,
    ULONG Action,
    PVOID Adapter,
    PVOID Vc,
    PNDIS_PACKET Packet1,
    PNDIS_PACKET Packet2
    )
{
    TRACE_RECORD_SEND record;

    ClearRecord(&record, sizeof(TRACE_RECORD_SEND));

    record.Preamble = TRACE_PREAMBLE;
    record.RecordType = RECORD_SEND;
    PsGetCurrentTime(&record.Now);
    record.Event = Event;
    record.Action = Action;
    record.Adapter = Adapter;
    record.Vc = Vc;
    record.Packet1 = Packet1;
    record.Packet2 = Packet2;

    WriteRecord((UCHAR *)&record, sizeof(TRACE_RECORD_SEND));
}

VOID DbugOid(
    ULONG Action,
    ULONG Local,
    ULONG PTState,
    ULONG MPState,
    PVOID Adapter,
    ULONG Oid,
    ULONG Status
    )
{
    TRACE_RECORD_OID record;

    ClearRecord(&record, sizeof(TRACE_RECORD_OID));

    record.Preamble = TRACE_PREAMBLE;
    record.RecordType = RECORD_OID;
    PsGetCurrentTime(&record.Now);
    record.Action = Action;
    record.Local = Local;
    record.Oid = Oid;
    record.PTState = PTState;
    record.MPState = MPState;
    record.Adapter = Adapter;
    record.Status = Status;

    WriteRecord((UCHAR *)&record, sizeof(TRACE_RECORD_OID));
}

VOID
DbugSchedPkts(
    ULONG CallingFunction,
    PVOID VC,
    PNDIS_PACKET Packet,
    ULONG Action,
    ULONG PacketLength)
{
    TRACE_RECORD_PKT record;

    ClearRecord(&record, sizeof(TRACE_RECORD_PKT));

    record.Preamble = TRACE_PREAMBLE;
    record.RecordType = RECORD_PKT;
    record.CallingFunction = CallingFunction;
    PsGetCurrentTime(&record.Now);
    record.VC = VC;
    record.Packet = Packet;
    record.Action = Action;
    record.PacketLength = PacketLength;
    
    WriteRecord((UCHAR *)&record, sizeof(TRACE_RECORD_PKT));
}

VOID
DbugSched(
    ULONG SchedulerComponent,
    ULONG Action,
    PVOID VC,
    PNDIS_PACKET Packet,
    ULONG PacketLength,
    ULONG Priority,
    LONGLONG ArrivalTime,
    LONGLONG ConformanceTime,
    ULONG PacketsInComponent,
    ULONG BytesInComponent
    )
{
    TRACE_RECORD_SCHED record;

    ClearRecord(&record, sizeof(TRACE_RECORD_SCHED));

    record.Preamble = TRACE_PREAMBLE;
    record.RecordType = RECORD_SCHED;
    record.SchedulerComponent = SchedulerComponent;
    PsGetCurrentTime(&record.Now);
    record.Action = Action;
    record.VC = VC;
    record.Packet = Packet;
    record.PacketLength = PacketLength;
    record.Priority = Priority;
    record.ArrivalTime = ArrivalTime,
    record.ConformanceTime = ConformanceTime;
    record.PacketsInComponent = PacketsInComponent;
    record.BytesInComponent = BytesInComponent;
    
    WriteRecord((UCHAR *)&record, sizeof(TRACE_RECORD_SCHED));
}

VOID
DbugComponentSpecificRec(
    ULONG Component,
    PVOID Data,
    ULONG Length)
{
    TRACE_RECORD_COMPONENT_SPECIFIC record;

    ClearRecord(&record, sizeof(TRACE_RECORD_COMPONENT_SPECIFIC));

    record.Preamble = TRACE_PREAMBLE;
    record.RecordType = RECORD_COMPONENT_SPECIFIC;
    record.SchedulerComponent = Component;
    PsGetCurrentTime(&record.Now);
    record.Length = (Length > MAX_RECORD_DATA) ? MAX_RECORD_DATA : Length;
    RtlCopyMemory(record.Data, Data, record.Length);
    
    WriteRecord((UCHAR *)&record, record.Length + FIELD_OFFSET(TRACE_RECORD_COMPONENT_SPECIFIC, Data));
}

ULONG
SchedtGetBufferSize()
{
    return SchedBufferSize;
}

ULONG
SchedtGetBytesUnread() 
{
    return SchedTraceBytesUnread;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\status.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    status.c

Abstract:

    status indications handled in here....

Author:

    Charlie Wickham (charlwi)  20-Jun-1996
    Rajesh Sundaram (rajeshsu) 01-Aug-1998.

Environment:

    Kernel Mode

Revision History:

--*/

#include "psched.h"
#pragma hdrstop

/* External */

/* Static */

/* Forward */

VOID
ClStatusIndication(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS GeneralStatus,
    IN  PVOID       StatusBuffer,
    IN  UINT        StatusBufferSize
    );

VOID
ClStatusIndicationComplete(
    IN  NDIS_HANDLE BindingContext
    );

/* End Forward */


VOID
ClStatusIndication(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS GeneralStatus,
    IN  PVOID       StatusBuffer,
    IN  UINT        StatusBufferSize
    )

/*++

Routine Description:

    Called by the NIC via NdisIndicateStatus

Arguments:

    See the DDK...

Return Values:

    None

--*/

{
    PADAPTER Adapter = (PADAPTER)ProtocolBindingContext;
    NDIS_STATUS Status;
    ULONG ErrorLogData[2];
    PVOID Context;

    PsDbgOut(DBG_TRACE, 
             DBG_PROTOCOL, 
             ("(%08X) ClStatusIndication: Status %08X\n", 
             Adapter, 
             GeneralStatus));

    // General rule:
    // If our device is not ready, we cannot forward the status indication. 
    // Yes - we care about the Media connect and link speed oids. We will 
    // query for these OIDs when we get to D0.
    //

    // (i) Special case for media_status. <need to pass it up>
    // Condition is that: 
    //	(Adapter state is OFF, so we can't process it ourselves)	AND
    //	(Status indication is about 'connect' or 'disconnect')		AND
    //	(Adapter state is 'running')							AND
    //	(Adapter has a binding handle for the protocol above)	
    // We will process fix our internal state when we wake up and go back to D0.
    if( 	(IsDeviceStateOn(Adapter) == FALSE)		&& 
    		((GeneralStatus == NDIS_STATUS_MEDIA_CONNECT) || (GeneralStatus == NDIS_STATUS_MEDIA_DISCONNECT))	&&
    		(Adapter->PsMpState == AdapterStateRunning )	&&
    		(Adapter->PsNdisHandle != NULL) )
	{
        NdisMIndicateStatus(Adapter->PsNdisHandle, 
                        GeneralStatus, 
                        StatusBuffer, 
                        StatusBufferSize );

        return;
    	}        
    
    // (ii) Special case for wan-line-down: <need to process it>
    // This is a special case for wan_line_down. Need to forward it even if the adapter is not in D0.
    if( (IsDeviceStateOn(Adapter) == FALSE)	&& (GeneralStatus != NDIS_STATUS_WAN_LINE_DOWN) )
    {
        return;
    }

    //
    // we cannot forward status indications until we have been called in our
    // MpInitialize handler. But we need to look at certain events even if we
    // are not called in the MpInitialize handler. Otherwise, we could lose these
    // indications.
    //

    switch(GeneralStatus)
    {
      case NDIS_STATUS_MEDIA_CONNECT:
      case NDIS_STATUS_LINK_SPEED_CHANGE:

          PsGetLinkSpeed(Adapter);
          
          break;
          
      case NDIS_STATUS_MEDIA_DISCONNECT:
          
          //
          // reset the link speed so definite rate flows can be 
          // admitted.
          //
          
          Adapter->RawLinkSpeed = (ULONG)UNSPECIFIED_RATE;
          UpdateAdapterBandwidthParameters(Adapter);
          
          break;

      default:
          break;
    }
          
    //   
    // Our virtual adapter has not been initialized. We cannot forward this indication.
    //

    if(Adapter->PsMpState != AdapterStateRunning || Adapter->PsNdisHandle == NULL) 
    {
        return;
    }

    //
    // For these WAN related indications, we have to send them to wanarp 
    //  So, there is no point in looking at these if our virtual adapter has not been initialized.
    //

    switch(GeneralStatus) 
    {
      case NDIS_STATUS_WAN_LINE_UP:
      {
          if(Adapter->ProtocolType == ARP_ETYPE_IP)
          {
              
              //
              // This will call NdisMIndicateStatus, so we have to return
              // directly.
              //

              Status = CreateInterfaceForNdisWan(Adapter,
                                                 StatusBuffer, 
                                                 StatusBufferSize);
              return;
          }

          break;
      }
          
      case NDIS_STATUS_WAN_LINE_DOWN:
          
          //
          // NDISWAN link has been torn down.
          //
          if(Adapter->ProtocolType == ARP_ETYPE_IP)
          {
              DeleteInterfaceForNdisWan(Adapter,
                                        StatusBuffer, 
                                        StatusBufferSize);
              return;
          }
          
          break;
          
      default:
          
          break;
          
    }

    //
    // now indicate the status to the upper layer. 
    //

    NdisMIndicateStatus(Adapter->PsNdisHandle, 
                        GeneralStatus, 
                        StatusBuffer, 
                        StatusBufferSize );

} // ClStatusIndication



VOID
ClStatusIndicationComplete(
    IN  NDIS_HANDLE ProtocolBindingContext
    )

/*++

Routine Description:

    Called by the NIC via NdisIndicateStatusComplete

Arguments:

    See the DDK...

Return Values:

    None

--*/

{
    PADAPTER Adapter = (PADAPTER)ProtocolBindingContext;

    PsDbgOut(DBG_TRACE, DBG_PROTOCOL, ("(%08X) ClStatusIndicationComplete\n", Adapter));

    if ( Adapter->PsNdisHandle != NULL) { 

        NdisMIndicateStatusComplete( Adapter->PsNdisHandle );
    }

} // ClStatusIndication

/* end status.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\stats.h ===
/*++

Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

    stats.h

Abstract:

    Defintions for getting statistics from driver

Author:

    Charlie Wickham (charlwi) 09-Mar-1995

Revision History:

--*/

#ifndef _STATS_
#define _STATS_

/* Prototypes */ /* Generated by Emacs 19.17.0 on Tue Apr 04 14:03:00 1995 */

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

NTSTATUS
GetStats(
    PVOID ioBuffer,
    ULONG inputBufferLength,
    PULONG outputBufferLength
    );

ULONG
RunningAverage(
    IN  PRUNNING_AVERAGE RunningAverage,
    IN  ULONG NewValue
    );

NDIS_STATUS
CreateAveragingArray(
    OUT PRUNNING_AVERAGE *RunningAverage,
    IN  ULONG ArraySize
    );

VOID
DeleteAveragingArray(
    PRUNNING_AVERAGE RunningAverage
    );

/* End Prototypes */

#endif /* _STATS_ */

/* end stats.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\timestmp.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:
    TimeStmp.c

Abstract:
    TimeStamp module

Author:
    Shreem, Sanjayka

Environment:
    Kernel Mode

Revision History:

--*/

#include "psched.h"

#pragma hdrstop


// The pipe information
typedef struct _TS_PIPE
{
    // ContextInfo -    Generic context info
    PS_PIPE_CONTEXT         ContextInfo;
} TS_PIPE, *PTS_PIPE;


// The flow information
typedef struct _TS_FLOW 
{
    // ContextInfo -            Generic context info
    PS_FLOW_CONTEXT ContextInfo;
} TS_FLOW, *PTS_FLOW;


/* Global variables */
LIST_ENTRY      TsList;
NDIS_SPIN_LOCK  TsSpinLock;
ULONG           TsCount;


/* Static */

/* Forward */

NDIS_STATUS
TimeStmpInitializePipe (
    IN HANDLE PsPipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters,
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_PROCS PsProcs,
    IN PPS_UPCALLS Upcalls
    );

NDIS_STATUS
TimeStmpModifyPipe (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters
    );

VOID
TimeStmpDeletePipe (
    IN PPS_PIPE_CONTEXT PipeContext
    );

NDIS_STATUS
TimeStmpCreateFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsFlowContext,
    IN PCO_CALL_PARAMETERS CallParameters,
    IN PPS_FLOW_CONTEXT ComponentFlowContext
    );

NDIS_STATUS
TimeStmpModifyFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PCO_CALL_PARAMETERS CallParameters
    );

VOID
TimeStmpDeleteFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext
    );

VOID
TimeStmpEmptyFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext
    );    

VOID
TimeStmpSetInformation (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN NDIS_OID Oid,
    IN ULONG Len,
    IN void *Data);

VOID
TimeStmpQueryInformation (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN NDIS_OID Oid,
    IN ULONG Len,
    IN PVOID Data,
    IN OUT PULONG BytesWritten,
    IN OUT PULONG BytesNeeded,
    IN OUT PNDIS_STATUS Status);


NDIS_STATUS 
TimeStmpCreateClassMap (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsClassMapContext,
    IN PTC_CLASS_MAP_FLOW ClassMap,
    IN PPS_CLASS_MAP_CONTEXT ComponentClassMapContext
    );

NDIS_STATUS 
TimeStmpDeleteClassMap (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_CLASS_MAP_CONTEXT ComponentClassMapContext
    );

BOOLEAN
TimeStmpSubmitPacket (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PPS_CLASS_MAP_CONTEXT ClassMapContext,
    IN PPACKET_INFO_BLOCK Packet
    );

BOOLEAN
TimeStmpReceivePacket (
    IN PPS_PIPE_CONTEXT         PipeContext,
    IN PPS_FLOW_CONTEXT         FlowContext,
    IN PPS_CLASS_MAP_CONTEXT    ClassMapContext,
    IN PNDIS_PACKET             Packet,
    IN NDIS_MEDIUM              Medium
    );

BOOLEAN
TimeStmpReceiveIndication(
                          IN PPS_PIPE_CONTEXT PipeContext,
                          IN PPS_FLOW_CONTEXT FlowContext,
                          IN PPS_CLASS_MAP_CONTEXT ClassMapContext,
                          IN PVOID    HeaderBuffer,
                          IN UINT     HeaderBufferSize,
                          IN PVOID    LookAheadBuffer,
                          IN UINT     LookAheadBufferSize,
                          IN UINT     PacketSize,
                          IN UINT     TransportHeaderOffset
                          );


/* End Forward */


VOID
InitializeTimeStmp( PPSI_INFO Info )
{
    Info->PipeContextLength = ((sizeof(TS_PIPE)+7) & ~7);
    Info->FlowContextLength = ((sizeof(TS_FLOW)+7) & ~7);
    Info->ClassMapContextLength = sizeof(PS_CLASS_MAP_CONTEXT);
    Info->InitializePipe = TimeStmpInitializePipe;
    Info->ModifyPipe = TimeStmpModifyPipe;
    Info->DeletePipe = TimeStmpDeletePipe;
    Info->CreateFlow = TimeStmpCreateFlow;
    Info->ModifyFlow = TimeStmpModifyFlow;
    Info->DeleteFlow = TimeStmpDeleteFlow;
    Info->EmptyFlow =  TimeStmpEmptyFlow;
    Info->CreateClassMap = TimeStmpCreateClassMap;
    Info->DeleteClassMap = TimeStmpDeleteClassMap;
    Info->SubmitPacket = TimeStmpSubmitPacket;
    Info->ReceivePacket = NULL;
    Info->ReceiveIndication = NULL;
    Info->SetInformation = TimeStmpSetInformation;
    Info->QueryInformation = TimeStmpQueryInformation;

    NdisAllocateSpinLock(&TsSpinLock);
    InitializeListHead( &TsList );

    TsCount = 0;
} 


NDIS_STATUS
TimeStmpInitializePipe (
    IN HANDLE PsPipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters,
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_PROCS PsProcs,
    IN PPS_UPCALLS Upcalls
    )
{
    PPS_PIPE_CONTEXT Pipe = ComponentPipeContext;

    return (*Pipe->NextComponent->InitializePipe)(
        PsPipeContext,
        PipeParameters,
        Pipe->NextComponentContext,
        PsProcs,
        Upcalls);
}



NDIS_STATUS
TimeStmpModifyPipe (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters
    )
{
    PPS_PIPE_CONTEXT Pipe = PipeContext;

    return (*Pipe->NextComponent->ModifyPipe)(
        Pipe->NextComponentContext, PipeParameters);
}



VOID
TimeStmpDeletePipe (
    IN PPS_PIPE_CONTEXT PipeContext
    )
{
    PPS_PIPE_CONTEXT Pipe = PipeContext;

     (*Pipe->NextComponent->DeletePipe)(Pipe->NextComponentContext);
}


NDIS_STATUS
TimeStmpCreateFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsFlowContext,
    IN PCO_CALL_PARAMETERS CallParameters,
    IN PPS_FLOW_CONTEXT ComponentFlowContext
    )
{
    PPS_PIPE_CONTEXT Pipe = PipeContext;

    return (*Pipe->NextComponent->CreateFlow)(
                Pipe->NextComponentContext,
                PsFlowContext,
                CallParameters,
                ComponentFlowContext->NextComponentContext);
}


NDIS_STATUS
TimeStmpModifyFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PCO_CALL_PARAMETERS CallParameters
    )
{
    PPS_PIPE_CONTEXT Pipe = PipeContext;

    return (*Pipe->NextComponent->ModifyFlow)(
                Pipe->NextComponentContext,
                FlowContext->NextComponentContext,
                CallParameters);
    
}


VOID
TimeStmpDeleteFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext
    )
{
    PPS_PIPE_CONTEXT Pipe = PipeContext;

    (*Pipe->NextComponent->DeleteFlow)(
        Pipe->NextComponentContext,
        FlowContext->NextComponentContext);
}


VOID
TimeStmpEmptyFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext
    )
{
    PPS_PIPE_CONTEXT Pipe = PipeContext;

    (*Pipe->NextComponent->EmptyFlow)(
        Pipe->NextComponentContext,
        FlowContext->NextComponentContext);
}



VOID
TimeStmpSetInformation (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN NDIS_OID Oid,
    IN ULONG Len,
    IN void *Data)
{
    PPS_PIPE_CONTEXT Pipe = PipeContext;
    PPS_FLOW_CONTEXT Flow = FlowContext;

    (*Pipe->NextComponent->SetInformation)(
        Pipe->NextComponentContext,
        (Flow)?Flow->NextComponentContext:0,
        Oid,
        Len,
        Data);
}



VOID
TimeStmpQueryInformation (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN NDIS_OID Oid,
    IN ULONG Len,
    IN PVOID Data,
    IN OUT PULONG BytesWritten,
    IN OUT PULONG BytesNeeded,
    IN OUT PNDIS_STATUS Status)
{
    PPS_PIPE_CONTEXT Pipe = PipeContext;
    PPS_FLOW_CONTEXT Flow = FlowContext;

    (*Pipe->NextComponent->QueryInformation)(
        Pipe->NextComponentContext,
        (Flow)?Flow->NextComponentContext:0,
        Oid,
        Len,
        Data,
        BytesWritten,
        BytesNeeded,
        Status);
}


NDIS_STATUS 
TimeStmpCreateClassMap (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsClassMapContext,
    IN PTC_CLASS_MAP_FLOW ClassMap,
    IN PPS_CLASS_MAP_CONTEXT ComponentClassMapContext
    )
{
    return (*PipeContext->NextComponent->CreateClassMap)(
        PipeContext->NextComponentContext,
        PsClassMapContext,
        ClassMap,
        ComponentClassMapContext->NextComponentContext);
}

NDIS_STATUS 
TimeStmpDeleteClassMap (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_CLASS_MAP_CONTEXT ComponentClassMapContext
    )
{
    return (*PipeContext->NextComponent->DeleteClassMap)(
        PipeContext->NextComponentContext,
        ComponentClassMapContext->NextComponentContext);
}



/*  Routine Description:
        Checks to see if there is any application requesting time-stamping for these end-points

    Return Value:
        MARK_NONE, MARK_IN_PKT, MARK_IN_BUF
*/        

int
CheckForMatch(  ULONG   SrcIp, 
                ULONG   DstIp, 
                USHORT  SrcPort, 
                USHORT  DstPort,
                USHORT  Proto,
                USHORT  IpId,
                USHORT  Size,
                USHORT  Direction)
{
	PLIST_ENTRY		ListEntry;
	PTS_ENTRY		pEntry;
	int             Status = MARK_NONE;

    NdisAcquireSpinLock(&TsSpinLock);
 
	ListEntry = TsList.Flink;
	
	while (ListEntry != &TsList) 
	{
        pEntry = CONTAINING_RECORD(ListEntry, TS_ENTRY, Linkage);

        if( ((pEntry->SrcIp == UL_ANY)      || (pEntry->SrcIp == SrcIp))            &&
		    ((pEntry->SrcPort== US_ANY)     || (pEntry->SrcPort == SrcPort))        &&
		    ((pEntry->DstIp == UL_ANY)      || (pEntry->DstIp == DstIp))            &&
		    ((pEntry->DstPort  == US_ANY)   || (pEntry->DstPort == DstPort))        &&
		    ((pEntry->Direction == US_ANY)  || (pEntry->Direction == Direction))    &&
            ((pEntry->Proto == US_ANY)      || (pEntry->Proto == Proto)))
        {
    		if(pEntry->Type == MARK_IN_BUF)
    		{
    		    LARGE_INTEGER           PerfFrequency, CurrentTime;
                UINT64                  RecdTime, Freq;
    		    MARK_IN_BUF_RECORD	    Record, *pRecord;

                Status = MARK_IN_BUF;

                if((int)( (char*)pEntry->pPacketStore - (char*)pEntry->pPacketStoreHead 
                            + sizeof(MARK_IN_BUF_RECORD) ) < PACKET_STORE_SIZE )
                {
                    pEntry->pPacketStore->IpId = IpId;
    			    pEntry->pPacketStore->Size = Size;

                    CurrentTime = KeQueryPerformanceCounter(&PerfFrequency);

                    // Convert the perffrequency into 100ns interval. //
                    Freq = 0;
                    Freq |= PerfFrequency.HighPart;
                    Freq = Freq << 32;
                    Freq |= PerfFrequency.LowPart;

                    pEntry->pPacketStore->TimeValue = 0;
                    pEntry->pPacketStore->TimeValue  |= CurrentTime.HighPart;
                    pEntry->pPacketStore->TimeValue  = pEntry->pPacketStore->TimeValue  << 32;
                    pEntry->pPacketStore->TimeValue  |= CurrentTime.LowPart;
    		
    		        // Normalize cycles with the frequency //
                    pEntry->pPacketStore->TimeValue  *= 10000000;
                    pEntry->pPacketStore->TimeValue  /= Freq;

                    pEntry->pPacketStore = (PMARK_IN_BUF_RECORD)((char*)pEntry->pPacketStore + sizeof(MARK_IN_BUF_RECORD));
                }                
                else
    		    {
    			    pEntry->pPacketStore = pEntry->pPacketStoreHead;
    		    }


                NdisReleaseSpinLock(&TsSpinLock);
    			return Status;
    		} 
    		else if(pEntry->Type == MARK_IN_PKT)
    		{
    		    Status = MARK_IN_PKT;
    		    NdisReleaseSpinLock(&TsSpinLock);
    			return Status;
    		}
        }
		else 
		{
			ListEntry = ListEntry->Flink;
		}
	}

    NdisReleaseSpinLock(&TsSpinLock);
	return Status;
}


/*  Routine Description:
        Adds an end-point to the list of monitoring end-points 
        
    Return Value:
        TRUE, FALSE
*/  
BOOL
AddRequest(  PFILE_OBJECT FileObject, 
             ULONG  SrcIp, 
             USHORT SrcPort,
             ULONG  DstIp, 
             USHORT DstPort,
             USHORT Proto,
             USHORT Type,
             USHORT Direction)
{
    PTS_ENTRY   pEntry = NULL;

    PsAllocatePool(pEntry, sizeof(TS_ENTRY), TsTag);

    if( !pEntry )
        return FALSE;
                        
    InitializeListHead(&pEntry->Linkage);

    pEntry->SrcIp   = SrcIp;
    pEntry->SrcPort = SrcPort;
    pEntry->DstIp   = DstIp;
    pEntry->DstPort = DstPort;
    pEntry->Proto   = Proto;
    pEntry->Type    = Type;
    pEntry->Direction = Direction;

    pEntry->FileObject = FileObject;
    pEntry->pPacketStore = NULL;
    pEntry->pPacketStoreHead = NULL;

    if(Type == MARK_IN_BUF)
    {   
        PsAllocatePool( pEntry->pPacketStoreHead, PACKET_STORE_SIZE, TsTag );

        if( !pEntry->pPacketStoreHead)
        {
            PsFreePool( pEntry );
            return FALSE;
        }

        pEntry->pPacketStore = pEntry->pPacketStoreHead;
    }

    NdisAcquireSpinLock(&TsSpinLock);

    /* Need to check for duplication ..*/
    InsertHeadList(&TsList, &pEntry->Linkage);

    InterlockedIncrement( &TsCount );

    NdisReleaseSpinLock(&TsSpinLock);

    return TRUE;
}


/*  Routine Description:
        Removes an end-point to the list of monitoring end-points 
        
    Return Value:
        None
        
    Note:
        Here, 0xffffffff means, wild card => Don't have to match on that field */
void
RemoveRequest(  PFILE_OBJECT FileObject, 
                ULONG  SrcIp, 
                USHORT SrcPort,
                ULONG  DstIp, 
                USHORT DstPort,
                USHORT Proto)
{
    PLIST_ENTRY		ListEntry;
    PTS_ENTRY       pEntry;

    NdisAcquireSpinLock(&TsSpinLock);

	ListEntry = TsList.Flink;

	while (ListEntry != &TsList) 
	{

		pEntry = CONTAINING_RECORD(ListEntry, TS_ENTRY, Linkage);								

		if( ((FileObject == ULongToPtr(UL_ANY)) || (pEntry->FileObject == FileObject))  &&
		    ((SrcIp == UL_ANY)                  || (pEntry->SrcIp == SrcIp))            &&
		    ((SrcPort == US_ANY)                || (pEntry->SrcPort == SrcPort))        &&
		    ((DstIp == UL_ANY)                  || (pEntry->DstIp == DstIp))            &&
		    ((DstPort == US_ANY)                || (pEntry->DstPort == SrcPort))        &&
            ((Proto== US_ANY)                   || (pEntry->Proto == Proto)))
        {		    
		    RemoveEntryList(&pEntry->Linkage);

		    if( pEntry->pPacketStoreHead)
		        PsFreePool( pEntry->pPacketStoreHead );
		        
		    PsFreePool( pEntry );

		    InterlockedDecrement( &TsCount );

		    /* Need to go back to the beginning of the list againg.. */
		    ListEntry = TsList.Flink;
		}
		else
		{
		    ListEntry = ListEntry->Flink;
		}
	}

    NdisReleaseSpinLock(&TsSpinLock);
}


int
CopyTimeStmps( PFILE_OBJECT FileObject, PVOID buf, ULONG    Len)
{
    PLIST_ENTRY		ListEntry;
    PTS_ENTRY       pEntry;
    ULONG           DataLen;
    LARGE_INTEGER   LargeLen;

    if( Len < PACKET_STORE_SIZE )
        return 0;

    NdisAcquireSpinLock(&TsSpinLock);

	ListEntry = TsList.Flink;

	while (ListEntry != &TsList) 
	{

		pEntry = CONTAINING_RECORD(ListEntry, TS_ENTRY, Linkage);								

		if( pEntry->FileObject == FileObject)
		{		    
		    // Copy the data across and rest the pointers.. //

		    LargeLen.QuadPart = ((char*)pEntry->pPacketStore) - ((char*)pEntry->pPacketStoreHead);

            DataLen = LargeLen.LowPart;
            
            NdisMoveMemory( buf, pEntry->pPacketStoreHead, DataLen);
            pEntry->pPacketStore = pEntry->pPacketStoreHead;	

            NdisReleaseSpinLock(&TsSpinLock);
            return DataLen;
		}
		else
		{
		    ListEntry = ListEntry->Flink;
		}
	}

    NdisReleaseSpinLock(&TsSpinLock);
    return 0;
}



VOID
UnloadTimeStmp( )
{
    // Clear all the Requests //
    RemoveRequest(  ULongToPtr(UL_ANY), 
                    UL_ANY, 
                    US_ANY,
                    UL_ANY,
                    US_ANY,
                    US_ANY);

    // Free the spin lock //
    NdisFreeSpinLock(&TsSpinLock);
} 




BOOLEAN
TimeStmpSubmitPacket (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PPS_CLASS_MAP_CONTEXT ClassMapContext,
    IN PPACKET_INFO_BLOCK PacketInfo
    )
{
    PTS_PIPE        Pipe = (PTS_PIPE)PipeContext;
    PTS_FLOW        Flow = (PTS_FLOW)FlowContext;
    PNDIS_PACKET    Packet = PacketInfo->NdisPacket;

    PNDIS_BUFFER    ArpBuf , IpBuf , TcpBuf, UdpBuf, DataBuf;
    ULONG           ArpLen , IpLen , IpHdrLen , TcpLen , UdpLen, DataLen , TotalLen , TcpHeaderOffset;
    
    VOID                *ArpH;
    IPHeader UNALIGNED  *IPH;
    TCPHeader UNALIGNED *TCPH;
    UDPHeader UNALIGNED *UDPH;

    IPAddr              Src, Dst;
    BOOLEAN             bFragment;
    USHORT              SrcPort , DstPort , IPID, FragOffset ,Size;
    PVOID               GeneralVA , Data;
    ULONG               i, Ret;


    if( (TsCount == 0)  ||
        (NDIS_GET_PACKET_PROTOCOL_TYPE(Packet) != NDIS_PROTOCOL_ID_TCP_IP))
    {
        goto SUBMIT_NEXT;
    }        

    IpBuf = NULL;

    // Steps  
    // Parse the IP Packet. 
    // Look for the appropriate ports.
    // Look for the data portion and put in the Time & length there.

    if(1)
    {
        PVOID           pAddr;
    	PNDIS_BUFFER    pNdisBuf1, pNdisBuf2;
    	UINT            Len;
        ULONG	        TransportHeaderOffset = 0;

    	TransportHeaderOffset = PacketInfo->IPHeaderOffset;

        NdisGetFirstBufferFromPacket(   Packet,
                                        &ArpBuf,
                                        &ArpH,
                                        &ArpLen,
                                        &TotalLen
                                    );

    	pNdisBuf1 = Packet->Private.Head;
    	NdisQueryBuffer(pNdisBuf1, &pAddr, &Len);

    	while(Len <= TransportHeaderOffset) 
	    {

        	TransportHeaderOffset -= Len;
        	NdisGetNextBuffer(pNdisBuf1, &pNdisBuf2);
        	
		    NdisQueryBuffer(pNdisBuf2, &pAddr, &Len);
        	pNdisBuf1 = pNdisBuf2;
    	}

	    /* Buffer Descriptor corresponding to Ip Packet */
	    IpBuf = pNdisBuf1;

        /* Length of this Buffer (IP buffer) */
	    IpLen = Len - TransportHeaderOffset;	

	    /* Starting Virtual Address for this buffer */
	    GeneralVA = pAddr;
	    
	    /* Virtual Address of the IP Header */
	    IPH = (IPHeader *)(((PUCHAR)pAddr) + TransportHeaderOffset);
   }

    if(!IpBuf)
         goto SUBMIT_NEXT;

    /* Let's try to parse the packet */
    Src = IPH->iph_src;
    Dst = IPH->iph_dest;
    IPID = net_short(IPH->iph_id);
    Size = net_short(IPH->iph_length);
    IpHdrLen = ((IPH->iph_verlen & (uchar)~IP_VER_FLAG) << 2);
    
    FragOffset = IPH->iph_offset & IP_OFFSET_MASK;
    FragOffset = net_short(FragOffset) * 8;

    bFragment = (IPH->iph_offset & IP_MF_FLAG) || (FragOffset > 0);

    // Don't want to deal with Fragmented packets right now..//
    if ( bFragment ) 
        goto SUBMIT_NEXT;


    switch (IPH->iph_protocol) 
    {
        case IPPROTO_TCP :

            if (IPH && ((USHORT)IpLen > IpHdrLen)) 
            {
                // We have more than the IP Header in this MDL //
                TCPH = (TCPHeader *) ((PUCHAR)IPH + IpHdrLen);
                TcpLen = IpLen - IpHdrLen;
                TcpBuf = IpBuf;

            } 
            else 
            {
                // TCP Header is in the next MDL //                
                NdisGetNextBuffer(IpBuf, &TcpBuf);

                if(!TcpBuf) 
                    goto SUBMIT_NEXT;

                GeneralVA = NULL;
                NdisQueryBuffer(TcpBuf,
                                &GeneralVA,
                                &TcpLen
                                );
            
                TCPH = (TCPHeader *) GeneralVA;
            }

            /* At this point, TcpBuf, TCPH and TcpLen contain the proper values */

            // Get the port numbers out.
            SrcPort = net_short(TCPH->tcp_src);
            DstPort = net_short(TCPH->tcp_dest);

            // We have the TCP Buffer now. Get to the DATA //
            TcpHeaderOffset = TCP_HDR_SIZE(TCPH);

            if (TcpLen > TcpHeaderOffset) 
            {
                // We have the DATA right here! //
                Data = (PUCHAR)TCPH + TcpHeaderOffset;
                DataLen = TcpLen - TcpHeaderOffset;

            } 
            else 
            {
                NdisGetNextBuffer(TcpBuf, &DataBuf);

                if(!DataBuf) 
                    goto SUBMIT_NEXT;

                GeneralVA = NULL;

                NdisQueryBuffer(DataBuf,
                                &Data,
                                &DataLen
                                );
            }

            /* At this point, DataBuf, Data and DataLen contain the proper values */
            goto TimeStamp;
            break;

        case IPPROTO_UDP:
        
            if (IpLen > IpHdrLen)
            {
                // We have more than the IP Header in this MDL //
                UDPH = (UDPHeader *) ((PUCHAR)IPH + IpHdrLen);
                UdpLen = IpLen - IpHdrLen;
                UdpBuf = IpBuf;
            } 
            else 
            {
                // UDP Header is in the next MDL //
                NdisGetNextBuffer(IpBuf, &UdpBuf);

                if(!UdpBuf)
                    goto SUBMIT_NEXT;

                GeneralVA = NULL;
                NdisQueryBuffer(UdpBuf,
                                &GeneralVA,
                                &UdpLen
                                );

                UDPH = (UDPHeader *) GeneralVA;
            }

             /* At this point, UdpBuf, UDPH and UdpLen contain the proper values */

            SrcPort = net_short(UDPH->uh_src);
            DstPort = net_short(UDPH->uh_dest);

            // Get to the data. //
            if (UdpLen > sizeof (UDPHeader)) 
            {
                // We have the DATA right here! //
                Data = (PUCHAR) UDPH + sizeof (UDPHeader);
                DataLen = UdpLen - sizeof (UDPHeader);
            } 
            else 
            {
                NdisGetNextBuffer(UdpBuf, &DataBuf);

                if(!DataBuf) 
                    goto SUBMIT_NEXT;

                GeneralVA = NULL;
                NdisQueryBuffer(DataBuf,
                                &Data,
                                &DataLen
                                );
            }

            /* At this point, DataBuf, Data and DataLen contain the proper values */
            goto TimeStamp;
            break;

        default:
            goto SUBMIT_NEXT;
    }


TimeStamp:

    Ret = CheckForMatch( Src, Dst, SrcPort, DstPort, IPH->iph_protocol, IPID, Size, DIR_SEND);
    
    if( Ret == MARK_IN_PKT)
    {
       if (DataLen >= sizeof(MARK_IN_PKT_RECORD))
       {
            LARGE_INTEGER           PerfFrequency, CurrentTime;
            UINT64                  RecdTime, Freq;
            PMARK_IN_PKT_RECORD     pRecord;

            pRecord     = (PMARK_IN_PKT_RECORD) Data;
            CurrentTime = KeQueryPerformanceCounter(&PerfFrequency);

            pRecord->BufferSize = DataLen;

            // Convert the perffrequency into 100ns interval //

            Freq = 0;
            Freq |= PerfFrequency.HighPart;
            Freq = Freq << 32;
            Freq |= PerfFrequency.LowPart;

            // convert to uint64 //

            pRecord->TimeSentWire = 0;
            pRecord->TimeSentWire |= CurrentTime.HighPart;
            pRecord->TimeSentWire = pRecord->TimeSentWire << 32;
            pRecord->TimeSentWire |= CurrentTime.LowPart;

            // Normalize cycles with the frequency.
            pRecord->TimeSentWire *= 10000000;
            pRecord->TimeSentWire /= Freq;

            if(IPH->iph_protocol == IPPROTO_UDP)
                UDPH->uh_xsum = 0;
        }    
    }
    else if( Ret == MARK_IN_BUF)
    {
        //  Nothing more to be done..
    }
    
SUBMIT_NEXT: 
    return (*Pipe->ContextInfo.NextComponent->SubmitPacket)(
                    Pipe->ContextInfo.NextComponentContext,
                    Flow->ContextInfo.NextComponentContext,
                    (ClassMapContext != NULL) ? ClassMapContext->NextComponentContext : NULL,
                    PacketInfo);
}




BOOLEAN
TimeStmpReceivePacket (
    IN PPS_PIPE_CONTEXT         PipeContext,
    IN PPS_FLOW_CONTEXT         FlowContext,
    IN PPS_CLASS_MAP_CONTEXT    ClassMapContext,
    IN PNDIS_PACKET             Packet,
    IN NDIS_MEDIUM              Medium
    )
{
    PPS_PIPE_CONTEXT    Pipe;
    LARGE_INTEGER       CurrentTime;
    IPHeader UNALIGNED  *IPH;
    TCPHeader UNALIGNED *TCPH;
    UDPHeader UNALIGNED *UDPH;
    IPAddr              Src, Dst;
    PUCHAR              headerBuffer, pData;
    PNDIS_BUFFER        pFirstBuffer;
    ULONG               firstbufferLength, bufferLength, HeaderLength;
    ULONG               TotalIpLen, IPDataLength, IpHdrLen;
    ULONG               TotalTcpLen, TcpDataLen, TotalLen, TcpHeaderOffset, i;
    int                 TotalUdpLen, UdpDataLen, UdpHdrLen, DataLen, Ret;
    USHORT              SrcPort, DstPort, IPID, FragOffset, Size;
    BOOLEAN             bFragment, bFirstFragment, bLastFragment;


    /* This will give the size of the "media-specific" header. So, this will be the offset to IP packet */
    UINT                HeaderBufferSize ;

    ushort          type;                       // Protocol type
    uint            ProtOffset;                 // Offset in Data to non-media info.

    if( ( TsCount == 0) ||
        (NDIS_GET_PACKET_PROTOCOL_TYPE(Packet) == NDIS_PROTOCOL_ID_TCP_IP))
    {        
        return TRUE;
    }        

    Pipe = PipeContext;
    HeaderBufferSize = NDIS_GET_PACKET_HEADER_SIZE(Packet);

    NdisGetFirstBufferFromPacket(Packet,                // packet
                                 &pFirstBuffer,         // first buffer descriptor
                                 &headerBuffer,         // VA of the first buffer
                                 &firstbufferLength,    // length of the header+lookahead
                                 &bufferLength);        // length of the bytes in the buffers

    IPH = (IPHeader *) ((PUCHAR)headerBuffer + HeaderBufferSize);
    
    // Check the header length and the version //
    HeaderLength = ((IPH->iph_verlen & (uchar)~IP_VER_FLAG) << 2);

    // If the HeaderLength seems to be incorrect, let's not try to parse //
    if( (HeaderLength < sizeof(IPHeader))   ||
        (HeaderLength > bufferLength) )
        return TRUE;        

    // Get past the IP Header and get the rest of the stuff out //
    TotalIpLen = (uint)net_short(IPH->iph_length);

    // Make sure the version and IpData Len are correct //
    if( ((IPH->iph_verlen & IP_VER_FLAG) != IP_VERSION )    ||
        ( TotalIpLen < HeaderLength )                       ||
        ( TotalIpLen > bufferLength ))
        return TRUE;
    
    // Let's try to parse the packet //
    Src = IPH->iph_src;
    Dst = IPH->iph_dest;
    IPID = net_short(IPH->iph_id);
    Size = net_short(IPH->iph_length);

    FragOffset = IPH->iph_offset & IP_OFFSET_MASK;
    FragOffset = net_short(FragOffset) * 8;

    bFragment = (IPH->iph_offset & IP_MF_FLAG) || (FragOffset > 0);
    bFirstFragment = bFragment && (FragOffset == 0);
    bLastFragment = bFragment && (!(IPH->iph_offset & IP_MF_FLAG));

    // If this is a fragment and NOT the first one, just put the Timestamp in here.
    // Otherwise, let it get to the protocols for processing.
    if (bFragment ) 
        return TRUE;

    // Do the protocol specific stuff //
    switch (IPH->iph_protocol) 
    {
        case IPPROTO_TCP:

            TotalTcpLen = TotalIpLen - HeaderLength;
            TCPH = (TCPHeader *) (((PUCHAR)IPH) + HeaderLength);

            // For TCP, the data offset is part of the TCP Header */
            TcpHeaderOffset = TCP_HDR_SIZE(TCPH);
            DataLen = TotalTcpLen - TcpHeaderOffset;
            pData = (PUCHAR) TCPH + TcpHeaderOffset;

            SrcPort = net_short(TCPH->tcp_src);
            DstPort = net_short(TCPH->tcp_dest);

            goto TimeStmp;
            break;

        case IPPROTO_UDP:
        
            TotalUdpLen = TotalIpLen - HeaderLength;
            UDPH = (UDPHeader *) (((PUCHAR)IPH) + HeaderLength);

            // For UDP, the header size is fixed //
            DataLen = TotalUdpLen - sizeof(UDPHeader);
            pData = ((PUCHAR) UDPH) + sizeof (UDPHeader);

            SrcPort = net_short(UDPH->uh_src);
            DstPort = net_short(UDPH->uh_dest);

            goto TimeStmp;
            break;

        default:
            break;
    }

    return TRUE;


TimeStmp:

    Ret = CheckForMatch( Src, Dst, SrcPort, DstPort, IPH->iph_protocol, IPID, Size, DIR_RECV);
    
    if( Ret == MARK_IN_PKT)
    {
       if (DataLen >= sizeof(MARK_IN_PKT_RECORD))
       {
            LARGE_INTEGER           PerfFrequency, CurrentTime;
            UINT64                  RecdTime, Freq;
            PMARK_IN_PKT_RECORD     pRecord;

            pRecord     = (PMARK_IN_PKT_RECORD) pData;
            CurrentTime = KeQueryPerformanceCounter(&PerfFrequency);

            // Convert the perffrequency into 100ns interval //
            Freq = 0;
            Freq |= PerfFrequency.HighPart;
            Freq = Freq << 32;
            Freq |= PerfFrequency.LowPart;

            //convert from large_integer to uint64

            pRecord->TimeReceivedWire = 0;
            pRecord->TimeReceivedWire |= CurrentTime.HighPart;
            pRecord->TimeReceivedWire = pRecord->TimeReceivedWire << 32;
            pRecord->TimeReceivedWire |= CurrentTime.LowPart;

            // Normalize cycles with the frequency.
            pRecord->TimeReceivedWire *= 10000000;
            pRecord->TimeReceivedWire /= Freq;

            if(IPH->iph_protocol == IPPROTO_UDP)
                UDPH->uh_xsum = 0;
        }    
    }
    else if( Ret == MARK_IN_BUF)
    {
    
    }      

    return TRUE;
}



#ifdef NEVER


//
// This function receives a buffer from NDIS which is indicated to the transport.
// We use this function and work past the headers (tcp, ip) and get to the data.
// Then, we timestamp and reset the checksum flags.
// We make the assumption that the lookahead is atleast 128. 
// mac header ~ 8+8, ip header ~20, tcp/udp ~ 20+options, LOG_RECORD ~ 44
// they all add up to less than 128. If this is not a good assumption, We will need
// to get into MiniportTransferData and such.
//
BOOLEAN
TimeStmpReceiveIndication(
                          IN PPS_PIPE_CONTEXT PipeContext,
                          IN PPS_FLOW_CONTEXT FlowContext,
                          IN PPS_CLASS_MAP_CONTEXT ClassMapContext,
                          IN PVOID    HeaderBuffer,
                          IN UINT     HeaderBufferSize,
                          IN PVOID    LookAheadBuffer,
                          IN UINT     LookAheadBufferSize,
                          IN UINT     PacketSize,
                          IN UINT     TransportHeaderOffset
                          )
{
    PPS_PIPE_CONTEXT    Pipe = PipeContext;
    LARGE_INTEGER       CurrentTime;
    IPHeader UNALIGNED  *IPH    = NULL;
    TCPHeader UNALIGNED *TCPH   = NULL;
    UDPHeader UNALIGNED *UDPH   = NULL;
    IPAddr              Src, Dst;
    PUCHAR              headerBuffer = NULL, pData = NULL;
    PNDIS_BUFFER        pFirstBuffer = NULL;
    ULONG               firstbufferLength = 0, bufferLength = 0, HeaderLength = 0;
    ULONG               TotalIpLen = 0, IPDataLength = 0, IpHdrLen = 0;
    ULONG               TotalTcpLen = 0, TcpDataLen = 0, TotalLen = 0, TcpHeaderOffset = 0;
    ULONG               TotalUdpLen = 0, UdpDataLen = 0, UdpHdrLen = 0;
    USHORT              SrcPort = 0, DstPort = 0, IPID = 0, FragOffset = 0, Size = 0;
    BOOLEAN             bFragment, bFirstFragment, bLastFragment;
    ULONG               i = 0;
    ushort              type;                       // Protocol type
    uint                ProtOffset;                 // Offset in Data to non-media info.
    UINT                MoreHeaderInLookAhead = 0;

    // Don't know anything about the MAC headers, piggy back from PSCHED...
    // Calculate if the header is more than the standard HeaderBufferSize (i.e. SNAP header, etc.)
    //
    MoreHeaderInLookAhead = TransportHeaderOffset - HeaderBufferSize;

    if (MoreHeaderInLookAhead) 
    {
        // Just munge these, so that we can actually get down to business //
        ((PUCHAR) LookAheadBuffer) += MoreHeaderInLookAhead;
        LookAheadBufferSize -= MoreHeaderInLookAhead;
    }

    if (LookAheadBufferSize > sizeof(IPHeader)) 
    {
        IPH = (IPHeader *) (PUCHAR)LookAheadBuffer;
    
        // Check the header length and the version. If any of these
        // checks fail silently discard the packet.
        HeaderLength = ((IPH->iph_verlen & (uchar)~IP_VER_FLAG) << 2);

        if (HeaderLength >= sizeof(IPHeader) && HeaderLength <= LookAheadBufferSize) 
        {
            // Get past the IP Header and get the rest of the stuff out//
            TotalIpLen = (uint)net_short(IPH->iph_length);

            if ((IPH->iph_verlen & IP_VER_FLAG) == IP_VERSION &&
                TotalIpLen >= HeaderLength  && TotalIpLen <= LookAheadBufferSize) 
            {
                Src = IPH->iph_src;
                Dst = IPH->iph_dest;
                IPID = net_short(IPH->iph_id);
		        Size = net_short(IPH->iph_length );

                FragOffset = IPH->iph_offset & IP_OFFSET_MASK;
                FragOffset = net_short(FragOffset) * 8;

                bFragment = (IPH->iph_offset & IP_MF_FLAG) || (FragOffset > 0);
                bFirstFragment = bFragment && (FragOffset == 0);
                bLastFragment = bFragment && (!(IPH->iph_offset & IP_MF_FLAG));

                // If this is a fragment and NOT the first one, just put the Timestamp in here.
                // Otherwise, let it get to the protocols for processing.
                if (bFragment ) 
			        return TRUE;

                // Do the protocol specific stuff.//

                switch (IPH->iph_protocol) 
                {
                case IPPROTO_TCP:
            
                    TotalTcpLen = TotalIpLen - HeaderLength;
                    TCPH = (TCPHeader *) (((PUCHAR)IPH) + HeaderLength);

                    SrcPort = net_short(TCPH->tcp_src);
                    DstPort = net_short(TCPH->tcp_dest);


                    TcpHeaderOffset = TCP_HDR_SIZE(TCPH);
                    pData = (PUCHAR) TCPH + TcpHeaderOffset;
                    TcpDataLen = TotalTcpLen - TcpHeaderOffset;

                    goto TimeStmp;
                    break;

                case IPPROTO_UDP:
            
                    TotalUdpLen = TotalIpLen - HeaderLength;
                    UDPH = (UDPHeader *) (((PUCHAR)IPH) + HeaderLength);
                
                    UdpDataLen = TotalUdpLen - sizeof(UDPHeader);
                    pData = ((PUCHAR) UDPH) + sizeof (UDPHeader);

                    SrcPort = net_short(UDPH->uh_src);
                    DstPort = net_short(UDPH->uh_dest);

                    if (UdpDataLen < sizeof(UDPHeader)) 
                        return TRUE;

                    goto TimeStmp;                        
                    break;

                default:
                    break;
                }
            }
        }
    }
TimeStmp:

    CheckForMatch( Src, Dst, SrcPort, DstPort,0, IPID, Size, DIR_RECV);
/*
    if (CheckInPortAndIpList(Src, DstPort))  
    {                    
                    LARGE_INTEGER   PerfFrequency;
                    UINT64          RecdTime, Freq;
		    LOG_RECORD	    Record;


			pRecord = &Record;			
                        CurrentTime = KeQueryPerformanceCounter(&PerfFrequency);

                        //
                        // Convert the perffrequency into 100ns interval.
                        //
                        Freq = 0;
                        Freq |= PerfFrequency.HighPart;
                        Freq = Freq << 32;
                        Freq |= PerfFrequency.LowPart;

                        pRecord->TimeReceivedWire = 0;
                        pRecord->TimeReceivedWire |= CurrentTime.HighPart;
                        pRecord->TimeReceivedWire = pRecord->TimeReceivedWire << 32;
                        pRecord->TimeReceivedWire |= CurrentTime.LowPart;

                        // Normalize cycles with the frequency.
                        pRecord->TimeReceivedWire *= 10000000;
                        pRecord->TimeReceivedWire /= Freq;

			if(  (int)( (char*)pPacketStore - (char*)pPacketStoreHead + sizeof(PACKET_RECORD) ) < PACKET_STORE_SIZE )	
			{
				pPacketStore->IpId = IPID;
				pPacketStore->cSeperator1='y';
				pPacketStore->TimeValue = pRecord->TimeReceivedWire;
				pPacketStore->cSeperator2 = 'm';
				pPacketStore->Size = Size;
				pPacketStore->cSeperator3 = 'z';
				pPacketStore->cSeperator4 = 'z';
				

				pPacketStore = (PPACKET_RECORD)((char*)pPacketStore + sizeof(PACKET_RECORD));
			}
			else
			{
				pPacketStore = pPacketStoreHead;
			}
			
        }
*/     

    return TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\wansup.c ===
/*++


Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    wansup.c

Abstract:

    support for ndiswan

Author:

    Yoram Bernet    (yoramb)    29-Oct-1997
    Rajesh Sundaram (rajeshsu)  01-Aug-1998

Environment:

    Kernel Mode

Revision History:

--*/

#include "psched.h"
#pragma hdrstop

/* External */

/* Static */

//
// Should be defined in ndis.h. Put it here for now.
//

#define UNKNOWN_PROTOCOL_TYPE (USHORT) -1

NDIS_STATUS
CleanWanLink(PADAPTER Adapter, 
             PPS_WAN_LINK WanLink);

NDIS_STATUS
WanHandleISSLOW(
    IN PGPC_CLIENT_VC Vc,
    IN PCO_CALL_PARAMETERS CallParameters);

VOID
PsWanMungeAddress(PUSHORT id, USHORT Index)
{
    *id = Index;
}

NDIS_STATUS
DeleteInterfaceForNdisWan(
    IN PADAPTER Adapter,
    IN PVOID StatusBuffer,
    IN UINT StatusBufferSize
    )
{
    PNDIS_WAN_LINE_DOWN LineDownBuff;
    PLIST_ENTRY         NextWanLink;
    PPS_WAN_LINK        WanLink;
    NDIS_STATUS         Status = NDIS_STATUS_FAILURE;

    LineDownBuff = (PNDIS_WAN_LINE_DOWN)StatusBuffer;

    PsDbgOut(DBG_TRACE, DBG_WAN,
             ("[DeleteInterfaceForNdisWan]: Linedown for remote address %02X:%02X:%02X:%02X:%02X:%02X \n",
              LineDownBuff->RemoteAddress[0],
              LineDownBuff->RemoteAddress[1],
              LineDownBuff->RemoteAddress[2],
              LineDownBuff->RemoteAddress[3],
              LineDownBuff->RemoteAddress[4],
              LineDownBuff->RemoteAddress[5]));


    //
    // Walk the List & remove the WanLink
    //
    PS_LOCK(&Adapter->Lock);

    NextWanLink = Adapter->WanLinkList.Flink;

    while(NextWanLink != &Adapter->WanLinkList) {

        WanLink = CONTAINING_RECORD(NextWanLink, PS_WAN_LINK, Linkage);

        //
        // We cannot compare the LocalAddress, because NDISWAN initially
        // passes us 0 for the LocalAddress in the LINE_UP
        // The LocalAddress is for Wanarp to store its context which it
        // sends down to NDISWAN. NDISWAN then sends this context back
        // to us as LocalAddress in LINE_DOWN. So, we have to ignore
        // the LocalAddress in the LINE_DOWN.
        //

        if(NdisEqualMemory(WanLink->OriginalRemoteMacAddress,
                           LineDownBuff->RemoteAddress,
                           sizeof(LineDownBuff->RemoteAddress)))
        {
            //
            // Get rid of the wanlink from the list.
            //
            g_WanLinkTable[WanLink->UniqueIndex] = 0;

            PS_UNLOCK(&Adapter->Lock);

            //
            // Munge the s-mac and r-mac so that wanarp can clean correctly.
            //
            PsWanMungeAddress((PUSHORT)&LineDownBuff->RemoteAddress[0], 
                              WanLink->UniqueIndex);

            PsWanMungeAddress((PUSHORT)&LineDownBuff->LocalAddress[0], 
                              (USHORT)(*(PUSHORT)&WanLink->OriginalLocalMacAddress[0]));

            Status = CleanWanLink(Adapter, WanLink);

            NdisMIndicateStatus(Adapter->PsNdisHandle,
                                NDIS_STATUS_WAN_LINE_DOWN,
                                StatusBuffer,
                                StatusBufferSize);

            return NDIS_STATUS_SUCCESS;
        }

        NextWanLink = NextWanLink->Flink;
    }

    PS_UNLOCK(&Adapter->Lock);

    PsDbgOut(DBG_CRITICAL_ERROR, DBG_WAN,
             ("[DeleteInterfaceForNdisWan]: Could not find wanlink for Remote Mac: (%02X:%02X:%02X:%02X:%02X:%02X) \n",
              LineDownBuff->RemoteAddress[0],
              LineDownBuff->RemoteAddress[1],
              LineDownBuff->RemoteAddress[2],
              LineDownBuff->RemoteAddress[3],
              LineDownBuff->RemoteAddress[4],
              LineDownBuff->RemoteAddress[5]));
    
    return Status;
}

NDIS_STATUS
PsWanGenerateUniqueIndex(
    PPS_WAN_LINK WanLink
)
{
    PADAPTER    Adapter = WanLink->Adapter;
    NDIS_STATUS Status  = NDIS_STATUS_FAILURE;
    USHORT      size, Index, i, j;
    PULONG_PTR  NewTable;

    PS_LOCK(&Adapter->Lock);

    for(i=0, Index = g_NextWanIndex;
        i < g_WanTableSize;
        i++)
    {
        if(g_WanLinkTable[Index] == 0)
        {
            //
            // We got a free slot.
            //

            g_WanLinkTable[Index]    = (ULONG_PTR)WanLink;
            WanLink->UniqueIndex     = Index;

            //
            // Assume that the next one is free.
            //
            g_NextWanIndex ++;
            g_NextWanIndex = g_NextWanIndex % g_WanTableSize;

            PS_UNLOCK(&Adapter->Lock);

            return NDIS_STATUS_SUCCESS;
        }

        Index ++;

        Index = Index % g_WanTableSize;
    } 

    //
    // We could not find a slot to insert the wanlink. Grow the table
    // and copy the existing table.
    //

    size = (g_WanTableSize + WAN_TABLE_INCREMENT) * sizeof(ULONG_PTR);

    PsAllocatePool(NewTable, size, WanTableTag);

    if(!NewTable)
    {
        PS_UNLOCK(&Adapter->Lock);

        return NDIS_STATUS_FAILURE;
    }

    NdisZeroMemory(NewTable, size);

    NdisMoveMemory(NewTable, g_WanLinkTable, g_WanTableSize * sizeof(ULONG_PTR));

    PsFreePool(g_WanLinkTable);

    g_WanLinkTable = NewTable;

    //
    //
    //
    g_WanLinkTable[g_WanTableSize] = (ULONG_PTR)WanLink;

    WanLink->UniqueIndex = g_WanTableSize;

    g_NextWanIndex = g_WanTableSize + 1;

    g_WanTableSize += WAN_TABLE_INCREMENT;

    PS_UNLOCK(&Adapter->Lock);

    return NDIS_STATUS_SUCCESS;
}

VOID
DeleteWanLink(
    PVOID   Instance,
    BOOLEAN AdapterLocked)
{
    PPS_WAN_LINK WanLink = (PPS_WAN_LINK)Instance;
        if(WanLink->pDiffServMapping)
        {
            PsFreePool(WanLink->pDiffServMapping);
        }

        if(WanLink->ShutdownMask & SHUTDOWN_DELETE_PIPE)
        {
            (*WanLink->PsComponent->DeletePipe)(WanLink->PsPipeContext);
        }

        if(WanLink->ShutdownMask & SHUTDOWN_FREE_PS_CONTEXT)
        {
            PsFreePool(WanLink->PsPipeContext);
        }

        if(WanLink->InstanceName.Buffer) {

            PsFreePool(WanLink->InstanceName.Buffer);
        }

        if(WanLink->MpDeviceName.Buffer){

           PsFreePool(WanLink->MpDeviceName.Buffer);
        }

        if(AdapterLocked)
        {
            RemoveEntryList(&WanLink->Linkage);
        }
        else
        {
            PS_LOCK(&WanLink->Adapter->Lock);

            RemoveEntryList(&WanLink->Linkage);

            PS_UNLOCK(&WanLink->Adapter->Lock);
        }

        NdisFreeSpinLock(&WanLink->Lock);

        PsFreePool(WanLink);

}

NDIS_STATUS
CreateInterfaceForNdisWan(
    IN PADAPTER Adapter,
    IN PVOID    StatusBuffer,
    IN UINT     StatusBufferSize
    )
/*++

Routine Description:

    Creates a TC interface to represent an underlying WAN link.

Arguments:

    Adapter - the adapter on which the link is being created.
    StatusBuffer - the buffer from NDISWAN.
    StatusBufferSize - the length of the buffer.

Return Values:

    None

--*/

{
    PNDIS_WAN_LINE_UP      LineUpBuff;
    PPS_WAN_LINK           WanLink;
    PLIST_ENTRY            NextWanLink;
    NDIS_STATUS            Status;
    PIP_WAN_LINKUP_INFO    RouterInfo;
    NTSTATUS               NtStatus;
    LARGE_INTEGER          Increment = {0, 1};
    LARGE_INTEGER          Index;
    PGPC_CLIENT_VC         Vc;
    UCHAR                  ZeroAddress[] = {0, 0, 0, 0, 0, 0};
    NDIS_HANDLE            LineUpHandle;
    int                    i,j;

    LineUpBuff = (PNDIS_WAN_LINE_UP)StatusBuffer;

    //
    // Check for MultiLink:
    //
    // The first link up will have a ZeroLocal Address, in this case, we create a new QoS interface. 
    // All subsequent lineups will have a non-zero LocalAddress. If the link is being updated, we 
    // only need to update the linkspeed on the existing interface.
    //

    if(!(NdisEqualMemory(LineUpBuff->LocalAddress, ZeroAddress, 6)))
    {
        //
        // Get the exisiting WanLink
        //
        PS_LOCK(&Adapter->Lock);

        NextWanLink = Adapter->WanLinkList.Flink;

        while(NextWanLink != &Adapter->WanLinkList) {

            WanLink = CONTAINING_RECORD(NextWanLink, PS_WAN_LINK, Linkage);

            if(NdisEqualMemory(WanLink->OriginalRemoteMacAddress,
                               LineUpBuff->RemoteAddress,
                               sizeof(LineUpBuff->RemoteAddress))) 
            {
                REFADD(&Adapter->RefCount, 'WANU');

                PS_UNLOCK(&Adapter->Lock);

                PsDbgOut(DBG_TRACE, DBG_WAN,
                         ("[CreateInterfaceForNdisWan]: Link speed of WanLink 0x%x has changed "
                          "from %d to %d \n", WanLink, WanLink->LinkSpeed, LineUpBuff->LinkSpeed));

                WanLink->LinkSpeed = LineUpBuff->LinkSpeed;

                UpdateWanLinkBandwidthParameters(WanLink);

                TcIndicateInterfaceChange(Adapter, WanLink, NDIS_STATUS_INTERFACE_CHANGE);

                //
                // Munge s-mac and d-mac and send to wanarp.
                //
                PsWanMungeAddress((PUSHORT)&LineUpBuff->RemoteAddress[0], 
                                  WanLink->UniqueIndex);

                PsWanMungeAddress((PUSHORT)&LineUpBuff->LocalAddress[0], 
                                  (USHORT)(*(PUSHORT)&WanLink->OriginalLocalMacAddress[0]));

                NdisMIndicateStatus(Adapter->PsNdisHandle,
                                    NDIS_STATUS_WAN_LINE_UP,
                                    StatusBuffer,
                                    StatusBufferSize);

                REFDEL(&Adapter->RefCount, FALSE, 'WANU');

                return NDIS_STATUS_SUCCESS;
            }

            NextWanLink = NextWanLink->Flink;
        }

        PS_UNLOCK(&Adapter->Lock);

        PsDbgOut(DBG_FAILURE, DBG_WAN,
                 ("[CreateInterfaceForNdisWan]: Got a change notification, but could not find wanlink "
                  "Remote Mac: (%02X:%02X:%02X:%02X:%02X:%02X) \n",
                  LineUpBuff->RemoteAddress[0],
                  LineUpBuff->RemoteAddress[1],
                  LineUpBuff->RemoteAddress[2],
                  LineUpBuff->RemoteAddress[3],
                  LineUpBuff->RemoteAddress[4],
                  LineUpBuff->RemoteAddress[5]));


        return NDIS_STATUS_FAILURE;
    }

    //
    // Create an internal representation of the link.
    //

    PsAllocatePool(WanLink,
                   sizeof(PS_WAN_LINK),
                   WanLinkTag);

    if(WanLink == NULL)
    {

        PsDbgOut(DBG_FAILURE,
                 DBG_WAN,
                 ("[CreateInterfaceForNdisWan]: Adapter %08X, couldn't create WanLink\n",
                  Adapter));

        return NDIS_STATUS_RESOURCES;
    }

    //
    // Initialize the wanlink.
    //

    NdisZeroMemory(WanLink, sizeof(PS_WAN_LINK));
    WanLink->Adapter  = Adapter;

    REFINIT(&WanLink->RefCount, WanLink, DeleteWanLink);
    REFADD(&WanLink->RefCount, 'WANU');
    PS_INIT_SPIN_LOCK(&WanLink->Lock);

    //
    // Link the SausageLink on the link list.
    //

    NdisInterlockedIncrement(&Adapter->WanLinkCount);

    NdisInterlockedInsertHeadList(&Adapter->WanLinkList,
                                  &WanLink->Linkage,
                                  &Adapter->Lock.Lock);

    //
    // Update the LinkSpeed and create a pipe off the wanlink.
    //
    WanLink->RawLinkSpeed = LineUpBuff->LinkSpeed;
    WanLink->LinkSpeed    = ( WanLink->RawLinkSpeed / 8 ) * 100;


    Status = UpdateWanLinkBandwidthParameters(WanLink);

    if(!NT_SUCCESS(Status))
    {
        PsDbgOut(DBG_FAILURE,
                 DBG_WAN,
                 ("[CreateInterfaceForNdisWan]: Adapter %08X, UpdateWanLinkBandwidthParameters failed with %08X",
                  Adapter, Status));

        REFDEL(&WanLink->RefCount, FALSE, 'WANU');

        return Status;
    }
        
    //
    // Extract the network addresses from the protocol part
    // of the status buffer. Update the network layer address list
    // which is held on the adapter.
    //

    switch(LineUpBuff->ProtocolType)
    {

      case PROTOCOL_IP:
          
          RouterInfo = (PIP_WAN_LINKUP_INFO) LineUpBuff->ProtocolBuffer;
          
          WanLink->DialUsage = RouterInfo->duUsage;
          WanLink->ProtocolType = LineUpBuff->ProtocolType;
          WanLink->LocalIpAddress = RouterInfo->dwLocalAddr;
          WanLink->RemoteIpAddress = RouterInfo->dwRemoteAddr;
          WanLink->LocalIpxAddress = 0;
          WanLink->RemoteIpxAddress = 0;
          break;

      default:
          
          //
          // Unknown address type. We'll create a manageable
          // entity, but - we don't know how to represent its
          // addresses. Therefore, we also don't know how to
          // format traffic control filters for it. So - it
          // probably won't be particualrly useful. At least it
          // lets the user see that there is an interface.
          //
          
          WanLink->ProtocolType = UNKNOWN_PROTOCOL_TYPE;
          WanLink->LocalIpAddress = 0;
          WanLink->RemoteIpAddress = 0;
          WanLink->LocalIpxAddress = 0;
          WanLink->RemoteIpxAddress = 0;
    }

    PsAllocatePool(WanLink->InstanceName.Buffer,
                   Adapter->WMIInstanceName.Length + WanPrefix.Length + INSTANCE_ID_SIZE,
                   PsMiscTag);

    if(!WanLink->InstanceName.Buffer)
    {
        PsDbgOut(DBG_FAILURE,
                 DBG_WAN,
                 ("[CreateInterfaceForNdisWan]: Adapter %08X, could not allocate memory for instance name \n",
                  Adapter));

        REFDEL(&WanLink->RefCount, FALSE, 'WANU');
        return NDIS_STATUS_RESOURCES;
    }

    if((Status = PsWanGenerateUniqueIndex(WanLink)) != NDIS_STATUS_SUCCESS)
    {
        PsDbgOut(DBG_FAILURE,
                 DBG_WAN,
                 ("[CreateInterfaceForNdisWan]: Adapter %08X, PsWanGenerateUniqueIndex failed with Status %08X \n",
                  Adapter, Status));

        REFDEL(&WanLink->RefCount, FALSE, 'WANU');
        return Status;
    }

    Index.QuadPart = WanLink->UniqueIndex;
    NtStatus = GenerateInstanceName(&WanPrefix,
                                    Adapter,
                                    &Index,
                                    &WanLink->InstanceName);


    //
    // Copy the DeviceName
    //
    WanLink->MpDeviceName.MaximumLength   = LineUpBuff->DeviceName.MaximumLength;

    PsAllocatePool(WanLink->MpDeviceName.Buffer,
                   WanLink->MpDeviceName.MaximumLength,
                   PsMiscTag);

    if(!WanLink->MpDeviceName.Buffer) 
    {
        PsDbgOut(DBG_FAILURE,
                 DBG_WAN,
                 ("[CreateInterfaceForNdisWan]: Adapter %08X, could not allocate memory for device name \n",
                  Adapter));

        PS_LOCK(&Adapter->Lock);

        g_WanLinkTable[WanLink->UniqueIndex] = 0;

        REFDEL(&WanLink->RefCount, TRUE, 'WANU');

        PS_UNLOCK(&Adapter->Lock);
        
        return NDIS_STATUS_RESOURCES;
    }


    NdisZeroMemory(WanLink->MpDeviceName.Buffer, WanLink->MpDeviceName.MaximumLength);


    Status = CreateBestEffortVc(Adapter, 
                                &WanLink->BestEffortVc, 
                                WanLink);

    if(Status != NDIS_STATUS_SUCCESS)
    {
        PsDbgOut(DBG_FAILURE,
                 DBG_WAN,
                 ("[CreateInterfaceForNdisWan]: Adapter %08X, could not create BestEffort Vc, status %08X",
                  Adapter, Status));

        PS_LOCK(&Adapter->Lock);

        g_WanLinkTable[WanLink->UniqueIndex] = 0;

        REFDEL(&WanLink->RefCount, TRUE, 'WANU');

        PS_UNLOCK(&Adapter->Lock);

        return Status;
    }            

    //
    //  Create 2 BEVCS and make the NextVc as the first one.
    WanLink->NextVc = 0;

    for( i = 0; i < BEVC_LIST_LEN; i++)
    {
        
        Status = CreateBestEffortVc(Adapter, 
                                    &WanLink->BeVcList[i], 
                                    WanLink);

        if(Status != NDIS_STATUS_SUCCESS)
        {
            PsDbgOut(DBG_FAILURE,
                     DBG_WAN,
                     ("[CreateInterfaceForNdisWan]: Adapter %08X, could not create BestEffort Vc, status %08X",
                      Adapter, Status));

            PS_LOCK(&Adapter->Lock);

            g_WanLinkTable[WanLink->UniqueIndex] = 0;
                
            for( j = 0; j < i; j++ )
            {
                PS_LOCK_DPC(&WanLink->BeVcList[j].Lock);
 
                InternalCloseCall(&WanLink->BeVcList[j]);

                PS_LOCK(&Adapter->Lock);
            }

            PS_LOCK_DPC(&WanLink->BestEffortVc.Lock);

            InternalCloseCall(&WanLink->BestEffortVc);

            REFDEL(&WanLink->RefCount, TRUE, 'WANU');

            return Status;
        }
    }



    //
    // Copy the original Remote Addresses and munge it.
    //

    NdisMoveMemory(&WanLink->OriginalRemoteMacAddress,
                   &LineUpBuff->RemoteAddress,
                   6);

    PsWanMungeAddress((PUSHORT) &LineUpBuff->RemoteAddress[0], WanLink->UniqueIndex);

    NdisMIndicateStatus(Adapter->PsNdisHandle,
                        NDIS_STATUS_WAN_LINE_UP,
                        StatusBuffer,
                        StatusBufferSize);

    //
    // Fail if wanarp has failed the line up
    //
    
    *((ULONG UNALIGNED *)(&LineUpHandle)) =
        *((ULONG UNALIGNED *)(&LineUpBuff->LocalAddress[2]));
    
    if (LineUpHandle == NULL) 
    {
        PsDbgOut(DBG_FAILURE, DBG_WAN, 
                 ("[ClStatusIndication]: wanarp has failed the lineup. "
                  "Remote Address (%02X:%02X:%02X:%02X:%02X:%02X) \n", 
                  LineUpBuff->RemoteAddress[0],
                  LineUpBuff->RemoteAddress[1],
                  LineUpBuff->RemoteAddress[2],
                  LineUpBuff->RemoteAddress[3],
                  LineUpBuff->RemoteAddress[4],
                  LineUpBuff->RemoteAddress[5]));
   
        PS_LOCK(&Adapter->Lock);

        g_WanLinkTable[WanLink->UniqueIndex] = 0;

        for( j = 0; j < BEVC_LIST_LEN; j++ )
        {
            PS_LOCK_DPC(&WanLink->BeVcList[j].Lock);
 
            InternalCloseCall(&WanLink->BeVcList[j]);

            PS_LOCK(&Adapter->Lock);
        }   

        PS_LOCK_DPC(&WanLink->BestEffortVc.Lock);

        InternalCloseCall(&WanLink->BestEffortVc);
            
        REFDEL(&WanLink->RefCount, FALSE, 'WANU');

        return NDIS_STATUS_FAILURE;
    }
    else
    {
        //
        // If wanarp has succeeded the lineup, we cannot get a zero local mac address.
        //
        PsAssert(!(NdisEqualMemory(LineUpBuff->LocalAddress, ZeroAddress, 6)));
    }

    //
    // Copy the device name that wanarp has filled in.
    //

    WanLink->MpDeviceName.Length = LineUpBuff->DeviceName.Length;
    NdisMoveMemory(WanLink->MpDeviceName.Buffer,
                   LineUpBuff->DeviceName.Buffer,
                   LineUpBuff->DeviceName.Length);

    //
    // Munge the smac address. Remember the original one that wanarp gave us.
    //

    NdisMoveMemory(&WanLink->OriginalLocalMacAddress,
                   &LineUpBuff->LocalAddress,
                   6);

    PsWanMungeAddress((PUSHORT)&LineUpBuff->LocalAddress[0], WanLink->UniqueIndex);

    //
    // Create the headers that have to be slapped on the send/recv path.
    //
    NdisMoveMemory(&WanLink->SendHeader.DestAddr[0], 
                   WanLink->OriginalRemoteMacAddress, 
                   ARP_802_ADDR_LENGTH);

    NdisMoveMemory(&WanLink->SendHeader.SrcAddr[0] , 
                   LineUpBuff->LocalAddress,
                   ARP_802_ADDR_LENGTH);

    NdisMoveMemory(&WanLink->RecvHeader.DestAddr[0],
                   WanLink->OriginalLocalMacAddress,
                   ARP_802_ADDR_LENGTH);

    NdisMoveMemory(&WanLink->RecvHeader.SrcAddr[0],
                   LineUpBuff->RemoteAddress,
                   ARP_802_ADDR_LENGTH);

    //
    // Unmunge the remote address in the lineup buff now.
    //
    PsWanMungeAddress((PUSHORT)&LineUpBuff->RemoteAddress[0], 
                      (USHORT)(*(PUSHORT)WanLink->OriginalRemoteMacAddress));


    // 
    // We are ready to recv and send packets.
    //

    PS_LOCK(&WanLink->Lock);

    WanLink->State = WanStateOpen;

    PS_UNLOCK(&WanLink->Lock);

    PsScheduleInterfaceIdWorkItem(Adapter, WanLink);

    //
    // Indicate the new interface up to the TCI. We indicate both the
    // addition of a new interface and the addresses available on it.
    // The address descriptors indicated for WAN interfaces differ from
    // those indicated for LAN interfaces. WAN interfaces include a
    // destination network layer address, as well as a source address.
    //

    TcIndicateInterfaceChange(Adapter, WanLink, NDIS_STATUS_INTERFACE_UP);


    PsDbgOut(DBG_TRACE, DBG_WAN,
             ("[CreateInterfaceForNdisWan]: Created WanLink 0x%x, Remote Address (%02X:%02X:%02X:%02X:%02X:%02X) \n",
              WanLink,
              LineUpBuff->RemoteAddress[0],
              LineUpBuff->RemoteAddress[1],
              LineUpBuff->RemoteAddress[2],
              LineUpBuff->RemoteAddress[3],
              LineUpBuff->RemoteAddress[4],
              LineUpBuff->RemoteAddress[5]));

    return(NDIS_STATUS_SUCCESS);

}

NDIS_STATUS
OpenWanAddressFamily(
    IN  PADAPTER                Adapter,
    IN  PCO_ADDRESS_FAMILY      WanAddressFamily
    )

/*++

Routine Description:

    Establish the binding between the PS miniport, NDISWAN and the
    NDISWAN call manager.

Arguments:

    Adapter - pointer to adapter

Return Value:

    None

--*/

{
    NDIS_CLIENT_CHARACTERISTICS WanClCharacteristics;
    NDIS_STATUS Status;

    WanClCharacteristics.MajorVersion = 5;
    WanClCharacteristics.MinorVersion = 0;
    WanClCharacteristics.Reserved     = 0;

    WanClCharacteristics.ClCreateVcHandler              = WanCreateVc;
    WanClCharacteristics.ClDeleteVcHandler              = WanDeleteVc;
    WanClCharacteristics.ClOpenAfCompleteHandler        = WanOpenAddressFamilyComplete;
    WanClCharacteristics.ClCloseAfCompleteHandler       = WanCloseAddressFamilyComplete;
    WanClCharacteristics.ClRegisterSapCompleteHandler   = WanRegisterSapComplete;
    WanClCharacteristics.ClDeregisterSapCompleteHandler = WanDeregisterSapComplete;
    WanClCharacteristics.ClMakeCallCompleteHandler      = WanMakeCallComplete;
    WanClCharacteristics.ClModifyCallQoSCompleteHandler = WanModifyCallComplete;
    WanClCharacteristics.ClCloseCallCompleteHandler     = WanCloseCallComplete;
    WanClCharacteristics.ClAddPartyCompleteHandler      = WanAddPartyComplete;
    WanClCharacteristics.ClDropPartyCompleteHandler     = WanDropPartyComplete;
    WanClCharacteristics.ClIncomingCallHandler          = WanIncomingCall;
    WanClCharacteristics.ClIncomingCallQoSChangeHandler = WanIncomingCallQoSChange;
    WanClCharacteristics.ClIncomingCloseCallHandler     = WanIncomingCloseCall;
    WanClCharacteristics.ClIncomingDropPartyHandler     = WanIncomingDropParty;
    WanClCharacteristics.ClCallConnectedHandler         = WanCallConnected;
    WanClCharacteristics.ClRequestHandler               = WanCoRequest;
    WanClCharacteristics.ClRequestCompleteHandler       = WanCoRequestComplete;

    PsDbgOut(DBG_TRACE,
             DBG_WAN | DBG_INIT,
             ("[OpenWanAddressFamily]: Adapter %08X \n", Adapter));

    Status = NdisClOpenAddressFamily(Adapter->LowerMpHandle,
                                     WanAddressFamily,
                                     Adapter,
                                     &WanClCharacteristics,
                                     sizeof(WanClCharacteristics),
                                     &Adapter->WanCmHandle);

    if(Status != NDIS_STATUS_PENDING)
    {
        WanOpenAddressFamilyComplete(Status,
                                     Adapter,
                                     Adapter->WanCmHandle);
    }

    return Status;

} // OpenWanAddressFamily


VOID
WanOpenAddressFamilyComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolAfContext,
    IN  NDIS_HANDLE NdisAfHandle
    )

/*++

Routine Description:

    Complete a call to NdisClOpenAddressFamily.

Arguments:

    see the DDK

Return Value:

    None

--*/

{
    PADAPTER Adapter = (PADAPTER)ProtocolAfContext;


    if(Status != NDIS_STATUS_SUCCESS){

        PsDbgOut(DBG_CRITICAL_ERROR,
                 DBG_WAN,
                 ("[WanOpenAddressFamilyComplete]: Adapter %08X, open failed %08X\n",
                 Adapter, Status));

        PsAdapterWriteEventLog(
            EVENT_PS_REGISTER_ADDRESS_FAMILY_FAILED,
            0,
            &Adapter->MpDeviceName,
            sizeof(Status),
            &Status);

        return;
    }
    else{

        PS_LOCK(&Adapter->Lock);

        Adapter->WanBindingState |= WAN_ADDR_FAMILY_OPEN;

        Adapter->ShutdownMask |= SHUTDOWN_CLOSE_WAN_ADDR_FAMILY;

        Adapter->WanCmHandle = NdisAfHandle;

        Adapter->FinalStatus = Status;

        PS_UNLOCK(&Adapter->Lock);

        PsDbgOut(DBG_TRACE,
                DBG_WAN | DBG_INIT,
                ("[WanOpenAddressFamilyComplete]: Adapter %08X, Status = %x\n",
                Adapter,
                Status));
    }

} // WanOpenAddressFamilyComplete

VOID
WanMakeCallComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE ProtocolVcContext,
    IN NDIS_HANDLE NdisPartyHandle,
    IN OUT PCO_CALL_PARAMETERS CallParameters
    )
{
    PGPC_CLIENT_VC       Vc      = (PGPC_CLIENT_VC) ProtocolVcContext;
    PADAPTER             Adapter = Vc->Adapter;

    PsStructAssert(Adapter);

    //
    // Common code to complete both synchronous and asynchronous
    // returns from WanMakeCall. Note that, unless there is a WAN
    // adapter, CmMakeCall will always complete synchronously.
    //

    if(Status != NDIS_STATUS_SUCCESS){

        //
        // We probably at least succeeeded in creating a VC in NDISWAN.
        // If we did, we should delete it here. We may have failed however,
        // because we could not create the VC, in which case, we have
        // nothing to delete.
        //

        if(Vc->NdisWanVcHandle){

            NdisCoDeleteVc(Vc->NdisWanVcHandle);

            Vc->NdisWanVcHandle = NULL;
        }
    }

    CompleteMakeCall(Vc,
                     CallParameters,
                     Status);
}

VOID
WanModifyCallComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE ProtocolVcContext,
    IN OUT PCO_CALL_PARAMETERS CallParameters
    )
{
    PGPC_CLIENT_VC Vc = (PGPC_CLIENT_VC)ProtocolVcContext;
    PADAPTER Adapter = Vc->Adapter;

    PsStructAssert(Adapter);

    //
    // Common code to complete both synchronous and asynchronous
    // returns from WanModifyCall.
    //

    if(Status != NDIS_STATUS_SUCCESS) {

        //
        // We changed some of the ISSLOW stuff - Time to revert back
        //

        WanHandleISSLOW(Vc, Vc->CallParameters);
    }

    ModifyCallComplete(Vc, CallParameters, Status);
}


VOID
WanCloseAddressFamilyComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolBindingContext
    )
{
    PADAPTER Adapter = (PADAPTER)ProtocolBindingContext;

    PS_LOCK(&Adapter->Lock);
    Adapter->WanBindingState &= ~WAN_ADDR_FAMILY_OPEN;
    PS_UNLOCK(&Adapter->Lock);
}

NDIS_STATUS
WanCreateVc(
    IN NDIS_HANDLE  ProtocolAfContext,
    IN  NDIS_HANDLE             NdisVcHandle,
    OUT PNDIS_HANDLE            ProtocolVcContext
    )
{
    DEBUGCHK;
    return NDIS_STATUS_FAILURE;
}

NDIS_STATUS
WanDeleteVc(
    IN  NDIS_HANDLE             ProtocolVcContext
    )
{
    DEBUGCHK;
    return NDIS_STATUS_FAILURE;
}

VOID
WanRegisterSapComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolSapContext,
    IN  PCO_SAP Sap,
    IN  NDIS_HANDLE NdisSapHandle
    )
{
    DEBUGCHK;
}

VOID
WanDeregisterSapComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolSapContext
    )
{
    DEBUGCHK;
}

NDIS_STATUS
WanIncomingCall(
    IN  NDIS_HANDLE ProtocolSapContext,
    IN  NDIS_HANDLE ProtocolVcContext,
    IN OUT PCO_CALL_PARAMETERS CallParameters
    )
{
    DEBUGCHK;
    return NDIS_STATUS_FAILURE;
}

VOID
WanAddPartyComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolPartyContext,
    IN  NDIS_HANDLE NdisPartyHandle,
    IN  PCO_CALL_PARAMETERS CallParameters
    )
{
    DEBUGCHK;
}

VOID
WanDropPartyComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolPartyContext
    )
{
    DEBUGCHK;
}


NDIS_STATUS
WanHandleISSLOW(
    IN PGPC_CLIENT_VC Vc,
    IN PCO_CALL_PARAMETERS CallParameters
    )
{
    LONG                        ParamsLength;
    LPQOS_OBJECT_HDR            QoSObject;
    PADAPTER                    Adapter = Vc->Adapter;
    PCO_MEDIA_PARAMETERS        CallMgrParams = CallParameters->MediaParameters;
    ULONGLONG                   i,j,k;

    //
    // See if this is an ISSLOW flow.
    //
    ParamsLength = (LONG)CallMgrParams->MediaSpecific.Length;
    QoSObject = (LPQOS_OBJECT_HDR)CallMgrParams->MediaSpecific.Parameters;

    //
    // By default, this is not an ISSLOW flow.
    //

    Vc->Flags &= ~GPC_ISSLOW_FLOW;

    while(ParamsLength > 0){

        if(QoSObject->ObjectType == QOS_OBJECT_WAN_MEDIA)
        {
            LPQOS_WAN_MEDIA WanMedia = (LPQOS_WAN_MEDIA)QoSObject;

            WanMedia->ISSLOW = FALSE;

            //
            // See if the flow is an ISSLOW flow. If the TokenRate of the flow
            // is under ISSLOW TokenRate and the PacketSize is under MaxPacketSize
            // Then we qualify this as ISSLOW flows.
            //
            // If a wanlink's linkspeed is greater than a certain amount, we don't run issow over it.
            //

            if((Vc->WanLink->LinkSpeed <= Adapter->ISSLOWLinkSpeed) && 
                (CallParameters->CallMgrParameters->Transmit.ServiceType != SERVICETYPE_BESTEFFORT))
            {
                i = (ULONG) Adapter->ISSLOWTokenRate * (ULONG) CallParameters->CallMgrParameters->Transmit.MaxSduSize;
                j = (ULONG) Adapter->ISSLOWPacketSize * (ULONG) CallParameters->CallMgrParameters->Transmit.TokenRate;
                k = (ULONG) Adapter->ISSLOWTokenRate * (ULONG)Adapter->ISSLOWPacketSize;

                if((i+j)<k)
                {
                    WanMedia->ISSLOW = TRUE;

                    PsDbgOut(DBG_TRACE, DBG_WAN,
                             ("[WanHandleISSLOW]: Vc %08X is an ISSLOW VC (TokenRate = %d, PacketSize = %d \n",
                              Vc, CallParameters->CallMgrParameters->Transmit.TokenRate,
                              CallParameters->CallMgrParameters->Transmit.MaxSduSize));

                    //
                    // The MaxSDUSize is normally a measure of the latency requirements of -that- flow
                    // For audio codes, MaxSDUSize = f(Latency requirements, unit size);
                    //
                    // But, we don't want to chop these into very small fragments. Therefore, we have
                    // an upper bound and pick the maximum.
                    //

                    if(CallParameters->CallMgrParameters->Transmit.MaxSduSize > Adapter->ISSLOWFragmentSize)
                    {
                        Vc->ISSLOWFragmentSize = CallParameters->CallMgrParameters->Transmit.MaxSduSize;
                    }
                    else
                    {
                        Vc->ISSLOWFragmentSize = Adapter->ISSLOWFragmentSize;
                    }

                    Vc->Flags |= GPC_ISSLOW_FLOW;

                    PsDbgOut(DBG_TRACE, DBG_WAN,
                             ("[WanHandleISSLOW]: Adapter %08X, ISSLOW Vc %08X, FragmentSize = %d bytes \n",
                              Adapter, Vc, Vc->ISSLOWFragmentSize));

                }
                else 
                {
                    PsDbgOut(DBG_TRACE, DBG_WAN,
                             ("[WanHandleISSLOW]: Non ISSLOW Vc %08X. ISSLOW TokenRate %d, "
                              "ISSLOW Packet Size %d, VC TokenRate %d, VC Packet Size %d \n", 
                              Vc, Adapter->ISSLOWTokenRate,
                              Adapter->ISSLOWPacketSize, 
                              CallParameters->CallMgrParameters->Transmit.TokenRate,
                              CallParameters->CallMgrParameters->Transmit.MaxSduSize));
                }
            }
            else 
            {
                PsDbgOut(DBG_TRACE, DBG_WAN,
                         ("[WanHandleISSLOW]: Non ISSLOW Vc %08X. (servicetype == B/E "
                          " or WAN LinkSpeed %d < ISSLOW LinkSpeed %d \n",
                          Vc, Vc->WanLink->LinkSpeed, Adapter->ISSLOWLinkSpeed));
            }

            return NDIS_STATUS_SUCCESS;
        }
        else {

            if(
                ((LONG)QoSObject->ObjectLength <= 0) ||
                ((LONG)QoSObject->ObjectLength > ParamsLength)
                ){

                return(QOS_STATUS_TC_OBJECT_LENGTH_INVALID);
            }

            ParamsLength -= QoSObject->ObjectLength;
            QoSObject = (LPQOS_OBJECT_HDR)((UINT_PTR)QoSObject +
                                           QoSObject->ObjectLength);

        }
    }

    return NDIS_STATUS_FAILURE;
}

NDIS_STATUS
WanMakeCall(
    IN PGPC_CLIENT_VC Vc,
    IN OUT PCO_CALL_PARAMETERS CallParameters
    )
{
    NDIS_STATUS Status;
    PADAPTER Adapter;

    Adapter = Vc->Adapter;
    PsStructAssert(Adapter);

    //
    // Handle ISSLOW
    //
    WanHandleISSLOW(Vc, CallParameters);

    //
    // Create a VC in the Wan adapter.
    //
    Vc->NdisWanVcHandle = NULL;

    Status = NdisCoCreateVc(Adapter->LowerMpHandle,
                            Adapter->WanCmHandle,
                            Vc,
                            &Vc->NdisWanVcHandle);
        
    PsAssert(Status != NDIS_STATUS_PENDING);
    
    if(Status != NDIS_STATUS_SUCCESS)
    {
        Vc->NdisWanVcHandle = 0;

        PsDbgOut(DBG_FAILURE, DBG_WAN,
                 ("[WanMakeCall]: cannot create VC.  Status = %d\n", Status));
        
        WanMakeCallComplete(Status, Vc, NULL, CallParameters);
    }
    else 
    {
        Status = NdisClMakeCall(Vc->NdisWanVcHandle, CallParameters, NULL, NULL);
        
        if(Status != NDIS_STATUS_PENDING){
            
            WanMakeCallComplete(Status, Vc, NULL, CallParameters);
        }
    }

    return (NDIS_STATUS_PENDING);
}

VOID
WanCloseCall(
    IN PGPC_CLIENT_VC Vc
    )
{
    NDIS_STATUS Status;

    //
    // Issue a CloseCall to the WAN call manager. 
    //

    PsAssert(Vc->NdisWanVcHandle);

    Status = NdisClCloseCall(Vc->NdisWanVcHandle,
                             NULL,
                             NULL,
                             0);

    if(Status != NDIS_STATUS_PENDING)
    {
        WanCloseCallComplete(Status,
                             Vc,
                             Vc->CallParameters);
    }
}
    
VOID
WanCloseCallComplete(
        NDIS_STATUS Status,
        NDIS_HANDLE ProtocolVcContext,
        PCO_CALL_PARAMETERS CallParameters
        )
{
    PGPC_CLIENT_VC Vc = (PGPC_CLIENT_VC) ProtocolVcContext;

    Status = NdisCoDeleteVc(Vc->NdisWanVcHandle);

    PsAssert(Status != NDIS_STATUS_PENDING);
    
    Vc->NdisWanVcHandle = 0;

    CmDeleteVc(Vc);

}

NDIS_STATUS
WanModifyCall(
    IN PGPC_CLIENT_VC Vc,
    IN OUT PCO_CALL_PARAMETERS CallParameters
    )
{
    NDIS_STATUS Status;

    WanHandleISSLOW(Vc, CallParameters);

    PsAssert(Vc->NdisWanVcHandle);

    Status = NdisClModifyCallQoS(Vc->NdisWanVcHandle, CallParameters);

    if(Status != NDIS_STATUS_PENDING)
    {
        WanModifyCallComplete(Status, Vc, CallParameters);
    }

    return NDIS_STATUS_PENDING;
}

VOID
AskWanLinksToClose(PADAPTER Adapter)
{

    PLIST_ENTRY NextWanLink;
    PPS_WAN_LINK WanLink;

    PsDbgOut(DBG_TRACE, DBG_WAN, 
             ("[AskWanLinksToClose]: Adapter %08X - All wanlinks are closing \n", Adapter));

    //
    // Walk the List & remove the WanLink
    //
    PS_LOCK(&Adapter->Lock);

    while(!IsListEmpty(&Adapter->WanLinkList)) {

        NextWanLink = RemoveHeadList(&Adapter->WanLinkList);

        WanLink = CONTAINING_RECORD(NextWanLink, PS_WAN_LINK, Linkage);

        //
        // Get rid of the wanlink from the list.
        //
        g_WanLinkTable[WanLink->UniqueIndex] = 0;

        PS_UNLOCK(&Adapter->Lock);

        CleanWanLink(Adapter, WanLink);

        PS_LOCK(&Adapter->Lock);

    }

    PS_UNLOCK(&Adapter->Lock);

    return;
}

NDIS_STATUS
CleanWanLink(PADAPTER Adapter, 
             PPS_WAN_LINK WanLink)
{
    PLIST_ENTRY      NextVc;
    PGPC_CLIENT_VC   Vc;
    PUSHORT          id;
    int              j;

    PsDbgOut(DBG_TRACE, DBG_WAN, ("[CleanWanLink]: WanLink 0x%x is going down \n", WanLink));

    TcIndicateInterfaceChange(Adapter, WanLink, NDIS_STATUS_INTERFACE_DOWN);

    PS_LOCK(&WanLink->Lock);

    WanLink->State = WanStateClosing;

    PS_UNLOCK(&WanLink->Lock);

    PS_LOCK(&Adapter->Lock);

    //
    //  Make sure to delete Be Vc1 also..

    for( j = 0; j < BEVC_LIST_LEN; j++ )
    {
        PS_LOCK_DPC(&WanLink->BeVcList[j].Lock);
 
        InternalCloseCall(&WanLink->BeVcList[j]);

        PS_LOCK(&Adapter->Lock);
    } 

    PS_LOCK_DPC(&WanLink->BestEffortVc.Lock);

    InternalCloseCall(&WanLink->BestEffortVc);

    NdisInterlockedDecrement(&Adapter->WanLinkCount);

    PS_LOCK(&Adapter->Lock);

    //
    // Clean up all the GPC VCs on the WanLink;
    //

    NextVc = Adapter->GpcClientVcList.Flink;

    while(NextVc != &Adapter->GpcClientVcList)
    {

        Vc = CONTAINING_RECORD(NextVc, GPC_CLIENT_VC, Linkage);

        NextVc = NextVc->Flink;

        PsAssert(Vc);

        if(Vc->WanLink == WanLink)
        {

            PS_LOCK_DPC(&Vc->Lock);

            if(Vc->ClVcState == CL_INTERNAL_CLOSE_PENDING || Vc->Flags & INTERNAL_CLOSE_REQUESTED)
            {
                // We have already closed this Vc. Let's move on.

                PS_UNLOCK_DPC(&Vc->Lock);
            }
            else 
            {

                InternalCloseCall(Vc);
    
                PS_LOCK(&Adapter->Lock);

                //
                // Sigh. We can't really get hold to the NextVc in a reliable manner. When we call 
                // InternalCloseCall on the Vc, it releases the Adapter Lock (since it might have to
                // make calls into NDIS). Now, in this window, the next Vc could go away, and we 
                // could point to a stale Vc. So, we start at the head of the list. 
                // Note that this can never lead to a infinite loop, since we don't process the 
                // internal close'd VCs repeatedly.
                //
    
                NextVc = Adapter->GpcClientVcList.Flink;
            }
        }
    }

    PS_UNLOCK(&Adapter->Lock);

    REFDEL(&WanLink->RefCount, FALSE, 'WANU');

    return NDIS_STATUS_SUCCESS;
}

VOID
WanIncomingCallQoSChange(
    IN  NDIS_HANDLE ProtocolVcContext,
    IN  PCO_CALL_PARAMETERS CallParameters
    )
{
    DEBUGCHK;
}

VOID
WanIncomingCloseCall(
    IN NDIS_STATUS CloseStatus,
    IN NDIS_HANDLE ProtocolVcContext,
    IN PVOID CloseData          OPTIONAL,
    IN UINT Size                OPTIONAL
    )
{
    PGPC_CLIENT_VC Vc = (PGPC_CLIENT_VC) ProtocolVcContext;

    PsAssert(Vc);

    CheckLLTag(Vc, GpcClientVc);

    PS_LOCK(&Vc->Adapter->Lock);

    PS_LOCK_DPC(&Vc->Lock);

    InternalCloseCall(Vc);

    return;
}

VOID
WanIncomingDropParty(
    IN NDIS_STATUS DropStatus,
    IN NDIS_HANDLE ProtocolPartyContext,
    IN PVOID CloseData          OPTIONAL,
    IN UINT Size                OPTIONAL
    )
{
    DEBUGCHK;
}

VOID
WanCallConnected(
    IN  NDIS_HANDLE ProtocolPartyContext
    )
{
    DEBUGCHK;
}

NDIS_STATUS
WanCoRequest(
    IN  NDIS_HANDLE ProtocolAfContext,
    IN  NDIS_HANDLE ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE ProtocolPartyContext    OPTIONAL,
    IN OUT PNDIS_REQUEST NdisRequest
    )
{
    DEBUGCHK;
    return NDIS_STATUS_INVALID_OID;
}

VOID
WanCoRequestComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolAfContext,
    IN  NDIS_HANDLE ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE ProtocolPartyContext    OPTIONAL,
    IN  PNDIS_REQUEST NdisRequest
    )
{
    ClRequestComplete(ProtocolAfContext,
                      NdisRequest,
                      Status);
}

NDIS_STATUS
UpdateWanLinkBandwidthParameters(PPS_WAN_LINK WanLink)
{
    //
    // Called any time the link speed is updated. This
    // function generates the adapter link speed and the
    // and non-best-effort rate limits, both in bytes per second.
    //

    PsUpdateLinkSpeed(WanLink->Adapter,
                      WanLink->RawLinkSpeed,
                      &WanLink->RemainingBandWidth,
                      &WanLink->LinkSpeed,
                      &WanLink->NonBestEffortLimit,
                      &WanLink->Lock);

    return UpdateWanSchedulingPipe(WanLink);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\wansup.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    wansup.h

Abstract:

    defines for WAN support functions

Author:

    Yoram Bernet (yoramb) 31-Oct-1997

Revision History:

--*/

#ifndef _WANSUP_
#define _WANSUP_

/* Prototypes */

NDIS_STATUS
DeleteInterfaceForNdisWan(
    IN PADAPTER Adapter,
    IN PVOID StatusBuffer,
    IN UINT StatusBufferSize
    );

NDIS_STATUS
CreateInterfaceForNdisWan(
    IN PADAPTER Adapter,
    IN PVOID StatusBuffer,
    IN UINT StatusBufferSize
    );

NDIS_STATUS
OpenWanAddressFamily(
    IN  PADAPTER                Adapter,
    IN  PCO_ADDRESS_FAMILY      WanAddressFamily
    );

VOID
WanOpenAddressFamilyComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolAfContext,
    IN  NDIS_HANDLE NdisAfHandle
    );

VOID
WanMakeCallComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE ProtocolVcContext,
    IN NDIS_HANDLE NdisPartyHandle,
    IN OUT PCO_CALL_PARAMETERS CallParameters
    );

VOID
WanModifyCallComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE ProtocolVcContext,
    IN OUT PCO_CALL_PARAMETERS CallParameters
    );

NDIS_STATUS
WanModifyCall(
    IN PGPC_CLIENT_VC Vc,
    IN OUT PCO_CALL_PARAMETERS CallParameters
    );

VOID
WanCloseAddressFamilyComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolBindingContext
    );

NDIS_STATUS
WanCreateVc(
    IN NDIS_HANDLE  ProtocolAfContext,
    IN  NDIS_HANDLE             NdisVcHandle,
    OUT PNDIS_HANDLE            ProtocolVcContext
    );

NDIS_STATUS
WanDeleteVc(
    IN  NDIS_HANDLE             ProtocolVcContext
    );

VOID
WanRegisterSapComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolSapContext,
    IN  PCO_SAP Sap,
    IN  NDIS_HANDLE NdisSapHandle
    );

VOID
WanDeregisterSapComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolSapContext
    );

NDIS_STATUS
WanIncomingCall(
    IN  NDIS_HANDLE ProtocolSapContext,
    IN  NDIS_HANDLE ProtocolVcContext,
    IN OUT PCO_CALL_PARAMETERS CallParameters
    );

VOID
WanAddPartyComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolPartyContext,
    IN  NDIS_HANDLE NdisPartyHandle,
    IN  PCO_CALL_PARAMETERS CallParameters
    );

VOID
WanDropPartyComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolPartyContext
    );


NDIS_STATUS
WanMakeCall(
    IN PGPC_CLIENT_VC Vc,
    IN OUT PCO_CALL_PARAMETERS CallParameters
    );

VOID
WanCloseCallComplete(
    NDIS_STATUS Status,
    NDIS_HANDLE ProtocolVcContext,
    PCO_CALL_PARAMETERS CallParameters
    );

VOID
WanCloseCall(
    IN PGPC_CLIENT_VC Vc
    );

VOID
WanIncomingCallQoSChange(
    IN  NDIS_HANDLE ProtocolVcContext,
    IN  PCO_CALL_PARAMETERS CallParameters
    );

VOID
WanIncomingCloseCall(
    IN NDIS_STATUS CloseStatus,
    IN NDIS_HANDLE ProtocolVcContext,
    IN PVOID CloseData          OPTIONAL,
    IN UINT Size                OPTIONAL
    );

VOID
WanIncomingDropParty(
    IN NDIS_STATUS DropStatus,
    IN NDIS_HANDLE ProtocolPartyContext,
    IN PVOID CloseData          OPTIONAL,
    IN UINT Size                OPTIONAL
    );

VOID
WanCallConnected(
    IN  NDIS_HANDLE ProtocolPartyContext
    );

NDIS_STATUS
WanCoRequest(
    IN  NDIS_HANDLE ProtocolAfContext,
    IN  NDIS_HANDLE ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE ProtocolPartyContext    OPTIONAL,
    IN OUT PNDIS_REQUEST NdisRequest
    );

VOID
WanCoRequestComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolAfContext,
    IN  NDIS_HANDLE ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE ProtocolPartyContext    OPTIONAL,
    IN  PNDIS_REQUEST NdisRequest
    );

NDIS_STATUS
UpdateWanLinkBandwidthParameters(PPS_WAN_LINK WanLink);
    

VOID 
AskWanLinksToClose(PADAPTER Adapter);

/* End Prototypes */

#define PROTOCOL_IP          0x0800
#define PROTOCOL_IPX         0x8137

#endif /* _WANSUP_ */

/* end wansup.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\status.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    status.h

Abstract:

    defines for status handlers

Author:

    Charlie Wickham (charlwi) 20-Jun-1996

Revision History:

--*/

#ifndef _STATUS_
#define _STATUS_

/* Prototypes */

VOID
ClStatusIndication(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS GeneralStatus,
    IN  PVOID       StatusBuffer,
    IN  UINT        StatusBufferSize
    );

VOID
ClStatusIndicationComplete(
    IN  NDIS_HANDLE BindingContext
    );

/* End Prototypes */

#endif /* _STATUS_ */

/* end status.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\zaw\zaw.c ===
#include <stdarg.h>
#include <stdio.h>
//#include <windows.h>
#include<nt.h>
#include<ntrtl.h>
#include<nturtl.h>
#include<stdlib.h>
#include<string.h>
#include<ctype.h>
#include<stdarg.h>
#include<tchar.h>
#include<windows.h>
#include <wmium.h>
#include <tcguid.h>
#include <netevent.h>
VOID
SendPschedIoctl(
    )

/*++

Routine Description:

    Does device i/o control with the driver for IOCTL_PSCHED_ZAW_EVENT. This kicks psched to read the registry.

Arguments:

    None.

Return Value:

    None.

 --*/
{

    HANDLE   PschedDriverHandle;
    ULONG    BytesReturned;
    BOOL     IOStatus;

    #define DriverName              TEXT("\\\\.\\PSCHED")

    #define IOCTL_PSCHED_ZAW_EVENT  CTL_CODE( \
                                        FILE_DEVICE_NETWORK, \
                                        20, \
                                        METHOD_BUFFERED, \
                                        FILE_ANY_ACCESS \
                                        )

    PschedDriverHandle = CreateFile(
                             DriverName,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                             NULL
                             );

    if (PschedDriverHandle != INVALID_HANDLE_VALUE) {

        IOStatus = DeviceIoControl(
                       PschedDriverHandle,
                       IOCTL_PSCHED_ZAW_EVENT,
                       NULL,
                       0,
                       NULL,
                       0,
                       &BytesReturned,
                       NULL
                       );

        printf("Configured psched with status %x \n", IOStatus);

        CloseHandle(PschedDriverHandle);
    }
}

int _cdecl main()
{
    SendPschedIoctl();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\wmi.c ===
/*++
Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    wmi.c

Abstract:
    Psched's WMI support.

Author:
    Rajesh Sundaram (rajeshsu) 01-Aug-1998.

Environment:

    Kernel Mode

Revision History:

--*/

#include "psched.h"
#pragma hdrstop


//
// Forward declaration for using in #pragma.
//

NTSTATUS
PsQueryGuidDataSize(
    PADAPTER Adapter, 
    PPS_WAN_LINK WanLink,
    PGPC_CLIENT_VC Vc,
    NDIS_OID Oid,
    PULONG BytesNeeded);


#pragma alloc_text(PAGE, PsQueryGuidDataSize)

#define ALIGN(x) (((x) + 7) & ~7)

NDIS_STRING DefaultProfile = NDIS_STRING_CONST("Default Profile");

#define fPS_GUID_TO_OID           0x00000001   // Normal GUID to OID mapping
#define fPS_GUID_TO_STATUS        0x00000002   // GUID to status mapping
#define fPS_GUID_ANSI_STRING      0x00000004   // ANSI string
#define fPS_GUID_UNICODE_STRING   0x00000008   // Unicode String
#define fPS_GUID_ARRAY            0x00000010   // Array
#define fPS_GUID_EVENT_ENABLED    0x00000020   // Event is enabled
#define fPS_GUID_NOT_SETTABLE     0x00000040   // GUID is read only
#define fPS_GUID_EVENT_PERMANENT  0x00000080

#define PS_GUID_SET_FLAG(m, f)          ((m)->Flags |= (f))
#define PS_GUID_CLEAR_FLAG(m, f)                ((m)->Flags &= ~(f))
#define PS_GUID_TEST_FLAG(m, f)         (((m)->Flags & (f)) != 0)
#define MOF_RESOURCE_NAME       L"PschedMofResource"

#if DBG
#define NUMBER_QOS_GUIDS 30
#else
#define NUMBER_QOS_GUIDS 24
#endif



NDIS_GUID   gPschedSupportedGuids[NUMBER_QOS_GUIDS] =
{
#if DBG
    //
    // GUID_QOS_LOG_LEVEL
    //
    {{0x9dd7f3aeL,0xf2a8,0x11d2,0xbe,0x1b,0x00,0xa0,0xc9,0x9e,0xe6,0x3b},
     OID_QOS_LOG_LEVEL,
     4,
     fPS_GUID_TO_OID
    },

    //
    // GUID_QOS_LOG_MASK
    //
    {{0x9e696320L,0xf2a8,0x11d2,0xbe,0x1b,0x00,0xa0,0xc9,0x9e,0xe6,0x3b},
     OID_QOS_LOG_MASK,
     4,
     fPS_GUID_TO_OID
    },

    //
    // GUID_QOS_STATUS_LOG_THRESHOLD
    //
    {{0x357b74d2L,0x6134,0x11d1,0xab,0x5b,0x00,0xa0,0xc9,0x24,0x88,0x37},
     QOS_STATUS_LOG_THRESHOLD,
     4,
     fPS_GUID_TO_STATUS
    },

    //
    // GUID_QOS_LOG_BUFFER_SIZE
    //
    {{0x357b74d3L,0x6134,0x11d1,0xab,0x5b,0x00,0xa0,0xc9,0x24,0x88,0x37},
     OID_QOS_LOG_BUFFER_SIZE,
     4,
     fPS_GUID_TO_OID
    },

    //
    // GUID_QOS_LOG_THRESHOLD
    //
    {{0x357b74d0L,0x6134,0x11d1,0xab,0x5b,0x00,0xa0,0xc9,0x24,0x88,0x37},
     OID_QOS_LOG_THRESHOLD,
     4,
     fPS_GUID_TO_OID
    },

    //
    // GUID_QOS_LOG_DATA
    //
    {{0x357b74d1L,0x6134,0x11d1,0xab,0x5b,0x00,0xa0,0xc9,0x24,0x88,0x37},
     OID_QOS_LOG_DATA,
     (ULONG)-1,
     fPS_GUID_TO_OID 
    },
#endif

    //
    // GUID_QOS_TC_SUPPORTED
    //
    {{0xe40056dcL,0x40c8,0x11d1,0x2c,0x91,0x00,0xaa,0x00,0x57,0x59,0x15},
     OID_QOS_TC_SUPPORTED,
     -1,
     fPS_GUID_TO_OID | fPS_GUID_NOT_SETTABLE
    },

    //
    // GUID_QOS_REMAINING_BANDWIDTH
    //
    {{0xc4c51720L,0x40ec,0x11d1,0x2c,0x91,0x00,0xaa,0x00,0x57,0x49,0x15},
     OID_QOS_REMAINING_BANDWIDTH,
     4,
     fPS_GUID_TO_OID | fPS_GUID_TO_STATUS | fPS_GUID_NOT_SETTABLE
    },

    //
    // GUID_QOS_BESTEFFORT_BANDWIDTH
    //
    {{0xed885290L,0x40ec,0x11d1,0x2c,0x91,0x00,0xaa,0x00,0x57,0x49,0x15},
     OID_QOS_BESTEFFORT_BANDWIDTH,
     4,
     fPS_GUID_TO_OID
    },

    //
    // GUID_QOS_HIERARCHY_CLASS
    //
    {{0xf2cc20c0,0x70c7,0x11d1,0xab,0x5c,0x0,0xa0,0xc9,0x24,0x88,0x37},
     OID_QOS_HIERARCHY_CLASS,
     4,
     fPS_GUID_TO_OID
    },

    //
    // GUID_QOS_LATENCY
    //
    {{0xfc408ef0L,0x40ec,0x11d1,0x2c,0x91,0x00,0xaa,0x00,0x57,0x49,0x15},
     OID_QOS_LATENCY,
     4,
     fPS_GUID_TO_OID | fPS_GUID_NOT_SETTABLE
    },

    //
    // GUID_QOS_FLOW_COUNT
    //
    {{0x1147f880L,0x40ed,0x11d1,0x2c,0x91,0x00,0xaa,0x00,0x57,0x49,0x15},
     OID_QOS_FLOW_COUNT,
     4,
     fPS_GUID_TO_OID | fPS_GUID_TO_STATUS | fPS_GUID_NOT_SETTABLE
    },

    //
    // GUID_QOS_NON_BESTEFFORT_LIMIT
    //
    {{0x185c44e0L,0x40ed,0x11d1,0x2c,0x91,0x00,0xaa,0x00,0x57,0x49,0x15},
     OID_QOS_NON_BESTEFFORT_LIMIT,
     4,
     fPS_GUID_TO_OID
    },

    //
    // GUID_QOS_SCHEDULING_PROFILES_SUPPORTED
    //
    {{0x1ff890f0L,0x40ed,0x11d1,0x2c,0x91,0x00,0xaa,0x00,0x57,0x49,0x15},
     OID_QOS_SCHEDULING_PROFILES_SUPPORTED,
     8,
     fPS_GUID_TO_OID
    },

    //
    // GUID_QOS_CURRENT_SCHEDULING_PROFILE
    //
    {{0x2966ed30L,0x40ed,0x11d1,0x2c,0x91,0x00,0xaa,0x00,0x57,0x49,0x15},
     OID_QOS_CURRENT_SCHEDULING_PROFILE,
     -1,
     fPS_GUID_TO_OID | fPS_GUID_UNICODE_STRING | fPS_GUID_NOT_SETTABLE
    },

    //
    // GUID_QOS_MAX_OUTSTANDING_SENDS
    //
    {{0x161ffa86L,0x6120,0x11d1,0x2c,0x91,0x00,0xaa,0x00,0x57,0x49,0x15},
     OID_QOS_MAX_OUTSTANDING_SENDS,
     4,
     fPS_GUID_TO_OID
    },

    //
    // GUID_QOS_DISABLE_DRR
    //
    {{0x1fa6dc7aL,0x6120,0x11d1,0x2c,0x91,0x00,0xaa,0x00,0x57,0x49,0x15},
     OID_QOS_DISABLE_DRR,
     4,
     fPS_GUID_TO_OID 
    },

    //
    // GUID_QOS_STATISTICS_BUFFER
    //
    {{0xbb2c0980L,0xe900,0x11d1,0xb0,0x7e,0x00,0x80,0xc7,0x13,0x82,0xbf},
     OID_QOS_STATISTICS_BUFFER,
     -1,
     fPS_GUID_TO_OID 
    },

    //
    // GUID_QOS_TC_INTERFACE_UP_INDICATION
    //
    {{0x0ca13af0L,0x46c4,0x11d1,0x78,0xac,0x00,0x80,0x5f,0x68,0x35,0x1e},
     NDIS_STATUS_INTERFACE_UP,
     8,
     fPS_GUID_TO_STATUS | fPS_GUID_EVENT_ENABLED | fPS_GUID_EVENT_PERMANENT
    },

    //
    // GUID_QOS_TC_INTERFACE_DOWN_INDICATION
    //
    {{0xaf5315e4L,0xce61,0x11d1,0x7c,0x8a,0x00,0xc0,0x4f,0xc9,0xb5,0x7c},
     NDIS_STATUS_INTERFACE_DOWN,
     8,
     fPS_GUID_TO_STATUS | fPS_GUID_EVENT_ENABLED | fPS_GUID_EVENT_PERMANENT
    },

    //
    // GUID_QOS_TC_INTERFACE_CHANGE_INDICATION
    //
    {{0xda76a254L,0xce61,0x11d1,0x7c,0x8a,0x00,0xc0,0x4f,0xc9,0xb5,0x7c},
     NDIS_STATUS_INTERFACE_CHANGE,
     8,
     fPS_GUID_TO_STATUS | fPS_GUID_EVENT_ENABLED | fPS_GUID_EVENT_PERMANENT
    },

    //
    // GUID_QOS_FLOW_MODE
    //
    {{0x5c82290aL,0x515a,0x11d2,0x8e,0x58,0x00,0xc0,0x4f,0xc9,0xbf,0xcb},
     OID_QOS_FLOW_MODE,
     4,
     fPS_GUID_TO_OID
    },

    //
    // GUID_QOS_ISSLOW_FLOW
    //
    {{0xabf273a4,0xee07,0x11d2,0xbe,0x1b,0x00,0xa0,0xc9,0x9e,0xe6,0x3b},
     OID_QOS_ISSLOW_FLOW,
     4,
     fPS_GUID_TO_OID | fPS_GUID_NOT_SETTABLE
    },

    //
    // GUID_QOS_TIMER_RESOLUTION
    //
    {{0xba10cc88,0xf13e,0x11d2,0xbe,0x1b,0x00,0xa0,0xc9,0x9e,0xe6,0x3b},
     OID_QOS_TIMER_RESOLUTION,
     4,
     fPS_GUID_TO_OID | fPS_GUID_NOT_SETTABLE
    },

    //
    // GUID_QOS_FLOW_IP_CONFORMING
    //
    {{0x07f99a8b, 0xfcd2, 0x11d2, 0xbe, 0x1e,  0x00, 0xa0, 0xc9, 0x9e, 0xe6, 0x3b},
     OID_QOS_FLOW_IP_CONFORMING,
     4,
     fPS_GUID_TO_OID | fPS_GUID_NOT_SETTABLE
    },

    //
    // GUID_QOS_FLOW_IP_NONCONFORMING
    //
    {{0x087a5987, 0xfcd2, 0x11d2, 0xbe, 0x1e,  0x00, 0xa0, 0xc9, 0x9e, 0xe6, 0x3b},
     OID_QOS_FLOW_IP_NONCONFORMING,
     4,
     fPS_GUID_TO_OID | fPS_GUID_NOT_SETTABLE
    },

    //
    // GUID_QOS_FLOW_8021P_CONFORMING
    //
    {{0x08c1e013, 0xfcd2, 0x11d2, 0xbe, 0x1e,  0x00, 0xa0, 0xc9, 0x9e, 0xe6, 0x3b},
     OID_QOS_FLOW_8021P_CONFORMING,
     4,
     fPS_GUID_TO_OID | fPS_GUID_NOT_SETTABLE
    },

    //
    // GUID_QOS_FLOW_8021P_NONCONFORMING
    //
    {{0x09023f91, 0xfcd2, 0x11d2, 0xbe, 0x1e,  0x00, 0xa0, 0xc9, 0x9e, 0xe6, 0x3b},
     OID_QOS_FLOW_8021P_NONCONFORMING,
     4,
     fPS_GUID_TO_OID | fPS_GUID_NOT_SETTABLE
    },

    //
    // GUID_QOS_ENABLE_AVG_STATS
    //
    {{0xbafb6d11, 0x27c4, 0x4801, 0xa4, 0x6f, 0xef, 0x80, 0x80, 0xc1, 0x88, 0xc8},
     OID_QOS_ENABLE_AVG_STATS,
     4,
     fPS_GUID_TO_OID
    },

    //
    // GUID_QOS_ENABLE_WINDOW_ADJUSTMENT
    //
    {{0xaa966725, 0xd3e9, 0x4c55, 0xb3, 0x35, 0x2a, 0x0, 0x27, 0x9a, 0x1e, 0x64},
     OID_QOS_ENABLE_WINDOW_ADJUSTMENT,
     4,
     fPS_GUID_TO_OID
    }
};

NTSTATUS
PsWmiGetGuid(
        OUT     PNDIS_GUID                              *ppNdisGuid,
        IN      LPGUID                                  guid,
        IN      NDIS_OID                                Oid
        )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    UINT            c;
    PNDIS_GUID      pNdisGuid;
    NDIS_STATUS     RetStatus = STATUS_UNSUCCESSFUL;
    
    //
    //      Search the custom GUIDs
    //
    for (c = 0, pNdisGuid = gPschedSupportedGuids;
         (c < NUMBER_QOS_GUIDS);
         c++, pNdisGuid++)
    {
        //
        //      Make sure that we have a supported GUID and the GUID maps
        //      to an OID.
        //
        if (NULL != guid)
        {
            //
            //  We are to look for a guid to oid mapping.
            //
            if (NdisEqualMemory(&pNdisGuid->Guid, guid, sizeof(GUID)))
            {
                //
                //      We found the GUID, save the OID that we will need to
                //      send to the miniport.
                //
                RetStatus = STATUS_SUCCESS;
                *ppNdisGuid = pNdisGuid;
                
                break;
            }
        }
        else
        {
            //
            //  We need to find the quid for the status indication
            //
            if (PS_GUID_TEST_FLAG(pNdisGuid, fPS_GUID_TO_STATUS) &&
                (pNdisGuid->Oid == Oid))
            {
                RetStatus = STATUS_SUCCESS;
                *ppNdisGuid = pNdisGuid;
                
                break;
            }
        }
    }
    
    return(RetStatus);
}

NTSTATUS
PsWmiRegister(
        IN      ULONG_PTR                               RegistrationType,
        IN      PWMIREGINFO                             wmiRegInfo,
        IN      ULONG                                   wmiRegInfoSize,
        IN      PULONG                                  pReturnSize
        )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PWMIREGINFO             pwri;
    ULONG                   SizeNeeded = 0;
    PNDIS_GUID              pguid;
    PWMIREGGUID             pwrg;
    PUCHAR                  ptmp;
    NTSTATUS                Status;
    UINT                    c;
    
    //
    //      Initialize the return size.
    //
    *pReturnSize = 0;
    
    //
    //  Is this a register request?
    //
    if (WMIREGISTER == RegistrationType)
    {
        
        //
        // Determine the amount of space needed for the GUIDs, the MOF and the
        // registry path
        //
        SizeNeeded = sizeof(WMIREGINFO) + 
            (NUMBER_QOS_GUIDS * sizeof(WMIREGGUID)) +
            //(sizeof(MOF_RESOURCE_NAME) - sizeof(WCHAR) + sizeof(USHORT)) +
            (PsMpName.Length + sizeof(USHORT));
        
        
        //
        //      We need to give this above information back to WMI.
        //
        if (wmiRegInfoSize < SizeNeeded) 
        {
            PsAssert(wmiRegInfoSize >= 4);
            
            *((PULONG)wmiRegInfo) = SizeNeeded ;

            *pReturnSize = sizeof(ULONG);
            
            Status = STATUS_SUCCESS;
                
            PsDbgOut(DBG_TRACE, DBG_WMI,
                     ("[PsWmiRegister]: Insufficient buffer space for WMI registration information.\n"));
            
            return Status;
        }
        
        //
        //      Get a pointer to the buffer passed in.
        //
        pwri = wmiRegInfo;
        
        *pReturnSize = SizeNeeded;
        
        NdisZeroMemory(pwri, SizeNeeded);
        
        pwri->BufferSize     = SizeNeeded;

        //
        // Copy the GUIDs
        //

        pwri->GuidCount      = NUMBER_QOS_GUIDS;
        for(c = 0, pwrg = pwri->WmiRegGuid, pguid = gPschedSupportedGuids; 
            c < NUMBER_QOS_GUIDS; 
            c++, pguid++, pwrg++)
        {
            RtlCopyMemory(&pwrg->Guid, &pguid->Guid, sizeof(GUID));
        }
        
        //
        // Fill in the registry path
        //
        ptmp = (PUCHAR)pwrg;
        pwri->RegistryPath = (ULONG)((ULONG_PTR)ptmp - (ULONG_PTR)pwri);
        *((PUSHORT)ptmp) = PsMpName.Length;
        ptmp += sizeof(USHORT);
        RtlCopyMemory(ptmp, PsMpName.Buffer, PsMpName.Length);
        
        

	    /*
        //
        //      Get a pointer to the destination for the MOF name.
        //
        ptmp += PsMpName.Length;
        
        //
        //      Save the offset to the mof resource.
        //
        /*
        pwri->MofResourceName = (ULONG)((ULONG_PTR)ptmp - (ULONG_PTR)pwri);
        *((PUSHORT)ptmp) = sizeof(MOF_RESOURCE_NAME) - sizeof(WCHAR);
        ptmp += sizeof(USHORT);
        
        //
        //      Copy the mof name into the wri buffer.
        //
        RtlCopyMemory(ptmp, MOF_RESOURCE_NAME, sizeof(MOF_RESOURCE_NAME) - sizeof(WCHAR));
        */
        Status = STATUS_SUCCESS;
    }
    else
    {
        PsDbgOut(DBG_FAILURE, DBG_WMI,
                 ("[PsWmiRegister]: Unsupported registration type\n"));
        
        Status = STATUS_INVALID_PARAMETER;
    }

    return(Status);
}

NTSTATUS
PsTcNotify(IN PADAPTER     Adapter, 
           IN PPS_WAN_LINK WanLink,
           IN NDIS_OID     Oid,
           IN PVOID        StatusBuffer,
           IN ULONG        StatusBufferSize)
{
    KIRQL      OldIrql;
    NTSTATUS   NtStatus = STATUS_SUCCESS;
    
    do
    {
        PWCHAR                  pInstanceName;
        USHORT                  cbInstanceName;
        PWNODE_SINGLE_INSTANCE  wnode;
        ULONG                   wnodeSize;
        ULONG                   DataBlockSize   = 0;
        ULONG                   InstanceNameSize   = 0;
        ULONG                   BufSize;
        PUCHAR                  ptmp;
        PNDIS_GUID              pNdisGuid;
       
        REFADD(&Adapter->RefCount, 'WMIN'); 
        
        if(Adapter->MediaType == NdisMediumWan) {
            
            if(!WanLink) {
                
                REFDEL(&Adapter->RefCount, FALSE, 'WMIN'); 
                
                return STATUS_UNSUCCESSFUL;
            }
            
            PS_LOCK(&WanLink->Lock);
            
            if(WanLink->State != WanStateOpen) {
                
                PS_UNLOCK(&WanLink->Lock);
                
                REFDEL(&Adapter->RefCount, FALSE, 'WMIN'); 
                
                return STATUS_UNSUCCESSFUL;
            }
            else {
                REFADD(&WanLink->RefCount, 'WMIN'); 

                PS_UNLOCK(&WanLink->Lock);
            }
            
            pInstanceName  = WanLink->InstanceName.Buffer;
            cbInstanceName = WanLink->InstanceName.Length;
        }
        else {
            
            //
            // Get nice pointers to the instance names.
            //
            
            pInstanceName  = Adapter->WMIInstanceName.Buffer;
            cbInstanceName = Adapter->WMIInstanceName.Length;
        }
        
        //
        // If there is no instance name then we can't indicate an event.
        //
        if (NULL == pInstanceName)
        {
            NtStatus = STATUS_UNSUCCESSFUL;
            break;
        }
        
        //
        // Check to see if the status is enabled for WMI event indication.
        //
        NtStatus = PsWmiGetGuid(&pNdisGuid, NULL, Oid);
        if ((!NT_SUCCESS(NtStatus)) ||
            !PS_GUID_TEST_FLAG(pNdisGuid, fPS_GUID_EVENT_ENABLED))
        {
            NtStatus = STATUS_UNSUCCESSFUL;
            break;
        }
        
        //
        // Determine the amount of wnode information we need.
        //
        wnodeSize = ALIGN(sizeof(WNODE_SINGLE_INSTANCE));

        //
        // If the data item is an array then we need to add in the number of
        // elements.
        //
        if (PS_GUID_TEST_FLAG(pNdisGuid, fPS_GUID_ARRAY))
        {
            DataBlockSize = StatusBufferSize + sizeof(ULONG);
        }
        else
        {
            DataBlockSize = StatusBufferSize;
        }
        
        //
        // We have a guid registered and active.
        //
   
        // 
        // The data has to start at a word boundary, so need to align everything before it (the wnode and the
        // instance name)
        //
        InstanceNameSize = ALIGN(cbInstanceName + sizeof(USHORT));
        BufSize = wnodeSize + InstanceNameSize + DataBlockSize;
        
        wnode = ExAllocatePoolWithTag(NonPagedPool, BufSize, WMITag);
        
        if (NULL == wnode)
        {
            NtStatus = STATUS_UNSUCCESSFUL;
            break;
        }
        
        NdisZeroMemory(wnode, BufSize);
        wnode->WnodeHeader.BufferSize = BufSize;
        wnode->WnodeHeader.ProviderId = IoWMIDeviceObjectToProviderId(PsDeviceObject);
        wnode->WnodeHeader.Version = 1;
        KeQuerySystemTime(&wnode->WnodeHeader.TimeStamp);
        
        RtlCopyMemory(&wnode->WnodeHeader.Guid, &pNdisGuid->Guid, sizeof(GUID));
        wnode->WnodeHeader.Flags = WNODE_FLAG_EVENT_ITEM |
            WNODE_FLAG_SINGLE_INSTANCE;
        
        wnode->OffsetInstanceName = wnodeSize;
       
        wnode->DataBlockOffset = wnodeSize + InstanceNameSize;

        wnode->SizeDataBlock = DataBlockSize;
        
        //
        // Get a pointer to the start of the data block.
        //
        ptmp = (PUCHAR)wnode + wnodeSize;
        
        //
        // Copy in the instance name. wnodesize is already aligned to 8 byte boundary, so the instance
        // name will begin at a 8 byte boundary.
        //
        *((PUSHORT)ptmp) = cbInstanceName;
        NdisMoveMemory(ptmp + sizeof(USHORT), pInstanceName, cbInstanceName);
        
        //
        // Increment ptmp to the start of the data block.
        //
        ptmp = (PUCHAR)wnode + wnode->DataBlockOffset;
        
        //
        // Copy in the data.
        //
        if (PS_GUID_TEST_FLAG(pNdisGuid, fPS_GUID_ARRAY))
        {
            //
            // If the status is an array but there is no data then complete it with no
            // data and a 0 length
            //
            if ((NULL == StatusBuffer) || (0 == StatusBufferSize))
            {
                *((PULONG)ptmp) = 0;
            }
            else
            {
                //
                // Save the number of elements in the first ULONG.
                //
                *((PULONG)ptmp) = StatusBufferSize / pNdisGuid->Size;
                
                //
                // Copy the data after the number of elements.
                //
                NdisMoveMemory(ptmp + sizeof(ULONG), StatusBuffer, StatusBufferSize);
            }
        }
        else
        {
            PsAssert(StatusBuffer != NULL);
            
            //
            // Do we indicate any data up?
            //
            if (0 != DataBlockSize)
            {
                //
                // Copy the data into the buffer.
                //
                NdisMoveMemory(ptmp, StatusBuffer, DataBlockSize);
            }
        }
        
        //
        // Indicate the event to WMI. WMI will take care of freeing
        // the WMI struct back to pool.
        //
        NtStatus = IoWMIWriteEvent(wnode);
        if (!NT_SUCCESS(NtStatus))
        {
            PsDbgOut(DBG_FAILURE, DBG_WMI,
                     ("[PsTcNotify]: Adapter %08X, Unable to indicate the WMI event.\n", Adapter));
            
            ExFreePool(wnode);
        }
    } while (FALSE);
    
    REFDEL(&Adapter->RefCount, FALSE, 'WMIN'); 
    
    if(WanLink) {
       
        REFDEL(&WanLink->RefCount, FALSE, 'WMIN'); 
    }
    
    return NtStatus;
    
}


NTSTATUS
FASTCALL
PsWmiEnableEvents(
    IN      LPGUID                                      Guid
    )
/*++
  
  Routine Description:
  
  Arguments:
  
  Return Value:
  
  --*/
{
    NTSTATUS        Status;
    PNDIS_GUID      pNdisGuid;
    
    do
    {
        //
        //      Get a pointer to the Guid/Status to enable.
        //
        Status = PsWmiGetGuid(&pNdisGuid, Guid, 0);
        
        if (!NT_SUCCESS(Status))
        {
            PsDbgOut(DBG_FAILURE, DBG_WMI,
                     ("[PsWmiEnableEvents]: Cannot find the guid to enable an event\n"));
            
            Status = STATUS_INVALID_PARAMETER;
            break;
        }
        
        //
        //      Is this GUID an event indication?
        //
        if (!PS_GUID_TEST_FLAG(pNdisGuid, fPS_GUID_TO_STATUS))
        {
            PsDbgOut(DBG_FAILURE, DBG_WMI,
                     ("[PsWmiEnableEvents]: Guid is not an event request \n"));
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }
        
        //
        //      Mark the guid as enabled
        //
        PS_GUID_SET_FLAG(pNdisGuid, fPS_GUID_EVENT_ENABLED);
        Status = STATUS_SUCCESS;
        
    } while (FALSE);
    
    return(Status);
}

NTSTATUS
FASTCALL
PsWmiDisableEvents(
        IN      LPGUID                                      Guid
        )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS        Status;
    PNDIS_GUID      pNdisGuid;
    
    do
    {
        //
        //      Get a pointer to the Guid/Status to enable.
        //
        Status = PsWmiGetGuid(&pNdisGuid, Guid, 0);
        if (!NT_SUCCESS(Status))
        {
            PsDbgOut(DBG_FAILURE, DBG_WMI,
                     ("[PsWmiDisableEvents]: Cannot find the guid to disable an event\n"));
            
            Status = STATUS_INVALID_PARAMETER;
            break;
        }
        
        //
        //      Is this GUID an event indication?
        //
        if (!PS_GUID_TEST_FLAG(pNdisGuid, fPS_GUID_TO_STATUS))
        {
            PsDbgOut(DBG_FAILURE, DBG_WMI,
                     ("[PsWmiDisableEvents]: Guid is not an event request \n"));
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }
        
        if(!PS_GUID_TEST_FLAG(pNdisGuid, fPS_GUID_EVENT_PERMANENT)) {
            //
            //  Mark the guid as disabled
            //
            PS_GUID_CLEAR_FLAG(pNdisGuid, fPS_GUID_EVENT_ENABLED);
        }
        
        Status = STATUS_SUCCESS;
        
    } while (FALSE);
    
    return(Status);
}

#define WMI_BUFFER_TOO_SMALL(_BufferSize, _Wnode, _WnodeSize, _pStatus, _pRSize)        \
{                                                                                       \
        if ((_BufferSize) < sizeof(WNODE_TOO_SMALL))                                    \
        {                                                                               \
                *(_pStatus) = STATUS_BUFFER_TOO_SMALL;                                  \
        }                                                                               \
        else                                                                            \
        {                                                                               \
                (_Wnode)->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);             \
                (_Wnode)->WnodeHeader.Flags |= WNODE_FLAG_TOO_SMALL;                    \
                ((PWNODE_TOO_SMALL)(_Wnode))->SizeNeeded = (_WnodeSize);                \
                *(_pRSize) = sizeof(WNODE_TOO_SMALL);                                   \
                *(_pStatus) = STATUS_SUCCESS;                                           \
        }                                                                               \
}

NTSTATUS
PsQueryGuidDataSize(
    PADAPTER Adapter, 
    PPS_WAN_LINK WanLink,
    PGPC_CLIENT_VC Vc,
    NDIS_OID Oid,
    PULONG BytesNeeded)
{
    ULONG Len;
    ULONG BytesWritten;
    NDIS_STATUS Status;

    PAGED_CODE();


    if(Vc) 
    {
        switch(Oid) 
        {
          case OID_QOS_STATISTICS_BUFFER:
              
              // If the query comes for a VC, then we return per flow stats
              // else we return per adapter stats. The query is also sent through
              // the scheduling components, so that they can fill in the per flow
              // or per query stats.
              //
              
              
              Len = 0;
              BytesWritten = 0;
              Status = NDIS_STATUS_BUFFER_TOO_SHORT;
              *BytesNeeded = 0;
              
              (*Vc->PsComponent->QueryInformation)
                  (Vc->PsPipeContext,
                   Vc->PsFlowContext,
                   Oid,
                   Len,
                   NULL,
                   &BytesWritten, 
                   BytesNeeded,
                   &Status);
              
              *BytesNeeded += sizeof(PS_FLOW_STATS) + FIELD_OFFSET(PS_COMPONENT_STATS, Stats);
              
              return STATUS_SUCCESS;

          case OID_QOS_ISSLOW_FLOW:
          case OID_QOS_FLOW_IP_CONFORMING:
          case OID_QOS_FLOW_IP_NONCONFORMING:
          case OID_QOS_FLOW_8021P_CONFORMING:
          case OID_QOS_FLOW_8021P_NONCONFORMING:
              *BytesNeeded = sizeof(ULONG);
              return STATUS_SUCCESS;
              
          default:
              
              return STATUS_WMI_NOT_SUPPORTED;
        }
    }

    //
    // The following OIDs are similar for both WAN and Adapters
    //
    switch(Oid) 
    {
        //
        // (12636): The following will be enabled when we do admission control over WAN. 
        // case OID_QOS_REMAINING_BANDWIDTH:
        // case OID_QOS_NON_BESTEFFORT_LIMIT:
        //

      case OID_QOS_BESTEFFORT_BANDWIDTH:
      case OID_QOS_LATENCY:
      case OID_QOS_FLOW_COUNT:
      case OID_QOS_FLOW_MODE:
      case OID_QOS_MAX_OUTSTANDING_SENDS:
      case OID_QOS_DISABLE_DRR:
      case OID_QOS_TIMER_RESOLUTION:
      case OID_QOS_ENABLE_AVG_STATS:
      case OID_QOS_ENABLE_WINDOW_ADJUSTMENT:
#if DBG
      case OID_QOS_LOG_BUFFER_SIZE:
      case OID_QOS_LOG_THRESHOLD:
      case OID_QOS_LOG_LEVEL:
      case OID_QOS_LOG_MASK:
#endif

          *BytesNeeded = sizeof(ULONG);
          
          return STATUS_SUCCESS;
          
#if DBG
      case OID_QOS_LOG_DATA:
            
          *BytesNeeded = SchedtGetBytesUnread();
          
          return STATUS_SUCCESS;
          
#endif
          
      case OID_QOS_CURRENT_SCHEDULING_PROFILE:
          
          if(!Adapter->ProfileName.Buffer) {
              
              *BytesNeeded = sizeof(DefaultProfile);
          }
          else {
              
              *BytesNeeded = Adapter->ProfileName.Length;
          }
          
          return STATUS_SUCCESS;
    }
    
    //
    // OIDs that are WAN link specific
    //
    
    if(WanLink) 
    {
        switch(Oid) 
        {
          case OID_QOS_HIERARCHY_CLASS:
          {
              Len = 0;
              BytesWritten = 0;
              Status = NDIS_STATUS_BUFFER_TOO_SHORT;
              *BytesNeeded = 0;
              
              (*WanLink->PsComponent->QueryInformation)
                  (WanLink->PsPipeContext,
                   0,
                   Oid, 
                   Len, 
                   NULL,
                   &BytesWritten,
                   BytesNeeded,
                   &Status);
         
              return STATUS_SUCCESS;
          }
          case OID_QOS_STATISTICS_BUFFER:
          {
              Len = 0;
              BytesWritten = 0;
              Status = NDIS_STATUS_BUFFER_TOO_SHORT;
              *BytesNeeded = 0;
          
              (*WanLink->PsComponent->QueryInformation)
                  (WanLink->PsPipeContext,
                   NULL,
                   Oid,
                   Len,
                   NULL,
                   &BytesWritten, 
                   BytesNeeded,
                   &Status);
          
              *BytesNeeded += sizeof(PS_ADAPTER_STATS) + FIELD_OFFSET(PS_COMPONENT_STATS, Stats);
              
              return STATUS_SUCCESS;
          }
          
          case OID_QOS_TC_SUPPORTED:
              
              *BytesNeeded = 0;
              
              CollectWanNetworkAddresses(Adapter, WanLink, BytesNeeded, NULL);
              
              return STATUS_SUCCESS;

          default:

              return STATUS_WMI_NOT_SUPPORTED;
        }
    }
    
    if(Adapter->MediaType != NdisMediumWan) 
    {

        switch(Oid) 
        {
          case OID_QOS_TC_SUPPORTED:
              
              *BytesNeeded = 0;
              
              CollectNetworkAddresses(Adapter, BytesNeeded, NULL);
              
              return STATUS_SUCCESS;
          
          //
          // (12636): Take the next 2 case statements away when we turn on admission control over WAN links.
          // 
          
          case OID_QOS_REMAINING_BANDWIDTH:
          case OID_QOS_NON_BESTEFFORT_LIMIT:

              *BytesNeeded = sizeof(ULONG);
              
              return STATUS_SUCCESS;

          case OID_QOS_HIERARCHY_CLASS:
          {
              Len = 0;
              BytesWritten = 0;
              Status = NDIS_STATUS_BUFFER_TOO_SHORT;
              *BytesNeeded = 0;
              
              (*Adapter->PsComponent->QueryInformation)
                  (Adapter->PsPipeContext,
                   0,
                   Oid, 
                   Len, 
                   NULL,
                   &BytesWritten,
                   BytesNeeded,
                   &Status);
         
              return STATUS_SUCCESS;
          }

          case OID_QOS_STATISTICS_BUFFER:
          {
              Len = 0;
              BytesWritten = 0;
              Status = NDIS_STATUS_BUFFER_TOO_SHORT;
              *BytesNeeded = 0;
              
              (*Adapter->PsComponent->QueryInformation)
                  (Adapter->PsPipeContext,
                   NULL,
                   Oid,
                   Len,
                   NULL,
                   &BytesWritten, 
                   BytesNeeded,
                   &Status);
              
              *BytesNeeded += sizeof(PS_ADAPTER_STATS) + FIELD_OFFSET(PS_COMPONENT_STATS, Stats);
              
              return STATUS_SUCCESS;
          }
          
          default:
              
              return STATUS_WMI_NOT_SUPPORTED;
        }
    }

    return STATUS_WMI_NOT_SUPPORTED;
}

NTSTATUS
PsQueryGuidData(
    PADAPTER Adapter,
    PPS_WAN_LINK WanLink,
    PGPC_CLIENT_VC Vc,
    NDIS_OID Oid,
    PVOID Buffer,
    ULONG BufferSize)
{

    PULONG pData = (PULONG) Buffer;
    ULONG Len;
    ULONG BytesNeeded;
    ULONG BytesWritten;
    PUCHAR Data;
    NDIS_STATUS Status;
    PPS_COMPONENT_STATS  Cstats;

    PsAssert(((ULONGLONG)pData % sizeof(PULONG)) == 0);

    if(Vc) 
    {
        switch(Oid) 
        {
          case OID_QOS_FLOW_IP_CONFORMING:
              *pData = (((PCF_INFO_QOS)(Vc->CfInfoQoS))->ToSValue) >> 2;
              return STATUS_SUCCESS;

          case OID_QOS_FLOW_IP_NONCONFORMING:
              *pData = (Vc->IPPrecedenceNonConforming >> 2);
              return STATUS_SUCCESS;

          case OID_QOS_FLOW_8021P_CONFORMING:
              *pData = Vc->UserPriorityConforming;
              return STATUS_SUCCESS;

          case OID_QOS_FLOW_8021P_NONCONFORMING:
              *pData = Vc->UserPriorityNonConforming;
              return STATUS_SUCCESS;
            
          case OID_QOS_ISSLOW_FLOW:

              *pData = (Vc->Flags & GPC_ISSLOW_FLOW)?TRUE:FALSE;

              return STATUS_SUCCESS;

          case OID_QOS_STATISTICS_BUFFER:
              
              // If the query comes for a VC, then we return per flow stats
              // else we return per adapter stats. The query is also sent through
              // the scheduling components, so that they can fill in the per flow
              // or per query stats.
              //
              
              
              Len = BufferSize;
              BytesNeeded = 0;
              BytesWritten;

              BytesWritten = sizeof(PS_FLOW_STATS) + FIELD_OFFSET(PS_COMPONENT_STATS, Stats);

              Cstats = (PPS_COMPONENT_STATS) Buffer;

              Cstats->Type = PS_COMPONENT_FLOW;

              Cstats->Length = sizeof(PS_FLOW_STATS);

              NdisMoveMemory(&Cstats->Stats,
                             &Vc->Stats,
                             sizeof(PS_FLOW_STATS));
                          
              Status = NDIS_STATUS_SUCCESS;
                          
              Data = (PVOID)( (PUCHAR) Buffer + BytesWritten);

              (*Vc->PsComponent->QueryInformation)
                  (Vc->PsPipeContext,
                   Vc->PsFlowContext,
                   Oid,
                   Len,
                   Data,
                   &BytesWritten, 
                   &BytesNeeded,
                   &Status);
              
              return Status;
          default:
              
              return STATUS_WMI_NOT_SUPPORTED;
        }
    }

    //
    // The Following OIDs are similar for both WAN and Adapters
    //
    switch(Oid) 
    {
      case OID_QOS_CURRENT_SCHEDULING_PROFILE:
          
          if(!Adapter->ProfileName.Buffer)
          {
              NdisMoveMemory(Buffer,
                             &DefaultProfile,
                             sizeof(DefaultProfile));
              
          }
          else {
              
              NdisMoveMemory(Buffer,
                             &Adapter->ProfileName.Buffer,
                             Adapter->ProfileName.Length);
          }
          
          return STATUS_SUCCESS;

      case OID_QOS_DISABLE_DRR:
              
          *pData = (Adapter->PipeFlags & PS_DISABLE_DRR)?1:0;
                  
           return STATUS_SUCCESS;

      case OID_QOS_MAX_OUTSTANDING_SENDS:
              
          *pData = Adapter->MaxOutstandingSends;
              
          return STATUS_SUCCESS;
              

      case OID_QOS_BESTEFFORT_BANDWIDTH:
          
          PS_LOCK(&Adapter->Lock);
          
          *pData = Adapter->BestEffortLimit;
          
          PS_UNLOCK(&Adapter->Lock);
          
          return STATUS_SUCCESS;
             
      case OID_QOS_TIMER_RESOLUTION:

          *pData = gTimerResolutionActualTime/10;

          return STATUS_SUCCESS;

      case OID_QOS_LATENCY:
          
          //
          // Don't have a valid measure of latency right now.
          //
          
          *pData = -1;
          
          return STATUS_SUCCESS;

      case OID_QOS_ENABLE_AVG_STATS:

          *pData = gEnableAvgStats;
          
          return STATUS_SUCCESS;

      case OID_QOS_ENABLE_WINDOW_ADJUSTMENT:

          *pData = gEnableWindowAdjustment;
          
          return STATUS_SUCCESS;

#if DBG
      case OID_QOS_LOG_BUFFER_SIZE:
          
          *pData = SchedtGetBufferSize();
          
          
          return STATUS_SUCCESS;
          
          // The following is temporary until the status reporting works...
          // for a query on log threshold we return the current size of the
          // log rather than the threshold value... this is just an easy
          // way to allow the app to poll the log size without defining a
          // new GUID that would be temporary anyway.
          
      case OID_QOS_LOG_THRESHOLD:
          
          *pData = SchedtGetBytesUnread();
          
          return STATUS_SUCCESS;

      case OID_QOS_LOG_MASK:
          *pData = LogTraceMask;
          return STATUS_SUCCESS;

      case OID_QOS_LOG_LEVEL:
          *pData = LogTraceLevel;
          return STATUS_SUCCESS;
          
              
      case OID_QOS_LOG_DATA:
      {
          ULONG BytesRead;
          DbugReadTraceBuffer(Buffer, BufferSize, &BytesRead);
          
          return STATUS_SUCCESS;
      }
      
#endif
    }
              

    if(WanLink)
    {
        switch(Oid) 
        {

          case OID_QOS_FLOW_MODE:
          {
              *pData = WanLink->AdapterMode;

              return STATUS_SUCCESS;
          }

            //
            // (12636): This has to be uncommented when we do admission control over WAN links.
            //
#if 0
          case OID_QOS_REMAINING_BANDWIDTH:
              
              PS_LOCK(&WanLink->Lock);
                  
              *pData = WanLink->RemainingBandWidth;
                  
              PS_UNLOCK(&WanLink->Lock);
                  
              return STATUS_SUCCESS;

          case OID_QOS_NON_BESTEFFORT_LIMIT:
              
              PS_LOCK(&WanLink->Lock);
                  
              *pData = WanLink->NonBestEffortLimit;
                  
              PS_UNLOCK(&WanLink->Lock);
              
              return STATUS_SUCCESS;
#endif
          case OID_QOS_HIERARCHY_CLASS:
          {
              BytesWritten = 0;
              BytesNeeded = 0;
              Status = NDIS_STATUS_BUFFER_TOO_SHORT;
              
              (*WanLink->PsComponent->QueryInformation)
                  (WanLink->PsPipeContext,
                   NULL,
                   Oid, 
                   BufferSize, 
                   Buffer,
                   &BytesWritten,
                   &BufferSize,
                   &Status);
              
              return STATUS_SUCCESS;
          }

          case OID_QOS_STATISTICS_BUFFER:
              
              // If the query comes for a VC, then we return per flow stats
              // else we return per adapter stats. The query is also sent through
              // the scheduling components, so that they can fill in the per flow
              // or per query stats.
              //
              
              
              Len = BufferSize;
              BytesNeeded = 0;
              BytesWritten;
              
              BytesWritten = sizeof(PS_ADAPTER_STATS) + FIELD_OFFSET(PS_COMPONENT_STATS, Stats);
              
              Cstats = (PPS_COMPONENT_STATS) Buffer;
              
              Cstats->Type = PS_COMPONENT_ADAPTER;
              
              Cstats->Length = sizeof(PS_ADAPTER_STATS);
              
              NdisMoveMemory(&Cstats->Stats,
                             &WanLink->Stats,
                             sizeof(PS_ADAPTER_STATS));
              
              Status = NDIS_STATUS_SUCCESS;
              
              Data = (PVOID)( (PUCHAR) Buffer + BytesWritten);
             
              (*WanLink->PsComponent->QueryInformation)
                  (WanLink->PsPipeContext,
                   NULL,
                   Oid,
                   Len,
                   Data,
                   &BytesWritten, 
                   &BytesNeeded,
                   &Status);
              
              return Status;
              
          case OID_QOS_TC_SUPPORTED:

              CollectWanNetworkAddresses(Adapter, WanLink, &BufferSize, Buffer);

              return STATUS_SUCCESS;

          case OID_QOS_FLOW_COUNT:

              PS_LOCK(&WanLink->Lock);

              *pData = WanLink->FlowsInstalled;

              PS_UNLOCK(&WanLink->Lock);

              PsAssert((LONG)*pData >= 0);

              return STATUS_SUCCESS;

          default:
              return STATUS_WMI_NOT_SUPPORTED;
        }
    }

    if(Adapter->MediaType != NdisMediumWan)
    {

        switch(Oid) 
        {
          case OID_QOS_FLOW_MODE:
          {
              *pData = Adapter->AdapterMode;
              return STATUS_SUCCESS;
          }

          case OID_QOS_HIERARCHY_CLASS:
          {
              BytesWritten = 0;
              BytesNeeded = 0;
              Status = NDIS_STATUS_BUFFER_TOO_SHORT;
              
              (*Adapter->PsComponent->QueryInformation)
                  (Adapter->PsPipeContext,
                   NULL,
                   Oid, 
                   BufferSize, 
                   Buffer,
                   &BytesWritten,
                   &BufferSize,
                   &Status);
              
              return STATUS_SUCCESS;
          }

          case OID_QOS_STATISTICS_BUFFER:
              
              // If the query comes for a VC, then we return per flow stats
              // else we return per adapter stats. The query is also sent through
              // the scheduling components, so that they can fill in the per flow
              // or per query stats.
              //
              
              
              Len = BufferSize;
              BytesNeeded = 0;
              BytesWritten;
              
              BytesWritten = sizeof(PS_ADAPTER_STATS) + FIELD_OFFSET(PS_COMPONENT_STATS, Stats);
              
              Cstats = (PPS_COMPONENT_STATS) Buffer;
              
              Cstats->Type = PS_COMPONENT_ADAPTER;
          
              Cstats->Length = sizeof(PS_ADAPTER_STATS);
              
              NdisMoveMemory(&Cstats->Stats,
                             &Adapter->Stats,
                             sizeof(PS_ADAPTER_STATS));
              
              Status = NDIS_STATUS_SUCCESS;
              
              Data = (PVOID)( (PUCHAR) Buffer + BytesWritten);
              
              (*Adapter->PsComponent->QueryInformation)
                  (Adapter->PsPipeContext,
                   NULL,
                   Oid,
                   Len,
                   Data,
                   &BytesWritten, 
                   &BytesNeeded,
                   &Status);
              
              return Status;

          case OID_QOS_TC_SUPPORTED:
              
              CollectNetworkAddresses(Adapter, &BufferSize, Buffer);

              return STATUS_SUCCESS;

          case OID_QOS_REMAINING_BANDWIDTH:
              
              PS_LOCK(&Adapter->Lock);
                  
              *pData = Adapter->RemainingBandWidth;
                  
              PS_UNLOCK(&Adapter->Lock);
                  
              return STATUS_SUCCESS;
              
          case OID_QOS_FLOW_COUNT:
              
              PS_LOCK(&Adapter->Lock);

              *pData = Adapter->FlowsInstalled;

              PS_UNLOCK(&Adapter->Lock);
              
              PsAssert((LONG)*pData >= 0);
              
              return STATUS_SUCCESS;
              
          case OID_QOS_NON_BESTEFFORT_LIMIT:
              
              PS_LOCK(&Adapter->Lock);
                  
              *pData = Adapter->NonBestEffortLimit;
                  
              PS_UNLOCK(&Adapter->Lock);
              
              return STATUS_SUCCESS;
              
              
          default:
              
              return STATUS_WMI_NOT_SUPPORTED;
        }
    }

    return STATUS_WMI_NOT_SUPPORTED;
}

NTSTATUS
PsWmiQueryAllData(
        IN      LPGUID          guid,
        IN      PWNODE_ALL_DATA wnode,
        IN      ULONG           BufferSize,
        OUT     PULONG          pReturnSize
        )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS                      NtStatus;
    NDIS_STATUS                   Status;
    ULONG                         wnodeSize = ALIGN(sizeof(WNODE_ALL_DATA));
    ULONG                         wnodeTotalSize;
    PNDIS_GUID                    pNdisGuid;
    ULONG                         BytesNeeded;
    UINT                          cRoughInstanceCount;
    UINT                          cInstanceCount = 0;
    PUCHAR                        pBuffer;
    ULONG                         OffsetToInstanceNames;
    PLIST_ENTRY                   Link;
    PPS_WAN_LINK                  WanLink = NULL;
    POFFSETINSTANCEDATAANDLENGTH  poidl;
    PULONG                        pInstanceNameOffsets;
    ULONG                         OffsetToInstanceInfo;
    BOOLEAN                       OutOfSpace = FALSE;
    PADAPTER                      Adapter;
    PLIST_ENTRY                   NextAdapter;
    ULONG                         InstanceNameSize;

    do
    {
        *pReturnSize = 0;
        
        if (BufferSize < sizeof(WNODE_TOO_SMALL))
        {
            
            // 
            // Too small even to hold a WNODE_TOO_SMALL !
            //
            
            NtStatus = STATUS_BUFFER_TOO_SMALL;
            
            break;
        }
       
        //
        // We can maintain a global count when adapters and wanlinks go up and down rather 
        // than counting it here. However, QueryAllData is not a very frequently used operation to 
        // justify this extra code. 
        //

        cRoughInstanceCount = 0;

        PS_LOCK(&AdapterListLock);

        NextAdapter = AdapterList.Flink;
          
        while(NextAdapter != &AdapterList) 
        {
            Adapter = CONTAINING_RECORD(NextAdapter, ADAPTER, Linkage);
            
            NextAdapter = NextAdapter->Flink;
        
            if(Adapter->MediaType == NdisMediumWan) 
            {
                PS_LOCK_DPC(&Adapter->Lock);
            
                cRoughInstanceCount += Adapter->WanLinkCount;
            
                PS_UNLOCK_DPC(&Adapter->Lock);
            }
            else 
            {
                cRoughInstanceCount += 1;
            }
        }

        PS_UNLOCK(&AdapterListLock);
        
        //
        // Get the OID and see if we support it.
        //
        
        NtStatus = PsWmiGetGuid(&pNdisGuid, guid, 0);
        
        if(!NT_SUCCESS(NtStatus)) 
        {
            PsDbgOut(DBG_FAILURE, DBG_WMI,
                     ("[PsWmiQueryAllData]: Unsupported guid \n"));
            break;
        }
        
        //
        // Initialize common wnode information.
        //
        
        KeQuerySystemTime(&wnode->WnodeHeader.TimeStamp);
            
        //
        // Setup the OFFSETINSTANCEDATAANDLENGTH array.
        //
        poidl = wnode->OffsetInstanceDataAndLength;
        wnode->OffsetInstanceNameOffsets = wnodeSize + (sizeof(OFFSETINSTANCEDATAANDLENGTH) * cRoughInstanceCount);

        //
        // Get a pointer to the array of offsets to the instance names.
        //
        pInstanceNameOffsets = (PULONG)((PUCHAR)wnode + wnode->OffsetInstanceNameOffsets);

        //
        // Get the offset from the wnode where will will start copying the instance
        // data into.
        //
        OffsetToInstanceInfo = ALIGN(wnode->OffsetInstanceNameOffsets + (sizeof(ULONG) * cRoughInstanceCount));

        //
        // Get a pointer to start placing the data.
        //
        pBuffer = (PUCHAR)wnode + OffsetToInstanceInfo;

        //
        // Check to make sure we have at least this much buffer space in the wnode.
        //
        wnodeTotalSize = OffsetToInstanceInfo;

        PS_LOCK(&AdapterListLock);

        NextAdapter = AdapterList.Flink;
          
        while(NextAdapter != &AdapterList) 
        {
            Adapter = CONTAINING_RECORD(NextAdapter, ADAPTER, Linkage);

            PS_LOCK_DPC(&Adapter->Lock);

            if(Adapter->PsMpState != AdapterStateRunning) 
            {
                PS_UNLOCK_DPC(&Adapter->Lock);

                NextAdapter = NextAdapter->Flink;

                continue;
            }

            REFADD(&Adapter->RefCount, 'WMIQ');

            PS_UNLOCK_DPC(&Adapter->Lock);
            
            PS_UNLOCK(&AdapterListLock);
            
            if(Adapter->MediaType != NdisMediumWan) 
            {
                
                NtStatus = PsQueryGuidDataSize(Adapter, NULL, NULL, pNdisGuid->Oid, &BytesNeeded);
            
                if(NT_SUCCESS(NtStatus)) 
                {
                    
                    // Make sure we have enough buffer space for the instance name and
                    // the data. If not we still continue since we need to find the total
                    // size
                   
                    InstanceNameSize   = ALIGN(Adapter->WMIInstanceName.Length + sizeof(WCHAR));
                    wnodeTotalSize  += InstanceNameSize + ALIGN(BytesNeeded);
                    
                    if (BufferSize < wnodeTotalSize)
                    {
                        WMI_BUFFER_TOO_SMALL(BufferSize, wnode, wnodeTotalSize, &NtStatus, pReturnSize);

                        OutOfSpace = TRUE;

                        PS_LOCK(&AdapterListLock);

                        NextAdapter = NextAdapter->Flink;

                        REFDEL(&Adapter->RefCount, TRUE, 'WMIQ');

                        continue;
                    }

                    //
                    // We only have room for so many Instances.
                    //
                    if(cInstanceCount >= cRoughInstanceCount)
                    {
                        PsDbgOut(DBG_FAILURE, DBG_WMI,
                                 ("[PsWmiQueryAllData]: Adapter %08X, Received more wanlinks (%d) than we counted "
                                  "initially (%d)\n", Adapter, cInstanceCount, cRoughInstanceCount));

                        PS_LOCK(&AdapterListLock);

                        REFDEL(&Adapter->RefCount, TRUE, 'WMIQ');
                        
                        break;
                    }

                    //
                    //  Add the offset to the instance name to the table.
                    //
                    pInstanceNameOffsets[cInstanceCount] = OffsetToInstanceInfo;
                        
                    //
                    //  Copy the instance name into the wnode buffer.
                    //
                    *((PUSHORT)pBuffer) = Adapter->WMIInstanceName.Length;
                        
                    NdisMoveMemory(pBuffer + sizeof(USHORT),
                                   Adapter->WMIInstanceName.Buffer,
                                   Adapter->WMIInstanceName.Length);
                        
                    //
                    //  Keep track of true instance counts.
                    //
                    OffsetToInstanceInfo += InstanceNameSize;
                    pBuffer = (PUCHAR)wnode + OffsetToInstanceInfo;
                        
                    //
                    // Query the data 
                    //
                    NtStatus = PsQueryGuidData(Adapter, NULL, NULL, pNdisGuid->Oid, pBuffer, BytesNeeded);
                        
                    if(!NT_SUCCESS(NtStatus)) 
                    {
                        PsDbgOut(DBG_FAILURE, DBG_WMI,
                                 ("[PsWmiQueryAllData]: Adapter %08X, Failed to query OID %08X \n", Adapter,
                                  pNdisGuid->Oid));

                        PS_LOCK(&AdapterListLock);

                        REFDEL(&Adapter->RefCount, TRUE, 'WMIQ');

                        break;
                    }
                        
                        
                    //
                    //  Save the length of the data item for this instance.
                    //
                    poidl[cInstanceCount].OffsetInstanceData = OffsetToInstanceInfo;
                    poidl[cInstanceCount].LengthInstanceData = BytesNeeded;
                    
                    //
                    // Keep track of true instance count.
                    //
                    OffsetToInstanceInfo += ALIGN(BytesNeeded);
                    pBuffer = (PUCHAR)wnode + OffsetToInstanceInfo;

                    cInstanceCount ++;
                        
                }

            }
            else 
            {
                //
                // Search the Wan Links     
                //

                PS_LOCK(&Adapter->Lock);
                  
                Link = Adapter->WanLinkList.Flink;
            
                for(Link = Adapter->WanLinkList.Flink;
                    Link != &Adapter->WanLinkList;
                    )
                    
                {
            
                    //
                    // We only have room for so many Instances.
                    //
                    if(cInstanceCount >= cRoughInstanceCount)
                    {
                        PsDbgOut(DBG_FAILURE, DBG_WMI,
                                 ("[PsWmiQueryAllData]: Adapter %08X, Received more wanlinks (%d) than we counted "
                                  "initially (%d)\n", Adapter, cInstanceCount, cRoughInstanceCount));
                        break;
                    }

                    //
                    // Get a pointer to the WanLink.
                    //
                    
                    WanLink = CONTAINING_RECORD(Link, PS_WAN_LINK, Linkage);
                    
                    PS_LOCK_DPC(&WanLink->Lock);
                    
                    //
                    // Check to see if the WanLink is cleaning up.
                    //
                    
                    if(WanLink->State != WanStateOpen) {
                        
                        PS_UNLOCK_DPC(&WanLink->Lock);

                        PsDbgOut(DBG_FAILURE, DBG_WMI,
                                 ("[PsWmiQueryAllData]: Adapter %08X, WanLink %08X: Link not ready \n", Adapter, WanLink));

                        Link = Link->Flink;
                        
                        continue;
                    }
                   
                    REFADD(&WanLink->RefCount, 'WMIQ'); 
                    
                    PS_UNLOCK_DPC(&WanLink->Lock);

                    PS_UNLOCK(&Adapter->Lock);

                    //
                    // If there is an instance name associated with the VC then we need to query it.
                    //
                    PsAssert(WanLink->InstanceName.Buffer);
                    
                    NtStatus = PsQueryGuidDataSize(Adapter, WanLink, NULL, pNdisGuid->Oid, &BytesNeeded);
                    
                    if(NT_SUCCESS(NtStatus)) 
                    {
                        //
                        //  Make sure we have enough buffer space for the instance name and
                        //  the data.
                        //
                        InstanceNameSize   = ALIGN(WanLink->InstanceName.Length + sizeof(USHORT));
                        wnodeTotalSize += InstanceNameSize + ALIGN(BytesNeeded);
                        
                        if (BufferSize < wnodeTotalSize)
                        {
                            WMI_BUFFER_TOO_SMALL(BufferSize, wnode,
                                                 wnodeTotalSize,
                                                 &NtStatus, pReturnSize);
                            
                            OutOfSpace = TRUE;
                            
                            PS_LOCK(&Adapter->Lock);

                            Link = Link->Flink;
                
                            REFDEL(&WanLink->RefCount, TRUE, 'WMIQ');
                            
                            continue;
                        }
                    
                        //
                        //  The instance info contains the instance name followed by the
                        //  data for the item.
                        //
                        
                        //
                        //  Add the offset to the instance name to the table.
                        //
                        pInstanceNameOffsets[cInstanceCount] = OffsetToInstanceInfo;
                        
                        //
                        //  Copy the instance name into the wnode buffer.
                        //
                        *((PUSHORT)pBuffer) = WanLink->InstanceName.Length;
                        
                        NdisMoveMemory(pBuffer + sizeof(USHORT),
                                       WanLink->InstanceName.Buffer,
                                       WanLink->InstanceName.Length);
                        
                        //
                        //  Keep track of true instance counts.
                        //
                        OffsetToInstanceInfo += InstanceNameSize;
                        pBuffer = (PUCHAR)wnode + OffsetToInstanceInfo;
                        
                        
                        //
                        // 
                        // 
                        NtStatus = PsQueryGuidData(Adapter, WanLink, NULL, pNdisGuid->Oid, pBuffer, BytesNeeded);
                        
                        if (!NT_SUCCESS(NtStatus))
                        {
                            PsDbgOut(DBG_FAILURE, DBG_WMI,
                                     ("[PsWmiQueryAllData]: Adapter %08X, Failed to query GUID data\n", Adapter));

                            PS_LOCK(&Adapter->Lock);

                            REFDEL(&WanLink->RefCount, TRUE, 'WMIQ'); 
                            
                            break;
                        }
                        
                        //
                        //  Save the length of the data item for this instance.
                        //
                        poidl[cInstanceCount].OffsetInstanceData = OffsetToInstanceInfo;
                        poidl[cInstanceCount].LengthInstanceData = BytesNeeded;
                        
                        //
                        //  Keep track of true instance counts.
                        //
                        OffsetToInstanceInfo += ALIGN(BytesNeeded);
                        pBuffer = (PUCHAR)wnode + OffsetToInstanceInfo;
                        
                        //
                        //  Increment the current instance count.
                        //
                        cInstanceCount++;
                    }

                    PS_LOCK(&Adapter->Lock);

                    Link = Link->Flink;

                    REFDEL(&WanLink->RefCount, TRUE, 'WMIQ'); 
                    
                }
                
                PS_UNLOCK(&Adapter->Lock);
            }

            PS_LOCK(&AdapterListLock);
            
            NextAdapter = NextAdapter->Flink;
            
            REFDEL(&Adapter->RefCount, TRUE, 'WMIQ');
            
        }

        PS_UNLOCK(&AdapterListLock);

        if (!OutOfSpace)
        {
            wnode->WnodeHeader.BufferSize = wnodeTotalSize;
            wnode->InstanceCount = cInstanceCount;
            
            //
            // Set the status to success.
            //
            NtStatus = STATUS_SUCCESS;
            *pReturnSize = wnode->WnodeHeader.BufferSize;
        }

    } while (FALSE);

    return(NtStatus);
}

NTSTATUS
PsWmiFindInstanceName(
    IN      PPS_WAN_LINK            *pWanLink,
    IN      PGPC_CLIENT_VC          *pVc,
    IN      PADAPTER                Adapter, 
    IN      PWSTR                   pInstanceName,
    IN      USHORT                  cbInstanceName
    )
{
    NTSTATUS                Status = STATUS_SUCCESS;
    PVOID                   ptmp1;
    PVOID                   ptmp2;
    PLIST_ENTRY             Link;
    UINT                    cListCount;
    PLIST_ENTRY             pListHead;
    PPS_WAN_LINK            WanLink;
    PGPC_CLIENT_VC          Vc;
    NDIS_STRING             usTemp;
    
    *pWanLink = NULL;
    *pVc = NULL;
    
    
    if ( NdisEqualMemory(pInstanceName,
                         WanPrefix.Buffer,
                         WanPrefix.Length)) 
    {
        
        //
        //  The name belongs to a miniport, check to see if it is for this one.
        //
        usTemp.Buffer = (PWCHAR)((PCHAR)pInstanceName + WanPrefix.Length + INSTANCE_ID_SIZE);
        usTemp.Length = usTemp.MaximumLength = cbInstanceName - WanPrefix.Length - INSTANCE_ID_SIZE;
        
        //
        // Get a ULONGLONG pointer to the wnode's instance name.
        //
        ptmp1 = (PVOID)&pInstanceName[1];

        //
        // No point in searching wanlinks on the non wan adapters.
        //

        if(Adapter->MediaType == NdisMediumWan && RtlEqualUnicodeString(&Adapter->WMIInstanceName, &usTemp, TRUE)) 
        {
        
            //
            // The request is for some WAN Link. Go through the Miniport's list of WMI enabled VCs.
            //
            PS_LOCK(&Adapter->Lock);
            
            for(Link = Adapter->WanLinkList.Flink;
                Link != &Adapter->WanLinkList;
                Link = Link->Flink)
            {
                //
                // Get a pointer to the VC.
                //
                WanLink = CONTAINING_RECORD(Link, PS_WAN_LINK, Linkage);
                
                PS_LOCK_DPC(&WanLink->Lock);
                
                if(WanLink->State == WanStateOpen) 
                {
                    
                    //
                    // Check the name with the one in the wnode.
                    //
                    ptmp2 = (PVOID)&WanLink->InstanceName.Buffer[1];
                    if (RtlCompareMemory( ptmp1, ptmp2, 48) == 48)
                    {
                        //
                        //  This is our baby. Slap a reference on it and get out.
                        //  
                        
                        *pWanLink = WanLink;
                        
                        REFADD(&WanLink->RefCount, 'WMII'); 
                        
                        PS_UNLOCK_DPC(&WanLink->Lock);
                        
                        break;
                    }
                }
                    
                PS_UNLOCK_DPC(&WanLink->Lock);
                
            }
            
            PS_UNLOCK(&Adapter->Lock);
        
            //
            // If we didn't find the WanLink then return FAILURE.
            //
            if (!*pWanLink)
            {
                PsDbgOut(DBG_FAILURE, DBG_WMI,
                         ("[PsWmiFindInstanceName: Adapter %08X, Could not verify the instance name passed in\n"));
                
                Status = STATUS_WMI_INSTANCE_NOT_FOUND;
            }
        }
        else 
        {
            Status = STATUS_WMI_INSTANCE_NOT_FOUND;
        }
            
    }
    else {
        
        if ( NdisEqualMemory(pInstanceName,
                             VcPrefix.Buffer,
                             VcPrefix.Length)) 
        {
            //
            //  The name belongs to a miniport, check to see if it is for this one.
            //
            usTemp.Buffer = (PWCHAR)((PCHAR)pInstanceName + VcPrefix.Length + INSTANCE_ID_SIZE);
            usTemp.Length = usTemp.MaximumLength = cbInstanceName - VcPrefix.Length - INSTANCE_ID_SIZE;

            //
            // Make sure that the VC is searched on the correct adapter. Otherwise, we could land up
            // searching all the VCs on all the adapters.
            //
            if (!RtlEqualUnicodeString(&Adapter->WMIInstanceName, &usTemp, TRUE))
            {
                Status = STATUS_WMI_INSTANCE_NOT_FOUND;
            }
            else 
            {
            
                //
                //  Get a ULONGLONG pointer to the wnode's instance name.
                //
                ptmp1 = (PVOID)&pInstanceName[1];
                
                //
                //  The request is for some Vc. Go through the Miniport's list of WMI enabled VCs.
                //
                
                PS_LOCK(&Adapter->Lock);
                
                for(Link = Adapter->GpcClientVcList.Flink; 
                    Link != &Adapter->GpcClientVcList;
                    Link = Link->Flink)
                {
                    //
                    // Get a pointer to the VC.
                    //
                    Vc = CONTAINING_RECORD(Link, GPC_CLIENT_VC, Linkage);
                    
                    PS_LOCK_DPC(&Vc->Lock);
                    
                    if(Vc->ClVcState == CL_CALL_COMPLETE) {
                        
                        //
                        // Check the name with the one in the wnode. All we need to do is compare the 
                        // number in the name.
                        //
                        ptmp2 = (PVOID)&Vc->InstanceName.Buffer[1];
                        if(RtlCompareMemory(ptmp1, ptmp2, 48) == 48) 
                        {
                            //
                            // This is our baby. Slap a reference on it and get out.
                            //      
                            
                            *pVc = Vc;
                            
                            InterlockedIncrement(&Vc->RefCount);
                            
                            PS_UNLOCK_DPC(&Vc->Lock);
                            
                            break;
                            
                        }
                    }
                
                    PS_UNLOCK_DPC(&Vc->Lock);
                
                }
            
                PS_UNLOCK(&Adapter->Lock);
            
                //
                //  If we didn't find the VC then return FAILURE.
                //
                if (!*pVc)
                {
                    PsDbgOut(DBG_FAILURE, DBG_WMI,
                             ("[PsWmiFindInstanceName: Adapter %08X, Could not verify the instance name passed in\n"));
                    
                    Status = STATUS_WMI_INSTANCE_NOT_FOUND;
                }
            }
                
        }
        else 
        {
            //
            //  The name belongs to a miniport, check to see if it is for this one.
            //
            usTemp.Buffer = pInstanceName;
            usTemp.Length = usTemp.MaximumLength = cbInstanceName;

            
            if (!RtlEqualUnicodeString(&Adapter->WMIInstanceName, &usTemp, TRUE))
            {
                PsDbgOut(DBG_FAILURE, DBG_WMI,
                         ("[PsWmiFindInstanceName]: Adapter %08X, Invalid instance name \n", Adapter));
                
                Status = STATUS_WMI_INSTANCE_NOT_FOUND;
            }
        }
    }
    
    return(Status);
}

NTSTATUS
PsQuerySetMiniport(PADAPTER        Adapter,
                   PPS_WAN_LINK    WanLink,
                   PGPC_CLIENT_VC  Vc,
                   NDIS_OID        Oid,
                   PVOID           Data,
                   ULONG           DataSize) 
{

    //
    // Fail these no matter what 
    //
    switch(Oid) 
    {
        
      case OID_QOS_TC_SUPPORTED:
      case OID_QOS_REMAINING_BANDWIDTH:
      case OID_QOS_LATENCY:
      case OID_QOS_FLOW_COUNT:
      case OID_QOS_NON_BESTEFFORT_LIMIT:
      case OID_QOS_SCHEDULING_PROFILES_SUPPORTED:
      case OID_QOS_CURRENT_SCHEDULING_PROFILE:
      case OID_QOS_DISABLE_DRR:
      case OID_QOS_MAX_OUTSTANDING_SENDS:
      case OID_QOS_TIMER_RESOLUTION:
          
          return STATUS_WMI_NOT_SUPPORTED;
    }

    if(Vc) 
    {
        switch(Oid) 
        {
          case OID_QOS_STATISTICS_BUFFER:
              
              NdisZeroMemory(&Vc->Stats, sizeof(PS_FLOW_STATS));

              //
              // Send the request down, so that the scheduling components
              // can also reset their stats.
              //

              (*Vc->PsComponent->SetInformation)
                  (Vc->PsPipeContext,
                   Vc->PsFlowContext,
                   Oid, 
                   DataSize, 
                   Data);
                                  
              return STATUS_SUCCESS;

          default:
              
              return STATUS_WMI_NOT_SUPPORTED;
        }
    }

    //
    // These work for Wan and LAN
    //
    switch(Oid) {

      case OID_QOS_ENABLE_AVG_STATS:

          if(DataSize != sizeof(ULONG)) {
              
              return STATUS_BUFFER_TOO_SMALL;
          }

          gEnableAvgStats = *(PULONG)Data;
          return STATUS_SUCCESS;


      case OID_QOS_ENABLE_WINDOW_ADJUSTMENT:

          if(DataSize != sizeof(ULONG)) {
              
              return STATUS_BUFFER_TOO_SMALL;
          }

          gEnableWindowAdjustment = *(PULONG)Data;
          return STATUS_SUCCESS;


#if DBG          
      case OID_QOS_LOG_THRESHOLD:

          if(DataSize != sizeof(ULONG)) {
              
              return STATUS_BUFFER_TOO_SMALL;
          }
          
          DbugTraceSetThreshold(*(PULONG)Data, Adapter, IndicateLogThreshold);
          return STATUS_SUCCESS;

      case OID_QOS_LOG_MASK:
          if(DataSize != sizeof(ULONG)) {
              
              return STATUS_BUFFER_TOO_SMALL;
          }
          LogTraceMask = *(PULONG)Data;
          return STATUS_SUCCESS;

      case OID_QOS_LOG_LEVEL:
          if(DataSize != sizeof(ULONG)) {
              
              return STATUS_BUFFER_TOO_SMALL;
          }
          LogTraceLevel = *(PULONG)Data;
          return STATUS_SUCCESS;

#endif
    }

    if(WanLink)
    {
        switch(Oid)
        {
          case OID_QOS_STATISTICS_BUFFER:

              NdisZeroMemory(&WanLink->Stats, sizeof(PS_ADAPTER_STATS));
                          
              //
              // Send it to the scheduling components so that 
              // they can reset the per pipe stats
              //
          
              (*WanLink->PsComponent->SetInformation)
                  (WanLink->PsPipeContext,
                   NULL,
                   Oid, 
                   DataSize, 
                   Data);
              
              
              return STATUS_SUCCESS;

      case OID_QOS_FLOW_MODE:

          if(DataSize != sizeof(ULONG)) {

              return STATUS_BUFFER_TOO_SMALL;
          }

          if(*(PULONG)Data == ADAPTER_FLOW_MODE_DIFFSERV ||
             *(PULONG)Data == ADAPTER_FLOW_MODE_STANDARD ) 
          {
              InterlockedExchange((PLONG)&WanLink->AdapterMode, *(PULONG)Data);

              return STATUS_SUCCESS;
          }
          else 
          {
              return STATUS_INVALID_PARAMETER;
          }
              
          case OID_QOS_HIERARCHY_CLASS:
              
              (*WanLink->PsComponent->SetInformation)
                  (WanLink->PsPipeContext,
                   NULL,
                   Oid, 
                   DataSize, 
                   Data);
              
              return STATUS_SUCCESS;
        }
    }


    if(Adapter->MediaType != NdisMediumWan)
    {
       
        switch(Oid)
        {
          case OID_QOS_STATISTICS_BUFFER:
                 

              NdisZeroMemory(&Adapter->Stats, sizeof(PS_ADAPTER_STATS));
                          
              //
              // Send it to the scheduling components so that 
              // they can reset the per pipe stats
              //
          
              (*Adapter->PsComponent->SetInformation)
                  (Adapter->PsPipeContext,
                   NULL,
                   Oid, 
                   DataSize, 
                   Data);
              
              
              return STATUS_SUCCESS;

      case OID_QOS_FLOW_MODE:

          if(DataSize != sizeof(ULONG)) {

              return STATUS_BUFFER_TOO_SMALL;
          }

          if(*(PULONG)Data == ADAPTER_FLOW_MODE_DIFFSERV ||
             *(PULONG)Data == ADAPTER_FLOW_MODE_STANDARD ) 
          {
              InterlockedExchange((PLONG)&Adapter->AdapterMode, *(PULONG)Data);

              return STATUS_SUCCESS;
          }
          else 
          {
              return STATUS_INVALID_PARAMETER;
          }
              
          case OID_QOS_HIERARCHY_CLASS:
              
              (*Adapter->PsComponent->SetInformation)
                  (Adapter->PsPipeContext,
                   NULL,
                   Oid, 
                   DataSize, 
                   Data);
              
              return STATUS_SUCCESS;

          case OID_QOS_BESTEFFORT_BANDWIDTH: 
          
              if(DataSize != sizeof(ULONG)) 
              {
                  return STATUS_BUFFER_TOO_SMALL;
              }
              else 
              {
                  return ModifyBestEffortBandwidth(Adapter, *(PULONG)Data);
              }
        }
          
    }

    return STATUS_WMI_NOT_SUPPORTED;
    
}

NTSTATUS 
PsWmiHandleSingleInstance(ULONG                  MinorFunction, 
                          PWNODE_SINGLE_INSTANCE wnode, 
                          PNDIS_GUID             pNdisGuid,
                          ULONG                  BufferSize,
                          PULONG                 pReturnSize)
{
    PPS_WAN_LINK            WanLink;
    PGPC_CLIENT_VC          Vc;
    USHORT                  cbInstanceName;
    PWSTR                   pInstanceName;
    PLIST_ENTRY             NextAdapter;
    PADAPTER                Adapter;
    NTSTATUS                Status = STATUS_WMI_INSTANCE_NOT_FOUND;

    //
    // Send this to all the adapter instances.
    //

    *pReturnSize = 0;

   //
   // First, we need to check if this is the window size adjustment guid..
   //
 
   if( pNdisGuid->Oid == OID_QOS_ENABLE_WINDOW_ADJUSTMENT)
   {
	if( MinorFunction == IRP_MN_CHANGE_SINGLE_INSTANCE)
	{
	   PUCHAR pGuidData;
           ULONG  GuidDataSize;
	
	   pGuidData    = (PUCHAR)wnode + wnode->DataBlockOffset;
           GuidDataSize = wnode->SizeDataBlock;

	   //
           // Attempt to set the miniport with the information.
           //

	   Status = PsQuerySetMiniport(NULL,
                                       NULL,
                                       NULL,
                                       pNdisGuid->Oid,
                                       pGuidData,
                                       GuidDataSize);
	   return Status;
	}
	else if( MinorFunction == IRP_MN_QUERY_SINGLE_INSTANCE )
	{		
	   ULONG BytesNeeded;
           ULONG wnodeSize;
                  
           //
           //  Determine the buffer size needed for the GUID data.
           //
           Status = PsQueryGuidDataSize(NULL,
                                        NULL,
                                        NULL,
                                        pNdisGuid->Oid,
                                        &BytesNeeded);

	   if (!NT_SUCCESS(Status))
	   {
		return Status;	
	   }
        
           //
           //      Determine the size of the wnode.
           //
           wnodeSize = wnode->DataBlockOffset + BytesNeeded;
           if (BufferSize < wnodeSize)
           {
		WMI_BUFFER_TOO_SMALL(BufferSize, wnode, wnodeSize, &Status, pReturnSize);
                return Status;
	   }
        
	   //
           //      Initialize the wnode.
           //
           KeQuerySystemTime(&wnode->WnodeHeader.TimeStamp);
           wnode->WnodeHeader.BufferSize = wnodeSize;
           wnode->SizeDataBlock = BytesNeeded;
                  
           //
           //      Validate the guid and get the data for it.
           //
           Status = PsQueryGuidData(NULL,
                                    NULL,
                                    NULL,
                                    pNdisGuid->Oid,
                                    (PUCHAR)wnode + wnode->DataBlockOffset,
                                    BytesNeeded);
                  
	   if (!NT_SUCCESS(Status))
           {
		return Status;
	   }
           else 
           {
		*pReturnSize = wnodeSize;
	   }	
	}
    }

    //
    // If we are here, then it is a "per adapter" guid/oid
    //
          
    PS_LOCK(&AdapterListLock);

    NextAdapter = AdapterList.Flink;
          
    while(NextAdapter != &AdapterList) 
    {
        Adapter = CONTAINING_RECORD(NextAdapter, ADAPTER, Linkage);
        
        PS_LOCK_DPC(&Adapter->Lock);
        
        if(Adapter->PsMpState != AdapterStateRunning) 
        {
            PS_UNLOCK_DPC(&Adapter->Lock);
        
            NextAdapter = NextAdapter->Flink;
            
            continue;
        }

        REFADD(&Adapter->RefCount, 'WMIQ');

        PS_UNLOCK_DPC(&Adapter->Lock);

        PS_UNLOCK(&AdapterListLock);

        //
        // We first see if this instance name is meaningful for this adapter.
        //
        
        cbInstanceName = *(PUSHORT)((PUCHAR)wnode + wnode->OffsetInstanceName);
        pInstanceName  = (PWSTR)((PUCHAR)wnode + wnode->OffsetInstanceName + sizeof(USHORT));
              
        //
        // This routine will determine if the wnode's instance name is a miniport or VC.
        // If it's a VC then it will find which one.
        //      
        Vc = 0;
        
        WanLink = 0;
        
        Status = PsWmiFindInstanceName(&WanLink, &Vc, Adapter, pInstanceName, cbInstanceName);
        
        if(!NT_SUCCESS(Status)) 
        {
            PS_LOCK(&AdapterListLock);

            NextAdapter = NextAdapter->Flink;

            REFDEL(&Adapter->RefCount, TRUE, 'WMIQ');
            
            continue;
        }
        else 
        {
            //
            // Found the adapter or the Vc or the WanLink. If this fails from this point, we can just return.
            //
           
            switch(MinorFunction) 
            {
              case IRP_MN_QUERY_SINGLE_INSTANCE:
              {
                  ULONG BytesNeeded;
                  ULONG wnodeSize;
                  //
                  //  Determine the buffer size needed for the GUID data.
                  //
                  Status = PsQueryGuidDataSize(Adapter,
                                               WanLink,
                                               Vc,
                                               pNdisGuid->Oid,
                                               &BytesNeeded);
                  if (!NT_SUCCESS(Status))
                  {
                      PsDbgOut(DBG_FAILURE, DBG_WMI,
                               ("[PsWmiQuerySingleInstance]: Adpater %08X, Unable to determine OID data size for OID %0x\n", 
                                Adapter, pNdisGuid->Oid));
                      break;
                  }
        
                  //
                  //      Determine the size of the wnode.
                  //
                  wnodeSize = wnode->DataBlockOffset + BytesNeeded;
                  if (BufferSize < wnodeSize)
                  {
                      WMI_BUFFER_TOO_SMALL(BufferSize, wnode, wnodeSize, &Status, pReturnSize);
                      break;
                  }
        
                  //
                  //      Initialize the wnode.
                  //
                  KeQuerySystemTime(&wnode->WnodeHeader.TimeStamp);
                  wnode->WnodeHeader.BufferSize = wnodeSize;
                  wnode->SizeDataBlock = BytesNeeded;
                  
                  //
                  //      Validate the guid and get the data for it.
                  //
                  Status = PsQueryGuidData(Adapter,
                                           WanLink,
                                           Vc,
                                           pNdisGuid->Oid,
                                           (PUCHAR)wnode + wnode->DataBlockOffset,
                                           BytesNeeded);
                  
                  if (!NT_SUCCESS(Status))
                  {
                      PsDbgOut(DBG_FAILURE, DBG_WMI,
                               ("PsWmiQuerySingleInstance: Adapter %08X, Failed to get the OID data for OID %08X.\n", 
                                Adapter, pNdisGuid->Oid));
                  }
                  else 
                  {
                      *pReturnSize = wnodeSize;
                  }
                  
                  break;
              }

              case IRP_MN_CHANGE_SINGLE_INSTANCE:
              {
                  PUCHAR pGuidData;
                  ULONG  GuidDataSize;

                  pGuidData    = (PUCHAR)wnode + wnode->DataBlockOffset;
                  GuidDataSize = wnode->SizeDataBlock;

                  //
                  // Attempt to set the miniport with the information.
                  //
                  
                  Status = PsQuerySetMiniport(Adapter,
                                              WanLink,
                                              Vc,
                                              pNdisGuid->Oid,
                                              pGuidData,
                                              GuidDataSize);
                  break;
              }

              default:
                  PsAssert(0);
            }

            //
            // If this was a VC then we need to dereference it.
            //
            if (NULL != WanLink)
            {
                REFDEL(&WanLink->RefCount, FALSE, 'WMII');
            }
            
            if (NULL != Vc)
            {
                DerefClVc(Vc);
            }
            
            REFDEL(&Adapter->RefCount, FALSE, 'WMIQ');

            return Status;
            
        }
    }

    PS_UNLOCK(&AdapterListLock);

    return Status;
}

NTSTATUS
WMIDispatch(
        IN      PDEVICE_OBJECT  pdo,
        IN      PIRP            pirp
        )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PIO_STACK_LOCATION      pirpSp = IoGetCurrentIrpStackLocation(pirp);
    ULONG_PTR               ProviderId = pirpSp->Parameters.WMI.ProviderId;
    PVOID                   DataPath = pirpSp->Parameters.WMI.DataPath;
    ULONG                   BufferSize = pirpSp->Parameters.WMI.BufferSize;
    PVOID                   Buffer = pirpSp->Parameters.WMI.Buffer;
    NTSTATUS                Status;
    ULONG                   ReturnSize = 0;
    KIRQL                   OldIrql;
    ULONG                   MinorFunction;

    PsDbgOut(DBG_TRACE, DBG_WMI,
             ("[WMIDispatch]: Device Object %08X, IRP Device Object %08X, "
              "Minor function %d \n", pdo, pirpSp->Parameters.WMI.ProviderId,
              pirpSp->MinorFunction));

#if DBG
    OldIrql = KeGetCurrentIrql();
#endif

    //
    // Fail the irp if we don't find an adapter. We also fail the irp if the provider ID is not 
    // us.
    //
    // If the ProviderID is not us, then ideally we need to pass it down the irp stack.
    //
    // (By calling IoSkipCurrentIrpStackLocation(pirp) & 
    //             IocallDriver(Adapter->NextDeviceObject, pirp);
    //
    // In this case, we are not attached to anything, so we can just fail the request.
    //

    if((pirpSp->Parameters.WMI.ProviderId != (ULONG_PTR)pdo)) {

        PsDbgOut(DBG_FAILURE, DBG_WMI,
                 ("[WMIDispatch]: Could not find the adapter for pdo 0x%x \n", pdo));

        pirp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        
        pirp->IoStatus.Information = 0;
        
        IoCompleteRequest(pirp, IO_NO_INCREMENT);

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    MinorFunction = pirpSp->MinorFunction;

    switch (pirpSp->MinorFunction)
    {
      case IRP_MN_REGINFO:
          
          Status = PsWmiRegister((ULONG_PTR)DataPath,
                                 Buffer,
                                 BufferSize,
                                 &ReturnSize);
          break;
          
      case IRP_MN_QUERY_ALL_DATA:
          
          Status = PsWmiQueryAllData((LPGUID)DataPath,
                                     (PWNODE_ALL_DATA)Buffer,
                                     BufferSize,
                                     &ReturnSize);
          break;
         
      case IRP_MN_CHANGE_SINGLE_INSTANCE:
      {
          PWNODE_SINGLE_INSTANCE  wnode = (PWNODE_SINGLE_INSTANCE) Buffer;
          PPS_WAN_LINK            WanLink;
          PGPC_CLIENT_VC          Vc;
          USHORT                  cbInstanceName;
          PWSTR                   pInstanceName;
          PNDIS_GUID              pNdisGuid;
          PUCHAR                  pGuidData;
          ULONG                   GuidDataSize;

          //
          // See if the GUID is ours
          //
          Status = PsWmiGetGuid(&pNdisGuid, &wnode->WnodeHeader.Guid, 0);
          
          if(!NT_SUCCESS(Status)) 
          {
              PsDbgOut(DBG_FAILURE, DBG_WMI, ("[WmiDispatch]: Invalid GUID \n"));
              
              Status = STATUS_INVALID_PARAMETER;
              
              break;
          }

          //
          // Is this guid settable?
          //
        
          if (PS_GUID_TEST_FLAG(pNdisGuid, fPS_GUID_NOT_SETTABLE))
          {
              PsDbgOut(DBG_FAILURE, DBG_WMI, ("[WmiDispatch]: Guid is not settable!\n"));
              
              Status = STATUS_WMI_NOT_SUPPORTED;
              
              break;
          }
          
          //
          //  Get a pointer to the GUID data and size.
          //
          GuidDataSize = wnode->SizeDataBlock;
          
          pGuidData = (PUCHAR)wnode + wnode->DataBlockOffset;
          
          if (GuidDataSize == 0)
          {
              PsDbgOut(DBG_FAILURE, DBG_WMI,
                       ("[PsWmiHandleSingleInstance]: Guid has not data to set!\n"));
              
              Status = STATUS_INVALID_PARAMETER;

              break;
          }
          
          //
          //  Make sure it's not a stauts indication.
          //
          if (!PS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_TO_OID))
          {
              PsDbgOut(DBG_FAILURE, DBG_WMI,
                       ("[PsWmiHandleSingleInstance]: Guid does not translate to an OID\n"));
              
              Status = STATUS_INVALID_DEVICE_REQUEST;
              break;
          }

          Status = PsWmiHandleSingleInstance(IRP_MN_CHANGE_SINGLE_INSTANCE, wnode, pNdisGuid, BufferSize, &ReturnSize);

          break;
      }
          
      case IRP_MN_QUERY_SINGLE_INSTANCE:
      {
          PWNODE_SINGLE_INSTANCE  wnode = (PWNODE_SINGLE_INSTANCE) Buffer;
          PNDIS_GUID              pNdisGuid;

          //
          // See if the GUID is ours
          //
          Status = PsWmiGetGuid(&pNdisGuid, &wnode->WnodeHeader.Guid, 0);
          
          if(!NT_SUCCESS(Status)) 
          {
              PsDbgOut(DBG_FAILURE, DBG_WMI, ("[WmiDispatch]: Invalid GUID \n"));
              
              Status = STATUS_INVALID_PARAMETER;
          }
          else 
          {
              Status = PsWmiHandleSingleInstance(IRP_MN_QUERY_SINGLE_INSTANCE, wnode, pNdisGuid, BufferSize, &ReturnSize);
          }

          break;
      }
          
      case IRP_MN_ENABLE_EVENTS:
          
          Status = PsWmiEnableEvents((LPGUID)DataPath);  
          break;
          
      case IRP_MN_DISABLE_EVENTS:
          
          Status = PsWmiDisableEvents((LPGUID)DataPath); 
          break;
          
      case IRP_MN_ENABLE_COLLECTION:
      case IRP_MN_DISABLE_COLLECTION:
      case IRP_MN_CHANGE_SINGLE_ITEM:

          Status = STATUS_NOT_SUPPORTED;
          
          PsDbgOut(DBG_TRACE, DBG_WMI,
                   ("[WMIDispatch]: Unsupported minor function (0x%x) \n",
                    pirpSp->MinorFunction));
          
          break;
          
      default:
          
          PsDbgOut(DBG_FAILURE, DBG_WMI,
                   ("[WMIDispatch]: Invalid minor function (0x%x) \n",
                    pirpSp->MinorFunction));
          
          Status = STATUS_INVALID_DEVICE_REQUEST;
          break;
    }
    
    PsAssert(KeGetCurrentIrql() == OldIrql);

    pirp->IoStatus.Status = Status;
    PsAssert(ReturnSize <= BufferSize);
    
    pirp->IoStatus.Information = NT_SUCCESS(Status) ? ReturnSize : 0;
    
    IoCompleteRequest(pirp, IO_NO_INCREMENT);

    //
    // Allow IFC_UP notifications.
    //

    if(MinorFunction == IRP_MN_REGINFO)
    {
        //
        // Need to walk all the adapters and send notifications.
        //
        PLIST_ENTRY NextAdapter;
        PADAPTER    Adapter;

        PS_LOCK(&AdapterListLock);

        WMIInitialized = TRUE;

        NextAdapter = AdapterList.Flink;
          
        while(NextAdapter != &AdapterList) 
        {
            Adapter = CONTAINING_RECORD(NextAdapter, ADAPTER, Linkage);
            
            PS_LOCK_DPC(&Adapter->Lock);

            if(Adapter->PsMpState == AdapterStateRunning && !Adapter->IfcNotification)
            {

                Adapter->IfcNotification = TRUE;

                REFADD(&Adapter->RefCount, 'WMIN');

                PS_UNLOCK_DPC(&Adapter->Lock);

                PS_UNLOCK(&AdapterListLock);

                TcIndicateInterfaceChange(Adapter, 0, NDIS_STATUS_INTERFACE_UP);

                PS_LOCK(&AdapterListLock);

                NextAdapter = NextAdapter->Flink;

                REFDEL(&Adapter->RefCount, TRUE, 'WMIN');
            }
            else 
            {
                //
                // This adapter is not yet ready. The interface will be indicated 
                // in the mpinitialize handler, when the adapter gets ready.
                //

                PS_UNLOCK_DPC(&Adapter->Lock);

                NextAdapter = NextAdapter->Flink;
            }
        }

        PS_UNLOCK(&AdapterListLock);
    }
    
    PsDbgOut(DBG_TRACE, DBG_WMI, ("[WMIDispatch] : completing with Status %X \n", Status));
    return(Status);
}

NTSTATUS
GenerateInstanceName(
    IN PNDIS_STRING     Prefix,
    IN PADAPTER         Adapter,
    IN PLARGE_INTEGER   Index,
    IN PNDIS_STRING     pInstanceName)
{
#define CONVERT_MASK                    0x000000000000000F

    NTSTATUS        Status = STATUS_SUCCESS;
    USHORT          cbSize;
    PUNICODE_STRING uBaseInstanceName = (PUNICODE_STRING)&Adapter->WMIInstanceName;
    UINT            Value;
    WCHAR           wcLookUp[] = {L'0', L'1', L'2', L'3', L'4', L'5', L'6', L'7', L'8', L'9', L'A', L'B', L'C', L'D', L'E', L'F'};
    WCHAR           tmpBuffer[18] = {0};
    UINT            c;
    ULONGLONG       tmpIndex;
    KIRQL           OldIrql;

    do
    {
        //
        //      Is there already a name associated with this VC?
        //
        
        //
        //      The instance name will be of the format:
        //              <Prefix>: [YYYYYYYYYYYYYYYY] Base Name
        //
        
        cbSize = INSTANCE_ID_SIZE + Prefix->Length;
        
        if (NULL != uBaseInstanceName)
        {
            cbSize += uBaseInstanceName->Length;
        }


        //
        //      Initialize a temporary UNICODE_STRING to build the name.
        //
        NdisZeroMemory(pInstanceName->Buffer, cbSize);
        pInstanceName->Length = 0;
        pInstanceName->MaximumLength = cbSize;

        //
        // Add the prefix
        //
        RtlCopyUnicodeString(pInstanceName, Prefix);

        //
        //      Add the separator.
        //      
        RtlAppendUnicodeToString(pInstanceName, L" [");

        //
        //      Add the VC index.
        //
        //tmpIndex = (ULONGLONG)(Index->HighPart << 32) | (ULONGLONG)Index->LowPart;
        tmpIndex = Index->QuadPart;

        for (c = 16; c > 0; c--)
        {
            //
            //  Get the nibble to convert.
            //
            Value = (UINT)(tmpIndex & CONVERT_MASK);

            tmpBuffer[c - 1] = wcLookUp[Value];

            //
            //  Shift the tmpIndex by a nibble.
            //
            tmpIndex >>= 4;
        }

        RtlAppendUnicodeToString(pInstanceName, tmpBuffer);

        //
        //      Add closing bracket.
        //
        RtlAppendUnicodeToString(pInstanceName, L"]");


        if (NULL != uBaseInstanceName)
        {
            RtlAppendUnicodeToString(pInstanceName, L" ");

            //
            //  Append the base instance name passed into us to the end.
            //
            RtlAppendUnicodeToString(pInstanceName, uBaseInstanceName->Buffer);
        }

    } while (FALSE);
    
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\timestmp.h ===
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                  EXTERNAL (SHARED) DEFINITIONS                                           //
//                                                                                                          //
// ( Any user mode app which wants to use this functionality should copy this section of the header file)   //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

//  WildCard definitions for Ip Address, Port and Protocol                                          //

#define UL_ANY  0xffffffff
#define US_ANY  0xffff

//  Definitions for Direction (Send/Recv)                                                           //

#define DIR_SEND    1
#define DIR_RECV    2

//  Common InBuf structure: This is same for either type of request                                 //
//  For wildcarding, use UL_ANY for ULONGs and US_ANY for USHORTs                                   //
//                                                                                                  //
//  This will be layed out in the buffer in this fashion:                                           //
//          +---------------------------------------------+                                         //
//  0x00    |       SrcIp (4)    | SrcPort(2)  Padding(2) |                                         //
//          +---------------------------------------------+                                         //
//  0x08    |       DstIp (4)    | DstPort(2)  Padding(2) |                                         //
//          +---------------------------------------------+                                         //
//  0x10    | Proto(2)| Dir'n(2) |                                                                  //
//          +---------+----------+                                                                  //

typedef struct _TIMESTMP_REQ
{
    ULONG   SrcIp;
    USHORT  SrcPort;
    ULONG   DstIp;
    USHORT  DstPort;
    USHORT  Proto;
    USHORT  Direction;
} TIMESTMP_REQ, *PTIMESTMP_REQ;


//  1. MARK_IN_BUF_RECORD: THIS WILL MARK THE TIMESTAMPS IN A BUFFER WITH IP-ID'S AND PACKET-SIZES  //
//                                                                                                  //
//  This will be laid out in the buffer in this fashion:                                            //
//          +---------------------------------------------+                                         //
//  0x00    |IpId(2) Size(2)    |   Padding(4)            |                                         //
//          +---------------------------------------------+                                         //
//  0x08    |           TimeValue (8)                     |                                         //
//          +---------------------------------------------+                                         //

#define IOCTL_TIMESTMP_REGISTER_IN_BUF      CTL_CODE(   FILE_DEVICE_NETWORK, 23, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_TIMESTMP_DEREGISTER_IN_BUF    CTL_CODE(   FILE_DEVICE_NETWORK, 24, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_TIMESTMP_FINISH_BUFFERING     CTL_CODE(   FILE_DEVICE_NETWORK, 25, METHOD_BUFFERED, FILE_WRITE_ACCESS)

typedef struct _MARK_IN_BUF_RECORD
{
	USHORT	IpId;   
	USHORT	Size;
	UINT64	TimeValue;
} MARK_IN_BUF_RECORD, *PMARK_IN_BUF_RECORD;

//  This is the MINIMUM size of the buffer that should be passed in with every request to copy      //
//  timestamps colleced in the drivers internal buffer. Application should call this frequently     //
//  to prevent driver buffer re-use                                                                 //
#define	PACKET_STORE_SIZE	(sizeof(MARK_IN_BUF_RECORD)*5000)



//  2. MARK_IN_PKT_RECORD: THIS WILL MARK THE TIMESTAMPS IN THE PACKET ITSELF                       //
//                                                                                                  //
//  This will be laid out in the packet in this fashion:                                            //
//          +---------------------------------------------+                                         //
//  0x00    |           Time Sent - App (8)               |                                         //
//          +---------------------------------------------+                                         //
//  0x08    |           Time Rcvd - App (8)               |                                         //
//          +---------------------------------------------+                                         //
//  0x10    |           Time Sent - OS (8)                |                                         //
//          +---------------------------------------------+                                         //
//  0x18    |           Time Rcvd - OS (8)                |                                         //
//          +---------------------------------------------+                                         //
//  0x20    |           Latency - App (8)                 |                                         //
//          +---------------------------------------------+                                         //
//  0x28    | BufferSize - App(4) | Seq No - App (4)      |                                         //
//          +---------------------------------------------+                                         //
//                                                                                                  //

#define IOCTL_TIMESTMP_REGISTER_IN_PKT            CTL_CODE(   FILE_DEVICE_NETWORK, 21, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_TIMESTMP_DEREGISTER_IN_PKT           CTL_CODE(   FILE_DEVICE_NETWORK, 22, METHOD_BUFFERED, FILE_WRITE_ACCESS)

typedef struct _MARK_IN_PKT_RECORD
{
    UINT64  TimeSent;
    UINT64  TimeReceived;
    UINT64  TimeSentWire;         
    UINT64  TimeReceivedWire;     
    UINT64  Latency;
    INT     BufferSize;
    INT     SequenceNumber;
} MARK_IN_PKT_RECORD, *PMARK_IN_PKT_RECORD;



//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                  INTERNAL TIMESTMP DEFINITIONS                                           //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define IOCTL_PSCHED_ZAW_EVENT                  CTL_CODE(   FILE_DEVICE_NETWORK, 20, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define     MARK_NONE   0
#define     MARK_IN_PKT 1
#define     MARK_IN_BUF 2


typedef struct _TS_ENTRY {
    LIST_ENTRY              Linkage;

    ULONG	                SrcIp;
    USHORT                  SrcPort;
    ULONG	                DstIp;
    USHORT                  DstPort;
    USHORT                  Proto;
    USHORT                  Type;
    USHORT                  Direction;
    
    PFILE_OBJECT            FileObject;    
    PMARK_IN_BUF_RECORD	    pPacketStore;
    PMARK_IN_BUF_RECORD	    pPacketStoreHead;
} TS_ENTRY, *PTS_ENTRY;


extern LIST_ENTRY       TsList;
extern NDIS_SPIN_LOCK   TsSpinLock;
extern ULONG            TsCount;

VOID
InitializeTimeStmp( PPSI_INFO Info );


BOOL
AddRequest(  PFILE_OBJECT FileObject, 
             ULONG  SrcIp, 
             USHORT SrcPort,
             ULONG  DstIp, 
             USHORT DstPort,
             USHORT Proto,
             USHORT Type,
             USHORT Direction);


void
RemoveRequest(  PFILE_OBJECT FileObject, 
                ULONG  SrcIp, 
                USHORT SrcPort,
                ULONG  DstIp, 
                USHORT DstPort,
                USHORT Proto);

int
CopyTimeStmps( PFILE_OBJECT FileObject, PVOID buf, ULONG    Len);

VOID
UnloadTimeStmp();


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                  COPIED TRANSPORT DEFINITIONS
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define IPPROTO_TCP                     6               
#define IPPROTO_UDP                     17  
#define IP_MF_FLAG                      0x0020              
#define IP_VERSION                      0x40
#define IP_VER_FLAG                     0xF0
#define TCP_OFFSET_MASK                 0xf0
#define TCP_HDR_SIZE(t)                 (uint)(((*(uchar *)&(t)->tcp_flags) & TCP_OFFSET_MASK) >> 2)
#define IP_OFFSET_MASK                  ~0x00E0         
#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
#define net_short(_x) _byteswap_ushort((USHORT)(_x))
#else
#define net_short(x)                    ((((x)&0xff) << 8) | (((x)&0xff00) >> 8))
#endif

typedef int                             SeqNum;                         // A sequence number.

struct TCPHeader {
        ushort                          tcp_src;                        // Source port.
        ushort                          tcp_dest;                       // Destination port.
        SeqNum                          tcp_seq;                        // Sequence number.
        SeqNum                          tcp_ack;                        // Ack number.
        ushort                          tcp_flags;                      // Flags and data offset.
        ushort                          tcp_window;                     // Window offered.
        ushort                          tcp_xsum;                       // Checksum.
        ushort                          tcp_urgent;                     // Urgent pointer.
};

typedef struct TCPHeader TCPHeader;

struct UDPHeader {
        ushort          uh_src;                         // Source port.
        ushort          uh_dest;                        // Destination port.
        ushort          uh_length;                      // Length
        ushort          uh_xsum;                        // Checksum.
}; /* UDPHeader */

typedef struct UDPHeader UDPHeader;

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\psched\sys\wmi.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    wmi.h

Abstract:

    defines for psched's WMI support

Author:

    Rajesh Sundaram (rajeshsu)

Revision History:

--*/

NTSTATUS
PsTcNotify(IN PADAPTER Adapter, 
           IN PPS_WAN_LINK WanLink,
           IN NDIS_OID Oid,
           IN PVOID    StatusBuffer,
           IN ULONG    StatusBufferSize);

NTSTATUS
WMIDispatch(
	IN	PDEVICE_OBJECT	pdo,
	IN	PIRP			pirp
	);

NTSTATUS
GenerateInstanceName(
    IN PNDIS_STRING     Prefix,
    IN PADAPTER         Adapter,
    IN PLARGE_INTEGER   Index,
    OUT PNDIS_STRING    pInstanceName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\tc\dll\dbgmem.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    dbgmem.c

Abstract:

    This module contains memory debug routines for catching memory leaks and memory
    overwrites.

Author:

    Jim Stewart   January 8, 1997

Revision History:

--*/

#include"precomp.h"
#pragma hdrstop

#include<imagehlp.h>


#ifdef DBG


#define ulCheckByteEnd          0x9ABCDEF0
#define cbExtraBytes            (sizeof(MEM_TRACKER) + sizeof(DWORD))
#define dwStackLimit            0x00010000      //  64KB for NT


// Protect access to allocated memory chain
CRITICAL_SECTION    critsMemory;
BOOL                SymbolsInitialized = FALSE;

//
// Head of allocated memory chain
//
LIST_ENTRY MemList;

//
// The type of machine we are on - needed to figure out the call stack
//
DWORD   MachineType;
HANDLE  OurProcess;

VOID
InitSymbols(
    );



BOOL
InitDebugMemory(
    )
/*++

Description:

    This routine initializes the debug memory functionality.

Arguments:

    none

Return Value:

    BOOL - pass or fail

--*/
{
    BOOL        status;
    SYSTEM_INFO SysInfo;

    __try {

        InitializeCriticalSection(&critsMemory);

    } __except (EXCEPTION_EXECUTE_HANDLER) {
    
        return FALSE;
    }

    InitializeListHead( &MemList );

    OurProcess = GetCurrentProcess();

    GetSystemInfo( &SysInfo );
    switch (SysInfo.wProcessorArchitecture) {

    default:
    case PROCESSOR_ARCHITECTURE_INTEL:
        MachineType = IMAGE_FILE_MACHINE_I386;
        break;

    case PROCESSOR_ARCHITECTURE_MIPS:
        //
        // note this may not detect R10000 machines correctly
        //
        MachineType = IMAGE_FILE_MACHINE_R4000;
        break;

    case PROCESSOR_ARCHITECTURE_ALPHA:
        MachineType = IMAGE_FILE_MACHINE_ALPHA;
        break;

    case PROCESSOR_ARCHITECTURE_PPC:
        MachineType = IMAGE_FILE_MACHINE_POWERPC;
        break;

    }

    return( TRUE );
}

VOID
DeInitDebugMemory(
    )
/*++

Description:

    This routine deinitializes the critical section used by the dbg mem functions.

Arguments:

    none

Return Value:

    none

--*/
{
    DeleteCriticalSection(&critsMemory);
}


VOID
InitSymbols(
    )
/*++

Description:

    This routine initializes the debug memory functionality.

Arguments:

    none

Return Value:

    BOOL - pass or fail

--*/
{
    BOOL        status;

    //
    // only load the symbols if we are going to track the call stack
    //

    IF_DEBUG(MEM_CALLSTACK) {
        status = SymInitialize( OurProcess,NULL,TRUE );
    }

    SymbolsInitialized = TRUE;
}


VOID
UpdateCheckBytes(
    IN PMEM_TRACKER MemTracker
    )
/*++

Description:

    This routine adds check bytes at the end of allocatedmemory. These check bytes are used to check
    for memory overwrites. Also a check sum in the MEM_TRACKER structure is also set here.

Arguments:

    MemTracker       newly allocated memory block

Return Value:

    none

--*/
{
    *((DWORD*)(((PUCHAR)MemTracker) + MemTracker->nSize + sizeof(MEM_TRACKER))) = ulCheckByteEnd;

    MemTracker->ulCheckSum = ulCheckByteEnd +
                            PtrToUlong(MemTracker->szFile) +
                            MemTracker->nLine +
                            MemTracker->nSize +
                            PtrToUlong(MemTracker->Linkage.Blink) +
                            PtrToUlong(MemTracker->Linkage.Flink);
}


BOOL
FCheckCheckBytes(
    IN PMEM_TRACKER MemTracker
    )
/*++

Description:

    This routine checks the check sum in the MEM_TRACKER structure, called before freeing the allocated
    memory.

Arguments:

    MemTracker       memory block whose check sum needs to be validated

Return Value:

    TRUE        if check sum is correct
    FALSE       otherwise

--*/
{
    DWORD   ul;

    ul = *((DWORD*)(((PUCHAR)MemTracker)+MemTracker->nSize+sizeof(MEM_TRACKER))) +
                  PtrToUlong(MemTracker->szFile) +
                  MemTracker->nLine +
                  MemTracker->nSize +
                  PtrToUlong(MemTracker->Linkage.Blink) +
                  PtrToUlong(MemTracker->Linkage.Flink);

    if (ul != MemTracker->ulCheckSum) {

        WSPRINT(( "Memory overwrite on location 0x%08lx\n",
                  PtrToUlong(MemTracker+sizeof(MEM_TRACKER)) ));

        return FALSE;
    }

    return TRUE;
}


BOOL
FCheckAllocatedMemory()
/*++

Description:

    This routine walks the allocated memory list and checks for validity of check sum and check
    bytes.

Arguments:

    none

Return Value:

    TRUE        if all the allocated memory pass the above two checks.
    FALSE       otherwise

--*/
{
    PMEM_TRACKER    MemTracker;
    BOOL            check = TRUE;
    PLIST_ENTRY     Entry;

    IF_DEBUG(CHKSUM_ALLMEM) {

        EnterCriticalSection(&critsMemory);

        for (Entry = MemList.Flink; Entry != &MemList; Entry = Entry->Flink ) {

            MemTracker = CONTAINING_RECORD( Entry,MEM_TRACKER,Linkage );
            if (!FCheckCheckBytes(MemTracker)) {
                check = FALSE;
            }

        }

        LeaveCriticalSection(&critsMemory);

    }

    return check;
}



VOID
AddMemTracker(
    IN PMEM_TRACKER     MemTracker
    )
/*++

Description:

    Adds the supplied MEM_TRACKER at the tail of the doubly linked allocated memory list and
    set the check sum also.

Arguments:

    MemTracker   MEM_TRACKER * to be added to the list

Return Value:

    none

--*/
{
    PMEM_TRACKER    Tracker;

    ASSERT(MemTracker);


    InsertTailList( &MemList,&MemTracker->Linkage );

    UpdateCheckBytes( MemTracker );
    FCheckCheckBytes( MemTracker );

    //
    // if there are other blocks in the list then change their check sum
    // since we have just changed their Flink to point to us
    //
    if (MemTracker->Linkage.Blink != &MemList) {

        Tracker = CONTAINING_RECORD( MemTracker->Linkage.Blink,MEM_TRACKER,Linkage );
        UpdateCheckBytes( Tracker );
        FCheckCheckBytes( Tracker );
    }
}



VOID
RemoveMemTracker(
    IN  PMEM_TRACKER MemTracker
    )
/*++

Description:

    Removes the supplied MEM_TRACKER * from the list of allocated memory. Also checks
    for memory overwites and updated the check sum for the entries before and
    after the entry being removed

Arguments:

    MemTracker   MEM_TRACKER to remove from the list

Return Value:

    none

--*/
{
    ASSERT(MemTracker);

    //
    // Validate the check sum before
    // removing from the list
    //

    FCheckCheckBytes(MemTracker);

    //
    // Remove MemTracker from the list
    //

    RemoveEntryList( &MemTracker->Linkage );

    //
    // Since the check sum is based on next and
    // prev pointers, need to update the check
    // sum for prev entry
    //

    if (MemTracker->Linkage.Blink != &MemList) {
        UpdateCheckBytes((MEM_TRACKER*)MemTracker->Linkage.Blink);
        FCheckCheckBytes((MEM_TRACKER*)MemTracker->Linkage.Blink);
    }

    if (MemTracker->Linkage.Flink != &MemList) {
        UpdateCheckBytes((MEM_TRACKER*)MemTracker->Linkage.Flink);
        FCheckCheckBytes((MEM_TRACKER*)MemTracker->Linkage.Flink);
    }

}

BOOL
ReadMem(
    IN HANDLE    hProcess,
    IN ULONG_PTR BaseAddr,
    IN PVOID     Buffer,
    IN DWORD     Size,
    IN PDWORD    NumBytes )
/*++

Description:

    This is a callback routine that StackWalk uses - it just calls teh system ReadProcessMemory
    routine with this process's handle

Arguments:


Return Value:

    none

--*/

{
    BOOL    status;
    SIZE_T  RealNumBytes;

    status = ReadProcessMemory( GetCurrentProcess(),
                                (LPCVOID)BaseAddr,
                                Buffer,
                                Size,
                                &RealNumBytes );
    *NumBytes = (DWORD)RealNumBytes;

    return( status );
}


VOID
GetCallStack(
    IN PCALLER_SYM   Caller,
    IN int           Skip,
    IN int           cFind
    )
/*++

Description:

    This routine walks te stack to find the return address of caller. The number of callers
    and the number of callers on top to be skipped can be specified.

Arguments:

    pdwCaller       array of DWORD to return callers
                    return addresses
    Skip            no. of callers to skip
    cFInd           no. of callers to find

Return Value:

    none

--*/
{
    BOOL             status;
    CONTEXT          ContextRecord;
    PUCHAR           Buffer[sizeof(IMAGEHLP_SYMBOL)-1 + MAX_FUNCTION_INFO_SIZE];
    PIMAGEHLP_SYMBOL Symbol = (PIMAGEHLP_SYMBOL)Buffer;
    STACKFRAME       StackFrame;
    INT              i;
    DWORD            Count;

    memset(Caller, 0, cFind * sizeof(CALLER_SYM));

    ZeroMemory( &ContextRecord,sizeof( CONTEXT ) );
    ContextRecord.ContextFlags = CONTEXT_CONTROL;
    status = GetThreadContext( GetCurrentThread(),&ContextRecord );

    ZeroMemory( &StackFrame,sizeof(STACKFRAME) );
    StackFrame.AddrPC.Segment = 0;
    StackFrame.AddrPC.Mode = AddrModeFlat;

#ifdef _M_IX86
    StackFrame.AddrFrame.Offset = ContextRecord.Ebp;
    StackFrame.AddrFrame.Mode = AddrModeFlat;

    StackFrame.AddrStack.Offset = ContextRecord.Esp;
    StackFrame.AddrStack.Mode = AddrModeFlat;

    StackFrame.AddrPC.Offset = (DWORD)ContextRecord.Eip;
#elif defined(_M_MRX000)
    StackFrame.AddrPC.Offset = (DWORD)ContextRecord.Fir;
#elif defined(_M_ALPHA)
    StackFrame.AddrPC.Offset = (DWORD)ContextRecord.Fir;
#elif defined(_M_PPC)
    StackFrame.AddrPC.Offset = (DWORD)ContextRecord.Iar;
#endif

    Count = 0;
    for (i=0;i<cFind+Skip ;i++ ) {
        status = StackWalk( MachineType,
                            OurProcess,
                            GetCurrentThread(),
                            &StackFrame,
                            (PVOID)&ContextRecord,
                            ReadMem,
                            SymFunctionTableAccess,
                            SymGetModuleBase,
                            NULL );


        if (status && i >= Skip) {
            DWORD_PTR   Displacement;

            ZeroMemory( Symbol,sizeof(IMAGEHLP_SYMBOL)-1 + MAX_FUNCTION_INFO_SIZE );
            Symbol->SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
            Symbol->Address = StackFrame.AddrPC.Offset;
            Symbol->MaxNameLength = MAX_FUNCTION_INFO_SIZE-1;
            Symbol->Flags = SYMF_OMAP_GENERATED;

            status = SymGetSymFromAddr( OurProcess,
                                        StackFrame.AddrPC.Offset,
                                        &Displacement,
                                        Symbol );

            //
            // save the name of the function and the displacement into it for later printing
            //

            if (status) {
                strcpy( Caller[Count].Buff,Symbol->Name );
                Caller[Count].Displacement = Displacement;
            }
            Count++;

        }
    }

}


PVOID
AllocMemory(
    IN DWORD    nSize,
    IN BOOL     Calloc,
    IN PSZ      szFileName,
    IN DWORD    nLine
    )
/*++

Description:

    This routine is the memory allocator (like malloc) for DBG builds. This routine allocated
    more memory than requested by the caller. In this extra space this routine save info to
    track memory leaks, overwrite, callers etc. All the info is stored in a MEM_TRACKER structure
    which preceed the buffer to be returned.

Arguments:

    nSize           size of the required buffer.
    Calloc          if true then call Calloc ( which initializes memory to zero )
    szFileName      name of the file which contains
                    the routine asking for memory.
    nLine           line number in the above file
                    which has the call to PvAlloc.

Return Value:

    address of the allocated buffer.

--*/
{
    PVOID           pvRet;
    PMEM_TRACKER    MemTracker;
    static DWORD    ulAllocs = 0;
    PUCHAR          FileName;

    if (!SymbolsInitialized){
        InitSymbols();
    }

    EnterCriticalSection(&critsMemory);
    ++ulAllocs;


    //
    // Check entire allocated memory for overwite
    //

    if ( !FCheckAllocatedMemory() ) {
        WSPRINT(("Memory Overwrite detected in AllocMemory\n" ));
        ASSERT(0);
    }

    //
    // Size of the allocated memory is always
    // a multiple of sizeof(DWORD)
    //

    nSize = ((nSize +3) /4) * 4;

    //
    // shorten file name to just be the file name and not the path too
    //

    FileName = strrchr( szFileName,'\\' );
    if (!FileName) {
        FileName = szFileName;
    } else {
        FileName++; // skip /
    }

    //
    // Allocate extra for MEM_TRACKER and guard byte at end
    //

    if (!Calloc) {
        pvRet = malloc( nSize + cbExtraBytes );
    } else {
        //
        // this routine will initialize the memory to zero
        //
        pvRet = calloc( 1,(nSize + cbExtraBytes) );
    }
    if (!pvRet) {


        IF_DEBUG(ERRORS) {
            WSPRINT(( "Memory alloc failed size=%li, %s line %li\n",
                      nSize,
                      FileName,
                      nLine ));
        }

        LeaveCriticalSection(&critsMemory);
        return NULL;
    }

    //
    // Fill in new alloc with 0xFA.
    //

    if (!Calloc) {
        memset(pvRet, 0xFA, nSize+cbExtraBytes);
    }

    //
    // Save all the debug info needed in MEM_TRACKER
    //

    MemTracker = pvRet;
    MemTracker->szFile = FileName;
    MemTracker->nLine = nLine;
    MemTracker->nSize = nSize;
    MemTracker->ulAllocNum = ulAllocs;

    //
    // only save the call stack info if it is turned on
    //

    IF_DEBUG(MEM_CALLSTACK) {
        GetCallStack( MemTracker->Callers,
                      3,
                      NCALLERS);

    }

    //
    // Add to the list
    //

    AddMemTracker(MemTracker);

    LeaveCriticalSection(&critsMemory);

    IF_DEBUG(MEMORY_ALLOC) {
        WSPRINT(( "Memory alloc (0x%08lX) size=%li, %s line %li\n",
               PtrToUlong(pvRet)+sizeof(MEM_TRACKER),
               nSize,
               FileName,
               nLine ));
    }

    //
    // Return the address following the MEM_TRACKER as
    // address of the buffer allocated.
    //

    return (PVOID)((PUCHAR)pvRet+sizeof(MEM_TRACKER));
}



PVOID
ReAllocMemory(
    IN PVOID    pvOld,
    IN DWORD    nSizeNew,
    IN PSZ      szFileName,
    IN DWORD    nLine
    )
/*++

Description:

    This routine is the DBG version of realloc memory allocator function. This routine
    works just like PvAlloc function.

Arguments:

    pvOld           address of the buffer whose size
                    needs to be changed.
    nSizeNew        new size of the required buffer.
    szFileName      name of the file which contains
                    the routine asking for memory.
    nLine           line number in the above file
                    which has the call to PvAlloc.

Return Value:

    address of the buffer with the new size.

--*/
{
    PVOID           pvRet;
    PMEM_TRACKER    MemTracker;

    //
    // Check the entire allocated memory for
    // overwrites.
    //

    if ( !FCheckAllocatedMemory() ) {
        WSPRINT(("Memory Overwrite detected in ReAllocMemory\n" ));
        ASSERT(0);
    }


    ASSERT(pvOld);

    //
    // Size of the memory allocated is always
    // a multiple of sizeof(DWORD)
    //

    nSizeNew = ((nSizeNew + 3)/4) *4;

    //
    // Extra space for MEM_TRACKER and Guard bytes
    //

    pvRet = realloc(pvOld, nSizeNew+cbExtraBytes);
    if (!pvRet) {

        IF_DEBUG(MEMORY_ALLOC) {
            WSPRINT(( "Memory realloc failed (0x%08lX) size=%li, %s line %li\n",
                     PtrToUlong(pvOld) + sizeof(MEM_TRACKER),
                     nSizeNew,
                     szFileName,
                     nLine ));
        }
    } else {

        IF_DEBUG(MEMORY_ALLOC) {
            WSPRINT(( "Memory realloc succeeded (0x%08lX) size=%li, %s line %li\n",
                     PtrToUlong(pvOld) + sizeof(MEM_TRACKER),
                     PtrToUlong(pvRet)+sizeof(MEM_TRACKER),
                     nSizeNew,
                     szFileName,
                     nLine ));
        }

        MemTracker = (PMEM_TRACKER)pvRet;

        if (nSizeNew > (DWORD)MemTracker->nSize) {

            //
            // Fill in extra alloc with 0xEA.
            //

            memset((PUCHAR)pvRet+sizeof(MEM_TRACKER)+MemTracker->nSize, 0xEA, nSizeNew - MemTracker->nSize);
        }

        MemTracker = pvRet;
        MemTracker->szFile = szFileName;
        MemTracker->nLine = nLine;
        MemTracker->nSize = nSizeNew;
    }

    //
    // Add the new buffer to the list and update check sum
    //

    AddMemTracker(MemTracker);

    LeaveCriticalSection(&critsMemory);

    if (pvRet)
    return (PVOID)((PUCHAR)pvRet+sizeof(MEM_TRACKER));
    else
    return NULL;
}


VOID
FreeMemory(
    IN PVOID    pv,
    IN PSZ      szFileName,
    IN DWORD    nLine
    )
/*++

Description:

    This is the DBG version of free function. This routine checks for memory overwrites in the
    block of memory being freed before removing from the list.

Arguments:

    pv          address of the buffer to be freed
    szFileName  name of the file from which this
                block of memory is being freed.
    nLine       line number in the above file
                which has the call to FreePvFn.

Return Value:

    none

--*/
{
    PMEM_TRACKER   MemTracker;

    ASSERT(pv);
    if (NULL == pv)
    return;

    EnterCriticalSection(&critsMemory);

    MemTracker = (PMEM_TRACKER)((PUCHAR)pv-sizeof(MEM_TRACKER));

    //
    // Check for memory overwrites
    //

    if (!FCheckCheckBytes(MemTracker)) {
        WSPRINT(( "Memory Overwrite detected when freeing memory\n" ));
        ASSERT(0);
    }

    if ( !FCheckAllocatedMemory() ){
        WSPRINT(("Memory Overwrite - detected when checking allocated mem when freeing a block\n" ));
        ASSERT(0);
    }

    IF_DEBUG(MEMORY_FREE) {
        PUCHAR  FileName;

        //
        // shorten file name to just be the file name and not the path too
        //

        FileName = strrchr( szFileName,'\\' );
        if (!FileName) {
            FileName = szFileName;
        } else {
            FileName++; // skip /
        }
        WSPRINT(( "Memory freed (0x%08lX) size=%li, %s line %li\n",
                 PtrToUlong(pv),
                 MemTracker->nSize,
                 FileName,
                 nLine ));

    }
    //
    // Remove from the list
    //

    RemoveMemTracker(MemTracker);

    //
    // Fill in freed alloc with 0xCC.
    //

    memset(MemTracker, 0xCC, MemTracker->nSize+cbExtraBytes);

    free( MemTracker );

    LeaveCriticalSection(&critsMemory);
}


BOOL
DumpAllocatedMemory()
/*++

Description:

    This routine is called during shutdown to dump out any unfreed memory blocks.

Arguments:

    none

Return Value:

    TRUE        if there are any unfreed memory blocks.
    FALSE       if all the allocated memory has been freed.

--*/
{

    BOOL         status;
    PMEM_TRACKER MemTracker;
    DWORD        ulNumBlocks = 0;
    DWORD        ulTotalMemory = 0;
    PLIST_ENTRY  Entry;

    //
    // If the head of the chain is NULL,
    // all memory has been freed.
    //

    IF_DEBUG(DUMP_MEM) {
        EnterCriticalSection(&critsMemory);

        WSPRINT(("\n\n*** Start dumping unfreed memory ***\n\n",0 ));

        for (Entry = MemList.Flink; Entry != &MemList; Entry = Entry->Flink) {
            INT  i;

            MemTracker = CONTAINING_RECORD( Entry,MEM_TRACKER,Linkage );

            ulNumBlocks++;
            ulTotalMemory += MemTracker->nSize;

            WSPRINT(( "(0x%08lX) size=%li, %s line %li alloc# 0x%lx\n",
                      PtrToUlong(MemTracker)+sizeof(MEM_TRACKER),
                      MemTracker->nSize,
                      MemTracker->szFile,
                      MemTracker->nLine,
                      MemTracker->ulAllocNum ));


            //
            // dump the call stack if that debugging is on
            //

            IF_DEBUG(MEM_CALLSTACK) {
                for (i = 0; i < NCALLERS && MemTracker->Callers[i].Buff[0] != 0; i++) {

                    WSPRINT(( "%d %s + 0x%X \n",i,MemTracker->Callers[i].Buff,MemTracker->Callers[i].Displacement ));
                }
            }

            FCheckCheckBytes( MemTracker );
        }


        if (ulNumBlocks > 0) {

            WSPRINT(( "%li blocks allocated, and %li bytes\n",
                      ulNumBlocks,
                      ulTotalMemory ));

            status = TRUE;

        } else {
            status = FALSE;
        }

        WSPRINT(( "\n\n*** Finished dumping memory ***\n\n",0 ));

        LeaveCriticalSection(&critsMemory);
    }

    return status;
}


BOOL
SearchAllocatedMemory(
    IN PSZ      szFile,
    IN DWORD    nLine
    )
/*++

Description:

    This routine dumps details about memory allocated by a given line of code in a given file.

Arguments:

    szFile      name of the file
    nLine       line number of code whose memory allocationto be displayed

Return Value:

    TRUE        if there was atleast one memory block allocated by the given line number
                in the given file.
    FALE        otherwise.

--*/
{
    PMEM_TRACKER    MemTracker;
    BOOL            fFound = FALSE;
    PLIST_ENTRY     Entry;

    EnterCriticalSection(&critsMemory);

    WSPRINT(( "Searching memory\n", 0 ));

    for (Entry = MemList.Flink; Entry != &MemList; Entry = Entry->Flink ) {

        MemTracker = CONTAINING_RECORD( Entry,MEM_TRACKER,Linkage );

        //
        // Look for a match on filename and line number
        //

        if ( strcmp(MemTracker->szFile, szFile) == 0 &&  MemTracker->nLine == nLine ) {

            ASSERT(FALSE);
            WSPRINT(( "(0x%08lX) size=%li, %s line %li alloc# 0x%lx\n",
                     PtrToUlong(MemTracker)+sizeof(MEM_TRACKER),
                     MemTracker->nSize,
                     MemTracker->szFile,
                     MemTracker->nLine,
                     MemTracker->ulAllocNum));
            fFound = TRUE;
            break;
        }
    }

    LeaveCriticalSection(&critsMemory);

    WSPRINT(( "Finished searching memory\n",0 ));

    return fFound;
}



#endif      // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\tc\dll\handfact.c ===
/*
 *  handfact.c
 *
 *  author:	John R. Douceur
 *  date:	26 January 1998
 *
 *  This source file provides functions that implement assignment, release, and
 *  dereferencing operations with a handle_factory.  The code is object-oriented
 *  C, transliterated from a C++ implementation.
 *
 *  The handle factory is a component that generates and validates handles.  It
 *  is intended to be used in a software module that provides client software
 *  modules with means to refer to information structures contained within the
 *  provider.  While such a means could simply be a pointer, this would not
 *  enable the deletion of the information structures without explicitly
 *  notifying the clients of such deletion.  Unlike pointers, the handles
 *  generated by the handle factory can be examined (by the handle factory)
 *  to determine their validity.
 *
 *  Handles can be invalidated in one of two ways.  The handle can be released
 *  by calling the release_HF_handle() function, indicating to the handle
 *  factory that the handle is no longer necessary and that future requests
 *  to dereference this handle should be met with a null pointer.  Alternately,
 *  the handle can be revoked by the handle factory; this will happen unter two
 *  circumstances.  If a large number of handles (more than four billion) are
 *  issued and subsequently released, it becomes necessary to reuse portions of
 *  the handle space for future assignments; under these circumstances, very
 *  old handles will be revoked well before this recycling occurs, to give the
 *  holders of those handles ample opportunity to notice that their handles
 *  have become invalid and to request new handles.  The other situation in
 *  which revokation can occur is if the amount of available memory becomes
 *  too small to allocate additional space to expand the handle database; then,
 *  if the assignment of a new handle is requested, the least-recently-assigned
 *  handle will be revoked to make room for the new request.
 *
 *  Use of the handle factory in a multi-threaded environment requires a lock.
 *  This lock must be taken by a single thread for the execution of either
 *  assign_HF_handle() or release_HF_handle().  Use of dereference_HF_handle()
 *  does not require taking a lock, since synchronization is handled internally
 *  through careful sequencing of read and write operations.
 *
 *  None of the code or comments in this file need to be understood by writers
 *  of client code; all explanatory information for clients is found in the
 *  associated header file, handfact.h.
 *
 */

#include "precomp.h"

/*
 *  There are a number of aspects to the handle factory that must be understood
 *  by anyone wishing to modify this code.  The description in this comment
 *  block is intended to provide a progressive overview of the handle factory.
 *
 *  The basic system comprises a table of entries.  Each assigned handle
 *  corresponds to a single, unique entry, as determined by the handle value
 *  modulo the table size.  A handle is validated by comparing the handle value
 *  to the stored handle value in the entry.  The unassigned entries are kept
 *  on a list; when an entry is released (or revoked), it is put on the tail of
 *  the list, and when an entry is needed for an assignment, it is taken from
 *  the head of the list.
 *
 *  If there are no unassigned entries in the table when a new handle is
 *  requested, a new table of twice the size is allocated, and all assigned
 *  handles are relocated to the new table.  All unassigned handles in the new
 *  table are placed on the unassigned list.
 *
 *  As handles are released, the space required for handle entries is reduced.
 *  The table can be contracted into a table of half the size if no two assigned
 *  handles will yield the same entry address.  Two handles which will yield
 *  the same entry address in a half-size table are called a pair, and the
 *  number of such pairs is tracked in the variable pair_count, which must be
 *  zero in order to contract the table.  In order to minimize the number of
 *  pairs in the table, there are actually two lists of unassigned entries.
 *  Assigning an entry from the primary list will not increase the pair count,
 *  whereas assigning an entry from the secondary list will increase the pair
 *  count.  Thus, assignments are always made from the primary list, if it is
 *  not empty.
 *
 *  Assigned handles are also kept on a list, in order of assignment.  If it
 *  becomes necessary to revoke a handle to make room for another, the oldest
 *  handle will be revoked, and it will be found at the head of this list.
 *
 */

// This macro allocates an array of HFEntry structures.  The size of the array
// is provided as an argument to the macro.
//
#define NEW_HFEntry_array(array_size) \
	((HFEntry *)malloc(array_size * sizeof(HFEntry)))

// This macro allocates an array of integers.  The size of the array is
// provided as an argument to the macro.
//
#define NEW_int_array(array_size) \
	((int *)malloc(array_size * sizeof(int)))

/*
 *  Following are prototypes for static functions that are used internally by
 *  the handle factory routines.
 *
 */

// This function doubles the size of the table in which the handles and pointers
// are stored.  It is called by assign_HF_handle() when there is insufficient
// space in the table to assign the newly requested handle.  If the expansion
// is successful, the function returns a value of 0.  If the expansion fails
// (due, for example, to an inability to allocate memory), the function returns
// a value of 1.
//
int expand_HF_table(
	HandleFactory *hfact);

// This function halves the size of the table in which the handles and pointers
// are stored.  In order to reduce the amount of space consumed by the handle
// factory, this function is called called by release_HF_handle() and
// revoke_ancient_HF_handles() when they determine that the table can and should
// be contracted.  The table can be contracted when pair_count == 0 and
// table_size > 2.  However, the table may not be contracted then, because
// hysteresis is employed both to keep the mean assignment and release times
// constant and to minimize the allocation chatter of rapidly expanding and
// contracting the table.  If the contraction is successful, the function
// returns a value of 0.  If the contraction fails, the function returns a
// value of 1.
//
int contract_HF_table(
	HandleFactory *hfact);

// This function revokes handles that are between handle_base and handle_base
// + 2 * HANDLE_RANGE_STEP - 1, inclusive.  It then increments the value of
// handle_base by HANDLE_RANGE_STEP.  Suspended handles will be revoked one
// revokation pass later than non-suspended handles.
//
void revoke_ancient_HF_handles(
	HandleFactory *hfact);

// Every entry is on one of three lists, and the heads and tails of these lists
// are maintained in the entry_list[] array.  The index of this array is given
// by the following three manifest constants.
//
#define LD_PRIMARY 0       // first list from which to select an entry to assign
#define LD_SECONDARY 1    // second list from which to select an entry to assign
#define LD_ASSIGNED 2    // list of assigned entries, in order of assignment age

// When the handle space is recycled, there is a danger of handle collisions.
// In order to substantially reduce the likelihood of these collisions, very
// old handles are revoked well before their recycling begins, to give the
// holders of these handles ample opportunity to notice that their handles
// have become invalid and to request new handles.  Thus, handles are revoked
// when they become more than MAX_HANDLE_RANGE less than the currently generated
// handles.  To reduce overhead, revokations are performed in batches of size
// determined by HANDLE_RANGE_STEP.
//
// A handle may be suspended by incrementing the handle value by
// HANDLE_RANGE_STEP.  This causes the comparison in dereference_HF_handle() to
// fail, so the handle is judged to be invalid.  To reinstate the handle, the
// handle value is decremented by HANDLE_RANGE_STEP, returning the handle to its
// original value.  A handle that is suspended will be revoked one revokation
// pass later than it would have been if it hadn't been suspended.
//
#define HANDLE_RANGE_STEP ((HFHandle)0x20000000)
#define MAX_HANDLE_RANGE ((HFHandle)0x90000000)

// To keep the mean assignment and release times constant (and, indirectly, to
// minimize the allocation chatter of rapidly expanding and contracting the
// table), the table is not necessarily contracted as soon as possible.
// Hysteresis is employed to postpone the contraction until the computational
// cost of previous expansions and contractions is distributed over a sufficient
// number of assignment or release operations to maintain a constant cost per
// operation ratio.  The cost of each expansion is equal to the overhead of
// memory allocation and deallocation plus the cost to split each entry into
// two entries.  The cost of each contraction is equal to the overhead of
// memory allocation and deallocation plus the cost to merge each pair of
// entries into one entry.  The cost of memory allocation and deallocation is
// equal to ALLOCATION_COST times the mean cost of a single split or merge
// operation.  This value was determined by empirical measurement.
//
#define ALLOCATION_COST 12

// This manifest constant is used by the expand and contract routines to request
// access to a set of table_size and entries variables.  It is subtracted from
// the appropriate sync variable.  If there are ever more than SYNC_SUBTRAHEND
// threads simultaneously invoking dereference_HF_handle{), then the
// synchronization logic will break.
//
#define SYNC_SUBTRAHEND 1000000000

// Since this is not C++, the HandleFactory structure is not self-constructing;
// therefore, the following constructor code must be called on the HandleFactory
// structure after it is allocated.  If the construction is successful, the
// function returns a value of 0.  If the construction fails (due, for example,
// to an inability to allocate memory), the function returns a value of 1.
//
int
constructHandleFactory(
	HandleFactory *hfact)
{
	int table_size;
	HFEntry *entries;

	// The table size is initially set to 2, and it will never be smaller.
	table_size = 2;
	// Allocate space for the initial table.
	entries = NEW_HFEntry_array(table_size);
	if (entries == 0)
	{
		// Memory could not be allocated for the array of entries created by
		// the constructor.  Therefore, we return an indication of failure to
		// the client.
		return 1;
	}
	// Initially, both sets of the table_size and entries variables are set
	// equal.  They will match most of the time except during the very brief
	// moments when the table size is changed during an expansion or
	// contraction.
	hfact->table_size[0] = table_size;
	hfact->entries[0] = entries;
	hfact->table_size[1] = table_size;
	hfact->entries[1] = entries;
	// The sync variables are initialized to zero.  These variables are
	// incremented by the dereference_HF_handle() routine to request access to
	// the corresponding table_size and entries variables.  They are massively
	// decremented (by a value of SYNC_SUBTRAHEND) by the expansion and
	// contraction routines to request permission to change the corresponding
	// table_size and entries variables.  If a sync variable is positive, then
	// at least one thread using the dereference routine has access to the
	// corresponding table_size and entries variables.  If a sync variable
	// equals -SYNC_SUBTRAHEND, then the expand or contract routine has access
	// to the corresponding variables.  A zero value means no one has requested
	// access, and a negative value greater than -SYNC_SUBTRAHEND means that
	// the expand or contract routine has requested access but has to wait
	// for one or more dereference threads to finish access.
	hfact->sync[0] = 0;
	hfact->sync[1] = 0;
	// Initially, the default variable set is set to zero.  This is arbitrary;
	// it could be set to one, instead.
	hfact->varset = 0;
	hfact->handle_base = 0;                         // handles will start with 0
	hfact->population = 0;                      // no handles initially assigned
	hfact->pair_count = 0;                // since no assigned handles, no pairs
	hfact->hysteresis_debt = 0;
	// Initialize the two entries that are initially allocated.  Both are marked
	// as unassigned; the larger value (2) is put on the secondary list, and the
	// smaller value (1) on the secondary list.  Record 0 contains an initial
	// handle value of 2 instead of 0 because a handle value of 0 is reserved.
	entries[0].handle = hfact->handle_base + table_size;
	entries[0].next_handle = hfact->handle_base + table_size;
	entries[0].reference = 0;
	entries[0].next_entry = &hfact->entry_list[LD_SECONDARY];
	entries[0].prev_entry = &hfact->entry_list[LD_SECONDARY];
	entries[1].handle = hfact->handle_base + 1;
	entries[1].next_handle = hfact->handle_base + 1;
	entries[1].reference = 0;
	entries[1].next_entry = &hfact->entry_list[LD_PRIMARY];
	entries[1].prev_entry = &hfact->entry_list[LD_PRIMARY];
	// Initialize the primary list.  This list initially contains entry 1.
	hfact->entry_list[LD_PRIMARY].handle = 0;
	hfact->entry_list[LD_PRIMARY].next_handle = 0;
	hfact->entry_list[LD_PRIMARY].reference = 0;
	hfact->entry_list[LD_PRIMARY].next_entry = &entries[1];
	hfact->entry_list[LD_PRIMARY].prev_entry = &entries[1];
	// Initialize the secondary list.  This list initially contains entry 0.
	hfact->entry_list[LD_SECONDARY].handle = 0;
	hfact->entry_list[LD_SECONDARY].next_handle = 0;
	hfact->entry_list[LD_SECONDARY].reference = 0;
	hfact->entry_list[LD_SECONDARY].next_entry = &entries[0];
	hfact->entry_list[LD_SECONDARY].prev_entry = &entries[0];
	// Initialize the assigned list.  This list initially is empty.
	hfact->entry_list[LD_ASSIGNED].handle = 0;
	hfact->entry_list[LD_ASSIGNED].next_handle = 0;
	hfact->entry_list[LD_ASSIGNED].reference = 0;
	hfact->entry_list[LD_ASSIGNED].next_entry = &hfact->entry_list[LD_ASSIGNED];
	hfact->entry_list[LD_ASSIGNED].prev_entry = &hfact->entry_list[LD_ASSIGNED];
	// Reduce handle_base by HANDLE_RANGE_STEP so that suspended handles will
	// not slip through revokation.
	hfact->handle_base -= HANDLE_RANGE_STEP;
	// return an indication of success to the client.
	return 0;
}

// Since this is not C++, the HandleFactory structure is not self-destructing;
// therefore, the following destructor code must be called on the HandleFactory
// structure before it is deallocated.
//
void
destructHandleFactory(
	HandleFactory *hfact)
{
	// Free the space consumed by the table of handles.
	free(hfact->entries[hfact->varset]);
}

// This function generates a new handle value, associates the handle value with
// the provided reference pointer, and returns the handle value.  Barring
// highly unusual circumstances, this handle will remain valid until it is
// explicitly released by a call to release_HF_handle().  However, there is no
// guarantee that the handle will persist for an arbitrary duration; it may
// become necessary for the handle factory to revoke the handle under some
// circumstances, particularly when the handle becomes very old or when memory
// becomes scarce.
//
// The assign_HF_handle() function will never return a handle value of zero.
// Thus, the client program is free to use a zero handle value as an escape
// indicator, if desired.
//
// In a multi-threaded environment, a single thread must take a lock prior to
// calling this function, and this must be the same lock taken before calling
// release_HF_handle().
//
HFHandle
assign_HF_handle(
	HandleFactory *hfact,
	void *reference)
{
	int table_size;
	int list;
	HFEntry *entry;
	volatile HFEntry *seq_entry;                // volatile to ensure sequencing
	HFHandle handle;
	HFHandle handle_range;

	table_size = hfact->table_size[hfact->varset];
	if (hfact->population >= table_size)
	{
		// All entries in the table are assigned, so it is necessary to
		// increase the table size.
		int expansion_failure = expand_HF_table(hfact);
		// Update the local value of table_size to reflect the new value.
		table_size = hfact->table_size[hfact->varset];
		if (expansion_failure)
		{
			// Expanding the table failed, presumably due to inability to
			// allocate sufficient memory.  So, instead, we revoke the least-
			// recently assigned handle.  First, remove the entry from the
			// assigned list and place it on the secondary list.
			entry = hfact->entry_list[LD_ASSIGNED].next_entry;
			entry->next_entry->prev_entry = &hfact->entry_list[LD_ASSIGNED];
			hfact->entry_list[LD_ASSIGNED].next_entry = entry->next_entry;
			entry->next_entry = &hfact->entry_list[LD_SECONDARY];
			entry->prev_entry = hfact->entry_list[LD_SECONDARY].prev_entry;
			hfact->entry_list[LD_SECONDARY].prev_entry->next_entry = entry;
			hfact->entry_list[LD_SECONDARY].prev_entry = entry;
			// Then, invalidate the handle.  The order of the operations is
			// important to correct multi-threaded operation.
			seq_entry = entry;
			seq_entry->handle = entry->next_handle;   // first invalidate handle
			seq_entry->reference = 0;                    // then clear reference
			// Decrement the pair count and population, so that when they are
			// incremented in the code below, they will have correct values.
			hfact->pair_count--;
			hfact->population--;
		}
	}
	// At this point, there is at least one available entry.  If there is any
	// entry on the primary list, it should be selected.
	list = LD_PRIMARY;
	if (hfact->entry_list[LD_PRIMARY].next_entry ==
		&hfact->entry_list[LD_PRIMARY])
	{
		// The primary list is empty, so we take from the secondary list.  By
		// definition, this will increase the pair count.
		list = LD_SECONDARY;
		hfact->pair_count++;
	}
	// Remove the entry from the head of the appropriate list and place it on
	// the assigned list.
	entry = hfact->entry_list[list].next_entry;
	handle = entry->handle;
	entry->next_entry->prev_entry = entry->prev_entry;
	entry->prev_entry->next_entry = entry->next_entry;
	entry->next_entry = &hfact->entry_list[LD_ASSIGNED];
	entry->prev_entry = hfact->entry_list[LD_ASSIGNED].prev_entry;
	hfact->entry_list[LD_ASSIGNED].prev_entry->next_entry = entry;
	hfact->entry_list[LD_ASSIGNED].prev_entry = entry;
	// Set the reference pointer to that provided as an argument.
	entry->reference = reference;
	// The next handle for this entry will be greater by the table size.  It
	// is important to set this value in this routine because unequal values of
	// handle and next_handle indicate an assigned entry.
	entry->next_handle = handle + table_size;
	if (entry->next_handle == 0)
	{
		// The handle value has wrapped around back to zero; however, zero is
		// a reserved value, so we instead set the next handle to the subsequent
		// legal value, which is the table size.
		entry->next_handle = table_size;
	}
	// The population has increased by one.
	hfact->population++;
	// We're being tricky with unsigned integer math here.  We revoke ancient
	// handles if the value of the handle we are currently issuing is greater
	// than the handle base by more than MAX_HANDLE_RANGE, modulo the size of
	// the handle space.  The modulo is implicit.
	handle_range = handle - hfact->handle_base;
	if (handle_range > MAX_HANDLE_RANGE)
	{
		revoke_ancient_HF_handles(hfact);
	}
	// This assignment operation decreases the hysteresis debt.
	if (hfact->hysteresis_debt > 0)
	{
		hfact->hysteresis_debt--;
	}
	// Return the newly assigned handle.
	return handle;
}

// This function releases a handle, indicating that further attempts to
// dereference the handle should result in a null pointer value rather than the
// pointer value that was originally assigned to the handle.  The handle factory
// checks the validity of the handle and returns a corresponding status code.
// If the handle is currently assigned, then it is released, and the function
// returns a value of 0.  If the handle is not currently assigned, the function
// aborts and returns a value of 1.
//
// In a multi-threaded environment, a single thread must take a lock prior to
// calling this function, and this must be the same lock taken before calling
// assign_HF_handle().
//
int
release_HF_handle(
	HandleFactory *hfact,
	HFHandle handle)
{
	int table_size;
	HFEntry *entries;
	int entry_index;
	HFEntry *entry;
	HFEntry *other_entry;
	int list;
	HFHandle adjusted_next_handle;
	HFHandle adjusted_other_next_handle;
	volatile HFEntry *seq_entry;                // volatile to ensure sequencing

	table_size = hfact->table_size[hfact->varset];
	entries = hfact->entries[hfact->varset];
	// Compute the index of the entry by taking the handle value modulo the
	// table size.  Since the table size is a power of two, we can simply
	// subtract one to produce a mask and then conjoin the mask with the
	// handle value.
	entry_index = handle & table_size - 1;
	entry = &entries[entry_index];
	if ((entry->handle != handle && entry->handle != handle + HANDLE_RANGE_STEP)
		|| entry->handle == entry->next_handle)
	{
		// Either the indexed entry does not refer to the provided handle nor to
		// the provided handle's suspension value, or the entry is unassigned.
		// In any of these cases, abort and return an error code to the client.
		return 1;
	}
	// The "other entry" is the entry that would have to be merged with the
	// indexed entry if the table size were to be contracted in half.
	other_entry = &entries[entry_index ^ table_size / 2];
	if (other_entry->handle == other_entry->next_handle)
	{
		// We're being tricky with unsigned integer math here.  Before comparing
		// the two next handles, we subtract from each the value of handle_base,
		// modulo the size of the handle space (the modulo is implicit).  This
		// allows the effective comparison of their logical acyclic values
		// rather than their actual cyclic values.
		adjusted_next_handle = entry->next_handle - hfact->handle_base;
		adjusted_other_next_handle =
			other_entry->next_handle - hfact->handle_base;
		if (adjusted_other_next_handle < adjusted_next_handle)
		{
			// The other entry is unassigned and has a smaller handle value
			// than the indexed entry.  Thus, the other entry should be moved
			// from the secondary list to the primary list, and the indexed
			// entry should be placed on the secondary list.
			other_entry->next_entry->prev_entry = other_entry->prev_entry;
			other_entry->prev_entry->next_entry = other_entry->next_entry;
			other_entry->next_entry = &hfact->entry_list[LD_PRIMARY];
			other_entry->prev_entry = hfact->entry_list[LD_PRIMARY].prev_entry;
			hfact->entry_list[LD_PRIMARY].prev_entry->next_entry = other_entry;
			hfact->entry_list[LD_PRIMARY].prev_entry = other_entry;
			list = LD_SECONDARY;
		}
		else
		{
			// The other entry is unassigned and has a larger handle value
			// than the indexed entry.  Thus, the indexed entry should be
			// placed on the secondary list.
			list = LD_PRIMARY;
		}
	}
	else
	{
		// The other entry is assigned.  Thus, the indexed entry should be
		// placed on the secondary list.  Also, since the two entries were
		// both assigned, they formed a pair.  Since we are releasing one of
		// them, the pair count drops by one.
		list = LD_SECONDARY;
		hfact->pair_count--;
	}
	// Remove the entry from the assigned list and place it on the
	// appropriate list.
	entry->next_entry->prev_entry = entry->prev_entry;
	entry->prev_entry->next_entry = entry->next_entry;
	entry->next_entry = &hfact->entry_list[list];
	entry->prev_entry = hfact->entry_list[list].prev_entry;
	hfact->entry_list[list].prev_entry->next_entry = entry;
	hfact->entry_list[list].prev_entry = entry;
	// Invalidate the handle.  The order of the operations is important to
	// correct multi-threaded operation.
	seq_entry = entry;
	seq_entry->handle = entry->next_handle;           // first invalidate handle
	seq_entry->reference = 0;                            // then clear reference
	// The population has decreased by one.
	hfact->population--;
	// This release operation decreases the hysteresis debt.
	if (hfact->hysteresis_debt > 0)
	{
		hfact->hysteresis_debt--;
	}
	// To contract the table, there must be no pairs, because otherwise two
	// assigned handles would yield the same entry index and thereby conflict.
	// Furthermore, the table size must be greater than 2, because much of the
	// handle factory code assumes that the table is at least of size 2.  In
	// addition to these strict requirements, hysteresis is employed both to
	// keep the mean assignment and release times constant and to minimize the
	// allocation chatter of rapidly expanding and contracting the table.  Only
	// if the hysteresis debt is zero will the table be contracted.
	if (hfact->pair_count == 0 && table_size > 2 &&
		hfact->hysteresis_debt == 0)
	{
		contract_HF_table(hfact);
		// Note that we ignore the return code.  If the contraction is
		// unsuccessful, we just continue as usual.  There is no real harm in
		// not contracting the table, except that we consume more space than
		// necessary.
	}
	// return an indication of success to the client.
	return 0;
}

// This function suspends a handle, indicating that further attempts to
// dereference the handle should result in a null pointer value rather than the
// pointer value that was originally assigned to the handle, unless and until
// reinstate_HF_handle() is called on the handle value.  The handle factory
// checks the validity of the handle and returns a corresponding status code.
// If the handle is currently assigned and not suspended, then it is suspended,
// and the function returns a value of 0.  If the handle is not currently
// assigned or has already been suspended, the function aborts and returns a
// value of 1.
//
// In a multi-threaded environment, a single thread must take a lock prior to
// calling this function, and this must be the same lock taken before calling
// assign_HF_handle(), release_HF_handle(), and reinstate_HF_handle().
//
int
suspend_HF_handle(
	HandleFactory *hfact,
	HFHandle handle)
{
	int table_size;
	HFEntry *entries;
	int entry_index;
	HFEntry *entry;

	table_size = hfact->table_size[hfact->varset];
	entries = hfact->entries[hfact->varset];
	// Compute the index of the entry by taking the handle value modulo the
	// table size.  Since the table size is a power of two, we can simply
	// subtract one to produce a mask and then conjoin the mask with the
	// handle value.
	entry_index = handle & table_size - 1;
	entry = &entries[entry_index];
	if (entry->handle != handle || entry->handle == entry->next_handle)
	{
		// Either the indexed entry does not refer to the provided handle, or
		// the entry is unassigned.  In either case, abort and return an error
		// code to the client.
		return 1;
	}
	// Suspend the handle.
	entry->handle += HANDLE_RANGE_STEP;
	// This suspension operation decreases the hysteresis debt.
	if (hfact->hysteresis_debt > 0)
	{
		hfact->hysteresis_debt--;
	}
	// return an indication of success to the client.
	return 0;
}

// This function reinstates a suspended handle, indicating that further attempts
// to dereference the handle should result in the pointer value that was
// originally assigned to the handle, rather than the null pointer value to
// which a suspended handle dereferences.  The handle factory checks the
// validity of the handle and returns a corresponding status code. If the handle
// is currently assigned and suspended, then it is reinstated, and the function
// returns a value of 0.  If the handle is not currently assigned or is not
// suspended, the function aborts and returns a value of 1.
//
// In a multi-threaded environment, a single thread must take a lock prior to
// calling this function, and this must be the same lock taken before calling
// assign_HF_handle(), release_HF_handle(), and suspend_HF_handle().
//
int
reinstate_HF_handle(
	HandleFactory *hfact,
	HFHandle handle)
{
	int table_size;
	HFEntry *entries;
	int entry_index;
	HFEntry *entry;

	table_size = hfact->table_size[hfact->varset];
	entries = hfact->entries[hfact->varset];
	// Compute the index of the entry by taking the handle value modulo the
	// table size.  Since the table size is a power of two, we can simply
	// subtract one to produce a mask and then conjoin the mask with the
	// handle value.
	entry_index = handle & table_size - 1;
	entry = &entries[entry_index];
	if (entry->handle != handle + HANDLE_RANGE_STEP ||
		entry->handle == entry->next_handle)
	{
		// Either the indexed entry does not refer to the provided handle's
		// suspension value, or the entry is unassigned.  In either case, abort
		// and return an error code to the client.
		return 1;
	}
	// Reinstate the handle.
	entry->handle -= HANDLE_RANGE_STEP;
	// This reinstatement operation decreases the hysteresis debt.
	if (hfact->hysteresis_debt > 0)
	{
		hfact->hysteresis_debt--;
	}
	// return an indication of success to the client.
	return 0;
}

// This function validates a handle and returns either the associated pointer
// (if the handle is valid) or a null pointer value (if the handle is invalid).
// If the handle has not been released but a null value is returned, then the
// handle has been revoked by the handle factory.  This is expected to be a
// highly unusual occurrence; however, since it can happen, any program that
// employs the handle factory must have some auxiliary mechanism for retrieving
// the desired pointer information.  Once the pointer is retrieved through this
// (presumably expensive) auxiliary means, a new handle can be reassigned to
// the pointer by another call to assign_HF_handle().
//
// Even in a multi-threaded environment, it is not necessary to take a lock
// prior to calling this function.  Careful sequencing of read and write
// operations inside the handle factory code obviates the need to explicitly
// lock the data structure for dereferencing handles.
//
void *
dereference_HF_handle(
	HandleFactory *hfact,
	HFHandle handle)
{
	HFHandle entry_handle;
	void *reference;
	int entry_index;
	volatile HFEntry *entry;                    // volatile to ensure sequencing
	LONG sync;
	int varset;
    int loopcount = 0;

	// This loop spins until one of the sync variables passes the interlocked
	// increment with a non-negative value, indicating that the corresponding
	// data values are valid.  There is a very short sequence of instructions
	// in the expand and contract routines that modifies the values of the
	// entries and table_size variables and also frees memory, and these
	// modifications are bracketed by massive interlocked changes to the
	// associated sync variables.  The loop should rarely be entered, since
	// the modification in the other routines is so short.  The loop should
	// almost never be execute more than once, because this would require two
	// invokations of expand or contract during this short function.
	//
	// Start with the default variable set.
	// If we read hfact->varset at the same instant that another thread is
	// writing it, we should get either the old value or the new value, either
	// of which will work fine in the following code.  We should never get a
	// garbage value, but just to be safe, we clear all bits other than the
	// LSB, to ensure that the value we use is valid.
	varset = hfact->varset & 1;
	// Indicate intention to access table_size and entries.
	sync = InterlockedIncrement(&hfact->sync[varset]);
    loopcount = 0;

	while (sync < 0)
	{
		// We incremented the sync variable after the expand or contract
		// routine massively decremented it, so we can not be sure that we
		// have access to the table_size and entries variables.  Thus, we
		// indicate that we are no longer interested in accessing these
		// variables.
		InterlockedDecrement(&hfact->sync[varset]);
		// Since we didn't get access to the table_size and entries variables,
		// we try accessing the other set.
		varset = 1 - varset;
		sync = InterlockedIncrement(&hfact->sync[varset]);
        loopcount++;

	}

    if (loopcount > 2) {
        OutputDebugString(TEXT("Loopcount in deref was > 2 - how bizzare!\n"));
        DEBUGBREAK();
    }
	// We incremented the sync variable before the expand or contract routine
	// massively decremented it, so we have access to the table_size and
	// entries variables.
	//
	// Compute the index of the entry by taking the handle value modulo the
	// table size.  Since the table size is a power of two, we can simply
	// subtract one to produce a mask and then conjoin the mask with the
	// handle value.
	entry_index = handle & hfact->table_size[varset] - 1;
	entry = &hfact->entries[varset][entry_index];
	// Get local copies of the reference pointer and handle value.  The order
	// of the operations is important to correct multi-threaded operation.
	reference = entry->reference;                         // first get reference
	entry_handle = entry->handle;           // then get handle to check validity
	// Indicate that we're done with table_size and entries
	InterlockedDecrement(&hfact->sync[varset]);
	if (entry_handle == handle)
	{
		// The stored handle matches the provided handle, so the latter is
		// valid.  We thus return the reference pointer.
		return reference;
	}
	else
	{
		// The stored handle does not match the provided handle, so the latter
		// is invalid.  We thus return a null pointer.
		return 0;
	}
}

#ifdef _TEST_HANDFACT

// This is a test routine that simply verifies the internal valididy of the
// handle factory's data structures.  By defining the constant _TEST_HANDFACT,
// this routine will be compiled and available to the client code.  It can be
// called at any time, unless running in a multi-threaded environment, in which
// case the caller must first take the same lock used for assign_HF_handle()
// and release_HF_handle.  If the routine returns any value other than zero,
// then the internal lists of records are in an inconsistent state.
//
int
verify_HF_lists(
	HandleFactory *hfact)
{
	int table_size;
	HFEntry *entries;
	int entry_count[3];
	int list;
	HFEntry *entry;

	table_size = hfact->table_size[hfact->varset];
	entries = hfact->entries[hfact->varset];
	for (list = 0; list < 3; list++)
	{
		entry_count[list] = 0;
		entry = &hfact->entry_list[list];
		do
		{
			entry_count[list]++;
			if (entry->next_entry->prev_entry != entry)
			{
				return 1;
			}
			entry = entry->next_entry;
		}	while (entry != &hfact->entry_list[list]);
		entry_count[list]--;
	}
	if (entry_count[2] != hfact->population)
	{
		return 2;
	}
	if (entry_count[0] + entry_count[2] - 2 * hfact->pair_count !=
		entry_count[1])
	{
		return 3;
	}
	if (entry_count[0] + entry_count[1] + entry_count[2] != table_size)
	{
		return 4;
	}
	return 0;
}

#endif /* _TEST_HANDFACT */

// This function doubles the size of the table in which the handles and pointers
// are stored.  It is called by assign_HF_handle() when there is insufficient
// space in the table to assign the newly requested handle.  If the expansion
// is successful, the function returns a value of 0.  If the expansion fails
// (due, for example, to an inability to allocate memory), the function returns
// a value of 1.
//
int expand_HF_table(
	HandleFactory *hfact)
{
	int table_size;
	HFEntry *entries;
	int double_size;
	HFEntry *new_entries;
	HFEntry *old_entries;
	HFEntry *old_entry;
	HFEntry *low_entry;
	HFEntry *high_entry;
	HFEntry *assigned_entry;
	HFEntry *secondary_entry;
	HFEntry *other_entry;
	HFHandle handle;
	HFHandle next_handle;
	HFHandle other_handle;
	void *reference;
	int other_entry_index;
	int index;
	int varset;
    DWORD   StartTick =0, EndTick = 0;

	table_size = hfact->table_size[hfact->varset];
	entries = hfact->entries[hfact->varset];
	// Expanded table is double the size of the old table.
	double_size = table_size * 2;
	// Allocate space for the expanded table.
	new_entries = NEW_HFEntry_array(double_size);
	if (new_entries == 0)
	{
		// Memory could not be allocated for the new array of entries.
		// Therefore, we return an indication of failure.
		return 1;
	}
	// Since we are doubling the table size, we will be treating one more bit
	// of each handle as a bit of the entry index.  The value of this bit
	// determines the index of the entry in the new table.  For each entry,
	// we have to determine the value of this bit and relocate the entry to
	// the indicated location.
	for (index = 0; index < table_size; index++)
	{
		old_entry = &entries[index];
		low_entry = &new_entries[index];
		high_entry = &new_entries[table_size + index];
		handle = old_entry->handle;
		next_handle = old_entry->next_handle;
		reference = old_entry->reference;
		// One of the two entries in the new table that correspond to the
		// indexed entry in the old table will have a next handle value equal
		// to the next handle value of the entry in the old table, and one will
		// have a handle value equal to the indexed entry's next handle plus
		// the old table size.
		other_handle = next_handle + table_size;
		if (other_handle == 0)
		{
			// The handle value has wrapped around back to zero; however, zero
			// is a reserved value, so we instead set the next handle to the
			// subsequent legal value, which is the new table size.
			other_handle = double_size;
		}
		if ((handle & table_size) == 0)
		{
			// The handle of the old entry has a zero in its next bit, so the
			// old entry will be located in the lower half of the new table.
			if ((next_handle & table_size) == 0)
			{
				// The next handle of the old entry has a zero in its next bit,
				// so this value will be the next handle for the lower entry
				// and the other next handle value will be the next handle
				// value for the higher entry.  The high entry handle is set
				// equal to its next handle because it is unassigned.
				high_entry->handle = other_handle;
				high_entry->next_handle = other_handle;
				low_entry->next_handle = next_handle;
			}
			else
			{
				// The next handle of the old entry has a zero in its next bit,
				// so this value will be the next handle for the higher entry
				// and the other next handle value will be the next handle
				// value for the lower entry.  The high entry handle is set
				// equal to its next handle because it is unassigned.
				high_entry->handle = next_handle;
				high_entry->next_handle = next_handle;
				low_entry->next_handle = other_handle;
			}
			// The high entry is unassigned, so set its reference to null.
			// Copy the information from the old entry to the low entry.
			// Remove the old entry from the assigned list, and replace it
			// with the low entry.
			high_entry->reference = 0;
			low_entry->handle = handle;
			low_entry->reference = reference;
			old_entry->next_entry->prev_entry = low_entry;
			old_entry->prev_entry->next_entry = low_entry;
			low_entry->next_entry = old_entry->next_entry;
			low_entry->prev_entry = old_entry->prev_entry;
		}
		else
		{
			// The handle of the old entry has a one in its next bit, so the
			// old entry will be located in the higher half of the new table.
			if ((next_handle & table_size) == 0)
			{
				// The next handle of the old entry has a zero in its next bit,
				// so this value will be the next handle for the lower entry
				// and the other next handle value will be the next handle
				// value for the higher entry.  The low entry handle is set
				// equal to its next handle because it is unassigned.
				high_entry->next_handle = other_handle;
				low_entry->handle = next_handle;
				low_entry->next_handle = next_handle;
			}
			else
			{
				// The next handle of the old entry has a zero in its next bit,
				// so this value will be the next handle for the higher entry
				// and the other next handle value will be the next handle
				// value for the lower entry.  The low entry handle is set
				// equal to its next handle because it is unassigned.
				high_entry->next_handle = next_handle;
				low_entry->handle = other_handle;
				low_entry->next_handle = other_handle;
			}
			// The low entry is unassigned, so set its reference to null.
			// Copy the information from the old entry to the high entry.
			// Remove the old entry from the assigned list, and replace it
			// with the high entry.
			low_entry->reference = 0;
			high_entry->handle = handle;
			high_entry->reference = reference;
			old_entry->next_entry->prev_entry = high_entry;
			old_entry->prev_entry->next_entry = high_entry;
			high_entry->next_entry = old_entry->next_entry;
			high_entry->prev_entry = old_entry->prev_entry;
		}
	}
	// All of the unassigned entries in the new table will be placed on the
	// secondary list.  We loop through the assigned list and place the
	// unassigned entry corresponding each assigned entry onto the secondary
	// list.  Doing the list assignment in this manner tends to approximately
	// sort the secondary list according to handle value, since the assigned
	// list is sorted according to assignment order, and this approximately
	// correlates to the handle value.
	assigned_entry = hfact->entry_list[LD_ASSIGNED].next_entry;
	secondary_entry = &hfact->entry_list[LD_SECONDARY];
	while (assigned_entry != &hfact->entry_list[LD_ASSIGNED])
	{
		other_entry_index =
			assigned_entry->handle + table_size & double_size - 1;
		other_entry = &new_entries[other_entry_index];
		secondary_entry->next_entry = other_entry;
		other_entry->prev_entry = secondary_entry;
		secondary_entry = other_entry;
		assigned_entry = assigned_entry->next_entry;
	}
	// Wrap up lists by connecting in tails.
	secondary_entry->next_entry = &hfact->entry_list[LD_SECONDARY];
	hfact->entry_list[LD_SECONDARY].prev_entry = secondary_entry;
	// This expansion increases the hysteresis debt by the cost of one set of
	// allocation and deallocation operations plus the cost of splitting each
	// entry into two entries.
	hfact->hysteresis_debt += ALLOCATION_COST + table_size;
	// Save a pointer to the old entry table so that it can be deallocated.
	old_entries = entries;
	// Note that we have not modified the handle, next_handle, or reference
	// fields of any entries in the old table.  Therefore, any calls to the
	// dereference_HF_handle() routine that may have been made by other threads
	// during the above operations would have been performed successfully.
	// We are now about to increase the table size and update the entries
	// variable to point to the new table.  We do this by first updating the
	// alternate table_size and entries variables and then updating the standard
	// ones.  That way, there will always be one set that is correct, so that
	// dereferences can proceed relatively unimpeded.
	//
	// Our local varset is initialized to the non-default set.
	varset = 1 - hfact->varset;
	// Indicate that the non-default table_size and entries are becoming
	// inaccessible.
	InterlockedExchangeAdd(&hfact->sync[varset], -SYNC_SUBTRAHEND);
	// Wait until no dereferences to the non-default variables are in progress.
    StartTick = GetTickCount();

	while (hfact->sync[varset] > -SYNC_SUBTRAHEND)
	{
		// no-op or sleep
        if ((GetTickCount() - StartTick) > 300000000) {
            OutputDebugString(TEXT("Expand 1\n"));
            DEBUGBREAK();
        }
	}
	// Update non-default table_size and entries to new table.
	hfact->entries[varset] = new_entries;
	hfact->table_size[varset] = double_size;
	// Indicate that non-default table_size and entries are usable again.
	InterlockedExchangeAdd(&hfact->sync[varset], SYNC_SUBTRAHEND);
	// Make non-default table_size and entries the default set.
	hfact->varset = varset;
	// Update our local varset so it again indicates the non-default set.
	varset = 1 - varset;
	// Indicate that the non-default table_size and entries are becoming
	// inaccessible.
	InterlockedExchangeAdd(&hfact->sync[varset], -SYNC_SUBTRAHEND);
	// Wait until no dereferences to the non-default variables are in progress.
	while (hfact->sync[varset] > -SYNC_SUBTRAHEND)
	{
        
        if ((GetTickCount() - StartTick) > 300000000) {
            OutputDebugString(TEXT("Expand 2\n"));
            DEBUGBREAK();
        }
		
        // no-op or sleep
	}
	// Update non-default table_size and entries to new table.
	hfact->entries[varset] = new_entries;
	hfact->table_size[varset] = double_size;
	// Indicate that non-default table_size and entries are usable again.
	InterlockedExchangeAdd(&hfact->sync[varset], SYNC_SUBTRAHEND);
	// Deallocate the old table.
	free(old_entries);
	// Since the new table was created by expanding a half-size table, the pair
	// count must be zero.
	hfact->pair_count = 0;
	// return an indication of success.
	return 0;
}

// This function halves the size of the table in which the handles and pointers
// are stored.  In order to reduce the amount of space consumed by the handle
// factory, this function is called called by release_HF_handle() and
// revoke_ancient_HF_handles() when they determine that the table can and should
// be contracted.  The table can be contracted when pair_count == 0 and
// table_size > 2.  However, the table may not be contracted then, because
// hysteresis is employed both to keep the mean assignment and release times
// constant and to minimize the allocation chatter of rapidly expanding and
// contracting the table.  If the contraction is successful, the function
// returns a value of 0.  If the contraction fails, the function returns a
// value of 1.
//
int contract_HF_table(
	HandleFactory *hfact)
{
	int table_size;
	HFEntry *entries;
	HFEntry *new_entries;
	HFEntry *old_entries;
	int *list;
	int half_size;
	int quarter_size;
	int index;
	HFEntry *high_entry1;
	HFEntry *high_entry0;
	HFEntry *low_entry1;
	HFEntry *low_entry0;
	HFEntry *new_entry1;
	HFEntry *new_entry0;
	HFHandle adjusted_high_next_handle1;
	HFHandle adjusted_low_next_handle1;
	HFHandle next_handle1;
	HFHandle adjusted_high_next_handle0;
	HFHandle adjusted_low_next_handle0;
	HFHandle next_handle0;
	HFHandle adjusted_new_handle0;
	HFHandle adjusted_new_handle1;
	HFEntry *entry;
	HFEntry *primary_entry;
	HFEntry *secondary_entry;
	int varset;
    DWORD   StartTick = 0;

	table_size = hfact->table_size[hfact->varset];
	entries = hfact->entries[hfact->varset];
	// Contracted table is half the size of the old table.
	half_size = table_size / 2;
	quarter_size = half_size / 2;
	// Allocate space for the contracted table.
	new_entries = NEW_HFEntry_array(half_size);
	if (new_entries == 0)
	{
		// Memory could not be allocated for the new array of entries, so we
		// are ironically prevented from reducing the amount of memory that
		// the handle factory is consuming. Therefore, we return an indication
		// of failure.
		return 1;
	}
	// Allocate space for auxiliary array of list indicators
	list = NEW_int_array(half_size);
	if (list == 0)
	{
		// Memory could not be allocated for the auxiliary array, so again we
		// are ironically prevented from reducing the amount of memory that
		// the handle factory is consuming. Therefore, we return an indication
		// of failure.  First, however, we must free the memory allocated for
		// the new array of entries above.
		free(new_entries);
		return 1;
	}
	// Since we are halving the size of the table, it might seem reasonable to
	// loop through each index of the new table and merge the two corresponding
	// entries from the old table.  This is in fact what the following routine
	// does; however, it does it by looping through only half of the new indices
	// and processing two merges for each index.  It does this so that it can
	// then examine the two new entries to determine on which list to place each
	// of them.
	for (index = 0; index < quarter_size; index++)
	{
		// We're looking at four entries at once.  First we merge high_entry1
		// and low_entry1, and then we independently merge high_entry0 and
		// low_entry0.  After the two merges, we examine the results jointly.
		high_entry1 = &entries[half_size + quarter_size + index];
		high_entry0 = &entries[half_size + index];
		low_entry1 = &entries[quarter_size + index];
		low_entry0 = &entries[index];
		new_entry1 = &new_entries[quarter_size + index];
		new_entry0 = &new_entries[index];
		// When merging two entries, the next handle value for the combined
		// entry is equal to the larger next handle value of the two, minus
		// the new table size.  However, the determination of which is larger
		// must be made with respect to their logical acyclic values rather
		// than their actual cyclic values, so we subtract from each the value
		// of handle_base, modulo the size of the handle space.  The modulo is
		// implicit.
		adjusted_high_next_handle1 =
			high_entry1->next_handle - hfact->handle_base;
		adjusted_low_next_handle1 =
			low_entry1->next_handle - hfact->handle_base;
		next_handle1 = __max(adjusted_high_next_handle1,
			adjusted_low_next_handle1) + hfact->handle_base - half_size;
		// Since handle 1 is -- by definition -- in either the second or fourth
		// quarter of the table, there is no need to check for the reserved
		// value of zero.
		if (high_entry1->handle != high_entry1->next_handle)
		{
			// The high entry is assigned, so we copy its handle value and
			// reference pointer.  Also, we remove it from the assigned list
			// and replace it with the new entry.
			new_entry1->handle = high_entry1->handle;
			new_entry1->reference = high_entry1->reference;
			high_entry1->next_entry->prev_entry = new_entry1;
			high_entry1->prev_entry->next_entry = new_entry1;
			new_entry1->next_entry = high_entry1->next_entry;
			new_entry1->prev_entry = high_entry1->prev_entry;
		}
		else if (low_entry1->handle != low_entry1->next_handle)
		{
			// The low entry is assigned, so we copy its handle value and
			// reference pointer.  Also, we remove it from the assigned list
			// and replace it with the new entry.
			new_entry1->handle = low_entry1->handle;
			new_entry1->reference = low_entry1->reference;
			low_entry1->next_entry->prev_entry = new_entry1;
			low_entry1->prev_entry->next_entry = new_entry1;
			new_entry1->next_entry = low_entry1->next_entry;
			new_entry1->prev_entry = low_entry1->prev_entry;
		}
		else
		{
			// Neither entry is assigned, so we indicate an unassigned condition
			// in the new entry.
			new_entry1->handle = next_handle1;
			new_entry1->reference = 0;
			if (adjusted_high_next_handle1 < adjusted_low_next_handle1)
			{
				// The high entry next handle has a lesser value than the low
				// entry next handle, so the high entry must be on the primary
				// list.  We remove it from the primary list and replace it
				// with the new entry.
				high_entry1->next_entry->prev_entry = new_entry1;
				high_entry1->prev_entry->next_entry = new_entry1;
				new_entry1->next_entry = high_entry1->next_entry;
				new_entry1->prev_entry = high_entry1->prev_entry;
			}
			else
			{
				// The low entry next handle has a lesser value than the high
				// entry next handle, so the low entry must be on the primary
				// list.  We remove it from the primary list and replace it
				// with the new entry.
				low_entry1->next_entry->prev_entry = new_entry1;
				low_entry1->prev_entry->next_entry = new_entry1;
				new_entry1->next_entry = low_entry1->next_entry;
				new_entry1->prev_entry = low_entry1->prev_entry;
			}
		}
		// Set the next handle for the new entry.
		new_entry1->next_handle = next_handle1;
		// When merging two entries, the next handle value for the combined
		// entry is equal to the larger next handle value of the two, minus
		// the new table size.  However, the determination of which is larger
		// must be made with respect to their logical acyclic values rather
		// than their actual cyclic values, so we subtract from each the value
		// of handle_base, modulo the size of the handle space.  The modulo is
		// implicit.
		adjusted_high_next_handle0 =
			high_entry0->next_handle - hfact->handle_base;
		adjusted_low_next_handle0 =
			low_entry0->next_handle - hfact->handle_base;
		next_handle0 = __max(adjusted_high_next_handle0,
			adjusted_low_next_handle0) + hfact->handle_base - half_size;
		if (next_handle0 == 0)
		{
			// The handle value has wrapped around back to zero; however, zero
			// is a reserved value, so we instead set the next handle to the
			// subsequent legal value, which is the new table size.
			next_handle0 = half_size;
		}
		if (high_entry0->handle != high_entry0->next_handle)
		{
			// The high entry is assigned, so we copy its handle value and
			// reference pointer.  Also, we remove it from the assigned list
			// and replace it with the new entry.
			new_entry0->handle = high_entry0->handle;
			new_entry0->reference = high_entry0->reference;
			high_entry0->next_entry->prev_entry = new_entry0;
			high_entry0->prev_entry->next_entry = new_entry0;
			new_entry0->next_entry = high_entry0->next_entry;
			new_entry0->prev_entry = high_entry0->prev_entry;
		}
		else if (low_entry0->handle != low_entry0->next_handle)
		{
			// The low entry is assigned, so we copy its handle value and
			// reference pointer.  Also, we remove it from the assigned list
			// and replace it with the new entry.
			new_entry0->handle = low_entry0->handle;
			new_entry0->reference = low_entry0->reference;
			low_entry0->next_entry->prev_entry = new_entry0;
			low_entry0->prev_entry->next_entry = new_entry0;
			new_entry0->next_entry = low_entry0->next_entry;
			new_entry0->prev_entry = low_entry0->prev_entry;
		}
		else
		{
			// Neither entry is assigned, so we indicate an unassigned condition
			// in the new entry.
			new_entry0->handle = next_handle0;
			new_entry0->reference = 0;
			if (adjusted_high_next_handle0 < adjusted_low_next_handle0)
			{
				// The high entry next handle has a lesser value than the low
				// entry next handle, so the high entry must be on the primary
				// list.  We remove it from the primary list and replace it
				// with the new entry.
				high_entry0->next_entry->prev_entry = new_entry0;
				high_entry0->prev_entry->next_entry = new_entry0;
				new_entry0->next_entry = high_entry0->next_entry;
				new_entry0->prev_entry = high_entry0->prev_entry;
			}
			else
			{
				// The low entry next handle has a lesser value than the high
				// entry next handle, so the low entry must be on the primary
				// list.  We remove it from the primary list and replace it
				// with the new entry.
				low_entry0->next_entry->prev_entry = new_entry0;
				low_entry0->prev_entry->next_entry = new_entry0;
				new_entry0->next_entry = low_entry0->next_entry;
				new_entry0->prev_entry = low_entry0->prev_entry;
			}
		}
		// Set the next handle for the new entry.
		new_entry0->next_handle = next_handle0;
		// Now that we have merged high_entry1 and low_entry1 into new_entry1,
		// and independently merged high_entry0 and low_entry0 into new_entry0,
		// we examine the two new entries to determine on which list to place
		// each of them.  Note that we do not actually manipulate the lists in
		// this portion of the code; we merely make decisions and record these
		// decisions for the future.
		if (new_entry0->handle == new_entry0->next_handle &&
			new_entry1->handle == new_entry1->next_handle)
		{
			// Both new_entry0 and new_entry1 are unassigned, so one of them
			// belongs on the primary list and the other on the secondary list.
			// Which goes on which is determined by a comparison of their handle
			// values.  We're being tricky with unsigned integer math here.
			// Before comparing the two handles, we subtract from each the value
			// of handle_base, modulo the size of the handle space (the modulo
			// is implicit).  This allows the effective comparison of their
			// logical acyclic values rather than their actual cyclic values.
			adjusted_new_handle0 = new_entry0->handle - hfact->handle_base;
			adjusted_new_handle1 = new_entry1->handle - hfact->handle_base;
			if (adjusted_new_handle0 < adjusted_new_handle1)
			{
				// The handle value for new_entry0 is lower, so new_entry0
				// belongs on the primary list and new_entry1 on the secondary
				// list.  We indicate this decision in the list array.
				list[index] = LD_PRIMARY;
				list[quarter_size + index] = LD_SECONDARY;
			}
			else
			{
				// The handle value for new_entry1 is lower, so new_entry1
				// belongs on the primary list and new_entry0 on the secondary
				// list.  We indicate this decision in the list array.
				list[index] = LD_SECONDARY;
				list[quarter_size + index] = LD_PRIMARY;
			}
		}
		else
		{
			// Either new_entry0 or new_entry1 (or both) is assigned, and it is
			// therefore already on the assigned list.  If one of the entries
			// is not assigned, it belongs on the secondary list.  We indicate
			// this decision in both places of the list array, which is safe to
			// do since the assigned entry's list indicator will never be
			// examined.
			list[index] = LD_SECONDARY;
			list[quarter_size + index] = LD_SECONDARY;
		}
		if (new_entry0->handle != new_entry0->next_handle &&
			new_entry1->handle != new_entry1->next_handle)
		{
			// Both new_entry0 and new_entry1 are assigned, so they form a pair.
			// We thus increment the pair count.  Note that we never set the
			// pair count to zero above, but this was not necessary since the
			// table could not be contracted unless the pair count was zero.
			hfact->pair_count++;
		}
	}
	// At this point, the table has been completely contracted except for the
	// reassembly of the unassigned lists.  In the code above, any entries that
	// had previously been on the secondary list were merged with assigned
	// entries, so they are no longer relevant.  Only those entries that had
	// previously been (and are still) on the primary list will still be
	// unassigned.  We now loop through the primary list and place each list
	// element on the appropriate list, as indicated by the list array.  Doing
	// the list assignment in these two steps preserves the general order of
	// the entries, which has some value since they will tend to be partially
	// sorted.
	entry = hfact->entry_list[LD_PRIMARY].next_entry;
	primary_entry = &hfact->entry_list[LD_PRIMARY];
	secondary_entry = &hfact->entry_list[LD_SECONDARY];
	while (entry != &hfact->entry_list[LD_PRIMARY])
	{
		if (list[entry->handle & half_size - 1] == LD_PRIMARY)
		{
			// The list array indicates the primary list, so place the entry
			// onto the primary list.
			primary_entry->next_entry = entry;
			entry->prev_entry = primary_entry;
			primary_entry = entry;
		}
		else
		{
			// The list array indicates the secondary list, so place the entry
			// onto the secondary list.
			secondary_entry->next_entry = entry;
			entry->prev_entry = secondary_entry;
			secondary_entry = entry;
		}
		entry = entry->next_entry;
	}
	// Wrap up lists by connecting in tails.
	primary_entry->next_entry = &hfact->entry_list[LD_PRIMARY];
	hfact->entry_list[LD_PRIMARY].prev_entry = primary_entry;
	secondary_entry->next_entry = &hfact->entry_list[LD_SECONDARY];
	hfact->entry_list[LD_SECONDARY].prev_entry = secondary_entry;
	// This contraction increases the hysteresis debt by the cost of one set of
	// allocation and deallocation operations plus the cost of merging each
	// pair of entries into a single entry.
	hfact->hysteresis_debt += ALLOCATION_COST + half_size;
	// Save a pointer to the old entry table so that it can be deallocated.
	old_entries = entries;
	// Note that we have not modified the handle, next_handle, or reference
	// fields of any entries in the old table.  Therefore, any calls to the
	// dereference_HF_handle() routine that may have been made by other threads
	// during the above operations would have been performed successfully.
	// We are now about to increase the table size and update the entries
	// variable to point to the new table.  We do this by first updating the
	// alternate table_size and entries variables and then updating the standard
	// ones.  That way, there will always be one set that is correct, so that
	// dereferences can proceed relatively unimpeded.
	//
	// Our local varset is initialized to the non-default set.
	varset = 1 - hfact->varset;
	// Indicate that the non-default table_size and entries are becoming
	// inaccessible.
	InterlockedExchangeAdd(&hfact->sync[varset], -SYNC_SUBTRAHEND);
	// Wait until no dereferences to the non-default variables are in progress.
    StartTick = GetTickCount();

	while (hfact->sync[varset] > -SYNC_SUBTRAHEND)
	{
		

        if ((GetTickCount() - StartTick) > 300000000) {
            OutputDebugString(TEXT("Contract 1\n"));
            DEBUGBREAK();
        }

        // no-op or sleep
	}
	// Update non-default table_size and entries to new table.
	hfact->table_size[varset] = half_size;
	hfact->entries[varset] = new_entries;
	// Indicate that non-default table_size and entries are usable again.
	InterlockedExchangeAdd(&hfact->sync[varset], SYNC_SUBTRAHEND);
	// Make non-default table_size and entries the default set.
	hfact->varset = varset;
	// Update our local varset so it again indicates the non-default set.
	varset = 1 - varset;
	// Indicate that the non-default table_size and entries are becoming
	// inaccessible.
	InterlockedExchangeAdd(&hfact->sync[varset], -SYNC_SUBTRAHEND);
	// Wait until no dereferences to the non-default variables are in progress.
	while (hfact->sync[varset] > -SYNC_SUBTRAHEND)
	{
		// no-op or sleep
        if ((GetTickCount() - StartTick) > 300000000) {
            OutputDebugString(TEXT("Contract 2\n"));
            DEBUGBREAK();
        }
	}
	// Update non-default table_size and entries to new table.
	hfact->table_size[varset] = half_size;
	hfact->entries[varset] = new_entries;
	// Indicate that non-default table_size and entries are usable again.
	InterlockedExchangeAdd(&hfact->sync[varset], SYNC_SUBTRAHEND);
	// Deallocate the old table and the auxiliary list indicator array.
	free(old_entries);
	free(list);
	// return an indication of success.
	return 0;
}

// This function revokes handles that are between handle_base and handle_base
// + 2 * HANDLE_RANGE_STEP - 1, inclusive.  It then increments the value of
// handle_base by HANDLE_RANGE_STEP.  Suspended handles will be revoked one
// revokation pass later than non-suspended handles.
//
void revoke_ancient_HF_handles(
	HandleFactory *hfact)
{
	int table_size;
	HFEntry *entries;
	HFHandle new_handle_base;
	int half_size;
	int index;
	HFEntry *high_entry;
	HFEntry *low_entry;
	HFHandle adjusted_high_handle;
	HFHandle adjusted_low_handle;
	HFHandle adjusted_high_next_handle;
	HFHandle adjusted_low_next_handle;
	HFHandle handle;
	volatile HFEntry *seq_entry;                // volatile to ensure sequencing

	table_size = hfact->table_size[hfact->varset];
	entries = hfact->entries[hfact->varset];
	// Compute new handle base.
	new_handle_base = hfact->handle_base + HANDLE_RANGE_STEP;
	// It might seem reasonable to loop through each index of the table and
	// determine whether to revoke the handle of each entry.  This is in fact
	// what the following routine does; however, it does it by looping through
	// only half of the indices and examining two entries for each index.  It
	// does this so that it can compare the two entries to determine on which
	// list to place each of them.
	half_size = table_size / 2;
	for (index = 0; index < half_size; index++)
	{
		// We're looking at two entries at once.
		high_entry = &entries[half_size + index];
		low_entry = &entries[index];
		// We're being tricky with unsigned integer math here.  Before making
		// comparisons on either handle, we subtract from it the value of
		// handle_base, modulo the size of the handle space (the modulo is
		// implicit).  This allows the effective comparison of its logical
		// acyclic value rather than its actual cyclic value.
		adjusted_high_handle = high_entry->handle - hfact->handle_base;
		adjusted_low_handle = low_entry->handle - hfact->handle_base;
		if (adjusted_high_handle < 2 * HANDLE_RANGE_STEP ||
			adjusted_low_handle < 2 * HANDLE_RANGE_STEP)
		{
			// At least one of the handles is less than twice HANDLE_RANGE_STEP
			// more than the current handle base, so it will need to be updated.
			// For the vast majority of cases, this test is expected to fail,
			// and so all of the following work can be skipped.
			if (high_entry->handle != high_entry->next_handle &&
				low_entry->handle != low_entry->next_handle)
			{
				// Both of the entries are assigned, so, since at least one of
				// them will be revoked, we will be losing one pair.
				hfact->pair_count--;
			}
			if (high_entry->handle == high_entry->next_handle ||
				adjusted_high_handle < 2 * HANDLE_RANGE_STEP)
			{
				// Either the high entry is unassigned or in need of revokation
				// (after which it will be unassigned), so we remove it from
				// whatever list it is on.  We do this because all unassigned
				// entries will be added to the appropriate list below.
				high_entry->next_entry->prev_entry = high_entry->prev_entry;
				high_entry->prev_entry->next_entry = high_entry->next_entry;
				// Zeroing these pointers is unnecessary, but it will help to
				// catch any mistakes made further down.
				high_entry->next_entry = 0;
				high_entry->prev_entry = 0;
			}
			if (adjusted_high_handle < 2 * HANDLE_RANGE_STEP)
			{
				// The high handle needs to be updated.
				if (high_entry->handle != high_entry->next_handle)
				{
					// The high handle is assigned, so this updating will
					// revoke the handle.  Thus, we decrement the population.
					hfact->population--;
				}
				// Compute the handle value as the maximum of (1) the next
				// handle and (2) the new handle base plus the entry index.
				// We're being tricky with unsigned integer math here.  The
				// maximum involves partial decomposition of the sums, from
				// which we then subtract the value of handle_base, modulo the
				// size of the handle space (the modulo is implicit).  Thus,
				// the maximum is taken with respect to the logical acyclic
				// values rather than the actual cyclic values.
				adjusted_high_next_handle =
					high_entry->next_handle - hfact->handle_base;
				handle = __max(adjusted_high_next_handle,
					HANDLE_RANGE_STEP + half_size + index) + hfact->handle_base;
				// Since the high handle is -- by definition -- in the upper
				// half of the table, there is no need to check for the reserved
				// value of zero.
				// Update the handle value.  Since this updating will invalidate
				// the handle if it is currently assigned, the order of the
				// operations is important to correct multi-threaded operation.
				seq_entry = high_entry;
				seq_entry->next_handle = handle;
				seq_entry->handle = handle;           // first invalidate handle
				seq_entry->reference = 0;                // then clear reference
			}
			if (low_entry->handle == low_entry->next_handle ||
				adjusted_low_handle < 2 * HANDLE_RANGE_STEP)
			{
				// Either the low entry is unassigned or in need of revokation
				// (after which it will be unassigned), so we remove it from
				// whatever list it is on.  We do this because all unassigned
				// entries will be added to the appropriate list below.
				low_entry->next_entry->prev_entry = low_entry->prev_entry;
				low_entry->prev_entry->next_entry = low_entry->next_entry;
				// Zeroing these pointers is unnecessary, but it will help to
				// catch any mistakes made further down.
				low_entry->next_entry = 0;
				low_entry->prev_entry = 0;
			}
			if (adjusted_low_handle < 2 * HANDLE_RANGE_STEP)
			{
				// The low handle needs to be updated.
				if (low_entry->handle != low_entry->next_handle)
				{
					// The low handle is assigned, so this updating will
					// revoke the handle.  Thus, we decrement the population.
					hfact->population--;
				}
				// Compute the handle value as the maximum of (1) the next
				// handle and (2) the new handle base plus the entry index.
				// We're being tricky with unsigned integer math here.  The
				// maximum involves partial decomposition of the sums, from
				// which we then subtract the value of handle_base, modulo the
				// size of the handle space (the modulo is implicit).  Thus,
				// the maximum is taken with respect to the logical acyclic
				// values rather than the actual cyclic values.
				adjusted_low_next_handle =
					low_entry->next_handle - hfact->handle_base;
				handle = __max(adjusted_low_next_handle,
					HANDLE_RANGE_STEP + index) + hfact->handle_base;
				if (handle == 0)
				{
					// The handle value has wrapped around back to zero;
					// however, zero is a reserved value, so we instead set the
					// handle to the subsequent legal value, which is the table
					// size.
					handle = table_size;
				}
				// Update the handle value.  Since this updating will invalidate
				// the handle if it is currently assigned, the order of the
				// operations is important to correct multi-threaded operation.
				seq_entry = low_entry;
				seq_entry->next_handle = handle;
				seq_entry->handle = handle;           // first invalidate handle
				seq_entry->reference = 0;                // then clear reference
			}
			if (high_entry->handle != high_entry->next_handle)
			{
				// The high entry is still assigned, so the low entry belongs
				// on the secondary list.
				low_entry->next_entry = &hfact->entry_list[LD_SECONDARY];
				low_entry->prev_entry =
					hfact->entry_list[LD_SECONDARY].prev_entry;
				hfact->entry_list[LD_SECONDARY].prev_entry->next_entry =
					low_entry;
				hfact->entry_list[LD_SECONDARY].prev_entry = low_entry;
			}
			else if (low_entry->handle != low_entry->next_handle)
			{
				// The low entry is still assigned, so the high entry belongs
				// on the secondary list.
				high_entry->next_entry = &hfact->entry_list[LD_SECONDARY];
				high_entry->prev_entry =
					hfact->entry_list[LD_SECONDARY].prev_entry;
				hfact->entry_list[LD_SECONDARY].prev_entry->next_entry =
					high_entry;
				hfact->entry_list[LD_SECONDARY].prev_entry = high_entry;
			}
			else
			{
				// Neither entry is still assigned, so one entry belongs on the
				// primary list and one on the secondary list.  Which goes on
				// which is determined by a comparison of their handle values.
				// We're being tricky with unsigned integer math here.  Before
				// comparing the two handles, we subtract from each the value
				// of handle_base, modulo the size of the handle space (the
				// modulo is implicit).  This allows the effective comparison
				// of their logical acyclic values rather than their actual
				// cyclic values.
				adjusted_high_next_handle =
					high_entry->next_handle - new_handle_base;
				adjusted_low_next_handle =
					low_entry->next_handle - new_handle_base;
				if (adjusted_low_next_handle < adjusted_high_next_handle)
				{
					// The handle value for the low entry is smaller, so it
					// belongs on the primary list and the high entry on the
					// secondary list.
					high_entry->next_entry = &hfact->entry_list[LD_SECONDARY];
					high_entry->prev_entry =
						hfact->entry_list[LD_SECONDARY].prev_entry;
					hfact->entry_list[LD_SECONDARY].prev_entry->next_entry =
						high_entry;
					hfact->entry_list[LD_SECONDARY].prev_entry = high_entry;
					low_entry->next_entry = &hfact->entry_list[LD_PRIMARY];
					low_entry->prev_entry =
						hfact->entry_list[LD_PRIMARY].prev_entry;
					hfact->entry_list[LD_PRIMARY].prev_entry->next_entry =
						low_entry;
					hfact->entry_list[LD_PRIMARY].prev_entry = low_entry;
				}
				else
				{
					// The handle value for the high entry is smaller, so it
					// belongs on the primary list and the low entry on the
					// secondary list.
					high_entry->next_entry = &hfact->entry_list[LD_PRIMARY];
					high_entry->prev_entry =
						hfact->entry_list[LD_PRIMARY].prev_entry;
					hfact->entry_list[LD_PRIMARY].prev_entry->next_entry =
						high_entry;
					hfact->entry_list[LD_PRIMARY].prev_entry = high_entry;
					low_entry->next_entry = &hfact->entry_list[LD_SECONDARY];
					low_entry->prev_entry =
						hfact->entry_list[LD_SECONDARY].prev_entry;
					hfact->entry_list[LD_SECONDARY].prev_entry->next_entry =
						low_entry;
					hfact->entry_list[LD_SECONDARY].prev_entry = low_entry;
				}
			}
		}
	}
	// Update the handle base with the new handle base.
	hfact->handle_base = new_handle_base;
	// To contract the table, there must be no pairs, because otherwise two
	// assigned handles would yield the same entry index and thereby conflict.
	// Furthermore, the table size must be greater than 2, because much of the
	// handle factory code assumes that the table is at least of size 2.  In
	// addition to these strict requirements, hysteresis is employed both to
	// keep the mean assignment and release times constant and to minimize the
	// allocation chatter of rapidly expanding and contracting the table.  Only
	// if the hysteresis debt is zero will the table be contracted.
	if (hfact->pair_count == 0 && table_size > 2 &&
		hfact->hysteresis_debt == 0)
	{
		contract_HF_table(hfact);
		// Note that we ignore the return code.  If the contraction is
		// unsuccessful, we just continue as usual.  There is no real harm in
		// not contracting the table, except that we consume more space than
		// necessary.
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\tc\dll\api.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    api.c

Abstract:

    This module contains the traffic control apis.

Author:

    Jim Stewart ( jstew )    July 28, 1996

Revision History:

    Ofer Bar ( oferbar )    Oct 1, 1997 - Rev 2
    Shreedhar Madhavapeddi (ShreeM) March 10, 1999 Rev 3

--*/

/*
*********************************************************************
Revision 3 => Changes [ShreeM]

1. Build concrete state machines for Interface, Flow and Filter structures.
2. Define Locks for each of these structures.
3. Use above Locks for recording every state transistion.
4. Use debug logs to record transitions.
5. The Global lock is always taken before any of the Flow, Filter or Interface locks.
*/

#include "precomp.h"
//#pragma hdrstop
//#include "oscode.h"

/*
************************************************************************

Description:

    This will create a new client handle and will also associate 
    it with a client's handler list. It also checks for the version number.

Arguments:

    TciVersion            - The client expected version
    ClientHandlerList    - The client's handler list
    pClientHandle        - output client handle

Return Value:

    NO_ERROR    
    ERROR_NOT_ENOUGH_MEMORY            out of memory
    ERROR_INVALID_PARAMETER            one of the parameters is NULL
    ERROR_INCOMPATIBLE_TC_VERSION    wrong version
    ERROR_NO_SYSTEM_RESOURCES        not enough resources (handles)


************************************************************************
*/
DWORD
APIENTRY
TcRegisterClient(
    IN        ULONG                   TciVersion,
    IN        HANDLE                  ClRegCtx,
    IN        PTCI_CLIENT_FUNC_LIST   ClientHandlerList,
    OUT       PHANDLE                 pClientHandle
    )
{
    DWORD           Status;
    PCLIENT_STRUC   pClient;
    BOOL            RegisterWithGpc = FALSE;


    VERIFY_INITIALIZATION_STATUS;

    IF_DEBUG(CALLS) {
        WSPRINT(("==>TcRegisterClient: Called: Ver= %d, Ctx=%x\n", 
                 TciVersion, ClRegCtx));
    }

    if (IsBadWritePtr(pClientHandle,sizeof(HANDLE))) {
        Status = ERROR_INVALID_PARAMETER;

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcRegisterClient: Error = 0x%X\n", Status ));
        }

        return Status;
    }

    //
    // Set a default pClientHandle as early as possible
    //
    __try {
    
        *pClientHandle = TC_INVALID_HANDLE;
    
    } __except (EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode();
        
        IF_DEBUG(ERRORS) {
            WSPRINT(("TcRegisterClient: Exception Error: = 0x%X\n", Status ));
        }
        
        return Status;
    }
      

    if (TciVersion != CURRENT_TCI_VERSION) {

        Status = ERROR_INCOMPATIBLE_TCI_VERSION;

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcRegisterClient: Error = 0x%X\n", Status ));
        }

        return Status;
    }

    if (IsBadReadPtr(ClientHandlerList,sizeof(TCI_CLIENT_FUNC_LIST))) {
        
        Status = ERROR_INVALID_PARAMETER;

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcRegisterClient: Error = 0x%X\n", Status ));
        }

        return Status;
    }
    
    if (IsBadCodePtr((FARPROC) ClientHandlerList->ClNotifyHandler)) {
        
        //
        // a client must support a notification handler
        //
        
        Status = ERROR_INVALID_PARAMETER;

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcRegisterClient: Error = 0x%X\n", Status ));
        }

        return Status;
    }

    // Prevent another thread from doing TcRegisterClient and TcDeregisterClient
    GetLock( ClientRegDeregLock );
    
    //
    // finish initialization (if needed)
    //
    
    InitializeWmi();

    Status = EnumAllInterfaces();

    if (ERROR_FAILED(Status)) {

        FreeLock( ClientRegDeregLock );
        return Status;
    }

    Status = OpenGpcClients(GPC_CF_QOS);
    if (ERROR_FAILED(Status)) {

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcRegisterClient: Error = 0x%X\n", Status ));
        }

        FreeLock( ClientRegDeregLock );
        return Status;
    }
    
    OpenGpcClients(GPC_CF_CLASS_MAP);

    //
    // allocate a new client structure and link it on the global list
    //

    Status = CreateClientStruc(0,            // This will be the client reg ctx
                               &pClient
                               );
    
    if (ERROR_FAILED(Status)) {

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcRegisterClient: Error = 0x%X\n", Status ));
        }
        
        FreeLock( ClientRegDeregLock );
        return Status;

    }

    //
    // copy the handler list privately
    //

    __try {

        RtlCopyMemory(&pClient->ClHandlers, 
                      ClientHandlerList, 
                      sizeof(TCI_CLIENT_FUNC_LIST));

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode();
        
        IF_DEBUG(ERRORS) {
            WSPRINT(("TcRegisterClient: Exception Error: = 0x%X\n", Status ));
        }
        
        FreeLock( ClientRegDeregLock );
        return Status;
    }

    pClient->ClRegCtx = ClRegCtx;

    //
    // Update linked lists, add the client to the global linked list of
    // clients.
    // 
    // NOTE! NOTE! NOTE! NOTE! NOTE! NOTE! NOTE! NOTE! NOTE! NOTE!
    //
    // Once we add the client to the list, it can get notified by an
    // incoming event, for example: TC_NOTIFY_IFC_CHANGE,
    // so everything should be in place by the time we release the lock!
    //
    
    GetLock(pClient->Lock);
    SET_STATE(pClient->State, OPEN);
    FreeLock(pClient->Lock);

    GetLock( pGlobals->Lock );

    // If this is the first client then register for GPC notifications
    if ( IsListEmpty( &pGlobals->ClientList ) )
        RegisterWithGpc = TRUE;
        
    InsertTailList( &pGlobals->ClientList, &pClient->Linkage );
    FreeLock( pGlobals->Lock );
    
    //
    // so far so good, set the returned handle
    //

    __try {
    
        *pClientHandle = (HANDLE)pClient->ClHandle;
    
    } __except (EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode();
        
        IF_DEBUG(ERRORS) {
            WSPRINT(("TcRegisterClient: Exception Error: = 0x%X\n", Status ));
        }

        // We couldn't return the handle so we do our best effort to undo 
        // the client registration
        TcDeregisterClient((HANDLE)pClient->ClHandle);
        
        FreeLock( ClientRegDeregLock );
        return Status;
    }

    if ( RegisterWithGpc ) 
    {
        Status = StartGpcNotifyThread();
        
        if ( Status )
        {
            // We couldn't return the handle so we do our best effort to undo 
            // the client registration
            TcDeregisterClient((HANDLE)pClient->ClHandle);
            
            FreeLock( ClientRegDeregLock );
            return Status;
        }
    }

    
    // Finally allow other TcRegisterClient and TcDeregisterClient to go through
    FreeLock( ClientRegDeregLock );
        
    IF_DEBUG(CALLS) {
        WSPRINT(("<==TcRegisterClient: ClHandle=%d Status=%X\n", 
                 pClient->ClHandle, Status));
    }

    return Status;
}



/*
************************************************************************

Description:

    The will call the system to enumerate all the TC aware interfaces.
    For each interface, it will return the interface instance name and
    a list of supported network addresses. This list can also be empty
    if the interface currently does not have an address associated with.
    On return, *pBufferSize is set to the actual number of bytes filled
    in Buffer. If the buffer is too small to hold all the interfaces
    data, it will return ERROR_INSUFFICIENT_BUFFER.

Arguments:

    ClientHandle    - the client handle from TcRegisterClient
    pBufferSize        - in: allocate buffer size, out: returned byte count
    InterfaceBuffer - the buffer

Return Value:

    NO_ERROR
    ERROR_INVALID_HANDLE        invalid client handle
    ERROR_INVALID_PARAMETER        one of the parameters is NULL
    ERROR_INSUFFICIENT_BUFFER    buffer too small to enumerate all interfaces
    ERROR_NOT_ENOUGH_MEMORY        system out of memory

************************************************************************
*/
DWORD
APIENTRY
TcEnumerateInterfaces(    
    IN          HANDLE              ClientHandle,
    IN OUT      PULONG              pBufferSize,
    OUT         PTC_IFC_DESCRIPTOR  InterfaceBuffer 
    )
{
    PCLIENT_STRUC   pClient;
    DWORD           Status = NO_ERROR;
    ULONG           MyBufferSize = 2 KiloBytes; // is this enough?!?
    ULONG           Offset2IfcName;
    ULONG           Offset2IfcID;
    INT             t, InputBufSize, CurrentLength = 0;
    PLIST_ENTRY     pHead, pEntry;
    PTC_IFC         pTcIfc;

    IF_DEBUG(CALLS) {
        WSPRINT(("==>TcEnumerateInterfaces: Called: ClientHandle= %d", 
                 ClientHandle  ));
    }
    
    VERIFY_INITIALIZATION_STATUS;


    if (    IsBadWritePtr(pBufferSize, sizeof(ULONG)) 
        ||  IsBadWritePtr(InterfaceBuffer, *pBufferSize) ) {
               
        return ERROR_INVALID_PARAMETER;
    }

    __try {
    
        InputBufSize = *pBufferSize;
        *pBufferSize = 0; // reset it in case of an error
    
    } __except (EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode();              
        
        return Status;
    }
      
    pClient = (PCLIENT_STRUC)GetHandleObjectWithRef(ClientHandle, ENUM_CLIENT_TYPE, 'TCEI');

    if (pClient == NULL) {
        
        return ERROR_INVALID_HANDLE;
    }

    ASSERT((HANDLE)pClient->ClHandle == ClientHandle);

    GetLock(pGlobals->Lock);

    //
    // walk the list of TC interfaces
    //

    pHead = &pGlobals->TcIfcList;
    pEntry = pHead->Flink;

    while (pEntry != pHead) {


        pTcIfc = (PTC_IFC)CONTAINING_RECORD(pEntry,
                                            TC_IFC,
                                            Linkage 
                                            );
        
        //
        // 273978 - if the interface is down - dont show it.
        //
        GetLock(pTcIfc->Lock);
        
        if (QUERY_STATE(pTcIfc->State) != OPEN) {
            
            FreeLock(pTcIfc->Lock);
            pEntry = pEntry->Flink;
            continue;
        }
        
        FreeLock(pTcIfc->Lock);

        //
        // calculate the offset to the interface name buffer data
        //

        Offset2IfcName = FIELD_OFFSET(TC_IFC_DESCRIPTOR, AddressListDesc) + 
            pTcIfc->AddrListBytesCount;

        //
        // calculate the offset to the interface ID buffer data
        //

        Offset2IfcID = Offset2IfcName + 
            pTcIfc->InstanceNameLength + sizeof(WCHAR);

        //
        // total descriptor length
        //

        t = Offset2IfcID
            + pTcIfc->InstanceIDLength + sizeof(WCHAR);  // ID

        t = MULTIPLE_OF_EIGHT(t);
        
        if (t <= InputBufSize - CurrentLength) {

            __try {
                //
                // enough space in the buffer
                //

                InterfaceBuffer->Length = t;

                //
                // update the interface name pointer, place it right after
                // the address desc. buffer
                //

                InterfaceBuffer->pInterfaceName = 
                    (LPWSTR)((PUCHAR)InterfaceBuffer + Offset2IfcName);

                //
                // update the interface ID ID pointer, place it right after
                // the Interface Name string
                //

                InterfaceBuffer->pInterfaceID = 
                    (LPWSTR)((PUCHAR)InterfaceBuffer + Offset2IfcID);

                //
                // copy the address list
                //          

                RtlCopyMemory(&InterfaceBuffer->AddressListDesc,
                              pTcIfc->pAddressListDesc,
                              pTcIfc->AddrListBytesCount
                              );
   
                //
                // copy the interface name
                //

                RtlCopyMemory(InterfaceBuffer->pInterfaceName,
                              &pTcIfc->InstanceName[0],
                              pTcIfc->InstanceNameLength + sizeof(WCHAR)
                              );

                //
                // copy the interface ID
                //

                RtlCopyMemory(InterfaceBuffer->pInterfaceID,
                              &pTcIfc->InstanceID[0],
                              pTcIfc->InstanceIDLength + sizeof(WCHAR)
                              );
            

                //
                // update the output buffer size
                //
                
                CurrentLength += t;

                //
                // advance the interface buffer to the next free space
                //

                InterfaceBuffer = 
                    (PTC_IFC_DESCRIPTOR)((PUCHAR)InterfaceBuffer + t);
                
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                
                Status = GetExceptionCode();
                
                IF_DEBUG(ERRORS) {
                    WSPRINT(("TcEnumerateInterfaces: Exception Error: = 0x%X\n", 
                             Status ));
                }               
                
                break;
            }

            
            //
            // get next entry in the linked list
            //

            pEntry = pEntry->Flink;

        } else {

            //
            // buffer too small to contain data
            // so lets just 
            //
            CurrentLength += t;

            //
            // get next entry in the linked list
            //

            pEntry = pEntry->Flink;

            Status = ERROR_INSUFFICIENT_BUFFER;
        }

    }





    FreeLock(pGlobals->Lock);
    
    REFDEL(&pClient->RefCount, 'TCEI');


    __try {
        
        *pBufferSize = CurrentLength; 
    
    } __except (EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode();              

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcEnumerateInterfaces: Exception Error: = 0x%X\n", 
                      Status ));
        }      
    }
     
    IF_DEBUG(CALLS) {
        WSPRINT(("<==TcEnumerateInterfaces: Returned= 0x%X\n", Status ));
    }
    
    return Status;
}
                


/*
************************************************************************

Description:

    This routine will open an interface for the client.
    It needs to know the interface name, as it was returned from
    TcEnumerateInterfaces. The client is also expected to give a context
    that will be passed to the client upon certains notifications.
    

Arguments:

    InterfaceName    - the intefrace name
    ClientHandle    - as returned from TcRegisterClient
    ClIfcCtx        - a client context for this specific interface
    pIfcHandle        - returned interface handle

Return Value:

    NO_ERROR
    ERROR_INVALID_PARAMETER    one of the parameters is NULL
    ERROR_NOT_ENOUGH_MEMORY    system out of memory
    ERROR_NOT_FOUND            failed to find an interface with the name provided


************************************************************************
*/
DWORD
APIENTRY
TcOpenInterfaceW(
    IN      LPWSTR      pInterfaceName,
    IN      HANDLE      ClientHandle,
    IN      HANDLE      ClIfcCtx,
    OUT     PHANDLE     pIfcHandle
    )
{
    DWORD                Status;
    ULONG                Instance;
    PINTERFACE_STRUC    pClInterface;
    PCLIENT_STRUC        pClient;
    HANDLE                 Handle;
    PTC_IFC                pTcIfc;

    VERIFY_INITIALIZATION_STATUS;

    //
    // Validate the pifcHandle
    //
    if (IsBadWritePtr(pIfcHandle, sizeof(HANDLE))) {
        
        return ERROR_INVALID_PARAMETER;
    }

    // Set a return value early
    __try {
        
        *pIfcHandle = TC_INVALID_HANDLE;
        
    } __except (EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode();              

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcOpenInterfaces: Exception Error: = 0x%X\n", 
                      Status ));
        }      

        return Status;
    }

    //
    // Validate the pInterfaceName
    //
    
    if (IsBadStringPtrW(pInterfaceName,MAX_STRING_LENGTH)) {
        
        return ERROR_INVALID_PARAMETER;
    }

    IF_DEBUG(CALLS) {
        WSPRINT(("==>TcOpenInterface: Called: ClientHandle= %d, Name=%S\n", 
                 ClientHandle, pInterfaceName));
    }


    pClient = (PCLIENT_STRUC)GetHandleObjectWithRef(ClientHandle, ENUM_CLIENT_TYPE, 'TCOI');

    if (pClient == NULL) {
        
        return ERROR_INVALID_HANDLE;
    }

    ASSERT((HANDLE)pClient->ClHandle == ClientHandle);

    //
    // verify that the interface name exist
    //

    pTcIfc = GetTcIfcWithRef(pInterfaceName, 'TCOI');

    if (pTcIfc == NULL) {

        REFDEL(&pClient->RefCount, 'TCOI');
        return ERROR_NOT_FOUND;
    
    } 
    
    //
    //  create a client interface structure
    //

    Status = CreateClInterfaceStruc(ClIfcCtx, &pClInterface);

    if (ERROR_FAILED(Status)) {

        REFDEL(&pClient->RefCount, 'TCOI');
        REFDEL(&pTcIfc->RefCount, 'TCOI');

        return Status;
    
    } else {

        REFADD(&pClInterface->RefCount, 'TCOI');
    
    }

    //
    // set up the client interface structure and link it to the client data
    //

    pClInterface->pTcIfc = pTcIfc;
    pClInterface->pClient = pClient;

    GetLock(pClInterface->Lock);
    SET_STATE(pClInterface->State, OPEN);
    FreeLock(pClInterface->Lock);

    GetLock(pGlobals->Lock);
    //
    // add the interface on the client's list
    //
    GetLock(pClient->Lock);
    GetLock(pTcIfc->Lock);

    if (    (QUERY_STATE(pClient->State) != OPEN) 
        ||  (QUERY_STATE(pTcIfc->State) != OPEN) ) 
    {

        FreeLock(pTcIfc->Lock);
        FreeLock(pClient->Lock);
        FreeLock(pGlobals->Lock);

        IF_DEBUG(CALLS) {
            WSPRINT(("<==TcOpenInterface: IfcHandle=%d Status=%X\n", 
                     pClInterface->ClHandle, Status));
        }

        //
        // Ideally we need to dereference the Interface, we really
        // need only a subset of the functions.
        //
        FreeHandle(pClInterface->ClHandle);
        CloseHandle(pClInterface->IfcEvent);
        FreeMem(pClInterface);

        REFDEL(&pClient->RefCount, 'TCOI');
        REFDEL(&pTcIfc->RefCount, 'TCOI');
        
        return ERROR_NOT_FOUND;

    }

    __try {

        // the handle is all the client wants.
        *pIfcHandle = (HANDLE)pClInterface->ClHandle;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        
          Status = GetExceptionCode();
        
          IF_DEBUG(ERRORS) {
              WSPRINT(("TcOpenInterfaceW: Exception Error: = 0x%X\n", 
                       Status ));
          }

          REFDEL(&pClient->RefCount, 'TCOI');
          REFDEL(&pTcIfc->RefCount, 'TCOI');
          REFDEL(&pClInterface->RefCount, 'TCOI');
        
          return Status;
    }

    InsertTailList( &pClient->InterfaceList, &pClInterface->Linkage );
    
    //
    // for every interface add one ref count
    //
    
    REFADD(&pClient->RefCount, 'CIFC');
    REFADD(&pTcIfc->RefCount, 'CIFC');
        
    pClient->InterfaceCount++;
    
    //
    // add the interface on the TC interface list for back reference
    //
    
    InsertTailList( &pTcIfc->ClIfcList, &pClInterface->NextIfc );
    
    FreeLock(pTcIfc->Lock);
    FreeLock(pClient->Lock);
    FreeLock(pGlobals->Lock);
    

    REFDEL(&pClient->RefCount, 'TCOI');
    REFDEL(&pTcIfc->RefCount, 'TCOI');
    REFDEL(&pClInterface->RefCount, 'TCOI');
    
    IF_DEBUG(CALLS) {
        WSPRINT(("<==TcOpenInterface: IfcHandle=%d Status=%X\n", 
                 pClInterface->ClHandle, Status));
    }

    return Status;
    
}


/*
************************************************************************

Description:

    The ANSI version of TcOpenInterfaceW    

Arguments:

    See TcOpenInterfaceW

Return Value:

    See TcOpenInterfaceW

************************************************************************
*/
DWORD
APIENTRY
TcOpenInterfaceA(
    IN      LPSTR       pInterfaceName,
    IN      HANDLE      ClientHandle,
    IN      HANDLE      ClIfcCtx,
    OUT     PHANDLE     pIfcHandle
    )
{
    LPWSTR    pWstr;
    int     l;
    DWORD    Status;


    if (IsBadWritePtr(pIfcHandle,sizeof(HANDLE))) {

        return ERROR_INVALID_PARAMETER;
            
    }

    __try {
        
        *pIfcHandle = TC_INVALID_HANDLE;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        
          Status = GetExceptionCode();
        
          IF_DEBUG(ERRORS) {
              WSPRINT(("TcOpenInterfaceA: Exception Error: = 0x%X\n", 
                       Status ));
          }
  
          return Status;
    }


    if (IsBadStringPtrA(pInterfaceName,MAX_STRING_LENGTH)) {
        
        return ERROR_INVALID_PARAMETER;
    }


    __try {
        
        l = strlen(pInterfaceName) + 1;

        AllocMem(&pWstr, l*sizeof(WCHAR));

        if (pWstr == NULL) {

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        if ( -1 == mbstowcs(pWstr, pInterfaceName, l)) {

            FreeMem(pWstr);
            return ERROR_NO_UNICODE_TRANSLATION;

        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        
          Status = GetExceptionCode();
        
          IF_DEBUG(ERRORS) {
              WSPRINT(("TcOpenInterfaceA: Exception Error: = 0x%X\n", 
                       Status ));
          }
  
          return Status;
    }
    
    Status =  TcOpenInterfaceW(pWstr,
                               ClientHandle,
                               ClIfcCtx,
                               pIfcHandle
                               );
    FreeMem(pWstr);

    return Status;
}



/*
************************************************************************

Description:

    This will close the interface previously open witt TcOpenInterface.
    All flows should be deleted before calling it, o/w an error will be 
    returned. All notificaitons will stop being reported on this interface.

Arguments:

    InterfaceHandle - the interface handle

Return Value:

    NO_ERROR
    ERROR_INVALID_HANDLE                bad interface handle
    ERROR_TC_SUPPORTED_OBJECTS_EXIST    not all flows have been deleted for 
                                        this interface
    
************************************************************************
*/
DWORD
APIENTRY
TcCloseInterface(
    IN HANDLE       InterfaceHandle
    )
{

    DWORD               Status = NO_ERROR;
    PINTERFACE_STRUC    pInterface;
    HANDLE              hWaitEvent;
    PFLOW_STRUC         pFlow;
    PLIST_ENTRY         pEntry;

    VERIFY_INITIALIZATION_STATUS;

    IF_DEBUG(CALLS) {
        WSPRINT(("==>TcCloseInterface: Called: IfcHandle= %d\n", 
                 InterfaceHandle));
    }

    pInterface = (PINTERFACE_STRUC)GetHandleObjectWithRef(InterfaceHandle, 
                                                   ENUM_INTERFACE_TYPE, 'TCCI');

    if (pInterface == NULL) {
        
        IF_DEBUG(ERRORS) {
            WSPRINT(("==>TcCloseInterface: ERROR_INVALID_HANDLE\n"));
        }

        //
        // If the Interface State is FORCED_KERNELCLOSE, it means we need
        // to hang out here until the callback (in cbinterfacenotifyclient is done).
        // 
        GetLock( pGlobals->Lock );
        
        pInterface = (PINTERFACE_STRUC)GetHandleObject(InterfaceHandle, 
                                                       ENUM_INTERFACE_TYPE);

        if (pInterface) {

            if (pInterface->CallbackThreadId == GetCurrentThreadId()) {
                // same thread - bail!
                FreeLock(pGlobals->Lock);                

            } else {

                GetLock(pInterface->Lock);
            
                // This is the state before the callback, so we shall wait here.
                if (QUERY_STATE(pInterface->State) == FORCED_KERNELCLOSE) {
                
                    REFADD(&pInterface->RefCount, 'TCCW');
                    FreeLock(pInterface->Lock);
                
                    pInterface->Flags |= TC_FLAGS_WAITING;
                    hWaitEvent = pInterface->IfcEvent;

                    IF_DEBUG(INTERFACES) {
                        WSPRINT(("<==TcCloseInterface: Premature Forced Kernel Close, waiting for the callbacks to complete\n"));
                    }

                    FreeLock(pGlobals->Lock);
                    REFDEL(&pInterface->RefCount, 'TCCW');
                    WaitForSingleObject(hWaitEvent, INFINITE);
                    CloseHandle(hWaitEvent);
                
                } else {

                    FreeLock(pInterface->Lock);
                    FreeLock(pGlobals->Lock);

                }

            }

        } else {

            FreeLock(pGlobals->Lock);

        }

        return ERROR_INVALID_HANDLE;
    }

    ASSERT((HANDLE)pInterface->ClHandle == InterfaceHandle);

    //
    // release the ref count we added when we opened the interface
    //

    GetLock( pGlobals->Lock );

    if (pInterface->FlowCount > 0) {

        IF_DEBUG(ERRORS) {
            WSPRINT(("<==TcCloseInterface: ERROR: there are still open flows on this interface!\n"));
        }
#if DBG
        pEntry = pInterface->FlowList.Flink;
        while (pEntry != &pInterface->FlowList) {

            pFlow = CONTAINING_RECORD(pEntry, FLOW_STRUC, Linkage);
            IF_DEBUG(ERRORS) {
                WSPRINT(("<==TcCloseInterface: Flow %x (handle %x) is open with RefCount:%d\n", pFlow, pFlow->ClHandle, pFlow->RefCount));
            }

            pEntry = pEntry->Flink;
        }
#endif 
        


        FreeLock(pGlobals->Lock);
        REFDEL(&pInterface->RefCount, 'TCCI');
        Status = ERROR_TC_SUPPORTED_OBJECTS_EXIST;
        return Status;

    }
        
    //
    // OK, so we are taking it out for sure now.
    //
    GetLock(pInterface->Lock);

    if (QUERY_STATE(pInterface->State) == OPEN) {
        
        SET_STATE(pInterface->State, USERCLOSED_KERNELCLOSEPENDING);
        FreeLock(pInterface->Lock);

    } else if (QUERY_STATE(pInterface->State) == FORCED_KERNELCLOSE) {

        //
        // if the interface is going down, we are going to notify the 
        // client, make sure we wait here till the callbacks are done.
        // 
        FreeLock(pInterface->Lock);

        pInterface->Flags |= TC_FLAGS_WAITING;
        hWaitEvent = pInterface->IfcEvent;

        IF_DEBUG(INTERFACES) {
            WSPRINT(("<==TcCloseInterface: Forced Kernel Close, waiting for the callbacks to complete\n"));
        }

        FreeLock(pGlobals->Lock);

        REFDEL(&pInterface->RefCount, 'TCCI');
        WaitForSingleObject(hWaitEvent, INFINITE);
        
        CloseHandle(hWaitEvent);
        return ERROR_INVALID_HANDLE;

    } else {

        //
        // Is someone else (wmi) already taking it out.
        //
        FreeLock(pInterface->Lock);
        FreeLock( pGlobals->Lock );
        REFDEL(&pInterface->RefCount, 'TCCI');

        return ERROR_INVALID_HANDLE;

    }


    FreeLock(pGlobals->Lock);

    Status = CloseInterface(pInterface, FALSE);

    IF_DEBUG(CALLS) {
        WSPRINT(("<==TcCloseInterface: Status=%X\n", 
                 Status));
    }

    //
    // Shall we wait until the last interface goes away? (292120 D)
    //
    GetLock( pGlobals->Lock );

    if (pInterface->CallbackThreadId != 0 ) {
        //
        // We are doing a notification, don't block (343058)
        //
  
        FreeLock(pGlobals->Lock);
        REFDEL(&pInterface->RefCount, 'TCCI'); 

    } else {
        pInterface->Flags |= TC_FLAGS_WAITING;
        hWaitEvent = pInterface->IfcEvent;

        IF_DEBUG(INTERFACES) {

            WSPRINT(("<==TcCloseInterface: Waiting for event to get set when we are ready to delete!!\n"));

        }

        FreeLock(pGlobals->Lock);
        REFDEL(&pInterface->RefCount, 'TCCI');
        WaitForSingleObject(hWaitEvent, INFINITE);
        CloseHandle(hWaitEvent);
    } 

    return Status;
}



/*
************************************************************************

Description:

    This call will add a new flow on the interface.
    
Arguments:

    IfcHandle        - the interface handle to add the flow on
    ClFlowCtx        - a client given flow context
    AddressType        - determines what protocol template to use with the GPC
    Flags            - reserved, will be used to indicate a persistent flow
    pGenericFlow    - flow parameters
    pFlowHandle        - returned flow handle in case of success

Return Value:

    NO_ERROR
    ERROR_SIGNAL_PENDING

    General error codes:

    ERROR_INVALID_HANDLE        bad handle.
    ERROR_NOT_ENOUGH_MEMORY        system out of memory
    ERROR_INVALID_PARAMETER        a general parameter is invalid

    TC specific error codes:

    ERROR_INVALID_SERVICE_TYPE    unspecified or bad intserv service type
    ERROR_INVALID_TOKEN_RATE    unspecified or bad TokenRate
    ERROR_INVALID_PEAK_RATE        bad PeakBandwidth
    ERROR_INVALID_SD_MODE        invalid ShapeDiscardMode
    ERROR_INVALID_PRIORITY        invalid priority value
    ERROR_INVALID_TRAFFIC_CLASS invalid traffic class value
    ERROR_ADDRESS_TYPE_NOT_SUPPORTED     the address type is not supported for 
                                this interface
    ERROR_NO_SYSTEM_RESOURCES    not enough resources to accommodate flows

************************************************************************
*/ 
DWORD
APIENTRY
TcAddFlow(
    IN      HANDLE          IfcHandle,
    IN      HANDLE          ClFlowCtx,
    IN      ULONG           Flags,
    IN      PTC_GEN_FLOW    pGenericFlow,
    OUT     PHANDLE         pFlowHandle
    )
{
    DWORD               Status, Status2 = NO_ERROR;
    PFLOW_STRUC         pFlow;
    PINTERFACE_STRUC    pInterface;
    PCLIENT_STRUC       pClient;
    PGPC_CLIENT         pGpcClient;
    ULONG               l;
    HANDLE              hFlowTemp;

    IF_DEBUG(CALLS) {
        WSPRINT(("==>TcAddFlow: Called: IfcHandle= %d, ClFlowCtx=%d\n", 
                 IfcHandle, ClFlowCtx ));
    }
    
    VERIFY_INITIALIZATION_STATUS;
    
    if (IsBadWritePtr(pFlowHandle,sizeof(HANDLE))) {
        
        Status = ERROR_INVALID_PARAMETER;

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcAddFlow: Error = 0x%X\n", Status ));
        }

        return Status;
    }

    __try {
        
        *pFlowHandle = TC_INVALID_HANDLE;

        if (IsBadReadPtr(pGenericFlow, sizeof(TC_GEN_FLOW))) {
        
            Status = ERROR_INVALID_PARAMETER;

            IF_DEBUG(ERRORS) {
                WSPRINT(("TcAddFlow: Error = 0x%X\n", Status ));
            }

            return Status;
        }

        l = FIELD_OFFSET(TC_GEN_FLOW, TcObjects) + pGenericFlow->TcObjectsLength;
        
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        
          Status = GetExceptionCode();
        
          IF_DEBUG(ERRORS) {
              WSPRINT(("TcAddFlow: Exception Error: = 0x%X\n", Status ));
          }
  
          return Status;
    }

    if (IsBadReadPtr(pGenericFlow, l)) {
        
        Status = ERROR_INVALID_PARAMETER;

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcAddFlow: Error = 0x%X\n", Status ));
        }

        return Status;
    }

    pInterface = (PINTERFACE_STRUC)GetHandleObjectWithRef(IfcHandle, 
                                                   ENUM_INTERFACE_TYPE, 'TCAF');

    if (pInterface == NULL) {

        Status = ERROR_INVALID_HANDLE;

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcAddFlow: Error = 0x%X\n", Status ));
        }

        return Status;
    }

    ASSERT((HANDLE)pInterface->ClHandle == IfcHandle);

    //
    // search for an open GPC client that supports this address type
    //

    pGpcClient = FindGpcClient(GPC_CF_QOS);

    if (pGpcClient == NULL) {

        //
        // not found!
        //

        Status = ERROR_ADDRESS_TYPE_NOT_SUPPORTED;

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcAddFlow: Error = 0x%X\n", Status ));
        }

        REFDEL(&pInterface->RefCount, 'TCAF');
        return Status;
    }
    

    //
    // create a new flow structure
    //
    Status = CreateFlowStruc(ClFlowCtx, pGenericFlow, &pFlow);

    if (ERROR_FAILED(Status)) {

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcAddFlow: Error = 0x%X\n", Status ));
        }
        
        REFDEL(&pInterface->RefCount, 'TCAF');
        return Status;
    }

    pClient = pInterface->pClient;

    //
    // initialize the flow structure and add it on the intefrace list
    //

    pFlow->pInterface = pInterface;
    pFlow->UserFlags = Flags;
    
    pFlow->pGpcClient = pGpcClient;
    
    //
    // call to actually add the flow
    //

    Status = IoAddFlow( pFlow, TRUE );

    if (!ERROR_FAILED(Status)) {
        
        __try {
            
            *pFlowHandle = (HANDLE)pFlow->ClHandle;
            
        } __except (EXCEPTION_EXECUTE_HANDLER) {
        
            Status2 = GetExceptionCode();
        
            IF_DEBUG(ERRORS) {
              WSPRINT(("TcAddFlow: Exception Error: = 0x%X\n", Status2 ));
            }
            
            hFlowTemp = (HANDLE)pFlow->ClHandle;    
        } 
    } 
    
    if (!ERROR_PENDING(Status)) {

        //
        // call completed, either success or failure...
        //
        CompleteAddFlow(pFlow, Status);
    }

    //
    // !!! don't reference pFlow after this since it may be gone!!!
    //

    if (Status2 != NO_ERROR) {
        
        // We won't be able to return the flow, so we need to try to delete it
        // and return the error

        TcDeleteFlow(hFlowTemp);
        return (Status2);
        
    }
    
    IF_DEBUG(CALLS) {
        WSPRINT(("<==TcAddFlow: Returned= 0x%X\n", Status ));
    }

    return Status;
}




/*
************************************************************************

Description:

    This call will modify the flow.

Arguments:

    FlowHandle        - flow handle to modify
    pGenericFlow    - new flow parameters

Return Value:

    See TcAddFlow

************************************************************************
*/
DWORD
APIENTRY
TcModifyFlow(
    IN      HANDLE          FlowHandle,
    IN      PTC_GEN_FLOW    pGenericFlow
    )
{
    DWORD                Status;
    PFLOW_STRUC            pFlow;
    ULONG                l;

    IF_DEBUG(CALLS) {
        WSPRINT(("==>TcModifyFlow: Called: FlowHandle= %d\n", 
                 FlowHandle ));
    }

    VERIFY_INITIALIZATION_STATUS;

    if (IsBadReadPtr(pGenericFlow,sizeof(TC_GEN_FLOW))) {
        
        Status = ERROR_INVALID_PARAMETER;

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcModifyFlow: Error = 0x%X\n", Status ));
        }

        return Status;
    }

    // 
    // Figure out the full length for immediate verification and also for later usage
    //

    __try {

        l = FIELD_OFFSET(TC_GEN_FLOW, TcObjects) + pGenericFlow->TcObjectsLength;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        
          Status = GetExceptionCode();
        
          IF_DEBUG(ERRORS) {
              WSPRINT(("TcModifyFlow: Exception Error: = 0x%X\n", 
                       Status ));
          }
        
          return Status;
    }

    if (IsBadReadPtr(pGenericFlow,l)) {
        
        Status = ERROR_INVALID_PARAMETER;

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcModifyFlow: Error = 0x%X\n", Status ));
        }

        return Status;
    }
    

    pFlow = (PFLOW_STRUC)GetHandleObjectWithRef(FlowHandle, ENUM_GEN_FLOW_TYPE, 'TCMF');

    if (pFlow == NULL) {
        
        Status = ERROR_INVALID_HANDLE;

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcModifyFlow: Error = 0x%X\n", Status ));
        }

        return Status;
    }
    else if (pFlow == INVALID_HANDLE_VALUE ) 
    {
    
        Status = ERROR_NOT_READY;
        
        IF_DEBUG(ERRORS) {
            WSPRINT(("TcModifyFlow: Error = 0x%X\n", Status ));
        }

        return Status;
    }
    
    ASSERT((HANDLE)pFlow->ClHandle == FlowHandle);

    GetLock(pFlow->Lock);
    
    if (IS_MODIFYING(pFlow->Flags)) {
        
        FreeLock(pFlow->Lock);
        
        IF_DEBUG(REFCOUNTS) { 
            WSPRINT(("0 DEREF FLOW %X (%X) - ref (%d)\n", pFlow->ClHandle, pFlow, pFlow->RefCount)); 
        }
        
        REFDEL(&pFlow->RefCount, 'TCMF');

        return ERROR_NOT_READY;

    }

    AllocMem(&pFlow->pGenFlow1, l);

    if (pFlow->pGenFlow1 == NULL) {

        Status = ERROR_NOT_ENOUGH_MEMORY;

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcModifyFlow: Error = 0x%X\n", Status ));
        }

        FreeLock(pFlow->Lock);
        
        IF_DEBUG(REFCOUNTS) { 
            WSPRINT(("1 DEREF FLOW %X (%X) - ref (%d)\n", pFlow->ClHandle, pFlow, pFlow->RefCount)); 
        }

        REFDEL(&pFlow->RefCount, 'TCMF');
        
        return Status;
    }

    __try {

        RtlCopyMemory(pFlow->pGenFlow1, pGenericFlow, l);

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        
        Status = GetExceptionCode();
        
        IF_DEBUG(ERRORS) {
            WSPRINT(("TcModifyFlow: Exception Error: = 0x%X\n", 
                     Status ));
        }
        
        FreeLock(pFlow->Lock);
        //IF_DEBUG(REFCOUNTS) { WSPRINT(("2\n"));
        IF_DEBUG(REFCOUNTS) { 
            WSPRINT(("2 DEREF FLOW %X (%X) ref (%d)\n", pFlow->ClHandle, pFlow, pFlow->RefCount)); 
        }

        REFDEL(&pFlow->RefCount, 'TCMF');

        return Status;
    }

    pFlow->Flags |= TC_FLAGS_MODIFYING;
    pFlow->GenFlowLen1 = l;

    FreeLock(pFlow->Lock);

    //
    // call to actually modify the flow
    //

    Status = IoModifyFlow( pFlow, TRUE );

    if (!ERROR_PENDING(Status)) {

        //
        // call completed, either success or failure...
        //

        CompleteModifyFlow(pFlow, Status);
    }

    //
    // !!! don't reference pFlow after this since it may be gone!!!
    //
    //IF_DEBUG(REFCOUNTS) { WSPRINT(("3\n"));
    IF_DEBUG(REFCOUNTS) { 
        WSPRINT(("3 DEREF FLOW %X (%X), ref(%d)\n", pFlow->ClHandle, pFlow, pFlow->RefCount)); 
    }
    
    IF_DEBUG(CALLS) {
        WSPRINT(("<==TcModifyFlow: Returned= 0x%X\n", Status ));
    }

    return Status;
}




/*
************************************************************************

Description:

    This will delete the flow. All the filters must have been deleted
    by now, o/w an error code will be returned. Also the handle is
    invalidated. No TC_NOTIFY_FLOW_CLOSE will be reported for this flow.

Arguments:

    FlowHandle - handle of the flow to delete

Return Value:

    NO_ERROR
    ERROR_SIGNAL_PENDING
    ERROR_INVALID_HANDLE                invalid or NULL handle
    ERROR_TC_SUPPORTED_OBJECTS_EXIST    not all the filters have been deleted


************************************************************************
*/
DWORD
APIENTRY
TcDeleteFlow(
    IN HANDLE  FlowHandle
    )
{
    DWORD                Status;
    PFLOW_STRUC            pFlow;

    IF_DEBUG(CALLS) {
        WSPRINT(("==>TcDeleteFlow: Called: FlowHandle= %d\n", 
                 FlowHandle ));
    }

    VERIFY_INITIALIZATION_STATUS;

    pFlow = (PFLOW_STRUC)GetHandleObjectWithRef(FlowHandle, ENUM_GEN_FLOW_TYPE, 'TCDF');
    
    if (pFlow == NULL) {
        
        Status = ERROR_INVALID_HANDLE;

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcDeleteFlow: Error = 0x%X\n", Status ));
        }

        return Status;
    }
    else if (pFlow == INVALID_HANDLE_VALUE ) 
    {
    
        Status = ERROR_NOT_READY;
        
        IF_DEBUG(ERRORS) {
            WSPRINT(("TcDeleteFlow: Error = 0x%X\n", Status ));
        }

        return ERROR_NOT_READY;
    }

    ASSERT((HANDLE)pFlow->ClHandle == FlowHandle);

    //
    // Set the state and call to actually delete the flow
    //
    GetLock(pFlow->Lock);

    if (QUERY_STATE(pFlow->State) == OPEN) {
        
        if (IS_MODIFYING(pFlow->Flags)) 
        {
            //
            // Someone else is taking this out.
            //
            FreeLock(pFlow->Lock);
            REFDEL(&pFlow->RefCount, 'TCDF');
            
            return ERROR_NOT_READY;
        }
    
        SET_STATE(pFlow->State, USERCLOSED_KERNELCLOSEPENDING);
        FreeLock(pFlow->Lock);

    } else {

        //
        // Someone else is taking this out.
        //
        FreeLock(pFlow->Lock);
        REFDEL(&pFlow->RefCount, 'TCDF');
        
        return ERROR_INVALID_HANDLE;

    }

    Status = DeleteFlow(pFlow, FALSE);

    if (ERROR_FAILED(Status)) {

        GetLock(pFlow->Lock);
        SET_STATE(pFlow->State, OPEN);
        FreeLock(pFlow->Lock);

    }

    //
    // !!! don't reference pFlow after this since it may be gone!!!
    //
    //IF_DEBUG(REFCOUNTS) { WSPRINT(("4\n"));
    IF_DEBUG(REFCOUNTS) { 
        WSPRINT(("4 DEREF FLOW %X (%X) ref(%d)\n", pFlow->ClHandle, pFlow, pFlow->RefCount)); 
    }

    REFDEL(&pFlow->RefCount, 'TCDF');

    IF_DEBUG(CALLS) {
        WSPRINT(("<==TcDeleteFlow: Returned= 0x%X\n", Status ));
    }

    return Status;
}




/*
************************************************************************

Description:

    Will add a filter and attach it to the flow.

Arguments:

    FlowHandle        - handle of the flow to add the filter on
    pGenericFilter    - the filter characteristics
    pFilterHandle    - the returned filter handle after success

Return Value:

    NO_ERROR

    General error codes:
    
    ERROR_INVALID_HANDLE        bad handle.
    ERROR_NOT_ENOUGH_MEMORY        system out of memory
    ERROR_INVALID_PARAMETER        a general parameter is invalid

    TC specific error codes:

    ERROR_INVALID_ADDRESS_TYPE    invalid address type
    ERROR_DUPLICATE_FILTER        attempt to install identical filters on 
                                different flows
    ERROR_FILTER_CONFLICT        attempt to install conflicting filter

************************************************************************
*/
DWORD
APIENTRY
TcAddFilter(
    IN      HANDLE          FlowHandle,
    IN      PTC_GEN_FILTER  pGenericFilter,
    OUT     PHANDLE         pFilterHandle
    )
{
    DWORD           Status;
    PFLOW_STRUC     pFlow;
    PFILTER_STRUC   pFilter;
    ULONG           PatternSize;

    IF_DEBUG(CALLS) {
        WSPRINT(("==>TcAddFilter: Called: FlowHandle=%d\n", FlowHandle ));
    }

    VERIFY_INITIALIZATION_STATUS;

    if (IsBadWritePtr(pFilterHandle,sizeof(HANDLE))) {
        
        Status = ERROR_INVALID_PARAMETER;

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcAddFilter: Error = 0x%X\n", Status ));
        }

        return Status;
    }

    __try {
        
        *pFilterHandle = TC_INVALID_HANDLE;
   
        if (    IsBadReadPtr(pGenericFilter,sizeof(TC_GEN_FILTER))
            ||  IsBadReadPtr(pGenericFilter->Pattern,pGenericFilter->PatternSize) 
            ||  IsBadReadPtr(pGenericFilter->Mask,pGenericFilter->PatternSize)) {

            Status = ERROR_INVALID_PARAMETER;

            IF_DEBUG(ERRORS) {
                WSPRINT(("TcAddFilter: Error = 0x%X\n", Status ));
            }

            return Status;

        }   
        
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        
        Status = GetExceptionCode();
        
        IF_DEBUG(ERRORS) {
            WSPRINT(("TcAddFilter: Exception Error: = 0x%X\n", Status ));
        }
        
        return Status;
    }

    pFlow = (PFLOW_STRUC)GetHandleObjectWithRef(FlowHandle, 
                                         ENUM_GEN_FLOW_TYPE, 'TAFL');

    if (pFlow == NULL) {
        
        Status = ERROR_INVALID_HANDLE;

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcAddFilter: Error = 0x%X\n", Status ));
        }

        return Status;
    }
    else if (pFlow == INVALID_HANDLE_VALUE ) 
    {
    
        Status = ERROR_NOT_READY;
        
        IF_DEBUG(ERRORS) {
            WSPRINT(("TcAddFilter: Error = 0x%X\n", Status ));
        }

        return Status;
    }


    ASSERT((HANDLE)pFlow->ClHandle == FlowHandle);

    //
    // create a new filter structure
    //

    Status = CreateFilterStruc(pGenericFilter, pFlow, &pFilter);

    if ( Status != NO_ERROR ) {

        if ( ERROR_PENDING(Status) )
            Status = ERROR_NOT_READY;
            
        IF_DEBUG(ERRORS) {
            WSPRINT(("TcAddFilter: Error = 0x%X\n", Status ));
        }
        //IF_DEBUG(REFCOUNTS) { WSPRINT(("5\n"));
        IF_DEBUG(REFCOUNTS) { 
            WSPRINT(("5 DEREF FLOW %X (%X) ref(%d)\n", pFlow->ClHandle, pFlow, pFlow->RefCount)); 
        }

        REFDEL(&pFlow->RefCount, 'TAFL');
        return Status;
    }

    //
    // initialize the filter structure and add it on the flow list
    //

    pFilter->pFlow = pFlow;
    //
    // call to actually add the filter
    //

    Status = IoAddFilter( pFilter );

    if (!ERROR_FAILED(Status)) {

        __try {
            
            *pFilterHandle = (HANDLE)pFilter->ClHandle;
            
        } __except (EXCEPTION_EXECUTE_HANDLER) {
        
            Status = GetExceptionCode();
        
            IF_DEBUG(ERRORS) {
                WSPRINT(("TcAddFilter: Exception Error: = 0x%X\n", Status ));
            }
        
        }

        GetLock(pGlobals->Lock);
        GetLock(pFlow->Lock);
        
        if (QUERY_STATE(pFlow->State) == OPEN) {

            SET_STATE(pFilter->State, OPEN);
            InsertTailList(&pFlow->FilterList, &pFilter->Linkage);
            REFADD(&pFlow->RefCount, 'FILT');
            
            FreeLock(pFlow->Lock);
        
        } 
        else {

            IF_DEBUG(WARNINGS) { 
                WSPRINT(("Flow %X (handle %X) is not OPEN! \n", pFlow, pFlow->ClHandle)); 
            }

            FreeLock(pFlow->Lock);
            DeleteFilter(pFilter);
            Status = ERROR_INVALID_HANDLE;
        }

        FreeLock(pGlobals->Lock);

    } else {

        //
        // failed, release the filter resources
        //
        REFDEL(&pFilter->RefCount, 'FILT');

    }
    //IF_DEBUG(REFCOUNTS) { WSPRINT(("6\n"));
    IF_DEBUG(REFCOUNTS) { 
        WSPRINT(("6 DEREF FLOW %X (%X) (%d)\n", pFlow->ClHandle, pFlow, pFlow->RefCount)); 
    }

    REFDEL(&pFlow->RefCount, 'TAFL');

    IF_DEBUG(CALLS) {
        WSPRINT(("<==TcAddFilter: Returned= 0x%X\n", Status ));
    }

    return Status;
}


/*
************************************************************************

Description:

    Deletes the filter and invalidates the handle.

Arguments:

    FilterHandle - handle of the filter to be deleted

Return Value:

    NO_ERROR
    ERROR_INVALID_HANDLE        invalid or NULL handle

************************************************************************
*/
DWORD
APIENTRY
TcDeleteFilter(
    IN         HANDLE          FilterHandle
    )
{
    DWORD                Status;
    PFILTER_STRUC        pFilter;

    IF_DEBUG(CALLS) {
        WSPRINT(("==>TcDeleteFilter: Called: FilterHandle=%d\n", 
                 FilterHandle ));
    }

    VERIFY_INITIALIZATION_STATUS;

    pFilter = (PFILTER_STRUC)GetHandleObjectWithRef(FilterHandle, 
                                             ENUM_FILTER_TYPE, 'TDFL');

    if (pFilter == NULL) {

        Status = ERROR_INVALID_HANDLE;

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcDeleteFilter: Error = 0x%X\n", Status ));
        }

        return Status;
    }

    ASSERT((HANDLE)pFilter->ClHandle == FilterHandle);

    GetLock(pFilter->Lock);

    if (QUERY_STATE(pFilter->State) == OPEN) {
        
        SET_STATE(pFilter->State, USERCLOSED_KERNELCLOSEPENDING);
        FreeLock(pFilter->Lock);

    } else {

        //
        // Someone else is taking this out.
        //
        FreeLock(pFilter->Lock);
        REFDEL(&pFilter->RefCount, 'TDFL');

        return ERROR_INVALID_HANDLE;

    }



    Status = DeleteFilter(pFilter);

    IF_DEBUG(CALLS) {
        WSPRINT(("<==TcDeleteFilter: Returned= 0x%X\n", Status ));
    }

    REFDEL(&pFilter->RefCount, 'TDFL');
    
    return Status;
}




/*
************************************************************************

Description:

    This will deregister the client and release all associated resources.
    TC_NOTIFY_IFC_CHANGE notifications will no longer be reported to
    this client. All interface must have being close prior to calling
    this API, o/w an error will be returned.

Arguments:

    ClientHandle - handle of the client to be deregistered

Return Value:

    NO_ERROR
    ERROR_INVALID_HANDLE                invalid or NULL handle
    ERROR_TC_SUPPORTED_OBJECTS_EXIST    not all the interfaces have been 
                                        closed for this client

************************************************************************
*/
DWORD
TcDeregisterClient(
    IN        HANDLE        ClientHandle
    )
{
    DWORD               Status;
    ULONG               Instance;
    PINTERFACE_STRUC    pClInterface;
    PCLIENT_STRUC       pClient;
    PLIST_ENTRY         pEntry;
    BOOLEAN             fOpenInterfacesFound;
    BOOLEAN             fDeRegisterWithGpc = FALSE;

    VERIFY_INITIALIZATION_STATUS;
    Status = NO_ERROR;
    fOpenInterfacesFound = FALSE;

    IF_DEBUG(CALLS) {
        WSPRINT(("==>TcDeregisterClient: ClientHandle=%d\n", 
                 ClientHandle));
    }

    pClient = (PCLIENT_STRUC)GetHandleObject(ClientHandle, ENUM_CLIENT_TYPE);

    if (pClient == NULL) {
        
        IF_DEBUG(ERRORS) {
            WSPRINT(("<==TcDeregisterClient: ERROR_INVALID_HANDLE\n"));
        }

        return ERROR_INVALID_HANDLE;
    }

    ASSERT((HANDLE)pClient->ClHandle == ClientHandle);

    // Prevent another thread from doing TcRegisterClient and TcDeregisterClient
    GetLock( ClientRegDeregLock );
    
    GetLock( pGlobals->Lock );
    
    // Go through the interface list and check if any interfaces are open.
    // for a checked build, lets dump out the interfaces and the refcounts on these
    // interfaces too. [ShreeM]

    pEntry = pClient->InterfaceList.Flink;
    while (pEntry != &pClient->InterfaceList) {

        pClInterface = CONTAINING_RECORD(pEntry, INTERFACE_STRUC, Linkage);

        GetLock(pClInterface->Lock);

        if ((QUERY_STATE(pClInterface->State) == FORCED_KERNELCLOSE) ||
            (QUERY_STATE(pClInterface->State) == KERNELCLOSED_USERCLEANUP)) {

#if DBG
            IF_DEBUG(WARNINGS) {
                WSPRINT(("<==TcDeregisterClient: Interface %x (H%x) is FORCED_KERNELCLOSE with RefCount:%d\n", 
                         pClInterface, pClInterface->ClHandle, pClInterface->RefCount));
            }
#endif 
        
        } else {

            fOpenInterfacesFound = TRUE;

#if DBG
            IF_DEBUG(ERRORS) {
                WSPRINT(("<==TcDeregisterClient: Interface %x (H%x) is open with RefCount:%d\n", pClInterface, pClInterface->ClHandle, pClInterface->RefCount));
            }
#endif 
        
        }

        pEntry = pEntry->Flink;
        FreeLock(pClInterface->Lock);



        if (fOpenInterfacesFound) {
            
            IF_DEBUG(ERRORS) {
                WSPRINT(("<==TcDeregisterClient: ERROR_TC_SUPPORTED_OBJECTS_EXIST (%d Interfaces)\n", pClient->InterfaceCount));
            }
            
            FreeLock( ClientRegDeregLock );
            FreeLock( pGlobals->Lock );
            return ERROR_TC_SUPPORTED_OBJECTS_EXIST;

        }

    }

    //
    // Lets mark it as deleting.
    //
    GetLock(pClient->Lock);
    SET_STATE(pClient->State, USERCLOSED_KERNELCLOSEPENDING);
    FreeLock(pClient->Lock);

    IF_DEBUG(HANDLES) {
        WSPRINT(("<==TcDeregisterClient: client (%x), RefCount:%d\n", pClient->ClHandle, pClient->RefCount));
    }

    REFDEL(&pClient->RefCount, 'CLNT');

    if ( IsListEmpty( &pGlobals->ClientList ) )
        fDeRegisterWithGpc = TRUE;
        
    FreeLock( pGlobals->Lock );
    
    if ( fDeRegisterWithGpc ) 
    {
        // When there are no clients left stop listening to
        // GPC notifications.
        Status = StopGpcNotifyThread();
    }
    
    FreeLock( ClientRegDeregLock );
    
    IF_DEBUG(CALLS) {
        WSPRINT(("<==TcDeregisterClient: NO_ERROR\n" ));
    }

    return NO_ERROR;
}





/*
************************************************************************

Description:

    Sends a WMI query on the guid with the instance name.
    Also sets the notification state to TRUE (=notify) or FALSE (dont notify).
    
Arguments:

    IfcHandle        - interface to send the query to 
    pGuidParam        - GUID of the queried property
    NotifyChange    - set the notification state for this property
    BufferSize        - size of allocated buffer
    Buffer             - the buffer for returned result

Return Value:

    NO_ERROR
    ERROR_INVALID_HANDLE        bad interface handle
    ERROR_INVALID_PARAMETER        bad parameter 
    ERROR_INSUFFICIENT_BUFFER    buffer too small for result
    ERROR_NOT_SUPPORTED            unsupported GUID

************************************************************************
*/
DWORD
APIENTRY
TcQueryInterface(    
    IN      HANDLE      IfcHandle,
    IN      LPGUID      pGuidParam,
    IN      BOOLEAN     NotifyChange,
    IN OUT  PULONG      pBufferSize,
    OUT     PVOID       Buffer 
    )
{
    DWORD                   Status;
    PINTERFACE_STRUC        pInterface;
    WMIHANDLE               hWmiHandle;
    TCHAR                   cstr[MAX_STRING_LENGTH];
    PWNODE_SINGLE_INSTANCE  pWnode;
    ULONG                   cBufSize;
    ULONG                   InputBufferSize;
    

    IF_DEBUG(CALLS) {
        WSPRINT(("==>TcQueryInterface: Called: Name=%d\n", 
                 IfcHandle));
    }
    
    VERIFY_INITIALIZATION_STATUS;
        
    if (IsBadWritePtr(pBufferSize, sizeof(ULONG))) {
        
        return ERROR_INVALID_PARAMETER;
        
    }

    __try {
        
        InputBufferSize = *pBufferSize;
        *pBufferSize = 0;
        
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        
        Status = GetExceptionCode();
        
        IF_DEBUG(ERRORS) {
            WSPRINT(("TcModifyFlow: Exception Error: = 0x%X\n", 
                       Status ));
        }      

        return Status;
    }

    if (IsBadReadPtr(pGuidParam,sizeof(GUID))) {
        
        return ERROR_INVALID_PARAMETER;
    }

    if (    (InputBufferSize != 0) 
        &&  (IsBadWritePtr(Buffer,InputBufferSize)) ) 
    {
        return ERROR_INVALID_PARAMETER;
    }

    pInterface = (PINTERFACE_STRUC)GetHandleObjectWithRef(IfcHandle, 
                                                          ENUM_INTERFACE_TYPE, 'TCQI');

    if (pInterface == NULL) {
        
        return ERROR_INVALID_HANDLE;
    }
    

    Status = WmiOpenBlock( pGuidParam,    // object
                           0,            // access
                           &hWmiHandle
                           );
    
    if (ERROR_FAILED(Status)) {

        TC_TRACE(ERRORS, ("[TcQueryInterface]: WmiOpenBlock failed with %x \n", Status));
        REFDEL(&pInterface->RefCount, 'TCQI');
        
        return Status;
    }

    //
    // allocate memory for the output wnode
    //
    
    cBufSize =    sizeof(WNODE_SINGLE_INSTANCE) 
                + InputBufferSize 
                + MAX_STRING_LENGTH * sizeof(TCHAR);
    
    AllocMem(&pWnode, cBufSize);
    
    if (pWnode == NULL) {
        
        Status = ERROR_NOT_ENOUGH_MEMORY;

    } else {
        
        //
        // query for the single instance
        //

#ifndef UNICODE
            
        if (-1 == wcstombs(cstr, 
                           pInterface->pTcIfc->InstanceName, 
                           pInterface->pTcIfc->InstanceNameLength
                           )) 
        {
            Status = ERROR_NO_UNICODE_TRANSLATION;
        }
        else 
        {

            Status = WmiQuerySingleInstance( hWmiHandle,
                                             cstr,
                                             &cBufSize,
                                             pWnode
                                             );
        }
#else

        Status = WmiQuerySingleInstance( hWmiHandle,
                                         pInterface->pTcIfc->InstanceName,
                                         &cBufSize,
                                         pWnode
                                         );
#endif


        if (!ERROR_FAILED(Status)) 
        {
            Status = WmiNotificationRegistration(pGuidParam,
                                                 NotifyChange,
                                                 CbWmiParamNotification,
                                                 PtrToUlong(IfcHandle),
                                                 NOTIFICATION_CALLBACK_DIRECT
                                                 );

            if (Status == ERROR_WMI_ALREADY_DISABLED ||
                Status == ERROR_WMI_ALREADY_ENABLED) {
                
                //
                // ignore these errors, we assumed it's okay
                //
                
                Status = NO_ERROR;
            }

            //
            // Now that we are registered with WMI - add it OR delete it from our list. (258218)
            //
            
            if (NotifyChange) {
                
                if (!TcipAddToNotificationList(
                                               pGuidParam,
                                               pInterface,
                                               0
                                               )) {
                    //
                    // Failed to put it on the list for some reason..
                    //
                    TC_TRACE(ERRORS, ("[TcQueryInterface]: Could not add the GUID/IFC to private list \n"));
                    
                }
            } else {
                    
                if (!TcipDeleteFromNotificationList(
                                                    pGuidParam,
                                                    pInterface,
                                                    0
                                                    )) {
                    //
                    // Failed to remove it from the list for some reason..
                    //
                    TC_TRACE(ERRORS, ("[TcQueryInterface]: Could not remove the GUID/IFC from private list \n"));

                }

            }
                
        }

        if (!ERROR_FAILED(Status)) {

            //
            // parse the wnode
            //

            //
            // check to see if the user allocated enough space for the 
            // returned buffer
            //

            if (pWnode->SizeDataBlock <= InputBufferSize) {
                
                __try {

                    RtlCopyMemory(Buffer,
                                  (PBYTE)OffsetToPtr(pWnode, pWnode->DataBlockOffset),
                                  pWnode->SizeDataBlock
                                  );

                    *pBufferSize = pWnode->SizeDataBlock;

                } __except (EXCEPTION_EXECUTE_HANDLER) {
                    
                    Status = GetExceptionCode();
                    
                    TC_TRACE(ERRORS, ("[TcQueryInterface]: Exception 0x%x while copying data \n", Status));
                }

            } else {

                //
                // output buffer too small
                //

                Status = ERROR_INSUFFICIENT_BUFFER;
                
                __try {
                
                    *pBufferSize = pWnode->SizeDataBlock;
                    
                } __except (EXCEPTION_EXECUTE_HANDLER) {
                    
                    Status = GetExceptionCode();
                   
               }
            }
        }
    }
    
    WmiCloseBlock(hWmiHandle);

    if (pWnode)
        FreeMem(pWnode);

    REFDEL(&pInterface->RefCount, 'TCQI');

    IF_DEBUG(CALLS) {
        WSPRINT(("<==TcQueryInterface: Returned= 0x%X\n", Status ));
    }

    return Status;
}

/*
************************************************************************

Description:

    Sends a WMI set on the GUID with the instance name.
    Not all propertied are writeable.

Arguments:
    IfcHandle    - interface handle to set the property on
    pGuidParam    - GUID of the property
    BufferSize    - allocate buffer size
    Buffer        - buffer that contains the data to be set

Return Value:

    NO_ERROR
    ERROR_INVALID_HANDLE        bad interface handle
    ERROR_INVALID_PARAMETER        bad parameter 
    ERROR_NOT_SUPPORTED            unsupported GUID
    ERROR_WRITE_PROTECT            GUID is read-only

************************************************************************
*/
DWORD
APIENTRY
TcSetInterface(    
    IN         HANDLE         IfcHandle,
    IN        LPGUID        pGuidParam,
    IN         ULONG        BufferSize,
    IN        PVOID        Buffer
    )
{
    DWORD                    Status;
    PINTERFACE_STRUC        pInterface;
    WMIHANDLE                hWmiHandle;
    TCHAR                    cstr[MAX_STRING_LENGTH];
    PWNODE_SINGLE_INSTANCE    pWnode;
    ULONG                    cBufSize;

    VERIFY_INITIALIZATION_STATUS;


    if (    IsBadReadPtr(pGuidParam,sizeof(GUID)) 
        ||  (BufferSize == 0) 
        ||  IsBadReadPtr(Buffer,BufferSize)) {

        return ERROR_INVALID_PARAMETER;
    }

    pInterface = (PINTERFACE_STRUC)GetHandleObjectWithRef(IfcHandle, 
                                                   ENUM_INTERFACE_TYPE, 'TCSI');

    if (pInterface == NULL) {
        
        return ERROR_INVALID_HANDLE;
    }

    __try {
        
        Status = WmiOpenBlock( pGuidParam,    // object
                           0,            // access
                           &hWmiHandle
                           );
        
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        
          Status = GetExceptionCode();
        
          IF_DEBUG(ERRORS) {
              WSPRINT(("TcSetInterface: Exception Error: = 0x%X\n", 
                       Status ));
          }

          REFDEL(&pInterface->RefCount, 'TCSI'); 
          return Status;
    }


    if (ERROR_FAILED(Status)) {
        
        TC_TRACE(ERRORS, ("[TcSetInterface]: WmiOpenBlock failed with error 0x%x \n", Status));
        REFDEL(&pInterface->RefCount, 'TCSI');

        return Status;
    }

    //
    // allocate memory for the output wnode
    //
    
    cBufSize = sizeof(WNODE_SINGLE_INSTANCE) 
        + BufferSize 
        + MAX_STRING_LENGTH * sizeof(TCHAR);
    
    AllocMem(&pWnode, cBufSize);
    
    if (pWnode == NULL) {
        
        Status = ERROR_NOT_ENOUGH_MEMORY;

    } else {

        //
        // set the single instance
        //

        __try {
        
#ifndef UNICODE

            if (-1 == wcstombs(cstr, 
                           pInterface->pTcIfc->InstanceName, 
                           pInterface->pTcIfc->InstanceNameLength
                           )) {
            
                Status = ERROR_NO_UNICODE_TRANSLATION;
            
            }
            else {

            
                Status = WmiSetSingleInstance( hWmiHandle,
                                           cstr,
                                           1,
                                           BufferSize,
                                           Buffer
                                           );
            }
#else
            Status = WmiSetSingleInstance( hWmiHandle,
                                       pInterface->pTcIfc->InstanceName,
                                       1,
                                       BufferSize,
                                       Buffer
                                       );
            
#endif
        } __except (EXCEPTION_EXECUTE_HANDLER) {
        
            Status = GetExceptionCode();
        
            IF_DEBUG(ERRORS) {
                WSPRINT(("TcSetInterface: Exception Error: = 0x%X\n", 
                       Status ));
            }           
        }
    }

    WmiCloseBlock(hWmiHandle);

    if (pWnode)
        FreeMem(pWnode);

    REFDEL(&pInterface->RefCount, 'TCSI');

    return Status;
}




/*
************************************************************************

Description:

    Will issue a WMI query on the specific flow instance name.

Arguments:

    pFlowName    - flow instance name
    pGuidParam    - GUID of the queried property
    BufferSize    - size of allocated buffer
    Buffer         - the buffer for returned result

Return Value:

    NO_ERROR
    ERROR_INVALID_PARAMETER        bad parameter 
    ERROR_INSUFFICIENT_BUFFER    buffer too small for result
    ERROR_NOT_SUPPORTED            unsupported GUID
    ERROR_WMI_GUID_NOT_FOUND    
    ERROR_WMI_INSTANCE_NOT_FOUND

************************************************************************
*/
DWORD
APIENTRY
TcQueryFlowW(
    IN      LPWSTR      pFlowName,
    IN      LPGUID      pGuidParam,
    IN OUT  PULONG      pBufferSize,
    OUT     PVOID       Buffer 
    )
{
    DWORD                   Status;
    HANDLE                  hWmiHandle;
    TCHAR                   cstr[MAX_STRING_LENGTH];
    PWNODE_SINGLE_INSTANCE  pWnode;
    ULONG                   cBufSize;
    ULONG                   InputBufferSize;
    
   
    if (IsBadWritePtr(pBufferSize, sizeof(ULONG)))
    {
        return ERROR_INVALID_PARAMETER;
    }

    __try {

        InputBufferSize = *pBufferSize;
        *pBufferSize = 0;
        
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        
          Status = GetExceptionCode();
        
          IF_DEBUG(ERRORS) {
              WSPRINT(("TcSetFlowW: Exception Error: = 0x%X\n", 
                       Status ));
          }
  
          return Status;
    }
   
    if (    IsBadReadPtr(pGuidParam, sizeof(GUID))
        ||  IsBadStringPtr(pFlowName, MAX_STRING_LENGTH)
        ||  IsBadWritePtr(Buffer,InputBufferSize) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    Status = WmiOpenBlock(pGuidParam,    // object
                          0,            // access
                          &hWmiHandle);

    if (ERROR_FAILED(Status)) {

        TC_TRACE(ERRORS, ("[TcQueryInterface]: WmiOpenBlock Error: = 0x%X\n", Status ));
        return Status;
    }

    //
    // allocate memory for the output wnode
    //
    
    cBufSize = sizeof(WNODE_SINGLE_INSTANCE) 
        + InputBufferSize
        + MAX_STRING_LENGTH * sizeof(TCHAR);
    
    AllocMem(&pWnode, cBufSize);
    
    if (pWnode == NULL) {

        Status = ERROR_NOT_ENOUGH_MEMORY;
    } 
    else 
    {

        //
        // query for the single instance
        //


#ifndef UNICODE

        if (-1 == wcstombs(cstr,
                           pFlowName,
                           wcslen(pFlowName)
                           )) 
        {
            Status = ERROR_NO_UNICODE_TRANSLATION;
        } 
        else 
        {

            Status = WmiQuerySingleInstance( hWmiHandle,
                                             cstr,
                                             &cBufSize,
                                             pWnode
                                             );
        }
#else

        Status = WmiQuerySingleInstance( hWmiHandle,
                                         pFlowName,
                                         &cBufSize,
                                         pWnode
                                         );
#endif

        if (!ERROR_FAILED(Status)) {

            //
            // parse the wnode
            //


            //
            // check to see if the user allocated enough space for the 
            // returned buffer
            //

            if (pWnode->SizeDataBlock <= InputBufferSize) {

                __try {

                    RtlCopyMemory(Buffer,
                                  (PBYTE)OffsetToPtr(pWnode, pWnode->DataBlockOffset),
                                  pWnode->SizeDataBlock
                                  );

                    *pBufferSize = pWnode->SizeDataBlock;

                } __except (EXCEPTION_EXECUTE_HANDLER) {
                    
                    Status = GetExceptionCode();
                    
                    TC_TRACE(ERRORS, ("[TcQueryInterface]: RtlCopyMemory Exception Error: = 0x%X\n", Status ));
                }

            } else {

                //
                // output buffer too small
                //
                __try {
                    *pBufferSize = pWnode->SizeDataBlock;
                 
                    Status = ERROR_INSUFFICIENT_BUFFER;
                    
                } __except (EXCEPTION_EXECUTE_HANDLER) {
                    
                    Status = GetExceptionCode();
                    
                    TC_TRACE(ERRORS, ("[TcQueryInterface]: RtlCopyMemory Exception Error: = 0x%X\n", Status ));
                }
            }
        }
    }

    WmiCloseBlock(hWmiHandle);

    if(pWnode)
        FreeMem(pWnode);

    return Status;
}


/*
************************************************************************

Description:

    The ANSI version of TcQueryFlowW

Arguments:

    See TcQueryFlowW

Return Value:

    See TcQueryFlowW

************************************************************************
*/
DWORD
APIENTRY
TcQueryFlowA(
    IN         LPSTR        pFlowName,
    IN        LPGUID        pGuidParam,
    IN OUT    PULONG        pBufferSize,
    OUT        PVOID        Buffer 
    )
{
    LPWSTR    pWstr = NULL;
    int     l;
    DWORD    Status;

    if (IsBadStringPtrA(pFlowName,MAX_STRING_LENGTH)) {
        
        return ERROR_INVALID_PARAMETER;
    }


    l = strlen(pFlowName) + 1;

    AllocMem(&pWstr, l*sizeof(WCHAR));

    if (pWstr == NULL) {

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if (-1 == mbstowcs(pWstr, pFlowName, l)) {
            
        FreeMem(pWstr);
        return ERROR_NO_UNICODE_TRANSLATION;

    }


    Status = TcQueryFlowW(pWstr,
                          pGuidParam,
                          pBufferSize,
                          Buffer
                          );

    FreeMem(pWstr);

    return Status;
}



/*
************************************************************************

Description:

    Will issue a WMI set on the specific flow instance name.

Arguments:

    pFlowName    - flow instance name
    pGuidParam    - GUID of the queried property
    BufferSize    - size of allocated buffer
    Buffer         - the buffer to set

Return Value:

    NO_ERROR
    ERROR_INVALID_PARAMETER        bad parameter 
    ERROR_INSUFFICIENT_BUFFER    buffer too small for result
    ERROR_NOT_SUPPORTED            unsupported GUID
    ERROR_WMI_GUID_NOT_FOUND    
    ERROR_WMI_INSTANCE_NOT_FOUND

************************************************************************
*/
DWORD
APIENTRY
TcSetFlowW(
    IN      LPWSTR      pFlowName,
    IN      LPGUID      pGuidParam,
    IN      ULONG       BufferSize,
    IN      PVOID       Buffer 
    )
{
    DWORD                   Status;
    HANDLE                  hWmiHandle;
    TCHAR                   cstr[MAX_STRING_LENGTH];
    PWNODE_SINGLE_INSTANCE  pWnode;
    ULONG                   cBufSize;

    if (    IsBadStringPtr(pFlowName,MAX_STRING_LENGTH) 
        ||  IsBadReadPtr(pGuidParam,sizeof(GUID)) 
        ||  (BufferSize == 0)
        ||  IsBadReadPtr(Buffer,BufferSize)) {

        return ERROR_INVALID_PARAMETER;
    
    }

    Status = WmiOpenBlock( pGuidParam,    // object
                           0,            // access
                           &hWmiHandle
                           );
       
    if (ERROR_FAILED(Status)) {

        TC_TRACE(ERRORS, ("[TcSetFlow]: WmiOpenBlock failed with 0x%x \n", Status));
        return Status;
    }

    //
    // allocate memory for the output wnode
    //
    
    cBufSize = sizeof(WNODE_SINGLE_INSTANCE) 
        + BufferSize 
        + MAX_STRING_LENGTH * sizeof(TCHAR);

     
    AllocMem(&pWnode, cBufSize);
    
    if (pWnode == NULL) {
        
        Status = ERROR_NOT_ENOUGH_MEMORY;

    } else {

        //
        // set the single instance
        //

        __try {
#ifndef UNICODE

            if (-1 == wcstombs(cstr,
                           pFlowName,
                           wcslen(pFlowName)
                           )) {

                Status = ERROR_NO_UNICODE_TRANSLATION;
            
            } else {            

                Status = WmiQuerySingleInstance( hWmiHandle,
                                             cstr,
                                             &cBufSize,
                                             pWnode
                                             );
            }
#else
            Status = WmiSetSingleInstance( hWmiHandle,
                                       pFlowName,
                                       1,
                                       BufferSize,
                                       Buffer
                                       );
#endif
        } __except (EXCEPTION_EXECUTE_HANDLER) {
        
            Status = GetExceptionCode();
        
            IF_DEBUG(ERRORS) {
                WSPRINT(("TcSetFlowW: Exception Error: = 0x%X\n", 
                       Status ));
            }
  
        }

    }

    WmiCloseBlock(hWmiHandle);

    if (pWnode)
        FreeMem(pWnode);

    return Status;
}




/*
************************************************************************

Description:

    The ANSI version of TcSetFlowW

Arguments:

    See TcSetFlowW

Return Value:

    See TcSetFlowW

************************************************************************
*/ 
DWORD
APIENTRY
TcSetFlowA(
    IN      LPSTR       pFlowName,
    IN      LPGUID      pGuidParam,
    IN      ULONG       BufferSize,
    IN      PVOID       Buffer 
    )
{
    LPWSTR  pWstr;
    int     l;
    DWORD   Status;

    if (IsBadStringPtrA(pFlowName,MAX_STRING_LENGTH)) {
        
        return ERROR_INVALID_PARAMETER;
    }

    l = strlen(pFlowName) + 1;

    AllocMem(&pWstr, l*sizeof(WCHAR));

    if (pWstr == NULL) {

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if(-1 == mbstowcs(pWstr, pFlowName, l)) {
        // couldn't convert some multibyte characters - bail with error.
        
        FreeMem(pWstr);
        return ERROR_NO_UNICODE_TRANSLATION;
    }
     

    Status = TcSetFlowW(pWstr,
                        pGuidParam,
                        BufferSize,
                        Buffer
                        );

    FreeMem(pWstr);

    return Status;
}



/*
************************************************************************

Description:

    Will return the flow inatsnace name associated with the flow handle.

Arguments:

    FlowHandle  - the flow handle
    StrSize        - how many TCHAR can fit in the string buffer
    pFlowName    - a pointer to a string buffer

Return Value:

    See TcGetFlowNameW

************************************************************************
*/
DWORD
APIENTRY
TcGetFlowNameW(
    IN        HANDLE            FlowHandle,
    IN        ULONG            StrSize,
    OUT        LPWSTR            pFlowName
    )
{
    PFLOW_STRUC        pFlow;
    DWORD           Status;

    VERIFY_INITIALIZATION_STATUS;

    if (IsBadWritePtr(pFlowName,StrSize*sizeof(WCHAR))) {
    
        return ERROR_INVALID_PARAMETER;
    }
    
    pFlow = (PFLOW_STRUC)GetHandleObjectWithRef(FlowHandle, ENUM_GEN_FLOW_TYPE, 'TGFW');

    if (pFlow == NULL) {
        
        return ERROR_INVALID_HANDLE;
    }
    else if (pFlow == INVALID_HANDLE_VALUE ) 
    {
    
        Status = ERROR_NOT_READY;
        
        IF_DEBUG(ERRORS) {
            WSPRINT(("TcGetFlowNameW: Error = 0x%X\n", Status ));
        }

        return ERROR_NOT_READY;
    }

    ASSERT((HANDLE)pFlow->ClHandle == FlowHandle);

    if (pFlow->InstanceNameLength+sizeof(WCHAR) > (USHORT)StrSize) {

        //IF_DEBUG(REFCOUNTS) { WSPRINT(("8\n"));
        IF_DEBUG(REFCOUNTS) { 
            WSPRINT(("8 DEREF FLOW %X (%X) ref(%d)\n", pFlow->ClHandle, pFlow, pFlow->RefCount)); 
        }
        REFDEL(&pFlow->RefCount, 'TGFW');

        return ERROR_INSUFFICIENT_BUFFER;
    }

    __try {

        wcscpy(pFlowName, pFlow->InstanceName);

    } __except (EXCEPTION_EXECUTE_HANDLER) {

          Status = GetExceptionCode();
          
          IF_DEBUG(ERRORS) {
              WSPRINT(("TcGetFlowName: Exception Error: = 0x%X\n", Status ));
          }
      
          REFDEL(&pFlow->RefCount, 'TGFW');
      
          return Status;
    }


    IF_DEBUG(REFCOUNTS) { 
        WSPRINT(("9 DEREF FLOW %X (%X) ref(%d)\n", pFlow->ClHandle, pFlow, pFlow->RefCount)); 
    }

    REFDEL(&pFlow->RefCount, 'TGFW');
    
    return NO_ERROR;
}




/*
************************************************************************

Description:

    The ANSI version of TcGetFlowNameW

Arguments:

    See TcGetFlowNameW

Return Value:

    See TcGetFlowNameW

************************************************************************
*/
DWORD
APIENTRY
TcGetFlowNameA(
    IN        HANDLE            FlowHandle,
    IN        ULONG            StrSize,
    OUT        LPSTR            pFlowName
    )
{
    PFLOW_STRUC        pFlow;
    DWORD           Status = NO_ERROR;

    VERIFY_INITIALIZATION_STATUS;

    if (IsBadWritePtr(pFlowName,StrSize * sizeof(CHAR))) {

        return ERROR_INVALID_PARAMETER;
    }
    
    pFlow = (PFLOW_STRUC)GetHandleObjectWithRef(FlowHandle, ENUM_GEN_FLOW_TYPE, 'TGFA');

    if (pFlow == NULL) {
        
        return ERROR_INVALID_HANDLE;
    }
    else if (pFlow == INVALID_HANDLE_VALUE ) 
    {
    
        Status = ERROR_NOT_READY;
        
        IF_DEBUG(ERRORS) {
            WSPRINT(("TcGetFlowNameA: Error = 0x%X\n", Status ));
        }

        return ERROR_NOT_READY;
    }

    ASSERT((HANDLE)pFlow->ClHandle == FlowHandle);

    if (pFlow->InstanceNameLength+sizeof(CHAR) > (USHORT)StrSize) {

        IF_DEBUG(REFCOUNTS) { 
            WSPRINT(("11 DEREF FLOW %X (%X) ref(%d)\n", pFlow->ClHandle, pFlow, pFlow->RefCount)); 
        }
        REFDEL(&pFlow->RefCount, 'TGFA');

        return ERROR_INSUFFICIENT_BUFFER;
    }

    __try {

        if (-1 == wcstombs(
                           pFlowName, 
                           pFlow->InstanceName, 
                           pFlow->InstanceNameLength)) {

            Status = ERROR_NO_UNICODE_TRANSLATION;

        }


    } __except (EXCEPTION_EXECUTE_HANDLER) {

          Status = GetExceptionCode();

          IF_DEBUG(ERRORS) {
              WSPRINT(("TcGetFlowName: Exception Error: = 0x%X\n", Status ));
          }
          
          REFDEL(&pFlow->RefCount, 'TGFA');
          
          return Status;
    }



    IF_DEBUG(REFCOUNTS) { 
        WSPRINT(("12 DEREF FLOW %X (%X) ref(%d)\n", pFlow->ClHandle, pFlow, pFlow->RefCount)); 
    }
    
    REFDEL(&pFlow->RefCount, 'TGFA');

    return Status;
}




/*
************************************************************************

Description:

    This will return a specified number of flows with their respective
    filter, given the buffer is big enough. The user allocates the buffer,
    and passes a pointer to an enumeration token. This will be used
    by the GPC to keep track what was the last enumerated flow and will 
    initially be point to a NULL value (reset by TC_RESET_ENUM_TOKEN).
    The user will also pass the number of requested flow and will get back 
    the actual number of flows that have been placed in the buffer.
    If the buffer is too small, an error code will be returned. If there are
    no more flows to enumerate, NO_ERROR will be returned and pFlowCount
    will be set to zero. It is invalid to request zero flows

Arguments:

    IfcHandle    - the interface to enumerate flows on
    pEnumToken    - enumeration handles pointer, 
                  user must not change after the first call
    pFlowCount    - in: # of requested flows; out: actual # of flows returned
    pBufSize    - in: allocated bytes; out: filled bytes
    Buffer        - formatted data

Return Value:

    NO_ERROR
    ERROR_INVALID_HANDLE        bad interface handle
    ERROR_INVALID_PARAMETER        one of the pointers is null or either
                                pFlowCount or pBufSize are set to zero
    ERROR_INSUFFICIENT_BUFFER    indicates that the provided buffer is too 
                                small to return even the information for a 
                                single flow and the attached filters.
    ERROR_NOT_ENOUGH_MEMORY        out of memory
    ERROR_INVALID_DATA            enumeration handle no longer valid

************************************************************************
*/
DWORD
APIENTRY
TcEnumerateFlows(    
    IN      HANDLE              IfcHandle,
    IN OUT  PHANDLE             pEnumHandle,
    IN OUT  PULONG              pFlowCount,
    IN OUT  PULONG              pBufSize,
    OUT     PENUMERATION_BUFFER Buffer
    )
{
    DWORD                   Status;
    PINTERFACE_STRUC        pInterface;
    PGPC_ENUM_CFINFO_RES    OutBuffer;
    ULONG                   cFlows;
    ULONG                   BufSize;
    ULONG                   TotalFlows;
    ULONG                   TotalBytes;
    PFLOW_STRUC             pFlow;
    PGPC_CLIENT             pGpcClient;
    PLIST_ENTRY             pHead, pEntry;
    GPC_HANDLE              GpcFlowHandle;
    PGPC_ENUM_CFINFO_BUFFER pGpcEnumBuf;
    PCF_INFO_QOS            pCfInfo;
    ULONG                   Len, i, j;
    ULONG                   GenFlowSize;
    PCHAR                   p;
    BOOLEAN                 bMore;
    PTC_GEN_FILTER          pFilter;
    PGPC_GEN_PATTERN        pPattern;

    ULONG                   InputBufSize;
    ULONG                   InputFlowCount;

    VERIFY_INITIALIZATION_STATUS;

    IF_DEBUG(CALLS) {
        WSPRINT(("==>TcEnumerateFlows: Called: IfcHandle= %d", 
                 IfcHandle  ));
    }


    if (    IsBadWritePtr(pBufSize, sizeof(ULONG))
        ||  IsBadWritePtr(pFlowCount, sizeof(ULONG))
        ||  IsBadWritePtr(pEnumHandle,sizeof(HANDLE)) ) {

        return ERROR_INVALID_PARAMETER;

    }

    __try {
    
        InputBufSize    = *pBufSize;
       // *pBufSize      = 0; // reset it in case of an error
        InputFlowCount  = *pFlowCount;
        GpcFlowHandle   = *pEnumHandle;
                    
    } __except (EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode();              
        
        return Status;
    }

    if (    IsBadWritePtr(Buffer, InputBufSize)
        ||  (InputFlowCount == 0) ) {

	return ERROR_INVALID_PARAMETER;

    }

    if (InputBufSize == 0) {

        return ERROR_INSUFFICIENT_BUFFER;

    }
    
    pInterface = (PINTERFACE_STRUC)GetHandleObjectWithRef(IfcHandle, 
                                                   ENUM_INTERFACE_TYPE, 'TCEF');

    if (pInterface == NULL) {
        
        return ERROR_INVALID_HANDLE;
    }

   
    pGpcClient = FindGpcClient(GPC_CF_QOS);

    if (pGpcClient == NULL) {
        
        REFDEL(&pInterface->RefCount, 'TCEF');

        return ERROR_DEV_NOT_EXIST;
    }

    //
    // We are enumerating flows on the interface. we cant afford to have the
    // flows deleted from teh list, therefore we shall take the global lock here.
    //
    GetLock(pGlobals->Lock);

    // back to regularly scheduled programming

    TotalFlows = 0;
    TotalBytes = 0;

    bMore = TRUE;

    while (bMore) {

        BufSize = InputBufSize - TotalBytes;
        cFlows = InputFlowCount - TotalFlows;
        
        Status = IoEnumerateFlows(pGpcClient,
                                  &GpcFlowHandle,
                                  &cFlows,
                                  &BufSize,
                                  &OutBuffer
                                  );
    
        if (!ERROR_FAILED(Status)) {

            //
            // parse the output buffer and return only the flows that have the 
            // interface name in them
            //

            pGpcEnumBuf = &OutBuffer->EnumBuffer[0];
            
            for (i = 0; i < cFlows; i++) {

                //
                // get the CfInfo
                //
                
                pCfInfo = (PCF_INFO_QOS)((PCHAR)pGpcEnumBuf + 
                                         pGpcEnumBuf->CfInfoOffset);

                //
                // check if this flow belongs to this interface
                //

                if (wcscmp(pCfInfo->InstanceName,
                           pInterface->pTcIfc->InstanceName) == 0) {

                    //
                    // the flow is installed on this instance
                    //

                    GenFlowSize = FIELD_OFFSET(TC_GEN_FLOW, TcObjects)
                        + pCfInfo->GenFlow.TcObjectsLength;

                    //
                    // The GPC used GPC_GEN_PATTERN when it computed 
                    // PatternMaskLen. But, we are using TC_GEN_FILTER
                    // to display the patterns. So, we need to account 
                    // for the difference in GPC_GEN_PATTERN and 
                    // TC_GEN_FILTER.
                    //
                    // No, this cannot be made cleaner by getting the GPC
                    // to use TC_GEN_FILTER. The GPC is a generic packet 
                    // classifier and hence shouldn't know about TC_GEN_FILTER.
                    //

                    Len = FIELD_OFFSET(ENUMERATION_BUFFER, GenericFilter)
                        + GenFlowSize
                        + pGpcEnumBuf->PatternMaskLen
                        - pGpcEnumBuf->PatternCount * sizeof(GPC_GEN_PATTERN) 
                        + pGpcEnumBuf->PatternCount * sizeof(TC_GEN_FILTER);

                    Len = ((Len + (sizeof(PVOID)-1)) & ~(sizeof(PVOID)-1));

                    if (TotalBytes + Len > InputBufSize) {
                        
                        //
                        // not enough buffer output space
                        //
                        
                        if (TotalFlows == 0) 
                            Status = ERROR_INSUFFICIENT_BUFFER;
                        
                        bMore = FALSE;
                        break;
                    }
                    
                    //
                    // fill the output buffer
                    //

                    __try {
                    
                        Buffer->Length = Len;
                        Buffer->OwnerProcessId = PtrToUlong(pGpcEnumBuf->OwnerClientCtx);
                        Buffer->FlowNameLength = pGpcEnumBuf->InstanceNameLength;
                        wcscpy(Buffer->FlowName, pGpcEnumBuf->InstanceName);
                        Buffer->NumberOfFilters = pGpcEnumBuf->PatternCount;
                        pFilter = (PTC_GEN_FILTER)
                            ((PCHAR)Buffer
                             + FIELD_OFFSET(ENUMERATION_BUFFER, GenericFilter));
                        
                    } __except (EXCEPTION_EXECUTE_HANDLER) {

                        Status = GetExceptionCode();              
        
                        break;
                    }

                    pPattern = &pGpcEnumBuf->GenericPattern[0];

                    //
                    // fill the filters
                    //

                    for (j = 0; j < pGpcEnumBuf->PatternCount; j++) {

                        switch(pPattern->ProtocolId) {

                        case GPC_PROTOCOL_TEMPLATE_IP:
                            
                            pFilter->AddressType = NDIS_PROTOCOL_ID_TCP_IP;
                            ASSERT(pPattern->PatternSize 
                                   == sizeof(IP_PATTERN));
                            break;

                        case GPC_PROTOCOL_TEMPLATE_IPX:
                            
                            pFilter->AddressType = NDIS_PROTOCOL_ID_IPX;
                            ASSERT(pPattern->PatternSize 
                                   == sizeof(IPX_PATTERN));
                            break;

                        default:
                            ASSERT(0);
                        }

                        pFilter->PatternSize = pPattern->PatternSize ;
                        pFilter->Pattern = (PVOID)((PCHAR)pFilter 
                                                   + sizeof(TC_GEN_FILTER));
                        pFilter->Mask = (PVOID)((PCHAR)pFilter->Pattern
                                                + pPattern->PatternSize);

                        //
                        // copy the pattern
                        //

                        p = ((PUCHAR)pPattern) + pPattern->PatternOffset;

                        RtlCopyMemory(pFilter->Pattern, 
                                      p, 
                                      pPattern->PatternSize);

                        //
                        // copy the mask
                        //

                        p = ((PUCHAR)pPattern) + pPattern->MaskOffset;

                        RtlCopyMemory(pFilter->Mask, 
                                      p, 
                                      pPattern->PatternSize);

                        //
                        // advance the filter pointer to the next item
                        //

                        pFilter = (PTC_GEN_FILTER)
                            ((PCHAR)pFilter
                             + sizeof(TC_GEN_FILTER)
                             + pPattern->PatternSize * 2);

                        pPattern = (PGPC_GEN_PATTERN)(p + pPattern->PatternSize);

                    } // for (...)

                    //
                    // fill the flow
                    //

                    __try {
                    
                        Buffer->pFlow = (PTC_GEN_FLOW)pFilter;
                        RtlCopyMemory(pFilter, 
                                      &pCfInfo->GenFlow,
                                      GenFlowSize
                                      );

                        //
                        // advance to the next available slot in
                        // the output buffer
                        //

                        Buffer = (PENUMERATION_BUFFER)((PCHAR)Buffer + Len);

                    } __except (EXCEPTION_EXECUTE_HANDLER) {

                        Status = GetExceptionCode();              
        
                        break;
                    }

                    
                    //
                    // update total counts
                    //

                    TotalBytes += Len;
                    TotalFlows++;
                }
                
                //
                // advance to the next entry in the GPC returned buffer
                //

                pGpcEnumBuf = (PGPC_ENUM_CFINFO_BUFFER)((PCHAR)pGpcEnumBuf
                                                        + pGpcEnumBuf->Length);
            }

            //
            // release the buffer 
            //

            FreeMem(OutBuffer);

            //
            // check to see if we still have room for more flows
            // and adjust the call parameters
            //

            if (TotalFlows == InputFlowCount ||
                TotalBytes + sizeof(ENUMERATION_BUFFER) > InputBufSize ) {

                //
                // that's it, stop enumerating here
                //

                break;
            }

            //
            // check the GpcFlowHandle and quit if needed
            //

            if (GpcFlowHandle == NULL) {

                break;
            }

        } else {
            
            //
            // there was some error returned,
            // we still have to check if that's the first call
            // 
            //

            if (Status == ERROR_INVALID_DATA) {
                __try {
                    
                    *pEnumHandle = NULL;
                    
                } __except (EXCEPTION_EXECUTE_HANDLER) {
                
                    Status = GetExceptionCode();              
       
                }

            } else if (TotalFlows > 0) {

                Status = NO_ERROR;

            }

            break;
        }
    } // while

    if (!ERROR_FAILED(Status)) {

        __try {

            *pEnumHandle = GpcFlowHandle;
            *pFlowCount = TotalFlows;
            *pBufSize = TotalBytes;
            
        } __except (EXCEPTION_EXECUTE_HANDLER) {
                
            Status = GetExceptionCode();              

        }        

    } 
    
    //
    // Free all the flow refs taken at the start.
    //
    FreeLock(pGlobals->Lock);

    REFDEL(&pInterface->RefCount, 'TCEF');
    
    IF_DEBUG(CALLS) {
        WSPRINT(("<==TcEnumerateFlows: Returned= 0x%X\n", Status ));
    }
    
    return Status;
}





/*
************************************************************************

Description:

    This call will add a new Class Map flow on the interface.
    
Arguments:

    IfcHandle        - the interface handle to add the flow on
    ClFlowCtx        - a client given flow context
    AddressType        - determines what protocol template to use with the GPC
    Flags            - reserved, will be used to indicate a persistent flow
    pClassMapFlow    - class map flow
    pFlowHandle        - returned flow handle in case of success

Return Value:

    NO_ERROR
    ERROR_SIGNAL_PENDING

    General error codes:

    ERROR_INVALID_HANDLE        bad handle.
    ERROR_NOT_ENOUGH_MEMORY        system out of memory
    ERROR_INVALID_PARAMETER        a general parameter is invalid

    TC specific error codes:

    ERROR_INVALID_TRAFFIC_CLASS invalid traffic class value
    ERROR_NO_SYSTEM_RESOURCES    not enough resources to accommodate flows

************************************************************************
*/
DWORD
APIENTRY
TcAddClassMap(
    IN      HANDLE                 IfcHandle,
    IN        HANDLE                ClFlowCtx,
    IN        ULONG                Flags,
    IN        PTC_CLASS_MAP_FLOW    pClassMapFlow,
    OUT        PHANDLE                pFlowHandle
    )
{
    DWORD                Status;
    PFLOW_STRUC            pFlow;
    PINTERFACE_STRUC    pInterface;
    PCLIENT_STRUC        pClient;
    PGPC_CLIENT            pGpcClient;

    return ERROR_CALL_NOT_IMPLEMENTED;

#if NEVER

    // As this is not published in MSDN and not implemented in PSCHED also

    IF_DEBUG(CALLS) {
        WSPRINT(("==>TcAddClassMap: Called: IfcHandle= %d, ClFlowCtx=%d\n", 
                 IfcHandle, ClFlowCtx ));
    }

    if (pFlowHandle) {
        *pFlowHandle = TC_INVALID_HANDLE;
    }

    VERIFY_INITIALIZATION_STATUS;

    if (pFlowHandle == NULL || pClassMapFlow == NULL) {
        
        Status = ERROR_INVALID_PARAMETER;

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcAddClassMap: Error = 0x%X\n", Status ));
        }

        return Status;
    }

    *pFlowHandle = TC_INVALID_HANDLE;

    pInterface = (PINTERFACE_STRUC)GetHandleObjectWithRef(IfcHandle, 
                                                   ENUM_INTERFACE_TYPE, 'TACM');

    if (pInterface == NULL) {

        Status = ERROR_INVALID_HANDLE;

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcAddClassMap: Error = 0x%X\n", Status ));
        }

        return Status;
    }

    ASSERT((HANDLE)pInterface->ClHandle == IfcHandle);

    //
    // search for an open GPC client that supports this address type
    //

    pGpcClient = FindGpcClient(GPC_CF_CLASS_MAP);

    if (pGpcClient == NULL) {

        //
        // not found!
        //

        Status = ERROR_ADDRESS_TYPE_NOT_SUPPORTED;

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcAddClassMap: Error = 0x%X\n", Status ));
        }

        REFDEL(&pInterface->RefCount, 'TACM');

        return Status;
    }

    //
    // create a new flow structure
    //

    Status = CreateClassMapFlowStruc(ClFlowCtx, pClassMapFlow, &pFlow);

    if (ERROR_FAILED(Status)) {

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcAddClassMap: Error = 0x%X\n", Status ));
        }

        REFDEL(&pInterface->RefCount, 'TACM');

        return Status;
    }

    pClient = pInterface->pClient;

    //
    // initialize the flow structure and add it on the intefrace list
    //

    pFlow->pInterface = pInterface;
    pFlow->Flags = Flags | TC_FLAGS_INSTALLING;
    
    pFlow->pGpcClient = pGpcClient;

    GetLock(pGlobals->Lock);
    InsertTailList(&pInterface->FlowList, &pFlow->Linkage);

    pInterface->FlowCount++;
    REFADD(&pInterface->RefCount, 'FLOW');

    FreeLock(pGlobals->Lock);

    //
    // call to actually add the flow
    //

    Status = IoAddClassMapFlow( pFlow, TRUE );

    if (!ERROR_FAILED(Status)) {

        *pFlowHandle = (HANDLE)pFlow->ClHandle;
    }

    if (!ERROR_PENDING(Status)) {

        //
        // call completed, either success or failure...
        //

        CompleteAddFlow(pFlow, Status);
    }

    //
    // !!! don't reference pFlow after this since it may be gone!!!
    //

    IF_DEBUG(CALLS) {
        WSPRINT(("<==TcAddClassMap: Returned= 0x%X\n", Status ));
    }

    REFDEL(&pInterface->RefCount, 'TACM');

    return Status;
    
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\tc\dll\handles.c ===
/*++
Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    rsvphndls.c

Abstract:

    This file contains the code to create and release handles

Author:

    Jim Stewart (JStew) June 10, 1996

Environment:


Revision History:

	Ofer Bar (oferbar) Oct 1, 1997 - Revision II

--*/

#include "precomp.h"
#pragma hdrstop


PVOID
GetHandleObject(
	IN  HANDLE				h,
    IN  ENUM_OBJECT_TYPE	ObjType
    )
{
    ENUM_OBJECT_TYPE   *p;
    
    GetLock(pGlobals->Lock);
    p = (ENUM_OBJECT_TYPE *)dereference_HF_handle(pGlobals->pHandleTbl, 
                                                  PtrToUlong(h));

    if (p != NULL) {

        //
        // we found a reference for the handle
        // we verify that it's the right object type
        //

        if ((*p & ObjType) == 0) {

            //
            // sorry, wrong type
            //

            p = NULL;
        }
    } else {

        IF_DEBUG(HANDLES) {
            WSPRINT(("The handle (%x) is invalid\n", h));
            DEBUGBREAK();
        }

    }
    
    FreeLock(pGlobals->Lock);

    return (PVOID)p;

}


PVOID
GetHandleObjectWithRef(
	IN  HANDLE					h,
    IN  ENUM_OBJECT_TYPE	    ObjType,
    IN  ULONG                   RefType
    )
{
    ENUM_OBJECT_TYPE   *p, *p1;
    PCLIENT_STRUC       pClient;
    PFILTER_STRUC       pFilter;
    PFLOW_STRUC         pFlow;
    PINTERFACE_STRUC    pInterface;

    GetLock(pGlobals->Lock);

    p = (ENUM_OBJECT_TYPE *) dereference_HF_handle(pGlobals->pHandleTbl, 
                                                   PtrToUlong(h));

    if (p != NULL) {

        //
        // we found a reference for the handle
        // we verify that it's the right object type
        //

        if (*p != ObjType) {

            //
            // sorry, wrong type
            //

            p = NULL;

        }
        
    }

    if (p != NULL) {

        p1 = p;

        switch (ObjType) {
 
        case ENUM_CLIENT_TYPE:

            pClient = (PCLIENT_STRUC)p;
            
            GetLock(pClient->Lock);
            if (QUERY_STATE(pClient->State) == OPEN) {
                REFADD(&pClient->RefCount, RefType);
            } else {
                p = NULL; // we can deref a struct that is not open for business
            }
            FreeLock(pClient->Lock);

            break;
        
        case ENUM_FILTER_TYPE:

            pFilter = (PFILTER_STRUC)p;

            GetLock(pFilter->Lock);
            if (QUERY_STATE(pFilter->State) == OPEN) {
                REFADD(&pFilter->RefCount, RefType);
            } else {
                p = NULL;
            }
            FreeLock(pFilter->Lock);

            break;

        case ENUM_INTERFACE_TYPE:
            
            pInterface = (PINTERFACE_STRUC)p;

            GetLock(pInterface->Lock);
            if (QUERY_STATE(pInterface->State) == OPEN) {
                REFADD(&pInterface->RefCount, RefType);
            } else {
                p = NULL;
            }
            FreeLock(pInterface->Lock);

            break;

        case ENUM_GEN_FLOW_TYPE:

            pFlow = (PFLOW_STRUC)p;

            GetLock(pFlow->Lock);
            
            // Return a HANDLE only if it is in OPEN state
            // Otherwise return INVALID_HANDLE_VALUE so the
            // caller will know that the Flow is not in the 
            // correct state
            if (QUERY_STATE(pFlow->State) == OPEN) 
            {
                REFADD(&pFlow->RefCount, RefType);
            } else 
            {
                p = INVALID_HANDLE_VALUE;
            }
            FreeLock(pFlow->Lock);

            break;
        
        case ENUM_CLASS_MAP_FLOW_TYPE:

            pFlow = (PFLOW_STRUC)p;

            GetLock(pFlow->Lock);
            if (QUERY_STATE(pFlow->State) == OPEN) {
                REFADD(&pFlow->RefCount, RefType);
            } else {
                p = NULL;
            }
            FreeLock(pFlow->Lock);

            break;

        default:
            ASSERT(0);
        
        }

        
        //
        // random debug code - please delete
        //
        IF_DEBUG(HANDLES) {
            if (p1 != p) {
                WSPRINT(("The object being derefed is NOT in OPEN state p1=%x and p=%x\n", p1, p));
                DEBUGBREAK();
            }
        }
        
    } else {
        
        IF_DEBUG(HANDLES) {
            WSPRINT(("The handle (%x) is invalid\n", h));
            DEBUGBREAK();
        }

    }
    
    FreeLock(pGlobals->Lock);

    return (PVOID)p;
}


HANDLE
AllocateHandle(
    IN  PVOID  Context
    )
/*++

Routine Description:

    This function creates a handle.

Arguments:

    Context     - the context value to store with the handle

Return Value:

	The handle factory handle, or NULL in case of en error

--*/
{
    HFHandle	Handle;
    PVOID		VerifyCtx;

    GetLock( pGlobals->Lock );

    Handle = assign_HF_handle(pGlobals->pHandleTbl, Context);

    //
    // verify the handle is valid
    //

    VerifyCtx = dereference_HF_handle(pGlobals->pHandleTbl, Handle);
    ASSERT(VerifyCtx == Context);
    
    IF_DEBUG(HANDLES) {
        WSPRINT(("AllocHandle: (%x) being allocated\n", Handle ));
    }

    FreeLock(pGlobals->Lock);

    return UlongToPtr(Handle);
}



VOID
FreeHandle(
    IN 	HANDLE    Handle
    )
/*++

Routine Description:

    This function frees the handle

Arguments:

    Handle - 

Return Value:

--*/
{
    int  r;

    GetLock( pGlobals->Lock );

    IF_DEBUG(HANDLES) {
        WSPRINT(("FreeHandle (%x) being freed\n", PtrToUlong(Handle) ));
    }

    r = release_HF_handle(pGlobals->pHandleTbl, PtrToUlong(Handle));

    ASSERT(r == 0);

    FreeLock(pGlobals->Lock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\tc\dll\apiutil.c ===
/*++                                   

Copyright (c) 1996-1997 Microsoft Corporation

Module Name:

    apiutil.c

Abstract:

    This module contains the traffic control api utils

Author:

    Jim Stewart ( jstew )    August 22, 1996

Revision History:

        Ofer Bar (oferbar)              Oct 1, 1997
--*/

#include "precomp.h"
#pragma hdrstop

#include <initguid.h>
#define INITGUID
#include "ntddtc.h"


static BOOLEAN _init = FALSE;

#if 0
// Name of the DLL to load
const CHAR  IpHlpApiDllName[] = "iphlpapi";

// Names of the functions called in IPHLPAPI
const CHAR GET_IF_ENTRY[] =         "GetIfEntry";
const CHAR GET_IP_ADDR_TABLE[] =    "GetIpAddrTable";
const CHAR GET_BEST_ROUTE[] =       "GetBestRoute";


 
IPROUTE_IF      IpRouteTab;
#endif

TCHAR   SzBuf[MAX_PATH];

//
VOID
MarkAllNodesForClosing(
                           PINTERFACE_STRUC pInterface,
			   STATE stateToMark
                           )
/*++

Description:
    This routine will mark all flows and filters on a INTERFACE_STRUC (a client's interface struct)
    as close FORCED_KERNELCLOSE or EXIT_CLEANUP. Please note that it is already called with the global lock held.

Arguments:

    pInterface - ptr to the interface
    stateToMark - the state to mark the nodes (FORCED_KERNELCLOSE or EXIT_CLEANUP)

Return Value:

    nothing

--*/

{
    PLIST_ENTRY     pEntry, pFilterEntry;
    PFLOW_STRUC     pFlow;
    PFILTER_STRUC   pFilter;

    ASSERT((stateToMark == FORCED_KERNELCLOSE) || (stateToMark == EXIT_CLEANUP));

    pEntry = pInterface->FlowList.Flink;

    while (pEntry != &pInterface->FlowList) {
        
        pFlow = CONTAINING_RECORD(pEntry, FLOW_STRUC, Linkage);

        //
        // For each flow and filter, first check if the user is trying to close it
        // if that is the case, do nothing, otherwise, mark it 
        GetLock(pFlow->Lock);

        if (QUERY_STATE(pFlow->State) == OPEN) {

            // Cleanup from under teh user...
            SET_STATE(pFlow->State, stateToMark);
            

        } else {

            ASSERT(IsListEmpty(&pFlow->FilterList));
            // There's nothing to be done here.
            IF_DEBUG(WARNINGS) {
                WSPRINT(("Against a forced close - Flow is removed by the user\n", pFlow));

            }
        }

        pFilterEntry = pFlow->FilterList.Flink;

        while (pFilterEntry != &pFlow->FilterList) {

            pFilter = CONTAINING_RECORD(pFilterEntry, FILTER_STRUC, Linkage);

            GetLock(pFilter->Lock);

            if (QUERY_STATE(pFilter->State) == OPEN) {
    
                // Cleanup from under teh user...
                SET_STATE(pFilter->State, stateToMark);                
    
            } else {
    
                // There's nothing to be done here.
                IF_DEBUG(WARNINGS) {
                    WSPRINT(("Against a forced close - Filter is removed by the user\n", pFilter));
    
                }
            }
            
            pFilterEntry = pFilterEntry->Flink;
            FreeLock(pFilter->Lock);

        }

        pEntry = pEntry->Flink;
        FreeLock(pFlow->Lock);
    }

}



VOID
CloseOpenFlows(
    IN PINTERFACE_STRUC   pInterface
    )

/*++

Description:
    This routine closes any flows that are open on an interface.

Arguments:

    pInterface - ptr to the interface

Return Value:

    nothing

--*/
{
    DWORD           Status = NO_ERROR;
    PLIST_ENTRY     pEntry;
    PFLOW_STRUC     pFlow;

    GetLock( pGlobals->Lock );
    
    pEntry = pInterface->FlowList.Flink;

    while (pEntry != &pInterface->FlowList) {
    
        pFlow = CONTAINING_RECORD( pEntry, FLOW_STRUC, Linkage );

        GetLock(pFlow->Lock);

        if ((QUERY_STATE(pFlow->State) == FORCED_KERNELCLOSE) ||
            (QUERY_STATE(pFlow->State) == EXIT_CLEANUP)) {

            pEntry = pEntry->Flink;
            FreeLock(pFlow->Lock);

            IF_DEBUG(SHUTDOWN) {
                WSPRINT(( "Closing Flow: 0x%X\n", pFlow));
            }

            Status = DeleteFlow( pFlow, TRUE );

            IF_DEBUG(SHUTDOWN) {
                WSPRINT(("CloseOpenFlows: DeleteFlow returned=0x%X\n", 
                         Status));
            }

        } else {

            pEntry = pEntry->Flink;
            FreeLock(pFlow->Lock);

        }

    }
    
    FreeLock( pGlobals->Lock );

}



VOID
CloseOpenFilters(
    IN PFLOW_STRUC   pFlow
    )

/*++

Description:
    This routine closes any filters that are open on a flow.

Arguments:

    pFlow - ptr to the flow

Return Value:

    nothing

--*/
{
    DWORD           Status = NO_ERROR;
    PLIST_ENTRY     pEntry;
    PFILTER_STRUC   pFilter;

    IF_DEBUG(SHUTDOWN) {
        WSPRINT(( "CloseOpenFilters: Closing all Open Filters\n" ));
    }

    GetLock( pGlobals->Lock );
    
    pEntry = pFlow->FilterList.Flink;

    while (pEntry != &pFlow->FilterList) {
    
        pFilter = CONTAINING_RECORD( pEntry, FILTER_STRUC, Linkage );

        GetLock(pFilter->Lock);

        if ((QUERY_STATE(pFilter->State) == FORCED_KERNELCLOSE) ||
            (QUERY_STATE(pFilter->State) == EXIT_CLEANUP)) {
        
            // we can take a ref here, but we own it anyways!
            pEntry = pEntry->Flink;
            FreeLock(pFilter->Lock);

            Status = DeleteFilter( pFilter );

            IF_DEBUG(SHUTDOWN) {
                WSPRINT(( "CloseOpenFilters: DeleteFilter returned=0x%X\n",
                          Status));
            }
            //ASSERT(Status == NO_ERROR);

        } else {

            pEntry = pEntry->Flink;
            FreeLock(pFilter->Lock);

            IF_DEBUG(SHUTDOWN) {
                WSPRINT(( "CloseOpenFilters: DeleteFilter (%x) was skipped because its state (%d)\n",
                          pFilter, pFilter->State));
            }

        }
                
    }
        
    FreeLock( pGlobals->Lock );

}



VOID
DeleteFlowStruc(
    IN PFLOW_STRUC  pFlow 
    )

/*++

Description:

    This routine frees the handle and memory associated
    with the structure.

Arguments:

    pFlow      - ptr to the flow

Return Value:

    nothing

--*/
{

    if(pFlow->PendingEvent)
        CloseHandle(pFlow->PendingEvent);    

    DeleteLock(pFlow->Lock);

    if (pFlow->pGenFlow) {
        FreeMem(pFlow->pGenFlow);
        pFlow->GenFlowLen = 0;
    }

    if (pFlow->pGenFlow1) {
        FreeMem(pFlow->pGenFlow1);
        pFlow->GenFlowLen1 = 0;
    }

    if (pFlow->pClassMapFlow)
        FreeMem(pFlow->pClassMapFlow);

    if (pFlow->pClassMapFlow1)
        FreeMem(pFlow->pClassMapFlow1);

    FreeMem(pFlow);
}



VOID
DeleteFilterStruc(
    IN PFILTER_STRUC  pFilter
    )

/*++

Description:

    This routine frees the handle and memory associated
    with the structure.

Arguments:

    pFIlter

Return Value:

    nothing

--*/
{

    if (pFilter->pGpcFilter)
        FreeMem(pFilter->pGpcFilter);

    DeleteLock(pFilter->Lock);

    FreeMem(pFilter);

}




PTC_IFC
GetTcIfc(
        IN LPWSTR       pInterfaceName
    )
{
    PTC_IFC             pIfc = NULL;
    PLIST_ENTRY pHead, pEntry;
    DWORD       Status = NO_ERROR;

    GetLock(pGlobals->Lock);

    pHead = &pGlobals->TcIfcList;

    pEntry = pHead->Flink;

    while (pEntry != pHead && pIfc == NULL) {

        pIfc = CONTAINING_RECORD(pEntry, TC_IFC, Linkage);

        __try {
            
            if (wcsncmp(pInterfaceName,
                        pIfc->InstanceName,
                        wcslen(pIfc->InstanceName)) != 0) {
            
                //
                // not found
                //
                pIfc = NULL;

            }

        } __except (EXCEPTION_EXECUTE_HANDLER) {
      
              Status = GetExceptionCode();

              IF_DEBUG(ERRORS) {
                  WSPRINT(("GetTcIfc: Invalid pInterfaceName(%x) Exception: = 0x%X\n", 
                           pInterfaceName, Status ));
              }
              
              FreeLock(pGlobals->Lock);
              return NULL;
        }

        pEntry = pEntry->Flink;
    }

    FreeLock(pGlobals->Lock);

    return pIfc;
}



PTC_IFC
GetTcIfcWithRef(
        IN LPWSTR       pInterfaceName,
        IN ULONG        RefType
    )
{
    PTC_IFC             pIfc = NULL;
    PLIST_ENTRY pHead, pEntry;
    DWORD       Status = NO_ERROR;

    GetLock(pGlobals->Lock);

    pHead = &pGlobals->TcIfcList;

    pEntry = pHead->Flink;

    while (pEntry != pHead && pIfc == NULL) {

        pIfc = CONTAINING_RECORD(pEntry, TC_IFC, Linkage);

        __try {
            
            if (wcsncmp(pInterfaceName,
                        pIfc->InstanceName,
                        wcslen(pIfc->InstanceName)) != 0) {
            
                //
                // not found
                //
                pIfc = NULL;

            }

        } __except (EXCEPTION_EXECUTE_HANDLER) {
      
              Status = GetExceptionCode();

              IF_DEBUG(ERRORS) {
                  WSPRINT(("GetTcIfc: Invalid pInterfaceName(%x) Exception: = 0x%X\n", 
                           pInterfaceName, Status ));
              }
              
              FreeLock(pGlobals->Lock);
              return NULL;
        }

        pEntry = pEntry->Flink;

    }


    
    if (pIfc) {

        GetLock(pIfc->Lock);

        if (QUERY_STATE(pIfc->State)== OPEN) {

            FreeLock(pIfc->Lock);
            REFADD(&pIfc->RefCount, RefType);
            FreeLock(pGlobals->Lock);
            return pIfc;

        } else {

            FreeLock(pIfc->Lock);
            FreeLock(pGlobals->Lock);
            return NULL;

        }

    } else {
        
        FreeLock(pGlobals->Lock);
        return NULL;

    }

}


DWORD
UpdateTcIfcList(
        IN      LPWSTR                                  InstanceName,
        IN  ULONG                                   IndicationBufferSize,
        IN  PTC_INDICATION_BUFFER   IndicationBuffer,
        IN  DWORD                                   IndicationCode
        )
{
    DWORD                       Status = NO_ERROR;
    PTC_IFC                     pTcIfc;
    ULONG                       l;
    PADDRESS_LIST_DESCRIPTOR    pAddrListDesc;

    switch (IndicationCode) {

    case TC_NOTIFY_IFC_UP:

        //
        // Allocate a new interface descriptor structure
        //
        
        l = IndicationBufferSize 
            - FIELD_OFFSET(TC_INDICATION_BUFFER,InfoBuffer) - FIELD_OFFSET(TC_SUPPORTED_INFO_BUFFER, AddrListDesc);


        CreateKernelInterfaceStruc(&pTcIfc, l);

        if (pTcIfc) {
            
            //
            // copy the instance name string data
            //
                
            wcscpy(pTcIfc->InstanceName, InstanceName);
    
            pTcIfc->InstanceNameLength = wcslen(InstanceName) * sizeof(WCHAR);
    
            //
            // copy the instance ID string data
            //
                
            pTcIfc->InstanceIDLength = IndicationBuffer->InfoBuffer.InstanceIDLength;
    
            memcpy((PVOID)pTcIfc->InstanceID, 
                   (PVOID)IndicationBuffer->InfoBuffer.InstanceID,
                   pTcIfc->InstanceIDLength);
    
            pTcIfc->InstanceID[pTcIfc->InstanceIDLength/sizeof(WCHAR)] = L'\0';
    
            //
            // copy the instance data
            // in this case - the network address
            //
                
            pTcIfc->AddrListBytesCount = l;
    
            RtlCopyMemory( pTcIfc->pAddressListDesc,
                           &IndicationBuffer->InfoBuffer.AddrListDesc, 
                           l );
    
            if (NO_ERROR != GetInterfaceIndex(pTcIfc->pAddressListDesc,
                                              &pTcIfc->InterfaceIndex,
                                              &pTcIfc->SpecificLinkCtx)) {
                pTcIfc->InterfaceIndex  = IF_UNKNOWN;
                pTcIfc->SpecificLinkCtx = IF_UNKNOWN;

            }

            //
            //
            // Add the structure to the global linked list
            //
            GetLock(pTcIfc->Lock);
            SET_STATE(pTcIfc->State, OPEN);
            FreeLock(pTcIfc->Lock);

            GetLock( pGlobals->Lock );
            InsertTailList(&pGlobals->TcIfcList, &pTcIfc->Linkage );
            FreeLock( pGlobals->Lock );

#if 0            
            //
            // there's a new TC inetrface, check the GPC client list
            //
    
            OpenGpcClients(pTcIfc);
#endif
                


        } else {

            Status = ERROR_NOT_ENOUGH_MEMORY;

        }

        break;

    case TC_NOTIFY_IFC_CLOSE:

        pTcIfc = GetTcIfc(InstanceName);
        REFDEL(&pTcIfc->RefCount, 'KIFC');

        break;

    case TC_NOTIFY_IFC_CHANGE:
        
        pTcIfc = GetTcIfc(InstanceName);

        if (pTcIfc == NULL) {

            return Status;
        }

        //
        // copy the instance ID string data
        //
        
        pTcIfc->InstanceIDLength = IndicationBuffer->InfoBuffer.InstanceIDLength;
        
        memcpy(pTcIfc->InstanceID, 
               IndicationBuffer->InfoBuffer.InstanceID,
               pTcIfc->InstanceIDLength);
        
        pTcIfc->InstanceID[pTcIfc->InstanceIDLength/sizeof(WCHAR)] = L'\0';

        l = IndicationBufferSize 
            - FIELD_OFFSET(TC_INDICATION_BUFFER,InfoBuffer) - FIELD_OFFSET(TC_SUPPORTED_INFO_BUFFER, AddrListDesc);

        AllocMem(&pAddrListDesc, l);

        if (pAddrListDesc) {

            //
            // copy the instance data
            // in this case - the network address
            //
            
            RtlCopyMemory( pAddrListDesc,
                           &IndicationBuffer->InfoBuffer.AddrListDesc,
                           l );

            GetLock( pGlobals->Lock );

            FreeMem(pTcIfc->pAddressListDesc);

            pTcIfc->AddrListBytesCount = l;
            pTcIfc->pAddressListDesc = pAddrListDesc;


            if (NO_ERROR != GetInterfaceIndex(pTcIfc->pAddressListDesc,
                                              &pTcIfc->InterfaceIndex,
                                              &pTcIfc->SpecificLinkCtx)) {
                pTcIfc->InterfaceIndex  = IF_UNKNOWN;
                pTcIfc->SpecificLinkCtx = IF_UNKNOWN;

            }

            FreeLock( pGlobals->Lock );

#if 0            
            //
            // there's a new addr list, check the GPC client list
            //

            OpenGpcClients(pTcIfc);
#endif

        } else {

            Status = ERROR_NOT_ENOUGH_MEMORY;
        }

        break;

    default:
        ASSERT(0);
    }

    return Status;
}





DWORD
CreateClientStruc(
        IN  HANDLE                      ClRegCtx,
    OUT PCLIENT_STRUC   *ppClient
    )
{
    PCLIENT_STRUC       pClient;
    DWORD                       Status = NO_ERROR;

    AllocMem(&pClient, sizeof(CLIENT_STRUC));

    if (pClient != NULL) {

        RtlZeroMemory(pClient, sizeof(CLIENT_STRUC));

        //
        // acquire a new handle for the client
        //

        pClient->ClHandle = AllocateHandle((PVOID)pClient);

        //
        // set the other parameters in the client interface
        //
        
        pClient->ObjectType = ENUM_CLIENT_TYPE;
        pClient->ClRegCtx = ClRegCtx;
        InitializeListHead(&pClient->InterfaceList);
        ReferenceInit(&pClient->RefCount, pClient, DereferenceClient);
        REFADD(&pClient->RefCount, 'CLNT');

        __try {

            InitLock(pClient->Lock);
                                                                     
        } __except (EXCEPTION_EXECUTE_HANDLER) {                            
                                                                                 
            Status = GetExceptionCode();                                    
                                                                    
            IF_DEBUG(ERRORS) {                                              
                WSPRINT(("TcRegisterClient: Exception Error: = 0x%X\n", Status ));  
            }                                                               
            
            FreeMem(pClient);
                                                                     
            return Status; 

        }

        SET_STATE(pClient->State, INSTALLING);

    } else {

        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    *ppClient = pClient;

    return Status;
}



DWORD
CreateClInterfaceStruc(
        IN  HANDLE                              ClIfcCtx,
    OUT PINTERFACE_STRUC        *ppClIfc
    )
{
    PINTERFACE_STRUC    pClIfc;
    DWORD                               Status = NO_ERROR;

    AllocMem(&pClIfc, sizeof(INTERFACE_STRUC));

    if (pClIfc != NULL) {

        RtlZeroMemory(pClIfc, sizeof(INTERFACE_STRUC));

        if ((pClIfc->IfcEvent = CreateEvent(  NULL,  // pointer to security attributes
                                              TRUE,  // flag for manual-reset event
                                              FALSE, // flag for initial state
                                              NULL   // pointer to event-object name);
                                              )) == NULL) {
            Status = GetLastError();

            IF_DEBUG(ERRORS) {
                WSPRINT(( "Error Creating Event for Interface: 0x%X:%d\n", pClIfc, Status));
            }
    
            FreeMem(pClIfc);
            return Status;

        } 

        //
        // acquire a new handle for the client
        //

        GetLock(pGlobals->Lock);
        pClIfc->ClHandle = AllocateHandle((PVOID)pClIfc);
        FreeLock(pGlobals->Lock);

        //
        // set the other parameters in the client interface
        //
        
        pClIfc->ObjectType = ENUM_INTERFACE_TYPE;
        pClIfc->ClIfcCtx = ClIfcCtx;
        pClIfc->CallbackThreadId = 0;

        ReferenceInit(&pClIfc->RefCount, pClIfc, DereferenceInterface);
        REFADD(&pClIfc->RefCount, 'CIFC');
        
        InitializeListHead(&pClIfc->FlowList);
    
        __try {

            InitLock(pClIfc->Lock);

        } __except (EXCEPTION_EXECUTE_HANDLER) {

            Status = GetExceptionCode();

            IF_DEBUG(ERRORS) {
                WSPRINT(("TcRegisterClient: Exception Error: = 0x%X\n", Status ));
            }

            FreeMem(pClIfc);

            return Status;

        }

        SET_STATE(pClIfc->State, INSTALLING);
        pClIfc->Flags = 0; // reset flags

    } else {
        
        Status = ERROR_NOT_ENOUGH_MEMORY;

    }

    *ppClIfc = pClIfc;

    return Status;
}


DWORD
CreateKernelInterfaceStruc(
                           OUT PTC_IFC        *ppTcIfc,
                           IN  DWORD          AddressLength
                           )
{
    PTC_IFC         pTcIfc;
    DWORD           Status = NO_ERROR;

    IF_DEBUG(CALLS) {
        WSPRINT(("==> CreateKernelInterfaceStruc: AddressLength %d\n", AddressLength));
    }

    *ppTcIfc = NULL;

    AllocMem(&pTcIfc, sizeof(TC_IFC));

    if (pTcIfc) {
    
        RtlZeroMemory(pTcIfc, sizeof(TC_IFC));

        AllocMem(&pTcIfc->pAddressListDesc, AddressLength);

        if (pTcIfc->pAddressListDesc) {
        
            RtlZeroMemory(pTcIfc->pAddressListDesc, AddressLength);

            //
            // initialize the new structure
            //
            ReferenceInit(&pTcIfc->RefCount, pTcIfc, DereferenceKernelInterface);
            REFADD(&pTcIfc->RefCount, 'KIFC');
            SET_STATE(pTcIfc->State, INSTALLING);
        
            __try {

                InitLock(pTcIfc->Lock);

            } __except (EXCEPTION_EXECUTE_HANDLER) {

                Status = GetExceptionCode();

                IF_DEBUG(ERRORS) {
                    WSPRINT(("TcRegisterClient: Exception Error: = 0x%X\n", Status ));
                }

                FreeMem(pTcIfc->pAddressListDesc);
                FreeMem(pTcIfc);

                return Status;

            }

            InitializeListHead(&pTcIfc->ClIfcList);
        
        } else {

            FreeMem(pTcIfc);
            Status = ERROR_NOT_ENOUGH_MEMORY;
            return Status;

        }
    
    } else {
        
        Status = ERROR_NOT_ENOUGH_MEMORY;
        return Status;

    }

    *ppTcIfc = pTcIfc;

    IF_DEBUG(CALLS) {
        WSPRINT(("==> CreateKernelInterfaceStruc: Status%d\n", Status));
    }

    return Status;
}


DWORD
DereferenceKernelInterface(
                           PTC_IFC        pTcIfc
                           )
{
    DWORD           Status = NO_ERROR;

    IF_DEBUG(CALLS) {
        WSPRINT(("==> DereferenceKernelInterfaceStruc: %X\n", pTcIfc));
    }

    ASSERT(pTcIfc);

    ASSERT( IsListEmpty( &pTcIfc->ClIfcList ) );

    GetLock( pGlobals->Lock );
    RemoveEntryList(&pTcIfc->Linkage);
    FreeLock( pGlobals->Lock );

    DeleteLock(pTcIfc->Lock);
    FreeMem(pTcIfc->pAddressListDesc);
    FreeMem(pTcIfc);
    
    IF_DEBUG(CALLS) {
        WSPRINT(("==> DereferenceKernelInterfaceStruc: %d\n", Status));
    }

    return Status;
}


DWORD
CreateFlowStruc(
        IN  HANDLE                      ClFlowCtx,
    IN  PTC_GEN_FLOW    pGenFlow,
    OUT PFLOW_STRUC     *ppFlow
    )
{
    PFLOW_STRUC         pFlow;
    DWORD               Status = NO_ERROR;
    ULONG               l;
    PUCHAR              pCurrentObject;
    LONG                BufRemaining;

    *ppFlow = NULL;

    __try {
      
        pCurrentObject = (PUCHAR) pGenFlow->TcObjects;
        BufRemaining = pGenFlow->TcObjectsLength;

        while ((BufRemaining > 0) && (((QOS_OBJECT_HDR*)pCurrentObject)->ObjectType != QOS_OBJECT_END_OF_LIST))

        {
            BufRemaining -= ((QOS_OBJECT_HDR*)pCurrentObject)->ObjectLength;
            pCurrentObject = pCurrentObject + ((QOS_OBJECT_HDR*)pCurrentObject)->ObjectLength;
        }

        if (BufRemaining < 0)
            return (ERROR_TC_OBJECT_LENGTH_INVALID);

        l = FIELD_OFFSET(TC_GEN_FLOW, TcObjects) + pGenFlow->TcObjectsLength;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
      
        Status = GetExceptionCode();

        IF_DEBUG(ERRORS) {
        WSPRINT(("CreateFlowStruc: Invalid pGenFlow: = 0x%X\n", 
                Status ));
        }

        return Status;
    }

    AllocMem(&pFlow, sizeof(FLOW_STRUC));

    if (pFlow != NULL) {

        RtlZeroMemory(pFlow, sizeof(FLOW_STRUC));

        //
        // Allocate memory and save the generic flow structure
        //

        AllocMem(&pFlow->pGenFlow, l);

        if (pFlow->pGenFlow == NULL) {

            FreeMem(pFlow);
            
            pFlow = NULL;

            Status = ERROR_NOT_ENOUGH_MEMORY;

        } else {

            //
            // copy the generic flow into the new allocation
            //

            __try {

                RtlCopyMemory(pFlow->pGenFlow, pGenFlow, l);

            } __except (EXCEPTION_EXECUTE_HANDLER) {
                
                Status = GetExceptionCode();
                
                IF_DEBUG(ERRORS) {
                    WSPRINT(("CreateFlowStruc: Exception Error: = 0x%X\n", 
                             Status ));
                }
                
                return Status;
            }

            //
            // acquire a new handle for the flow
            //
            
            pFlow->ClHandle = AllocateHandle((PVOID)pFlow);
            
            //
            // set the other parameters in the flow
            //
            
            pFlow->GenFlowLen = l;
            pFlow->ObjectType = ENUM_GEN_FLOW_TYPE;
            pFlow->ClFlowCtx = ClFlowCtx;
            pFlow->Flags = 0;
            pFlow->InstanceNameLength = 0;
            ReferenceInit(&pFlow->RefCount, pFlow, DereferenceFlow);
            REFADD(&pFlow->RefCount, 'FLOW');
            pFlow->FilterCount = 0;
            InitializeListHead(&pFlow->FilterList);
            
            __try {

                InitLock(pFlow->Lock);

            } __except (EXCEPTION_EXECUTE_HANDLER) {

                Status = GetExceptionCode();

                IF_DEBUG(ERRORS) {
                    WSPRINT(("TcRegisterClient: Exception Error: = 0x%X\n", Status ));
                }


                FreeHandle(pFlow->ClHandle);
                FreeMem(pFlow->pGenFlow);
                FreeMem(pFlow);

                return Status;

            }

            SET_STATE(pFlow->State, INSTALLING);
            
            //
            // Next create the event
            //

            pFlow->PendingEvent = CreateEvent(NULL,     // default attr
                                              FALSE,    // auto reset
                                              FALSE,    // init = not signaled
                                              NULL              // no name
                                              );

            if (!pFlow->PendingEvent)
            {
                // Failed to create event, get the error and free flow
                Status = GetLastError();
                
                DeleteFlowStruc(
                    pFlow );

                return Status;
            }
        }
        
    } else {

        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    *ppFlow = pFlow;

    return Status;
}



DWORD
CreateClassMapFlowStruc(
        IN  HANDLE                              ClFlowCtx,
    IN  PTC_CLASS_MAP_FLOW      pClassMapFlow,
    OUT PFLOW_STRUC             *ppFlow
    )
{
    PFLOW_STRUC         pFlow;
    DWORD                       Status = NO_ERROR;
    ULONG                       l;

    return ERROR_CALL_NOT_IMPLEMENTED;

#if NEVER

    // As this is not published in MSDN and not implemented in PSCHED also
    *ppFlow = NULL;

    AllocMem(&pFlow, sizeof(FLOW_STRUC));

    if (pFlow != NULL) {

        RtlZeroMemory(pFlow, sizeof(FLOW_STRUC));

        //
        // Allocate memory and save the generic flow structure
        //

        l = sizeof(TC_CLASS_MAP_FLOW) + pClassMapFlow->ObjectsLength;

        AllocMem(&pFlow->pClassMapFlow, l);

        if (pFlow->pClassMapFlow == NULL) {

            FreeMem(pFlow);
            
            pFlow = NULL;

            Status = ERROR_NOT_ENOUGH_MEMORY;

        } else {

            //
            // copy the generic flow into the new allocation
            //

            __try {

                RtlCopyMemory(pFlow->pClassMapFlow, pClassMapFlow, l);

            } __except (EXCEPTION_EXECUTE_HANDLER) {
                
                Status = GetExceptionCode();
                
                IF_DEBUG(ERRORS) {
                    WSPRINT(("CreateClassMapFlowStruc: Exception Error: = 0x%X\n", 
                             Status ));
                }
                
                return Status;
            }

            //
            // acquire a new handle for the flow
            //
            
            pFlow->ClHandle = AllocateHandle((PVOID)pFlow);
            
            //
            // set the other parameters in the flow
            //
            
            pFlow->ObjectType = ENUM_CLASS_MAP_FLOW_TYPE;
            pFlow->ClFlowCtx = ClFlowCtx;
            pFlow->Flags = 0;
            pFlow->InstanceNameLength = 0;
            InitializeListHead(&pFlow->FilterList);

            __try {

                InitLock(pFlow->Lock);
            
            } __except (EXCEPTION_EXECUTE_HANDLER) {

                Status = GetExceptionCode();

                IF_DEBUG(ERRORS) {
                    WSPRINT(("TcRegisterClient: Exception Error: = 0x%X\n", Status ));
                }
                
                if(pFlow->pClassMapFlow) 
                    FreeMem(pFlow->pClassMapFlow);

                if(pFlow) 
                    FreeMem(pFlow);

                return Status;

            }

            //
            //
            //

            pFlow->PendingEvent = CreateEvent(NULL,     // default attr
                                              FALSE,    // auto reset
                                              FALSE,    // init = not signaled
                                              NULL              // no name
                                              );

            if (!pFlow->PendingEvent)
            {
                // Failed to create event, get the error and free flow
                Status = GetLastError();
                
                DeleteFlowStruc(
                    pFlow );

                return Status;
            }
        }
        
    } else {

        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    *ppFlow = pFlow;

    return Status;

#endif
}



DWORD
CreateFilterStruc(
        IN      PTC_GEN_FILTER  pGenFilter,
    IN  PFLOW_STRUC             pFlow,
    OUT PFILTER_STRUC   *ppFilter
    )
{
    PFILTER_STRUC                       pFilter;
    DWORD                                       Status = NO_ERROR;
    ULONG                                       GenFilterSize;
    PTC_GEN_FILTER                      pGpcFilter;
    PUCHAR                                      p;
    ULONG                                       ProtocolId;
    ULONG                                       PatternSize;
    PIP_PATTERN                         pIpPattern;
    PTC_IFC                             pTcIfc;
    int                                         i,n;

    *ppFilter = NULL;
    pTcIfc = pFlow->pInterface->pTcIfc;

    ASSERT(pTcIfc);

    __try {

        switch (pGenFilter->AddressType) {

        case NDIS_PROTOCOL_ID_TCP_IP:
            ProtocolId = GPC_PROTOCOL_TEMPLATE_IP;
            PatternSize = sizeof(IP_PATTERN);
            break;

        case NDIS_PROTOCOL_ID_IPX:
            ProtocolId = GPC_PROTOCOL_TEMPLATE_IPX;
            PatternSize = sizeof(IPX_PATTERN);
            break;

        default:
            return ERROR_INVALID_ADDRESS_TYPE;
        }

        if (PatternSize != pGenFilter->PatternSize ||
            pGenFilter->Pattern == NULL ||
            pGenFilter->Mask == NULL) {

            return ERROR_INVALID_PARAMETER;
        }

    } __except(EXCEPTION_EXECUTE_HANDLER) {
                
          Status = ERROR_INVALID_PARAMETER;
                
          IF_DEBUG(ERRORS) {
              WSPRINT(("CreateFilterStruc: Exception Error: = 0x%X\n", 
                       Status ));
          }
                
          return Status;
    }

    AllocMem(&pFilter, sizeof(FILTER_STRUC));

    if (pFilter != NULL) {

        RtlZeroMemory(pFilter, sizeof(FILTER_STRUC));

        //
        // Allocate memory and save the generic filter structure
        //

        GenFilterSize = sizeof(TC_GEN_FILTER) + 2*pGenFilter->PatternSize;
        AllocMem(&pGpcFilter, GenFilterSize);

        if (pGpcFilter == NULL) {

            FreeMem(pFilter);
            
            pFilter = NULL;

            Status = ERROR_NOT_ENOUGH_MEMORY;
            
        } else {

            //
            // copy the generic filter to local storage
            //

            pGpcFilter->AddressType = pGenFilter->AddressType;
            pGpcFilter->PatternSize = PatternSize;

            p = (PUCHAR)pGpcFilter + sizeof(TC_GEN_FILTER);

            __try {

                RtlCopyMemory(p, pGenFilter->Pattern, pGenFilter->PatternSize);

                if (pGenFilter->AddressType == NDIS_PROTOCOL_ID_TCP_IP) {
                
                    if(pTcIfc->InterfaceIndex == IF_UNKNOWN) {
                    
                        if (NO_ERROR != (Status = GetInterfaceIndex(pTcIfc->pAddressListDesc,
                                                                      &pTcIfc->InterfaceIndex,
                                                                      &pTcIfc->SpecificLinkCtx))) {
                            FreeMem(pFilter);
                            FreeMem(pGpcFilter);
                            return Status;
                        }
                    }

                    //
                    // IP pattern, set reserved fields
                    //

                    pIpPattern = (PIP_PATTERN)p;
                    pIpPattern->Reserved1 = pFlow->pInterface->pTcIfc->InterfaceIndex;
                    pIpPattern->Reserved2 = pFlow->pInterface->pTcIfc->SpecificLinkCtx;
                    pIpPattern->Reserved3[0] = pIpPattern->Reserved3[1] = pIpPattern->Reserved3[2] = 0;
                    
                }
                
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                
                Status = ERROR_INVALID_PARAMETER;
                
                IF_DEBUG(ERRORS) {
                    WSPRINT(("CreateFilterStruc: Exception Error: = 0x%X\n", 
                             Status ));
                }
                
                FreeMem(pGpcFilter);
                FreeMem(pFilter);
                
                return Status;
            }
            
            pGpcFilter->Pattern = (PVOID)p;
            
            p += pGenFilter->PatternSize;
            
            __try {
                
                RtlCopyMemory(p, pGenFilter->Mask, pGenFilter->PatternSize);
                
                if (pGenFilter->AddressType == NDIS_PROTOCOL_ID_TCP_IP) {
                    
                    //
                    // IP pattern, set reserved fields
                    //
                    
                    pIpPattern = (PIP_PATTERN)p;
                    pIpPattern->Reserved1 = pIpPattern->Reserved2 = 0xffffffff;
                    pIpPattern->Reserved3[0] = pIpPattern->Reserved3[1] = pIpPattern->Reserved3[2] = 0xff;
                    
                }
                
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                
                Status = ERROR_INVALID_PARAMETER;
                
                IF_DEBUG(ERRORS) {
                    WSPRINT(("CreateFilterStruc: Exception Error: = 0x%X\n", 
                             Status ));
                }
                
                FreeMem(pGpcFilter);
                FreeMem(pFilter);
                
                return Status;
            }

            pGpcFilter->Mask = (PVOID)p;
            
            pFilter->pGpcFilter = pGpcFilter;

            //
            // acquire a new handle for the Filter
            //
            
            pFilter->ClHandle = AllocateHandle((PVOID)pFilter);

            // what if we're out of memory?
            if (!pFilter->ClHandle) {
                
                IF_DEBUG(ERRORS) {
                    WSPRINT(("CreateFilterStruc: Cant allocate Handle\n"));
                }

                FreeMem(pGpcFilter);
                FreeMem(pFilter);
                return ERROR_NOT_ENOUGH_MEMORY;
                
            }
            
            //
            // set the other parameters in the Filter
            //
            
            pFilter->ObjectType = ENUM_FILTER_TYPE;
            pFilter->Flags = 0;

            ReferenceInit(&pFilter->RefCount, pFilter, DereferenceFilter);
            REFADD(&pFilter->RefCount, 'FILT');

            __try {

                InitLock(pFilter->Lock);

            } __except (EXCEPTION_EXECUTE_HANDLER) {

                Status = GetExceptionCode();

                IF_DEBUG(ERRORS) {
                    WSPRINT(("TcRegisterClient: Exception Error: = 0x%X\n", Status ));
                }

                FreeHandle(pFilter->ClHandle);
                FreeMem(pFilter);
                FreeMem(pGpcFilter);

                return Status;

            }

            SET_STATE(pFilter->State, INSTALLING);

            //
            // set the Gpc protocol template from the address type
            //
            
            pFilter->GpcProtocolTemplate = ProtocolId;

        }
        
    } else {

        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    *ppFilter = pFilter;

    return Status;
}



DWORD
EnumAllInterfaces(VOID)
{
    PCLIENT_STRUC                       pClient;
    DWORD                                       Status;
    WMIHANDLE                           WmiHandle;
    ULONG                                       MyBufferSize = 2 KiloBytes; // is this enough?!?
    PWNODE_ALL_DATA                     pWnode;
    PWNODE_ALL_DATA                     pWnodeBuffer;
    PTC_IFC                                     pTcIfc;

    if (_init)
        return NO_ERROR;

    //
    // get a WMI block handle to the GUID_QOS_SUPPORTED
    //

    Status = WmiOpenBlock((GUID *)&GUID_QOS_TC_SUPPORTED, 0, &WmiHandle);

    if (ERROR_FAILED(Status)) {

        if (Status == ERROR_WMI_GUID_NOT_FOUND) {

            //
            // this means there is no TC data provider
            //

            Status = NO_ERROR; //ERROR_TC_NOT_SUPPORTED
        }

        return Status;
    }

    do {

        //
        // allocate a private buffer to retrieve all wnodes
        //
        
        AllocMem(&pWnodeBuffer, MyBufferSize);
        
        if (pWnodeBuffer == NULL) {
            
            WmiCloseBlock(WmiHandle);
            
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        __try {

            Status = WmiQueryAllData(WmiHandle, &MyBufferSize, pWnodeBuffer);

        } __except (EXCEPTION_EXECUTE_HANDLER) {

            Status = GetExceptionCode();

            IF_DEBUG(ERRORS) {
                WSPRINT(("EnumAllInterfaces: Exception Error: = %X\n", 
                         Status ));
            }

        }

        if (Status == ERROR_INSUFFICIENT_BUFFER) {

            //
            // failed since the buffer was too small
            // release the buffer and double the size
            //

            MyBufferSize *= 2;
            FreeMem(pWnodeBuffer);
            pWnodeBuffer = NULL;
        }

    } while (Status == ERROR_INSUFFICIENT_BUFFER);

    if (!ERROR_FAILED(Status)) {

        ULONG   dwInstanceNum;
        ULONG   InstanceSize;
        PULONG  lpdwNameOffsets;
        BOOL    bFixedSize = FALSE;
        USHORT  usNameLength;
        ULONG   DescSize;
        PTC_SUPPORTED_INFO_BUFFER pTcInfoBuffer;

        pWnode = pWnodeBuffer;
        
        ASSERT(pWnode->WnodeHeader.Flags & WNODE_FLAG_ALL_DATA);
                
        do {

            //
            // Check for fixed instance size
            //

            if (pWnode->WnodeHeader.Flags & WNODE_FLAG_FIXED_INSTANCE_SIZE) {

                InstanceSize = pWnode->FixedInstanceSize;
                bFixedSize = TRUE;
                pTcInfoBuffer = 
                    (PTC_SUPPORTED_INFO_BUFFER)OffsetToPtr(pWnode, 
                                                           pWnode->DataBlockOffset);
            }

            //
            //  Get a pointer to the array of offsets to the instance names
            //
            
            lpdwNameOffsets = (PULONG) OffsetToPtr(pWnode, 
                                                   pWnode->OffsetInstanceNameOffsets);
            
            for ( dwInstanceNum = 0; 
                  dwInstanceNum < pWnode->InstanceCount; 
                  dwInstanceNum++) {

                usNameLength = 
                    *(USHORT *)OffsetToPtr(pWnode, 
                                           lpdwNameOffsets[dwInstanceNum]);
                    
                //
                //  Length and offset for variable data
                //
                
                if ( !bFixedSize ) {
                    
                    InstanceSize = 
                        pWnode->OffsetInstanceDataAndLength[dwInstanceNum].LengthInstanceData;
                    
                    pTcInfoBuffer = 
                        (PTC_SUPPORTED_INFO_BUFFER)OffsetToPtr(
                                           (PBYTE)pWnode,
                                           pWnode->OffsetInstanceDataAndLength[dwInstanceNum].OffsetInstanceData);
                }
                
                //
                // we have all that is needed. we need to figure if 
                // there is enough buffer space to put the data as well
                //
                
                ASSERT(usNameLength < MAX_STRING_LENGTH);

                DescSize = InstanceSize - FIELD_OFFSET(TC_SUPPORTED_INFO_BUFFER, AddrListDesc);

                //
                // Allocate a new interface descriptor structure
                //
                
                CreateKernelInterfaceStruc(&pTcIfc, DescSize);

                if (pTcIfc != NULL) {
                     
                    //
                    // copy the instance name string data
                    //

                    RtlCopyMemory(pTcIfc->InstanceName,
                                  OffsetToPtr(pWnode,
                                              lpdwNameOffsets[dwInstanceNum]+2),
                                  usNameLength );
                    pTcIfc->InstanceNameLength = usNameLength;
                    pTcIfc->InstanceName[usNameLength/sizeof(WCHAR)] = 
                        (WCHAR)0;

                    //
                    // copy the instance ID string data
                    //

                    RtlCopyMemory(pTcIfc->InstanceID,
                                  &pTcInfoBuffer->InstanceID[0],
                                  pTcInfoBuffer->InstanceIDLength );
                    pTcIfc->InstanceIDLength = pTcInfoBuffer->InstanceIDLength;
                    pTcIfc->InstanceID[pTcInfoBuffer->InstanceIDLength/sizeof(WCHAR)] = 
                        (WCHAR)0;

                    //
                    // copy the instance data
                    // in this case - the network address
                    //
                    
                    pTcIfc->AddrListBytesCount = DescSize;

                    //
                    // a sizeof(ULONG) since the structure is defined as ARRAY
                    // and the first ULONG is the number of elements
                    //

                    RtlCopyMemory( pTcIfc->pAddressListDesc,
                                   &pTcInfoBuffer->AddrListDesc,
                                   DescSize );

                    if (NO_ERROR != GetInterfaceIndex(pTcIfc->pAddressListDesc,
                                                      &pTcIfc->InterfaceIndex,
                                                      &pTcIfc->SpecificLinkCtx)) {
                        pTcIfc->InterfaceIndex  = IF_UNKNOWN;
                        pTcIfc->SpecificLinkCtx = IF_UNKNOWN;

                    }

                    // set the state to open
                    GetLock(pTcIfc->Lock);
                    SET_STATE(pTcIfc->State, OPEN);
                    FreeLock(pTcIfc->Lock);

                    //
                    // Add the structure to the global linked list
                    //

                    GetLock( pGlobals->Lock );
                    InsertTailList(&pGlobals->TcIfcList, &pTcIfc->Linkage );
                    FreeLock( pGlobals->Lock );

#if 0
                    //
                    // make sure we have one gpc client per address type
                    //
                    
                    Status = OpenGpcClients(pTcIfc);
                    
                    if (ERROR_FAILED(Status)) {

                        break;
                    }
#endif

                } else {

                    //
                    // no more memory, quit here
                    //
                
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
                
            }
            
            //
            //  Update Wnode to point to next node
            //

            if ( pWnode->WnodeHeader.Linkage != 0) {

                pWnode = (PWNODE_ALL_DATA) OffsetToPtr( pWnode, 
                                                        pWnode->WnodeHeader.Linkage);
            } else {
                
                pWnode = NULL;
            }

        } while (pWnode != NULL && !ERROR_FAILED(Status));

    }

    //
    // release resources and close WMI handle
    //

    WmiCloseBlock(WmiHandle);

    if (pWnodeBuffer)
        FreeMem(pWnodeBuffer);

    if (Status == NO_ERROR) {

        _init = TRUE;
    }

    return Status;
}



DWORD
CloseInterface(
    IN PINTERFACE_STRUC pInterface,
    BOOLEAN             RemoveFlows
    )
{
    IF_DEBUG(CALLS) {
        WSPRINT(("==>CloseInterface: pInterface=%X\n",
                 pInterface));
    }

    if (RemoveFlows) {

        CloseOpenFlows(pInterface);
    }

    REFDEL(&pInterface->RefCount, 'CIFC');

    IF_DEBUG(CALLS) {
        WSPRINT(("==>CloseInterface: NO_ERROR\n"));
    }

    return NO_ERROR;
}




DWORD
DeleteFlow(
    IN PFLOW_STRUC      pFlow,
    IN BOOLEAN          RemoveFilters
    )
{
    DWORD               Status;
    PLIST_ENTRY         pEntry;
    PFILTER_STRUC       pFilter;

    IF_DEBUG(CALLS) {
        WSPRINT(("DeleteFlow: attempting to delete flow=0x%X\n", 
                 PtrToUlong(pFlow)));
    }

    if (RemoveFilters) {

        CloseOpenFilters(pFlow);
        
    } else {

        if (/*pFlow->FilterCount > 0*/ !IsListEmpty(&pFlow->FilterList)) {
            

            IF_DEBUG(ERRORS) {
                WSPRINT(("DeleteFlow: filter list NOT empty\n"));
            }

#if DBG
        pEntry = pFlow->FilterList.Flink;
        while (pEntry != &pFlow->FilterList) {

            pFilter = CONTAINING_RECORD(pEntry, FILTER_STRUC, Linkage);
            IF_DEBUG(ERRORS) {
                WSPRINT(("<==TcDeleteFlow: Filter %x (handle %x) is open with RefCount:%d\n", pFilter, pFilter->ClHandle, pFilter->RefCount));
            }

            pEntry = pEntry->Flink;
        }
#endif 


            return ERROR_TC_SUPPORTED_OBJECTS_EXIST;
        }
    }

    //
    // can remove the flow now
    //

    Status = IoDeleteFlow( pFlow, (BOOLEAN)!RemoveFilters );

    IF_DEBUG(CALLS) {
        WSPRINT(("DeleteFlow: IoDeleteFlow returned=0x%X\n",
                 Status));
    }

    if (!ERROR_PENDING(Status)) {

        //
        // call completed, either success or failure...
        //

        CompleteDeleteFlow(pFlow, Status);
    }

    return Status;
}



DWORD
DeleteFilter(
    IN PFILTER_STRUC    pFilter
    )
{
    DWORD               Status;

    IF_DEBUG(CALLS) {
        WSPRINT(( "DeleteFilter: attempting to delete=0x%X\n",
                  PtrToUlong(pFilter)));
    }
    //
    // call to actually delete the filter
    //

    Status = IoDeleteFilter( pFilter );

    IF_DEBUG(CALLS) {
        WSPRINT(( "DeleteFilter: IoDeleteFilter returned=0x%X\n",
                  Status));
    }

    //ASSERT(Status == NO_ERROR);

    REFDEL(&pFilter->RefCount, 'FILT');

    return Status;
}



PGPC_CLIENT
FindGpcClient(
        IN  ULONG       CfInfoType
    )
{
    PGPC_CLIENT         pGpcClient = NULL;
    PLIST_ENTRY         pHead, pEntry;

    GetLock( pGlobals->Lock );

    pHead = &pGlobals->GpcClientList;
    pEntry = pHead->Flink;

    while (pHead != pEntry && pGpcClient == NULL) {

        pGpcClient = CONTAINING_RECORD(pEntry, GPC_CLIENT, Linkage);
        
        if (CfInfoType != pGpcClient->CfInfoType) {

            //
            // address type doesn't match!
            //

            pGpcClient = NULL;
        }
        
        pEntry = pEntry->Flink;
    }

    FreeLock( pGlobals->Lock );

    return pGpcClient;
}




VOID
CompleteAddFlow(
        IN      PFLOW_STRUC             pFlow,
    IN  DWORD                   Status
    )
{
    PINTERFACE_STRUC    pInterface;

    ASSERT(pFlow);
    ASSERT(!ERROR_PENDING(Status));

    IF_DEBUG(CALLS) {
        WSPRINT(("CompleteAddFlow: pFlow=0x%X Status=0x%X\n", 
                 PtrToUlong(pFlow), Status));
    }

    if(pFlow->CompletionBuffer) {

        FreeMem(pFlow->CompletionBuffer);
        pFlow->CompletionBuffer = NULL;

    }

    //
    // Check if the interface is still around.
    //
    GetLock(pFlow->Lock);
    pInterface = pFlow->pInterface;
    FreeLock(pFlow->Lock);

    if (ERROR_FAILED(Status)) {
    
        //
        // failed, release resources
        //
        CompleteDeleteFlow(pFlow, Status);
    
    } else {
    
        GetLock(pGlobals->Lock);
        GetLock(pInterface->Lock);

        if (QUERY_STATE(pInterface->State) != OPEN) {
    
            FreeLock(pInterface->Lock);
            FreeLock(pGlobals->Lock);

            IF_DEBUG(ERRORS) {
                WSPRINT(("CompleteAddFlow: Interface (%X) is NOT open pFlow=0x%X Status=0x%X\n", pInterface->ClHandle,
                         PtrToUlong(pFlow), Status));
            }

            //
            // Delete the only ref we have on this flow and get out.
            //
            REFDEL(&pFlow->RefCount, 'FLOW');

        } else {

            FreeLock(pInterface->Lock);    

            //
            // The flow is ready for business
            //
            GetLock(pFlow->Lock);
            SET_STATE(pFlow->State, OPEN);
            FreeLock(pFlow->Lock);
    
            //
            // Announce on the lists that we are ready for business
            //

            pInterface->FlowCount++;
            REFADD(&pInterface->RefCount, 'FLOW');
            InsertTailList(&pInterface->FlowList, &pFlow->Linkage);
            FreeLock(pGlobals->Lock);

        }


    
    }

    //
    // This ref was taken in TcAddFlow.
    //
    REFDEL(&pInterface->RefCount, 'TCAF');

}



VOID
CompleteModifyFlow(
        IN      PFLOW_STRUC             pFlow,
    IN  DWORD                   Status
    )
{
    ASSERT(pFlow);
    ASSERT(!ERROR_PENDING(Status));

    IF_DEBUG(CALLS) {
        WSPRINT(("CompleteModifyFlow: pFlow=0x%X Status=0x%X\n", 
                 PtrToUlong(pFlow), Status));
    }

    GetLock(pFlow->Lock);

    if(pFlow->CompletionBuffer) {

        FreeMem(pFlow->CompletionBuffer);
        pFlow->CompletionBuffer = NULL;

    }

    if (ERROR_FAILED(Status)) {

        //
        // failed, release the newly allocated generic flow parameters
        //
        
        FreeMem(pFlow->pGenFlow1);

    } else {

        //
        // modification accepted, update the generic flow parameters
        //
        
        FreeMem(pFlow->pGenFlow);
        pFlow->pGenFlow = pFlow->pGenFlow1;
        pFlow->GenFlowLen = pFlow->GenFlowLen;

    }

    //
    // clear the installing flag
    //
    
    pFlow->Flags &= ~TC_FLAGS_MODIFYING;
    pFlow->pGenFlow1 = NULL;
    pFlow->GenFlowLen1 = 0;

    FreeLock(pFlow->Lock);

    //
    // This ref was taken in TcModifyFlow
    //

    REFDEL(&pFlow->RefCount, 'TCMF');
    
    IF_DEBUG(CALLS) {
        WSPRINT(("CompleteModifyFlow: pFlow=0x%X Status=0x%X\n", 
                 PtrToUlong(pFlow), Status));
    }

}



VOID
CompleteDeleteFlow(
        IN      PFLOW_STRUC             pFlow,
    IN  DWORD                   Status
    )
{
    ASSERT(pFlow);
    //ASSERT(Status == NO_ERROR);
    //ASSERT(pFlow->CompletionBuffer);

    IF_DEBUG(CALLS) {
        WSPRINT(("CompleteDeleteFlow: pFlow=0x%X Status=0x%X\n", 
                 PtrToUlong(pFlow), Status));
    }

    //
    // okay, release resources
    //
    GetLock(pFlow->Lock);
    if (pFlow->CompletionBuffer) {
        
        FreeMem(pFlow->CompletionBuffer);
        pFlow->CompletionBuffer = NULL;
    
    }
    FreeLock(pFlow->Lock);
    
    IF_DEBUG(REFCOUNTS) { 
        WSPRINT(("#21 DEREF FLOW %X (%X) ref(%d)\n", pFlow->ClHandle, pFlow, pFlow->RefCount)); 
    }

    REFDEL(&pFlow->RefCount, 'FLOW');

}





DWORD
OpenGpcClients(
    IN  ULONG   CfInfoType
    )
{
    DWORD                               Status = NO_ERROR;
    PLIST_ENTRY                 pHead, pEntry;
    PGPC_CLIENT                 pGpcClient;
    //int                                       i;
    
    if (FindGpcClient(CfInfoType) == NULL) {
        
        //
        // create an entry in the 
        //
        
        AllocMem(&pGpcClient, sizeof(GPC_CLIENT) );
        
        if (pGpcClient == NULL) {
            
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        
        pGpcClient->CfInfoType = CfInfoType;
        pGpcClient->RefCount = 1;
        
        //
        // register the gpc client
        //
        
        Status = IoRegisterClient(pGpcClient);
        
        if (ERROR_FAILED(Status)) {
            
            FreeMem(pGpcClient);

        } else {
        
            GetLock( pGlobals->Lock);
            InsertTailList(&pGlobals->GpcClientList, &pGpcClient->Linkage);
            FreeLock( pGlobals->Lock);
        }
    }
    
    return Status;
}




DWORD
DereferenceInterface(
                     IN      PINTERFACE_STRUC        pInterface
                     )
{

    DWORD   Status = NO_ERROR;

    IF_DEBUG(CALLS) {
        WSPRINT(("==>DereferenceInterface: IfcH=%X RefCount=%d\n",
                 pInterface->ClHandle, pInterface->RefCount));
    }
    
    FreeHandle(pInterface->ClHandle);
    //GetLock(pGlobals->Lock);

    IF_DEBUG(REFCOUNTS) {
            
        WSPRINT(("==>DereferenceInterface: IfcH=%X Interface=%x\n",
                 pInterface->ClHandle, pInterface));

    }
    //
    // close the interface and all flows/filters
    //
    RemoveEntryList(&pInterface->Linkage);
    RemoveEntryList(&pInterface->NextIfc);

    //
    // Deregister from any guid notification requests
    //
    TcipDeleteInterfaceFromNotificationList(
                                            pInterface,
                                            0
                                            );

    //
    // #295267
    // Do not dereference Client OR decrement Interface Count until
    // the Interface is actually going away. Otherwise, the client structures
    // are cleaned out, and when the ref count finally goes down and we
    // touch this code path, we hit an AV.
    // 
    pInterface->pClient->InterfaceCount--;
    IF_DEBUG(HANDLES) {
        WSPRINT(("DEREF Client A : %x\n", pInterface->pClient->ClHandle));
    }

    REFDEL(&pInterface->pClient->RefCount, 'CIFC');
    REFDEL(&pInterface->pTcIfc->RefCount, 'CIFC');
    
    //
    // This is complex, so read carefully.
    // We want CloseInterface to wait until the event is set (292120). 
    // It is likely that in case the TcCloseInterface call didn't
    // come in, we dont have to set the Event since the TC_FLAGS_WAITING
    // will not be set in that case.
    //
    if (!IS_WAITING(pInterface->Flags)) {
            
        CloseHandle(pInterface->IfcEvent);

    } else {

        SetEvent(pInterface->IfcEvent);

    }

    //
    // free the interface resources
    //

    DeleteLock(pInterface->Lock);
    FreeMem(pInterface);
        
    //FreeLock(pGlobals->Lock);
    
    IF_DEBUG(CALLS) {
        WSPRINT(("<==DereferenceInterface: Status=%X\n", Status));
    }

    return Status;
}



DWORD
DereferenceFlow(
        IN      PFLOW_STRUC     pFlow
    )
{
    DWORD Status = NO_ERROR;

    IF_DEBUG(CALLS) {
        WSPRINT(("==>DereferenceFlow: FlowH=%X Flow=%X\n",
                 pFlow->ClHandle, pFlow));
    }

    //GetLock(pGlobals->Lock);

    IF_DEBUG(REFCOUNTS) {
        WSPRINT(("==>DereferenceFlow: FlowH=%X Flow=%X\n",
                 pFlow->ClHandle, pFlow));
    }   

    //
    // remove the flow from the list
    //
    FreeHandle(pFlow->ClHandle);        
        
    GetLock(pFlow->Lock);
    if (QUERY_STATE(pFlow->State) != INSTALLING) {
            
        FreeLock(pFlow->Lock);
        RemoveEntryList(&pFlow->Linkage);
        pFlow->pInterface->FlowCount--;
            
        IF_DEBUG(HANDLES) {
            WSPRINT(("DEREF Interface A : %x\n", pFlow->pInterface->ClHandle));
        }

        REFDEL(&pFlow->pInterface->RefCount, 'FLOW');

    } else {
            
        FreeLock(pFlow->Lock);

    }

    //
    // moved here from CompleteDeleteFlow
    // 

    //
    // free the interface resources
    //

    DeleteFlowStruc(pFlow);
        
    //FreeLock(pGlobals->Lock);

    IF_DEBUG(CALLS) {
        WSPRINT(("<==DereferenceFlow: Status=%X\n", Status));
    }

    return Status;
}



DWORD
DereferenceClient(
        IN      PCLIENT_STRUC   pClient
    )
{
    //GetLock( pGlobals->Lock );

    IF_DEBUG(REFCOUNTS) {
        WSPRINT(("==>DereferenceClient: pClient=%x, Handle=%x, RefCount=%d\n",
                 pClient, pClient->ClHandle, pClient->RefCount));
    }   


    GetLock(pClient->Lock);
    SET_STATE(pClient->State, REMOVED);
    FreeLock(pClient->Lock);

    FreeHandle( pClient->ClHandle );
    RemoveEntryList( &pClient->Linkage );
    DeleteLock(pClient->Lock);
    FreeMem( pClient );

    //FreeLock( pGlobals->Lock );    
    
    return NO_ERROR;
}


DWORD
DereferenceFilter(
                  IN    PFILTER_STRUC     pFilter
                  )
{
    DWORD Status = NO_ERROR;

    IF_DEBUG(CALLS) {
        WSPRINT(("==>DereferenceFilter: FilterH=%X RefCount=%d\n",
                 pFilter->ClHandle, pFilter->RefCount));
    }

    //GetLock(pGlobals->Lock);

    IF_DEBUG(REFCOUNTS) {
        WSPRINT(("==>DereferenceFilter: FilterH=%X Filter=%X on FLOW=%X\n",
                 pFilter->ClHandle, pFilter, pFilter->pFlow));
    }   
        
    FreeHandle(pFilter->ClHandle);
        
    //
    // remove the flow from the list
    //
    GetLock(pFilter->Lock);
        
    if (QUERY_STATE(pFilter->State) != INSTALLING) {
            
        FreeLock(pFilter->Lock);
        RemoveEntryList(&pFilter->Linkage);
        pFilter->pFlow->FilterCount--;

        IF_DEBUG(REFCOUNTS) { 
            WSPRINT(("#22 DEREF FLOW %X (%X) ref(%d)\n", pFilter->pFlow->ClHandle, pFilter->pFlow, pFilter->pFlow->RefCount)); 
        }

        REFDEL(&pFilter->pFlow->RefCount, 'FILT');

    } else {
            
        FreeLock(pFilter->Lock);

    }

    DeleteFilterStruc(pFilter);
        
    //FreeLock(pGlobals->Lock);

    IF_DEBUG(CALLS) {
        WSPRINT(("<==DereferenceFilter: Status=%X\n", Status));
    }

    return Status;
}



DWORD
GetInterfaceIndex(
        IN  PADDRESS_LIST_DESCRIPTOR pAddressListDesc,
    OUT  PULONG pInterfaceIndex,
    OUT PULONG pSpecificLinkCtx)
{
    PNETWORK_ADDRESS_LIST       pAddrList;
    NETWORK_ADDRESS UNALIGNED   *pAddr;
    DWORD                                       n,k;
    DWORD                                       Status = NO_ERROR;
    PMIB_IPADDRTABLE            pIpAddrTbl;
    DWORD                                       dwSize = 2 KiloBytes;
    NETWORK_ADDRESS_IP UNALIGNED *pIpNetAddr = 0;
    DWORD                                       cAddr;

    *pInterfaceIndex = 0;
    *pSpecificLinkCtx = 0;

    cAddr = pAddressListDesc->AddressList.AddressCount;
    if (cAddr == 0) {

        //
        // no address
        //

        return NO_ERROR;
    }

#if INTERFACE_ID

    AllocMem(&pIpAddrTbl, dwSize);

    if (pIpAddrTbl == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pAddr = (UNALIGNED NETWORK_ADDRESS *) &pAddressListDesc->AddressList.Address[0];
    
    for (n = 0; n < cAddr; n++) {
            
        if (pAddr->AddressType == NDIS_PROTOCOL_ID_TCP_IP) {
                
            pIpNetAddr = (UNALIGNED NETWORK_ADDRESS_IP *)&pAddr->Address[0];
            break;
        }
            
        pAddr = (UNALIGNED NETWORK_ADDRESS *)(((PUCHAR)pAddr) 
                                   + pAddr->AddressLength 
                                   + FIELD_OFFSET(NETWORK_ADDRESS, Address));
    }

    if (pIpNetAddr) {

        Status = GetIpAddrTableFromStack(
                                         pIpAddrTbl,
                                         dwSize,
                                         FALSE
                                         );
        if (Status == NO_ERROR) {
            
            //
            // search for the matching IP address to IpAddr
            // in the table we got back from the stack
            //

            for (k = 0; k < pIpAddrTbl->dwNumEntries; k++) {

                if (pIpAddrTbl->table[k].dwAddr == pIpNetAddr->in_addr) {

                    //
                    // found one, get the index
                    //
                    
                    *pInterfaceIndex = pIpAddrTbl->table[k].dwIndex;
                    break;
                }
            }

            if (pAddressListDesc->MediaType == NdisMediumWan) {
        
                if (n+1 < cAddr) {

                    //
                    // there is another address that contains
                    // the remote client address
                    // this should be used as the link ID
                    //

                    pAddr = (UNALIGNED NETWORK_ADDRESS *)(((PUCHAR)pAddr) 
                                               + pAddr->AddressLength 
                                               + FIELD_OFFSET(NETWORK_ADDRESS, Address));
                    
                    if (pAddr->AddressType == NDIS_PROTOCOL_ID_TCP_IP) {
                    
                        //
                        // parse the second IP address,
                        // this would be the remote IP address for dialin WAN
                        // 
                        
                        pIpNetAddr = (UNALIGNED NETWORK_ADDRESS_IP *)&pAddr->Address[0];
                        *pSpecificLinkCtx = pIpNetAddr->in_addr;
                    }
                }
            }
            
        }
        
    }

    FreeMem(pIpAddrTbl);

#endif

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\tc\dll\handfact.h ===
//#define WIN32_LEAN_AND_MEAN 1
//#include <windows.h>

/*
 *  handfact.h
 *
 *  author:	John R. Douceur
 *  date:	26 January 1998
 *
 *  This header file defines structures, function prototypes, and macros for
 *  the handle factory.  The code is object-oriented C, transliterated from a
 *  C++ implementation.
 *
 *  The handle factory is a component that generates and validates handles.  It
 *  is intended to be used in a software module that provides client software
 *  modules with means to refer to information structures contained within the
 *  provider.  While such a means could simply be a pointer, this would not
 *  enable the deletion of the information structures without explicitly
 *  notifying the clients of such deletion.  Unlike pointers, the handles
 *  generated by the handle factory can be examined (by the handle factory)
 *  to determine their validity.
 *
 *  Handles can be invalidated in one of two ways.  The handle can be released
 *  by calling the release_HF_handle() function, indicating to the handle
 *  factory that the handle is no longer necessary and that future requests
 *  to dereference this handle should be met with a null pointer.  Alternately,
 *  the handle can be revoked by the handle factory; this will happen unter two
 *  circumstances.  If a large number of handles (more than four billion) are
 *  issued and subsequently released, it becomes necessary to reuse portions of
 *  the handle space for future assignments; under these circumstances, very
 *  old handles will be revoked well before this recycling occurs, to give the
 *  holders of those handles ample opportunity to notice that their handles
 *  have become invalid and to request new handles.  The other situation in
 *  which revokation can occur is if the amount of available memory becomes
 *  too small to allocate additional space to expand the handle database; then,
 *  if the assignment of a new handle is requested, the least-recently-assigned
 *  handle will be revoked to make room for the new request.
 *
 *  Use of the handle factory in a multi-threaded environment requires a lock.
 *  This lock must be taken by a single thread for the execution of either
 *  assign_HF_handle() or release_HF_handle().  Use of dereference_HF_handle()
 *  does not require taking a lock, since synchronization is handled internally
 *  through careful sequencing of read and write operations.
 *
 *  Because this code is C, rather than C++, it is not possible to hide as
 *  much of the implementation from the client code as one might wish.
 *  Nonetheless, there is an attempt to isolate the client from some of the
 *  implementation details through the use of macros.  Below is described each
 *  of the functions and macros necessary to use the handle factory.
 *
 */

#ifndef _INC_HANDFACT

#define _INC_HANDFACT

#ifdef __cplusplus
extern "C" {
#endif

/*
 *  There are two basic structures employed: the HFEntry and the HandleFactory.
 *  Ideally, these would be completely hidden from the client, but the size of
 *  the HandleFactory structure structure needs to be known by the client for
 *  allocation purposes, and this is most easily accomplished by declaring the
 *  structure itself here in the header file, which in turn requires declaring
 *  the HFEntry structure.  It is strongly urged that the client not directly
 *  refer to any of the fields of either of these structures.  To support the
 *  documentation of the accompanying rhizome.c file, these structures are
 *  annotated with internal comments, but these can be ignored by the reader
 *  who wishes only to understand how to write client code that makes use of
 *  the handle factory.
 *
 *  The handles generated by the handle factory are of type HFHandle.  This is
 *  typedefed to an unsigned int, but this fact can be ignored by the client,
 *  since it is an implementation detail.
 *
 */

//#include <stdlib.h>
//#include <malloc.h>

// HFHandle is the type of the handles generated by the handle factory.
//
typedef unsigned int HFHandle;

struct _HFEntry;

typedef struct _HFEntry HFEntry;

struct _HFEntry
{
	// This is the element in which each handle and its associated pointer are
	// stored.  If handle == next_handle, the entry is not assigned, and it is
	// available for assignment to a pointer via the assign_HF_handle()
	// function.  If handle != next_handle, then the entry is assigned to the
	// pointer in the reference field.
	//
	// Each entry is on one of three lists: the primary free list, the secondary
	// free list, or the assigned list.  Each of these lists is maintained via
	// the next_entry and prev_entry pointers.

	HFHandle handle;                                          // value of handle
	HFHandle next_handle;         // next value given to handle when invalidated
	void *reference;                           // pointer to which handle refers
	HFEntry *next_entry;                        // pointer to next entry in list
	HFEntry *prev_entry;                    // pointer to previous entry in list
};

struct _HandleFactory;

typedef struct _HandleFactory HandleFactory;

struct _HandleFactory
{
	// This structure contains private member variables for the handle factory.
	// The table_size and entries fields are marked volatile to insure that the
	// operations performed on them occur in the specified sequence.  The handle
	// factory can operate in a multi-threaded environment without requiring
	// that a lock be taken before calling dereference_HF_handle(), and this is
	// accomplished by careful sequencing of the read and write operations on
	// these two variables.
	//
	// There are two sets of table_size and entries variables, which are used
	// to provide a synchronization mechanism in conjunction with the two
	// sync variables.  The varset variable indicates which set of these three
	// variables is used by default.  Most normal operations (assign, release,
	// suspend, reinstate) simply use the default set of table_size and entries.
	// However, the expand and contract routines update both sets, and the
	// dereference routine needs to examine the sets in a special way to ensure
	// that it does not conflict with a concurrent expansion or contraction.
	//
	// The dereference_HF_handle() routine increments one of the sync variables
	// to indicate an intention to refer to the corresponding table_size and
	// entries variables.  The expand_HF_table() and contract_HF_table()
	// routines each massively decrement one of the sync variables to indicate
	// an intention to change the corresponding table_size and entries
	// variables.  All changes to the sync variables are done through
	// interlocked operations.
	//
	// The table that holds the handles can only be contracted (shrunk in half)
	// when for each assigned handle in the lower half of the table, there is
	// no assigned handle in the corresponding upper half of the table.  The
	// number of correspondences between the two table halves is given by
	// pair_count.

	volatile int table_size[2];             // size of table for storing entries
	HFEntry *volatile entries[2];                // pointer to tables of entries
	LONG sync[2];                                    // synchronization variable
	int varset;                                // variable set for default usage
	HFHandle handle_base;                // rolling point of lowest handle value
	int population;                      // number of handles currently assigned
	int pair_count;               // contractions can occur when pair_count == 0
	int hysteresis_debt;                      // must be zero before contraction
	HFEntry entry_list[3];                     // array of all three entry lists
};

/*
 *  The client interface to the handle factory is provided by seven functions
 *  and one macro.  It is expected that the provider will first instantiate a
 *  handle factory, either in the static data segment, on the stack, or on the
 *  heap.  Then, the provider will assign handles to various pointers by
 *  calling assign_HF_handle(), which it will distribute to its clients.  When
 *  the provider wishes to release these handles, it will do so by calling
 *  release_HF_handle().  Each time a client presents a handle to the provider,
 *  the provider can validate the handle and retrieve the associated pointer
 *  by calling dereference_HF_handle().  A client can temporarily suspend a
 *  handle by calling suspend_HF_handle(), after which it can either reinstate
 *  the handle by calling reinstate_HF_handle() or release the handle by calling
 *  release_HF_handle().
 *
 */

// A handle factory may be allocated in the static data segment or on the stack
// simply by declaring a variable of type HandleFactory.  To allocate it on the
// heap, the following macro returns a pointer to a new HandleFactory structure.
// If this macro is used, a corresponding call to free() must be made to
// deallocate the structure from the heap.
//
#define NEW_HandleFactory(_h) AllocMem(&(_h), sizeof(HandleFactory))

#define FreeHandleFactory(_h) FreeMem(_h)
// Since this is not C++, the HandleFactory structure is not self-constructing;
// therefore, the following constructor code must be called on the HandleFactory
// structure after it is allocated.  If the construction is successful, the
// function returns a value of 0.  If the construction fails (due, for example,
// to an inability to allocate memory), the function returns a value of 1.
//
int
constructHandleFactory(
	HandleFactory *hfact);

// Since this is not C++, the HandleFactory structure is not self-destructing;
// therefore, the following destructor code must be called on the HandleFactory
// structure before it is deallocated.
//
void
destructHandleFactory(
	HandleFactory *hfact);

// This function generates a new handle value, associates the handle value with
// the provided reference pointer, and returns the handle value.  Barring
// highly unusual circumstances, this handle will remain valid until it is
// explicitly released by a call to release_HF_handle().  However, there is no
// guarantee that the handle will persist for an arbitrary duration; it may
// become necessary for the handle factory to revoke the handle under some
// circumstances, particularly when the handle becomes very old or when memory
// becomes scarce.
//
// The assign_HF_handle() function will never return a handle value of zero.
// Thus, the client program is free to use a zero handle value as an escape
// indicator, if desired.
//
// In a multi-threaded environment, a single thread must take a lock prior to
// calling this function, and this must be the same lock taken before calling
// release_HF_handle(), suspend_HF_handle(), and reinstate_HF_handle().
//
HFHandle
assign_HF_handle(
	HandleFactory *hfact,
	void *reference);

// This function releases a handle, indicating that further attempts to
// dereference the handle should result in a null pointer value rather than the
// pointer value that was originally assigned to the handle.  The handle factory
// checks the validity of the handle and returns a corresponding status code.
// If the handle is currently assigned, then it is released, and the function
// returns a value of 0.  If the handle is not currently assigned, the function
// aborts and returns a value of 1.
//
// In a multi-threaded environment, a single thread must take a lock prior to
// calling this function, and this must be the same lock taken before calling
// assign_HF_handle(), suspend_HF_handle(), and reinstate_HF_handle().
//
int
release_HF_handle(
	HandleFactory *hfact,
	HFHandle handle);

// This function suspends a handle, indicating that further attempts to
// dereference the handle should result in a null pointer value rather than the
// pointer value that was originally assigned to the handle, unless and until
// reinstate_HF_handle() is called on the handle value.  The handle factory
// checks the validity of the handle and returns a corresponding status code.
// If the handle is currently assigned and not suspended, then it is suspended,
// and the function returns a value of 0.  If the handle is not currently
// assigned or has already been suspended, the function aborts and returns a
// value of 1.
//
// In a multi-threaded environment, a single thread must take a lock prior to
// calling this function, and this must be the same lock taken before calling
// assign_HF_handle(), release_HF_handle(), and reinstate_HF_handle().
//
int
suspend_HF_handle(
	HandleFactory *hfact,
	HFHandle handle);

// This function reinstates a suspended handle, indicating that further attempts
// to dereference the handle should result in the pointer value that was
// originally assigned to the handle, rather than the null pointer value to
// which a suspended handle dereferences.  The handle factory checks the
// validity of the handle and returns a corresponding status code. If the handle
// is currently assigned and suspended, then it is reinstated, and the function
// returns a value of 0.  If the handle is not currently assigned or is not
// suspended, the function aborts and returns a value of 1.
//
// In a multi-threaded environment, a single thread must take a lock prior to
// calling this function, and this must be the same lock taken before calling
// assign_HF_handle(), release_HF_handle(), and suspend_HF_handle().
//
int
reinstate_HF_handle(
	HandleFactory *hfact,
	HFHandle handle);

// This function validates a handle and returns either the associated pointer
// (if the handle is valid) or a null pointer value (if the handle is invalid).
// If the handle has not been released or suspended but a null value is
// returned, then the handle has been revoked by the handle factory.  This is
// expected to be a highly unusual occurrence; however, since it can happen, any
// program that employs the handle factory must have some auxiliary mechanism
// for retrieving the desired pointer information.  Once the pointer is
// retrieved through this (presumably expensive) auxiliary means, a new handle
// can be reassigned to the pointer by another call to assign_HF_handle().
//
// Even in a multi-threaded environment, it is not necessary to take a lock
// prior to calling this function.  Careful sequencing of read and write
// operations inside the handle factory code obviates the need to explicitly
// lock the data structure for dereferencing handles.
//
void *
dereference_HF_handle(
	HandleFactory *hfact,
	HFHandle handle);

#ifdef _TEST_HANDFACT

// This is a test routine that simply verifies the internal valididy of the
// handle factory's data structures.  By defining the constant _TEST_HANDFACT,
// this routine will be compiled and available to the client code.  It can be
// called at any time, unless running in a multi-threaded environment, in which
// case the caller must first take the same lock used for assign_HF_handle(),
// release_HF_handle(), suspend_HF_handle(), and reinstate_HF_handle().  If the
// routine returns any value other than zero, then the internal lists of records
// are in an inconsistent state.
//
int
verify_HF_lists(
	HandleFactory *hfact);

#endif /* _TEST_HANDFACT */

#ifdef __cplusplus
}
#endif

#endif	/* _INC_HANDFACT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\tc\dll\callback.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    callback.c

Abstract:

    This module contains the traffic control call back routines
    that are called by OS, either IO conpletion routines or WMI
    notifications.

Author:

	Ofer Bar (oferbar)		Oct 1, 1997

--*/

#include "precomp.h"

/*
Calculate the length of a unicode string with the NULL char
*/
int StringLength(TCHAR * String)
{
    const TCHAR *eos = String;

    while( *eos++ ) ;

    return( (int)(eos - String) );
}



VOID
NTAPI CbAddFlowComplete(
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    )
{
    PFLOW_STRUC				pFlow = (PFLOW_STRUC)ApcContext;
    DWORD					Status;
    PGPC_ADD_CF_INFO_RES    GpcRes;

    ASSERT(pFlow);

    GpcRes = (PGPC_ADD_CF_INFO_RES)pFlow->CompletionBuffer;
    
    ASSERT(GpcRes);

    Status = MapNtStatus2WinError(IoStatusBlock->Status);
    
    if (Status == NO_ERROR) {

        Status = MapNtStatus2WinError(GpcRes->Status);
    }

    IF_DEBUG(IOCTLS) {
        WSPRINT(("CbAddFlowComplete: Flow=0x%X GpcRes=0x%X IoStatus=0x%X Information=%d Status=0x%X\n", 
                 PtrToUlong(pFlow), 
                 PtrToUlong(GpcRes),
                 IoStatusBlock->Status, IoStatusBlock->Information,
                 Status));
    }

    if (Status == NO_ERROR) {

        pFlow->GpcHandle = GpcRes->GpcCfInfoHandle;
        pFlow->InstanceNameLength = GpcRes->InstanceNameLength;
        wcscpy(pFlow->InstanceName, GpcRes->InstanceName );
    }

    //
    // locate the client and notify the add flow completion
    //

    ASSERT(pFlow->pInterface->pClient->ClHandlers.ClAddFlowCompleteHandler);

    pFlow->pInterface->pClient->ClHandlers.ClAddFlowCompleteHandler(pFlow->ClFlowCtx, Status);

    //
    // complete the add flow
    //

    CompleteAddFlow(pFlow, Status);
}



VOID
NTAPI CbModifyFlowComplete(
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    )
{
    PFLOW_STRUC				pFlow = (PFLOW_STRUC)ApcContext;
    DWORD					Status;
    PGPC_MODIFY_CF_INFO_RES GpcRes;

    ASSERT(pFlow);

    GpcRes = (PGPC_MODIFY_CF_INFO_RES)pFlow->CompletionBuffer;
    
    // it is likely that the flow got deleted while we tried to 
    // modify it. in that case, just clean up, remove the ref 
    // and get out.
    GetLock(pFlow->Lock);

    if (QUERY_STATE(pFlow->State) != OPEN) {
    
        FreeLock(pFlow->Lock);
        
        if (pFlow->CompletionBuffer) {
            
            FreeMem(pFlow->CompletionBuffer);
            pFlow->CompletionBuffer = NULL;

        }
    
        if (pFlow->pGenFlow1) {
            FreeMem(pFlow->pGenFlow1);
            pFlow->pGenFlow1 = NULL;
        }

        // call them back.
        ASSERT(pFlow->pInterface->pClient->ClHandlers.ClModifyFlowCompleteHandler);

        pFlow->pInterface->pClient->ClHandlers.ClModifyFlowCompleteHandler(pFlow->ClFlowCtx,  ERROR_INVALID_HANDLE);

        //
        // This ref was taken in TcModifyFlow
        //

        REFDEL(&pFlow->RefCount, 'TCMF');
        return;

    }

    FreeLock(pFlow->Lock);

    ASSERT(GpcRes);

    Status = MapNtStatus2WinError(IoStatusBlock->Status);
    
    if (Status == NO_ERROR) {

        Status = MapNtStatus2WinError(GpcRes->Status);
    }

    IF_DEBUG(IOCTLS) {
        WSPRINT(("CbModifyFlowComplete: Flow=0x%X GpcRes=0x%X IoStatus=0x%X Information=%d Status=0x%X\n", 
                 PtrToUlong(pFlow), 
                 PtrToUlong(GpcRes),
                 IoStatusBlock->Status, IoStatusBlock->Information,
                 Status));
    }

    //
    // locate the client and notify the modify flow completion
    //
    
    ASSERT(pFlow->pInterface->pClient->ClHandlers.ClModifyFlowCompleteHandler);
    
    pFlow->pInterface->pClient->ClHandlers.ClModifyFlowCompleteHandler(pFlow->ClFlowCtx, Status);

    //
    // complete the modify flow
    //

    CompleteModifyFlow(pFlow, Status);
}



VOID
NTAPI CbDeleteFlowComplete(
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    )
{
    PFLOW_STRUC				pFlow = (PFLOW_STRUC)ApcContext;
    DWORD					Status;
    PGPC_REMOVE_CF_INFO_RES GpcRes;

    ASSERT(pFlow);

    GpcRes = (PGPC_REMOVE_CF_INFO_RES)pFlow->CompletionBuffer;
    
    ASSERT(GpcRes);

    Status = MapNtStatus2WinError(IoStatusBlock->Status);
    
    if (Status == NO_ERROR) {

        Status = MapNtStatus2WinError(GpcRes->Status);
    }

    ASSERT(Status != ERROR_SIGNAL_PENDING);

    IF_DEBUG(IOCTLS) {
        WSPRINT(("CbDeleteFlowComplete: Flow=0x%X GpcRes=0x%X IoStatus=0x%X Information=%d Status=0x%X\n", 
                 PtrToUlong(pFlow), 
                 PtrToUlong(GpcRes),
                 IoStatusBlock->Status, IoStatusBlock->Information,
                 Status));
    }

    //
    // locate the client and notify the delete flow completion
    //

    ASSERT(pFlow->pInterface->pClient->ClHandlers.ClDeleteFlowCompleteHandler);

    pFlow->pInterface->pClient->ClHandlers.ClDeleteFlowCompleteHandler(pFlow->ClFlowCtx, Status);

    //
    // complete the Delete flow
    //

    CompleteDeleteFlow(pFlow, Status);
}



VOID
NTAPI 
CbGpcNotifyRoutine(
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    )
{
    PGPC_NOTIFY_REQUEST_RES     GpcRes = (PGPC_NOTIFY_REQUEST_RES)ApcContext;
    PFLOW_STRUC					pFlow;
    PCLIENT_STRUC				pClient;
    PINTERFACE_STRUC			pInterface;
    HANDLE						FlowCtx;

    if (IoStatusBlock->Status == STATUS_CANCELLED) 
    {
        IF_DEBUG(IOCTLS) {
            WSPRINT(("==>CbGpcNotifyRoutine: CANCELLED\n"));
        }
        if ( GpcCancelEvent != INVALID_HANDLE_VALUE )
            SetEvent ( GpcCancelEvent );
            
        return;
    }
    
    ASSERT(GpcRes->SubCode == GPC_NOTIFY_CFINFO_CLOSED);
    
    IF_DEBUG(IOCTLS) {
        WSPRINT(("==>CbGpcNotifyRoutine: Context=%d IoStatus=0x%X Information=%d\n", 
                 ApcContext, IoStatusBlock->Status, IoStatusBlock->Information));
    }

    if (GpcRes->SubCode == GPC_NOTIFY_CFINFO_CLOSED) {

        pFlow = (PFLOW_STRUC)GpcRes->NotificationCtx;

        ASSERT(pFlow);

        pInterface = pFlow->pInterface;
        pClient = pInterface->pClient;

        //
        // since the GPC will NOT wait for confirmation about the 
        // flow deletion, we expect the user to delete each filter
        // but don't want the IOCTL to go down to the GPC,
        // therefore, we'll mark eahc filter with Delete flag.
        //

        GetLock(pGlobals->Lock);

        FlowCtx = pFlow->ClFlowCtx;
        
        //
        // The Flags need protection from flow->lock
        //
        GetLock(pFlow->Lock);
        SET_STATE(pFlow->State, REMOVED);
        FreeLock(pFlow->Lock);

        DeleteFlow( pFlow, TRUE );

        FreeLock(pGlobals->Lock);

        //
        // notify the user about the flow close
        //

        pClient->ClHandlers.ClNotifyHandler(pClient->ClRegCtx,
                                            pInterface->ClIfcCtx,
                                            TC_NOTIFY_FLOW_CLOSE,
                                            ULongToPtr(GpcRes->Reason),
                                            sizeof(FlowCtx),
                                            (PVOID)&FlowCtx
                                            );
    }        
    
    //
    // finally, release this memory
    //

    FreeMem(GpcRes);

    //
    // make the next call to the GPC.
    // Ignoring errors as nothing more can be done :-(

    IoRequestNotify();

    return;
}






VOID
CbParamNotifyClient(
    IN	ULONG	Context,
    IN  LPGUID	pGuid,
	IN	LPWSTR	InstanceName,
    IN	ULONG	DataSize,
    IN	PVOID	DataBuffer
    )
/*
  Description:

	This is a callback routine that is called when there is a incoming
    WMI interface parameter change event notification. The WMI notification
    handler calls a helper routine to walk the wnode and passing a pointer
    to this routine. This callback routine will be called for each instance
    name identified in the wnode with the buffer and buffer size.
    The client will be called on its notification handler (given during
    client registration) to let it know about the parameter value change.

*/  
{
    PINTERFACE_STRUC	pInterface, oldInterface = NULL;
    PTC_IFC				pTcIfc;
    PLIST_ENTRY			pHead, pEntry;
    TCI_NOTIFY_HANDLER	callback;

    IF_DEBUG(CALLBACK) {
        WSPRINT(("==>CbParamNotifyClient: Context=%d, Guid=%08x-%04x-%04x iName=%S Size=%d\n", 
                 Context, pGuid->Data1, pGuid->Data2, pGuid->Data3, InstanceName, DataSize));
    }

    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);

    pTcIfc = GetTcIfcWithRef(InstanceName, 'CALL');
        
    if (pTcIfc) {

            GetLock(pGlobals->Lock);
    
            pHead = pEntry = &pTcIfc->ClIfcList;

            pEntry = pEntry->Flink;

            while (pEntry != pHead) {
    
                pInterface =    CONTAINING_RECORD(pEntry, INTERFACE_STRUC, NextIfc);
                ASSERT(pInterface);

                GetLock(pInterface->Lock);

                if (QUERY_STATE(pInterface->State) != OPEN) {
    
                    FreeLock(pInterface->Lock);
                    pEntry = pEntry->Flink;
                    continue;

                } else {

                    FreeLock(pInterface->Lock);
                    REFADD(&pInterface->RefCount, 'CBNC');

                }

                FreeLock(pGlobals->Lock);
                
                //
                // call the client
                //
                    

                callback = pInterface->pClient->ClHandlers.ClNotifyHandler;
                    
                ASSERT(callback);
                    
                IF_DEBUG(CALLBACK) {
                    WSPRINT(("CbParamNotifyClient: Context=%d, IfcH=%d ClientH=%d ClientCtx=%d IfcCtx=%d\n", 
                             Context, pInterface->ClHandle, pInterface->pClient->ClHandle, 
                             pInterface->pClient->ClRegCtx, pInterface->ClIfcCtx));
                }
        
                //
                // 258218: call the client only if it registered for this.
                //
                if (TcipClientRegisteredForNotification(pGuid, pInterface, 0)) {
                    
                    callback(pInterface->pClient->ClRegCtx,
                             pInterface->ClIfcCtx,
                             TC_NOTIFY_PARAM_CHANGED,
                             pGuid,
                             DataSize,
                             DataBuffer
                             );
                    
                }
    
                //
                // Take the lock, so that no one's monkeying with the list
                // while we are in there.
                //
                GetLock(pGlobals->Lock);

                pEntry = pEntry->Flink;
                    
                REFDEL(&pInterface->RefCount, 'CBNC');

            }
                
            FreeLock(pGlobals->Lock);
            
            REFDEL(&pTcIfc->RefCount, 'CALL');

        }


    IF_DEBUG(CALLBACK) {
        WSPRINT(("<==CbParamNotifyClient: exit\n"));
    }
}

VOID
CbInterfaceNotifyClient(
    IN	ULONG	Context,
    IN  LPGUID	pGuid,
	IN	LPWSTR	InstanceName,
    IN	ULONG	DataSize,
    IN	PVOID	DataBuffer
    )
/*
  Description:

	This is a callback routine that is called when there is a incoming
    WMI interface indication event notification. The WMI notification
    handler calls a helper routine to walk the wnode and passing a pointer
    to this routine. Each registered client should be called at its
    notification handler and be passed the client context. In addition,
    if the notified interface was opened by the client, the interface
    context will also be passed in the same call. There are three kernel
    interface indications (UP, DOWN, CHANGE) which are mapped to two
    user notifications: 
    {UP,CHANGE} ==> TC_NOTIFY_IFC_CHANGE
    {DOWN} ==> TC_NOTIFY_IFC_CLOSE

    This routine first update the internal cached TcIfcList, so that
    the next TcEnumerateInterfaces will return an updated view of the
    TC kernel interfaces.

*/  
{
    DWORD				Status;
    PINTERFACE_STRUC	pInterface;
    PCLIENT_STRUC		pClient;
    TCI_NOTIFY_HANDLER	callback;
    PTC_IFC				pTcIfc;
    PGEN_LIST			pNotifyInterfaceList = NULL;
    PGEN_LIST			pNotifyClientList = NULL;
    PGEN_LIST			pItem;
    PLIST_ENTRY			pEntry, pHead, pFlowEntry, pFilterEntry;
    PFLOW_STRUC         pFlow;
    PFILTER_STRUC       pFilter;
    PGEN_LIST 			p;
    ULONG				NotificationCode = 0;
    PTC_INDICATION_BUFFER	IndicationBuffer 
        = (PTC_INDICATION_BUFFER)DataBuffer;

    if (CompareGUIDs(pGuid, &GUID_QOS_TC_INTERFACE_DOWN_INDICATION)) {
        NotificationCode = TC_NOTIFY_IFC_CLOSE;
    } else if (CompareGUIDs(pGuid, &GUID_QOS_TC_INTERFACE_UP_INDICATION)) {
        NotificationCode = TC_NOTIFY_IFC_UP;
    } else if (CompareGUIDs(pGuid, &GUID_QOS_TC_INTERFACE_CHANGE_INDICATION)) {
        NotificationCode = TC_NOTIFY_IFC_CHANGE;
    }

    ASSERT(NotificationCode != 0);
        
    //
    // update the TC interface list, this means add a new interface,
    // remove an interface or update the net addr list
    //

    if (NotificationCode != TC_NOTIFY_IFC_CLOSE) {

        //
        // don't call this in case of IFC_DOWN now.
        // we'll do it after notifying the clients
        //

        Status = UpdateTcIfcList(InstanceName,
                                 DataSize,
                                 IndicationBuffer,
                                 NotificationCode
                                 );
    } 

    //
    // find a TC interface that matches the name
    //

    pTcIfc = GetTcIfcWithRef(InstanceName, 'CALL');
    
    if (pTcIfc == NULL) {

        //
        // no interface has been opened yet, possible that the driver
        // indicated a change before the interface up
        //
        
        return;
    }

    //
    // if the Interface is going down - just mark it for now.
    // In addition, mark the whole tree of objects that it supports too
    // This includes all the filters and flows..
    if (NotificationCode == TC_NOTIFY_IFC_CLOSE) {
        
        GetLock(pTcIfc->Lock);
        SET_STATE(pTcIfc->State, KERNELCLOSED_USERCLEANUP);
        FreeLock(pTcIfc->Lock);

        GetLock(pGlobals->Lock);

        pHead = &pTcIfc->ClIfcList;
        pEntry = pHead->Flink;
    
        while (pHead != pEntry) {
    
            pInterface = CONTAINING_RECORD(pEntry, INTERFACE_STRUC, NextIfc);
            GetLock(pInterface->Lock);
            if (QUERY_STATE(pInterface->State) == OPEN) {
                
                SET_STATE(pInterface->State, FORCED_KERNELCLOSE);
                FreeLock(pInterface->Lock);
                MarkAllNodesForClosing(pInterface, FORCED_KERNELCLOSE);            

            } else {
                
                FreeLock(pInterface->Lock);
                ASSERT(IsListEmpty(&pInterface->FlowList));

            }

            pEntry = pEntry->Flink;

        }

        FreeLock(pGlobals->Lock);

    }

    //
    // Build the list of every interface that needs to be notified
    //

    GetLock(pGlobals->Lock);

    pHead = &pTcIfc->ClIfcList;
    pEntry = pHead->Flink;

    while (pHead != pEntry) {

        pInterface = CONTAINING_RECORD(pEntry, INTERFACE_STRUC, NextIfc);
        
        //
        // Lock and check for open state.
        //
        GetLock(pInterface->Lock);

        if ((QUERY_STATE(pInterface->State) != OPEN) &&
            (QUERY_STATE(pInterface->State) != FORCED_KERNELCLOSE)) {
                
            FreeLock(pInterface->Lock);
            pEntry = pEntry->Flink;

        } else {

            FreeLock(pInterface->Lock);
            
            AllocMem(&pItem, sizeof(GEN_LIST));
    
            if (pItem == NULL)
                break;
    
            //
            // add a refcount since we'll release the lock later
            //
            REFADD(&pInterface->RefCount, 'CINC');
    
            //
            // add the interface to the list head
            //
            pItem->Next = pNotifyInterfaceList;
            pItem->Ptr = (PVOID)pInterface;
            pNotifyInterfaceList = pItem;
    
            pEntry = pEntry->Flink;

        }

    }

    //
    // now build the list of clients that don't have this interface opened
    // they still need to be notified, so they will be able to update the list
    // of interfaces
    //
    
    pHead = &pGlobals->ClientList;
    pEntry = pHead->Flink;

    while (pHead != pEntry) {

        pClient = CONTAINING_RECORD(pEntry, CLIENT_STRUC, Linkage);
        
        //
        // search the client on the interface notify list
        //
        GetLock(pClient->Lock);

        if (QUERY_STATE(pClient->State) != OPEN) {

        } else {

            for (p = pNotifyInterfaceList; p != NULL; p = p->Next) {

                if (pClient == ((PINTERFACE_STRUC)p->Ptr)->pClient) {
                
                    //
                    // found!
                    //
                    break;
                }
            }

            if (p == NULL) {

                //
                // add the client to the list head
                //

                AllocMem(&pItem, sizeof(GEN_LIST));
            
                if (pItem == NULL) {

                    FreeLock(pClient->Lock);
                    break;

                }

                REFADD(&pClient->RefCount, 'CINC'); // Dont want the client to slip away.
                pItem->Next = pNotifyClientList;
                pItem->Ptr = (PVOID)pClient;
                pNotifyClientList = pItem;
            }
        }

        pEntry = pEntry->Flink;
        FreeLock(pClient->Lock);

    }

    FreeLock(pGlobals->Lock);

    //
    // now we have two separate lists of clients and interfaces we
    // need to send notifications on
    //

    //
    // start with the list of interfaces
    //

    for (p = pNotifyInterfaceList; p != NULL; ) {
        
        pInterface = (PINTERFACE_STRUC)p->Ptr;

        callback = pInterface->pClient->ClHandlers.ClNotifyHandler;

        ASSERT(callback);
        
        // we now add the thread id to avoid deadlock.
        // in the callback, an app can come back in to
        // close the interface, we dont want to block there.
        // it is set back to Zero after the callback.
        pInterface->CallbackThreadId = GetCurrentThreadId();

        // 
        // 275482 - Indicate the Interfacename instead of the 
        // the addresses (what good are addresses, asks ericeil).
        //

        callback(pInterface->pClient->ClRegCtx,
                 pInterface->ClIfcCtx,
                 NotificationCode,
                 ULongToPtr(IndicationBuffer->SubCode),
                 StringLength(InstanceName) * sizeof(WCHAR),
                 InstanceName
                 );
        
        pNotifyInterfaceList = p->Next;
        FreeMem(p);
        p = pNotifyInterfaceList;

        // reset the threadid - the callback is done.
        pInterface->CallbackThreadId = 0;

        //
        // release the previous refcount we kept across the callback
        //

        REFDEL(&pInterface->RefCount, 'CINC');

        if (NotificationCode == TC_NOTIFY_IFC_CLOSE) {

            //
            // now we can remove the interface, and all the supported flows
            // and filters
            //
            
            GetLock(pInterface->Lock);
            SET_STATE(pInterface->State, KERNELCLOSED_USERCLEANUP);
            FreeLock(pInterface->Lock);

            CloseInterface(pInterface, TRUE);
        
        }

    }

    ASSERT(pNotifyInterfaceList == NULL);

    //
    // next, scan the list of clients (didn't open this interface)
    //

    for (p = pNotifyClientList; p != NULL; ) {
        
        pClient = (PCLIENT_STRUC)p->Ptr;

        callback = pClient->ClHandlers.ClNotifyHandler;

        ASSERT(callback);

        callback(pClient->ClRegCtx,
                 NULL,
                 NotificationCode,
                 ULongToPtr(IndicationBuffer->SubCode),
                 (wcslen(InstanceName) + 1)* sizeof(WCHAR),
                 InstanceName
                 );


        //
        // Deref the ref we took to keep the client around when we 
        // made the pnotifyclientlist
        //
        REFDEL(&pClient->RefCount, 'CINC');

        //
        // free the items as we walk down the list
        //

        pNotifyClientList = p->Next;
        FreeMem(p);
        p = pNotifyClientList;

    }


    REFDEL(&pTcIfc->RefCount, 'CALL');

    ASSERT(pNotifyClientList == NULL);

    if (NotificationCode == TC_NOTIFY_IFC_CLOSE) {

        //
        // time to remove the TC interface
        //
        Status = UpdateTcIfcList(InstanceName,
                                 DataSize,
                                 IndicationBuffer,
                                 NotificationCode
                                 );
    }

}


VOID
CbWmiParamNotification(
   IN  PWNODE_HEADER 	pWnodeHdr,
   IN  ULONG 			Context
   )
/*

Description:

	This callback routine is called by WMI when there is a notification
    for the GUID previously registered. The Context parameter is the
    interface handle. If it is still valid, we call the client's 
    notification handler (if exist) and pass it the notified data.
*/
{
    WalkWnode(pWnodeHdr,
              Context,
              CbParamNotifyClient
              );
}




VOID
CbWmiInterfaceNotification(
   IN  PWNODE_HEADER pWnodeHdr,
   IN  ULONG Context
   )
/*

Description:

	This callback routine is called by WMI when there is a notification
    for the GUID_QOS_TC_INTERFACE_INDICATION. We parse the data buffer
    in the Wnode and determine which event to notify the client.
    Each client will be notified at its notification handler.

*/
{
    WalkWnode(pWnodeHdr,
              Context,
              CbInterfaceNotifyClient
              );
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\tc\dll\dbgmem.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    dbgmem.h

Abstract:

    This module contains memory debug function prototypes and macros.

Author:

    Jim Stewart    January 8, 1997

Revision History:

	Ofer Bar ( oferbar )     Oct 1, 1996 - Revision II changes

--*/

#ifdef  DBG
//
// define the amount of symbol info to keep per function in the stack trace.
//
#define MAX_FUNCTION_INFO_SIZE  20
typedef struct {

    DWORD_PTR   Displacement;                   // displacement into the function
    UCHAR   Buff[MAX_FUNCTION_INFO_SIZE];   // name of function on call stack


} CALLER_SYM, *PCALLER_SYM;

//
// NOTE:
// If you change the structure of MEM_TRACKER, please make sure it's size
// aligned to 8-byte boundary
//
#define NCALLERS    5
typedef struct {

    LIST_ENTRY  Linkage;
    PSZ         szFile;
    ULONG       nLine;
    ULONG       nSize;
    ULONG       ulAllocNum;
    CALLER_SYM  Callers[NCALLERS];
    ULONG       ulCheckSum;
    ULONG       ulPad;          // To make the struct aligned to 8-byte

} MEM_TRACKER, *PMEM_TRACKER;


BOOL
InitDebugMemory(
    );

VOID
DeInitDebugMemory(
    );


VOID
UpdateCheckBytes(
    IN PMEM_TRACKER TrackMem
    );

BOOL
FCheckCheckBytes(
    IN PMEM_TRACKER TrackMem
    );

BOOL
FCheckAllocatedMemory();

VOID
AddPamem(
    IN PMEM_TRACKER TrackMem
    );

VOID
RemovePamem(
    IN  PMEM_TRACKER TrackMem
    );

VOID
GetCallStack(
    IN PCALLER_SYM pdwCaller,
    IN int         cSkip,
    IN int         cFind
    );

PVOID
AllocMemory(
    IN DWORD       nSize,
    IN BOOL        Calloc,
    IN PSZ         szFileName,
    IN DWORD       nLine
    );

PVOID
ReAllocMemory(
    IN PVOID    pvOld,
    IN DWORD    nSizeNew,
    IN PSZ      szFileName,
    IN DWORD    nLine
    );

VOID
FreeMemory(
    IN PVOID    pv,
    IN PSZ      szFileName,
    IN DWORD    nLine
    );

BOOL
DumpAllocatedMemory();

BOOL
SearchAllocatedMemory(
    IN PSZ      szFile,
    IN DWORD    nLine
    );

VOID
Trace(
    IN DWORD      Severity,
    IN const CHAR *Format,
    IN ...
    );

BOOL
ControlCTermination(
    IN DWORD      ControlType
    );


#endif  // #ifdef DBG


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\tc\dll\t1.c ===
#include "precomp.h"

int
__cdecl
main()
{
    TcSetupInterfaceConfiguration(ADDRESS_TYPE_IP,
                                  TRUE,				// installFlows
                                  TEXT("")
                                  );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\tc\dll\init.c ===
/*++

Copyright (c) 1996-1997 Microsoft Corporation

Module Name:

    init.c

Abstract:

    This module contains initialization code for traffic.DLL.

Author:

    Jim Stewart ( jstew )    July 28, 1996

Revision History:

	Ofer Bar (oferbar)		Oct 1, 1997

--*/

#include "precomp.h"
//#pragma hdrstop

//#include "oscode.h"

//
// global data
//
ULONG       	DebugMask = 0;
BOOL        	NTPlatform = FALSE;
//LPWSCONTROL 	WsCtrl = NULL;
PGLOBAL_STRUC	pGlobals = NULL;
DWORD    		InitializationStatus = NO_ERROR;

static	BOOL				_init_rpc = FALSE;
static	PUSHORT 			_RpcStringBinding;

//
// 258218 changes
//
TRAFFIC_LOCK        NotificationListLock;
LIST_ENTRY          NotificationListHead;

TRAFFIC_LOCK        ClientRegDeregLock;
HANDLE              GpcCancelEvent = INVALID_HANDLE_VALUE;

PVOID               hinstTrafficDll;

VOID
CloseAll(VOID);

#if DBG
TCHAR *TC_States[] = {
    TEXT("INVALID"),
    TEXT("INSTALLING"),     // structures were allocated.
    TEXT("OPEN"),           // Open for business
    TEXT("USERCLOSED_KERNELCLOSEPENDING"), // the user component has closed it, we are awaiting a kernel close
    TEXT("FORCED_KERNELCLOSE"),            // the kernel component has forced a close.
    TEXT("KERNELCOSED_USERCLEANUP"),       // Kernel has closed it, we are ready to delete this obj.
    TEXT("REMOVED"),        // Its gone (being freed - remember that the handle has to be freed before removing)
    TEXT("EXIT_CLEANUP"),  // We are going away and need to be cleanedup
    TEXT("MAX_STATES")
    
};

#endif 

BOOL
Initialize (
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PVOID Context OPTIONAL
    )
/*++

Description:
    This is the DLL entry point, called when a process  
    attaches or a thread is created

Arguments:

    DllHandle   - a handle to the DLL
    Reason      - why the dll entry point is being called
    Context     - additional information about call reason

Return Value:

    TRUE or FALSE

--*/
{
    HANDLE 		Handle;
    DWORD   	Error;

    //
    // On a thread detach, set up the context param so that all
    // necessary deallocations will occur. On a FreeLibrary call Context
    // will be NULL and that is the case that we DO want to cleanup.
    //

    if ( Reason == DLL_THREAD_DETACH ) {
        Context = NULL;
    }

    switch ( Reason ) {

    case DLL_PROCESS_ATTACH:

        // Save the DLL handle as it is used to change ref count on this DLL
        hinstTrafficDll = DllHandle;
        
        //
        // disable the DLL_THREAD_ATTACH event
        //

        DisableThreadLibraryCalls( DllHandle );

        SETUP_DEBUG_INFO();

        IF_DEBUG(INIT) {

            WSPRINT(( "Initialize: DLL Process Attach \n" ));
        }

        INIT_DBG_MEMORY();

        if (!InitializeGlobalData()) {

            CLOSE_DEBUG();
            return FALSE;
        }

        IF_DEBUG(INIT) {
            WSPRINT(("traffic.dll Version %d\n", CURRENT_TCI_VERSION));
        }

        InitializationStatus = InitializeOsSpecific();

        if (ERROR_FAILED(InitializationStatus)) {

            WSPRINT(("\tInitialize: Failed OS specific initialization!\n"));
            CLOSE_DEBUG();

            //
            // we return TRUE to succedd DLL loading into the process
            // all other TCI calls will check this and fail...
            //

            return TRUE;

        } else {

#if 0
            InitializeWmi();

            //
            // call to internally enumerate the interfaces
            //

             EnumAllInterfaces();
#endif
        }

        //InitializeIpRouteTab();

        break;

    case DLL_PROCESS_DETACH:

        if ( Context )
        {
            // As per MSDN a non-zero Context means process is
            // terminating. Do not do any cleanup
            break;
        }
        
        IF_DEBUG(SHUTDOWN) {

            WSPRINT(( "Shutdown: Process Detach, Context = %X\n",Context ));
        }

        //DUMP_MEM_ALLOCATIONS();

        //
        // Only clean up resources if we're being called because of a
        // FreeLibrary().  If this is because of process termination,
        // do not clean up, as the system will do it for us.  However 
        // we must still clear all flows and filters with the kernel 
        // since the system will not clean these up on termination.
        //

        //
        // don't want to get WMI notifications
        //

        DeInitializeWmi();

        //
        // close all flows and filters with the kernel and deregister from GPC
        //

        CloseAll();

        //
        // close the kernel file handle
        //

        DeInitializeOsSpecific();

        //
        // release all allocated resources
        //
       
        DeInitializeGlobalData();

        //
        // dump allocated memory, before and after we cleanup to 
        //  help track any leaks 

        DUMP_MEM_ALLOCATIONS();

        DEINIT_DBG_MEMORY();

        CLOSE_DEBUG();
        
        break;

    case DLL_THREAD_DETACH:

        IF_DEBUG(SHUTDOWN) {

            WSPRINT(( "Shutdown: thread detach\n" ));
        }

        break;

    case DLL_THREAD_ATTACH:
        break;

    default:

        ASSERT( FALSE );
        break;
    }

    return TRUE;

}



VOID
CloseAll()
/*++

Description:

    Close all interfaces, all flows and all filters. 
    Also deregister GPC clients and release all TC ineterfaces.

Arguments:

    none

Return Value:

    none

--*/
{
    DWORD       		Status;
    PLIST_ENTRY 		pEntry;
    PINTERFACE_STRUC  	pInterface;
    PCLIENT_STRUC		pClient;
    PGPC_CLIENT			pGpcClient;
    PTC_IFC				pTcIfc;

    IF_DEBUG(SHUTDOWN) {
        WSPRINT(( "CloseAll: Attempting to close any open interface\n" ));
    }

    while (!IsListEmpty( &pGlobals->ClientList )) {

        pClient = CONTAINING_RECORD( pGlobals->ClientList.Flink,
                                     CLIENT_STRUC,
                                     Linkage );

        IF_DEBUG(SHUTDOWN) {
            WSPRINT(( "CloseAll: Closing client=0x%X\n",
                      PtrToUlong(pClient)));
        }

        while (!IsListEmpty( &pClient->InterfaceList )) {

            pInterface = CONTAINING_RECORD( pClient->InterfaceList.Flink,
                                            INTERFACE_STRUC,
                                            Linkage );

            //
            // remove all flows/filters and close the interface
            //


            IF_DEBUG(SHUTDOWN) {
                WSPRINT(( "CloseAll: Closing interface=0x%X\n",
                          PtrToUlong(pInterface)));
            }
		
            MarkAllNodesForClosing(pInterface, EXIT_CLEANUP); 
            CloseInterface(pInterface, TRUE);
        }

        //
        // deregister the client
        //

        IF_DEBUG(SHUTDOWN) {
            WSPRINT(( "CloseAll: Deregistring TC client\n"));
        }

        TcDeregisterClient(pClient->ClHandle);

    }


    //
    // Deregister GPC clients
    //

    while (!IsListEmpty( &pGlobals->GpcClientList )) {

        pEntry = pGlobals->GpcClientList.Flink;

        pGpcClient = CONTAINING_RECORD( pEntry,
                                        GPC_CLIENT,
                                        Linkage );

        IF_DEBUG(SHUTDOWN) {
            WSPRINT(( "CloseAll: Deregistring GPC client\n"));
        }

        IoDeregisterClient(pGpcClient);

        RemoveEntryList(pEntry);

        FreeMem(pGpcClient);
    }


    //
    // Remove TC interfaces
    //

    while (!IsListEmpty( &pGlobals->TcIfcList )) {

        pEntry = pGlobals->TcIfcList.Flink;

        pTcIfc = CONTAINING_RECORD( pEntry,
                                    TC_IFC,
                                    Linkage );

        ASSERT( IsListEmpty( &pTcIfc->ClIfcList ) );

        IF_DEBUG(SHUTDOWN) {
            WSPRINT(( "CloseAll: Remove TC (%x) interface from list\n", pTcIfc));
        }

        REFDEL(&pTcIfc->RefCount, 'KIFC');
    }

    IF_DEBUG(SHUTDOWN) {
        WSPRINT(( "<==CloseAll: exit...\n"));
    }

}




DWORD
InitializeGlobalData(VOID)

/*++

Description:
    This routine initializes the global data.

Arguments:

    none

Return Value:

    none

--*/
{
    DWORD   Status;
    //
    // allocate memory for the globals
    //

    AllocMem(&pGlobals, sizeof(GLOBAL_STRUC));

    if (pGlobals == NULL) {

        return FALSE;
    }

    RtlZeroMemory(pGlobals, sizeof(GLOBAL_STRUC));

    __try {

        InitLock( pGlobals->Lock );
        InitLock( NotificationListLock);
        InitLock( ClientRegDeregLock );

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode();

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcRegisterClient: Exception Error: = 0x%X\n", Status ));
        }

        FreeMem(pGlobals);

        return FALSE;

    }

    //
    // initialize the handle table
    //

    NEW_HandleFactory(pGlobals->pHandleTbl);
    
    if (pGlobals->pHandleTbl == NULL) {

        FreeMem(pGlobals);
        return FALSE;
    }

    if (constructHandleFactory(pGlobals->pHandleTbl) != 0) {

        //
        // failed to construct the handle table, exit
        //

        FreeHandleFactory(pGlobals->pHandleTbl);
        FreeMem(pGlobals);
        return FALSE;
    }

    InitializeListHead( &pGlobals->ClientList );
    InitializeListHead( &pGlobals->TcIfcList );
    InitializeListHead( &pGlobals->GpcClientList );
    InitializeListHead( &NotificationListHead );        // 258218

    ASSERT(sizeof(IP_PATTERN) == sizeof(GPC_IP_PATTERN));
    ASSERT(FIELD_OFFSET(IP_PATTERN,SrcAddr) ==
           FIELD_OFFSET(GPC_IP_PATTERN,SrcAddr));
    ASSERT(FIELD_OFFSET(IP_PATTERN,ProtocolId) ==
           FIELD_OFFSET(GPC_IP_PATTERN,ProtocolId));
    return TRUE;
}




VOID
DeInitializeGlobalData(VOID)

/*++

Description:
    This routine de-initializes the global data.

Arguments:

    none

Return Value:

    none

--*/
{
    PLIST_ENTRY		pEntry;
    PTC_IFC			pTcIfc;
    PNOTIFICATION_ELEMENT   pNotifyElem;

    IF_DEBUG(SHUTDOWN) {
        WSPRINT(( "DeInitializeGlobalData: cleanup global data\n"));
    }

    destructHandleFactory(pGlobals->pHandleTbl);
    FreeHandleFactory(pGlobals->pHandleTbl);

#if 0
    //
    // clear the TC interface structures 
    //

    while (!IsListEmpty(&pGlobals->TcIfcList)) {

        pEntry = RemoveHeadList(&pGlobals->TcIfcList);
        pTcIfc = (PTC_IFC)CONTAINING_RECORD(pEntry, TC_IFC, Linkage);

        FreeMem(pTcIfc);
    }
#endif

    DeleteLock( pGlobals->Lock );
    
    //
    // Free the notification elements (258218)
    //
    while (!IsListEmpty(&NotificationListHead)) {

        pEntry = RemoveHeadList(&NotificationListHead);
        pNotifyElem = (PNOTIFICATION_ELEMENT)CONTAINING_RECORD(pEntry, NOTIFICATION_ELEMENT, Linkage.Flink);

        FreeMem(pNotifyElem);
    }

    DeleteLock( NotificationListLock);
    DeleteLock( ClientRegDeregLock );
    

    FreeMem(pGlobals);

    IF_DEBUG(SHUTDOWN) {
        WSPRINT(( "<==DeInitializeGlobalData: exit\n"));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\tc\dll\oscode.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    oscode.c

Abstract:

    This module contains support routines for the traffic DLL.

Author:

    Jim Stewart (jstew)    August 14, 1996

Revision History:

--*/


#include "precomp.h"
//#pragma hdrstop

//#include "oscode.h"

//
// function pointers for NT functions to Open driver
//
FARPROC    CreateFileNt = NULL;
FARPROC    CloseNt = NULL;
FARPROC    NtStatusToDosError = NULL;
FARPROC    RtlInitUnicodeStringNt = NULL;

PTCHAR     NTDLL = L"\\ntdll.dll";

extern     PGPC_NOTIFY_REQUEST_RES     GpcResCb;

DWORD
OpenDriver(
    OUT HANDLE  *pHandle,
    IN  LPCWSTR DriverName
    )
/*++

Routine Description:

    This function opens a specified drivers control channel.

Arguments:

    pHandle -  the handle to the opened driver

    DriverName - name of the driver to be opened.

Return Value:

    Windows Error Code.

--*/
{
    NTSTATUS            Status = NO_ERROR;
    IO_STATUS_BLOCK     ioStatusBlock;
    OBJECT_ATTRIBUTES   objectAttributes;
    UNICODE_STRING      nameString;

    (*RtlInitUnicodeStringNt)(&nameString,DriverName);

    InitializeObjectAttributes( &objectAttributes,
                                &nameString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL);
    //
    // Open a Handle to the driver.
    //

    Status = (NTSTATUS)(*CreateFileNt)( pHandle,
                              SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                              &objectAttributes,
                              &ioStatusBlock,
                              NULL,
                              FILE_ATTRIBUTE_NORMAL,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              FILE_OPEN_IF,
                              0,
                              NULL,
                              0);

    if (Status == STATUS_SUCCESS) {

        //
        // send an IOCTL for driver notifications
        //

        // IOCTL is done when the first client registers
        // with TC. This is done in another thread so that
        // it can be cancelled when there are no clients
//        IoRequestNotify(/*pGpcClient*/);

    }

    return (Status == STATUS_SUCCESS ? 0 : ERROR_OPEN_FAILED);

}

DWORD
DeviceControl(
    IN  HANDLE                          FileHandle,
    IN  HANDLE                          EventHandle,
    IN  PIO_APC_ROUTINE         ApcRoutine,
    IN  PVOID                           ApcContext,
    OUT PIO_STATUS_BLOCK        pIoStatBlock,
    IN  ULONG                           Ioctl,
    IN  PVOID                           setBuffer,
    IN  ULONG                           setBufferSize,
    IN  PVOID                           OutBuffer,
    IN  ULONG                           OutBufferSize )
/*++

Routine Description:

    This routine issues a device control request to the GPC

Arguments:

    FileHandle    - Open handle to the GPC driver
    Ioctl         - The IOCTL to pass to the stack
    setBuffer     - Data buffer containing the information to be set
    setBufferSize - The size of the set data buffer.
    Outbuffer     - the returned buffer
    OutBufferSize - the size

Return Value:

    A winerror status value.

--*/
{
    NTSTATUS        NtStatus = NO_ERROR;
    DWORD                       Status;

    if (NTPlatform) {

        IF_DEBUG(IOCTLS) {
            WSPRINT(("==>DeviceIoControl: Ioctl= %x\n", Ioctl ));
        }

        NtStatus = NtDeviceIoControlFile( FileHandle,
                                          EventHandle,          // Event
                                          ApcRoutine,           // when completed
                                          ApcContext,           // for ApcRoutine
                                          pIoStatBlock,         // for ApcRoutine
                                          Ioctl,            // Control code
                                          setBuffer,        // Input buffer
                                          setBufferSize,    // Input buffer size
                                          OutBuffer,        // Output buffer
                                          OutBufferSize );  // Output buffer size

        if (ApcRoutine && NT_SUCCESS(NtStatus)) {

            Status = ERROR_SIGNAL_PENDING;
            
            IF_DEBUG(IOCTLS) {
                WSPRINT(("DeviceIoControl: ApcRoutine defined Status=0x%X\n", 
                         Status ));
            }
            
        } else {

          Status = MapNtStatus2WinError(NtStatus);
          
          IF_DEBUG(IOCTLS) {
              WSPRINT(("DeviceIoControl: NtStatus=0x%X, Status=0x%X\n", 
                       NtStatus, Status ));
          }

#if DBG
          if (EventHandle) {
              IF_DEBUG(IOCTLS) {
                  WSPRINT(("DeviceIoControl: Event defined\n"));
              }
          }
#endif          
        }


    } else {

        // yoramb - not supporting other OSs for now.

        WSPRINT(("DeviceControl: Only Windows NT supported at this time!\n"));

        Status = ERROR_NOT_SUPPORTED;

    }

    IF_DEBUG(IOCTLS) {
        WSPRINT(("<==DeviceIoControl: Returned=0x%X\n", 
                 Status ));
    }

    return( Status );
}



DWORD
InitializeOsSpecific(VOID)

/*++

Routine Description:

    

Arguments:

    status - status to convert:

Return Value:

    status

--*/

{
    DWORD           Status;
    OSVERSIONINFO   VersionInfo;

    //
    // determine the type of system we are running on
    //

    Status = NO_ERROR;
    NTPlatform = TRUE;

    VersionInfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );

    if (GetVersionEx( &VersionInfo )) {
        if (VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
            NTPlatform = TRUE;
        }

    } else {

        WSPRINT(("Could not get version\n"));
    }


    if (!NTPlatform) {

        //
        // Initially, only NT compatibility is required.
        //

        return(ERROR_SERVICE_DOES_NOT_EXIST);

    } else {

        HINSTANCE  NtDll;
        WCHAR      wszNtDllPath[MAX_PATH];
        DWORD      dwPos = 0;
        
        //
        // get the function ptrs to NT specific routines that we need
        //

        //
        // Obtain the path to the system directory.
        //
        dwPos = (DWORD) GetSystemDirectoryW(wszNtDllPath, MAX_PATH);

        if ((dwPos <= 0) || (dwPos >= (MAX_PATH - wcslen(NTDLL) -1)))
        {
            //
            // Either error or not enough room to write the path to ntdll.dll
            //
            WSPRINT(("InitializeOsSpecific: Failed to load ntdll.dll\n"));
            return(FALSE);
        }

        //
        // Concatenate the word "\NTDLL.DLL"
        //
        wcsncat(&wszNtDllPath[dwPos], NTDLL, wcslen(NTDLL));

        //
        // Terminate the string
        //
        wszNtDllPath[dwPos + wcslen(NTDLL)] = '\0';
        
        //
        // Finally, load the library.
        //
        NtDll = LoadLibraryExW(wszNtDllPath, NULL, 0);

        if (NtDll == NULL) {
            WSPRINT(("InitializeOsSpecific: Failed to load ntdll.dll\n"));
            return(FALSE);
        }

        CreateFileNt = GetProcAddress(NtDll,"NtCreateFile" );

        CloseNt = GetProcAddress( NtDll,"NtClose" );

        RtlInitUnicodeStringNt = GetProcAddress( NtDll,"RtlInitUnicodeString" );

        NtStatusToDosError = GetProcAddress( NtDll,"RtlNtStatusToDosError" );

        if ( (CreateFileNt == NULL)           ||
             (CloseNt == NULL)                ||
             (RtlInitUnicodeStringNt == NULL) ||
             (NtStatusToDosError == NULL) ) {

            Status = ERROR_PATH_NOT_FOUND;

        } else {

            //
            // open a handle to the GPC
            //

            Status = OpenDriver( &pGlobals->GpcFileHandle, 
                                 (LPWSTR)DD_GPC_DEVICE_NAME);

            if (Status != NO_ERROR){

                WSPRINT(("\tThis version of traffic.dll requires kernel traffic control components.\n"));
                WSPRINT(("\tIt is unable to find these components.\n"));
                WSPRINT(("\tDilithium crystals may be used in their place...\n"));
            }

        }
    }

    return( Status );
}




VOID
DeInitializeOsSpecific(VOID)

/*++

Routine Description:

    This procedure closes the file handle passed in, in a platform dependent manner.

Arguments:

    Handle - the handle to close

Return Value:

    status

--*/

{

    //
    // only on NT do we close the handle, since on Win95, 
    // we don't actually open a file for Tcp, so there
    // is no handle in that case
    //

    IF_DEBUG(SHUTDOWN) {
        WSPRINT(( "DeInitializeOsSpecific: closing the GPC file handle\n" ));
    }
    
    if (NTPlatform && pGlobals->GpcFileHandle) 
    {
        (*CloseNt)( pGlobals->GpcFileHandle );
    }

    IF_DEBUG(SHUTDOWN) {
        WSPRINT(( "<==DeInitializeOsSpecific: exit...\n" ));
    }

}


DWORD
MapNtStatus2WinError(
    NTSTATUS       NtStatus
    )

/*++

Routine Description:

    This procedure maps the ntstatus return codes Winerrors.

Arguments:

    status - status to convert:

Return Value:

    status

--*/

{
    DWORD   stat;

    switch (NtStatus) {

    case    STATUS_SUCCESS:
        stat = NO_ERROR;
        break;

    case    STATUS_INSUFFICIENT_RESOURCES:
        stat = ERROR_NO_SYSTEM_RESOURCES;
        break;

    case    STATUS_BUFFER_OVERFLOW:
        stat = ERROR_MORE_DATA;
        break;

    case    STATUS_INVALID_PARAMETER:
        stat = ERROR_INVALID_PARAMETER;
        break;

    case    STATUS_TRANSACTION_TIMED_OUT:
        stat = ERROR_TIMEOUT;
        break;

    case    STATUS_REQUEST_NOT_ACCEPTED:
        stat = ERROR_NETWORK_BUSY;
        break;

    case    STATUS_NOT_SUPPORTED:
    case        STATUS_UNSUCCESSFUL:
        stat = ERROR_NOT_SUPPORTED;
        break;

    case        STATUS_BUFFER_TOO_SMALL:
        stat = ERROR_INSUFFICIENT_BUFFER;
        break;

    case    STATUS_PENDING:
        stat = ERROR_SIGNAL_PENDING;
        break;

    case    STATUS_OBJECT_NAME_NOT_FOUND:
        stat = ERROR_PATH_NOT_FOUND;
        break;

    case        STATUS_DEVICE_NOT_READY:
      stat = ERROR_NOT_READY;
      break;

    case        STATUS_NOT_FOUND:
      stat = ERROR_NOT_FOUND;
      break;

    case        STATUS_DUPLICATE_NAME:
      stat = ERROR_DUPLICATE_FILTER;
      break;

    case        STATUS_INVALID_HANDLE:
      stat = ERROR_INVALID_HANDLE;
      break;

    case        STATUS_DIRECTORY_NOT_EMPTY:
      stat = ERROR_TC_SUPPORTED_OBJECTS_EXIST;
      break;

    case        STATUS_TOO_MANY_OPENED_FILES:
      stat = ERROR_TOO_MANY_OPEN_FILES;
      break;

    case        STATUS_NOT_IMPLEMENTED:
      stat = ERROR_CALL_NOT_IMPLEMENTED;
      break;

    case        STATUS_DATA_ERROR:
        stat = ERROR_INVALID_DATA;
        break;

    case NDIS_STATUS_INCOMPATABLE_QOS:
        stat = ERROR_INCOMPATABLE_QOS;
        break;

    case QOS_STATUS_INVALID_SERVICE_TYPE:
        stat = ERROR_INVALID_SERVICE_TYPE;
        break;

    case QOS_STATUS_INVALID_TOKEN_RATE:
        stat = ERROR_INVALID_TOKEN_RATE;
        break;

    case QOS_STATUS_INVALID_PEAK_RATE:
        stat = ERROR_INVALID_PEAK_RATE;
        break;

    case QOS_STATUS_INVALID_SD_MODE:
        stat = ERROR_INVALID_SD_MODE;
        break;

    case QOS_STATUS_INVALID_QOS_PRIORITY:
        stat = ERROR_INVALID_QOS_PRIORITY;
        break;

    case QOS_STATUS_INVALID_TRAFFIC_CLASS:
        stat = ERROR_INVALID_TRAFFIC_CLASS;
        break;

    case QOS_STATUS_TC_OBJECT_LENGTH_INVALID:
        stat = ERROR_TC_OBJECT_LENGTH_INVALID;
        break;

    case QOS_STATUS_INVALID_FLOW_MODE:
        stat = ERROR_INVALID_FLOW_MODE;
        break;

    case QOS_STATUS_INVALID_DIFFSERV_FLOW:
        stat = ERROR_INVALID_DIFFSERV_FLOW;
        break;

    case QOS_STATUS_DS_MAPPING_EXISTS:
        stat = ERROR_DS_MAPPING_EXISTS;
        break;

    case QOS_STATUS_INVALID_SHAPE_RATE:
        stat = ERROR_INVALID_SHAPE_RATE;
        break;

    case STATUS_NETWORK_UNREACHABLE:
        stat = ERROR_NETWORK_UNREACHABLE;
        break;

    case QOS_STATUS_INVALID_DS_CLASS:
        stat = ERROR_INVALID_DS_CLASS;
        break;

    case ERROR_TOO_MANY_OPEN_FILES:
    	stat = ERROR_TOO_MANY_CLIENTS;
    	break;

    default:
        stat = ERROR_GEN_FAILURE;

    }

    return stat;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\tc\dll\refcnt.h ===
/*++        

Copyright (c) 1996  Microsoft Corporation

Module Name:

    refcnt.h

Abstract:


Author:

    Shreedhar Madhavapeddi (ShreeM)    18-October-1998

Revision History:

--*/

#ifndef REFCNT_H
#define REFCNT_H

//
// Reference Count Control Block
//
//  Elements:
//
//  - Count:            number of outstanding references
//  - Instance:      user supplied context 
//  - UserDeleteFunc:   user supplied delete function
//

#define TAG_CNT 12
#define REF_SIG 0x7841eeee

typedef struct
{
    ULONG   Tag;
    LONG    Count;
} REF_TAG;    

typedef struct  reference_count_control
{
    LONG       	        Count;
    PVOID               Instance;
    VOID                (*DeleteHandler)( PVOID );
#if DBG    
    int                 Sig;
    REF_TAG             Tags[TAG_CNT];
    CRITICAL_SECTION    Lock;
#endif     
}
REF_CNT, *PREF_CNT;


VOID    
ReferenceInit 
( 
    IN PREF_CNT pRefCnt, 
    PVOID       InstanceHandle, 
    VOID        (*DeleteHandler)( PVOID ) 
);

VOID
ReferenceAdd
(
    IN 	PREF_CNT  pRefCnt
);

VOID
ReferenceAddCount
(
    IN 	PREF_CNT    pRefCnt,
	IN	UINT	    Count
);

PVOID
ReferenceRemove 
(
    IN PREF_CNT  pRefCnt
);

VOID
ReferenceApiTest
( 
	VOID 
);

#if DBG

VOID ReferenceAddDbg(PREF_CNT pRefCnt, ULONG Tag);
VOID ReferenceRemoveDbg(PREF_CNT pRefCnt, ULONG Tag);

#define REFADD(Rc, Tag)     ReferenceAddDbg(Rc, Tag)
#define REFDEL(Rc, Tag)     ReferenceRemoveDbg(Rc, Tag)

#else

#define REFADD(Rc, Tag)  ReferenceAdd(Rc);
#define REFDEL(Rc, Tag)  ReferenceRemove(Rc);

#endif

#define RefInitLock( _s1 )    InitializeCriticalSection( &(_s1)) 

#define RefDeleteLock( _s1 )  DeleteCriticalSection( &(_s1))

#define RefGetLock( _s1 )     EnterCriticalSection( &(_s1)) 

#define RefFreeLock(_s1)  LeaveCriticalSection( &(_s1)) 


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\tc\dll\refcnt.c ===
/*++                                                                       

Copyright (c) 1996  Microsoft Corporation

Module Name:

    refcnt.c

Abstract:

    This module exports Reference Counting support functions. By 
    including a Reference Count Control Block (REF_CNT) in a
    dynamic type, and using this API, a Reference scheme can be
    implemented for that type.

Author:

    Shreedhar Madhavapeddi (ShreeM)    15-March-1999

Revision History:

--*/

//
// Include Files
//

#include "precomp.h"

#define EXPAND_TAG(t)   ((CHAR *)(&Tag))[0],((CHAR *)(&Tag))[1],((CHAR *)(&Tag))[2],((CHAR *)(&Tag))[3]
VOID
ReferenceInit 
(
    IN PREF_CNT pRefCnt,
    PVOID       InstanceHandle,
    VOID        (*DeleteHandler)( PVOID )
)

/*++

Routine Description:

    ReferenceInit initializes and adds one reference to the
    supplied Reference Control Block. If provided, an instance
    handle and delete handler are saved for use by the ReferenceRemove 
    function when all references to the instance are removed.

Arguments:

    pRefCnt - pointer to uninitialized Reference Control Block
    InstanceHandle - handle to the managed instance.
    DeleteHandler - pointer to delete function, NULL is OK.

Return Value:

    The function's value is VOID.

--*/

{
    IF_DEBUG(REFCOUNTX) { 
        WSPRINT(( "ReferenceInit( 0x%x, 0x%x, 0x%x )\n", 
                  pRefCnt, InstanceHandle, DeleteHandler ));
    }

    ASSERT( pRefCnt );

    // Set the reference to 1 and save the instance 
    // handle and the delete handler.

    pRefCnt->Count         = 0;
    pRefCnt->Instance      = InstanceHandle;
    pRefCnt->DeleteHandler = DeleteHandler;
    
#if DBG
    pRefCnt->Sig = REF_SIG;
    RtlZeroMemory(pRefCnt->Tags, sizeof(REF_TAG) * TAG_CNT);
    pRefCnt->Tags[0].Tag = 'LTOT';
    RefInitLock(pRefCnt->Lock);
#endif
        
}

VOID
ReferenceAdd
( 
    IN  PREF_CNT pRefCnt
)

/*++

Routine Description:


Arguments:


Return Value:


--*/

{

    ASSERT( pRefCnt );

    InterlockedIncrement(&pRefCnt->Count);
    IF_DEBUG(REFCOUNTX) { 
        WSPRINT(( "R+%d\n", pRefCnt->Count ));   
    }
}

VOID
ReferenceAddCount
(
    IN  PREF_CNT    pRefCnt,
    IN  UINT        Count
)

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    
    ASSERT( pRefCnt->Count > 0 );
    InterlockedExchangeAdd(&pRefCnt->Count, Count);

}

PVOID
ReferenceRemove 
(
    IN PREF_CNT  pRefCnt
)

/*++

Routine Description:
Arguments:
Return Value:


--*/

{
UINT    Count;
UINT    NoReference;
UINT    i;
PVOID   pInstance;

    ASSERT( pRefCnt );

    // Trap remove reference on a zero count
    ASSERT(pRefCnt->Count>0);

    pInstance = pRefCnt->Instance;
    
    //ASSERT( pRefCnt->Count > 0 );

    // If the decremented count is non zero return the instance handle

    if (InterlockedDecrement(&pRefCnt->Count) > 0 ) 
    {
        
        IF_DEBUG(REFCOUNTX) {
            
            WSPRINT(( "R-%d\n", pRefCnt->Count ));        
            WSPRINT(( "ReferenceRemove:remaining: %d\n", pRefCnt->Count ));

        }
#if DBG

        RefFreeLock(pRefCnt->Lock);            

#endif 

        return(pInstance);
    
    }

    // Delete this instance if a delete handler is available
    if( pRefCnt->DeleteHandler )
    {
        

#if DBG
        // sanity check
        for (i = 1; i < TAG_CNT; i++)
        {
            if ((pRefCnt->Tags[i].Tag != 0) && (pRefCnt->Tags[i].Count != 0))
            {
                IF_DEBUG(ERRORS) {
                    WSPRINT(("Allors!! There is a NON-zero ref and we are deleting...\n"));
                }
                DEBUGBREAK();
            }
        }
        


        IF_DEBUG(REFCOUNTX) { 
            WSPRINT(( "Executing DeleteHandler for %X\n", pRefCnt->Instance ));
        }

        //
        // All the Dereference* code takes the locks, so lets take it here.
        // Also, Take the global lock before releasing the ref lock.
        //

        // Time to delete the ref lock too.
        RefFreeLock(pRefCnt->Lock);            
#endif 

        GetLock(pGlobals->Lock);

#if DBG
        RefDeleteLock(pRefCnt->Lock);
#endif 


        (pRefCnt->DeleteHandler)( pRefCnt->Instance );
        FreeLock(pGlobals->Lock);
    
    }

    // Indicate no active references to this instance

    return( NULL );
}

//
// API Test Support
//

#if DBG

VOID
ReferenceApiTest( VOID )
{
REF_CNT  RefCnt;

    IF_DEBUG(REFCOUNTX) {
        WSPRINT(
        ( "\nReferenceApiTest\n" ));

        WSPRINT(( "\nTest #1: NULL delete handler\n" ));
    }

    ReferenceInit( &RefCnt, &RefCnt, NULL );

    ReferenceAdd( &RefCnt );
    ReferenceAdd( &RefCnt );
    ReferenceAdd( &RefCnt );

    while( ReferenceRemove( &RefCnt ) )
    {
        ;
    }

    IF_DEBUG(REFCOUNTX) {
        WSPRINT(( "\nTest #2: Delete Handler - TBD\n" ));
    }
}

VOID
ReferenceAddDbg(PREF_CNT pRefCnt, ULONG Tag)
{
    int             i;
    int             TotalPerArray = 0;
    
    RefGetLock(pRefCnt->Lock);
    //ASSERT(pRefCnt->Sig == REF_SIG);
    if (pRefCnt->Sig != REF_SIG) {
        DEBUGBREAK();
    }
    
    IF_DEBUG(REFCOUNTX) {
        WSPRINT(("TCREF: add %X (%c%c%c%c) %d\n",
                  pRefCnt, EXPAND_TAG(Tag), pRefCnt->Count));    
    }
    
    for (i = 1; i < TAG_CNT; i++)
    {
        if (pRefCnt->Tags[i].Tag == 0 || pRefCnt->Tags[i].Tag == Tag)
        {
            pRefCnt->Tags[i].Tag = Tag;
            InterlockedIncrement(&pRefCnt->Tags[i].Count);
            break;
        }
    }
    
    
    //ASSERT(i < TAG_CNT);
    if (i >= TAG_CNT) {
        
        DEBUGBREAK();

    }

    ReferenceAdd(pRefCnt);           
    
    InterlockedIncrement(&pRefCnt->Tags[0].Count);
 
    // sanity check
    
    for (i = 1; i < TAG_CNT; i++)
    {
        if (pRefCnt->Tags[i].Tag != 0)
        {
            TotalPerArray += pRefCnt->Tags[i].Count;
            continue;
        }
    }

    ASSERT(TotalPerArray == pRefCnt->Tags[0].Count);
    
    if (TotalPerArray != pRefCnt->Tags[0].Count)
    {
        DbgBreakPoint();
    }        
    

    
    RefFreeLock(pRefCnt->Lock);
}

VOID
ReferenceRemoveDbg(PREF_CNT pRefCnt, ULONG Tag)
{
    int             i;
    int             TotalPerArray = 0;
    BOOLEAN         FoundIt = FALSE;
    
    RefGetLock(pRefCnt->Lock);

    if (pRefCnt->Sig != REF_SIG) {
        DEBUGBREAK();
    }

    //ASSERT(pRefCnt->Sig == REF_SIG);

    IF_DEBUG(REFCOUNTX) { 
        WSPRINT(("TCREF: remove %X (%c%c%c%c) %d\n",
                 pRefCnt, EXPAND_TAG(Tag), pRefCnt->Count));
    }
             
    for (i = 1; i < TAG_CNT; i++)
    {
        if (pRefCnt->Tags[i].Tag == Tag)
        {
            FoundIt = TRUE;
            
            if(pRefCnt->Tags[i].Count <= 0) {
                
                DEBUGBREAK();

            }
            //ASSERT(pRefCnt->Tags[i].Count > 0);
            InterlockedDecrement(&pRefCnt->Tags[i].Count);
            if (pRefCnt->Tags[i].Count == 0)
                pRefCnt->Tags[i].Tag = Tag; 
            break;
        }
    }

    if (!FoundIt) {
        DEBUGBREAK();
    }
    
    ASSERT(FoundIt);
  
    ASSERT(pRefCnt->Tags[0].Count > 0);
      
    InterlockedDecrement(&pRefCnt->Tags[0].Count);

    // sanity check
    for (i = 1; i < TAG_CNT; i++)
    {
        if (pRefCnt->Tags[i].Tag != 0)
        {
            TotalPerArray += pRefCnt->Tags[i].Count;
            continue;
        }
    }
    
    ASSERT(TotalPerArray == pRefCnt->Tags[0].Count);
    
    if (TotalPerArray != pRefCnt->Tags[0].Count)
    {
        DbgPrint("Tag %X, RefCnt %X, perArray %d, total %d\n", Tag, pRefCnt,
                  TotalPerArray, pRefCnt->Tags[0].Count);
                  
        DbgBreakPoint();
    }    
    

    
    ReferenceRemove(pRefCnt);        
    

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\tc\dll\oscode.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    oscode.h

Abstract:

    This module contains the header definitions for NT support routines 
    for talking to the kernel on NT systems.

Author:

    Jim Stewart (jstew)    August 14, 1996

Revision History:

	Ofer Bar ( oferbar )     Oct 1, 1996 - Revision II changes

--*/

#ifndef __OSCODE_H
#define __OSCODE_H

DWORD
MapNtStatus2WinError(
    NTSTATUS       NtStatus
    );


DWORD
OpenDriver(
    OUT HANDLE  *Handle,
    IN  LPCWSTR DriverName
    );

DWORD
DeviceControl(
    IN  HANDLE  			FileHandle,
    IN  HANDLE				EventHandle,
    IN  PIO_APC_ROUTINE		ApcRoutine,
    IN	PVOID				ApcContext,
    OUT	PIO_STATUS_BLOCK 	pIoStatusBlock,
    IN  ULONG   			Ioctl,
    IN  PVOID   			setBuffer,
    IN  ULONG   			setBufferSize,
    IN  PVOID   			OutBuffer,
    IN  ULONG   			OutBufferSize
    );

DWORD
InitializeOsSpecific(VOID);

VOID
DeInitializeOsSpecific(VOID);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\tc\dll\tcfwd.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    tcfwd.h

Abstract:

    This module contains the forward function definitions for all the functions in
    the traffic control dll.

Author:

    Jim Stewart (jstew)    August 14, 1996

Revision History:

	Ofer Bar (oferbar)     Oct 1, 1997 - Revision II

--*/

#ifndef __TCFWD_H
#define __TCFWD_H

//
// tckrnl.c
//



DWORD
IoModifyFlow(
    IN  PFLOW_STRUC	pFlow,
    IN  BOOLEAN		Async
    );

DWORD
IoAddFlow(
    IN  PFLOW_STRUC	pFlow,
    IN  BOOLEAN		Async
    );

DWORD
IoAddClassMapFlow(
    IN  PFLOW_STRUC	pFlow,
    IN  BOOLEAN		Async
    );

DWORD
IoDeleteFlow(
    IN  PFLOW_STRUC	pFlow,
    IN  BOOLEAN		Async
    );

DWORD
IoAddFilter(
    IN  PFILTER_STRUC	pFilter
    );

DWORD
IoDeleteFilter(
    IN  PFILTER_STRUC	pFilter
    );

DWORD
IoRegisterClient(
    IN  PGPC_CLIENT	pGpcClient
    );

DWORD
IoDeregisterClient(
    IN  PGPC_CLIENT	pGpcClient
    );

DWORD
IoEnumerateFlows(
	IN		PGPC_CLIENT				pGpcClient,
    IN OUT	PHANDLE					pEnumHandle,
    IN OUT	PULONG					pFlowCount,
    IN OUT	PULONG					pBufSize,
    OUT		PGPC_ENUM_CFINFO_RES 	*ppBuffer
    );

DWORD
IoRequestNotify(
	VOID
    //IN  PGPC_CLIENT	pGpcClient
    );

VOID
CancelIoRequestNotify(
	VOID
    );

DWORD
StartGpcNotifyThread();

DWORD
StopGpcNotifyThread();

//
// tcutils.c
//

VOID
WsAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber
    );

VOID
WsPrintf (
    char *Format,
    ...
    );

VOID
SetupDebugInfo( void );

VOID
CloseDbgFile( void );



//
// handles.c
//

PVOID
GetHandleObjectWithRef(
	IN  HANDLE					h,
    IN  ENUM_OBJECT_TYPE	    ObjType,
    IN  ULONG                   RefType
    );

PVOID
GetHandleObject(
	IN  HANDLE				h,
    IN  ENUM_OBJECT_TYPE	ObjType
    );

HANDLE
AllocateHandle(
    IN  PVOID 	Context
    );

VOID
FreeHandle(
    IN HANDLE   Handle
    );

//
// apiutil.c
//

VOID
MarkAllNodesForClosing(
                      PINTERFACE_STRUC pInterface,
                      STATE stateToMark
                      );

PTC_IFC
GetTcIfc(
	IN LPWSTR	pInterfaceName
    );

PTC_IFC
GetTcIfcWithRef(
        IN LPWSTR       pInterfaceName,
        IN ULONG        RefType
    );

DWORD
UpdateTcIfcList(
	IN	LPWSTR					InstanceName,
    IN	ULONG					IndicationBufferSize,
    IN  PTC_INDICATION_BUFFER	IndicationBuffer,
    IN  DWORD					IndicationCode
    );

DWORD
CreateClientStruc(
	IN  HANDLE ClRegCtx,
    OUT PCLIENT_STRUC *ppClient
    );

DWORD
CreateClInterfaceStruc(
	IN  HANDLE 		   		ClIfcCtx,
    OUT PINTERFACE_STRUC 	*ppClIfc
    );

DWORD
CreateFlowStruc(
	IN  HANDLE 			ClFlowCtx,
    IN  PTC_GEN_FLOW	pGenFlow,
    OUT PFLOW_STRUC 	*ppFlow
    );

DWORD
CreateClassMapFlowStruc(
	IN  HANDLE 				ClFlowCtx,
    IN  PTC_CLASS_MAP_FLOW	pClassMapFlow,
    OUT PFLOW_STRUC 		*ppFlow
    );

DWORD
CreateFilterStruc(
	IN	PTC_GEN_FILTER	pGenericFilter,
    IN  PFLOW_STRUC		pFlow,
    IN	PFILTER_STRUC	*ppFiler
);

VOID
DeleteFlowStruc(
    IN PFLOW_STRUC  pFlow
    );

DWORD
EnumAllInterfaces(VOID);


DWORD
CloseInterface(
    IN  PINTERFACE_STRUC	pInterface,
    IN	BOOLEAN				RemoveFlows
    );

PGPC_CLIENT
FindGpcClient(
	IN  ULONG  	CfInfoType
    );

VOID
CloseOpenFlows(
    IN PINTERFACE_STRUC   pInterface
    );

DWORD
DeleteFlow(
    IN PFLOW_STRUC  	pFlow,
    IN BOOLEAN			RemoveFilters
    );

DWORD
DeleteFilter(
    IN PFILTER_STRUC  	pFilter
    );

VOID
DeleteFilterStruc(
    IN PFILTER_STRUC  pFilter
    );

VOID
CompleteAddFlow(
	IN	PFLOW_STRUC		pFlow,
    IN	DWORD			Status
    );

VOID
CompleteAddClassMapFlow(
	IN	PFLOW_STRUC		pFlow,
    IN	DWORD			Status
    );

VOID
CompleteModifyFlow(
	IN	PFLOW_STRUC		pFlow,
    IN	DWORD			Status
    );

VOID
CompleteDeleteFlow(
	IN	PFLOW_STRUC		pFlow,
    IN	DWORD			Status
    );

DWORD
OpenGpcClients(
    IN	ULONG	CfInfoType
    );

DWORD
DereferenceInterface(
	IN	PINTERFACE_STRUC	pInterface
    );

DWORD
DereferenceFlow(
	IN	PFLOW_STRUC	pFlow
    );

DWORD
DereferenceFilter(
	IN	PFILTER_STRUC	pFilter
    );

DWORD
DereferenceClient(
	IN	PCLIENT_STRUC	pClient
    );


DWORD
GetInterfaceIndex(
	IN  PADDRESS_LIST_DESCRIPTOR pAddressListDesc,
    OUT  PULONG pInterfaceIndex,
    OUT PULONG pSpecificLinkCtx
    );

DWORD
CreateKernelInterfaceStruc(
                           OUT PTC_IFC        *ppTcIfc,
                           IN  DWORD          AddresssLength
                           );

DWORD
DereferenceKernelInterface(
                           PTC_IFC        pTcIfc
                           );



//
// tcglob.c
//

DWORD
InitializeGlobalData();

VOID
DeInitializeGlobalData();


//
// callback.c
//

VOID
NTAPI CbAddFlowComplete(
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    );

VOID
NTAPI CbModifyFlowComplete(
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    );

VOID
NTAPI CbDeleteFlowComplete(
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    );

VOID
NTAPI CbGpcNotifyRoutine(
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    );

VOID
CbParamNotifyClient(
    IN	ULONG	Context,
    IN  LPGUID	pGuid,
	IN	LPWSTR	InstanceName,
    IN	ULONG	DataSize,
    IN	PVOID	DataBuffer
    );

VOID
CbInterfaceNotifyClient(
    IN	ULONG	Context,
    IN  LPGUID	pGuid,
	IN	LPWSTR	InstanceName,
    IN	ULONG	DataSize,
    IN	PVOID	DataBuffer
    );

//
// tcwmi.c
//

DWORD
InitializeWmi(VOID);

DWORD
DeInitializeWmi(VOID);

VOID
CbWmiParamNotification(
   IN  PWNODE_HEADER WnodeHeader,
   IN  ULONG Index
   );

VOID
CbWmiInterfaceNotification(
   IN  PWNODE_HEADER WnodeHeader,
   IN  ULONG Index
   );

DWORD
WalkWnode(
   IN  PWNODE_HEADER 			pWnodeHdr,
   IN  ULONG 					Context,
   IN  CB_PER_INSTANCE_ROUTINE	CbPerInstance
   );

//
// tcutils.c
//

ULONG
LockedDec(
    IN  PULONG  Count
    );


//
// tcnotify.c
//
ULONG
TcipAddToNotificationList(
                          IN LPGUID             Guid,
                          IN PINTERFACE_STRUC   IfcHandle,
                          IN ULONG              Flags        
                          );

ULONG
TcipDeleteFromNotificationList(
                             IN LPGUID              Guid,
                             IN PINTERFACE_STRUC    IfcHandle,
                             IN ULONG               Flags        
                             );

ULONG
TcipClientRegisteredForNotification(
                            IN LPGUID               Guid,
                            IN PINTERFACE_STRUC     IfcHandle,
                            IN ULONG                Flags        
                            );

ULONG
TcipDeleteInterfaceFromNotificationList(
                               IN PINTERFACE_STRUC    IfcHandle,
                               IN ULONG               Flags        
                               );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\tc\dll\precomp.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This is the main include file for traffic.dll

Author:

    Jim Stewart (jstew)    August 14, 1996

Revision History:

	Ofer Bar ( oferbar )     Oct 1, 1996 - Revision II changes

--*/

#ifndef __TRAFF_PRECOMP
#define __TRAFF_PRECOMP

#define UNICODE

#include<nt.h>
#include<ntrtl.h>
#include<nturtl.h>

#include<tdi.h>
#include<tdiinfo.h>
#include<ntddtcp.h>
#include<ntddip.h>
#include<stdlib.h>
#include<string.h>
#include<ctype.h>
#include<stdarg.h>
#include<tchar.h>
#include<windows.h>

#include<winsock2.h>
#include<iprtrmib.h>
#include<ipinfo.h>
#include<iphlpstk.h>

#include <tcerror.h>
#include <wmium.h>
#include <ntddndis.h>

//
// traffic control include files
//
//#include"tcifx.h"

#include"refcnt.h"
#include"traffic.h"
#include"tcmacro.h"
#include"handfact.h"
#include"gpcifc.h"
#include"gpcstruc.h"
#include"ntddtc.h"
#include"tctypes.h"
#include"tcfwd.h"
#include"dbgmem.h"
#include"oscode.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\tc\dll\tcnotify.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    tcnotify.c

Abstract:

    This module contains the notification interaction with WMI

Author:

    Shreedhar Madhavapeddi ( shreem )   Jan 12, 1999.

Revision History:

--*/

#include "precomp.h"


int 
IsEqualGUIDx(
                LPGUID guid1, 
                LPGUID guid2
                )
{
    return !memcmp(guid1, guid2, sizeof(GUID));
}

//
// Add the guid/ifchandle to the NotificationList.
// Although it shouldn't happen - check for dupes before adding it.
// Interface handle leads to Client handle 
// 
ULONG
TcipAddToNotificationList(
                          IN LPGUID             Guid,
                          IN PINTERFACE_STRUC   IfcHandle,
                          IN ULONG              Flags        
                          )
{
    PLIST_ENTRY             pCurrent;
    PNOTIFICATION_ELEMENT   pNotifyElem, pNewElem;
    int i = 0;
    //
    // Take the List Lock.
    // 
    pNotifyElem = NULL;
    GetLock(NotificationListLock);
    pCurrent = NotificationListHead.Flink;

    while (&NotificationListHead != pCurrent) {
        
        pNotifyElem = CONTAINING_RECORD(pCurrent, NOTIFICATION_ELEMENT, Linkage.Flink);
        
        if ((pNotifyElem->IfcHandle != IfcHandle) || 
            (FALSE == IsEqualGUIDx(&pNotifyElem->NotificationGuid, Guid))) {
            
            pCurrent = pNotifyElem->Linkage.Flink;

        } else {
            
            //
            // We found a guid/ifchandle combo already!
            
            //DEBUGBREAK();
            goto exit;

        }

        
    }

    //
    // If we are here, we couldnt find the GUID/IfcHAndle combo
    // Allocate a new element and add it to the list, return TRUE;
    //
    
    AllocMem(&pNewElem, sizeof(NOTIFICATION_ELEMENT));
    if (!pNewElem) {
        
        // cant alloc memory;
        goto exit;

    }
    pNewElem->IfcHandle = IfcHandle;
    pNewElem->NotificationGuid      = *Guid;

    InsertHeadList(&NotificationListHead, &pNewElem->Linkage);
    FreeLock(NotificationListLock);
    return TRUE;

exit:

    FreeLock(NotificationListLock);
    return FALSE;
}

//
// Remove the guid/ifchandle from the NotificationListHead.
// If DBG - check for more than one entries.
// 
ULONG
TcipDeleteFromNotificationList(
                             IN LPGUID              Guid,
                             IN PINTERFACE_STRUC    IfcHandle,
                             IN ULONG               Flags        
                             )
{

    PLIST_ENTRY             pCurrent;
    PNOTIFICATION_ELEMENT   pNotifyElem;


    pNotifyElem = NULL;

    GetLock(NotificationListLock);
    pCurrent = NotificationListHead.Flink;

    while (&NotificationListHead != pCurrent) {

        pNotifyElem = CONTAINING_RECORD(pCurrent, NOTIFICATION_ELEMENT, Linkage.Flink);
        
        if ((pNotifyElem->IfcHandle == IfcHandle) && 
            (TRUE == IsEqualGUIDx(&pNotifyElem->NotificationGuid, Guid))) {
            
            //
            // We found the guid/ifchandle combo - remove it.
            RemoveEntryList(&pNotifyElem->Linkage);
            FreeMem(pNotifyElem);
            break;



        } else {

            pCurrent = pNotifyElem->Linkage.Flink;            

        }

    }

    FreeLock(NotificationListLock);
    return TRUE;

}

// Take a Interface & GUID that has a notification from WMI, and
// find if this Client registered to be notified.
ULONG
TcipClientRegisteredForNotification(
                            IN LPGUID               Guid,
                            IN PINTERFACE_STRUC     IfcHandle,
                            IN ULONG                Flags        
                            )
{
    PLIST_ENTRY             pCurrent;
    PNOTIFICATION_ELEMENT   pNotifyElem;

    pNotifyElem = NULL;

    // make sure the list doesn't change under us.
    GetLock(NotificationListLock);
    pCurrent = NotificationListHead.Flink;

    while (&NotificationListHead != pCurrent) {
        
        pNotifyElem = CONTAINING_RECORD(pCurrent, NOTIFICATION_ELEMENT, Linkage.Flink);
        
        if ((pNotifyElem->IfcHandle == IfcHandle) && 
            (IsEqualGUIDx(&pNotifyElem->NotificationGuid, Guid))) {

            FreeLock(NotificationListLock);
            return TRUE;
        }

        pCurrent = pNotifyElem->Linkage.Flink;
    
    }

    FreeLock(NotificationListLock);

    return FALSE;

}

//
// Remove the guid/ifchandle from the NotificationListHead.
// 
ULONG
TcipDeleteInterfaceFromNotificationList(
                                        IN PINTERFACE_STRUC    IfcHandle,
                                        IN ULONG               Flags        
                                        )
{

    PLIST_ENTRY             pCurrent;
    PNOTIFICATION_ELEMENT   pNotifyElem;

    pNotifyElem = NULL;
    ASSERT(IfcHandle);
    
    GetLock(NotificationListLock);
    pCurrent = NotificationListHead.Flink;

    while (&NotificationListHead != pCurrent) {

        pNotifyElem = CONTAINING_RECORD(pCurrent, NOTIFICATION_ELEMENT, Linkage.Flink);
        
        if (pNotifyElem->IfcHandle == IfcHandle) {
            
            pCurrent = pNotifyElem->Linkage.Flink;            
            
            //
            // We found the guid/ifchandle combo - remove it.
            RemoveEntryList(&pNotifyElem->Linkage);
            FreeMem(pNotifyElem);

        } else {

            pCurrent = pNotifyElem->Linkage.Flink;            

        }

    }


    FreeLock(NotificationListLock);
    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\tc\dll\tcmacro.h ===
/*++
Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    rsvp.h

Abstract:

    This code contains the macros definitions for rsvp.sys

Author:

    Jim Stewart (JStew) June 12, 1996

Environment:

    Kernel mode

Revision History:

--*/

#ifndef __TCMACRO_H
#define __TCMACRO_H

#if DBG


#define WSPRINT( stuff )     WsPrintf stuff
#define SETUP_DEBUG_INFO     SetupDebugInfo
#define CLOSE_DEBUG          CloseDbgFile
#define DUMP_MEM_ALLOCATIONS DumpAllocatedMemory
#define INIT_DBG_MEMORY      InitDebugMemory
#define DEINIT_DBG_MEMORY    DeInitDebugMemory

#define IF_DEBUG( _ErrLevel ) if ( (DebugMask & DEBUG_ ## _ErrLevel ) != 0 )

#define TC_TRACE(_ErrLevel, String) if((DebugMask & DEBUG_ ## _ErrLevel) != 0) WsPrintf String

#define IF_DEBUG_CHECK(_status,_ErrLevel) if ( (_status != NO_ERROR) && ((DebugMask & DEBUG_ ## _ErrLevel) != 0) )

#define DEBUGBREAK DebugBreak

#undef ASSERT
/*++
VOID
Assert(
    IN Value
    )


Routine Description:

    Checks if the Value passed in is zero.  If its zero then assert.

Arguments:

    Value - the parameter to check against zero

Return Value:

    none

--*/
#define ASSERT( exp ) if ( !(exp) ) WsAssert( #exp, __FILE__,__LINE__ )

/*++
VOID
AllocMem(
    OUT PVOID   *Address,
    IN  ULONG   Length
    )


Routine Description:

    Allocates memory and then writes a tag and length into the first two Ulongs.  It
    then writes the same tag into the last Ulong.

Arguments:

    Address - the return address of the memory
    Length  - the length of the memory to allocate

Return Value:

    none

--*/
#define CAllocMem(_num,_size)           AllocMemory( _num*_size,TRUE, __FILE__, __LINE__ )
#define AllocMem(_Address,_cb)          *_Address = AllocMemory( _cb,FALSE,__FILE__, __LINE__ )
#define ReAllocMem(_pv, _cb)            ReAllocMemory(_pv,_cb,__FILE__,__LINE__ )
#if 0
#define AllocMem( _Address,_Length )                                                    \
{                                                                                       \
    PULONG  _Addr;                                                                      \
    ULONG   _Len;                                                                       \
    _Len = _Length + (sizeof(ULONG) << 2);                                              \
    _Addr = malloc( _Len );                                                             \
    IF_DEBUG(MEMORY_ALLOC) {                                                            \
        WSPRINT(( "AllocMemory %X, %d bytes %s %d\n",_Addr,_Length,__FILE__,__LINE__ ));\
    }                                                                                   \
                                                                                        \
    if (_Addr) {                                                                        \
        *(PULONG)_Addr++ = RSVP_TAG;                                                    \
        *(PULONG)_Addr++ = _Length;                                                     \
        *_Address = (PVOID)_Addr;                                                       \
        *(PULONG)((PUCHAR)_Addr + _Length) = RSVP_TAG;                                  \
    } else {                                                                            \
        *_Address = NULL;                                                               \
    }                                                                                   \
}
#endif

/*++
VOID
FreeMem(
    IN PVOID    Address
    )


Routine Description:

    Frees non-paged pool.  It checks if the tag value is still set at both the beginning
    and the end of the pool block and asserts if it's not.

Arguments:

    Address - the address of the memory

Return Value:

    none

--*/
#define FreeMem(_pv)                    FreeMemory( _pv,__FILE__,__LINE__ )
#if 0
#define FreeMem( _Address )                                                                    \
{                                                                                              \
    PULONG _Addr;                                                                              \
    _Addr = (PULONG)((PUCHAR)_Address - (sizeof(ULONG) << 1));                                 \
    if (( *_Addr++ != RSVP_TAG ) ||                                                            \
        (( *(PULONG)((PUCHAR)_Addr + *_Addr + sizeof(ULONG)) ) != RSVP_TAG)) {                 \
        WSPRINT(("Bogus Address passed in - Addr = %X\n",_Address ));                          \
        ASSERT( 0 );                                                                           \
    }                                                                                          \
    _Addr--;                                                                                   \
                                                                                               \
    IF_DEBUG(MEMORY_FREE) {                                                                    \
        WSPRINT(( "FreeMemory %X, %d bytes %s %d\n",_Address,*(_Addr + 1),__FILE__,__LINE__ ));\
    }                                                                                          \
    *(_Addr + 1) = 0;                                                                          \
    free( _Addr );                                                                             \
}
#endif

/*++
VOID
CheckMemoryOwner(
    IN PVOID    Address
    )


Routine Description:

    Check for a tag in the memory block to ensure we own the memory

Arguments:

    Address - the address of the memory

Return Value:

    none

--*/

#define CheckMemoryOwner( _Address )
#if 0
#define CheckMemoryOwner( _Address )                                      \
{                                                                         \
    if (( *(PULONG)((PUCHAR)_Address - sizeof( ULONG ))) != RSVP_TAG ) {  \
        WSPRINT(("Bogus Address passed in - Addr = %X\n",_Address ));     \
        ASSERT( 0 );                                                      \
    }                                                                     \
}
#endif


/*++
ULONG
LockedDecrement(
    IN PULONG   _Count
    )


Routine Description:

    Atomically decrement a counter and return an indication whether the count has gone to
    zero.  The value returned will be zero if the count is zero after the decrement. However if
    the count is either greater or less than zero then this routine will not return the current
    count value, but rather some number that has the same sign as the real count.

Arguments:

    _Count - the address of the memory to decrement

Return Value:

    none

--*/
#define LockedDecrement( _Count )  \
    LockedDec( _Count )

/*++
ULONG
LockedIncrement(
    IN PULONG   _Count
    )


Routine Description:

    Atomically increment a counter and return an indication whether the 
    count has gone to zero.  The value returned will be zero if the 
    count is zero after the increment. However if the count is either 
    greater or less than zero then this routine will not return the current
    count value, but rather some number that has the same sign 
    as the real count.

Arguments:

    _Count - the address of the memory to increment

Return Value:

    none

--*/
#define LockedIncrement( _Count )  ++(*_Count)


//
// this macro is used to vector exceptions to the debugger on a DBG build and to
// simply execute the exception handler on a free build
//
#define EXCEPTION_FILTER UnhandledExceptionFilter(GetExceptionInformation())

#define InitLock( _s1 )   {                                         \
    IF_DEBUG(LOCKS) WSPRINT(("INITLOCK %s [%d]\n", __FILE__,__LINE__)); \
    InitializeCriticalSection( &(_s1).Lock );                       \
    (_s1).LockAcquired = 0;                                        \
    strncpy((_s1).LastAcquireFile, strrchr(__FILE__, '\\')+1, 7);   \
    (_s1).LastAcquireLine = __LINE__;                               \
}

#define GetLock(_s1)                                                     \
{                                                                        \
      EnterCriticalSection( &(_s1).Lock);                                \
      IF_DEBUG(LOCKS) WSPRINT(("GETLOCK[%X] %s [%d]\n", &(_s1).Lock, __FILE__,__LINE__)); \
      (_s1).LockAcquired++;                                         \
      ASSERT((_s1).LockAcquired > 0);                               \
      (_s1).LastAcquireLine = __LINE__;                                  \
      strncpy((_s1).LastAcquireFile, strrchr(__FILE__,'\\')+1, 7);       \
}

#define SafeGetLock(_s1)                                                 \
    __try {                                                              \
      EnterCriticalSection( &(_s1).Lock);                                \
      IF_DEBUG(LOCKS) WSPRINT(("SGETLOCK %s [%d]\n", __FILE__,__LINE__));\
      (_s1).LockAcquired = TRUE;                                         \
      (_s1).LastAcquireLine = __LINE__;                                  \
      strncpy((_s1).LastAcquireFile, strrchr(__FILE__,'\\')+1, 7);       \
      
#define FreeLock(_s1)                                                    \
{                                                                        \
      IF_DEBUG(LOCKS) WSPRINT(("FREELOCK[%X] %s [%d]\n", &(_s1).Lock, __FILE__,__LINE__));\
      (_s1).LockAcquired--;                                        \
      ASSERT((_s1).LockAcquired >= 0);                               \
      (_s1).LastReleaseLine = __LINE__;                                  \
      strncpy((_s1).LastReleaseFile, strrchr(__FILE__,'\\')+1, 7);       \
      LeaveCriticalSection( &(_s1).Lock);                                \
}

#define SafeFreeLock(_s1)                                                         \
      } __finally {                                                               \
              IF_DEBUG(LOCKS) WSPRINT(("SFREELOCK %s [%d]\n", __FILE__,__LINE__));\
              (_s1).LockAcquired = FALSE;                                         \
              (_s1).LastReleaseLine = __LINE__;                                   \
              strncpy((_s1).LastReleaseFile, strrchr(__FILE__,'\\')+1, 7);        \
              LeaveCriticalSection( &(_s1).Lock);                                 \
}

#define DeleteLock( _s1 ) {                                                  \
    IF_DEBUG(LOCKS) WSPRINT(("DELLOCK[%X] %s [%d]\n", &(_s1).Lock, __FILE__,__LINE__));       \
    (_s1).LockAcquired--;                                                 \
    ASSERT((_s1).LockAcquired == -1);                                                 \
    strncpy((_s1).LastReleaseFile, strrchr(__FILE__, '\\')+1, 7);            \
    (_s1).LastReleaseLine = __LINE__;                                        \
    DeleteCriticalSection(&(_s1).Lock);                                      \
}


#define QUERY_STATE(_p)     (_p).State 

#define SET_STATE(_p, _state) {                                             \
    IF_DEBUG(STATES) {                                                      \
        DbgPrint("Setting Object to STATE [%s] (File:%s, Line%d)\n", TC_States[_state], __FILE__, __LINE__);       \
        }                                                                       \
   (_p).PreviousState = (_p).State;                                        \
   (_p).PreviousStateLine = (_p).CurrentStateLine;                         \
   (_p).CurrentStateLine = __LINE__;                                       \
   strncpy((_p).PreviousStateFile, (_p).CurrentStateFile, 7);              \
   strncpy((_p).CurrentStateFile, strrchr(__FILE__, '\\')+1, 7);           \
   (_p).State = _state;                                                    \
}

    
#else  // DBG

//
// These are the NON debug versions of the macros
//

#define IF_DEBUG( _ErrLevel ) if (FALSE)
#define IF_DEBUG_CHECK( _status,_ErrLevel ) if (FALSE)
#ifndef ASSERT
#define ASSERT(a)
#endif
#define WSPRINT(stuff)
#define TC_TRACE(_ErrLevel, stuff)
#define SETUP_DEBUG_INFO()
#define CLOSE_DEBUG()
#define DUMP_MEM_ALLOCATIONS()
#define INIT_DBG_MEMORY()
#define DEINIT_DBG_MEMORY()
#define DEBUGBREAK()

#define AllocMem( _Addr,_Len )  \
    *_Addr = malloc(_Len )

#define FreeMem( _Address )     \
    free( _Address )

#define CheckMemoryOwner( Address )

#define LockedDecrement( _Count )  \
    CTEInterlockedDecrementLong( _Count )

#define EXCEPTION_FILTER EXCEPTION_EXECUTE_HANDLER

#define InitLock( _s1 )    InitializeCriticalSection( &(_s1).Lock) 

#define DeleteLock( _s1 )  DeleteCriticalSection( &(_s1).Lock)

#define GetLock( _s1 )     EnterCriticalSection( &(_s1).Lock) 

#define SafeGetLock( _s1 ) __try { EnterCriticalSection( &(_s1).Lock);

#define FreeLock(_s1)  LeaveCriticalSection( &(_s1).Lock) 

#define SafeFreeLock( _s1 ) } __finally {LeaveCriticalSection( &(_s1).Lock);}

#define SET_STATE(_p, _state) { (_p).State = _state; }
#define QUERY_STATE(_p)     (_p).State
    

#endif // DBG

/*++
ULONG
IS_LENGTH(
    IN ULONG   _Length,
    )

Routine Description:

    This calculates the number of 32 bit words in a length and returns that.  It is used
    for Int Serv objects that require the size in 32 bit words.

Arguments:

    _Length - Length

Return Value:

    number of 32 bit words

--*/
#define IS_LENGTH( _Length )                                   \
    (_Length + 3)/sizeof(ULONG)


        //#define IS_INITIALIZED  (Initialized)

#define VERIFY_INITIALIZATION_STATUS	\
	if (InitializationStatus != NO_ERROR) return InitializationStatus

#define OffsetToPtr(Base, Offset)     ((PBYTE) ((PBYTE)Base + Offset))

#define ERROR_FAILED(_stat)	   (_stat!=NO_ERROR && _stat!=ERROR_SIGNAL_PENDING)
#define ERROR_PENDING(_stat)   (_stat==ERROR_SIGNAL_PENDING)

#define MULTIPLE_OF_EIGHT(_x)  (((_x)+7) & ~7)

#endif  // end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\tc\dll\tcutils.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    tcutils.c

Abstract:

    This module contains support routines for the traffic DLL.

Author:

    Jim Stewart (jstew)    August 14, 1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include <wincon.h>
#include <winuser.h>


#if DBG
BOOLEAN     ConsoleInitialized = FALSE;
HANDLE      DebugFileHandle = INVALID_HANDLE_VALUE;
PTCHAR      DebugFileName = L"/temp/traffic.log";
PTCHAR      TRAFFIC_DBG = L"Traffic.dbg";


VOID
WsAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber
    )
{
    BOOL ok;
    CHAR choice[16];
    DWORD bytes;
    DWORD error;

    IF_DEBUG(CONSOLE) {
        WSPRINT(( " failed: %s\n  at line %ld of %s\n",
                    FailedAssertion, LineNumber, FileName ));
        do {
            WSPRINT(( "[B]reak/[I]gnore? " ));
            bytes = sizeof(choice);
            ok = ReadFile(
                    GetStdHandle(STD_INPUT_HANDLE),
                    &choice,
                    bytes,
                    &bytes,
                    NULL
                    );
            if ( ok ) {
                if ( toupper(choice[0]) == 'I' ) {
                    break;
                }
                if ( toupper(choice[0]) == 'B' ) {
                    DEBUGBREAK();
                }
            } else {
                error = GetLastError( );
            }
        } while ( TRUE );

        return;
    }

    RtlAssert( FailedAssertion, FileName, LineNumber, NULL );

} // WsAssert



VOID
WsPrintf (
    char *Format,
    ...
    )

{
    va_list arglist;
    char OutputBuffer[1024];
    ULONG length;
    BOOL ret;

    length = (ULONG)wsprintfA( OutputBuffer, "TRAFFIC [%05d]: ", 
                               GetCurrentThreadId() );

    va_start( arglist, Format );

    wvsprintfA( OutputBuffer + length, Format, arglist );

    va_end( arglist );

    IF_DEBUG(DEBUGGER) {
        DbgPrint( "%s", OutputBuffer );
    }

    IF_DEBUG(CONSOLE) {

        if ( !ConsoleInitialized ) {
            CONSOLE_SCREEN_BUFFER_INFO csbi;
            COORD coord;

            ConsoleInitialized = TRUE;
            (VOID)AllocConsole( );
            (VOID)GetConsoleScreenBufferInfo(
                    GetStdHandle(STD_OUTPUT_HANDLE),
                    &csbi
                    );
            coord.X = (SHORT)(csbi.srWindow.Right - csbi.srWindow.Left + 1);
            coord.Y = (SHORT)((csbi.srWindow.Bottom - csbi.srWindow.Top + 1) * 20);
            (VOID)SetConsoleScreenBufferSize(
                    GetStdHandle(STD_OUTPUT_HANDLE),
                    coord
                    );
        }

        length = strlen( OutputBuffer );

        ret = WriteFile(
                  GetStdHandle(STD_OUTPUT_HANDLE),
                  (LPVOID )OutputBuffer,
                  length,
                  &length,
                  NULL
                  );

        if ( !ret ) {
            DbgPrint( "WsPrintf: console WriteFile failed: %ld\n",
                          GetLastError( ) );
        }

    }

    IF_DEBUG(FILE) {

        if ( DebugFileHandle == INVALID_HANDLE_VALUE ) {
            DebugFileHandle = CreateFile(
                                  DebugFileName,
                                  GENERIC_READ | GENERIC_WRITE,
                                  FILE_SHARE_READ,
                                  NULL,
                                  CREATE_ALWAYS,
                                  0,
                                  NULL
                                  );
        }

        if ( DebugFileHandle == INVALID_HANDLE_VALUE ) {

            //DbgPrint( "WsPrintf: Failed to open traffic debug log file %s: %ld\n",
            //              DebugFileName, GetLastError( ) );
        } else {

            length = strlen( OutputBuffer );

            ret = WriteFile(
                      DebugFileHandle,
                      (LPVOID )OutputBuffer,
                      length,
                      &length,
                      NULL
                      );
            
            if ( !ret ) {
                DbgPrint( "WsPrintf: file WriteFile failed: %ld\n",
                              GetLastError( ) );
            }
        }
    }

} // WsPrintf

#endif


ULONG
LockedDec(
    IN  PULONG  Count
    )

/*++

Routine Description:

    This routine is a debug routine used for checking decrements on counts.
    It asserts if the count goes negative. The Macro LockedDecrement calls it.

Arguments:

    pointer to the count.

Return Value:

    none

--*/

{
    ULONG Result;

    Result = InterlockedDecrement( (PLONG)Count );

    ASSERT( Result < 0x80000000 );
    return( Result );

}

#if DBG
VOID
SetupDebugInfo()

/*++

Description:
    This routine reads in a debug file that may contain debug instructions.

Arguments:

    none

Return Value:

    none

--*/
{
    HANDLE      handle;

    //
    // If there is a file in the current directory called "tcdebug"
    // open it and read the first line to set the debugging flags.
    //

    handle = CreateFile(
                        TRAFFIC_DBG,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL
                        );

    if( handle == INVALID_HANDLE_VALUE ) {

        //
        // Set default value. changed - Oferbar
        //

        //DebugMask = DEBUG_DEBUGGER | DEBUG_CONSOLE;
        DebugMask |= DEBUG_ERRORS;  // always dump errors
        DebugMask |= DEBUG_FILE;    // always print a log.
        DebugMask |= DEBUG_WARNINGS;    // until Beta3, we want the warnings too

    } else {

        CHAR buffer[11];
        DWORD bytesRead;

        RtlZeroMemory( buffer, sizeof(buffer) );

        if ( ReadFile( handle, buffer, 10, &bytesRead, NULL ) ) {

            buffer[bytesRead] = '\0';

            DebugMask = strtoul( buffer, NULL, 16 );

        } else {

            WSPRINT(( "read file failed: %ld\n", GetLastError( ) ));
        }

        CloseHandle( handle );
    }

}

VOID
CloseDbgFile(
    )

/*++

Routine Description:

    This closes the debug output file if its open.

Arguments:

    none

Return Value:

    none

--*/
{

    if (DebugFileHandle != INVALID_HANDLE_VALUE) {
        CloseHandle( DebugFileHandle );
    }
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\tc\dll\tckrnl.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    tckrnl.c

Abstract:

    This module contains routines that talk to the kernel

Author:

    Jim Stewart (jstew)    August 14, 1996

Revision History:

	Ofer Bar (oferbar)		Oct 1, 1997

--*/

#include "precomp.h"
#pragma hdrstop

//
// we use this mutex to synchronous start up with other traffic.dll's
//
const   UCHAR   TrafficSyncMutex[] = "_TRAFFIC_CTL_MUTEX";


HANDLE  hGpcNotifyThread = INVALID_HANDLE_VALUE;
HANDLE  hGpcNotifyStopEvent = INVALID_HANDLE_VALUE;

DWORD
IoAddFlow(
    IN  PFLOW_STRUC  	pFlow,
    IN  BOOLEAN			Async
    )

/*++

Routine Description:

    This procedure builds up the structure necessary to add a flow.

Arguments:


Return Value:

    status

--*/

{
    DWORD					Status = NO_ERROR;
    PCLIENT_STRUC			pClient = pFlow->pInterface->pClient;
    PTC_IFC					pTcIfc = pFlow->pInterface->pTcIfc;
    PCF_INFO_QOS            Kflow;
    PGPC_ADD_CF_INFO_REQ    GpcReq;
    PGPC_ADD_CF_INFO_RES    GpcRes;
    ULONG                   InBuffSize;
    ULONG                   OutBuffSize;
    ULONG					CfInfoSize;
    PIO_APC_ROUTINE			pCbRoutine = NULL;
    ULONG					l;
    HANDLE					hEvent = NULL;

    //
    // allocate memory for a CF_INFO struct to be passed to the GPC. 
    //

    ASSERT(pFlow->pGenFlow);

    pFlow->GpcHandle = NULL;

    l = pFlow->GenFlowLen;
    ASSERT(l > 0);
    CfInfoSize = l + FIELD_OFFSET(CF_INFO_QOS, GenFlow);
        
    InBuffSize = sizeof(GPC_ADD_CF_INFO_REQ) + CfInfoSize;        

    //
    // And for the return info...
    //

    OutBuffSize = sizeof(GPC_ADD_CF_INFO_RES);

    AllocMem(&GpcRes, OutBuffSize);
    pFlow->CompletionBuffer = (PVOID)GpcRes;
    AllocMem(&GpcReq, InBuffSize);
        
    if (GpcRes && GpcReq) {

        RtlZeroMemory(GpcRes, OutBuffSize);
        RtlZeroMemory(GpcReq, InBuffSize);
    
        //
        // fill in the flow information
        //

        GpcReq->ClientHandle = pFlow->pGpcClient->GpcHandle;
        GpcReq->ClientCfInfoContext = pFlow;
        GpcReq->CfInfoSize = CfInfoSize;

        Kflow = (PCF_INFO_QOS)&GpcReq->CfInfo;

        //
        // fill the instance name
        //

        Kflow->InstanceNameLength = (USHORT) pTcIfc->InstanceNameLength;
        RtlCopyMemory(Kflow->InstanceName, 
                      pTcIfc->InstanceName,
                      pTcIfc->InstanceNameLength * sizeof(WCHAR));

        //
        // set the flow flags
        //
        Kflow->Flags = pFlow->UserFlags;

        //
        // copy the generic flow parameter
        //

        RtlCopyMemory(&Kflow->GenFlow,
                      pFlow->pGenFlow,
                      l);


        if (pClient->ClHandlers.ClAddFlowCompleteHandler && Async) {
            pCbRoutine = CbAddFlowComplete;
        } else {
            hEvent = pFlow->PendingEvent;
        }

        Status = DeviceControl( pGlobals->GpcFileHandle,
                                hEvent,
                                pCbRoutine,
                                (PVOID)pFlow,
                                &pFlow->IoStatBlock,
                                IOCTL_GPC_ADD_CF_INFO,
                                GpcReq,
                                InBuffSize,
                                GpcRes,
                                OutBuffSize);


        if (!ERROR_FAILED(Status)) {

            if (hEvent && Status == ERROR_SIGNAL_PENDING) {

                //
                // wait for the event to signal
                //
                
                IF_DEBUG(IOCTLS) {
                    WSPRINT(("IoAddFlow: Waiting for event 0x%X...\n", 
                             PtrToUlong(hEvent)));
                }

                Status = WaitForSingleObject(hEvent,
                                             INFINITE
                                             );
                IF_DEBUG(IOCTLS) {
                    WSPRINT(("IoAddFlow: ... Event 0x%X signaled, Status=0x%X\n", 
                             PtrToUlong(hEvent), Status));
                }

            }

            if (Status == NO_ERROR) {

                Status = MapNtStatus2WinError(GpcRes->Status);

                IF_DEBUG(IOCTLS) {
                    WSPRINT(("IoAddFlow: GpcRes returned=0x%X mapped to =0x%X\n", 
                             GpcRes->Status, Status));
                }
            }
            
            if (ERROR_SUCCESS == Status) {

                ASSERT(GpcRes->GpcCfInfoHandle);
                
                pFlow->GpcHandle = GpcRes->GpcCfInfoHandle;

                pFlow->InstanceNameLength = GpcRes->InstanceNameLength;

                RtlCopyMemory(pFlow->InstanceName,
                              GpcRes->InstanceName,
                              GpcRes->InstanceNameLength
                              );

                pFlow->InstanceName[pFlow->InstanceNameLength/sizeof(WCHAR)] = L'\0';

                IF_DEBUG(IOCTLS) {
                    WSPRINT(("IoAddFlow: Flow Handle=%d Name=%S\n", 
                             pFlow->GpcHandle,
                             pFlow->InstanceName));
                }
            }
        }

    } else {

        Status = ERROR_NOT_ENOUGH_MEMORY;

    }

    //
    // No, it's not a bug
    // GpcRes will be release in CompleteAddFlow
    //

    if (GpcReq)
        FreeMem(GpcReq);

    IF_DEBUG(IOCTLS) {
        WSPRINT(("<==IoAddFlow: Status=0x%X\n", 
                 Status));
    }

    return Status;
}



DWORD
IoAddClassMapFlow(
    IN  PFLOW_STRUC  	pFlow,
    IN  BOOLEAN			Async
    )

/*++

Routine Description:

    This procedure builds up the structure necessary to add a flow.

Arguments:


Return Value:

    status

--*/

{
    DWORD					Status = NO_ERROR;
    PCLIENT_STRUC			pClient = pFlow->pInterface->pClient;
    PTC_IFC					pTcIfc = pFlow->pInterface->pTcIfc;
    PCF_INFO_CLASS_MAP      Kflow;
    PGPC_ADD_CF_INFO_REQ    GpcReq;
    PGPC_ADD_CF_INFO_RES    GpcRes;
    ULONG                   InBuffSize;
    ULONG                   OutBuffSize;
    ULONG					CfInfoSize;
    PIO_APC_ROUTINE			pCbRoutine = NULL;
    ULONG					l;
    HANDLE					hEvent = NULL;

    return ERROR_CALL_NOT_IMPLEMENTED;

#if NEVER

    // As this is not published in MSDN and not implemented in PSCHED also
    //
    // allocate memory for a CF_INFO struct to be passed to the GPC. 
    //

    ASSERT(pFlow->pClassMapFlow);

    pFlow->GpcHandle = NULL;

    l = sizeof(TC_CLASS_MAP_FLOW) + pFlow->pClassMapFlow->ObjectsLength;
    CfInfoSize = l + FIELD_OFFSET(CF_INFO_CLASS_MAP, ClassMapInfo);
        
    InBuffSize = sizeof(GPC_ADD_CF_INFO_REQ) + CfInfoSize;

    //
    // And for the return info...
    //

    OutBuffSize = sizeof(GPC_ADD_CF_INFO_RES);

    AllocMem(&GpcRes, OutBuffSize);
    pFlow->CompletionBuffer = (PVOID)GpcRes;
    AllocMem(&GpcReq, InBuffSize);

    if (GpcRes && GpcReq) {

        RtlZeroMemory(GpcRes, OutBuffSize);
        RtlZeroMemory(GpcReq, InBuffSize);
    
        //
        // fill in the flow information
        //

        GpcReq->ClientHandle = pFlow->pGpcClient->GpcHandle;
        GpcReq->ClientCfInfoContext = pFlow;
        GpcReq->CfInfoSize = CfInfoSize;

        Kflow = (PCF_INFO_CLASS_MAP)&GpcReq->CfInfo;

        //
        // fill the instance name
        //

        Kflow->InstanceNameLength = (USHORT) pTcIfc->InstanceNameLength;
        RtlCopyMemory(Kflow->InstanceName, 
                      pTcIfc->InstanceName,
                      pTcIfc->InstanceNameLength * sizeof(WCHAR));

        //
        // copy the generic flow parameter
        //

        RtlCopyMemory(&Kflow->ClassMapInfo,
                      pFlow->pClassMapFlow,
                      l);


        if (pClient->ClHandlers.ClAddFlowCompleteHandler && Async) {
            pCbRoutine = CbAddFlowComplete;
        } else {
            hEvent = pFlow->PendingEvent;
        }

        Status = DeviceControl( pGlobals->GpcFileHandle,
                                hEvent,
                                pCbRoutine,
                                (PVOID)pFlow,
                                &pFlow->IoStatBlock,
                                IOCTL_GPC_ADD_CF_INFO,
                                GpcReq,
                                InBuffSize,
                                GpcRes,
                                OutBuffSize);


        if (!ERROR_FAILED(Status)) {

            if (hEvent && Status == ERROR_SIGNAL_PENDING) {

                //
                // wait for the event to signal
                //
                
                IF_DEBUG(IOCTLS) {
                    WSPRINT(("IoAddClassMapFlow: Waiting for event 0x%X...\n", 
                             PtrToUlong(hEvent)));
                }

                Status = WaitForSingleObject(hEvent,
                                             INFINITE
                                             );
                IF_DEBUG(IOCTLS) {
                    WSPRINT(("IoAddClassMapFlow: ... Event 0x%X signaled, Status=0x%X\n", 
                             PtrToUlong(hEvent), Status));
                }

            }

            if (Status == NO_ERROR) {

                Status = MapNtStatus2WinError(GpcRes->Status);

                IF_DEBUG(IOCTLS) {
                    WSPRINT(("IoAddFlow: GpcRes returned=0x%X mapped to =0x%X\n", 
                             GpcRes->Status, Status));
                }
            }
            
            if (!ERROR_FAILED(Status)) {

                ASSERT(GpcRes->GpcCfInfoHandle);
                
                pFlow->GpcHandle = GpcRes->GpcCfInfoHandle;

                pFlow->InstanceNameLength = GpcRes->InstanceNameLength;

                RtlCopyMemory(pFlow->InstanceName,
                              GpcRes->InstanceName,
                              GpcRes->InstanceNameLength
                              );

                pFlow->InstanceName[pFlow->InstanceNameLength/sizeof(WCHAR)] = L'\0';

                IF_DEBUG(IOCTLS) {
                    WSPRINT(("IoAddClassMapFlow: Flow Handle=%d Name=%S\n", 
                             pFlow->GpcHandle,
                             pFlow->InstanceName));
                }
            }
        }

    } else {

        Status = ERROR_NOT_ENOUGH_MEMORY;

    }

    //
    // No, it's not a bug
    // GpcRes will be release in CompleteAddFlow
    //

    if (GpcReq)
        FreeMem(GpcReq);

    IF_DEBUG(IOCTLS) {
        WSPRINT(("<==IoAddClassMapFlow: Status=0x%X\n", 
                 Status));
    }

    return Status;

#endif
}



DWORD
IoModifyFlow(
    IN  PFLOW_STRUC  	pFlow,
    IN  BOOLEAN			Async
    )

/*++

Routine Description:

    This procedure builds up the structure necessary to modify a flow.

Arguments:

	pFlow

Return Value:

    status

--*/

{
    DWORD                	Status = NO_ERROR;
    PCLIENT_STRUC			pClient = pFlow->pInterface->pClient;
    PTC_IFC					pTcIfc = pFlow->pInterface->pTcIfc;
    PCF_INFO_QOS            Kflow;
    PGPC_MODIFY_CF_INFO_REQ GpcReq;
    PGPC_MODIFY_CF_INFO_RES GpcRes;
    ULONG                   InBuffSize;
    ULONG                   OutBuffSize;
    ULONG					CfInfoSize;
    PIO_APC_ROUTINE			pCbRoutine = NULL;
    ULONG					l;
    HANDLE					hEvent = NULL;

    //
    // allocate memory for a CF_INFO struct to be passed to the GPC. 
    //

    ASSERT(pFlow->pGenFlow1);

    l = pFlow->GenFlowLen1;
    ASSERT(l > 0);
    CfInfoSize = l + FIELD_OFFSET(CF_INFO_QOS, GenFlow);
        
    InBuffSize = sizeof(GPC_MODIFY_CF_INFO_REQ) + CfInfoSize;        

    //
    // And for the return info...
    //

    OutBuffSize = sizeof(GPC_MODIFY_CF_INFO_RES);

    AllocMem(&GpcRes, OutBuffSize);
    pFlow->CompletionBuffer = (PVOID)GpcRes;
    AllocMem(&GpcReq, InBuffSize);

    if (GpcRes && GpcReq) {

        RtlZeroMemory(GpcRes, OutBuffSize);
        RtlZeroMemory(GpcReq, InBuffSize);
    
        //
        // fill in the flow information
        //

        GpcReq->ClientHandle = pFlow->pGpcClient->GpcHandle;
        GpcReq->GpcCfInfoHandle = pFlow->GpcHandle;
        GpcReq->CfInfoSize = CfInfoSize;

        Kflow = (PCF_INFO_QOS)&GpcReq->CfInfo;

        //
        // fill the instance name
        //

        Kflow->InstanceNameLength = (USHORT) pTcIfc->InstanceNameLength;
        RtlCopyMemory(Kflow->InstanceName, 
                      pTcIfc->InstanceName,
                      pTcIfc->InstanceNameLength * sizeof(WCHAR));

        //
        // copy the generic flow parameter
        //

        RtlCopyMemory(&Kflow->GenFlow,
                      pFlow->pGenFlow1,
                      l);

                      
        if (pClient->ClHandlers.ClModifyFlowCompleteHandler && Async) {
            pCbRoutine = CbModifyFlowComplete;
        } else {
            hEvent = pFlow->PendingEvent;
        }

        Status = DeviceControl( pGlobals->GpcFileHandle,
                                hEvent,
                                pCbRoutine,
                                (PVOID)pFlow,
                                &pFlow->IoStatBlock,
                                IOCTL_GPC_MODIFY_CF_INFO,
                                GpcReq,
                                InBuffSize,
                                GpcRes,
                                OutBuffSize);

        if (!ERROR_FAILED(Status)) {

            if (hEvent && Status == ERROR_SIGNAL_PENDING) {

                //
                // wait for the event to signal
                //
                
                IF_DEBUG(IOCTLS) {
                    WSPRINT(("IoModifyFlow: Waiting for event 0x%X\n", 
                             PtrToUlong(hEvent)));
                }

                Status = WaitForSingleObject(hEvent,
                                             INFINITE
                                             );
                IF_DEBUG(IOCTLS) {
                    WSPRINT(("IoModifyFlow: ... Event 0x%X signaled, Status=0x%X\n",
                             PtrToUlong(hEvent), Status));
                }
            }

            if (Status == NO_ERROR) {

                Status = MapNtStatus2WinError(GpcRes->Status);
                
                IF_DEBUG(IOCTLS) {
                    WSPRINT(("IoModifyFlow: GpcRes returned=0x%X mapped to =0x%X\n", 
                             GpcRes->Status, Status));
                }
            }
        } else{

            Status = MapNtStatus2WinError(GpcRes->Status);
            
            IF_DEBUG(IOCTLS) {
                WSPRINT(("IoModifyFlow: GpcRes returned=0x%X mapped to =0x%X\n", 
                         GpcRes->Status, Status));
            }

        }

    } else {

        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // No, it's not a bug
    // GpcRes will be release in CompleteModifyFlow
    //

    if (GpcReq)
        FreeMem(GpcReq);

    IF_DEBUG(IOCTLS) {
        WSPRINT(("IoModifyFlow: Status=0x%X\n", 
                 Status));
    }

    return Status;
}



DWORD
IoDeleteFlow(
	IN  PFLOW_STRUC		pFlow,
    IN  BOOLEAN			Async
    )

/*++

Routine Description:

    This procedure builds up the structure necessary to delete a flow.
    It then calls a routine to pass this info to the GPC. 

Arguments:

	pFlow

Return Value:

    status

--*/

{
    DWORD               		Status;
    ULONG               		InBuffSize;
    ULONG               		OutBuffSize;
    PGPC_REMOVE_CF_INFO_REQ     GpcReq;
    PGPC_REMOVE_CF_INFO_RES     GpcRes;
    PIO_APC_ROUTINE				pCbRoutine = NULL;
    PCLIENT_STRUC				pClient = pFlow->pInterface->pClient;
    HANDLE						hEvent = NULL;

    if (IS_REMOVED(pFlow->Flags)) {
        
        //
        // this flow has been already deleted in the kernel
        // due to a flow close notification.
        // no need to send IOTCL to GPC, just return OK
        //

        IF_DEBUG(IOCTLS) {
            WSPRINT(("IoDeleteFlow: Flow has already been deleted=0x%X\n", 
                     PtrToUlong(pFlow)));
        }

        return NO_ERROR;
    }

    //
    // If we add this over here, then if WMI deletes the flow, 
    // the user mode call will just return above.
    //
    GetLock(pFlow->Lock);
    pFlow->Flags |= TC_FLAGS_REMOVED;
    FreeLock(pFlow->Lock);

    //
    // allocate memory for in and out buffers
    //

    InBuffSize =  sizeof(GPC_REMOVE_CF_INFO_REQ);
    OutBuffSize = sizeof(GPC_REMOVE_CF_INFO_RES);

    AllocMem(&GpcRes, OutBuffSize);
    pFlow->CompletionBuffer = (PVOID)GpcRes;
    AllocMem(&GpcReq, InBuffSize);

    if (GpcReq && GpcRes){

        IF_DEBUG(IOCTLS) {
            WSPRINT(("IoDeleteFlow: preparing to delete the flow=0x%X\n", 
                     PtrToUlong(pFlow)));
        }

        GpcReq->ClientHandle = pFlow->pGpcClient->GpcHandle;
        GpcReq->GpcCfInfoHandle = pFlow->GpcHandle;

    
        if (pClient->ClHandlers.ClDeleteFlowCompleteHandler && Async) {
            pCbRoutine = CbDeleteFlowComplete;
        } else {
            hEvent = pFlow->PendingEvent;
        }

        Status = DeviceControl( pGlobals->GpcFileHandle,
                                hEvent,
                                pCbRoutine,
                                (PVOID)pFlow,
                                &pFlow->IoStatBlock,
                                IOCTL_GPC_REMOVE_CF_INFO,
                                GpcReq,
                                InBuffSize,
                                GpcRes,
                                OutBuffSize);

        if (!ERROR_FAILED(Status)) {
        
            if (hEvent && Status == ERROR_SIGNAL_PENDING) {

                //
                // wait for the event to signal
                //
                
                IF_DEBUG(IOCTLS) {
                    WSPRINT(("IoDeleteFlow: Waiting for event 0x%X\n", 
                             PtrToUlong(hEvent)));
                }

                Status = WaitForSingleObject(hEvent,
                                             INFINITE
                                             );
                IF_DEBUG(IOCTLS) {
                    WSPRINT(("IoDeleteFlow: ... Event 0x%X signaled, Status=0x%X\n",
                             PtrToUlong(hEvent), Status));
                }
            }

            if (Status == NO_ERROR) {

                Status = MapNtStatus2WinError(GpcRes->Status);

                IF_DEBUG(IOCTLS) {
                    WSPRINT(("IoDeleteFlow: Gpc returned=0x%X mapped to 0x%X\n", 
                             GpcRes->Status, Status));
                }

                //
                // If the deletion was unsuccessful, let's un-mark the REMOVED flag.
                //
                if (ERROR_FAILED(Status)) {

                    GetLock(pFlow->Lock);
                    pFlow->Flags &= ~TC_FLAGS_REMOVED;
                    FreeLock(pFlow->Lock);

                }

            }
        }

    } else {

        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // No, it's not a bug
    // GpcRes will be release in CompleteDeleteFlow
    //

    if (GpcReq)
        FreeMem(GpcReq);

    IF_DEBUG(IOCTLS) {
        WSPRINT(("<==IoDeleteFlow: Status=0x%X\n", 
                 Status));
    }

    return Status;
}




DWORD
IoAddFilter(
    IN  PFILTER_STRUC	pFilter
    )

/*++

Routine Description:

    This procedure builds up the structure necessary to add a filter.
    It then calls a routine to pass this info to the GPC. 

Arguments:

	pFilter

Return Value:

    status

--*/
{
    DWORD					Status;
    PGPC_ADD_PATTERN_REQ 	GpcReq;
    PGPC_ADD_PATTERN_RES 	GpcRes;
    ULONG               	InBuffSize;
    ULONG               	OutBuffSize;
    PFLOW_STRUC         	pFlow = pFilter->pFlow;
    PTC_GEN_FILTER			pGpcFilter = pFilter->pGpcFilter;
    PUCHAR					p;
    ULONG					PatternSize;
    IO_STATUS_BLOCK			IoStatBlock;

    pFilter->GpcHandle = NULL;

    ASSERT(pGpcFilter);
    ASSERT(pFlow);

    PatternSize = pGpcFilter->PatternSize;

    InBuffSize = sizeof(GPC_ADD_PATTERN_REQ) + 2*PatternSize;
        
    OutBuffSize = sizeof(GPC_ADD_PATTERN_RES);

    AllocMem(&GpcReq, InBuffSize);
    AllocMem(&GpcRes, OutBuffSize);
    
    if (GpcReq && GpcRes){
        
        IF_DEBUG(IOCTLS) {
            WSPRINT(("IoAddFilter: Filling request: size: in=%d, out=%d\n", 
                     InBuffSize, OutBuffSize));
        }

        GpcReq->ClientHandle            = pFlow->pGpcClient->GpcHandle;
        GpcReq->GpcCfInfoHandle         = pFlow->GpcHandle;
        GpcReq->ClientPatternContext    = (GPC_CLIENT_HANDLE)pFilter;
        GpcReq->Priority                = 0;
        GpcReq->PatternSize             = PatternSize;
        GpcReq->ProtocolTemplate		= pFilter->GpcProtocolTemplate;

        //
        // fill in the pattern
        //

        p = (PUCHAR)&GpcReq->PatternAndMask;

        RtlCopyMemory(p, pGpcFilter->Pattern, PatternSize);

        //
        // fill in the mask
        //

        p += PatternSize;

        RtlCopyMemory(p, pGpcFilter->Mask, PatternSize);
        
        Status = DeviceControl( pGlobals->GpcFileHandle,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatBlock,
                                IOCTL_GPC_ADD_PATTERN,
                                GpcReq,
                                InBuffSize,
                                GpcRes,
                                OutBuffSize);

        if (!ERROR_FAILED(Status)) {

            Status = MapNtStatus2WinError(GpcRes->Status);
            
            IF_DEBUG(IOCTLS) {
                WSPRINT(("IoAddFilter: GpcRes returned=0x%X mapped to =0x%X\n", 
                         GpcRes->Status, Status));
            }
            
            //
            // save the filter handle 
            //

            if (!ERROR_FAILED(Status)) {
                
                pFilter->GpcHandle = GpcRes->GpcPatternHandle;
            
            } else {

                IF_DEBUG(IOCTLS) {
                    WSPRINT(("IoAddFilter: GpcRes returned=0x%X mapped to =0x%X\n", 
                             GpcRes->Status, Status));
                }
                
                IF_DEBUG(IOCTLS) {
                    WSPRINT(("Error - failed the addfilter call\n"));
                }
                
                //ASSERT(Status == ERROR_DUPLICATE_FILTER); removed for WAN - interface up down situation

            }   
            
        }

    } else {
        
        Status = ERROR_NOT_ENOUGH_MEMORY;

        IF_DEBUG(ERRORS) {
            WSPRINT(("IoAddFilter: Error =0x%X\n", 
                     Status));
        }

    }
    
    if (GpcReq)
        FreeMem(GpcReq);
    
    if (GpcRes)
        FreeMem(GpcRes);

    IF_DEBUG(IOCTLS) {
        WSPRINT(("<==IoAddFilter: Returned =0x%X\n", 
                 Status));
    }
            
    return Status;
}




DWORD
IoDeleteFilter(
    IN  PFILTER_STRUC	pFilter
    )

/*++

Routine Description:

    This procedure builds up the structure necessary to delete a filter.
    It then calls a routine to pass this info to the GPC. 

Arguments:

	pFilter

Return Value:

    status

--*/
{
    DWORD						Status;
    ULONG               		InBuffSize;
    ULONG               		OutBuffSize;
    GPC_REMOVE_PATTERN_REQ     	GpcReq;
    GPC_REMOVE_PATTERN_RES     	GpcRes;
    IO_STATUS_BLOCK				IoStatBlock;

    //
    // allocate memory for in and out buffers
    //

    if (IS_REMOVED(pFilter->Flags)) {
        
        //
        // this filter has been already deleted in the kernel
        // due to a flow close notification.
        // no need to send IOTCL to GPC, just return OK
        //

        IF_DEBUG(IOCTLS) {
            WSPRINT(("IoDeleteFilter: Filter has already been deleted=0x%X\n", 
                     PtrToUlong(pFilter)));
        }

        return NO_ERROR;
    }

    //
    // If we add this over here, then if WMI deletes the Interface (and the 
    // flows/filters) the user mode call will just return above.
    //
    GetLock(pFilter->Lock);
    pFilter->Flags |= TC_FLAGS_REMOVED;
    FreeLock(pFilter->Lock);

    InBuffSize = sizeof(GPC_REMOVE_PATTERN_REQ);
    OutBuffSize = sizeof(GPC_REMOVE_PATTERN_RES);

    GpcReq.ClientHandle = pFilter->pFlow->pGpcClient->GpcHandle;
    GpcReq.GpcPatternHandle = pFilter->GpcHandle;
    
    ASSERT(GpcReq.ClientHandle);
    ASSERT(GpcReq.GpcPatternHandle);

    Status = DeviceControl( pGlobals->GpcFileHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatBlock,
                            IOCTL_GPC_REMOVE_PATTERN,
                            &GpcReq,
                            InBuffSize,
                            &GpcRes,
                            OutBuffSize
                            );

    if (!ERROR_FAILED(Status)) {
        
        Status = MapNtStatus2WinError(GpcRes.Status);

        IF_DEBUG(IOCTLS) {
            WSPRINT(("IoDeleteFilter: GpcRes returned=0x%X mapped to =0x%X\n", 
                     GpcRes.Status, Status));
        }

        //
        // If the deletion was unsuccessful, let's un-mark the REMOVED flag.
        //
        if (ERROR_FAILED(Status)) {
            
            GetLock(pFilter->Lock);
            pFilter->Flags &= ~TC_FLAGS_REMOVED;
            FreeLock(pFilter->Lock);
        }

    }

    IF_DEBUG(IOCTLS) {
        WSPRINT(("<==IoDeleteFilter: Status=0x%X\n", 
                 Status));
    }

    return Status;
}




DWORD
IoRegisterClient(
    IN  PGPC_CLIENT	pGpcClient
    )
{
    DWORD  					Status;
    GPC_REGISTER_CLIENT_REQ	GpcReq;
    GPC_REGISTER_CLIENT_RES GpcRes;
    ULONG 					InBuffSize;
    ULONG 					OutBuffSize;
    IO_STATUS_BLOCK			IoStatBlock;

    InBuffSize = sizeof(GPC_REGISTER_CLIENT_REQ);
    OutBuffSize = sizeof(GPC_REGISTER_CLIENT_RES);

    GpcReq.CfId = pGpcClient->CfInfoType;
    GpcReq.Flags = GPC_FLAGS_FRAGMENT;
    GpcReq.MaxPriorities = 1;
    GpcReq.ClientContext = 
        (GPC_CLIENT_HANDLE)UlongToPtr(GetCurrentProcessId());	// process id

    Status = DeviceControl( pGlobals->GpcFileHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatBlock,
                            IOCTL_GPC_REGISTER_CLIENT,
                            &GpcReq,
                            InBuffSize,
                            &GpcRes,
                            OutBuffSize );

    if (!ERROR_FAILED(Status)) {
        
        Status = MapNtStatus2WinError(GpcRes.Status);
        pGpcClient->GpcHandle = GpcRes.ClientHandle;

        IF_DEBUG(IOCTLS) {
            WSPRINT(("IoRegisterClient: GpcRes returned=0x%X mapped to =0x%X\n", 
                     GpcRes.Status, Status));
        }
    }

    IF_DEBUG(IOCTLS) {
        WSPRINT(("<==IoRegisterClient: Status=0x%X\n", 
                 Status));
    }

    return Status;
}



DWORD
IoDeregisterClient(
    IN  PGPC_CLIENT	pGpcClient
    )
{
    DWORD						Status;
    GPC_DEREGISTER_CLIENT_REQ   GpcReq;
    GPC_DEREGISTER_CLIENT_RES   GpcRes;
    ULONG 						InBuffSize;
    ULONG 						OutBuffSize;
    IO_STATUS_BLOCK				IoStatBlock;

    InBuffSize = sizeof(GPC_DEREGISTER_CLIENT_REQ);
    OutBuffSize = sizeof(GPC_DEREGISTER_CLIENT_RES);

    GpcReq.ClientHandle = pGpcClient->GpcHandle;

    Status = DeviceControl( pGlobals->GpcFileHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatBlock,
                            IOCTL_GPC_DEREGISTER_CLIENT,
                            &GpcReq,
                            InBuffSize,
                            &GpcRes,
                            OutBuffSize
                            );

    if (!ERROR_FAILED(Status)) {
                
        Status = MapNtStatus2WinError(GpcRes.Status);

        IF_DEBUG(IOCTLS) {
            WSPRINT(("IoDeegisterClient: GpcRes returned=0x%X mapped to =0x%X\n", 
                     GpcRes.Status, Status));
        }
    }

    IF_DEBUG(IOCTLS) {
        WSPRINT(("<==IoDeregisterClient: Status=0x%X\n", 
                 Status));
    }

    return Status;
}

PGPC_NOTIFY_REQUEST_RES     GpcResCb;

DWORD
IoRequestNotify(
	VOID
    //IN  PGPC_CLIENT	pGpcClient
    )
/*
  Description:

  	This routine sends a notification request buffer to the GPC.
    The request will pend until the GPC notifies about a flow 
    being deleted. This will cause a callback to CbGpcNotifyRoutine.

*/
{
    DWORD               		Status;
    ULONG               		OutBuffSize;

    //
    // allocate memory for in and out buffers
    //

    OutBuffSize = sizeof(GPC_NOTIFY_REQUEST_RES);

    AllocMem(&GpcResCb, OutBuffSize);

    if (GpcResCb){

        Status = DeviceControl( pGlobals->GpcFileHandle,
                                NULL,
                                CbGpcNotifyRoutine,
                                (PVOID)GpcResCb,
                                &GpcResCb->IoStatBlock,
                                IOCTL_GPC_NOTIFY_REQUEST,
                                NULL,		//GpcReq,
                                0,			//InBuffSize,
                                GpcResCb,
                                OutBuffSize);

        if (ERROR_FAILED(Status)) {
            
            FreeMem(GpcResCb);
            GpcResCb = NULL;
        }
        else if ( ERROR_PENDING(Status) )
        {
            Status = NO_ERROR;
        }
    } else {

        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    IF_DEBUG(IOCTLS) {
        WSPRINT(("<==IoRequestNotify: Buffer=%p Status=0x%X\n", 
                 GpcResCb, Status));
    }

    return Status;
}


VOID
CancelIoRequestNotify()
/*

    Description:
        This routine cancels the IRP in GPC and waits for the pending
        IO to be cancelled. The callback routine set an event when
        IO request is canclled and this routine waits for that event
        before returning.
        
 */
{
    // Non-zero value of GpcResCb indicates a pending IRP
    if (GpcResCb)
    {
        GpcCancelEvent = CreateEvent ( 
                            NULL,
                            FALSE,
                            FALSE,
                            NULL );
        
        if ( CancelIo ( pGlobals->GpcFileHandle ) )
        {
            if ( GpcCancelEvent )
            {
                WaitForSingleObjectEx(
                    GpcCancelEvent,
                    INFINITE,
                    TRUE );        
                    
                CloseHandle ( GpcCancelEvent );
                GpcCancelEvent = NULL;
            }
            else
            {
                IF_DEBUG(IOCTLS) {
                    WSPRINT((
                        "CancelIo: Status=0x%X\n", 
                        GetLastError() ));
                }
            }
        }    
        
        FreeMem(GpcResCb);

        IF_DEBUG(IOCTLS) 
        {
            WSPRINT(("<==CancelIoRequestNotify: Freed %p\n",
                    GpcResCb ));
        }
    }
    
    return;
}

void 
IncrementLibraryUsageCount(
    HINSTANCE   hinst, 
    int         nCount) 
/*

    Utility routine to increment the ref count on
    the TRAFFIC.DLL so that it will not get unloaded
    before the GPCNotify thread gets a chance to run.
    
 */
{
   TCHAR szModuleName[_MAX_PATH];
   
   GetModuleFileName(hinst, szModuleName, _MAX_PATH);
   
    while (nCount--) 
        LoadLibrary(szModuleName);

    return;
}

DWORD
GpcNotifyThreadFunction ()
/*

    This routine registers an IRP with GPC to listen for
    FLOW close notifications and waits for the stop event.
    When the event is signalled the IRP is canceled and this
    thread exits.

    Since the wait is done in an alertable state GPC callbacks
    are executed in this thread itself.
    
 */
{
    DWORD   dwError;
    
    dwError = IoRequestNotify();

    WaitForSingleObjectEx(
        hGpcNotifyStopEvent,
        INFINITE,
        TRUE );        

    CancelIoRequestNotify();

    FreeLibraryAndExitThread(
        hinstTrafficDll, 
        0 );

    return 0;
}

DWORD
StartGpcNotifyThread()
/*

    Description:
        This routine starts a thread which queues an IRP for
        GPC notifications.
    
    
 */
{
    DWORD   dwError = 0;
    DWORD   dwThreadId = 0;

    // Increment the ref count on this DLL so it will not be unloaded
    // before the GpcNotifyThreadFunction gets to run
    IncrementLibraryUsageCount(
        hinstTrafficDll,
        1);    

    // Create the stop event for the thread to receive 
    // GPC flow close notifications
    hGpcNotifyStopEvent = CreateEvent ( 
                            NULL,
                            FALSE,
                            FALSE,
                            NULL );
    if ( !hGpcNotifyStopEvent ) 
    {
        dwError = GetLastError();
        goto Error;
    }

    // Start the thread.
    hGpcNotifyThread = CreateThread( 
                            NULL,
                            0,
                            (LPTHREAD_START_ROUTINE )GpcNotifyThreadFunction,
                            NULL,
                            0,
                            &dwThreadId );
    if ( !hGpcNotifyThread )
    {
        dwError = GetLastError();
        goto Error;
    }

    // Not closing the thread handle as StopGpcNotifyThread
    // routine will use this handle to wait for thread to
    // terminate.
    
    return 0;
    
Error:
    
    if ( hGpcNotifyStopEvent )
    {
        CloseHandle ( hGpcNotifyStopEvent );
        hGpcNotifyStopEvent = NULL;
    }
    
    if ( hGpcNotifyThread )
    {
        CloseHandle ( hGpcNotifyThread );
        hGpcNotifyThread = NULL;
    }
    
    return dwError;
}


DWORD
StopGpcNotifyThread()
/*
    Description:
        Signal the GPC notification thread to stop
        and wait it to stop.
 */
{
    // If there was no thread created nothing more to do.
    if ( hGpcNotifyThread ) 
    {
    
        // Tell GPC Notify thread to stop
        SetEvent ( hGpcNotifyStopEvent );

        // Wait for it to stop
        WaitForSingleObject ( 
            hGpcNotifyThread,
            INFINITE );

        CloseHandle( hGpcNotifyThread );
        
        hGpcNotifyThread = NULL;

        CloseHandle ( hGpcNotifyStopEvent );
        
        hGpcNotifyStopEvent = NULL;
    }
    
    return 0;
}



DWORD
IoEnumerateFlows(
	IN		PGPC_CLIENT				pGpcClient,
    IN OUT	PHANDLE					pEnumHandle,
    IN OUT	PULONG					pFlowCount,
    IN OUT	PULONG					pBufSize,
    OUT		PGPC_ENUM_CFINFO_RES 	*ppBuffer
    )
/*
  Description:

  	This routine sends a notification request buffer to the GPC.
    The request will pend until the GPC notifies about a flow 
    being deleted. This will cause a callback to CbGpcNotifyRoutine.

*/
{
    DWORD	Status;
    ULONG               		InBuffSize;
    ULONG               		OutBuffSize;
    PGPC_ENUM_CFINFO_REQ     	GpcReq;
    PGPC_ENUM_CFINFO_RES     	GpcRes;
    IO_STATUS_BLOCK				IoStatBlock;
    
    //
    // allocate memory for in and out buffers
    //

    InBuffSize =  sizeof(GPC_ENUM_CFINFO_REQ);
    OutBuffSize = *pBufSize + FIELD_OFFSET(GPC_ENUM_CFINFO_RES,EnumBuffer);

    *ppBuffer = NULL;

    AllocMem(&GpcRes, OutBuffSize);
    AllocMem(&GpcReq, InBuffSize);

    if (GpcReq && GpcRes) {

        GpcReq->ClientHandle = pGpcClient->GpcHandle;
        GpcReq->EnumHandle = *pEnumHandle;
        GpcReq->CfInfoCount = *pFlowCount;

        Status = DeviceControl( pGlobals->GpcFileHandle,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatBlock,
                                IOCTL_GPC_ENUM_CFINFO,
                                GpcReq,
                                InBuffSize,
                                GpcRes,
                                OutBuffSize);

        if (!ERROR_FAILED(Status)) {

            Status = MapNtStatus2WinError(GpcRes->Status);

            IF_DEBUG(IOCTLS) {
                WSPRINT(("IoEnumerateFlows: GpcRes returned=0x%X mapped to =0x%X\n", 
                         GpcRes->Status, Status));
            }

            if (!ERROR_FAILED(Status)) {

                *pEnumHandle = GpcRes->EnumHandle;
                *pFlowCount = GpcRes->TotalCfInfo;
                *pBufSize = (ULONG)IoStatBlock.Information - 
                    FIELD_OFFSET(GPC_ENUM_CFINFO_RES,EnumBuffer);
                *ppBuffer = GpcRes;
            }
        }

    } else {

        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (GpcReq)
        FreeMem(GpcReq);

    if (ERROR_FAILED(Status)) {

        //
        // free GpcReq only if there was an error
        //

        if (GpcRes)
            FreeMem(GpcRes);
    }

    IF_DEBUG(IOCTLS) {
        WSPRINT(("<==IoEnumerateFlows: Status=0x%X\n", 
                 Status));
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\tc\dll\tcwmi.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    tcwmi.c

Abstract:

    This module contains WMI support for traffic control

Author:

        Ofer Bar (oferbar)              Oct 1, 1997

Revision History:


--*/

#include "precomp.h"


static BOOLEAN _init = FALSE;

DWORD
InitializeWmi(VOID)
{
    DWORD               Status = NO_ERROR;

    if (!_init) {

        __try {

            Status = WmiNotificationRegistration( (LPGUID)&GUID_QOS_TC_INTERFACE_UP_INDICATION,
                                                  TRUE,
                                                  CbWmiInterfaceNotification,
                                                  0,
                                                  NOTIFICATION_CALLBACK_DIRECT
                                                  );
            Status = WmiNotificationRegistration( (LPGUID)&GUID_QOS_TC_INTERFACE_DOWN_INDICATION,
                                                  TRUE,
                                                  CbWmiInterfaceNotification,
                                                  0,
                                                  NOTIFICATION_CALLBACK_DIRECT
                                                  );
            Status = WmiNotificationRegistration( (LPGUID)&GUID_QOS_TC_INTERFACE_CHANGE_INDICATION,
                                                  TRUE,
                                                  CbWmiInterfaceNotification,
                                                  0,
                                                  NOTIFICATION_CALLBACK_DIRECT
                                                  );
        } __except (EXCEPTION_EXECUTE_HANDLER) {

            Status = GetExceptionCode();

            IF_DEBUG(ERRORS) {
                WSPRINT(("InitializeWmi: Exception Error: = %X\n", Status ));
            }

        }

        if (Status == NO_ERROR) 
            _init = TRUE;
    }

    return Status;
}



DWORD
DeInitializeWmi(VOID)
{
    DWORD               Status = NO_ERROR;

    if (_init) {

        __try {

            Status = WmiNotificationRegistration( (LPGUID)&GUID_QOS_TC_INTERFACE_UP_INDICATION,
                                                  FALSE,
                                                  CbWmiInterfaceNotification,
                                                  0,
                                                  NOTIFICATION_CALLBACK_DIRECT
                                                  );
            Status = WmiNotificationRegistration( (LPGUID)&GUID_QOS_TC_INTERFACE_DOWN_INDICATION,
                                                  FALSE,
                                                  CbWmiInterfaceNotification,
                                                  0,
                                                  NOTIFICATION_CALLBACK_DIRECT
                                                  );
            Status = WmiNotificationRegistration( (LPGUID)&GUID_QOS_TC_INTERFACE_CHANGE_INDICATION,
                                                  FALSE,
                                                  CbWmiInterfaceNotification,
                                                  0,
                                                  NOTIFICATION_CALLBACK_DIRECT
                                                  );

        } __except (EXCEPTION_EXECUTE_HANDLER) {

            Status = GetExceptionCode();

            IF_DEBUG(ERRORS) {
                WSPRINT(("DeInitializeWmi: Exception Error: = %X\n", Status ));
            }

        }

        if (Status == NO_ERROR) 
            _init = FALSE;
    }

    return Status;
}



DWORD
WalkWnode(
   IN  PWNODE_HEADER                    pWnodeHdr,
   IN  ULONG                                    Context,
   IN  CB_PER_INSTANCE_ROUTINE  CbPerInstance
   )
{
    DWORD               Status;
    ULONG       Flags;
    PWCHAR      NamePtr;
    USHORT      NameSize;
    PBYTE       DataBuffer;
    ULONG       DataSize;
    PULONG              NameOffset;
    WCHAR               TmpName[512];

    Flags = pWnodeHdr->Flags;
    
    if (Flags & WNODE_FLAG_ALL_DATA) {

        //
        // WNODE_ALL_DATA structure has multiple interfaces
        //

        PWNODE_ALL_DATA pWnode = (PWNODE_ALL_DATA)pWnodeHdr;
        UINT            Instance;
        //PULONG        NameOffsets;
        
        NameOffset = (PULONG) OffsetToPtr(pWnode, 
                                          pWnode->OffsetInstanceNameOffsets );
        DataBuffer = (PBYTE) OffsetToPtr (pWnode, 
                                          pWnode->DataBlockOffset);
        
        for ( Instance = 0; 
              Instance < pWnode->InstanceCount; 
              Instance++) {
            
            //
            //  Instance Name
            //
            
            NamePtr = (PWCHAR) OffsetToPtr(pWnode, 
                                           NameOffset[Instance] 
                                           + sizeof(USHORT));
            NameSize = * (USHORT *) OffsetToPtr(pWnode, 
                                                NameOffset[Instance]);
            
            //
            //  Instance Data
            //
            //  Get size and pointer to the buffer
            //
        
            if ( Flags & WNODE_FLAG_FIXED_INSTANCE_SIZE ) {
            
                DataSize = pWnode->FixedInstanceSize;
            
            } else {
            
                DataSize = 
                    pWnode->OffsetInstanceDataAndLength[Instance].LengthInstanceData;
                DataBuffer = 
                    (PBYTE)OffsetToPtr(pWnode,
                                       pWnode->OffsetInstanceDataAndLength[Instance].OffsetInstanceData);
            }

            //
            // a call back to a notification handler that calls the client
            //

            CbPerInstance(Context,
                          (LPGUID)&pWnode->WnodeHeader.Guid,
                          (LPWSTR)NamePtr,
                          DataSize,
                          DataBuffer
                          );
        }

    } else if (Flags & WNODE_FLAG_SINGLE_INSTANCE) {

        //
        // WNODE_SINGLE_INSTANCE structure has only one instance
        // 

        PWNODE_SINGLE_INSTANCE  pWnode = (PWNODE_SINGLE_INSTANCE)pWnodeHdr;
        
        if (Flags & WNODE_FLAG_STATIC_INSTANCE_NAMES) {

            //
            // What am I supposed to do with THAT ?!?
            // NOTHING! (55686)
            //
            
            return (-1);
        }

        NamePtr = (PWCHAR)OffsetToPtr(pWnode, 
                                      pWnode->OffsetInstanceName 
                                      + sizeof(USHORT) );
        NameSize = * (USHORT *) OffsetToPtr(pWnode, 
                                            pWnode->OffsetInstanceName);

        memcpy(TmpName, NamePtr, NameSize);
        TmpName[NameSize/sizeof(WCHAR)] = L'\0';

        //
        //  Data Size
        //

        DataSize = pWnode->SizeDataBlock;
        
        //
        //  Instance Data
        //

        DataBuffer = (PBYTE)OffsetToPtr (pWnode, pWnode->DataBlockOffset);
        
        //
        // a call back to a notification handler that calls the client
        //
        
        CbPerInstance(Context,
                      (LPGUID)&pWnode->WnodeHeader.Guid,
                      (LPWSTR)TmpName,
                      DataSize,
                      DataBuffer
                      );

    } else if (Flags & WNODE_FLAG_SINGLE_ITEM) {

        //
        // WNODE_SINGLE_INSTANCE structure has only one instance
        // 

        PWNODE_SINGLE_ITEM      pWnode = (PWNODE_SINGLE_ITEM)pWnodeHdr;
        
        if (Flags & WNODE_FLAG_STATIC_INSTANCE_NAMES) {

            //
            // What am I supposed to do with THAT ?!?
            // NOTHING! (55686)
            //
            
            return (-1);
        }

        NamePtr = (PWCHAR)OffsetToPtr(pWnode, 
                                      pWnode->OffsetInstanceName 
                                      + sizeof(USHORT) );
        NameSize = * (USHORT *) OffsetToPtr(pWnode, 
                                            pWnode->OffsetInstanceName);
        //
        //  Data Size
        //

        DataSize = pWnode->SizeDataItem;
        
        //
        //  Instance Data
        //

        DataBuffer = (PBYTE)OffsetToPtr (pWnode, pWnode->DataBlockOffset);
        
        //
        // a call back to a notification handler that calls the client
        //
        
        CbPerInstance(Context,
                      (LPGUID)&pWnode->WnodeHeader.Guid,
                      (LPWSTR)NamePtr,
                      DataSize,
                      DataBuffer
                      );
        
    } else {

        ASSERT(0);

    }
    
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\tc\dll\tcglob.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    tcglob.c

Abstract:

    This module contains global variables.

Author:

    Jim Stewart (jstew)    August 14, 1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


//
// global data
//
ULONG       DebugMask = 0;
BOOL        NTPlatform = FALSE;
LPWSCONTROL WsCtrl = NULL;




BOOL
InitializeGlobalData()

/*++

Description:
    This routine initializes the global data.

Arguments:

    none

Return Value:

    none

--*/
{

    DebugMask = DEBUG_FILE | DEBUG_LOCKS;
    InterfaceHandleTable = 0;

    InitializeListHead( &InterfaceList );

    InitLock( InterfaceListLock );

    INIT_DBG_MEMORY();

    return( TRUE );

}

VOID
DeInitializeGlobalData()

/*++

Description:
    This routine de-initializes the global data.

Arguments:

    none

Return Value:

    none

--*/
{

    InterfaceHandleTable = 0;

    DeleteLock( InterfaceListLock );

    DEINIT_DBG_MEMORY();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\tc\dll\tctypes.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    tctypes.h

Abstract:

    This module contains various types and macros for traffic.dll.

Author:

    Jim Stewart ( jstew )    July 28, 1996

Revision History:

	Ofer Bar ( oferbar )     Oct 1, 1996 - Revision II changes

--*/


//
// just patch it in, I can't include ndis.h now
//

#define NDIS_STATUS_INCOMPATABLE_QOS			0xC0010027L


//
// debug mask values for DebugMask
//

#define  DEBUG_CONSOLE        0x00000001
#define  DEBUG_FILE           0x00000002
#define  DEBUG_DEBUGGER       0x00000004
#define  DEBUG_INIT           0x00000008
#define  DEBUG_MEMORY_ALLOC   0x00000010
#define  DEBUG_MEMORY_FREE    0x00000020
#define  DEBUG_MEM_CALLSTACK  0x00000040
#define  DEBUG_CHKSUM_ALLMEM  0x00000080
#define  DEBUG_DUMP_MEM       0x00000100
#define  DEBUG_ERRORS         0x00000200
#define  DEBUG_SHUTDOWN       0x00000400
#define  DEBUG_IOCTLS         0x00000800
#define  DEBUG_CALLS          0x00001000
#define  DEBUG_LOCKS          0x00002000
#define  DEBUG_CALLBACK       0x00004000
#define  DEBUG_STATES         0x00008000
#define  DEBUG_REFCOUNTS      0x00010000
#define  DEBUG_WARNINGS       0x00020000
#define  DEBUG_HANDLES        0x00040000
#define  DEBUG_INTERFACES     0x00080000
#define  DEBUG_REFCOUNTX      0x00100000

#define KiloBytes  		* 1024
//#define MAX_STRING_LENGTH	256

//
// internal flow/filter flags
//
#define TC_FLAGS_INSTALLING		0x00010000
#define TC_FLAGS_MODIFYING		0x00020000
#define TC_FLAGS_DELETING		0x00040000
#define TC_FLAGS_REMOVED		0x00080000
#define TC_FLAGS_WAITING		0x00100000

#define IS_INSTALLING(_f)   (((_f)&TC_FLAGS_INSTALLING)==TC_FLAGS_INSTALLING)
#define IS_MODIFYING(_f)    (((_f)&TC_FLAGS_MODIFYING)==TC_FLAGS_MODIFYING)
#define IS_DELETING(_f)		(((_f)&TC_FLAGS_DELETING)==TC_FLAGS_DELETING)
#define IS_REMOVED(_f)		(((_f)&TC_FLAGS_REMOVED)==TC_FLAGS_REMOVED)
#define IS_WAITING(_f)		(((_f)&TC_FLAGS_WAITING)==TC_FLAGS_WAITING)
#define IS_FLOW_READY(_f)   (!IS_INSTALLING(_f) && \
                             !IS_MODIFYING(_f) && \
                             !IS_DELETING(_f) && \
                             !IS_REMOVED(_f))

//
// GUID compare
//
#define CompareGUIDs(rguid1, rguid2)  (memcmp(rguid1,rguid2,sizeof(GUID))==0)

//
// define object type enum for handle verification
//
typedef enum ULONG ENUM_OBJECT_TYPE;

#define ENUM_CLIENT_TYPE 			0x00000001
#define ENUM_INTERFACE_TYPE			0x00000002
#define ENUM_GEN_FLOW_TYPE			0x00000004
#define ENUM_CLASS_MAP_FLOW_TYPE	0x00000008
#define ENUM_FILTER_TYPE			0x00000010

//
// N.B. tcmacro.h has an array that needs to be in synch with the following
//
typedef enum _STATE {
        INVALID,        // 0 
        INSTALLING,     // 1 - structures were allocated.
        OPEN,           // 2 - Open for business
        USERCLOSED_KERNELCLOSEPENDING, // 3 - the user component has closed it, we are awaiting a kernel close
        FORCED_KERNELCLOSE,            // 4 - the kernel component has forced a close.
        KERNELCLOSED_USERCLEANUP,       // 5 - Kernel has closed it, we are ready to delete this obj.
        REMOVED,        // 6 - Its gone (being freed - remember that the handle has to be freed before removing)
        EXIT_CLEANUP,   // 7 - we are unloading and need to be cleanedup
        MAX_STATES

} STATE;

#define IF_UNKNOWN 0xbaadf00d

#if DBG
//
// N.B. Ensure that this array is in sync with the enum in tctypes.h
//

extern TCHAR *TC_States[];
/* = {
    TEXT("INVALID"),
    TEXT("INSTALLING"),     // structures were allocated.
    TEXT("OPEN"),           // Open for business
    TEXT("USERCLOSED_KERNELCLOSEPENDING"), // the user component has closed it, we are awaiting a kernel close
    TEXT("FORCED_KERNELCLOSE"),            // the kernel component has forced a close.
    TEXT("KERNELCOSED_USERCLEANUP"),       // Kernel has closed it, we are ready to delete this obj.
    TEXT("REMOVED"),        // Its gone (being freed - remember that the handle has to be freed before removing)
    TEXT("EXIT_CLEANUP"),  // we are unloading and need to be cleanedup
    TEXT("MAX_STATES")
    
};*/
#endif 

typedef struct _TRAFFIC_STATE {

    STATE   State;              // current state

#if DBG 
    UCHAR   CurrentStateFile[8];
    ULONG   CurrentStateLine;
    STATE   PreviousState;      // The previous state
    UCHAR   PreviousStateFile[8];       
    ULONG   PreviousStateLine;
#endif 

} TRAFFIC_STATE;

typedef HandleFactory HANDLE_TABLE, *PHANDLE_TABLE;

typedef struct _TRAFFIC_LOCK {

    CRITICAL_SECTION Lock;
#if DBG
    LONG  LockAcquired;             // is it current held?
    UCHAR LastAcquireFile[8];       
    ULONG LastAcquireLine;
    UCHAR LastReleaseFile[8];
    ULONG LastReleaseLine;
#endif

} TRAFFIC_LOCK, *PTRAFFIC_LOCK;


//
// A global structure per process to hold handle table, client list, etc...
//

typedef struct _GLOBAL_STRUC {

    PHANDLE_TABLE		pHandleTbl;
    TRAFFIC_STATE       State;
    LIST_ENTRY			ClientList;    // list of clients
    LIST_ENTRY			TcIfcList;     // list of kernel TC interfaces
    LIST_ENTRY          GpcClientList; // list of GPC clients
    HANDLE				GpcFileHandle; // result of CreateFile on GPC device
    TRAFFIC_LOCK        Lock;

} GLOBAL_STRUC, *PGLOBAL_STRUC;


//
// TC interface structure that holds the kernel interfaces information
//
typedef struct _TC_IFC {

    LIST_ENTRY		Linkage;						// next TC ifc
    LIST_ENTRY		ClIfcList;						// client interface list
    TRAFFIC_STATE   State;                          // need this state for bug 273978
    TRAFFIC_LOCK    Lock;
    REF_CNT         RefCount;
    ULONG			InstanceNameLength;				// 
    WCHAR			InstanceName[MAX_STRING_LENGTH];// instance friendly name
    ULONG			InstanceIDLength;				// 
    WCHAR			InstanceID[MAX_STRING_LENGTH];  // instance ID
    ULONG			AddrListBytesCount;
	PADDRESS_LIST_DESCRIPTOR	pAddressListDesc;   //
    ULONG			InterfaceIndex; 				// the interafce index from the OS
    ULONG			SpecificLinkCtx;				// the link context (only for WAN)

} TC_IFC, *PTC_IFC;


//
// A GPC client structure, one per CF_INFO type
//
typedef struct _GPC_CLIENT {

    LIST_ENTRY		Linkage;	// next GPC client
    ULONG			CfInfoType; // QOS, CBQ, etc.
    GPC_HANDLE		GpcHandle;	// return by GPC after GpcRegisterClient call
    ULONG			RefCount;
    
} GPC_CLIENT, *PGPC_CLIENT;

//
// this is the client structure that is allocated per TcRegisterClient
//
typedef struct _CLIENT_STRUC {

    ENUM_OBJECT_TYPE		ObjectType;	// must be first!
    TRAFFIC_STATE           State;
    TRAFFIC_LOCK            Lock;
    LIST_ENTRY				Linkage;	// next client
    HANDLE					ClHandle;	// client handle
    TCI_CLIENT_FUNC_LIST	ClHandlers;	// client's handler list
    HANDLE					ClRegCtx;   // client registration context
    REF_CNT					RefCount;
    LIST_ENTRY				InterfaceList;	// list of opened interface for the client
    ULONG					InterfaceCount;

} CLIENT_STRUC, *PCLIENT_STRUC;


//
// this type is allocated each time an app calls TcOpenInterface
//
typedef struct _INTERFACE_STRUC {

    ENUM_OBJECT_TYPE	ObjectType;		// must be first!
    TRAFFIC_STATE       State;          
    TRAFFIC_LOCK        Lock;
    LIST_ENTRY  		Linkage;    	// linkage onto the client's list
    LIST_ENTRY  		NextIfc;    	// next interface for the same TcIfc
    HANDLE				ClHandle;     	// handle returned to the app
    HANDLE				ClIfcCtx;       // client context for this interface
    PTC_IFC				pTcIfc;			// pointer to the kernel TC interface struct
    PCLIENT_STRUC		pClient;		// supporting client
    REF_CNT				RefCount;
    LIST_ENTRY  		FlowList;		// list of open flows on the Interface
    ULONG				FlowCount;
    HANDLE              IfcEvent;       
    ULONG               Flags;          // Used for deciding if we need to wait 
                                        // while closing the interface.
    DWORD               CallbackThreadId;
} INTERFACE_STRUC, *PINTERFACE_STRUC;


//
// this type is allocated each time TcAddFlow is called
//
typedef struct _FLOW_STRUC {

    ENUM_OBJECT_TYPE	ObjectType;	// must be first!
    TRAFFIC_STATE       State;
    TRAFFIC_LOCK        Lock;
    LIST_ENTRY  		Linkage;	// next flow on the interface
    USHORT				InstanceNameLength;				// 
    WCHAR				InstanceName[MAX_STRING_LENGTH];// instance ID
    PINTERFACE_STRUC  	pInterface;	// back ptr to interface struc
    GPC_HANDLE			GpcHandle;	// GPC handle
    HANDLE        		ClHandle;	// handle returned to app
    HANDLE				ClFlowCtx;	// client flow context
    ULONG				Flags;		// status indication
    ULONG				UserFlags;	// User defined flags
    PGPC_CLIENT			pGpcClient;	// GPC client to use
    PTC_GEN_FLOW		pGenFlow;	// save the flow spec
    PTC_GEN_FLOW		pGenFlow1;	// save the modified flow spec
    ULONG				GenFlowLen;
    ULONG				GenFlowLen1;
    PTC_CLASS_MAP_FLOW	pClassMapFlow;	//
    PTC_CLASS_MAP_FLOW	pClassMapFlow1;	//
    IO_STATUS_BLOCK		IoStatBlock;// for async completion
    PVOID    			CompletionBuffer;
    HANDLE				PendingEvent;
    REF_CNT				RefCount;
    LIST_ENTRY  		FilterList; // head of list of filters on this flow
    ULONG               FilterCount;
} FLOW_STRUC, *PFLOW_STRUC;

//
// this type is allocated each time TcAddFilter is called
//
typedef struct _FILTER_STRUC {

    ENUM_OBJECT_TYPE	ObjectType;	// must be first!
    TRAFFIC_STATE       State;      
    TRAFFIC_LOCK        Lock;
    LIST_ENTRY  		Linkage; 	// next filter on the flow
    REF_CNT             RefCount;   // When do we remove the structure?
    PFLOW_STRUC 		pFlow; 		// back ptr to flow struc
    HANDLE      		GpcHandle;	// GPC handle
    HANDLE				ClHandle;	// handle returned to app
    ULONG				Flags;
    ULONG				GpcProtocolTemplate;
    PTC_GEN_FILTER		pGpcFilter; // GPC pattern

} FILTER_STRUC, *PFILTER_STRUC;


//
// gen linked list
//
typedef struct _GEN_LIST {

    struct _GEN_LIST	*Next;
    PVOID				Ptr;

} GEN_LIST, *PGEN_LIST;

//
// callback routine typedef
//
typedef
VOID (* CB_PER_INSTANCE_ROUTINE)(
    IN	ULONG	Context,
    IN  LPGUID	pGuid,
	IN	LPWSTR	InstanceName,
    IN	ULONG	DataSize,
    IN	PVOID	DataBuffer
    );

//
// Global Variable definitions
//

extern ULONG    DebugMask;

//
// ptr to global structure per process
//

extern PGLOBAL_STRUC	pGlobals;

//
// keep track of which platform - NT or Win95
//

extern BOOL             NTPlatform;

//
// This is the ptr used in Win95 to access the Ioctl functions via Winsock
//

//extern LPWSCONTROL             WsCtrl;

//
// set when we call InitializeOsSpecific(), it will indicate status
// for the initialization routine, that will later be reported
// in TcRegisterClient, since we don't want to fail clients, like RSVP
// during DLL init time when TC is not available, but rather prevent it
// from doing any TC
//

extern DWORD    InitializationStatus;

//
// NtBug : 258218
// Within a process, need to maintain notification registrations specific 
// a Client, interface and Notification GUID. Lets define the struct below
// that will enable us to do this. Maintain a list of every notification
// that we care about. (yes, its not the most optimized Data Structure)
//

extern TRAFFIC_LOCK         NotificationListLock;
extern LIST_ENTRY           NotificationListHead;

typedef struct _NOTIFICATION_ELEMENT {
    
    LIST_ENTRY              Linkage;            // Other notification elements
    PINTERFACE_STRUC        IfcHandle;          // Interface on which we want this notification
    GUID                    NotificationGuid;   // Notification GUID

} NOTIFICATION_ELEMENT, *PNOTIFICATION_ELEMENT;

extern  TRAFFIC_LOCK        ClientRegDeregLock;
extern  HANDLE              GpcCancelEvent;
extern  PVOID               hinstTrafficDll;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\tools\qtcp\ioctl.h ===
#ifndef _IOCTL
#define _IOCTL

// Define the ioctls for adding and removing ports.
#define CTRL_CODE(function, method, access) \
                CTL_CODE(FILE_DEVICE_NETWORK, function, method, access)

#define IOCTL_TIMESTMP_REGISTER_PORT       CTRL_CODE( 0x847, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_TIMESTMP_DEREGISTER_PORT     CTRL_CODE( 0x848, METHOD_BUFFERED, FILE_WRITE_ACCESS)


#endif //_IOCTL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\tools\timestmp\timestmp.h ===
#ifndef _TIMESTMP_

#define _TIMESTMP_

#include <ntosp.h>
#include <ndis.h>
#include <qos.h>
#include <traffic.h>
#include <ntddtc.h>
#include <cxport.h>
#include <ip.h>
#include <pktsched.h>
#include "ioctl.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\tools\qtcp\qtcp.c ===
//
//  QTCP.C version 1.0.3
//
// This program tests the quality of a network connection in terms of 
// variation in latency (jitter). It is based on TTCP, a public domain 
// program, written for BSD. The version of TTCP upon which this was
// based has been contributed to by:
//
//      T.C. Slattery, USNA (18 Dec 84)
//      Mike Muuss and T. Slattery (16 Oct 85)
//      Silicon Graphics, Inc. (1989)
//
// QTCP is written by Yoram Bernet (yoramb@microsoft.com)
//      further development work by John Holmes (jsholmes@mit.edu)
// 
// QTCP user level code may be used to provide rough jitter measurements,
// which indicate both operating system and network jitter. However, QTCP
// is intended to be used in conjunction with kernel timestamping for precise
// jitter measurements. The kernel component timestmp.sys should be installed
// when running on Win2000 (beta-3 or later).
//
// timestmp.sys is written by Shreedhar Madhavapeddi (shreem@microsoft.com)
//
//
// Distribution Status -
//      Public Domain.  Distribution Unlimited.
//

// Version History -
//   0.8:
//		- adaptation of TTCP by Yoram Bernet -- core functionality
//   0.9: (6/15/99)
//		- first version by John Holmes -- bug fixes and new features
//      - fixed all compile warnings
//      - added -v option to set up RSVP connection without sending data
//      - added -y option to skip confirmation of continues
//      - fixed line length error in log files
//      - fixed service type string to display properly
//      - added best effort and no service service types (BE & NS)
//      - added version string print upon execution
//   0.9.1: (6/17/99)
//      - check for hardware clock reset using correlation coefficient
//      - fixed incorrect clock skew in .sta file
//      - fixed -v option to keep socket open until user carriage returns
//      - added local statistics to clock skew computation for better estimate
//      - added -k option to prevent using local statistics for clock skew
//      - fixed maximum latency computation
//   0.9.2: (6/23/99)
//  	- fixed peak rate in flowspec so no shaping happens in CL servicetype
//      - added -e option to force shaping
//      - fixed error in allocating size of log array with bufsize <= 1500 bytes
//      - fixed not exiting on receiver
//      - fixed access violation if no filename specified on receiver
//      - changed dummy log entries to be off by default
//      - added -F option to convert raw file to log file
//   0.9.3: (6/29/99)
//      - improved low transmission speed at high packet/second rates by changing
//        default # async buffers from 3 to 32
//      - fixed user mode timestamps to use NtQueryPerformanceCounter()
//      - added -u option to use usermode timestamps in log generation
//   0.9.4: (7/8/99)
//      - cleaned up source (chopped up main into a bunch of functions to improve readability)
//      - fixed default buffer size to be 1472 bytes, so whole packet is 1500 bytes.
//      - rewrote i/o code to use callbacks for asynch i/o in order to improve throughput
//      - doing the right thing if not getting kernel-mode timestamps
//      - added ability to run for a specified amount of time with -n##s paramater
//      - added dynamic resizing of log array on receiver to prevent access violations
//        with mismatched parameters
//      - fixed devious bug in the GrowLogArray routine
//      - fixed total time reported for long runs (use UINT64 instead of DWORD)
//      - fixed problem with -F option specified on empty but extant file
//      - added RSVPMonitor Thread to watch for RSVP-err messages on receiver and
//        early abort by sender
//      - removed -a option as it is now obsolete
//      - revised usage screen to make more clear what pertains to sender and what
//        pertains to receiver
//      - fixed crash if receiver terminates before transmitter finishes
//   0.9.5: (7/15/99)
//      - re-added error checking on WriteFileEx and ReadFileEx routines
//   0.9.6: (7/20/99)
//      - changed default filler data in buffer so that it is less compressible to 
//        better account for links that compress data before sending
//      - added -i option to use more compressible data
//   0.9.7: (7/24/99)
//      - put back a thread to watch for 'q' on receiver to quit properly before sender's done
//      - added control channel to better handle RSVP timeouts, early aborts, etc.
//      - if no calibrations are specified, we calibrate based on all buffers
//      - gracefully exit if LogRecord runs out of memory, saving all logs we've got so far
//      - changed default behavior so raw file is dumped with no normalization whatsoever.
//      - improved the way anomalous points are caught in clock-skew calc
//   0.9.8: (7/28/99)
//      - fixed field assignments & file opening problem on converting raw file to log.
//      - changed latency to be written to file to signed and fixed normalization routine for
//        cases when clocks are orders of magnitude different (underflow error)
//      - added absolute deviation as goodness of fit measure
//      - added routine to look for clock jumps and fix for them (with -k3 option)
//   0.9.9: (8/4/99)
//      - changed format of .sta file to include more useful information and test params
//      - changed Logging scheme so that we are limited by disk space instead of memory
//        (now using a memory mapped file for the log, so the theoretical limit has gone from
//        less than 2GB to 18EB, but we won't ever get that in practice on normal disks)
//      - added -ni option to run indefinitely
//      - added -R##B option to specify tokenrate in bytes
//      - made default not to show dropped packets at console (it only causes more drops)
//      - added -q## option to log only every nth packet
//   1.0.0: (8/6/99)
//      - fixed bug where if a new qtcp receiver is started immediately after a previous
//        instance, it will think "theend" packets are normal packets and AV
//      - added check for the piix4 timer chip and an appropriate warning
//      - using precise incorrect value in FixWackyTimestamps function
//      - added -A option (aggregate data processing of all .sta files in a directory)
//   1.0.1: (8/6/99)
//      - fixed incorrect calculation of send rate with dropped packets
//   1.0.2: (8/23/99)
//      - improved clock skip detection algorithm
//      - fixed a bug in control channel communication of TokenRate
//      - fixed problem with forceshape option when rate is specified in bytes
//   1.0.3: (8/26/99)
//      - fixed SENDERS NO_SENDERS bug
//      - added summary over time to aggregate stats option
//      - changed .sta file format to include number of drops
//      - fixed shaping in best effort servicetype

// ToDo:
//      - add histogram to output in .sta file and on console
//      - add ability to run w/o control channel connection
//      - mark control channel traffic as higher priority
//      - add more aggregate stats (time varying statistics) -- maybe fourier xform

#ifndef lint
static char RCSid[] = "qtcp.c $Revision: 1.0.3 $";
#endif

#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <io.h>
#include <signal.h>
#include <ctype.h>
#include <sys/types.h>
#include <winsock2.h>
#include <qossp.h>
#include <winbase.h>
#include <time.h>
#include <shlwapi.h>

#if defined(_AMD64_)
#include <math.h>
#endif

#include "ioctl.h"

#define CONTROL_PORT 7239

CHAR *VERSION_STRING = "1.0.3";
#define MAX_STRING 255

INT64 MAX_INT64=9223372036854775807;

HANDLE hRSVPMonitor;
DWORD idRSVPMonitor;

INT64 g_BadHalAdjustment = 46869688;  // this is the value on a piix4 chip
SYSTEM_INFO g_si;
char g_szErr[255];
CRITICAL_SECTION g_csLogRecord;
EXCEPTION_RECORD g_erec;

BOOL g_fOtherSideFinished = FALSE;
BOOL g_fReadyForXmit = FALSE;
SOCKET fd;
SOCKET g_sockControl = INVALID_SOCKET;
struct sockaddr_in sinhim;
struct sockaddr_in sinme;
short port = 5003;              // UDP port number
char *host;                     // ptr to name of host
char szHisAddr[MAX_STRING];
char szMyAddr[MAX_STRING];

int trans;                      // 0=receive, !0=transmit mode
int normalize = 0;              // dump raw file after normalizing

char *Name = NULL;              // Name of file for logs
HANDLE hRawFile = NULL;
HANDLE hLogFile = NULL;
HANDLE hStatFile = NULL;
HANDLE hDriver = NULL;	// handle to the timestmp.sys driver

WSADATA WsaData;
WSAEVENT QoSEvents;

SYSTEMTIME systimeStart;
INT64 timeStart;
INT64 time0;
INT64 time1;
INT64 timeElapsed;

CHAR* TheEnd = "TheEnd";
CHAR* ControlledLoad = "CL";
CHAR* Guaranteed = "GR";
CHAR* BestEffort = "BE";
CHAR* NoTraffic = "NT";

LPCTSTR DriverName = TEXT("\\\\.\\Timestmp");

BOOL fWackySender = FALSE;
BOOL fWackyReceiver = FALSE;

typedef struct {
    HANDLE hSocket;
    INT TokenRate;   
    INT MaxSDUSize;
    INT BucketSize;
    INT MinPolicedSize;
    SERVICETYPE dwServiceType;
    CHAR *szServiceType;
    INT buflen;          // length of buffer
    INT nbuf;            // number of buffers to send
    INT64 calibration;
    BOOLEAN UserStamps;  // By default, we use kernel mode timestamping, if available
    BOOLEAN SkipConfirm; // By default, we wait for user confirmation at certain times
    BOOLEAN RESVonly;    // By default, we send data after getting the resv
    int SkewFitMode;     // by default, 0 = no fit, 1 = chisq, 2 = chisq w/outlier removal
                         //   3 = abs dev
    BOOLEAN Wait;        // By default, we wait for a QoS reservation
    BOOLEAN Dummy;       // insert dummy rows in log by default
    BOOLEAN PrintDrops;  // report dropped packets on console
    BOOLEAN ForceShape;  // by default, we do not force shaping on CL flows
    BOOLEAN RateInBytes; // KB by default
    BOOLEAN AggregateStats; // by default, we do not do this
    BOOLEAN ConvertOnly; // by default, we act normally and do not go around converting files
    BOOLEAN NoSenderTimestamps;
    BOOLEAN NoReceiverTimestamps;
    BOOLEAN TimedRun;    // true if we're running for a specified amount of time
    BOOLEAN RunForever;  // run until the person pushes 'q'
    BOOLEAN nBufUnspecified; // true if the user has not specified the -n parameter
    BOOLEAN RandomFiller;// by default, we use random, incompressible filler data
    int LoggingPeriod;   // by default, 1 (log every packet)
} QTCPPARAMS, *PQTCPPARAMS;

QTCPPARAMS g_params;

typedef struct {
    BOOL Done;             // done if true
    int nWritesInProgress; // number of writes outstanding
    int nReadsInProgress;  // number of reads outstanding
    int nBuffersSent;      // number of buffers sent to the device
    int nBuffersReceived;  // number of buffers received from network
    int nBytesTransferred; // number of bytes written to device
} QTCPSTATE, *PQTCPSTATE;

QTCPSTATE g_state;

typedef struct {
    OVERLAPPED Overlapped;
    PVOID pBuffer;
    DWORD BytesWritten;
} IOREQ, *PIOREQ;

#define MAX_PENDING_IO_REQS 64  // number of simultaneous async calls.

// This format is used for the buffer
// transmitted on the wire.
typedef struct _BUFFER_FORMAT{
    INT64 TimeSentUser;
    INT64 TimeReceivedUser;
    INT64 TimeSent;
    INT64 TimeReceived;
    INT64 Latency;
    INT BufferSize;
    INT SequenceNumber;
} BUFFER_FORMAT, *PBUFFER_FORMAT;

// This format is used for the scheduling record
// written based on the received buffers.
typedef struct _LOG_RECORD{
    INT64 TimeSentUser;
    INT64 TimeReceivedUser;
    INT64 TimeSent;
    INT64 TimeReceived;
    INT64 Latency;
    INT BufferSize;
    INT SequenceNumber;
} LOG_RECORD, *PLOG_RECORD;

// The LOG structure is a data abstraction for a log of LOG_RECORDS that uses memory
// mapped files to have a theoretical storage limit of 18EB. It uses two buffers in memory
// along with a watcher thread so that there is no delay when switching from one bit to
// the next.
typedef struct {
    INT64 nBuffersLogged;
    PBYTE pbMapView;           // view of file in Get/SetLogElement functions
    INT64 qwMapViewOffset;     // offset of Get/Set view in file (rounded down to allocation)
    char *szStorageFile;       // the name of the mapped file on disk (so we can delete it)
    HANDLE hStorageFile;       // the memory mapped file on disk
    HANDLE hFileMapping;       // the file mapping object for our storage file
    INT64 qwFileSize;          // the size of the storage file in bytes
} LOG, *PLOG;
LOG g_log;

// The STATS structure keeps a record of overall statistics for the qtcp run
typedef struct {
    char szStaFile[MAX_PATH];
    char szSender[MAX_STRING];
    char szReceiver[MAX_STRING];
    int nBuffers;
    int nTokenRate;
    int nBytesPerBuffer;
    double sendrate;
    double recvrate;
    double median;
    double mean;
    double var;
    double kurt;
    double skew;
    double abdev;
    FILETIME time; 
    int nDrops;
} STATS, *PSTATS;

INT64 totalBuffers;
INT anomalies = 0;
INT SequenceNumber = 0;
INT LastSequenceNumber = -1;

#define bcopy(s, d, c)  memcpy((u_char *)(d), (u_char *)(s), (c))
#define bzero(d, l)     memset((d), '\0', (l))

#define SENDER      1
#define RECEIVER    0

#define SECONDS_BETWEEN_HELLOS 120
// control messages
#define MSGCH_DELIMITER '!'
#define MSGST_RSVPERR "RSVPERR"
#define MSGST_ABORT "ABORT"
#define MSGST_ERROR "ERROR"
#define MSGST_DONE "DONE"
#define MSGST_HELLO "HELLO"
#define MSGST_RATE "RATE"
#define MSGST_SIZE "SIZE"
#define MSGST_NUM "NUM"
#define MSGST_READY "READY"
#define MSGST_VER "VER"

// -------------------
// Function prototypes
// -------------------

VOID
SetDefaults();

VOID
Usage();

BOOLEAN
GoodParams();

VOID
SetupLogs();

VOID
SetupSockets();
	
SOCKET 
OpenQoSSocket();

INT
SetQoSSocket(
    SOCKET fd,
    BOOL Sending);

VOID
WaitForQoS(
    BOOL Sender,
    SOCKET fd);

ULONG
GetRsvpStatus(
    DWORD dwTimeout,
    SOCKET fd);

VOID
PrintRSVPStatus(
    ULONG code);

VOID
DoTransmit();

VOID WINAPI
TransmitCompletionRoutine(
    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransferred,
    LPOVERLAPPED pOverlapped);

VOID WINAPI
DelimiterSendCompletion(
    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransferred,
    LPOVERLAPPED pOverlapped);

VOID
FillBuffer(
    CHAR *Cp,
    INT   Cnt);

INT
TimeStamp(
    CHAR *Cp, 
    INT   Cnt);

VOID
DoReceive();

VOID WINAPI
RecvCompletionRoutine(
    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransferred,
    LPOVERLAPPED pOverlapped);

VOID
LogRecord(CHAR * Buffer);

BOOL CreateLog(PLOG plog, INT64 c);
BOOL GetLogEntry(PLOG plog, PLOG_RECORD prec, INT64 i);
BOOL DestroyLog(PLOG plog);
BOOL SetLogEntry(PLOG plog, PLOG_RECORD prec, INT64 i);
BOOL AddLogEntry(PLOG plog, PLOG_RECORD prec);

UINT64
GetUserTime();

DWORD
MyCreateFile(
    IN PCHAR Name,
    IN PCHAR Extension,
    OUT HANDLE *File);
    
void AggregateStats();

int IndexOfStatRecWith(int rate, int size, INT64 time, PSTATS pStats, int cStats);

BOOL GetStatsFromFile(PSTATS pstats);

VOID
DoStatsFromFile();
    
DWORD
OpenRawFile(
	IN PCHAR Name,
	OUT HANDLE *File);

INT64 ReadSchedulingRecords(HANDLE file);
	
VOID
DoStats();
	
VOID
WriteSchedulingRecords(
    HANDLE File,
    BOOLEAN InsertDummyRows);

void AdvancedStats();

VOID
GenericStats();

VOID
CheckForLostPackets();

VOID
WriteStats(
    UCHAR * HoldingBuffer,
    INT Count);

VOID
NormalizeTimeStamps();

VOID
ClockSkew(
    DOUBLE * Slope,
    DOUBLE * Offset);

BOOLEAN
AnomalousPoint(
    DOUBLE x,
    DOUBLE y);

VOID
AdjustForClockSkew(
    DOUBLE Slope,
    DOUBLE Offset);
    
BOOL FixWackyTimestamps();

// monitor threads
DWORD WINAPI RSVPMonitor (LPVOID lpvThreadParm);    
DWORD WINAPI KeyboardMonitor (LPVOID lpvThreadParm);
DWORD WINAPI ControlSocketMonitor(LPVOID lpvThreadParm);
DWORD WINAPI LogWatcher(LPVOID lpvThreadParm);

// utilities
int SendControlMessage(SOCKET sock, char * szMsg);
void ErrorExit(char *msg, DWORD dwErrorNumber);
UINT64 GetBadHalAdjustment();
//int compare( const void *arg1, const void *arg2 );
int __cdecl compare(const void *elem1, const void *elem2 ) ;
void medfit(double x[], double y[], int N, double *a, double *b, double *abdev);
double mode(const double data[], const int N);
void RemoveDuplicates(int rg[], int * pN);
void RemoveDuplicatesI64(INT64 rg[], int * pN);
#define RoundUp(val, unit) (val + (val % unit))
#define InRange(val, low, high) ((val >= low) && (val < high)) ? TRUE:FALSE
void PrintFlowspec(LPFLOWSPEC lpfs);

VOID __cdecl
main(INT argc,CHAR **argv)
{
    int 		error;
    char 		*stopstring;
    char 		szBuf[MAX_STRING];
	BOOL        b;
	ULONG		bytesreturned;
	
    printf("qtcp version %s\n\n",VERSION_STRING);

    if (GetBadHalAdjustment() == (UINT64)g_BadHalAdjustment) {
        printf("WARNING: This machine has a timer whose frequency matches that of the piix4\n");
        printf("         chip. There is a known bug in the HAL for this timer that causes the\n");
        printf("         timer to jump forward about 4.7 seconds every once in a while.\n");
        printf("         If you notice large jumps in the timestamps from this machine, try\n");
        printf("         running with the -k3 option to attempt to correct for the timer bug.\n\n");
    }    
    
    srand( (unsigned)time( NULL ) ); // seed the random number generator
    timeStart = GetUserTime();
    GetSystemInfo(&g_si);
    error = WSAStartup( 0x0101, &WsaData );
    if (error == SOCKET_ERROR) {
        printf("qtcp: WSAStartup failed %ld:", WSAGetLastError());
    }

    if (argc < 2) Usage();

    Name = malloc(MAX_STRING);
    bzero(Name,MAX_STRING);

    SetDefaults();

    argv++; argc--;
    while( argc>0 && argv[0][0] == '-' )  {
        switch (argv[0][1]) {
            case 'B':
                g_params.BucketSize = atoi(&argv[0][2]);
                break;
            case 'm':
                g_params.MinPolicedSize = atoi(&argv[0][2]);
                break;
            case 'M':
                g_params.MaxSDUSize = atoi(&argv[0][2]);
                break;
            case 'R':
                g_params.TokenRate = (int)strtod(&argv[0][2],&stopstring);
                if (*stopstring == 0) { // normal run
                    g_params.RateInBytes = FALSE;
                    break;
                }
                if (*stopstring == 'B') { // rate is in bytes / sec, not kbytes/sec
                    g_params.RateInBytes = TRUE;
                    break;
                }
                else {
                    Usage();
                    break;
                }
            case 'S':
                g_params.szServiceType = &argv[0][2];
                if(!strncmp(g_params.szServiceType, ControlledLoad, 2)){
                    g_params.dwServiceType = SERVICETYPE_CONTROLLEDLOAD;
                break;
                }
                if(!strncmp(g_params.szServiceType, Guaranteed, 2)){
                    g_params.dwServiceType = SERVICETYPE_GUARANTEED;
                break;
                }
				if(!strncmp(g_params.szServiceType, BestEffort, 2)){
				    g_params.dwServiceType = SERVICETYPE_BESTEFFORT;
					g_params.Wait = FALSE;
					break;
			    }
				if(!strncmp(g_params.szServiceType, NoTraffic, 2)){
					g_params.dwServiceType = SERVICETYPE_NOTRAFFIC;
					g_params.Wait = FALSE;
					break;
				}
                fprintf(stderr, "Invalid service type (not CL or GR).\n");
                fprintf(stderr, "Using GUARANTEED service.\n");
                break;
            case 'e':
                g_params.ForceShape = TRUE;
              	break;
            case 'W':
                g_params.Wait = FALSE;
                break;
            case 't':
                trans = 1;
                break;
            case 'f':
                strcpy(Name,&argv[0][2]);
                break;
            case 'F':
                strcpy(Name,&argv[0][2]);
                g_params.ConvertOnly = TRUE;
              	break;
            case 'A':
                strcpy(Name,&argv[0][2]);
                g_params.AggregateStats = TRUE;
                break;
            case 'r':
                trans = 0;
                break;
            case 'n':
                g_params.nbuf = (INT)strtod(&argv[0][2],&stopstring);
                if (*stopstring == 0) { // normal run
                    g_params.nBufUnspecified = FALSE;
                    break;
                }
                if (*stopstring == 'i') { // run for an infinite time
                    g_params.RunForever = TRUE;
                    break;
                }
                if (*stopstring == 's') { // run for a specified time
                    g_params.TimedRun = TRUE;
                    printf("Running for %d seconds\n",g_params.nbuf);
                    break;
                }
                else {
                    Usage();
                    break;
                }
            case 'c':
                g_params.calibration = atoi(&argv[0][2]);
                break;
		    case 'k':
		        g_params.SkewFitMode = atoi(&argv[0][2]);
		        if (g_params.SkewFitMode < 0 || g_params.SkewFitMode > 3)
		            ErrorExit("Invalid Skew Fit Mode",g_params.SkewFitMode);
		        break;
            case 'l':
                g_params.buflen = atoi(&argv[0][2]);
                break;
            case 'p':

                port = (short)atoi(&argv[0][2]);


                break;
            case 'd':
                g_params.Dummy = TRUE;
                break;
            case 'N':
                normalize = 1;
                break;
            case 'P':
                g_params.PrintDrops = TRUE;
                break;
			case 'v':
			    g_params.RESVonly = TRUE;
				break;
			case 'y':
				g_params.SkipConfirm = TRUE;
				break;
			case 'u':
			    g_params.UserStamps = TRUE;
			    break;
			case 'i':
			    g_params.RandomFiller = FALSE;
			    break;
			case 'q':
                g_params.LoggingPeriod = atoi(&argv[0][2]);
			    break;
            default:
                Usage();
        }
        argv++; 
        argc--;
    }

	//
	// Make an ioctl to Timestmp driver, if its exists about the 
	// port to timestamp on.
	//
	printf("Trying to open %s\n", DriverName);
				
    hDriver = CreateFile(DriverName,
                         GENERIC_READ | GENERIC_WRITE, 
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         0,                     // Default security
                         OPEN_EXISTING,
                         0,  
                         0);                    // No template
   	if(hDriver == INVALID_HANDLE_VALUE) {
	            
		printf("Timestmp.sys CreateFile- Error %ld - Maybe its not INSTALLED\n", GetLastError());
		// Otherwise, print success and close the driver
		
	} else {

       	printf("Timestmp.sys - CreateFile Success.\n");

		b = DeviceIoControl(
					  		hDriver,              			// handle to a device, file, or directory 
							IOCTL_TIMESTMP_REGISTER_PORT,   // control code of operation to perform
							&port,                          // pointer to buffer to supply input data
							2, //nInBufferSize,         	// size, in bytes, of input buffer
							NULL, //lpOutBuffer,            // pointer to buffer to receive output data
							0, //nOutBufferSize,        	// size, in bytes, of output buffer
							&bytesreturned, 				// pointer to variable to receive byte count
                            NULL                            // pointer to overlapped structure
							);

		printf("IOCTL performed\n");
		
		if (!b) {

			printf("IOCTL FAILED!\n", GetLastError());
          	// Close the driver
           	CloseHandle(hDriver);
    	            	
		} else {
			printf("IOCTL succeeded!\n");
		}
   	}
	
    // get the host address if we're the sender
    if(trans)  {
        if(argc != 1)
            Usage();
        host = malloc(strlen(argv[0]) + 1);
        strcpy(host,argv[0]);
    }
        
	// first, we see if this is a conversion -- if it is, just jump right in, else go on
	if (g_params.ConvertOnly) {
		DoStatsFromFile();
		exit(0);
	}

    // see if we're supposed to do stat aggregation
    if (g_params.AggregateStats) {
        AggregateStats();
        exit(0);
    }
    
    // Do argument sanity tests & set default values if not already set
    if (!GoodParams()) exit(1); 

    // Spawn off the control socket monitor thread
    CreateThread(NULL, 0, ControlSocketMonitor, (LPVOID)host, 0, NULL);

    // Get the sockets ready, set for QoS, and wait for a connection
    SetupSockets();

    // Check for a RESV only session
	if (g_params.RESVonly) {  // keep socket open and hang out
		fprintf(stdout, "RSVP connection established. Press return to quit.\n");
		while(TRUE){
			if(getchar())
				break;
		}
		exit(0);
	}

    // start up the RSVPMonitor and keyboard monitor threads to watch for wackiness
    hRSVPMonitor = CreateThread(NULL,0,RSVPMonitor,NULL,0,&idRSVPMonitor);
    CreateThread(NULL,0,KeyboardMonitor,NULL,0,NULL);

    // wait for the control channel to be set up, if it's not already
    while (g_sockControl == INVALID_SOCKET) Sleep(50);

    if (!trans) { // we want to make sure these are not initialized, so we don't put wrong values in .sta
        g_params.buflen = 0;
        g_params.nbuf = 2048; // it's ok to init this because it's not saved in .sta
        g_params.TokenRate = 0;
    }
    
    totalBuffers = g_params.nbuf + g_params.calibration;
    // Tell the receiver the important parameters
    if (trans) {
        if (g_params.RunForever) totalBuffers = 2048;
        sprintf(szBuf, "%s %d", MSGST_NUM, totalBuffers);
        SendControlMessage(g_sockControl, szBuf);
        sprintf(szBuf, "%s %d", MSGST_SIZE, g_params.buflen);
        SendControlMessage(g_sockControl, szBuf);
        if (g_params.RateInBytes) sprintf(szBuf, "%s %d", MSGST_RATE, g_params.TokenRate);
        else sprintf(szBuf, "%s %d", MSGST_RATE, 1000 * g_params.TokenRate);
        SendControlMessage(g_sockControl, szBuf);
    }

    while (!g_fReadyForXmit) Sleep(50);
    
    // If we're the receiver, set up the log buffer and files
    if((Name != NULL) && !trans){
        SetupLogs();
    }

    // Let the user know what's up
    if(trans){
        fprintf(stdout, "qtcp TRANSMITTER\n");
        if (g_params.calibration)
            fprintf(stdout, "\tSending %d calibration buffers.\n", g_params.calibration);
        fprintf(stdout, "\tSending %d buffers of length %d.\n", g_params.nbuf, g_params.buflen);
        fprintf(stdout, "\tDestination address (port) is %s (%d).\n", argv[0], port);
        if (g_params.RateInBytes)
            fprintf(stdout, "\tToken rate is %d bytes/sec.\n", g_params.TokenRate);
        else
            fprintf(stdout, "\tToken rate is %d Kbytes/sec.\n", g_params.TokenRate);
        fprintf(stdout, "\tBucket size is %d bytes.\n", g_params.BucketSize);
    }
    else{
        fprintf(stdout, "qtcp RECEIVER\n");
        if (g_params.calibration)
            fprintf(stdout, "\tPrepared to receive %d calibration buffers.\n", g_params.calibration);
        if (!g_params.nBufUnspecified) {
            fprintf(stdout, "\tPrepared to receive %d buffers.\n", g_params.nbuf); 
        }
    }
    
    // Do the actual communication
    time0 = GetUserTime();
    
    if (trans)
        DoTransmit();
    else
        DoReceive();
        
    time1 = GetUserTime();
    timeElapsed = (time1 - time0)/10000;

    // tell the other guy we're done
    SendControlMessage(g_sockControl, MSGST_DONE);
    
    // get to a new line
    printf("\n");

    // put some stats on the transmitter console
    if (trans) {
        printf("Sent %ld bytes in %I64d milliseconds = %I64d KBps\n", 
            g_state.nBytesTransferred, timeElapsed, g_state.nBytesTransferred/timeElapsed);
    }

    // wait for the other side to tell us it's done.
    while (!g_fOtherSideFinished) Sleep(50);
    
    // let the user know if timestmp.sys was installed
    if (g_params.NoSenderTimestamps && g_params.NoReceiverTimestamps)
        printf("WARNING: No kernel-level timestamps detected on sender or receiver\n\tUsing user-mode timestamps.\n");
    else if (g_params.NoSenderTimestamps)
        printf("WARNING: No kernel-level timestamps detected on sender\n\tUsing user-mode timestamps.\n");
    else if (g_params.NoReceiverTimestamps)
        printf("WARNING: No kernel-level timestamps detected on receiver\n         Using user-mode timestamps.\n");
    

    // Close down the sockets
    if (closesocket((SOCKET)g_params.hSocket) != 0)
        fprintf(stderr,"closesocket failed: %d\n",WSAGetLastError());

    if(timeElapsed <= 100){
        fprintf(stdout,
                "qtcp %s:Time interval too short for valid measurement!\n",
                trans?"-t":"-r");
    }

    // Close files & exit
    if(!trans && Name != NULL){
        if (g_log.nBuffersLogged) {
            DoStats();
        } else {
            printf("ERROR: no buffers logged due to errors.\n");
        }
        CloseHandle(hRawFile);
        CloseHandle(hLogFile);
        CloseHandle(hStatFile);
        DestroyLog(&g_log);
    }
    
    if (WSACleanup() != 0)
        fprintf(stderr,"WSACleanup failed: %d\n",WSAGetLastError());
        
    printf("\n");
    _exit(0);
}  // main()

VOID SetDefaults()
{
    g_params.hSocket = NULL;
    g_params.TokenRate = 100;
    g_params.MaxSDUSize = QOS_NOT_SPECIFIED;
    g_params.BucketSize = QOS_NOT_SPECIFIED;
    g_params.MinPolicedSize = QOS_NOT_SPECIFIED;
    g_params.dwServiceType = SERVICETYPE_GUARANTEED;
    g_params.szServiceType = "GR";
    g_params.buflen = 1472;              /* length of buffer */
    g_params.nbuf = 2 * 1024;            /* number of buffers to send */
    g_params.calibration = 0;
    g_params.UserStamps = FALSE;  // By default, we use kernel mode timestamping, if available
    g_params.SkipConfirm = FALSE; // By default, we wait for user confirmation at certain times
    g_params.SkewFitMode = 2;     // by default, we use absolute deviation
    g_params.Wait = TRUE;         // By default, we wait for a QoS reservation
    g_params.Dummy = FALSE;       // insert dummy rows in log by default
    g_params.PrintDrops = FALSE;   // report dropped packets on console
    g_params.ForceShape = FALSE;  // by default, we do not force shaping on CL flows
    g_params.RateInBytes = FALSE; // KB by default
    g_params.ConvertOnly = FALSE; // by default, we act normally and do not go around converting files
    g_params.AggregateStats = FALSE;
    g_params.NoSenderTimestamps = FALSE;
    g_params.NoReceiverTimestamps = FALSE;
    g_params.TimedRun = FALSE;    // by default, we run for a number of packets
    g_params.RunForever = FALSE;  // by default, we run fora  number of packets
    g_params.nBufUnspecified = TRUE;
    g_params.RandomFiller = TRUE; // by default, we use random filler to prevent compression
    g_params.LoggingPeriod = 1;
} // SetDefaults()

VOID Usage()
{
    fprintf(stderr,"Usage: qtcp [-options] -t host\n");
    fprintf(stderr,"       qtcp [-options] -r\n");
    fprintf(stderr," -t options:\n");
    fprintf(stderr,"        -B##    TokenBucket size signaled to network and to traffic control\n"); 
    fprintf(stderr,"                (default is equal to buffer size)\n");
    fprintf(stderr,"        -m##    MinPolicedSize signaled to network and to traffic control\n");
    fprintf(stderr,"                (default is equal to buffer size)\n");
    fprintf(stderr,"        -R##    TokenRate in kilobytes per second (default is 100 KBPS)\n");
    fprintf(stderr,"        -R##B   TokenRate in bytes per second\n");
    fprintf(stderr,"        -e      Force shaping to TokenRate.\n");
    fprintf(stderr,"        -M      MaxSDUSize to be used in signaling messages (default is buffer\n");
    fprintf(stderr,"                size\n");
    fprintf(stderr,"        -l##    length of buffers to transmit (default is 1472 bytes)\n");
    fprintf(stderr,"        -n##    number of source bufs written to network (default is 2048 bytes)\n");
    fprintf(stderr,"        -n##s   numbef of seconds to send buffers for (numbef of buffers will\n");
    fprintf(stderr,"                be calculated based on other parameters\n");
    fprintf(stderr,"        -ni     run indefinitely (will stop when 'q' is pressed on either)\n");
    fprintf(stderr,"        -c##    Specifies number of calibration packets to be sent\n");
    fprintf(stderr,"                Calibration packets will be sent immediately\n"); 
    fprintf(stderr,"                After calibration packets are sent, n additional\n");
    fprintf(stderr,"                packets will be sent. This option is useful if you want to\n");
    fprintf(stderr,"                change network conditions after a set calibration phase\n");
	fprintf(stderr,"        -y      skip confirmation message after calibration phase\n");
    fprintf(stderr,"        -p##    port number to send to or listen at (default 5003)\n");
    fprintf(stderr,"        -i      use more compressible buffer data\n");
    fprintf(stderr," -r options:\n");
    fprintf(stderr,"        -f\"filename\"    Name prefix to be used in generating log file and\n");
    fprintf(stderr,"                statistics summary. (no file generated by default)\n");
    fprintf(stderr,"        -c##    Specifies number of buffers to use in clock-skew calibration\n");
	fprintf(stderr,"        -k0     do not calculate clock skew\n");
	fprintf(stderr,"        -k1     use chi squared as goodness of fit\n");
	fprintf(stderr,"        -k2     use absolute deviation as goodness of fit (default)\n");
	fprintf(stderr,"        -k3     use abs dev and check for clock jumps\n");
    fprintf(stderr,"        -d      suppress insertion of dummy log records for lost packets.\n");
    fprintf(stderr,"        -N      Normalize before dumping raw file (default is after)\n");
    fprintf(stderr,"        -P      enables console reporting of dropped packets\n");
    fprintf(stderr,"        -u      use user mode timestamps instead of kernel timestamps in logs\n");
    fprintf(stderr,"        -q##    log only every ##th packet\n");
    fprintf(stderr," common options:\n");
    fprintf(stderr,"        -S\"service type\" (CL or GR -- GR is default)\n");
    fprintf(stderr,"        -W      Suppress waiting for QoS reservation\n");
	fprintf(stderr,"        -v      Set up QoS reservation only, send no data\n");
    fprintf(stderr,"        -F\"filename\"  Name prefix of raw file to be converted to log file\n");
    fprintf(stderr,"        -A\"path\"      Path to directory for aggregate statistics computation\n");

    WSACleanup();
    exit(1);
} // Usage()

BOOLEAN GoodParams()
{          
    BOOLEAN ok = TRUE;
    
    if(g_params.buflen < sizeof(BUFFER_FORMAT)){
        printf("Buffer size too small for record!\n");
        ok = FALSE;
    }

    // Unless otherwise specified, min policed size will be equal to 
    // buflen.
    
    if(g_params.MinPolicedSize == QOS_NOT_SPECIFIED){
        g_params.MinPolicedSize = g_params.buflen;
    }
    
    // Same goes for bucket size
    
    if(g_params.BucketSize == QOS_NOT_SPECIFIED){
        g_params.BucketSize = g_params.buflen;
    }

    // And for MaxSDU
    
    if(g_params.MaxSDUSize == QOS_NOT_SPECIFIED){
        g_params.MaxSDUSize = g_params.buflen;
    }

    // If the bucket size is smaller than the buffer size,
    // and this is a sender, then warn the user because 
    // data will be discarded
    
    if((g_params.BucketSize < g_params.buflen) && trans){
        printf("Token bucket size is smaller than buffer size!\n");
        ok = FALSE;
    }

    if(g_params.MaxSDUSize < g_params.buflen){
        printf("MaxSDU cannot be less than buffer size!\n");
        ok = FALSE;
    }

    if(g_params.buflen < 5){
        g_params.buflen = 5;   // send more than the sentinel size
    }

    if(g_params.TimedRun) {
        if (g_params.RateInBytes)
            g_params.nbuf = g_params.nbuf * g_params.TokenRate / g_params.buflen;
        else
            g_params.nbuf = g_params.nbuf * g_params.TokenRate * 1000 / g_params.buflen;
        printf("Using %d buffers\n",g_params.nbuf);
    }

    return ok;
} // GoodParams()

VOID SetupLogs()
{
    CreateLog(&g_log, totalBuffers);

    // set up logging files
    if(ERROR_SUCCESS != MyCreateFile(Name,".raw",&hRawFile)){
        fprintf(stderr, "WARNING: Could not create raw file.\n");
    } 
    
    if(ERROR_SUCCESS == MyCreateFile(Name,".log", &hLogFile)){
        fprintf(stdout,"Logging per-packet data to %s.log.\n",Name);
    }
    else{
        fprintf(stderr, "WARNING: Could not create log file.\n");
    }

    if(ERROR_SUCCESS == MyCreateFile(Name, ".sta", &hStatFile)){
        fprintf(stdout,"Writing statistics sumary to %s.sta\n",Name);
    }
    else{
        fprintf(stderr,"Could not create statistics file.\n");
    }
} // SetupLogs()

VOID SetupSockets() 
{
    struct hostent *addr;
    ULONG addr_tmp;
    char szAddr[MAX_STRING];
    int dwAddrSize, dwError;

        
    // Set address and port parameters 
    if(trans)  {
        bzero((char *)&sinhim, sizeof(sinhim));
        if (atoi(host) > 0 )  {
            sinhim.sin_family = AF_INET;
            sinhim.sin_addr.s_addr = inet_addr(host);
        } 
        else{
            if ((addr=gethostbyname(host)) == NULL){
                printf("ERROR: bad hostname\n");
                WSACleanup();
                exit(1);
            }
            sinhim.sin_family = addr->h_addrtype;
            bcopy(addr->h_addr,(char*)&addr_tmp, addr->h_length);
            sinhim.sin_addr.s_addr = addr_tmp;
        }

        sinhim.sin_port = htons(port);
        sinme.sin_port = 0;             /* free choice */
    } 
    else{
        sinme.sin_port =  htons(port);
    }

    sinme.sin_family = AF_INET;

    // Open socket for QoS traffic
    fd = OpenQoSSocket();

    if((fd == (UINT_PTR)NULL) || (fd == INVALID_SOCKET)){
        fprintf(stderr,"Failed to open QoS socket!\n");
        exit(1);
    }

    // Prepare to get QoS notifications

    if((QoSEvents = WSACreateEvent()) == WSA_INVALID_EVENT){
        fprintf(stderr,
                "Failed to create an event for QoS notifications %ld\n",
                WSAGetLastError());
        exit(1);
    }

    if(WSAEventSelect(fd, QoSEvents, FD_QOS) == SOCKET_ERROR){
        fprintf(stderr,
                "Unable to get notifications for QoS events. %ld\n",
                WSAGetLastError());
    }

    if(trans){
        // Set QoS on sending traffic
        if(SetQoSSocket(fd, TRUE)){
            exit(1);
        }

        fprintf(stdout, "Initiated QoS connection. Waiting for receiver.\n");

        WaitForQoS(SENDER, fd);
    }
    else{ // we're the receiver, so bind and wait
        if(bind(fd, (PSOCKADDR)&sinme, sizeof(sinme)) < 0){
            printf("bind() failed: %ld\n", GetLastError( ));
        }

        if(SetQoSSocket(fd, FALSE)){
            exit(1);
        }

        fprintf(stdout, "Waiting for QoS sender to initiate QoS connection.\n");

        WaitForQoS(RECEIVER, fd);
    }

    // set some options
    // none to set!

    g_params.hSocket = (HANDLE)fd;
} // SetupSockets()

SOCKET 
OpenQoSSocket(
    )
{
    INT bufferSize = 0;
    INT numProtocols;
    LPWSAPROTOCOL_INFO installedProtocols, qosProtocol; 
    INT i;
    SOCKET fd;
    BOOLEAN QoSInstalled = FALSE;

    // Call WSAEnumProtocols to determine buffer size required

    numProtocols = WSAEnumProtocols(NULL, NULL, &bufferSize);

    if((numProtocols != SOCKET_ERROR) && (WSAGetLastError() != WSAENOBUFS)){
        printf("Failed to enumerate protocols!\n");
        return((UINT_PTR)NULL);
    }
    else{
        // Enumerate the protocols, find the QoS enabled one

        installedProtocols = (LPWSAPROTOCOL_INFO)malloc(bufferSize);

        numProtocols = WSAEnumProtocols(NULL,
                                        (LPVOID)installedProtocols,
                                        &bufferSize);

        if(numProtocols == SOCKET_ERROR){
            printf("Failed to enumerate protocols!\n");
            return((UINT_PTR)NULL);
        }
        else{
            qosProtocol = installedProtocols;

            for(i=0; i<numProtocols; i++){
                if((qosProtocol->dwServiceFlags1 & XP1_QOS_SUPPORTED)&&
                   (qosProtocol->dwServiceFlags1 & XP1_CONNECTIONLESS) &&
                   (qosProtocol->iAddressFamily == AF_INET)){
                        QoSInstalled = TRUE;
                        break;
                }
                qosProtocol++;
            }
        }

        // Now open the socket.

        if (!QoSInstalled) {
            fprintf(stderr,"ERROR: No QoS protocols installed on this machine\n");
            exit(1);
        }

        fd = WSASocket(0, 
                       SOCK_DGRAM, 
                       0, 
                       qosProtocol, 
                       0, 
                       WSA_FLAG_OVERLAPPED);

        free(installedProtocols);

        return(fd);
    }
}  // OpenQoSSocket()

INT
SetQoSSocket(
    SOCKET fd,
    BOOL Sending)
{
    QOS qos;
    INT status;
    LPFLOWSPEC flowSpec;
    INT dummy;

    INT receiverServiceType = Sending?
                              SERVICETYPE_NOTRAFFIC:
                              g_params.dwServiceType;

    qos.ProviderSpecific.len = 0;
    qos.ProviderSpecific.buf = 0;

    // receiving flowspec is either NO_TRAFFIC (on a sender) or all
    // defaults except for the service type (on a receiver)

    flowSpec = &qos.ReceivingFlowspec;

    flowSpec->TokenRate = QOS_NOT_SPECIFIED;
    flowSpec->TokenBucketSize = QOS_NOT_SPECIFIED;
    flowSpec->PeakBandwidth = QOS_NOT_SPECIFIED;
    flowSpec->Latency = QOS_NOT_SPECIFIED;
    flowSpec->DelayVariation = QOS_NOT_SPECIFIED;
    flowSpec->ServiceType = receiverServiceType;
    flowSpec->MaxSduSize = QOS_NOT_SPECIFIED;
    flowSpec->MinimumPolicedSize = QOS_NOT_SPECIFIED;

    // now do the sending flowspec

    flowSpec = &qos.SendingFlowspec;

    if(Sending){
        if (g_params.RateInBytes)
            flowSpec->TokenRate = g_params.TokenRate;
        else
            flowSpec->TokenRate = g_params.TokenRate * 1000;
        flowSpec->TokenBucketSize = g_params.BucketSize; 
        

        if (g_params.ForceShape) {
            if (g_params.RateInBytes)
                flowSpec->PeakBandwidth = g_params.TokenRate;
    	    else
    	        flowSpec->PeakBandwidth = g_params.TokenRate * 1000;
    	}
        else 
	        flowSpec->PeakBandwidth = QOS_NOT_SPECIFIED;
        flowSpec->Latency = QOS_NOT_SPECIFIED;
        flowSpec->DelayVariation = QOS_NOT_SPECIFIED;
        flowSpec->ServiceType = g_params.dwServiceType;
        
        if (g_params.ForceShape && flowSpec->ServiceType == SERVICETYPE_BESTEFFORT )
            flowSpec->ServiceType = SERVICETYPE_GUARANTEED | SERVICE_NO_QOS_SIGNALING;

        flowSpec->MaxSduSize = g_params.MaxSDUSize;
        flowSpec->MinimumPolicedSize = g_params.MinPolicedSize;

        printf("Sending Flowspec\n");
        PrintFlowspec(&qos.SendingFlowspec);
        
        status = WSAConnect(fd,
                            (PSOCKADDR)&sinhim,
                            sizeof(sinhim),
                            NULL,
                            NULL,
                            &qos,
                            NULL);
        if(status){
            printf("SetQoS failed on socket: %ld\n", WSAGetLastError());
        }
    }
    else{
        flowSpec->TokenRate = QOS_NOT_SPECIFIED;
        flowSpec->TokenBucketSize = QOS_NOT_SPECIFIED;
        flowSpec->PeakBandwidth = QOS_NOT_SPECIFIED;
        flowSpec->Latency = QOS_NOT_SPECIFIED;
        flowSpec->DelayVariation = QOS_NOT_SPECIFIED;
        flowSpec->ServiceType = SERVICETYPE_NOTRAFFIC;
        flowSpec->MaxSduSize = QOS_NOT_SPECIFIED;
        flowSpec->MinimumPolicedSize = QOS_NOT_SPECIFIED;

        status = WSAIoctl(fd,
                          SIO_SET_QOS,
                          &qos,
                          sizeof(QOS),
                          NULL,
                          0,
                          &dummy,
                          NULL,
                          NULL);
        if(status){
            printf("SetQoS failed on socket: %ld\n", WSAGetLastError());
        }
    }
    
    return(status);
} // SetQoSSocket()
   
VOID
WaitForQoS(
    BOOL Sender,
    SOCKET fd)
{
    ULONG status;

    if(!g_params.Wait){
        // For best effort, we don't do anything QoS... Return
        // right away. In this case, the sender should be started
        // after the reciever, since there is no synchronization
        // via rsvp and data could be missed.

        fprintf(stdout, "WARNING: Not waiting for QoS reservation.\n");
        return;
    }
        
    while(TRUE){
        // get the statuscode, waiting for as long as it takes
        status = GetRsvpStatus(WSA_INFINITE,fd);

        switch (status) {
            case WSA_QOS_RECEIVERS:      // at least one RESV has arrived 
                if (Sender)
                    fprintf(stdout, "QoS reservation installed for %s service.\n", g_params.szServiceType);
                break;
            case WSA_QOS_SENDERS:        // at least one PATH has arrived 
                if (!Sender)
                    fprintf(stdout, "QoS sender detected using %s service.\n", g_params.szServiceType);
                break;
            default:
                PrintRSVPStatus(status);
                break;
        }

        // if we received one of the coveted status codes, break out
        // altogether. otherwise wait and see if we get another batch
        // of indications.
        if( ((status == WSA_QOS_RECEIVERS) && Sender) ||
            ((status == WSA_QOS_SENDERS) && !Sender) ) {
            break;
        }
    }
} // WaitForQoS()

ULONG
GetRsvpStatus(
    DWORD dwTimeout,
    SOCKET fd)
{
    LPQOS   qos;
    UCHAR   qosBuffer[500];
    LPRSVP_STATUS_INFO rsvpStatus;
    INT bytesReturned;
    
    qos = (LPQOS)qosBuffer;
    qos->ProviderSpecific.len = sizeof(RSVP_STATUS_INFO);
    qos->ProviderSpecific.buf = (PUCHAR)(qos+1);
    
    // wait for notification that a QoS event has occured
    WSAWaitForMultipleEvents(1,
                            &QoSEvents,
                            FALSE,
                            dwTimeout,
                            TRUE);

    // loop through all qos events
    WSAIoctl(fd,
             SIO_GET_QOS,
             NULL,
             0,
             qosBuffer,
             sizeof(qosBuffer),
             &bytesReturned,
             NULL,
             NULL);

    rsvpStatus = (LPRSVP_STATUS_INFO)qos->ProviderSpecific.buf;
    
    return rsvpStatus->StatusCode;
} // GetRsvpStatus

VOID
PrintRSVPStatus(ULONG code) 
{    
    switch (code) {
        case WSA_QOS_RECEIVERS:             // at least one RESV has arrived 
            printf("WSA_QOS_RECEIVERS\n");
            break;
        case WSA_QOS_SENDERS:               // at least one PATH has arrived 
            printf("WSA_QOS_SENDERS\n");
            break;
        case WSA_QOS_REQUEST_CONFIRMED:     // Reserve has been confirmed
            printf("WSA_QOS_REQUEST_CONFIRMED\n"); 
            break;
        case WSA_QOS_ADMISSION_FAILURE:     // error due to lack of resources
            printf("WSA_QOS_ADMISSION_FAILURE\n"); 
            break;
        case WSA_QOS_POLICY_FAILURE:        // rejected for admin reasons
            printf("WSA_QOS_POLICY_FAILURE\n"); 
            break;
        case WSA_QOS_BAD_STYLE:             // unknown or conflicting style
            printf("WSA_QOS_BAD_STYLE\n"); 
            break;
        case WSA_QOS_BAD_OBJECT:            // problem with some part of the 
                                            // filterspec/providerspecific 
                                            // buffer in general 
            printf("WSA_QOS_BAD_OBJECT\n"); 
            break;
        case WSA_QOS_TRAFFIC_CTRL_ERROR:    // problem with some part of the 
                                            // flowspec
            printf("WSA_QOS_TRAFFIC_CTRL_ERROR\n"); 
            break;
        case WSA_QOS_GENERIC_ERROR:         // general error 
            printf("WSA_QOS_GENERIC_ERROR\n");
            break;
        default:
            printf("Unknown RSVP StatusCode %lu\n", code); 
            break;
    }
} // PrintRSVPStatus


VOID
DoTransmit()
{
    IOREQ IOReq[MAX_PENDING_IO_REQS] = { 0 };
    INT i;
    BOOL ret;
    BOOL fOk;

    g_state.nBytesTransferred = 0;
    g_state.nBuffersSent = 0;
    g_state.nWritesInProgress = 0;

    // fill up the initial buffers and send them on their way    
    for (i=0; i<MAX_PENDING_IO_REQS; i++) {
        IOReq[i].pBuffer = malloc(g_params.buflen);
        FillBuffer(IOReq[i].pBuffer,g_params.buflen);
        TimeStamp(IOReq[i].pBuffer,g_params.buflen);
        IOReq[i].Overlapped.Internal = 0;
        IOReq[i].Overlapped.InternalHigh = 0;
        IOReq[i].Overlapped.Offset = 0;
        IOReq[i].Overlapped.OffsetHigh = 0;
        IOReq[i].Overlapped.hEvent = NULL;

        if (g_state.nBuffersSent < totalBuffers) {
            WriteFileEx(g_params.hSocket,
                        IOReq[i].pBuffer,
                        g_params.buflen,
                        &IOReq[i].Overlapped,
                        TransmitCompletionRoutine);

            g_state.nWritesInProgress++;
            g_state.nBuffersSent++;
        }
    } 

    // now loop until an error happens or we're done writing to the socket
    while (g_state.nWritesInProgress > 0) {
        SleepEx(INFINITE, TRUE);
    }

    // send the end of transmission delimiters
    for (i=0; i<MAX_PENDING_IO_REQS; i++) {
        strncpy(IOReq[i].pBuffer,TheEnd,strlen(TheEnd));
        fOk = WriteFileEx(g_params.hSocket,
                    IOReq[i].pBuffer,
                    strlen(TheEnd),
                    &IOReq[i].Overlapped,
                    DelimiterSendCompletion);
        g_state.nWritesInProgress++;

        if (!fOk) {
            printf("WriteFileEx() failed: %lu\n",GetLastError());
        }

    }

    // wait for all the delimiters to be sent
    while (g_state.nWritesInProgress > 0) {
        SleepEx(INFINITE, TRUE);
    }

    // free up the used memory
    for (i=0; i<MAX_PENDING_IO_REQS; i++) {
        free(IOReq[i].pBuffer);
    }
} // DoTransmit()

VOID WINAPI
TransmitCompletionRoutine(
    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransferred,
    LPOVERLAPPED pOverlapped)
{
    PIOREQ pIOReq = (PIOREQ) pOverlapped;
    BOOL fOk;
    
    if (dwErrorCode == ERROR_REQUEST_ABORTED) {
        g_state.Done = TRUE;
    }
    else if (dwErrorCode != NO_ERROR) {
        printf("ERROR: Write completed abnormally: %u\n",dwErrorCode);
    }

    g_state.nWritesInProgress--;
    g_state.nBytesTransferred += dwNumberOfBytesTransferred;

    // check to make sure we're not done
    if (g_state.Done)
        return;

    // give some indication of life
    if(!(g_state.nBuffersSent % 100)){
        fprintf(stdout, ".");
    }

    // if there are more buffers to go, send one
    if (g_state.nBuffersSent < totalBuffers || g_params.RunForever) {
    
        // see if this was the last of the calibration buffers (if we want confirmation)
        if (g_params.SkipConfirm == FALSE) {
            if (g_params.calibration && (g_state.nBuffersSent == g_params.calibration)) {
                printf("\nCalibration complete. Type 'c' to continue.\n");
                while(TRUE){
                    if(getchar() == 'c'){
                        break;
                    }
                }
            }
        }
    
        // fill in the buffer with new values
        FillBuffer(pIOReq->pBuffer,g_params.buflen);
        TimeStamp(pIOReq->pBuffer,g_params.buflen);

        // send a request to write the new buffer
        fOk = WriteFileEx(g_params.hSocket,
                    pIOReq->pBuffer,
                    g_params.buflen,
                    pOverlapped,
                    TransmitCompletionRoutine);

        if (!fOk) {
            printf("WriteFileEx() failed: %lu\n",GetLastError());
        }

        g_state.nWritesInProgress++;
        g_state.nBuffersSent++;
    }
} // TransmitCompletionRoutine()

VOID WINAPI
DelimiterSendCompletion(
    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransferred,
    LPOVERLAPPED pOverlapped)
{
    g_state.nWritesInProgress--;
} // DelimiterSendCompletion()

VOID
FillBuffer(
    CHAR *Cp,
    INT   Cnt)
{
    PBUFFER_FORMAT buf = (PBUFFER_FORMAT) Cp;
    CHAR c = 0;
    
    // Fill with a background pattern
    if (g_params.RandomFiller) { // incompressible
        while(Cnt-- > 0) {
            c = rand() % 0x5F;
            c += 0x20;
            *Cp++ = c;
        }
    }
    else { // compressible
        while(Cnt-- > 0){
            while(!isprint((c&0x7F))) c++;
            *Cp++ = (c++&0x7F);
        }
    }

    buf->TimeSent = -1;
    buf->TimeReceived = -1;
} // FillBuffer()

INT
TimeStamp(
    CHAR *Cp, 
    INT   Cnt)
{
    PBUFFER_FORMAT record;
    LARGE_INTEGER timeSent;
    INT64 time;

    record = (BUFFER_FORMAT *)Cp;
        
    // Stamp with length and sequence number
    
    if(Cnt < sizeof(BUFFER_FORMAT)){
        printf("ERROR: Buffer length smaller than record size!\n");
        return(0);
    }
    else{
        time = GetUserTime();
        record->TimeSentUser = time;
        record->BufferSize = Cnt;
        record->SequenceNumber = SequenceNumber++;
    }
    return 1;
} // TimeStamp()

VOID
DoReceive()
{
    IOREQ IOReq[MAX_PENDING_IO_REQS] = { 0 };
    INT i;
    BOOL ret;
    
    // set the start state
    g_state.Done = FALSE;
    g_state.nBytesTransferred = 0;
    g_state.nBuffersReceived = 0;
    g_state.nReadsInProgress = 0;

    // fill up the initial buffers and send them on their way    
    for (i=0; i<MAX_PENDING_IO_REQS; i++) {
        IOReq[i].pBuffer = malloc(g_params.buflen);
        
        IOReq[i].Overlapped.Internal = 0;
        IOReq[i].Overlapped.InternalHigh = 0;
        IOReq[i].Overlapped.Offset = 0;
        IOReq[i].Overlapped.OffsetHigh = 0;
        IOReq[i].Overlapped.hEvent = NULL;

        if (g_state.nBuffersReceived < totalBuffers) {
            ReadFileEx(g_params.hSocket,
                       IOReq[i].pBuffer,
                       g_params.buflen,
                       &IOReq[i].Overlapped,
                       RecvCompletionRoutine);

            g_state.nReadsInProgress++;
        }
    }

    InitializeCriticalSection(&g_csLogRecord);

    // now loop until an error happens or we're done writing to the socket
    while ((g_state.nReadsInProgress > 0) && !g_state.Done) {
        SleepEx(5000, TRUE);
        if (g_state.Done)
            break;
    }
    DeleteCriticalSection(&g_csLogRecord);

    // cancel the other pending reads
    CancelIo(g_params.hSocket);

    // free up the used memory
    for (i=0; i<MAX_PENDING_IO_REQS; i++) {
        free(IOReq[i].pBuffer);
    }
} // DoReceive()

VOID WINAPI
RecvCompletionRoutine(
    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransferred,
    LPOVERLAPPED pOverlapped)
{
    PIOREQ pIOReq = (PIOREQ) pOverlapped;
    BOOL fOk;
    static BOOL fLastWasError = FALSE;

    g_state.nReadsInProgress--;
    g_state.nBytesTransferred += dwNumberOfBytesTransferred;

    if (dwNumberOfBytesTransferred == 0) { // an error occurred
        if (!fLastWasError) {
            printf("ERROR in RecvCompletionRoutine: code=%d, lasterr=%d\n",
                dwErrorCode, GetLastError());
            printf("\tReceived no data. Telling sender to abort...\n");
            SendControlMessage(g_sockControl, MSGST_ERROR);
        }
        fLastWasError = TRUE;
    }
    else fLastWasError = FALSE;

    // if this is the first packet we've received, save the system time
    if (g_state.nBuffersReceived == 0) {
        GetSystemTime(&systimeStart);
    }

    // give some indication of life
    if(!(g_state.nBuffersReceived % 100)){
        fprintf(stdout, ".");
    }

    // end of transmission delimiter? if so, set the total buffers to the number got
    if(!(strncmp(pIOReq->pBuffer, TheEnd, 6))) {
        totalBuffers = g_state.nBuffersReceived;
        g_state.Done = TRUE;
    }

    // check to see if someone's set our done flag (if they have, leave)
    if (g_state.Done)
        return;

    // if not, then the buffer should hold a scheduling record.
    if(dwNumberOfBytesTransferred>0 && dwNumberOfBytesTransferred <= sizeof(BUFFER_FORMAT)) {
        printf("Buffer too small for scheduling record\n");
        printf("\tOnly %d bytes read.\n", dwNumberOfBytesTransferred);
    }

    // Log the record, but don't log more than one at a time (lock on this call)
    if (dwNumberOfBytesTransferred >= sizeof(BUFFER_FORMAT) && 
            g_state.nBuffersReceived % g_params.LoggingPeriod == 0) {
        EnterCriticalSection(&g_csLogRecord);
        LogRecord(pIOReq->pBuffer);
        LeaveCriticalSection(&g_csLogRecord);
    }

    // if there are more buffers (or if we don't know how many are coming), ask for one
    if ((g_state.nBuffersReceived < totalBuffers) || g_params.nBufUnspecified) {        
        // send a request to read the next buffer
        fOk = ReadFileEx(g_params.hSocket,
                   pIOReq->pBuffer,
                   g_params.buflen,
                   pOverlapped,
                   RecvCompletionRoutine);

        if (!fOk) {
            printf("ReadFileEx() failed: %lu\n",GetLastError());
        }
        
        g_state.nReadsInProgress++;
        g_state.nBuffersReceived++;
    }
} // RecvCompletionRoutine()

void LogRecord(char * Buffer)
{
    // This function copies the recieved record to the scheduling array.
    // The contents of the array are processed and written to file once
    // reception is complete.
 
    PBUFFER_FORMAT inRecord = (PBUFFER_FORMAT)Buffer;
    LOG_RECORD outRecord;
    INT64 time;
    SYSTEMTIME CurrentTime;

    time = GetUserTime();

	outRecord.TimeSentUser = inRecord->TimeSentUser;
	outRecord.TimeReceivedUser = time;
    outRecord.TimeSent = inRecord->TimeSent;
    outRecord.TimeReceived = inRecord->TimeReceived;
    outRecord.BufferSize = inRecord->BufferSize;
    outRecord.SequenceNumber = inRecord->SequenceNumber;

    if (inRecord->TimeSent == -1) {
        outRecord.TimeSent = outRecord.TimeSentUser;
        g_params.NoSenderTimestamps = TRUE;
    }

    if (inRecord->TimeReceived == -1) {
        outRecord.TimeReceived = outRecord.TimeReceivedUser;
        g_params.NoReceiverTimestamps = TRUE;
    }

    if(g_params.UserStamps){
        outRecord.TimeSent = outRecord.TimeSentUser;
        outRecord.TimeReceived = outRecord.TimeReceivedUser;
    }
    outRecord.Latency = outRecord.TimeReceived - outRecord.TimeSent;

    AddLogEntry(&g_log, &outRecord);

    if(g_params.PrintDrops){
        if(inRecord->SequenceNumber != LastSequenceNumber + g_params.LoggingPeriod){
            GetLocalTime(&CurrentTime);

            printf("\n%4d/%02d/%02d %02d:%02d:%02d:%04d: ",
                    CurrentTime.wYear,
                    CurrentTime.wMonth,
                    CurrentTime.wDay,
                    CurrentTime.wHour,
                    CurrentTime.wMinute,
                    CurrentTime.wSecond,
                    CurrentTime.wMilliseconds);

            printf("Dropped %d packets after packet %d.\n",
                    inRecord->SequenceNumber - LastSequenceNumber,
                    LastSequenceNumber);
        }

        LastSequenceNumber = inRecord->SequenceNumber;
    }
    return;
} // LogRecord()

BOOL CreateLog(PLOG plog, INT64 c) {
    // sets up a log structure that can hold c entries
    char szTempFile[MAX_PATH];
    char szTempPath[MAX_PATH];
    SYSTEM_INFO si;
    DWORD dwFileSizeHigh;
    DWORD dwFileSizeLow;
    INT64 qwFileSize;

    // get some system info
    GetSystemInfo(&si);
    
    // allocate logging array
    plog->nBuffersLogged = 0;
    plog->pbMapView = NULL;
    plog->qwMapViewOffset = -1;

    // set up the temporary storage file for logging
    GetTempPath(MAX_PATH, szTempPath);
    GetTempFileName(szTempPath, "qtc", 0, szTempFile);
    plog->szStorageFile = malloc(strlen(szTempFile) + 1);
    strcpy(plog->szStorageFile, szTempFile);
    plog->hStorageFile = CreateFile(szTempFile, GENERIC_READ | GENERIC_WRITE, 0, 
        NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_TEMPORARY, NULL);
    if (plog->hStorageFile == INVALID_HANDLE_VALUE)
        ErrorExit("Could not create temp storage file",GetLastError());

    // create the memory mapping kernel object
    qwFileSize = c * sizeof(LOG_RECORD);
    dwFileSizeHigh = (DWORD) (qwFileSize >> 32);
    dwFileSizeLow = (DWORD) (qwFileSize & 0xFFFFFFFF);
    plog->qwFileSize = qwFileSize;
    plog->hFileMapping = CreateFileMapping(plog->hStorageFile, NULL, PAGE_READWRITE,
        dwFileSizeHigh,dwFileSizeLow,NULL);
    if (plog->hFileMapping == NULL)
        ErrorExit("Could not create mapping for temp storage file",GetLastError());
    
    return TRUE;
}

BOOL DestroyLog(PLOG plog) {
    DWORD dwError;
    // destroys the log and all associated data
    dwError = CloseHandle(plog->hFileMapping);
    if (!dwError) printf("Error in DestroyLog:CloseHandle(FileMapping) %d\n",GetLastError());
    dwError = CloseHandle(plog->hStorageFile);
    if (!dwError) printf("Error in DestroyLog:CloseHandle(StorageFile) %d\n",GetLastError());
    dwError = UnmapViewOfFile(plog->pbMapView);
    if (!dwError) printf("Error in DestroyLog:UnmapViewOfFile(plog->pbMapView) %d\n",GetLastError());
    dwError = DeleteFile(plog->szStorageFile);
    if (!dwError) printf("Error in DestroyLog:DeleteFile(StroageFile) %d\n",GetLastError());
    free(plog->szStorageFile);
    return FALSE;
}

void PrintLogRecord(PLOG_RECORD prec) {
    char szBuf[MAX_STRING];

    sprintf(szBuf,"%d: %I64u - %I64u (%I64d)",
        prec->SequenceNumber,prec->TimeSent,prec->TimeReceived,prec->Latency);
    puts(szBuf);
}

BOOL ExtendLog(PLOG plog) {
    // makes the log bigger by some fixed constant
    HANDLE hNewFileMapping;
    INT64 qwNewFileSize;
    
    UnmapViewOfFile(plog->pbMapView);

    qwNewFileSize = plog->qwFileSize + g_si.dwAllocationGranularity * sizeof(LOG_RECORD);
    hNewFileMapping = CreateFileMapping(plog->hStorageFile, NULL, PAGE_READWRITE,
                (DWORD)(qwNewFileSize >> 32), (DWORD)(qwNewFileSize & 0xFFFFFFFF), NULL);
    if (hNewFileMapping == NULL) {
        ErrorExit("Could not create mapping for temp storage file",GetLastError());
        return FALSE;
    }
    plog->qwFileSize = qwNewFileSize;
    CloseHandle(plog->hFileMapping);
    plog->hFileMapping = hNewFileMapping;
    plog->qwMapViewOffset = -1;
    return TRUE;
}

BOOL GetLogEntry(PLOG plog, PLOG_RECORD prec, INT64 i) {
    // fills prec with the (0 indexed) i'th log in plog
    // returns TRUE if it was successful, FALSE otherwise
    INT64 qwT;
    PLOG_RECORD entry;

    // first, check to see if this is within the range of our file
    if ((INT64)((i+1)*sizeof(LOG_RECORD)) > plog->qwFileSize) {
        // too high, so we return false
        return FALSE;
    }
    
    // we have to round down to the nearest allocation boundary
    qwT = sizeof(LOG_RECORD) * i;   // offset within file
    qwT /= g_si.dwAllocationGranularity; // in allocation granularity units

    // check to see if we do not already have this mapped in memory
    if (plog->qwMapViewOffset != qwT * g_si.dwAllocationGranularity) {
        if (plog->pbMapView != NULL) UnmapViewOfFile(plog->pbMapView);
        plog->qwMapViewOffset = qwT * g_si.dwAllocationGranularity;  // offset of lower allocation bound  
        if (plog->qwFileSize < (INT64)g_si.dwAllocationGranularity) {
            // file is smaller than allocation granularity
            plog->qwMapViewOffset = 0;
            plog->pbMapView = MapViewOfFile(plog->hFileMapping, FILE_MAP_WRITE, 0, 0, 0);
        }
        else if (plog->qwFileSize - plog->qwMapViewOffset < g_si.dwAllocationGranularity) {
            // we're within an allocation granularity of the end of the file
            plog->pbMapView = MapViewOfFile(plog->hFileMapping, FILE_MAP_WRITE,
                                (DWORD)(plog->qwMapViewOffset >> 32),
                                (DWORD)(plog->qwMapViewOffset & 0xFFFFFFFF), 
                                (DWORD)(plog->qwFileSize - plog->qwMapViewOffset));
        }
        else {
            // we're just somewhere in the file with space around us
            plog->pbMapView = MapViewOfFile(plog->hFileMapping, FILE_MAP_WRITE, 
                                (DWORD)(plog->qwMapViewOffset >> 32),
                                (DWORD)(plog->qwMapViewOffset & 0xFFFFFFFF), 
                                RoundUp(g_si.dwAllocationGranularity,sizeof(LOG_RECORD)));
        }
        if (plog->pbMapView == NULL) 
            ErrorExit("GetLogEntry could not MapViewOfFile",GetLastError());
    }
    qwT = sizeof(LOG_RECORD) * i;
    entry = (PLOG_RECORD)(plog->pbMapView + (qwT - plog->qwMapViewOffset));
    CopyMemory(prec, entry, sizeof(LOG_RECORD));
    return TRUE;
}


BOOL SetLogEntry(PLOG plog, PLOG_RECORD prec, INT64 i) {
    // fills log entry i with the data pointed to by prec
    // returns TRUE if it was successful, FALSE otherwise
    INT64 qwT;
    PLOG_RECORD entry;

    // first, check to see if this is within the range of our file
    if ((INT64)((i+1)*sizeof(LOG_RECORD)) > plog->qwFileSize) {
        // we need to make our mapping bigger
        ExtendLog(plog);
    }
    
    // we have to round down to the nearest allocation boundary
    qwT = sizeof(LOG_RECORD) * i;   // offset within file
    qwT /= g_si.dwAllocationGranularity; // in allocation granularity units

    // check to see if we do not already have this mapped in memory
    if (plog->qwMapViewOffset != qwT * g_si.dwAllocationGranularity) {
        if (plog->pbMapView != NULL) UnmapViewOfFile(plog->pbMapView);
        plog->qwMapViewOffset = qwT * g_si.dwAllocationGranularity;  // offset of lower allocation bound  
        if (plog->qwFileSize < (INT64)g_si.dwAllocationGranularity) {
            // file is smaller than allocation granularity
            plog->qwMapViewOffset = 0;
            plog->pbMapView = MapViewOfFile(plog->hFileMapping, FILE_MAP_WRITE, 0, 0, 0);
        }
        else if (plog->qwFileSize - plog->qwMapViewOffset < g_si.dwAllocationGranularity) {
            // we're within an allocation granularity of the end of the file
            plog->pbMapView = MapViewOfFile(plog->hFileMapping, FILE_MAP_WRITE,
                                (DWORD)(plog->qwMapViewOffset >> 32),
                                (DWORD)(plog->qwMapViewOffset & 0xFFFFFFFF), 
                                (DWORD)(plog->qwFileSize - plog->qwMapViewOffset));
        }
        else {
            // we're just somewhere in the file with space around us
            plog->pbMapView = MapViewOfFile(plog->hFileMapping, FILE_MAP_WRITE, 
                                (DWORD)(plog->qwMapViewOffset >> 32),
                                (DWORD)(plog->qwMapViewOffset & 0xFFFFFFFF), 
                                RoundUp(g_si.dwAllocationGranularity,sizeof(LOG_RECORD)));
        }
        if (plog->pbMapView == NULL) 
            ErrorExit("SetLogEntry could not MapViewOfFile",GetLastError());
    }
    qwT = sizeof(LOG_RECORD) * i;
    entry = (PLOG_RECORD)(plog->pbMapView + (qwT - plog->qwMapViewOffset));

    CopyMemory(entry, prec, sizeof(LOG_RECORD));
    
    return TRUE;
}

BOOL AddLogEntry(PLOG plog, PLOG_RECORD prec) {
    PLOG_RECORD entry;
    // adds the data pointed to by prec to the end of the log
    // returns TRUE if it was successful, FALSE otherwise

    SetLogEntry(plog, prec, plog->nBuffersLogged);

    plog->nBuffersLogged++;

    return TRUE;
}

UINT64
GetUserTime()
{   // This function returns the performance counter time in units of 100ns
    LARGE_INTEGER count, freq;

    NtQueryPerformanceCounter(&count,&freq);
    
    // make sure we have hardware performance counting
    if(freq.QuadPart == 0) {
        NtQuerySystemTime(&count);
        return (UINT64)count.QuadPart;
    }
   
    return (UINT64)((10000000 * count.QuadPart) / freq.QuadPart);
} // GetUserTime()

UINT64
GetBadHalAdjustment() {
    // this function returns the amount the hal timer in a machine with 
    // an intel chipset with the piix4 timer chip will jump forward in the case of
    // repeated garbage returned fom the piix4 (bug #347410) so we can correct it out
    // in the FixWackyTimestamps routine
    LARGE_INTEGER freq;
    UINT64 diff;

    QueryPerformanceFrequency(&freq);
    // so we want to find how much it is increased in 100ns intervals if we increase
    // byte 3 by 1.
    diff   = 0x01000000;
    diff *= 10000000;
    diff  /= (UINT64)freq.QuadPart;
    return diff;
}

DWORD
MyCreateFile(
    IN PCHAR Name,
    IN PCHAR Extension,
    OUT HANDLE *File)
{
    HANDLE hFile;
    UCHAR * fileName;

    fileName = malloc(strlen(Name) + 5);
    bzero(fileName,strlen(Name) + 5);
    strncpy(fileName, Name, strlen(Name));
    if (strlen(Extension)==4) {
        strcat(fileName,Extension);
    }
    else
        return !ERROR_SUCCESS;

    hFile = CreateFile(fileName,
                       GENERIC_WRITE | GENERIC_READ,
                       0,
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    *File = hFile;

    return(INVALID_HANDLE_VALUE == hFile ? (!(ERROR_SUCCESS)) : ERROR_SUCCESS);
} // MyCreateFile()

void AggregateStats() {
    // this will go through the directory specified in Name and aggregate stats from
    // all the .sta files therein. it will then output the results of the aggregation
    // in a file within that directory called stats.qtc
    char szDirPath[3 * MAX_PATH];
    char szSearchString[3 * MAX_PATH];
    WIN32_FIND_DATA FileData;   // Data structure describes the file found
    HANDLE hSearch;             // Search handle returned by FindFirstFile
    PCHAR rgszStaFiles[1000];   // an array of the names of the .sta files
    int cStaFiles = 0, i,j,k,l; // keeps track of how many of the .sta files there are
    STATS * pStats;
    int rgSizes[1000], cSizes = 0;
    int rgRates[1000], cRates = 0;
    char szAggFile[3 * MAX_PATH];
    char szLineBuf[1000];
    STATS statsT;
    FILE *pfile;
    FILETIME rgtime[1000];
    SYSTEMTIME st;
    ULARGE_INTEGER uliT;
    int ctime = 0;
    int cSpecs = 0;

    PathCanonicalize(szDirPath,Name);
    if (szDirPath[strlen(szDirPath) - 1] == '"') szDirPath[strlen(szDirPath) - 1] = 0;
    if (!PathIsDirectory(szDirPath)) {
        printf("Path (%s) is not a directory\n",szDirPath);
        ErrorExit("Invalid Path for aggregate stats", -1);
    }

    // so now szDirPath is the path to the directory we want to go through
    // and we begin our search for .sta files
    sprintf(szSearchString,"%s\\*.sta",szDirPath);
    hSearch = FindFirstFile (szSearchString, &FileData);
    if (hSearch == INVALID_HANDLE_VALUE) {
        ErrorExit("No .sta files found.",GetLastError());
    }
    
    do {
        rgszStaFiles[cStaFiles] = malloc(sizeof(char) * 3 * MAX_PATH);
        // check to see if it's a good .sta file
        sprintf(statsT.szStaFile,"%s\\%s", szDirPath, FileData.cFileName);
        if (GetStatsFromFile(&statsT)) {
            // if it's good, include it
            strcpy(rgszStaFiles[cStaFiles], FileData.cFileName);
            cStaFiles++;
        }
    } while (FindNextFile(hSearch, &FileData));
    if (GetLastError() != ERROR_NO_MORE_FILES) {
        ErrorExit("Problem in FindNextFile()",GetLastError());
    }

    // open the stats file
    sprintf(szAggFile,"%s\\stats.qtc",szDirPath);
    pfile = fopen(szAggFile,"w+");
    if (pfile == NULL) printf("Could not open file for aggregate stats: %s\n",szAggFile);
    
    pStats = malloc(cStaFiles * sizeof(STATS));
    ZeroMemory(pStats, cStaFiles * sizeof(STATS));
    for (i=0; i<cStaFiles; i++) {
        sprintf(pStats[i].szStaFile, "%s\\%s", szDirPath, rgszStaFiles[i]);
        GetStatsFromFile(&(pStats[i]));
    }

    // at this point our pStats array is loaded up, so we can go to work
    for (i=0; i<cStaFiles; i++) {
        rgSizes[i] = pStats[i].nBytesPerBuffer;
        rgRates[i] = pStats[i].nTokenRate;
        rgtime[i] = pStats[i].time;
    }

    // now sort them and get out the dupliates
    cSizes = cRates = ctime = cStaFiles;
    RemoveDuplicates(rgSizes, &cSizes);
    RemoveDuplicates(rgRates, &cRates);
    RemoveDuplicatesI64((INT64 *)rgtime, &ctime);
    // --- do the stats by by time ---
    fprintf(pfile, "Latency Characteristics at varying times\n");
    fprintf(pfile, "                                 Latency Characteristics (microseconds)              Rates (Bps)           Buffers\n");
    fprintf(pfile, "       Time (UTC)            Median      StDev       Mean     Skew     Kurt       Send    Receive   Received    Dropped\n");
    for (i=0; i<cRates; i++) {
        for (j=0; j<cSizes; j++) {
            // print the flowspec
            if (IndexOfStatRecWith(rgRates[i],rgSizes[j],-1,pStats,cStaFiles) != -1) {
                fprintf(pfile, "FLOWSPEC %d: %dB buffers at %d Bps\n",
                    cSpecs++, rgSizes[j], rgRates[i]);
                for (k=0; k<ctime; k++) {
                    // check to see if there is something with these params and print it
                    ZeroMemory(&uliT, sizeof(ULARGE_INTEGER));
                    CopyMemory(&uliT, &rgtime[k], sizeof(ULARGE_INTEGER));
                    l = IndexOfStatRecWith(rgRates[i],rgSizes[j],uliT.QuadPart,pStats,cStaFiles);
                    if (l > 0) {
                        FileTimeToSystemTime(&pStats[l].time, &st);
                        fprintf(pfile,"%02hu/%02hu/%04hu %2hu:%02hu.%02hu.%03hu: %10.1lf %10.1lf %10.1lf %8.2lf %8.2lf %10.1lf %10.1lf %10d %10d\n",
                            st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond, st.wMilliseconds, 
                            pStats[l].median, sqrt((double)pStats[l].var), pStats[l].mean, 
                            pStats[l].skew, pStats[l].kurt, pStats[l].sendrate, pStats[l].recvrate,
                            pStats[l].nBuffers, pStats[l].nDrops);
                    }
                }
                fprintf(pfile,"\n");
            }
        }
    }

    fprintf(pfile, "Latency Characteristics by flowspec\n");
    // --- do the stats by flowspec ---
    // now write the file, line by line, to szLineBuf, then to the file
    // median
    fprintf(pfile,"Median Latency (microseconds)\n");
    fprintf(pfile,"           ");
    for (i=0; i<cSizes; i++)
        fprintf(pfile,"%9dB ",rgSizes[i]);
    fprintf(pfile,"\n");
    for (i=0; i<cRates; i++) {
        fprintf(pfile,"%7dBps ",rgRates[i]);
        for (j=0; j<cSizes; j++) {
            k = IndexOfStatRecWith(rgRates[i],rgSizes[j],-1,pStats,cStaFiles);
            if (k != -1) {
                fprintf(pfile,"%10.1lf ",pStats[k].median);
            }
            else {
                fprintf(pfile,"           ");
            }
        }
        fprintf(pfile,"\n");
    }
    fprintf(pfile,"\n");
    // mean
    fprintf(pfile,"Mean Latency (microseconds)\n");
    fprintf(pfile,"           ");
    for (i=0; i<cSizes; i++)
        fprintf(pfile,"%9dB ",rgSizes[i]);
    fprintf(pfile,"\n");
    for (i=0; i<cRates; i++) {
        fprintf(pfile,"%7dBps ",rgRates[i]);
        for (j=0; j<cSizes; j++) {
            k = IndexOfStatRecWith(rgRates[i],rgSizes[j],-1,pStats,cStaFiles);
            if (k != -1) {
                fprintf(pfile,"%10.2lf ",pStats[k].mean);
            }
            else {
                fprintf(pfile,"           ");
            }
        }
        fprintf(pfile,"\n");
    }
    fprintf(pfile,"\n");

    // variance
    fprintf(pfile,"Latency Standard Deviation\n");
    fprintf(pfile,"           ");
    for (i=0; i<cSizes; i++)
        fprintf(pfile,"%9dB ",rgSizes[i]);
    fprintf(pfile,"\n");
    for (i=0; i<cRates; i++) {
        fprintf(pfile,"%7dBps ",rgRates[i]);
        for (j=0; j<cSizes; j++) {
            k = IndexOfStatRecWith(rgRates[i],rgSizes[j],-1,pStats,cStaFiles);
            if (k != -1) {
                fprintf(pfile,"%10.2lf ",sqrt((double)pStats[k].var));
            }
            else {
                fprintf(pfile,"           ");
            }
        }
        fprintf(pfile,"\n");
    }
    fprintf(pfile,"\n");

    // skew
    fprintf(pfile,"Latency Skew\n");
    fprintf(pfile,"           ");
    for (i=0; i<cSizes; i++)
        fprintf(pfile,"%9dB ",rgSizes[i]);
    fprintf(pfile,"\n");
    for (i=0; i<cRates; i++) {
        fprintf(pfile,"%7dBps ",rgRates[i]);
        for (j=0; j<cSizes; j++) {
            k = IndexOfStatRecWith(rgRates[i],rgSizes[j],-1,pStats,cStaFiles);
            if (k != -1) {
                fprintf(pfile,"%10.2lf ",pStats[k].skew);
            }
            else {
                fprintf(pfile,"           ");
            }
        }
        fprintf(pfile,"\n");
    }
    fprintf(pfile,"\n");

    // kurtosis
    fprintf(pfile,"Latency Kurtosis\n");
    fprintf(pfile,"           ");
    for (i=0; i<cSizes; i++)
        fprintf(pfile,"%9dB ",rgSizes[i]);
    fprintf(pfile,"\n");
    for (i=0; i<cRates; i++) {
        fprintf(pfile,"%7dBps ",rgRates[i]);
        for (j=0; j<cSizes; j++) {
            k = IndexOfStatRecWith(rgRates[i],rgSizes[j],-1,pStats,cStaFiles);
            if (k != -1) {
                fprintf(pfile,"%10.2lf ",pStats[k].kurt);
            }
            else {
                fprintf(pfile,"           ");
            }
        }
        fprintf(pfile,"\n");
    }
    fprintf(pfile,"\n");

    // send rate
    fprintf(pfile,"Send Rate (Bps)\n");
    fprintf(pfile,"           ");
    for (i=0; i<cSizes; i++)
        fprintf(pfile,"%9dB ",rgSizes[i]);
    fprintf(pfile,"\n");
    for (i=0; i<cRates; i++) {
        fprintf(pfile,"%7dBps ",rgRates[i]);
        for (j=0; j<cSizes; j++) {
            k = IndexOfStatRecWith(rgRates[i],rgSizes[j],-1,pStats,cStaFiles);
            if (k != -1) {
                fprintf(pfile,"%10.1lf ",pStats[k].sendrate);
            }
            else {
                fprintf(pfile,"           ");
            }
        }
        fprintf(pfile,"\n");
    }
    fprintf(pfile,"\n");

    // recv rate
    fprintf(pfile,"Receive Rate (Bps)\n");
    fprintf(pfile,"           ");
    for (i=0; i<cSizes; i++)
        fprintf(pfile,"%9dB ",rgSizes[i]);
    fprintf(pfile,"\n");
    for (i=0; i<cRates; i++) {
        fprintf(pfile,"%7dBps ",rgRates[i]);
        for (j=0; j<cSizes; j++) {
            k = IndexOfStatRecWith(rgRates[i],rgSizes[j],-1,pStats,cStaFiles);
            if (k != -1) {
                fprintf(pfile,"%10.1lf ",pStats[k].recvrate);
            }
            else {
                fprintf(pfile,"           ");
            }
        }
        fprintf(pfile,"\n");
    }
    fprintf(pfile,"\n");

    // show the file to the screen, just for kicks
    rewind(pfile);
    while (fgets(szLineBuf, 1000, pfile) != NULL)
        printf("%s", szLineBuf);
        
    // we're done, so we free up the memory we used    
    printf("Saved aggregate stats to %s\n",szAggFile);
    fclose(pfile);
    for (i=0; i<cStaFiles; i++) {
        free(rgszStaFiles[i]);
    }
    free(pStats);
}

int IndexOfStatRecWith(int rate, int size, INT64 time, PSTATS pStats, int cStats) {
    // returns an index into pStats that has the requested values for rate and size
    // if there are more than one, returns arbitrary match
    // returns -1 if no suitable entry is found.
    int i;
    ULARGE_INTEGER uliT;

    for (i=0; i<cStats; i++) {
        if (rate == -1 || pStats[i].nTokenRate == rate) {
            if (size == -1 || pStats[i].nBytesPerBuffer == size) {
                CopyMemory(&uliT, &(pStats[i].time), sizeof(ULARGE_INTEGER));
                if (time == -1 || uliT.QuadPart == (UINT64)time) {
                    return i;
                }
            }
        }
    }

    return -1;
}

BOOL GetStatsFromFile(PSTATS pstats) {
    // this function gets the overall statistics from the .sta file it's pointed to
    // it returns true if successful, false otherwise
    PCHAR szBuf = NULL;
    double T1,T2,T3;
    int nT1,nT2,nT3,nT4,nT5,nT6;
    HANDLE hFile;
    DWORD dwFileSize;
    DWORD dwRead;
    int nFields;
    SYSTEMTIME st;

    szBuf = malloc(sizeof(CHAR) * 1000);
    
    if (!szBuf) return FALSE;
        
    ZeroMemory(szBuf,1000);
    // open the file
    hFile = CreateFile(pstats->szStaFile,GENERIC_READ, FILE_SHARE_READ, NULL, 
                       OPEN_EXISTING, 0, NULL);
    dwFileSize = GetFileSize(hFile, NULL);
    if (dwFileSize == 0) return FALSE;
    
    // read the whole file into szBuf
    ReadFile(hFile, szBuf, dwFileSize, &dwRead, NULL);

    // close the file
    CloseHandle(hFile);

    // parse the buffer
    nFields = sscanf(szBuf,
                 "Sender: %s Receiver: %s\n" \
                 "First packet received: %hu:%hu.%hu.%hu %hu/%hu/%hu (UTC)\n" \
                 "Buffer size: %d\tTokenrate: %d\n" \
                 "Received %d packets.\n" \
                 "Logged %d records.\n" \
                 "Received %d bytes in %d milliseconds = %d KBps\n" \
                 "Clock skew is %lf microseconds per second.\n " \
                 "\tbased on %d calibration points\n" \
                 "Overall send rate: %lf Bytes/s\n" \
                 "Overall recv rate: %lf Bytes/s\n" \
                 "Latency Statistics (microsecond units): median: %lf\n" \
                 "\tMean: %lf\tStdev: %lf\tAbDev: %lf\n" \
                 "\tVariance: %lf\tSkew: %lf\t Kurtosis: %lf \n" \
                 "Dropped %d packets\n",
                 pstats->szSender, pstats->szReceiver,
                 &(st.wHour), &(st.wMinute), &(st.wSecond), &(st.wMilliseconds), 
                 &(st.wDay), &(st.wMonth), &(st.wYear),
                 &(pstats->nBytesPerBuffer), &(pstats->nTokenRate),
                 &(pstats->nBuffers), &nT2, &nT3, &nT4, &nT5, &T1, &nT6, &(pstats->sendrate), 
                 &(pstats->recvrate), &(pstats->median),
                 &(pstats->mean),&T2,&(pstats->abdev),
                 &(pstats->var),&(pstats->skew),&(pstats->kurt),
                 &(pstats->nDrops));

    if (nFields != 28 && nFields != 27) { // see if they ran without clock skew calc
        nFields = sscanf(szBuf,
                 "Sender: %s Receiver: %s\n" \
                 "First packet received: %hu:%hu.%hu.%hu %hu/%hu/%hu (UTC)\n" \
                 "Buffer size: %d\tTokenrate: %d\n" \
                 "Received %d packets.\n" \
                 "Logged %d records.\n" \
                 "Received %d bytes in %d milliseconds = %d KBps\n" \
                 "Overall send rate: %lf Bytes/s\n" \
                 "Overall recv rate: %lf Bytes/s\n" \
                 "Latency Statistics (microsecond units): median: %lf\n" \
                 "\tMean: %lf\tStdev: %lf\tAbDev: %lf\n" \
                 "\tVariance: %lf\tSkew: %lf\t Kurtosis: %lf \n" \
                 "Dropped %d packets\n",
                 pstats->szSender, pstats->szReceiver,
                 &(st.wHour), &(st.wMinute), &(st.wSecond), &(st.wMilliseconds), 
                 &(st.wDay), &(st.wMonth), &(st.wYear),
                 &(pstats->nBytesPerBuffer), &(pstats->nTokenRate),
                 &nT1, &nT2, &nT3, &nT4, &nT5, &(pstats->sendrate), 
                 &(pstats->recvrate), &(pstats->median),
                 &(pstats->mean),&T2,&(pstats->abdev),
                 &(pstats->var),&(pstats->skew),&(pstats->kurt),
                 &(pstats->nDrops));
    
        if (nFields != 26 && nFields != 25) return FALSE;
    }


    // assemble a FILETIME structure from the date & time
    if (!SystemTimeToFileTime(&st,&pstats->time)) {
        return FALSE;
    }

    free(szBuf);

    return TRUE;    
}

VOID
DoStatsFromFile()
{
    DOUBLE slope = 0;
	DOUBLE offset = 0;
	
    printf("Logging stats from file.\n");
	if (Name == NULL) {
		fprintf(stderr, "ERROR: you must specify a file to convert\n");
	}
	if(MyCreateFile(Name, ".log", &hLogFile) != ERROR_SUCCESS) {
		fprintf(stderr, "ERROR: could not create log file\n");
		exit(1);
	}
	if(OpenRawFile(Name, &hRawFile) != ERROR_SUCCESS) {
		fprintf(stderr, "ERROR: could not open raw file\n");
		exit(1);
	}

    ReadSchedulingRecords(hRawFile);
		
    if (g_params.calibration == 0)
        g_params.calibration = g_log.nBuffersLogged;
        
	NormalizeTimeStamps();

    // here we check for wacky timestamps on the sender and receiver
    if (g_params.SkewFitMode == 3)
        FixWackyTimestamps();
    
	if (g_params.SkewFitMode) {
    	ClockSkew(&slope, &offset);
	    AdjustForClockSkew(slope,offset);
	    NormalizeTimeStamps();
	}

	if(hLogFile != INVALID_HANDLE_VALUE) {
		WriteSchedulingRecords(hLogFile, g_params.Dummy);
	}
	printf("Done stats from file.\n");
} // DoStatsFromFile()

DWORD
OpenRawFile(
	IN PCHAR Name,
	OUT HANDLE *File
	)
{   
	HANDLE hFile;
    UCHAR * logName;

    logName = malloc(strlen(Name) + 4);
    strncpy(logName, Name, strlen(Name));
    
    logName[strlen(Name)+0] = '.';
    logName[strlen(Name)+1] = 'r';
    logName[strlen(Name)+2] = 'a';
    logName[strlen(Name)+3] = 'w';
    logName[strlen(Name)+4] = (UCHAR)NULL;

    hFile = CreateFile(logName,
                       GENERIC_READ,
                       0,
                       NULL,
                       OPEN_EXISTING ,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);
                       
    *File = hFile;

    return(INVALID_HANDLE_VALUE == hFile ? (!(ERROR_SUCCESS)) : ERROR_SUCCESS);
} // OpenRawFile()

INT64 ReadSchedulingRecords(HANDLE File)
{
    char szTempFile[MAX_PATH];
    char szTempPath[MAX_PATH];
	LOG_RECORD currentRecord;
	CHAR lineBuf[MAX_STRING];
	CHAR nextChar[2] = {0,0};
	DWORD readBytes = 0;
	INT assignedFields;

	if (!File || (File == INVALID_HANDLE_VALUE)) {
		fprintf(stderr,"ERROR: Invalid File\n");
		return 0;
	}

    CreateLog(&g_log, 2048);
	// loop through the file, reading in line after line
	do 
	{
		// get the next line of characters
		bzero(lineBuf, MAX_STRING);
		ZeroMemory(lineBuf, MAX_STRING);
		do {
			ReadFile(File,nextChar,1,&readBytes,NULL);
			if (readBytes == 0) {
			    if (g_log.nBuffersLogged == 0) {
			        fprintf(stderr,"ERROR: no logs read\n");
			        exit(1);
			    }
			    break;
			}
			strcat(lineBuf,nextChar);
		} while (*nextChar != '\n');
		// parse line and add it to the log
		assignedFields = sscanf(lineBuf, 
			"%I64u:%I64u:%I64u:%d:%d\n", 
			&(currentRecord.TimeSent),
			&(currentRecord.TimeReceived),
			&(currentRecord.Latency),
			&(currentRecord.BufferSize),
			&(currentRecord.SequenceNumber));
		if ((assignedFields != 5) && (assignedFields != EOF))
			printf("ERROR: parsing the log gave bad field assignments on record %d\n", 
			    g_log.nBuffersLogged);

		if (assignedFields == EOF) break;
        AddLogEntry(&g_log, &currentRecord);
	}
	while (readBytes != 0);

    printf("read %d records\n",g_log.nBuffersLogged);
	return g_log.nBuffersLogged;  // return the number of records read
} // ReadSchedulingRecords()

VOID
DoStats()
{
    DOUBLE slope = 0;
    DOUBLE offset = 0;

    GenericStats();
    
    if(!normalize){
        if(hRawFile != INVALID_HANDLE_VALUE){
            WriteSchedulingRecords(hRawFile, FALSE);
        }
    }
    
    NormalizeTimeStamps();
    
    if(normalize){
        if(hRawFile != INVALID_HANDLE_VALUE){
            WriteSchedulingRecords(hRawFile, FALSE);
        }
    }

    if(!g_params.calibration) { // if we have nothing specified, calibrate on all buffers
        g_params.calibration = g_state.nBuffersReceived;
    }
   
    // here we check for wacky timestamps on the sender and receiver
    if (g_params.SkewFitMode == 3)
        FixWackyTimestamps();
    
    if(g_params.SkewFitMode) {
        ClockSkew(&slope, &offset);
        AdjustForClockSkew(slope, offset);
        NormalizeTimeStamps();
    }

    // we calculate these stats on the normalized / skew adjusted data
    AdvancedStats();
    
    CheckForLostPackets();
    
    if(hLogFile != INVALID_HANDLE_VALUE){
        WriteSchedulingRecords(hLogFile, g_params.Dummy);
    }
    printf("\n");
}

VOID
WriteSchedulingRecords(
    HANDLE File,
    BOOLEAN InsertDummyRows)
{
    
    LOG_RECORD scheduleRecord;
    CHAR formattingBuffer[MAX_STRING];
    INT dwWritten;
    INT64 records = g_log.nBuffersLogged;
	INT wrote;
    INT i;
    INT64 maxLatency = (INT64)0;

    if(!File || (File == INVALID_HANDLE_VALUE)){
        return;
    }

    while(records){
        GetLogEntry(&g_log, &scheduleRecord, g_log.nBuffersLogged - records);
		ZeroMemory(formattingBuffer,MAX_STRING);
		
        wrote = sprintf(formattingBuffer,
		                "%020I64u:%020I64u:%010I64d:%10d:%10d\n", 
						scheduleRecord.TimeSent,
						scheduleRecord.TimeReceived,
				        scheduleRecord.Latency,
					    scheduleRecord.BufferSize,
						scheduleRecord.SequenceNumber);

        WriteFile(File, formattingBuffer, wrote, &dwWritten, NULL);

        records--;
    }
} // WriteSchedulingRecords()

VOID
GenericStats()
{
    INT bytesWritten;
    UCHAR holdingBuffer[MAX_STRING];
    INT count;

    // say who the sender and receiver are
    count = sprintf(holdingBuffer, "Sender: %s Receiver: %s\n",szHisAddr, szMyAddr);
    WriteStats(holdingBuffer, count);
    printf("%s",holdingBuffer);

    // say when we received the first packet
    count = sprintf(holdingBuffer, "First packet received: %02u:%02u.%02u.%03u %02u/%02u/%04u (UTC)\n",
        systimeStart.wHour, systimeStart.wMinute, systimeStart.wSecond, 
        systimeStart.wMilliseconds, systimeStart.wDay, systimeStart.wMonth, systimeStart.wYear);
    WriteStats(holdingBuffer, count);
    printf("%s",holdingBuffer);
    
    // write the test params to the .sta file
    bzero(holdingBuffer, MAX_STRING);
    count = _snprintf(holdingBuffer, MAX_STRING -1,
                      "Buffer size: %d\tTokenrate: %d\n",
                      g_params.buflen, g_params.TokenRate);
    WriteStats(holdingBuffer, count);
    printf("%s",holdingBuffer);
    
    // write some generic results
    bzero(holdingBuffer, MAX_STRING);
    count = _snprintf(holdingBuffer,
                      MAX_STRING-1, // leave room for NULL
                      "Received %u packets.\n",
                      g_state.nBuffersReceived);
    WriteStats(holdingBuffer, count);
    printf("%s",holdingBuffer);

    bzero(holdingBuffer, MAX_STRING);
    count = _snprintf(holdingBuffer,
                      MAX_STRING-1, // leave room for NULL
                      "Logged %I64u records.\n",
                      g_log.nBuffersLogged);
    WriteStats(holdingBuffer, count);
    printf("%s",holdingBuffer);

    bzero(holdingBuffer, MAX_STRING);
    count = _snprintf(holdingBuffer,
                      MAX_STRING-1, // room for NULL
                      "Received %ld bytes in %I64d milliseconds = %I64d KBps\n",
                      g_state.nBytesTransferred,
                      timeElapsed,
                      g_state.nBytesTransferred/timeElapsed);
    WriteStats(holdingBuffer, count);
    printf("%s",holdingBuffer);
} // GenericStats()

void AdvancedStats() {
    // write some more interesting stats to the .sta file
    char szBuf[MAX_STRING];
    INT64 i,n;
    int count;
    INT64 FirstTime,LastTime;
    double rate, median, mean, var, abdev, skew, kurt, sdev, ep = 0.0, s, p;
    LOG_RECORD rec;
    double * sortedLatencies;

    // overall send rate
    GetLogEntry(&g_log, &rec, 0);
    FirstTime = rec.TimeSent;
    GetLogEntry(&g_log, &rec, g_log.nBuffersLogged - 1);
    LastTime = rec.TimeSent;
    rate = (rec.SequenceNumber * g_params.buflen)/((double)(LastTime - FirstTime)/10000000.0);
    count = sprintf(szBuf, "Overall send rate: %.3f Bytes/s\n",rate);
    WriteStats(szBuf, count);
    printf("%s",szBuf);
    GetLogEntry(&g_log, &rec, 0);
    FirstTime = rec.TimeReceived;
    GetLogEntry(&g_log, &rec, g_log.nBuffersLogged - 1);
    LastTime = rec.TimeReceived;
    rate = (g_state.nBytesTransferred)/((double)(LastTime - FirstTime)/10000000.0);
    count = sprintf(szBuf, "Overall recv rate: %.3f Bytes/s\n",rate);
    WriteStats(szBuf, count);
    printf("%s",szBuf);

    // now show mean, variance, avdev, etc of latency.
    s = 0.0;
    n = g_log.nBuffersLogged;
    sortedLatencies = malloc(sizeof(double) * (UINT)n);
    for (i=0; i < n; i++) { // first pass, we get mean
        GetLogEntry(&g_log, &rec, i);
        s += (double)rec.Latency/10.0;
        sortedLatencies[i] = (double)rec.Latency/10.0;
    }
    qsort(sortedLatencies,(UINT)n,sizeof(double),compare);
    median = (n & 1) ? sortedLatencies[(n-1)/2] : 0.5*(sortedLatencies[n/2] + sortedLatencies[n/2 - 1]);
    free(sortedLatencies);
    mean = s / n;
    abdev = var = skew = kurt = 0.0;
    for (i=0; i<n; i++) { // second pass, we get 1st,2nd,3rd,4th moments of deviation from mean
        GetLogEntry(&g_log, &rec, i);
        abdev += fabs(s=(double)rec.Latency/10.0 - mean);
        ep += s;
        var += (p = s*s);
        skew += (p *= s);
        kurt += (p *= s);
    }
    abdev /= n;
    var = (var - ep*ep/n) / (n-1);
    sdev = sqrt(var);
    if (var) {           // if var=0, no skew/kurtosis defined
        skew /= (n*var*sdev);
        kurt  = kurt / (n*var*var) - 3.0;
    }

    count = sprintf(szBuf, "Latency Statistics (microsecond units): median: %.1lf\n",median);
    WriteStats(szBuf, count);
    printf("%s",szBuf);
    count = sprintf(szBuf, "\tMean:     %6.2lf\tStdev: %6.2lf\tAbDev:    %6.2lf\n",mean,sdev,abdev);
    WriteStats(szBuf, count);
    printf("%s",szBuf);
    count = sprintf(szBuf, "\tVariance: %6.2lf\tSkew:  %6.2lf\tKurtosis: %6.2lf\n",var,skew,kurt);
    WriteStats(szBuf, count);
    printf("%s",szBuf);
}

VOID
CheckForLostPackets()
{
    LOG_RECORD currentRecord;
    INT currentSequenceNumber = 0;
    INT bytesWritten;
    UCHAR holdingBuffer[MAX_STRING];
    INT count;
    INT64 nLost = 0;
    INT i;

    for(i=0; i<g_log.nBuffersLogged; i++){
        GetLogEntry(&g_log, &currentRecord, i);
        if(currentRecord.SequenceNumber != currentSequenceNumber){
            nLost += currentRecord.SequenceNumber - currentSequenceNumber;
            currentSequenceNumber = currentRecord.SequenceNumber;
        }

        currentSequenceNumber += g_params.LoggingPeriod;
    }
    count = sprintf(holdingBuffer, "Dropped %I64u packets\n", nLost);
    WriteStats(holdingBuffer, count);
} // CheckForLostPackets()

VOID
WriteStats(
    UCHAR * HoldingBuffer,
    INT Count)
{
    INT bytesWritten;

    if(Count < 0){
        Count = MAX_STRING;
    }

    WriteFile(hStatFile,
              HoldingBuffer,
              Count,
              &bytesWritten,
              NULL);
} // WriteStats()

VOID
NormalizeTimeStamps()
{
    LOG_RECORD currentRecord;
    INT bytesWritten;
    UCHAR holdingBuffer[MAX_STRING];
    INT count;
    INT i;

    UINT64 timeSent;
    UINT64 timeReceived;
    UINT64 smaller;
    INT64 constantDelay = MAX_INT64;
    INT64 currentDelay;
    UINT64 base = 0xFFFFFFFFFFFFFFFF;

    for(i=0; i<g_log.nBuffersLogged; i++){
        GetLogEntry(&g_log, &currentRecord, i);
        currentDelay = currentRecord.TimeReceived - currentRecord.TimeSent;
        constantDelay = (currentDelay < constantDelay) ? currentDelay : constantDelay;
    }

    // now subtract off the constant delay off
    for(i=0; i<g_log.nBuffersLogged; i++){
        GetLogEntry(&g_log, &currentRecord, i);
        currentRecord.TimeReceived -= constantDelay;
        currentRecord.Latency = currentRecord.TimeReceived - currentRecord.TimeSent;
        SetLogEntry(&g_log, &currentRecord, i);
    }

    for (i=0; i<g_log.nBuffersLogged; i++) {
        GetLogEntry(&g_log, &currentRecord, i);
        smaller = (currentRecord.TimeReceived < currentRecord.TimeSent) ?
            currentRecord.TimeReceived : currentRecord.TimeSent;
        base = (base < smaller)?base:smaller;  // find the smallest timestamp
    }        
    
    // now we can subtract the base off of the send & receive times
    for (i=0; i<g_log.nBuffersLogged; i++) {
        GetLogEntry(&g_log, &currentRecord, i);
        currentRecord.TimeSent -= base;
        currentRecord.TimeReceived -= base;
        SetLogEntry(&g_log, &currentRecord, i);
    }
} // NormalizeTimeStamps()

VOID
ClockSkew(
    DOUBLE * Slope,
    DOUBLE * Offset) {
    // If there is a calibration period, we can estimate clock skew between
    // sender and receiver. See comments under AdjustForClockSkew. We use
    // calculus to determine the best-fit slope.

    INT i;
    LOG_RECORD currentRecord;
	DOUBLE N;
    DOUBLE slope;
    DOUBLE offset;
    UCHAR holdingBuffer[MAX_STRING];
    INT count;
    double *x, *y, abdev;
    double devpercent;
    
    // We find the clock skew using medfit, a function which fits to minimum absolute deviation
    N = (double) g_params.calibration;
    x = malloc(sizeof(double) * (UINT)N);
    y = malloc(sizeof(double) * (UINT)N);
    for (i = 0; i<N; i++) {
        GetLogEntry(&g_log,&currentRecord,i);
        x[i] = (DOUBLE)currentRecord.TimeSent;
        y[i] = (DOUBLE)currentRecord.Latency;
    }
    medfit(x, y, (INT)N, &offset, &slope, &abdev);

    // Now write out our findings.
    bzero(holdingBuffer, MAX_STRING);

    count = _snprintf(holdingBuffer,
					MAX_STRING-1, // leave room for NULL
					"Clock skew is %f microseconds per second.\n  " \
					"\tbased on %d calibration points\n",
					100000*slope, g_params.calibration);

    WriteStats(holdingBuffer, count);
	printf("%s",holdingBuffer);

    for (i = 0,devpercent = 0.0; i<N; i++) {
        devpercent += y[i];
    }
    devpercent /= N;
    devpercent = 100 * abdev / devpercent;

    printf("\tfit resulted in avg. absolute deviation of %f percent from mean\n",devpercent);

    free(x);
    free(y);
    *Slope = slope;
    *Offset = offset;
} // ClockSkew()

BOOLEAN
AnomalousPoint(
			   DOUBLE x,
			   DOUBLE y)
{
	// here we simply keep a buffer of the past 10 calls and if this one 
	// falls out of a few standard deviations of the 8 inner points, we deem it anomalous
	static DOUBLE buf[10];
	DOUBLE sortedbuf[10];
	DOUBLE mean = 0;
	DOUBLE sum = 0;
	DOUBLE sumsqdev = 0;
	DOUBLE median = 0;
	DOUBLE sdev = 0;
	DOUBLE N;
	static int curIndex = 0;
	int i;
	static INT64 submittedPoints;

	buf[curIndex % 10] = y;
	curIndex++;
	submittedPoints++;
	
	if (g_params.SkewFitMode != 4)
		return FALSE;

	if (submittedPoints >= 10) {
		sum = 0;
		sumsqdev = 0;

        // sort them into sortedbuf
        for (i=0; i<10; i++) sortedbuf[i] = buf[i];
        qsort(sortedbuf, 10, sizeof(DOUBLE), compare);

        // use only the inner 8 points in the calculation of mean & var
		for (i = 1; i < 9; i++) {
			sum += sortedbuf[i];
		}

		N = 8.0; // using only 8 points
		mean = sum / N;

		for (i = 1; i < 9; i++) {
			sumsqdev += ((sortedbuf[i] - mean) * (sortedbuf[i] - mean));
		}
		
		sdev = sqrt(sumsqdev / N);
		if (fabs(y - mean) < 2.5 * sdev) {
			return FALSE;
		}
		else {
		    anomalies++;
			return TRUE;
		}
	}

	return TRUE;
} // AnomalousPoint()

VOID
AdjustForClockSkew(
    DOUBLE Slope,
    DOUBLE Offset)
{
    //
    // When measuring very low jitter, clock drift between machines 
    // introduces noise in the form of a monotonically increasing 
    // skew between sending and receiving clock. This effect can be 
    // filtered out by finding the best-fit slope for all samples 
    // taken during the calibration period, then using this slope to
    // normalize the entire run. This routine normalizes using the 
    // slope determined in the routine ClockSkew.
    //

    INT i;
    LOG_RECORD currentRecord;
    INT64 minLatency = MAX_INT64;
    INT64 x;
    DOUBLE mXPlusB;

    for(i=0; i < g_log.nBuffersLogged; i++){
        GetLogEntry(&g_log, &currentRecord, i);
        mXPlusB = (currentRecord.TimeSent*Slope) + Offset; // offset is not necessary

        currentRecord.TimeReceived -= (INT64)mXPlusB;
        currentRecord.Latency -= (INT64)mXPlusB;

        SetLogEntry(&g_log, &currentRecord, i);

        //
        // find the minimum latency value
        //

        minLatency = (currentRecord.Latency < minLatency)?
                        currentRecord.Latency:
                        minLatency;
    }

    for(i=0; i < g_log.nBuffersLogged; i++){
        GetLogEntry(&g_log, &currentRecord, i);
        currentRecord.Latency -= minLatency;
        currentRecord.TimeReceived -= minLatency;
        SetLogEntry(&g_log, &currentRecord, i);   
    }
} // AdjustForClockSkew()

#define WACKY 2.5

BOOL FixWackyTimestamps() {
    // This routine will look over the sender & receiver timestamps and try to see if there
    // are any non-clock skew related irregularities (such as one of them bumping it's clock
    // a fixed amount every once-in-a-while) and try to remove them.
    INT64 *sendstamps, *recvstamps;
    double *sendgaps, *recvgaps;
    double *sortedsendgaps, *sortedrecvgaps;
    double sendmean, sendsdev, sendsum, sendsumsqdev;
    double recvmean, recvsdev, recvsum, recvsumsqdev;
    double mediansendgap, medianrecvgap;
    double modesendgap, moderecvgap;
    double meansendwackiness, sdevsendwackiness, sumsendwackiness, sumsqdevsendwackiness;
    double meanrecvwackiness, sdevrecvwackiness, sumrecvwackiness, sumsqdevrecvwackiness;
    double fractionaldevofsendwackiness, fractionaldevofrecvwackiness;
    double normalsendgapmean, normalrecvgapmean;
    double trimmeansendgap, trimmeanrecvgap;
    BOOL *fWackoSend, *fWackoRecv;
    int cWackoSend, cWackoRecv;
    BOOL *fMaybeWackoSend, *fMaybeWackoRecv;
    int i,N;
    LOG_RECORD currentRecord;
    const double FixThreshold = 0.1;
    double CumulativeFixMagnitude = 0.0;

    N = (int)g_log.nBuffersLogged;
    cWackoSend = cWackoRecv = 0;
    // fill our arrays.
    sendstamps = malloc(sizeof(INT64) * N);
    recvstamps = malloc(sizeof(INT64) * N);
    sendgaps = malloc(sizeof(double) * N);
    recvgaps = malloc(sizeof(double) * N);
    sortedsendgaps = malloc(sizeof(double) *N);
    sortedrecvgaps = malloc(sizeof(double) *N);
    fWackoRecv = malloc(sizeof(BOOL) * N);
    fWackoSend = malloc(sizeof(BOOL) * N);
    fMaybeWackoSend = malloc(sizeof(BOOL) * N);
    fMaybeWackoRecv = malloc(sizeof(BOOL) * N);

    for (i=0; i<N; i++) {
        GetLogEntry(&g_log, &currentRecord, i);
        sendstamps[i] = currentRecord.TimeSent;
        recvstamps[i] = currentRecord.TimeReceived;
        fWackoSend[i] = FALSE;
        fMaybeWackoSend[i] = FALSE;
        fWackoRecv[i] = FALSE;
        fMaybeWackoRecv[i] = FALSE;
    }
    
    // First, check for wacky timestamps. This is a multistep process:
    //    1. Calculate the interpacket gaps on both sender & receiver.
    for (i=1; i<N; i++) {
        sendgaps[i] = (double) (sendstamps[i] - sendstamps[i-1]);
        recvgaps[i] = (double) (recvstamps[i] - recvstamps[i-1]);
    }
    //    2. We will define wacky as being at least WACKY standard deviations away from the
    //       mean.
    sendsum = recvsum = 0.0;
    for (i=1; i<N; i++) {
        sendsum += sendgaps[i];
        recvsum += recvgaps[i];
    }
    sendmean = sendsum / N;
    recvmean = recvsum / N;
    sendsumsqdev = recvsumsqdev = 0.0;
    for (i=1; i<N; i++) {
        sendsumsqdev += ((sendgaps[i] - sendmean) * (sendgaps[i] - sendmean));
        recvsumsqdev += ((recvgaps[i] - recvmean) * (recvgaps[i] - recvmean));
    }
	sendsdev = sqrt(sendsumsqdev / N);
	recvsdev = sqrt(recvsumsqdev / N);

    for (i=1; i<N; i++) {
        if ((sendgaps[i] < sendmean - WACKY*sendsdev) ||
            (sendgaps[i] > sendmean + WACKY*sendsdev)) {
            fMaybeWackoSend[i] = fWackoSend[i] = TRUE;
        }
        if ((recvgaps[i] < recvmean - WACKY*recvsdev) ||
            (recvgaps[i] > recvmean + WACKY*recvsdev)) {
            fMaybeWackoRecv[i] = fWackoRecv[i] = TRUE;
        }        
    }
    
    //    3. Check to see if any wacky points are unpaired (that is, a wacky point in the
    //       sending timestamps is not matched with an equally wacky point in the receiving
    //       timestamps).
    for (i=1; i<N; i++) {
        if (fMaybeWackoSend[i] && fMaybeWackoRecv[i]) {
            // I should check to make sure they're equally wacky, but i'm not currently
            fMaybeWackoSend[i] = fWackoSend[i] = FALSE;
            fMaybeWackoRecv[i] = fWackoRecv[i] = FALSE;
        }
    }
    //    4. Check to see if any wacky unpaired points are solitary (that is, they are not
    //       surrounded by other wacky points).
    for (i=1; i<N-1; i++) {
        if (fMaybeWackoSend[i]) {
            if (fMaybeWackoSend[i-1] || fMaybeWackoSend[i+1]) {
                fWackoSend[i] = FALSE;
            }
        }
        if (fMaybeWackoRecv[i]) {
            if (fMaybeWackoRecv[i-1] || fMaybeWackoRecv[i+1]) {
                fWackoRecv[i] = FALSE;
            }
        }
    }
    if (fMaybeWackoSend[N-1] && fMaybeWackoSend[N-2]) fWackoSend[N-1] = FALSE;
    if (fMaybeWackoRecv[N-1] && fMaybeWackoRecv[N-2]) fWackoRecv[N-1] = FALSE;
    //    5. If we find a point that meets all these criteria, label it wacky and add it to
    //       our list of wacky points.
    for (i=1; i<N; i++) {
        fMaybeWackoSend[i] = fWackoSend[i];
        fMaybeWackoRecv[i] = fWackoRecv[i];    
    }

    // Now we find out the stats for the sends & receivees to use as the baseline
    sendsum = recvsum = 0.0;
    cWackoSend = cWackoRecv = 0;
    for (i=1; i<N; i++) {
        sortedsendgaps[i] = sendgaps[i];
        sortedrecvgaps[i] = recvgaps[i];
        if (!fWackoSend[i]) {
            sendsum += sendgaps[i];
            cWackoSend++;
        }
        if (!fWackoRecv[i]) {
            recvsum += recvgaps[i];
            cWackoRecv++;
        }
    }
    normalsendgapmean = sendsum / cWackoSend;
    normalrecvgapmean = recvsum / cWackoRecv;
    qsort(sortedsendgaps, N, sizeof(double), compare);
    qsort(sortedrecvgaps, N, sizeof(double), compare);
    if (N & 1) { // odd N
        mediansendgap = sortedsendgaps[(N+1) / 2];
        medianrecvgap = sortedrecvgaps[(N+1) / 2];
    } else { // even N
        i = N/2;
        mediansendgap = 0.5 * (sortedsendgaps[i] + sortedsendgaps[i+1]);
        medianrecvgap = 0.5 * (sortedrecvgaps[i] + sortedrecvgaps[i+1]);
    }
    sendsum = recvsum = 0.0;
    for (i=(int)(0.05*N); i<(int)(0.85*N); i++) { // find the 80% trimmean (bottom heavy)
        sendsum += sortedsendgaps[i];
        recvsum += sortedrecvgaps[i];
    }
    trimmeansendgap = sendsum / (0.80 * N);
    trimmeanrecvgap = recvsum / (0.80 * N);
    modesendgap = mode(sendgaps, N);
    moderecvgap = mode(recvgaps, N);

    // 6. we have to check to see if the wackiness at each wacky point is about equal to what
    // we think it ought to be, based on the timer clock
    for (i=1; i<N; i++) {
        if (fWackoSend[i]) {
            if (!InRange(sendgaps[i] - g_BadHalAdjustment, 
                    mediansendgap - sendsdev, mediansendgap + sendsdev)) {
               fWackoSend[i] = FALSE;
               cWackoSend--;
            }
        }
        if (fWackoRecv[i]) {
            if (!InRange(recvgaps[i] - g_BadHalAdjustment, 
                    medianrecvgap - recvsdev, medianrecvgap + recvsdev)) {
               fWackoRecv[i] = FALSE;
               cWackoRecv--;
            }
        }
    }

    // Now we want to correct for the wacky timestamps, so we see if the wacky points are all
    // equally wacky. If they are, we're psyched and we simply subtract off the wackiness
    // from the wacky points and all points after them. (Wackiness is cumulative!)
    cWackoSend = cWackoRecv = 0;
    sumsendwackiness = sumrecvwackiness = sumsqdevsendwackiness = sumsqdevrecvwackiness = 0.0;
    for (i=1; i<N; i++) {
        if (fWackoSend[i]) {
            sumsendwackiness += (sendgaps[i] - trimmeansendgap);
            cWackoSend++;
        }
        if (fWackoRecv[i]) {
            sumrecvwackiness += (recvgaps[i] - trimmeanrecvgap);
            cWackoRecv++;
        }
    }
    meansendwackiness = sumsendwackiness / cWackoSend;
    meanrecvwackiness = sumrecvwackiness / cWackoRecv;
    for (i=1; i<N; i++) {
        if (fWackoSend[i])
            sumsqdevsendwackiness += ((sendgaps[i]-trimmeansendgap-meansendwackiness) * (sendgaps[i]-normalsendgapmean-meansendwackiness));
        if (fWackoRecv[i])
            sumsqdevrecvwackiness += ((recvgaps[i]-trimmeanrecvgap-meanrecvwackiness) * (recvgaps[i]-normalrecvgapmean-meanrecvwackiness));
    }
    sdevsendwackiness = sqrt(sumsqdevsendwackiness / cWackoSend);
    sdevrecvwackiness = sqrt(sumsqdevrecvwackiness / cWackoRecv);
    
    // so if the fractional deviation is less than some set amount, we apply the fix
    fractionaldevofsendwackiness = sdevsendwackiness / meansendwackiness;
    fractionaldevofrecvwackiness = sdevrecvwackiness / meanrecvwackiness;
    if (cWackoSend && (fractionaldevofsendwackiness < FixThreshold)) {
        // apply fix to send timestamps
        CumulativeFixMagnitude = 0.0;
        cWackoSend = 0;
        for (i=0; i<N; i++) {
            if (fWackoSend[i]) {
                fWackySender = TRUE;
                CumulativeFixMagnitude += g_BadHalAdjustment;
                cWackoSend++;
            }
            sendstamps[i] -= (INT64)CumulativeFixMagnitude;
        }
    }
    if (cWackoRecv && (fractionaldevofrecvwackiness < FixThreshold)) {
        // apply fix to recv timestamps
        CumulativeFixMagnitude = 0.0;
        cWackoRecv = 0;
        for (i=0; i<N; i++) {
            if (fWackoRecv[i]) {
                fWackyReceiver = TRUE;
                CumulativeFixMagnitude += g_BadHalAdjustment;
                cWackoRecv++;
            }
            recvstamps[i] -= (INT64)CumulativeFixMagnitude;
        }
    }

    // set the globals to reflect our "fixed" values
    for (i=0; i<N; i++) {
        if (fWackySender) {
            GetLogEntry(&g_log, &currentRecord, i);
            currentRecord.TimeSent = sendstamps[i];
            SetLogEntry(&g_log, &currentRecord, i);
        }
        if (fWackyReceiver) {
            GetLogEntry(&g_log, &currentRecord, i);
            currentRecord.TimeReceived = recvstamps[i];
            SetLogEntry(&g_log, &currentRecord, i);
        }
    }
    if (fWackySender || fWackyReceiver) {
        printf("WARNING: I noticed some oddities among the timestamps on the");
        if (fWackySender) printf(" sender");
        if (fWackySender && fWackyReceiver) printf(" and");
        if (fWackyReceiver) printf(" receiver");
        printf(".\n");
        if (fWackySender) {
            printf("\t%d of them on the order of %fms each on the sender.\n",
                cWackoSend, meansendwackiness / 10000); }
        if (fWackyReceiver) {
            printf("\t%d of them on the order of %fms each on the receiver.\n",
                cWackoRecv, meanrecvwackiness / 10000); }
        printf("\tThey are caused by a malfunctioning clock on the afflicted machine.\n");
        printf("\tI have tried to compensate for them in the .log file.\n");
        NormalizeTimeStamps(); // we have to renormalize now
    }
    return FALSE;
}

DWORD WINAPI RSVPMonitor (LPVOID lpvThreadParm) {   
    DWORD dwResult = 0;
    ULONG status;
    BOOLEAN confirmed = FALSE;
    UINT64 ui64LastHi = 0,ui64Now = 0;
    FILETIME filetime;
    ULARGE_INTEGER ulargeint;
    BOOLEAN fResvGood = FALSE;

    // don't do anything until the control socket is established
    while (g_sockControl == INVALID_SOCKET) {
        Sleep(10);
    }

    while(TRUE){
        // send a HELLO message every once in a while
        GetSystemTimeAsFileTime(&filetime);
        memcpy(&ulargeint, &filetime, sizeof(FILETIME));
        ui64Now = ulargeint.QuadPart;
        if (ui64LastHi + 10000000*SECONDS_BETWEEN_HELLOS < ui64Now) {
            SendControlMessage(g_sockControl,MSGST_HELLO);
            ui64LastHi = ui64Now;
        }
        
        // get the RSVP statuscode, waiting for as long as it takes
        status = GetRsvpStatus(WSA_INFINITE,fd);

        if (g_state.Done) {
            ExitThread(1);
        }
        switch (status) {
            case WSA_QOS_TRAFFIC_CTRL_ERROR: // sad if we get this
                printf("RSVP-ERR: Reservation rejected by traffic control on server. Aborting.\n");
                SendControlMessage(g_sockControl,MSGST_RSVPERR);
                g_state.Done = TRUE;
                exit(1);
                break;
            case WSA_QOS_REQUEST_CONFIRMED:  // happy if we get this
                if (!confirmed) {
                    printf("RSVP: Reservation confirmed\n");
                    confirmed = TRUE;
                    fResvGood = TRUE;
                }
                break;
            case WSA_QOS_SENDERS:
                if (!fResvGood && !trans) {
                    printf("\nRSVP Monitor: WSA_QOS_SENDERS at t=%I64ds\n",
                        (GetUserTime() - timeStart) / 10000000);
                    fResvGood = TRUE;
                }
                break;
            case WSA_QOS_RECEIVERS:
                if (!fResvGood && trans) {
                    printf("\nRSVP Monitor: WSA_QOS_RECEIVERS at t=%I64ds\n",
                        (GetUserTime() - timeStart) / 10000000);
                    fResvGood = TRUE;
                }
                break;
            case WSA_QOS_NO_SENDERS: // the sender is now gone, so we stop
                if (fResvGood && !trans) {
                    printf("\nRSVP Monitor: WSA_QOS_NO_SENDERS at t=%I64ds\n",
                        (GetUserTime() - timeStart) / 10000000);
                    fResvGood = FALSE;
                }
                break;
            case WSA_QOS_NO_RECEIVERS: // means the sender is done, so he should exit
                if (fResvGood && trans) {
                    printf("\nRSVP Monitor: WSA_QOS_NO_RECEIVERS at t=%I64ds\n",
                        (GetUserTime() - timeStart) / 10000000);
                    fResvGood = FALSE;
                }
                break;
            default:
                break;
        }
        Sleep(1000); // check at most once per second
    }
    
    return dwResult;
} // RSVPMonitor()

DWORD WINAPI KeyboardMonitor(LPVOID lpvThreadParm) {
    DWORD dwResult = 0;
    char ch;
    while (TRUE) {
        ch = (CHAR) getchar();
        switch (ch) {
        case 'q':
            SendControlMessage(g_sockControl,MSGST_DONE);
            g_state.Done = TRUE;
            ExitThread(1);
            break;
        }
    }
    return 0;
}

DWORD WINAPI ControlSocketMonitor(LPVOID lpvThreadParm) {
    DWORD dwResult = 0;
    DWORD dwError, cbBuf = 0;
    DWORD dwAddrSize = MAX_STRING;
    char szAddr[MAX_STRING];
    char szBuf[MAX_STRING],szCommand[MAX_STRING], *pchStart, *pchEnd;
    int cch;
    char szT[MAX_STRING];
    char szT2[MAX_STRING];
    char * szHost;
    BOOL fSender;
    SOCKET sockControl, sockListen;
    SOCKADDR_IN sinmeControl, sinhimControl;
    PHOSTENT phostent;
    UINT64 ui64LastHello = 0;
    BOOL fDone = FALSE;
    BOOL fGotRate=FALSE, fGotSize=FALSE, fGotNum=FALSE;
    BOOL fSentReady =FALSE;

    // find out if we're the sender or receiver
    if (lpvThreadParm == NULL) fSender = FALSE;
    else fSender = TRUE;

    // if sender, copy the host address into our local host string
    if (fSender) {
        szHost = malloc(strlen((char *)lpvThreadParm) + 1);
        strcpy(szHost, (const char *)lpvThreadParm);
    }        

    // set up a control socket
    if (fSender) {
        sockControl = socket(AF_INET, SOCK_STREAM, 0);
    }
    else {
        sockListen = socket(AF_INET, SOCK_STREAM, 0);
    }
    
    // bind properly
    sinmeControl.sin_family = AF_INET;
    sinmeControl.sin_addr.s_addr = INADDR_ANY;
    sinhimControl.sin_family = AF_INET;
    if (fSender) {
        sinmeControl.sin_port = 0;
        // set up the sinhim structure
        if (atoi(szHost) > 0 )  {
            sinhimControl.sin_addr.s_addr = inet_addr(szHost);
        }
        else{
            if ((phostent=gethostbyname(szHost)) == NULL) {
                ErrorExit("bad host name",WSAGetLastError());
            }
            sinhimControl.sin_family = phostent->h_addrtype;
            memcpy(&(sinhimControl.sin_addr.s_addr), phostent->h_addr, phostent->h_length);
        }
        sinhimControl.sin_port = htons(CONTROL_PORT);
        dwError = bind(sockControl,(SOCKADDR*)&sinmeControl,sizeof(sinmeControl));
    }
    else { // receiver
        sinmeControl.sin_port = htons(CONTROL_PORT);
        dwError = bind(sockListen,(SOCKADDR*)&sinmeControl,sizeof(sinmeControl));
    }
    if (dwError == SOCKET_ERROR)
        ErrorExit("bind failed",WSAGetLastError());

    // now connect the socket
    sinhimControl.sin_family = AF_INET;
    if (fSender) {
        // if we're the sender, keep trying to connect until we get through
        dwAddrSize = MAX_STRING;
        dwError = WSAAddressToString((SOCKADDR *)&(sinhimControl),
                               sizeof(SOCKADDR_IN),
                               NULL,
                               szAddr,
                               &dwAddrSize);
        if (dwError == SOCKET_ERROR)
            ErrorExit("WSAAddressToString failed", WSAGetLastError());
        else
            strcpy(szHisAddr,szAddr);
        
        while (TRUE) {
            dwError = connect(sockControl,(SOCKADDR*)&sinhimControl,sizeof(sinhimControl));
            if (!dwError) {
                printf("control socket: connected to %s\n",szAddr);
                break;
            }
            dwError = WSAGetLastError();
            if (dwError != WSAECONNREFUSED) {
                ErrorExit("connect() failed",dwError);
            }
            Sleep(500); // wait a half second between attempts
        }
    }
    else {
        // if we're the receiver, listen / accept
        if (listen(sockListen, SOMAXCONN) == SOCKET_ERROR) {
            ErrorExit("listen() failed", WSAGetLastError());
        }

        sockControl = accept(sockListen, (SOCKADDR*)&sinhimControl, &dwAddrSize);
        // once we've accepted, close the listen socket
        closesocket(sockListen);
        if ((INT_PTR)sockControl < 0) {
            ErrorExit("accept() failed",WSAGetLastError());
        }
        
        dwAddrSize = MAX_STRING;    
        dwError = WSAAddressToString((SOCKADDR *)&(sinhimControl),
                               sizeof(SOCKADDR_IN),
                               NULL,
                               szAddr,
                               &dwAddrSize);
        if (dwError == SOCKET_ERROR)
            ErrorExit("WSAAddressToString failed", WSAGetLastError());
        else
            strcpy(szHisAddr, szAddr);
        
        printf("control socket: accepted connection from %s\n",szAddr);
    }

    // set our global control socket variable
    g_sockControl = sockControl;

    // record my name
    dwAddrSize = sizeof(SOCKADDR_IN);
    getsockname(sockControl,(SOCKADDR *)&(sinmeControl),&dwAddrSize);
    dwAddrSize = MAX_STRING;    
    dwError = WSAAddressToString((SOCKADDR *)&(sinmeControl),
                    sizeof(SOCKADDR_IN), NULL, szAddr, &dwAddrSize);
    if (dwError == SOCKET_ERROR)
        ErrorExit("WSAAddressToString failed", WSAGetLastError());
    else
        strcpy(szMyAddr, szAddr);  
        
    // exchange version information
    sprintf(szBuf, "%s %s", MSGST_VER, VERSION_STRING);
    SendControlMessage(sockControl, szBuf);
    
    // now that we're all set, do the actual work of the control socket
    while (!fDone) {
        ZeroMemory(szBuf,MAX_STRING);
        dwError = cbBuf = recv(sockControl, szBuf, MAX_STRING, 0);
        pchStart = szBuf;
        pchEnd = szBuf + cbBuf;
        if (dwError == 0) { // the connection's been gracefully closed
            fDone = TRUE;
            closesocket(sockControl);
            g_fOtherSideFinished=TRUE;
            ExitThread(0);
        }
        if (dwError == SOCKET_ERROR) {
            dwError = WSAGetLastError();
            if (dwError == WSAECONNRESET) {
                printf("\ncontrol socket: connection reset by peer");
                printf("\n\t%I64us since last HELLO packet received",
                    (GetUserTime() - ui64LastHello)/10000000);
                printf("\n\t%I64us since start",
                    (GetUserTime() - timeStart)/10000000);
                g_state.Done = TRUE;
                fDone = TRUE;
                g_fOtherSideFinished = TRUE;
                closesocket(sockControl);
                ExitThread(1);
            }
            else {
                printf("\ncontrol socket: error in recv: %d\n",dwError);
                g_state.Done = TRUE;
                fDone = TRUE;
                g_fOtherSideFinished = TRUE;
                closesocket(sockControl);
                ExitThread(1);
            }
            continue;
        }
        while (pchStart < pchEnd) {
            ZeroMemory(szCommand,MAX_STRING);
            // consume the first command and act on it
            if (pchEnd > szBuf + cbBuf) break;
            pchEnd = strchr(pchStart, MSGCH_DELIMITER);
            if (pchEnd == NULL) break;
            strncpy(szCommand,pchStart,pchEnd - pchStart);
            if (strcmp(szCommand,MSGST_HELLO) == 0) {
                // update last hello time
                ui64LastHello = GetUserTime();
                // i should do something like set a timer here that sleeps until a certain timeout
                // passes, at which point it aborts our transfer
            }
            if (strcmp(szCommand,MSGST_ERROR) == 0) {
                // the other guy's had an error, so we stop and tell him to abort
                g_fOtherSideFinished = TRUE;
                g_state.Done = TRUE;
                fDone = TRUE;
                SendControlMessage(sockControl,MSGST_ABORT);
                closesocket(sockControl);
                ExitThread(1);
            }
            if (strcmp(szCommand,MSGST_ABORT) == 0) {
                // we're told to abort, so do so
                g_fOtherSideFinished = TRUE;
                g_state.Done = TRUE;
                fDone = TRUE;
                closesocket(sockControl);
                ExitThread(1);
            }
            if (strcmp(szCommand,MSGST_DONE) == 0) {
                // we're told the other guy's done, so therefore are we
                closesocket(sockControl);
                g_fOtherSideFinished = TRUE;
                g_state.Done = TRUE;
                fDone = TRUE;
                ExitThread(1);
            }
            if (strcmp(szCommand,MSGST_RSVPERR) == 0) {
                // we're told the other guy got an rsvp error, so we abort the whole program
                closesocket(sockControl);
                g_fOtherSideFinished = TRUE;
                g_state.Done = TRUE;
                fDone = TRUE;
                exit(1);
            }
            if (strncmp(szCommand,MSGST_SIZE,4) == 0) {
                // the sender is telling us how big the buffers are
                sscanf(szCommand,"%s %d",szT, &g_params.buflen);
                fGotSize = TRUE;
            }
            if (strncmp(szCommand,MSGST_RATE,4) == 0) {
                // the sender is telling us how fast the buffers are coming
                sscanf(szCommand, "%s %d",szT, &g_params.TokenRate);
                fGotRate = TRUE;
            }
            if (strncmp(szCommand,MSGST_NUM,3) == 0) {
                // the sender is telling us how many buffers it's sending
                sscanf(szCommand, "%s %d",szT, &g_params.nbuf);
                totalBuffers = g_params.nbuf;
                fGotNum = TRUE;
            }
            if (strncmp(szCommand,MSGST_VER,3) == 0) {
                sscanf(szCommand, "%s %s",szT, szT2);
                if (strcmp(szT2,VERSION_STRING) != 0) {
                    printf("WARNING: remote machine using different version of qtcp: %s vs. %s\n", 
                        szT2,VERSION_STRING);
                }
            }
            if (trans) {
                if (strcmp(szCommand,MSGST_READY) == 0) {
                    g_fReadyForXmit = TRUE;
                }
            }
            else {
                if (!fSentReady && fGotRate && fGotSize && fGotNum) {
                    SendControlMessage(sockControl, MSGST_READY);
                    fSentReady = TRUE;
                    g_fReadyForXmit = TRUE;
                }
            }
            pchStart = pchEnd + 1;
            pchEnd = szBuf + cbBuf;
        }    
    }
    return 0;
}

int SendControlMessage(SOCKET sock, char * szMsg) {
    int iResult;
    char szBuf[MAX_STRING];

    sprintf(szBuf,"%s%c",szMsg,MSGCH_DELIMITER);
    iResult = send (sock, szBuf, strlen(szBuf), 0);

    if (iResult == SOCKET_ERROR) {
        return WSAGetLastError();
    }
    return iResult;
}

void ErrorExit(char *msg, DWORD dwErrorNumber) {
    fprintf(stderr,"ERROR: %d\n",dwErrorNumber);
    if (msg != NULL)
        fprintf(stderr,"\t%s\n",msg);
    else {
        switch(dwErrorNumber) {
        case WSAEFAULT:
            fprintf(stderr,"\tWSAEFAULT: Buffer too small to contain name\n");
            break;
        case WSAEINVAL:
            fprintf(stderr,"\tWSAEINVAL: Invalid socket address\n");
            break;
        case WSANOTINITIALISED:
            fprintf(stderr,"\tWSANOTINITIALIZED: WSA Not initialized\n");
            break;
        default:
            fprintf(stderr,"\tUnknown error\n");
            break;
        }
    }
    SendControlMessage(g_sockControl, MSGST_ABORT);
    
    DestroyLog(&g_log);
    WSACleanup();
    exit(1);
    _exit(1);
}

// some math utility functions

// comparison for doubles (to use in qsort)
int __cdecl compare( const void *arg1, const void *arg2 )
{
    DOUBLE dTemp;
    DOUBLE d1 = * (DOUBLE *) arg1;
    DOUBLE d2 = * (DOUBLE *) arg2;
    dTemp = d1 - d2;
    if (dTemp < 0) return -1;
    if (dTemp == 0) return 0;
    else 
        return 1;

}
// comparison for ints (to use in qsort)
int __cdecl compareint( const void *arg1, const void *arg2 )
{
    int nTemp;
    int n1 = * (int *) arg1;
    int n2 = * (int *) arg2;
    nTemp = n1 - n2;
    if (nTemp < 0) return -1;
    if (nTemp == 0) return 0;
    else 
      return 1;
}
// comparison for int64s (to use in qsort)
int __cdecl compareI64( const void *arg1, const void *arg2 )
{
    INT64 nTemp;
    INT64 n1 = * (INT64 *) arg1;
    INT64 n2 = * (INT64 *) arg2;
    nTemp = n1 - n2;
    if (nTemp < 0) return -1;
    if (nTemp == 0) return 0;
    else return 1;
}


#define EPS 1.0e-7
// sum up error function for given value of b
double rofunc(double b, int N, double yt[], double xt[], double * paa, double * pabdevt) {
    int i;
    double *pfT;
    double d, sum=0.0;
    double aa = *paa;
    double abdevt = *pabdevt;

    pfT = malloc(sizeof(double) * N);
    for (i = 0; i < N; i++) pfT[i] = yt[i]-b*xt[i];
    qsort(pfT, N, sizeof(DOUBLE), compare);
    if (N & 1) { // odd N
        aa = pfT[(N+1) / 2];
    }
    else {
        i = N / 2;
        aa = 0.5 * (pfT[i] + pfT[i+1]);
    }
    abdevt = 0.0;
    for (i = 0; i<N; i++) {
        d = yt[i] - (b*xt[i]+aa);
        abdevt += fabs(d);
        if (yt[i] != 0.0) d /= fabs(yt[i]);
        if (fabs(d) > EPS) sum += (d >= 0.0 ? xt[i]: -xt[i]);
    }
    *paa = aa;
    *pabdevt = abdevt;
    free(pfT);
    return sum;
}

#define SIGN(a,b) ((b) >= 0 ? fabs(a) : fabs(-a))

void medfit(double x[], double y[], int N, double *a, double *b, double *abdev) {
    // fit y = a + bx to least absolute deviation. abdev is mean absolute deviation.
    // incoming, a and b are treated as starting guesses
    int i;
    double *xt = x;
    double *yt = y;
    double sx, sy, sxy, sxx, chisq;
    double del, sigb;
    double bb, b1, b2, aa, abdevt, f, f1, f2, temp;

    sx = sy = sxy = sxx = chisq = 0.0;
    // we find chisq fit to use as starting guess
    for (i=0; i<N; i++) {
        sx += x[i];
        sy += y[i];
        sxy += x[i]*y[i];
        sxx += x[i]*x[i];
    }
    del = N*sxx - sx*sx;
    aa = (sxx*sy-sx*sxy) / del;
    bb = (N*sxy - sx*sy) / del;
    // do the absolute deviation fit, if we're supposed to.
    if (g_params.SkewFitMode == 2) { 
        for (i=0; i<N; i++)
            chisq += (temp=y[i]-(aa+bb*x[i]), temp*temp);
        sigb = sqrt(chisq/del);
        b1 = bb;
        f1 = rofunc(b1, N, yt, xt, &aa, &abdevt);
        // guess the bracket as 3 sigma away in downhill direction from f1
        b2 = bb + SIGN(3.0 * sigb, f1);
        f2 = rofunc(b2, N, yt, xt, &aa, &abdevt);
        if (b2 == b1) {
            *a = aa;
            *b = bb;
            *abdev = abdevt / N;
            return;
        }
        // Bracketing
        while ((f1*f2) > 0.0) {
            if (fabs(f1) < fabs(f2))
                f1 = rofunc(b1 += 1.6*(b1-b2),N,yt,xt,&aa,&abdevt);
            else
                f2 = rofunc(b2 += 1.6*(b2-b1),N,yt,xt,&aa,&abdevt);
        }
        
        sigb = 0.000001 * sigb; // refine
        while (fabs(b2 - b1) > sigb) {
            bb = b1 + 0.5 * (b2 - b1);
            if (bb == b1 || bb == b2) break;
            f = rofunc(bb, N, yt, xt, &aa, &abdevt);
            if (f*f1 >= 0.0) {
                f1 = f;
                b1 = bb;
            } else {
                f2 = f;
                b2 = bb;
            }
        }
    }
    
    *a = aa;
    *b = bb;
    *abdev = abdevt / N;
}

double mode(const double data[], const int N) {
    // finds and returns the mode of the N points in data
    double * sorted;
    double mode, cur=0;
    int cMode, cCur;
    int i;

    sorted = malloc(N * sizeof(double));

    for (i=0; i<N; i++) sorted[i] = data[i];
    qsort(sorted, N, sizeof(double), compare);
    mode = sorted[0];
    cMode = cCur = 0;
    for (i=0; i<N; i++) {
        if (cCur > cMode) {
            mode = cur;
            cMode = cCur;
        }
        if (sorted[i] == mode) {
            cMode++;
        } else {
            if (sorted[i] == cur) cCur++;
            else {
                cur = sorted[i];
                cCur = 1;
            }
        }
    }
    
    free(sorted);
    return mode;
}

void RemoveDuplicates(int rg[], int * pN) {
    // this removes duplicates from the array passed in and returns it with *pN = #remaining
    // it makes no guarantees about elements after rg[#remaining]
    int *pNewArray;
    int cNew;
    int i;
    
    qsort(rg,*pN,sizeof(int),compareint);
    pNewArray = malloc(sizeof(int) * *pN);
    pNewArray[0] = rg[0];
    cNew = 1;
    for (i=1; i<*pN; i++) {
        if (rg[i] != pNewArray[cNew - 1]) {
            pNewArray[cNew++] = rg[i];
        }
    }
    *pN = cNew;
    for (i=0; i<cNew; i++)
        rg[i] = pNewArray[i];
}

void RemoveDuplicatesI64(INT64 rg[], int * pN) {
    // this removes duplicates from the array passed in and returns it with *pN = #remaining
    // it makes no guarantees about elements after rg[#remaining]
    INT64 *pNewArray;
    int cNew;
    int i;
    
    qsort(rg,*pN,sizeof(INT64),compareI64);
    pNewArray = malloc(sizeof(INT64) * *pN);
    pNewArray[0] = rg[0];
    cNew = 1;
    for (i=1; i<*pN; i++) {
        if (rg[i] != pNewArray[cNew - 1]) {
            pNewArray[cNew++] = rg[i];
        }
    }
    *pN = cNew;
    for (i=0; i<cNew; i++)
        rg[i] = pNewArray[i];
}

void PrintFlowspec(LPFLOWSPEC lpfs) {
    printf("TokenRate:          %lu bytes/sec\n",lpfs->TokenRate);
    printf("TokenBucketSize:    %lu bytes\n",lpfs->TokenBucketSize);
    printf("PeakBandwidth:      %lu bytes/sec\n",lpfs->PeakBandwidth);
    printf("Latency:            %lu microseconds\n",lpfs->Latency);
    printf("DelayVariation:     %lu microseconds\n",lpfs->DelayVariation);
    printf("ServiceType:        %X\n",lpfs->ServiceType);
    printf("MaxSduSize:         %lu bytes\n",lpfs->MaxSduSize);
    printf("MinimumPolicedSize: %lu bytes\n",lpfs->MinimumPolicedSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\tools\timestmp\timestmp.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    timestmp.c

Abstract:

    Timestamper module

Author:
    Shreedhar Madhavapeddi (shreem)

Revision History:

--*/

#include <timestmp.h>

//
// The following struct has to be in ssync with
// ndis\trfccntl\tools\qtcp\qtcp.c
//
typedef struct _LOG_RECORD{
    UINT64  TimeSent;
    UINT64  TimeReceived;
    UINT64  TimeSentWire;         // These fields are used by the kernel timestamper
    UINT64  TimeReceivedWire;     // These fields are used by the kernel timestamper
    UINT64  Latency;
    INT     BufferSize;
    INT     SequenceNumber;
} LOG_RECORD, *PLOG_RECORD;

ULONG           GlobalSequenceNumber = 0;        

// 321618 needs checking for PSCHED's existence.
NDIS_STRING     PschedDriverName           = NDIS_STRING_CONST("\\Device\\PSched");
HANDLE          PschedHandle;
NTSTATUS CheckForPsched(VOID);

	
//
// TCP Headers (redefined here, since there are no exported headers
//
#define IP_OFFSET_MASK          ~0x00E0         // Mask for extracting offset field.
#define net_short(x) ((((x)&0xff) << 8) | (((x)&0xff00) >> 8))

/*
 * Protocols (from winsock.h)
 */
#define IPPROTO_IP              0               /* dummy for IP */
#define IPPROTO_ICMP            1               /* control message protocol */
#define IPPROTO_IGMP            2               /* group management protocol */
#define IPPROTO_GGP             3               /* gateway^2 (deprecated) */
#define IPPROTO_TCP             6               /* tcp */
#define IPPROTO_PUP             12              /* pup */
#define IPPROTO_UDP             17              /* user datagram protocol */
#define IPPROTO_IDP             22              /* xns idp */
#define IPPROTO_ND              77              /* UNOFFICIAL net disk proto */
#define IPPROTO_IPSEC                   51              /* ???????? */

#define IPPROTO_RAW             255             /* raw IP packet */
#define IPPROTO_MAX             256

#define IP_MF_FLAG                          0x0020              // 'More fragments flag'
#define IP_VERSION                      0x40
#define IP_VER_FLAG                     0xF0


#define TCP_OFFSET_MASK 0xf0
#define TCP_HDR_SIZE(t) (uint)(((*(uchar *)&(t)->tcp_flags) & TCP_OFFSET_MASK) >> 2)

typedef int             SeqNum;                         // A sequence number.


struct TCPHeader {
        ushort                          tcp_src;                        // Source port.
        ushort                          tcp_dest;                       // Destination port.
        SeqNum                          tcp_seq;                        // Sequence number.
        SeqNum                          tcp_ack;                        // Ack number.
        ushort                          tcp_flags;                      // Flags and data offset.
        ushort                          tcp_window;                     // Window offered.
        ushort                          tcp_xsum;                       // Checksum.
        ushort                          tcp_urgent;                     // Urgent pointer.
};

typedef struct TCPHeader TCPHeader;

struct UDPHeader {
        ushort          uh_src;                         // Source port.
        ushort          uh_dest;                        // Destination port.
        ushort          uh_length;                      // Length
        ushort          uh_xsum;                        // Checksum.
}; /* UDPHeader */

typedef struct UDPHeader UDPHeader;

#ifdef DBG
//
// Define the Trace Level.
//
#define TS_DBG_DEATH               1
#define TS_DBG_TRACE               2

//
// Masks
//
#define TS_DBG_PIPE      0x00000001
#define TS_DBG_FLOW      0x00000002
#define TS_DBG_SEND      0x00000004
#define TS_DBG_RECV      0x00000008
#define TS_DBG_INIT      0x00000010
#define TS_DBG_OID       0x00000020
#define TS_DBG_CLASS_MAP 0x00000040

ULONG DbgTraceLevel = 1;
ULONG DbgTraceMask  = 0x8;

#define TimeStmpTrace(_DebugLevel, _DebugMask, _Out) \
    if ((DbgTraceLevel >= _DebugLevel) &&           \
        ((_DebugMask) & DbgTraceMask)){             \
        DbgPrint("TimeStamp: ");                       \
        DbgPrint _Out;                              \
    }

#else // DBG
#define TimeStmpTrace
#endif

#define         PORT_RANGE  20
USHORT          IPIDList[PORT_RANGE];
NDIS_SPIN_LOCK  IPIDListLock;

#define         PORT_RANGE  20
USHORT          IPIDListRecv[PORT_RANGE];
NDIS_SPIN_LOCK  IPIDListLockRecv;

/*
Let's create a driver unload function, so that timestmp is stoppable via net sto
p timestmp
*/
VOID
TimeStmpUnload(
               IN PDRIVER_OBJECT DriverObject
               )
{

	IoctlCleanup();
    return;

}

NDIS_STATUS
TimeStmpInitializePipe (
    IN HANDLE PsPipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters,
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_PROCS PsProcs,
    IN PPS_UPCALLS Upcalls
    )
{
    PPS_PIPE_CONTEXT Pipe = ComponentPipeContext;

    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_PIPE, ("[TimeStmpIndicatePipe]: \n"));
    return (*Pipe->NextComponent->InitializePipe)(
        PsPipeContext,
        PipeParameters,
        Pipe->NextComponentContext,
        PsProcs,
        Upcalls);
}

NDIS_STATUS
TimeStmpModifyPipe (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters
    )
{
    PPS_PIPE_CONTEXT Pipe = PipeContext;
    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_PIPE, ("[TimeStmpModifyPipe]: \n"));
    return (*Pipe->NextComponent->ModifyPipe)(
        Pipe->NextComponentContext, PipeParameters);
}

VOID
TimeStmpDeletePipe (
    IN PPS_PIPE_CONTEXT PipeContext
    )
{
    PPS_PIPE_CONTEXT Pipe = PipeContext;
    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_PIPE, ("[TimeStmpDeletePipe]: \n"));
    (*Pipe->NextComponent->DeletePipe)(Pipe->NextComponentContext);
}


NDIS_STATUS
TimeStmpCreateFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsFlowContext,
    IN PCO_CALL_PARAMETERS CallParameters,
    IN PPS_FLOW_CONTEXT ComponentFlowContext
    )
{
    PPS_PIPE_CONTEXT Pipe = PipeContext;

    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_FLOW, ("[TimeStmpCreateFlow]: \n"));
    return (*Pipe->NextComponent->CreateFlow)(
                Pipe->NextComponentContext,
                PsFlowContext,
                CallParameters,
                ComponentFlowContext->NextComponentContext);
}


NDIS_STATUS
TimeStmpModifyFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PCO_CALL_PARAMETERS CallParameters
    )
{
    PPS_PIPE_CONTEXT Pipe = PipeContext;
    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_FLOW, ("[TimeStmpModifyFlow]: \n"));
    return (*Pipe->NextComponent->ModifyFlow)(
                Pipe->NextComponentContext,
                FlowContext->NextComponentContext,
                CallParameters);
    
}


VOID
TimeStmpDeleteFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext
    )
{
    PPS_PIPE_CONTEXT Pipe = PipeContext;
    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_FLOW, ("[TimeStmpDeleteFlow]: \n"));
    (*Pipe->NextComponent->DeleteFlow)(
        Pipe->NextComponentContext,
        FlowContext->NextComponentContext);
}


BOOLEAN
TimeStmpSubmitPacket (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PPS_CLASS_MAP_CONTEXT ClassMapContext,
    IN PPACKET_INFO_BLOCK PacketInfo
    )
{
    PPS_PIPE_CONTEXT    Pipe = PipeContext;
    LARGE_INTEGER       CurrentTime;
    IPHeader UNALIGNED  *IPH    = NULL;
    TCPHeader UNALIGNED *TCPH   = NULL;
    UDPHeader UNALIGNED *UDPH   = NULL;
    PVOID               ArpH    = NULL, GeneralVA = NULL, Data = NULL;
    IPAddr              Src, Dst;
    PNDIS_BUFFER        ArpBuf = NULL, IpBuf = NULL, TcpBuf = NULL, DataBuf = NULL, UdpBuf = NULL;
    ULONG               ArpLen = 0, IpLen = 0, IpHdrLen = 0, TcpLen = 0, DataLen = 0, TotalLen = 0, TcpHeaderOffset = 0;
    ULONG               UdpLen = 0;
    USHORT              SrcPort = 0, DstPort = 0, IPID = 0, FragOffset = 0;
    PLIST_ENTRY         CurrentEntry = NULL, LastEntry = NULL;
    BOOLEAN             bFragment, bFirstFragment, bLastFragment;
    ULONG               i = 0;
    PLOG_RECORD         pRecord = NULL;
    PNDIS_PACKET        Packet = PacketInfo->NdisPacket;

    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_SEND, ("[TimeStmpSubmitPacket]: \n"));
    
    //
    // Steps  
    // Parse the IP Packet. 
    // Look for the appropriate ports.
    // Look for the data portion and put in the Time & length there.
    //

    NdisGetFirstBufferFromPacket(
                                 Packet,
                                 &ArpBuf,
                                 &ArpH,
                                 &ArpLen,
                                 &TotalLen
                                 );

    //
    // We are guaranteed that the ARP buffer if always a different MDL, so
    // jump to the next MDL
    //
    NdisGetNextBuffer(ArpBuf, &IpBuf)

    if (IpBuf) {

        NdisQueryBuffer(IpBuf,
                        &GeneralVA,
                        &IpLen
                        );
        
        IPH = (IPHeader *) GeneralVA;
    
        if (!IPH) {
            goto FAILURE;
        }

        Src = net_short(IPH->iph_src);
        Dst = net_short(IPH->iph_dest);
        IPID = net_short(IPH->iph_id);
        //IpHdrLen = 8 * net_short(IPH->iph_length);
        IpHdrLen = ((IPH->iph_verlen & (uchar)~IP_VER_FLAG) << 2);
        
        FragOffset = IPH->iph_offset & IP_OFFSET_MASK;
        FragOffset = net_short(FragOffset) * 8;

        bFragment = (IPH->iph_offset & IP_MF_FLAG) || (FragOffset > 0);
        bFirstFragment = bFragment && (FragOffset == 0);
        bLastFragment = bFragment && (!(IPH->iph_offset & IP_MF_FLAG));

        if (bFragment && (!bFirstFragment)) {
            
            //
            // Its a fragment alright and NOT the first one.
            //
            NdisAcquireSpinLock(&IPIDListLock);

            for (i = 0; i < PORT_RANGE; i++) {
            
                //
                // Found the match...
                //
                if (IPIDList[i] == IPID) {
                
                    if (bLastFragment) {
                        //
                        // Since it is the last fragment, recall
                        // the IP ID.
                        //
                        IPIDList[i] = 0xffff;
                    }

                    NdisReleaseSpinLock(&IPIDListLock);
                    
                    //
                    // Is the data in the same buffer?
                    //
                    if (IpLen <= IpHdrLen) {
                        
                        NdisGetNextBuffer(IpBuf, &DataBuf);
            
                        if(DataBuf) {
            
                            NdisQueryBuffer(DataBuf,
                                            &Data,
                                            &DataLen
                                            );

                            goto TimeStamp;
        
                        } else {
        
                            goto FAILURE;
                        }


                    } else {

                        //
                        // The Data Offsets need to be primed now.
                        //
                        DataLen = IpLen - FragOffset;
                        Data    = ((PUCHAR) GeneralVA) + IpHdrLen; 
                        goto TimeStamp;
                    }
                }
            }

            NdisReleaseSpinLock(&IPIDListLock);
            //
            // If we are here, we dont care about this IPID for this fragment.
            // Just return TRUE to continue processing.
            //
            
            //
            // Ready to go.
            //
            PacketInfo->FlowContext = FlowContext;
            PacketInfo->ClassMapContext = ClassMapContext;

            return (*Pipe->NextComponent->SubmitPacket)(
                                                 Pipe->NextComponentContext,
                                                 FlowContext->NextComponentContext, 
                                                 ClassMapContext?ClassMapContext->NextComponentContext:0,
                                                 PacketInfo);

        }

        //
        // If it is not a fragment, depending upon the protocol, process differently
        //

        switch (IPH->iph_protocol) {
        
        case IPPROTO_TCP :
            
            TimeStmpTrace(TS_DBG_TRACE, TS_DBG_SEND, ("[TimeStmpSubmitPacket]: Procol TCP\n"));

            if (IPH && ((USHORT)IpLen > IpHdrLen)) {

                //
                // We have more than the IP Header in this MDL.
                //
                TCPH = (TCPHeader *) ((PUCHAR)GeneralVA + IpHdrLen);
                TcpLen = IpLen - IpHdrLen;
                TcpBuf = IpBuf;

            } else {
                
                //
                // TCP Header is in the next MDL
                //
                
                NdisGetNextBuffer(IpBuf, &TcpBuf);
    
                if(TcpBuf) {
    
                    GeneralVA = NULL;
                    NdisQueryBuffer(TcpBuf,
                                    &GeneralVA,
                                    &TcpLen
                                    );
                
                    TCPH = (TCPHeader *) GeneralVA;
                } else {

                    goto FAILURE;

                }
            }

            //
            // Get the port numbers out.
            //
            SrcPort = net_short(TCPH->tcp_src);
            DstPort = net_short(TCPH->tcp_dest);

            //
            // We have the TCP Buffer now. Get to the DATA.
            //
            TcpHeaderOffset = TCP_HDR_SIZE(TCPH);

            if (TcpLen > TcpHeaderOffset) {

                //
                // We have the DATA right here!
                //

                Data = (PUCHAR)TCPH + TcpHeaderOffset;
                DataLen = TcpLen - TcpHeaderOffset;

            } else {
            
                NdisGetNextBuffer(TcpBuf, &DataBuf);
    
                if(DataBuf) {
    
                    GeneralVA = NULL;
                    NdisQueryBuffer(DataBuf,
                                    &Data,
                                    &DataLen
                                    );

                } else {

                    goto FAILURE;
                }
            }

            if (CheckInPortList(DstPort) && bFirstFragment) {

                NdisAcquireSpinLock(&IPIDListLock);
                
                // need new Entry for IPID
                for (i = 0; i < PORT_RANGE; i++) {
                    //
                    // Look for a free slot
                    //
                    if (0xffff == IPIDList[i]) {
                        
                        IPIDList[i] = IPID;
                        break;
                    
                    }


                }

                NdisReleaseSpinLock(&IPIDListLock);
                
                if (i == PORT_RANGE) {

                   TimeStmpTrace(TS_DBG_DEATH, TS_DBG_SEND, ("Couldn't find an empty IPID - Bailing \n"));
                   goto FAILURE;
                }
                //DbgBreakPoint();

            } 
            
            //
            // Let's timestmp this now.
            //
            if (CheckInPortList(DstPort)) {

                goto TimeStamp;

            } else {

                //
                // This is not one of our packet, get out.
                // 
                goto FAILURE;
            }

            break;

        case IPPROTO_UDP:
            
            TimeStmpTrace(TS_DBG_TRACE, TS_DBG_SEND, ("[TimeStmpSubmitPacket]: Protocol UDP\n"));

            if (IPH && (IpLen > IpHdrLen)) {

                //
                // We have more than the IP Header in this MDL.
                //
                UDPH = (UDPHeader *) ((PUCHAR)GeneralVA + IpHdrLen);
                UdpLen = IpLen - IpHdrLen;
                UdpBuf = IpBuf;

            } else {
                
                //
                // UDP Header is in the next MDL
                //
    
                NdisGetNextBuffer(IpBuf, &UdpBuf);

                if(UdpBuf) {

                    GeneralVA = NULL;
                    NdisQueryBuffer(UdpBuf,
                                    &GeneralVA,
                                    &UdpLen
                                    );
    
                    UDPH = (UDPHeader *) GeneralVA;
                } else {
                    
                    goto FAILURE;

                }
            }

            SrcPort = net_short(UDPH->uh_src);      // Source port.
            DstPort = net_short(UDPH->uh_dest);         // Destination port.


            //
            // Get to the data. 
            //
            if (UdpLen > sizeof (UDPHeader)) {

                //
                // We have the DATA right here!
                //
                Data = (PUCHAR) UDPH + sizeof (UDPHeader);
                DataLen = UdpLen - sizeof (UDPHeader);

            } else {

                NdisGetNextBuffer(UdpBuf, &DataBuf);

                if(DataBuf) {

                    GeneralVA = NULL;
                    NdisQueryBuffer(DataBuf,
                                    &Data,
                                    &DataLen
                                    );

                } else {

                    goto FAILURE;

                }
            }


            if (CheckInPortList(DstPort) && bFirstFragment) {

                NdisAcquireSpinLock(&IPIDListLock);
                
                // need new Entry for IPID
                for (i = 0; i < PORT_RANGE; i++) {
                    //
                    // Look for a free slot
                    //
                    if (0xffff == IPIDList[i]) {
                        
                        IPIDList[i] = IPID;
                        break;
                    
                    }

                    ASSERT(FALSE);

                }

                NdisReleaseSpinLock(&IPIDListLock);
                
                //
                // Couldnt find a free IPID place holder, lets bail.
                //
                if (PORT_RANGE == i) {

                    goto FAILURE;

                }

            } 
            
            
            
            //
            // Let's timestmp this now.
            //
            if (CheckInPortList(DstPort)) {

                goto TimeStamp;

            } else {

                //
                // This is not one of our packet, get out.
                // 
                goto FAILURE;
            }

            break;

        case IPPROTO_RAW:
            
            TimeStmpTrace(TS_DBG_TRACE, TS_DBG_SEND, ("[TimeStmpSubmitPacket]: Protocol RAW\n"));
            goto FAILURE;

            break;
        
        case IPPROTO_IGMP:
            
            TimeStmpTrace(TS_DBG_TRACE, TS_DBG_SEND, ("[TimeStmpSubmitPacket]: Protocol IGMP\n"));
            goto FAILURE;

            break;
        
        case IPPROTO_ICMP:

            TimeStmpTrace(TS_DBG_TRACE, TS_DBG_SEND, ("[TimeStmpSubmitPacket]: Protocol TCMP\n"));
            goto FAILURE;

            break;

        default:
            
            //TimeStmpTrace(TS_DBG_DEATH, TS_DBG_SEND, ("[TimeStmpSubmitPacket]: Protocol - UNKNOWN (%d)\n", IPH->iph_protocol));
            goto FAILURE;

            //DbgBreakPoint();

        }

    } else {

        TimeStmpTrace(TS_DBG_TRACE, TS_DBG_SEND, ("[TimeStmpSubmitPacket]: NO Buffer beyond MAC Header\n"));
        goto FAILURE;

    }

TimeStamp:
    //
    // If we get here, the Data and DataLen variables have been primed.
    // Set the Time and Length.
    //
    if (Data) {
        
        pRecord = (PLOG_RECORD) Data;
        
        if (DataLen > sizeof (LOG_RECORD)) {
            
            LARGE_INTEGER   PerfFrequency;
            UINT64          Freq;

            //
            // Set the fields accordingly
            pRecord->BufferSize = DataLen;
            //pRecord->SequenceNumber = InterlockedIncrement(&GlobalSequenceNumber);
            CurrentTime = KeQueryPerformanceCounter(&PerfFrequency);

            //
            // Convert the perffrequency into 100ns interval.
            //
            Freq = 0;
            Freq |= PerfFrequency.HighPart;
            Freq = Freq << 32;
            Freq |= PerfFrequency.LowPart;


            //
            // Convert from LARGE_INTEGER to UINT64
            //
            pRecord->TimeSentWire = 0;
            pRecord->TimeSentWire |= CurrentTime.HighPart;
            pRecord->TimeSentWire = pRecord->TimeSentWire << 32;
            pRecord->TimeSentWire |= CurrentTime.LowPart;

            // Normalize cycles with the frequency.
            pRecord->TimeSentWire *= 10000000;
            pRecord->TimeSentWire /= Freq;

        }
    
    }
    //
    // Ready to go.
    //
    PacketInfo->FlowContext = FlowContext;
    PacketInfo->ClassMapContext = ClassMapContext;

    return (*Pipe->NextComponent->SubmitPacket)(
        Pipe->NextComponentContext,
        FlowContext->NextComponentContext, 
        ClassMapContext?ClassMapContext->NextComponentContext:0,
        PacketInfo);

FAILURE: 

    //
    // Ready to go.
    //
    PacketInfo->FlowContext = FlowContext;
    PacketInfo->ClassMapContext = ClassMapContext;

    return (*Pipe->NextComponent->SubmitPacket)(
        Pipe->NextComponentContext,
        FlowContext->NextComponentContext, 
        ClassMapContext?ClassMapContext->NextComponentContext:0,
        PacketInfo);

}


BOOLEAN
TimeStmpReceivePacket (
    IN PPS_PIPE_CONTEXT         PipeContext,
    IN PPS_FLOW_CONTEXT         FlowContext,
    IN PPS_CLASS_MAP_CONTEXT    ClassMapContext,
    IN PNDIS_PACKET             Packet,
    IN NDIS_MEDIUM              Medium
    )
{
    PPS_PIPE_CONTEXT    Pipe = PipeContext;
    LARGE_INTEGER       CurrentTime;
    IPHeader UNALIGNED  *IPH    = NULL;
    TCPHeader UNALIGNED *TCPH   = NULL;
    UDPHeader UNALIGNED *UDPH   = NULL;
    IPAddr              Src, Dst;
    PUCHAR              headerBuffer = NULL, pData = NULL;
    PNDIS_BUFFER        pFirstBuffer = NULL;
    ULONG               firstbufferLength = 0, bufferLength = 0, HeaderLength = 0;
    ULONG               TotalIpLen = 0, IPDataLength = 0, IpHdrLen = 0;
    ULONG               TotalTcpLen = 0, TcpDataLen = 0, TotalLen = 0, TcpHeaderOffset = 0, Size = 0;
    ULONG               TotalUdpLen = 0, UdpDataLen = 0, UdpHdrLen = 0;
    USHORT              SrcPort = 0, DstPort = 0, IPID = 0, FragOffset = 0;
    BOOLEAN             bFragment, bFirstFragment, bLastFragment;
    ULONG               i = 0;
    PLOG_RECORD         pRecord = NULL;
    UINT  HeaderBufferSize = NDIS_GET_PACKET_HEADER_SIZE(Packet);

    ushort          type;                       // Protocol type
    uint            ProtOffset;                 // Offset in Data to non-media info.

    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV, ("[TimeStmpReceivePacket]: \n"));

    NdisGetFirstBufferFromPacket(Packet,                // packet
                                 &pFirstBuffer,         // first buffer descriptor
                                 &headerBuffer,         // ptr to the start of packet
                                 &firstbufferLength,    // length of the header+lookahead
                                 &bufferLength);        // length of the bytes in the buffers

    IPH = (IPHeader *) ((PUCHAR)headerBuffer + HeaderBufferSize);
    
    // Check the header length and the version. If any of these
    // checks fail silently discard the packet.
    HeaderLength = ((IPH->iph_verlen & (uchar)~IP_VER_FLAG) << 2);


    if (HeaderLength >= sizeof(IPHeader) && HeaderLength <= bufferLength) {

        //
        // Get past the IP Header and get the rest of the stuff out.
        //
        TotalIpLen = (uint)net_short(IPH->iph_length);

        if ((IPH->iph_verlen & IP_VER_FLAG) == IP_VERSION &&
            TotalIpLen >= HeaderLength  && TotalIpLen <= bufferLength) {

            Src = net_short(IPH->iph_src);
            Dst = net_short(IPH->iph_dest);
            IPID = net_short(IPH->iph_id);

            FragOffset = IPH->iph_offset & IP_OFFSET_MASK;
            FragOffset = net_short(FragOffset) * 8;

            bFragment = (IPH->iph_offset & IP_MF_FLAG) || (FragOffset > 0);
            bFirstFragment = bFragment && (FragOffset == 0);
            bLastFragment = bFragment && (!(IPH->iph_offset & IP_MF_FLAG));

            //
            // If this is a fragment and NOT the first one, just put the Timestamp in here.
            // Otherwise, let it get to the protocols for processing.
            //
            if (bFragment && !bFirstFragment) {

                NdisAcquireSpinLock(&IPIDListLockRecv);

                for (i = 0; i < PORT_RANGE; i++) {

                    if (IPID == IPIDListRecv[i]) {
                        
                        if (bLastFragment) {
                            //
                            // If its the last fragment, release the slot.
                            //
                            IPIDListRecv[i] = 0xffff;
                        }

                        break;
                    }

                }

                NdisReleaseSpinLock(&IPIDListLockRecv);

                if (i == PORT_RANGE) {

                    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV, ("Couldnt find an IPID that we care about, get outta here.\n"));
                    goto RECV_FAILURE;

                } 
                //
                // So we found a IPID that matches - set the timestamp and get out after this.
                //
                
                TotalLen = TotalIpLen - FragOffset;
                pData    = ((PUCHAR) IPH) + IpHdrLen; 
                
                if (TotalLen > sizeof (LOG_RECORD)) {

                    LARGE_INTEGER   PerfFrequency;
                    UINT64          RecdTime, Freq;

                    pRecord = (LOG_RECORD *) pData;
                    CurrentTime = KeQueryPerformanceCounter(&PerfFrequency);
                    
                    //
                    // Convert the perffrequency into 100ns interval.
                    //
                    Freq = 0;
                    Freq |= PerfFrequency.HighPart;
                    Freq = Freq << 32;
                    Freq |= PerfFrequency.LowPart;

                    //convert from Largeinteger to uint64
                    pRecord->TimeReceivedWire = 0;
                    pRecord->TimeReceivedWire |= CurrentTime.HighPart;
                    pRecord->TimeReceivedWire = pRecord->TimeReceivedWire << 32;
                    pRecord->TimeReceivedWire |= CurrentTime.LowPart;

                    // Normalize cycles with the frequency.
                    pRecord->TimeReceivedWire *= 10000000;
                    pRecord->TimeReceivedWire /= Freq;

                }
                
                return TRUE;

            }

            //
            // Do the protocol specific stuff.
            //

            switch (IPH->iph_protocol) {
            case IPPROTO_TCP:
            
                TotalTcpLen = TotalIpLen - HeaderLength;
                TCPH = (TCPHeader *) (((PUCHAR)IPH) + HeaderLength);

                SrcPort = net_short(TCPH->tcp_src);
                DstPort = net_short(TCPH->tcp_dest);

                TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV, ("[TimeStmpReceivePacket]: *TCP* Address: SRC = %x DST = %x, Port S : %x, Port D: %x\n",
                                                          IPH->iph_src, 
                                                          IPH->iph_dest, 
                                                          SrcPort, 
                                                          DstPort));

                TcpHeaderOffset = TCP_HDR_SIZE(TCPH);
                pData = (PUCHAR) TCPH + TcpHeaderOffset;
                TcpDataLen = TotalTcpLen - TcpHeaderOffset;

                if ((CheckInPortList(DstPort)) && (TcpDataLen > sizeof (LOG_RECORD))) {
                    
                    LARGE_INTEGER   PerfFrequency;
                    UINT64          RecdTime, Freq;

                    pRecord = (LOG_RECORD *) pData;
                    CurrentTime = KeQueryPerformanceCounter(&PerfFrequency);
                    
                    //
                    // Convert the perffrequency into 100ns interval.
                    //
                    Freq = 0;
                    Freq |= PerfFrequency.HighPart;
                    Freq = Freq << 32;
                    Freq |= PerfFrequency.LowPart;

                    //convert from large_integer to uint64

                    pRecord->TimeReceivedWire = 0;
                    pRecord->TimeReceivedWire |= CurrentTime.HighPart;
                    pRecord->TimeReceivedWire = pRecord->TimeReceivedWire << 32;
                    pRecord->TimeReceivedWire |= CurrentTime.LowPart;

                    // Normalize cycles with the frequency.
                    pRecord->TimeReceivedWire *= 10000000;
                    pRecord->TimeReceivedWire /= Freq;


                } else if (CheckInPortList(DstPort)) {

                    if (TcpDataLen < sizeof(LOG_RECORD)) 
                        TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV, ("The Datagram was too small!! IpLen:%d, Tcplen:%d HeaderOff(tcp):%d log_record:%d\n", TotalIpLen, TotalTcpLen, TcpHeaderOffset, sizeof (LOG_RECORD)));

                }
    
                //
                // If its the first fragment, keep a place holder so we know which
                // subsequent IP fragments to timestamp.
                //
                if ((CheckInPortList(DstPort)) && bFirstFragment) {

                    NdisAcquireSpinLock(&IPIDListLockRecv);
    
                    // need new Entry for IPID
                    for (i = 0; i < PORT_RANGE; i++) {
                        //
                        // Look for a free slot
                        //
                        if (0xffff == IPIDListRecv[i]) {
            
                            IPIDListRecv[i] = IPID;
                            break;
        
                        }


                    }

                    NdisReleaseSpinLock(&IPIDListLockRecv);
    
                    if (i == PORT_RANGE) {

                        TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV, ("Couldn't find an empty IPID - Bailing \n"));
                    }
                }


                break;

            case IPPROTO_UDP:
            
                TotalUdpLen = TotalIpLen - HeaderLength;
                UDPH = (UDPHeader *) (((PUCHAR)IPH) + HeaderLength);
                
                TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV, ("PAcket %x, IPH = %x, UDPH = %x, HeaderLength = %x\n", Packet, IPH, UDPH, HeaderLength));

                UdpDataLen = TotalUdpLen - sizeof(UDPHeader);
                pData = ((PUCHAR) UDPH) + sizeof (UDPHeader);

                SrcPort = net_short(UDPH->uh_src);          // Source port.
                DstPort = net_short(UDPH->uh_dest);             // Destination port.

                if (UdpDataLen < sizeof(UDPHeader)) {
                    return TRUE;
                } 
                
                if ((CheckInPortList(DstPort)) && (UdpDataLen > sizeof(LOG_RECORD))) {
                    
                    LARGE_INTEGER   PerfFrequency;
                    UINT64          RecdTime, Freq;

                    pRecord = (LOG_RECORD *) pData;
                    CurrentTime = KeQueryPerformanceCounter(&PerfFrequency);

                    //
                    // Convert the perffrequency into 100ns interval.
                    //
                    Freq = 0;
                    Freq |= PerfFrequency.HighPart;
                    Freq = Freq << 32;
                    Freq |= PerfFrequency.LowPart;

                    // convert to uint64

                    pRecord->TimeReceivedWire = 0;
                    pRecord->TimeReceivedWire |= CurrentTime.HighPart;
                    pRecord->TimeReceivedWire = pRecord->TimeReceivedWire << 32;
                    pRecord->TimeReceivedWire |= CurrentTime.LowPart;
                                        
                    // Normalize cycles with the frequency.
                    pRecord->TimeReceivedWire *= 10000000;
                    pRecord->TimeReceivedWire /= Freq;


                    //
                    // Dont want to get rejected due to bad xsum ...
                    //
                    UDPH->uh_xsum = 0;

                } else if (CheckInPortList(DstPort)) {

                    if ((UdpDataLen) < sizeof(LOG_RECORD))
                        TimeStmpTrace(TS_DBG_DEATH, TS_DBG_RECV, ("The Datagram was too small (UDP)!! IpLen:%d, Size:%d log_record:%d\n", 
                                                                  TotalIpLen, UdpDataLen, sizeof (LOG_RECORD)));

                }

                if ((CheckInPortList(DstPort)) && bFirstFragment) {

                    NdisAcquireSpinLock(&IPIDListLockRecv);

                    // need new Entry for IPID
                    for (i = 0; i < PORT_RANGE; i++) {
                        //
                        // Look for a free slot
                        //
                        if (0xffff == IPIDListRecv[i]) {

                            IPIDListRecv[i] = IPID;
                            break;

                        }


                    }

                    NdisReleaseSpinLock(&IPIDListLockRecv);

                    if (i == PORT_RANGE) {

                        TimeStmpTrace(TS_DBG_DEATH, TS_DBG_RECV, ("Couldn't find an empty IPID - Bailing \n"));
                    }
                }

                TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV, ("[TimeStmpReceivePacket]: *UDP* Address: SRC = %x DST = %x, Port S : %x, Port D: %x\n",
                                          IPH->iph_src, 
                                          IPH->iph_dest, 
                                          UDPH->uh_src, 
                                          UDPH->uh_dest));

                break;

            case IPPROTO_RAW:
            
                TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV, ("[TimeStmpReceivePacket]: Protocol RAW\n"));

                break;
        
            case IPPROTO_IGMP:
            
                TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV, ("[TimeStmpReceivePacket]: Protocol IGMP\n"));

                break;
        
            case IPPROTO_ICMP:

                TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV, ("[TimeStmpReceivePacket]: Protocol TCMP\n"));

                break;

            default:
            
                ;
                //TimeStmpTrace(TS_DBG_DEATH, TS_DBG_RECV, ("[TimeStmpReceivePacket]: Protocol - UNKNOWN (%d)\n", IPH->iph_protocol));
                //DbgBreakPoint();

            }
        }
    }

RECV_FAILURE:

    return TRUE;
}

//
// This function receives a buffer from NDIS which is indicated to the transport.
// We use this function and work past the headers (tcp, ip) and get to the data.
// Then, we timestamp and reset the checksum flags.
// We make the assumption that the lookahead is atleast 128. 
// mac header ~ 8+8, ip header ~20, tcp/udp ~ 20+options, LOG_RECORD ~ 44
// they all add up to less than 128. If this is not a good assumption, We will need
// to get into MiniportTransferData and such.
//
BOOLEAN
TimeStmpReceiveIndication(
                          IN PPS_PIPE_CONTEXT PipeContext,
                          IN PPS_FLOW_CONTEXT FlowContext,
                          IN PPS_CLASS_MAP_CONTEXT ClassMapContext,
                          IN PVOID    HeaderBuffer,
                          IN UINT     HeaderBufferSize,
                          IN PVOID    LookAheadBuffer,
                          IN UINT     LookAheadBufferSize,
                          IN UINT     PacketSize,
                          IN UINT     TransportHeaderOffset
                          )
{
    PPS_PIPE_CONTEXT    Pipe = PipeContext;
    LARGE_INTEGER       CurrentTime;
    IPHeader UNALIGNED  *IPH    = NULL;
    TCPHeader UNALIGNED *TCPH   = NULL;
    UDPHeader UNALIGNED *UDPH   = NULL;
    IPAddr              Src, Dst;
    PUCHAR              headerBuffer = NULL, pData = NULL;
    PNDIS_BUFFER        pFirstBuffer = NULL;
    ULONG               firstbufferLength = 0, bufferLength = 0, HeaderLength = 0;
    ULONG               TotalIpLen = 0, IPDataLength = 0, IpHdrLen = 0;
    ULONG               TotalTcpLen = 0, TcpDataLen = 0, TotalLen = 0, TcpHeaderOffset = 0, Size = 0;
    ULONG               TotalUdpLen = 0, UdpDataLen = 0, UdpHdrLen = 0;
    USHORT              SrcPort = 0, DstPort = 0, IPID = 0, FragOffset = 0;
    BOOLEAN             bFragment, bFirstFragment, bLastFragment;
    ULONG               i = 0;
    PLOG_RECORD         pRecord = NULL;
    ushort              type;                       // Protocol type
    uint                ProtOffset;                 // Offset in Data to non-media info.
    UINT                MoreHeaderInLookAhead = 0;
    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV, ("[TimeStmpReceiveIndication]: \n"));

    //
    // Don't know anything about the MAC headers, piggy back from PSCHED...
    // Calculate if the header is more than the standard HeaderBufferSize (i.e. SNAP header, etc.)
    //
    MoreHeaderInLookAhead = TransportHeaderOffset - HeaderBufferSize;

    if (MoreHeaderInLookAhead) {
        
        //
        // Just munge these, so that we can actually get down to business.
        //
        ((PUCHAR) LookAheadBuffer) += MoreHeaderInLookAhead;
        LookAheadBufferSize -= MoreHeaderInLookAhead;

    }

    if (LookAheadBufferSize > sizeof(IPHeader)) {

        IPH = (IPHeader *) (PUCHAR)LookAheadBuffer;
    
        // Check the header length and the version. If any of these
        // checks fail silently discard the packet.
        HeaderLength = ((IPH->iph_verlen & (uchar)~IP_VER_FLAG) << 2);

        if (HeaderLength >= sizeof(IPHeader) && HeaderLength <= LookAheadBufferSize) {

            //
            // Get past the IP Header and get the rest of the stuff out.
            //
            TotalIpLen = (uint)net_short(IPH->iph_length);

            if ((IPH->iph_verlen & IP_VER_FLAG) == IP_VERSION &&
                TotalIpLen >= HeaderLength  && TotalIpLen <= LookAheadBufferSize) {

                Src = net_short(IPH->iph_src);
                Dst = net_short(IPH->iph_dest);
                IPID = net_short(IPH->iph_id);

                FragOffset = IPH->iph_offset & IP_OFFSET_MASK;
                FragOffset = net_short(FragOffset) * 8;

                bFragment = (IPH->iph_offset & IP_MF_FLAG) || (FragOffset > 0);
                bFirstFragment = bFragment && (FragOffset == 0);
                bLastFragment = bFragment && (!(IPH->iph_offset & IP_MF_FLAG));

                //
                // If this is a fragment and NOT the first one, just put the Timestamp in here.
                // Otherwise, let it get to the protocols for processing.
                //
                if (bFragment && !bFirstFragment) {

                    NdisAcquireSpinLock(&IPIDListLockRecv);

                    for (i = 0; i < PORT_RANGE; i++) {

                        if (IPID == IPIDListRecv[i]) {
                        
                            if (bLastFragment) {
                                //
                                // If its the last fragment, release the slot.
                                //
                                IPIDListRecv[i] = 0xffff;
                            }

                            break;
                        }

                    }

                    NdisReleaseSpinLock(&IPIDListLockRecv);

                    if (i == PORT_RANGE) {

                        TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV, ("Couldnt find an IPID that we care about, get outta here.\n"));
                        goto RECV_FAILURE;

                    } 
                    //
                    // So we found a IPID that matches - set the timestamp and get out after this.
                    //
                
                    TotalLen = TotalIpLen - FragOffset;
                    pData    = ((PUCHAR) IPH) + IpHdrLen; 
                
                    if (TotalLen >= sizeof (LOG_RECORD)) {

                        LARGE_INTEGER   PerfFrequency;
                        UINT64          RecdTime, Freq;

                        pRecord = (LOG_RECORD *) pData;
                        CurrentTime = KeQueryPerformanceCounter(&PerfFrequency);

                        //
                        // Convert the perffrequency into 100ns interval.
                        //
                        Freq = 0;
                        Freq |= PerfFrequency.HighPart;
                        Freq = Freq << 32;
                        Freq |= PerfFrequency.LowPart;

                        //
                        // Convert from LARGE_INTEGER to UINT64
                        //
                        pRecord->TimeReceivedWire = 0;
                        pRecord->TimeReceivedWire |= CurrentTime.HighPart;
                        pRecord->TimeReceivedWire = pRecord->TimeReceivedWire << 32;
                        pRecord->TimeReceivedWire |= CurrentTime.LowPart;
                        
                        // Normalize cycles with the frequency.
                        pRecord->TimeReceivedWire *= 10000000;
                        pRecord->TimeReceivedWire /= Freq;


                    }
                
                    return TRUE;

                }

                //
                // Do the protocol specific stuff.
                //

                switch (IPH->iph_protocol) {
                case IPPROTO_TCP:
            
                    TotalTcpLen = TotalIpLen - HeaderLength;
                    TCPH = (TCPHeader *) (((PUCHAR)IPH) + HeaderLength);

                    SrcPort = net_short(TCPH->tcp_src);
                    DstPort = net_short(TCPH->tcp_dest);

                    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV, ("[TimeStmpReceiveIndication]: *TCP* Address: SRC = %x DST = %x, Port S : %x, Port D: %x\n",
                                                              IPH->iph_src, 
                                                              IPH->iph_dest, 
                                                              SrcPort, 
                                                              DstPort));

                    TcpHeaderOffset = TCP_HDR_SIZE(TCPH);
                    pData = (PUCHAR) TCPH + TcpHeaderOffset;
                    TcpDataLen = TotalTcpLen - TcpHeaderOffset;

                    if ((CheckInPortList(DstPort)) && (TcpDataLen > sizeof (LOG_RECORD))) {
                    
                        LARGE_INTEGER   PerfFrequency;
                        UINT64          RecdTime, Freq;

                        pRecord = (LOG_RECORD *) pData;
                        CurrentTime = KeQueryPerformanceCounter(&PerfFrequency);

                        //
                        // Convert the perffrequency into 100ns interval.
                        //
                        Freq = 0;
                        Freq |= PerfFrequency.HighPart;
                        Freq = Freq << 32;
                        Freq |= PerfFrequency.LowPart;

                        // convert to uint64
                        pRecord->TimeReceivedWire = 0;
                        pRecord->TimeReceivedWire |= CurrentTime.HighPart;
                        pRecord->TimeReceivedWire = pRecord->TimeReceivedWire << 32;
                        pRecord->TimeReceivedWire |= CurrentTime.LowPart;
                    
                        // Normalize cycles with the frequency.
                        pRecord->TimeReceivedWire *= 10000000;
                        pRecord->TimeReceivedWire /= Freq;


                        //
                        //pRecord->TimeReceivedWire);
                        //

                    } else if (CheckInPortList(DstPort)) {

                        if (TcpDataLen < sizeof(LOG_RECORD)) 
                            TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV,
                            ("The Datagram was too small!! IpLen:%d, Tcplen:%d HeaderOff(tcp):%d log_record:%d\n", TotalIpLen, TotalTcpLen, TcpHeaderOffset, sizeof (LOG_RECORD)));

                    }
    
                    //
                    // If its the first fragment, keep a place holder so we know which
                    // subsequent IP fragments to timestamp.
                    //
                    if ((CheckInPortList(DstPort)) && bFirstFragment) {

                        NdisAcquireSpinLock(&IPIDListLockRecv);
    
                        // need new Entry for IPID
                        for (i = 0; i < PORT_RANGE; i++) {
                            //
                            // Look for a free slot
                            //
                            if (0xffff == IPIDListRecv[i]) {
            
                                IPIDListRecv[i] = IPID;
                                break;
        
                            }


                        }

                        NdisReleaseSpinLock(&IPIDListLockRecv);
    
                        if (i == PORT_RANGE) {

                            TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV, ("Couldn't find an empty IPID - Bailing \n"));
                        }
                    }


                    break;

                case IPPROTO_UDP:
            
                    TotalUdpLen = TotalIpLen - HeaderLength;
                    UDPH = (UDPHeader *) (((PUCHAR)IPH) + HeaderLength);
                
                    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV, ("PAcket %x, IPH = %x, UDPH = %x, HeaderLength = %x\n", LookAheadBuffer, IPH, UDPH, HeaderLength));

                    UdpDataLen = TotalUdpLen - sizeof(UDPHeader);
                    pData = ((PUCHAR) UDPH) + sizeof (UDPHeader);

                    SrcPort = net_short(UDPH->uh_src);      // Source port.
                    DstPort = net_short(UDPH->uh_dest);         // Destination port.

                    if (UdpDataLen < sizeof(UDPHeader)) {
                        return TRUE;
                    } 
                
                    if ((CheckInPortList(DstPort)) && (UdpDataLen > sizeof(LOG_RECORD))) {

                        LARGE_INTEGER   PerfFrequency;
                        UINT64          RecdTime, Freq;

                        pRecord = (LOG_RECORD *) pData;
                        CurrentTime = KeQueryPerformanceCounter(&PerfFrequency);

                        //
                        // Convert the perffrequency into 100ns interval.
                        //
                        Freq = 0;
                        Freq |= PerfFrequency.HighPart;
                        Freq = Freq << 32;
                        Freq |= PerfFrequency.LowPart;

                        pRecord->TimeReceivedWire = 0;
                        pRecord->TimeReceivedWire |= CurrentTime.HighPart;
                        pRecord->TimeReceivedWire = pRecord->TimeReceivedWire << 32;
                        pRecord->TimeReceivedWire |= CurrentTime.LowPart;

                        // Normalize cycles with the frequency.
                        pRecord->TimeReceivedWire *= 10000000;
                        pRecord->TimeReceivedWire /= Freq;


                        //
                        // Dont want to get rejected due to bad xsum ...
                        //
                        UDPH->uh_xsum = 0;

                    } else if (CheckInPortList(DstPort)) {

                        if ((UdpDataLen) < sizeof(LOG_RECORD))
                            TimeStmpTrace(TS_DBG_DEATH, TS_DBG_RECV, ("The Datagram was too small (UDP)!! IpLen:%d, Size:%d log_record:%d\n", 
                                                                      TotalIpLen, UdpDataLen, sizeof (LOG_RECORD)));

                    }

                    if ((CheckInPortList(DstPort)) && bFirstFragment) {

                        NdisAcquireSpinLock(&IPIDListLockRecv);

                        // need new Entry for IPID
                        for (i = 0; i < PORT_RANGE; i++) {
                            //
                            // Look for a free slot
                            //
                            if (0xffff == IPIDListRecv[i]) {

                                IPIDListRecv[i] = IPID;
                                break;

                            }


                        }

                        NdisReleaseSpinLock(&IPIDListLockRecv);

                        if (i == PORT_RANGE) {

                            TimeStmpTrace(TS_DBG_DEATH, TS_DBG_RECV, ("Couldn't find an empty IPID - Bailing \n"));
                        }
                    }

                    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV, ("[TimeStmpReceiveIndication]: *UDP* Address: SRC = %x DST = %x, Port S : %x, Port D: %x\n",
                                                              IPH->iph_src, 
                                                              IPH->iph_dest, 
                                                              UDPH->uh_src, 
                                                              UDPH->uh_dest));

                    break;

                case IPPROTO_RAW:
            
                    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV, ("[TimeStmpReceiveIndication]: Protocol RAW\n"));

                    break;
        
                case IPPROTO_IGMP:
            
                    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV, ("[TimeStmpReceiveIndication]: Protocol IGMP\n"));

                    break;
        
                case IPPROTO_ICMP:

                    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV, ("[TimeStmpReceiveIndication]: Protocol TCMP\n"));

                    break;

                default:
            
                
                    TimeStmpTrace(TS_DBG_DEATH, TS_DBG_RECV, ("[TimeStmpReceiveIndication]: Protocol - UNKNOWN (%d)\n", IPH->iph_protocol));

                    //DbgBreakPoint();

                }
            }
        }
    }

RECV_FAILURE:

    return TRUE;
}


VOID
TimeStmpSetInformation (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN NDIS_OID Oid,
    IN ULONG Len,
    IN void *Data)
{
    PPS_PIPE_CONTEXT Pipe = PipeContext;
    PPS_FLOW_CONTEXT Flow = FlowContext;
    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_OID, ("[TimeStmpSetInformation]:\n"));
    (*Pipe->NextComponent->SetInformation)(
        Pipe->NextComponentContext,
        (Flow)?Flow->NextComponentContext:0,
        Oid,
        Len,
        Data);
}


VOID
TimeStmpQueryInformation (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN NDIS_OID Oid,
    IN ULONG Len,
    IN PVOID Data,
    IN OUT PULONG BytesWritten,
    IN OUT PULONG BytesNeeded,
    IN OUT PNDIS_STATUS Status)
{
    PPS_PIPE_CONTEXT Pipe = PipeContext;
    PPS_FLOW_CONTEXT Flow = FlowContext;
    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_OID, ("[TimeStmpQueryInformation]:\n"));
    (*Pipe->NextComponent->QueryInformation)(
        Pipe->NextComponentContext,
        (Flow)?Flow->NextComponentContext:0,
        Oid,
        Len,
        Data,
        BytesWritten,
        BytesNeeded,
        Status);
}

NDIS_STATUS 
TimeStmpCreateClassMap (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsClassMapContext,
    IN PTC_CLASS_MAP_FLOW ClassMap,
    IN PPS_CLASS_MAP_CONTEXT ComponentClassMapContext
    )
{
    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_CLASS_MAP, ("[TimeStmpCreateClassMap]: \n"));
    return (*PipeContext->NextComponent->CreateClassMap)(
        PipeContext->NextComponentContext,
        PsClassMapContext,
        ClassMap,
        ComponentClassMapContext->NextComponentContext);
}

NDIS_STATUS 
TimeStmpDeleteClassMap (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_CLASS_MAP_CONTEXT ComponentClassMapContext
    )
{
    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_CLASS_MAP, ("[TimeStmpDeleteClassMap]: \n"));
    return (*PipeContext->NextComponent->DeleteClassMap)(
        PipeContext->NextComponentContext,
        ComponentClassMapContext->NextComponentContext);
}
    
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    PSI_INFO        Component;
    NDIS_HANDLE     ConfigHandle;
    NDIS_STATUS     Status;
    NDIS_STRING     ComponentKey = NDIS_STRING_CONST("DisplayName");
    NDIS_STRING     ComponentName = NDIS_STRING_CONST("TimeStmp");
    PNDIS_CONFIGURATION_PARAMETER pConfigParam;
    NDIS_STRING     PsParamKey;
    PWSTR           p = RegistryPath->Buffer + RegistryPath->Length;
    PS_DEBUG_INFO   Dbg;
    ULONG           i = 0;

    // The last word of Registry Path points to the driver name.
    // NdisOpenProtocol needs that name!
    while(p != RegistryPath->Buffer && *p != L'\\')
        p-- ;
    p++;
    RtlInitUnicodeString(&PsParamKey, p);
    DbgPrint("PsParamKey:%s\n", PsParamKey);

    NdisOpenProtocolConfiguration(&Status, &ConfigHandle, &PsParamKey);

    DbgPrint("Status of NdisOpenProtocol:%x\n", Status);

    if (!NT_SUCCESS(Status)) {
        goto failure;
    }

    //
    // Check if psched is installed by opening it.
    // If it fails, we dont load either.
    //
    Status = CheckForPsched();
    
    if (!NT_SUCCESS(Status)) {
        
        DbgPrint("PSCHED is NOT installed. Timestmp is bailing too\n");
        goto failure;
    }

    IoctlInitialize(DriverObject);

	// this list maintains a list of all ports that need to be timestamped.
    InitializeListHead(&PortList);
    NdisAllocateSpinLock(&PortSpinLock);
    
    DriverObject->DriverUnload = TimeStmpUnload;
    
    
    //
    // We need to keep track of IPIDs for dealing with fragments 
    // that we need to stamp...
    // 
    for (i = 0; i < PORT_RANGE; i++) {
        IPIDList[i] = 0xffff;
    }

    NdisAllocateSpinLock(&IPIDListLock);

    //
    // Do the same for the receive side.
    // 
    for (i = 0; i < PORT_RANGE; i++) {
        IPIDListRecv[i] = 0xffff;
    }

    NdisAllocateSpinLock(&IPIDListLockRecv);


    if ( NT_SUCCESS( Status )) 
    {
        // Read the name of the component from the registry
#if 0
        NdisReadConfiguration( &Status,
                               &pConfigParam,
                               ConfigHandle,
                               &ComponentKey,
                               NdisParameterString);
        if( NT_SUCCESS( Status ))
        {
            RtlInitUnicodeString(&Component.ComponentName,
                                pConfigParam->ParameterData.StringData.Buffer);
#else 
            RtlInitUnicodeString(&Component.ComponentName, ComponentName.Buffer);
#endif

            Component.Version = PS_COMPONENT_CURRENT_VERSION;
            Component.PacketReservedLength = 0;
            Component.PipeContextLength = sizeof(PS_PIPE_CONTEXT);
            Component.FlowContextLength = sizeof(PS_FLOW_CONTEXT);
            Component.ClassMapContextLength = sizeof(PS_CLASS_MAP_CONTEXT);
            Component.SupportedOidsLength  = 0;
            Component.SupportedOidList = 0;
            Component.SupportedGuidsLength = 0;
            Component.SupportedGuidList = 0;
            Component.InitializePipe = TimeStmpInitializePipe;
            Component.ModifyPipe = TimeStmpModifyPipe;
            Component.DeletePipe = TimeStmpDeletePipe;
            Component.CreateFlow = TimeStmpCreateFlow;
            Component.ModifyFlow = TimeStmpModifyFlow;
            Component.DeleteFlow = TimeStmpDeleteFlow;
            Component.CreateClassMap = TimeStmpCreateClassMap;
            Component.DeleteClassMap = TimeStmpDeleteClassMap;
            Component.SubmitPacket = TimeStmpSubmitPacket;
            Component.ReceivePacket = TimeStmpReceivePacket;
            Component.ReceiveIndication = TimeStmpReceiveIndication;
            Component.SetInformation = TimeStmpSetInformation;
            Component.QueryInformation = TimeStmpQueryInformation;

            //
            // Call Psched's RegisterPsComponent
            //
            Status = RegisterPsComponent(&Component, sizeof(Component), 
                                         &Dbg);
            if(Status != NDIS_STATUS_SUCCESS)
            {
                
                DbgPrint("Status of RegisterPsComponent%x\n", Status);

                TimeStmpTrace(TS_DBG_DEATH, TS_DBG_INIT, 
                          ("DriverEntry: RegisterPsComponent Failed \n"));
            } 
            else 
            {
                
                DbgPrint("Status of RegisterPsComponent:%x\n", Status);

            }

#if 0
                
        }
        else 
        {
            DbgPrint("Status of NdisReadProtocol:%x\n", Status);
            
            DbgBreakPoint();
            TimeStmpTrace(TS_DBG_DEATH, TS_DBG_INIT, 
                      ("DriverEntry: ComponentName not specified \n"));
        }
#endif
    }
    else 
    
    {
        DbgPrint("Status of NdisOpenProtocol:%x\n", Status);

        TimeStmpTrace(TS_DBG_DEATH, TS_DBG_INIT,
                  ("DriverEntry: Can't read driver information in registry"
                   "\n"));
    }

failure:
    return Status;
}


//
// The following function checks for the existence of PSCHED on the machine.
// The assumption being that PSCHED gets loaded before TimeStmp on a system.
// If we can open the device, it means that PSCHED is on, otherwise, we bail.
// This fix is for Bug - 321618
//
NTSTATUS
CheckForPsched(
               VOID
               )

{
    NTSTATUS                    status;
    IO_STATUS_BLOCK             ioStatusBlock;
    OBJECT_ATTRIBUTES           objectAttr;

    InitializeObjectAttributes(
        &objectAttr,
        &PschedDriverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    status = NtCreateFile(
                &PschedHandle,
                GENERIC_READ,
                &objectAttr,
                &ioStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                0L);

    if (!NT_SUCCESS(status)) {

        return status;

    } else {

        NtClose(PschedHandle);

    }

    return status;
}

PPORT_ENTRY 
CheckInPortList(USHORT Port) {

	PLIST_ENTRY		ListEntry;
	PPORT_ENTRY		pPortEntry;
	
	NdisAcquireSpinLock(&PortSpinLock);
	ListEntry = PortList.Flink;
	
	while (ListEntry != &PortList) {

		pPortEntry = CONTAINING_RECORD(ListEntry, PORT_ENTRY, Linkage);
		if (Port == pPortEntry->Port) {
		
			//DbgPrint("Found Port%d\n", Port);
			NdisReleaseSpinLock(&PortSpinLock);
			return pPortEntry;

		} else {
		
			ListEntry = ListEntry->Flink;
			//DbgPrint("NOT Found Trying NEXT\n");
		}
		
	}

	NdisReleaseSpinLock(&PortSpinLock);
	//DbgPrint("NOT Found returning from function\n");
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\tools\tsinstl\main.c ===
//
// Popup choices and install Timestamp driver.
//
// ShreeM (January 31, 1999)
//
// This command line based installation program does the following -
// 1. TcEnumerateInterfaces.
// 2. Display these interfaces to the user.
// 3. Based on the user input - Plumb the registry.
// 4. Ask the user if the service needs to be AUTO or MANUAL.
//

#define UNICODE
#define INITGUID
#include <windows.h>
#include <stdio.h>
#include <objbase.h>
#include <wmium.h>
#include <ntddndis.h>
#include <qos.h>
#include <qossp.h>
#include <wtypes.h>
#include <traffic.h>
#include <tcerror.h>
#include <tcguid.h>
#include <winsock2.h>
#include <ndisguid.h>
#include <tlhelp32.h>
#include <ntddpsch.h>

#define LAST_COMPATIBLE_OS_VERSION  2050

HANDLE  hClient = NULL;
ULONG   ClientContext = 12;
BOOLEAN WANlink = FALSE;
#define REGKEY_SERVICES                 TEXT("System\\CurrentControlSet\\Services")
#define REGKEY_PSCHED                   TEXT("System\\CurrentControlSet\\Services\\Psched")
#define REGKEY_PSCHED_PARAMS            TEXT("System\\CurrentControlSet\\Services\\Psched\\Parameters")
#define REGKEY_PSCHED_PARAMS_ADAPTERS   TEXT("System\\CurrentControlSet\\Services\\Psched\\Parameters\\Adapters")
#define REGKEY_TIMESTMP                 TEXT("System\\CurrentControlSet\\Services\\TimeStmp")
TCHAR   Profiles[] = TEXT("LANTEST");
TCHAR   Lantest[] = TEXT("TokenBucketConformer\0TrafficShaper\0DRRSequencer\0TimeStmp");

//
// Function prototype
//

VOID ShutdownNT();

VOID _stdcall NotifyHandler(
              HANDLE   ClRegCtx, 
              HANDLE   ClIfcCtx, 
              ULONG    Event, 
              HANDLE   SubCode, 
              ULONG    BufSize,
              PVOID    Buffer)
{                                                                                                            
        //                                                                                                   
        // This function may get executed in a new thread, so we can't fire the events directly (because     
        // it breaks some clients, like VB and IE.)  To get around this, we'll fire off an APC in the origina
        // thread, which will handle the actual event firing.                                                
        //                                                                                                   
    OutputDebugString(TEXT("Notify called\n"));

                                                                                                             
}                                                                                                            

//
// Delete the service and cleanup Psched regkeys
//
BOOLEAN
DeleteTimeStamp(PTC_IFC_DESCRIPTOR pIf);
            
// Just delete the service (no psched stuff)
VOID RemoveTimeStampService();


void _cdecl main(
          INT argc,
          CHAR *argv[]
          )
{      
    
    TCI_CLIENT_FUNC_LIST ClientHandlerList;
    ULONG   err;
    TCHAR   SzBuf[MAX_PATH], *TBuffer, *KeyBuffer;
    ULONG   i = 0, len = 0, j = 0, cb = 0, Number = 0, size = 0, interfaceid = 0;
    WCHAR   servicetype, response;
    BYTE    *Buffer;
    TC_IFC_DESCRIPTOR   *pIf, WanIf;
    DWORD   ret, Disposition, starttype, choice, InstallFlag = -1;
    HKEY    hConfigKey, TimeStampKey;
    SC_HANDLE    schService;
    SC_HANDLE    schSCManager;
    BOOLEAN Success = FALSE;
    OSVERSIONINFO       osversion;
    
    ClientHandlerList.ClNotifyHandler               = NotifyHandler;
    ClientHandlerList.ClAddFlowCompleteHandler      = NULL;
    ClientHandlerList.ClModifyFlowCompleteHandler   = NULL;
    ClientHandlerList.ClDeleteFlowCompleteHandler   = NULL;
    

    wprintf(TEXT("Installer for Time Stamp module 1.0 for Windows NT (c) Microsoft Corp.\n\n"));

    // check if the psched versions will be compatible before doing anything here.
    osversion.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
    osversion.dwBuildNumber = 0;
    GetVersionEx(&osversion);
    if (osversion.dwBuildNumber < LAST_COMPATIBLE_OS_VERSION) {
        wprintf(TEXT("Install ERROR!\nYour current Windows 2000 OS build number is %d.\n"), osversion.dwBuildNumber);
        wprintf(TEXT("To use the version of TIMESTMP in the QoS Tools CD, you will be required to upgrade \nto an OS build number of atleast 2050 or later.\n"));
        return;
    }
    
    wprintf(TEXT("Running this program will (un)install this module on one Interface at a time.\n"));
    wprintf(TEXT("You will the prompted for basic choices in the installation process.\n"));
    
    j = 0;
get_again:
    wprintf(TEXT("[1] Install\n[2] Uninstall\n[3] Exit\n Your Choice:"));
    fflush(stdin);
    wscanf(TEXT("%d"), &choice);

    if (1 == choice) {
        InstallFlag = 1;
    } else if (2 == choice) {
        InstallFlag = 0;
    } else if (3 == choice) {
        return;
    } else if (j < 3) {
        j++;
        goto get_again;
    } else {
        return;
    }

    err = TcRegisterClient(
              CURRENT_TCI_VERSION,
              (HANDLE)UlongToPtr(ClientContext),
              &ClientHandlerList,
              &hClient
              );

    if (NO_ERROR != err) {

        hClient = NULL;
        wsprintf(SzBuf, TEXT("Error registering Client: %d - %d\n"), err, GetLastError());
        OutputDebugString(SzBuf);
        wprintf(TEXT("INSTALLER: QoS is not installed on this machine\n\n"));

        //
        // However, if it should be ok to Uninstall the Timestmp service using this easily.
        //
        if (0 == InstallFlag) {
            RemoveTimeStampService();
        }
        return;
    
    } else {

        OutputDebugString(TEXT("Registered Client:\n"));

    }
    
    size = 0;
    // Query Buffer Size required.
    err = TcEnumerateInterfaces(	
                                hClient,
                                &size,
                                (TC_IFC_DESCRIPTOR *)NULL
                                );
    
    if (NO_ERROR != err) {
        wsprintf(SzBuf, TEXT("Error Enumerating Interfaces: %d - (size reqd. %d) \n"), err, size);
        OutputDebugString(SzBuf);

    } else {

        wsprintf(SzBuf, TEXT("Enumerating Interfaces works??? : %d - ITS OK!\n"), size);
        OutputDebugString(SzBuf);
        wprintf(TEXT("INSTALLER: QoS is either not installed on this machine\n\t OR \n"));
        wprintf(TEXT("None of the adapters are enabled for QoS\n"));
        
        //
        // However, if it should be ok to Uninstall the Timestmp service using this easily.
        //
        if (0 == InstallFlag) {
            RemoveTimeStampService();
        }

        wprintf(TEXT("Exiting...\n"));

        goto cleanup_no_free;
    }

    // if there are no interfaces (qos is not installed on this machine), get out.
    // 
    if (!size) {
        wprintf(TEXT("INSTALLER: QoS is either not installed on this machine\n\t OR \n"));
        wprintf(TEXT("None of the adapters are enabled for QoS\n"));

        //
        // However, if it should be ok to Uninstall the Timestmp service using this easily.
        //
        if (0 == InstallFlag) {
            RemoveTimeStampService();
        }
        
        wprintf(TEXT("Exiting...\n"));

        goto cleanup_no_free;
    }

    // query the interfaces
    Buffer = malloc (size);
    err = TcEnumerateInterfaces(	
                                hClient,
                                &size,
                                (TC_IFC_DESCRIPTOR *)Buffer
                                );
    
    if (NO_ERROR != err) {
        wsprintf(SzBuf, TEXT("Error Enumerating Interfaces: %d (size:%d)!\n"), err, size);
        OutputDebugString(SzBuf);
        
        //
        // However, if it should be ok to Uninstall the Timestmp service using this easily.
        //
        if (0 == InstallFlag) {
            RemoveTimeStampService();
        }
        
        wprintf(TEXT("Exiting...\n"));

        goto cleanup;

    } else {

        OutputDebugString(TEXT("OK, so we got the interfaces.\n"));

    }

    // Display the interfaces for the user.
    wprintf(TEXT("\nThe interfaces available for (un)installing time stamp module are - \n"));
    len = 0;

    for (i = 1; len < size ; i++) {

        pIf = (PTC_IFC_DESCRIPTOR)(Buffer + len);
        wprintf(TEXT("[%d]:%ws\n\t%ws\n"), i, pIf->pInterfaceName, pIf->pInterfaceID);

        // Move to next interface
        len += pIf->Length;
        
        if (NULL != wcsstr(pIf->pInterfaceName, L"WAN")) {
            wprintf(TEXT("Please disconnect WAN links before installing Timestmp\n"));
            goto cleanup;
        }

    }

    wprintf(TEXT("[%d]:NDISWANIP (the WAN Interface)\n"), i);
    
    // Try to get the interface ID thrice...
    j = 0;

get_interfaceid:
    
    wprintf(TEXT("\nYour choice:"));
    fflush(stdin);

    wscanf(TEXT("%d"), &interfaceid);
    
    if (interfaceid < 1 || (interfaceid > i)) {

        j++;
        
        if (j > 2) {

            wprintf(TEXT("Invalid Choice - Exiting...\n"));
            goto cleanup;
        
        } else {
            
            wprintf(TEXT("Invalid choice - pick again\n"));
            goto get_interfaceid;
        }
    }

    // Get to the interface ID for the Interface selected.

    pIf = NULL;
    len = 0;

    if (i == interfaceid) {

        wprintf(TEXT("\nInterface selected for (un)installing Time Stamp - \nNdisWanIp\n\n\n"));
        WANlink = TRUE;
        pIf = NULL;

    } else {

        for (i = 1; i <= interfaceid ; i++) {

            pIf = (PTC_IFC_DESCRIPTOR)(Buffer + len);
            wprintf(TEXT("[%d]:%ws\n\t%ws\n"), i, pIf->pInterfaceName, pIf->pInterfaceID);

            if (i == interfaceid) {

                break;

            }

            // Move to next interface
            len += pIf->Length;

        }
        wprintf(TEXT("\nInterface selected for (un)installing Time Stamp - \n%ws\n\n\n"), pIf->pInterfaceName);

    }


    //
    // Branch here for Uninstall/Install.
    //
    if (InstallFlag == FALSE) {
        
        if (!DeleteTimeStamp(pIf)) {
            
            wprintf(TEXT("Delete TimeStamp Failed!\n"));

        }

        return;
    } 

    //
    // This is the regular install path.
    //

    j = 0;
get_servicetype:
    wprintf(TEXT("\nWould you like this service to be- [A]UTO, [M]ANUAL, [D]ISABLED:"));
    fflush(stdin);
    wscanf(TEXT("%[a-z]"), &servicetype);

    switch (towupper(servicetype)) {
    
    case TEXT('A'):
        
        wprintf(TEXT("\nYou have chosen AUTO start up option\n"));
        starttype = SERVICE_AUTO_START;

        break;

    case TEXT('D'):
        
        wprintf(TEXT("\nYou have chosen DISABLED start up option\n"));
        starttype = SERVICE_DISABLED;
        break;

    case TEXT('M'):
        
        wprintf(TEXT("\nYou have chosen MANUAL start up option"));
        starttype = SERVICE_DEMAND_START;
        break;

    default:
        
        if (j > 2) {
            
            wprintf(TEXT("\nIncorrect choice. Exiting...\n"));
            goto cleanup;

        } else {

            j++;
            wprintf(TEXT("\nInvalid - Choose again.\n"));
            goto get_servicetype;

        }
        break;
        
    }

    wprintf(TEXT("\n\n\n"));
    //
    // We have enough info to muck with the registry now.
    //

    // 1.1 open psched regkey and add profile
    ret = RegOpenKeyEx(
                       HKEY_LOCAL_MACHINE,
                       REGKEY_PSCHED_PARAMS,
                       0,
                       KEY_ALL_ACCESS,
                       &hConfigKey);
    
    if (ret !=ERROR_SUCCESS){

        wprintf(TEXT("Cant OPEN key\n"));
        goto cleanup;

    }

    ret = RegSetValueEx(
                        hConfigKey,
                        TEXT("Profiles"),
                        0,
                        REG_MULTI_SZ,
                        (LPBYTE)Profiles,
                        sizeof(Profiles)
                        );

    if (ret !=ERROR_SUCCESS){

        wprintf(TEXT("Cant SET Value:Profiles\n"));
        RegCloseKey(hConfigKey);
        goto cleanup;


    }

    ret = RegSetValueEx(
                    hConfigKey,
                    TEXT("LANTEST"),
                    0,
                    REG_MULTI_SZ,
                    (LPBYTE)Lantest,
                    sizeof(Lantest)
                    );

    if (ret !=ERROR_SUCCESS){

        wprintf(TEXT("Cant SET Value:LANTEST\n"));
        RegCloseKey(hConfigKey);
        goto cleanup;


    } 

    RegCloseKey(hConfigKey);

    // 1.2 Open the adapters section and add the profile
    if (!WANlink) {
        KeyBuffer = malloc(sizeof(TCHAR) * (wcslen(pIf->pInterfaceID) + wcslen(REGKEY_PSCHED_PARAMS_ADAPTERS)));
    
    } else {

        KeyBuffer = malloc(sizeof(TCHAR) * (wcslen(TEXT("NdisWanIp")) + wcslen(REGKEY_PSCHED_PARAMS_ADAPTERS)));

    }
    wcscpy(KeyBuffer, REGKEY_PSCHED_PARAMS_ADAPTERS);
    wcscat(KeyBuffer, TEXT("\\"));
    if (!WANlink) {
        wcscat(KeyBuffer, pIf->pInterfaceID);
    } else {
        wcscat(KeyBuffer, TEXT("NdisWanIp"));
    }

    ret = RegOpenKeyEx(
                       HKEY_LOCAL_MACHINE,
                       KeyBuffer,
                       0,
                       KEY_ALL_ACCESS,
                       &hConfigKey);

    if (ret != ERROR_SUCCESS) {

        wprintf(TEXT("INSTALLER: Couldn't open Regkey for Adapter specific info\n"));
        free(KeyBuffer);
        RegCloseKey(hConfigKey);
        goto cleanup;


    }

    ret = RegSetValueEx(
                    hConfigKey,
                    TEXT("Profile"),
                    0,
                    REG_SZ,
                    (LPBYTE)Profiles,
                    sizeof(Profiles)
                    );

    if (ret !=ERROR_SUCCESS){

        wprintf(TEXT("Cant SET Value:LANTEST under PARAMETERS\\ADAPTERS\n"));
        free(KeyBuffer);
        RegCloseKey(hConfigKey);
        goto cleanup;


    } 

    free(KeyBuffer);
    RegCloseKey(hConfigKey);

    // 2. throw in time stamp into the registry

    ret = RegCreateKeyEx(
                         HKEY_LOCAL_MACHINE,                // handle of an open key
                         REGKEY_TIMESTMP,         // address of subkey name
                         0,           // reserved
                         TEXT(""),           // address of class string
                         REG_OPTION_NON_VOLATILE,          // special options flag
                         KEY_ALL_ACCESS,        // desired security access
                         NULL,                            // address of key security structure
                         &TimeStampKey,          // address of buffer for opened handle
                         &Disposition   // address of disposition value buffer
                         );
 
    if (ret != ERROR_SUCCESS) {
        wprintf(TEXT("Couldn't open Regkey to plumb time stamp module\n"));
        RegCloseKey(hConfigKey);
        goto cleanup;

    }

    if (Disposition == REG_OPENED_EXISTING_KEY) {
        wprintf(TEXT("Time Stamp module is already installed.\n\n\n\n"));
        RegCloseKey(hConfigKey);
        goto cleanup;

    }
    
    RegCloseKey(hConfigKey);    

    // 3. Create the service...

    schSCManager = OpenSCManager(
                                 NULL,            // machine (NULL == local)
                                 NULL,            // database (NULL == default)
                                 SC_MANAGER_ALL_ACCESS    // access required
                                 );
    
    if ( schSCManager ) {

        schService = CreateService(
                                   schSCManager,        // SCManager database
                                   TEXT("TimeStmp"),            // name of service
                                   TEXT("TimeStmp"),        // name to display
                                   SERVICE_ALL_ACCESS,        // desired access
                                   SERVICE_KERNEL_DRIVER,    // service type
                                   starttype,        // start type 
                                   SERVICE_ERROR_NORMAL,    // error control type
                                   TEXT("System32\\Drivers\\timestmp.sys"),            // service's binary
                                   NULL,            // no load ordering group
                                   NULL,            // no tag identifier
                                   NULL,            // BUGBUG: no depend upon PNP_TDI??
                                   NULL,            // LocalSystem account
                                   NULL);            // no password

        if (!schService) {

            // couldn't create it.
            wprintf(TEXT("Could NOT create Time Stamp service - %d"), GetLastError());
            goto cleanup;

        } else {

            wprintf(TEXT("\nThe service will start on reboot.\n"));
            Success = TRUE;

        }

        CloseServiceHandle(schService);
        CloseServiceHandle(schSCManager);
    
    } else {

        wprintf(TEXT("\nINSTALLER: Couldn't open Service Control Manager - Do you have access?\n"));

    }
    
    wprintf(TEXT("The Time Stamp module installation is complete.\n"));
    wprintf(TEXT("Please ensure that a copy of timestmp.sys exists in your\n"));
    wprintf(TEXT("\\system32\\drivers directory before you reboot.\n"));

cleanup:
    // cleanup before getting out
    free(Buffer);

cleanup_no_free:
    // deregister before bailing...

    err = TcDeregisterClient(hClient);

    if (NO_ERROR != err) {
        hClient = NULL;
        wsprintf(SzBuf, TEXT("Error DEregistering Client: %d - %d\n"), err, GetLastError());
        OutputDebugString(SzBuf);
        return;
    }

    if (Success) {
        ShutdownNT();
    }
}

//
// Delete the service and cleanup Psched regkeys
// 
BOOLEAN
DeleteTimeStamp(PTC_IFC_DESCRIPTOR pIf)
{

    SC_HANDLE       schService;
    SC_HANDLE       schSCManager;
    TCHAR           *KBuffer;
    DWORD           err;
    HKEY            hKey;

    //
    // 1. Delete Timestamp service.
    //
    schSCManager = OpenSCManager(
                                 NULL,            // machine (NULL == local)
                                 NULL,            // database (NULL == default)
                                 SC_MANAGER_ALL_ACCESS    // access required
                                 );
    
    if ( schSCManager ) {

        schService = OpenService(
                                 schSCManager,  // handle to service control manager 
                                 TEXT("TimeStmp"), // pointer to name of service to start
                                 SERVICE_ALL_ACCESS // type of access to service
                                 );

        if (!schService) {

            // couldn't open it.
            wprintf(TEXT("Could NOT open Time Stamp service - %d\n"), GetLastError());
            wprintf(TEXT("Deletion of Time Stamp Service was UNSUCCESSFUL\n"));
            //return FALSE;

        } else {

            if (!DeleteService(schService)) {

                wprintf(TEXT("\nThe deletion of Timestamp service has failed - error (%d).\n"), GetLastError());

            } else {

                wprintf(TEXT("\nThe service will NOT start on reboot.\n"));
            }

            

        }

        CloseServiceHandle(schService);
        CloseServiceHandle(schSCManager);
    
    } else {

        wprintf(TEXT("\nINSTALLER: Couldn't open Service Control Manager - Do you have access?\n"));

    }

    //
    // 2. Clean up psched registry.
    //
    err = RegOpenKeyEx(
                       HKEY_LOCAL_MACHINE,
                       REGKEY_PSCHED_PARAMS,
                       0,
                       KEY_ALL_ACCESS,
                       &hKey);
    
    if (err !=ERROR_SUCCESS){

        wprintf(TEXT("Cant OPEN key\n"));
        return FALSE;

    }

    err = RegDeleteValue(
                         hKey,
                         TEXT("Profiles")
                         );

    if (err !=ERROR_SUCCESS){

        wprintf(TEXT("Cant Delete Value:Profiles\n"));
        RegCloseKey(hKey);
        return FALSE;
    }

    err = RegDeleteValue(
                         hKey,
                         TEXT("LANTEST")
                         );

    if (err != ERROR_SUCCESS){

        wprintf(TEXT("Cant Delete Value:LANTEST\n"));
        RegCloseKey(hKey);
        return FALSE;
    } 

    RegCloseKey(hKey);

    // 2.2 Clean up the adapter specific registry
    if (!WANlink) {
        KBuffer = malloc(sizeof(TCHAR) * (wcslen(pIf->pInterfaceID) + wcslen(REGKEY_PSCHED_PARAMS_ADAPTERS)));
    
    } else {

        KBuffer = malloc(sizeof(TCHAR) * (wcslen(TEXT("NdisWanIp")) + wcslen(REGKEY_PSCHED_PARAMS_ADAPTERS)));

    }
    wcscpy(KBuffer, REGKEY_PSCHED_PARAMS_ADAPTERS);
    wcscat(KBuffer, TEXT("\\"));
    if (!WANlink) {
        wcscat(KBuffer, pIf->pInterfaceID);
    } else {
        wcscat(KBuffer, TEXT("NdisWanIp"));
    }

    err = RegOpenKeyEx(
                       HKEY_LOCAL_MACHINE,
                       KBuffer,
                       0,
                       KEY_ALL_ACCESS,
                       &hKey);

    if (err != ERROR_SUCCESS) {

        wprintf(TEXT("INSTALLER: Couldn't open Regkey for Adapter specific info\n"));
        wprintf(TEXT("INSTALLER: CLEAN UP is partial\n"));
        free(KBuffer);
        return FALSE;
    }

    err = RegDeleteValue(
                    hKey,
                    TEXT("Profile")
                    );

    if (err !=ERROR_SUCCESS){

        wprintf(TEXT("Cant Delete Value:LANTEST under PARAMETERS\\ADAPTERS\n"));
        wprintf(TEXT("INSTALLER: CLEAN UP is partial\n"));
        free(KBuffer);
        RegCloseKey(hKey);
        return FALSE;
    } 

    free(KBuffer);
    RegCloseKey(hKey);
    
    wprintf(TEXT("The Time Stamp service is successfully deleted\n"));
    wprintf(TEXT("You need to reboot for the changes to take effect\n"));
    return TRUE;

}

// Just delete the service (no psched stuff)
VOID RemoveTimeStampService(
                            )
{
    SC_HANDLE       schService;
    SC_HANDLE       schSCManager;
    TCHAR           *KBuffer;
    DWORD           err;
    HKEY            hKey;

    //
    // 1. Delete Timestamp service.
    //
    schSCManager = OpenSCManager(
                                 NULL,            // machine (NULL == local)
                                 NULL,            // database (NULL == default)
                                 SC_MANAGER_ALL_ACCESS    // access required
                                 );

    if ( schSCManager ) {

        schService = OpenService(
                                 schSCManager,  // handle to service control manager 
                                 TEXT("TimeStmp"), // pointer to name of service to start
                                 SERVICE_ALL_ACCESS // type of access to service
                                 );

        if (!schService) {

            // couldn't open it.
            wprintf(TEXT("Could NOT open Time Stamp service - %d\n"), GetLastError());
            wprintf(TEXT("Deletion of Time Stamp Service was UNSUCCESSFUL\n"));
            return;

        } else {

            if (!DeleteService(schService)) {

                wprintf(TEXT("\nThe deletion of Timestamp service has failed - error (%d).\n"), GetLastError());

            } else {

                wprintf(TEXT("\nThe service will NOT start on reboot.\n"));
            }

        
            
        }

        CloseServiceHandle(schService);
        CloseServiceHandle(schSCManager);

    } else {

        wprintf(TEXT("\nINSTALLER: Couldn't open Service Control Manager - Do you have access?\n"));

    }

    wprintf(TEXT("The Time Stamp service is successfully deleted\n"));
    wprintf(TEXT("You need to reboot for the changes to take effect\n"));
    return;
}

VOID ShutdownNT()
{


	HANDLE				hToken;		// handle to process token
	TOKEN_PRIVILEGES	tkp;		// ptr. to token structure
    TCHAR               SzBuf[MAX_PATH];  
	BOOL                fResult;					// system shutdown flag
    INT                 nRet = IDYES;
	
	// Get the curren process token handle
	// so we can get shutdown privilege.

    if (!OpenProcessToken (GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) {
        wsprintf(SzBuf, TEXT("OpenProcessToken failed (%d)\n"), GetLastError());
        OutputDebugString(SzBuf);
        return;
    }									

	// Get the LUID for shutdown privilege

    LookupPrivilegeValue (NULL, SE_SHUTDOWN_NAME,
                          &tkp.Privileges[0].Luid);

    tkp.PrivilegeCount = 1;			// one privilege to set
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

	// Get shutdown privileges for this process

    AdjustTokenPrivileges (hToken, 
                           FALSE, 
                           &tkp, 
                           0,
                           (PTOKEN_PRIVILEGES) NULL, 
                           0);

	// Cannot test the return value of AdjustTokenPrivileges

	if (GetLastError() != ERROR_SUCCESS) {
        wsprintf(SzBuf, TEXT("AdjustTokenPriviledges failed (%d)\n"), GetLastError());
        OutputDebugString(SzBuf);
        CloseHandle(hToken);
        return;
    }

    CloseHandle(hToken);

    /*if (!InitiateSystemShutdownEx(
                                  NULL,
                                  ,
                                  0xffffff00,
                                  FALSE,    //BOOL bForceAppsClosed,  
                                  TRUE,     //BOOL bRebootAfterShutdown,  
                                  0         //DWORD dwReason
                                  )) {*/

    //
    // OK, so how about a popup?
    //


    nRet = MessageBox (
                       NULL,//hwndParent, 
                       TEXT("A reboot is required for TimeStamp Driver to get loaded. Please ensure that your %windir%\\system32\\driver's directory has a copy of timestmp.sys. Reboot now?"), 
                       TEXT("TIMESTAMP Driver Install Program"),
                       MB_YESNO | MB_ICONEXCLAMATION
                       );

    if (nRet == IDYES) {

        if (!ExitWindowsEx(EWX_REBOOT, 10)) {
    
            wsprintf(SzBuf, TEXT("InitializeShutdownEx failed (%d)\n"), GetLastError());
            OutputDebugString(SzBuf);

        } else {

            return;

        }


    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\tools\timestmp\ioctl.h ===
#ifndef _IOCTL
#define _IOCTL

//
// Create a list of the ports we want to keep timestamps for
// 5003 is no longer all we do.
//
typedef struct _PORT_ENTRY {
    LIST_ENTRY      Linkage;
    USHORT          Port;
    PFILE_OBJECT    FileObject;
    } PORT_ENTRY, *PPORT_ENTRY;

LIST_ENTRY      PortList;

NDIS_SPIN_LOCK  PortSpinLock;


// Prototypes
NTSTATUS
IoctlInitialize(
                PDRIVER_OBJECT  DriverObject
                );

NTSTATUS
IoctlHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
IoctlCleanup();

PPORT_ENTRY 
CheckInPortList
               (USHORT Port
               );

VOID
RemoveAllPortsForFileObject(
                            PFILE_OBJECT FileObject
                            );


// Other vars.

PDEVICE_OBJECT          TimestmpDeviceObject;
#pragma NDIS_PAGEABLE_FUNCTION(IoctlHandler)

//
// Define the ioctls for adding and removing ports.
#define CTRL_CODE(function, method, access) \
                CTL_CODE(FILE_DEVICE_NETWORK, function, method, access)

#define IOCTL_TIMESTMP_REGISTER_PORT       CTRL_CODE( 0x847, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_TIMESTMP_DEREGISTER_PORT     CTRL_CODE( 0x848, METHOD_BUFFERED, FILE_WRITE_ACCESS)

UNICODE_STRING  TimestmpDriverName;
UNICODE_STRING  symbolicLinkName;
DRIVER_OBJECT   TimestmpDriverObject;

#endif //_IOCTL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\qos\tools\timestmp\ioctl.c ===
#include "timestmp.h"

#define FRIENDLY_NAME 	L"\\DosDevices\\Timestmp"

NTSTATUS
IoctlInitialize(
    PDRIVER_OBJECT 	DriverObject
    )

/*++

Routine Description:

    Perform initialization 

Arguments:

    DriverObject - pointer to DriverObject from DriverEntry
    InitShutdownMask - pointer to mask used to indicate which events have been
        successfully init'ed

Return Value:

    STATUS_SUCCESS if everything worked ok

--*/

{
    NTSTATUS Status;
    UINT FuncIndex;

    //
    // Initialize the driver object's entry points
    //

    DriverObject->FastIoDispatch = NULL;

    for (FuncIndex = 0; FuncIndex <= IRP_MJ_MAXIMUM_FUNCTION; FuncIndex++) {
        DriverObject->MajorFunction[FuncIndex] = IoctlHandler;
    }

	RtlInitUnicodeString(&TimestmpDriverName,   
                     L"\\Device\\Timestmp");

    Status = IoCreateDevice(DriverObject,
                            0,
                            &TimestmpDriverName,
                            FILE_DEVICE_NETWORK,
                            FILE_DEVICE_SECURE_OPEN,
                            FALSE,
                            &TimestmpDeviceObject);

    if ( NT_SUCCESS( Status )) {

		// Now create a symbolic link so that apps can open with createfile.
		
        DbgPrint("IoCreateDevice SUCCESS!\n");

	 	RtlInitUnicodeString (&symbolicLinkName, FRIENDLY_NAME);

	 	DbgPrint("The DeviceName(%ws) and FriendlyName(%ws) are OK\n", TimestmpDriverName, symbolicLinkName);
		Status = IoCreateSymbolicLink(&symbolicLinkName, &TimestmpDriverName);

 		if (!NT_SUCCESS (Status)) {

	    	DbgPrint("Failed to create symbolic link: %lx\n", Status);
     		//IoDeleteDevice(TimestmpDeviceObject);
	     	return STATUS_UNSUCCESSFUL;
 		}

        TimestmpDeviceObject->Flags |= DO_BUFFERED_IO;

    } else {
    
        DbgPrint("IoCreateDevice failed. Status = %x\n", Status);
        TimestmpDeviceObject = NULL;
    }

    return Status;
}


NTSTATUS
IoctlHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Process the IRPs sent to this device.

Arguments:

    DeviceObject - pointer to a device object
    Irp      - pointer to an I/O Request Packet

Return Value:

    None

--*/

{
    PIO_STACK_LOCATION  irpStack;
    PVOID               ioBuffer;
    ULONG               inputBufferLength;
    ULONG               outputBufferLength;
    ULONG               ioControlCode;
    UCHAR				saveControlFlags;
    NTSTATUS            Status = STATUS_SUCCESS;
	PPORT_ENTRY			pPortEntry;
	PLIST_ENTRY			ListEntry;
	USHORT				Port = 0;
    PAGED_CODE();

    //
    // Init to default settings- we only expect 1 type of
    //     IOCTL to roll through here, all others an error.
    //

    Irp->IoStatus.Status      = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the current location in the Irp. This is where
    //     the function codes and parameters are located.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get the pointer to the input/output buffer and it's length
    //

    ioBuffer           	= Irp->AssociatedIrp.SystemBuffer;
    inputBufferLength  	= irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength 	= irpStack->Parameters.DeviceIoControl.OutputBufferLength;
    ioControlCode 		= irpStack->Parameters.DeviceIoControl.IoControlCode;
    saveControlFlags 	= irpStack->Control;


	
    switch (irpStack->MajorFunction) {

    case IRP_MJ_CREATE:
		DbgPrint("CREATE\n");
        break;

    case IRP_MJ_READ:
		DbgPrint("READ\n");
        break;

    case IRP_MJ_CLOSE:
    	DbgPrint("CLOSE\n");
        DbgPrint("FileObject %X\n", irpStack->FileObject);

        RemoveAllPortsForFileObject(irpStack->FileObject);
        
        //
        // make sure we clean all the objects for this particular
        // file object, since it's closing right now.
        //

        break;

    case IRP_MJ_CLEANUP:
		DbgPrint("CLEANUP\n");

        break;

    case IRP_MJ_SHUTDOWN:
    	DbgPrint("Shutdown\n");
        break;

    case IRP_MJ_DEVICE_CONTROL:

		DbgPrint("The ioBuffer is %X and the contents are %d\n", ioBuffer, Port);
		Port = *(USHORT *)ioBuffer;
		DbgPrint("The Port number being added is %d\n", Port);

        switch (ioControlCode) {

        case IOCTL_TIMESTMP_REGISTER_PORT:
			DbgPrint("Register\n");
			//
			// Grab the PortList lock and Insert the new port.
			//
			NdisAcquireSpinLock(&PortSpinLock);

			pPortEntry = ExAllocatePool(
										NonPagedPool,
										sizeof(PORT_ENTRY));
			if (pPortEntry) {

				InitializeListHead(&pPortEntry->Linkage);
				pPortEntry->Port = Port;
				pPortEntry->FileObject = irpStack->FileObject;
				InsertHeadList(&PortList, &pPortEntry->Linkage);
				DbgPrint("Successfully inserted %d\n", Port);											

			} else {

				DbgPrint("Couldn't allocate memory\n");

			}
			
			NdisReleaseSpinLock(&PortSpinLock);
        	break;

		case IOCTL_TIMESTMP_DEREGISTER_PORT:

			DbgPrint("DERegister\n");
			//
			// Grab the PortList lock and REMOVE the new port.
			//
			NdisAcquireSpinLock(&PortSpinLock);

			pPortEntry = CheckInPortList(Port);
			if (pPortEntry) {

				RemoveEntryList(&pPortEntry->Linkage);
				ExFreePool(pPortEntry);
				
				DbgPrint("Successfully removed/freed %d\n", Port);											

			} else {

				DbgPrint("Couldn't find port %d\n", Port);

			}

			
			NdisReleaseSpinLock(&PortSpinLock);

	        break;
        
        }	// switch (ioControlCode)
        
        break;


    default:
        DbgPrint("GPCIoctl: Unknown IRP major function = %08X\n", irpStack->MajorFunction);

        Status = STATUS_UNSUCCESSFUL;
        break;
    }

    DbgPrint("GPCIoctl: Status=0x%X, IRP=0x%X, outSize=%d\n", Status, (ULONG_PTR)Irp,  outputBufferLength);
    
    if (Status != STATUS_PENDING) {

        //
        // IRP completed and it's not Pending, we need to restore the Control flags,
        // since it might have been marked as Pending before...
        //

        irpStack->Control = saveControlFlags;
        
        Irp->IoStatus.Status = Status;
        Irp->IoStatus.Information = outputBufferLength;
        
        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    }


    return Status;

} // GPCIoctl




VOID
IoctlCleanup(
	    	)

/*++

Routine Description:

    Cleanup code for Initialize

Arguments:

    ShutdownMask - mask indicating which functions need to be cleaned up

Return Value:

    None

--*/

{

	IoDeleteDevice( TimestmpDeviceObject );

}

VOID
RemoveAllPortsForFileObject(
							PFILE_OBJECT FileObject
							)
{

	PLIST_ENTRY		ListEntry;
	PPORT_ENTRY		pPortEntry;
	
	NdisAcquireSpinLock(&PortSpinLock);
	ListEntry = PortList.Flink;
	
	while (ListEntry != &PortList) {

		pPortEntry = CONTAINING_RECORD(ListEntry, PORT_ENTRY, Linkage);

		ListEntry = ListEntry->Flink;

		if (FileObject == pPortEntry->FileObject) {

			DbgPrint("Deleting Port%d for FileObject0x%X\n", pPortEntry->Port, pPortEntry->FileObject);
			RemoveEntryList(&pPortEntry->Linkage);
			ExFreePool(pPortEntry);

		}
		
	}

	NdisReleaseSpinLock(&PortSpinLock);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rndis\inf\makefile.inc ===
_LNG=$(LANGUAGE)
_INX=.
STAMP=stampinf -f $@ -d date -v 

$(O)\usb8023.inf: $(_INX)\usb8023.inx $(_LNG)\usb8023.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rndis\inc\rndis.h ===
/***************************************************************************

Copyright (c) 1999  Microsoft Corporation

Module Name:

    RNDIS.H

Abstract:

    This module defines the Remote NDIS message structures.

Environment:

    kernel mode only

Notes:

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

    Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    2/8/99 : created

Authors:

    
****************************************************************************/


#ifndef _RNDIS_H_
#define _RNDIS_H_

//
//  Basic types
//
typedef UINT32                                  RNDIS_REQUEST_ID;
typedef UINT32                                  RNDIS_HANDLE;
typedef UINT32                                  RNDIS_STATUS;
typedef UINT32                                  RNDIS_REQUEST_TYPE;
typedef UINT32                                  RNDIS_OID;
typedef UINT32                                  RNDIS_CLASS_ID;
typedef UINT32                                  RNDIS_MEDIUM;
typedef UINT32                                  *PRNDIS_REQUEST_ID;
typedef UINT32                                  *PRNDIS_HANDLE;
typedef UINT32                                  *PRNDIS_STATUS;
typedef UINT32                                  *PRNDIS_REQUEST_TYPE;
typedef UINT32                                  *PRNDIS_OID;
typedef UINT32                                  *PRNDIS_CLASS_ID;
typedef UINT32                                  *PRNDIS_MEDIUM;
typedef UINT32                                  RNDIS_AF;

//
//  Status codes
//

#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS                          (0x00000000L)
#endif

#ifndef STATUS_UNSUCCESSFUL
#define STATUS_UNSUCCESSFUL                     (0xC0000001L)
#endif

#ifndef STATUS_PENDING
#define STATUS_PENDING                          (0x00000103L)
#endif

#ifndef STATUS_INSUFFICIENT_RESOURCES
#define STATUS_INSUFFICIENT_RESOURCES           (0xC000009AL)
#endif

#ifndef STATUS_BUFFER_OVERFLOW
#define STATUS_BUFFER_OVERFLOW                  (0x80000005L)
#endif

#ifndef STATUS_NOT_SUPPORTED
#define STATUS_NOT_SUPPORTED                    (0xC00000BBL)
#endif

#define RNDIS_STATUS_SUCCESS                    ((RNDIS_STATUS)STATUS_SUCCESS)
#define RNDIS_STATUS_PENDING                    ((RNDIS_STATUS)STATUS_PENDING)
#define RNDIS_STATUS_NOT_RECOGNIZED             ((RNDIS_STATUS)0x00010001L)
#define RNDIS_STATUS_NOT_COPIED                 ((RNDIS_STATUS)0x00010002L)
#define RNDIS_STATUS_NOT_ACCEPTED               ((RNDIS_STATUS)0x00010003L)
#define RNDIS_STATUS_CALL_ACTIVE                ((RNDIS_STATUS)0x00010007L)

#define RNDIS_STATUS_ONLINE                     ((RNDIS_STATUS)0x40010003L)
#define RNDIS_STATUS_RESET_START                ((RNDIS_STATUS)0x40010004L)
#define RNDIS_STATUS_RESET_END                  ((RNDIS_STATUS)0x40010005L)
#define RNDIS_STATUS_RING_STATUS                ((RNDIS_STATUS)0x40010006L)
#define RNDIS_STATUS_CLOSED                     ((RNDIS_STATUS)0x40010007L)
#define RNDIS_STATUS_WAN_LINE_UP                ((RNDIS_STATUS)0x40010008L)
#define RNDIS_STATUS_WAN_LINE_DOWN              ((RNDIS_STATUS)0x40010009L)
#define RNDIS_STATUS_WAN_FRAGMENT               ((RNDIS_STATUS)0x4001000AL)
#define RNDIS_STATUS_MEDIA_CONNECT              ((RNDIS_STATUS)0x4001000BL)
#define RNDIS_STATUS_MEDIA_DISCONNECT           ((RNDIS_STATUS)0x4001000CL)
#define RNDIS_STATUS_HARDWARE_LINE_UP           ((RNDIS_STATUS)0x4001000DL)
#define RNDIS_STATUS_HARDWARE_LINE_DOWN         ((RNDIS_STATUS)0x4001000EL)
#define RNDIS_STATUS_INTERFACE_UP               ((RNDIS_STATUS)0x4001000FL)
#define RNDIS_STATUS_INTERFACE_DOWN             ((RNDIS_STATUS)0x40010010L)
#define RNDIS_STATUS_MEDIA_BUSY                 ((RNDIS_STATUS)0x40010011L)
#define RNDIS_STATUS_MEDIA_SPECIFIC_INDICATION  ((RNDIS_STATUS)0x40010012L)
#define RNDIS_STATUS_WW_INDICATION              RNDIS_STATUS_MEDIA_SPECIFIC_INDICATION
#define RNDIS_STATUS_LINK_SPEED_CHANGE          ((RNDIS_STATUS)0x40010013L)

#define RNDIS_STATUS_NOT_RESETTABLE             ((RNDIS_STATUS)0x80010001L)
#define RNDIS_STATUS_SOFT_ERRORS                ((RNDIS_STATUS)0x80010003L)
#define RNDIS_STATUS_HARD_ERRORS                ((RNDIS_STATUS)0x80010004L)
#define RNDIS_STATUS_BUFFER_OVERFLOW            ((RNDIS_STATUS)STATUS_BUFFER_OVERFLOW)

#define RNDIS_STATUS_FAILURE                    ((RNDIS_STATUS)STATUS_UNSUCCESSFUL)
#define RNDIS_STATUS_RESOURCES                  ((RNDIS_STATUS)STATUS_INSUFFICIENT_RESOURCES)
#define RNDIS_STATUS_CLOSING                    ((RNDIS_STATUS)0xC0010002L)
#define RNDIS_STATUS_BAD_VERSION                ((RNDIS_STATUS)0xC0010004L)
#define RNDIS_STATUS_BAD_CHARACTERISTICS        ((RNDIS_STATUS)0xC0010005L)
#define RNDIS_STATUS_ADAPTER_NOT_FOUND          ((RNDIS_STATUS)0xC0010006L)
#define RNDIS_STATUS_OPEN_FAILED                ((RNDIS_STATUS)0xC0010007L)
#define RNDIS_STATUS_DEVICE_FAILED              ((RNDIS_STATUS)0xC0010008L)
#define RNDIS_STATUS_MULTICAST_FULL             ((RNDIS_STATUS)0xC0010009L)
#define RNDIS_STATUS_MULTICAST_EXISTS           ((RNDIS_STATUS)0xC001000AL)
#define RNDIS_STATUS_MULTICAST_NOT_FOUND        ((RNDIS_STATUS)0xC001000BL)
#define RNDIS_STATUS_REQUEST_ABORTED            ((RNDIS_STATUS)0xC001000CL)
#define RNDIS_STATUS_RESET_IN_PROGRESS          ((RNDIS_STATUS)0xC001000DL)
#define RNDIS_STATUS_CLOSING_INDICATING         ((RNDIS_STATUS)0xC001000EL)
#define RNDIS_STATUS_NOT_SUPPORTED              ((RNDIS_STATUS)STATUS_NOT_SUPPORTED)
#define RNDIS_STATUS_INVALID_PACKET             ((RNDIS_STATUS)0xC001000FL)
#define RNDIS_STATUS_OPEN_LIST_FULL             ((RNDIS_STATUS)0xC0010010L)
#define RNDIS_STATUS_ADAPTER_NOT_READY          ((RNDIS_STATUS)0xC0010011L)
#define RNDIS_STATUS_ADAPTER_NOT_OPEN           ((RNDIS_STATUS)0xC0010012L)
#define RNDIS_STATUS_NOT_INDICATING             ((RNDIS_STATUS)0xC0010013L)
#define RNDIS_STATUS_INVALID_LENGTH             ((RNDIS_STATUS)0xC0010014L)
#define RNDIS_STATUS_INVALID_DATA               ((RNDIS_STATUS)0xC0010015L)
#define RNDIS_STATUS_BUFFER_TOO_SHORT           ((RNDIS_STATUS)0xC0010016L)
#define RNDIS_STATUS_INVALID_OID                ((RNDIS_STATUS)0xC0010017L)
#define RNDIS_STATUS_ADAPTER_REMOVED            ((RNDIS_STATUS)0xC0010018L)
#define RNDIS_STATUS_UNSUPPORTED_MEDIA          ((RNDIS_STATUS)0xC0010019L)
#define RNDIS_STATUS_GROUP_ADDRESS_IN_USE       ((RNDIS_STATUS)0xC001001AL)
#define RNDIS_STATUS_FILE_NOT_FOUND             ((RNDIS_STATUS)0xC001001BL)
#define RNDIS_STATUS_ERROR_READING_FILE         ((RNDIS_STATUS)0xC001001CL)
#define RNDIS_STATUS_ALREADY_MAPPED             ((RNDIS_STATUS)0xC001001DL)
#define RNDIS_STATUS_RESOURCE_CONFLICT          ((RNDIS_STATUS)0xC001001EL)
#define RNDIS_STATUS_NO_CABLE                   ((RNDIS_STATUS)0xC001001FL)

#define RNDIS_STATUS_INVALID_SAP                ((RNDIS_STATUS)0xC0010020L)
#define RNDIS_STATUS_SAP_IN_USE                 ((RNDIS_STATUS)0xC0010021L)
#define RNDIS_STATUS_INVALID_ADDRESS            ((RNDIS_STATUS)0xC0010022L)
#define RNDIS_STATUS_VC_NOT_ACTIVATED           ((RNDIS_STATUS)0xC0010023L)
#define RNDIS_STATUS_DEST_OUT_OF_ORDER          ((RNDIS_STATUS)0xC0010024L)
#define RNDIS_STATUS_VC_NOT_AVAILABLE           ((RNDIS_STATUS)0xC0010025L)
#define RNDIS_STATUS_CELLRATE_NOT_AVAILABLE     ((RNDIS_STATUS)0xC0010026L)
#define RNDIS_STATUS_INCOMPATABLE_QOS           ((RNDIS_STATUS)0xC0010027L)
#define RNDIS_STATUS_AAL_PARAMS_UNSUPPORTED     ((RNDIS_STATUS)0xC0010028L)
#define RNDIS_STATUS_NO_ROUTE_TO_DESTINATION    ((RNDIS_STATUS)0xC0010029L)

#define RNDIS_STATUS_TOKEN_RING_OPEN_ERROR      ((RNDIS_STATUS)0xC0011000L)


//
// Object Identifiers used by NdisRequest Query/Set Information
//

//
// General Objects
//

#define RNDIS_OID_GEN_SUPPORTED_LIST                    0x00010101
#define RNDIS_OID_GEN_HARDWARE_STATUS                   0x00010102
#define RNDIS_OID_GEN_MEDIA_SUPPORTED                   0x00010103
#define RNDIS_OID_GEN_MEDIA_IN_USE                      0x00010104
#define RNDIS_OID_GEN_MAXIMUM_LOOKAHEAD                 0x00010105
#define RNDIS_OID_GEN_MAXIMUM_FRAME_SIZE                0x00010106
#define RNDIS_OID_GEN_LINK_SPEED                        0x00010107
#define RNDIS_OID_GEN_TRANSMIT_BUFFER_SPACE             0x00010108
#define RNDIS_OID_GEN_RECEIVE_BUFFER_SPACE              0x00010109
#define RNDIS_OID_GEN_TRANSMIT_BLOCK_SIZE               0x0001010A
#define RNDIS_OID_GEN_RECEIVE_BLOCK_SIZE                0x0001010B
#define RNDIS_OID_GEN_VENDOR_ID                         0x0001010C
#define RNDIS_OID_GEN_VENDOR_DESCRIPTION                0x0001010D
#define RNDIS_OID_GEN_CURRENT_PACKET_FILTER             0x0001010E
#define RNDIS_OID_GEN_CURRENT_LOOKAHEAD                 0x0001010F
#define RNDIS_OID_GEN_DRIVER_VERSION                    0x00010110
#define RNDIS_OID_GEN_MAXIMUM_TOTAL_SIZE                0x00010111
#define RNDIS_OID_GEN_PROTOCOL_OPTIONS                  0x00010112
#define RNDIS_OID_GEN_MAC_OPTIONS                       0x00010113
#define RNDIS_OID_GEN_MEDIA_CONNECT_STATUS              0x00010114
#define RNDIS_OID_GEN_MAXIMUM_SEND_PACKETS              0x00010115
#define RNDIS_OID_GEN_VENDOR_DRIVER_VERSION             0x00010116
#define RNDIS_OID_GEN_NETWORK_LAYER_ADDRESSES           0x00010118
#define RNDIS_OID_GEN_TRANSPORT_HEADER_OFFSET           0x00010119
#define RNDIS_OID_GEN_MACHINE_NAME                      0x0001021A
#define RNDIS_OID_GEN_RNDIS_CONFIG_PARAMETER            0x0001021B

#define RNDIS_OID_GEN_XMIT_OK                           0x00020101
#define RNDIS_OID_GEN_RCV_OK                            0x00020102
#define RNDIS_OID_GEN_XMIT_ERROR                        0x00020103
#define RNDIS_OID_GEN_RCV_ERROR                         0x00020104
#define RNDIS_OID_GEN_RCV_NO_BUFFER                     0x00020105

#define RNDIS_OID_GEN_DIRECTED_BYTES_XMIT               0x00020201
#define RNDIS_OID_GEN_DIRECTED_FRAMES_XMIT              0x00020202
#define RNDIS_OID_GEN_MULTICAST_BYTES_XMIT              0x00020203
#define RNDIS_OID_GEN_MULTICAST_FRAMES_XMIT             0x00020204
#define RNDIS_OID_GEN_BROADCAST_BYTES_XMIT              0x00020205
#define RNDIS_OID_GEN_BROADCAST_FRAMES_XMIT             0x00020206
#define RNDIS_OID_GEN_DIRECTED_BYTES_RCV                0x00020207
#define RNDIS_OID_GEN_DIRECTED_FRAMES_RCV               0x00020208
#define RNDIS_OID_GEN_MULTICAST_BYTES_RCV               0x00020209
#define RNDIS_OID_GEN_MULTICAST_FRAMES_RCV              0x0002020A
#define RNDIS_OID_GEN_BROADCAST_BYTES_RCV               0x0002020B
#define RNDIS_OID_GEN_BROADCAST_FRAMES_RCV              0x0002020C

#define RNDIS_OID_GEN_RCV_CRC_ERROR                     0x0002020D
#define RNDIS_OID_GEN_TRANSMIT_QUEUE_LENGTH             0x0002020E

#define RNDIS_OID_GEN_GET_TIME_CAPS                     0x0002020F
#define RNDIS_OID_GEN_GET_NETCARD_TIME                  0x00020210

//
// These are connection-oriented general OIDs.
// These replace the above OIDs for connection-oriented media.
//
#define RNDIS_OID_GEN_CO_SUPPORTED_LIST                 0x00010101
#define RNDIS_OID_GEN_CO_HARDWARE_STATUS                0x00010102
#define RNDIS_OID_GEN_CO_MEDIA_SUPPORTED                0x00010103
#define RNDIS_OID_GEN_CO_MEDIA_IN_USE                   0x00010104
#define RNDIS_OID_GEN_CO_LINK_SPEED                     0x00010105
#define RNDIS_OID_GEN_CO_VENDOR_ID                      0x00010106
#define RNDIS_OID_GEN_CO_VENDOR_DESCRIPTION             0x00010107
#define RNDIS_OID_GEN_CO_DRIVER_VERSION                 0x00010108
#define RNDIS_OID_GEN_CO_PROTOCOL_OPTIONS               0x00010109
#define RNDIS_OID_GEN_CO_MAC_OPTIONS                    0x0001010A
#define RNDIS_OID_GEN_CO_MEDIA_CONNECT_STATUS           0x0001010B
#define RNDIS_OID_GEN_CO_VENDOR_DRIVER_VERSION          0x0001010C
#define RNDIS_OID_GEN_CO_MINIMUM_LINK_SPEED             0x0001010D

#define RNDIS_OID_GEN_CO_GET_TIME_CAPS                  0x00010201
#define RNDIS_OID_GEN_CO_GET_NETCARD_TIME               0x00010202

//
// These are connection-oriented statistics OIDs.
//
#define RNDIS_OID_GEN_CO_XMIT_PDUS_OK                   0x00020101
#define RNDIS_OID_GEN_CO_RCV_PDUS_OK                    0x00020102
#define RNDIS_OID_GEN_CO_XMIT_PDUS_ERROR                0x00020103
#define RNDIS_OID_GEN_CO_RCV_PDUS_ERROR                 0x00020104
#define RNDIS_OID_GEN_CO_RCV_PDUS_NO_BUFFER             0x00020105


#define RNDIS_OID_GEN_CO_RCV_CRC_ERROR                  0x00020201
#define RNDIS_OID_GEN_CO_TRANSMIT_QUEUE_LENGTH          0x00020202
#define RNDIS_OID_GEN_CO_BYTES_XMIT                     0x00020203
#define RNDIS_OID_GEN_CO_BYTES_RCV                      0x00020204
#define RNDIS_OID_GEN_CO_BYTES_XMIT_OUTSTANDING         0x00020205
#define RNDIS_OID_GEN_CO_NETCARD_LOAD                   0x00020206

//
// These are objects for Connection-oriented media call-managers.
//
#define RNDIS_OID_CO_ADD_PVC                            0xFF000001
#define RNDIS_OID_CO_DELETE_PVC                         0xFF000002
#define RNDIS_OID_CO_GET_CALL_INFORMATION               0xFF000003
#define RNDIS_OID_CO_ADD_ADDRESS                        0xFF000004
#define RNDIS_OID_CO_DELETE_ADDRESS                     0xFF000005
#define RNDIS_OID_CO_GET_ADDRESSES                      0xFF000006
#define RNDIS_OID_CO_ADDRESS_CHANGE                     0xFF000007
#define RNDIS_OID_CO_SIGNALING_ENABLED                  0xFF000008
#define RNDIS_OID_CO_SIGNALING_DISABLED                 0xFF000009


//
// 802.3 Objects (Ethernet)
//

#define RNDIS_OID_802_3_PERMANENT_ADDRESS               0x01010101
#define RNDIS_OID_802_3_CURRENT_ADDRESS                 0x01010102
#define RNDIS_OID_802_3_MULTICAST_LIST                  0x01010103
#define RNDIS_OID_802_3_MAXIMUM_LIST_SIZE               0x01010104
#define RNDIS_OID_802_3_MAC_OPTIONS                     0x01010105

//
//
#define NDIS_802_3_MAC_OPTION_PRIORITY                  0x00000001

#define RNDIS_OID_802_3_RCV_ERROR_ALIGNMENT             0x01020101
#define RNDIS_OID_802_3_XMIT_ONE_COLLISION              0x01020102
#define RNDIS_OID_802_3_XMIT_MORE_COLLISIONS            0x01020103

#define RNDIS_OID_802_3_XMIT_DEFERRED                   0x01020201
#define RNDIS_OID_802_3_XMIT_MAX_COLLISIONS             0x01020202
#define RNDIS_OID_802_3_RCV_OVERRUN                     0x01020203
#define RNDIS_OID_802_3_XMIT_UNDERRUN                   0x01020204
#define RNDIS_OID_802_3_XMIT_HEARTBEAT_FAILURE          0x01020205
#define RNDIS_OID_802_3_XMIT_TIMES_CRS_LOST             0x01020206
#define RNDIS_OID_802_3_XMIT_LATE_COLLISIONS            0x01020207


//
// 802.5 Objects (Token-Ring)
//

#define RNDIS_OID_802_5_PERMANENT_ADDRESS               0x02010101
#define RNDIS_OID_802_5_CURRENT_ADDRESS                 0x02010102
#define RNDIS_OID_802_5_CURRENT_FUNCTIONAL              0x02010103
#define RNDIS_OID_802_5_CURRENT_GROUP                   0x02010104
#define RNDIS_OID_802_5_LAST_OPEN_STATUS                0x02010105
#define RNDIS_OID_802_5_CURRENT_RING_STATUS             0x02010106
#define RNDIS_OID_802_5_CURRENT_RING_STATE              0x02010107

#define RNDIS_OID_802_5_LINE_ERRORS                     0x02020101
#define RNDIS_OID_802_5_LOST_FRAMES                     0x02020102

#define RNDIS_OID_802_5_BURST_ERRORS                    0x02020201
#define RNDIS_OID_802_5_AC_ERRORS                       0x02020202
#define RNDIS_OID_802_5_ABORT_DELIMETERS                0x02020203
#define RNDIS_OID_802_5_FRAME_COPIED_ERRORS             0x02020204
#define RNDIS_OID_802_5_FREQUENCY_ERRORS                0x02020205
#define RNDIS_OID_802_5_TOKEN_ERRORS                    0x02020206
#define RNDIS_OID_802_5_INTERNAL_ERRORS                 0x02020207


//
// FDDI Objects
//

#define RNDIS_OID_FDDI_LONG_PERMANENT_ADDR              0x03010101
#define RNDIS_OID_FDDI_LONG_CURRENT_ADDR                0x03010102
#define RNDIS_OID_FDDI_LONG_MULTICAST_LIST              0x03010103
#define RNDIS_OID_FDDI_LONG_MAX_LIST_SIZE               0x03010104
#define RNDIS_OID_FDDI_SHORT_PERMANENT_ADDR             0x03010105
#define RNDIS_OID_FDDI_SHORT_CURRENT_ADDR               0x03010106
#define RNDIS_OID_FDDI_SHORT_MULTICAST_LIST             0x03010107
#define RNDIS_OID_FDDI_SHORT_MAX_LIST_SIZE              0x03010108

#define RNDIS_OID_FDDI_ATTACHMENT_TYPE                  0x03020101
#define RNDIS_OID_FDDI_UPSTREAM_NODE_LONG               0x03020102
#define RNDIS_OID_FDDI_DOWNSTREAM_NODE_LONG             0x03020103
#define RNDIS_OID_FDDI_FRAME_ERRORS                     0x03020104
#define RNDIS_OID_FDDI_FRAMES_LOST                      0x03020105
#define RNDIS_OID_FDDI_RING_MGT_STATE                   0x03020106
#define RNDIS_OID_FDDI_LCT_FAILURES                     0x03020107
#define RNDIS_OID_FDDI_LEM_REJECTS                      0x03020108
#define RNDIS_OID_FDDI_LCONNECTION_STATE                0x03020109

#define RNDIS_OID_FDDI_SMT_STATION_ID                   0x03030201
#define RNDIS_OID_FDDI_SMT_OP_VERSION_ID                0x03030202
#define RNDIS_OID_FDDI_SMT_HI_VERSION_ID                0x03030203
#define RNDIS_OID_FDDI_SMT_LO_VERSION_ID                0x03030204
#define RNDIS_OID_FDDI_SMT_MANUFACTURER_DATA            0x03030205
#define RNDIS_OID_FDDI_SMT_USER_DATA                    0x03030206
#define RNDIS_OID_FDDI_SMT_MIB_VERSION_ID               0x03030207
#define RNDIS_OID_FDDI_SMT_MAC_CT                       0x03030208
#define RNDIS_OID_FDDI_SMT_NON_MASTER_CT                0x03030209
#define RNDIS_OID_FDDI_SMT_MASTER_CT                    0x0303020A
#define RNDIS_OID_FDDI_SMT_AVAILABLE_PATHS              0x0303020B
#define RNDIS_OID_FDDI_SMT_CONFIG_CAPABILITIES          0x0303020C
#define RNDIS_OID_FDDI_SMT_CONFIG_POLICY                0x0303020D
#define RNDIS_OID_FDDI_SMT_CONNECTION_POLICY            0x0303020E
#define RNDIS_OID_FDDI_SMT_T_NOTIFY                     0x0303020F
#define RNDIS_OID_FDDI_SMT_STAT_RPT_POLICY              0x03030210
#define RNDIS_OID_FDDI_SMT_TRACE_MAX_EXPIRATION         0x03030211
#define RNDIS_OID_FDDI_SMT_PORT_INDEXES                 0x03030212
#define RNDIS_OID_FDDI_SMT_MAC_INDEXES                  0x03030213
#define RNDIS_OID_FDDI_SMT_BYPASS_PRESENT               0x03030214
#define RNDIS_OID_FDDI_SMT_ECM_STATE                    0x03030215
#define RNDIS_OID_FDDI_SMT_CF_STATE                     0x03030216
#define RNDIS_OID_FDDI_SMT_HOLD_STATE                   0x03030217
#define RNDIS_OID_FDDI_SMT_REMOTE_DISCONNECT_FLAG       0x03030218
#define RNDIS_OID_FDDI_SMT_STATION_STATUS               0x03030219
#define RNDIS_OID_FDDI_SMT_PEER_WRAP_FLAG               0x0303021A
#define RNDIS_OID_FDDI_SMT_MSG_TIME_STAMP               0x0303021B
#define RNDIS_OID_FDDI_SMT_TRANSITION_TIME_STAMP        0x0303021C
#define RNDIS_OID_FDDI_SMT_SET_COUNT                    0x0303021D
#define RNDIS_OID_FDDI_SMT_LAST_SET_STATION_ID          0x0303021E
#define RNDIS_OID_FDDI_MAC_FRAME_STATUS_FUNCTIONS       0x0303021F
#define RNDIS_OID_FDDI_MAC_BRIDGE_FUNCTIONS             0x03030220
#define RNDIS_OID_FDDI_MAC_T_MAX_CAPABILITY             0x03030221
#define RNDIS_OID_FDDI_MAC_TVX_CAPABILITY               0x03030222
#define RNDIS_OID_FDDI_MAC_AVAILABLE_PATHS              0x03030223
#define RNDIS_OID_FDDI_MAC_CURRENT_PATH                 0x03030224
#define RNDIS_OID_FDDI_MAC_UPSTREAM_NBR                 0x03030225
#define RNDIS_OID_FDDI_MAC_DOWNSTREAM_NBR               0x03030226
#define RNDIS_OID_FDDI_MAC_OLD_UPSTREAM_NBR             0x03030227
#define RNDIS_OID_FDDI_MAC_OLD_DOWNSTREAM_NBR           0x03030228
#define RNDIS_OID_FDDI_MAC_DUP_ADDRESS_TEST             0x03030229
#define RNDIS_OID_FDDI_MAC_REQUESTED_PATHS              0x0303022A
#define RNDIS_OID_FDDI_MAC_DOWNSTREAM_PORT_TYPE         0x0303022B
#define RNDIS_OID_FDDI_MAC_INDEX                        0x0303022C
#define RNDIS_OID_FDDI_MAC_SMT_ADDRESS                  0x0303022D
#define RNDIS_OID_FDDI_MAC_LONG_GRP_ADDRESS             0x0303022E
#define RNDIS_OID_FDDI_MAC_SHORT_GRP_ADDRESS            0x0303022F
#define RNDIS_OID_FDDI_MAC_T_REQ                        0x03030230
#define RNDIS_OID_FDDI_MAC_T_NEG                        0x03030231
#define RNDIS_OID_FDDI_MAC_T_MAX                        0x03030232
#define RNDIS_OID_FDDI_MAC_TVX_VALUE                    0x03030233
#define RNDIS_OID_FDDI_MAC_T_PRI0                       0x03030234
#define RNDIS_OID_FDDI_MAC_T_PRI1                       0x03030235
#define RNDIS_OID_FDDI_MAC_T_PRI2                       0x03030236
#define RNDIS_OID_FDDI_MAC_T_PRI3                       0x03030237
#define RNDIS_OID_FDDI_MAC_T_PRI4                       0x03030238
#define RNDIS_OID_FDDI_MAC_T_PRI5                       0x03030239
#define RNDIS_OID_FDDI_MAC_T_PRI6                       0x0303023A
#define RNDIS_OID_FDDI_MAC_FRAME_CT                     0x0303023B
#define RNDIS_OID_FDDI_MAC_COPIED_CT                    0x0303023C
#define RNDIS_OID_FDDI_MAC_TRANSMIT_CT                  0x0303023D
#define RNDIS_OID_FDDI_MAC_TOKEN_CT                     0x0303023E
#define RNDIS_OID_FDDI_MAC_ERROR_CT                     0x0303023F
#define RNDIS_OID_FDDI_MAC_LOST_CT                      0x03030240
#define RNDIS_OID_FDDI_MAC_TVX_EXPIRED_CT               0x03030241
#define RNDIS_OID_FDDI_MAC_NOT_COPIED_CT                0x03030242
#define RNDIS_OID_FDDI_MAC_LATE_CT                      0x03030243
#define RNDIS_OID_FDDI_MAC_RING_OP_CT                   0x03030244
#define RNDIS_OID_FDDI_MAC_FRAME_ERROR_THRESHOLD        0x03030245
#define RNDIS_OID_FDDI_MAC_FRAME_ERROR_RATIO            0x03030246
#define RNDIS_OID_FDDI_MAC_NOT_COPIED_THRESHOLD         0x03030247
#define RNDIS_OID_FDDI_MAC_NOT_COPIED_RATIO             0x03030248
#define RNDIS_OID_FDDI_MAC_RMT_STATE                    0x03030249
#define RNDIS_OID_FDDI_MAC_DA_FLAG                      0x0303024A
#define RNDIS_OID_FDDI_MAC_UNDA_FLAG                    0x0303024B
#define RNDIS_OID_FDDI_MAC_FRAME_ERROR_FLAG             0x0303024C
#define RNDIS_OID_FDDI_MAC_NOT_COPIED_FLAG              0x0303024D
#define RNDIS_OID_FDDI_MAC_MA_UNITDATA_AVAILABLE        0x0303024E
#define RNDIS_OID_FDDI_MAC_HARDWARE_PRESENT             0x0303024F
#define RNDIS_OID_FDDI_MAC_MA_UNITDATA_ENABLE           0x03030250
#define RNDIS_OID_FDDI_PATH_INDEX                       0x03030251
#define RNDIS_OID_FDDI_PATH_RING_LATENCY                0x03030252
#define RNDIS_OID_FDDI_PATH_TRACE_STATUS                0x03030253
#define RNDIS_OID_FDDI_PATH_SBA_PAYLOAD                 0x03030254
#define RNDIS_OID_FDDI_PATH_SBA_OVERHEAD                0x03030255
#define RNDIS_OID_FDDI_PATH_CONFIGURATION               0x03030256
#define RNDIS_OID_FDDI_PATH_T_R_MODE                    0x03030257
#define RNDIS_OID_FDDI_PATH_SBA_AVAILABLE               0x03030258
#define RNDIS_OID_FDDI_PATH_TVX_LOWER_BOUND             0x03030259
#define RNDIS_OID_FDDI_PATH_T_MAX_LOWER_BOUND           0x0303025A
#define RNDIS_OID_FDDI_PATH_MAX_T_REQ                   0x0303025B
#define RNDIS_OID_FDDI_PORT_MY_TYPE                     0x0303025C
#define RNDIS_OID_FDDI_PORT_NEIGHBOR_TYPE               0x0303025D
#define RNDIS_OID_FDDI_PORT_CONNECTION_POLICIES         0x0303025E
#define RNDIS_OID_FDDI_PORT_MAC_INDICATED               0x0303025F
#define RNDIS_OID_FDDI_PORT_CURRENT_PATH                0x03030260
#define RNDIS_OID_FDDI_PORT_REQUESTED_PATHS             0x03030261
#define RNDIS_OID_FDDI_PORT_MAC_PLACEMENT               0x03030262
#define RNDIS_OID_FDDI_PORT_AVAILABLE_PATHS             0x03030263
#define RNDIS_OID_FDDI_PORT_MAC_LOOP_TIME               0x03030264
#define RNDIS_OID_FDDI_PORT_PMD_CLASS                   0x03030265
#define RNDIS_OID_FDDI_PORT_CONNECTION_CAPABILITIES     0x03030266
#define RNDIS_OID_FDDI_PORT_INDEX                       0x03030267
#define RNDIS_OID_FDDI_PORT_MAINT_LS                    0x03030268
#define RNDIS_OID_FDDI_PORT_BS_FLAG                     0x03030269
#define RNDIS_OID_FDDI_PORT_PC_LS                       0x0303026A
#define RNDIS_OID_FDDI_PORT_EB_ERROR_CT                 0x0303026B
#define RNDIS_OID_FDDI_PORT_LCT_FAIL_CT                 0x0303026C
#define RNDIS_OID_FDDI_PORT_LER_ESTIMATE                0x0303026D
#define RNDIS_OID_FDDI_PORT_LEM_REJECT_CT               0x0303026E
#define RNDIS_OID_FDDI_PORT_LEM_CT                      0x0303026F
#define RNDIS_OID_FDDI_PORT_LER_CUTOFF                  0x03030270
#define RNDIS_OID_FDDI_PORT_LER_ALARM                   0x03030271
#define RNDIS_OID_FDDI_PORT_CONNNECT_STATE              0x03030272
#define RNDIS_OID_FDDI_PORT_PCM_STATE                   0x03030273
#define RNDIS_OID_FDDI_PORT_PC_WITHHOLD                 0x03030274
#define RNDIS_OID_FDDI_PORT_LER_FLAG                    0x03030275
#define RNDIS_OID_FDDI_PORT_HARDWARE_PRESENT            0x03030276
#define RNDIS_OID_FDDI_SMT_STATION_ACTION               0x03030277
#define RNDIS_OID_FDDI_PORT_ACTION                      0x03030278
#define RNDIS_OID_FDDI_IF_DESCR                         0x03030279
#define RNDIS_OID_FDDI_IF_TYPE                          0x0303027A
#define RNDIS_OID_FDDI_IF_MTU                           0x0303027B
#define RNDIS_OID_FDDI_IF_SPEED                         0x0303027C
#define RNDIS_OID_FDDI_IF_PHYS_ADDRESS                  0x0303027D
#define RNDIS_OID_FDDI_IF_ADMIN_STATUS                  0x0303027E
#define RNDIS_OID_FDDI_IF_OPER_STATUS                   0x0303027F
#define RNDIS_OID_FDDI_IF_LAST_CHANGE                   0x03030280
#define RNDIS_OID_FDDI_IF_IN_OCTETS                     0x03030281
#define RNDIS_OID_FDDI_IF_IN_UCAST_PKTS                 0x03030282
#define RNDIS_OID_FDDI_IF_IN_NUCAST_PKTS                0x03030283
#define RNDIS_OID_FDDI_IF_IN_DISCARDS                   0x03030284
#define RNDIS_OID_FDDI_IF_IN_ERRORS                     0x03030285
#define RNDIS_OID_FDDI_IF_IN_UNKNOWN_PROTOS             0x03030286
#define RNDIS_OID_FDDI_IF_OUT_OCTETS                    0x03030287
#define RNDIS_OID_FDDI_IF_OUT_UCAST_PKTS                0x03030288
#define RNDIS_OID_FDDI_IF_OUT_NUCAST_PKTS               0x03030289
#define RNDIS_OID_FDDI_IF_OUT_DISCARDS                  0x0303028A
#define RNDIS_OID_FDDI_IF_OUT_ERRORS                    0x0303028B
#define RNDIS_OID_FDDI_IF_OUT_QLEN                      0x0303028C
#define RNDIS_OID_FDDI_IF_SPECIFIC                      0x0303028D


//
// WAN objects
//

#define RNDIS_OID_WAN_PERMANENT_ADDRESS                 0x04010101
#define RNDIS_OID_WAN_CURRENT_ADDRESS                   0x04010102
#define RNDIS_OID_WAN_QUALITY_OF_SERVICE                0x04010103
#define RNDIS_OID_WAN_PROTOCOL_TYPE                     0x04010104
#define RNDIS_OID_WAN_MEDIUM_SUBTYPE                    0x04010105
#define RNDIS_OID_WAN_HEADER_FORMAT                     0x04010106

#define RNDIS_OID_WAN_GET_INFO                          0x04010107
#define RNDIS_OID_WAN_SET_LINK_INFO                     0x04010108
#define RNDIS_OID_WAN_GET_LINK_INFO                     0x04010109

#define RNDIS_OID_WAN_LINE_COUNT                        0x0401010A

#define RNDIS_OID_WAN_GET_BRIDGE_INFO                   0x0401020A
#define RNDIS_OID_WAN_SET_BRIDGE_INFO                   0x0401020B
#define RNDIS_OID_WAN_GET_COMP_INFO                     0x0401020C
#define RNDIS_OID_WAN_SET_COMP_INFO                     0x0401020D
#define RNDIS_OID_WAN_GET_STATS_INFO                    0x0401020E


//
// LocalTalk objects
//

#define RNDIS_OID_LTALK_CURRENT_NODE_ID                 0x05010102

#define RNDIS_OID_LTALK_IN_BROADCASTS                   0x05020101
#define RNDIS_OID_LTALK_IN_LENGTH_ERRORS                0x05020102

#define RNDIS_OID_LTALK_OUT_NO_HANDLERS                 0x05020201
#define RNDIS_OID_LTALK_COLLISIONS                      0x05020202
#define RNDIS_OID_LTALK_DEFERS                          0x05020203
#define RNDIS_OID_LTALK_NO_DATA_ERRORS                  0x05020204
#define RNDIS_OID_LTALK_RANDOM_CTS_ERRORS               0x05020205
#define RNDIS_OID_LTALK_FCS_ERRORS                      0x05020206


//
// Arcnet objects
//

#define RNDIS_OID_ARCNET_PERMANENT_ADDRESS              0x06010101
#define RNDIS_OID_ARCNET_CURRENT_ADDRESS                0x06010102

#define RNDIS_OID_ARCNET_RECONFIGURATIONS               0x06020201


//
// TAPI objects
//
#define RNDIS_OID_TAPI_ACCEPT                           0x07030101
#define RNDIS_OID_TAPI_ANSWER                           0x07030102
#define RNDIS_OID_TAPI_CLOSE                            0x07030103
#define RNDIS_OID_TAPI_CLOSE_CALL                       0x07030104
#define RNDIS_OID_TAPI_CONDITIONAL_MEDIA_DETECTION      0x07030105
#define RNDIS_OID_TAPI_CONFIG_DIALOG                    0x07030106
#define RNDIS_OID_TAPI_DEV_SPECIFIC                     0x07030107
#define RNDIS_OID_TAPI_DIAL                             0x07030108
#define RNDIS_OID_TAPI_DROP                             0x07030109
#define RNDIS_OID_TAPI_GET_ADDRESS_CAPS                 0x0703010A
#define RNDIS_OID_TAPI_GET_ADDRESS_ID                   0x0703010B
#define RNDIS_OID_TAPI_GET_ADDRESS_STATUS               0x0703010C
#define RNDIS_OID_TAPI_GET_CALL_ADDRESS_ID              0x0703010D
#define RNDIS_OID_TAPI_GET_CALL_INFO                    0x0703010E
#define RNDIS_OID_TAPI_GET_CALL_STATUS                  0x0703010F
#define RNDIS_OID_TAPI_GET_DEV_CAPS                     0x07030110
#define RNDIS_OID_TAPI_GET_DEV_CONFIG                   0x07030111
#define RNDIS_OID_TAPI_GET_EXTENSION_ID                 0x07030112
#define RNDIS_OID_TAPI_GET_ID                           0x07030113
#define RNDIS_OID_TAPI_GET_LINE_DEV_STATUS              0x07030114
#define RNDIS_OID_TAPI_MAKE_CALL                        0x07030115
#define RNDIS_OID_TAPI_NEGOTIATE_EXT_VERSION            0x07030116
#define RNDIS_OID_TAPI_OPEN                             0x07030117
#define RNDIS_OID_TAPI_PROVIDER_INITIALIZE              0x07030118
#define RNDIS_OID_TAPI_PROVIDER_SHUTDOWN                0x07030119
#define RNDIS_OID_TAPI_SECURE_CALL                      0x0703011A
#define RNDIS_OID_TAPI_SELECT_EXT_VERSION               0x0703011B
#define RNDIS_OID_TAPI_SEND_USER_USER_INFO              0x0703011C
#define RNDIS_OID_TAPI_SET_APP_SPECIFIC                 0x0703011D
#define RNDIS_OID_TAPI_SET_CALL_PARAMS                  0x0703011E
#define RNDIS_OID_TAPI_SET_DEFAULT_MEDIA_DETECTION      0x0703011F
#define RNDIS_OID_TAPI_SET_DEV_CONFIG                   0x07030120
#define RNDIS_OID_TAPI_SET_MEDIA_MODE                   0x07030121
#define RNDIS_OID_TAPI_SET_STATUS_MESSAGES              0x07030122


//
// ATM Connection Oriented Ndis
//
#define RNDIS_OID_ATM_SUPPORTED_VC_RATES                0x08010101
#define RNDIS_OID_ATM_SUPPORTED_SERVICE_CATEGORY        0x08010102
#define RNDIS_OID_ATM_SUPPORTED_AAL_TYPES               0x08010103
#define RNDIS_OID_ATM_HW_CURRENT_ADDRESS                0x08010104
#define RNDIS_OID_ATM_MAX_ACTIVE_VCS                    0x08010105
#define RNDIS_OID_ATM_MAX_ACTIVE_VCI_BITS               0x08010106
#define RNDIS_OID_ATM_MAX_ACTIVE_VPI_BITS               0x08010107
#define RNDIS_OID_ATM_ALIGNMENT_REQUIRED                0x08010108
#define RNDIS_OID_ATM_MAX_AAL0_PACKET_SIZE              0x08010109
#define RNDIS_OID_ATM_MAX_AAL1_PACKET_SIZE              0x0801010A
#define RNDIS_OID_ATM_MAX_AAL34_PACKET_SIZE             0x0801010B
#define RNDIS_OID_ATM_MAX_AAL5_PACKET_SIZE              0x0801010C

#define RNDIS_OID_ATM_SIGNALING_VPIVCI                  0x08010201
#define RNDIS_OID_ATM_ASSIGNED_VPI                      0x08010202
#define RNDIS_OID_ATM_ACQUIRE_ACCESS_NET_RESOURCES      0x08010203
#define RNDIS_OID_ATM_RELEASE_ACCESS_NET_RESOURCES      0x08010204
#define RNDIS_OID_ATM_ILMI_VPIVCI                       0x08010205
#define RNDIS_OID_ATM_DIGITAL_BROADCAST_VPIVCI          0x08010206
#define RNDIS_OID_ATM_GET_NEAREST_FLOW                  0x08010207

//
// ATM specific statistics OIDs.
//
#define RNDIS_OID_ATM_RCV_CELLS_OK                      0x08020101
#define RNDIS_OID_ATM_XMIT_CELLS_OK                     0x08020102
#define RNDIS_OID_ATM_RCV_CELLS_DROPPED                 0x08020103

#define RNDIS_OID_ATM_RCV_INVALID_VPI_VCI               0x08020201
#define RNDIS_OID_ATM_CELLS_HEC_ERROR                   0x08020202
#define RNDIS_OID_ATM_RCV_REASSEMBLY_ERROR              0x08020203

//
// PCCA (Wireless) object
//

//
// All WirelessWAN devices must support the following OIDs
//

#define RNDIS_OID_WW_GEN_NETWORK_TYPES_SUPPORTED        0x09010101
#define RNDIS_OID_WW_GEN_NETWORK_TYPE_IN_USE            0x09010102
#define RNDIS_OID_WW_GEN_HEADER_FORMATS_SUPPORTED       0x09010103
#define RNDIS_OID_WW_GEN_HEADER_FORMAT_IN_USE           0x09010104
#define RNDIS_OID_WW_GEN_INDICATION_REQUEST             0x09010105
#define RNDIS_OID_WW_GEN_DEVICE_INFO                    0x09010106
#define RNDIS_OID_WW_GEN_OPERATION_MODE                 0x09010107
#define RNDIS_OID_WW_GEN_LOCK_STATUS                    0x09010108
#define RNDIS_OID_WW_GEN_DISABLE_TRANSMITTER            0x09010109
#define RNDIS_OID_WW_GEN_NETWORK_ID                     0x0901010A
#define RNDIS_OID_WW_GEN_PERMANENT_ADDRESS              0x0901010B
#define RNDIS_OID_WW_GEN_CURRENT_ADDRESS                0x0901010C
#define RNDIS_OID_WW_GEN_SUSPEND_DRIVER                 0x0901010D
#define RNDIS_OID_WW_GEN_BASESTATION_ID                 0x0901010E
#define RNDIS_OID_WW_GEN_CHANNEL_ID                     0x0901010F
#define RNDIS_OID_WW_GEN_ENCRYPTION_SUPPORTED           0x09010110
#define RNDIS_OID_WW_GEN_ENCRYPTION_IN_USE              0x09010111
#define RNDIS_OID_WW_GEN_ENCRYPTION_STATE               0x09010112
#define RNDIS_OID_WW_GEN_CHANNEL_QUALITY                0x09010113
#define RNDIS_OID_WW_GEN_REGISTRATION_STATUS            0x09010114
#define RNDIS_OID_WW_GEN_RADIO_LINK_SPEED               0x09010115
#define RNDIS_OID_WW_GEN_LATENCY                        0x09010116
#define RNDIS_OID_WW_GEN_BATTERY_LEVEL                  0x09010117
#define RNDIS_OID_WW_GEN_EXTERNAL_POWER                 0x09010118

//
// Network Dependent OIDs - Mobitex:
//

#define RNDIS_OID_WW_MBX_SUBADDR                        0x09050101
// OID 0x09050102 is reserved and may not be used
#define RNDIS_OID_WW_MBX_FLEXLIST                       0x09050103
#define RNDIS_OID_WW_MBX_GROUPLIST                      0x09050104
#define RNDIS_OID_WW_MBX_TRAFFIC_AREA                   0x09050105
#define RNDIS_OID_WW_MBX_LIVE_DIE                       0x09050106
#define RNDIS_OID_WW_MBX_TEMP_DEFAULTLIST               0x09050107

//
// Network Dependent OIDs - Pinpoint:
//

#define RNDIS_OID_WW_PIN_LOC_AUTHORIZE                  0x09090101
#define RNDIS_OID_WW_PIN_LAST_LOCATION                  0x09090102
#define RNDIS_OID_WW_PIN_LOC_FIX                        0x09090103

//
// Network Dependent - CDPD:
//

#define RNDIS_OID_WW_CDPD_SPNI                          0x090D0101
#define RNDIS_OID_WW_CDPD_WASI                          0x090D0102
#define RNDIS_OID_WW_CDPD_AREA_COLOR                    0x090D0103
#define RNDIS_OID_WW_CDPD_TX_POWER_LEVEL                0x090D0104
#define RNDIS_OID_WW_CDPD_EID                           0x090D0105
#define RNDIS_OID_WW_CDPD_HEADER_COMPRESSION            0x090D0106
#define RNDIS_OID_WW_CDPD_DATA_COMPRESSION              0x090D0107
#define RNDIS_OID_WW_CDPD_CHANNEL_SELECT                0x090D0108
#define RNDIS_OID_WW_CDPD_CHANNEL_STATE                 0x090D0109
#define RNDIS_OID_WW_CDPD_NEI                           0x090D010A
#define RNDIS_OID_WW_CDPD_NEI_STATE                     0x090D010B
#define RNDIS_OID_WW_CDPD_SERVICE_PROVIDER_IDENTIFIER   0x090D010C
#define RNDIS_OID_WW_CDPD_SLEEP_MODE                    0x090D010D
#define RNDIS_OID_WW_CDPD_CIRCUIT_SWITCHED              0x090D010E
#define RNDIS_OID_WW_CDPD_TEI                           0x090D010F
#define RNDIS_OID_WW_CDPD_RSSI                          0x090D0110

//
// Network Dependent - Ardis:
//

#define RNDIS_OID_WW_ARD_SNDCP                          0x09110101
#define RNDIS_OID_WW_ARD_TMLY_MSG                       0x09110102
#define RNDIS_OID_WW_ARD_DATAGRAM                       0x09110103

//
// Network Dependent - DataTac:
//

#define RNDIS_OID_WW_TAC_COMPRESSION                    0x09150101
#define RNDIS_OID_WW_TAC_SET_CONFIG                     0x09150102
#define RNDIS_OID_WW_TAC_GET_STATUS                     0x09150103
#define RNDIS_OID_WW_TAC_USER_HEADER                    0x09150104

//
// Network Dependent - Metricom:
//

#define RNDIS_OID_WW_MET_FUNCTION                       0x09190101

//
// IRDA objects
//
#define RNDIS_OID_IRDA_RECEIVING                        0x0A010100
#define RNDIS_OID_IRDA_TURNAROUND_TIME                  0x0A010101
#define RNDIS_OID_IRDA_SUPPORTED_SPEEDS                 0x0A010102
#define RNDIS_OID_IRDA_LINK_SPEED                       0x0A010103
#define RNDIS_OID_IRDA_MEDIA_BUSY                       0x0A010104

#define RNDIS_OID_IRDA_EXTRA_RCV_BOFS                   0x0A010200
#define RNDIS_OID_IRDA_RATE_SNIFF                       0x0A010201
#define RNDIS_OID_IRDA_UNICAST_LIST                     0x0A010202
#define RNDIS_OID_IRDA_MAX_UNICAST_LIST_SIZE            0x0A010203



//
// Remote NDIS message types
//
#define REMOTE_NDIS_PACKET_MSG                  0x00000001
#define REMOTE_NDIS_INITIALIZE_MSG              0x00000002
#define REMOTE_NDIS_HALT_MSG                    0x00000003
#define REMOTE_NDIS_QUERY_MSG                   0x00000004
#define REMOTE_NDIS_SET_MSG                     0x00000005
#define REMOTE_NDIS_RESET_MSG                   0x00000006
#define REMOTE_NDIS_INDICATE_STATUS_MSG         0x00000007
#define REMOTE_NDIS_KEEPALIVE_MSG               0x00000008

#define REMOTE_CONDIS_MP_CREATE_VC_MSG          0x00008001
#define REMOTE_CONDIS_MP_DELETE_VC_MSG          0x00008002
#define REMOTE_CONDIS_MP_ACTIVATE_VC_MSG        0x00008005
#define REMOTE_CONDIS_MP_DEACTIVATE_VC_MSG      0x00008006
#define REMOTE_CONDIS_INDICATE_STATUS_MSG       0x00008007


// Remote NDIS message completion types
#define REMOTE_NDIS_INITIALIZE_CMPLT            0x80000002
#define REMOTE_NDIS_QUERY_CMPLT                 0x80000004
#define REMOTE_NDIS_SET_CMPLT                   0x80000005
#define REMOTE_NDIS_RESET_CMPLT                 0x80000006
#define REMOTE_NDIS_KEEPALIVE_CMPLT             0x80000008

#define REMOTE_CONDIS_MP_CREATE_VC_CMPLT        0x80008001
#define REMOTE_CONDIS_MP_DELETE_VC_CMPLT        0x80008002
#define REMOTE_CONDIS_MP_ACTIVATE_VC_CMPLT      0x80008005
#define REMOTE_CONDIS_MP_DEACTIVATE_VC_CMPLT    0x80008006

//
// Reserved message type for private communication between lower-layer
// host driver and remote device, if necessary.
//
#define REMOTE_NDIS_BUS_MSG                     0xff000001



//
//  Defines for DeviceFlags in RNDIS_INITIALIZE_COMPLETE
//
#define RNDIS_DF_CONNECTIONLESS             0x00000001
#define RNDIS_DF_CONNECTION_ORIENTED        0x00000002
#define RNDIS_DF_RAW_DATA                   0x00000004

//
//  Remote NDIS medium types.
//
#define RNdisMedium802_3                    0x00000000
#define RNdisMedium802_5                    0x00000001
#define RNdisMediumFddi                     0x00000002
#define RNdisMediumWan                      0x00000003
#define RNdisMediumLocalTalk                0x00000004
#define RNdisMediumArcnetRaw                0x00000006
#define RNdisMediumArcnet878_2              0x00000007
#define RNdisMediumAtm                      0x00000008
#define RNdisMediumWirelessWan              0x00000009
#define RNdisMediumIrda                     0x0000000a
#define RNdisMediumCoWan                    0x0000000b
#define RNdisMediumMax                      0x0000000d     // Not a real medium, defined as an upper-bound

//
// Remote NDIS medium connection states.
//
#define RNdisMediaStateConnected            0x00000000
#define RNdisMediaStateDisconnected         0x00000001

//
//  Remote NDIS version numbers
//
#define RNDIS_MAJOR_VERSION                 0x00000001
#define RNDIS_MINOR_VERSION                 0x00000000

//
//  NdisInitialize message
//
typedef struct _RNDIS_INITIALIZE_REQUEST 
{
    RNDIS_REQUEST_ID                        RequestId;
    UINT32                                  MajorVersion;
    UINT32                                  MinorVersion;
    UINT32                                  MaxTransferSize;
} RNDIS_INITIALIZE_REQUEST, *PRNDIS_INITIALIZE_REQUEST;


//
//  Response to NdisInitialize
//
typedef struct _RNDIS_INITIALIZE_COMPLETE 
{
    RNDIS_REQUEST_ID                        RequestId;
    RNDIS_STATUS                            Status;
    UINT32                                  MajorVersion;
    UINT32                                  MinorVersion;
    UINT32                                  DeviceFlags;
    RNDIS_MEDIUM                            Medium;
    UINT32                                  MaxPacketsPerMessage;
    UINT32                                  MaxTransferSize;
    UINT32                                  PacketAlignmentFactor;
    UINT32                                  AFListOffset;
    UINT32                                  AFListSize;
} RNDIS_INITIALIZE_COMPLETE, *PRNDIS_INITIALIZE_COMPLETE;


//
//  Call manager devices only: Information about an address family
//  supported by the device is appended to the response to NdisInitialize.
//
typedef struct _RNDIS_CO_ADDRESS_FAMILY
{
    RNDIS_AF                                AddressFamily;
    UINT32                                  MajorVersion;
    UINT32                                  MinorVersion;
} RNDIS_CO_ADDRESS_FAMILY, *PRNDIS_CO_ADDRESS_FAMILY;


//
//  NdisHalt message
//
typedef struct _RNDIS_HALT_REQUEST 
{
    RNDIS_REQUEST_ID                        RequestId;
} RNDIS_HALT_REQUEST, *PRNDIS_HALT_REQUEST;


//
// NdisQueryRequest message
//
typedef struct _RNDIS_QUERY_REQUEST 
{
    RNDIS_REQUEST_ID                        RequestId;
    RNDIS_OID                               Oid;
    UINT32                                  InformationBufferLength;
    UINT32                                  InformationBufferOffset;
    RNDIS_HANDLE                            DeviceVcHandle;
} RNDIS_QUERY_REQUEST, *PRNDIS_QUERY_REQUEST;


//
//  Response to NdisQueryRequest
//
typedef struct _RNDIS_QUERY_COMPLETE
{
    RNDIS_REQUEST_ID                        RequestId;
    RNDIS_STATUS                            Status;
    UINT32                                  InformationBufferLength;
    UINT32                                  InformationBufferOffset;
} RNDIS_QUERY_COMPLETE, *PRNDIS_QUERY_COMPLETE;


//
//  NdisSetRequest message
//
typedef struct _RNDIS_SET_REQUEST 
{
    RNDIS_REQUEST_ID                        RequestId;
    RNDIS_OID                               Oid;
    UINT32                                  InformationBufferLength;
    UINT32                                  InformationBufferOffset;
    RNDIS_HANDLE                            DeviceVcHandle;
} RNDIS_SET_REQUEST, *PRNDIS_SET_REQUEST;


//
//  Response to NdisSetRequest
//
typedef struct _RNDIS_SET_COMPLETE
{
    RNDIS_REQUEST_ID                        RequestId;
    RNDIS_STATUS                            Status;
} RNDIS_SET_COMPLETE, *PRNDIS_SET_COMPLETE;


//
//  NdisReset message
//
typedef struct _RNDIS_RESET_REQUEST
{
    UINT32                                  Reserved;
} RNDIS_RESET_REQUEST, *PRNDIS_RESET_REQUEST;

//
//  Response to NdisReset
//
typedef struct _RNDIS_RESET_COMPLETE
{
    RNDIS_STATUS                            Status;
    UINT32                                  AddressingReset;
} RNDIS_RESET_COMPLETE, *PRNDIS_RESET_COMPLETE;


//
//  NdisMIndicateStatus message
//
typedef struct _RNDIS_INDICATE_STATUS
{
    RNDIS_STATUS                            Status;
    UINT32                                  StatusBufferLength;
    UINT32                                  StatusBufferOffset;
} RNDIS_INDICATE_STATUS, *PRNDIS_INDICATE_STATUS;


//
//  Diagnostic information passed as the status buffer in
//  RNDIS_INDICATE_STATUS messages signifying error conditions.
//
typedef struct _RNDIS_DIAGNOSTIC_INFO
{
    RNDIS_STATUS                            DiagStatus;
    UINT32                                  ErrorOffset;
} RNDIS_DIAGNOSTIC_INFO, *PRNDIS_DIAGNOSTIC_INFO;



//
//  NdisKeepAlive message
//
typedef struct _RNDIS_KEEPALIVE_REQUEST
{
    RNDIS_REQUEST_ID                        RequestId;
} RNDIS_KEEPALIVE_REQUEST, *PRNDIS_KEEPALIVE_REQUEST;


//
// Response to NdisKeepAlive
//  
typedef struct _RNDIS_KEEPALIVE_COMPLETE
{
    RNDIS_REQUEST_ID                        RequestId;
    RNDIS_STATUS                            Status;
} RNDIS_KEEPALIVE_COMPLETE, *PRNDIS_KEEPALIVE_COMPLETE;


//
//  Data message. All Offset fields contain byte offsets from the beginning
//  of the RNDIS_PACKET structure. All Length fields are in bytes.
//  VcHandle is set to 0 for connectionless data, otherwise it
//  contains the VC handle.
//
typedef struct _RNDIS_PACKET
{
    UINT32                                  DataOffset;
    UINT32                                  DataLength;
    UINT32                                  OOBDataOffset;
    UINT32                                  OOBDataLength;
    UINT32                                  NumOOBDataElements;
    UINT32                                  PerPacketInfoOffset;
    UINT32                                  PerPacketInfoLength;
    RNDIS_HANDLE                            VcHandle;
    UINT32                                  Reserved;
} RNDIS_PACKET, *PRNDIS_PACKET;

//
//  Optional Out of Band data associated with a Data message.
//
typedef struct _RNDIS_OOBD
{
    UINT32                                  Size;
    RNDIS_CLASS_ID                          Type;
    UINT32                                  ClassInformationOffset;
} RNDIS_OOBD, *PRNDIS_OOBD;

//
//  Packet extension field contents associated with a Data message.
//
typedef struct _RNDIS_PER_PACKET_INFO
{
    UINT32                                  Size;
    UINT32                                  Type;
    UINT32                                  PerPacketInformationOffset;
} RNDIS_PER_PACKET_INFO, *PRNDIS_PER_PACKET_INFO;


//
//  Format of Information buffer passed in a SetRequest for the OID
//  OID_GEN_RNDIS_CONFIG_PARAMETER.
//
typedef struct _RNDIS_CONFIG_PARAMETER_INFO
{
    UINT32                                  ParameterNameOffset;
    UINT32                                  ParameterNameLength;
    UINT32                                  ParameterType;
    UINT32                                  ParameterValueOffset;
    UINT32                                  ParameterValueLength;
} RNDIS_CONFIG_PARAMETER_INFO, *PRNDIS_CONFIG_PARAMETER_INFO;

//
//  Values for ParameterType in RNDIS_CONFIG_PARAMETER_INFO
//
#define RNDIS_CONFIG_PARAM_TYPE_INTEGER     0
#define RNDIS_CONFIG_PARAM_TYPE_STRING      2


//
//  CONDIS Miniport messages for connection oriented devices
//  that do not implement a call manager.
//

//
//  CoNdisMiniportCreateVc message
//
typedef struct _RCONDIS_MP_CREATE_VC 
{
    RNDIS_REQUEST_ID                        RequestId;
    RNDIS_HANDLE                            NdisVcHandle;
} RCONDIS_MP_CREATE_VC, *PRCONDIS_MP_CREATE_VC;

//
//  Response to CoNdisMiniportCreateVc
//
typedef struct _RCONDIS_MP_CREATE_VC_COMPLETE 
{
    RNDIS_REQUEST_ID                        RequestId;
    RNDIS_HANDLE                            DeviceVcHandle;
    RNDIS_STATUS                            Status;
} RCONDIS_MP_CREATE_VC_COMPLETE, *PRCONDIS_MP_CREATE_VC_COMPLETE;


//
//  CoNdisMiniportDeleteVc message
//
typedef struct _RCONDIS_MP_DELETE_VC 
{
    RNDIS_REQUEST_ID                        RequestId;
    RNDIS_HANDLE                            DeviceVcHandle;
} RCONDIS_MP_DELETE_VC, *PRCONDIS_MP_DELETE_VC;

//
//  Response to CoNdisMiniportDeleteVc
//
typedef struct _RCONDIS_MP_DELETE_VC_COMPLETE 
{
    RNDIS_REQUEST_ID                        RequestId;
    RNDIS_STATUS                            Status;
} RCONDIS_MP_DELETE_VC_COMPLETE, *PRCONDIS_MP_DELETE_VC_COMPLETE;


//
//  CoNdisMiniportQueryRequest message
//
typedef struct _RCONDIS_MP_QUERY_REQUEST 
{
    RNDIS_REQUEST_ID                        RequestId;
    RNDIS_REQUEST_TYPE                      RequestType;
    RNDIS_OID                               Oid;
    RNDIS_HANDLE                            DeviceVcHandle;
    UINT32                                  InformationBufferLength;
    UINT32                                  InformationBufferOffset;
} RCONDIS_MP_QUERY_REQUEST, *PRCONDIS_MP_QUERY_REQUEST;


//
//  CoNdisMiniportSetRequest message
//
typedef struct _RCONDIS_MP_SET_REQUEST 
{
    RNDIS_REQUEST_ID                        RequestId;
    RNDIS_REQUEST_TYPE                      RequestType;
    RNDIS_OID                               Oid;
    RNDIS_HANDLE                            DeviceVcHandle;
    UINT32                                  InformationBufferLength;
    UINT32                                  InformationBufferOffset;
} RCONDIS_MP_SET_REQUEST, *PRCONDIS_MP_SET_REQUEST;


//
//  CoNdisIndicateStatus message
//
typedef struct _RCONDIS_INDICATE_STATUS
{
    RNDIS_HANDLE                            NdisVcHandle;
    RNDIS_STATUS                            Status;
    UINT32                                  StatusBufferLength;
    UINT32                                  StatusBufferOffset;
} RCONDIS_INDICATE_STATUS, *PRCONDIS_INDICATE_STATUS;


//
//  CONDIS Call/VC parameters
//

typedef struct _RCONDIS_SPECIFIC_PARAMETERS
{
    UINT32                                  ParameterType;
    UINT32                                  ParameterLength;
    UINT32                                  ParameterOffset;
} RCONDIS_SPECIFIC_PARAMETERS, *PRCONDIS_SPECIFIC_PARAMETERS;

typedef struct _RCONDIS_MEDIA_PARAMETERS
{
    UINT32                                  Flags;
    UINT32                                  Reserved1;
    UINT32                                  Reserved2;
    RCONDIS_SPECIFIC_PARAMETERS             MediaSpecific;
} RCONDIS_MEDIA_PARAMETERS, *PRCONDIS_MEDIA_PARAMETERS;


typedef struct _RNDIS_FLOWSPEC
{
    UINT32                                  TokenRate;
    UINT32                                  TokenBucketSize;
    UINT32                                  PeakBandwidth;
    UINT32                                  Latency;
    UINT32                                  DelayVariation;
    UINT32                                  ServiceType;
    UINT32                                  MaxSduSize;
    UINT32                                  MinimumPolicedSize;
} RNDIS_FLOWSPEC, *PRNDIS_FLOWSPEC;

typedef struct _RCONDIS_CALL_MANAGER_PARAMETERS
{
    RNDIS_FLOWSPEC                          Transmit;
    RNDIS_FLOWSPEC                          Receive;
    RCONDIS_SPECIFIC_PARAMETERS             CallMgrSpecific;
} RCONDIS_CALL_MANAGER_PARAMETERS, *PRCONDIS_CALL_MANAGER_PARAMETERS;

//
//  CoNdisMiniportActivateVc message
//
typedef struct _RCONDIS_MP_ACTIVATE_VC_REQUEST
{
    RNDIS_REQUEST_ID                        RequestId;
    UINT32                                  Flags;
    RNDIS_HANDLE                            DeviceVcHandle;
    UINT32                                  MediaParamsOffset;
    UINT32                                  MediaParamsLength;
    UINT32                                  CallMgrParamsOffset;
    UINT32                                  CallMgrParamsLength;
} RCONDIS_MP_ACTIVATE_VC_REQUEST, *PRCONDIS_MP_ACTIVATE_VC_REQUEST;

//
//  Response to CoNdisMiniportActivateVc
//
typedef struct _RCONDIS_MP_ACTIVATE_VC_COMPLETE
{
    RNDIS_REQUEST_ID                        RequestId;
    RNDIS_STATUS                            Status;
} RCONDIS_MP_ACTIVATE_VC_COMPLETE, *PRCONDIS_MP_ACTIVATE_VC_COMPLETE;


//
//  CoNdisMiniportDeactivateVc message
//
typedef struct _RCONDIS_MP_DEACTIVATE_VC_REQUEST
{
    RNDIS_REQUEST_ID                        RequestId;
    UINT32                                  Flags;
    RNDIS_HANDLE                            DeviceVcHandle;
} RCONDIS_MP_DEACTIVATE_VC_REQUEST, *PRCONDIS_MP_DEACTIVATE_VC_REQUEST;

//
//  Response to CoNdisMiniportDeactivateVc
//
typedef struct _RCONDIS_MP_DEACTIVATE_VC_COMPLETE
{
    RNDIS_REQUEST_ID                        RequestId;
    RNDIS_STATUS                            Status;
} RCONDIS_MP_DEACTIVATE_VC_COMPLETE, *PRCONDIS_MP_DEACTIVATE_VC_COMPLETE;


//
// union with all of the RNDIS messages
//
typedef union _RNDIS_MESSAGE_CONTAINER
{
    RNDIS_PACKET                        Packet;
    RNDIS_INITIALIZE_REQUEST            InitializeRequest;
    RNDIS_HALT_REQUEST                  HaltRequest;
    RNDIS_QUERY_REQUEST                 QueryRequest;
    RNDIS_SET_REQUEST                   SetRequest;
    RNDIS_RESET_REQUEST                 ResetRequest;
    RNDIS_KEEPALIVE_REQUEST             KeepaliveRequest;
    RNDIS_INDICATE_STATUS               IndicateStatus;
    RNDIS_INITIALIZE_COMPLETE           InitializeComplete;
    RNDIS_QUERY_COMPLETE                QueryComplete;
    RNDIS_SET_COMPLETE                  SetComplete;
    RNDIS_RESET_COMPLETE                ResetComplete;
    RNDIS_KEEPALIVE_COMPLETE            KeepaliveComplete;
    RCONDIS_MP_CREATE_VC                CoMiniportCreateVc;
    RCONDIS_MP_DELETE_VC                CoMiniportDeleteVc;
    RCONDIS_INDICATE_STATUS             CoIndicateStatus;
    RCONDIS_MP_ACTIVATE_VC_REQUEST      CoMiniportActivateVc;
    RCONDIS_MP_DEACTIVATE_VC_REQUEST    CoMiniportDeactivateVc;
    RCONDIS_MP_CREATE_VC_COMPLETE       CoMiniportCreateVcComplete;
    RCONDIS_MP_DELETE_VC_COMPLETE       CoMiniportDeleteVcComplete;
    RCONDIS_MP_ACTIVATE_VC_COMPLETE     CoMiniportActivateVcComplete;
    RCONDIS_MP_DEACTIVATE_VC_COMPLETE   CoMiniportDeactivateVcComplete;


} RNDIS_MESSAGE_CONTAINER, *PRNDIS_MESSAGE_CONTAINER;

//
// Remote NDIS message format
//
typedef struct _RNDIS_MESSAGE 
{
    UINT32                                  NdisMessageType;

    //
    // Total length of this message, from the beginning
    // of the RNDIS_MESSAGE struct, in bytes.
    //
    UINT32                                  MessageLength;

    // Actual message
    RNDIS_MESSAGE_CONTAINER                 Message;

} RNDIS_MESSAGE, *PRNDIS_MESSAGE;



//
// Handy macros

// get the size of an RNDIS message. Pass in the message type, 
// RNDIS_SET_REQUEST, RNDIS_PACKET for example
#define RNDIS_MESSAGE_SIZE(Message)                             \
    (sizeof(Message) + (sizeof(RNDIS_MESSAGE) - sizeof(RNDIS_MESSAGE_CONTAINER)))

// get pointer to info buffer with message pointer
#define MESSAGE_TO_INFO_BUFFER(Message)                         \
    (((PUCHAR)(Message)) + Message->InformationBufferOffset)

// get pointer to status buffer with message pointer
#define MESSAGE_TO_STATUS_BUFFER(Message)                       \
    (((PUCHAR)(Message)) + Message->StatusBufferOffset)

// get pointer to OOBD buffer with message pointer
#define MESSAGE_TO_OOBD_BUFFER(Message)                         \
    (((PUCHAR)(Message)) + Message->OOBDataOffset)

// get pointer to data buffer with message pointer
#define MESSAGE_TO_DATA_BUFFER(Message)                         \
    (((PUCHAR)(Message)) + Message->PerPacketInfoOffset)

// get pointer to contained message from NDIS_MESSAGE pointer
#define RNDIS_MESSAGE_PTR_TO_MESSAGE_PTR(RndisMessage)          \
    ((PVOID) &RndisMessage->Message)

// get pointer to contained message from NDIS_MESSAGE pointer
#define RNDIS_MESSAGE_RAW_PTR_TO_MESSAGE_PTR(RndisMessage)      \
    ((PVOID) RndisMessage)

#endif // _RNDIS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rndis\rndismp\debug.c ===
/***************************************************************************

Copyright (c) 1999  Microsoft Corporation

Module Name:

    DEBUG.C

Abstract:

    Debug routines

Environment:

    kernel mode only

Notes:

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

    Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    6/6/99 : created

Author:

    Tom Green

    
****************************************************************************/

#include "precomp.h"

#if DBG

// this is for translating a code into an ASCII string
typedef struct Code2Ascii
{
	NDIS_OID				Oid;
	PCHAR					OidName;
} Code2Ascii;


static Code2Ascii OidList[] =
{
    OID_GEN_SUPPORTED_LIST,                 "OID_GEN_SUPPORTED_LIST",
    OID_GEN_HARDWARE_STATUS,                "OID_GEN_HARDWARE_STATUS",
    OID_GEN_MEDIA_SUPPORTED,                "OID_GEN_MEDIA_SUPPORTED",
    OID_GEN_MEDIA_IN_USE,                   "OID_GEN_MEDIA_IN_USE",
    OID_GEN_MAXIMUM_LOOKAHEAD,              "OID_GEN_MAXIMUM_LOOKAHEAD",
    OID_GEN_MAXIMUM_FRAME_SIZE,             "OID_GEN_MAXIMUM_FRAME_SIZE",
    OID_GEN_LINK_SPEED,                     "OID_GEN_LINK_SPEED",
    OID_GEN_TRANSMIT_BUFFER_SPACE,          "OID_GEN_TRANSMIT_BUFFER_SPACE",
    OID_GEN_RECEIVE_BUFFER_SPACE,           "OID_GEN_RECEIVE_BUFFER_SPACE",
    OID_GEN_TRANSMIT_BLOCK_SIZE,            "OID_GEN_TRANSMIT_BLOCK_SIZE",
    OID_GEN_RECEIVE_BLOCK_SIZE,             "OID_GEN_RECEIVE_BLOCK_SIZE",
    OID_GEN_VENDOR_ID,                      "OID_GEN_VENDOR_ID",
    OID_GEN_VENDOR_DESCRIPTION,             "OID_GEN_VENDOR_DESCRIPTION",
    OID_GEN_CURRENT_PACKET_FILTER,          "OID_GEN_CURRENT_PACKET_FILTER",
    OID_GEN_TRANSPORT_HEADER_OFFSET,        "OID_GEN_TRANSPORT_HEADER_OFFSET",
    OID_GEN_CURRENT_LOOKAHEAD,              "OID_GEN_CURRENT_LOOKAHEAD",
    OID_GEN_DRIVER_VERSION,                 "OID_GEN_DRIVER_VERSION",
    OID_GEN_VENDOR_DRIVER_VERSION,          "OID_GEN_VENDOR_DRIVER_VERSION",
    OID_GEN_MAXIMUM_TOTAL_SIZE,             "OID_GEN_MAXIMUM_TOTAL_SIZE",
    OID_GEN_PROTOCOL_OPTIONS,               "OID_GEN_PROTOCOL_OPTIONS",
    OID_GEN_MAC_OPTIONS,                    "OID_GEN_MAC_OPTIONS",
    OID_GEN_MEDIA_CONNECT_STATUS,           "OID_GEN_MEDIA_CONNECT_STATUS",
    OID_GEN_MAXIMUM_SEND_PACKETS,           "OID_GEN_MAXIMUM_SEND_PACKETS",
    OID_GEN_SUPPORTED_GUIDS,                "OID_GEN_SUPPORTED_GUIDS",
    OID_GEN_XMIT_OK,                        "OID_GEN_XMIT_OK",
    OID_GEN_RCV_OK,                         "OID_GEN_RCV_OK",
    OID_GEN_XMIT_ERROR,                     "OID_GEN_XMIT_ERROR",
    OID_GEN_RCV_ERROR,                      "OID_GEN_RCV_ERROR",
    OID_GEN_RCV_NO_BUFFER,                  "OID_GEN_RCV_NO_BUFFER",
    OID_GEN_RCV_CRC_ERROR,                  "OID_GEN_RCV_CRC_ERROR",
    OID_GEN_TRANSMIT_QUEUE_LENGTH,          "OID_GEN_TRANSMIT_QUEUE_LENGTH",
    OID_802_3_PERMANENT_ADDRESS,            "OID_802_3_PERMANENT_ADDRESS",
    OID_802_3_CURRENT_ADDRESS,              "OID_802_3_CURRENT_ADDRESS",
    OID_802_3_MULTICAST_LIST,               "OID_802_3_MULTICAST_LIST",
    OID_802_3_MAXIMUM_LIST_SIZE,            "OID_802_3_MAXIMUM_LIST_SIZE",
    OID_802_3_RCV_ERROR_ALIGNMENT,          "OID_802_3_RCV_ERROR_ALIGNMENT",
    OID_802_3_XMIT_ONE_COLLISION,           "OID_802_3_XMIT_ONE_COLLISION",
    OID_802_3_XMIT_MORE_COLLISIONS,         "OID_802_3_XMIT_MORE_COLLISIONS",
    OID_802_3_XMIT_DEFERRED,                "OID_802_3_XMIT_DEFERRED",
    OID_802_3_XMIT_MAX_COLLISIONS,          "OID_802_3_XMIT_MAX_COLLISIONS",
    OID_802_3_RCV_OVERRUN,                  "OID_802_3_RCV_OVERRUN",
    OID_802_3_XMIT_UNDERRUN,                "OID_802_3_XMIT_UNDERRUN",
    OID_802_3_XMIT_HEARTBEAT_FAILURE,       "OID_802_3_XMIT_HEARTBEAT_FAILURE",
    OID_802_3_XMIT_TIMES_CRS_LOST,          "OID_802_3_XMIT_TIMES_CRS_LOST",
    OID_802_3_XMIT_LATE_COLLISIONS,         "OID_802_3_XMIT_LATE_COLLISIONS",
    OID_802_3_MAC_OPTIONS,                  "OID_802_3_MAC_OPTIONS",
    OID_TCP_TASK_OFFLOAD,                   "OID_TCP_TASK_OFFLOAD",
    OID_PNP_CAPABILITIES,                   "OID_PNP_CAPABILITIES",
    OID_PNP_SET_POWER,                      "OID_PNP_SET_POWER",
    OID_PNP_QUERY_POWER,                    "OID_PNP_QUERY_POWER",
    OID_PNP_ADD_WAKE_UP_PATTERN,            "OID_PNP_ADD_WAKE_UP_PATTERN",
    OID_PNP_REMOVE_WAKE_UP_PATTERN,         "OID_PNP_REMOVE_WAKE_UP_PATTERN",
    OID_PNP_ENABLE_WAKE_UP,                 "OID_PNP_ENABLE_WAKE_UP"
};


static UINT NumOid = sizeof(OidList) / sizeof(Code2Ascii);


//
// Debug level
//
UINT            RndismpDebugFlags = DBG_LEVEL0 | DBG_LEVEL1; // | DBG_LEVEL2; // | DBG_DUMP; // | DBG_OID_LIST;


/****************************************************************************/
/*                          GetOidName                                      */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Returns string with OID name                                            */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Oid - OID to find                                                       */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  PCHAR                                                                   */
/*                                                                          */
/****************************************************************************/
PCHAR
GetOidName(IN NDIS_OID Oid)
{
    UINT Index;

    // see if the matching Oid and string are in the list
    for(Index = 0; Index < NumOid; Index++)
    {
        if(Oid == OidList[Index].Oid)
        {
            return OidList[Index].OidName;
        }
    }

    DbgPrint("GetOidName: unknown OID %x\n", Oid);
    return "Unknown OID";

} // GetOidName


/****************************************************************************/
/*                          DisplayOidList                                  */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Prints list of supported OIDs and whether they are supported in         */
/*  the device or driver                                                    */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Adapter - adapter object                                                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
DisplayOidList(IN PRNDISMP_ADAPTER Adapter)
{
    ASSERT(Adapter->SupportedOIDList);

    ASSERT(Adapter->OIDHandlerList);

    if(RndismpDebugFlags & DBG_OID_LIST)
    {
        UINT Index;

        for(Index = 0;Index < Adapter->NumOIDSupported;Index++)
        {
            if(Adapter->OIDHandlerList[Index] == DRIVER_SUPPORTED_OID)
            {
                DbgPrint("Support (%s)  OID (%s)\n", "Driver",
                         GetOidName(Adapter->SupportedOIDList[Index]));
            }
            else if(Adapter->OIDHandlerList[Index] ==
                    DEVICE_SUPPORTED_OID)
            {
                DbgPrint("Support (%s)  OID (%s)\n", "Device",
                         GetOidName(Adapter->SupportedOIDList[Index]));
            }
            else
            {
                DbgPrint("Support (%s)  OID (%s) (%08X)\n", "Unknown",
                         GetOidName(Adapter->SupportedOIDList[Index]),                         
                         Adapter->OIDHandlerList[Index]);
            }
        }
    }
} // DisplayOidList


#define BYTES_PER_LINE				16
#define CHARS_PER_BYTE				 3	// e.g. " 12"

ULONG   MaxHexDumpLength = 0xffff;

VOID
RndisPrintHexDump(PVOID            Pointer,
                  ULONG            Length)
{
    CHAR    DumpArray[BYTES_PER_LINE*CHARS_PER_BYTE+1];
    PCHAR   pBuf;
    PUCHAR  pInBuf;
    ULONG   i;

    pInBuf = (PUCHAR)Pointer;
    pBuf = DumpArray;

    Length = MIN(Length, MaxHexDumpLength);

    for (i = 0; i < Length; i++)
    {
        //
        //  Are we at the end of a line?
        //
        if ((i > 0) && ((i & 0xf) == 0))
        {
            *pBuf = '\0';
            DbgPrint("%s\n", DumpArray);
            pBuf = &DumpArray[0];
        }

        //
        //  Print the address if we are at the start of a new line.
        //
        if ((i & 0xf) == 0)
        {
            DbgPrint("%08x  ", pInBuf);
        }

        //
        //  Convert the current hex byte into a sequence of two chars.
        //
        *pBuf = ' ';
        pBuf++;

        *pBuf = ((*pInBuf) >> 4);
        *pBuf = ((*pBuf > 9)? (*pBuf - 10 + 'a') : (*pBuf + '0'));

        pBuf++;

        *pBuf = ((*pInBuf) & 0x0F);
        *pBuf = ((*pBuf > 9)? (*pBuf - 10 + 'a') : (*pBuf + '0'));

        pBuf++;

        pInBuf++;
    }

    if (Length > 0)
    {
        *pBuf = '\0';
        DbgPrint("%s\n", DumpArray);
    }
}


#define LOG_ENTRY_SIZE      128
#define LOG_BUFFER_SIZE     (2 * PAGE_SIZE)

VOID
RndisLogSendMessage(
    IN  PRNDISMP_ADAPTER        pAdapter,
    IN  PRNDISMP_MESSAGE_FRAME  pMsgFrame)
{
    NDIS_STATUS Status;
    BOOLEAN     bLockAcquired;
    PUCHAR      pMsgData;
    ULONG       CopyLength;
    PUCHAR      pDst;

    bLockAcquired = TRUE;
    RNDISMP_ACQUIRE_ADAPTER_LOCK(pAdapter);

    do
    {
        if (pAdapter->pSendLogBuffer == NULL)
        {
            pAdapter->LogBufferSize = LOG_BUFFER_SIZE;
            Status = MemAlloc(&pAdapter->pSendLogBuffer, LOG_BUFFER_SIZE);
            if (Status != NDIS_STATUS_SUCCESS)
            {
                TRACE1(("Failed to alloc log buffer (%d bytes)\n", LOG_BUFFER_SIZE));
                break;
            }

            pAdapter->pSendLogWrite = pAdapter->pSendLogBuffer;
        }


        pDst = pAdapter->pSendLogWrite;
        pAdapter->pSendLogWrite += LOG_ENTRY_SIZE;
        if (pAdapter->pSendLogWrite >= pAdapter->pSendLogBuffer + pAdapter->LogBufferSize)
        {
            pAdapter->pSendLogWrite = pDst = pAdapter->pSendLogBuffer;
        }

        RNDISMP_RELEASE_ADAPTER_LOCK(pAdapter);
        bLockAcquired = FALSE;

        CopyLength = MIN(LOG_ENTRY_SIZE, RNDISMP_GET_MDL_LENGTH(pMsgFrame->pMessageMdl));
        pMsgData = RNDISMP_GET_MDL_ADDRESS(pMsgFrame->pMessageMdl);

        RtlFillMemory(pDst, LOG_ENTRY_SIZE, 0);
        RNDISMP_MOVE_MEM(pDst, pMsgData, CopyLength);

    }
    while (FALSE);

    if (bLockAcquired)
    {
        RNDISMP_RELEASE_ADAPTER_LOCK(pAdapter);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rndis\rndismp\comini.c ===
/***************************************************************************

Copyright (c) 1999  Microsoft Corporation

Module Name:

    COMINI.C

Abstract:

    CO-NDIS Miniport driver entry points for the Remote NDIS miniport.

Environment:

    kernel mode only

Notes:

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

    Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    12/16/99:   Created

Author:

    ArvindM

    
****************************************************************************/

#include "precomp.h"



/****************************************************************************/
/*                          RndismpCoCreateVc                               */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Entry point to create a VC. We allocate a local VC structure, and send  */
/*  off a CreateVc message to the device.                                   */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  MiniportAdapterContext - pointer to our adapter structure               */
/*  NdisVcHandle - the NDIS wrapper's handle for this VC                    */
/*  pMiniportVcContext - place to return our context for this VC            */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  NDIS_STATUS                                                             */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
RndismpCoCreateVc(IN  NDIS_HANDLE    MiniportAdapterContext,
                  IN  NDIS_HANDLE    NdisVcHandle,
                  OUT PNDIS_HANDLE   pMiniportVcContext)
{
    PRNDISMP_ADAPTER        pAdapter;
    PRNDISMP_VC             pVc;
    PRNDISMP_MESSAGE_FRAME  pMsgFrame;
    NDIS_STATUS             Status;
    ULONG                   RefCount = 0;

    pVc = NULL;

    // get adapter context
    pAdapter = PRNDISMP_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

    do
    {
        if (pAdapter->Halting)
        {
            Status = NDIS_STATUS_NOT_ACCEPTED;
            break;
        }

        pVc = AllocateVc(pAdapter);
        if (pVc == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        RNDISMP_REF_VC(pVc);    // Creation ref

        //
        //  Prepare a CreateVc message to send to the device.
        //
        pMsgFrame = BuildRndisMessageCoMiniport(pAdapter,
                                                pVc,
                                                REMOTE_CONDIS_MP_CREATE_VC_MSG,
                                                NULL);
        if (pMsgFrame == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        pVc->VcState = RNDISMP_VC_CREATING;

        RNDISMP_REF_VC(pVc);    // Pending CreateVc response

        RNDISMP_SEND_TO_MICROPORT(pAdapter, pMsgFrame, TRUE, CompleteSendCoCreateVc);

    }
    while (FALSE);

    //
    //  Clean up if failure.
    //
    if (Status != NDIS_STATUS_SUCCESS)
    {
        if (pVc != NULL)
        {
            RNDISMP_DEREF_VC(pVc, &RefCount);  // Creation ref

            ASSERT(RefCount == 0); // the Vc should be dealloc'ed above.
        }
    }

    return (Status);
}

/****************************************************************************/
/*                          CompleteSendCoCreateVc                          */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Callback routine called when microport completes sending a CreateVc     */
/*  message to the device.                                                  */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pMsgFrame - Pointer to message frame                                    */
/*  SendStatus - status of the microport send.                              */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
CompleteSendCoCreateVc(IN PRNDISMP_MESSAGE_FRAME    pMsgFrame,
                       IN NDIS_STATUS               SendStatus)
{
    PRNDISMP_VC             pVc;
    PRNDISMP_ADAPTER        pAdapter;
    PRNDISMP_MESSAGE_FRAME  pTmpMsgFrame;
    ULONG                   RefCount = 0;

    if (SendStatus == NDIS_STATUS_SUCCESS)
    {
        //
        //  The message was sent successfully. Do nothing until
        //  we get a response from the device.
        //
    }
    else
    {
        pVc = pMsgFrame->pVc;
        pAdapter = pVc->pAdapter;

        TRACE1(("CompleteSendCoCreateVc: VC %x, Adapter %x, fail status %x\n",
                pVc, pAdapter, SendStatus));

        //
        //  Failed to send it to the device. Remove this message from
        //  the pending list and free it.
        //
        RNDISMP_LOOKUP_PENDING_MESSAGE(pTmpMsgFrame, pAdapter, pMsgFrame->RequestId);
        ASSERT(pMsgFrame == pTmpMsgFrame);
        DereferenceMsgFrame(pMsgFrame);

        HandleCoCreateVcFailure(pVc, SendStatus);
    }

} // CompleteSendCoCreateVc


/****************************************************************************/
/*                          HandleCoCreateVcFailure                         */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Utility routine to handle failure of a CreateVc, either due to a local  */
/*  microport send failure, or via explicit rejection by the device.        */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pVc - Pointer to VC on which this failure has occurred                  */
/*  Status - NDIS status associated with this failure                       */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
HandleCoCreateVcFailure(IN PRNDISMP_VC      pVc,
                        IN NDIS_STATUS      Status)
{
    NDIS_HANDLE         NdisVcHandle;
    BOOLEAN             bFailActivateVc = FALSE;
    PCO_CALL_PARAMETERS pCallParameters;
    ULONG               RefCount = 0;
   
    RNDISMP_ACQUIRE_VC_LOCK(pVc);

    NdisVcHandle = pVc->NdisVcHandle;

    switch (pVc->VcState)
    {
        case RNDISMP_VC_CREATING:
            pVc->VcState = RNDISMP_VC_CREATE_FAILURE;
            break;
        
        case RNDISMP_VC_CREATING_DELETE_PENDING:
            pVc->VcState = RNDISMP_VC_ALLOCATED;
            break;

        case RNDISMP_VC_CREATING_ACTIVATE_PENDING:
            bFailActivateVc = TRUE;
            pCallParameters = pVc->pCallParameters;
            pVc->VcState = RNDISMP_VC_CREATE_FAILURE;
            break;

        default:
            ASSERT(FALSE);
            break;
    }

    RNDISMP_DEREF_VC_LOCKED(pVc, &RefCount);    // Pending CreateVc response

    if (RefCount != 0)
    {
        RNDISMP_RELEASE_VC_LOCK(pVc);
    }

    if (bFailActivateVc)
    {
        NdisMCoActivateVcComplete(Status,
                                  NdisVcHandle,
                                  pCallParameters);
    }

} // HandleCoCreateVcFailure


/****************************************************************************/
/*                          RndismpCoDeleteVc                               */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Entry point to delete a VC. We send a DeleteVc message to the device.   */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  MiniportVcContext - pointer to our VC structure                         */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  NDIS_STATUS                                                             */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
RndismpCoDeleteVc(IN NDIS_HANDLE    MiniportVcContext)
{
    PRNDISMP_VC             pVc;
    NDIS_STATUS             Status;

    pVc = PRNDISMP_VC_FROM_CONTEXT_HANDLE(MiniportVcContext);

    Status = StartVcDeletion(pVc);
    return (Status);

} // RndismpCoDeleteVc


/****************************************************************************/
/*                          StartVcDeletion                                 */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Initiate a DeleteVc operation on the specified VC.                      */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pVc - Pointer to VC structure                                           */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  NDIS_STATUS                                                             */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
StartVcDeletion(IN PRNDISMP_VC      pVc)
{
    PRNDISMP_ADAPTER        pAdapter;
    PRNDISMP_MESSAGE_FRAME  pMsgFrame;
    NDIS_STATUS             Status;
    ULONG                   RefCount = 0;
    BOOLEAN                 bSendDeleteVc;

    pAdapter = pVc->pAdapter;

    bSendDeleteVc = FALSE;
    pMsgFrame = NULL;

    do
    {
        //
        //  Prepare a DeleteVc message to send to the device.
        //
        pMsgFrame = BuildRndisMessageCoMiniport(pAdapter,
                                                pVc,
                                                REMOTE_CONDIS_MP_DELETE_VC_MSG,
                                                NULL);

        Status = NDIS_STATUS_SUCCESS;

        TRACE2(("StartVcDeletion: VC %x, state %d, Msg %x\n", pVc, pVc->VcState, pMsgFrame));

        RNDISMP_ACQUIRE_VC_LOCK(pVc);

        switch (pVc->VcState)
        {
            case RNDISMP_VC_CREATED:
                if (pMsgFrame != NULL)
                {
                    pVc->VcState = RNDISMP_VC_DELETING;
                    bSendDeleteVc = TRUE;
                }
                else
                {
                    Status = NDIS_STATUS_RESOURCES;
                    bSendDeleteVc = FALSE;
                }
                break;

            case RNDISMP_VC_CREATING:
                bSendDeleteVc = FALSE;
                pVc->VcState = RNDISMP_VC_CREATING_DELETE_PENDING;
                break;
            
            case RNDISMP_VC_CREATE_FAILURE:
                bSendDeleteVc = FALSE;
                pVc->VcState = RNDISMP_VC_ALLOCATED;
                break;
            
            default:
                bSendDeleteVc = FALSE;
                Status = NDIS_STATUS_NOT_ACCEPTED;
                break;
        }

        RNDISMP_RELEASE_VC_LOCK(pVc);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        if (bSendDeleteVc)
        {
            ASSERT(pMsgFrame != NULL);
            RNDISMP_REF_VC(pVc);    // pending DeleteVc message

            RNDISMP_SEND_TO_MICROPORT(pAdapter, pMsgFrame, TRUE, CompleteSendCoDeleteVc);
        }

        RNDISMP_DEREF_VC(pVc, &RefCount); // successful DeleteVc

    }
    while (FALSE);

    if (!bSendDeleteVc)
    {
        if (pMsgFrame != NULL)
        {
            DereferenceMsgFrame(pMsgFrame);
        }
    }

    return (Status);

} // StartVcDeletion


/****************************************************************************/
/*                          CompleteSendCoDeleteVc                          */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Callback routine called when microport completes sending a DeleteVc     */
/*  message to the device.                                                  */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pMsgFrame - Pointer to message frame                                    */
/*  SendStatus - status of the microport send.                              */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
CompleteSendCoDeleteVc(IN PRNDISMP_MESSAGE_FRAME    pMsgFrame,
                       IN NDIS_STATUS               SendStatus)
{
    PRNDISMP_VC             pVc;
    PRNDISMP_ADAPTER        pAdapter;
    PRNDISMP_MESSAGE_FRAME  pTmpMsgFrame;

    if (SendStatus == NDIS_STATUS_SUCCESS)
    {
        //
        //  The message was sent successfully. Do nothing until
        //  we get a response from the device.
        //
    }
    else
    {
        pVc = pMsgFrame->pVc;
        pAdapter = pVc->pAdapter;

        TRACE1(("CompleteSendCoDeleteVc: VC %x, Adapter %x, fail status %x\n",
                pVc, pAdapter, SendStatus));

        //
        //  Failed to send it to the device. Remove this message from
        //  the pending list and free it.
        //
        RNDISMP_LOOKUP_PENDING_MESSAGE(pTmpMsgFrame, pAdapter, pMsgFrame->RequestId);
        ASSERT(pMsgFrame == pTmpMsgFrame);
        DereferenceMsgFrame(pMsgFrame);

        //
        //  Take care of the VC now.
        //
        HandleCoDeleteVcFailure(pVc, SendStatus);
    }

} // CompleteSendCoDeleteVc


/****************************************************************************/
/*                          HandleCoDeleteVcFailure                         */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Utility routine to handle failure of a DeleteVc, either due to a local  */
/*  microport send failure, or via explicit rejection by the device.        */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pVc - Pointer to VC on which this failure has occurred                  */
/*  Status - NDIS status associated with this failure                       */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
HandleCoDeleteVcFailure(IN PRNDISMP_VC      pVc,
                        IN NDIS_STATUS      Status)
{
    ULONG       RefCount = 0;

    RNDISMP_ACQUIRE_VC_LOCK(pVc);

    switch (pVc->VcState)
    {
        case RNDISMP_VC_DELETING:
            pVc->VcState = RNDISMP_VC_DELETE_FAIL;
            break;

        default:
            ASSERT(FALSE);
            break;
    }

    RNDISMP_DEREF_VC_LOCKED(pVc, &RefCount);    // Pending DeleteVc response

    if (RefCount != 0)
    {
        RNDISMP_RELEASE_VC_LOCK(pVc);
    }

} // HandleCoDeleteVcFailure


/****************************************************************************/
/*                          RndismpCoActivateVc                             */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Entry point to activate a VC. We send an ActivateVc message to the      */
/*  device.                                                                 */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  MiniportVcContext - pointer to our VC structure                         */
/*  pCallParameters - CONDIS parameters for the VC                          */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  NDIS_STATUS                                                             */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
RndismpCoActivateVc(IN NDIS_HANDLE          MiniportVcContext,
                    IN PCO_CALL_PARAMETERS  pCallParameters)
{
    PRNDISMP_VC             pVc;
    NDIS_STATUS             Status;

    pVc = PRNDISMP_VC_FROM_CONTEXT_HANDLE(MiniportVcContext);

    pVc->pCallParameters = pCallParameters;
    Status = StartVcActivation(pVc);

    return (Status);

} // RndismpCoActivateVc


/****************************************************************************/
/*                          StartVcActivation                               */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Start an Activate-VC operation on the specified VC.                     */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pVc - Pointer to VC structure                                           */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  NDIS_STATUS                                                             */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
StartVcActivation(IN PRNDISMP_VC            pVc)
{
    NDIS_STATUS             Status;
    PRNDISMP_MESSAGE_FRAME  pMsgFrame;
    PRNDISMP_ADAPTER        pAdapter;
    BOOLEAN                 bSendActivateVc;
    NDIS_HANDLE             NdisVcHandle;
    PCO_CALL_PARAMETERS     pCallParameters;

    Status = NDIS_STATUS_PENDING;
    bSendActivateVc = FALSE;

    NdisVcHandle = pVc->NdisVcHandle;
    pCallParameters = pVc->pCallParameters;
    pAdapter = pVc->pAdapter;

    do
    {
        //
        //  Prepare an ActivateVc message to send to the device.
        //
        pMsgFrame = BuildRndisMessageCoMiniport(pAdapter,
                                                pVc,
                                                REMOTE_CONDIS_MP_ACTIVATE_VC_MSG,
                                                pCallParameters);

        RNDISMP_ACQUIRE_VC_LOCK(pVc);

        switch (pVc->VcState)
        {
            case RNDISMP_VC_CREATING:

                pVc->VcState = RNDISMP_VC_CREATING_ACTIVATE_PENDING;
                break;

            case RNDISMP_VC_CREATED:

                if (pMsgFrame != NULL)
                {
                    pVc->VcState = RNDISMP_VC_ACTIVATING;
                    bSendActivateVc = TRUE;
                }
                else
                {
                    TRACE1(("StartVcAct: VC %x, failed to build msg!\n", pVc));
                    Status = NDIS_STATUS_RESOURCES;
                }
                break;

            default:

                TRACE1(("StartVcAct: VC %x in invalid state %d\n", pVc, pVc->VcState));
                Status = NDIS_STATUS_NOT_ACCEPTED;
                break;
        }

        RNDISMP_RELEASE_VC_LOCK(pVc);

        if (Status != NDIS_STATUS_PENDING)
        {
            break;
        }

        if (bSendActivateVc)
        {
            ASSERT(pMsgFrame != NULL);
            RNDISMP_REF_VC(pVc);    // pending ActivateVc message

            RNDISMP_SEND_TO_MICROPORT(pAdapter, pMsgFrame, TRUE, CompleteSendCoActivateVc);
        }
    }
    while (FALSE);

    if (!bSendActivateVc)
    {
        if (pMsgFrame != NULL)
        {
            DereferenceMsgFrame(pMsgFrame);
        }
    }

    if (Status != NDIS_STATUS_PENDING)
    {
        NdisMCoActivateVcComplete(
            Status,
            NdisVcHandle,
            pCallParameters);
        
        Status = NDIS_STATUS_PENDING;
    }

    return (Status);

} // StartVcActivation


/****************************************************************************/
/*                          CompleteSendCoActivateVc                        */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Callback routine to handle send-completion of an Activate VC message.   */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pMsgFrame - Pointer to message frame                                    */
/*  SendStatus - status of the microport send.                              */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
CompleteSendCoActivateVc(IN PRNDISMP_MESSAGE_FRAME      pMsgFrame,
                         IN NDIS_STATUS                 SendStatus)
{
    PRNDISMP_VC             pVc;
    PRNDISMP_ADAPTER        pAdapter;
    PRNDISMP_MESSAGE_FRAME  pTmpMsgFrame;
    PCO_CALL_PARAMETERS     pCallParameters;
    ULONG                   RefCount = 0;
    NDIS_HANDLE             NdisVcHandle;

    if (SendStatus == NDIS_STATUS_SUCCESS)
    {
        //
        //  The message was sent successfully. Do nothing until
        //  we get a response from the device.
        //
    }
    else
    {
        pVc = pMsgFrame->pVc;
        pAdapter = pVc->pAdapter;

        TRACE1(("CompleteSendCoActivateVc: VC %x, Adapter %x, fail status %x\n",
                pVc, pAdapter, SendStatus));

        ASSERT(SendStatus != NDIS_STATUS_PENDING);

        //
        //  Failed to send it to the device. Remove this message from
        //  the pending list and free it.
        //
        RNDISMP_LOOKUP_PENDING_MESSAGE(pTmpMsgFrame, pAdapter, pMsgFrame->RequestId);
        ASSERT(pMsgFrame == pTmpMsgFrame);
        DereferenceMsgFrame(pMsgFrame);

        //
        //  Take care of the VC now.
        //
        RNDISMP_ACQUIRE_VC_LOCK(pVc);

        NdisVcHandle = pVc->NdisVcHandle;
        pCallParameters = pVc->pCallParameters;

        pVc->VcState = RNDISMP_VC_CREATED;

        RNDISMP_DEREF_VC_LOCKED(pVc, &RefCount); // pending ActivateVc

        if (RefCount != 0)
        {
            RNDISMP_RELEASE_VC_LOCK(pVc);
        }

        NdisMCoActivateVcComplete(
            SendStatus,
            NdisVcHandle,
            pCallParameters);
        
    }

} // CompleteSendCoActivateVc


/****************************************************************************/
/*                        RndismpCoDeactivateVc                             */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Entry point to de-activate a VC. We send an DeactivateVc message to the */
/*  device.                                                                 */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  MiniportVcContext - pointer to our VC structure                         */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  NDIS_STATUS                                                             */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
RndismpCoDeactivateVc(IN NDIS_HANDLE          MiniportVcContext)
{
    PRNDISMP_VC             pVc;
    PRNDISMP_ADAPTER        pAdapter;
    PRNDISMP_MESSAGE_FRAME  pMsgFrame;
    NDIS_STATUS             Status;
    NDIS_HANDLE             NdisVcHandle;
    BOOLEAN                 bVcLockAcquired = FALSE;
    BOOLEAN                 bSendDeactivateVc = FALSE;

    pMsgFrame = NULL;
    pVc = PRNDISMP_VC_FROM_CONTEXT_HANDLE(MiniportVcContext);
    pAdapter = pVc->pAdapter;
    Status = NDIS_STATUS_PENDING;

    do
    {
        //
        //  Prepare a DeactivateVc message to send to the device.
        //
        pMsgFrame = BuildRndisMessageCoMiniport(pAdapter,
                                                pVc,
                                                REMOTE_CONDIS_MP_DEACTIVATE_VC_MSG,
                                                NULL);

        bVcLockAcquired = TRUE;
        RNDISMP_ACQUIRE_VC_LOCK(pVc);

        NdisVcHandle = pVc->NdisVcHandle;

        if (pVc->VcState != RNDISMP_VC_ACTIVATED)
        {
            Status = NDIS_STATUS_NOT_ACCEPTED;
            break;
        }

        switch (pVc->VcState)
        {
            case RNDISMP_VC_ACTIVATED:

                if (pMsgFrame != NULL)
                {
                    bSendDeactivateVc = TRUE;
                    pVc->VcState = RNDISMP_VC_DEACTIVATING;
                }
                else
                {
                    bSendDeactivateVc = FALSE;
                    Status = NDIS_STATUS_RESOURCES;
                }
                break;

            default:

                bSendDeactivateVc = FALSE;
                break;
         }

         if (bSendDeactivateVc)
         {
            RNDISMP_REF_VC(pVc);    // pending Deactivate VC

            RNDISMP_SEND_TO_MICROPORT(pAdapter, pMsgFrame, TRUE, CompleteSendCoDeactivateVc);
        }
    }
    while (FALSE);


    if (!bSendDeactivateVc)
    {
        if (pMsgFrame != NULL)
        {
            DereferenceMsgFrame(pMsgFrame);
        }
    }

    if (Status != NDIS_STATUS_PENDING)
    {
        ASSERT(Status != NDIS_STATUS_SUCCESS);
        NdisMCoDeactivateVcComplete(
            Status,
            NdisVcHandle);
        
        Status = NDIS_STATUS_PENDING;
    }

    return (Status);
}

/****************************************************************************/
/*                          CompleteSendCoDeactivateVc                      */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Callback routine to handle send-completion of a deactivate VC message.  */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pMsgFrame - Pointer to message frame                                    */
/*  SendStatus - status of the microport send.                              */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
CompleteSendCoDeactivateVc(IN PRNDISMP_MESSAGE_FRAME    pMsgFrame,
                           IN NDIS_STATUS               SendStatus)
{
    PRNDISMP_VC             pVc;
    PRNDISMP_ADAPTER        pAdapter;
    PRNDISMP_MESSAGE_FRAME  pTmpMsgFrame;
    PCO_CALL_PARAMETERS     pCallParameters;
    ULONG                   RefCount = 0;
    NDIS_HANDLE             NdisVcHandle;

    if (SendStatus == NDIS_STATUS_SUCCESS)
    {
        //
        //  The message was sent successfully. Do nothing until
        //  we get a response from the device.
        //
    }
    else
    {
        pVc = pMsgFrame->pVc;
        pAdapter = pVc->pAdapter;

        TRACE1(("CompleteSendCoDeactivateVc: VC %x, Adapter %x, fail status %x\n",
                pVc, pAdapter, SendStatus));

        ASSERT(SendStatus != NDIS_STATUS_PENDING);

        //
        //  Failed to send it to the device. Remove this message from
        //  the pending list and free it.
        //
        RNDISMP_LOOKUP_PENDING_MESSAGE(pTmpMsgFrame, pAdapter, pMsgFrame->RequestId);
        ASSERT(pMsgFrame == pTmpMsgFrame);
        DereferenceMsgFrame(pMsgFrame);

        //
        //  Take care of the VC now.
        //
        RNDISMP_ACQUIRE_VC_LOCK(pVc);

        NdisVcHandle = pVc->NdisVcHandle;
        pCallParameters = pVc->pCallParameters;

        pVc->VcState = RNDISMP_VC_ACTIVATED;

        RNDISMP_DEREF_VC_LOCKED(pVc, &RefCount); // pending DeactivateVc

        if (RefCount != 0)
        {
            RNDISMP_RELEASE_VC_LOCK(pVc);
        }

        NdisMCoDeactivateVcComplete(
            SendStatus,
            NdisVcHandle);
        
    }

} // CompleteSendCoDeactivateVc


/****************************************************************************/
/*                          RndismpCoRequest                                */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Entry point to handle a CO-request. We send a MiniportCoRequest message */
/*  to the device.                                                          */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  MiniportAdapterContext - pointer to our adapter structure               */
/*  MiniportVcContext - pointer to our VC structure                         */
/*  pRequest - Pointer to NDIS request                                      */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  NDIS_STATUS                                                             */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
RndismpCoRequest(IN NDIS_HANDLE          MiniportAdapterContext,
                 IN NDIS_HANDLE          MiniportVcContext,
                 IN OUT PNDIS_REQUEST    pRequest)
{
    PRNDISMP_ADAPTER    pAdapter;
    PRNDISMP_VC         pVc;
    NDIS_STATUS         Status;
    NDIS_OID            Oid;

    pAdapter = PRNDISMP_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);
    pVc = PRNDISMP_VC_FROM_CONTEXT_HANDLE(MiniportVcContext);

    switch (pRequest->RequestType)
    {
        case NdisRequestQueryInformation:
        case NdisRequestQueryStatistics:

            Oid = pRequest->DATA.QUERY_INFORMATION.Oid;

            TRACE2(("CoReq: Adapter %x, Req %x, QueryInfo/Stat (%d) Oid %x\n",
                pAdapter, pRequest, pRequest->RequestType, Oid));

            Status = ProcessQueryInformation(pAdapter,
                                             pVc,
                                             pRequest,
                                             Oid,
                                             pRequest->DATA.QUERY_INFORMATION.InformationBuffer,
                                             pRequest->DATA.QUERY_INFORMATION.InformationBufferLength,
                                             &pRequest->DATA.QUERY_INFORMATION.BytesWritten,
                                             &pRequest->DATA.QUERY_INFORMATION.BytesNeeded);
            break;
        
        case NdisRequestSetInformation:

            Oid = pRequest->DATA.SET_INFORMATION.Oid;

            TRACE1(("CoReq: Adapter %x, Req %x, SetInfo Oid %x\n",
                 pAdapter, pRequest, Oid));

            Status = ProcessSetInformation(pAdapter,
                                           pVc,
                                           pRequest,
                                           Oid,
                                           pRequest->DATA.SET_INFORMATION.InformationBuffer,
                                           pRequest->DATA.SET_INFORMATION.InformationBufferLength,
                                           &pRequest->DATA.SET_INFORMATION.BytesRead,
                                           &pRequest->DATA.SET_INFORMATION.BytesNeeded);
            break;
        
        default:
            TRACE1(("CoReq: Unsupported request type %d\n",
                        pRequest->RequestType));
                
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;
    }

    return (Status);
}

/****************************************************************************/
/*                          RndismpCoSendPackets                            */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Entry point to send one or more packets on a VC.                        */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  MiniportVcContext - pointer to our VC structure                         */
/*  PacketArray - Array of packet pointers                                  */
/*  NumberOfPackets - number of packets in array above                      */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
RndismpCoSendPackets(IN NDIS_HANDLE          MiniportVcContext,
                     IN PNDIS_PACKET *       PacketArray,
                     IN UINT                 NumberOfPackets)
{
    PRNDISMP_VC         pVc;
    UINT                i;

    pVc = PRNDISMP_VC_FROM_CONTEXT_HANDLE(MiniportVcContext);

    RNDISMP_ACQUIRE_VC_LOCK(pVc);

    pVc->RefCount += NumberOfPackets;

    if (pVc->VcState == RNDISMP_VC_ACTIVATED)
    {
        RNDISMP_RELEASE_VC_LOCK(pVc);

        DoMultipleSend(pVc->pAdapter,
                       pVc,
                       PacketArray,
                       NumberOfPackets);
    }
    else
    {
        RNDISMP_RELEASE_VC_LOCK(pVc);

        for (i = 0; i < NumberOfPackets; i++)
        {
            CompleteSendDataOnVc(pVc, PacketArray[i], NDIS_STATUS_VC_NOT_ACTIVATED);
        }
    }

} // RndismpCoSendPackets

/****************************************************************************/
/*                          ReceiveCreateVcComplete                         */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Process a CONDIS CreateVcComplete message from the device               */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - pointer to our Adapter structure                             */
/*  pMessage - pointer to RNDIS message                                     */
/*  pMdl - pointer to MDL received from microport                           */
/*  TotalLength - length of complete message                                */
/*  MicroportMessageContext - context for message from micorport            */
/*  ReceiveStatus - used by microport to indicate it is low on resource     */
/*  bMessageCopied - is this a copy of the original message?                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  BOOLEAN - should the message be returned to the microport?              */
/*                                                                          */
/****************************************************************************/
BOOLEAN
ReceiveCreateVcComplete(IN PRNDISMP_ADAPTER    pAdapter,
                        IN PRNDIS_MESSAGE      pMessage,
                        IN PMDL                pMdl,
                        IN ULONG               TotalLength,
                        IN NDIS_HANDLE         MicroportMessageContext,
                        IN NDIS_STATUS         ReceiveStatus,
                        IN BOOLEAN             bMessageCopied)
{
    BOOLEAN                         bDiscardPkt = TRUE;
    PRNDISMP_VC                     pVc;
    PRNDISMP_MESSAGE_FRAME          pCreateVcMsgFrame;
    PRCONDIS_MP_CREATE_VC_COMPLETE  pCreateVcComp;
    RNDISMP_VC_STATE                VcState;
    BOOLEAN                         bVcLockAcquired = FALSE;
    ULONG                           RefCount = 0;
    NDIS_STATUS                     Status;

    pVc = NULL;

    do
    {
        pCreateVcComp = RNDIS_MESSAGE_PTR_TO_MESSAGE_PTR(pMessage);

        //
        //  TBD - Validate lengths?
        //

        //
        //  Check the request Id.
        //
        RNDISMP_LOOKUP_PENDING_MESSAGE(pCreateVcMsgFrame, pAdapter, pCreateVcComp->RequestId);
        if (pCreateVcMsgFrame == NULL)
        {
            TRACE1(("CreateVcComp: Adapter %x, Invalid ReqId %d!\n",
                    pAdapter, pCreateVcComp->RequestId));
            break;
        }

        pVc = pCreateVcMsgFrame->pVc;
        Status = pCreateVcComp->Status;

        DereferenceMsgFrame(pCreateVcMsgFrame);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            HandleCoCreateVcFailure(pVc, Status);
            break;
        }

        bVcLockAcquired = TRUE;
        RNDISMP_ACQUIRE_VC_LOCK(pVc);

        RNDISMP_DEREF_VC_LOCKED(pVc, &RefCount); // pending CreateVc

        if (RefCount == 0)
        {
            bVcLockAcquired = FALSE;
            break;
        }

        pVc->DeviceVcContext = pCreateVcComp->DeviceVcHandle;

        VcState = pVc->VcState;

        switch (VcState)
        {
            case RNDISMP_VC_CREATING:

                pVc->VcState = RNDISMP_VC_CREATED;
                break;
            
            case RNDISMP_VC_CREATING_ACTIVATE_PENDING:

                pVc->VcState = RNDISMP_VC_CREATED;
                RNDISMP_RELEASE_VC_LOCK(pVc);
                bVcLockAcquired = FALSE;

                Status = StartVcActivation(pVc);
                ASSERT(Status == NDIS_STATUS_PENDING);
                break;

            case RNDISMP_VC_CREATING_DELETE_PENDING:

                pVc->VcState = RNDISMP_VC_CREATED;
                RNDISMP_RELEASE_VC_LOCK(pVc);
                bVcLockAcquired = FALSE;

                Status = StartVcDeletion(pVc);
                break;
                
            default:

                TRACE1(("CreateVcComp: VC %x, wrong state %d\n",
                        pVc, VcState));
                break;
        }

    }
    while (FALSE);

    if (bVcLockAcquired)
    {
        RNDISMP_RELEASE_VC_LOCK(pVc);
    }

    return (bDiscardPkt);
}

/****************************************************************************/
/*                        ReceiveActivateVcComplete                         */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Process a CONDIS ActivateVcComplete message from the device             */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - pointer to our Adapter structure                             */
/*  pMessage - pointer to RNDIS message                                     */
/*  pMdl - pointer to MDL received from microport                           */
/*  TotalLength - length of complete message                                */
/*  MicroportMessageContext - context for message from micorport            */
/*  ReceiveStatus - used by microport to indicate it is low on resource     */
/*  bMessageCopied - is this a copy of the original message?                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  BOOLEAN - should the message be returned to the microport?              */
/*                                                                          */
/****************************************************************************/
BOOLEAN
ReceiveActivateVcComplete(IN PRNDISMP_ADAPTER    pAdapter,
                          IN PRNDIS_MESSAGE      pMessage,
                          IN PMDL                pMdl,
                          IN ULONG               TotalLength,
                          IN NDIS_HANDLE         MicroportMessageContext,
                          IN NDIS_STATUS         ReceiveStatus,
                          IN BOOLEAN             bMessageCopied)
{
    BOOLEAN                         bDiscardPkt = TRUE;
    PRNDISMP_VC                     pVc;
    PRNDISMP_MESSAGE_FRAME          pActVcMsgFrame;
    PRCONDIS_MP_ACTIVATE_VC_COMPLETE        pActVcComp;
    BOOLEAN                         bVcLockAcquired = FALSE;
    ULONG                           RefCount = 0;
    NDIS_STATUS                     Status;
    NDIS_HANDLE                     NdisVcHandle;
    PCO_CALL_PARAMETERS             pCallParameters;

    pVc = NULL;

    do
    {
        pActVcComp = RNDIS_MESSAGE_PTR_TO_MESSAGE_PTR(pMessage);

        //
        //  TBD - Validate lengths?
        //

        //
        //  Check the request Id.
        //
        RNDISMP_LOOKUP_PENDING_MESSAGE(pActVcMsgFrame, pAdapter, pActVcComp->RequestId);
        if (pActVcMsgFrame == NULL)
        {
            TRACE1(("ActVcComp: Adapter %x, Invalid ReqId %d!\n",
                    pAdapter, pActVcComp->RequestId));
            break;
        }

        pVc = pActVcMsgFrame->pVc;

        DereferenceMsgFrame(pActVcMsgFrame);

        bVcLockAcquired = TRUE;
        RNDISMP_ACQUIRE_VC_LOCK(pVc);

        RNDISMP_DEREF_VC_LOCKED(pVc, &RefCount); // pending ActivateVc

        if (RefCount == 0)
        {
            bVcLockAcquired = FALSE;
            break;
        }

        if (pVc->VcState != RNDISMP_VC_ACTIVATING)
        {
            TRACE1(("ActVcComp: Adapter %x, VC %x: invalid state %d\n",
                    pAdapter, pVc, pVc->VcState));
            break;
        }

        Status = pActVcComp->Status;

        if (Status == NDIS_STATUS_SUCCESS)
        {
            pVc->VcState = RNDISMP_VC_ACTIVATED;
        }
        else
        {
            pVc->VcState = RNDISMP_VC_CREATED;
        }
            
        NdisVcHandle = pVc->NdisVcHandle;
        pCallParameters = pVc->pCallParameters;
        
        RNDISMP_RELEASE_VC_LOCK(pVc);
        bVcLockAcquired = FALSE;

        NdisMCoActivateVcComplete(
            pActVcComp->Status,
            NdisVcHandle,
            pCallParameters);

    }
    while (FALSE);

    if (bVcLockAcquired)
    {
        RNDISMP_RELEASE_VC_LOCK(pVc);
    }

    return (bDiscardPkt);
}

/****************************************************************************/
/*                        ReceiveDeleteVcComplete                           */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Process a CONDIS DeleteVcComplete message from the device               */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - pointer to our Adapter structure                             */
/*  pMessage - pointer to RNDIS message                                     */
/*  pMdl - pointer to MDL received from microport                           */
/*  TotalLength - length of complete message                                */
/*  MicroportMessageContext - context for message from micorport            */
/*  ReceiveStatus - used by microport to indicate it is low on resource     */
/*  bMessageCopied - is this a copy of the original message?                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  BOOLEAN - should the message be returned to the microport?              */
/*                                                                          */
/****************************************************************************/
BOOLEAN
ReceiveDeleteVcComplete(IN PRNDISMP_ADAPTER    pAdapter,
                        IN PRNDIS_MESSAGE      pMessage,
                        IN PMDL                pMdl,
                        IN ULONG               TotalLength,
                        IN NDIS_HANDLE         MicroportMessageContext,
                        IN NDIS_STATUS         ReceiveStatus,
                        IN BOOLEAN             bMessageCopied)
{
    BOOLEAN                         bDiscardPkt = TRUE;
    PRNDISMP_VC                     pVc;
    PRCONDIS_MP_DELETE_VC_COMPLETE  pDeleteVcComp;
    PRNDISMP_MESSAGE_FRAME          pDeleteVcMsgFrame;
    RNDISMP_VC_STATE                VcState;
    BOOLEAN                         bVcLockAcquired = FALSE;
    ULONG                           RefCount = 0;
    NDIS_STATUS                     Status;

    pVc = NULL;

    do
    {
        pDeleteVcComp = RNDIS_MESSAGE_PTR_TO_MESSAGE_PTR(pMessage);

        //
        //  TBD - Validate lengths?
        //

        //
        //  Check the request Id.
        //
        RNDISMP_LOOKUP_PENDING_MESSAGE(pDeleteVcMsgFrame, pAdapter, pDeleteVcComp->RequestId);
        if (pDeleteVcMsgFrame == NULL)
        {
            TRACE1(("DeleteVcComp: Adapter %x, Invalid ReqId %d!\n",
                    pAdapter, pDeleteVcComp->RequestId));
            break;
        }

        pVc = pDeleteVcMsgFrame->pVc;
        Status = pDeleteVcComp->Status;

        DereferenceMsgFrame(pDeleteVcMsgFrame);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            HandleCoDeleteVcFailure(pVc, Status);
            break;
        }

        bVcLockAcquired = TRUE;
        RNDISMP_ACQUIRE_VC_LOCK(pVc);

        RNDISMP_DEREF_VC_LOCKED(pVc, &RefCount); // pending DeleteVc

        if (RefCount == 0)
        {
            bVcLockAcquired = FALSE;
            break;
        }

        if (pVc->VcState != RNDISMP_VC_DELETING)
        {
            TRACE1(("DeleteVcComp: Adapter %x, VC %x: invalid state %d\n",
                    pAdapter, pVc, pVc->VcState));
            break;
        }

        pVc->VcState = RNDISMP_VC_ALLOCATED;

        RNDISMP_DEREF_VC(pVc, &RefCount);   // remove create ref

        if (RefCount == 0)
        {
            bVcLockAcquired = FALSE;
        }
    }
    while (FALSE);

    if (bVcLockAcquired)
    {
        RNDISMP_RELEASE_VC_LOCK(pVc);
    }

    return (bDiscardPkt);
}

/****************************************************************************/
/*                        ReceiveDeactivateVcComplete                       */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Process a CONDIS DeActivateVcComplete message from the device           */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - pointer to our Adapter structure                             */
/*  pMessage - pointer to RNDIS message                                     */
/*  pMdl - pointer to MDL received from microport                           */
/*  TotalLength - length of complete message                                */
/*  MicroportMessageContext - context for message from micorport            */
/*  ReceiveStatus - used by microport to indicate it is low on resource     */
/*  bMessageCopied - is this a copy of the original message?                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  BOOLEAN - should the message be returned to the microport?              */
/*                                                                          */
/****************************************************************************/
BOOLEAN
ReceiveDeactivateVcComplete(IN PRNDISMP_ADAPTER    pAdapter,
                            IN PRNDIS_MESSAGE      pMessage,
                            IN PMDL                pMdl,
                            IN ULONG               TotalLength,
                            IN NDIS_HANDLE         MicroportMessageContext,
                            IN NDIS_STATUS         ReceiveStatus,
                            IN BOOLEAN             bMessageCopied)
{
    BOOLEAN                         bDiscardPkt = TRUE;
    PRNDISMP_VC                     pVc;
    RNDISMP_VC_STATE                VcState;
    PRNDISMP_MESSAGE_FRAME          pDeactivateVcMsgFrame;
    PRCONDIS_MP_DEACTIVATE_VC_COMPLETE  pDeactivateVcComp;
    BOOLEAN                         bVcLockAcquired = FALSE;
    BOOLEAN                         bAddTempRef = FALSE;
    ULONG                           RefCount = 0;
    NDIS_STATUS                     Status;

    pVc = NULL;

    do
    {
        pDeactivateVcComp = RNDIS_MESSAGE_PTR_TO_MESSAGE_PTR(pMessage);

        //
        //  TBD - Validate lengths?
        //

        //
        //  Check the request Id.
        //
        RNDISMP_LOOKUP_PENDING_MESSAGE(pDeactivateVcMsgFrame, pAdapter, pDeactivateVcComp->RequestId);
        if (pDeactivateVcMsgFrame == NULL)
        {
            TRACE1(("DeactivateVcComp: Adapter %x, Invalid ReqId %d!\n",
                    pAdapter, pDeactivateVcComp->RequestId));
            break;
        }

        pVc = pDeactivateVcMsgFrame->pVc;

        DereferenceMsgFrame(pDeactivateVcMsgFrame);

        bVcLockAcquired = TRUE;
        RNDISMP_ACQUIRE_VC_LOCK(pVc);

        RNDISMP_DEREF_VC_LOCKED(pVc, &RefCount); // pending DeactivateVc

        if (RefCount == 0)
        {
            bVcLockAcquired = FALSE;
            break;
        }

        if (pVc->VcState != RNDISMP_VC_DEACTIVATING)
        {
            TRACE1(("DeactVcComp: Adapter %x, VC %x: invalid state %d\n",
                    pAdapter, pVc, pVc->VcState));
            ASSERT(FALSE);
            break;
        }

        if (pDeactivateVcComp->Status == NDIS_STATUS_SUCCESS)
        {
            pVc->VcState = RNDISMP_VC_DEACTIVATED;

            //
            //  We add a temp ref on the VC to help complete deactivate-VC
            //  from a common place (see bAddTempRef below).
            //
            RNDISMP_REF_VC(pVc);    // temp ref, deactivate vc complete OK
            bAddTempRef = TRUE;
        }
        else
        {
            pVc->VcState = RNDISMP_VC_ACTIVATED;
        }

        RNDISMP_RELEASE_VC_LOCK(pVc);
        bVcLockAcquired = FALSE;

        if (bAddTempRef)
        {
            //
            //  The following deref will check and call NDIS'
            //  deactivate vc complete API if we don't have any
            //  outstanding sends or receives on this VC.
            //
            RNDISMP_DEREF_VC(pVc, &RefCount); // temp ref
        }
    }
    while (FALSE);

    if (bVcLockAcquired)
    {
        RNDISMP_RELEASE_VC_LOCK(pVc);
    }

    return (bDiscardPkt);
}

/****************************************************************************/
/*                          BuildRndisMessageCoMiniport                     */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Allocate resources for message and frame and build an RNDIS message     */
/*  for sending to a remote CONDIS Miniport device.                         */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Pointer to adapter structure                                 */
/*  pVc - Pointer to VC structure                                           */
/*  NdisMessageType - RNDIS message type                                    */
/*  pCallParameters - optional pointer to call parameters, applicable to    */
/*       certain message types.                                             */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  PRNDISMP_MESSAGE_FRAME                                                  */
/*                                                                          */
/****************************************************************************/
PRNDISMP_MESSAGE_FRAME
BuildRndisMessageCoMiniport(IN  PRNDISMP_ADAPTER    pAdapter,
                            IN  PRNDISMP_VC         pVc,
                            IN  UINT                NdisMessageType,
                            IN  PCO_CALL_PARAMETERS pCallParameters OPTIONAL)
{
    PRNDIS_MESSAGE          pMessage;
    UINT                    MessageSize;
    PRNDISMP_MESSAGE_FRAME  pMsgFrame;

    switch (NdisMessageType)
    {
        case REMOTE_CONDIS_MP_CREATE_VC_MSG:
        {
            PRCONDIS_MP_CREATE_VC       pCreateVc;

            MessageSize = RNDIS_MESSAGE_SIZE(RCONDIS_MP_CREATE_VC);

            pMsgFrame = AllocateMessageAndFrame(pAdapter, MessageSize);

            if (pMsgFrame == NULL)
            {
                break;
            }

            pMessage = RNDISMP_GET_MSG_FROM_FRAME(pMsgFrame);
            pMessage->NdisMessageType = NdisMessageType;
            pMsgFrame->NdisMessageType = NdisMessageType;

            pCreateVc = &pMessage->Message.CoMiniportCreateVc;
            pCreateVc->RequestId = pMsgFrame->RequestId;
            pCreateVc->NdisVcHandle = pVc->VcId;

            break;
        }

        case REMOTE_CONDIS_MP_DELETE_VC_MSG:
        {
            PRCONDIS_MP_DELETE_VC       pDeleteVc;

            MessageSize = RNDIS_MESSAGE_SIZE(RCONDIS_MP_DELETE_VC);

            pMsgFrame = AllocateMessageAndFrame(pAdapter, MessageSize);

            if (pMsgFrame == NULL)
            {
                break;
            }

            pMessage = RNDISMP_GET_MSG_FROM_FRAME(pMsgFrame);
            pMessage->NdisMessageType = NdisMessageType;
            pMsgFrame->NdisMessageType = NdisMessageType;

            pDeleteVc = &pMessage->Message.CoMiniportDeleteVc;
            pDeleteVc->RequestId = pMsgFrame->RequestId;
            pDeleteVc->DeviceVcHandle = pVc->DeviceVcContext;

            break;
        }

        case REMOTE_CONDIS_MP_ACTIVATE_VC_MSG:
        {
            PRCONDIS_MP_ACTIVATE_VC_REQUEST             pActivateVc;
            PRCONDIS_CALL_MANAGER_PARAMETERS    pCallMgrParams;
            PRCONDIS_MEDIA_PARAMETERS           pMediaParams;
            ULONG_PTR                           FillLocation;
            UINT                                FillOffset;

            ASSERT(pCallParameters != NULL);
            MessageSize = RNDIS_MESSAGE_SIZE(RCONDIS_MP_ACTIVATE_VC_REQUEST);

            if (pCallParameters->CallMgrParameters)
            {
                MessageSize += (sizeof(RCONDIS_CALL_MANAGER_PARAMETERS) +
                                pCallParameters->CallMgrParameters->CallMgrSpecific.Length);
            }

            if (pCallParameters->MediaParameters)
            {
                MessageSize += (sizeof(RCONDIS_MEDIA_PARAMETERS) +
                                pCallParameters->MediaParameters->MediaSpecific.Length);
            }

            pMsgFrame = AllocateMessageAndFrame(pAdapter, MessageSize);

            if (pMsgFrame == NULL)
            {
                break;
            }

            pMessage = RNDISMP_GET_MSG_FROM_FRAME(pMsgFrame);
            pMessage->NdisMessageType = NdisMessageType;
            pMsgFrame->NdisMessageType = NdisMessageType;

            pActivateVc = &pMessage->Message.CoMiniportActivateVc;
            pActivateVc->RequestId = pMsgFrame->RequestId;
            pActivateVc->DeviceVcHandle = pVc->DeviceVcContext;
            pActivateVc->Flags = pCallParameters->Flags;

            FillOffset = RNDIS_MESSAGE_SIZE(RCONDIS_MP_ACTIVATE_VC_REQUEST);
            FillLocation = ((ULONG_PTR)pMessage + FillOffset);

            //
            //  Fill in Media parameters, if present.
            //
            if (pCallParameters->MediaParameters)
            {
                PCO_SPECIFIC_PARAMETERS     pMediaSpecific;

                pMediaSpecific = &pCallParameters->MediaParameters->MediaSpecific;
                pMediaParams = (PRCONDIS_MEDIA_PARAMETERS)FillLocation;
                pActivateVc->MediaParamsOffset = (UINT32)(FillLocation - (ULONG_PTR)pActivateVc);
                pActivateVc->MediaParamsLength = sizeof(RCONDIS_MEDIA_PARAMETERS) +
                                                    pMediaSpecific->Length;
                RNDISMP_MOVE_MEM(pMediaParams,
                                 pCallParameters->MediaParameters,
                                 FIELD_OFFSET(RCONDIS_MEDIA_PARAMETERS, MediaSpecific));

                FillLocation += sizeof(RCONDIS_MEDIA_PARAMETERS);
                FillOffset += sizeof(RCONDIS_MEDIA_PARAMETERS);

                pMediaParams->MediaSpecific.ParameterOffset =
                                 sizeof(RCONDIS_SPECIFIC_PARAMETERS);
                pMediaParams->MediaSpecific.ParameterType =
                                 pMediaSpecific->ParamType;
                pMediaParams->MediaSpecific.ParameterLength =
                                 pMediaSpecific->Length;

                RNDISMP_MOVE_MEM((PVOID)FillLocation,
                                 &pMediaSpecific->Parameters[0],
                                 pMediaSpecific->Length);

                FillLocation += pMediaSpecific->Length;
                FillOffset += pMediaSpecific->Length;
            }
            else
            {
                pActivateVc->MediaParamsOffset = 0;
                pActivateVc->MediaParamsLength = 0;
            }

            //
            //  Fill in Call manager parameters, if present.
            //
            if (pCallParameters->CallMgrParameters)
            {
                PCO_SPECIFIC_PARAMETERS     pCallMgrSpecific;

                pCallMgrSpecific = &pCallParameters->CallMgrParameters->CallMgrSpecific;

                pCallMgrParams = (PRCONDIS_CALL_MANAGER_PARAMETERS)FillLocation;
                pActivateVc->CallMgrParamsOffset = (UINT32)(FillLocation - (ULONG_PTR)pActivateVc);
                pActivateVc->CallMgrParamsLength = sizeof(RCONDIS_CALL_MANAGER_PARAMETERS) +
                                                    pCallMgrSpecific->Length;
                
                RNDISMP_MOVE_MEM(pCallMgrParams,
                                 pCallParameters->CallMgrParameters,
                                 FIELD_OFFSET(RCONDIS_CALL_MANAGER_PARAMETERS, CallMgrSpecific));

                FillLocation += sizeof(RCONDIS_CALL_MANAGER_PARAMETERS);
                FillOffset += sizeof(RCONDIS_CALL_MANAGER_PARAMETERS);
                
                pCallMgrParams->CallMgrSpecific.ParameterOffset =
                                 sizeof(RCONDIS_SPECIFIC_PARAMETERS);
                pCallMgrParams->CallMgrSpecific.ParameterType =
                                 pCallMgrSpecific->ParamType;
                pCallMgrParams->CallMgrSpecific.ParameterLength =
                                 pCallMgrSpecific->Length;
                

                RNDISMP_MOVE_MEM((PVOID)FillLocation,
                                 &pCallMgrSpecific->Parameters[0],
                                 pCallMgrSpecific->Length);

                FillLocation += pCallMgrSpecific->Length;
                FillOffset += pCallMgrSpecific->Length;
            }
            else
            {
                pActivateVc->CallMgrParamsOffset = 0;
                pActivateVc->CallMgrParamsLength = 0;
            }

            break;
        }

        case REMOTE_CONDIS_MP_DEACTIVATE_VC_MSG:
        {
            PRCONDIS_MP_DEACTIVATE_VC_REQUEST       pDeactivateVc;

            MessageSize = RNDIS_MESSAGE_SIZE(RCONDIS_MP_DEACTIVATE_VC_REQUEST);

            pMsgFrame = AllocateMessageAndFrame(pAdapter, MessageSize);

            if (pMsgFrame == NULL)
            {
                break;
            }

            pMessage = RNDISMP_GET_MSG_FROM_FRAME(pMsgFrame);
            pMessage->NdisMessageType = NdisMessageType;
            pMsgFrame->NdisMessageType = NdisMessageType;

            pDeactivateVc = &pMessage->Message.CoMiniportDeactivateVc;
            pDeactivateVc->RequestId = pMsgFrame->RequestId;
            pDeactivateVc->DeviceVcHandle = pVc->DeviceVcContext;

            break;
        }

        default:

            ASSERT(FALSE);
            pMsgFrame = NULL;
            break;
    }


    return (pMsgFrame);

} // BuildRndisMessageCoMiniport

/****************************************************************************/
/*                          CompleteSendDataOnVc                            */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Handle send-completion of CONDIS data                                   */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pVc - Pointer to Vc                                                     */
/*  pNdisPacket - Packet being completed                                    */
/*  Status - send completion status                                         */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
CompleteSendDataOnVc(IN PRNDISMP_VC         pVc,
                     IN PNDIS_PACKET        pNdisPacket,
                     IN NDIS_STATUS         Status)
{
    ULONG   RefCount;

    NdisMCoSendComplete(Status,
                        pVc->NdisVcHandle,
                        pNdisPacket);

    RNDISMP_DEREF_VC(pVc, &RefCount);
}

/****************************************************************************/
/*                   IndicateReceiveDataOnVc                                */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Handle reception of a bunch of CONDIS packets on a Vc.                  */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pVc - Pointer to VC on which data arrived.                              */
/*  PacketArray - Array of packets                                          */
/*  NumberOfPackets - size of above array                                   */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
IndicateReceiveDataOnVc(IN PRNDISMP_VC         pVc,
                        IN PNDIS_PACKET *      PacketArray,
                        IN UINT                NumberOfPackets)
{
    UINT            i;

    do
    {
        if (pVc->VcState != RNDISMP_VC_ACTIVATED)
        {
            TRACE1(("Rcv VC data: VC %x, invalid state %d\n", pVc, pVc->VcState));
            break;
        }

        for (i = 0; i < NumberOfPackets; i++)
        {
            RNDISMP_REF_VC(pVc);
        }

        NdisMCoIndicateReceivePacket(pVc->NdisVcHandle,
                                     PacketArray,
                                     NumberOfPackets);
    }
    while (FALSE);

} // IndicateReceiveDataOnVc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rndis\inc\rndisioc.h ===
/***************************************************************************

Copyright (c) 1999  Microsoft Corporation

Module Name:

    RNDISIOC.H

Abstract:

    Header file for controlling the RNDIS Miniport driver.

Environment:

    User/Kernel mode

Notes:

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

    Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    10/19/99:  created

Author:

    ArvindM


****************************************************************************/

#ifndef _RNDISIOC__H
#define _RNDISIOC__H


#define OID_RNDISMP_STATISTICS      0xFFA0C90A
#ifdef BINARY_MOF_TEST
#define OID_RNDISMP_DEVICE_OID      0xFFA0C90B
#define OID_RNDISMP_GET_MOF_OID     0xFFA0C90C
#endif // BINARY_MOF_TEST

typedef struct _RNDISMP_ADAPTER_STATS
{
    ULONG                       XmitToMicroport;
    ULONG                       XmitOk;
    ULONG                       XmitError;
    ULONG                       SendMsgLowRes;
    ULONG                       RecvOk;
    ULONG                       RecvError;
    ULONG                       RecvNoBuf; 
    ULONG                       RecvLowRes;
    ULONG                       Resets;
    ULONG                       KeepAliveTimeout;
    ULONG                       MicroportSendError;
} RNDISMP_ADAPTER_STATS, *PRNDISMP_ADAPTER_STATS;


typedef struct _RNDISMP_ADAPTER_INFO
{
    RNDISMP_ADAPTER_STATS       Statistics;
    ULONG                       HiWatPendedMessages;
    ULONG                       LoWatPendedMessages;
    ULONG                       CurPendedMessages;
} RNDISMP_ADAPTER_INFO, *PRNDISMP_ADAPTER_INFO;

#endif // _RNDISIOC__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rndis\rndismp\init.c ===
/***************************************************************************

Copyright (c) 1999  Microsoft Corporation

Module Name:

    INIT.C

Abstract:

    Remote NDIS Miniport driver initialization code

Environment:

    kernel mode only

Notes:

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

    Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    5/13/99 : created

Author:

    Tom Green

    
****************************************************************************/

#include "precomp.h"

extern ULONG    MsgFrameAllocs;

/****************************************************************************/
/*                          SetupSendQueues                                 */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Set up queues for sending packets to microport                          */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Adapter - adapter object                                                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   NDIS_STATUS                                                            */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
SetupSendQueues(IN PRNDISMP_ADAPTER Adapter)
{
    NdisInitializeNPagedLookasideList(
        &Adapter->MsgFramePool,
        NULL,
        NULL,
        0,
        sizeof(RNDISMP_MESSAGE_FRAME),
        RNDISMP_TAG_SEND_FRAME,
        0);

    Adapter->MsgFramePoolAlloced = TRUE;

    return NDIS_STATUS_SUCCESS;
} // SetupSendQueues


/****************************************************************************/
/*                          SetupReceiveQueues                              */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Allocate resources for receiving packets from the microport             */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Adapter - adapter object                                                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   NDIS_STATUS                                                            */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
SetupReceiveQueues(IN PRNDISMP_ADAPTER Adapter)
{
    NDIS_STATUS                 AllocationStatus;
    UINT                        Index;

    TRACE2(("SetupReceiveQueues\n"));


    do
    {
        Adapter->InitialReceiveFrames = INITIAL_RECEIVE_FRAMES;
        Adapter->MaxReceiveFrames = MAX_RECEIVE_FRAMES;

        // Set up a pool of receive data frame structures
        NdisInitializeNPagedLookasideList(
            &Adapter->RcvFramePool,
            NULL,
            NULL,
            0,
            sizeof(RNDISMP_RECV_DATA_FRAME),
            RNDISMP_TAG_RECV_DATA_FRAME,
            0);

        Adapter->RcvFramePoolAlloced = TRUE;

        // Set up a pool of packets for indicating groups of packets to NDIS
        NdisAllocatePacketPoolEx(&AllocationStatus,
                                 &Adapter->ReceivePacketPool,
                                 Adapter->InitialReceiveFrames,
                                 Adapter->MaxReceiveFrames,
                                 NUM_BYTES_PROTOCOL_RESERVED_SECTION);

        if (AllocationStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE2(("NdisAllocatePacketPool failed (%08X)\n", AllocationStatus));
            break;
        }

        // Set up our pool of buffer descriptors one per packet
        NdisAllocateBufferPool(&AllocationStatus,
                               &Adapter->ReceiveBufferPool,
                               Adapter->MaxReceiveFrames);

        if (AllocationStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE2(("NdisAllocateBufferPool failed (%08X)\n", AllocationStatus));
            break;
        }

    }
    while (FALSE);

    if (AllocationStatus != NDIS_STATUS_SUCCESS)
    {
        FreeReceiveResources(Adapter);
    }

    return AllocationStatus;

} // SetupReceiveQueues



/****************************************************************************/
/*                          AllocateTransportResources                      */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Allocate resources for transmit, receive, and requests                  */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Adapter - adapter object                                                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   NDIS_STATUS                                                            */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
AllocateTransportResources(IN PRNDISMP_ADAPTER Adapter)
{
    NDIS_STATUS Status;

    TRACE2(("AllocateTransportResources\n"));

    Status = SetupSendQueues(Adapter);

    if(Status != NDIS_STATUS_SUCCESS)
    {
        goto AllocateDone;
    }
    
    Status = SetupReceiveQueues(Adapter);

    if(Status != NDIS_STATUS_SUCCESS)
    {
        FreeSendResources(Adapter);
        goto AllocateDone;
    }
    
AllocateDone:
    return Status;
} // AllocateTransportResources

/****************************************************************************/
/*                          FreeTransportResources                          */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Free up resources for transmit, receive, and requests                   */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Adapter - adapter object                                                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   VOID                                                                   */
/*                                                                          */
/****************************************************************************/
VOID
FreeTransportResources(IN PRNDISMP_ADAPTER Adapter)
{
    TRACE2(("FreeTransportResources\n"));

    FreeSendResources(Adapter);
    FreeReceiveResources(Adapter);
} // FreeTransportResources

/****************************************************************************/
/*                          FreeSendResources                               */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Free up resources for sending packets                                   */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Adapter - adapter object                                                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   VOID                                                                   */
/*                                                                          */
/****************************************************************************/
VOID
FreeSendResources(IN PRNDISMP_ADAPTER Adapter)
{

    TRACE3(("FreeSendResources\n"));

    if (Adapter->MsgFramePoolAlloced)
    {
        ASSERT(MsgFrameAllocs == 0);
        NdisDeleteNPagedLookasideList(&Adapter->MsgFramePool);
        Adapter->MsgFramePoolAlloced = FALSE;
    }

} // FreeSendResources


/****************************************************************************/
/*                          FreeReceiveResources                            */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Free up resources allocated for receiving packets                       */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Adapter - adapter object                                                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   VOID                                                                   */
/*                                                                          */
/****************************************************************************/
VOID
FreeReceiveResources(IN PRNDISMP_ADAPTER Adapter)
{
    UINT                    Index;
    UINT                    Size;
    PUCHAR                  Buffer;

    TRACE3(("FreeReceiveResources\n"));

    // free up buffer pool
    if (Adapter->ReceiveBufferPool)
    {
        NdisFreeBufferPool(Adapter->ReceiveBufferPool);
        Adapter->ReceiveBufferPool = NULL;
    }
    
    // free up packet pool
    if (Adapter->ReceivePacketPool)
    {
        NdisFreePacketPool(Adapter->ReceivePacketPool);
        Adapter->ReceivePacketPool = NULL;
    }

    // delete receive data frame pool.
    if (Adapter->RcvFramePoolAlloced)
    {
        NdisDeleteNPagedLookasideList(&Adapter->RcvFramePool);
        Adapter->RcvFramePoolAlloced = FALSE;
    }

} // FreeReceiveResources
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rndis\inc\rndisapi.h ===
/***************************************************************************

Copyright (c) 1999  Microsoft Corporation

Module Name:

    RNDISAPI.H

Abstract:

    This module defines the Remote NDIS Wrapper API set.

Environment:

    kernel mode only

Notes:

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

    Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    2/8/99 : created

Authors:

    Arvind Murching and Tom Green

    
****************************************************************************/



#ifndef _RNDISAPI_H_
#define _RNDISAPI_H_


#define RNDIS_VERSION                       0x00010000


//
//  RNDIS Microport Channel type definitions.
//
typedef enum _RM_CHANNEL_TYPE
{
    RMC_DATA,   // for NDIS Packet messages
    RMC_CONTROL // all other messages (Init/Query/Set)

} RM_CHANNEL_TYPE, *PRM_CHANNEL_TYPE;


//
//  RNDIS Microport handler templates:
//
typedef
NDIS_STATUS
(*RM_DEVICE_INIT_HANDLER)(
    OUT   PNDIS_HANDLE                      pMicroportAdapterContext,
    OUT   PULONG                            pMaxReceiveSize,
    IN    NDIS_HANDLE                       MiniportAdapterContext,
    IN    NDIS_HANDLE                       NdisMiniportHandle,
    IN    NDIS_HANDLE                       WrapperConfigurationContext,
	IN    PDEVICE_OBJECT					Pdo
    );

typedef
NDIS_STATUS
(*RM_DEVICE_INIT_CMPLT_NOTIFY_HANDLER)(
    IN    NDIS_HANDLE                       MicroportAdapterContext,
    IN    ULONG                             DeviceFlags,
    IN OUT PULONG                           pMaxTransferSize
    );

typedef
VOID
(*RM_DEVICE_HALT_HANDLER)(
    IN    NDIS_HANDLE                       MicroportAdapterContext
    );

typedef
VOID
(*RM_SHUTDOWN_HANDLER)(
    IN    NDIS_HANDLE                       MicroportAdapterContext
    );

typedef
VOID
(*RM_UNLOAD_HANDLER)(
    IN    NDIS_HANDLE                       MicroportContext
    );

typedef
VOID
(*RM_SEND_MESSAGE_HANDLER)(
    IN    NDIS_HANDLE                       MicroportAdapterContext,
    IN    PMDL                              pMessageHead,
    IN    NDIS_HANDLE                       RndisMessageHandle,
    IN    RM_CHANNEL_TYPE                   ChannelType
    );

typedef
VOID
(*RM_RETURN_MESSAGE_HANDLER)(
    IN    NDIS_HANDLE                       MicroportAdapterContext,
    IN    PMDL                              pMessageHead,
    IN    NDIS_HANDLE                       MicroportMessageContext
    );


typedef struct _RNDIS_MICROPORT_CHARACTERISTICS
{
    ULONG                                   RndisVersion;           // RNDIS_VERSION
    ULONG                                   Reserved;               // Should be 0
    RM_DEVICE_INIT_HANDLER                  RmInitializeHandler;
    RM_DEVICE_INIT_CMPLT_NOTIFY_HANDLER     RmInitCompleteNotifyHandler;
    RM_DEVICE_HALT_HANDLER                  RmHaltHandler;
    RM_SHUTDOWN_HANDLER                     RmShutdownHandler;
    RM_UNLOAD_HANDLER                       RmUnloadHandler;
    RM_SEND_MESSAGE_HANDLER                 RmSendMessageHandler;
    RM_RETURN_MESSAGE_HANDLER               RmReturnMessageHandler;

} RNDIS_MICROPORT_CHARACTERISTICS, *PRNDIS_MICROPORT_CHARACTERISTICS;


//
//  RNDIS APIs
//
#ifndef RNDISMP
DECLSPEC_IMPORT
#endif
NDIS_STATUS
RndisMInitializeWrapper(
    OUT   PNDIS_HANDLE                      pNdisWrapperHandle,
    IN    PVOID                             MicroportContext,
    IN    PVOID                             DriverObject,
    IN    PVOID                             RegistryPath,
    IN    PRNDIS_MICROPORT_CHARACTERISTICS  pCharacteristics
    );

#ifndef RNDISMP
DECLSPEC_IMPORT
#endif
VOID
RndisMSendComplete(
    IN    NDIS_HANDLE                       MiniportAdapterContext,
    IN    NDIS_HANDLE                       RndisMessageHandle,
    IN    NDIS_STATUS                       SendStatus
    );

#ifndef RNDISMP
DECLSPEC_IMPORT
#endif
VOID
RndisMIndicateReceive(
    IN    NDIS_HANDLE                       MiniportAdapterContext,
    IN    PMDL                              pMessageHead,
    IN    NDIS_HANDLE                       MicroportMessageContext,
    IN    RM_CHANNEL_TYPE                   ChannelType,
    IN    NDIS_STATUS                       ReceiveStatus
    );


#endif // _RNDISAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rndis\rndismp\queue.h ===
/***************************************************************************

Copyright (c) 1999  Microsoft Corporation

Module Name:

    QUEUE.H

Abstract:

    Queueing routines used for lists of transmit, receive, and request "frames"

Environment:

    kernel mode only

Notes:

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

    Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    5/20/99 : created

Author:

    Tom Green

    
****************************************************************************/

#ifndef _QUEUE_H_
#define _QUEUE_H_


// QueueInitList - Macro which will initialize a queue to NULL
#define QueueInitList(_L) (_L)->Link.Flink = (_L)->Link.Blink = (PLIST_ENTRY)NULL;


// QueueEmpty - Macro which checks to see if a queue is empty
#define QueueEmpty(_L) (QueueGetHead((_L)) == (PRNDISMP_LIST_ENTRY) NULL)


// QueueGetHead - Macro which returns the head of the queue, but does not
//                remove the head from the queue
#define QueueGetHead(_L) ((PRNDISMP_LIST_ENTRY)((_L)->Link.Flink))


// QueuePushHead - Macro which puts an element at the head of the queue
#define QueuePushHead(_L, _E)                               \
{                                                           \
    ASSERT(_L);                                             \
    ASSERT(_E);                                             \
    if(!((_E)->Link.Flink = (_L)->Link.Flink))              \
    {                                                       \
        (_L)->Link.Blink = (PLIST_ENTRY)(_E);               \
    }                                                       \
    (_L)->Link.Flink = (PLIST_ENTRY)(_E);                   \
}


// QueueRemoveHead - Macro which removes the head of queue
#define QueueRemoveHead(_L)                                 \
{                                                           \
    PRNDISMP_LIST_ENTRY ListElem;                           \
    ASSERT((_L));                                           \
    if(ListElem = (PRNDISMP_LIST_ENTRY)(_L)->Link.Flink)    \
    {                                                       \
        if(!((_L)->Link.Flink = ListElem->Link.Flink))      \
            (_L)->Link.Blink = (PLIST_ENTRY) NULL;          \
    }                                                       \
}

// QueuePutTail - Macro which puts an element at the tail (end) of the queue
#define QueuePutTail(_L, _E)                                \
{                                                           \
    ASSERT(_L);                                             \
    ASSERT(_E);                                             \
    if((_L)->Link.Blink)                                    \
    {                                                       \
        ((PRNDISMP_LIST_ENTRY)                              \
            (_L)->Link.Blink)->Link.Flink =                 \
            (PLIST_ENTRY)(_E);                              \
        (_L)->Link.Blink = (PLIST_ENTRY)(_E);               \
    }                                                       \
    else                                                    \
    {                                                       \
        (_L)->Link.Flink =                                  \
        (_L)->Link.Blink = (PLIST_ENTRY)(_E);               \
    }                                                       \
    (_E)->Link.Flink = (PLIST_ENTRY) NULL;                  \
}

// QueueGetTail - Macro which returns the tail of the queue, but 
//                does not remove the tail from the queue
#define QueueGetTail(_L) ((PRNDISMP_LIST_ENTRY)((_L)->Link.Blink))

// QueuePopHead -- Macro which  will pop the head off of a queue (list), and
//                 return it (this differs only from queueremovehead only in the 1st line)
#define QueuePopHead(_L)                                    \
(PRNDISMP_LIST_ENTRY) (_L)->Link.Flink; QueueRemoveHead(_L);

#endif // _QUEUE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rndis\rndismp\precomp.h ===
#include "ndis.h"
#include "rndisioc.h"
#include "rndis.h"
#include "rndisapi.h"
#include "rndismp.h"
#include "rmdat.h"
#include "queue.h"
#include "wmiguid.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rndis\rndismp\receive.c ===
/***************************************************************************

Copyright (c) 1999  Microsoft Corporation

Module Name:

    RECEIVE.C

Abstract:

    Packet and message receive routines

Environment:

    kernel mode only

Notes:

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

    Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    5/20/99 : created

Author:

    Tom Green

    
****************************************************************************/

#include "precomp.h"


//
//  Some debug stuff, not critical to operation:
//
ULONG   RcvFrameAllocs = 0;
ULONG   RcvTimerCount = 0;
ULONG   RcvPacketCount = 0;
ULONG   RcvMaxPackets = 0;
ULONG   RcvIndicateCount = 0;
ULONG   RcvReturnCount = 0;

//
//  For raw encapsulation test
//

extern ULONG gRawEncap;

/****************************************************************************/
/*                          RndismpGetReturnedPackets                       */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  This function is called by NDIS to return to our possession a packet    */
/*  that we had indicated up.                                               */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  MiniportAdapterContext - a context version of our Adapter pointer       */
/*  pNdisPacket - the packet that is being freed                            */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
RndismpReturnPacket(IN NDIS_HANDLE    MiniportAdapterContext,
                    IN PNDIS_PACKET   pNdisPacket)
{
    PRNDISMP_ADAPTER            pAdapter;
    PRNDISMP_RECV_PKT_RESERVED  pRcvResvd;
    PRNDISMP_RECV_DATA_FRAME    pRcvFrame;
    PRNDISMP_VC                 pVc;
    PNDIS_BUFFER                pNdisBuffer;
    ULONG                       RefCount;

    // get adapter context
    pAdapter = PRNDISMP_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

    CHECK_VALID_ADAPTER(pAdapter);

    TRACE2(("RndismpReturnPacket: Adapter %x, Pkt %x\n", pAdapter, pNdisPacket));

    // get receive frame context
    pRcvResvd = PRNDISMP_RESERVED_FROM_RECV_PACKET(pNdisPacket);
    pRcvFrame = pRcvResvd->pRcvFrame;
    pVc = pRcvResvd->pVc;

    // Free the buffer.
    NdisQueryPacket(pNdisPacket,
                    NULL,
                    NULL,
                    &pNdisBuffer,
                    NULL);
    
    NdisFreeBuffer(pNdisBuffer);

    DereferenceRcvFrame(pRcvFrame, pAdapter);

    if (pVc != NULL)
    {
        RNDISMP_DEREF_VC(pVc, &RefCount);
    }

    NdisFreePacket(pNdisPacket);
    RcvReturnCount++;

} // RndismpReturnPacket


/****************************************************************************/
/*                          DereferenceRcvFrame                             */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Utility routine to deref a receive frame structure, e.g. when a         */
/*  received packet is returned to us from higher layers.                   */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pRcvFrame - Pointer to receive frame to be deref'ed.                    */
/*  pAdapter - Pointer to adapter structure                                 */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
DereferenceRcvFrame(IN PRNDISMP_RECV_DATA_FRAME pRcvFrame,
                    IN PRNDISMP_ADAPTER         pAdapter)
{
    ULONG   ReturnsPending;

    ReturnsPending = NdisInterlockedDecrement(&pRcvFrame->ReturnsPending);

    if (ReturnsPending == 0)
    {
        TRACE3(("DerefRcvFrame: Adapter %x, Frame %p, uPcontext %x, LocalCopy %d\n",
                    pAdapter, pRcvFrame, pRcvFrame->MicroportMessageContext, pRcvFrame->bMessageCopy));

        if (pRcvFrame->bMessageCopy)
        {
            FreeRcvMessageCopy(pRcvFrame->pLocalMessageCopy);
        }
        else
        {
            TRACE3(("DerefRcvFrame: uP MDL %x, uPContext %x\n",
                            pRcvFrame->pMicroportMdl,
                            pRcvFrame->MicroportMessageContext));

            RNDISMP_RETURN_TO_MICROPORT(pAdapter,
                                        pRcvFrame->pMicroportMdl,
                                        pRcvFrame->MicroportMessageContext);
        }

        FreeReceiveFrame(pRcvFrame, pAdapter);

    }

} // DereferenceRcvFrame


/****************************************************************************/
/*                          RndisMIndicateReceive                           */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Called by microport to indicate receiving RNDIS messages                */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  MiniportAdapterContext - a context version of our Adapter pointer       */
/*  pMdl - pointer to MDL chain describing RNDIS message                    */
/*  MicroportMessageContext - context for message from micorport            */
/*  ChannelType - channel on which this message arrived (control/data)      */
/*  ReceiveStatus - used by microport to indicate it is low on resource     */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   VOID                                                                   */
/*                                                                          */
/****************************************************************************/
VOID
RndisMIndicateReceive(IN NDIS_HANDLE        MiniportAdapterContext,
                      IN PMDL               pMdl,
                      IN NDIS_HANDLE        MicroportMessageContext,
                      IN RM_CHANNEL_TYPE    ChannelType,
                      IN NDIS_STATUS        ReceiveStatus)
{
    PRNDISMP_ADAPTER            Adapter;
    PRNDIS_MESSAGE              pMessage;
    BOOLEAN                     bMessageCopied = FALSE;
    PRNDISMP_MSG_HANDLER_FUNC   pMsgHandlerFunc;
    BOOLEAN                     bReturnToMicroport;
    NDIS_STATUS                 Status;
    PRNDISMP_RECV_MSG_CONTEXT   pRcvMsg;
    PMDL                        pTmpMdl;
    ULONG                       TotalLength;

    Adapter = PRNDISMP_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

    CHECK_VALID_ADAPTER(Adapter);

    TRACE2(("RndisIndicateReceive: Adapter %x, Mdl %x\n", Adapter, pMdl));

    RNDISMP_ASSERT_AT_DISPATCH();
    bReturnToMicroport = TRUE;

#if DBG
    NdisInterlockedIncrement(&Adapter->MicroportReceivesOutstanding);
#endif

    do
    {
        //
        // Find the total length first.
        //
        TotalLength = 0;
        for (pTmpMdl = pMdl; pTmpMdl != NULL; pTmpMdl = RNDISMP_GET_MDL_NEXT(pTmpMdl))
        {
            TotalLength += RNDISMP_GET_MDL_LENGTH(pTmpMdl);
        }

        //
        // Check if the entire message is in a single MDL - if not, make a copy
        // TBD -- handle multi-MDL messages without copying.
        //
        if ((RNDISMP_GET_MDL_NEXT(pMdl) == NULL) &&
            (!Adapter->bRunningOnWin9x || (ReceiveStatus != NDIS_STATUS_RESOURCES)))
        {
            pMessage = RNDISMP_GET_MDL_ADDRESS(pMdl);
            if (pMessage == NULL)
            {
                TRACE0(("RndisMIndicateReceive: Adapter %x: failed to"
                        " access msg from MDL %x\n", Adapter, pMdl));
                break;
            }
        }
        else
        {
            pMessage = CoalesceMultiMdlMessage(pMdl, TotalLength);
            if (pMessage == NULL)
            {
                break;
            }
            bMessageCopied = TRUE;
        }

        TRACEDUMP(("Received msg (%d bytes):\n", TotalLength),
                     pMessage, TotalLength);

        // get timer tick for this message
        NdisGetSystemUpTime(&Adapter->LastMessageFromDevice);

        if (Adapter->bRunningOnWin9x)
        {
            Status = MemAlloc(&pRcvMsg, sizeof(RNDISMP_RECV_MSG_CONTEXT));

            if (Status != NDIS_STATUS_SUCCESS)
            {
                bReturnToMicroport = TRUE;
                TRACE1(("RndisMIndicateReceive: Adapter %x, failed to alloc rcv msg\n",
                        Adapter));
                break;
            }

            pRcvMsg->MicroportMessageContext = MicroportMessageContext;
            pRcvMsg->pMdl = pMdl;
            pRcvMsg->TotalLength = TotalLength;
            pRcvMsg->pMessage = pMessage;
            pRcvMsg->ReceiveStatus = ReceiveStatus;
            pRcvMsg->bMessageCopied = bMessageCopied;
            pRcvMsg->ChannelType = ChannelType;

            //
            //  Queue all packets for indicating receives up to protocols.
            //  We do this rather than indicate packets directly because
            //  we are in a DPC context, and need to be in a "global event"
            //  context to make the upper layers happy. One way to be in a
            //  global event context is to be in the context of an NDIS timer
            //  callback function.
            //
            //  So, queue this up on the adapter and start a timer
            //  routine if necessary.
            //

            bReturnToMicroport = FALSE;

            RNDISMP_ACQUIRE_ADAPTER_LOCK(Adapter);

            InsertTailList(&Adapter->PendingRcvMessageList, &pRcvMsg->Link);

            if (!Adapter->IndicatingReceives)
            {
                Adapter->IndicatingReceives = TRUE;

                NdisSetTimer(&Adapter->IndicateTimer, 0);
            }

            RNDISMP_RELEASE_ADAPTER_LOCK(Adapter);
        }
        else
        {
            //
            //  Running on NT.
           
            if ((Adapter->DeviceFlags & RNDIS_DF_RAW_DATA) || (gRawEncap))
            {
                if (ChannelType == RMC_CONTROL)
                {
                    RNDISMP_GET_MSG_HANDLER(pMsgHandlerFunc,pMessage->NdisMessageType);
#if DBG
                    ASSERT(pMessage->NdisMessageType != REMOTE_NDIS_PACKET_MSG);
#endif
                } else
                {
                    pMsgHandlerFunc = ReceivePacketMessageRaw;
                }
            } else
            {
                RNDISMP_GET_MSG_HANDLER(pMsgHandlerFunc, pMessage->NdisMessageType);
#if DBG
                if (pMessage->NdisMessageType == REMOTE_NDIS_PACKET_MSG)
                {
                    ASSERT(ChannelType == RMC_DATA);
                }
                else
                {
                    ASSERT(ChannelType == RMC_CONTROL);
                }
#endif
	        }

            bReturnToMicroport = (*pMsgHandlerFunc)(
                                    Adapter,
                                    pMessage,
                                    pMdl,
                                    TotalLength,
                                    MicroportMessageContext,
                                    ReceiveStatus,
                                    bMessageCopied);
        }
    }
    while (FALSE);

    //
    // Are we done with the microport's message?
    //
    if (bReturnToMicroport || bMessageCopied)
    {
        RNDISMP_RETURN_TO_MICROPORT(Adapter,
                                    pMdl,
                                    MicroportMessageContext);
    }

    //
    // If we had made a copy of the microport's message, are we done with
    // this copy?
    //
    if (bMessageCopied && bReturnToMicroport)
    {
        FreeRcvMessageCopy(pMessage);
    }
}

/****************************************************************************/
/*                          CoalesceMultiMdlMessage                         */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Make a copy of a received message that is in a chain of multiple        */
/*  MDLs, into one single buffer.                                           */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pMdl - pointer to MDL that is the head of the chain.                    */
/*  TotalLength - length of data contained in entire chain.                 */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  PRNDIS_MESSAGE                                                          */
/*                                                                          */
/****************************************************************************/
PRNDIS_MESSAGE
CoalesceMultiMdlMessage(IN PMDL         pMdl,
                        IN ULONG        TotalLength)
{
    ULONG           MdlLength;
    PRNDIS_MESSAGE  pMessage;
    NDIS_STATUS     Status;
    PMDL            pTmpMdl;
    PUCHAR          pDest;

    TRACE2(("Coalesce: Mdl %x\n", pMdl));

    Status = MemAlloc(&pMessage, TotalLength);

    if (Status == NDIS_STATUS_SUCCESS)
    {
        pDest = (PUCHAR)pMessage;
        for (pTmpMdl = pMdl; pTmpMdl != NULL; pTmpMdl = RNDISMP_GET_MDL_NEXT(pTmpMdl))
        {
            MdlLength = RNDISMP_GET_MDL_LENGTH(pTmpMdl);
            RNDISMP_MOVE_MEM(pDest,
                             RNDISMP_GET_MDL_ADDRESS(pTmpMdl),
                             MdlLength);
            pDest = (PUCHAR)pDest + MdlLength;
        }
    }
    else
    {
        pMessage = NULL;
    }

    return (pMessage);
}

/****************************************************************************/
/*                          FreeRcvMessageCopy                              */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Free the local copy of a received RNDIS message.                        */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pMessage - pointer to RNDIS message                                     */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   VOID                                                                   */
/*                                                                          */
/****************************************************************************/
VOID
FreeRcvMessageCopy(IN PRNDIS_MESSAGE    pMessage)
{
    TRACE3(("FreeRcvMessageCopy: pMessage %x\n", pMessage));
    MemFree(pMessage, -1);
}

/****************************************************************************/
/*                          ReceivePacketMessage                            */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Got a packet message, so send it to the upper layers                    */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - pointer to our Adapter structure                             */
/*  pMessage - pointer to RNDIS message                                     */
/*  pMdl - pointer to MDL received from microport                           */
/*  TotalLength - length of complete message                                */
/*  MicroportMessageContext - context for message from micorport            */
/*  ReceiveStatus - used by microport to indicate it is low on resource     */
/*  bMessageCopied - is this a copy of the original message?                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  BOOLEAN - should the message be returned to the microport?              */
/*                                                                          */
/****************************************************************************/
BOOLEAN
ReceivePacketMessage(IN PRNDISMP_ADAPTER    pAdapter,
                     IN PRNDIS_MESSAGE      pMessage,
                     IN PMDL                pMdl,
                     IN ULONG               TotalLength,
                     IN NDIS_HANDLE         MicroportMessageContext,
                     IN NDIS_STATUS         ReceiveStatus,
                     IN BOOLEAN             bMessageCopied)
{
    ULONG                       LengthRemaining; // in entire message
    PMDL                        pTmpMdl;
    PRNDISMP_RECV_DATA_FRAME    pRcvFrame;
    ULONG                       NumberOfPackets;
    PRNDIS_PACKET               pRndisPacket;
    ULONG                       i;
#define MAX_RECV_PACKETS_IN_MSG     40
    PNDIS_PACKET                PacketArray[MAX_RECV_PACKETS_IN_MSG];
    ULONG                       NumPackets;

    PNDIS_PACKET                pNdisPacket;
    PRNDISMP_RECV_PKT_RESERVED  pRcvResvd;
    PNDIS_BUFFER                pNdisBuffer;
    NDIS_STATUS                 BufferStatus;
    NDIS_STATUS                 Status;
    BOOLEAN                     bDiscardPkt;
    PRNDISMP_VC                 pVc;

    bDiscardPkt = FALSE;
    pVc = NULL;

    do
    {
#ifndef BUILD_WIN9X
        if (bMessageCopied)
        {
            ReceiveStatus = NDIS_STATUS_SUCCESS;
        }
#else
        //
        // Rur ReturnPacket handler never gets called on
        // Win98 Gold, so we force the status to be able
        // to reclaim the indicated packet immediately.
        //
        ReceiveStatus = NDIS_STATUS_RESOURCES;
#endif

        //
        // Allocate a receive frame to keep track of this RNDIS packet message.
        //
        pRcvFrame = AllocateReceiveFrame(pAdapter);

        if (pRcvFrame == NULL)
        {
            bDiscardPkt = TRUE;
            break;
        }

        pRcvFrame->MicroportMessageContext = MicroportMessageContext;
        if (bMessageCopied)
        {
            pRcvFrame->pLocalMessageCopy = pMessage;
            pRcvFrame->bMessageCopy = TRUE;
        }
        else
        {
            pRcvFrame->pMicroportMdl = pMdl;
            pRcvFrame->bMessageCopy = FALSE;
        }

        NumberOfPackets = 0;

        LengthRemaining = TotalLength;

        //
        // TBD - Check that the received message is well-formed!
        //

        //
        //  Temp ref to take care of multiple indications.
        //
        pRcvFrame->ReturnsPending = 1;

        //
        //  Prepare NDIS packets for indicating up. 
        //
        do
        {
            pRndisPacket = RNDIS_MESSAGE_PTR_TO_MESSAGE_PTR(pMessage);

            //
            // Some sanity checks. TBD - do better checks!
            //
            if ((pMessage->MessageLength > LengthRemaining) ||
                (pMessage->NdisMessageType != REMOTE_NDIS_PACKET_MSG) ||
                (pMessage->MessageLength < RNDIS_MESSAGE_SIZE(RNDIS_PACKET)))
            {
                TRACE1(("ReceivePacketMessage: Msg %x: length %d  or type %x has a problem\n",
                        pMessage, pMessage->MessageLength, pMessage->NdisMessageType));
                ASSERT(FALSE);
                RNDISMP_INCR_STAT(pAdapter, RecvError);
                break;
            }

            if (pRndisPacket->DataLength > pMessage->MessageLength)
            {
                TRACE1(("ReceivePacketMessage: invalid data length (%d) > Msg length (%d)\n",
                    pRndisPacket->DataLength, pMessage->MessageLength));
                RNDISMP_INCR_STAT(pAdapter, RecvError);
                break;
            }

            if (pRndisPacket->VcHandle != 0)
            {
                pVc = LookupVcId(pAdapter, pRndisPacket->VcHandle);
                if (pVc == NULL)
                {
                    TRACE1(("ReceivePacketMessage: invalid Vc handle %x\n", pRndisPacket->VcHandle));
                    RNDISMP_INCR_STAT(pAdapter, RecvError);
                    break;
                }
            }

            //
            // Allocate an NDIS packet to do the indication with.
            //
            NdisAllocatePacket(&Status, &pNdisPacket, pAdapter->ReceivePacketPool);
            if (Status != NDIS_STATUS_SUCCESS)
            {
                pNdisPacket = NULL;

                TRACE2(("ReceivePacketMessage: failed to allocate packet, Adapter %X\n",
                    pAdapter));

                RNDISMP_INCR_STAT(pAdapter, RecvNoBuf);
                break;
            }

            NDIS_SET_PACKET_STATUS(pNdisPacket, ReceiveStatus);

            switch (pAdapter->Medium)
            {
                case NdisMedium802_3:
                    NDIS_SET_PACKET_HEADER_SIZE(pNdisPacket, ETHERNET_HEADER_SIZE);
                    break;
                default:
                    break;
            }

            NdisAllocateBuffer(&BufferStatus,
                               &pNdisBuffer,
                               pAdapter->ReceiveBufferPool,
                               GET_PTR_TO_RNDIS_DATA_BUFF(pRndisPacket),
                               pRndisPacket->DataLength);

            if (BufferStatus != NDIS_STATUS_SUCCESS)
            {
                TRACE1(("ReceivePacketMessage: failed to allocate"
                        " buffer, Adapter %X\n", pAdapter));
                NdisFreePacket(pNdisPacket);
                RNDISMP_INCR_STAT(pAdapter, RecvNoBuf);
                break;
            }

            TRACE2(("Rcv: msg Pkt %d bytes\n", pRndisPacket->DataLength));
            TRACEDUMP(("Rcv %d bytes\n", pRndisPacket->DataLength),
                        GET_PTR_TO_RNDIS_DATA_BUFF(pRndisPacket),
                        MIN(pRndisPacket->DataLength, 32));

            NdisChainBufferAtFront(pNdisPacket, pNdisBuffer);

            //
            //  Check if there is per-packet info.
            //
            if (!pAdapter->bRunningOnWin9x)
            {
                PRNDIS_PER_PACKET_INFO  pPerPacketInfo;
                ULONG                   PerPacketInfoLength;

                if (PerPacketInfoLength = pRndisPacket->PerPacketInfoLength)
                {
                    TRACE1(("ReceivePacketMessage: Adapter %p, Pkt %p:"
                        " non-zero perpacket length %d\n",
                        pAdapter, pRndisPacket, PerPacketInfoLength));

                    pPerPacketInfo = (PRNDIS_PER_PACKET_INFO)((PUCHAR)pRndisPacket +
                                        pRndisPacket->PerPacketInfoOffset);

                    while (PerPacketInfoLength != 0)
                    {
                        switch (pPerPacketInfo->Type)
                        {
                            case TcpIpChecksumPacketInfo:
                                NDIS_PER_PACKET_INFO_FROM_PACKET(pNdisPacket, TcpIpChecksumPacketInfo) =
                                    UlongToPtr(*(PULONG)((PUCHAR)pPerPacketInfo + pPerPacketInfo->PerPacketInformationOffset));
                                break;

                            case Ieee8021pPriority:
                                NDIS_PER_PACKET_INFO_FROM_PACKET(pNdisPacket, Ieee8021pPriority) =
                                    UlongToPtr(*(PULONG)((PUCHAR)pPerPacketInfo + pPerPacketInfo->PerPacketInformationOffset));

                            default:
                                break;
                        }
                        PerPacketInfoLength -= pPerPacketInfo->Size;
                        pPerPacketInfo = (PRNDIS_PER_PACKET_INFO)((PUCHAR)pPerPacketInfo +
                                    pPerPacketInfo->Size);
                    }
                }
            }

            //
            // Add this to the array of packets to be indicated up.
            //
            PacketArray[NumberOfPackets] = pNdisPacket;
            NumberOfPackets++;
            RNDISMP_INCR_STAT(pAdapter, RecvOk);

            pRcvResvd = PRNDISMP_RESERVED_FROM_RECV_PACKET(pNdisPacket);
            pRcvResvd->pRcvFrame = pRcvFrame;
            pRcvResvd->pVc = pVc;

            TRACE2(("ReceivePacketMessage: pRndisPkt %X, MsgLen %d,"
                    " DataLen %d, Stat %x, Discard %d\n", 
                        pRndisPacket, pMessage->MessageLength,
                        pRndisPacket->DataLength, ReceiveStatus, bDiscardPkt));

            LengthRemaining -= pMessage->MessageLength;
            pMessage = (PRNDIS_MESSAGE)((ULONG_PTR)pMessage + pMessage->MessageLength);

            NdisInterlockedIncrement(&pRcvFrame->ReturnsPending);

            if ((NumberOfPackets == MAX_RECV_PACKETS_IN_MSG) ||
                (LengthRemaining < RNDIS_MESSAGE_SIZE(RNDIS_PACKET)))
            {
                if (pVc == NULL)
                {
                    RcvIndicateCount += NumberOfPackets;
                    NdisMIndicateReceivePacket(pAdapter->MiniportAdapterHandle,
                                               PacketArray,
                                               NumberOfPackets);
                }
                else
                {
                    IndicateReceiveDataOnVc(pVc, PacketArray, NumberOfPackets);
                }
            
                if (ReceiveStatus == NDIS_STATUS_RESOURCES)
                {
                    for (i = 0; i < NumberOfPackets; i++)
                    {
                        RNDISMP_INCR_STAT(pAdapter, RecvLowRes);
                        RndismpReturnPacket(pAdapter,
                                            PacketArray[i]);
                    }
                }

                NumberOfPackets = 0;
            }
        }
        while (LengthRemaining >= RNDIS_MESSAGE_SIZE(RNDIS_PACKET));


        if (NumberOfPackets != 0)
        {
            //
            //  We bailed out of the above loop. Return what we
            //  have collected so far.
            //
            for (i = 0; i < NumberOfPackets; i++)
            {
                RndismpReturnPacket(pAdapter,
                                    PacketArray[i]);
            }
        }

        //
        //  Remove temp ref we added at the top.
        //
        DereferenceRcvFrame(pRcvFrame, pAdapter);
            
    }
    while (FALSE);

    if (pVc != NULL)
    {
        ULONG       RefCount;

        RNDISMP_DEREF_VC(pVc, &RefCount);
    }

    return (bDiscardPkt);
}

/****************************************************************************/
/*                        ReceivePacketMessageRaw                           */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Got a packet message, so send it to the upper layers                    */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - pointer to our Adapter structure                             */
/*  pMessage - pointer to RNDIS message                                     */
/*  pMdl - pointer to MDL received from microport                           */
/*  TotalLength - length of complete message                                */
/*  MicroportMessageContext - context for message from micorport            */
/*  ReceiveStatus - used by microport to indicate it is low on resource     */
/*  bMessageCopied - is this a copy of the original message?                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  BOOLEAN - should the message be returned to the microport?              */
/*                                                                          */
/****************************************************************************/
BOOLEAN
ReceivePacketMessageRaw(IN PRNDISMP_ADAPTER    pAdapter,
                        IN PRNDIS_MESSAGE      pMessage,
                        IN PMDL                pMdl,
                        IN ULONG               TotalLength,
                        IN NDIS_HANDLE         MicroportMessageContext,
                        IN NDIS_STATUS         ReceiveStatus,
                        IN BOOLEAN             bMessageCopied)
{
    ULONG                       LengthRemaining; // in entire message
    PMDL                        pTmpMdl;
    PRNDISMP_RECV_DATA_FRAME    pRcvFrame;
    ULONG                       NumberOfPackets;
    PRNDIS_PACKET               pRndisPacket;
    ULONG                       i;
#define MAX_RECV_PACKETS_IN_MSG     40
    PNDIS_PACKET                PacketArray[MAX_RECV_PACKETS_IN_MSG];
    ULONG                       NumPackets;

    PNDIS_PACKET                pNdisPacket;
    PRNDISMP_RECV_PKT_RESERVED  pRcvResvd;
    PNDIS_BUFFER                pNdisBuffer;
    NDIS_STATUS                 BufferStatus;
    NDIS_STATUS                 Status;
    BOOLEAN                     bDiscardPkt;
    PRNDISMP_VC                 pVc;

    bDiscardPkt = FALSE;
    pVc = NULL;
    pRcvFrame = NULL;

    do
    {
#ifndef BUILD_WIN9X
        if (bMessageCopied)
        {
            ReceiveStatus = NDIS_STATUS_SUCCESS;
        }
#else
        //
        // Rur ReturnPacket handler never gets called on
        // Win98 Gold, so we force the status to be able
        // to reclaim the indicated packet immediately.
        //
        ReceiveStatus = NDIS_STATUS_RESOURCES;
#endif

        //
        // Allocate a receive frame to keep track of this RNDIS packet message.
        //
        pRcvFrame = AllocateReceiveFrame(pAdapter);

        if (pRcvFrame == NULL)
        {
            bDiscardPkt = TRUE;
            break;
        }

        pRcvFrame->MicroportMessageContext = MicroportMessageContext;
        if (bMessageCopied)
        {
            pRcvFrame->pLocalMessageCopy = pMessage;
            pRcvFrame->bMessageCopy = TRUE;
        }
        else
        {
            pRcvFrame->pMicroportMdl = pMdl;
            pRcvFrame->bMessageCopy = FALSE;
        }

        NumberOfPackets = 0;

        LengthRemaining = TotalLength;

        //
        //  Temp ref to take care of multiple indications.
        //
        pRcvFrame->ReturnsPending = 1;

        //
        //  Prepare NDIS packets for indicating up. 
        //
        {
            pRndisPacket = RNDIS_MESSAGE_RAW_PTR_TO_MESSAGE_PTR(pMessage);

            //
            // Allocate an NDIS packet to do the indication with.
            //
            NdisAllocatePacket(&Status, &pNdisPacket, pAdapter->ReceivePacketPool);
            if (Status != NDIS_STATUS_SUCCESS)
            {
                pNdisPacket = NULL;

                TRACE2(("ReceivePacketMessage: failed to allocate packet, Adapter %X\n",
                    pAdapter));

                RNDISMP_INCR_STAT(pAdapter, RecvNoBuf);
                bDiscardPkt = TRUE;
                break;
            }

            NDIS_SET_PACKET_STATUS(pNdisPacket, ReceiveStatus);

            switch (pAdapter->Medium)
            {
                case NdisMedium802_3:
                    NDIS_SET_PACKET_HEADER_SIZE(pNdisPacket, ETHERNET_HEADER_SIZE);
                    break;
                default:
                    break;
            }

            NdisAllocateBuffer(&BufferStatus,
                               &pNdisBuffer,
                               pAdapter->ReceiveBufferPool,
                               pRndisPacket,
                               TotalLength);

            if (BufferStatus != NDIS_STATUS_SUCCESS)
            {
                TRACE1(("ReceivePacketMessage: failed to allocate"
                        " buffer, Adapter %X\n", pAdapter));
                NdisFreePacket(pNdisPacket);
                RNDISMP_INCR_STAT(pAdapter, RecvNoBuf);
                bDiscardPkt = TRUE;
                break;
            }

            TRACE2(("Rcv: msg Pkt %d bytes\n", pMessage->MessageLength));
            TRACEDUMP(("Rcv %d bytes\n", pMessage->MessageLength),
                        pRndisPacket,
						MIN(pMessage->MessageLength, 32));

            NdisChainBufferAtFront(pNdisPacket, pNdisBuffer);

            //
            // Add this to the array of packets to be indicated up.
            //
            PacketArray[NumberOfPackets] = pNdisPacket;
            NumberOfPackets++;
            RNDISMP_INCR_STAT(pAdapter, RecvOk);

            pRcvResvd = PRNDISMP_RESERVED_FROM_RECV_PACKET(pNdisPacket);
            pRcvResvd->pRcvFrame = pRcvFrame;
            pRcvResvd->pVc = pVc;

            TRACE1(("ReceivePacketMessageRaw: pRcvFrame %p/%d, pRndisPkt %p,"
                    " DataLen %d, Stat %x, Discard %d\n", 
                        pRcvFrame, pRcvFrame->ReturnsPending,
                        pRndisPacket,
                        pRndisPacket->DataLength, 
						ReceiveStatus, 
						bDiscardPkt));

            LengthRemaining -= pMessage->MessageLength;

            NdisInterlockedIncrement(&pRcvFrame->ReturnsPending);

            NdisMIndicateReceivePacket(pAdapter->MiniportAdapterHandle,
                                       PacketArray,
                                       NumberOfPackets);

            if (ReceiveStatus == NDIS_STATUS_RESOURCES)
            {
                for (i = 0; i < NumberOfPackets; i++)
                {
                    RNDISMP_INCR_STAT(pAdapter, RecvLowRes);
                    RndismpReturnPacket(pAdapter,
                                        PacketArray[i]);
                }
            }

        }

        //
        //  Remove temp ref we added at the top.
        //
        DereferenceRcvFrame(pRcvFrame, pAdapter);
            
    }
    while (FALSE);

    if (bDiscardPkt)
    {
    	//
    	//  Some failure occured above.
    	//
    	if (pRcvFrame != NULL)
    	{
	        FreeReceiveFrame(pRcvFrame, pAdapter);
	    }
	}

    return (bDiscardPkt);
}

/****************************************************************************/
/*                          IndicateStatusMessage                           */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Got an indicate status message, so send to upper layers                 */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Pointer to our Adapter structure                             */
/*  pMessage - pointer to RNDIS message                                     */
/*  pMdl - Pointer to MDL from microport                                    */
/*  TotalLength - length of complete message                                */
/*  MicroportMessageContext - context for message from microport            */
/*  ReceiveStatus - used by microport to indicate it is low on resource     */
/*  bMessageCopied - is this a copy of the original message?                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  BOOLEAN - should the message be returned to the microport?              */
/*                                                                          */
/****************************************************************************/
BOOLEAN
IndicateStatusMessage(IN PRNDISMP_ADAPTER   pAdapter,
              IN PRNDIS_MESSAGE     pMessage,
              IN PMDL               pMdl,
              IN ULONG              TotalLength,
              IN NDIS_HANDLE        MicroportMessageContext,
              IN NDIS_STATUS        ReceiveStatus,
              IN BOOLEAN            bMessageCopied)
{
    PRNDIS_INDICATE_STATUS  pRndisIndicateStatus;

    TRACE3(("IndicateStatusMessage: Adapter %x, Mdl %x\n", pAdapter, pMdl));

    // get a pointer to the indicate status message
    pRndisIndicateStatus = RNDIS_MESSAGE_PTR_TO_MESSAGE_PTR(pMessage);

    if (!pAdapter->Initing)
    {
#if DBG
        if (pRndisIndicateStatus->Status == NDIS_STATUS_MEDIA_CONNECT)
        {
            TRACE1(("Adapter %x: +++ Media Connect +++\n", pAdapter));
        }
        else if (pRndisIndicateStatus->Status == NDIS_STATUS_MEDIA_DISCONNECT)
        {
            TRACE1(("Adapter %x: --- Media Disconnect ---\n", pAdapter));
        }
#endif // DBG

        // send status indication to upper layers
        NdisMIndicateStatus(pAdapter->MiniportAdapterHandle,
                            (NDIS_STATUS) pRndisIndicateStatus->Status,
                            MESSAGE_TO_STATUS_BUFFER(pRndisIndicateStatus),
                            pRndisIndicateStatus->StatusBufferLength);

        // always have to indicate status complete
        NdisMIndicateStatusComplete(pAdapter->MiniportAdapterHandle);
    }
    else
    {
        //
        // drop status indications that arrive when we are
        // in the process of initializing.
        //
        TRACE1(("Adapter %x: indicated status %x when still initializing\n",
                pAdapter, (NDIS_STATUS) pRndisIndicateStatus->Status));
    }

    return (TRUE);
} // IndicateStatusMessage

/****************************************************************************/
/*                          UnknownMessage                                  */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Process a message with unknown message type. We simply drop it for now. */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Pointer to our Adapter structure                             */
/*  pMessage - pointer to RNDIS message                                     */
/*  pMdl - Pointer to MDL from microport                                    */
/*  TotalLength - length of complete message                                */
/*  MicroportMessageContext - context for message from microport            */
/*  ReceiveStatus - used by microport to indicate it is low on resource     */
/*  bMessageCopied - is this a copy of the original message?                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  BOOLEAN - should the message be returned to the microport?              */
/*                                                                          */
/****************************************************************************/
BOOLEAN
UnknownMessage(IN PRNDISMP_ADAPTER   pAdapter,
       IN PRNDIS_MESSAGE     pMessage,
       IN PMDL               pMdl,
       IN ULONG              TotalLength,
       IN NDIS_HANDLE        MicroportMessageContext,
       IN NDIS_STATUS        ReceiveStatus,
       IN BOOLEAN            bMessageCopied)
{
    TRACE1(("Unknown Message on Adapter %x, type %x, MDL %x, uPContext %x\n",
            pAdapter, pMessage->NdisMessageType, pMdl, MicroportMessageContext));

    ASSERT(FALSE);
    return TRUE;
}

/****************************************************************************/
/*                          AllocateReceiveFrame                            */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Allocate a receive frame to keep context about a single RNDIS_PACKET    */
/*  message.                                                                */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Pointer to our Adapter structure                             */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  PRNDISMP_RECV_DATA_FRAME                                                */
/*                                                                          */
/****************************************************************************/
PRNDISMP_RECV_DATA_FRAME
AllocateReceiveFrame(IN PRNDISMP_ADAPTER    pAdapter)
{
    PRNDISMP_RECV_DATA_FRAME    pRcvFrame;

#ifndef DONT_USE_LOOKASIDE_LIST
    pRcvFrame = (PRNDISMP_RECV_DATA_FRAME)
                NdisAllocateFromNPagedLookasideList(&pAdapter->RcvFramePool);
#else
    {
        NDIS_STATUS     Status;

        Status = MemAlloc(&pRcvFrame, sizeof(RNDISMP_RECV_DATA_FRAME));

        if (Status == NDIS_STATUS_SUCCESS)
        {
            NdisInterlockedIncrement(&RcvFrameAllocs);
        }
        else
        {
            pRcvFrame = NULL;
        }
    }
#endif // DONT_USE_LOOKASIDE_LIST

    return (pRcvFrame);
}

/****************************************************************************/
/*                          FreeReceiveFrame                                */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Allocate a receive frame to keep context about a single RNDIS_PACKET    */
/*  message.                                                                */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pRcvFrame - Pointer to receive frame being freed                        */
/*  pAdapter - Pointer to our Adapter structure                             */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
FreeReceiveFrame(IN PRNDISMP_RECV_DATA_FRAME    pRcvFrame,
                 IN PRNDISMP_ADAPTER            pAdapter)
{
#ifndef DONT_USE_LOOKASIDE_LIST
    NdisFreeToNPagedLookasideList(&pAdapter->RcvFramePool, pRcvFrame);
#else
    MemFree(pRcvFrame, sizeof(RNDISMP_RECV_DATA_FRAME));
    NdisInterlockedDecrement(&RcvFrameAllocs);
#endif // DONT_USE_LOOKASIDE_LIST
}



/****************************************************************************/
/*                          IndicateTimeout                                 */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Timeout callback routine to handle all receive indications. The actual  */
/*  NDIS routines to indicate receives is done from here, since this        */
/*  function runs in the right environment for protocols on WinME.          */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  SystemSpecific[1-3] - Ignored                                           */
/*  Context - Pointer to our Adapter structure                              */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
IndicateTimeout(IN PVOID SystemSpecific1,
                IN PVOID Context,
                IN PVOID SystemSpecific2,
                IN PVOID SystemSpecific3)
{
    PRNDISMP_ADAPTER            pAdapter;
    PLIST_ENTRY                 pEntry;
    PRNDISMP_RECV_MSG_CONTEXT   pRcvMsg;
    PRNDISMP_MSG_HANDLER_FUNC   pMsgHandlerFunc;
    PRNDIS_MESSAGE              pMessage;
    BOOLEAN                     bMessageCopied;
    BOOLEAN                     bReturnToMicroport;
    ULONG                       CurMsgs;

    pAdapter = (PRNDISMP_ADAPTER)Context;
    CHECK_VALID_ADAPTER(pAdapter);

    ASSERT(pAdapter->IndicatingReceives == TRUE);

    CurMsgs = 0;
    RcvTimerCount++;

    RNDISMP_ACQUIRE_ADAPTER_LOCK(pAdapter);

    while (!IsListEmpty(&pAdapter->PendingRcvMessageList))
    {
        pEntry = RemoveHeadList(&pAdapter->PendingRcvMessageList);

        RNDISMP_RELEASE_ADAPTER_LOCK(pAdapter);

        CurMsgs++;

        pRcvMsg = CONTAINING_RECORD(pEntry, RNDISMP_RECV_MSG_CONTEXT, Link);

        RNDISMP_GET_MSG_HANDLER(pMsgHandlerFunc, pRcvMsg->pMessage->NdisMessageType);

        bMessageCopied = pRcvMsg->bMessageCopied;
        pMessage = pRcvMsg->pMessage;

        bReturnToMicroport = (*pMsgHandlerFunc)(
                                pAdapter,
                                pMessage,
                                pRcvMsg->pMdl,
                                pRcvMsg->TotalLength,
                                pRcvMsg->MicroportMessageContext,
                                pRcvMsg->ReceiveStatus,
                                bMessageCopied);

        //
        // Are we done with the message?
        //
        if (bReturnToMicroport)
        {
            if (!bMessageCopied)
            {
                RNDISMP_RETURN_TO_MICROPORT(pAdapter,
                                            pRcvMsg->pMdl,
                                            pRcvMsg->MicroportMessageContext);
            }
            else
            {
                FreeRcvMessageCopy(pMessage);
            }
        }

        MemFree(pRcvMsg, sizeof(RNDISMP_RECV_MSG_CONTEXT));

        RNDISMP_ACQUIRE_ADAPTER_LOCK(pAdapter);
    }

    pAdapter->IndicatingReceives = FALSE;

    RcvMaxPackets = MAX(RcvMaxPackets, CurMsgs);

    RNDISMP_RELEASE_ADAPTER_LOCK(pAdapter);


} // IndicateTimeout
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rndis\rndismp\send.c ===
/***************************************************************************

Copyright (c) 1999  Microsoft Corporation

Module Name:

    SEND.C

Abstract:

    Multiple packet send routines for Remote NDIS Miniport driver

Environment:

    kernel mode only

Notes:

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

    Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    5/13/99 : created

Author:

    Tom Green

    
****************************************************************************/

#include "precomp.h"


ULONG   MdlsAllocated = 0;
ULONG   PktWrapperAllocated = 0;
ULONG   SndPacketCount = 0;
ULONG   SndTimerCount = 0;
ULONG   SndMaxPackets = 0;

BOOLEAN FirstDbg = FALSE;
BOOLEAN PrintPkts = FALSE;

/****************************************************************************/
/*                          RndismpMultipleSend                             */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  NDIS Entry point to send an array of NDIS packets on the specified      */
/*  adapter.                                                                */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  MiniportAdapterContext - a context version of our Adapter pointer       */
/*  PacketArray - An array of pointers to NDIS packets                      */
/*  NumberOfPackets - Number of packets in array                            */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
RndismpMultipleSend(IN NDIS_HANDLE   MiniportAdapterContext,
                    IN PPNDIS_PACKET PacketArray,
                    IN UINT          NumberOfPackets)
{
    PRNDISMP_ADAPTER                pAdapter;
    PNDIS_PACKET                    pNdisPacket;
    PRNDISMP_SEND_PKT_RESERVED_TEMP pSendRsvdTemp;
    ULONG                           i;

    // get adapter context
    pAdapter = PRNDISMP_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

    CHECK_VALID_ADAPTER(pAdapter);

    TRACE2(("RndismpMultipleSend\n"));

    if (pAdapter->bRunningOnWin9x)
    {
        RNDISMP_ACQUIRE_ADAPTER_LOCK(pAdapter);

        for (i = 0; i < NumberOfPackets; i++)
        {
            pNdisPacket = PacketArray[i];
            pSendRsvdTemp = PRNDISMP_RESERVED_TEMP_FROM_SEND_PACKET(pNdisPacket);

            InsertTailList(&pAdapter->PendingSendProcessList, &pSendRsvdTemp->Link);
        }

        if (!pAdapter->SendProcessInProgress)
        {
            pAdapter->SendProcessInProgress = TRUE;
            NdisSetTimer(&pAdapter->SendProcessTimer, 0);
        }

        RNDISMP_RELEASE_ADAPTER_LOCK(pAdapter);
    }
    else
    {
        //
        //  Running on NT.
        //

        ASSERT(pAdapter->MultipleSendFunc != NULL);

        pAdapter->MultipleSendFunc(pAdapter,
                                   NULL,
                                   PacketArray,
                                   NumberOfPackets);
    }

}

/****************************************************************************/
/*                             DoMultipleSend                               */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  NDIS Entry point to send an array of NDIS packets on the specified      */
/*  adapter. Handles both connection-less and connection-oriented data.     */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - pointer to Adapter structure                                 */
/*  pVc - pointer to VC structure (NULL if CL send)                         */
/*  PacketArray - An array of pointers to NDIS packets                      */
/*  NumberOfPackets - Number of packets in array                            */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
DoMultipleSend(IN PRNDISMP_ADAPTER  pAdapter,
               IN PRNDISMP_VC       pVc OPTIONAL,
               IN PPNDIS_PACKET     PacketArray,
               IN UINT              NumberOfPackets)
{
    UINT                    PacketCount;
    PNDIS_PACKET            pNdisPacket;
    PNDIS_PACKET *          pPacketArray;
    PNDIS_PACKET *          pPktPointer;
    PRNDISMP_SEND_PKT_RESERVED   pResvd, pPrevResvd;
    PRNDISMP_MESSAGE_FRAME  pMsgFrame;
    PRNDISMP_PACKET_WRAPPER pPktWrapper;
    PMDL                    pMdl;
    ULONG                   TotalMessageLength; // of current message
    ULONG                   MessagePacketCount; // # of NDIS_PACKETS in this message
    ULONG                   CurPacketLength;
    PULONG                  pNextPacketOffset;
    NDIS_STATUS             Status;
    ULONG                   i;
    BOOLEAN                 bMorePackets;


    pNextPacketOffset = NULL;
    pMsgFrame = NULL;
    Status = NDIS_STATUS_SUCCESS;
    PacketCount = 0;

    do
    {
        if (pAdapter->Halting)
        {
            Status = NDIS_STATUS_NOT_ACCEPTED;
            break;
        }

        pPacketArray = &PacketArray[0];

#if DBG
        if (NumberOfPackets > 1)
        {
            if (FirstDbg)
            {
                FirstDbg = FALSE;
                PrintPkts = TRUE;
            }
            else
            {
                PrintPkts = FALSE;
            }
        }
#endif

        for (PacketCount = 0;
             PacketCount < NumberOfPackets;
             NOTHING)
        {
            pNdisPacket = *pPacketArray;

            NdisQueryPacket(pNdisPacket, NULL, NULL, NULL, &CurPacketLength);

            TRACE2(("Send: Pkt %d bytes\n", CurPacketLength));

            bMorePackets = (pAdapter->bMultiPacketSupported &&
                            (PacketCount < NumberOfPackets - 1));

            if (pMsgFrame == NULL)
            {
                //
                //  Allocate a frame.
                //
                pMsgFrame = AllocateMsgFrame(pAdapter);
                if (pMsgFrame == NULL)
                {
                    Status = NDIS_STATUS_RESOURCES;
                    break;
                }

                pMsgFrame->NdisMessageType = REMOTE_NDIS_PACKET_MSG;
                pMsgFrame->pVc = pVc;
                pMsgFrame->pNdisPacket = NULL;
                pPktPointer = &pMsgFrame->pNdisPacket;
                TotalMessageLength = 0;
                MessagePacketCount = 0;
                pPrevResvd = NULL;
            }

            //
            //  Allocate and fill up the RNDIS message header for this packet.
            //
            pPktWrapper = PrepareDataMessage(
                            pNdisPacket,
                            pAdapter,
                            pVc,
                            &TotalMessageLength);

            if (pPktWrapper != NULL)
            {
                pPktWrapper->pMsgFrame = pMsgFrame;
                pMdl = pPktWrapper->pHeaderMdl;

                //
                //  Initialize our context in this packet.
                //
                pResvd = PRNDISMP_RESERVED_FROM_SEND_PACKET(pNdisPacket);
                pResvd->pPktWrapper = pPktWrapper;
                pResvd->pNext = NULL;

                if (pMsgFrame->pMessageMdl == NULL)
                {
                    pMsgFrame->pMessageMdl = pMdl;
                }

                //
                //  Link this packet to the list.
                //
                *pPktPointer = pNdisPacket;
                MessagePacketCount++;

                if (pPrevResvd != NULL)
                {
                    pPrevResvd->pPktWrapper->pTailMdl->Next = pMdl;
                }
            }

            if ((pPktWrapper == NULL) ||
                (!bMorePackets) ||
                (MessagePacketCount == pAdapter->MaxPacketsPerMessage))
            {
                //
                //  Check if we have some data that we can send.
                //
                if (MessagePacketCount != 0)
                {
                    //
                    //  Send this off to the microport.
                    //
#if DBG
                    if (NumberOfPackets != 1)
                    {
                        TRACE2(("Send: MsgFrame %x, FirstPkt %x, %d/%d pkts\n",
                                pMsgFrame,
                                pMsgFrame->pNdisPacket,
                                MessagePacketCount,
                                NumberOfPackets));
                    }

                    {
                        PMDL    pTmpMdl;
                        PUCHAR  pBuf;
                        ULONG   Length;

                        for (pTmpMdl = pMsgFrame->pMessageMdl;
                             pTmpMdl != NULL;
                             pTmpMdl = pTmpMdl->Next)
                        {
                            Length = MmGetMdlByteCount(pTmpMdl);
                            pBuf = MmGetSystemAddressForMdl(pTmpMdl);
                            TRACEDUMP(("MDL %x\n", pTmpMdl), pBuf, Length);
                        }
                    }
#endif // DBG
                    {
                        ULONG   k;

                        for (k = 0; k < MessagePacketCount; k++)
                        {
                            RNDISMP_INCR_STAT(pAdapter, XmitToMicroport);
                        }
                    }

                    RNDISMP_SEND_TO_MICROPORT(pAdapter, pMsgFrame, FALSE, CompleteSendData);
                    MessagePacketCount = 0;
                    pMsgFrame = NULL;

                    if (pPktWrapper != NULL)
                    {
                        PacketCount++;
                        pPacketArray++;
                    }

                    continue;
                }
                else
                {
                    TRACE1(("RndismpMultipleSend: Adapter %x, fail: PktWrp %x, bMore %d, MsgPktCount %d\n",
                            pAdapter,
                            pPktWrapper,
                            bMorePackets,
                            MessagePacketCount));
                    Status = NDIS_STATUS_RESOURCES;
                    break;
                }
            }

            pPktPointer = &pResvd->pNext;

            pPrevResvd = pResvd;
            PacketCount++;
            pPacketArray++;
        }

        if (PacketCount < NumberOfPackets)
        {
            break;
        }

        Status = NDIS_STATUS_SUCCESS;
    }
    while (FALSE);

    if (Status != NDIS_STATUS_SUCCESS)
    {
        TRACE1(("DoMultipleSend: Adapter %x, failure Status %x, PktCount %d, TotalPkts %d\n",
             pAdapter, Status, PacketCount, NumberOfPackets));

        //
        //  Undo all we have done so far.
        //
        for (i = PacketCount; i < NumberOfPackets; i++)
        {
            RNDISMP_INCR_STAT(pAdapter, XmitError);

            if (pVc == NULL)
            {
                TRACE1(("DoMultipleSend: Adapter %x, failing pkt %x\n",
                        pAdapter, PacketArray[i]));

                NdisMSendComplete(pAdapter->MiniportAdapterHandle,
                                  PacketArray[i],
                                  Status);
            }
            else
            {
                CompleteSendDataOnVc(pVc, PacketArray[i], Status);
            }
        }

        if (pMsgFrame)
        {
            pMsgFrame->pMessageMdl = NULL;
            DereferenceMsgFrame(pMsgFrame);
        }

    }

    return;
}

/****************************************************************************/
/*                            DoMultipleSendRaw                             */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  NDIS Entry point to send an array of NDIS packets on the specified      */
/*  adapter. Unlike DoMultipleSend, this handles raw encapsulation.         */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - pointer to Adapter structure                                 */
/*  pVc - pointer to VC structure (NULL if CL send)                         */
/*  PacketArray - An array of pointers to NDIS packets                      */
/*  NumberOfPackets - Number of packets in array                            */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
DoMultipleSendRaw(IN PRNDISMP_ADAPTER  pAdapter,
               IN PRNDISMP_VC       pVc OPTIONAL,
               IN PPNDIS_PACKET     PacketArray,
               IN UINT              NumberOfPackets)
{
    UINT                    PacketCount;
    PNDIS_PACKET            pNdisPacket;
    PNDIS_PACKET *          pPacketArray;
    PNDIS_PACKET *          pPktPointer;
    PRNDISMP_SEND_PKT_RESERVED   pResvd, pPrevResvd;
    PRNDISMP_MESSAGE_FRAME  pMsgFrame;
    PRNDISMP_PACKET_WRAPPER pPktWrapper;
    PMDL                    pMdl;
    ULONG                   TotalMessageLength; // of current message
    ULONG                   MessagePacketCount; // # of NDIS_PACKETS in this message
    ULONG                   CurPacketLength;
    PULONG                  pNextPacketOffset;
    NDIS_STATUS             Status;
    ULONG                   i;
    BOOLEAN                 bMorePackets;


    pNextPacketOffset = NULL;
    pMsgFrame = NULL;
    Status = NDIS_STATUS_SUCCESS;
    PacketCount = 0;

    if (pAdapter->Halting)
    {
        Status = NDIS_STATUS_NOT_ACCEPTED;
    } else
    {
        pPacketArray = &PacketArray[0];

#if DBG
        if (NumberOfPackets > 1)
        {
            if (FirstDbg)
            {
                FirstDbg = FALSE;
                PrintPkts = TRUE;
            }
            else
            {
                PrintPkts = FALSE;
            }
        }
#endif

        for (PacketCount = 0;
            PacketCount < NumberOfPackets;
            NOTHING)
        {
            pNdisPacket = *pPacketArray;

            NdisQueryPacket(pNdisPacket, NULL, NULL, NULL, &CurPacketLength);

            TRACE2(("Send: Pkt %d bytes\n", CurPacketLength));

            //
            //  Allocate a frame.
            //
            pMsgFrame = AllocateMsgFrame(pAdapter);
            if (pMsgFrame == NULL)
            {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }

            pMsgFrame->NdisMessageType = REMOTE_NDIS_PACKET_MSG;
            pMsgFrame->pNdisPacket = pNdisPacket;
            NdisQueryPacket(pNdisPacket,NULL,NULL,&(pMsgFrame->pMessageMdl),NULL);
            TotalMessageLength = 0;

            pPktWrapper = PrepareDataMessageRaw(
                            pNdisPacket,
                            pAdapter,
                            &TotalMessageLength);

            if (pPktWrapper != NULL)
            {
                pPktWrapper->pMsgFrame = pMsgFrame;
                pMdl = pPktWrapper->pHeaderMdl;

                pResvd = PRNDISMP_RESERVED_FROM_SEND_PACKET(pNdisPacket);
                pResvd->pPktWrapper = pPktWrapper;
                pResvd->pNext = NULL;

                pMsgFrame->pMessageMdl = pMdl;

#ifdef DBG
                TRACE2(("Send: MsgFrame %x, Pkt %x\n",pMsgFrame, pMsgFrame->pNdisPacket));
#endif

                RNDISMP_INCR_STAT(pAdapter,XmitToMicroport);

                RNDISMP_SEND_TO_MICROPORT(pAdapter,pMsgFrame,FALSE,CompleteSendData);
            }

            PacketCount++;
        }
    }


    if (Status != NDIS_STATUS_SUCCESS)
    {
        TRACE1(("DoMultipleSendRaw: Adapter %x, failure Status %x, PktCount %d, TotalPkts %d\n",
             pAdapter, Status, PacketCount, NumberOfPackets));

        //
        //  Undo all we have done so far.
        //
        for (i = PacketCount; i < NumberOfPackets; i++)
        {
            RNDISMP_INCR_STAT(pAdapter, XmitError);

            TRACE1(("DoMultipleSendRaw: Adapter %x, failing pkt %x\n",
                     pAdapter, PacketArray[i]));

            NdisMSendComplete(pAdapter->MiniportAdapterHandle,
                              PacketArray[i],
                              Status);
        }

        if (pMsgFrame)
        {
            pMsgFrame->pMessageMdl = NULL;
            DereferenceMsgFrame(pMsgFrame);
        }

    }

    return;
}

/****************************************************************************/
/*                          PrepareDataMessage                              */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Utility routine to prepare a complete or part of a data message.        */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pNdisPacket - the NDIS packet to be converted                           */
/*  pAdapter    - Adapter on which the packet is being sent                 */
/*  pVc         - VC on which the packet is sent (NULL if no VC context)    */
/*  pTotalMessageLength - On input, contains the total message length       */
/*       filled in so far. Updated on output.                               */
/*                                                                          */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    PRNDISMP_PACKET_WRAPPER                                               */
/*                                                                          */
/****************************************************************************/
PRNDISMP_PACKET_WRAPPER
PrepareDataMessage(IN   PNDIS_PACKET            pNdisPacket,
                   IN   PRNDISMP_ADAPTER        pAdapter,
                   IN   PRNDISMP_VC             pVc         OPTIONAL,
                   IN OUT PULONG                pTotalMessageLength)
{
    PMDL                        pMdl, pNextMdl;
    PMDL *                      ppNextMdl;
    PRNDISMP_PACKET_WRAPPER     pPktWrapper;
    RNDIS_MESSAGE UNALIGNED *   pRndisMessage;
    RNDIS_PACKET UNALIGNED *    pPacketMsg;
    PNDIS_BUFFER                pNdisBuffer;
    PNDIS_BUFFER                pNextNdisBuffer;
    ULONG                       TotalMessageLength;
    ULONG                       PacketMsgLength;
    ULONG                       OobDataLength;
    ULONG                       PerPacketInfoLength;
    ULONG                       AlignedLength;
    ULONG                       AlignmentOffset;
    ULONG                       TotalDataLength;
    ULONG                       TcpipChecksum, TcpLargeSend, PacketPriority;
    NDIS_STATUS                 Status = NDIS_STATUS_SUCCESS;

    pPktWrapper = NULL;
    pMdl = NULL;

    do
    {
        TotalMessageLength = 0;

        RNDISMP_GET_ALIGNED_LENGTH(AlignedLength, *pTotalMessageLength, pAdapter);
        AlignmentOffset = (AlignedLength - *pTotalMessageLength);

        //
        //  Compute attachments. Zero for now.
        //  TBD -- do the real thing.
        //
        OobDataLength = 0;
        PerPacketInfoLength = 0;

        //
        //  Look for per-packet info elements, only on Win2K/Whistler.
        //
        if (!pAdapter->bRunningOnWin9x)
        {
            //
            //  TCP/IP checksum offload?
            //
            TcpipChecksum = PtrToUlong(NDIS_PER_PACKET_INFO_FROM_PACKET(pNdisPacket, TcpIpChecksumPacketInfo));
            if (TcpipChecksum != 0)
            {
                PerPacketInfoLength += sizeof(RNDIS_PER_PACKET_INFO) + sizeof(ULONG);
                TRACE1(("Send: Pkt %p has TCP checksum %x\n",
                        pNdisPacket, TcpipChecksum));
            }

            //
            //  TCP large send offload?
            //
            TcpLargeSend = PtrToUlong(NDIS_PER_PACKET_INFO_FROM_PACKET(pNdisPacket, TcpLargeSendPacketInfo));
            if (TcpLargeSend != 0)
            {
                PerPacketInfoLength += sizeof(RNDIS_PER_PACKET_INFO) + sizeof(ULONG);
                TRACE1(("Send: Pkt %p has TCP large send %x\n",
                        pNdisPacket, TcpLargeSend));
            }

            //
            //  Packet priority?
            //
            PacketPriority = PtrToUlong(NDIS_PER_PACKET_INFO_FROM_PACKET(pNdisPacket, Ieee8021pPriority));
            if (PacketPriority != 0)
            {
                PerPacketInfoLength += sizeof(RNDIS_PER_PACKET_INFO) + sizeof(ULONG);
                TRACE1(("Send: Pkt %p has priority %x\n",
                        pNdisPacket, PacketPriority));
            }
        }

        PacketMsgLength = sizeof(*pPacketMsg) +
                          OobDataLength +
                          PerPacketInfoLength +
                          AlignmentOffset;

        //
        //  Need space for common RNDIS message header.
        //
        PacketMsgLength += (sizeof(RNDIS_MESSAGE) - sizeof(RNDIS_MESSAGE_CONTAINER));

        NdisQueryPacket(pNdisPacket, NULL, NULL, NULL, &TotalDataLength);

        //
        //  We know the max transfer size of any message that we are allowed
        //  to send to the device. Is this going beyond that limit?
        //
        if (*pTotalMessageLength + PacketMsgLength + TotalDataLength >
                pAdapter->MaxTransferSize)
        {
            TRACE2(("PrepareDataMessage: Adapter %x, pkt %x, length %d > device limit (%d)\n",
                    pAdapter,
                    pNdisPacket,
                    *pTotalMessageLength + PacketMsgLength + TotalDataLength,
                    pAdapter->MaxTransferSize));
            break;
        }

        //
        //  Allocate an RNDIS_PACKET buffer.
        //
        pPktWrapper = AllocatePacketMsgWrapper(pAdapter, PacketMsgLength);

        if (pPktWrapper == NULL)
        {
            TRACE1(("PrepareDataMessage: failed to alloc wrapper, Adapter %x, Length %d\n", pAdapter, PacketMsgLength));
            ASSERT(FALSE);
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        pPktWrapper->pNdisPacket = pNdisPacket;
        pPktWrapper->pVc = pVc;
        pRndisMessage = (PRNDIS_MESSAGE)
                        ((ULONG_PTR)&pPktWrapper->Packet[0] + AlignmentOffset);

        pPacketMsg = (PRNDIS_PACKET)(&pRndisMessage->Message);
        pRndisMessage->NdisMessageType = REMOTE_NDIS_PACKET_MSG;

        if (pVc == NULL)
        {
            pPacketMsg->VcHandle = 0;
        }
        else
        {
            pPacketMsg->VcHandle = pVc->DeviceVcContext;
        }

#if DBG
        if (PrintPkts)
        {
            TRACE1(("  Offs %d/x%x AlignOff %d/x%x, DataLen %d/x%x\n",
                    *pTotalMessageLength, *pTotalMessageLength,
                    AlignmentOffset, AlignmentOffset,
                    TotalDataLength, TotalDataLength));
        }
#endif // DBG

        //
        //  Allocate MDLs for the RNDIS_PACKET header and for each
        //  component NDIS buffer in the packet.
        //
        pMdl = IoAllocateMdl(
                    &pPktWrapper->Packet[0],
                    PacketMsgLength,
                    FALSE,
                    FALSE,
                    NULL);


        if (pMdl == NULL)
        {
            TRACE1(("PrepareDataMsg: Adapter %x failed to alloc MDL for header\n", pAdapter));
            Status = NDIS_STATUS_RESOURCES;
            TRACE1(("PrepareDataMsg: outstanding MDL count %d, at %x\n", MdlsAllocated, &MdlsAllocated));
            ASSERT(FALSE);
            break;
        }

        NdisInterlockedIncrement(&MdlsAllocated);

        MmBuildMdlForNonPagedPool(pMdl);

        pMdl->Next = NULL;
        pPktWrapper->pHeaderMdl = pMdl;
        ppNextMdl = &pMdl->Next;

        TRACE2(("PrepareDataMsg: NdisPkt %x, PacketMsgLen %d, TotalDatalen %d, Mdl %x, pRndisMessage %x\n",
                pNdisPacket, PacketMsgLength, TotalDataLength, pMdl, pRndisMessage));

        TotalDataLength = 0;

        for (pNdisBuffer = pNdisPacket->Private.Head;
             pNdisBuffer != NULL;
             pNdisBuffer = pNextNdisBuffer)
        {
            PVOID       VirtualAddress;
            UINT        BufferLength;

            NdisGetNextBuffer(pNdisBuffer, &pNextNdisBuffer);

#ifndef BUILD_WIN9X
            NdisQueryBufferSafe(pNdisBuffer, &VirtualAddress, &BufferLength, NormalPagePriority);
            if ((BufferLength != 0) && (VirtualAddress == NULL))
            {
                TRACE1(("PrepareDataMsg: Adapter %x failed to query buffer %p, Pkt %p\n",
                        pAdapter, pNdisBuffer, pNdisPacket));
                Status = NDIS_STATUS_RESOURCES;
                break;
            }
#else
            NdisQueryBuffer(pNdisBuffer, &VirtualAddress, &BufferLength);
#endif // BUILD_WIN9X

            //
            //  Skip any 0-length buffers given to us by IP or NDISTEST
            //
            if (BufferLength != 0)
            {
                TotalDataLength += BufferLength;

                pMdl = IoAllocateMdl(
                        VirtualAddress,
                        BufferLength,
                        FALSE,
                        FALSE,
                        NULL);

                if (pMdl == NULL)
                {
                    TRACE1(("PrepareDataMsg: Adapter %x failed to alloc MDL\n", pAdapter));
                    Status = NDIS_STATUS_RESOURCES;
                    TRACE1(("PrepareDataMsg: outstanding MDL count %d, at %x\n", MdlsAllocated, &MdlsAllocated));
                    ASSERT(FALSE);
                    break;
                }

                NdisInterlockedIncrement(&MdlsAllocated);

                MmBuildMdlForNonPagedPool(pMdl);
                *ppNextMdl = pMdl;
                ppNextMdl = &pMdl->Next;

                pMdl->Next = NULL;
            }
        }
        
        if (pNdisBuffer != NULL)
        {
            //
            //  We bailed out before reaching the end of the list.
            //
            break;
        }

        *ppNextMdl = NULL;
        pPktWrapper->pTailMdl = pMdl;

        TotalMessageLength += (PacketMsgLength + TotalDataLength);
        pRndisMessage->MessageLength = PacketMsgLength + TotalDataLength;

        *pTotalMessageLength += TotalMessageLength;

        //
        //  Fill in the RNDIS_PACKET message completely now.
        //
        pPacketMsg->DataOffset = sizeof(RNDIS_PACKET) + OobDataLength + PerPacketInfoLength;
        pPacketMsg->DataLength = TotalDataLength;

        if (PerPacketInfoLength)
        {
            PRNDIS_PER_PACKET_INFO  pPerPacketInfo;

            pPacketMsg->PerPacketInfoOffset = sizeof(RNDIS_PACKET);
            pPacketMsg->PerPacketInfoLength = PerPacketInfoLength;

            pPerPacketInfo = (PRNDIS_PER_PACKET_INFO)((PUCHAR)pPacketMsg + sizeof(RNDIS_PACKET));
            if (TcpipChecksum)
            {
                pPerPacketInfo->Size = sizeof(RNDIS_PER_PACKET_INFO) + sizeof(ULONG);
                pPerPacketInfo->Type = TcpIpChecksumPacketInfo;
                pPerPacketInfo->PerPacketInformationOffset = sizeof(RNDIS_PER_PACKET_INFO);
                *(PULONG)(pPerPacketInfo + 1) = TcpipChecksum;
                pPerPacketInfo = (PRNDIS_PER_PACKET_INFO)((PUCHAR)pPerPacketInfo + pPerPacketInfo->Size);
            }

            if (TcpLargeSend)
            {
                pPerPacketInfo->Size = sizeof(RNDIS_PER_PACKET_INFO) + sizeof(ULONG);
                pPerPacketInfo->Type = TcpLargeSendPacketInfo;
                pPerPacketInfo->PerPacketInformationOffset = sizeof(RNDIS_PER_PACKET_INFO);
                *(PULONG)(pPerPacketInfo + 1) = TcpLargeSend;
                pPerPacketInfo = (PRNDIS_PER_PACKET_INFO)((PUCHAR)pPerPacketInfo + pPerPacketInfo->Size);
                //
                //  Since we do not have a send-completion message, we fill up
                //  the "ack" for large send right here.
                //
                NDIS_PER_PACKET_INFO_FROM_PACKET(pNdisPacket, TcpLargeSendPacketInfo) =
                    UlongToPtr(TotalDataLength);
            }

            if (PacketPriority)
            {
                pPerPacketInfo->Size = sizeof(RNDIS_PER_PACKET_INFO) + sizeof(ULONG);
                pPerPacketInfo->Type = Ieee8021pPriority;
                pPerPacketInfo->PerPacketInformationOffset = sizeof(RNDIS_PER_PACKET_INFO);
                *(PULONG)(pPerPacketInfo + 1) = PacketPriority;
                pPerPacketInfo = (PRNDIS_PER_PACKET_INFO)((PUCHAR)pPerPacketInfo + pPerPacketInfo->Size);
            }
        }

    }
    while (FALSE);

    if (Status != NDIS_STATUS_SUCCESS)
    {
        TRACE1(("PrepareDataMessage: Adapter %x, failed %x\n", pAdapter, Status));

        //
        //  Undo all we have done so far.
        //
        if (pPktWrapper)
        {
            for (pMdl = pPktWrapper->pHeaderMdl;
                 pMdl != NULL;
                 pMdl = pNextMdl)
            {
                pNextMdl = pMdl->Next;
                IoFreeMdl(pMdl);
                NdisInterlockedDecrement(&MdlsAllocated);
            }

            FreePacketMsgWrapper(pPktWrapper);

            pPktWrapper = NULL;
        }
    }

    TRACE2(("PrepareDataMessage (%08X)\n", pPktWrapper));
    return (pPktWrapper);
}
/****************************************************************************/
/*                         PrepareDataMessageRaw                            */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Utility routine to prepare a complete or part of a data message.        */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pNdisPacket - the NDIS packet to be converted                           */
/*  pAdapter    - Adapter on which the packet is being sent                 */
/*  pVc         - VC on which the packet is sent (NULL if no VC context)    */
/*  pTotalMessageLength - On input, contains the total message length       */
/*       filled in so far. Updated on output.                               */
/*                                                                          */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    PRNDISMP_PACKET_WRAPPER                                               */
/*                                                                          */
/****************************************************************************/
PRNDISMP_PACKET_WRAPPER
PrepareDataMessageRaw(IN   PNDIS_PACKET            pNdisPacket,
                      IN   PRNDISMP_ADAPTER        pAdapter,
                      IN OUT PULONG                pTotalMessageLength)
{
    PMDL                        pMdl, pNextMdl;
    PMDL *                      ppNextMdl;
    PRNDISMP_PACKET_WRAPPER     pPktWrapper;
    RNDIS_MESSAGE UNALIGNED *   pRndisMessage;
    PNDIS_BUFFER                pNdisBuffer;
    PNDIS_BUFFER                pNextNdisBuffer;
    ULONG                       TotalMessageLength;
    ULONG                       TotalDataLength;
    ULONG                       AlignedLength;
    ULONG                       AlignmentOffset;
    NDIS_STATUS                 Status = NDIS_STATUS_SUCCESS;

    pPktWrapper = NULL;
    pMdl = NULL;
    
    RNDISMP_GET_ALIGNED_LENGTH(AlignedLength, *pTotalMessageLength, pAdapter);
    AlignmentOffset = (AlignedLength - *pTotalMessageLength);

    do
    {
        TotalMessageLength = 0;


        //
        //  Allocate an RNDIS_PACKET buffer.
        //
        pPktWrapper = AllocatePacketMsgWrapper(pAdapter, 0);

        if (pPktWrapper == NULL)
        {
            TRACE1(("PrepareDataMessage: failed to alloc wrapper, Adapter %x\n", pAdapter));
            ASSERT(FALSE);
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        pPktWrapper->pNdisPacket = pNdisPacket;
        pPktWrapper->pVc = NULL;
		pPktWrapper->pHeaderMdl = NULL;

        TotalDataLength = 0;

        for (pNdisBuffer = pNdisPacket->Private.Head;
             pNdisBuffer != NULL;
             pNdisBuffer = pNextNdisBuffer)
        {
            PVOID       VirtualAddress;
            UINT        BufferLength;

            NdisGetNextBuffer(pNdisBuffer, &pNextNdisBuffer);

#ifndef BUILD_WIN9X
            NdisQueryBufferSafe(pNdisBuffer, &VirtualAddress, &BufferLength, NormalPagePriority);
            if ((BufferLength != 0) && (VirtualAddress == NULL))
            {
                TRACE1(("PrepareDataMsg: Adapter %x failed to query buffer %p, Pkt %p\n",
                        pAdapter, pNdisBuffer, pNdisPacket));
                Status = NDIS_STATUS_RESOURCES;
                break;
            }
#else
            NdisQueryBuffer(pNdisBuffer, &VirtualAddress, &BufferLength);
#endif // BUILD_WIN9X

            //
            //  Skip any 0-length buffers given to us by IP or NDISTEST
            //
            if (BufferLength != 0)
            {
                TotalDataLength += BufferLength;

                pMdl = IoAllocateMdl(
                        VirtualAddress,
                        BufferLength,
                        FALSE,
                        FALSE,
                        NULL);

                if (pMdl == NULL)
                {
                    TRACE1(("PrepareDataMsg: Adapter %x failed to alloc MDL\n", pAdapter));
                    Status = NDIS_STATUS_RESOURCES;
                    TRACE1(("PrepareDataMsg: outstanding MDL count %d, at %x\n", MdlsAllocated, &MdlsAllocated));
                    ASSERT(FALSE);
                    break;
                }

                pMdl->Next = NULL;

                if (pPktWrapper->pHeaderMdl == NULL)
                {
                    pPktWrapper->pHeaderMdl = pMdl;
                    pPktWrapper->pTailMdl = pMdl;
                } else
                {
                    pPktWrapper->pTailMdl->Next = pMdl;
                    pPktWrapper->pTailMdl = pMdl;
                }


                NdisInterlockedIncrement(&MdlsAllocated);
                MmBuildMdlForNonPagedPool(pMdl);
            }
        }
        
        if (pNdisBuffer != NULL)
        {
            //
            //  We bailed out before reaching the end of the list.
            //
            break;
        }

        

        *pTotalMessageLength += TotalDataLength;

    }
    while (FALSE);

    if (Status != NDIS_STATUS_SUCCESS)
    {
        TRACE1(("PrepareDataMessage: Adapter %x, failed %x\n", pAdapter, Status));

        //
        //  Undo all we have done so far.
        //
        if (pPktWrapper)
        {
            for (pMdl = pPktWrapper->pHeaderMdl;
                 pMdl != NULL;
                 pMdl = pNextMdl)
            {
                pNextMdl = pMdl->Next;
                IoFreeMdl(pMdl);
                NdisInterlockedDecrement(&MdlsAllocated);
            }

            FreePacketMsgWrapper(pPktWrapper);

            pPktWrapper = NULL;
        }
    }

    TRACE2(("PrepareDataMessage (%08X)\n", pPktWrapper));
    return (pPktWrapper);
}



/****************************************************************************/
/*                          AllocatePacketMsgWrapper                        */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Allocate a structure to keep information about one NDIS packet sent     */
/*  through the microport.                                                  */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Adapter on which this packet is going to be sent.            */
/*  MsgHeaderLength - Total length of the wrapper structure                 */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    PRNDISMP_PACKET_WRAPPER                                               */
/*                                                                          */
/****************************************************************************/
PRNDISMP_PACKET_WRAPPER
AllocatePacketMsgWrapper(IN PRNDISMP_ADAPTER        pAdapter,
                         IN ULONG                   MsgHeaderLength)
{
    PRNDISMP_PACKET_WRAPPER     pPktWrapper;
    NDIS_STATUS                 Status;
    ULONG                       TotalLength;

    TotalLength = sizeof(RNDISMP_PACKET_WRAPPER) + MsgHeaderLength;

    Status = MemAlloc(&pPktWrapper, TotalLength);

    if (Status == NDIS_STATUS_SUCCESS)
    {
        NdisZeroMemory(pPktWrapper, TotalLength);
        NdisInterlockedIncrement(&PktWrapperAllocated);
    }
    else
    {
        TRACE1(("AllocPacketMsgWrapper failed, adapter %x, alloc count %d at %x\n",
            pAdapter, PktWrapperAllocated, &PktWrapperAllocated));
        ASSERT(FALSE);
        pPktWrapper = NULL;
    }

    return (pPktWrapper);
}

    


/****************************************************************************/
/*                          FreePacketMsgWrapper                            */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Free a structure used to keep information about one NDIS packet sent    */
/*  through the microport.                                                  */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pPktWrapper - Pointer to wrapper structure.                             */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
FreePacketMsgWrapper(IN PRNDISMP_PACKET_WRAPPER     pPktWrapper)
{
    MemFree(pPktWrapper, sizeof(RNDISMP_PACKET_WRAPPER));
    NdisInterlockedDecrement(&PktWrapperAllocated);
}


/****************************************************************************/
/*                          CompleteSendData                                */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Callback function to handle completion of send data message sent        */
/*  down to microport                                                       */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pMsgFrame - our frame structure holding information about a send        */
/*  SendStatus - indicate status of send message                            */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
CompleteSendData(IN  PRNDISMP_MESSAGE_FRAME pMsgFrame,
                 IN  NDIS_STATUS            SendStatus)
{
    PRNDISMP_ADAPTER            Adapter;
    PNDIS_PACKET                Packet;
    PMDL                        pMdl, pNextMdl;
    PRNDISMP_PACKET_WRAPPER     pPktWrapper, pNextPktWrapper;
    PRNDISMP_SEND_PKT_RESERVED  pResvd;
    PNDIS_PACKET                NextPacket;
    PRNDISMP_VC                 pVc;


    Adapter = pMsgFrame->pAdapter;

    TRACE2(("CompleteSendData: Adapter %x, MsgFrame %x, SendStatus %x\n",
                Adapter, pMsgFrame, SendStatus));

#if DBG_TIME_STAMPS
    {
        ULONG   NowTime;
        ULONG   PendedTime;

        RNDISMP_GET_TIME_STAMP(&NowTime);
        PendedTime = NowTime - pMsgFrame->TimeSent;
        if (PendedTime > Adapter->MaxSendCompleteTime)
        {
            TRACE1(("CompleteSendData: Adapter %x: pend time %d millisec\n",
                    Adapter, PendedTime));
            Adapter->MaxSendCompleteTime = PendedTime;
        }
    }
#endif // DBG_TIME_STAMPS

    //
    // free all MDLs we had allocated.
    //
    for (pMdl = pMsgFrame->pMessageMdl;
         pMdl != NULL;
         pMdl = pNextMdl)
    {
        pNextMdl = pMdl->Next;
        IoFreeMdl(pMdl);
        NdisInterlockedDecrement(&MdlsAllocated);
    }


    //
    // we may have sent several NDIS packets in one message
    // so we have to walk the list and complete each one
    //
    for (Packet = pMsgFrame->pNdisPacket;
         Packet != NULL;
         Packet = NextPacket)
    {
        pResvd = PRNDISMP_RESERVED_FROM_SEND_PACKET(Packet);

        // get the next packet linked
        NextPacket = pResvd->pNext;

        pPktWrapper = pResvd->pPktWrapper;
#if DBG
        if (NextPacket != NULL)
        {
            TRACE2(("CompleteSendData: multi: MsgFrame %x, tpkt %x, wrapper %x\n",
                pMsgFrame, Packet,
                // *(PULONG)((PUCHAR)Packet + 0x98),
                pPktWrapper));
        }
#endif // DBG

        pVc = pPktWrapper->pVc;

        // free the wrapper structure for this packet.
        FreePacketMsgWrapper(pPktWrapper);

        // send completion to upper layers
        TRACE2(("CompleteSendData: Adapter %x, completing pkt %x\n", Adapter, Packet));

        if (SendStatus == NDIS_STATUS_SUCCESS)
        {
            RNDISMP_INCR_STAT(Adapter, XmitOk);
        }
        else
        {
            RNDISMP_INCR_STAT(Adapter, XmitError);
        }

        if (pVc == NULL)
        {
            NdisMSendComplete(Adapter->MiniportAdapterHandle,
                              Packet,
                              SendStatus);
        }
        else
        {
            CompleteSendDataOnVc(pVc, Packet, SendStatus);
        }
    }

    // free up frame and resources
    pMsgFrame->pMessageMdl = NULL;
    DereferenceMsgFrame(pMsgFrame);


} // CompleteSendData


/****************************************************************************/
/*                          FreeMsgAfterSend                                */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Called by microport to indicate completion of send data message sent    */
/*  down by miniport                                                        */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pMsgFrame - our frame structure holding information about a send        */
/*  SendStatus - indicate status of send message                            */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
FreeMsgAfterSend(IN  PRNDISMP_MESSAGE_FRAME pMsgFrame,
                 IN  NDIS_STATUS            SendStatus)
{
    DereferenceMsgFrame(pMsgFrame);
}


#if THROTTLE_MESSAGES
/****************************************************************************/
/*                          QueueMessageToMicroport                         */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Queue the given message on the list of messages to be send to the       */
/*  microport, and start sending down these, if we haven't sent too many    */
/*  already.                                                                */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter  - our Adapter structure                                       */
/*  pMsgFrame - our frame structure holding information about a send        */
/*  bQueueMessageForResponse - add this message to the pending-response     */
/*                              list on the adapter. We expect a response   */
/*                              for this from the device.                   */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
QueueMessageToMicroport(IN PRNDISMP_ADAPTER pAdapter,
                        IN PRNDISMP_MESSAGE_FRAME pMsgFrame,
                        IN BOOLEAN bQueueMessageForResponse)
{
    PLIST_ENTRY             pEnt;
    PRNDISMP_MESSAGE_FRAME  pFrame;
    RM_CHANNEL_TYPE         ChannelType;

    RNDISMP_ACQUIRE_ADAPTER_LOCK(pAdapter);

    do
    {
        if (pMsgFrame)
        {
            //
            //  Add to waiting queue.
            //
            InsertTailList(&pAdapter->WaitingMessageList, &pMsgFrame->PendLink);
            if (bQueueMessageForResponse)
            {
                InsertTailList(&pAdapter->PendingFrameList, &pMsgFrame->Link);
            }
        }

        //
        //  Prevent more than one thread from executing below.
        //
        if (pAdapter->SendInProgress)
        {
            break;
        }

        pAdapter->SendInProgress = TRUE;

        //
        //  Send as many messages to the microport as we can, without exceeding
        //  the high-water mark for messages pending at the microport.
        //
        while ((pAdapter->CurPendedMessages < pAdapter->HiWatPendedMessages) &&
               !IsListEmpty(&pAdapter->WaitingMessageList))
        {
            //
            //  Take out the first message in the waiting queue.
            //
            pEnt = pAdapter->WaitingMessageList.Flink;
            pFrame = CONTAINING_RECORD(pEnt, RNDISMP_MESSAGE_FRAME, PendLink);
            RemoveEntryList(pEnt);

            CHECK_VALID_FRAME(pFrame);

            pAdapter->CurPendedMessages++;
            InsertTailList(&pAdapter->PendingAtMicroportList, pEnt);

            RNDISMP_RELEASE_ADAPTER_LOCK(pAdapter);

            RNDISMP_GET_TIME_STAMP(&pFrame->TimeSent);

            DBG_LOG_SEND_MSG(pAdapter, pFrame);

            //
            //  Check if we are halting the adapter, fail if so.
            //  NOTE: the only message we let thru is a HALT.
            //
            if (pAdapter->Halting &&
                (pFrame->NdisMessageType != REMOTE_NDIS_HALT_MSG))
            {
                TRACE1(("QueueMsg: Adapter %x is halting, dropped msg 0x%x!\n", 
                        pAdapter, pFrame->NdisMessageType));

                RndisMSendComplete(
                    (NDIS_HANDLE)pAdapter,
                    pFrame,
                    NDIS_STATUS_NOT_ACCEPTED);

                RNDISMP_ACQUIRE_ADAPTER_LOCK(pAdapter);

                continue;
            }
            
            //
            //  Send the message to the microport. The microport will
            //  call RndisMSendComplete when it is done with it.
            //
#if DBG
            {
                ULONG       Length;
                PUCHAR      pBuf;

                Length = MmGetMdlByteCount(pFrame->pMessageMdl);
                pBuf = MmGetSystemAddressForMdl(pFrame->pMessageMdl);
                TRACEDUMP(("Sending msg type %x (%d bytes):\n",
                            pFrame->NdisMessageType, Length), pBuf, Length);
            }
#endif

            //
            // Does this go on the data or control channel of the microport?
            //
            if (pFrame->NdisMessageType == REMOTE_NDIS_PACKET_MSG)
            {
                ChannelType = RMC_DATA;
            }
            else
            {
                ChannelType = RMC_CONTROL;
            }

            (pAdapter)->RmSendMessageHandler(pAdapter->MicroportAdapterContext,
                                             pFrame->pMessageMdl,
                                             (NDIS_HANDLE)pFrame,
                                             ChannelType);

            RNDISMP_ACQUIRE_ADAPTER_LOCK(pAdapter);
        }

        pAdapter->SendInProgress = FALSE;

    }
    while (FALSE);

    RNDISMP_RELEASE_ADAPTER_LOCK(pAdapter);
}


/****************************************************************************/
/*                          FlushPendingMessages                            */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Remove and send-complete any messages pending to be sent to the         */
/*  microport.                                                              */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter  - our Adapter structure                                       */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
FlushPendingMessages(IN  PRNDISMP_ADAPTER        pAdapter)
{
    PLIST_ENTRY             pEnt;
    PRNDISMP_MESSAGE_FRAME  pFrame;

    RNDISMP_ACQUIRE_ADAPTER_LOCK(pAdapter);

    //
    //  Prevent further sends to microport.
    //
    pAdapter->SendInProgress = TRUE;

    while (!IsListEmpty(&pAdapter->WaitingMessageList))
    {
        //
        //  Take out the first message in the waiting queue.
        //
        pEnt = pAdapter->WaitingMessageList.Flink;
        pFrame = CONTAINING_RECORD(pEnt, RNDISMP_MESSAGE_FRAME, PendLink);
        RemoveEntryList(pEnt);
        
        CHECK_VALID_FRAME(pFrame);

        //
        //  Fake send to microport
        //
        pAdapter->CurPendedMessages++;
        InsertTailList(&pAdapter->PendingAtMicroportList, pEnt);

        RNDISMP_RELEASE_ADAPTER_LOCK(pAdapter);

        TRACE1(("Flush: Adapter %x, MsgFrame %x, MsgType %x\n",
                pAdapter, pFrame, pFrame->NdisMessageType));

        //
        //  Complete it right here.
        //
        RndisMSendComplete(
            (NDIS_HANDLE)pAdapter,
            pFrame,
            NDIS_STATUS_NOT_ACCEPTED);

        RNDISMP_ACQUIRE_ADAPTER_LOCK(pAdapter);
    }

    pAdapter->SendInProgress = FALSE;

    RNDISMP_RELEASE_ADAPTER_LOCK(pAdapter);

    TRACE1(("Flush done, adapter %x\n", pAdapter));
}



#endif // THROTTLE_MESSAGES



/****************************************************************************/
/*                       SendProcessTimeout                                 */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Timeout callback routine to handle all sends. This is to avoid issues   */
/*  with TCP/IP stack preemption on WinME.                                  */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  SystemSpecific[1-3] - Ignored                                           */
/*  Context - Pointer to our Adapter structure                              */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
SendProcessTimeout(IN PVOID SystemSpecific1,
                 IN PVOID Context,
                 IN PVOID SystemSpecific2,
                 IN PVOID SystemSpecific3)
{
    PRNDISMP_ADAPTER                pAdapter;
    PNDIS_PACKET                    pNdisPacket;
    PRNDISMP_SEND_PKT_RESERVED_TEMP pSendResvdTemp;
    PLIST_ENTRY                     pEntry;
    NDIS_STATUS                     Status;
    ULONG                           NumPkts;
    ULONG                           CurPkts;
#define MAX_MULTI_SEND  20
    PNDIS_PACKET                    PacketArray[MAX_MULTI_SEND];

    pAdapter = (PRNDISMP_ADAPTER)Context;
    CHECK_VALID_ADAPTER(pAdapter);

    ASSERT(pAdapter->SendProcessInProgress == TRUE);

    SndTimerCount++;

    NumPkts = 0;
    CurPkts = 0;

    RNDISMP_ACQUIRE_ADAPTER_LOCK(pAdapter);

    while (!IsListEmpty(&pAdapter->PendingSendProcessList))
    {
        pEntry = RemoveHeadList(&pAdapter->PendingSendProcessList);

        RNDISMP_RELEASE_ADAPTER_LOCK(pAdapter);

        SndPacketCount++;
        CurPkts++;

        pSendResvdTemp = CONTAINING_RECORD(pEntry, RNDISMP_SEND_PKT_RESERVED_TEMP, Link);
        pNdisPacket = CONTAINING_RECORD(pSendResvdTemp, NDIS_PACKET, MiniportReserved);
        PacketArray[NumPkts] = pNdisPacket;

        NumPkts++;

        if (NumPkts == MAX_MULTI_SEND)
        {
            pAdapter->MultipleSendFunc(pAdapter, NULL, PacketArray, NumPkts);
            NumPkts = 0;
        }

        RNDISMP_ACQUIRE_ADAPTER_LOCK(pAdapter);
    }

    pAdapter->SendProcessInProgress = FALSE;

    SndMaxPackets = MAX(SndMaxPackets, CurPkts);

    RNDISMP_RELEASE_ADAPTER_LOCK(pAdapter);

    if (NumPkts != 0)
    {
        pAdapter->MultipleSendFunc(pAdapter, NULL, PacketArray, NumPkts);
    }


} // SendProcessTimeout
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rndis\rndismp\sys\makefile.inc ===
clean: 
    del $(O)\rmdat.h $(O)\rndismp.bmf

$(O)\rndismp.mof: ..\rndismp.mof

$(O)\rmdat.h: $(O)\rndismp.bmf
    wmimofck -h$(O)\rmdat.h $(O)\rndismp.bmf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rndis\rndismp\win9x\makefile.inc ===
clean: 
    del $(O)\rmdat.h $(O)\rndismp.bmf

$(O)\rndismp.mof: ..\rndismp.mof

$(O)\rmdat.h: $(O)\rndismp.bmf
    wmimofck -h$(O)\rmdat.h $(O)\rndismp.bmf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rndis\rndismp\request.c ===
/***************************************************************************

Copyright (c) 1999  Microsoft Corporation

Module Name:

    REQUEST.C

Abstract:

    Handles set and query requests

Environment:

    kernel mode only

Notes:

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

    Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    5/13/99 : created

Author:

    Tom Green

    
****************************************************************************/

#include "precomp.h"


#ifdef TESTING
extern PUCHAR   pOffloadBuffer;
extern ULONG    OffloadSize;
#endif

// supported OID list
NDIS_OID RndismpSupportedOids[] = 
{
    OID_GEN_SUPPORTED_LIST,
    OID_GEN_MEDIA_IN_USE,
    OID_GEN_MAXIMUM_LOOKAHEAD,
    OID_GEN_MAXIMUM_TOTAL_SIZE,
    OID_GEN_PROTOCOL_OPTIONS,
    OID_GEN_TRANSMIT_BUFFER_SPACE,
    OID_GEN_RECEIVE_BUFFER_SPACE,
    OID_GEN_TRANSMIT_BLOCK_SIZE,
    OID_GEN_RECEIVE_BLOCK_SIZE,
    OID_GEN_VENDOR_DESCRIPTION,
    OID_GEN_DRIVER_VERSION,
    OID_GEN_VENDOR_ID,
    OID_GEN_VENDOR_DRIVER_VERSION,
    OID_GEN_CURRENT_LOOKAHEAD,
    OID_GEN_MAXIMUM_SEND_PACKETS,
    OID_GEN_XMIT_OK,
    OID_GEN_RCV_OK,
    OID_GEN_XMIT_ERROR,
    OID_GEN_RCV_ERROR,
    OID_GEN_RCV_NO_BUFFER,
    OID_GEN_MAC_OPTIONS,
    OID_RNDISMP_STATISTICS,
#ifdef TESTING
    OID_TCP_TASK_OFFLOAD,
    OID_GEN_TRANSPORT_HEADER_OFFSET,
    OID_GEN_PHYSICAL_MEDIUM,
#endif
    OID_GEN_SUPPORTED_GUIDS
};

UINT RndismpSupportedOidsNum = sizeof(RndismpSupportedOids) / sizeof(NDIS_OID);

#ifdef BINARY_MOF_TEST

UCHAR RndismpBinaryMof[] = { 
    0x46, 0x4f, 0x4d, 0x42, 0x01, 0x00, 0x00, 0x00, 0x45, 0x02, 0x00, 0x00, 0xbc, 0x04, 0x00, 0x00,
    0x44, 0x53, 0x00, 0x01, 0x1a, 0x7d, 0xda, 0x54, 0x18, 0x44, 0x82, 0x00, 0x01, 0x06, 0x18, 0x42,
    0x20, 0xe4, 0x03, 0x89, 0xc0, 0x61, 0x68, 0x24, 0x18, 0x06, 0xe5, 0x01, 0x44, 0x6a, 0x20, 0xe4,
    0x82, 0x89, 0x09, 0x10, 0x01, 0x21, 0xaf, 0x02, 0x6c, 0x0a, 0x30, 0x09, 0xa2, 0xfe, 0xfd, 0x15,
    0xa1, 0xa1, 0x84, 0x40, 0x48, 0xa2, 0x00, 0xf3, 0x02, 0x74, 0x0b, 0x30, 0x2c, 0xc0, 0xb6, 0x00,
    0xd3, 0x02, 0x1c, 0x23, 0x12, 0x65, 0xd0, 0x94, 0xc0, 0x4a, 0x20, 0x24, 0x54, 0x80, 0x72, 0x01,
    0xbe, 0x05, 0x68, 0x07, 0x94, 0x64, 0x01, 0x96, 0x61, 0x34, 0x07, 0x0e, 0xc6, 0x09, 0x8a, 0x46,
    0x46, 0xa9, 0x80, 0x90, 0x67, 0x01, 0xd6, 0x71, 0x09, 0x41, 0xf7, 0x02, 0xa4, 0x09, 0x70, 0x26,
    0xc0, 0xdb, 0x34, 0xa4, 0x59, 0xc0, 0x30, 0x22, 0xd8, 0x16, 0x8e, 0x30, 0xe2, 0x9c, 0x42, 0x94,
    0xc6, 0x10, 0x84, 0x19, 0x31, 0x4a, 0x73, 0x58, 0x82, 0x8a, 0x11, 0xa5, 0x30, 0x04, 0x01, 0x86,
    0x88, 0x55, 0x9c, 0x00, 0x6b, 0x58, 0x42, 0x39, 0x80, 0x13, 0xb0, 0xfd, 0x39, 0x48, 0x13, 0x84,
    0x1c, 0x4c, 0x0b, 0x25, 0x7b, 0x40, 0x9a, 0xc6, 0xf1, 0x05, 0x39, 0x87, 0x83, 0x61, 0x26, 0x86,
    0x2c, 0x55, 0x98, 0x28, 0x2d, 0x73, 0x23, 0xe3, 0xb4, 0x45, 0x01, 0xe2, 0x05, 0x08, 0x07, 0xd5,
    0x58, 0x3b, 0xc7, 0xd0, 0x05, 0x80, 0xa9, 0x1e, 0x1e, 0x4a, 0xcc, 0x98, 0x09, 0x5a, 0xbc, 0x93,
    0x38, 0xcc, 0xc0, 0x61, 0x4b, 0xc7, 0xd0, 0x40, 0x02, 0x27, 0x68, 0x10, 0x49, 0x8a, 0x71, 0x84,
    0x14, 0xe4, 0x5c, 0x42, 0x9c, 0x7c, 0x41, 0x02, 0x94, 0x0a, 0xd0, 0x09, 0xac, 0x19, 0x77, 0x3a,
    0x66, 0x4d, 0x39, 0x50, 0x78, 0x8f, 0xdc, 0xf8, 0x41, 0xe2, 0xf4, 0x09, 0xac, 0x79, 0x44, 0x89,
    0x13, 0xba, 0xa9, 0x09, 0x28, 0xa4, 0x02, 0x88, 0x16, 0x40, 0x94, 0x66, 0x32, 0xa8, 0xab, 0x40,
    0x82, 0x47, 0x03, 0x8f, 0xe0, 0xa8, 0x0c, 0x7a, 0x1a, 0x41, 0xe2, 0x7b, 0x18, 0xef, 0x04, 0x1e,
    0x99, 0x87, 0x79, 0x8a, 0x0c, 0xf3, 0xff, 0xff, 0x8e, 0x80, 0x75, 0x8d, 0xa7, 0x11, 0x9d, 0x80,
    0xe5, 0xa0, 0xa1, 0xae, 0x03, 0x1e, 0x57, 0xb4, 0xf8, 0xa7, 0x6c, 0xb8, 0xba, 0xc6, 0x82, 0xba,
    0x2a, 0xd8, 0xe1, 0x54, 0x34, 0xb6, 0x52, 0x05, 0x98, 0x1d, 0x9c, 0xe6, 0x9c, 0xe0, 0x68, 0x3c,
    0x55, 0xcf, 0xe6, 0xe1, 0x20, 0xc1, 0x23, 0x82, 0xa7, 0xc0, 0xa7, 0x65, 0x1d, 0xc3, 0x25, 0x03,
    0x34, 0x62, 0xb8, 0x73, 0x32, 0x7a, 0x82, 0x3b, 0x94, 0x80, 0xd1, 0xc0, 0xbd, 0x1b, 0x1c, 0x0d,
    0xec, 0x59, 0xbf, 0x04, 0x44, 0x78, 0x38, 0xf0, 0x5c, 0x3d, 0x06, 0xfd, 0x08, 0xe4, 0x64, 0x36,
    0x28, 0x3d, 0x37, 0x02, 0x7a, 0x05, 0xe0, 0x27, 0x09, 0x76, 0x3c, 0x30, 0xc8, 0x29, 0x1d, 0xad,
    0x53, 0x43, 0xe8, 0xad, 0xe1, 0x19, 0xc1, 0x05, 0x7e, 0x4c, 0x00, 0xcb, 0xe9, 0x00, 0x3b, 0x16,
    0x3c, 0x52, 0xe3, 0x47, 0x0c, 0xe1, 0x18, 0x31, 0xc6, 0x69, 0x04, 0x0a, 0xeb, 0x91, 0x04, 0xa9,
    0x70, 0xf6, 0x64, 0x98, 0x6f, 0x0a, 0x35, 0x0a, 0xb8, 0x09, 0x58, 0xd4, 0x65, 0x02, 0x25, 0xe5,
    0x32, 0x81, 0x98, 0x47, 0xd8, 0xb7, 0x04, 0x4f, 0xf8, 0xac, 0x7c, 0x98, 0xf0, 0xa5, 0x00, 0xfe,
    0xed, 0xc3, 0xc3, 0x08, 0xfd, 0xb0, 0xf1, 0x44, 0xe2, 0x23, 0x43, 0x5c, 0xcc, 0xff, 0x1f, 0xd7,
    0x03, 0xb7, 0x5f, 0x01, 0x08, 0xb1, 0xcb, 0xbc, 0x16, 0xe8, 0x38, 0x11, 0x21, 0xc1, 0x1b, 0x05,
    0x16, 0xe3, 0x60, 0x3c, 0x50, 0x9f, 0x13, 0x3c, 0x4c, 0x83, 0x1c, 0x59, 0xbc, 0x88, 0x09, 0x4e,
    0xed, 0xa8, 0xb1, 0x73, 0xe0, 0x03, 0x38, 0x86, 0xf0, 0xe7, 0x13, 0xfe, 0x00, 0xa2, 0x1c, 0xc7,
    0x21, 0x79, 0xc8, 0x46, 0x38, 0x81, 0x72, 0x2f, 0x2b, 0xe4, 0x58, 0x72, 0x14, 0xa7, 0xf5, 0x74,
    0x10, 0xe8, 0x04, 0x30, 0x0a, 0x6d, 0xfa, 0xd4, 0x68, 0xd4, 0xaa, 0x41, 0x99, 0x1a, 0x65, 0x1a,
    0xd4, 0xea, 0x53, 0xa9, 0x31, 0x63, 0xf3, 0xb5, 0xb4, 0x77, 0x83, 0x40, 0x1c, 0x0a, 0x84, 0x66,
    0xa4, 0x10, 0x88, 0xff, 0xff};

ULONG  RndismpBinaryMofSize = sizeof(RndismpBinaryMof);

#define RNDISMPDeviceOIDGuid \
    { 0x437cf222,0x72fe,0x11d4, { 0x97,0xf9,0x00,0x20,0x48,0x57,0x03,0x37}}

#endif // BINARY_MOF_TEST

NDIS_GUID CustomGuidList[] =
{
    {
            RNDISMPStatisticsOIDGuid,
            OID_RNDISMP_STATISTICS,
            sizeof(UINT32), // size is size of each element in the array
            (fNDIS_GUID_TO_OID|fNDIS_GUID_ARRAY)
    }
#ifdef BINARY_MOF_TEST
,
    {
            RNDISMPDeviceOIDGuid,
            OID_RNDISMP_DEVICE_OID,
            sizeof(UINT32),
            fNDIS_GUID_TO_OID
    },
    {
            BINARY_MOF_GUID,
            OID_RNDISMP_GET_MOF_OID,
            sizeof(UINT8),
            (fNDIS_GUID_TO_OID|fNDIS_GUID_ARRAY)
    }
#endif
};

UINT CustomGuidCount = sizeof(CustomGuidList)/sizeof(NDIS_GUID);

/****************************************************************************/
/*                          RndismpQueryInformation                         */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*    NDIS Entry point called to handle a query for a particular OID.       */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*    MiniportAdapterContext - a context version of our Adapter pointer     */
/*    Oid - the NDIS_OID to process.                                        */
/*    InformationBuffer - a pointer into the NdisRequest->InformationBuffer */
/*     into which store the result of the query.                            */
/*    InformationBufferLength - a pointer to the number of bytes left in    */
/*     the InformationBuffer.                                               */
/*    pBytesWritten - a pointer to the number of bytes written into the     */
/*     InformationBuffer.                                                   */
/*    pBytesNeeded - If there is not enough room in the information buffer  */
/*     then this will contain the number of bytes needed to complete the    */
/*     request.                                                             */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    NDIS_STATUS                                                           */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
RndismpQueryInformation(IN  NDIS_HANDLE MiniportAdapterContext,
                        IN  NDIS_OID    Oid,
                        IN  PVOID       InformationBuffer,
                        IN  ULONG       InformationBufferLength,
                        OUT PULONG      pBytesWritten,
                        OUT PULONG      pBytesNeeded)
{
    PRNDISMP_ADAPTER    pAdapter;
    NDIS_STATUS         Status;

    // get adapter context
    pAdapter = PRNDISMP_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

    CHECK_VALID_ADAPTER(pAdapter);

    TRACE3(("RndismpQueryInformation\n"));

    Status = ProcessQueryInformation(pAdapter,
                                     NULL,
                                     NULL,
                                     Oid,
                                     InformationBuffer,
                                     InformationBufferLength,
                                     pBytesWritten,
                                     pBytesNeeded);
    return Status;
}


/****************************************************************************/
/*                          ProcessQueryInformation                         */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*    Utility routine to process a Query (connection-less or connection-    */
/*    oriented).                                                            */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*    pAdapter - Pointer to our adapter structure                           */
/*    pVc - Pointer to a VC, possibly NULL.                                 */
/*    pRequest - Pointer to NDIS request, if this came via our CoRequest    */
/*          handler.                                                        */
/*    Oid - the NDIS_OID to process.                                        */
/*    InformationBuffer - a pointer into the NdisRequest->InformationBuffer */
/*     into which store the result of the query.                            */
/*    InformationBufferLength - a pointer to the number of bytes left in    */
/*     the InformationBuffer.                                               */
/*    pBytesWritten - a pointer to the number of bytes written into the     */
/*     InformationBuffer.                                                   */
/*    pBytesNeeded - If there is not enough room in the information buffer  */
/*     then this will contain the number of bytes needed to complete the    */
/*     request.                                                             */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    NDIS_STATUS                                                           */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
ProcessQueryInformation(IN  PRNDISMP_ADAPTER    pAdapter,
                        IN  PRNDISMP_VC         pVc,
                        IN  PNDIS_REQUEST       pRequest,
                        IN  NDIS_OID            Oid,
                        IN  PVOID               InformationBuffer,
                        IN  ULONG               InformationBufferLength,
                        OUT PULONG              pBytesWritten,
                        OUT PULONG              pBytesNeeded)
{
    NDIS_STATUS         Status;
    UINT                OIDHandler;

    OIDHandler = GetOIDSupport(pAdapter, Oid);
    
    switch(OIDHandler)
    {
        case DRIVER_SUPPORTED_OID:
            Status = DriverQueryInformation(pAdapter,
                                            pVc,
                                            pRequest,
                                            Oid,
                                            InformationBuffer,
                                            InformationBufferLength,
                                            pBytesWritten,
                                            pBytesNeeded);
            break;
        case DEVICE_SUPPORTED_OID:
            Status = DeviceQueryInformation(pAdapter,
                                            pVc,
                                            pRequest,
                                            Oid,
                                            InformationBuffer,
                                            InformationBufferLength,
                                            pBytesWritten,
                                            pBytesNeeded);
            break;
        case OID_NOT_SUPPORTED:
        default:
            TRACE2(("Invalid Query OID (%08X)\n", Oid));
            Status = NDIS_STATUS_INVALID_OID;
            break;
    }

    TRACE2(("ProcessQueryInfo: Oid %08X, returning Status %x\n", Oid, Status));

    return Status;
} // ProcessQueryInformation

    
/****************************************************************************/
/*                          RndismpSetInformation                           */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*    The RndismpSetInformation processes a Set request for                 */
/*    NDIS_OIDs that are specific about the Driver.                         */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*    MiniportAdapterContext - a context version of our Adapter pointer     */
/*    Oid - the NDIS_OID to process.                                        */
/*    InformationBuffer - Holds the data to be set.                         */
/*    InformationBufferLength - The length of InformationBuffer.            */
/*    pBytesRead - If the call is successful, returns the number            */
/*        of bytes read from InformationBuffer.                             */
/*    pBytesNeeded - If there is not enough data in InformationBuffer       */
/*        to satisfy the OID, returns the amount of storage needed.         */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    NDIS_STATUS                                                           */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
RndismpSetInformation(IN  NDIS_HANDLE   MiniportAdapterContext,
                      IN  NDIS_OID      Oid,
                      IN  PVOID         InformationBuffer,
                      IN  ULONG         InformationBufferLength,
                      OUT PULONG        pBytesRead,
                      OUT PULONG        pBytesNeeded)
{
    PRNDISMP_ADAPTER    pAdapter;
    NDIS_STATUS         Status;

    // get adapter context
    pAdapter = PRNDISMP_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

    CHECK_VALID_ADAPTER(pAdapter);

    TRACE3(("RndismpSetInformation\n"));

    Status = ProcessSetInformation(pAdapter,
                                   NULL,
                                   NULL,
                                   Oid,
                                   InformationBuffer,
                                   InformationBufferLength,
                                   pBytesRead,
                                   pBytesNeeded);
    return Status;
}


/****************************************************************************/
/*                          ProcessSetInformation                           */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*    Utility routine to process a Set (connection-less or connection-      */
/*    oriented).                                                            */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*    pAdapter - Pointer to our adapter structure                           */
/*    pVc - Pointer to a VC, possibly NULL.                                 */
/*    pRequest - Pointer to NDIS request, if this came via our CoRequest    */
/*          handler.                                                        */
/*    Oid - the NDIS_OID to process.                                        */
/*    InformationBuffer - a pointer into the NdisRequest->InformationBuffer */
/*     into which store the result of the query.                            */
/*    InformationBufferLength - a pointer to the number of bytes left in    */
/*     the InformationBuffer.                                               */
/*    pBytesRead - a pointer to the number of bytes read from the           */
/*     InformationBuffer.                                                   */
/*    pBytesNeeded - If there is not enough room in the information buffer  */
/*     then this will contain the number of bytes needed to complete the    */
/*     request.                                                             */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    NDIS_STATUS                                                           */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
ProcessSetInformation(IN  PRNDISMP_ADAPTER    pAdapter,
                      IN  PRNDISMP_VC         pVc OPTIONAL,
                      IN  PNDIS_REQUEST       pRequest OPTIONAL,
                      IN  NDIS_OID            Oid,
                      IN  PVOID               InformationBuffer,
                      IN  ULONG               InformationBufferLength,
                      OUT PULONG              pBytesRead,
                      OUT PULONG              pBytesNeeded)
{
    NDIS_STATUS         Status;
    UINT                OIDHandler;

    OIDHandler = GetOIDSupport(pAdapter, Oid);
    
    switch(OIDHandler)
    {
        case DRIVER_SUPPORTED_OID:
            Status = DriverSetInformation(pAdapter,
                                          pVc,
                                          pRequest,
                                          Oid,
                                          InformationBuffer,
                                          InformationBufferLength,
                                          pBytesRead,
                                          pBytesNeeded);
            break;

        case DEVICE_SUPPORTED_OID:
            Status = DeviceSetInformation(pAdapter,
                                          pVc,
                                          pRequest,
                                          Oid,
                                          InformationBuffer,
                                          InformationBufferLength,
                                          pBytesRead,
                                          pBytesNeeded);
            break;

        case OID_NOT_SUPPORTED:
        default:
            TRACE1(("Invalid Set OID (%08X), Adapter %p\n", Oid, pAdapter));
            Status = NDIS_STATUS_INVALID_OID;
            break;
    }

    return Status;
} // ProcessSetInformation

/****************************************************************************/
/*                          DriverQueryInformation                          */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*    The RndismpQueryInformation processes a Query request for             */
/*    NDIS_OIDs that are specific about the Driver. This routine            */
/*    Handles OIDs supported by the driver instead of the device            */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*    pAdapter - Pointer to our adapter structure                           */
/*    pVc - Pointer to a VC, possibly NULL.                                 */
/*    pRequest - Pointer to NDIS request, if this came via our CoRequest    */
/*          handler.                                                        */
/*    Oid - the NDIS_OID to process.                                        */
/*    InformationBuffer - a pointer into the NdisRequest->InformationBuffer */
/*     into which store the result of the query.                            */
/*    InformationBufferLength - a pointer to the number of bytes left in    */
/*     the InformationBuffer.                                               */
/*    pBytesWritten - a pointer to the number of bytes written into the     */
/*     InformationBuffer.                                                   */
/*    pBytesNeeded - If there is not enough room in the information buffer  */
/*     then this will contain the number of bytes needed to complete the    */
/*     request.                                                             */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    NDIS_STATUS                                                           */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
DriverQueryInformation(IN  PRNDISMP_ADAPTER pAdapter,
                       IN  PRNDISMP_VC      pVc OPTIONAL,
                       IN  PNDIS_REQUEST    pRequest OPTIONAL,
                       IN  NDIS_OID         Oid,
                       IN  PVOID            InformationBuffer,
                       IN  ULONG            InformationBufferLength,
                       OUT PULONG           pBytesWritten,
                       OUT PULONG           pBytesNeeded)
{
    NDIS_STATUS         Status;
    PVOID               MoveSource;
    UINT                MoveBytes;
    ULONG               GenericUlong;
    USHORT              GenericUshort;
    CHAR                VendorDescription[] = "Remote NDIS Network Card";

    TRACE3(("DriverQueryInformation\n"));
    OID_NAME_TRACE(Oid, "DriverQuery");

    Status      = NDIS_STATUS_SUCCESS;
    MoveSource  = (PVOID) (&GenericUlong);
    MoveBytes   = sizeof(GenericUlong);

    // this is one we have to handle
    switch(Oid)
    {
        case OID_GEN_DRIVER_VERSION:
            GenericUshort = (pAdapter->DriverBlock->MajorNdisVersion << 8) +
                            (pAdapter->DriverBlock->MinorNdisVersion);

            MoveSource = (PVOID)&GenericUshort;
            MoveBytes = sizeof(GenericUshort);
            break;

        case OID_GEN_VENDOR_ID:
            TRACE1(("Query for OID_GEN_VENDOR_ID not supported by device!\n"));
            GenericUlong = 0xFFFFFF;
            break;

        case OID_GEN_VENDOR_DESCRIPTION:
            TRACE1(("Query for OID_GEN_VENDOR_DESCRIPTION not supported by device!\n"));
            if (pAdapter->FriendlyNameAnsi.Length != 0)
            {
                MoveSource = pAdapter->FriendlyNameAnsi.Buffer;
                MoveBytes = pAdapter->FriendlyNameAnsi.Length;
            }
            else
            {
                MoveSource = VendorDescription;
                MoveBytes = sizeof(VendorDescription);
            }
            break;
        
        case OID_GEN_VENDOR_DRIVER_VERSION:
            TRACE1(("Query for OID_GEN_VENDOR_DRIVER_VERSION not supported by device!\n"));
            GenericUlong = 0xA000B;
            break;

        case OID_GEN_MAC_OPTIONS:
            GenericUlong = pAdapter->MacOptions;
            break;

        case OID_GEN_SUPPORTED_LIST:
            // get the list we generated
            MoveSource  = (PVOID) (pAdapter->SupportedOIDList);
            MoveBytes   = pAdapter->SupportedOIDListSize;
            break;

        case OID_GEN_MEDIA_IN_USE:
            Status = DeviceQueryInformation(pAdapter,
                                            pVc,
                                            pRequest,
                                            OID_GEN_MEDIA_SUPPORTED,
                                            InformationBuffer,
                                            InformationBufferLength,
                                            pBytesWritten,
                                            pBytesNeeded);                                        
            break;

        case OID_GEN_MAXIMUM_LOOKAHEAD:
            Status = DeviceQueryInformation(pAdapter,
                                            pVc,
                                            pRequest,
                                            OID_GEN_MAXIMUM_FRAME_SIZE,
                                            InformationBuffer,
                                            InformationBufferLength,
                                            pBytesWritten,
                                            pBytesNeeded);

            break;

        case OID_GEN_TRANSMIT_BUFFER_SPACE:
            GenericUlong = pAdapter->MaxTransferSize;
            break;

        case OID_GEN_RECEIVE_BUFFER_SPACE:
            GenericUlong = pAdapter->MaxReceiveSize * 8;
            break;

        case OID_GEN_CURRENT_LOOKAHEAD:
            Status = DeviceQueryInformation(pAdapter,
                                            pVc,
                                            pRequest,
                                            OID_GEN_MAXIMUM_FRAME_SIZE,
                                            InformationBuffer,
                                            InformationBufferLength,
                                            pBytesWritten,
                                            pBytesNeeded);

            break;

        case OID_GEN_MAXIMUM_FRAME_SIZE:
            Status = DeviceQueryInformation(pAdapter,
                                            pVc,
                                            pRequest,
                                            OID_GEN_MAXIMUM_FRAME_SIZE,
                                            InformationBuffer,
                                            InformationBufferLength,
                                            pBytesWritten,
                                            pBytesNeeded);

            break;

        case OID_GEN_MAXIMUM_TOTAL_SIZE:
        	TRACE1(("Query for OID_GEN_MAXIMUM_TOTAL_SIZE not supported by device!\n"));
            GenericUlong = (ULONG) MAXIMUM_ETHERNET_PACKET_SIZE;
            break;

        case OID_GEN_TRANSMIT_BLOCK_SIZE:
        	TRACE1(("Query for OID_GEN_TRANSMIT_BLOCK_SIZE not supported by device!\n"));
            GenericUlong = (ULONG) MAXIMUM_ETHERNET_PACKET_SIZE;
            break;

        case OID_GEN_RECEIVE_BLOCK_SIZE:
        	TRACE1(("Query for OID_GEN_RECEIVE_BLOCK_SIZE not supported by device!\n"));
            GenericUlong = (ULONG) MAXIMUM_ETHERNET_PACKET_SIZE;
            break;

        case OID_GEN_MAXIMUM_SEND_PACKETS:
            GenericUlong = (ULONG) pAdapter->MaxPacketsPerMessage;
            break;

        case OID_PNP_CAPABILITIES:
        case OID_PNP_QUERY_POWER:
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;

        case OID_GEN_XMIT_OK:
            GenericUlong = RNDISMP_GET_ADAPTER_STATS(pAdapter, XmitOk);
            break;
        
        case OID_GEN_XMIT_ERROR:
            GenericUlong = RNDISMP_GET_ADAPTER_STATS(pAdapter, XmitError);
            break;
        
        case OID_GEN_RCV_OK:
            GenericUlong = RNDISMP_GET_ADAPTER_STATS(pAdapter, RecvOk);
            break;
        
        case OID_GEN_RCV_ERROR:
            GenericUlong = RNDISMP_GET_ADAPTER_STATS(pAdapter, RecvError);
            break;
        
        case OID_GEN_RCV_NO_BUFFER:
            GenericUlong = RNDISMP_GET_ADAPTER_STATS(pAdapter, RecvNoBuf);
            break;
        
        case OID_GEN_SUPPORTED_GUIDS:
            MoveSource = (PVOID)&CustomGuidList[0];
            MoveBytes = sizeof(CustomGuidList);
            TRACE1(("Query for supported GUIDs, len %d\n", InformationBufferLength));
            break;

        case OID_RNDISMP_STATISTICS:
            MoveSource = &pAdapter->Statistics;
            MoveBytes = sizeof(pAdapter->Statistics);
            break;

#ifdef BINARY_MOF_TEST

        case OID_RNDISMP_DEVICE_OID:
            DbgPrint("*** RNDISMP: Query for Device OID\n");
            GenericUlong = 0xabcdefab;
            break;

        case OID_RNDISMP_GET_MOF_OID:
            DbgPrint("*** RNDISMP: Query for MOF Info: Src %p, Size %d\n",
                RndismpBinaryMof, RndismpBinaryMofSize);
            MoveSource = RndismpBinaryMof;
            MoveBytes = RndismpBinaryMofSize;
            break;

#endif // BINARY_MOF_TEST

#ifdef TESTING
        case OID_TCP_TASK_OFFLOAD:
        	DbgPrint("RNDISMP: got query for TCP offload\n");
        	MoveSource = pOffloadBuffer;
        	MoveBytes = OffloadSize;
        	break;
		case OID_GEN_PHYSICAL_MEDIUM:
			DbgPrint("RNDISMP: got query for physical medium\n");
			GenericUlong = NdisPhysicalMediumDSL;
			break;
#endif

        default:
            Status = NDIS_STATUS_INVALID_OID;
            break;
    }

    // copy stuff to information buffer
    if (Status == NDIS_STATUS_SUCCESS)
    {
        if (MoveBytes > InformationBufferLength)
        {
            // Not enough room in InformationBuffer
            *pBytesNeeded = MoveBytes;

            Status = NDIS_STATUS_BUFFER_TOO_SHORT;
        }
        else
        {
            // Copy result into InformationBuffer
            *pBytesWritten = MoveBytes;

            if (MoveBytes > 0)
                RNDISMP_MOVE_MEM(InformationBuffer, MoveSource, MoveBytes);
        }
    }

    TRACE2(("Status (%08X)  BytesWritten (%08X)\n", Status, *pBytesWritten));

    return Status;
} // DriverQueryInformation

/****************************************************************************/
/*                          DeviceQueryInformation                          */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*    The DeviceQueryInformation processes a Query request                  */
/*    that is going to the Remote NDIS device                               */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*    pAdapter - pointer to our Adapter structure                           */
/*    pVc - optional pointer to our VC structure, if this is a per-Vc req.  */
/*    pRequest - optional pointer to NDIS request, if CONDIS.               */
/*    Oid - the NDIS_OID to process.                                        */
/*    InformationBuffer - a pointer into the NdisRequest->InformationBuffer */
/*     into which store the result of the query.                            */
/*    InformationBufferLength - a pointer to the number of bytes left in    */
/*     the InformationBuffer.                                               */
/*    pBytesWritten - a pointer to the number of bytes written into the     */
/*     InformationBuffer.                                                   */
/*    pBytesNeeded - If there is not enough room in the information buffer  */
/*     then this will contain the number of bytes needed to complete the    */
/*     request.                                                             */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    NDIS_STATUS                                                           */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
DeviceQueryInformation(IN  PRNDISMP_ADAPTER pAdapter,
                       IN  PRNDISMP_VC      pVc OPTIONAL,
                       IN  PNDIS_REQUEST    pRequest OPTIONAL,
                       IN  NDIS_OID         Oid,
                       IN  PVOID            InformationBuffer,
                       IN  ULONG            InformationBufferLength,
                       OUT PULONG           pBytesWritten,
                       OUT PULONG           pBytesNeeded)
{
    PRNDISMP_MESSAGE_FRAME      pMsgFrame;
    PRNDISMP_REQUEST_CONTEXT    pReqContext;
    NDIS_STATUS                 Status;

    TRACE3(("DeviceQueryInformation\n"));

    OID_NAME_TRACE(Oid, "DeviceQuery");
    TRACE3(("DeviceQuery: InfoBuf %p, Len %d, pBytesWrit %p, pBytesNeed %p\n",
        InformationBuffer, InformationBufferLength, pBytesWritten, pBytesNeeded));

    do
    {
        if (pAdapter->Halting)
        {
            Status = NDIS_STATUS_NOT_ACCEPTED;
            break;
        }

        pReqContext = AllocateRequestContext(pAdapter);
        if (pReqContext == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        //
        // HACKHACK to avoid a strange length from going to the device
        // At least one device does not like this.
        //
        // In general, there is no point sending a huge information buffer
        // along with a Query that does not require an IN parameter.
        // Long term, we may have to separate out the few OIDs that do
        // use IN parameters and allow those buffers to pass through
        //

        pMsgFrame = BuildRndisMessageCommon(pAdapter, 
                                            pVc,
                                            REMOTE_NDIS_QUERY_MSG,
                                            Oid,
                                            InformationBuffer,
                                            ((InformationBufferLength > 48)?
                                               48: InformationBufferLength));

        // see if we got a message
        if (!pMsgFrame)
        {
            Status = NDIS_STATUS_RESOURCES;
            FreeRequestContext(pAdapter, pReqContext);
            break;
        }

        Status = NDIS_STATUS_PENDING;

        pReqContext->InformationBuffer = InformationBuffer;
        pReqContext->InformationBufferLength = InformationBufferLength;
        pReqContext->pBytesRead = NULL;
        pReqContext->pBytesWritten = pBytesWritten;
        pReqContext->pBytesNeeded = pBytesNeeded;
        pReqContext->Oid = Oid;
        pReqContext->RetryCount = 0;
        pReqContext->bInternal = FALSE;
        pReqContext->pVc = pVc;
        pReqContext->pNdisRequest = pRequest;

        pMsgFrame->pReqContext = pReqContext;

        // Add a ref to keep the frame around until we complete the request.
        ReferenceMsgFrame(pMsgFrame);

        // send the message to the microport
        RNDISMP_SEND_TO_MICROPORT(pAdapter, pMsgFrame, TRUE, CompleteSendDeviceRequest);

        break;
    }
    while (FALSE);

    return Status;

} // DeviceQueryInformation

/****************************************************************************/
/*                          DriverSetInformation                            */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*    Utility routine to handle SetInformation requests that aren't         */
/*    specific to the device. We also land up here for requests for any     */
/*    OIDs that aren't supported by the device.                             */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*    pAdapter - Pointer to our adapter structure                           */
/*    pVc - Pointer to a VC, possibly NULL.                                 */
/*    pRequest - Pointer to NDIS request, if this came via our CoRequest    */
/*          handler.                                                        */
/*    Oid - the NDIS_OID to process.                                        */
/*    InformationBuffer - Holds the data to be set.                         */
/*    InformationBufferLength - The length of InformationBuffer.            */
/*    pBytesRead - If the call is successful, returns the number            */
/*        of bytes read from InformationBuffer.                             */
/*    pBytesNeeded - If there is not enough data in InformationBuffer       */
/*        to satisfy the OID, returns the amount of storage needed.         */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    NDIS_STATUS                                                           */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
DriverSetInformation(IN  PRNDISMP_ADAPTER   pAdapter,
                     IN  PRNDISMP_VC        pVc OPTIONAL,
                     IN  PNDIS_REQUEST      pRequest OPTIONAL,
                     IN  NDIS_OID           Oid,
                     IN  PVOID              InformationBuffer,
                     IN  ULONG              InformationBufferLength,
                     OUT PULONG             pBytesRead,
                     OUT PULONG             pBytesNeeded)
{
    NDIS_STATUS                 Status;

    TRACE2(("DriverSetInformation: Adapter %p, Oid %x\n", pAdapter, Oid));

    OID_NAME_TRACE(Oid, "DriverSet");

    Status = NDIS_STATUS_SUCCESS;

    switch(Oid)
    {
        case OID_GEN_CURRENT_LOOKAHEAD:
            // Verify the Length
            if(InformationBufferLength != sizeof(ULONG))
                Status = NDIS_STATUS_INVALID_LENGTH;

            *pBytesRead = sizeof(ULONG);
            break;

        case OID_PNP_SET_POWER:
        case OID_PNP_ADD_WAKE_UP_PATTERN:
        case OID_PNP_REMOVE_WAKE_UP_PATTERN:
        case OID_PNP_ENABLE_WAKE_UP:
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;

#ifdef TESTING
        case OID_TCP_TASK_OFFLOAD:
        	Status = NDIS_STATUS_SUCCESS;
        	DbgPrint("RNDISMP: Set TCP_TASK_OFFLOAD\n");
        	break;
		case OID_GEN_TRANSPORT_HEADER_OFFSET:
			Status = NDIS_STATUS_SUCCESS;
			break;
#endif
        default:
            Status = NDIS_STATUS_INVALID_OID;
            break;
    }

    TRACE2(("Status (%08X)  BytesRead (%08X)\n", Status, *pBytesRead));

    return Status;
} // DriverSetInformation

/****************************************************************************/
/*                          DeviceSetInformation                            */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*    The DeviceSetInformation processes a set request                      */
/*    that is going to the Remote NDIS device                               */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*    pAdapter - pointer to our Adapter structure                           */
/*    pVc - optional pointer to our VC structure, if this is a per-Vc req.  */
/*    pRequest - optional pointer to NDIS request, if CONDIS.               */
/*    Oid - the NDIS_OID to process.                                        */
/*    InformationBuffer - Holds the data to be set.                         */
/*    InformationBufferLength - The length of InformationBuffer.            */
/*    pBytesRead - If the call is successful, returns the number            */
/*        of bytes read from InformationBuffer.                             */
/*    pBytesNeeded - If there is not enough data in InformationBuffer       */
/*        to satisfy the OID, returns the amount of storage needed.         */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    NDIS_STATUS                                                           */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
DeviceSetInformation(IN  PRNDISMP_ADAPTER   pAdapter,
                     IN  PRNDISMP_VC        pVc OPTIONAL,
                     IN  PNDIS_REQUEST      pRequest OPTIONAL,
                     IN  NDIS_OID           Oid,
                     IN  PVOID              InformationBuffer,
                     IN  ULONG              InformationBufferLength,
                     OUT PULONG             pBytesRead,
                     OUT PULONG             pBytesNeeded)
{
    PRNDISMP_MESSAGE_FRAME      pMsgFrame;
    PRNDISMP_REQUEST_CONTEXT    pReqContext;
    NDIS_STATUS                 Status;

    TRACE2(("DeviceSetInformation: Adapter %p, Oid %x\n"));

    OID_NAME_TRACE(Oid, "DeviceSet");

#if DBG
    if (Oid == OID_GEN_CURRENT_PACKET_FILTER)
    {
        PULONG      pFilter = (PULONG)InformationBuffer;

        TRACE1(("DeviceSetInfo: Adapter %p: Setting packet filter to %x\n",
                pAdapter, *pFilter));
    }
#endif

    do
    {
        if (pAdapter->Halting)
        {
            TRACE1(("DeviceSetInfo: Adapter %p is halting: succeeding Oid %x\n",
                    pAdapter, Oid));
            Status = NDIS_STATUS_SUCCESS;
            break;
        }

        pReqContext = AllocateRequestContext(pAdapter);
        if (pReqContext == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        pMsgFrame = BuildRndisMessageCommon(pAdapter, 
                                            pVc,
                                            REMOTE_NDIS_SET_MSG,
                                            Oid,
                                            InformationBuffer,
                                            InformationBufferLength);

        // see if we got a message
        if (!pMsgFrame)
        {
            Status = NDIS_STATUS_RESOURCES;
            FreeRequestContext(pAdapter, pReqContext);
            break;
        }

        Status = NDIS_STATUS_PENDING;

        pReqContext->InformationBuffer = InformationBuffer;
        pReqContext->InformationBufferLength = InformationBufferLength;
        pReqContext->pBytesRead = pBytesRead;
        pReqContext->pBytesWritten = NULL;
        pReqContext->pBytesNeeded = pBytesNeeded;
        pReqContext->Oid = Oid;
        pReqContext->RetryCount = 0;
        pReqContext->bInternal = FALSE;
        pReqContext->pVc = pVc;
        pReqContext->pNdisRequest = pRequest;

        pMsgFrame->pReqContext = pReqContext;

#ifndef BUILD_WIN9X
        // Add a ref to keep the frame around until we complete the request.
        ReferenceMsgFrame(pMsgFrame);

        // send the message to the microport
        RNDISMP_SEND_TO_MICROPORT(pAdapter, pMsgFrame, TRUE, CompleteSendDeviceRequest);
#else
        //
        // Win9X!
        //
        // Special-case for setting the current packet filter to 0.
        // We complete this one synchronously, otherwise NdisCloseAdapter
        // doesn't seem to complete.
        //
        if ((Oid == OID_GEN_CURRENT_PACKET_FILTER) &&
            (*(PULONG)InformationBuffer == 0))
        {
            //
            // Do not queue the request, so that when we get a completion
            // from the device, we simply drop it.
            //
            RNDISMP_SEND_TO_MICROPORT(pAdapter, pMsgFrame, FALSE, CompleteSendDiscardDeviceRequest);
            Status = NDIS_STATUS_SUCCESS;
        }
        else
        {
            // Add a ref to keep the frame around until we complete the request.
            ReferenceMsgFrame(pMsgFrame);

            // send the message to the microport
            RNDISMP_SEND_TO_MICROPORT(pAdapter, pMsgFrame, TRUE, CompleteSendDeviceRequest);
        }

#endif // BUILD_WIN9X
        break;
    }
    while (FALSE);

    return Status;
} // DeviceSetInformation


/****************************************************************************/
/*                          QuerySetCompletionMessage                       */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Completion message from microport in response to query or set message   */
/*  miniport sent. This information is now ready to pass to upper layers    */
/*  since the original call into the miniport returned STATUS_PENDING       */
/*                                                                          */
/*  Danger Danger - an OID_GEN_SUPPORTED_LIST query is special cased here   */
/*  This is only sent to the device from the adapter init routine to build  */
/*  a list of OIDs supported by the driver and device.                      */
/*  All OID_GEN_SUPPORTED_LIST queries from upper layers are handled by     */
/*  the driver and not the device.                                          */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Pointer to our adapter structure                             */
/*  pMessage - pointer to RNDIS message                                     */
/*  pMdl - pointer to MDL from microport                                    */
/*  TotalLength - length of complete message                                */
/*  MicroportMessageContext - context for message from microport            */
/*  ReceiveStatus - used by microport to indicate it is low on resource     */
/*  bMessageCopied - is this a copy of the original message?                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  BOOLEAN - should the message be returned to the microport?              */
/*                                                                          */
/****************************************************************************/
BOOLEAN
QuerySetCompletionMessage(IN PRNDISMP_ADAPTER   pAdapter,
                          IN PRNDIS_MESSAGE     pMessage,
                          IN PMDL               pMdl,
                          IN ULONG              TotalLength,
                          IN NDIS_HANDLE        MicroportMessageContext,
                          IN NDIS_STATUS        ReceiveStatus,
                          IN BOOLEAN            bMessageCopied)
{
    PRNDISMP_MESSAGE_FRAME      pMsgFrame;
    PRNDISMP_REQUEST_CONTEXT    pReqContext;
    PRNDIS_QUERY_COMPLETE       pQueryComplMessage;
    PRNDIS_SET_COMPLETE         pSetComplMessage;
    UINT32                      NdisMessageType;
    NDIS_STATUS                 Status;
    UINT                        BytesWritten;
    UINT                        BytesRead;
    BOOLEAN                     bInternal;

    TRACE3(("QuerySetCompletionMessage\n"));

    pReqContext = NULL;
    pMsgFrame = NULL;

    pQueryComplMessage = RNDIS_MESSAGE_PTR_TO_MESSAGE_PTR(pMessage);
    pSetComplMessage = RNDIS_MESSAGE_PTR_TO_MESSAGE_PTR(pMessage);
    bInternal = FALSE;
    NdisMessageType = 0xdead;
    Status = NDIS_STATUS_SUCCESS;

    do
    {
        // get request frame from request ID in message
        RNDISMP_LOOKUP_PENDING_MESSAGE(pMsgFrame, pAdapter, pQueryComplMessage->RequestId);

        if (pMsgFrame == NULL)
        {
            // invalid request ID or aborted request.
            TRACE1(("Invalid/aborted request ID %08X in Query/Set Complete msg %p\n",
                    pQueryComplMessage->RequestId, pQueryComplMessage));
            break;
        }

        pReqContext = pMsgFrame->pReqContext;
        ASSERT(pReqContext != NULL);
        bInternal = pReqContext->bInternal;

        NdisMessageType = pMessage->NdisMessageType;
        
        if (NdisMessageType != RNDIS_COMPLETION(pMsgFrame->NdisMessageType))
        {
            TRACE1(("Query/Response mismatch: Msg @ %p, ReqId %d, req type %X, compl type %X\n",
                    pMessage,
                    pQueryComplMessage->RequestId,
                    pMsgFrame->NdisMessageType,
                    NdisMessageType));
            ASSERT(FALSE);
            pMsgFrame = NULL;
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        switch(NdisMessageType)
        {
            // a query complete message indicates we have a response
            // to a query message the miniport sent down. we carry around
            // appropriate context so we can indicate the completion
            // to upper layers and pass the query data up
            //
            // OID_GEN_SUPPORTED_LIST is a special case since it
            // is never indicated to upper layers from the device

            case REMOTE_NDIS_QUERY_CMPLT:

                // an OID_GEN_SUPPORTED_LIST is never completed to the upper
                // layers. This is sent from our adapter init routine
                // in preparation for building a list of OIDs

                TRACE2(("QueryCompl: OID %08X, %d bytes, Status %x\n",
                        pReqContext->Oid,
                        pQueryComplMessage->InformationBufferLength,
                        pQueryComplMessage->Status));

                pReqContext->CompletionStatus = pQueryComplMessage->Status;
                if (pReqContext->Oid == OID_GEN_SUPPORTED_LIST)
                {
                    if (pReqContext->CompletionStatus == NDIS_STATUS_SUCCESS)
                    {
                        // Build a list of supported OIDs.

                        TRACE1(("QueryComplete: SupportedList: InfoBufLength %d (%d OIDs)\n",
                                    pQueryComplMessage->InformationBufferLength,
                                    pQueryComplMessage->InformationBufferLength/sizeof(NDIS_OID)));

                        Status = BuildOIDLists(pAdapter, 
                                               (PNDIS_OID) (((PUCHAR)(pQueryComplMessage)) +
                                               pQueryComplMessage->InformationBufferOffset),
                                               pQueryComplMessage->InformationBufferLength / sizeof(NDIS_OID),
                                               pAdapter->DriverOIDList,
                                               pAdapter->NumDriverOIDs);

                    }

                    // the adapter init routine is waiting for a response
                    NdisSetEvent(pReqContext->pEvent);

                    // The message frame is freed by the Init routine.
                    pMsgFrame = NULL;
                    break;
                }

                // something other than OID_GEN_SUPPORTED_LIST
                *pReqContext->pBytesNeeded = pQueryComplMessage->InformationBufferLength;

                if (pQueryComplMessage->InformationBufferLength > pReqContext->InformationBufferLength)
                {
                    TRACE0(("Query Complete (Oid = %08X): InfoBuffLen %d < %d\n",
                        pReqContext->Oid,
                        pQueryComplMessage->InformationBufferLength,
                        pReqContext->InformationBufferLength));

                    Status = NDIS_STATUS_BUFFER_TOO_SHORT;
                    break;
                }

                if (pQueryComplMessage->Status != RNDIS_STATUS_SUCCESS)
                {
                    TRACE0(("Query Complete (Oid = %08X): error status %08X\n",
                        pReqContext->Oid, pQueryComplMessage->Status));

                    *pReqContext->pBytesNeeded = pQueryComplMessage->InformationBufferLength;
                    *pReqContext->pBytesWritten = 0;
                    Status = pQueryComplMessage->Status;
                }
                else
                {
                    // copy information from RNDIS message to NDIS buffer passed down
                    TRACE3(("QueryCompl: copy %d bytes to %p\n",
                        pQueryComplMessage->InformationBufferLength,
                        pReqContext->InformationBuffer));

                    RNDISMP_MOVE_MEM(pReqContext->InformationBuffer,
                                     MESSAGE_TO_INFO_BUFFER(pQueryComplMessage),
                                     pQueryComplMessage->InformationBufferLength);

                    // tell the upper layers the size
                    *pReqContext->pBytesWritten = pQueryComplMessage->InformationBufferLength;

                    BytesWritten = *pReqContext->pBytesWritten;
                    TRACE3(("Query Compl OK: Adapter %p, Oid %x\n",
                    		pAdapter, pReqContext->Oid));

                    TRACE2(("Info Data (%08X)\n", *((PUINT) pReqContext->InformationBuffer)));

                    if (pReqContext->Oid == OID_GEN_MEDIA_CONNECT_STATUS)
                    {
                    	TRACE3(("Adapter %p: link is %s\n",
                    		pAdapter, (((*(PULONG)pReqContext->InformationBuffer) == NdisMediaStateConnected)?
                    			"Connected": "Not connected")));
                    }

                    if (pReqContext->Oid == OID_GEN_MAC_OPTIONS)
                    {
                        PULONG  pMacOptions = (PULONG)pReqContext->InformationBuffer;
                        ULONG   MacOptions = *pMacOptions;

                        TRACE1(("Adapter %p: OID_GEN_MAC_OPTIONS from device is %x\n",
                                pAdapter, MacOptions));
                        //
                        // We only let the device dictate some of these bits.
                        //
                        MacOptions = (MacOptions & RNDIS_DEVICE_MAC_OPTIONS_MASK) |
                                      pAdapter->MacOptions;

                        *pMacOptions = MacOptions;

                        TRACE1(("Adapter %p: Modified OID_GEN_MAC_OPTIONS is %x\n",
                                pAdapter, *pMacOptions));
                    }


#if 0
                    //
                    //  Temp hack for old-firmware Peracom devices - report a smaller
                    //  value for max multicast list aize.
                    //  
                    if (pReqContext->Oid == OID_802_3_MAXIMUM_LIST_SIZE)
                    {
                        PULONG  pListSize = (PULONG)pReqContext->InformationBuffer;
                        if (*pListSize > 64)
                        {

                            TRACE1(("Adapter %p: Truncating max multicast list size from %d to 63!\n",
                                pAdapter, *pListSize));
                            *pListSize = 64;

                        }
                    }
#endif

                    Status = NDIS_STATUS_SUCCESS;
                }

                break;

            case REMOTE_NDIS_SET_CMPLT:

                TRACE2(("SetCompl: OID %08X, Status %x\n",
                        pReqContext->Oid,
                        pSetComplMessage->Status));

                if (pSetComplMessage->Status == RNDIS_STATUS_SUCCESS)
                {
                    *pReqContext->pBytesRead = pReqContext->InformationBufferLength;
                    BytesRead = *pReqContext->pBytesRead;
                    Status = NDIS_STATUS_SUCCESS;
                }
                else
                {
                    // don't really expect to see this other than via NDISTEST

                    TRACE1(("Set Complete (Oid = %08X) failure: %08X\n",
                                pReqContext->Oid,
                                pSetComplMessage->Status));

                    *pReqContext->pBytesRead = 0;
                    BytesRead = 0;
                    Status = pSetComplMessage->Status;
                }

                pReqContext->CompletionStatus = Status;

                if (bInternal && pReqContext->pEvent)
                {
                    NdisSetEvent(pReqContext->pEvent);
                    pMsgFrame = NULL;
                    pReqContext = NULL;
                }

                break;

            default:
                TRACE1(("Invalid Ndis Message Type (%08X)\n", NdisMessageType));
                ASSERT(FALSE);  // we shouldn't have sent an invalid message type!
                break;
        }

        break;
    }
    while (FALSE);

    //
    // Send the completion to the upper layers unless it was a request
    // we generated outselves.
    //
    if (!bInternal && pReqContext)
    {
        if (pReqContext->pNdisRequest)
        {
            NdisMCoRequestComplete(Status,
                                   pAdapter->MiniportAdapterHandle,
                                   pReqContext->pNdisRequest);
        }
        else
        {
            if (NdisMessageType == REMOTE_NDIS_QUERY_CMPLT)
            {
                TRACE2(("Status (%08X)  BytesWritten (%08X)\n", Status, BytesWritten));
    
                // complete the query
    
                NdisMQueryInformationComplete(pAdapter->MiniportAdapterHandle,
                                              Status);
            }
            else if (NdisMessageType == REMOTE_NDIS_SET_CMPLT)
            {
                TRACE2(("Status (%08X)  BytesRead (%08X)\n", Status, BytesRead));

                // complete the set
                NdisMSetInformationComplete(pAdapter->MiniportAdapterHandle,
                                            Status);
            }
        }
    }

    if (pReqContext)
    {
        FreeRequestContext(pAdapter, pReqContext);
    }

    if (pMsgFrame)
    {
        DereferenceMsgFrame(pMsgFrame);
    }

    return (TRUE);

} // QuerySetCompletionMessage

/****************************************************************************/
/*                          CompleteSendDeviceRequest                       */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Completion of send of a device set or query request thru the microport. */
/*  If the message send failed, complete the request right now.             */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pMsgFrame - our context for the message                                 */
/*  SendStatus - microport's send status                                    */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  None.                                                                   */
/*                                                                          */
/****************************************************************************/
VOID
CompleteSendDeviceRequest(IN PRNDISMP_MESSAGE_FRAME pMsgFrame,
                          IN NDIS_STATUS            SendStatus)
{
    PRNDISMP_ADAPTER            pAdapter;
    PRNDISMP_MESSAGE_FRAME      pOrgMsgFrame;
    PRNDISMP_REQUEST_CONTEXT    pReqContext;
    UINT                        NdisMessageType;

    pAdapter = pMsgFrame->pAdapter;

    TRACE3(("CompleteSendDevice Request: Adapter %p, MsgFrame %p, Status %x\n",
        pAdapter, pMsgFrame, SendStatus));
    
    if (SendStatus != NDIS_STATUS_SUCCESS)
    {
        //
        // Microport failed to send the Request message;
        // attempt to fail the original NDIS request.
        //
        TRACE1(("CompleteSendDeviceReq: Adapter %p, MsgFrame %p, failed %x\n",
                pAdapter, pMsgFrame, SendStatus));

        RNDISMP_LOOKUP_PENDING_MESSAGE(pOrgMsgFrame, pAdapter, pMsgFrame->RequestId);

        if (pOrgMsgFrame == pMsgFrame)
        {
            //
            // The request has not been aborted, so complete it now.
            //
            pReqContext = pMsgFrame->pReqContext;
            NdisMessageType = pMsgFrame->NdisMessageType;

            TRACE1(("CompleteSendReq: Adapter %p: Device req send failed, Oid %x, retry count %d\n",
                    pAdapter, pReqContext->Oid, pReqContext->RetryCount));

            if (NdisMessageType == REMOTE_NDIS_QUERY_MSG)
            {
                // complete the query
                NdisMQueryInformationComplete(pAdapter->MiniportAdapterHandle,
                                              SendStatus);
            }
            else if (NdisMessageType == REMOTE_NDIS_SET_MSG)
            {
                // complete the set
                NdisMSetInformationComplete(pAdapter->MiniportAdapterHandle,
                                            SendStatus);
            }
            else
            {
                ASSERT(FALSE);
            }

            FreeRequestContext(pAdapter, pReqContext);
            pMsgFrame->pReqContext = (PRNDISMP_REQUEST_CONTEXT)UlongToPtr(0xbcbcbcbc);

            //
            // Deref for NDIS request completion:
            //
            DereferenceMsgFrame(pMsgFrame);
        }
        //
        // else we failed to locate the request on the pending list;
        // it must have been removed when aborting all requests due
        // to a reset.
        //
    }
    //
    //  else sent the message out successfully; wait for a response.
    //

    //
    // Deref for send-complete:
    //
    DereferenceMsgFrame(pMsgFrame);
}

#ifdef BUILD_WIN9X
/****************************************************************************/
/*                    CompleteSendDiscardDeviceRequest                      */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Completion of send of a device set or query request thru the microport. */
/*  The sender of the request just wants us to free it up here.             */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pMsgFrame - our context for the message                                 */
/*  SendStatus - microport's send status                                    */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  None.                                                                   */
/*                                                                          */
/****************************************************************************/
VOID
CompleteSendDiscardDeviceRequest(IN PRNDISMP_MESSAGE_FRAME pMsgFrame,
                                 IN NDIS_STATUS            SendStatus)
{
    PRNDISMP_ADAPTER            pAdapter;
    PRNDISMP_REQUEST_CONTEXT    pReqContext;

    pAdapter = pMsgFrame->pAdapter;
    pReqContext = pMsgFrame->pReqContext;

    TRACE1(("CompleteSendDiscard: Adapter %p, MsgFrame %p, ReqContext %p\n",
            pAdapter, pMsgFrame, pReqContext));

    FreeRequestContext(pAdapter, pReqContext);
    DereferenceMsgFrame(pMsgFrame);
}
#endif // BUILD_WIN9X

/****************************************************************************/
/*                          BuildOIDLists                                   */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Build list of supported OIDs and associated function pointers           */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Adapter - Adapter object                                                */
/*  DeviceOIDList - list of OIDs supported by the device                    */
/*  NumDeviceOID - number of OIDs supported by device                       */
/*  DriverOIDList - list of OIDs supported by the driver                    */
/*  NumDriverOID - number of OIDs supported by driver                       */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  NDIS_STATUS                                                             */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
BuildOIDLists(IN PRNDISMP_ADAPTER  Adapter, 
              IN PNDIS_OID         DeviceOIDList,
              IN UINT              NumDeviceOID,
              IN PNDIS_OID         DriverOIDList,
              IN UINT              NumDriverOID)
{
    UINT        DeviceIndex;
    UINT        DriverIndex;
    UINT        NumOID;
    NDIS_STATUS Status;
    PNDIS_OID   OIDList;
    PUINT       OIDHandlerList;

    TRACE3(("BuildOIDLists\n"));

    ASSERT(DeviceOIDList);
    ASSERT(DriverOIDList);
    
    NumOID  = NumDriverOID;

    // see what OIDs are duplicated in the device and route
    // those to the device
    for(DeviceIndex = 0; DeviceIndex < NumDeviceOID; DeviceIndex++)
    {
        for(DriverIndex = 0; DriverIndex < NumDriverOID; DriverIndex++)
        {
            if(DeviceOIDList[DeviceIndex] == DriverOIDList[DriverIndex])
            {
                // this OID is supported by the device, so don't
                // support in the driver, set to 0 for when we build new list
                DriverOIDList[DriverIndex] = 0;
                break;
            }
        }

        // if no match, increment the OID count
        if(DriverIndex == NumDriverOID)
            NumOID++;
    }

    // allocate OID list
    Status = MemAlloc(&Adapter->SupportedOIDList, 
                       NumOID * sizeof(NDIS_OID));

    // see if we got our buffer
    if(Status == NDIS_STATUS_SUCCESS)
    {
        Adapter->SupportedOIDListSize = NumOID * sizeof(NDIS_OID);
    }
    else
    {
        Adapter->OIDHandlerList         = (PUINT) NULL;
        Adapter->OIDHandlerListSize     = 0;

        Adapter->SupportedOIDList       = (PNDIS_OID) NULL;
        Adapter->SupportedOIDListSize   = 0;

        Status = NDIS_STATUS_FAILURE;

        goto BuildDone;
    }
    
    // allocate list to indicate whether the OID is device or driver supported
    Status = MemAlloc(&Adapter->OIDHandlerList, 
                       NumOID * sizeof(UINT));

    // see if we got our buffer
    if(Status == NDIS_STATUS_SUCCESS)
    {
        Adapter->OIDHandlerListSize = NumOID * sizeof(UINT);
    }
    else
    {
        // free up allocated OID list cause this allocation failed
        MemFree(Adapter->SupportedOIDList, Adapter->SupportedOIDListSize);

        Adapter->OIDHandlerList         = (PUINT) NULL;
        Adapter->OIDHandlerListSize     = 0;

        Adapter->SupportedOIDList       = (PNDIS_OID) NULL;
        Adapter->SupportedOIDListSize   = 0;

        Status = NDIS_STATUS_FAILURE;

        goto BuildDone;
    }

    Adapter->NumOIDSupported    = NumOID;
    OIDHandlerList              = Adapter->OIDHandlerList;
    OIDList                     = Adapter->SupportedOIDList;

    // O.K., build our lists
    for(DriverIndex = 0; DriverIndex < NumDriverOID; DriverIndex++)
    {
        if(DriverOIDList[DriverIndex] != 0)
        {
            // got one, so add to the list
            *OIDList = DriverOIDList[DriverIndex];
            OIDList++;

            // set flag
            *OIDHandlerList = DRIVER_SUPPORTED_OID;
            OIDHandlerList++;
        }
    }

    // let's add device supported OIDs
    for(DeviceIndex = 0; DeviceIndex < NumDeviceOID; DeviceIndex++)
    {
        if(DeviceOIDList[DeviceIndex] != 0)
        {
            // got one, so add to the list
            *OIDList = DeviceOIDList[DeviceIndex];
            OIDList++;

            // set flag
            *OIDHandlerList = DEVICE_SUPPORTED_OID;
            OIDHandlerList++;
        }
    }

    // Now do a fixup to point OID_GEN_SUPPORTED_LIST at the driver since
    // we now have a complete list.
    //
    for(DeviceIndex = 0; DeviceIndex < Adapter->NumOIDSupported; DeviceIndex++)
    {
        if (Adapter->SupportedOIDList[DeviceIndex] == OID_GEN_SUPPORTED_LIST)
        {
            Adapter->OIDHandlerList[DeviceIndex] = DRIVER_SUPPORTED_OID;
        }
    }

BuildDone:

    if(Status == NDIS_STATUS_SUCCESS)
    {
        DISPLAY_OID_LIST(Adapter);
    }

    return Status;
} // BuildOIDLists

/****************************************************************************/
/*                          GetOIDSupport                                   */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Returns flag to indicate if OID is device or driver supported           */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Adapter - Adapter object                                                */
/*  Oid - looking for a match on this OID                                   */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  UINT                                                                    */
/*                                                                          */
/****************************************************************************/
UINT
GetOIDSupport(IN PRNDISMP_ADAPTER Adapter, IN NDIS_OID Oid)
{
    UINT Index;

    TRACE3(("GetOIDSupport\n"));

    // sanity check
    ASSERT(Adapter->SupportedOIDList);
    ASSERT(Adapter->OIDHandlerList);

    // search for a match on the OID
    for(Index = 0; Index < Adapter->NumOIDSupported; Index++)
    {
        if(Adapter->SupportedOIDList[Index] == Oid)
        {
            return Adapter->OIDHandlerList[Index];
        }
    }

    return OID_NOT_SUPPORTED;
} // GetOIDSupport


/****************************************************************************/
/*                          FreeOIDLists                                    */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Free OID and handler lists                                              */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Adapter - Adapter object                                                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
FreeOIDLists(IN PRNDISMP_ADAPTER Adapter)
{
    UINT        Size1, Size2;
    PUCHAR      Buffer1, Buffer2;

    TRACE3(("FreeOIDLists\n"));

    // grab the spinlock
    NdisAcquireSpinLock(&Adapter->Lock);

    Buffer1                         = (PUCHAR) Adapter->SupportedOIDList;
    Size1                           = Adapter->SupportedOIDListSize;

    Buffer2                         = (PUCHAR) Adapter->OIDHandlerList;
    Size2                           = Adapter->OIDHandlerListSize;

    Adapter->SupportedOIDList       = (PUINT) NULL;
    Adapter->SupportedOIDListSize   = 0;

    Adapter->OIDHandlerList         = (PUINT) NULL;
    Adapter->OIDHandlerListSize     = 0;
    Adapter->NumOIDSupported        = 0;

    // release spinlock
    NdisReleaseSpinLock(&Adapter->Lock);

    if(Buffer1)
        MemFree(Buffer1, Size1);

    if(Buffer2)
        MemFree(Buffer2, Size2);

} // FreeOIDLists    

/****************************************************************************/
/*                        AllocateRequestContext                            */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Allocate a context structure to keep track of an NDIS request           */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Pointer to our adapter structure                             */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   PRNDISMP_REQUEST_CONTEXT                                               */
/*                                                                          */
/****************************************************************************/
PRNDISMP_REQUEST_CONTEXT
AllocateRequestContext(IN PRNDISMP_ADAPTER pAdapter)
{
    NDIS_STATUS                 Status;
    PRNDISMP_REQUEST_CONTEXT    pReqContext;

    TRACE3(("AllocateRequestContext\n"));

    Status = MemAlloc(&pReqContext, sizeof(RNDISMP_REQUEST_CONTEXT));

    if (Status != NDIS_STATUS_SUCCESS)
    {
        pReqContext = NULL;
    }

    return pReqContext;
} // AllocateRequestContext


/****************************************************************************/
/*                          FreeRequestContext                              */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Freeing up miniport resources associated with a request                 */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Pointer to our adapter structure                             */
/*  pReqContext - Pointer to request context to be freed                    */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   VOID                                                                   */
/*                                                                          */
/****************************************************************************/
VOID
FreeRequestContext(IN PRNDISMP_ADAPTER pAdapter, 
                   IN PRNDISMP_REQUEST_CONTEXT pReqContext)
{

    TRACE3(("FreeRequestContext\n"));

    MemFree(pReqContext, -1);
} // FreeRequestContext
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rndis\rndismp\rndismp.c ===
/***************************************************************************

Copyright (c) 1999  Microsoft Corporation

Module Name:

    RNDISMP.C

Abstract:

    Remote NDIS Miniport driver. Sits on top of Remote NDIS bus specific
    layers.

Environment:

    kernel mode only

Notes:

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

    Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    5/6/99 : created

Author:

    Tom Green

    
****************************************************************************/

#include "precomp.h"



//
// miniport driver block list (miniport layer may support several microports)
//
DRIVER_BLOCK        RndismpMiniportBlockListHead = {0};

UINT                RndismpNumMicroports = 0;

NDIS_SPIN_LOCK      RndismpGlobalLock;

ULONG               RndisForceReset = FALSE;

#ifdef TESTING
UCHAR               OffloadBuffer[sizeof(NDIS_TASK_OFFLOAD_HEADER) +
                                  sizeof(NDIS_TASK_OFFLOAD) +
                                  sizeof(NDIS_TASK_TCP_IP_CHECKSUM)];
PUCHAR              pOffloadBuffer = OffloadBuffer;
ULONG               OffloadSize = sizeof(OffloadBuffer);
#endif

#ifdef RAW_ENCAP
ULONG               gRawEncap = TRUE;
#else
ULONG               gRawEncap = FALSE;
#endif

//
//  A list of NDIS versions we cycle through, trying to register the
//  highest version we can with NDIS. This is so that we can run on
//  earlier platforms.
//
//  To support a newer version, add an entry at the TOP of the list.
//
struct _RNDISMP_NDIS_VERSION_TABLE
{
    UCHAR           MajorVersion;
    UCHAR           MinorVersion;
    ULONG           CharsSize;
} RndismpNdisVersionTable[] =

{
#ifdef NDIS51_MINIPORT
    {5, 1, sizeof(NDIS51_MINIPORT_CHARACTERISTICS)},
#endif

    {5, 0, sizeof(NDIS50_MINIPORT_CHARACTERISTICS)}
};

ULONG   RndismpNdisVersions = sizeof(RndismpNdisVersionTable) /
                              sizeof(struct _RNDISMP_NDIS_VERSION_TABLE);


/****************************************************************************/
/*                          DriverEntry                                     */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*   Driver entry routine. Never called, Microport driver entry is used     */
/*                                                                          */
/****************************************************************************/
NTSTATUS
DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)
{
    // this is never called. Driver entry in Microport is entry.
    TRACE1(("DriverEntry\n"));

    return NDIS_STATUS_SUCCESS;
} // DriverEntry

/****************************************************************************/
/*                          RndisMInitializeWrapper                         */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*   RndisMInitializeWrapper is called from the microport to init driver    */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*   pNdisWrapperHandle    - Pass NDIS wrapper handle back to microport     */
/*   MicroportContext      - Microport "Global" context                     */
/*   DriverObject          - Driver object                                  */
/*   RegistryPath          - Registry path                                  */
/*   pCharacteristics      - Characteristics of RNDIS microport             */
/*                                                                          */
/* Return Value:                                                            */
/*                                                                          */
/*   NDIS_STATUS_SUCCESS                                                    */
/*   NDIS_STATUS_PENDING                                                    */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
RndisMInitializeWrapper(OUT PNDIS_HANDLE                      pNdisWrapperHandle,
                        IN  PVOID                             MicroportContext,
                        IN  PVOID                             DriverObject,
                        IN  PVOID                             RegistryPath,
                        IN  PRNDIS_MICROPORT_CHARACTERISTICS  pCharacteristics)
{
    // Receives the status of the NdisMRegisterMiniport operation.
    NDIS_STATUS                         Status;

    // Characteristics table for this driver
    NDIS_MINIPORT_CHARACTERISTICS       RndismpChar;

    // Pointer to the global information for this driver
    PDRIVER_BLOCK                       NewDriver;

    // Handle for referring to the wrapper about this driver.
    NDIS_HANDLE                         NdisWrapperHandle;

    ULONG                               i;

    TRACE3(("RndisMInitializeWrapper\n"));

    // allocate the driver block object, exit if error occurs
    Status = MemAlloc(&NewDriver, sizeof(DRIVER_BLOCK));

    if(Status != NDIS_STATUS_SUCCESS)
    {
        TRACE2(("Block Allocate Memory failed (%08X)\n", Status));
        return Status;
    }

    // Initialize the wrapper.
    NdisMInitializeWrapper(&NdisWrapperHandle,
                           (PDRIVER_OBJECT)DriverObject,
                           RegistryPath,
                           NULL);

    // Save the global information about this driver.
    NewDriver->NdisWrapperHandle        = NdisWrapperHandle;
    NewDriver->AdapterList              = (PRNDISMP_ADAPTER) NULL;
    NewDriver->DriverObject             = DriverObject;
    NewDriver->Signature                = BLOCK_SIGNATURE;

    // get handlers passed in from microport
    NewDriver->RmInitializeHandler      = pCharacteristics->RmInitializeHandler;
    NewDriver->RmInitCompleteNotifyHandler  = pCharacteristics->RmInitCompleteNotifyHandler;
    NewDriver->RmHaltHandler            = pCharacteristics->RmHaltHandler;
    NewDriver->RmShutdownHandler        = pCharacteristics->RmShutdownHandler;
    NewDriver->RmUnloadHandler          = pCharacteristics->RmUnloadHandler;
    NewDriver->RmSendMessageHandler     = pCharacteristics->RmSendMessageHandler;
    NewDriver->RmReturnMessageHandler   = pCharacteristics->RmReturnMessageHandler;

    // save microport "Global" context
    NewDriver->MicroportContext         = MicroportContext;

    // pass the microport the wrapper handle
    *pNdisWrapperHandle                 = (NDIS_HANDLE) NdisWrapperHandle;

    // initialize the Miniport characteristics for the call to NdisMRegisterMiniport.
    NdisZeroMemory(&RndismpChar, sizeof(RndismpChar));
    
    RndismpChar.HaltHandler             = RndismpHalt;
    RndismpChar.InitializeHandler       = RndismpInitialize;
    RndismpChar.QueryInformationHandler = RndismpQueryInformation;
    RndismpChar.ReconfigureHandler      = RndismpReconfigure;
    RndismpChar.ResetHandler            = RndismpReset;
    RndismpChar.SendPacketsHandler      = RndismpMultipleSend;
    RndismpChar.SetInformationHandler   = RndismpSetInformation;
    RndismpChar.ReturnPacketHandler     = RndismpReturnPacket;
    RndismpChar.CheckForHangHandler     = RndismpCheckForHang;
    RndismpChar.DisableInterruptHandler = NULL;
    RndismpChar.EnableInterruptHandler  = NULL;
    RndismpChar.HandleInterruptHandler  = NULL;
    RndismpChar.ISRHandler              = NULL;
    RndismpChar.SendHandler             = NULL;
    RndismpChar.TransferDataHandler     = NULL;
#if CO_RNDIS
    RndismpChar.CoSendPacketsHandler    = RndismpCoSendPackets;
    RndismpChar.CoCreateVcHandler       = RndismpCoCreateVc;
    RndismpChar.CoDeleteVcHandler       = RndismpCoDeleteVc;
    RndismpChar.CoActivateVcHandler     = RndismpCoActivateVc;
    RndismpChar.CoDeactivateVcHandler   = RndismpCoDeactivateVc;
    RndismpChar.CoRequestHandler        = RndismpCoRequest;
#endif // CO_RNDIS

#ifdef NDIS51_MINIPORT
    RndismpChar.PnPEventNotifyHandler   = RndismpPnPEventNotify;
    RndismpChar.AdapterShutdownHandler  = RndismpShutdownHandler;
#endif

    for (i = 0; i < RndismpNdisVersions; i++)
    {
        RndismpChar.MajorNdisVersion = RndismpNdisVersionTable[i].MajorVersion;
        RndismpChar.MinorNdisVersion = RndismpNdisVersionTable[i].MinorVersion;

        Status = NdisMRegisterMiniport(NdisWrapperHandle,
                                       &RndismpChar,
                                       RndismpNdisVersionTable[i].CharsSize);

        if (Status == NDIS_STATUS_SUCCESS)
        {
            TRACE1(("InitializeWrapper: successfully registered as a %d.%d miniport\n",
                RndismpNdisVersionTable[i].MajorVersion,
                RndismpNdisVersionTable[i].MinorVersion));

            NewDriver->MajorNdisVersion = RndismpNdisVersionTable[i].MajorVersion;
            NewDriver->MinorNdisVersion = RndismpNdisVersionTable[i].MinorVersion;

            break;
        }
    }

    if(Status != NDIS_STATUS_SUCCESS)
    {
        Status = STATUS_UNSUCCESSFUL;

        // free up memory allocated for block
        MemFree(NewDriver, sizeof(DRIVER_BLOCK));
    }
    else
    {
        // everything went fine, so add the driver block to the list
        AddDriverBlock(&RndismpMiniportBlockListHead, NewDriver);

#ifndef BUILD_WIN9X
        // if we are running on a platform < NDIS 5.1, attempt to support
        // surprise removal.
        HookPnpDispatchRoutine(NewDriver);
#endif

#ifndef BUILD_WIN9X
        // Not supported on Win98 Gold:
        NdisMRegisterUnloadHandler(NdisWrapperHandle, RndismpUnload);
#endif
    }

    return (NDIS_STATUS) Status;

} // RndisMInitializeWrapper


/****************************************************************************/
/*                          RndismpUnload                                   */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Called by NDIS when this driver is unloaded.                            */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pDriverObject - Pointer to driver object.                               */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   VOID                                                                   */
/*                                                                          */
/****************************************************************************/
VOID
RndismpUnload(IN PDRIVER_OBJECT pDriverObject)
{
    PDRIVER_BLOCK       DriverBlock;

    // Find our Driver block for this driver object.
    DriverBlock = DriverObjectToDriverBlock(&RndismpMiniportBlockListHead, pDriverObject);

    TRACE1(("RndismpUnload: DriverObj %x, DriverBlock %x\n", pDriverObject, DriverBlock));

    if (DriverBlock)
    {
        if (DriverBlock->RmUnloadHandler)
        {
            (DriverBlock->RmUnloadHandler)(DriverBlock->MicroportContext);
        }

        RemoveDriverBlock(&RndismpMiniportBlockListHead, DriverBlock);

        MemFree(DriverBlock, sizeof(*DriverBlock));
    }

    TRACE1(("RndismpUnload: Done\n"));

}

#ifndef BUILD_WIN9X

/****************************************************************************/
/*                          DllInitialize                                   */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Called by the system when this driver is loaded.                        */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pRegistryPath - Pointer to registry path for this service.              */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   NTSTATUS - success always                                              */
/*                                                                          */
/****************************************************************************/
NTSTATUS
DllInitialize(IN PUNICODE_STRING    pRegistryPath)
{
#if DBG
    DbgPrint("RNDISMP: RndismpDebugFlags set to %x, &RndismpDebugFlags is %p\n",
                RndismpDebugFlags, &RndismpDebugFlags);
#endif

    TRACE1(("DllInitialize\n"));
#ifdef TESTING
    {
        PNDIS_TASK_OFFLOAD_HEADER   pOffloadHdr = (PNDIS_TASK_OFFLOAD_HEADER)pOffloadBuffer;
        PNDIS_TASK_OFFLOAD  pTask;
        PNDIS_TASK_TCP_IP_CHECKSUM pChksum;

        pOffloadHdr->Version = NDIS_TASK_OFFLOAD_VERSION;
        pOffloadHdr->Size = sizeof(NDIS_TASK_OFFLOAD_HEADER);
        pOffloadHdr->EncapsulationFormat.Encapsulation = IEEE_802_3_Encapsulation;
        pOffloadHdr->EncapsulationFormat.EncapsulationHeaderSize = 0; // ?
        pOffloadHdr->EncapsulationFormat.Flags.FixedHeaderSize = 0;
        pOffloadHdr->OffsetFirstTask = sizeof(NDIS_TASK_OFFLOAD_HEADER);

        pTask = (PNDIS_TASK_OFFLOAD)(pOffloadHdr + 1);
        pTask->Version = NDIS_TASK_OFFLOAD_VERSION;
        pTask->Size = sizeof(NDIS_TASK_OFFLOAD);
        pTask->Task = TcpIpChecksumNdisTask;
        pTask->OffsetNextTask = 0;
        pTask->TaskBufferLength = sizeof(NDIS_TASK_TCP_IP_CHECKSUM);

        pChksum = (PNDIS_TASK_TCP_IP_CHECKSUM)&pTask->TaskBuffer[0];
        *(PULONG)pChksum = 0;
        pChksum->V4Transmit.TcpChecksum = 1;
        pChksum->V4Transmit.UdpChecksum = 1;
    }
#endif

    return STATUS_SUCCESS;
}

#endif // !BUILD_WIN9X

/****************************************************************************/
/*                          DllUnload                                       */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Called by the system when this driver is unloaded.                      */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  None                                                                    */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   NTSTATUS - success always                                              */
/*                                                                          */
/****************************************************************************/
NTSTATUS
DllUnload(VOID)
{
#if DBG
    DbgPrint("RNDISMP: DllUnload called!\n");
#endif

    return STATUS_SUCCESS;
}

/****************************************************************************/
/*                          RndismpHalt                                     */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Stop the adapter and release resources                                  */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  MiniportAdapterContext - a context version of our Adapter pointer       */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   VOID                                                                   */
/*                                                                          */
/****************************************************************************/
VOID
RndismpHalt(IN NDIS_HANDLE MiniportAdapterContext)
{

#ifdef BUILD_WIN9X
    //
    //  On Win98/SE, we would have intercepted the config mgr handler.
    //  Put it back the way it was.
    //
    UnHookNtKernCMHandler((PRNDISMP_ADAPTER)MiniportAdapterContext);
#endif

    RndismpInternalHalt(MiniportAdapterContext, TRUE);
}

/****************************************************************************/
/*                          RndismpInternalHalt                             */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Internal Halt routine. This is usually called from the MiniportHalt     */
/*  entry point, but it may also be called when we are notified of surprise */
/*  removal by NDIS. Do all work atmost once.                               */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  MiniportAdapterContext - a context version of our Adapter pointer       */
/*  bCalledFromHalt - Is this called from the MiniportHalt entry point?     */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
RndismpInternalHalt(IN NDIS_HANDLE MiniportAdapterContext,
                    IN BOOLEAN bCalledFromHalt)
{
    PRNDISMP_ADAPTER            Adapter;
    PDRIVER_BLOCK               DriverBlock;
    PRNDISMP_MESSAGE_FRAME      pMsgFrame;
    BOOLEAN                     bWokenUp;
    UINT                        Count, LoopCount;

    // get adapter context
    Adapter = PRNDISMP_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

    CHECK_VALID_ADAPTER(Adapter);

    TRACE1(("RndismpInternalHalt: Adapter %x, Halting %d, CalledFromHalt %d\n", Adapter, Adapter->Halting, bCalledFromHalt));

    FlushPendingMessages(Adapter);

    if (!Adapter->Halting)
    {
        pMsgFrame = BuildRndisMessageCommon(Adapter, 
                                            NULL,
                                            REMOTE_NDIS_HALT_MSG,
                                            0,
                                            NULL,
                                            0);

        if(pMsgFrame)
        {
            RNDISMP_ACQUIRE_ADAPTER_LOCK(Adapter);

            Adapter->Halting = TRUE;
            NdisInitializeEvent(&Adapter->HaltWaitEvent);

            RNDISMP_RELEASE_ADAPTER_LOCK(Adapter);

            // send the message to the microport
            RNDISMP_SEND_TO_MICROPORT(Adapter, pMsgFrame, FALSE, CompleteSendHalt);

            // wait for the -Send- to complete
            bWokenUp = NdisWaitEvent(&Adapter->HaltWaitEvent, MINIPORT_HALT_TIMEOUT);
        }
        else
        {
            ASSERT(FALSE);
            // Consider allocating the Halt message during Init time.
        }

        //
        // Wait for any outstanding receives to finish before halting
        // the microport.
        //
        LoopCount = 0;
        while ((Count = NdisPacketPoolUsage(Adapter->ReceivePacketPool)) != 0)
        {
            TRACE1(("RndismpInternalHalt: Adapter %p, Pkt pool %x has "
                "%d outstanding\n",
                Adapter, Adapter->ReceivePacketPool, Count));

            NdisMSleep(200);

            if (LoopCount++ > 30)
            {
                TRACE1(("RndismpInternalHalt: Adapter %p, cant reclaim packet pool %x\n",
                        Adapter, Adapter->ReceivePacketPool));
                break;
            }
        }

        //
        // Wait for send-messages pending at the microport to finish.
        // Since we have set Halting to TRUE, no -new- messages will
        // be sent down, however there may be running threads that
        // have gone past the check for Halting - allow those
        // threads to finish now.
        //
        LoopCount = 0;
        while (Adapter->CurPendedMessages)
        {
            TRACE1(("RndismpInternalHalt: Adapter %p, %d msgs at microport\n",
                Adapter, Adapter->CurPendedMessages));

            NdisMSleep(200);

            if (LoopCount++ > 30)
            {
                TRACE1(("RndismpInternalHalt: Adapter %p, %d messages not send-completed!\n",
                        Adapter, Adapter->CurPendedMessages));
                break;
            }
        }

        // cancel our keep alive timer
        NdisCancelTimer(&Adapter->KeepAliveTimer, &Adapter->TimerCancelled);

        // call the microport halt handler
        Adapter->RmHaltHandler(Adapter->MicroportAdapterContext);
    }

    if (bCalledFromHalt)
    {
        // free lists associated with OID support
        FreeOIDLists(Adapter);

        // free the adapter spinlock
        NdisFreeSpinLock(&Adapter->Lock);

        // save driver block pointer
        DriverBlock = Adapter->DriverBlock;

        // remove adapter from list
        RemoveAdapter(Adapter);

        // Free the Adapter and associated memory resources
        FreeAdapter(Adapter);
    }

} // RndismpInternalHalt


/****************************************************************************/
/*                          RndismpReconfigure                              */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  NDIS calls this when the device is pulled. Note: only on WinMe!         */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  MiniportAdapterContext - a context version of our Adapter pointer       */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
RndismpReconfigure(OUT PNDIS_STATUS pStatus,
                   IN NDIS_HANDLE MiniportAdapterContext,
                   IN NDIS_HANDLE ConfigContext)
{
    PRNDISMP_ADAPTER        pAdapter;

    // get adapter context
    pAdapter = PRNDISMP_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

    CHECK_VALID_ADAPTER(pAdapter);

    TRACE1(("Reconfig: Adapter %x\n", pAdapter));

    RndismpInternalHalt(pAdapter, FALSE);

    *pStatus = NDIS_STATUS_SUCCESS;

    return (NDIS_STATUS_SUCCESS);
}
    

/****************************************************************************/
/*                          RndismpReset                                    */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  The RndismpReset request instructs the Miniport to issue a hardware     */
/*  reset to the network adapter.  The driver also resets its software      */
/*  state.  See the description of NdisMReset for a detailed description    */
/*  of this request.                                                        */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  AddressingReset - Does the adapter need the addressing information      */
/*   reloaded.                                                              */
/*  MiniportAdapterContext - a context version of our Adapter pointer       */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    NDIS_STATUS                                                           */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
RndismpReset(OUT PBOOLEAN    AddressingReset,
             IN  NDIS_HANDLE MiniportAdapterContext)
{
    PRNDISMP_ADAPTER        Adapter;
    PRNDISMP_MESSAGE_FRAME  pMsgFrame;
    NDIS_STATUS             Status;

    // get adapter context
    Adapter = PRNDISMP_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

    CHECK_VALID_ADAPTER(Adapter);
    ASSERT(Adapter->ResetPending == FALSE);

    TRACE1(("RndismpReset: Adapter %x\n", Adapter));

    Adapter->ResetPending = TRUE;

    FlushPendingMessages(Adapter);

    pMsgFrame = BuildRndisMessageCommon(Adapter, 
                                        NULL,
                                        REMOTE_NDIS_RESET_MSG,
                                        0,
                                        NULL,
                                        0);

    if (pMsgFrame)
    {
        RNDISMP_ACQUIRE_ADAPTER_LOCK(Adapter);

        Adapter->NeedReset = FALSE;

        //
        // Fix water mark so that the reset gets sent down.
        //
        Adapter->HiWatPendedMessages = RNDISMP_PENDED_SEND_HIWAT + 1;

        RNDISMP_RELEASE_ADAPTER_LOCK(Adapter);

        // send the message to the microport
        RNDISMP_SEND_TO_MICROPORT(Adapter, pMsgFrame, FALSE, CompleteSendReset);
        Status = NDIS_STATUS_PENDING;

        RNDISMP_ACQUIRE_ADAPTER_LOCK(Adapter);

        Adapter->HiWatPendedMessages--;

        RNDISMP_RELEASE_ADAPTER_LOCK(Adapter);
    }
    else
    {
        CompleteMiniportReset(Adapter, NDIS_STATUS_RESOURCES, FALSE);
        Status = NDIS_STATUS_PENDING;
    }

    return Status;
} // RndismpReset

/****************************************************************************/
/*                          RndismpCheckForHang                             */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Check and see if device is "hung"                                       */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  MiniportAdapterContext - a context version of our Adapter pointer       */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   BOOLEAN                                                                */
/*                                                                          */
/****************************************************************************/
BOOLEAN
RndismpCheckForHang(IN NDIS_HANDLE MiniportAdapterContext)
{
    PRNDISMP_ADAPTER        Adapter;
    BOOLEAN                 bReturnHung;
    PRNDISMP_MESSAGE_FRAME  pMsgFrame;
    PLIST_ENTRY             pEnt;

    Adapter = PRNDISMP_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

    TRACE2(("RndismpCheckForHang: Adapter %x\n", Adapter));

    CHECK_VALID_ADAPTER(Adapter);

    RNDISMP_ACQUIRE_ADAPTER_LOCK(Adapter);

    bReturnHung = (Adapter->NeedReset && !Adapter->ResetPending);

#if THROTTLE_MESSAGES
    // Try to grow the pending send window, if we can.
    //
    if (!Adapter->SendInProgress)
    {
        if (Adapter->CurPendedMessages == 0)
        {
            Adapter->HiWatPendedMessages = RNDISMP_PENDED_SEND_HIWAT;
            Adapter->LoWatPendedMessages = RNDISMP_PENDED_SEND_LOWAT;
        }
    }

    if (!bReturnHung && !Adapter->ResetPending)
    {
        //
        //  Check if the microport isn't completing messages.
        //
        if (!IsListEmpty(&Adapter->PendingAtMicroportList))
        {
            pEnt = Adapter->PendingAtMicroportList.Flink;
            pMsgFrame = CONTAINING_RECORD(pEnt, RNDISMP_MESSAGE_FRAME, PendLink);

            if (pMsgFrame->TicksOnQueue > 4)
            {
                TRACE1(("CheckForHang: Adapter %x, Msg %x has timed out!\n",
                        Adapter, pMsgFrame));
                bReturnHung = TRUE;
            }
            else
            {
                pMsgFrame->TicksOnQueue++;
            }
        }
    }

#endif // THROTTLE_MESSAGES

    if (RndisForceReset)
    {
        RndisForceReset = FALSE;
        Adapter->NeedReset = TRUE;
        Adapter->ResetPending = FALSE;
        bReturnHung = TRUE;
    }

    RNDISMP_RELEASE_ADAPTER_LOCK(Adapter);

    return (bReturnHung);


} // RndismpCheckForHang


/****************************************************************************/
/*                          RndismpInitialize                               */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*   RndismpInitialize starts an adapter and registers resources with the   */
/*   wrapper.                                                               */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*    OpenErrorStatus - Extra status bytes for opening token ring adapters. */
/*    SelectedMediumIndex - Index of the media type chosen by the driver.   */
/*    MediumArray - Array of media types for the driver to chose from.      */
/*    MediumArraySize - Number of entries in the array.                     */
/*    MiniportAdapterHandle - Handle for passing to the wrapper when        */
/*       referring to this adapter.                                         */
/*    ConfigurationHandle - A handle to pass to NdisOpenConfiguration.      */
/*                                                                          */
/* Return Value:                                                            */
/*                                                                          */
/*    NDIS_STATUS_SUCCESS                                                   */
/*    NDIS_STATUS_PENDING                                                   */
/*                                                                          */
/****************************************************************************/

NDIS_STATUS
RndismpInitialize(OUT PNDIS_STATUS  OpenErrorStatus,
                  OUT PUINT         SelectedMediumIndex,
                  IN  PNDIS_MEDIUM  MediumArray,
                  IN  UINT          MediumArraySize,
                  IN  NDIS_HANDLE   MiniportAdapterHandle,
                  IN  NDIS_HANDLE   ConfigurationHandle)
{
    ULONG                       Index;
    NDIS_STATUS                 Status;
    PRNDISMP_ADAPTER            Adapter;
    NDIS_INTERFACE_TYPE         IfType;
    PDEVICE_OBJECT              Pdo, Fdo, Ndo;
    PDRIVER_BLOCK               DriverBlock;
    PRNDIS_INITIALIZE_COMPLETE  pInitCompleteMessage;
    PRNDISMP_MESSAGE_FRAME      pMsgFrame = NULL;
    PRNDISMP_MESSAGE_FRAME      pPendingMsgFrame;
    PRNDISMP_REQUEST_CONTEXT    pReqContext = NULL;
    RNDIS_REQUEST_ID            RequestId;
    ULONG                       PacketAlignmentFactor;
    NDIS_EVENT                  Event;
    BOOLEAN                     bWokenUp;
    BOOLEAN                     bLinkedAdapter;
    BOOLEAN                     bMicroportInitialized;

    TRACE2(("RndismpInitialize\n"));
    Adapter = NULL;
    Status = NDIS_STATUS_SUCCESS;
    bLinkedAdapter = FALSE;
    bMicroportInitialized = FALSE;

    do
    {
        // allocate the adapter object, exit if error occurs
        Status = MemAlloc(&Adapter, sizeof(RNDISMP_ADAPTER));

        if (Status != NDIS_STATUS_SUCCESS)
        {
            TRACE2(("Adapter Allocate Memory failed (%08X)\n", Status));
            break;
        }

        // allocate space for list of driver-supported OIDs
        Status = MemAlloc(&Adapter->DriverOIDList,
                           RndismpSupportedOidsNum*sizeof(NDIS_OID));

        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }
            
        RNDISMP_MOVE_MEM(Adapter->DriverOIDList, RndismpSupportedOids, RndismpSupportedOidsNum*sizeof(NDIS_OID));

        Adapter->NumDriverOIDs = RndismpSupportedOidsNum;

        Adapter->MiniportAdapterHandle  = MiniportAdapterHandle;

        InitializeListHead(&Adapter->PendingFrameList);
        Adapter->Initing = TRUE;
        Adapter->MacOptions = RNDIS_DRIVER_MAC_OPTIONS;

#if THROTTLE_MESSAGES
        Adapter->HiWatPendedMessages = RNDISMP_PENDED_SEND_HIWAT;
        Adapter->LoWatPendedMessages = RNDISMP_PENDED_SEND_LOWAT;
        Adapter->CurPendedMessages = 0;
        Adapter->SendInProgress = FALSE;
        InitializeListHead(&Adapter->WaitingMessageList);
#endif
        InitializeListHead(&Adapter->PendingAtMicroportList);

        Adapter->IndicatingReceives = FALSE;
        InitializeListHead(&Adapter->PendingRcvMessageList);
        NdisInitializeTimer(&Adapter->IndicateTimer, IndicateTimeout, (PVOID)Adapter);

        Adapter->SendProcessInProgress = FALSE;
        InitializeListHead(&Adapter->PendingSendProcessList);
        NdisInitializeTimer(&Adapter->SendProcessTimer, SendProcessTimeout, (PVOID)Adapter);


        TRACE2(("Adapter structure pointer is (%08X)\n", Adapter));

        NdisAllocateSpinLock(&Adapter->Lock);

        // get PDO to pass to microport
        NdisMGetDeviceProperty(MiniportAdapterHandle,
                               &Pdo,
                               &Fdo,
                               &Ndo,
                               NULL,
                               NULL);

#if NEW_NDIS_API_IN_MILLENNIUM
        {
            NDIS_STRING        UnicodeString;
            Status = NdisMQueryAdapterInstanceName(&UnicodeString,
                                                   Adapter->MiniportAdapterHandle);
            if (Status == NDIS_STATUS_SUCCESS)
            {
                TRACE1(("Init: NDIS returned len %d [%ws]\n",
                        UnicodeString.Length, UnicodeString.Buffer));
                NdisFreeString(UnicodeString);
            }
        }
#endif

        Adapter->pDeviceObject = Fdo;
        Adapter->pPhysDeviceObject = Pdo;

        Status = GetDeviceFriendlyName(Pdo,
                                       &Adapter->FriendlyNameAnsi,
                                       &Adapter->FriendlyNameUnicode);

        if (Status == NDIS_STATUS_SUCCESS)
        {
            TRACE1(("Init: Pdo %x, Ndo %x: Adapter %x: [%s]\n",
                Pdo, Ndo, Adapter, Adapter->FriendlyNameAnsi.Buffer));
        }
        else
        {
            Status = NDIS_STATUS_SUCCESS;
        }

        // Determine the platform we are running on. Ideally we would
        // like to do this from DriverEntry, but the NDIS API isn't
        // available until MiniportInit time.
        {
            NDIS_STATUS                     NdisStatus;
            PNDIS_CONFIGURATION_PARAMETER   pParameter;
            NDIS_STRING                     VersionKey = NDIS_STRING_CONST("Environment");

            NdisReadConfiguration(
                &NdisStatus,
                &pParameter,
                ConfigurationHandle,
                &VersionKey,
                NdisParameterInteger);
           
            if ((NdisStatus == NDIS_STATUS_SUCCESS) &&
                ((pParameter->ParameterType == NdisParameterInteger) ||
                 (pParameter->ParameterType == NdisParameterHexInteger)))
            {
                Adapter->bRunningOnWin9x =
                    (pParameter->ParameterData.IntegerData == NdisEnvironmentWindows);

                TRACE1(("Init: Adapter %p, running on %s\n",
                        Adapter,
                        ((Adapter->bRunningOnWin9x)? "Win9X": "NT")));
            }
            else
            {
                TRACE1(("Init: ReadConfig: NdisStatus %x\n", NdisStatus));
#if DBG
                if (NdisStatus == NDIS_STATUS_SUCCESS)
                {
                    TRACE1(("Init: ReadConfig: parametertype %x\n",
                        pParameter->ParameterType));
                }
#endif // DBG
                Adapter->bRunningOnWin9x = TRUE;
            }
        }

        // find the driver block associated with this adapter
        DriverBlock = DeviceObjectToDriverBlock(&RndismpMiniportBlockListHead, Fdo);

        if (DriverBlock == NULL)
        {
            TRACE1(("Init: Can't find driver block for FDO %x!\n", Fdo));
            Status = NDIS_STATUS_ADAPTER_NOT_FOUND;
            break;
        }

        // save the associated driver block in the adapter
        Adapter->DriverBlock            = DriverBlock;

        Adapter->Signature              = ADAPTER_SIGNATURE;

        // get handlers passed in from microport
        Adapter->RmInitializeHandler    = DriverBlock->RmInitializeHandler;
        Adapter->RmInitCompleteNotifyHandler = DriverBlock->RmInitCompleteNotifyHandler;
        Adapter->RmHaltHandler          = DriverBlock->RmHaltHandler;
        Adapter->RmShutdownHandler      = DriverBlock->RmShutdownHandler;
        Adapter->RmSendMessageHandler   = DriverBlock->RmSendMessageHandler;
        Adapter->RmReturnMessageHandler = DriverBlock->RmReturnMessageHandler;

        // call microport initialize handler
        //
        // Microport returns context
        // Pass in Miniport context
        // Pass in NDIS adapter handle
        // Pass in NDIS configuration handle
        // Pass in PDO for this adapter
        Status = Adapter->RmInitializeHandler(&Adapter->MicroportAdapterContext,
                                              &Adapter->MaxReceiveSize,
                                              (NDIS_HANDLE) Adapter,
                                              (NDIS_HANDLE) MiniportAdapterHandle,
                                              (NDIS_HANDLE) ConfigurationHandle,
                                              Ndo);


        if (Status != NDIS_STATUS_SUCCESS)
        {
            TRACE2(("Microport initialize handler failed (%08X)\n", Status));
            break;
        }

        bMicroportInitialized = TRUE;

        // everything looks good, so finish up
        Status = AllocateTransportResources(Adapter);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            Status = NDIS_STATUS_RESOURCES; 
            break;
        }

        // allocate space to receive a copy of the Initialize complete message in
        Status = MemAlloc(&Adapter->pInitCompleteMessage, sizeof(RNDIS_INITIALIZE_COMPLETE));
        if (Status != NDIS_STATUS_SUCCESS)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }
    

        // now we send down a RNDIS initialize message to the device
        pMsgFrame = BuildRndisMessageCommon(Adapter, 
                                            NULL,
                                            REMOTE_NDIS_INITIALIZE_MSG,
                                            0,
                                            (PVOID) NULL,
                                            0);

        if (pMsgFrame == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        RequestId = pMsgFrame->RequestId;

        pReqContext = AllocateRequestContext(Adapter);
        if (pReqContext == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        pReqContext->pNdisRequest = NULL;

        NdisInitializeEvent(&Event);
        pReqContext->pEvent = &Event;

        pMsgFrame->pVc = NULL;
        pMsgFrame->pReqContext = pReqContext;

        RNDISMP_ASSERT_AT_PASSIVE();

        // send the message to the microport.
        RNDISMP_SEND_TO_MICROPORT(Adapter, pMsgFrame, TRUE, NULL);

        RNDISMP_ASSERT_AT_PASSIVE();
        // wait for message to complete
        bWokenUp = NdisWaitEvent(&Event, MINIPORT_INIT_TIMEOUT);

        // remove the message from the pending queue - it may or may not be there.
        RNDISMP_LOOKUP_PENDING_MESSAGE(pPendingMsgFrame, Adapter, RequestId);

        DereferenceMsgFrame(pMsgFrame);

        if (!bWokenUp)
        {
            // Failed to receive an Init complete within a reasonable time.
            TRACE1(("Init: Adapter %x, failed to receive Init complete\n", Adapter));
            Status = NDIS_STATUS_DEVICE_FAILED; 
            break;
        }

        //
        // the init complete message from the device is now
        // copied over to our local structure
        //
        pInitCompleteMessage = Adapter->pInitCompleteMessage;

        if (pInitCompleteMessage->Status != NDIS_STATUS_SUCCESS)
        {
            Status = pInitCompleteMessage->Status;
            break;
        }

        // make sure this is a supported device.
        if (!(pInitCompleteMessage->DeviceFlags & (RNDIS_DF_CONNECTIONLESS | RNDIS_DF_RAW_DATA)) ||
             (pInitCompleteMessage->Medium != RNdisMedium802_3))
        {
            TRACE1(("Init: Complete: unknown DeviceFlags %x or Medium %d\n",
                    pInitCompleteMessage->DeviceFlags,
                    pInitCompleteMessage->Medium));
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;
        }

        if ((pInitCompleteMessage->DeviceFlags & RNDIS_DF_RAW_DATA)
            || (gRawEncap))
        {
            Adapter->MultipleSendFunc = DoMultipleSendRaw;
        } else
        {
            Adapter->MultipleSendFunc = DoMultipleSend;
        }

        Adapter->Medium = RNDIS_TO_NDIS_MEDIUM(pInitCompleteMessage->Medium);

        // get device parameters.
        Adapter->MaxPacketsPerMessage = pInitCompleteMessage->MaxPacketsPerMessage;
        if (Adapter->MaxPacketsPerMessage == 0)
        {
            Adapter->MaxPacketsPerMessage = 1;
        }

#if HACK
        if (Adapter->MaxPacketsPerMessage > 1)
        {
            Adapter->MaxPacketsPerMessage = 2;
        }
#endif // HACK

        Adapter->bMultiPacketSupported = (Adapter->MaxPacketsPerMessage > 1);

        Adapter->MaxTransferSize = pInitCompleteMessage->MaxTransferSize;

        PacketAlignmentFactor = pInitCompleteMessage->PacketAlignmentFactor;

        if (PacketAlignmentFactor > 7)
        {
            PacketAlignmentFactor = 7;
        }

        Adapter->AlignmentIncr = (1 << PacketAlignmentFactor);
        Adapter->AlignmentMask = ~((1 << PacketAlignmentFactor) - 1);

#if DBG
        DbgPrint("RNDISMP: InitComp: Adapter %x, Version %d.%d, MaxPkt %d, AlignIncr %d, AlignMask %x, MaxXferSize %d\n",
                Adapter,
                pInitCompleteMessage->MajorVersion,
                pInitCompleteMessage->MinorVersion,
                Adapter->MaxPacketsPerMessage,
                Adapter->AlignmentIncr,
                Adapter->AlignmentMask,
                Adapter->MaxTransferSize);
#endif // DBG

        // Get the medium type.
        for (Index = 0; Index < MediumArraySize; Index++)
        {
            if (MediumArray[Index] == Adapter->Medium)
            {
                break;
            }
        }

        if (Index == MediumArraySize)
        {
            TRACE1(("InitComp: Adapter %x, device returned unsupported medium %d\n",
                Adapter, pInitCompleteMessage->Medium));
            Status = NDIS_STATUS_UNSUPPORTED_MEDIA;
            break;
        }

        *SelectedMediumIndex = Index;

        Adapter->DeviceFlags = pInitCompleteMessage->DeviceFlags;

        // call NdisMSetAttributesEx in order to let NDIS know
        // what kind of driver and features we support

        // interface type
        IfType = NdisInterfaceInternal;

        if (Adapter->bRunningOnWin9x)
        {
            //
            //  NOTE! The 0x80000000 bit is set to let NDIS know
            //  (Millennium only!) that our reconfig handler should
            //  be called when the device is surprise-removed.
            //
            NdisMSetAttributesEx(Adapter->MiniportAdapterHandle,
                                (NDIS_HANDLE) Adapter,
                                4,
                                (ULONG) NDIS_ATTRIBUTE_DESERIALIZE | 0x80000000,
                                IfType);
        }
        else
        {
            ULONG       AttrFlags;

            AttrFlags = NDIS_ATTRIBUTE_DESERIALIZE |
                        NDIS_ATTRIBUTE_SURPRISE_REMOVE_OK;

            if (Adapter->DeviceFlags & RNDIS_DF_CONNECTIONLESS)
            {
                AttrFlags |= NDIS_ATTRIBUTE_NOT_CO_NDIS;
            }

            NdisMSetAttributesEx(Adapter->MiniportAdapterHandle,
                                (NDIS_HANDLE) Adapter,
                                4,
                                AttrFlags,
                                IfType);
        }

        // Tell the microport that the device completed Init
        // successfully:
        if (Adapter->RmInitCompleteNotifyHandler)
        {
            Status = Adapter->RmInitCompleteNotifyHandler(
                                Adapter->MicroportAdapterContext,
                                Adapter->DeviceFlags,
                                &Adapter->MaxTransferSize);
            if (Status != NDIS_STATUS_SUCCESS)
            {
                break;
            }
        }

        // get the list of supported OIDs from the device
        pMsgFrame = BuildRndisMessageCommon(Adapter, 
                                            NULL,
                                            REMOTE_NDIS_QUERY_MSG,
                                            OID_GEN_SUPPORTED_LIST,
                                            (PVOID) NULL,
                                            0);

        if (pMsgFrame == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        // link us on to the list of adapters for this driver block
        AddAdapter(Adapter);
        bLinkedAdapter = TRUE;

        pReqContext->pNdisRequest = NULL;
        pReqContext->Oid = OID_GEN_SUPPORTED_LIST;
        pReqContext->CompletionStatus = NDIS_STATUS_SUCCESS;

        NdisInitializeEvent(&Event);
        pReqContext->pEvent = &Event;

        pMsgFrame->pVc = NULL;
        pMsgFrame->pReqContext = pReqContext;

        // send the message to the microport.
        RNDISMP_SEND_TO_MICROPORT(Adapter, pMsgFrame, TRUE, NULL);

        RNDISMP_ASSERT_AT_PASSIVE();
        bWokenUp = NdisWaitEvent(&Event, MINIPORT_INIT_TIMEOUT);

        // remove the message from the pending queue - it may or may not be there.
        RNDISMP_LOOKUP_PENDING_MESSAGE(pPendingMsgFrame, Adapter, RequestId);

        DereferenceMsgFrame(pMsgFrame);

        if (!bWokenUp || (Adapter->DriverOIDList == NULL))
        {
            // Failed to receive a response within a reasonable time,
            // or the device failed this query.
            //
            TRACE1(("Init: Adapter %x, failed to receive response to OID_GEN_SUPPORTED_LIST\n", Adapter));
            Status = NDIS_STATUS_DEVICE_FAILED; 
            ASSERT(FALSE);
            break;
        }

        // Successfully queried the supported OID list.

#ifdef BUILD_WIN9X
        //
        // Attempt to support surprise removal of this device (Win98/SE)
        // by intercepting config mgr messages forwarded by NDIS.
        //
        HookNtKernCMHandler(Adapter);
#endif

        // send any registry parameters down to the device, if it supports them.

        if (GetOIDSupport(Adapter, OID_GEN_RNDIS_CONFIG_PARAMETER) == DEVICE_SUPPORTED_OID)
        {
            Status = ReadAndSetRegistryParameters(Adapter, ConfigurationHandle);
            if (Status != NDIS_STATUS_SUCCESS)
            {
                break;
            }
        }

        // register a shutdown handler
        NdisMRegisterAdapterShutdownHandler(Adapter->MiniportAdapterHandle,
                                            (PVOID) Adapter,
                                            RndismpShutdownHandler);

        Adapter->TimerCancelled = FALSE;

        Adapter->Initing = FALSE;

        // initialize "KeepAlive" timer
        NdisInitializeTimer(&Adapter->KeepAliveTimer,
                            KeepAliveTimerHandler,
                            (PVOID) Adapter);

        NdisSetTimer(&Adapter->KeepAliveTimer, KEEP_ALIVE_TIMER / 2);

        Status = NDIS_STATUS_SUCCESS;
    }
    while (FALSE);

    if (Adapter)
    {
        if (Adapter->pInitCompleteMessage)
        {
            MemFree(Adapter->pInitCompleteMessage, sizeof(*Adapter->pInitCompleteMessage));
        }
    }

    if (Status != NDIS_STATUS_SUCCESS)
    {
        TRACE1(("Failed to init adapter %x, status %x\n", Adapter, Status));

        if (bMicroportInitialized)
        {
            ASSERT(Adapter);

            Adapter->RmHaltHandler(Adapter->MicroportAdapterContext);
        }

        if (Adapter)
        {
            if (bLinkedAdapter)
            {
                RemoveAdapter(Adapter);
            }

            FreeAdapter(Adapter);
        }
    }
        
    return Status;
} // RndismpInitialize

/****************************************************************************/
/*                          RndisMSendComplete                              */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Called by microport to indicate a message miniport sent is completed    */
/*  by microport                                                            */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  MiniportAdapterContext - a context version of our Adapter pointer       */
/*  RndisMessageHandle - context used by miniport                           */
/*  SendStatus - indicate status of send message                            */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
RndisMSendComplete(IN  NDIS_HANDLE     MiniportAdapterContext,
                   IN  NDIS_HANDLE     RndisMessageHandle,
                   IN  NDIS_STATUS     SendStatus)
{
    PRNDISMP_ADAPTER        Adapter;
    PRNDISMP_MESSAGE_FRAME  pMsgFrame;

    // get adapter context
    Adapter = PRNDISMP_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

    CHECK_VALID_ADAPTER(Adapter);

    pMsgFrame = MESSAGE_FRAME_FROM_HANDLE(RndisMessageHandle);

    CHECK_VALID_FRAME(pMsgFrame);

    ASSERT(pMsgFrame->pAdapter == Adapter);

    TRACE2(("RndisMSendComplete: Adapter %x, MsgFrame %x, MDL %x\n", Adapter, pMsgFrame, pMsgFrame->pMessageMdl));

    if ((SendStatus != NDIS_STATUS_SUCCESS) &&
        (SendStatus != NDIS_STATUS_RESOURCES))
    {
        RNDISMP_INCR_STAT(Adapter, MicroportSendError);
        TRACE0(("RndisMSendComplete: Adapter %x, MsgFrame %x, MDL %x, ERROR %x\n",
                    Adapter,
                    pMsgFrame,
                    pMsgFrame->pMessageMdl,
                    SendStatus));
    }

#if THROTTLE_MESSAGES
    RNDISMP_ACQUIRE_ADAPTER_LOCK(Adapter);

    Adapter->CurPendedMessages--;
    RemoveEntryList(&pMsgFrame->PendLink);

    if (SendStatus == NDIS_STATUS_RESOURCES)
    {
        RNDISMP_INCR_STAT(Adapter, SendMsgLowRes);
    }

    if ((SendStatus != NDIS_STATUS_RESOURCES) ||
        (Adapter->CurPendedMessages < 2))
    {
        if (Adapter->CurPendedMessages == Adapter->LoWatPendedMessages)
        {
            RNDISMP_RELEASE_ADAPTER_LOCK(Adapter);
            QueueMessageToMicroport(Adapter, NULL, FALSE);
        }
        else
        {
            RNDISMP_RELEASE_ADAPTER_LOCK(Adapter);
        }

        if (SendStatus == NDIS_STATUS_RESOURCES)
        {
            TRACE1(("RndisMSendComplete: Adapter %x, got resources\n", Adapter));
            SendStatus = NDIS_STATUS_SUCCESS;
        }

        if (pMsgFrame->pCallback)
        {
            (*pMsgFrame->pCallback)(pMsgFrame, SendStatus);
        }
        else
        {
            //
            //  Do nothing. The sender will take care of freeing
            //  this.
            //
        }
    }
    else
    {
        //
        //  The microport is out of send resources. Requeue this
        //  and adjust water marks.
        //
        InsertHeadList(&Adapter->WaitingMessageList, &pMsgFrame->PendLink);

        Adapter->HiWatPendedMessages = Adapter->CurPendedMessages;
        Adapter->LoWatPendedMessages = Adapter->CurPendedMessages / 2;

        TRACE1(("RndisMSendComplete: Adapter %x, new Hiwat %d, Lowat %d\n",
                Adapter, Adapter->HiWatPendedMessages, Adapter->LoWatPendedMessages));
        RNDISMP_RELEASE_ADAPTER_LOCK(Adapter);
    }
#else
    if (pMsgFrame->pCallback)
    {
        (*pMsgFrame->pCallback)(pMsgFrame, SendStatus);
    }
    else
    {
        //
        //  Do nothing. The sender will take care of freeing
        //  this.
        //
    }
#endif // THROTTLE_MESSAGES

} // RndisMSendComplete

/****************************************************************************/
/*                          InitCompletionMessage                           */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Completion message from microport in response to init message miniport  */
/*  sent. The init message was sent  from the adapter init routine which is */
/*  waiting for this event to unblock                                       */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Pointer to our adapter structure                             */
/*  pMessage - Pointer to RNDIS message                                     */
/*  pMdl - Pointer to MDL received from microport                           */
/*  TotalLength - length of complete message                                */
/*  MicroportMessageContext - context for message from micorport            */
/*  ReceiveStatus - used by microport to indicate it is low on resource     */
/*  bMessageCopied - is this a copy of the original message?                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  BOOLEAN - should the message be returned to the microport?              */
/*                                                                          */
/****************************************************************************/
BOOLEAN
InitCompletionMessage(IN PRNDISMP_ADAPTER   pAdapter,
                      IN PRNDIS_MESSAGE     pMessage,
                      IN PMDL               pMdl,
                      IN ULONG              TotalLength,
                      IN NDIS_HANDLE        MicroportMessageContext,
                      IN NDIS_STATUS        ReceiveStatus,
                      IN BOOLEAN            bMessageCopied)
{
    PRNDIS_INITIALIZE_COMPLETE  pInitCompleteMessage;
    PRNDISMP_MESSAGE_FRAME      pMsgFrame;
    PRNDISMP_REQUEST_CONTEXT    pReqContext;
    BOOLEAN                     bDiscardMsg = TRUE;

    TRACE2(("InitCompletionMessage\n"));

    do
    {
        if (pMessage->MessageLength < RNDISMP_MIN_MESSAGE_LENGTH(InitializeComplete))
        {
            TRACE1(("InitCompletion: Message length (%d) too short, expect at least (%d)\n",
                    pMessage->MessageLength,
                    RNDISMP_MIN_MESSAGE_LENGTH(InitializeComplete)));
            break;
        }

        if (pAdapter->pInitCompleteMessage == NULL)
        {
            TRACE1(("InitCompletion: multiple InitComplete from device, ignored\n"));
            break;
        }

        pInitCompleteMessage = RNDIS_MESSAGE_PTR_TO_MESSAGE_PTR(pMessage);

        // get request frame from request ID in message
        RNDISMP_LOOKUP_PENDING_MESSAGE(pMsgFrame, pAdapter, pInitCompleteMessage->RequestId);

        if (pMsgFrame == NULL)
        {
            // invalid request ID or aborted request.
            TRACE1(("Invalid request ID %d in Init Complete\n",
                    pInitCompleteMessage->RequestId));
            break;
        }

        pReqContext = pMsgFrame->pReqContext;

        RNDISMP_MOVE_MEM(pAdapter->pInitCompleteMessage,
                         pInitCompleteMessage,
                         sizeof(*pInitCompleteMessage));

        // signal the adapter init routine we are done
        NdisSetEvent(pReqContext->pEvent);

    }
    while (FALSE);

    return (bDiscardMsg);

} // InitCompletionMessage

/****************************************************************************/
/*                               HaltMessage                                */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Process a HALT message from the device.                                 */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Pointer to our Adapter structure                             */
/*  pMessage - pointer to RNDIS message                                     */
/*  pMdl - Pointer to MDL from microport                                    */
/*  TotalLength - length of complete message                                */
/*  MicroportMessageContext - context for message from microport            */
/*  ReceiveStatus - used by microport to indicate it is low on resource     */
/*  bMessageCopied - is this a copy of the original message?                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  BOOLEAN - should the message be returned to the microport?              */
/*                                                                          */
/****************************************************************************/
BOOLEAN
HaltMessage(IN PRNDISMP_ADAPTER   pAdapter,
            IN PRNDIS_MESSAGE     pMessage,
            IN PMDL               pMdl,
            IN ULONG              TotalLength,
            IN NDIS_HANDLE        MicroportMessageContext,
            IN NDIS_STATUS        ReceiveStatus,
            IN BOOLEAN            bMessageCopied)
{
    TRACE1(("HaltMessage: Adapter %x\n", pAdapter));

#ifndef BUILD_WIN9X
	// Not supported on Win98 Gold:
    NdisMRemoveMiniport(pAdapter->MiniportAdapterHandle);
#endif

    return TRUE;

} // HaltMessage

/****************************************************************************/
/*                          ResetCompletionMessage                          */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Completion message from microport in response to reset message miniport */
/*  sent. Indicate this completion message to the upper layers since        */
/*  the miniport reset routine indicated STATUS_PENDING to the upper layers */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Pointer to our Adapter structure                             */
/*  pMessage - pointer to RNDIS message                                     */
/*  pMdl - Pointer to MDL from microport                                    */
/*  TotalLength - length of complete message                                */
/*  MicroportMessageContext - context for message from microport            */
/*  ReceiveStatus - used by microport to indicate it is low on resource     */
/*  bMessageCopied - is this a copy of the original message?                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  BOOLEAN - should the message be returned to the microport?              */
/*                                                                          */
/****************************************************************************/
BOOLEAN
ResetCompletionMessage(IN PRNDISMP_ADAPTER   pAdapter,
                       IN PRNDIS_MESSAGE     pMessage,
                       IN PMDL               pMdl,
                       IN ULONG              TotalLength,
                       IN NDIS_HANDLE        MicroportMessageContext,
                       IN NDIS_STATUS        ReceiveStatus,
                       IN BOOLEAN            bMessageCopied)
{
    PRNDIS_RESET_COMPLETE   pResetMessage;
    BOOLEAN                 AddressingReset;
    NDIS_STATUS             Status;
    
    TRACE2(("ResetCompletionMessage\n"));

    pResetMessage = RNDIS_MESSAGE_PTR_TO_MESSAGE_PTR(pMessage);

    // save these parameters to call to upper layers
    Status = pResetMessage->Status;
    AddressingReset = (BOOLEAN)pResetMessage->AddressingReset;

    CompleteMiniportReset(pAdapter, Status, AddressingReset);

    return TRUE;

} // ResetCompletionMessage


/****************************************************************************/
/*                          KeepAliveCompletionMessage                      */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Completion message for a keep alive request send down by miniport       */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Pointer to our Adapter structure                             */
/*  pMessage - pointer to RNDIS message                                     */
/*  pMdl - Pointer to MDL from microport                                    */
/*  TotalLength - length of complete message                                */
/*  MicroportMessageContext - context for message from microport            */
/*  ReceiveStatus - used by microport to indicate it is low on resource     */
/*  bMessageCopied - is this a copy of the original message?                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  BOOLEAN - should the message be returned to the microport?              */
/*                                                                          */
/****************************************************************************/
BOOLEAN
KeepAliveCompletionMessage(IN PRNDISMP_ADAPTER   pAdapter,
                           IN PRNDIS_MESSAGE     pMessage,
                           IN PMDL               pMdl,
                           IN ULONG              TotalLength,
                           IN NDIS_HANDLE        MicroportMessageContext,
                           IN NDIS_STATUS        ReceiveStatus,
                           IN BOOLEAN            bMessageCopied)
{
    PRNDIS_KEEPALIVE_COMPLETE   pKeepaliveComplete;
    NDIS_STATUS                 Status;

    TRACE2(("KeepAliveCompletionMessage\n"));

    pKeepaliveComplete = RNDIS_MESSAGE_PTR_TO_MESSAGE_PTR(pMessage);

    // save off status
    Status = pKeepaliveComplete->Status;

    // grab the spinlock
    NdisAcquireSpinLock(&pAdapter->Lock);

    if (pKeepaliveComplete->RequestId != pAdapter->KeepAliveMessagePendingId)
    {
        TRACE0(("KeepAliveCompletion: Adapter %x, expected ID %x, got %x\n",
                pAdapter,
                pAdapter->KeepAliveMessagePendingId,
                pKeepaliveComplete->RequestId));
        //
        // TBD - should we set NeedReset?
    }

    pAdapter->KeepAliveMessagePending = FALSE;

    // if there are problems, tell the check for hang handler we need a reset
    if (Status != NDIS_STATUS_SUCCESS)
    {
        TRACE0(("KeepAliveCompletion: Adapter %x, err status %x from device\n",
                   pAdapter, Status));

        // indicate later from check for hang handler
        pAdapter->NeedReset = TRUE;
    }

    // release spinlock
    NdisReleaseSpinLock(&pAdapter->Lock);

    return TRUE;

} // KeepAliveCompletionMessage


/****************************************************************************/
/*                          KeepAliveMessage                                */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Process a keepalive message sent by the device. Send back a completion. */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Pointer to our Adapter structure                             */
/*  pMessage - pointer to RNDIS message                                     */
/*  pMdl - Pointer to MDL from microport                                    */
/*  TotalLength - length of complete message                                */
/*  MicroportMessageContext - context for message from microport            */
/*  ReceiveStatus - used by microport to indicate it is low on resource     */
/*  bMessageCopied - is this a copy of the original message?                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  BOOLEAN - should the message be returned to the microport?              */
/*                                                                          */
/****************************************************************************/
BOOLEAN
KeepAliveMessage(IN PRNDISMP_ADAPTER   pAdapter,
                 IN PRNDIS_MESSAGE     pMessage,
                 IN PMDL               pMdl,
                 IN ULONG              TotalLength,
                 IN NDIS_HANDLE        MicroportMessageContext,
                 IN NDIS_STATUS        ReceiveStatus,
                 IN BOOLEAN            bMessageCopied)
{
    PRNDIS_KEEPALIVE_REQUEST    pKeepalive;
    PRNDISMP_MESSAGE_FRAME      pMsgFrame;

    TRACE2(("KeepAliveMessage\n"));

    pKeepalive = RNDIS_MESSAGE_PTR_TO_MESSAGE_PTR(pMessage);

    //
    //  Send a response if we can.
    //
    pMsgFrame = BuildRndisMessageCommon(pAdapter,
                                        NULL,
                                        REMOTE_NDIS_KEEPALIVE_CMPLT,
                                        0,
                                        &pKeepalive->RequestId,
                                        sizeof(pKeepalive->RequestId));
    if (pMsgFrame != NULL)
    {
        // send the message to the microport.
        RNDISMP_SEND_TO_MICROPORT(pAdapter, pMsgFrame, FALSE, NULL);
    }
    else
    {
        TRACE1(("KeepAlive: Adapter %x: failed to alloc response!\n", pAdapter));
    }

    return TRUE;

} // KeepAliveMessage
                      

/****************************************************************************/
/*                          RndismpShutdownHandler                          */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Removes an adapter instance that was previously initialized. Since the  */
/*  system is shutting down there is no need to release resources, just     */
/*  shutdown receive.                                                       */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  MiniportAdapterContext - a context version of our Adapter pointer       */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
RndismpShutdownHandler(IN NDIS_HANDLE MiniportAdapterContext)
{
    PRNDISMP_ADAPTER            Adapter;

    // get adapter context
    Adapter = PRNDISMP_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

    TRACE1(("RndismpShutdownHandler\n"));
} // RndismpShutdownHandler


//
// Interrupt routines, stubbed up for now, we don't need them
//

/****************************************************************************/
/*                          RndismpDisableInterrupt                         */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  MiniportAdapterContext - a context version of our Adapter pointer       */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   VOID                                                                   */
/*                                                                          */
/****************************************************************************/
VOID
RndismpDisableInterrupt(IN NDIS_HANDLE MiniportAdapterContext)
{

    // NOP

} // RndismpDisableInterrupt


/****************************************************************************/
/*                          RndismpEnableInterrupt                          */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  MiniportAdapterContext - a context version of our Adapter pointer       */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   VOID                                                                   */
/*                                                                          */
/****************************************************************************/
VOID
RndismpEnableInterrupt(IN NDIS_HANDLE MiniportAdapterContext)
{

    // NOP

} // RndismpEnableInterrupt

/****************************************************************************/
/*                          RndismpHandleInterrupt                          */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  MiniportAdapterContext - a context version of our Adapter pointer       */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   VOID                                                                   */
/*                                                                          */
/****************************************************************************/
VOID
RndismpHandleInterrupt(IN NDIS_HANDLE MiniportAdapterContext)
{

    // NOP

} // RndismpHandleInterrupt

/****************************************************************************/
/*                          RndismpIsr                                      */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  This is the interrupt handler which is registered with the operating    */
/*  system. If several are pending (i.e. transmit complete and receive),    */
/*  handle them all.  Block new interrupts until all pending interrupts     */
/*  are handled.                                                            */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  InterruptRecognized - Boolean value which returns TRUE if the           */
/*      ISR recognizes the interrupt as coming from this adapter.           */
/*                                                                          */
/*  QueueDpc - TRUE if a DPC should be queued.                              */
/*                                                                          */
/*  Context - pointer to the adapter object                                 */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   VOID                                                                   */
/*                                                                          */
/****************************************************************************/
VOID
RndismpIsr(OUT PBOOLEAN InterruptRecognized,
           OUT PBOOLEAN QueueDpc,
           IN  PVOID    Context)
{

    ASSERT(FALSE); // don't expect to be called here.

} // RndismpIsr

/****************************************************************************/
/*                          CompleteSendHalt                                */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Utility function to handle completion of sending of a HALT message.     */
/*  We simply wake up the thread waiting for this.                          */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pMsgFrame - Frame structure describing the HALT message                 */
/*  SendStatus - outcome of sending this message.                           */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   VOID                                                                   */
/*                                                                          */
/****************************************************************************/
VOID
CompleteSendHalt(IN PRNDISMP_MESSAGE_FRAME pMsgFrame,
                 IN NDIS_STATUS SendStatus)
{
    PRNDISMP_ADAPTER        pAdapter;

    pAdapter = pMsgFrame->pAdapter;

    TRACE1(("CompleteSendHalt: Adapter %x, SendStatus %x\n", pAdapter, SendStatus));

    ASSERT(pAdapter->Halting);

    DereferenceMsgFrame(pMsgFrame);

    NdisSetEvent(&pAdapter->HaltWaitEvent);
} // CompleteSendHalt


/****************************************************************************/
/*                          CompleteSendReset                               */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Callback routine to handle send-completion of a reset message by the    */
/*  microport.                                                              */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pMsgFrame - Pointer to message frame for the Reset.                     */
/*  SendStatus - Status of send                                             */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
CompleteSendReset(IN PRNDISMP_MESSAGE_FRAME pMsgFrame,
                  IN NDIS_STATUS SendStatus)
{
    PRNDISMP_ADAPTER        pAdapter;

    pAdapter = pMsgFrame->pAdapter;

    TRACE1(("CompleteSendReset: Adapter %x, SendStatus %x\n",
            pAdapter, SendStatus));

    DereferenceMsgFrame(pMsgFrame);

    if (SendStatus != NDIS_STATUS_SUCCESS)
    {
        CompleteMiniportReset(pAdapter, SendStatus, FALSE);
    }
}


/****************************************************************************/
/*                          CompleteMiniportReset                           */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Utility function to complete a pending NDIS Reset. We complete any      */
/*  pending requests/sets before indicating reset complete to NDIS.         */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Pointer to our adapter structure                             */
/*  ResetStatus - to be used for completing reset                           */
/*  AddressingReset - Do we need filters to be resent to us?                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   VOID                                                                   */
/*                                                                          */
/****************************************************************************/
VOID
CompleteMiniportReset(IN PRNDISMP_ADAPTER pAdapter,
                      IN NDIS_STATUS ResetStatus,
                      IN BOOLEAN AddressingReset)
{
    LIST_ENTRY              PendingRequests;
    PLIST_ENTRY             pEntry, pNext;
    PRNDISMP_MESSAGE_FRAME  pMsgFrame;

    do
    {
        if (!pAdapter->ResetPending)
        {
            break;
        }

        pAdapter->ResetPending = FALSE;
        
        //
        //  Take out all pending requests/sets queued on the adapter.
        //
        InitializeListHead(&PendingRequests);

        RNDISMP_ACQUIRE_ADAPTER_LOCK(pAdapter);

        for (pEntry = pAdapter->PendingFrameList.Flink;
             pEntry != &pAdapter->PendingFrameList;
             pEntry = pNext)
        {
            pNext = pEntry->Flink;
            pMsgFrame = CONTAINING_RECORD(pEntry, RNDISMP_MESSAGE_FRAME, Link);
            if (pMsgFrame->NdisMessageType == REMOTE_NDIS_QUERY_MSG ||
                pMsgFrame->NdisMessageType == REMOTE_NDIS_SET_MSG)
            {
                RemoveEntryList(pEntry);
                InsertTailList(&PendingRequests, pEntry);

                TRACE0(("RNDISMP: ResetComplete: taking out MsgFrame %x, msg type %x\n",
                        pMsgFrame, pMsgFrame->NdisMessageType));

            }
        }

        RNDISMP_RELEASE_ADAPTER_LOCK(pAdapter);

        //
        //  Complete all these requests.
        //
        for (pEntry = PendingRequests.Flink;
             pEntry != &PendingRequests;
             pEntry = pNext)
        {
            pNext = pEntry->Flink;
            pMsgFrame = CONTAINING_RECORD(pEntry, RNDISMP_MESSAGE_FRAME, Link);

            TRACE0(("RNDISMP: ResetComplete: completing MsgFrame %x, msg type %x\n",
                    pMsgFrame, pMsgFrame->NdisMessageType));

            ASSERT(pMsgFrame->pReqContext != NULL);

            if (pMsgFrame->pReqContext->pNdisRequest != NULL)
            {
                //
                //  This request came down thru our MiniportCoRequest handler.
                //
                NdisMCoRequestComplete(NDIS_STATUS_REQUEST_ABORTED,
                                       pAdapter->MiniportAdapterHandle,
                                       pMsgFrame->pReqContext->pNdisRequest);
            }
            else
            {
                //
                //  This request came thru our connectionless query/set handler.
                //
                if (pMsgFrame->NdisMessageType == REMOTE_NDIS_QUERY_MSG)
                {
                    NdisMQueryInformationComplete(pAdapter->MiniportAdapterHandle,
                                                  NDIS_STATUS_REQUEST_ABORTED);
                }
                else
                {
                    ASSERT(pMsgFrame->NdisMessageType == REMOTE_NDIS_SET_MSG);
                    NdisMSetInformationComplete(pAdapter->MiniportAdapterHandle,
                                                NDIS_STATUS_REQUEST_ABORTED);
                }
            }

            FreeRequestContext(pAdapter, pMsgFrame->pReqContext);
            pMsgFrame->pReqContext = (PRNDISMP_REQUEST_CONTEXT)UlongToPtr(0xabababab);
            DereferenceMsgFrame(pMsgFrame);
        }

        TRACE0(("Completing reset on Adapter %x, Status %x, AddressingReset %d\n",
                    pAdapter, ResetStatus, AddressingReset));

        RNDISMP_INCR_STAT(pAdapter, Resets);

        //
        //  Complete the reset now.
        //
        NdisMResetComplete(pAdapter->MiniportAdapterHandle,
                           ResetStatus,
                           AddressingReset);
    }
    while (FALSE);
}



/****************************************************************************/
/*                     ReadAndSetRegistryParameters                         */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  This is called when initializing a device, to read and send any         */
/*  registry parameters applicable to this device.                          */
/*                                                                          */
/*  We go through the entire list of configurable parameters by walking     */
/*  subkeys under the "ndi\Params" key. Each subkey represents one          */
/*  parameter. Using information about this parameter (specifically, its    */
/*  name and type), we query its value, and send a SetRequest to the        */
/*  device.                                                                 */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Pointer to adapter structure for the device                  */
/*  ConfigurationContext - NDIS handle to access registry for this device   */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   NDIS_STATUS                                                            */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
ReadAndSetRegistryParameters(IN PRNDISMP_ADAPTER pAdapter,
                             IN NDIS_HANDLE ConfigurationContext)
{
    NDIS_STATUS                 Status;
    NDIS_HANDLE                 ConfigHandle;
    NDIS_STRING                 NdiKeyName = NDIS_STRING_CONST("Ndi");
    NDIS_HANDLE                 NdiKeyHandle = NULL;

    Status = NDIS_STATUS_SUCCESS;
    ConfigHandle = NULL;

    do
    {
        NdisOpenConfiguration(&Status,
                              &ConfigHandle,
                              ConfigurationContext);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        NdisOpenConfigurationKeyByName(
            &Status,
            ConfigHandle,
            &NdiKeyName,
            &NdiKeyHandle);
        
        if (Status == NDIS_STATUS_SUCCESS)
        {
            NDIS_STRING     ParamsKeyName = NDIS_STRING_CONST("Params");
            NDIS_HANDLE     ParamsKeyHandle = NULL;

            NdisOpenConfigurationKeyByName(
                &Status,
                NdiKeyHandle,
                &ParamsKeyName,
                &ParamsKeyHandle);
            
            if (Status == NDIS_STATUS_SUCCESS)
            {
                ULONG   i;
                BOOLEAN bDone = FALSE;

                //
                //  Iterate through all subkeys under ndi\Params:
                //
                for (i = 0; !bDone; i++)
                {
                    NDIS_STRING     ParamSubKeyName;
                    NDIS_HANDLE     ParamSubKeyHandle;
                    NDIS_STRING     ParamTypeName = NDIS_STRING_CONST("type");
                    PNDIS_CONFIGURATION_PARAMETER    pConfigParameter;

                    ParamSubKeyName.Length =
                    ParamSubKeyName.MaximumLength = 0;
                    ParamSubKeyName.Buffer = NULL;

                    NdisOpenConfigurationKeyByIndex(
                        &Status,
                        ParamsKeyHandle,
                        i,
                        &ParamSubKeyName,
                        &ParamSubKeyHandle);
                   
                    if (Status != NDIS_STATUS_SUCCESS)
                    {
                        //
                        //  Done with parameters. Cook return value.
                        //
                        Status = NDIS_STATUS_SUCCESS;
                        break;
                    }

                    //
                    //  Got the handle to a subkey under ndi\Params,
                    //  now read the type information for this parameter.
                    //

#ifndef BUILD_WIN9X
                    TRACE3(("ReadAndSetRegParams: subkey %d under ndi\\params: %ws\n",
                        i, ParamSubKeyName.Buffer));
#else
                    //
                    //  Handle Win98Gold behavior.
                    //
                    if (ParamSubKeyName.Buffer == NULL)
                    {
                        PNDIS_STRING    pNdisString;

                        pNdisString = *(PNDIS_STRING *)&ParamSubKeyName;
                        ParamSubKeyName = *pNdisString;
                    }

                    TRACE2(("ReadAndSetRegParams: subkey %d under ndi\\params: %ws\n",
                        i, ParamSubKeyName.Buffer));
#endif

                    //
                    //  We have a parameter name now, in ParamSubKeyName.
                    //  Get its type information.
                    //
                    NdisReadConfiguration(
                        &Status,
                        &pConfigParameter,
                        ParamSubKeyHandle,
                        &ParamTypeName,
                        NdisParameterString);
                    
                    if (Status == NDIS_STATUS_SUCCESS)
                    {
                        TRACE2(("ReadAndSetRegParams: Adapter %p, type is %ws\n",
                            pAdapter,
                            pConfigParameter->ParameterData.StringData.Buffer));

                        //
                        //  Send off a Set Request for this
                        //  parameter to the device.
                        //

                        Status = SendConfiguredParameter(
                                        pAdapter,
                                        ConfigHandle,
                                        &ParamSubKeyName,
                                        &pConfigParameter->ParameterData.StringData);

                        if (Status != NDIS_STATUS_SUCCESS)
                        {
                            TRACE0(("ReadAndSetRegParams: Adapter %p, failed %x\n",
                                pAdapter, Status));
                            bDone = TRUE;
                        }
                        else
                        {
                            NDIS_STRING     NetworkAddressName =
                                        NDIS_STRING_CONST("NetworkAddress");

                            //
                            //  Special case for the "NetworkAddress"
                            //  parameter - if we just set this successfully,
                            //  make note of the fact.
                            //
                            if (NdisEqualString(&ParamSubKeyName,
                                                &NetworkAddressName,
                                                TRUE))
                            {
                                TRACE1(("ReadAndSetRegParams: Adapter %p,"
                                        " supports MAC address overwrite\n",
                                        pAdapter));

                                pAdapter->MacOptions |=
                                    NDIS_MAC_OPTION_SUPPORTS_MAC_ADDRESS_OVERWRITE;
                            }
                        }
    
                    }

                    //
                    //  Done with this subkey under ndi\Params.
                    //
                    NdisCloseConfiguration(ParamSubKeyHandle);

                } // for each subkey under ndi\Params

                //
                //  Done with "ndi\Params"
                //
                NdisCloseConfiguration(ParamsKeyHandle);
            }

            //
            //  Done with "ndi"
            //
            NdisCloseConfiguration(NdiKeyHandle);
        }

        //
        //  Done with configuration section for this device.
        //
        NdisCloseConfiguration(ConfigHandle);
    }
    while (FALSE);
   
    return (Status);
}


/****************************************************************************/
/*                     SendConfiguredParameter                              */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Read the value of the specified config parameter, format a SetRequest,  */
/*  send it to the device, and wait for a response.                         */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Pointer to adapter structure for the device                  */
/*  ConfigHandle - handle to configuration section for this device          */
/*  pParameterName - parameter key name                                     */
/*  pParameterType - parameter type                                         */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   NDIS_STATUS                                                            */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
SendConfiguredParameter(IN PRNDISMP_ADAPTER     pAdapter,
                        IN NDIS_HANDLE          ConfigHandle,
                        IN PNDIS_STRING         pParameterName,
                        IN PNDIS_STRING         pParameterType)
{
    PRNDISMP_MESSAGE_FRAME          pMsgFrame = NULL;
    PRNDISMP_MESSAGE_FRAME          pPendingMsgFrame = NULL;
    PRNDISMP_REQUEST_CONTEXT        pReqContext = NULL;
    NDIS_PARAMETER_TYPE             NdisParameterType;
    PNDIS_CONFIGURATION_PARAMETER   pConfigParameter;
    ULONG                           ParameterValueLength;
    PUCHAR                          pParameterValue;
    UINT32                          ParameterType;
    NDIS_EVENT                      Event;
    UINT                            BytesRead;
    BOOLEAN                         bWokenUp;
    RNDIS_REQUEST_ID                RequestId;

    PRNDIS_CONFIG_PARAMETER_INFO    pRndisConfigInfo = NULL;
    ULONG                           RndisConfigInfoLength;
    PUCHAR                          pConfigInfoBuf;
    NDIS_STATUS                     Status;

    struct {
        NDIS_STRING         TypeName;
        NDIS_PARAMETER_TYPE NdisType;
    } StringToNdisType[] =
        {
            {NDIS_STRING_CONST("int"), NdisParameterInteger},
            {NDIS_STRING_CONST("long"), NdisParameterInteger},
            {NDIS_STRING_CONST("word"), NdisParameterInteger},
            {NDIS_STRING_CONST("dword"), NdisParameterInteger},
            {NDIS_STRING_CONST("edit"), NdisParameterString},
            {NDIS_STRING_CONST("enum"), NdisParameterString}
        };

    ULONG                       NumTypes = sizeof(StringToNdisType);
    ULONG                       i;

    do
    {
        //
        //  Determine the parameter type.
        //
        for (i = 0; i < NumTypes; i++)
        {
            if (NdisEqualString(&StringToNdisType[i].TypeName,
                                pParameterType,
                                TRUE))
            {
                NdisParameterType = StringToNdisType[i].NdisType;
                break;
            }
        }

        if (i == NumTypes)
        {
            TRACE1(("SendConfiguredParam: Adapter %p, Param %ws, invalid type %ws\n",
                pAdapter,
                pParameterName->Buffer,
                pParameterType->Buffer));
            Status = NDIS_STATUS_INVALID_DATA;
            break;
        }

        NdisReadConfiguration(
            &Status,
            &pConfigParameter,
            ConfigHandle,
            pParameterName,
            NdisParameterType
            );

        if (Status != NDIS_STATUS_SUCCESS)
        {
            //
            //  It is okay for a parameter to not be configured.
            //
            Status = NDIS_STATUS_SUCCESS;
            break;
        }

        if (NdisParameterType == NdisParameterInteger)
        {
            ParameterValueLength = sizeof(UINT32);
            pParameterValue = (PUCHAR)&pConfigParameter->ParameterData.IntegerData;
            ParameterType = RNDIS_CONFIG_PARAM_TYPE_INTEGER;
        }
        else
        {
            ASSERT(NdisParameterType == NdisParameterString);
            ParameterValueLength = pConfigParameter->ParameterData.StringData.Length;
            pParameterValue = (PUCHAR)pConfigParameter->ParameterData.StringData.Buffer;
            ParameterType = RNDIS_CONFIG_PARAM_TYPE_STRING;
        }

        RndisConfigInfoLength = sizeof(RNDIS_CONFIG_PARAMETER_INFO) +
                                pParameterName->Length +
                                ParameterValueLength;

        Status = MemAlloc(&pRndisConfigInfo, RndisConfigInfoLength);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        pRndisConfigInfo->ParameterNameOffset = sizeof(RNDIS_CONFIG_PARAMETER_INFO);
        pRndisConfigInfo->ParameterNameLength = pParameterName->Length;
        pRndisConfigInfo->ParameterType = ParameterType;
        pRndisConfigInfo->ParameterValueOffset =
                    pRndisConfigInfo->ParameterNameOffset +
                    pRndisConfigInfo->ParameterNameLength;
        pRndisConfigInfo->ParameterValueLength = ParameterValueLength;

        //
        //  Copy in the parameter name.
        //
        pConfigInfoBuf = (PUCHAR)pRndisConfigInfo +
                          pRndisConfigInfo->ParameterNameOffset;
        
        RNDISMP_MOVE_MEM(pConfigInfoBuf, pParameterName->Buffer, pParameterName->Length);

        //
        //  Copy in the parameter value.
        //
        pConfigInfoBuf = (PUCHAR)pRndisConfigInfo +
                          pRndisConfigInfo->ParameterValueOffset;
        RNDISMP_MOVE_MEM(pConfigInfoBuf, pParameterValue, ParameterValueLength);

        //
        //  Build a Set Request
        //
        pMsgFrame = BuildRndisMessageCommon(pAdapter,
                                            NULL,
                                            REMOTE_NDIS_SET_MSG,
                                            OID_GEN_RNDIS_CONFIG_PARAMETER,
                                            pRndisConfigInfo,
                                            RndisConfigInfoLength);

        if (pMsgFrame == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

#if DBG
        {
            PMDL    pTmpMdl = pMsgFrame->pMessageMdl;
            ULONG   Length;
            PUCHAR  pBuf;
            ULONG   OldDebugFlags = RndismpDebugFlags;

            Length = MmGetMdlByteCount(pTmpMdl);
            pBuf = MmGetSystemAddressForMdl(pTmpMdl);

            RndismpDebugFlags |= DBG_DUMP;
            TRACEDUMP(("SetRequest (OID_GEN_RNDIS_CONFIG_PARAMETER):"
                " Adapter %p, Param %ws\n", pAdapter, pParameterName->Buffer), pBuf, Length);
            RndismpDebugFlags = OldDebugFlags;
        }
#endif

        pReqContext = AllocateRequestContext(pAdapter);
        if (pReqContext == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        // Fill up the request context.

        pReqContext->pNdisRequest = NULL;
        pReqContext->Oid = OID_GEN_RNDIS_CONFIG_PARAMETER;

        NdisInitializeEvent(&Event);
        pReqContext->pEvent = &Event;
        pReqContext->bInternal = TRUE;
        pReqContext->pBytesRead = &BytesRead;
        pReqContext->InformationBufferLength = RndisConfigInfoLength;

        pMsgFrame->pVc = NULL;
        pMsgFrame->pReqContext = pReqContext;

        // save off the request Id.
        RequestId = pMsgFrame->RequestId;

        // send the message to the microport.
        RNDISMP_SEND_TO_MICROPORT(pAdapter, pMsgFrame, TRUE, NULL);

        RNDISMP_ASSERT_AT_PASSIVE();
        bWokenUp = NdisWaitEvent(&Event, MINIPORT_INIT_TIMEOUT);

        // remove the message from the pending queue - it may or may not be there.
        RNDISMP_LOOKUP_PENDING_MESSAGE(pPendingMsgFrame, pAdapter, RequestId);


        if (!bWokenUp)
        {
            TRACE1(("No response to set parameter, Adapter %x\n", pAdapter));
            Status = NDIS_STATUS_DEVICE_FAILED; 
        }
        else
        {
            Status = pReqContext->CompletionStatus;
            TRACE1(("Got response to set config param, Status %x, %d bytes read\n",
                        Status, BytesRead));
        }

    }
    while (FALSE);

    if (pRndisConfigInfo)
    {
        MemFree(pRndisConfigInfo, RndisConfigInfoLength);
    }

    if (pMsgFrame)
    {
        DereferenceMsgFrame(pMsgFrame);
    }

    if (pReqContext)
    {
        FreeRequestContext(pAdapter, pReqContext);
    }

    return (Status);
}


#ifdef NDIS51_MINIPORT
/****************************************************************************/
/*                          RndismpPnPEventNotify                           */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Entry point called by NDIS to notify us of PnP events affecting our     */
/*  device. The main event of importance to us is surprise removal.         */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Pointer to adapter structure                                 */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  NDIS_STATUS                                                             */
/*                                                                          */
/****************************************************************************/
VOID
RndismpPnPEventNotify(IN NDIS_HANDLE MiniportAdapterContext,
                      IN NDIS_DEVICE_PNP_EVENT EventCode,
                      IN PVOID InformationBuffer,
                      IN ULONG InformationBufferLength)
{
    PRNDISMP_ADAPTER        pAdapter;

    // get adapter context
    pAdapter = PRNDISMP_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

    CHECK_VALID_ADAPTER(pAdapter);

    TRACE3(("PnPEventNotify: Adapter %x\n", pAdapter));


    switch (EventCode)
    {
        case NdisDevicePnPEventSurpriseRemoved:
            TRACE1(("PnPEventNotify: Adapter %p, surprise remove\n", pAdapter));
            RndismpInternalHalt(pAdapter, FALSE);
            break;

        default:
            break;
    }

} // RndismpPnPEventNotify

#endif // NDIS51_MINIPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rndis\rndismp\win2k\makefile.inc ===
clean: 
    del $(O)\rmdat.h $(O)\rndismp.bmf

$(O)\rndismp.mof: ..\rndismp.mof

$(O)\rmdat.h: $(O)\rndismp.bmf
    wmimofck -h$(O)\rmdat.h $(O)\rndismp.bmf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rndis\rndismp\rndismp.h ===
/***************************************************************************

Copyright (c) 1999  Microsoft Corporation

Module Name:

    RNDISMP.H

Abstract:

    Header file for Remote NDIS Miniport driver. Sits on top of Remote 
    NDIS bus specific layers.

Environment:

    kernel mode only

Notes:

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

    Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    5/6/99 : created

Author:

    Tom Green

    
****************************************************************************/

#ifndef _RNDISMP_H_
#define _RNDISMP_H_

#ifndef OID_GEN_RNDIS_CONFIG_PARAMETER
#define OID_GEN_RNDIS_CONFIG_PARAMETER          0x0001021B  // Set only
#endif


//
// DEBUG stuff
//

#if DBG


//
// Definitions for all of the Debug macros.  If we're in a debug (DBG) mode,
// these macros will print information to the debug terminal.  If the
// driver is compiled in a free (non-debug) environment the macros become
// NOPs.
//

VOID
NTAPI
DbgBreakPoint(VOID);

//
// DEBUG enable bit definitions
//
#define DBG_LEVEL0          0x1000      // Display TRACE0 messages
#define DBG_LEVEL1          0x0001      // Display TRACE1 messages
#define DBG_LEVEL2          0x0002      // Display TRACE2 messages
#define DBG_LEVEL3          0x0004      // Display TRACE3 messages
#define DBG_OID_LIST        0x0008      // display OID list
#define DBG_OID_NAME        0x0010      // display name of OID in query and set routines
#define DBG_DUMP            0x0020      // Display buffer dumps
#define DBG_LOG_SENDS       0x0100      // Log sent messages.

#define TRACE0(S)     {if(RndismpDebugFlags & DBG_LEVEL0) {DbgPrint("RNDISMP: "); DbgPrint S;}}
#define TRACE1(S)     {if(RndismpDebugFlags & DBG_LEVEL1) {DbgPrint("RNDISMP: "); DbgPrint S;}}
#define TRACE2(S)     {if(RndismpDebugFlags & DBG_LEVEL2) {DbgPrint("RNDISMP: "); DbgPrint S;}}
#define TRACE3(S)     {if(RndismpDebugFlags & DBG_LEVEL3) {DbgPrint("RNDISMP: "); DbgPrint S;}}

#define TRACEDUMP(_s, _buf, _len)     {if(RndismpDebugFlags & DBG_DUMP) {DbgPrint("RNDISMP: "); DbgPrint _s; RndisPrintHexDump(_buf, _len);}}

#define DISPLAY_OID_LIST(Adapter)   DisplayOidList(Adapter)

#define GET_OID_NAME(Oid)           GetOidName(Oid)

#define OID_NAME_TRACE(Oid, s)                                 \
{                                                               \
    if(RndismpDebugFlags & DBG_OID_NAME)                        \
        DbgPrint("RNDISMP: %s: (%s)  (%08X)\n", s, GET_OID_NAME(Oid), Oid);     \
}

#undef ASSERT
#define ASSERT(exp)                                             \
{                                                               \
    if(!(exp))                                                  \
    {                                                           \
        DbgPrint("Assertion Failed: %s:%d %s\n",                \
                 __FILE__,__LINE__,#exp);                       \
        DbgBreakPoint();                                        \
    }                                                           \
}

#define DBGINT(S)                                               \
{                                                               \
    DbgPrint("%s:%d - ", __FILE__, __LINE__);                   \
    DbgPrint S;                                                 \
    DbgBreakPoint();                                            \
}


// check frame for problems
#define CHECK_VALID_FRAME(Frame)                                \
{                                                               \
    ASSERT(Frame);                                              \
    if(Frame)                                                   \
    {                                                           \
        if(Frame->Signature != FRAME_SIGNATURE)                 \
        {                                                       \
            DbgPrint("RNDISMP: Invalid Frame (%p) Signature: %s:%d\n",\
                    Frame, __FILE__,__LINE__);                  \
            DbgBreakPoint();                                    \
        }                                                       \
    }                                                           \
}

// check adapter for problems
#define CHECK_VALID_ADAPTER(Adapter)                            \
{                                                               \
    ASSERT(Adapter);                                            \
    if(Adapter)                                                 \
    {                                                           \
        if(Adapter->Signature != ADAPTER_SIGNATURE)             \
        {                                                       \
            DbgPrint("RNDISMP: Invalid Adapter Signature: %s:%d\n",\
                     __FILE__,__LINE__);                        \
            DbgBreakPoint();                                    \
        }                                                       \
    }                                                           \
}

// check block for problems
#define CHECK_VALID_BLOCK(Block)                                \
{                                                               \
    ASSERT(Block);                                              \
    if(Block)                                                   \
    {                                                           \
        if(Block->Signature != BLOCK_SIGNATURE)                 \
        {                                                       \
            DbgPrint("RNDISMP: Invalid Block Signature: %s:%d\n",\
                     __FILE__,__LINE__);                        \
            DbgBreakPoint();                                    \
        }                                                       \
    }                                                           \
}


#define RNDISMP_ASSERT_AT_PASSIVE()                             \
{                                                               \
    KIRQL Irql = KeGetCurrentIrql();                            \
    if (Irql != PASSIVE_LEVEL)                                  \
    {                                                           \
        DbgPrint("RNDISMP: found IRQL %d instead of passive!\n", Irql); \
        DbgPrint("RNDISMP: at line %d, file %s\n", __LINE__, __FILE__); \
        DbgBreakPoint();                                        \
    }                                                           \
}


#define RNDISMP_ASSERT_AT_DISPATCH()                            \
{                                                               \
    KIRQL Irql = KeGetCurrentIrql();                            \
    if (Irql != DISPATCH_LEVEL)                                 \
    {                                                           \
        DbgPrint("RNDISMP: found IRQL %d instead of dispatch!\n", Irql); \
        DbgPrint("RNDISMP: at line %d, file %s\n", __LINE__, __FILE__); \
        DbgBreakPoint();                                        \
    }                                                           \
}


#define DBG_LOG_SEND_MSG(_pAdapter, _pMsgFrame)                 \
{                                                               \
    if (RndismpDebugFlags & DBG_LOG_SENDS)                      \
    {                                                           \
        RndisLogSendMessage(_pAdapter, _pMsgFrame);             \
    }                                                           \
}

#else // !DBG


#define TRACE0(S)
#define TRACE1(S)
#define TRACE2(S)
#define TRACE3(S)
#define TRACEDUMP(_s, _buf, _len)

#undef ASSERT
#define ASSERT(exp)

#define DBGINT(S)

#define CHECK_VALID_FRAME(Frame)
#define CHECK_VALID_ADAPTER(Adapter)
#define CHECK_VALID_BLOCK(Block)
#define DISPLAY_OID_LIST(Adapter)
#define OID_NAME_TRACE(Oid, s)

#define RNDISMP_ASSERT_AT_PASSIVE()
#define RNDISMP_ASSERT_AT_DISPATCH()

#define DBG_LOG_SEND_MSG(_pAdapter, _pMsgFrame)
#endif //DBG


//
// Defines
//

#define MINIMUM_ETHERNET_PACKET_SIZE            60
#define MAXIMUM_ETHERNET_PACKET_SIZE            1514
#define NUM_BYTES_PROTOCOL_RESERVED_SECTION     (4*sizeof(PVOID))
#define ETHERNET_HEADER_SIZE                    14

#define INITIAL_RECEIVE_FRAMES                  20
#define MAX_RECEIVE_FRAMES                      400

// this is the size of the buffer we will use to pass Data packet header data
// to the remote device.
#define RNDIS_PACKET_MESSAGE_HEADER_SIZE        128

// align all RNDIS packets on 4 byte boundaries
#define RNDIS_PACKET_MESSAGE_BOUNDARY           (4)

#define ONE_SECOND                              1000 // in milliseconds

#define KEEP_ALIVE_TIMER                        (5 * ONE_SECOND)

#define REQUEST_TIMEOUT                         (10 * ONE_SECOND)

#define FRAME_SIGNATURE                         ((ULONG)('GSRF'))
#define ADAPTER_SIGNATURE                       ((ULONG)('GSDA'))
#define BLOCK_SIGNATURE                         ((ULONG)('GSLB'))

#define RNDISMP_TAG_GEN_ALLOC                   ((ULONG)(' MNR'))
#define RNDISMP_TAG_SEND_FRAME                  ((ULONG)('sMNR'))
#define RNDISMP_TAG_RECV_DATA_FRAME             ((ULONG)('rMNR'))

#if DBG
#define MINIPORT_INIT_TIMEOUT                   (10 * ONE_SECOND)
#define MINIPORT_HALT_TIMEOUT                   (5 * ONE_SECOND)
#else
#define MINIPORT_INIT_TIMEOUT                   (5 * ONE_SECOND)
#define MINIPORT_HALT_TIMEOUT                   (2 * ONE_SECOND)
#endif

#ifndef MAX
#define MAX(a, b)   (((a) > (b)) ? (a) : (b))
#endif

// flags for driver and device supported OIDs
#define OID_NOT_SUPPORTED       0x0000
#define DRIVER_SUPPORTED_OID    0x0001
#define DEVICE_SUPPORTED_OID    0x0002


//
// Defines for OID_GEN_MAC_OPTIONS - most of the bits returned
// in response to this query are driver-specific, however some
// are device-specific.
//
#define RNDIS_DRIVER_MAC_OPTIONS        (NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA  | \
                                         NDIS_MAC_OPTION_TRANSFERS_NOT_PEND |   \
                                         NDIS_MAC_OPTION_NO_LOOPBACK)

#define RNDIS_DEVICE_MAC_OPTIONS_MASK   NDIS_MAC_OPTION_8021P_PRIORITY

//
// Data structures
//

typedef NDIS_SPIN_LOCK          RNDISMP_SPIN_LOCK;


#ifdef BUILD_WIN9X

//
//  Equivalents of types defined for Win9X config mgr.
//
typedef ULONG           MY_CONFIGRET;
typedef ULONG           MY_DEVNODE;
typedef ULONG           MY_CONFIGFUNC;
typedef ULONG           MY_SUBCONFIGFUNC;
typedef MY_CONFIGRET    (_cdecl *MY_CMCONFIGHANDLER)(MY_CONFIGFUNC, MY_SUBCONFIGFUNC, MY_DEVNODE, ULONG, ULONG);

#define MY_CR_SUCCESS           0x00000000
#define MY_CONFIG_PREREMOVE     0x0000000C
#define MY_CONFIG_PRESHUTDOWN   0x00000012

#endif

//
// This structure contains information about a specific
// microport the miniport sits on top of. One of these
// per microport
//
typedef struct _DRIVER_BLOCK 
{
    // NDIS wrapper handle from NdisInitializeWrapper
    NDIS_HANDLE                 NdisWrapperHandle;

    // The NDIS version we manage to register this miniport instance as.
    UCHAR                       MajorNdisVersion;
    UCHAR                       MinorNdisVersion;

    struct _DRIVER_BLOCK       *NextDriverBlock;

    // pointer to driver object this block is associated with
    PDRIVER_OBJECT              DriverObject;
    // intercepted dispatch function for IRP_MJ_PNP
    PDRIVER_DISPATCH            SavedPnPDispatch;

    // Handlers registered by Remote NDIS microport
    RM_DEVICE_INIT_HANDLER      RmInitializeHandler;
    RM_DEVICE_INIT_CMPLT_NOTIFY_HANDLER RmInitCompleteNotifyHandler;
    RM_DEVICE_HALT_HANDLER      RmHaltHandler;
    RM_SHUTDOWN_HANDLER         RmShutdownHandler;
    RM_UNLOAD_HANDLER           RmUnloadHandler;
    RM_SEND_MESSAGE_HANDLER     RmSendMessageHandler;
    RM_RETURN_MESSAGE_HANDLER   RmReturnMessageHandler;

    // "Global" context for Microport
    PVOID                       MicroportContext;
    
    // list of adapters registered for this Miniport driver.
    struct _RNDISMP_ADAPTER    *AdapterList;

    // number of adapters in use with this driver block
    ULONG                       NumberAdapters;

    // sanity check
    ULONG                       Signature;
} DRIVER_BLOCK, *PDRIVER_BLOCK;



typedef
VOID
(*PRNDISMP_MSG_COMPLETE_HANDLER) (
    IN  struct _RNDISMP_MESSAGE_FRAME *     pMsgFrame,
    IN  NDIS_STATUS                         Status
    );



typedef
BOOLEAN
(*PRNDISMP_MSG_HANDLER_FUNC) (
    IN  struct _RNDISMP_ADAPTER *   pAdapter,
    IN  PRNDIS_MESSAGE              pMessage,
    IN  PMDL                        pMdl,
    IN  ULONG                       TotalLength,
    IN  NDIS_HANDLE                 MicroportMessageContext,
    IN  NDIS_STATUS                 ReceiveStatus,
    IN  BOOLEAN                     bMessageCopied
    );

//
// One of these structures for each NDIS_PACKET that we send.
//
typedef struct _RNDISMP_PACKET_WRAPPER
{
    struct _RNDISMP_MESSAGE_FRAME * pMsgFrame;
    PNDIS_PACKET                    pNdisPacket;
    struct _RNDISMP_VC *            pVc;

    // MDL to describe the RNDIS NdisPacket header:
    PMDL                            pHeaderMdl;

    // Last MDL in the list of MDLs describing this RNDIS packet.
    PMDL                            pTailMdl;

    // Space for the RNDIS Packet header:
    UCHAR                           Packet[sizeof(PVOID)];
} RNDISMP_PACKET_WRAPPER, *PRNDISMP_PACKET_WRAPPER;


//
// Structure used to overlay the MiniportReserved field
// of outgoing (sent) packets. 
//
typedef struct _RNDISMP_SEND_PKT_RESERVED 
{
    // Points to the next packet for multi-packet sends.
    PNDIS_PACKET                    pNext;

    // Points to more detailed information about this packet, too much
    // to fit into one PVOID.
    PRNDISMP_PACKET_WRAPPER         pPktWrapper;
} RNDISMP_SEND_PKT_RESERVED, *PRNDISMP_SEND_PKT_RESERVED;


//
// Structure used to TEMPORARILY overlay the MiniportReserved field
// of sent packets -- this is used to link packets in a list pending
// actual transmission from a timeout routine.
//
typedef struct _RNDISMP_SEND_PKT_RESERVED_TEMP
{
    LIST_ENTRY                      Link;
} RNDISMP_SEND_PKT_RESERVED_TEMP, *PRNDISMP_SEND_PKT_RESERVED_TEMP;


//
// Request context - holds information about a pended request (Set or Query)
//
typedef struct _RNDISMP_REQUEST_CONTEXT
{
    PNDIS_REQUEST                   pNdisRequest;
    struct _RNDISMP_VC *            pVc;
    NDIS_OID                        Oid;
    PVOID                           InformationBuffer;
    UINT                            InformationBufferLength;
    PUINT                           pBytesRead;     // for Set
    PUINT                           pBytesWritten;  // for Query
    PUINT                           pBytesNeeded;
    BOOLEAN                         bInternal;
    NDIS_STATUS                     CompletionStatus;
    ULONG                           RetryCount;
    PNDIS_EVENT                     pEvent;
} RNDISMP_REQUEST_CONTEXT, *PRNDISMP_REQUEST_CONTEXT;

//
// Message Frame - generic structure to hold context about all
// messages sent via the microport.
//
typedef struct _RNDISMP_MESSAGE_FRAME
{
    LIST_ENTRY                      Link;           // used to queue this if
                                                    // a response is expected
                                                    // from the device.
    ULONG                           RefCount;       // Determines when to free
                                                    // this message frame.
    struct _RNDISMP_ADAPTER *       pAdapter;
    struct _RNDISMP_VC *            pVc;
    union
    {
        PNDIS_PACKET                pNdisPacket;    // if DATA message
        PRNDISMP_REQUEST_CONTEXT    pReqContext;    // if Request message
    };
    PMDL                            pMessageMdl;    // what goes to the microport
    UINT32                          NdisMessageType;// copied from the RNDIS message
    UINT32                          RequestId;      // to match requests/responses

    PRNDISMP_MSG_COMPLETE_HANDLER   pCallback;      // called on completion of message send

    ULONG                           TicksOnQueue;
    ULONG                           TimeSent;
#if THROTTLE_MESSAGES
    LIST_ENTRY                      PendLink;       // used to queue this
                                                    // pending send to microport
#endif
    ULONG                           Signature;
} RNDISMP_MESSAGE_FRAME, *PRNDISMP_MESSAGE_FRAME;



//
// linked list entry for transport frames (transmit, receive, request)
//
typedef struct _RNDISMP_LIST_ENTRY 
{
    LIST_ENTRY  Link;
} RNDISMP_LIST_ENTRY, *PRNDISMP_LIST_ENTRY;


//
//  RNDIS VC states.
//
typedef enum
{
    RNDISMP_VC_ALLOCATED = 0,
    RNDISMP_VC_CREATING,
    RNDISMP_VC_CREATING_ACTIVATE_PENDING,
    RNDISMP_VC_CREATING_DELETE_PENDING,
    RNDISMP_VC_CREATE_FAILURE,
    RNDISMP_VC_CREATED,
    RNDISMP_VC_ACTIVATING,
    RNDISMP_VC_ACTIVATED,
    RNDISMP_VC_DEACTIVATING,
    RNDISMP_VC_DEACTIVATED,
    RNDISMP_VC_DELETING,
    RNDISMP_VC_DELETE_FAIL

} RNDISMP_VC_STATE;


//
//  RNDIS Call states.
//
typedef enum
{
    RNDISMP_CALL_IDLE
    // others TBD

} RNDISMP_CALL_STATE;


#define NULL_DEVICE_CONTEXT                 0


//
//  All information about a single VC/call.
//
typedef struct _RNDISMP_VC
{
    //  link to list of VCs on adapter.
    LIST_ENTRY                      VcList;

    //  owning adapter
    struct _RNDISMP_ADAPTER *       pAdapter;

    //  VC handle sent to the device, also our hash lookup key.
    UINT32                          VcId;

    //  base VC state
    RNDISMP_VC_STATE                VcState;

    //  call state, relevant only for devices that are call managers.
    RNDISMP_CALL_STATE              CallState;

    ULONG                           RefCount;

    //  NDIS Wrapper's handle for this Vc
    NDIS_HANDLE                     NdisVcHandle;

    //  remote device's context for this VC
    RNDIS_HANDLE                    DeviceVcContext;

    RNDISMP_SPIN_LOCK               Lock;

    //  sends on this VC that haven't been completed.
    ULONG                           PendingSends;

    //  receive indications that haven't been returned to us.
    ULONG                           PendingReceives;

    //  NDIS requests that haven't been completed.
    ULONG                           PendingRequests;

    //  VC activation (or call setup) parameters.
    PCO_CALL_PARAMETERS             pCallParameters;
} RNDISMP_VC, *PRNDISMP_VC;


//
//  VC hash table.
//
#define RNDISMP_VC_HASH_TABLE_SIZE  41

typedef struct _RNDISMP_VC_HASH_TABLE
{
    ULONG                           NumEntries;
    LIST_ENTRY                      HashEntry[RNDISMP_VC_HASH_TABLE_SIZE];

} RNDISMP_VC_HASH_TABLE, *PRNDISMP_VC_HASH_TABLE;


#define RNDISMP_HASH_VCID(_VcId)    ((_VcId) % RNDISMP_VC_HASH_TABLE_SIZE)


//
// High and low watermarks for messages pending
// at the microport
//
#define RNDISMP_PENDED_SEND_HIWAT       0xffff
#define RNDISMP_PENDED_SEND_LOWAT       0xfff


typedef VOID (*RM_MULTIPLE_SEND_HANDLER) ();

//
// This structure contains all the information about a single
// adapter that this driver is controlling
//
typedef struct _RNDISMP_ADAPTER
{
    // This is the handle given by the wrapper for calling NDIS functions.
    NDIS_HANDLE                 MiniportAdapterHandle;

    // pointer to next adapter in list hanging off driver block
    struct _RNDISMP_ADAPTER    *NextAdapter;

    // pointer to driver block for this adapter
    PDRIVER_BLOCK               DriverBlock;

    // Friendly name:
    ANSI_STRING                 FriendlyNameAnsi;
    UNICODE_STRING              FriendlyNameUnicode;

#if THROTTLE_MESSAGES
    // Counters for messages pending at the microport
    ULONG                       HiWatPendedMessages;
    ULONG                       LoWatPendedMessages;
    ULONG                       CurPendedMessages;

    // Messages not yet sent to microport.
    LIST_ENTRY                  WaitingMessageList;
    BOOLEAN                     SendInProgress;
#endif // THROTTLE_MESSAGES
    // Messages sent to microport, awaiting completion
    LIST_ENTRY                  PendingAtMicroportList;
    BOOLEAN                     SendProcessInProgress;
    LIST_ENTRY                  PendingSendProcessList;
    NDIS_TIMER                  SendProcessTimer;

    // Pool of RNDISMP_MESSAGE_FRAME structures
    NPAGED_LOOKASIDE_LIST       MsgFramePool;
    BOOLEAN                     MsgFramePoolAlloced;

    RNDIS_REQUEST_ID            RequestId;

    // Receive Routine Data Area
    NDIS_HANDLE                 ReceivePacketPool;
    NDIS_HANDLE                 ReceiveBufferPool;
    ULONG                       InitialReceiveFrames;
    ULONG                       MaxReceiveFrames;
    NPAGED_LOOKASIDE_LIST       RcvFramePool;
    BOOLEAN                     RcvFramePoolAlloced;
    BOOLEAN                     IndicatingReceives;
    // Messages to be processed.
    LIST_ENTRY                  PendingRcvMessageList;
    NDIS_TIMER                  IndicateTimer;

    // handlers registered by Remote NDIS microport
    RM_DEVICE_INIT_HANDLER      RmInitializeHandler;
    RM_DEVICE_INIT_CMPLT_NOTIFY_HANDLER RmInitCompleteNotifyHandler;
    RM_DEVICE_HALT_HANDLER      RmHaltHandler;
    RM_SHUTDOWN_HANDLER         RmShutdownHandler;
    RM_SEND_MESSAGE_HANDLER     RmSendMessageHandler;
    RM_RETURN_MESSAGE_HANDLER   RmReturnMessageHandler;

    // handler for DoMultipleSend
    RM_MULTIPLE_SEND_HANDLER    MultipleSendFunc;

    // context for microport adapter
    NDIS_HANDLE                 MicroportAdapterContext;

    // pointer to list of OIDs supported
    PNDIS_OID                   SupportedOIDList;

    // size of OID list
    UINT                        SupportedOIDListSize;

    // pointer to list of flags indicating whether the OID is driver or device supported
    PUINT                       OIDHandlerList;

    // size of OID handler list
    UINT                        OIDHandlerListSize;

    // pointer to list of Driver OIDs
    PNDIS_OID                   DriverOIDList;

    // size of Driver OID list, in OIDs
    UINT                        NumDriverOIDs;

    // total number of OIDs we support
    UINT                        NumOIDSupported;

    // medium type supported by the device.
    NDIS_MEDIUM                 Medium;

    // device flags reported by the device.
    ULONG                       DeviceFlags;

    // max NDIS_PACKETs that can be sent in one RNDIS message
    ULONG                       MaxPacketsPerMessage;
    BOOLEAN                     bMultiPacketSupported;

    // max message size supported for receive by the microport
    ULONG                       MaxReceiveSize;

    // max message size supported by the device
    ULONG                       MaxTransferSize;

    // alignment required by the device
    ULONG                       AlignmentIncr;
    ULONG                       AlignmentMask;

    // list of message frames pending completion by the device
    LIST_ENTRY                  PendingFrameList;

    // synchronization
    NDIS_SPIN_LOCK              Lock;

    // timer to see if we need to send a keep alive message
    NDIS_TIMER                  KeepAliveTimer;

    BOOLEAN                     TimerCancelled;

    // timer tick saved last time a message was received from device
    ULONG                       LastMessageFromDevice;

    // used by check for hang handler to determine if the device is in trouble
    BOOLEAN                     NeedReset;

    // are we waiting for a response to NdisReset?
    BOOLEAN                     ResetPending;

    // used by check for hang handler to determine if the device is in trouble
    BOOLEAN                     KeepAliveMessagePending;

    // are we initializing?
    BOOLEAN                     Initing;

    // are we halting?
    BOOLEAN                     Halting;

    // to wait until we complete sending the Halt message
    NDIS_EVENT                  HaltWaitEvent;

    // request ID of last Keepalive message we have sent
    RNDIS_REQUEST_ID            KeepAliveMessagePendingId;

    PRNDIS_INITIALIZE_COMPLETE  pInitCompleteMessage;

    // are we running on Win9x (WinMe)?
    BOOLEAN                     bRunningOnWin9x;

    // are we running on Win98 Gold?
    BOOLEAN                     bRunningOnWin98Gold;

    // CONDIS - Vc hash table
    PRNDISMP_VC_HASH_TABLE      pVcHashTable;
    ULONG                       LastVcId;

    // Statistics
    RNDISMP_ADAPTER_STATS       Statistics;
    ULONG                       MaxSendCompleteTime;

    // FDO for this device.
    PVOID                       pDeviceObject;

    // PDO for this device.
    PVOID                       pPhysDeviceObject;

    // MAC options
    ULONG                       MacOptions;

    // sanity check
    ULONG                       Signature;

#ifdef BUILD_WIN9X
    MY_CMCONFIGHANDLER          NdisCmConfigHandler;
    MY_DEVNODE                  DevNode;
    ULONG                       WrapContextOffset;
#endif
#if DBG
    ULONG                       MicroportReceivesOutstanding;
    PUCHAR                      pSendLogBuffer;
    ULONG                       LogBufferSize;
    PUCHAR                      pSendLogWrite;
#endif // DBG


} RNDISMP_ADAPTER, *PRNDISMP_ADAPTER;

typedef
VOID
(*RM_MULTIPLE_SEND_HANDLER) (
     IN PRNDISMP_ADAPTER pAdapter,
     IN PRNDISMP_VC      pVc  OPTIONAL,
     IN PPNDIS_PACKET    PacketArray,
     IN UINT             NumberofPackets);

//
// Structure to keep context about a single received RNDIS message.
//
typedef struct _RNDISMP_RECV_MSG_CONTEXT
{
    LIST_ENTRY                      Link;
    NDIS_HANDLE                     MicroportMessageContext;
    PMDL                            pMdl;
    ULONG                           TotalLength;
    PRNDIS_MESSAGE                  pMessage;
    NDIS_STATUS                     ReceiveStatus;
    BOOLEAN                         bMessageCopied;
    RM_CHANNEL_TYPE                 ChannelType;

} RNDISMP_RECV_MSG_CONTEXT, *PRNDISMP_RECV_MSG_CONTEXT;


//
// Structure to keep context about a single received RNDIS_PACKET -message-.
// Note that this can contain more than one packet. We store a pointer to
// this structure in our reserved section of each received NDIS_PACKET.
//
typedef struct _RNDISMP_RECV_DATA_FRAME
{
    NDIS_HANDLE                     MicroportMessageContext;
    union {
        PMDL                        pMicroportMdl;
        PRNDIS_MESSAGE              pLocalMessageCopy;
    };
    ULONG                           ReturnsPending;
    BOOLEAN                         bMessageCopy;       // did we make a copy?
} RNDISMP_RECV_DATA_FRAME, *PRNDISMP_RECV_DATA_FRAME;


//
// Per NDIS_PACKET context for received packets. This goes into MiniportReserved.
//
typedef struct _RNDISMP_RECV_PKT_RESERVED
{
    PRNDISMP_RECV_DATA_FRAME        pRcvFrame;
    PRNDISMP_VC                     pVc;
} RNDISMP_RECV_PKT_RESERVED, *PRNDISMP_RECV_PKT_RESERVED;


//
// Used to overlay ProtocolReserved in a packet queued for indicating up.
//
typedef struct _RNDISMP_RECV_PKT_LINKAGE
{
    LIST_ENTRY                      Link;
} RNDISMP_RECV_PKT_LINKAGE, *PRNDISMP_RECV_PKT_LINKAGE;
    

//
// Global Data
//
extern DRIVER_BLOCK             RndismpMiniportBlockListHead;

extern UINT                     RndismpNumMicroports;

extern NDIS_SPIN_LOCK           RndismpGlobalLock;

extern NDIS_OID                 RndismpSupportedOids[];

extern UINT                     RndismpSupportedOidsNum;

extern NDIS_PHYSICAL_ADDRESS    HighestAcceptableMax;

#if DBG

extern UINT                     RndismpDebugFlags;

#endif


//
// Macros
//

// Given a request message type value, return its completion message type
#define RNDIS_COMPLETION(_Type) ((_Type) | 0x80000000)


// Convert an RNdisMediumXXX value to its NdisMediumXXX equivalent
#define RNDIS_TO_NDIS_MEDIUM(_RndisMedium)  ((NDIS_MEDIUM)(_RndisMedium))

#define RNDISMP_GET_ALIGNED_LENGTH(_AlignedLength, _InputLen, _pAdapter)    \
{                                                                           \
    ULONG       _Length = _InputLen;                                        \
    if (_Length == 0)                                                       \
        (_AlignedLength) = 0;                                               \
    else                                                                    \
        (_AlignedLength) = ((_Length + (_pAdapter)->AlignmentIncr) &        \
                            (_pAdapter)->AlignmentMask);                    \
}

// The minimum MessageLength expected in an RNDIS message of a given type.
#define RNDISMP_MIN_MESSAGE_LENGTH(_MsgTypeField)                           \
    FIELD_OFFSET(RNDIS_MESSAGE, Message) + sizeof(((PRNDIS_MESSAGE)0)->Message._MsgTypeField##)

// memory move macro
#define RNDISMP_MOVE_MEM(dest,src,size) NdisMoveMemory(dest,src,size)

// Macros to extract high and low bytes of a word.
#define MSB(Value) ((UCHAR)((((ULONG)Value) >> 8) & 0xff))
#define LSB(Value) ((UCHAR)(((ULONG)Value) & 0xff))


// Acquire the adapter lock
#define RNDISMP_ACQUIRE_ADAPTER_LOCK(_pAdapter) \
    NdisAcquireSpinLock(&(_pAdapter)->Lock);

// Release the adapter lock
#define RNDISMP_RELEASE_ADAPTER_LOCK(_pAdapter) \
    NdisReleaseSpinLock(&(_pAdapter)->Lock);

// Increment adapter statistics.
#define RNDISMP_INCR_STAT(_pAdapter, _StatsCount)               \
    NdisInterlockedIncrement(&(_pAdapter)->Statistics._StatsCount)

// Get adapter statistics
#define RNDISMP_GET_ADAPTER_STATS(_pAdapter, _StatsCount)           \
    ((_pAdapter)->Statistics._StatsCount)

// Get the send packet reserved field
#define PRNDISMP_RESERVED_FROM_SEND_PACKET(_Packet)             \
    ((PRNDISMP_SEND_PKT_RESERVED)((_Packet)->MiniportReserved))

#define PRNDISMP_RESERVED_TEMP_FROM_SEND_PACKET(_Packet)        \
    ((PRNDISMP_SEND_PKT_RESERVED_TEMP)((_Packet)->MiniportReserved))

#define PRNDISMP_RESERVED_FROM_RECV_PACKET(_Packet)             \
    ((PRNDISMP_RECV_PKT_RESERVED)((_Packet)->MiniportReserved))

// store receive frame context in miniport reserved field
#define RECEIVE_FRAME_TO_NDIS_PACKET(_Packet, _ReceiveFrame)    \
{                                                               \
    PRNDISMP_RECEIVE_FRAME  *TmpPtr;                            \
    TmpPtr  = (PRNDISMP_RECEIVE_FRAME *)                        \
              &(_Packet->MiniportReserved);                     \
    *TmpPtr = _ReceiveFrame;                                    \
}


// Get adapter context from handle passed in NDIS routines
#define PRNDISMP_ADAPTER_FROM_CONTEXT_HANDLE(_Handle)           \
    ((PRNDISMP_ADAPTER)(_Handle))

// Get miniport context handle from adapter context
#define CONTEXT_HANDLE_FROM_PRNDISMP_ADAPTER(_Ptr)              \
    ((NDIS_HANDLE)(_Ptr))

// Get VC context from handle passed in from NDIS
#define PRNDISMP_VC_FROM_CONTEXT_HANDLE(_Handle)                   \
    ((PRNDISMP_VC)(_Handle))

// Get miniport context from VC
#define CONTEXT_HANDLE_FROM_PRNDISMP_VC(_pVc)                   \
    ((NDIS_HANDLE)(_Vc))

// Get message frame from message handle
#define MESSAGE_FRAME_FROM_HANDLE(_Handle)                      \
    ((PRNDISMP_MESSAGE_FRAME)(_Handle))

// Get a pointer to the data buff in an RNDIS_PACKET
#define GET_PTR_TO_RNDIS_DATA_BUFF(_Message)                    \
    ((PVOID) ((PUCHAR)(_Message) +  _Message->DataOffset))

// Get a pointer to the OOBD data in an RNDIS_PACKET
#define GET_PTR_TO_OOB_DATA(_Message)                           \
    ((PVOID) ((PUCHAR)(_Message) +  _Message->OOBDataOffset))

// Get a pointer to the per packet info in an RNDIS_PACKET
#define GET_PTR_TO_PER_PACKET_INFO(_Message)                    \
    ((PVOID) ((PUCHAR)(_Message) +  _Message->PerPacketInfoOffset))

// Get an offset to the data buff in an RNDIS_PACKET
#define GET_OFFSET_TO_RNDIS_DATA_BUFF(_Message)                 \
    (sizeof(RNDIS_PACKET))

// Get an offset to the OOBD data in an RNDIS_PACKET
#define GET_OFFSET_TO_OOB_DATA(_Message)                        \
    (sizeof(RNDIS_PACKET) +  Message->DataLength)

// Get an offset to the per packet info in an RNDIS_PACKET
#define GET_OFFSET_TO_PER_PACKET_INFO(_Message)                 \
    (sizeof(RNDIS_PACKET) + _Message->DataLength + _Message->OOBDataLength)

#define RNDISMP_GET_INFO_BUFFER_FROM_QUERY_MSG(_Message)        \
    ((PUCHAR)(_Message) + (_Message)->InformationBufferOffset)

#define MIN(x,y) ((x > y) ? y : x)


// Return the virtual address for a received message MDL.
#if NDIS_WDM
#define RNDISMP_GET_MDL_ADDRESS(_pMdl)  MmGetSystemAddressForMdl(_pMdl)
#else
#define RNDISMP_GET_MDL_ADDRESS(_pMdl)  MmGetSystemAddressForMdlSafe(_pMdl, NormalPagePriority)
#endif

// Return the MDL chained to this MDL
#define RNDISMP_GET_MDL_NEXT(_pMdl) ((_pMdl)->Next)

// Return the MDL length
#define RNDISMP_GET_MDL_LENGTH(_pMdl)   MmGetMdlByteCount(_pMdl)

// Access the RNDIS message from our Message Frame structure.
#define RNDISMP_GET_MSG_FROM_FRAME(_pMsgFrame)                  \
    RNDISMP_GET_MDL_ADDRESS(_pMsgFrame->pMessageMdl)

// Return an RNDIS message back to the microport.
#if DBG

#define RNDISMP_RETURN_TO_MICROPORT(_pAdapter, _pMdl, _MicroportMsgContext) \
{                                                                           \
    NdisInterlockedDecrement(&(_pAdapter)->MicroportReceivesOutstanding);   \
    (_pAdapter)->RmReturnMessageHandler((_pAdapter)->MicroportAdapterContext,\
                                        (_pMdl),                            \
                                        (_MicroportMsgContext));            \
}

#else

#define RNDISMP_RETURN_TO_MICROPORT(_pAdapter, _pMdl, _MicroportMsgContext) \
    (_pAdapter)->RmReturnMessageHandler((_pAdapter)->MicroportAdapterContext,\
                                        (_pMdl),                            \
                                        (_MicroportMsgContext))
#endif // DBG

// Send an RNDIS message to the microport.
#if THROTTLE_MESSAGES
#define RNDISMP_SEND_TO_MICROPORT(_pAdapter, _pMsgFrame, _bQueueForResponse, _CallbackFunc)     \
{                                                                           \
    TRACE2(("Send: Adapter %x, MsgFrame %x, Mdl %x\n",                      \
                _pAdapter, _pMsgFrame, _pMsgFrame->pMessageMdl));           \
    (_pMsgFrame)->pCallback = _CallbackFunc;                                \
    QueueMessageToMicroport(_pAdapter, _pMsgFrame, _bQueueForResponse);     \
}
#else
#define RNDISMP_SEND_TO_MICROPORT(_pAdapter, _pMsgFrame, _bQueueForResponse, _CallbackFunc)     \
{                                                                           \
    (_pMsgFrame)->pCallback = _CallbackFunc;                                \
    if (_bQueueForResponse)                                                 \
    {                                                                       \
        RNDISMP_ACQUIRE_ADAPTER_LOCK(_pAdapter);                            \
        InsertTailList(&(_pAdapter)->PendingFrameList, &(_pMsgFrame)->Link);\
        RNDISMP_RELEASE_ADAPTER_LOCK(_pAdapter);                            \
    }                                                                       \
    (_pAdapter)->RmSendMessageHandler((_pAdapter)->MicroportAdapterContext, \
                                              (_pMsgFrame)->pMessageMdl,    \
                                              (_pMsgFrame));                \
}
#endif // THROTTLE_MESSAGES

// Return the handler function for a given message type.
#define RNDISMP_GET_MSG_HANDLER(_pMsgHandlerFunc, _MessageType) \
{                                                               \
    switch (_MessageType)                                       \
    {                                                           \
        case REMOTE_NDIS_HALT_MSG:                              \
            _pMsgHandlerFunc = HaltMessage;                     \
            break;                                              \
        case REMOTE_NDIS_PACKET_MSG:                            \
            _pMsgHandlerFunc = ReceivePacketMessage;            \
            break;                                              \
        case REMOTE_NDIS_INDICATE_STATUS_MSG:                   \
            _pMsgHandlerFunc = IndicateStatusMessage;           \
            break;                                              \
        case REMOTE_NDIS_QUERY_CMPLT:                           \
        case REMOTE_NDIS_SET_CMPLT:                             \
            _pMsgHandlerFunc = QuerySetCompletionMessage;       \
            break;                                              \
        case REMOTE_NDIS_KEEPALIVE_MSG:                         \
            _pMsgHandlerFunc = KeepAliveMessage;                \
            break;                                              \
        case REMOTE_NDIS_KEEPALIVE_CMPLT:                       \
            _pMsgHandlerFunc = KeepAliveCompletionMessage;      \
            break;                                              \
        case REMOTE_NDIS_RESET_CMPLT:                           \
            _pMsgHandlerFunc = ResetCompletionMessage;          \
            break;                                              \
        case REMOTE_NDIS_INITIALIZE_CMPLT:                      \
            _pMsgHandlerFunc = InitCompletionMessage;           \
            break;                                              \
        case REMOTE_CONDIS_MP_CREATE_VC_CMPLT:                  \
            _pMsgHandlerFunc = ReceiveCreateVcComplete;         \
            break;                                              \
        case REMOTE_CONDIS_MP_DELETE_VC_CMPLT:                  \
            _pMsgHandlerFunc = ReceiveDeleteVcComplete;         \
            break;                                              \
        case REMOTE_CONDIS_MP_ACTIVATE_VC_CMPLT:                \
            _pMsgHandlerFunc = ReceiveActivateVcComplete;       \
            break;                                              \
        case REMOTE_CONDIS_MP_DEACTIVATE_VC_CMPLT:              \
            _pMsgHandlerFunc = ReceiveDeactivateVcComplete;     \
            break;                                              \
        default:                                                \
            _pMsgHandlerFunc = UnknownMessage;                  \
            break;                                              \
    }                                                           \
}



//
// Look up a message frame on the adapter given a request ID. If found,
// remove it from the pending list and return it.
//
#define RNDISMP_LOOKUP_PENDING_MESSAGE(_pMsgFrame, _pAdapter, _ReqId)       \
{                                                                           \
    PLIST_ENTRY             _pEnt;                                          \
    PRNDISMP_MESSAGE_FRAME  _pFrame;                                        \
                                                                            \
    (_pMsgFrame) = NULL;                                                    \
    RNDISMP_ACQUIRE_ADAPTER_LOCK(_pAdapter);                                \
    for (_pEnt = (_pAdapter)->PendingFrameList.Flink;                       \
         _pEnt != &(_pAdapter)->PendingFrameList;                           \
         _pEnt = _pEnt->Flink)                                              \
    {                                                                       \
        _pFrame = CONTAINING_RECORD(_pEnt, RNDISMP_MESSAGE_FRAME, Link);    \
        if (_pFrame->RequestId == (_ReqId))                                 \
        {                                                                   \
            RemoveEntryList(_pEnt);                                         \
            (_pMsgFrame) = _pFrame;                                         \
            break;                                                          \
        }                                                                   \
    }                                                                       \
    RNDISMP_RELEASE_ADAPTER_LOCK(_pAdapter);                                \
}


#if DBG_TIME_STAMPS
#define RNDISMP_GET_TIME_STAMP(_pTs)                                        \
{                                                                           \
    LONGLONG systime_usec;                                                  \
    NdisGetCurrentSystemTime((PVOID)&systime_usec);                         \
    *_pTs = (ULONG)((*(PULONG)&systime_usec)/1000);                         \
}
#else
#define RNDISMP_GET_TIME_STAMP(_pTs)
#endif

#define RNDISMP_INIT_LOCK(_pLock)                                           \
    NdisAllocateSpinLock((_pLock));

#define RNDISMP_ACQUIRE_LOCK(_pLock)                                        \
    NdisAcquireSpinLock((_pLock));

#define RNDISMP_RELEASE_LOCK(_pLock)                                        \
    NdisReleaseSpinLock((_pLock));

#define RNDISMP_ACQUIRE_LOCK_DPC(_pLock)                                    \
    NdisDprAcquireSpinLock((_pLock));

#define RNDISMP_RELEASE_LOCK_DPC(_pLock)                                    \
    NdisDprReleaseSpinLock((_pLock));


#define RNDISMP_INIT_VC_LOCK(_pVc)                                          \
    RNDISMP_INIT_LOCK(&((_pVc)->Lock))

#define RNDISMP_ACQUIRE_VC_LOCK(_pVc)                                       \
    RNDISMP_ACQUIRE_LOCK(&((_pVc))->Lock)

#define RNDISMP_RELEASE_VC_LOCK(_pVc)                                       \
    RNDISMP_RELEASE_LOCK(&((_pVc))->Lock)
   
#define RNDISMP_ACQUIRE_VC_LOCK_DPC(_pVc)                                   \
    RNDISMP_ACQUIRE_LOCK_DPC(&((_pVc))->Lock)

#define RNDISMP_RELEASE_VC_LOCK_DPC(_pVc)                                   \
    RNDISMP_RELEASE_LOCK_DPC(&((_pVc))->Lock)


#define RNDISMP_REF_VC(_pVc)                                     