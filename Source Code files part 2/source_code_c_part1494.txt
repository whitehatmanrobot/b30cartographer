   CDirectSoundWaveDownload(
        CDirectSoundWave           *pDSWave, 
        CDirectMusicPortDownload   *pPortDL,
        SAMPLE_TIME                 stStart,
        SAMPLE_TIME                 stReadAhead);
        
    ~CDirectSoundWaveDownload();
    
    // Initialize
    //
    HRESULT Init();

    // Download wave buffers and articulation. In the case of streaming this
    // means downloading readahead data.
    //    
    HRESULT Download();                         
    
    // Unload everything
    //
    HRESULT Unload();
    
    // Notification that the stream has reached a certain sample position;
    // refresh the buffers as needed. (Streaming only)
    //
    HRESULT RefreshThroughSample(SAMPLE_POSITION sp);
    
    // Return the articulation download ID
    //
    inline DWORD GetDLId()
    { return m_dwDLIdArt; }
    
private:
    CDirectSoundWave           *m_pDSWave;          // Wave object
    CDirectMusicPortDownload   *m_pPortDL;          // Port download object
    
    CDirectSoundWaveArt        *m_pWaveArt;         // Wave articulation wrapper
    DWORD                       m_dwDLIdWave;       // First wave buffer DLID
    DWORD                       m_dwDLIdArt;        // Articulation DLID
    UINT                        m_cSegments;        // How many segments? 
    UINT                        m_cWaveBuffer;      // Number of wave buffers
    IDirectMusicDownload      **m_ppWaveBuffer;     // Wave download buffers
    void                      **m_ppWaveBufferData; //  and their data
    IDirectMusicDownload      **m_ppArtBuffer;      // Articulation buffers (one per channel)
    SAMPLE_TIME                 m_stStart;          // Starting sample
    SAMPLE_TIME                 m_stReadAhead;      // Read ahead (buffer length)
    LONG                        m_cDLRefCount;      // Download reference count
    SAMPLE_TIME                 m_stLength;         // How many samples to 
                                                    //  process? (Lenth of
                                                    //  stream - start pos)
    SAMPLE_TIME                 m_stWrote;          // Buffer-aligned sample
                                                    //  written through                                                    
    UINT                        m_nNextBuffer;      // Next buffer that should
                                                    // be filled.                                                    
    
private:
    HRESULT DownloadWaveBuffers();
    HRESULT UnloadWaveBuffers();
    HRESULT DownloadWaveArt();
    HRESULT UnloadWaveArt();
};

class CDirectSoundWaveList;

#define ENTIRE_WAVE ((SAMPLE_TIME)0x7FFFFFFFFFFFFFFF)

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave
//
// Internal wrapper for an external IDirectSoundWave.
//
class CDirectSoundWave : public IDirectSoundDownloadedWaveP, public AListItem
{
public:
    // IUnknown
    //
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *);
    STDMETHOD_(ULONG,AddRef)        (THIS);
    STDMETHOD_(ULONG,Release)       (THIS);
    
    CDirectSoundWave(
        IDirectSoundWave            *pIDSWave, 
        bool                        fStreaming, 
        REFERENCE_TIME              rtReadAhead,
        bool                        fUseNoPreRoll,
        REFERENCE_TIME              rtStartHint);
    ~CDirectSoundWave();


    // Find a CDirectSoundWave matching an IDirectSoundWave
    //
    static CDirectSoundWave *GetMatchingDSWave(IDirectSoundWave *pIDSWave);
    
    // General initialization. 
    //
    HRESULT Init(CDirectMusicPortDownload *pPortDL);

    // Write a piece of the wave or the whole wave into the buffer
    // Writes all channels for a single segment
    //
    HRESULT Write(
        LPVOID                  pvBuffer[], 
        SAMPLE_TIME             stStart, 
        SAMPLE_TIME             stLength,
        DWORD                   dwDLId,
        DWORD                   dwDLType) const;
        
    // Refill an already downloaded buffer with new wave data
    //        
    HRESULT RefillBuffers(
        LPVOID                  rpv[], 
        SAMPLE_TIME             stStart, 
        SAMPLE_TIME             stLength,
        SAMPLE_TIME             stBufferLength);
        
    // Convert reference time to samples 
    //
    SAMPLE_TIME RefToSampleTime(REFERENCE_TIME rt) const;                        
    
    // Download and unload all buffers if this is a one-shot
    //
    HRESULT Download();
    HRESULT Unload();
    
    // Override GetNext list operator
    //    
    inline CDirectSoundWave *GetNext() 
    { return (CDirectSoundWave*)AListItem::GetNext(); }
    
    // Determine if this wave is a streaming or one-shot
    //
    inline bool IsStreaming() const
    { return m_fStreaming; }
    
    // Figure out how much buffer to read a piece of the wave
    //
    void GetSize(SAMPLE_TIME stLength, PULONG pcb) const;
    
    // Returns the number of channels
    //
    inline UINT GetNumChannels() const
    { return m_pwfex->nChannels; }

    // Seek to a sample position
    //
    inline HRESULT Seek(SAMPLE_TIME st)
    { return m_pSource->Seek(st * m_nBytesPerSample * GetNumChannels()); }

    // Returns the wrapped IDirectSoundWave
    //
    inline IDirectSoundWave *GetWrappedIDSWave() 
    { m_pIDSWave->AddRef(); return m_pIDSWave; }    
    
    // Returns the wrapped wave format
    //
    inline const LPWAVEFORMATEX GetWaveFormat() const
    { return m_pwfex; }
    
    // Return the length of the stream in samples
    //
    inline SAMPLE_TIME GetStreamSize() const
    { return m_stLength; }
    
    // Get the download ID of the articulation if one-shot
    //
    inline DWORD GetDLId()
    { assert(!m_fStreaming); assert(m_pDSWD); 
      TraceI(1, "CDirectSoundWave::GetDLId() -> %d\n", m_pDSWD->GetDLId());
      return m_pDSWD->GetDLId(); }
      
    inline REFERENCE_TIME GetReadAhead()
    { return m_rtReadAhead; }      
      
    // Convert number of samples to number of bytes for this wave format
    // (assuming PCM). Truncates to a DWORD, so shouldn't be used for
    // huge number of samples.
    //
    inline DWORD SamplesToBytes(SAMPLE_TIME st) const
    { LONGLONG cb = st * m_nBytesPerSample; 
      assert(!(cb & 0xFFFFFFFF00000000));
      return (DWORD)cb; }
      
    inline SAMPLE_TIME BytesToSamples(DWORD cb) const
    { return cb / m_nBytesPerSample; }

    inline SAMPLE_TIME GetPrecacheStart() const
    { assert(IsStreaming()); return m_stStartHint; }

    inline LPBYTE *GetPrecache() const
    { assert(IsStreaming()); return m_rpbPrecache; }

          
    
    static CDirectSoundWaveList sDSWaveList;        // List of all wave objects
    static CRITICAL_SECTION sDSWaveCritSect;        //  and critical section
   
private:
    
    LONG                    m_cRef;                 // COM reference count
    IDirectSoundWave       *m_pIDSWave;             // Wrapped IDirectSoundWave
    bool                    m_fStreaming;           // Is this a streaming wave?
    bool                    m_fUseNoPreRoll;
    REFERENCE_TIME          m_rtReadAhead;          // If so, buffering amount    
    LPWAVEFORMATEX          m_pwfex;                // Native format of wave
    UINT                    m_cbSample;             // Bytes per sample
    SAMPLE_TIME             m_stLength;             // Length of entire wave
    IDirectSoundSource     *m_pSource;              // Source interface
    
    CDirectSoundWaveDownload    
                           *m_pDSWD;                // Wave download wrapper if 
                                                    //  not streaming
    UINT                    m_nBytesPerSample;      // Bytes per sample from wfex
    LPVOID                 *m_rpv;                  // Working space - one pv 
                                                    //  per channel
    LPBYTE                 *m_rpbPrecache;          // Samples starting at start hint
    REFERENCE_TIME          m_rtStartHint;          //  and where it starts
    SAMPLE_TIME             m_stStartHint;          //  in samples as well 
    SAMPLE_TIME             m_stStartLength;        // How many samples in precache?
};

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveList
//
// Type-safe wrapper for AList of CDirectSoundWave's
//
class CDirectSoundWaveList : public AList
{
public:
    inline CDirectSoundWave *GetHead()
    { return static_cast<CDirectSoundWave*>(AList::GetHead()); }
    
    inline void AddTail(CDirectSoundWave *pdsw)
    { AList::AddTail(static_cast<AListItem*>(pdsw)); }
    
    inline void Remove(CDirectSoundWave *pdsw)
    { AList::Remove(static_cast<AListItem*>(pdsw)); }
};


#endif // _DSWAVE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\dswave.cpp ===
//
// dswave.cpp
//
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Support for streaming or oneshot waves from IDirectSoundWaveObject
//
//
#include <windows.h>
#include "dmusicp.h"
#include "DsWave.h"
#include "dmdls.h"
#include "dls1.h"
#include "dls2.h"

const DWORD gnRefTicksPerSecond = 10 * 1000 * 1000;

// Global list of all CDirectSoundWave objects in this process
//
CDirectSoundWaveList CDirectSoundWave::sDSWaveList;
CRITICAL_SECTION CDirectSoundWave::sDSWaveCritSect;

//#############################################################################
//
// CDirectSoundWaveDownload
//
// This class contains all the code to maintain one downloaded instance of a
// wave object. It is abstracted away from CDirectSoundWave (which represents
// an IDirectSoundDownloadedWave to the application) because of the case
// of streaming waves. Here's how it works:
//
// In the case of a one-shot download, there is only one set of buffers (one
// per channel in the source wave) for all voices playing the wave. Each
// buffer contains one channel of data for the entire length of the source
// wave. Since there is a one-to-one mapping of a buffer set (and associated
// download ID's) with the application-requested download, this case is
// handled by having CDirectSoundWave own one CDirectSoundWaveDownload.
//
// In the case of a streaming wave, what a download really does is to set up
// a ring of buffers that are kept full and refreshed by the voice service
// thread. There is one set of buffers (three buffer sets, each containing
// as many channels as the original source wave) per voice. Now there is a
// one-to-one correspondence between the downloaded buffer set and the voice,
// so the CDirectSoundWaveDownload is owned by each voice object playing
// the CDirectSoundWave.
//
//#############################################################################

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveDownload::CDirectSoundWaveDownload
//
CDirectSoundWaveDownload::CDirectSoundWaveDownload(
    CDirectSoundWave            *pDSWave,
    CDirectMusicPortDownload    *pPortDL,
    SAMPLE_TIME                 stStart,
    SAMPLE_TIME                 stReadAhead)
{
    m_pDSWave = pDSWave;
    m_pPortDL = pPortDL;

    m_ppWaveBuffer     = NULL;
	m_ppWaveBufferData = NULL;
    m_ppArtBuffer      = NULL;

    m_cDLRefCount  = 0;

    // Allocate download ID's
    //
    m_cSegments   = pDSWave->IsStreaming() ? gnDownloadBufferPerStream : 1;
    m_cWaveBuffer = m_cSegments * pDSWave->GetNumChannels();

    CDirectMusicPortDownload::GetDLIdP(&m_dwDLIdWave, m_cWaveBuffer);
    CDirectMusicPortDownload::GetDLIdP(&m_dwDLIdArt,  pDSWave->GetNumChannels());

    TraceI(2, "CDirectSoundWaveDownload: Allocating IDs: wave [%d..%d], art [%d..%d]\n",
        m_dwDLIdWave, m_dwDLIdWave + m_cWaveBuffer - 1,
        m_dwDLIdArt, m_dwDLIdArt + pDSWave->GetNumChannels() - 1);

    // Cache sample positions of where to start and how long the buffers are,
    // based on whether or not this is a streaming wave.
    //
    if (pDSWave->IsStreaming())
    {
        m_stStart     = stStart;
        m_stReadAhead = stReadAhead;
    }
    else
    {
        m_stStart     = 0;
        m_stReadAhead = ENTIRE_WAVE;
    }
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveDownload::~CDirectSoundWaveDownload
//
CDirectSoundWaveDownload::~CDirectSoundWaveDownload()
{
    if (m_cDLRefCount)
    {
        TraceI(0, "CDirectSoundWaveDownload %p: Released with download count %d\n",
            this,
            m_cDLRefCount);
    }

    if (m_ppWaveBuffer)
    {
        for (UINT idxWaveBuffer = 0; idxWaveBuffer < m_cWaveBuffer; idxWaveBuffer++)
        {
            RELEASE(m_ppWaveBuffer[idxWaveBuffer]);
        }

        delete[] m_ppWaveBuffer;
    }

    if (m_ppArtBuffer)
    {
        for (UINT idxArtBuffer = 0; idxArtBuffer < m_pDSWave->GetNumChannels(); idxArtBuffer++)
        {
            RELEASE(m_ppArtBuffer[idxArtBuffer]);
        }

		delete[] m_ppArtBuffer;
    }

	if(m_ppWaveBufferData)
	{
		delete[] m_ppWaveBufferData;
	}


	if(m_pWaveArt)
	{
		delete[] m_pWaveArt;
	}
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveDownload::Init
//
HRESULT CDirectSoundWaveDownload::Init()
{
    HRESULT hr = S_OK;

    m_pWaveArt = new CDirectSoundWaveArt[m_pDSWave->GetNumChannels()];

    hr = HRFromP(m_pWaveArt);

    //For the time being, assume the channel and BusId is the same
    //  Works for stereo.
    DWORD dwFlags = 0;
    if (m_pDSWave->GetNumChannels() > 1)
    {
        dwFlags = F_WAVELINK_MULTICHANNEL;
    }

    for (UINT idx = 0; idx < m_pDSWave->GetNumChannels() && SUCCEEDED(hr); idx++)
    {
        // XXX WAVEFORMATEXTENSIBLE parsing to get channel mappings should go here.
        //
        hr = m_pWaveArt[idx].Init(m_pDSWave, m_cSegments, (DWORD)idx, dwFlags);
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveDownload::Download
//
HRESULT CDirectSoundWaveDownload::Download()
{
    HRESULT                 hr;

    hr = DownloadWaveBuffers();

    if (SUCCEEDED(hr))
    {
        hr = DownloadWaveArt();
    }

    if (SUCCEEDED(hr))
    {
        InterlockedIncrement(&m_cDLRefCount);
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveDownload::Unload
//
HRESULT CDirectSoundWaveDownload::Unload()
{
    HRESULT                 hr;

    if (InterlockedDecrement(&m_cDLRefCount) != 0)
    {
        return S_OK;
    }

    hr = UnloadWaveArt();

    if (SUCCEEDED(hr))
    {
        hr = UnloadWaveBuffers();
    }

    if (FAILED(hr))
    {
        InterlockedIncrement(&m_cDLRefCount);
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveDownload::RefreshThroughSample
//
HRESULT CDirectSoundWaveDownload::RefreshThroughSample(SAMPLE_POSITION sp)
{
    int cBuffersLeft;

    // Make sample position be in terms of the stream
    //
    sp += m_stStart;

    TraceI(0, "RTS: Adjusted sp %I64d m_stWrote %I64d m_stReadAhead %I64d m_stLength %I64d\n",
        sp, m_stWrote, m_stReadAhead, m_stLength);

    if (sp > m_stLength)
    {
        TraceI(0, "Wave is over\n");
        return S_FALSE;
    }

    if(sp <= m_stReadAhead && m_stWrote >= m_stReadAhead)
    {
        TraceI(0, "\nAlready have enough data in the buffers\n");
        return S_OK;
    }

    if(m_stWrote >= m_stLength)
    {
        TraceI(0, "Entire wave already in the buffer\n");
        return S_OK;
    }

    // How many buffers left to play?
    //
    if (sp >= m_stWrote)
    {
        TraceI(0, "RTS: Glitch!\n");
        // Glitch! Play cursor has gone beyond end of read buffers.
        //
        cBuffersLeft = 0;
    }
    else
    {
        // Calculate buffers left to play, including partial buffers
        //
        cBuffersLeft = (int)((m_stWrote - sp + m_stReadAhead - 1) / m_stReadAhead);
        assert(cBuffersLeft <= (int)m_cSegments);
        TraceI(0, "RTS: %d buffers left\n", cBuffersLeft);
    }

    HRESULT hr = S_OK;

    int cBuffersToFill = m_cSegments - cBuffersLeft;
    TraceI(0, "RTS: %d buffers to fill\n", cBuffersToFill);

    while (cBuffersToFill--)
    {
        TraceI(0, "Refilling buffer %d\n", m_nNextBuffer);
        hr = m_pDSWave->RefillBuffers(
            &m_ppWaveBufferData[m_nNextBuffer * m_pDSWave->GetNumChannels()],
            m_stWrote,
            m_stReadAhead,
            m_stReadAhead);

        TraceI(0, "Refill buffers returned %08X\n", hr);

        if (SUCCEEDED(hr))
        {
            DWORD dwDLId = m_dwDLIdWave + m_pDSWave->GetNumChannels() * m_nNextBuffer;

            for (UINT idxChannel = 0;
                 idxChannel < m_pDSWave->GetNumChannels() && SUCCEEDED(hr);
                 idxChannel++, dwDLId++)
            {
                // Need to preserve a return code of S_FALSE from RefillBuffers
                // across this call
                //
                TraceI(0, "Marking %d as valid.\n", dwDLId);
                HRESULT hrTemp = m_pPortDL->Refresh(
                    dwDLId,
                    0);
                if (FAILED(hrTemp))
                {
                    hr = hrTemp;
                }
            }

            if (SUCCEEDED(hr))
            {
                m_stWrote += m_stReadAhead;
                m_nNextBuffer = (m_nNextBuffer + 1) % m_cSegments;
            }
        }
    }

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveDownload::DownloadWaveBuffers
//
HRESULT CDirectSoundWaveDownload::DownloadWaveBuffers()
{
    HRESULT                 hr = S_OK;
    bool                    fUnloadOnFail = false;
    UINT                    nChannels = m_pDSWave->GetNumChannels();
    DWORD                   dwDownloadType;

    dwDownloadType =
        (m_pDSWave->IsStreaming()) ?
            DMUS_DOWNLOADINFO_STREAMINGWAVE :
            DMUS_DOWNLOADINFO_ONESHOTWAVE;

    // Allocate space to hold the buffers we're going to download
    //
    if (m_ppWaveBuffer == NULL)
    {
        m_ppWaveBuffer = new IDirectMusicDownload*[m_cWaveBuffer];
        hr = HRFromP(m_ppWaveBuffer);
        if (SUCCEEDED(hr))
        {
            memset(m_ppWaveBuffer, 0, m_cWaveBuffer * sizeof(IDirectMusicDownload*));

            // Cache pointers into buffers so we don't continually have to
            // get them.
            //
            assert(!m_ppWaveBufferData);
            m_ppWaveBufferData = new LPVOID[m_cWaveBuffer];
            hr = HRFromP(m_ppWaveBufferData);
        }
    }

    // Figure out how much to add to each buffer
    //
    DWORD                   dwAppend;

    if (SUCCEEDED(hr))
    {
        hr = m_pPortDL->GetCachedAppend(&dwAppend);
    }

    if (SUCCEEDED(hr))
    {
        // Retrieved value is in samples. Convert to bytes.
        //
        dwAppend *= ((m_pDSWave->GetWaveFormat()->wBitsPerSample + 7) / 8);
    }

    // Seek to the start position in the stream
    //
    if (SUCCEEDED(hr))
    {
        m_pDSWave->Seek(m_stStart);
    }

    // Make sure the buffers are all allocated
    //
    if (SUCCEEDED(hr))
    {
        DWORD cbSize;

        m_pDSWave->GetSize(m_stReadAhead, &cbSize);
        cbSize += dwAppend;

        for (UINT idxBuffer = 0; (idxBuffer < m_cWaveBuffer) && SUCCEEDED(hr); idxBuffer++)
        {
            if (m_ppWaveBuffer[idxBuffer])
            {
                continue;
            }

            hr = m_pPortDL->AllocateBuffer(cbSize, &m_ppWaveBuffer[idxBuffer]);

            if (SUCCEEDED(hr))
            {
                DWORD cb;
                hr = m_ppWaveBuffer[idxBuffer]->GetBuffer(
                    &m_ppWaveBufferData[idxBuffer], &cb);
            }
        }
    }

    // We have all the buffers. Try to download if needed.
    //
    if (SUCCEEDED(hr))
    {
        SAMPLE_TIME             stStart = m_stStart;
        SAMPLE_TIME             stRead;
        DWORD                   dwDLId = m_dwDLIdWave;
        IDirectMusicDownload  **ppBuffers = &m_ppWaveBuffer[0];
        UINT                    idxSegment;
        UINT                    idxChannel;
        void                  **ppv = m_ppWaveBufferData;

        m_stLength    = m_pDSWave->GetStreamSize();
        m_stWrote     = m_stStart;
        m_nNextBuffer = 0;

        for (idxSegment = 0;
             idxSegment < m_cSegments;
             idxSegment++, dwDLId += nChannels, ppBuffers += nChannels, ppv += nChannels)
        {
            // Since we guarantee that if one buffer gets downloaded, all
            // get downloaded, we only need to check the first download ID
            // to see if all channels of this segment are already downloaded
            //
            IDirectMusicDownload *pBufferTemp;
            HRESULT hrTemp = m_pPortDL->GetBufferInternal(dwDLId, &pBufferTemp);
            if (SUCCEEDED(hrTemp))
            {
                TraceI(1, "Looks like buffer %d is already downloaded.", dwDLId);
                pBufferTemp->Release();
                continue;
            }

            // There is at least one buffer not downloaded, so yank back
            // everything on failure to guarantee all or nothing.
            //
            fUnloadOnFail = true;

            // We need to download. Get the buffer pointers and fill them with
            // wave data.
            //
            if (SUCCEEDED(hr))
            {
                stRead = min(m_stLength - m_stWrote, m_stReadAhead);
				hr = m_pDSWave->Write(ppv, stStart, stRead, dwDLId, dwDownloadType);
            }

            if (SUCCEEDED(hr))
            {
                // Now try to do the actual downloads
                //
                for (idxChannel = 0;
                     (idxChannel < nChannels) && SUCCEEDED(hr);
                     idxChannel++)
                {
                    hr = m_pPortDL->Download(ppBuffers[idxChannel]);
                }
            }

            TraceI(2, "Downloading wave buffers with dlid %d\n", dwDLId);

            if (SUCCEEDED(hr))
            {
                stStart += stRead;
                m_stWrote += stRead;
                m_nNextBuffer = (m_nNextBuffer + 1) % m_cSegments;
            }
        }
    }

    if (FAILED(hr) && fUnloadOnFail)
    {
        UnloadWaveBuffers();
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveDownload::UnloadWaveBuffers
//
HRESULT CDirectSoundWaveDownload::UnloadWaveBuffers()
{
    HRESULT                 hr = S_OK;

    if (m_ppWaveBuffer)
    {
        for (UINT idxWaveBuffer = 0; idxWaveBuffer < m_cWaveBuffer; idxWaveBuffer++)
        {
            if (m_ppWaveBuffer[idxWaveBuffer])
            {
                HRESULT hrTemp = m_pPortDL->Unload(m_ppWaveBuffer[idxWaveBuffer]);
				m_ppWaveBuffer[idxWaveBuffer]->Release();
				m_ppWaveBuffer[idxWaveBuffer] = NULL; // Since we unloaded the buffer, zero out the contents


                if (FAILED(hrTemp) && hrTemp != DMUS_E_NOT_DOWNLOADED_TO_PORT)
                {
                    hr = hrTemp;
                }
            }
        }
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveDownload::DownloadWaveArt
//
HRESULT CDirectSoundWaveDownload::DownloadWaveArt()
{
    HRESULT                 hr = S_OK;
    UINT                    idx;

    // First see if there are wave articulation buffers already downloaded
    //
    if (m_ppArtBuffer == NULL)
    {
        m_ppArtBuffer = new IDirectMusicDownload*[m_pDSWave->GetNumChannels()];

        hr = HRFromP(m_ppArtBuffer);

        if (SUCCEEDED(hr))
        {
            memset(m_ppArtBuffer, 0, sizeof(IDirectMusicDownload*) * m_pDSWave->GetNumChannels());

            for (idx = 0; idx < m_pDSWave->GetNumChannels() && SUCCEEDED(hr); idx++)
            {
                hr = m_pPortDL->AllocateBuffer(m_pWaveArt[idx].GetSize(), &m_ppArtBuffer[idx]);
            }
        }

        if (FAILED(hr))
        {
            if (m_ppArtBuffer)
            {
                for (idx = 0; idx < m_pDSWave->GetNumChannels(); idx++)
                {
                    RELEASE(m_ppArtBuffer[idx]);
                }

                delete[] m_ppArtBuffer;
                m_ppArtBuffer = NULL;
            }
        }
    }

    // Make sure the buffers are all allocated
    //
    if (SUCCEEDED(hr))
    {
        for (idx = 0; idx < m_pDSWave->GetNumChannels() && SUCCEEDED(hr); idx++)
        {
            if (m_ppArtBuffer[idx])
            {
                continue;
            }

            hr = m_pPortDL->AllocateBuffer(m_pWaveArt[idx].GetSize(), &m_ppArtBuffer[idx]);
        }

        if (FAILED(hr))
        {
            for (idx = 0; idx < m_pDSWave->GetNumChannels(); idx++)
            {
                RELEASE(m_ppArtBuffer[idx]);
            }

            delete[] m_ppArtBuffer;
            m_ppArtBuffer = NULL;
        }
    }

    // We have all the buffers. Try to download if needed.
    //
    if (SUCCEEDED(hr))
    {
        for (idx = 0; idx < m_pDSWave->GetNumChannels() && SUCCEEDED(hr); idx++)
        {
            IDirectMusicDownload *pBufferTemp;

            HRESULT hrTemp = m_pPortDL->GetBufferInternal(m_dwDLIdArt + idx, &pBufferTemp);
            if (SUCCEEDED(hrTemp))
            {
                pBufferTemp->Release();
            }
            else
            {
                assert(hrTemp == DMUS_E_NOT_DOWNLOADED_TO_PORT);

                LPVOID          pv;
                DWORD           cb;

                hr = m_ppArtBuffer[idx]->GetBuffer(&pv, &cb);

                if (SUCCEEDED(hr))
                {
                    m_pWaveArt[idx].Write(pv, m_dwDLIdArt + idx, m_dwDLIdWave + idx, m_dwDLIdArt);
                }

                if (SUCCEEDED(hr))
                {
                    hr = m_pPortDL->Download(m_ppArtBuffer[idx]);

                    if (FAILED(hr))
                    {
                        UnloadWaveArt();
                    }
                    else
                    {
                        TraceI(0, "Downloading wave art DLID %d\n", m_dwDLIdArt);
                    }
                }
            }
        }
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveDownload::UnloadWaveArt
//
HRESULT CDirectSoundWaveDownload::UnloadWaveArt()
{
    HRESULT                     hr = S_OK;
    UINT                        idx;

    if (m_ppArtBuffer)
    {
        for (idx = 0; idx < m_pDSWave->GetNumChannels(); idx++)
        {
            if (m_ppArtBuffer[idx])
            {
                HRESULT hrTemp = m_pPortDL->Unload(m_ppArtBuffer[idx]);
                m_ppArtBuffer[idx]->Release();
                m_ppArtBuffer[idx] = NULL; // Since we unloaded the buffer, zero out the contents

                if (FAILED(hrTemp) && hrTemp != DMUS_E_NOT_DOWNLOADED_TO_PORT)
                {
                    hr = hrTemp;
                }
            }
        }
    }

    return hr;
}

//#############################################################################
//
// CDirectSoundWave
//
// This class represents a downloaded wave object from the application's
// perspective. It is the implementation of the IDirectSoundDownloadedWave
// object returned to the application from CDirectMusicPort::DownloadWave.
//
// The actual download mechanism will either be delegated to a
// CDirectSoundWaveDownload object and done when the application requests
// the download (one-shot case) or deferred until a voice is allocated on
// the wave (streaming case). See the comments for CDirectSoundWaveDownload.
//
//#############################################################################


////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave::CDirectSoundWave
//
CDirectSoundWave::CDirectSoundWave(
    IDirectSoundWave *pIDSWave,
    bool fStreaming,
    REFERENCE_TIME rtReadAhead,
    bool fUseNoPreRoll,
    REFERENCE_TIME rtStartHint) :
    m_cRef(1),
    m_fStreaming(fStreaming),
    m_rtReadAhead(rtReadAhead),
    m_fUseNoPreRoll(fUseNoPreRoll),
    m_rtStartHint(rtStartHint),
    m_pDSWD(NULL),
    m_rpv(NULL),
    m_rpbPrecache(NULL),
	m_pSource(NULL)
{
    m_pIDSWave = pIDSWave;
    m_pIDSWave->AddRef();
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave::~CDirectSoundWave
//
CDirectSoundWave::~CDirectSoundWave()
{
    delete[] m_rpv;
    delete m_pDSWD;

    if (m_rpbPrecache)
    {
        // NOTE: Memory is allocated into first array element and the other
        // elements just point at offsets into the block, so only free
        // the first element.
        //
        delete[] m_rpbPrecache[0];
        delete[] m_rpbPrecache;
        m_rpbPrecache = NULL;
    }

    if (m_pwfex)
    {
        BYTE *pb = (BYTE*)m_pwfex;
        delete[] pb;
        m_pwfex = NULL;
    }


    RELEASE(m_pSource);
    RELEASE(m_pIDSWave);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave::QueryInterface
//
STDMETHODIMP CDirectSoundWave::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
    V_INAME(IDirectSoundWave::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IDirectSoundDownloadedWaveP)
    {
        *ppv = static_cast<IDirectSoundDownloadedWaveP*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave::AddRef
//
STDMETHODIMP_(ULONG) CDirectSoundWave::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave::Release
//
STDMETHODIMP_(ULONG) CDirectSoundWave::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        EnterCriticalSection(&sDSWaveCritSect);
        sDSWaveList.Remove(this);
        LeaveCriticalSection(&sDSWaveCritSect);

        delete this;
        return 0;
    }

    return m_cRef;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave::GetMatchingDSWave
//
// See if there's an object yet matching this IDirectSoundWave
//
CDirectSoundWave *CDirectSoundWave::GetMatchingDSWave(
    IDirectSoundWave *pIDSWave)
{
    CDirectSoundWave *pDSWave;

    EnterCriticalSection(&sDSWaveCritSect);

    for (pDSWave = sDSWaveList.GetHead(); pDSWave; pDSWave = pDSWave->GetNext())
    {
        if (pDSWave->m_pIDSWave == pIDSWave)
        {
            break;
        }
    }

    LeaveCriticalSection(&sDSWaveCritSect);

    if (pDSWave)
    {
        pDSWave->AddRef();
    }

    return pDSWave;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave::Init
//
// Save the wave format of the source wave, and verify that it's a PCM format.
//
//
HRESULT CDirectSoundWave::Init(
    CDirectMusicPortDownload *pPortDL)
{
    HRESULT hr = S_OK;

    DWORD cbwfex;

    // Get the format of the wave
    //
    if (SUCCEEDED(hr))
    {
        cbwfex = 0;
        hr = m_pIDSWave->GetFormat(NULL, 0, &cbwfex);
    }

    if (SUCCEEDED(hr))
    {
        BYTE *pb = new BYTE[cbwfex];
        m_pwfex = (LPWAVEFORMATEX)pb;

        hr = HRFromP(pb);
    }

    if (SUCCEEDED(hr))
    {
        hr = m_pIDSWave->GetFormat(m_pwfex, cbwfex, NULL);
    }

    // Synthesizers currently only support PCM format data
    //
    if (SUCCEEDED(hr) && m_pwfex->wFormatTag != WAVE_FORMAT_PCM)
    {
        hr = DMUS_E_NOTPCM;
    }

    // Figure out bytes per sample to avoid lots of divisions later
    //
    if (SUCCEEDED(hr))
    {
        m_nBytesPerSample = ((m_pwfex->wBitsPerSample + 7) / 8);
    }
    // Allocate working pointers. These are used for passing
    // to the wave object to get n channels worth of data for
    // one buffer segment. Keeping this around help us not
    // fail from out-of-memory while streaming.
    //
    if (SUCCEEDED(hr))
    {
        m_rpv = new LPVOID[GetNumChannels()];
        hr = HRFromP(m_rpv);
    }

    // Get a viewport
    //
    if (SUCCEEDED(hr))
    {
        // This is bytes per sample in one channel only.
        //
        m_cbSample = (m_pwfex->wBitsPerSample + 7) / 8;

        DWORD dwFlags = IsStreaming() ? DMUS_DOWNLOADINFO_STREAMINGWAVE : DMUS_DOWNLOADINFO_ONESHOTWAVE;
        hr = m_pIDSWave->CreateSource(&m_pSource, m_pwfex, dwFlags);
    }

    // Get the length of the wave in samples
    //
    ULONGLONG ullStreamSize;
    if (SUCCEEDED(hr))
    {
        hr = m_pSource->GetSize(&ullStreamSize);
    }

    if (SUCCEEDED(hr))
    {
        m_stLength = BytesToSamples((LONG)(ullStreamSize / GetNumChannels()));
    }

    // If a one-shot voice, this object owns the actual download
    // structures as well.
    //
    // This has to happen last because it assumes the CDirectSoundWave
    // object passed is initialized.
    //
    if (SUCCEEDED(hr) && !IsStreaming())
    {
        m_pDSWD = new CDirectSoundWaveDownload(
            this,
            pPortDL,
            0,
            ENTIRE_WAVE);
        hr = HRFromP(m_pDSWD);

        if (SUCCEEDED(hr))
        {
            hr = m_pDSWD->Init();
        }
    }

    // If this is a streaming wave, then preread starting at rtStartHint
    // so that we won't have to do this at download time.
    //
    if (SUCCEEDED(hr) && IsStreaming() && m_fUseNoPreRoll == false)
    {
        // Allocate precache pointers. This is used to
        // preread wave data so we don't have to do it
        // at download time.
        //
        SAMPLE_TIME stReadAhead = RefToSampleTime(m_rtReadAhead);
        stReadAhead *= gnDownloadBufferPerStream;
        DWORD cb = SamplesToBytes(stReadAhead);

        m_rpbPrecache = new LPBYTE[GetNumChannels()];
        hr = HRFromP(m_rpbPrecache);

        // Now get the actual precache buffers
        //
        if (SUCCEEDED(hr))
        {
            m_rpbPrecache[0] = new BYTE[cb * GetNumChannels()];
            hr = HRFromP(m_rpbPrecache);
        }

        if (SUCCEEDED(hr))
        {
            for (UINT i = 1; i < GetNumChannels(); i++)
            {
                m_rpbPrecache[i] = m_rpbPrecache[i - 1] + cb;
            }
        }

        if (SUCCEEDED(hr))
        {
            m_stStartHint = RefToSampleTime(m_rtStartHint);
            hr = Seek(m_stStartHint);
        }

        if (SUCCEEDED(hr))
        {
            LONG lReadPrecache = 2;
            ULONGLONG cbRead = cb;
            hr = m_pSource->Read((LPVOID*)m_rpbPrecache, NULL, NULL, &lReadPrecache, GetNumChannels(), &cbRead);

            if (FAILED(hr) || (((DWORD)cbRead) < cb))
            {
                // Read completed but with less sample data than we expected.
                // Fill the rest of the buffer with silence.
                //
                cb -= (DWORD)cbRead;
                BYTE bSilence = (m_pwfex->wBitsPerSample == 8) ? 0x80 : 0x00;

                for (UINT i = 0; i < GetNumChannels(); i++)
                {
                    memset(m_rpbPrecache[i] + cbRead, bSilence, cb);
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            m_stStartLength = stReadAhead;
        }
    }

    if (SUCCEEDED(hr) && !IsStreaming())
    {
        // Everything constructed. Put this object on the global list of
        // waves
        //
        EnterCriticalSection(&sDSWaveCritSect);
        sDSWaveList.AddTail(this);
        LeaveCriticalSection(&sDSWaveCritSect);
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave::GetSize
//
void CDirectSoundWave::GetSize(
    SAMPLE_TIME             stLength,
    PULONG                  pcbSize) const
{
    HRESULT                 hr = S_OK;

    // Since we're only dealing with PCM formats here, this is easy to compute
    // and is time invariant.
    //

    // If stLength is ENTIRE_WAVE, stStart must be zero.
    //
    if (stLength == ENTIRE_WAVE)
    {
        // We cached the length of the wave in Init
        //
        stLength = m_stLength;
    }

    // This is a workaround to not fail when downloading
    // the buffers to the synth. The synth will complain
    // if the buffer has no wave data so we pretend we have one sample.
    // The buffer is always aloocated to be the ReadAhead size so this
    // shouldn't cause any major problems
    if(stLength == 0)
    {
        stLength = 1;
    }

    // Bytes for one channel's worth of data
    //
    // XXX Overflow?
    //
    DWORD cbChannel = (DWORD)(stLength * m_cbSample);

    // We need:
    // 1. Download header
    // 2. Offset table (one entry per channel)
    // 3. Enough samples per each channel
    //
    *pcbSize =
        CHUNK_ALIGN(sizeof(DMUS_DOWNLOADINFO)) +
        2*sizeof(DWORD) +                       // Offset table. DWORD's are
                                                // by definition chunk aligned
        CHUNK_ALIGN(sizeof(DMUS_WAVEDL)) +
        CHUNK_ALIGN(cbChannel);
}


////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave::Write
//
//
HRESULT CDirectSoundWave::Write(
    LPVOID                  rpv[],
    SAMPLE_TIME             stStart,
    SAMPLE_TIME             stLength,
    DWORD                   dwDLId,
    DWORD                   dwDLType) const
{
    HRESULT                 hr = S_OK;
    DWORD                   cbWaveData;
    ULONGLONG               cbBytesRead = 0;
    bool                    fUsingPrecache = false;
    bool                    fPartialPreCache = false;
    DWORD                   offPrecache;

    if (IsStreaming() && 
        m_fUseNoPreRoll == false &&
        m_stStartHint <= stStart &&
        stStart <= m_stStartHint + m_stStartLength)
    {
        fUsingPrecache = true;
        offPrecache = SamplesToBytes(stStart - m_stStartHint);
    }

    if((stStart + stLength > m_stStartHint + m_stStartLength) && fUsingPrecache)
    {
        fPartialPreCache = true;
    }

    cbWaveData = SamplesToBytes(stLength);

    for (UINT idxChannel = 0;
         idxChannel < m_pwfex->nChannels && SUCCEEDED(hr);
         idxChannel++)
    {
        unsigned char *pdata = (unsigned char *)rpv[idxChannel];

        // First we have the download header
        //
        DMUS_DOWNLOADINFO *pdmdli = (DMUS_DOWNLOADINFO *)pdata;

        memset(pdmdli, 0, sizeof(DMUS_DOWNLOADINFO));
        pdmdli->dwDLType                = dwDLType;
        pdmdli->dwDLId                  = dwDLId + idxChannel;
        pdmdli->dwNumOffsetTableEntries = 2;

        GetSize(stLength, &pdmdli->cbSize);

        pdata += CHUNK_ALIGN(sizeof(DMUS_DOWNLOADINFO));

        // Offset table
        //
        DMUS_OFFSETTABLE *pot = (DMUS_OFFSETTABLE*)pdata;
        pdata += CHUNK_ALIGN(sizeof(ULONG) * 2);

        // Wave header chunk
        //
        pot->ulOffsetTable[0] = (ULONG)(pdata - (unsigned char*)rpv[idxChannel]);

        // Wave data chunk
        //
        DMUS_WAVEDL *pwdl = (DMUS_WAVEDL *)pdata;
        pdata += CHUNK_ALIGN(sizeof(DMUS_WAVEDL));

        pwdl->cbWaveData = cbWaveData;

        // Save off pointer to this channel's wave data
        //
        pot->ulOffsetTable[1] = (ULONG)(pdata - (unsigned char*)rpv[idxChannel]);
        m_rpv[idxChannel] = (LPVOID)pdata;
    }

    // Fill in the wave data
    //
    if (SUCCEEDED(hr))
    {
        DWORD cbPreCache = cbWaveData;
        cbBytesRead = cbPreCache;
        ULONGLONG cbRead = 0;

        if(fPartialPreCache)
        {
            SAMPLE_TIME stPreCache = (m_stStartHint + m_stStartLength) - stStart;
            cbPreCache = SamplesToBytes(stPreCache);
            cbRead = cbWaveData - cbPreCache;
        }

        if (fUsingPrecache)
        {
            for (UINT i = 0; i < GetNumChannels(); i++)
            {
                memcpy(m_rpv[i], m_rpbPrecache[i] + offPrecache, cbPreCache);
            }

            // Cache doesn't have enough data so we read the rest
            if(fPartialPreCache)
            {
                // Allocate a temporary pool of buffers to read data into
                LPBYTE* ppbData = new LPBYTE[GetNumChannels()];
                hr = HRFromP(ppbData);

                if(SUCCEEDED(hr))
                {
                    ppbData[0] = new BYTE[(DWORD)(cbRead * GetNumChannels())];
                    hr = HRFromP(ppbData);
                }

                if (SUCCEEDED(hr))
                {
                    for (UINT nChannel = 1; nChannel < GetNumChannels(); nChannel++)
                    {
                        ppbData[nChannel] = ppbData[nChannel - 1] + cbRead;
                    }
                }

                if(SUCCEEDED(hr))
                {
                    // Seek to precache position
                    DWORD cbNewPos = SamplesToBytes(m_stStartHint + m_stStartLength) * GetNumChannels();
                    hr = m_pSource->Seek(cbNewPos);

                    // And read the required number of bytes from there
                    // We use the LPLONG plPitchShifts in the read method as a boolean
                    // this is a HACK!! We need to change this...
                    LONG lPreCacheRead = 1;
                    hr = m_pSource->Read((void**)ppbData, NULL, NULL, &lPreCacheRead, m_pwfex->nChannels, &cbRead);
                }

                if(SUCCEEDED(hr))
                {
                    cbBytesRead += cbRead;

                    // Copy all the data to the actual buffer
                    for (UINT i = 0; i < GetNumChannels(); i++)
                    {
                        memcpy((BYTE*)m_rpv[i] + cbPreCache, ppbData[i], (DWORD)cbRead);
                    }
                }


                if(ppbData)
                {
                    delete[] ppbData[0];
                    delete[] ppbData;
                }
            }
            else if(stStart + stLength >= m_stStartHint + m_stStartLength)
            {
                // Seek is exactly after the precached samples
                DWORD cbNewPos = SamplesToBytes(m_stStartHint + m_stStartLength) * GetNumChannels();
                hr = m_pSource->Seek(cbNewPos);
            }
            else
            {
                // We might have a wave that's shorter than the read-ahead time
                DWORD cbNewPos = SamplesToBytes(stStart + stLength) * GetNumChannels();
                hr = m_pSource->Seek(cbNewPos);
            }
        }
        else
        {
            cbRead = cbWaveData;
            hr = m_pSource->Read(m_rpv, NULL, NULL, NULL, m_pwfex->nChannels, &cbRead);
        }
    }

    if (SUCCEEDED(hr) && cbWaveData != cbBytesRead)
    {
        // Read completed but with less sample data than we expected.
        //
        hr = S_FALSE;
    }

    return hr;
}


////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave::RefillBuffers
//
// rpv[] points to one sample buffer per channel
// stStart is the sample starting position within the stream
// stLength is how many samples to read
// stBufferSize is how big the buffers actually are (>= stLength)
//
// If stLength < stBufferSize or there is not enough data left
// in the stream, then fill with PCM silence for the rest of
// the buffer.
//
// Returns S_FALSE if we padded with silence (and therefore
// are past the end of the stream).
//
HRESULT CDirectSoundWave::RefillBuffers(
    LPVOID                  rpv[],
    SAMPLE_TIME             stStart,
    SAMPLE_TIME             stLength,
    SAMPLE_TIME             stBufferSize)
{
    HRESULT                 hr = S_OK;
    ULONGLONG               cbRead;
    DWORD                   cbLength = SamplesToBytes(stLength);
    DWORD                   cbBuffer = SamplesToBytes(stBufferSize);
    UINT                    idxChannel;

    for (idxChannel = 0;
         idxChannel < m_pwfex->nChannels && SUCCEEDED(hr);
         idxChannel++)
    {
        unsigned char *pdata = (unsigned char *)rpv[idxChannel];
        DMUS_OFFSETTABLE *pot =
            (DMUS_OFFSETTABLE *)(pdata + CHUNK_ALIGN(sizeof(DMUS_DOWNLOADINFO)));

        // Update length of data in buffer
        //
        DMUS_WAVEDL *pwdl = (DMUS_WAVEDL*)(pdata + pot->ulOffsetTable[0]);
        pwdl->cbWaveData = SamplesToBytes(stLength);

        // Where to put it
        //
        m_rpv[idxChannel] = pdata + pot->ulOffsetTable[1];
    }

    cbRead = 0;
    if (SUCCEEDED(hr))
    {
        cbRead = cbLength;
        if(stStart == m_stStartHint + m_stStartLength)
        {
            // We use the LPLONG plPitchShifts in the read method as a boolean
            // this is a HACK!! We need to change this...
            LONG lPreCacheRead = 1;
            hr = m_pSource->Read(m_rpv, NULL, NULL, &lPreCacheRead, m_pwfex->nChannels, &cbRead);
        }
        else
        {
            hr = m_pSource->Read(m_rpv, NULL, NULL, NULL, m_pwfex->nChannels, &cbRead);
        }
    }

    TraceI(0, "Wave: RefillBuffer read %d buffer %d bytes hr %08X\n", (DWORD)cbRead, (DWORD)cbBuffer, hr);

    if (FAILED(hr) || (SUCCEEDED(hr) && (cbRead < cbBuffer)))
    {
        // Read completed but with less sample data than we expected.
        // Fill the rest of the buffer with silence.
        //
        cbBuffer -= (DWORD)cbRead;
        BYTE bSilence = (m_pwfex->wBitsPerSample == 8) ? 0x80 : 0x00;

        for (idxChannel = 0; idxChannel < m_pwfex->nChannels; idxChannel++)
        {
            memset(((LPBYTE)m_rpv[idxChannel]) + cbRead, bSilence, cbBuffer);
        }

        TraceI(0, "Wave: RefillBuffer padded with silence\n");
        hr = S_FALSE;
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave::RefToSampleTime
//
SAMPLE_TIME CDirectSoundWave::RefToSampleTime(REFERENCE_TIME rt) const
{
    // For PCM, the samples per second metric in the waveformat is exact.
    //
    return (rt * m_pwfex->nSamplesPerSec) / gnRefTicksPerSecond;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave::Download
//
HRESULT CDirectSoundWave::Download()
{
    if (m_pDSWD)
    {
        return m_pDSWD->Download();
    }

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave::Unload
//
HRESULT CDirectSoundWave::Unload()
{
    if (m_pDSWD)
    {
        return m_pDSWD->Unload();
    }

    return S_OK;
}

//#############################################################################
//
// CDirectSoundWaveArt
//
// Implements calculating and writing the wave articulation header into a
// download buffer.
//
//#############################################################################

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveArt::CDirectSoundWaveArt
//
//
CDirectSoundWaveArt::CDirectSoundWaveArt()
{
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveArt::CDirectSoundWaveArt
//
//
CDirectSoundWaveArt::~CDirectSoundWaveArt()
{
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveArt::Init
//
//
HRESULT CDirectSoundWaveArt::Init(
    CDirectSoundWave        *pDSWave,
    UINT                    nSegments,
    DWORD                   dwBus,
    DWORD                   dwFlags)
{
    HRESULT                 hr = S_OK;

    m_pDSWave = pDSWave;
    const LPWAVEFORMATEX    pwfex = pDSWave->GetWaveFormat();

    // Cache wave format size
    //
    m_cbWaveFormat = sizeof(PCMWAVEFORMAT);
    if (pwfex->wFormatTag != WAVE_FORMAT_PCM)
    {
        m_cbWaveFormat = sizeof(WAVEFORMATEX) + pwfex->cbSize;
    }

    if (SUCCEEDED(hr))
    {
        // This stuff in the wave articulation never changes
        //
        m_WaveArtDL.ulDownloadIdIdx = 1;
        m_WaveArtDL.ulBus           = dwBus;
        m_WaveArtDL.ulBuffers       = nSegments;
        m_WaveArtDL.usOptions       = (USHORT)dwFlags;

        m_nDownloadIds = nSegments;
        DWORD cbDLIds = sizeof(DWORD) * m_nDownloadIds;

        m_cbSize =
            CHUNK_ALIGN(sizeof(DMUS_DOWNLOADINFO)) +
            CHUNK_ALIGN(3 * sizeof(ULONG)) +            // 3 entry offset table
            CHUNK_ALIGN(sizeof(DMUS_WAVEARTDL)) +
            CHUNK_ALIGN(m_cbWaveFormat) +
            CHUNK_ALIGN(cbDLIds);
    }

   return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveArt::Write
//
// Write the wave articulation into the buffer
//
//
void CDirectSoundWaveArt::Write(
    void                    *pv,                // To pack into
    DWORD                   dwDLIdArt,          // Articulation chunk DLID
    DWORD                   dwDLIdWave,         // First wave DLId
    DWORD                   dwMasterDLId)       // DLId of group master
{
    unsigned char *pdata = (unsigned char *)pv;
    DMUS_DOWNLOADINFO *pdmdli = (DMUS_DOWNLOADINFO *)pdata;

    memset(pdmdli, 0, sizeof(DMUS_DOWNLOADINFO));
    pdmdli->dwDLType                = DMUS_DOWNLOADINFO_WAVEARTICULATION;
    pdmdli->dwDLId                  = dwDLIdArt;
    pdmdli->dwNumOffsetTableEntries = 3;
    pdmdli->cbSize                  = GetSize();

    pdata += CHUNK_ALIGN(sizeof(DMUS_DOWNLOADINFO));

    DMUS_OFFSETTABLE *pot = (DMUS_OFFSETTABLE*)pdata;
    pdata += CHUNK_ALIGN(3 * sizeof(ULONG));

    pot->ulOffsetTable[0] = (ULONG)(pdata - (unsigned char *)pv);
    m_WaveArtDL.ulMasterDLId = dwMasterDLId;
    memcpy(pdata, &m_WaveArtDL, sizeof(DMUS_WAVEARTDL));

    pdata += sizeof(DMUS_WAVEARTDL);
    pot->ulOffsetTable[1] = (ULONG)(pdata - (unsigned char *)pv);

    const LPWAVEFORMATEX     pwfex = m_pDSWave->GetWaveFormat();
    memcpy(pdata, pwfex, m_cbWaveFormat);

    pdata += CHUNK_ALIGN(m_cbWaveFormat);
    pot->ulOffsetTable[2] = (ULONG)(pdata - (unsigned char *)pv);

    // Get the download ID's. The download ID's for each buffer are
    // grouped together.
    //
    DWORD nChannels = pwfex->nChannels;
    DWORD dwLastWaveDLId = dwDLIdWave + nChannels * m_WaveArtDL.ulBuffers;
    DWORD dwDLId;
    DWORD *pdw = (DWORD*)pdata;

    for (dwDLId = dwDLIdWave; dwDLId < dwLastWaveDLId; dwDLId += nChannels, pdw++)
    {
        *pdw = dwDLId;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\oledll.h ===
//
// OleDLL.h
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// @doc INTERNAL
//
//
#ifndef _OLEDLL_
#define _OLEDLL_

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID);

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID);

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue);
				 
HRESULT CLSIDToStr(const CLSID &clsid,
				   TCHAR *szStr,
				   int cbStr);

HRESULT StrToCLSID(TCHAR *szStr,
				   CLSID &clsid,
				   int cbStr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\oledll.cpp ===
// oledll.cpp
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Handle standard stuff for OLE server DLL
//
#include <objbase.h>
#include "debug.h"
#include <iostream.h>

#include "oledll.h"

#ifdef UNICODE
#ifndef UNDER_CE
#error DirectMusic Win NT/9x must be compiled without UNICODE
#endif
#endif

static const TCHAR g_szCLSID[]           = TEXT("CLSID");
static const TCHAR g_szCLSIDSlash[]      = TEXT("CLSID\\");
static const TCHAR g_szInProc32[]        = TEXT("InProcServer32");
static const TCHAR g_szProgIDKey[]       = TEXT("ProgID");
static const TCHAR g_szVerIndProgIDKey[] = TEXT("VersionIndependentProgID");
static const TCHAR g_szCurVer[]          = TEXT("CurVer"); 
static const TCHAR g_szThreadingModel[]	= TEXT("ThreadingModel");
static const TCHAR g_szBoth[]		= TEXT("Both");

static const int CLSID_STRING_SIZE = 39;

static LONG RegSetDefValue(LPCTSTR pstrKey, LPCTSTR pstrSubkey, LPCTSTR pstrValueName, LPCTSTR pstrValue);
static void RegRemoveSubtree(HKEY hk, LPCTSTR pstrChild);

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    LONG lr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    TCHAR szModule[512];
    lr = ::GetModuleFileName(hModule, szModule, sizeof(szModule));
    assert(lr);

    lr = 0;

    lr |= RegSetDefValue(szClsKey, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szClsKey, g_szInProc32, NULL, szModule);
	lr |= RegSetDefValue(szClsKey, g_szInProc32, g_szThreadingModel, g_szBoth);
    lr |= RegSetDefValue(szClsKey, g_szProgIDKey, NULL, szProgID);
    lr |= RegSetDefValue(szClsKey, g_szVerIndProgIDKey, NULL, szVerIndProgID);

    lr |= RegSetDefValue(szVerIndProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szVerIndProgID, g_szCLSID, NULL, szCLSID);
    lr |= RegSetDefValue(szVerIndProgID, g_szCurVer, NULL, szProgID);
    
	lr |= RegSetDefValue(szProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szProgID, g_szCLSID, NULL, szCLSID);

#if 0 
    if (lr) {
        UnregisterServer(clsid,
                         szFriendlyName,
                         szVerIndProgID,
                         szProgID);
        // ???
        //
        return S_OK;
    }
#endif

    return S_OK;
}

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    RegRemoveSubtree(HKEY_CLASSES_ROOT, szClsKey);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szVerIndProgID);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szProgID);

    return S_OK;
}

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    HKEY hk;
	DWORD dw;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);
	lstrcat(szClsKey, TEXT("\\"));
    if (szKey)
    {
	    lstrcat(szClsKey, szKey);
    }

	if (RegOpenKeyEx(HKEY_CLASSES_ROOT,
					 szClsKey,
					 0,
					 KEY_READ,
					 &hk)) {
		return FALSE;
	}

	if (RegQueryValueEx(hk,
						NULL,
						NULL,
						&dw,
						(LPBYTE)pValue,
						pcbValue)) {
		RegCloseKey(hk);
		return FALSE;
	}

	RegCloseKey(hk);
	
	return TRUE;
}

HRESULT
CLSIDToStr(const CLSID &clsid,
           TCHAR *szStr,
           int cbStr)
{
    // XXX What to return here?
    //
    assert(cbStr >= CLSID_STRING_SIZE);
    
	LPOLESTR wszCLSID = NULL;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
    if (!SUCCEEDED(hr)) {
        return hr;
    }

#ifdef UNICODE
    lstrcpy(szStr, wszCLSID);
#else
	// Covert from wide characters to non-wide.
	wcstombs(szStr, wszCLSID, cbStr);
#endif

	// Free memory.
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

HRESULT
StrToCLSID(TCHAR *szStr,
		   CLSID &clsid,
		   int cbStr)
{
#ifdef UNICODE
    return CLSIDFromString(szStr, &clsid);
#else    
	WCHAR wsz[512];
    if (cbStr > 512)
    {
        cbStr = 512;
    }

	mbstowcs(wsz, szStr, cbStr);

	return CLSIDFromString(wsz, &clsid);
#endif
}
   

static LONG
RegSetDefValue(LPCTSTR pstrKey,
               LPCTSTR pstrSubkey,
			   LPCTSTR pstrValueName,
               LPCTSTR pstrValue)
{
    HKEY hk;
    LONG lr;
    TCHAR sz[1024];
    LPCTSTR pstr;

    if (!pstrSubkey) {
        pstr = pstrKey;
    } else {
        lstrcpy(sz, pstrKey);
        lstrcat(sz, TEXT("\\"));
        lstrcat(sz, pstrSubkey);
        pstr = sz;
    }

    lr = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                        pstr,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hk,
                        NULL);
    if (lr) {
        return lr;
    }

    lr = RegSetValueEx(hk,
                       pstrValueName,
                       0,
                       REG_SZ,
                       (CONST BYTE*)pstrValue,
                       1+lstrlen(pstrValue));
    RegCloseKey(hk);

    return lr;
}

static void
RegRemoveSubtree(HKEY hk,
                 LPCTSTR pstrChild)
{
    LONG lResult;
    HKEY hkChild;

    lResult = RegOpenKeyEx(hk,
                           pstrChild,
                           0,
                           KEY_ALL_ACCESS,
                           &hkChild);
    if (lResult) {
        return;
    }

#ifndef UNDER_CE    // CE doesn't support RegEnumKey()
    TCHAR szSubkey[256];

    // NOTE: Unlike regular enumeration, we always grab the 0th item
    // and delete it.
    //
    while (!RegEnumKey(hkChild, 0, szSubkey, sizeof(szSubkey))) {
        RegRemoveSubtree(hkChild, szSubkey);
    }
#endif    

    RegCloseKey(hkChild);
    RegDeleteKey(hk, pstrChild);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\suwrap.h ===
//
// suwrap.h
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// @doc INTERNAL
//
//
//
//
//
#ifndef _SUWRAP_
#define _SUWRAP_

#include <setupapi.h>

typedef BOOL (*PDESTROYDEVICEINFOLIST)(
    IN HDEVINFO DeviceInfoSet
    );

typedef BOOL (*PENUMDEVICEINTERFACES)(
    IN  HDEVINFO                  DeviceInfoSet,
    IN  PSP_DEVINFO_DATA          DeviceInfoData,     OPTIONAL
    IN  LPGUID                    InterfaceClassGuid,
    IN  DWORD                     MemberIndex,
    OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData
    );


typedef HDEVINFO (*PSETUPDIGETCLASSDEVS)(
    IN LPGUID ClassGuid,  OPTIONAL
    IN PCSTR  Enumerator, OPTIONAL
    IN HWND   hwndParent, OPTIONAL
    IN DWORD  Flags
);

typedef BOOL (*PSETUPDIGETDEVICEINTERFACEDETAIL)(
    IN  HDEVINFO                           DeviceInfoSet,
    IN  PSP_DEVICE_INTERFACE_DATA          DeviceInterfaceData,
    OUT PSP_DEVICE_INTERFACE_DETAIL_DATA_A DeviceInterfaceDetailData,     OPTIONAL
    IN  DWORD                              DeviceInterfaceDetailDataSize,
    OUT PDWORD                             RequiredSize,                  OPTIONAL
    OUT PSP_DEVINFO_DATA                   DeviceInfoData                 OPTIONAL
    );
    
typedef BOOL (*PSETUPDIGETDEVICEINSTANCEID)(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    OUT PSTR             DeviceInstanceId,
    IN  DWORD            DeviceInstanceIdSize,
    OUT PDWORD           RequiredSize          OPTIONAL
    );


class SetupAPI
{
public:
    SetupAPI();
    ~SetupAPI();

    BOOL IsValid();

    BOOL        SetupDiDestroyDeviceInfoList(HDEVINFO DeviceInfoSet);

    BOOL        SetupDiEnumDeviceInterfaces(HDEVINFO DeviceInfoSet,
                                            PSP_DEVINFO_DATA DeviceInfoData,
                                            LPGUID InterfaceClassGuid,
                                            DWORD MemberIndex,
                                            PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData);
    
    HDEVINFO    SetupDiGetClassDevs(LPGUID ClassGuid, PCSTR Enumerator, HWND hwndParent, DWORD Flags);

    BOOL        SetupDiGetDeviceInterfaceDetail(HDEVINFO DeviceInfoSet,
                                                PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
                                                PSP_DEVICE_INTERFACE_DETAIL_DATA_A DeviceInterfaceDetailData,
                                                DWORD DeviceInterfaceDetailDataSize,
                                                PDWORD RequiredSize,
                                                PSP_DEVINFO_DATA DeviceInfoData);
    BOOL        SetupDiGetDeviceInstanceId(HDEVINFO DeviceInfoSet,
                                           PSP_DEVINFO_DATA DeviceInfoData,
                                           PSTR DeviceInstanceId,
                                           DWORD DeviceInstanceIdSize,
                                           PDWORD RequiredSize);
                                                

private:
    HMODULE                     m_hmodule;
    BOOL                        m_fValid;

    PDESTROYDEVICEINFOLIST              m_pfnDestroyDeviceInfoList;
    PENUMDEVICEINTERFACES               m_pfnEnumDeviceInterfaces;
    PSETUPDIGETCLASSDEVS                m_pfnGetClassDevs;
    PSETUPDIGETDEVICEINTERFACEDETAIL    m_pfnGetDeviceInterfaceDetail;
    PSETUPDIGETDEVICEINSTANCEID         m_pfnGetDeviceInstanceId;
};

#endif // _SUWRAP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\suwrap.cpp ===
//
// suwrap.cpp
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Wrap needed SetupAPI calls through LoadLibrary so they are only
// called on a platform that supports them.
//
#include <windows.h>
#include "debug.h"
#include <setupapi.h>

#include "debug.h"
#include "suwrap.h"

static const char szSetupAPI[]                  = "setupapi.dll";

static const char szDestroyDeviceInfoList[]     = "SetupDiDestroyDeviceInfoList";
static const char szEnumDeviceInterfaces[]      = "SetupDiEnumDeviceInterfaces";
static const char szGetClassDevs[]              = "SetupDiGetClassDevsA";
static const char szGetDeviceInterfaceDetail[]  = "SetupDiGetDeviceInterfaceDetailA";
static const char szGetDeviceInstanceId[]       = "SetupDiGetDeviceInstanceIdA";

SetupAPI::SetupAPI()
{
    m_fValid = FALSE;
    m_hmodule = LoadLibrary(szSetupAPI);
    if (m_hmodule == (HMODULE)NULL)
    {
        TraceI(0, "SetupAPI: Could not LoadLibrary; error %d", GetLastError());
        goto Cleanup;
    }

    m_pfnGetClassDevs = (PSETUPDIGETCLASSDEVS)GetProcAddress(m_hmodule, szGetClassDevs);
    if (!m_pfnGetClassDevs)
    {
        TraceI(0, "SetupAPI: Could not GetProcAddress(%s)", szGetClassDevs);
        goto Cleanup;
    }

    m_pfnEnumDeviceInterfaces = (PENUMDEVICEINTERFACES)GetProcAddress(m_hmodule, szEnumDeviceInterfaces);
    if (!m_pfnEnumDeviceInterfaces)
    {
        TraceI(0, "SetupAPI: Could not GetProcAddress(%s)", szEnumDeviceInterfaces);
        goto Cleanup;
    }

    m_pfnDestroyDeviceInfoList = (PDESTROYDEVICEINFOLIST)GetProcAddress(m_hmodule, szDestroyDeviceInfoList);
    if (!m_pfnDestroyDeviceInfoList)
    {
        TraceI(0, "SetupAPI: Could not GetProcAddress(%s)", szDestroyDeviceInfoList);
        goto Cleanup;
    }
    
    m_pfnGetDeviceInterfaceDetail = (PSETUPDIGETDEVICEINTERFACEDETAIL)GetProcAddress(m_hmodule, szGetDeviceInterfaceDetail);
    if (!m_pfnGetDeviceInterfaceDetail)
    {
        TraceI(0, "SetupAPI: Could not GetProcAddress(%s)", szGetDeviceInterfaceDetail);
        goto Cleanup;
    }

    // SetupDiGetDeviceInstanceId is not available on Win9x, so succeed w/o it
    //
    m_pfnGetDeviceInstanceId = (PSETUPDIGETDEVICEINSTANCEID)GetProcAddress(m_hmodule, szGetDeviceInstanceId);
    if (!m_pfnGetDeviceInstanceId)
    {
        TraceI(0, "SetupAPI: Could not GetProcAddress(%s)", szGetDeviceInstanceId);
    }

    m_fValid = TRUE;

Cleanup:
    if (!m_fValid && m_hmodule != (HMODULE)NULL)
    {
        FreeLibrary(m_hmodule);
        m_hmodule = NULL;                                
    }
}

SetupAPI::~SetupAPI()
{
    if (m_hmodule)
    {
        FreeLibrary(m_hmodule);
    }
}

BOOL SetupAPI::IsValid()
{
    return (BOOL)(m_hmodule != (HMODULE)NULL);
}

BOOL SetupAPI::SetupDiDestroyDeviceInfoList(
    HDEVINFO DeviceInfoSet)
{
    assert(m_fValid);

    return (*m_pfnDestroyDeviceInfoList)(DeviceInfoSet);
}

BOOL SetupAPI::SetupDiEnumDeviceInterfaces(HDEVINFO DeviceInfoSet,
                                           PSP_DEVINFO_DATA DeviceInfoData,
                                           LPGUID InterfaceClassGuid,
                                           DWORD MemberIndex,
                                           PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData)
{
    assert(m_fValid);

    return (*m_pfnEnumDeviceInterfaces)(DeviceInfoSet,
                                        DeviceInfoData,
                                        InterfaceClassGuid,
                                        MemberIndex,
                                        DeviceInterfaceData);
}                                           


HDEVINFO SetupAPI::SetupDiGetClassDevs(
    LPGUID ClassGuid, 
    PCSTR Enumerator, 
    HWND hwndParent, 
    DWORD Flags)
{
    assert(m_fValid);

    return (*m_pfnGetClassDevs)(ClassGuid, Enumerator, hwndParent, Flags);
}

BOOL SetupAPI::SetupDiGetDeviceInterfaceDetail(HDEVINFO DeviceInfoSet,
                                               PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
                                               PSP_DEVICE_INTERFACE_DETAIL_DATA_A DeviceInterfaceDetailData,
                                               DWORD DeviceInterfaceDetailDataSize,
                                               PDWORD RequiredSize,
                                               PSP_DEVINFO_DATA DeviceInfoData)
{
    assert(m_fValid);

    return (*m_pfnGetDeviceInterfaceDetail)(DeviceInfoSet,
                                            DeviceInterfaceData,
                                            DeviceInterfaceDetailData,
                                            DeviceInterfaceDetailDataSize,
                                            RequiredSize,
                                            DeviceInfoData);
}

BOOL SetupAPI::SetupDiGetDeviceInstanceId(HDEVINFO DeviceInfoSet,
                                          PSP_DEVINFO_DATA DeviceInfoData,
                                          PSTR DeviceInstanceId,
                                          DWORD DeviceInstanceIdSize,
                                          PDWORD RequiredSize)
{
    if (!m_pfnGetDeviceInstanceId)
    {
        SetLastError(ERROR_BAD_COMMAND);
        return FALSE;
    }

    return (*m_pfnGetDeviceInstanceId)(DeviceInfoSet,
                                       DeviceInfoData,
                                       DeviceInstanceId,
                                       DeviceInstanceIdSize,
                                       RequiredSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\sysaudio.cpp ===
//
// SysAudio.CPP
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Interfaces to the WDM System Audio Device
//
#include <objbase.h>
#include <devioctl.h>
#include <setupapi.h>
#include <mmsystem.h>
#include <mmddkp.h>
#include <regstr.h>

#ifndef DRVM_MAPPER_PREFERRED_GET
#define DRVM_MAPPER_PREFERRED_GET                 (DRVM_MAPPER+21)
#endif

#include "dmusicp.h"
#include "debug.h"

#include "suwrap.h"

static int  GetPreferredAudioPlaybackDeviceId();
static BOOL WaveOutIdToInstanceId(int iDeviceId, char **ppInstanceId);

#ifdef DBG
extern void _TraceIGuid(int iLevel, GUID *pGUID);
#define TraceIGuid _TraceIGuid
#else
#define TraceIGuid(x,y)
#endif


typedef struct tag_KSPROPERTYDEVICEINDEX
{
    KSPROPERTY Property;
    ULONG      DeviceIndex;
}   KSPROPERTYDEVICEINDEX, 
    *PKSPROPERTYDEVICEINDEX;


// OpenDefaultDevice
//
// Use the SetupDi API's to retrieve the path of the SysAudio filter and open
// a handle to it.
//
// Handle should be closed with CloseHandle when done using it.
//
// Returns TRUE on success
//
BOOL OpenDefaultDevice(
    IN REFGUID           rguidCategory,
    OUT HANDLE          *pHandle)
{
    BOOL fResult = FALSE;
    SetupAPI suwrap;

    if (!suwrap.IsValid()) 
    {
        return FALSE;
    }

    *pHandle = (HANDLE)NULL;

    // Get the device class for KSCATEGORY_SYSAUDIO
    //
	GUID *pClassGuid = const_cast<GUID*>(&rguidCategory);  //KSCATEGORY_SYSAUDIO);
	HDEVINFO hDevInfo = suwrap.SetupDiGetClassDevs(pClassGuid,
											NULL,
											NULL,
											DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);
	if (hDevInfo == NULL || hDevInfo == INVALID_HANDLE_VALUE)
	{
		TraceI(0, "Could not open SetupDiGetClassDevs\n");
        return FALSE;
	}

    // Get device details. There should only be one SysAudio.
    //
	SP_DEVICE_INTERFACE_DATA DevInterfaceData;
	DevInterfaceData.cbSize = sizeof(DevInterfaceData);

	BYTE rgbStorage[sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) + _MAX_PATH];
	SP_DEVICE_INTERFACE_DETAIL_DATA * pDevInterfaceDetails = (SP_DEVICE_INTERFACE_DETAIL_DATA *)rgbStorage;
	pDevInterfaceDetails->cbSize = sizeof(*pDevInterfaceDetails);

	if (suwrap.SetupDiEnumDeviceInterfaces(hDevInfo, NULL, pClassGuid, 0, &DevInterfaceData))
    {
		if (suwrap.SetupDiGetDeviceInterfaceDetail(hDevInfo, 
		                                    &DevInterfaceData, 
		                                    pDevInterfaceDetails,
 										    sizeof(rgbStorage), 
 										    NULL, 
 										    NULL))
        {
            // Have to convert this since there's no CreateFileW on Win9x.
            //
            HANDLE hFilter = CreateFile(pDevInterfaceDetails->DevicePath,
                                        GENERIC_READ | GENERIC_WRITE, 
                                        0,
                                        NULL,
                                        OPEN_EXISTING,
                                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                                        NULL);
            if (hFilter != NULL && hFilter != INVALID_HANDLE_VALUE)
            {
                *pHandle = hFilter;
                fResult = TRUE;
            }
            else
            {
                TraceI(0, "Open of SysAudio filter failed.\n");
            }
        }
        else
        {
            TraceI(0, "SetUpDiGetDeviceInterfaceDetail failed\n");
        }
    }
    else
    {
        TraceI(0, "SetUpDiEnumDeviceInterfaces failed\n");
    }

    suwrap.SetupDiDestroyDeviceInfoList(hDevInfo);

    return fResult;
}

// IsEqualInterface
//
// Check the equality of two KS pin interfaces
//
BOOL IsEqualInterface(
    const KSPIN_INTERFACE *pInterface1,
    const KSPIN_INTERFACE *pInterface2)
{
    return ( IsEqualGUID(pInterface1->Set, pInterface2->Set) &&
             (pInterface1->Id    == pInterface2->Id)           &&
             (pInterface1->Flags == pInterface2->Flags) );
}

// CreatePin
//
// Given a handle to SysAudio with the default device set, create a handle to the given pin.
//
HRESULT CreatePin(
    IN      HANDLE          handleFilter,
    IN      ULONG           ulPinId,
    OUT     HANDLE          *pHandle)
{
    static char szKsCreatePin[] = "KsCreatePin";

    DWORD (WINAPI *pKsCreatePin)(HANDLE, PKSPIN_CONNECT, ACCESS_MASK, PHANDLE);
    PKSPIN_CONNECT  pKsPinConnect;
    PKSDATAFORMAT   pKsDataFormat;

    *pHandle = NULL;

    if (!LoadKsUser())
    {
        TraceI(0, "CDirectMusicPort::Init() -> No KSUSER.DLL handle");
        return E_NOINTERFACE;
    }

    pKsCreatePin = (DWORD (WINAPI *)(HANDLE, PKSPIN_CONNECT, ACCESS_MASK, PHANDLE))
                   GetProcAddress(g_hModuleKsUser, szKsCreatePin);
    if (!pKsCreatePin)
    {
        TraceI(0, "CDirectMusicPort::Init() -> No entry point");
        return E_NOINTERFACE;
    }

    pKsPinConnect = (PKSPIN_CONNECT)LocalAlloc(LPTR, sizeof(KSPIN_CONNECT) + sizeof(KSDATAFORMAT));

    if (!pKsPinConnect)
    {
        TraceI(0, "LocalAlloc failed in CreatePin\n");
        return E_OUTOFMEMORY;
    }

    pKsPinConnect->Interface.Set              = KSINTERFACESETID_Standard;
    pKsPinConnect->Interface.Id               = KSINTERFACE_STANDARD_STREAMING;
    pKsPinConnect->Interface.Flags            = 0;
    pKsPinConnect->Medium.Set                 = KSMEDIUMSETID_Standard;
    pKsPinConnect->Medium.Id                  = KSMEDIUM_TYPE_ANYINSTANCE;
    pKsPinConnect->Medium.Flags               = 0;
    pKsPinConnect->PinId                      = ulPinId;
    pKsPinConnect->PinToHandle                = NULL;
    pKsPinConnect->Priority.PriorityClass     = KSPRIORITY_NORMAL;
    pKsPinConnect->Priority.PrioritySubClass  = 1;

    pKsDataFormat = PKSDATAFORMAT(pKsPinConnect + 1);
    pKsDataFormat->FormatSize     = sizeof(KSDATAFORMAT);
    pKsDataFormat->Reserved       = 0;
    pKsDataFormat->MajorFormat    = KSDATAFORMAT_TYPE_MUSIC;
    pKsDataFormat->SubFormat      = KSDATAFORMAT_SUBTYPE_DIRECTMUSIC;
    pKsDataFormat->Specifier      = KSDATAFORMAT_SPECIFIER_NONE;

    
    DWORD dwRes = (*pKsCreatePin)(handleFilter,
                                  pKsPinConnect,
                                  GENERIC_WRITE | GENERIC_READ,
                                  pHandle);
    if (dwRes != ERROR_SUCCESS)
    {
        LocalFree(pKsPinConnect);
        return WIN32ERRORtoHRESULT(dwRes);
    }

    LocalFree(pKsPinConnect);
    return S_OK;
}

// GetSizedProperty
//
// Retrieve a property of which the size is unknown. 
//
BOOL GetSizedProperty(
    IN      HANDLE      handle,
    IN      ULONG       ulPropSize,
    IN      PKSPROPERTY pKsProperty,
    OUT     PVOID *     ppvBuffer,
    OUT     PULONG      pulBytesReturned)
{
    *ppvBuffer = NULL;

    // determine size of data we are attempting to retrieve
    //
    ULONG ulSize;

    BOOL fResult = SyncIoctl(
            handle,
            IOCTL_KS_PROPERTY,
            pKsProperty,
            ulPropSize,
            NULL,
            0,
            &ulSize);

    if (fResult)
    {
        *ppvBuffer = LocalAlloc(LPTR, ulSize);

        if (!*ppvBuffer)
        {
            //If we are going to fail, at least say we are returning
            //zero bytes.
            *pulBytesReturned = 0;
            return FALSE;
        }

        fResult = Property(handle,
                           ulPropSize,
                           pKsProperty,
                           ulSize,
                           *ppvBuffer,
                           pulBytesReturned);

        if (fResult && (*pulBytesReturned != ulSize))
        {
            TraceI(0, "GetSizedProperty: Property returned %lu bytes, asked for %lu\n", 
                *pulBytesReturned, ulSize);
            LocalFree(*ppvBuffer);
            *ppvBuffer = NULL;

            fResult = FALSE;
        }
    }
    else
    {
        TraceI(0, "GetSizedProperty: Size query failed\n");
    }

    return fResult;
}

// Property
// 
//
BOOL Property(
    IN      HANDLE      handle,
    IN      ULONG       ulPropSize,
    IN      PKSPROPERTY pKsProperty,
    IN      ULONG       ulBufferSize,
    IN OUT  PVOID       pvBuffer,
    OUT     PULONG      pulBytesReturned)
{
    ULONG   ulReturned = 0;
    PULONG  pulReturned = pulBytesReturned ? pulBytesReturned : &ulReturned;


    BOOL fResult = SyncIoctl(
            handle,
            IOCTL_KS_PROPERTY,
            pKsProperty,
            ulPropSize,
            pvBuffer,
            ulBufferSize,
            pulReturned);

#ifdef DBG
    if (!fResult)
    {
        TraceI(0, "DeviceIoControl: %08X\n", GetLastError());

        TraceI(0, "KS Item: ");
        TraceIGuid(0, &pKsProperty->Set);
        TraceI(0, "\t#%d\n", pKsProperty->Id);
        TraceI(0, "\tFlags: %08X\n", pKsProperty->Flags);
    }
#endif // DBG

    return fResult;
}

// SyncIoctl
//
//
BOOL SyncIoctl(
    IN      HANDLE  handle,
    IN      ULONG   ulIoctl,
    IN      PVOID   pvInBuffer  OPTIONAL,
    IN      ULONG   ulInSize,
    OUT     PVOID   pvOutBuffer OPTIONAL,
    IN      ULONG   ulOutSize,
    OUT     PULONG  pulBytesReturned)
{
    OVERLAPPED overlapped;
    memset(&overlapped,0,sizeof(overlapped));
    overlapped.hEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
    if (!overlapped.hEvent)
    {
        return FALSE;
    }

    BOOL fResult = DeviceIoControl(handle, 
                                   ulIoctl, 
                                   pvInBuffer, 
                                   ulInSize, 
                                   pvOutBuffer, 
                                   ulOutSize, 
                                   pulBytesReturned, 
                                   &overlapped);

    if ((!fResult) && (ERROR_IO_PENDING == GetLastError())) 
    {
        fResult = GetOverlappedResult(handle, &overlapped, pulBytesReturned, TRUE);
    }
    if (!fResult)
    {
        if  (   (ulIoctl == IOCTL_KS_PROPERTY) 
            &&  (ulOutSize == 0)
            &&  (GetLastError() == ERROR_MORE_DATA)
            )
        {
            fResult = TRUE;
        }
        else
        {
            *pulBytesReturned = 0;
        }
    }

    CloseHandle(overlapped.hEvent);

    return fResult;
}

// GetSysAudioDeviceCount
//
BOOL GetSysAudioDeviceCount(
    HANDLE              hSysAudio,
    PULONG              pulDeviceCount)
{
    ULONG               ulBytesReturned;
    KSP_PIN             ksp;
    BOOL                fStatus;

    ksp.Property.Set   = KSPROPSETID_Sysaudio;
    ksp.Property.Id    = KSPROPERTY_SYSAUDIO_DEVICE_COUNT;
    ksp.Property.Flags = KSPROPERTY_TYPE_GET;
    ksp.PinId          = 0;
    ksp.Reserved       = 0;

    fStatus = Property(hSysAudio,
                       sizeof(ksp),
                       (PKSIDENTIFIER)&ksp,
                       sizeof(ULONG),
                       pulDeviceCount,
                       &ulBytesReturned);
    if ((!fStatus) || (ulBytesReturned < sizeof(ULONG)))
    {
        return FALSE;
    }

    return TRUE;
}


// SetDefaultDevice
//
// Set the default SysAudio device to the given index
//
BOOL SetSysAudioDevice(
    HANDLE              hSysAudio,
    ULONG               idxDevice)
{
    SYSAUDIO_INSTANCE_INFO  saInstInfo;
    ZeroMemory(&saInstInfo, sizeof(saInstInfo));

    saInstInfo.Property.Set     = KSPROPSETID_Sysaudio;
    saInstInfo.Property.Id      = KSPROPERTY_SYSAUDIO_INSTANCE_INFO;
    saInstInfo.Property.Flags   = KSPROPERTY_TYPE_SET;
    saInstInfo.Flags            = SYSAUDIO_FLAGS_DONT_COMBINE_PINS;
    saInstInfo.DeviceNumber     = idxDevice;

    return Property(hSysAudio,
                    sizeof(saInstInfo),
                    (PKSIDENTIFIER)&saInstInfo,
                    0,
                    NULL,
                    NULL);
}

// CreateVirtualSource
//
// Create a SysAudio virtual source for controlling volume on this device.
// 
BOOL CreateVirtualSource(
    HANDLE              hSysAudio, 
    PULONG              pulSourceIndex)
{
    SYSAUDIO_CREATE_VIRTUAL_SOURCE  CreateVirtualSource;

    CreateVirtualSource.Property.Set = KSPROPSETID_Sysaudio;
    CreateVirtualSource.Property.Id = KSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE;
    CreateVirtualSource.Property.Flags = KSPROPERTY_TYPE_GET;
    
    CreateVirtualSource.PinCategory = KSNODETYPE_LEGACY_AUDIO_CONNECTOR;
    CreateVirtualSource.PinName = KSNODETYPE_LEGACY_AUDIO_CONNECTOR;

    ULONG BytesReturned;

    BOOL fRet = Property(hSysAudio,
                         sizeof(CreateVirtualSource),
                         (PKSIDENTIFIER)&CreateVirtualSource,
                         sizeof(ULONG),
                         pulSourceIndex,
                         &BytesReturned);
    if (!fRet || BytesReturned != sizeof(ULONG)) 
    {
        return FALSE;
    }

    return TRUE;
}

// AttachVirtualSource
//
// Attach the given virtual source to the pin
//
BOOL AttachVirtualSource(
    HANDLE              hPin,
    ULONG               ulSourceIndex)
{
    SYSAUDIO_ATTACH_VIRTUAL_SOURCE  AttachVirtualSource;

    AttachVirtualSource.Property.Set = KSPROPSETID_Sysaudio_Pin;
    AttachVirtualSource.Property.Id = KSPROPERTY_SYSAUDIO_ATTACH_VIRTUAL_SOURCE;
    AttachVirtualSource.Property.Flags = KSPROPERTY_TYPE_SET;

    AttachVirtualSource.MixerPinId = ulSourceIndex;
    AttachVirtualSource.Reserved = 0;

    return Property(hPin,
                    sizeof(AttachVirtualSource),
                    (PKSIDENTIFIER)&AttachVirtualSource,
                    sizeof(ulSourceIndex),
                    &ulSourceIndex,
                    NULL);
}

// FindGuidNode
//
// Give a handle to SysAudio, find the first node ID within the current device's topology having
// the given GUID.
//
// Returns the node ID or -1 if there is no synthesizer node.
//
int FindGuidNode(
    HANDLE              hSysAudio, 
    ULONG               ulPinId,
    REFGUID             rguid)
{
    KSPROPERTY ksProp;
    LPVOID pvProp;
    ULONG  ulProp;

    // Get node list
    //
    ZeroMemory(&ksProp, sizeof(ksProp));
    ksProp.Set  = KSPROPSETID_Topology;
    ksProp.Id   = KSPROPERTY_TOPOLOGY_NODES;
    ksProp.Flags= KSPROPERTY_TYPE_GET;

    if (!GetSizedProperty(hSysAudio, 
                          sizeof(ksProp),
                          &ksProp,
                          &pvProp,
                          &ulProp))
    {
        TraceI(0, "FindGuidNode: Could not get node topology list\n");
        return -1;
    }                                              

    if (ulProp < sizeof(KSMULTIPLE_ITEM))
    {
        TraceI(0, "FindGuidNode: Node list size smaller than header size!\n");
        LocalFree(pvProp);
        return -1;
    }

    PKSMULTIPLE_ITEM pksmiNodes = (PKSMULTIPLE_ITEM)pvProp;

    // Get connection list
    //
    ZeroMemory(&ksProp, sizeof(ksProp));
    ksProp.Set  = KSPROPSETID_Topology;
    ksProp.Id   = KSPROPERTY_TOPOLOGY_CONNECTIONS;
    ksProp.Flags= KSPROPERTY_TYPE_GET;

    if (!GetSizedProperty(hSysAudio, 
                          sizeof(ksProp),
                          &ksProp,
                          &pvProp,
                          &ulProp))
    {
        TraceI(0, "FindGuidNode: Could not get connection topology list\n");
        LocalFree(pksmiNodes);
        return -1;
    }                                              

    if (ulProp < sizeof(KSMULTIPLE_ITEM))
    {
        TraceI(0, "FindGuidNode: Connection list size smaller than header size!\n");
        LocalFree(pksmiNodes);
        LocalFree(pvProp);
        return -1;
    }

    PKSMULTIPLE_ITEM pksmiConnections = (PKSMULTIPLE_ITEM)pvProp;
    PKSTOPOLOGY_CONNECTION pConnection = PKSTOPOLOGY_CONNECTION(pksmiConnections + 1);
    ULONG idxNodeRet = -1;
    
    // Search connection list for pin ID & guid
    //
    for (ULONG idxConnection = 0; idxConnection < pksmiConnections->Count; ++idxConnection)
    {
        if (pConnection->FromNode == -1 && // filter node
            pConnection->FromNodePin == ulPinId) 
        {
            // REVIEW: walk the topology paths which start from this connection
            
            idxNodeRet = pConnection->ToNode;
        }
        else if (pConnection->ToNode == -1 &&
                 pConnection->ToNodePin == ulPinId)
        {
            idxNodeRet = pConnection->FromNode;
        }
        else 
        {
            idxNodeRet = -1;
        }                    

        if (idxNodeRet != -1)
        {
            ULONG idxNode;
            LPGUID guidNode = LPGUID(pksmiNodes + 1);

            // See if node for connection has the desired guid
            //
            for (idxNode = 0; idxNode < pksmiNodes->Count; ++idxNode)
            {
                if (idxNode == idxNodeRet)
                {
                    break;
                }

                guidNode = LPGUID(PBYTE(guidNode) + ((sizeof(GUID) + 7) & ~7));
            }

            if (idxNode == pksmiNodes->Count ||
                *guidNode != rguid)
            {
                idxNodeRet = -1;
            }
            else
            {
                break;
            }
        }

        pConnection = PKSTOPOLOGY_CONNECTION(PBYTE(pConnection) + ((sizeof(KSTOPOLOGY_CONNECTION) + 7) & ~7));
    }

    LocalFree(pksmiNodes);
    LocalFree(pksmiConnections);
    return idxNodeRet;
}

// GetFilterCaps
//
// Attempts to retrieve the filter caps for this synth filter.
//
BOOL GetFilterCaps(
    HANDLE              hSysAudio,
    ULONG               idxNode,
    PSYNTHCAPS          pcaps)
{
    KSP_NODE ksNodeProp;
    
    ZeroMemory(&ksNodeProp, sizeof(ksNodeProp));
    ksNodeProp.Property.Set     = KSPROPSETID_Synth;
    ksNodeProp.Property.Id      = KSPROPERTY_SYNTH_CAPS;
    ksNodeProp.Property.Flags   = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;
    ksNodeProp.NodeId           = idxNode;

    if (!Property(hSysAudio,
                  sizeof(ksNodeProp),
                  (PKSPROPERTY)&ksNodeProp,
                  sizeof(SYNTHCAPS),
                  pcaps,
                  NULL))
    {
        TraceI(0, "Could not get caps\n");
        return FALSE;
    }

    return TRUE;    
}

// GetNumPinTypes
//
// Retrieve the number of supported pin types on the current SysAudio device.
// 
BOOL GetNumPinTypes(
    HANDLE              hSysAudio,
    PULONG              pulPinTypes)
{
    ULONG   BytesReturned;
    KSP_PIN ksp;
    BOOL    Status;
    
    ksp.Property.Set   = KSPROPSETID_Pin;
    ksp.Property.Id    = KSPROPERTY_PIN_CTYPES;
    ksp.Property.Flags = KSPROPERTY_TYPE_GET;
    ksp.PinId          = 0;
    ksp.Reserved       = 0;

    Status = Property(hSysAudio,
                      sizeof(ksp),
                      (PKSIDENTIFIER)&ksp,
                      sizeof(ULONG),
                      pulPinTypes,
                      &BytesReturned);
    
    if ((!Status) || (BytesReturned < sizeof(ULONG)))
    {
        TraceI(0, "GetNumPinTypes failed\n");
        return FALSE;
    }
    
    return TRUE;
}


// PinSupportsInterface
//
// Given a pin, return TRUE if the given interface is supported. Assumes the
// default device on SysAudio.
//
BOOL PinSupportsInterface(
    HANDLE              hSysAudio,
    ULONG               ulPinId, 
    REFGUID             rguidInterface, 
    ULONG               ulId)
{
    KSP_PIN             ksp;
    PKSMULTIPLE_ITEM    pksmi; 
    ULONG               ulBytesReturned;

    ksp.Property.Set    = KSPROPSETID_Pin;
    ksp.Property.Id     = KSPROPERTY_PIN_INTERFACES;
    ksp.Property.Flags  = KSPROPERTY_TYPE_GET;
    ksp.PinId           = ulPinId;
    ksp.Reserved        = 0;

    if ( (!GetSizedProperty(hSysAudio,
                           sizeof(ksp),
                           (PKSIDENTIFIER)&ksp,
                           (void**)&pksmi,
                           &ulBytesReturned)) ||
        (ulBytesReturned < sizeof(KSMULTIPLE_ITEM)))
    {
        TraceI(0, "PinSupportsInterface: GetSizedProperty failed!\n");
        return FALSE;
    }

    KSPIN_INTERFACE ksInterface;
    
    ksInterface.Set      = rguidInterface;
    ksInterface.Id       = ulId;
    ksInterface.Flags    = 0;

    PCHAR pchProperty = (PCHAR)(pksmi + 1);

    for (ULONG idxInterface = 0; idxInterface < pksmi->Count; ++idxInterface)
    {
        PKSIDENTIFIER pksi = (PKSIDENTIFIER)pchProperty;
        if (IsEqualInterface(pksi, &ksInterface))
        {
            LocalFree(pksmi);
            return TRUE;
        }

        pchProperty += ((sizeof(KSIDENTIFIER) + 7) & ~7);
    }

    LocalFree(pksmi);
    return FALSE;
}

// PinSupportsDataRange
//
BOOL PinSupportsDataRange(
    HANDLE              hSysAudio, 
    ULONG               ulPinId, 
    REFGUID             rguidFormat, 
    REFGUID             rguidSubformat)
{
    KSP_PIN             ksp;
    PKSMULTIPLE_ITEM    pksmi;
    ULONG               ulBytesReturned;

    ksp.Property.Set    = KSPROPSETID_Pin;
    ksp.Property.Id     = KSPROPERTY_PIN_DATARANGES;
    ksp.Property.Flags  = KSPROPERTY_TYPE_GET;
    ksp.PinId           = ulPinId;
    ksp.Reserved        = 0;

    if ((!GetSizedProperty(hSysAudio,
                           sizeof(ksp),
                           (PKSIDENTIFIER)&ksp,
                           (void**)&pksmi,
                           &ulBytesReturned)) ||
        (ulBytesReturned < sizeof(KSMULTIPLE_ITEM)))
    {
        TraceI(0, "PinSupportsInterface: GetSizedProperty failed!\n");
        return FALSE;
    }

    PCHAR pchPropData = (PCHAR)(pksmi + 1);

    for (ULONG idxDataRange = 0; idxDataRange < pksmi->Count; ++idxDataRange)
    {
        PKSDATARANGE pksdr = (PKSDATARANGE)(pchPropData);

        if (IsEqualGUID(pksdr->MajorFormat, rguidFormat) &&
            IsEqualGUID(pksdr->SubFormat,   rguidSubformat))
        {
            LocalFree(pksmi);
            return TRUE;
        }

        pchPropData += pksdr->Alignment;
    }

    LocalFree(pksmi);
    return FALSE;
}

// PinGetDataFlow
// 
BOOL PinGetDataFlow(
    HANDLE              hSysAudio, 
    ULONG               ulPinId, 
    PKSPIN_DATAFLOW     pkspdf)
{
    KSP_PIN             ksp;
    BOOL                Status;
    ULONG               ulBytesReturned;

    ksp.Property.Set   = KSPROPSETID_Pin;
    ksp.Property.Id    = KSPROPERTY_PIN_DATAFLOW;
    ksp.Property.Flags = KSPROPERTY_TYPE_GET;
    ksp.PinId          = ulPinId;
    ksp.Reserved       = 0;

    Status = Property(hSysAudio,
                      sizeof(ksp),
                      (PKSIDENTIFIER)&ksp,
                      sizeof(KSPIN_DATAFLOW),
                      pkspdf,
                      &ulBytesReturned);

    if ((!Status) || (ulBytesReturned < sizeof(KSPIN_DATAFLOW)))
    {
        TraceI(0, "PinGetDataFlow: Property failed!\n");
        return FALSE;
    }

    return TRUE;
}

// GetDeviceFriendlyName
//
// Assumes the default device is already set.
//
BOOL GetDeviceFriendlyName(
    HANDLE              hSysAudio, 
    ULONG               ulDeviceIndex,
    PWCHAR              pwch, 
    ULONG               cbwch)
{
    KSPROPERTYDEVICEINDEX   kspdi;

    if (cbwch < sizeof(WCHAR))
    {
        return FALSE;
    }

    kspdi.Property.Set   = KSPROPSETID_Sysaudio;
    kspdi.Property.Id    = KSPROPERTY_SYSAUDIO_DEVICE_FRIENDLY_NAME;
    kspdi.Property.Flags = KSPROPERTY_TYPE_GET;
    kspdi.DeviceIndex    = ulDeviceIndex;

    if (!Property(hSysAudio,
                  sizeof(kspdi),
                  (PKSIDENTIFIER)&kspdi,
                  cbwch,
                  pwch,
                  NULL))
    {
        return FALSE;
    }

    pwch[(cbwch / sizeof(WCHAR)) - 1] = ((WCHAR)0);

    return TRUE;
}

// GetDeviceFriendlyName
//
// Assumes the default device is already set.
//
BOOL GetDeviceInterfaceName(
    HANDLE              hSysAudio, 
    ULONG               ulDeviceIndex,
    PWCHAR              pwch, 
    ULONG               cbwch)
{
    KSPROPERTYDEVICEINDEX   kspdi;

    if (cbwch < sizeof(WCHAR))
    {
        return FALSE;
    }

    kspdi.Property.Set   = KSPROPSETID_Sysaudio;
    kspdi.Property.Id    = KSPROPERTY_SYSAUDIO_DEVICE_INTERFACE_NAME;
    kspdi.Property.Flags = KSPROPERTY_TYPE_GET;
    kspdi.DeviceIndex    = ulDeviceIndex;

    if (!Property(hSysAudio,
                  sizeof(kspdi),
                  (PKSIDENTIFIER)&kspdi,
                  cbwch,
                  pwch,
                  NULL))
    {
        return FALSE;
    }

    pwch[(cbwch / sizeof(WCHAR)) - 1] = ((WCHAR)0);

    return TRUE;
}

// GetPreferredAudioPlaybackDevice
//
//
BOOL InstanceIdOfPreferredAudioDevice(char **ppInstanceId)
{
    // Determine the device ID of the preferred audio device
    //
    int iDeviceId = GetPreferredAudioPlaybackDeviceId();
    if (iDeviceId == -1)
    {
        TraceI(0, "Could not determine preferred device ID\n");
        return FALSE;
    }
    
    return WaveOutIdToInstanceId(iDeviceId, ppInstanceId);
}

#ifdef WINNT

// GetPreferredAudioPlaybackDeviceId
//
// Returns the WinMM device ID of the preferred audio playback device, or -1
// if the device could not be found.
//
static int GetPreferredAudioPlaybackDeviceId()
{
    MMRESULT    mmr;
    UINT        uPreferredId;
    DWORD       dwFlags;

    // Use the new improved NT WinMM service for determining the preferred 
    // audio device 
    //
    mmr = waveOutMessage((HWAVEOUT)-1,        // Mapper
                         DRVM_MAPPER_PREFERRED_GET,
                         (DWORD_PTR)&uPreferredId,
                         (DWORD_PTR)&dwFlags);
    if (mmr != MMSYSERR_NOERROR)
    {
        TraceI(0, "GetPreferredAudioPlaybackDeviceId: Mapper returned %d\n", mmr);
        return -1;
    }

    // May still be -1 if there is no preferred device
    //
    return (int)uPreferredId;
}

#else /* Win9x */

// GetPreferredAudioPlaybackDeviceId
//
// Returns the WinMM device ID of the preferred audio playback device, or -1
// if the device could not be found.
//
// Works on both Win9x.
//
#define REGSTR_PREFERRED_AUDIO  "Software\\Microsoft\\Multimedia\\Sound Mapper"
#define PLAYBACK                "Playback"

static int GetPreferredAudioDeviceReg();
static int GetFirstMappableDevice();

// GetPreferredAudioPlaybackDeviceId
//
// Determine the preferred audio playback device as a wave out device ID.
// If the registry has been set, use that setting;
// otherwise, use the first mappable device
//
static int GetPreferredAudioPlaybackDeviceId()
{
    int id = GetPreferredAudioDeviceReg();

    if (id != -1) 
    {
        return id;
    }

    // If the registry method failed, it could be because the control panel
    // has not been run yet and there is nothing written in the registry.
    // In this case the mapper picks the first mappable device.
    //
    // This will return -1 if there are no mappable devices.
    //
    return GetFirstMappableDevice();
}

// GetPreferredAudioDeviceReg
//
// Find the preferred wave out device in the registry if it has been written
// there.
//
static int GetPreferredAudioDeviceReg()
{
    HKEY hk;

    // Save how many wave devices are loaded. If none, no need to continue.
    //
    int nWaveOutDevs = waveOutGetNumDevs();
    if (nWaveOutDevs == 0) 
    {
        return -1;
    }

    // Get the preferred audio playback device from the registry. This is the 
    // name of the audio device.
    //
    if (RegOpenKeyEx(HKEY_CURRENT_USER,
                     REGSTR_PREFERRED_AUDIO,
                     0,                         // Reserved
                     KEY_READ,
                     &hk) != ERROR_SUCCESS)
    {
        return -1;
    }        

    CHAR szPName[MAXPNAMELEN];
    DWORD cb;
    LONG lResult;

    cb = sizeof(szPName);
    lResult = RegQueryValueEx(hk,
                              PLAYBACK,
                              NULL,                   // Reserved
                              NULL,                   // Type
                              (LPBYTE)szPName,
                              &cb) != ERROR_SUCCESS;
    RegCloseKey(hk);

    if (lResult != ERROR_SUCCESS)
    {
        return -1;
    }

    // Loop through all the loaded wave devices and look for one with the same name
    // as the preferred device name.
    //
    int iWaveOutDev;
    WAVEOUTCAPS woc;

    for (iWaveOutDev = 0; iWaveOutDev < nWaveOutDevs; iWaveOutDev++)
    {
        MMRESULT mmr = waveOutGetDevCaps(iWaveOutDev, &woc, sizeof(woc));
        if (mmr != MMSYSERR_NOERROR) 
        {
            continue;
        }            

        if (!strcmp(szPName, woc.szPname))
        {
            break;
        }
    }

    if (iWaveOutDev >= nWaveOutDevs)
    {
        return -1;
    }

    return iWaveOutDev;
}

// GetFirstMappableDevice
//
// Find the first mappable wave out device, which is what wave mapper is supposed
// to do in the absence of registry settings.
//
static int GetFirstMappableDevice()
{
    int nWaveOutDevs = waveOutGetNumDevs();

    if (nWaveOutDevs == 0) 
    {
        return -1;
    }

    for (int iDeviceId = 0; iDeviceId < nWaveOutDevs; iDeviceId++)
    {
        MMRESULT mmr = waveOutMessage((HWAVEOUT)iDeviceId,
                                      DRV_QUERYMAPPABLE,
                                      0, 0);
        if (mmr == MMSYSERR_NOERROR)
        {
            // This device ID is mappable
            //
            return iDeviceId;
        }                                          
    }
    
    return -1;
}

#endif /* Win9x */

#ifdef WINNT
static BOOL GetDINameFromWaveOutId(int iDeviceId, char **ppDIName);

static BOOL WaveOutIdToInstanceId(int iDeviceId, char **ppInstanceId)
{
    char *pstrDIName;

    if (!GetDINameFromWaveOutId(iDeviceId, &pstrDIName))
    {
        return FALSE;
    }

    BOOL bRet = DINameToInstanceId(pstrDIName, ppInstanceId);

    delete[] pstrDIName;
    return bRet;
}

// GetDINameFromWaveOutId
//
// Given a WaveOut device ID, determine the matching device interface
// name.
//
static BOOL GetDINameFromWaveOutId(int iDeviceId, char **ppDIName)
{
    ULONG cb;
    
    // Ask how many bytes (NOT WCHAR's the name is)
    //
    MMRESULT mmr = waveOutMessage((HWAVEOUT)(UINT64)iDeviceId,
                                  DRV_QUERYDEVICEINTERFACESIZE,
                                  (DWORD_PTR)(PULONG)&cb,
                                  0);
    if (mmr != MMSYSERR_NOERROR)
    {
        return FALSE;
    }

    // Allocate and ask for the name
    //
    ULONG  cwch = (cb + sizeof(WCHAR) - 1) / sizeof(WCHAR);
    PWCHAR pwstrDeviceInterfaceName = new WCHAR[cwch];
    if (pwstrDeviceInterfaceName == NULL)
    {
        return FALSE;
    }

    mmr = waveOutMessage((HWAVEOUT)(UINT64)iDeviceId,
                         DRV_QUERYDEVICEINTERFACE,
                         (DWORD_PTR)pwstrDeviceInterfaceName,
                         cb);
    if (mmr != MMSYSERR_NOERROR)
    {
        delete[] pwstrDeviceInterfaceName;
        return FALSE;
    }

    // We want to name as a multibyte string
    //    
    LPSTR pstrDeviceInterfaceName = new CHAR[cwch];
    if (pstrDeviceInterfaceName == NULL)
    {
        delete[] pwstrDeviceInterfaceName;
        return FALSE;
    }

    wcstombs(pstrDeviceInterfaceName, pwstrDeviceInterfaceName, cwch);

    // Clean up and return it
    //
    *ppDIName = pstrDeviceInterfaceName;
    delete[] pwstrDeviceInterfaceName;

    return TRUE;
}

#else /* Win9x */
static BOOL WaveOutIdToInstanceId(int iDeviceId, char **ppInstanceId)
{
    BOOL bRet = FALSE;

    MMRESULT mmr;
    char szDrvEntry[256];
    char szKey[512];
    HKEY hk;
    DWORD cb;

    *ppInstanceId = NULL;

    mmr = waveOutMessage((HWAVEOUT)iDeviceId,
                         DRV_QUERYDRVENTRY,
                         (DWORD)(LPSTR)szDrvEntry,
                         sizeof(szDrvEntry));
    if (mmr) 
    {
        TraceI(1, "DRV_QUERYDRVENTRY: %d\n", mmr);
        return FALSE;
    }

    wsprintf(szKey, "%s\\%s",
             REGSTR_PATH_MEDIARESOURCES TEXT("\\Wave"),
             szDrvEntry);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     szKey,
                     0,
                     KEY_READ,
                     &hk) != ERROR_SUCCESS)
    {
        TraceI(1, "WaveOutIdToInstanceId: RegOpenKeyEx failed\n");
        TraceI(2, "[%s]\n", szKey);
        return FALSE;
    }

    cb = sizeof(szDrvEntry);
    if (RegQueryValueEx(hk,
                        "DeviceID",
                        NULL,
                        NULL,
                        (LPBYTE)szDrvEntry,
                        &cb) == ERROR_SUCCESS)
    {
        *ppInstanceId = new char[strlen(szDrvEntry) + 1];
        if (*ppInstanceId) 
        {
            strcpy(*ppInstanceId, szDrvEntry);
            bRet = TRUE;
        }
    }
    else
    {
        TraceI(1, "WaveOutIdToInstanceId: No DeviceID key, not WDM device\n");
    }

    RegCloseKey(hk);

    return bRet;
}
#endif /* Win9x */


// DINameToInstanceId
//
// Determine the device interface which implements this 
// ID
//
// Walk device list looking for the interface name.
//
//

// The first 4 characters of the DI name are different between setupapi and
// sysaudio, even though the paths match (\\?\ versus \??\). This is how
// much to ignore when matching the paths.
//
#define DI_PATH_PREFIX_LEN 4
static char gszDosDevices[] = "\\DosDevices\\";

BOOL DINameToInstanceId(char *pstrDIName, char **ppInstanceId)
{
    BOOL     bRet = FALSE;

    SetupAPI suwrap;
    long     lErr;
	HDEVINFO hDevInfo;

    if (!suwrap.IsValid())
    {
        return FALSE;
    }

#ifdef WINNT
    // We can get the empty string here, which obviously
    // matches nothing.
    //
    if (strlen(pstrDIName) < DI_PATH_PREFIX_LEN)
    {
        return FALSE;
    }
    pstrDIName += DI_PATH_PREFIX_LEN;
#else
    if (!_strnicmp(pstrDIName, "\\DosDevices\\", strlen(gszDosDevices)))
    {
        pstrDIName += strlen(gszDosDevices);
    }
    else if (!_strnicmp(pstrDIName, "\\\\.\\", DI_PATH_PREFIX_LEN))
    {
        // Already prepended, don't want to see that.
        pstrDIName += DI_PATH_PREFIX_LEN;
    }
#endif       

    *ppInstanceId = NULL;

    if (strlen(pstrDIName) < DI_PATH_PREFIX_LEN)
    {
        return FALSE;
    }
	
	hDevInfo = suwrap.SetupDiGetClassDevs(const_cast<GUID*>(&KSCATEGORY_AUDIO),
										  NULL,
										  NULL,
										  DIGCF_DEVICEINTERFACE);
    if (hDevInfo == NULL || hDevInfo == INVALID_HANDLE_VALUE)
    {
        TraceI(0, "SetupDiGetClassDevs %d\n", GetLastError());
        return FALSE;
    }

	BYTE rgbStorage[sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) + _MAX_PATH];

	SP_DEVICE_INTERFACE_DETAIL_DATA * pDevInterfaceDetails = 
	    (SP_DEVICE_INTERFACE_DETAIL_DATA *)rgbStorage;
	pDevInterfaceDetails->cbSize = sizeof(*pDevInterfaceDetails);

    SP_DEVINFO_DATA DevInfo;
    DevInfo.cbSize = sizeof(DevInfo);

    DWORD   dwRequiredInstanceIdSize;

    for (DWORD MemberIndex = 0; ; MemberIndex++)
    {
	    SP_DEVICE_INTERFACE_DATA DevInterfaceData;
	    DevInterfaceData.cbSize = sizeof(DevInterfaceData);

        if (!suwrap.SetupDiEnumDeviceInterfaces(hDevInfo,
                                                NULL,
                                                const_cast<GUID*>(&KSCATEGORY_AUDIO),
                                                MemberIndex,
                                                &DevInterfaceData))
        {
            TraceI(0, "SetupDiEnumDeviceInterfaces %d\n", GetLastError());
            break;
        }

        if (!suwrap.SetupDiGetDeviceInterfaceDetail(hDevInfo,
                                                    &DevInterfaceData,
                                                    pDevInterfaceDetails,
        								  	  	    sizeof(rgbStorage), 
 										            NULL, 
 										            &DevInfo))
        {
            TraceI(0, "SetupDiGetDeviceInterfaceDetail %d\n", GetLastError());
            break;
        }
    
        // Look for a case insensitive match, ignoring the first 
        // DI_PATH_PREFIX_LEN characters.
        //
        if (strlen(pDevInterfaceDetails->DevicePath) < DI_PATH_PREFIX_LEN)
        {
            continue;
        }
                    
        if (_stricmp(pDevInterfaceDetails->DevicePath + DI_PATH_PREFIX_LEN, 
                     pstrDIName))
        {
            continue;
        }

        // We have a match. Get the device instance ID
        //
        lErr = 0;
        char c;
        suwrap.SetupDiGetDeviceInstanceId(hDevInfo,
                                          &DevInfo,
                                          &c,
                                          sizeof(c),
                                          &dwRequiredInstanceIdSize);

        lErr = GetLastError();
        if (lErr != ERROR_INSUFFICIENT_BUFFER)
        {   
            TraceI(0, "SetupDiGetDeviceInstanceId %d\n", lErr);
            break;
        }

        *ppInstanceId = new char[dwRequiredInstanceIdSize];
        if (!*ppInstanceId)
        {
            TraceI(0, "Out of memory determining preferred audio device\n");
            break;
        }

        if (!suwrap.SetupDiGetDeviceInstanceId(hDevInfo,
                                               &DevInfo,
                                               *ppInstanceId,
                                               dwRequiredInstanceIdSize,
                                               &dwRequiredInstanceIdSize))
        {
            TraceI(0, "SetupDiGetDeviceInstanceId %d\n", GetLastError());
            break;
        }

        bRet = TRUE;
        break;
    }                                              

    suwrap.SetupDiDestroyDeviceInfoList(hDevInfo);

    if (!bRet && *ppInstanceId)
    {
        delete[] *ppInstanceId;
        *ppInstanceId = NULL;
    }
    
    return bRet;        
}

#ifdef DBG
void _TraceIGuid(int iLevel, GUID *pGUID)
{
    char sz[256];
    char *psz = sz;
    
    psz += wsprintf(psz, "%08X-%04X-%04X-", pGUID->Data1, pGUID->Data2, pGUID->Data3);
    for (int i = 0; i < 8; i++) 
    {
        psz += wsprintf(psz, "%02X", pGUID->Data4[i]);
        if (i < 7)
        {
            *psz++ = '-';
        }
    }    

    TraceI(iLevel, sz);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic16\cmphlp.inc ===
;***
;cmphlp.inc - include to aid in generating compiler helpers
;
;	Copyright (c) 1987-1998 Microsoft Corporation
;
;Purpose:
;	This file is a compiler helper include to aid in generating
;	backwards compatible compiler helpers.
;
;*******************************************************************************


callnahlpr MACRO nm		;;call non-assigning helper
if	sizeC
	push	cs
	call	near ptr __aF&nm
else
	call	near ptr __aN&nm
endif
ENDM


DFLT	MACRO	tag,prfx,nm
externP _a&prfx&tag&nm
cProc	_&tag&nm,<PUBLIC>,<>
cBegin	nogen
	jmp	_a&prfx&tag&nm
cEnd	nogen
ENDM

DFLT2	MACRO	tag,prfx,nm
externP _a&prfx&tag&nm
cProc	_&tag&u&nm,<PUBLIC>,<>
cBegin	nogen
cEnd	nogen
cProc	_&tag&nm,<PUBLIC>,<>
cBegin	nogen
	jmp	_a&prfx&tag&nm
cEnd	nogen
ENDM

ASGN	MACRO	nm		;;macro to fix up entry sequence of non
				;;assigning code helpers
if	sizeC
cProc	_aF&nm,<PUBLIC>,<>
cBegin

else
cProc	_aN&nm,<PUBLIC>,<>
cBegin
endif
ENDM



aASGN	MACRO	nm		;;macro to fix up entry sequence of assigning
				;;code helpers
if	memL	eq 1
externP _aF&nm
cProc	_aFFa&nm,<PUBLIC>,<>
cBegin
endif
if	memM	eq 1
externP _aF&nm
cProc	_aFNa&nm,<PUBLIC>,<>
cBegin
endif
if	memC	eq 1
externP _aN&nm
cProc	_aNFa&nm,<PUBLIC>,<>
cBegin
endif
if	memS	eq 1
externP _aN&nm
cProc	_aNNa&nm,<PUBLIC>,<>
cBegin
endif
ENDM


OLDSLEAZ MACRO

ifdef	lhdiff
OLDASGN hdiff
endif

ifdef	llshl
OLDASGN lshl
endif

ifdef	llshr
OLDASGN lshr
endif

ifdef	lulshr
OLDASGN ulshr
endif

ifdef	lldiv
OLDASGN ldiv
endif

ifdef	llmul
OLDASGN2 lmul
endif

ifdef	llrem
OLDASGN lrem
endif

ifdef	luldiv
OLDASGN uldiv
endif

ifdef	lulrem
OLDASGN ulrem
endif
	ENDM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic\tlist.h ===
/***************************************************************************
 *
 *  Copyright (c) 1995-1999 Microsoft Corporation
 *
 *  File:       tlist.h
 *  Content:    Linked-list template classes.  There's some seriously
 *              magical C++ in here, so be forewarned all ye C
 *              programmers.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  4/12/97     dereks  Created.
 *
 ***************************************************************************/

#ifndef __TLIST_H__
#define __TLIST_H__

#ifdef __cplusplus

template<class type> class CNode
{
public:
    CNode<type> *       pPrev;          // Previous node in the list
    CNode<type> *       pNext;          // Next node in the list
    type                data;           // Node data

public:
    CNode(CNode<type> *, CNode<type> *, const type&);
};

template<class type> CNode<type>::CNode(CNode<type> *pInitPrev, CNode<type> *pInitNext, const type& rInitData)
{
    pPrev = pInitPrev;
    pNext = pInitNext;
    data = rInitData;
}

template<class type> class CList
{
private:
    CNode<type> *       m_pHead;        // Pointer to the head of the list
    CNode<type> *       m_pTail;        // Pointer to the tail of the list
    UINT                m_uCount;       // Count of nodes in the list

public:
    CList(void);
    virtual ~CList(void);

public:
    virtual CNode<type> *AddNodeToList(const type&);
    virtual void RemoveNodeFromList(CNode<type> *);
    virtual void RemoveDataFromList(const type&);
    virtual CNode<type> *IsDataInList(const type&);
    virtual CNode<type> *GetListHead(void);
    virtual UINT GetNodeCount(void);
};

template<class type> CList<type>::CList(void)
{
    m_pHead = NULL;
    m_pTail = NULL;
    m_uCount = 0;
}

template<class type> CList<type>::~CList(void)
{
    CNode<type> *       pNext;

    while(m_pHead)
    {
        pNext = m_pHead->pNext;
        delete m_pHead;
        m_pHead = pNext;
    }
}

template<class type> CNode<type> *CList<type>::AddNodeToList(const type& data)
{
    CNode<type> *       pNode;

    pNode = new CNode<type>(m_pTail, NULL, data);

    if(pNode)
    {
        if(pNode->pPrev)
        {
            pNode->pPrev->pNext = pNode;
        }

        if(!m_pHead)
        {
            m_pHead = pNode;
        }

        m_pTail = pNode;
        m_uCount++;
    }

    return pNode;
}

template<class type> void CList<type>::RemoveNodeFromList(CNode<type> *pNode)
{
//    ASSERT(pNode);

#ifdef DEBUG

    CNode<type> *pNext;

    for(pNext = m_pHead; pNext && pNext != pNode; pNext = pNext->pNext);
//    ASSERT(pNext == pNode);

#endif // DEBUG

    if(pNode->pPrev)
    {
        pNode->pPrev->pNext = pNode->pNext;
    }

    if(pNode->pNext)
    {
        pNode->pNext->pPrev = pNode->pPrev;
    }

    if(pNode == m_pHead)
    {
        m_pHead = pNode->pNext;
    }

    if(pNode == m_pTail)
    {
        m_pTail = pNode->pPrev;
    }

    delete pNode;
    m_uCount--;
}

template<class type> void CList<type>::RemoveDataFromList(const type& data)
{
    CNode<type> *       pNode;

    if(pNode = IsDataInList(data))
    {
        RemoveNodeFromList(pNode);
    }
}

template<class type> CNode<type> *CList<type>::IsDataInList(const type& data)
{
    CNode<type> *       pNode;

    for(pNode = m_pHead; pNode && !memcmp(&data, &pNode->data, sizeof(data)); pNode = pNode->pNext);

    return pNode;
}

template<class type> CNode<type> *CList<type>::GetListHead(void) 
{ 
    return m_pHead; 
}

template<class type> UINT CList<type>::GetNodeCount(void) 
{ 
    return m_uCount; 
}

#endif // __cplusplus

#endif // __TLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic16\alloc.c ===
/* Copyright (c) 1998-1999 Microsoft Corporation */
/* @doc DMusic16
 *
 * @module Alloc.c - Memory allocation routines |
 *
 * This module provides memory allocation routines for DMusic16.DLL. It allows the MIDI input and
 * output modules to allocated and free <c EVENT> structures.
 *
 * The allocated recognizes two types of events by size. If an event is create with 4 or less bytes
 * of data, then it is allocated as a channel message. Channel message events are allocated one
 * page at a time and kept in a free list.
 *
 * If the event size is greater than 4 bytes, then the event is a system exclusive message (or long
 * data in the legacy API nomenclature). These events are allocated individually, one per page.
 *
 * All allocated memory is preceded with a <c SEGHDR>, which is used to identify the size and type
 * of the segment and to keep it in a list. Since all events will be accessed at event time (in
 * either a MIDI input callback or a timeSetEvent callback), all memory is automatically page
 * locked.
 *
 * @globalv WORD | gsSegList |Selector of first segment in allocated list
 * @globalv LPEVENT | glpFreeEventList | List of free 4-byte events 
 * @globalv LPEVENT | glpFreeBigEventList | List of free 4-byte events 
 */
#include <windows.h>
#include <mmsystem.h>
#include <memory.h>

#include "dmusic16.h"
#include "debug.h"

STATIC WORD gsSegList;
STATIC LPEVENT glpFreeEventList;        
STATIC LPEVENT glpFreeBigEventList;     

/* Given a far pointer, get its selector.
 */
#define SEL_OF(lp) (WORD)((((DWORD)lp) >> 16) & 0xffff)

/* Given a far event pointer, get the far pointer to its segment headear.
 */
#define SEGHDR_OF(lp)   ((LPSEGHDR)(((DWORD)lp) & 0xffff0000l))

STATIC BOOL RefillEventList(VOID);
STATIC LPSEGHDR AllocSeg(WORD cbSeg);
STATIC VOID FreeBigEvents(VOID);
STATIC VOID FreeSeg(LPSEGHDR lpSeg);

/* @func Called at DLL LibInit
 *
 * @comm
 * Initializes all free lists to empty.
 *
 */
VOID PASCAL
AllocOnLoad(VOID)
{
    gsSegList = 0;
    glpFreeEventList = NULL;
    glpFreeBigEventList = NULL;
}

/* @func Called at DLL LibExit
 *
 * @comm
 * Unlock and free all of the memory allocated.
 *
 * AllocOnUnload jettisons all memory the allocator has ever allocated. 
 * It assumes that all pointers to events will no longer ever be touched (i.e. all callbacks must
 * have already been disabled by this point).
 */
VOID PASCAL
AllocOnExit(VOID)
{
    WORD sSel;
    WORD sSelNext;
    LPSEGHDR lpSeg;

    sSel = gsSegList;

    while (sSel)
    {
        lpSeg = (LPSEGHDR)(((DWORD)sSel) << 16);
        sSelNext = lpSeg->selNext;
        
        FreeSeg(lpSeg);

        sSel = sSelNext;
    }
    
    /* This just invalidated both free lists as well as the segment list
     */
    gsSegList = 0;
    glpFreeEventList = NULL;
    glpFreeBigEventList = NULL;
}

/* @func Allocate an event of a given size
 *
 * @rdesc Returns a far pointer to the event or NULL if memory could not be allocated.
 *
 * @comm
 *
 * This function is not callable at interrupt time.
 *
 * This function is called to allocate a single event. The event will be allocated from
 * page-locked memory and filled with the given event data.
 *
 * Events are classified as normal events, which contain channel messages, and big events,
 * which contain SysEx data. The two are distinguished by their size: any event containing
 * a DWORD of data or less is a normal event.
 *
 * Since channel messages comprise most of the MIDI stream, allocation of these events is optimized.
 * A segment is allocated containing approximately one page worth (4k) of 4-byte events. These
 * events are doled out of a free pool, which only occasionally needs to be refilled from system
 * memory.
 *
 * Big events are allocated on an as-needed basis. When they have been free'd by a call to FreeEvent,
 * they are placed on a special free list. This list is used to find memory for future big events,
 * and is occasionally free'd back to Windows on a call to AllocEvent in order to minimize the
 * amount of page-locked memory in use.
 */
LPEVENT PASCAL
AllocEvent(
    DWORD msTime,           /* @parm The absolute time based on timeGetTime() of the event */
    QUADWORD rtTime,        /* @parm The absolute time based on the IRferenceClock in 100ns units */
    WORD cbEvent)           /* @parm The number of bytes of event data in pbData */
{
    LPEVENT lpEvent;
    LPEVENT lpEventPrev;
    LPEVENT lpEventCurr;
    LPSEGHDR lpSeg;
    
    /* Check for big event first (Sysex)
     */
    if (cbEvent > sizeof(DWORD))
    {
        /* First see if we have an event that will work already
         */
        lpEventPrev = NULL;
        lpEventCurr = glpFreeBigEventList;
        
        while (lpEventCurr)
        {
            if (SEGHDR_OF(lpEventCurr)->cbSeg >= sizeof(EVENT) + cbEvent)
            {
                break;
            }
            lpEventPrev = lpEventCurr;
            lpEventCurr = lpEventCurr->lpNext;
        }

        if (lpEventCurr)
        {
            /* Remove this event from the list and use it
             */
            if (lpEventPrev)
            {
                lpEventPrev->lpNext = lpEventCurr->lpNext;
            }
            else
            {
                glpFreeBigEventList = lpEventCurr->lpNext;
            }

            lpEventCurr->lpNext = NULL;
        }
        else
        {
            /* Nope, need to allocate one
             */
            lpSeg = AllocSeg(sizeof(EVENT) + cbEvent);
            if (NULL == lpSeg)
            {
                return NULL;
            }

            lpEventCurr = (LPEVENT)(lpSeg + 1);
        }

        lpEventCurr->msTime = msTime;
        lpEventCurr->rtTime = rtTime;
        lpEventCurr->wFlags = 0;
        lpEventCurr->cbEvent = cbEvent;

        return lpEventCurr;
    }

    /* BUGBUG How often???
     */
    FreeBigEvents();

    /* Normal event. Pull it off the free list (refill if needed) and fill it in.
     */
    if (NULL == glpFreeEventList)
    {
        if (!RefillEventList())
        {
            return NULL;
        }
    }

    lpEvent = glpFreeEventList;
    glpFreeEventList = lpEvent->lpNext;

    lpEvent->msTime = msTime;
    lpEvent->rtTime = rtTime;
    lpEvent->wFlags = 0;
    lpEvent->cbEvent = cbEvent;

    return lpEvent;
}

/* @func Free an event back to its appropriate free list
 *
 * @comm
 *
 * FreeEvent makes no system calls; it simply places the given event back on the correct
 * free list. If the event needs to be actually free'd, that will be done at a later time
 * in user mode.
 */
VOID PASCAL
FreeEvent(
    LPEVENT lpEvent)            /* @parm The event to free */
{
    LPSEGHDR lpSeg;

    lpSeg = SEGHDR_OF(lpEvent);
    if (lpSeg->wFlags & SEG_F_4BYTE_EVENTS)
    {
        lpEvent->lpNext = glpFreeEventList;
        glpFreeEventList = lpEvent;
    }
    else
    {
        lpEvent->lpNext = glpFreeBigEventList;
        glpFreeBigEventList = lpEvent;
    }
}

/* @func Refill the free list of normal events
 *
 * @rdesc Returns TRUE if the list was refilled or FALSE if there was no memory.
 *
 * @comm
 *
 * This routine is not callable from interrupt time.
 *
 * Allocate one page-sized segment of normal events and add them to the free list.
 *
 */
STATIC BOOL
RefillEventList(VOID)
{
    LPSEGHDR lpSeg;
    LPEVENT lpEvent;
    UINT cbEvent;
    UINT idx;

    cbEvent = sizeof(EVENT) + sizeof(DWORD);
    lpSeg = AllocSeg(C_PER_SEG * cbEvent);
    if (NULL == lpSeg)
    {
        return FALSE;
    }

    lpSeg->wFlags = SEG_F_4BYTE_EVENTS;

    /* Put the events into the free pool
     */
    lpEvent = (LPEVENT)(lpSeg + 1);

    for (idx = C_PER_SEG - 1; idx; --idx)
    {
        lpEvent->lpNext = (LPEVENT)(((LPBYTE)lpEvent) + cbEvent);
        lpEvent = lpEvent->lpNext;
    }

    lpEvent->lpNext = glpFreeEventList;
    glpFreeEventList = (LPEVENT)(lpSeg + 1);
                                 
    return TRUE;
}

/* @func Free all big events
 *
 * @comm
 *
 * This function is not callable at interrupt time.
 *
 * This function frees all big events on the free big event list. Free big events are those
 * with event data sizes of more than one DWORD; they are allocated one event per segment
 * as needed rather than being pooled like channel messages.
 *
 * This function is called every now and then as a side effect of AllocEvent in order to
 * free up the page-locked memory associated with completed big events.
 *
 */ 
STATIC VOID
FreeBigEvents(VOID)
{
    LPEVENT lpEvent;
    LPEVENT lpEventNext;
    LPSEGHDR lpSeg;

    lpEvent = glpFreeBigEventList;
    while (lpEvent)
    {
        lpEventNext = lpEvent->lpNext;

        lpSeg = SEGHDR_OF(lpEvent);
        FreeSeg(lpSeg);

        lpEvent = lpEventNext;
    }

    glpFreeBigEventList = NULL;
}

/* @func Allocate a segment and put it into the list of allocated segments.
 *
 * @rdesc A far pointer to the segment header or NULL if the memory could not be allocated.
 *
 * @comm
 *
 * This function is not callable at interrupt time.
 *
 * This is the lowest-level allocation routine which actually calls Windows to allocate the memory.
 * The caller is responsible for carving the memory into one or more events.
 *
 * The data area of the segment will be filled with zeroes.
 *
 * Since events are accessed at interrupt time (timeSetEvent callback), the memory is allocated and
 * page locked.
 *
 * This routine also inserts the segment into the global list of allocated segments for cleanup.
 */
STATIC LPSEGHDR
AllocSeg(
    WORD cbSeg)                 /* @parm The size of data needed in the segment, excluding the segment header */
{
    HANDLE hSeg;
    WORD sSegHdr;
    LPSEGHDR lpSeg;

    /* Allocate and page-lock a segment
     * NOTE: GPTR contains zero-init
     */
    cbSeg += sizeof(SEGHDR);
    hSeg = GlobalAlloc(GPTR | GMEM_SHARE, cbSeg);
    if (0 == hSeg)
    {
        return NULL;
    }

    lpSeg = (LPSEGHDR)GlobalLock(hSeg);
    if (NULL == lpSeg)
    {
        GlobalFree(sSegHdr);
        return NULL;
    }

    sSegHdr = SEL_OF(lpSeg);
    if (!GlobalSmartPageLock(sSegHdr))
    {
        GlobalUnlock(sSegHdr);
        GlobalFree(sSegHdr);
        return NULL;
    }

    lpSeg->hSeg = hSeg;
    lpSeg->cbSeg = cbSeg;

    lpSeg->selNext  = gsSegList;
    gsSegList = sSegHdr;
    
    return lpSeg;
}

/* @func Free a segment back to Windows
 *
 * @comm
 *
 * This function is not callable at interrupt time.
 *
 * Just unlock the segment and free it. The calling cleanup code is assumed to have removed
 * the segment from the global list of allocated segments.
 *
 */
STATIC VOID FreeSeg(
    LPSEGHDR lpSeg)         /* @parm The segment to free */
{
    WORD sSel = SEL_OF(lpSeg);
    HANDLE hSeg;
    
    hSeg = lpSeg->hSeg;
    
    GlobalSmartPageUnlock(sSel);
    GlobalUnlock(hSeg);
    GlobalFree(hSeg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic16\debug.h ===
//==========================================================================;
//
//      Copyright (c) 1991-1998 Microsoft Corporation
//
//      You have a royalty-free right to use, modify, reproduce and 
//      distribute the Sample Files (and/or any modified version) in 
//      any way you find useful, provided that you agree that 
//      Microsoft has no warranty obligations or liability for any 
//      Sample Application Files which are modified. 
//
//--------------------------------------------------------------------------;
//
//  debug.h
//
//  Description:
//
//
//  Notes:
//
//      To use this library at interrupt time under Win16, you must do
//      the following:
//
//      1. Defined ISRDEBUG when compiling debug.c
//  
//      2. Add a line in the SEGMENTS section of your .DEF file to
//         define the DEBUG_TEXT segment:
//
//
//      SEGMENTS
//          DEBUG_TEXT FIXED PRELOAD
//
//
//      These routines are callable at interrupt time under Win32 by
//      default.
//
//  win.ini
//  [debug]
//  MIDIMAP=0|1|2|3|4
//
//  History:
//      11/23/92    cjp     [curtisp] 
//
//==========================================================================;

#ifndef _INC_DEBUG
#define _INC_DEBUG
#ifdef __cplusplus
extern "C"
{
#endif

//
//  
//
//
//
#define  ISRDEBUG             1
#define  DEBUG_SECTION        "debug"        // section name for 
#define  ASSERT_BREAK         "AssertBreak"  // Key for break on assert
#define  DEBUG_MODULE_NAME    "DMUSIC16"     // key name and prefix for output
#define  DEBUG_MAX_LINE_LEN   255            // max line length (bytes)

#define  K_DEFAULT_LOGMEM     32
#define  K_MAX_LOGMEM         63
    
#define  DRV_ENABLE_DEBUG     (DRV_USER+1)   // Enable/disable debug message
#define  DRV_SET_DEBUG_LEVEL  (DRV_USER+2)   // Message to set the debug level

#define WM_DEBUGUPDATE          (WM_USER+1000)

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef DEBUG
    VOID WINAPI DbgAssert(LPSTR lpstrExp, LPSTR lpstrFile, DWORD dwLine);
    BOOL WINAPI DbgEnable(BOOL fEnable);
    UINT WINAPI DbgSetLevel(UINT uLevel);
    UINT WINAPI DbgInitialize(BOOL fEnable);
    void WINAPI DbgRegisterCallback(HWND hWnd);
    BOOL WINAPI DbgGetNextLogEntry(LPSTR lpstrBuffer, UINT cbBuffer);

    void FAR CDECL dprintf(UINT uDbgLevel, LPSTR szFmt, ...);

    #define assert(exp) \
        ( (exp) ? (void) 0 : DbgAssert(#exp, __FILE__, __LINE__) )

    #define DPF                  dprintf

    #define D1(sz)               dprintf(1,sz) 
    #define D2(sz)               dprintf(2,sz) 
    #define D3(sz)               dprintf(3,sz) 
    #define D4(sz)               dprintf(4,sz) 
#else
    #define assert(exp)          ((void)0)
    
    #define DbgEnable(x)         FALSE
    #define DbgSetLevel(x)       0
    #define DbgInitialize(x)     0

    #define DPF                  1 ? (void)0 : (void)

    #define D1(sz)
    #define D2(sz)
    #define D3(sz)
    #define D4(sz)
#endif


#ifdef __cplusplus
}
#endif
#endif  // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic16\debug.c ===
//==========================================================================; 
//
//      Copyright (c) 1991-1999 Microsoft Corporation
//
//      You have a royalty-free right to use, modify, reproduce and 
//      distribute the Sample Files (and/or any modified version) in 
//      any way you find useful, provided that you agree that 
//      Microsoft has no warranty obligations or liability for any 
//      Sample Application Files which are modified. 
//
//--------------------------------------------------------------------------;
//
//  debug.c
//
//  Description:
//      This file contains code yanked from several places to provide debug
//      support that works in win 16 and win 32.
//
//  History:
//      11/23/92    cjp     [curtisp] 
//
//==========================================================================;

#ifdef   DEBUG

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <stdarg.h>

#include "debug.h"

#ifdef WIN32
   #define  BCODE
#else
   #define  BCODE                   __based(__segname("_TEXT"))
#endif


#define WSPRINTF_LIMIT 1024

typedef struct tagLOG
{
     LPBYTE             lpbQueue;
     UINT               cbBuffer;
     UINT               idxRead;
     UINT               idxWrite;
} LOG, FAR *LPLOG;

#define LOG_INCIDX(pl,x) ((++(x) >= pl->cbBuffer) ? x = 0 : x)

VOID FAR CDECL DbgVPrintF(LPSTR szFmt, LPSTR va) ;

BOOL NEAR PASCAL LogInit(LPLOG lpLog, UINT ckBuffer);
VOID NEAR PASCAL LogWrite(LPLOG lpLog, LPSTR lpstrEvent);
BOOL NEAR PASCAL LogRead(LPLOG lpLog, LPSTR lpstrBuffer, UINT cbBuffer);

#ifdef ISRDEBUG
int wivsprintf(LPSTR lpOut, LPCSTR lpFmt, VOID FAR* lpParms) ;

LPCSTR  NEAR PASCAL SP_GetFmtValue(LPCSTR lpch, LPWORD lpw) ;
UINT    NEAR PASCAL SP_PutNumber(LPSTR lpb, DWORD n, UINT limit, UINT radix, UINT icase) ;
VOID    NEAR PASCAL SP_Reverse(LPSTR lpFirst, LPSTR lpLast) ;
UINT    NEAR PASCAL ilstrlen(LPSTR lpstr) ;
VOID    NEAR PASCAL ilstrcat(LPSTR lpstrDest, LPSTR lpstrSrc) ;
#endif

//
//  since we don't UNICODE our debugging messages, use the ASCII entry
//  points regardless of how we are compiled.
//
#define wvsprintfA           wvsprintf
#define GetProfileIntA       GetProfileInt
#define OutputDebugStringA   OutputDebugString

#ifdef ISRDEBUG
   #define wvsprintf        wivsprintf
   #define lstrcatA         ilstrcat
   #define lstrlenA         ilstrlen    
#else
   #define lstrcatA         lstrcat
   #define lstrlenA         lstrlen
#endif

//
//
//
BOOL    __gfDbgEnabled  = TRUE;     // master enable
UINT    __guDbgLevel    = 0;        // current debug level
BOOL    __gfLogging     = 0;        // Are we logging as well?
BOOL    __gfAssertBreak = 0;        // Break on assert?

HWND    ghWndCB         = (HWND)NULL;
LOG     gLog;
WORD    wDebugLevel     = 0;

//************************************************************************
//**
//**  DbgAssert();
//**
//**  DESCRIPTION:
//**
//**
//**  ARGUMENTS:
//**     LPSTR lpstrExp
//**     LPSTR lpstrFile
//**     DWORD dwLine  
//**
//**  RETURNS:
//**     VOID 
//**
//**  HISTORY:
//**
//************************************************************************
VOID WINAPI DbgAssert(
    LPSTR           lpstrExp,
    LPSTR           lpstrFile,
    DWORD           dwLine)
{
    static char BCODE szFormat[] =
        "Assert:%s@%lu %s";
    dprintf(0, szFormat, lpstrFile, dwLine, lpstrExp);
    if (__gfAssertBreak)
        DebugBreak();
}

//************************************************************************
//**
//**  DbgVPrintF();
//**
//**  DESCRIPTION:
//**
//**
//**  ARGUMENTS:
//**     LPSTR szFmt
//**     LPSTR va
//**
//**  RETURNS:
//**     VOID 
//**
//**  HISTORY:
//**
//************************************************************************

VOID FAR CDECL DbgVPrintF(
   LPSTR szFmt, 
   LPSTR va)
{
    char    ach[DEBUG_MAX_LINE_LEN];
    BOOL    fDebugBreak = FALSE;
    BOOL    fPrefix     = TRUE;
    BOOL    fCRLF       = TRUE;

    ach[0] = '\0';

    for (;;)
    {
        switch(*szFmt)
        {
            case '!':
                fDebugBreak = TRUE;
                szFmt++;
                continue;

            case '`':
                fPrefix = FALSE;
                szFmt++;
                continue;

            case '~':
                fCRLF = FALSE;
                szFmt++;
                continue;
        }

        break;
    }

    if (fDebugBreak)
    {
        ach[0] = '\007';
        ach[1] = '\0';
    }

    if (fPrefix)
        lstrcatA(ach, DEBUG_MODULE_NAME ": ");

    wvsprintfA(ach + lstrlenA(ach), szFmt, (LPSTR)va);

    if (fCRLF)
        lstrcatA(ach, "\r\n");

    if (__gfLogging)
    {
        LogWrite(&gLog, ach);
        if (ghWndCB)
            PostMessage(ghWndCB, WM_DEBUGUPDATE, 0, 0);
    }

    OutputDebugStringA(ach);

    if (fDebugBreak)
        DebugBreak();
} //** DbgVPrintF()


//************************************************************************
//**
//**  dprintf();
//**
//**  DESCRIPTION:
//**     dprintf() is called by the DPF macro if DEBUG is defined at compile
//**     time.
//**     
//**     The messages will be send to COM1: like any debug message. To
//**     enable debug output, add the following to WIN.INI :
//**
//**     [debug]
//**     ICSAMPLE=1
//**
//**
//**  ARGUMENTS:
//**     UINT     uDbgLevel
//**     LPCSTR   szFmt
//**     ...
//**
//**  RETURNS:
//**     VOID 
//**
//**  HISTORY:
//**     06/12/93       [t-kyleb]      
//**
//************************************************************************

VOID FAR CDECL dprintf(
   UINT     uDbgLevel, 
   LPSTR   szFmt, 
   ...)
{
    va_list va;

    if (!__gfDbgEnabled || (__guDbgLevel < uDbgLevel))
        return;

    va_start(va, szFmt);
    DbgVPrintF(szFmt, (LPSTR)va);
    va_end(va);
} //** dprintf()


//************************************************************************
//**
//**  DbgEnable();
//**
//**  DESCRIPTION:
//**
//**
//**  ARGUMENTS:
//**     BOOL fEnable
//**
//**  RETURNS:
//**     BOOL 
//**
//**  HISTORY:
//**     06/12/93       [t-kyleb]      
//**
//************************************************************************

BOOL WINAPI DbgEnable(
   BOOL fEnable)
{
    BOOL    fOldState;

    fOldState      = __gfDbgEnabled;
    __gfDbgEnabled = fEnable;

    return (fOldState);
} //** DbgEnable()



//************************************************************************
//**
//**  DbgSetLevel();
//**
//**  DESCRIPTION:
//**
//**
//**  ARGUMENTS:
//**     UINT uLevel
//**
//**  RETURNS:
//**     UINT 
//**
//**  HISTORY:
//**     06/12/93       [t-kyleb]      
//**
//************************************************************************

UINT WINAPI DbgSetLevel(
   UINT uLevel)
{
    UINT    uOldLevel;

    uOldLevel    = __guDbgLevel;
    __guDbgLevel = wDebugLevel = uLevel;

    return (uOldLevel);
} //** DbgSetLevel()


//--------------------------------------------------------------------------;
//
//  UINT DbgInitialize(VOID)
//
//  Description:
//      
//
//  Arguments:
//
//  Return (UINT):
//
//
//  History:
//      11/24/92    cjp     [curtisp] 
//
//--------------------------------------------------------------------------;


UINT WINAPI DbgInitialize(BOOL fEnable)
{
    char            szTemp[64];
    LPSTR           pstr;
    UINT            uLevel;
    UINT            uLogMem;
    
    __gfAssertBreak = GetProfileInt(DEBUG_SECTION, ASSERT_BREAK, 0);

    GetProfileString(DEBUG_SECTION, DEBUG_MODULE_NAME, "", szTemp, sizeof(szTemp));

    pstr = szTemp;
    uLevel = 0;
    while (*pstr >= '0' && *pstr <= '9')
    {
        uLevel = uLevel*10 + (UINT)(*pstr - '0');
        pstr++;
    }

    __gfLogging = FALSE;
    if (*pstr == ',')
    {
        pstr++;
        uLogMem = 0;
        while (*pstr >= '0' && *pstr <= '9')
        {
            uLogMem = uLogMem*10 + (UINT)(*pstr - '0');
            pstr++;
        }

        if (0 == uLogMem) uLogMem = K_DEFAULT_LOGMEM;
        if (uLogMem > K_MAX_LOGMEM) uLogMem = K_MAX_LOGMEM;

        __gfLogging = TRUE;
    }
    
    if (__gfLogging)
        __gfLogging = LogInit(&gLog, uLogMem);
    
    DbgSetLevel(GetProfileIntA(DEBUG_SECTION, DEBUG_MODULE_NAME, 0));
    DbgEnable(fEnable);

    return (__guDbgLevel);
} // DbgInitialize()

VOID WINAPI DbgRegisterCallback(HWND hWnd)
{
    ghWndCB = hWnd;
}

BOOL WINAPI DbgGetNextLogEntry(LPSTR lpstrBuffer, UINT cbBuffer)
{
    if (!__gfLogging)
        return FALSE;

    return LogRead(&gLog, lpstrBuffer, cbBuffer);
}

BOOL NEAR PASCAL LogInit(LPLOG lpLog, UINT ckMem)
{
    DWORD               cbMem;

    cbMem = 1024L * ckMem;

    lpLog->lpbQueue = GlobalAllocPtr(GPTR, cbMem);
    if (NULL == lpLog->lpbQueue)
        return FALSE;

    if (!GlobalSmartPageLock(HIWORD(lpLog->lpbQueue)))
    {
        GlobalFreePtr(lpLog->lpbQueue);
        return FALSE;
    }

    lpLog->cbBuffer = (UINT)cbMem;
    lpLog->idxRead = 0;
    lpLog->idxWrite = 0;

    return TRUE;
}

VOID NEAR PASCAL LogWrite(LPLOG lpLog, LPSTR lpstrEvent)
{
    if (!*lpstrEvent)
        return;

    while (*lpstrEvent)
    {
        lpLog->lpbQueue[lpLog->idxWrite] = *lpstrEvent++;
        LOG_INCIDX(lpLog,lpLog->idxWrite);
    }

    lpLog->idxRead = lpLog->idxWrite;

    while (lpLog->lpbQueue[lpLog->idxRead])
    {
        lpLog->lpbQueue[lpLog->idxRead] = '\0';
        LOG_INCIDX(lpLog,lpLog->idxRead);
    }
    
    LOG_INCIDX(lpLog,lpLog->idxRead);
    LOG_INCIDX(lpLog,lpLog->idxWrite);
}

BOOL NEAR PASCAL LogRead(LPLOG lpLog, LPSTR lpstrBuffer, UINT cbBuffer)
{
    BYTE                    c;
    UINT                    idx;

    if (!cbBuffer)
        return FALSE;
    
    idx = lpLog->idxRead;

    while ('\0' == lpLog->lpbQueue[idx])
    {
        LOG_INCIDX(lpLog,idx);
        if (idx == lpLog->idxRead)
            return FALSE;
    }

    cbBuffer--;
    while (0 != (c = lpLog->lpbQueue[idx]))
    {
        if (cbBuffer)
        {
            *lpstrBuffer++ = c;
            cbBuffer--;
        }
            
        lpLog->lpbQueue[idx] = '\0';
        LOG_INCIDX(lpLog,idx);
    }

    *lpstrBuffer = '\0';

    LOG_INCIDX(lpLog,idx);

    lpLog->idxRead = idx;
    return TRUE;
}



//--------------------------------------------------------------------------;
//
// The rest of the code is only needed if we're in Win16 and need to be
// interrupt callable.
//
//--------------------------------------------------------------------------;

#ifdef ISRDEBUG

#define OUT(ch) if (--cchLimit) *lpOut++=(ch); else goto error_Out

//************************************************************************
//**
//**  wivsprintf();
//**
//**  DESCRIPTION:
//**     Interrupt callable version of wvsprintf() 
//**
//**
//**  ARGUMENTS:
//**     LPSTR       lpOut    -  Buffer to format into.
//**     LPCSTR      lpFmt    -  Format string.
//**     VOID FAR*   lpParms  -  Points to the first of args 
//**                             described by lpFmt.
//**
//**  RETURNS:
//**     int   -  Number of characters stored.
//**
//**  HISTORY:
//**     3/28/93     jfg      [jimge] 
//**
//************************************************************************

int wivsprintf(
    LPSTR       lpOut,
    LPCSTR      lpFmt,
    VOID FAR*   lpParms)
{
    int         left ;
    char        prefix ;
    int         width ;
    int         prec ;
    char        fillch ;
    int         size ;
    int         sign ;
    int         radix ;
    int         upper ;
    int         cchLimit = WSPRINTF_LIMIT;
    int         cch ;
    LPSTR       lpT ;
    union
    {
        long            l ;
        unsigned long   ul ;
        char sz[sizeof(long)] ;
    } val;
                
    while (*lpFmt)
    {
        if (*lpFmt=='%')
        {
            //
            // Read the format flags. 
            //
            left   = 0 ;
            prefix = 0 ;

            while (*++lpFmt)
            {
                if (*lpFmt=='-')
                {    
                    left++;
                }
                else if (*lpFmt=='#')
                {
                    prefix++;
                }
                else
                {
                    break;
                }
            }

            //
            // Find the fill character (either '0' or ' ')
            //
            if (*lpFmt=='0')
            {
                fillch = '0' ;
                lpFmt++ ;
            }
            else
            {
                fillch = ' ' ;
            }

            //
            // Now parse [width[.precision]]
            //
            lpFmt = SP_GetFmtValue(lpFmt,&cch);
            width = cch;

            if (*lpFmt=='.')
            {
                lpFmt = SP_GetFmtValue(++lpFmt,&cch);
                prec = cch;
            }
            else
            {
                prec = (UINT)-1 ;
            }

            //
            // Get the operand size modifier
            //
            if (*lpFmt=='l')
            {
                size = 1 ;
                lpFmt++ ;
            }
            else
            {
                size = 0 ;
                if (*lpFmt=='h')
                {
                    lpFmt++ ;
                }
            }
            
            //
            // We've gotten all the modifier; now format the output
            // based on the type (which should now be pointed at
            // by lpFmt).
            //
            upper = 0 ;
            sign = 0 ;
            radix = 10 ;

            switch (*lpFmt)
            {
                case 0:
                    goto error_Out ;

                case 'i' :
                case 'd' :
                    sign++ ;

                case 'u':
                    //
                    // Don't show a prefix for decimal formats
                    // 
                    prefix=0 ;
do_Numeric:
                    //
                    // Special cases to act like MSC v5.10
                    //
                    if (left || prec>=0)
                    {
                        fillch = ' ';
                    }

                    //
                    // Get value from parm list into val union 
                    // 
                    if (size)
                    {
                        val.l=*((long far *)lpParms)++;
                    }
                    else
                    {
                        if (sign)
                        {
                            val.l=(long)*((short far *)lpParms)++;
                        }
                        else
                        {
                            val.ul=(unsigned long)*((unsigned far *)lpParms)++;
                        }
                    }

                    //
                    // Save sign of val.l in sign and set val.l positive.
                    //
                    if (sign && val.l<0L)
                    {
                        val.l=-val.l;
                    }
                    else
                    {
                        sign=0;
                    }

                    //
                    // Save start of output stream for later reverse
                    //
                    lpT = lpOut;

                    //
                    // Blast the number backwards into the user buffer 
                    //
                    cch = SP_PutNumber(lpOut,val.l,cchLimit,radix,upper) ;
                    if (!(cchLimit-=cch))
                        goto error_Out ;

                    lpOut += cch ;
                    width -= cch ;
                    prec -= cch ;

                    if (prec>0)
                    {
                        width -= prec ;
                    }

                    //
                    // Fill in up to precision
                    //
                    while (prec-- > 0)
                    {
                        OUT('0') ;
                    }

                    if (width>0 && !left)
                    {
                        //
                        // If we're filling with spaces, put sign first 
                        //
                        if (fillch != '0')
                        {
                            if (sign)
                            {
                                sign = 0 ;
                                OUT('-') ;
                                width-- ;
                            }

                            if (prefix)
                            {
                                OUT(prefix) ;
                                OUT('0') ;
                                prefix = 0 ;
                            }
                        }

                        if (sign)
                        {
                            width-- ;
                        }

                        //
                        // Now fill to width
                        //
                        while (width-- > 0)
                        {
                            OUT(fillch) ;
                        }

                        //
                        // Still have a sign? 
                        //
                        if (sign)
                        {
                            OUT('-') ;
                        }

                        if (prefix)
                        {
                            OUT(prefix) ;
                            OUT('0') ;
                        }

                        //
                        // Now reverse the string in place
                        //
                        SP_Reverse(lpT,lpOut-1);
                    }
                    else
                    {
                        //
                        // Add the sign character
                        //
                        if (sign)
                        {
                            OUT('-') ;
                            width-- ;
                        }

                        if (prefix)
                        {
                            OUT(prefix);
                            OUT('0');
                        }

                        //
                        // Now reverse the string in place
                        //
                        SP_Reverse(lpT,lpOut-1);

                        //
                        // Pad to the right of the string in case left aligned 
                        //
                        while (width-- > 0)
                        {
                            OUT(fillch) ;
                        }
                    }
                    break ;

                case 'X':
                    upper++ ;
                    //
                    // Falling through...
                    //

                case 'x':
                    radix=16 ;
                    if (prefix)
                    {
                        prefix = upper ? 'X' : 'x' ;
                    }
                    goto do_Numeric ;

                case 'c':
                    //
                    // Save as one character string and join common code
                    // 
                    val.sz[0] = *((char far*)lpParms) ;
                    val.sz[1]=0 ;
                    lpT = val.sz ;
                    cch = 1 ;  
                    (BYTE far*)lpParms += sizeof(WORD) ;

                    goto put_String ;

                case 's':
                    lpT = *((LPSTR FAR *)lpParms)++ ;
                    cch = ilstrlen(lpT) ;
put_String:
                    if (prec>=0 && cch>prec)
                    {
                        cch = prec ;
                    }

                    width -= cch ;

                    if (left)
                    {
                        while (cch--)
                        {
                            OUT(*lpT++) ;
                        }

                        while (width-->0)
                        {
                            OUT(fillch) ;
                        }
                    }
                    else
                    {
                        while (width-- > 0)
                        {
                            OUT(fillch) ;
                        }

                        while (cch--)
                        {
                            OUT(*lpT++) ;
                        }
                    }
                    break ;

                default:
                    //
                    // An unsupported type character was given. We just
                    // print the character and go on. 
                    //
                    OUT(*lpFmt) ;
                    break ;

            } // switch(*lpfmt)
        } // if (*lpfmt == '%')
        else
        {
            //
            // Normal not-format character
            //
            OUT(*lpFmt) ;
        }
                
        lpFmt++ ;
    } // while (*lpFmt) 

error_Out:
    *lpOut = 0 ;

    return WSPRINTF_LIMIT-cchLimit ;
} //** wivsprintf()


//************************************************************************
//**
//**  SP_GetFmtValue();
//**
//**  DESCRIPTION:
//**     Parse a decimal integer forming part of a format string.
//**
//**
//**  ARGUMENTS:
//**     LPCSTR   lpch  -  Points to the string to parse.
//**     LPWORD   lpw   -  Points to a word where the value will be 
//**                       returned.
//**
//**  RETURNS:
//**     LPCSTR   -  Pointer of first character past the format value.
//**
//**  HISTORY:
//**     3/28/93     jfg      [jimge] 
//**
//************************************************************************

LPCSTR NEAR PASCAL SP_GetFmtValue(
   LPCSTR   lpch,
   LPWORD   lpw)
{
    WORD        i = 0 ;

    while (*lpch>='0' && *lpch<='9')
    {
        i *= 10;
        i += (UINT)(*lpch++-'0');
    }     

    *lpw = i;

    return(lpch); 
} //** SP_GetFmtValue()

//************************************************************************
//**
//**  SP_PutNumber();
//**
//**  DESCRIPTION:
//**     Formats the given number in the given radix into the buffer
//**     *backwards*. The entire string will be reversed after printf
//**     has added sign, prefix, etc. to it.
//**
//**  
//**  ARGUMENTS:
//**     LPSTR lpb   -  Points to the output buffer.
//**     DWORD n     -  Number to convert.
//**     UINT  limit -  Maximum number of characters to store.
//**     UINT  radix -  Base to format in.
//**     UINT  icase -  Non-zero if the string should be upper case (hex).
//**
//**  RETURNS:
//**     UINT  -  Number of characters output.
//**
//**  HISTORY:
//**
//************************************************************************

UINT NEAR PASCAL SP_PutNumber(
   LPSTR lpb,
   DWORD n,
   UINT  limit,
   UINT  radix,
   UINT  icase)
{
   BYTE  bTemp;
   UINT  cchStored = 0;

   //
   // Set icase to the offset to add to the character if it
   // represents a value > 10
   //
   icase = (icase ? 'A' : 'a') - '0' - 10 ;

   while (limit--)
   {
//
//    AVOID a call to __aFulrem
//    This code words because radix is only a word
//
//    bTemp = '0' + (BYTE)(n%radix) ;
//
      _asm
      {
         mov     cx, radix
         mov     ax, word ptr n+2
         xor     dx, dx
         div     cx
         mov     ax, word ptr n
         div     cx
         add     dl, '0'
         mov     bTemp, dl
      }

      if (bTemp > '9')
      {
         bTemp += icase ;
      }

      *lpb++ = bTemp ;
      ++cchStored ;

//       
//    AVOID a call to __aFFauldiv
//    This code words because radix is only a word
//
//    n /= radix
//
      _asm
      {
         push    bx
         mov     cx, radix
         mov     ax, word ptr n+2
         xor     dx, dx
         div     cx
         mov     bx, ax
         mov     ax, word ptr n
         div     cx
         mov     word ptr n+2, bx
         mov     word ptr n, ax
         pop     bx
      }

      if (n == 0)
      {
         break ;
      }    
   }

   return cchStored ;
} //** SP_PutNumber()


//************************************************************************
//**
//**  SP_Reverse();
//**
//**  DESCRIPTION:
//**     Reverse string in place.
//**
//**  ARGUMENTS:
//**     LPSTR pFirst
//**     LPSTR pLast
//**
//**  RETURNS:
//**     VOID 
//**
//**  HISTORY:
//**
//************************************************************************

VOID NEAR PASCAL SP_Reverse(
   LPSTR pFirst,
   LPSTR pLast)
{
   UINT  uSwaps = (pLast - pFirst + 1) / 2;
   BYTE  bTemp;

   while (uSwaps--)
   {
      bTemp   = *pFirst;
      *pFirst = *pLast;
      *pLast  = bTemp;

      pFirst++, pLast--;
   }
} //** SP_Reverse()

//************************************************************************
//**
//**  ilstrlen();
//**
//**  DESCRIPTION:
//**     Interrupt callable version of strlen().
//**
//**  ARGUMENTS:
//**     LPSTR   pstr
//**
//**  RETURNS:
//**     UINT 
//**
//**  HISTORY:
//**
//************************************************************************

UINT NEAR PASCAL ilstrlen(
    LPSTR   pstr)
{
   UINT    cch = 0 ;

   while (*pstr++)
      ++cch;

   return(cch);
} //** ilstrlen()

//************************************************************************
//**
//**  ilstrcat();
//**
//**  DESCRIPTION:
//**     Interrupt callable version of lstrcat().
//**
//**  ARGUMENTS:
//**     LPSTR   pstrDest
//**     LPSTR   pstrSrc
//**
//**  RETURNS:
//**     VOID 
//**
//**  HISTORY:
//**
//************************************************************************

VOID NEAR PASCAL ilstrcat(
    LPSTR   pstrDest,
    LPSTR   pstrSrc)
{
   while (*pstrDest)
      pstrDest++;

   while (*pstrDest++ = *pstrSrc++)
      ;

} //** ilstrcat()

#endif // #ifdef ISRDEBUG

#endif // #ifdef DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic16\device.c ===
/*
 * @Doc DMusic16
 *
 * @Module Device.c - Device management routines |
 *
 * This module manages handles and handle instances to the legacy MIDI device.
 *
 * Each open device is represented by a handle (which is 
 * an <c OPENHANDLE> struct). This struct contains all of the information
 * concerning the state of the device, including a reference count of the
 * number of clients using the device.
 *
 * Each client use of one device is represented by a handle instance (which
 * is an <c OPENHANDLINSTANCE> struct). A near pointer to this struct is
 * the actual handle seen by the client. These handle instances are used
 * to hold any client-specific information, and to dereference client
 * handles to the proper <c OPENHANDLE> struct.
 *
 * Currently we support multiple clients on the same output device but
 * only one client per input device.
 *
 * @globalv NPLINKNODE | gOpenHandleInstanceList | The master list of all
 * open handle instances.
 *
 * @globalv NPLINKNODE | gOpenHandleList | The master list of all open
 * handles.
 *
 * @globalv UINT | gcOpenInputDevices | A reference count of open MIDI
 * in devices.
 *
 * @globalv UINT | gcOpenOutputDevices | A reference count of open MIDI
 * out devices.
 */

#include <windows.h>
#include <mmsystem.h>

#include "dmusic16.h"
#include "debug.h"

NPLINKNODE gOpenHandleInstanceList;  
NPLINKNODE gOpenHandleList;          
UINT gcOpenInputDevices;             
UINT gcOpenOutputDevices;            

STATIC VOID PASCAL UpdateSegmentLocks(BOOL fIsOutput);

#pragma alloc_text(INIT_TEXT, DeviceOnLoad)
#pragma alloc_text(FIX_COMM_TEXT, IsValidHandle)

/* @func Called at DLL LibInit 
 *
 * @comm
 *
 * Initialize the handle lists to empty and clear the device reference counts.
 */
VOID PASCAL
DeviceOnLoad(VOID)
{
   gOpenHandleInstanceList = NULL;
   gOpenHandleList = NULL;

   gcOpenInputDevices = 0;
   gcOpenOutputDevices = 0;
}

/* @func Open a device
 *
 * @comm
 *
 * This function is thunked to the 32-bit peer.
 *
 * This function allocates an <c OPENHANDLEINSTANCE> struct on behalf of the caller.
 * If the requested device is already open and is an output device, the device's
 * reference count will be incremented an no other action is taken. If the requested
 * device is already open and is an input device, then the open will fail.
 *
 * If a non-DirectMusic application has the requested device open, then the
 * open will fail regardless of device type.
 *
 * If this open is the first input or output device opened, then it will
 * page lock the appropriate segments containing callback code and data.
 *
 * @rdesc Returns one of the following:
 *
 * @flag MMSYSERR_NOERROR | On success
 * @flag MMSYSERR_NOMEM | If there was insufficient memory to allocate
 * the tracking structure.
 *
 * @flag MMSYSERR_BADDEVICEID | If the given device ID was out of range.
 * @flag MMSYSERR_ALLOCATED | The specified device is already open.
 *
 */
MMRESULT WINAPI
OpenLegacyDevice(
    UINT id,            /* @parm MMSYSTEM id of device to open */
    BOOL fIsOutput,     /* @parm TRUE if this is an output device */
    BOOL fShare,        /* @parm TRUE if the device should be shareable */
    LPHANDLE ph)        /* @parm Pointer where handle will be returned */
                        /*       on success. */
{
    NPOPENHANDLEINSTANCE pohi;
    NPLINKNODE pLink;
    NPOPENHANDLE poh;
    MMRESULT mmr;

    DPF(2, "OpenLegacyDevice(%d,%s,%s)",
        (UINT)id,
        (LPSTR)(fIsOutput ? "Output" : "Input"),
        (LPSTR)(fShare ? "Shared" : "Exclusive"));
        
    *ph = (HANDLE)NULL;

    /* Sharing capture device is not allowed.
     */
    if ((!fIsOutput) && (fShare))
    {
        return MMSYSERR_ALLOCATED;
    }

    /* Make sure id is in the valid range of devices
     */
    if (fIsOutput)
    {
        if (id != MIDI_MAPPER &&
            id >= midiOutGetNumDevs())
        {
            return MMSYSERR_BADDEVICEID;
        }
    }
    else
    {
        if (id >= midiInGetNumDevs())
        {
            return MMSYSERR_BADDEVICEID;
        }
    }

    /* Create an open handle instance. This will be returned to
     * Win32 as the handle.
     */
    pohi = (NPOPENHANDLEINSTANCE)LocalAlloc(LPTR, sizeof(OPENHANDLEINSTANCE));
    if (NULL == pohi)
    {
        return MMSYSERR_NOMEM;
    }

    /* Search through the handles we already have open and try
     * to find the handle already open.
     */
    mmr = MMSYSERR_NOERROR;
    for (pLink = gOpenHandleList; pLink; pLink = pLink->pNext)
    {   
        poh = (NPOPENHANDLE)pLink;

        if (poh->id != id)
        {
            continue;
        }

        if ((fIsOutput    && (!(poh->wFlags & OH_F_MIDIIN))) ||
            ((!fIsOutput) && (poh->wFlags & OH_F_MIDIIN)))
        {
            break;
        }
    }

    /* If we didn't find it, try to allocate it.
     *
     */
    if (NULL == pLink)
    {
        poh = (NPOPENHANDLE)LocalAlloc(LPTR, sizeof(OPENHANDLE));
        if (NULL == poh)
        {
            LocalFree((HLOCAL)pohi);
            return MMSYSERR_NOMEM;
        }

        poh->uReferenceCount = 1;
        poh->id = id;
        poh->wFlags = (fIsOutput ? 0 : OH_F_MIDIIN);
        if (fShare)
        {
            poh->wFlags |= OH_F_SHARED;
        }
        InitializeCriticalSection(&poh->wCritSect);
    }
    else
    {
        poh = (NPOPENHANDLE)pLink;
        
        /* Validate sharing modes match.
         * If they want exclusive mode, fail. 
         * If the device is already open in exclusive mode, fail.
         */
        if (!fShare)
        {
            DPF(0, "Legacy open failed: non-shared open request, port already open.");
            LocalFree((HLOCAL)pohi);
            return MIDIERR_BADOPENMODE;
        }

        if (!(poh->wFlags & OH_F_SHARED))
        {
            DPF(0, "Legacy open failed: Port already open in exclusive mode.");
            LocalFree((HLOCAL)pohi);
            return MIDIERR_BADOPENMODE;
        }

        ++poh->uReferenceCount;
    }

    pohi->pHandle = poh;
    pohi->fActive = FALSE;
    pohi->wTask = GetCurrentTask();

    /* We lock segments here so we minimize the impacy of activation. However,
     * actual device open is tied to activation.
     */
    if (fIsOutput)
    {
        ++gcOpenOutputDevices;
        mmr = MidiOutOnOpen(pohi);
        if (mmr)
        {
            --gcOpenOutputDevices;
        }
        UpdateSegmentLocks(fIsOutput);
    }
    else
    {
        ++gcOpenInputDevices;
        mmr = MidiInOnOpen(pohi);
        if (mmr)
        {
            --gcOpenInputDevices;
        }
        UpdateSegmentLocks(fIsOutput);
    }

    if (poh->uReferenceCount == 1)
    {
        ListInsert(&gOpenHandleList, &poh->link);
    }

    ListInsert(&gOpenHandleInstanceList, &pohi->link);
    ListInsert(&poh->pInstanceList, &pohi->linkHandleList);

    *ph = (HANDLE)(DWORD)(WORD)pohi;

    return MMSYSERR_NOERROR;
}

/* @func Close a legacy device
 *
 * @comm
 *
 * This function is thunked to the 32-bit peer.
 *
 * It just validates the handle and calls the internal close device API.
 *
 * @rdesc Returns one of the following:
 *
 * @flag MMSYSERR_NOERROR | On success
 *
 * @flag MMSYSERR_INVALHANDLE | If the passed handle was not recognized.
 *
 */
MMRESULT WINAPI
CloseLegacyDevice(
    HANDLE h)       /* @parm The handle to close. */
{
    NPOPENHANDLEINSTANCE pohi = (NPOPENHANDLEINSTANCE)(WORD)h;

    DPF(2, "CloseLegacyDevice %04X\n", h);

    if (!IsValidHandle(h, VA_F_EITHER, &pohi))
    {
        DPF(0, "CloseLegacyDevice: Invalid handle\n");
        return MMSYSERR_INVALHANDLE;
    }

    return CloseLegacyDeviceI(pohi);
}

/* @func Activate or deactivate a legacy device
 *
 * @comm
 *
 * This function is thunked to the 32-bit peer.
 *
 * Validate parameters and pass the call to the internal activate.
 *
 * @rdesc Returns one of the following:
 *
 * @flag MMSYSERR_NOERROR | On success
 * @flag MMSYSERR_INVALHANDLE | If the passed handle was not recognized.
 * Any other MMRESULT that a midiXxx call might return.
 *
 */
MMRESULT WINAPI
ActivateLegacyDevice(
    HANDLE h,
    BOOL fActivate)
{
    NPOPENHANDLEINSTANCE pohi;

    if (!IsValidHandle(h, VA_F_EITHER, &pohi))
    {
        DPF(0, "Activate: Invalid handle\n");
        return MMSYSERR_INVALHANDLE;
    }

    return ActivateLegacyDeviceI(pohi, fActivate);
}

/* @func Close a legacy device (internal)
 *
 * @comm
 *
 * This function deallocates the referenced <c OPENHANDLEINSTANCE> struct.
 * If it is the last reference to the device, then the device will be closed
 * as well.
 *
 * If this is the last input or output device being closed, then the
 * appropriate segments containing callback code and data will be
 * unlocked.
 *
 * @rdesc Returns one of the following:
 *
 * @flag MMSYSERR_NOERROR | On success
 *
 */
MMRESULT PASCAL
CloseLegacyDeviceI(
    NPOPENHANDLEINSTANCE pohi)
{
    NPOPENHANDLE poh;

    /* Deactivate this device. This might result in the device being closed.
     */
    ActivateLegacyDeviceI(pohi, FALSE);

    poh = pohi->pHandle;
    ListRemove(&gOpenHandleInstanceList, &pohi->link);
    ListRemove(&poh->pInstanceList, &pohi->linkHandleList);

    --poh->uReferenceCount;
    if (poh->wFlags & OH_F_MIDIIN)
    {
        --gcOpenInputDevices;
        MidiInOnClose(pohi);
        UpdateSegmentLocks(FALSE /*fIsOutput*/);
    }
    else
    {
        --gcOpenOutputDevices;
        MidiOutOnClose(pohi);
        UpdateSegmentLocks(TRUE  /*fIsOutput*/);
    }

    if (0 == poh->uReferenceCount)
    {
        ListRemove(&gOpenHandleList, &poh->link);
        LocalFree((HLOCAL)poh);
    }

    LocalFree((HLOCAL)pohi);

    return MMSYSERR_NOERROR;
}

/* @func Activate or deactivate a legacy device (internal)
 *
 * @comm
 *
 * This function is thunked to the 32-bit peer.
 *
 * Handle open and close of the device on first activate and last deactivate.
 *
 * @rdesc Returns one of the following:
 *
 * @flag MMSYSERR_NOERROR | On success
 * @flag MMSYSERR_INVALHANDLE | If the passed handle was not recognized.
 * Any other MMRESULT that a midiXxx call might return.
 *
 */
MMRESULT PASCAL
ActivateLegacyDeviceI(
    NPOPENHANDLEINSTANCE pohi,
    BOOL fActivate)
{
    NPOPENHANDLE poh;
    MMRESULT mmr;

    poh = pohi->pHandle;

    if (fActivate)
    {
        if (pohi->fActive)
        {
            DPF(0, "Activate: Activating already active handle %04X", pohi);
            return MMSYSERR_NOERROR;
        }

        poh->uActiveCount++;
    
        if (poh->wFlags & OH_F_MIDIIN)
        {
            mmr = MidiInOnActivate(pohi);
        }
        else
        {
            mmr = MidiOutOnActivate(pohi);
        }

        if (mmr == MMSYSERR_NOERROR) 
        {
            pohi->fActive = TRUE;
        }
        else
        {
            --poh->uActiveCount;
        }
    }
    else
    {
        if (!pohi->fActive)
        {
            DPF(0, "Activate: Deactivating already inactive handle %04X", pohi);
            return MMSYSERR_NOERROR;
        }

        pohi->fActive = TRUE;
        poh->uActiveCount--;

        if (poh->wFlags & OH_F_MIDIIN)
        {
            mmr = MidiInOnDeactivate(pohi);
        }
        else
        {
            mmr = MidiOutOnDeactivate(pohi);
        }

        if (mmr == MMSYSERR_NOERROR) 
        {
            pohi->fActive = FALSE;
        }
        else
        {
            --poh->uActiveCount;
        }
    }

    return mmr;    
}

/* @func Validate the given handle
 *
 * @comm
 *
 * Determine if the given handle is valid, and if so, return the open handle instance.
 *
 * The handle is merely a pointer to an <c OPENHANDLEINSTANCE> struct. This function,
 * in the debug build, will verify that the handle actually points to a struct allocated
 * by this DLL. In all builds, the handle type will be verified.
 *
 * @rdesc Returns one of the following:
 * @flag MMSYSERR_NOERROR | On success
 * @flag MMSYSERR_INVALHANDLE | If the given handle is invalid or of the wrong type.
 *
 */
BOOL PASCAL
IsValidHandle(
    HANDLE h,                           /* @parm The handle to verify */
    WORD wType,                         /* @parm The required type of handle. One of the following: */
                                        /* @flag VA_F_INPUT  | If the handle must specify an input device */
                                        /* @flag VA_F_OUTPUT | If the handle must specify an output device */
                                        /* @flag VA_F_EITHER | If either type of handle is acceptable */
    NPOPENHANDLEINSTANCE FAR *lppohi)   /* @parm Will contain the open handle instance on return */
{
#ifdef DEBUG
    NPLINKNODE pLink;
#endif
    NPOPENHANDLEINSTANCE pohi = (NPOPENHANDLEINSTANCE)(WORD)h;

#ifdef DEBUG
    /* Find the handle instance in the global list
     */
    for (pLink = gOpenHandleInstanceList; pLink; pLink = pLink->pNext)
    {
        DPF(2, "IsValidHandle: Theirs %04X mine %04X", (WORD)h, (WORD)pLink);
        if (pLink == (NPLINKNODE)(WORD)h)
        {
            break;
        }
    }

    if (NULL == pLink)
    {
        return FALSE;
    }
#endif

    DPF(2, "IsValidHandle: Got handle, flags are %04X", pohi->pHandle->wFlags);

    *lppohi = pohi;
    
    /* Verify the handle type
     */
    if (pohi->pHandle->wFlags & OH_F_MIDIIN)
    {
        if (wType & VA_F_INPUT)
        {
            return TRUE;
        }
    }
    else
    {
        if (wType & VA_F_OUTPUT)
        {
            return TRUE;
        }
    }

    *lppohi = NULL;

    return FALSE;
}


/* @func Lock or unlock segments as need be.
 *
 * @comm
 *
 * This function calls the DLL's Lock and Unlock functions to bring the lock status
 * of the segments containing callback code and data into sync with the actual types
 * of devices currently open. This prevents having too much memory page locked when
 * it is not actually being used.
 *
 */
STATIC VOID PASCAL
UpdateSegmentLocks(
    BOOL fIsOutput)     /* @parm TRUE if the last device opened or closed was an output device */
{
    if (fIsOutput)
    {
        switch(gcOpenOutputDevices)
        {
            case 0:
                if (gcOpenInputDevices)
                {
                    DPF(2, "Unlocking output");
                    UnlockCode(LOCK_F_OUTPUT);
                }
                else
                {
                    DPF(2, "Unlocking output+common");
                    UnlockCode(LOCK_F_OUTPUT | LOCK_F_COMMON);
                }
                break;

            case 1:
                if (gcOpenInputDevices)
                {
                    DPF(2, "Locking output");
                    LockCode(LOCK_F_OUTPUT);
                }
                else
                {
                    DPF(2, "Locking output+common");
                    LockCode(LOCK_F_OUTPUT | LOCK_F_COMMON);
                }
                break;
        }
    }
    else
    {
        switch(gcOpenInputDevices)
        {
            case 0:
                if (gcOpenOutputDevices)
                {
                    DPF(2, "Unlocking input");
                    UnlockCode(LOCK_F_INPUT);
                }
                else
                {
                    DPF(2, "Unlocking input+common");
                    UnlockCode(LOCK_F_INPUT | LOCK_F_COMMON);
                }
                break;

            case 1:
                if (gcOpenOutputDevices)
                {
                    DPF(2, "Locking input");
                    LockCode(LOCK_F_INPUT);
                }
                else
                {
                    DPF(2, "Locking input+common");
                    LockCode(LOCK_F_INPUT | LOCK_F_COMMON);
                }
                break;
        }
    }
}

/* @func Clean up all open handles held by a given task
 *
 * @comm This function is called when a task terminates. It will clean up resources left
 * behind by a process which did not terminate cleanly, and therefore did not tell
 * this DLL to unload in its context.
 */
VOID PASCAL
CloseDevicesForTask(
    WORD wTask)
{
    NPLINKNODE pLink;
    NPOPENHANDLEINSTANCE pohi;

    for (pLink = gOpenHandleInstanceList; pLink; pLink = pLink->pNext)
    {
        pohi = (NPOPENHANDLEINSTANCE)pLink;

        if (pohi->wTask != wTask)
        {
            continue;
        }

        DPF(0, "CloseDevicesForTask: Closing %04X", (WORD)pohi);
        /* NOTE: This will free pohi
         */
        CloseLegacyDeviceI(pohi);

        pLink = gOpenHandleInstanceList;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic16\dmhelp.asm ===
; Copyright (c) 1998 Microsoft Corporation
;
; @Doc DMusic16
;
; @Module  DMHelp.asm - Helper functions |
;
; Thunk helpers for DMusic16.DLL
;

        page    ,132

        TITLE   $dos\usa\dmhelp.asm

        .386
        OPTION READONLY
        OPTION OLDSTRUCTS

        OPTION SEGMENT:USE16
        .model LARGE,PASCAL

;?MEDIUM=1
;?QUIET=1

externDef TileBuffer:far16
externDef UntileBuffer:far16
externDef OutputDebugString:far16

;===========================================================================
;
; 64-bit integer struct as passed in from C routines
;
; This must match the definition in dmusic16.h
;
;
;===========================================================================
QUADWORD	struc
qwLow		dd			?
qwHigh		dd			?
QUADWORD	ends

        .code dmhelp


;===========================================================================

EAXtoDXAX       macro
        shld    edx, eax, 16            ; move HIWORD(eax) to dx
endm

DXAXtoEAX       macro
        ror     eax, 16                 ; xchg HIWORD(eax) and LOWORD(eax)
        shrd    eax, edx, 16            ; move LOWORD(edx) to HIWORD(eax)
endm

;===========================================================================
public dmTileBuffer
public dmUntileBuffer
public QuadwordDiv

externDef       __FLATDS:abs

_DATA SEGMENT WORD USE16 PUBLIC 'DATA'
FlatData                dw      __FLATDS
ifdef DEBUG
szNotOwner              db      'Critical section released by other than owner', 0
endif
_DATA ENDS

;===========================================================================
;
; @func DWORD | dmTileBuffer | Tile a 32-bit linear address as selectors
;
; @comm 
;
; Take the 32-bit virtual address in <p dwFlatMemory> of length <p dwLength> and create
; tiled selectors for it. This is used to pass a region of memory to a 16 bit thunk
; as a huge pointer.
;
; @rdesc
; 
; Returns a DWORD of tiling information, or 0 if the tiling could not be completed.
; The tiling information consists of a 16 bit selector in the high word and the
; number of tiled selectors in the low word. To make a 16:16 pointer to the 
; block of memory, mask the low 16 bits of the tiling information to zero.
;
; @parm DWORD | dwFlatMemory | The linear address of the memory to tile
;
; @parm DWORD | dwLength | The length in bytes of the region to tile
;
align
dmTileBuffer proc far16 public,
        dwFlatMemory:dword, dwLength:dword
        
        push    edi
        push    esi

        mov     eax, dwFlatMemory
        mov     ecx, dwLength
        call    TileBuffer
        mov     eax, ecx
        EAXtoDXAX

        pop     esi
        pop     edi
        ret
dmTileBuffer endp

;===========================================================================
;
; @func VOID | dmUntileBuffer | Untile a buffer
;
; @comm
;
; Free the tiled selectors allocated by dmTileBuffer. The buffer must have
; been previously tiles with <f dmTileBuffer>.
;
; @parm DWORD | dwTilingInfo | The tiling info returned by a previous call 
; to <f dmTileBuffer>.
;
align
dmUntileBuffer proc far16 public,
        dwTilingInfo:dword

        push    esi
        push    edi
        mov     ecx, dwTilingInfo
        call    UntileBuffer
        pop     edi
        pop     esi
        ret
dmUntileBuffer endp

;===========================================================================
;
; @func VOID PASCAL |  InitializeCriticalSection | Initialize a critical section
;
; @comm
;
; Initialize the critical section to not-in.
;
; @parm LPWORD | lpwCritSect | The critical section to initialize.
;
align
InitializeCriticalSection proc far16 public,
        lpwCritSect:dword

        push    es
        push    di

        les     di, [lpwCritSect]
        mov     word ptr es:[di], 1

        pop     di
        pop     es
        ret

InitializeCriticalSection endp

;===========================================================================
;
; @func WORD PASCAL | EnterCriticalSection | Enter a critical section
;
; @comm
;
; If fBlocking is set, then spin until we can get the critical section.
; Otherwise, return failure if we could not get it. 
;
; @rdesc
; Returns 
;  0 if we did not get the critical section
;  A non-zero ID if we did get the critical section
;
; @parm LPWORD | lpwCritSect | A pointer to the critical section to enter
; @parm WORD | fBlocking | A flag to indicate that the function should block if the 
; critical section is not immediately available
;
align
EnterCriticalSection proc far16 public,
        lpwCritSect:dword,
        fBlocking:word
        
        push    es
        push    di

        les     di, [lpwCritSect]       ; -> critical section
        mov     cx, [fBlocking]

ecs_check:
        dec     word ptr es:[di]        ; 1 -> 0 means we got it
                                        ; atomic on non-MP 
        jz      short ecs_success

        inc     word ptr es:[di]        ; Return to previous state

        or      cx, cx                  ; Blocking?
        jnz     short ecs_check         ; Yes

        xor     ax, ax                  ; Non-blocking and failed
        jmp     ecs_done

ecs_success: 
        mov     ax, 1

ecs_done:
        pop     di
        pop     es
        ret

EnterCriticalSection endp

;===========================================================================
;
; @func VOID PASCAL | LeaveCriticalSection | Leave a critical section
;
; @comm
;
; Leave the critical section. wCritSectID must be the critical section ID returned
; by the matching call to <f EnterCriticalSection> (used to verify nesting in debug
; versions).
;
; @parm LPWORD | lpwCritSect | The critical section to leave
;
align
LeaveCriticalSection proc far16 public,
        lpwCritSect:dword
                
        push    es
        push    di

        les     di, [lpwCritSect]       ; -> critical section
        inc     word ptr es:[di]        ; Reset to default value of 1

        pop     di
        pop     es
        ret

LeaveCriticalSection endp

;===========================================================================
;
; @func WORD PASCAL | DisableInterrupts | Disable interrupts
;
; @comm
;
; Disable interrupts and return the previous status for a call to
; <f RestoreInterrupts>
; 
; @rdesc
;
; Returns the previous state of the interrupt flag
;
;
DisableInterrupts proc far16 public
        
        pushf
        pop     ax                      ; Get state
        and     ax, 0200h               ; Already disabled?
        jz      short @F                ; Don't do it again
        cli
@@:
        ret

DisableInterrupts endp

;===========================================================================
;
; @func VOID PASCAL | RestoreInterrupts | Restore the interrupt state
;
; @comm
;
; Restore interrupts if they were enabled when <f DisableInterrupts> was
; called.
;
; @parm WORD | wIntStat | The previous interrupt state as returned from a 
; call to <f DisableInterrupts> 
;
RestoreInterrupts proc far16 public,
        wIntStat : word
        
        mov     ax, [wIntStat]          ; Previous state
        test    ax, 0200h               ; Enabled before?
        jz      short @F                ; No, don't re-enable now
        sti
@@:
        ret

RestoreInterrupts endp

;===========================================================================
;
; @func WORD PASCAL | InterlockedIncrement | Increment the given word
; atomically and return the result.
;
; @comm
;
; Disable interrupts to guarantee increment-and-read as an atomic 
; operation.
;
; @parm LPWORD | lpw | The word to increment.
;
InterlockedIncrement proc far16 public,
        lpw : dword
        
        pushf
        pop     cx
        test    cx, 0200h               ; Were interrupts enabled?
        jz      @F                      ; No
        cli                             ; Yes, disable
@@:
        les     bx, [lpw]   
        inc     word ptr es:[bx]
        mov     ax, word ptr es:[bx]

        test    cx, 0200h               ; Were interrupts enabled?
        jz      @F                      ; No
        sti                             ; Yes, reenable
@@:
        ret

InterlockedIncrement endp

;===========================================================================
;
; @func WORD PASCAL | InterlockedDecrement | Decrement the given word
; atomically and return the result.
;
; @comm
;
; Disable interrupts to guarantee decrement-and-read as an atomic 
; operation.
;
; @parm LPWORD | lpw | The word to decrement.
;
InterlockedDecrement proc far16 public,
        lpw : dword
        
        pushf
        pop     cx
        test    cx, 0200h               ; Were interrupts enabled?
        jz      @F                      ; No
        cli                             ; Yes, disable
@@:
        les     bx, [lpw]   
        dec     word ptr es:[bx]
        mov     ax, word ptr es:[bx]

        test    cx, 0200h               ; Were interrupts enabled?
        jz      @F                      ; No
        sti                             ; Yes, reenable
@@:
        ret

InterlockedDecrement endp

;===========================================================================
;
; @func void PASCAL | QuadwordMul | Multiply using 64-bit precision
;
; @comm
;
; Multiply the two 32-bit numbers in <p m1> and <p m2> giving a 64-bit result
; in <p lpqwResult>.
;
; @rdesc 
; Returns m1 * m2
;
; @parm DWORD | m1 | First multiplicand
; @parm DWORD | m2 | Second multiplicand
; @parm LPQUADWORD | lpqwResult | 64-bit result
;
QuadwordMul proc far16 public,
        m1 : dword,
        m2 : dword,
        lpqwResult : dword

        mov     edx, [m1]
        mov     eax, [m2]
        mul     edx

        les     bx, [lpqwResult]
        mov     es:[bx.qwLow], eax
        mov     es:[bx.qwHigh], edx

        ret
QuadwordMul endp

;===========================================================================
;
; @func DWORD PASCAL | QuadwordDiv | Divide using 64-bit precision
;
; @comm
;
; Divide the 64-bit number in <p ull> by the 32-bit number in <p dwDivisor> and
; return the result. May throw a divide by zero exception.
;
; @rdesc 
; Returns ull / dwDivisor
;
; @parm QUADWORD | ull | The unsigned long dividend
; @parm DWORD | dwDivisor | The divisor
;
;
QuadwordDiv proc far16 public,
        qwDividend : QUADWORD,
        dwDivisor : dword

        mov     edx, [qwDividend.qwHigh]
        mov     eax, [qwDividend.qwLow]
        mov     ebx, [dwDivisor]
        
        div     ebx
        
        ; Result in eax, needs to be dx:ax for 16-bit code

        ror     eax, 16
        mov     dx, ax
        ror     eax, 16
        
        ret
QuadwordDiv endp

;===========================================================================
;
; @func DWORD PASCAL | QuadwordLT | Compare two quadwords for less than (unsigned)
;
; @rdesc 
; Returns TRUE if qwLValue < qwRValue
;
; @parm QUADWORD | qwLValue | The first operand of less-than
; @parm QUADWORD | qwRValue | The second operand of less-than
;
;
QuadwordLT proc far16 public,
		qwLValue : QUADWORD,
		qwRValue : QUADWORD

		mov		ebx, [qwLValue.qwHigh]
		sub		ebx, [qwRValue.qwHigh]
		jz 		short @F
		sbb		eax, eax
		ret
		
@@:		mov		ebx, [qwLValue.qwLow]
		sub		ebx, [qwRValue.qwLow]
		sbb		eax, eax
		ret			
QuadwordLT endp
         
;===========================================================================
;
; @func DWORD PASCAL | QuadwordAdd | Add two unsigned quadwords
;
; @parm QUADWORD | qwOp1 | The first operand 
; @parm QUADWORD | qwOp2 | The second operand
; @parm LPQUADWORD | lpwqResult | The result
;
;
QuadwordAdd proc far16 public,
		qwOp1 : QUADWORD,
		qwOp2 : QUADWORD,
		lpdwResult : DWORD

		mov		eax, [qwOp1.qwLow]
		add		eax, [qwOp2.qwLow]
		mov		edx, [qwOp1.qwHigh]
		adc		edx, [qwOp2.qwHigh]
		les		bx, [lpdwResult]
		mov		es:[bx.qwLow], eax
		mov		es:[bx.qwHigh], edx

		ret			
QuadwordAdd endp

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic16\dmusic16.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
/* @Doc DMusic16
 *
 * @Module DMusic16.h - Internal definitions for DMusic16.DLL |
 */

#ifndef __DMUSIC16__
#define __DMUSIC16__

#undef  WINAPI                                 
#define WINAPI            _loadds FAR PASCAL   

#ifdef WIN32
   #define  BCODE
   #define  BSTACK
#else
   #define  BCODE                   __based(__segname("_CODE"))
   #define  BSTACK                  __based(__segname("_STACK"))
#endif

/* Make symbols show up in debug builds
 */
#ifdef DEBUG
#define STATIC 
#else
#define STATIC static
#endif

/* MIDI defines 
 */
#define MIDI_CHANNELS           16
 

#define SZCODE const char BCODE

/* Quadword alignment for event lengths in DMEVENT's
 */
#define QWORD_ALIGN(x) (((x) + 7) & ~7)         /* Next highest */

#define QWORD_TRUNC(x) ((x) & ~7)               /* Next lowest */

/* Multiplier to convert between reftime and milliseconds
 */
#define REFTIME_TO_MS (10L*1000L)


/* Number of events we want in the capture pool. Based on about a second's worth of high
 * concentration data
 */
#define CAP_HIGHWATERMARK 1024

/* How often user-mode timer ticks happen (milliseconds)
 */
#define MS_USERMODE 1000

/* Typedefs for everyone. Woohoo!
 */
typedef struct QUADWORD       QUADWORD;
typedef struct QUADWORD NEAR *NPQUADWORD;
typedef struct QUADWORD FAR  *LPQUADWORD;

typedef struct LINKNODE       LINKNODE;
typedef struct LINKNODE NEAR *NPLINKNODE;
typedef struct LINKNODE FAR  *LPLINKNODE;

typedef struct DMEVENT       DMEVENT;
typedef struct DMEVENT NEAR *NPDMEVENT;
typedef struct DMEVENT FAR  *LPDMEVENT;

typedef struct EVENT       EVENT;
typedef struct EVENT NEAR *NPEVENT;
typedef struct EVENT FAR  *LPEVENT;

typedef struct EVENTQUEUE       EVENTQUEUE;
typedef struct EVENTQUEUE NEAR *NPEVENTQUEUE;
typedef struct EVENTQUEUE FAR  *LPEVENTQUEUE;

typedef struct OPENHANDLEINSTANCE        OPENHANDLEINSTANCE;
typedef struct OPENHANDLEINSTANCE NEAR *NPOPENHANDLEINSTANCE;
typedef struct OPENHANDLEINSTANCE FAR  *LPOPENHANDLEINSTANCE;

typedef struct OPENHANDLE       OPENHANDLE;
typedef struct OPENHANDLE NEAR *NPOPENHANDLE;
typedef struct OPENHANDLE FAR  *LPOPENHANDLE;

typedef struct THRUCHANNEL       THRUCHANNEL;
typedef struct THRUCHANNEL NEAR *NPTHRUCHANNEL;
typedef struct THRUCHANNEL FAR  *LPTHRUCHANNEL;

/* 64-bit integer used w/ assembly helpers
 */
struct QUADWORD
{
    DWORD dwLow;
    DWORD dwHigh;
};

/* @struct Holds things in doubly linked lists
 */ 
struct LINKNODE {
    NPLINKNODE pPrev;           /* @field NPLINKNODE | pPrev |
                                   Pointer to the previous node in the list */
    
    NPLINKNODE pNext;           /* @field NPLINKNODE | pNext |
                                   Pointer to the next node in the list */
};

/* @struct DirectMusic event as packed by IDirectMusic
 */
struct DMEVENT {
    DWORD cbEvent;              /* @field DWORD | cbEvent |
                                   Unrounded number of event bytes */
    
    DWORD dwChannelGroup;       /* @field DWORD | dwChannelGroup |
                                   This field determines which channel group (set of 16 MIDI channels) receives the event. */

    QUADWORD rtDelta;			/* @field QUADWORD | rtDelta | Offset from buffer header in 100 ns units */
    
    DWORD dwFlags;              /* @field DWORD | dwFlags | DMEVENT_xxx */
    
    BYTE  abEvent[0];           /* @field BYTE | abEvent[] |
                                   Actual event data, rounded up to be an even number 
                                   of QWORD's (8 bytes) */
};

                                /* Total size of an event needed to hold cb bytes of data */
                                
#define DMEVENT_SIZE(cb) QWORD_ALIGN(sizeof(DMEVENT) + (cb))      

                                /* If we have cb for event + data, how much data can we fit? */
                                
#define DMEVENT_DATASIZE(cb) (QWORD_TRUNC(cb) - sizeof(DMEVENT))

#define DMEVENT_STRUCTURED  0x00000001

#define EVENT_F_MIDIHDR     0x0001

/* @struct Event as stored in an <c EVENTQUEUE>.
 */
struct EVENT {
    LPEVENT lpNext;             /* @field LPEVENT | lpNext |
                                   Next event in queue */
    
    DWORD msTime;               /* @field DWORD | msTime |
                                   Absolute ms time in stream time (i.e. timeSetEvent) */

    QUADWORD rtTime;			/* @field QUADWORD | rtTime |
								   Absolute time in 100ns units relative to reference clock. Use for sorting event queue. */
    
    WORD  wFlags;               /* @field WORD | wFlags |
                                   A bitwise combination of the following flags: 
                                   @flag EVENT_F_MIDIHDR | The event data starts with a MIDIHDR */
    
    WORD  cbEvent;              /* @field WORD | cbEvent |
                                   The unrounded number of bytes in the event data */
    
    BYTE  abEvent[0];           /* @field BYTE | abEvent[] |
                                   The actual event data, rounded up to be an even number of DWORD's */
};

/* @struct A queue of <c EVENT> structs.
 *
 * @comm
 * This is not the same as the generic list in list.c because we don't need
 * the overhead of a prev pointer here and we don't need the overhead of a far
 * pointer there.
 */
struct EVENTQUEUE {
    LPEVENT pHead;              /* @field LPEVENT | pHead | Pointer to the first event */
    LPEVENT pTail;              /* @field LPEVENT | pTail | Pointer to the last event */
    UINT    cEle;               /* @field UINT | cEle | The number of events currently in queue */
};

/* @struct An instance of an open device
 *
 * @comm
 *
 * Since multiple Win32 processes can hold a single MMSYSTEM handle open,
 * we need to track them. There is one of these structs per Win32 client
 * per open handle. It simply refers to the OPENHANDLE which contains
 * all the actual handle data.
 *
 */
struct OPENHANDLEINSTANCE {
    LINKNODE link;               /* @field LINKNODE | link | Holds this handle in gOpenHandleInstanceList */
    LINKNODE linkHandleList;     /* @field LINKNODE | linkHandleList |
                                    Holds this handle in the list maintained in the <c OPENHANDLE> struct for this device. */
                                    
    NPOPENHANDLE pHandle;        /* @field NPOPENHANDLE | pHandle |
                                    Pointer to the <c OPENHANDLE> struct for this device. */
    
    DWORD dwVxDEventHandle;      /* @field DWORD | dwVxDEventHandle |
                                    VxD Event handle for signalling input on this device for this client. */

    BOOL fActive;                /* @field BOOL | fActive | Indicates if the port is active or not. This is used for per-instance
                                    focus management. If the port is flagged as inactive, then the underlying device is not opened. */

    WORD wTask;                  /* @field WORD | wTask | Task which opened the handle. This is used to clean up if the task
                                    terminates abnormally. */

    NPTHRUCHANNEL pThru;         /* @field NPTHRUCHANNEL | pThru If an input device, an array of 16 thru
                                    entries, one per input channel. */
};

/* OPENHANDLE.wFlags
 */
#define OH_F_MIDIIN  0x0001     /* This is a MIDI input device */
#define OH_F_CLOSING 0x0002     /* This device is being closed */
#define OH_F_SHARED  0x0004     /* This device is shareable */

/* @struct An open device
 *
 * @comm
 *
 * There is a one-to-one relationship between open handles and <c OPENHANDLE> structs.
 *
 * All of the following event queues are either
 *  Protected - means it is accessible at callback time and user time, and is
 *              protected by wCritSect
 *  Callback  - Means it is unprotected by a critical section and is only accessible
 *              at callback time. Callbacks, per handle, are not reentered.
 *
 * In the MIDI in callback, we *cannot* just go away if we don't get wCritSect,
 * as we can on output. Hence the multiple input queues below.
 *
 * When the user mode refill algorithm runs, it puts events in qFree, protected
 * by the critical section. (The one exception to this is preloading qFreeCB before
 * midiInStart is called on the handle). When the callback runs, it tried to get the
 * critical section. If it can, it moves the free events from qFree to qFreeCB.
 *
 * In any case, the callback can now use qFreeCB even if it didn't get the critical
 * section. It pulls a free event from the queue, fills it, and puts it back onto
 * the tail of qDoneCB. If the critical section is held, it then transfers the
 * entire contents of qDoneCB to qDone.
 *
 * These transfers are not time consuming; they are merely the manipulation of
 * a couple of pointers.
 */
struct OPENHANDLE {
    LINKNODE link;              /* @field LINKNODE | link |
                                   Holds this handle in gOpenHandles */

    NPLINKNODE pInstanceList;   /* @field NPLINKLINK | pInstanceList |
                                   Points to the first element in the list of open handle instances using
                                   this device. */
    
    UINT uReferenceCount;       /* @field UINT | uReferenceCount |
                                   The number of clients using this device; i.e., the number of elements in the
                                   pInstanceList. */
    UINT uActiveCount;          /* @field UINT | uActiveCount |
                                   The number of clients that have activated this device */                                   

    UINT id;                    /* @field UINT | id | The MMSYSTEM device ID of this device */
    WORD wFlags;                /* @field WORD | wFlags | Some combination of the following flags:
                                   @flag OH_F_MIDIIN | This device is a MIDI input device
                                   @flag OH_F_CLOSING | This device is being closed. 
                                   @flag OH_F_SHARE | This device is opened in shared mode */
    
    HMIDIOUT hmo;               /* @field HMIDIOUT | hmo | MIDI output handle if an output device */
    HMIDIIN  hmi;               /* @field HMIDIIN | hmi | MIDI input handle if an input device */

    WORD wCritSect;             /* @field WORD | wCritSect | Critical section protecting protected queues */
    DWORD msStartTime;          /* @field DWORD | msStartTime | <f timeGetTime()> Time we started input */
    
    EVENTQUEUE qPlay;           /* @field EVENTQUEUE | qPlay |
                                   Output: Queue of events to play (protected) */
    
    EVENTQUEUE qDone;           /* @field EVENTQUEUE | qDone |
                                   Input/Output: Events already done (played or received) (protected) */

    EVENTQUEUE qFree;           /* @field EVENTQUEUE | qFree |
                                   Input: Queue of free events (protected) */
                                   
    EVENTQUEUE qFreeCB;         /* @field EVENTQUEUE | qFreeCB |
                                   Input: Queue of free events used by callback */
     
    EVENTQUEUE qDoneCB;         /* @field EVENTQUEUE | qDoneCB |
                                   Input: Queue of received events used by callback */
                                   
    WORD wPostedSysExBuffers;   /* @field WORD | cPostedSysExBuffers |
                                   Input: Buffers posted in MMSYSTEM for recording SysEx */                                           
};

#define CLASS_MIDI              0 /* dwEventClass */

/* Close to our page size
 */
#define SEG_SIZE 4096
#define C_PER_SEG ((SEG_SIZE - sizeof(SEGHDR)) / (sizeof(EVENT) + sizeof(DWORD)))

#define SEG_F_4BYTE_EVENTS 0x0001

typedef struct SEGHDR SEGHDR;
typedef struct SEGHDR FAR * LPSEGHDR;

/* @struct The header for one segment of allocated memory
 */
struct SEGHDR {
    WORD selNext; /* @field WORD | selNext |
                     The selector of the next block of memory in the allocated list */
    
    WORD hSeg;    /* @field WORD | hSeg |
                     The global handle of the memory block */
    
    WORD wFlags;  /* @field WORD | wFlags |
                     A bitwise combination of the following flags:
                     
                     @flag SEG_F_4BYTE_EVENTS | This segment contains multiple 
                     channel messages */
    
    WORD cbSeg;   /* @field WORD | cbSeg |
                     The size of the segment, less the <c SEGHDR> */
};

/* @struct Thru information for one channel
 *
 * @comm 
 *
 * Each input device handle instance contains an array of 16 of these structures containing
 * the thru destination for data that arrives on that channel.
 *
 */
struct THRUCHANNEL {
    WORD wChannel;              /* @field WORD | wChannel | The destination channel */
    NPOPENHANDLEINSTANCE pohi;  /* @field NPOPENHANDLEINSTANCE | pohi | The output handle instance
                                   to receive the thru'ed data. */
}; 

/* globals */
extern HINSTANCE ghInst;
extern NPLINKNODE gOpenHandleInstanceList;
extern NPLINKNODE gOpenHandleList;
extern UINT gcOpenInputDevices;
extern UINT gcOpenOutputDevices;

/* device.c */
#define VA_F_INPUT  0x0001
#define VA_F_OUTPUT 0x0002
#define VA_F_EITHER (VA_F_INPUT | VA_F_OUTPUT)

extern VOID PASCAL DeviceOnLoad(VOID);
extern MMRESULT PASCAL CloseLegacyDeviceI(NPOPENHANDLEINSTANCE pohi);
extern MMRESULT PASCAL ActivateLegacyDeviceI(NPOPENHANDLEINSTANCE pohi, BOOL fActivate);

extern BOOL PASCAL IsValidHandle(HANDLE h, WORD wType, NPOPENHANDLEINSTANCE FAR *lppohi);
extern VOID PASCAL CloseDevicesForTask(WORD wTask);


/* list.c */
extern VOID PASCAL ListInsert(NPLINKNODE *pHead, NPLINKNODE pNode);
extern VOID PASCAL ListRemove(NPLINKNODE *pHead, NPLINKNODE pNode);

/* eventq.c */
extern VOID PASCAL QueueInit(NPEVENTQUEUE pQueue);
extern VOID PASCAL QueueAppend(NPEVENTQUEUE pQueue, LPEVENT pEvent);
extern VOID PASCAL QueueCat(NPEVENTQUEUE pDest, NPEVENTQUEUE pSource);
extern LPEVENT PASCAL QueueRemoveFromFront(NPEVENTQUEUE pQueue);

#define QUEUE_FILTER_KEEP   (0)
#define QUEUE_FILTER_REMOVE (1)

typedef int (PASCAL *PFNQUEUEFILTER)(LPEVENT pEvent, DWORD dwInstance);
extern VOID PASCAL QueueFilter(NPEVENTQUEUE pQueue, DWORD dwInstance, PFNQUEUEFILTER pfnFilter);
extern LPEVENT PASCAL QueuePeek(NPEVENTQUEUE pQueue);

#ifdef DEBUG
#define AssertQueueValid(pQueue) _AssertQueueValid((pQueue), __FILE__, __LINE__)
extern VOID PASCAL _AssertQueueValid(NPEVENTQUEUE pQueue, LPSTR pstrFile, UINT uLine);
#else
#define AssertQueueValid
#endif

/* locks.c */
#define LOCK_F_INPUT  0x0001
#define LOCK_F_OUTPUT 0x0002
#define LOCK_F_COMMON 0x0004
extern VOID PASCAL LockCode(WORD wFlags);
extern VOID PASCAL UnlockCode(WORD wFlags);

/* dmhelp.asm */
extern VOID PASCAL InitializeCriticalSection(LPWORD lpwCritSect);

#define CS_NONBLOCKING  (0)
#define CS_BLOCKING     (1)
extern WORD PASCAL EnterCriticalSection(LPWORD lpwCritSect, WORD fBlocking);
extern VOID PASCAL LeaveCriticalSection(LPWORD lpwCritSect);
extern WORD PASCAL DisableInterrupts(VOID);
extern VOID PASCAL RestoreInterrupts(WORD wIntStat);
extern WORD PASCAL InterlockedIncrement(LPWORD pw);
extern WORD PASCAL InterlockedDecrement(LPWORD pw);

extern DWORD PASCAL QuadwordDiv(QUADWORD qwDividend, DWORD dwDivisor);
extern VOID PASCAL QuadwordMul(DWORD m1, DWORD m2, LPQUADWORD qwResult);
extern BOOL PASCAL QuadwordLT(QUADWORD qwLValue, QUADWORD qwRValue);
extern VOID PASCAL QuadwordAdd(QUADWORD qwOp1, QUADWORD qwOp2, LPQUADWORD lpqwResult);

/* alloc.c */
extern VOID PASCAL AllocOnLoad(VOID);
extern VOID PASCAL AllocOnExit(VOID);
extern LPEVENT PASCAL AllocEvent(DWORD msTime, QUADWORD rtTime, WORD cbEvent);
extern VOID PASCAL FreeEvent(LPEVENT lpEvent);

/* midiout.c */
extern VOID PASCAL MidiOutOnLoad(VOID);
extern VOID PASCAL MidiOutOnExit(VOID);
extern MMRESULT PASCAL MidiOutOnOpen(NPOPENHANDLEINSTANCE pohi);
extern VOID PASCAL MidiOutOnClose(NPOPENHANDLEINSTANCE pohi);
extern MMRESULT PASCAL MidiOutOnActivate(NPOPENHANDLEINSTANCE pohi);
extern MMRESULT PASCAL MidiOutOnDeactivate(NPOPENHANDLEINSTANCE pohi);
extern VOID PASCAL SetOutputTimerRes(BOOL fOnOpen);
extern VOID PASCAL FreeDoneHandleEvents(NPOPENHANDLE poh, BOOL fClosing);
extern VOID PASCAL MidiOutThru(NPOPENHANDLEINSTANCE pohi, DWORD dwMessage);

/* midiin.c */
extern VOID PASCAL MidiInOnLoad(VOID);
extern VOID PASCAL MidiInOnExit(VOID);
extern MMRESULT PASCAL MidiInOnOpen(NPOPENHANDLEINSTANCE pohi);
extern VOID PASCAL MidiInOnClose(NPOPENHANDLEINSTANCE pohi);
extern MMRESULT PASCAL MidiInOnActivate(NPOPENHANDLEINSTANCE pohi);
extern MMRESULT PASCAL MidiInOnDeactivate(NPOPENHANDLEINSTANCE pohi);
extern VOID PASCAL MidiInRefillFreeLists(VOID);
extern VOID PASCAL MidiInUnthruToInstance(NPOPENHANDLEINSTANCE pohi);
extern VOID PASCAL FreeAllQueueEvents(NPEVENTQUEUE peq);

/* mmdevldr.asm */
extern MMRESULT CDECL SetWin32Event(DWORD dwVxDEvent); /* Must be CDECL! */

/* timerwnd.c */
extern BOOL PASCAL CreateTimerTask(VOID);
extern VOID PASCAL DestroyTimerTask(VOID);




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic16\list.c ===
/* Copyright (c) 1998 Microsoft Corporation */
/*
 * @DOC DMusic16
 *
 * @MODULE List.c - Generic list management |
 */

#include <windows.h>
#include <mmsystem.h>

#include "dmusic16.h"
#include "debug.h"

#ifdef DEBUG
STATIC BOOL PASCAL IsNodeInList(NPLINKNODE pHead, NPLINKNODE pNode);
#endif

/* @func Insert a node into a linked list.
 *
 */
VOID PASCAL
ListInsert(
    NPLINKNODE *pHead,      /* @parm A pointer to the list head */
    NPLINKNODE pNode)       /* @parm A pointer to the node to insert */
{
    assert(!IsNodeInList(*pHead, pNode));
    
    if (*pHead)
    {
        (*pHead)->pPrev = pNode;
    }

    pNode->pNext = *pHead;
    pNode->pPrev = NULL;
    *pHead = pNode;
}

/* @func Remove a node into a linked list.
 *
 * @comm
 *
 * The node must exist in the list. The debug version which check for this.
 */
VOID PASCAL
ListRemove(
    NPLINKNODE *pHead,      /* @parm A pointer to the list head */
    NPLINKNODE pNode)       /* @parm A pointer to the node to delete */
{
    assert(IsNodeInList(*pHead, pNode));

    if (pNode->pPrev)
    {
        pNode->pPrev->pNext = pNode->pNext;
    }
    else
    {
        *pHead = pNode->pNext;
    }

    if (pNode->pNext)
    {
        pNode->pNext->pPrev = pNode->pPrev;
    }
}


#ifdef DEBUG
/* @func Determine if a node is in a linked list.
 *
 */
STATIC BOOL PASCAL
IsNodeInList(
    NPLINKNODE pHead,       /* @parm A pointer to the first node in the list */
    NPLINKNODE pNode)       /* @parm A pointer to the node to look for in the list */
{
    for (; pHead; pHead = pHead->pNext)
    {
        if (pHead == pNode)
        {
            return TRUE;
        }
    }

    return FALSE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic16\dmusic16.c ===
/* Copyright (c) 1998 Microsoft Corporation */
/*
 * @Doc DMusic
 *
 * @Module DMusic16.c - Startup code |
 *
 * 16-bit Dll for DirectMusic sequencing on legacy devices (Win95/Win98 non-WDM drivers)
 *
 * This Dll is the 16-bit thunk peer for DMusic32.Dll
 *
 * @globalv HINSTANCE | ghInst | The instance handle for the DLL.
 *
 */

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>

#include "dmusic16.h"
#include "debug.h"

HINSTANCE ghInst;
HDRVR ghDrvr;
UINT guReferenceCount = 0;

/* @func LibMain system entry point
 *
 * @comm
 *
 * This entry point is called when the DLL is first loaded (NOT every time).
 *
 * Saves the global instance handle and initializes all the other modules.
 *
 */
int PASCAL
LibMain(
    HINSTANCE   hInst,              /* @parm Instance handle for the DLL */
    WORD        cbHeap,             /* @parm Initial size of the local heap */
    LPSTR       lpszCmdLine)        /* @parm Command-line parameters */
{
    UINT        uLev;
    char        szFilename[260];

    if (GetModuleFileName(hInst, szFilename, sizeof(szFilename)))
    {
        DPF(2, "%s", (LPSTR)szFilename);
    }

    ghDrvr = OpenDriver(szFilename, NULL, 0L);
               
    DPF(1, "DMusic16.DLL task %04X hdrvr %04X", GetCurrentTask(), (WORD)ghDrvr);


    ghInst = hInst;
    uLev = DbgInitialize(TRUE);
    DPF(0, "DMusic16: Debug level is %u", uLev);

    if (uLev > 2)
    {
        DPF(0, "DMusic16: Break in LibMain");
        DebugBreak();
    }
    
    DeviceOnLoad();
    AllocOnLoad();
    MidiOutOnLoad();

#if 0
    // This causes problems at terminate time. Find out later if we really need it.
    //
    if (!CreateTimerTask())
    {
        DPF(0, "CreateTimerTask() failed");
    }


    if (NULL == (LoadLibrary("dmusic16")))
    {
        DPF(0, "Could not LoadLibrary ourselves!");
    }
#endif

    return 1;
}

/* @func LibExit system call
 *
 * @comm
 *
 * This entry point is called just before the DLL is unloaded.
 *
 * Uninitialize all the other modules
 */

VOID PASCAL __loadds
LibExit(VOID)
{
    DPF(2, "LibExit start");
#if 0
    DestroyTimerTask();
#endif
    MidiOutOnExit();
    AllocOnExit();
    DPF(2, "LibExit end, going away now.");
}

extern BOOL FAR PASCAL dmthunk_ThunkConnect16(LPCSTR, LPCSTR, HINSTANCE, DWORD);
STATIC char pszDll16[] = "DMUSIC16.DLL";
STATIC char pszDll32[] = "DMUSIC.DLL";

/* @func DLLEntryPoint system entry point
 *
 * @comm
 *
 * This entry point is called each time the DLL is loaded or unloaded
 *
 * It is used here to initialize the peer connection for the thunk layer.
 */
#define PROCESS_DETACH          0
#define PROCESS_ATTACH          1

BOOL WINAPI
DllEntryPoint(
    DWORD       dwReason,           /* @parm Is the DLL being loaded or unloaded? */
    HINSTANCE   hi,                 /* @parm The instance handle */
    HGLOBAL     hgDS,               /* @parm The global handle of the DLL's (shared) DS */
    WORD        wHeapSize,          /* @parm The initial size of the local heap */
    LPCSTR      lszCmdLine,         /* @parm The command line (always NULL) */
    WORD        wCmdLine)           /* @parm Unused */
{
    // DllEntryPoint is called before LibEntry in a 4.x dll, so we have to LocalInit here if we're
    // going to use LocalAlloc
    //
    if (guReferenceCount == 0 && wHeapSize)
    {
        LocalInit(0, 0, wHeapSize);
    }

    switch(dwReason)
    {
        case PROCESS_ATTACH:
            DPF(2, "ProcessAttach task %04X", GetCurrentTask());
            ++guReferenceCount;
            dmthunk_ThunkConnect16(pszDll16, pszDll32, ghInst, 1);
            break;

        case PROCESS_DETACH:
            DPF(2, "ProcessDetach task %04X", GetCurrentTask());

            /* Clean up after them if they didn't close handles. We must do this here as well as
             * in DriverProc because on the last exit, we will go away before the DriverProc cleanup
             * gets called if the process termination is normal.
             */
            CloseDevicesForTask(GetCurrentTask());
            
            /* NOTE: We close on reference count of 1 since the initial OpenDriver call
               causes one more PROCESS_ATTACH to happen. */
            if (1 == --guReferenceCount)
            {
                CloseDriver(ghDrvr, 0, 0);
            }
            
            break;
    }

    return TRUE;
}

        
/* @func DriverProc entry point for ourselves as a loadable driver.
 *
 * @comm This entry points allows us to know when a task has gone away and therefore to clean
 * up after it even though we don't properly get notified that our thunk peer has gone away.
 */
LRESULT WINAPI DriverProc(
    DWORD               dwID,
    HDRVR               hdrvr,
    UINT                umsg,
    LPARAM              lParam1,
    LPARAM              lParam2)
{
    //
    //  NOTE DS is not valid here.
    //
    switch (umsg) 
    {
        case DRV_LOAD:
            return(1L);

        case DRV_FREE:
            return(0L);

        case DRV_OPEN:
        case DRV_CLOSE:
            return(1L);

        case DRV_EXITAPPLICATION:
            DPF(2, "Cleaning up handles for task %04X", GetCurrentTask());
            CloseDevicesForTask(GetCurrentTask());
            break;

        default:
            return(DefDriverProc(dwID, hdrvr, umsg, lParam1, lParam2));
    }
} //** DriverProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic16\libentry.asm ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   LIBENTRY.ASM
;
;   Copyright (c) 1989-1998 Microsoft Corporation
;
;   This module contains the entry point for MidiMap.dll
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        PMODE = 1

        include cmacros.inc                   

?PLM=1  ; pascal call convention
?WIN=0  ; Windows prolog/epilog code

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   extrns
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        externFP LibMain
        externFP LocalInit
        externFP LibExit

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   Code segment
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

;-----------------------------------------------------------------------;
;
; Stuff needed to avoid the C runtime coming in, and init the windows
; reserved parameter block at the base of DGROUP
;
sBegin  Data
assumes DS,Data

            DD  0               ; So null pointers get 0
maxRsrvPtrs = 5
            DW  maxRsrvPtrs
usedRsrvPtrs = 0
labelDP     <PUBLIC,rsrvptrs>

DefRsrvPtr  MACRO   name
globalW     name,0
usedRsrvPtrs = usedRsrvPtrs + 1
ENDM

DefRsrvPtr  pLocalHeap          ; Local heap pointer
DefRsrvPtr  pAtomTable          ; Atom table pointer
DefRsrvPtr  pStackTop           ; top of stack
DefRsrvPtr  pStackMin           ; minimum value of SP
DefRsrvPtr  pStackBot           ; bottom of stack

if maxRsrvPtrs-usedRsrvPtrs
            DW maxRsrvPtrs-usedRsrvPtrs DUP (0)
endif

public  __acrtused
        __acrtused = 1

sEnd        Data

sBegin  CodeSeg
        assumes cs,CodeSeg
        assumes ds,Data
        assumes es,nothing

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;       Library entry point
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;--------------------------Private-Routine-----------------------------;
;
; LibEntry - called when DLL is loaded
;
; Entry:
;       CX    = size of heap
;       DI    = module handle
;       DS    = automatic data segment
;       ES:SI = address of command line (not used)
;
; Returns:
;       AX = TRUE if success
; Error Returns:
;       AX = FALSE if error (ie fail load process)
; Registers Preserved:
;       SI,DI,DS,BP
; Registers Destroyed:
;       AX,BX,CX,DX,ES,FLAGS
; Calls:
;       None
; History:
;
;       06-27-89 -by-  Todd Laney [ToddLa]
;       Created.
;-----------------------------------------------------------------------;

cProc   LibEntry,<FAR,PUBLIC,NODATA>,<>
cBegin
        ;
        ; Push frame for LibMain (hModule,cbHeap,lpszCmdLine)
        ;
        push    di
        push    cx
        push    es
        push    si

        ;
        ; Init the local heap (if one is declared in the .def file)
        ;
        jcxz no_heap

        xor     ax,ax
        cCall   LocalInit,<ax,ax,cx>

no_heap:
        cCall   LibMain
cEnd

        assumes ds,nothing
        assumes es,nothing

cProc   WEP, <FAR, PUBLIC, PASCAL>, <>
        ParmW   fSystemExit
cBegin nogen
        mov     ax, fSystemExit
        cCall   LibExit, <ax>
        mov     ax, 1
        retf    2
cEnd   nogen

        sEnd CodeSeg

        end LibEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic16\equeue.c ===
/* Copyright (c) 1998 Microsoft Corporation */
/*
 * @DOC DMusic16
 *
 * @MODULE EQueue.c - Event queue routines |
 *
 * These routines maintain queues of events. It is expected that other routines will operate
 * directly on the queue. The following invariants must be maintained:
 *
 * If the queue is empty, then the head and tail pointers must be NULL and the element count must be zero.
 *
 * The queue must not contain circular links.
 *
 * An event may only be on one queue.
 *
 * The element count must be equal to the number of events in the queue.
 */
#include <windows.h>
#include <mmsystem.h>
#include <memory.h>

#include "dmusic16.h"
#include "debug.h"

/* @func Initialize an event queue to be empty
 *
 * @comm
 *
 * Any previous contents of the queue will be lost (NOT freed).
 */
VOID PASCAL
QueueInit(
    NPEVENTQUEUE pQueue)        /* @parm Pointer to the queue to initialize */
{
    DPF(4, "QueueInit(%04X)", (WORD)pQueue);
    
    pQueue->pHead = NULL;
    pQueue->pTail = NULL;
    pQueue->cEle  = 0;

    AssertQueueValid(pQueue);
}

/* @func Append an event to the end of the queue
 *
 */
VOID PASCAL
QueueAppend(
    NPEVENTQUEUE pQueue,        /* @parm Pointer to the queue */
    LPEVENT pEvent)             /* @parm Pointer to the event to tack on the end of the queue */
{
    DPF(4, "QueueAppend(%04X,%08lX)", (WORD)pQueue, (DWORD)pEvent);
    
    if (pQueue->cEle)
    {
        assert(pQueue->pHead);
        assert(pQueue->pTail);

        pQueue->pTail->lpNext = pEvent;
    }
    else
    {
        assert(NULL == pQueue->pHead);
        assert(NULL == pQueue->pTail);
        
        pQueue->pHead = pEvent;
    }
    
    pEvent->lpNext = NULL;
    pQueue->pTail = pEvent;
    ++pQueue->cEle;

    AssertQueueValid(pQueue);
}

/* @func Concatenate two queues
 *
 * @comm
 *
 * This function tacks the contents of <p pSrc> onto the end of <p pDest> in very short constant time.
 * <p pSrc> is left empty after the operation.
 */
VOID PASCAL
QueueCat(
    NPEVENTQUEUE pDest,     /* @parm The queue to receive new events */
    NPEVENTQUEUE pSrc)      /* @parm The queue which will lost all its events */
{
    DPF(4, "QueueCat(%04X,%04X)", (WORD)pDest, (WORD)pSrc);
    
    if (0 == pSrc->cEle)
    {
        assert(NULL == pSrc->pHead);
        assert(NULL == pSrc->pTail);

        return;
    }

    assert(pSrc->pHead);
    assert(pSrc->pTail);

    if (0 != pDest->cEle)
    {
        assert(pDest->pHead);
        assert(pDest->pTail);
        
        pDest->cEle += pSrc->cEle;
        pDest->pTail->lpNext = pSrc->pHead;
        pDest->pTail = pSrc->pTail;
    }
    else
    {
        assert(NULL == pDest->pHead);
        assert(NULL == pDest->pTail);

        *pDest = *pSrc;
    }

    pSrc->pHead = NULL;
    pSrc->pTail = NULL;
    pSrc->cEle  = 0;
    
    AssertQueueValid(pDest);
    AssertQueueValid(pSrc);
}

/* @func Dequeue an element from the front of the queue
 *
 * @rdesc Returns an event pointer or NULL if the queue is empty
 *
 */
LPEVENT PASCAL
QueueRemoveFromFront(
    NPEVENTQUEUE pQueue)        /* @parm The queue to dequeue from */
{
    LPEVENT pEvent;
    
    DPF(4, "QueueRemoveFromFront(%04X)", (WORD)pQueue);

    if (0 == pQueue->cEle)
    {
        assert(NULL == pQueue->pHead);
        assert(NULL == pQueue->pTail);
        
        return NULL;
    }

    assert(pQueue->pHead);
    assert(pQueue->pTail);

    pEvent = pQueue->pHead;

    if (0 != --pQueue->cEle)
    {
        assert(pQueue->pHead != pQueue->pTail);
        
        pQueue->pHead = pQueue->pHead->lpNext;
    }
    else
    {
        assert(pQueue->pHead == pQueue->pTail);

        pQueue->pHead = NULL;
        pQueue->pTail = NULL;
    }

    AssertQueueValid(pQueue);

    return pEvent;
}

/* @func Enumerate the events in a queue, possibly deleting some or all of them
 *
 * @comm
 *
 * This function calls the function pointed to by <p pfnFilter> once for each event in
 * the queue, starting at the front and working towards the back.
 *
 * The function <p pfnFilter> may return one of two values:
 * @flag QUEUE_FILTER_KEEP | If the event is to be kept
 * @flag QUEUE_FILTER_REMOVE | If the event is to be removed from the queue
 */
VOID PASCAL
QueueFilter(
    NPEVENTQUEUE pQueue,        /* @parm The queue to enumerate */
    DWORD dwInstance,           /* @parm Instance data which will be passed to
                                   <p pfnFilter> on each call. */
    PFNQUEUEFILTER pfnFilter)   /* @parm The function to call with each event */
{
    LPEVENT pPrev;
    LPEVENT pCurr;
    LPEVENT pNext;

    DPF(4, "QueueFilter(%04X, %08lX, %08lX)", (WORD)pQueue, (DWORD)dwInstance, (DWORD)pfnFilter);

    pPrev = NULL;
    pCurr = pQueue->pHead;

    while (pCurr)
    {
        /* Callback is allowed to relink into another queue, so save the next
         * pointer now.
         */
        pNext = pCurr->lpNext;

        switch((*pfnFilter)(pCurr, dwInstance))
        {
            case QUEUE_FILTER_REMOVE:
                if (pPrev)
                {
                    pPrev->lpNext = pNext;
                }
                else
                {
                    pQueue->pHead = pNext;
                }

                if (pNext == NULL)
                {
                    pQueue->pTail = pPrev;
                }

                --pQueue->cEle;
                
                AssertQueueValid(pQueue);
                
                pCurr = pNext;
                break;

            case QUEUE_FILTER_KEEP:
                pPrev = pCurr;
                pCurr = pNext;
                break;
                
            default:
                assert(0);
        }
    }

    AssertQueueValid(pQueue);
}

/* @func Peek at the head of the event queue to see what's next
 *
 * @comm
 *
 * Non-destructively return the first event in the queue
 *
 * @rdesc
 * Returns the event pointer or NULL if the queue is empty
 */
LPEVENT PASCAL
QueuePeek(
    NPEVENTQUEUE pQueue)
{
    DPF(4, "QueuePeek(%04X)", (WORD)pQueue);
            
    return pQueue->pHead;
}

/* @func Look at the queue and make sure it's internally consistent.
 *
 * @comm
 *
 * Walk the queue and make sure it isn't circularly linked. Also make sure the count
 * is correct.
 *
 * Asserts into debugger if queue is corrupt.
 *
 * Called by the AssertQueueValid macro in debug builds.
 *
 * Disables interrupts to avoid false reports of corruption based on the queue changing under
 * the routine.
 *
 */
#ifdef DEBUG
void PASCAL
_AssertQueueValid(
    NPEVENTQUEUE pQueue,
    LPSTR szFile,
    UINT uLine)
{
    LPEVENT pEventSlow;
    LPEVENT pEventFast;
    UINT cEle;
    WORD wIntStat;
    BOOL fTrace = FALSE;

    wIntStat = DisableInterrupts();
    
    if (!pQueue)
    {
        DPF(0, "_AssertQueueValid %s@%u: Passed NULL!", szFile, uLine);
        assert(FALSE);
        goto cleanup;
    }

    pEventFast = pEventSlow = pQueue->pHead;

    cEle = 0;

    while (pEventSlow)
    {
        ++cEle;
        pEventSlow = pEventSlow->lpNext;
        
        if (pEventFast)
        {
            pEventFast = pEventFast->lpNext;
        }

        if (pEventFast)
        {
            pEventFast = pEventFast->lpNext;
        }
        
        if (pEventSlow && pEventFast && pEventSlow == pEventFast)
        {
            DPF(0, "_AssertQueueValid %s@%u: Queue %04X is circularly linked!",
                szFile,
                uLine,
                (WORD)pQueue);
            assert(FALSE);
            fTrace = TRUE;
            break;
        }
    }
    
    if (cEle != pQueue->cEle)
    {
        DPF(0, "_AssertQueueValid %s@%u: Queue %04X has incorrect element count!",
            szFile,
            uLine,
            (WORD)pQueue);
        assert(FALSE);
        fTrace = TRUE;
    }
    
    if ((pQueue->pHead && !pQueue->pTail) ||
        (pQueue->pTail && !pQueue->pHead))
    {
        DPF(0, "_AssertQueueValid %s@%u: Queue %04X head XOR tail is NULL!",
            szFile,
            uLine,
            (WORD)pQueue);
        assert(FALSE);
        fTrace = TRUE;
    }

    if (fTrace)
    {
        DPF(0, "Queue %04X: head %08lX tail %08lX count %u",
            (WORD)pQueue,
            (DWORD)pQueue->pHead,
            (DWORD)pQueue->pTail,
            (WORD)pQueue->cEle);
        
        for (pEventSlow = pQueue->pHead; pEventSlow; pEventSlow = pEventSlow->lpNext)
        {
            DPF(2, "  Event %08lX: lpNext %08lX msTime %lu wFlags %04X cbEvent %04X",
                (DWORD)pEventSlow,
                (DWORD)pEventSlow->lpNext,
                (DWORD)pEventSlow->msTime,
                (WORD)pEventSlow->wFlags,
                (WORD)pEventSlow->cbEvent);
        }
    }

cleanup:
    RestoreInterrupts(wIntStat);
}
#endif //DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic16\locks.c ===
/* Copyright (c) 1998 Microsoft Corporation */
/*
 * @Doc DMusic16
 *
 * @module locks.c - Manage page-locking the code which will be accessed via callbacks from MMSYSTEM |
 *
 */
#include <windows.h>
#include <mmsystem.h>
#include "dmusic16.h"
#include "debug.h"

#define SINTEXT     __segname("FIX_IN_TEXT")
#define SOUTTEXT    __segname("FIX_OUT_TEXT")
#define SCOMMTEXT   __segname("FIX_COMM_TEXT")
#define SDATA       __segname("_DATA")

static VOID PASCAL NEAR
ForcePresent(
    WORD wSegment)
{
    LPBYTE lpb = (LPBYTE)MAKELP(wSegment, 0);

    _asm 
    {
        les bx, [lpb]
        mov al, es:[bx]
    }
}


/* @func Page lock needed segments 
 *
 */
VOID PASCAL
LockCode(
    WORD wFlags)            /* @parm What to lock: Any combination of: */
                            /* @flag LOCK_F_INPUT  | To lock the MIDI input code segments */
                            /* @flag LOCK_F_OUTPUT | To lock the MIDI output code segments */
                            /* @flag LOCK_F_COMMON | To lock the common code segments */

{
    if (wFlags & LOCK_F_INPUT)
    {
        ForcePresent(SINTEXT);
        if (!GlobalSmartPageLock(SINTEXT))
        {
            DPF(0, "Could not lock input text");
        }
    }
    
    if (wFlags & LOCK_F_OUTPUT)
    {
        ForcePresent(SOUTTEXT);
        if (!GlobalSmartPageLock(SOUTTEXT))
        {
            DPF(0, "Could not lock output text");
        }
    }

    if (wFlags & LOCK_F_COMMON)
    {
        ForcePresent(SCOMMTEXT);
        if (!GlobalSmartPageLock(SCOMMTEXT))
        {
            DPF(0, "Could not lock common text");
        }

        ForcePresent(SDATA);
        if (!GlobalSmartPageLock(SDATA))
        {
            DPF(0, "Could not lock data segment");
        }
    }
}

/* @func Page unlock needed segments 
 *
 * @comm
 */
VOID PASCAL
UnlockCode(
    WORD wFlags)            /* @parm What to unlock: Any combination of: */
                            /* @flag LOCK_F_INPUT  | To unlock the MIDI input code segments */
                            /* @flag LOCK_F_OUTPUT | To unlock the MIDI output code segments */
                            /* @flag LOCK_F_COMMON | To unlock the common code segments */

{
    if (wFlags & LOCK_F_INPUT)
    {
        if (!GlobalSmartPageUnlock(SINTEXT))
        {
            DPF(0, "Could not unlock input text");
        }
    }
    
    if (wFlags & LOCK_F_OUTPUT)
    {
        if (!GlobalSmartPageUnlock(SOUTTEXT))
        {
            DPF(0, "Could not unlock output text");
        }
    }

    if (wFlags & LOCK_F_COMMON)
    {
        if (!GlobalSmartPageUnlock(SCOMMTEXT))
        {
            DPF(0, "Could not unlock common text");
        }

        if (!GlobalSmartPageUnlock(SDATA))
        {
            DPF(0, "Could not unlock data");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic16\locks.h ===
// Copyright (c) 1998 Microsoft Corporation
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic16\midiin.c ===
/* Copyright (c) 1998-1999 Microsoft Corporation */
/*
 * @Doc DMusic16
 *
 * @Module MIDIIn.c - Legacy MIDI capture emulation for DirectMusic |
 */
#pragma warning(disable:4704)       /* Inline assembly */

#include <windows.h>
#include <mmsystem.h>
#include <stddef.h>

#include "dmusic16.h"
#include "debug.h"

#define IS_STATUS_BYTE(x)     ((x) & 0x80)
#define IS_CHANNEL_MSG(x)     (((x) & 0xF0) != 0xF0)
#define IS_SYSEX(x)           ((x) == 0xF0)

#define SYSEX_SIZE            4096  
                            /* (65535 - sizeof(MIDIHDR) - sizeof(EVENT) - sizeof(SEGHDR)) */
#define SYSEX_BUFFERS         8                     /* Keep 2 buffers outstanding */

static unsigned cbChanMsg[16] =
{
    0, 0, 0, 0, 0, 0, 0, 0, /* Running status */
    3, 3, 3, 3, 2, 2, 3, 0
};

static unsigned cbSysCommData[16] =
{
    1, 2, 3, 2, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1
};

VOID CALLBACK _loadds midiInProc(HMIDIIN hMidiIn, UINT wMsg, DWORD dwInstance, DWORD dwParam1, DWORD dwParam2);
STATIC BOOL NEAR PASCAL RecordShortEvent(NPOPENHANDLE poh, DWORD dwMessage, DWORD dwTime);
STATIC BOOL NEAR PASCAL RecordSysExEvent(NPOPENHANDLE poh, LPMIDIHDR lpmh, DWORD dwTime);
STATIC VOID NEAR PASCAL NotifyClientList(LPOPENHANDLE poh);
STATIC VOID NEAR PASCAL ThruClientList(LPOPENHANDLE poh, DWORD dwMessage);
STATIC VOID NEAR PASCAL RefillFreeEventList(NPOPENHANDLE poh);
STATIC VOID NEAR PASCAL MidiInFlushQueues(NPOPENHANDLE poh);

#pragma alloc_text(INIT_TEXT, MidiOutOnLoad)
#pragma alloc_text(FIX_IN_TEXT, midiInProc)
#pragma alloc_text(FIX_IN_TEXT, RecordShortEvent)
#pragma alloc_text(FIX_IN_TEXT, RecordSysExEvent)
#pragma alloc_text(FIX_IN_TEXT, NotifyClientList)
#pragma alloc_text(FIX_IN_TEXT, ThruClientList)

/* @func Called at DLL <f LibInit>
 *
 * @comm
 *
 * Currently does nothing.
 *
 */
VOID PASCAL
MidiInOnLoad(VOID)
{
}

/* @func Called at DLL <f LibExit>
 *
 * @comm
 *
 * Currently does nothing
 */
VOID PASCAL
MidiInOnExit()
{
}

/* @func Open a MIDI in device
 *
 * @rdesc Returns one of the following:
 * @flag MMSYSERR_NOERROR | on success
 * @flag MMSYSERR_NOMEM | on out of memory
 *
 * @comm
 *
 * Makes sure only one client is opening the device.
 *
 * Opens the device and starts MIDI input on it, noting the time of the start for timestamp calculations.
 */
MMRESULT PASCAL
MidiInOnOpen(
    NPOPENHANDLEINSTANCE pohi)      /* @parm The open handle instance to fulfill */
{
    NPOPENHANDLE poh = pohi->pHandle;

    int iChannel;    
    MMRESULT mmr;

    /* Protect here against more than one client opening an input device.
     */
    if (poh->uReferenceCount > 1) 
    {
        return MMSYSERR_ALLOCATED;
    }
    
    /* Per client initialize thruing to NULL. 
     */
    pohi->pThru = (NPTHRUCHANNEL)LocalAlloc(LPTR, MIDI_CHANNELS * sizeof(THRUCHANNEL));
    if (pohi->pThru == NULL)
    {
        return MMSYSERR_NOMEM;
    }

    DPF(2, "MidiInOnOpen: pohi %04X pThru %04X", pohi, pohi->pThru);

    for (iChannel = 0; iChannel < MIDI_CHANNELS; iChannel++)
    {
        pohi->pThru[iChannel].pohi = (HANDLE)NULL;
    }

    return MMSYSERR_NOERROR;
}

/* @func Close a MIDI in device
 *
 * @comm
 *
 * Close the device using the <f midiInClose> API.
 */
VOID PASCAL
MidiInOnClose(
    NPOPENHANDLEINSTANCE pohi)      /* @parm The open handle instance to close */
{
}

/* @func Activate a MIDI in device
 *
 * @rdesc Returns one of the following:
 * @flag MMSYSERR_NOERROR | on success
 * @flag MMSYSERR_ALLOCATED | if the device is already in use
 *
 * May also return any of the possible return codes from the <f midiInOpen> API call.
 *
 * @comm
 *
 * Opens the device and starts MIDI input on it, noting the time of the start for timestamp calculations.
 */
MMRESULT PASCAL
MidiInOnActivate(
    NPOPENHANDLEINSTANCE pohi)
{
    NPOPENHANDLE poh = pohi->pHandle;

    MMRESULT mmr;

    if (1 == poh->uActiveCount)
    {
        poh->wFlags &= ~OH_F_CLOSING;
        mmr = midiInOpen(&poh->hmi,
                         poh->id,
                         (DWORD)midiInProc,
                         (DWORD)(LPOPENHANDLE)poh,
                         CALLBACK_FUNCTION);
        if (mmr)
        {
            return mmr;
        }

        mmr = midiInStart(poh->hmi);
        poh->msStartTime = timeGetTime();
        if (mmr)
        {   
            midiInClose(poh->hmi);
        }

        /* NOTE: poh memory is guaranteed zeroed by allocator, so we have
         * no event count and NULL pointers right now.
         */
        RefillFreeEventList(poh);
    }

    return MMSYSERR_NOERROR;
}

/* @func Deactivate a MIDI in device
 *
 * @comm
 *
 * Close the device using the <f midiInClose> API.
 */
MMRESULT PASCAL
MidiInOnDeactivate(
    NPOPENHANDLEINSTANCE pohi)
{
    NPOPENHANDLE poh = pohi->pHandle;

    MMRESULT mmr;

    if (0 == poh->uActiveCount)
    {
        poh->wFlags |= OH_F_CLOSING;
        mmr = midiInStop(poh->hmi);
        if (mmr)
        {
            return mmr;
        }

        if (MMSYSERR_NOERROR == midiInReset(poh->hmi))
        {
            while (poh->wPostedSysExBuffers)
            {
            }
        }

        midiInClose(poh->hmi);
        MidiInFlushQueues(poh);
    }

    return MMSYSERR_NOERROR;
}


/* @func Set the event handle to signal
 *
 * @rdesc Always returns MMSYSERR_NOERROR.
 *
 * @comm
 *
 * This function is exported through the thunk layer to DMusic32.DLL
 *
 * This handle is already the VxD handle that can be passed to VWin32 via MMDEVLDR using
 * <f SetWin32Event>.
 *
 * Input notification is delivered to the Win32 application using events. The application creates
 * an event using the <f CreateEvent> API and gives it to the DirectMusic port. The port code
 * for legacy emulation calls the undocumented Win9x kernel API <f OpenVxDHandle> to retrieve
 * an equivalent event handle that is valid in any kernel context. That handle is passed to
 * this function.
 *
 * The event handle is stored in our per-client data (<c OPENHANDLEINSTANCE>). When MIDI data
 * arrives, the event will be set. This is done using MMDEVLDR, which already has semantics
 * in place to do the same sort of notification for WinMM event callbacks.
 *
 */
MMRESULT WINAPI
MidiInSetEventHandle(
    HANDLE hMidiIn,             /* @parm The handle of the input device which desires notification */
    DWORD dwEvent)              /* @parm The VxD handle of the event to set when new data arrives */
{
    NPOPENHANDLEINSTANCE pohi;
    
    if (!IsValidHandle(hMidiIn, VA_F_INPUT, &pohi))
    {
        return MMSYSERR_INVALHANDLE;
    }

    pohi->dwVxDEventHandle = dwEvent;

    return MMSYSERR_NOERROR;
}

/* @func Read MIDI input data into a buffer
 *
 * @rdesc Returns one of the following
 *
 * @comm
 *
 * This function is thunked to the 32-bit DLL
 *
 * Take as much data from the given event list as will fit and put it into the buffer.
 */
MMRESULT WINAPI
MidiInRead(
    HANDLE hMidiIn,         /* @parm The handle of the input device to read */
    LPBYTE lpBuffer,        /* @parm A pointer to memory to pack, in DMEVENT format */
    LPDWORD pcbData,        /* @parm On input, the max size of <p lpBuffer> in bytes.
                                     On return, will contain the number of bytes of data packed into the buffer */
    LPDWORD pmsTime)        /* @parm On return, will contain the starting time of the buffer */ 
{
    NPOPENHANDLEINSTANCE pohi;
    NPOPENHANDLE poh;
    WORD wCSID;
    LPEVENT pEvent;
    LPEVENT pEventRemoved;
    LPBYTE pbEventData;
    DWORD cbLength;
    DWORD cbPaddedLength;
    DWORD cbLeft;
    LPBYTE lpNextEvent;
    LPDMEVENT pdm;
    DWORD msFirst;
    MMRESULT mmr;
    LPMIDIHDR lpmh;
            
    if (!IsValidHandle(hMidiIn, VA_F_INPUT, &pohi))
    {
        return MMSYSERR_INVALHANDLE;
    }

    poh = pohi->pHandle;

    lpNextEvent = lpBuffer;
    cbLeft = *pcbData;

    wCSID = EnterCriticalSection(&poh->wCritSect, CS_BLOCKING);
    assert(wCSID);
    msFirst = 0;

    while (NULL != (pEvent = QueuePeek(&poh->qDone)))
    {
        lpmh = NULL;

        if (cbLeft < sizeof(DMEVENT))
        {
            break;
        }

        if (pEvent->wFlags & EVENT_F_MIDIHDR)
        {
            /* This event is a SysEx message starting with a MIDIHDR, which contains
             * the recorded length of the message.
             */
            lpmh = (LPMIDIHDR)(&pEvent->abEvent[0]);

            cbLength = lpmh->dwBytesRecorded - lpmh->dwOffset;
            pbEventData = lpmh->lpData + lpmh->dwOffset;
            cbPaddedLength = DMEVENT_SIZE(cbLength);

            /* For SysEx, split out as much as will fit if the whole message can't.
             */
            if (cbPaddedLength > cbLeft)
            {
                cbLength = DMEVENT_DATASIZE(cbLeft);
                cbPaddedLength = DMEVENT_SIZE(cbLength);        
            }
        }
        else
        {
            /* The data for this event is directly contained in the event.
             */
            cbLength = pEvent->cbEvent;
            pbEventData = &pEvent->abEvent[0];
            cbPaddedLength = DMEVENT_SIZE(cbLength);

            if (cbPaddedLength > cbLeft)
            {
                break;
            }
        }

        assert(cbPaddedLength <= cbLeft);

        pdm = (LPDMEVENT)lpNextEvent;

        pdm->cbEvent = cbLength;
        pdm->dwChannelGroup = 1;
        pdm->dwFlags = 0;

        if (msFirst)
        {
            QuadwordMul( pEvent->msTime - msFirst,
                         REFTIME_TO_MS,
                         &pdm->rtDelta);
        }
        else
        {
            *pmsTime = pEvent->msTime;
            msFirst = pEvent->msTime;

            pdm->rtDelta.dwLow  = 0;
            pdm->rtDelta.dwHigh = 0;
        }
        
        hmemcpy(pdm->abEvent, pbEventData, cbLength);

        lpNextEvent += cbPaddedLength;
        cbLeft -= cbPaddedLength;

        if (lpmh)
        {
            lpmh->dwOffset += cbLength;
            assert(lpmh->dwOffset <= lpmh->dwBytesRecorded);

            if (lpmh->dwOffset == lpmh->dwBytesRecorded)
            {
                pEventRemoved = QueueRemoveFromFront(&poh->qDone);
                assert(pEventRemoved == pEvent);

                InterlockedIncrement(&poh->wPostedSysExBuffers);

                lpmh->dwOffset = 0;
                mmr = midiInAddBuffer(poh->hmi, (LPMIDIHDR)(&pEvent->abEvent[0]), sizeof(MIDIHDR));
                if (mmr)
                {
                    InterlockedDecrement(&poh->wPostedSysExBuffers);
                    DPF(0, "midiInAddBuffer failed with mmr=%d", mmr);
                    mmr = midiInUnprepareHeader(poh->hmi, (LPMIDIHDR)(&pEvent->abEvent[0]), sizeof(MIDIHDR));
                    if (mmr)
                    {
                        DPF(0, "...midiInUnprepareHeader failed too %d, memory leak!", mmr);
                    }
                    else
                    {
                        FreeEvent(pEvent);
                    }
                }
            }
        }
        else
        {
            pEventRemoved = QueueRemoveFromFront(&poh->qDone);
            assert(pEventRemoved == pEvent);

            QueueAppend(&poh->qFree, pEvent);
        }
    }

    *pcbData = lpNextEvent - lpBuffer;

    DPF(1, "MidiInRead: Returning %ld bytes", (DWORD)*pcbData);

    LeaveCriticalSection(&poh->wCritSect);
    return MMSYSERR_NOERROR;
}

/* @func Enable thruing to a MIDI output port
 *
 * @comm For the given channel group and channel, enable (or disable, if the
 * output handle is NULL) thruing to the given output handle, channel group, and
 * channel.
 */
MMRESULT WINAPI
MidiInThru(
    HANDLE hMidiIn,             /* @parm The handle of the input device to thru */
    DWORD dwFrom,               /* @parm The channel of the input stream to thru */
    DWORD dwTo,                 /* @parm Desination channel */
    HANDLE hMidiOut)            /* The output handle to receive the thru'ed data. */
{
    NPOPENHANDLEINSTANCE pohiInput;
    NPOPENHANDLEINSTANCE pohiOutput;
    
    if (!IsValidHandle(hMidiIn, VA_F_INPUT, &pohiInput) ||
        ((hMidiOut != NULL) && !IsValidHandle(hMidiOut, VA_F_OUTPUT, &pohiOutput)))
    {
        return MMSYSERR_INVALHANDLE;
    }    

    /* Note that since only 1 channel group is supported on legacy drivers, 
     * we don't need any channel group information.
     */
    if (dwFrom > 15 || dwTo > 15) 
    {
        return MMSYSERR_INVALPARAM;
    }

    DPF(1, "Thru: Sending <%04X,%u> to <%04X,%u>", 
        (WORD)hMidiIn, (UINT)dwFrom, (WORD)hMidiOut, (UINT)dwTo);
        
    pohiInput->pThru[(WORD)dwFrom].wChannel = (WORD)dwTo;
    pohiInput->pThru[(WORD)dwFrom].pohi = hMidiOut ? pohiOutput : NULL;    

    return MMSYSERR_NOERROR;
}

/* @func MIDI in data callback
 *
 * @comm
 *
 * This is a standard MIDI input callback from MMSYSYTEM. It calls the correct record routine
 * and notifies the client that data has arrived.
 *
 * For a description of event notification of clients, see <f MidiInSetEventHandle>.
 */
VOID CALLBACK _loadds
midiInProc(
    HMIDIIN hMidiIn,            /* @parm The MMSYSTEM handle of the device which received data */
    UINT wMsg,                  /* @parm The type of callback */
    DWORD dwInstance,           /* @parm Instance data; in our case, a pointer to an <c OPENHANDLE> matching <p hMidiIn> */
    DWORD dwParam1,             /* @parm Message-specific parameters */
    DWORD dwParam2)             /* @parm Message-specific parameters */
{
    NPOPENHANDLE poh = (NPOPENHANDLE)(WORD)dwInstance;
    BOOL bIsNewData = FALSE;
    
    WORD wCSID;


    /* If we can get the critical section we can do all sorts of fun stuff like
     * transfer the lists over.
     */
    wCSID = EnterCriticalSection(&poh->wCritSect, CS_NONBLOCKING);
    if (wCSID)
    {
        /* We now have exclusive access to all the queues.
         *
         * Move any new free events into our internal free list.
         */
        QueueCat(&poh->qFreeCB, &poh->qFree);
    }

    switch(wMsg)
    {
        case MIM_DATA:
            DPF(1, "MIM_DATA %08lX %08lX", dwParam1, dwParam2);
            bIsNewData = RecordShortEvent(poh, dwParam1, dwParam2);
            break;

        case MIM_LONGDATA:
            DPF(1, "MIM_LONGDATA %08lX %08lX", dwParam1, dwParam2);
            bIsNewData = RecordSysExEvent(poh, (LPMIDIHDR)dwParam1, dwParam2);
            break;

        default:
            break;
    }

    if (wCSID)
    {
        /* It's safe to move events over to the shared list.
         */
        QueueCat(&poh->qDone, &poh->qDoneCB);
        LeaveCriticalSection(&poh->wCritSect);
    }

    /* Let clients know there is new data
     */
    if (bIsNewData && (!(poh->wFlags & OH_F_CLOSING)))
    {
        NotifyClientList(poh);
    }
}

/* @func Record a short message (channel messsage or system message).
 *
 * @comm
 *
 * Queue the incoming data as quickly as possible.
 *
 * For a description of the queues used for incoming data, see the <c OPENHANDLE> struct.
 *
 * @rdesc
 * Returns TRUE if the data was successfully recorded; FALSE otherwise.
 */
STATIC BOOL NEAR PASCAL 
RecordShortEvent(
    NPOPENHANDLE poh,           /* @parm The handle to record this data to */
    DWORD dwMessage,            /* @parm The short message to record */
    DWORD dwTime)               /* @parm The time stamp of the message */
{
    LPEVENT pEvent;
    LPBYTE pb;
    BYTE b;

    pEvent = QueueRemoveFromFront(&poh->qFreeCB);
    if (pEvent == NULL)
    {
        DPF(0, "midiInProc: Missed a short event!!!");
        return FALSE;
    }
        
    pEvent->msTime = poh->msStartTime + dwTime;
    pEvent->wFlags = 0;

    /* Now we have to parse and rebuild the channel message.
     *
     * NOTE: Endian specific code ahead
     */
    pb = (LPBYTE)&dwMessage;

    assert(!IS_SYSEX(*pb));         /* This should *always* be in MIM_LONGDATA */
    assert(IS_STATUS_BYTE(*pb));    /* API guarantees no running status */

    /* Copying over all the bytes is harmless (we have a DWORD in both
     * source and dest) and is faster than checking to see if we have to.
     */
    b = pEvent->abEvent[0] = *pb++;
    pEvent->abEvent[1] = *pb++;
    pEvent->abEvent[2] = *pb++;

    if (IS_CHANNEL_MSG(b))
    {
        /* 8x, 9x, Ax, Bx, Cx, Dx, Ex */
        /* 0x..7x invalid, that would need running status */
        /* Fx handled below */
        
        pEvent->cbEvent = cbChanMsg[(b >> 4) & 0x0F];

        /* This is also our criteria for thruing
         */
        ThruClientList(poh, dwMessage);
    }
    else
    {
        /* F1..FF */
        /* F0 is sysex, should never see it here */
        pEvent->cbEvent = cbSysCommData[b & 0x0F];
    }

    /* Now we have something to save
     */
    QueueAppend(&poh->qDoneCB, pEvent);

    return TRUE;
}

/* @func Record a SysEx message.
 *
 * @comm
 *
 * Queue the incoming data as quickly as possible.
 *
 * For a description of the queues used for incoming data, see the <c OPENHANDLE> struct.
 *
 * @rdesc
 * Returns TRUE if the data was successfully recorded; FALSE otherwise.
 */
STATIC BOOL NEAR PASCAL 
RecordSysExEvent(
    NPOPENHANDLE poh,           /* @parm The handle to record this data to */
    LPMIDIHDR lpmh,             /* @parm The SysEx message to record */
    DWORD dwTime)               /* @parm The time stamp of the message */
{
    LPEVENT pEvent;
    
    /* Get back the event header for this MIDIHDR. While buffers are in MMSYSTEM, they are not 
     * in any queue.
     */
    InterlockedDecrement(&poh->wPostedSysExBuffers);

    /* dwOffset in the MIDIHDR is used to indicate the start of data to send
     * up to Win32. It is incremented by MidiInRead until the buffer has been
     * emptied, at which time it will be put back into the pool.
     */
    lpmh->dwOffset = 0;

    pEvent = (LPEVENT)(lpmh->dwUser);
    pEvent->msTime = poh->msStartTime + dwTime;
    QueueAppend(&poh->qDoneCB, pEvent);
    
    return TRUE;
}

/* @func Notify all clients of a device that data has arrived.
 *
 * @comm
 *
 * Walks the list of clients for the device and sets the notification event for each one.
 *
 * This function is now overkill since we no longer support multiple input clients per device.
 */
STATIC VOID NEAR PASCAL
NotifyClientList(
    LPOPENHANDLE poh)           /* @parm The handle of the device that has received data */
{
    NPLINKNODE plink;
    NPOPENHANDLEINSTANCE pohi;

    for (plink = poh->pInstanceList; plink; plink = plink->pNext)
    {
        pohi = (NPOPENHANDLEINSTANCE)(((PBYTE)plink) - offsetof(OPENHANDLEINSTANCE, linkHandleList));

        if (!pohi->dwVxDEventHandle)
        {
            /* No notification event registered for this handle yet.
             */
            continue;
        }

        SetWin32Event(pohi->dwVxDEventHandle);
    }
}

/* @func Thru this message based on the settings of all clients of a device.
 *
 * @comm
 *
 * Walks the list of clients for the device and looks at the thru settings of each one.
 *
 * This function is now overkill since we no longer support multiple input clients per device.
 */
STATIC VOID NEAR PASCAL 
ThruClientList(
    LPOPENHANDLE poh, 
    DWORD dwMessage)
{
    NPLINKNODE plink;
    NPOPENHANDLEINSTANCE pohi;
    NPOPENHANDLEINSTANCE pohiDest;
    int iChannel;

    iChannel = (int)(dwMessage & 0x0000000Fl);
    dwMessage &= 0xFFFFFFF0l;

    for (plink = poh->pInstanceList; plink; plink = plink->pNext)
    {
        pohi = (NPOPENHANDLEINSTANCE)(((PBYTE)plink) - offsetof(OPENHANDLEINSTANCE, linkHandleList));

        pohiDest = pohi->pThru[iChannel].pohi;
        if (pohiDest == NULL || !pohiDest->fActive)
        {
            continue;
        }

        MidiOutThru(pohiDest,
                    dwMessage & 0xFFFFFFF0l | pohi->pThru[iChannel].wChannel);
    }
}

/* @func Refill the free lists
 *
 * @comm
 *
 * This function is called periodically from user mode to ensure that there are enough free
 * events available for the input callback. 
 */
VOID PASCAL
MidiInRefillFreeLists(VOID)
{
    NPLINKNODE plink;
    NPOPENHANDLE poh;
    
    for (plink = gOpenHandleList;
         (poh = (NPOPENHANDLE)plink) != NULL;
         plink = plink->pNext)
    {
        /* Only refill MIDI in devices which are not in the process of closing
         */
        if ((poh->wFlags & (OH_F_MIDIIN | OH_F_CLOSING)) != OH_F_MIDIIN)
        {
            continue;
        }

        RefillFreeEventList(poh);
    }
}
                 
/* @func Terminate thruing to this output handle
 *
 * @comm
 *
 * This function is called before the given output handle is closed.
 */
VOID PASCAL 
MidiInUnthruToInstance(
    NPOPENHANDLEINSTANCE pohiClosing)   /* @parm NPOPENHANDLE | pohClosing | 
                                           The handle which is closing. */
{
    NPLINKNODE plink;
    NPOPENHANDLE poh;
    NPLINKNODE plinkInstance;
    NPOPENHANDLEINSTANCE pohiInstance;
    int iChannel;

    for (plink = gOpenHandleList; (poh = (NPOPENHANDLE)plink) != NULL; plink = plink->pNext)
    {
        DPF(2, "Unthru: poh <%04X>", (WORD)poh);

        if (!(poh->wFlags & OH_F_MIDIIN)) 
        {
            DPF(2, "...not input");
            continue;
        }

        for (plinkInstance = poh->pInstanceList; plinkInstance; plinkInstance = plinkInstance->pNext)
        {
            pohiInstance = (NPOPENHANDLEINSTANCE)(((PBYTE)plinkInstance) - offsetof(OPENHANDLEINSTANCE, linkHandleList));

            DPF(2, "pohiInstance <%04X>", (WORD)pohiInstance);
            
            for (iChannel = 0; iChannel < MIDI_CHANNELS; iChannel++)
            {
                DPF(2, "Channel 0 @ <%04X>", (WORD)&pohiInstance->pThru[iChannel]);
                if (pohiInstance->pThru[iChannel].pohi == pohiClosing)
                {
                    DPF(1, "Thru: Closing output handle %04X which is in use!", (WORD)pohiClosing);
                    pohiInstance->pThru[iChannel].pohi = NULL;
                }
            }
        }
    }        
}

/* @func Allocate enough free events to refill the pool to CAP_HIGHWATERMARK
 *
 * @comm
 *
 * BUGBUG call this on a window timer callback
 *
 */
STATIC VOID NEAR PASCAL
RefillFreeEventList(
    NPOPENHANDLE poh)           /* @parm The device to refill the free list of */
{
    int idx;
    LPEVENT pEvent;
    UINT cFree;
    WORD wCSID;
    QUADWORD rt = {0, 0};
    int cNewBuffers;
    LPMIDIHDR lpmh;
    MMRESULT mmr;
    WORD wIntStat;

    wCSID = EnterCriticalSection(&poh->wCritSect, CS_BLOCKING);
    assert(wCSID);
    
    /* NOTE: Technically not allowed to access qFreeCB here, but this is an approximation
     */
    cFree = poh->qFree.cEle + poh->qFreeCB.cEle;
    if (cFree < CAP_HIGHWATERMARK)
    {
        DPF(1, "RefillFreeEventList poh %.4x free %u highwater %u",
            (WORD)poh,
            (UINT)cFree,
            (UINT)CAP_HIGHWATERMARK);
        
        for (idx = CAP_HIGHWATERMARK - cFree; idx; --idx)
        {
            pEvent = AllocEvent(0, rt, sizeof(DWORD));
            if (NULL == pEvent)
            {
                DPF(0, "AllocEvent returned NULL in RefillFreeEventList");
                break;
            }

            QueueAppend(&poh->qFree, pEvent);
        }
    }

    LeaveCriticalSection(&poh->wCritSect);

    if (poh->wPostedSysExBuffers < SYSEX_BUFFERS)
    {
        for (idx = SYSEX_BUFFERS - cFree; idx; --idx)
        {
            pEvent = AllocEvent(0, rt, sizeof(MIDIHDR) + SYSEX_SIZE);
            if (NULL == pEvent)
            {
                break;
            }

            pEvent->wFlags |= EVENT_F_MIDIHDR;

            lpmh = (LPMIDIHDR)(&pEvent->abEvent[0]);
            lpmh->lpData = (LPSTR)(lpmh + 1);
            lpmh->dwBufferLength = SYSEX_SIZE;
            lpmh->dwUser = (DWORD)pEvent;

            mmr = midiInPrepareHeader(poh->hmi, lpmh, sizeof(MIDIHDR));
            if (mmr)
            {   
                DPF(0, "midiInPrepareHeader: %u\n", mmr);
                FreeEvent(pEvent);
                break;
            }

            InterlockedIncrement(&poh->wPostedSysExBuffers);
            mmr = midiInAddBuffer(poh->hmi, lpmh, sizeof(MIDIHDR));
            if (mmr)
            {
                InterlockedDecrement(&poh->wPostedSysExBuffers);

                DPF(0, "midiInAddBuffer: %u\n", mmr);
                midiInUnprepareHeader(poh->hmi, lpmh, sizeof(MIDIHDR));
                FreeEvent(pEvent);
                break;
            }
        }
    }
}

/* @func Return all memory from all queues to the free event list.
 *
 * @comm
 *
 */
STATIC VOID NEAR PASCAL 
MidiInFlushQueues(
    NPOPENHANDLE poh)
{
    WORD wCSID;

    wCSID = EnterCriticalSection(&poh->wCritSect, CS_BLOCKING);
    assert(wCSID);

    FreeAllQueueEvents(&poh->qDone);
    FreeAllQueueEvents(&poh->qDoneCB);
    FreeAllQueueEvents(&poh->qFree);
    FreeAllQueueEvents(&poh->qFreeCB);

    LeaveCriticalSection(&poh->wCritSect);
}

/* @func Free all events in the given event queue.
 *
 * @comm
 *
 * Assumes that the queue's critical section has already been taken by the caller.
 *
 */
VOID PASCAL
FreeAllQueueEvents(
    NPEVENTQUEUE peq)
{
    LPEVENT lpCurr;
    LPEVENT lpNext;
    
    lpCurr = peq->pHead;
    while (lpCurr)
    {
        lpNext = lpCurr->lpNext;
        FreeEvent(lpCurr);
        lpCurr = lpNext;
    }

    peq->pHead = peq->pTail = NULL;
    peq->cEle = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic16\mmdevldr.asm ===
; Copyright (c) 1998 Microsoft Corporation

;;MMDEVLDR.ASM

        page    ,132
;-----------------------------Module-Header-----------------------------;
;
; @Doc DMusic16
;
; @Module MMDevLdr.asm - Interface routines for MMDevLdr |
;
;-----------------------------------------------------------------------;

        ?PLM    = 1
        ?WIN    = 0
        PMODE   = 1

        .xlist
        include cmacros.inc
        include windows.inc
        include mmdevldr.inc
        include mmsystem.inc
        .list

externFP        AllocCStoDSAlias        ;(UINT sel);
externFP        FreeSelector            ;(UINT sel);

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   equates
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

OFFSEL struc
        off     dw  ?
        sel     dw  ?
OFFSEL ends

GetDeviceAPI            EQU     1684h                   ; int 2Fh query

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   segmentation
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;createSeg %SEGNAME, CodeSeg, word, public, CODE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   code segment
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Remember, we are still 16bit.

    .model medium
        .386

;sBegin CodeSeg
         .code

;        assumes cs, _text

        MMDEVLDR_Entry  dd      ?       ; the api entry point for mmdevldr


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; @func BOOL CDECL | SetWin32Event | Set a Win32 event from any context
;
; @comm
; 
; Given the VxD handle to an event, set the event. This function calls the MMDevLdr
; VxD API entry, which in turn calls the VWin32 function to perform the set.
;
; @rdesc
; Returns TRUE on success, or FALSE if MMDevLdr could not be found.
;
; @parm DWORD | dwRing0Event | The VxD handle of the event as returned
; from the <f OpenVxDHandle> kernel API.
;
;

cProc _SetWin32Event <FAR, CDECL, PUBLIC> <>
        ParmD  dwRing0Evt
cBegin nogen
        mov    dx, MMDEVLDR_API_SetEvent
        jmp    short MMDEVLDR_Call
cEnd nogen

;
;
;
cProc MMDEVLDR_Call <FAR, CDECL> <>
cBegin nogen
        mov     ecx, [MMDEVLDR_Entry]
        jecxz   short mmdevldr_load
        jmp     [MMDEVLDR_Entry]
mmdevldr_load:
        push    dx                      ; save MMDEVLDR command ID
        push    di
        push    si
        cCall   AllocCStoDSAlias, <cs>
        mov     si, ax
        xor     di, di                  ; zero ES:DI before call
        mov     es, di
        mov     ax, GetDeviceAPI        ; get device API entry point
        mov     bx, MMDEVLDR_Device_ID  ; virtual device ID
        int     2Fh                     ; call WIN/386 INT 2F API
        mov     ax, es
        mov     es, si
;        assumes es, CodeSeg
        mov     es:MMDEVLDR_Entry.off, di
        mov     es:MMDEVLDR_Entry.sel, ax
        assumes es, nothing
        push    ax
        cCall   FreeSelector, <si>
        pop     ax
        or      ax, di
        pop     si
        pop     di
        pop     dx
        jz      short mmdevldr_fail
        jmp     [MMDEVLDR_Entry]
mmdevldr_fail:
        mov     ax, MMSYSERR_NODRIVER;
        retf
cEnd nogen


;sEnd CodeSeg

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic16\midiout.c ===
/* Copyright (c) 1998 Microsoft Corporation */
/*
 * @Doc DMusic16
 *
 * @Module MIDIOut.c - Legacy MIDI output emulation for DirectMusic |
 *
 * @comm
 *
 * BUGBUG Need to deal with timer wraparound
 *
 */
#pragma warning(disable:4704)       /* Inline assembly */

#include <windows.h>
#include <mmsystem.h>

#include "dmusic16.h"
#include "debug.h"

#define MIDI_CHANMSG_STATUS_CMD_MASK    (0xF0)
#define MIDI_NOTE_ON                    (0x90)

/* How far past the current time do we send events?
 */
#define MS_TIMER_SLOP           (3)

STATIC TIMECAPS gTimeCaps;
STATIC BOOL gbTimerRunning;
STATIC DWORD gdwTimerDue;
STATIC UINT guTimerID;
STATIC UINT gcActiveOutputDevices;

int PASCAL IsEventDone(LPEVENT pEvent, DWORD dwInstance);
VOID SetNextTimer();
VOID CALLBACK __loadds midiOutProc(HMIDIOUT hMidiIn, UINT wMsg, DWORD dwInstance, DWORD dwParam1, DWORD dwParam2);
VOID CALLBACK __loadds RunTimer(UINT uTimerID, UINT wMsg, DWORD dwUser, DWORD dw1, DWORD dw2);
STATIC VOID NEAR PASCAL MidiOutFlushQueues(NPOPENHANDLE poh);
STATIC VOID NEAR PASCAL MidiOutSendAllNow(NPOPENHANDLE poh);

#pragma alloc_text(INIT_TEXT, MidiOutOnLoad)
#pragma alloc_text(FIX_OUT_TEXT, midiOutProc)
#pragma alloc_text(FIX_OUT_TEXT, RunTimer)

/* @func Called at DLL <f LibInit>
 *
 * @comm
 *
 * Get the timer caps.
 * Initialize globals.
 */
VOID PASCAL
MidiOutOnLoad()
{
    /* This cannot fail
     */
    timeGetDevCaps(&gTimeCaps, sizeof(gTimeCaps));

    gbTimerRunning = FALSE;
}

/* @func Called at DLL <f LibExit>
 *
 * @comm
 *
 * The DLL is unloading, so kill any future timer callback.
 */
VOID PASCAL
MidiOutOnExit()
{
    WORD wIntStat;

    wIntStat = DisableInterrupts();

    if (gbTimerRunning)
    {
        DPF(1, "DLL unloading, killing timer interrupts");
        timeKillEvent(guTimerID);
        gbTimerRunning = FALSE;
    }
    
    RestoreInterrupts(wIntStat);
}

/* @func Open a handle instance
 *
 * @comm
 *
 */
MMRESULT PASCAL
MidiOutOnOpen(
    NPOPENHANDLEINSTANCE pohi)
{
    return MMSYSERR_NOERROR;
}

/* @func Close a MIDI device
 *
 * @comm
 *
 */
VOID PASCAL
MidiOutOnClose(
    NPOPENHANDLEINSTANCE pohi)
{
    /* Give MIDI input a chance to turn off thruing to this handle.
     */

    MidiInUnthruToInstance(pohi);
}

/* @func Activate a MIDI device
 *
 * @comm
 *
 * If this is the first activation of the device, open it using the <f midiOutOpen> legacy API.
 */
MMRESULT PASCAL
MidiOutOnActivate(
    NPOPENHANDLEINSTANCE pohi)
{
    NPOPENHANDLE poh = pohi->pHandle;

    MMRESULT mmr;
    HINSTANCE hInstance;
    WORD sel;
    WORD off;
    HTASK FAR *lph;

    DPF(1, "MidiOutActivate poh %04X device %d refcount %u", 
        (WORD)poh,
        poh->id,
        poh->uReferenceCount);

    /* Only open on the first activation 
     */    
    if (1 == poh->uActiveCount)
    {
        mmr = midiOutOpen(&poh->hmo,
                          poh->id,
                          (DWORD)midiOutProc,
                          (DWORD)(LPOPENHANDLE)poh,
                          CALLBACK_FUNCTION);
        if (mmr)
        {
            return mmr;
        }

        /* Since mapper can't be open shared, and we don't want the first instance that opens
         * mapper to take it with it on exit (due to mmsystem appexit), we do really nasty 
         * stuff here. 
         * 
         * The WORD immediately PRECEDING the handle in MMSYSTEM's data segment is the task
         * owner of the handle. We nuke it to NULL (which is all MIDI_IO_SHARED does anyway)
         * to make AppExit ignore us.
         *
         * God help us if anyone changes HNDL in mmsysi.h
         *
         */
        hInstance = LoadLibrary("mmsystem.dll");
        sel = (WORD)hInstance;

        /* hInstance <= 32 means LoadLibrary failed; in this case we just live with it.
         */
        if (sel > 32)
        {
            off = ((WORD)poh->hmo) - sizeof(WORD);
            lph = (HTASK FAR *)MAKELP(sel, off);
            *lph = (HTASK)NULL;
            FreeLibrary(hInstance);
        }

        /* If this is the first output device, bump up timer resolution
         */
        ++gcActiveOutputDevices;
        if (gcActiveOutputDevices == 1)
        {
            SetOutputTimerRes(TRUE);
        }

    }

    return MMSYSERR_NOERROR;
}

/* @func Deactivate a MIDI device
 *
 * @comm
 *
 * If the last client using the device is closing, then close the actual device.
 * If closing the last actual device, then shut down the high precision timer
 *
 */
MMRESULT PASCAL
MidiOutOnDeactivate(
    NPOPENHANDLEINSTANCE pohi)
{
    NPOPENHANDLE poh = pohi->pHandle;

    DPF(1, "MidiOutOnDeactivate poh %04X device %d refcount %u",
        (WORD)poh,
        poh->id,
        poh->uReferenceCount);

    if (poh->uActiveCount)
    {
        /* Still open instances out there
         */
        return MMSYSERR_NOERROR;
    }

	MidiOutSendAllNow(poh);
    midiOutReset(poh->hmo);
    midiOutClose(poh->hmo);
    MidiOutFlushQueues(poh);

    /* If this was the last output device, shut down precision timer resolution
     */
    --gcActiveOutputDevices;
    if (gcActiveOutputDevices == 0)
    {
        SetOutputTimerRes(FALSE);
    }

	return MMSYSERR_NOERROR;
}
             
/* @func Set the timer resolution
 *
 * @comm
 *
 * Set the resolution of the timer callbacks using the <f timeBeginPeriod> and <f timeEndPeriod>
 * API's.
 *
 * If <p fOnOpen> is TRUE, then the timer resolution will be changed to 1 millisecond. Otherwise, it
 * will be set to its previous value.
 *
 */
VOID PASCAL
SetOutputTimerRes(
    BOOL fOnOpen)           /* @parm TRUE if we are supposed to raise precision */
{
    MMRESULT mmr;
    
    if (fOnOpen)
    {
        mmr = timeBeginPeriod(gTimeCaps.wPeriodMin);
        if (MMSYSERR_NOERROR != mmr)
        {
            DPF(1, "Could not timeBeginPeriod() -> %u", (UINT)mmr);
        }
    }
    else
    {
        mmr = timeEndPeriod(gTimeCaps.wPeriodMin);
        if (MMSYSERR_NOERROR != mmr)
        {
            DPF(1, "Could not timeEndPeriod() -> %u", (UINT)mmr);
        }
    }
}
   

/* @func Submit a buffer to a device for playback
 *
 * @rdesc Returns one of the following
 * @flag MMSYSERR_NOERROR | If the buffer was successfully queued
 * @flag MMSYSERR_INVALPARAM | If the buffer is incorrectly packed or the handle is invalid
 * @flag MMSYSERR_NOMEM | If there was no memory available to queue the events
 *
 * @comm
 *
 * This function is thunked to DMusic32.
 *
 * The DirectMusic port interface specifies that a submitted buffer not be
 * kept by the system past the time of the call which submits it.
 *
 * This routine parses the buffer into individual events and copies them into
 * local event structures, which are then queued onto the handle of the device
 * specified by <p h>. The queue for each device is kept in time-increasing order.
 * All local event memory is page-locked (see alloc.c) so that it can be accessed
 * at interrupt time.
 *
 * The time stamps in the buffer are millisecond resolution and are relative to
 * the absolute time <p msStartTime>.
 *
 */
MMRESULT WINAPI
MidiOutSubmitPlaybackBuffer(
    HANDLE h,                   /* @parm The handle of the device to queue these events for */
    LPBYTE lpBuffer,            /* @parm A pointer to the buffer as packed by the IDirectMusicBuffer interface */
    DWORD cbBuffer,             /* @parm The number of bytes of data in the buffer */
    DWORD msStartTime,          /* @parm The starting time of the buffer in absolute time */
    DWORD rtStartTimeLow,       /* @parm Low DWORD of starting reference time */
    DWORD rtStartTimeHigh)      /* @parm High DWORD of starting reference time */
{
    NPOPENHANDLEINSTANCE pohi;
    NPOPENHANDLE poh;
    LPDMEVENT lpEventHdr;
    DWORD cbEvent;
    DWORD msTime;
    LPEVENT pPrev;
    LPEVENT pCurr;
    LPEVENT pNew;
    WORD    wCSID;
    MMRESULT mmr;
    LPMIDIHDR lpmh;
    QUADWORD rtStartTime;
    QUADWORD rtTime;

#ifdef DUMP_EVERY_BUFFER
    UINT idx;
    LPDWORD lpdw;
#endif //DUMP_EVERY_BUFFER
    
    rtStartTime.dwLow = rtStartTimeLow;
    rtStartTime.dwHigh = rtStartTimeHigh;

    DPF(2, "Buffer @ %08lX msStartTime %lu", (DWORD)lpBuffer, (DWORD)msStartTime);
    DPF(2, "At the tone the time will be... %lu <BEEP>", (DWORD)timeGetTime());

#ifdef DUMP_EVERY_BUFFER
    cbEvent = cbBuffer & 0xFFFFFFF0;

    lpdw = (LPDWORD)lpBuffer;
    for (idx = 0; idx < cbEvent; idx += 16) {
        DPF(3, "%04X: %08lX %08lX %08lX %08lX",
            (UINT)idx,
            lpdw[0],
            lpdw[1],
            lpdw[2],
            lpdw[3]);
        lpdw += 4;
    }

    cbEvent = cbBuffer - (cbBuffer & 0xFFFFFFF0);

    if (cbEvent >= 12) {
        DPF(3, "%04x: %08lX %08lX %08lX",
            (UINT)idx, lpdw[0], lpdw[1], lpdw[2]);
    } else if (cbEvent >= 8) {
        DPF(3, "%04x: %08lX %08lX",
            (UINT)idx, lpdw[0], lpdw[1]);
    } else if (cbEvent >= 8) {
        DPF(3, "%04x: %08lX",
            (UINT)idx, lpdw[0]);
    }
#endif // DUMP_EVERY_BUFFER
    
    if (!IsValidHandle(h, VA_F_OUTPUT, &pohi))
    {
        return MMSYSERR_INVALHANDLE;
    }

    /* Get the handle and lock its list
     */
    poh = pohi->pHandle;

    /* Dequeue and free all completed events on this handle
     */
    FreeDoneHandleEvents(poh, FALSE);

    wCSID = EnterCriticalSection(&poh->wCritSect, CS_BLOCKING);
    assert(wCSID);

    /* Get the time of the first event and position ourselves in the list
     */
    if (0 == poh->qPlay.cEle)
    {
        pPrev = NULL;
        pCurr = NULL;
    }
    else if (!QuadwordLT(rtStartTime, poh->qPlay.pTail->rtTime))
    {
        pPrev = poh->qPlay.pTail;
        pCurr = NULL;
    }
    else
    {
        pPrev = NULL;
        pCurr = poh->qPlay.pHead;
    }
    
    /* Walk the buffer and add the events to the handle's queue
     */
    while (cbBuffer)
    {
        if (cbBuffer < sizeof(DMEVENT))
        {
            return MMSYSERR_INVALPARAM;
        }

        lpEventHdr = (LPDMEVENT)lpBuffer;
        cbEvent = DMEVENT_SIZE(lpEventHdr->cbEvent);
        DPF(2, "cbEvent now %u", (UINT)cbEvent);
        if (cbEvent > cbBuffer)
        {
            DPF(0, "Event past end of buffer");
            return MMSYSERR_INVALPARAM;
        }
        
        lpBuffer += cbEvent;
        cbBuffer -= cbEvent;

        /* We only play events on channel group 1 (0 is broadcast, so we
         * play that as well).
         */
        if (lpEventHdr->dwChannelGroup > 1)
        {
            continue;
        }

        // Time here is in 100ns for queue sorting
        //
        QuadwordAdd(rtStartTime, lpEventHdr->rtDelta, &rtTime);
        
        // Also need msTime for scheduling
        //
        msTime = msStartTime + QuadwordDiv(lpEventHdr->rtDelta, REFTIME_TO_MS);


        // BUGBUG: >64k??
        //
        DPF(2, "Schedule event %02X%02X%02X%02X at %lu",
            (BYTE)lpEventHdr->abEvent[0],
            (BYTE)lpEventHdr->abEvent[1],
            (BYTE)lpEventHdr->abEvent[2],
            (BYTE)lpEventHdr->abEvent[3],
            msTime);

        if (lpEventHdr->cbEvent <= sizeof(DWORD))
        {
            pNew = AllocEvent(msTime, rtTime, (WORD)lpEventHdr->cbEvent);
            if (!pNew)
            {
                return MMSYSERR_NOMEM;
            }
            
            hmemcpy(pNew->abEvent, lpEventHdr->abEvent, lpEventHdr->cbEvent);
        }
        else
        {
            pNew = AllocEvent(msTime, rtTime, (WORD)(lpEventHdr->cbEvent + sizeof(MIDIHDR)));
            if (!pNew)
            {   
                return MMSYSERR_NOMEM;
            }

            pNew->wFlags |= EVENT_F_MIDIHDR;

            lpmh = (LPMIDIHDR)&pNew->abEvent;

            lpmh->lpData =          (LPSTR)(lpmh + 1);
            lpmh->dwBufferLength =  lpEventHdr->cbEvent;
            lpmh->dwUser =          0;  /* Flag if MMSYSTEM owns this buffer */
            lpmh->dwFlags =         0;

            hmemcpy(lpmh->lpData, lpEventHdr->abEvent, lpEventHdr->cbEvent);
            mmr = midiOutPrepareHeader(poh->hmo, lpmh, sizeof(MIDIHDR));
            if (mmr)
            {
                DPF(2, "midiOutPrepareHeader %u", mmr);
                FreeEvent(pNew);
                return mmr;
            }
        }

        while (pCurr)
        {
            if (QuadwordLT(rtTime, pCurr->rtTime))
            {
                break;
            }

            pPrev = pCurr;
            pCurr = pCurr->lpNext;
        }

        if (pPrev)
        {
            pPrev->lpNext = pNew;
        }
        else
        {
            poh->qPlay.pHead = pNew;
        }

        pNew->lpNext = pCurr;
        if (NULL == pCurr)
        {
            poh->qPlay.pTail = pNew;
        }

        pPrev = pNew;
        pCurr = pNew->lpNext;

        ++poh->qPlay.cEle;

        AssertQueueValid(&poh->qPlay);
    }

    LeaveCriticalSection(&poh->wCritSect);

    SetNextTimer();
    
    return MMSYSERR_NOERROR;
}

/* @func VOID PASCAL | FreeDoneHandleEvents | Free events that have already been played, but are still sitting in the done queue
 * on this handle.
 *
 * @comm
 *
 * If fClosing is TRUE, then the events will be free'd regardless of whether they are marked as completed.
 *
 */
typedef struct {
    NPOPENHANDLE poh;
    BOOL fClosing;
} ISEVENTDONEPARMS, FAR *LPISEVENTDONEPARMS;

VOID PASCAL
FreeDoneHandleEvents(
    NPOPENHANDLE poh,       /* @parm What handle? */
    BOOL fClosing)          /* @parm TRUE if the device is being closed. */
{
    ISEVENTDONEPARMS iedp;
    WORD wCSID;

    iedp.poh = poh;
    iedp.fClosing = fClosing;
    
    wCSID = EnterCriticalSection(&poh->wCritSect, CS_BLOCKING);
    assert(wCSID);

    QueueFilter(&poh->qDone, (DWORD)(LPVOID)&iedp, IsEventDone);

    LeaveCriticalSection(&poh->wCritSect);
}

/* @func
 *
 * @comm
 */
int PASCAL
IsEventDone(
    LPEVENT pEvent,
    DWORD dwInstance)
{
    LPISEVENTDONEPARMS piedp = (LPISEVENTDONEPARMS)dwInstance;
    MMRESULT mmr;
    
    if (piedp->fClosing ||
        pEvent->cbEvent <= sizeof(DWORD) ||
        ((LPMIDIHDR)(&pEvent->abEvent[0]))->dwUser == 0)
    {
        /* Ok to free this event
         */
        
        if (pEvent->cbEvent > sizeof(DWORD))
        {
            mmr = midiOutUnprepareHeader(piedp->poh->hmo, (LPMIDIHDR)(&pEvent->abEvent[0]), sizeof(MIDIHDR));
            if (mmr)
            {
                DPF(0, "FreeOldEvents: midiOutUnprepareHeader returned %u", (UINT)mmr);
            }
        }
        
        FreeEvent(pEvent);

        return QUEUE_FILTER_REMOVE;
    }   

    return QUEUE_FILTER_KEEP;
}

/* @func Thru the given message on the given output port
 *
 * @comm
 *
 */
VOID PASCAL 
MidiOutThru(
    NPOPENHANDLEINSTANCE pohi, 
    DWORD dwMessage)
{
    NPOPENHANDLE poh = pohi->pHandle;

    MMRESULT mmr;

    /* !!! Verify that VMM will not interrupt a timer callback with another event
     */
    mmr = midiOutShortMsg(poh->hmo, dwMessage);
    if (mmr)
    {
        DPF(0, "Thru: midiOutShortMsg() -> %d", mmr);
    }    
}


/* @func Set the timer to schedule the next pending event
 *
 * @comm
 *
 * Walk the list of output handles and look at the first scheduled event on each. Save the time
 * of the nearest event. If there is such an event, schedule a timer callback at that time to call
 * <f RunTimer>; otherwise, schedule no callback.
 * 
 * Any pending timer callback will be killed before the new callback is scheduled.
 */
VOID
SetNextTimer(VOID)
{
    WORD wIntStat;

    NPLINKNODE npLink;
    NPOPENHANDLE poh;
    DWORD dwLowTime;
    BOOL fNeedTimer;
    DWORD dwNow;
    LONG lWhen;
    UINT uWhen;

    /* We actually need to disable interrupts here as opposed to just entering a critical section
     * because we don't want the timer callback to fire.
     */
    wIntStat = DisableInterrupts();

    /* BUGBUG: wrap
     */
    fNeedTimer = FALSE;
    dwLowTime = (DWORD)(0xFFFFFFFFL);
    for (npLink = gOpenHandleList; npLink; npLink = npLink->pNext)
    {
        poh = (NPOPENHANDLE)npLink;

        if (0 == poh->qPlay.cEle)
        {
            continue;
        }
        
        assert(poh->qPlay.pHead);
        

        if (poh->qPlay.pHead->msTime < dwLowTime)
        {
            fNeedTimer = TRUE;
            dwLowTime = poh->qPlay.pHead->msTime;
        }
    }

    if (fNeedTimer)
    {
        if ((!gbTimerRunning) || dwLowTime < gdwTimerDue)
        {
            /* We need to set the timer. Kill it now so there's no chance of it
             * firing before being killed
             */
            if (gbTimerRunning)
            {
                timeKillEvent(guTimerID);
                gbTimerRunning = FALSE;
            }
        }
        else
        {
            fNeedTimer = FALSE;
        }
    }

    RestoreInterrupts(wIntStat);

    if (fNeedTimer)
    {
        /* Guaranteed that current timer expired or dead. Reschedule.
         */

        dwNow = timeGetTime();
        gbTimerRunning = TRUE;
        gdwTimerDue = dwLowTime;

        lWhen = gdwTimerDue - dwNow;
        if (lWhen < (LONG)gTimeCaps.wPeriodMin)
        {
            uWhen = gTimeCaps.wPeriodMin;
        }
        else if (lWhen > (LONG)gTimeCaps.wPeriodMax)
        {
            uWhen = gTimeCaps.wPeriodMax;
        }
        else
        {
            uWhen = (UINT)lWhen;
        }

        DPF(2, "SetNextTimer: Now %lu, setting timer for %u ms from now. dwLowTime %lu",
           (DWORD)dwNow, (UINT)uWhen, (DWORD)dwLowTime);
        guTimerID = timeSetEvent(uWhen,
                                 gTimeCaps.wPeriodMin,
                                 RunTimer,
                                 NULL,
                                 TIME_ONESHOT);
        if (0 == guTimerID)
        {
            gbTimerRunning = FALSE;
        }
    }
    else
    {
        DPF(2, "SetNextTimer: Timer cancelled; no pending events.");
    }
}

/* @func Process a high precision timer callback
 *
 * @comm
 *
 * This is a standard callback for the <f timeSetEvent> API.
 *
 * Walk the list of open output handles. For each handle, look at the event queue. Play all
 * the events that are due.
 *
 * Events are pulled from the qPlay queue on each handle. This queue (as well as the qDone queue) are
 * protected by the handle's critical section. If we cannot get the critical section, then the events
 * that may be due on that handle will not be played.
 *
 * If we do get the critical section and play events, then the events will be moved to the qDone
 * queue, where they will later be returned to the free list.
 *
 * This intermediate step is needed because we cannot call <f FreeEvent> at interrupt time. We cannot
 * just protect the free list with a critical section, because we cannot afford to fail getting the
 * critical section. If we did, we would lost the memory for the event we were about to free.
 *
 */
VOID CALLBACK __loadds
RunTimer(
    UINT        uTimerID,           /* @parm The ID of the timer which fired */
    UINT        wMsg,               /* @parm The type of callback (unused) */
    DWORD       dwUser,             /* @parm User instance data */
    DWORD       dw1,                /* @parm Message specific data (unused) */
    DWORD       dw2)                /* @parm Message specific data (unused) */
{    
    NPLINKNODE npLink;
    NPOPENHANDLE poh;
    WORD wCSID;
    WORD wIntStat;
    DWORD msNow;
    DWORD msFence;
    LPEVENT pEvent;
    DWORD dwEvent;
    MMRESULT mmr;


    /* Walk the event queues and send out pending events.
     */
    msNow = timeGetTime();
    msFence = msNow + MS_TIMER_SLOP;
    
    for (npLink = gOpenHandleList; npLink; npLink = npLink->pNext)
    {
        poh = (NPOPENHANDLE)npLink;

        /* If we can't get the critical section, don't sweat it - just reschedule
         */
        wCSID = EnterCriticalSection(&poh->wCritSect, CS_NONBLOCKING);
        if (!wCSID)
        {
            DPF(1, "Timer: Could not get critical section for '%04x'; next time.", (UINT)poh);
            continue;
        }

        /* Now safe against foreground messing with this handle
         */

        for(;;)
        {
            pEvent = poh->qPlay.pHead;
            if (NULL == pEvent || pEvent->msTime > msFence)
            {
                break;
            }

            if (pEvent->msTime > msNow)
            {
                DPF(2, "Late!");
            }

            QueueRemoveFromFront(&poh->qPlay);
            
            if (pEvent->cbEvent <= 4)
            {
                dwEvent = (pEvent->abEvent[0]) |
                          (((DWORD)pEvent->abEvent[1]) << 8) |
                          (((DWORD)pEvent->abEvent[2]) << 16);
                mmr = midiOutShortMsg(poh->hmo, dwEvent);
                if (mmr)
                {
                    DPF(0, "midiOutShortMsg(%04X,%08lX) -> %u",
                        (UINT)poh->hmo,
                        dwEvent,
                        (UINT)mmr);
                }
                else
                {
                    DPF(2, "midiOutShortMsg(%04X,%08lX) ",
                        (UINT)poh->hmo,
                        dwEvent);
                }
            }
            else
            {
                /* Data contains an already prepared long message.
                 * DON'T leave interrupts disabled here! Most legacy MIDI drivers
                 * do this synchronously.
                 *
                 */
                RestoreInterrupts(wIntStat);
                ((LPMIDIHDR)(&pEvent->abEvent[0]))->dwUser = 1;
                mmr = midiOutLongMsg(poh->hmo,
                                     (LPMIDIHDR)(&pEvent->abEvent[0]),
                                     sizeof(MIDIHDR));
                if (mmr)
                {
                    DPF(0, "midiOutLongMsg(%04X, %08lX, %04X) -> %u\n",
                        (UINT)poh->hmo,
                        (DWORD)(LPMIDIHDR)(&pEvent->abEvent[0]),
                        (UINT)sizeof(MIDIHDR),
                        (UINT)mmr);
                }
                DisableInterrupts();
            }
            

            /* We're done with this event; back to the free list with ya!
             *
             * Since we can't protect the free list with a critical section (what
             * would we do if getting the critical section failed here?) we keep
             * a temporary free list in the handle. Free events are moved from
             * the handle to the master free list in user time.
             */
            QueueAppend(&poh->qDone, pEvent);
        }

        LeaveCriticalSection(&poh->wCritSect);
    }

    /* Now reschedule ourselves if needed.
     */
    gbTimerRunning = FALSE;
    SetNextTimer();

}


VOID CALLBACK _loadds
midiOutProc(
    HMIDIOUT hMidiIn,
    UINT wMsg,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2)
{
    LPOPENHANDLE poh = (LPOPENHANDLE)dwInstance;

    switch(wMsg)
    {
        case MOM_DONE:
            /* Buffer is already queued for free on the device's queue. dwUser flags if it
             * is still in use by MMSYSTEM/driver.
             */
            ((LPMIDIHDR)dwParam1)->dwUser = 0;
            break;
    }
}

/* @func Return all memory from all queues to the free event list.
 *
 * @comm
 *
 */
STATIC VOID NEAR PASCAL 
MidiOutFlushQueues(
    NPOPENHANDLE poh)
{
    WORD wCSID;

    wCSID = EnterCriticalSection(&poh->wCritSect, CS_BLOCKING);
    assert(wCSID);

    FreeAllQueueEvents(&poh->qPlay);
    FreeAllQueueEvents(&poh->qDone);

    LeaveCriticalSection(&poh->wCritSect);
}

/* @func Send all pending messages (other than note on) in preperation
 * to close the port.
 *
 * @comm
 *
 */
STATIC VOID NEAR PASCAL 
MidiOutSendAllNow(
	NPOPENHANDLE poh)
{
	LPEVENT pEvent;
	DWORD dwEvent;
	MMRESULT mmr;
	WORD wCSID;
	
	wCSID = EnterCriticalSection(&poh->wCritSect, CS_BLOCKING);
	assert(wCSID);

	/* Now safe against foreground messing with this handle
	 */

	for(;;)
	{
    	pEvent = poh->qPlay.pHead;
	    if (NULL == pEvent)
	    {
	    	DPF(2,"MidiOutSendAllNow: No queued Messages.");
	        break;
	    }

	    QueueRemoveFromFront(&poh->qPlay);
    
	    if (pEvent->cbEvent <= 4)
	    {
	        dwEvent = (pEvent->abEvent[0]) |
	                 (((DWORD)pEvent->abEvent[1]) << 8) |
                  (((DWORD)pEvent->abEvent[2]) << 16);

			// We aren't going to process MIDI_NOTE_ON with a
			// velocity of zero

			//There are two kinds of short messages,  Two Byte and 
			//Three Byte..  They pack differently in MIDI Short message

			//If the first bit if the High Byte of the Low Word is SET we are
			//looking at a 3 byte message.

			//MIDI status messages begin with a 
			//set bit, and every other part of the same message starts with an
			//unset bit.
			if (HIBYTE(LOWORD(dwEvent) & 0x80) )
			{
				//This is a THREE BYTE message

				// note on with a non-zero velocity is skipped
				if ( (HIBYTE(LOWORD(dwEvent)) & MIDI_NOTE_ON) && (LOBYTE(LOWORD(dwEvent)) != 0 ))
				{
					QueueAppend(&poh->qDone, pEvent);
					continue;
				}
			}
			else
			{
				//This is a THREE BYTE Message

				// Any note-on is skiped
				if (LOBYTE(LOWORD(dwEvent)) & MIDI_NOTE_ON)
				{
					QueueAppend(&poh->qDone, pEvent);
					continue;
				}
			}
            
    	    mmr = midiOutShortMsg(poh->hmo, dwEvent);
        	if (mmr)
        	{
            	DPF(0, "midiOutShortMsg(%04X,%08lX) -> %u",
                (UINT)poh->hmo,
                dwEvent,
                (UINT)mmr);
        	}
        	else
        	{
            DPF(2, "midiOutShortMsg(%04X,%08lX) ",
                (UINT)poh->hmo,
                dwEvent);
        	}
    	}
    	else
    	{
        	/* Data contains an already prepared long message.
         	* DON'T leave interrupts disabled here! Most legacy MIDI drivers
         	* do this synchronously.
         	*
         	*/
        	((LPMIDIHDR)(&pEvent->abEvent[0]))->dwUser = 1;
        	mmr = midiOutLongMsg(poh->hmo,
                             (LPMIDIHDR)(&pEvent->abEvent[0]),
                             sizeof(MIDIHDR));
        	if (mmr)
        	{	
            	DPF(0, "midiOutLongMsg(%04X, %08lX, %04X) -> %u\n",
               		(UINT)poh->hmo,
               	 	(DWORD)(LPMIDIHDR)(&pEvent->abEvent[0]),
                	(UINT)sizeof(MIDIHDR),
                	(UINT)mmr);
        	}
    	}
    

    	/* We're done with this event; back to the free list with ya!
     	*
     	* Since we can't protect the free list with a critical section (what
     	* would we do if getting the critical section failed here?) we keep
     	* a temporary free list in the handle. Free events are moved from
     	* the handle to the master free list in user time.
     	*/
    	QueueAppend(&poh->qDone, pEvent);
	}

	LeaveCriticalSection(&poh->wCritSect);

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic16\mmsystem.inc ===
; Copyright (c) 1998-1999 Microsoft Corporation

; general constants
MAXPNAMELEN	EQU	32     ; max product name length (including NULL)
MAXERRORLENGTH	EQU	256    ; max error text length (including NULL)
MAX_JOYSTICKOEMVXDNAME	EQU	260 ; max oem vxd name length (including NULL)

MMTIME	STRUC
mmt_wType	DW	?
mmt_TimeUnion	DD	?
MMTIME	ENDS

SMPTE	STRUC
smpte_hour	DB	?
smpte_min	DB	?
smpte_sec	DB	?
smpte_frame	DB	?
smpte_fps	DB	?
smpte_reserved	DB	?
SMPTE	ENDS
; types for wType field in MMTIME struct
TIME_MS	EQU	0001H  ; time in milliseconds
TIME_SAMPLES	EQU	0002H  ; number of wave samples
TIME_BYTES	EQU	0004H  ; current byte offset
TIME_SMPTE	EQU	0008H  ; SMPTE time
TIME_MIDI	EQU	0010H  ; MIDI time
TIME_TICKS	EQU	0020H  ; Ticks within MIDI stream
MM_JOY1MOVE	EQU	3A0H           ; joystick
MM_JOY2MOVE	EQU	3A1H
MM_JOY1ZMOVE	EQU	3A2H
MM_JOY2ZMOVE	EQU	3A3H
MM_JOY1BUTTONDOWN	EQU	3B5H
MM_JOY2BUTTONDOWN	EQU	3B6H
MM_JOY1BUTTONUP	EQU	3B7H
MM_JOY2BUTTONUP	EQU	3B8H
MM_MCINOTIFY	EQU	3B9H           ; MCI
						;internal; 0x3BA is open
MM_WOM_OPEN	EQU	3BBH           ; waveform output
MM_WOM_CLOSE	EQU	3BCH
MM_WOM_DONE	EQU	3BDH
MM_WIM_OPEN	EQU	3BEH           ; waveform input
MM_WIM_CLOSE	EQU	3BFH
MM_WIM_DATA	EQU	3C0H
MM_MIM_OPEN	EQU	3C1H           ; MIDI input
MM_MIM_CLOSE	EQU	3C2H
MM_MIM_DATA	EQU	3C3H
MM_MIM_LONGDATA	EQU	3C4H
MM_MIM_ERROR	EQU	3C5H
MM_MIM_LONGERROR	EQU	3C6H
MM_MOM_OPEN	EQU	3C7H           ; MIDI output
MM_MOM_CLOSE	EQU	3C8H
MM_MOM_DONE	EQU	3C9H
MMSYSERR_BASE	EQU	0
WAVERR_BASE	EQU	32
MIDIERR_BASE	EQU	64
TIMERR_BASE	EQU	96
JOYERR_BASE	EQU	160
MCIERR_BASE	EQU	256
MIXERR_BASE	EQU	1024
MCI_STRING_OFFSET	EQU	512
MCI_VD_OFFSET	EQU	1024
MCI_CD_OFFSET	EQU	1088
MCI_WAVE_OFFSET	EQU	1152
MCI_SEQ_OFFSET	EQU	1216
;***************************************************************************
;	General error return values
;*************************************************************************
; general error return values
MMSYSERR_NOERROR	EQU	0                    ; no error
MMSYSERR_ERROR	EQU	(MMSYSERR_BASE+1)  ; unspecified error
MMSYSERR_BADDEVICEID	EQU	(MMSYSERR_BASE+2)  ; device ID out of range
MMSYSERR_NOTENABLED	EQU	(MMSYSERR_BASE+3)  ; driver failed enable
MMSYSERR_ALLOCATED	EQU	(MMSYSERR_BASE+4)  ; device already allocated
MMSYSERR_INVALHANDLE	EQU	(MMSYSERR_BASE+5)  ; device handle is invalid
MMSYSERR_NODRIVER	EQU	(MMSYSERR_BASE+6)  ; no device driver present
MMSYSERR_NOMEM	EQU	(MMSYSERR_BASE+7)  ; memory allocation error
MMSYSERR_NOTSUPPORTED	EQU	(MMSYSERR_BASE+8)  ; function isn't supported
MMSYSERR_BADERRNUM	EQU	(MMSYSERR_BASE+9)  ; error value out of range
MMSYSERR_INVALFLAG	EQU	(MMSYSERR_BASE+10) ; invalid flag passed
MMSYSERR_INVALPARAM	EQU	(MMSYSERR_BASE+11) ; invalid parameter passed
MMSYSERR_HANDLEBUSY	EQU	(MMSYSERR_BASE+12) ; handle being used
						   ; simultaneously on another
						   ; thread (eg callback)
MMSYSERR_INVALIDALIAS	EQU	(MMSYSERR_BASE+13) ; specified alias not found
MMSYSERR_BADDB	EQU	(MMSYSERR_BASE+14) ; bad registry database
MMSYSERR_KEYNOTFOUND	EQU	(MMSYSERR_BASE+15) ; registry key not found
MMSYSERR_READERROR	EQU	(MMSYSERR_BASE+16) ; registry read error
MMSYSERR_WRITEERROR	EQU	(MMSYSERR_BASE+17) ; registry write error
MMSYSERR_DELETEERROR	EQU	(MMSYSERR_BASE+18) ; registry delete error
MMSYSERR_VALNOTFOUND	EQU	(MMSYSERR_BASE+19) ; registry value not found
MMSYSERR_NODRIVERCB	EQU	(MMSYSERR_BASE+20) ; driver does not call DriverCallback
MMSYSERR_LASTERROR	EQU	(MMSYSERR_BASE+20) ; last error in range
ifndef MMNODRV                                                 ;both
ifndef DRV_RESERVED
DRV_RESERVED	EQU	0800H
DRV_USER	EQU	4000H
endif
DRV_MCI_FIRST	EQU	DRV_RESERVED
DRV_MCI_LAST	EQU	(DRV_RESERVED+0FFFH)
endif                                      ;both; ifndef MMNODRV
;***************************************************************************
;	  Driver callback support
;*************************************************************************
; flags used with waveOutOpen(), waveInOpen(), midiInOpen(), and
; midiOutOpen() to specify the type of the dwCallback parameter.
CALLBACK_TYPEMASK	EQU	00070000H    ; callback type mask
CALLBACK_NULL	EQU	00000000H    ; no callback
CALLBACK_WINDOW	EQU	00010000H    ; dwCallback is a HWND
CALLBACK_TASK	EQU	00020000H    ; dwCallback is a HTASK
CALLBACK_FUNCTION	EQU	00030000H    ; dwCallback is a FARPROC
CALLBACK_THUNK	EQU	00040000H    	;internal; dwCallback is a Ring0 Thread Handle
ifdef _WIN32
CALLBACK_THREAD	EQU	(CALLBACK_TASK); thread ID replaces 16 bit task
CALLBACK_EVENT	EQU	00050000H    ; dwCallback is an EVENT Handle
endif
CALLBACK_EVENT16	EQU	00060000H    	;internal; dwCallback is an EVENT under Win16
SND_SYNC	EQU	0000H  ; play synchronously (default)
SND_ASYNC	EQU	0001H  ; play asynchronously
SND_NODEFAULT	EQU	0002H  ; silence (!default) if sound not found
SND_MEMORY	EQU	0004H  ; pszSound points to a memory file
SND_LOOP	EQU	0008H  ; loop the sound until next sndPlaySound
SND_NOSTOP	EQU	0010H  ; don't stop any currently playing sound
ifndef MMNOWAVE                                                 ;both
;***************************************************************************
;	Waveform audio support
;*************************************************************************
; waveform audio error return values
WAVERR_BADFORMAT	EQU	(WAVERR_BASE+0)    ; unsupported wave format
WAVERR_STILLPLAYING	EQU	(WAVERR_BASE+1)    ; still something playing
WAVERR_UNPREPARED	EQU	(WAVERR_BASE+2)    ; header not prepared
WAVERR_SYNC	EQU	(WAVERR_BASE+3)    ; device is synchronous
WAVERR_LASTERROR	EQU	(WAVERR_BASE+3)    ; last error in range
; wave callback messages
WOM_OPEN	EQU	MM_WOM_OPEN
WOM_CLOSE	EQU	MM_WOM_CLOSE
WOM_DONE	EQU	MM_WOM_DONE
WIM_OPEN	EQU	MM_WIM_OPEN
WIM_CLOSE	EQU	MM_WIM_CLOSE
WIM_DATA	EQU	MM_WIM_DATA
; device ID for wave device mapper
WAVE_MAPPER	EQU	(-1)
; flags for dwFlags parameter in waveOutOpen() and waveInOpen()
WAVE_FORMAT_QUERY	EQU	0001H
WAVE_ALLOWSYNC	EQU	0002H
WAVE_VALID	EQU	800FH			;internal

WAVEHDR	STRUC
lpWaveData	DD	?
dwWaveBufferLength	DD	?
dwWaveBytesRecorded	DD	?
dwWaveUser	DD	?
dwWaveFlags	DD	?
dwWaveLoops	DD	?
lpWaveNext	DD	?
Wavereserved	DD	?
WAVEHDR	ENDS
; flags for dwFlags field of WAVEHDR
WHDR_DONE	EQU	00000001H  ; done bit
WHDR_PREPARED	EQU	00000002H  ; set if this header has been prepared
WHDR_BEGINLOOP	EQU	00000004H  ; loop start block
WHDR_ENDLOOP	EQU	00000008H  ; loop end block
WHDR_INQUEUE	EQU	00000010H  ; reserved for driver
WHDR_MAPPED	EQU	00001000H  	;internal; thunked header
WHDR_VALID	EQU	0000101FH  		;internal; valid flags

WAVEOUTCAPS	STRUC
woc_wMid	DW	?
woc_wPid	DW	?
woc_vDriverVersion	DW	?
woc_szPname	DB	MAXPNAMELEN DUP (?)
woc_dwFormats	DD	?
woc_wChannels	DW	?
woc_dwSupport	DD	?
WAVEOUTCAPS	ENDS
; flags for dwSupport field of WAVEOUTCAPS
WAVECAPS_PITCH	EQU	0001H   ; supports pitch control
WAVECAPS_PLAYBACKRATE	EQU	0002H   ; supports playback rate control
WAVECAPS_VOLUME	EQU	0004H   ; supports volume control
WAVECAPS_LRVOLUME	EQU	0008H   ; separate left-right volume control
WAVECAPS_SYNC	EQU	0010H
WAVECAPS_SAMPLEACCURATE	EQU	0020H
WAVECAPS_DIRECTSOUND	EQU	0040H

WAVEINCAPS	STRUC
wic_wMid	DW	?
wic_wPid	DW	?
wic_vDriverVersion	DW	?
wic_szPname	DB	MAXPNAMELEN DUP (?)
wic_dwFormats	DD	?
wic_wChannels	DW	?
WAVEINCAPS	ENDS
; defines for dwFormat field of WAVEINCAPS and WAVEOUTCAPS
WAVE_INVALIDFORMAT	EQU	00000000H       ; invalid format
WAVE_FORMAT_1M08	EQU	00000001H       ; 11.025 kHz, Mono,   8-bit
WAVE_FORMAT_1S08	EQU	00000002H       ; 11.025 kHz, Stereo, 8-bit
WAVE_FORMAT_1M16	EQU	00000004H       ; 11.025 kHz, Mono,   16-bit
WAVE_FORMAT_1S16	EQU	00000008H       ; 11.025 kHz, Stereo, 16-bit
WAVE_FORMAT_2M08	EQU	00000010H       ; 22.05  kHz, Mono,   8-bit
WAVE_FORMAT_2S08	EQU	00000020H       ; 22.05  kHz, Stereo, 8-bit
WAVE_FORMAT_2M16	EQU	00000040H       ; 22.05  kHz, Mono,   16-bit
WAVE_FORMAT_2S16	EQU	00000080H       ; 22.05  kHz, Stereo, 16-bit
WAVE_FORMAT_4M08	EQU	00000100H       ; 44.1   kHz, Mono,   8-bit
WAVE_FORMAT_4S08	EQU	00000200H       ; 44.1   kHz, Stereo, 8-bit
WAVE_FORMAT_4M16	EQU	00000400H       ; 44.1   kHz, Mono,   16-bit
WAVE_FORMAT_4S16	EQU	00000800H       ; 44.1   kHz, Stereo, 16-bit

WAVEFORMAT	STRUC
wfmt_wFormatTag	DW	?
wfmt_nChannels	DW	?
wfmt_nSamplesPerSec	DD	?
wfmt_nAvgBytesPerSec	DD	?
wfmt_nBlockAlign	DW	?
WAVEFORMAT	ENDS
; flags for wFormatTag field of WAVEFORMAT
WAVE_FORMAT_PCM	EQU	1

PCMWAVEFORMAT	STRUC
pcm_wf	DB	SIZE WAVEFORMAT DUP (?)
pcm_wBitsPerSample	DW	?
PCMWAVEFORMAT	ENDS
endif                                      ;both; ifndef MMNOWAVE
ifndef MMNOMIDI                               ;both
;***************************************************************************
;	    MIDI audio support
;*************************************************************************
; MIDI error return values
MIDIERR_UNPREPARED	EQU	(MIDIERR_BASE+0)   ; header not prepared
MIDIERR_STILLPLAYING	EQU	(MIDIERR_BASE+1)   ; still something playing
MIDIERR_NOMAP	EQU	(MIDIERR_BASE+2)   ; no configured instruments
MIDIERR_NOTREADY	EQU	(MIDIERR_BASE+3)   ; hardware is still busy
MIDIERR_NODEVICE	EQU	(MIDIERR_BASE+4)   ; port no longer connected
MIDIERR_INVALIDSETUP	EQU	(MIDIERR_BASE+5)   ; invalid MIF
MIDIERR_BADOPENMODE	EQU	(MIDIERR_BASE+6)   ; operation unsupported w/ open mode
MIDIERR_DONT_CONTINUE	EQU	(MIDIERR_BASE+7)   ; thru device 'eating' a message
MIDIERR_LASTERROR	EQU	(MIDIERR_BASE+7)   ; last error in range
MIDIPATCHSIZE	EQU	128
; MIDI callback messages
MIM_OPEN	EQU	MM_MIM_OPEN
MIM_CLOSE	EQU	MM_MIM_CLOSE
MIM_DATA	EQU	MM_MIM_DATA
MIM_LONGDATA	EQU	MM_MIM_LONGDATA
MIM_ERROR	EQU	MM_MIM_ERROR
MIM_LONGERROR	EQU	MM_MIM_LONGERROR
MOM_OPEN	EQU	MM_MOM_OPEN
MOM_CLOSE	EQU	MM_MOM_CLOSE
MOM_DONE	EQU	MM_MOM_DONE
; device ID for MIDI mapper
MIDIMAPPER	EQU	(-1)
MIDI_MAPPER	EQU	(-1)
; flags for wFlags parm of midiOutCachePatches(), midiOutCacheDrumPatches()
MIDI_CACHE_ALL	EQU	1
MIDI_CACHE_BESTFIT	EQU	2
MIDI_CACHE_QUERY	EQU	3
MIDI_UNCACHE	EQU	4
MIDI_CACHE_VALID	EQU	(MIDI_CACHE_ALL OR MIDI_CACHE_BESTFIT OR MIDI_CACHE_QUERY OR MIDI_UNCACHE)     ;internal

MIDIOUTCAPS	STRUC
moc_wMid	DW	?
moc_wPid	DW	?
moc_vDriverVersion	DW	?
moc_szPname	DB	MAXPNAMELEN DUP (?)
moc_wTechnology	DW	?
moc_wVoices	DW	?
moc_wNotes	DW	?
moc_wChannelMask	DW	?
moc_dwSupport	DD	?
MIDIOUTCAPS	ENDS
; flags for wTechnology field of MIDIOUTCAPS structure
MOD_MIDIPORT	EQU	1  ; output port
MOD_SYNTH	EQU	2  ; generic internal synth
MOD_SQSYNTH	EQU	3  ; square wave internal synth
MOD_FMSYNTH	EQU	4  ; FM internal synth
MOD_MAPPER	EQU	5  ; MIDI mapper
; flags for dwSupport field of MIDIOUTCAPS structure
MIDICAPS_VOLUME	EQU	0001H  ; supports volume control
MIDICAPS_LRVOLUME	EQU	0002H  ; separate left-right volume control
MIDICAPS_CACHE	EQU	0004H

MIDIINCAPS	STRUC
mic_wMid	DW	?
mic_wPid	DW	?
mic_vDriverVersion	DW	?
mic_szPname	DB	MAXPNAMELEN DUP (?)
MIDIINCAPS	ENDS

MIDIHDR	STRUC
lpMidiData	DD	?
dwMidiBufferLength	DD	?
dwMidiBytesRecorded	DD	?
dwMidiUser	DD	?
dwMidiFlags	DD	?
lpMidiNext	DD	?
Midireserved	DD	?
MididwOffset	DD	?
MididwReserved	DD	4 DUP (?)
MIDIHDR	ENDS

MIDIHDR31	STRUC
w31lpMidiData	DD	?
w31dwMidiBufferLength	DD	?
w31dwMidiBytesRecorded	DD	?
w31dwMidiUser	DD	?
w31dwMidiFlags	DD	?
w31lpMidiNext	DD	?
w31Midireserved	DD	?
MIDIHDR31	ENDS
; flags for dwFlags field of MIDIHDR structure
MHDR_DONE	EQU	00000001H       ; done bit
MHDR_PREPARED	EQU	00000002H       ; set if header prepared
MHDR_INQUEUE	EQU	00000004H       ; reserved for driver
MHDR_ISSTRM	EQU	00000008H       ; Buffer is stream buffer
MHDR_SENDING	EQU	00000020H       ;internal
MHDR_MAPPED	EQU	00001000H       	;internal; thunked header
MHDR_SHADOWHDR	EQU	00002000H        ;internal; MIDIHDR is 16-bit shadow
MHDR_VALID	EQU	0000302FH       	;internal; valid flags
	;internal */;#define MHDR_VALID      0xFFFF000F       /* valid flags
MHDR_SAVE	EQU	00003000H         ;internal; Save these flags
                                          ;internal; past driver calls
endif                                     ;both; ifndef MMNOMIDI
ifndef MMNOAUX                                                  ;both
;***************************************************************************
;	Auxiliary audio support
;*************************************************************************
; device ID for aux device mapper
AUX_MAPPER	EQU	(-1)

AUXCAPS	STRUC
acaps_wMid	DW	?
acaps_wPid	DW	?
acaps_vDriverVersion	DW	?
acaps_szPname	DB	MAXPNAMELEN DUP (?)
acaps_wTechnology	DW	?
acaps_dwSupport	DD	?
AUXCAPS	ENDS
; flags for wTechnology field in AUXCAPS structure
AUXCAPS_CDAUDIO	EQU	1       ; audio from internal CD-ROM drive
AUXCAPS_AUXIN	EQU	2       ; audio from auxiliary input jacks
; flags for dwSupport field in AUXCAPS structure
AUXCAPS_VOLUME	EQU	0001H  ; supports volume control
AUXCAPS_LRVOLUME	EQU	0002H  ; separate left-right volume control
endif                                       ;both; ifndef MMNOAUX
ifndef MMNOTIMER                                               ;both
ifndef _WIN32_VXD
;***************************************************************************
;	    Timer support
;*************************************************************************
; timer error return values
TIMERR_NOERROR	EQU	(0)                  ; no error
TIMERR_NOCANDO	EQU	(TIMERR_BASE+1)      ; request not completed
TIMERR_STRUCT	EQU	(TIMERR_BASE+33)     ; time struct size
; flags for fuEvent parameter of timeSetEvent() function
TIME_ONESHOT	EQU	0000H   ; program timer for single event
TIME_PERIODIC	EQU	0001H   ; program for continuous periodic event
ifdef _WIN32
TIME_CALLBACK_FUNCTION	EQU	0000H  ; callback is function
TIME_CALLBACK_EVENT_SET	EQU	0010H  ; callback is event - use SetEvent
TIME_CALLBACK_EVENT_PULSE	EQU	0020H  ; callback is event - use PulseEvent
TIME_CALLBACK_TYPEMASK	EQU	00F0H  ;internal
endif

TIMECAPS	STRUC
tc_wPeriodMin	DW	?
tc_wPeriodMax	DW	?
TIMECAPS	ENDS
endif  ; ifndef _WIN32_VXD
endif                                    ;both; ifndef MMNOTIMER
ifndef MMNOJOY                                                 ;both
;***************************************************************************
;	    Joystick support
;*************************************************************************
; joystick error return values
JOYERR_NOERROR	EQU	(0)                  ; no error
JOYERR_PARMS	EQU	(JOYERR_BASE+5)      ; bad parameters
JOYERR_NOCANDO	EQU	(JOYERR_BASE+6)      ; request not completed
JOYERR_UNPLUGGED	EQU	(JOYERR_BASE+7)      ; joystick is unplugged
; constants used with JOYINFO and JOYINFOEX structures and MM_JOY* messages
JOY_BUTTON1	EQU	0001H
JOY_BUTTON2	EQU	0002H
JOY_BUTTON3	EQU	0004H
JOY_BUTTON4	EQU	0008H
JOY_BUTTON1CHG	EQU	0100H
JOY_BUTTON2CHG	EQU	0200H
JOY_BUTTON3CHG	EQU	0400H
JOY_BUTTON4CHG	EQU	0800H
; constants used with JOYINFOEX
JOY_BUTTON5	EQU	00000010H
JOY_BUTTON6	EQU	00000020H
JOY_BUTTON7	EQU	00000040H
JOY_BUTTON8	EQU	00000080H
JOY_BUTTON9	EQU	00000100H
JOY_BUTTON10	EQU	00000200H
JOY_BUTTON11	EQU	00000400H
JOY_BUTTON12	EQU	00000800H
JOY_BUTTON13	EQU	00001000H
JOY_BUTTON14	EQU	00002000H
JOY_BUTTON15	EQU	00004000H
JOY_BUTTON16	EQU	00008000H
JOY_BUTTON17	EQU	00010000H
JOY_BUTTON18	EQU	00020000H
JOY_BUTTON19	EQU	00040000H
JOY_BUTTON20	EQU	00080000H
JOY_BUTTON21	EQU	00100000H
JOY_BUTTON22	EQU	00200000H
JOY_BUTTON23	EQU	00400000H
JOY_BUTTON24	EQU	00800000H
JOY_BUTTON25	EQU	01000000H
JOY_BUTTON26	EQU	02000000H
JOY_BUTTON27	EQU	04000000H
JOY_BUTTON28	EQU	08000000H
JOY_BUTTON29	EQU	10000000H
JOY_BUTTON30	EQU	20000000H
JOY_BUTTON31	EQU	40000000H
JOY_BUTTON32	EQU	80000000H
; constants used with JOYINFOEX structure
JOY_POVCENTERED	EQU	-1
JOY_POVFORWARD	EQU	0
JOY_POVRIGHT	EQU	9000
JOY_POVBACKWARD	EQU	18000
JOY_POVLEFT	EQU	27000
JOY_RETURNX	EQU	00000001H
JOY_RETURNY	EQU	00000002H
JOY_RETURNZ	EQU	00000004H
JOY_RETURNR	EQU	00000008H
JOY_RETURNU	EQU	00000010H	; axis 5
JOY_RETURNV	EQU	00000020H	; axis 6
JOY_RETURNPOV	EQU	00000040H
JOY_RETURNBUTTONS	EQU	00000080H
JOY_RETURNRAWDATA	EQU	00000100H
JOY_RETURNPOVCTS	EQU	00000200H
JOY_RETURNCENTERED	EQU	00000400H
JOY_USEDEADZONE	EQU	00000800H
JOY_RETURNALL	EQU	(JOY_RETURNX OR JOY_RETURNY OR JOY_RETURNZ OR JOY_RETURNR OR JOY_RETURNU OR JOY_RETURNV OR JOY_RETURNPOV OR JOY_RETURNBUTTONS)
JOY_CAL_READALWAYS	EQU	00010000H
JOY_CAL_READXYONLY	EQU	00020000H
JOY_CAL_READ3	EQU	00040000H
JOY_CAL_READ4	EQU	00080000H
JOY_CAL_READXONLY	EQU	00100000H
JOY_CAL_READYONLY	EQU	00200000H
JOY_CAL_READ5	EQU	00400000H
JOY_CAL_READ6	EQU	00800000H
JOY_CAL_READZONLY	EQU	01000000H
JOY_CAL_READRONLY	EQU	02000000H
JOY_CAL_READUONLY	EQU	04000000H
JOY_CAL_READVONLY	EQU	08000000H
; joystick ID constants
JOYSTICKID1	EQU	0
JOYSTICKID2	EQU	1
; joystick driver capabilites
JOYCAPS_HASZ	EQU	0001H
JOYCAPS_HASR	EQU	0002H
JOYCAPS_HASU	EQU	0004H
JOYCAPS_HASV	EQU	0008H
JOYCAPS_HASPOV	EQU	0010H
JOYCAPS_POV4DIR	EQU	0020H
JOYCAPS_POVCTS	EQU	0040H

JOYCAPS	STRUC
jcaps_wMid	DW	?
jcaps_wPid	DW	?
jcaps_szPname	DB	MAXPNAMELEN DUP (?)
jcaps_wXmin	DW	?
jcaps_wXmax	DW	?
jcaps_wYmin	DW	?
jcaps_wYmax	DW	?
jcaps_wZmin	DW	?
jcaps_wZmax	DW	?
jcaps_wNumButtons	DW	?
jcaps_wPeriodMin	DW	?
jcaps_wPeriodMax	DW	?
jcaps_wRmin	DW	?
jcaps_wRmax	DW	?
jcaps_wUmin	DW	?
jcaps_wUmax	DW	?
jcaps_wVmin	DW	?
jcaps_wVmax	DW	?
jcaps_wCaps	DW	?
jcaps_wMaxAxes	DW	?
jcaps_wNumAxes	DW	?
jcaps_wMaxButtons	DW	?
jcaps_szRegKey	DB	MAXPNAMELEN DUP (?)
jcaps_szOEMVxD	DB	MAX_JOYSTICKOEMVXDNAME DUP (?)
JOYCAPS	ENDS

JOYINFO	STRUC
jinfo_wXpos	DW	?
jinfo_wYpos	DW	?
jinfo_wZpos	DW	?
jinfo_wButtons	DW	?
JOYINFO	ENDS

JOYINFOEX	STRUC
jinfoex_dwSize	DD	?
jinfoex_dwFlags	DD	?
jinfoex_dwXpos	DD	?
jinfoex_dwYpos	DD	?
jinfoex_dwZpos	DD	?
jinfoex_dwRpos	DD	?
jinfoex_dwUpos	DD	?
jinfoex_dwVpos	DD	?
jinfoex_dwButtons	DD	?
jinfoex_dwButtonNumber	DD	?
jinfoex_dwPOV	DD	?
jinfoex_dwReserved1	DD	?
jinfoex_dwReserved2	DD	?
JOYINFOEX	ENDS
endif                                       ;both; ifndef MMNOJOY
ifndef MMNOMMIO                                                ;both
ifndef _WIN32_VXD
;***************************************************************************
;	Multimedia File I/O support
;*************************************************************************
; MMIO error return values
MMIOERR_BASE	EQU	256
MMIOERR_FILENOTFOUND	EQU	(MMIOERR_BASE+1)  ; file not found
MMIOERR_OUTOFMEMORY	EQU	(MMIOERR_BASE+2)  ; out of memory
MMIOERR_CANNOTOPEN	EQU	(MMIOERR_BASE+3)  ; cannot open
MMIOERR_CANNOTCLOSE	EQU	(MMIOERR_BASE+4)  ; cannot close
MMIOERR_CANNOTREAD	EQU	(MMIOERR_BASE+5)  ; cannot read
MMIOERR_CANNOTWRITE	EQU	(MMIOERR_BASE+6)  ; cannot write
MMIOERR_CANNOTSEEK	EQU	(MMIOERR_BASE+7)  ; cannot seek
MMIOERR_CANNOTEXPAND	EQU	(MMIOERR_BASE+8)  ; cannot expand file
MMIOERR_CHUNKNOTFOUND	EQU	(MMIOERR_BASE+9)  ; chunk not found
MMIOERR_UNBUFFERED	EQU	(MMIOERR_BASE+10) ;
MMIOERR_PATHNOTFOUND	EQU	(MMIOERR_BASE+11) ; path incorrect
MMIOERR_ACCESSDENIED	EQU	(MMIOERR_BASE+12) ; file was protected
MMIOERR_SHARINGVIOLATION	EQU	(MMIOERR_BASE+13) ; file in use
MMIOERR_NETWORKERROR	EQU	(MMIOERR_BASE+14) ; network not responding
MMIOERR_TOOMANYOPENFILES	EQU	(MMIOERR_BASE+15) ; no more file handles
MMIOERR_INVALIDFILE	EQU	(MMIOERR_BASE+16) ; default error file error
; MMIO constants
CFSEPCHAR	EQU	<'+'>             ; compound file name separator char.

MMIOINFO	STRUC
mmio_dwFlags	DD	?
mmio_fccIOProc	DD	?
mmio_pIOProc	DD	?
mmio_wErrorRet	DW	?
mmio_htask	DW	?
mmio_cchBuffer	DD	?
mmio_pchBuffer	DD	?
mmio_pchNext	DD	?
mmio_pchEndRead	DD	?
mmio_pchEndWrite	DD	?
mmio_lBufOffset	DD	?
mmio_lDiskOffset	DD	?
mmio_adwInfo	DD	3 DUP (?)
mmio_dwReserved1	DD	?
mmio_dwReserved2	DD	?
mmio_hmmio	DW	?
MMIOINFO	ENDS
; bit field masks
MMIO_RWMODE	EQU	00000003H      ; open file for reading/writing/both
MMIO_SHAREMODE	EQU	00000070H      ; file sharing mode number
; constants for dwFlags field of MMIOINFO
MMIO_CREATE	EQU	00001000H      ; create new file (or truncate file)
MMIO_PARSE	EQU	00000100H      ; parse new file returning path
MMIO_DELETE	EQU	00000200H      ; create new file (or truncate file)
MMIO_EXIST	EQU	00004000H      ; checks for existence of file
MMIO_ALLOCBUF	EQU	00010000H      ; mmioOpen() should allocate a buffer
MMIO_GETTEMP	EQU	00020000H      ; mmioOpen() should retrieve temp name
MMIO_DIRTY	EQU	10000000H      ; I/O buffer is dirty
; read/write mode numbers (bit field MMIO_RWMODE)
MMIO_READ	EQU	00000000H      ; open file for reading only
MMIO_WRITE	EQU	00000001H      ; open file for writing only
MMIO_READWRITE	EQU	00000002H      ; open file for reading and writing
; share mode numbers (bit field MMIO_SHAREMODE)
MMIO_COMPAT	EQU	00000000H      ; compatibility mode
MMIO_EXCLUSIVE	EQU	00000010H      ; exclusive-access mode
MMIO_DENYWRITE	EQU	00000020H      ; deny writing to other processes
MMIO_DENYREAD	EQU	00000030H      ; deny reading to other processes
MMIO_DENYNONE	EQU	00000040H      ; deny nothing to other processes
; various MMIO flags
MMIO_FHOPEN	EQU	0010H  ; mmioClose: keep file handle open
MMIO_EMPTYBUF	EQU	0010H  ; mmioFlush: empty the I/O buffer
MMIO_TOUPPER	EQU	0010H  ; mmioStringToFOURCC: to u-case
MMIO_INSTALLPROC	EQU	00010000H  ; mmioInstallIOProc: install MMIOProc
MMIO_GLOBALPROC	EQU	10000000H  ; mmioInstallIOProc: install globally
MMIO_REMOVEPROC	EQU	00020000H  ; mmioInstallIOProc: remove MMIOProc
MMIO_UNICODEPROC	EQU	01000000H  ; mmioInstallIOProc: Unicode MMIOProc
MMIO_FINDPROC	EQU	00040000H  ; mmioInstallIOProc: find an MMIOProc
MMIO_FINDCHUNK	EQU	0010H  ; mmioDescend: find a chunk by ID
MMIO_FINDRIFF	EQU	0020H  ; mmioDescend: find a LIST chunk
MMIO_FINDLIST	EQU	0040H  ; mmioDescend: find a RIFF chunk
MMIO_CREATERIFF	EQU	0020H  ; mmioCreateChunk: make a LIST chunk
MMIO_CREATELIST	EQU	0040H  ; mmioCreateChunk: make a RIFF chunk
; message numbers for MMIOPROC I/O procedure functions
MMIOM_READ	EQU	MMIO_READ       ; read
MMIOM_WRITE	EQU	MMIO_WRITE       ; write
MMIOM_SEEK	EQU	2       ; seek to a new position in file
MMIOM_OPEN	EQU	3       ; open file
MMIOM_CLOSE	EQU	4       ; close file
MMIOM_WRITEFLUSH	EQU	5       ; write and flush
MMIOM_RENAME	EQU	6       ; rename specified file
MMIOM_USER	EQU	8000H       ; beginning of user-defined messages
; flags for mmioSeek()
ifndef SEEK_SET
SEEK_SET	EQU	0               ; seek to an absolute position
SEEK_CUR	EQU	1               ; seek relative to current position
SEEK_END	EQU	2               ; seek relative to end of file
endif  ; ifndef SEEK_SET
; other constants
MMIO_DEFAULTBUFFER	EQU	8192    ; default buffer size
endif  ; ifndef _WIN32_VXD
endif                                     ;both; ifndef MMNOMMIO
ifndef MMNOMCI                                                 ;both
ifndef _WIN32_VXD
; MCI error return values
MCIERR_INVALID_DEVICE_ID	EQU	(MCIERR_BASE+1)
MCIERR_UNRECOGNIZED_KEYWORD	EQU	(MCIERR_BASE+3)
MCIERR_UNRECOGNIZED_COMMAND	EQU	(MCIERR_BASE+5)
MCIERR_HARDWARE	EQU	(MCIERR_BASE+6)
MCIERR_INVALID_DEVICE_NAME	EQU	(MCIERR_BASE+7)
MCIERR_OUT_OF_MEMORY	EQU	(MCIERR_BASE+8)
MCIERR_DEVICE_OPEN	EQU	(MCIERR_BASE+9)
MCIERR_CANNOT_LOAD_DRIVER	EQU	(MCIERR_BASE+10)
MCIERR_MISSING_COMMAND_STRING	EQU	(MCIERR_BASE+11)
MCIERR_PARAM_OVERFLOW	EQU	(MCIERR_BASE+12)
MCIERR_MISSING_STRING_ARGUMENT	EQU	(MCIERR_BASE+13)
MCIERR_BAD_INTEGER	EQU	(MCIERR_BASE+14)
MCIERR_PARSER_INTERNAL	EQU	(MCIERR_BASE+15)
MCIERR_DRIVER_INTERNAL	EQU	(MCIERR_BASE+16)
MCIERR_MISSING_PARAMETER	EQU	(MCIERR_BASE+17)
MCIERR_UNSUPPORTED_FUNCTION	EQU	(MCIERR_BASE+18)
MCIERR_FILE_NOT_FOUND	EQU	(MCIERR_BASE+19)
MCIERR_DEVICE_NOT_READY	EQU	(MCIERR_BASE+20)
MCIERR_INTERNAL	EQU	(MCIERR_BASE+21)
MCIERR_DRIVER	EQU	(MCIERR_BASE+22)
MCIERR_CANNOT_USE_ALL	EQU	(MCIERR_BASE+23)
MCIERR_MULTIPLE	EQU	(MCIERR_BASE+24)
MCIERR_EXTENSION_NOT_FOUND	EQU	(MCIERR_BASE+25)
MCIERR_OUTOFRANGE	EQU	(MCIERR_BASE+26)
MCIERR_FLAGS_NOT_COMPATIBLE	EQU	(MCIERR_BASE+28)
MCIERR_FILE_NOT_SAVED	EQU	(MCIERR_BASE+30)
MCIERR_DEVICE_TYPE_REQUIRED	EQU	(MCIERR_BASE+31)
MCIERR_DEVICE_LOCKED	EQU	(MCIERR_BASE+32)
MCIERR_DUPLICATE_ALIAS	EQU	(MCIERR_BASE+33)
MCIERR_BAD_CONSTANT	EQU	(MCIERR_BASE+34)
MCIERR_MUST_USE_SHAREABLE	EQU	(MCIERR_BASE+35)
MCIERR_MISSING_DEVICE_NAME	EQU	(MCIERR_BASE+36)
MCIERR_BAD_TIME_FORMAT	EQU	(MCIERR_BASE+37)
MCIERR_NO_CLOSING_QUOTE	EQU	(MCIERR_BASE+38)
MCIERR_DUPLICATE_FLAGS	EQU	(MCIERR_BASE+39)
MCIERR_INVALID_FILE	EQU	(MCIERR_BASE+40)
MCIERR_NULL_PARAMETER_BLOCK	EQU	(MCIERR_BASE+41)
MCIERR_UNNAMED_RESOURCE	EQU	(MCIERR_BASE+42)
MCIERR_NEW_REQUIRES_ALIAS	EQU	(MCIERR_BASE+43)
MCIERR_NOTIFY_ON_AUTO_OPEN	EQU	(MCIERR_BASE+44)
MCIERR_NO_ELEMENT_ALLOWED	EQU	(MCIERR_BASE+45)
MCIERR_NONAPPLICABLE_FUNCTION	EQU	(MCIERR_BASE+46)
MCIERR_ILLEGAL_FOR_AUTO_OPEN	EQU	(MCIERR_BASE+47)
MCIERR_FILENAME_REQUIRED	EQU	(MCIERR_BASE+48)
MCIERR_EXTRA_CHARACTERS	EQU	(MCIERR_BASE+49)
MCIERR_DEVICE_NOT_INSTALLED	EQU	(MCIERR_BASE+50)
MCIERR_GET_CD	EQU	(MCIERR_BASE+51)
MCIERR_SET_CD	EQU	(MCIERR_BASE+52)
MCIERR_SET_DRIVE	EQU	(MCIERR_BASE+53)
MCIERR_DEVICE_LENGTH	EQU	(MCIERR_BASE+54)
MCIERR_DEVICE_ORD_LENGTH	EQU	(MCIERR_BASE+55)
MCIERR_NO_INTEGER	EQU	(MCIERR_BASE+56)
MCIERR_WAVE_OUTPUTSINUSE	EQU	(MCIERR_BASE+64)
MCIERR_WAVE_SETOUTPUTINUSE	EQU	(MCIERR_BASE+65)
MCIERR_WAVE_INPUTSINUSE	EQU	(MCIERR_BASE+66)
MCIERR_WAVE_SETINPUTINUSE	EQU	(MCIERR_BASE+67)
MCIERR_WAVE_OUTPUTUNSPECIFIED	EQU	(MCIERR_BASE+68)
MCIERR_WAVE_INPUTUNSPECIFIED	EQU	(MCIERR_BASE+69)
MCIERR_WAVE_OUTPUTSUNSUITABLE	EQU	(MCIERR_BASE+70)
MCIERR_WAVE_SETOUTPUTUNSUITABLE	EQU	(MCIERR_BASE+71)
MCIERR_WAVE_INPUTSUNSUITABLE	EQU	(MCIERR_BASE+72)
MCIERR_WAVE_SETINPUTUNSUITABLE	EQU	(MCIERR_BASE+73)
MCIERR_SEQ_DIV_INCOMPATIBLE	EQU	(MCIERR_BASE+80)
MCIERR_SEQ_PORT_INUSE	EQU	(MCIERR_BASE+81)
MCIERR_SEQ_PORT_NONEXISTENT	EQU	(MCIERR_BASE+82)
MCIERR_SEQ_PORT_MAPNODEVICE	EQU	(MCIERR_BASE+83)
MCIERR_SEQ_PORT_MISCERROR	EQU	(MCIERR_BASE+84)
MCIERR_SEQ_TIMER	EQU	(MCIERR_BASE+85)
MCIERR_SEQ_PORTUNSPECIFIED	EQU	(MCIERR_BASE+86)
MCIERR_SEQ_NOMIDIPRESENT	EQU	(MCIERR_BASE+87)
MCIERR_NO_WINDOW	EQU	(MCIERR_BASE+90)
MCIERR_CREATEWINDOW	EQU	(MCIERR_BASE+91)
MCIERR_FILE_READ	EQU	(MCIERR_BASE+92)
MCIERR_FILE_WRITE	EQU	(MCIERR_BASE+93)
MCIERR_NO_IDENTITY	EQU	(MCIERR_BASE+94)
; all custom device driver errors must be >= than this value
MCIERR_CUSTOM_DRIVER_BASE	EQU	(MCIERR_BASE+256)
MCI_FIRST	EQU	DRV_MCI_FIRST   ; 0x0800
; MCI command message identifiers
MCI_OPEN	EQU	0803H
MCI_CLOSE	EQU	0804H
MCI_ESCAPE	EQU	0805H
MCI_PLAY	EQU	0806H
MCI_SEEK	EQU	0807H
MCI_STOP	EQU	0808H
MCI_PAUSE	EQU	0809H
MCI_INFO	EQU	080AH
MCI_GETDEVCAPS	EQU	080BH
MCI_SPIN	EQU	080CH
MCI_SET	EQU	080DH
MCI_STEP	EQU	080EH
MCI_RECORD	EQU	080FH
MCI_SYSINFO	EQU	0810H
MCI_BREAK	EQU	0811H
MCI_SOUND	EQU	0812H    ;internal
MCI_SAVE	EQU	0813H
MCI_STATUS	EQU	0814H
MCI_CUE	EQU	0830H
MCI_REALIZE	EQU	0840H
MCI_WINDOW	EQU	0841H
MCI_PUT	EQU	0842H
MCI_WHERE	EQU	0843H
MCI_FREEZE	EQU	0844H
MCI_UNFREEZE	EQU	0845H
MCI_LOAD	EQU	0850H
MCI_CUT	EQU	0851H
MCI_COPY	EQU	0852H
MCI_PASTE	EQU	0853H
MCI_UPDATE	EQU	0854H
MCI_RESUME	EQU	0855H
MCI_DELETE	EQU	0856H
MCI_WIN32CLIENT	EQU	0857H	;internal
; all custom MCI command messages must be >= than this value
MCI_USER_MESSAGES	EQU	(DRV_MCI_FIRST+400H)
MCI_LAST	EQU	0FFFH
MCI_ALL_DEVICE_ID	EQU	-1
; constants for predefined MCI device types
MCI_DEVTYPE_VCR	EQU	513 ; (MCI_STRING_OFFSET + 1)
MCI_DEVTYPE_VIDEODISC	EQU	514 ; (MCI_STRING_OFFSET + 2)
MCI_DEVTYPE_OVERLAY	EQU	515 ; (MCI_STRING_OFFSET + 3)
MCI_DEVTYPE_CD_AUDIO	EQU	516 ; (MCI_STRING_OFFSET + 4)
MCI_DEVTYPE_DAT	EQU	517 ; (MCI_STRING_OFFSET + 5)
MCI_DEVTYPE_SCANNER	EQU	518 ; (MCI_STRING_OFFSET + 6)
MCI_DEVTYPE_ANIMATION	EQU	519 ; (MCI_STRING_OFFSET + 7)
MCI_DEVTYPE_DIGITAL_VIDEO	EQU	520 ; (MCI_STRING_OFFSET + 8)
MCI_DEVTYPE_OTHER	EQU	521 ; (MCI_STRING_OFFSET + 9)
MCI_DEVTYPE_WAVEFORM_AUDIO	EQU	522 ; (MCI_STRING_OFFSET + 10)
MCI_DEVTYPE_SEQUENCER	EQU	523 ; (MCI_STRING_OFFSET + 11)
MCI_DEVTYPE_FIRST	EQU	MCI_DEVTYPE_VCR
MCI_DEVTYPE_LAST	EQU	MCI_DEVTYPE_SEQUENCER
MCI_DEVTYPE_FIRST_USER	EQU	1000H
; return values for 'status mode' command
MCI_MODE_NOT_READY	EQU	(MCI_STRING_OFFSET+12)
MCI_MODE_STOP	EQU	(MCI_STRING_OFFSET+13)
MCI_MODE_PLAY	EQU	(MCI_STRING_OFFSET+14)
MCI_MODE_RECORD	EQU	(MCI_STRING_OFFSET+15)
MCI_MODE_SEEK	EQU	(MCI_STRING_OFFSET+16)
MCI_MODE_PAUSE	EQU	(MCI_STRING_OFFSET+17)
MCI_MODE_OPEN	EQU	(MCI_STRING_OFFSET+18)
; constants used in 'set time format' and 'status time format' commands
MCI_FORMAT_MILLISECONDS	EQU	0
MCI_FORMAT_HMS	EQU	1
MCI_FORMAT_MSF	EQU	2
MCI_FORMAT_FRAMES	EQU	3
MCI_FORMAT_SMPTE_24	EQU	4
MCI_FORMAT_SMPTE_25	EQU	5
MCI_FORMAT_SMPTE_30	EQU	6
MCI_FORMAT_SMPTE_30DROP	EQU	7
MCI_FORMAT_BYTES	EQU	8
MCI_FORMAT_SAMPLES	EQU	9
MCI_FORMAT_TMSF	EQU	10
; flags for wParam of MM_MCINOTIFY message
MCI_NOTIFY_SUCCESSFUL	EQU	0001H
MCI_NOTIFY_SUPERSEDED	EQU	0002H
MCI_NOTIFY_ABORTED	EQU	0004H
MCI_NOTIFY_FAILURE	EQU	0008H
; common flags for dwFlags parameter of MCI command messages
MCI_NOTIFY	EQU	00000001H
MCI_WAIT	EQU	00000002H
MCI_FROM	EQU	00000004H
MCI_TO	EQU	00000008H
MCI_TRACK	EQU	00000010H
; flags for dwFlags parameter of MCI_OPEN command message
MCI_OPEN_SHAREABLE	EQU	00000100H
MCI_OPEN_ELEMENT	EQU	00000200H
MCI_OPEN_ALIAS	EQU	00000400H
MCI_OPEN_ELEMENT_ID	EQU	00000800H
MCI_OPEN_TYPE_ID	EQU	00001000H
MCI_OPEN_TYPE	EQU	00002000H
; flags for dwFlags parameter of MCI_SEEK command message
MCI_SEEK_TO_START	EQU	00000100H
MCI_SEEK_TO_END	EQU	00000200H
; flags for dwFlags parameter of MCI_STATUS command message
MCI_STATUS_ITEM	EQU	00000100H
MCI_STATUS_START	EQU	00000200H
; flags for dwItem field of the MCI_STATUS_PARMS parameter block
MCI_STATUS_LENGTH	EQU	00000001H
MCI_STATUS_POSITION	EQU	00000002H
MCI_STATUS_NUMBER_OF_TRACKS	EQU	00000003H
MCI_STATUS_MODE	EQU	00000004H
MCI_STATUS_MEDIA_PRESENT	EQU	00000005H
MCI_STATUS_TIME_FORMAT	EQU	00000006H
MCI_STATUS_READY	EQU	00000007H
MCI_STATUS_CURRENT_TRACK	EQU	00000008H
; flags for dwFlags parameter of MCI_INFO command message
MCI_INFO_PRODUCT	EQU	00000100H
MCI_INFO_FILE	EQU	00000200H
MCI_INFO_MEDIA_UPC	EQU	00000400H
MCI_INFO_MEDIA_IDENTITY	EQU	00000800H
MCI_INFO_NAME	EQU	00001000H
MCI_INFO_COPYRIGHT	EQU	00002000H
; flags for dwFlags parameter of MCI_GETDEVCAPS command message
MCI_GETDEVCAPS_ITEM	EQU	00000100H
; flags for dwItem field of the MCI_GETDEVCAPS_PARMS parameter block
MCI_GETDEVCAPS_CAN_RECORD	EQU	00000001H
MCI_GETDEVCAPS_HAS_AUDIO	EQU	00000002H
MCI_GETDEVCAPS_HAS_VIDEO	EQU	00000003H
MCI_GETDEVCAPS_DEVICE_TYPE	EQU	00000004H
MCI_GETDEVCAPS_USES_FILES	EQU	00000005H
MCI_GETDEVCAPS_COMPOUND_DEVICE	EQU	00000006H
MCI_GETDEVCAPS_CAN_EJECT	EQU	00000007H
MCI_GETDEVCAPS_CAN_PLAY	EQU	00000008H
MCI_GETDEVCAPS_CAN_SAVE	EQU	00000009H
; flags for dwFlags parameter of MCI_SYSINFO command message
MCI_SYSINFO_QUANTITY	EQU	00000100H
MCI_SYSINFO_OPEN	EQU	00000200H
MCI_SYSINFO_NAME	EQU	00000400H
MCI_SYSINFO_INSTALLNAME	EQU	00000800H
; flags for dwFlags parameter of MCI_SET command message
MCI_SET_DOOR_OPEN	EQU	00000100H
MCI_SET_DOOR_CLOSED	EQU	00000200H
MCI_SET_TIME_FORMAT	EQU	00000400H
MCI_SET_AUDIO	EQU	00000800H
MCI_SET_VIDEO	EQU	00001000H
MCI_SET_ON	EQU	00002000H
MCI_SET_OFF	EQU	00004000H
; flags for dwAudio field of MCI_SET_PARMS or MCI_SEQ_SET_PARMS
MCI_SET_AUDIO_ALL	EQU	00000000H
MCI_SET_AUDIO_LEFT	EQU	00000001H
MCI_SET_AUDIO_RIGHT	EQU	00000002H
; flags for dwFlags parameter of MCI_BREAK command message
MCI_BREAK_KEY	EQU	00000100H
MCI_BREAK_HWND	EQU	00000200H
MCI_BREAK_OFF	EQU	00000400H
; flags for dwFlags parameter of MCI_RECORD command message
MCI_RECORD_INSERT	EQU	00000100H
MCI_RECORD_OVERWRITE	EQU	00000200H
	;internal; flags for dwFlags parameter of MCI_SOUND command message
MCI_SOUND_NAME	EQU	00000100H		;internal
								;internal
; flags for dwFlags parameter of MCI_SAVE command message
MCI_SAVE_FILE	EQU	00000100H
; flags for dwFlags parameter of MCI_LOAD command message
MCI_LOAD_FILE	EQU	00000100H

MCI_GENERIC_PARMS	STRUC
mcigen_dwCallback	DD	?
MCI_GENERIC_PARMS	ENDS

MCI_OPEN_PARMS	STRUC
mciopen_dwCallback	DD	?
mciopen_wDeviceID	DW	?
mciopen_wReserved0	DW	?
mciopen_lpstrDeviceType	DD	?
mciopen_lpstrElementName	DD	?
mciopen_lpstrAlias	DD	?
MCI_OPEN_PARMS	ENDS

MCI_PLAY_PARMS	STRUC
mciplay_dwCallback	DD	?
mciplay_dwFrom	DD	?
mciplay_dwTo	DD	?
MCI_PLAY_PARMS	ENDS

MCI_SEEK_PARMS	STRUC
mciseek_dwCallback	DD	?
mciseek_dwTo	DD	?
MCI_SEEK_PARMS	ENDS

MCI_STATUS_PARMS	STRUC
mcistat_dwCallback	DD	?
mcistat_dwReturn	DD	?
mcistat_dwItem	DD	?
mcistat_dwTrack	DD	?
MCI_STATUS_PARMS	ENDS

MCI_INFO_PARMS	STRUC
mciinfo_dwCallback	DD	?
mciinfo_lpstrReturn	DD	?
mciinfo_dwRetSize	DD	?
MCI_INFO_PARMS	ENDS

MCI_GETDEVCAPS_PARMS	STRUC
mcigdc_dwCallback	DD	?
mcigdc_dwReturn	DD	?
mcigdc_dwItem	DD	?
MCI_GETDEVCAPS_PARMS	ENDS

MCI_SYSINFO_PARMS	STRUC
mcisi_dwCallback	DD	?
mcisi_lpstrReturn	DD	?
mcisi_dwRetSize	DD	?
mcisi_dwNumber	DD	?
mcisi_wDeviceType	DW	?
mcisi_wReserved0	DW	?
MCI_SYSINFO_PARMS	ENDS

MCI_SET_PARMS	STRUC
mciset_dwCallback	DD	?
mciset_dwTimeFormat	DD	?
mciset_dwAudio	DD	?
MCI_SET_PARMS	ENDS

MCI_BREAK_PARMS	STRUC
mcibreak_dwCallback	DD	?
mcibreak_nVirtKey	DW	?
mcibreak_wReserved0	DW	?
mcibreak_hwndBreak	DW	?
mcibreak_wReserved1	DW	?
MCI_BREAK_PARMS	ENDS

MCI_SAVE_PARMS	STRUC
mcisave_dwCallback	DD	?
mcisave_lpfilename	DD	?
MCI_SAVE_PARMS	ENDS

MCI_LOAD_PARMS	STRUC
mciload_dwCallback	DD	?
mciload_lpfilename	DD	?
MCI_LOAD_PARMS	ENDS

MCI_RECORD_PARMS	STRUC
mcirec_dwCallback	DD	?
mcirec_dwFrom	DD	?
mcirec_dwTo	DD	?
MCI_RECORD_PARMS	ENDS
; MCI extensions for videodisc devices
; flag for dwReturn field of MCI_STATUS_PARMS
; MCI_STATUS command, (dwItem == MCI_STATUS_MODE)
MCI_VD_MODE_PARK	EQU	(MCI_VD_OFFSET+1)
; flag for dwReturn field of MCI_STATUS_PARMS
; MCI_STATUS command, (dwItem == MCI_VD_STATUS_MEDIA_TYPE)
MCI_VD_MEDIA_CLV	EQU	(MCI_VD_OFFSET+2)
MCI_VD_MEDIA_CAV	EQU	(MCI_VD_OFFSET+3)
MCI_VD_MEDIA_OTHER	EQU	(MCI_VD_OFFSET+4)
MCI_VD_FORMAT_TRACK	EQU	4001H
; flags for dwFlags parameter of MCI_PLAY command message
MCI_VD_PLAY_REVERSE	EQU	00010000H
MCI_VD_PLAY_FAST	EQU	00020000H
MCI_VD_PLAY_SPEED	EQU	00040000H
MCI_VD_PLAY_SCAN	EQU	00080000H
MCI_VD_PLAY_SLOW	EQU	00100000H
; flag for dwFlags parameter of MCI_SEEK command message
MCI_VD_SEEK_REVERSE	EQU	00010000H
; flags for dwItem field of MCI_STATUS_PARMS parameter block
MCI_VD_STATUS_SPEED	EQU	00004002H
MCI_VD_STATUS_FORWARD	EQU	00004003H
MCI_VD_STATUS_MEDIA_TYPE	EQU	00004004H
MCI_VD_STATUS_SIDE	EQU	00004005H
MCI_VD_STATUS_DISC_SIZE	EQU	00004006H
; flags for dwFlags parameter of MCI_GETDEVCAPS command message
MCI_VD_GETDEVCAPS_CLV	EQU	00010000H
MCI_VD_GETDEVCAPS_CAV	EQU	00020000H
MCI_VD_SPIN_UP	EQU	00010000H
MCI_VD_SPIN_DOWN	EQU	00020000H
; flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block
MCI_VD_GETDEVCAPS_CAN_REVERSE	EQU	00004002H
MCI_VD_GETDEVCAPS_FAST_RATE	EQU	00004003H
MCI_VD_GETDEVCAPS_SLOW_RATE	EQU	00004004H
MCI_VD_GETDEVCAPS_NORMAL_RATE	EQU	00004005H
; flags for the dwFlags parameter of MCI_STEP command message
MCI_VD_STEP_FRAMES	EQU	00010000H
MCI_VD_STEP_REVERSE	EQU	00020000H
; flag for the MCI_ESCAPE command message
MCI_VD_ESCAPE_STRING	EQU	00000100H

MCI_VD_PLAY_PARMS	STRUC
mcivdplay_dwCallback	DD	?
mcivdplay_dwFrom	DD	?
mcivdplay_dwTo	DD	?
mcivdplay_dwSpeed	DD	?
MCI_VD_PLAY_PARMS	ENDS

MCI_VD_STEP_PARMS	STRUC
mcivdstep_dwCallback	DD	?
mcivdstep_dwFrames	DD	?
MCI_VD_STEP_PARMS	ENDS

MCI_VD_ESCAPE_PARMS	STRUC
mcivcesc_dwCallback	DD	?
mcivcesc_lpstrCommand	DD	?
MCI_VD_ESCAPE_PARMS	ENDS
; MCI extensions for CD audio devices
; flags for the dwItem field of the MCI_STATUS_PARMS parameter block
MCI_CDA_STATUS_TYPE_TRACK	EQU	00004001H
; flags for the dwReturn field of MCI_STATUS_PARMS parameter block
; MCI_STATUS command, (dwItem == MCI_CDA_STATUS_TYPE_TRACK)
MCI_CDA_TRACK_AUDIO	EQU	(MCI_CD_OFFSET+0)
MCI_CDA_TRACK_OTHER	EQU	(MCI_CD_OFFSET+1)
; MCI extensions for waveform audio devices
MCI_WAVE_PCM	EQU	(MCI_WAVE_OFFSET+0)
MCI_WAVE_MAPPER	EQU	(MCI_WAVE_OFFSET+1)
; flags for the dwFlags parameter of MCI_OPEN command message
MCI_WAVE_OPEN_BUFFER	EQU	00010000H
; flags for the dwFlags parameter of MCI_SET command message
MCI_WAVE_SET_FORMATTAG	EQU	00010000H
MCI_WAVE_SET_CHANNELS	EQU	00020000H
MCI_WAVE_SET_SAMPLESPERSEC	EQU	00040000H
MCI_WAVE_SET_AVGBYTESPERSEC	EQU	00080000H
MCI_WAVE_SET_BLOCKALIGN	EQU	00100000H
MCI_WAVE_SET_BITSPERSAMPLE	EQU	00200000H
; flags for the dwFlags parameter of MCI_STATUS, MCI_SET command messages
MCI_WAVE_INPUT	EQU	00400000H
MCI_WAVE_OUTPUT	EQU	00800000H
; flags for the dwItem field of MCI_STATUS_PARMS parameter block
MCI_WAVE_STATUS_FORMATTAG	EQU	00004001H
MCI_WAVE_STATUS_CHANNELS	EQU	00004002H
MCI_WAVE_STATUS_SAMPLESPERSEC	EQU	00004003H
MCI_WAVE_STATUS_AVGBYTESPERSEC	EQU	00004004H
MCI_WAVE_STATUS_BLOCKALIGN	EQU	00004005H
MCI_WAVE_STATUS_BITSPERSAMPLE	EQU	00004006H
MCI_WAVE_STATUS_LEVEL	EQU	00004007H
; flags for the dwFlags parameter of MCI_SET command message
MCI_WAVE_SET_ANYINPUT	EQU	04000000H
MCI_WAVE_SET_ANYOUTPUT	EQU	08000000H
; flags for the dwFlags parameter of MCI_GETDEVCAPS command message
MCI_WAVE_GETDEVCAPS_INPUTS	EQU	00004001H
MCI_WAVE_GETDEVCAPS_OUTPUTS	EQU	00004002H

MCI_WAVE_OPEN_PARMS	STRUC
mciwopen_dwCallback	DD	?
mciwopen_wDeviceID	DW	?
mciwopen_wReserved0	DW	?
mciwopen_lpstrDeviceType	DD	?
mciwopen_lpstrElementName	DD	?
mciwopen_lpstrAlias	DD	?
mciwopen_dwBufferSeconds	DD	?
MCI_WAVE_OPEN_PARMS	ENDS

MCI_WAVE_DELETE_PARMS	STRUC
mciwdel_dwCallback	DD	?
mciwdel_dwFrom	DD	?
mciwdel_dwTo	DD	?
MCI_WAVE_DELETE_PARMS	ENDS

MCI_WAVE_SET_PARMS	STRUC
mciwset_dwCallback	DD	?
mciwset_dwTimeFormat	DD	?
mciwset_dwAudio	DD	?
mciwset_wInput	DW	?
mciwset_wReserved0	DW	?
mciwset_wOutput	DW	?
mciwset_wReserved1	DW	?
mciwset_wFormatTag	DW	?
mciwset_wReserved2	DW	?
mciwset_nChannels	DW	?
mciwset_wReserved3	DW	?
mciwset_nSamplesPerSec	DW	?
mciwset_nAvgBytesPerSec	DW	?
mciwset_nBlockAlign	DW	?
mciwset_wReserved4	DW	?
mciwset_wBitsPerSample	DW	?
mciwset_wReserved5	DW	?
MCI_WAVE_SET_PARMS	ENDS
; MCI extensions for MIDI sequencer devices
; flags for the dwReturn field of MCI_STATUS_PARMS parameter block
; MCI_STATUS command, (dwItem == MCI_SEQ_STATUS_DIVTYPE)
MCI_SEQ_DIV_PPQN	EQU	(0+MCI_SEQ_OFFSET)
MCI_SEQ_DIV_SMPTE_24	EQU	(1+MCI_SEQ_OFFSET)
MCI_SEQ_DIV_SMPTE_25	EQU	(2+MCI_SEQ_OFFSET)
MCI_SEQ_DIV_SMPTE_30DROP	EQU	(3+MCI_SEQ_OFFSET)
MCI_SEQ_DIV_SMPTE_30	EQU	(4+MCI_SEQ_OFFSET)
; flags for the dwMaster field of MCI_SEQ_SET_PARMS parameter block
; MCI_SET command, (dwFlags == MCI_SEQ_SET_MASTER)
MCI_SEQ_FORMAT_SONGPTR	EQU	4001H
MCI_SEQ_FILE	EQU	4002H
MCI_SEQ_MIDI	EQU	4003H
MCI_SEQ_SMPTE	EQU	4004H
MCI_SEQ_NONE	EQU	65533
MCI_SEQ_MAPPER	EQU	65535
; flags for the dwItem field of MCI_STATUS_PARMS parameter block
MCI_SEQ_STATUS_TEMPO	EQU	00004002H
MCI_SEQ_STATUS_PORT	EQU	00004003H
MCI_SEQ_STATUS_SLAVE	EQU	00004007H
MCI_SEQ_STATUS_MASTER	EQU	00004008H
MCI_SEQ_STATUS_OFFSET	EQU	00004009H
MCI_SEQ_STATUS_DIVTYPE	EQU	0000400AH
MCI_SEQ_STATUS_NAME	EQU	0000400BH
MCI_SEQ_STATUS_COPYRIGHT	EQU	0000400CH
; flags for the dwFlags parameter of MCI_SET command message
MCI_SEQ_SET_TEMPO	EQU	00010000H
MCI_SEQ_SET_PORT	EQU	00020000H
MCI_SEQ_SET_SLAVE	EQU	00040000H
MCI_SEQ_SET_MASTER	EQU	00080000H
MCI_SEQ_SET_OFFSET	EQU	01000000H

MCI_SEQ_SET_PARMS	STRUC
mcisset_dwCallback	DD	?
mcisset_dwTimeFormat	DD	?
mcisset_dwAudio	DD	?
mcisset_dwTempo	DD	?
mcisset_dwPort	DD	?
mcisset_dwSlave	DD	?
mcisset_dwMaster	DD	?
mcisset_dwOffset	DD	?
MCI_SEQ_SET_PARMS	ENDS
; MCI extensions for animation devices
; flags for dwFlags parameter of MCI_OPEN command message
MCI_ANIM_OPEN_WS	EQU	00010000H
MCI_ANIM_OPEN_PARENT	EQU	00020000H
MCI_ANIM_OPEN_NOSTATIC	EQU	00040000H
; flags for dwFlags parameter of MCI_PLAY command message
MCI_ANIM_PLAY_SPEED	EQU	00010000H
MCI_ANIM_PLAY_REVERSE	EQU	00020000H
MCI_ANIM_PLAY_FAST	EQU	00040000H
MCI_ANIM_PLAY_SLOW	EQU	00080000H
MCI_ANIM_PLAY_SCAN	EQU	00100000H
; flags for dwFlags parameter of MCI_STEP command message
MCI_ANIM_STEP_REVERSE	EQU	00010000H
MCI_ANIM_STEP_FRAMES	EQU	00020000H
; flags for dwItem field of MCI_STATUS_PARMS parameter block
MCI_ANIM_STATUS_SPEED	EQU	00004001H
MCI_ANIM_STATUS_FORWARD	EQU	00004002H
MCI_ANIM_STATUS_HWND	EQU	00004003H
MCI_ANIM_STATUS_HPAL	EQU	00004004H
MCI_ANIM_STATUS_STRETCH	EQU	00004005H
; flags for the dwFlags parameter of MCI_INFO command message
MCI_ANIM_INFO_TEXT	EQU	00010000H
; flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block
MCI_ANIM_GETDEVCAPS_CAN_REVERSE	EQU	00004001H
MCI_ANIM_GETDEVCAPS_FAST_RATE	EQU	00004002H
MCI_ANIM_GETDEVCAPS_SLOW_RATE	EQU	00004003H
MCI_ANIM_GETDEVCAPS_NORMAL_RATE	EQU	00004004H
MCI_ANIM_GETDEVCAPS_PALETTES	EQU	00004006H
MCI_ANIM_GETDEVCAPS_CAN_STRETCH	EQU	00004007H
MCI_ANIM_GETDEVCAPS_MAX_WINDOWS	EQU	00004008H
; flags for the MCI_REALIZE command message
MCI_ANIM_REALIZE_NORM	EQU	00010000H
MCI_ANIM_REALIZE_BKGD	EQU	00020000H
; flags for dwFlags parameter of MCI_WINDOW command message
MCI_ANIM_WINDOW_HWND	EQU	00010000H
MCI_ANIM_WINDOW_STATE	EQU	00040000H
MCI_ANIM_WINDOW_TEXT	EQU	00080000H
MCI_ANIM_WINDOW_ENABLE_STRETCH	EQU	00100000H
MCI_ANIM_WINDOW_DISABLE_STRETCH	EQU	00200000H
; flags for hWnd field of MCI_ANIM_WINDOW_PARMS parameter block
; MCI_WINDOW command message, (dwFlags == MCI_ANIM_WINDOW_HWND)
MCI_ANIM_WINDOW_DEFAULT	EQU	00000000H
; flags for dwFlags parameter of MCI_PUT command message
MCI_ANIM_RECT	EQU	00010000H
MCI_ANIM_PUT_SOURCE	EQU	00020000H
MCI_ANIM_PUT_DESTINATION	EQU	00040000H
; flags for dwFlags parameter of MCI_WHERE command message
MCI_ANIM_WHERE_SOURCE	EQU	00020000H
MCI_ANIM_WHERE_DESTINATION	EQU	00040000H
; flags for dwFlags parameter of MCI_UPDATE command message
MCI_ANIM_UPDATE_HDC	EQU	00020000H

MCI_ANIM_OPEN_PARMS	STRUC
mciaopen_dwCallback	DD	?
mciaopen_wDeviceID	DW	?
mciaopen_wReserved0	DW	?
mciaopen_lpstrDeviceType	DD	?
mciaopen_lpstrElementName	DD	?
mciaopen_lpstrAlias	DD	?
mciaopen_dwStyle	DD	?
mciaopen_hWndParent	DW	?
mciaopen_wReserved1	DW	?
MCI_ANIM_OPEN_PARMS	ENDS

MCI_ANIM_PLAY_PARMS	STRUC
mciaplay_dwCallback	DD	?
mciaplay_dwFrom	DD	?
mciaplay_dwTo	DD	?
mciaplay_dwSpeed	DD	?
MCI_ANIM_PLAY_PARMS	ENDS

MCI_ANIM_STEP_PARMS	STRUC
mciastep_dwCallback	DD	?
mciastep_dwFrames	DD	?
MCI_ANIM_STEP_PARMS	ENDS

MCI_ANIM_WINDOW_PARMS	STRUC
mciawin_dwCallback	DD	?
mciawin_hWnd	DW	?
mciawin_wReserved1	DW	?
mciawin_nCmdShow	DW	?
mciawin_wReserved2	DW	?
mciawin_lpstrText	DD	?
MCI_ANIM_WINDOW_PARMS	ENDS

MCI_ANIM_RECT_PARMS	STRUC
mciarect_dwCallback	DD	?
ifdef MCI_USE_OFFEXT
mciarect_ptOffset	DB	SIZE POINT DUP (?)
mciarect_ptExtent	DB	SIZE POINT DUP (?)
else	;ifdef MCI_USE_OFFEXT
mciarect_rc	DB	SIZE RECT DUP (?)
endif  ;ifdef MCI_USE_OFFEXT
MCI_ANIM_RECT_PARMS	ENDS

MCI_ANIM_UPDATE_PARMS	STRUC
mciaupd_dwCallback	DD	?
mciaupd_rc	DB	SIZE RECT DUP (?)
mciaupd_hDC	DW	?
MCI_ANIM_UPDATE_PARMS	ENDS
; MCI extensions for video overlay devices
; flags for dwFlags parameter of MCI_OPEN command message
MCI_OVLY_OPEN_WS	EQU	00010000H
MCI_OVLY_OPEN_PARENT	EQU	00020000H
; flags for dwFlags parameter of MCI_STATUS command message
MCI_OVLY_STATUS_HWND	EQU	00004001H
MCI_OVLY_STATUS_STRETCH	EQU	00004002H
; flags for dwFlags parameter of MCI_INFO command message
MCI_OVLY_INFO_TEXT	EQU	00010000H
; flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block
MCI_OVLY_GETDEVCAPS_CAN_STRETCH	EQU	00004001H
MCI_OVLY_GETDEVCAPS_CAN_FREEZE	EQU	00004002H
MCI_OVLY_GETDEVCAPS_MAX_WINDOWS	EQU	00004003H
; flags for dwFlags parameter of MCI_WINDOW command message
MCI_OVLY_WINDOW_HWND	EQU	00010000H
MCI_OVLY_WINDOW_STATE	EQU	00040000H
MCI_OVLY_WINDOW_TEXT	EQU	00080000H
MCI_OVLY_WINDOW_ENABLE_STRETCH	EQU	00100000H
MCI_OVLY_WINDOW_DISABLE_STRETCH	EQU	00200000H
; flags for hWnd parameter of MCI_OVLY_WINDOW_PARMS parameter block
MCI_OVLY_WINDOW_DEFAULT	EQU	00000000H
; flags for dwFlags parameter of MCI_PUT command message
MCI_OVLY_RECT	EQU	00010000H
MCI_OVLY_PUT_SOURCE	EQU	00020000H
MCI_OVLY_PUT_DESTINATION	EQU	00040000H
MCI_OVLY_PUT_FRAME	EQU	00080000H
MCI_OVLY_PUT_VIDEO	EQU	00100000H
; flags for dwFlags parameter of MCI_WHERE command message
MCI_OVLY_WHERE_SOURCE	EQU	00020000H
MCI_OVLY_WHERE_DESTINATION	EQU	00040000H
MCI_OVLY_WHERE_FRAME	EQU	00080000H
MCI_OVLY_WHERE_VIDEO	EQU	00100000H

MCI_OVLY_OPEN_PARMS	STRUC
mcioopen_dwCallback	DD	?
mcioopen_wDeviceID	DW	?
mcioopen_wReserved0	DW	?
mcioopen_lpstrDeviceType	DD	?
mcioopen_lpstrElementName	DD	?
mcioopen_lpstrAlias	DD	?
mcioopen_dwStyle	DD	?
mcioopen_hWndParent	DW	?
mcioopen_wReserved1	DW	?
MCI_OVLY_OPEN_PARMS	ENDS

MCI_OVLY_WINDOW_PARMS	STRUC
mciowin_dwCallback	DD	?
mciowin_hWnd	DW	?
mciowin_wReserved1	DW	?
mciowin_nCmdShow	DW	?
mciowin_wReserved2	DW	?
mciowin_lpstrText	DD	?
MCI_OVLY_WINDOW_PARMS	ENDS

MCI_OVLY_RECT_PARMS	STRUC
mciorect_dwCallback	DD	?
ifdef MCI_USE_OFFEXT
mciorect_ptOffset	DB	SIZE POINT DUP (?)
mciorect_ptExtent	DB	SIZE POINT DUP (?)
else	;ifdef MCI_USE_OFFEXT
mciorect_rc	DB	SIZE RECT DUP (?)
endif  ;ifdef MCI_USE_OFFEXT
MCI_OVLY_RECT_PARMS	ENDS

MCI_OVLY_SAVE_PARMS	STRUC
mciosave_dwCallback	DD	?
mciosave_lpfilename	DD	?
mciosave_rc	DB	SIZE RECT DUP (?)
MCI_OVLY_SAVE_PARMS	ENDS

MCI_OVLY_LOAD_PARMS	STRUC
mcioload_dwCallback	DD	?
mcioload_lpfilename	DD	?
mcioload_rc	DB	SIZE RECT DUP (?)
MCI_OVLY_LOAD_PARMS	ENDS
endif  ; ifndef _WIN32_VXD
endif                                      ;both; ifndef MMNOMCI
;***************************************************************************
;	DISPLAY Driver extensions
;*************************************************************************
ifndef NEWTRANSPARENT
NEWTRANSPARENT	EQU	3           ; use with SetBkMode()
QUERYROPSUPPORT	EQU	40          ; use to determine ROP support
endif  ; ifndef NEWTRANSPARENT
;***************************************************************************
;	DIB Driver extensions
;*************************************************************************
SELECTDIB	EQU	41                      ; DIB.DRV select dib escape
ifndef SC_SCREENSAVE
SC_SCREENSAVE	EQU	0F140H
endif  ; ifndef SC_SCREENSAVE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic16\mm.inc ===
;***
;mm.inc - macros to write memory model dependent code
;
;	Copyright (c) 1987-1998 Microsoft Corporation
;
;Purpose:
;	This file contains definitions of a number of macros which
;	make the writing of memory model dependent code for the
;	8086 a little easier and more portable.
;
;*******************************************************************************

; the macro below is used by the assigning long arithmetic routines (almul,
; etc) to handle the model dependent data addressing - in small and middle
; models data addresses default to short (2 byte) addresses. in large model,
; data address are long (4 bytes).

LOAD	macro	to,from
if	sizeD
	lds	to,from
else
	mov	to,from
endif
	endm


; general code & data size constants & macros

if	sizeD			; 4 byte data addresses
DAT_ADDR_SZ =	4
BDAT_ADDR_SZ =	2
else				; 2 byte data addresses
DAT_ADDR_SZ =	2
BDAT_ADDR_SZ =	4
endif

if	sizeC			; 4 byte code addresses
TXT_ADDR_SZ =	4
else				; 2 byte code addresses
TXT_ADDR_SZ =	2
endif


; Big/Little Endian Definitions for Long Integers

LOWORD	equ	[0]
HIWORD	equ	[2]


; All Model Definitions

BPARGBAS equ	TXT_ADDR_SZ+2	; offset from BP to first argument


; macro for windows fixup with retf #

return	macro	n
	org	$-1
if	sizeC
	db	0cah
else
	db	0c2h
endif
	dw	n
	endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic16\preclude.h ===
// Copyright (c) 1998 Microsoft Corporation

// MMSYSTEM precludes
//
 
#define     MMNOSOUND
#define     MMNOWAVE
#define     MMNOSEQ
#define     MMNOTIMER
#define     MMNOJOY
////#define     MMNOMCI
#define     MMNOTASK

// MMDDK precludes
//
#define     MMNOWAVEDEV
#define     MMNOAUXDEV
#define     MMNOTIMERDEV
#define     MMNOJOYDEV
/////#define     MMNOMCIDEV
#define     MMNOTASKDEV

// WINDOWS precludes
//

#define     NOGDICAPMASKS        //- CC_*, LC_*, PC_*, CP_*, TC_*, RC_
#define     NOVIRTUALKEYCODES    //- VK_*
#define     NOICONS              //- IDI_*
#define     NOKEYSTATES          //- MK_*
#define     NOSYSCOMMANDS        //- SC_*
#define     NORASTEROPS          //- Binary and Tertiary raster ops
#define     OEMRESOURCE          //- OEM Resource values
#define     NOCLIPBOARD          //- Clipboard routines
#define     NOMETAFILE           //- typedef METAFILEPICT
//#define     NOOPENFILE           //- OpenFile(), OemToAnsi, AnsiToOem, and OF_*
#define     NOSOUND              //- Sound driver routines
#define     NOWH                 //- SetWindowsHook and WH_*
#define     NOCOMM               //- COMM driver routines
#define     NOKANJI              //- Kanji support stuff.
//#define     NOHELP               //- Help engine interface.
#define     NOPROFILER           //- Profiler interface.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic16\mmdevldr.inc ===
;******************************************************************************
TITLE mmdevldr.inc - Windows/386 MMSYSTEM Device loader DLVxD include file
;******************************************************************************
;
;   (C) Copyright (c) 1993-1998 Microsoft Corporation
;
;   Title:  mmdevldr.INC - Windows/386 Config Manager DLVxD DEVLOADER for MMSYSTEM
;
;   Version:    1.00
;
;
;==============================================================================
Multimedia_OEM_ID           equ 0440h            ; MS Reserved OEM # 34
MMDEVLDR_Device_ID           equ Multimedia_OEM_ID + 10 ;MMDEVLDR's device ID

MMDEVLDR_Ver_Major           equ 1                ; version 1.0 of this VxD
MMDEVLDR_Ver_Minor           equ 0

MMDEVLDR_API_MMSystem_Up        equ 0			;Internal
MMDEVLDR_API_Continue		equ 1			;Internal
MMDEVLDR_API_QueryVxD           equ 2                   ;Internal
MMDEVLDR_API_QueueCallback32    equ 3                   ;Internal
MMDEVLDR_API_SetEvent           equ 4                   ;Internal
MMDEVLDR_API_PageAllocate       equ 5                   ;Internal
MMDEVLDR_API_PageFree           equ 6                   ;Internal
MMDEVLDR_APIS                   equ 7                   ;Internal

ifdef DDB_Sys_Crit_Init_Done
 
Begin_Service_Table	MMDEVLDR
	MMDEVLDR_Service	MMDEVLDR_Register_Device_Driver, LOCAL
	MMDEVLDR_Service	_MMDEVLDR_SetDevicePresence
        MMDEVLDR_Service        _MMDEVLDR_SetEnvironmentString
        MMDEVLDR_Service        _MMDEVLDR_GetEnvironmentString
        MMDEVLDR_Service        _MMDEVLDR_RemoveEnvironmentString
        MMDEVLDR_Service        _MMDEVLDR_AddEnvironmentString
End_Service_Table MMDEVLDR	

MMDEVLDR_IOCTL_GETVERSION       equ     0		;Internal
MMDEVLDR_IOCTL_LINPAGELOCK      equ     1		;Internal
MMDEVLDR_IOCTL_LINPAGEUNLOCK    equ     2		;Internal
MMDEVLDR_IOCTL_RING0THREADHANDLE equ    3		;Internal
MMDEVLDR_IOCTL_QUEUEAPC         equ     4		;Internal
MMDEVLDR_IOCTL_GETCHANGENOTIFYPTR equ   5		;Internal
MMDEVLDR_IOCTL_CLOSEVXDHANDLE   equ     6		;Internal
MMDEVLDR_IOCTL_PAGEALLOCATE     equ     7		;Internal
MMDEVLDR_IOCTL_PAGEFREE         equ     8		;Internal
MMDEVLDR_IOCTL_GETDEVICESTATUS  equ     9		;Internal
							;Internal
MM_DEVSTATUS_ERROR          equ 0			;Internal
MM_DEVSTATUS_STARTED        equ 1			;Internal
MM_DEVSTATUS_UNKNOWNPROB    equ 2			;Internal
MM_DEVSTATUS_DISABLED       equ 3			;Internal
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic16\res.h ===
/**********************************************************************

    Copyright (c) 1992-1998 Microsoft Corporation

    res.h

    DESCRIPTION:

*********************************************************************/

#ifndef _RES_
#define _RES_

#define IDS_DMUSIC16    1000

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic16\uldiv.asm ===
page	,132
	title	uldiv - unsigned long divide routine
;***
;uldiv.asm - unsigned long divide routine
;
;	Copyright (c) 1985-1998 Microsoft Corporation
;
;Purpose:
;	defines the unsigned long divide routine
;	the following routines are created:
;	    __aFuldiv	(large, medium models)
;	    __aNuldiv	(small, compact models)
;
;*******************************************************************************

.xlist

        ?PLM = 0
        ?WIN = 1
	PMODE= 1
        memM = 1


include cmacros.inc
include cmphlp.inc
include mm.inc
.list

CreateSeg       FIXMIDI,        MidiFix, word, public, CODE

sBegin	MidiFix
	assumes cs,MidiFix
	assumes ds,data

page
;***
;uldiv - unsigned long divide
;
;Purpose:
;	Does a unsigned long divide of the arguments.  Arguments are
;	not changed.
;
;Entry:
;	Arguments are passed on the stack:
;		1st pushed: divisor (DWORD)
;		2nd pushed: dividend (DWORD)
;
;Exit:
;	DX:AX contains the quotient (dividend/divisor)
;	NOTE: this routine removes the parameters from the stack.
;
;Uses:
;	CX
;
;Exceptions:
;
;*******************************************************************************

;	ASGN	uldiv
if	sizeC
cProc	_aFuldiv,<PUBLIC>,<>

else
cProc	_aNuldiv,<PUBLIC>,<>
endif

ParmD	DVND1
ParmD   DVSR1
cBegin

	push	bx
	push	si

; Set up the local stack and save the index registers.	When this is done
; the stack frame will look as follows (assuming that the expression a/b will
; generate a call to uldiv(a, b)):
;
;		-----------------
;		|		|
;		|---------------|
;		|		|
;		|--divisor (b)--|
;		|		|
;		|---------------|
;		|		|
;		|--dividend (a)-|
;		|		|
;		|---------------|
;		| return addr** |
;		|---------------|
;	BP----->|    old BP	|
;		|---------------|
;		|      BX	|
;		|---------------|
;	SP----->|      SI	|
;		-----------------
;
; ** - 2 bytes if small/compact model; 4 bytes if medium/large model

DVND	equ	BPARGBAS[bp]	; stack address of dividend (a)
DVSR	equ	BPARGBAS+4[bp]	; stack address of divisor (b)

;
; Now do the divide.  First look to see if the divisor is less than 64K.
; If so, then we can use a simple algorithm with word divides, otherwise
; things get a little more complex.
;

	mov	ax,HIWORD(DVSR) ; check to see if divisor < 64K
	or	ax,ax
	jnz	L1		; nope, gotta do this the hard way
	mov	cx,LOWORD(DVSR) ; load divisor
	mov	ax,HIWORD(DVND) ; load high word of dividend
	xor	dx,dx
	div	cx		; get high order bits of quotient
	mov	bx,ax		; save high bits of quotient
	mov	ax,LOWORD(DVND) ; dx:ax <- remainder:lo word of dividend
	div	cx		; get low order bits of quotient
	mov	dx,bx		; dx:ax <- quotient hi:quotient lo
	jmp	short L2	; restore stack and return

;
; Here we do it the hard way.  Remember, ax contains DVSRHI
;

L1:
	mov	cx,ax		; cx:bx <- divisor
	mov	bx,LOWORD(DVSR)
	mov	dx,HIWORD(DVND) ; dx:ax <- dividend
	mov	ax,LOWORD(DVND)
L3:
	shr	cx,1		; shift divisor right one bit; hi bit <- 0
	rcr	bx,1
	shr	dx,1		; shift dividend right one bit; hi bit <- 0
	rcr	ax,1
	or	cx,cx
	jnz	L3		; loop until divisor < 64K
	div	bx		; now divide, ignore remainder
	mov	si,ax		; save quotient

;
; We may be off by one, so to check, we will multiply the quotient
; by the divisor and check the result against the orignal dividend
; Note that we must also check for overflow, which can occur if the
; dividend is close to 2**32 and the quotient is off by 1.
;

	mul	word ptr HIWORD(DVSR) ; QUOT * HIWORD(DVSR)
	xchg	cx,ax		; "mov cx,ax" but only 1 byte
	mov	ax,LOWORD(DVSR)
	mul	si		; QUOT * LOWORD(DVSR)
	add	dx,cx		; DX:AX = QUOT * DVSR
	jc	L4		; carry means Quotient is off by 1

;
; do long compare here between original dividend and the result of the
; multiply in dx:ax.  If original is larger or equal, we are ok, otherwise
; subtract one (1) from the quotient.
;

	cmp	dx,HIWORD(DVND) ; compare hi words of result and original
	ja	L4		; if result > original, do subtract
	jb	L5		; if result < original, we are ok
	cmp	ax,LOWORD(DVND) ; hi words are equal, compare lo words
	jbe	L5		; if less or equal we are ok, else subtract
L4:
	dec	si		; subtract 1 from quotient
L5:
	xor	dx,dx		; dx:ax <- quotient
	xchg	ax,si		; "mov ax,si" but only 1 byte

;
; Just the cleanup left to do.	dx:ax contains the quotient.
; Restore the saved registers and return.
;

L2:

	pop	si
	pop	bx

cEnd	<nolocals>
return	8

sEnd

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic16\win9x\makefile.inc ===
#
# Copyright (c) 1998-2000 Microsoft Corporation
#
#

LIBS=                                      \
    ..\..\..\public\sdk\lib16\libw.lib     \
    ..\..\..\public\sdk\lib16\mmsystem.lib \
    ..\..\..\public\sdk\lib16\kernel.lib

!if $(FREEBUILD)
DEFS=
!else
DEFS=-DDEBUG_RETAIL=1 -DDEBUG=1
!endif

CL=$(DXROOT)\public\tools\c816\bin\cl
ML=$(BASEDIR)\tools\x86\ml
THUNK=$(BASEDIR)\tools\x86\thunk
LINK=$(DXROOT)\public\tools\c816\bin\link
MAPSYM=$(DXROOT)\public\tools\c816\bin\mapsym
RC=$(DXROOT)\public\tools\c816\bin\rc

C16FLAGS=-DWIN16 -DWINVER=0x0400 /Alnw /GD -G3s -Fd$* -Fo$@ -Fc -Fl -c $(DEFS) \
    -I..\..\..\public\tools\c816\inc \
    -I..\..\..\public\sdk\inc16
AFLAGS=-D?MEDIUM -D?QUIET -c -Zm -Fo$@ $(DEFS) \
    -I..\..\..\public\sdk\inc16
RFLAGS=$(DEFS)

OBJS=                   \
    $(O)\libentry.obj   \
    $(O)\alloc.obj      \
    $(O)\debug.obj      \
    $(O)\device.obj     \
    $(O)\dmthunk.obj    \
    $(O)\dmusic16.obj   \
    $(O)\equeue.obj     \
    $(O)\list.obj       \
    $(O)\locks.obj      \
    $(O)\midiin.obj     \
    $(O)\midiout.obj    \
    $(O)\dmhelp.obj     \
    $(O)\mmdevldr.obj

$(O)\dmusic16.res: ..\dmusic16.rc
    $(DXROOT)\public\tools\c816\bin\rc \
    -I..\..\..\inc \
    -I..\..\..\public\sdk\inc16 \
    $(RFLAGS) -r -fo $@ ..\dmusic16.rc

$(O)\dmusic16.dll: $(OBJS)  $(O)\dmusic16.res
    $(LINK) @<<
$(OBJS: =+
),
$(O)\dmusic16.dll /AL:16/onerror:noexe/NODEF,
$(O)\dmusic16.map,
$(LIBS),
..\dmusic16.def
<<
    $(RC) $(O)\dmusic16.res $@
    $(MAPSYM) -o $(@:dll=sym) $(O)\dmusic16.map

$(O)\alloc.obj:    ..\alloc.c
    $(CL) $(C16FLAGS) ..\$(@B).c

$(O)\debug.obj:    ..\debug.c
    $(CL) $(C16FLAGS) ..\$(@B).c

$(O)\device.obj:   ..\device.c
    $(CL) $(C16FLAGS) ..\$(@B).c

$(O)\dmusic16.obj: ..\dmusic16.c
    $(CL) $(C16FLAGS) ..\$(@B).c

$(O)\equeue.obj:   ..\equeue.c
    $(CL) $(C16FLAGS) ..\$(@B).c

$(O)\list.obj:     ..\list.c
    $(CL) $(C16FLAGS) ..\$(@B).c

$(O)\locks.obj:    ..\locks.c
    $(CL) $(C16FLAGS) ..\$(@B).c

$(O)\midiin.obj:   ..\midiin.c
    $(CL) $(C16FLAGS) ..\$(@B).c

$(O)\midiout.obj:  ..\midiout.c
    $(CL) $(C16FLAGS) ..\$(@B).c

$(O)\dmhelp.obj:   ..\dmhelp.asm
    $(ML) $(AFLAGS) ..\$(@B).asm

$(O)\libentry.obj: ..\libentry.asm
    $(ML) $(AFLAGS) ..\$(@B).asm

$(O)\mmdevldr.obj: ..\mmdevldr.asm
    $(ML) $(AFLAGS) ..\$(@B).asm

$(O)\uldiv.obj:    ..\uldiv.asm
    $(ML) $(AFLAGS) ..\$(@B).asm


$(O)\dmthunk.obj:  $(O)\dmthunk.asm
    $(ML) -c -DIS_16 -Fo$(O)\dmthunk.obj $(O)\dmthunk.asm

$(O)\dmthunk.asm:    ..\..\dmusic32\dmthunk.thk
    $(THUNK) -o $(O)\dmthunk.asm ..\..\dmusic32\dmthunk.thk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic32\debug.cpp ===
//
// Debug.CPP
//
// Copyright (c) 1997-1998 Microsoft Corporation
//
// @doc INTERNAL
//
// @module Debug | Debug services for DMusic.DLL
//

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>

#include "debug.h"

#ifdef DBG

#define MODULE "DMUSIC32"

// @globalv Section in WIN.INI for all debug settings
const char szDebugSection[] = "debug";

// @globalv Key in WIN.INI for our debug level. All messages with
// a level of this number or lower will be displayed.
const char szDebugKey[] = MODULE;

// @globalv Key in WIN.INI [debug] section which determines if assert calls
// DebugBreak or not
//
const char szAssertBreak[] = "AssertBreak";

// @globalv Prefix for all debug outputs
//
const char szDebugPrefix[] = MODULE ": ";

// @globalv The current debug level. 
static int giDebugLevel;

// @globalv Do asserts break?
static BOOL gfAssertBreak;

// @func Sets the debug level from WIN.INI
// 
void DebugInit(
    void)
{
    giDebugLevel = GetProfileInt(szDebugSection, szDebugKey, 0);
    gfAssertBreak = GetProfileInt(szDebugSection, szAssertBreak, 0);


    // Nepotism at its finest
    DebugTrace(-1, "Debug level is %d\n", giDebugLevel);
}

// @func Send a debug trace out.
//
// @comm Any message with a level less than or equal to the current debug
// level will be displayed using the OutputDebugString API. This means either
// the IDE Debug window if the app is running in that context or WDEB if
// it's running.
//
static BOOL fNeedPrefix = TRUE;
void DebugTrace(
    int iDebugLevel,        // @parm The debug level of this message
    LPSTR pstrFormat,       // @parm A printf style format string
    ...)                    // @parm | ... | Variable paramters based on <p pstrFormat>
{
    char sz[512];
    

    if (iDebugLevel != -1 && iDebugLevel > giDebugLevel)
    {
        return;
    }

    va_list va;

    va_start(va, pstrFormat);
    vsprintf(sz, pstrFormat, va);
    va_end(va);

    if (fNeedPrefix)
    {
        OutputDebugString(szDebugPrefix);
    }
    
    OutputDebugString(sz);

    // Let them construct multiple piece trace outs w/o
    // prefixing each one
    //
    fNeedPrefix = FALSE;
    for (;*pstrFormat && !fNeedPrefix; ++pstrFormat)
    {
        if (*pstrFormat == '\n')
        {
            fNeedPrefix = TRUE;
        }
    }
}

void DebugAssert(
    LPSTR szExp, 
    LPSTR szFile, 
    ULONG ulLine)
{
    DebugTrace(0, "ASSERT: \"%s\" %s@%lu\n", szExp, szFile, ulLine);
    if (gfAssertBreak)
    {
        DebugBreak();
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic32\debug.h ===
//
// debug.h
// 
// Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
//
// Note:
//

#ifndef DEBUG_H
#define DEBUG_H

#include <windows.h>

#define DM_DEBUG_CRITICAL		1	// Used to include critical messages
#define DM_DEBUG_NON_CRITICAL	2	// Used to include level 1 plus important non-critical messages
#define DM_DEBUG_STATUS			3	// Used to include level 1 and level 2 plus status\state messages
#define DM_DEBUG_FUNC_FLOW		4	// Used to include level 1, level 2 and level 3 plus function flow messages
#define DM_DEBUG_ALL			5	// Used to include all debug messages

#ifdef DBG
extern void DebugInit(void);
extern void DebugTrace(int iDebugLevel, LPSTR pstrFormat, ...);
extern void DebugAssert(LPSTR szExp, LPSTR szFile, ULONG ulLine);
#define Trace DebugTrace
#define assert(exp) (void)( (exp) || (DebugAssert(#exp, __FILE__, __LINE__), 0) )
#else
#define Trace
#define assert(exp)	((void)0)
#endif
#endif // #ifndef DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic32\dm32p.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
/*
 * Internal function prototypes for DMusic32.dll
 */
#ifndef _DM32P_
#define _DM32P_

#include "..\shared\dmusiccp.h"
#include "tpool.h"

#define THREAD_KILL_TIMEOUT         5000
#define THREAD_WORK_BUFFER_SIZE     4096

#define QWORD_ALIGN(x) (((x) + 7) & ~7)

#define MIDI_CHANNELS               16

/* DevIoctl.c - MMDEVLDR hooks we use
 */
extern BOOL WINAPI OpenMMDEVLDR(void);
extern VOID WINAPI CloseMMDEVLDR(void);
extern VOID WINAPI CloseVxDHandle(DWORD hVxDHandle);

/* From Win32 kernel
 */
extern "C" DWORD WINAPI OpenVxDHandle(HANDLE hEvent);

// 10 ms in 100ns units
//
#define FIXED_LEGACY_LATENCY_OFFSET (10L * 10L * 1000L)

class CEmulateLatencyClock : public IReferenceClock
{
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IReferenceClock
    //
    STDMETHODIMP GetTime(REFERENCE_TIME *pTime);
    STDMETHODIMP AdviseTime(REFERENCE_TIME baseTime,  
				    REFERENCE_TIME streamTime,
				    HANDLE hEvent,            
				    DWORD * pdwAdviseCookie); 

    STDMETHODIMP AdvisePeriodic(REFERENCE_TIME startTime,
					REFERENCE_TIME periodTime,
					HANDLE hSemaphore,   
					DWORD * pdwAdviseCookie);

    STDMETHODIMP Unadvise(DWORD dwAdviseCookie);

    // Class
    //
    CEmulateLatencyClock(IReferenceClock *pMasterClock);
    ~CEmulateLatencyClock();

    void Close();

private:
    long m_cRef;
    IReferenceClock *m_pMasterClock;
};

// Struct for holding a property item supported by the synth
//

class CDirectMusicEmulatePort;

typedef HRESULT (CDirectMusicEmulatePort::*GENPROPHANDLER)(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG cbBuffer);

#define GENPROP_F_STATIC                0x00000000
#define GENPROP_F_FNHANDLER             0x00000001


struct GENERICPROPERTY
{
    const GUID *pguidPropertySet;       // What property set?
    ULONG       ulId;                   // What item?

    ULONG       ulSupported;            // Get/Set flags for QuerySupported

    ULONG       ulFlags;                // GENPROP_F_xxx

    LPVOID      pPropertyData;          // Data to be returned
    ULONG       cbPropertyData;         // and its size    

    GENPROPHANDLER pfnHandler;          // Handler fn iff GENPROP_F_FNHANDLER
};






class CDirectMusicEmulatePort : 
    public IDirectMusicPort, 
    public IDirectMusicPortP, 
    public IDirectMusicThru,
    public IDirectMusicPortPrivate, 
    public IKsControl
{
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectMusicPort
    //
    STDMETHODIMP PlayBuffer(LPDIRECTMUSICBUFFER pBuffer);
    STDMETHODIMP SetReadNotificationHandle(HANDLE hEvent);
    STDMETHODIMP Read(LPDIRECTMUSICBUFFER pBuffer);
	STDMETHODIMP DownloadInstrument(IDirectMusicInstrument*,
                                            IDirectMusicDownloadedInstrument**,
                                            DMUS_NOTERANGE*,
                                            DWORD);
	STDMETHODIMP UnloadInstrument(IDirectMusicDownloadedInstrument*);
    
    STDMETHODIMP GetLatencyClock(IReferenceClock **ppClock);
    STDMETHODIMP GetRunningStats(LPDMUS_SYNTHSTATS pStats);
    STDMETHODIMP Compact();
    STDMETHODIMP GetCaps(LPDMUS_PORTCAPS pPortCaps);
	STDMETHODIMP DeviceIoControl(DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, 
	                                 LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP SetNumChannelGroups(DWORD dwNumChannelGroups);
    STDMETHODIMP GetNumChannelGroups(LPDWORD pdwNumChannelGroups);
    STDMETHODIMP Activate(BOOL fActivate);
    STDMETHODIMP SetChannelPriority(DWORD dwChannelGroup, DWORD dwChannel, DWORD dwPriority);
    STDMETHODIMP GetChannelPriority(DWORD dwChannelGroup, DWORD dwChannel, LPDWORD pdwPriority);
    STDMETHODIMP SetDirectSound(LPDIRECTSOUND pDirectSound, LPDIRECTSOUNDBUFFER pDirectSoundBuffer);
    STDMETHODIMP GetFormat(LPWAVEFORMATEX pWaveFormatEx, LPDWORD pdwWaveFormatExSize, LPDWORD pdwBufferSize);
        
    // IDirectMusicThru
    STDMETHODIMP ThruChannel(DWORD dwSourceChannelGroup, 
                             DWORD dwSourceChannel, 
                             DWORD dwDestinationChannelGroup,
                             DWORD dwDestinationChannel,
                             LPDIRECTMUSICPORT pDestinationPort);
    
    // IDirectMusicPortP
    //
    STDMETHODIMP DownloadWave(
         IN  IDirectSoundWave *pWave,               
         OUT IDirectSoundDownloadedWaveP **ppWave,
         IN  REFERENCE_TIME rtStartHint
        );
        
    STDMETHODIMP UnloadWave(
         IN  IDirectSoundDownloadedWaveP *pWave      
        );
            
    STDMETHODIMP AllocVoice(
         IN  IDirectSoundDownloadedWaveP *pWave,     
         IN  DWORD dwChannel,                       
         IN  DWORD dwChannelGroup,                  
         IN  REFERENCE_TIME rtStart,                     
         IN  SAMPLE_TIME stLoopStart,
         IN  SAMPLE_TIME stLoopEnd,
         OUT IDirectMusicVoiceP **ppVoice            
        );        
        
    STDMETHODIMP AssignChannelToBuses(
         IN DWORD dwChannelGroup,
         IN DWORD dwChannel,
         IN LPDWORD pdwBuses,
         IN DWORD cBusCount
        );        
        
    STDMETHODIMP SetSink(
        IN IDirectSoundConnect *pSinkConnect
    );

    STDMETHODIMP GetSink(
        IN IDirectSoundConnect **ppSinkConnect
    );

    // IKsControl
    STDMETHODIMP KsProperty(
        IN PKSPROPERTY Property,
        IN ULONG PropertyLength,
        IN OUT LPVOID PropertyData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );
    
    STDMETHODIMP KsMethod(
        IN PKSMETHOD Method,
        IN ULONG MethodLength,
        IN OUT LPVOID MethodData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );

    STDMETHODIMP KsEvent(
        IN PKSEVENT Event,
        IN ULONG EventLength,
        IN OUT LPVOID EventData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );

    // IDirectMusicPortPrivate
    STDMETHODIMP Close();
	STDMETHODIMP Report();
    STDMETHODIMP StartVoice(          
         DWORD dwVoiceId,
         DWORD dwChannel,
         DWORD dwChannelGroup,
         REFERENCE_TIME rtStart,
         DWORD dwDLId,
         LONG prPitch,
         LONG veVolume,
         SAMPLE_TIME stVoiceStart,
         SAMPLE_TIME stLoopStart,
         SAMPLE_TIME stLoopEnd
        );

    STDMETHODIMP StopVoice(
         DWORD dwVoiceID,
         REFERENCE_TIME rtStop
        );
    
    STDMETHODIMP GetVoiceState(   
         DWORD dwVoice[], 
         DWORD cbVoice,
         DMUS_VOICE_STATE VoiceState[] 
        );
        
    STDMETHODIMP Refresh(
         DWORD dwDownloadID,
         DWORD dwFlags
         );        
         
    // Class
    //
    CDirectMusicEmulatePort(PORTENTRY *pPE, CDirectMusic *pDM);
    ~CDirectMusicEmulatePort();
    HRESULT Init(LPDMUS_PORTPARAMS pPortParams);

    HRESULT LegacyCaps(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG cbBuffer);

    DWORD InputWorker();
    DWORD TimerWorker();
    
   

private:
    long                    m_cRef;
    UINT                    m_id;
    BOOL                    m_fIsOutput;
    HANDLE                  m_hDevice;
    CDirectMusic            *m_pDM;
    DWORD                   m_hVxDEvent;
    DMUS_PORTCAPS           dmpc;
    IReferenceClock         *m_pMasterClock;
    CEmulateLatencyClock    *m_pLatencyClock;
    IDirectMusicPortNotify  *m_pNotify;
    
    HANDLE                  m_hAppEvent;
    HANDLE                  m_hDataReady;
    HANDLE                  m_hKillThreads;
    HANDLE                  m_hCaptureThread;
    BYTE                    m_WorkBuffer[THREAD_WORK_BUFFER_SIZE];
    DWORD                   m_dwWorkBufferTileInfo;
    DWORD                   m_p1616WorkBuffer;
    EVENT_POOL              m_FreeEvents;        
    EVENT_QUEUE             m_ReadEvents;
    CRITICAL_SECTION        m_csEventQueues;
    BOOL                    m_fCSInitialized;
    
    IDirectMusicBuffer      *m_pThruBuffer;
    LPDMUS_THRU_CHANNEL     m_pThruMap;

    long                    m_lActivated;    
    
    BOOL                    m_fSyncToMaster;
    LONGLONG                m_lTimeOffset;
    
private:
    static GENERICPROPERTY m_aProperty[];
    static const int m_nProperty;
    static GENERICPROPERTY *FindPropertyItem(REFGUID rguid, ULONG ulId);
    
private:
    HRESULT InitializeClock();
    HRESULT InitializeCapture();
    void InputWorkerDataReady();    
    void ThruEvent(DMEVENT *pEvent);
    void MasterToSlave(REFERENCE_TIME *prt);
    void SlaveToMaster(REFERENCE_TIME *prt);
    void SyncClocks();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic32\dm32dll.cpp ===
// Copyright (c) 1998 Microsoft Corporation
// dm32dll.cpp
//
// Dll entry points 
//
#include <objbase.h>
#include <assert.h>
#include <mmsystem.h>
#include <dsoundp.h>

#include "dmusicc.h"
#include "..\dmusic\dmusicp.h"
#include "debug.h"

#include "dmusic32.h"
#include "dm32p.h"

// Globals
//

// Dll's hModule
//
HMODULE g_hModule = NULL;

extern "C" BOOL PASCAL dmthunk_ThunkConnect32(LPCSTR pszDll16, LPCSTR pszDll32, HINSTANCE hinst, DWORD dwReason);

static CONST TCHAR pszDll16[] = "DMUSIC16.DLL";
static CONST TCHAR pszDll32[] = "DMUSIC32.DLL";

#ifdef DBG
static char* aszReasons[] =
{
    "DLL_PROCESS_DETACH",
    "DLL_PROCESS_ATTACH",
    "DLL_THREAD_ATTACH",
    "DLL_THREAD_DETACH"
};
const DWORD nReasons = (sizeof(aszReasons) / sizeof(char*));
#endif

// Standard Win32 DllMain
//
BOOL APIENTRY DllMain(HINSTANCE hModule,
                      DWORD dwReason,
                      void *lpReserved)
{
    OSVERSIONINFO osvi;
    HANDLE ph;
    static int nReferenceCount = 0;

#ifdef DBG
    if (dwReason < nReasons)
    {
        Trace(2, "DllMain: %s\n", (LPSTR)aszReasons[dwReason]);
    }
    else
    {
        Trace(2, "DllMain: Unknown dwReason <%u>\n", dwReason);
    }
#endif

    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            if (++nReferenceCount == 1)
            {
                #ifdef DBG
                    DebugInit();
                #endif
                if (!DisableThreadLibraryCalls(hModule))
                {
                    Trace(0, "DisableThreadLibraryCalls failed.\n");
                }

                if (!OpenMMDEVLDR())
                {
                    Trace(0, "OpenMMDEVLDR failed.\n");
                }
            }
            break;

        case DLL_PROCESS_DETACH:
            if (--nReferenceCount == 0)
            {
                Trace(1, "Last process detach\n");
                CloseMMDEVLDR();
            }
            break;

        default:
            Trace(-1, "Got a non-process at/detach!\n");
            break;
    }


    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = hModule;

        osvi.dwOSVersionInfoSize = sizeof(osvi);
        GetVersionEx(&osvi);
        if (osvi.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS)
        {
            return FALSE;
        }
    }


    if (!dmthunk_ThunkConnect32(pszDll16, pszDll32, hModule, dwReason))
    {
        Trace(-1, "Could not connect to thunk layer! - not loading.\n");
        return FALSE;
    }       

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic32\opnew.cpp ===
// Copyright (c) 1999 Microsoft Corporation
// OpNew.cpp
//
// Override operator new[] so that we ignore the new_handler mechanism.
//
//
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#include "Debug.h"

LPVOID __cdecl operator new(size_t cbBuffer)
{
    LPVOID p;

    p = malloc(cbBuffer ? cbBuffer : 1);
    return p;
}

void __cdecl operator delete(LPVOID p)
{
    free(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic32\devioctl.cpp ===
// Copyright (c) 1998 Microsoft Corporation
#include <windows.h>

#include <objbase.h>
#include <assert.h>
#include <mmsystem.h>
#include <dsoundp.h>

#include "mmdevldr.h"

#include "dmusicc.h"
#include "..\dmusic\dmusicp.h"
#include "dmusic32.h"
#include "dm32p.h"

static CONST TCHAR cszMMDEVLDR[] = "\\\\.\\MMDEVLDR.VXD";

static HANDLE ghMMDEVLDR = INVALID_HANDLE_VALUE;

BOOL WINAPI OpenMMDEVLDR(
    void)
{
    ghMMDEVLDR = CreateFile(
        cszMMDEVLDR,
        GENERIC_WRITE,
        FILE_SHARE_WRITE,
        NULL,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    return ghMMDEVLDR != INVALID_HANDLE_VALUE;
}


VOID WINAPI CloseMMDEVLDR(
    void)
{
    if (ghMMDEVLDR != INVALID_HANDLE_VALUE)
    {
        CloseHandle(ghMMDEVLDR);
        ghMMDEVLDR = INVALID_HANDLE_VALUE;
    }
}
                          
                          

VOID WINAPI CloseVxDHandle(
    DWORD hVxDHandle)                           
{
    DWORD cb;

    DeviceIoControl(ghMMDEVLDR,
                    MMDEVLDR_IOCTL_CLOSEVXDHANDLE,
                    NULL,
                    0,
                    &hVxDHandle,
                    sizeof(hVxDHandle),
                    &cb,
                    NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic32\dmeport.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// dmeport.cpp
//
// CDirectMusicEmulatePort
// Implements the MMSYSTEM API version of IDirectMusicPort.
//
#define INITGUID
#include <objbase.h>
#include <ks.h>
#include <ksproxy.h>
#include <assert.h>
#include <mmsystem.h>
#include <dsoundp.h>

#include "dmusicc.h"
#include "..\dmusic\dmusicp.h"
#include "debug.h"
#include "dmusic32.h"
#include "dm32p.h"
#include "dmthunk.h"
#include "..\shared\validate.h"

#include <ks.h>             // KSDATAFORMAT_SUBTYPE_MIDI

#pragma warning(disable:4530)

#define CLOCK_UPDATE_INTERVAL   100         // milliseconds

#define MS_TO_REFERENCE_TIME    (10 * 1000)

static HRESULT MMRESULTToHRESULT(
    MMRESULT mmr);

static DWORD InputWorker(LPVOID lpv);

// @func API call into DLL to get a new port
//
HRESULT
CreateCDirectMusicEmulatePort(
    PORTENTRY *pPE,
    CDirectMusic *pDM,
    LPDMUS_PORTPARAMS pPortParams,
    CDirectMusicEmulatePort **pPort)
{
    HRESULT hr;
    
    *pPort = new CDirectMusicEmulatePort(pPE, pDM);
    if (NULL == *pPort)
    {
        return E_OUTOFMEMORY;
    }

    hr = (*pPort)->Init(pPortParams);
    if (!SUCCEEDED(hr))
    {
        delete *pPort;
        *pPort = NULL;
        return hr;
    }

    return hr;
}
   

// @mfunc Constructor for CDirectMusicEmulatePort
//
CDirectMusicEmulatePort::CDirectMusicEmulatePort(
                                                 PORTENTRY *pPE,    // @parm The portentry of this device
                                                 CDirectMusic *pDM):// @parm The CDirectMusic implementation which created this port
                                                 m_cRef(1),
                                                 m_id(pPE->idxDevice),
                                                 m_pDM(pDM),
                                                 m_hKillThreads(NULL),
                                                 m_hDataReady(NULL),
                                                 m_hAppEvent(NULL),
                                                 m_dwWorkBufferTileInfo(0),
                                                 m_pThruBuffer(NULL),
                                                 m_pThruMap(NULL),
                                                 m_lActivated(0),
                                                 m_hCaptureThread(NULL),
                                                 m_pMasterClock(NULL),
                                                 m_fCSInitialized(FALSE)
{
    m_fIsOutput = (pPE->pc.dwClass == DMUS_PC_OUTPUTCLASS) ? TRUE : FALSE;
    m_hDevice = NULL;
    m_pLatencyClock = NULL;
    dmpc = pPE->pc;
}

// @mfunc Destructor for CDirectMusicEmulatePort
//
CDirectMusicEmulatePort::~CDirectMusicEmulatePort()
{
    Close();
}

// @mfunc Initialization of CDirectMusicEmulatePort
//
// @comm Call through the thunk layer to open the requested device. 
//

// Flags we recognize 
//
#define DMUS_ALL_FLAGS (DMUS_PORTPARAMS_VOICES |            \
                        DMUS_PORTPARAMS_CHANNELGROUPS |     \
                        DMUS_PORTPARAMS_AUDIOCHANNELS |     \
                        DMUS_PORTPARAMS_SAMPLERATE |        \
                        DMUS_PORTPARAMS_EFFECTS |           \
                        DMUS_PORTPARAMS_SHARE)

// Of those, which do we actually look at?
//
#define DMUS_SUP_FLAGS (DMUS_PORTPARAMS_CHANNELGROUPS |     \
                        DMUS_PORTPARAMS_SHARE)

HRESULT
CDirectMusicEmulatePort::Init(
    LPDMUS_PORTPARAMS pPortParams)
{
    MMRESULT mmr;
    HRESULT hr;
    BOOL fChangedParms;

    // Get, but don't hold onto, the notification interface
    //
    hr = m_pDM->QueryInterface(IID_IDirectMusicPortNotify, (void**)&m_pNotify);
    if (FAILED(hr))
    {
        return hr;
    }

    m_pNotify->Release();

    // Munge the portparams to match what we support.
    //
    fChangedParms = FALSE;
    if (pPortParams->dwValidParams & ~DMUS_ALL_FLAGS) 
    {
        Trace(0, "Undefined flags in port parameters: %08X\n", pPortParams->dwValidParams & ~DMUS_ALL_FLAGS);
        // Flags set we don't recognize.
        //
        pPortParams->dwValidParams &= DMUS_ALL_FLAGS;
        fChangedParms = TRUE;
    }

    // We recognize these flags but don't support them.
    //
    if (pPortParams->dwValidParams & ~DMUS_SUP_FLAGS)
    {
        pPortParams->dwValidParams &= DMUS_SUP_FLAGS;
        fChangedParms = TRUE;
    }

    // Channel groups better be one.
    //
    if (pPortParams->dwValidParams & DMUS_PORTPARAMS_CHANNELGROUPS)
    {
        if (pPortParams->dwChannelGroups != 1)
        {
            pPortParams->dwChannelGroups = 1;
            fChangedParms = TRUE;
        }
    }
    else
    {
        pPortParams->dwValidParams |= DMUS_PORTPARAMS_CHANNELGROUPS;
        pPortParams->dwChannelGroups = 1;
    }

    BOOL fShare = FALSE;
    if (pPortParams->dwValidParams & DMUS_PORTPARAMS_SHARE)
    {
        if (m_fIsOutput)
        {
            fShare = pPortParams->fShare;
        }
        else
        {
            pPortParams->fShare = FALSE;
            fChangedParms = TRUE;
        }
    }
    else
    {
        pPortParams->dwValidParams |= DMUS_PORTPARAMS_SHARE;
        pPortParams->fShare = fShare;
    }

    mmr = OpenLegacyDevice(m_id, m_fIsOutput, fShare, &m_hDevice);
    if (mmr)
    {
        return MMRESULTToHRESULT(mmr);
    }

    // Set up the master clock and our latency clock
    //
    hr = InitializeClock();
    if (FAILED(hr))
    {
        return hr;
    }

    // If an input port, initialize capture specific stuff like thruing
    //    
    if (!m_fIsOutput)
    {
        hr = InitializeCapture();
        if (FAILED(hr))
        {  
            return hr;
        }
    }

    return fChangedParms ? S_FALSE : S_OK;
}

HRESULT CDirectMusicEmulatePort::InitializeClock()
{
    HRESULT hr;
    GUID guidMasterClock;
    DWORD dwThreadID;
    REFERENCE_TIME rtMasterClock;
    REFERENCE_TIME rtSlaveClock;

    hr = m_pDM->GetMasterClock(&guidMasterClock, &m_pMasterClock);
    if (FAILED(hr))
    {
        return hr;
    }

    m_pLatencyClock = new CEmulateLatencyClock(m_pMasterClock);

    if (NULL == m_pLatencyClock)
    {
        return E_OUTOFMEMORY;
    }

#if 0
    if (guidMasterClock == GUID_SysClock)
    {
        m_fSyncToMaster = FALSE;
        return S_OK;
    }
#endif

    m_fSyncToMaster = TRUE;
    // Read both clocks 
    //
    hr = m_pMasterClock->GetTime(&rtMasterClock);
    rtSlaveClock = MS_TO_REFERENCE_TIME * ((ULONGLONG)timeGetTime());
    
    if (FAILED(hr))
    {
        return hr;
    }

    m_lTimeOffset = rtMasterClock - rtSlaveClock;

    return S_OK;
}

HRESULT CDirectMusicEmulatePort::InitializeCapture()
{
    HRESULT hr;
    MMRESULT mmr;
    DWORD dwThreadID;

    // Allocate thru map for 16 channels, since we only have one channel group
    // Initialize to no thruing (destination port is NULL).
    //
    m_pThruMap = new DMUS_THRU_CHANNEL[MIDI_CHANNELS];
    ZeroMemory(m_pThruMap, MIDI_CHANNELS * sizeof(DMUS_THRU_CHANNEL));

    // Create thruing buffer
    //
    // XXX Defer this until the first call to thru?
    //
    // Note: guaranteed by dmusic16 this is the biggest event ever to be returned
    // (thunk api asking?)
    //
    DMUS_BUFFERDESC dmbd;
    ZeroMemory(&dmbd, sizeof(dmbd));
    dmbd.dwSize = sizeof(dmbd);
    dmbd.cbBuffer = 4096;               // XXX Where should we get this???

    hr = m_pDM->CreateMusicBuffer(&dmbd, &m_pThruBuffer, NULL);
    if (FAILED(hr))
    {
        Trace(0, "Failed to create thruing buffer\n");
        return hr;
    }

    // Create events
    //
    m_hDataReady = CreateEvent(NULL,        // Event attributes
                               FALSE,       // Manual reset
                               FALSE,       // Not signalled
                               NULL);       // Name

    m_hKillThreads = CreateEvent(NULL,       // Event attributes
                                 FALSE,      // Manual reset
                                 FALSE,      // Not signalled
                                 NULL);      // Name

    if (m_hDataReady == (HANDLE)NULL || m_hKillThreads == (HANDLE)NULL)
    {
        return E_OUTOFMEMORY;
    }

    // Set our data ready event for dmusic16 
    //
    m_hVxDEvent = OpenVxDHandle(m_hDataReady);

    Trace(2, "Setting event handle; hDevice %08x hEvent=%08X hVxDEvent=%08X\n",
          (DWORD)m_hDevice,
          (DWORD)m_hDataReady,
          (DWORD)m_hVxDEvent);
    
    mmr = MidiInSetEventHandle(m_hDevice, m_hVxDEvent);
    if (mmr)
    {
        Trace(0, "MidiInSetEventHandle returned [%d]\n", mmr);
        return MMRESULTToHRESULT(mmr);
    }

    // Create a tiling for our work buffer so we only need to do it once
    //
    m_dwWorkBufferTileInfo = dmTileBuffer((DWORD)m_WorkBuffer, sizeof(m_WorkBuffer));
    m_p1616WorkBuffer = TILE_P1616(m_dwWorkBufferTileInfo);
    if (m_p1616WorkBuffer == NULL)
    {
        Trace(0, "Could not tile work buffer\n");
        return E_OUTOFMEMORY;
    }

    // Initialize cs to protect event queues.
    //
    // Unfortunately this can throw an exception if out of memory.
    //
    _try 
    {
        InitializeCriticalSection(&m_csEventQueues);
    } 
    _except (EXCEPTION_EXECUTE_HANDLER) 
    {
        return E_OUTOFMEMORY;
    }
    
    m_fCSInitialized = TRUE;

    m_hCaptureThread = CreateThread(NULL,          // Thread attributes
                                    0,             // Stack size
                                    ::InputWorker,
                                    this,
                                    0,             // Flags
                                    &dwThreadID);
    if (m_hCaptureThread == NULL)
    {
        Trace(0, "CreateThread failed with error %d\n", GetLastError());
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

static DWORD WINAPI InputWorker(LPVOID lpv)
{
    CDirectMusicEmulatePort *pPort = (CDirectMusicEmulatePort*)lpv;

    return pPort->InputWorker();
}



// @mfunc
//
// @comm Standard QueryInterface
//
STDMETHODIMP
CDirectMusicEmulatePort::QueryInterface(const IID &iid,
                                        void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDirectMusicPort)
    {
        *ppv = static_cast<IDirectMusicPort*>(this);
    }
    else if (iid == IID_IDirectMusicPortP)
    {
        *ppv = static_cast<IDirectMusicPortP*>(this);
    }
    else if (iid == IID_IDirectMusicPortPrivate)
    {
        *ppv = static_cast<IDirectMusicPortPrivate*>(this);
    }
    else if (iid == IID_IKsControl)
    {
        *ppv = static_cast<IKsControl*>(this);
    }
    else if (iid == IID_IDirectMusicThru)
    {
        *ppv = static_cast<IDirectMusicThru*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}


// CDirectMusicEmulatePort::AddRef
//
STDMETHODIMP_(ULONG)
CDirectMusicEmulatePort::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// CDirectMusicEmulatePort::Release
//
STDMETHODIMP_(ULONG)
CDirectMusicEmulatePort::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        if (m_pNotify)
        {
            m_pNotify->NotifyFinalRelease(static_cast<IDirectMusicPort*>(this));
        }
        
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicEmulatePort::Compact

STDMETHODIMP
CDirectMusicEmulatePort::Compact()
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicEmulatePort::GetCaps

STDMETHODIMP
CDirectMusicEmulatePort::GetCaps(
    LPDMUS_PORTCAPS pPortCaps)
{
    V_INAME(IDirectMusicPort::GetCaps);
    V_STRUCTPTR_WRITE(pPortCaps, DMUS_PORTCAPS);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    CopyMemory(pPortCaps, &dmpc, sizeof(DMUS_PORTCAPS));
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicEmulatePort::DeviceIoControl

STDMETHODIMP 
CDirectMusicEmulatePort::DeviceIoControl(
    DWORD dwIoControlCode, 
    LPVOID lpInBuffer, 
    DWORD nInBufferSize, 
    LPVOID lpOutBuffer, 
    DWORD nOutBufferSize, 
    LPDWORD lpBytesReturned, 
    LPOVERLAPPED lpOverlapped)
{
    return E_NOTIMPL;
}


STDMETHODIMP
CDirectMusicEmulatePort::SetNumChannelGroups(
    DWORD   dwNumChannelGroups)
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (dwNumChannelGroups != 1)
    {
        return E_INVALIDARG;
    }

    return S_OK;
}

STDMETHODIMP
CDirectMusicEmulatePort::GetNumChannelGroups(
    LPDWORD   pdwChannelGroups)
{
    V_INAME(IDirectMusicPort::GetNumChannelGroups);
    V_PTR_WRITE(pdwChannelGroups, DWORD);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    *pdwChannelGroups = 1;
    
    return S_OK;
}




// @mfunc Queue a buffer for playback
//
#define REFTIME_TO_MS (10L*1000L)

STDMETHODIMP
CDirectMusicEmulatePort::PlayBuffer(
    IDirectMusicBuffer *pIBuffer)
{
    CDirectMusicBuffer *pBuffer = reinterpret_cast<CDirectMusicBuffer *>(pIBuffer);

    REFERENCE_TIME rt;
    LPBYTE pbData;
    DWORD  cbData;
    DWORD  dwTileInfo;
    LONGLONG msTime;
    MMRESULT mmr;

    V_INAME(IDirectMusicPort::PlayBuffer);
    V_INTERFACE(pIBuffer);
    
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (!m_fIsOutput)
    {
        return E_NOTIMPL;
    }

    if (!m_lActivated)
    {
        return DMUS_E_SYNTHINACTIVE;
    }
    
    // Make sure the object doesn't disappear out from under us while we're in Win16
    //
    pBuffer->AddRef();
    pBuffer->GetUsedBytes(&cbData);
    if (cbData == 0)
    {
        pBuffer->Release();
        return S_OK;
    }

    pBuffer->GetRawBufferPtr(&pbData);
    assert(pbData);
    pBuffer->GetStartTime(&rt);

    // Adjust timebase if we are not using the timeGetTime clock
    //

    Trace(2, "Buffer base time %I64d timeGetTime %u\n", rt, timeGetTime());
    SyncClocks();
    MasterToSlave(&rt);
    Trace(2, "Buffer adjusted base time %I64d\n", rt);



    msTime = rt / REFTIME_TO_MS;

    // Send it through the thunk
    //
    dwTileInfo = dmTileBuffer((DWORD)pbData, cbData);
    mmr = MidiOutSubmitPlaybackBuffer(m_hDevice,
                               TILE_P1616(dwTileInfo),
                               cbData,
                               (DWORD)msTime,
                               (DWORD)(rt & 0xFFFFFFFF),                  // RefTime low
                               (DWORD)((rt >> 32) & 0xFFFFFFFF));       // RefTime high
    dmUntileBuffer(dwTileInfo);

    pBuffer->Release();
    
    return MMRESULTToHRESULT(mmr);
}

STDMETHODIMP
CDirectMusicEmulatePort::Read(
    IDirectMusicBuffer *pIBuffer)
{
    HRESULT hr;
    
    V_INAME(IDirectMusicPort::Read);
    V_INTERFACE(pIBuffer);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (m_fIsOutput)
    {
        return E_NOTIMPL;
    }

    LPBYTE pbBuffer;
    hr = pIBuffer->GetRawBufferPtr(&pbBuffer);
    if (FAILED(hr))
    {
        return hr;
    }

    DWORD cbBuffer;
    hr = pIBuffer->GetMaxBytes(&cbBuffer);
    if (FAILED(hr))
    {
        return hr;
    }

    Trace(1, "Read: buffer size %u\n", cbBuffer);

    LPBYTE pbData = pbBuffer;

    // Since events are now buffered, we read them out of the local queue
    //
    //
    EnterCriticalSection(&m_csEventQueues);

    REFERENCE_TIME rtStart;

    if (m_ReadEvents.pFront)
    {
        rtStart = m_ReadEvents.pFront->e.rtDelta;
    }
    else
    {
        Trace(2, "Read: No events queued\n");
    }

    while (m_ReadEvents.pFront)
    {               
        QUEUED_EVENT *pQueuedEvent = m_ReadEvents.pFront;

        DWORD cbQueuedEvent = DMUS_EVENT_SIZE(pQueuedEvent->e.cbEvent);
        Trace(2, "Read: cbEvent %u  cbQueuedEvent %u\n", 
            pQueuedEvent->e.cbEvent,
            cbQueuedEvent);

        if (cbQueuedEvent > cbBuffer)
        {
            Trace(2, "Read: No more room for events in buffer.\n");
            break;
        }

        Trace(2, "Read: Got an event!\n");

        pQueuedEvent->e.rtDelta -= rtStart;

        CopyMemory(pbData, 
                   &pQueuedEvent->e,
                   sizeof(DMEVENT) - sizeof(DWORD) + pQueuedEvent->e.cbEvent);

        pbData += cbQueuedEvent;
        cbBuffer -= cbQueuedEvent;

        m_ReadEvents.pFront = pQueuedEvent->pNext;

        if (pQueuedEvent->e.cbEvent <= sizeof(DWORD))
        {
            // This event came out of the pool
            //
            m_FreeEvents.Free(pQueuedEvent);
        }
        else
        {
            // This event was allocated via new char[]
            //
            char *pOriginalMemory = (char*)pQueuedEvent;
            delete[] pOriginalMemory;
        }
    }

    if (m_ReadEvents.pFront == NULL)
    {
        m_ReadEvents.pRear = NULL;
    }

    LeaveCriticalSection(&m_csEventQueues);

    // Update the buffer header information to match the events just packed
    //
    Trace(2, "Read: Leaving with %u bytes in buffer\n", (unsigned)(pbData - pbBuffer));
    pIBuffer->SetStartTime(rtStart);
    pIBuffer->SetUsedBytes(pbData - pbBuffer);

    return (pbData == pbBuffer) ? S_FALSE : S_OK;
}

STDMETHODIMP
CDirectMusicEmulatePort::SetReadNotificationHandle(
    HANDLE hEvent)
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (m_fIsOutput)
    {
        return E_NOTIMPL;
    }

    m_hAppEvent = hEvent;

    return S_OK;    
}

STDMETHODIMP
CDirectMusicEmulatePort::DownloadInstrument(
    IDirectMusicInstrument *pInstrument,
    IDirectMusicDownloadedInstrument **pDownloadedInstrument,
    DMUS_NOTERANGE *pRange,
    DWORD dw)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CDirectMusicEmulatePort::UnloadInstrument(
    IDirectMusicDownloadedInstrument *pDownloadedInstrument)
{
    V_INAME(IDirectMusicPort::UnloadInstrument);
    V_INTERFACE(pDownloadedInstrument);

    return E_NOTIMPL;
}

STDMETHODIMP
CDirectMusicEmulatePort::GetLatencyClock(
    IReferenceClock **ppClock)
{
    V_INAME(IDirectMusicPort::GetLatencyClock);
    V_PTRPTR_WRITE(ppClock);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    m_pLatencyClock->AddRef();
    *ppClock = m_pLatencyClock;
    return S_OK;
}

STDMETHODIMP
CDirectMusicEmulatePort::GetRunningStats(
    LPDMUS_SYNTHSTATS pStats)
{
    V_INAME(IDirectMusicPort::GetRunningStats);
    V_STRUCTPTR_WRITE(pStats, DMUS_SYNTHSTATS);

    return E_NOTIMPL;
}

STDMETHODIMP
CDirectMusicEmulatePort::Activate(
    BOOL fActivate)
{
    MMRESULT mmr;

	V_INAME(IDirectMusicPort::Activate);
	
	if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (fActivate)
    {
        if (InterlockedExchange(&m_lActivated, 1)) 
        {
            Trace(0, "Activate: Already active\n");
            // Already activated
            //
            return S_FALSE;
        }    

        mmr = ActivateLegacyDevice(m_hDevice, TRUE);
        if (mmr)
        {
            Trace(0, "Activate: Activate mmr %d\n", mmr);
            m_lActivated = 0;
        }
    }
    else
    {
        if (InterlockedExchange(&m_lActivated, 0) == 0)
        {
            Trace(0, "Activate: Already inactive\n");
            // Already deactivated
            //
            return S_FALSE;
        }

        mmr = ActivateLegacyDevice(m_hDevice, FALSE);
        if (mmr)
        {
            Trace(0, "Activate: Deactivate mmr %d\n", mmr);
            m_lActivated = 1;
        }
    }

    return MMRESULTToHRESULT(mmr);
}

STDMETHODIMP 
CDirectMusicEmulatePort::SetChannelPriority(
    DWORD dwChannelGroup, 
    DWORD dwChannel, 
    DWORD dwPriority)
{
    return E_NOTIMPL;
}
    
STDMETHODIMP 
CDirectMusicEmulatePort::GetChannelPriority(
    DWORD dwChannelGroup, 
    DWORD dwChannel, 
    LPDWORD pdwPriority)
{
    return E_NOTIMPL;
}    


STDMETHODIMP
CDirectMusicEmulatePort::Close()
{
    if (m_hCaptureThread)
    {
        SetEvent(m_hKillThreads);
        if (WaitForSingleObject(m_hCaptureThread, THREAD_KILL_TIMEOUT) == WAIT_TIMEOUT)
        {
            Trace(0, "Warning: Input thread timed out; exit anyway.\n");
        }

        m_hCaptureThread = NULL;
    }

    if (m_pThruMap)
    {
        for (int iChannel = 0; iChannel < 16; iChannel++)
        {
            if (m_pThruMap[iChannel].pDestinationPort == NULL)
            {
                continue;
            }

            if (m_pThruMap[iChannel].fThruInWin16)
            {
                MMRESULT mmr = MidiInThru(m_hDevice,
                                          (DWORD)iChannel,
                                          0,
                                          NULL);
            }

            m_pThruMap[iChannel].pDestinationPort->Release();
        }

        delete[] m_pThruMap;
        m_pThruMap = NULL;
    }

    if (m_pThruBuffer)
    {
        m_pThruBuffer->Release();
        m_pThruBuffer = NULL;
    }

    if (m_hDataReady)
    {
        CloseHandle(m_hDataReady);
        m_hDataReady = NULL;
    }

    if (m_hKillThreads)
    {
        CloseHandle(m_hKillThreads);
        m_hKillThreads = NULL;
    }

    if (m_hAppEvent)
    {
        m_hAppEvent = NULL;
    }

    if (m_dwWorkBufferTileInfo)
    {
        dmUntileBuffer(m_dwWorkBufferTileInfo);
        m_dwWorkBufferTileInfo = 0;
        m_p1616WorkBuffer = NULL; 
    }

    if (m_hVxDEvent)
    {
        CloseVxDHandle(m_hVxDEvent);
        m_hVxDEvent = NULL;
    }
    
    if (m_hDevice)
    {
        CloseLegacyDevice(m_hDevice);
        m_hDevice = NULL;
    }

    if (m_pMasterClock)
    {
        m_pMasterClock->Release();
        m_pMasterClock = NULL;
    }

    if (m_pLatencyClock)
    {
        m_pLatencyClock->Close();
        m_pLatencyClock->Release();
        m_pLatencyClock = NULL;
    }

    if (m_fCSInitialized)
    {
        DeleteCriticalSection(&m_csEventQueues);
    }

    m_pDM = NULL;
    m_pNotify = NULL;

    
    return S_OK;
}

STDMETHODIMP
CDirectMusicEmulatePort::Report()
{
    return S_OK;
}

// StartVoice and StopVoice don't work on legacy devices
//
STDMETHODIMP CDirectMusicEmulatePort::StartVoice(          
     DWORD dwVoiceId,
     DWORD dwChannel,
     DWORD dwChannelGroup,
     REFERENCE_TIME rtStart,
     DWORD dwDLId,
     LONG prPitch,
     LONG veVolume,
     SAMPLE_TIME stVoiceStart,
     SAMPLE_TIME stLoopStart,
     SAMPLE_TIME stLoopEnd)
{
    return E_NOTIMPL;
}    

STDMETHODIMP CDirectMusicEmulatePort::StopVoice(
     DWORD dwVoiceID,
     REFERENCE_TIME rtStop)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDirectMusicEmulatePort::GetVoiceState(   
     DWORD dwVoice[], 
     DWORD cbVoice,
     DMUS_VOICE_STATE VoiceState[])
{
    return E_NOTIMPL;
}
    
STDMETHODIMP CDirectMusicEmulatePort::Refresh(
     DWORD dwDownloadID,
     DWORD dwFlags)
{
    return E_NOTIMPL;
}


// CDirectMusicEmulatePort::ThruChannel
//
STDMETHODIMP 
CDirectMusicEmulatePort::ThruChannel(
    DWORD dwSourceChannelGroup, 
    DWORD dwSourceChannel, 
    DWORD dwDestinationChannelGroup,
    DWORD dwDestinationChannel,
    LPDIRECTMUSICPORT pDestinationPort)
{
    V_INAME(IDirectMusicPort::Thru);
    V_INTERFACE_OPT(pDestinationPort);

    if (m_fIsOutput)
    {
        return E_NOTIMPL;
    }    

    // Channel group must not be zero (broadcast) but in range 1..NumChannelGroups]
    // (which for legacy is always 1)
    //
    if (dwSourceChannelGroup != 1 ||
        dwSourceChannel > 15)
    {
        return E_INVALIDARG;
    }
    
    // Given a port means enable thruing for this channel; NULL means
    // disable.
    //
    if (pDestinationPort)
    {
        // Enabling thruing on this channel. First look at the destination port.
        //
        DMUS_PORTCAPS dmpc;
        dmpc.dwSize = sizeof(dmpc);
        HRESULT hr = pDestinationPort->GetCaps(&dmpc);
        if (FAILED(hr))
        {
            Trace(0, "ThruChannel: Destination port failed portcaps [%08X]\n", hr);
            return hr;
        }

        // Port must be an output port
        //
        if (dmpc.dwClass != DMUS_PC_OUTPUTCLASS)
        {
            return DMUS_E_PORT_NOT_RENDER;
        }

        // Channel group and channel must be in range.
        //
        if (dwDestinationChannel > 15 ||
            dwDestinationChannelGroup > dmpc.dwMaxChannelGroups) 
        {
            return E_INVALIDARG;
        }

        // Release existing port
        //
        if (m_pThruMap[dwSourceChannel].pDestinationPort)
        {
            // Reference to another port type, release it.
            // (NOTE: No need to turn off native dmusic16 thruing at this point,
            // that's handled in dmusic16).
            //
            m_pThruMap[dwSourceChannel].pDestinationPort->Release();
        }


        m_pThruMap[dwSourceChannel].dwDestinationChannel = dwDestinationChannel;
        m_pThruMap[dwSourceChannel].dwDestinationChannelGroup = dwDestinationChannelGroup;
        m_pThruMap[dwSourceChannel].pDestinationPort = pDestinationPort;
        m_pThruMap[dwSourceChannel].fThruInWin16 = FALSE;

        // Is the destination also a legacy port?
        //
        if (dmpc.dwType == DMUS_PORT_WINMM_DRIVER)
        {
            // Woohoo! We can do native thruing in Win16!
            //
            m_pThruMap[dwSourceChannel].fThruInWin16 = TRUE;

            Trace(2, "32: Thruing <%d> -> <%d> in Win16\n", 
                dwSourceChannel,
                dwDestinationChannel);

            MMRESULT mmr = MidiInThru(m_hDevice,
                                      dwSourceChannel,
                                      dwDestinationChannel,
                                      ((CDirectMusicEmulatePort*)pDestinationPort)->m_hDevice);
            if (mmr)
            {
                Trace(0, "ThruChannel: MidiInThru returned %d\n", mmr);
                return MMRESULTToHRESULT(mmr);

            }
        }
        else
        { 
            Trace(2, "ThruChannel: From (%u,%u) -> (%u,%u,%p)\n",
                dwSourceChannelGroup,
                dwSourceChannel,
                dwDestinationChannelGroup,
                dwDestinationChannel,
                pDestinationPort);
        }

        pDestinationPort->AddRef();
    } 
    else
    {
        // Disabling thruing on this channel
        //
        if (m_pThruMap[dwSourceChannel].pDestinationPort)
        {
            if (m_pThruMap[dwSourceChannel].fThruInWin16)
            {
                MMRESULT mmr = MidiInThru(m_hDevice,
                                          dwSourceChannel,
                                          0,
                                          (HANDLE)NULL);
            
                if (mmr)
                {
                    Trace(0, "ThruChannel: MidiInThru returned %d\n", mmr);
                    return MMRESULTToHRESULT(mmr);

                }
            }

            m_pThruMap[dwSourceChannel].pDestinationPort->Release();
            m_pThruMap[dwSourceChannel].pDestinationPort = NULL;
        }
    }

    return S_OK;
}

STDMETHODIMP 
CDirectMusicEmulatePort::SetDirectSound(
    LPDIRECTSOUND pDirectSound, 
    LPDIRECTSOUNDBUFFER pDirectSoundBuffer)
{
    return E_NOTIMPL;
}

STDMETHODIMP 
CDirectMusicEmulatePort::GetFormat(
    LPWAVEFORMATEX pWaveFormatEx, 
    LPDWORD pdwWaveFormatExSize, 
    LPDWORD pdwBufferSize)
{
    return E_NOTIMPL;
}

// CDirectMusicEmulatePort::DownloadWave
//
STDMETHODIMP 
CDirectMusicEmulatePort::DownloadWave(
    IDirectSoundWave *pWave,               
    IDirectSoundDownloadedWaveP **ppWave,
    REFERENCE_TIME rtStartHint)
{
    V_INAME(IDirectMusicPort::DownloadWave);
    V_INTERFACE(pWave);
	V_PTRPTR_WRITE(ppWave);

    return E_NOTIMPL;
}

// CDirectMusicEmulatePort::UnloadWave
//
STDMETHODIMP 
CDirectMusicEmulatePort::UnloadWave(
    IDirectSoundDownloadedWaveP *pDownloadedWave)
{
    V_INAME(IDirectMusicPort::UnloadWave);
    V_INTERFACE(pDownloadedWave);

    return E_NOTIMPL;
}

            
// CDirectMusicEmulatePort::AllocVoice
//
STDMETHODIMP 
CDirectMusicEmulatePort::AllocVoice(
    IDirectSoundDownloadedWaveP *pWave,     
    DWORD dwChannel,                       
    DWORD dwChannelGroup,                  
    REFERENCE_TIME rtStart,                     
    SAMPLE_TIME stLoopStart,
    SAMPLE_TIME stLoopEnd,
    IDirectMusicVoiceP **ppVoice)
{
    V_INAME(IDirectMusicPort::AllocVoice);
    V_INTERFACE(pWave);
    V_PTRPTR_WRITE(ppVoice);

    return E_NOTIMPL;
}        

// CDirectMusicEmulatePort::AssignChannelToBuses
//
STDMETHODIMP 
CDirectMusicEmulatePort::AssignChannelToBuses(
    DWORD dwChannelGroup,
    DWORD dwChannel,
    LPDWORD pdwBuses,
    DWORD cBusCount)
{
    return E_NOTIMPL;
}        

STDMETHODIMP
CDirectMusicEmulatePort::SetSink(
    IDirectSoundConnect *pSinkConnect)
{
    return E_NOTIMPL;
}        

STDMETHODIMP
CDirectMusicEmulatePort::GetSink(
    IDirectSoundConnect **ppSinkConnect)
{
    return E_NOTIMPL;
}        

GENERICPROPERTY CDirectMusicEmulatePort::m_aProperty[] = 
{      
    { &GUID_DMUS_PROP_LegacyCaps,           // Set
      0,                                    // Item
      KSPROPERTY_SUPPORT_GET,               // KS support flags
      GENPROP_F_FNHANDLER,                  // GENPROP flags
      NULL, 0,                              // static data and size
      CDirectMusicEmulatePort::LegacyCaps   // Handler
    }
};

const int CDirectMusicEmulatePort::m_nProperty = sizeof(m_aProperty) / sizeof(m_aProperty[0]);


HRESULT CDirectMusicEmulatePort::LegacyCaps(
    ULONG               ulId, 
    BOOL                fSet, 
    LPVOID              pbBuffer, 
    PULONG              pcbBuffer)
{
    if (fSet == KSPROPERTY_SUPPORT_SET)
    {
        return DMUS_E_SET_UNSUPPORTED;
    }

    MIDIINCAPS  mic;
    MIDIOUTCAPS moc;
    LPBYTE      pbData;
    ULONG       cbData;

    if (m_fIsOutput)
    {    
        MMRESULT mmr = midiOutGetDevCaps(m_id, &moc, sizeof(moc));
        if (mmr)
        {
            Trace(0, "midiOutGetDevCaps failed!\n");
            return MMRESULTToHRESULT(mmr);
        }

        pbData = (LPBYTE)&moc;
        cbData = sizeof(moc);
    }
    else
    {
        MMRESULT mmr = midiInGetDevCaps(m_id, &mic, sizeof(mic));
        if (mmr)
        {
            Trace(0, "midiInGetDevCaps failed!\n");
            return MMRESULTToHRESULT(mmr);
        }

        pbData = (LPBYTE)&mic;
        cbData = sizeof(mic);
    }

    ULONG cbToCopy = min(*pcbBuffer, cbData);
    CopyMemory(pbBuffer, pbData, cbToCopy);
    *pcbBuffer = cbToCopy;

    return S_OK;
}

// 
// CDirectMusicEmulatePort::FindPropertyItem
//
// Given a GUID and an item ID, find the associated property item in the synth's
// table of SYNPROPERTY's.
//
// Returns a pointer to the entry or NULL if the item was not found.
//
GENERICPROPERTY *CDirectMusicEmulatePort::FindPropertyItem(REFGUID rguid, ULONG ulId)
{
    GENERICPROPERTY *pPropertyItem = &m_aProperty[0];
    GENERICPROPERTY *pEndOfItems = pPropertyItem + m_nProperty;

    for (; pPropertyItem != pEndOfItems; pPropertyItem++)
    {
        if (*pPropertyItem->pguidPropertySet == rguid && 
             pPropertyItem->ulId == ulId)
        {
            return pPropertyItem;
        }
    }

    return NULL;
}

#define KS_VALID_FLAGS (KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_GET| KSPROPERTY_TYPE_BASICSUPPORT)

STDMETHODIMP CDirectMusicEmulatePort::KsProperty(
    PKSPROPERTY pPropertyIn, ULONG ulPropertyLength,
    LPVOID pvPropertyData, ULONG ulDataLength,
    PULONG pulBytesReturned)
{
    V_INAME(DirectMusicSynthPort::IKsContol::KsProperty);
    V_BUFPTR_WRITE(pPropertyIn, ulPropertyLength);
    V_BUFPTR_WRITE_OPT(pvPropertyData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);

    DWORD dwFlags = pPropertyIn->Flags & KS_VALID_FLAGS;
    if ((dwFlags == 0) || (dwFlags == (KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_GET)))
    {
    }

    GENERICPROPERTY *pProperty = FindPropertyItem(pPropertyIn->Set, pPropertyIn->Id);

    if (pProperty == NULL)
    {
        return DMUS_E_UNKNOWN_PROPERTY;
    }

    switch (dwFlags)
    {
        case KSPROPERTY_TYPE_GET:
            if (!(pProperty->ulSupported & KSPROPERTY_SUPPORT_GET))
            {
                return DMUS_E_GET_UNSUPPORTED;
            }

            if (pProperty->ulFlags & GENPROP_F_FNHANDLER)
            {
                GENPROPHANDLER pfn = pProperty->pfnHandler;
                *pulBytesReturned = ulDataLength;
                return (this->*pfn)(pPropertyIn->Id, KSPROPERTY_SUPPORT_GET, pvPropertyData, pulBytesReturned);
            }
    
            if (ulDataLength > pProperty->cbPropertyData)
            {
                ulDataLength = pProperty->cbPropertyData;
            }

            CopyMemory(pvPropertyData, pProperty->pPropertyData, ulDataLength);
            *pulBytesReturned = ulDataLength;

            return S_OK;

        case KSPROPERTY_TYPE_SET:
            if (!(pProperty->ulSupported & KSPROPERTY_SUPPORT_SET))
            {
                return DMUS_E_SET_UNSUPPORTED;
            }

            if (pProperty->ulFlags & GENPROP_F_FNHANDLER)
            {
                GENPROPHANDLER pfn = pProperty->pfnHandler;
                return (this->*pfn)(pPropertyIn->Id, KSPROPERTY_SUPPORT_SET, pvPropertyData, &ulDataLength);
            }

            if (ulDataLength > pProperty->cbPropertyData)
            {
                ulDataLength = pProperty->cbPropertyData;
            }

            CopyMemory(pProperty->pPropertyData, pvPropertyData, ulDataLength);

            return S_OK;
            

        case KSPROPERTY_TYPE_BASICSUPPORT:
            if (pProperty == NULL)
            {
                return DMUS_E_UNKNOWN_PROPERTY;
            }

            // XXX Find out what convention is for this!!
            //
            if (ulDataLength < sizeof(DWORD))
            {
                return E_INVALIDARG;
            }

            *(LPDWORD)pvPropertyData = pProperty->ulSupported;    
            *pulBytesReturned = sizeof(DWORD);
            
            return S_OK;
    }

    Trace(-1, "%s: Flags must contain one of\n"
              "\tKSPROPERTY_TYPE_SET, KSPROPERTY_TYPE_GET, or KSPROPERTY_TYPE_BASICSUPPORT\n");
    return E_INVALIDARG;
}

STDMETHODIMP CDirectMusicEmulatePort::KsMethod(
    PKSMETHOD pMethod, ULONG ulMethodLength,
    LPVOID pvMethodData, ULONG ulDataLength,
    PULONG pulBytesReturned)
{
    V_INAME(DirectMusicSynth::IKsContol::KsMethod);
    V_BUFPTR_WRITE(pMethod, ulMethodLength);
    V_BUFPTR_WRITE_OPT(pvMethodData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);

    return DMUS_E_UNKNOWN_PROPERTY;
}
STDMETHODIMP CDirectMusicEmulatePort::KsEvent(
    PKSEVENT pEvent, ULONG ulEventLength,
    LPVOID pvEventData, ULONG ulDataLength,
    PULONG pulBytesReturned)
{
    V_INAME(DirectMusicSynthPort::IKsContol::KsEvent);
    V_BUFPTR_WRITE(pEvent, ulEventLength);
    V_BUFPTR_WRITE_OPT(pvEventData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);
    
    return DMUS_E_UNKNOWN_PROPERTY;
}

#define OFFSET_DATA_READY   0
#define OFFSET_KILL_THREAD  1

DWORD CDirectMusicEmulatePort::InputWorker()
{
    HANDLE h[2];

    h[OFFSET_DATA_READY]  = m_hDataReady;
    h[OFFSET_KILL_THREAD] = m_hKillThreads;

    UINT uWait;

    for(;;) 
    {
        uWait = WaitForMultipleObjects(2, h, FALSE, INFINITE);

        switch(uWait)
        {
            case WAIT_OBJECT_0 + OFFSET_DATA_READY:
                // m_hDataReady set
                //
                InputWorkerDataReady();
                if (m_hAppEvent)
                {
                    try
                    {
                        SetEvent(m_hAppEvent);
                    } 
                    catch (...)
                    {
                        Trace(0, "Capture: Application notify event handle prematurely free'd!\n");
                    }
                }
                break;

            case WAIT_OBJECT_0 + OFFSET_KILL_THREAD:
                // m_hKillThread set
                //
                Trace(0, "CDirectMusicEmulateWorker::InputWorker thread exit\n");
                return 0;

            case WAIT_FAILED:
                Trace(0, "WaitForMultipleObjects failed %d killing thread\n", GetLastError());
                return 0;

            default:
                break;
        }            
    }

    return 0;
}

// CDirectMusicEmulatePort::InputWorkerDataReady()
//
// The input worker thread has been notified that there is data available. 
// Read any pending events from the 16-bit DLL, perform needed thruing, and
// save the data in a queue so we can repackage it on the read request
// from the client.
//
void CDirectMusicEmulatePort::InputWorkerDataReady()
{
    MMRESULT mmr;
    DWORD cbData;
    DWORD msTime;
    LPBYTE pbData;
    DMEVENT *pEvent;
    DWORD cbRounded;
    REFERENCE_TIME rtStart;
    HRESULT hr;
    REFERENCE_TIME rtMasterClock;

    Trace(0, "Enter InputWorkerDataReady()\n");
    for(;;)
    {
        // Fill temporary buffer
        //
        cbData = sizeof(m_WorkBuffer);
        mmr = MidiInRead(m_hDevice,
                         m_p1616WorkBuffer,
                         &cbData,
                         &msTime);

        rtStart = ((ULONGLONG)msTime) * REFTIME_TO_MS;
        SyncClocks();
        SlaveToMaster(&rtStart);
        
        hr = m_pMasterClock->GetTime(&rtMasterClock);

        if (mmr)
        {
            Trace(2, "InputWorkerDataReady: MidiInRead returned %d\n", mmr);
            return;
        }

        if (cbData == 0)
        {
            Trace(2, "MidiInRead returned no data\n");
            return;
        }

        // Copy temporary buffer as events into queue
        //
        pbData = m_WorkBuffer;
        while (cbData)
        {
            pEvent = (DMEVENT*)pbData;
            cbRounded = DMUS_EVENT_SIZE(pEvent->cbEvent);

            Trace(2, "cbData %u  cbRounded %u\n", cbData, cbRounded);

            if (cbRounded > cbData)
            {
                Trace(0, "InputWorkerDataReady: Event ran off end of buffer\n");
                break;
            }

            cbData -= cbRounded;
            pbData += cbRounded;

            EnterCriticalSection(&m_csEventQueues);

            QUEUED_EVENT *pQueuedEvent;
            int cbEvent;

            
            if (pEvent->cbEvent <= sizeof(DWORD))
            {
                // Channel message or other really small event, take from
                // free pool.
                //
                pQueuedEvent = m_FreeEvents.Alloc();
                cbEvent = sizeof(DMEVENT);

                Trace(2, "Queue [%02X %02X %02X %02X]\n",
                    pEvent->abEvent[0],
                    pEvent->abEvent[1],
                    pEvent->abEvent[2],
                    pEvent->abEvent[3]);
            }
            else
            {
                // SysEx or other long event, just allocate it
                //
                cbEvent = DMUS_EVENT_SIZE(pEvent->cbEvent);
                pQueuedEvent = (QUEUED_EVENT*)new char[QUEUED_EVENT_SIZE(pEvent->cbEvent)];
            }

            if (pQueuedEvent)
            {

                CopyMemory(&pQueuedEvent->e, pEvent, cbEvent);

                // rtDelta is the absolute time of the event while it's in our queue
                //
                pQueuedEvent->e.rtDelta += rtStart;
                ThruEvent(&pQueuedEvent->e);

        
                if (m_ReadEvents.pFront)
                {
                    m_ReadEvents.pRear->pNext = pQueuedEvent;
                }
                else
                {
                    m_ReadEvents.pFront = pQueuedEvent;   
                }

                m_ReadEvents.pRear = pQueuedEvent;
                pQueuedEvent->pNext = NULL;
            }
            else
            {
                Trace(1, "InputWorker: Failed to allocate event; dropping\n");
            }        
            LeaveCriticalSection(&m_csEventQueues);
        }
    }    
    Trace(2, "Leave InputWorkerDataReady()\n");
}

void CDirectMusicEmulatePort::ThruEvent(
    DMEVENT *pEvent)
{
    // Since we know we only have one event and we already have it in the right format,
    // just slam it into the thru buffer. We only have to do this because we might modify 
    // it.
    //
    LPBYTE pbData;
    DWORD  cbData;
    DWORD  cbEvent = DMUS_EVENT_SIZE(pEvent->cbEvent);

    // First see if the event is thruable
    //
    if (pEvent->cbEvent > 3 || ((pEvent->abEvent[0] & 0xF0) == 0xF0))
    {
        // SysEx of some description
        return;
    }

    // Note: legacy driver assures no running status
    //
    DWORD dwSourceChannel = (DWORD)(pEvent->abEvent[0] & 0x0F);

    DMUS_THRU_CHANNEL *pThru = &m_pThruMap[dwSourceChannel];
    if (pThru->pDestinationPort == NULL ||
        pThru->fThruInWin16)
    {
        return;
    }

    if (FAILED(m_pThruBuffer->GetRawBufferPtr(&pbData)))
    {
        Trace(0, "Thru: GetRawBufferPtr\n");
        return;
    }

    if (FAILED(m_pThruBuffer->GetMaxBytes(&cbData)))
    {
        Trace(0, "Thru: GetMaxBytes\n");
        return;
    }

    if (cbEvent > cbData)
    {
        Trace(0, "Thru: cbData %u  cbEvent %u\n", cbData, cbEvent);
        return;
    }
    
    if (FAILED(m_pThruBuffer->SetStartTime(pEvent->rtDelta)) ||
        FAILED(m_pThruBuffer->SetUsedBytes(cbEvent)))
    {
        Trace(0, "Thru: buffer setup failed\n");
    }

    pEvent->rtDelta = 50000;
    CopyMemory(pbData, pEvent, cbEvent);

    pEvent = (DMEVENT*)pbData;
    pEvent->dwChannelGroup = pThru->dwDestinationChannelGroup;
    pEvent->abEvent[0] = (BYTE)((pEvent->abEvent[0] & 0xF0) | pThru->dwDestinationChannel);

    pThru->pDestinationPort->PlayBuffer(m_pThruBuffer);
}

void CDirectMusicEmulatePort::MasterToSlave(
    REFERENCE_TIME *prt)
{
    if (m_fSyncToMaster)
    {
        *prt -= m_lTimeOffset;
    }
}

void CDirectMusicEmulatePort::SlaveToMaster(
    REFERENCE_TIME *prt)
{
    if (m_fSyncToMaster)
    {
        *prt += m_lTimeOffset;
    }
}

void CDirectMusicEmulatePort::SyncClocks()
{
    HRESULT hr;
    REFERENCE_TIME rtMasterClock;
    REFERENCE_TIME rtSlaveClock;
    LONGLONG drift;

    if (m_fSyncToMaster)
    {
        hr = m_pMasterClock->GetTime(&rtMasterClock);
        rtSlaveClock = ((ULONGLONG)timeGetTime()) * MS_TO_REFERENCE_TIME;
        if (FAILED(hr))
        {
            return;
        }


        drift = (rtSlaveClock + m_lTimeOffset) - rtMasterClock;

        // Work-around 46782 for DX8 release:
        // If drift is greater than 10ms, jump to the new offset value instead
        // of drifting there slowly.
        if( drift > 10000 * 10
        ||  drift < 10000 * -10 )
        {
            m_lTimeOffset -= drift;
        }
        else
        {
            m_lTimeOffset -= drift / 100;
        }
    }
}




/////////////////////////////////////////////////////////////////////
//
// CEmulateLatencyClock
//
// Latency clock for emulated ports, which is just a fixed offset from
// the DirectMusic master clock
//
CEmulateLatencyClock::CEmulateLatencyClock(IReferenceClock *pMasterClock) :
   m_cRef(1),
   m_pMasterClock(pMasterClock)
{
    pMasterClock->AddRef();
}

CEmulateLatencyClock::~CEmulateLatencyClock()
{
    Close();
}

STDMETHODIMP
CEmulateLatencyClock::QueryInterface(
    const IID &iid,
    void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IReferenceClock)
    {
        *ppv = static_cast<IReferenceClock*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG)
CEmulateLatencyClock::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CEmulateLatencyClock::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CEmulateLatencyClock::GetTime(
    REFERENCE_TIME *pTime)
{
    REFERENCE_TIME rt;

    V_INAME(IReferenceClock::GetTime);
    V_PTR_WRITE(pTime, REFERENCE_TIME);

    if (!m_pMasterClock)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }
    
    HRESULT hr = m_pMasterClock->GetTime(&rt);

    rt += FIXED_LEGACY_LATENCY_OFFSET;          // Default : 10 ms
    *pTime = rt;
    
    return hr;
}

STDMETHODIMP
CEmulateLatencyClock::AdviseTime(
    REFERENCE_TIME baseTime,  
    REFERENCE_TIME streamTime,
    HANDLE hEvent,            
    DWORD * pdwAdviseCookie)
{
    return DMUS_E_UNKNOWN_PROPERTY;
}

STDMETHODIMP
CEmulateLatencyClock::AdvisePeriodic(
    REFERENCE_TIME startTime,
    REFERENCE_TIME periodTime,
    HANDLE hSemaphore,   
    DWORD * pdwAdviseCookie)
{
    return DMUS_E_UNKNOWN_PROPERTY;
}

STDMETHODIMP
CEmulateLatencyClock::Unadvise(
    DWORD dwAdviseCookie)
{
    return DMUS_E_UNKNOWN_PROPERTY;
}


void
CEmulateLatencyClock::Close()
{
    if (m_pMasterClock)
    {
        m_pMasterClock->Release();
        m_pMasterClock = NULL;
    }
}

static HRESULT MMRESULTToHRESULT(
    MMRESULT mmr)
{
    switch (mmr)
    {
    case MMSYSERR_NOERROR:
        return S_OK;

    case MMSYSERR_ALLOCATED:
        return DMUS_E_DEVICE_IN_USE;

    case MIDIERR_BADOPENMODE:
        return DMUS_E_ALREADYOPEN;

    case MMSYSERR_NOMEM:
        return E_OUTOFMEMORY;
    }

    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic32\dmthunk.h ===
// Copyright (c) 1998 Microsoft Corporation
/*
 * Prototypes for thunked functions between DMusic32.dll and DMusic16.dll
 */
#ifndef _DMTHUNK_
#define _DMTHUNK_

#ifdef __cplusplus
extern "C" {
#endif

extern void PASCAL dmUntileBuffer(DWORD dwTilingInfo);
extern DWORD PASCAL dmTileBuffer(DWORD dwFlatMemory, DWORD dwLength);
extern MMRESULT PASCAL OpenLegacyDevice(DWORD dwId, BOOL fIsOutput, BOOL fShare, HANDLE *pHandle);
extern MMRESULT PASCAL CloseLegacyDevice(HANDLE h);
extern MMRESULT PASCAL ActivateLegacyDevice(HANDLE h, DWORD fActivate);

extern MMRESULT PASCAL MidiOutSubmitPlaybackBuffer(HANDLE hMidiOut, DWORD pbBuffer, DWORD cbBuffer, DWORD msStartTime,
												   DWORD rtStartTimeLow, DWORD rtStartTimeHigh);

extern MMRESULT PASCAL MidiInSetEventHandle(HANDLE hMidiIn, DWORD hEvent);
extern MMRESULT PASCAL MidiInRead(HANDLE hMidiIn, DWORD pbBuffer, DWORD *cbBuffer, DWORD *msStartTime);
extern MMRESULT PASCAL MidiInThru(HANDLE hMidiIn, DWORD dwFrom, DWORD dwTo, HANDLE hMidiOut);

#ifdef __cplusplus
};
#endif 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic32\dmusic32.h ===
// Copyright (c) 1998 Microsoft Corporation
//
    //
//
#ifndef _DMUSIC32_
#define _DMUSIC32_

typedef HRESULT (*PORTENUMCB)(
    LPVOID pInstance,          // @parm Callback instance data
    DMUS_PORTCAPS &dmpc,                              
    PORTTYPE pt,                              
    int idxDev,                // @parm The WinMM or SysAudio device ID of this driver
    int idxPin,                // @parm The Pin ID of the device or -1 if the device is a legacy device
    int idxNode,               // @parm The node ID of the device's synth node (unused for legacy)
    HKEY hkPortsRoot);         // @parm Where port information is stored in the registry


extern HRESULT EnumLegacyDevices(
    LPVOID pInstance,          // @parm Callback instance data
    PORTENUMCB cb);            // @parm Pointer to callback function

typedef HRESULT (__stdcall *PENUMLEGACYDEVICES)(
    LPVOID pInstance,          // @parm Callback instance data
    PORTENUMCB cb);            // @parm Pointer to callback function

extern HRESULT CreateCDirectMusicEmulatePort(
    PORTENTRY *pPE,
    CDirectMusic *pDM,
    LPDMUS_PORTPARAMS pPortParams,
    IDirectMusicPort **pPort);

typedef HRESULT (__stdcall *PCREATECDIRECTMUSICEMULATEPORT)(
    PORTENTRY *pPE,
    CDirectMusic *pDM,
    LPDMUS_PORTPARAMS pPortParams,
    IDirectMusicPort **pPort);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dswave\debug.h ===
//
// debug.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note:
//

#ifndef DEBUG_H
#define DEBUG_H

#include <windows.h>

#define DM_DEBUG_CRITICAL		1	// Used to include critical messages
#define DM_DEBUG_NON_CRITICAL	2	// Used to include level 1 plus important non-critical messages
#define DM_DEBUG_STATUS			3	// Used to include level 1 and level 2 plus status\state messages
#define DM_DEBUG_FUNC_FLOW		4	// Used to include level 1, level 2 and level 3 plus function flow messages
#define DM_DEBUG_ALL			5	// Used to include all debug messages

// Default to no debug output compiled
//
#define Trace
#define TraceI
#define assert(exp) ((void)0)

#ifdef DBG

// Checked build: include at least external debug spew
//
extern void DebugInit(void);
extern void DebugTrace(int iDebugLevel, LPSTR pstrFormat, ...);
extern void DebugAssert(LPSTR szExp, LPSTR szFile, ULONG ulLine);

# undef Trace
# define Trace DebugTrace

# undef assert
# define assert(exp) (void)( (exp) || (DebugAssert(#exp, __FILE__, __LINE__), 0) )

// If internal build flag set, include everything
//
# ifdef DMUSIC_INTERNAL
#  undef TraceI
#  define TraceI DebugTrace
# endif

#endif  // #ifdef DBG

#endif  // #ifndef DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic32\mmdevldr.h ===
/*
 *  MMDEVLDR.H - The main include file for the DevLoader
 *
 *  Version 4.00
 *
 *  Copyright (c) 1994-1998 Microsoft Corporation
 *
 */

#ifdef _WIN32                                                           /* ;BeginInternal */
#define MMDEVLDR_IOCTL_GETVERSION           0
#define MMDEVLDR_IOCTL_LINPAGELOCK          1
#define MMDEVLDR_IOCTL_LINPAGEUNLOCK        2
#define MMDEVLDR_IOCTL_RING0THREADHANDLE    3
#define MMDEVLDR_IOCTL_QUEUEAPC             4
#define MMDEVLDR_IOCTL_GETCHANGENOTIFYPTR   5
#define MMDEVLDR_IOCTL_CLOSEVXDHANDLE       6
#define MMDEVLDR_IOCTL_PAGEALLOCATE         7
#define MMDEVLDR_IOCTL_PAGEFREE             8
#define MMDEVLDR_IOCTL_GETDEVICESTATUS      9

#define MM_DEVSTATUS_ERROR          0
#define MM_DEVSTATUS_STARTED        1
#define MM_DEVSTATUS_UNKNOWNPROB    2
#define MM_DEVSTATUS_DISABLED       3


typedef struct tagLOCKUNLOCKPARMS
{
    DWORD           dwStartPage;
    DWORD           dwPageCount;
    DWORD           fdwOperation;
}   LOCKUNLOCKPARMS;

typedef struct tagQUEUEAPCPARMS
{
    DWORD           fnCallback;
    DWORD           dwUser;
    DWORD           hRing0Thd;
}   QUEUEAPCPARMS;

typedef struct tagPAGEALLOCATEPARMS
{
    DWORD           dwFlags;
    DWORD           dwPageCount;
} PAGEALLOCATEPARMS;

typedef struct tagPAGEALLOCATERETURN
{
    VOID *          lpvBase;
    DWORD           hMem;
    DWORD           dwPageCount;
    DWORD           dwPhysBase;
} PAGEALLOCATERETURN;

#endif

#ifdef MMDEVLDR_VXD
#define MM_STOP         0
#define MM_START        1
#define MM_MMDEVLDR_UP  3
#define MM_REMOVE       4

#define CONFIG_QUERYSTART       0x01000

#define MAXLEN  256

typedef struct tagMMDEVNODE
{
   DEVNODE      dn ;
   DWORD        dwDevStatus ;
   VMMLIST      hlDrivers ;
   BOOL         IsWDMDriver ;

} MMDEVNODE, *PMMDEVNODE ;


typedef struct tagMMDRVNODE
{
   CMCONFIGHANDLER  pConfigHandler ;
   DWORD            dwRefData ;

} MMDRVNODE, *PMMDRVNODE ;

//
// macros
//

#define SIZEOF_ARRAY(ar)        (sizeof(ar)/sizeof((ar)[0]))

#if defined(DEBUG_RETAIL) || defined(DEBUG)
#define DBG_TRACE(strings) {\
        _Debug_Printf_Service( "MMDEVLDR: "); \
        _Debug_Printf_Service##strings; \
        _Debug_Printf_Service("\n");}
#ifdef DEBUG
#define DBG_ERROR(strings) {\
        _Debug_Printf_Service( "MMDEVLDR ERROR: "); \
        _Debug_Printf_Service##strings; \
        _Debug_Printf_Service("\n");\
        {_asm   int     3}}
#else
#define DBG_ERROR(strings) {\
        _Debug_Printf_Service( "MMDEVLDR ERROR: "); \
        _Debug_Printf_Service##strings; \
        _Debug_Printf_Service("\n");}
#endif
#else
   #define DBG_TRACE(strings)
   #define DBG_ERROR(strings)
#endif

#ifdef DEBUG
#define DPF( strings ) _Debug_Printf_Service##strings;

void __cdecl _my_assert(void *, void *, unsigned);

#define ASSERT(exp) (void)( (exp) || (_my_assert(#exp, __FILE__, __LINE__), 0) )

#else

#define DPF( strings )
#define ASSERT( exp )

#endif

#define QUOTE(x) #x
#define QQUOTE(y) QUOTE(y)
#define REMIND(str) __FILE__ "(" QQUOTE(__LINE__) ") : " str

//
// internal function prototypes
//

void MMDEVLDR_Call_MMSystem(DEVNODE dnDevNode, DWORD fLoad);
void MMDEVLDR_CheckForMMSystem(void);
DWORD StringLen(PCHAR psz);
PCHAR StringCopy(PCHAR pszDst, PCHAR pszSrc);
PCHAR StringCat(PCHAR pszDst, PCHAR pszSrc);

#pragma warning (disable:4035)          // turn off no return code warning
PSTR VXDINLINE Get_Environment_String
(
    PSTR            pszName
)
{
    _asm push esi
    _asm mov esi, pszName
    VMMCall( Get_Environment_String ) ;
    _asm mov   eax, edx
    _asm pop   esi
}
#pragma warning (default:4035)     // turn on no return code warning

BOOL _InitGlobalEnvironment() ;

VOID MMDEVLDR_SetEnvironmentString
(
    PSTR            pszName,
    PSTR            pszValue
) ;

BOOL MMDEVLDR_GetEnvironmentString
(
    PSTR            pszName,
    PSTR            pszValue,
    UINT            uBufSize
) ;

VOID MMDEVLDR_RemoveEnvironmentString
(
    PSTR            pszName
) ;

VOID    MMDEVLDR_AddEnvironmentString
(
    PSTR            pszName,
    PSTR            pszValue
) ;

#else                                                           /* ;EndInternal */


#define Multimedia_OEM_ID   0x0440      //            ; MS Reserved OEM # 34
#define MMDEVLDR_DEVICE_ID  Multimedia_OEM_ID + 10      //;MMDEVLDR's device ID

#ifdef Begin_Service_Table              // define only if vmm.h is included

#define MMDEVLDR_Service        Declare_Service
#pragma warning (disable:4003)          // turn off not enough params warning

//MACROS
Begin_Service_Table(MMDEVLDR)

MMDEVLDR_Service        (MMDEVLDR_Register_Device_Driver, LOCAL)
MMDEVLDR_Service        (MMDEVLDR_SetDevicePresence)
MMDEVLDR_Service  (MMDEVLDR_SetEnvironmentString)
MMDEVLDR_Service  (MMDEVLDR_GetEnvironmentString)
MMDEVLDR_Service  (MMDEVLDR_RemoveEnvironmentString)
MMDEVLDR_Service  (MMDEVLDR_AddEnvironmentString)

End_Service_Table(MMDEVLDR)
//ENDMACROS

#pragma warning (default:4003)          // turn on not enough params warning

#pragma warning (disable:4035)          // turn off no return code warning

VOID VXDINLINE MMDEVLDR_Register_Device_Driver
(
    DEVNODE         dnDevNode,
    DWORD           fnConfigHandler,
    DWORD           dwUserData
)
{
    _asm push ebx
    _asm mov eax,dnDevNode
    _asm mov ebx,fnConfigHandler
    _asm mov ecx,dwUserData
    Touch_Register(edx)
    VxDCall(MMDEVLDR_Register_Device_Driver);
    _asm pop ebx
}

VOID VXDINLINE MMDEVLDR_SetDevicePresence
(
    DEVNODE         dn,
    PCHAR           pszReg,
    BOOL            fPresent
)
{
    _asm push fPresent
    _asm push pszReg
    _asm push dn
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_SetDevicePresence);
    _asm add  esp, 3*4
} ;

VOID VXDINLINE MMDEVLDR_SetEnvironmentString
(
    PCHAR           pszName,
    PCHAR           pszValue
)
{
    _asm push pszValue
    _asm push pszName
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_SetEnvironmentString);
    _asm add  esp, 2*4
} ;

BOOL VXDINLINE MMDEVLDR_GetEnvironmentString
(
    PCHAR           pszName,
    PCHAR           pszValue,
    UINT            uBufSize
)
{
    _asm push uBufSize
    _asm push pszValue
    _asm push pszName
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_GetEnvironmentString);
    _asm add  esp, 3*4
} ;

VOID VXDINLINE MMDEVLDR_RemoveEnvironmentString
(
    PCHAR           pszName
)
{
    _asm push pszName
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_RemoveEnvironmentString);
    _asm add  esp, 4
} ;

VOID VXDINLINE MMDEVLDR_AddEnvironmentString
(
    PCHAR           pszName,
    PCHAR           pszValue
)
{
    _asm push pszValue
    _asm push pszName
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_AddEnvironmentString);
    _asm add  esp, 2*4
} ;

#pragma warning (disable:4035)          // turn on no return code warning

#endif // Begin_Service_Table

#endif                  /* ;Internal */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic32\win9x\makefile.inc ===
..\i386\dmthunk.asm:    ..\dmthunk.thk
    thunk -o $@ $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic32\enumport.cpp ===
// Copyright (c) 1998 Microsoft Corporation
#include <windows.h>
#include <mmsystem.h>
#include <dsoundp.h>
#include <regstr.h>

#include "dmusicc.h"
#include "..\dmusic\dmusicp.h"

#include "dmusic32.h"


// @globalv Registry location of legacy driver port definitions
const char cszPortsRoot[] = REGSTR_PATH_PRIVATEPROPERTIES "\\Midi\\Ports";

// @mfunc:(INTERNAL) Update the port list with legacy devices enumerated via 
// the WinMM MIDI API.
//
// @rdesc Returns one of the following:
//
// @flag S_OK | On success
// @flag S_FALSE | If there were no devices found
// @flag E_OUTOFMEMORY | If there was insufficient memory to build the port list
//
//
HRESULT EnumLegacyDevices(
    LPVOID pInstance,
    PORTENUMCB cb)                          
{
    MIDIOUTCAPS moc;
    MIDIINCAPS mic;
    int idxDev;
    int cDev;
    UINT cAdded;
    HRESULT hr;
    HKEY hkPortsRoot;
    DMUS_PORTCAPS dmpc;

    // Initialize caps with stuff that doesn't change
    //
    ZeroMemory(&dmpc, sizeof(dmpc));
    dmpc.dwSize = sizeof(dmpc);
    dmpc.dwMaxChannelGroups = 1;


    // Try to open the port registry key. We will continue even if this fails and use
    // non-persistent GUID's.
    //
    if (RegCreateKey(HKEY_LOCAL_MACHINE, cszPortsRoot, &hkPortsRoot))
    {
        hkPortsRoot = NULL;
    }

    cAdded = 0;
    
    // MIDI output devices
    //
    // Starts at -1 == MIDI mapper
    //
    cDev = (int)midiOutGetNumDevs();
    for (idxDev = -1; idxDev < cDev; ++idxDev)
    {
        if (midiOutGetDevCaps((UINT)idxDev, &moc, sizeof(moc)))
        {
            continue;
        }

        // NOTE: Since this DLL is only Win9x, we know that moc.szPname
        // is from midiOutGetDevCapsA
        //
        MultiByteToWideChar(
            CP_OEMCP,
            0,
            moc.szPname,
            -1,
            dmpc.wszDescription,
            sizeof(dmpc.wszDescription));

        dmpc.dwClass = DMUS_PC_OUTPUTCLASS;
        dmpc.dwType  = DMUS_PORT_WINMM_DRIVER;
        dmpc.dwFlags = DMUS_PC_SHAREABLE;

        if (moc.wTechnology == MOD_MIDIPORT)
        {
            dmpc.dwFlags |= DMUS_PC_EXTERNAL;
        }
        
        hr = (*cb)(pInstance,
                   dmpc,
                   ptLegacyDevice,
                   idxDev,
                   -1,
                   -1,          
                   hkPortsRoot);
        if (SUCCEEDED(hr))
        {
            ++cAdded;
        }
        else if (hr == E_OUTOFMEMORY)
        {
            return hr;
        }
    }

    // MIDI input devices
    //
    // NOTE: Starts at 0, no input mapper
    //
    cDev = (int)midiInGetNumDevs();
    for (idxDev = 0; idxDev < cDev; ++idxDev)
    {
        if (midiInGetDevCaps((UINT)idxDev, &mic, sizeof(mic)))
        {
            continue;
        }
                   
        MultiByteToWideChar(
            CP_OEMCP,
            0,
            mic.szPname,
            -1,
            dmpc.wszDescription,
            sizeof(dmpc.wszDescription));

        
        dmpc.dwClass = DMUS_PC_INPUTCLASS;
        dmpc.dwFlags = DMUS_PC_EXTERNAL;
        
        hr = (*cb)(pInstance,
                   dmpc,
                   ptLegacyDevice,
                   idxDev,
                   -1,        // PinID -1 flags as legacy device
                   -1,
                   hkPortsRoot);
        if (SUCCEEDED(hr))
        {
            ++cAdded;
        }
        else if (hr == E_OUTOFMEMORY)
        {
            return hr;
        }
    }

    if (hkPortsRoot)
    {
        RegCloseKey(hkPortsRoot);
    }

    return cAdded ? S_OK : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dmusic32\tpool.h ===
// Copyright (c) 1998 Microsoft Corporation
//
// TPool.h
//
// Template pool memory manager. Efficiently manage requests for many of the same (small) object.
// Named after t'Pool, the Vulcan programmer who invented the technique.
//
#ifndef _TPOOL_H_
#define _TPOOL_H_

#include "debug.h"

#define POOL_DEFAULT_BYTE_PER_BLOCK     4096
#define MIN_ITEMS_PER_BLOCK             4

///////////////////////////////////////////////////////////////////////////////
//
// CPool
//
// A simple memory manager that efficiently handles many objects of the same 
// size by allocating blocks containing multiple objects at once.
//
// 
template<class contained> class CPool
{
public:
    CPool(int nApproxBytesPerBlock = POOL_DEFAULT_BYTE_PER_BLOCK);
    ~CPool();

    contained *Alloc();
    void Free(contained* pToFree);

private:
    union CPoolNode
    {
        CPoolNode       *pNext;
        contained       c;
    };

    class CPoolBlock
    {
    public:
        CPoolBlock      *pNext;
        CPoolNode       *pObjects;
    };

    int                 nItemsPerBlock;             // Based on bytes per block
    int                 nAllocatedBlocks;           // # allocated blocks
    CPoolBlock          *pAllocatedBlocks;          // list of allocated blocks
    int                 nFreeList;                  // # nodes in free list
    CPoolNode           *pFreeList;                 // free list

private:
    bool RefillFreeList();

#ifdef DBG
    bool IsPoolNode(CPoolNode *pNode);
    bool IsInFreeList(CPoolNode *pNode);
#endif

};

///////////////////////////////////////////////////////////////////////////////
//
// CPool::CPool
//
// Figure out the number of contained objects per block based on the requested
// approximate block size. Initialize the free list to contain one block's 
// worth of objects.
// 
//
template<class contained> CPool<contained>::CPool(int nApproxBytesPerBlock)
{
    // Figure out how many items per block and cheat if too small
    //
    nItemsPerBlock = nApproxBytesPerBlock / sizeof(CPoolNode);
    if (nItemsPerBlock < MIN_ITEMS_PER_BLOCK)
    {
        nItemsPerBlock = MIN_ITEMS_PER_BLOCK;
    }

    nAllocatedBlocks = 0;
    pAllocatedBlocks = NULL;
    nFreeList = 0;
    pFreeList = NULL;

    // Fill up with some items ahead of time
    //
    RefillFreeList();
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::~CPool
//
// Free up all allocated blocks. There should be no outstanding blocks 
// allocated at this point.
//
// 
template<class contained> CPool<contained>::~CPool()
{
#ifdef DBG
    if (nFreeList < nAllocatedBlocks * nItemsPerBlock)
    {
        Trace(0, "CPool::~Cpool: Warning: free'ing with outstanding objects allocated.\n");
    }
#endif
    
    // Clean up all allocated blocks and contained objects.
    //
    while (pAllocatedBlocks)
    {
        CPoolBlock *pNext = pAllocatedBlocks->pNext;

        delete[] pAllocatedBlocks->pObjects;
        delete pAllocatedBlocks;

        pAllocatedBlocks = pNext;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::Alloc
//
// Attempt to allocate a contained object and return NULL if out of memory.
// If the free list is empty then allocate another block.
//
// 
template<class contained> contained *CPool<contained>::Alloc()
{
    if (pFreeList == NULL)
    {
        if (!RefillFreeList())
        {
            return false;
        }
    }

    nFreeList--;
    contained *pAlloc = (contained*)pFreeList;
    pFreeList = pFreeList->pNext;

    return pAlloc;
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::Free
//
// Return a contained object to the free list. In the debug version make sure
// the object was in fact allocated from this pool in the first place and that
// it isn't already in the free list.
//
// 
template<class contained> void CPool<contained>::Free(contained *pToFree)
{
    CPoolNode *pNode = (CPoolNode*)pToFree;

#ifdef DBG
    if (!IsPoolNode(pNode))
    {
        Trace(0, "CPool::Free() Object %p is not a pool node; ignored.\n", pToFree);
        return;
    }
    
    if (IsInFreeList(pNode))
    {
        Trace(0, "CPool::Free() Object %p is already in the free list; ignored.\n", pToFree);
        return;
    }
#endif

    nFreeList++;
    pNode->pNext = pFreeList;
    pFreeList = pNode;
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::RefillFreeList
//
// Add one block's worth of contained objects to the free list, tracking the 
// allocated memory so we can free it later.
//
// 
template<class contained> bool CPool<contained>::RefillFreeList()
{
    // Allocate a new block and the actual block of objects
    //
    CPoolBlock *pNewBlock = new CPoolBlock;
    if (pNewBlock == NULL)
    {
        return false;
    }

    pNewBlock->pObjects = new CPoolNode[nItemsPerBlock];
    if (pNewBlock->pObjects == NULL)
    {
        delete pNewBlock;
        return false;
    }

    // Link the block and objects into the right places. First link the new block
    // into the list of allocated blocks.
    //
    pNewBlock->pNext = pAllocatedBlocks;
    pAllocatedBlocks = pNewBlock;

    // Link all the contained object nodes into the free list.
    //
    CPoolNode *pFirstNode = &pNewBlock->pObjects[0];
    CPoolNode *pLastNode  = &pNewBlock->pObjects[nItemsPerBlock - 1];

    for (CPoolNode *pNode = pFirstNode; pNode < pLastNode; pNode++)
    {
        pNode->pNext = pNode + 1;
    }

    pLastNode->pNext = pFreeList;
    pFreeList = pFirstNode;
    
    nFreeList += nItemsPerBlock;
    nAllocatedBlocks++;

    return true;
}

#ifdef DBG
///////////////////////////////////////////////////////////////////////////////
//
// CPool::IsPoolNode (debug)
//
// Verify that the passed pointer is a pointer to a pool node by walking the list
// of allocated blocks.
//
// 
template<class contained> bool CPool<contained>::IsPoolNode(CPoolNode *pTest)
{
    for (CPoolBlock *pBlock = pAllocatedBlocks; pBlock; pBlock = pBlock->pNext)
    {
        CPoolNode *pFirstNode = &pBlock->pObjects[0];
        CPoolNode *pLastNode  = &pBlock->pObjects[nItemsPerBlock - 1];

        for (CPoolNode *pNode = pFirstNode; pNode <= pLastNode; pNode++)
        {
            if (pNode == pTest)
            {
                return true;
            }
        }
    }

    return false;
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::IsInFreeList (debug)
//
// Verify that the passed pointer points to a node that is already in the free
// list.
//
// 
template<class contained> bool CPool<contained>::IsInFreeList(CPoolNode *pTest)
{
    for (CPoolNode *pNode = pFreeList; pNode; pNode = pNode->pNext)
    {
        if (pTest == pNode)
        {
            return true;
        }
    }
    
    return false;
}
#endif  // DBG
#endif  // _TPOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dswave\dmstrm.cpp ===
//
// dmstrm.cpp
// 
// Copyright (c) 1995-2001 Microsoft Corporation
//

#include "debug.h"
#include "dmusicc.h"
#include "..\shared\dmstrm.h"
#include "..\shared\validate.h"

/////////////////////////////////////////////////////////////////////////////
// AllocDIrectMusicStream

STDAPI AllocDirectMusicStream(IStream* pIStream, IDMStream** ppIDMStream)
{
    if(pIStream == NULL || ppIDMStream == NULL)
    {
        return E_INVALIDARG;            
    }

    if((*ppIDMStream = (IDMStream*) new CDirectMusicStream()) == NULL)
    {
        return E_OUTOFMEMORY;
    }
    
    ((CDirectMusicStream*)*ppIDMStream)->Init(pIStream);
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::CDirectMusicStream

CDirectMusicStream::CDirectMusicStream() :
m_cRef(1),
m_pStream(NULL)
{
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::~CDirectMusicStream
   
CDirectMusicStream::~CDirectMusicStream()
{
    if(m_pStream != NULL)
    {
        m_pStream->Release();
    }
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Init
   
STDMETHODIMP CDirectMusicStream::Init(IStream* pStream)
{
    SetStream(pStream);
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IUnknown

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::QueryInterface

STDMETHODIMP CDirectMusicStream::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(CDirectMusicStream::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    if(iid == IID_IUnknown || iid == IID_IDMStream)
    {
        *ppv = static_cast<IDMStream*>(this);
    } 
    else 
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::AddRef

STDMETHODIMP_(ULONG) CDirectMusicStream::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Release

STDMETHODIMP_(ULONG) CDirectMusicStream::Release()
{
    if(!InterlockedDecrement(&m_cRef)) 
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::SetStream

STDMETHODIMP CDirectMusicStream::SetStream(IStream* pStream)
{
    if(m_pStream != NULL)
    {
        m_pStream->Release();
    }

    m_pStream = pStream;
    
    if(m_pStream != NULL)
    {
        m_pStream->AddRef();
    }
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::GetStream

STDMETHODIMP_(IStream*) CDirectMusicStream::GetStream()
{
    if(m_pStream != NULL)
    {
        m_pStream->AddRef();
    }
    
    return m_pStream;
}

//////////////////////////////////////////////////////////////////////
// IDMStream

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Descend

STDMETHODIMP CDirectMusicStream::Descend(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags)
{
    assert(lpck);

    FOURCC ckidFind;           // Chunk ID to find (or NULL)
    FOURCC fccTypeFind;    // Form/list type to find (or NULL)

    // Figure out what chunk id and form/list type for which to search
    if(wFlags & MMIO_FINDCHUNK)
    {
        ckidFind = lpck->ckid;
        fccTypeFind = NULL;
    }
    else if(wFlags & MMIO_FINDRIFF)
    {
        ckidFind = FOURCC_RIFF;
        fccTypeFind = lpck->fccType;
    }
    else if(wFlags & MMIO_FINDLIST)
    {
        ckidFind = FOURCC_LIST;
        fccTypeFind = lpck->fccType;
    }
    else
    {
        ckidFind = fccTypeFind = NULL;
    }

    lpck->dwFlags = 0L;

    for(;;)
    {
        HRESULT hr;
        LARGE_INTEGER li;
        ULARGE_INTEGER uli;
        ULONG cbRead;

        // Read the chunk header
        hr = m_pStream->Read(lpck, 2 * sizeof(DWORD), &cbRead);

        if (FAILED(hr) || (cbRead != 2 * sizeof(DWORD)))
        {
            Trace(1,"Error: Unable to read file.\n");
            return DMUS_E_DESCEND_CHUNK_FAIL;
        }

        // Store the offset of the data part of the chunk
        li.QuadPart = 0;
        hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

        if(FAILED(hr))
        {
            Trace(1,"Error: Unable to read file.\n");
            return DMUS_E_CANNOTSEEK;
        }
        else
        {
            lpck->dwDataOffset = uli.LowPart;
        }

        // See if the chunk is within the parent chunk (if given)
        if((lpckParent != NULL) &&
           (lpck->dwDataOffset - 8L >=
           lpckParent->dwDataOffset + lpckParent->cksize))
        {
            Trace(1,"Error: Unable to read file.\n");
            return DMUS_E_DESCEND_CHUNK_FAIL;
        }

        // If the chunk is a 'RIFF' or 'LIST' chunk, read the
        // form type or list type
        if((lpck->ckid == FOURCC_RIFF) || (lpck->ckid == FOURCC_LIST))
        {
            hr = m_pStream->Read(&lpck->fccType, sizeof(DWORD), &cbRead);

            if(FAILED(hr) || (cbRead != sizeof(DWORD)))
            {
                Trace(1,"Error: Unable to read file.\n");
                return DMUS_E_DESCEND_CHUNK_FAIL;
            }
        }
        else
        {
            lpck->fccType = NULL;
        }

        // If this is the chunk we're looking for, stop looking
        if(((ckidFind == NULL) || (ckidFind == lpck->ckid)) &&
           ((fccTypeFind == NULL) || (fccTypeFind == lpck->fccType)))
        {
            break;
        }

        // Ascend out of the chunk and try again
        HRESULT w = Ascend(lpck, 0);
        if(FAILED(w))
        {
            return w;
        }
    }

    return S_OK;
}


//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Ascend

STDMETHODIMP CDirectMusicStream::Ascend(LPMMCKINFO lpck, UINT /*wFlags*/)
{
    assert(lpck);

    HRESULT hr;
    LARGE_INTEGER li;
    ULARGE_INTEGER uli;
    
    if (lpck->dwFlags & MMIO_DIRTY)
    {
        // <lpck> refers to a chunk created by CreateChunk();
        // check that the chunk size that was written when
        // CreateChunk() was called is the real chunk size;
        // if not, fix it
        LONG lOffset;           // current offset in file
        LONG lActualSize;   // actual size of chunk data

        li.QuadPart = 0;
        hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

        if(FAILED(hr))
        {
            Trace(1,"Error: Unable to write file.\n");
            return DMUS_E_CANNOTSEEK;
        }
        else
        {
            lOffset = uli.LowPart;
        }
        
        if((lActualSize = lOffset - lpck->dwDataOffset) < 0)
        {
            Trace(1,"Error: Unable to write file.\n");
            return DMUS_E_CANNOTWRITE;
        }

        if(LOWORD(lActualSize) & 1)
        {
            ULONG cbWritten;

            // Chunk size is odd -- write a null pad byte
            hr = m_pStream->Write("\0", 1, &cbWritten); 
            
            if(FAILED(hr) || cbWritten != 1)
            {
                Trace(1,"Error: Unable to write file.\n");
                return DMUS_E_CANNOTWRITE;
            }
        
        }
    
        if(lpck->cksize == (DWORD)lActualSize)
        {
            return S_OK;
        }

        // Fix the chunk header
        lpck->cksize = lActualSize;

        li.QuadPart = lpck->dwDataOffset - sizeof(DWORD);
        hr = m_pStream->Seek(li, STREAM_SEEK_SET, &uli);

        if(FAILED(hr))
        {
            Trace(1,"Error: Unable to write file.\n");
            return DMUS_E_CANNOTSEEK;
        }

        ULONG cbWritten;

        hr = m_pStream->Write(&lpck->cksize, sizeof(DWORD), &cbWritten); 
        
        if(FAILED(hr) || cbWritten != sizeof(DWORD))
        {
            Trace(1,"Error: Unable to write file.\n");
            return DMUS_E_CANNOTWRITE;
        }
    }

    // Seek to the end of the chunk, past the null pad byte
    // (which is only there if chunk size is odd)
    li.QuadPart = lpck->dwDataOffset + lpck->cksize + (lpck->cksize & 1L);
    hr = m_pStream->Seek(li, STREAM_SEEK_SET, &uli);

    if(FAILED(hr))
    {
        Trace(1,"Error: Unable to write file.\n");
        return DMUS_E_CANNOTSEEK;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::CreateChunk

STDMETHODIMP CDirectMusicStream::CreateChunk(LPMMCKINFO lpck, UINT wFlags)
{
    assert(lpck);

    UINT iBytes;    // Bytes to write
    LONG lOffset;   // Current offset in file

    // Store the offset of the data part of the chunk
    LARGE_INTEGER li;
    ULARGE_INTEGER uli;

    li.QuadPart = 0;
    HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

    if(FAILED(hr))
    {
        Trace(1,"Error: Unable to write file.\n");
        return DMUS_E_CANNOTSEEK;
    }
    else
    {
        lOffset = uli.LowPart;
    }
    
    lpck->dwDataOffset = lOffset + 2 * sizeof(DWORD);

    // figure out if a form/list type needs to be written
    if(wFlags & MMIO_CREATERIFF)
    {
        lpck->ckid = FOURCC_RIFF, iBytes = 3 * sizeof(DWORD);
    }
    else if(wFlags & MMIO_CREATELIST)
    {
        lpck->ckid = FOURCC_LIST, iBytes = 3 * sizeof(DWORD);
    }
    else
    {
        iBytes = 2 * sizeof(DWORD);
    }

    // Write the chunk header
    ULONG cbWritten;

    hr = m_pStream->Write(lpck, iBytes, &cbWritten); 
        
    if(FAILED(hr) || cbWritten != iBytes)
    {
        Trace(1,"Error: Unable to write file.\n");
        return DMUS_E_CANNOTWRITE;
    }

    lpck->dwFlags = MMIO_DIRTY;

    return S_OK;
}

CRiffParser::CRiffParser(IStream *pStream)

{
    assert(pStream);
    m_fDebugOn = FALSE;
    m_pStream = pStream; 
    m_pParent = NULL;
    m_pChunk = NULL;
    m_lRead = 0;
    m_fFirstPass = TRUE;
    m_fComponentFailed = FALSE;
    m_fInComponent = FALSE;
}

void CRiffParser::EnterList(RIFFIO *pChunk)

{
    assert (pChunk);
    pChunk->lRead = 0;
    pChunk->pParent = m_pChunk; // Previous chunk (could be NULL.)
    m_pParent = m_pChunk;
    m_pChunk = pChunk;
    m_fFirstPass = TRUE;
}

void CRiffParser::LeaveList()

{
    assert (m_pChunk);
    if (m_pChunk)
    {
        m_pChunk = m_pChunk->pParent;
        if (m_pChunk)
        {
            m_pParent = m_pChunk->pParent;
        }
    }
}

BOOL CRiffParser::NextChunk(HRESULT * pHr)

{
    BOOL fMore = FALSE;
    if (SUCCEEDED(*pHr))
    {
        // If this is the first time we've entered this list, there is no previous chunk.
        if (m_fFirstPass)
        {
            // Clear the flag.
            m_fFirstPass = FALSE;
        }
        else
        {
            // Clean up the previous pass.
            *pHr = LeaveChunk();
        }
        // Find out if there are more chunks to read.
        fMore = MoreChunks();
        // If so, and we don't have any failure, go ahead and read the next chunk header.
        if (fMore && SUCCEEDED(*pHr))
        {
            *pHr = EnterChunk();
        }
    }
    else
    {
#ifdef DBG
        char szName[5];
        if (m_fDebugOn)
        {
            szName[4] = 0;
            strncpy(szName,(char *)&m_pChunk->ckid,4);
            Trace(0,"Error parsing %s, Read %ld of %ld\n",szName,m_pChunk->lRead,RIFF_ALIGN(m_pChunk->cksize));
        }
#endif
        // If we were in a component, it's okay to fail. Mark that fact by setting
        // m_fComponentFailed then properly pull out of the chunk so we can
        // continue reading.
        if (m_fInComponent) 
        {
            m_fComponentFailed = TRUE;
            // We don't need to check for first pass, because we must have gotten
            // that far. Instead, we just clean up from the failed chunk.
            // Note that this sets the hresult to S_OK, which is what we want.
            // Later, the caller needs to call ComponentFailed() to find out if
            // this error occured.
            *pHr = LeaveChunk();
        }
        else
        {
            // Clean up but leave the error code.
            LeaveChunk();
        }
    }
    return fMore && SUCCEEDED(*pHr);
}

BOOL CRiffParser::MoreChunks()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        if (m_pParent)
        {
            // Return TRUE if there's enough room for another chunk.
            return (m_pParent->lRead < (m_pParent->cksize - 8));
        }
        else
        {
            // This must be a top level chunk, in which case there would only be one to read.
            return (m_pChunk->lRead == 0);
        }
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return false;
}

HRESULT CRiffParser::EnterChunk()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Read the chunk header
        HRESULT hr = m_pStream->Read(m_pChunk, 2 * sizeof(DWORD), NULL);
        if (SUCCEEDED(hr))
        {
#ifdef DBG
            char szName[5];
            if (m_fDebugOn)
            {
                szName[4] = 0;
                strncpy(szName,(char *)&m_pChunk->ckid,4);
                ULARGE_INTEGER ul;
                LARGE_INTEGER li;
                li.QuadPart = 0;
                m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);

                Trace(0,"Entering %s, Length %ld, File position is %ld",szName,m_pChunk->cksize,(long)ul.QuadPart);
            }
#endif
            // Clear bytes read field.
            m_pChunk->lRead = 0;
            // Check to see if this is a container (LIST or RIFF.)
            if((m_pChunk->ckid == FOURCC_RIFF) || (m_pChunk->ckid == FOURCC_LIST))
            {
                hr = m_pStream->Read(&m_pChunk->fccType, sizeof(DWORD), NULL);
                if (SUCCEEDED(hr))
                {
                    m_pChunk->lRead += sizeof(DWORD);
#ifdef DBG
                    if (m_fDebugOn)
                    {
                        strncpy(szName,(char *)&m_pChunk->fccType,4);
                        Trace(0," Type %s",szName);
                    }
#endif
                }
                else
                {
                    Trace(1,"Error: Unable to read file.\n");
                }
            }
#ifdef DBG
            if (m_fDebugOn) Trace(0,"\n");
#endif
        }
        else
        {
            Trace(1,"Error: Unable to read file.\n");
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::LeaveChunk()

{
    HRESULT hr = S_OK;
    assert(m_pChunk);
    if (m_pChunk)
    {
        m_fInComponent = false;
        // Get the rounded up size of the chunk.
        long lSize = RIFF_ALIGN(m_pChunk->cksize);
        // Increment the parent's count of bytes read so far.
        if (m_pParent)
        {
            m_pParent->lRead += lSize + (2 * sizeof(DWORD));
            if (m_pParent->lRead > RIFF_ALIGN(m_pParent->cksize))
            {
                Trace(1,"Error: Unable to read file.\n");
                hr = DMUS_E_DESCEND_CHUNK_FAIL; // Goofy error name, but need to be consistent with previous versions.
            }
        }
#ifdef DBG
        char szName[5];
        if (m_fDebugOn)
        {
            szName[4] = 0;
            strncpy(szName,(char *)&m_pChunk->ckid,4);
            ULARGE_INTEGER ul;
            LARGE_INTEGER li;
            li.QuadPart = 0;
            m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);

            Trace(0,"Leaving %s, Read %ld of %ld, File Position is %ld\n",szName,m_pChunk->lRead,lSize,(long)ul.QuadPart);
        }
#endif
        // If we haven't actually read this entire chunk, seek to the end of it.
        if (m_pChunk->lRead < lSize)
        {
            LARGE_INTEGER li;
            li.QuadPart = lSize - m_pChunk->lRead;
            hr = m_pStream->Seek(li,STREAM_SEEK_CUR,NULL);
            // There's a chance it could fail because we are at the end of file with an odd length chunk.
            if (FAILED(hr))
            {
                // If there's a parent, see if this is the last chunk.
                if (m_pParent)
                {
                    if (m_pParent->cksize >= (m_pParent->lRead - 1))
                    {
                        hr = S_OK;
                    }
                }
                // Else, see if we are an odd length.
                else if (m_pChunk->cksize & 1)
                {
                    hr = S_OK;
                }
            }
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::Read(void *pv,ULONG cb)

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Make sure we don't read beyond the end of the chunk.
        if (((long)cb + m_pChunk->lRead) > m_pChunk->cksize)
        {
            cb -= (cb - (m_pChunk->cksize - m_pChunk->lRead));
        }
        HRESULT hr = m_pStream->Read(pv,cb,NULL);
        if (SUCCEEDED(hr))
        {
            m_pChunk->lRead += cb;
        }
        else
        {
            Trace(1,"Error: Unable to read %ld bytes from file.\n",cb);
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::Skip(ULONG ulBytes)

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Make sure we don't scan beyond the end of the chunk.
        if (((long)ulBytes + m_pChunk->lRead) > m_pChunk->cksize)
        {
            ulBytes -= (ulBytes - (m_pChunk->cksize - m_pChunk->lRead));
        }
        LARGE_INTEGER li;
        li.HighPart = 0;
        li.LowPart = ulBytes;
        HRESULT hr = m_pStream->Seek( li, STREAM_SEEK_CUR, NULL );
        if (SUCCEEDED(hr))
        {
            m_pChunk->lRead += ulBytes;
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}


void CRiffParser::MarkPosition()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        LARGE_INTEGER li;
        ULARGE_INTEGER ul;
        li.HighPart = 0;
        li.LowPart = 0;
        m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
        m_pChunk->liPosition.QuadPart = (LONGLONG) ul.QuadPart;
    }
}

HRESULT CRiffParser::SeekBack()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Move back to the start of the current chunk. Also, store the
        // absolute position because that will be useful later when we need to seek to the
        // end of this chunk.
        ULARGE_INTEGER ul;
        LARGE_INTEGER li;
        li.QuadPart = 0;
        li.QuadPart -= (m_pChunk->lRead + (2 * sizeof(DWORD))); 
        HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
        // Now, save the absolute position for the end of this chunk.
        m_pChunk->liPosition.QuadPart = ul.QuadPart + 
            RIFF_ALIGN(m_pChunk->cksize) + (2 * sizeof(DWORD));
        m_pChunk->lRead = 0;
        return hr;
    }
    return E_FAIL;
}

HRESULT CRiffParser::SeekForward()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        m_pChunk->lRead = RIFF_ALIGN(m_pChunk->cksize);
        return m_pStream->Seek(m_pChunk->liPosition, STREAM_SEEK_SET, NULL);
    }
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dswave\dswave.h ===
// dswave.h
// (c) 1999-2000 Microsoft Corp.

#ifndef _DSWAVE_H_
#define _DSWAVE_H_

#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include "dsoundp.h"    // For IDirectSoundWave and IDirectSoundSource
#include "dmusicc.h"
#include "dmusici.h"
#include "riff.h"

extern long g_cComponent;

#define REF_PER_MIL     10000   // For converting from reference time to mils 
#define CONVERTLENGTH   250

// #define DSWCS_F_DEINTERLEAVED 0x00000001    // Multi-channel data as multiple buffers
// FIXME: unimplemented so far?

typedef struct tCREATEVIEWPORT
{
    IStream            *pStream;
    DWORD               cSamples;
    DWORD               dwDecompressedStart;
    DWORD               cbStream;
    LPWAVEFORMATEX      pwfxSource;
    LPWAVEFORMATEX      pwfxTarget;
    DWORD               fdwOptions;
} CREATEVIEWPORT, *PCREATEVIEWPORT;


// Private interface for getting the length of a wave
interface IPrivateWave : IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE GetLength(REFERENCE_TIME *prtLength)=0;
};

DEFINE_GUID(IID_IPrivateWave, 0xce6ae366, 0x9d61, 0x420a, 0xad, 0x53, 0xe5, 0xe5, 0xf6, 0xa8, 0x4a, 0xe4);

// Flags for SetWaveBehavior()

#define DSOUND_WAVEF_ONESHOT        1           /* The wave will be played as a one shot */
#define DSOUND_WAVEF_PORT           2           /* The wave will be played via a DMusic port. */
#define DSOUND_WAVEF_SINK           4           /* The wave will be played via a streamed sink interface. */
#define DSOUND_WAVEF_CREATEMASK     0x00000001  /*  Currently only ONESHOT is define for CreateSource  */

#define DSOUND_WVP_NOCONVERT        0x80000000  /*  The viewport data is the same format as the wave  */
#define DSOUND_WVP_STREAMEND        0x40000000  /*  The viewport data is the same format as the wave  */
#define DSOUND_WVP_CONVERTSTATE_01  0x01000000
#define DSOUND_WVP_CONVERTSTATE_02  0x02000000
#define DSOUND_WVP_CONVERTSTATE_03  0x04000000

#define DSOUND_WVP_CONVERTMASK      0x0f000000

/*  The CWaveViewPort structure represents one instance, or "view", of the
    wave object. It manages the reading of the wave data, ACM decompression,
    and demultiplexing into mono buffers. If a wave object is being
    streamed, each playback instance gets a unique CWaveViewPort. 
    However, in the more typical case where the wave object is being
    played as a one shot, each playback instance uses the same
    CWaveViewPort.
    Each additional CWaveViewPort owns a cloned instance of the IStream.
*/

class CWaveViewPort :
    public IDirectSoundSource   // Used by a port or sink to pull data. 
{
public:
    CWaveViewPort();            // Constructor receives stream.
    ~CWaveViewPort();           //  Destructor releases memory, streams, etc.

    // IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectSoundSource
    STDMETHODIMP SetSink(IDirectSoundConnect *pSinkConnect);
    STDMETHODIMP GetFormat(LPWAVEFORMATEX pwfx, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten);
    STDMETHODIMP Seek(ULONGLONG sp);
    STDMETHODIMP Read(LPVOID *ppvBuffer, LPDWORD pdwBusIds, LPDWORD pdwFuncIds, LPLONG plPitchShifts, DWORD cpvBuffer, ULONGLONG *pcb);
    STDMETHODIMP GetSize(ULONGLONG *pcb);

    // Misc
    HRESULT Create(PCREATEVIEWPORT pCreate);

private:

    HRESULT acmRead();

    //  General stuff...
    CRITICAL_SECTION    m_CriticalSection;  //  Used to ensure thread safe
    long                m_cRef;             //  COM reference counter.

    //  Details about original data stream...
    IStream *           m_pStream;          //  IStream pointer which is connected to IPersistStream
                                            //  interface to pull data from file. 
    DWORD               m_cSamples;         //  Number of samples (if available)
    DWORD               m_cbStream;         //  Number of bytes in stream.
    DWORD               m_dwStart;          //  Offset into stream where data starts
    //LPWAVEFORMATEX      m_pwfxSource;       //  Do we need to hold on to this?

    //  Details needed for this viewport.
    DWORD               m_dwOffset;   //  Current byte offset into data stream
    DWORD               m_dwStartPos; //  Initial Start Offset
    LPWAVEFORMATEX      m_pwfxTarget; //  Target destination format.
    ACMSTREAMHEADER     m_ash;        //  ACM Stream header (used for conversion)
    HACMSTREAM          m_hStream;    //  ACM Stream handle for conversion
    LPBYTE              m_pDst;       //  Pointer to (decompressed) destination  
    LPBYTE              m_pRaw;       //  Pointer to compressed source buffer
    DWORD               m_fdwOptions; //  Options for viewport

    DWORD               m_dwDecompressedStart;  // Actual start for the data after decompression in Samples
                                                // This is important for MP3 and WMA codecs that 
                                                // insert some amount of silence in the beginning
    
    DWORD               m_dwDecompStartOffset;  // Byte Offset in the compressed stream to the block which
                                                // needs to be decompressed to get to the right start value
    
    DWORD               m_dwDecompStartOffsetPCM;// Byte offset in the decompressed stream...corresponds to
                                                // m_dwDecompressedStart samples

    DWORD               m_dwDecompStartDelta;   // The delta (in bytes) to add when we decompress the block starting
                                                // from m_dwDecompStartOffset

    // Only used to accurately get data after precached data for DirectSoundWave in DMusic
    DWORD               m_dwPreCacheFilePos;
    DWORD               m_dwFirstPCMSample;
    DWORD               m_dwPCMSampleOut;
};

/*  The CWave class represents one instance of a wave object. It
    supports the IDirectSoundWave interface, which the application
    uses to access the wave. It also support IPersistStream and
    IDirectMusicObject, which are used by the loader to load the 
    wave data from a stream into the wave object.
    And, the IDirectSoundSource interface manages the direct 
    transfer of the wave data from the object to the
    synth or DirectSound. This is for internal use, not by the
    application (though it represents an easy way for an app 
    to load wave data and then extract it.) 
    CWave maintains a list of CWaveViewPorts, though typically
    there is only one.
*/

class CWave : 
    public IDirectSoundWave,    // Standard interface.
    public IPersistStream,      // For file io
    public IDirectMusicObject,  // For DirectMusic loader
    public IPrivateWave         // For GetLength
{
public:
    CWave();
    ~CWave();

    // IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectSoundWave
    STDMETHODIMP GetFormat(LPWAVEFORMATEX pWaveFormatEx, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten);
    STDMETHODIMP CreateSource(IDirectSoundSource **ppSource, LPWAVEFORMATEX pwfx, DWORD dwFlags);
    STDMETHODIMP GetStreamingParms(LPDWORD pdwFlags, LPREFERENCE_TIME prtReadahread);

    // IPersist functions (base class for IPersistStream)
    STDMETHODIMP GetClassID( CLSID* pClsId );

    // IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );

    // IDirectMusicObject 
    STDMETHODIMP GetDescriptor(LPDMUS_OBJECTDESC pDesc);
    STDMETHODIMP SetDescriptor(LPDMUS_OBJECTDESC pDesc);
    STDMETHODIMP ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

    // IPrivateWave
    STDMETHODIMP GetLength(REFERENCE_TIME *prtLength);

private:
    
    // Internal methods.

    BOOL ParseHeader(IStream *pIStream, IRIFFStream* pIRiffStream, LPMMCKINFO pckMain);

    void FallbackStreamingBehavior()
    {
        REFERENCE_TIME rtLength = 0;
        if (SUCCEEDED(GetLength(&rtLength)))
        {
            // if > 5000 milliseconds, set to streaming with a 500 ms readahead
            if (rtLength > 5000)
            {
                m_rtReadAheadTime = 500 * REF_PER_MIL;
                m_fdwFlags &= ~DSOUND_WAVEF_ONESHOT;
            }
            else
            {
                m_rtReadAheadTime = 0;
                m_fdwFlags |= DSOUND_WAVEF_ONESHOT;
            }
        }
    }

    CRITICAL_SECTION    m_CriticalSection;      //  Used to ensure thread safe
    LPWAVEFORMATEX      m_pwfxDst;              //  Destination format, if compressed 
    REFERENCE_TIME      m_rtReadAheadTime;      //  Readahead for streaming.
    DWORD               m_fdwFlags;             //  Various flags, including whether this is a one-shot.
    long                m_cRef;                 //  COM reference counter.
    IStream *           m_pStream;              //  IStream pointer which is connected to IPersistStream
    DWORD               m_fdwOptions;           //  Flags set by call to SetWaveBehavior().
    LPWAVEFORMATEX      m_pwfx;                 //  File's format
    DWORD               m_cbStream;
    DWORD               m_cSamples;
    GUID                m_guid;
    FILETIME            m_ftDate;
    DMUS_VERSION        m_vVersion;
    WCHAR               m_wszFilename[DMUS_MAX_FILENAME];
    DWORD               m_dwDecompressedStart;
};

class CDirectSoundWaveFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectSoundWaveFactory();

    // Destructor
    ~CDirectSoundWaveFactory(); 

private:
    long m_cRef;
};

#endif // _DSWAVE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dswave\ima.h ===
// IMA.h : Declaration of private interface for IMA legacy mode.
//
//

#ifndef __IMA_H_
#define __IMA_H_

#include <windows.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#ifdef __cplusplus
extern "C" {
#endif


#undef  INTERFACE
#define INTERFACE  IDirectMusicIMA
DECLARE_INTERFACE_(IDirectMusicIMA, IUnknown)
{
	/* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

	/* IDirectMusicIMA */
	STDMETHOD(LegacyCaching)		(THIS_ BOOL fEnable) PURE;
};

DEFINE_GUID(IID_IDirectMusicIMA,0xd2ac28b3, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

#ifdef __cplusplus
}; /* extern "C" */
#endif

#endif /* #ifndef __IMA_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dswave\guids.cpp ===
#include <objbase.h>
#include "initguid.h"
#include <mmsystem.h>
#include <dsoundp.h>
#include "dmusicc.h"
#include "dmusici.h"
#include "riff.h"
#include "dswave.h"
#include "dmstrm.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dswave\debug.cpp ===
//
// Debug.CPP
//
// Copyright (C) 1997-1998 Microsoft Corporation.  All Rights Reserved
//
// @doc INTERNAL
//
// @module Debug | Debug services for DMusic.DLL
//

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>

#include "debug.h"

#ifdef DBG

#define MODULE "DSWAVE"

// @globalv Section in WIN.INI for all debug settings
const char szDebugSection[] = "debug";

// @globalv Key in WIN.INI for our debug level. All messages with
// a level of this number or lower will be displayed.
const char szDebugKey[] = MODULE;

// @globalv Key in WIN.INI [debug] section which determines if assert calls
// DebugBreak or not
//
const char szAssertBreak[] = "AssertBreak";

// @globalv Prefix for all debug outputs
//
const char szDebugPrefix[] = MODULE ": ";

// @globalv The current debug level. 
static int giDebugLevel;

// @globalv Do asserts break?
static BOOL gfAssertBreak;

// @func Sets the debug level from WIN.INI
// 
void DebugInit(
    void)
{
    giDebugLevel = GetProfileInt(szDebugSection, szDebugKey, 0);
    gfAssertBreak = GetProfileInt(szDebugSection, szAssertBreak, 0);


    // Nepotism at its finest
    DebugTrace(-1, "Debug level is %d\n", giDebugLevel);
}

// @func Send a debug trace out.
//
// @comm Any message with a level less than or equal to the current debug
// level will be displayed using the OutputDebugString API. This means either
// the IDE Debug window if the app is running in that context or WDEB if
// it's running.
//
static BOOL fNeedPrefix = TRUE;
void DebugTrace(
    int iDebugLevel,        // @parm The debug level of this message
    LPSTR pstrFormat,       // @parm A printf style format string
    ...)                    // @parm | ... | Variable paramters based on <p pstrFormat>
{
    char sz[512];
    

    if (iDebugLevel != -1 && iDebugLevel > giDebugLevel)
    {
        return;
    }

    va_list va;

    va_start(va, pstrFormat);
    vsprintf(sz, pstrFormat, va);
    va_end(va);

    if (fNeedPrefix)
    {
        OutputDebugString(szDebugPrefix);
    }
    
    OutputDebugString(sz);

    // Let them construct multiple piece trace outs w/o
    // prefixing each one
    //
    fNeedPrefix = FALSE;
    for (;*pstrFormat && !fNeedPrefix; ++pstrFormat)
    {
        if (*pstrFormat == '\n')
        {
            fNeedPrefix = TRUE;
        }
    }
}

void DebugAssert(
    LPSTR szExp, 
    LPSTR szFile, 
    ULONG ulLine)
{
    DebugTrace(0, "ASSERT: \"%s\" %s@%lu\n", szExp, szFile, ulLine);
    if (gfAssertBreak)
    {
        DebugBreak();
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dswave\dll.cpp ===
// dll.cpp
//
// Dll entry points and IDirectSoundWaveFactory implementation
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)
#include <objbase.h>
#include <mmsystem.h>
#include <dsoundp.h>
#include "debug.h"

#include "oledll.h"
#include "debug.h" 
#include "dmusicc.h"
#include "dmusici.h"
#include "riff.h"
#include "dswave.h"

#include <regstr.h>


// Globals
//

// Version information for our class
//
char g_szFriendlyName[]    = "Microsoft DirectSound Wave";
char g_szVerIndProgID[]    = "Microsoft.DirectSoundWave";
char g_szProgID[]          = "Microsoft.DirectSoundWave.1";

// Dll's hModule
//
HMODULE g_hModule = NULL; 

// Track whether running on Unicode machine.

BOOL g_fIsUnicode = FALSE;

// Count of active components and class factory server locks
//
long g_cComponent = 0;
long g_cLock = 0;


static char const g_szDoEmulation[] = "DoEmulation";

// CDirectSoundWaveFactory::QueryInterface
//
HRESULT __stdcall
CDirectSoundWaveFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

CDirectSoundWaveFactory::CDirectSoundWaveFactory()

{
	m_cRef = 1;
	InterlockedIncrement(&g_cLock);
}

CDirectSoundWaveFactory::~CDirectSoundWaveFactory()

{
	InterlockedDecrement(&g_cLock);
}

// CDirectSoundWaveFactory::AddRef
//
ULONG __stdcall
CDirectSoundWaveFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// CDirectSoundWaveFactory::Release
//
ULONG __stdcall
CDirectSoundWaveFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

// CDirectSoundWaveFactory::CreateInstance
//
//
HRESULT __stdcall
CDirectSoundWaveFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CWave *pWave;
    
    try
    {
        pWave = new CWave;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if (pWave == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pWave->QueryInterface(iid, ppv);
    pWave->Release();
    
    return hr;
}

// CDirectSoundWaveFactory::LockServer
//
HRESULT __stdcall
CDirectSoundWaveFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

// Standard calls needed to be an inproc server
//
STDAPI  DllCanUnloadNow()
{
    if (g_cComponent || g_cLock) {
        return S_FALSE;
    }

    return S_OK;
}

STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
        IUnknown* pIUnknown = NULL;

        if(clsid == CLSID_DirectSoundWave)
        {
            pIUnknown = static_cast<IUnknown*> (new CDirectSoundWaveFactory);
            if(!pIUnknown) 
            {
                    return E_OUTOFMEMORY;
            }
        }
        else
        {
			return CLASS_E_CLASSNOTAVAILABLE;
		}

        HRESULT hr = pIUnknown->QueryInterface(iid, ppv);
        pIUnknown->Release();

    return hr;
}

STDAPI DllUnregisterServer()
{
    UnregisterServer(CLSID_DirectSoundWave,
                     g_szFriendlyName,
                     g_szVerIndProgID,
                     g_szProgID);
    return S_OK;
}

STDAPI DllRegisterServer()
{
    RegisterServer(g_hModule,
                   CLSID_DirectSoundWave,
                   g_szFriendlyName,
                   g_szVerIndProgID,
                   g_szProgID);
    return S_OK; 
}

extern void DebugInit();

// Standard Win32 DllMain
//

#ifdef DBG
static char* aszReasons[] =
{
    "DLL_PROCESS_DETACH",
    "DLL_PROCESS_ATTACH",
    "DLL_THREAD_ATTACH",
    "DLL_THREAD_DETACH"
};
const DWORD nReasons = (sizeof(aszReasons) / sizeof(char*));
#endif

BOOL APIENTRY DllMain(HINSTANCE hModule,
                      DWORD dwReason,
                      void *lpReserved)
{
    OSVERSIONINFO osvi;
    static int nReferenceCount = 0;

#ifdef DBG
    if (dwReason < nReasons)
    {
        DebugTrace(0, "DllMain: %s\n", (LPSTR)aszReasons[dwReason]);
    }
    else
    {
        DebugTrace(0, "DllMain: Unknown dwReason <%u>\n", dwReason);
    }
#endif
    if (dwReason == DLL_PROCESS_ATTACH) {
        if (++nReferenceCount == 1)
        { 
            DisableThreadLibraryCalls(hModule);
            g_hModule = hModule;
            osvi.dwOSVersionInfoSize = sizeof(osvi);
            GetVersionEx(&osvi);
            g_fIsUnicode = 
				(osvi.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS);
#ifdef DBG
			DebugInit();
#endif
		}
    }
#ifdef DBG
    else if (dwReason == DLL_PROCESS_DETACH) {
        if (--nReferenceCount == 0)
        {
            TraceI(-1, "Unloading DSWave : g_cLock = %d, g_cComponent = %d", g_cLock, g_cComponent);

            // Assert if we still have some objects hanging around
            assert(g_cComponent == 0);
            assert(g_cLock == 0);
        }
    }
#endif

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dswave\oledll.cpp ===
// oledll.cpp
//
// Handle standard stuff for OLE server DLL
//
#include <objbase.h>
#include "debug.h"
#include <iostream.h>

#include "oledll.h"

static const char g_szCLSID[]           = "CLSID";
static const char g_szCLSIDSlash[]      = "CLSID\\";
static const char g_szInProc32[]        = "InProcServer32";
static const char g_szProgIDKey[]       = "ProgID";
static const char g_szVerIndProgIDKey[] = "VersionIndependentProgID";
static const char g_szCurVer[]          = "CurVer"; 
static const char g_szThreadingModel[]	= "ThreadingModel";
static const char g_szBoth[]		= "Both";

static const int CLSID_STRING_SIZE = 39;

static LONG RegSetDefValue(LPCSTR pstrKey, LPCSTR pstrSubkey, LPCSTR pstrValueName, LPCSTR pstrValue);
static void RegRemoveSubtree(HKEY hk, LPCSTR pstrChild);

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const char *szFriendlyName,
               const char *szVerIndProgID,
               const char *szProgID)
{
    char szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    LONG lr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    char szClsKey[256];
    strcpy(szClsKey, g_szCLSIDSlash);
    strcat(szClsKey, szCLSID);

    char szModule[512];
    lr = ::GetModuleFileName(hModule, szModule, sizeof(szModule));
    assert(lr);

    lr = 0;

    lr |= RegSetDefValue(szClsKey, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szClsKey, g_szInProc32, NULL, szModule);
	lr |= RegSetDefValue(szClsKey, g_szInProc32, g_szThreadingModel, g_szBoth);
    lr |= RegSetDefValue(szClsKey, g_szProgIDKey, NULL, szProgID);
    lr |= RegSetDefValue(szClsKey, g_szVerIndProgIDKey, NULL, szVerIndProgID);

    lr |= RegSetDefValue(szVerIndProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szVerIndProgID, g_szCLSID, NULL, szCLSID);
    lr |= RegSetDefValue(szVerIndProgID, g_szCurVer, NULL, szProgID);
    
	lr |= RegSetDefValue(szProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szProgID, g_szCLSID, NULL, szCLSID);

#if 0 
    if (lr) {
        UnregisterServer(clsid,
                         szFriendlyName,
                         szVerIndProgID,
                         szProgID);
        // ???
        //
        return S_OK;
    }
#endif

    return S_OK;
}

STDAPI
UnregisterServer(const CLSID &clsid,
                 const char *szFriendlyName,
                 const char *szVerIndProgID,
                 const char *szProgID)
{
    char szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    char szClsKey[256];
    strcpy(szClsKey, g_szCLSIDSlash);
    strcat(szClsKey, szCLSID);

    RegRemoveSubtree(HKEY_CLASSES_ROOT, szClsKey);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szVerIndProgID);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szProgID);

    return S_OK;
}

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const char *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue)
{
    char szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    HKEY hk;
	DWORD dw;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    char szClsKey[256];
    strcpy(szClsKey, g_szCLSIDSlash);
    strcat(szClsKey, szCLSID);
	strcat(szClsKey, "\\");
    if (szKey)
    {
	    strcat(szClsKey, szKey);
    }

	if (RegOpenKeyEx(HKEY_CLASSES_ROOT,
					 szClsKey,
					 0,
					 KEY_READ,
					 &hk)) {
		return FALSE;
	}

	if (RegQueryValueEx(hk,
						NULL,
						NULL,
						&dw,
						(LPBYTE)pValue,
						pcbValue)) {
		RegCloseKey(hk);
		return FALSE;
	}

	RegCloseKey(hk);
	
	return TRUE;
}

HRESULT
CLSIDToStr(const CLSID &clsid,
           char *szStr,
           int cbStr)
{
    // XXX What to return here?
    //
    assert(cbStr >= CLSID_STRING_SIZE);
    
	LPOLESTR wszCLSID = NULL;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
    if (!SUCCEEDED(hr)) {
        return hr;
    }

	// Covert from wide characters to non-wide.
	wcstombs(szStr, wszCLSID, cbStr);

	// Free memory.
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

HRESULT
StrToCLSID(char *szStr,
		   CLSID &clsid,
		   int cbStr)
{
	WCHAR wsz[512];

    if (cbStr > 512)
    {
        cbStr = 512;
    }

	mbstowcs(wsz, szStr, cbStr);

	return CLSIDFromString(wsz, &clsid);
}
   

static LONG
RegSetDefValue(LPCSTR pstrKey,
               LPCSTR pstrSubkey,
			   LPCSTR pstrValueName,
               LPCSTR pstrValue)
{
    HKEY hk;
    LONG lr;
    char sz[1024];
    LPCSTR pstr;

    if (!pstrSubkey) {
        pstr = pstrKey;
    } else {
        strcpy(sz, pstrKey);
        strcat(sz, "\\");
        strcat(sz, pstrSubkey);
        pstr = sz;
    }

    lr = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                        pstr,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hk,
                        NULL);
    if (lr) {
        return lr;
    }

    lr = RegSetValueEx(hk,
                       pstrValueName,
                       0,
                       REG_SZ,
                       (CONST BYTE*)pstrValue,
                       1+strlen(pstrValue));
    RegCloseKey(hk);

    return lr;
}

static void
RegRemoveSubtree(HKEY hk,
                 LPCSTR pstrChild)
{
    LONG lResult;
    HKEY hkChild;

    lResult = RegOpenKeyEx(hk,
                           pstrChild,
                           0,
                           KEY_ALL_ACCESS,
                           &hkChild);
    if (lResult) {
        return;
    }

    char szSubkey[256];

    // NOTE: Unlike regular enumeration, we always grab the 0th item
    // and delete it.
    //
    while (!RegEnumKey(hkChild, 0, szSubkey, sizeof(szSubkey))) {
        RegRemoveSubtree(hkChild, szSubkey);
    }

    RegCloseKey(hkChild);
    RegDeleteKey(hk, pstrChild);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dswave\oledll.h ===
//
//
//
#ifndef _OLEDLL_
#define _OLEDLL_

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const char *szFriendlyName,
               const char *szVerIndProgID,
               const char *szProgID);

STDAPI
UnregisterServer(const CLSID &clsid,
                 const char *szFriendlyName,
                 const char *szVerIndProgID,
                 const char *szProgID);

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const char *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue);
				 
HRESULT CLSIDToStr(const CLSID &clsid,
				   char *szStr,
				   int cbStr);

HRESULT StrToCLSID(char *szStr,
				   CLSID &clsid,
				   int cbStr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\shared\alist.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
// alist.cpp
//
#include "alist.h"

LONG AListItem::GetCount(void) const
{
    LONG l;
    const AListItem *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

AListItem* AListItem::Cat(AListItem *pItem)
{
    AListItem *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

AListItem* AListItem::Remove(AListItem *pItem)
{
    AListItem *li,*prev;

    //treat remove(NULL) same as item not found in list
   if (pItem==NULL) 
   return this;

    if(pItem==this)
    {
        li = m_pNext;
        m_pNext = NULL;
        return li;
    }
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);

    // SetNext on pItem to NULL
    pItem->SetNext(NULL);

    return this;
}

AListItem* AListItem::GetPrev(AListItem *pItem) const
{
    const AListItem *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (AListItem*)prev;
}

AListItem * AListItem::GetItem(LONG index)

{
	AListItem *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) 
	{
		index--;
	}
	return (scan);
}

void AList::InsertBefore(AListItem *pItem,AListItem *pInsert)

{
	AListItem *prev = GetPrev(pItem);
	pInsert->SetNext(pItem);
	if (prev) prev->SetNext(pInsert);
	else m_pHead = pInsert;
}

void AList::AddTail(AListItem *pItem)
{
    if (m_pHead == NULL)
    {
        AddHead(pItem);
    }
    else
    {
        m_pHead = m_pHead->AddTail(pItem);
    }
}

void AList::Reverse()

{
    AList Temp;
    AListItem *pItem;
    while (pItem = RemoveHead())
    {
        Temp.AddHead(pItem);
    }
    m_pHead = Temp.GetHead();
}

BOOL AList::IsMember(AListItem *pItem)

{
    AListItem *pScan = GetHead();
    for (;pScan;pScan = pScan->GetNext())
    {
        if (pItem == pScan) return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dswave\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Jim Geist (JimGe) 29-Aug-97

NOTE:   Commented description of this file is in \nt\oak\bin\sources.tpl

!ENDIF

!include ..\..\dmusic.inc

MAJORCOMP=windows
MINORCOMP=directx

TARGETNAME=dswave

!IF !$(FREEBUILD) && defined( DIRECTX_REDIST )
TARGETNAME=$(TARGETNAME)d
!ENDIF

TARGETPATH=obj
TARGETTYPE=DYNLINK
UMTYPE=windows
DLLDEF=..\dswave.def
DLLENTRY=_DllMainCRTStartup
USE_MAPSYM=1
USE_CRTDLL=1

!if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"

!if "$(BuildMode)" == "internal"
C_DEFINES = $(C_DEFINES) -DDEBUG=1
!else
C_DEFINES = $(C_DEFINES) -DRDEBUG=1
!endif

!endif

C_DEFINES= $(C_DEFINES) -D_WIN32

TARGETLIBS=$(BASEDIR)\public\sdk\lib\*\kernel32.lib             \
           $(BASEDIR)\public\sdk\lib\*\advapi32.lib             \
           $(BASEDIR)\public\sdk\lib\*\uuid.lib                 \
           $(BASEDIR)\public\sdk\lib\*\msacm32.lib              \
           $(BASEDIR)\public\sdk\lib\*\ole32.lib        


INCLUDES=$(INCLUDES);   \
    ..\..\shared



SOURCES=..\debug.cpp   \
..\dll.cpp             \
..\guids.cpp           \
..\oledll.cpp          \
..\wave.cpp            \
..\stream.cpp          \
..\viewport.cpp        \
..\waveutil.cpp        \
..\dmstrm.cpp          \
..\dswave.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dswave\waveutil.h ===
#ifndef	WAVEUTIL_H
#define WAVEUTIL_H

#define SIZEOFFORMAT(pwfx)		((WAVE_FORMAT_PCM == pwfx->wFormatTag)? \
								(sizeof(PCMWAVEFORMAT)): \
								(sizeof(WAVEFORMATEX)+pwfx->cbSize))

#define SIZEOFFORMATEX(pwfx)	(sizeof(WAVEFORMATEX) + \
								((WAVE_FORMAT_PCM == pwfx->wFormatTag)?0:pwfx->cbSize))

#define BLOCKALIGN(cb, b)		((DWORD)((DWORD)((DWORD)((cb) + (b) - 1) / (b)) * (b)))

#define V_PWFX_READ(p)			{ \
	V_PTR_READ(p, PCMWAVEFORMAT); \
	if (WAVE_FORMAT_PCM != p->wFormatTag) { V_PTR_READ(p, WAVEFORMATEX); \
		V_BUFPTR_READ(p, (sizeof(WAVEFORMATEX) + p->cbSize)); } \
}

void CopyFormat
(
	LPWAVEFORMATEX 	pwfxDst,
	LPWAVEFORMATEX 	pwfxSrc
);

void CopyFormatEx
(
	LPWAVEFORMATEX 	pwfxDst,
	LPWAVEFORMATEX 	pwfxSrc
);

BOOL FormatCmp
(
	LPWAVEFORMATEX 	pwfx1,
	LPWAVEFORMATEX 	pwfx2
);

DWORD DeinterleaveBuffers
(
	LPWAVEFORMATEX 	pwfx,
	LPBYTE 			pSrc,
	LPBYTE 			*ppbDst,
	DWORD 			cBuffers,
	DWORD 			cbSrcLength,
	DWORD 			dwBytesWritten
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\shared\debug.h ===
//
// debug.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note:
//

#ifndef DEBUG_H
#define DEBUG_H

#include <windows.h>

#define DM_DEBUG_CRITICAL		1	// Used to include critical messages
#define DM_DEBUG_NON_CRITICAL	2	// Used to include level 1 plus important non-critical messages
#define DM_DEBUG_STATUS			3	// Used to include level 1 and level 2 plus status\state messages
#define DM_DEBUG_FUNC_FLOW		4	// Used to include level 1, level 2 and level 3 plus function flow messages
#define DM_DEBUG_ALL			5	// Used to include all debug messages

// Default to no debug output compiled
//
#define Trace
#define TraceI
#define assert(exp) ((void)0)

#ifdef DBG

// Checked build: include at least external debug spew
//
extern void DebugInit(void);
extern void DebugTrace(int iDebugLevel, LPSTR pstrFormat, ...);
extern void DebugAssert(LPSTR szExp, LPSTR szFile, ULONG ulLine);

# undef Trace
# define Trace DebugTrace

# undef assert
# define assert(exp) (void)( (exp) || (DebugAssert(#exp, __FILE__, __LINE__), 0) )

// If internal build flag set, include everything
//
# ifdef DMUSIC_INTERNAL
#  undef TraceI
#  define TraceI DebugTrace
# endif

#endif  // #ifdef DBG

#endif  // #ifndef DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dswave\wave.cpp ===
#include <objbase.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <dsoundp.h>
//#include "debug.h"

#include "debug.h" 
#include "dmusicc.h" 
#include "dmusici.h" 
#include "dmusicf.h" 
#include "validate.h"
#include "riff.h"
#include "dswave.h"
#include "riff.h"
#include <regstr.h>
#include <share.h>
#include "waveutil.h"
#include "dmstrm.h"

// seeks to a 32-bit position in a stream.
HRESULT __inline StreamSeek( LPSTREAM pStream, long lSeekTo, DWORD dwOrigin )
{
	LARGE_INTEGER li;

	if( lSeekTo < 0 )
	{
		li.HighPart = -1;
	}
	else
	{
        li.HighPart = 0;
	}
	li.LowPart = lSeekTo;
	return pStream->Seek( li, dwOrigin, NULL );
}

// returns the current 32-bit position in a stream.
DWORD __inline StreamTell( LPSTREAM pStream )
{
	LARGE_INTEGER li;
    ULARGE_INTEGER ul;
#ifdef DBG
    HRESULT hr;
#endif

    li.HighPart = 0;
    li.LowPart = 0;
#ifdef DBG
    hr = pStream->Seek( li, STREAM_SEEK_CUR, &ul );
    if( FAILED( hr ) )
#else
    if( FAILED( pStream->Seek( li, STREAM_SEEK_CUR, &ul ) ) )
#endif
    {
        return 0;
    }
    return ul.LowPart;
}

CWave::CWave() : m_dwDecompressedStart(0)
{
	V_INAME(CWave::CWave);

	InterlockedIncrement(&g_cComponent);

    InitializeCriticalSection(&m_CriticalSection);

    m_pwfx            = NULL;
    m_pwfxDst         = NULL;
	m_fdwFlags		  = 0;
    m_fdwOptions      = 0;
    m_cSamples        = 0L;
	m_pStream         = NULL;
	m_rtReadAheadTime = 0;

    m_cRef = 1;
}

CWave::~CWave()
{
	V_INAME(CWave::~CWave);

    if (NULL != m_pwfx)
    {
        GlobalFreePtr(m_pwfx);
    }
    if (NULL != m_pwfxDst)
    {
        GlobalFreePtr(m_pwfxDst);
    }

	if (m_pStream) m_pStream->Release();

    DeleteCriticalSection(&m_CriticalSection);

	InterlockedDecrement(&g_cComponent);
}

STDMETHODIMP CWave::QueryInterface
(
    const IID &iid,
    void **ppv
)
{
	V_INAME(CWave::QueryInterface);
	V_REFGUID(iid);
	V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IDirectSoundWave)
    {
        *ppv = static_cast<IDirectSoundWave*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else if (iid == IID_IDirectMusicObject)
    {
        *ppv = static_cast<IDirectMusicObject*>(this);
    }
    else if (iid == IID_IPrivateWave)
    {
        *ppv = static_cast<IPrivateWave*>(this);
    }
    else
    {
        *ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on Wave Object\n");
        return E_NOINTERFACE;
    }
    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CWave::AddRef()
{
	V_INAME(CWave::AddRef);

    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CWave::Release()
{
	V_INAME(CWave::Release);

    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

static inline HRESULT MMRESULTToHRESULT(
    MMRESULT mmr)
{
    switch (mmr)
    {
    case MMSYSERR_NOERROR:
        return S_OK;

    case MMSYSERR_ALLOCATED:
        return DSERR_ALLOCATED;

    case MMSYSERR_NOMEM:
        return E_OUTOFMEMORY;

    case MMSYSERR_INVALFLAG:
        return E_INVALIDARG;

    case MMSYSERR_INVALHANDLE:
        return E_INVALIDARG;

    case MMSYSERR_INVALPARAM:
        return E_INVALIDARG;
    }

    return E_FAIL;
}   

STDMETHODIMP CWave::GetFormat
(
    LPWAVEFORMATEX pwfx,
    DWORD dwSizeAllocated,
    LPDWORD pdwSizeWritten
)
{
    DWORD           cbSize;
    LPWAVEFORMATEX  pwfxTemp = NULL;

	V_INAME(CWave::GetFormat);

    if (!pwfx && !pdwSizeWritten)
    {
        Trace(1, "ERROR: GetFormat (Wave): Must request either the format or the required size\n.");
        return E_INVALIDARG;
    }

    if (!m_pwfx)
    {
        return DSERR_BADFORMAT;
    }
    if (WAVE_FORMAT_PCM == m_pwfx->wFormatTag)
    {
        pwfxTemp = m_pwfx;
    }
    else
    {
        pwfxTemp = m_pwfxDst;
        if (!pwfxTemp)
        {
            return DSERR_BADFORMAT;
        }
    }

    //  Note: Assuming that the wave object fills the cbSize field even
    //  on PCM formats...

    if (WAVE_FORMAT_PCM == pwfxTemp->wFormatTag)
    {
        cbSize = sizeof(PCMWAVEFORMAT);
    }
    else
    {
        cbSize = sizeof(WAVEFORMATEX) + pwfxTemp->cbSize;
    }

    if (cbSize > dwSizeAllocated || !pwfx)
    {
        if (pdwSizeWritten)
        {
            *pdwSizeWritten = cbSize;
            return S_OK;  //  What to return?
        }
        else
        {
            return DSERR_INVALIDPARAM;
        }
    }

	//	We don't validate this parameter any earlier on the off chance
	//	that they're doing a query...

	V_BUFPTR_WRITE(pwfx, dwSizeAllocated); 

    CopyMemory(pwfx, pwfxTemp, cbSize);

    //  Set the cbSize field in destination for PCM, IF WE HAVE ROOM...

    if (WAVE_FORMAT_PCM == pwfxTemp->wFormatTag)
    {
        if (sizeof(WAVEFORMATEX) <= dwSizeAllocated)
        {
            pwfx->cbSize = 0;
        }
    }

    // Return the numbers of bytes actually writted
    if (pdwSizeWritten)
    {
        *pdwSizeWritten = cbSize;
    }

    return S_OK;
}

STDMETHODIMP CWave::CreateSource
(
    IDirectSoundSource  **ppSource,
    LPWAVEFORMATEX      pwfx,
    DWORD               fdwFlags
)
{
	HRESULT			hr = S_OK;
	CWaveViewPort* 	pVP;
	CREATEVIEWPORT	cvp;

	V_INAME(CWave::CreateSource);
	V_PTRPTR_WRITE(ppSource);
    V_PWFX_READ(pwfx);

    DWORD dwCreateFlags = 0;
    if (fdwFlags == DMUS_DOWNLOADINFO_ONESHOTWAVE)
    {
        dwCreateFlags |= DSOUND_WAVEF_ONESHOT;
    }
	if (dwCreateFlags & (~DSOUND_WAVEF_CREATEMASK))
	{
        Trace(1, "ERROR: CreateSource (Wave): Unknown flag.\n");
		return (E_INVALIDARG);
	}

    TraceI(5, "CWave::CreateSource [%d samples]\n", m_cSamples);
	
	pVP = new CWaveViewPort;
    if (!pVP)
    {
        return E_OUTOFMEMORY;
    }

	cvp.pStream 	        = m_pStream;
	cvp.cSamples	        = m_cSamples;
    cvp.dwDecompressedStart = m_dwDecompressedStart;
	cvp.cbStream	        = m_cbStream;
	cvp.pwfxSource	        = m_pwfx;
	cvp.pwfxTarget          = pwfx;
    cvp.fdwOptions          = dwCreateFlags;

	hr = pVP->Create(&cvp);

	if (SUCCEEDED(hr)) 
	{
		hr = pVP->QueryInterface(IID_IDirectSoundSource, (void **)ppSource);
	}
	else
	{
	    TraceI(5, "CWave::CreateSource 00\n");
	}

	if (SUCCEEDED(hr))
	{
		// The QI gave us one ref too many
		pVP->Release();
	}
	else
	{
	    TraceI(5, "CWave::CreateSource 01\n");
	}

    return hr;
}

STDMETHODIMP CWave::GetStreamingParms
(
    LPDWORD              pdwFlags, 
    LPREFERENCE_TIME    prtReadAhead
)
{
    V_INAME(IDirectSoundWave::GetStreamingParms);
    V_PTR_WRITE(pdwFlags, DWORD);
    V_PTR_WRITE(prtReadAhead, REFERENCE_TIME);
    
    *pdwFlags = 0;

    if(!(m_fdwFlags & DSOUND_WAVEF_ONESHOT))
    {
        *pdwFlags |= DMUS_WAVEF_STREAMING;
    }

    if(m_fdwFlags & DMUS_WAVEF_NOPREROLL)
    {
        *pdwFlags |= DMUS_WAVEF_NOPREROLL;
    }

    *prtReadAhead  = m_rtReadAheadTime;
    return S_OK;
}

STDMETHODIMP CWave::GetClassID
(
    CLSID*  pClsId
)
{
	V_INAME(CWave::GetClassID);
	V_PTR_WRITE(pClsId, CLSID); 

    *pClsId = CLSID_DirectSoundWave;
    return S_OK;
}

STDMETHODIMP CWave::IsDirty()
{
	V_INAME(CWave::IsDirty);

    return S_FALSE;
}

BOOL CWave::ParseHeader
(
    IStream*        pIStream,
    IRIFFStream*    pIRiffStream,
    LPMMCKINFO      pckMain
)
{
    MMCKINFO    ck;
    DWORD       cb = 0;
    DWORD       dwPos = 0;
    MMCKINFO    ckINFO;
    HRESULT     hr;

    ck.ckid    = 0;
    ck.fccType = 0;

	V_INAME(CWave::ParseHeader);

	BOOL fFormat = FALSE;
 	BOOL fData = FALSE;
 	BOOL fHeader = FALSE;
    BOOL fReadDecompressionFmt = FALSE;
    DWORD dwSamplesFromFact = 0;
   
    while (0 == pIRiffStream->Descend(&ck, pckMain, MMIO_FINDCHUNK))
    {
        switch (ck.ckid)
        {
            case mmioFOURCC('w','a','v','u') :
			{
                cb = 0;
                bool bRuntime = false;
                hr = pIStream->Read(&bRuntime, sizeof(bool), &cb);
                if(FAILED(hr) || cb != sizeof(bool))
                {
                    return FALSE;
                }

                cb = 0;
                bool bCompressed = false;
                hr = pIStream->Read(&bCompressed, sizeof(bool), &cb);
                if(FAILED(hr) || cb != sizeof(bool))
                {
                    return FALSE;
                }

                if(bRuntime && bCompressed)
                {
                    // If we have already allocated m_pwfxDst, delete it first
                    if (NULL != m_pwfxDst)
                    {
                        GlobalFreePtr(m_pwfxDst);
                    }

                    m_pwfxDst = (LPWAVEFORMATEX)GlobalAllocPtr(GHND, sizeof(WAVEFORMATEX));
                    if (NULL == m_pwfxDst)
                    {
				        return FALSE;
                    }

                    cb = 0;
                    hr = pIStream->Read(m_pwfxDst, sizeof(WAVEFORMATEX), &cb);
                    if(FAILED(hr) || cb != sizeof(WAVEFORMATEX))
                    {
                        GlobalFreePtr(m_pwfxDst);
                        return FALSE;
                    }

                    // Read the actual start for the decompressed data if available
                    // This is very important for MP3 and WMA codecs which insert silence in the beginning
                    if(ck.cksize > 2 + sizeof(WAVEFORMATEX))
                    {
                        cb = 0;
                        hr = pIStream->Read(&m_dwDecompressedStart, sizeof(DWORD), &cb);
                        if(FAILED(hr) || cb != sizeof(DWORD))
                        {
                            GlobalFreePtr(m_pwfxDst);
                            return FALSE;
                        }
                    }

                    fReadDecompressionFmt = TRUE;
                }

				break;
			}

            case DMUS_FOURCC_WAVEHEADER_CHUNK:
			{
                m_fdwFlags = 0;
				fHeader = TRUE;
				DMUS_IO_WAVE_HEADER iWaveHeader;
				memset(&iWaveHeader, 0, sizeof(iWaveHeader));
                hr = pIStream->Read(&iWaveHeader, sizeof(iWaveHeader), &cb);
				if (iWaveHeader.dwFlags & DMUS_WAVEF_STREAMING)
				{
					m_fdwFlags &= ~DSOUND_WAVEF_ONESHOT;
					m_rtReadAheadTime = iWaveHeader.rtReadAhead;
				}
				else
				{
					m_fdwFlags |= DSOUND_WAVEF_ONESHOT;
					m_rtReadAheadTime = 0;
				}

                if (iWaveHeader.dwFlags & DMUS_WAVEF_NOPREROLL)
                {
                    m_fdwFlags |= DMUS_WAVEF_NOPREROLL;
                }
                else
                {
                    m_fdwFlags &= ~DMUS_WAVEF_NOPREROLL;
                }

                break;
			}

			case DMUS_FOURCC_GUID_CHUNK:
				hr = pIStream->Read(&m_guid, sizeof(GUID), &cb);
				m_fdwOptions |= DMUS_OBJ_OBJECT;
                break;

            case DMUS_FOURCC_VERSION_CHUNK:
				hr = pIStream->Read( &m_vVersion, sizeof(DMUS_VERSION), &cb );
				m_fdwOptions |= DMUS_OBJ_VERSION;
                break;

            case FOURCC_LIST:
				switch(ck.fccType)
				{
                    case DMUS_FOURCC_INFO_LIST:
		                while( pIRiffStream->Descend( &ckINFO, &ck, 0 ) == 0 )
		                {
		                    switch(ckINFO.ckid)
		                    {
			                    case mmioFOURCC('I','N','A','M'):
			                    {
				                    DWORD cbSize;
				                    cbSize = min(ckINFO.cksize, DMUS_MAX_NAME);
				                    char szName[DMUS_MAX_NAME];
				                    hr = pIStream->Read((BYTE*)szName, cbSize, &cb);
				                    if(SUCCEEDED(hr))
				                    {
					                    MultiByteToWideChar(CP_ACP, 0, szName, -1, m_wszFilename, DMUS_MAX_NAME);
							            m_fdwOptions |= DMUS_OBJ_NAME;
				                    }
                                    break;
                                }
                            }
    		                pIRiffStream->Ascend( &ckINFO, 0 );
                        }
                        break;
                }
                break;

            case mmioFOURCC('f','m','t',' '):
            {
                // If we have already allocated m_pwfx, delete it first
                if (NULL != m_pwfx)
                {
                    GlobalFreePtr(m_pwfx);
                }

				m_pwfx = (LPWAVEFORMATEX)GlobalAllocPtr(GHND, max (sizeof(WAVEFORMATEX), ck.cksize));

                if (NULL == m_pwfx)
                {
                    return FALSE;
                }

                hr = pIStream->Read(m_pwfx, ck.cksize, &cb);

                if (S_OK != hr)
                {
                    return FALSE;
                }

			    if (m_pwfx && WAVE_FORMAT_PCM != m_pwfx->wFormatTag)
			    {
                    if(fReadDecompressionFmt == FALSE)
                    {
                        // If we have already allocated m_pwfxDst, delete it first
                        if (NULL != m_pwfxDst)
                        {
                            GlobalFreePtr(m_pwfxDst);
                        }

                        m_pwfxDst = (LPWAVEFORMATEX)GlobalAllocPtr(GHND, sizeof(WAVEFORMATEX));
                        if (NULL == m_pwfxDst)
                        {
				            return FALSE;
                        }
                        m_pwfxDst->wFormatTag = WAVE_FORMAT_PCM;

                        MMRESULT mmr = acmFormatSuggest(NULL, m_pwfx, m_pwfxDst, sizeof(WAVEFORMATEX), ACM_FORMATSUGGESTF_WFORMATTAG);
	                    if(MMSYSERR_NOERROR != mmr)
                        {
                            GlobalFreePtr(m_pwfxDst);
                            m_pwfxDst = NULL;
                            return FALSE;
                        }
                    }
                }

				fFormat = TRUE;
                TraceI(5, "Format [%d:%d%c%02d]\n", m_pwfx->wFormatTag, m_pwfx->nSamplesPerSec/1000, ((2==m_pwfx->nChannels)?'S':'M'), m_pwfx->wBitsPerSample);
                break;
            }

            case mmioFOURCC('f','a','c','t'):
                hr = pIStream->Read(&dwSamplesFromFact, sizeof(DWORD), &cb);
                TraceI(5, "Stream is %d samples\n", dwSamplesFromFact);
                break;

            case mmioFOURCC('d','a','t','a'):
                TraceI(5, "Data chunk %d bytes\n", ck.cksize);
                m_cbStream = ck.cksize;

				fData = TRUE;
				if (!fHeader) FallbackStreamingBehavior();

                // save stream position so we can seek back later
                dwPos = StreamTell( pIStream ); 
                break;

            default:
                break;
        }
        pIRiffStream->Ascend(&ck, 0);
        ck.ckid    = 0;
        ck.fccType = 0;
    }

	if (m_pwfx && WAVE_FORMAT_PCM != m_pwfx->wFormatTag && dwSamplesFromFact)
	{
        m_cSamples = dwSamplesFromFact;
    }

	if (!fHeader) FallbackStreamingBehavior();

    // Seek to beginning of data
    if (fData)
    {
		StreamSeek(pIStream, dwPos, STREAM_SEEK_SET);
    }
    return fFormat && fData;
}

STDMETHODIMP CWave::Load
(
    IStream*    pIStream
)
{
    IRIFFStream*    pIRiffStream = NULL;
    HRESULT         hr = S_OK;

	V_INAME(CWave::Load);

    if (NULL == pIStream)
    {
        Trace(1, "ERROR: Load (Wave): Attempt to load from null stream.\n");
        return E_INVALIDARG;
    }

    EnterCriticalSection( &m_CriticalSection );

    if (SUCCEEDED(AllocRIFFStream(pIStream, &pIRiffStream)))
    {
        MMCKINFO    ckMain;

        ckMain.fccType = mmioFOURCC('W','A','V','E');

        if (0 != pIRiffStream->Descend(&ckMain, NULL, MMIO_FINDRIFF))
        {
            Trace(1, "ERROR: Load (Wave): Stream does not contain a wave chunk.\n");
            hr = E_INVALIDARG;
			goto ON_END;
        }

        //  Parses the header information and seeks to the beginning
        //  of the data in the data chunk.

        if (0 == ParseHeader(pIStream, pIRiffStream, &ckMain))
        {
		    Trace(1, "ERROR: Load (Wave): Attempt to read wave's header information failed.\n");
            hr = E_INVALIDARG;
			goto ON_END;
        }

		if (0 == m_cSamples)
		{
			if (m_pwfx && WAVE_FORMAT_PCM == m_pwfx->wFormatTag)
			{
				m_cSamples = m_cbStream / m_pwfx->nBlockAlign;
			}
			else // wave format not supported
			{
				hr = DSERR_BADFORMAT;
				goto ON_END;
			}
		}
    }

	pIStream->AddRef();
    if (m_pStream)
    {
        m_pStream->Release();
    }
	m_pStream = pIStream;

ON_END:
	if (pIRiffStream) pIRiffStream->Release();
    LeaveCriticalSection( &m_CriticalSection );
    TraceI(5, "CWave::Load01\n");

    return hr;
}

STDMETHODIMP CWave::Save
(
    IStream*    pIStream,
    BOOL        fClearDirty
)
{
	V_INAME(CWave::Save);

	return E_NOTIMPL; 
}

STDMETHODIMP CWave::GetSizeMax
(
    ULARGE_INTEGER FAR* pcbSize
)
{
	V_INAME(CWave::GetSizeMax);

	return E_NOTIMPL; 
}

STDMETHODIMP CWave::GetDescriptor
(
    LPDMUS_OBJECTDESC   pDesc
)
{
    //  Parameter validation...

	V_INAME(CWave::GetDescriptor);
    V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC)

    ZeroMemory(pDesc, sizeof(DMUS_OBJECTDESC));

    pDesc->dwSize      = sizeof(DMUS_OBJECTDESC);
    pDesc->dwValidData = DMUS_OBJ_CLASS;
    pDesc->guidClass   = CLSID_DirectSoundWave;

    if (NULL != m_pwfx)
    {
        pDesc->dwValidData |= DMUS_OBJ_LOADED;
    }

    if (m_fdwOptions & DMUS_OBJ_OBJECT)
    {
        pDesc->guidObject   = m_guid;
        pDesc->dwValidData |= DMUS_OBJ_OBJECT;
    }

    if (m_fdwOptions & DMUS_OBJ_NAME)
    {
        memcpy( pDesc->wszName, m_wszFilename, sizeof(m_wszFilename) );
        pDesc->dwValidData |= DMUS_OBJ_NAME;
    }

    if (m_fdwOptions & DMUS_OBJ_VERSION)
    {
		pDesc->vVersion.dwVersionMS = m_vVersion.dwVersionMS;
		pDesc->vVersion.dwVersionLS = m_vVersion.dwVersionLS;
        pDesc->dwValidData |= DMUS_OBJ_VERSION;
    }

    return S_OK;
}

STDMETHODIMP CWave::SetDescriptor
(
    LPDMUS_OBJECTDESC   pDesc
)
{
    HRESULT hr = E_INVALIDARG;
    DWORD   dw = 0;

    //  Parameter validation...

	V_INAME(CWave::SetDescriptor);
    V_PTR_READ(pDesc, DMUS_OBJECTDESC)

    if (pDesc->dwSize >= sizeof(DMUS_OBJECTDESC))
    {
        if(pDesc->dwValidData & DMUS_OBJ_CLASS)
        {
            dw           |= DMUS_OBJ_CLASS;
        }

        if(pDesc->dwValidData & DMUS_OBJ_LOADED)
        {
            dw           |= DMUS_OBJ_LOADED;
        }

        if (pDesc->dwValidData & DMUS_OBJ_OBJECT)
        {
            m_guid        = pDesc->guidObject;
            dw           |= DMUS_OBJ_OBJECT;
            m_fdwOptions |= DMUS_OBJ_OBJECT;
        }

        if (pDesc->dwValidData & DMUS_OBJ_NAME)
        {
            memcpy( m_wszFilename, pDesc->wszName, sizeof(WCHAR)*DMUS_MAX_NAME );
            dw           |= DMUS_OBJ_NAME;
            m_fdwOptions |= DMUS_OBJ_NAME;
        }

        if (pDesc->dwValidData & DMUS_OBJ_VERSION)
        {
			m_vVersion.dwVersionMS = pDesc->vVersion.dwVersionMS;
			m_vVersion.dwVersionLS = pDesc->vVersion.dwVersionLS;
			dw           |= DMUS_OBJ_VERSION;
			m_fdwOptions |= DMUS_OBJ_VERSION;
        }

        if (pDesc->dwValidData & (~dw))
        {
            Trace(2, "WARNING: SetDescriptor (Wave): Descriptor contains fields that were not set.\n");
            hr = S_FALSE;
            pDesc->dwValidData = dw;
        }
        else
        {
            hr = S_OK;
        }
    }

    return hr;
}

STDMETHODIMP CWave::ParseDescriptor
(
    LPSTREAM            pStream,
    LPDMUS_OBJECTDESC   pDesc
)
{
	V_INAME(CWave::ParseDescriptor);
    V_PTR_READ(pDesc, DMUS_OBJECTDESC)

    CRiffParser Parser(pStream);
    RIFFIO ckMain;
	RIFFIO ckNext;
    RIFFIO ckINFO;
    HRESULT hr = S_OK;

    Parser.EnterList(&ckMain);  
    if (Parser.NextChunk(&hr) && (ckMain.fccType == mmioFOURCC('W','A','V','E')))
    {
        Parser.EnterList(&ckNext);
	    while(Parser.NextChunk(&hr))
	    {
		    switch(ckNext.ckid)
		    {
            case DMUS_FOURCC_GUID_CHUNK:
				hr = Parser.Read( &pDesc->guidObject, sizeof(GUID) );
				if( SUCCEEDED(hr) )
				{
					pDesc->dwValidData |= DMUS_OBJ_OBJECT;
				}
				break;

            case DMUS_FOURCC_VERSION_CHUNK:
				hr = Parser.Read( &pDesc->vVersion, sizeof(DMUS_VERSION) );
				if( SUCCEEDED(hr) )
				{
					pDesc->dwValidData |= DMUS_OBJ_VERSION;
				}
				break;

			case FOURCC_LIST:
				switch(ckNext.fccType)
				{
                case DMUS_FOURCC_INFO_LIST:
                    Parser.EnterList(&ckINFO);
                    while (Parser.NextChunk(&hr))
					{
						switch( ckINFO.ckid )
						{
                        case mmioFOURCC('I','N','A','M'):
						{
				            DWORD cbSize;
				            cbSize = min(ckINFO.cksize, DMUS_MAX_NAME);
						    char szName[DMUS_MAX_NAME];
                            hr = Parser.Read(&szName, sizeof(szName));
						    if(SUCCEEDED(hr))
						    {
								MultiByteToWideChar(CP_ACP, 0, szName, -1, pDesc->wszName, DMUS_MAX_NAME);
								pDesc->dwValidData |= DMUS_OBJ_NAME;
                            }
							break;
						}
						default:
							break;
						}
					}
                    Parser.LeaveList();
					break;            
				}
				break;

			default:
				break;

		    }
        }
        Parser.LeaveList();
    }
    else
    {
        Trace(2, "WARNING: ParseDescriptor (Wave): The stream does not contain a Wave chunk.\n");
        hr = DMUS_E_CHUNKNOTFOUND;
    }
	
	return hr;
}

STDMETHODIMP CWave::GetLength(REFERENCE_TIME *prtLength)
{
	HRESULT hr = S_OK;
	if (0 == m_cSamples)
	{
		if (m_pwfx && WAVE_FORMAT_PCM == m_pwfx->wFormatTag)
		{
			m_cSamples = m_cbStream / m_pwfx->nBlockAlign;
		}
	}
	if (m_cSamples && m_pwfx && m_pwfx->nSamplesPerSec)
	{
        if(m_dwDecompressedStart > 0)
        {
            assert(m_dwDecompressedStart < m_cSamples);
            *prtLength = 1000 * (REFERENCE_TIME)(m_cSamples - m_dwDecompressedStart) / m_pwfx->nSamplesPerSec;
        }
        else
        {
		    *prtLength = 1000 * (REFERENCE_TIME)m_cSamples / m_pwfx->nSamplesPerSec;
        }
	}
	else
	{
        Trace(2, "WARNING: Couldn't get a length for a Wave.\n");
		hr = DMUS_E_BADWAVE;
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dswave\viewport.cpp ===
#include <objbase.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <dsoundp.h>

#include "debug.h" 
#include "dmusicc.h" 
#include "dmusici.h" 
#include "validate.h"
#include "riff.h"
#include "dswave.h"
#include "waveutil.h"
#include "riff.h"
#include <regstr.h>
#include <share.h>

//    CWaveViewPort(IStream *pStream);  // Constructor receives stream.
//    ~CWaveViewPort();                 //  Destructor releases memory, streams, etc.
//
//    STDMETHODIMP Init();
//    STDMETHODIMP GetFormat(LPWAVEFORMATEX pWaveFormatEx, LPDWORD pdwWaveFormatExSize);
//    STDMETHODIMP Seek(DWORD dwSample);
//    STDMETHODIMP Read(LPVOID *ppvBuffer, DWORD cpvBuffer, LPDWORD pcb);


CWaveViewPort::CWaveViewPort() : m_dwDecompressedStart(0), m_dwDecompStartOffset(0), m_dwDecompStartOffsetPCM(0), m_dwDecompStartDelta(0)
{
    V_INAME(CWaveViewPort::CWaveViewPort);

    InterlockedIncrement(&g_cComponent);

    InitializeCriticalSection(&m_CriticalSection);
    // Note: on pre-Blackcomb OS's, this call can raise an exception; if it
    // ever pops in stress, we can add an exception handler and retry loop.

    m_cRef = 1;

    //  General stuff...
    m_pStream    = NULL; 
    m_cSamples   = 0L;
    m_cbStream   = 0L;
    m_dwStart    = 0L;

    //  Viewport info...
    m_pwfxTarget = NULL;
    ZeroMemory(&m_ash, sizeof(ACMSTREAMHEADER));
    m_hStream    = NULL;   
    m_pDst       = NULL;      
    m_pRaw       = NULL;      
    m_fdwOptions = 0L;

    m_dwPreCacheFilePos = 0;
    m_dwFirstPCMSample = 0;
    m_dwPCMSampleOut = 0;

    return;
}


CWaveViewPort::~CWaveViewPort()
{
    V_INAME(CWaveViewPort::~CWaveViewPort);

    if (m_pStream) m_pStream->Release();
    if (m_hStream)
    {
        acmStreamUnprepareHeader(m_hStream, &m_ash, 0L);
        acmStreamClose(m_hStream, 0);
    }
    if (NULL != m_pwfxTarget)
    {
        GlobalFreePtr(m_pwfxTarget);
    }
    if (NULL != m_ash.pbDst)
    {
        GlobalFreePtr(m_ash.pbDst);
    }
    if (NULL != m_ash.pbSrc)
    {
        GlobalFreePtr(m_ash.pbSrc);
    }
    
    DeleteCriticalSection(&m_CriticalSection);

    InterlockedDecrement(&g_cComponent);

    return;
}

STDMETHODIMP CWaveViewPort::QueryInterface
(
    const IID &iid,
    void **ppv
)
{
    V_INAME(CWaveViewPort::QueryInterface);

    if (iid == IID_IUnknown || iid == IID_IDirectSoundSource)
    {
        *ppv = static_cast<IDirectSoundSource*>(this);
    }
    else
    {
        *ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on Viewport\n");
        return E_NOINTERFACE;
    }
    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CWaveViewPort::AddRef()
{
    V_INAME(CWaveViewPort::AddRef);

    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CWaveViewPort::Release()
{
    V_INAME(CWaveViewPort::Release);

    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CWaveViewPort::SetSink
(
    IDirectSoundConnect *pSinkConnect
)
{
    V_INAME(CWaveViewPort::Init);
    
    return S_OK;
}

STDMETHODIMP CWaveViewPort::GetFormat
(
    LPWAVEFORMATEX pwfx,
    DWORD dwSizeAllocated,
    LPDWORD pdwSizeWritten
)
{
    DWORD           cbSize;

    V_INAME(CWaveViewPort::GetFormat);

    if (!pwfx && !pdwSizeWritten)
    {
        Trace(1, "ERROR: GetFormat (Viewport): Must request either the format or the required size");
        return E_INVALIDARG;
    }

    if (!m_pwfxTarget)
    {
        return DSERR_BADFORMAT;
    }

    //  Note: Assuming that the wave object fills the cbSize field even
    //  on PCM formats...

    if (WAVE_FORMAT_PCM == m_pwfxTarget->wFormatTag)
    {
        cbSize = sizeof(PCMWAVEFORMAT);
    }
    else
    {
        cbSize = sizeof(WAVEFORMATEX) + m_pwfxTarget->cbSize;
    }

    if (pdwSizeWritten)
    {
        V_PTR_WRITE(pdwSizeWritten, DWORD);
        *pdwSizeWritten = cbSize;
    }

    if (pwfx)
    {
        V_BUFPTR_WRITE(pwfx, dwSizeAllocated);
        if (dwSizeAllocated < cbSize)
        {
            return DSERR_INVALIDPARAM;
        }
        else
        {
            CopyMemory(pwfx, m_pwfxTarget, cbSize);
            // Set the cbSize field in destination if we have room
            if (WAVE_FORMAT_PCM == m_pwfxTarget->wFormatTag && dwSizeAllocated >= sizeof(WAVEFORMATEX))
            {
                pwfx->cbSize = 0;
            }
        }
    }

    return S_OK;
}

STDMETHODIMP CWaveViewPort::Seek
(
    ULONGLONG       ullPosition
)
{
    LARGE_INTEGER   li;
    HRESULT         hr;
    MMRESULT        mmr;
    DWORD           cbSize;

    V_INAME(CWaveViewPort::Seek);

    m_fdwOptions &= ~DSOUND_WVP_STREAMEND; // rsw clear this on seek: no longer at stream end

    if (m_fdwOptions & DSOUND_WVP_NOCONVERT)
    {
        if ((DWORD) ullPosition >= m_cbStream)
        {
            // Seek past end of stream
            //
            m_fdwOptions |= DSOUND_WVP_STREAMEND;
            m_dwOffset = m_cbStream;

            return S_OK;
        }

        m_dwOffset = (DWORD) ullPosition;      // rsw initialize offset to Seek position

        if (0 != (ullPosition % m_pwfxTarget->nBlockAlign))
        {
            //  Seek position not block aligned?

            Trace(1, "ERROR: Seek (wave): Seek position is not block-aligned.\n");
            return (DMUS_E_BADWAVE);
        }

        li.HighPart = 0;
        li.LowPart  = ((DWORD)ullPosition) + m_dwStartPos;

        hr = m_pStream->Seek(li, STREAM_SEEK_SET, NULL);

        if (FAILED(hr))
        {
            Trace(1, "ERROR: Seek (Viewport): Seeking the vieport's stream failed.\n");
            return (DMUS_E_BADWAVE);
        }
    }
    else
    {
        //  Estimating source stream position...
        //
        //  Should we create lookup table?!

        cbSize = (DWORD)ullPosition;

        if (cbSize)
        {
            mmr = acmStreamSize(m_hStream, cbSize, &cbSize, ACM_STREAMSIZEF_DESTINATION);

            if (MMSYSERR_NOERROR != mmr)
            {
                Trace(1, "ERROR: Seek (viewport): Could not convert target stream size to source format.\n");
                return (DMUS_E_BADWAVE);
            }
        }

        if (cbSize >= m_cbStream)
        {
            // Seek past end of stream
            //
            m_fdwOptions |= DSOUND_WVP_STREAMEND;
            m_dwOffset = m_cbStream;

            return S_OK;
        }

        // If this is a seek to the precache end we know where to start reading from
        if((m_fdwOptions & DSOUND_WAVEF_ONESHOT) == 0)
        {
            // Go back to the block that was read for the end of the precached data
            if(cbSize != 0 && m_dwPCMSampleOut == ullPosition)
            {
                m_dwOffset = m_dwPreCacheFilePos;
                li.HighPart = 0;
                li.LowPart  = m_dwOffset + m_dwStartPos;
            }
            else
            {
                m_dwOffset = cbSize; // rsw initialize offset to Seek position
                li.HighPart = 0;
                li.LowPart  = cbSize + m_dwStartPos;

            }

            hr = m_pStream->Seek(li, STREAM_SEEK_SET, NULL);

            if (FAILED(hr))
            {
                Trace(1, "ERROR: Seek (viewport): Seeking the viewport's stream failed.\n");
                return (DMUS_E_BADWAVE);
            }

            // Since we're restarting, re-initialize.
            m_fdwOptions &= (~DSOUND_WVP_CONVERTMASK);
            m_fdwOptions |= DSOUND_WVP_CONVERTSTATE_01;

            m_ash.cbSrcLength     = (DWORD)m_ash.dwSrcUser;
            m_ash.cbSrcLengthUsed = m_ash.cbSrcLength;

            m_ash.dwDstUser       = 0L;
            m_ash.cbDstLengthUsed = 0L;

        }

        /////////////////////////////////////////////////////////////////////////////////////
        // If we're starting the wave, re-seek the stream (one-shots always need to re-seek).
        // NOTE: The following assumes that compressed waves always seek from the beginning,
        // since the value returned by acmStreamSize is pretty unreliable.
        /////////////////////////////////////////////////////////////////////////////////////
        else if ( cbSize == 0 || (m_fdwOptions & DSOUND_WAVEF_ONESHOT) )
        {
        
            m_dwOffset = cbSize; // rsw initialize offset to Seek position
            li.HighPart = 0;
            li.LowPart  = cbSize + m_dwStartPos;

            hr = m_pStream->Seek(li, STREAM_SEEK_SET, NULL);

            if (FAILED(hr))
            {
                Trace(1, "ERROR: Seek (viewport): Seeking the viewport's stream failed.\n");
                return (DMUS_E_BADWAVE);
            }

            // Since we're restarting, re-initialize.
            m_fdwOptions &= (~DSOUND_WVP_CONVERTMASK);
            m_fdwOptions |= DSOUND_WVP_CONVERTSTATE_01;

            m_ash.cbSrcLength     = (DWORD)m_ash.dwSrcUser;
            m_ash.cbSrcLengthUsed = m_ash.cbSrcLength;

            m_ash.dwDstUser       = 0L;
            m_ash.cbDstLengthUsed = 0L;

        }
    }

    TraceI(5, "Seek (Viewport): Succeeded.\n");
    return S_OK;
}

static inline HRESULT MMRESULTToHRESULT(
    MMRESULT mmr)
{
    switch (mmr)
    {
    case MMSYSERR_NOERROR:
        return S_OK;

    case MMSYSERR_ALLOCATED:
        return DSERR_ALLOCATED;

    case MMSYSERR_NOMEM:
        return E_OUTOFMEMORY;
    }

    return E_FAIL;
}   

HRESULT CWaveViewPort::acmRead
(
    void
)
{
    DWORD       cbSize;
    DWORD       dwOffset;
    DWORD       fdwConvert = 0;
    MMRESULT    mmr;
    HRESULT     hr;

    V_INAME(CWaveViewPort::acmRead);
    
    for (m_ash.cbDstLengthUsed = 0; 0 == m_ash.cbDstLengthUsed; )
    {
        //  Did we use up the entire buffer?

        if (m_ash.cbSrcLengthUsed == m_ash.cbSrcLength)
        {
            //  Yep!

            dwOffset = 0L;
            cbSize   = (DWORD)m_ash.dwSrcUser;
        }
        else
        {
            //  Nope!

            dwOffset = m_ash.cbSrcLength - m_ash.cbSrcLengthUsed;
            cbSize   = (DWORD)m_ash.dwSrcUser - dwOffset;

            //  Moving the remaining data from the end of buffer to the beginning

            MoveMemory(
                    m_ash.pbSrc,                            //  Base address
                    &(m_ash.pbSrc[m_ash.cbSrcLengthUsed]),  //  Address of unused bytes
                    dwOffset);                              //  Number of unused bytes
        }

        //  Are we at the end of the stream?
        cbSize = min(cbSize, m_cbStream - m_dwOffset);

        if (0 == cbSize)
        {
            if (dwOffset)
            {
                m_ash.cbSrcLength = dwOffset;
            }
        }
        else
        {
            hr = m_pStream->Read(&(m_ash.pbSrc[dwOffset]), cbSize, &cbSize);

            if (FAILED(hr))
            {
                Trace(1, "ERROR: Read (Viewport): Attempt to read source stream returned 0x%08lx\n", hr);
                //>>>>>>>>>>>>>>>>>>>> 
                m_fdwOptions &= (~DSOUND_WVP_CONVERTMASK);
                m_fdwOptions |= DSOUND_WVP_STREAMEND;
                return(DMUS_E_CANNOTREAD);
                //>>>>>>>>>>>>>>>>>>>> 
            }

            m_dwOffset        += cbSize;
            m_ash.cbSrcLength  = cbSize + dwOffset;
        }

        switch (m_fdwOptions & DSOUND_WVP_CONVERTMASK)
        {
            case DSOUND_WVP_CONVERTSTATE_01:
                fdwConvert = ACM_STREAMCONVERTF_BLOCKALIGN;
                break;

            case DSOUND_WVP_CONVERTSTATE_02:
                fdwConvert = ACM_STREAMCONVERTF_BLOCKALIGN | ACM_STREAMCONVERTF_END;
                break;

            case DSOUND_WVP_CONVERTSTATE_03:
                fdwConvert = ACM_STREAMCONVERTF_END;
                break;

            default:
                TraceI(3, "CWaveViewPort::acmRead: Default case?!\n");
                break;
        }

        mmr = acmStreamConvert(m_hStream, &m_ash, fdwConvert);

        if (MMSYSERR_NOERROR != mmr)
        {
            Trace(1, "ERROR: Read (Viewport): Attempt to convert wave to PCM failed.\n");
            return (MMRESULTToHRESULT(mmr));
        }

        if (0 != m_ash.cbDstLengthUsed)
        {
            m_ash.dwDstUser = 0L;
            return (S_OK);
        }

        //  No data returned?

        switch (m_fdwOptions & DSOUND_WVP_CONVERTMASK)
        {
            case DSOUND_WVP_CONVERTSTATE_01:
                if (0 == cbSize)
                {
                    //  We're at the end of the stream..

                    m_fdwOptions &= (~DSOUND_WVP_CONVERTMASK);
                    m_fdwOptions |= DSOUND_WVP_CONVERTSTATE_02;
                    TraceI(5, "CWaveViewPort::acmRead: Moving to stage 2\n");
                }

                //  Otherwise, continue converting data as normal.
                break;

            case DSOUND_WVP_CONVERTSTATE_02:
                //  We have hit the last partial block!

                m_fdwOptions &= (~DSOUND_WVP_CONVERTMASK);
                m_fdwOptions |= DSOUND_WVP_CONVERTSTATE_03;
                TraceI(5, "CWaveViewPort::acmRead: Moving to stage 3\n");
                break;

            case DSOUND_WVP_CONVERTSTATE_03:
                //  No more data after end flag, NO MORE DATA!!
                m_fdwOptions &= (~DSOUND_WVP_CONVERTMASK);
                m_fdwOptions |= DSOUND_WVP_STREAMEND;
                Trace(2, "WARNING: Read (Viewport): End of source stream.\n");
                return (DMUS_E_BADWAVE);

            default:
                TraceI(3, "CWaveViewPort::acmRead: Default case?!\n");
                break;
        }
    }

    TraceI(3, "CWaveViewPort::acmRead: We should never get here!\n");

    return (S_OK);
}

//////////////////////////////////////////////////////////////////////////////
//
// ppvBuffer[] contains cpvBuffer pointers-to-samples, each to be filled with
// *pcb bytes of data. On output *pcb will contain the number of bytes (per
// buffer) actually read.
//
// pdwBusIds and pdwFuncIds are used to specify the bus and functionality
// of each buffer, but these are ignored by the wave object.
//
STDMETHODIMP CWaveViewPort::Read
(
    LPVOID         *ppvBuffer,
    LPDWORD         pdwBusIds,
    LPDWORD         pdwFuncIds,
    LPLONG          plPitchShifts,
    DWORD           cpvBuffer,
    ULONGLONG      *pcb
)
{
    HRESULT     hr = S_OK;
    DWORD       cbRead;
    DWORD       dwOffset;
    DWORD       cbSize;

    V_INAME(CWaveViewPort::Read);
    V_BUFPTR_READ(ppvBuffer, (cpvBuffer * sizeof(LPVOID)));
    V_BUFPTR_READ_OPT(pdwBusIds, (cpvBuffer * sizeof(LPDWORD)));
    V_BUFPTR_READ_OPT(pdwFuncIds, (cpvBuffer * sizeof(LPDWORD)));

    for (cbRead = cpvBuffer, cbSize = (DWORD)*pcb; cbRead; cbRead--)
    {
        V_BUFPTR_WRITE(ppvBuffer[cbRead - 1], cbSize);
    }

    if (m_fdwOptions & DSOUND_WVP_STREAMEND)
    {
        *pcb = 0;
        Trace(2, "WARNING: Read (Viewport): Attempt to read at end of stream.\n");
        return (S_FALSE);
    }

    LPVOID *ppvWriteBuffers  = ppvBuffer;
    DWORD dwWriteBufferCount = cpvBuffer;

    if (m_fdwOptions & DSOUND_WVP_NOCONVERT)
    {
        //  Total number of bytes to read... size of each buffer * number of buffers

        cbRead   = ((DWORD)*pcb) * dwWriteBufferCount;
        dwOffset = 0;

        TraceI(5, "CWaveViewPort::Read - No conversion [%d bytes]\n", cbRead);

        do
        {
            //  Calculate read size...  It's going to be the size of:
            //    1.  Remaining bytes to read.
            //    2.  Size of the buffer.
            //    3.  Remaining bytes in the stream.
            //  Whichever happens to be the smallest.

            cbSize = min(cbRead, m_ash.cbDstLength);
            cbSize = min(cbSize, m_cbStream - m_dwOffset);

            TraceI(5, "CWaveViewPort::Read - Trying to read %d bytes\n", cbSize);

            DWORD _cbSize = cbSize; cbSize = 0; // Read may not set cbSize to zero 
        
            hr = m_pStream->Read(m_ash.pbDst, _cbSize, &cbSize);

            TraceI(5, "CWaveViewPort::Read - Read %d bytes\n", cbSize);

            if (FAILED(hr))
            {
                Trace(2, "WARNING: Read (Viewport): Attempt to read returned 0x%08lx.\n", hr);
                break;
            }

            dwOffset = DeinterleaveBuffers(
                            m_pwfxTarget,
                            m_ash.pbDst,
                            (LPBYTE *)ppvWriteBuffers,
                            dwWriteBufferCount,
                            cbSize,
                            dwOffset);

            cbRead     -= cbSize;
            m_dwOffset += cbSize;

            if (m_dwOffset >= m_cbStream)
            {
                m_fdwOptions |= DSOUND_WVP_STREAMEND;
                break;
            }
        }
        while (0 != cbRead);

        if (SUCCEEDED(hr))
        {
            *pcb = dwOffset;
        }
    }
    else
    {
        // If this is the read for the precache then we should remember the fileposition, 
        // start sample for the decompressed block and the last sample passed back so we 
        // can accurately pick up from there when refilling buffers
        // We use the LPLONG plPitchShifts in the read method as a boolean
        // this is a HACK!! We need to change this...
        // *plPitchShifts == 2 is to remember the precache offset
        // *plPitchShifts == 1 is to read from there
        bool fRememberPreCache = false;
        if(plPitchShifts != NULL && *plPitchShifts == 2 && (m_fdwOptions & DSOUND_WAVEF_ONESHOT) == 0)
        {
            fRememberPreCache = true;
        }

        bool bRemoveSilence = false;
        
        cbRead   = ((DWORD)*pcb) * dwWriteBufferCount;
        dwOffset = 0;

        TraceI(5, "CWaveViewPort::Read - Conversion needed\n");

        do
        {
            if(m_dwDecompressedStart > 0 && m_dwOffset <= m_dwDecompStartOffset)
            {
                bRemoveSilence = true;
            }

            //  Is there any remnant data in destination buffer?
            if (m_ash.dwDstUser >= m_ash.cbDstLengthUsed)
            {
                if(fRememberPreCache)
                {
                    // Go back on block
                    m_dwPreCacheFilePos = m_dwOffset - m_ash.cbSrcLength;
                    m_dwFirstPCMSample = dwOffset * dwWriteBufferCount;
                }

                if(plPitchShifts != NULL && *plPitchShifts == 1)
                {
                    // Seek to the right place first
                    Seek(m_dwPCMSampleOut);

                    // Read one block since we're starting one block behind
                    hr = acmRead();
                    if(FAILED(hr))
                    {
                        break;
                    }
                }

                hr = acmRead();
            }

            if (FAILED(hr))
            {
                // acmRead spews when it fails; no need to do it again here
                break;
            }

            DWORD dwDstOffset = (ULONG)m_ash.dwDstUser;

            if(bRemoveSilence)
            {
                // We have partial data to throw away
                if(m_dwDecompStartOffset <= m_dwOffset)
                {
                    if(dwDstOffset > 0)
                    {
                        dwDstOffset += m_dwDecompStartDelta;
                    }
                    else
                    {
                        // This is the first decompressed block so we go straight to the value we know
                        dwDstOffset += m_dwDecompStartOffsetPCM;
                    }

                    m_ash.dwDstUser = dwDstOffset;
                    bRemoveSilence = false;
                }
                else
                {
                    // This is all throw away data
                    bRemoveSilence = false;
                    cbSize = min(cbRead, m_ash.cbDstLengthUsed - dwDstOffset);
                    m_ash.dwDstUser += cbSize;
                    continue;
                }
            }


            // We use the LPLONG plPitchShifts in the read method as a boolean
            // this is a HACK!! We need to change this...
            if(plPitchShifts && *plPitchShifts == 1)
            {
                dwDstOffset = m_dwPCMSampleOut - m_dwFirstPCMSample;
                m_ash.dwDstUser = dwDstOffset;
                plPitchShifts = 0;
            }

            cbSize = min(cbRead, m_ash.cbDstLengthUsed - dwDstOffset);

            dwOffset = DeinterleaveBuffers(
                            m_pwfxTarget,
                            &(m_ash.pbDst[dwDstOffset]),
                            (LPBYTE *)ppvWriteBuffers,
                            dwWriteBufferCount,
                            cbSize,
                            dwOffset);

            cbRead -= cbSize;
            m_ash.dwDstUser += cbSize;

            if ((m_fdwOptions & DSOUND_WVP_STREAMEND) &&
                (m_ash.dwDstUser >= m_ash.cbDstLengthUsed))
            {
                break;
            }
        }
        while(0 != cbRead);

        if(fRememberPreCache)
        {
            m_dwPCMSampleOut = dwOffset * dwWriteBufferCount;
        }

        if (SUCCEEDED(hr))
        {
            *pcb = dwOffset;
        }
    }

    TraceI(5, "CWaveViewPort::Read returning %x (%d bytes)\n", hr, dwOffset);
    return hr;
}

STDMETHODIMP CWaveViewPort::GetSize
(
    ULONGLONG      *pcb
)
{
    V_INAME(CWaveViewPort::GetSize);
    V_PTR_WRITE(pcb, ULONGLONG);
    
    TraceI(5, "CWaveViewPort::GetSize [%d samples]\n", m_cSamples);
    HRESULT hr = S_OK;

    if (m_fdwOptions & DSOUND_WVP_NOCONVERT)
    {
        //  No conversion.  This is trivial

        *pcb = (SAMPLE_TIME)(m_cbStream);
    }
    else if (!m_pwfxTarget)
    {
        hr = DSERR_UNINITIALIZED;
    }
    else
    {
        //  Conversion required; let's hope target format is PCM

        if (WAVE_FORMAT_PCM == m_pwfxTarget->wFormatTag)
        {
            //  Cool.  This is simply the number of samples X the block align

            *pcb = (SAMPLE_TIME)((m_cSamples - m_dwDecompressedStart) * m_pwfxTarget->nBlockAlign);
        }
        else
        {
            Trace(1, "ERROR: GetSize (Viewport): Conversion required and target is not PCM.\n");
            hr = DSERR_BADFORMAT;
        }
    }

    return (hr);
}

HRESULT CWaveViewPort::Create
(
    PCREATEVIEWPORT     pCreate
)
{
    DWORD           cbSize;
    MMRESULT        mmr;
    HRESULT         hr;
    LARGE_INTEGER   li;
    LPWAVEFORMATEX  pwfxSrc = pCreate->pwfxSource;
    LPWAVEFORMATEX  pwfxDst = pCreate->pwfxTarget;

    V_INAME(CWaveViewPort::Create);
    
    TraceI(5, "CWaveViewPort::Create [%d samples]\n", pCreate->cSamples);

    EnterCriticalSection(&m_CriticalSection);

    //  Clone source stream...

    hr = pCreate->pStream->Clone(&m_pStream);

    if (FAILED(hr))
    {
        LeaveCriticalSection(&m_CriticalSection);
        return (hr);
    }

    //  Misc assignments
    m_cSamples   = pCreate->cSamples;
    m_cbStream   = pCreate->cbStream;
    m_dwOffset   = 0L;
    m_fdwOptions = pCreate->fdwOptions;
    m_dwDecompressedStart = pCreate->dwDecompressedStart;
    m_dwDecompStartOffset = 0L;
    m_dwDecompStartOffsetPCM = 0L;
    m_dwDecompStartDelta = 0L;

    TraceI(5, "CWaveViewPort:: %d samples\n", m_cSamples);

    //  Allocate destination format
    cbSize = SIZEOFFORMATEX(pwfxDst);

    m_pwfxTarget = (LPWAVEFORMATEX)GlobalAllocPtr(GHND, cbSize);

    if (NULL == m_pwfxTarget)
    {
        LeaveCriticalSection(&m_CriticalSection);
        TraceI(1, "OUT OF MEMORY: CWaveViewPort::Create - size: %d \n", cbSize);
        return (E_OUTOFMEMORY);
    }

    //  We don't own the buffer for pwfxDst, so we can't touch its cbSize.
    //  We have to set the size manually on PCM, we KNOW the buffer is
    //  large enough.

    CopyFormat(m_pwfxTarget, pwfxDst);
    if (WAVE_FORMAT_PCM == m_pwfxTarget->wFormatTag)
    {
        m_pwfxTarget->cbSize = 0;
    }

    //  Calculating (block-aligned) size of destination buffer...
    cbSize = (pwfxDst->nAvgBytesPerSec * CONVERTLENGTH) / 1000;
    cbSize = BLOCKALIGN(cbSize, pwfxDst->nBlockAlign);

    m_ash.pbDst = (LPBYTE)GlobalAllocPtr(GHND, cbSize);

    if (NULL == m_ash.pbDst)
    {
        LeaveCriticalSection(&m_CriticalSection);
        TraceI(1, "OUT OF MEMORY: CWaveViewPort::Create 01\n");
        return (E_OUTOFMEMORY);
    }

    m_ash.cbDstLength = cbSize;

    //  Getting stream starting offset...

    li.HighPart = 0;
    li.LowPart  = 0;
    hr = m_pStream->Seek(li, STREAM_SEEK_CUR, (ULARGE_INTEGER *)(&li));

    m_dwStartPos = li.LowPart;

    //  Do we need to use the ACM?
    if (FormatCmp(pwfxSrc, pwfxDst))
    {
        //  Formats compare!!  All we need to do is to copy the data straight
        //  from the source stream.  Way Cool!!

        TraceI(5, "Source and Destination formats are similar!\n");

        m_fdwOptions |= DSOUND_WVP_NOCONVERT;
    }
    else
    {
        //  Source and destination formats are different...

        TraceI(5, "CWaveViewPort:Create: Formats are different... Use ACM!\n");

        m_fdwOptions |= DSOUND_WVP_CONVERTSTATE_01;

        mmr = acmStreamOpen(&m_hStream, NULL, pwfxSrc, pwfxDst, NULL, 0, 0, 0);

        if (MMSYSERR_NOERROR != mmr)
        {
            Trace(1, "ERROR: Create (Viewport): Attempt to open a conversion stream failed.\n");
            LeaveCriticalSection(&m_CriticalSection);
            return MMRESULTToHRESULT(mmr);
        }

        mmr = acmStreamSize(m_hStream, cbSize, &cbSize, ACM_STREAMSIZEF_DESTINATION);

        if (MMSYSERR_NOERROR != mmr)
        {
            Trace(1, "ERROR: Create(Viewport): Could not convert target stream size to source format.\n");
            LeaveCriticalSection(&m_CriticalSection);
            return MMRESULTToHRESULT(mmr);
        }

        m_ash.cbSrcLength = cbSize;
        m_ash.pbSrc       = (LPBYTE)GlobalAllocPtr(GHND, cbSize);

        if (NULL == m_ash.pbSrc)
        {
            TraceI(1, "OUT OF MEMORY: CWaveViewPort:Create: GlobalAlloc failed.\n");
            LeaveCriticalSection(&m_CriticalSection);
            return E_OUTOFMEMORY;
        }

        // Also get the position for the actual start for the decompressed data
        if(m_dwDecompressedStart > 0)
        {
            m_dwDecompStartOffsetPCM = m_dwDecompressedStart * (pwfxDst->wBitsPerSample / 8) * pwfxDst->nChannels;
            mmr = acmStreamSize(m_hStream, m_dwDecompStartOffsetPCM, &m_dwDecompStartOffset, ACM_STREAMSIZEF_DESTINATION);
            
            DWORD dwDelta = 0;
            mmr = acmStreamSize(m_hStream, m_dwDecompStartOffset, &dwDelta, ACM_STREAMSIZEF_SOURCE);

            m_dwDecompStartDelta = m_dwDecompStartOffsetPCM - dwDelta;
            m_dwDecompStartOffset += m_dwStartPos;
        }

        //  For the source buffer, it is the full buffer size.
        m_ash.dwSrcUser       = m_ash.cbSrcLength;
        m_ash.cbSrcLengthUsed = m_ash.cbSrcLength;

        //  For the destination buffer, it is the offset into the buffer
        //  where the data can be found.
        m_ash.dwDstUser       = 0L;
        m_ash.cbDstLengthUsed = 0L;

        m_ash.cbStruct = sizeof(ACMSTREAMHEADER);

        mmr= acmStreamPrepareHeader(m_hStream, &m_ash, 0L);

        if (MMSYSERR_NOERROR != mmr)
        {
            Trace(1, "ERROR: Create (Viewport): Attempt to prepare header for conversion stream failed.\n");
            LeaveCriticalSection(&m_CriticalSection);
            return MMRESULTToHRESULT(mmr);
        }
    }

    LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dswave\stream.cpp ===
//	stream.cpp
// Copyright (C) 1997, 1998 Microsoft Corporation.  All Rights Reserved
//
// @doc EXTERNAL

#include <objbase.h>
#include <mmsystem.h>
#include <dsoundp.h>
#include "debug.h"

#include "dmusicc.h" 
#include "dmusici.h" 
#include "riff.h"
#include "dswave.h"

STDAPI AllocRIFFStream( IStream* pStream, IRIFFStream** ppRiff )
{
    if( ( *ppRiff = (IRIFFStream*) new CRIFFStream( pStream ) ) == NULL )
    {
        return E_OUTOFMEMORY;
    }
    return S_OK;
}


/* MyRead, MyWrite, MySeek
 *
 * These are functionally identical to mmioRead, mmioWrite, and mmioSeek,
 * except for the absence of the HMMIO parameter.
 */

long CRIFFStream::MyRead(void *pv, long cb)
{
    ULONG cbRead;
    if (FAILED(m_pStream->Read(pv, cb, &cbRead)))
        return -1;
    return cbRead;
}

long CRIFFStream::MyWrite(const void *pv, long cb)
{
    ULONG cbWritten;
    if (FAILED(m_pStream->Write(pv, cb, &cbWritten)))
        return -1;
    return cbWritten;
}

long CRIFFStream::MySeek(long lOffset, int iOrigin)
{
    LARGE_INTEGER   dlibSeekTo;
    ULARGE_INTEGER  dlibNewPos;

    dlibSeekTo.HighPart = 0;
    dlibSeekTo.LowPart = lOffset;
    if (FAILED(m_pStream->Seek(dlibSeekTo, iOrigin, &dlibNewPos)))
        return -1;

    return dlibNewPos.LowPart;
}


UINT CRIFFStream::Descend(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags)
{
    FOURCC          ckidFind;       // chunk ID to find (or NULL)
    FOURCC          fccTypeFind;    // form/list type to find (or NULL)

    /* figure out what chunk id and form/list type to search for */
    if (wFlags & MMIO_FINDCHUNK)
        ckidFind = lpck->ckid, fccTypeFind = NULL;
    else
    if (wFlags & MMIO_FINDRIFF)
        ckidFind = FOURCC_RIFF, fccTypeFind = lpck->fccType;
    else
    if (wFlags & MMIO_FINDLIST)
        ckidFind = FOURCC_LIST, fccTypeFind = lpck->fccType;
    else
        ckidFind = fccTypeFind = NULL;

    lpck->dwFlags = 0L;

    for(;;)
    {
        UINT        w;

        /* read the chunk header */
        if (MyRead(lpck, 2 * sizeof(DWORD)) !=
            2 * sizeof(DWORD))
        return MMIOERR_CHUNKNOTFOUND;
        FixBytes( FBT_LONG, &lpck->cksize );

        /* store the offset of the data part of the chunk */
        if ((lpck->dwDataOffset = MySeek(0L, SEEK_CUR)) == -1)
            return MMIOERR_CANNOTSEEK;

        /* see if the chunk is within the parent chunk (if given) */
        if ((lpckParent != NULL) &&
            (lpck->dwDataOffset - 8L >=
             lpckParent->dwDataOffset + lpckParent->cksize))
            return MMIOERR_CHUNKNOTFOUND;

        /* if the chunk if a 'RIFF' or 'LIST' chunk, read the
         * form type or list type
         */
        if ((lpck->ckid == FOURCC_RIFF) || (lpck->ckid == FOURCC_LIST))
        {
            if (MyRead(&lpck->fccType,
                     sizeof(DWORD)) != sizeof(DWORD))
                return MMIOERR_CHUNKNOTFOUND;
        }
        else
            lpck->fccType = NULL;

        /* if this is the chunk we're looking for, stop looking */
        if ( ((ckidFind == NULL) || (ckidFind == lpck->ckid)) &&
             ((fccTypeFind == NULL) || (fccTypeFind == lpck->fccType)) )
            break;

        /* ascend out of the chunk and try again */
        if ((w = Ascend(lpck, 0)) != 0)
            return w;
    }

    return 0;
}


UINT CRIFFStream::Ascend(LPMMCKINFO lpck, UINT /*wFlags*/)
{
    if (lpck->dwFlags & MMIO_DIRTY)
    {
        /* <lpck> refers to a chunk created by CreateChunk();
         * check that the chunk size that was written when
         * CreateChunk() was called is the real chunk size;
         * if not, fix it
         */
        LONG            lOffset;        // current offset in file
        LONG            lActualSize;    // actual size of chunk data

        if ((lOffset = MySeek(0L, SEEK_CUR)) == -1)
            return MMIOERR_CANNOTSEEK;
        if ((lActualSize = lOffset - lpck->dwDataOffset) < 0)
            return MMIOERR_CANNOTWRITE;

        if (LOWORD(lActualSize) & 1)
        {
            /* chunk size is odd -- write a null pad byte */
            if (MyWrite("\0", 1) != 1)
                return MMIOERR_CANNOTWRITE;

        }

        if (lpck->cksize == (DWORD)lActualSize)
            return 0;

        /* fix the chunk header */
        lpck->cksize = lActualSize;
        if (MySeek(lpck->dwDataOffset - sizeof(DWORD), SEEK_SET) == -1)
            return MMIOERR_CANNOTSEEK;
        FixBytes( FBT_LONG, &lpck->cksize );
        if (MyWrite(&lpck->cksize, sizeof(DWORD)) != sizeof(DWORD))  {
        	FixBytes( FBT_LONG, &lpck->cksize );
            return MMIOERR_CANNOTWRITE;
        }
        FixBytes( FBT_LONG, &lpck->cksize );
    }

    /* seek to the end of the chunk, past the null pad byte
     * (which is only there if chunk size is odd)
     */
    if (MySeek(lpck->dwDataOffset + lpck->cksize + (lpck->cksize & 1L),
            SEEK_SET) == -1)
        return MMIOERR_CANNOTSEEK;

    return 0;
}


UINT CRIFFStream::CreateChunk(LPMMCKINFO lpck, UINT wFlags)
{
    int             iBytes;         // bytes to write
    LONG            lOffset;        // current offset in file

    /* store the offset of the data part of the chunk */
    if ((lOffset = MySeek(0L, SEEK_CUR)) == -1)
        return MMIOERR_CANNOTSEEK;
    lpck->dwDataOffset = lOffset + 2 * sizeof(DWORD);

    /* figure out if a form/list type needs to be written */
    if (wFlags & MMIO_CREATERIFF)
        lpck->ckid = FOURCC_RIFF, iBytes = 3 * sizeof(DWORD);
    else
    if (wFlags & MMIO_CREATELIST)
        lpck->ckid = FOURCC_LIST, iBytes = 3 * sizeof(DWORD);
    else
        iBytes = 2 * sizeof(DWORD);

    /* write the chunk header */
	FixBytes( FBT_MMCKINFO, lpck );
    if (MyWrite(lpck, (LONG) iBytes) != (LONG) iBytes)  {
    	FixBytes( FBT_MMCKINFO, lpck );
        return MMIOERR_CANNOTWRITE;
    }
    FixBytes( FBT_MMCKINFO, lpck );

    lpck->dwFlags = MMIO_DIRTY;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dswave\riff.h ===
//
// riff.h
//

#include <objbase.h>

#ifndef __RIFF__
#define __RIFF__
#include <windows.h>
#include <mmsystem.h>
#define FixBytes(a1,a2)

// {0D5057E1-8889-11CF-B9DA-00AA00C08146}
DEFINE_GUID( IID_IRIFFStream, 0xd5057e1, 0x8889, 0x11cf, 0xb9, 0xda, 0x0, 0xaa, 0x0, 0xc0, 0x81, 0x46 );
#undef INTERFACE
#define INTERFACE IRIFFStream
DECLARE_INTERFACE_(IRIFFStream, IUnknown)
{
    // IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // IMKRIFFStream members
    STDMETHOD_(UINT, Descend)(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags) PURE;
    STDMETHOD_(UINT, Ascend)(LPMMCKINFO lpck, UINT wFlags) PURE;
    STDMETHOD_(UINT, CreateChunk)(LPMMCKINFO lpck, UINT wFlags) PURE;
    STDMETHOD(SetStream)(LPSTREAM pStream) PURE;
    STDMETHOD_(LPSTREAM, GetStream)() PURE;
};



struct CRIFFStream : IRIFFStream
{
///// object state
    ULONG       m_cRef;         // object reference count
    IStream*    m_pStream;      // stream to operate on

///// construction and destruction
    CRIFFStream(IStream* pStream)
    {
        m_cRef = 1;
		// replaced a call to SetStream with the following to avoid releasing an
		// unallocated stream
        m_pStream = pStream;
        if( m_pStream != NULL )
        {
            m_pStream->AddRef();
        }
    }
    ~CRIFFStream()
    {
        if( m_pStream != NULL )
        {
            m_pStream->Release();
        }
    }

///// IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj)
    {
        if( IsEqualIID( riid, IID_IUnknown ) ||
            IsEqualIID( riid, IID_IRIFFStream ) )
        {
            *ppvObj = (IRIFFStream*)this;
            AddRef();
            return NOERROR;
        }
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return ++m_cRef;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        if( --m_cRef == 0L )
        {
            delete this;
            return 0;
        }
        return m_cRef;
    }

// IAARIFFStream methods
    STDMETHODIMP_(UINT) Descend( LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags );
    STDMETHODIMP_(UINT) Ascend( LPMMCKINFO lpck, UINT wFlags );
    STDMETHODIMP_(UINT) CreateChunk( LPMMCKINFO lpck, UINT wFlags );
    STDMETHOD(SetStream)(LPSTREAM pStream)
    {
        if( m_pStream != NULL )
        {
            m_pStream->Release();
        }
        m_pStream = pStream;
        if( m_pStream != NULL )
        {
            m_pStream->AddRef();
        }
        return S_OK;
    }
    STDMETHOD_(LPSTREAM, GetStream)()
    {
        if( m_pStream != NULL )
        {
            m_pStream->AddRef();
        }
        return m_pStream;
    }

// private methods
    long MyRead( void *pv, long cb );
    long MyWrite( const void *pv, long cb );
    long MySeek( long lOffset, int iOrigin );
};
/*
// seeks to a 32-bit position in a stream.
HRESULT __inline StreamSeek( LPSTREAM pStream, long lSeekTo, DWORD dwOrigin )
{
	LARGE_INTEGER li;

	if( lSeekTo < 0 )
	{
		li.HighPart = -1;
	}
	else
	{
        li.HighPart = 0;
	}
	li.LowPart = lSeekTo;
	return pStream->Seek( li, dwOrigin, NULL );
}

// returns the current 32-bit position in a stream.
DWORD __inline StreamTell( LPSTREAM pStream )
{
	LARGE_INTEGER li;
    ULARGE_INTEGER ul;
#ifdef DBG
    HRESULT hr;
#endif

    li.HighPart = 0;
    li.LowPart = 0;
#ifdef DBG
    hr = pStream->Seek( li, STREAM_SEEK_CUR, &ul );
    if( FAILED( hr ) )
#else
    if( FAILED( pStream->Seek( li, STREAM_SEEK_CUR, &ul ) ) )
#endif
    {
        return 0;
    }
    return ul.LowPart;
}

// this function gets a long that is formatted the correct way
// i.e. the motorola way as opposed to the intel way
BOOL __inline GetMLong( LPSTREAM pStream, DWORD& dw )
{
    union uLong
	{
		unsigned char buf[4];
        DWORD dw;
	} u;
    unsigned char ch;

    if( FAILED( pStream->Read( u.buf, 4, NULL ) ) )
    {
        return FALSE;
    }

#ifndef _MAC
    // swap bytes
    ch = u.buf[0];
    u.buf[0] = u.buf[3];
    u.buf[3] = ch;

    ch = u.buf[1];
    u.buf[1] = u.buf[2];
    u.buf[2] = ch;
#endif

    dw = u.dw;
    return TRUE;
}

BOOL __inline IsGUIDZero( REFGUID guid )
{
    GUID g;

    memset( &g, 0, sizeof( g ) );
    return IsEqualGUID( g, guid );
}

// misc function prototypes

STDAPI AllocFileStream( LPCSTR szFileName, DWORD dwDesiredAccess, IStream **ppstream );
*/
STDAPI AllocRIFFStream( IStream* pStream, IRIFFStream** ppRiff );

#endif  // __RIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\dswave\waveutil.cpp ===
#include <windows.h>
#include <mmsystem.h>
#include "waveutil.h"


void CopyFormat
(
	LPWAVEFORMATEX 	pwfxDst,
	LPWAVEFORMATEX 	pwfxSrc
)
{
	DWORD	cbSize;

	cbSize = SIZEOFFORMAT(pwfxSrc);

	CopyMemory(pwfxDst, pwfxSrc, cbSize);
}

void CopyFormatEx
(
	LPWAVEFORMATEX 	pwfxDst,
	LPWAVEFORMATEX 	pwfxSrc
)
{
	DWORD	cbSize;

	cbSize = SIZEOFFORMATEX(pwfxSrc);

	CopyMemory(pwfxDst, pwfxSrc, cbSize);

	if (WAVE_FORMAT_PCM == pwfxDst->wFormatTag)
	{
		pwfxDst->cbSize = 0;
	}
}

BOOL FormatCmp
(
	LPWAVEFORMATEX 	pwfx1,
	LPWAVEFORMATEX 	pwfx2
)
{
	DWORD	cbSize;

	cbSize = SIZEOFFORMAT(pwfx1);

	if (cbSize != SIZEOFFORMAT(pwfx2))
	{
		return (FALSE);
	}
	else
	{
		LPBYTE	pb1 = (LPBYTE)pwfx1, pb2 = (LPBYTE)pwfx2;

		for (; cbSize; cbSize--)
		{
			if (pb1[cbSize - 1] != pb2[cbSize - 1])
			{
				return (FALSE);
			}
		}
	}

	return (TRUE);
}


DWORD DeinterleaveBuffers
(
	LPWAVEFORMATEX 	pwfx,
	LPBYTE 			pSrc,
	LPBYTE 			*ppbDst,
	DWORD 			cBuffers,
	DWORD 			cbSrcLength,
	DWORD 			dwOffset
)
{
	DWORD			ii;

	//	Note:  Right now, we don't deal with anything but PCM

	if (WAVE_FORMAT_PCM != pwfx->wFormatTag)
	{
		return (dwOffset);
	}

	if (1 == cBuffers)
	{
		LPBYTE	pDst = ppbDst[0];

		pDst += dwOffset;

		CopyMemory(pDst, pSrc, cbSrcLength);

		dwOffset += cbSrcLength;
		return (dwOffset);
	}

	if (8 == pwfx->wBitsPerSample)
	{
		if ( !cBuffers || (0 != (cbSrcLength % cBuffers)) )
		{
			//  Hmm... Buffer sizes don't line up!

			return (dwOffset);
		}

		for (; cbSrcLength; cbSrcLength -= cBuffers)
		{
			for (ii = 0; ii < cBuffers; ii++)
			{
				ppbDst[ii][dwOffset] = *pSrc++;
			}

			dwOffset++;
		}

		return (dwOffset);
	}
	else
	{
		PWORD	*ppwDst = (PWORD*)ppbDst;
		PWORD	pwSrc   = (PWORD)pSrc;

		//  Assuming 16-bit...

		if ( !cBuffers || (0 != (cbSrcLength % (cBuffers * 2))) || (0 != (dwOffset % sizeof(WORD))))
		{
			//	Hmm... Buffer sizes don't line up!

			return (0);
		}

		// Convert byte index into word index
		//
        dwOffset /= sizeof(WORD);            
		for (; cbSrcLength; cbSrcLength -= (2 * cBuffers))
		{
			for (ii = 0; ii < cBuffers; ii++)
			{
				ppwDst[ii][dwOffset] = *pwSrc++;
			}

			dwOffset++;
		}

		// Return byte index
		//
		dwOffset *= sizeof(WORD);

		return (dwOffset);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\shared\alist.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
// alist.h
//
#ifndef __ALIST_H__
#define __ALIST_H__

#include <windows.h>

class AListItem
{
public:
    AListItem() { m_pNext=NULL; };
    AListItem *GetNext() const {return m_pNext;};
    void SetNext(AListItem *pNext) {m_pNext=pNext;};
    LONG GetCount() const;
    AListItem* Cat(AListItem* pItem);
    AListItem* AddTail(AListItem* pItem) {return Cat(pItem);};
    AListItem* Remove(AListItem* pItem);
    AListItem* GetPrev(AListItem *pItem) const;
    AListItem* GetItem(LONG index);

protected:
    AListItem *m_pNext;
};

class AList
{
public:
    AList() {m_pHead=NULL;};
    AListItem *GetHead() const { return m_pHead;};

    void RemoveAll() { m_pHead=NULL;};
    LONG GetCount() const {return m_pHead->GetCount();}; 
    AListItem *GetItem(LONG index) { return m_pHead->GetItem(index);}; 
    void InsertBefore(AListItem *pItem,AListItem *pInsert);
    void Cat(AListItem *pItem) {m_pHead=m_pHead->Cat(pItem);};
    void Cat(AList *pList)
        {
//            assert(pList!=NULL);
            if (pList)
            {
                m_pHead=m_pHead->Cat(pList->GetHead());
            }
        };
    void AddHead(AListItem *pItem)
        {
            if (pItem!=NULL)
            {
                pItem->SetNext(m_pHead);
                m_pHead=pItem;
            }
        };
    void AddTail(AListItem *pItem);// {m_pHead=m_pHead->AddTail(pItem);};
    void Remove(AListItem *pItem) 
        {
            if (pItem != NULL)
            {
                m_pHead=m_pHead->Remove(pItem);
            }
        };
    AListItem *GetPrev(AListItem *pItem) const {return m_pHead->GetPrev(pItem);};
    AListItem *GetTail() const {return GetPrev(NULL);};
    BOOL IsEmpty(void) const {return (m_pHead==NULL);};
    BOOL IsMember(AListItem *pItem);
    AListItem *RemoveHead(void)
        {
            AListItem *li;
            li = m_pHead;
            if(m_pHead)
            {
                m_pHead = m_pHead->GetNext();
                li->SetNext(NULL);
            }
            return li;
        }
    void Reverse();

protected:
    AListItem *m_pHead;
};

#endif // __ALIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\shared\oledll.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
//
//
#ifndef _OLEDLL_
#define _OLEDLL_

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID);

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID);

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue);
				 
HRESULT CLSIDToStr(const CLSID &clsid,
				   TCHAR *szStr,
				   int cbStr);

HRESULT StrToCLSID(TCHAR *szStr,
				   CLSID &clsid,
				   int cbStr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\shared\dmusiccp.h ===
//
// dmusiccp.h
//
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Private interfaces

#ifndef _DMUSICCP_DOT_H_
#define _DMUSICCP_DOT_H_

#include <dsoundp.h>  // For IDirectSoundWave

// Interfaces/methods removed from Direct Music Core layer:

// IDirectMusicVoiceP
interface IDirectMusicVoiceP : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicVoiceP
	virtual HRESULT STDMETHODCALLTYPE Play(
         REFERENCE_TIME rtStart,                // Time to play
         LONG prPitch,                          // Initial pitch
         LONG vrVolume                          // Initial volume
        )=0;
    
	virtual HRESULT STDMETHODCALLTYPE Stop(
          REFERENCE_TIME rtStop                 // When to stop
        )=0;
};


// IDirectSoundDownloadedWaveP
interface IDirectSoundDownloadedWaveP : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectSoundDownloadedWaveP
};

// IDirectMusicPortP
interface IDirectMusicPortP : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicPortP
	virtual HRESULT STDMETHODCALLTYPE DownloadWave(
		IDirectSoundWave *pWave,                // Wave object
        IDirectSoundDownloadedWaveP **ppWave,   // Returned downloaded wave
        REFERENCE_TIME rtStartHint = 0          // Where we're likely to start
        )=0;
        
	virtual HRESULT STDMETHODCALLTYPE UnloadWave(
		IDirectSoundDownloadedWaveP *pWave      // Wave object
        )=0;
            
	virtual HRESULT STDMETHODCALLTYPE AllocVoice(
         IDirectSoundDownloadedWaveP *pWave,    // Wave to play on this voice
         DWORD dwChannel,                       // Channel and channel group
         DWORD dwChannelGroup,                  //  this voice will play on
         REFERENCE_TIME rtStart,                // Start position (stream only)
         SAMPLE_TIME stLoopStart,               // Loop start (one-shot only)
         SAMPLE_TIME stLoopEnd,                 // Loop end (one-shot only)
         IDirectMusicVoiceP **ppVoice           // Returned voice
        )=0;
        
	virtual HRESULT STDMETHODCALLTYPE AssignChannelToBuses(
		DWORD dwChannelGroup,                   // Channel group and
		DWORD dwChannel,                        // channel to assign
		LPDWORD pdwBuses,                       // Array of bus id's to assign
		DWORD cBusCount                         // Count of bus id's           
        )=0;
        
	virtual HRESULT STDMETHODCALLTYPE SetSink(
		IDirectSoundConnect *pSinkConnect       // From IDirectSoundPrivate::AllocSink
        )=0;
        
 	virtual HRESULT STDMETHODCALLTYPE GetSink(
		IDirectSoundConnect **ppSinkConnect     // The sink in use 
        )=0;
};

// GUIDs for new core layer private interfaces
DEFINE_GUID(IID_IDirectMusicVoiceP, 0x827ae928, 0xe44, 0x420d, 0x95, 0x24, 0x56, 0xf4, 0x93, 0x57, 0x8, 0xa6);
DEFINE_GUID(IID_IDirectSoundDownloadedWaveP, 0x3b527b6e, 0x5577, 0x4060, 0xb9, 0x6, 0xcd, 0x34, 0xa, 0x46, 0x71, 0x27);
DEFINE_GUID(IID_IDirectMusicPortP, 0x7048bcd8, 0x43fd, 0x4ca5, 0x93, 0x11, 0xf3, 0x24, 0x8f, 0xa, 0x25, 0x22);

// Class ID for synth sink. We pulled this from public headers since apps should never cocreate this.
DEFINE_GUID(CLSID_DirectMusicSynthSink,0xaec17ce3, 0xa514, 0x11d1, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);


#endif          // _DMUSICCP_DOT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\shared\dmscriptautguids.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declares the CLSIDs for creating the wrapper objects that implement the IDispatch
// interfaces for the various DirectMusic objects.  These CLSIDs are not public --
// they are only needed in the implementation of the DirectMusic objects.  A user of
// the IDispatch interface will get ahold of it by QueryInterface from the associated
// DirectMusic object.

#pragma once

DEFINE_GUID(CLSID_AutDirectMusicPerformance,		0xa861c6e2, 0xfcfc, 0x11d2, 0x8b, 0xc9, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); // {A861C6E2-FCFC-11d2-8BC9-00600893B1B6}
DEFINE_GUID(CLSID_AutDirectMusicSegment,			0x4062c116, 0x0270, 0x11d3, 0x8b, 0xcb, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); // {4062C116-0270-11d3-8BCB-00600893B1B6}
DEFINE_GUID(CLSID_AutDirectMusicSong,				0xa16f1761, 0xb6d8, 0x42eb, 0x8d, 0x57, 0x4a, 0x44, 0xfe, 0xdd, 0x3b, 0xd2);// {A16F1761-B6D8-42eb-8D57-4A44FEDD3BD2}
DEFINE_GUID(CLSID_AutDirectMusicSegmentState,		0xebf2320a, 0x2502, 0x11d3, 0x8b, 0xd1, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); // {EBF2320A-2502-11d3-8BD1-00600893B1B6}
DEFINE_GUID(CLSID_AutDirectMusicAudioPathConfig,	0x1cebde3e, 0x6b91, 0x484a, 0xaf, 0x48, 0x5e, 0x4f, 0x4e, 0xd6, 0xb1, 0xe1);// {1CEBDE3E-6B91-484a-AF48-5E4F4ED6B1E1}
DEFINE_GUID(CLSID_AutDirectMusicAudioPath,			0x2c5f9b72, 0x7148, 0x4d97, 0xbf, 0xc9, 0x68, 0xa0, 0xe0, 0x76, 0xbe, 0xbd);// {2C5F9B72-7148-4d97-BFC9-68A0E076BEBD}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\shared\miscutil.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Misc tiny helper functions.
//

#pragma once

// Releases a COM pointer and then sets it to NULL.  No effect if pointer already was NULL.
template<class T>
void SafeRelease(T *&t) { if (t) t->Release(); t = NULL; }

// Returns the number of elements in an array determined at compile time.
// Note: Only works for variables actually declared as arrays.  Don't try this with a pointer to an array.  There's no way to determine the size at that point.
#define ARRAY_SIZE(array) (sizeof(array) / sizeof(*(array)))

// Zeros memory of struct pointed to.
// Note: This is statically typed.  Don't use it with a pointer to void, pointer to an array, or a pointer to a base class because the size will be too small.
template<class T> void Zero(T *pT) { ZeroMemory(pT, sizeof(*pT)); }

// Zeros memory of the struct pointed to and sets its dwSize field.
template<class T> void ZeroAndSize(T *pT) { Zero(pT); pT->dwSize = sizeof(*pT); }

// Copies one dwSize struct to another dwSize struct without reading/writing beyond either struct
template<class T> void CopySizedStruct(T *ptDest, const T *ptSrc)
{
	assert(ptDest && ptSrc);
	DWORD dwDestSize = ptDest->dwSize;
	memcpy(ptDest, ptSrc, std::_cpp_min(ptDest->dwSize, ptSrc->dwSize));
	ptDest->dwSize = dwDestSize;
}

// Copy pwszSource to pwszDest where pwszDest is a buffer of size uiBufferSize.
// Returns S_OK if successful or DMUS_S_STRING_TRUNCATED if the string had to be truncated.
// Faster then wcsncpy for short strings because the entire buffer isn't padded with nulls.
inline HRESULT wcsTruncatedCopy(WCHAR *pwszDest, const WCHAR *pwszSource, UINT uiBufferSize)
{
    for (UINT i = 0; i < uiBufferSize; ++i)
    {
        if (!(pwszDest[i] = pwszSource[i])) // assign and check for null
            return S_OK; // the whole string copied
    }

    // string needs to be truncated
    pwszDest[uiBufferSize - 1] = L'\0';
    return DMUS_S_STRING_TRUNCATED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\shared\dmstrm.h ===
//
// dmstrm.h
// 
// Copyright (c) 1995-1998 Microsoft Corporation. All rights reserved.
//


#ifndef DMSTRM_H
#define DMSTRM_H

DEFINE_GUID(IID_IDMStream, 0x1894c260, 0xaa21, 0x11d1, 0x86, 0xbc, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);

DECLARE_INTERFACE_(IDMStream, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDMStream
	STDMETHOD(Init)					(THIS_ IStream* pStream) PURE;
    STDMETHOD(Descend)		(THIS_ LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags) PURE;
    STDMETHOD(Ascend)		(THIS_ LPMMCKINFO lpck, UINT wFlags) PURE;
    STDMETHOD(CreateChunk)	(THIS_ LPMMCKINFO lpck, UINT wFlags) PURE;
   	STDMETHOD(SetStream)			(THIS_ IStream* pIStream) PURE;
    STDMETHOD_(IStream*, GetStream)	(THIS) PURE;
};

STDAPI AllocDirectMusicStream(IStream* pIStream, IDMStream** ppIDMStream);

class CDirectMusicStream : public IDMStream
{
public:

    CDirectMusicStream();
    ~CDirectMusicStream();
 
	STDMETHODIMP Init(IStream* pStream);
	
	// IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDMStream
    STDMETHODIMP Descend(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags);
    STDMETHODIMP Ascend(LPMMCKINFO lpck, UINT wFlags);
    STDMETHODIMP CreateChunk(LPMMCKINFO lpck, UINT wFlags);

	STDMETHODIMP SetStream(IStream* pStream);
    STDMETHODIMP_(IStream*) GetStream();

private:
	long		m_cRef;         // object reference count
    IStream*    m_pStream;      // stream to operate on
};

// Macro to round up an odd size to RIFF 16 bit boundary.
#define RIFF_ALIGN(dwSize) (dwSize + (dwSize & 1))

typedef struct _RIFFIO
{
    FOURCC          ckid;           /* chunk ID */
    long            cksize;         /* chunk size */
    FOURCC          fccType;        /* form type or list type */
    long            lRead;          /* How much of this chunk has been read so far. */
    _RIFFIO *       pParent;        /* pointer to parent chunk */
    LARGE_INTEGER   liPosition;     /* Filled in by MarkPosition() when handing stream to another component. */
} RIFFIO;


class CRiffParser
{
public:
    CRiffParser(IStream *pStream);
    void        DebugOn() { m_fDebugOn = TRUE; } // Turns on tracing of parsing. Only available in debug builds.
    BOOL        NextChunk(HRESULT * pHr); // Does the work of LeaveChunk, MoreChunks, and EnterChunk in one call. 
    void        EnterList(RIFFIO *pChunk); // Descend into a new list.
    void        LeaveList();    // Pop out of the current list. 
    BOOL        MoreChunks();   // Returns true if there are more chunks to process in this LIST or RIFF.
    HRESULT     EnterChunk();   // Reads header of next chunk in this LIST or RIFF container.
    HRESULT     LeaveChunk();   // Move to the end of the current chunk in the LIST or RIFF.
    void        MarkPosition(); // Stores the absolute position of the start of the current chunk.
    HRESULT     SeekBack();     // Scan back to the beginning of the current chunk.
    HRESULT     SeekForward();  // Scan forward to the end of the current chunk.
    HRESULT     Read(void *pv,ULONG cb); // Reads data from stream. 
    HRESULT     Skip(ULONG ulBytes); // Seeks forward ulBytes.
    void        EnteringComponent() { m_fInComponent = true; } 
    BOOL        ComponentFailed() { return m_fComponentFailed; }
    IStream *   GetStream() { return m_pStream; }
private:
    BOOL        m_fDebugOn;     // Set true to turn tracing of parsing on. 
    BOOL        m_fFirstPass;   // Used by NextChunk to understand whether this is the first time in the list.
    IStream *   m_pStream;      // Stream to operate on. 
    RIFFIO *    m_pChunk;       // Current chunk that we are in. 
    RIFFIO *    m_pParent;      // Parent chunk of current chunk.
    long        m_lRead;        // How far we've read in the current chunk.
    BOOL        m_fComponentFailed; // Set true if a component failed to load, yet the file is okay.
    BOOL        m_fInComponent; // Set to true when inside a component's chunk.
};

#endif // #ifndef DMSTRM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\shared\dmstrm.cpp ===
//
// dmstrm.cpp
// 
// Copyright (c) 1995-2000 Microsoft Corporation
//

#include "debug.h"
#include "dmusicc.h"
#include "..\shared\dmstrm.h"
#include "..\shared\validate.h"

/////////////////////////////////////////////////////////////////////////////
// AllocDIrectMusicStream

STDAPI AllocDirectMusicStream(IStream* pIStream, IDMStream** ppIDMStream)
{
	if(pIStream == NULL || ppIDMStream == NULL)
	{
		return E_INVALIDARG;            
	}

	if((*ppIDMStream = (IDMStream*) new CDirectMusicStream()) == NULL)
    {
		return E_OUTOFMEMORY;
    }
	
	((CDirectMusicStream*)*ppIDMStream)->Init(pIStream);
    
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::CDirectMusicStream

CDirectMusicStream::CDirectMusicStream() :
m_cRef(1),
m_pStream(NULL)
{
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::~CDirectMusicStream
   
CDirectMusicStream::~CDirectMusicStream()
{
	if(m_pStream != NULL)
    {
		m_pStream->Release();
    }
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Init
   
STDMETHODIMP CDirectMusicStream::Init(IStream* pStream)
{
    SetStream(pStream);
	
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IUnknown

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::QueryInterface

STDMETHODIMP CDirectMusicStream::QueryInterface(const IID &iid, void **ppv)
{
	V_INAME(CDirectMusicStream::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

	if(iid == IID_IUnknown || iid == IID_IDMStream)
	{
		*ppv = static_cast<IDMStream*>(this);
    } 
	else 
	{
		*ppv = NULL;
		return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::AddRef

STDMETHODIMP_(ULONG) CDirectMusicStream::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Release

STDMETHODIMP_(ULONG) CDirectMusicStream::Release()
{
    if(!InterlockedDecrement(&m_cRef)) 
	{
		delete this;
		return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::SetStream

STDMETHODIMP CDirectMusicStream::SetStream(IStream* pStream)
{
    if(m_pStream != NULL)
    {
		m_pStream->Release();
    }

	m_pStream = pStream;
    
	if(m_pStream != NULL)
    {
		m_pStream->AddRef();
    }
    
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::GetStream

STDMETHODIMP_(IStream*) CDirectMusicStream::GetStream()
{
	if(m_pStream != NULL)
    {
		m_pStream->AddRef();
    }
    
	return m_pStream;
}

//////////////////////////////////////////////////////////////////////
// IDMStream

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Descend

STDMETHODIMP CDirectMusicStream::Descend(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags)
{
    assert(lpck);

	FOURCC ckidFind;           // Chunk ID to find (or NULL)
    FOURCC fccTypeFind;    // Form/list type to find (or NULL)

    // Figure out what chunk id and form/list type for which to search
    if(wFlags & MMIO_FINDCHUNK)
	{
		ckidFind = lpck->ckid;
		fccTypeFind = NULL;
	}
    else if(wFlags & MMIO_FINDRIFF)
    {
		ckidFind = FOURCC_RIFF;
		fccTypeFind = lpck->fccType;
    }
	else if(wFlags & MMIO_FINDLIST)
	{
		ckidFind = FOURCC_LIST;
		fccTypeFind = lpck->fccType;
	}
    else
    {
		ckidFind = fccTypeFind = NULL;
	}

    lpck->dwFlags = 0L;

    for(;;)
    {
		HRESULT hr;
		LARGE_INTEGER li;
		ULARGE_INTEGER uli;
		ULONG cbRead;

		// Read the chunk header
		hr = m_pStream->Read(lpck, 2 * sizeof(DWORD), &cbRead);

        if (FAILED(hr) || (cbRead != 2 * sizeof(DWORD)))
		{
            Trace(1,"Error: Unable to read file.\n");
			return DMUS_E_DESCEND_CHUNK_FAIL;
		}

		// Store the offset of the data part of the chunk
		li.QuadPart = 0;
		hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

		if(FAILED(hr))
		{
            Trace(1,"Error: Unable to read file.\n");
			return DMUS_E_CANNOTSEEK;
		}
		else
		{
			lpck->dwDataOffset = uli.LowPart;
		}

		// See if the chunk is within the parent chunk (if given)
		if((lpckParent != NULL) &&
		   (lpck->dwDataOffset - 8L >=
		   lpckParent->dwDataOffset + lpckParent->cksize))
		{
            Trace(1,"Error: Unable to read file.\n");
			return DMUS_E_DESCEND_CHUNK_FAIL;
		}

		// If the chunk is a 'RIFF' or 'LIST' chunk, read the
		// form type or list type
		if((lpck->ckid == FOURCC_RIFF) || (lpck->ckid == FOURCC_LIST))
		{

			ULONG cbRead;

			hr = m_pStream->Read(&lpck->fccType, sizeof(DWORD), &cbRead);

			if(FAILED(hr) || (cbRead != sizeof(DWORD)))
			{
                Trace(1,"Error: Unable to read file.\n");
				return DMUS_E_DESCEND_CHUNK_FAIL;
			}
		}
		else
		{
			lpck->fccType = NULL;
		}

		// If this is the chunk we're looking for, stop looking
		if(((ckidFind == NULL) || (ckidFind == lpck->ckid)) &&
		   ((fccTypeFind == NULL) || (fccTypeFind == lpck->fccType)))
		{
			break;
		}

		// Ascend out of the chunk and try again
		HRESULT w = Ascend(lpck, 0);
		if(FAILED(w))
		{
			return w;
		}
	}

    return S_OK;
}


//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Ascend

STDMETHODIMP CDirectMusicStream::Ascend(LPMMCKINFO lpck, UINT /*wFlags*/)
{
	assert(lpck);

    HRESULT hr;
	LARGE_INTEGER li;
	ULARGE_INTEGER uli;
	
	if (lpck->dwFlags & MMIO_DIRTY)
    {
		// <lpck> refers to a chunk created by CreateChunk();
		// check that the chunk size that was written when
		// CreateChunk() was called is the real chunk size;
		// if not, fix it
		LONG lOffset;           // current offset in file
		LONG lActualSize;   // actual size of chunk data

		li.QuadPart = 0;
		hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

		if(FAILED(hr))
		{
            Trace(1,"Error: Unable to write file.\n");
			return DMUS_E_CANNOTSEEK;
		}
		else
		{
			lOffset = uli.LowPart;
		}
		
		if((lActualSize = lOffset - lpck->dwDataOffset) < 0)
		{
            Trace(1,"Error: Unable to write file.\n");
			return DMUS_E_CANNOTWRITE;
		}

		if(LOWORD(lActualSize) & 1)
		{
			ULONG cbWritten;

			// Chunk size is odd -- write a null pad byte
			hr = m_pStream->Write("\0", 1, &cbWritten); 
			
			if(FAILED(hr) || cbWritten != 1)
			{
                Trace(1,"Error: Unable to write file.\n");
				return DMUS_E_CANNOTWRITE;
			}
		
		}
	
		if(lpck->cksize == (DWORD)lActualSize)
		{
			return S_OK;
		}

		// Fix the chunk header
		lpck->cksize = lActualSize;

		li.QuadPart = lpck->dwDataOffset - sizeof(DWORD);
		hr = m_pStream->Seek(li, STREAM_SEEK_SET, &uli);

		if(FAILED(hr))
		{
            Trace(1,"Error: Unable to write file.\n");
			return DMUS_E_CANNOTSEEK;
		}

		ULONG cbWritten;

		hr = m_pStream->Write(&lpck->cksize, sizeof(DWORD), &cbWritten); 
		
		if(FAILED(hr) || cbWritten != sizeof(DWORD))
		{
            Trace(1,"Error: Unable to write file.\n");
			return DMUS_E_CANNOTWRITE;
		}
    }

	// Seek to the end of the chunk, past the null pad byte
	// (which is only there if chunk size is odd)
	li.QuadPart = lpck->dwDataOffset + lpck->cksize + (lpck->cksize & 1L);
	hr = m_pStream->Seek(li, STREAM_SEEK_SET, &uli);

	if(FAILED(hr))
	{
        Trace(1,"Error: Unable to write file.\n");
		return DMUS_E_CANNOTSEEK;
	}

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::CreateChunk

STDMETHODIMP CDirectMusicStream::CreateChunk(LPMMCKINFO lpck, UINT wFlags)
{
	assert(lpck);

    UINT iBytes;    // Bytes to write
    LONG lOffset;   // Current offset in file

	// Store the offset of the data part of the chunk
	LARGE_INTEGER li;
	ULARGE_INTEGER uli;

	li.QuadPart = 0;
	HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

	if(FAILED(hr))
	{
        Trace(1,"Error: Unable to write file.\n");
		return DMUS_E_CANNOTSEEK;
	}
    else
	{
		lOffset = uli.LowPart;
	}
    
    lpck->dwDataOffset = lOffset + 2 * sizeof(DWORD);

    // figure out if a form/list type needs to be written
    if(wFlags & MMIO_CREATERIFF)
	{
		lpck->ckid = FOURCC_RIFF, iBytes = 3 * sizeof(DWORD);
    }
	else if(wFlags & MMIO_CREATELIST)
	{
		lpck->ckid = FOURCC_LIST, iBytes = 3 * sizeof(DWORD);
	}
    else
    {
		iBytes = 2 * sizeof(DWORD);
	}

    // Write the chunk header
	ULONG cbWritten;

	hr = m_pStream->Write(lpck, iBytes, &cbWritten); 
		
	if(FAILED(hr) || cbWritten != iBytes)
	{
        Trace(1,"Error: Unable to write file.\n");
		return DMUS_E_CANNOTWRITE;
	}

	lpck->dwFlags = MMIO_DIRTY;

    return S_OK;
}

CRiffParser::CRiffParser(IStream *pStream)

{
    assert(pStream);
    m_fDebugOn = FALSE;
    m_pStream = pStream; 
    m_pParent = NULL;
    m_pChunk = NULL;
    m_lRead = 0;
    m_fFirstPass = TRUE;
    m_fComponentFailed = FALSE;
    m_fInComponent = FALSE;
}

void CRiffParser::EnterList(RIFFIO *pChunk)

{
    assert (pChunk);
    pChunk->lRead = 0;
    pChunk->pParent = m_pChunk; // Previous chunk (could be NULL.)
    m_pParent = m_pChunk;
    m_pChunk = pChunk;
    m_fFirstPass = TRUE;
}

void CRiffParser::LeaveList()

{
    assert (m_pChunk);
    if (m_pChunk)
    {
        m_pChunk = m_pChunk->pParent;
        if (m_pChunk)
        {
            m_pParent = m_pChunk->pParent;
        }
    }
}

BOOL CRiffParser::NextChunk(HRESULT * pHr)

{
    BOOL fMore = FALSE;
    if (SUCCEEDED(*pHr))
    {
        // If this is the first time we've entered this list, there is no previous chunk.
        if (m_fFirstPass)
        {
            // Clear the flag.
            m_fFirstPass = FALSE;
        }
        else
        {
            // Clean up the previous pass.
            *pHr = LeaveChunk();
        }
        // Find out if there are more chunks to read.
        fMore = MoreChunks();
        // If so, and we don't have any failure, go ahead and read the next chunk header.
        if (fMore && SUCCEEDED(*pHr))
        {
            *pHr = EnterChunk();
        }
    }
    else
    {
#ifdef DBG
        char szName[5];
        if (m_fDebugOn)
        {
            szName[4] = 0;
            strncpy(szName,(char *)&m_pChunk->ckid,4);
            Trace(0,"Error parsing %s, Read %ld of %ld\n",szName,m_pChunk->lRead,RIFF_ALIGN(m_pChunk->cksize));
        }
#endif
        // If we were in a component, it's okay to fail. Mark that fact by setting
        // m_fComponentFailed then properly pull out of the chunk so we can
        // continue reading.
        if (m_fInComponent) 
        {
            m_fComponentFailed = TRUE;
            // We don't need to check for first pass, because we must have gotten
            // that far. Instead, we just clean up from the failed chunk.
            // Note that this sets the hresult to S_OK, which is what we want.
            // Later, the caller needs to call ComponentFailed() to find out if
            // this error occured.
            *pHr = LeaveChunk();
        }
        else
        {
            // Clean up but leave the error code.
            LeaveChunk();
        }
    }
    return fMore && SUCCEEDED(*pHr);
}

BOOL CRiffParser::MoreChunks()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        if (m_pParent)
        {
            // Return TRUE if there's enough room for another chunk.
            return (m_pParent->lRead < (m_pParent->cksize - 8));
        }
        else
        {
            // This must be a top level chunk, in which case there would only be one to read.
            return (m_pChunk->lRead == 0);
        }
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return false;
}

HRESULT CRiffParser::EnterChunk()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Read the chunk header
	    HRESULT hr = m_pStream->Read(m_pChunk, 2 * sizeof(DWORD), NULL);
        if (SUCCEEDED(hr))
        {
#ifdef DBG
            char szName[5];
            if (m_fDebugOn)
            {
                szName[4] = 0;
                strncpy(szName,(char *)&m_pChunk->ckid,4);
                ULARGE_INTEGER ul;
                LARGE_INTEGER li;
                li.QuadPart = 0;
                HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);

                Trace(0,"Entering %s, Length %ld, File position is %ld",szName,m_pChunk->cksize,(long)ul.QuadPart);
            }
#endif
            // Clear bytes read field.
            m_pChunk->lRead = 0;
            // Check to see if this is a container (LIST or RIFF.)
            if((m_pChunk->ckid == FOURCC_RIFF) || (m_pChunk->ckid == FOURCC_LIST))
		    {
			    hr = m_pStream->Read(&m_pChunk->fccType, sizeof(DWORD), NULL);
                if (SUCCEEDED(hr))
                {
                    m_pChunk->lRead += sizeof(DWORD);
#ifdef DBG
                    if (m_fDebugOn)
                    {
                        strncpy(szName,(char *)&m_pChunk->fccType,4);
                        Trace(0," Type %s",szName);
                    }
#endif
                }
                else
                {
                    Trace(1,"Error: Unable to read file.\n");
                }
		    }
#ifdef DBG
            if (m_fDebugOn) Trace(0,"\n");
#endif
        }
        else
        {
            Trace(1,"Error: Unable to read file.\n");
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::LeaveChunk()

{
    HRESULT hr = S_OK;
    assert(m_pChunk);
    if (m_pChunk)
    {
        m_fInComponent = false;
        // Get the rounded up size of the chunk.
        long lSize = RIFF_ALIGN(m_pChunk->cksize);
        // Increment the parent's count of bytes read so far.
        if (m_pParent)
        {
            m_pParent->lRead += lSize + (2 * sizeof(DWORD));
            if (m_pParent->lRead > RIFF_ALIGN(m_pParent->cksize))
            {
                Trace(1,"Error: Unable to read file.\n");
                hr = DMUS_E_DESCEND_CHUNK_FAIL; // Goofy error name, but need to be consistent with previous versions.
            }
        }
#ifdef DBG
        char szName[5];
        if (m_fDebugOn)
        {
            szName[4] = 0;
            strncpy(szName,(char *)&m_pChunk->ckid,4);
            ULARGE_INTEGER ul;
            LARGE_INTEGER li;
            li.QuadPart = 0;
            HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);

            Trace(0,"Leaving %s, Read %ld of %ld, File Position is %ld\n",szName,m_pChunk->lRead,lSize,(long)ul.QuadPart);
        }
#endif
        // If we haven't actually read this entire chunk, seek to the end of it.
        if (m_pChunk->lRead < lSize)
        {
            LARGE_INTEGER li;
            li.QuadPart = lSize - m_pChunk->lRead;
            hr = m_pStream->Seek(li,STREAM_SEEK_CUR,NULL);
            // There's a chance it could fail because we are at the end of file with an odd length chunk.
            if (FAILED(hr))
            {
                // If there's a parent, see if this is the last chunk.
                if (m_pParent)
                {
                    if (m_pParent->cksize >= (m_pParent->lRead - 1))
                    {
                        hr = S_OK;
                    }
                }
                // Else, see if we are an odd length.
                else if (m_pChunk->cksize & 1)
                {
                    hr = S_OK;
                }
            }
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::Read(void *pv,ULONG cb)

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Make sure we don't read beyond the end of the chunk.
        if (((long)cb + m_pChunk->lRead) > m_pChunk->cksize)
        {
            cb -= (cb - (m_pChunk->cksize - m_pChunk->lRead));
        }
        HRESULT hr = m_pStream->Read(pv,cb,NULL);
        if (SUCCEEDED(hr))
        {
            m_pChunk->lRead += cb;
        }
        else
        {
            Trace(1,"Error: Unable to read %ld bytes from file.\n",cb);
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::Skip(ULONG ulBytes)

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Make sure we don't scan beyond the end of the chunk.
        if (((long)ulBytes + m_pChunk->lRead) > m_pChunk->cksize)
        {
            ulBytes -= (ulBytes - (m_pChunk->cksize - m_pChunk->lRead));
        }
        LARGE_INTEGER li;
        li.HighPart = 0;
		li.LowPart = ulBytes;
        HRESULT hr = m_pStream->Seek( li, STREAM_SEEK_CUR, NULL );
        if (SUCCEEDED(hr))
        {
            m_pChunk->lRead += ulBytes;
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}


void CRiffParser::MarkPosition()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        LARGE_INTEGER li;
        ULARGE_INTEGER ul;
        li.HighPart = 0;
        li.LowPart = 0;
        m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
        m_pChunk->liPosition.QuadPart = (LONGLONG) ul.QuadPart;
    }
}

HRESULT CRiffParser::SeekBack()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Move back to the start of the current chunk. Also, store the
        // absolute position because that will be useful later when we need to seek to the
        // end of this chunk.
        ULARGE_INTEGER ul;
        LARGE_INTEGER li;
        li.QuadPart = 0;
        li.QuadPart -= (m_pChunk->lRead + (2 * sizeof(DWORD))); 
        HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
        // Now, save the absolute position for the end of this chunk.
        m_pChunk->liPosition.QuadPart = ul.QuadPart + 
            RIFF_ALIGN(m_pChunk->cksize) + (2 * sizeof(DWORD));
        m_pChunk->lRead = 0;
        return hr;
    }
    return E_FAIL;
}

HRESULT CRiffParser::SeekForward()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        m_pChunk->lRead = RIFF_ALIGN(m_pChunk->cksize);
        return m_pStream->Seek(m_pChunk->liPosition, STREAM_SEEK_SET, NULL);
    }
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\shared\dmusicp.h ===
//
// dmusicp.h
//
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Private interfaces

#ifndef _DMUSICP_DOT_H_
#define _DMUSICP_DOT_H_

#include <dmusicf.h>

// private guid for script track events
DEFINE_GUID(IID_CScriptTrackEvent, 0x8f42c9da, 0xd37a, 0x499c, 0x85, 0x82, 0x1a, 0x80, 0xeb, 0xf9, 0xb2, 0x3c);

// Stuff used in melody formulation that's currently either not implemented or hidden by Producer.

/* Used to get a playmode to be used for a melody (pParam points to a single byte) */
DEFINE_GUID(GUID_MelodyPlaymode, 0x288ea6ca, 0xaecc, 0x4327, 0x9f, 0x79, 0xfb, 0x46, 0x44, 0x37, 0x4a, 0x65);

#define DMUS_FRAGMENTF_ANTICIPATE      (0x1 << 3) /* Anticipate next chord */
#define DMUS_FRAGMENTF_INVERT          (0x1 << 4) /* Invert the fragment */
#define DMUS_FRAGMENTF_REVERSE         (0x1 << 5) /* Reverse the fragment */
#define DMUS_FRAGMENTF_SCALE           (0x1 << 6) /* Align MIDI values with scale intervals */
#define DMUS_FRAGMENTF_CHORD           (0x1 << 7) /* Align MIDI values with chord intervals */
#define DMUS_FRAGMENTF_USE_PLAYMODE    (0x1 << 8) /* Use playmode to compute MIDI values */

#define DMUS_CONNECTIONF_GHOST         0x1        /* Use ghost notes for transitions */

// flags used in ComposeSegmentFromTemplateEx
typedef enum enumDMUS_COMPOSE_TEMPLATEF_FLAGS
{
    DMUS_COMPOSE_TEMPLATEF_ACTIVITY    = 0x1, // Use activity level (dx7 default)
    DMUS_COMPOSE_TEMPLATEF_CLONE       = 0x2  // Clone a segment from the template (dx7 default)
} DMUS_COMPOSE_TEMPLATEF_FLAGS;

// Interfaces/methods removed from Direct Music Performance layer:

// IDirectMusicSegment8P
interface IDirectMusicSegment8P : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicSegment8P
	virtual HRESULT STDMETHODCALLTYPE GetObjectInPath(
		DWORD dwPChannel,    /* PChannel to search. */
		DWORD dwStage,       /* Which stage in the path. */
		DWORD dwBuffer,      /* Which buffer to address, if more than one. */
		REFGUID guidObject,  /* ClassID of object. */
		DWORD dwIndex,       /* Which object of that class. */
		REFGUID iidInterface,/* Requested COM interface. */
		void ** ppObject)=0; /* Pointer to interface. */
    virtual HRESULT STDMETHODCALLTYPE GetHeaderChunk(
        DWORD *pdwSize,      /* Size of passed header chunk. Also, returns size written. */
        DMUS_IO_SEGMENT_HEADER *pHeader)=0; /* Header chunk to fill. */
    virtual HRESULT STDMETHODCALLTYPE SetHeaderChunk(
        DWORD dwSize,        /* Size of passed header chunk. */
        DMUS_IO_SEGMENT_HEADER *pHeader)=0; /* Header chunk to fill. */
    virtual HRESULT STDMETHODCALLTYPE SetTrackPriority(
        REFGUID rguidTrackClassID,  /* ClassID of Track. */
        DWORD dwGroupBits,          /* Group bits. */
        DWORD dwIndex,              /* Nth track. */
        DWORD dwPriority) = 0;      /* Priority to set. */
    virtual HRESULT STDMETHODCALLTYPE SetAudioPathConfig(
        IUnknown *pAudioPathConfig) = 0; /* Audio path config, from file. */
};


// IDirectMusicComposer8P
interface IDirectMusicComposer8P : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicComposer8P
    // Use style to get embellishment lengths
	virtual HRESULT STDMETHODCALLTYPE ComposeTemplateFromShapeEx(
		WORD wNumMeasures,
		WORD wShape, 
		BOOL fIntro,
		BOOL fEnd,
		IDirectMusicStyle* pStyle, 
		IDirectMusicSegment** ppTemplate)=0;
    // New flags DWORD (discard activity level; compose in place)
    virtual HRESULT STDMETHODCALLTYPE ComposeSegmentFromTemplateEx(
        IDirectMusicStyle* pStyle, 
        IDirectMusicSegment* pTemplate, 
        DWORD dwFlags,
        DWORD dwActivity,
        IDirectMusicChordMap* pChordMap, 
        IDirectMusicSegment** ppSegment)=0;
};

//  IDirectMusicStyle8P
interface IDirectMusicStyle8P : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	//  IDirectMusicStyle8P
	virtual HRESULT STDMETHODCALLTYPE ComposeMelodyFromTemplate(
		IDirectMusicStyle* pStyle, 
		IDirectMusicSegment* pTemplate, 
        IDirectMusicSegment** ppSegment)=0;
};

// IDirectMusicLoader8P
interface IDirectMusicLoader8P : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicLoader8P
	virtual HRESULT STDMETHODCALLTYPE GetDynamicallyReferencedObject(
		IDirectMusicObject *pSourceObject,
		LPDMUS_OBJECTDESC pDesc,
		REFIID riid,
		LPVOID FAR *ppv)=0;
	virtual HRESULT STDMETHODCALLTYPE ReportDynamicallyReferencedObject(
		IDirectMusicObject *pSourceObject,
		IUnknown *pReferencedObject)=0;

	// These should probably never be exposed publicly.
	// Scripts hold a reference to the loader because they need to be able to inform it
	// when they set variables to reference DirectMusic objects the loader tracks for
	// garbage collection.  However, that would create a circular reference because the
	// loader also holds a reference to scripts in its cache.  Garbage collection can't break
	// a circular reference that the loader itself is involved in.  Instead we use these private
	// ref count methods.  When the app is no longer using the loader (public Release drops
	// to zero) then the loader can clear its cache.  This releases references to scripts
	// (and also to streams, which use the same technique), triggering them to do ReleaseP
	// and everything gets cleaned up.
	virtual ULONG STDMETHODCALLTYPE AddRefP() = 0;	// Private AddRef, for scripts.
	virtual ULONG STDMETHODCALLTYPE ReleaseP() = 0;	// Private Release, for scripts.
};

// IDirectMusicBandP
interface IDirectMusicBandP : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicBandP
	virtual HRESULT STDMETHODCALLTYPE DownloadEx(IUnknown *pAudioPath)=0; 
	virtual HRESULT STDMETHODCALLTYPE UnloadEx(IUnknown *pAudioPath)=0; 
};

// IDirectMusicObjectP
interface IDirectMusicObjectP : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicObjectP
	virtual void STDMETHODCALLTYPE Zombie()=0; 
};

// IDirectMusicPerformanceP
interface IDirectMusicPerformanceP : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicPerformanceP
    virtual HRESULT STDMETHODCALLTYPE GetPortAndFlags(DWORD dwPChannel,IDirectMusicPort **ppPort,DWORD * pdwFlags) = 0;
};

#define DM_PORTFLAGS_GM     1       /* Synth has GM set locally. */
#define DM_PORTFLAGS_GS     2       /* Synth has GS set locally. */
#define DM_PORTFLAGS_XG     4       /* Synth has XG set locally. */


// Private path stage to access the sink.
#define DMUS_PATH_SINK             0x5000      /* Access the DSound Sink interface. */

// GUIDs for new performance layer private interfaces
DEFINE_GUID(IID_IDirectMusicSegment8P, 0x4bd7fb35, 0x8253, 0x48e0, 0x90, 0x64, 0x8a, 0x20, 0x89, 0x82, 0x37, 0xcb);
DEFINE_GUID(IID_IDirectMusicComposer8P, 0xabaf70dc, 0xdfba, 0x4adf, 0xbf, 0xa9, 0x7b, 0x0, 0xe4, 0x19, 0xeb, 0xbb);
DEFINE_GUID(IID_IDirectMusicStyle8P, 0x2b7c5f39, 0x990a, 0x4fd7, 0x9b, 0x70, 0x1e, 0xa3, 0xde, 0x31, 0x55, 0xa5);
DEFINE_GUID(IID_IDirectMusicLoader8P, 0x3939facd, 0xf6ed, 0x4619, 0xbd, 0x16, 0x56, 0x60, 0x3f, 0x1, 0x51, 0xca);
DEFINE_GUID(IID_IDirectMusicBandP, 0xf2e00137, 0xa131, 0x4289, 0xaa, 0x6c, 0xa9, 0x60, 0x7d, 0x4, 0x85, 0xf5);
DEFINE_GUID(IID_IDirectMusicObjectP, 0x6a20c217, 0xeb3e, 0x40ec, 0x9f, 0x3a, 0x92, 0x5, 0x8, 0x70, 0x2b, 0x5e);
DEFINE_GUID(IID_IDirectMusicPerformanceP, 0xe583be58, 0xe93f, 0x4316, 0xbb, 0x6b, 0xcb, 0x2c, 0x71, 0x96, 0x40, 0x44);


/* DMUS_PMSGT_PRIVATE_TYPES fill the DMUS_PMSG's dwType member */
/* These start at 15000 in order to avoid conflicting with public DMUS_PMSGT_TYPES. */
typedef enum enumDMUS_PMSGT_PRIVATE_TYPES
{
    DMUS_PMSGT_SCRIPTTRACKERROR = 15000, /* Sent by the script track when an error occurs in the script. */
} DMUS_PMSGT_PRIVATE_TYPES;

/* DMUS_SCRIPT_TRACK_ERROR_PMSG */
/* These PMsgs are sent by the script track if there is a syntax error in a script it tries to connect to or
   if a routine it calls fails. */
typedef struct _DMUS_SCRIPT_TRACK_ERROR_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    DMUS_SCRIPT_ERRORINFO ErrorInfo; /* The error that occured.  Same as structure returned by IDirectMusicScript's Init and CallRoutine members. */
} DMUS_SCRIPT_TRACK_ERROR_PMSG;

/* Track param type guids */

/* Use (call SetParam on the script track) to turn on PMsgs (DMUS_SCRIPT_TRACK_ERROR_PMSG) the script track sends if there
   is a syntax error in the script it tries to connect to or if one of the routines it calls fails. */
DEFINE_GUID(GUID_EnableScriptTrackError,0x1cc7e0bf, 0x981c, 0x4b9f, 0xbe, 0x17, 0xd5, 0x72, 0xfc, 0x5f, 0xa9, 0x33); // {1CC7E0BF-981C-4b9f-BE17-D572FC5FA933}

#endif          // _DMUSICP_DOT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\shared\tlist.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       tlist.cpp
//
//--------------------------------------------------------------------------

//
// tlist.cpp
//

//#include "stdafx.h"
#include "tlist.h"

template <class T>
TListItem<T>::~TListItem()
{
	//if (m_pNext != NULL) { delete m_pNext; }
	// IMPORTANT: user of the list is required to delete content first!
	//ZeroMemory(&m_Tinfo, sizeof(T));
}

template <class T>
void TListItem<T>::Delete(TListItem<T>* pFirst)
{
	TListItem<T>* pScan = pFirst;
	TListItem<T>* pNext = NULL;
	while (pScan)
	{
		pNext = pScan->m_pNext;
		delete pScan;
		pScan = pNext;
	}
}

template <class T>
LONG TListItem<T>::GetCount(void) const
{
    LONG l;
    const TListItem<T> *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

template <class T>
TListItem<T>* TListItem<T>::Cat(TListItem<T> *pItem)
{
    TListItem<T> *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

template <class T>
TListItem<T>* TListItem<T>::Remove(TListItem<T> *pItem)
{
    TListItem<T> *li,*prev;

    if(pItem==this)
        return m_pNext;
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);
    return this;
}

template <class T>
TListItem<T>* TListItem<T>::GetPrev(TListItem<T> *pItem) const
{
    const TListItem<T> *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (TListItem<T>*)prev;
}

template <class T>
TListItem<T> * TListItem<T>::GetItem(LONG index)

{
	TListItem<T> *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) 
	{
		index--;
	}
	return (scan);
}

template <class T>
TListItem<T>* TListItem<T>::MergeSort(BOOL (* fcnCompare) (T&, T&))
{
	if (m_pNext != NULL)
	{
		TListItem<T> *pList1, *pList2;
		Divide(pList1, pList2);
		return pList1->MergeSort(fcnCompare)->Merge(pList2->MergeSort(fcnCompare), fcnCompare);
	}
	return this;
}

template <class T>
void TListItem<T>::Divide(TListItem<T>*& pHead1, TListItem<T>*& pHead2)
{
	TListItem<T> *pCurrent = this, *pTail1 = NULL, *pTail2 = NULL;
	do
	{
		pHead1 = pCurrent;
		pCurrent = pCurrent->m_pNext;
		pHead1->m_pNext = pTail1;
		pTail1 = pHead1;
		if (pCurrent != NULL)
		{
			pHead2 = pCurrent;
			pCurrent = pCurrent->m_pNext;
			pHead2->m_pNext = pTail2;
			pTail2 = pHead2;
		}
	} while (pCurrent != NULL);
}

template <class T>
TListItem<T>* TListItem<T>::Merge(TListItem<T>* pOtherList, BOOL (* fcnCompare) (T&, T&))
{
	if (!pOtherList) return this;
	TListItem<T>
		*pThisList = this, *pResultHead = NULL, *pResultTail = NULL, *pMergeItem = NULL;
	while (pThisList && pOtherList)
	{
		if ( fcnCompare(pThisList->m_Tinfo, pOtherList->m_Tinfo) )
		{
			pMergeItem = pThisList;
			pThisList = pThisList->GetNext();
		}
		else
		{
			pMergeItem = pOtherList;
			pOtherList = pOtherList->GetNext();
		}
		pMergeItem->SetNext(NULL);
		if (!pResultTail)
		{
			pResultHead = pResultTail = pMergeItem;
		}
		else
		{
			pResultTail->SetNext(pMergeItem);
			pResultTail = pMergeItem;
		}
	}
	if (pThisList) pResultTail->SetNext(pThisList);
	else pResultTail->SetNext(pOtherList);
	return pResultHead;
}

template <class T>
void TList<T>::InsertBefore(TListItem<T> *pItem,TListItem<T> *pInsert)

{
	TListItem<T> *prev = GetPrev(pItem);
	pInsert->SetNext(pItem);
	if (prev) prev->SetNext(pInsert);
	else m_pHead = pInsert;
}

template <class T>
void TList<T>::AddTail(TListItem<T> *pItem) 

{
	m_pHead = m_pHead->AddTail(pItem);
}

template <class T>
void TList<T>::MergeSort(BOOL (* fcnCompare) (T&, T&))
{
	if (m_pHead != NULL && m_pHead->GetNext() != NULL)
		m_pHead = m_pHead->MergeSort(fcnCompare);
}

template <class T>
void TList<T>::Reverse(void)
{
	if( m_pHead )
	{
		TListItem<T>* pNewHead = m_pHead;
		TListItem<T>* pNext = m_pHead->GetNext();
		pNewHead->SetNext(NULL);
		for( m_pHead = pNext; m_pHead; m_pHead = pNext )
		{
			pNext = m_pHead->GetNext();
			m_pHead->SetNext(pNewHead);
			pNewHead = m_pHead;
		}
		m_pHead = pNewHead;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\shared\smartref.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Simple helper classes that use the "resource acquisition is initialization" technique.
// In English, this means they acquire a reference to a resource and the resource is automatically
//    released in the destructor.
//

// This is particularly helpful if you are using exception handling or simulating it (painfully)
//    in OLE by putting "if (FAILED(hr)) return;" after every function call.  In such circumstances
//    it simpler if you know that the resource will be automatically freed no matter how you end
//    up exiting the function.
// Since we're not using exception handling, these classes do not throw.  If resource acquisition
//    could fail, be sure to check for the error before using the resource!
// Sometimes these helper classes are more than just simple wrappers for freeing the resource.
//    They may also provide useful methods that make it easier to perform operations on the resource.
// Everything here is enclosed in the SmartRef namespace.  Thus you can't refer to CritSec directly.
//    Instead you must say SmartRef::CritSec.

#pragma once
#include "debug.h"
#include "mmsystem.h"
#include "dmstrm.h"
#include "dmerror.h"
#include "dmusici.h"

// Place this in the private: section of a class to prevent use of the default C++ copy and assignment.
// Creates an error if someone later tries to use the automatic member-by-member copy that would be incorrect.
// Use this if you don't do the work to implement correct copying or if copying doesn't make sense for this class.
#define NOCOPYANDASSIGN(classname) classname(const classname &o); classname &operator= (const classname &o);

namespace SmartRef
{

	// Enters a critical section on contruction.  Leaves on destruction.
	class CritSec
	{
	public:
		CritSec(CRITICAL_SECTION *pCriticalSection) : m_pCriticalSection(pCriticalSection) { EnterCriticalSection(m_pCriticalSection); }
		~CritSec() { LeaveCriticalSection(m_pCriticalSection); }
	private:
		NOCOPYANDASSIGN(CritSec)
		CRITICAL_SECTION *m_pCriticalSection;
	};

	// Makes a copy of an ANSI string and frees it on destruction.
	// hungarian: astr
	class AString
	{
	public:
		AString(const WCHAR *psz) : m_psz(NULL) { this->AssignFromW(psz); }
		AString(const char *psz = NULL) : m_psz(NULL) { *this = psz; }
		AString(const char *psz, UINT cch); // take first cch characters of psz
		AString(const AString &str) : m_psz(NULL) { *this = str.m_psz; }
		~AString() { *this = NULL; }
		operator const char *() const { return m_psz; }
		AString &operator= (const char *psz);
		AString &operator= (const AString &str) { return *this = str.m_psz; }
		AString &Assign(const char *psz, UINT cch); // take first cch characters of psz
		AString &AssignFromW(const WCHAR *psz);

		char ** operator& () { assert(!m_psz); return &m_psz; } // allows direct setting of psz, adopting a string without copying it

	private:
		char *m_psz;
	};

	// Same as AString for Unicode strings.
	// Also accepts ANSI strings, converting them to Unicode.
	// hungarian: wstr
	class WString
	{
	public:
		WString(const char *psz) : m_psz(NULL) { this->AssignFromA(psz); }
		WString(const WCHAR *psz = NULL) : m_psz(NULL) { *this = psz; }
		WString(const WCHAR *psz, UINT cch) : m_psz(NULL) { this->Assign(psz, cch); }
		WString(const WString &str) : m_psz(NULL) { *this = str.m_psz; }
		~WString() { *this = static_cast<WCHAR *>(NULL); }
		operator const WCHAR *() const { return m_psz; }
		WString &operator= (const WCHAR *psz);
		WString &operator= (const WString &str) { return *this = str.m_psz; }
		WString &Assign(const WCHAR *psz, UINT cch); // take first cch characters of psz
		WString &AssignFromA(const char *psz);

		WCHAR ** operator& () { assert(!m_psz); return &m_psz; } // allows direct setting of psz, adopting a string without copying it

	private:
		WCHAR *m_psz;
	};

	// Allocates a writable buffer of a fixed size and frees it on destruction.
	// (For example, you could use a Buffer<char> to write a string into.)
	// hungarian: buf prefixed by type
	//            use abuf for Buffer<char> and wbuf for Buffer<WCHAR>
	template<class T>
	class Buffer
	{
	public:
		Buffer(UINT uiSize) { m_p = new T[uiSize + 1]; }
		~Buffer() { delete[] m_p; }
		operator T *() { return m_p; }

		// use to defer allocation (say, if you don't know the size at the declaration)
		Buffer() : m_p(NULL) {}
		void Alloc(UINT uiSize) { delete[] m_p; m_p = new T[uiSize + 1]; }
		T* disown() { T *_p = m_p; m_p = NULL; return _p; }
		T** operator& () { assert(!m_p); return &m_p; } // allows direct setting of m_p, adopting a string without copying it

	private:
		NOCOPYANDASSIGN(Buffer)
		T *m_p;
	};

	// Holds an array that grows automatically.
	// Doesn't throw so you must call AccessTo before using a position that might have required
	//    reallocation to ensure that memory didn't run out.
	// Values held in the vector must have value semantics so that they can be copied freely
	//    into reallocated memory slots.
	// hungarian: vec prefixed by type
	//            of just use svec (for smart vector) without specifying the type
	//            use avec for Vector<char> and wvec for Vector<WCHAR>
	template<class T>
	class Vector
	{
	public:
		Vector() : m_pT(NULL), m_size(0), m_capacity(0) {}
		~Vector() { delete[] m_pT; }
		UINT size() { return m_size; }
		operator bool() { return m_fFail; }
		bool AccessTo(UINT uiPos) { return Grow(uiPos + 1); }
		T& operator[](UINT uiPos) { assert(uiPos < m_size); return m_pT[uiPos]; }
		T* GetArray() { return m_pT; } // Danger: only use when needed and don't write past the end.
		void Shrink(UINT uiNewSize) { m_size = uiNewSize; } // Semantically shrinks -- doesn't actually free up any memory

	private:
		NOCOPYANDASSIGN(Vector)
		bool Grow(UINT size)
			{
				if (size > m_size)
				{
					if (size > m_capacity)
					{
						for (UINT capacity = m_capacity ? m_capacity : 1;
								capacity < size;
								capacity *= 2)
						{}
						T *pT = new T[capacity];
						if (!pT)
							return false;
						for (UINT i = 0; i < m_size; ++i)
							pT[i] = m_pT[i];
						delete[] m_pT;
						m_pT = pT;
						m_capacity = capacity;
					}
					m_size = size;
				}
				return true;
			}

		T *m_pT;
		UINT m_size;
		UINT m_capacity;
	};

	// Standard stack abstract data type.
	// Values held in the stack must have value semantics so that they can be copied freely
	//    into reallocated memory slots.
	// hungarian: stack prefixed by type
	template<class T>
	class Stack
	{
	public:
		Stack() : iTop(-1) {}
		bool empty() { return iTop < 0; }
		HRESULT push(const T& t) { if (!m_vec.AccessTo(iTop + 1)) return E_OUTOFMEMORY; m_vec[++iTop] = t; return S_OK; }
		T top() { if (empty()) {assert(false); return T();} return m_vec[iTop]; }
		void pop() { if (empty()) {assert(false); return;} --iTop; }

	private:
		Vector<T> m_vec;
		int iTop;
	};

	// Lookup table that maps keys to values.  Grows automatically as needed.
	// Type K (keys) must support operator =, operator ==. and a Hash function that returns an int.
	// Type V must support operator =.
	template <class K, class V>
	class Hash
	{
	public:
		Hash(HRESULT *phr, int iInitialSize = 2) : m_p(NULL), m_iCapacity(0), m_iSize(0) { *phr = Grow(iInitialSize); }
		~Hash() { delete[] m_p; }

		struct entry
		{
			V v;
			bool fFound() { return iHash != -1; }
		private:
			// only let the hash make them
			friend class Hash<K, V>;
			entry() : iHash(-1) {};
			entry(const entry &o); // disallowed copy constructor

			int iHash;
			K k;
		};

		entry &Find(K k) // if iHash is -1 then it wasn't found and you may immediately add the entry using Add().
		{
			assert(m_p);
			return HashTo(k.Hash(), k, m_p, m_iCapacity);
		}

		// Warning: no intervening additions may have occurred between the time e was returned by Find and the time Add(e, ...) is called.
		// Also k must be the same in both calls.  If you want to be crafty, "same" can be replaced with equivalence in terms of Hash and operator==.
		HRESULT Add(entry &e, K k, V v)
		{
			assert(!e.fFound());
			assert(&e == &Find(k));

			e.v = v;
			e.iHash = k.Hash();
			e.k = k;
			++m_iSize;
			if (m_iSize * 2 > m_iCapacity)
				return Grow(m_iCapacity * 2);
			return S_OK;
		}

		V &operator[](K k)
		{
			entry &e = Find(k);
			assert(e.fFound());
			return e.v;
		}

	private:
		HRESULT Grow(int iCapacity)
		{
#ifdef DBG
			// size must be at least 2 and a power of 2
			for (int iCheckSize = iCapacity; !(iCheckSize & 1); iCheckSize >>= 1)
			{}
			assert(iCapacity > 1 && iCheckSize == 1);
#endif

			// alloc new table
			entry *p = new entry[iCapacity];
			if (!p)
			{
				delete[] m_p;
				return E_OUTOFMEMORY;
			}

			// rehash everything into the larger table
			for (int i = 0; i < m_iCapacity; ++i)
			{
				entry &eSrc = m_p[i];
				if (eSrc.iHash != -1)
				{
					entry &eDst = HashTo(eSrc.iHash, eSrc.k, p, iCapacity);
					assert(eDst.iHash == -1);
					eDst = eSrc;
				}
			}

			delete[] m_p;
			m_p = p;
			m_iCapacity = iCapacity;
			return S_OK;
		}

		entry &HashTo(int iHash, K k, entry *p, int iCapacity)
		{
			// initial hash using modulus, then jump three slots at a time (3 is guaranteed to take us to all slots because capacity is a power of 2)
			assert(iHash >= 0);
			for (int i = iHash % iCapacity;
					p[i].iHash != -1 && (p[i].iHash != iHash || !(p[i].k == k)); // rehash while slot occupied or it doesn't match
					i = (i + 3) % iCapacity)
			{}
			return p[i];
		}
		
		entry *m_p;
		int m_iCapacity;
		int m_iSize;
	};

	// Holds the supplied pointer and frees it on destruction.
	// hungarian: sp (smart pointer)
	template <class T>
	class Ptr
	{
	public:
		Ptr(T *_p) : p(_p) {}
		~Ptr() { delete p; }
		operator T*() { return p; }
		T *operator->() { return p; }

		T* disown() { T *_p = p; p = NULL; return _p; }

	private:
		NOCOPYANDASSIGN(Ptr)
		T* p;
	};

	// Holds the supplied pointer to an array and frees it (with delete[]) on destruction.
	// hungarian: sprg
	template <class T>
	class PtrArray
	{
	public:
		PtrArray(T *_p) : p(_p) {}
		~PtrArray() { delete[] p; }
		operator T*() { return p; }

		T* disown() { T *_p = p; p = NULL; return _p; }

	private:
		NOCOPYANDASSIGN(PtrArray)
		T* p;
	};

	// Holds the supplied COM interface and releases it on destruction.
	// hungarian: scom
	template <class T>
	class ComPtr
	{
	public:
		ComPtr(T *_p = NULL) : p(_p) {}
		~ComPtr() { *this = NULL; }
		operator T*() { return p; }
		T* operator-> () { assert(p); return p; }
		ComPtr &operator= (T *_p) { if (p) p->Release(); p = _p; return *this; }
		T** operator& () { assert(!p); return &p; }

		void Release() { *this = NULL; }
		T* disown() { T *_p = p; p = NULL; return _p; }

	private:
		T* p;
	};

	// Holds the supplied registry key handle and closes it on destruction.
	// hungarian: shkey
	class HKey
	{
	public:
		HKey(HKEY hkey = NULL) : m_hkey(hkey) {}
		~HKey() { *this = NULL; }
		HKey &operator= (HKEY hkey) { if (m_hkey) ::RegCloseKey(m_hkey); m_hkey = hkey; return *this; }
		HKEY *operator& () { assert(!m_hkey); return &m_hkey; }
		operator HKEY() { return m_hkey; }

	private:
		NOCOPYANDASSIGN(HKey)
		HKEY m_hkey;
	};

	// Allocates and clears a one of the DMUS_*_PMSG structures.  You fill out its fields
	// and then call StampAndSend.  The message is automatically cleared after a successful
	// send or freed on destruction.  Be sure the check the hr function for failures.
	// hungarian: pmsg
	template <class T>
	class PMsg
	{
	public:
		T *p; // pointer to the message structure -- use to set the fields before sending
		PMsg(IDirectMusicPerformance *pPerf, UINT cbExtra = 0) // use cbExtra to allocate extra space in the structure, such as for DMUS_SYSEX_PMSG or DMUS_LYRIC_PMSG
		  : m_pPerf(pPerf), m_hr(S_OK), p(NULL)
		{
			const UINT cb = sizeof(T) + cbExtra;
			m_hr = m_pPerf->AllocPMsg(cb, reinterpret_cast<DMUS_PMSG**>(&p));
			if (SUCCEEDED(m_hr))
			{
				assert(p->dwSize == cb);
				ZeroMemory(p, cb);
				p->dwSize = cb;
			}
		}
		~PMsg() { if (p) m_pPerf->FreePMsg(reinterpret_cast<DMUS_PMSG*>(p)); }
		void StampAndSend(IDirectMusicGraph *pGraph)
		{
			m_hr = pGraph->StampPMsg(reinterpret_cast<DMUS_PMSG*>(p));
			if (FAILED(m_hr))
				return;

			m_hr = m_pPerf->SendPMsg(reinterpret_cast<DMUS_PMSG*>(p));
			if (SUCCEEDED(m_hr))
				p = NULL; // PMsg now owned by the performance
		}
		HRESULT hr() { return m_hr; }

	private:
		NOCOPYANDASSIGN(PMsg)
		IDirectMusicPerformance *m_pPerf; // weak ref
		HRESULT m_hr;
	};

	// Walks through the RIFF file structure held in a stream.  Releases it on destruction.
	// Although I found this to be quite useful, it a bit complicated.  You should look over
	//    the source or step through some examples before you use it.  Although I'm not positive
	//    this wouldn't work, it is not designed to have multiple RiffIter's walking over the
	//    same stream at once (see note in Descend).
	// hungarian: ri
	class RiffIter
	{
	public:
		enum RiffType { Riff, List, Chunk };

		RiffIter(IStream *pStream);
		~RiffIter();

		RiffIter &operator ++();
		RiffIter &Find(RiffType t, FOURCC id);
		HRESULT FindRequired(RiffType t, FOURCC id, HRESULT hrOnNotFound) { if (Find(t, id)) return S_OK; HRESULT _hr = hr(); return SUCCEEDED(_hr) ? hrOnNotFound : _hr; } // Attempts to find the expected chunk.  Returns S_OK if found, an error code if there was a problem reading, and hrOnNotFound if reading worked OK but the chunk simply wasn't there.

		// With Descend, use the returned iterator to process the children before resuming use of the parent.  Using both at once won't work.
		RiffIter Descend() { validate(); return RiffIter(*this, m_ckChild); }

		operator bool() const { return SUCCEEDED(m_hr); }
		HRESULT hr() const { return (m_hr == DMUS_E_DESCEND_CHUNK_FAIL) ? S_OK : m_hr; }

		RiffType type() const { validate(); return (m_ckChild.ckid == FOURCC_LIST) ? List : ((m_ckChild.ckid == FOURCC_RIFF) ? Riff : Chunk); }
		FOURCC id() const { validate(); return (type() == Chunk) ? m_ckChild.ckid : m_ckChild.fccType; }

		DWORD size() const { validate(); assert(type() == Chunk); return m_ckChild.cksize; }
		HRESULT ReadChunk(void *pv, UINT cb);
		HRESULT ReadArrayChunk(DWORD cbSize, void **ppv, int *pcRecords); // Reads an array chunk that is an array of records where the first DWORD gives the size of the records.  The records are copied into an array of records of size dwSize (filling with zero if the actual records in the file are smaller and ignoring additional fields if the actual records are larger).  ppv is set to return a pointer to this array, which the caller now owns and must delete.  pcRecords is set to the number of records returned.

		// Find the chunk (or return hrOnNoteFound). Load an object embedded in the stream. Then leaves the iterator on the next chunk.
		HRESULT FindAndGetEmbeddedObject(RiffType t, FOURCC id, HRESULT hrOnNotFound, IDirectMusicLoader *pLoader, REFCLSID rclsid, REFIID riid, LPVOID *ppv);

		// read specific RIFF structures
		HRESULT ReadReference(DMUS_OBJECTDESC *pDESC); // no need to init (zero, set size) the passed descriptor before calling
		HRESULT LoadReference(IDirectMusicLoader *pIDMLoader, const IID &iid, void **ppvObject)
		{
			DMUS_OBJECTDESC desc;
			HRESULT hr = ReadReference(&desc);
			if(SUCCEEDED(hr))
				hr = pIDMLoader->GetObject(&desc, iid, ppvObject);
			return hr;
		}

		struct ObjectInfo
		{
			ObjectInfo() { Clear(); }
			void Clear() { wszName[0] = L'\0'; guid = GUID_NULL; vVersion.dwVersionMS = 0; vVersion.dwVersionLS = 0; }

			WCHAR wszName[DMUS_MAX_NAME];
			GUID guid;
			DMUS_VERSION vVersion;
		};
		HRESULT LoadObjectInfo(ObjectInfo *pObjInfo, RiffType rtypeStop, FOURCC ridStop); // No need to init/zero. Reads from <guid-ck>, <vers-ck>, and <UNFO-list>/<UNAM-ck>. Stops at rtypeStop/ridStop, or returns E_FAIL if not found.

		HRESULT ReadText(WCHAR **ppwsz); // allocates a buffer and reads the current chunk--a NULL-terminated Unicode string--into it
		HRESULT ReadTextTrunc(WCHAR *pwsz, UINT cbBufSize); // reads only as much as it can fit in the buffer with a terminator

		// This is deliberately placed in the public section but never implemented in order to allow statements such as:
		//   SmartRef::RiffIter riChild = ri.Descend();
		// But it is never defined to prevent someone from trying to actually make two copies of a riffiter and then use them, which is not supported.
		// This would yield an unresolved symbol error:
		//   SmartRef::RiffIter riError = ri;
		// We don't allow general copying of RiffIters.  Only used to get the return value of Descend, where it is optimized away.
		RiffIter(const RiffIter &o);

	private:
		RiffIter &operator= (const RiffIter &o); // Also never defined -- don't allow assignment

		RiffIter(const RiffIter &other, MMCKINFO ckParent);
		bool validate() const { if (FAILED(m_hr)) { assert(false); return true; } else return false; }

		HRESULT m_hr;
		IStream *m_pIStream;
		IDMStream *m_pIDMStream;
		bool m_fParent;
		MMCKINFO m_ckParent;
		MMCKINFO m_ckChild;
	};

	// Templated ReadChunk typed helpers (templated member function wasn't working for me on current version of compiler)
	template <class T> HRESULT RiffIterReadChunk(RiffIter &ri, T *pT) { return ri.ReadChunk(pT, sizeof(*pT)); }
	template <class T> HRESULT RiffIterReadArrayChunk(RiffIter &ri, T **ppT, int *pcRecords) { return ri.ReadArrayChunk(sizeof(T), reinterpret_cast<void**>(ppT), pcRecords); }

}; // namespace SmartRef
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\shared\tlist.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       tlist.h
//
//--------------------------------------------------------------------------

//
// tlist.h --- template version of AList
//
#ifndef __TLIST_H__
#define __TLIST_H__

//#include "stdafx.h"

//template <class T>
//typedef BOOL (* TRelation) (T, T);

// TListItem<> contains four more members than AListItem: one additional constructor,
// a destructor, one member function, and one data member.
template <class T>
class TListItem
{
public:
    TListItem() { m_pNext=NULL; };
    ~TListItem();												// new destructor
	static void Delete(TListItem<T>* pFirst);                           // new deletion helper
    TListItem(const T& item) { m_Tinfo = item; m_pNext=NULL; };	// additional constructor.
    TListItem<T> *GetNext() const {return m_pNext;};
    void SetNext(TListItem<T> *pNext) {m_pNext=pNext;};
    LONG GetCount() const;
    TListItem<T>* Cat(TListItem<T>* pItem);
    TListItem<T>* AddTail(TListItem<T>* pItem) {return Cat(pItem);};
    TListItem<T>* Remove(TListItem<T>* pItem);
    TListItem<T>* GetPrev(TListItem<T> *pItem) const;
    TListItem<T>* GetItem(LONG index);
    T& GetItemValue() { return m_Tinfo; }  // additional member function
	TListItem<T>* MergeSort(BOOL (* fcnCompare) (T&, T&)); // Destructively mergeSorts the list items 
private:
	void Divide(TListItem<T>* &pHalf1, TListItem<T>* &pHalf2);
	TListItem<T>* Merge(TListItem<T>* pOtherList, BOOL (* fcnCompare) (T&, T&));
	T m_Tinfo;  // additional data member, but memory is the same since in AListItem 
				// you put the extra data member in the derived class 
    TListItem<T> *m_pNext;
};

// TList<> adds a destructor to AList.
template <class T>
class TList
{
public:
    TList() {m_pHead=NULL;}
	~TList()
	{ 
		//if (m_pHead != NULL) delete m_pHead;
		TListItem<T>::Delete(m_pHead);
	} // new destructor
    TListItem<T> *GetHead() const { return m_pHead;};

    void RemoveAll() { m_pHead=NULL;};
    void CleanUp() 
	{ 
		//if (m_pHead) delete m_pHead;
		if (m_pHead) TListItem<T>::Delete(m_pHead);
		m_pHead=NULL;
	}
    LONG GetCount() const {return m_pHead->GetCount();}; 
    TListItem<T> *GetItem(LONG index) { return m_pHead->GetItem(index);}; 
    void InsertBefore(TListItem<T> *pItem,TListItem<T> *pInsert);
    void Cat(TListItem<T> *pItem) {m_pHead=m_pHead->Cat(pItem);};
    void Cat(TList<T> *pList)
        {
//            assert(pList!=NULL);
            m_pHead=m_pHead->Cat(pList->GetHead());
        };
    void AddHead(TListItem<T> *pItem)
        {
//            assert(pItem!=NULL);
            pItem->SetNext(m_pHead);
            m_pHead=pItem;
        }
    void AddTail(TListItem<T> *pItem);// {m_pHead=m_pHead->AddTail(pItem);};
    void Remove(TListItem<T> *pItem) {m_pHead=m_pHead->Remove(pItem);};
    TListItem<T> *GetPrev(TListItem<T> *pItem) const {return m_pHead->GetPrev(pItem);};
    TListItem<T> *GetTail() const {return GetPrev(NULL);};
    BOOL IsEmpty(void) const {return (m_pHead==NULL);};
    TListItem<T> *RemoveHead(void)
        {
            TListItem<T> *li;
            li=m_pHead;
            if(m_pHead)
			{
                m_pHead=m_pHead->GetNext();
				li->SetNext(NULL);
			}
            return li;
        }
	void MergeSort(BOOL (* fcnCompare) (T&, T&)); // Destructively mergeSorts the list
	void Reverse(void); // Reverses the entire list

protected:
    TListItem<T> *m_pHead;
};

#include "tlist.cpp"

#endif // __TLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\shared\oledll.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// oledll.cpp
//
// Handle standard stuff for OLE server DLL
//
#include <objbase.h>
#include <iostream.h>

#include "oledll.h"

#ifdef UNICODE
#ifndef UNDER_CE
#error DirectMusic Win NT/9x must be compiled without UNICODE
#endif
#endif

static const TCHAR g_szCLSID[]           = TEXT("CLSID");
static const TCHAR g_szCLSIDSlash[]      = TEXT("CLSID\\");
static const TCHAR g_szInProc32[]        = TEXT("InProcServer32");
static const TCHAR g_szProgIDKey[]       = TEXT("ProgID");
static const TCHAR g_szVerIndProgIDKey[] = TEXT("VersionIndependentProgID");
static const TCHAR g_szCurVer[]          = TEXT("CurVer"); 
static const TCHAR g_szThreadingModel[]	= TEXT("ThreadingModel");
static const TCHAR g_szApartment[]		= TEXT("Apartment");

static const int CLSID_STRING_SIZE = 39;

static LONG RegSetDefValue(LPCTSTR pstrKey, LPCTSTR pstrSubkey, LPCTSTR pstrValueName, LPCTSTR pstrValue);
static void RegRemoveSubtree(HKEY hk, LPCTSTR pstrChild);

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    LONG lr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    TCHAR szModule[512];
    lr = ::GetModuleFileName(hModule, szModule, sizeof(szModule));

    lr = 0;

    lr |= RegSetDefValue(szClsKey, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szClsKey, g_szInProc32, NULL, szModule);
	lr |= RegSetDefValue(szClsKey, g_szInProc32, g_szThreadingModel, g_szApartment);
    lr |= RegSetDefValue(szClsKey, g_szProgIDKey, NULL, szProgID);
    lr |= RegSetDefValue(szClsKey, g_szVerIndProgIDKey, NULL, szVerIndProgID);

    lr |= RegSetDefValue(szVerIndProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szVerIndProgID, g_szCLSID, NULL, szCLSID);
    lr |= RegSetDefValue(szVerIndProgID, g_szCurVer, NULL, szProgID);
    
	lr |= RegSetDefValue(szProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szProgID, g_szCLSID, NULL, szCLSID);

#if 0 
    if (lr) {
        UnregisterServer(clsid,
                         szFriendlyName,
                         szVerIndProgID,
                         szProgID);
        // ???
        //
        return S_OK;
    }
#endif

    return S_OK;
}

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    RegRemoveSubtree(HKEY_CLASSES_ROOT, szClsKey);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szVerIndProgID);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szProgID);

    return S_OK;
}

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    HKEY hk;
	DWORD dw;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);
	lstrcat(szClsKey, TEXT("\\"));
	lstrcat(szClsKey, szKey);

	if (RegOpenKeyEx(HKEY_CLASSES_ROOT,
					 szClsKey,
					 0,
					 KEY_READ,
					 &hk)) {
		return FALSE;
	}

	if (RegQueryValueEx(hk,
						NULL,
						NULL,
						&dw,
						(LPBYTE)pValue,
						pcbValue)) {
		RegCloseKey(hk);
		return FALSE;
	}

	RegCloseKey(hk);
	
	return TRUE;
}

HRESULT
CLSIDToStr(const CLSID &clsid,
           TCHAR *szStr,
           int cbStr)
{
    
	LPOLESTR wszCLSID = NULL;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
    if (!SUCCEEDED(hr)) {
        return hr;
    }

#ifdef UNICODE
    lstrcpy(szStr, wszCLSID);
#else
	// Covert from wide characters to non-wide.
	wcstombs(szStr, wszCLSID, cbStr);
#endif

	// Free memory.
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

HRESULT
StrToCLSID(TCHAR *szStr,
		   CLSID &clsid,
		   int cbStr)
{
#ifdef UNICODE
    return CLSIDFromString(szStr, &clsid);
#else    
	WCHAR wsz[512];

	mbstowcs(wsz, szStr, cbStr);

	return CLSIDFromString(wsz, &clsid);
#endif
}
   

static LONG
RegSetDefValue(LPCTSTR pstrKey,
               LPCTSTR pstrSubkey,
			   LPCTSTR pstrValueName,
               LPCTSTR pstrValue)
{
    HKEY hk;
    LONG lr;
    TCHAR sz[1024];
    LPCTSTR pstr;

    if (!pstrSubkey) {
        pstr = pstrKey;
    } else {
        lstrcpy(sz, pstrKey);
        lstrcat(sz, TEXT("\\"));
        lstrcat(sz, pstrSubkey);
        pstr = sz;
    }

    lr = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                        pstr,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hk,
                        NULL);
    if (lr) {
        return lr;
    }

    lr = RegSetValueEx(hk,
                       pstrValueName,
                       0,
                       REG_SZ,
                       (CONST BYTE*)pstrValue,
                       1+lstrlen(pstrValue));
    RegCloseKey(hk);

    return lr;
}

static void
RegRemoveSubtree(HKEY hk,
                 LPCTSTR pstrChild)
{
    LONG lResult;
    HKEY hkChild;

    lResult = RegOpenKeyEx(hk,
                           pstrChild,
                           0,
                           KEY_ALL_ACCESS,
                           &hkChild);
    if (lResult) {
        return;
    }

#ifndef UNDER_CE    // CE doesn't support RegEnumKey()
    TCHAR szSubkey[256];

    // NOTE: Unlike regular enumeration, we always grab the 0th item
    // and delete it.
    //
    while (!RegEnumKey(hkChild, 0, szSubkey, sizeof(szSubkey))) {
        RegRemoveSubtree(hkChild, szSubkey);
    }
#endif    

    RegCloseKey(hkChild);
    RegDeleteKey(hk, pstrChild);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\shared\toolprops_i.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0328 */
/* at Wed Jun 07 15:59:39 2000
 */
/* Compiler settings for ..\toolprops.idl:
    Os (OptLev=s), W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_TOOLPROPSLib,0x2735B8F3,0xFF4A,0x4AF2,0x80,0x53,0xBE,0x22,0xC0,0xCA,0x32,0x32);


MIDL_DEFINE_GUID(CLSID, CLSID_EchoPage,0x5337AF8F,0x3827,0x44DD,0x9E,0xE9,0xAB,0x6E,0x1A,0xAB,0xB6,0x0F);


MIDL_DEFINE_GUID(CLSID, CLSID_TransposePage,0x691BD8C2,0x2B07,0x4C92,0xA8,0x2E,0x92,0xD8,0x58,0xDE,0x23,0xD6);


MIDL_DEFINE_GUID(CLSID, CLSID_DurationPage,0x79D9CAF8,0xDBDA,0x4560,0xA8,0xB0,0x07,0xE7,0x3A,0x79,0xFA,0x6B);


MIDL_DEFINE_GUID(CLSID, CLSID_QuantizePage,0x623286DC,0x67F8,0x4055,0xA9,0xBE,0xF7,0xA7,0x17,0x6B,0xD1,0x50);


MIDL_DEFINE_GUID(CLSID, CLSID_TimeShiftPage,0x7D3BDEE7,0x9557,0x4085,0x82,0xEE,0x1B,0x2F,0x02,0xCE,0x4B,0xA6);


MIDL_DEFINE_GUID(CLSID, CLSID_SwingPage,0x0B237E01,0x062A,0x4A40,0x8D,0x43,0x4B,0x5F,0xCD,0x49,0x96,0x5A);


MIDL_DEFINE_GUID(CLSID, CLSID_VelocityPage,0x30EC7213,0x64BE,0x4EF6,0xBB,0x1B,0x46,0x34,0x27,0xEC,0x86,0x4B);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0328 */
/* at Wed Jun 07 15:59:39 2000
 */
/* Compiler settings for ..\toolprops.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_TOOLPROPSLib,0x2735B8F3,0xFF4A,0x4AF2,0x80,0x53,0xBE,0x22,0xC0,0xCA,0x32,0x32);


MIDL_DEFINE_GUID(CLSID, CLSID_EchoPage,0x5337AF8F,0x3827,0x44DD,0x9E,0xE9,0xAB,0x6E,0x1A,0xAB,0xB6,0x0F);


MIDL_DEFINE_GUID(CLSID, CLSID_TransposePage,0x691BD8C2,0x2B07,0x4C92,0xA8,0x2E,0x92,0xD8,0x58,0xDE,0x23,0xD6);


MIDL_DEFINE_GUID(CLSID, CLSID_DurationPage,0x79D9CAF8,0xDBDA,0x4560,0xA8,0xB0,0x07,0xE7,0x3A,0x79,0xFA,0x6B);


MIDL_DEFINE_GUID(CLSID, CLSID_QuantizePage,0x623286DC,0x67F8,0x4055,0xA9,0xBE,0xF7,0xA7,0x17,0x6B,0xD1,0x50);


MIDL_DEFINE_GUID(CLSID, CLSID_TimeShiftPage,0x7D3BDEE7,0x9557,0x4085,0x82,0xEE,0x1B,0x2F,0x02,0xCE,0x4B,0xA6);


MIDL_DEFINE_GUID(CLSID, CLSID_SwingPage,0x0B237E01,0x062A,0x4A40,0x8D,0x43,0x4B,0x5F,0xCD,0x49,0x96,0x5A);


MIDL_DEFINE_GUID(CLSID, CLSID_VelocityPage,0x30EC7213,0x64BE,0x4EF6,0xBB,0x1B,0x46,0x34,0x27,0xEC,0x86,0x4B);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\shared\trackhelp.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Base classes that implement aspects of a standard DirectMusic track.
// Unless you're doing something pretty unusual, you should be able to inherit from one
//    of these classes and reduce the work needed to implement a new track type.
//
// * CBasicTrack
//    Contains stubs that no-op or return notimpl most track methods.
//    You implement Load, InitPlay, EndPlay, PlayMusicOrClock, and Clone.
//
// * CPlayingTrack
//    CBasicTrack plus standard implementations of InitPlay, EndPlay, Clone.
//    PlayMusicOrClock and Load are partially implemented.  You fill in the rest by implementing
//       the methods PlayItem and LoadRiff.
//    You also must implement classes for event items and (optionally) state data.

#pragma once

#include "dmusici.h"
#include "validate.h"
#include "miscutil.h"
#include "tlist.h"
#include "smartref.h"


const int gc_RefPerMil = 10000; // Value for converting from reference time to milliseconds


//////////////////////////////////////////////////////////////////////
// TrackHelpCreateInstance
// Standard implementation of CreateInstance to call from class factory templated on
// the type of your derived class.  Your class constructor must take an HRESULT pointer
// it can use to return an error.

template <class T>
HRESULT TrackHelpCreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv, T *pUnused = NULL)
{
	// 
	// pUnused is just a dummy to force generation of the correct template type T.
	// Compiler bug?

	*ppv = NULL;
	if (pUnknownOuter)
		 return CLASS_E_NOAGGREGATION;

	HRESULT hr = S_OK;
	T *pInst = new T(&hr);
	if (pInst == NULL)
		return E_OUTOFMEMORY;
	if (FAILED(hr))
		return hr;

	return pInst->QueryInterface(iid, ppv);
}

//////////////////////////////////////////////////////////////////////
// CBasicTrack
//
// Base class with a standard implementation the following aspects of a DirectMusic track:
// - IUnknown: AddRef, Release, and QueryInterface (QI for IUnknown, IDirectMusicTrack, IDirectMusicTrack8, IPersistStream, IPersist)
// - IPersistStrea: stubs out GetClassID, IsDirty, Save, and GetSizeMax.
// - IDirectMusicTrack:
//      stubs out IsParamSupported, Init, GetParam, SetParam, AddNotificationType, RemoveNotificationType.
//      implements millisecond time conversion for PlayEx, GetParamEx, SetParamEx.
// - Declares and initializes a critical section.
//
// Pure virtual functions you must implement:
// - Load
// - InitPlay
// - EndPlay
// - Clone
// - PlayMusicOrClock (single method called by both Play and PlayEx)

class CBasicTrack
  : public IPersistStream,
	public IDirectMusicTrack8
{
public:
	// IUnknown
	STDMETHOD(QueryInterface)(const IID &iid, void **ppv);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	// IPersistStream functions
	STDMETHOD(GetClassID)(CLSID* pClassID);
	STDMETHOD(IsDirty)() {return S_FALSE;}
	STDMETHOD(Load)(IStream* pStream) = 0;
	STDMETHOD(Save)(IStream* pStream, BOOL fClearDirty) {return E_NOTIMPL;}
	STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pcbSize) {return E_NOTIMPL;}

	// IDirectMusicTrack methods
	STDMETHOD(IsParamSupported)(REFGUID rguid) {return DMUS_E_TYPE_UNSUPPORTED;}
	STDMETHOD(Init)(IDirectMusicSegment *pSegment);
	STDMETHOD(InitPlay)(
		IDirectMusicSegmentState *pSegmentState,
		IDirectMusicPerformance *pPerformance,
		void **ppStateData,
		DWORD dwTrackID,
		DWORD dwFlags) = 0;
	STDMETHOD(EndPlay)(void *pStateData) = 0;
	STDMETHOD(Play)(
		void *pStateData,
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		MUSIC_TIME mtOffset,
		DWORD dwFlags,
		IDirectMusicPerformance* pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID);
	STDMETHOD(GetParam)(REFGUID rguid,MUSIC_TIME mtTime,MUSIC_TIME* pmtNext,void *pData) {return DMUS_E_GET_UNSUPPORTED;}
	STDMETHOD(SetParam)(REFGUID rguid,MUSIC_TIME mtTime,void *pData) {return DMUS_E_SET_UNSUPPORTED;}
	STDMETHOD(AddNotificationType)(REFGUID rguidNotification) {return E_NOTIMPL;}
	STDMETHOD(RemoveNotificationType)(REFGUID rguidNotification) {return E_NOTIMPL;}
	STDMETHOD(Clone)(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicTrack** ppTrack) = 0;

	// IDirectMusicTrack8
	STDMETHODIMP PlayEx(
		void* pStateData,
		REFERENCE_TIME rtStart,
		REFERENCE_TIME rtEnd,
		REFERENCE_TIME rtOffset,
		DWORD dwFlags,
		IDirectMusicPerformance* pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID);
	STDMETHODIMP GetParamEx(REFGUID rguidType, REFERENCE_TIME rtTime, REFERENCE_TIME* prtNext, void* pParam, void * pStateData, DWORD dwFlags);
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;

protected:
	// plModuleLockCounter: a pointer to your .dll's lock counter that will be incremented/decremented when the track is created/destroyed
	// rclsid: the classid of your track
	CBasicTrack(long *plModuleLockCounter, const CLSID &rclsid); // Takes pointer to lock counter to increment and decrement on component creation/destruction.  Typically, pass &g_cComponent and the clsid of your track.
	virtual ~CBasicTrack() { InterlockedDecrement(m_plModuleLockCounter); }

	// Shared implentation of play for either music or clock time.
	virtual HRESULT PlayMusicOrClock(
		void *pStateData,
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		MUSIC_TIME mtOffset,
		REFERENCE_TIME rtOffset,
		DWORD dwFlags,
		IDirectMusicPerformance* pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID,
		bool fClockTime) = 0;

	// Use this critical section to guard entry points for thread safety
	CRITICAL_SECTION m_CriticalSection;

private:
	long m_cRef;
	long *m_plModuleLockCounter;
	const CLSID &m_rclsid;
};

//////////////////////////////////////////////////////////////////////
// CPlayingTrack
//
// Base class that provides standard implementations of InitPlay, EndPlay, and Clone.
// Also, partially implemented are:
//  - PlayMusicOrClock.  You must implement the pure virual function PlayItem, which is
//    called during play as each event needs to be performed.
//  - Load.  This just does a few standard things (clearing the event list, incrementing the
//    state data counter, optionally getting the loader, and sorting the results).  It
//    depends on your implementation of the pure virtual function LoadRiff that you must
//    implement to do the real processing.
// Template types required:
//    T: Your derived class (needed for New in clone).  Must have a constructor that takes a pointer to an HRESULT.
//    StateData: Type for your state data.  Must contain dwValidate, used to check if the track has been reloaded, and pCurrentEvent, a pointer to the next event item to be played.
//    EventItem: Type for the event items in your track.  Must contain lTriggerTime, which is the time during Play when PlayItem will be called.  Must implement Clone, which copies another EventItem, shifting it back according to a start MUSIC_TIME.

// Standard state data for use with CPlayingTrack.  Or inherit from it and add more information.
template<class EventItem>
struct CStandardStateData
{
	CStandardStateData() : dwValidate(0), pCurrentEvent(NULL) {}
	DWORD dwValidate;
	TListItem<EventItem> *pCurrentEvent;
};

template<class T, class EventItem, class StateData = CStandardStateData<EventItem> >
class CPlayingTrack
  : public CBasicTrack
{
public:
	typedef StateData statedata;

	STDMETHOD(Load)(IStream* pIStream);
	STDMETHOD(InitPlay)(
		IDirectMusicSegmentState *pSegmentState,
		IDirectMusicPerformance *pPerformance,
		void **ppStateData,
		DWORD dwTrackID,
		DWORD dwFlags);
	STDMETHOD(EndPlay)(void *pStateData);
	STDMETHOD(Clone)(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicTrack** ppTrack);
	virtual HRESULT PlayMusicOrClock(
		void *pStateData,
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		MUSIC_TIME mtOffset,
		REFERENCE_TIME rtOffset,
		DWORD dwFlags,
		IDirectMusicPerformance* pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID,
		bool fClockTime);

protected:
	// plModuleLockCounter: a pointer to your .dll's lock counter that will be incremented/decremented when the track is created/destroyed
	// rclsid: the classid of your track
	// fNeedsLoader: pass true if you will need a reference to the loader when your LoadRiff method is called
	// fPlayInvalidations: if true, then your items will be played more than once when an invalidation occurs
	//						pass false if your track doesn't want to respond to invalidations
	CPlayingTrack(long *plModuleLockCounter, const CLSID &rclsid, bool fNeedsLoader, bool fPlayInvalidations);

	virtual HRESULT PlayItem(
		const EventItem &item,
		StateData &state,
		IDirectMusicPerformance *pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID,
		MUSIC_TIME mtOffset,
		REFERENCE_TIME rtOffset,
		bool fClockTime) = 0; // feel free to add additional parameters if you need to pass more information from Play
	virtual HRESULT LoadRiff(SmartRef::RiffIter &ri, IDirectMusicLoader *pIDMLoader) = 0; // note that pIDMLoader will be null unless true is passed for fNeedsLoader in constructor

	virtual TListItem<EventItem> *Seek(MUSIC_TIME mtStart); // this method is provided in case you want to inherit and intercept when a seek is happening

	// Increment this counter in Load, causing the state data to synchonize with the new events
	DWORD m_dwValidate;
	TList<EventItem> m_EventList;
	bool m_fNeedsLoader;
	bool m_fPlayInvalidations;
};

#include "trackhelp.inl"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\shared\trackhelp.inl ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Base classes that implement aspects of a standard DirectMusic track.
// Implementations for CPlayingTrack.
//

//////////////////////////////////////////////////////////////////////
// Creation

template<class T, class EventItem, class StateData>
CPlayingTrack<T, EventItem, StateData>::CPlayingTrack(
		long *plModuleLockCounter,
		const CLSID &rclsid,
		bool fNeedsLoader,
		bool fPlayInvalidations)
  : m_dwValidate(0),
	m_fNeedsLoader(fNeedsLoader),
	m_fPlayInvalidations(fPlayInvalidations),
	CBasicTrack(plModuleLockCounter, rclsid)
{
}

//////////////////////////////////////////////////////////////////////
// IPersistStream

// Function used to sort the event list according to trigger time.
template<class EventItem>
struct CmpStruct //  shouldn't need this, but I had trouble getting a straight templated function to match the function pointer with the NT compiler.  try again later with the new one.
{
	static BOOL EventCompare(EventItem &ri1, EventItem &ri2)
	{
		return ri1.lTriggerTime < ri2.lTriggerTime;
	}
};

template<class T, class EventItem, class StateData>
STDMETHODIMP
CPlayingTrack<T, EventItem, StateData>::Load(IStream* pIStream)
{
	V_INAME(CPlayingTrack::Load);
	V_INTERFACE(pIStream);
	HRESULT hr = S_OK;

	SmartRef::CritSec CS(&m_CriticalSection);

	// Clear the event list in case we're being reloaded.
	m_EventList.CleanUp();
	// Increment counter so the next play will update state data with the new list.
	++m_dwValidate;

	// Get the loader if requested in constructor
	SmartRef::ComPtr<IDirectMusicLoader> scomLoader;
	if (m_fNeedsLoader)
	{
		IDirectMusicGetLoader *pIGetLoader;
		hr = pIStream->QueryInterface(IID_IDirectMusicGetLoader, reinterpret_cast<void**>(&pIGetLoader));
		if (FAILED(hr))
			return hr;
		hr = pIGetLoader->GetLoader(&scomLoader);
		pIGetLoader->Release();
		if (FAILED(hr))
			return hr;
	}

	SmartRef::RiffIter ri(pIStream);
	if (!ri)
		return ri.hr();

	hr = this->LoadRiff(ri, scomLoader);
	if (FAILED(hr))
		return hr;

	m_EventList.MergeSort(CmpStruct<EventItem>::EventCompare);

	return hr;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack

template<class T, class EventItem, class StateData>
STDMETHODIMP
CPlayingTrack<T, EventItem, StateData>::InitPlay(
		IDirectMusicSegmentState *pSegmentState,
		IDirectMusicPerformance *pPerformance,
		void **ppStateData,
		DWORD dwTrackID,
		DWORD dwFlags)
{
	V_INAME(CPlayingTrack::InitPlay);
	V_PTRPTR_WRITE(ppStateData);
	V_INTERFACE(pSegmentState);
	V_INTERFACE(pPerformance);

	SmartRef::CritSec CS(&m_CriticalSection);

	// Set up state data
	StateData *pStateData = new StateData;
	if (!pStateData)
		return E_OUTOFMEMORY;

	*ppStateData = pStateData;

	return S_OK;
}

template<class T, class EventItem, class StateData>
STDMETHODIMP
CPlayingTrack<T, EventItem, StateData>::EndPlay(void *pStateData)
{
	V_INAME(CPlayingTrack::EndPlay);
	V_BUFPTR_WRITE(pStateData, sizeof(StateData));

	SmartRef::CritSec CS(&m_CriticalSection);

	StateData *pSD = static_cast<StateData *>(pStateData);
	delete pSD;

	return S_OK;
}

template<class T, class EventItem, class StateData>
STDMETHODIMP
CPlayingTrack<T, EventItem, StateData>::Clone(
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		IDirectMusicTrack** ppTrack)
{
	V_INAME(CPlayingTrack::Clone);
	V_PTRPTR_WRITE(ppTrack);

	SmartRef::CritSec CS(&m_CriticalSection);

	HRESULT hr = S_OK;

	T *pTrack = new T(&hr);
	if (FAILED(hr))
		return hr;
	*ppTrack = pTrack;
	if (!pTrack)
		return E_OUTOFMEMORY;

	pTrack->AddRef();
	for (TListItem<EventItem> *pItem = m_EventList.GetHead();
			pItem;
			pItem = pItem->GetNext())
	{
		EventItem &ritem = pItem->GetItemValue();
		if (ritem.lTriggerTime >= mtEnd)
			break;
		if (ritem.lTriggerTime < mtStart)
			continue;

		TListItem<EventItem> *pNewItem = new TListItem<EventItem>;
		if (!pNewItem)
		{
			hr = E_OUTOFMEMORY;
			goto End;
		}

		EventItem &rnew = pNewItem->GetItemValue();
		hr = rnew.Clone(ritem, mtStart);
		if (FAILED(hr))
		{
			delete pNewItem;
			goto End;
		}
		pTrack->m_EventList.AddHead(pNewItem);
	}
	pTrack->m_EventList.Reverse();
	++pTrack->m_dwValidate;

End:
	if (FAILED(hr))
		pTrack->Release();
	return hr;
}

template<class T, class EventItem, class StateData>
HRESULT
CPlayingTrack<T, EventItem, StateData>::PlayMusicOrClock(
	void *pStateData,
	MUSIC_TIME mtStart,
	MUSIC_TIME mtEnd,
	MUSIC_TIME mtOffset,
	REFERENCE_TIME rtOffset,
	DWORD dwFlags,
	IDirectMusicPerformance* pPerf,
	IDirectMusicSegmentState* pSegSt,
	DWORD dwVirtualID,
	bool fClockTime)
{
	V_INAME(CPlayingTrack::Play);
	V_BUFPTR_WRITE( pStateData, sizeof(StateData));
	V_INTERFACE(pPerf);
	V_INTERFACE(pSegSt);

	if (dwFlags & DMUS_TRACKF_PLAY_OFF)
		return S_OK;

	SmartRef::CritSec CS(&m_CriticalSection);

	StateData *pSD = static_cast<StateData *>(pStateData);
	TListItem<EventItem> *li = pSD->pCurrentEvent;

	// Seek through the event list to find the proper first event if
	// the event list pointed to by the state data has been reloaded
	// or if playback has made a jump to a different position in the track.
	if (m_dwValidate != pSD->dwValidate ||
			dwFlags & (DMUS_TRACKF_SEEK | DMUS_TRACKF_LOOP | DMUS_TRACKF_FLUSH))
	{
		assert(m_dwValidate != pSD->dwValidate || dwFlags & DMUS_TRACKF_SEEK); // by contract SEEK should be set whenever the other dwFlags are
		li = this->Seek(mtStart);
		pSD->dwValidate = m_dwValidate;
	}

	if (m_fPlayInvalidations || !(dwFlags & DMUS_TRACKF_FLUSH))
	{
		for (; li; li = li->GetNext())
		{
			EventItem &rinfo = li->GetItemValue();
			if (rinfo.lTriggerTime < mtStart) // this can happen if DMUS_TRACKF_PLAY_OFF was set and the seek pointer remains at events from the past
				continue;
			if (rinfo.lTriggerTime >= mtEnd)
				break;
			if (FAILED(this->PlayItem(rinfo, *pSD, pPerf, pSegSt, dwVirtualID, mtOffset, rtOffset, fClockTime)))
			{
				// Returning an error from Play is not allowed.  Just ignore it and assert
				// so we would detect this while testing.
				assert(false);
				continue;
			}
		}
	}

	pSD->pCurrentEvent = li;
	return li ? S_OK : DMUS_S_END;
}

template<class T, class EventItem, class StateData>
TListItem<EventItem> *
CPlayingTrack<T, EventItem, StateData>::Seek(MUSIC_TIME mtStart)
{
	TListItem<EventItem> *li;
	for (li = m_EventList.GetHead();
			li && li->GetItemValue().lTriggerTime < mtStart;
			li = li->GetNext())
	{}

	return li;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\shared\tpool.h ===
// Copyright (c) 1998 Microsoft Corporation
//
// TPool.h
//
// Template pool memory manager. Efficiently manage requests for many of the same (small) object.
// Named after t'Pool, the Vulcan programmer who invented the technique.
//
#ifndef _TPOOL_H_
#define _TPOOL_H_

#include "debug.h"

#define POOL_DEFAULT_BYTE_PER_BLOCK     4096
#define MIN_ITEMS_PER_BLOCK             4

///////////////////////////////////////////////////////////////////////////////
//
// CPool
//
// A simple memory manager that efficiently handles many objects of the same 
// size by allocating blocks containing multiple objects at once.
//
// 
template<class contained> class CPool
{
public:
    CPool(int nApproxBytesPerBlock = POOL_DEFAULT_BYTE_PER_BLOCK);
    ~CPool();

    contained *Alloc();
    void Free(contained* pToFree);

private:
    union CPoolNode
    {
        CPoolNode       *pNext;
        contained       c;
    };

    class CPoolBlock
    {
    public:
        CPoolBlock      *pNext;
        CPoolNode       *pObjects;
    };

    int                 nItemsPerBlock;             // Based on bytes per block
    int                 nAllocatedBlocks;           // # allocated blocks
    CPoolBlock          *pAllocatedBlocks;          // list of allocated blocks
    int                 nFreeList;                  // # nodes in free list
    CPoolNode           *pFreeList;                 // free list

private:
    bool RefillFreeList();

#ifdef DBG
    bool IsPoolNode(CPoolNode *pNode);
    bool IsInFreeList(CPoolNode *pNode);
#endif

};

///////////////////////////////////////////////////////////////////////////////
//
// CPool::CPool
//
// Figure out the number of contained objects per block based on the requested
// approximate block size. Initialize the free list to contain one block's 
// worth of objects.
// 
//
template<class contained> CPool<contained>::CPool(int nApproxBytesPerBlock)
{
    // Figure out how many items per block and cheat if too small
    //
    nItemsPerBlock = nApproxBytesPerBlock / sizeof(CPoolNode);
    if (nItemsPerBlock < MIN_ITEMS_PER_BLOCK)
    {
        nItemsPerBlock = MIN_ITEMS_PER_BLOCK;
    }

    nAllocatedBlocks = 0;
    pAllocatedBlocks = NULL;
    nFreeList = 0;
    pFreeList = NULL;

    // Fill up with some items ahead of time
    //
    RefillFreeList();
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::~CPool
//
// Free up all allocated blocks. There should be no outstanding blocks 
// allocated at this point.
//
// 
template<class contained> CPool<contained>::~CPool()
{
#ifdef DBG
    if (nFreeList < nAllocatedBlocks * nItemsPerBlock)
    {
        TraceI(0, "CPool::~Cpool: Warning: free'ing with outstanding objects allocated.\n");
    }
#endif
    
    // Clean up all allocated blocks and contained objects.
    //
    while (pAllocatedBlocks)
    {
        CPoolBlock *pNext = pAllocatedBlocks->pNext;

        delete[] pAllocatedBlocks->pObjects;
        delete pAllocatedBlocks;

        pAllocatedBlocks = pNext;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::Alloc
//
// Attempt to allocate a contained object and return NULL if out of memory.
// If the free list is empty then allocate another block.
//
// 
template<class contained> contained *CPool<contained>::Alloc()
{
    if (pFreeList == NULL)
    {
        if (!RefillFreeList())
        {
            return false;
        }
    }

    nFreeList--;
    contained *pAlloc = (contained*)pFreeList;
    pFreeList = pFreeList->pNext;

    return pAlloc;
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::Free
//
// Return a contained object to the free list. In the debug version make sure
// the object was in fact allocated from this pool in the first place and that
// it isn't already in the free list.
//
// 
template<class contained> void CPool<contained>::Free(contained *pToFree)
{
    CPoolNode *pNode = (CPoolNode*)pToFree;

#ifdef DBG
    if (!IsPoolNode(pNode))
    {
        TraceI(0, "CPool::Free() Object %p is not a pool node; ignored.\n", pToFree);
        return;
    }
    
    if (IsInFreeList(pNode))
    {
        TraceI(0, "CPool::Free() Object %p is already in the free list; ignored.\n", pToFree);
        return;
    }
#endif

    nFreeList++;
    pNode->pNext = pFreeList;
    pFreeList = pNode;
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::RefillFreeList
//
// Add one block's worth of contained objects to the free list, tracking the 
// allocated memory so we can free it later.
//
// 
template<class contained> bool CPool<contained>::RefillFreeList()
{
    // Allocate a new block and the actual block of objects
    //
    CPoolBlock *pNewBlock = new CPoolBlock;
    if (pNewBlock == NULL)
    {
        return false;
    }

    pNewBlock->pObjects = new CPoolNode[nItemsPerBlock];
    if (pNewBlock->pObjects == NULL)
    {
        delete pNewBlock;
        return false;
    }
    
    TraceI(1, "CPool: Alllocated block %p objects %p for %d bytes\n", 
        pNewBlock, pNewBlock->pObjects, sizeof(CPoolNode) * nItemsPerBlock);

    // Link the block and objects into the right places. First link the new block
    // into the list of allocated blocks.
    //
    pNewBlock->pNext = pAllocatedBlocks;
    pAllocatedBlocks = pNewBlock;

    // Link all the contained object nodes into the free list.
    //
    CPoolNode *pFirstNode = &pNewBlock->pObjects[0];
    CPoolNode *pLastNode  = &pNewBlock->pObjects[nItemsPerBlock - 1];

    for (CPoolNode *pNode = pFirstNode; pNode < pLastNode; pNode++)
    {
        pNode->pNext = pNode + 1;
    }

    pLastNode->pNext = pFreeList;
    pFreeList = pFirstNode;
    
    nFreeList += nItemsPerBlock;
    nAllocatedBlocks++;

    return true;
}

#ifdef DBG
///////////////////////////////////////////////////////////////////////////////
//
// CPool::IsPoolNode (debug)
//
// Verify that the passed pointer is a pointer to a pool node by walking the list
// of allocated blocks.
//
// 
template<class contained> bool CPool<contained>::IsPoolNode(CPoolNode *pTest)
{
    for (CPoolBlock *pBlock = pAllocatedBlocks; pBlock; pBlock = pBlock->pNext)
    {
        CPoolNode *pFirstNode = &pBlock->pObjects[0];
        CPoolNode *pLastNode  = &pBlock->pObjects[nItemsPerBlock - 1];

        for (CPoolNode *pNode = pFirstNode; pNode <= pLastNode; pNode++)
        {
            if (pNode == pTest)
            {
                return true;
            }
        }
    }

    return false;
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::IsInFreeList (debug)
//
// Verify that the passed pointer points to a node that is already in the free
// list.
//
// 
template<class contained> bool CPool<contained>::IsInFreeList(CPoolNode *pTest)
{
    for (CPoolNode *pNode = pFreeList; pNode; pNode = pNode->pNext)
    {
        if (pTest == pNode)
        {
            return true;
        }
    }
    
    return false;
}
#endif  // DBG
#endif  // _TPOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\shared\validate.h ===
//
// validate.h
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Parameter validation macros
//
// Summary:
//
// V_INAME(interfacename)                - Set the interface name for error display
// V_STRUCTPTR_READ(ptr,type)            - A dwSize struct which we will read
// V_STRUCTPTR_WRITE(ptr,type)           - A dwSize struct which we will read/write
// V_PTR_READ(ptr,type)                  - A typed ptr w/o a dwSize which we will read
// V_PTR_WRITE(ptr,type)                 - A typed ptr w/o a dwSize which we will read/write
// V_PTR_WRITE_OPT(ptr,type)             - An optional typed ptr w/o a dwSize which we will read/write
// V_BUFPTR_READ(ptr,size)               - A variable-size buffer that we will read
// V_BUFPTR_READ_OPT(ptr,size)			 - An optional variable-size buffer that we will read
// V_BUFPTR_WRITE(ptr,size)              - A variable-size buffer that we will read/write
// V_BUFPTR_WRITE_OPT(ptr,size)          - An optional variable-size buffer that we will read/write
// V_PTRPTR_WRITE(ptrptr)                - A pointer to a pointer to write to
// V_PTRPTR_WRITE_OPT(ptrptr)            - A pointer to a pointer to write to that is optional
// V_PUNKOUTER(punk)                     - A pointer to a controlling unknown, aggregation supported
// V_PUNKOUTER_NOADD(punk)               - A pointer to a controlling unknown, aggregation not supported
// V_INTERFACE(ptr)                      - A pointer to a COM interface
// V_INTERFACE_OPT(ptr)                  - An optional pointer to a COM interface
// V_REFGUID(ref)                        - A reference to a GUID (type REFGUID)
// V_HWND(hwnd)							 - A window handle
// V_HWNDOPT(hwnd)						 - An optional window handle
//
// For handling different versions of structures:
// 
// V_STRUCTPTR_READ_VER(ptr,ver)         - Begin a struct version block for read access
//                                         At the end, 'ver' will contain the 
//                                         discovered version of the struct
// V_STRUCTPTR_READ_VER_CASE(base,ver)   - Test struct against version ver of
//                                         type 'base'. 
// V_STRUCTPTR_READ_VER_END(base,ptr)    - End a struct version block
//
// V_STRUCTPTR_WRITE_VER(ptr,ver)        - Struct version block for write access
// V_STRUCTPTR_WRITE_VER_CASE(base,ver)
// V_STRUCTPTR_WRITE_VER_END(base,ptr)
//
// The struct version block expects type names of a base type followed by a 
// numeric version, such as
//
// typedef struct { } FOO7;
// typedef struct { } FOO8;
//
// In the header FOO and LPFOO are conditionally typedef'd based on a version
// #define. The DLL will be compiled with the latest version number and hence
// the largest version of the struct.
//
// Since Windows headers are compiled by default with 8-byte alignment, adding
// one DWORD may not cause the size of the structure to change. If this happens
// you will get a 'case label already used' error on one of the VER_CASE macros.
// If this happens, you can get around it by adding a dwReserved field to the 
// end of the struct to force the padding.
//
// 'optional' means the pointer is allowed to be NULL by the interface specification.
//
// Sample usage:
//
// int IDirectMusic::SetFooBarInterface(
//     LPDMUS_REQUESTED_CAPS    pCaps,          // Caps w/ dwSize (read-only)
//     LPVOID                   pBuffer,        // Buffer we will fill in
//     DWORD                    cbSize,         // Size of the buffer
//     PDIRECTMUSICBAR          pBar)           // Callback interface for bar on this buffer
// {
//     V_INTERFACE(IDirectMusic::SetFooBarInterface);
//     V_BUFPTR_WRITE(pBuffer, cbSize);
//     V_INTERFACE(pBar);
//     DWORD dwCapsVer;                         // Must be a DWORD!!!
//
//     V_STRUCTPTR_READ_VER(pCaps, dwCapsVer);
//     V_STRUCTPTR_READ_VER_CASE(DMUS_REQUESTED_CAPS, 7);
//     V_STRUCTPTR_READ_VER_CASE(DMUS_REQUESTED_CAPS, 8);
//     V_STRUCTPTR_READ_VER_END_(DMUS_REQUESTED_CAPS, pCaps);
//
//     // At this point, if we are still in the function we have a valid pCaps
//     // pointer and dwCapsVer is either 7 or 8, indicating the version of
//     // the struct passed in.
//
//     ...
// }
//
#ifndef _VALIDATE_H_
#define _VALIDATE_H_


#ifdef DBG
#include <stddef.h>

#include "debug.h"

// To turn on DebugBreak on parameter error, use the following or -DRIP_BREAK in the build:
//
//#define RIP_BREAK 1

#ifdef RIP_BREAK
#define _RIP_BREAK DebugBreak();
#else
#define _RIP_BREAK 
#endif

#define V_INAME(x) \
    static const char __szValidateInterfaceName[] = #x;                       

#define RIP_E_POINTER(ptr) \
{   Trace(-1, "%s: Invalid pointer " #ptr "\n", __szValidateInterfaceName); \
    _RIP_BREAK \
    return E_POINTER; }

#define RIP_E_INVALIDARG(ptr) \
{   Trace(-1, "%s: Invalid argument " #ptr "\n", __szValidateInterfaceName); \
    _RIP_BREAK \
    return E_INVALIDARG; }

#define RIP_E_HANDLE(h) \
{	Trace(-1, "%s: Invalid handle " #h "\n", __szValidateInterfaceName); \
    _RIP_BREAK \
	return E_HANDLE; }
    
#define RIP_W_INVALIDSIZE(ptr) \
{   Trace(-1, "%s: " #ptr "->dwSize matches no known structure size. Defaulting to oldest structure.\n", \
    __szValidateInterfaceName); \
    _RIP_BREAK \
    }
    
#define RIP_E_INVALIDSIZE(ptr) \
{   Trace(-1, "%s: " #ptr "->dwSize is too small\n", __szValidateInterfaceName); \
    _RIP_BREAK \
    return E_INVALIDARG; }
    
#define RIP_E_BLOCKVSDWSIZE(ptr) \
{   Trace(-1, "%s: " #ptr " does not point to as much memory as " #ptr "->dwSize indicates\n", \
    __szValidateInterfaceName); \
    _RIP_BREAK \
    return E_INVALIDARG; }    

// NOTE: The DebugBreak() not in #ifdef is intentional - this is something that
// must be fixed in our code, not an app-generated error.
//
#define V_ASSERT(exp) \
{   if (!(exp)) { \
        Trace(-1, "%s@%s: %s\n", __FILE__, __LINE__, #exp); \
        DebugBreak(); }}

#else

#define V_INAME(x)
#define RIP_E_POINTER(ptr)          { return E_POINTER; }
#define RIP_E_INVALIDARG(ptr)       { return E_INVALIDARG; }
#define RIP_E_HANDLE(h)	            { return E_HANDLE; }
#define RIP_E_BLOCKVSDWSIZE(ptr)    { return E_INVALIDARG; }
#define RIP_W_INVALIDSIZE(ptr)
#define RIP_E_INVALIDSIZE(ptr)      { return E_INVALIDARG; }
#define V_ASSERT(exp)

#endif          // DBG

// A passed struct we will only read from or may write to. Must be a struct
// with a dwSize.
//
// int foo(CFoo *pFoo)
// ...
// V_STRUCTPTR_READ(pFoo, CFoo);
// V_STRUCTPTR_WRITE(pFoo, CFoo);
//
// Use _PTR_ variants for structs w/o a dwSize
//
#define V_STRUCTPTR_READ(ptr,type) \
{   V_ASSERT(offsetof(type, dwSize) == 0); \
    if (IsBadReadPtr(ptr, sizeof(DWORD)))               RIP_E_BLOCKVSDWSIZE(ptr); \
	if (ptr->dwSize < sizeof(type))						RIP_E_INVALIDSIZE(ptr); \
    if (IsBadReadPtr(ptr, (ptr)->dwSize))               RIP_E_BLOCKVSDWSIZE(ptr); }

#define V_STRUCTPTR_WRITE(ptr,type) \
{   V_ASSERT(offsetof(type, dwSize) == 0); \
    if (IsBadReadPtr(ptr, sizeof(DWORD)))               RIP_E_BLOCKVSDWSIZE(ptr); \
	if (ptr->dwSize < sizeof(type))						RIP_E_INVALIDSIZE(ptr); \
    if (IsBadWritePtr(ptr, (ptr)->dwSize))              RIP_E_BLOCKVSDWSIZE(ptr); }

#define V_PTR_READ(ptr,type) \
{ if (IsBadReadPtr(ptr, sizeof(type)))                  RIP_E_POINTER(ptr); }

#define V_PTR_WRITE(ptr,type) \
{ if (IsBadWritePtr(ptr, sizeof(type)))                 RIP_E_POINTER(ptr); }

#define V_PTR_WRITE_OPT(ptr,type) \
{ if (ptr) if (IsBadWritePtr(ptr, sizeof(type)))        RIP_E_POINTER(ptr); }

// A buffer pointer with separate length (not defined by the pointer type) we will only
// read from or may write to.
//
// int foo(LPVOID *pBuffer, DWORD cbBuffer)
// ...
// V_BUFPTR_READ(pBuffer, cbBuffer);
// V_BUFPTR_WRITE(pBuffer, cbBuffer);
//
#define V_BUFPTR_READ(ptr,len) \
{   if (IsBadReadPtr(ptr, len))                         RIP_E_POINTER(ptr); }

#define V_BUFPTR_READ_OPT(ptr,len) \
{	if (ptr) V_BUFPTR_READ(ptr,len); }

#define V_BUFPTR_WRITE(ptr,len) \
{   if (IsBadWritePtr(ptr, len))                        RIP_E_POINTER(ptr); }

#define V_BUFPTR_WRITE_OPT(ptr,len) \
{	if (ptr) V_BUFPTR_WRITE(ptr,len); }

// A pointer to a pointer (such as a pointer to an interface pointer) to return
//
// int foo(IReturnMe **ppRet)
// ...
// V_PTRPTR_WRITE(ppRet);
// V_PTRPTR_WRITE_OPT(ppRet);
//
#define V_PTRPTR_WRITE(ptr) \
{   if (IsBadWritePtr(ptr, sizeof(void*)))              RIP_E_POINTER(ptr); }

#define V_PTRPTR_WRITE_OPT(ptr) \
{   if (ptr) if (IsBadWritePtr(ptr, sizeof(void*)))     RIP_E_POINTER(ptr); }

// A pointer to a controlling unknown
//
#define V_PUNKOUTER(punk) \
{   if (punk && IsBadCodePtr(punk))                     RIP_E_POINTER(ptr); }

// A pointer to a controlling unknown for which we don't support aggregation
//
#define V_PUNKOUTER_NOAGG(punk) \
{   if (punk && IsBadReadPtr(punk, sizeof(IUnknown)))   RIP_E_POINTER(ptr); \
    if (punk) return CLASS_E_NOAGGREGATION; }

// Validate an incoming interface pointer. 
//
struct _V_GENERIC_INTERFACE
{
    FARPROC *(__vptr[1]);
};

#define V_INTERFACE(ptr) \
{   if (IsBadReadPtr(ptr, sizeof(_V_GENERIC_INTERFACE)))                              RIP_E_POINTER(ptr); \
    if (IsBadReadPtr(*reinterpret_cast<_V_GENERIC_INTERFACE*>(ptr)->__vptr, sizeof(FARPROC))) \
                                                                                      RIP_E_POINTER(ptr); \
    if (IsBadCodePtr(*(reinterpret_cast<_V_GENERIC_INTERFACE*>(ptr)->__vptr)[0]))     RIP_E_POINTER(ptr); }

#define V_INTERFACE_OPT(ptr) \
{   if (ptr) V_INTERFACE(ptr); }

// Validation for a reference to a GUID, which we only ever read. 
//
#define V_REFGUID(ref) \
{   if (IsBadReadPtr((void*)&ref, sizeof(GUID)))        RIP_E_POINTER((void*)&ref); }

// Validation for a window handle
//
#define V_HWND(h) \
{	if (!IsWindow(h))									RIP_E_HANDLE(h); }	

#define V_HWND_OPT(h) \
{	if (h) if (!IsWindow(h))							RIP_E_HANDLE(h); }	

// Validation for multiple sized structs based on version
//
#define V_STRUCTPTR_READ_VER(ptr,ver) \
{   ver = 7; DWORD *pdw = &ver;  \
    if (IsBadReadPtr(ptr, sizeof(DWORD)))               RIP_E_BLOCKVSDWSIZE(ptr); \
    if (IsBadReadPtr(ptr, (ptr)->dwSize))               RIP_E_BLOCKVSDWSIZE(ptr); \
    switch ((ptr)->dwSize) {
    
#define V_STRUCTPTR_READ_VER_CASE(basetype,ver) \
    case sizeof(basetype##ver) : \
    V_ASSERT(offsetof(basetype##ver, dwSize) == 0); \
    *pdw = ver; break;
    
#define V_STRUCTPTR_READ_VER_END(basetype,ptr) \
    default : if ((ptr)->dwSize > sizeof(basetype##7)) \
    { RIP_W_INVALIDSIZE(ptr); } else \
    RIP_E_INVALIDSIZE(ptr); }}


#define V_STRUCTPTR_WRITE_VER(ptr,ver) \
{   ver = 7; DWORD *pdw = &ver;  \
    if (IsBadReadPtr(ptr, sizeof(DWORD)))               RIP_E_BLOCKVSDWSIZE(ptr); \
    if (IsBadWritePtr(ptr, (ptr)->dwSize))              RIP_E_BLOCKVSDWSIZE(ptr); \
    switch ((ptr)->dwSize) {
    
#define V_STRUCTPTR_WRITE_VER_CASE(basetype,ver) \
    case sizeof(basetype##ver) : \
        V_ASSERT(offsetof(basetype##ver, dwSize) == 0); \
        *pdw = ver; break;
    
#define V_STRUCTPTR_WRITE_VER_END(basetype,ptr) \
    default : if ((ptr)->dwSize > sizeof(basetype##7)) \
    { RIP_W_INVALIDSIZE(ptr); } else \
    RIP_E_INVALIDSIZE(ptr); }}



#endif          // _VALIDATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\bldcfg\dpcustrc.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpcustrc.h
 *  Content:    Custom build resource information file.  Overrides default
 *              build environment info.
 *  History:
 
 * Date     By      Reason
 * ====     ======= ========================================================
 * 04/11/00 rodtoll Created
 ***************************************************************************/
#ifdef DPLAY_VERSIONSTR

#undef VERSIONSTR
#define VERSIONSTR DPLAY_VERSIONSTR

#undef MANVERSION
#undef MANREVISION
#undef MANMINORREV
#undef BUILD_NUMBER
#undef VER_PRODUCTVERSION
#undef VER_FILEVERSION
#undef VER_PRODUCTVERSION_STR
#define MANVERSION              DPLAY_VERSION_MANVERSION
#define MANREVISION             DPLAY_VERSION_MANREVISION
#define MANMINORREV             DPLAY_VERSION_MANMINORREV
#define BUILD_NUMBER            DPLAY_VERSION_BUILD_NUMBER
#define VER_PRODUCTVERSION      DPLAY_VERSIONSTR_WINNT
#define VER_FILEVERSION         DPLAY_VERSIONSTR_WINNT
#define VER_PRODUCTVERSION_STR  DPLAY_VERSION_PRODUCT

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\bldcfg\dpvbld.inc ===
############################################################################
#
# Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
#
# File:       dpvbld.inc
# Content:    Build framework switch
# History:
# 
# Date     By      Reason
# ======== ======= ========================================================
# 02/25/00 rodtoll Created
#
############################################################################

!if "$(VOICE_TARGET)"=="gamevoice"
!INCLUDE "gvbld.inc"
!endif

!if "$(VOICE_TARGET)"=="allegiance"
!INCLUDE "msrgbld.inc"
!endif

!if "$(VOICE_TARGET)"==""
!INCLUDE "dxbld.inc"
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dmusic\shared\validp.h ===
// Copyright (c) 1998 Microsoft Corporation
// ValidP.h --- An inline function to test for valid pointers

#ifndef __VALID_P__
#define __VALID_P__

// The debug version checks for Null pointers and pointers to unreadable/unwriteable data.
// (NOTE: only the first byte pointed to is checked)
// The non-debug version just checks for Null pointers.

template <class T>
inline BOOL Validate(T *p)
{ 
#ifdef _DEBUG
	return (p != NULL) && !IsBadReadPtr(p, 1) && !IsBadWritePtr(p, 1);
#else
	return p != NULL;
#endif
}

/* Use:

  Foo *pFoo;
  //
  // stuff...
  //
  if (Validate(pFoo))
  {
     // do stuff with the pointer
  }
  else
  {
     // don't do stuff with the pointer
  }

*/

#endif // __VALID_P__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\bldcfg\dpvcfg.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpvcfg.h
 *  Content:    Switch for determining build info.
 *  History:
 
 * Date     By      Reason
 * ====     ======= ========================================================
 * 02/25/00 rodtoll Created
 ***************************************************************************/

#ifndef __DPVCFG_H
#define __DPVCFG_H

#if defined(VOICE_BUILD_GAMEVOICE)
#include "gvcfg.h"
#elif defined(VOICE_BUILD_ALLEGIANCE)
#include "msrgcfg.h"
#else
#include "dxcfg.h"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\bldcfg\dxbld.inc ===
############################################################################
#
# Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
#
# File:       dpvbld.inc
# Content:    Build filenames for DPV build
# History:
# 
# Date     By      Reason
# ======== ======= ========================================================
# 02/25/00 rodtoll Created
#
############################################################################

# dpvoice.dll filename
DPVOICE_BUILD_FILENAME_DPVOICE=DPVOICE

# dpvsetup.exe filename
DPVOICE_BUILD_FILENAME_DPVSETUP=DPVSETUP

# dpvvox.dll filename
DPVOICE_BUILD_FILENAME_DPVVOX=DPVVOX

# dpvacm filename
DPVOICE_BUILD_FILENAME_DPVACM=DPVACM

# dplayx filename
DPLAY_BUILD_FILENAME_DPLAYX=dplayx

# dpwsockx filename
DPLAY_BUILD_FILENAME_DPWSOCKX=dpwsockx

# dpvhelp filename
DPVOICE_BUILD_FILENAME_DPVHELP=DPVHELP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\bldcfg\msrgbld.inc ===
############################################################################
#
# Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
#
# File:       hawkbld.inc
# Content:    Build filenames for Hawk build
# History:
# 
# Date     By      Reason
# ======== ======= ========================================================
# 02/25/00 rodtoll Created
#
#
############################################################################

# dpvoice.dll filename
DPVOICE_BUILD_FILENAME_DPVOICE=MSRGVE

# dpvsetup.exe filename
DPVOICE_BUILD_FILENAME_DPVSETUP=MSRGSE

# dpvvox.dll filename
DPVOICE_BUILD_FILENAME_DPVVOX=MSRGVOX

# dpvacm filename
DPVOICE_BUILD_FILENAME_DPVACM=MSRGACM

# dplayx filename
DPLAY_BUILD_FILENAME_DPLAYX=MSRGTRAN

# dpwsockx filename
DPLAY_BUILD_FILENAME_DPWSOCKX=MSRGIP

# dpvhelp filename
DPVOICE_BUILD_FILENAME_DPVHELP=MSRGHELP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\bldcfg\gamevoice.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       gamevoice.h
 *  Content:    Constant declarations for HAWK standalone DLL
 *  History:
 
 * Date     By      Reason
 * ====     ======= ========================================================
 * 02/25/00 rodtoll Created
 * 05/09/00 rodtoll Incremented build number
 * 06/12/00 rodtoll Copied from hawk tree
 ***************************************************************************/

#ifndef __HAWKCFG_H
#define __HAWKCFG_H

// DEFAULT DIRECTPLAYVOICE CONFIG FILE
//
// This file is for the default build.
//
#define DPVOICE_REGISTRY_BASE           L"SOFTWARE\\MICROSOFT\\GAMEVOICE\\VOICEENGINE"
#define DPVOICE_REGISTRY_CP             L"\\Compression Providers"
#define DPVOICE_REGISTRY_DPVACM         L"\\MSGVACM"
#define DPVOICE_REGISTRY_DPVVOX         L"\\MSGVVOX"
#define DPVOICE_REGISTRY_AGC            L"\\AGC"
#define DPVOICE_REGISTRY_AUDIOCONFIG    L"\\AudioConfig"

// FINAL 
// #define DPLAY_VERSIONSTR                "4.07.00.725"

#define DPLAY_VERSIONSTR                "4.07.00.722"
#define DPLAY_VERSION_MANVERSION        4
#define DPLAY_VERSION_MANREVISION       7
#define DPLAY_VERSION_MANMINORREV       0
#define DPLAY_VERSION_BUILD_NUMBER      722
#define DPLAY_VERSION_PRODUCT           "4.07"
#define DPLAY_VERSIONSTR_WINNT          4,07,00,722

#define DPLAY_LOADTRUE_BIT              0x00000001
#define DPLAY_LOADANDCHECKTRUE 
#define DPLAY_LOADTRUE_REGKEY           L"Compat1"
#define DPLAY_LOADTRUE_REGPATH          L"SOFTWARE\\MICROSOFT\\DIRECTPLAY"
#define DPLAY_LOADTREE_REGTREE          HKEY_LOCAL_MACHINE
#define DPLAY_LOADTRUE_REGKEY_A         "Compat1"
#define DPLAY_LOADTRUE_REGPATH_A        "SOFTWARE\\MICROSOFT\\DIRECTPLAY"

#define VOICE_BUILD_CUSTOM

// {7C492D36-79CE-4e5b-B88A-D8F4B6E17D15}
DEFINE_GUID(CLSID_MSGVVE, 
0x7c492d36, 0x79ce, 0x4e5b, 0xb8, 0x8a, 0xd8, 0xf4, 0xb6, 0xe1, 0x7d, 0x15);

// {5D176FB5-41BA-4bb3-B244-649CB46B9F6C}
DEFINE_GUID(CLSID_MSGVACM, 
0x5d176fb5, 0x41ba, 0x4bb3, 0xb2, 0x44, 0x64, 0x9c, 0xb4, 0x6b, 0x9f, 0x6c);

// {3FE91DE3-B4F5-42cc-B4EE-3313967B98E8}
DEFINE_GUID(CLSID_MSGVVOX, 
0x3fe91de3, 0xb4f5, 0x42cc, 0xb4, 0xee, 0x33, 0x13, 0x96, 0x7b, 0x98, 0xe8);

// {497187AF-BDEA-443b-8838-3EE7A43B479A}
DEFINE_GUID(CLSID_MSGVTRAN, 
0x497187af, 0xbdea, 0x443b, 0x88, 0x38, 0x3e, 0xe7, 0xa4, 0x3b, 0x47, 0x9a);

// {3617F8E6-C4D4-423c-99EA-E48FA7E67007}
DEFINE_GUID(CLSID_MSGVLOBBY, 
0x3617f8e6, 0xc4d4, 0x423c, 0x99, 0xea, 0xe4, 0x8f, 0xa7, 0xe6, 0x70, 0x7);

// {8CA915CD-8E8B-4ffc-95E5-D6A6FFD68382}
DEFINE_GUID(CLSID_MSGVIP, 
0x8ca915cd, 0x8e8b, 0x4ffc, 0x95, 0xe5, 0xd6, 0xa6, 0xff, 0xd6, 0x83, 0x82);

#define DPLAY_CLSID_DPLOBBY             CLSID_MSGVLOBBY
#define DPVOICE_CLSID_DPVOICE           CLSID_MSGVVE   
#define DPVOICE_CLSID_DPVVOX            CLSID_MSGVVOX
#define DPVOICE_CLSID_DPVACM            CLSID_MSGVACM
#define DPLAY_CLSID_DPLAY               CLSID_MSGVTRAN
#define DPLAY_CLSID_DPWSOCKX            CLSID_MSGVIP

// Unicode filenames (for resource files)
#define DPVOICE_FILENAME_DPVOICE        L"MSGVVE.dll"
#define DPVOICE_FILENAME_DPVSETUP       L"MSGVSE.exe"
#define DPVOICE_FILENAME_RES             L"MSGVVE.dll"
#define DPVOICE_FILENAME_DPVVOX         L"MSGVVOX.dll"
#define DPVOICE_FILENAME_DPVACM         L"MSGVACM.dll"
#define DPLAY_FILENAME_DPLAYX	        L"MSGVTRAN.dll"
#define DPLAY_FILENAME_DPWSOCKX		L"MSGVIP.dll"
#define DPVOICE_FILENAME_DPVHELP        L"MSGVHELP.exe"

// ANSI filenames (for resource files)
#define DPVOICE_FILENAME_DPVOICE_A      "MSGVVE.dll"
#define DPVOICE_FILENAME_DPVSETUP_A     "MSGVSE.exe"
#define DPVOICE_FILENAME_RES_A           "MSGVVE.dll"
#define DPVOICE_FILENAME_DPVVOX_A       "MSGVVOX.dll"
#define DPVOICE_FILENAME_DPVACM_A       "MSGVACM.dll"
#define DPLAY_FILENAME_DPLAYX_A	        "MSGVTRAN.dll"
#define DPLAY_FILENAME_DPWSOCKX_A	"MSGVIP.dll"
#define DPVOICE_FILENAME_DPVHELP_A        "MSGVHELP.exe"


#define DPVOICE_COMMANDLINE_PRIORITY    DPVOICE_FILENAME_DPVSETUP_A " -p"
#define DPVOICE_COMMANDLINE_FULLDUPLEX  DPVOICE_FILENAME_DPVSETUP_A " -f"

// Version Info
#define DPVOICE_VERINFO_DPVOICE          "Microsoft GameVoice Voice Engine"
#define DPVOICE_VERINFO_DPVOICE_DEBUG   DPVOICE_VERINFO_DPVOICE " Debug\0"
#define DPVOICE_VERINFO_DPVOICE_RETAIL  DPVOICE_VERINFO_DPVOICE "\0"
#define DPVOICE_VERINFO_DPVOICE_WINNT   DPVOICE_VERINFO_DPVOICE
#define DPVOICE_VERNAME_DPVOICE_WIN9X   DPVOICE_FILENAME_DPVOICE_A "\0"
#define DPVOICE_VERNAME_DPVOICE_WINNT   DPVOICE_FILENAME_DPVOICE_A

// dpvvox
#define DPVOICE_VERINFO_DPVVOX           "Microsoft GameVoice Voxware Provider"
#define DPVOICE_VERINFO_DPVVOX_DEBUG    DPVOICE_VERINFO_DPVVOX " Debug\0"
#define DPVOICE_VERINFO_DPVVOX_RETAIL   DPVOICE_VERINFO_DPVVOX "\0"
#define DPVOICE_VERINFO_DPVVOX_WINNT    DPVOICE_VERINFO_DPVVOX
#define DPVOICE_VERNAME_DPVVOX_WIN9X   DPVOICE_FILENAME_DPVVOX_A "\0"
#define DPVOICE_VERNAME_DPVVOX_WINNT   DPVOICE_FILENAME_DPVVOX_A

// dpvacm
#define DPVOICE_VERINFO_DPVACM          "Microsoft GameVoice ACM Provider"
#define DPVOICE_VERINFO_DPVACM_DEBUG    DPVOICE_VERINFO_DPVACM " Debug\0"
#define DPVOICE_VERINFO_DPVACM_RETAIL   DPVOICE_VERINFO_DPVACM "\0"
#define DPVOICE_VERINFO_DPVACM_WINNT    DPVOICE_VERINFO_DPVACM
#define DPVOICE_VERNAME_DPVACM_WIN9X   DPVOICE_FILENAME_DPVACM_A "\0"
#define DPVOICE_VERNAME_DPVACM_WINNT   DPVOICE_FILENAME_DPVACM_A

// dpvsetup
#define DPVOICE_VERINFO_DPVSETUP         "Microsoft GameVoice Test"
#define DPVOICE_VERINFO_DPVSETUP_DEBUG  DPVOICE_VERINFO_DPVSETUP " Debug\0"
#define DPVOICE_VERINFO_DPVSETUP_RETAIL DPVOICE_VERINFO_DPVSETUP "\0"
#define DPVOICE_VERINFO_DPVSETUP_WINNT  DPVOICE_VERINFO_DPVSETUP
#define DPVOICE_VERNAME_DPVSETUP_WIN9X   DPVOICE_FILENAME_DPVSETUP_A "\0"
#define DPVOICE_VERNAME_DPVSETUP_WINNT   DPVOICE_FILENAME_DPVSETUP_A

// dplayx
#define DPLAY_VERINFO_DPLAY         	"Microsoft GameVoice Transport"
#define DPLAY_VERINFO_DPLAY_DEBUG  	DPLAY_VERINFO_DPLAY " Debug\0"
#define DPLAY_VERINFO_DPLAY_RETAIL 	DPLAY_VERINFO_DPLAY "\0"
#define DPLAY_VERINFO_DPLAY_WINNT  	DPLAY_VERINFO_DPLAY
#define DPLAY_VERNAME_DPLAY_WIN9X   	DPLAY_VERINFO_DPLAY "\0"
#define DPLAY_VERNAME_DPLAY_WINNT   	DPLAY_VERINFO_DPLAY

// dplayx
#define DPLAY_VERINFO_DPWSOCKX         	"Microsoft GameVoice IP Transport"
#define DPLAY_VERINFO_DPWSOCKX_DEBUG  	DPLAY_VERINFO_DPWSOCKX " Debug\0"
#define DPLAY_VERINFO_DPWSOCKX_RETAIL 	DPLAY_VERINFO_DPWSOCKX "\0"
#define DPLAY_VERINFO_DPWSOCKX_WINNT  	DPLAY_VERINFO_DPWSOCKX
#define DPLAY_VERNAME_DPWSOCKX_WIN9X   	DPLAY_FILENAME_DPWSOCKX_A "\0"
#define DPLAY_VERNAME_DPWSOCKX_WINNT   	DPLAY_FILENAME_DPWSOCKX_A

// dpvhelp
#define DPVOICE_VERINFO_DPVHELP         "Microsoft GameVoice Helper"
#define DPVOICE_VERINFO_DPVHELP_DEBUG  DPVOICE_VERINFO_DPVHELP " Debug\0"
#define DPVOICE_VERINFO_DPVHELP_RETAIL DPVOICE_VERINFO_DPVHELP "\0"
#define DPVOICE_VERINFO_DPVHELP_WINNT  DPVOICE_VERINFO_DPVHELP
#define DPVOICE_VERNAME_DPVHELP_WIN9X  DPVOICE_FILENAME_DPVHELP_A "\0"
#define DPVOICE_VERNAME_DPVHELP_WINNT  DPVOICE_FILENAME_DPVHELP_A

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\bldcfg\dxcfg.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpvcfg.h
 *  Content:    Constant declarations for standalone DLL
 *  History:
 
 * Date     By      Reason
 * ====     ======= ========================================================
 * 02/25/00 rodtoll Created
 ***************************************************************************/

#ifndef __DXCFG_H
#define __DXCFG_H

// DEFAULT DIRECTPLAYVOICE CONFIG FILE
//
// This file is for the default build.
//

#define DPVOICE_REGISTRY_BASE           L"SOFTWARE\\MICROSOFT\\DIRECTPLAY\\VOICE"
#define DPVOICE_REGISTRY_CP             L"\\Compression Providers"
#define DPVOICE_REGISTRY_DPVACM         L"\\DPVACM"
#define DPVOICE_REGISTRY_DPVVOX         L"\\DPVVOX"
#define DPVOICE_REGISTRY_AGC            L"\\AGC"
#define DPVOICE_REGISTRY_AUDIOCONFIG   L"\\AudioConfig"
#define DPVOICE_CLSID_DPVOICE           CLSID_DirectPlayVoice   
#define DPVOICE_CLSID_DPVVOX            CLSID_DPVCPVOX
#define DPVOICE_CLSID_DPVVOX_CONVERTER  CLSID_DPVCPVOX_CONVERTER
#define DPVOICE_CLSID_DPVACM            CLSID_DPVCPACM
#define DPVOICE_CLSID_DPVACM_CONVERTER	CLSID_DPVCPACM_CONVERTER
#define DPLAY_CLSID_DPLAY               CLSID_DirectPlay
#define DPLAY_CLSID_DPLOBBY             CLSID_DirectPlayLobby

// Unicode filenames (for resource files)
#define DPVOICE_FILENAME_DPVOICE        L"dpvoice.dll"
#define DPVOICE_FILENAME_DPVSETUP       L"dpvsetup.exe"
#define DPVOICE_FILENAME_RES             L"dpvoice.dll"
#define DPVOICE_FILENAME_DPVVOX         L"dpvvox.dll"
#define DPVOICE_FILENAME_DPVACM         L"dpvacm.dll"
#define DPLAY_FILENAME_DPLAYX	        L"dplayx.dll"
#define DPVOICE_FILENAME_DPVHELP        L"dpvhelp.exe"
#define DPLAY_FILENAME_DPWSOCKX			L"dpwsockx.dll"

// ANSI filenames (for resource files)
#define DPVOICE_FILENAME_DPVOICE_A      "dpvoice.dll"
#define DPVOICE_FILENAME_DPVSETUP_A     "dpvsetup.exe"
#define DPVOICE_FILENAME_RES_A           "dpvoice.dll"
#define DPVOICE_FILENAME_DPVVOX_A       "dpvvox.dll"
#define DPVOICE_FILENAME_DPVACM_A       "dpvacm.dll"
#define DPLAY_FILENAME_DPLAYX_A	        "dplayx.dll"
#define DPVOICE_FILENAME_DPVHELP_A      "dpvhelp.exe"
#define DPLAY_FILENAME_DPWSOCKX_A		"dpwsockx.dll"

#define DPVOICE_COMMANDLINE_PRIORITY    _T( DPVOICE_FILENAME_DPVSETUP_A ) _T( " -p")
#define DPVOICE_COMMANDLINE_FULLDUPLEX  _T( DPVOICE_FILENAME_DPVSETUP_A ) _T(" -f")

// Version Info
#define DPVOICE_VERINFO_DPVOICE          "Microsoft DirectPlay Voice"
#define DPVOICE_VERINFO_DPVOICE_DEBUG   DPVOICE_VERINFO_DPVOICE "Debug\0"
#define DPVOICE_VERINFO_DPVOICE_RETAIL  DPVOICE_VERINFO_DPVOICE "\0"
#define DPVOICE_VERINFO_DPVOICE_WINNT   DPVOICE_VERINFO_DPVOICE
#define DPVOICE_VERNAME_DPVOICE_WIN9X   DPVOICE_FILENAME_DPVOICE_A "\0"
#define DPVOICE_VERNAME_DPVOICE_WINNT   DPVOICE_FILENAME_DPVOICE_A

// dpvvox
#define DPVOICE_VERINFO_DPVVOX           "Microsoft DirectPlay Voice Voxware Provider"
#define DPVOICE_VERINFO_DPVVOX_DEBUG    DPVOICE_VERINFO_DPVVOX " Debug\0"
#define DPVOICE_VERINFO_DPVVOX_RETAIL   DPVOICE_VERINFO_DPVVOX "\0"
#define DPVOICE_VERINFO_DPVVOX_WINNT    DPVOICE_VERINFO_DPVVOX
#define DPVOICE_VERNAME_DPVVOX_WIN9X   DPVOICE_FILENAME_DPVVOX_A "\0"
#define DPVOICE_VERNAME_DPVVOX_WINNT   DPVOICE_FILENAME_DPVVOX_A

// dpvacm
#define DPVOICE_VERINFO_DPVACM          "Microsoft DirectPlay Voice ACM Provider"
#define DPVOICE_VERINFO_DPVACM_DEBUG    DPVOICE_VERINFO_DPVACM " Debug\0"
#define DPVOICE_VERINFO_DPVACM_RETAIL   DPVOICE_VERINFO_DPVACM "\0"
#define DPVOICE_VERINFO_DPVACM_WINNT    DPVOICE_VERINFO_DPVACM
#define DPVOICE_VERNAME_DPVACM_WIN9X   DPVOICE_FILENAME_DPVACM_A "\0"
#define DPVOICE_VERNAME_DPVACM_WINNT   DPVOICE_FILENAME_DPVACM_A

// dpvsetup
#define DPVOICE_VERINFO_DPVSETUP         "Microsoft DirectPlay Voice Test"
#define DPVOICE_VERINFO_DPVSETUP_DEBUG  DPVOICE_VERINFO_DPVSETUP "Debug\0"
#define DPVOICE_VERINFO_DPVSETUP_RETAIL DPVOICE_VERINFO_DPVSETUP "\0"
#define DPVOICE_VERINFO_DPVSETUP_WINNT  DPVOICE_VERINFO_DPVSETUP
#define DPVOICE_VERNAME_DPVSETUP_WIN9X   DPVOICE_FILENAME_DPVSETUP_A "\0"
#define DPVOICE_VERNAME_DPVSETUP_WINNT   DPVOICE_FILENAME_DPVSETUP_A

// dplayx
#define DPLAY_VERINFO_DPLAY         	"Microsoft DirectPlay"
#define DPLAY_VERINFO_DPLAY_DEBUG  	DPLAY_VERINFO_DPLAY "Debug\0"
#define DPLAY_VERINFO_DPLAY_RETAIL 	DPLAY_VERINFO_DPLAY "\0"
#define DPLAY_VERINFO_DPLAY_WINNT  	DPLAY_VERINFO_DPLAY
#define DPLAY_VERNAME_DPLAY_WIN9X   	DPLAY_FILENAME_DPLAYX_A "\0"
#define DPLAY_VERNAME_DPLAY_WINNT   	DPLAY_FILENAME_DPLAYX_A

// dplayx
#define DPLAY_VERINFO_DPWSOCKX         	"Internet TCP/IP and IPX Connection For DirectPlay"
#define DPLAY_VERINFO_DPWSOCKX_DEBUG  	DPLAY_VERINFO_DPWSOCKX "Debug\0"
#define DPLAY_VERINFO_DPWSOCKX_RETAIL 	DPLAY_VERINFO_DPWSOCKX "\0"
#define DPLAY_VERINFO_DPWSOCKX_WINNT  	DPLAY_VERINFO_DPWSOCKX
#define DPLAY_VERNAME_DPWSOCKX_WIN9X   	DPLAY_FILENAME_DPWSOCKX_A "\0"
#define DPLAY_VERNAME_DPWSOCKX_WINNT   	DPLAY_FILENAME_DPWSOCKX_A

// dpvhelp
#define DPVOICE_VERINFO_DPVHELP         "Microsoft DirectPlay Voice"
#define DPVOICE_VERINFO_DPVHELP_DEBUG  DPVOICE_VERINFO_DPVHELP "Debug\0"
#define DPVOICE_VERINFO_DPVHELP_RETAIL DPVOICE_VERINFO_DPVHELP "\0"
#define DPVOICE_VERINFO_DPVHELP_WINNT  DPVOICE_VERINFO_DPVHELP
#define DPVOICE_VERNAME_DPVHELP_WIN9X  DPVOICE_FILENAME_DPVHELP_A "\0"
#define DPVOICE_VERNAME_DPVHELP_WINNT  DPVOICE_FILENAME_DPVHELP_A


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\bldcfg\gvbld.inc ===
############################################################################
#
# Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
#
# File:       hawkbld.inc
# Content:    Build filenames for Hawk build
# History:
# 
# Date     By      Reason
# ======== ======= ========================================================
# 02/25/00 rodtoll Created
#
############################################################################

# dpvoice.dll filename
DPVOICE_BUILD_FILENAME_DPVOICE=MSGVVE

# dpvsetup.exe filename
DPVOICE_BUILD_FILENAME_DPVSETUP=MSGVSE

# dpvvox.dll filename
DPVOICE_BUILD_FILENAME_DPVVOX=MSGVVOX

# dpvacm filename
DPVOICE_BUILD_FILENAME_DPVACM=MSGVACM

# dplayx filename
DPLAY_BUILD_FILENAME_DPLAYX=MSGVTRAN

# dpwsockx filename
DPLAY_BUILD_FILENAME_DPWSOCKX=MSGVIP

# dpvhelp filename
DPVOICE_BUILD_FILENAME_DPVHELP=MSGVHELP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\bilink.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       bilink.c
 *  Content:    Management for doubly linked (BILINK) lists
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   1993				George Joy
 *   10/15/99	mjn		Changed Delete to initialize bilink element after adjusting pointers
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncmni.h"
#include "bilink.h"

// Note: serialization of access to BILINK structures must 
//       take place in the calling code.  Operations are
//       not intrinsically atomic.

#ifdef DEBUG
#undef DPF_MODNAME
#define DPF_MODNAME "FindObject"
int FindObject(BILINK *link,BILINK *list)
{
    BILINK *p = list->next;
    while(p != link && p != list)
        p= p->next;
    return (p==link);
}
#endif


/*=========================================================================
 *  Description:
 *      Insert an object after a specified object in the doubly linked list.
 *      The after object could be the Head BILINK for adding to the head of a
 *      queue.
 *  Returns:
 *
 */
#undef DPF_MODNAME
#define DPF_MODNAME "InsertAfter"
void InsertAfter(BILINK *in,BILINK *after)
{
    #ifdef DEBUG
    if(FindObject(in,after)) {
        DPFX(DPFPREP, 0,"Attempt to re-insert object in BILINK queue\n");
        DEBUG_BREAK();
    }
    #endif
    in->next = after->next;
    in->prev = after;
    after->next->prev = in;
    after->next = in;
}


/*=========================================================================
 *  Description:
 * Inserts an  object before a specified object in the doubly linked list.
 * The before object could be the Head BILINK for adding to the end
 * of the queue
 * CALLED WITH INTERRUPTS_OFF
 *
 *  Returns:
 *
 */
#undef DPF_MODNAME
#define DPF_MODNAME "InsertBefore"
void InsertBefore(BILINK *in,BILINK *before)
{
    #ifdef DEBUG
    if(FindObject(in,before)) {
        DPFX(DPFPREP, 0,"Attempt to re-insert object in BILINK queue\n");
        DEBUG_BREAK();
    }
    #endif
    in->next = before;
    in->prev = before->prev;
    before->prev->next = in;
    before->prev = in;
}


/*=========================================================================
 *  Description:
 *
 * Delete a  object from a doubly linked list. Make sure it IS on a list!
 * CALLED WITH INTERRUPTS OFF (must be atomic).
 *
 *  Returns:
 *
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Delete"
void Delete(BILINK *p)
{
    DNASSERT(p && p->prev && p->next);
    DNASSERT(p->prev->next == p && p->next->prev == p);
#ifdef	DEBUG
    if(!p && p->prev && p->next){
    	DEBUG_BREAK();
    }
    if(!(p->prev->next == p && p->next->prev == p)){
    	DEBUG_BREAK();
    }
#endif
    p->next->prev = p->prev;
    p->prev->next = p->next;
    InitBilink(p, p->pvObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\bilink.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    BILINK.H

Abstract:

    Management for doubly linked lists

Author:

    George Joy

Environment:

    32-bit 'C'

Revision History:

--*/// BILINK.H

// Make sure all variations of DEBUG are defined if any one is
#if defined(DEBUG) || defined(DBG) || defined(_DEBUG)
#if !defined(DBG)
#define DBG
#endif
#if !defined(DEBUG)
#define DEBUG
#endif
#if !defined(_DEBUG)
#define _DEBUG
#endif
#endif

#ifdef	__cplusplus
extern	"C"
{
#endif	// __cplusplus

#ifndef _BILINK_

#define _BILINK_

#if !defined(offsetof)
	#define offsetof(type, field) ((int)(&((type *)0)->field))
#endif	

#ifndef	CONTAINING_RECORD
#define CONTAINING_RECORD(address,type,field) \
						((type *)((PCHAR)(address) - (UINT_PTR)(&((type *)0)->field)))
#endif	// CONTAINING_RECORD

typedef struct BILINK {
    struct BILINK *next;
    struct BILINK *prev;
	void *pvObject;
} BILINK;

/* XLATOFF */

#define EMPTY_BILINK(_pBilink) ((_pBilink)->next==(_pBilink))

#ifdef DEBUG
    #define ASSERT_EMPTY_BILINK(_b) ASSERT((_b)->next==(_b))
#else
    #define ASSERT_EMPTY_BILINK(_b)
#endif

// This only works for BILINKS that are the first item in a structure.
#define BilinkToList( _pBilink ) \
	(_pBilink)->prev->next=NULL;

#define InitBilink( _pBilink, _pvObject ) \
    (_pBilink)->prev=(_pBilink)->next=(_pBilink); (_pBilink)->pvObject = _pvObject; 

#ifdef DEBUG

int FindObject(
    BILINK *link,
    BILINK *list
    );
#endif

void InsertAfter(
    BILINK *in,
    BILINK *after
    );

void InsertBefore(
     BILINK *in,
     BILINK *before
    );

void Delete(
     BILINK *p
);

/* XLATON */

#endif


#ifdef	__cplusplus
}
#endif	// __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\bldcfg\gvcfg.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       hawkcfg.h
 *  Content:    Constant declarations for HAWK standalone DLL
 *  History:
 
 * Date     By      Reason
 * ====     ======= ========================================================
 * 02/25/00 rodtoll Created
 * 05/09/00 rodtoll Incremented build number
 ***************************************************************************/

#ifndef __HAWKCFG_H
#define __HAWKCFG_H

// DEFAULT DIRECTPLAYVOICE CONFIG FILE
//
// This file is for the default build.
//
#define DPVOICE_REGISTRY_BASE           L"SOFTWARE\\MICROSOFT\\GAMEVOICE\\VOICEENGINE"
#define DPVOICE_REGISTRY_CP             L"\\Compression Providers"
#define DPVOICE_REGISTRY_DPVACM         L"\\MSGVACM"
#define DPVOICE_REGISTRY_DPVVOX         L"\\MSGVVOX"
#define DPVOICE_REGISTRY_AGC            L"\\AGC"
#define DPVOICE_REGISTRY_AUDIOCONFIG    L"\\AudioConfig"

// FINAL 
// #define DPLAY_VERSIONSTR                "4.07.00.725"

#define DPLAY_VERSIONSTR                "4.07.00.722"
#define DPLAY_VERSION_MANVERSION        4
#define DPLAY_VERSION_MANREVISION       7
#define DPLAY_VERSION_MANMINORREV       0
#define DPLAY_VERSION_BUILD_NUMBER      722
#define DPLAY_VERSION_PRODUCT           "4.07"
#define DPLAY_VERSIONSTR_WINNT          4,07,00,722

#define DPLAY_LOADTRUE_BIT              0x00000001
#define DPLAY_LOADANDCHECKTRUE 
#define DPLAY_LOADTRUE_REGKEY           L"Compat1"
#define DPLAY_LOADTRUE_REGPATH          L"SOFTWARE\\MICROSOFT\\DIRECTPLAY"
#define DPLAY_LOADTREE_REGTREE          HKEY_LOCAL_MACHINE
#define DPLAY_LOADTRUE_REGKEY_A         "Compat1"
#define DPLAY_LOADTRUE_REGPATH_A        "SOFTWARE\\MICROSOFT\\DIRECTPLAY"

#define VOICE_BUILD_CUSTOM

// {7C492D36-79CE-4e5b-B88A-D8F4B6E17D15}
DEFINE_GUID(CLSID_MSGVVE, 
0x7c492d36, 0x79ce, 0x4e5b, 0xb8, 0x8a, 0xd8, 0xf4, 0xb6, 0xe1, 0x7d, 0x15);

// {5D176FB5-41BA-4bb3-B244-649CB46B9F6C}
DEFINE_GUID(CLSID_MSGVACM, 
0x5d176fb5, 0x41ba, 0x4bb3, 0xb2, 0x44, 0x64, 0x9c, 0xb4, 0x6b, 0x9f, 0x6c);

// {F2A25EE5-FA62-47f4-B981-EA7AB064395D}
DEFINE_GUID(CLSID_MSGVACM_CONVERTER, 
0xf2a25ee5, 0xfa62, 0x47f4, 0xb9, 0x81, 0xea, 0x7a, 0xb0, 0x64, 0x39, 0x5d);

// {3FE91DE3-B4F5-42cc-B4EE-3313967B98E8}
DEFINE_GUID(CLSID_MSGVVOX, 
0x3fe91de3, 0xb4f5, 0x42cc, 0xb4, 0xee, 0x33, 0x13, 0x96, 0x7b, 0x98, 0xe8);

// {BA37086C-FC18-4616-807E-B5098DD665EA}
DEFINE_GUID(CLSID_MSGVVOX_CONVERTER, 
0xba37086c, 0xfc18, 0x4616, 0x80, 0x7e, 0xb5, 0x9, 0x8d, 0xd6, 0x65, 0xea);

// {497187AF-BDEA-443b-8838-3EE7A43B479A}
DEFINE_GUID(CLSID_MSGVTRAN, 
0x497187af, 0xbdea, 0x443b, 0x88, 0x38, 0x3e, 0xe7, 0xa4, 0x3b, 0x47, 0x9a);

// {3617F8E6-C4D4-423c-99EA-E48FA7E67007}
DEFINE_GUID(CLSID_MSGVLOBBY, 
0x3617f8e6, 0xc4d4, 0x423c, 0x99, 0xea, 0xe4, 0x8f, 0xa7, 0xe6, 0x70, 0x7);

// {8CA915CD-8E8B-4ffc-95E5-D6A6FFD68382}
DEFINE_GUID(CLSID_MSGVIP, 
0x8ca915cd, 0x8e8b, 0x4ffc, 0x95, 0xe5, 0xd6, 0xa6, 0xff, 0xd6, 0x83, 0x82);

#define DPLAY_CLSID_DPLOBBY             CLSID_MSGVLOBBY
#define DPVOICE_CLSID_DPVOICE           CLSID_MSGVVE   
#define DPVOICE_CLSID_DPVVOX            CLSID_MSGVVOX
#define DPVOICE_CLSID_DPVVOX_CONVERTER  CLSID_MSGVVOX_CONVERTER
#define DPVOICE_CLSID_DPVACM            CLSID_MSGVACM
#define DPVOICE_CLSID_DPVVOX_CONVERTER	CLSID_MSGVACM_CONVERTER
#define DPLAY_CLSID_DPLAY               CLSID_MSGVTRAN
#define DPLAY_CLSID_DPWSOCKX            CLSID_MSGVIP

// Unicode filenames (for resource files)
#define DPVOICE_FILENAME_DPVOICE        L"MSGVVE.dll"
#define DPVOICE_FILENAME_DPVSETUP       L"MSGVSE.exe"
#define DPVOICE_FILENAME_RES             L"MSGVVE.dll"
#define DPVOICE_FILENAME_DPVVOX         L"MSGVVOX.dll"
#define DPVOICE_FILENAME_DPVACM         L"MSGVACM.dll"
#define DPLAY_FILENAME_DPLAYX	        L"MSGVTRAN.dll"
#define DPLAY_FILENAME_DPWSOCKX		L"MSGVIP.dll"
#define DPVOICE_FILENAME_DPVHELP        L"MSGVHELP.exe"

// ANSI filenames (for resource files)
#define DPVOICE_FILENAME_DPVOICE_A      "MSGVVE.dll"
#define DPVOICE_FILENAME_DPVSETUP_A     "MSGVSE.exe"
#define DPVOICE_FILENAME_RES_A           "MSGVVE.dll"
#define DPVOICE_FILENAME_DPVVOX_A       "MSGVVOX.dll"
#define DPVOICE_FILENAME_DPVACM_A       "MSGVACM.dll"
#define DPLAY_FILENAME_DPLAYX_A	        "MSGVTRAN.dll"
#define DPLAY_FILENAME_DPWSOCKX_A	"MSGVIP.dll"
#define DPVOICE_FILENAME_DPVHELP_A        "MSGVHELP.exe"


#define DPVOICE_COMMANDLINE_PRIORITY    DPVOICE_FILENAME_DPVSETUP_A " -p"
#define DPVOICE_COMMANDLINE_FULLDUPLEX  DPVOICE_FILENAME_DPVSETUP_A " -f"

// Version Info
#define DPVOICE_VERINFO_DPVOICE          "Microsoft GameVoice Voice Engine"
#define DPVOICE_VERINFO_DPVOICE_DEBUG   DPVOICE_VERINFO_DPVOICE " Debug\0"
#define DPVOICE_VERINFO_DPVOICE_RETAIL  DPVOICE_VERINFO_DPVOICE "\0"
#define DPVOICE_VERINFO_DPVOICE_WINNT   DPVOICE_VERINFO_DPVOICE
#define DPVOICE_VERNAME_DPVOICE_WIN9X   DPVOICE_FILENAME_DPVOICE_A "\0"
#define DPVOICE_VERNAME_DPVOICE_WINNT   DPVOICE_FILENAME_DPVOICE_A

// dpvvox
#define DPVOICE_VERINFO_DPVVOX           "Microsoft GameVoice Voxware Provider"
#define DPVOICE_VERINFO_DPVVOX_DEBUG    DPVOICE_VERINFO_DPVVOX " Debug\0"
#define DPVOICE_VERINFO_DPVVOX_RETAIL   DPVOICE_VERINFO_DPVVOX "\0"
#define DPVOICE_VERINFO_DPVVOX_WINNT    DPVOICE_VERINFO_DPVVOX
#define DPVOICE_VERNAME_DPVVOX_WIN9X   DPVOICE_FILENAME_DPVVOX_A "\0"
#define DPVOICE_VERNAME_DPVVOX_WINNT   DPVOICE_FILENAME_DPVVOX_A

// dpvacm
#define DPVOICE_VERINFO_DPVACM          "Microsoft GameVoice ACM Provider"
#define DPVOICE_VERINFO_DPVACM_DEBUG    DPVOICE_VERINFO_DPVACM " Debug\0"
#define DPVOICE_VERINFO_DPVACM_RETAIL   DPVOICE_VERINFO_DPVACM "\0"
#define DPVOICE_VERINFO_DPVACM_WINNT    DPVOICE_VERINFO_DPVACM
#define DPVOICE_VERNAME_DPVACM_WIN9X   DPVOICE_FILENAME_DPVACM_A "\0"
#define DPVOICE_VERNAME_DPVACM_WINNT   DPVOICE_FILENAME_DPVACM_A

// dpvsetup
#define DPVOICE_VERINFO_DPVSETUP         "Microsoft GameVoice Test"
#define DPVOICE_VERINFO_DPVSETUP_DEBUG  DPVOICE_VERINFO_DPVSETUP " Debug\0"
#define DPVOICE_VERINFO_DPVSETUP_RETAIL DPVOICE_VERINFO_DPVSETUP "\0"
#define DPVOICE_VERINFO_DPVSETUP_WINNT  DPVOICE_VERINFO_DPVSETUP
#define DPVOICE_VERNAME_DPVSETUP_WIN9X   DPVOICE_FILENAME_DPVSETUP_A "\0"
#define DPVOICE_VERNAME_DPVSETUP_WINNT   DPVOICE_FILENAME_DPVSETUP_A

// dplayx
#define DPLAY_VERINFO_DPLAY         	"Microsoft GameVoice Transport"
#define DPLAY_VERINFO_DPLAY_DEBUG  	DPLAY_VERINFO_DPLAY " Debug\0"
#define DPLAY_VERINFO_DPLAY_RETAIL 	DPLAY_VERINFO_DPLAY "\0"
#define DPLAY_VERINFO_DPLAY_WINNT  	DPLAY_VERINFO_DPLAY
#define DPLAY_VERNAME_DPLAY_WIN9X   	DPLAY_VERINFO_DPLAY "\0"
#define DPLAY_VERNAME_DPLAY_WINNT   	DPLAY_VERINFO_DPLAY

// dplayx
#define DPLAY_VERINFO_DPWSOCKX         	"Microsoft GameVoice IP Transport"
#define DPLAY_VERINFO_DPWSOCKX_DEBUG  	DPLAY_VERINFO_DPWSOCKX " Debug\0"
#define DPLAY_VERINFO_DPWSOCKX_RETAIL 	DPLAY_VERINFO_DPWSOCKX "\0"
#define DPLAY_VERINFO_DPWSOCKX_WINNT  	DPLAY_VERINFO_DPWSOCKX
#define DPLAY_VERNAME_DPWSOCKX_WIN9X   	DPLAY_FILENAME_DPWSOCKX_A "\0"
#define DPLAY_VERNAME_DPWSOCKX_WINNT   	DPLAY_FILENAME_DPWSOCKX_A

// dpvhelp
#define DPVOICE_VERINFO_DPVHELP         "Microsoft GameVoice Helper"
#define DPVOICE_VERINFO_DPVHELP_DEBUG  DPVOICE_VERINFO_DPVHELP " Debug\0"
#define DPVOICE_VERINFO_DPVHELP_RETAIL DPVOICE_VERINFO_DPVHELP "\0"
#define DPVOICE_VERINFO_DPVHELP_WINNT  DPVOICE_VERINFO_DPVHELP
#define DPVOICE_VERNAME_DPVHELP_WIN9X  DPVOICE_FILENAME_DPVHELP_A "\0"
#define DPVOICE_VERNAME_DPVHELP_WINNT  DPVOICE_FILENAME_DPVHELP_A

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\bldcfg\msrgcfg.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       msrgcfg.h
 *  Content:    Constant declarations for standalone DLL
 *  History:
 
 * Date     By      Reason
 * ====     ======= ========================================================
 * 04/03/00 rodtoll Created
 ***************************************************************************/

#ifndef __MSRGCFG_H
#define __MSRGCFG_H

// {222FD207-B521-403c-97C6-A75D95657D6C}
DEFINE_GUID(MSRG_CLSID_DPWSOCKX, 
0x222fd207, 0xb521, 0x403c, 0x97, 0xc6, 0xa7, 0x5d, 0x95, 0x65, 0x7d, 0x6c);

// DEFAULT DIRECTPLAYVOICE CONFIG FILE
//
// This file is for the default build.
//

#define DPVOICE_REGISTRY_BASE           L"SOFTWARE\\MICROSOFT\\ALLEGIANCE\\VOICE"
#define DPVOICE_REGISTRY_CP             L"\\Compression Providers"
#define DPVOICE_REGISTRY_DPVACM         L"\\MSRGACM"
#define DPVOICE_REGISTRY_DPVVOX         L"\\MSRGVOX"
#define DPVOICE_REGISTRY_AGC            L"\\AGC"
#define DPVOICE_REGISTRY_AUDIOCONFIG   L"\\AudioConfig"

// FINAL 
// #define DPLAY_VERSIONSTR                "7.07.00.720"
#define DPLAY_VERSIONSTR                "7.07.00.722"
#define DPLAY_VERSION_MANVERSION        7
#define DPLAY_VERSION_MANREVISION       7
#define DPLAY_VERSION_MANMINORREV       0
#define DPLAY_VERSION_BUILD_NUMBER      722
#define DPLAY_VERSION_PRODUCT           "7.07"
#define DPLAY_VERSIONSTR_WINNT          7,07,00,72

#define DPLAY_LOADTRUE_BIT              0x00000001

#define VOICE_BUILD_CUSTOM

#define DPLAY_LOADANDCHECKTRUE          
#define DPLAY_LOADTRUE_REGKEY           L"Compat2"
#define DPLAY_LOADTRUE_REGPATH          L"SOFTWARE\\MICROSOFT\\DIRECTPLAY"
#define DPLAY_LOADTREE_REGTREE          HKEY_LOCAL_MACHINE
#define DPLAY_LOADTRUE_REGKEY_A         "Compat2"
#define DPLAY_LOADTRUE_REGPATH_A        "SOFTWARE\\MICROSOFT\\DIRECTPLAY"

// {4BFE308D-1279-492a-8E9A-F21C4E3CD819}
DEFINE_GUID(MSRG_CLSID_DPVOICE, 
0x4bfe308d, 0x1279, 0x492a, 0x8e, 0x9a, 0xf2, 0x1c, 0x4e, 0x3c, 0xd8, 0x19);

// {17DFBCA4-B281-491b-AE09-97963A0D7983}
DEFINE_GUID(MSRG_CLSID_DPVVOX, 
0x17dfbca4, 0xb281, 0x491b, 0xae, 0x9, 0x97, 0x96, 0x3a, 0xd, 0x79, 0x83);

// {6859F895-FD41-452a-9D07-08BED143FD2C}
DEFINE_GUID(MSRG_CLSID_DPVVOX_CONVERTER, 
0x6859f895, 0xfd41, 0x452a, 0x9d, 0x7, 0x8, 0xbe, 0xd1, 0x43, 0xfd, 0x2c);

// {8D777B43-7654-4e25-B649-839C1FED06DF}
DEFINE_GUID(MSRG_CLSID_DPVACM, 
0x8d777b43, 0x7654, 0x4e25, 0xb6, 0x49, 0x83, 0x9c, 0x1f, 0xed, 0x6, 0xdf);

// {190B1CCD-8754-4291-A84C-19E347BD2258}
DEFINE_GUID(MSRG_CLSID_DPVACM_CONVERTER, 
0x190b1ccd, 0x8754, 0x4291, 0xa8, 0x4c, 0x19, 0xe3, 0x47, 0xbd, 0x22, 0x58);

#define DPVOICE_CLSID_DPVOICE           MSRG_CLSID_DPVOICE   
#define DPVOICE_CLSID_DPVVOX            MSRG_CLSID_DPVVOX
#define DPVOICE_CLSID_DPVVOX_CONVERTER  MSRG_CLSID_DPVVOX_CONVERTER
#define DPVOICE_CLSID_DPVACM            MSRG_CLSID_DPVACM
#define DPVOICE_CLSID_DPVACM_CONVERTER	MSRG_CLSID_DPVACM_CONVERTER

// {DA9CABC6-C724-4265-A61D-6E78EB2042B4}
DEFINE_GUID(MSRG_CLSID_DPLAY, 
0xda9cabc6, 0xc724, 0x4265, 0xa6, 0x1d, 0x6e, 0x78, 0xeb, 0x20, 0x42, 0xb4);

// {FD732D2F-6DDD-448d-8BFF-C8D94022BB9E}
DEFINE_GUID(MSRG_CLSID_DPLOBBY, 
0xfd732d2f, 0x6ddd, 0x448d, 0x8b, 0xff, 0xc8, 0xd9, 0x40, 0x22, 0xbb, 0x9e);


#define DPLAY_CLSID_DPLAY        	    MSRG_CLSID_DPLAY       
#define DPLAY_CLSID_DPLOBBY             MSRG_CLSID_DPLOBBY
#define DPLAY_CLSID_DPWSOCKX            MSRG_CLSID_DPWSOCKX

// Unicode filenames (for resource files)
#define DPVOICE_FILENAME_DPVOICE        L"msrgve.dll"
#define DPVOICE_FILENAME_DPVSETUP       L"msrgse.exe"
#define DPVOICE_FILENAME_RES            L"msrgve.dll"
#define DPVOICE_FILENAME_DPVVOX         L"msrgvox.dll"
#define DPVOICE_FILENAME_DPVACM         L"msrgacm.dll"
#define DPLAY_FILENAME_DPLAYX	        L"msrgtran.dll"
#define DPVOICE_FILENAME_DPVHELP        L"msrghelp.exe"
#define DPLAY_FILENAME_DPWSOCKX		    L"msrgip.dll"

// ANSI filenames (for resource files)
#define DPVOICE_FILENAME_DPVOICE_A      "msrgve.dll"
#define DPVOICE_FILENAME_DPVSETUP_A     "msrgse.exe"
#define DPVOICE_FILENAME_RES_A          "msrgve.dll"
#define DPVOICE_FILENAME_DPVVOX_A       "msrgvox.dll"
#define DPVOICE_FILENAME_DPVACM_A       "msrgacm.dll"
#define DPLAY_FILENAME_DPLAYX_A	        "msrgtran.dll"
#define DPVOICE_FILENAME_DPVHELP_A      "msrghelp.exe"
#define DPLAY_FILENAME_DPWSOCKX_A		"msrgip.dll"

#define DPVOICE_COMMANDLINE_PRIORITY    DPVOICE_FILENAME_DPVSETUP_A " -p"
#define DPVOICE_COMMANDLINE_FULLDUPLEX  DPVOICE_FILENAME_DPVSETUP_A " -f"

// Version Info
#define DPVOICE_VERINFO_DPVOICE          "Microsoft DirectPlay Voice"
#define DPVOICE_VERINFO_DPVOICE_DEBUG   DPVOICE_VERINFO_DPVOICE " Debug\0"
#define DPVOICE_VERINFO_DPVOICE_RETAIL  DPVOICE_VERINFO_DPVOICE "\0"
#define DPVOICE_VERINFO_DPVOICE_WINNT   DPVOICE_VERINFO_DPVOICE
#define DPVOICE_VERNAME_DPVOICE_WIN9X   DPVOICE_FILENAME_DPVOICE_A "\0"
#define DPVOICE_VERNAME_DPVOICE_WINNT   DPVOICE_FILENAME_DPVOICE_A

// dpvvox
#define DPVOICE_VERINFO_DPVVOX           "Microsoft DirectPlay Voice Voxware Provider"
#define DPVOICE_VERINFO_DPVVOX_DEBUG    DPVOICE_VERINFO_DPVVOX " Debug\0"
#define DPVOICE_VERINFO_DPVVOX_RETAIL   DPVOICE_VERINFO_DPVVOX "\0"
#define DPVOICE_VERINFO_DPVVOX_WINNT    DPVOICE_VERINFO_DPVVOX
#define DPVOICE_VERNAME_DPVVOX_WIN9X   DPVOICE_FILENAME_DPVVOX_A "\0"
#define DPVOICE_VERNAME_DPVVOX_WINNT   DPVOICE_FILENAME_DPVVOX_A

// dpvacm
#define DPVOICE_VERINFO_DPVACM          "Microsoft DirectPlay Voice ACM Provider"
#define DPVOICE_VERINFO_DPVACM_DEBUG    DPVOICE_VERINFO_DPVACM " Debug\0"
#define DPVOICE_VERINFO_DPVACM_RETAIL   DPVOICE_VERINFO_DPVACM "\0"
#define DPVOICE_VERINFO_DPVACM_WINNT    DPVOICE_VERINFO_DPVACM
#define DPVOICE_VERNAME_DPVACM_WIN9X   DPVOICE_FILENAME_DPVACM_A "\0"
#define DPVOICE_VERNAME_DPVACM_WINNT   DPVOICE_FILENAME_DPVACM_A

// dpvsetup
#define DPVOICE_VERINFO_DPVSETUP         "Microsoft DirectPlay Voice Test"
#define DPVOICE_VERINFO_DPVSETUP_DEBUG  DPVOICE_VERINFO_DPVSETUP " Debug\0"
#define DPVOICE_VERINFO_DPVSETUP_RETAIL DPVOICE_VERINFO_DPVSETUP "\0"
#define DPVOICE_VERINFO_DPVSETUP_WINNT  DPVOICE_VERINFO_DPVSETUP
#define DPVOICE_VERNAME_DPVSETUP_WIN9X   DPVOICE_FILENAME_DPVSETUP_A "\0"
#define DPVOICE_VERNAME_DPVSETUP_WINNT   DPVOICE_FILENAME_DPVSETUP_A

// dplayx
#define DPLAY_VERINFO_DPLAY         	"Microsoft DirectPlay"
#define DPLAY_VERINFO_DPLAY_DEBUG  	    DPLAY_VERINFO_DPLAY " Debug\0"
#define DPLAY_VERINFO_DPLAY_RETAIL 	    DPLAY_VERINFO_DPLAY "\0"
#define DPLAY_VERINFO_DPLAY_WINNT  	    DPLAY_VERINFO_DPLAY
#define DPLAY_VERNAME_DPLAY_WIN9X   	DPLAY_FILENAME_DPLAYX_A "\0"
#define DPLAY_VERNAME_DPLAY_WINNT   	DPLAY_FILENAME_DPLAYX_A

// dplayx
#define DPLAY_VERINFO_DPWSOCKX         	"Internet TCP/IP and IPX Connection For DirectPlay"
#define DPLAY_VERINFO_DPWSOCKX_DEBUG  	DPLAY_VERINFO_DPWSOCKX " Debug\0"
#define DPLAY_VERINFO_DPWSOCKX_RETAIL 	DPLAY_VERINFO_DPWSOCKX "\0"
#define DPLAY_VERINFO_DPWSOCKX_WINNT  	DPLAY_VERINFO_DPWSOCKX
#define DPLAY_VERNAME_DPWSOCKX_WIN9X   	DPLAY_FILENAME_DPWSOCKX_A "\0"
#define DPLAY_VERNAME_DPWSOCKX_WINNT   	DPLAY_FILENAME_DPWSOCKX_A

// dpvhelp
#define DPVOICE_VERINFO_DPVHELP         "Microsoft DirectPlay Voice"
#define DPVOICE_VERINFO_DPVHELP_DEBUG  DPVOICE_VERINFO_DPVHELP " Debug\0"
#define DPVOICE_VERINFO_DPVHELP_RETAIL DPVOICE_VERINFO_DPVHELP "\0"
#define DPVOICE_VERINFO_DPVHELP_WINNT  DPVOICE_VERINFO_DPVHELP
#define DPVOICE_VERNAME_DPVHELP_WIN9X  DPVOICE_FILENAME_DPVHELP_A "\0"
#define DPVOICE_VERNAME_DPVHELP_WINNT  DPVOICE_FILENAME_DPVHELP_A


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\classhash.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ClassHash.h
 *  Content:	Hash table that takes a class as a key.  The key class MUST support
 *				two member functions:
 *				'HashFunction' will perform a hash down to a specified number of bits.
 *				'CompareFunction' will perform a comparison of two items of that class.
 *
 *				Note: This class requires an FPM to operate.
 *
 *				THIS CLASS IS NOT THREAD SAFE!!
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/15/98	jwo		Created it (map).
 *	04/19/99	jtk		Rewrote without using STL (map)
 *	08/03/99	jtk		Derived from ClassMap.h
 ***************************************************************************/

#ifndef __CLASS_HASH_H__
#define __CLASS_HASH_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	OFFSETOF
// Macro to compute the offset of an element inside of a larger structure (copied from MSDEV's STDLIB.H)
#define OFFSETOF(s,m)	( (INT_PTR) &(((s *)0)->m) )
#define	__LOCAL_OFFSETOF_DEFINED__
#endif	// OFFSETOF

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable prototypes
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definitions
//**********************************************************************

//
// Template class for entry in map.
//
template<class T, class S>
class CClassHashEntry
{
	public:
		CClassHashEntry(){};
		~CClassHashEntry(){};


		//
		// internals, put the linkage at the end to make sure the FPM doesn't
		// wail on it!
		//
		PVOID		m_FPMPlaceHolder;
		S			m_Key;
		T			m_Item;
		CBilink		m_Linkage;

		//
		// linkage functions
		//
		static	CClassHashEntry	*EntryFromBilink( CBilink *const pLinkage )
		{
			DBG_CASSERT( sizeof( void* ) == sizeof( INT_PTR ) );
			return	reinterpret_cast<CClassHashEntry*>( &reinterpret_cast<BYTE*>( pLinkage )[ -OFFSETOF( CClassHashEntry, m_Linkage ) ] );
		}

		void	AddToList( CBilink *const pLinkage )
		{
			m_Linkage.InsertAfter( pLinkage );
		}

		void	RemoveFromList( void )
		{
			m_Linkage.RemoveFromList();
		}

		//
		// pool management functions
		//
		#undef DPF_MODNAME
		#define DPF_MODNAME "CClassHashEntry::InitAlloc"
		static	BOOL	InitAlloc( void *pItem )
		{
			CClassHashEntry<T,S>	*pThisObject;

			DNASSERT( pItem != NULL );
			pThisObject = static_cast<CClassHashEntry<T,S>*>( pItem );

			pThisObject->m_Linkage.Initialize();
			return	TRUE;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CClassHashEntry::Init"
		static	void	Init( void *pItem )
		{
			CClassHashEntry<T,S>	*pThisObject;

			DNASSERT( pItem != NULL );
			pThisObject = static_cast<CClassHashEntry<T,S>*>( pItem );
			DNASSERT( pThisObject->m_Linkage.IsEmpty() != FALSE );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CClassHashEntry::Release"
		static	void	Release( void *pItem )
		{
			CClassHashEntry<T,S>	*pThisObject;

			DNASSERT( pItem != NULL );
			pThisObject = static_cast<CClassHashEntry<T,S>*>( pItem );
			DNASSERT( pThisObject->m_Linkage.IsEmpty() != FALSE );			
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CClassHashEntry::Dealloc"
		static	void	Dealloc( void *pItem )
		{
			CClassHashEntry<T,S>	*pThisObject;

			DNASSERT( pItem != NULL );
			pThisObject = static_cast<CClassHashEntry<T,S>*>( pItem );
			DNASSERT( pThisObject->m_Linkage.IsEmpty() != FALSE );
		}

	protected:

	private:

	//
	// make copy constructor and assignment operator private and unimplemented
	// to prevent illegal copies from being made
	//
	CClassHashEntry( const CClassHashEntry & );
	CClassHashEntry& operator=( const CClassHashEntry & );
};


//
// template class for the map
//
template<class T, class S>
class	CClassHash
{
	public:
		CClassHash();
		~CClassHash();

		BOOL	Initialize( const INT_PTR iBitDepth, const INT_PTR iGrowBits );
		void	Deinitialize( void );
		BOOL	Insert( const S& Key, T Item );
		void	Remove( const S& Key );
		BOOL	RemoveLastEntry( T *const pItem );
		BOOL	Find( const S& Key, T *const pItem );
		BOOL	IsEmpty( void ) { return ( m_iEntriesInUse == 0 ); }

		INT_PTR		m_iHashBitDepth;		// number of bits used for hash entry
		INT_PTR		m_iGrowBits;			// number of bits to grow has by
		CBilink		*m_pHashEntries;		// list of hash entries
		INT_PTR		m_iAllocatedEntries;	// count of allocated entries in index/item list
		INT_PTR		m_iEntriesInUse;		// count of entries in use
		FPOOL		m_EntryPool;			// pool of entries

	private:
		DEBUG_ONLY(	BOOL	m_fInitialized );

		BOOL	LocalFind( const S& Key, CBilink **const ppLink );
		void	Grow( void );
		void	InitializeHashEntries( const UINT_PTR uEntryCount ) const;

		//
		// make copy constructor and assignment operator private and unimplemented
		// to prevent illegal copies from being made
		//
		CClassHash( const CClassHash & );
		CClassHash& operator=( const CClassHash & );
};

//**********************************************************************
// Class function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::CClassHash - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::CClassHash"

template<class T, class S>
CClassHash< T, S >::CClassHash():
	m_iHashBitDepth( 0 ),
	m_iGrowBits( 0 ),
	m_pHashEntries( NULL ),
	m_iAllocatedEntries( 0 ),
	m_iEntriesInUse( 0 )
{
	//
	// clear internals
	//
	DEBUG_ONLY( m_fInitialized = FALSE );
	memset( &m_EntryPool, 0x00, sizeof( m_EntryPool ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::~CClassHash - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::~CClassHash"

template<class T, class S>
CClassHash< T, S >::~CClassHash()
{
	DNASSERT( m_iHashBitDepth == 0 );
	DNASSERT( m_iGrowBits == 0 );
	DNASSERT( m_pHashEntries == NULL );
	DNASSERT( m_iAllocatedEntries == 0 );
	DNASSERT( m_iEntriesInUse == 0 );
	DEBUG_ONLY( DNASSERT( m_fInitialized == FALSE ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::Initialize - initialize hash table
//
// Entry:		Pointer to key
//				Pointer to 'key' associated with this item
//				Pointer to item to add
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::Initialize"

template<class T, class S>
BOOL	CClassHash< T, S >::Initialize( const INT_PTR iBitDepth, const INT_PTR iGrowBits )
{
	BOOL		fReturn;


	DNASSERT( iBitDepth != 0 );

	//
	// initialize
	//
	fReturn = TRUE;

	DNASSERT( m_pHashEntries == NULL );
	m_pHashEntries = static_cast<CBilink*>( DNMalloc( sizeof( *m_pHashEntries ) * ( 1 << iBitDepth ) ) );
	if ( m_pHashEntries == NULL )
	{
		fReturn = FALSE;
		DPFX(DPFPREP,  0, "Unable to allocate memory for hash table!" );
		goto Exit;
	}
	m_iAllocatedEntries = 1 << iBitDepth;
	InitializeHashEntries( m_iAllocatedEntries );

	if ( FPM_Initialize( &m_EntryPool,						// pointer to pool
						 sizeof( CClassHashEntry<T,S> ),	// size of pool entry
						 CClassHashEntry<T,S>::InitAlloc,	// function for allocating item
						 CClassHashEntry<T,S>::Init,		// function for getting item from pool
						 CClassHashEntry<T,S>::Release,		// function for releasing item
						 CClassHashEntry<T,S>::Dealloc		// function for deallocating item
						 ) == FALSE )
	{
		DPFX(DPFPREP,  0, "Failed to initialize FPM!" );
		fReturn = FALSE;
	}

	m_iHashBitDepth = iBitDepth;
	m_iGrowBits = iGrowBits;

	DEBUG_ONLY( m_fInitialized = TRUE );

Exit:
	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::Deinitialize - deinitialize hash table
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::Deinitialize"

template<class T, class S>
void	CClassHash< T, S >::Deinitialize( void )
{
	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );
	DNASSERT( m_iEntriesInUse == 0 );
	DNASSERT( m_pHashEntries != NULL );
	
	DNFree( m_pHashEntries );
	m_pHashEntries = NULL;
	FPM_Deinitialize( &m_EntryPool );
	
	m_iHashBitDepth = 0;
	m_iGrowBits = 0;
	m_iAllocatedEntries = 0;
	DEBUG_ONLY( m_fInitialized = FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::Insert - add item to map
//
// Entry:		Pointer to 'key' associated with this item
//				Pointer to item to add
//
// Exit:		Boolean indicating success:
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::Insert"

template<class T, class S>
BOOL	CClassHash< T, S >::Insert( const S& Key, T Item )
{
	BOOL	fReturn;
	BOOL	fFound;
	CBilink	*pLink;
	CClassHashEntry< T, S >	*pNewEntry;

	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );

	//
	// initialize
	//
 	fReturn = TRUE;
	pNewEntry = NULL;

	//
	// grow the map if applicable
	//
	if ( ( m_iEntriesInUse >= ( m_iAllocatedEntries / 2 ) ) &&
		 ( m_iGrowBits != 0 ) )
	{
		Grow();
	}

	//
	// get a new table entry before trying the lookup
	//
	pNewEntry = static_cast<CClassHashEntry<T,S>*>( m_EntryPool.Get( &m_EntryPool ) );
	if ( pNewEntry == NULL )
	{
		fReturn = FALSE;
		DPFX(DPFPREP,  0, "Problem allocating new hash table entry on Insert!" );
		goto Exit;
	}

	//
	// scan for this item in the list, since we're only supposed to have
	// unique items in the list, ASSERT if a duplicate is found
	//
	fFound = LocalFind( Key, &pLink );
	DNASSERT( pLink != NULL );
	DNASSERT( fFound == FALSE );

	//
	// officially add entry to the hash table
	//
	m_iEntriesInUse++;
	pNewEntry->m_Key = Key;
	pNewEntry->m_Item = Item;
	DNASSERT( pLink != NULL );
	pNewEntry->AddToList( pLink );

	DNASSERT( fReturn == TRUE );

Exit:
	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::Remove - remove item from map
//
// Entry:		Reference to 'key' used to look up this item
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::Remove"

template<class T, class S>
void	CClassHash< T, S >::Remove( const S& Key )
{
	CBilink	*pLink;


	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );
	if ( LocalFind( Key, &pLink ) != FALSE )
	{
		CClassHashEntry< T, S >	*pEntry;


		DNASSERT( pLink != NULL );
		pEntry = CClassHashEntry< T, S >::EntryFromBilink( pLink );
		pEntry->RemoveFromList();
		m_EntryPool.Release( &m_EntryPool, pEntry );

		DNASSERT( m_iEntriesInUse != 0 );
		m_iEntriesInUse--;
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::RemoveLastEntry - remove last item from map
//
// Entry:		Pointer to pointer to item data
//
// Exit:		Boolean indicating success
//				TRUE = item was removed
//				FALSE = item was not removed (map empty)
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::RemoveLastEntry"

template<class T, class S>
BOOL	CClassHash< T, S >::RemoveLastEntry( T *const pItem )
{
	BOOL	fReturn;


	DNASSERT( pItem != NULL );

	//
	// initialize
	//
	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );
	fReturn = FALSE;

	if ( m_iEntriesInUse != 0 )
	{
		INT_PTR	iIndex;


		DNASSERT( m_pHashEntries != NULL );
		iIndex = m_iAllocatedEntries;
		while ( iIndex > 0 )
		{
			iIndex--;

			if ( m_pHashEntries[ iIndex ].IsEmpty() == FALSE )
			{
				CClassHashEntry<T,S>	*pEntry;


				pEntry = pEntry->EntryFromBilink( m_pHashEntries[ iIndex ].GetNext() );
				pEntry->RemoveFromList();
				*pItem = pEntry->m_Item;
				m_EntryPool.Release( &m_EntryPool, pEntry );
				m_iEntriesInUse--;
				fReturn = TRUE;

				goto Exit;
			}
		}
	}

Exit:
	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::Find - find item in map
//
// Entry:		Reference of 'key' used to look up this item
//				Pointer to pointer to be filled in with data
//
// Exit:		Boolean indicating success
//				TRUE = item found
//				FALSE = item not found
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::Find"

template<class T, class S>
BOOL	CClassHash< T, S >::Find( const S& Key, T *const pItem )
{
	BOOL	fReturn;
	CBilink	*pLinkage;


	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );

	//
	// initialize
	//
	fReturn = FALSE;
	pLinkage = NULL;

	if ( LocalFind( Key, &pLinkage ) != FALSE )
	{
		CClassHashEntry<T,S>	*pEntry;


		pEntry = CClassHashEntry<T,S>::EntryFromBilink( pLinkage );
		*pItem = pEntry->m_Item;
		fReturn = TRUE;
	}

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::LocalFind - find an entry in a hash table, or find out where to insert.
//
// Entry:		Refernce of 'key' to look for
//				Pointer to pointer to linkage of find or insert
//
// Exit:		Boolean indicating whether the item was found
//				TRUE = found
//				FALSE = not found
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::LocalFind"

template<class T, class S>
BOOL	CClassHash< T, S >::LocalFind( const S& Key, CBilink **const ppLinkage )
{
	BOOL		fFound;
	INT_PTR		HashResult;
	CBilink		*pTemp;


	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );

	HashResult = Key->HashFunction( m_iHashBitDepth );
	DNASSERT( ( HashResult < ( 1 << m_iHashBitDepth ) ) &&
			  ( HashResult >= 0 ) );

	fFound = FALSE;
	pTemp = &m_pHashEntries[ HashResult ];
	while ( pTemp->GetNext() != &m_pHashEntries[ HashResult ] )
	{
		const CClassHashEntry< T, S >	*pEntry;


		pEntry = CClassHashEntry< T, S >::EntryFromBilink( pTemp->GetNext() );
		if ( Key->CompareFunction( pEntry->m_Key ) == 0 )
		{
			fFound = TRUE;
			*ppLinkage = pTemp->GetNext();
			goto Exit;
		}
		else
		{
			pTemp = pTemp->GetNext();
		}
	}

	//
	// entry was not found, return pointer to linkage to insert after if a new
	// entry is being added to the table
	//
	*ppLinkage = pTemp;

Exit:
	return	fFound;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::Grow - grow hash table to next larger size
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::Grow"

template<class T, class S>
void	CClassHash< T, S >::Grow( void )
{
	CBilink	*pTemp;
	INT_PTR	iNewEntryBitCount;


	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );
	DNASSERT( m_iGrowBits != 0 );

	//
	// We're more than 50% full, find a new has table size that will accomodate
	// all of the current entries, and keep a pointer to the old data in case
	// the memory allocation fails.
	//
	pTemp = m_pHashEntries;
	iNewEntryBitCount = m_iHashBitDepth;

	do
	{
		iNewEntryBitCount += m_iGrowBits;
	} while ( m_iEntriesInUse >= ( ( 1 << iNewEntryBitCount ) / 2 ) );

	//
	// assert that we don't pull up half of the machine's address space!
	//
	DNASSERT( iNewEntryBitCount <= ( sizeof( UINT_PTR ) * 8 / 2 ) );

	m_pHashEntries = static_cast<CBilink*>( DNMalloc( sizeof( *pTemp ) * ( 1 << iNewEntryBitCount ) ) );
	if ( m_pHashEntries == NULL )
	{
		//
		// Allocation failed, restore the old data pointer and insert the item
		// into the hash table.  This will probably result in adding to a bucket.
		//
		m_pHashEntries = pTemp;
		DPFX(DPFPREP,  0, "Warning: Failed to grow hash table when 50% full!" );
	}
	else
	{
		INT_PTR		iOldHashSize;
		DEBUG_ONLY( INT_PTR		iOldEntryCount );


		//
		// we have more memory, reorient the hash table and re-add all of
		// the old items
		//
		InitializeHashEntries( 1 << iNewEntryBitCount );
		DEBUG_ONLY( iOldEntryCount = m_iEntriesInUse );

		iOldHashSize = 1 << m_iHashBitDepth;
		m_iHashBitDepth = iNewEntryBitCount;

		m_iAllocatedEntries = 1 << iNewEntryBitCount;
		m_iEntriesInUse = 0;

		DNASSERT( iOldHashSize > 0 );
		while ( iOldHashSize > 0 )
		{
			iOldHashSize--;
			while ( pTemp[ iOldHashSize ].GetNext() != &pTemp[ iOldHashSize ] )
			{
				BOOL	fTempReturn;
				S		Key;
				T		Item;
				CClassHashEntry<T,S>	*pTempEntry;


				pTempEntry = pTempEntry->EntryFromBilink( pTemp[ iOldHashSize ].GetNext() );
				pTempEntry->RemoveFromList();
				Key = pTempEntry->m_Key;
				Item = pTempEntry->m_Item;
				m_EntryPool.Release( &m_EntryPool, pTempEntry );

				//
				// Since we're returning the current hash table entry to the pool
				// it will be immediately reused in the new table.  We should never
				// have a problem adding to the new list.
				//
				fTempReturn = Insert( Key, Item );
				DNASSERT( fTempReturn != FALSE );
				DEBUG_ONLY( iOldEntryCount-- );
			}
		}

		DEBUG_ONLY( DNASSERT( iOldEntryCount == 0 ) );
		DNFree( pTemp );
		pTemp = NULL;
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::InitializeHashEntries - initialize all of the entries in the hash table
//
// Entry:		Count of entries to initialize.
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::InitializeHashEntries"

template<class T, class S>
void	CClassHash< T, S >::InitializeHashEntries( const UINT_PTR uEntryCount ) const
{
	UINT_PTR	uLocalEntryCount;


	DNASSERT( m_pHashEntries != NULL );
	uLocalEntryCount = uEntryCount;
	while ( uLocalEntryCount != 0 )
	{
		uLocalEntryCount--;

		m_pHashEntries[ uLocalEntryCount ].Initialize();
	}
}
//**********************************************************************

#ifdef	__LOCAL_OFFSETOF_DEFINED__
#undef	__LOCAL_OFFSETOF_DEFINED__
#undef	OFFSETOF
#endif	// __LOCAL_OFFSETOF_DEFINED__

#undef DPF_SUBCOMP
#undef DPF_MODNAME

#endif	// __CLASS_HASH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\classhashvc.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ClassHash.h
 *  Content:	Hash table that takes a class as a key.  The key class MUST support
 *				two member functions:
 *				'HashFunction' will perform a hash down to a specified number of bits.
 *				'CompareFunction' will perform a comparrisson of two items of that class.
 *
 *				Note: This class requires an FPM to operate.
 *
 *				THIS CLASS IS NOT THREAD SAFE!!
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/15/98	jwo		Created it (map).
 *	04/19/99	jtk		Rewrote without using STL (map)
 *	08/03/99	jtk		Derived from ClassMap.h
 ***************************************************************************/

#ifndef __CLASS_HASH_H__
#define __CLASS_HASH_H__

#include "dndbg.h"
#include "classbilink.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable prototypes
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definitions
//**********************************************************************


// Macro to compute the offset of an element inside of a larger structure.
// Copied from MSDEV's STDLIB.H and modified to return INT_PTR
//
#define OFFSETOF(s,m)	( ( INT_PTR ) &( ( (s*) 0 )->m ) )
//
// Template class for entry in map.
//
template<class T, class S>
class CClassHashEntry
{
	public:
		CClassHashEntry(){};
		~CClassHashEntry(){};


		//
		// internals, put the linkage at the end to make sure the FPM doesn't
		// wail on it!
		//
		PVOID		m_FPMPlaceHolder;
		S			m_Key;
		T			*m_pItem;
		CBilink		m_Linkage;

		//
		// linkage functions
		//
		#undef DPF_MODNAME
		#define DPF_MODNAME "CClassHashEntry::EntryFromBilink"
		static	CClassHashEntry	*EntryFromBilink( CBilink *const pLinkage )
		{
			DBG_CASSERT( sizeof( void* ) == sizeof( INT_PTR ) );
			return	reinterpret_cast<CClassHashEntry*>( &reinterpret_cast<BYTE*>( pLinkage )[ -OFFSETOF( CClassHashEntry, m_Linkage ) ] );
		}

		void	AddToList( CBilink &Linkage )
		{
			m_Linkage.InsertAfter( &Linkage );
		}

		void	RemoveFromList( void )
		{
			m_Linkage.RemoveFromList();
		}

		//
		// pool management functions
		//
		#undef DPF_MODNAME
		#define DPF_MODNAME "CClassHashEntry::InitAlloc"
		static	BOOL	InitAlloc( void *pItem )
		{
			CClassHashEntry<T,S>	*pThisObject;


			DNASSERT( pItem != NULL );
			pThisObject = static_cast<CClassHashEntry<T,S>*>( pItem );

			pThisObject->m_pItem = NULL;
			pThisObject->m_Linkage.Initialize();
			return	TRUE;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CClassHashEntry::Init"
		static	void	Init( void *pItem )
		{
			CClassHashEntry<T,S>	*pThisObject;

			DNASSERT( pItem != NULL );
			pThisObject = static_cast<CClassHashEntry<T,S>*>( pItem );
			DNASSERT( pThisObject->m_pItem == NULL );
			DNASSERT( pThisObject->m_Linkage.IsEmpty() != FALSE );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CClassHashEntry::Release"
		static	void	Release( void *pItem )
		{
			CClassHashEntry<T,S>	*pThisObject;

			DNASSERT( pItem != NULL );
			pThisObject = static_cast<CClassHashEntry<T,S>*>( pItem );
			pThisObject->m_pItem = NULL;
			DNASSERT( pThisObject->m_Linkage.IsEmpty() != FALSE );			
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CClassHashEntry::Dealloc"
		static	void	Dealloc( void *pItem )
		{
			CClassHashEntry<T,S>	*pThisObject;

			DNASSERT( pItem != NULL );
			pThisObject = static_cast<CClassHashEntry<T,S>*>( pItem );
			DNASSERT( pThisObject->m_pItem == NULL );
			DNASSERT( pThisObject->m_Linkage.IsEmpty() != FALSE );
		}

	protected:

	private:

	//
	// make copy constructor and assignment operator private and unimplemented
	// to prevent illegal copies from being made
	//
	CClassHashEntry( const CClassHashEntry & );
	CClassHashEntry& operator=( const CClassHashEntry & );
};


//
// template class for the map
//
template<class T, class S>
class	CClassHash
{
	public:
		CClassHash();
		~CClassHash();

		BOOL	Initialize( const INT_PTR iBitDepth, const INT_PTR iGrowBits );
		void	Deinitialize( void );
		BOOL	Insert( const S Key, T *const pItem );
		void	Remove( const S Key );
		BOOL	RemoveLastEntry( T **const ppItem );
		BOOL	Find( const S Key, T **const ppItem );
		BOOL	IsEmpty( void ) { return ( m_iEntriesInUse == 0 ); }

		INT_PTR		m_iHashBitDepth;		// number of bits used for hash entry
		INT_PTR		m_iGrowBits;			// number of bits to grow has by
		CBilink		*m_pHashEntries;		// list of hash entries
		INT_PTR		m_iAllocatedEntries;	// count of allocated entries in index/item list
		INT_PTR		m_iEntriesInUse;		// count of entries in use
		FPOOL		m_EntryPool;			// pool of entries
	private:

		BOOL	m_fInitialized;

		BOOL	LocalFind( const S Key, CBilink **const ppLink );
		void	Grow( void );
		void	InitializeHashEntries( const UINT_PTR uEntryCount ) const;

		//
		// make copy constructor and assignment operator private and unimplemented
		// to prevent illegal copies from being made
		//
		CClassHash( const CClassHash & );
		CClassHash& operator=( const CClassHash & );
};

//**********************************************************************
// Class function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::CClassHash - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::CClassHash"

template<class T, class S>
CClassHash< T, S >::CClassHash(): m_iHashBitDepth( 0 ),m_iGrowBits( 0 ),
		m_pHashEntries( NULL ),m_iAllocatedEntries( 0 ),m_iEntriesInUse( 0 )
{
	//
	// clear internals
	//
	m_fInitialized = FALSE;
	memset( &m_EntryPool, 0x00, sizeof( m_EntryPool ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::~CClassHash - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::~CClassHash"

template<class T, class S>
CClassHash< T, S >::~CClassHash()
{
	DNASSERT( m_iHashBitDepth == 0 );
	DNASSERT( m_iGrowBits == 0 );
	DNASSERT( m_pHashEntries == NULL );
	DNASSERT( m_iAllocatedEntries == 0 );
	DNASSERT( m_iEntriesInUse == 0 );
	DNASSERT( m_fInitialized == FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::Initialize - initialize hash table
//
// Entry:		Pointer to key
//				Pointer to 'key' associated with this item
//				Pointer to item to add
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::Initialize"

template<class T, class S>
BOOL	CClassHash< T, S >::Initialize( const INT_PTR iBitDepth, const INT_PTR iGrowBits )
{
	BOOL		fReturn;


	DNASSERT( iBitDepth != 0 );

	//
	// initialize
	//
	fReturn = TRUE;

	DNASSERT( m_pHashEntries == NULL );
	m_pHashEntries = static_cast<CBilink*>( DNMalloc( sizeof( *m_pHashEntries ) * ( 1 << iBitDepth ) ) );
	if ( m_pHashEntries == NULL )
	{
		fReturn = FALSE;
		DPFX(DPFPREP,  0, "Unable to allocate memory for hash table!" );
		goto Exit;
	}
	m_iAllocatedEntries = 1 << iBitDepth;
	InitializeHashEntries( m_iAllocatedEntries );

	FPM_Initialize( &m_EntryPool,						// pointer to pool
						 sizeof( CClassHashEntry<T,S> ),	// size of pool entry
						 CClassHashEntry<T,S>::InitAlloc,	// function for allocating item
						 CClassHashEntry<T,S>::Init,		// function for getting item from pool
						 CClassHashEntry<T,S>::Release,		// function for releasing item
						 CClassHashEntry<T,S>::Dealloc		// function for deallocating item
						 );
	m_iHashBitDepth = iBitDepth;
	m_iGrowBits = iGrowBits;

	m_fInitialized = TRUE;

Exit:
	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::Deinitialize - deinitialize hash table
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::Deinitialize"

template<class T, class S>
void	CClassHash< T, S >::Deinitialize( void )
{
	if( !m_fInitialized )
		return;

	DNASSERT( m_iEntriesInUse == 0 );
	DNASSERT( m_pHashEntries != NULL );
	DNFree( m_pHashEntries );
	m_pHashEntries = NULL;
	FPM_Deinitialize( &m_EntryPool );
	m_fInitialized = FALSE;
	m_iHashBitDepth = 0;
	m_iGrowBits = 0;
	m_iAllocatedEntries = 0;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::Insert - add item to map
//
// Entry:		Pointer to 'key' associated with this item
//				Pointer to item to add
//
// Exit:		Boolean indicating success:
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::Insert"

template<class T, class S>
BOOL	CClassHash< T, S >::Insert( const S Key, T *const pItem )
{
	BOOL	fReturn;
	BOOL	fFound;
	CBilink	*pLink;
	CClassHashEntry< T, S >	*pNewEntry;


	DNASSERT( pItem != NULL );
	DNASSERT( m_fInitialized != FALSE );

	//
	// initialize
	//
 	fReturn = TRUE;
	pNewEntry = NULL;

	//
	// grow the map if applicable
	//
	if ( m_iEntriesInUse >= ( m_iAllocatedEntries / 2 ) )
	{
		Grow();
	}

	//
	// get a new table entry before trying the lookup
	//
	pNewEntry = static_cast<CClassHashEntry<T,S>*>( m_EntryPool.Get( &m_EntryPool ) );
	if ( pNewEntry == NULL )
	{
		fReturn = FALSE;
		DPFX(DPFPREP,  0, "Problem allocating new hash table entry on Insert!" );
		goto Exit;
	}

	//
	// scan for this item in the list, since we're only supposed to have
	// unique items in the list, ASSERT if a duplicate is found
	//
	fFound = LocalFind( Key, &pLink );
	DNASSERT( pLink != NULL );
	DNASSERT( fFound == FALSE );

	//
	// officially add entry to the hash table
	//
	m_iEntriesInUse++;
	pNewEntry->m_Key = Key;
	pNewEntry->m_pItem = pItem;
	DNASSERT( pLink != NULL );
	pNewEntry->AddToList( *pLink );

	DNASSERT( fReturn == TRUE );

Exit:
	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::Remove - remove item from map
//
// Entry:		Reference to 'key' used to look up this item
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::Remove"

template<class T, class S>
void	CClassHash< T, S >::Remove( const S Key )
{
	CBilink	*pLink;


	DNASSERT( m_fInitialized != FALSE );
	if ( LocalFind( Key, &pLink ) != FALSE )
	{
		CClassHashEntry< T, S >	*pEntry;


		DNASSERT( pLink != NULL );
		pEntry = pEntry->EntryFromBilink( pLink );
		pEntry->RemoveFromList();
		m_EntryPool.Release( &m_EntryPool, pEntry );

		DNASSERT( m_iEntriesInUse != 0 );
		m_iEntriesInUse--;
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::RemoveLastEntry - remove last item from map
//
// Entry:		Pointer to pointer to 'key'
//				Pointer to pointer to item data
//
// Exit:		Boolean indicating success
//				TRUE = item was removed
//				FALSE = item was not removed (map empty)
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::RemoveLastEntry"

template<class T, class S>
BOOL	CClassHash< T, S >::RemoveLastEntry( T **const ppItem )
{
	BOOL	fReturn;


	DNASSERT( ppItem != NULL );

	//
	// initialize
	//
	DNASSERT( m_fInitialized != FALSE );
	fReturn = FALSE;

	if ( m_iEntriesInUse != 0 )
	{
		INT_PTR	iIndex;


		DNASSERT( m_pHashEntries != NULL );
		iIndex = m_iAllocatedEntries;
		while ( iIndex > 0 )
		{
			iIndex--;

			if ( m_pHashEntries[ iIndex ].IsEmpty() == FALSE )
			{
				CClassHashEntry<T,S>	*pEntry;


				pEntry = pEntry->EntryFromBilink( m_pHashEntries[ iIndex ].GetNext() );
				pEntry->RemoveFromList();
				*ppItem = pEntry->m_pItem;
				m_EntryPool.Release( &m_EntryPool, pEntry );
				m_iEntriesInUse--;
				fReturn = TRUE;

				goto Exit;
			}
		}
	}

Exit:
	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::Find - find item in map
//
// Entry:		Reference of 'key' used to look up this item
//				Pointer to pointer to be filled in with data
//
// Exit:		Boolean indicating success
//				TRUE = item found
//				FALSE = item not found
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::Find"

template<class T, class S>
BOOL	CClassHash< T, S >::Find( const S Key, T **const ppItem )
{
	BOOL	fReturn;
	CBilink	*pLinkage;


	DNASSERT( m_fInitialized != FALSE );

	//
	// initialize
	//
	fReturn = FALSE;
	pLinkage = NULL;

	if ( LocalFind( Key, &pLinkage ) != FALSE )
	{
		CClassHashEntry<T,S>	*pEntry;


		pEntry = pEntry->EntryFromBilink( pLinkage );
		*ppItem = pEntry->m_pItem;
		fReturn = TRUE;
	}

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::LocalFind - find an entry in a hash table, or find out where to insert.
//
// Entry:		Refernce of 'key' to look for
//				Pointer to pointer to linkage of find or insert
//
// Exit:		Boolean indicating whether the item was found
//				TRUE = found
//				FALSE = not found
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::LocalFind"

template<class T, class S>
BOOL	CClassHash< T, S >::LocalFind( const S Key, CBilink **const ppLinkage )
{
	BOOL		fFound;
	DWORD_PTR	HashResult;
	CBilink		*pTemp;


	DNASSERT( m_fInitialized != FALSE );

	HashResult = ClassHash_Hash( Key, m_iHashBitDepth );
	DNASSERT( HashResult < ( 1 << m_iHashBitDepth ) );
//	DNASSERT( HashResult >= 0 );	-- REMOVED by MiNara

	fFound = FALSE;
	pTemp = &m_pHashEntries[ HashResult ];
	while ( pTemp->GetNext() != &m_pHashEntries[ HashResult ] )
	{
		const CClassHashEntry< T, S >	*pEntry;


		pEntry = CClassHashEntry< T, S >::EntryFromBilink( pTemp->GetNext() );
		if ( Key == pEntry->m_Key )
		{
			fFound = TRUE;
			*ppLinkage = pTemp->GetNext();
			goto Exit;
		}
		else
		{
			pTemp = pTemp->GetNext();
		}
	}

	//
	// entry was not found, return pointer to linkage to insert after if a new
	// entry is being added to the table
	//
	*ppLinkage = pTemp;

Exit:
	return	fFound;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::Grow - grow hash table to next larger size
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::Grow"

template<class T, class S>
void	CClassHash< T, S >::Grow( void )
{
	CBilink	*pTemp;
	INT_PTR	iNewEntryBitCount;


	DNASSERT( m_fInitialized != FALSE );

	//
	// We're more than 50% full, find a new has table size that will accomodate
	// all of the current entries, and keep a pointer to the old data
	// in case the memory allocation fails.
	//
	pTemp = m_pHashEntries;
	iNewEntryBitCount = m_iHashBitDepth;

	do
	{
		iNewEntryBitCount += m_iGrowBits;
	} while ( m_iEntriesInUse >= ( ( 1 << iNewEntryBitCount ) / 2 ) );

	//
	// assert that we don't consume half of the machine's address space!
	//
	DNASSERT( iNewEntryBitCount <= ( sizeof( UINT_PTR ) * 8 / 2 ) );

	m_pHashEntries = static_cast<CBilink*>( DNMalloc( sizeof( *pTemp ) * ( 1 << iNewEntryBitCount ) ) );
	if ( m_pHashEntries == NULL )
	{
		//
		// Allocation failed, restore the old data pointer and insert the item
		// into the hash table.  This will probably result in adding to a bucket.
		//
		m_pHashEntries = pTemp;
		DPFX(DPFPREP,  0, "Warning: Failed to grow hash table when 50% full!" );
	}
	else
	{
		INT_PTR		iOldHashSize;
		INT_PTR		iOldEntryCount;


		//
		// we have more memory, reorient the hash table and re-add all of
		// the old items
		//
		InitializeHashEntries( 1 << iNewEntryBitCount );
		iOldEntryCount = m_iEntriesInUse;

		iOldHashSize = 1 << m_iHashBitDepth;
		m_iHashBitDepth = iNewEntryBitCount;

		iOldEntryCount = m_iEntriesInUse;
		m_iAllocatedEntries = 1 << iNewEntryBitCount;
		m_iEntriesInUse = 0;

		DNASSERT( iOldHashSize > 0 );
		while ( iOldHashSize > 0 )
		{
			iOldHashSize--;
			while ( pTemp[ iOldHashSize ].GetNext() != &pTemp[ iOldHashSize ] )
			{
				BOOL	fTempReturn;
				S	Key;
				T*		pItem;
				CClassHashEntry<T,S>	*pTempEntry;


				pTempEntry = pTempEntry->EntryFromBilink( pTemp[ iOldHashSize ].GetNext() );
				pTempEntry->RemoveFromList();
				Key = pTempEntry->m_Key;
				pItem = pTempEntry->m_pItem;
				m_EntryPool.Release( &m_EntryPool, pTempEntry );

				//
				// Since we're returning the current hash table entry to the pool
				// it will be immediately reused in the new table.  We should never
				// have a problem adding to the new list.
				//
				fTempReturn = Insert( Key, pItem );
				DNASSERT( fTempReturn != FALSE );
				iOldEntryCount--;
			}
		}

		DNASSERT( iOldEntryCount == 0 );
		DNFree( pTemp );
		pTemp = NULL;
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::InitializeHashEntries - initialize all of the entries in the hash table
//
// Entry:		Count of entries to initialize.
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::InitializeHashEntries"

template<class T, class S>
void	CClassHash< T, S >::InitializeHashEntries( const UINT_PTR uEntryCount ) const
{
	UINT_PTR	uLocalEntryCount;


	DNASSERT( m_pHashEntries != NULL );
	uLocalEntryCount = uEntryCount;
	while ( uLocalEntryCount != 0 )
	{
		uLocalEntryCount--;

		m_pHashEntries[ uLocalEntryCount ].Initialize();
	}
}
//**********************************************************************

#undef DPF_SUBCOMP

#endif	// __CLASS_HASH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\comutil.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       comutil.h
 *  Content:    Defines COM helper functions for DPLAY8 project.
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   06/07/00	rmt		Created
 *   06/27/00	rmt		Added abstraction for COM_Co(Un)Initialize
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

HRESULT COM_Init();
HRESULT COM_CoInitialize( void * pvParam );
void COM_CoUninitialize();
HRESULT COM_Free();
HRESULT COM_GetDLLName( GUID guidCLSID, CHAR *szPath, DWORD *pdwSize );
STDAPI COM_CoCreateInstance( REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid, LPVOID *ppv, BOOL fWarnUser = FALSE );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\classbilink.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ClassBilink.h
 *  Content:	Class-based bilink
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	09/17/99	jtk		Derived from bilink.c
 *	08/15/00	masonb		Changed assert to DNASSERT and added DNASSERT(this)
 *
 ***************************************************************************/

#ifndef __CLASS_BILINK_H__
#define __CLASS_BILINK_H__

#include "dndbg.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function Prototypes
//**********************************************************************

//**********************************************************************
// Class definitions
//**********************************************************************

class	CBilink
{
	public:
		CBilink(){};
		~CBilink(){};

		#undef DPF_MODNAME
		#define DPF_MODNAME "CBilink::Initialize"
		void	Initialize( void )
		{
			DNASSERT( this != NULL );

			m_pNext = this;
			m_pPrev = this;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CBilink::GetNext"
		CBilink	*GetNext( void ) const 
		{ 
			DNASSERT( this != NULL );

			return m_pNext; 
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CBilink::GetPrev"
		CBilink *GetPrev( void ) const 
		{ 
			DNASSERT( this != NULL );

			return m_pPrev; 
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CBilink::IsEmpty"
		BOOL	IsEmpty( void ) const
		{
			DNASSERT( this != NULL );
			DNASSERT( m_pNext != NULL );

			if ( ( m_pNext == m_pPrev ) &&
				 ( m_pNext == this ) )
			{
				return	TRUE;
			}

			return	FALSE;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CBilink::IsListMember"
		BOOL	IsListMember( const CBilink *const pList ) const
		{
			CBilink *	pTemp;


			DNASSERT( this != NULL );
			DNASSERT( pList != NULL );

			pTemp = pList->GetNext();
			while ( pTemp != pList )
			{
				if ( pTemp == this )
				{
					return	TRUE;
				}
				pTemp = pTemp->GetNext();
			}

			return	FALSE;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CBilink::InsertAfter"
		void	InsertAfter( CBilink* const pList )
		{
			DNASSERT( this != NULL );
			DNASSERT( pList->m_pNext != NULL );
			DNASSERT( pList->m_pPrev != NULL );
			DNASSERT( !IsListMember( pList ) );

			m_pNext = pList->m_pNext;
			m_pPrev = pList;
			pList->m_pNext->m_pPrev = this;
			pList->m_pNext = this;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CBilink::InsertBefore"
		void	InsertBefore( CBilink* const pList )
		{
			DNASSERT( this != NULL );
			DNASSERT( pList->m_pNext != NULL );
			DNASSERT( pList->m_pPrev != NULL );
			DNASSERT( !IsListMember( pList ) );

			m_pNext = pList;
			m_pPrev = pList->m_pPrev;
			pList->m_pPrev->m_pNext = this;
			pList->m_pPrev = this;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CBilink::RemoveFromList"
		void	RemoveFromList( void )
		{
			DNASSERT( this != NULL );
			DNASSERT( m_pNext != NULL );
			DNASSERT( m_pPrev != NULL );
			DNASSERT( m_pNext->m_pPrev == this );
			DNASSERT( m_pPrev->m_pNext == this );

			m_pNext->m_pPrev = m_pPrev;
			m_pPrev->m_pNext = m_pNext;
			Initialize();
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CBilink::AttachListBefore"
		void	AttachListBefore( CBilink* const pList )
		{
			CBilink*	pAddLast;


			DNASSERT( this != NULL );
			DNASSERT( pList->m_pNext != NULL );
			DNASSERT( pList->m_pPrev != NULL );
			DNASSERT( !this->IsListMember( pList ) );
			DNASSERT( !pList->IsListMember( this ) );

			pAddLast = pList->m_pPrev;

			m_pPrev->m_pNext = pList;
			pList->m_pPrev = m_pPrev;
			m_pPrev = pAddLast;
			pAddLast->m_pNext = this;
		}

	protected:

	private:
		CBilink	*m_pNext;
		CBilink	*m_pPrev;
};

#undef DPF_MODNAME
#undef DPF_SUBCOMP

#endif	// __CLASS_BILINK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\comutil.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       comutil.cpp
 *  Content:    Contains implementation of COM helper functions for DPLAY8 project.
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   06/07/00	rmt		Created
 *   06/15/2000 rmt     Fixed small bug in COM_CoCreateInstance which was causing AV
 *   06/27/00	rmt		Added abstraction for COM_Co(Un)Initialize
 *   07/06/00	rmt		Modified to match updated creg usage
 *   08/08/2000	rmt		Bug #41736 - AV in call to lstrcpy by COM_GetDllName
 *   01/11/2001	rmt		MANBUG #48487 - DPLAY: Crashes if CoCreate() isn't called.  
 *   03/14/2001 rmt		WINBUG #342420 - Restore COM emulation layer to operation.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncmni.h"
#include "comutil.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON


typedef HRESULT (WINAPI *PFNDLLGETCLASSOBJECT)(REFCLSID rclsid,REFIID riid,LPVOID *ppvObj );
typedef HRESULT (WINAPI *PFNDLLCANUNLOADNOW)(void);

CBilink g_blComEntriesGlobal;
DNCRITICAL_SECTION csComEntriesLock;

typedef struct _COMDLL_ENTRY
{
    HMODULE                 hDLL;
    CHAR                    szFileName[_MAX_PATH];
    GUID                    clsid;
    PFNDLLGETCLASSOBJECT    pfnGetClassObject;
    PFNDLLCANUNLOADNOW      pfnCanUnloadNow;
    CBilink                 blComEntries;
} COMDLL_ENTRY, *PCOMDLL_ENTRY;

#undef DPF_MODNAME
#define DPF_MODNAME "COM_Init"
HRESULT COM_Init()
{
    g_blComEntriesGlobal.Initialize();
    if (DNInitializeCriticalSection( &csComEntriesLock ) == FALSE)
	{
		return DPNERR_OUTOFMEMORY;
	}
    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "COM_Free"
HRESULT COM_Free()
{
    CBilink *pblSearch;
    PCOMDLL_ENTRY pEntry;

    pblSearch = g_blComEntriesGlobal.GetNext();

    while( pblSearch != &g_blComEntriesGlobal )
    {
        pEntry = CONTAINING_RECORD( pblSearch, COMDLL_ENTRY, blComEntries );
        pblSearch = pblSearch->GetNext();

        FreeLibrary( pEntry->hDLL );
        delete pEntry;
    }

    DNDeleteCriticalSection( &csComEntriesLock );
    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "COM_CoInitialize"
HRESULT COM_CoInitialize( void * pvParam )
{
	return CoInitializeEx( pvParam, COINIT_MULTITHREADED );
}

#undef DPF_MODNAME
#define DPF_MODNAME "COM_CoUninitialize"
void COM_CoUninitialize()
{
	CoUninitialize();
}

#undef DPF_MODNAME
#define DPF_MODNAME "COM_GetEntry"
HRESULT COM_GetEntry( GUID clsid, PCOMDLL_ENTRY *ppEntry )
{
    CBilink *pblSearch;
    PCOMDLL_ENTRY pEntry;
    HRESULT hr;
    DWORD dwSize;

    DNEnterCriticalSection( &csComEntriesLock );

    pblSearch = g_blComEntriesGlobal.GetNext();

    while( pblSearch != &g_blComEntriesGlobal )
    {
        pEntry = CONTAINING_RECORD( pblSearch, COMDLL_ENTRY, blComEntries );

		// This should never happen, but makes prefix happy
		if( !pEntry )
		{
			DNASSERT( FALSE );
            DNLeaveCriticalSection( &csComEntriesLock );
			return DPNERR_GENERIC;
		}

        if( pEntry->clsid == clsid )
        {
            *ppEntry = pEntry;
            DNLeaveCriticalSection( &csComEntriesLock );
            return DPN_OK;
        }

        pblSearch = pblSearch->GetNext();
    }

    pEntry = new COMDLL_ENTRY;
	if (pEntry == NULL)
	{
        DPFERR( "Error allocating COM entry" );
		hr = DPNERR_OUTOFMEMORY;
        goto LOAD_FAILED;
	}
    memset( pEntry, 0x00, sizeof( COMDLL_ENTRY ) );

    pEntry->clsid = clsid;
	pEntry->blComEntries.Initialize();

    dwSize = _MAX_PATH;

    hr = COM_GetDLLName( clsid, pEntry->szFileName, &dwSize );

    if( FAILED( hr ) )
    {
        DPFERR( "Unable to find DLL name for COM object" );
        goto LOAD_FAILED;
    }

    pEntry->hDLL = LoadLibraryA( pEntry->szFileName );

    if( !pEntry->hDLL )
    {
        hr = GetLastError();
        DPFX(DPFPREP,  0, "Unable to load libary err=0x%x", hr );
        goto LOAD_FAILED;
    }
    pEntry->pfnGetClassObject = (PFNDLLGETCLASSOBJECT) GetProcAddress( pEntry->hDLL, "DllGetClassObject" );
    pEntry->pfnCanUnloadNow = (PFNDLLCANUNLOADNOW) GetProcAddress( pEntry->hDLL, "DllCanUnloadNow" );

	pEntry->blComEntries.InsertBefore( &g_blComEntriesGlobal );

    DNLeaveCriticalSection( &csComEntriesLock );

    *ppEntry = pEntry;

    return DPN_OK;

LOAD_FAILED:

    if( pEntry != NULL )
	{
		if( pEntry->hDLL != NULL )
		{
			FreeLibrary( pEntry->hDLL );
		}

		delete pEntry;
	}

    DNLeaveCriticalSection( &csComEntriesLock );

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "COM_GetDLLName"
HRESULT COM_GetDLLName( GUID guidCLSID, CHAR *szPath, DWORD *pdwSize )
{
    CRegistry cregRoot;
    CRegistry cregCLSID;
    CRegistry cregInProc;

    HRESULT hr = DPN_OK;
    BOOL fSuccess;
    WCHAR *wszTmpPath = NULL;
    DWORD dwTmpSize = 0;

    fSuccess = cregRoot.Open( HKEY_CLASSES_ROOT, L"CLSID", TRUE, FALSE );

    if( !fSuccess )
    {
        DPFX(DPFPREP,  0, "Error opening HKEY_CLASSES_ROOT\\CLSID" );
        hr = E_FAIL;
        goto COM_GETDLLNAME_ERROR;
    }

    fSuccess = cregCLSID.Open( cregRoot, &guidCLSID, TRUE, FALSE );

    if( !fSuccess )
    {
        DPFX(DPFPREP,  0, "Error opening specified CLSID" );
        hr = E_FAIL;
        goto COM_GETDLLNAME_ERROR;
    }

    fSuccess = cregInProc.Open( cregCLSID, L"InprocServer32", TRUE, FALSE );

    if( !fSuccess )
    {
        DPFX(DPFPREP,  0, "Error opening inprocserver key" );
        hr = E_FAIL;
        goto COM_GETDLLNAME_ERROR;
    }

    cregCLSID.Close();
    cregRoot.Close();

    fSuccess = cregInProc.ReadString( L"", wszTmpPath, &dwTmpSize );

    if( !dwTmpSize )
    {
        DPFX(DPFPREP,  0, "Error opening default key" );
        hr = E_FAIL;
        goto COM_GETDLLNAME_ERROR;
    }

    if( dwTmpSize > *pdwSize )
    {
    	DPFX(DPFPREP,  0, "Buffer too small" );
    	hr = DPNERR_BUFFERTOOSMALL;
    	*pdwSize = dwTmpSize;
    	goto COM_GETDLLNAME_ERROR;
    }

    *pdwSize = dwTmpSize;

    wszTmpPath = new WCHAR[dwTmpSize];

	if( !wszTmpPath )
	{
		DPFX(DPFPREP,  0, "Error allocating memory" );
		hr = DPNERR_OUTOFMEMORY;
		goto COM_GETDLLNAME_ERROR;
	}

    fSuccess = cregInProc.ReadString( L"", wszTmpPath, &dwTmpSize );

    if( !fSuccess )
    {
        DPFX(DPFPREP,  0, "Error opening default key" );
        hr = E_FAIL;
        goto COM_GETDLLNAME_ERROR;
    }

    if( FAILED( hr = STR_jkWideToAnsi(szPath,wszTmpPath, *pdwSize ) ) )
    {
        DPFX(DPFPREP,  0, "Error converting path to DLL to ANSI hr=0x%x", hr );
        hr = E_FAIL;
    }

    

    delete [] wszTmpPath;

    return hr;

COM_GETDLLNAME_ERROR:

    if( wszTmpPath )
        delete [] wszTmpPath;

    return hr;

}


// DP_CoCreateInstance
//
// This CoCreateInstance can be used instead of CoCreateInstance and will manually perform the
// steps neccessary to do a CoCreateInstance if COM has not been initialized.
//
#undef DPF_MODNAME
#define DPF_MODNAME "COM_CoCreateInstance"
STDAPI COM_CoCreateInstance( REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid, LPVOID *ppv, BOOL fWarnUser )
{
    HRESULT hr;
    CHAR *szFileName = NULL;
    DWORD dwFileNameSize = 0;
    PCOMDLL_ENTRY pEntry;
    IClassFactory *pClassFactory;

    hr = CoCreateInstance( rclsid, pUnkOuter, dwClsContext, riid, ppv );

    if( hr == CO_E_NOTINITIALIZED )
    {
    	if( fWarnUser )
    	{
    		DPFX(DPFPREP, 0, "=====================================================================================" );
    		DPFX(DPFPREP, 0, "" );
			DPFX(DPFPREP, 0, "The DirectPlay8/Voice create functions are no longer supported.  It is recommended" );
		    DPFX(DPFPREP, 0, "that your application be updated to use CoCreateInstance instead." );
     		DPFX(DPFPREP, 0, "" );    		
    		DPFX(DPFPREP, 0, "=====================================================================================" );    			
    	}
    	
        hr = COM_GetEntry( rclsid, &pEntry );

        if( FAILED( hr ) )
            return hr;

        hr = (*pEntry->pfnGetClassObject)( rclsid, IID_IClassFactory, (void **) &pClassFactory );

        if( FAILED( hr ) )
        {
            DPFX(DPFPREP,  0, "Failed getting class object on dynamic entry hr=0x%x", hr );
            return hr;
        }


        hr = pClassFactory->lpVtbl->CreateInstance( pClassFactory, pUnkOuter, riid, ppv );

        if( FAILED( hr ) )
        {
            DPFX(DPFPREP,  0, "Class factory returned an error hr=0x%x", hr );
        }

        pClassFactory->lpVtbl->Release(pClassFactory);

        return hr;

    } 

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\classfpm.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ClassFPM.h
 *  Content:	fixed size pool manager for classes
 *
 *  History:
 *   Date		By		Reason
 *   ======		==		======
 *  12-18-97	aarono	Original
 *	11-06-98	ejs		Add custom handler for Release function
 *	04-12-99	jtk		Trimmed unused functions and parameters, added size assert
 *	01-31-00	jtk		Added code to check for items already being in the pool on Release().
 *	03-20-01	vanceo	Added thread-local versions
***************************************************************************/

#ifndef __CLASS_FPM_H__
#define __CLASS_FPM_H__




#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	CLASSFPM_BLANK_NODE_VALUE	0x55AA817E

#define	CHECK_FOR_DUPLICATE_CLASSFPM_RELEASE

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	OFFSETOF
// Macro to compute the offset of an element inside of a larger structure (copied from MSDEV's STDLIB.H)
#define OFFSETOF(s,m)	( (INT_PTR) &(((s *)0)->m) )
#define	__LOCAL_OFFSETOF_DEFINED__
#endif	// OFFSETOF

#ifndef	CONTAINING_OBJECT
#define	CONTAINING_OBJECT(b,t,m)	(reinterpret_cast<t*>(&reinterpret_cast<BYTE*>(b)[-OFFSETOF(t,m)]))
#endif


//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definitions
//**********************************************************************

// class to act as a link in the pool
template< class T >
class	CPoolNode
{
	public:
		CPoolNode() { m_pNext = NULL; }
		~CPoolNode() {};

		T			m_Item;
		CPoolNode	*m_pNext;

	protected:
	private:
};

// class to manage the pool
template< class T >
class	CFixedPool
{
	public:
		CFixedPool();
		~CFixedPool();

		T		*Get( void );
		void	Release( T *const pItem );

	protected:

	private:
		CPoolNode< T >		*m_pPool;		// pointer to list of available elements
		DEBUG_ONLY( UINT_PTR	m_uOutstandingItemCount );
};

//**********************************************************************
// Class function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CFixedPool::CFixedPool - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CFixedPool::CFixedPool"

template< class T >
CFixedPool< T >::CFixedPool()
{
	m_pPool = NULL;
	DEBUG_ONLY( m_uOutstandingItemCount = 0 );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CFixedPool::~CFixedPool - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CFixedPool::~CFixedPool"

template< class T >
CFixedPool< T >::~CFixedPool()
{
	DEBUG_ONLY( DNASSERT( m_uOutstandingItemCount == 0 ) );
	while ( m_pPool != NULL )
	{
		CPoolNode< T >	*pTemp;

		pTemp = m_pPool;
		m_pPool = m_pPool->m_pNext;
		delete	pTemp;
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CFixedPool::Get - get an item from the pool
//
// Entry:		Nothing
//
// Exit:		Pointer to item
//				NULL = out of memory
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CFixedPool::Get"

template< class T >
T	*CFixedPool< T >::Get( void )
{
	CPoolNode< T >	*pNode;
	T	*pReturn;


	// initialize
	pReturn = NULL;

	// is the pool empty?
	if ( m_pPool == NULL )
	{
		// try to create a new entry
		pNode = new CPoolNode< T >;
	}
	else
	{
		// grab first item from the pool
		pNode = m_pPool;
		m_pPool = m_pPool->m_pNext;
	}

	if ( pNode != NULL )
	{
		DEBUG_ONLY( pNode->m_pNext = (CPoolNode<T>*) CLASSFPM_BLANK_NODE_VALUE );
		pReturn = &pNode->m_Item;
		DEBUG_ONLY( m_uOutstandingItemCount++ );
	}

	return	 pReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CFixedPool::Release - return item to pool
//
// Entry:		Pointer to item
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CFixedPool::Release"

template< class T >
void	CFixedPool< T >::Release( T *const pItem )
{
	CPoolNode< T >	*pNode;


	DNASSERT( pItem != NULL );
	DBG_CASSERT( sizeof( BYTE* ) == sizeof( pItem ) );
	DBG_CASSERT( sizeof( CPoolNode< T >* ) == sizeof( BYTE* ) );
	pNode = reinterpret_cast<CPoolNode< T >*>( &reinterpret_cast<BYTE*>( pItem )[ -OFFSETOF( CPoolNode< T >, m_Item ) ] );

#if defined(CHECK_FOR_DUPLICATE_CLASSFPM_RELEASE) && defined(DEBUG)
	{
		CPoolNode< T >	*pTemp;


		pTemp = m_pPool;
		while ( pTemp != NULL )
		{
			DNASSERT( pTemp != pNode );
			pTemp = pTemp->m_pNext;
		}
	}
#endif	// CHECK_FOR_DUPLICATE_CLASSFPM_RELEASE

	DEBUG_ONLY( DNASSERT( pNode->m_pNext == (CPoolNode< T >*)CLASSFPM_BLANK_NODE_VALUE ) );

#ifdef NO_POOLS
	delete pNode;
#else
	pNode->m_pNext = m_pPool;
	m_pPool = pNode;
#endif
	
	DEBUG_ONLY( m_uOutstandingItemCount-- );
}
//**********************************************************************




// class to act as a link in the pool
template< class T >
class	CTLPoolNode
{
	public:
		CTLPoolNode()
		{
			m_blList.Initialize();
#ifdef TRACK_POOL_STATS
			m_dwSourceThreadID = 0;
#endif // TRACK_POOL_STATS
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CTLPoolNode::~CTLPoolNode"
		~CTLPoolNode()
		{
			DNASSERT(m_blList.IsEmpty());
		};

		CBilink		m_blList;
		T			m_Item;
#ifdef TRACK_POOL_STATS
		DWORD		m_dwSourceThreadID;
#endif // TRACK_POOL_STATS

	protected:
	private:
};

// class to manage the pool
template< class T >
class	CFixedTLPool
{
	public:
		CFixedTLPool(CFixedTLPool< T > * pGlobalPool);
		~CFixedTLPool();

		T		*Get( void );
		void	Release( T *const pItem );
		static void	ReleaseWithoutPool( T *const pItem );

	protected:

	private:
		CBilink					m_blItems;						// bilink list of available elements
		CFixedTLPool< T > *		m_pGlobalPool;					// pointer to global pool, or NULL if this is the global pool
		DNCRITICAL_SECTION *	m_pcsLock;						// pointer to pool critical section, or NULL if this is not the global pool
		DWORD					m_dwNumItems;					// number of items currently in this pool

#ifdef TRACK_POOL_STATS
		DWORD					m_dwAllocations;				// how many objects were allocated by this pool
		DWORD					m_dwSlurpsFromGlobal;			// how many times some items were taken from the global pool
		DWORD					m_dwLargestSlurpFromGlobal;		// most number of items taken from the global pool at one time
		DWORD					m_dwRetrievals;					// how many times objects were pulled out of this pool
		DWORD					m_dwReturnsOnSameThread;		// how many times objects that were pulled out of this pool were returned to this pool
		DWORD					m_dwReturnsOnDifferentThread;	// how many times objects that were pulled out of another thread's pool were returned to this pool
		DWORD					m_dwDumpsToGlobal;				// how many times some items were dumped into the global pool
		DWORD					m_dwDeallocations;				// how many objects were freed by this pool
#endif // TRACK_POOL_STATS
};

//**********************************************************************
// Class function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CFixedTLPool::CFixedTLPool - constructor
//
// Entry:		Pointer to global pool, or NULL if this is a global pool
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CFixedTLPool::CFixedTLPool"

template< class T >
CFixedTLPool< T >::CFixedTLPool(CFixedTLPool< T > * pGlobalPool):
	m_pGlobalPool( pGlobalPool ),
	m_pcsLock( NULL ),
	m_dwNumItems( 0 )
{
	m_blItems.Initialize();

	if (pGlobalPool == NULL)
	{
		//DPFX(DPFPREP, 9, "Initializing global pool 0x%p.", this);
		m_pcsLock = (DNCRITICAL_SECTION*) DNMalloc( sizeof(DNCRITICAL_SECTION) );
		if (m_pcsLock != NULL)
		{
			if (! DNInitializeCriticalSection( m_pcsLock ))
			{
				DNFree( m_pcsLock );
				DEBUG_ONLY( m_pcsLock = NULL );
			}
		}
	}

#ifdef TRACK_POOL_STATS
	m_dwAllocations = 0;
	m_dwSlurpsFromGlobal = 0;
	m_dwLargestSlurpFromGlobal = 0;
	m_dwRetrievals = 0;
	m_dwReturnsOnSameThread = 0;
	m_dwReturnsOnDifferentThread = 0;
	m_dwDumpsToGlobal = 0;
	m_dwDeallocations = 0;
#endif // TRACK_POOL_STATS
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CFixedTLPool::~CFixedTLPool - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CFixedTLPool::~CFixedTLPool"

template< class T >
CFixedTLPool< T >::~CFixedTLPool()
{
	CBilink *			pBilink;
	CTLPoolNode< T > *	pNode;


	pBilink = m_blItems.GetNext();
	while ( pBilink != &m_blItems )
	{
		pNode = CONTAINING_OBJECT(pBilink, CTLPoolNode< T >, m_blList);
		pBilink = pBilink->GetNext();
		pNode->m_blList.RemoveFromList();

		delete	pNode;
#ifdef TRACK_POOL_STATS
		m_dwDeallocations++;
#endif // TRACK_POOL_STATS
		DEBUG_ONLY( m_dwNumItems-- );
	}

	DNASSERT( m_dwNumItems == 0 );
	DNASSERT( m_blItems.IsEmpty() );

	if (m_pcsLock != NULL)
	{
		//DPFX(DPFPREP, 9, "Deinitializing global pool 0x%p.", this);

		DNDeleteCriticalSection( m_pcsLock );

		DNFree( m_pcsLock );
		DEBUG_ONLY( m_pcsLock = NULL );
	}

#ifdef TRACK_POOL_STATS
	DPFX(DPFPREP, 9, "Pool 0x%p information:", this);
	DPFX(DPFPREP, 9, "\tAllocations              = %u", m_dwAllocations);
	DPFX(DPFPREP, 9, "\tSlurpsFromGlobal         = %u", m_dwSlurpsFromGlobal);
	DPFX(DPFPREP, 9, "\tLargestSlurpFromGlobal   = %u", m_dwLargestSlurpFromGlobal);
	DPFX(DPFPREP, 9, "\tRetrievals               = %u", m_dwRetrievals);
	DPFX(DPFPREP, 9, "\tReturnsOnSameThread      = %u", m_dwReturnsOnSameThread);
	DPFX(DPFPREP, 9, "\tReturnsOnDifferentThread = %u", m_dwReturnsOnDifferentThread);
	DPFX(DPFPREP, 9, "\tDumpsToGlobal            = %u", m_dwDumpsToGlobal);
	DPFX(DPFPREP, 9, "\tDeallocations            = %u", m_dwDeallocations);
#endif // TRACK_POOL_STATS
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CFixedTLPool::Get - get an item from the pool
//
// Entry:		Nothing
//
// Exit:		Pointer to item
//				NULL = out of memory
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CFixedTLPool::Get"

template< class T >
T	*CFixedTLPool< T >::Get( void )
{
	CBilink *			pBilink;
	CTLPoolNode< T > *	pNode;
	T *					pReturn;


	DNASSERT( m_pGlobalPool != NULL );


	//
	// If the pool is empty, steal the ones in the global pool.
	//
	pBilink = m_blItems.GetNext();
	if ( pBilink == &m_blItems )
	{
		DNEnterCriticalSection( m_pGlobalPool->m_pcsLock );

		pBilink = m_pGlobalPool->m_blItems.GetNext();
		if ( pBilink == &m_pGlobalPool->m_blItems )
		{
			//
			// No items.  Drop global pool lock and allocate a new one.
			//
			DNLeaveCriticalSection( m_pGlobalPool->m_pcsLock );


			pNode = new CTLPoolNode< T >;
			if ( pNode != NULL )
			{
#ifdef TRACK_POOL_STATS
				//
				// Update counter.
				//
				m_dwAllocations++;
#endif // TRACK_POOL_STATS
			}
			else
			{
				pReturn = NULL;
				goto Exit;
			}
		}
		else
		{
			//
			// Separate all the items from the global list.
			// We still have a pointer to the orphaned items (pBilink).
			//

			m_pGlobalPool->m_blItems.RemoveFromList();

			DNASSERT(m_pGlobalPool->m_dwNumItems > 0);

#ifdef TRACK_POOL_STATS
			m_dwSlurpsFromGlobal++;
			if ( m_pGlobalPool->m_dwNumItems > m_dwLargestSlurpFromGlobal )
			{
				m_dwLargestSlurpFromGlobal = m_pGlobalPool->m_dwNumItems;
			}
#endif // TRACK_POOL_STATS

			m_dwNumItems = m_pGlobalPool->m_dwNumItems - 1;	// -1 because we need one right now
			m_pGlobalPool->m_dwNumItems = 0;


			//
			// Drop the lock since we don't need the global pool anymore.
			//
			DNLeaveCriticalSection( m_pGlobalPool->m_pcsLock );


			//
			// Get the first item from the orphaned list.
			//
			pNode = CONTAINING_OBJECT(pBilink, CTLPoolNode< T >, m_blList);

			//
			// If there was more than one item in the global pool, transfer
			// the remaining orphaned items (after the first) to this pool.
			//
			if (pBilink != pBilink->GetNext())
			{
				pBilink = pBilink->GetNext();
				pNode->m_blList.RemoveFromList();
				m_blItems.InsertBefore(pBilink);
			}
		}
	}
	else
	{
		pNode = CONTAINING_OBJECT(pBilink, CTLPoolNode< T >, m_blList);
		pBilink->RemoveFromList();

		DNASSERT( m_dwNumItems > 0 );
		m_dwNumItems--;
	}

	//
	// If we're here, we have an entry (it was freshly created, or removed from
	// some pool).
	//
	pReturn = &pNode->m_Item;

#ifdef TRACK_POOL_STATS
	//
	// Update status counts.
	//
	m_dwRetrievals++;
	pNode->m_dwSourceThreadID = GetCurrentThreadId();
#endif // TRACK_POOL_STATS


Exit:

	return	 pReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CFixedTLPool::Release - return item to pool
//
// Entry:		Pointer to item
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CFixedTLPool::Release"

template< class T >
void	CFixedTLPool< T >::Release( T *const pItem )
{
	CTLPoolNode< T >	*pNode;


	DNASSERT( m_pGlobalPool != NULL );
	DNASSERT( pItem != NULL );
	DBG_CASSERT( sizeof( BYTE* ) == sizeof( pItem ) );
	DBG_CASSERT( sizeof( CTLPoolNode< T >* ) == sizeof( BYTE* ) );
	pNode = reinterpret_cast<CTLPoolNode< T >*>( &reinterpret_cast<BYTE*>( pItem )[ -OFFSETOF( CTLPoolNode< T >, m_Item ) ] );

#if defined(CHECK_FOR_DUPLICATE_CONTEXTCFPM_RELEASE) && defined(DEBUG)
	DNASSERT( ! pNode->m_blList.IsListMember( &m_blItems ));
#endif	// CHECK_FOR_DUPLICATE_CONTEXTCFPM_RELEASE

#ifdef TRACK_POOL_STATS
	//
	// Update status counts.
	//
	if (pNode->m_dwSourceThreadID == GetCurrentThreadId())
	{
		m_dwReturnsOnSameThread++;
	}
	else
	{
		m_dwReturnsOnDifferentThread++;
	}
#endif // TRACK_POOL_STATS


#ifdef NO_POOLS
	delete pNode;
#ifdef TRACK_POOL_STATS
	m_dwDeallocations++;
#endif // TRACK_POOL_STATS
#else // ! NO_POOLS
	pNode->m_blList.InsertAfter( &m_blItems );
	m_dwNumItems++;


	//
	// If this pool has built up some extra items, return them to the
	// global pool.
	//
	if ( m_dwNumItems >= 25 )
	{
		CBilink *	pFirstItem;


		//
		// Save a pointer to the first item. 
		//
		pFirstItem = m_blItems.GetNext();
		DNASSERT( pFirstItem != &m_blItems );

		//
		// Orphan the items.
		//
		m_blItems.RemoveFromList();

		
		//
		// Take the lock and transfer the list to the global pool.
		//

		DNEnterCriticalSection( m_pGlobalPool->m_pcsLock );

		m_pGlobalPool->m_blItems.AttachListBefore(pFirstItem);
		m_pGlobalPool->m_dwNumItems += m_dwNumItems;

		DNLeaveCriticalSection( m_pGlobalPool->m_pcsLock );

		m_dwNumItems = 0;
#ifdef TRACK_POOL_STATS
		m_dwDumpsToGlobal++;
#endif // TRACK_POOL_STATS
	}
#endif // ! NO_POOLS
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CFixedTLPool::ReleaseWithoutPool - destroy an item without returning it to a
//								pool
//								NOTE: this is a static function and cannot use
//								the 'this' pointer!
//
// Entry:		Pointer to item
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CFixedTLPool::ReleaseWithoutPool"

template< class T >
void	CFixedTLPool< T >::ReleaseWithoutPool( T *const pItem )
{
	CTLPoolNode< T >	*pNode;


	DNASSERT( pItem != NULL );
	DBG_CASSERT( sizeof( BYTE* ) == sizeof( pItem ) );
	DBG_CASSERT( sizeof( CTLPoolNode< T >* ) == sizeof( BYTE* ) );
	pNode = reinterpret_cast<CTLPoolNode< T >*>( &reinterpret_cast<BYTE*>( pItem )[ -OFFSETOF( CTLPoolNode< T >, m_Item ) ] );

	DNASSERT( pNode->m_blList.IsEmpty() );

	delete pNode;
}
//**********************************************************************






#ifdef	__LOCAL_OFFSETOF_DEFINED__
#undef	__LOCAL_OFFSETOF_DEFINED__
#undef	OFFSETOF
#endif	// __LOCAL_OFFSETOF_DEFINED__

#undef DPF_SUBCOMP
#undef DPF_MODNAME

#endif	// __CLASS_FPM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\callstack.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       CallStack.cpp
 *  Content:	Call stack tracking class
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/23/99	jtk		Derived from OSInd.cpp
 ***************************************************************************/

#ifndef	__CALLSTACK_H__
#define	__CALLSTACK_H__

#define	_IMAGEHLP_SOURCE_
#include	<Imagehlp.h>

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// Size of temp buffer to build strings into.
// If the call stack depth is increased, increase the size of the buffer
// to prevent stack corruption with long symbol names.
//
#define	CALLSTACK_BUFFER_SIZE	8192

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//
// prototypes for ImageHlp.DLL functions we get from LoadLibrary().
//
typedef DWORD	(__stdcall * PIMAGEHELP_SYMGETOPTIONS)( void );
typedef DWORD	(__stdcall * PIMAGEHELP_SYMSETOPTIONS)( DWORD SymOptions );
typedef	BOOL	(__stdcall * PIMAGEHELP_SYMINITIALIZE)( HANDLE hProcess, PSTR pUserSearchPath, BOOL fInvadeProcess );
typedef BOOL	(__stdcall * PIMAGEHELP_SYMGETSYMFROMADDR)( HANDLE hProcess, DWORD dwAddress, PDWORD pdwDisplacement, PIMAGEHLP_SYMBOL pSymbol );
typedef BOOL	(__stdcall * PIMAGEHELP_SYMGETSYMFROMADDR64)( HANDLE hProcess, DWORD_PTR dwAddress, PDWORD_PTR pdwDisplacement, PIMAGEHLP_SYMBOL64 pSymbol );

//**********************************************************************
// Class definitions
//**********************************************************************

template< UINT_PTR uStackDepth >
class	CCallStack
{
	public:
		CCallStack(){}
		~CCallStack(){}

		void	NoteCurrentCallStack( void );
		void	GetCallStackString( char *const pOutputString ) const;

	private:
		const void	*m_CallStack[ uStackDepth ];

		const void		*GetStackTop( void ) const;
		const void		*GetStackBottom( void ) const;
		const UINT_PTR	GetCallStackDepth( void ) const { return uStackDepth; }

		//
		// make copy constructor and assignment operator private and unimplemented
		// to prevent unwarranted copies
		//
		CCallStack( const CCallStack & );
		CCallStack& operator=( const CCallStack & );
};


//**********************************************************************
// Class function definitions
//**********************************************************************

//**********************************************************************
// ------------------------------
// CCallStack::NoteCurrentCallStack - get a call stack
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
template< UINT_PTR uStackDepth >
void	CCallStack< uStackDepth >::NoteCurrentCallStack( void )
{
	void		**CallersEBP = NULL;
	void		*ReturnAddr;
	UINT_PTR	i,iCount;
	const void	*StackTop;
	const void	*StackBottom;
	static const void	*const min_dll_base = NULL;


	StackTop = GetStackTop();
	StackBottom = GetStackBottom();
	memset(	m_CallStack, 0x00, sizeof( m_CallStack ) );

#ifdef	_X86_
	_asm
	{
		mov eax,[ebp]
		mov CallersEBP,eax
	}
#endif	// _X86_

	__try
	{
		//
		// this code can generate exception if it steps back too far...
		//
 		for ( i = 0, iCount = 0; i < GetCallStackDepth(); iCount++ )
		{
			if ( ( CallersEBP < StackBottom ) || ( CallersEBP >= StackTop ) )
				break;
			ReturnAddr = CallersEBP[ 1 ];
			if ( ( iCount > 0 ) || ( ReturnAddr >= min_dll_base ) ) // iCount check skips memory_alloc_debug
				m_CallStack[ i++ ] = ReturnAddr;
			CallersEBP = reinterpret_cast<void**>( *CallersEBP ); // get callers callers ebp
		}
	}
	__except( 1 )  // went too far back on the stack, rest of array is filled with zeros
	{
//		DPFX(DPFPREP,  0, "Benign access violation creating return address stack." );
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CCallStack::GetStackTop - return pointer to top of stack
//
// Entry:		Nothing
//
// Exit:		Pointer to top of stack
// ------------------------------
template< UINT_PTR uStackDepth >
const void	*CCallStack< uStackDepth >::GetStackTop( void ) const
{
	void	*pReturn = NULL;

#ifdef	_X86_
	_asm	mov eax,dword ptr fs:[4]
	_asm	mov pReturn, eax
#endif	// _X86_

	return	pReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CCallStack::GetStackBottom - return pointer to bottom of call stack
//
// Entry:		Nothing
//
// Exit:		Pointer to bottom of call stack
// ------------------------------
template< UINT_PTR uStackDepth >
const void	*CCallStack< uStackDepth >::GetStackBottom( void ) const
{
	void	*pReturn = NULL;

#ifdef	_X86_
	_asm	mov eax,dword ptr fs:[8]
	_asm	mov pReturn, eax
#endif	// _X86_

	return	pReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CCallStack::GetCallStack - return pointer to bottom of call stack
//
// Entry:		Pointer to destination string
//
// Exit:		Nothing
// ------------------------------
template< UINT_PTR uStackDepth >
void	CCallStack< uStackDepth >::GetCallStackString( char *const pOutputString ) const
{
	static const char	CallStackTitle[] = "\nCALL STACK:\n";
	static const char	CallStackTitleWithSymbols[] = "\nCALL STACK:\tFUNCTION DETAILS:\n";
	static enum
	{
		IMAGEHELP_STATUS_UNKNOWN,
		IMAGEHELP_STATUS_LOADED,
		IMAGEHELP_STATUS_LOAD_FAILED
	} ImageHelpStatus = IMAGEHELP_STATUS_UNKNOWN;

	static HINSTANCE	hImageHelp = NULL;
	
	static PIMAGEHELP_SYMGETOPTIONS			pSymGetOptions = NULL;
	static PIMAGEHELP_SYMSETOPTIONS			pSymSetOptions = NULL;
	static PIMAGEHELP_SYMINITIALIZE			pSymInitialize = NULL;

#ifndef	_WIN64	
	static PIMAGEHELP_SYMGETSYMFROMADDR		pSymGetSymFromAddr = NULL;
#else
	static PIMAGEHELP_SYMGETSYMFROMADDR64	pSymGetSymFromAddr = NULL;
#endif	// _WIN64

	UINT_PTR	uIndex;


	//
	// if ImageHelp isn't loaded attempt to load it
	//
	if ( ImageHelpStatus == IMAGEHELP_STATUS_UNKNOWN )
	{
		ImageHelpStatus = IMAGEHELP_STATUS_LOAD_FAILED;

		hImageHelp = LoadLibrary( "ImageHLP.DLL" );
		if ( hImageHelp == NULL )
		{
			goto FailedImageHelpLoad;
		}

		pSymGetOptions = reinterpret_cast<PIMAGEHELP_SYMGETOPTIONS>( GetProcAddress( hImageHelp, "SymGetOptions" ) );
		pSymSetOptions = reinterpret_cast<PIMAGEHELP_SYMSETOPTIONS>( GetProcAddress( hImageHelp, "SymSetOptions" ) );
		pSymInitialize = reinterpret_cast<PIMAGEHELP_SYMINITIALIZE>( GetProcAddress( hImageHelp, "SymInitialize" ) );

#ifndef	_WIN64		
		pSymGetSymFromAddr = reinterpret_cast<PIMAGEHELP_SYMGETSYMFROMADDR>( GetProcAddress( hImageHelp, "SymGetSymFromAddr" ) );
#else	// _WIN64
		pSymGetSymFromAddr = reinterpret_cast<PIMAGEHELP_SYMGETSYMFROMADDR64>( GetProcAddress( hImageHelp, "SymGetSymFromAddr64" ) );
#endif	// _WIN64

		if ( ( pSymGetOptions == NULL ) ||
			 ( pSymSetOptions == NULL ) ||
			 ( pSymInitialize == NULL ) ||
			 ( pSymGetSymFromAddr == NULL ) )
		{
			goto FailedImageHelpLoad;
		}

		pSymSetOptions( SYMOPT_DEFERRED_LOADS | pSymGetOptions() );

		if ( pSymInitialize( GetCurrentProcess(), NULL, TRUE ) == FALSE )
		{
			if ( pSymInitialize( GetCurrentProcess(), NULL, FALSE ) == FALSE )
			{
				goto FailedImageHelpLoad;
			}
		}

		ImageHelpStatus = IMAGEHELP_STATUS_LOADED;
	}

FailedImageHelpLoad:
	if ( ImageHelpStatus == IMAGEHELP_STATUS_LOADED )
	{
		memcpy( pOutputString, CallStackTitleWithSymbols, sizeof( CallStackTitleWithSymbols ) );
	}
	else
	{
		memcpy( pOutputString, CallStackTitle, sizeof( CallStackTitle ) );
	}

	for ( uIndex = 0; ( ( uIndex < GetCallStackDepth() ) && ( m_CallStack[ uIndex ] != NULL ) ); uIndex++ )
	{
		char	AddressBuffer[ CALLSTACK_BUFFER_SIZE ];


		if ( ImageHelpStatus == IMAGEHELP_STATUS_LOADED )
		{
			char	ImageBuffer[ CALLSTACK_BUFFER_SIZE + sizeof(IMAGEHLP_SYMBOL) ];
			DWORD_PTR	dwFunctionDisplacement;
#ifndef	_WIN64
			IMAGEHLP_SYMBOL	*const pImageHelpSymbol = reinterpret_cast<IMAGEHLP_SYMBOL*>( ImageBuffer );
#else	// _WIN64
			IMAGEHLP_SYMBOL64	*const pImageHelpSymbol = reinterpret_cast<IMAGEHLP_SYMBOL64*>( ImageBuffer );
#endif	// _WIN64


			pImageHelpSymbol->SizeOfStruct = sizeof( *pImageHelpSymbol );
			pImageHelpSymbol->Flags = 0;
			pImageHelpSymbol->Address = reinterpret_cast<DWORD_PTR>( m_CallStack[ uIndex ] );
            pImageHelpSymbol->MaxNameLength = sizeof( ImageBuffer ) - sizeof( *pImageHelpSymbol ) - 14;   // account for \t%s+0x00000000\n\0
            if ( pSymGetSymFromAddr( GetCurrentProcess(),
									 reinterpret_cast<DWORD_PTR>( m_CallStack[ uIndex ] ),
									 &dwFunctionDisplacement,
									 pImageHelpSymbol
									 ) != FALSE )
            {
                if ( dwFunctionDisplacement != 0 )
				{
#ifdef	_X86_
					wsprintf( AddressBuffer, "0x%x\t%s+0x%x\n", m_CallStack[ uIndex ], pImageHelpSymbol->Name, dwFunctionDisplacement );
#else
					wsprintf( AddressBuffer, "0x%p\t%s+0x%x\n", m_CallStack[ uIndex ], pImageHelpSymbol->Name, dwFunctionDisplacement );
#endif
				}
                else
				{
#ifdef	_X86_
                    wsprintf( AddressBuffer, "0x%x\t%s\n", m_CallStack[ uIndex ], pImageHelpSymbol->Name );
#else
                    wsprintf( AddressBuffer, "0x%p\t%s\n", m_CallStack[ uIndex ], pImageHelpSymbol->Name );
#endif
				}

				strcat( pOutputString, AddressBuffer );

				//
				// continue FOR loop
				//
				continue;
            }
		}	

#ifdef	_X86_
		wsprintf( AddressBuffer, "0x08%x\n", m_CallStack[ uIndex ] );
#else
		wsprintf( AddressBuffer, "0x%p\n", m_CallStack[ uIndex ] );
#endif
		strcat( pOutputString, AddressBuffer );
	}

	return;
}
//**********************************************************************


#endif	// __CALLSTACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\contextcfpm.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ContextCFPM.h
 *  Content:	fixed pool manager for classes that takes into account contexts
 *
 *  History:
 *   Date		By		Reason
 *   ======		==		======
 *  12-18-97	aarono	Original
 *	11-06-98	ejs		Add custom handler for Release function
 *	04-12-99	jtk		Trimmed unused functions and parameters, added size assert
 *	01-31-2000	jtk		Added code to check for items already being in the pool on Release().
 *	02-08-2000	jtk		Derived from ClassFPM.h
 *	03-20-2001	vanceo	Added thread-local versions
***************************************************************************/

#ifndef __CONTEXT_CLASS_FPM_H__
#define __CONTEXT_CLASS_FPM_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON










#define TRACK_POOL_STATS












//**********************************************************************
// Constant definitions
//**********************************************************************

#define	CONTEXTCFPM_BLANK_NODE_VALUE	0x5AA5817E

#define	CHECK_FOR_DUPLICATE_CONTEXTCFPM_RELEASE

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	OFFSETOF
// Macro to compute the offset of an element inside of a larger structure (copied from MSDEV's STDLIB.H)
#define OFFSETOF(s,m)	( (INT_PTR) &(((s *)0)->m) )
#define	__LOCAL_OFFSETOF_DEFINED__
#endif	// OFFSETOF

#ifndef	CONTAINING_OBJECT
#define	CONTAINING_OBJECT(b,t,m)	(reinterpret_cast<t*>(&reinterpret_cast<BYTE*>(b)[-OFFSETOF(t,m)]))
#endif



//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definitions
//**********************************************************************



// class to act as a link in the pool
template< class T >
class	CContextClassFPMPoolNode
{
	public:
		CContextClassFPMPoolNode() { m_pNext = NULL; }
		~CContextClassFPMPoolNode() {};

		CContextClassFPMPoolNode	*m_pNext;
		T		m_Item;

	protected:
	private:
};

// class to manage the pool
template< class T, class S >
class	CContextFixedPool
{
	public:
		CContextFixedPool();
		~CContextFixedPool();


typedef BOOL (T::*PBOOLCALLBACK)( S *const pContext );
typedef	void (T::*PVOIDCONTEXTCALLBACK)( S *const pContext );
typedef void (T::*PVOIDCALLBACK)( void );

		BOOL	Initialize( PBOOLCALLBACK pAllocFunction, PVOIDCONTEXTCALLBACK pInitFunction, PVOIDCALLBACK pReleaseFunction, PVOIDCALLBACK pDeallocFunction );
		void	Deinitialize( void ) { DEBUG_ONLY( m_fInitialized = FALSE ); }

		T		*Get( S *const pContext );
		void	Release( T *const pItem );

	protected:

	private:
		PBOOLCALLBACK			m_pAllocFunction;
		PVOIDCONTEXTCALLBACK	m_pInitFunction;
		PVOIDCALLBACK			m_pReleaseFunction;
		PVOIDCALLBACK			m_pDeallocFunction;

		CContextClassFPMPoolNode< T >	*m_pPool;		// pointer to list of available elements
		DEBUG_ONLY( BOOL		m_fInitialized );
		DEBUG_ONLY( UINT_PTR	m_uOutstandingItemCount );
};

//**********************************************************************
// Class function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CContextFixedPool::CContextFixedPool - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CContextFixedPool::CContextFixedPool"

template< class T, class S >
CContextFixedPool< T, S >::CContextFixedPool():
	m_pAllocFunction( NULL ),
	m_pInitFunction( NULL ),
	m_pReleaseFunction( NULL ),
	m_pDeallocFunction( NULL ),
	m_pPool( NULL )
{
	DEBUG_ONLY( m_uOutstandingItemCount = 0 );
	DEBUG_ONLY( m_fInitialized = FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CContextFixedPool::~CContextFixedPool - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CContextFixedPool::~CContextFixedPool"

template< class T, class S >
CContextFixedPool< T, S >::~CContextFixedPool()
{
	DEBUG_ONLY( DNASSERT( m_uOutstandingItemCount == 0 ) );
	while ( m_pPool != NULL )
	{
		CContextClassFPMPoolNode< T >	*pNode;


		DEBUG_ONLY( DNASSERT( m_fInitialized == FALSE ) );
		pNode = m_pPool;
		m_pPool = m_pPool->m_pNext;
		(pNode->m_Item.*m_pDeallocFunction)();
		delete	pNode;
	}

	DEBUG_ONLY( DNASSERT( m_fInitialized == FALSE ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CContextFixedPool::Initialize - initialize pool
//
// Entry:		Pointer to function to call when a new entry is allocated
//				Pointer to function to call when a new entry is removed from the pool
//				Pointer to function to call when an entry is returned to the pool
//				Pointer to function to call when an entry is deallocated
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CContextFixedPool::Initialize"

template< class T, class S >
BOOL	CContextFixedPool< T, S >::Initialize( PBOOLCALLBACK pAllocFunction, PVOIDCONTEXTCALLBACK pInitFunction, PVOIDCALLBACK pReleaseFunction, PVOIDCALLBACK pDeallocFunction )
{
	BOOL	fReturn;


	DNASSERT( pAllocFunction != NULL );
	DNASSERT( pInitFunction != NULL );
	DNASSERT( pReleaseFunction != NULL );
	DNASSERT( pDeallocFunction != NULL );

	fReturn = TRUE;
	m_pAllocFunction = pAllocFunction;
	m_pInitFunction = pInitFunction;
	m_pReleaseFunction = pReleaseFunction;
	m_pDeallocFunction = pDeallocFunction;

	DEBUG_ONLY( DNASSERT( m_fInitialized == FALSE ) );
	DEBUG_ONLY( m_fInitialized = TRUE );

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CContextFixedPool::Get - get an item from the pool
//
// Entry:		Pointer to user context
//
// Exit:		Pointer to item
//				NULL = out of memory
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CContextFixedPool::Get"

template< class T, class S >
T	*CContextFixedPool< T, S >::Get( S *const pContext )
{
	CContextClassFPMPoolNode< T >	*pNode;
	T	*pReturn;


	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );

	//
	// initialize
	//
	pReturn = NULL;

	//
	// if the pool is empty, try to allocate a new entry, otherwise grab
	// the first item from the pool
	//
	if ( m_pPool == NULL )
	{
		pNode = new CContextClassFPMPoolNode< T >;
		if ( pNode != NULL )
		{
			if ( (pNode->m_Item.*m_pAllocFunction)( pContext ) == FALSE )
			{
				delete pNode;
				pNode = NULL;
			}
		}
	}
	else
	{
		pNode = m_pPool;
		m_pPool = m_pPool->m_pNext;
	}

	//
	// if we have an entry (it was freshly created, or removed from the pool),
	// attempt to initialize it before passing it to the user
	//
	if ( pNode != NULL )
	{
		(pNode->m_Item.*m_pInitFunction)( pContext );

		pReturn = &pNode->m_Item;
		DEBUG_ONLY( pNode->m_pNext = (CContextClassFPMPoolNode<T>*) CONTEXTCFPM_BLANK_NODE_VALUE );
		DEBUG_ONLY( m_uOutstandingItemCount++ );
	}

	return	 pReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CContextFixedPool::Release - return item to pool
//
// Entry:		Pointer to item
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CContextFixedPool::Release"

template< class T, class S >
void	CContextFixedPool< T, S >::Release( T *const pItem )
{
	CContextClassFPMPoolNode< T >	*pNode;


	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );
	DNASSERT( pItem != NULL );
	DBG_CASSERT( sizeof( BYTE* ) == sizeof( pItem ) );
	DBG_CASSERT( sizeof( CContextClassFPMPoolNode< T >* ) == sizeof( BYTE* ) );
	pNode = reinterpret_cast<CContextClassFPMPoolNode< T >*>( &reinterpret_cast<BYTE*>( pItem )[ -OFFSETOF( CContextClassFPMPoolNode< T >, m_Item ) ] );

#if defined(CHECK_FOR_DUPLICATE_CONTEXTCFPM_RELEASE) && defined(DEBUG)
	{
		CContextClassFPMPoolNode< T >	*pTemp;


		pTemp = m_pPool;
		while ( pTemp != NULL )
		{
			DNASSERT( pTemp != pNode );
			pTemp = pTemp->m_pNext;
		}
	}
#endif	// CHECK_FOR_DUPLICATE_CONTEXTCFPM_RELEASE

	DEBUG_ONLY( DNASSERT( pNode->m_pNext == (CContextClassFPMPoolNode< T >*)CONTEXTCFPM_BLANK_NODE_VALUE ) );
	(pNode->m_Item.*m_pReleaseFunction)();

#ifdef NO_POOLS
	(pNode->m_Item.*m_pDeallocFunction)();
	delete pNode;
#else
	pNode->m_pNext = m_pPool;
	m_pPool = pNode;
#endif

	DEBUG_ONLY( m_uOutstandingItemCount-- );
}
//**********************************************************************





// class to act as a link in the pool
template< class T >
class	CContextClassFPMTLPoolNode
{
	public:
		CContextClassFPMTLPoolNode()
		{
			m_blList.Initialize();
#ifdef TRACK_POOL_STATS
			m_dwSourceThreadID = 0;
#endif // TRACK_POOL_STATS
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CContextClassFPMTLPoolNode::~CContextClassFPMTLPoolNode"
		~CContextClassFPMTLPoolNode()
		{
			DNASSERT(m_blList.IsEmpty());
		};

		CBilink		m_blList;
		T			m_Item;
#ifdef TRACK_POOL_STATS
		DWORD		m_dwSourceThreadID;
#endif // TRACK_POOL_STATS

	protected:
	private:
};

// class to manage the pool
template< class T, class S >
class	CContextFixedTLPool
{
	public:
		CContextFixedTLPool();
		~CContextFixedTLPool();


typedef BOOL (T::*PBOOLCALLBACK)( S *const pContext );
typedef	void (T::*PVOIDCONTEXTCALLBACK)( S *const pContext );
typedef void (T::*PVOIDCALLBACK)( void );

		BOOL	Initialize( CContextFixedTLPool< T, S > * pGlobalPool, PBOOLCALLBACK pAllocFunction, PVOIDCONTEXTCALLBACK pInitFunction, PVOIDCALLBACK pReleaseFunction, PVOIDCALLBACK pDeallocFunction );
		void	Deinitialize( void );

		T		*Get( S *const pContext );
		void	Release( T *const pItem );
		static void		ReleaseWithoutPool( T *const pItem, PVOIDCALLBACK pReleaseFunction, PVOIDCALLBACK pDeallocFunction );

	protected:

	private:
		PBOOLCALLBACK					m_pAllocFunction;
		PVOIDCONTEXTCALLBACK			m_pInitFunction;
		PVOIDCALLBACK					m_pReleaseFunction;
		PVOIDCALLBACK					m_pDeallocFunction;

		CBilink							m_blItems;						// bilink list of available elements
		CContextFixedTLPool< T, S > *	m_pGlobalPool;					// pointer to global pool, or NULL if this is the global pool
		DNCRITICAL_SECTION *			m_pcsLock;						// pointer to pool critical section, or NULL if this is not the global pool
		DWORD							m_dwNumItems;					// number of items currently in this pool

		DEBUG_ONLY( BOOL				m_fInitialized );
#ifdef TRACK_POOL_STATS
		DWORD							m_dwAllocations;				// how many objects were allocated by this pool
		DWORD							m_dwSlurpsFromGlobal;			// how many times some items were taken from the global pool
		DWORD							m_dwLargestSlurpFromGlobal;		// most number of items taken from the global pool at one time
		DWORD							m_dwRetrievals;					// how many times objects were pulled out of this pool
		DWORD							m_dwReturnsOnSameThread;		// how many times objects that were pulled out of this pool were returned to this pool
		DWORD							m_dwReturnsOnDifferentThread;	// how many times objects that were pulled out of another thread's pool were returned to this pool
		DWORD							m_dwDumpsToGlobal;				// how many times some items were dumped into the global pool
		DWORD							m_dwDeallocations;				// how many objects were freed by this pool
#endif // TRACK_POOL_STATS
};


//**********************************************************************
// Class function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CContextFixedTLPool::CContextFixedTLPool - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CContextFixedTLPool::CContextFixedTLPool"

template< class T, class S >
CContextFixedTLPool< T, S >::CContextFixedTLPool():
	m_pAllocFunction( NULL ),
	m_pInitFunction( NULL ),
	m_pReleaseFunction( NULL ),
	m_pDeallocFunction( NULL ),
	m_pGlobalPool( NULL ),
	m_pcsLock( NULL ),
	m_dwNumItems( 0 )
{
	m_blItems.Initialize();

	DEBUG_ONLY( m_fInitialized = FALSE );
#ifdef TRACK_POOL_STATS
	m_dwAllocations = 0;
	m_dwSlurpsFromGlobal = 0;
	m_dwLargestSlurpFromGlobal = 0;
	m_dwRetrievals = 0;
	m_dwReturnsOnSameThread = 0;
	m_dwReturnsOnDifferentThread = 0;
	m_dwDumpsToGlobal = 0;
	m_dwDeallocations = 0;
#endif // TRACK_POOL_STATS
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CContextFixedTLPool::~CContextFixedTLPool - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CContextFixedTLPool::~CContextFixedTLPool"

template< class T, class S >
CContextFixedTLPool< T, S >::~CContextFixedTLPool()
{
	CBilink *							pBilink;
	CContextClassFPMTLPoolNode< T > *	pNode;


	pBilink = m_blItems.GetNext();
	while ( pBilink != &m_blItems )
	{
		pNode = CONTAINING_OBJECT(pBilink, CContextClassFPMTLPoolNode< T >, m_blList);
		pBilink = pBilink->GetNext();
		pNode->m_blList.RemoveFromList();

		(pNode->m_Item.*m_pDeallocFunction)();
		delete	pNode;
#ifdef TRACK_POOL_STATS
		m_dwDeallocations++;
#endif // TRACK_POOL_STATS
		DEBUG_ONLY( m_dwNumItems-- );
	}

	DNASSERT( m_fInitialized == FALSE );
	DNASSERT( m_dwNumItems == 0 );
	DNASSERT( m_blItems.IsEmpty() );
	DNASSERT( m_pcsLock == NULL );

#ifdef TRACK_POOL_STATS
	DPFX(DPFPREP, 9, "Pool 0x%p information:", this);
	DPFX(DPFPREP, 9, "\tAllocations              = %u", m_dwAllocations);
	DPFX(DPFPREP, 9, "\tSlurpsFromGlobal         = %u", m_dwSlurpsFromGlobal);
	DPFX(DPFPREP, 9, "\tLargestSlurpFromGlobal   = %u", m_dwLargestSlurpFromGlobal);
	DPFX(DPFPREP, 9, "\tRetrievals               = %u", m_dwRetrievals);
	DPFX(DPFPREP, 9, "\tReturnsOnSameThread      = %u", m_dwReturnsOnSameThread);
	DPFX(DPFPREP, 9, "\tReturnsOnDifferentThread = %u", m_dwReturnsOnDifferentThread);
	DPFX(DPFPREP, 9, "\tDumpsToGlobal            = %u", m_dwDumpsToGlobal);
	DPFX(DPFPREP, 9, "\tDeallocations            = %u", m_dwDeallocations);
#endif // TRACK_POOL_STATS
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CContextFixedTLPool::Initialize - initialize pool
//
// Entry:		Pointer to global pool, or NULL if this is the global pool
//				Pointer to function to call when a new entry is allocated
//				Pointer to function to call when a new entry is removed from the pool
//				Pointer to function to call when an entry is returned to the pool
//				Pointer to function to call when an entry is deallocated
//
// Exit:		TRUE if successful, FALSE otherwise.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CContextFixedTLPool::Initialize"

template< class T, class S >
BOOL	CContextFixedTLPool< T, S >::Initialize( CContextFixedTLPool< T, S > * pGlobalPool, PBOOLCALLBACK pAllocFunction, PVOIDCONTEXTCALLBACK pInitFunction, PVOIDCALLBACK pReleaseFunction, PVOIDCALLBACK pDeallocFunction )
{
	BOOL	fReturn;


	DNASSERT( pAllocFunction != NULL );
	DNASSERT( pInitFunction != NULL );
	DNASSERT( pReleaseFunction != NULL );
	DNASSERT( pDeallocFunction != NULL );

	fReturn = TRUE;
	
	m_pAllocFunction = pAllocFunction;
	m_pInitFunction = pInitFunction;
	m_pReleaseFunction = pReleaseFunction;
	m_pDeallocFunction = pDeallocFunction;

	m_pGlobalPool = pGlobalPool;
	if (pGlobalPool == NULL)
	{
		//DPFX(DPFPREP, 9, "Initializing global pool 0x%p.", this);
		m_pcsLock = (DNCRITICAL_SECTION*) DNMalloc( sizeof(DNCRITICAL_SECTION) );
		if (m_pcsLock == NULL)
		{
			fReturn = FALSE;
			goto Exit;
		}

		if (! DNInitializeCriticalSection( m_pcsLock ))
		{
			DNFree( m_pcsLock );
			DEBUG_ONLY( m_pcsLock = NULL );
			fReturn = FALSE;
			goto Exit;
		}
	}

	DEBUG_ONLY( DNASSERT( m_fInitialized == FALSE ) );
	DEBUG_ONLY( m_fInitialized = TRUE );


Exit:

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CContextFixedTLPool::Deinitialize - deinitialize pool
//
// Entry:		None.
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CContextFixedTLPool::Deinitialize"

template< class T, class S >
void	CContextFixedTLPool< T, S >::Deinitialize( void )
{
	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );
	DEBUG_ONLY( m_fInitialized = FALSE );

	if (m_pcsLock != NULL)
	{
		//DPFX(DPFPREP, 9, "Deinitializing global pool 0x%p.", this);

		DNDeleteCriticalSection( m_pcsLock );

		DNFree( m_pcsLock );
		DEBUG_ONLY( m_pcsLock = NULL );
	}
}
//**********************************************************************



//**********************************************************************
// ------------------------------
// CContextFixedTLPool::Get - get an item from the pool
//
// Entry:		Pointer to user context
//
// Exit:		Pointer to item
//				NULL = out of memory
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CContextFixedTLPool::Get"

template< class T, class S >
T	*CContextFixedTLPool< T, S >::Get( S *const pContext )
{
	CBilink *							pBilink;
	CContextClassFPMTLPoolNode< T > *	pNode;
	T *									pReturn;


	DNASSERT( m_fInitialized != FALSE );
	DNASSERT( m_pGlobalPool != NULL );


	//
	// If the pool is empty, steal the ones in the global pool.
	//
	pBilink = m_blItems.GetNext();
	if ( pBilink == &m_blItems )
	{
		DNEnterCriticalSection( m_pGlobalPool->m_pcsLock );

		pBilink = m_pGlobalPool->m_blItems.GetNext();
		if ( pBilink == &m_pGlobalPool->m_blItems )
		{
			//
			// No items.  Drop global pool lock and allocate a new one.
			//
			DNLeaveCriticalSection( m_pGlobalPool->m_pcsLock );


			pNode = new CContextClassFPMTLPoolNode< T >;
			if ( pNode != NULL )
			{
				if ( (pNode->m_Item.*m_pAllocFunction)( pContext ) == FALSE )
				{
					delete pNode;

					pReturn = NULL;
					goto Exit;
				}
#ifdef TRACK_POOL_STATS
				else
				{
					//
					// Update counter.
					//
					m_dwAllocations++;
				}
#endif // TRACK_POOL_STATS
			}
			else
			{
				pReturn = NULL;
				goto Exit;
			}
		}
		else
		{
			//
			// Separate all the items from the global list.
			// We still have a pointer to the orphaned items (pBilink).
			//

			m_pGlobalPool->m_blItems.RemoveFromList();

			DNASSERT(m_pGlobalPool->m_dwNumItems > 0);

#ifdef TRACK_POOL_STATS
			m_dwSlurpsFromGlobal++;
			if ( m_pGlobalPool->m_dwNumItems > m_dwLargestSlurpFromGlobal )
			{
				m_dwLargestSlurpFromGlobal = m_pGlobalPool->m_dwNumItems;
			}
#endif // TRACK_POOL_STATS

			m_dwNumItems = m_pGlobalPool->m_dwNumItems - 1;	// -1 because we need one right now
			m_pGlobalPool->m_dwNumItems = 0;


			//
			// Drop the lock since we don't need the global pool anymore.
			//
			DNLeaveCriticalSection( m_pGlobalPool->m_pcsLock );


			//
			// Get the first item from the orphaned list.
			//
			pNode = CONTAINING_OBJECT(pBilink, CContextClassFPMTLPoolNode< T >, m_blList);

			//
			// If there was more than one item in the global pool, transfer
			// the remaining orphaned items (after the first) to this pool.
			//
			if (pBilink != pBilink->GetNext())
			{
				pBilink = pBilink->GetNext();
				pNode->m_blList.RemoveFromList();
				m_blItems.InsertBefore(pBilink);
			}
		}
	}
	else
	{
		pNode = CONTAINING_OBJECT(pBilink, CContextClassFPMTLPoolNode< T >, m_blList);
		pBilink->RemoveFromList();

		DNASSERT( m_dwNumItems > 0 );
		m_dwNumItems--;
	}

	//
	// If we're here, we have an entry (it was freshly created, or removed from
	// some pool).  Attempt to initialize it before passing it to the user.
	//
	(pNode->m_Item.*m_pInitFunction)( pContext );

	pReturn = &pNode->m_Item;

#ifdef TRACK_POOL_STATS
	//
	// Update status counts.
	//
	m_dwRetrievals++;
	pNode->m_dwSourceThreadID = GetCurrentThreadId();
#endif // TRACK_POOL_STATS


Exit:

	return	 pReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CContextFixedTLPool::Release - return item to pool
//
// Entry:		Pointer to item
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CContextFixedTLPool::Release"

template< class T, class S >
void	CContextFixedTLPool< T, S >::Release( T *const pItem )
{
	CContextClassFPMTLPoolNode< T >	*pNode;


	DNASSERT( m_fInitialized != FALSE );
	DNASSERT( m_pGlobalPool != NULL );
	DNASSERT( pItem != NULL );
	DBG_CASSERT( sizeof( BYTE* ) == sizeof( pItem ) );
	DBG_CASSERT( sizeof( CContextClassFPMTLPoolNode< T >* ) == sizeof( BYTE* ) );
	pNode = reinterpret_cast<CContextClassFPMTLPoolNode< T >*>( &reinterpret_cast<BYTE*>( pItem )[ -OFFSETOF( CContextClassFPMTLPoolNode< T >, m_Item ) ] );

#if defined(CHECK_FOR_DUPLICATE_CONTEXTCFPM_RELEASE) && defined(DEBUG)
	DNASSERT( ! pNode->m_blList.IsListMember( &m_blItems ));
#endif	// CHECK_FOR_DUPLICATE_CONTEXTCFPM_RELEASE

	(pNode->m_Item.*m_pReleaseFunction)();

#ifdef TRACK_POOL_STATS
	//
	// Update status counts.
	//
	if (pNode->m_dwSourceThreadID == GetCurrentThreadId())
	{
		m_dwReturnsOnSameThread++;
	}
	else
	{
		m_dwReturnsOnDifferentThread++;
	}
#endif // TRACK_POOL_STATS


#ifdef NO_POOLS
	(pNode->m_Item.*m_pDeallocFunction)();
	delete pNode;
#ifdef TRACK_POOL_STATS
	m_dwDeallocations++;
#endif // TRACK_POOL_STATS
#else // ! NO_POOLS
	pNode->m_blList.InsertAfter( &m_blItems );
	m_dwNumItems++;


	//
	// If this pool has built up some extra items, return them to the
	// global pool.
	//
	if ( m_dwNumItems >= 25 )
	{
		CBilink *	pFirstItem;


		//
		// Save a pointer to the first item. 
		//
		pFirstItem = m_blItems.GetNext();
		DNASSERT( pFirstItem != &m_blItems );

		//
		// Orphan the items.
		//
		m_blItems.RemoveFromList();

		
		//
		// Take the lock and transfer the list to the global pool.
		//

		DNEnterCriticalSection( m_pGlobalPool->m_pcsLock );

		m_pGlobalPool->m_blItems.AttachListBefore(pFirstItem);
		m_pGlobalPool->m_dwNumItems += m_dwNumItems;

		DNLeaveCriticalSection( m_pGlobalPool->m_pcsLock );

		m_dwNumItems = 0;
#ifdef TRACK_POOL_STATS
		m_dwDumpsToGlobal++;
#endif // TRACK_POOL_STATS
	}
#endif // ! NO_POOLS
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CContextFixedTLPool::ReleaseWithoutPool - destroy an item without returning it
//										to a pool
//										NOTE: this is a static function
//										and cannot use the 'this' pointer!
//
// Entry:		Pointer to item
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CContextFixedTLPool::ReleaseWithoutPool"

template< class T, class S >
void	CContextFixedTLPool< T, S >::ReleaseWithoutPool( T *const pItem, PVOIDCALLBACK pReleaseFunction, PVOIDCALLBACK pDeallocFunction )
{
	CContextClassFPMTLPoolNode< T >	*pNode;


	DNASSERT( pItem != NULL );
	DBG_CASSERT( sizeof( BYTE* ) == sizeof( pItem ) );
	DBG_CASSERT( sizeof( CContextClassFPMTLPoolNode< T >* ) == sizeof( BYTE* ) );
	pNode = reinterpret_cast<CContextClassFPMTLPoolNode< T >*>( &reinterpret_cast<BYTE*>( pItem )[ -OFFSETOF( CContextClassFPMTLPoolNode< T >, m_Item ) ] );

	DNASSERT( pNode->m_blList.IsEmpty() );
	(pNode->m_Item.*pReleaseFunction)();
	(pNode->m_Item.*pDeallocFunction)();
	delete pNode;
}
//**********************************************************************



#ifdef	__LOCAL_OFFSETOF_DEFINED__
#undef	__LOCAL_OFFSETOF_DEFINED__
#undef	OFFSETOF
#endif	// __LOCAL_OFFSETOF_DEFINED__

#undef DPF_SUBCOMP
#undef DPF_MODNAME




#endif	// __CONTEXT_CLASS_FPM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\dncmni.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DNCOMMONi.h
 *  Content:    DirectPlay Common master internal header file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/28/01    masonb  Created.
 *  04/12/01	VanceO	Moved granting registry permissions into common.
 *
 ***************************************************************************/

#ifndef __DNCOMMONI_H__
#define __DNCOMMONI_H__

// 
// Public includes
//
#include <windows.h>
#include <mmsystem.h>
#include <inetmsg.h>
#include <tapi.h>
#include <stdio.h> // swscanf being used by guidutil.cpp
#include <accctrl.h>
#include <aclapi.h>

// 
// DirectPlay public includes
//
#include "dplay8.h"

// 
// Common private includes
//
#include "dndbg.h"
#include "osind.h"
#include "classbilink.h"
#include "dneterrors.h"
#include "LockedCCFPM.h"
#include "guidutil.h"
#include "creg.h"
#include "strutils.h"
#include "ReadWriteLock.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON


#endif // __DNCOMMONI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\creg.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		creg.cpp
 *  Content:	
 *			This module contains the implementation of the CRegistry class.
 *			For a class description, see creg.h
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/16/99	rodtoll	Created
 *	08/18/99	rodtoll	Added Register/UnRegister that can be used to
 *						allow COM objects to register themselves.
 *	08/25/99	rodtoll	Updated to provide read/write of binary (blob) data
 *	10/05/99	rodtoll	Added DPF_MODNAMEs
 *	10/07/99	rodtoll	Updated to work in Unicode
 *	10/08/99	rodtoll	Fixes to DeleteKey / Reg/UnReg for Win9X
 *	10/15/99	rodtoll	Plugged some memory leaks
 *	10/27/99	pnewson	added Open() call that takes a GUID
 *	01/18/00	mjn		Added GetMaxKeyLen function
 *	01/24/00	mjn		Added GetValueSize function
 * 	01/24/00	rodtoll	Fixed error handling for ReadString (Unicode version)
 * 	04/21/2000 	rodtoll Bug #32889 - Does not run on Win2k on non-admin account 
 *             	rodtoll Bug #32952 - Does not run on Win95 GOLD w/o IE4 -- modified
 *                     	to allow reads of REG_BINARY when expecting REG_DWORD
 *	05/02/00	mjn		Changed CRegistry::Open() to use KEY_READ when Create set to FALSE
 *  06/08/00    rmt     Updated to use common string utils
 *  07/06/00	rmt		Modified to allow seperate read/write parameter
 * 	07/09/2000	rodtoll	Added signature bytes 
 *  07/21/00	rmt		Fixed a memory leak
 *  08/08/2000	rmt		Bug #41736 - AV in call to lstrcpy by COM_GetDllName 
 *	08/28/2000	masonb	Voice Merge: Modified platform checks to use osind.cpp layer
 *  08/30/2000	rodtoll	Bug #171822 - PREFIX Bug
 *  04/13/2001	VanceO	Moved granting registry permissions into common, and
 *						added DeleteValue and EnumValues.
 *  06/19/2001  RichGr  DX8.0 added special security rights for "everyone" - remove them if
 *                      they exist with new RemoveAllAccessSecurityPermissions() method.
 ***************************************************************************/

#include "dncmni.h"




// Security function prototypes

typedef BOOL (*PALLOCATEANDINITIALIZESID)(
  PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, // authority
  BYTE nSubAuthorityCount,                        // count of subauthorities
  DWORD dwSubAuthority0,                          // subauthority 0
  DWORD dwSubAuthority1,                          // subauthority 1
  DWORD dwSubAuthority2,                          // subauthority 2
  DWORD dwSubAuthority3,                          // subauthority 3
  DWORD dwSubAuthority4,                          // subauthority 4
  DWORD dwSubAuthority5,                          // subauthority 5
  DWORD dwSubAuthority6,                          // subauthority 6
  DWORD dwSubAuthority7,                          // subauthority 7
  PSID *pSid                                      // SID
);

typedef VOID (*PBUILDTRUSTEEWITHSID)(
  PTRUSTEE pTrustee,  // structure
  PSID pSid           // trustee name
);

typedef DWORD (*PSETENTRIESINACL)(
  ULONG cCountOfExplicitEntries,           // number of entries
  PEXPLICIT_ACCESS pListOfExplicitEntries, // buffer
  PACL OldAcl,                             // original ACL
  PACL *NewAcl                             // new ACL
);

typedef DWORD (*PSETSECURITYINFO)(
  HANDLE handle,                     // handle to object
  SE_OBJECT_TYPE ObjectType,         // object type
  SECURITY_INFORMATION SecurityInfo, // buffer
  PSID psidOwner,                    // new owner SID
  PSID psidGroup,                    // new primary group SID
  PACL pDacl,                        // new DACL
  PACL pSacl                         // new SACL
);

typedef PVOID (*PFREESID)(
  PSID pSid   // SID to free
);




#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::CRegistry"
// CRegistry Constructor
//
// This is the default constructor for the registry class.  It
// is used to construct a registry object which has not yet
// opened a handle to the registry.  Open must be called before
// this object can be used.
//
// Parameters:
// N/A
//
// Returns:
// N/A
//
CRegistry::CRegistry( ): m_isOpen(FALSE), m_dwSignature(VSIG_CREGISTRY)
{
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::CRegistry"
// CRegistry Copy Constructor
//
// This is the copy constructor for the class which attempts to
// open a new registry handle at the same point in the registry
// as the registry parameter.  You must check the IsOpen function
// to see if the object was succesfully initialized.
//
// Parameters:
// const CRegistry &registry - The registry object to set this
//                             object to
//
// Returns:
// N/A
//
/*
CRegistry::CRegistry( const CRegistry &registry ): m_isOpen(FALSE), m_dwSignature(VSIG_CREGISTRY)
{
	Open( registry.GetBaseHandle(), FALSE );
}
*/

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::CRegistry"
// CRegistry Constructor
//
// This constructor attempts to open a registry connection using
// the given parameters.  This is equivalent to calling the default
// constructor and then Open with the equivalent parameters.
//
// After using this constructor you should call IsOpen to see if
// the open succeeded.
//
// Parameters:
// HKEY branch - Identifies the branch of the registry to open
//               a connect to.  E.g. HKEY_LOCAL_MACHINE
//               This can also be an HKEY which points to another
//               open portion of the registry
// const TCHAR *pathName - A string specifiying the registry path
//                        to open within the key.  NO leading
//                        slash is required and path is relative
//                        from the patch represented by the branch
//                        parameter.
// BOOL create - Set to TRUE to create the given path if it doesn't
//               exist, FALSE otherwise.
//
// Returns:
// N/A
//
CRegistry::CRegistry( HKEY branch, LPWSTR pathName, BOOL fReadOnly, BOOL create ): m_dwSignature(VSIG_CREGISTRY), m_isOpen(FALSE)
{
	Open( branch, pathName, fReadOnly, create );
}

// CRegistry Destructor
//
// This is the destructor for the class, and will close the connection
// to the registry if this object has one open.
//
// Parameters:
// N/A
//
// Returns:
// N/A
//
CRegistry::~CRegistry() {

	if( m_isOpen ) {
		Close();
	}

	m_dwSignature = VSIG_CREGISTRY_FREE;
}

// DeleteSubKey
//
// This function causes the key specified by the string equivalent of
// the pGuidName parameter to be deleted from the point in the registry
// this object is rooted at, if the key exists.  If the object does not
// have an open connection to the registry, or the keyName is not specified
//
// Parmaters:
// const GUID *pGuidName - GUID whose equivalent string needs to be deleted
//
// Returns:
// BOOL - returns TRUE on success, FALSE on failure
//
BOOL CRegistry::DeleteSubKey( const GUID *pGuidName )
{

   	WCHAR wszGuidString[GUID_STRING_LEN];
	HRESULT hr;
	
	DNASSERT( pGuidName != NULL );

	// convert the guid to a string
	hr = DVStringFromGUID(pGuidName, wszGuidString, GUID_STRING_LEN);
	if (FAILED(hr))
	{
		DPFX(DPFPREP, 0, "DVStringFromGUID failed");
		return FALSE;
	}

	return DeleteSubKey(wszGuidString);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::DeleteSubKey"
// DeleteSubKey
//
// This function causes the key specified by the keyName parameter
// to be deleted from the point in the registry this object is rooted
// at, if the key exists.  If the object does not have an open connection
// to the registry, or the keyName is not specified, FALSE is returned
//
// Parmaters:
// const TCHAR *keyName - key name to delete
//
// Returns:
// BOOL - returns TRUE on success, FALSE on failure
//
BOOL CRegistry::DeleteSubKey( const LPCWSTR keyName ) {

	if( keyName == NULL || !IsOpen() ) return FALSE;

	LONG	retValue;
	
	if( IsUnicodePlatform )
	{
		retValue = RegDeleteKeyW( m_regHandle, keyName );
	}
	else
	{
		LPSTR lpstrKeyName;

		if( FAILED( STR_AllocAndConvertToANSI( &lpstrKeyName, keyName ) ) )
		{
			return FALSE;
		}
		else
		{
			retValue = RegDeleteKeyA( m_regHandle, lpstrKeyName );

			delete [] lpstrKeyName;
		}
	}

	return (retValue == ERROR_SUCCESS);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::DeleteValue"
// DeleteValue
//
// This function causes the value specified by the valueName parameter
// to be deleted from the point in the registry this object is rooted
// at, if the value exists.  If the object does not have an open connection
// to the registry, or the valueName is not specified, FALSE is returned
//
// Parmaters:
// const TCHAR *keyName - key name to delete
//
// Returns:
// BOOL - returns TRUE on success, FALSE on failure
//
BOOL CRegistry::DeleteValue( const LPCWSTR valueName ) {

	if( valueName == NULL || !IsOpen() ) return FALSE;

	LONG	retValue;
	
	if( IsUnicodePlatform )
	{
		retValue = RegDeleteValueW( m_regHandle, valueName );
	}
	else
	{
		LPSTR lpstrValueName;

		if( FAILED( STR_AllocAndConvertToANSI( &lpstrValueName, valueName ) ) )
		{
			return FALSE;
		}
		else
		{
			retValue = RegDeleteValueA( m_regHandle, lpstrValueName );

			delete [] lpstrValueName;
		}
	}

	return (retValue == ERROR_SUCCESS);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::Open"
// Open
//
// This function opens a connection to the registry in the branch
// specified by branch with the path specified by pathName.  If
// the path doesn't exist in the registry it will be created if
// the create parameters is set to true, otherwise the call will
// fail.
//
// If this object already has an open connection to the registry
// the previous connection will be closed before this one is
// attempted.
//
// Parameters:
// HKEY branch - A handle to a registry location where the open
//               will be rooted.  E.g. HKEY_LOCAL_MACHINE
// const TCHAR *path - The path relative to the root specified by
//                    branch where the registry connection will
//                    be opened.
// BOOL create - Settings this parameter conrols how this function
//               handles opens on paths which don't exists.  If set
//               to TRUE the path will be created, if set to FALSE
//               the function will fail if the path doesn't exist.
//
// Returns:
// BOOL - TRUE on success, FALSE on failure.
//
BOOL CRegistry::Open( HKEY branch, const LPCWSTR pathName, BOOL fReadOnly, BOOL create, BOOL fCustomSAM, REGSAM samCustom ) {

	DWORD	dwResult;	// Temp used in call to RegXXXX
	LONG	result;		// used to store results

	if( pathName == NULL )
		return FALSE;

	// If there is an open connection, close it.
	if( m_isOpen ) {
		Close();
	}

	m_fReadOnly = fReadOnly;

	if( IsUnicodePlatform )
	{
		// Create or open the key based on create parameter
		if( create ) {
			result = RegCreateKeyExW( branch, pathName, 0, NULL, REG_OPTION_NON_VOLATILE, (fCustomSAM) ? samCustom : KEY_ALL_ACCESS,
				                     NULL, &m_regHandle, &dwResult );
		} else {
			result = RegOpenKeyExW( branch, pathName, 0, (fReadOnly) ? KEY_READ : ((fCustomSAM) ? samCustom : KEY_ALL_ACCESS), &m_regHandle );
		}
	}
	else
	{
		LPSTR lpszKeyName;

		if( STR_AllocAndConvertToANSI( &lpszKeyName, pathName ) == S_OK && pathName )
		{
			if( create ) {
				result = RegCreateKeyExA( branch, lpszKeyName, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
					                     NULL, &m_regHandle, &dwResult );
			} else {
				result = RegOpenKeyExA( branch, lpszKeyName, 0, (fReadOnly) ? KEY_READ : KEY_ALL_ACCESS, &m_regHandle );
			}

			delete [] lpszKeyName;
		}
		else
		{
			return FALSE;
		}
	}

	// If succesful, initialize object, otherwise set it to
	// not open state.
	if( result == ERROR_SUCCESS ) {
		m_isOpen	 = TRUE;
		m_baseHandle = branch;
		return TRUE;

	} else {
		m_isOpen = FALSE;
		return FALSE;
	}

}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::Open"
// Open
//
// This function opens a connection to the registry in the branch
// specified by branch with the path specified by pathName.  If
// the path doesn't exist in the registry it will be created if
// the create parameters is set to true, otherwise the call will
// fail.
//
// In this version of the function, the path is specified as
// a guid instead of a string. The function will attempt to open
// a key with a name in the form "{CB4961DB-D2FA-43f3-942A-991D9294DDBB}"
// that corresponds to the guid as you would expect.
//
// If this object already has an open connection to the registry
// the previous connection will be closed before this one is
// attempted.
//
// Parameters:
// HKEY branch - A handle to a registry location where the open
//               will be rooted.  E.g. HKEY_LOCAL_MACHINE
// const LPGUID lpguid - The path relative to the root specified by
//                    branch where the registry connection will
//                    be opened. See comment above.
// BOOL create - Settings this parameter conrols how this function
//               handles opens on paths which don't exists.  If set
//               to TRUE the path will be created, if set to FALSE
//               the function will fail if the path doesn't exist.
//
// Returns:
// BOOL - TRUE on success, FALSE on failure.
//
BOOL CRegistry::Open( HKEY branch, const GUID* lpguid, BOOL fReadOnly, BOOL create, BOOL fCustomSAM, REGSAM samCustom ) {

	WCHAR wszGuidString[GUID_STRING_LEN];
	HRESULT hr;
	
	DNASSERT( lpguid != NULL );

	// If there is an open connection, close it.
	if( m_isOpen ) {
		Close();
	}

	m_fReadOnly = fReadOnly;

	// convert the guid to a string
	hr = DVStringFromGUID(lpguid, wszGuidString, GUID_STRING_LEN);
	if (FAILED(hr))
	{
		DPFX(DPFPREP, 0, "DVStringFromGUID failed");
		return FALSE;
	}

	return Open(branch, wszGuidString, fReadOnly, create, fCustomSAM, samCustom);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::Close"
// Close
//
// This function will close an open connection to the registry
// if this object has one.  Otherwise it does nothing.
//
// Parameters:
// N/A
//
// Returns:
// BOOL - Returns TRUE on success, FALSE on failure.  If the object
//        is not open it will return TRUE.
//
BOOL CRegistry::Close() {

	LONG retValue;

	if( m_isOpen ) {
		retValue = RegCloseKey( m_regHandle );
        if( retValue == ERROR_SUCCESS )
        {
            m_isOpen = FALSE;
            return TRUE;
        }
        else
        {
            return FALSE;
        }
	} else {
		return TRUE;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::EnumKeys"
// EnumKeys
//
// This function can be used to enumerate the keys at the point
// in the registry rooted at the root this object was opened
// with, at the path specified when opening the object.
//
// To properly enumerate the keys you should pass 0 as the index on
// the first call, and increment the index parameter by one on each
// call.  You can stop enumerating when the function returns FALSE.
//
// Parameters:
// LPWSTR lpwStrName - The current key in the enumeration will be returned
//                 in this string.  Unless the enumeration fails or
//                 ended at which case this parameter won't be touched.
//
// LPDWORD lpdwStringLen - pointer to length of string buffer, or place to
//						to store size required.
//
// DWORD index - The current enum index.  See above for details.
//
// Returns:
// BOOL - FALSE when enumeration is done or on error, TRUE otherwise.
//
BOOL CRegistry::EnumKeys( LPWSTR lpwStrName, LPDWORD lpdwStringLen, DWORD index )
{
	if( IsUnicodePlatform )
	{
	    wchar_t buffer[MAX_REGISTRY_STRING_SIZE];
	    DWORD   bufferSize = MAX_REGISTRY_STRING_SIZE;
	    FILETIME tmpTime;

	    if( RegEnumKeyExW( m_regHandle, index, buffer, &bufferSize, NULL, NULL, NULL, &tmpTime ) != ERROR_SUCCESS )
	    {
	        return FALSE;
	    }
	    else
	    {
	    	if( bufferSize+1 > *lpdwStringLen  )
	    	{
	    		*lpdwStringLen = bufferSize+1;
	    		return FALSE;
	    	}

	    	lstrcpyW( lpwStrName, buffer );

			*lpdwStringLen = bufferSize+1;
	    	
	        return TRUE;
	    }	
	}
	else
	{
	    char buffer[MAX_REGISTRY_STRING_SIZE];
	    DWORD   bufferSize = MAX_REGISTRY_STRING_SIZE;
	    FILETIME tmpTime;

	    if( RegEnumKeyExA( m_regHandle, index, buffer, &bufferSize, NULL, NULL, NULL, &tmpTime ) != ERROR_SUCCESS )
	    {
	        return FALSE;
	    }
	    else
	    {
	    	if( bufferSize+1 > *lpdwStringLen )
	    	{
	    		*lpdwStringLen = bufferSize+1;
	    		return FALSE;
	    	}

	    	if( FAILED( STR_jkAnsiToWide( lpwStrName, buffer, *lpdwStringLen ) ) )
	    	{
	    		return FALSE;
	    	}
	    	else
	    	{
				*lpdwStringLen = bufferSize+1;
	    	    return TRUE;
	    	}
	    }	
		

    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::EnumValues"
// EnumValues
//
// This function can be used to enumerate the values at the point
// in the registry rooted at the root this object was opened
// with, at the path specified when opening the object.
//
// To properly enumerate the values you should pass 0 as the index on
// the first call, and increment the index parameter by one on each
// call.  You can stop enumerating when the function returns FALSE.
//
// Parameters:
// LPWSTR lpwStrName - The current value in the enumeration will be returned
//                 in this string.  Unless the enumeration fails or
//                 ended at which case this parameter won't be touched.
//
// LPDWORD lpdwStringLen - pointer to length of string buffer, or place to
//						to store size required.
//
// DWORD index - The current enum index.  See above for details.
//
// Returns:
// BOOL - FALSE when enumeration is done or on error, TRUE otherwise.
//
BOOL CRegistry::EnumValues( LPWSTR lpwStrName, LPDWORD lpdwStringLen, DWORD index )
{
	if( IsUnicodePlatform )
	{
	    wchar_t buffer[MAX_REGISTRY_STRING_SIZE];
	    DWORD   bufferSize = MAX_REGISTRY_STRING_SIZE;

	    if( RegEnumValueW( m_regHandle, index, buffer, &bufferSize, NULL, NULL, NULL, NULL ) != ERROR_SUCCESS )
	    {
	        return FALSE;
	    }
	    else
	    {
	    	if( bufferSize+1 > *lpdwStringLen  )
	    	{
	    		*lpdwStringLen = bufferSize+1;
	    		return FALSE;
	    	}

	    	lstrcpyW( lpwStrName, buffer );

			*lpdwStringLen = bufferSize+1;
	    	
	        return TRUE;
	    }	
	}
	else
	{
	    char buffer[MAX_REGISTRY_STRING_SIZE];
	    DWORD   bufferSize = MAX_REGISTRY_STRING_SIZE;

	    if( RegEnumValueA( m_regHandle, index, buffer, &bufferSize, NULL, NULL, NULL, NULL ) != ERROR_SUCCESS )
	    {
	        return FALSE;
	    }
	    else
	    {
	    	if( bufferSize+1 > *lpdwStringLen )
	    	{
	    		*lpdwStringLen = bufferSize+1;
	    		return FALSE;
	    	}

	    	if( FAILED( STR_jkAnsiToWide( lpwStrName, buffer, *lpdwStringLen ) ) )
	    	{
	    		return FALSE;
	    	}
	    	else
	    	{
				*lpdwStringLen = bufferSize+1;
	    	    return TRUE;
	    	}
	    }	
		

    }
}


// This comment documents ALL of the Read<Data Type> functions which
// follow.
//
// CRegistry Read<Data Type> Functions
//
// The set of ReadXXXXX functions for the CRegistry class are
// responsible for reading <data type> type data from the registry.
// The object must have an open connection to the registry before
// any of these functions may be used.  A connection to the registry
// can be made with the Open call or the constructors.
//
// Parameters:
// const TCHAR *keyName - The keyname of the data you wish to read
// <datatype> & - A reference to the specific data type where
//				  the data will be placed on a succesful read.
//                This parameter will be unaffected if the read
//                fails.
//
// Returns:
// BOOL - Returns TRUE on success, FALSE on failure.
//


// This comment documents ALL of the Write<Data Type> functions which
// follow.
//
// CRegistry Write<Data Type> Functions
//
// The set of Write<Data Type> functions for the CRegistry class are
// responsible for writing <data type> type data to the registry.
// The object must have an open connection to the registry before
// any of these functions may be used.  A connection to the registry
// can be made with the Open call or the constructors.
//
// Parameters:
// const TCHAR *keyName - The keyname of the data you wish to write
// <datatype> & - A reference to the specific data type which
//                contains the data to be written to the registry.
//
// Returns:
// BOOL - Returns TRUE on success, FALSE on failure.
//
#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::WriteString"
// WriteString
//
// Writes Strings's to the registry, see block comment above
// for details.
//
BOOL CRegistry::WriteString( LPCWSTR keyName, const LPCWSTR lpwstrValue )
{

	LONG		retValue;
	
	if( keyName == NULL || !IsOpen() ) return FALSE;

	if( m_fReadOnly )
	{
	    DPFX(DPFPREP, 0, "Attempt to Write to read-only CRegistry key");
	    return FALSE;
	}

	if( IsUnicodePlatform )
	{
		retValue = RegSetValueExW( m_regHandle, keyName, 0, REG_SZ, (const unsigned char *) lpwstrValue, (lstrlenW( lpwstrValue )+1)*sizeof(wchar_t) );	
	}
	else
	{
		LPSTR lpstrKeyName;
		LPSTR lpstrValue;
		
		if( FAILED( STR_AllocAndConvertToANSI( &lpstrKeyName, keyName ) ) )
		{
			return FALSE;
		}

		if( FAILED( STR_AllocAndConvertToANSI( &lpstrValue, lpwstrValue ) ) )
		{
			delete [] lpstrKeyName;
			return FALSE;
		}
		
		retValue = RegSetValueExA( m_regHandle, lpstrKeyName, 0, REG_SZ, (const unsigned char *) lpstrValue, lstrlenA( lpstrValue )+1 );

		delete [] lpstrKeyName;
		delete [] lpstrValue;
	}

	return (retValue == ERROR_SUCCESS);

}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::ReadString"
// ReadString
//
// Reads CString's from the registry, see block comment above
// for details.
//
BOOL CRegistry::ReadString( const LPCWSTR keyName, LPWSTR lpwstrValue, LPDWORD lpdwLength )
{
	if( keyName == NULL || !IsOpen() ) return FALSE;

	LONG		retValue;
	DWORD		tmpSize;
	DWORD		tmpType;	

	if( IsUnicodePlatform )
	{
		wchar_t		buffer[MAX_REGISTRY_STRING_SIZE];
		tmpSize = MAX_REGISTRY_STRING_SIZE*sizeof(wchar_t);
		
		retValue = RegQueryValueExW( m_regHandle, keyName, 0, &tmpType, (unsigned char *) &buffer[0], &tmpSize );
		if (retValue != ERROR_SUCCESS)
		{
			return FALSE;
		}

		if( (tmpSize/2) > *lpdwLength || !lpwstrValue )
		{
			*lpdwLength = (tmpSize/2);
			return FALSE;
		}

		lstrcpyW( lpwstrValue, buffer );

		*lpdwLength = (tmpSize/2);

		return TRUE;
	}
	else
	{
		LPSTR lpstrKeyName;
		char buffer[MAX_REGISTRY_STRING_SIZE];
		tmpSize = MAX_REGISTRY_STRING_SIZE;

		if( FAILED( STR_AllocAndConvertToANSI( &lpstrKeyName, keyName ) ) )
			return FALSE;
			
		retValue = RegQueryValueExA( m_regHandle, lpstrKeyName, 0, &tmpType, (unsigned char *) &buffer[0], &tmpSize );
		if (retValue != ERROR_SUCCESS)
		{
			delete [] lpstrKeyName;
			return FALSE;
		}

		delete [] lpstrKeyName;

		if( tmpSize > *lpdwLength || !lpwstrValue )
		{
			*lpdwLength = tmpSize;
			return FALSE;
		}

		if( FAILED( STR_jkAnsiToWide( lpwstrValue, buffer, *lpdwLength ) ) )
			return FALSE;

		*lpdwLength = tmpSize;	
	}

	if( retValue == ERROR_SUCCESS && tmpType == REG_SZ ) {
		return TRUE;
	} else {
		return FALSE;
	}

}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::WriteGUID"
// WriteGUID
//
// Writes GUID's to the registry, see block comment above
// for details.  The GUID is written in the format it is usually
// displayed.  (But without the '{''s).
//
BOOL CRegistry::WriteGUID( LPCWSTR keyName, const GUID &guid )
{
	LONG retValue;
	WCHAR wszGuidString[GUID_STRING_LEN];
	HRESULT hr;

	if( m_fReadOnly )
	{
	    DPFX(DPFPREP, 0, "Attempt to Write to read-only CRegistry key");
	    return FALSE;
	}

	hr = DVStringFromGUID(&guid, wszGuidString, GUID_STRING_LEN);
	if (FAILED(hr))
	{
		DPFX(DPFPREP, 0, "DVStringFromGUID failed, code: 0x%08x", hr);
		return FALSE;
	}

	if( IsUnicodePlatform )
	{
	    retValue = RegSetValueExW( m_regHandle, keyName, 0, REG_SZ, (const unsigned char *) wszGuidString, (lstrlenW( wszGuidString )+1)*sizeof(wchar_t) );
	}
	else
	{
		LPSTR lpstrKeyName;
		LPSTR lpstrKeyValue;

		hr = STR_AllocAndConvertToANSI( &lpstrKeyName, keyName );
		if (FAILED(hr))
		{
			DPFX(DPFPREP, 0, "DVStringFromGUID failed, code: 0x%08x", hr);
			return FALSE;
		}
		
		hr = STR_AllocAndConvertToANSI( &lpstrKeyValue, wszGuidString );
		if (FAILED(hr))
		{
			DPFX(DPFPREP, 0, "DVStringFromGUID failed, code: 0x%08x", hr);
		    delete [] lpstrKeyName;
			return FALSE;
		}

	    retValue = RegSetValueExA( m_regHandle, lpstrKeyName, 0, REG_SZ, (const unsigned char *) lpstrKeyValue, lstrlenA( lpstrKeyValue )+1);

	    delete [] lpstrKeyName;
	    delete [] lpstrKeyValue;
	}

	if( retValue == ERROR_SUCCESS )
		return TRUE;
	else
		return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::ReadGUID"
// ReadGUID
//
// Reads GUID's from the registry, see block comment above
// for details.  The GUID must be stored in the format written by
// the WriteGUID function or it will not be read correctly.
//
BOOL CRegistry::ReadGUID( LPCWSTR keyName, GUID &guid )
{
	wchar_t		buffer[MAX_REGISTRY_STRING_SIZE];
	DWORD		dwLength = MAX_REGISTRY_STRING_SIZE;
    HRESULT hr;

    if( !ReadString( keyName, buffer, &dwLength ) )
    {
        return FALSE;
    }
    else
    {
    	hr = DVGUIDFromString(buffer, &guid);
    	if (FAILED(hr))
    	{
    		DPFX(DPFPREP, 0, "DVGUIDFromString failed, code: 0x%08x", hr);
    		return FALSE;
    	}
    	return TRUE;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::WriteDWORD"
// WriteDWORD
//
// Writes DWORDS to the registry, see block comment above
// for details.
//
BOOL CRegistry::WriteDWORD( LPCWSTR keyName, DWORD value ) {

	LONG		retValue;

	if( keyName == NULL || !IsOpen() ) return FALSE;

	if( m_fReadOnly )
	{
	    DPFX(DPFPREP, 0, "Attempt to Write to read-only CRegistry key");
	    return FALSE;
	}

	if( IsUnicodePlatform )
	{
		retValue = RegSetValueExW( m_regHandle, keyName, 0, REG_DWORD, (const unsigned char *) &value, sizeof( DWORD ) );		
	}
	else
	{
		LPSTR lpszKeyName;

		if( FAILED( STR_AllocAndConvertToANSI( &lpszKeyName, keyName ) ) )
			return FALSE;

		retValue = RegSetValueExA( m_regHandle, lpszKeyName, 0, REG_DWORD, (const unsigned char *) &value, sizeof( DWORD ) );

		delete [] lpszKeyName;
	}

	return (retValue == ERROR_SUCCESS);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Cregistry::ReadBOOL"
BOOL CRegistry::ReadBOOL( LPCWSTR keyName, BOOL &result )
{
	DWORD tmpResult;

	if( ReadDWORD( keyName, tmpResult ) )
	{
		result = (BOOL) tmpResult;
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::WriteBOOL"
BOOL CRegistry::WriteBOOL( LPCWSTR keyName, BOOL value )
{
	DWORD tmpValue = (DWORD) value;

	if( m_fReadOnly )
	{
	    DPFX(DPFPREP, 0, "Attempt to Write to read-only CRegistry key");
	    return FALSE;
	}

	return WriteDWORD( keyName, tmpValue );
}


#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::ReadDWORD"
// ReadDWORD
//
// Reads DWORDS from the registry, see block comment above
// for details.
//
BOOL CRegistry::ReadDWORD( LPCWSTR keyName, DWORD &result ) {

	if( keyName == NULL || !IsOpen() ) return FALSE;

	LONG		retValue;
	DWORD		tmpValue;
	DWORD		tmpType;
	DWORD		tmpSize;

	tmpSize = sizeof( DWORD );

	if( IsUnicodePlatform )
	{
		retValue = RegQueryValueExW( m_regHandle, keyName, 0, &tmpType, (unsigned char *) &tmpValue, &tmpSize );
	}
	else
	{
		LPSTR lpszKeyName;

		if( FAILED( STR_AllocAndConvertToANSI( &lpszKeyName, keyName ) ) )
			return FALSE;

		retValue = RegQueryValueExA( m_regHandle, lpszKeyName, 0, &tmpType, (unsigned char *) &tmpValue, &tmpSize );
		
		delete [] lpszKeyName;
	}

	if( retValue == ERROR_SUCCESS && (tmpType == REG_DWORD || tmpType == REG_BINARY) && tmpSize == sizeof(DWORD) ) {
		result = tmpValue;
		return TRUE;
	} else {
		return FALSE;
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::Register"
BOOL CRegistry::Register( LPCWSTR lpszProgID, const LPCWSTR lpszDesc, const LPCWSTR lpszProgName, GUID guidCLSID, LPCWSTR lpszVerIndProgID )
{
	CRegistry core;

	DNASSERT( lpszDesc != NULL );
	DNASSERT( lpszProgID != NULL );

	// Build a string representation of the GUID from the GUID
    wchar_t lpszGUID[MAX_REGISTRY_STRING_SIZE];
    wchar_t lpszKeyName[_MAX_PATH];

    swprintf( lpszGUID, L"{%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}", guidCLSID.Data1, guidCLSID.Data2, guidCLSID.Data3, 
               guidCLSID.Data4[0], guidCLSID.Data4[1], guidCLSID.Data4[2], guidCLSID.Data4[3],
               guidCLSID.Data4[4], guidCLSID.Data4[5], guidCLSID.Data4[6], guidCLSID.Data4[7] );	

	// Write the HKEY_CLASSES_ROOT\CLSID\{GUID} section
    swprintf( lpszKeyName, L"CLSID\\%s", lpszGUID );

    if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName, FALSE, TRUE ) )
    {
    	DPFX(DPFPREP,  0, "Unable to open/create registry key \"%S\"", lpszKeyName );
    	return FALSE;
    }

    core.WriteString( L"", lpszDesc );
    core.Close();

	// Write the HKEY_CLASSES_ROOT\CLSID\{GUID}\InProcServer32 section
    swprintf( lpszKeyName, L"CLSID\\%s\\InProcServer32", lpszGUID );

    if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName, FALSE, TRUE ) )
    {
    	DPFX(DPFPREP,  0, "Unable to open/create registry key \"%S\"", lpszKeyName );
    	return FALSE;
    }
    core.WriteString( L"", lpszProgName );
    core.WriteString( L"ThreadingModel", L"Both" );
    core.Close();

	// Write the HKEY_CLASSES_ROOT\CLSID\{GUID}\VersionIndependentProgID section
    if( lpszVerIndProgID != NULL )
    {
	    swprintf( lpszKeyName, L"CLSID\\%s\\VersionIndependentProgID", lpszGUID );

	    if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName, FALSE, TRUE ) )
	    {
	    	DPFX(DPFPREP,  0, "Unable to open/create verind registry key \"%S\"", lpszKeyName );
	    	return FALSE;
	    }
    
	    core.WriteString( L"", lpszVerIndProgID );
	    core.Close();
	}

	// Write the HKEY_CLASSES_ROOT\CLSID\{GUID}\ProgID section
    swprintf( lpszKeyName, L"CLSID\\%s\\ProgID", lpszGUID );

    if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName, FALSE, TRUE ) )
    {
    	DPFX(DPFPREP,  0, "Unable to open/create verind registry key \"%S\"", lpszKeyName );
    	return FALSE;
    }

    core.WriteString( L"", lpszProgID );
    core.Close();

	// Write The VersionIND ProgID
	
	if( lpszVerIndProgID != NULL )
	{
		if( !core.Open( HKEY_CLASSES_ROOT, lpszVerIndProgID, FALSE, TRUE ) )
		{
			DPFX(DPFPREP,  0, "Unable to open/create reg key \"%S\"", lpszVerIndProgID );
		}
		else
		{
			core.WriteString( L"", lpszDesc );
			core.Close();			
		}

		swprintf( lpszKeyName, L"%s\\CLSID", lpszVerIndProgID );

		if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName, FALSE, TRUE ) )
		{
			DPFX(DPFPREP,  0, "Unable to open/create reg key \"%S\"", lpszKeyName );
		}
		else
		{
			core.WriteString( L"", lpszGUID );
			core.Close();
		}

		swprintf( lpszKeyName, L"%s\\CurVer", lpszVerIndProgID );

		if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName, FALSE, TRUE ) )
		{
			DPFX(DPFPREP,  0, "Unable to open/create reg key \"%S\"", lpszKeyName );
		}
		else
		{
			core.WriteString( L"", lpszProgID );
			core.Close();
		}		
	}

	if( !core.Open( HKEY_CLASSES_ROOT, lpszProgID, FALSE, TRUE ) )
	{
		DPFX(DPFPREP,  0, "Unable to open/create reg key \"%S\"", lpszKeyName );
	}
	else
	{
		core.WriteString( L"", lpszDesc );
		core.Close();
	}
	
	swprintf( lpszKeyName, L"%s\\CLSID", lpszProgID );

	if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName, FALSE, TRUE ) )
	{
		DPFX(DPFPREP,  0, "Unable to open/create reg key \"%S\"", lpszKeyName );
	}
	else
	{
		core.WriteString( L"", lpszGUID );
		core.Close();
	}

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::UnRegister"
BOOL CRegistry::UnRegister( GUID guidCLSID )
{
	CRegistry core, cregClasses, cregSub;

	// Build a string representation of the GUID from the GUID
    wchar_t lpszGUID[MAX_REGISTRY_STRING_SIZE];
    wchar_t lpszKeyName[_MAX_PATH];
    wchar_t szProgID[MAX_REGISTRY_STRING_SIZE];
    wchar_t szVerIndProgID[MAX_REGISTRY_STRING_SIZE];
    DWORD dwSize = MAX_REGISTRY_STRING_SIZE;

    swprintf( lpszGUID, L"{%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}", guidCLSID.Data1, guidCLSID.Data2, guidCLSID.Data3, 
               guidCLSID.Data4[0], guidCLSID.Data4[1], guidCLSID.Data4[2], guidCLSID.Data4[3],
               guidCLSID.Data4[4], guidCLSID.Data4[5], guidCLSID.Data4[6], guidCLSID.Data4[7] );	

	if( !cregClasses.Open( HKEY_CLASSES_ROOT, L"", FALSE, FALSE ) )
	{
		DPFX(DPFPREP,  0, "Unable to open HKEY_CLASSES_ROOT" );
		return FALSE;
	}

	// Write the HKEY_CLASSES_ROOT\CLSID\{GUID} section
    swprintf( lpszKeyName, L"CLSID\\%s\\ProgID", lpszGUID );

	if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName, FALSE, FALSE ) )
	{
		DPFX(DPFPREP,  0, "Unable to open \"%S\"", lpszKeyName );
		return FALSE;
	}

	dwSize = MAX_REGISTRY_STRING_SIZE;	

    if( core.ReadString( L"", szProgID, &dwSize ) )
    {
    	swprintf( lpszKeyName, L"%s\\CLSID", szProgID );
    	
    	if( !cregClasses.DeleteSubKey( lpszKeyName ) )
    	{
    		DPFX(DPFPREP,  0, "Unable to delete \"%S\"", lpszKeyName );
    		return FALSE;
    	}
    	
    	if( !cregClasses.DeleteSubKey( szProgID ) )
    	{
    		DPFX(DPFPREP,  0, "Unable to delete HKEY_CLASSES_ROOT/ProgID" );

    		return FALSE;
    	}
    }

	core.Close();

    swprintf( lpszKeyName, L"CLSID\\%s\\VersionIndependentProgID", lpszGUID );

	if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName, FALSE, FALSE ) )
	{
		DPFX(DPFPREP,  0, "Unable to open \"%S\"", lpszKeyName );
		return FALSE;
	}

	dwSize = MAX_REGISTRY_STRING_SIZE;
	
    if( core.ReadString( L"", szVerIndProgID, &dwSize ) )
    {
    	swprintf( lpszKeyName, L"%s\\CLSID", szVerIndProgID );

    	if( !cregClasses.DeleteSubKey( lpszKeyName ) )
    	{
    		DPFX(DPFPREP,  0, "Unable to delete \"%S\"", lpszKeyName );
    		return FALSE;
    	}

    	swprintf( lpszKeyName, L"%s\\CurVer", szVerIndProgID );

    	if( !cregClasses.DeleteSubKey( lpszKeyName ) )
    	{
    		DPFX(DPFPREP,  0, "Unable to delete \"%S\"", lpszKeyName );
    		return FALSE;
    	}
    	
    	
    	if( !cregClasses.DeleteSubKey( szVerIndProgID ) )
    	{
    		DPFX(DPFPREP,  0, "Unable to delete \"HKEY_CLASSES_ROOT/%S\"", szVerIndProgID);

    		return FALSE;
    	}
    }

    core.Close();

	swprintf( lpszKeyName, L"CLSID\\%s\\InprocServer32", lpszGUID );

	if( !cregClasses.DeleteSubKey( lpszKeyName ) )
	{
		DPFX(DPFPREP,  0, "Unable to delete \"%S\"", lpszKeyName );
		return FALSE;	
	}	
	
	swprintf( lpszKeyName, L"CLSID\\%s\\ProgID", lpszGUID );

	if( !cregClasses.DeleteSubKey( lpszKeyName ) )
	{
		DPFX(DPFPREP,  0, "Unable to delete \"%S\"", lpszKeyName );
		return FALSE;	
	}	
	
	swprintf( lpszKeyName, L"CLSID\\%s\\VersionIndependentProgID", lpszGUID );

	if( !cregClasses.DeleteSubKey( lpszKeyName ) )
	{
		DPFX(DPFPREP,  0, "Unable to delete \"%S\"", lpszKeyName );
		return FALSE;	
	}	

	swprintf( lpszKeyName, L"CLSID\\%s", lpszGUID );

	if( !cregClasses.DeleteSubKey( lpszKeyName ) )
	{
		DPFX(DPFPREP,  0, "Unable to delete \"%S\"", lpszKeyName );
		return FALSE;	
	}

    return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::ReadBlob"
BOOL CRegistry::ReadBlob( LPCWSTR keyName, LPBYTE lpbBuffer, LPDWORD lpdwSize )
{
	if( keyName == NULL || !IsOpen() ) return FALSE;

	LONG		retValue;
	DWORD		tmpType;

	if( IsUnicodePlatform )
	{
		retValue = RegQueryValueExW( m_regHandle, keyName, 0, &tmpType, lpbBuffer, lpdwSize );	
	}
	else
	{
		LPSTR lpszKeyName;
		
		if( FAILED( STR_AllocAndConvertToANSI( &lpszKeyName, keyName ) ) )
			return FALSE;

		retValue = RegQueryValueExA( m_regHandle, lpszKeyName, 0, &tmpType, lpbBuffer, lpdwSize );

		delete [] lpszKeyName;
	}
	
	if( retValue == ERROR_SUCCESS && tmpType == REG_BINARY ) {
		return TRUE;
	} else {
		return FALSE;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::WriteBlob"
BOOL CRegistry::WriteBlob( LPCWSTR keyName, LPBYTE lpbBuffer, DWORD dwSize )
{
	LONG		retValue;

	if( keyName == NULL || !IsOpen() ) return FALSE;

	if( m_fReadOnly )
	{
	    DPFX(DPFPREP, 0, "Attempt to Write to read-only CRegistry key");
	    return FALSE;
	}

	if( IsUnicodePlatform )
	{
		retValue = RegSetValueExW( m_regHandle, keyName, 0, REG_BINARY, lpbBuffer, dwSize );
	}
	else
	{
		LPSTR lpszKeyName;
		
		if( FAILED( STR_AllocAndConvertToANSI( &lpszKeyName, keyName ) ) )
			return FALSE;

		retValue = RegSetValueExA( m_regHandle, lpszKeyName, 0, REG_BINARY, lpbBuffer, dwSize );
		
		delete [] lpszKeyName;	
	}

	return (retValue == ERROR_SUCCESS);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::GetMaxKeyLen"
BOOL CRegistry::GetMaxKeyLen( DWORD &dwMaxKeyLen )
{
	LONG	retVal;

	if ( IsUnicodePlatform )
	{
		retVal = RegQueryInfoKeyW( m_regHandle,NULL,NULL,NULL,NULL,&dwMaxKeyLen,
				NULL,NULL,NULL,NULL,NULL,NULL);
	}
	else
	{
		retVal = RegQueryInfoKeyA( m_regHandle,NULL,NULL,NULL,NULL,&dwMaxKeyLen,
				NULL,NULL,NULL,NULL,NULL,NULL);
	}

	return (retVal == ERROR_SUCCESS);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::GetValueLength"
// GetValueLength
//
// Determines the length of a particular key value
//
BOOL CRegistry::GetValueLength( const LPCWSTR keyName, DWORD *const pdwValueLength )
{
	LONG		retValue;
	DWORD		tmpLength;

	if ( keyName == NULL || pdwValueLength == NULL || !IsOpen() )
	{
		return FALSE;
	}

	if( IsUnicodePlatform )
	{
		DWORD	dwType;
	
			
		retValue = RegQueryValueExW( m_regHandle, keyName, 0, &dwType, NULL, &tmpLength );
		if (retValue != ERROR_SUCCESS)
		{
			return FALSE;
		}

		//
		// if this is a string, we need to compensate for WCHAR characters being
		// returned
		//
		if ( dwType == REG_SZ )
		{
			tmpLength /= sizeof( WCHAR );
		}
	}
	else
	{
		LPSTR lpstrKeyName;

		if( FAILED( STR_AllocAndConvertToANSI( &lpstrKeyName, keyName ) ) )
			return FALSE;
			
		retValue = RegQueryValueExA( m_regHandle, lpstrKeyName, 0, NULL, NULL, &tmpLength );

		delete [] lpstrKeyName;	

		if (retValue != ERROR_SUCCESS)
		{
			return FALSE;
		}
	}

	*pdwValueLength = tmpLength;

	return TRUE;
}



#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::GrantAllAccessSecurityPermissions"
// GrantAllAccessSecurityPermissions
//
// Gives the given key all access for everyone rights
//
// Taken from hresMumbleKeyEx in diregutl.c in the dinput tree.
//
BOOL CRegistry::GrantAllAccessSecurityPermissions()
{
	BOOL						fResult = FALSE;
	HRESULT						hr;
    EXPLICIT_ACCESS				ExplicitAccess;
    PACL						pACL = NULL;
	PSID						pSid = NULL;
	HMODULE						hModuleADVAPI32 = NULL;
	SID_IDENTIFIER_AUTHORITY	authority = SECURITY_WORLD_SID_AUTHORITY;
	PALLOCATEANDINITIALIZESID	pAllocateAndInitializeSid = NULL;
	PBUILDTRUSTEEWITHSID		pBuildTrusteeWithSid = NULL;
	PSETENTRIESINACL			pSetEntriesInAcl = NULL;
	PSETSECURITYINFO			pSetSecurityInfo = NULL;
	PFREESID					pFreeSid = NULL;

	hModuleADVAPI32 = LoadLibraryA( "advapi32.dll" );

	if( !hModuleADVAPI32 )
	{
		DPFX(DPFPREP,  0, "Failed loading advapi32.dll" );
		goto EXIT;
	}

	pFreeSid = reinterpret_cast<PFREESID>( GetProcAddress( hModuleADVAPI32, "FreeSid" ) );
	pSetSecurityInfo = reinterpret_cast<PSETSECURITYINFO>( GetProcAddress( hModuleADVAPI32, "SetSecurityInfo" ) );
	pSetEntriesInAcl = reinterpret_cast<PSETENTRIESINACL>( GetProcAddress( hModuleADVAPI32, "SetEntriesInAclA" ) );
	pBuildTrusteeWithSid = reinterpret_cast<PBUILDTRUSTEEWITHSID>( GetProcAddress( hModuleADVAPI32, "BuildTrusteeWithSidA" ) );
	pAllocateAndInitializeSid = reinterpret_cast<PALLOCATEANDINITIALIZESID>( GetProcAddress( hModuleADVAPI32, "AllocateAndInitializeSid" ) );

	if( !pFreeSid || !pSetSecurityInfo || !pSetEntriesInAcl || !pBuildTrusteeWithSid || !pAllocateAndInitializeSid )
	{
		DPFX(DPFPREP,  0, "Failed loading entry points" );
		goto EXIT;
	}

    // Describe the access we want to create the key with
    ZeroMemory (&ExplicitAccess, sizeof(ExplicitAccess) );
    ExplicitAccess.grfAccessPermissions = ((KEY_ALL_ACCESS & ~WRITE_DAC) & ~WRITE_OWNER);
    									/*KEY_QUERY_VALUE | KEY_SET_VALUE 
                                        | KEY_CREATE_SUB_KEY | KEY_ENUMERATE_SUB_KEYS
                                        | KEY_NOTIFY | KEY_CREATE_LINK
                                        | DELETE | READ_CONTROL; */
    ExplicitAccess.grfAccessMode = SET_ACCESS;      // discard any existing AC info
    ExplicitAccess.grfInheritance =  SUB_CONTAINERS_AND_OBJECTS_INHERIT;

	if (pAllocateAndInitializeSid(
				&authority,
				1, 
				SECURITY_WORLD_RID,  0, 0, 0, 0, 0, 0, 0,
				&pSid
				))
	{
		pBuildTrusteeWithSid(&(ExplicitAccess.Trustee), pSid );

		hr = pSetEntriesInAcl( 1, &ExplicitAccess, NULL, &pACL );

		if( hr == ERROR_SUCCESS )
		{
			hr = pSetSecurityInfo( m_regHandle, SE_REGISTRY_KEY, DACL_SECURITY_INFORMATION, NULL, NULL, pACL, NULL ); 

			if( FAILED( hr ) )
			{
				DPFX(DPFPREP,  0, "Unable to set security for key.  Error! hr=0x%x", hr );
			}
			else
			{
				fResult = TRUE;
			}
		} 
		else
		{
			DPFX(DPFPREP,  0, "SetEntriesInACL failed, hr=0x%x", hr );
		}
	}
	else
	{
		hr = GetLastError();
		DPFX(DPFPREP,  0, "AllocateAndInitializeSid failed lastError=0x%x", hr );
	}

EXIT:

	if( pACL )
	{
		LocalFree( pACL );
	}

	//Cleanup pSid
	if (pSid != NULL)
	{
		(pFreeSid)(pSid);
	}

	if( hModuleADVAPI32 )
	{
		FreeLibrary( hModuleADVAPI32 );
	}

	return fResult;
}



#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::RemoveAllAccessSecurityPermissions"
// RemoveAllAccessSecurityPermissions
//
// Removes "all access for everyone" rights from the specified key.
// This is identical to GrantAllAccessSecurityPermissions(), except that
// now we REVOKE_ACCESS instead of SET_ACCESS, and we don't have to fill
// out the rest of the EXPLICIT_ACCESS struct.
//
//
BOOL CRegistry::RemoveAllAccessSecurityPermissions()
{
	BOOL						fResult = FALSE;
	HRESULT						hr;
    EXPLICIT_ACCESS				ExplicitAccess;
    PACL						pACL = NULL;
	PSID						pSid = NULL;
	HMODULE						hModuleADVAPI32 = NULL;
	SID_IDENTIFIER_AUTHORITY	authority = SECURITY_WORLD_SID_AUTHORITY;
	PALLOCATEANDINITIALIZESID	pAllocateAndInitializeSid = NULL;
	PBUILDTRUSTEEWITHSID		pBuildTrusteeWithSid = NULL;
	PSETENTRIESINACL			pSetEntriesInAcl = NULL;
	PSETSECURITYINFO			pSetSecurityInfo = NULL;
	PFREESID					pFreeSid = NULL;

	hModuleADVAPI32 = LoadLibraryA( "advapi32.dll" );

	if( !hModuleADVAPI32 )
	{
		DPFX(DPFPREP,  0, "Failed loading advapi32.dll" );
		goto EXIT;
	}

	pFreeSid = reinterpret_cast<PFREESID>( GetProcAddress( hModuleADVAPI32, "FreeSid" ) );
	pSetSecurityInfo = reinterpret_cast<PSETSECURITYINFO>( GetProcAddress( hModuleADVAPI32, "SetSecurityInfo" ) );
	pSetEntriesInAcl = reinterpret_cast<PSETENTRIESINACL>( GetProcAddress( hModuleADVAPI32, "SetEntriesInAclA" ) );
	pBuildTrusteeWithSid = reinterpret_cast<PBUILDTRUSTEEWITHSID>( GetProcAddress( hModuleADVAPI32, "BuildTrusteeWithSidA" ) );
	pAllocateAndInitializeSid = reinterpret_cast<PALLOCATEANDINITIALIZESID>( GetProcAddress( hModuleADVAPI32, "AllocateAndInitializeSid" ) );

	if( !pFreeSid || !pSetSecurityInfo || !pSetEntriesInAcl || !pBuildTrusteeWithSid || !pAllocateAndInitializeSid )
	{
		DPFX(DPFPREP,  0, "Failed loading entry points" );
		goto EXIT;
	}

    ZeroMemory (&ExplicitAccess, sizeof(ExplicitAccess) );
	ExplicitAccess.grfAccessMode = REVOKE_ACCESS;		//Remove any existing ACEs for the specified trustee

	if (pAllocateAndInitializeSid(
				&authority,
				1, 
				SECURITY_WORLD_RID,  0, 0, 0, 0, 0, 0, 0,	// trustee is "Everyone"
				&pSid
				))
	{
		pBuildTrusteeWithSid(&(ExplicitAccess.Trustee), pSid );

		hr = pSetEntriesInAcl( 1, &ExplicitAccess, NULL, &pACL );

		if( hr == ERROR_SUCCESS )
		{
			hr = pSetSecurityInfo( m_regHandle, SE_REGISTRY_KEY, DACL_SECURITY_INFORMATION, NULL, NULL, pACL, NULL ); 

			if( FAILED( hr ) )
			{
				DPFX(DPFPREP,  0, "Unable to set security for key.  Error! hr=0x%x", hr );
			}
			else
			{
				fResult = TRUE;
			}
		} 
		else
		{
			DPFX(DPFPREP,  0, "SetEntriesInACL failed, hr=0x%x", hr );
		}
	}
	else
	{
		hr = GetLastError();
		DPFX(DPFPREP,  0, "AllocateAndInitializeSid failed lastError=0x%x", hr );
	}

EXIT:

	if( pACL )
	{
		LocalFree( pACL );
	}

	//Cleanup pSid
	if (pSid != NULL)
	{
		(pFreeSid)(pSid);
	}

	if( hModuleADVAPI32 )
	{
		FreeLibrary( hModuleADVAPI32 );
	}

	return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\creg.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		creg.h
 *  Content:	definition of the CRegistry class
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/16/99	rodtoll	Created
 *	08/18/99	rodtoll	Added Register/UnRegister that can be used to
 *						allow COM objects to register themselves.
 *	08/25/99	rodtoll	Updated to provide read/write of binary (blob) data
 *	10/07/99	rodtoll	Updated to work in Unicode
 *	10/27/99	pnewson	added Open() call that takes a GUID
 *	01/18/00	mjn		Added GetMaxKeyLen function
 *	01/24/00	mjn		Added GetValueSize function
 *	04/05/2000	jtk		Changed GetVauleSize to GetValueLength and modified to return WCHAR lengths
 * 	04/21/2000   	rodtoll Bug #32889 - Does not run on Win2k on non-admin account 
 *      	        rodtoll Bug #32952 - Does not run on Win95 GOLD w/o IE4 -- modified
 *		                to allow reads of REG_BINARY when expecting REG_DWORD 
 * 	07/09/2000	rodtoll	Added signature bytes 
 *	08/28/2000	masonb	Voice Merge: Modified platform checks to use osind.cpp layer (removed CRegistry::CheckUnicodePlatform)
 *  04/13/2001	VanceO	Moved granting registry permissions into common, and
 *						added DeleteValue and EnumValues.
 *  06/19/2001  RichGr  DX8.0 added special security rights for "everyone" - remove them if
 *                      they exist with new RemoveAllAccessSecurityPermissions() method.
 *
 ***************************************************************************/

#ifndef __CREGISTRY_H
#define __CREGISTRY_H

// Useful definition
#define MAX_REGISTRY_STRING_SIZE		_MAX_PATH+1

#define DPN_KEY_ALL_ACCESS				((KEY_ALL_ACCESS & ~WRITE_DAC) & ~WRITE_OWNER)


#define VSIG_CREGISTRY			'GERV'
#define VSIG_CREGISTRY_FREE		'GER_'

// CRegistry
//
// This class handles reading/writing to the windows registry.  Each instance
// of the CRegistry class is attached to a single registry handle, which is
// an open handle to a point in the registry tree.
//
class CRegistry
{

public:

	CRegistry();
	CRegistry( const CRegistry &registry );
	CRegistry( const HKEY branch, LPWSTR pathName, BOOL fReadOnly = TRUE, BOOL create = FALSE );

	~CRegistry();

    BOOL        EnumKeys( LPWSTR lpwStrName, LPDWORD lpdwStringLen, DWORD index = 0 );
    BOOL        EnumValues( LPWSTR lpwStrName, LPDWORD lpdwStringLen, DWORD index = 0 );

	BOOL		Open( const HKEY branch, const LPCWSTR pathName, BOOL fReadOnly = TRUE, BOOL create = FALSE, BOOL fCustomSAM = FALSE, REGSAM samCustom = NULL);
	BOOL		Open( const HKEY branch, const GUID* lpguid, BOOL fReadOnly = TRUE, BOOL create = FALSE, BOOL fCustomSAM = FALSE, REGSAM samCustom = NULL);
	BOOL		Close();

	BOOL		IsOpen()	{ return m_isOpen;	};

	BOOL		DeleteSubKey( LPCWSTR keyName );
	BOOL        DeleteSubKey( const GUID *pGuidName );

	BOOL		DeleteValue( LPCWSTR valueName );

    BOOL        ReadGUID( LPCWSTR keyName, GUID &guid );
    BOOL        WriteGUID( LPCWSTR keyName, const GUID &guid );

	BOOL		WriteString( LPCWSTR keyName, const LPCWSTR lpwstrValue );
	BOOL		ReadString( LPCWSTR keyName, LPWSTR lpwstrValue, LPDWORD lpdwLength );

	BOOL		WriteDWORD( LPCWSTR keyName, DWORD value );
	BOOL		ReadDWORD( LPCWSTR keyName, DWORD &result );

	BOOL		WriteBOOL( LPCWSTR keyName, BOOL value );
	BOOL		ReadBOOL( LPCWSTR keyName, BOOL &result );

	BOOL		ReadBlob( LPCWSTR keyName, LPBYTE lpbBuffer, LPDWORD lpdwSize );
	BOOL		WriteBlob( LPCWSTR keyName, LPBYTE lpbBuffer, DWORD dwSize );

	BOOL		GetMaxKeyLen( DWORD &dwMaxKeyLen );
	BOOL		GetValueLength( const LPCWSTR keyName, DWORD *const pdwValueLength );

	BOOL		GrantAllAccessSecurityPermissions();
	BOOL		RemoveAllAccessSecurityPermissions();

	static BOOL	Register( LPCWSTR lpszProgID, LPCWSTR lpszDesc, LPCWSTR lpszProgName, GUID guidCLSID, LPCWSTR lpszVerIndProgID );
	static BOOL UnRegister( GUID guidCLSID );

	// Data access functions
	operator	HKEY() const		{ return m_regHandle; };
	HKEY		GetBaseHandle() const { return m_baseHandle; };
	HKEY		GetHandle() const { return m_regHandle; };

protected:

	DWORD	m_dwSignature;	// Signature
	BOOL    m_fReadOnly;

	BOOL	m_isOpen;		// BOOL indicating if the object is open
	HKEY	m_regHandle;	// Handle to the registry which is represented by this object
	HKEY	m_baseHandle;	// Handle to the root of the part of the registry
							// this object is in.  E.g. HKEY_LOCAL_MACHINE
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\dndbg.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 - 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dndbg.h
 *  Content:	debug support functions for DirectNet
 *				
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  05-20-99	aarono	Created
 *	07-16-99	johnkan	Added DEBUG_ONLY, DBG_CASSERT, fixed DPFERR to take an argument
 *  02-17-00	rodtoll	Added Memory / String validation routines
 *  05-23-00	RichGr  IA64: Changed some DWORDs to DWORD_PTRs to make va_arg work OK.
 *  07-27-00	masonb	Rewrite to make sub-component stuff work, improve perf
 *  08/28/2000	masonb	Voice Merge: Part of header guard was missing (#define _DNDBG_H_)
 *
 ***************************************************************************/

#ifndef _DNDBG_H_
#define _DNDBG_H_

// Make sure all variations of DEBUG are defined if any one is
#if defined(DEBUG) || defined(DBG) || defined(_DEBUG)
#if !defined(DBG)
#define DBG
#endif // ! DBG
#if !defined(DEBUG)
#define DEBUG
#endif // ! DEBUG
#if !defined(_DEBUG)
#define _DEBUG
#endif // ! _DEBUG
#endif // DEBUG or DBG or _DEBUG

#ifdef __cplusplus
	extern "C" {
#endif	


// ALWAYS_BREAK
#if defined( _WIN32 ) && !defined(WINNT) && defined(_X86_)
	#define ALWAYS_BREAK()       _try { _asm { int 3 } } _except (EXCEPTION_EXECUTE_HANDLER) {;}
#else
	#define ALWAYS_BREAK()       DebugBreak()
#endif


// DEBUG_BREAK()
#if defined(DEBUG)
	#define DEBUG_BREAK()      ALWAYS_BREAK()
#endif
//
// macros used generate compile time messages
//
// you need to use these with #pragma, example
//
//      #pragma TODO(ToddLa, "Fix this later!")
//

#ifndef DNETLOCALBUILD
#define TODO_OFF
#define BUGBUG_OFF	
#endif

// to turn this off, set cl = /DTODO_OFF in your environment variables
#define __TODO(e,m,n)   message(__FILE__ "(" #n ") : TODO: " #e ": " m)
#define _TODO(e,m,n)    __TODO(e,m,n)
#define __BUGBUG(e,m,n)   message(__FILE__ "(" #n ") : BUGBUG: " #e ": " m)
#define _BUGBUG(e,m,n)    __BUGBUG(e,m,n)

#ifdef TODO_OFF
#define TODO(e,m)
#else
#define TODO(e,m)		_TODO(e,m,__LINE__)
#endif

#ifdef BUGBUG_OFF
#define BUGBUG(e,m)
#else
#define BUGBUG(e,m)		_BUGBUG(e,m,__LINE__)
#endif

//========================
// Debug Logging support
//========================

/*=============================================================================
 Usage:

 In code, you can use DPF to print to the log or the debug windows of the
 running application.  The format of DPF (debug printf) is as follows:

	DPFX(DPFPREP,level, string *fmt, arg1, arg2, ...);

 level specifies how important this debug printf is.  The standard convention
 for debug levels is as follows.  This is no way strictly enforced for
 personal use, but by the time the code is checked in, it should be as close
 to this as possible...

  DPF_ERRORLEVEL:		Error useful for application developers.
  DPF_WARNINGLEVEL:		Warning useful for application developers.
  DPF_ENTRYLEVEL:		API Entered
  DPF_APIPARAM:			API parameters, API return values
  DPF_LOCKS:			Driver conversation
  DPF_INFOLEVEL:		Deeper program flow notifications
  DPF_STRUCTUREDUMP:	Dump structures
  DPF_TRACELEVEL:		Trace messages

 When printing a critical error, you can use:
	
	  DPERR( "String" );

 which will print a string at debug level zero.

 In order to cause the code to stop and break in.  You can use ASSERT() or
 DEBUG_BREAK().  In order for ASSERT to break in, you must have
 BreakOnAssert set in the win.ini file section (see osindep.cpp).

=============================================================================*/

#define DPF_ERRORLEVEL		0
#define DPF_WARNINGLEVEL	1
#define DPF_ENTRYLEVEL		2
#define DPF_APIPARAM		3
#define DPF_LOCKS			4
#define DPF_INFOLEVEL		5
#define DPF_STRUCTUREDUMP	6
#define DPF_TRACELEVEL		9

// For Voice
#define DVF_ERRORLEVEL		0
#define DVF_WARNINGLEVEL	1
#define DVF_ENTRYLEVEL		2
#define DVF_APIPARAM		3
#define DVF_LOCKS			4
#define DVF_INFOLEVEL		5
#define DVF_STRUCTUREDUMP	6
#define DVF_TRACELEVEL		9


#define DN_SUBCOMP_GLOBAL	0
#define DN_SUBCOMP_CORE		1
#define DN_SUBCOMP_ADDR		2
#define DN_SUBCOMP_LOBBY	3
#define DN_SUBCOMP_PROTOCOL	4
#define DN_SUBCOMP_VOICE	5
#define DN_SUBCOMP_DPNSVR	6
#define DN_SUBCOMP_WSOCK	7
#define DN_SUBCOMP_MODEM	8
#define DN_SUBCOMP_COMMON	9
#define DN_SUBCOMP_NATHELP	10
#define DN_SUBCOMP_TOOLS	11

#ifdef DEBUG

extern void DebugPrintfX(LPCSTR szFile, DWORD dwLineNumber,LPCSTR szFnName, DWORD dwSubComp, DWORD dwDetail, ...);
extern void _DNAssert(LPCSTR szFile, DWORD dwLineNumber, LPCSTR szFnName, DWORD dwSubComp, LPCSTR szCondition, DWORD dwLevel);

#define DPFX		DebugPrintfX

#ifndef DX_FINAL_RELEASE
#define DPFPREP			__FILE__,__LINE__,DPF_MODNAME, DPF_SUBCOMP
#else /* THE FINAL RELEASE - ELIMINATE FILE AND LINE INFO */
#define DPFPREP			"",0,DPF_MODNAME, DPF_SUBCOMP
#endif 

#define DPFERR( a ) 				DebugPrintfX(DPFPREP, DPF_ERRORLEVEL, a )
#define DNASSERT(condition) 		if (!(condition)) _DNAssert(DPFPREP, #condition, 1)
#define DNASSERTX(condition, level) if (!(condition)) _DNAssert(DPFPREP, #condition, level)

#define DBG_CASSERT( exp )	switch (0) case 0: case exp:
#define	DEBUG_ONLY( arg )	arg
#define DPF_RETURN(a) 		DPFX(DPFPREP,DPF_APIPARAM,"Returning: 0x%lx",a);    return a;
#define DPF_ENTER() 		DPFX(DPFPREP,DPF_TRACELEVEL, "Enter");
#define DPF_EXIT() 		DPFX(DPFPREP,DPF_TRACELEVEL, "Exit");


#else /* NOT DEBUG */

	#pragma warning(disable:4002)
	#define DPFX()
    	#define DPF_RETURN(a)                 return a;	
	#define DPFERR()
	#define DNASSERT()
	#define DNASSERTX()
	#define	DEBUG_ONLY()
	#define	DBG_CASSERT()
	#define DPF_ENTER()
	#define DPF_EXIT()

#endif /* DEBUG */

extern BOOL IsValidStringW( const WCHAR * const szString );
extern BOOL IsValidStringA( const CHAR * const swzString );

#define DNVALID_STRING_A(a)		IsValidStringA(a)
#define DNVALID_STRING_W(a)		IsValidStringW(a)
#define DNVALID_WRITEPTR(a,b)	(!IsBadWritePtr(a,b))
#define DNVALID_READPTR(a,b)	(!IsBadReadPtr(a,b))

#ifdef __cplusplus
	}	//extern "C"
#endif

#endif /* _DNDBG_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\createin.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       createin.h
 *  Content:	defines functions required by the generic class factory
 *
 *
 *	The generic class factory (classfac.c) requires these functions to be
 *	implemented by the COM object(s) its supposed to be generating
 *
 *	GP_ stands for "General Purpose"
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	10/13/98	jwo		Created it.
 ***************************************************************************/

#ifndef __CREATEINS__
#define __CREATEINS__


#ifdef __cplusplus
extern "C" {
#endif

// you must implement this function to create an instance of your COM object
HRESULT	DoCreateInstance(LPCLASSFACTORY This, LPUNKNOWN pUnkOuter, REFCLSID rclsid, REFIID riid,
    						LPVOID *ppvObj);

// you must implement this function.  Given a class id, you must respond
//	whether or not your DLL implements it
BOOL	IsClassImplemented(REFCLSID rclsid);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\dneterrors.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DNetErrors.cpp
 *  Content:    Function for expanding Play8 errors to debug output
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/04/98  johnkan	Created
 *	07/22/99	a-evsch	removed DPF_MODNAME.  This is defined in DbgInfo.h
 *	01/24/00	mjn		Added DPNERR_NOHOSTPLAYER error
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include	"dncmni.h"
#include	<Limits.h>

#if defined(_DEBUG) || defined(DEBUG) || defined(DBG)

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************
static	char	*GetDNErrorString( const HRESULT DNError );
static	char	*GetInternetErrorString( const HRESULT InternetError );
static	char	*GetTAPIErrorString( const HRESULT TAPIError );
static	char	*GetWIN32ErrorString( const LONG Error );
static	char	*GetWinsockErrorString( const DWORD WinsockError );

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// LclDisplayString - display user string
//
// Entry:		Pointer to string
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "LclDisplayString"

void	LclDisplayString( DN_OUT_TYPE OutputType, DWORD ErrorLevel, char *pString )
{
	// was there no error?
	if ( pString != NULL )
	{
		// how do we output?
		switch ( OutputType )
		{
			// output to debugger via DPF
			case DPNERR_OUT_DEBUGGER:
			{
				DPFX(DPFPREP,  ErrorLevel, pString );
				break;
			}

			// unknown debug state
			default:
			{
				DNASSERT( FALSE );
				break;
			}
		}
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// LclDisplayError - display error code
//
// Entry:		Error type
//				Output type
//				Error level
//				Error code
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "LclDisplayError"

void	LclDisplayError( EC_TYPE ErrorType, DN_OUT_TYPE OutputType, DWORD ErrorLevel, HRESULT ErrorCode )
{
	char	*pString;


	switch ( ErrorType )
	{
		// DirectNet error
		case EC_DPLAY8:
		{
			pString = GetDNErrorString( ErrorCode );
			break;
		}

		// internet error
		case EC_INET:
		{
			pString = GetInternetErrorString( ErrorCode );
			break;
		}

		// Win32
		case EC_WIN32:
		{
			pString = GetWIN32ErrorString( ErrorCode );
			break;
		}

		// TAPI
		case EC_TAPI:
		{
			pString = GetTAPIErrorString( ErrorCode );
			break;
		}

		// winsock
		case EC_WINSOCK:
		{
			pString = GetWinsockErrorString( ErrorCode );
			break;
		}

		// unknown type
		default:
		{
			DNASSERT( FALSE );
			pString = "Unknown error type!";
			break;
		}
	}

	LclDisplayString( OutputType, ErrorLevel, pString );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// GetDNErrorString - convert DirectNet error to a string
//
// Entry:		Error code
//
// Exit:		Pointer to string
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "GetDNErrorString"

static	char	*GetDNErrorString( HRESULT ErrorCode )
{
	char *pString = NULL;


	// what was the error
	switch ( ErrorCode )
	{

		case DPN_OK:
		{
//			no output if no error
//			pString = "DN_OK";
			break;
		}

		case DPNERR_ABORTED:
		{
			pString = "DPNERR_ABORTED";
			break;
		}

		case DPNERR_ADDRESSING:
		{
			pString = "DPNERR_ADDRESSING";
			break;
		}

		case DPNERR_ALREADYCLOSING:
		{
			pString = "DPNERR_ALREADYCLOSING";
			break;
		}

		case DPNERR_ALREADYCONNECTED:
		{
			pString = "DPNERR_ALREADYCONNECTED";
			break;
		}

		case DPNERR_ALREADYDISCONNECTING:
		{
			pString = "DPNERR_ALREADYDISCONNECTING";
			break;
		}

		case DPNERR_ALREADYINITIALIZED:
		{
			pString = "DPNERR_ALREADYINITIALIZED";
			break;
		}

		case DPNERR_ALREADYREGISTERED:
		{
			pString = "DPNERR_ALREADYREGISTERED";
			break;
		}

		case DPNERR_BUFFERTOOSMALL:
		{
			pString = "DPNERR_BUFFERTOOSMALL";
			break;
		}

		case DPNERR_CANNOTCANCEL:
		{
			pString = "DPNERR_CANNOTCANCEL";
			break;
		}

		case DPNERR_CANTCREATEGROUP:
		{
			pString = "DPNERR_CANTCREATEGROUP";
			break;
		}

		case DPNERR_CANTCREATEPLAYER:
		{
			pString = "DPNERR_CANTCREATEPLAYER";
			break;
		}

		case DPNERR_CANTLAUNCHAPPLICATION:
		{
			pString = "DPNERR_CANTLAUNCHAPPLICATION";
			break;
		}

		case DPNERR_CONNECTING:
		{
			pString = "DPNERR_CONNECTING";
			break;
		}

		case DPNERR_CONNECTIONLOST:
		{
			pString = "DPNERR_CONNECTIONLOST";
			break;
		}

		case DPNERR_CONVERSION:
		{
			pString = "DPNERR_CONVERSION";
			break;
		}

		case DPNERR_DATATOOLARGE:
		{
			pString = "DPNERR_DATATOOLARGE";
			break;
		}

		case DPNERR_DOESNOTEXIST:
		{
			pString = "DPNERR_DOESNOTEXIST";
			break;
		}

		case DPNERR_DUPLICATECOMMAND:
		{
			pString = "DPNERR_DUPLICATECOMMAND";
			break;
		}

		case DPNERR_ENDPOINTNOTRECEIVING:
		{
			pString = "DPNERR_ENDPOINTNOTRECEIVING";
			break;
		}

		case DPNERR_ENUMQUERYTOOLARGE:
		{
			pString = "DPNERR_ENUMQUERYTOOLARGE";
			break;
		}

		case DPNERR_ENUMRESPONSETOOLARGE:
		{
			pString = "DPNERR_ENUMRESPONSETOOLARGE";
			break;
		}

		case DPNERR_EXCEPTION:
		{
			pString = "DPNERR_EXCEPTION";
			break;
		}

		case DPNERR_GENERIC:
		{
			pString = "DPNERR_GENERIC";
			break;
		}

		case DPNERR_GROUPNOTEMPTY:
		{
			pString = "DPNERR_GROUPNOTEMPTY";
			break;
		}

		case DPNERR_HOSTING:
		{
			pString = "DPNERR_HOSTING";
			break;
		}

		case DPNERR_HOSTREJECTEDCONNECTION:
		{
			pString = "DPNERR_HOSTREJECTEDCONNECTION";
			break;
		}

		case DPNERR_HOSTTERMINATEDSESSION:
		{
			pString = "DPNERR_HOSTTERMINATEDSESSION";
			break;
		}

		case DPNERR_INCOMPLETEADDRESS:
		{
			pString = "DPNERR_INCOMPLETEADDRESS";
			break;
		}

		case DPNERR_INVALIDADDRESSFORMAT:
		{
			pString = "DPNERR_INVALIDADDRESSFORMAT";
			break;
		}

		case DPNERR_INVALIDAPPLICATION:
		{
			pString = "DPNERR_INVALIDAPPLICATION";
			break;
		}

		case DPNERR_INVALIDCOMMAND:
		{
			pString = "DPNERR_INVALIDCOMMAND";
			break;
		}

		case DPNERR_INVALIDENDPOINT:
		{
			pString = "DPNERR_INVALIDENDPOINT";
			break;
		}

		case DPNERR_INVALIDFLAGS:
		{
			pString = "DPNERR_INVALIDFLAGS";
			break;
		}

		case DPNERR_INVALIDGROUP:
		{
			pString = "DPNERR_INVALIDGROUP";
			break;
		}

		case DPNERR_INVALIDHANDLE:
		{
			pString = "DPNERR_INVALIDHANDLE";
			break;
		}

		case DPNERR_INVALIDINSTANCE:
		{
			pString = "DPNERR_INVALIDINSTANCE";
			break;
		}

		case DPNERR_INVALIDINTERFACE:
		{
			pString = "DPNERR_INVALIDINTERFACE";
			break;
		}

		case DPNERR_INVALIDDEVICEADDRESS:
		{
			pString = "DPNERR_INVALIDDEVICEADDRESS";
			break;
		}

		case DPNERR_INVALIDOBJECT:
		{
			pString = "DPNERR_INVALIDOBJECT";
			break;
		}

		case DPNERR_INVALIDPARAM:
		{
			pString = "DPNERR_INVALIDPARAM";
			break;
		}

		case DPNERR_INVALIDPASSWORD:
		{
			pString = "DPNERR_INVALIDPASSWORD";
			break;
		}

		case DPNERR_INVALIDPLAYER:
		{
			pString = "DPNERR_INVALIDPLAYER";
			break;
		}

		case DPNERR_INVALIDPOINTER:
		{
			pString = "DPNERR_INVALIDPOINTER";
			break;
		}

		case DPNERR_INVALIDPRIORITY:
		{
			pString = "DPNERR_INVALIDPRIORITY";
			break;
		}

		case DPNERR_INVALIDHOSTADDRESS:
		{
			pString = "DPNERR_INVALIDHOSTADDRESS";
			break;
		}

		case DPNERR_INVALIDSTRING:
		{
			pString = "DPNERR_INVALIDSTRING";
			break;
		}

		case DPNERR_INVALIDURL:
		{
			pString = "DPNERR_INVALIDURL";
			break;
		}

		case DPNERR_INVALIDVERSION:
		{
			pString = "DPNERR_INVALIDVERSION";
			break;
		}

		case DPNERR_NOCAPS:
		{
			pString = "DPNERR_NOCAPS";
			break;
		}

		case DPNERR_NOCONNECTION:
		{
			pString = "DPNERR_NOCONNECTION";
			break;
		}

		case DPNERR_NOHOSTPLAYER:
		{
			pString = "DPNERR_NOHOSTPLAYER";
			break;
		}

		case DPNERR_NOINTERFACE:
		{
			pString = "DPNERR_NOINTERFACE";
			break;
		}

		case DPNERR_NOMOREADDRESSCOMPONENTS:
		{
			pString = "DPNERR_NOMOREADDRESSCOMPONENTS";
			break;
		}

		case DPNERR_NORESPONSE:
		{
			pString = "DPNERR_NORESPONSE";
			break;
		}

		case DPNERR_NOTALLOWED:
		{
			pString = "DPNERR_NOTALLOWED";
			break;
		}

		case DPNERR_NOTHOST:
		{
			pString = "DPNERR_NOTHOST";
			break;
		}

		case DPNERR_NOTREADY:
		{
			pString = "DPNERR_NOTREADY";
			break;
		}

		case DPNERR_NOTREGISTERED:
		{
			pString = "DPNERR_NOTREGISTERED";
			break;
		}

		case DPNERR_OUTOFMEMORY:
		{
			pString = "DPNERR_OUTOFMEMORY";
			break;
		}

		case DPNERR_PENDING:
		{
			pString = "DPNERR_PENDING";
			break;
		}

		case DPNERR_PLAYERLOST:
		{
			pString = "DPNERR_PLAYERLOST";
			break;
		}
		case DPNERR_PLAYERNOTINGROUP:
		{
			pString = "DPNERR_PLAYERNOTINGROUP";
			break;
		}
		case DPNERR_PLAYERNOTREACHABLE:
		{
			pString = "DPNERR_PLAYERNOTREACHABLE";
			break;
		}

		case DPNERR_SENDTOOLARGE:
		{
			pString = "DPNERR_SENDTOOLARGE";
			break;
		}

		case DPNERR_SESSIONFULL:
		{
			pString = "DPNERR_SESSIONFULL";
			break;
		}

		case DPNERR_TABLEFULL:
		{
			pString = "DPNERR_TABLEFULL";
			break;
		}

		case DPNERR_TIMEDOUT:
		{
			pString = "DPNERR_TIMEDOUT";
			break;
		}

		case DPNERR_UNINITIALIZED:
		{
			pString = "DPNERR_UNINITIALIZED";
			break;
		}

		case DPNERR_UNSUPPORTED:
		{
			pString = "DPNERR_UNSUPPORTED";
			break;
		}

		case DPNERR_USERCANCEL:
		{
			pString = "DPNERR_USERCANCEL";
			break;
		}

		// unknown error code, possibly a new one?
		default:
		{
			DPFX(DPFPREP, 0, "Unknown DPlay error code %u/0x%lx", ErrorCode, ErrorCode );

			pString = "Unknown DPlay8 error code";
			break;
		}
	}

	return	pString;
}
//**********************************************************************



//**********************************************************************
// ------------------------------
// GetInternetErrorString - convert Internet error to a string
//
// Entry:		Error code
//
// Exit:		Pointer to string
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "GetInternetErrorString"

static	char	*GetInternetErrorString( HRESULT ErrorCode )
{
	char *pString = NULL;


	switch ( ErrorCode )
	{
		case ERROR_INTERNET_OUT_OF_HANDLES:
		{
			pString = "ERROR_INTERNET_OUT_OF_HANDLES";
			break;
		}

		case ERROR_INTERNET_TIMEOUT:
		{
			pString = "ERROR_INTERNET_TIMEOUT";
			break;
		}

		case ERROR_INTERNET_EXTENDED_ERROR:
		{
			pString = "ERROR_INTERNET_EXTENDED_ERROR";
			break;
		}

		case ERROR_INTERNET_INTERNAL_ERROR:
		{
			pString = "ERROR_INTERNET_INTERNAL_ERROR";
			break;
		}

		case ERROR_INTERNET_INVALID_URL:
		{
			pString = "ERROR_INTERNET_INVALID_URL";
			break;
		}

		case ERROR_INTERNET_UNRECOGNIZED_SCHEME:
		{
			pString = "ERROR_INTERNET_UNRECOGNIZED_SCHEME";
			break;
		}

		case ERROR_INTERNET_NAME_NOT_RESOLVED:
		{
			pString = "ERROR_INTERNET_NAME_NOT_RESOLVED";
			break;
		}

		case ERROR_INTERNET_PROTOCOL_NOT_FOUND:
		{
			pString = "ERROR_INTERNET_PROTOCOL_NOT_FOUND";
			break;
		}

		case ERROR_INTERNET_INVALID_OPTION:
		{
			pString = "ERROR_INTERNET_INVALID_OPTION";
			break;
		}

		case ERROR_INTERNET_BAD_OPTION_LENGTH:
		{
			pString = "ERROR_INTERNET_BAD_OPTION_LENGTH";
			break;
		}

		case ERROR_INTERNET_OPTION_NOT_SETTABLE:
		{
			pString = "ERROR_INTERNET_OPTION_NOT_SETTABLE";
			break;
		}

		case ERROR_INTERNET_SHUTDOWN:
		{
			pString = "ERROR_INTERNET_SHUTDOWN";
			break;
		}

		case ERROR_INTERNET_INCORRECT_USER_NAME:
		{
			pString = "ERROR_INTERNET_INCORRECT_USER_NAME";
			break;
		}

		case ERROR_INTERNET_INCORRECT_PASSWORD:
		{
			pString = "ERROR_INTERNET_INCORRECT_PASSWORD";
			break;
		}

		case ERROR_INTERNET_LOGIN_FAILURE:
		{
			pString = "ERROR_INTERNET_LOGIN_FAILURE";
			break;
		}

		case ERROR_INTERNET_INVALID_OPERATION:
		{
			pString = "ERROR_INTERNET_INVALID_OPERATION";
			break;
		}

		case ERROR_INTERNET_OPERATION_CANCELLED:
		{
			pString = "ERROR_INTERNET_OPERATION_CANCELLED";
			break;
		}

		case ERROR_INTERNET_INCORRECT_HANDLE_TYPE:
		{
			pString = "ERROR_INTERNET_INCORRECT_HANDLE_TYPE";
			break;
		}

		case ERROR_INTERNET_INCORRECT_HANDLE_STATE:
		{
			pString = "ERROR_INTERNET_INCORRECT_HANDLE_STATE";
			break;
		}

		case ERROR_INTERNET_NOT_PROXY_REQUEST:
		{
			pString = "ERROR_INTERNET_NOT_PROXY_REQUEST";
			break;
		}

		case ERROR_INTERNET_REGISTRY_VALUE_NOT_FOUND:
		{
			pString = "ERROR_INTERNET_REGISTRY_VALUE_NOT_FOUND";
			break;
		}

		case ERROR_INTERNET_BAD_REGISTRY_PARAMETER:
		{
			pString = "ERROR_INTERNET_BAD_REGISTRY_PARAMETER";
			break;
		}

		case ERROR_INTERNET_NO_DIRECT_ACCESS:
		{
			pString = "ERROR_INTERNET_NO_DIRECT_ACCESS";
			break;
		}

		case ERROR_INTERNET_NO_CONTEXT:
		{
			pString = "ERROR_INTERNET_NO_CONTEXT";
			break;
		}

		case ERROR_INTERNET_NO_CALLBACK:
		{
			pString = "ERROR_INTERNET_NO_CALLBACK";
			break;
		}

		case ERROR_INTERNET_REQUEST_PENDING:
		{
			pString = "ERROR_INTERNET_REQUEST_PENDING";
			break;
		}

		case ERROR_INTERNET_INCORRECT_FORMAT:
		{
			pString = "ERROR_INTERNET_INCORRECT_FORMAT";
			break;
		}

		case ERROR_INTERNET_ITEM_NOT_FOUND:
		{
			pString = "ERROR_INTERNET_ITEM_NOT_FOUND";
			break;
		}

		case ERROR_INTERNET_CANNOT_CONNECT:
		{
			pString = "ERROR_INTERNET_CANNOT_CONNECT";
			break;
		}

		case ERROR_INTERNET_CONNECTION_ABORTED:
		{
			pString = "ERROR_INTERNET_CONNECTION_ABORTED";
			break;
		}

		case ERROR_INTERNET_CONNECTION_RESET:
		{
			pString = "ERROR_INTERNET_CONNECTION_RESET";
			break;
		}

		case ERROR_INTERNET_FORCE_RETRY:
		{
			pString = "ERROR_INTERNET_FORCE_RETRY";
			break;
		}

		case ERROR_INTERNET_INVALID_PROXY_REQUEST:
		{
			pString = "ERROR_INTERNET_INVALID_PROXY_REQUEST";
			break;
		}

		case ERROR_INTERNET_NEED_UI:
		{
			pString = "ERROR_INTERNET_NEED_UI";
			break;
		}

		case ERROR_INTERNET_HANDLE_EXISTS:
		{
			pString = "ERROR_INTERNET_HANDLE_EXISTS";
			break;
		}

		case ERROR_INTERNET_SEC_CERT_DATE_INVALID:
		{
			pString = "ERROR_INTERNET_SEC_CERT_DATE_INVALID";
			break;
		}

		case ERROR_INTERNET_SEC_CERT_CN_INVALID:
		{
			pString = "ERROR_INTERNET_SEC_CERT_CN_INVALID";
			break;
		}

		case ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR:
		{
			pString = "ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR";
			break;
		}

		case ERROR_INTERNET_HTTPS_TO_HTTP_ON_REDIR:
		{
			pString = "ERROR_INTERNET_HTTPS_TO_HTTP_ON_REDIR";
			break;
		}

		case ERROR_INTERNET_MIXED_SECURITY:
		{
			pString = "ERROR_INTERNET_MIXED_SECURITY";
			break;
		}

		case ERROR_INTERNET_CHG_POST_IS_NON_SECURE:
		{
			pString = "ERROR_INTERNET_CHG_POST_IS_NON_SECURE";
			break;
		}

		case ERROR_INTERNET_POST_IS_NON_SECURE:
		{
			pString = "ERROR_INTERNET_POST_IS_NON_SECURE";
			break;
		}

		case ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED:
		{
			pString = "ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED";
			break;
		}

		case ERROR_INTERNET_INVALID_CA:
		{
			pString = "ERROR_INTERNET_INVALID_CA";
			break;
		}

		case ERROR_INTERNET_CLIENT_AUTH_NOT_SETUP:
		{
			pString = "ERROR_INTERNET_CLIENT_AUTH_NOT_SETUP";
			break;
		}

		case ERROR_INTERNET_ASYNC_THREAD_FAILED:
		{
			pString = "ERROR_INTERNET_ASYNC_THREAD_FAILED";
			break;
		}

		case ERROR_INTERNET_REDIRECT_SCHEME_CHANGE:
		{
			pString = "ERROR_INTERNET_REDIRECT_SCHEME_CHANGE";
			break;
		}

		case ERROR_FTP_TRANSFER_IN_PROGRESS:
		{
			pString = "ERROR_FTP_TRANSFER_IN_PROGRESS";
			break;
		}

		case ERROR_FTP_DROPPED:
		{
			pString = "ERROR_FTP_DROPPED";
			break;
		}

		case ERROR_GOPHER_PROTOCOL_ERROR:
		{
			pString = "ERROR_GOPHER_PROTOCOL_ERROR";
			break;
		}

		case ERROR_GOPHER_NOT_FILE:
		{
			pString = "ERROR_GOPHER_NOT_FILE";
			break;
		}

		case ERROR_GOPHER_DATA_ERROR:
		{
			pString = "ERROR_GOPHER_DATA_ERROR";
			break;
		}

		case ERROR_GOPHER_END_OF_DATA:
		{
			pString = "ERROR_GOPHER_END_OF_DATA";
			break;
		}

		case ERROR_GOPHER_INVALID_LOCATOR:
		{
			pString = "ERROR_GOPHER_INVALID_LOCATOR";
			break;
		}

		case ERROR_GOPHER_INCORRECT_LOCATOR_TYPE:
		{
			pString = "ERROR_GOPHER_INCORRECT_LOCATOR_TYPE";
			break;
		}

		case ERROR_GOPHER_NOT_GOPHER_PLUS:
		{
			pString = "ERROR_GOPHER_NOT_GOPHER_PLUS";
			break;
		}

		case ERROR_GOPHER_ATTRIBUTE_NOT_FOUND:
		{
			pString = "ERROR_GOPHER_ATTRIBUTE_NOT_FOUND";
			break;
		}

		case ERROR_GOPHER_UNKNOWN_LOCATOR:
		{
			pString = "ERROR_GOPHER_UNKNOWN_LOCATOR";
			break;
		}

		case ERROR_HTTP_HEADER_NOT_FOUND:
		{
			pString = "ERROR_HTTP_HEADER_NOT_FOUND";
			break;
		}

		case ERROR_HTTP_DOWNLEVEL_SERVER:
		{
			pString = "ERROR_HTTP_DOWNLEVEL_SERVER";
			break;
		}

		case ERROR_HTTP_INVALID_SERVER_RESPONSE:
		{
			pString = "ERROR_HTTP_INVALID_SERVER_RESPONSE";
			break;
		}

		case ERROR_HTTP_INVALID_HEADER:
		{
			pString = "ERROR_HTTP_INVALID_HEADER";
			break;
		}

		case ERROR_HTTP_INVALID_QUERY_REQUEST:
		{
			pString = "ERROR_HTTP_INVALID_QUERY_REQUEST";
			break;
		}

		case ERROR_HTTP_HEADER_ALREADY_EXISTS:
		{
			pString = "ERROR_HTTP_HEADER_ALREADY_EXISTS";
			break;
		}

		case ERROR_HTTP_REDIRECT_FAILED:
		{
			pString = "ERROR_HTTP_REDIRECT_FAILED";
			break;
		}

		case ERROR_HTTP_NOT_REDIRECTED:
		{
			pString = "ERROR_HTTP_NOT_REDIRECTED";
			break;
		}

		case ERROR_INTERNET_SECURITY_CHANNEL_ERROR:
		{
			pString = "ERROR_INTERNET_SECURITY_CHANNEL_ERROR";
			break;
		}

		case ERROR_INTERNET_UNABLE_TO_CACHE_FILE:
		{
			pString = "ERROR_INTERNET_UNABLE_TO_CACHE_FILE";
			break;
		}

		case ERROR_INTERNET_TCPIP_NOT_INSTALLED:
		{
			pString = "ERROR_INTERNET_TCPIP_NOT_INSTALLED";
			break;
		}

		// unknown
		default:
		{
			DPFX(DPFPREP, 0, "Unknown Internet error code %u/0x%lx", ErrorCode, ErrorCode );

			DNASSERT( FALSE );

			pString = "Unknown Internet error code";
			break;
		}
	}

	return	pString;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// GetTAPIErrorString - convert TAPI error code to a string
//
// Entry:		Error code
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "GetTAPIErrorString"

static	char	*GetTAPIErrorString( const HRESULT TAPIError )
{
	char	*pString;


	switch ( TAPIError )
	{
		// The specified address is blocked from being dialed on the specified call.
		case LINEERR_ADDRESSBLOCKED:
		{
			pString = "LINEERR_ADDRESSBLOCKED";
			break;
		}

		// The line cannot be opened due to a persistent condition, such as that of a serial port being exclusively opened by another process.
		case LINEERR_ALLOCATED:
		{
			pString = "LINEERR_ALLOCATED";
			break;
		}

		// The specified device identifier or line device identifier (such as in a dwDeviceID parameter) is invalid or out of range.
		case LINEERR_BADDEVICEID:
		{
			pString = "LINEERR_BADDEVICEID";
			break;
		}

		// The call's bearer mode cannot be changed to the specified bearer mode.
		case LINEERR_BEARERMODEUNAVAIL:
		{
			pString = "LINEERR_BEARERMODEUNAVAIL";
			break;
		}

		// All call appearances on the specified address are currently in use.
		case LINEERR_CALLUNAVAIL:
		{
			pString = "LINEERR_CALLUNAVAIL";
			break;
		}

		// The maximum number of outstanding call completions has been exceeded.
		case LINEERR_COMPLETIONOVERRUN:
		{
			pString = "LINEERR_COMPLETIONOVERRUN";
			break;
		}

		// The maximum number of parties for a conference has been reached, or the requested number of parties cannot be satisfied.
		case LINEERR_CONFERENCEFULL:
		{
			pString = "LINEERR_CONFERENCEFULL";
			break;
		}

		// The dialable address parameter contains dialing control characters that are not processed by the service provider.
		case LINEERR_DIALBILLING:
		{
			pString = "LINEERR_DIALBILLING";
			break;
		}

		// The dialable address parameter contains dialing control characters that are not processed by the service provider.
		case LINEERR_DIALQUIET:
		{
			pString = "LINEERR_DIALQUIET";
			break;
		}

		// The dialable address parameter contains dialing control characters that are not processed by the service provider.
		case LINEERR_DIALDIALTONE:
		{
			pString = "LINEERR_DIALDIALTONE";
			break;
		}

		// The dialable address parameter contains dialing control characters that are not processed by the service provider.
		case LINEERR_DIALPROMPT:
		{
			pString = "LINEERR_DIALPROMPT";
			break;
		}

		// The application requested an API version or version range that is either incompatible or cannot be supported by the Telephony API implementation and/or corresponding service provider.
		case LINEERR_INCOMPATIBLEAPIVERSION:
		{
			pString = "LINEERR_INCOMPATIBLEAPIVERSION";
			break;
		}

		// The application requested an extension version range that is either invalid or cannot be supported by the corresponding service provider.
		case LINEERR_INCOMPATIBLEEXTVERSION:
		{
			pString = "LINEERR_INCOMPATIBLEEXTVERSION";
			break;
		}

		// The telephon.ini file cannot be read or understood properly by TAPI because of internal inconsistencies or formatting problems. For example, the [Locations], [Cards], or [Countries] section of the telephon.ini file may be corrupted or inconsistent.
		case LINEERR_INIFILECORRUPT:
		{
			pString = "LINEERR_INIFILECORRUPT";
			break;
		}

		// The line device is in use and cannot currently be configured, allow a party to be added, allow a call to be answered, allow a call to be placed, or allow a call to be transferred.
		case LINEERR_INUSE:
		{
			pString = "LINEERR_INUSE";
			break;
		}

		// A specified address is either invalid or not allowed. If invalid, the address contains invalid characters or digits, or the destination address contains dialing control characters (W, @, $, or ?) that are not supported by the service provider. If not allowed, the specified address is either not assigned to the specified line or is not valid for address redirection.
		case LINEERR_INVALADDRESS:
		{
			pString = "LINEERR_INVALADDRESS";
			break;
		}

		// The specified address identifier is either invalid or out of range.
		case LINEERR_INVALADDRESSID:
		{
			pString = "LINEERR_INVALADDRESSID";
			break;
		}

		// The specified address mode is invalid.
		case LINEERR_INVALADDRESSMODE:
		{
			pString = "LINEERR_INVALADDRESSMODE";
			break;
		}

		// dwAddressStates contains one or more bits that are not LINEADDRESSSTATE_ constants.
		case LINEERR_INVALADDRESSSTATE:
		{
			pString = "LINEERR_INVALADDRESSSTATE";
			break;
		}

		// The specified agent activity is not valid.
		case LINEERR_INVALAGENTACTIVITY:
		{
			pString = "LINEERR_INVALAGENTACTIVITY";
			break;
		}

		// The specified agent group information is not valid or contains errors. The requested action has not been carried out.
		case LINEERR_INVALAGENTGROUP:
		{
			pString = "LINEERR_INVALAGENTGROUP";
			break;
		}

		// The specified agent identifier is not valid.
		case LINEERR_INVALAGENTID:
		{
			pString = "LINEERR_INVALAGENTID";
			break;
		}

//		// The specified agent skill information is not valid.
//		case LINEERR_INVALAGENTSKILL:
//		{
//			pString = "LINEERR_INVALAGENTSKILL";
//			break;
//		}

		// The specified agent state is not valid or contains errors. No changes have been made to the agent state of the specified address.
		case LINEERR_INVALAGENTSTATE:
		{
			pString = "LINEERR_INVALAGENTSTATE";
			break;
		}

//		// The specified agent supervisor information is not valid.
//		case LINEERR_INVALAGENTSUPERVISOR:
//		{
//			pString = "LINEERR_INVALAGENTSUPERVISOR";
//			break;
//		}

		// The application handle (such as specified by a hLineApp parameter) or the appliction registration handle is invalid.
		case LINEERR_INVALAPPHANDLE:
		{
			pString = "LINEERR_INVALAPPHANDLE";
			break;
		}

		// The specified application name is invalid. If an application name is specified by the application, it is assumed that the string does not contain any non-displayable characters, and is zero-terminated.
		case LINEERR_INVALAPPNAME:
		{
			pString = "LINEERR_INVALAPPNAME";
			break;
		}

		// The specified bearer mode is invalid.
		case LINEERR_INVALBEARERMODE:
		{
			pString = "LINEERR_INVALBEARERMODE";
			break;
		}

		// The specified completion is invalid.
		case LINEERR_INVALCALLCOMPLMODE:
		{
			pString = "LINEERR_INVALCALLCOMPLMODE";
			break;
		}

		// The specified call handle is not valid. For example, the handle is not NULL but does not belong to the given line. In some cases, the specified call device handle is invalid.
		case LINEERR_INVALCALLHANDLE:
		{
			pString = "LINEERR_INVALCALLHANDLE";
			break;
		}

		// The specified call parameters are invalid.
		case LINEERR_INVALCALLPARAMS:
		{
			pString = "LINEERR_INVALCALLPARAMS";
			break;
		}

		// The specified call privilege parameter is invalid.
		case LINEERR_INVALCALLPRIVILEGE:
		{
			pString = "LINEERR_INVALCALLPRIVILEGE";
			break;
		}

		// The specified select parameter is invalid.
		case LINEERR_INVALCALLSELECT:
		{
			pString = "LINEERR_INVALCALLSELECT";
			break;
		}

		// The current state of a call is not in a valid state for the requested operation.
		case LINEERR_INVALCALLSTATE:
		{
			pString = "LINEERR_INVALCALLSTATE";
			break;
		}

		// The specified call state list is invalid.
		case LINEERR_INVALCALLSTATELIST:
		{
			pString = "LINEERR_INVALCALLSTATELIST";
			break;
		}

		// The permanent card identifier specified in dwCard could not be found in any entry in the [Cards] section in the registry.
		case LINEERR_INVALCARD:
		{
			pString = "LINEERR_INVALCARD";
			break;
		}

		// The completion identifier is invalid.
		case LINEERR_INVALCOMPLETIONID:
		{
			pString = "LINEERR_INVALCOMPLETIONID";
			break;
		}

		// The specified call handle for the conference call is invalid or is not a handle for a conference call.
		case LINEERR_INVALCONFCALLHANDLE:
		{
			pString = "LINEERR_INVALCONFCALLHANDLE";
			break;
		}

		// The specified consultation call handle is invalid.
		case LINEERR_INVALCONSULTCALLHANDLE:
		{
			pString = "LINEERR_INVALCONSULTCALLHANDLE";
			break;
		}

		// The specified country code is invalid.
		case LINEERR_INVALCOUNTRYCODE:
		{
			pString = "LINEERR_INVALCOUNTRYCODE";
			break;
		}

		// The line device has no associated device for the given device class, or the specified line does not support the indicated device class.
		case LINEERR_INVALDEVICECLASS:
		{
			pString = "LINEERR_INVALDEVICECLASS";
			break;
		}

		// The specified digit list is invalid.
		case LINEERR_INVALDIGITLIST:
		{
			pString = "LINEERR_INVALDIGITLIST";
			break;
		}

		// The specified digit mode is invalid.
		case LINEERR_INVALDIGITMODE:
		{
			pString = "LINEERR_INVALDIGITMODE";
			break;
		}

		// The specified termination digits are not valid.
		case LINEERR_INVALDIGITS:
		{
			pString = "LINEERR_INVALDIGITS";
			break;
		}

		// The dwFeature parameter is invalid.
		case LINEERR_INVALFEATURE:
		{
			pString = "LINEERR_INVALFEATURE";
			break;
		}

		// The specified group identifier is invalid.
		case LINEERR_INVALGROUPID:
		{
			pString = "LINEERR_INVALGROUPID";
			break;
		}

		// The specified call, device, line device, or line handle is invalid.
		case LINEERR_INVALLINEHANDLE:
		{
			pString = "LINEERR_INVALLINEHANDLE";
			break;
		}

		// The device configuration may not be changed in the current line state. The line may be in use by another application or a dwLineStates parameter contains one or more bits that are not LINEDEVSTATE_ constants. The LINEERR_INVALLINESTATE value can also indicate that the device is DISCONNECTED or OUTOFSERVICE. These states are indicated by setting the bits corresponding to the LINEDEVSTATUSFLAGS_CONNECTED and LINEDEVSTATUSFLAGS_INSERVICE values to 0 in the dwDevStatusFlags member of the LINEDEVSTATUS structure returned by the lineGetLineDevStatus function.
		case LINEERR_INVALLINESTATE:
		{
			pString = "LINEERR_INVALLINESTATE";
			break;
		}

		// The permanent location identifier specified in dwLocation could not be found in any entry in the [Locations] section in the registry.
		case LINEERR_INVALLOCATION:
		{
			pString = "LINEERR_INVALLOCATION";
			break;
		}

		// The specified media list is invalid.
		case LINEERR_INVALMEDIALIST:
		{
			pString = "LINEERR_INVALMEDIALIST";
			break;
		}

		// The list of media types to be monitored contains invalid information, the specified media mode parameter is invalid, or the service provider does not support the specified media mode. The media modes supported on the line are listed in the dwMediaModes member in the LINEDEVCAPS structure.
		case LINEERR_INVALMEDIAMODE:
		{
			pString = "LINEERR_INVALMEDIAMODE";
			break;
		}

		// The number given in dwMessageID is outside the range specified by the dwNumCompletionMessages member in the LINEADDRESSCAPS structure.
		case LINEERR_INVALMESSAGEID:
		{
			pString = "LINEERR_INVALMESSAGEID";
			break;
		}

		// A parameter (such as dwTollListOption, dwTranslateOptions, dwNumDigits, or a structure pointed to by lpDeviceConfig) contains invalid values, a country code is invalid, a window handle is invalid, or the specified forward list parameter contains invalid information.
		case LINEERR_INVALPARAM:
		{
			pString = "LINEERR_INVALPARAM";
			break;
		}

		// The specified park mode is invalid.
		case LINEERR_INVALPARKMODE:
		{
			pString = "LINEERR_INVALPARKMODE";
			break;
		}

		// The specified password is not correct and the requested action has not been carried out.
		case LINEERR_INVALPASSWORD:
		{
			pString = "LINEERR_INVALPASSWORD";
			break;
		}

		// One or more of the specified pointer parameters (such as lpCallList, lpdwAPIVersion, lpExtensionID, lpdwExtVersion, lphIcon, lpLineDevCaps, and lpToneList) are invalid, or a required pointer to an output parameter is NULL.
		case LINEERR_INVALPOINTER:
		{
			pString = "LINEERR_INVALPOINTER";
			break;
		}

		// An invalid flag or combination of flags was set for the dwPrivileges parameter.
		case LINEERR_INVALPRIVSELECT:
		{
			pString = "LINEERR_INVALPRIVSELECT";
			break;
		}

		// The specified bearer mode is invalid.
		case LINEERR_INVALRATE:
		{
			pString = "LINEERR_INVALRATE";
			break;
		}

		// The specified request mode is invalid.
		case LINEERR_INVALREQUESTMODE:
		{
			pString = "LINEERR_INVALREQUESTMODE";
			break;
		}

		// The specified terminal mode parameter is invalid.
		case LINEERR_INVALTERMINALID:
		{
			pString = "LINEERR_INVALTERMINALID";
			break;
		}

		// The specified terminal modes parameter is invalid.
		case LINEERR_INVALTERMINALMODE:
		{
			pString = "LINEERR_INVALTERMINALMODE";
			break;
		}

		// Timeouts are not supported or the values of either or both of the parameters dwFirstDigitTimeout or dwInterDigitTimeout fall outside the valid range specified by the call's line-device capabilities.
		case LINEERR_INVALTIMEOUT:
		{
			pString = "LINEERR_INVALTIMEOUT";
			break;
		}

		// The specified custom tone does not represent a valid tone or is made up of too many frequencies or the specified tone structure does not describe a valid tone.
		case LINEERR_INVALTONE:
		{
			pString = "LINEERR_INVALTONE";
			break;
		}

		// The specified tone list is invalid.
		case LINEERR_INVALTONELIST:
		{
			pString = "LINEERR_INVALTONELIST";
			break;
		}

		// The specified tone mode parameter is invalid.
		case LINEERR_INVALTONEMODE:
		{
			pString = "LINEERR_INVALTONEMODE";
			break;
		}

		// The specified transfer mode parameter is invalid.
		case LINEERR_INVALTRANSFERMODE:
		{
			pString = "LINEERR_INVALTRANSFERMODE";
			break;
		}

		// LINEMAPPER was the value passed in the dwDeviceID parameter, but no lines were found that match the requirements specified in the lpCallParams parameter.
		case LINEERR_LINEMAPPERFAILED:
		{
			pString = "LINEERR_LINEMAPPERFAILED";
			break;
		}

		// The specified call is not a conference call handle or a participant call.
		case LINEERR_NOCONFERENCE:
		{
			pString = "LINEERR_NOCONFERENCE";
			break;
		}

		// The specified device identifier, which was previously valid, is no longer accepted because the associated device has been removed from the system since TAPI was last initialized. Alternately, the line device has no associated device for the given device class.
		case LINEERR_NODEVICE:
		{
			pString = "LINEERR_NODEVICE";
			break;
		}

		// Either tapiaddr.dll could not be located or the telephone service provider for the specified device found that one of its components is missing or corrupt in a way that was not detected at initialization time. The user should be advised to use the Telephony Control Panel to correct the problem.
		case LINEERR_NODRIVER:
		{
			pString = "LINEERR_NODRIVER";
			break;
		}

		// Insufficient memory to perform the operation, or unable to lock memory.
		case LINEERR_NOMEM:
		{
			pString = "LINEERR_NOMEM";
			break;
		}

		// A telephony service provider which does not support multiple instances is listed more than once in the [Providers] section in the registry. The application should advise the user to use the Telephony Control Panel to remove the duplicated driver.
		case LINEERR_NOMULTIPLEINSTANCE:
		{
			pString = "LINEERR_NOMULTIPLEINSTANCE";
			break;
		}

		// There currently is no request pending of the indicated mode, or the application is no longer the highest-priority application for the specified request mode.
		case LINEERR_NOREQUEST:
		{
			pString = "LINEERR_NOREQUEST";
			break;
		}

		// The application does not have owner privilege to the specified call.
		case LINEERR_NOTOWNER:
		{
			pString = "LINEERR_NOTOWNER";
			break;
		}

		// The application is not registered as a request recipient for the indicated request mode.
		case LINEERR_NOTREGISTERED:
		{
			pString = "LINEERR_NOTREGISTERED";
			break;
		}

		// The operation failed for an unspecified or unknown reason.
		case LINEERR_OPERATIONFAILED:
		{
			pString = "LINEERR_OPERATIONFAILED";
			break;
		}

		// The operation is not available, such as for the given device or specified line.
		case LINEERR_OPERATIONUNAVAIL:
		{
			pString = "LINEERR_OPERATIONUNAVAIL";
			break;
		}

		// The service provider currently does not have enough bandwidth available for the specified rate.
		case LINEERR_RATEUNAVAIL:
		{
			pString = "LINEERR_RATEUNAVAIL";
			break;
		}

		// If TAPI reinitialization has been requested, for example as a result of adding or removing a telephony service provider, then lineInitialize, lineInitializeEx, or lineOpen requests are rejected with this error until the last application shuts down its usage of the API (using lineShutdown), at which time the new configuration becomes effective and applications are once again permitted to call lineInitialize or lineInitializeEx.
		case LINEERR_REINIT:
		{
			pString = "LINEERR_REINIT";
			break;
		}

		// Insufficient resources to complete the operation. For example, a line cannot be opened due to a dynamic resource overcommitment.
		case LINEERR_RESOURCEUNAVAIL:
		{
			pString = "LINEERR_RESOURCEUNAVAIL";
			break;
		}

		// The dwTotalSize member indicates insufficient space to contain the fixed portion of the specified structure.
		case LINEERR_STRUCTURETOOSMALL:
		{
			pString = "LINEERR_STRUCTURETOOSMALL";
			break;
		}

		// A target for the call handoff was not found. This can occur if the named application did not open the same line with the LINECALLPRIVILEGE_OWNER bit in the dwPrivileges parameter of lineOpen. Or, in the case of media-mode handoff, no application has opened the same line with the LINECALLPRIVILEGE_OWNER bit in the dwPrivileges parameter of lineOpen and with the media mode specified in the dwMediaMode parameter having been specified in the dwMediaModes parameter of lineOpen.
		case LINEERR_TARGETNOTFOUND:
		{
			pString = "LINEERR_TARGETNOTFOUND";
			break;
		}

		// The application invoking this operation is the target of the indirect handoff. That is, TAPI has determined that the calling application is also the highest priority application for the given media mode.
		case LINEERR_TARGETSELF:
		{
			pString = "LINEERR_TARGETSELF";
			break;
		}

		// The operation was invoked before any application called lineInitialize , lineInitializeEx.
		case LINEERR_UNINITIALIZED:
		{
			pString = "LINEERR_UNINITIALIZED";
			break;
		}

		// The string containing user-user information exceeds the maximum number of bytes specified in the dwUUIAcceptSize, dwUUIAnswerSize, dwUUIDropSize, dwUUIMakeCallSize, or dwUUISendUserUserInfoSize member of LINEDEVCAPS, or the string containing user-user information is too long.
		case LINEERR_USERUSERINFOTOOBIG:
		{
			pString = "LINEERR_USERUSERINFOTOOBIG";
			break;
		}

		default:
		{
			DPFX(DPFPREP, 0, "Unknown TAPI error code %u/0x%lx", TAPIError, TAPIError );

			DNASSERT( FALSE );

			pString = "Unknown TAPI error";
			break;
		}
	}

	return	pString;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// GetWIN32ErrorString - convert system error to a string
//
// Entry:		Error code
//
// Exit:		Pointer to string
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "GetWIN32ErrorString"

static	char	*GetWIN32ErrorString( const LONG Error )
{
	char	*pString;

	switch ( Error )
	{
		case ERROR_SUCCESS:
		{
			// 0 The operation completed successfully.  ERROR_SUCCESS
			pString = "ERROR_SUCCESS";
			break;
		}

		case ERROR_INVALID_FUNCTION:
		{
			// 1 Incorrect function.  ERROR_INVALID_FUNCTION
			pString = "ERROR_INVALID_FUNCTION";
			break;
		}

		case ERROR_FILE_NOT_FOUND:
		{
			// 2 The system cannot find the file specified.  ERROR_FILE_NOT_FOUND
			pString = "ERROR_FILE_NOT_FOUND";
			break;
		}

		case ERROR_PATH_NOT_FOUND:
		{
			// 3 The system cannot find the path specified.  ERROR_PATH_NOT_FOUND
			pString = "ERROR_PATH_NOT_FOUND";
			break;
		}

		case ERROR_TOO_MANY_OPEN_FILES:
		{
			// 4 The system cannot open the file.  ERROR_TOO_MANY_OPEN_FILES
			pString = "ERROR_TOO_MANY_OPEN_FILES";
			break;
		}

		case ERROR_ACCESS_DENIED:
		{
			// 5 Access is denied.  ERROR_ACCESS_DENIED
			pString = "ERROR_ACCESS_DENIED";
			break;
		}

		case ERROR_INVALID_HANDLE:
		{
			// 6 The handle is invalid.  ERROR_INVALID_HANDLE
			pString = "ERROR_INVALID_HANDLE";
			break;
		}

		case ERROR_ARENA_TRASHED:
		{
			// 7 The storage control blocks were destroyed.  ERROR_ARENA_TRASHED
			pString = "ERROR_ARENA_TRASHED";
			break;
		}

		case ERROR_NOT_ENOUGH_MEMORY:
		{
			// 8 Not enough storage is available to process this command.  ERROR_NOT_ENOUGH_MEMORY
			pString = "ERROR_NOT_ENOUGH_MEMORY";
			break;
		}

		case ERROR_INVALID_BLOCK:
		{
			// 9 The storage control block address is invalid.  ERROR_INVALID_BLOCK
			pString = "ERROR_INVALID_BLOCK";
			break;
		}

		case ERROR_BAD_ENVIRONMENT:
		{
			// 10 The environment is incorrect.  ERROR_BAD_ENVIRONMENT
			pString = "ERROR_BAD_ENVIRONMENT";
			break;
		}

		case ERROR_BAD_FORMAT:
		{
			// 11 An attempt was made to load a program with an incorrect format.  ERROR_BAD_FORMAT
			pString = "ERROR_BAD_FORMAT";
			break;
		}

		case ERROR_INVALID_ACCESS:
		{
			// 12 The access code is invalid.  ERROR_INVALID_ACCESS
			pString = "ERROR_INVALID_ACCESS";
			break;
		}

		case ERROR_INVALID_DATA:
		{
			// 13 The data is invalid.  ERROR_INVALID_DATA
			pString = "ERROR_INVALID_DATA";
			break;
		}

		case ERROR_OUTOFMEMORY:
		{
			// 14 Not enough storage is available to complete this operation.  ERROR_OUTOFMEMORY
			pString = "ERROR_OUTOFMEMORY";
			break;
		}

		case ERROR_INVALID_DRIVE:
		{
			// 15 The system cannot find the drive specified.  ERROR_INVALID_DRIVE
			pString = "ERROR_INVALID_DRIVE";
			break;
		}

		case ERROR_CURRENT_DIRECTORY:
		{
			// 16 The directory cannot be removed.  ERROR_CURRENT_DIRECTORY
			pString = "ERROR_CURRENT_DIRECTORY";
			break;
		}

		case ERROR_NOT_SAME_DEVICE:
		{
			// 17 The system cannot move the file to a different disk drive.  ERROR_NOT_SAME_DEVICE
			pString = "ERROR_NOT_SAME_DEVICE";
			break;
		}

		case ERROR_NO_MORE_FILES:
		{
			// 18 There are no more files.  ERROR_NO_MORE_FILES
			pString = "ERROR_NO_MORE_FILES";
			break;
		}

		case ERROR_WRITE_PROTECT:
		{
			// 19 The media is write protected.  ERROR_WRITE_PROTECT
			pString = "ERROR_WRITE_PROTECT";
			break;
		}

		case ERROR_BAD_UNIT:
		{
			// 20 The system cannot find the device specified.  ERROR_BAD_UNIT
			pString = "ERROR_BAD_UNIT";
			break;
		}

		case ERROR_NOT_READY:
		{
			// 21 The device is not ready.  ERROR_NOT_READY
			pString = "ERROR_NOT_READY";
			break;
		}

		case ERROR_BAD_COMMAND:
		{
			// 22 The device does not recognize the command.  ERROR_BAD_COMMAND
			pString = "ERROR_BAD_COMMAND";
			break;
		}

		case ERROR_CRC:
		{
			// 23 Data error (cyclic redundancy check).  ERROR_CRC
			pString = "ERROR_CRC";
			break;
		}

		case ERROR_BAD_LENGTH:
		{
			// 24 The program issued a command but the command length is incorrect.  ERROR_BAD_LENGTH
			pString = "ERROR_BAD_LENGTH";
			break;
		}

		case ERROR_SEEK:
		{
			// 25 The drive cannot locate a specific area or track on the disk.  ERROR_SEEK
			pString = "ERROR_SEEK";
			break;
		}

		case ERROR_NOT_DOS_DISK:
		{
			// 26 The specified disk or diskette cannot be accessed.  ERROR_NOT_DOS_DISK
			pString = "ERROR_NOT_DOS_DISK";
			break;
		}

		case ERROR_SECTOR_NOT_FOUND:
		{
			// 27 The drive cannot find the sector requested.  ERROR_SECTOR_NOT_FOUND
			pString = "ERROR_SECTOR_NOT_FOUND";
			break;
		}

		case ERROR_OUT_OF_PAPER:
		{
			// 28 The printer is out of paper.  ERROR_OUT_OF_PAPER
			pString = "ERROR_OUT_OF_PAPER";
			break;
		}

		case ERROR_WRITE_FAULT:
		{
			// 29 The system cannot write to the specified device.  ERROR_WRITE_FAULT
			pString = "ERROR_WRITE_FAULT";
			break;
		}

		case ERROR_READ_FAULT:
		{
			// 30 The system cannot read from the specified device.  ERROR_READ_FAULT
			pString = "ERROR_READ_FAULT";
			break;
		}

		case ERROR_GEN_FAILURE:
		{
			// 31 A device attached to the system is not functioning.  ERROR_GEN_FAILURE
			pString = "ERROR_GEN_FAILURE";
			break;
		}

		case ERROR_SHARING_VIOLATION:
		{
			// 32 The process cannot access the file because it is being used by another process.  ERROR_SHARING_VIOLATION
			pString = "ERROR_SHARING_VIOLATION";
			break;
		}

		case ERROR_LOCK_VIOLATION:
		{
			// 33 The process cannot access the file because another process has locked a portion of the file.  ERROR_LOCK_VIOLATION
			pString = "ERROR_LOCK_VIOLATION";
			break;
		}

		case ERROR_WRONG_DISK:
		{
			// 34 The wrong diskette is in the drive. Insert %2 (Volume Serial Number: %3) into drive %1.  ERROR_WRONG_DISK
			pString = "ERROR_WRONG_DISK";
			break;
		}

		case ERROR_SHARING_BUFFER_EXCEEDED:
		{
			// 36 Too many files opened for sharing.  ERROR_SHARING_BUFFER_EXCEEDED
			pString = "ERROR_SHARING_BUFFER_EXCEEDED";
			break;
		}

		case ERROR_HANDLE_EOF:
		{
			// 38 Reached the end of the file.  ERROR_HANDLE_EOF
			pString = "ERROR_HANDLE_EOF";
			break;
		}

		case ERROR_HANDLE_DISK_FULL:
		{
			// 39 The disk is full.  ERROR_HANDLE_DISK_FULL
			pString = "ERROR_HANDLE_DISK_FULL";
			break;
		}

		case ERROR_NOT_SUPPORTED:
		{
			// 50 The network request is not supported.  ERROR_NOT_SUPPORTED
			pString = "ERROR_NOT_SUPPORTED";
			break;
		}

		case ERROR_REM_NOT_LIST:
		{
			// 51 The remote computer is not available.  ERROR_REM_NOT_LIST
			pString = "ERROR_REM_NOT_LIST";
			break;
		}

		case ERROR_DUP_NAME:
		{
			// 52 A duplicate name exists on the network.  ERROR_DUP_NAME
			pString = "ERROR_DUP_NAME";
			break;
		}

		case ERROR_BAD_NETPATH:
		{
			// 53 The network path was not found.  ERROR_BAD_NETPATH
			pString = "ERROR_BAD_NETPATH";
			break;
		}

		case ERROR_NETWORK_BUSY:
		{
			// 54 The network is busy.  ERROR_NETWORK_BUSY
			pString = "ERROR_NETWORK_BUSY";
			break;
		}

		case ERROR_DEV_NOT_EXIST:
		{
			// 55 The specified network resource or device is no longer available.  ERROR_DEV_NOT_EXIST
			pString = "ERROR_DEV_NOT_EXIST";
			break;
		}

		case ERROR_TOO_MANY_CMDS:
		{
			// 56 The network BIOS command limit has been reached.  ERROR_TOO_MANY_CMDS
			pString = "ERROR_TOO_MANY_CMDS";
			break;
		}

		case ERROR_ADAP_HDW_ERR:
		{
			// 57 A network adapter hardware error occurred.  ERROR_ADAP_HDW_ERR
			pString = "ERROR_ADAP_HDW_ERR";
			break;
		}

		case ERROR_BAD_NET_RESP:
		{
			// 58 The specified server cannot perform the requested operation.  ERROR_BAD_NET_RESP
			pString = "ERROR_BAD_NET_RESP";
			break;
		}

		case ERROR_UNEXP_NET_ERR:
		{
			// 59 An unexpected network error occurred.  ERROR_UNEXP_NET_ERR
			pString = "ERROR_UNEXP_NET_ERR";
			break;
		}

		case ERROR_BAD_REM_ADAP:
		{
			// 60 The remote adapter is not compatible.  ERROR_BAD_REM_ADAP
			pString = "ERROR_BAD_REM_ADAP";
			break;
		}

		case ERROR_PRINTQ_FULL:
		{
			// 61 The printer queue is full.  ERROR_PRINTQ_FULL
			pString = "ERROR_PRINTQ_FULL";
			break;
		}

		case ERROR_NO_SPOOL_SPACE:
		{
			// 62 Space to store the file waiting to be printed is not available on the server.  ERROR_NO_SPOOL_SPACE
			pString = "ERROR_NO_SPOOL_SPACE";
			break;
		}

		case ERROR_PRINT_CANCELLED:
		{
			// 63 Your file waiting to be printed was deleted.  ERROR_PRINT_CANCELLED
			pString = "ERROR_PRINT_CANCELLED";
			break;
		}

		case ERROR_NETNAME_DELETED:
		{
			// 64 The specified network name is no longer available.  ERROR_NETNAME_DELETED
			pString = "ERROR_NETNAME_DELETED";
			break;
		}

		case ERROR_NETWORK_ACCESS_DENIED:
		{
			// 65 Network access is denied.  ERROR_NETWORK_ACCESS_DENIED
			pString = "ERROR_NETWORK_ACCESS_DENIED";
			break;
		}

		case ERROR_BAD_DEV_TYPE:
		{
			// 66 The network resource type is not correct.  ERROR_BAD_DEV_TYPE
			pString = "ERROR_BAD_DEV_TYPE";
			break;
		}

		case ERROR_BAD_NET_NAME:
		{
			// 67 The network name cannot be found.  ERROR_BAD_NET_NAME
			pString = "ERROR_BAD_NET_NAME";
			break;
		}

		case ERROR_TOO_MANY_NAMES:
		{
			// 68 The name limit for the local computer network adapter card was exceeded.  ERROR_TOO_MANY_NAMES
			pString = "ERROR_TOO_MANY_NAMES";
			break;
		}

		case ERROR_TOO_MANY_SESS:
		{
			// 69 The network BIOS session limit was exceeded.  ERROR_TOO_MANY_SESS
			pString = "ERROR_TOO_MANY_SESS";
			break;
		}

		case ERROR_SHARING_PAUSED:
		{
			// 70 The remote server has been paused or is in the process of being started.  ERROR_SHARING_PAUSED
			pString = "ERROR_SHARING_PAUSED";
			break;
		}

		case ERROR_REQ_NOT_ACCEP:
		{
			// 71 No more connections can be made to this remote computer at this time because there are already as many connections as the computer can accept.  ERROR_REQ_NOT_ACCEP
			pString = "ERROR_REQ_NOT_ACCEP";
			break;
		}

		case ERROR_REDIR_PAUSED:
		{
			// 72 The specified printer or disk device has been paused.  ERROR_REDIR_PAUSED
			pString = "ERROR_REDIR_PAUSED";
			break;
		}

		case ERROR_FILE_EXISTS:
		{
			// 80 The file exists.  ERROR_FILE_EXISTS
			pString = "ERROR_FILE_EXISTS";
			break;
		}

		case ERROR_CANNOT_MAKE:
		{
			// 82 The directory or file cannot be created.  ERROR_CANNOT_MAKE
			pString = "ERROR_CANNOT_MAKE";
			break;
		}

		case ERROR_FAIL_I24:
		{
			// 83 Fail on INT 24.  ERROR_FAIL_I24
			pString = "ERROR_FAIL_I24";
			break;
		}

		case ERROR_OUT_OF_STRUCTURES:
		{
			// 84 Storage to process this request is not available.  ERROR_OUT_OF_STRUCTURES
			pString = "ERROR_OUT_OF_STRUCTURES";
			break;
		}

		case ERROR_ALREADY_ASSIGNED:
		{
			// 85 The local device name is already in use.  ERROR_ALREADY_ASSIGNED
			pString = "ERROR_ALREADY_ASSIGNED";
			break;
		}

		case ERROR_INVALID_PASSWORD:
		{
			// 86 The specified network password is not correct.  ERROR_INVALID_PASSWORD
			pString = "ERROR_INVALID_PASSWORD";
			break;
		}

		case ERROR_INVALID_PARAMETER:
		{
			// 87 The parameter is incorrect.  ERROR_INVALID_PARAMETER
			pString = "ERROR_INVALID_PARAMETER";
			break;
		}

		case ERROR_NET_WRITE_FAULT:
		{
			// 88 A write fault occurred on the network.  ERROR_NET_WRITE_FAULT
			pString = "ERROR_NET_WRITE_FAULT";
			break;
		}

		case ERROR_NO_PROC_SLOTS:
		{
			// 89 The system cannot start another process at this time.  ERROR_NO_PROC_SLOTS
			pString = "ERROR_NO_PROC_SLOTS";
			break;
		}

		case ERROR_TOO_MANY_SEMAPHORES:
		{
			// 100 Cannot create another system semaphore.  ERROR_TOO_MANY_SEMAPHORES
			pString = "ERROR_TOO_MANY_SEMAPHORES";
			break;
		}

		case ERROR_EXCL_SEM_ALREADY_OWNED:
		{
			// 101 The exclusive semaphore is owned by another process.  ERROR_EXCL_SEM_ALREADY_OWNED
			pString = "ERROR_EXCL_SEM_ALREADY_OWNED";
			break;
		}

		case ERROR_SEM_IS_SET:
		{
			// 102 The semaphore is set and cannot be closed.  ERROR_SEM_IS_SET
			pString = "ERROR_SEM_IS_SET";
			break;
		}

		case ERROR_TOO_MANY_SEM_REQUESTS:
		{
			// 103 The semaphore cannot be set again.  ERROR_TOO_MANY_SEM_REQUESTS
			pString = "ERROR_TOO_MANY_SEM_REQUESTS";
			break;
		}

		case ERROR_INVALID_AT_INTERRUPT_TIME:
		{
			// 104 Cannot request exclusive semaphores at interrupt time.  ERROR_INVALID_AT_INTERRUPT_TIME
			pString = "ERROR_INVALID_AT_INTERRUPT_TIME";
			break;
		}

		case ERROR_SEM_OWNER_DIED:
		{
			// 105 The previous ownership of this semaphore has ended.  ERROR_SEM_OWNER_DIED
			pString = "ERROR_SEM_OWNER_DIED";
			break;
		}

		case ERROR_SEM_USER_LIMIT:
		{
			// 106 Insert the diskette for drive %1.  ERROR_SEM_USER_LIMIT
			pString = "ERROR_SEM_USER_LIMIT";
			break;
		}

		case ERROR_DISK_CHANGE:
		{
			// 107 The program stopped because an alternate diskette was not inserted.  ERROR_DISK_CHANGE
			pString = "ERROR_DISK_CHANGE";
			break;
		}

		case ERROR_DRIVE_LOCKED:
		{
			// 108 The disk is in use or locked by another process.  ERROR_DRIVE_LOCKED
			pString = "ERROR_DRIVE_LOCKED";
			break;
		}

		case ERROR_BROKEN_PIPE:
		{
			// 109 The pipe has been ended.  ERROR_BROKEN_PIPE
			pString = "ERROR_BROKEN_PIPE";
			break;
		}

		case ERROR_OPEN_FAILED:
		{
			// 110 The system cannot open the device or file specified.  ERROR_OPEN_FAILED
			pString = "ERROR_OPEN_FAILED";
			break;
		}

		case ERROR_BUFFER_OVERFLOW:
		{
			// 111 The file name is too long.  ERROR_BUFFER_OVERFLOW
			pString = "ERROR_BUFFER_OVERFLOW";
			break;
		}

		case ERROR_DISK_FULL:
		{
			// 112 There is not enough space on the disk.  ERROR_DISK_FULL
			pString = "ERROR_DISK_FULL";
			break;
		}

		case ERROR_NO_MORE_SEARCH_HANDLES:
		{
			// 113 No more internal file identifiers available.  ERROR_NO_MORE_SEARCH_HANDLES
			pString = "ERROR_NO_MORE_SEARCH_HANDLES";
			break;
		}

		case ERROR_INVALID_TARGET_HANDLE:
		{
			// 114 The target internal file identifier is incorrect.  ERROR_INVALID_TARGET_HANDLE
			pString = "ERROR_INVALID_TARGET_HANDLE";
			break;
		}

		case ERROR_INVALID_CATEGORY:
		{
			// 117 The IOCTL call made by the application program is not correct.  ERROR_INVALID_CATEGORY
			pString = "ERROR_INVALID_CATEGORY";
			break;
		}

		case ERROR_INVALID_VERIFY_SWITCH:
		{
			// 118 The verify-on-write switch parameter value is not correct.  ERROR_INVALID_VERIFY_SWITCH
			pString = "ERROR_INVALID_VERIFY_SWITCH";
			break;
		}

		case ERROR_BAD_DRIVER_LEVEL:
		{
			// 119 The system does not support the command requested.  ERROR_BAD_DRIVER_LEVEL
			pString = "ERROR_BAD_DRIVER_LEVEL";
			break;
		}

		case ERROR_CALL_NOT_IMPLEMENTED:
		{
			// 120 This function is not supported on this system.  ERROR_CALL_NOT_IMPLEMENTED
			pString = "ERROR_CALL_NOT_IMPLEMENTED";
			break;
		}

		case ERROR_SEM_TIMEOUT:
		{
			// 121 The semaphore timeout period has expired.  ERROR_SEM_TIMEOUT
			pString = "ERROR_SEM_TIMEOUT";
			break;
		}

		case ERROR_INSUFFICIENT_BUFFER:
		{
			// 122 The data area passed to a system call is too small.  ERROR_INSUFFICIENT_BUFFER
			pString = "ERROR_INSUFFICIENT_BUFFER";
			break;
		}

		case ERROR_INVALID_NAME:
		{
			// 123 The filename, directory name, or volume label syntax is incorrect.  ERROR_INVALID_NAME
			pString = "ERROR_INVALID_NAME";
			break;
		}

		case ERROR_INVALID_LEVEL:
		{
			// 124 The system call level is not correct.  ERROR_INVALID_LEVEL
			pString = "ERROR_INVALID_LEVEL";
			break;
		}

		case ERROR_NO_VOLUME_LABEL:
		{
			// 125 The disk has no volume label.  ERROR_NO_VOLUME_LABEL
			pString = "ERROR_NO_VOLUME_LABEL";
			break;
		}

		case ERROR_MOD_NOT_FOUND:
		{
			// 126 The specified module could not be found.  ERROR_MOD_NOT_FOUND
			pString = "ERROR_MOD_NOT_FOUND";
			break;
		}

		case ERROR_PROC_NOT_FOUND:
		{
			// 127 The specified procedure could not be found.  ERROR_PROC_NOT_FOUND
			pString = "ERROR_PROC_NOT_FOUND";
			break;
		}

		case ERROR_WAIT_NO_CHILDREN:
		{
			// 128 There are no child processes to wait for.  ERROR_WAIT_NO_CHILDREN
			pString = "ERROR_WAIT_NO_CHILDREN";
			break;
		}

		case ERROR_CHILD_NOT_COMPLETE:
		{
			// 129 The %1 application cannot be run in Win32 mode.  ERROR_CHILD_NOT_COMPLETE
			pString = "ERROR_CHILD_NOT_COMPLETE";
			break;
		}

		case ERROR_DIRECT_ACCESS_HANDLE:
		{
			// 130 Attempt to use a file handle to an open disk partition for an operation other than raw disk I/O.  ERROR_DIRECT_ACCESS_HANDLE
			pString = "ERROR_DIRECT_ACCESS_HANDLE";
			break;
		}

		case ERROR_NEGATIVE_SEEK:
		{
			// 131 An attempt was made to move the file pointer before the beginning of the file.  ERROR_NEGATIVE_SEEK
			pString = "ERROR_NEGATIVE_SEEK";
			break;
		}

		case ERROR_SEEK_ON_DEVICE:
		{
			// 132 The file pointer cannot be set on the specified device or file.  ERROR_SEEK_ON_DEVICE
			pString = "ERROR_SEEK_ON_DEVICE";
			break;
		}

		case ERROR_IS_JOIN_TARGET:
		{
			// 133 A JOIN or SUBST command cannot be used for a drive that contains previously joined drives.  ERROR_IS_JOIN_TARGET
			pString = "ERROR_IS_JOIN_TARGET";
			break;
		}

		case ERROR_IS_JOINED:
		{
			// 134 An attempt was made to use a JOIN or SUBST command on a drive that has already been joined.  ERROR_IS_JOINED
			pString = "ERROR_IS_JOINED";
			break;
		}

		case ERROR_IS_SUBSTED:
		{
			// 135 An attempt was made to use a JOIN or SUBST command on a drive that has already been substituted.  ERROR_IS_SUBSTED
			pString = "ERROR_IS_SUBSTED";
			break;
		}

		case ERROR_NOT_JOINED:
		{
			// 136 The system tried to delete the JOIN of a drive that is not joined.  ERROR_NOT_JOINED
			pString = "ERROR_NOT_JOINED";
			break;
		}

		case ERROR_NOT_SUBSTED:
		{
			// 137 The system tried to delete the substitution of a drive that is not substituted.  ERROR_NOT_SUBSTED
			pString = "ERROR_NOT_SUBSTED";
			break;
		}

		case ERROR_JOIN_TO_JOIN:
		{
			// 138 The system tried to join a drive to a directory on a joined drive.  ERROR_JOIN_TO_JOIN
			pString = "ERROR_JOIN_TO_JOIN";
			break;
		}

		case ERROR_SUBST_TO_SUBST:
		{
			// 139 The system tried to substitute a drive to a directory on a substituted drive.  ERROR_SUBST_TO_SUBST
			pString = "ERROR_SUBST_TO_SUBST";
			break;
		}

		case ERROR_JOIN_TO_SUBST:
		{
			// 140 The system tried to join a drive to a directory on a substituted drive.  ERROR_JOIN_TO_SUBST
			pString = "ERROR_JOIN_TO_SUBST";
			break;
		}

		case ERROR_SUBST_TO_JOIN:
		{
			// 141 The system tried to SUBST a drive to a directory on a joined drive.  ERROR_SUBST_TO_JOIN
			pString = "ERROR_SUBST_TO_JOIN";
			break;
		}

		case ERROR_BUSY_DRIVE:
		{
			// 142 The system cannot perform a JOIN or SUBST at this time.  ERROR_BUSY_DRIVE
			pString = "ERROR_BUSY_DRIVE";
			break;
		}

		case ERROR_SAME_DRIVE:
		{
			// 143 The system cannot join or substitute a drive to or for a directory on the same drive.  ERROR_SAME_DRIVE
			pString = "ERROR_SAME_DRIVE";
			break;
		}

		case ERROR_DIR_NOT_ROOT:
		{
			// 144 The directory is not a subdirectory of the root directory.  ERROR_DIR_NOT_ROOT
			pString = "ERROR_DIR_NOT_ROOT";
			break;
		}

		case ERROR_DIR_NOT_EMPTY:
		{
			// 145 The directory is not empty.  ERROR_DIR_NOT_EMPTY
			pString = "ERROR_DIR_NOT_EMPTY";
			break;
		}

		case ERROR_IS_SUBST_PATH:
		{
			// 146 The path specified is being used in a substitute.  ERROR_IS_SUBST_PATH
			pString = "ERROR_IS_SUBST_PATH";
			break;
		}

		case ERROR_IS_JOIN_PATH:
		{
			// 147 Not enough resources are available to process this command.  ERROR_IS_JOIN_PATH
			pString = "ERROR_IS_JOIN_PATH";
			break;
		}

		case ERROR_PATH_BUSY:
		{
			// 148 The path specified cannot be used at this time.  ERROR_PATH_BUSY
			pString = "ERROR_PATH_BUSY";
			break;
		}

		case ERROR_IS_SUBST_TARGET:
		{
			// 149 An attempt was made to join or substitute a drive for which a directory on the drive is the target of a previous substitute.  ERROR_IS_SUBST_TARGET
			pString = "ERROR_IS_SUBST_TARGET";
			break;
		}

		case ERROR_SYSTEM_TRACE:
		{
			// 150 System trace information was not specified in your CONFIG.SYS file, or tracing is disallowed.  ERROR_SYSTEM_TRACE
			pString = "ERROR_SYSTEM_TRACE";
			break;
		}

		case ERROR_INVALID_EVENT_COUNT:
		{
			// 151 The number of specified semaphore events for DosMuxSemWait is not correct.  ERROR_INVALID_EVENT_COUNT
			pString = "ERROR_INVALID_EVENT_COUNT";
			break;
		}

		case ERROR_TOO_MANY_MUXWAITERS:
		{
			// 152 DosMuxSemWait did not execute; too many semaphores are already set.  ERROR_TOO_MANY_MUXWAITERS
			pString = "ERROR_TOO_MANY_MUXWAITERS";
			break;
		}

		case ERROR_INVALID_LIST_FORMAT:
		{
			// 153 The DosMuxSemWait list is not correct.  ERROR_INVALID_LIST_FORMAT
			pString = "ERROR_INVALID_LIST_FORMAT";
			break;
		}

		case ERROR_LABEL_TOO_LONG:
		{
			// 154 The volume label you entered exceeds the label character limit of the target file system.  ERROR_LABEL_TOO_LONG
			pString = "ERROR_LABEL_TOO_LONG";
			break;
		}

		case ERROR_TOO_MANY_TCBS:
		{
			// 155 Cannot create another thread.  ERROR_TOO_MANY_TCBS
			pString = "ERROR_TOO_MANY_TCBS";
			break;
		}

		case ERROR_SIGNAL_REFUSED:
		{
			// 156 The recipient process has refused the signal.  ERROR_SIGNAL_REFUSED
			pString = "ERROR_SIGNAL_REFUSED";
			break;
		}

		case ERROR_DISCARDED:
		{
			// 157 The segment is already discarded and cannot be locked.  ERROR_DISCARDED
			pString = "ERROR_DISCARDED";
			break;
		}

		case ERROR_NOT_LOCKED:
		{
			// 158 The segment is already unlocked.  ERROR_NOT_LOCKED
			pString = "ERROR_NOT_LOCKED";
			break;
		}

		case ERROR_BAD_THREADID_ADDR:
		{
			// 159 The address for the thread ID is not correct.  ERROR_BAD_THREADID_ADDR
			pString = "ERROR_BAD_THREADID_ADDR";
			break;
		}

		case ERROR_BAD_ARGUMENTS:
		{
			// 160 The argument string passed to DosExecPgm is not correct.  ERROR_BAD_ARGUMENTS
			pString = "ERROR_BAD_ARGUMENTS";
			break;
		}

		case ERROR_BAD_PATHNAME:
		{
			// 161 The specified path is invalid.  ERROR_BAD_PATHNAME
			pString = "ERROR_BAD_PATHNAME";
			break;
		}

		case ERROR_SIGNAL_PENDING:
		{
			// 162 A signal is already pending.  ERROR_SIGNAL_PENDING
			pString = "ERROR_SIGNAL_PENDING";
			break;
		}

		case ERROR_MAX_THRDS_REACHED:
		{
			// 164 No more threads can be created in the system.  ERROR_MAX_THRDS_REACHED
			pString = "ERROR_MAX_THRDS_REACHED";
			break;
		}

		case ERROR_LOCK_FAILED:
		{
			// 167 Unable to lock a region of a file.  ERROR_LOCK_FAILED
			pString = "ERROR_LOCK_FAILED";
			break;
		}

		case ERROR_BUSY:
		{
			// 170 The requested resource is in use.  ERROR_BUSY
			pString = "ERROR_BUSY";
			break;
		}

		case ERROR_CANCEL_VIOLATION:
		{
			// 173 A lock request was not outstanding for the supplied cancel region.  ERROR_CANCEL_VIOLATION
			pString = "ERROR_CANCEL_VIOLATION";
			break;
		}

		case ERROR_ATOMIC_LOCKS_NOT_SUPPORTED:
		{
			// 174 The file system does not support atomic changes to the lock type.  ERROR_ATOMIC_LOCKS_NOT_SUPPORTED
			pString = "ERROR_ATOMIC_LOCKS_NOT_SUPPORTED";
			break;
		}

		case ERROR_INVALID_SEGMENT_NUMBER:
		{
			// 180 The system detected a segment number that was not correct.  ERROR_INVALID_SEGMENT_NUMBER
			pString = "ERROR_INVALID_SEGMENT_NUMBER";
			break;
		}

		case ERROR_INVALID_ORDINAL:
		{
			// 182 The operating system cannot run %1.  ERROR_INVALID_ORDINAL
			pString = "ERROR_INVALID_ORDINAL";
			break;
		}

		case ERROR_ALREADY_EXISTS:
		{
			// 183 Cannot create a file when that file already exists.  ERROR_ALREADY_EXISTS
			pString = "ERROR_ALREADY_EXISTS";
			break;
		}

		case ERROR_INVALID_FLAG_NUMBER:
		{
			// 186 The flag passed is not correct.  ERROR_INVALID_FLAG_NUMBER
			pString = "ERROR_INVALID_FLAG_NUMBER";
			break;
		}

		case ERROR_SEM_NOT_FOUND:
		{
			// 187 The specified system semaphore name was not found.  ERROR_SEM_NOT_FOUND
			pString = "ERROR_SEM_NOT_FOUND";
			break;
		}

		case ERROR_INVALID_STARTING_CODESEG:
		{
			// 188 The operating system cannot run %1.  ERROR_INVALID_STARTING_CODESEG
			pString = "ERROR_INVALID_STARTING_CODESEG";
			break;
		}

		case ERROR_INVALID_STACKSEG:
		{
			// 189 The operating system cannot run %1.  ERROR_INVALID_STACKSEG
			pString = "ERROR_INVALID_STACKSEG";
			break;
		}

		case ERROR_INVALID_MODULETYPE:
		{
			// 190 The operating system cannot run %1.  ERROR_INVALID_MODULETYPE
			pString = "ERROR_INVALID_MODULETYPE";
			break;
		}

		case ERROR_INVALID_EXE_SIGNATURE:
		{
			// 191 Cannot run %1 in Win32 mode.  ERROR_INVALID_EXE_SIGNATURE
			pString = "ERROR_INVALID_EXE_SIGNATURE";
			break;
		}

		case ERROR_EXE_MARKED_INVALID:
		{
			// 192 The operating system cannot run %1.  ERROR_EXE_MARKED_INVALID
			pString = "ERROR_EXE_MARKED_INVALID";
			break;
		}

		case ERROR_BAD_EXE_FORMAT:
		{
			// 193 is not a valid Win32 application.  ERROR_BAD_EXE_FORMAT
			pString = "ERROR_BAD_EXE_FORMAT";
			break;
		}

		case ERROR_ITERATED_DATA_EXCEEDS_64k:
		{
			// 194 The operating system cannot run %1.  ERROR_ITERATED_DATA_EXCEEDS_64k
			pString = "ERROR_ITERATED_DATA_EXCEEDS_64k";
			break;
		}

		case ERROR_INVALID_MINALLOCSIZE:
		{
			// 195 The operating system cannot run %1.  ERROR_INVALID_MINALLOCSIZE
			pString = "ERROR_INVALID_MINALLOCSIZE";
			break;
		}

		case ERROR_DYNLINK_FROM_INVALID_RING:
		{
			// 196 The operating system cannot run this application program.  ERROR_DYNLINK_FROM_INVALID_RING
			pString = "ERROR_DYNLINK_FROM_INVALID_RING";
			break;
		}

		case ERROR_IOPL_NOT_ENABLED:
		{
			// 197 The operating system is not presently configured to run this application.  ERROR_IOPL_NOT_ENABLED
			pString = "ERROR_IOPL_NOT_ENABLED";
			break;
		}

		case ERROR_INVALID_SEGDPL:
		{
			// 198 The operating system cannot run %1.  ERROR_INVALID_SEGDPL
			pString = "ERROR_INVALID_SEGDPL";
			break;
		}

		case ERROR_AUTODATASEG_EXCEEDS_64k:
		{
			// 199 The operating system cannot run this application program.  ERROR_AUTODATASEG_EXCEEDS_64k
			pString = "ERROR_AUTODATASEG_EXCEEDS_64k";
			break;
		}

		case ERROR_RING2SEG_MUST_BE_MOVABLE:
		{
			// 200 The code segment cannot be greater than or equal to 64K.  ERROR_RING2SEG_MUST_BE_MOVABLE
			pString = "ERROR_RING2SEG_MUST_BE_MOVABLE";
			break;
		}

		case ERROR_RELOC_CHAIN_XEEDS_SEGLIM:
		{
			// 201 The operating system cannot run %1.  ERROR_RELOC_CHAIN_XEEDS_SEGLIM
			pString = "ERROR_RELOC_CHAIN_XEEDS_SEGLIM";
			break;
		}

		case ERROR_INFLOOP_IN_RELOC_CHAIN:
		{
			// 202 The operating system cannot run %1.  ERROR_INFLOOP_IN_RELOC_CHAIN
			pString = "ERROR_INFLOOP_IN_RELOC_CHAIN";
			break;
		}

		case ERROR_ENVVAR_NOT_FOUND:
		{
			// 203 The system could not find the environment option that was entered.  ERROR_ENVVAR_NOT_FOUND
			pString = "ERROR_ENVVAR_NOT_FOUND";
			break;
		}

		case ERROR_NO_SIGNAL_SENT:
		{
			// 205 No process in the command subtree has a signal handler.  ERROR_NO_SIGNAL_SENT
			pString = "ERROR_NO_SIGNAL_SENT";
			break;
		}

		case ERROR_FILENAME_EXCED_RANGE:
		{
			// 206 The filename or extension is too long.  ERROR_FILENAME_EXCED_RANGE
			pString = "ERROR_FILENAME_EXCED_RANGE";
			break;
		}

		case ERROR_RING2_STACK_IN_USE:
		{
			// 207 The ring 2 stack is in use.  ERROR_RING2_STACK_IN_USE
			pString = "ERROR_RING2_STACK_IN_USE";
			break;
		}

		case ERROR_META_EXPANSION_TOO_LONG:
		{
			// 208 The global filename characters, * or ?, are entered incorrectly or too many global filename characters are specified.  ERROR_META_EXPANSION_TOO_LONG
			pString = "ERROR_META_EXPANSION_TOO_LONG";
			break;
		}

		case ERROR_INVALID_SIGNAL_NUMBER:
		{
			// 209 The signal being posted is not correct.  ERROR_INVALID_SIGNAL_NUMBER
			pString = "ERROR_INVALID_SIGNAL_NUMBER";
			break;
		}

		case ERROR_THREAD_1_INACTIVE:
		{
			// 210 The signal handler cannot be set.  ERROR_THREAD_1_INACTIVE
			pString = "ERROR_THREAD_1_INACTIVE";
			break;
		}

		case ERROR_LOCKED:
		{
			// 212 The segment is locked and cannot be reallocated.  ERROR_LOCKED
			pString = "ERROR_LOCKED";
			break;
		}

		case ERROR_TOO_MANY_MODULES:
		{
			// 214 Too many dynamic-link modules are attached to this program or dynamic-link module.  ERROR_TOO_MANY_MODULES
			pString = "ERROR_TOO_MANY_MODULES";
			break;
		}

		case ERROR_NESTING_NOT_ALLOWED:
		{
			// 215 Can't nest calls to LoadModule.  ERROR_NESTING_NOT_ALLOWED
			pString = "ERROR_NESTING_NOT_ALLOWED";
			break;
		}

		case ERROR_EXE_MACHINE_TYPE_MISMATCH:
		{
			// 216 The image file %1 is valid, but is for a machine type other than the current machine.  ERROR_EXE_MACHINE_TYPE_MISMATCH
			pString = "ERROR_EXE_MACHINE_TYPE_MISMATCH";
			break;
		}

		case ERROR_BAD_PIPE:
		{
			// 230 The pipe state is invalid.  ERROR_BAD_PIPE
			pString = "ERROR_BAD_PIPE";
			break;
		}

		case ERROR_PIPE_BUSY:
		{
			// 231 All pipe instances are busy.  ERROR_PIPE_BUSY
			pString = "ERROR_PIPE_BUSY";
			break;
		}

		case ERROR_NO_DATA:
		{
			// 232 The pipe is being closed.  ERROR_NO_DATA
			pString = "ERROR_NO_DATA";
			break;
		}

		case ERROR_PIPE_NOT_CONNECTED:
		{
			// 233 No process is on the other end of the pipe.  ERROR_PIPE_NOT_CONNECTED
			pString = "ERROR_PIPE_NOT_CONNECTED";
			break;
		}

		case ERROR_MORE_DATA:
		{
			// 234 More data is available.  ERROR_MORE_DATA
			pString = "ERROR_MORE_DATA";
			break;
		}

		case ERROR_VC_DISCONNECTED:
		{
			// 240 The session was canceled.  ERROR_VC_DISCONNECTED
			pString = "ERROR_VC_DISCONNECTED";
			break;
		}

		case ERROR_INVALID_EA_NAME:
		{
			// 254 The specified extended attribute name was invalid.  ERROR_INVALID_EA_NAME
			pString = "ERROR_INVALID_EA_NAME";
			break;
		}

		case ERROR_EA_LIST_INCONSISTENT:
		{
			// 255 The extended attributes are inconsistent.  ERROR_EA_LIST_INCONSISTENT
			pString = "ERROR_EA_LIST_INCONSISTENT";
			break;
		}

		case ERROR_NO_MORE_ITEMS:
		{
			// 259 No more data is available.  ERROR_NO_MORE_ITEMS
			pString = "ERROR_NO_MORE_ITEMS";
			break;
		}

		case ERROR_CANNOT_COPY:
		{
			// 266 The copy functions cannot be used.  ERROR_CANNOT_COPY
			pString = "ERROR_CANNOT_COPY";
			break;
		}

		case ERROR_DIRECTORY:
		{
			// 267 The directory name is invalid.  ERROR_DIRECTORY
			pString = "ERROR_DIRECTORY";
			break;
		}

		case ERROR_EAS_DIDNT_FIT:
		{
			// 275 The extended attributes did not fit in the buffer.  ERROR_EAS_DIDNT_FIT
			pString = "ERROR_EAS_DIDNT_FIT";
			break;
		}

		case ERROR_EA_FILE_CORRUPT:
		{
			// 276 The extended attribute file on the mounted file system is corrupt.  ERROR_EA_FILE_CORRUPT
			pString = "ERROR_EA_FILE_CORRUPT";
			break;
		}

		case ERROR_EA_TABLE_FULL:
		{
			// 277 The extended attribute table file is full.  ERROR_EA_TABLE_FULL
			pString = "ERROR_EA_TABLE_FULL";
			break;
		}

		case ERROR_INVALID_EA_HANDLE:
		{
			// 278 The specified extended attribute handle is invalid.  ERROR_INVALID_EA_HANDLE
			pString = "ERROR_INVALID_EA_HANDLE";
			break;
		}

		case ERROR_EAS_NOT_SUPPORTED:
		{
			// 282 The mounted file system does not support extended attributes.  ERROR_EAS_NOT_SUPPORTED
			pString = "ERROR_EAS_NOT_SUPPORTED";
			break;
		}

		case ERROR_NOT_OWNER:
		{
			// 288 Attempt to release mutex not owned by caller.  ERROR_NOT_OWNER
			pString = "ERROR_NOT_OWNER";
			break;
		}

		case ERROR_TOO_MANY_POSTS:
		{
			// 298 Too many posts were made to a semaphore.  ERROR_TOO_MANY_POSTS
			pString = "ERROR_TOO_MANY_POSTS";
			break;
		}

		case ERROR_PARTIAL_COPY:
		{
			// 299 Only part of a ReadProcessMemoty or WriteProcessMemory request was completed.  ERROR_PARTIAL_COPY
			pString = "ERROR_PARTIAL_COPY";
			break;
		}

		case ERROR_OPLOCK_NOT_GRANTED:
		{
			// 300 The oplock request is denied.  ERROR_OPLOCK_NOT_GRANTED
			pString = "ERROR_OPLOCK_NOT_GRANTED";
			break;
		}

		case ERROR_INVALID_OPLOCK_PROTOCOL:
		{
			// 301 An invalid oplock acknowledgment was received by the system.  ERROR_INVALID_OPLOCK_PROTOCOL
			pString = "ERROR_INVALID_OPLOCK_PROTOCOL";
			break;
		}

		case ERROR_MR_MID_NOT_FOUND:
		{
			// 317 The system cannot find message text for message number 0x%1 in the message file for %2.  ERROR_MR_MID_NOT_FOUND
			pString = "ERROR_MR_MID_NOT_FOUND";
			break;
		}

		case ERROR_INVALID_ADDRESS:
		{
			// 487 Attempt to access invalid address.  ERROR_INVALID_ADDRESS
			pString = "ERROR_INVALID_ADDRESS";
			break;
		}

		case ERROR_ARITHMETIC_OVERFLOW:
		{
			// 534 Arithmetic result exceeded 32 bits.  ERROR_ARITHMETIC_OVERFLOW
			pString = "ERROR_ARITHMETIC_OVERFLOW";
			break;
		}

		case ERROR_PIPE_CONNECTED:
		{
			// 535 There is a process on other end of the pipe.  ERROR_PIPE_CONNECTED
			pString = "ERROR_PIPE_CONNECTED";
			break;
		}

		case ERROR_PIPE_LISTENING:
		{
			// 536 Waiting for a process to open the other end of the pipe.  ERROR_PIPE_LISTENING
			pString = "ERROR_PIPE_LISTENING";
			break;
		}

		case ERROR_EA_ACCESS_DENIED:
		{
			// 994 Access to the extended attribute was denied.  ERROR_EA_ACCESS_DENIED
			pString = "ERROR_EA_ACCESS_DENIED";
			break;
		}

		case ERROR_OPERATION_ABORTED:
		{
			// 995 The I/O operation has been aborted because of either a thread exit or an application request.  ERROR_OPERATION_ABORTED
			pString = "ERROR_OPERATION_ABORTED";
			break;
		}

		case ERROR_IO_INCOMPLETE:
		{
			// 996 Overlapped I/O event is not in a signaled state.  ERROR_IO_INCOMPLETE
			pString = "ERROR_IO_INCOMPLETE";
			break;
		}

		case ERROR_IO_PENDING:
		{
			// 997 Overlapped I/O operation is in progress.  ERROR_IO_PENDING
			pString = "ERROR_IO_PENDING";
			break;
		}

		case ERROR_NOACCESS:
		{
			// 998 Invalid access to memory location.  ERROR_NOACCESS
			pString = "ERROR_NOACCESS";
			break;
		}

		case ERROR_SWAPERROR:
		{
			// 999 Error performing inpage operation.  ERROR_SWAPERROR
			pString = "ERROR_SWAPERROR";
			break;
		}

		case ERROR_STACK_OVERFLOW:
		{
			// 1001 Recursion too deep; the stack overflowed.  ERROR_STACK_OVERFLOW
			pString = "ERROR_STACK_OVERFLOW";
			break;
		}

		case ERROR_INVALID_MESSAGE:
		{
			// 1002 The window cannot act on the sent message.  ERROR_INVALID_MESSAGE
			pString = "ERROR_INVALID_MESSAGE";
			break;
		}

		case ERROR_CAN_NOT_COMPLETE:
		{
			// 1003 Cannot complete this function.  ERROR_CAN_NOT_COMPLETE
			pString = "ERROR_CAN_NOT_COMPLETE";
			break;
		}

		case ERROR_INVALID_FLAGS:
		{
			// 1004 Invalid flags.  ERROR_INVALID_FLAGS
			pString = "ERROR_INVALID_FLAGS";
			break;
		}

		case ERROR_UNRECOGNIZED_VOLUME:
		{
			// 1005 The volume does not contain a recognized file system. Please make sure that all required file system drivers are loaded and that the volume is not corrupted.  ERROR_UNRECOGNIZED_VOLUME
			pString = "ERROR_UNRECOGNIZED_VOLUME";
			break;
		}

		case ERROR_FILE_INVALID:
		{
			// 1006 The volume for a file has been externally altered so that the opened file is no longer valid.  ERROR_FILE_INVALID
			pString = "ERROR_FILE_INVALID";
			break;
		}

		case ERROR_FULLSCREEN_MODE:
		{
			// 1007 The requested operation cannot be performed in full-screen mode.  ERROR_FULLSCREEN_MODE
			pString = "ERROR_FULLSCREEN_MODE";
			break;
		}

		case ERROR_NO_TOKEN:
		{
			// 1008 An attempt was made to reference a token that does not exist.  ERROR_NO_TOKEN
			pString = "ERROR_NO_TOKEN";
			break;
		}

		case ERROR_BADDB:
		{
			// 1009 The configuration registry database is corrupt.  ERROR_BADDB
			pString = "ERROR_BADDB";
			break;
		}

		case ERROR_BADKEY:
		{
			// 1010 The configuration registry key is invalid.  ERROR_BADKEY
			pString = "ERROR_BADKEY";
			break;
		}

		case ERROR_CANTOPEN:
		{
			// 1011 The configuration registry key could not be opened.  ERROR_CANTOPEN
			pString = "ERROR_CANTOPEN";
			break;
		}

		case ERROR_CANTREAD:
		{
			// 1012 The configuration registry key could not be read.  ERROR_CANTREAD
			pString = "ERROR_CANTREAD";
			break;
		}

		case ERROR_CANTWRITE:
		{
			// 1013 The configuration registry key could not be written.  ERROR_CANTWRITE
			pString = "ERROR_CANTWRITE";
			break;
		}

		case ERROR_REGISTRY_RECOVERED:
		{
			// 1014 One of the files in the registry database had to be recovered by use of a log or alternate copy. The recovery was successful.  ERROR_REGISTRY_RECOVERED
			pString = "ERROR_REGISTRY_RECOVERED";
			break;
		}

		case ERROR_REGISTRY_CORRUPT:
		{
			// 1015 The registry is corrupted. The structure of one of the files that contains registry data is corrupted, or the system's image of the file in memory is corrupted, or the file could not be recovered because the alternate copy or log was absent or corrupted.  ERROR_REGISTRY_CORRUPT
			pString = "ERROR_REGISTRY_CORRUPT";
			break;
		}

		case ERROR_REGISTRY_IO_FAILED:
		{
			// 1016 An I/O operation initiated by the registry failed unrecoverably. The registry could not read in, or write out, or flush, one of the files that contain the system's image of the registry.  ERROR_REGISTRY_IO_FAILED
			pString = "ERROR_REGISTRY_IO_FAILED";
			break;
		}

		case ERROR_NOT_REGISTRY_FILE:
		{
			// 1017 The system has attempted to load or restore a file into the registry, but the specified file is not in a registry file format.  ERROR_NOT_REGISTRY_FILE
			pString = "ERROR_NOT_REGISTRY_FILE";
			break;
		}

		case ERROR_KEY_DELETED:
		{
			// 1018 Illegal operation attempted on a registry key that has been marked for deletion.  ERROR_KEY_DELETED
			pString = "ERROR_KEY_DELETED";
			break;
		}

		case ERROR_NO_LOG_SPACE:
		{
			// 1019 System could not allocate the required space in a registry log.  ERROR_NO_LOG_SPACE
			pString = "ERROR_NO_LOG_SPACE";
			break;
		}

		case ERROR_KEY_HAS_CHILDREN:
		{
			// 1020 Cannot create a symbolic link in a registry key that already has subkeys or values.  ERROR_KEY_HAS_CHILDREN
			pString = "ERROR_KEY_HAS_CHILDREN";
			break;
		}

		case ERROR_CHILD_MUST_BE_VOLATILE:
		{
			// 1021 Cannot create a stable subkey under a volatile parent key.  ERROR_CHILD_MUST_BE_VOLATILE
			pString = "ERROR_CHILD_MUST_BE_VOLATILE";
			break;
		}

		case ERROR_NOTIFY_ENUM_DIR:
		{
			// 1022 A notify change request is being completed and the information is not being returned in the caller's buffer. The caller now needs to enumerate the files to find the changes.  ERROR_NOTIFY_ENUM_DIR
			pString = "ERROR_NOTIFY_ENUM_DIR";
			break;
		}

		case ERROR_DEPENDENT_SERVICES_RUNNING:
		{
			// 1051 A stop control has been sent to a service that other running services are dependent on.  ERROR_DEPENDENT_SERVICES_RUNNING
			pString = "ERROR_DEPENDENT_SERVICES_RUNNING";
			break;
		}

		case ERROR_INVALID_SERVICE_CONTROL:
		{
			// 1052 The requested control is not valid for this service.  ERROR_INVALID_SERVICE_CONTROL
			pString = "ERROR_INVALID_SERVICE_CONTROL";
			break;
		}

		case ERROR_SERVICE_REQUEST_TIMEOUT:
		{
			// 1053 The service did not respond to the start or control request in a timely fashion.  ERROR_SERVICE_REQUEST_TIMEOUT
			pString = "ERROR_SERVICE_REQUEST_TIMEOUT";
			break;
		}

		case ERROR_SERVICE_NO_THREAD:
		{
			// 1054 A thread could not be created for the service.  ERROR_SERVICE_NO_THREAD
			pString = "ERROR_SERVICE_NO_THREAD";
			break;
		}

		case ERROR_SERVICE_DATABASE_LOCKED:
		{
			// 1055 The service database is locked.  ERROR_SERVICE_DATABASE_LOCKED
			pString = "ERROR_SERVICE_DATABASE_LOCKED";
			break;
		}

		case ERROR_SERVICE_ALREADY_RUNNING:
		{
			// 1056 An instance of the service is already running.  ERROR_SERVICE_ALREADY_RUNNING
			pString = "ERROR_SERVICE_ALREADY_RUNNING";
			break;
		}

		case ERROR_INVALID_SERVICE_ACCOUNT:
		{
			// 1057 The account name is invalid or does not exist.  ERROR_INVALID_SERVICE_ACCOUNT
			pString = "ERROR_INVALID_SERVICE_ACCOUNT";
			break;
		}

		case ERROR_SERVICE_DISABLED:
		{
			// 1058 The service cannot be started, either because it is disabled or because it has no enabled devices associated with it.  ERROR_SERVICE_DISABLED
			pString = "ERROR_SERVICE_DISABLED";
			break;
		}

		case ERROR_CIRCULAR_DEPENDENCY:
		{
			// 1059 Circular service dependency was specified.  ERROR_CIRCULAR_DEPENDENCY
			pString = "ERROR_CIRCULAR_DEPENDENCY";
			break;
		}

		case ERROR_SERVICE_DOES_NOT_EXIST:
		{
			// 1060 The specified service does not exist as an installed service.  ERROR_SERVICE_DOES_NOT_EXIST
			pString = "ERROR_SERVICE_DOES_NOT_EXIST";
			break;
		}

		case ERROR_SERVICE_CANNOT_ACCEPT_CTRL:
		{
			// 1061 The service cannot accept control messages at this time.  ERROR_SERVICE_CANNOT_ACCEPT_CTRL
			pString = "ERROR_SERVICE_CANNOT_ACCEPT_CTRL";
			break;
		}

		case ERROR_SERVICE_NOT_ACTIVE:
		{
			// 1062 The service has not been started.  ERROR_SERVICE_NOT_ACTIVE
			pString = "ERROR_SERVICE_NOT_ACTIVE";
			break;
		}

		case ERROR_FAILED_SERVICE_CONTROLLER_CONNECT:
		{
			// 1063 The service process could not connect to the service controller.  ERROR_FAILED_SERVICE_CONTROLLER_CONNECT
			pString = "ERROR_FAILED_SERVICE_CONTROLLER_CONNECT";
			break;
		}

		case ERROR_EXCEPTION_IN_SERVICE:
		{
			// 1064 An exception occurred in the service when handling the control request.  ERROR_EXCEPTION_IN_SERVICE
			pString = "ERROR_EXCEPTION_IN_SERVICE";
			break;
		}

		case ERROR_DATABASE_DOES_NOT_EXIST:
		{
			// 1065 The database specified does not exist.  ERROR_DATABASE_DOES_NOT_EXIST
			pString = "ERROR_DATABASE_DOES_NOT_EXIST";
			break;
		}

		case ERROR_SERVICE_SPECIFIC_ERROR:
		{
			// 1066 The service has returned a service-specific error code.  ERROR_SERVICE_SPECIFIC_ERROR
			pString = "ERROR_SERVICE_SPECIFIC_ERROR";
			break;
		}

		case ERROR_PROCESS_ABORTED:
		{
			// 1067 The process terminated unexpectedly.  ERROR_PROCESS_ABORTED
			pString = "ERROR_PROCESS_ABORTED";
			break;
		}

		case ERROR_SERVICE_DEPENDENCY_FAIL:
		{
			// 1068 The dependency service or group failed to start.  ERROR_SERVICE_DEPENDENCY_FAIL
			pString = "ERROR_SERVICE_DEPENDENCY_FAIL";
			break;
		}

		case ERROR_SERVICE_LOGON_FAILED:
		{
			// 1069 The service did not start due to a logon failure.  ERROR_SERVICE_LOGON_FAILED
			pString = "ERROR_SERVICE_LOGON_FAILED";
			break;
		}

		case ERROR_SERVICE_START_HANG:
		{
			// 1070 After starting, the service hung in a start-pending state.  ERROR_SERVICE_START_HANG
			pString = "ERROR_SERVICE_START_HANG";
			break;
		}

		case ERROR_INVALID_SERVICE_LOCK:
		{
			// 1071 The specified service database lock is invalid.  ERROR_INVALID_SERVICE_LOCK
			pString = "ERROR_INVALID_SERVICE_LOCK";
			break;
		}

		case ERROR_SERVICE_MARKED_FOR_DELETE:
		{
			// 1072 The specified service has been marked for deletion.  ERROR_SERVICE_MARKED_FOR_DELETE
			pString = "ERROR_SERVICE_MARKED_FOR_DELETE";
			break;
		}

		case ERROR_SERVICE_EXISTS:
		{
			// 1073 The specified service already exists.  ERROR_SERVICE_EXISTS
			pString = "ERROR_SERVICE_EXISTS";
			break;
		}

		case ERROR_ALREADY_RUNNING_LKG:
		{
			// 1074 The system is currently running with the last-known-good configuration.  ERROR_ALREADY_RUNNING_LKG
			pString = "ERROR_ALREADY_RUNNING_LKG";
			break;
		}

		case ERROR_SERVICE_DEPENDENCY_DELETED:
		{
			// 1075 The dependency service does not exist or has been marked for deletion.  ERROR_SERVICE_DEPENDENCY_DELETED
			pString = "ERROR_SERVICE_DEPENDENCY_DELETED";
			break;
		}

		case ERROR_BOOT_ALREADY_ACCEPTED:
		{
			// 1076 The current boot has already been accepted for use as the last-known-good control set.  ERROR_BOOT_ALREADY_ACCEPTED
			pString = "ERROR_BOOT_ALREADY_ACCEPTED";
			break;
		}

		case ERROR_SERVICE_NEVER_STARTED:
		{
			// 1077 No attempts to start the service have been made since the last boot.  ERROR_SERVICE_NEVER_STARTED
			pString = "ERROR_SERVICE_NEVER_STARTED";
			break;
		}

		case ERROR_DUPLICATE_SERVICE_NAME:
		{
			// 1078 The name is already in use as either a service name or a service display name.  ERROR_DUPLICATE_SERVICE_NAME
			pString = "ERROR_DUPLICATE_SERVICE_NAME";
			break;
		}

		case ERROR_DIFFERENT_SERVICE_ACCOUNT:
		{
			// 1079 The account specified for this service is different from the account specified for other services running in the same process.  ERROR_DIFFERENT_SERVICE_ACCOUNT
			pString = "ERROR_DIFFERENT_SERVICE_ACCOUNT";
			break;
		}

		case ERROR_CANNOT_DETECT_DRIVER_FAILURE:
		{
			// 1080 Failure actions can only be set for Win32 services, not for drivers.  ERROR_CANNOT_DETECT_DRIVER_FAILURE
			pString = "ERROR_CANNOT_DETECT_DRIVER_FAILURE";
			break;
		}

		case ERROR_CANNOT_DETECT_PROCESS_ABORT:
		{
			// 1081 This service runs in the same process as the service control manager. Therefore, the service control manager cannot take action if this service's process terminates unexpectedly.  ERROR_CANNOT_DETECT_PROCESS_ABORT
			pString = "ERROR_CANNOT_DETECT_PROCESS_ABORT";
			break;
		}

		case ERROR_NO_RECOVERY_PROGRAM:
		{
			// 1082 No recovery program has been configured for this service.  ERROR_NO_RECOVERY_PROGRAM
			pString = "ERROR_NO_RECOVERY_PROGRAM";
			break;
		}

		case ERROR_END_OF_MEDIA:
		{
			// 1100 The physical end of the tape has been reached.  ERROR_END_OF_MEDIA
			pString = "ERROR_END_OF_MEDIA";
			break;
		}

		case ERROR_FILEMARK_DETECTED:
		{
			// 1101 A tape access reached a filemark.  ERROR_FILEMARK_DETECTED
			pString = "ERROR_FILEMARK_DETECTED";
			break;
		}

		case ERROR_BEGINNING_OF_MEDIA:
		{
			// 1102 The beginning of the tape or a partition was encountered.  ERROR_BEGINNING_OF_MEDIA
			pString = "ERROR_BEGINNING_OF_MEDIA";
			break;
		}

		case ERROR_SETMARK_DETECTED:
		{
			// 1103 A tape access reached the end of a set of files.  ERROR_SETMARK_DETECTED
			pString = "ERROR_SETMARK_DETECTED";
			break;
		}

		case ERROR_NO_DATA_DETECTED:
		{
			// 1104 No more data is on the tape.  ERROR_NO_DATA_DETECTED
			pString = "ERROR_NO_DATA_DETECTED";
			break;
		}

		case ERROR_PARTITION_FAILURE:
		{
			// 1105 Tape could not be partitioned.  ERROR_PARTITION_FAILURE
			pString = "ERROR_PARTITION_FAILURE";
			break;
		}

		case ERROR_INVALID_BLOCK_LENGTH:
		{
			// 1106 When accessing a new tape of a multivolume partition, the current blocksize is incorrect.  ERROR_INVALID_BLOCK_LENGTH
			pString = "ERROR_INVALID_BLOCK_LENGTH";
			break;
		}

		case ERROR_DEVICE_NOT_PARTITIONED:
		{
			// 1107 Tape partition information could not be found when loading a tape.  ERROR_DEVICE_NOT_PARTITIONED
			pString = "ERROR_DEVICE_NOT_PARTITIONED";
			break;
		}

		case ERROR_UNABLE_TO_LOCK_MEDIA:
		{
			// 1108 Unable to lock the media eject mechanism.  ERROR_UNABLE_TO_LOCK_MEDIA
			pString = "ERROR_UNABLE_TO_LOCK_MEDIA";
			break;
		}

		case ERROR_UNABLE_TO_UNLOAD_MEDIA:
		{
			// 1109 Unable to unload the media.  ERROR_UNABLE_TO_UNLOAD_MEDIA
			pString = "ERROR_UNABLE_TO_UNLOAD_MEDIA";
			break;
		}

		case ERROR_MEDIA_CHANGED:
		{
			// 1110 The media in the drive may have changed.  ERROR_MEDIA_CHANGED
			pString = "ERROR_MEDIA_CHANGED";
			break;
		}

		case ERROR_BUS_RESET:
		{
			// 1111 The I/O bus was reset.  ERROR_BUS_RESET
			pString = "ERROR_BUS_RESET";
			break;
		}

		case ERROR_NO_MEDIA_IN_DRIVE:
		{
			// 1112 No media in drive.  ERROR_NO_MEDIA_IN_DRIVE
			pString = "ERROR_NO_MEDIA_IN_DRIVE";
			break;
		}

		case ERROR_NO_UNICODE_TRANSLATION:
		{
			// 1113 No mapping for the Unicode character exists in the target multi-byte code page.  ERROR_NO_UNICODE_TRANSLATION
			pString = "ERROR_NO_UNICODE_TRANSLATION";
			break;
		}

		case ERROR_DLL_INIT_FAILED:
		{
			// 1114 A dynamic link library (DLL) initialization routine failed.  ERROR_DLL_INIT_FAILED
			pString = "ERROR_DLL_INIT_FAILED";
			break;
		}

		case ERROR_SHUTDOWN_IN_PROGRESS:
		{
			// 1115 A system shutdown is in progress.  ERROR_SHUTDOWN_IN_PROGRESS
			pString = "ERROR_SHUTDOWN_IN_PROGRESS";
			break;
		}

		case ERROR_NO_SHUTDOWN_IN_PROGRESS:
		{
			// 1116 Unable to abort the system shutdown because no shutdown was in progress.  ERROR_NO_SHUTDOWN_IN_PROGRESS
			pString = "ERROR_NO_SHUTDOWN_IN_PROGRESS";
			break;
		}

		case ERROR_IO_DEVICE:
		{
			// 1117 The request could not be performed because of an I/O device error.  ERROR_IO_DEVICE
			pString = "ERROR_IO_DEVICE";
			break;
		}

		case ERROR_SERIAL_NO_DEVICE:
		{
			// 1118 No serial device was successfully initialized. The serial driver will unload.  ERROR_SERIAL_NO_DEVICE
			pString = "ERROR_SERIAL_NO_DEVICE";
			break;
		}

		case ERROR_IRQ_BUSY:
		{
			// 1119 Unable to open a device that was sharing an interrupt request (IRQ) with other devices. At least one other device that uses that IRQ was already opened.  ERROR_IRQ_BUSY
			pString = "ERROR_IRQ_BUSY";
			break;
		}

		case ERROR_MORE_WRITES:
		{
			// 1120 A serial I/O operation was completed by another write to the serial port. The IOCTL_SERIAL_XOFF_COUNTER reached zero.)  ERROR_MORE_WRITES
			pString = "ERROR_MORE_WRITES";
			break;
		}

		case ERROR_COUNTER_TIMEOUT:
		{
			// 1121 A serial I/O operation completed because the timeout period expired. The IOCTL_SERIAL_XOFF_COUNTER did not reach zero.)  ERROR_COUNTER_TIMEOUT
			pString = "ERROR_COUNTER_TIMEOUT";
			break;
		}

		case ERROR_FLOPPY_ID_MARK_NOT_FOUND:
		{
			// 1122 No ID address mark was found on the floppy disk.  ERROR_FLOPPY_ID_MARK_NOT_FOUND
			pString = "ERROR_FLOPPY_ID_MARK_NOT_FOUND";
			break;
		}

		case ERROR_FLOPPY_WRONG_CYLINDER:
		{
			// 1123 Mismatch between the floppy disk sector ID field and the floppy disk controller track address.  ERROR_FLOPPY_WRONG_CYLINDER
			pString = "ERROR_FLOPPY_WRONG_CYLINDER";
			break;
		}

		case ERROR_FLOPPY_UNKNOWN_ERROR:
		{
			// 1124 The floppy disk controller reported an error that is not recognized by the floppy disk driver.  ERROR_FLOPPY_UNKNOWN_ERROR
			pString = "ERROR_FLOPPY_UNKNOWN_ERROR";
			break;
		}

		case ERROR_FLOPPY_BAD_REGISTERS:
		{
			// 1125 The floppy disk controller returned inconsistent results in its registers.  ERROR_FLOPPY_BAD_REGISTERS
			pString = "ERROR_FLOPPY_BAD_REGISTERS";
			break;
		}

		case ERROR_DISK_RECALIBRATE_FAILED:
		{
			// 1126 While accessing the hard disk, a recalibrate operation failed, even after retries.  ERROR_DISK_RECALIBRATE_FAILED
			pString = "ERROR_DISK_RECALIBRATE_FAILED";
			break;
		}

		case ERROR_DISK_OPERATION_FAILED:
		{
			// 1127 While accessing the hard disk, a disk operation failed even after retries.  ERROR_DISK_OPERATION_FAILED
			pString = "ERROR_DISK_OPERATION_FAILED";
			break;
		}

		case ERROR_DISK_RESET_FAILED:
		{
			// 1128 While accessing the hard disk, a disk controller reset was needed, but even that failed.  ERROR_DISK_RESET_FAILED
			pString = "ERROR_DISK_RESET_FAILED";
			break;
		}

		case ERROR_EOM_OVERFLOW:
		{
			// 1129 Physical end of tape encountered.  ERROR_EOM_OVERFLOW
			pString = "ERROR_EOM_OVERFLOW";
			break;
		}

		case ERROR_NOT_ENOUGH_SERVER_MEMORY:
		{
			// 1130 Not enough server storage is available to process this command.  ERROR_NOT_ENOUGH_SERVER_MEMORY
			pString = "ERROR_NOT_ENOUGH_SERVER_MEMORY";
			break;
		}

		case ERROR_POSSIBLE_DEADLOCK:
		{
			// 1131 A potential deadlock condition has been detected.  ERROR_POSSIBLE_DEADLOCK
			pString = "ERROR_POSSIBLE_DEADLOCK";
			break;
		}

		case ERROR_MAPPED_ALIGNMENT:
		{
			// 1132 The base address or the file offset specified does not have the proper alignment.  ERROR_MAPPED_ALIGNMENT
			pString = "ERROR_MAPPED_ALIGNMENT";
			break;
		}

		case ERROR_SET_POWER_STATE_VETOED:
		{
			// 1140 An attempt to change the system power state was vetoed by another application or driver.  ERROR_SET_POWER_STATE_VETOED
			pString = "ERROR_SET_POWER_STATE_VETOED";
			break;
		}

		case ERROR_SET_POWER_STATE_FAILED:
		{
			// 1141 The system BIOS failed an attempt to change the system power state.  ERROR_SET_POWER_STATE_FAILED
			pString = "ERROR_SET_POWER_STATE_FAILED";
			break;
		}

		case ERROR_TOO_MANY_LINKS:
		{
			// 1142 An attempt was made to create more links on a file than the file system supports.  ERROR_TOO_MANY_LINKS
			pString = "ERROR_TOO_MANY_LINKS";
			break;
		}

		case ERROR_OLD_WIN_VERSION:
		{
			// 1150 The specified program requires a newer version of Windows.  ERROR_OLD_WIN_VERSION
			pString = "ERROR_OLD_WIN_VERSION";
			break;
		}

		case ERROR_APP_WRONG_OS:
		{
			// 1151 The specified program is not a Windows or MS-DOS program.  ERROR_APP_WRONG_OS
			pString = "ERROR_APP_WRONG_OS";
			break;
		}

		case ERROR_SINGLE_INSTANCE_APP:
		{
			// 1152 Cannot start more than one instance of the specified program.  ERROR_SINGLE_INSTANCE_APP
			pString = "ERROR_SINGLE_INSTANCE_APP";
			break;
		}

		case ERROR_RMODE_APP:
		{
			// 1153 The specified program was written for an earlier version of Windows.  ERROR_RMODE_APP
			pString = "ERROR_RMODE_APP";
			break;
		}

		case ERROR_INVALID_DLL:
		{
			// 1154 One of the library files needed to run this application is damaged.  ERROR_INVALID_DLL
			pString = "ERROR_INVALID_DLL";
			break;
		}

		case ERROR_NO_ASSOCIATION:
		{
			// 1155 No application is associated with the specified file for this operation.  ERROR_NO_ASSOCIATION
			pString = "ERROR_NO_ASSOCIATION";
			break;
		}

		case ERROR_DDE_FAIL:
		{
			// 1156 An error occurred in sending the command to the application.  ERROR_DDE_FAIL
			pString = "ERROR_DDE_FAIL";
			break;
		}

		case ERROR_DLL_NOT_FOUND:
		{
			// 1157 One of the library files needed to run this application cannot be found.  ERROR_DLL_NOT_FOUND
			pString = "ERROR_DLL_NOT_FOUND";
			break;
		}

		case ERROR_NO_MORE_USER_HANDLES:
		{
			// 1158 The current process has used all of its system allowance of handles for Window Manager objects.  ERROR_NO_MORE_USER_HANDLES
			pString = "ERROR_NO_MORE_USER_HANDLES";
			break;
		}

		case ERROR_MESSAGE_SYNC_ONLY:
		{
			// 1159 The message can be used only with synchronous operations.  ERROR_MESSAGE_SYNC_ONLY
			pString = "ERROR_MESSAGE_SYNC_ONLY";
			break;
		}

		case ERROR_SOURCE_ELEMENT_EMPTY:
		{
			// 1160 The indicated source element has no media.  ERROR_SOURCE_ELEMENT_EMPTY
			pString = "ERROR_SOURCE_ELEMENT_EMPTY";
			break;
		}

		case ERROR_DESTINATION_ELEMENT_FULL:
		{
			// 1161 The indicated destination element already contains media.  ERROR_DESTINATION_ELEMENT_FULL
			pString = "ERROR_DESTINATION_ELEMENT_FULL";
			break;
		}

		case ERROR_ILLEGAL_ELEMENT_ADDRESS:
		{
			// 1162 The indicated element does not exist.  ERROR_ILLEGAL_ELEMENT_ADDRESS
			pString = "ERROR_ILLEGAL_ELEMENT_ADDRESS";
			break;
		}

		case ERROR_MAGAZINE_NOT_PRESENT:
		{
			// 1163 The indicated element is part of a magazine that is not present.  ERROR_MAGAZINE_NOT_PRESENT
			pString = "ERROR_MAGAZINE_NOT_PRESENT";
			break;
		}

		case ERROR_DEVICE_REINITIALIZATION_NEEDED:
		{
			// 1164 The indicated device requires reinitialization due to hardware errors.  ERROR_DEVICE_REINITIALIZATION_NEEDED
			pString = "ERROR_DEVICE_REINITIALIZATION_NEEDED";
			break;
		}

		case ERROR_DEVICE_REQUIRES_CLEANING:
		{
			// 1165 The device has indicated that cleaning is required before further operations are attempted.  ERROR_DEVICE_REQUIRES_CLEANING
			pString = "ERROR_DEVICE_REQUIRES_CLEANING";
			break;
		}

		case ERROR_DEVICE_DOOR_OPEN:
		{
			// 1166 The device has indicated that its door is open.  ERROR_DEVICE_DOOR_OPEN
			pString = "ERROR_DEVICE_DOOR_OPEN";
			break;
		}

		case ERROR_DEVICE_NOT_CONNECTED:
		{
			// 1167 The device is not connected.  ERROR_DEVICE_NOT_CONNECTED
			pString = "ERROR_DEVICE_NOT_CONNECTED";
			break;
		}

		case ERROR_NOT_FOUND:
		{
			// 1168 Element not found.  ERROR_NOT_FOUND
			pString = "ERROR_NOT_FOUND";
			break;
		}

		case ERROR_NO_MATCH:
		{
			// 1169 There was no match for the specified key in the index.  ERROR_NO_MATCH
			pString = "ERROR_NO_MATCH";
			break;
		}

		case ERROR_SET_NOT_FOUND:
		{
			// 1170 The property set specified does not exist on the object.  ERROR_SET_NOT_FOUND
			pString = "ERROR_SET_NOT_FOUND";
			break;
		}

		case ERROR_POINT_NOT_FOUND:
		{
			// 1171 The point passed to GetMouseMovePoints is not in the buffer.  ERROR_POINT_NOT_FOUND
			pString = "ERROR_POINT_NOT_FOUND";
			break;
		}

		case ERROR_NO_TRACKING_SERVICE:
		{
			// 1172 The tracking (workstation) service is not running.  ERROR_NO_TRACKING_SERVICE
			pString = "ERROR_NO_TRACKING_SERVICE";
			break;
		}

		case ERROR_NO_VOLUME_ID:
		{
			// 1173 The Volume ID could not be found.  ERROR_NO_VOLUME_ID
			pString = "ERROR_NO_VOLUME_ID";
			break;
		}

		case ERROR_BAD_DEVICE:
		{
			// 1200 The specified device name is invalid.  ERROR_BAD_DEVICE
			pString = "ERROR_BAD_DEVICE";
			break;
		}

		case ERROR_CONNECTION_UNAVAIL:
		{
			// 1201 The device is not currently connected but it is a remembered connection.  ERROR_CONNECTION_UNAVAIL
			pString = "ERROR_CONNECTION_UNAVAIL";
			break;
		}

		case ERROR_DEVICE_ALREADY_REMEMBERED:
		{
			// 1202 An attempt was made to remember a device that had previously been remembered.  ERROR_DEVICE_ALREADY_REMEMBERED
			pString = "ERROR_DEVICE_ALREADY_REMEMBERED";
			break;
		}

		case ERROR_NO_NET_OR_BAD_PATH:
		{
			// 1203 No network provider accepted the given network path.  ERROR_NO_NET_OR_BAD_PATH
			pString = "ERROR_NO_NET_OR_BAD_PATH";
			break;
		}

		case ERROR_BAD_PROVIDER:
		{
			// 1204 The specified network provider name is invalid.  ERROR_BAD_PROVIDER
			pString = "ERROR_BAD_PROVIDER";
			break;
		}

		case ERROR_CANNOT_OPEN_PROFILE:
		{
			// 1205 Unable to open the network connection profile.  ERROR_CANNOT_OPEN_PROFILE
			pString = "ERROR_CANNOT_OPEN_PROFILE";
			break;
		}

		case ERROR_BAD_PROFILE:
		{
			// 1206 The network connection profile is corrupted.  ERROR_BAD_PROFILE
			pString = "ERROR_BAD_PROFILE";
			break;
		}

		case ERROR_NOT_CONTAINER:
		{
			// 1207 Cannot enumerate a noncontainer.  ERROR_NOT_CONTAINER
			pString = "ERROR_NOT_CONTAINER";
			break;
		}

		case ERROR_EXTENDED_ERROR:
		{
			// 1208 An extended error has occurred.  ERROR_EXTENDED_ERROR
			pString = "ERROR_EXTENDED_ERROR";
			break;
		}

		case ERROR_INVALID_GROUPNAME:
		{
			// 1209 The format of the specified group name is invalid.  ERROR_INVALID_GROUPNAME
			pString = "ERROR_INVALID_GROUPNAME";
			break;
		}

		case ERROR_INVALID_COMPUTERNAME:
		{
			// 1210 The format of the specified computer name is invalid.  ERROR_INVALID_COMPUTERNAME
			pString = "ERROR_INVALID_COMPUTERNAME";
			break;
		}

		case ERROR_INVALID_EVENTNAME:
		{
			// 1211 The format of the specified event name is invalid.  ERROR_INVALID_EVENTNAME
			pString = "ERROR_INVALID_EVENTNAME";
			break;
		}

		case ERROR_INVALID_DOMAINNAME:
		{
			// 1212 The format of the specified domain name is invalid.  ERROR_INVALID_DOMAINNAME
			pString = "ERROR_INVALID_DOMAINNAME";
			break;
		}

		case ERROR_INVALID_SERVICENAME:
		{
			// 1213 The format of the specified service name is invalid.  ERROR_INVALID_SERVICENAME
			pString = "ERROR_INVALID_SERVICENAME";
			break;
		}

		case ERROR_INVALID_NETNAME:
		{
			// 1214 The format of the specified network name is invalid.  ERROR_INVALID_NETNAME
			pString = "ERROR_INVALID_NETNAME";
			break;
		}

		case ERROR_INVALID_SHARENAME:
		{
			// 1215 The format of the specified share name is invalid.  ERROR_INVALID_SHARENAME
			pString = "ERROR_INVALID_SHARENAME";
			break;
		}

		case ERROR_INVALID_PASSWORDNAME:
		{
			// 1216 The format of the specified password is invalid.  ERROR_INVALID_PASSWORDNAME
			pString = "ERROR_INVALID_PASSWORDNAME";
			break;
		}

		case ERROR_INVALID_MESSAGENAME:
		{
			// 1217 The format of the specified message name is invalid.  ERROR_INVALID_MESSAGENAME
			pString = "ERROR_INVALID_MESSAGENAME";
			break;
		}

		case ERROR_INVALID_MESSAGEDEST:
		{
			// 1218 The format of the specified message destination is invalid.  ERROR_INVALID_MESSAGEDEST
			pString = "ERROR_INVALID_MESSAGEDEST";
			break;
		}

		case ERROR_SESSION_CREDENTIAL_CONFLICT:
		{
			// 1219 The credentials supplied conflict with an existing set of credentials.  ERROR_SESSION_CREDENTIAL_CONFLICT
			pString = "ERROR_SESSION_CREDENTIAL_CONFLICT";
			break;
		}

		case ERROR_REMOTE_SESSION_LIMIT_EXCEEDED:
		{
			// 1220 An attempt was made to establish a session to a network server, but there are already too many sessions established to that server.  ERROR_REMOTE_SESSION_LIMIT_EXCEEDED
			pString = "ERROR_REMOTE_SESSION_LIMIT_EXCEEDED";
			break;
		}

		case ERROR_DUP_DOMAINNAME:
		{
			// 1221 The workgroup or domain name is already in use by another computer on the network.  ERROR_DUP_DOMAINNAME
			pString = "ERROR_DUP_DOMAINNAME";
			break;
		}

		case ERROR_NO_NETWORK:
		{
			// 1222 The network is not present or not started.  ERROR_NO_NETWORK
			pString = "ERROR_NO_NETWORK";
			break;
		}

		case ERROR_CANCELLED:
		{
			// 1223 The operation was canceled by the user.  ERROR_CANCELLED
			pString = "ERROR_CANCELLED";
			break;
		}

		case ERROR_USER_MAPPED_FILE:
		{
			// 1224 The requested operation cannot be performed on a file with a user-mapped section open.  ERROR_USER_MAPPED_FILE
			pString = "ERROR_USER_MAPPED_FILE";
			break;
		}

		case ERROR_CONNECTION_REFUSED:
		{
			// 1225 The remote system refused the network connection.  ERROR_CONNECTION_REFUSED
			pString = "ERROR_CONNECTION_REFUSED";
			break;
		}

		case ERROR_GRACEFUL_DISCONNECT:
		{
			// 1226 The network connection was gracefully closed.  ERROR_GRACEFUL_DISCONNECT
			pString = "ERROR_GRACEFUL_DISCONNECT";
			break;
		}

		case ERROR_ADDRESS_ALREADY_ASSOCIATED:
		{
			// 1227 The network transport endpoint already has an address associated with it.  ERROR_ADDRESS_ALREADY_ASSOCIATED
			pString = "ERROR_ADDRESS_ALREADY_ASSOCIATED";
			break;
		}

		case ERROR_ADDRESS_NOT_ASSOCIATED:
		{
			// 1228 An address has not yet been associated with the network endpoint.  ERROR_ADDRESS_NOT_ASSOCIATED
			pString = "ERROR_ADDRESS_NOT_ASSOCIATED";
			break;
		}

		case ERROR_CONNECTION_INVALID:
		{
			// 1229 An operation was attempted on a nonexistent network connection.  ERROR_CONNECTION_INVALID
			pString = "ERROR_CONNECTION_INVALID";
			break;
		}

		case ERROR_CONNECTION_ACTIVE:
		{
			// 1230 An invalid operation was attempted on an active network connection.  ERROR_CONNECTION_ACTIVE
			pString = "ERROR_CONNECTION_ACTIVE";
			break;
		}

		case ERROR_NETWORK_UNREACHABLE:
		{
			// 1231 The remote network is not reachable by the transport.  ERROR_NETWORK_UNREACHABLE
			pString = "ERROR_NETWORK_UNREACHABLE";
			break;
		}

		case ERROR_HOST_UNREACHABLE:
		{
			// 1232 The remote system is not reachable by the transport.  ERROR_HOST_UNREACHABLE
			pString = "ERROR_HOST_UNREACHABLE";
			break;
		}

		case ERROR_PROTOCOL_UNREACHABLE:
		{
			// 1233 The remote system does not support the transport protocol.  ERROR_PROTOCOL_UNREACHABLE
			pString = "ERROR_PROTOCOL_UNREACHABLE";
			break;
		}

		case ERROR_PORT_UNREACHABLE:
		{
			// 1234 No service is operating at the destination network endpoint on the remote system.  ERROR_PORT_UNREACHABLE
			pString = "ERROR_PORT_UNREACHABLE";
			break;
		}

		case ERROR_REQUEST_ABORTED:
		{
			// 1235 The request was aborted.  ERROR_REQUEST_ABORTED
			pString = "ERROR_REQUEST_ABORTED";
			break;
		}

		case ERROR_CONNECTION_ABORTED:
		{
			// 1236 The network connection was aborted by the local system.  ERROR_CONNECTION_ABORTED
			pString = "ERROR_CONNECTION_ABORTED";
			break;
		}

		case ERROR_RETRY:
		{
			// 1237 The operation could not be completed. A retry should be performed.  ERROR_RETRY
			pString = "ERROR_RETRY";
			break;
		}

		case ERROR_CONNECTION_COUNT_LIMIT:
		{
			// 1238 A connection to the server could not be made because the limit on the number of concurrent connections for this account has been reached.  ERROR_CONNECTION_COUNT_LIMIT
			pString = "ERROR_CONNECTION_COUNT_LIMIT";
			break;
		}

		case ERROR_LOGIN_TIME_RESTRICTION:
		{
			// 1239 Attempting to log in during an unauthorized time of day for this account.  ERROR_LOGIN_TIME_RESTRICTION
			pString = "ERROR_LOGIN_TIME_RESTRICTION";
			break;
		}

		case ERROR_LOGIN_WKSTA_RESTRICTION:
		{
			// 1240 The account is not authorized to log in from this station.  ERROR_LOGIN_WKSTA_RESTRICTION
			pString = "ERROR_LOGIN_WKSTA_RESTRICTION";
			break;
		}

		case ERROR_INCORRECT_ADDRESS:
		{
			// 1241 The network address could not be used for the operation requested.  ERROR_INCORRECT_ADDRESS
			pString = "ERROR_INCORRECT_ADDRESS";
			break;
		}

		case ERROR_ALREADY_REGISTERED:
		{
			// 1242 The service is already registered.  ERROR_ALREADY_REGISTERED
			pString = "ERROR_ALREADY_REGISTERED";
			break;
		}

		case ERROR_SERVICE_NOT_FOUND:
		{
			// 1243 The specified service does not exist.  ERROR_SERVICE_NOT_FOUND
			pString = "ERROR_SERVICE_NOT_FOUND";
			break;
		}

		case ERROR_NOT_AUTHENTICATED:
		{
			// 1244 The operation being requested was not performed because the user has not been authenticated.  ERROR_NOT_AUTHENTICATED
			pString = "ERROR_NOT_AUTHENTICATED";
			break;
		}

		case ERROR_NOT_LOGGED_ON:
		{
			// 1245 The operation being requested was not performed because the user has not logged on to the network. The specified service does not exist.  ERROR_NOT_LOGGED_ON
			pString = "ERROR_NOT_LOGGED_ON";
			break;
		}

		case ERROR_CONTINUE:
		{
			// 1246 Continue with work in progress.  ERROR_CONTINUE
			pString = "ERROR_CONTINUE";
			break;
		}

		case ERROR_ALREADY_INITIALIZED:
		{
			// 1247 An attempt was made to perform an initialization operation when initialization has already been completed.  ERROR_ALREADY_INITIALIZED
			pString = "ERROR_ALREADY_INITIALIZED";
			break;
		}

		case ERROR_NO_MORE_DEVICES:
		{
			// 1248 No more local devices.  ERROR_NO_MORE_DEVICES
			pString = "ERROR_NO_MORE_DEVICES";
			break;
		}

		case ERROR_NO_SUCH_SITE:
		{
			// 1249 The specified site does not exist.  ERROR_NO_SUCH_SITE
			pString = "ERROR_NO_SUCH_SITE";
			break;
		}

		case ERROR_DOMAIN_CONTROLLER_EXISTS:
		{
			// 1250 A domain controller with the specified name already exists.  ERROR_DOMAIN_CONTROLLER_EXISTS
			pString = "ERROR_DOMAIN_CONTROLLER_EXISTS";
			break;
		}

		case ERROR_DS_NOT_INSTALLED:
		{
			// 1251 An error occurred while installing the Windows NT directory service. Please view the event log for more information.  ERROR_DS_NOT_INSTALLED
			pString = "ERROR_DS_NOT_INSTALLED";
			break;
		}

		case ERROR_NOT_ALL_ASSIGNED:
		{
			// 1300 Not all privileges referenced are assigned to the caller.  ERROR_NOT_ALL_ASSIGNED
			pString = "ERROR_NOT_ALL_ASSIGNED";
			break;
		}

		case ERROR_SOME_NOT_MAPPED:
		{
			// 1301 Some mapping between account names and security IDs was not done.  ERROR_SOME_NOT_MAPPED
			pString = "ERROR_SOME_NOT_MAPPED";
			break;
		}

		case ERROR_NO_QUOTAS_FOR_ACCOUNT:
		{
			// 1302 No system quota limits are specifically set for this account.  ERROR_NO_QUOTAS_FOR_ACCOUNT
			pString = "ERROR_NO_QUOTAS_FOR_ACCOUNT";
			break;
		}

		case ERROR_LOCAL_USER_SESSION_KEY:
		{
			// 1303 No encryption key is available. A well-known encryption key was returned.  ERROR_LOCAL_USER_SESSION_KEY
			pString = "ERROR_LOCAL_USER_SESSION_KEY";
			break;
		}

		case ERROR_NULL_LM_PASSWORD:
		{
			// 1304 The Windows NT password is too complex to be converted to a LAN Manager password. The LAN Manager password returned is a NULL string.  ERROR_NULL_LM_PASSWORD
			pString = "ERROR_NULL_LM_PASSWORD";
			break;
		}

		case ERROR_UNKNOWN_REVISION:
		{
			// 1305 The revision level is unknown.  ERROR_UNKNOWN_REVISION
			pString = "ERROR_UNKNOWN_REVISION";
			break;
		}

		case ERROR_REVISION_MISMATCH:
		{
			// 1306 Indicates two revision levels are incompatible.  ERROR_REVISION_MISMATCH
			pString = "ERROR_REVISION_MISMATCH";
			break;
		}

		case ERROR_INVALID_OWNER:
		{
			// 1307 This security ID may not be assigned as the owner of this object.  ERROR_INVALID_OWNER
			pString = "ERROR_INVALID_OWNER";
			break;
		}

		case ERROR_INVALID_PRIMARY_GROUP:
		{
			// 1308 This security ID may not be assigned as the primary group of an object.  ERROR_INVALID_PRIMARY_GROUP
			pString = "ERROR_INVALID_PRIMARY_GROUP";
			break;
		}

		case ERROR_NO_IMPERSONATION_TOKEN:
		{
			// 1309 An attempt has been made to operate on an impersonation token by a thread that is not currently impersonating a client.  ERROR_NO_IMPERSONATION_TOKEN
			pString = "ERROR_NO_IMPERSONATION_TOKEN";
			break;
		}

		case ERROR_CANT_DISABLE_MANDATORY:
		{
			// 1310 The group may not be disabled.  ERROR_CANT_DISABLE_MANDATORY
			pString = "ERROR_CANT_DISABLE_MANDATORY";
			break;
		}

		case ERROR_NO_LOGON_SERVERS:
		{
			// 1311 There are currently no logon servers available to service the logon request.  ERROR_NO_LOGON_SERVERS
			pString = "ERROR_NO_LOGON_SERVERS";
			break;
		}

		case ERROR_NO_SUCH_LOGON_SESSION:
		{
			// 1312 A specified logon session does not exist. It may already have been terminated.  ERROR_NO_SUCH_LOGON_SESSION
			pString = "ERROR_NO_SUCH_LOGON_SESSION";
			break;
		}

		case ERROR_NO_SUCH_PRIVILEGE:
		{
			// 1313 A specified privilege does not exist.  ERROR_NO_SUCH_PRIVILEGE
			pString = "ERROR_NO_SUCH_PRIVILEGE";
			break;
		}

		case ERROR_PRIVILEGE_NOT_HELD:
		{
			// 1314 A required privilege is not held by the client.  ERROR_PRIVILEGE_NOT_HELD
			pString = "ERROR_PRIVILEGE_NOT_HELD";
			break;
		}

		case ERROR_INVALID_ACCOUNT_NAME:
		{
			// 1315 The name provided is not a properly formed account name.  ERROR_INVALID_ACCOUNT_NAME
			pString = "ERROR_INVALID_ACCOUNT_NAME";
			break;
		}

		case ERROR_USER_EXISTS:
		{
			// 1316 The specified user already exists.  ERROR_USER_EXISTS
			pString = "ERROR_USER_EXISTS";
			break;
		}

		case ERROR_NO_SUCH_USER:
		{
			// 1317 The specified user does not exist.  ERROR_NO_SUCH_USER
			pString = "ERROR_NO_SUCH_USER";
			break;
		}

		case ERROR_GROUP_EXISTS:
		{
			// 1318 The specified group already exists.  ERROR_GROUP_EXISTS
			pString = "ERROR_GROUP_EXISTS";
			break;
		}

		case ERROR_NO_SUCH_GROUP:
		{
			// 1319 The specified group does not exist.  ERROR_NO_SUCH_GROUP
			pString = "ERROR_NO_SUCH_GROUP";
			break;
		}

		case ERROR_MEMBER_IN_GROUP:
		{
			// 1320 Either the specified user account is already a member of the specified group, or the specified group cannot be deleted because it contains a member.  ERROR_MEMBER_IN_GROUP
			pString = "ERROR_MEMBER_IN_GROUP";
			break;
		}

		case ERROR_MEMBER_NOT_IN_GROUP:
		{
			// 1321 The specified user account is not a member of the specified group account.  ERROR_MEMBER_NOT_IN_GROUP
			pString = "ERROR_MEMBER_NOT_IN_GROUP";
			break;
		}

		case ERROR_LAST_ADMIN:
		{
			// 1322 The last remaining administration account cannot be disabled or deleted.  ERROR_LAST_ADMIN
			pString = "ERROR_LAST_ADMIN";
			break;
		}

		case ERROR_WRONG_PASSWORD:
		{
			// 1323 Unable to update the password. The value provided as the current password is incorrect.  ERROR_WRONG_PASSWORD
			pString = "ERROR_WRONG_PASSWORD";
			break;
		}

		case ERROR_ILL_FORMED_PASSWORD:
		{
			// 1324 Unable to update the password. The value provided for the new password contains values that are not allowed in passwords.  ERROR_ILL_FORMED_PASSWORD
			pString = "ERROR_ILL_FORMED_PASSWORD";
			break;
		}

		case ERROR_PASSWORD_RESTRICTION:
		{
			// 1325 Unable to update the password because a password update rule has been violated.  ERROR_PASSWORD_RESTRICTION
			pString = "ERROR_PASSWORD_RESTRICTION";
			break;
		}

		case ERROR_LOGON_FAILURE:
		{
			// 1326 Logon failure: unknown user name or bad password.  ERROR_LOGON_FAILURE
			pString = "ERROR_LOGON_FAILURE";
			break;
		}

		case ERROR_ACCOUNT_RESTRICTION:
		{
			// 1327 Logon failure: user account restriction.  ERROR_ACCOUNT_RESTRICTION
			pString = "ERROR_ACCOUNT_RESTRICTION";
			break;
		}

		case ERROR_INVALID_LOGON_HOURS:
		{
			// 1328 Logon failure: account logon time restriction violation.  ERROR_INVALID_LOGON_HOURS
			pString = "ERROR_INVALID_LOGON_HOURS";
			break;
		}

		case ERROR_INVALID_WORKSTATION:
		{
			// 1329 Logon failure: user not allowed to log on to this computer.  ERROR_INVALID_WORKSTATION
			pString = "ERROR_INVALID_WORKSTATION";
			break;
		}

		case ERROR_PASSWORD_EXPIRED:
		{
			// 1330 Logon failure: the specified account password has expired.  ERROR_PASSWORD_EXPIRED
			pString = "ERROR_PASSWORD_EXPIRED";
			break;
		}

		case ERROR_ACCOUNT_DISABLED:
		{
			// 1331 Logon failure: account currently disabled.  ERROR_ACCOUNT_DISABLED
			pString = "ERROR_ACCOUNT_DISABLED";
			break;
		}

		case ERROR_NONE_MAPPED:
		{
			// 1332 No mapping between account names and security IDs was done.  ERROR_NONE_MAPPED
			pString = "ERROR_NONE_MAPPED";
			break;
		}

		case ERROR_TOO_MANY_LUIDS_REQUESTED:
		{
			// 1333 Too many local user identifiers (LUIDs) were requested at one time.  ERROR_TOO_MANY_LUIDS_REQUESTED
			pString = "ERROR_TOO_MANY_LUIDS_REQUESTED";
			break;
		}

		case ERROR_LUIDS_EXHAUSTED:
		{
			// 1334 No more local user identifiers (LUIDs) are available.  ERROR_LUIDS_EXHAUSTED
			pString = "ERROR_LUIDS_EXHAUSTED";
			break;
		}

		case ERROR_INVALID_SUB_AUTHORITY:
		{
			// 1335 The subauthority part of a security ID is invalid for this particular use.  ERROR_INVALID_SUB_AUTHORITY
			pString = "ERROR_INVALID_SUB_AUTHORITY";
			break;
		}

		case ERROR_INVALID_ACL:
		{
			// 1336 The access control list (ACL) structure is invalid.  ERROR_INVALID_ACL
			pString = "ERROR_INVALID_ACL";
			break;
		}

		case ERROR_INVALID_SID:
		{
			// 1337 The security ID structure is invalid.  ERROR_INVALID_SID
			pString = "ERROR_INVALID_SID";
			break;
		}

		case ERROR_INVALID_SECURITY_DESCR:
		{
			// 1338 The security descriptor structure is invalid.  ERROR_INVALID_SECURITY_DESCR
			pString = "ERROR_INVALID_SECURITY_DESCR";
			break;
		}

		case ERROR_BAD_INHERITANCE_ACL:
		{
			// 1340 The inherited access control list (ACL) or access control entry (ACE) could not be built.  ERROR_BAD_INHERITANCE_ACL
			pString = "ERROR_BAD_INHERITANCE_ACL";
			break;
		}

		case ERROR_SERVER_DISABLED:
		{
			// 1341 The server is currently disabled.  ERROR_SERVER_DISABLED
			pString = "ERROR_SERVER_DISABLED";
			break;
		}

		case ERROR_SERVER_NOT_DISABLED:
		{
			// 1342 The server is currently enabled.  ERROR_SERVER_NOT_DISABLED
			pString = "ERROR_SERVER_NOT_DISABLED";
			break;
		}

		case ERROR_INVALID_ID_AUTHORITY:
		{
			// 1343 The value provided was an invalid value for an identifier authority.  ERROR_INVALID_ID_AUTHORITY
			pString = "ERROR_INVALID_ID_AUTHORITY";
			break;
		}

		case ERROR_ALLOTTED_SPACE_EXCEEDED:
		{
			// 1344 No more memory is available for security information updates.  ERROR_ALLOTTED_SPACE_EXCEEDED
			pString = "ERROR_ALLOTTED_SPACE_EXCEEDED";
			break;
		}

		case ERROR_INVALID_GROUP_ATTRIBUTES:
		{
			// 1345 The specified attributes are invalid, or incompatible with the attributes for the group as a whole.  ERROR_INVALID_GROUP_ATTRIBUTES
			pString = "ERROR_INVALID_GROUP_ATTRIBUTES";
			break;
		}

		case ERROR_BAD_IMPERSONATION_LEVEL:
		{
			// 1346 Either a required impersonation level was not provided, or the provided impersonation level is invalid.  ERROR_BAD_IMPERSONATION_LEVEL
			pString = "ERROR_BAD_IMPERSONATION_LEVEL";
			break;
		}

		case ERROR_CANT_OPEN_ANONYMOUS:
		{
			// 1347 Cannot open an anonymous level security token.  ERROR_CANT_OPEN_ANONYMOUS
			pString = "ERROR_CANT_OPEN_ANONYMOUS";
			break;
		}

		case ERROR_BAD_VALIDATION_CLASS:
		{
			// 1348 The validation information class requested was invalid.  ERROR_BAD_VALIDATION_CLASS
			pString = "ERROR_BAD_VALIDATION_CLASS";
			break;
		}

		case ERROR_BAD_TOKEN_TYPE:
		{
			// 1349 The type of the token is inappropriate for its attempted use.  ERROR_BAD_TOKEN_TYPE
			pString = "ERROR_BAD_TOKEN_TYPE";
			break;
		}

		case ERROR_NO_SECURITY_ON_OBJECT:
		{
			// 1350 Unable to perform a security operation on an object that has no associated security.  ERROR_NO_SECURITY_ON_OBJECT
			pString = "ERROR_NO_SECURITY_ON_OBJECT";
			break;
		}

		case ERROR_CANT_ACCESS_DOMAIN_INFO:
		{
			// 1351 Indicates a Windows NT Server could not be contacted or that objects within the domain are protected such that necessary information could not be retrieved.  ERROR_CANT_ACCESS_DOMAIN_INFO
			pString = "ERROR_CANT_ACCESS_DOMAIN_INFO";
			break;
		}

		case ERROR_INVALID_SERVER_STATE:
		{
			// 1352 The security account manager (SAM) or local security authority (LSA) server was in the wrong state to perform the security operation.  ERROR_INVALID_SERVER_STATE
			pString = "ERROR_INVALID_SERVER_STATE";
			break;
		}

		case ERROR_INVALID_DOMAIN_STATE:
		{
			// 1353 The domain was in the wrong state to perform the security operation.  ERROR_INVALID_DOMAIN_STATE
			pString = "ERROR_INVALID_DOMAIN_STATE";
			break;
		}

		case ERROR_INVALID_DOMAIN_ROLE:
		{
			// 1354 This operation is only allowed for the Primary Domain Controller of the domain.  ERROR_INVALID_DOMAIN_ROLE
			pString = "ERROR_INVALID_DOMAIN_ROLE";
			break;
		}

		case ERROR_NO_SUCH_DOMAIN:
		{
			// 1355 The specified domain did not exist.  ERROR_NO_SUCH_DOMAIN
			pString = "ERROR_NO_SUCH_DOMAIN";
			break;
		}

		case ERROR_DOMAIN_EXISTS:
		{
			// 1356 The specified domain already exists.  ERROR_DOMAIN_EXISTS
			pString = "ERROR_DOMAIN_EXISTS";
			break;
		}

		case ERROR_DOMAIN_LIMIT_EXCEEDED:
		{
			// 1357 An attempt was made to exceed the limit on the number of domains per server.  ERROR_DOMAIN_LIMIT_EXCEEDED
			pString = "ERROR_DOMAIN_LIMIT_EXCEEDED";
			break;
		}

		case ERROR_INTERNAL_DB_CORRUPTION:
		{
			// 1358 Unable to complete the requested operation because of either a catastrophic media failure or a data structure corruption on the disk.  ERROR_INTERNAL_DB_CORRUPTION
			pString = "ERROR_INTERNAL_DB_CORRUPTION";
			break;
		}

		case ERROR_INTERNAL_ERROR:
		{
			// 1359 The security account database contains an internal inconsistency.  ERROR_INTERNAL_ERROR
			pString = "ERROR_INTERNAL_ERROR";
			break;
		}

		case ERROR_GENERIC_NOT_MAPPED:
		{
			// 1360 Generic access types were contained in an access mask which should already be mapped to nongeneric types.  ERROR_GENERIC_NOT_MAPPED
			pString = "ERROR_GENERIC_NOT_MAPPED";
			break;
		}

		case ERROR_BAD_DESCRIPTOR_FORMAT:
		{
			// 1361 A security descriptor is not in the right format (absolute or self-relative).  ERROR_BAD_DESCRIPTOR_FORMAT
			pString = "ERROR_BAD_DESCRIPTOR_FORMAT";
			break;
		}

		case ERROR_NOT_LOGON_PROCESS:
		{
			// 1362 The requested action is restricted for use by logon processes only. The calling process has not registered as a logon process.  ERROR_NOT_LOGON_PROCESS
			pString = "ERROR_NOT_LOGON_PROCESS";
			break;
		}

		case ERROR_LOGON_SESSION_EXISTS:
		{
			// 1363 Cannot start a new logon session with an ID that is already in use.  ERROR_LOGON_SESSION_EXISTS
			pString = "ERROR_LOGON_SESSION_EXISTS";
			break;
		}

		case ERROR_NO_SUCH_PACKAGE:
		{
			// 1364 A specified authentication package is unknown.  ERROR_NO_SUCH_PACKAGE
			pString = "ERROR_NO_SUCH_PACKAGE";
			break;
		}

		case ERROR_BAD_LOGON_SESSION_STATE:
		{
			// 1365 The logon session is not in a state that is consistent with the requested operation.  ERROR_BAD_LOGON_SESSION_STATE
			pString = "ERROR_BAD_LOGON_SESSION_STATE";
			break;
		}

		case ERROR_LOGON_SESSION_COLLISION:
		{
			// 1366 The logon session ID is already in use.  ERROR_LOGON_SESSION_COLLISION
			pString = "ERROR_LOGON_SESSION_COLLISION";
			break;
		}

		case ERROR_INVALID_LOGON_TYPE:
		{
			// 1367 A logon request contained an invalid logon type value.  ERROR_INVALID_LOGON_TYPE
			pString = "ERROR_INVALID_LOGON_TYPE";
			break;
		}

		case ERROR_CANNOT_IMPERSONATE:
		{
			// 1368 Unable to impersonate using a named pipe until data has been read from that pipe.  ERROR_CANNOT_IMPERSONATE
			pString = "ERROR_CANNOT_IMPERSONATE";
			break;
		}

		case ERROR_RXACT_INVALID_STATE:
		{
			// 1369 The transaction state of a registry subtree is incompatible with the requested operation.  ERROR_RXACT_INVALID_STATE
			pString = "ERROR_RXACT_INVALID_STATE";
			break;
		}

		case ERROR_RXACT_COMMIT_FAILURE:
		{
			// 1370 An internal security database corruption has been encountered.  ERROR_RXACT_COMMIT_FAILURE
			pString = "ERROR_RXACT_COMMIT_FAILURE";
			break;
		}

		case ERROR_SPECIAL_ACCOUNT:
		{
			// 1371 Cannot perform this operation on built-in accounts.  ERROR_SPECIAL_ACCOUNT
			pString = "ERROR_SPECIAL_ACCOUNT";
			break;
		}

		case ERROR_SPECIAL_GROUP:
		{
			// 1372 Cannot perform this operation on this built-in special group.  ERROR_SPECIAL_GROUP
			pString = "ERROR_SPECIAL_GROUP";
			break;
		}

		case ERROR_SPECIAL_USER:
		{
			// 1373 Cannot perform this operation on this built-in special user.  ERROR_SPECIAL_USER
			pString = "ERROR_SPECIAL_USER";
			break;
		}

		case ERROR_MEMBERS_PRIMARY_GROUP:
		{
			// 1374 The user cannot be removed from a group because the group is currently the user's primary group.  ERROR_MEMBERS_PRIMARY_GROUP
			pString = "ERROR_MEMBERS_PRIMARY_GROUP";
			break;
		}

		case ERROR_TOKEN_ALREADY_IN_USE:
		{
			// 1375 The token is already in use as a primary token.  ERROR_TOKEN_ALREADY_IN_USE
			pString = "ERROR_TOKEN_ALREADY_IN_USE";
			break;
		}

		case ERROR_NO_SUCH_ALIAS:
		{
			// 1376 The specified local group does not exist.  ERROR_NO_SUCH_ALIAS
			pString = "ERROR_NO_SUCH_ALIAS";
			break;
		}

		case ERROR_MEMBER_NOT_IN_ALIAS:
		{
			// 1377 The specified account name is not a member of the local group.  ERROR_MEMBER_NOT_IN_ALIAS
			pString = "ERROR_MEMBER_NOT_IN_ALIAS";
			break;
		}

		case ERROR_MEMBER_IN_ALIAS:
		{
			// 1378 The specified account name is already a member of the local group.  ERROR_MEMBER_IN_ALIAS
			pString = "ERROR_MEMBER_IN_ALIAS";
			break;
		}

		case ERROR_ALIAS_EXISTS:
		{
			// 1379 The specified local group already exists.  ERROR_ALIAS_EXISTS
			pString = "ERROR_ALIAS_EXISTS";
			break;
		}

		case ERROR_LOGON_NOT_GRANTED:
		{
			// 1380 Logon failure: the user has not been granted the requested logon type at this computer.  ERROR_LOGON_NOT_GRANTED
			pString = "ERROR_LOGON_NOT_GRANTED";
			break;
		}

		case ERROR_TOO_MANY_SECRETS:
		{
			// 1381 The maximum number of secrets that may be stored in a single system has been exceeded.  ERROR_TOO_MANY_SECRETS
			pString = "ERROR_TOO_MANY_SECRETS";
			break;
		}

		case ERROR_SECRET_TOO_LONG:
		{
			// 1382 The length of a secret exceeds the maximum length allowed.  ERROR_SECRET_TOO_LONG
			pString = "ERROR_SECRET_TOO_LONG";
			break;
		}

		case ERROR_INTERNAL_DB_ERROR:
		{
			// 1383 The local security authority database contains an internal inconsistency.  ERROR_INTERNAL_DB_ERROR
			pString = "ERROR_INTERNAL_DB_ERROR";
			break;
		}

		case ERROR_TOO_MANY_CONTEXT_IDS:
		{
			// 1384 During a logon attempt, the user's security context accumulated too many security IDs.  ERROR_TOO_MANY_CONTEXT_IDS
			pString = "ERROR_TOO_MANY_CONTEXT_IDS";
			break;
		}

		case ERROR_LOGON_TYPE_NOT_GRANTED:
		{
			// 1385 Logon failure: the user has not been granted the requested logon type at this computer.  ERROR_LOGON_TYPE_NOT_GRANTED
			pString = "ERROR_LOGON_TYPE_NOT_GRANTED";
			break;
		}

		case ERROR_NT_CROSS_ENCRYPTION_REQUIRED:
		{
			// 1386 A cross-encrypted password is necessary to change a user password.  ERROR_NT_CROSS_ENCRYPTION_REQUIRED
			pString = "ERROR_NT_CROSS_ENCRYPTION_REQUIRED";
			break;
		}

		case ERROR_NO_SUCH_MEMBER:
		{
			// 1387 A new member could not be added to a local group because the member does not exist.  ERROR_NO_SUCH_MEMBER
			pString = "ERROR_NO_SUCH_MEMBER";
			break;
		}

		case ERROR_INVALID_MEMBER:
		{
			// 1388 A new member could not be added to a local group because the member has the wrong account type.  ERROR_INVALID_MEMBER
			pString = "ERROR_INVALID_MEMBER";
			break;
		}

		case ERROR_TOO_MANY_SIDS:
		{
			// 1389 Too many security IDs have been specified.  ERROR_TOO_MANY_SIDS
			pString = "ERROR_TOO_MANY_SIDS";
			break;
		}

		case ERROR_LM_CROSS_ENCRYPTION_REQUIRED:
		{
			// 1390 A cross-encrypted password is necessary to change this user password.  ERROR_LM_CROSS_ENCRYPTION_REQUIRED
			pString = "ERROR_LM_CROSS_ENCRYPTION_REQUIRED";
			break;
		}

		case ERROR_NO_INHERITANCE:
		{
			// 1391 Indicates an ACL contains no inheritable components.  ERROR_NO_INHERITANCE
			pString = "ERROR_NO_INHERITANCE";
			break;
		}

		case ERROR_FILE_CORRUPT:
		{
			// 1392 The file or directory is corrupted and unreadable.  ERROR_FILE_CORRUPT
			pString = "ERROR_FILE_CORRUPT";
			break;
		}

		case ERROR_DISK_CORRUPT:
		{
			// 1393 The disk structure is corrupted and unreadable.  ERROR_DISK_CORRUPT
			pString = "ERROR_DISK_CORRUPT";
			break;
		}

		case ERROR_NO_USER_SESSION_KEY:
		{
			// 1394 There is no user session key for the specified logon session.  ERROR_NO_USER_SESSION_KEY
			pString = "ERROR_NO_USER_SESSION_KEY";
			break;
		}

		case ERROR_LICENSE_QUOTA_EXCEEDED:
		{
			// 1395 The service being accessed is licensed for a particular number of connections. No more connections can be made to the service at this time because there are already as many connections as the service can accept.  ERROR_LICENSE_QUOTA_EXCEEDED
			pString = "ERROR_LICENSE_QUOTA_EXCEEDED";
			break;
		}

		case ERROR_INVALID_WINDOW_HANDLE:
		{
			// 1400 Invalid window handle.  ERROR_INVALID_WINDOW_HANDLE
			pString = "ERROR_INVALID_WINDOW_HANDLE";
			break;
		}

		case ERROR_INVALID_MENU_HANDLE:
		{
			// 1401 Invalid menu handle.  ERROR_INVALID_MENU_HANDLE
			pString = "ERROR_INVALID_MENU_HANDLE";
			break;
		}

		case ERROR_INVALID_CURSOR_HANDLE:
		{
			// 1402 Invalid cursor handle.  ERROR_INVALID_CURSOR_HANDLE
			pString = "ERROR_INVALID_CURSOR_HANDLE";
			break;
		}

		case ERROR_INVALID_ACCEL_HANDLE:
		{
			// 1403 Invalid accelerator table handle.  ERROR_INVALID_ACCEL_HANDLE
			pString = "ERROR_INVALID_ACCEL_HANDLE";
			break;
		}

		case ERROR_INVALID_HOOK_HANDLE:
		{
			// 1404 Invalid hook handle.  ERROR_INVALID_HOOK_HANDLE
			pString = "ERROR_INVALID_HOOK_HANDLE";
			break;
		}

		case ERROR_INVALID_DWP_HANDLE:
		{
			// 1405 Invalid handle to a multiple-window position structure.  ERROR_INVALID_DWP_HANDLE
			pString = "ERROR_INVALID_DWP_HANDLE";
			break;
		}

		case ERROR_TLW_WITH_WSCHILD:
		{
			// 1406 Cannot create a top-level child window.  ERROR_TLW_WITH_WSCHILD
			pString = "ERROR_TLW_WITH_WSCHILD";
			break;
		}

		case ERROR_CANNOT_FIND_WND_CLASS:
		{
			// 1407 Cannot find window class.  ERROR_CANNOT_FIND_WND_CLASS
			pString = "ERROR_CANNOT_FIND_WND_CLASS";
			break;
		}

		case ERROR_WINDOW_OF_OTHER_THREAD:
		{
			// 1408 Invalid window; it belongs to other thread.  ERROR_WINDOW_OF_OTHER_THREAD
			pString = "ERROR_WINDOW_OF_OTHER_THREAD";
			break;
		}

		case ERROR_HOTKEY_ALREADY_REGISTERED:
		{
			// 1409 Hot key is already registered.  ERROR_HOTKEY_ALREADY_REGISTERED
			pString = "ERROR_HOTKEY_ALREADY_REGISTERED";
			break;
		}

		case ERROR_CLASS_ALREADY_EXISTS:
		{
			// 1410 Class already exists.  ERROR_CLASS_ALREADY_EXISTS
			pString = "ERROR_CLASS_ALREADY_EXISTS";
			break;
		}

		case ERROR_CLASS_DOES_NOT_EXIST:
		{
			// 1411 Class does not exist.  ERROR_CLASS_DOES_NOT_EXIST
			pString = "ERROR_CLASS_DOES_NOT_EXIST";
			break;
		}

		case ERROR_CLASS_HAS_WINDOWS:
		{
			// 1412 Class still has open windows.  ERROR_CLASS_HAS_WINDOWS
			pString = "ERROR_CLASS_HAS_WINDOWS";
			break;
		}

		case ERROR_INVALID_INDEX:
		{
			// 1413 Invalid index.  ERROR_INVALID_INDEX
			pString = "ERROR_INVALID_INDEX";
			break;
		}

		case ERROR_INVALID_ICON_HANDLE:
		{
			// 1414 Invalid icon handle.  ERROR_INVALID_ICON_HANDLE
			pString = "ERROR_INVALID_ICON_HANDLE";
			break;
		}

		case ERROR_PRIVATE_DIALOG_INDEX:
		{
			// 1415 Using private DIALOG window words.  ERROR_PRIVATE_DIALOG_INDEX
			pString = "ERROR_PRIVATE_DIALOG_INDEX";
			break;
		}

		case ERROR_LISTBOX_ID_NOT_FOUND:
		{
			// 1416 The list box identifier was not found.  ERROR_LISTBOX_ID_NOT_FOUND
			pString = "ERROR_LISTBOX_ID_NOT_FOUND";
			break;
		}

		case ERROR_NO_WILDCARD_CHARACTERS:
		{
			// 1417 No wildcards were found.  ERROR_NO_WILDCARD_CHARACTERS
			pString = "ERROR_NO_WILDCARD_CHARACTERS";
			break;
		}

		case ERROR_CLIPBOARD_NOT_OPEN:
		{
			// 1418 Thread does not have a clipboard open.  ERROR_CLIPBOARD_NOT_OPEN
			pString = "ERROR_CLIPBOARD_NOT_OPEN";
			break;
		}

		case ERROR_HOTKEY_NOT_REGISTERED:
		{
			// 1419 Hot key is not registered.  ERROR_HOTKEY_NOT_REGISTERED
			pString = "ERROR_HOTKEY_NOT_REGISTERED";
			break;
		}

		case ERROR_WINDOW_NOT_DIALOG:
		{
			// 1420 The window is not a valid dialog window.  ERROR_WINDOW_NOT_DIALOG
			pString = "ERROR_WINDOW_NOT_DIALOG";
			break;
		}

		case ERROR_CONTROL_ID_NOT_FOUND:
		{
			// 1421 Control ID not found.  ERROR_CONTROL_ID_NOT_FOUND
			pString = "ERROR_CONTROL_ID_NOT_FOUND";
			break;
		}

		case ERROR_INVALID_COMBOBOX_MESSAGE:
		{
			// 1422 Invalid message for a combo box because it does not have an edit control.  ERROR_INVALID_COMBOBOX_MESSAGE
			pString = "ERROR_INVALID_COMBOBOX_MESSAGE";
			break;
		}

		case ERROR_WINDOW_NOT_COMBOBOX:
		{
			// 1423 The window is not a combo box.  ERROR_WINDOW_NOT_COMBOBOX
			pString = "ERROR_WINDOW_NOT_COMBOBOX";
			break;
		}

		case ERROR_INVALID_EDIT_HEIGHT:
		{
			// 1424 Height must be less than 256.  ERROR_INVALID_EDIT_HEIGHT
			pString = "ERROR_INVALID_EDIT_HEIGHT";
			break;
		}

		case ERROR_DC_NOT_FOUND:
		{
			// 1425 Invalid device context (DC) handle.  ERROR_DC_NOT_FOUND
			pString = "ERROR_DC_NOT_FOUND";
			break;
		}

		case ERROR_INVALID_HOOK_FILTER:
		{
			// 1426 Invalid hook procedure type.  ERROR_INVALID_HOOK_FILTER
			pString = "ERROR_INVALID_HOOK_FILTER";
			break;
		}

		case ERROR_INVALID_FILTER_PROC:
		{
			// 1427 Invalid hook procedure.  ERROR_INVALID_FILTER_PROC
			pString = "ERROR_INVALID_FILTER_PROC";
			break;
		}

		case ERROR_HOOK_NEEDS_HMOD:
		{
			// 1428 Cannot set nonlocal hook without a module handle.  ERROR_HOOK_NEEDS_HMOD
			pString = "ERROR_HOOK_NEEDS_HMOD";
			break;
		}

		case ERROR_GLOBAL_ONLY_HOOK:
		{
			// 1429 This hook procedure can only be set globally.  ERROR_GLOBAL_ONLY_HOOK
			pString = "ERROR_GLOBAL_ONLY_HOOK";
			break;
		}

		case ERROR_JOURNAL_HOOK_SET:
		{
			// 1430 The journal hook procedure is already installed.  ERROR_JOURNAL_HOOK_SET
			pString = "ERROR_JOURNAL_HOOK_SET";
			break;
		}

		case ERROR_HOOK_NOT_INSTALLED:
		{
			// 1431 The hook procedure is not installed.  ERROR_HOOK_NOT_INSTALLED
			pString = "ERROR_HOOK_NOT_INSTALLED";
			break;
		}

		case ERROR_INVALID_LB_MESSAGE:
		{
			// 1432 Invalid message for single-selection list box.  ERROR_INVALID_LB_MESSAGE
			pString = "ERROR_INVALID_LB_MESSAGE";
			break;
		}

		case ERROR_SETCOUNT_ON_BAD_LB:
		{
			// 1433 LB_SETCOUNT sent to non-lazy list box.  ERROR_SETCOUNT_ON_BAD_LB
			pString = "ERROR_SETCOUNT_ON_BAD_LB";
			break;
		}

		case ERROR_LB_WITHOUT_TABSTOPS:
		{
			// 1434 This list box does not support tab stops.  ERROR_LB_WITHOUT_TABSTOPS
			pString = "ERROR_LB_WITHOUT_TABSTOPS";
			break;
		}

		case ERROR_DESTROY_OBJECT_OF_OTHER_THREAD:
		{
			// 1435 Cannot destroy object created by another thread.  ERROR_DESTROY_OBJECT_OF_OTHER_THREAD
			pString = "ERROR_DESTROY_OBJECT_OF_OTHER_THREAD";
			break;
		}

		case ERROR_CHILD_WINDOW_MENU:
		{
			// 1436 Child windows cannot have menus.  ERROR_CHILD_WINDOW_MENU
			pString = "ERROR_CHILD_WINDOW_MENU";
			break;
		}

		case ERROR_NO_SYSTEM_MENU:
		{
			// 1437 The window does not have a system menu.  ERROR_NO_SYSTEM_MENU
			pString = "ERROR_NO_SYSTEM_MENU";
			break;
		}

		case ERROR_INVALID_MSGBOX_STYLE:
		{
			// 1438 Invalid message box style.  ERROR_INVALID_MSGBOX_STYLE
			pString = "ERROR_INVALID_MSGBOX_STYLE";
			break;
		}

		case ERROR_INVALID_SPI_VALUE:
		{
			// 1439 Invalid system-wide (SPI_*) parameter.  ERROR_INVALID_SPI_VALUE
			pString = "ERROR_INVALID_SPI_VALUE";
			break;
		}

		case ERROR_SCREEN_ALREADY_LOCKED:
		{
			// 1440 Screen already locked.  ERROR_SCREEN_ALREADY_LOCKED
			pString = "ERROR_SCREEN_ALREADY_LOCKED";
			break;
		}

		case ERROR_HWNDS_HAVE_DIFF_PARENT:
		{
			// 1441 All handles to windows in a multiple-window position structure must have the same parent.  ERROR_HWNDS_HAVE_DIFF_PARENT
			pString = "ERROR_HWNDS_HAVE_DIFF_PARENT";
			break;
		}

		case ERROR_NOT_CHILD_WINDOW:
		{
			// 1442 The window is not a child window.  ERROR_NOT_CHILD_WINDOW
			pString = "ERROR_NOT_CHILD_WINDOW";
			break;
		}

		case ERROR_INVALID_GW_COMMAND:
		{
			// 1443 Invalid GW_* command.  ERROR_INVALID_GW_COMMAND
			pString = "ERROR_INVALID_GW_COMMAND";
			break;
		}

		case ERROR_INVALID_THREAD_ID:
		{
			// 1444 Invalid thread identifier.  ERROR_INVALID_THREAD_ID
			pString = "ERROR_INVALID_THREAD_ID";
			break;
		}

		case ERROR_NON_MDICHILD_WINDOW:
		{
			// 1445 Cannot process a message from a window that is not a multiple document interface (MDI) window.  ERROR_NON_MDICHILD_WINDOW
			pString = "ERROR_NON_MDICHILD_WINDOW";
			break;
		}

		case ERROR_POPUP_ALREADY_ACTIVE:
		{
			// 1446 Popup menu already active.  ERROR_POPUP_ALREADY_ACTIVE
			pString = "ERROR_POPUP_ALREADY_ACTIVE";
			break;
		}

		case ERROR_NO_SCROLLBARS:
		{
			// 1447 The window does not have scroll bars.  ERROR_NO_SCROLLBARS
			pString = "ERROR_NO_SCROLLBARS";
			break;
		}

		case ERROR_INVALID_SCROLLBAR_RANGE:
		{
			// 1448 Scroll bar range cannot be greater than 0x7FFF.  ERROR_INVALID_SCROLLBAR_RANGE
			pString = "ERROR_INVALID_SCROLLBAR_RANGE";
			break;
		}

		case ERROR_INVALID_SHOWWIN_COMMAND:
		{
			// 1449 Cannot show or remove the window in the way specified.  ERROR_INVALID_SHOWWIN_COMMAND
			pString = "ERROR_INVALID_SHOWWIN_COMMAND";
			break;
		}

		case ERROR_NO_SYSTEM_RESOURCES:
		{
			// 1450 Insufficient system resources exist to complete the requested service.  ERROR_NO_SYSTEM_RESOURCES
			pString = "ERROR_NO_SYSTEM_RESOURCES";
			break;
		}

		case ERROR_NONPAGED_SYSTEM_RESOURCES:
		{
			// 1451 Insufficient system resources exist to complete the requested service.  ERROR_NONPAGED_SYSTEM_RESOURCES
			pString = "ERROR_NONPAGED_SYSTEM_RESOURCES";
			break;
		}

		case ERROR_PAGED_SYSTEM_RESOURCES:
		{
			// 1452 Insufficient system resources exist to complete the requested service.  ERROR_PAGED_SYSTEM_RESOURCES
			pString = "ERROR_PAGED_SYSTEM_RESOURCES";
			break;
		}

		case ERROR_WORKING_SET_QUOTA:
		{
			// 1453 Insufficient quota to complete the requested service.  ERROR_WORKING_SET_QUOTA
			pString = "ERROR_WORKING_SET_QUOTA";
			break;
		}

		case ERROR_PAGEFILE_QUOTA:
		{
			// 1454 Insufficient quota to complete the requested service.  ERROR_PAGEFILE_QUOTA
			pString = "ERROR_PAGEFILE_QUOTA";
			break;
		}

		case ERROR_COMMITMENT_LIMIT:
		{
			// 1455 The paging file is too small for this operation to complete.  ERROR_COMMITMENT_LIMIT
			pString = "ERROR_COMMITMENT_LIMIT";
			break;
		}

		case ERROR_MENU_ITEM_NOT_FOUND:
		{
			// 1456 A menu item was not found.  ERROR_MENU_ITEM_NOT_FOUND
			pString = "ERROR_MENU_ITEM_NOT_FOUND";
			break;
		}

		case ERROR_INVALID_KEYBOARD_HANDLE:
		{
			// 1457 Invalid keyboard layout handle.  ERROR_INVALID_KEYBOARD_HANDLE
			pString = "ERROR_INVALID_KEYBOARD_HANDLE";
			break;
		}

		case ERROR_HOOK_TYPE_NOT_ALLOWED:
		{
			// 1458 Hook type not allowed.  ERROR_HOOK_TYPE_NOT_ALLOWED
			pString = "ERROR_HOOK_TYPE_NOT_ALLOWED";
			break;
		}

		case ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION:
		{
			// 1459 This operation requires an interactive window station.  ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION
			pString = "ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION";
			break;
		}

		case ERROR_TIMEOUT:
		{
			// 1460 This operation returned because the timeout period expired.  ERROR_TIMEOUT
			pString = "ERROR_TIMEOUT";
			break;
		}

		case ERROR_INVALID_MONITOR_HANDLE:
		{
			// 1461 Invalid monitor handle.  ERROR_INVALID_MONITOR_HANDLE
			pString = "ERROR_INVALID_MONITOR_HANDLE";
			break;
		}

		case ERROR_EVENTLOG_FILE_CORRUPT:
		{
			// 1500 The event log file is corrupted.  ERROR_EVENTLOG_FILE_CORRUPT
			pString = "ERROR_EVENTLOG_FILE_CORRUPT";
			break;
		}

		case ERROR_EVENTLOG_CANT_START:
		{
			// 1501 No event log file could be opened, so the event logging service did not start.  ERROR_EVENTLOG_CANT_START
			pString = "ERROR_EVENTLOG_CANT_START";
			break;
		}

		case ERROR_LOG_FILE_FULL:
		{
			// 1502 The event log file is full.  ERROR_LOG_FILE_FULL
			pString = "ERROR_LOG_FILE_FULL";
			break;
		}

		case ERROR_EVENTLOG_FILE_CHANGED:
		{
			// 1503 The event log file has changed between read operations.  ERROR_EVENTLOG_FILE_CHANGED
			pString = "ERROR_EVENTLOG_FILE_CHANGED";
			break;
		}

		#pragma TODO(vanceo, "Temporarily commented out INSTALL_SERVICE so NT build environment will work, figure this out.")
		/*
		//
		case ERROR_INSTALL_SERVICE:
		{
			// 1601 Failure accessing install service.  ERROR_INSTALL_SERVICE
			pString = "ERROR_INSTALL_SERVICE";
			break;
		}
		*/

		case ERROR_INSTALL_USEREXIT:
		{
			// 1602 The user canceled the installation.  ERROR_INSTALL_USEREXIT
			pString = "ERROR_INSTALL_USEREXIT";
			break;
		}

		case ERROR_INSTALL_FAILURE:
		{
			// 1603 Fatal error during installation.  ERROR_INSTALL_FAILURE
			pString = "ERROR_INSTALL_FAILURE";
			break;
		}

		case ERROR_INSTALL_SUSPEND:
		{
			// 1604 Installation suspended, incomplete.  ERROR_INSTALL_SUSPEND
			pString = "ERROR_INSTALL_SUSPEND";
			break;
		}

		case ERROR_UNKNOWN_PRODUCT:
		{
			// 1605 Product code not registered.  ERROR_UNKNOWN_PRODUCT
			pString = "ERROR_UNKNOWN_PRODUCT";
			break;
		}

		case ERROR_UNKNOWN_FEATURE:
		{
			// 1606 Feature ID not registered.  ERROR_UNKNOWN_FEATURE
			pString = "ERROR_UNKNOWN_FEATURE";
			break;
		}

		case ERROR_UNKNOWN_COMPONENT:
		{
			// 1607 Component ID not registered.  ERROR_UNKNOWN_COMPONENT
			pString = "ERROR_UNKNOWN_COMPONENT";
			break;
		}

		case ERROR_UNKNOWN_PROPERTY:
		{
			// 1608 Unknown property.  ERROR_UNKNOWN_PROPERTY
			pString = "ERROR_UNKNOWN_PROPERTY";
			break;
		}

		case ERROR_INVALID_HANDLE_STATE:
		{
			// 1609 Handle is in an invalid state.  ERROR_INVALID_HANDLE_STATE
			pString = "ERROR_INVALID_HANDLE_STATE";
			break;
		}

		case ERROR_BAD_CONFIGURATION:
		{
			// 1610 Configuration data corrupt.  ERROR_BAD_CONFIGURATION
			pString = "ERROR_BAD_CONFIGURATION";
			break;
		}

		case ERROR_INDEX_ABSENT:
		{
			// 1611 Language not available.  ERROR_INDEX_ABSENT
			pString = "ERROR_INDEX_ABSENT";
			break;
		}

		case ERROR_INSTALL_SOURCE_ABSENT:
		{
			// 1612 Install source unavailable.  ERROR_INSTALL_SOURCE_ABSENT
			pString = "ERROR_INSTALL_SOURCE_ABSENT";
			break;
		}

		#pragma TODO(vanceo, "Temporarily commented out BAD_DATABASE_VERSION so NT build environment will work, figure this out.")
		/*
		case ERROR_BAD_DATABASE_VERSION:
		{
			// 1613 Database version unsupported.  ERROR_BAD_DATABASE_VERSION
			pString = "ERROR_BAD_DATABASE_VERSION";
			break;
		}
		*/

		case ERROR_PRODUCT_UNINSTALLED:
		{
			// 1614 Product is uninstalled.  ERROR_PRODUCT_UNINSTALLED
			pString = "ERROR_PRODUCT_UNINSTALLED";
			break;
		}

		case ERROR_BAD_QUERY_SYNTAX:
		{
			// 1615 SQL query syntax invalid or unsupported.  ERROR_BAD_QUERY_SYNTAX
			pString = "ERROR_BAD_QUERY_SYNTAX";
			break;
		}

		case ERROR_INVALID_FIELD:
		{
			// 1616 Record field does not exist.  ERROR_INVALID_FIELD
			pString = "ERROR_INVALID_FIELD";
			break;
		}

		case RPC_S_INVALID_STRING_BINDING:
		{
			// 1700 The string binding is invalid.  RPC_S_INVALID_STRING_BINDING
			pString = "RPC_S_INVALID_STRING_BINDING";
			break;
		}

		case RPC_S_WRONG_KIND_OF_BINDING:
		{
			// 1701 The binding handle is not the correct type.  RPC_S_WRONG_KIND_OF_BINDING
			pString = "RPC_S_WRONG_KIND_OF_BINDING";
			break;
		}

		case RPC_S_INVALID_BINDING:
		{
			// 1702 The binding handle is invalid.  RPC_S_INVALID_BINDING
			pString = "RPC_S_INVALID_BINDING";
			break;
		}

		case RPC_S_PROTSEQ_NOT_SUPPORTED:
		{
			// 1703 The RPC protocol sequence is not supported.  RPC_S_PROTSEQ_NOT_SUPPORTED
			pString = "RPC_S_PROTSEQ_NOT_SUPPORTED";
			break;
		}

		case RPC_S_INVALID_RPC_PROTSEQ:
		{
			// 1704 The RPC protocol sequence is invalid.  RPC_S_INVALID_RPC_PROTSEQ
			pString = "RPC_S_INVALID_RPC_PROTSEQ";
			break;
		}

		case RPC_S_INVALID_STRING_UUID:
		{
			// 1705 The string universal unique identifier (UUID) is invalid.  RPC_S_INVALID_STRING_UUID
			pString = "RPC_S_INVALID_STRING_UUID";
			break;
		}

		case RPC_S_INVALID_ENDPOINT_FORMAT:
		{
			// 1706 The endpoint format is invalid.  RPC_S_INVALID_ENDPOINT_FORMAT
			pString = "RPC_S_INVALID_ENDPOINT_FORMAT";
			break;
		}

		case RPC_S_INVALID_NET_ADDR:
		{
			// 1707 The network address is invalid.  RPC_S_INVALID_NET_ADDR
			pString = "RPC_S_INVALID_NET_ADDR";
			break;
		}

		case RPC_S_NO_ENDPOINT_FOUND:
		{
			// 1708 No endpoint was found.  RPC_S_NO_ENDPOINT_FOUND
			pString = "RPC_S_NO_ENDPOINT_FOUND";
			break;
		}

		case RPC_S_INVALID_TIMEOUT:
		{
			// 1709 The timeout value is invalid.  RPC_S_INVALID_TIMEOUT
			pString = "RPC_S_INVALID_TIMEOUT";
			break;
		}

		case RPC_S_OBJECT_NOT_FOUND:
		{
			// 1710 The object universal unique identifier (UUID) was not found.  RPC_S_OBJECT_NOT_FOUND
			pString = "RPC_S_OBJECT_NOT_FOUND";
			break;
		}

		case RPC_S_ALREADY_REGISTERED:
		{
			// 1711 The object universal unique identifier (UUID) has already been registered.  RPC_S_ALREADY_REGISTERED
			pString = "RPC_S_ALREADY_REGISTERED";
			break;
		}

		case RPC_S_TYPE_ALREADY_REGISTERED:
		{
			// 1712 The type universal unique identifier (UUID) has already been registered.  RPC_S_TYPE_ALREADY_REGISTERED
			pString = "RPC_S_TYPE_ALREADY_REGISTERED";
			break;
		}

		case RPC_S_ALREADY_LISTENING:
		{
			// 1713 The RPC server is already listening.  RPC_S_ALREADY_LISTENING
			pString = "RPC_S_ALREADY_LISTENING";
			break;
		}

		case RPC_S_NO_PROTSEQS_REGISTERED:
		{
			// 1714 No protocol sequences have been registered.  RPC_S_NO_PROTSEQS_REGISTERED
			pString = "RPC_S_NO_PROTSEQS_REGISTERED";
			break;
		}

		case RPC_S_NOT_LISTENING:
		{
			// 1715 The RPC server is not listening.  RPC_S_NOT_LISTENING
			pString = "RPC_S_NOT_LISTENING";
			break;
		}

		case RPC_S_UNKNOWN_MGR_TYPE:
		{
			// 1716 The manager type is unknown.  RPC_S_UNKNOWN_MGR_TYPE
			pString = "RPC_S_UNKNOWN_MGR_TYPE";
			break;
		}

		case RPC_S_UNKNOWN_IF:
		{
			// 1717 The interface is unknown.  RPC_S_UNKNOWN_IF
			pString = "RPC_S_UNKNOWN_IF";
			break;
		}

		case RPC_S_NO_BINDINGS:
		{
			// 1718 There are no bindings.  RPC_S_NO_BINDINGS
			pString = "RPC_S_NO_BINDINGS";
			break;
		}

		case RPC_S_NO_PROTSEQS:
		{
			// 1719 There are no protocol sequences.  RPC_S_NO_PROTSEQS
			pString = "RPC_S_NO_PROTSEQS";
			break;
		}

		case RPC_S_CANT_CREATE_ENDPOINT:
		{
			// 1720 The endpoint cannot be created.  RPC_S_CANT_CREATE_ENDPOINT
			pString = "RPC_S_CANT_CREATE_ENDPOINT";
			break;
		}

		case RPC_S_OUT_OF_RESOURCES:
		{
			// 1721 Not enough resources are available to complete this operation.  RPC_S_OUT_OF_RESOURCES
			pString = "RPC_S_OUT_OF_RESOURCES";
			break;
		}

		case RPC_S_SERVER_UNAVAILABLE:
		{
			// 1722 The RPC server is unavailable.  RPC_S_SERVER_UNAVAILABLE
			pString = "RPC_S_SERVER_UNAVAILABLE";
			break;
		}

		case RPC_S_SERVER_TOO_BUSY:
		{
			// 1723 The RPC server is too busy to complete this operation.  RPC_S_SERVER_TOO_BUSY
			pString = "RPC_S_SERVER_TOO_BUSY";
			break;
		}

		case RPC_S_INVALID_NETWORK_OPTIONS:
		{
			// 1724 The network options are invalid.  RPC_S_INVALID_NETWORK_OPTIONS
			pString = "RPC_S_INVALID_NETWORK_OPTIONS";
			break;
		}

		case RPC_S_NO_CALL_ACTIVE:
		{
			// 1725 There are no remote procedure calls active on this thread.  RPC_S_NO_CALL_ACTIVE
			pString = "RPC_S_NO_CALL_ACTIVE";
			break;
		}

		case RPC_S_CALL_FAILED:
		{
			// 1726 The remote procedure call failed.  RPC_S_CALL_FAILED
			pString = "RPC_S_CALL_FAILED";
			break;
		}

		case RPC_S_CALL_FAILED_DNE:
		{
			// 1727 The remote procedure call failed and did not execute.  RPC_S_CALL_FAILED_DNE
			pString = "RPC_S_CALL_FAILED_DNE";
			break;
		}

		case RPC_S_PROTOCOL_ERROR:
		{
			// 1728 A remote procedure call (RPC) protocol error occurred.  RPC_S_PROTOCOL_ERROR
			pString = "RPC_S_PROTOCOL_ERROR";
			break;
		}

		case RPC_S_UNSUPPORTED_TRANS_SYN:
		{
			// 1730 The transfer syntax is not supported by the RPC server.  RPC_S_UNSUPPORTED_TRANS_SYN
			pString = "RPC_S_UNSUPPORTED_TRANS_SYN";
			break;
		}

		case RPC_S_UNSUPPORTED_TYPE:
		{
			// 1732 The universal unique identifier (UUID) type is not supported.  RPC_S_UNSUPPORTED_TYPE
			pString = "RPC_S_UNSUPPORTED_TYPE";
			break;
		}

		case RPC_S_INVALID_TAG:
		{
			// 1733 The tag is invalid.  RPC_S_INVALID_TAG
			pString = "RPC_S_INVALID_TAG";
			break;
		}

		case RPC_S_INVALID_BOUND:
		{
			// 1734 The array bounds are invalid.  RPC_S_INVALID_BOUND
			pString = "RPC_S_INVALID_BOUND";
			break;
		}

		case RPC_S_NO_ENTRY_NAME:
		{
			// 1735 The binding does not contain an entry name.  RPC_S_NO_ENTRY_NAME
			pString = "RPC_S_NO_ENTRY_NAME";
			break;
		}

		case RPC_S_INVALID_NAME_SYNTAX:
		{
			// 1736 The name syntax is invalid.  RPC_S_INVALID_NAME_SYNTAX
			pString = "RPC_S_INVALID_NAME_SYNTAX";
			break;
		}

		case RPC_S_UNSUPPORTED_NAME_SYNTAX:
		{
			// 1737 The name syntax is not supported.  RPC_S_UNSUPPORTED_NAME_SYNTAX
			pString = "RPC_S_UNSUPPORTED_NAME_SYNTAX";
			break;
		}

		case RPC_S_UUID_NO_ADDRESS:
		{
			// 1739 No network address is available to use to construct a universal unique identifier (UUID).  RPC_S_UUID_NO_ADDRESS
			pString = "RPC_S_UUID_NO_ADDRESS";
			break;
		}

		case RPC_S_DUPLICATE_ENDPOINT:
		{
			// 1740 The endpoint is a duplicate.  RPC_S_DUPLICATE_ENDPOINT
			pString = "RPC_S_DUPLICATE_ENDPOINT";
			break;
		}

		case RPC_S_UNKNOWN_AUTHN_TYPE:
		{
			// 1741 The authentication type is unknown.  RPC_S_UNKNOWN_AUTHN_TYPE
			pString = "RPC_S_UNKNOWN_AUTHN_TYPE";
			break;
		}

		case RPC_S_MAX_CALLS_TOO_SMALL:
		{
			// 1742 The maximum number of calls is too small.  RPC_S_MAX_CALLS_TOO_SMALL
			pString = "RPC_S_MAX_CALLS_TOO_SMALL";
			break;
		}

		case RPC_S_STRING_TOO_LONG:
		{
			// 1743 The string is too long.  RPC_S_STRING_TOO_LONG
			pString = "RPC_S_STRING_TOO_LONG";
			break;
		}

		case RPC_S_PROTSEQ_NOT_FOUND:
		{
			// 1744 The RPC protocol sequence was not found.  RPC_S_PROTSEQ_NOT_FOUND
			pString = "RPC_S_PROTSEQ_NOT_FOUND";
			break;
		}

		case RPC_S_PROCNUM_OUT_OF_RANGE:
		{
			// 1745 The procedure number is out of range.  RPC_S_PROCNUM_OUT_OF_RANGE
			pString = "RPC_S_PROCNUM_OUT_OF_RANGE";
			break;
		}

		case RPC_S_BINDING_HAS_NO_AUTH:
		{
			// 1746 The binding does not contain any authentication information.  RPC_S_BINDING_HAS_NO_AUTH
			pString = "RPC_S_BINDING_HAS_NO_AUTH";
			break;
		}

		case RPC_S_UNKNOWN_AUTHN_SERVICE:
		{
			// 1747 The authentication service is unknown.  RPC_S_UNKNOWN_AUTHN_SERVICE
			pString = "RPC_S_UNKNOWN_AUTHN_SERVICE";
			break;
		}

		case RPC_S_UNKNOWN_AUTHN_LEVEL:
		{
			// 1748 The authentication level is unknown.  RPC_S_UNKNOWN_AUTHN_LEVEL
			pString = "RPC_S_UNKNOWN_AUTHN_LEVEL";
			break;
		}

		case RPC_S_INVALID_AUTH_IDENTITY:
		{
			// 1749 The security context is invalid.  RPC_S_INVALID_AUTH_IDENTITY
			pString = "RPC_S_INVALID_AUTH_IDENTITY";
			break;
		}

		case RPC_S_UNKNOWN_AUTHZ_SERVICE:
		{
			// 1750 The authorization service is unknown.  RPC_S_UNKNOWN_AUTHZ_SERVICE
			pString = "RPC_S_UNKNOWN_AUTHZ_SERVICE";
			break;
		}

		case EPT_S_INVALID_ENTRY:
		{
			// 1751 The entry is invalid.  EPT_S_INVALID_ENTRY
			pString = "EPT_S_INVALID_ENTRY";
			break;
		}

		case EPT_S_CANT_PERFORM_OP:
		{
			// 1752 The server endpoint cannot perform the operation.  EPT_S_CANT_PERFORM_OP
			pString = "EPT_S_CANT_PERFORM_OP";
			break;
		}

		case EPT_S_NOT_REGISTERED:
		{
			// 1753 There are no more endpoints available from the endpoint mapper.  EPT_S_NOT_REGISTERED
			pString = "EPT_S_NOT_REGISTERED";
			break;
		}

		case RPC_S_NOTHING_TO_EXPORT:
		{
			// 1754 No interfaces have been exported.  RPC_S_NOTHING_TO_EXPORT
			pString = "RPC_S_NOTHING_TO_EXPORT";
			break;
		}

		case RPC_S_INCOMPLETE_NAME:
		{
			// 1755 The entry name is incomplete.  RPC_S_INCOMPLETE_NAME
			pString = "RPC_S_INCOMPLETE_NAME";
			break;
		}

		case RPC_S_INVALID_VERS_OPTION:
		{
			// 1756 The version option is invalid.  RPC_S_INVALID_VERS_OPTION
			pString = "RPC_S_INVALID_VERS_OPTION";
			break;
		}

		case RPC_S_NO_MORE_MEMBERS:
		{
			// 1757 There are no more members.  RPC_S_NO_MORE_MEMBERS
			pString = "RPC_S_NO_MORE_MEMBERS";
			break;
		}

		case RPC_S_NOT_ALL_OBJS_UNEXPORTED:
		{
			// 1758 There is nothing to unexport.  RPC_S_NOT_ALL_OBJS_UNEXPORTED
			pString = "RPC_S_NOT_ALL_OBJS_UNEXPORTED";
			break;
		}

		case RPC_S_INTERFACE_NOT_FOUND:
		{
			// 1759 The interface was not found.  RPC_S_INTERFACE_NOT_FOUND
			pString = "RPC_S_INTERFACE_NOT_FOUND";
			break;
		}

		case RPC_S_ENTRY_ALREADY_EXISTS:
		{
			// 1760 The entry already exists.  RPC_S_ENTRY_ALREADY_EXISTS
			pString = "RPC_S_ENTRY_ALREADY_EXISTS";
			break;
		}

		case RPC_S_ENTRY_NOT_FOUND:
		{
			// 1761 The entry is not found.  RPC_S_ENTRY_NOT_FOUND
			pString = "RPC_S_ENTRY_NOT_FOUND";
			break;
		}

		case RPC_S_NAME_SERVICE_UNAVAILABLE:
		{
			// 1762 The name service is unavailable.  RPC_S_NAME_SERVICE_UNAVAILABLE
			pString = "RPC_S_NAME_SERVICE_UNAVAILABLE";
			break;
		}

		case RPC_S_INVALID_NAF_ID:
		{
			// 1763 The network address family is invalid.  RPC_S_INVALID_NAF_ID
			pString = "RPC_S_INVALID_NAF_ID";
			break;
		}

		case RPC_S_CANNOT_SUPPORT:
		{
			// 1764 The requested operation is not supported.  RPC_S_CANNOT_SUPPORT
			pString = "RPC_S_CANNOT_SUPPORT";
			break;
		}

		case RPC_S_NO_CONTEXT_AVAILABLE:
		{
			// 1765 No security context is available to allow impersonation.  RPC_S_NO_CONTEXT_AVAILABLE
			pString = "RPC_S_NO_CONTEXT_AVAILABLE";
			break;
		}

		case RPC_S_INTERNAL_ERROR:
		{
			// 1766 An internal error occurred in a remote procedure call (RPC).  RPC_S_INTERNAL_ERROR
			pString = "RPC_S_INTERNAL_ERROR";
			break;
		}

		case RPC_S_ZERO_DIVIDE:
		{
			// 1767 The RPC server attempted an integer division by zero.  RPC_S_ZERO_DIVIDE
			pString = "RPC_S_ZERO_DIVIDE";
			break;
		}

		case RPC_S_ADDRESS_ERROR:
		{
			// 1768 An addressing error occurred in the RPC server.  RPC_S_ADDRESS_ERROR
			pString = "RPC_S_ADDRESS_ERROR";
			break;
		}

		case RPC_S_FP_DIV_ZERO:
		{
			// 1769 A floating-point operation at the RPC server caused a division by zero.  RPC_S_FP_DIV_ZERO
			pString = "RPC_S_FP_DIV_ZERO";
			break;
		}

		case RPC_S_FP_UNDERFLOW:
		{
			// 1770 A floating-point underflow occurred at the RPC server.  RPC_S_FP_UNDERFLOW
			pString = "RPC_S_FP_UNDERFLOW";
			break;
		}

		case RPC_S_FP_OVERFLOW:
		{
			// 1771 A floating-point overflow occurred at the RPC server.  RPC_S_FP_OVERFLOW
			pString = "RPC_S_FP_OVERFLOW";
			break;
		}

		case RPC_X_NO_MORE_ENTRIES:
		{
			// 1772 The list of RPC servers available for the binding of auto handles has been exhausted.  RPC_X_NO_MORE_ENTRIES
			pString = "RPC_X_NO_MORE_ENTRIES";
			break;
		}

		case RPC_X_SS_CHAR_TRANS_OPEN_FAIL:
		{
			// 1773 Unable to open the character translation table file.  RPC_X_SS_CHAR_TRANS_OPEN_FAIL
			pString = "RPC_X_SS_CHAR_TRANS_OPEN_FAIL";
			break;
		}

		case RPC_X_SS_CHAR_TRANS_SHORT_FILE:
		{
			// 1774 The file containing the character translation table has fewer than bytes.  RPC_X_SS_CHAR_TRANS_SHORT_FILE
			pString = "RPC_X_SS_CHAR_TRANS_SHORT_FILE";
			break;
		}

		case RPC_X_SS_IN_NULL_CONTEXT:
		{
			// 1775 A null context handle was passed from the client to the host during a remote procedure call.  RPC_X_SS_IN_NULL_CONTEXT
			pString = "RPC_X_SS_IN_NULL_CONTEXT";
			break;
		}

		case RPC_X_SS_CONTEXT_DAMAGED:
		{
			// 1777 The context handle changed during a remote procedure call.  RPC_X_SS_CONTEXT_DAMAGED
			pString = "RPC_X_SS_CONTEXT_DAMAGED";
			break;
		}

		case RPC_X_SS_HANDLES_MISMATCH:
		{
			// 1778 The binding handles passed to a remote procedure call do not match.  RPC_X_SS_HANDLES_MISMATCH
			pString = "RPC_X_SS_HANDLES_MISMATCH";
			break;
		}

		case RPC_X_SS_CANNOT_GET_CALL_HANDLE:
		{
			// 1779 The stub is unable to get the remote procedure call handle.  RPC_X_SS_CANNOT_GET_CALL_HANDLE
			pString = "RPC_X_SS_CANNOT_GET_CALL_HANDLE";
			break;
		}

		case RPC_X_NULL_REF_POINTER:
		{
			// 1780 A null reference pointer was passed to the stub.  RPC_X_NULL_REF_POINTER
			pString = "RPC_X_NULL_REF_POINTER";
			break;
		}

		case RPC_X_ENUM_VALUE_OUT_OF_RANGE:
		{
			// 1781 The enumeration value is out of range.  RPC_X_ENUM_VALUE_OUT_OF_RANGE
			pString = "RPC_X_ENUM_VALUE_OUT_OF_RANGE";
			break;
		}

		case RPC_X_BYTE_COUNT_TOO_SMALL:
		{
			// 1782 The byte count is too small.  RPC_X_BYTE_COUNT_TOO_SMALL
			pString = "RPC_X_BYTE_COUNT_TOO_SMALL";
			break;
		}

		case RPC_X_BAD_STUB_DATA:
		{
			// 1783 The stub received bad data.  RPC_X_BAD_STUB_DATA
			pString = "RPC_X_BAD_STUB_DATA";
			break;
		}

		case ERROR_INVALID_USER_BUFFER:
		{
			// 1784 The supplied user buffer is not valid for the requested operation.  ERROR_INVALID_USER_BUFFER
			pString = "ERROR_INVALID_USER_BUFFER";
			break;
		}

		case ERROR_UNRECOGNIZED_MEDIA:
		{
			// 1785 The disk media is not recognized. It may not be formatted.  ERROR_UNRECOGNIZED_MEDIA
			pString = "ERROR_UNRECOGNIZED_MEDIA";
			break;
		}

		case ERROR_NO_TRUST_LSA_SECRET:
		{
			// 1786 The workstation does not have a trust secret.  ERROR_NO_TRUST_LSA_SECRET
			pString = "ERROR_NO_TRUST_LSA_SECRET";
			break;
		}

		case ERROR_NO_TRUST_SAM_ACCOUNT:
		{
			// 1787 The SAM database on the Windows NT Server does not have a computer account for this workstation trust relationship.  ERROR_NO_TRUST_SAM_ACCOUNT
			pString = "ERROR_NO_TRUST_SAM_ACCOUNT";
			break;
		}

		case ERROR_TRUSTED_DOMAIN_FAILURE:
		{
			// 1788 The trust relationship between the primary domain and the trusted domain failed.  ERROR_TRUSTED_DOMAIN_FAILURE
			pString = "ERROR_TRUSTED_DOMAIN_FAILURE";
			break;
		}

		case ERROR_TRUSTED_RELATIONSHIP_FAILURE:
		{
			// 1789 The trust relationship between this workstation and the primary domain failed.  ERROR_TRUSTED_RELATIONSHIP_FAILURE
			pString = "ERROR_TRUSTED_RELATIONSHIP_FAILURE";
			break;
		}

		case ERROR_TRUST_FAILURE:
		{
			// 1790 The network logon failed.  ERROR_TRUST_FAILURE
			pString = "ERROR_TRUST_FAILURE";
			break;
		}

		case RPC_S_CALL_IN_PROGRESS:
		{
			// 1791 A remote procedure call is already in progress for this thread.  RPC_S_CALL_IN_PROGRESS
			pString = "RPC_S_CALL_IN_PROGRESS";
			break;
		}

		case ERROR_NETLOGON_NOT_STARTED:
		{
			// 1792 An attempt was made to logon, but the network logon service was not started.  ERROR_NETLOGON_NOT_STARTED
			pString = "ERROR_NETLOGON_NOT_STARTED";
			break;
		}

		case ERROR_ACCOUNT_EXPIRED:
		{
			// 1793 The user's account has expired.  ERROR_ACCOUNT_EXPIRED
			pString = "ERROR_ACCOUNT_EXPIRED";
			break;
		}

		case ERROR_REDIRECTOR_HAS_OPEN_HANDLES:
		{
			// 1794 The redirector is in use and cannot be unloaded.  ERROR_REDIRECTOR_HAS_OPEN_HANDLES
			pString = "ERROR_REDIRECTOR_HAS_OPEN_HANDLES";
			break;
		}

		case ERROR_PRINTER_DRIVER_ALREADY_INSTALLED:
		{
			// 1795 The specified printer driver is already installed.  ERROR_PRINTER_DRIVER_ALREADY_INSTALLED
			pString = "ERROR_PRINTER_DRIVER_ALREADY_INSTALLED";
			break;
		}

		case ERROR_UNKNOWN_PORT:
		{
			// 1796 The specified port is unknown.  ERROR_UNKNOWN_PORT
			pString = "ERROR_UNKNOWN_PORT";
			break;
		}

		case ERROR_UNKNOWN_PRINTER_DRIVER:
		{
			// 1797 The printer driver is unknown.  ERROR_UNKNOWN_PRINTER_DRIVER
			pString = "ERROR_UNKNOWN_PRINTER_DRIVER";
			break;
		}

		case ERROR_UNKNOWN_PRINTPROCESSOR:
		{
			// 1798 The print processor is unknown.  ERROR_UNKNOWN_PRINTPROCESSOR
			pString = "ERROR_UNKNOWN_PRINTPROCESSOR";
			break;
		}

		case ERROR_INVALID_SEPARATOR_FILE:
		{
			// 1799 The specified separator file is invalid.  ERROR_INVALID_SEPARATOR_FILE
			pString = "ERROR_INVALID_SEPARATOR_FILE";
			break;
		}

		case ERROR_INVALID_PRIORITY:
		{
			// 1800 The specified priority is invalid.  ERROR_INVALID_PRIORITY
			pString = "ERROR_INVALID_PRIORITY";
			break;
		}

		case ERROR_INVALID_PRINTER_NAME:
		{
			// 1801 The printer name is invalid.  ERROR_INVALID_PRINTER_NAME
			pString = "ERROR_INVALID_PRINTER_NAME";
			break;
		}

		case ERROR_PRINTER_ALREADY_EXISTS:
		{
			// 1802 The printer already exists.  ERROR_PRINTER_ALREADY_EXISTS
			pString = "ERROR_PRINTER_ALREADY_EXISTS";
			break;
		}

		case ERROR_INVALID_PRINTER_COMMAND:
		{
			// 1803 The printer command is invalid.  ERROR_INVALID_PRINTER_COMMAND
			pString = "ERROR_INVALID_PRINTER_COMMAND";
			break;
		}

		case ERROR_INVALID_DATATYPE:
		{
			// 1804 The specified datatype is invalid.  ERROR_INVALID_DATATYPE
			pString = "ERROR_INVALID_DATATYPE";
			break;
		}

		case ERROR_INVALID_ENVIRONMENT:
		{
			// 1805 The environment specified is invalid.  ERROR_INVALID_ENVIRONMENT
			pString = "ERROR_INVALID_ENVIRONMENT";
			break;
		}

		case RPC_S_NO_MORE_BINDINGS:
		{
			// 1806 There are no more bindings.  RPC_S_NO_MORE_BINDINGS
			pString = "RPC_S_NO_MORE_BINDINGS";
			break;
		}

		case ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT:
		{
			// 1807 The account used is an interdomain trust account. Use your global user account or local user account to access this server.  ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT
			pString = "ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT";
			break;
		}

		case ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT:
		{
			// 1808 The account used is a computer account. Use your global user account or local user account to access this server.  ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT
			pString = "ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT";
			break;
		}

		case ERROR_NOLOGON_SERVER_TRUST_ACCOUNT:
		{
			// 1809 The account used is a server trust account. Use your global user account or local user account to access this server.  ERROR_NOLOGON_SERVER_TRUST_ACCOUNT
			pString = "ERROR_NOLOGON_SERVER_TRUST_ACCOUNT";
			break;
		}

		case ERROR_DOMAIN_TRUST_INCONSISTENT:
		{
			// 1810 The name or security ID (SID) of the domain specified is inconsistent with the trust information for that domain.  ERROR_DOMAIN_TRUST_INCONSISTENT
			pString = "ERROR_DOMAIN_TRUST_INCONSISTENT";
			break;
		}

		case ERROR_SERVER_HAS_OPEN_HANDLES:
		{
			// 1811 The server is in use and cannot be unloaded.  ERROR_SERVER_HAS_OPEN_HANDLES
			pString = "ERROR_SERVER_HAS_OPEN_HANDLES";
			break;
		}

		case ERROR_RESOURCE_DATA_NOT_FOUND:
		{
			// 1812 The specified image file did not contain a resource section.  ERROR_RESOURCE_DATA_NOT_FOUND
			pString = "ERROR_RESOURCE_DATA_NOT_FOUND";
			break;
		}

		case ERROR_RESOURCE_TYPE_NOT_FOUND:
		{
			// 1813 The specified resource type cannot be found in the image file.  ERROR_RESOURCE_TYPE_NOT_FOUND
			pString = "ERROR_RESOURCE_TYPE_NOT_FOUND";
			break;
		}

		case ERROR_RESOURCE_NAME_NOT_FOUND:
		{
			// 1814 The specified resource name cannot be found in the image file.  ERROR_RESOURCE_NAME_NOT_FOUND
			pString = "ERROR_RESOURCE_NAME_NOT_FOUND";
			break;
		}

		case ERROR_RESOURCE_LANG_NOT_FOUND:
		{
			// 1815 The specified resource language ID cannot be found in the image file.  ERROR_RESOURCE_LANG_NOT_FOUND
			pString = "ERROR_RESOURCE_LANG_NOT_FOUND";
			break;
		}

		case ERROR_NOT_ENOUGH_QUOTA:
		{
			// 1816 Not enough quota is available to process this command.  ERROR_NOT_ENOUGH_QUOTA
			pString = "ERROR_NOT_ENOUGH_QUOTA";
			break;
		}

		case RPC_S_NO_INTERFACES:
		{
			// 1817 No interfaces have been registered.  RPC_S_NO_INTERFACES
			pString = "RPC_S_NO_INTERFACES";
			break;
		}

		case RPC_S_CALL_CANCELLED:
		{
			// 1818 The remote procedure call was cancelled.  RPC_S_CALL_CANCELLED
			pString = "RPC_S_CALL_CANCELLED";
			break;
		}

		case RPC_S_BINDING_INCOMPLETE:
		{
			// 1819 The binding handle does not contain all required information.  RPC_S_BINDING_INCOMPLETE
			pString = "RPC_S_BINDING_INCOMPLETE";
			break;
		}

		case RPC_S_COMM_FAILURE:
		{
			// 1820 A communications failure occurred during a remote procedure call.  RPC_S_COMM_FAILURE
			pString = "RPC_S_COMM_FAILURE";
			break;
		}

		case RPC_S_UNSUPPORTED_AUTHN_LEVEL:
		{
			// 1821 The requested authentication level is not supported.  RPC_S_UNSUPPORTED_AUTHN_LEVEL
			pString = "RPC_S_UNSUPPORTED_AUTHN_LEVEL";
			break;
		}

		case RPC_S_NO_PRINC_NAME:
		{
			// 1822 No principal name registered.  RPC_S_NO_PRINC_NAME
			pString = "RPC_S_NO_PRINC_NAME";
			break;
		}

		case RPC_S_NOT_RPC_ERROR:
		{
			// 1823 The error specified is not a valid Windows RPC error code.  RPC_S_NOT_RPC_ERROR
			pString = "RPC_S_NOT_RPC_ERROR";
			break;
		}

		case RPC_S_UUID_LOCAL_ONLY:
		{
			// 1824 A UUID that is valid only on this computer has been allocated.  RPC_S_UUID_LOCAL_ONLY
			pString = "RPC_S_UUID_LOCAL_ONLY";
			break;
		}

		case RPC_S_SEC_PKG_ERROR:
		{
			// 1825 A security package specific error occurred.  RPC_S_SEC_PKG_ERROR
			pString = "RPC_S_SEC_PKG_ERROR";
			break;
		}

		case RPC_S_NOT_CANCELLED:
		{
			// 1826 Thread is not canceled.  RPC_S_NOT_CANCELLED
			pString = "RPC_S_NOT_CANCELLED";
			break;
		}

		case RPC_X_INVALID_ES_ACTION:
		{
			// 1827 Invalid operation on the encoding/decoding handle.  RPC_X_INVALID_ES_ACTION
			pString = "RPC_X_INVALID_ES_ACTION";
			break;
		}

		case RPC_X_WRONG_ES_VERSION:
		{
			// 1828 Incompatible version of the serializing package.  RPC_X_WRONG_ES_VERSION
			pString = "RPC_X_WRONG_ES_VERSION";
			break;
		}

		case RPC_X_WRONG_STUB_VERSION:
		{
			// 1829 Incompatible version of the RPC stub.  RPC_X_WRONG_STUB_VERSION
			pString = "RPC_X_WRONG_STUB_VERSION";
			break;
		}

		case RPC_X_INVALID_PIPE_OBJECT:
		{
			// 1830 The RPC pipe object is invalid or corrupted.  RPC_X_INVALID_PIPE_OBJECT
			pString = "RPC_X_INVALID_PIPE_OBJECT";
			break;
		}

		case RPC_X_WRONG_PIPE_ORDER:
		{
			// 1831 An invalid operation was attempted on an RPC pipe object.  RPC_X_WRONG_PIPE_ORDER
			pString = "RPC_X_WRONG_PIPE_ORDER";
			break;
		}

		case RPC_X_WRONG_PIPE_VERSION:
		{
			// 1832 Unsupported RPC pipe version.  RPC_X_WRONG_PIPE_VERSION
			pString = "RPC_X_WRONG_PIPE_VERSION";
			break;
		}

		case RPC_S_GROUP_MEMBER_NOT_FOUND:
		{
			// 1898 The group member was not found.  RPC_S_GROUP_MEMBER_NOT_FOUND
			pString = "RPC_S_GROUP_MEMBER_NOT_FOUND";
			break;
		}

		case EPT_S_CANT_CREATE:
		{
			// 1899 The endpoint mapper database entry could not be created.  EPT_S_CANT_CREATE
			pString = "EPT_S_CANT_CREATE";
			break;
		}

		case RPC_S_INVALID_OBJECT:
		{
			// 1900 The object universal unique identifier (UUID) is the nil UUID.  RPC_S_INVALID_OBJECT
			pString = "RPC_S_INVALID_OBJECT";
			break;
		}

		case ERROR_INVALID_TIME:
		{
			// 1901 The specified time is invalid.  ERROR_INVALID_TIME
			pString = "ERROR_INVALID_TIME";
			break;
		}

		case ERROR_INVALID_FORM_NAME:
		{
			// 1902 The specified form name is invalid.  ERROR_INVALID_FORM_NAME
			pString = "ERROR_INVALID_FORM_NAME";
			break;
		}

		case ERROR_INVALID_FORM_SIZE:
		{
			// 1903 The specified form size is invalid.  ERROR_INVALID_FORM_SIZE
			pString = "ERROR_INVALID_FORM_SIZE";
			break;
		}

		case ERROR_ALREADY_WAITING:
		{
			// 1904 The specified printer handle is already being waited on  ERROR_ALREADY_WAITING
			pString = "ERROR_ALREADY_WAITING";
			break;
		}

		case ERROR_PRINTER_DELETED:
		{
			// 1905 The specified printer has been deleted.  ERROR_PRINTER_DELETED
			pString = "ERROR_PRINTER_DELETED";
			break;
		}

		case ERROR_INVALID_PRINTER_STATE:
		{
			// 1906 The state of the printer is invalid.  ERROR_INVALID_PRINTER_STATE
			pString = "ERROR_INVALID_PRINTER_STATE";
			break;
		}

		case ERROR_PASSWORD_MUST_CHANGE:
		{
			// 1907 The user must change his password before he logs on the first time.  ERROR_PASSWORD_MUST_CHANGE
			pString = "ERROR_PASSWORD_MUST_CHANGE";
			break;
		}

		case ERROR_DOMAIN_CONTROLLER_NOT_FOUND:
		{
			// 1908 Could not find the domain controller for this domain.  ERROR_DOMAIN_CONTROLLER_NOT_FOUND
			pString = "ERROR_DOMAIN_CONTROLLER_NOT_FOUND";
			break;
		}

		case ERROR_ACCOUNT_LOCKED_OUT:
		{
			// 1909 The referenced account is currently locked out and may not be logged on to.  ERROR_ACCOUNT_LOCKED_OUT
			pString = "ERROR_ACCOUNT_LOCKED_OUT";
			break;
		}

		case OR_INVALID_OXID:
		{
			// 1910 The object exporter specified was not found.  OR_INVALID_OXID
			pString = "OR_INVALID_OXID";
			break;
		}

		case OR_INVALID_OID:
		{
			// 1911 The object specified was not found.  OR_INVALID_OID
			pString = "OR_INVALID_OID";
			break;
		}

		case OR_INVALID_SET:
		{
			// 1912 The object resolver set specified was not found.  OR_INVALID_SET
			pString = "OR_INVALID_SET";
			break;
		}

		case RPC_S_SEND_INCOMPLETE:
		{
			// 1913 Some data remains to be sent in the request buffer.  RPC_S_SEND_INCOMPLETE
			pString = "RPC_S_SEND_INCOMPLETE";
			break;
		}

		case RPC_S_INVALID_ASYNC_HANDLE:
		{
			// 1914 Invalid asynchronous remote procedure call handle.  RPC_S_INVALID_ASYNC_HANDLE
			pString = "RPC_S_INVALID_ASYNC_HANDLE";
			break;
		}

		case RPC_S_INVALID_ASYNC_CALL:
		{
			// 1915 Invalid asynchronous RPC call handle for this operation.  RPC_S_INVALID_ASYNC_CALL
			pString = "RPC_S_INVALID_ASYNC_CALL";
			break;
		}

		case RPC_X_PIPE_CLOSED:
		{
			// 1916 The RPC pipe object has already been closed.  RPC_X_PIPE_CLOSED
			pString = "RPC_X_PIPE_CLOSED";
			break;
		}

		case RPC_X_PIPE_DISCIPLINE_ERROR:
		{
			// 1917 The RPC call completed before all pipes were processed.  RPC_X_PIPE_DISCIPLINE_ERROR
			pString = "RPC_X_PIPE_DISCIPLINE_ERROR";
			break;
		}

		case RPC_X_PIPE_EMPTY:
		{
			// 1918 No more data is available from the RPC pipe.  RPC_X_PIPE_EMPTY
			pString = "RPC_X_PIPE_EMPTY";
			break;
		}

		case ERROR_NO_SITENAME:
		{
			// 1919 No site name is available for this machine.  ERROR_NO_SITENAME
			pString = "ERROR_NO_SITENAME";
			break;
		}

		case ERROR_CANT_ACCESS_FILE:
		{
			// 1920 The file can not be accessed by the system.  ERROR_CANT_ACCESS_FILE
			pString = "ERROR_CANT_ACCESS_FILE";
			break;
		}

		case ERROR_CANT_RESOLVE_FILENAME:
		{
			// 1921 The name of the file cannot be resolved by the system.  ERROR_CANT_RESOLVE_FILENAME
			pString = "ERROR_CANT_RESOLVE_FILENAME";
			break;
		}

		case ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY:
		{
			// 1922 The directory service evaluated group memberships locally.  ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY
			pString = "ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY";
			break;
		}

		case ERROR_DS_NO_ATTRIBUTE_OR_VALUE:
		{
			// 1923 The specified directory service attribute or value does not exist.  ERROR_DS_NO_ATTRIBUTE_OR_VALUE
			pString = "ERROR_DS_NO_ATTRIBUTE_OR_VALUE";
			break;
		}

		case ERROR_DS_INVALID_ATTRIBUTE_SYNTAX:
		{
			// 1924 The attribute syntax specified to the directory service is invalid.  ERROR_DS_INVALID_ATTRIBUTE_SYNTAX
			pString = "ERROR_DS_INVALID_ATTRIBUTE_SYNTAX";
			break;
		}

		case ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED:
		{
			// 1925 The attribute type specified to the directory service is not defined.  ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED
			pString = "ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED";
			break;
		}

		case ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS:
		{
			// 1926 The specified directory service attribute or value already exists.  ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS
			pString = "ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS";
			break;
		}

		case ERROR_DS_BUSY:
		{
			// 1927 The directory service is busy.  ERROR_DS_BUSY
			pString = "ERROR_DS_BUSY";
			break;
		}

		case ERROR_DS_UNAVAILABLE:
		{
			// 1928 The directory service is unavailable.  ERROR_DS_UNAVAILABLE
			pString = "ERROR_DS_UNAVAILABLE";
			break;
		}

		case ERROR_DS_NO_RIDS_ALLOCATED:
		{
			// 1929 The directory service was unable to allocate a relative identifier.  ERROR_DS_NO_RIDS_ALLOCATED
			pString = "ERROR_DS_NO_RIDS_ALLOCATED";
			break;
		}

		case ERROR_DS_NO_MORE_RIDS:
		{
			// 1930 The directory service has exhausted the pool of relative identifiers.  ERROR_DS_NO_MORE_RIDS
			pString = "ERROR_DS_NO_MORE_RIDS";
			break;
		}

		case ERROR_DS_INCORRECT_ROLE_OWNER:
		{
			// 1931 The requested operation could not be performed because the directory service is not the master for that type of operation.  ERROR_DS_INCORRECT_ROLE_OWNER
			pString = "ERROR_DS_INCORRECT_ROLE_OWNER";
			break;
		}

		case ERROR_DS_RIDMGR_INIT_ERROR:
		{
			// 1932 The directory service was unable to initialize the subsystem that allocates relative identifiers.  ERROR_DS_RIDMGR_INIT_ERROR
			pString = "ERROR_DS_RIDMGR_INIT_ERROR";
			break;
		}

		case ERROR_DS_OBJ_CLASS_VIOLATION:
		{
			// 1933 The requested operation did not satisfy one or more constraints associated with the class of the object.  ERROR_DS_OBJ_CLASS_VIOLATION
			pString = "ERROR_DS_OBJ_CLASS_VIOLATION";
			break;
		}

		case ERROR_DS_CANT_ON_NON_LEAF:
		{
			// 1934 The directory service can perform the requested operation only on a leaf object.  ERROR_DS_CANT_ON_NON_LEAF
			pString = "ERROR_DS_CANT_ON_NON_LEAF";
			break;
		}

		case ERROR_DS_CANT_ON_RDN:
		{
			// 1935 The directory service cannot perform the requested operation on the RDN attribute of an object.  ERROR_DS_CANT_ON_RDN
			pString = "ERROR_DS_CANT_ON_RDN";
			break;
		}

		case ERROR_DS_CANT_MOD_OBJ_CLASS:
		{
			// 1936 The directory service detected an attempt to modify the object class of an object.  ERROR_DS_CANT_MOD_OBJ_CLASS
			pString = "ERROR_DS_CANT_MOD_OBJ_CLASS";
			break;
		}

		case ERROR_DS_CROSS_DOM_MOVE_ERROR:
		{
			// 1937 The requested cross domain move operation could not be performed.  ERROR_DS_CROSS_DOM_MOVE_ERROR
			pString = "ERROR_DS_CROSS_DOM_MOVE_ERROR";
			break;
		}

		case ERROR_DS_GC_NOT_AVAILABLE:
		{
			// 1938 Unable to contact the global catalog server.  ERROR_DS_GC_NOT_AVAILABLE
			pString = "ERROR_DS_GC_NOT_AVAILABLE";
			break;
		}

		case ERROR_INVALID_PIXEL_FORMAT:
		{
			// 2000 The pixel format is invalid.  ERROR_INVALID_PIXEL_FORMAT
			pString = "ERROR_INVALID_PIXEL_FORMAT";
			break;
		}

		case ERROR_BAD_DRIVER:
		{
			// 2001 The specified driver is invalid.  ERROR_BAD_DRIVER
			pString = "ERROR_BAD_DRIVER";
			break;
		}

		case ERROR_INVALID_WINDOW_STYLE:
		{
			// 2002 The window style or class attribute is invalid for this operation.  ERROR_INVALID_WINDOW_STYLE
			pString = "ERROR_INVALID_WINDOW_STYLE";
			break;
		}

		case ERROR_METAFILE_NOT_SUPPORTED:
		{
			// 2003 The requested metafile operation is not supported.  ERROR_METAFILE_NOT_SUPPORTED
			pString = "ERROR_METAFILE_NOT_SUPPORTED";
			break;
		}

		case ERROR_TRANSFORM_NOT_SUPPORTED:
		{
			// 2004 The requested transformation operation is not supported.  ERROR_TRANSFORM_NOT_SUPPORTED
			pString = "ERROR_TRANSFORM_NOT_SUPPORTED";
			break;
		}

		case ERROR_CLIPPING_NOT_SUPPORTED:
		{
			// 2005 The requested clipping operation is not supported.  ERROR_CLIPPING_NOT_SUPPORTED
			pString = "ERROR_CLIPPING_NOT_SUPPORTED";
			break;
		}

		case ERROR_CONNECTED_OTHER_PASSWORD:
		{
			// 2108 The network connection was made successfully, but the user had to be prompted for a password other than the one originally specified.  ERROR_CONNECTED_OTHER_PASSWORD
			pString = "ERROR_CONNECTED_OTHER_PASSWORD";
			break;
		}

		case ERROR_BAD_USERNAME:
		{
			// 2202 The specified username is invalid.  ERROR_BAD_USERNAME
			pString = "ERROR_BAD_USERNAME";
			break;
		}

		case ERROR_NOT_CONNECTED:
		{
			// 2250 This network connection does not exist.  ERROR_NOT_CONNECTED
			pString = "ERROR_NOT_CONNECTED";
			break;
		}

		case ERROR_INVALID_CMM:
		{
			// 2300 The specified color management module is invalid.  ERROR_INVALID_CMM
			pString = "ERROR_INVALID_CMM";
			break;
		}

		case ERROR_INVALID_PROFILE:
		{
			// 2301 The specified color profile is invalid.  ERROR_INVALID_PROFILE
			pString = "ERROR_INVALID_PROFILE";
			break;
		}

		case ERROR_TAG_NOT_FOUND:
		{
			// 2302 The specified tag was not found.  ERROR_TAG_NOT_FOUND
			pString = "ERROR_TAG_NOT_FOUND";
			break;
		}

		case ERROR_TAG_NOT_PRESENT:
		{
			// 2303 A required tag is not present.  ERROR_TAG_NOT_PRESENT
			pString = "ERROR_TAG_NOT_PRESENT";
			break;
		}

		case ERROR_DUPLICATE_TAG:
		{
			// 2304 The specified tag is already present.  ERROR_DUPLICATE_TAG
			pString = "ERROR_DUPLICATE_TAG";
			break;
		}

		case ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE:
		{
			// 2305 The specified color profile is not associated with any device.  ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE
			pString = "ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE";
			break;
		}

		case ERROR_PROFILE_NOT_FOUND:
		{
			// 2306 The specified color profile was not found.  ERROR_PROFILE_NOT_FOUND
			pString = "ERROR_PROFILE_NOT_FOUND";
			break;
		}

		case ERROR_INVALID_COLORSPACE:
		{
			// 2307 The specified color space is invalid.  ERROR_INVALID_COLORSPACE
			pString = "ERROR_INVALID_COLORSPACE";
			break;
		}

		case ERROR_ICM_NOT_ENABLED:
		{
			// 2308 Image Color Management is not enabled.  ERROR_ICM_NOT_ENABLED
			pString = "ERROR_ICM_NOT_ENABLED";
			break;
		}

		case ERROR_DELETING_ICM_XFORM:
		{
			// 2309 There was an error while deleting the color transform.  ERROR_DELETING_ICM_XFORM
			pString = "ERROR_DELETING_ICM_XFORM";
			break;
		}

		case ERROR_INVALID_TRANSFORM:
		{
			// 2310 The specified color transform is invalid.  ERROR_INVALID_TRANSFORM
			pString = "ERROR_INVALID_TRANSFORM";
			break;
		}

		case ERROR_OPEN_FILES:
		{
			// 2401 This network connection has files open or requests pending.  ERROR_OPEN_FILES
			pString = "ERROR_OPEN_FILES";
			break;
		}

		case ERROR_ACTIVE_CONNECTIONS:
		{
			// 2402 Active connections still exist.  ERROR_ACTIVE_CONNECTIONS
			pString = "ERROR_ACTIVE_CONNECTIONS";
			break;
		}

		case ERROR_DEVICE_IN_USE:
		{
			// 2404 The device is in use by an active process and cannot be disconnected.  ERROR_DEVICE_IN_USE
			pString = "ERROR_DEVICE_IN_USE";
			break;
		}

		case ERROR_UNKNOWN_PRINT_MONITOR:
		{
			// 3000 The specified print monitor is unknown.  ERROR_UNKNOWN_PRINT_MONITOR
			pString = "ERROR_UNKNOWN_PRINT_MONITOR";
			break;
		}

		case ERROR_PRINTER_DRIVER_IN_USE:
		{
			// 3001 The specified printer driver is currently in use.  ERROR_PRINTER_DRIVER_IN_USE
			pString = "ERROR_PRINTER_DRIVER_IN_USE";
			break;
		}

		case ERROR_SPOOL_FILE_NOT_FOUND:
		{
			// 3002 The spool file was not found.  ERROR_SPOOL_FILE_NOT_FOUND
			pString = "ERROR_SPOOL_FILE_NOT_FOUND";
			break;
		}

		case ERROR_SPL_NO_STARTDOC:
		{
			// 3003 A StartDocPrinter call was not issued.  ERROR_SPL_NO_STARTDOC
			pString = "ERROR_SPL_NO_STARTDOC";
			break;
		}

		case ERROR_SPL_NO_ADDJOB:
		{
			// 3004 An AddJob call was not issued.  ERROR_SPL_NO_ADDJOB
			pString = "ERROR_SPL_NO_ADDJOB";
			break;
		}

		case ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED:
		{
			// 3005 The specified print processor has already been installed.  ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED
			pString = "ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED";
			break;
		}

		case ERROR_PRINT_MONITOR_ALREADY_INSTALLED:
		{
			// 3006 The specified print monitor has already been installed.  ERROR_PRINT_MONITOR_ALREADY_INSTALLED
			pString = "ERROR_PRINT_MONITOR_ALREADY_INSTALLED";
			break;
		}

		case ERROR_INVALID_PRINT_MONITOR:
		{
			// 3007 The specified print monitor does not have the required functions.  ERROR_INVALID_PRINT_MONITOR
			pString = "ERROR_INVALID_PRINT_MONITOR";
			break;
		}

		case ERROR_PRINT_MONITOR_IN_USE:
		{
			// 3008 The specified print monitor is currently in use.  ERROR_PRINT_MONITOR_IN_USE
			pString = "ERROR_PRINT_MONITOR_IN_USE";
			break;
		}

		case ERROR_PRINTER_HAS_JOBS_QUEUED:
		{
			// 3009 The requested operation is not allowed when there are jobs queued to the printer.  ERROR_PRINTER_HAS_JOBS_QUEUED
			pString = "ERROR_PRINTER_HAS_JOBS_QUEUED";
			break;
		}

		case ERROR_SUCCESS_REBOOT_REQUIRED:
		{
			// 3010 The requested operation is successful. Changes will not be effective until the system is rebooted.  ERROR_SUCCESS_REBOOT_REQUIRED
			pString = "ERROR_SUCCESS_REBOOT_REQUIRED";
			break;
		}

		case ERROR_SUCCESS_RESTART_REQUIRED:
		{
			// 3011 The requested operation is successful. Changes will not be effective until the service is restarted.  ERROR_SUCCESS_RESTART_REQUIRED
			pString = "ERROR_SUCCESS_RESTART_REQUIRED";
			break;
		}

		case ERROR_WINS_INTERNAL:
		{
			// 4000 WINS encountered an error while processing the command.  ERROR_WINS_INTERNAL
			pString = "ERROR_WINS_INTERNAL";
			break;
		}

		case ERROR_CAN_NOT_DEL_LOCAL_WINS:
		{
			// 4001 The local WINS can not be deleted.  ERROR_CAN_NOT_DEL_LOCAL_WINS
			pString = "ERROR_CAN_NOT_DEL_LOCAL_WINS";
			break;
		}

		case ERROR_STATIC_INIT:
		{
			// 4002 The importation from the file failed.  ERROR_STATIC_INIT
			pString = "ERROR_STATIC_INIT";
			break;
		}

		case ERROR_INC_BACKUP:
		{
			// 4003 The backup failed. Was a full backup done before?  ERROR_INC_BACKUP
			pString = "ERROR_INC_BACKUP";
			break;
		}

		case ERROR_FULL_BACKUP:
		{
			// 4004 The backup failed. Check the directory to which you are backing the database.  ERROR_FULL_BACKUP
			pString = "ERROR_FULL_BACKUP";
			break;
		}

		case ERROR_REC_NON_EXISTENT:
		{
			// 4005 The name does not exist in the WINS database.  ERROR_REC_NON_EXISTENT
			pString = "ERROR_REC_NON_EXISTENT";
			break;
		}

		case ERROR_RPL_NOT_ALLOWED:
		{
			// 4006 Replication with a nonconfigured partner is not allowed.  ERROR_RPL_NOT_ALLOWED
			pString = "ERROR_RPL_NOT_ALLOWED";
			break;
		}

		case ERROR_DHCP_ADDRESS_CONFLICT:
		{
			// 4100 The DHCP client has obtained an IP address that is already in use on the network. The local interface will be disabled until the DHCP client can obtain a new address.  ERROR_DHCP_ADDRESS_CONFLICT
			pString = "ERROR_DHCP_ADDRESS_CONFLICT";
			break;
		}

		case ERROR_WMI_GUID_NOT_FOUND:
		{
			// 4200 The GUID passed was not recognized as valid by a WMI data provider.  ERROR_WMI_GUID_NOT_FOUND
			pString = "ERROR_WMI_GUID_NOT_FOUND";
			break;
		}

		case ERROR_WMI_INSTANCE_NOT_FOUND:
		{
			// 4201 The instance name passed was not recognized as valid by a WMI data provider.  ERROR_WMI_INSTANCE_NOT_FOUND
			pString = "ERROR_WMI_INSTANCE_NOT_FOUND";
			break;
		}

		case ERROR_WMI_ITEMID_NOT_FOUND:
		{
			// 4202 The data item ID passed was not recognized as valid by a WMI data provider.  ERROR_WMI_ITEMID_NOT_FOUND
			pString = "ERROR_WMI_ITEMID_NOT_FOUND";
			break;
		}

		case ERROR_WMI_TRY_AGAIN:
		{
			// 4203 The WMI request could not be completed and should be retried.  ERROR_WMI_TRY_AGAIN
			pString = "ERROR_WMI_TRY_AGAIN";
			break;
		}

		case ERROR_WMI_DP_NOT_FOUND:
		{
			// 4204 The WMI data provider could not be located.  ERROR_WMI_DP_NOT_FOUND
			pString = "ERROR_WMI_DP_NOT_FOUND";
			break;
		}

		case ERROR_WMI_UNRESOLVED_INSTANCE_REF:
		{
			// 4205 The WMI data provider references an instance set that has not been registered.  ERROR_WMI_UNRESOLVED_INSTANCE_REF
			pString = "ERROR_WMI_UNRESOLVED_INSTANCE_REF";
			break;
		}

		case ERROR_WMI_ALREADY_ENABLED:
		{
			// 4206 The WMI data block or event notification has already been enabled.  ERROR_WMI_ALREADY_ENABLED
			pString = "ERROR_WMI_ALREADY_ENABLED";
			break;
		}

		case ERROR_WMI_GUID_DISCONNECTED:
		{
			// 4207 The WMI data block is no longer available.  ERROR_WMI_GUID_DISCONNECTED
			pString = "ERROR_WMI_GUID_DISCONNECTED";
			break;
		}

		case ERROR_WMI_SERVER_UNAVAILABLE:
		{
			// 4208 The WMI data service is not available.  ERROR_WMI_SERVER_UNAVAILABLE
			pString = "ERROR_WMI_SERVER_UNAVAILABLE";
			break;
		}

		case ERROR_WMI_DP_FAILED:
		{
			// 4209 The WMI data provider failed to carry out the request.  ERROR_WMI_DP_FAILED
			pString = "ERROR_WMI_DP_FAILED";
			break;
		}

		case ERROR_WMI_INVALID_MOF:
		{
			// 4210 The WMI MOF information is not valid.  ERROR_WMI_INVALID_MOF
			pString = "ERROR_WMI_INVALID_MOF";
			break;
		}

		case ERROR_WMI_INVALID_REGINFO:
		{
			// 4211 The WMI registration information is not valid.  ERROR_WMI_INVALID_REGINFO
			pString = "ERROR_WMI_INVALID_REGINFO";
			break;
		}

		case ERROR_INVALID_MEDIA:
		{
			// 4300 The media identifier does not represent a valid medium.  ERROR_INVALID_MEDIA
			pString = "ERROR_INVALID_MEDIA";
			break;
		}

		case ERROR_INVALID_LIBRARY:
		{
			// 4301 The library identifier does not represent a valid library.  ERROR_INVALID_LIBRARY
			pString = "ERROR_INVALID_LIBRARY";
			break;
		}

		case ERROR_INVALID_MEDIA_POOL:
		{
			// 4302 The media pool identifier does not represent a valid media pool.  ERROR_INVALID_MEDIA_POOL
			pString = "ERROR_INVALID_MEDIA_POOL";
			break;
		}

		case ERROR_DRIVE_MEDIA_MISMATCH:
		{
			// 4303 The drive and medium are not compatible or exist in different libraries.  ERROR_DRIVE_MEDIA_MISMATCH
			pString = "ERROR_DRIVE_MEDIA_MISMATCH";
			break;
		}

		case ERROR_MEDIA_OFFLINE:
		{
			// 4304 The medium currently exists in an offline library and must be online to perform this operation.  ERROR_MEDIA_OFFLINE
			pString = "ERROR_MEDIA_OFFLINE";
			break;
		}

		case ERROR_LIBRARY_OFFLINE:
		{
			// 4305 The operation cannot be performed on an offline library.  ERROR_LIBRARY_OFFLINE
			pString = "ERROR_LIBRARY_OFFLINE";
			break;
		}

		case ERROR_EMPTY:
		{
			// 4306 The library, drive, or media pool is empty.  ERROR_EMPTY
			pString = "ERROR_EMPTY";
			break;
		}

		case ERROR_NOT_EMPTY:
		{
			// 4307 The library, drive, or media pool must be empty to perform this operation.  ERROR_NOT_EMPTY
			pString = "ERROR_NOT_EMPTY";
			break;
		}

		case ERROR_MEDIA_UNAVAILABLE:
		{
			// 4308 No media is currently available in this media pool or library.  ERROR_MEDIA_UNAVAILABLE
			pString = "ERROR_MEDIA_UNAVAILABLE";
			break;
		}

		case ERROR_RESOURCE_DISABLED:
		{
			// 4309 A resource required for this operation is disabled.  ERROR_RESOURCE_DISABLED
			pString = "ERROR_RESOURCE_DISABLED";
			break;
		}

		case ERROR_INVALID_CLEANER:
		{
			// 4310 The media identifier does not represent a valid cleaner.  ERROR_INVALID_CLEANER
			pString = "ERROR_INVALID_CLEANER";
			break;
		}

		case ERROR_UNABLE_TO_CLEAN:
		{
			// 4311 The drive cannot be cleaned or does not support cleaning.  ERROR_UNABLE_TO_CLEAN
			pString = "ERROR_UNABLE_TO_CLEAN";
			break;
		}

		case ERROR_OBJECT_NOT_FOUND:
		{
			// 4312 The object identifier does not represent a valid object.  ERROR_OBJECT_NOT_FOUND
			pString = "ERROR_OBJECT_NOT_FOUND";
			break;
		}

		case ERROR_DATABASE_FAILURE:
		{
			// 4313 Unable to read from or write to the database.  ERROR_DATABASE_FAILURE
			pString = "ERROR_DATABASE_FAILURE";
			break;
		}

		case ERROR_DATABASE_FULL:
		{
			// 4314 The database is full.  ERROR_DATABASE_FULL
			pString = "ERROR_DATABASE_FULL";
			break;
		}

		case ERROR_MEDIA_INCOMPATIBLE:
		{
			// 4315 The medium is not compatible with the device or media pool.  ERROR_MEDIA_INCOMPATIBLE
			pString = "ERROR_MEDIA_INCOMPATIBLE";
			break;
		}

		case ERROR_RESOURCE_NOT_PRESENT:
		{
			// 4316 The resource required for this operation does not exist.  ERROR_RESOURCE_NOT_PRESENT
			pString = "ERROR_RESOURCE_NOT_PRESENT";
			break;
		}

		case ERROR_INVALID_OPERATION:
		{
			// 4317 The operation identifier is not valid.  ERROR_INVALID_OPERATION
			pString = "ERROR_INVALID_OPERATION";
			break;
		}

		case ERROR_MEDIA_NOT_AVAILABLE:
		{
			// 4318 The media is not mounted or ready for use.  ERROR_MEDIA_NOT_AVAILABLE
			pString = "ERROR_MEDIA_NOT_AVAILABLE";
			break;
		}

		case ERROR_DEVICE_NOT_AVAILABLE:
		{
			// 4319 The device is not ready for use.  ERROR_DEVICE_NOT_AVAILABLE
			pString = "ERROR_DEVICE_NOT_AVAILABLE";
			break;
		}

		case ERROR_REQUEST_REFUSED:
		{
			// 4320 The operator or administrator has refused the request.  ERROR_REQUEST_REFUSED
			pString = "ERROR_REQUEST_REFUSED";
			break;
		}

		case ERROR_FILE_OFFLINE:
		{
			// 4350 The remote storage service was not able to recall the file.  ERROR_FILE_OFFLINE
			pString = "ERROR_FILE_OFFLINE";
			break;
		}

		case ERROR_REMOTE_STORAGE_NOT_ACTIVE:
		{
			// 4351 The remote storage service is not operational at this time.  ERROR_REMOTE_STORAGE_NOT_ACTIVE
			pString = "ERROR_REMOTE_STORAGE_NOT_ACTIVE";
			break;
		}

		case ERROR_REMOTE_STORAGE_MEDIA_ERROR:
		{
			// 4352 The remote storage service encountered a media error.  ERROR_REMOTE_STORAGE_MEDIA_ERROR
			pString = "ERROR_REMOTE_STORAGE_MEDIA_ERROR";
			break;
		}

		case ERROR_NOT_A_REPARSE_POINT:
		{
			// 4390 The file or directory is not a reparse point.  ERROR_NOT_A_REPARSE_POINT
			pString = "ERROR_NOT_A_REPARSE_POINT";
			break;
		}

		case ERROR_REPARSE_ATTRIBUTE_CONFLICT:
		{
			// 4391 The reparse point attribute cannot be set because it conflicts with an existing attribute.  ERROR_REPARSE_ATTRIBUTE_CONFLICT
			pString = "ERROR_REPARSE_ATTRIBUTE_CONFLICT";
			break;
		}

		case ERROR_DEPENDENT_RESOURCE_EXISTS:
		{
			// 5001 The cluster resource cannot be moved to another group because other resources are dependent on it.  ERROR_DEPENDENT_RESOURCE_EXISTS
			pString = "ERROR_DEPENDENT_RESOURCE_EXISTS";
			break;
		}

		case ERROR_DEPENDENCY_NOT_FOUND:
		{
			// 5002 The cluster resource dependency cannot be found.  ERROR_DEPENDENCY_NOT_FOUND
			pString = "ERROR_DEPENDENCY_NOT_FOUND";
			break;
		}

		case ERROR_DEPENDENCY_ALREADY_EXISTS:
		{
			// 5003 The cluster resource cannot be made dependent on the specified resource because it is already dependent.  ERROR_DEPENDENCY_ALREADY_EXISTS
			pString = "ERROR_DEPENDENCY_ALREADY_EXISTS";
			break;
		}

		case ERROR_RESOURCE_NOT_ONLINE:
		{
			// 5004 The cluster resource is not online.  ERROR_RESOURCE_NOT_ONLINE
			pString = "ERROR_RESOURCE_NOT_ONLINE";
			break;
		}

		case ERROR_HOST_NODE_NOT_AVAILABLE:
		{
			// 5005 A cluster node is not available for this operation.  ERROR_HOST_NODE_NOT_AVAILABLE
			pString = "ERROR_HOST_NODE_NOT_AVAILABLE";
			break;
		}

		case ERROR_RESOURCE_NOT_AVAILABLE:
		{
			// 5006 The cluster resource is not available.  ERROR_RESOURCE_NOT_AVAILABLE
			pString = "ERROR_RESOURCE_NOT_AVAILABLE";
			break;
		}

		case ERROR_RESOURCE_NOT_FOUND:
		{
			// 5007 The cluster resource could not be found.  ERROR_RESOURCE_NOT_FOUND
			pString = "ERROR_RESOURCE_NOT_FOUND";
			break;
		}

		case ERROR_SHUTDOWN_CLUSTER:
		{
			// 5008 The cluster is being shut down.  ERROR_SHUTDOWN_CLUSTER
			pString = "ERROR_SHUTDOWN_CLUSTER";
			break;
		}

		case ERROR_CANT_EVICT_ACTIVE_NODE:
		{
			// 5009 A cluster node cannot be evicted from the cluster while it is online.  ERROR_CANT_EVICT_ACTIVE_NODE
			pString = "ERROR_CANT_EVICT_ACTIVE_NODE";
			break;
		}

		case ERROR_OBJECT_ALREADY_EXISTS:
		{
			// 5010 The object already exists.  ERROR_OBJECT_ALREADY_EXISTS
			pString = "ERROR_OBJECT_ALREADY_EXISTS";
			break;
		}

		case ERROR_OBJECT_IN_LIST:
		{
			// 5011 The object is already in the list.  ERROR_OBJECT_IN_LIST
			pString = "ERROR_OBJECT_IN_LIST";
			break;
		}

		case ERROR_GROUP_NOT_AVAILABLE:
		{
			// 5012 The cluster group is not available for any new requests.  ERROR_GROUP_NOT_AVAILABLE
			pString = "ERROR_GROUP_NOT_AVAILABLE";
			break;
		}

		case ERROR_GROUP_NOT_FOUND:
		{
			// 5013 The cluster group could not be found.  ERROR_GROUP_NOT_FOUND
			pString = "ERROR_GROUP_NOT_FOUND";
			break;
		}

		case ERROR_GROUP_NOT_ONLINE:
		{
			// 5014 The operation could not be completed because the cluster group is not online.  ERROR_GROUP_NOT_ONLINE
			pString = "ERROR_GROUP_NOT_ONLINE";
			break;
		}

		case ERROR_HOST_NODE_NOT_RESOURCE_OWNER:
		{
			// 5015 The cluster node is not the owner of the resource.  ERROR_HOST_NODE_NOT_RESOURCE_OWNER
			pString = "ERROR_HOST_NODE_NOT_RESOURCE_OWNER";
			break;
		}

		case ERROR_HOST_NODE_NOT_GROUP_OWNER:
		{
			// 5016 The cluster node is not the owner of the group.  ERROR_HOST_NODE_NOT_GROUP_OWNER
			pString = "ERROR_HOST_NODE_NOT_GROUP_OWNER";
			break;
		}

		case ERROR_RESMON_CREATE_FAILED:
		{
			// 5017 The cluster resource could not be created in the specified resource monitor.  ERROR_RESMON_CREATE_FAILED
			pString = "ERROR_RESMON_CREATE_FAILED";
			break;
		}

		case ERROR_RESMON_ONLINE_FAILED:
		{
			// 5018 The cluster resource could not be brought online by the resource monitor.  ERROR_RESMON_ONLINE_FAILED
			pString = "ERROR_RESMON_ONLINE_FAILED";
			break;
		}

		case ERROR_RESOURCE_ONLINE:
		{
			// 5019 The operation could not be completed because the cluster resource is online.  ERROR_RESOURCE_ONLINE
			pString = "ERROR_RESOURCE_ONLINE";
			break;
		}

		case ERROR_QUORUM_RESOURCE:
		{
			// 5020 The cluster resource could not be deleted or brought offline because it is the quorum resource.  ERROR_QUORUM_RESOURCE
			pString = "ERROR_QUORUM_RESOURCE";
			break;
		}

		case ERROR_NOT_QUORUM_CAPABLE:
		{
			// 5021 The cluster could not make the specified resource a quorum resource because it is not capable of being a quorum resource.  ERROR_NOT_QUORUM_CAPABLE
			pString = "ERROR_NOT_QUORUM_CAPABLE";
			break;
		}

		case ERROR_CLUSTER_SHUTTING_DOWN:
		{
			// 5022 The cluster software is shutting down.  ERROR_CLUSTER_SHUTTING_DOWN
			pString = "ERROR_CLUSTER_SHUTTING_DOWN";
			break;
		}

		case ERROR_INVALID_STATE:
		{
			// 5023 The group or resource is not in the correct state to perform the requested operation.  ERROR_INVALID_STATE
			pString = "ERROR_INVALID_STATE";
			break;
		}

		case ERROR_RESOURCE_PROPERTIES_STORED:
		{
			// 5024 The properties were stored but not all changes will take effect until the next time the resource is brought online.  ERROR_RESOURCE_PROPERTIES_STORED
			pString = "ERROR_RESOURCE_PROPERTIES_STORED";
			break;
		}

		case ERROR_NOT_QUORUM_CLASS:
		{
			// 5025 The cluster could not make the specified resource a quorum resource because it does not belong to a shared storage class.  ERROR_NOT_QUORUM_CLASS
			pString = "ERROR_NOT_QUORUM_CLASS";
			break;
		}

		case ERROR_CORE_RESOURCE:
		{
			// 5026 The cluster resource could not be deleted since it is a core resource.  ERROR_CORE_RESOURCE
			pString = "ERROR_CORE_RESOURCE";
			break;
		}

		case ERROR_QUORUM_RESOURCE_ONLINE_FAILED:
		{
			// 5027 The quorum resource failed to come online.  ERROR_QUORUM_RESOURCE_ONLINE_FAILED
			pString = "ERROR_QUORUM_RESOURCE_ONLINE_FAILED";
			break;
		}

		case ERROR_QUORUMLOG_OPEN_FAILED:
		{
			// 5028 The quorum log could not be created or mounted successfully.  ERROR_QUORUMLOG_OPEN_FAILED
			pString = "ERROR_QUORUMLOG_OPEN_FAILED";
			break;
		}

		case ERROR_CLUSTERLOG_CORRUPT:
		{
			// 5029 The cluster log is corrupt.  ERROR_CLUSTERLOG_CORRUPT
			pString = "ERROR_CLUSTERLOG_CORRUPT";
			break;
		}

		case ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE:
		{
			// 5030 The record could not be written to the cluster log since it exceeds the maximum size.  ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE
			pString = "ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE";
			break;
		}

		case ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE:
		{
			// 5031 The cluster log exceeds its maximum size.  ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE
			pString = "ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE";
			break;
		}

		case ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND:
		{
			// 5032 No checkpoint record was found in the cluster log.  ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND
			pString = "ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND";
			break;
		}

		case ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE:
		{
			// 5033 The minimum required disk space needed for logging is not available.  ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE
			pString = "ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE";
			break;
		}

		case ERROR_ENCRYPTION_FAILED:
		{
			// 6000 The specified file could not be encrypted.  ERROR_ENCRYPTION_FAILED
			pString = "ERROR_ENCRYPTION_FAILED";
			break;
		}

		case ERROR_DECRYPTION_FAILED:
		{
			// 6001 The specified file could not be decrypted.  ERROR_DECRYPTION_FAILED
			pString = "ERROR_DECRYPTION_FAILED";
			break;
		}

		case ERROR_FILE_ENCRYPTED:
		{
			// 6002 The specified file is encrypted and the user does not have the ability to decrypt it.  ERROR_FILE_ENCRYPTED
			pString = "ERROR_FILE_ENCRYPTED";
			break;
		}

		case ERROR_NO_RECOVERY_POLICY:
		{
			// 6003 There is no encryption recovery policy configured for this system.  ERROR_NO_RECOVERY_POLICY
			pString = "ERROR_NO_RECOVERY_POLICY";
			break;
		}

		case ERROR_NO_EFS:
		{
			// 6004 The required encryption driver is not loaded for this system.  ERROR_NO_EFS
			pString = "ERROR_NO_EFS";
			break;
		}

		case ERROR_WRONG_EFS:
		{
			// 6005 The file was encrypted with a different encryption driver than is currently loaded.  ERROR_WRONG_EFS
			pString = "ERROR_WRONG_EFS";
			break;
		}

		case ERROR_NO_USER_KEYS:
		{
			// 6006 There are no EFS keys defined for the user.  ERROR_NO_USER_KEYS
			pString = "ERROR_NO_USER_KEYS";
			break;
		}

		case ERROR_FILE_NOT_ENCRYPTED:
		{
			// 6007 The specified file is not encrypted.  ERROR_FILE_NOT_ENCRYPTED
			pString = "ERROR_FILE_NOT_ENCRYPTED";
			break;
		}

		case ERROR_NOT_EXPORT_FORMAT:
		{
			// 6008 The specified file is not in the defined EFS export format.  ERROR_NOT_EXPORT_FORMAT
			pString = "ERROR_NOT_EXPORT_FORMAT";
			break;
		}

		case ERROR_NO_BROWSER_SERVERS_FOUND:
		{
			// 6118 The list of servers for this workgroup is not currently available  ERROR_NO_BROWSER_SERVERS_FOUND
			pString = "ERROR_NO_BROWSER_SERVERS_FOUND";
			break;
		}

		default:
		{
			DPFX(DPFPREP, 0, "Unknown Win32 error code %u/0x%lx", Error, Error );

			DNASSERT( FALSE );

			pString = "Unknown Win32 error code!";
			break;
		}
	}

	return	pString;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// GetWinsockErrorString - convert system error to a string
//
// Entry:		Error code
//
// Exit:		Pointer to string
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "GetWinsockErrorString"

static	char	*GetWinsockErrorString( const DWORD WinsockError )
{
	char	*pString = NULL;


	// what was the error code?
	switch ( WinsockError )
	{
		case WSAEINTR:
		{
			pString = "WSAEINTR";
			break;
		}

		case WSAEBADF:
		{
			pString = "WSAEBADF";
			break;
		}

		case WSAEACCES:
		{
			pString = "WSAEACCES";
			break;
		}

		case WSAEFAULT:
		{
			pString = "WSAEFAULT";
			break;
		}

		case WSAEINVAL:
		{
			pString = "WSAEINVAL";
			break;
		}

		case WSAEMFILE:
		{
			pString = "WSAEMFILE";
			break;
		}

		case WSAEWOULDBLOCK:
		{
			pString = "WSAEWOULDBLOCK";
			break;
		}

		case WSAEINPROGRESS:
		{
			pString = "WSAEINPROGRESS";
			break;
		}

		case WSAEALREADY:
		{
			pString = "WSAEALREADY";
			break;
		}

		case WSAENOTSOCK:
		{
			pString = "WSAENOTSOCK";
			break;
		}

		case WSAEDESTADDRREQ:
		{
			pString = "WSAEDESTADDRREQ";
			break;
		}

		case WSAEMSGSIZE:
		{
			pString = "WSAEMSGSIZE";
			break;
		}

		case WSAEPROTOTYPE:
		{
			pString = "WSAEPROTOTYPE";
			break;
		}

		case WSAENOPROTOOPT:
		{
			pString = "WSAENOPROTOOPT";
			break;
		}

		case WSAEPROTONOSUPPORT:
		{
			pString = "WSAEPROTONOSUPPORT";
			break;
		}

		case WSAESOCKTNOSUPPORT:
		{
			pString = "WSAESOCKTNOSUPPORT";
			break;
		}

		case WSAEOPNOTSUPP:
		{
			pString = "WSAEOPNOTSUPP";
			break;
		}

		case WSAEPFNOSUPPORT:
		{
			pString = "WSAEPFNOSUPPORT";
			break;
		}

		case WSAEAFNOSUPPORT:
		{
			pString = "WSAEAFNOSUPPORT";
			break;
		}

		case WSAEADDRINUSE:
		{
			pString = "WSAEADDRINUSE";
			break;
		}

		case WSAEADDRNOTAVAIL:
		{
			pString = "WSAEADDRNOTAVAIL";
			break;
		}

		case WSAENETDOWN:
		{
			pString = "WSAENETDOWN";
			break;
		}

		case WSAENETUNREACH:
		{
			pString = "WSAENETUNREACH";
			break;
		}

		case WSAENETRESET:
		{
			pString = "WSAENETRESET";
			break;
		}

		case WSAECONNABORTED:
		{
			pString = "WSAECONNABORTED";
			break;
		}

		case WSAECONNRESET:
		{
			pString = "WSAECONNRESET";
			break;
		}

		case WSAENOBUFS:
		{
			pString = "WSAENOBUFS";
			break;
		}

		case WSAEISCONN:
		{
			pString = "WSAEISCONN";
			break;
		}

		case WSAENOTCONN:
		{
			pString = "WSAENOTCONN";
			break;
		}

		case WSAESHUTDOWN:
		{
			pString = "WSAESHUTDOWN";
			break;
		}

		case WSAETOOMANYREFS:
		{
			pString = "WSAETOOMANYREFS";
			break;
		}

		case WSAETIMEDOUT:
		{
			pString = "WSAETIMEDOUT";
			break;
		}

		case WSAECONNREFUSED:
		{
			pString = "WSAECONNREFUSED";
			break;
		}

		case WSAELOOP:
		{
			pString = "WSAELOOP";
			break;
		}

		case WSAENAMETOOLONG:
		{
			pString = "WSAENAMETOOLONG";
			break;
		}

		case WSAEHOSTDOWN:
		{
			pString = "WSAEHOSTDOWN";
			break;
		}

		case WSAEHOSTUNREACH:
		{
			pString = "WSAEHOSTUNREACH";
			break;
		}

		case WSAENOTEMPTY:
		{
			pString = "WSAENOTEMPTY";
			break;
		}

		case WSAEPROCLIM:
		{
			pString = "WSAEPROCLIM";
			break;
		}

		case WSAEUSERS:
		{
			pString = "WSAEUSERS";
			break;
		}

		case WSAEDQUOT:
		{
			pString = "WSAEDQUOT";
			break;
		}

		case WSAESTALE:
		{
			pString = "WSAESTALE";
			break;
		}

		case WSAEREMOTE:
		{
			pString = "WSAEREMOTE";
			break;
		}

		case WSASYSNOTREADY:
		{
			pString = "WSASYSNOTREADY";
			break;
		}

		case WSAVERNOTSUPPORTED:
		{
			pString = "WSAVERNOTSUPPORTED";
			break;
		}

		case WSANOTINITIALISED:
		{
			pString = "WSANOTINITIALISED";
			break;
		}

		case WSAEDISCON:
		{
			pString = "WSAEDISCON";
			break;
		}

		case WSAENOMORE:
		{
			pString = "WSAENOMORE";
			break;
		}

		case WSAECANCELLED:
		{
			pString = "WSAECANCELLED";
			break;
		}

		case WSAEINVALIDPROCTABLE:
		{
			pString = "WSAEINVALIDPROCTABLE";
			break;
		}

		case WSAEINVALIDPROVIDER:
		{
			pString = "WSAEINVALIDPROVIDER";
			break;
		}

		case WSAEPROVIDERFAILEDINIT:
		{
			pString = "WSAEPROVIDERFAILEDINIT";
			break;
		}

		case WSASYSCALLFAILURE:
		{
			pString = "WSASYSCALLFAILURE";
			break;
		}

		case WSASERVICE_NOT_FOUND:
		{
			pString = "WSASERVICE_NOT_FOUND";
			break;
		}

		case WSATYPE_NOT_FOUND:
		{
			pString = "WSATYPE_NOT_FOUND";
			break;
		}

		case WSA_E_NO_MORE:
		{
			pString = "WSA_E_NO_MORE";
			break;
		}

		case WSA_E_CANCELLED:
		{
			pString = "WSA_E_CANCELLED";
			break;
		}

		case WSAEREFUSED:
		{
			pString = "WSAEREFUSED";
			break;
		}

		/* Authoritative Answer: Host not found */
		case WSAHOST_NOT_FOUND:
		{
			pString = "WSAHOST_NOT_FOUND";
			break;
		}

		/* Non-Authoritative: Host not found, or SERVERFAIL */
		case WSATRY_AGAIN:
		{
			pString = "WSATRY_AGAIN";
			break;
		}

		/* Non-recoverable errors, FORMERR, REFUSED, NOTIMP */
		case WSANO_RECOVERY:
		{
			pString = "WSANO_RECOVERY";
			break;
		}

		/* Valid name, no data record of requested type */
		case WSANO_DATA:
		{
			pString = "WSANO_DATA";
			break;
		}

// same error value as WSANO_DATA
//		/* no address, look for MX record */
//		case WSANO_ADDRESS:
//		{
//			pString = "WSANO_ADDRESS";
//			break;
//		}

		/* at least one Reserve has arrived */
		case WSA_QOS_RECEIVERS:
		{
			pString = "WSA_QOS_RECEIVERS";
			break;
		}

		/* at least one Path has arrived */
		case WSA_QOS_SENDERS:
		{
			pString = "WSA_QOS_SENDERS";
			break;
		}

		/* there are no senders */
		case WSA_QOS_NO_SENDERS:
		{
			pString = "WSA_QOS_NO_SENDERS";
			break;
		}

		/* there are no receivers */
		case WSA_QOS_NO_RECEIVERS:
		{
			pString = "WSA_QOS_NO_RECEIVERS";
			break;
		}

		/* Reserve has been confirmed */
		case WSA_QOS_REQUEST_CONFIRMED:
		{
			pString = "WSA_QOS_REQUEST_CONFIRMED";
			break;
		}

		/* error due to lack of resources */
		case WSA_QOS_ADMISSION_FAILURE:
		{
			pString = "WSA_QOS_ADMISSION_FAILURE";
			break;
		}

		/* rejected for administrative reasons - bad credentials */
		case WSA_QOS_POLICY_FAILURE:
		{
			pString = "WSA_QOS_POLICY_FAILURE";
			break;
		}

		/* unknown or conflicting style */
		case WSA_QOS_BAD_STYLE:
		{
			pString = "WSA_QOS_BAD_STYLE";
			break;
		}

		/* problem with some part of the filterspec or providerspecific
		 * buffer in general */
		 case WSA_QOS_BAD_OBJECT:
		{
			pString = "WSA_QOS_BAD_OBJECT";
			break;
		}

		/* problem with some part of the flowspec */
		case WSA_QOS_TRAFFIC_CTRL_ERROR:
		{
			pString = "WSA_QOS_TRAFFIC_CTRL_ERROR";
			break;
		}

		/* general error */
		case WSA_QOS_GENERIC_ERROR:
		{
			pString = "WSA_QOS_GENERIC_ERROR";
			break;
		}

		default:
		{
			DPFX(DPFPREP, 0, "Unknown WinSock error code %u/0x%lx", WinsockError, WinsockError );

			DNASSERT( FALSE );

			pString = "Unknown WinSock error";
			break;
		}
	}

	return	pString;
}
//**********************************************************************



//
// Make this function appear under the modem provider spew
//
#undef DPF_SUBCOMP
#define DPF_SUBCOMP	DN_SUBCOMP_MODEM

//**********************************************************************
// ------------------------------
// LclDisplayTAPIMessage - display TAPI Message contents
//
// Entry:		output type
//				error level
//				pointer to TAPI message
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "LclDisplayTAPIMessage"
void	LclDisplayTAPIMessage( DN_OUT_TYPE OutputType, DWORD ErrorLevel, const LINEMESSAGE *const pLineMessage )
{
	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  ErrorLevel, "Message: hDevice: 0x%08x\tdwMessageID: 0x%08x\tdwCallbackInstance: 0x%p", pLineMessage->hDevice, pLineMessage->dwMessageID, pLineMessage->dwCallbackInstance );
	DPFX(DPFPREP,  ErrorLevel, "dwParam1: 0x%p\tdwParam2: 0x%p\tdwParam3: 0x%p", pLineMessage->dwParam1, pLineMessage->dwParam2, pLineMessage->dwParam3 );

	// what was the message?
	switch ( pLineMessage->dwMessageID )
	{
	    case LINE_ADDRESSSTATE:
	    {
	    	DPFX(DPFPREP,  ErrorLevel, "LINE_ADDRESSSTATE" );
	    	break;
	    }

	    case LINE_AGENTSPECIFIC:
	    {
	    	DPFX(DPFPREP,  ErrorLevel, "LINE_AGENTSPECIFIC" );
	    	break;
	    }

	    case LINE_AGENTSTATUS:
	    {
	    	DPFX(DPFPREP,  ErrorLevel, "LINE_AGENTSTATUS" );
	    	break;
	    }

	    case LINE_APPNEWCALL:
	    {
	    	DPFX(DPFPREP,  ErrorLevel, "LINE_APPNEWCALL" );
			// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
			DPFX(DPFPREP,  ErrorLevel, "Active line: 0x%08x\tCallback instance: 0x%p", pLineMessage->hDevice, pLineMessage->dwCallbackInstance );
	    	DPFX(DPFPREP,  ErrorLevel, "Line address: 0x%p\tNew handle: 0x%p\tPrivilege: 0x%p", pLineMessage->dwParam1, pLineMessage->dwParam2, pLineMessage->dwParam3 );

	    	DNASSERT( pLineMessage->dwParam3 == LINECALLPRIVILEGE_OWNER );
			DBG_CASSERT( sizeof( HCALL ) == sizeof( DWORD ) );
			DBG_CASSERT( sizeof( DWORD ) == sizeof( UINT ) );
			DNASSERT( pLineMessage->dwParam2 <= UINT_MAX );

			break;
	    }

	    case LINE_CALLINFO:
	    {
	    	DPFX(DPFPREP,  ErrorLevel, "LINE_CALLINFO" );
	    	break;
	    }

	    case LINE_CALLSTATE:
	    {
	    	DPFX(DPFPREP,  ErrorLevel, "LINE_CALLSTATE" );
	    	// what is the call state?
	    	switch ( pLineMessage->dwParam1 )
	    	{
	    		// The call is idle-no call actually exists.
	    		case LINECALLSTATE_IDLE:
	    		{
	    			DPFX(DPFPREP,  ErrorLevel, "LINECALLSTATE_IDLE" );
	    			break;
	    		}

	    		// The call is being offered to the station, signaling the arrival of a new call. In some environments, a call in the offering state does not automatically alert the user. Alerting is done by the switch instructing the line to ring; it does not affect any call states.
	    		case LINECALLSTATE_OFFERING:
	    		{
	    			DPFX(DPFPREP,  ErrorLevel, "LINECALLSTATE_OFFERING" );

	    			switch ( pLineMessage->dwParam2 )
	    			{
	    				// Indicates that the call is alerting at the current station (is accompanied by LINEDEVSTATE_RINGING messages), and if any application is set up to automatically answer, it may do so.
	    				// MSDN states that 0 is assumed to be LINEOFFERINGMODE_ACTIVE
	    				case 0:
	    				case LINEOFFERINGMODE_ACTIVE:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEOFFERINGMODE_ACTIVE" );
	    					break;
	    				}

	    				// Indicates that the call is being offered at more than one station, but the current station is not alerting (for example, it may be an attendant station where the offering status is advisory, such as blinking a light).
	    				case LINEOFFERINGMODE_INACTIVE:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEOFFERINGMODE_INACTIVE" );
	    					break;
	    				}

	    				default:
	    				{
	    					DNASSERT( FALSE );
	    					break;
	    				}
	    			}

	    			break;
	    		}

	    		// The call was offering and has been accepted. This indicates to other (monitoring) applications that the current owner application has claimed responsibility for answering the call. In ISDN, this also indicates that alerting to both parties has started.
	    		case LINECALLSTATE_ACCEPTED:
	    		{
	    			DPFX(DPFPREP,  ErrorLevel, "LINECALLSTATE_ACCEPTED" );
	    			break;
	    		}

	    		// The call is receiving a dial tone from the switch, which means that the switch is ready to receive a dialed number.
	    		case LINECALLSTATE_DIALTONE:
	    		{
	    			DPFX(DPFPREP,  ErrorLevel, "LINECALLSTATE_DIALTONE" );

	    			switch ( pLineMessage->dwParam2 )
	    			{
	    				// This is a "normal" dial tone, which typically is a continuous tone.
	    				case LINEDIALTONEMODE_NORMAL:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEDIALTONEMODE_NORMAL" );
	    					break;
	    				}

	    				// This is a special dial tone indicating that a certain condition is currently in effect.
	    				case LINEDIALTONEMODE_SPECIAL:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEDIALTONEMODE_SPECIAL" );
	    					break;
	    				}

	    				// This is an internal dial tone, as within a PBX.
	    				case LINEDIALTONEMODE_INTERNAL:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEDIALTONEMODE_INTERNAL" );
	    					break;
	    				}

	    				// This is an external (public network) dial tone.
	    				case LINEDIALTONEMODE_EXTERNAL:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEDIALTONEMODE_EXTERNAL" );
	    					break;
	    				}

	    				// The dial tone mode is currently unknown, but may become known later.
	    				case LINEDIALTONEMODE_UNKNOWN:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEDIALTONEMODE_UNKNOWN" );
	    					break;
	    				}

	    				// The dial tone mode is unavailable and cannot become known.
	    				case LINEDIALTONEMODE_UNAVAIL:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEDIALTONEMODE_UNAVAIL" );
	    					break;
	    				}

	    				default:
	    				{
	    					DNASSERT( FALSE );
	    					break;
	    				}
	    			}

	    			break;
	    		}

	    		// Destination address information (a phone number) is being sent to the switch over the call. Note that lineGenerateDigits does not place the line into the dialing state.
	    		case LINECALLSTATE_DIALING:
	    		{
	    			DPFX(DPFPREP,  ErrorLevel, "LINECALLSTATE_DIALING" );
	    			break;
	    		}

	    		// The call is receiving ringback from the called address. Ringback indicates that the other station has been reached and is being alerted.
	    		case LINECALLSTATE_RINGBACK:
	    		{
	    			DPFX(DPFPREP,  ErrorLevel, "LINECALLSTATE_RINGBACK" );
	    			break;
	    		}

	    		// The call is receiving a busy tone. Busy tone indicates that the call cannot be completedeither a circuit (trunk) or the remote party's station are in use.
	    		case LINECALLSTATE_BUSY:
	    		{
	    			DPFX(DPFPREP,  ErrorLevel, "LINECALLSTATE_BUSY" );

	    			switch ( pLineMessage->dwParam2 )
	    			{
	    				// The busy signal indicates that the called party's station is busy. This is usually signaled by means of a "normal" busy tone.
	    				case LINEBUSYMODE_STATION:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEBUSYMODE_STATION" );
	    					break;
	    				}

	    				// The busy signal indicates that a trunk or circuit is busy. This is usually signaled with a "long" busy tone.
	    				case LINEBUSYMODE_TRUNK:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEBUSYMODE_TRUNK" );
	    					break;
	    				}

	    				// The busy signal's specific mode is currently unknown, but may become known later.
	    				case LINEBUSYMODE_UNKNOWN:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEBUSYMODE_UNKNOWN" );
	    					break;
	    				}

	    				// The busy signal's specific mode is unavailable and cannot become known.
	    				case LINEBUSYMODE_UNAVAIL:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEBUSYMODE_UNAVAIL" );
	    					break;
	    				}

	    				default:
	    				{
	    					DNASSERT( FALSE );
	    					break;
	    				}
	    			}

	    			break;
	    		}

	    		// Special information is sent by the network. Special information is typically sent when the destination cannot be reached.
	    		case LINECALLSTATE_SPECIALINFO:
	    		{
	    			DPFX(DPFPREP,  ErrorLevel, "LINECALLSTATE_SPECIALINFO" );

	    			switch ( pLineMessage->dwParam2 )
	    			{
	    				// This special information tone precedes a "no circuit" or emergency announcement (trunk blockage category).
	    				case LINESPECIALINFO_NOCIRCUIT:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINESPECIALINFO_NOCIRCUIT" );
	    					break;
	    				}

	    				// This special information tone precedes a vacant number, AIS, Centrex number change and nonworking station, access code not dialed or dialed in error, or manual intercept operator message (customer irregularity category).
	    				case LINESPECIALINFO_CUSTIRREG:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINESPECIALINFO_CUSTIRREG" );
	    					break;
	    				}

	    				// This special information tone precedes a reorder announcement (equipment irregularity category).
	    				case LINESPECIALINFO_REORDER:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINESPECIALINFO_REORDER" );
	    					break;
	    				}

	    				// Specifics about the special information tone are currently unknown but may become known later.
	    				case LINESPECIALINFO_UNKNOWN:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINESPECIALINFO_UNKNOWN" );
	    					break;
	    				}

	    				// Specifics about the special information tone are unavailable and cannot become known.
	    				case LINESPECIALINFO_UNAVAIL:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINESPECIALINFO_UNAVAIL" );
	    					break;
	    				}

	    				default:
	    				{
	    					DNASSERT( FALSE );
	    					break;
	    				}
	    			}

	    			break;
	    		}

	    		// The call has been established and the connection is made. Information is able to flow over the call between the originating address and the destination address.
	    		case LINECALLSTATE_CONNECTED:
	    		{
	    			DPFX(DPFPREP,  ErrorLevel, "LINECALLSTATE_CONNECTED" );

	    			switch ( pLineMessage->dwParam2 )
	    			{
	    				// Indicates that the call is connected at the current station (the current station is a participant in the call).
	    				// case zero is supposed to be assumed 'Active'
	    				case 0:
	    				case LINECONNECTEDMODE_ACTIVE:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINECONNECTEDMODE_ACTIVE" );
	    					break;
	    				}

	    				// Indicates that the call is active at one or more other stations, but the current station is not a participant in the call.
	    				case LINECONNECTEDMODE_INACTIVE:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINECONNECTEDMODE_INACTIVE" );
	    					break;
	    				}

	    				// Indicates that the station is an active participant in the call, but that the remote party has placed the call on hold (the other party considers the call to be in the onhold state). Normally, such information is available only when both endpoints of the call fall within the same switching domain.
	    				case LINECONNECTEDMODE_ACTIVEHELD:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINECONNECTEDMODE_ACTIVEHELD" );
	    					break;
	    				}

	    				// Indicates that the station is not an active participant in the call, and that the remote party has placed the call on hold.
	    				case LINECONNECTEDMODE_INACTIVEHELD:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINECONNECTEDMODE_INACTIVEHELD" );
	    					break;
	    				}

	    				// Indicates that the service provider received affirmative notification that the call has entered the connected state (for example, through answer supervision or similar mechanisms).
	    				case LINECONNECTEDMODE_CONFIRMED:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINECONNECTEDMODE_CONFIRMED" );
	    					break;
	    				}
	    				default:
	    				{
	    					DNASSERT( FALSE );
	    					break;
	    				}
	    			}

	    			// note that we're connected
	    			DBG_CASSERT( sizeof( pLineMessage->hDevice ) == sizeof( HCALL ) );

	    			break;
	    		}

	    		// Dialing has completed and the call is proceeding through the switch or telephone network.
	    		case LINECALLSTATE_PROCEEDING:
	    		{
	    			DPFX(DPFPREP,  ErrorLevel, "LINECALLSTATE_PROCEEDING" );
	    			break;
	    		}

	    		// The call is on hold by the switch.
	    		case LINECALLSTATE_ONHOLD:
	    		{
	    			DPFX(DPFPREP,  ErrorLevel, "LINECALLSTATE_ONHOLD" );
	    			break;
	    		}

	    		// The call is currently a member of a multiparty conference call.
	    		case LINECALLSTATE_CONFERENCED:
	    		{
	    			DPFX(DPFPREP,  ErrorLevel, "LINECALLSTATE_CONFERENCED" );
	    			break;
	    		}

	    		// The call is currently on hold while it is being added to a conference.
	    		case LINECALLSTATE_ONHOLDPENDCONF:
	    		{
	    			DPFX(DPFPREP,  ErrorLevel, "LINECALLSTATE_ONHOLDPENDCONF" );
	    			break;
	    		}

	    		// The call is currently on hold awaiting transfer to another number.
	    		case LINECALLSTATE_ONHOLDPENDTRANSFER:
	    		{
	    			DPFX(DPFPREP,  ErrorLevel, "LINECALLSTATE_ONHOLDPENTRANSFER" );
	    			break;
	    		}

	    		// The remote party has disconnected from the call.
	    		case LINECALLSTATE_DISCONNECTED:
	    		{
	    			DPFX(DPFPREP,  ErrorLevel, "LINECALLSTATE_DISCONNECTED" );

	    			switch ( pLineMessage->dwParam2 )
	    			{

	    				// This is a "normal" disconnect request by the remote party, the call was terminated normally.
	    				case LINEDISCONNECTMODE_NORMAL:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEDISCONNECTMODE_NORMAL" );
	    					break;
	    				}

	    				// The reason for the disconnect request is unknown.
	    				case LINEDISCONNECTMODE_UNKNOWN:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEDISCONNECTMODE_UNKNOWN" );
	    					break;
	    				}

	    				// The remote user has rejected the call.
	    				case LINEDISCONNECTMODE_REJECT:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEDISCONNECTMODE_REJECT" );
	    					break;
	    				}

	    				// The call was picked up from elsewhere.
	    				case LINEDISCONNECTMODE_PICKUP:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEDISCONNECTMODE_PICKUP" );
	    					break;
	    				}

	    				// The call was forwarded by the switch.
	    				case LINEDISCONNECTMODE_FORWARDED:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEDISCONNECTMODE_FORWARDED" );
	    					break;
	    				}

	    				// The remote user's station is busy.
	    				case LINEDISCONNECTMODE_BUSY:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEDISCONNECTMODE_BUSY" );
	    					break;
	    				}

	    				// The remote user's station does not answer.
	    				case LINEDISCONNECTMODE_NOANSWER:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEDISCONNECTMODE_NOANSWER" );
	    					break;
	    				}

	    				// A dial tone was not detected within a service-provider defined timeout, at a point during dialing when one was expected (such as at a "W" in the dialable string). This can also occur without a service-provider-defined timeout period or without a value specified in the dwWaitForDialTone member of the LINEDIALPARAMS structure.
	    				case LINEDISCONNECTMODE_NODIALTONE:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEDISCONNECTMODE_NODIALTONE" );
	    					break;
	    				}

	    				// The destination address in invalid.
	    				case LINEDISCONNECTMODE_BADADDRESS:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEDISCONNECTMODE_BADADDRESS" );
	    					break;
	    				}

	    				// The remote user could not be reached.
	    				case LINEDISCONNECTMODE_UNREACHABLE:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEDISCONNECTMODE_UNREACHABLE" );
	    					break;
	    				}

	    				// The network is congested.
	    				case LINEDISCONNECTMODE_CONGESTION:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEDISCONNECTMODE_CONGESTION" );
	    					break;
	    				}

	    				// The remote user's station equipment is incompatible for the type of call requested.
	    				case LINEDISCONNECTMODE_INCOMPATIBLE:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEDISCONNECTMODE_INCOMPATIBLE" );
	    					break;
	    				}

	    				// The reason for the disconnect is unavailable and cannot become known later.
	    				case LINEDISCONNECTMODE_UNAVAIL:
	    				{
	    					DPFX(DPFPREP,  ErrorLevel, "LINEDISCONNECTMODE_UNAVAIL" );
	    					break;
	    				}

	    				default:
	    				{
	    					DNASSERT( FALSE );
	    					break;
	    				}
	    			}

	    			// note that we've disconnected
	    			DBG_CASSERT( sizeof( pLineMessage->hDevice ) == sizeof( HCALL ) );

	    			break;
	    		}

	    		// The state of the call is not known. This may be due to limitations of the call-progress detection implementation.
	    		case LINECALLSTATE_UNKNOWN:
	    		{
	    			DPFX(DPFPREP,  ErrorLevel, "LINECALLSTATE_UNKNOWN" );
	    			break;
	    		}
	    	}

	    	// what are our priveleges?
	    	switch ( pLineMessage->dwParam3 )
	    	{
	    		// no privilege change
	    		case 0:
	    		{
	    			break;
	    		}

	    		// we're now monitoring the call
	    		case LINECALLPRIVILEGE_MONITOR:
	    		{
	    			DPFX(DPFPREP,  ErrorLevel, "We're now monitoring the call" );
	    			break;
	    		}

	    		// we're now owning the call
	    		case LINECALLPRIVILEGE_OWNER:
	    		{
	    			DPFX(DPFPREP,  ErrorLevel, "We're now owner of the call" );
	    			break;
	    		}

	    		default:
	    		{
	    			// unknown privilege
	    			DNASSERT( FALSE );
	    			break;
	    		}
	    	}

	    	break;
	    }

	    case LINE_CLOSE:
	    {
	    	DPFX(DPFPREP,  ErrorLevel, "LINE_CLOSE" );
	    	break;
	    }

	    case LINE_DEVSPECIFIC:
	    {
	    	DPFX(DPFPREP,  ErrorLevel, "LINE_DEVSPECIFIC" );
	    	break;
	    }

	    case LINE_DEVSPECIFICFEATURE:
	    {
	    	DPFX(DPFPREP,  ErrorLevel, "LINE_DEVSPECIFICFEATURE" );
	    	break;
	    }

	    case LINE_GATHERDIGITS:
	    {
	    	DPFX(DPFPREP,  ErrorLevel, "LINE_GATHERDIGITS" );
	    	break;
	    }

	    case LINE_GENERATE:
	    {
	    	DPFX(DPFPREP,  ErrorLevel, "LINE_GENERATE" );
	    	break;
	    }

	    case LINE_LINEDEVSTATE:
	    {
	    	DPFX(DPFPREP,  ErrorLevel, "LINE_LINEDEVSTATE" );
	    	break;
	    }

	    case LINE_MONITORDIGITS:
	    {
	    	DPFX(DPFPREP,  ErrorLevel, "LINE_MONITORDIGITS" );
	    	break;
	    }

	    case LINE_MONITORMEDIA:
	    {
	    	DPFX(DPFPREP,  ErrorLevel, "LINE_MONITORMEDIA" );
	    	break;
	    }

	    case LINE_MONITORTONE:
	    {
	    	DPFX(DPFPREP,  ErrorLevel, "LINE_MONITORTONE" );
	    	break;
	    }

	    case LINE_REPLY:
	    {
	    	// dwDevice and dwParam3 are supposed to be zero
	    	DNASSERT( pLineMessage->hDevice == 0 );

	    	DPFX(DPFPREP,  ErrorLevel, "LINE_REPLY" );
	    	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
			DPFX(DPFPREP,  ErrorLevel, "hDevice: 0x%08x\tdwMessageID: 0x%08x\tdwCallbackInstance: 0x%p", pLineMessage->hDevice, pLineMessage->dwMessageID, pLineMessage->dwCallbackInstance );
	    	DPFX(DPFPREP,  ErrorLevel, "dwParam1: 0x%p\tdwParam2: 0x%p\tdwParam3: 0x%p", pLineMessage->dwParam1, pLineMessage->dwParam2, pLineMessage->dwParam3 );

	    	break;
	    }

	    case LINE_REQUEST:
	    {
	    	DPFX(DPFPREP,  ErrorLevel, "LINE_REQUEST" );
	    	break;
	    }

	    default:
	    {
			DPFX(DPFPREP, 0, "Unknown TAPI message %u/0x%lx", pLineMessage->dwMessageID, pLineMessage->dwMessageID );
	    	DNASSERT( FALSE );
	    	break;
	    }
	}

	return;
}
//**********************************************************************

#endif	// _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\dvcslock.h ===
/*==========================================================================
 * Copyright (C) 1999, 2000 Microsoft Corporation.  All Rights Reserved.
 *
 * File:       dvcslock.h
 * Content:    Class to handle auto-leave of critical sections
 * History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/05/00	rodtoll	Created It
 *
 ***************************************************************************/
#ifndef __DVCSLOCK_H
#define __DVCSLOCK_H

// CDVCSLock
//
// A class to provide automatic unlocking of critical sections when the object
// passes out of scope.
//
class CDVCSLock
{
public:
	CDVCSLock( DNCRITICAL_SECTION *pcs ): m_pcs( pcs ), m_fLocked( FALSE )
	{
	};

	~CDVCSLock() 
	{ 
		if( m_fLocked ) DNLeaveCriticalSection( m_pcs ); 
	}

	void Lock()
	{
		DNEnterCriticalSection( m_pcs );
		m_fLocked = TRUE;
	}

	void Unlock()
	{
		DNLeaveCriticalSection( m_pcs );
		m_fLocked = FALSE;
	}

private:

	DNCRITICAL_SECTION *m_pcs;
	BOOL m_fLocked;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\dndbg.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 - 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dndbg.c
 *  Content:	debug support for DirectPlay8
 *				
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  05-20-99	aarono	Created
 *  07-16-99	johnkan	Fixed include of OSInd.h, defined WSPRINTF macro
 *  07-19-99	vanceo	Explicitly declared OutStr as returning void for NT
 *						Build environment.
 *	07-22-99	a-evsch	Check for multiple Inits,  and release CritSec when DebugPrintf
 *						returns early.
 *	08-02-99	a-evsch	Added LOGPF support. LW entries only go into shared-file log
 *	08-31-99	johnkan	Removed include of <OSIND.H>
 *  02-17-00  	rodtoll	Added Memory / String validation routines
 *  05-23-00    RichGr  IA64: Changed some DWORDs to DWORD_PTRs to make va_arg work OK.
 *  07-16-00    jchauvin IA64:  Added %p parsing to change back to %x for Win9x machines in DebugPrintf, DebugPrintfNoLock, LogPrintf
 *  07-24-00    RichGr  IA64: As there's no separate build for Win9x, added code to detect Win9x for the %p parse-and-replace.
 *	07-29-00	masonb	Rewrite to add logging by subcomponent, perf improvements, process ID
 *	08/28/2000	masonb	Voice Merge: Modified asm in DebugPrintf to preserve registers that may have affected Voice
 *  03/29/2001  RichGr  If DPINST is defined for Performance Instrumentation, allow free build to pick up the code.
 *	
 *  Notes:
 *	
 *  Use /Oi compiler option for strlen()
 *
 ***************************************************************************/

#include "dncmni.h"
#include "memlog.h"
#include <tchar.h>

#if defined(DEBUG) || defined(DPINST)

void DebugPrintfInit(void);
void DebugPrintfFini(void);

// The constructor of this will be called prior to DllMain and the destructor
// after DllMain, so we can be assured of having the logging code properly
// initialized and deinitialized for the life of the module.
#ifdef DPINST
#define DEBUG_BREAK()      ALWAYS_BREAK()
#endif

struct _InitDbg
{
	_InitDbg() { DebugPrintfInit(); }
	~_InitDbg() { DebugPrintfFini(); }
} DbgInited;

//===============
// Debug  support
//===============

/*******************************************************************************
	This file contains support for the following types of logging:
		1. Logging to a VXD (Win9x only)
		2. Logging to a shared memory region
		3. Logging to the Debug Output
		4. FUTURE: Logging to a file

	General:
	========

	Debug Logging and playback is designed to operate on both Win9x and
	Windows NT (Windows 2000).  A shared file is used to capture information
	and can be played back using dp8log.exe.

	Under NT you can use the 'dt' command of NTSD to dump structures.  For
	example:

		dt DIRECTPLAYOBJECT <some memory address>

	will show all of the members of the DIRECTPLAYOBJECT structure at the
	specified address.  Some features are available only in post-Win2k
	versions of NTSD which can be obtained at http://dbg.

	Logging:
	========

	Debug Logging is controlled by settings in the WIN.INI file, under
	the section heading [DirectPlay8].  There are several settings:

	debug=9

	controls the default debug level.  All messages, at or below that debug level
	are printed.  You can control logging by each component specified in the
	g_rgszSubCompName member by adding its name to the end of the 'debug' setting:

	debug.addr=9

	sets the logging level for the addressing subcomponent to 9, leaving all
	others at either their specified level or the level specified by 'debug'
	if there is no specific level specified.

	The second setting controls where the log is seen.  If not specified, all
	debug logs are sent through the standard DebugPrint and will appear in a
	debugger if it is attached.

	log=0 {no debug output}
	log=1 {spew to console only}
	log=2 {spew to shared memory log only}
	log=3 {spew to console and shared memory log}

	This setting can also be divided by subcomponent, so:

	log=3
	log.protocol=2

	sends logs for the 'protocol' subcomponent to the shared memory log only, and
	all other logs to both locations.

	example win.ini...

	[DirectPlay8]
	Debug=7		; lots of spew
	log=2		; don't spew to debug window

	[DirectPlay8]
	Debug=0		; only fatal errors spewed to debug window

	Asserts:
	========
	Asserts are used to validate assumptions in the code.  For example
	if you know that the variable jojo should be > 700 and are depending
	on it in subsequent code, you SHOULD put an assert before the code
	that acts on that assumption.  The assert would look like:

	DNASSERT(jojo>700);

	Asserts generally will produce 3 lines of debug spew to highlight the
	breaking of the assumption.  You can add text to your asserts by ANDing:
	
	  DNASSERT(jojo>700 && "Jojo was too low");
	
	Will show the specified text when the assert occurs. For testing, you might
	want to set the system to break in on asserts.  This is done in the
	[DirectPlay8] section of WIN.INI by setting BreakOnAssert=TRUE:

	[DirectPlay8]
	Debug=0
	BreakOnAssert=1
	Verbose=1

	The Verbose setting enables logging of file, function, and line information.

	Debug Breaks:
	=============
	When something really severe happens and you want the system to break in
	so that you can debug it later, you should put a debug break in the code
	path.  Some people use the philosophy that all code paths must be
	verified by hand tracing each one in the debugger.  If you abide by this
	you should place a DEBUG_BREAK() in every code path and remove them
	from the source as you trace each.  When you have good coverage but
	some unhit paths (error conditions) you should force those paths in
	the debugger.

	Debug Logging to Shared Memory Region:
	======================================

	All processes will share the same memory region, and will log the specified amount
	of activity.  The log can be viewed with the DPLOG.EXE utility.

	Debug Logging to Debug Output:
	==============================
	This option uses OutputDebugString to log the specified amount of activity.

==============================================================================*/

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON


#define ASSERT_BUFFER_SIZE   8192
#define ASSERT_BANNER_STRING "************************************************************"
#define ASSERT_MESSAGE_LEVEL 0

#define WSPRINTF		wsprintfA
#define WVSPRINTF		wvsprintfA
#define PROF_SECT		"DirectPlay8"

DWORD g_dwMemLogNumEntries = 40000;		// Default Num entries for MEM log, settable in win.ini
DWORD g_dwMemLogLineSize = DPLOG_MAX_STRING;	// Default number of bytes per log entry

//
// Globals for shared memory based logging
//
HANDLE g_hMemLogFile = 0; // NOTE: This is 0 because CreateFileMapping returns 0 on failure
HANDLE g_hMemLogMutex = 0; // NOTE: This is 0 because CreateMutex returns 0 on failure
PSHARED_LOG_FILE g_pMemLog = 0;

BOOL g_fMemLogInited = FALSE;

DWORD g_fAssertGrabMutex = FALSE;

// Values for g_rgDestination
#define LOG_TO_DEBUG	1
#define LOG_TO_MEM		2
//#define LOG_TO_FILE		4 // NOTE: Currently unused

LPSTR g_rgszSubCompName[] =
{
	"UNK",		// DN_SUBCOMP_GLOBAL	0
	"CORE",		// DN_SUBCOMP_CORE		1
	"ADDR",		// DN_SUBCOMP_ADDR		2
	"LOBBY",	// DN_SUBCOMP_LOBBY		3
	"PROTOCOL", // DN_SUBCOMP_PROTOCOL	4
	"VOICE",	// DN_SUBCOMP_VOICE		5
	"DPNSVR",	// DN_SUBCOMP_DPNSVR	6
	"WSOCK",	// DN_SUBCOMP_WSOCK		7
	"MODEM",	// DN_SUBCOMP_MODEM		8
	"COMMON",	// DN_SUBCOMP_COMMON	9
	"NATHELP",	// DN_SUBCOMP_NATHELP	10
	"TOOLS",	// DN_SUBCOMP_TOOLS		11
	"MAX",		// DN_SUBCOMP_MAX		12 // NOTE: this should never get used, but
										  // is needed due to the way DebugPrintfInit
										  // is written, since it reads one past the end.
};

#define MAX_SUBCOMPS (sizeof(g_rgszSubCompName)/sizeof(g_rgszSubCompName[0]) - 1)
UINT g_rgLevel[MAX_SUBCOMPS] = {0};
UINT g_rgDestination[MAX_SUBCOMPS] = {LOG_TO_DEBUG | LOG_TO_MEM};
UINT g_rgBreakOnAssert[MAX_SUBCOMPS] = {1};// if non-zero, causes DEBUG_BREAK on false asserts.

// if TRUE, file/line/module information is printed and logged.
DWORD g_fLogFileAndLine = FALSE;	

//  7/24/00(RichGr) - IA64: If g_dwPlatformId == VER_PLATFORM_WIN32_WINDOWS,
//     we're running under Win9x.
DWORD g_dwPlatformId;


// Create a shared file for logging information on the fly
// This support allows the current log to be dumped from the
// user mode DP8LOG.EXE application.  This is useful when debugging
// in MSSTUDIO or in NTSD.  When the DP8LOG.EXE is invoke, note that
// the application will get halted until the log is completely dumped
// so it is best to dump the log to a file.

#undef DPF_MODNAME
#define DPF_MODNAME "InitMemLogString"
static BOOL InitMemLogString(VOID)
{
	if(!g_fMemLogInited)
	{
		BOOL fInitLogFile = TRUE;

		if (g_dwPlatformId == VER_PLATFORM_WIN32_NT)
		{
			g_hMemLogFile = CreateFileMapping(INVALID_HANDLE_VALUE, DNGetNullDacl(), PAGE_READWRITE, 0, (DPLOG_HEADERSIZE + (DPLOG_ENTRYSIZE*g_dwMemLogNumEntries)), _T("Global\\") BASE_LOG_MEMFILENAME);
		}
		else
		{
			g_hMemLogFile = CreateFileMapping(INVALID_HANDLE_VALUE, DNGetNullDacl(), PAGE_READWRITE, 0, (DPLOG_HEADERSIZE + (DPLOG_ENTRYSIZE*g_dwMemLogNumEntries)), BASE_LOG_MEMFILENAME);
		}
		if (!g_hMemLogFile)
		{
			return FALSE;
		}
		if (GetLastError() == ERROR_ALREADY_EXISTS)
		{
			fInitLogFile = FALSE;
		}

		if (g_dwPlatformId == VER_PLATFORM_WIN32_NT)
		{
			g_hMemLogMutex = CreateMutex(DNGetNullDacl(), FALSE, _T("Global\\") BASE_LOG_MUTEXNAME);
		}
		else
		{
			g_hMemLogMutex = CreateMutex(DNGetNullDacl(), FALSE, BASE_LOG_MUTEXNAME);
		}
		if (!g_hMemLogMutex)
		{
			CloseHandle(g_hMemLogFile);
			g_hMemLogFile = 0;
			return FALSE;
		}
		g_pMemLog = (PSHARED_LOG_FILE)MapViewOfFile(g_hMemLogFile, FILE_MAP_ALL_ACCESS,0,0,0);
		if (!g_pMemLog)
		{
			CloseHandle(g_hMemLogMutex);
			g_hMemLogMutex = 0;
			CloseHandle(g_hMemLogFile);
			g_hMemLogFile = 0;
			return FALSE;
		}

		// NOTE: The above 3 functions do return NULL in the case of a failure,
		// not INVALID_HANDLE_VALUE
		if (fInitLogFile)
		{
			g_pMemLog->nEntries = g_dwMemLogNumEntries;
			g_pMemLog->cbLine   = g_dwMemLogLineSize;
			g_pMemLog->iWrite   = 0;
		}
		else
		{
			// This happens when someone before us has already created the mem log.  Could be a previous DPlay instance or TestNet.
			g_dwMemLogNumEntries = g_pMemLog->nEntries;
			g_dwMemLogLineSize = g_pMemLog->cbLine;
		}

		if (g_dwMemLogNumEntries && g_dwMemLogLineSize)
		{
			g_fMemLogInited = TRUE;
		}
	}
	return g_fMemLogInited;
}

// Log a string to a shared file.  This file can be dumped using the
// DPLOG.EXE utility.
//
// dwLength does not include the '\0'
//
void MemLogString(LPCSTR str, size_t dwLength)
{
	PMEMLOG_ENTRY pEntry;
	size_t cbCopy;


	// If this isn't inited, InitMemLogString failed earlier
	if(!g_fMemLogInited)
	{
		return;
	}

	WaitForSingleObject(g_hMemLogMutex, INFINITE);

	pEntry = (PMEMLOG_ENTRY)(((PUCHAR)(g_pMemLog + 1)) + (g_pMemLog->iWrite * (sizeof(MEMLOG_ENTRY) + g_dwMemLogLineSize)));
	g_pMemLog->iWrite = (g_pMemLog->iWrite + 1) % g_dwMemLogNumEntries;

	ReleaseMutex(g_hMemLogMutex);

	pEntry->tLogged = GETTIMESTAMP();

	cbCopy = dwLength + 1;			// Add the terminating NULL
	if(cbCopy > g_dwMemLogLineSize)
	{
		cbCopy = g_dwMemLogLineSize;
	}
	memcpy(pEntry->str, str, cbCopy);
	pEntry->str[cbCopy-2] = '\n';		// Ensure we always end with a return
	pEntry->str[cbCopy-1] = '\0';			// Ensure we always NULL terminate
}

// DebugPrintfInit() - initialize DPF support.
void DebugPrintfInit()
{
    // Get platform information
	OSVERSIONINFO   OSVersionInfo = {0};
    OSVersionInfo.dwOSVersionInfoSize = sizeof OSVersionInfo;
    GetVersionEx(&OSVersionInfo);
    g_dwPlatformId = OSVersionInfo.dwPlatformId;

	BOOL fUsingMemLog = FALSE;

	CHAR szLevel[32] = {0};
	strcpy(szLevel, "debug");

	CHAR szDest[32] = {0};
	strcpy(szDest, "log");

	CHAR szBreak[32] = {0};
	strcpy(szBreak, "breakonassert");

	// Loop through all the subcomps, and get the level and destination for each
	for (int iSubComp = 0; iSubComp < sizeof(g_rgszSubCompName)/sizeof(g_rgszSubCompName[0]) - 1; iSubComp++)
	{
	    // NOTE: The setting under "debug" sets the default and will be used if you
		// don't specify settings for each subcomp
		g_rgLevel[iSubComp] = GetProfileIntA(PROF_SECT, szLevel, g_rgLevel[0]);
	    g_rgDestination[iSubComp] = GetProfileIntA(PROF_SECT, szDest, g_rgDestination[0]);
	    g_rgBreakOnAssert[iSubComp] = GetProfileIntA( PROF_SECT, szBreak, g_rgBreakOnAssert[0]);

		if (g_rgDestination[iSubComp] & LOG_TO_MEM)
		{
			fUsingMemLog = TRUE;
		}

		// Set up for the next subcomp
		strcpy(szLevel + 5, "."); // 5 is strlen of "debug", we are building debug.addr, etc.
		strcpy(szLevel + 6, g_rgszSubCompName[iSubComp + 1]);

		strcpy(szDest + 3, "."); // 3 is strlen of "log", we are building log.addr, etc.
		strcpy(szDest + 4, g_rgszSubCompName[iSubComp + 1]);

		strcpy(szBreak + 13, "."); // 13 is strlen of "breakonassert", we are building breakonassert.addr, etc.
		strcpy(szDest + 14, g_rgszSubCompName[iSubComp + 1]);
	}

    g_dwMemLogNumEntries = GetProfileIntA( PROF_SECT, "MemLogEntries", 40000);
    g_fLogFileAndLine = GetProfileIntA( PROF_SECT, "Verbose", 0);
    g_fAssertGrabMutex = GetProfileIntA( PROF_SECT, "AssertGrabMutex", 0);

	if (fUsingMemLog)
	{
		// Open the shared log file
		InitMemLogString();	
	}
}

// DebugPrintfFini() - release resources used by DPF support.
void DebugPrintfFini()
{
	if(g_pMemLog)
	{
		UnmapViewOfFile(g_pMemLog);
		g_pMemLog = NULL;
	}
	if(g_hMemLogMutex)
	{
		CloseHandle(g_hMemLogMutex);
		g_hMemLogMutex = 0;
	}
	if(g_hMemLogFile)
	{
		CloseHandle(g_hMemLogFile);
		g_hMemLogFile = 0;
	}
	g_fMemLogInited = FALSE;
}

void DebugPrintfX(LPCSTR szFile, DWORD dwLine, LPCSTR szModName, DWORD dwSubComp, DWORD dwDetail, ...)
{
	DNASSERT(dwSubComp < MAX_SUBCOMPS);

	if(g_rgLevel[dwSubComp] < dwDetail)
	{
		return;
	}
	
	CHAR  cMsg[ ASSERT_BUFFER_SIZE ];
	LPSTR szFormat;
    char  *psz = NULL;
	va_list argptr;
	LPSTR pszCursor = cMsg;

	va_start(argptr, dwDetail);
	szFormat = (LPSTR) va_arg(argptr, DWORD_PTR);

	cMsg[0] = 0;

//  IA64: If g_dwPlatformId == VER_PLATFORM_WIN32_WINDOWS,
//     we're running under Win9x and need to replace %p with %x.
//	TODO: Make this build specific, don't penalize NT
    if (g_dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
    {
		CHAR  cTemp[ ASSERT_BUFFER_SIZE ];
		
        strcpy(cTemp, szFormat);                // Copy to a local string that we can modify.
	    szFormat = cTemp;					    // Point szFormat at the local string

        while (psz = strstr(szFormat, "%p"))    // Look for each "%p".
           *(psz+1) = 'x';                      // Substitute 'x' for 'p'.  Don't try to expand
    }

	// Prints out / logs as:
	// 1. Verbose
	// subcomp:dwDetail:ProcessId:ThreadId:File:Function:Line:DebugString
	// e.g.
	// ADDR:2:0450:0378:(c:\somefile.cpp)BuildURLA(L25)Can you believe it?
	//
	// 2. Regular
	// subcomp:dwDetail:ProcessId:ThreadId:Function:DebugString

	strcpy(pszCursor, g_rgszSubCompName[dwSubComp]);
	pszCursor += strlen(pszCursor);

	pszCursor += WSPRINTF(pszCursor,":%1d:",dwDetail);

	pszCursor += WSPRINTF(pszCursor,"%04x:",GetCurrentProcessId());

	pszCursor += WSPRINTF(pszCursor,"%04x:",GetCurrentThreadId());

	if (g_fLogFileAndLine)
	{
		LPCSTR c;

		int i = strlen(szFile);
		if (i < 25)
		{
			c = szFile;
		}
		else
		{
			c = szFile + i - 25;
		}

		pszCursor += WSPRINTF(pszCursor,"(%s)(L%d)", c, dwLine);
	}

	pszCursor += WSPRINTF(pszCursor, "%s: ", szModName);

	pszCursor += WVSPRINTF(pszCursor, szFormat, argptr);

	strcpy(pszCursor, "\n");
	pszCursor += strlen(pszCursor);

	if(g_rgDestination[dwSubComp] & LOG_TO_DEBUG)
	{
		// log to debugger output
		OutputDebugStringA(cMsg);
	}

	if(g_rgDestination[dwSubComp] & LOG_TO_MEM)
	{
		// log to shared file, pass length not including '\0'
		MemLogString(cMsg, (DWORD) ((DWORD_PTR) (pszCursor - cMsg)));
	}	

	//if(g_rgDestination[dwSubComp] & LOG_TO_FILE)
	//{
	//}

	va_end(argptr);

	return;
}


//
// NOTE: I don't want to get into error checking for buffer overflows when
// trying to issue an assertion failure message. So instead I just allocate
// a buffer that is "bug enough" (I know, I know...)
//

void _DNAssert( LPCSTR szFile, DWORD dwLine, LPCSTR szFnName, DWORD dwSubComp, LPCSTR szCondition, DWORD dwLevel )
{
    char buffer[ASSERT_BUFFER_SIZE];


	// For level 1 we always print the message to the log, but we may not actually break.  For other levels
	// we either print and break or do neither.
	if (dwLevel <= g_rgBreakOnAssert[dwSubComp] || dwLevel == 1)
	{
		// Build the debug stream message
		WSPRINTF( buffer, "ASSERTION FAILED! File: %s Line: %d: %s", szFile, dwLine, szCondition);

		// Actually issue the message. These messages are considered error level
		// so they all go out at error level priority.

		DebugPrintfX(szFile, dwLine, szFnName, dwSubComp, ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );
		DebugPrintfX(szFile, dwLine, szFnName, dwSubComp, ASSERT_MESSAGE_LEVEL, buffer );
		DebugPrintfX(szFile, dwLine, szFnName, dwSubComp, ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );

		// Should we drop into the debugger?
		if(g_rgBreakOnAssert[dwSubComp])
		{
			// Don't let dpnsvr keep writing to the log
			if (g_hMemLogMutex && g_fAssertGrabMutex)
			{
				WaitForSingleObject(g_hMemLogMutex, INFINITE);
			}

			// Into the debugger we go...
			DEBUG_BREAK();

			if (g_hMemLogMutex && g_fAssertGrabMutex)
			{
				ReleaseMutex(g_hMemLogMutex);
			}
		}
	}
}

#endif //defined debug

BOOL IsValidStringA( const CHAR * const szString )
{
	return (!IsBadStringPtrA( szString, 0xFFFFFFFF ) );
}

BOOL IsValidStringW( const WCHAR * const  swzString )
{
	const wchar_t *szTmpLoc = swzString;
	
	if( swzString == NULL )
	{
		return FALSE;
	}
	
	_try
	{
		for( ; *szTmpLoc ; szTmpLoc++ );
	}
	_except( EXCEPTION_EXECUTE_HANDLER )
	{
		return FALSE;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\dneterrors.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DNetErrors.h
 *  Content:    Function for expanding DNet errors to debug output
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   12/04/98  johnkan	Created
 *   08/28/2000	masonb	Voice Merge: Fix for code that only defines one of DEBUG, DBG, _DEBUG
 *@@END_MSINTERNAL
 *
 ***************************************************************************/


#ifndef	__DNET_ERRORS_H__
#define	__DNET_ERRORS_H__

// Make sure all variations of DEBUG are defined if any one is
#if defined(DEBUG) || defined(DBG) || defined(_DEBUG)
#if !defined(DBG)
#define DBG
#endif
#if !defined(DEBUG)
#define DEBUG
#endif
#if !defined(_DEBUG)
#define _DEBUG
#endif
#endif

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// enumerated values for determining output destination
//
typedef	enum
{
	DPNERR_OUT_DEBUGGER
} DN_OUT_TYPE;

//
// enumerated values to determine error class
typedef	enum
{
	EC_DPLAY8,
	EC_INET,
	EC_TAPI,
	EC_WIN32,
	EC_WINSOCK

	// no entry for TAPI message output

} EC_TYPE;

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifdef	_DEBUG

	// where is the output going?
	#define	OUT_TYPE	DPNERR_OUT_DEBUGGER

	// ErrorLevel = DPF level for outputting errors
	// DNErrpr = DirectNet error code

	#define	DisplayString( ErrorLevel, String )			LclDisplayString( OUT_TYPE, ErrorLevel, String )
	#define	DisplayErrorCode( ErrorLevel, Win32Error )	LclDisplayError( EC_WIN32, OUT_TYPE, ErrorLevel, Win32Error )
	#define	DisplayDNError( ErrorLevel, DNError )		LclDisplayError( EC_DPLAY8, OUT_TYPE, ErrorLevel, DNError )
	#define	DisplayInetError( ErrorLevel, InetError )	LclDisplayError( EC_INET, OUT_TYPE, ErrorLevel, InetError )
	#define	DisplayTAPIError( ErrorLevel, TAPIError )	LclDisplayError( EC_TAPI, OUT_TYPE, ErrorLevel, TAPIError )
	#define	DisplayWinsockError( ErrorLevel, WinsockError )	LclDisplayError( EC_WINSOCK, OUT_TYPE, ErrorLevel, WinsockError )
	#define	DisplayTAPIMessage( ErrorLevel, pTAPIMessage )	LclDisplayTAPIMessage( OUT_TYPE, ErrorLevel, pTAPIMessage )

#else	// _DEBUG

	#define	DisplayString( ErrorLevel, String )
	#define	DisplayErrorCode( ErrorLevel, Win32Error )
	#define	DisplayDNError( ErrorLevel, DNError )
	#define	DisplayInetError( ErrorLevel, InetError )
	#define	DisplayTAPIError( ErrorLevel, TAPIError )
	#define	DisplayWinsockError( ErrorLevel, WinsockError )
	#define	DisplayTAPIMessage( ErrorLevel, pTAPIMessage )

#endif	// _DEBUG

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef struct linemessage_tag	LINEMESSAGE;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

#ifdef	__cplusplus
extern	"C"	{
#endif	// __cplusplus

#ifdef	_DEBUG

// don't call this function directly, use the 'DisplayDNError' macro
void	LclDisplayError( EC_TYPE ErrorType, DN_OUT_TYPE OutputType, DWORD ErrorLevel, HRESULT ErrorCode );
void	LclDisplayString( DN_OUT_TYPE OutputType, DWORD ErrorLevel, char *pString );
void	LclDisplayTAPIMessage( DN_OUT_TYPE OutputType, DWORD ErrorLevel, const LINEMESSAGE *const pLineMessage );

#endif

#ifdef	__cplusplus
}
#endif	// __cplusplus

#endif	// __DNET_ERRORS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\fpm.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fpm.h
 *  Content:	fixed size pool manager
 *
 *  History:
 *   Date		By		Reason
 *   ======		==		======
 *  12-18-97	aarono	Original
 *	11-06-98	ejs		Add custom handler for Release function
 *	04-12-99	jtk		Trimmed unused functions and parameters, added size assert
 *	11-22-99	jtk		Modified to be .CPP compiliant
 *	01-21-2000	jtk		Modified to use DNCriticalSections.  Added code to check for
 *						items already being in the pool.
 *  11-16/2000	rmt		Bug #40587 - DPVOICE: Mixing server needs to use multi-processors 
***************************************************************************/

#ifndef _FPM_H_
#define _FPM_H_

typedef struct FPOOL *PFPOOL, *LPFPOOL;

typedef BOOL (*FN_BLOCKINITALLOC)(void * pvItem);
typedef VOID (*FN_BLOCKINIT)(void * pvItem);
typedef VOID (*FN_BLOCKRELEASE)(void * pvItem);
typedef VOID (*FN_BLOCKFINI)(void *pvItem);

LPFPOOL FPM_Create(
	unsigned int		size,				// size of blocks in pool
	FN_BLOCKINITALLOC	fnBlockInitAlloc,	// fn called for each new alloc
	FN_BLOCKINIT		fnBlockInit,		// fn called each time block used
	FN_BLOCKRELEASE		fnBlockRelease,		// fn called each time block released
	FN_BLOCKFINI		fnBlockFini,			// fn called before releasing mem
	DWORD				*pdwOutstandingItems = NULL, 
	DWORD				*pdwTotalItems = NULL
	);

BOOL	FPM_Initialize( LPFPOOL				pPool,				// pointer to pool to initialize
						DWORD				dwElementSize,		// size of blocks in pool
						FN_BLOCKINITALLOC	fnBlockInitAlloc,	// fn called for each new alloc
						FN_BLOCKINIT		fnBlockInit,		// fn called each time block used
						FN_BLOCKRELEASE		fnBlockRelease,		// fn called each time block released
						FN_BLOCKFINI		fnBlockFini,			// fn called before releasing mem
						DWORD				*pdwOutstandingItems = NULL, // Memory location to write statistics to
						DWORD				*pdwTotalItems = NULL		// Memory location to write statistics to
						);

void	FPM_Deinitialize( LPFPOOL pPool, BOOL fAssertOnLeak = TRUE );

typedef void * (*FPM_GET)(LPFPOOL pPool);						// get new item from pool
typedef void   (*FPM_RELEASE)(LPFPOOL pPool, void *pvItem);		// return item to pool
typedef void   (*FPM_FINI)(LPFPOOL pPool, BOOL fAssertOnLeak = TRUE);						// close pool (this frees the pPool parameter!)

typedef struct FPOOL {
	// external
	FPM_GET		Get;
	FPM_RELEASE Release;
	FPM_FINI    Fini;

	// internal
	FN_BLOCKINITALLOC fnBlockInitAlloc;
	FN_BLOCKINIT      fnBlockInit;
	FN_BLOCKRELEASE	  fnBlockRelease;
	FN_BLOCKFINI      fnBlockFini;

	int		cbItemSize;
	void	*pPoolElements;
	int		nAllocated;
	int		nInUse;

	DNCRITICAL_SECTION cs;

	DWORD 	*pdwOutstandingItems;
	DWORD	*pdwTotalItems;

} FPOOL, *LPFPOOL, *PFPOOL;

#endif	// _FPM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\fpm.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       FPM.cpp
 *  Content:	fixed size pool manager
 *
 *  History:
 *   Date		By		Reason
 *   ======		==		======
 *  12-18-97	aarono	Original
 *	11-06-98	ejs		Add custom handler for Release function
 *	04-12-99	jtk		Trimmed unused functions and parameters, added size assert
 *	11-22-99	jtk		Converted to .CPP
 *	01-31-2000	jtk		Changed to use DNCriticalSections.  Added code to check
 *						for items already being in the pool on Release().
 *	04-11-2000	ejs		Put ASSERTs back into service.  They had been MACRO'd away to nothing
 *  11-16/2000	rmt		Bug #40587 - DPVOICE: Mixing server needs to use multi-processors
 ***************************************************************************/

#include "dncmni.h"
#include "fpm.h"


#define	DPMEM_ALLOC		DNMalloc
#define	DPMEM_FREE		DNFree
#define	ASSERT(X)		DNASSERT(X)


//#define	CHECK_FOR_DUPLICATE_FPM_RELEASE


//**********************************************************************
// ------------------------------
// FN_BOOL_DUMMY - place-holder function to return a Boolean
//
// Entry:		Pointer
//
// Exit:		Boolean
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"FN_BOOL_DUMMY"
BOOL FN_BOOL_DUMMY(void *pvItem)
{
	return TRUE;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// FN_VOID_DUMMY - place-holder function
//
// Entry:		Pointer
//
// Exit:		Boolean
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"FN_VOID_DUMMY"
VOID FN_VOID_DUMMY(void *pvItem)
{
	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// FPM_Get - get an item from the pool
//
// Entry:		Pointer to pool
//
// Exit:		Pointer to item
//				NULL = out of memory
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"FPM_Get"
void * FPM_Get( FPOOL *pPool )
{
	void * pvItem;

	DNEnterCriticalSection(&pPool->cs);

	DNASSERT(pPool->pPoolElements == 0 || !IsBadReadPtr(pPool->pPoolElements, sizeof(PVOID)));
	if(!pPool->pPoolElements){

		DNLeaveCriticalSection(&pPool->cs);
		pvItem = DPMEM_ALLOC(pPool->cbItemSize);

		if((pvItem) && !(*pPool->fnBlockInitAlloc)(pvItem) ){
			DPMEM_FREE(pvItem);
			pvItem=NULL;
		}

		DNEnterCriticalSection(&pPool->cs);

		if(pvItem){	
			pPool->nAllocated++;
			if( pPool->pdwTotalItems )
				(*pPool->pdwTotalItems)++;					
		}

	} else {
		pvItem=pPool->pPoolElements;
		pPool->pPoolElements=*((void **)pvItem);
		DNASSERT(pPool->pPoolElements == 0 || !IsBadReadPtr(pPool->pPoolElements, sizeof(PVOID)));
	}

	if(pvItem){

		pPool->nInUse++;
		if( pPool->pdwOutstandingItems )
			(*pPool->pdwOutstandingItems)++;		

		DNLeaveCriticalSection(&pPool->cs);

		(*pPool->fnBlockInit)(pvItem);

	}
	else {
		DNLeaveCriticalSection(&pPool->cs);
	}

	return pvItem;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// FPM_Release - return element to pool
//
// Entry:		Pointer to pool
//				Pointer to element
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"FPM_Release"
void FPM_Release( FPOOL *pPool, void *pvItem)
{
	(*pPool->fnBlockRelease)(pvItem);

	DNEnterCriticalSection(&pPool->cs);

#if defined(CHECK_FOR_DUPLICATE_FPM_RELEASE) && defined(DEBUG)
	{
		void	*pTemp;

		pTemp = pPool->pPoolElements;
		while ( pTemp != NULL )
		{
			DNASSERT( pTemp != pvItem );
			pTemp = *((void**)pTemp);
		}
	}
#endif	// CHECK_FOR_DUPLICATE_FPM_RELEASE

	pPool->nInUse--;

	if( pPool->pdwOutstandingItems )
		(*pPool->pdwOutstandingItems)--;

#ifdef NO_POOLS
	(*pPool->fnBlockFini)(pvItem);
	DPMEM_FREE(pvItem);
	pPool->nAllocated--;
#else
	*((void**)pvItem)=pPool->pPoolElements;
	pPool->pPoolElements=pvItem;
#endif

	DNASSERT(pPool->pPoolElements == 0 || !IsBadReadPtr(pPool->pPoolElements, sizeof(PVOID)));
	DNLeaveCriticalSection(&pPool->cs);
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// FPM_Fini - destroy pool
//
// Entry:		Pointer to pool
//
// Exit:		Nothing
//
// Note:		This function frees the pool memory, the pointer passed in is
//				then invalid!
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"FPM_Fini"
VOID FPM_Fini( FPOOL *pPool, BOOL fAssertOnLeak )
{
	FPM_Deinitialize( pPool, fAssertOnLeak );

	DPMEM_FREE( pPool );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// FPM_Deinitialize - deinitialize pool
//
// Entry:		Pointer to pool
//				Boolean to control if it should assert on a leak
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"FPM_Deinitialize"
VOID FPM_Deinitialize( FPOOL *pPool, BOOL fAssertOnLeak )
{
	void *pvItem;


	while(pPool->pPoolElements){
		pvItem = pPool->pPoolElements;
		pPool->pPoolElements=*((void **)pvItem);
		DNASSERT(pPool->pPoolElements == 0 || !IsBadReadPtr(pPool->pPoolElements, sizeof(PVOID)));
		(*pPool->fnBlockFini)(pvItem);
		DPMEM_FREE(pvItem);
		pPool->nAllocated--;
		if( pPool->pdwOutstandingItems )
			(*pPool->pdwOutstandingItems)--;
	}

	if( fAssertOnLeak )
	{
		if(pPool->nAllocated){
			ASSERT(0);
		}
	}
	
	DNDeleteCriticalSection(&pPool->cs);
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// FPM_Create - Allocate a new pool
//
// Entry:		Size of pool element
// 				Pointer to function for initializing element on alloc
// 				Pointer to function for initializing element on get
//				Pointer to function for deinitializing element on release
//				Pointer to function for deinitializing element on free
//
// Exit:		Pointer to new pool
//				NULL = out of memory
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"FPM_Create"
FPOOL	*FPM_Create( unsigned int 		size,
					 FN_BLOCKINITALLOC	fnBlockInitAlloc,
					 FN_BLOCKINIT		fnBlockInit,
					 FN_BLOCKRELEASE	fnBlockRelease,
					 FN_BLOCKFINI		fnBlockFini,
					 DWORD				*pdwOutstandingItems, 
  					 DWORD				*pdwTotalItems
					 )
{
	LPFPOOL pPool;


	pPool=static_cast<FPOOL*>( DPMEM_ALLOC( sizeof( *pPool ) ) );
	if ( pPool == NULL )
	{
	  return NULL;
	}

	if ( FPM_Initialize( pPool,					// pointer to fixed pool
						 size,					// size of pool element
						 fnBlockInitAlloc,		// pointer to function for initializing element on alloc
						 fnBlockInit,			// pointer to function for initializing element on get
						 fnBlockRelease,		// pointer to function for deinitializing element on release
						 fnBlockFini,			// pointer to function for deinitializing element on free
						 pdwOutstandingItems,
						 pdwTotalItems
						 ) == FALSE )
	{
		DPMEM_FREE( pPool );
		pPool = NULL;
	}

	return pPool;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// FPM_Initialize - initialize an instance of a pool
//
// Entry:		Pointer to pool
//				Size of pool element
// 				Pointer to function for initializing element on alloc
// 				Pointer to function for initializing element on get
//				Pointer to function for deinitializing element on release
//				Pointer to function for deinitializing element on free
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"FPM_Initialize"
BOOL	FPM_Initialize( LPFPOOL				pPool,				// pointer to pool to initialize
						DWORD				dwElementSize,		// size of blocks in pool
						FN_BLOCKINITALLOC	fnBlockInitAlloc,	// fn called for each new alloc
						FN_BLOCKINIT		fnBlockInit,		// fn called each time block used
						FN_BLOCKRELEASE		fnBlockRelease,		// fn called each time block released
						FN_BLOCKFINI		fnBlockFini,		// fn called before releasing mem
						DWORD				*pdwOutstandingItems, 
  		  			    DWORD				*pdwTotalItems
						)
{
	BOOL	fReturn;


	fReturn = TRUE;

	if ( DNInitializeCriticalSection(&pPool->cs) == FALSE )
	{
		fReturn = FALSE;
		goto Exit;
	}
	DebugSetCriticalSectionRecursionCount( &pPool->cs, 0 );

	pPool->pPoolElements      = NULL;
	pPool->nAllocated = 0;
	pPool->nInUse     = 0;
	pPool->pdwOutstandingItems = pdwOutstandingItems;
	pPool->pdwTotalItems = pdwTotalItems;

	if( pPool->pdwOutstandingItems )
		*(pPool->pdwOutstandingItems) = 0;

	if( pPool->pdwTotalItems )
		*(pPool->pdwTotalItems) = 0;

	if(fnBlockInitAlloc){
		pPool->fnBlockInitAlloc = fnBlockInitAlloc;
	} else {
		pPool->fnBlockInitAlloc = FN_BOOL_DUMMY;
	}
	if(fnBlockInit){
		pPool->fnBlockInit      = fnBlockInit;
	} else {
		pPool->fnBlockInit      = FN_VOID_DUMMY;
	}
	if(fnBlockRelease){
		pPool->fnBlockRelease	= fnBlockRelease;
	} else {
		pPool->fnBlockRelease	= FN_VOID_DUMMY;
	}
	if(fnBlockFini){
		pPool->fnBlockFini      = fnBlockFini;
	} else {
		pPool->fnBlockFini      = FN_VOID_DUMMY;
	}

	pPool->Get    = FPM_Get;
	pPool->Release= FPM_Release;
	pPool->Fini   = FPM_Fini;

	// FPM reuses the item memory as a linked list when not in use,
	// make sure the items are large enough
	ASSERT( dwElementSize >= sizeof( void* ) );
	pPool->cbItemSize = dwElementSize;

Exit:
	return	fReturn;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\guidutil.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       guidutil.h
 *  Content:    Some GUID related utility functions
 *
 *  History:
 *	Date   By  Reason
 *	============
 *	08/19/99	pnewson		created
 ***************************************************************************/

#ifndef _GUIDUTIL_H_
#define _GUIDUTIL_H_

#define GUID_STRING_LEN 39

HRESULT DVStringFromGUID(const GUID* lpguid, WCHAR* wszBuf, DWORD dwNumChars);
HRESULT DVGUIDFromString(const WCHAR* wszBuf, GUID* lpguid);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\guidutil.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       guidutil.cpp
 *  Content:    Some GUID related utility functions
 *
 *  History:
 *	Date   By  Reason
 *	============
 *	08/19/99	pnewson		created
 ***************************************************************************/

#include "dncmni.h"


#undef DPF_MODNAME
#define DPF_MODNAME "DVStringFromGUID"
HRESULT DVStringFromGUID(const GUID* lpguid, WCHAR* swzBuf, DWORD dwNumChars)
{
	if (dwNumChars < GUID_STRING_LEN)
	{
		return E_FAIL;
	}
	
    swprintf( 
    	swzBuf, 
    	L"{%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}", 
    	lpguid->Data1, 
    	lpguid->Data2, 
    	lpguid->Data3, 
        lpguid->Data4[0], 
        lpguid->Data4[1], 
        lpguid->Data4[2], 
        lpguid->Data4[3],
        lpguid->Data4[4], 
        lpguid->Data4[5], 
        lpguid->Data4[6], 
        lpguid->Data4[7] );
        
    return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVGUIDFromString"
HRESULT DVGUIDFromString(const WCHAR* wszBuf, GUID* lpguid)
{
    UINT aiTmp[10];

    if( swscanf( wszBuf, L"{%8X-%4X-%4X-%2X%2X-%2X%2X%2X%2X%2X%2X}",
                    &lpguid->Data1, 
                    &aiTmp[0], &aiTmp[1], 
                    &aiTmp[2], &aiTmp[3],
                    &aiTmp[4], &aiTmp[5],
                    &aiTmp[6], &aiTmp[7],
                    &aiTmp[8], &aiTmp[9] ) != 11 )
    {
    	ZeroMemory(lpguid, sizeof(GUID));
        return E_FAIL;
    }
    else
    {
        lpguid->Data2       = (USHORT) aiTmp[0];
        lpguid->Data3       = (USHORT) aiTmp[1];
        lpguid->Data4[0]    = (BYTE) aiTmp[2];
        lpguid->Data4[1]    = (BYTE) aiTmp[3];
        lpguid->Data4[2]    = (BYTE) aiTmp[4];
        lpguid->Data4[3]    = (BYTE) aiTmp[5];
        lpguid->Data4[4]    = (BYTE) aiTmp[6];
        lpguid->Data4[5]    = (BYTE) aiTmp[7];
        lpguid->Data4[6]    = (BYTE) aiTmp[8];
        lpguid->Data4[7]    = (BYTE) aiTmp[9];
        return S_OK;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\in_def.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		in_def.h
 *  Content:	Definition of common structs for voice instrumentation
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 02/17/2000	rodtoll	Created it
 ***************************************************************************/
#ifndef __IN_DEF_H
#define __IN_DEF_H

struct DVINSTRUMENT_INFO
{
	DVINSTRUMENT_INFO( DWORD dwLevel, DWORD dwDefaultLevel, const char *szProfileName ):	m_dwLevel(dwLevel), m_dwDefaultLevel(dwDefaultLevel), m_szProfileName(szProfileName) {};	
	DWORD	m_dwLevel;
	DWORD m_dwDefaultLevel;
	const char *m_szProfileName;
};

typedef DVINSTRUMENT_INFO *PDVINSTRUMENT_INFO;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\lockedcfpm.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       LockedCFPM.h
 *  Content:	fixed size pool manager for classes that has its own locking mechanism
 *
 *  History:
 *   Date		By		Reason
 *   ======		==		======
 *  12-18-97	aarono	Original
 *	11-06-98	ejs		Add custom handler for Release function
 *	04-12-99	jtk		Trimmed unused functions and parameters, added size assert
 *	01-31-2000	jtk		Added code to check for items already being in the pool on Release().
 *	02-09-2000	jtk		Dereived from ClassFPM.h
***************************************************************************/

#ifndef __LOCKED_CLASS_FPM_H__
#define __LOCKED_CLASS_FPM_H__

#include "dndbg.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	LOCKEDCFPM_BLANK_NODE_VALUE		0x5A5A817E

#define	CHECK_FOR_DUPLICATE_LOCKEDCFPM_RELEASE

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	OFFSETOF
// Macro to compute the offset of an element inside of a larger structure (copied from MSDEV's STDLIB.H)
#define OFFSETOF(s,m)	( (INT_PTR) &(((s *)0)->m) )
#define	__LOCAL_OFFSETOF_DEFINED__
#endif	// OFFSETOF

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definitions
//**********************************************************************

// class to act as a link in the pool
template< class T >
class	CLockedPoolNode
{
	public:
		CLockedPoolNode() { m_pNext = NULL; }
		~CLockedPoolNode() {};

		T			m_Item;
		CLockedPoolNode	*m_pNext;

	protected:
	private:
};

// class to manage the pool
template< class T >
class	CLockedFixedPool
{
	public:
		CLockedFixedPool();
		~CLockedFixedPool();

		BOOL	Initialize( void );
		void	Deinitialize( void );

		void	Lock( void ) { DNEnterCriticalSection( &m_Lock ); }
		void	Unlock( void ) { DNLeaveCriticalSection( &m_Lock ); }

		T		*Get( void );
		void	Release( T *const pItem );

	protected:

	private:
		DNCRITICAL_SECTION		m_Lock;			// critical section		
		CLockedPoolNode< T >	*m_pPool;		// pointer to list of available elements
		DEBUG_ONLY( UINT_PTR	m_uOutstandingItemCount );
		DEBUG_ONLY( BOOL		m_fInitialized );
};

//**********************************************************************
// Class function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedFixedPool::CLockedFixedPool - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CLockedFixedPool::CLockedFixedPool"

template< class T >
CLockedFixedPool< T >::CLockedFixedPool():m_pPool( NULL )
{
	DEBUG_ONLY( m_uOutstandingItemCount = 0 );
	DEBUG_ONLY( m_fInitialized = FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedFixedPool::~CLockedFixedPool - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CLockedFixedPool::~CLockedFixedPool"

template< class T >
CLockedFixedPool< T >::~CLockedFixedPool()
{
	DEBUG_ONLY( DNASSERT( m_uOutstandingItemCount == 0 ) );
	DEBUG_ONLY( DNASSERT( m_fInitialized == FALSE ) );
	while ( m_pPool != NULL )
	{
		CLockedPoolNode< T >	*pTemp;


		pTemp = m_pPool;
		m_pPool = m_pPool->m_pNext;
		delete	pTemp;
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedFixedPool::Initialize - initialize this pool
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CLockedFixedPool::Initialize"

template< class T >
BOOL	CLockedFixedPool< T >::Initialize( void )
{
	BOOL	fReturn;


	DEBUG_ONLY( DNASSERT( m_fInitialized == FALSE ) );
	fReturn = TRUE;
	if ( DNInitializeCriticalSection( &m_Lock ) == FALSE )
	{
		fReturn = FALSE;
	}
	else
	{
		DebugSetCriticalSectionRecursionCount( &m_Lock, 0 );
	}

	DEBUG_ONLY( m_fInitialized = TRUE );

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedFixedPool::Deinitialize - deinitialize pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CLockedFixedPool::Deinitialize"

template< class T >
void	CLockedFixedPool< T >::Deinitialize( void  )
{
	DNDeleteCriticalSection( &m_Lock );
	DEBUG_ONLY( m_fInitialized = FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedFixedPool::Get - get an item from the pool
//
// Entry:		Nothing
//
// Exit:		Pointer to item
//				NULL = out of memory
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CLockedFixedPool::Get"

template< class T >
T	*CLockedFixedPool< T >::Get( void )
{
	CLockedPoolNode< T >	*pNode;
	T	*pReturn;


	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );

	//
	// initialize
	//
	pReturn = NULL;

	Lock();

	//
	// If the pool is empty, create a new item.  If the pool isn't empty, use
	// the first item in the pool
	//
	if ( m_pPool == NULL )
	{
		pNode = new CLockedPoolNode< T >;
	}
	else
	{
		pNode = m_pPool;
		m_pPool = m_pPool->m_pNext;
	}
	Unlock();

	if ( pNode != NULL )
	{
		DEBUG_ONLY( pNode->m_pNext = (CLockedPoolNode<T>*) LOCKEDCFPM_BLANK_NODE_VALUE );
		pReturn = &pNode->m_Item;
		DEBUG_ONLY( m_uOutstandingItemCount++ );
	}

	return	 pReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedFixedPool::Release - return item to pool
//
// Entry:		Pointer to item
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CLockedFixedPool::Release"

template< class T >
void	CLockedFixedPool< T >::Release( T *const pItem )
{
	CLockedPoolNode< T >	*pNode;


	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );
	DNASSERT( pItem != NULL );
	DBG_CASSERT( sizeof( BYTE* ) == sizeof( pItem ) );
	DBG_CASSERT( sizeof( CLockedPoolNode< T >* ) == sizeof( BYTE* ) );
	pNode = reinterpret_cast<CLockedPoolNode< T >*>( &reinterpret_cast<BYTE*>( pItem )[ -OFFSETOF( CLockedPoolNode< T >, m_Item ) ] );

	Lock();
#if defined(CHECK_FOR_DUPLICATE_LOCKEDCFPM_RELEASE) && defined(DEBUG)
	{
		CLockedPoolNode< T >	*pTemp;


		pTemp = m_pPool;
		while ( pTemp != NULL )
		{
			DNASSERT( pTemp != pNode );
			pTemp = pTemp->m_pNext;
		}
	}
#endif	// CHECK_FOR_DUPLICATE_LOCKEDCFPM_RELEASE

	DNASSERT( pNode->m_pNext == (CLockedPoolNode< T >*)LOCKEDCFPM_BLANK_NODE_VALUE );

#ifdef NO_POOLS
	delete pNode;
#else
	pNode->m_pNext = m_pPool;
	m_pPool = pNode;
#endif

	DEBUG_ONLY( m_uOutstandingItemCount-- );

	Unlock();
}
//**********************************************************************

#ifdef	__LOCAL_OFFSETOF_DEFINED__
#undef	__LOCAL_OFFSETOF_DEFINED__
#undef	OFFSETOF
#endif	// __LOCAL_OFFSETOF_DEFINED__

#undef DPF_MODNAME
#undef DPF_SUBCOMP

#endif	// __LOCKED_CLASS_FPM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\lockedccfpm.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ContextCFPM.h
 *  Content:	fixed pool manager for classes that takes into account contexts
 *
 *  History:
 *   Date		By		Reason
 *   ======		==		======
 *  12-18-97	aarono	Original
 *	11-06-98	ejs		Add custom handler for Release function
 *	04-12-99	jtk		Trimmed unused functions and parameters, added size assert
 *	01-31-2000	jtk		Added code to check for items already being in the pool on Release().
 *	02-08-2000	jtk		Derived from ClassFPM.h
***************************************************************************/

#ifndef __CONTEXT_CLASS_FPM_H__
#define __CONTEXT_CLASS_FPM_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON

//**********************************************************************
// Constant definitions
//**********************************************************************

#ifdef	_WIN64
#define	BLANK_NODE_VALUE	0xAA55817E6D5C4B3A
#else	// _WIN64
#define	BLANK_NODE_VALUE	0xAA55817E
#endif	// _WIN64

#define	CHECK_FOR_DUPLICATE_LOCKEDCCFPM_RELEASE

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	OFFSETOF
// Macro to compute the offset of an element inside of a larger structure (copied from MSDEV's STDLIB.H)
#define OFFSETOF(s,m)	( (INT_PTR) &(((s *)0)->m) )
#define	__LOCAL_OFFSETOF_DEFINED__
#endif	// OFFSETOF

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definitions
//**********************************************************************

// class to act as a link in the pool
template< class T >
class	CLockedContextClassFPMPoolNode
{
	public:
		CLockedContextClassFPMPoolNode() { m_pNext = NULL; }
		~CLockedContextClassFPMPoolNode() {};

		CLockedContextClassFPMPoolNode	*m_pNext;
		void	*m_pContext;
		T		m_Item;

	protected:
	private:
};

// class to manage the pool
template< class T >
class	CLockedContextClassFixedPool
{
	public:
		CLockedContextClassFixedPool();
		~CLockedContextClassFixedPool();


typedef BOOL (T::*PBOOLCALLBACK)( void *const pContext );
typedef void (T::*PVOIDCALLBACK)( void *const pContext );

		BOOL	Initialize( PBOOLCALLBACK pAllocFunction,
							PBOOLCALLBACK pInitFunction,
							PVOIDCALLBACK pReleaseFunction,
							PVOIDCALLBACK pDeallocFunction );

		void	Deinitialize( void );

		T		*Get( void *const pContext );
		void	Release( T *const pItem );

	protected:

	private:
		DNCRITICAL_SECTION	m_Lock;

		PBOOLCALLBACK	m_pAllocFunction;
		PBOOLCALLBACK	m_pInitFunction;
		PVOIDCALLBACK	m_pReleaseFunction;
		PVOIDCALLBACK	m_pDeallocFunction;

		CLockedContextClassFPMPoolNode< T >	*volatile m_pPool;		// pointer to list of available elements

		BOOL			m_fInitialized;					// Initialized ?

		DEBUG_ONLY( LONG	volatile m_lOutstandingItemCount );
};

//**********************************************************************
// Class function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedContextClassFixedPool::CLockedContextClassFixedPool - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
template< class T >
CLockedContextClassFixedPool< T >::CLockedContextClassFixedPool():
	m_pAllocFunction( NULL ),
	m_pInitFunction( NULL ),
	m_pReleaseFunction( NULL ),
	m_pDeallocFunction( NULL ),
	m_pPool( NULL ),
	m_fInitialized( FALSE )
{
	DEBUG_ONLY( m_lOutstandingItemCount = 0 );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedContextClassFixedPool::~CLockedContextClassFixedPool - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CCFPM::CCFPM"

template< class T >
CLockedContextClassFixedPool< T >::~CLockedContextClassFixedPool()
{
	DEBUG_ONLY( DNASSERT( m_lOutstandingItemCount == 0 ) );
	DEBUG_ONLY( DNASSERT( m_fInitialized == FALSE ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedContextClassFixedPool::Initialize - initialize pool
//
// Entry:		Pointer to function to call when a new entry is allocated
//				Pointer to function to call when a new entry is removed from the pool
//				Pointer to function to call when an entry is returned to the pool
//				Pointer to function to call when an entry is deallocated
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CCFPM::Initialize"

template< class T >
BOOL	CLockedContextClassFixedPool< T >::Initialize( PBOOLCALLBACK pAllocFunction, PBOOLCALLBACK pInitFunction, PVOIDCALLBACK pReleaseFunction, PVOIDCALLBACK pDeallocFunction )
{
	BOOL	fReturn;

	DNASSERT( m_fInitialized == FALSE );

	DNASSERT( pAllocFunction != NULL );
	DNASSERT( pInitFunction != NULL );
	DNASSERT( pReleaseFunction != NULL );
	DNASSERT( pDeallocFunction != NULL );

	fReturn = TRUE;

	if ( DNInitializeCriticalSection( &m_Lock ) == FALSE )
	{
		fReturn = FALSE;
		goto Exit;
	}

	m_pAllocFunction = pAllocFunction;
	m_pInitFunction = pInitFunction;
	m_pReleaseFunction = pReleaseFunction;
	m_pDeallocFunction = pDeallocFunction;

	m_fInitialized = TRUE;

Exit:
	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedContextClassFixedPool::Deinitialize - deinitialize pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CCFPM::Deinitialize"

template< class T >
void	CLockedContextClassFixedPool< T >::Deinitialize( void )
{
	DNASSERT( m_fInitialized == TRUE );

	DNEnterCriticalSection(&m_Lock);
	DEBUG_ONLY( DNASSERT( m_lOutstandingItemCount == 0 ) );
	while ( m_pPool != NULL )
	{
		CLockedContextClassFPMPoolNode< T >	*pNode;

		pNode = m_pPool;
		m_pPool = m_pPool->m_pNext;
		(pNode->m_Item.*this->m_pDeallocFunction)( pNode->m_pContext );
		delete	pNode;
	}
	DNLeaveCriticalSection(&m_Lock);

	DNDeleteCriticalSection(&m_Lock);

	m_fInitialized = FALSE;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedContextClassFixedPool::Get - get an item from the pool
//
// Entry:		Pointer to user context
//
// Exit:		Pointer to item
//				NULL = out of memory
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CCFPM::Get"

template< class T >
T	*CLockedContextClassFixedPool< T >::Get( void *const pContext )
{
	CLockedContextClassFPMPoolNode< T >	*pNode;
	T	*pReturn;


	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );

	//
	// initialize
	//
	pReturn = NULL;

	DNEnterCriticalSection(&m_Lock);

	//
	// if the pool is empty, try to allocate a new entry, otherwise grab
	// the first item from the pool
	//
	if ( m_pPool == NULL )
	{
		DNLeaveCriticalSection(&m_Lock);
		pNode = new CLockedContextClassFPMPoolNode< T >;
		if ( pNode != NULL )
		{
			if ( (pNode->m_Item.*this->m_pAllocFunction)( pContext ) == FALSE )
			{
				delete pNode;
				pNode = NULL;
			}
		}
	}
	else
	{
		pNode = m_pPool;
		m_pPool = m_pPool->m_pNext;
		DNLeaveCriticalSection(&m_Lock);
	}


	//
	// if we have an entry (it was freshly created, or removed from the pool),
	// attempt to initialize it before passing it to the user
	//
	if ( pNode != NULL )
	{
		if ( (pNode->m_Item.*this->m_pInitFunction)( pContext ) == FALSE )
		{
			DNEnterCriticalSection(&m_Lock);

			pNode->m_pNext = m_pPool;
			m_pPool = pNode;

			DNLeaveCriticalSection(&m_Lock);

			pNode = NULL;
		}
		else
		{
			pNode->m_pContext = pContext;
			pReturn = &pNode->m_Item;

			DEBUG_ONLY( pNode->m_pNext = (CLockedContextClassFPMPoolNode<T>*) BLANK_NODE_VALUE );
			DEBUG_ONLY( InterlockedIncrement(const_cast<LONG*>(&m_lOutstandingItemCount)) );
		}
	}

	return	 pReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedContextClassFixedPool::Release - return item to pool
//
// Entry:		Pointer to item
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CCFPM::Release"

template< class T >
void	CLockedContextClassFixedPool< T >::Release( T *const pItem )
{
	CLockedContextClassFPMPoolNode< T >	*pNode;


	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );
	DNASSERT( pItem != NULL );
	DBG_CASSERT( sizeof( BYTE* ) == sizeof( pItem ) );
	DBG_CASSERT( sizeof( CLockedContextClassFPMPoolNode< T >* ) == sizeof( BYTE* ) );
	pNode = reinterpret_cast<CLockedContextClassFPMPoolNode< T >*>( &reinterpret_cast<BYTE*>( pItem )[ -OFFSETOF( CLockedContextClassFPMPoolNode< T >, m_Item ) ] );

	DEBUG_ONLY( DNASSERT( pNode->m_pNext == (CLockedContextClassFPMPoolNode< T >*)BLANK_NODE_VALUE ) );
	(pNode->m_Item.*this->m_pReleaseFunction)( pNode->m_pContext );
	DNEnterCriticalSection(&m_Lock);

#if defined(CHECK_FOR_DUPLICATE_LOCKEDCCFPM_RELEASE) && defined(DEBUG)
	{
		CLockedContextClassFPMPoolNode< T >	*pTemp;


		pTemp = m_pPool;
		while ( pTemp != NULL )
		{
			DNASSERT( pTemp != pNode );
			pTemp = pTemp->m_pNext;
		}
	}
#endif	// CHECK_FOR_DUPLICATE_LOCKEDCCFPM_RELEASE

#ifdef NO_POOLS
	(pNode->m_Item.*this->m_pDeallocFunction)( pNode->m_pContext );
	delete pNode;
#else
	pNode->m_pNext = m_pPool;
	m_pPool = pNode;
#endif

	DEBUG_ONLY( InterlockedDecrement(const_cast<LONG*>(&m_lOutstandingItemCount)) );
	DNLeaveCriticalSection(&m_Lock);
}
//**********************************************************************

#ifdef	__LOCAL_OFFSETOF_DEFINED__
#undef	__LOCAL_OFFSETOF_DEFINED__
#undef	OFFSETOF
#endif	// __LOCAL_OFFSETOF_DEFINED__

#undef DPF_MODNAME
#undef DPF_SUBCOMP

#endif	// __CONTEXT_CLASS_FPM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\lockedpool.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       LockedPool.h
 *  Content:	Pool manager for classes
 *
 *  History:
 *   Date		By			Reason
 *   ======		==			======
 *  12-18-97	aarono		Original
 *	11-06-98	ejs			Add custom handler for Release function
 *	04-12-99	johnkan		Trimmed unused functions and parameters, added size assert
 *	01-31-2000	johnkan		Added code to check for items already being in the pool on Release().
 *	02-08-2000	johnkan		Derived from ClassFPM.h
 *	03-26-2000	johnkan		Renamed to avoid collisions with other classes
 *	04-06-2000	johnkan		Modified to have a base class to derive pool items from
 *	03-20-2001	vanceo		Added thread-local versions
***************************************************************************/

#ifndef __LOCKED_POOL__
#define __LOCKED_POOL__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON










#define TRACK_POOL_STATS











//**********************************************************************
// Constant definitions
//**********************************************************************

#define	CHECK_FOR_DUPLICATE_LOCKED_POOL_RELEASE

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	OFFSETOF
// Macro to compute the offset of an element inside of a larger structure (copied from MSDEV's STDLIB.H)
#define OFFSETOF(s,m)	( (INT_PTR) &(((s *)0)->m) )
#define	__LOCAL_OFFSETOF_DEFINED__
#endif	// OFFSETOF

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward reference
//
class	CLockedPoolItem;
template< class T > class	CLockedPool;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definitions
//**********************************************************************

//
// class to act as a link in the pool
//
class	CLockedPoolItem
{
	public:
		#undef DPF_MODNAME
		#define DPF_MODNAME "CLockedPoolItem::CLockedPoolItem"
		CLockedPoolItem()
		{
			m_iRefCount = 0;
			m_pNext = NULL;
		}
		
		#undef DPF_MODNAME
		#define DPF_MODNAME "CLockedPoolItem::~CLockedPoolItem"
		virtual	~CLockedPoolItem() { DNASSERT( m_iRefCount == 0 ); }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CLockedPoolItem::AddRef"
		void	AddRef( void )
		{
			DNASSERT( m_iRefCount != -1 );
			InterlockedIncrement( const_cast<LONG*>( &m_iRefCount ) );
		}
		
		#undef DPF_MODNAME
		#define DPF_MODNAME "CLockedPoolItem::DecRef"
		void	DecRef( void )
		{
			DNASSERT( m_iRefCount != 0 );
			if ( InterlockedDecrement( const_cast<LONG*>( &m_iRefCount ) ) == 0 )
			{
				ReturnSelfToPool();
			}
		}

		CLockedPoolItem	*GetNext( void ) const { return m_pNext; }
		void	InvalidateNext( void ) { m_pNext = NULL; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CLockedPoolItem::LinkToPool"
		void	LinkToPool( CLockedPoolItem *volatile *const ppPoolItems )
		{
			DNASSERT( ppPoolItems != NULL );
			m_pNext = *ppPoolItems;
			*ppPoolItems = this;
		}

		//
		// Default initialization and deinitialization functions.  These can
		// be overridden by the derived classes.
		//
		virtual	BOOL	PoolAllocFunction( void ){ return TRUE; }
		virtual	BOOL	PoolInitFunction( void ){ return TRUE; }
		virtual void	PoolReleaseFunction( void ){};
		virtual void	PoolDeallocFunction( void ){};

	protected:
	
	private:
		//
		// reference count used to return this item to the pool
		//
		volatile LONG	m_iRefCount;	

		//
		// pointer used to link this item to the rest of the pool
		//
		CLockedPoolItem		*m_pNext;

		virtual void	ReturnSelfToPool( void ) = 0;

		//
		// prevent unwarranted copies
		//
		CLockedPoolItem( const CLockedPoolItem & );
		CLockedPoolItem& operator=( const CLockedPoolItem & );
};


//
// class to manage the pool
//
template< class T >
class	CLockedPool
{
	public:
		CLockedPool();
		~CLockedPool();

		void	Lock( void ) { DNEnterCriticalSection( &m_Lock ); }
		void	Unlock( void ) { DNLeaveCriticalSection( &m_Lock ); }

		BOOL	Initialize( void );
		void	Deinitialize( void );

		T		*Get( void );
		void	Release( T *const pItem );

	protected:

	private:
		DNCRITICAL_SECTION	m_Lock;

		CLockedPoolItem	*volatile m_pPool;		// pointer to list of available elements

		DEBUG_ONLY( BOOL			m_fInitialized );
		DEBUG_ONLY( volatile LONG	m_lOutstandingItemCount );

		T	*RemoveNode( void )
		{
			T	*pReturn;


			if ( m_pPool != NULL )
			{
				pReturn = static_cast<T*>( m_pPool );
				m_pPool = m_pPool->GetNext();
				DEBUG_ONLY( pReturn->InvalidateNext() );
			}
			else
			{
				pReturn = NULL;
			}

			return	pReturn;
		}
		
		//
		// prevent unwarranted copies
		//
		CLockedPool< T >( const CLockedPool< T > & );
		CLockedPool< T >& operator=( const CLockedPool< T > & );
};


//**********************************************************************
// Class function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedPool::CLockedPool - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CLockedPool::CLockedPool"

template< class T >
CLockedPool< T >::CLockedPool():
	m_pPool( NULL )
{
	DEBUG_ONLY( m_fInitialized = FALSE );
	DEBUG_ONLY( m_lOutstandingItemCount = 0 );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedPool::~CLockedPool - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CLockedPool::~CLockedPool"

template< class T >
CLockedPool< T >::~CLockedPool()
{
	DEBUG_ONLY( DNASSERT( m_lOutstandingItemCount == 0 ) );
	DEBUG_ONLY( DNASSERT( m_fInitialized == FALSE ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedPool::Initialize - initialize pool
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = initialization succeeded
//				FALSE = initialization failed
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CLockedPool::Initialize"

template< class T >
BOOL	CLockedPool< T >::Initialize( void )
{
	BOOL	fReturn;

	
	DEBUG_ONLY( DNASSERT( m_fInitialized == FALSE ) );

	fReturn = TRUE;

	if ( DNInitializeCriticalSection( &m_Lock ) == FALSE )
	{
		fReturn = FALSE;
		goto Exit;
	}
	DebugSetCriticalSectionRecursionCount( &m_Lock, 0 );

	DEBUG_ONLY( m_fInitialized = TRUE );

Exit:
	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedPool::Deinitialize - deinitialize pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CLockedPool::Deinitialize"

template< class T >
void	CLockedPool< T >::Deinitialize( void )
{
	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );

	Lock();

	DEBUG_ONLY( DNASSERT( m_lOutstandingItemCount == 0 ) );
	while ( m_pPool != NULL )
	{
		CLockedPoolItem	*pNode;

		
		pNode = RemoveNode();
		pNode->PoolDeallocFunction();
		delete	pNode;
	}
	
	Unlock();

	DNDeleteCriticalSection( &m_Lock );

	DEBUG_ONLY( m_fInitialized = FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedPool::Get - get an item from the pool
//
// Entry:		Nothing
//
// Exit:		Pointer to item
//				NULL = out of memory
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CLockedPool::Get"

template< class T >
T	*CLockedPool< T >::Get( void )
{
	T	*pReturn;


	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );

	//
	// initialize
	//
	pReturn = NULL;

	Lock();

	//
	// if the pool is empty, try to allocate a new entry, otherwise grab
	// the first item from the pool
	//
	if ( m_pPool == NULL )
	{
		Unlock();
		
		pReturn = new T;
		if ( pReturn != NULL )
		{
			if ( pReturn->PoolAllocFunction() == FALSE )
			{
				delete pReturn;
				pReturn = NULL;
			}
		}
	}
	else
	{
		pReturn = RemoveNode();
		Unlock();
	}


	//
	// if we have an entry (it was freshly created, or removed from the pool),
	// attempt to initialize it before passing it to the user
	//
	if ( pReturn != NULL )
	{
		if ( pReturn->PoolInitFunction() == FALSE )
		{
			Lock();
			
			pReturn->LinkToPool( &m_pPool );
			
			Unlock();
			
			pReturn = NULL;
		}
		else
		{
			pReturn->SetOwningPool( this );
			pReturn->AddRef();
			DEBUG_ONLY( InterlockedIncrement( const_cast<LONG*>( &m_lOutstandingItemCount ) ) );
		}
	}

	return	 pReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedPool::Release - return item to pool
//
// Entry:		Pointer to item
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CLockedPool::Release"

template< class T >
void	CLockedPool< T >::Release( T *const pItem )
{
	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );
	DNASSERT( pItem != NULL );

	
	DEBUG_ONLY( DNASSERT( pItem->GetNext() == NULL ) );
	pItem->PoolReleaseFunction();
	
	Lock();
	
#if defined(CHECK_FOR_DUPLICATE_LOCKED_POOL_RELEASE) && defined(DEBUG)
	{
		CLockedPoolItem	*pTemp;


		pTemp = m_pPool;
		while ( pTemp != NULL )
		{
			DNASSERT( pTemp != pItem );
			pTemp = pTemp->GetNext();
		}
	}
#endif	// CHECK_FOR_DUPLICATE_LOCKED_POOL_RELEASE

	DEBUG_ONLY( pItem->SetOwningPool( NULL ) );

#ifdef NO_POOLS
	pItem->PoolDeallocFunction();
	delete pItem;
#else
	pItem->LinkToPool( &m_pPool );
#endif

	Unlock();
	
	DEBUG_ONLY( InterlockedDecrement( const_cast<LONG*>( &m_lOutstandingItemCount ) ) );
}
//**********************************************************************



//
// class to act as a link in the pool
//
class	CLockedTLPoolItem
{
	public:
		#undef DPF_MODNAME
		#define DPF_MODNAME "CLockedTLPoolItem::CLockedTLPoolItem"
		CLockedTLPoolItem()
		{
			m_iRefCount = 0;
			m_blList.Initialize();
		}
		
		#undef DPF_MODNAME
		#define DPF_MODNAME "CLockedTLPoolItem::~CLockedTLPoolItem"
		virtual	~CLockedTLPoolItem()
		{
			DNASSERT( m_iRefCount == 0 );
			DNASSERT( m_blList.IsEmpty() );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CLockedTLPoolItem::AddRef"
		void	AddRef( void )
		{
			DNASSERT( m_iRefCount != -1 );
			InterlockedIncrement( const_cast<LONG*>( &m_iRefCount ) );
		}
		
		#undef DPF_MODNAME
		#define DPF_MODNAME "CLockedTLPoolItem::DecRef"
		void	DecRef( void )
		{
			DNASSERT( m_iRefCount != 0 );
			if ( InterlockedDecrement( const_cast<LONG*>( &m_iRefCount ) ) == 0 )
			{
				ReturnSelfToPool();
			}
		}

		//
		// Default initialization and deinitialization functions.  These can
		// be overridden by the derived classes.
		//
		virtual	BOOL	PoolAllocFunction( void ){ return TRUE; }
		virtual	BOOL	PoolInitFunction( void ){ return TRUE; }
		virtual void	PoolReleaseFunction( void ){};
		virtual void	PoolDeallocFunction( void ){};


		//
		// linkage to the rest of the pool
		//
		CBilink			m_blList;
#ifdef TRACK_POOL_STATS
		DWORD			m_dwSourceThreadID;
#endif // TRACK_POOL_STATS


	protected:
	
	private:
		//
		// reference count used to return this item to the pool
		//
		volatile LONG	m_iRefCount;	

		virtual void	ReturnSelfToPool( void ) = 0;

		//
		// prevent unwarranted copies
		//
		CLockedTLPoolItem( const CLockedTLPoolItem & );
		CLockedTLPoolItem& operator=( const CLockedTLPoolItem & );
};


//
// class to manage the pool
//
template< class T >
class	CLockedTLPool
{
	public:
		CLockedTLPool();
		~CLockedTLPool();

		BOOL	Initialize( CLockedTLPool< T > * pGlobalPool );
		void	Deinitialize( void );

		T		*Get( void );
		void	Release( T *const pItem );
		static void		ReleaseWithoutPool( T *const pItem );

	protected:

	private:
		CBilink					m_blItems;						// bilink list of available elements
		CLockedTLPool< T > *	m_pGlobalPool;					// pointer to global pool, or NULL if this is the global pool
		DNCRITICAL_SECTION *	m_pcsLock;						// pointer to pool critical section, or NULL if this is not the global pool
		DWORD					m_dwNumItems;					// number of items currently in this pool

		DEBUG_ONLY( BOOL		m_fInitialized );
#ifdef TRACK_POOL_STATS
		DWORD					m_dwAllocations;				// how many objects were allocated by this pool
		DWORD					m_dwSlurpsFromGlobal;			// how many times some items were taken from the global pool
		DWORD					m_dwLargestSlurpFromGlobal;		// most number of items taken from the global pool at one time
		DWORD					m_dwRetrievals;					// how many times objects were pulled out of this pool
		DWORD					m_dwReturnsOnSameThread;		// how many times objects that were pulled out of this pool were returned to this pool
		DWORD					m_dwReturnsOnDifferentThread;	// how many times objects that were pulled out of another thread's pool were returned to this pool
		DWORD					m_dwDumpsToGlobal;				// how many times some items were dumped into the global pool
		DWORD					m_dwDeallocations;				// how many objects were freed by this pool
#endif // TRACK_POOL_STATS

	
		//
		// prevent unwarranted copies
		//
		CLockedTLPool< T >( const CLockedTLPool< T > & );
		CLockedTLPool< T >& operator=( const CLockedTLPool< T > & );
};


//**********************************************************************
// Class function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedTLPool::CLockedTLPool - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CLockedTLPool::CLockedTLPool"

template< class T >
CLockedTLPool< T >::CLockedTLPool():
	m_pGlobalPool( NULL ),
	m_pcsLock( NULL ),
	m_dwNumItems( 0 )
{
	m_blItems.Initialize();

	DEBUG_ONLY( m_fInitialized = FALSE );
#ifdef TRACK_POOL_STATS
	m_dwAllocations = 0;
	m_dwSlurpsFromGlobal = 0;
	m_dwLargestSlurpFromGlobal = 0;
	m_dwRetrievals = 0;
	m_dwReturnsOnSameThread = 0;
	m_dwReturnsOnDifferentThread = 0;
	m_dwDumpsToGlobal = 0;
	m_dwDeallocations = 0;
#endif // TRACK_POOL_STATS
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedTLPool::~CLockedTLPool - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CLockedTLPool::~CLockedTLPool"

template< class T >
CLockedTLPool< T >::~CLockedTLPool()
{
	DNASSERT( m_fInitialized == FALSE );
	DNASSERT( m_dwNumItems == 0 );
	DNASSERT( m_blItems.IsEmpty() );
	DNASSERT( m_pcsLock == NULL );

#ifdef TRACK_POOL_STATS
	DPFX(DPFPREP, 9, "Pool 0x%p information:", this);
	DPFX(DPFPREP, 9, "\tAllocations              = %u", m_dwAllocations);
	DPFX(DPFPREP, 9, "\tSlurpsFromGlobal         = %u", m_dwSlurpsFromGlobal);
	DPFX(DPFPREP, 9, "\tLargestSlurpFromGlobal   = %u", m_dwLargestSlurpFromGlobal);
	DPFX(DPFPREP, 9, "\tRetrievals               = %u", m_dwRetrievals);
	DPFX(DPFPREP, 9, "\tReturnsOnSameThread      = %u", m_dwReturnsOnSameThread);
	DPFX(DPFPREP, 9, "\tReturnsOnDifferentThread = %u", m_dwReturnsOnDifferentThread);
	DPFX(DPFPREP, 9, "\tDumpsToGlobal            = %u", m_dwDumpsToGlobal);
	DPFX(DPFPREP, 9, "\tDeallocations            = %u", m_dwDeallocations);
#endif // TRACK_POOL_STATS
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedTLPool::Initialize - initialize pool
//
// Entry:		Pointer to global pool, or NULL if this is the global pool
//
// Exit:		Boolean indicating success
//				TRUE = initialization succeeded
//				FALSE = initialization failed
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CLockedTLPool::Initialize"

template< class T >
BOOL	CLockedTLPool< T >::Initialize( CLockedTLPool< T > * pGlobalPool )
{
	BOOL	fReturn;


	fReturn = TRUE;
	
	m_pGlobalPool = pGlobalPool;
	if (pGlobalPool == NULL)
	{
		//DPFX(DPFPREP, 9, "Initializing global pool 0x%p.", this);
		m_pcsLock = (DNCRITICAL_SECTION*) DNMalloc( sizeof(DNCRITICAL_SECTION) );
		if (m_pcsLock == NULL)
		{
			fReturn = FALSE;
			goto Exit;
		}

		if (! DNInitializeCriticalSection( m_pcsLock ))
		{
			DNFree( m_pcsLock );
			DEBUG_ONLY( m_pcsLock = NULL );
			fReturn = FALSE;
			goto Exit;
		}
	}

	DEBUG_ONLY( DNASSERT( m_fInitialized == FALSE ) );
	DEBUG_ONLY( m_fInitialized = TRUE );


Exit:

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedTLPool::Deinitialize - deinitialize pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CLockedTLPool::Deinitialize"

template< class T >
void	CLockedTLPool< T >::Deinitialize( void )
{
	CBilink *	pBilink;
	T *			pItem;


	pBilink = m_blItems.GetNext();
	while ( pBilink != &m_blItems )
	{
		pItem = CONTAINING_OBJECT(pBilink, T, m_blList);
		pBilink = pBilink->GetNext();
		pItem->m_blList.RemoveFromList();

		pItem->PoolDeallocFunction();
		delete	pItem;
#ifdef TRACK_POOL_STATS
		m_dwDeallocations++;
#endif // TRACK_POOL_STATS
		DEBUG_ONLY( m_dwNumItems-- );
	}

	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );
	DEBUG_ONLY( m_fInitialized = FALSE );

	if (m_pcsLock != NULL)
	{
		//DPFX(DPFPREP, 9, "Deinitializing global pool 0x%p.", this);

		DNDeleteCriticalSection( m_pcsLock );

		DNFree( m_pcsLock );
		DEBUG_ONLY( m_pcsLock = NULL );
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedTLPool::Get - get an item from the pool
//
// Entry:		Nothing
//
// Exit:		Pointer to item
//				NULL = out of memory
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CLockedTLPool::Get"

template< class T >
T	*CLockedTLPool< T >::Get( void )
{
	CBilink *	pBilink;
	T *			pReturn;


	DNASSERT( m_fInitialized != FALSE );
	DNASSERT( m_pGlobalPool != NULL );


	//
	// If the pool is empty, steal the ones in the global pool.
	//
	pBilink = m_blItems.GetNext();
	if ( pBilink == &m_blItems )
	{
		DNEnterCriticalSection( m_pGlobalPool->m_pcsLock );

		pBilink = m_pGlobalPool->m_blItems.GetNext();
		if ( pBilink == &m_pGlobalPool->m_blItems )
		{
			//
			// No items.  Drop global pool lock and allocate a new one.
			//
			DNLeaveCriticalSection( m_pGlobalPool->m_pcsLock );


			pReturn = new T;
			if ( pReturn != NULL )
			{
				if ( pReturn->PoolAllocFunction() == FALSE )
				{
					delete pReturn;

					pReturn = NULL;
					goto Exit;
				}
#ifdef TRACK_POOL_STATS
				else
				{
					//
					// Update counter.
					//
					m_dwAllocations++;
				}
#endif // TRACK_POOL_STATS
			}
			else
			{
				pReturn = NULL;
				goto Exit;
			}
		}
		else
		{
			//
			// Separate all the items from the global list.
			// We still have a pointer to the orphaned items (pBilink).
			//

			m_pGlobalPool->m_blItems.RemoveFromList();

			DNASSERT(m_pGlobalPool->m_dwNumItems > 0);

#ifdef TRACK_POOL_STATS
			m_dwSlurpsFromGlobal++;
			if ( m_pGlobalPool->m_dwNumItems > m_dwLargestSlurpFromGlobal )
			{
				m_dwLargestSlurpFromGlobal = m_pGlobalPool->m_dwNumItems;
			}
#endif // TRACK_POOL_STATS

			m_dwNumItems = m_pGlobalPool->m_dwNumItems - 1;	// -1 because we need one right now
			m_pGlobalPool->m_dwNumItems = 0;


			//
			// Drop the lock since we don't need the global pool anymore.
			//
			DNLeaveCriticalSection( m_pGlobalPool->m_pcsLock );


			//
			// Get the first item from the orphaned list.
			//
			pReturn = CONTAINING_OBJECT(pBilink, T, m_blList);

			//
			// If there was more than one item in the global pool, transfer
			// the remaining orphaned items (after the first) to this pool.
			//
			if (pBilink != pBilink->GetNext())
			{
				pBilink = pBilink->GetNext();
				pReturn->m_blList.RemoveFromList();
				m_blItems.InsertBefore(pBilink);
			}
		}
	}
	else
	{
		pReturn = CONTAINING_OBJECT(pBilink, T, m_blList);
		pBilink->RemoveFromList();

		DNASSERT( m_dwNumItems > 0 );
		m_dwNumItems--;
	}

	//
	// If we're here, we have an entry (it was freshly created, or removed from
	// some pool).  Attempt to initialize it before passing it to the user.
	//
	if ( pReturn->PoolInitFunction() == FALSE )
	{
		pReturn->m_blList.InsertAfter( &m_blItems );
		pReturn = NULL;
	}
	else
	{
		pReturn->AddRef();

#ifdef TRACK_POOL_STATS
		//
		// Update status counts.
		//
		m_dwRetrievals++;
		pReturn->m_dwSourceThreadID = GetCurrentThreadId();
#endif // TRACK_POOL_STATS
	}


Exit:

	return	 pReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedTLPool::Release - return item to pool
//
// Entry:		Pointer to item
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CLockedTLPool::Release"

template< class T >
void	CLockedTLPool< T >::Release( T *const pItem )
{
	DNASSERT( m_fInitialized != FALSE );
	DNASSERT( m_pGlobalPool != NULL );
	DNASSERT( pItem != NULL );
	DBG_CASSERT( sizeof( BYTE* ) == sizeof( pItem ) );

#if defined(CHECK_FOR_DUPLICATE_CONTEXTCFPM_RELEASE) && defined(DEBUG)
	DNASSERT( ! pItem->m_blList.IsListMember( &m_blItems ));
#endif	// CHECK_FOR_DUPLICATE_CONTEXTCFPM_RELEASE

	pItem->PoolReleaseFunction();

#ifdef TRACK_POOL_STATS
	//
	// Update status counts.
	//
	if (pItem->m_dwSourceThreadID == GetCurrentThreadId())
	{
		m_dwReturnsOnSameThread++;
	}
	else
	{
		m_dwReturnsOnDifferentThread++;
	}
#endif // TRACK_POOL_STATS


#ifdef NO_POOLS
	pItem->PoolDeallocFunction();
	delete pItem;
#ifdef TRACK_POOL_STATS
	m_dwDeallocations++;
#endif // TRACK_POOL_STATS
#else
	pItem->m_blList.InsertAfter( &m_blItems );
	m_dwNumItems++;


	//
	// If this pool has built up some extra items, return them to the
	// global pool.
	//
	if ( m_dwNumItems >= 25 )
	{
		CBilink *	pFirstItem;


		//
		// Save a pointer to the first item. 
		//
		pFirstItem = m_blItems.GetNext();
		DNASSERT( pFirstItem != &m_blItems );

		//
		// Orphan the items.
		//
		m_blItems.RemoveFromList();

		
		//
		// Take the lock and transfer the list to the global pool.
		//

		DNEnterCriticalSection( m_pGlobalPool->m_pcsLock );

		m_pGlobalPool->m_blItems.AttachListBefore(pFirstItem);
		m_pGlobalPool->m_dwNumItems += m_dwNumItems;

		DNLeaveCriticalSection( m_pGlobalPool->m_pcsLock );

		m_dwNumItems = 0;
#ifdef TRACK_POOL_STATS
		m_dwDumpsToGlobal++;
#endif // TRACK_POOL_STATS
	}
#endif // ! NO_POOLS
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedTLPool::ReleaseWithoutPool - destroy an item without returning it
//										to a pool
//										NOTE: this is a static function
//										and cannot use the 'this' pointer!
//
// Entry:		Pointer to item
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CContextFixedTLPool::ReleaseWithoutPool"

template< class T >
void	CLockedTLPool< T >::ReleaseWithoutPool( T *const pItem )
{
	DNASSERT( pItem != NULL );
	DBG_CASSERT( sizeof( BYTE* ) == sizeof( pItem ) );

	DNASSERT( pItem->m_blList.IsEmpty() );
	pItem->PoolReleaseFunction();
	pItem->PoolDeallocFunction();
	delete pItem;
}
//**********************************************************************



#ifdef	__LOCAL_OFFSETOF_DEFINED__
#undef	__LOCAL_OFFSETOF_DEFINED__
#undef	OFFSETOF
#endif	// __LOCAL_OFFSETOF_DEFINED__


#undef DPF_SUBCOMP
#undef DPF_MODNAME

#endif	// __LOCKED_POOL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\memlog.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 - 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memlog.h
 *  Content:	format of the memory log for DPlay debugging
 *				
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  08-24-00		masonb		Created
 *
 ***************************************************************************/

#ifndef _DPLAY_SHARED_MEMLOG_
#define _DPLAY_SHARED_MEMLOG_

#define DPLOG_MAX_STRING 256	// Max string length for VXD and MEM logging

#define DPLOG_HEADERSIZE (sizeof(SHARED_LOG_FILE))
#define DPLOG_ENTRYSIZE (sizeof(MEMLOG_ENTRY)+DPLOG_MAX_STRING)

#define BASE_LOG_MEMFILENAME  	"DPLAY8MEMLOG-0"
#define BASE_LOG_MUTEXNAME 	"DPLAY8MEMLOGMUTEX-0"

#pragma warning(disable:4200) // 0 length array
typedef struct _MEM_LOG_ENTRY 
{
	DWORD	tLogged;
	CHAR	str[0];
} MEMLOG_ENTRY, *PMEMLOG_ENTRY;

typedef struct _SHARED_LOG_FILE
{
	DWORD   	nEntries;
	DWORD		cbLine;
	DWORD 		iWrite;
} SHARED_LOG_FILE, *PSHARED_LOG_FILE;
#pragma warning(default:4200)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\lockedcontextfixedpool.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       LockedContextFixedPool.h
 *  Content:	fixed pool manager for classes that takes into account contexts
 *
 *  History:
 *   Date		By			Reason
 *   ======		==			======
 *  12-18-97	aarono		Original
 *	11-06-98	ejs			Add custom handler for Release function
 *	04-12-99	johnkan		Trimmed unused functions and parameters, added size assert
 *	01-31-2000	johnkan		Added code to check for items already being in the pool on Release().
 *	02-08-2000	johnkan		Derived from ClassFPM.h
 *	03-26-2000	johnkan		Renamed to avoid collisions with other classes
 *	04-06-2000	johnkan		Modified to have a base class to derive pool items from
***************************************************************************/

#ifndef __LOCKED_CONTEXT_FIXED_POOL__
#define __LOCKED_CONTEXT_FIXED_POOL__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON


//**********************************************************************
// Constant definitions
//**********************************************************************

#define	CHECK_FOR_DUPLICATE_LOCKED_CONTEXT_FPM_RELEASE

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	OFFSETOF
// Macro to compute the offset of an element inside of a larger structure (copied from MSDEV's STDLIB.H)
#define OFFSETOF(s,m)	( (INT_PTR) &(((s *)0)->m) )
#define	__LOCAL_OFFSETOF_DEFINED__
#endif	// OFFSETOF

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward reference
//
template< class S > class	CLockedContextFixedPoolItem;
template< class T, class S > class	CLockedContextFixedPool;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definitions
//**********************************************************************

//
// class to act as a link in the pool
//
template< class S >
class	CLockedContextFixedPoolItem
{
	public:
		#undef DPF_MODNAME
		#define DPF_MODNAME "CLockedContextFixedPoolItem::CLockedContextFixedPoolItem"
		CLockedContextFixedPoolItem()
		{
			m_iRefCount = 0;
			m_pNext = NULL;
		}
		
		#undef DPF_MODNAME
		#define DPF_MODNAME "CLockedContextFixedPoolItem::~CLockedContextFixedPoolItem"
		virtual	~CLockedContextFixedPoolItem() { DNASSERT( m_iRefCount == 0 ); }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CLockedContextFixedPoolItem::AddRef"
		void	AddRef( void )
		{
			DNASSERT( m_iRefCount != -1 );
			InterlockedIncrement( const_cast<LONG*>( &m_iRefCount ) );
		}
		
		#undef DPF_MODNAME
		#define DPF_MODNAME "CLockedContextFixedPoolItem::DecRef"
		void	DecRef( void )
		{
			DNASSERT( m_iRefCount != 0 );
			if ( InterlockedDecrement( const_cast<LONG*>( &m_iRefCount ) ) == 0 )
			{
				ReturnSelfToPool();
			}
		}

		CLockedContextFixedPoolItem	*GetNext( void ) const { return m_pNext; }
		void	InvalidateNext( void ) { m_pNext = NULL; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CLockedContextFixedPoolItem::LinkToPool"
		void	LinkToPool( CLockedContextFixedPoolItem *volatile *const ppPoolItems )
		{
			DNASSERT( ppPoolItems != NULL );
			m_pNext = *ppPoolItems;
			*ppPoolItems = this;
		}

		//
		// Default initialization and deinitialization functions.  These can
		// be overridden by the derived classes.
		//
		virtual	BOOL	PoolAllocFunction( S Context ){ return TRUE; }
		virtual	BOOL	PoolInitFunction( S Context ){ return TRUE; }
		virtual void	PoolReleaseFunction( void ){};
		virtual void	PoolDeallocFunction( void ){};

	protected:
	
	private:
		//
		// reference count used to return this item to the pool
		//
		volatile LONG	m_iRefCount;	

		//
		// pointer used to link this item to the rest of the pool
		//
		CLockedContextFixedPoolItem		*m_pNext;

		virtual void	ReturnSelfToPool( void ) = 0;

		//
		// prevent unwarranted copies
		//
		CLockedContextFixedPoolItem< S >( const CLockedContextFixedPoolItem< S > & );
		CLockedContextFixedPoolItem< S >& operator=( const CLockedContextFixedPoolItem< S > & );
};


//
// class to manage the pool
//
template< class T, class S >
class	CLockedContextFixedPool
{
	public:
		CLockedContextFixedPool();
		~CLockedContextFixedPool();

		void	Lock( void ) { DNEnterCriticalSection( &m_Lock ); }
		void	Unlock( void ) { DNLeaveCriticalSection( &m_Lock ); }

		BOOL	Initialize( void );
		void	Deinitialize( void );

		T		*Get( S Context );
		void	Release( T *const pItem );

	protected:

	private:
		DNCRITICAL_SECTION	m_Lock;

		CLockedContextFixedPoolItem< S >	*volatile m_pPool;		// pointer to list of available elements

		DEBUG_ONLY( BOOL			m_fInitialized );
		DEBUG_ONLY( volatile LONG	m_lOutstandingItemCount );

		T	*RemoveNode( void )
		{
			T	*pReturn;


			if ( m_pPool != NULL )
			{
				pReturn = static_cast<T*>( m_pPool );
				m_pPool = m_pPool->GetNext();
				DEBUG_ONLY( pReturn->InvalidateNext() );
			}
			else
			{
				pReturn = NULL;
			}

			return	pReturn;
		}
		
		//
		// prevent unwarranted copies
		//
		CLockedContextFixedPool< T, S >( const CLockedContextFixedPool< T, S > & );
		CLockedContextFixedPool< T, S >& operator=( const CLockedContextFixedPool< T, S > & );
};


//**********************************************************************
// Class function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedContextFixedPool::CLockedContextFixedPool - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
template< class T, class S >
CLockedContextFixedPool< T, S >::CLockedContextFixedPool():
	m_pPool( NULL )
{
	DEBUG_ONLY( m_fInitialized = FALSE );
	DEBUG_ONLY( m_lOutstandingItemCount = 0 );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedContextFixedPool::~CLockedContextFixedPool - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
template< class T, class S >
CLockedContextFixedPool< T, S >::~CLockedContextFixedPool()
{
	DEBUG_ONLY( DNASSERT( m_lOutstandingItemCount == 0 ) );
	DEBUG_ONLY( DNASSERT( m_fInitialized == FALSE ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedContextFixedPool::Initialize - initialize pool
//
// Entry:		Nothing
//				Pointer to function to call when a new entry is removed from the pool
//				Pointer to function to call when an entry is returned to the pool
//				Pointer to function to call when an entry is deallocated
//
// Exit:		Boolean indicating success
//				TRUE = initialization succeeded
//				FALSE = initialization failed
// ------------------------------
template< class T, class S >
BOOL	CLockedContextFixedPool< T, S >::Initialize( void )
{
	BOOL	fReturn;

	
	DEBUG_ONLY( DNASSERT( m_fInitialized == FALSE ) );

	fReturn = TRUE;

	if ( DNInitializeCriticalSection( &m_Lock ) == FALSE )
	{
		fReturn = FALSE;
		goto Exit;
	}
	DebugSetCriticalSectionRecursionCount( &m_Lock, 0 );

	DEBUG_ONLY( m_fInitialized = TRUE );

Exit:
	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedContextFixedPool::Deinitialize - deinitialize pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
template< class T, class S >
void	CLockedContextFixedPool< T, S >::Deinitialize( void )
{
	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );

	Lock();

	DEBUG_ONLY( DNASSERT( m_lOutstandingItemCount == 0 ) );
	while ( m_pPool != NULL )
	{
		CLockedContextFixedPoolItem< S >	*pNode;

		
		pNode = RemoveNode();
		pNode->PoolDeallocFunction();
		delete	pNode;
	}
	
	Unlock();

	DNDeleteCriticalSection( &m_Lock );

	DEBUG_ONLY( m_fInitialized = FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedContextFixedPool::Get - get an item from the pool
//
// Entry:		Pointer to user context
//
// Exit:		Pointer to item
//				NULL = out of memory
// ------------------------------
template< class T, class S >
T	*CLockedContextFixedPool< T, S >::Get( S Context )
{
	T	*pReturn;


	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );

	//
	// initialize
	//
	pReturn = NULL;

	Lock();

	//
	// if the pool is empty, try to allocate a new entry, otherwise grab
	// the first item from the pool
	//
	if ( m_pPool == NULL )
	{
		Unlock();
		
		pReturn = new T;
		if ( pReturn != NULL )
		{
			if ( pReturn->PoolAllocFunction( Context ) == FALSE )
			{
				delete pReturn;
				pReturn = NULL;
			}
		}
	}
	else
	{
		pReturn = RemoveNode();
		Unlock();
	}


	//
	// if we have an entry (it was freshly created, or removed from the pool),
	// attempt to initialize it before passing it to the user
	//
	if ( pReturn != NULL )
	{
		if ( pReturn->PoolInitFunction( Context ) == FALSE )
		{
			Lock();
			
			pReturn->LinkToPool( &m_pPool );
			
			Unlock();
			
			pReturn = NULL;
		}
		else
		{
			pReturn->SetOwningPool( this );
			pReturn->AddRef();
			DEBUG_ONLY( InterlockedIncrement( const_cast<LONG*>( &m_lOutstandingItemCount ) ) );
		}
	}

	return	 pReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedContextFixedPool::Release - return item to pool
//
// Entry:		Pointer to item
//
// Exit:		Nothing
// ------------------------------
template< class T, class S >
void	CLockedContextFixedPool< T, S >::Release( T *const pItem )
{
	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );
	DNASSERT( pItem != NULL );

	
	DEBUG_ONLY( DNASSERT( pItem->GetNext() == NULL ) );
	pItem->PoolReleaseFunction();
	
	Lock();
#if defined(CHECK_FOR_DUPLICATE_LOCKED_CONTEXT_FPM_RELEASE) && defined(DEBUG)
	{
		CLockedContextFixedPoolItem< S >	*pTemp;


		pTemp = m_pPool;
		while ( pTemp != NULL )
		{
			DNASSERT( pTemp != pItem );
			pTemp = pTemp->GetNext();
		}
	}
#endif	// CHECK_FOR_DUPLICATE_LOCKED_CONTEXT_FPM_RELEASE
	DEBUG_ONLY( pItem->SetOwningPool( NULL ) );

#ifdef NO_POOLS
	pItem->PoolDeallocFunction();
	delete pItem;
#else
	pItem->LinkToPool( &m_pPool );
#endif

	Unlock();
	
	DEBUG_ONLY( InterlockedDecrement( const_cast<LONG*>( &m_lOutstandingItemCount ) ) );
}
//**********************************************************************

#ifdef	__LOCAL_OFFSETOF_DEFINED__
#undef	__LOCAL_OFFSETOF_DEFINED__
#undef	OFFSETOF
#endif	// __LOCAL_OFFSETOF_DEFINED__

#undef DPF_SUBCOMP
#undef DPF_MODNAME

#endif	// __LOCKED_CONTEXT_FIXED_POOL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\ministack.h ===
/*==========================================================================
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       MiniStack.h
 *  Content:	Reduced-overhead call stack tracking class
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	03/27/01	RichGr	Derived from CallStack.h
 ***************************************************************************/

#ifndef	__MINISTACK_H__
#define	__MINISTACK_H__

#define	_IMAGEHLP_SOURCE_
#include <Imagehlp.h>
#include <string.h>

//**********************************************************************
// Constant definitions
//**********************************************************************

#define MINISTACK_DEPTH         5    // Increasing this beyond 5 definitely slows things down.
#define SYM_CACHE_SIZE          100  // 100 seems big enough.  Old entries are automatically replaced.


//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//
// prototypes for ImageHlp.dll functions we get from LoadLibrary().
//
typedef DWORD	(__stdcall * PIMAGEHELP_SYMGETOPTIONS)( void );
typedef DWORD	(__stdcall * PIMAGEHELP_SYMSETOPTIONS)( DWORD SymOptions );
typedef	BOOL	(__stdcall * PIMAGEHELP_SYMINITIALIZE)( HANDLE hProcess, PSTR pUserSearchPath, BOOL fInvadeProcess );
typedef BOOL	(__stdcall * PIMAGEHELP_SYMGETSYMFROMADDR)( HANDLE hProcess, DWORD dwAddress, PDWORD pdwDisplacement, PIMAGEHLP_SYMBOL pSymbol );
typedef BOOL	(__stdcall * PIMAGEHELP_SYMGETSYMFROMADDR64)( HANDLE hProcess, DWORD_PTR dwAddress, PDWORD_PTR pdwDisplacement, PIMAGEHLP_SYMBOL64 pSymbol );

//**********************************************************************
// Class definitions
//**********************************************************************

class CMiniStack
{
public:
    // Member functions
    CMiniStack();
	~CMiniStack();
	void  GetCallStackString(char *const pOutputString);

private:  
    // Member functions
    void  Initialize(char *const pOutputString);
	void  NoteCurrentCallStack(PVOID pCallStack[]);

    // Member variables
    HANDLE                          m_hPID;
    BOOL                            m_bNotInited;
    volatile LONG                   m_nGuardInit;
	HINSTANCE	                    m_hImageHelp;
	PIMAGEHELP_SYMGETOPTIONS		m_pSymGetOptions;
	PIMAGEHELP_SYMSETOPTIONS		m_pSymSetOptions;
	PIMAGEHELP_SYMINITIALIZE		m_pSymInitialize;

#ifndef	_WIN64	
	PIMAGEHELP_SYMGETSYMFROMADDR	m_pSymGetSymFromAddr;
#else
	PIMAGEHELP_SYMGETSYMFROMADDR64  m_pSymGetSymFromAddr;
#endif	// _WIN64

    volatile LONG   m_nGuardSymTable;
    int             m_nNextCacheSlot;
    BOOL            m_bCacheIsFull;

    struct {
        PVOID       pAddress;
        char        szName[64];
        int         nReadCount;    
    } m_SymTable[SYM_CACHE_SIZE];
};


//**********************************************************************
// Per-Process instantiations
//**********************************************************************
#ifdef PER_PROCESS_INSTANTIATIONS   // Define this in just one source file.
CMiniStack          g_MiniStack;
#else
extern CMiniStack   g_MiniStack;
#endif


#ifdef PER_PROCESS_INSTANTIATIONS   // Define this in just one source file.
//**********************************************************************
// Class member function definitions
//**********************************************************************

// These should be moved to a new file MiniStack.cpp for DX9.
// ------------------------------
// CMiniStack::CMiniStack - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
CMiniStack::CMiniStack()
{
    m_bNotInited = TRUE;
    m_nGuardInit = 0;
    m_hPID = GetCurrentProcess();
	m_pSymGetOptions = NULL;
	m_pSymSetOptions = NULL;
	m_pSymInitialize = NULL;
	m_pSymGetSymFromAddr = NULL;
    m_hImageHelp = NULL;
    memset(&m_SymTable, 0, sizeof m_SymTable);
    m_nNextCacheSlot = 0;
    m_bCacheIsFull = FALSE;

    return;
}


// ------------------------------
// CMiniStack::Initialize - load ImageHlp.dll and get proc addresses.
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
void  CMiniStack::Initialize(char *const pOutputString)
{

	// Attempt to load ImageHelp.dll
	if ( (m_hImageHelp = LoadLibrary( "ImageHlp.dll" )) == NULL)
		goto FailedImageHelpLoad;

	m_pSymGetOptions = (PIMAGEHELP_SYMGETOPTIONS)GetProcAddress( m_hImageHelp, "SymGetOptions" );
	m_pSymSetOptions = (PIMAGEHELP_SYMSETOPTIONS)GetProcAddress( m_hImageHelp, "SymSetOptions" );
	m_pSymInitialize = (PIMAGEHELP_SYMINITIALIZE)GetProcAddress( m_hImageHelp, "SymInitialize" );

#ifndef	_WIN64		
	m_pSymGetSymFromAddr = (PIMAGEHELP_SYMGETSYMFROMADDR)GetProcAddress( m_hImageHelp, "SymGetSymFromAddr" );
#else	// _WIN64
	m_pSymGetSymFromAddr = (PIMAGEHELP_SYMGETSYMFROMADDR64)GetProcAddress( m_hImageHelp, "SymGetSymFromAddr64" );
#endif	// _WIN64

	if ( m_pSymGetOptions == NULL 
		|| m_pSymSetOptions == NULL  
		|| m_pSymInitialize == NULL  
		|| m_pSymGetSymFromAddr == NULL )
	{
		goto FailedImageHelpLoad;
	}

	m_pSymSetOptions( SYMOPT_DEFERRED_LOADS | m_pSymGetOptions() );

	if ( m_pSymInitialize( m_hPID, NULL, TRUE ) == FALSE 
		|| m_pSymInitialize( m_hPID, NULL, FALSE ) == FALSE )
    {
		goto FailedImageHelpLoad;
    }

    m_bNotInited = FALSE;

Exit:
    return;

FailedImageHelpLoad:
    strcpy(pOutputString, "*** ImageHlp.dll could not be loaded ***\r\n");

    if (m_hImageHelp)
    {
        FreeLibrary(m_hImageHelp);
        m_hImageHelp = NULL;
    }

    goto Exit;
}


//**********************************************************************
// ------------------------------
// CMiniStack::CMiniStack - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
CMiniStack::~CMiniStack()
{
    if (m_hImageHelp)
    {
        FreeLibrary(m_hImageHelp);
        m_hImageHelp = NULL;
    }

    return;
}


//**********************************************************************
// ------------------------------
// CMiniStack::NoteCurrentCallStack - get a call stack
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
void  CMiniStack::NoteCurrentCallStack(PVOID pCallStack[])
{
	PVOID      *ppCallersEBP;
	PVOID       pStackTop;
	PVOID       pStackBottom;
	int	        i;


    ppCallersEBP = NULL;
    pStackTop = pStackBottom = NULL;

#ifdef	_X86_
	_asm
	{
	    mov eax,dword ptr fs:[4]
	    mov pStackTop, eax
	    mov eax,dword ptr fs:[8]
	    mov pStackBottom, eax
		mov eax,[ebp]
		mov ppCallersEBP,eax
	}

	__try
	{
		// This code can generate exception if it steps back too far...
        // Skip the 1st. stack item because it's always PerfEnterCriticalSection()
        // and we don't need to report it.
 		for (i = -1; i < MINISTACK_DEPTH; i++)
		{
			if ( ppCallersEBP < pStackBottom || ppCallersEBP >= pStackTop )
				break;

            if (i >= 0)
			    pCallStack[i] = ppCallersEBP[1];

			ppCallersEBP = (PVOID*)*ppCallersEBP; // get callers callers ebp
		}
	}
	__except( 1 )  // went too far back on the stack, rest of array is filled with zeros
	{
        //  Benign access violation creating return address stack.
	}
#endif	// _X86_

    return;
}


//**********************************************************************
// ------------------------------
// CMiniStack::GetCallStack - return pointer to call stack string
//
// Entry:		Pointer to destination string
//
// Exit:		Nothing
// ------------------------------
void  CMiniStack::GetCallStackString( char *const pOutputString ) 
{
	int         i, j;
    PVOID       pCallStack[MINISTACK_DEPTH] = {0};
	char	    ImageBuffer[sizeof IMAGEHLP_SYMBOL + 64] = {0};
	DWORD_PTR	dwFunctionDisplacement = 0;
    BOOL        b1stStringDone = FALSE;
    char        szMsg[50] = {0};
#ifndef	_WIN64
	IMAGEHLP_SYMBOL	*const      pImageHelpSymbol = (IMAGEHLP_SYMBOL*)ImageBuffer;
#else	// _WIN64
	IMAGEHLP_SYMBOL64 *const    pImageHelpSymbol = (IMAGEHLP_SYMBOL64*)ImageBuffer;
#endif	// _WIN64

  
    strcpy(pOutputString, "STACK: ");

    if (m_bNotInited)
    {
        // Make sure we are the only thread attempting to call Initialize() at one time.
        if (InterlockedIncrement(&m_nGuardInit) == 1)
            Initialize(pOutputString);
        
        InterlockedDecrement(&m_nGuardInit);

        // If we skipped the Initialize() step or the Initialize() failed, we can just exit.
        if (m_bNotInited)
            return;
    }

	NoteCurrentCallStack(pCallStack);

	pImageHelpSymbol->SizeOfStruct = sizeof( *pImageHelpSymbol );
	pImageHelpSymbol->Flags = 0;
    pImageHelpSymbol->MaxNameLength = sizeof ImageBuffer - sizeof *pImageHelpSymbol - sizeof TCHAR;

    // Loop thru the call stack addresses and pick up the corresponding function names.
	for (i = 0; i < MINISTACK_DEPTH && pCallStack[i] != NULL; i++)
	{
        PVOID   pAddr;
        char   *psz;

        pAddr = pCallStack[i];
        psz = NULL;
        
        // Check to see if the address is in our Symbol table cache.
        // For a full array of 100, this only takes an average of 5 usecs on a P550.
        for (j = 0; m_SymTable[j].pAddress != NULL && j < SYM_CACHE_SIZE; j++)
        {
            if (pAddr == m_SymTable[j].pAddress)
            {
                psz = &m_SymTable[j].szName[0];
                m_SymTable[j].nReadCount++;     // Don't worry about wraps.
                break;
            }
        }

        // It's not in the cache, so get the name from the symbol file(using ImageHlp.dll).
        if (psz == NULL)
        {
    		pImageHelpSymbol->Address = (DWORD_PTR)pAddr;

            if ( m_pSymGetSymFromAddr( m_hPID, (DWORD_PTR)pCallStack[i], &dwFunctionDisplacement, pImageHelpSymbol) != FALSE )
            {
                psz = pImageHelpSymbol->Name;

                // We've taken a lot of time to extract the name.  Now save it in our Symbol table cache.
                // Make sure we are the only thread attempting to update the cache at one time.
                // If it doesn't get updated by a particular thread, it doesn't matter - it'll get updated
                // some other time.
                if (InterlockedIncrement(&m_nGuardSymTable) == 1)
                {
                    int     nLastSlotFilled;

                    // Fill slot.
                    m_SymTable[m_nNextCacheSlot].pAddress = pAddr;
                    m_SymTable[m_nNextCacheSlot].nReadCount = 0;

                    // Some symbol names are invalid, so omit them.
                    if ( !_stricmp(pImageHelpSymbol->Name, "GetModuleHandleA"))
                    {
                        wsprintf(szMsg, "0x%p (no symbols)", pAddr);
                        strcpy(m_SymTable[m_nNextCacheSlot].szName, szMsg);
                        psz = m_SymTable[m_nNextCacheSlot].szName;
                    }
                    else
                        strcpy(m_SymTable[m_nNextCacheSlot].szName, pImageHelpSymbol->Name);

                    nLastSlotFilled = m_nNextCacheSlot;

                    // Select the next slot
                    if ( !m_bCacheIsFull)
                    {
                        // This will work fine until we fill the cache table,
                        // then we have to change our strategy and look for the
                        // Least-Used slot.  
                        m_nNextCacheSlot++;

                        if (m_nNextCacheSlot >= SYM_CACHE_SIZE)
                            m_bCacheIsFull = TRUE;
                    }

                    // The cache is full, so we'll find the Least-Used slot and select that.
                    if (m_bCacheIsFull)
                    {
                        int     nLowestReadCount = 0x7fffffff;
                        int     k = 0;

                        for (j = 0; j < SYM_CACHE_SIZE; j++)
                        {
                            if (j != nLastSlotFilled && m_SymTable[j].nReadCount < nLowestReadCount)
                            {
                                nLowestReadCount = m_SymTable[j].nReadCount;
                                k = j;

                                if (nLowestReadCount == 0)
                                    break;
                            }
                        }

                        m_nNextCacheSlot = k;
                    }
                }

                InterlockedDecrement(&m_nGuardSymTable);
            }
        }

        if (psz)
        {
            if (b1stStringDone)
        		strcat(pOutputString, ", ");

    		strcat(pOutputString, psz);
            b1stStringDone = TRUE;
        }
	}                                                                                     

    return;
}
#endif  //#ifdef PER_PROCESS_INSTANTIATIONS   // Define this in just one source file.


#endif	// __MINISTACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\osind.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       OSInd.cpp
 *  Content:	OS indirection functions to abstract OS specific items.
 *
 *  History:
 *   Date		By	Reason
 *   ====		==	======
 *	07/12/99	jtk	Created
 *	09/21/99	rodtoll	Fixed for retail builds
 *	09/22/99	jtk	Added callstacks to memory allocations
 *	08/28/2000	masonb	Voice Merge: Allow new and delete with size of 0
 *  11/28/2000  rodtoll: WinBug #206257 - Retail DPNET.DLL links to DebugBreak()
 *  12/22/2000  aarono: ManBug # 190380 use process heap for retail.
 ***************************************************************************/

#include	"dncmni.h"


#define PROF_SECT		"DirectPlay8"

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// CRC key for validating memory linkages
// Signature for validating memory blocks
//
#ifdef	_WIN64
#define	MEMORY_CRC			0X5AA55AA55AA55AA5
#define	GUARD_SIGNATURE		0x0F1E2D3C4B5A6978
#else
#define	MEMORY_CRC			0X5AA55AA5
#define	GUARD_SIGNATURE		0x0F1E2D3C
#endif	// _WIN64

static	CRITICAL_SECTION	g_AllocatedMemoryLock;


//
// signature for validating memory blocks
//

//
// enumerated values to indicate how to report memory leaks
//
#if	defined( DN_MEMORY_TRACKING ) || defined( DN_CRITICAL_SECTION_TRACKING )
#define	MEMORY_LEAK_REPORT_NONE		0x00000000
#define	MEMORY_LEAK_REPORT_DPF		0x00000001
#define	MEMORY_LEAK_REPORT_DIALOG	0x00000002
#endif

//**********************************************************************
// Macro definitions
//**********************************************************************

//
// Macro to compute the offset of an element inside of a larger structure.
// Copied from MSDEV's STDLIB.H and modified to return INT_PTR
//
#define OFFSETOF(s,m)	( ( INT_PTR ) &( ( (s*) 0 )->m ) )

//
// macro for length of array
//
#define	LENGTHOF( arg )		( sizeof( arg ) / sizeof( arg[ 0 ] ) )

//
// ASSERT macro
//
#ifdef	_DEBUG

#ifdef	_X86_
#define	ASSERT( arg )	if ( arg == FALSE ) { _asm { int 3 }; }
#else
#define	ASSERT( arg )	if ( arg == FALSE ) { DebugBreak(); }
#endif

#else	// _DEBUG

#define	ASSERT( arg )

#endif	//_DEBUG

//**********************************************************************
// Structure definitions
//**********************************************************************


//**********************************************************************
// Variable definitions
//**********************************************************************

//
// debug variable to make sure we're initialized before having any functions
// called
//
DEBUG_ONLY( static	BOOL		g_fOSIndirectionLayerInitialized = FALSE );

//
// time variables
//
static	DNCRITICAL_SECTION	g_TimeLock;
static	DWORD				g_dwLastTimeCall = 0;

#ifdef	DN_CRITICAL_SECTION_TRACKING
CBilink				g_blCritSecs;
DNCRITICAL_SECTION	g_CSLock;
#endif

#ifdef	DN_MEMORY_TRACKING
DWORD g_dwMemLeakDisplayFlags = MEMORY_LEAK_REPORT_DPF;
#endif

//
// OS items
//
static OSVERSIONINFO g_OSVersionInfo;
static HINSTANCE g_hApplicationInstance;

//
// memory heap
//
HANDLE	g_hMemoryHeap = NULL;

PSECURITY_ATTRIBUTES g_psa = NULL;
SECURITY_ATTRIBUTES g_sa;
BYTE g_pSD[SECURITY_DESCRIPTOR_MIN_LENGTH];
BOOL g_fDaclInited = FALSE;

//**********************************************************************
// Function prototypes
//**********************************************************************
#ifdef	DN_MEMORY_TRACKING
static int	DisplayMemoryLeaks( void );
BOOL	DNMemoryTrackInitialize( void );
#endif

#if	defined( DN_MEMORY_TRACKING ) || defined( DN_CRITICAL_SECTION_TRACKING )
static int	DisplayCallStack( const char *const pszMsg,
							  const char *const pszTitle,
							  const char *const pCallStack );
#endif

//**********************************************************************
// Function definitions
//**********************************************************************

typedef BOOL (WINAPI *PFNINITCRITSECANDSPINCOUNT)(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount);

PFNINITCRITSECANDSPINCOUNT g_pfnInitializeCriticalSectionAndSpinCount = NULL;


//**********************************************************************
// ------------------------------
// DNOSIndirectionInit - initialize the OS indirection layer
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = initialization successful
//				FALSE = initialization unsuccessful
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNOSIndirectionInit"

BOOL	DNOSIndirectionInit( void )
{
	BOOL			fReturn;

	DNASSERT( g_fOSIndirectionLayerInitialized == FALSE );

	//
	// initialize
	//
	fReturn = TRUE;

	//
	// note OS version
	//
	memset( &g_OSVersionInfo, 0x00, sizeof( g_OSVersionInfo ) );
	g_OSVersionInfo.dwOSVersionInfoSize = sizeof( g_OSVersionInfo );
	if ( GetVersionEx( &g_OSVersionInfo ) == FALSE )
	{
		return FALSE;
	}

	HMODULE hKernel32 = GetModuleHandleA("kernel32.dll");
	if (hKernel32 != NULL)
	{
		g_pfnInitializeCriticalSectionAndSpinCount = (PFNINITCRITSECANDSPINCOUNT) GetProcAddress(hKernel32, "InitializeCriticalSectionAndSpinCount");
	}

	//
	// note application instance
	//
	g_hApplicationInstance = GetModuleHandle( NULL );
	if ( g_hApplicationInstance == NULL )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Failed to GetModuleHandle: 0x%x", dwError );
		goto Failure;
	}

#ifdef DN_MEMORY_TRACKING
	g_dwMemLeakDisplayFlags = GetProfileIntA( PROF_SECT, "MemoryLeakOutput", MEMORY_LEAK_REPORT_DPF );
#endif

	//
	// intialize critical section tracking code before anything else!
	//
#ifdef	DN_CRITICAL_SECTION_TRACKING
	g_blCritSecs.Initialize();

	if ( DNInitializeCriticalSection(&g_CSLock) == FALSE )
	{
		DPFX(DPFPREP,  0, "Failed to initialize critical section tracking code!" );
		DNASSERT( FALSE );
		goto Failure;
	}
#endif	// DN_CRITICAL_SECTION_TRACKING

	//
	// intiailize memory tracking before creating new memory heap
	//
#ifdef	DN_MEMORY_TRACKING
	if ( DNMemoryTrackInitialize() == FALSE )
	{
		DPFX(DPFPREP,  0, "Failed to initialize memory tracking code!" );
		DNASSERT( FALSE );
		goto Failure;
	}
#endif	// DN_MEMORY_TRACKING

	DNASSERT( g_hMemoryHeap == NULL );

#ifdef _DEBUG
	g_hMemoryHeap = HeapCreate( 0,		// flags (none)
								0,		// initial size (default)
								0		// maximum heap size (allow heap to grow)
								);
#else
	g_hMemoryHeap = GetProcessHeap();
#endif

	if ( g_hMemoryHeap == NULL )
	{
		DPFX(DPFPREP,  0, "Failed to create memory heap!" );
		goto Failure;
	}


	//
	// get initial time for timebase
	//
	g_dwLastTimeCall = GETTIMESTAMP();
	if ( DNInitializeCriticalSection( &g_TimeLock ) == FALSE )
	{
		goto Failure;
	}

	goto Exit;

Exit:
	if ( fReturn != FALSE )
	{
		DEBUG_ONLY( g_fOSIndirectionLayerInitialized = TRUE );
	}

	return	fReturn;

Failure:
	fReturn = FALSE;

	DNOSIndirectionDeinit();

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNOSIndirectionDeinit - deinitialize OS indirection layer
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNOSIndirectionDeinit"

void	DNOSIndirectionDeinit( void )
{
	//
	// clean up time management resources
	//
	DNDeleteCriticalSection( &g_TimeLock );

#ifdef	DN_CRITICAL_SECTION_TRACKING
	//
	// Display CritSec leaks before displaying memory leaks, because displaying memory leaks
	// may free the memory for the CritSec and corrupt the CritSec bilink
	//
	BOOL fDisplayLeaks = TRUE;

	DNEnterCriticalSection(&g_CSLock);
	CBilink* pblCS = g_blCritSecs.GetNext();
	while (pblCS != &g_blCritSecs)
	{
		UINT_PTR	MessageReturn;
		char		CallStackBuffer[ CALLSTACK_BUFFER_SIZE ];
		char		LeakSizeString[ 50 ];
		char		DialogTitle[ 1000 ];
		DNCRITICAL_SECTION* pCS = CONTAINING_RECORD(pblCS, DNCRITICAL_SECTION, blCritSec);

#ifdef _IA64_
		wsprintf( LeakSizeString, "Critical Section leaked at address 0x%p!\n", pCS );
#else
		wsprintf( LeakSizeString, "Critical Section leaked at address 0x%08x!\n", pCS );
#endif
		strcpy( DialogTitle, "DirectPlay8 critical section leak detected!");
		
		pCS->AllocCallStack.GetCallStackString( CallStackBuffer );

		if ( ( g_dwMemLeakDisplayFlags & MEMORY_LEAK_REPORT_DPF ) != 0 )
		{
			DPFX(DPFPREP,  0, "%s%s%s\n", DialogTitle, LeakSizeString, CallStackBuffer );
		}

		if ( ( g_dwMemLeakDisplayFlags & MEMORY_LEAK_REPORT_DIALOG ) != 0  )
		{
			if ( fDisplayLeaks != FALSE )
			{
				MessageReturn = DisplayCallStack( LeakSizeString, DialogTitle, CallStackBuffer );
				switch ( MessageReturn )
				{	
					//
					// stop application now
					//
					case IDABORT:
					{
						fDisplayLeaks = FALSE;
						break;
					}

					//
					// display next leak
					//
					case IDIGNORE:
					{
						break;
					}

					//
					// stop in the debugger
					//
					case IDRETRY:
					{
						DNASSERT( FALSE );
						break;
					}

					//
					// unknown
					//
					default:
					{
						DNASSERT( FALSE );
						break;
					}
				}
			}
		}

		pblCS = pblCS->GetNext();
	}
	DNLeaveCriticalSection(&g_CSLock);

	DNDeleteCriticalSection( &g_CSLock );

#endif	// DN_CRITICAL_SECTION_TRACKING

	//
	// Report memory leaks, validate the heap if we're on NT and then destroy
	// the heap.
	//
	if ( g_hMemoryHeap != NULL )
	{
		//
		// report memory leaks, if applicable
		//
#ifdef	DN_MEMORY_TRACKING
		DNMemoryTrackDisplayMemoryLeaks();
		DeleteCriticalSection( &g_AllocatedMemoryLock );
#endif	// DN_MEMORY_TRACKING

		//
		// Validate heap contents before shutdown.  This code only works on NT.
		//
#ifdef	_DEBUG
		if ( DNGetOSType() == VER_PLATFORM_WIN32_NT)
		{
			//
			// Check heap
			//
			if ( HeapValidate( g_hMemoryHeap, 0, NULL ) == FALSE )
			{
				DPFX(DPFPREP,  0, "Problem validating heap on destroy!" );
			}
		}
		//
		// destroy heap - debug only, we use the process heap for retail.
		//
		if ( HeapDestroy( g_hMemoryHeap ) == FALSE )
		{
			DWORD	dwErrorReturn;

			dwErrorReturn = GetLastError();
			DPFX(DPFPREP,  0, "Problem destroying heap in DNOSIndirectionDeinit!" );
			DisplayErrorCode( 0, dwErrorReturn );
		}
#endif _DEBUG

		g_hMemoryHeap = NULL;
	}

	//
	// clean critical section management resources
	//


	DEBUG_ONLY( g_fOSIndirectionLayerInitialized = FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNGetOSType - get OS type
//
// Entry:		Nothing
//
// Exit:		OS type
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNGetOSType"

UINT_PTR	DNGetOSType( void )
{
	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
	return	g_OSVersionInfo.dwPlatformId;
}

//**********************************************************************
// ------------------------------
// DNOSIsXPOrGreater - return TRUE if OS is WindowsXP or later or NT flavor
//
// Entry:		Nothing
//
// Exit:		BOOL
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNOSIsXPOrGreater"

BOOL DNOSIsXPOrGreater( void )
{
	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );

	return ((g_OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) && 
		    ((g_OSVersionInfo.dwMajorVersion > 5) || ((g_OSVersionInfo.dwMajorVersion == 5) && (g_OSVersionInfo.dwMinorVersion >= 1))) 
		    );
}

//**********************************************************************

//**********************************************************************
// ------------------------------
// DNGetNullDacl - get a SECURITY_ATTRIBUTE structure that specifies a 
//					NULL DACL which is accesible by all users.
//
// Entry:		Nothing
//
// Exit:		PSECURITY_ATTRIBUTES
// ------------------------------
#undef DPF_MODNAME 
#define DPF_MODNAME "DNGetNullDacl"
PSECURITY_ATTRIBUTES DNGetNullDacl()
{
	// This is done to make this function independent of DNOSIndirectionInit so that the debug
	// layer can call it before the indirection layer is initialized.
	if (!g_fDaclInited)
	{
		if (!InitializeSecurityDescriptor((SECURITY_DESCRIPTOR*)g_pSD, SECURITY_DESCRIPTOR_REVISION))
		{
			DPFX(DPFPREP,  0, "Failed to initialize security descriptor" );
		}
		else
		{
			// Add a NULL DACL to the security descriptor..
			if (!SetSecurityDescriptorDacl((SECURITY_DESCRIPTOR*)g_pSD, TRUE, (PACL) NULL, FALSE))
			{
				DPFX(DPFPREP,  0, "Failed to set NULL DACL on security descriptor" );
			}
			else
			{
				g_sa.nLength = sizeof(SECURITY_ATTRIBUTES);
				g_sa.lpSecurityDescriptor = g_pSD;
				g_sa.bInheritHandle = FALSE;

				g_psa = &g_sa;
			}
		}
		g_fDaclInited = TRUE;
	}
	
	return g_psa;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNGetApplcationInstance - application instance
//
// Entry:		Nothing
//
// Exit:		Application instance
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNGetApplicationInstance"

HINSTANCE	DNGetApplicationInstance( void )
{
	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
	return	g_hApplicationInstance;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNTimeGet - get time in milliseconds
//
// Entry:		Pointer to destination time
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNTimeGet"

void	DNTimeGet( DN_TIME *const pTimeDestination )
{
static	DN_TIME	Time = { 0 };
	DN_TIME		DeltaT;
	DWORD		dwCurrentTime;


	DNASSERT( pTimeDestination != NULL );
	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );

	DNEnterCriticalSection( &g_TimeLock );

	//
	// we'll assume that we're getting called more than once every 40 days
	// so time wraps can be easily accounted for
	//
	dwCurrentTime = GETTIMESTAMP();
	DeltaT.Time32.TimeHigh = 0;
	DeltaT.Time32.TimeLow = dwCurrentTime - g_dwLastTimeCall;
	if ( DeltaT.Time32.TimeLow > 0x7FFFFFFF )
	{
		DNASSERT( FALSE );
		DeltaT.Time32.TimeLow = -static_cast<INT>( DeltaT.Time32.TimeLow );
	}

	g_dwLastTimeCall = dwCurrentTime;
	DNTimeAdd( &Time, &DeltaT, &Time );

	DBG_CASSERT( sizeof( *pTimeDestination ) == sizeof( Time ) );
	memcpy( pTimeDestination, &Time, sizeof( *pTimeDestination ) );

	DNLeaveCriticalSection( &g_TimeLock );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNTimeCompare - compare two times
//
// Entry:		Pointer to time1
//				Pointer to time2
//
// Exit:		Value indicating relative magnitude
//				-1 = *pTime1 < *pTime2
//				0 = *pTime1 == *pTime2
//				1 = *pTime1 > *pTime2
//
// Notes:	This function comes in 32-bit and 64-bit flavors.  This function
//			will result in a compile error if compiled on an unsupported platform.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNTimeCompare"

INT_PTR	DNTimeCompare( const DN_TIME *const pTime1, const DN_TIME *const pTime2 )
{
	UINT_PTR	iReturnValue;


	DNASSERT( pTime1 != NULL );
	DNASSERT( pTime2 != NULL );
	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );

#pragma	TODO( johnkan, "Should this be inlined?" )

//#ifdef	_WIN32
	if ( pTime1->Time32.TimeHigh < pTime2->Time32.TimeHigh )
	{
		iReturnValue = -1;
	}
	else
	{
		if ( pTime1->Time32.TimeHigh > pTime2->Time32.TimeHigh )
		{
			iReturnValue = 1;
		}
		else
		{
			if ( pTime1->Time32.TimeLow < pTime2->Time32.TimeLow )
			{
				iReturnValue = -1;
			}
			else
			{
				if ( pTime1->Time32.TimeLow == pTime2->Time32.TimeLow )
				{
					iReturnValue = 0;
				}
				else
				{
					iReturnValue = 1;
				}
			}
		}
	}
//#endif	// _WIN32


//#ifdef	_WIN64
//	// debug me!
//	DNASSERT( FALSE );
//
//	if ( pTime1->Time < pTime2->Time )
//	{
//		iReturnValue = -1;
//	}
//	else
//	{
//		if ( pTime1->Time == pTime2->Time )
//		{
//			iReturnValue = 0;
//		}
//		else
//		{
//			iReturnValue = 1;
//		}
//	}
//#endif	// _WIN64

	return	iReturnValue;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNTimeAdd - add two times
//
// Entry:		Pointer to time1
//				Pointer to time2
//				Pointer to time result
//
// Exit:		Nothing
//
// Note:	This function assumes that the time calculation won't wrap!
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNTimeAdd"

void	DNTimeAdd( const DN_TIME *const pTime1, const DN_TIME *const pTime2, DN_TIME *const pTimeResult )
{
	DNASSERT( pTime1 != NULL );
	DNASSERT( pTime2 != NULL );
	DNASSERT( pTimeResult != NULL );
	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );

#pragma	TODO( johnkan, "Should this be inlined?" )

#ifdef	_X86_
	_asm { mov ecx, pTime1
		   mov eax, ( DN_TIME [ ecx ] ).Time32.TimeLow;
		   mov edx, ( DN_TIME [ ecx ] ).Time32.TimeHigh

		   mov ecx, pTime2
		   add eax, ( DN_TIME [ ecx ] ).Time32.TimeLow
		   adc edx, ( DN_TIME [ ecx ] ).Time32.TimeHigh

		   mov ecx, pTimeResult
		   mov ( DN_TIME [ ecx ] ).Time32.TimeLow, eax
		   mov ( DN_TIME [ ecx ] ).Time32.TimeHigh, edx
		   };

#else	// _X86_

/*
#ifdef	_ALPHA_
	// debug me
	DebugBreak();

	__asm{ mov	$t0, *pTime1
		   mov	$t1, *pTime2
		   addq	$t0, $t1
		   mov	*pTimeResult, $t0
	};
#else	// _ALPHA_
*/

//#ifdef	_WIN32
	DWORD	dwTempLowTime;


	dwTempLowTime = pTime1->Time32.TimeLow;
	pTimeResult->Time32.TimeLow = pTime1->Time32.TimeLow + pTime2->Time32.TimeLow;
	pTimeResult->Time32.TimeHigh = pTime1->Time32.TimeHigh + pTime2->Time32.TimeHigh;

	//
	// check for overflow in low 32-bits and increment high value if applicable
	//
	if ( pTimeResult->Time32.TimeLow < dwTempLowTime )
	{
		pTimeResult->Time32.TimeHigh++;
	}
//#endif	// _WIN32

//#ifdef	_WIN64
//	DEBUG_ONLY( UINT_PTR	ReferenceTime );
//
//	// debug me!
//	DNASSERT( FALSE );
//
//	DEBUG_ONLY( ReferenceTime = pTime1->Time );
//	*pTimeResult = pTime1->Time + pTime2->Time;
//	DNASSERT( *pTimeResult >= ReferenceTime );
//
//#endif	// _WIN64

// #endif	// _ALPHA_

#endif	// _X86_
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNTimeSubtract - subtract two times
//
// Entry:		Pointer to time1
//				Pointer to time2
//				Pointer to time result
//
// Exit:		Nothing
//
// Notes:	This function assumes no underflow!
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNTimeSubtract"

void	DNTimeSubtract( const DN_TIME *const pTime1, const DN_TIME *const pTime2, DN_TIME *const pTimeResult )
{
	DNASSERT( pTime1 != NULL );
	DNASSERT( pTime2 != NULL );
	DNASSERT( pTimeResult != NULL );
	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );


#pragma	TODO( johnkan, "Should this be inlined?" )

#ifdef	_X86_

	_asm { mov ecx, pTime1
		   mov eax, ( DN_TIME [ ecx ] ).Time32.TimeLow
		   mov edx, ( DN_TIME [ ecx ] ).Time32.TimeHigh

		   mov ecx, pTime2
		   sub eax, ( DN_TIME [ ecx ] ).Time32.TimeLow
		   sbb edx, ( DN_TIME [ ecx ] ).Time32.TimeHigh

		   mov ecx, pTimeResult
		   mov ( DN_TIME [ ecx ] ).Time32.TimeLow, eax
		   mov ( DN_TIME [ ecx ] ).Time32.TimeHigh, edx
		   };

#else	// _X86_

/*
#ifdef	_ALPHA_
	// debug me
	DebugBreak();

	mov		$t0, *pTime1
	mov		$t1, *pTime2
	addq	$t0, $t1
	mov		*pTimeResult, $t0
#else	// _ALPHA_
*/

//#ifdef	_WIN32
	DWORD	dwTempLowTime;


	dwTempLowTime = pTime1->Time32.TimeLow;
	pTimeResult->Time32.TimeLow = pTime1->Time32.TimeLow - pTime2->Time32.TimeLow;
	pTimeResult->Time32.TimeHigh = pTime1->Time32.TimeHigh - pTime2->Time32.TimeHigh;

	//
	// check for underflow in low 32-bits and decrement high value if applicable
	//
	if ( pTimeResult->Time32.TimeLow > dwTempLowTime )
	{
		pTimeResult->Time32.TimeHigh--;
	}
//#endif	// _WIN32

//#ifdef	_WIN64
//	// debug me!
//	DNASSERT( FALSE );
//
//	DNASSERT( pTime1->Time > pTime2->Time );
//	pTimeResult = pTime1->Time - pTime2->Time;
//#endif	// _WIN64

// #endif	// _ALPHA_

#endif	// _X86_
}
//**********************************************************************

//**********************************************************************
// ------------------------------
// DNInitializeCriticalSection - initialize a critical section
//
// Entry:		Pointer to critical section
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failue
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNInitializeCriticalSection"

BOOL	DNInitializeCriticalSection( DNCRITICAL_SECTION *const pCriticalSection )
{
	BOOL	fReturn;


	DNASSERT( pCriticalSection != NULL );
	fReturn = TRUE;

	memset( pCriticalSection, 0x00, sizeof( *pCriticalSection ) );

#ifdef	DN_CRITICAL_SECTION_TRACKING
	pCriticalSection->OwningThreadID = DN_INVALID_THREAD_ID;
	pCriticalSection->MaxLockCount = -1;
#endif	// DN_CRITICAL_SECTION_TRACKING

	//
	// attempt to enter the critical section once
	//
	_try
	{
		// Do this for Win95 support only
		if (g_pfnInitializeCriticalSectionAndSpinCount)
		{
			// Pre-allocate the critsec event by setting the high bit of the spin count and set spin to 1000
			// Win98 and up map calls to this function to InitializeCriticalSection which makes sense since 
			// 9x only uses one processor.  NT also converts the spin to 0 for single proc machines.
			fReturn = g_pfnInitializeCriticalSectionAndSpinCount( &pCriticalSection->CriticalSection , 0x80000000 | 1000);

			// Believe it or not Win9x defines this function as returning VOID so its return value is garbage
			if (g_OSVersionInfo.dwPlatformId != VER_PLATFORM_WIN32_NT)
			{
				fReturn = TRUE;
			}
		}
		else
		{
			InitializeCriticalSection( &pCriticalSection->CriticalSection );
		}
	}
	_except( EXCEPTION_EXECUTE_HANDLER )
	{
		fReturn = FALSE;
	}

	_try
	{
		if (fReturn)
		{
			EnterCriticalSection( &pCriticalSection->CriticalSection );
		}
	}
	_except( EXCEPTION_EXECUTE_HANDLER )
	{
		DeleteCriticalSection(&pCriticalSection->CriticalSection);
		fReturn = FALSE;
	}

	//
	// if we didn't fail on entering the critical section, make sure
	// we release it
	//
	if ( fReturn != FALSE )
	{
		LeaveCriticalSection( &pCriticalSection->CriticalSection );

#ifdef	DN_CRITICAL_SECTION_TRACKING
		pCriticalSection->AllocCallStack.NoteCurrentCallStack();
		// NOTE: We will not add g_CSLock to our list
		if (pCriticalSection != &g_CSLock)
		{
			DNEnterCriticalSection(&g_CSLock);
			pCriticalSection->blCritSec.InsertBefore(&g_blCritSecs);
			DNLeaveCriticalSection(&g_CSLock);
		}
#endif
	}

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNDeleteCriticalSection - delete a critical section
//
// Entry:		Pointer to critical section
//
// Exit:		Nothing
//
// Notes:	This function wrapping is overkill, but we're closing down so
//			the overhead is negligible.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNDeleteCriticalSection"

void	DNDeleteCriticalSection( DNCRITICAL_SECTION *const pCriticalSection )
{
	DNASSERT( pCriticalSection != NULL );
	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );

#ifdef	DN_CRITICAL_SECTION_TRACKING
	DNASSERT( pCriticalSection->LockCount == 0 );

	// NOTE: We will not remove g_CSLock from our list since we never added it
	if (pCriticalSection != &g_CSLock)
	{
		DNEnterCriticalSection(&g_CSLock);
		pCriticalSection->blCritSec.RemoveFromList();
		DNLeaveCriticalSection(&g_CSLock);
	}
#endif

	DeleteCriticalSection( &pCriticalSection->CriticalSection );
	memset( &pCriticalSection->CriticalSection, 0x00, sizeof( pCriticalSection->CriticalSection ) );
}
//**********************************************************************



#ifdef	DN_MEMORY_TRACKING
//**********************************************************************
//**
//** THIS IS THE MEMORY TRACKING SECTION.  ONLY ADD FUNCTIONS HERE THAT ARE
//** FOR MEMORY TRACKING!!
//**
//**********************************************************************

//
// Structure prepended to memory allocations to check for leaks.
// Disable warning 4200 (zero sized structure elements).
//
#pragma	warning ( disable : 4200 )
typedef	struct	_MEMORY_LINK
{
	public:
		void	Initialize( void )
		{
			m_pNext = this;
			m_pPrev = this;
		}

		BOOL	IsValid( void ) const
		{
			return ( m_Checksum == ( reinterpret_cast<UINT_PTR>( m_pPrev ) ^
									 reinterpret_cast<UINT_PTR>( m_pNext ) ^
									 m_Size ^
									 MEMORY_CRC ) );
		}

		void	UpdateCRC( void )
		{
			m_Checksum = reinterpret_cast<UINT_PTR>( m_pPrev ) ^
						 reinterpret_cast<UINT_PTR>( m_pNext ) ^
						 m_Size ^
						 MEMORY_CRC;
		}

		BOOL	IsEmpty( void ) { return ( ( m_pNext == this ) && ( m_pPrev == this ) ); }

		_MEMORY_LINK	*GetNext( void ) const { return m_pNext; }
		_MEMORY_LINK	*GetPrev( void ) const { return m_pPrev; }

		void	*GetDataPointer( void ) { return &m_Data[ sizeof( DWORD_PTR ) ]; }
		static _MEMORY_LINK	*PointerFromData( void *const pData )
		{
			return reinterpret_cast<_MEMORY_LINK*>( &( reinterpret_cast<BYTE*>( pData )[ - ( OFFSETOF( MEMORY_LINK, m_Data ) + static_cast<int>( sizeof( DWORD_PTR ) ) ) ] ) );
		}

		void		SetSize( const UINT_PTR Size ){ m_Size = Size; }
		UINT_PTR	GetSize( void ) const { return m_Size; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "_MEMORY_LINK::LinkAfterOther"
		void	LinkAfterOther( _MEMORY_LINK &OtherLink )
		{
			ASSERT( OtherLink.IsValid() != FALSE );
			if ( OtherLink.m_pNext != NULL )
			{
				ASSERT(	OtherLink.m_pNext->IsValid() != FALSE );
				OtherLink.m_pNext->m_pPrev = this;
				OtherLink.m_pNext->UpdateCRC();
			}
			m_pNext = OtherLink.m_pNext;
			m_pPrev = &OtherLink;
			UpdateCRC();
			OtherLink.m_pNext = this;
			OtherLink.UpdateCRC();
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "_MEMORY_LINK::RemoveFromList"
		void	RemoveFromList( void )
		{
			ASSERT( IsValid() != FALSE );
			ASSERT( m_pPrev != NULL );
			if ( m_pNext != NULL )
			{
				ASSERT( m_pNext->IsValid() != FALSE );
				m_pNext->m_pPrev = m_pPrev;
				m_pNext->UpdateCRC();
			}

			ASSERT( m_pPrev->IsValid() != FALSE );
			m_pPrev->m_pNext = m_pNext;
			m_pPrev->UpdateCRC();
			m_pNext = NULL;
			m_pPrev = NULL;
		}

		void	NoteCurrentCallStack( void ) { m_CallStack.NoteCurrentCallStack(); }
		void	GetCallStack( char *const pBuffer ) const { m_CallStack.GetCallStackString( pBuffer ); }

		void	SetOverrunSignatures( void )
		{
			*reinterpret_cast<DWORD_PTR*>( m_Data ) = GUARD_SIGNATURE;
            //  6/30/2000(RichGr) - IA64: Specifying UNALIGNED generates the correct IA64 code for non-8-byte alignment.
			*reinterpret_cast<UNALIGNED DWORD_PTR*>( &m_Data[ m_Size + sizeof( DWORD_PTR ) ] ) = GUARD_SIGNATURE;
		}

		BOOL	UnderrunDetected( void ) const { return ( *reinterpret_cast<const DWORD_PTR*>( m_Data ) != GUARD_SIGNATURE ); }
        //  6/30/2000(RichGr) - IA64: Specifying UNALIGNED generates the correct IA64 code for non-8-byte alignment.
		BOOL	OverrunDetected( void ) const { return ( *reinterpret_cast<const UNALIGNED DWORD_PTR*>( &m_Data[ m_Size + sizeof( DWORD_PTR ) ] ) != GUARD_SIGNATURE ); }
		BOOL	IsCorrupted( void ) const { return ( !IsValid() || UnderrunDetected() || OverrunDetected() ); }

	protected:

	private:
		UINT_PTR		m_Checksum;
		UINT_PTR		m_Size;
		_MEMORY_LINK	*m_pPrev;
		_MEMORY_LINK	*m_pNext;
		CCallStack<DN_MEMORY_CALL_STACK_DEPTH>	m_CallStack;
		BYTE			m_Data[];

} MEMORY_LINK;
#pragma	warning ( default : 4200 )

//
// forward structure references
//
typedef	struct	_MEMORY_LINK	MEMORY_LINK;

//
// memory tracking variables
//
static	UINT_PTR			g_uAllocatedMemoryCount;
static	MEMORY_LINK			g_AllocatedMemory;



//**********************************************************************
// ------------------------------
// DNMemoryTrackInitialize - initialize memory tracking
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNMemoryTrackInitialize"

static	BOOL	DNMemoryTrackInitialize( void )
{
	BOOL	fReturn;


	fReturn = TRUE;

	memset( &g_AllocatedMemory, 0x00, sizeof ( g_AllocatedMemory ) );

	g_uAllocatedMemoryCount = 0;
	g_AllocatedMemory.Initialize();
	g_AllocatedMemory.UpdateCRC();

	InitializeCriticalSection( &g_AllocatedMemoryLock );

	return	fReturn;
}
//**********************************************************************


//**********************************************************************


//**********************************************************************
// ------------------------------
// DNMemoryTrackHeapAlloc - allocate from heap and track allocations
//
// Entry:		Size of memory to allocate
//
// Exit:		Pointer to allocated memory
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNMemoryTrackHeapAlloc"

void	*DNMemoryTrackHeapAlloc( const UINT_PTR Size )
{
	UINT_PTR	RequiredSize;
	MEMORY_LINK	*pMemoryLink;
	void		*pReturn;


	//
	// Voice and lobby currently try allocating 0 byte buffers, can't enable this check yet.
	//
	//ASSERT( Size > 0 );

	RequiredSize = Size + sizeof( MEMORY_LINK ) + ( sizeof( DWORD_PTR ) * 2 );
	DNMemoryTrackingValidateMemory();

	pMemoryLink = static_cast<MEMORY_LINK*>( HeapAlloc( g_hMemoryHeap, 0, RequiredSize ) );
	if ( pMemoryLink != NULL )
	{
		pMemoryLink->Initialize();

		EnterCriticalSection( &g_AllocatedMemoryLock );

		g_uAllocatedMemoryCount++;
		pMemoryLink->SetSize( Size );
		pMemoryLink->LinkAfterOther( g_AllocatedMemory );
		pMemoryLink->NoteCurrentCallStack();
		pMemoryLink->SetOverrunSignatures();

		LeaveCriticalSection( &g_AllocatedMemoryLock );

		pReturn = pMemoryLink->GetDataPointer();
	}
	else
	{
		pReturn = NULL;
	}

	return	pReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNMemoryTrackHeapReAlloc - reallocate from heap and track allocations
//
// Entry:		Pointer to old memory
//				Size of memory to allocate
//
// Exit:		Pointer to allocated memory
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNMemoryTrackHeapReAlloc"

void	*DNMemoryTrackHeapReAlloc( void *const pMemory, const UINT_PTR MemorySize )
{
	UINT_PTR	RequiredSize;
	MEMORY_LINK	*pMemoryLink;
	void		*pReturn;


	ASSERT( pMemory != NULL );
	//
	// Voice and lobby currently try allocating 0 byte buffers, can't enable this check yet.
	//
	//ASSERT( MemorySize > 0 );

	pMemoryLink = MEMORY_LINK::PointerFromData( pMemory );

	DNMemoryTrackingValidateMemory();

	EnterCriticalSection( &g_AllocatedMemoryLock );
	g_uAllocatedMemoryCount--;
	pMemoryLink->RemoveFromList();
	pMemoryLink->SetSize( 0 );
	LeaveCriticalSection( &g_AllocatedMemoryLock );

	RequiredSize = MemorySize + sizeof( MEMORY_LINK ) + ( sizeof( DWORD_PTR ) * 2 );
	pMemoryLink = static_cast<MEMORY_LINK*>( HeapReAlloc( g_hMemoryHeap, 0, pMemoryLink, RequiredSize ) );
	if ( pMemoryLink != NULL )
	{
		EnterCriticalSection( &g_AllocatedMemoryLock );

		g_uAllocatedMemoryCount++;
		pMemoryLink->SetSize( MemorySize );
		pMemoryLink->LinkAfterOther( g_AllocatedMemory );
		pMemoryLink->SetOverrunSignatures();

		LeaveCriticalSection( & g_AllocatedMemoryLock );

		pReturn = pMemoryLink->GetDataPointer();
	}
	else
	{
		pReturn = NULL;
	}

	return	pReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNMemoryTrackHeapFree - free from heap and track memory
//
// Entry:		Pointer to old memory
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNMemoryTrackHeapFree"

void	DNMemoryTrackHeapFree( void *const pMemory )
{
	MEMORY_LINK	*pMemoryLink;
	ASSERT( pMemory != NULL );


	DNMemoryTrackingValidateMemory();

	pMemoryLink = MEMORY_LINK::PointerFromData( pMemory );
	EnterCriticalSection( &g_AllocatedMemoryLock );

	g_uAllocatedMemoryCount--;
	pMemoryLink->RemoveFromList();
	pMemoryLink->SetSize( 0 );

	LeaveCriticalSection( &g_AllocatedMemoryLock );

	HeapFree( g_hMemoryHeap, 0, pMemoryLink );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNMemoryTrackValidateMemory - validate allocated memory
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNMemoryTrackingValidateMemory"

void	DNMemoryTrackingValidateMemory( void )
{
	MEMORY_LINK	*pMemoryLink;
	char	CallStackBuffer[ CALLSTACK_BUFFER_SIZE ];


	//
	// validate all of the allocated memory
	//
	EnterCriticalSection( &g_AllocatedMemoryLock );

	pMemoryLink = g_AllocatedMemory.GetNext();
	while ( pMemoryLink != &g_AllocatedMemory )
	{
		if ( pMemoryLink->IsCorrupted() != FALSE )
		{
			UINT_PTR	MessageReturn;
			char	MessageString[ 1000 ];

			wsprintf( MessageString,
					  // 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers and handles.
#ifdef _IA64_
                      // 8/05/2000(RichGr) - IA64: GetSize() returns UINT_PTR (64-bit), so we may as well handle in hex as %d expects a DWORD.
					  "Memory block: 0x%p\tAllocated size: 0x%p bytes\nCorruption Type: ",
#else
					  "Memory block: 0x%08x\tAllocated size: %d bytes\nCorruption Type: ",
#endif
					  pMemoryLink->GetDataPointer(),
					  pMemoryLink->GetSize() );

			if ( !pMemoryLink->IsValid() )
			{
				strcat( MessageString, " ,INVALID LINK");
			}
			if ( pMemoryLink->UnderrunDetected() )
			{
				strcat( MessageString, " ,UNDERRUN DETECTED");
			}
			if ( pMemoryLink->OverrunDetected() )
			{
				strcat( MessageString, " ,OVERRUN DETECTED");
			}
			
			pMemoryLink->GetCallStack( CallStackBuffer );
			MessageReturn = DisplayCallStack( MessageString, "Memory Corruption!", CallStackBuffer );
			switch ( MessageReturn )
			{
				case IDABORT:
				{
					DNASSERT( FALSE );
					break;
				}

				case IDIGNORE:
				{
					//
					// You're probably going to get stopped in the heap
					// manager!!!
					//
					break;
				}

				case IDRETRY:
				{
					DNASSERT( FALSE );
					break;
				}
			}
		}

		pMemoryLink = pMemoryLink->GetNext();
	}

	LeaveCriticalSection( &g_AllocatedMemoryLock );

	//
	// ask the OS to validate the heap
	//
	if ( HeapValidate( g_hMemoryHeap, 0, NULL ) == FALSE )
	{
		DNASSERT( FALSE );
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNMemoryTrackDisplayMemoryLeaks - display memory leaks
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNMemoryTrackDisplayMemoryLeaks"

static	void	DNMemoryTrackDisplayMemoryLeaks( void )
{
	BOOL	fDisplayLeaks;
	UINT_PTR	uMaxMemoryLeakCount;
	UINT_PTR	uMemoryLeakIndex;

	//
	// initialize
	//
	fDisplayLeaks = TRUE;
	uMaxMemoryLeakCount = g_uAllocatedMemoryCount;
	uMemoryLeakIndex = 0;

	//
	// Check for outstanding memory allocations.
	//
	while ( g_AllocatedMemory.IsEmpty() == FALSE )
	{	
		MEMORY_LINK	*pTemp;
		UINT_PTR	MessageReturn;
		char		CallStackBuffer[ CALLSTACK_BUFFER_SIZE ];
		char		LeakSizeString[ 50 ];
		char		DialogTitle[ 1000 ];


		pTemp = g_AllocatedMemory.GetNext();
		
		uMemoryLeakIndex++;
		// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers and handles.
#ifdef _IA64_
        // 8/05/2000(RichGr) - IA64: GetSize() returns UINT_PTR (64-bit), so we may as well handle in hex as %d expects a DWORD.
		wsprintf( LeakSizeString, "0x%p bytes leaked at address 0x%p!\n", pTemp->GetSize(), pTemp->GetDataPointer() );
#else
		wsprintf( LeakSizeString, "%d bytes leaked at address 0x%08x!\n", pTemp->GetSize(), pTemp->GetDataPointer() );
#endif
		wsprintf( DialogTitle,
				  "DirectPlay8 memory leak detected! ( #%d of %d )",
				  uMemoryLeakIndex,
				  uMaxMemoryLeakCount );
		pTemp->GetCallStack( CallStackBuffer );


		if ( ( g_dwMemLeakDisplayFlags & MEMORY_LEAK_REPORT_DPF ) != 0 )
		{
			DPFX(DPFPREP,  0, "%s%s%s\n", DialogTitle, LeakSizeString, CallStackBuffer );
		}

		if ( ( g_dwMemLeakDisplayFlags & MEMORY_LEAK_REPORT_DIALOG ) != 0  )
		{
			if ( fDisplayLeaks != FALSE )
			{
				MessageReturn = DisplayCallStack( LeakSizeString, DialogTitle, CallStackBuffer );
				switch ( MessageReturn )
				{	
					//
					// stop application now
					//
					case IDABORT:
					{
						fDisplayLeaks = FALSE;
						break;
					}

					//
					// display next leak
					//
					case IDIGNORE:
					{
						break;
					}

					//
					// stop in the debugger
					//
					case IDRETRY:
					{
						DNASSERT( FALSE );
						break;
					}

					//
					// unknown
					//
					default:
					{
						DNASSERT( FALSE );
						break;
					}
				}
			}
		}

		DNFree( pTemp->GetDataPointer() );
	}
}
//**********************************************************************


//**********************************************************************
//**
//** THIS IS THE END OF THE MEMORY LOGGING SECTION.
//**
//**********************************************************************
#endif	// DN_MEMORY_TRACKING



#if	defined( DN_MEMORY_TRACKING ) || defined( DN_CRITICAL_SECTION_TRACKING )
//**********************************************************************
// ------------------------------
// DisplayCallStack - display a call stack message box
//
// Entry:		Pointer to information string
//				Pointer to title string
//				Pointer to call stack string
//
// Exit:		Dialog return code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DisplayCallStack"

static int	DisplayCallStack( const char *const pszMsg, const char *const pszTitle, const char *const pCallStackString )
{
	MSGBOXPARAMS	MessageBoxParams;
	char 			szStackTraceMsg[ CALLSTACK_BUFFER_SIZE ];

	_snprintf(szStackTraceMsg, CALLSTACK_BUFFER_SIZE-1, "%s%s", pszMsg, pCallStackString);

	//
	// display message box
	//
	memset( &MessageBoxParams, 0x00, sizeof( MessageBoxParams ) );
	MessageBoxParams.cbSize = sizeof( MessageBoxParams );
	MessageBoxParams.lpszText = szStackTraceMsg;
	MessageBoxParams.lpszCaption = pszTitle;
	MessageBoxParams.dwStyle = MB_ABORTRETRYIGNORE | MB_SETFOREGROUND | MB_TOPMOST | MB_DEFBUTTON2;
	MessageBoxParams.hInstance = NULL;

	return MessageBoxIndirect( &MessageBoxParams );
}
//**********************************************************************


//**********************************************************************
//**
//** END OF CALL STACK TRACKING SECTION.
//**
//**********************************************************************
#endif	// defined( DN_MEMORY_TRACKING ) || defined( DN_CRITICAL_SECTION_TRACKING )



#ifdef	DN_CRITICAL_SECTION_TRACKING
//**********************************************************************
//**
//** THIS IS THE CRITICAL-SECTION TRACKING SECTION.  DON'T ADD FUNCTIONS HERE
//** THAT ARE NOT FOR CRITICAL SECTIONS!!
//**
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNCSTrackInitialize - initialize critical section tracking code
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = initialization succeeded
//				FALSE = initialization failed
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackInitialize"

static	BOOL	DNCSTrackInitialize( void )
{
	g_blCritSecs.Initialize();

	return	DNInitializeCriticalSection(&g_CSLock);
}
//**********************************************************************



//**********************************************************************
// ------------------------------
// DNCSTrackSetCriticalSectionRecursionCount - set the maximum recursion depth
//		allowed by a DNCRITICAL_SECTION.
//
// Entry:		Pointer to critical section
//				Recursion count
//
// Exit:		Nothing
//
// Note:	The recursion count is the number of times we allow reentry so
//			we need to bais by one to allow the user to take the lock at
//			least once.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackSetCriticalRecursionCount"

void	DNCSTrackSetCriticalSectionRecursionCount( DNCRITICAL_SECTION *const pCriticalSection, const UINT_PTR RecursionCount )
{
	UINT_PTR	LocalRecursionCount;


	DNASSERT( pCriticalSection != NULL );

	//
	// make sure we don't overflow
	//
	LocalRecursionCount = RecursionCount;
	if ( LocalRecursionCount == -1 )
	{
		LocalRecursionCount--;
	}

	pCriticalSection->MaxLockCount = LocalRecursionCount + 1;
	DNASSERT( pCriticalSection->MaxLockCount != 0 );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNCSTrackEnterCriticalSection - enter a debug critical section
//
// Entry:		Pointer to critical section
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackEnterCriticalSection"

void	DNCSTrackEnterCriticalSection( DNCRITICAL_SECTION *const pCriticalSection )
{
	UINT_PTR	ThisThreadID;
	static	BOOL	fDisplayCallStacks = TRUE;


	DNASSERT( pCriticalSection != NULL );

	EnterCriticalSection( &pCriticalSection->CriticalSection );
	ThisThreadID = GetCurrentThreadId();
	if ( pCriticalSection->OwningThreadID != ThisThreadID )
	{
		DNASSERT( pCriticalSection->OwningThreadID == DN_INVALID_THREAD_ID );

		pCriticalSection->OwningThreadID = ThisThreadID;
		DNASSERT( pCriticalSection->LockCount == 0 );
	}
	else
	{
		DNASSERT( pCriticalSection->LockCount != 0 );
	}

	if ( pCriticalSection->LockCount == 0 )
	{
		pCriticalSection->CallStack.NoteCurrentCallStack();
	}
	pCriticalSection->LockCount++;

	if ( pCriticalSection->LockCount > pCriticalSection->MaxLockCount )
	{
		if ( pCriticalSection->MaxLockCount == 1 )
		{
			if ( fDisplayCallStacks != FALSE )
			{
				char	CallStackBuffer[ CALLSTACK_BUFFER_SIZE ];


				//
				// Exceeded recursion depth of 1, display stack of call orignally
				// holding the lock.
				//
				pCriticalSection->CallStack.GetCallStackString( CallStackBuffer );
				switch ( DisplayCallStack( "Stack trace of function that originally held the lock:",
										   "DNCritical section has been reentered!",
										   CallStackBuffer ) )
				{
					//
					// don't display any more critical section warnings!
					//
					case IDABORT:
					{
						fDisplayCallStacks = FALSE;
						break;
					}

					//
					// acknowledged
					//
					case IDIGNORE:
					{
						break;
					}

					//
					// stop in debugger
					//
					case IDRETRY:
					{
						DNASSERT( FALSE );
						break;
					}
				}
			}

		}
		else
		{
			//
			// exceeded recursion depth, check your code!!
			//
			DNASSERT( FALSE );
		}
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNCSTrackLeaveCriticalSection - leave a debug critical section
//
// Entry:		Pointer to critical section
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackLeaveCriticalSection"

void	DNCSTrackLeaveCriticalSection( DNCRITICAL_SECTION *const pCriticalSection )
{
	DNASSERT( pCriticalSection != NULL );

	DNASSERT( pCriticalSection->OwningThreadID == GetCurrentThreadId() );

	DNASSERT( pCriticalSection->LockCount <= pCriticalSection->MaxLockCount );
	DNASSERT( pCriticalSection->LockCount != 0 );
	pCriticalSection->LockCount--;

	if ( pCriticalSection->LockCount == 0 )
	{
		memset( &pCriticalSection->CallStack, 0x00, sizeof( pCriticalSection->CallStack ) );
		pCriticalSection->OwningThreadID = DN_INVALID_THREAD_ID;
	}

	LeaveCriticalSection( &pCriticalSection->CriticalSection );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNCSTrackCriticalSectionIsTakenByThisThread - determine if this thread has taken a
//		specific critical section
//
// Entry:		Pointer to critical section
//				Boolean condition to test for
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackCriticalSectionIsTakenByThisThread"

void	DNCSTrackCriticalSectionIsTakenByThisThread( const DNCRITICAL_SECTION *const pCriticalSection, const BOOL fFlag )
{
	ASSERT( fFlag == ( pCriticalSection->OwningThreadID == GetCurrentThreadId() ) )
}
//**********************************************************************


//**********************************************************************
//**
//** THIS IS THE END OF THE CRITICAL-SECTION TRACKING CODE.
//**
//**********************************************************************
#endif	// DN_CRITICAL_SECTION_TRACKING
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\packbuff.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       PackBuff.cpp
 *  Content:	Packed Buffers
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/01/00	mjn		Created
 *  06/15/2000  rmt     Added func to add string to packbuffer
 *  02/06/2001	rodtoll	WINBUG #293871: DPLOBBY8: [IA64] Lobby launching a 64-bit 
 * 						app from 64-bit lobby launcher crashes with unaligned memory error. 
 ***************************************************************************/

#include "dncmni.h"
#include "PackBuff.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CPackedBuffer::Initialize
//
// Entry:		void *const	pvBuffer		- Buffer to fill up (may be NULL)
//				const DWORD	dwBufferSize	- Size of buffer (may be 0)
//
// Exit:		Nothing
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CPackedBuffer::Initialize"
void CPackedBuffer::Initialize(void *const pvBuffer,
								  const DWORD dwBufferSize, const BOOL fAlignRequired)
{
	if (pvBuffer == NULL || dwBufferSize == 0)
	{
		m_pStart = NULL;
		m_pHead = NULL;
		m_pTail = NULL;
		m_dwRemaining = 0;
		m_bBufferTooSmall = TRUE;
	}
	else
	{
		m_pStart = reinterpret_cast<BYTE*>(pvBuffer);
		m_pHead = m_pStart;
		m_pTail = m_pStart + dwBufferSize;
		m_dwRemaining = dwBufferSize;

		if( fAlignRequired )
		{
			DWORD dwExtra = m_dwRemaining % sizeof( void * );

			m_dwRemaining -= dwExtra;
			m_pTail -= dwExtra;
		}
		
		m_bBufferTooSmall = FALSE;
	}
	m_dwRequired = 0;
}


//**********************************************************************
// ------------------------------
// CPackedBuffer::AddToFront
//
// Entry:		void *const	pvBuffer		- Buffer to add (may be NULL)
//				const DWORD	dwBufferSize	- Size of buffer (may be 0)
//
// Exit:		Error Code:	DPN_OK					if able to add
//							DPNERR_BUFFERTOOSMALL	if buffer is full
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CPackedBuffer::AddToFront"
HRESULT CPackedBuffer::AddToFront(const void *const pvBuffer,
								  const DWORD dwBufferSize, 
								  const BOOL fAlignedRequired )
{
	DWORD dwBytesToAdd = dwBufferSize;

	if( fAlignedRequired )
	{
		DWORD dwNumBytesFromAligned = dwBufferSize % sizeof( void *);

		if( dwNumBytesFromAligned )
		{
			dwBytesToAdd += sizeof( void * ) - dwNumBytesFromAligned;
		}

	}

	DPFX( DPFPREP, 9, "Adding to front: %d bytes --> %d bytes aligned, pointer %p new pointer %p", dwBufferSize, dwBytesToAdd, m_pHead, m_pHead + dwBytesToAdd	 );	

	m_dwRequired += dwBytesToAdd;
	if (!m_bBufferTooSmall)
	{
		if (m_dwRemaining >= dwBytesToAdd)
		{
			if (pvBuffer)
			{
				memcpy(m_pHead,pvBuffer,dwBufferSize);
			}
			m_pHead += dwBytesToAdd;
			
			m_dwRemaining -= dwBytesToAdd;
		}
		else
		{
			m_bBufferTooSmall = TRUE;
		}
	}

	if (m_bBufferTooSmall)
		return(DPNERR_BUFFERTOOSMALL);

	return(DPN_OK);
}

//**********************************************************************
// ------------------------------
// CPackedBuffer::AddWCHARStringToBack
//
// Entry:		const wchar_t * const pwszString - String to add (may be NULL)
//
// Exit:		Error Code:	DPN_OK					if able to add
//							DPNERR_BUFFERTOOSMALL	if buffer is full
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CPackedBuffer::AddWCHARStringToBack"
HRESULT CPackedBuffer::AddWCHARStringToBack( const wchar_t * const pwszString, const BOOL fAlignedRequired )
{
    return AddToBack( pwszString, sizeof( wchar_t ) * (wcslen( pwszString )+1), fAlignedRequired );
}

//**********************************************************************
// ------------------------------
// CPackedBuffer::AddStringToBack
//
// Entry:		Pointer to source string
//
// Exit:		Error Code:	DPN_OK					if able to add
//							DPNERR_BUFFERTOOSMALL	if buffer is full
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CPackedBuffer::AddStringToBack"
HRESULT CPackedBuffer::AddStringToBack( const char *const pszString )
{
	HRESULT	hr;
	DWORD	dwStringSize;
	DWORD	dwBufferSize;


	DNASSERT( pszString != NULL );
	
	//
	// initialize
	//
	hr = DPN_OK;

	dwStringSize = 0;
	hr = STR_AnsiToWide( pszString,
						 -1,
						 NULL,
						 &dwStringSize );
	if ( hr != DPNERR_BUFFERTOOSMALL )
	{
		DNASSERT( hr != DPN_OK );
		goto Failure;
	}
	
	dwBufferSize = dwStringSize * sizeof( WCHAR );
	m_dwRequired += dwBufferSize;
	if ( !m_bBufferTooSmall )
	{
		if (m_dwRemaining >= dwBufferSize)
		{
			m_pTail -= dwBufferSize;
			m_dwRemaining -= dwBufferSize;
			hr = STR_AnsiToWide( pszString,
								 -1,
								 reinterpret_cast<WCHAR*>( m_pTail ),
								 &dwStringSize );
			if ( hr != DPN_OK )
			{
				goto Failure;
			}

			DNASSERT( ( dwStringSize * sizeof( WCHAR ) ) == dwBufferSize );
		}
		else
		{
			m_bBufferTooSmall = TRUE;
		}
	}

	if ( m_bBufferTooSmall )
	{
		hr = DPNERR_BUFFERTOOSMALL;
	}

Exit:
	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************
// ------------------------------
// CPackedBuffer::AddToBack
//
// Entry:		void *const	pvBuffer		- Buffer to add (may be NULL)
//				const DWORD	dwBufferSize	- Size of buffer (may be 0)
//
// Exit:		Error Code:	DPN_OK					if able to add
//							DPNERR_BUFFERTOOSMALL	if buffer is full
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CPackedBuffer::AddToBack"
HRESULT CPackedBuffer::AddToBack(const void *const pvBuffer,
								 const DWORD dwBufferSize, 
								 const BOOL fAlignedRequired )
{
	DWORD dwBytesToAdd = dwBufferSize;

	if( fAlignedRequired )
	{
		DWORD dwNumBytesFromAligned = dwBufferSize % sizeof( void * );

		if( dwNumBytesFromAligned )
		{
			dwBytesToAdd += sizeof( void * ) - dwNumBytesFromAligned;
		}
	}

	DPFX( DPFPREP, 9, "Adding to back: %d bytes --> %d bytes aligned, pointer %p new pointer %p", dwBufferSize, dwBytesToAdd, m_pTail, m_pTail -dwBytesToAdd	 );
	
	m_dwRequired += dwBytesToAdd;
	if (!m_bBufferTooSmall)
	{
		if (m_dwRemaining >= dwBytesToAdd)
		{
			m_pTail -= dwBytesToAdd;

			m_dwRemaining -= dwBytesToAdd;
			if (pvBuffer)
			{
				memcpy(m_pTail,pvBuffer,dwBufferSize);
			}
		}
		else
		{
			m_bBufferTooSmall = TRUE;
		}
	}

	if (m_bBufferTooSmall)
		return(DPNERR_BUFFERTOOSMALL);

	return(DPN_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\packbuff.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       PackBuff.h
 *  Content:	Packed Buffers
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/11/00	mjn		Created
 *  06/15/2000  rmt     Added func to add string to packbuffer
 *  02/06/2001	rodtoll	WINBUG #293871: DPLOBBY8: [IA64] Lobby launching a 64-bit 
 * 						app from 64-bit lobby launcher crashes with unaligned memory error.
 *
 ***************************************************************************/

#ifndef __PACK_BUFF_H__
#define __PACK_BUFF_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for packed buffer

class CPackedBuffer
{
public:
	CPackedBuffer() { };	// Constructor

	~CPackedBuffer() { };	// Destructor

	void	Initialize(	void *const pvBuffer,
						const DWORD dwBufferSize, 
						const BOOL fAlignedRequired = FALSE );

	HRESULT AddToFront( const void *const pvBuffer,
						const DWORD dwBufferSize, const BOOL fAlignedRequired = FALSE );

	HRESULT AddToBack( const void *const pvBuffer,
						const DWORD dwBufferSize, 
						const BOOL fAlignedRequired = FALSE );

	PVOID GetStartAddress( void ) { return m_pStart; };

    HRESULT AddWCHARStringToBack( const wchar_t * const pwszString, const BOOL fAlignedRequired  = FALSE );					
	HRESULT	AddStringToBack( const char *const pszString );

	PVOID GetHeadAddress( void ) const { return( m_pHead ); }

	PVOID GetTailAddress( void ) const { return( m_pTail ); }

	DWORD GetHeadOffset( void ) const
	{
		return( (DWORD)(m_pHead - m_pStart) );
	}

	DWORD GetTailOffset( void ) const
	{
		return( (DWORD)(m_pTail - m_pStart) );
	}

	DWORD GetSpaceRemaining( void ) const { return( m_dwRemaining ); }

	DWORD GetSizeRequired( void ) const { return( m_dwRequired ); }

private:
	BYTE	*m_pStart;			// Start of the buffer
	BYTE	*m_pHead;			// Pointer to head of free buffer
	BYTE	*m_pTail;			// Pointer to tail of free buffer
	DWORD	m_dwRemaining;		// bytes remaining in buffer
	DWORD	m_dwRequired;		// bytes required so far
	BOOL	m_bBufferTooSmall;	// buffer has run out of space
};



#endif	// __PACK_BUFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\osind.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       OSInd.h
 *  Content:	OS indirection functions to abstract OS specific items.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/12/99	jtk		Created
 * 	09/21/99	rodtoll		Fixed for retail build
 *   	08/28/2000	masonb		Voice Merge: Fix for code that only defines one of DEBUG, DBG, _DEBUG
 *   	08/28/2000	masonb		Voice Merge: Added IsUnicodePlatform macro
 *
 ***************************************************************************/

#ifndef	__OSIND_H__
#define	__OSIND_H__

#include	"CallStack.h"
#include	"ClassBilink.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//
// defines for resource tracking
//

// Make sure all variations of DEBUG are defined if any one is
#if defined(DEBUG) || defined(DBG) || defined(_DEBUG)
#if !defined(DBG)
#define DBG
#endif
#if !defined(DEBUG)
#define DEBUG
#endif
#if !defined(_DEBUG)
#define _DEBUG
#endif
#endif

#ifdef	DEBUG
#define	DN_MEMORY_TRACKING
#define	DN_CRITICAL_SECTION_TRACKING
#endif	// DEBUG

#define	DN_MEMORY_CALL_STACK_DEPTH				12
#define	DN_CRITICAL_SECTION_CALL_STACK_DEPTH	10

//
// debug value for invalid thread ID
//
#define	DN_INVALID_THREAD_ID			-1

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// critical section
//
typedef	struct
{
	CRITICAL_SECTION	CriticalSection;

#ifdef	DN_CRITICAL_SECTION_TRACKING
	UINT_PTR		OwningThreadID;
	UINT_PTR		MaxLockCount;
	UINT_PTR		LockCount;
	CCallStack< DN_CRITICAL_SECTION_CALL_STACK_DEPTH > 	CallStack;
	CCallStack< DN_CRITICAL_SECTION_CALL_STACK_DEPTH > 	AllocCallStack;
	CBilink			blCritSec;
#endif	// DN_CRITICAL_SECTION_TRACKING

} DNCRITICAL_SECTION;

//
// DirectNet time variable.  Currently 64-bit, but can be made larger
//
typedef	union
{
	UINT_PTR	Time64;

	struct
	{
		DWORD	TimeLow;
		DWORD	TimeHigh;
	} Time32;
} DN_TIME;

//**********************************************************************
// Variable definitions
//**********************************************************************
extern	HANDLE	g_hMemoryHeap;

//**********************************************************************
// Function prototypes
//**********************************************************************

//
// initialization functions
//
BOOL	DNOSIndirectionInit( void );
void	DNOSIndirectionDeinit( void );

//
// Function to get OS version.  Supported returns:
//	VER_PLATFORM_WIN32_WINDOWS - Win9x
//	VER_PLATFORM_WIN32_NT - WinNT
//	VER_PLATFORM_WIN32s - Win32s on Win3.1
//	VER_PLATFORM_WIN32_CE - WinCE
//	
UINT_PTR	DNGetOSType( void );
BOOL		DNOSIsXPOrGreater( void );
HINSTANCE	DNGetApplicationInstance( void );
PSECURITY_ATTRIBUTES DNGetNullDacl();

#define		IsUnicodePlatform (DNGetOSType() == VER_PLATFORM_WIN32_NT)

#define GETTIMESTAMP() timeGetTime()

//
// time functions
//
void		DNTimeGet( DN_TIME *const pTimeDestination );
INT_PTR		DNTimeCompare( const DN_TIME *const pTime1, const DN_TIME *const pTime2 );
void		DNTimeAdd( const DN_TIME *const pTime1, const DN_TIME *const pTime2, DN_TIME *const pTimeResult );
void		DNTimeSubtract( const DN_TIME *const pTime1, const DN_TIME *const pTime2, DN_TIME *const pTimeResult );


//
// CriticalSection functions
//
#ifdef	DN_CRITICAL_SECTION_TRACKING

#define	DNEnterCriticalSection( arg )	DNCSTrackEnterCriticalSection( arg )
#define	DNLeaveCriticalSection( arg )	DNCSTrackLeaveCriticalSection( arg )
#define	AssertCriticalSectionIsTakenByThisThread( pCS, Flag )	DNCSTrackCriticalSectionIsTakenByThisThread( pCS, Flag )
#define	DebugSetCriticalSectionRecursionCount( pCS, Count )		DNCSTrackSetCriticalSectionRecursionCount( pCS, Count )

void	DNCSTrackEnterCriticalSection( DNCRITICAL_SECTION *const pCriticalSection );
void	DNCSTrackLeaveCriticalSection( DNCRITICAL_SECTION *const pCriticalSection );
void	DNCSTrackSetCriticalSectionRecursionCount( DNCRITICAL_SECTION *const pCriticalSection, const UINT_PTR RecursionCount );
void	DNCSTrackCriticalSectionIsTakenByThisThread( const DNCRITICAL_SECTION *const pCriticalSection, const BOOL fFlag );

#else	// DN_CRITICAL_SECTION_TRACKING

#define	AssertCriticalSectionIsTakenByThisThread( pCS, Flag )
#define	DebugSetCriticalSectionRecursionCount( pCS, Count )
#define	DNEnterCriticalSection( arg )	EnterCriticalSection( &((arg)->CriticalSection) )
#define	DNLeaveCriticalSection( arg )	LeaveCriticalSection( &((arg)->CriticalSection) )

#endif	// DN_CRITICAL_SECTION_TRACKING

BOOL	DNInitializeCriticalSection( DNCRITICAL_SECTION *const pCriticalSection );
void	DNDeleteCriticalSection( DNCRITICAL_SECTION *const pCriticalSection );

#ifdef	DN_MEMORY_TRACKING

#define	DNMalloc( size )				DNMemoryTrackHeapAlloc( size )
#define	DNRealloc( pMemory, size )		DNMemoryTrackHeapReAlloc( pMemory, size )
#define	DNFree( pData )					DNMemoryTrackHeapFree( pData )

void	*DNMemoryTrackHeapAlloc( const UINT_PTR MemorySize );
void	*DNMemoryTrackHeapReAlloc( void *const pMemory, const UINT_PTR MemorySize );
void	DNMemoryTrackHeapFree( void *const pMemory );
void	DNMemoryTrackDisplayMemoryLeaks( void );
void	DNMemoryTrackingValidateMemory( void );

#else	// DN_MEMORY_TRACKING

#define	DNMalloc( size )				HeapAlloc( g_hMemoryHeap, 0, size )
#define	DNRealloc( pMemory, size )		HeapReAlloc( g_hMemoryHeap, 0, pMemory, size )
#define	DNFree( pData )					HeapFree( g_hMemoryHeap, 0, pData )

#endif	// DN_MEMORY_TRACKING

//
// Memory functions
//

//**********************************************************************
// ------------------------------
// operator new - allocate memory for a C++ class
//
// Entry:		Size of memory to allocate
//
// Exit:		Pointer to memory
//				NULL = no memory available
//
// Notes:	This function is for classes only and will ASSERT on zero sized
//			allocations!  This function also doesn't do the whole proper class
//			thing of checking for replacement 'new handlers' and will not throw
//			an exception if allocation fails.
// ------------------------------
inline	void*	__cdecl operator new( size_t size )
{
	return DNMalloc( size );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// operator delete - deallocate memory for a C++ class
//
// Entry:		Pointer to memory
//
// Exit:		Nothing
//
// Notes:	This function is for classes only and will ASSERT on NULL frees!
// ------------------------------
inline	void	__cdecl operator delete( void *pData )
{
	//
	// Voice and lobby currently try allocating 0 byte buffers, can't disable this check yet.
	//
	if( pData == NULL )
		return;
	
	DNFree( pData );
}
//**********************************************************************



#endif	// __OSIND_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\perfinfo.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       perfinfo.h
 *  Content:	Performance tracking related code
 *				
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  ??-??-????  rodtoll	Created
 *	12-12-2000	rodtoll	Re-organize performance struct to handle data misalignment errors on IA64
 *
 ***************************************************************************/
#ifndef __PERFINFO_H
#define __PERFINFO_H

//
// This library provides support for exporting performance information from an application/DLL.
//
// An application can register will this library to be given a global memory block that other
// processes can read.  The application writes to the global memory block created by this 
// library.  Applications wishing to retrieve performance data can retrieve a list of
// applications who are using the library and optionally gain access to the performance
// data from within their own process.  
//
// The format of the central memory block is as follows:  
// <PERF_HEADER>
// <PERF_APPLICATION> (For app 0)
// <PERF_APPLICATION> (For app 1)
// ...
//
// The # of applications which can track performance data is limited to PERF_INSTANCE_BLOCK_MAXENTRIES
// which is defined in the perfinfo.cpp file.  
//
// Applications must tell this library how large a performance data block they want.  The format of the
// data within the block is application specific, so applications must have knowledge of the format to 
// use it.  
//
// Each process must make sure to call PERF_Initialize() in their process to enable access and must call
// PERF_DeInitialize to cleanup.
//
// Each element of the array of PERF_APPLICATION structures contains a flag field, if an entry is in use
// it will have the PERF_APPLICATION_VALID flag set.  When an application removes themselves this flag
// is cleared and the entry may be re-used.  (However, all of this should be done through the 
// functions in this library).
//
// Everytime an element is added or removed the table is checked for entries left behind by dead processes.
// If an entry exists for a process that has exited then it is removed from the table automatically.
//
// WARNING: Remember for 32/64bit interop you must ensure that the PERF_APPLICATION and PERF_HEADER are
// 		    quadword aligned.  
//
// Applications CAN have multiple entries in a single process.  You must insure that guidInternalInstance
// is unique amoung all the entries.  
//

// PERF_HEADER
//
// This structure is placed at the head of the central memory block.
// 
typedef struct _PERF_HEADER
{
	LONG lNumEntries;			// # of entries in the central memory block
	DWORD dwPack;  				// Alignment DWORD to ensure quadword alignment.
} PERF_HEADER, *PPERF_HEADER;

// PERF_APPLICATION_INFO
//
// This structure is used to track instance specific information.  So applications who add an
// entry into the global perf information table will have to store a copy of this structure
// that they get from the call to PERF_AddEntry.
//
typedef struct _PERF_APPLICATION_INFO
{
	HANDLE 	hFileMap;					
	PBYTE 	pbMemoryBlock;
	HANDLE 	hMutex;
} PERF_APPLICATION_INFO, *PPERF_APPLICATION_INFO;

// PERF_APPLICATION
//
// There is one of these structures for each entry in the performance library.  
//
// A single process can have multiple entries like this. 
//
// It tracks configuration information for an individual instance. 
//
// It is valid only if the PERF_APPLICATION_VALID flag is set on the dwFlags member
//
typedef struct _PERF_APPLICATION
{
	GUID 	guidApplicationInstance;		// Instance GUID (App usage)
	GUID 	guidInternalInstance;			// Per/interface instance instance GUID (MUST BE UNIQUE)
	GUID 	guidIID;						// Interface ID for this instance (App usage - suggested IID of interface using this)
	DWORD 	dwProcessID;					// Process ID
	DWORD 	dwFlags;						// Flags PERF_APPLICATION_XXXXX
	DWORD 	dwMemoryBlockSize;				// Size of the memory block
	DWORD 	dwPadding0;						// Padding to ensure Quadword alignment
} PERF_APPLICATION, *PPERF_APPLICATION;

// PERF_APPLICATION_VALID
//
// This flag is set on an entry if the entry is in use.
#define PERF_APPLICATION_VALID			0x00000001

// PERF_APPLICATION_VOICE
//
// The entry contains voice related statistics
#define PERF_APPLICATION_VOICE			0x00000002

// PERF_APPLICATION_TRANSPORT
//
// The entry contains transport related statistics
#define PERF_APPLICATION_TRANSPORT		0x00000004

// PERF_APPLICATION_SERVER
//
// The entry contains "server" statistics.
#define PERF_APPLICATION_SERVER			0x00000008

// PERF_Initialize
//
// Initialize the global "instance" list memory block.  Must be called once / process.
//
HRESULT PERF_Initialize( );


HRESULT PERF_AddEntry( PPERF_APPLICATION pperfApplication, PPERF_APPLICATION_INFO pperfApplicationInfo );


void PERF_RemoveEntry( GUID &guidInternalInstance, PPERF_APPLICATION_INFO pperfApplicationInfo );


void PERF_DeInitialize();

//
// Callback Function for table dumping
//
typedef HRESULT (WINAPI *PFNDUMPPERFTABLE)(PVOID, PPERF_APPLICATION, PBYTE);

void PERF_DumpTable( BOOL fGrabMutex, PVOID pvContext, PFNDUMPPERFTABLE pperfAppEntry );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\rcbuffer.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       RCBuffer.cpp
 *  Content:	RefCount Buffers
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/12/00	mjn		Created
 *	01/31/00	mjn		Allow user defined Alloc and Free
 ***************************************************************************/

#include "dncmni.h"
#include "RCBuffer.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CRefCountBuffer::Initialize
//
// Entry:		CFixedPool <CRefCountBuffer> *pFPRefCountBuffer
//				const DWORD dwBufferSize
//
// Exit:		Error Code:	DN_OK
//							DNERR_OUTOFMEMORY
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CRefCountBuffer::Initialize"

HRESULT CRefCountBuffer::Initialize(CLockedContextClassFixedPool <CRefCountBuffer> *pFPRefCountBuffer,
									PFNALLOC_REFCOUNT_BUFFER pfnAlloc,
									PFNFREE_REFCOUNT_BUFFER pfnFree,
									void *const pvContext,
									const DWORD dwBufferSize)
{
	DPFX(DPFPREP, 3,"Entered");

	DNASSERT(pFPRefCountBuffer != NULL);
	DNASSERT((pfnAlloc == NULL && pfnFree == NULL) || (pfnAlloc != NULL && pfnFree != NULL));

	m_pFPOOLRefCountBuffer = pFPRefCountBuffer;

	if (dwBufferSize)
	{
		if (pfnAlloc)
		{
			m_pfnAlloc = pfnAlloc;
			m_pfnFree = pfnFree;
			m_pvContext = pvContext;
		}
		else
		{
			m_pfnAlloc = RefCountBufferDefaultAlloc;
			m_pfnFree = RefCountBufferDefaultFree;
		}
		m_dnBufferDesc.pBufferData = static_cast<BYTE*>((pfnAlloc)(m_pvContext,dwBufferSize));
		if (m_dnBufferDesc.pBufferData == NULL)
		{
			return(DPNERR_OUTOFMEMORY);
		}
		m_dnBufferDesc.dwBufferSize = dwBufferSize;
	}

	return(DPN_OK);
}

/*	REMOVE
//**********************************************************************
// ------------------------------
// CRefCountBuffer::ReturnSelfToPool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CRefCountBuffer::ReturnSelfToPool"

void CRefCountBuffer::ReturnSelfToPool( void )
{
	DPFX(DPFPREP, 3,"Entered");

	DNASSERT(m_lRefCount == 0);
	m_pFPOOLRefCountBuffer->Release( this );
}

*/	
//**********************************************************************
// ------------------------------
// CRefCountBuffer::Release
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CRefCountBuffer::Release"

void CRefCountBuffer::Release( void )
{
	DNASSERT(m_lRefCount > 0);
	if ( InterlockedDecrement( &m_lRefCount ) == 0 )
	{
		if (m_pfnFree && m_dnBufferDesc.pBufferData)
		{
			(*m_pfnFree)(m_pvContext,m_dnBufferDesc.pBufferData);
			m_dnBufferDesc.pBufferData = NULL;
			m_dnBufferDesc.dwBufferSize = 0;
		}
		ReturnSelfToPool();
	}
}


PVOID RefCountBufferDefaultAlloc(void *const pv,const DWORD dwSize)
{
	return(DNMalloc(dwSize));
}


void RefCountBufferDefaultFree(PVOID pv,PVOID pvBuffer)
{
	DNFree(pvBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\perfinfo.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       perfinfo.h
 *  Content:	Performance tracking related code
 *				
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  ??-??-????  rodtoll	Created
 *	12-12-2000	rodtoll	Re-organize performance struct to handle data misalignment errors on IA64
 *
 ***************************************************************************/

#include "dncmni.h"
#include "PerfInfo.h"
#include <initguid.h>

// Name of block 
#define PERF_INSTANCE_BLOCK_NAME "{F10932E0-2556-4620-9ADE-F572406CFAEA}"

// GUID of block
DEFINE_GUID(PERF_INSTANCE_BLOCK_GUID, 
0xf10932e0, 0x2556, 0x4620, 0x9a, 0xde, 0xf5, 0x72, 0x40, 0x6c, 0xfa, 0xea);

#define PERF_INSTANCE_BLOCK_MUTEX_NAME "{2997F0C7-F135-405f-ABD4-8BAF491B3DAD}"

DEFINE_GUID(PERF_INSTANCE_BLOCK_MUTEX_GUID, 
0x2997f0c7, 0xf135, 0x405f, 0xab, 0xd4, 0x8b, 0xaf, 0x49, 0x1b, 0x3d, 0xad);

HANDLE g_hMutexInstanceBlock = NULL;
HANDLE g_hFileInstanceBlock = NULL;
BYTE *g_pbInstanceBlock = NULL;
PPERF_HEADER g_pperfHeader = NULL;
LONG *g_plNumEntries = NULL;
PPERF_APPLICATION g_pperfAppEntries = NULL;

#define PERF_INSTANCE_BLOCK_MAXENTRIES  100
#define PERF_INSTANCE_BLOCK_SIZE        ((sizeof( PERF_APPLICATION ) * PERF_INSTANCE_BLOCK_MAXENTRIES) + sizeof( PERF_HEADER ))
#define PERF_INFO_NAME_LENGTH		    64 // 38 for GUID string + room for Global prefix and mutex suffix

void PERF_Coalesce( DWORD dwProcessID = 0xFFFFFFFF );

#undef DPF_MODNAME
#define DPF_MODNAME "PERF_Initialize"
// PERF_Initialize
//
// Initialize the global "instance" list memory block 
//
HRESULT PERF_Initialize( )
{
    HRESULT hr = S_OK;
    BOOL fAlreadyExists = FALSE;


	if (DNGetOSType() == VER_PLATFORM_WIN32_NT)
	{
	    g_hMutexInstanceBlock = CreateMutexA( DNGetNullDacl(), FALSE, "Global\\" PERF_INSTANCE_BLOCK_MUTEX_NAME );
	}
	else
	{
	    g_hMutexInstanceBlock = CreateMutexA( DNGetNullDacl(), FALSE, PERF_INSTANCE_BLOCK_MUTEX_NAME );
	}

    if( g_hMutexInstanceBlock == NULL )
    {
        hr = GetLastError();
        DPFX(DPFPREP,  0, "Error initializing instance block hr=0x%x", hr );
        goto EXIT_ERROR;
    }

	if (DNGetOSType() == VER_PLATFORM_WIN32_NT)
	{
		g_hFileInstanceBlock = CreateFileMappingA(INVALID_HANDLE_VALUE,
											DNGetNullDacl(),
											PAGE_READWRITE,
											0,
											PERF_INSTANCE_BLOCK_SIZE,
											"Global\\" PERF_INSTANCE_BLOCK_NAME);
	}
	else
	{
		g_hFileInstanceBlock = CreateFileMappingA(INVALID_HANDLE_VALUE,
											DNGetNullDacl(),
											PAGE_READWRITE,
											0,
											PERF_INSTANCE_BLOCK_SIZE,
											PERF_INSTANCE_BLOCK_NAME);
	}
	if (g_hFileInstanceBlock == NULL)
	{
		hr = GetLastError();	    
		DPFX(DPFPREP,  0, "CreateFileMapping() failed hr=0x%x", hr);
        goto EXIT_ERROR;
	}
	
	if (GetLastError() == ERROR_ALREADY_EXISTS)
	{
	    fAlreadyExists = TRUE;
	}

	// Map file
	g_pbInstanceBlock = reinterpret_cast<BYTE*>(MapViewOfFile(g_hFileInstanceBlock,FILE_MAP_ALL_ACCESS,0,0,0));
	if (g_pbInstanceBlock == NULL)
	{
	    hr = GetLastError();
		DPFX(DPFPREP, 0,"MapViewOfFile() failed");
        goto EXIT_ERROR;
	}	

	g_pperfHeader = (PPERF_HEADER) g_pbInstanceBlock;

	g_plNumEntries = &g_pperfHeader->lNumEntries;
	g_pperfAppEntries = (PPERF_APPLICATION) &g_pperfHeader[1];

	// Access to entry count is protected by interlocked exchange
	if( !fAlreadyExists )
	{
        // Wait for the mutex to enter the block
        WaitForSingleObject( g_hMutexInstanceBlock, INFINITE );	    
        
        *g_plNumEntries = 0; 

        // Zero the memory in the block
        ZeroMemory( g_pbInstanceBlock, PERF_INSTANCE_BLOCK_SIZE );

        ReleaseMutex( g_hMutexInstanceBlock );
	}
	else
	{
        PERF_Coalesce();
	}

	return hr;

EXIT_ERROR:

    if( g_pbInstanceBlock )
    {
		UnmapViewOfFile(g_pbInstanceBlock);        
        g_pbInstanceBlock = NULL;
    }

    if( g_hFileInstanceBlock )
    {
        CloseHandle( g_hFileInstanceBlock );
        g_hFileInstanceBlock = NULL;
    }

    if( g_hMutexInstanceBlock )
    {
        CloseHandle( g_hMutexInstanceBlock );
        g_hMutexInstanceBlock = NULL;
    }

    return hr;

}

#undef DPF_MODNAME
#define DPF_MODNAME "PERF_CleanupEntry"
// PERF_CleanupEntry
//
// Cleanup global memory block for the entry
// 
void PERF_CleanupEntry( PPERF_APPLICATION pperfApplication, PPERF_APPLICATION_INFO pperfApplicationInfo  )
{
    if( pperfApplication->dwFlags & PERF_APPLICATION_VALID )
    {
        // This entry belongs to this process
        if( pperfApplicationInfo )
        {
            if( pperfApplicationInfo->pbMemoryBlock )
            {
                UnmapViewOfFile( pperfApplicationInfo->pbMemoryBlock );
            }

            if( pperfApplicationInfo->hFileMap )
            {
                CloseHandle( pperfApplicationInfo->hFileMap );
            }
        }

        ZeroMemory( pperfApplication, sizeof( PERF_APPLICATION ) );        

        (*g_plNumEntries)--;        
    }
    
}

#undef DPF_MODNAME
#define DPF_MODNAME "PERF_Coalesce"
// PERF_Coalesce
//
// Several routines run this function, the purpose is to run the list of processes 
// and remove dead processes from the list.
//
// WARNING: You must have the mutex when you enter this function
//
// Should be called when adding entries or reading entries.
//
// If called with a valid process ID then all entries for that process are removed
//  
void PERF_Coalesce( DWORD dwProcessID )
{
    if( !g_pbInstanceBlock )
        return;

    HANDLE hProcess;

    for( LONG lIndex = 0; lIndex < PERF_INSTANCE_BLOCK_MAXENTRIES; lIndex++ )
    {
		if( g_pperfAppEntries[lIndex].dwFlags & PERF_APPLICATION_VALID )
		{
			if( dwProcessID != 0xFFFFFFFF )
			{
				if( g_pperfAppEntries[lIndex].dwProcessID == dwProcessID )
					PERF_CleanupEntry( &g_pperfAppEntries[lIndex], NULL );
				break;
			}
			else
			{
				hProcess = OpenProcess( PROCESS_DUP_HANDLE, FALSE,  (DWORD) g_pperfAppEntries[lIndex].dwProcessID );

				// Check for process existance -- if it exists then leave entry, otherwise leave
    			if( !hProcess )
    				PERF_CleanupEntry( &g_pperfAppEntries[lIndex], NULL);     
    			else
    				CloseHandle( hProcess );   		    
			}
		}
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "PERF_AddEntry"
// PERF_AddEntry
//
// Requests the application be given a statistics block.  If succesful a memory block is allocated of the given size and 
// an entry is added to the central memory block.  The format of the datablock is application defined.
//
// Parameters for the entry to be created are specified in pperfApplication.  All entries in this structure should be 
// initialized except for dwProcessID which will be filled in by the system.
//  
// This function will fill the specified pperfApplicationInfo structure with information about the entry that was
// created.  This structure should be stored because it is needed in the call to PERF_RemoveEntry.
// 
HRESULT PERF_AddEntry( PPERF_APPLICATION pperfApplication, PPERF_APPLICATION_INFO pperfApplicationInfo )
{
    if( !g_pbInstanceBlock )
        return S_OK;

	// Zero the pperfApplicationInfo structture so in case of error it can be cleaned up properly
    ZeroMemory( pperfApplicationInfo, sizeof( PERF_APPLICATION_INFO ) );

    HRESULT hr = S_OK;

    // We need the mutex to access the block
    WaitForSingleObject( g_hMutexInstanceBlock, INFINITE );

    // Remove dead entries
    PERF_Coalesce();

    if( *g_plNumEntries >= PERF_INSTANCE_BLOCK_MAXENTRIES )
    {
        DPFX(DPFPREP,  0, "Instance block is full!" );
        hr = E_FAIL;
        ReleaseMutex( g_hMutexInstanceBlock );
        return hr;
    }

    for( LONG lIndex = 0; lIndex < PERF_INSTANCE_BLOCK_MAXENTRIES; lIndex++ )
    {
        // We've found a slot
        if( !(g_pperfAppEntries[lIndex].dwFlags & PERF_APPLICATION_VALID) )
        {
            DPFX(DPFPREP,  0, "Placing entry in index %i, pid=0x%x, flags=0x%x", lIndex, pperfApplication->dwProcessID, pperfApplication->dwFlags );
            memcpy( &g_pperfAppEntries[lIndex], pperfApplication, sizeof( PERF_APPLICATION ) );
            break;
        }
    }

    // Instance block is full -- wow. Shouldn't happen -- afterall we checked above.  
    if( lIndex == PERF_INSTANCE_BLOCK_MAXENTRIES )
    {
        // This should not happen, we have mutex AND checked entry count
        DNASSERT( FALSE );
        DPFX(DPFPREP,  0, "Unable to find an entry in the list" );
        hr = E_FAIL;
        ReleaseMutex( g_hMutexInstanceBlock );        
        return hr;
    }

    char szNameBuffer[PERF_INFO_NAME_LENGTH];

	// Build name for shared memory block
	if (DNGetOSType() == VER_PLATFORM_WIN32_NT)
	{
	    wsprintfA( szNameBuffer, "Global\\{%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}",
	    	     g_pperfAppEntries[lIndex].guidInternalInstance.Data1, g_pperfAppEntries[lIndex].guidInternalInstance.Data2, 
	    	     g_pperfAppEntries[lIndex].guidInternalInstance.Data3, g_pperfAppEntries[lIndex].guidInternalInstance.Data4[0], 
		         g_pperfAppEntries[lIndex].guidInternalInstance.Data4[1], g_pperfAppEntries[lIndex].guidInternalInstance.Data4[2], 
		         g_pperfAppEntries[lIndex].guidInternalInstance.Data4[3], g_pperfAppEntries[lIndex].guidInternalInstance.Data4[4], 
		         g_pperfAppEntries[lIndex].guidInternalInstance.Data4[5], g_pperfAppEntries[lIndex].guidInternalInstance.Data4[6], 
	             g_pperfAppEntries[lIndex].guidInternalInstance.Data4[7] );
	}
	else
	{
	    wsprintfA( szNameBuffer, "{%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}",
	    	     g_pperfAppEntries[lIndex].guidInternalInstance.Data1, g_pperfAppEntries[lIndex].guidInternalInstance.Data2, 
	    	     g_pperfAppEntries[lIndex].guidInternalInstance.Data3, g_pperfAppEntries[lIndex].guidInternalInstance.Data4[0], 
		         g_pperfAppEntries[lIndex].guidInternalInstance.Data4[1], g_pperfAppEntries[lIndex].guidInternalInstance.Data4[2], 
		         g_pperfAppEntries[lIndex].guidInternalInstance.Data4[3], g_pperfAppEntries[lIndex].guidInternalInstance.Data4[4], 
		         g_pperfAppEntries[lIndex].guidInternalInstance.Data4[5], g_pperfAppEntries[lIndex].guidInternalInstance.Data4[6], 
	             g_pperfAppEntries[lIndex].guidInternalInstance.Data4[7] );
	}

	// Create file mapping for memory block
	pperfApplicationInfo->hFileMap = CreateFileMappingA(INVALID_HANDLE_VALUE,
													DNGetNullDacl(),
													PAGE_READWRITE,
													0,
													pperfApplication->dwMemoryBlockSize,
													szNameBuffer);
	if (pperfApplicationInfo->hFileMap == NULL)
	{
		hr = GetLastError();	    
		DPFX(DPFPREP,  0, "CreateFileMapping() failed hr=0x%x", hr);
		goto EXIT_ERROR;
	}
    	
	// Create the shared memory block
    pperfApplicationInfo->pbMemoryBlock = reinterpret_cast<BYTE*>(MapViewOfFile(pperfApplicationInfo->hFileMap,FILE_MAP_ALL_ACCESS,0,0,0));
	
	if (pperfApplicationInfo->pbMemoryBlock == NULL)
	{
	    hr = GetLastError();
		DPFX(DPFPREP, 0,"MapViewOfFile() failed hr=0x%x", hr);
		goto EXIT_ERROR;
	}	

	strcat( szNameBuffer, "_M" );

	// Create mutex to protect the mutex.
	pperfApplicationInfo->hMutex = CreateMutexA( DNGetNullDacl(), FALSE, szNameBuffer );

	if( !pperfApplicationInfo->hMutex )
	{
		hr = GetLastError();
		DPFX(DPFPREP, 0,"MapViewOfFile() failed hr=0x%x", hr);
		goto EXIT_ERROR;
	}

	// Copy all the settings back to the app specified structure
	memcpy( pperfApplication, &g_pperfAppEntries[lIndex], sizeof( PERF_APPLICATION ) );

	(*g_plNumEntries)++;
	
    ReleaseMutex( g_hMutexInstanceBlock );

	return S_OK;
	
EXIT_ERROR:
	
	PERF_CleanupEntry( &g_pperfAppEntries[lIndex], pperfApplicationInfo );		
    ReleaseMutex( g_hMutexInstanceBlock );		
    return hr;			
}

#undef DPF_MODNAME
#define DPF_MODNAME "PERF_RemoveEntry"
// PERF_RemoveENtry
//
// When an entity no longer requires the statistics block they MUST call this function to free up the 
// resources and to allow their slot in the central memory block to be used by other applications.
//
void PERF_RemoveEntry( GUID &guidInternalInstance, PPERF_APPLICATION_INFO pperfApplicationInfo  )
{
    if( !g_pbInstanceBlock )
        return;

    HRESULT hr = S_OK;

    DPFX(DPFPREP,  DVF_INFOLEVEL, "PERF: Shutting down perf info" );

    // We need the mutex to access the block
    WaitForSingleObject( g_hMutexInstanceBlock, INFINITE );

    DPFX(DPFPREP,  DVF_INFOLEVEL, "PERF: Removing dead entries" );    

    // Remove dead entries
    PERF_Coalesce();
    
    for( LONG lIndex = 0; lIndex < PERF_INSTANCE_BLOCK_MAXENTRIES; lIndex++ )
    {
        // We've found the entry, mark it as empty
        if( g_pperfAppEntries[lIndex].guidInternalInstance == guidInternalInstance )
        {
		    DPFX(DPFPREP,  DVF_INFOLEVEL, "PERF: Removing our entry" );            	
            PERF_CleanupEntry( &g_pperfAppEntries[lIndex], pperfApplicationInfo );
			break;
        }
    }

    ReleaseMutex( g_hMutexInstanceBlock );

    DPFX(DPFPREP,  DVF_INFOLEVEL, "PERF: Exiting" );            	    
    
}

#undef DPF_MODNAME
#define DPF_MODNAME "PERF_DeInitialize"
// PERF_DeInitialize
//
// Free up the global memory map.  Must be called when process exits to cleanup
// 
void PERF_DeInitialize()
{
    if( g_hMutexInstanceBlock )
    {
        // We need the mutex to access the block
        WaitForSingleObject( g_hMutexInstanceBlock, INFINITE );
        PERF_Coalesce( GetCurrentProcessId() );
        ReleaseMutex( g_hMutexInstanceBlock );
       
        CloseHandle( g_hMutexInstanceBlock );
        g_hMutexInstanceBlock = NULL;
    }
        
    if( g_pbInstanceBlock )
    {
		UnmapViewOfFile(g_pbInstanceBlock);        
        g_pbInstanceBlock = NULL;
    }

    if( g_hFileInstanceBlock )
    {
        CloseHandle( g_hFileInstanceBlock );
        g_hFileInstanceBlock = NULL;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "PERF_DumpTable"
// PERF_DumpTable
//
// Helper function that calls the specified callback function once for each entry in the central performance
// table. 
void PERF_DumpTable( BOOL fGrabMutex, PVOID pvContext, PFNDUMPPERFTABLE pperfAppEntry )
{
	BOOL fSelfInitialized = FALSE;
	HANDLE hMapInstance = NULL;
    char szNameBuffer[PERF_INFO_NAME_LENGTH];	
    PBYTE pbDataBlob = NULL;
	
	if( !g_pbInstanceBlock )
	{
		PERF_Initialize();
		fSelfInitialized = TRUE;
	}

    if( fGrabMutex )
		WaitForSingleObject( g_hMutexInstanceBlock, INFINITE );

    for( LONG lIndex = 0; lIndex < PERF_INSTANCE_BLOCK_MAXENTRIES; lIndex++ )
    {
		// Build name for shared memory block
		if (DNGetOSType() == VER_PLATFORM_WIN32_NT)
		{
		    wsprintfA( szNameBuffer, "Global\\{%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}",
		    	     g_pperfAppEntries[lIndex].guidInternalInstance.Data1, g_pperfAppEntries[lIndex].guidInternalInstance.Data2, 
		    	     g_pperfAppEntries[lIndex].guidInternalInstance.Data3, g_pperfAppEntries[lIndex].guidInternalInstance.Data4[0], 
			         g_pperfAppEntries[lIndex].guidInternalInstance.Data4[1], g_pperfAppEntries[lIndex].guidInternalInstance.Data4[2], 
			         g_pperfAppEntries[lIndex].guidInternalInstance.Data4[3], g_pperfAppEntries[lIndex].guidInternalInstance.Data4[4], 
			         g_pperfAppEntries[lIndex].guidInternalInstance.Data4[5], g_pperfAppEntries[lIndex].guidInternalInstance.Data4[6], 
		             g_pperfAppEntries[lIndex].guidInternalInstance.Data4[7] );
		}
		else
		{
		    wsprintfA( szNameBuffer, "{%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}",
		    	     g_pperfAppEntries[lIndex].guidInternalInstance.Data1, g_pperfAppEntries[lIndex].guidInternalInstance.Data2, 
		    	     g_pperfAppEntries[lIndex].guidInternalInstance.Data3, g_pperfAppEntries[lIndex].guidInternalInstance.Data4[0], 
			         g_pperfAppEntries[lIndex].guidInternalInstance.Data4[1], g_pperfAppEntries[lIndex].guidInternalInstance.Data4[2], 
			         g_pperfAppEntries[lIndex].guidInternalInstance.Data4[3], g_pperfAppEntries[lIndex].guidInternalInstance.Data4[4], 
			         g_pperfAppEntries[lIndex].guidInternalInstance.Data4[5], g_pperfAppEntries[lIndex].guidInternalInstance.Data4[6], 
		             g_pperfAppEntries[lIndex].guidInternalInstance.Data4[7] );
		}

		// Create file mapping for memory block
		hMapInstance = OpenFileMappingA(PAGE_READWRITE,FALSE,szNameBuffer);

		if( hMapInstance )
		{
		    pbDataBlob = reinterpret_cast<BYTE*>(MapViewOfFile(hMapInstance,FILE_MAP_READ,0,0,0));

			HRESULT hr = GetLastError();
		}
    	
        if( FAILED( (*pperfAppEntry)( pvContext, &g_pperfAppEntries[lIndex], pbDataBlob ) ) )
        	break;

        if( pbDataBlob )
        {
        	UnmapViewOfFile( pbDataBlob );
        	pbDataBlob = NULL;
        }

        if( hMapInstance )
        {
        	CloseHandle( hMapInstance );
        	hMapInstance = NULL;
        }

    }    

	if( fGrabMutex )
	    ReleaseMutex( g_hMutexInstanceBlock );
    

	if( fSelfInitialized )
		PERF_DeInitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\readwritelock.h ===
// ReadWriteLock.h: interface for the CReadWriteLock class.
//
//////////////////////////////////////////////////////////////////////

#pragma once

class CReadWriteLock  
{
public:
	CReadWriteLock();
	~CReadWriteLock();

	BOOL Init();

	void EnterWriteLock();
	void EnterReadLock();

	void LeaveLock();

private:
	int		m_nWriterWaitingCount;
	int		m_nReaderWaitingCount;
	int		m_nActiveCount;
	HANDLE	m_hWriteSem;
	HANDLE	m_hReadSem;
	BOOL	m_fCritSecInited;
	DNCRITICAL_SECTION m_csWrite;

	DEBUG_ONLY(DWORD	m_dwWriteThread);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\perfmacs.h ===
/*==========================================================================
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       PerfMacs.h
 *  Content:	Performance Instrumentation macros.
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	03/21/01	RichGr	Created
 *
 *  Usage:  
 *    As Whistler/XP and DX 8.1 are now locked down for beta 2, this should
 *  not be included as part of the official builds.  So just include this file
 *  temporarily when you need to instrument some functions.
 *    Specify these macros before and after what you want to time:
 START_QPC
  DoSomeWork
 END_QPC

 *    Then temporarily change dndbg.cpp by replacing
this:
 #include "dndbg.h"
 #include "memlog.h"

 #if defined(DEBUG)


with this:
 #if defined(DPINST) && !defined(DEBUG)
   #define DEBUG
   #include "dndbg.h"
   #include "memlog.h"
   #undef DEBUG
 #else
   #include "dndbg.h"
   #include "memlog.h"
 #endif

 #if defined(DEBUG) || defined(DPINST)

 *    To build the instrumented binaries, set C_DEFINES=-DDPINST in your razzle build 
 *  environment.  Both free and checked builds can be instrumented.  If you want to
 *  put the bins in a different directory, set BUILD_ALT_DIR=i where 'i' is the character
 *  you want to append to \obj. 
 *
 *    To get useful results, you will usually need to use the shared memory
 *  log option (log=2 in win.ini) and run free binaries.  If you run the checked
 *  binaries, you should keep the amount of debug output low.
 *
 *
 ***************************************************************************/


#ifndef __PERFMACS_H__
#define __PERFMACS_H__

#ifdef DEBUG
#define DPINST
#endif

#ifdef DPINST
#pragma message("DPINST is defined and binaries are instrumented")

#define DPINST_CRITSEC  FALSE        // Specify TRUE or FALSE

#ifdef __cplusplus
	extern "C" {
#endif	

//**********************************************************************
// Constant definitions
//**********************************************************************

// #undef and #define this again before the code you're timing
// if you want to change the logging threshold.
#define QPC_THRESHOLD  10   // 10 usecs


//**********************************************************************
// Macro definitions
//**********************************************************************

// To provide local scope for n64QPCStart and n64QPCEnd, QPC_START has
// an unbalanced open { and QPC_END has the balancing close }.
#define START_QPC \
    { \
        __int64  n64QPCStart, n64QPCEnd, n64QPCDiff; \
        if (g_bQPC_Not_Inited) \
        { \
            QueryPerformanceFrequency((LARGE_INTEGER*)&g_n64QPCFrequency); \
            g_bQPC_Not_Inited = FALSE; \
        } \
        QueryPerformanceCounter((LARGE_INTEGER*)&n64QPCStart); 

// a) We can handle wraps.
// b) Below a certain threshold, we don't want to log the elapsed time.
// c) We don't compensate for thread switches.
#define END_QPC \
        QueryPerformanceCounter((LARGE_INTEGER*)&n64QPCEnd); \
        if (n64QPCEnd >= n64QPCStart) \
            n64QPCDiff = n64QPCEnd - n64QPCStart; \
        else \
            n64QPCDiff = (0x7fffffffffffffff - n64QPCStart) + 1 + n64QPCEnd; \
        n64QPCDiff = n64QPCDiff * 1000000 / g_n64QPCFrequency; \
        if (n64QPCDiff < 0) \
            n64QPCDiff = 0; \
        if (n64QPCDiff >= QPC_THRESHOLD) \
            DebugPrintfX(__FILE__, __LINE__, DPF_MODNAME, DPF_SUBCOMP, DPF_ERRORLEVEL, "%d usecs", (DWORD)n64QPCDiff); \
    } 
     

//**********************************************************************
// Redefinitions of existing macros
//**********************************************************************
#if DPINST_CRITSEC == TRUE
#undef  DNEnterCriticalSection

#define	DNEnterCriticalSection( arg )	DNTimeEnterCriticalSection( arg )
#endif


//**********************************************************************
// Global Variable definitions
//**********************************************************************

static __int64     g_n64QPCFrequency = 0;
static BOOL        g_bQPC_Not_Inited = TRUE;
 

//**********************************************************************
// Function Prototypes
//**********************************************************************

void DebugPrintfX(LPCSTR szFile, DWORD dwLineNumber,LPCSTR szFnName, DWORD dwSubComp, volatile DWORD_PTR dwDetail, ...);


#ifdef __cplusplus
	}	//extern "C"
#endif

#else   // NULL definition

#define START_QPC
#define END_QPC

#endif  //#ifdef DPINST

#endif	// __PERFMACS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\readwritelock.cpp ===
// ReadWriteLock.cpp: implementation of the CReadWriteLock class.
//
//////////////////////////////////////////////////////////////////////

#include "dncmni.h"


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

#undef DPF_MODNAME
#define DPF_MODNAME "CReadWriteLock::CReadWriteLock"

CReadWriteLock::CReadWriteLock() :
	m_hReadSem(0),
	m_hWriteSem(0),
	m_nReaderWaitingCount(0),
	m_nWriterWaitingCount(0),
	m_nActiveCount(0),
	m_fCritSecInited(FALSE)

#ifdef DEBUG
	,m_dwWriteThread(0)
#endif
{
	DPF_ENTER();
	DPF_EXIT();
}

#undef DPF_MODNAME
#define DPF_MODNAME "CReadWriteLock::~CReadWriteLock"

CReadWriteLock::~CReadWriteLock()
{
	DPF_ENTER();

	DNASSERT(m_nActiveCount == 0);

	if (m_fCritSecInited)
	{
		DNDeleteCriticalSection(&m_csWrite);
	}
	if (m_hReadSem)
	{
		CloseHandle(m_hReadSem);
	}
	if (m_hWriteSem)
	{
		CloseHandle(m_hWriteSem);
	}

	DPF_EXIT();
}

#undef DPF_MODNAME
#define DPF_MODNAME "CReadWriteLock::Init"

BOOL CReadWriteLock::Init()
{
	DPF_ENTER();

	// Core will attempt to initialize us multiple times, just take the first
	if (!m_fCritSecInited)
	{
		m_hReadSem = CreateSemaphore(0,0,MAXLONG,0);
		if (!m_hReadSem)
		{
			goto error;
		}

		m_hWriteSem = CreateSemaphore(0,0,MAXLONG,0);
		if (!m_hWriteSem)
		{
			goto error;
		}

		if (!DNInitializeCriticalSection(&m_csWrite))
		{
			goto error;
		}
		m_fCritSecInited = TRUE;
	}

	DPF_EXIT();

	return TRUE;

error:
	if (m_hReadSem)
	{
		CloseHandle(m_hReadSem);
		m_hReadSem = 0;
	}
	if (m_hWriteSem)
	{
		CloseHandle(m_hWriteSem);
		m_hWriteSem = 0;
	}

	DPF_EXIT();

	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CReadWriteLock::EnterReadLock"

void CReadWriteLock::EnterReadLock()
{
	DPF_ENTER();

	DNASSERT(m_fCritSecInited);

	DNEnterCriticalSection(&m_csWrite);

	// If there is a Writer writing or waiting to write, they have priority
	BOOL fWaitOnWriters = (m_nWriterWaitingCount || (m_nActiveCount < 0));

	if (fWaitOnWriters)
	{
		m_nReaderWaitingCount++;
	}
	else
	{
		m_nActiveCount++;
	}
	DNLeaveCriticalSection(&m_csWrite);

	if (fWaitOnWriters)
	{
		WaitForSingleObject(m_hReadSem, INFINITE);
	}

	DPF_EXIT();
}

#undef DPF_MODNAME
#define DPF_MODNAME "CReadWriteLock::LeaveLock"

void CReadWriteLock::LeaveLock()
{
	DPF_ENTER();

	DNASSERT(m_fCritSecInited);

	DNEnterCriticalSection(&m_csWrite);
	if (m_nActiveCount > 0)
	{
		m_nActiveCount--;
	}
	else
	{
		DEBUG_ONLY(m_dwWriteThread = 0);
		m_nActiveCount++;
	}

	HANDLE hSem = 0;
	LONG lCount = 1;

	if (m_nActiveCount == 0)
	{
		if (m_nWriterWaitingCount > 0)
		{
			m_nActiveCount = -1;
			m_nWriterWaitingCount--;
			hSem = m_hWriteSem;
		}
		else if (m_nReaderWaitingCount > 0)
		{
			m_nActiveCount = m_nReaderWaitingCount;
			m_nReaderWaitingCount = 0;
			hSem = m_hReadSem;
			lCount = m_nActiveCount;
		}
	}

	DNLeaveCriticalSection(&m_csWrite);

	if (hSem)
	{
		ReleaseSemaphore(hSem, lCount, 0);
	}

	DPF_EXIT();
}

#undef DPF_MODNAME
#define DPF_MODNAME "CReadWriteLock::EnterWriteLock"

void CReadWriteLock::EnterWriteLock()
{
	DPF_ENTER();

	DNASSERT(m_fCritSecInited);

	DNEnterCriticalSection(&m_csWrite);

	BOOL fAvailable = (m_nActiveCount == 0);

	if (fAvailable)
	{
		m_nActiveCount = -1;
	}
	else
	{
		DNASSERT(m_dwWriteThread != GetCurrentThreadId()); // No re-entrance!
		m_nWriterWaitingCount++;
	}

	DNLeaveCriticalSection(&m_csWrite);

	if (!fAvailable)
	{
		WaitForSingleObject(m_hWriteSem, INFINITE);
	}
	DEBUG_ONLY(m_dwWriteThread = GetCurrentThreadId());

	DPF_EXIT();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\rcbuffer.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       RCBuff.h
 *  Content:	RefCount Buffers
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/12/00	mjn		Created
 *	01/15/00	mjn		Added GetBufferAddress and GetBufferSize
 *	01/31/00	mjn		Allow user defined Alloc and Free
 ***************************************************************************/

#ifndef __RCBUFF_H__
#define __RCBUFF_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef PVOID (*PFNALLOC_REFCOUNT_BUFFER)(void *const,const DWORD);
typedef void (*PFNFREE_REFCOUNT_BUFFER)(void *const,void *const);
template< class CRefCountBuffer > class CLockedContextClassFixedPool;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

PVOID RefCountBufferDefaultAlloc(void *const pv,const DWORD dwSize);
void RefCountBufferDefaultFree(void *const pv,void *const pvBuffer);

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for RefCount buffer

class CRefCountBuffer
{
public:
	CRefCountBuffer() { };		// Constructor

	~CRefCountBuffer() { };		// Destructor

	#undef DPF_MODNAME
	#define DPF_MODNAME "FPMAlloc"
	BOOL FPMAlloc( void *const pvContext )
		{
			m_pvContext = pvContext;

			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "FPMInitialize"
	BOOL FPMInitialize( void *const pvContext )
		{
//			DNASSERT(pvContext == m_pvContext);

			m_lRefCount = 1;
			m_pvContext = pvContext;
			m_dnBufferDesc.dwBufferSize = 0;
			m_dnBufferDesc.pBufferData = NULL;

			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "FPMRelease"
	void FPMRelease( void *const pvContext ) { };

	#undef DPF_MODNAME
	#define DPF_MODNAME "FPMDealloc"
	void FPMDealloc( void *const pvContext ) { };

	HRESULT Initialize(	CLockedContextClassFixedPool <CRefCountBuffer> *pFPRefCountBuffer,
						PFNALLOC_REFCOUNT_BUFFER pfnAlloc,
						PFNFREE_REFCOUNT_BUFFER pfnFree,
						void *const pvContext,
						const DWORD dwBufferSize);

	#undef DPF_MODNAME
	#define DPF_MODNAME "ReturnSelfToPool"
	void ReturnSelfToPool()
		{
			DNASSERT(m_lRefCount == 0);
			m_pFPOOLRefCountBuffer->Release( this );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "AddRef"
	void AddRef()
		{
			DNASSERT(m_lRefCount >= 0);
			InterlockedIncrement( &m_lRefCount );
		};

	void Release();

	#undef DPF_MODNAME
	#define DPF_MODNAME "SetBufferDesc"
	HRESULT SetBufferDesc(	BYTE *const pBufferData,
							const DWORD dwBufferSize,
							PFNFREE_REFCOUNT_BUFFER pfnFree,
							void *const pvContext)
		{
			DNASSERT(m_lRefCount > 0);

			if (m_dnBufferDesc.dwBufferSize || m_dnBufferDesc.pBufferData)
				return(DPNERR_INVALIDPARAM);

			m_dnBufferDesc.dwBufferSize = dwBufferSize;
			m_dnBufferDesc.pBufferData = pBufferData;
			m_pfnFree = pfnFree;
			m_pvContext = pvContext;

			return(DPN_OK);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "BufferDescAddress"
	DPN_BUFFER_DESC *BufferDescAddress()
		{
			return(&m_dnBufferDesc);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "GetBufferAddress"
	BYTE *GetBufferAddress()
		{
			return(m_dnBufferDesc.pBufferData);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "GetBufferSize"
	DWORD GetBufferSize()
		{
			return(m_dnBufferDesc.dwBufferSize);
		};


private:
	LONG						m_lRefCount;
	DPN_BUFFER_DESC				m_dnBufferDesc;		// Buffer
	CLockedContextClassFixedPool< CRefCountBuffer >	*m_pFPOOLRefCountBuffer;	// source FP of RefCountBuffers
	PFNFREE_REFCOUNT_BUFFER		m_pfnFree;			// Function to free buffer when released
	PFNALLOC_REFCOUNT_BUFFER	m_pfnAlloc;
	PVOID						m_pvContext;	// Context provided to free buffer call
};

#undef DPF_SUBCOMP
#undef DPF_MODNAME

#endif	// __RCBUFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\strutils.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       StrUtils.cpp
 *  Content:    Implements the string utils
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   02/12/2000	rmt		Created
 *   08/28/2000	masonb	Voice Merge: Added check of return code of MultiByteToWideChar in STR_jkAnsiToWide
 *   09/16/2000 aarono  fix STR_AllocAndConvertToANSI, ANSI doesn't mean 1 byte per DBCS character so we
 *                       must allow up to 2 bytes per char when allocating buffer (B#43286)
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncmni.h"


#undef DPF_MODNAME
#define DPF_MODNAME "STR_WideToAnsi"

//**********************************************************************
// ------------------------------
// WideToANSI - convert a wide string to an ANSI string
//
// Entry:		Pointer to source wide string
//				Size of source string (in WCHAR units, -1 implies NULL-terminated)
//				Pointer to ANSI string destination
//				Pointer to size of ANSI destination
//
// Exit:		Error code:
//				DPNERR_GENERIC = operation failed
//				DPN_OK = operation succeded
//				DPNERR_BUFFERTOOSMALL = destination buffer too small
// ------------------------------
HRESULT	STR_WideToAnsi( const WCHAR *const pWCHARString,
						const DWORD dwWCHARStringLength,
						char *const pString,
						DWORD *const pdwStringLength )
{
	HRESULT	hr;
	int		iReturn;
	BOOL	fDefault;
	char	cMilleniumHackBuffer;	
	char	*pMilleniumHackBuffer;


	DNASSERT( pWCHARString != NULL );
	DNASSERT( pdwStringLength != NULL );
	DNASSERT( ( pString != NULL ) || ( *pdwStringLength == 0 ) );

	//
	// Initialize.  A hack needs to be implemented for WinME parameter
	// validation, because when you pass zero for a destination size, you
	// MUST have a valid pointer.  Works on Win95, 98, NT4, Win2K, etc.....
	//
	hr = DPN_OK;

	if ( *pdwStringLength == 0 )
	{
		pMilleniumHackBuffer = &cMilleniumHackBuffer;
	}
	else
	{
		pMilleniumHackBuffer = pString;
	}

	fDefault = FALSE;
	iReturn = WideCharToMultiByte( CP_ACP,					// code page (default ANSI)
								   0,						// flags (none)
								   pWCHARString,			// pointer to WCHAR string
								   dwWCHARStringLength,		// size of WCHAR string
								   pMilleniumHackBuffer,	// pointer to destination ANSI string
								   *pdwStringLength,		// size of destination string
								   NULL,					// pointer to default for unmappable characters (none)
								   &fDefault				// pointer to flag indicating that default was used
								   );
	if ( iReturn == 0 )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX( DPFPREP, 0, "Failed to convert WCHAR to multi-byte!" );
		DisplayDNError( 0, dwError );
		hr = DPNERR_GENERIC;
	}
	else
	{
		if ( *pdwStringLength == 0 )
		{
			hr = DPNERR_BUFFERTOOSMALL;
		}
		else
		{
			DNASSERT( hr == DPN_OK );
		}

		*pdwStringLength = iReturn;
	}

	//
	// if you hit this ASSERT it's because you've probably got ASCII text as your
	// input WCHAR string.  Double-check your input!!
	//
	DNASSERT( fDefault == FALSE );

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// ANSIToWide - convert an ANSI string to a wide string
//
// Entry:		Pointer to source multi-byte (ANSI) string
//				Size of source string (-1 imples NULL-terminated)
//				Pointer to multi-byte string destination
//				Pointer to size of multi-byte destination (in WCHAR units)
//
// Exit:		Error code:
//				DPNERR_GENERIC = operation failed
//				DPN_OK = operation succeded
//				DPNERR_BUFFERTOOSMALL = destination buffer too small
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "STR_AnsiToWide"
HRESULT	STR_AnsiToWide( const char *const pString,
						const DWORD dwStringLength,
						WCHAR *const pWCHARString,
						DWORD *const pdwWCHARStringLength )
{
	HRESULT	hr;
	int		iReturn;
	WCHAR	MilleniumHackBuffer;
	WCHAR	*pMilleniumHackBuffer;


	DNASSERT( pString != NULL );
	DNASSERT( pdwWCHARStringLength != NULL );
	DNASSERT( ( pWCHARString != NULL ) || ( *pdwWCHARStringLength == 0 ) );

	//
	// Initialize.  A hack needs to be implemented for WinME parameter
	// validation, because when you pass zero for a destination size, you
	// MUST have a valid pointer.  Works on Win95, 98, NT4, Win2K, etc.....
	//
	hr = DPN_OK;

	if ( *pdwWCHARStringLength == 0 )
	{
		pMilleniumHackBuffer = &MilleniumHackBuffer;
	}
	else
	{
		pMilleniumHackBuffer = pWCHARString;
	}
	
	iReturn = MultiByteToWideChar( CP_ACP,					// code page (default ANSI)
								   0,						// flags (none)
								   pString,					// pointer to multi-byte string			
								   dwStringLength,			// size of string (assume null-terminated)
								   pMilleniumHackBuffer,	// pointer to destination wide-char string
								   *pdwWCHARStringLength	// size of destination in WCHARs
								   );
	if ( iReturn == 0 )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Failed to convert multi-byte to WCHAR!" );
		DisplayDNError( 0, dwError );
		hr = DPNERR_GENERIC;
	}
	else
	{
		if ( *pdwWCHARStringLength == 0 )
		{
			hr = DPNERR_BUFFERTOOSMALL;
		}
		else
		{
			DNASSERT( hr == DPN_OK );
		}

		*pdwWCHARStringLength = iReturn;
	}

	return	hr;
}
//**********************************************************************



/*
 ** WideToAnsi
 *
 *  CALLED BY:	everywhere
 *
 *  PARAMETERS: lpStr - destination string
 *				lpWStr - string to convert
 *				cchStr - size of dest buffer
 *
 *  DESCRIPTION:
 *				converts unicode lpWStr to ansi lpStr.
 *				fills in unconvertable chars w/ DPLAY_DEFAULT_CHAR "-"
 *				
 *
 *  RETURNS:  if cchStr is 0, returns the size required to hold the string
 *				otherwise, returns the number of chars converted
 *
 */
#undef DPF_MODNAME
#define DPF_MODNAME "STR_jkWideToAnsi"
HRESULT STR_jkWideToAnsi(LPSTR lpStr,LPCWSTR lpWStr,int cchStr)
{
	int rval;
	BOOL bDefault = FALSE;

	if (!lpWStr && cchStr)
	{
		// can't call us w/ null pointer & non-zero cch
		DNASSERT(FALSE);
		return DPNERR_INVALIDPARAM;
	}
	
	// use the default code page (CP_ACP)
	// -1 indicates WStr must be null terminated
	rval = WideCharToMultiByte(CP_ACP,0,lpWStr,-1,lpStr,cchStr,
			NULL,&bDefault);

	if (bDefault)
	{
		DPFX(DPFPREP,3,"!!! WARNING - used default string in WideToAnsi conversion.!!!");
		DPFX(DPFPREP,3,"!!! Possible bad unicode string - (you're not hiding ansi in there are you?) !!! ");
		return DPNERR_CONVERSION;
	}
	
	return DPN_OK;

} // WideToAnsi


//	WideToAnsi
//
//	Convert a WCHAR (Wide) string to a CHAR (ANSI) string
//
//	CHAR	*pStr		CHAR string
//	WCHAR	*pWStr		WCHAR string
//	int		iStrSize	size (in bytes) of buffer pointed to by lpStr
#undef DPF_MODNAME
#define DPF_MODNAME "STR_AllocAndConvertToANSI"
/*
 ** GetAnsiString
 *
 *  CALLED BY: Everywhere
 *
 *  PARAMETERS: *ppszAnsi - pointer to string
 *				lpszWide - string to copy
 *
 *  DESCRIPTION:	  handy utility function
 *				allocs space for and converts lpszWide to ansi
 *
 *  RETURNS: string length
 *
 */
HRESULT STR_AllocAndConvertToANSI(LPSTR * ppszAnsi,LPCWSTR lpszWide)
{
	int iStrLen;
	BOOL bDefault;
	
	DNASSERT(ppszAnsi);

	if (!lpszWide)
	{
		*ppszAnsi = NULL;
		return S_OK;
	}

	*ppszAnsi = new char[wcslen(lpszWide)*2+1];
	if (!*ppszAnsi)	
	{
		DPFX(DPFPREP,0, "could not get ansi string -- out of memory");
		return E_OUTOFMEMORY;
	}

	iStrLen = WideCharToMultiByte(CP_ACP,0,lpszWide,-1,*ppszAnsi,wcslen(lpszWide)*2+1,
			NULL,&bDefault);

	return DPN_OK;
} // OSAL_AllocAndConvertToANSI


#undef DPF_MODNAME
#define DPF_MODNAME "STR_jkAnsiToWide"
/*
 ** AnsiToWide
 *
 *  CALLED BY: everywhere
 *
 *  PARAMETERS: lpWStr - dest string
 *				lpStr  - string to convert
 *				cchWstr - size of dest buffer
 *
 *  DESCRIPTION: converts Ansi lpStr to Unicode lpWstr
 *
 *
 *  RETURNS:  if cchStr is 0, returns the size required to hold the string
 *				otherwise, returns the number of chars converted
 *
 */
HRESULT STR_jkAnsiToWide(LPWSTR lpWStr,LPCSTR lpStr,int cchWStr)
{
	int rval;

	if (!lpStr && cchWStr)
	{
		// can't call us w/ null pointer & non-zero cch
		DNASSERT(FALSE);
		return DPNERR_INVALIDPOINTER;
	}

	rval =  MultiByteToWideChar(CP_ACP,0,lpStr,-1,lpWStr,cchWStr);
	if (!rval)
	{
		DPFX(DPFPREP,0,"MultiByteToWideChar failed in STR_jkAnsiToWide");
		return DPNERR_GENERIC;
	}
	else
	{
		return DPN_OK;
	}
}  // AnsiToWide
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\threadlocalptrs.h ===
/*==========================================================================
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       threadlocalptrs.h
 *  Content:	Thread local pointer macros
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	03/21/2001	vanceo	Created.
 ***************************************************************************/

#ifndef __THREADLOCALPTRS_H__
#define __THREADLOCALPTRS_H__




//**********************************************************************
// Structure definitions
//**********************************************************************

typedef struct _THREADLOCAL_HEADER	THREADLOCAL_HEADER, * PTHREADLOCAL_HEADER;

struct _THREADLOCAL_HEADER
{
	PTHREADLOCAL_HEADER		pNext;		// pointer to next allocated threadlocal structure header
	PTHREADLOCAL_HEADER		pPrev;		// pointer to previous allocated threadlocal structure header
	DWORD					dwThreadID;	// ID of thread that owns this header
	
	//
	// The actual thread local pointer structure follows this.
	//
};





//**********************************************************************
// Macro definitions
//**********************************************************************

//
// Global thread local pointer declarations.
//

#define DECLARE_THREADLOCALPTRS(pointers)	extern DWORD				g_dw##pointers##TlsIndex;\
											extern DNCRITICAL_SECTION	g_csAllocated##pointers;\
											extern PTHREADLOCAL_HEADER	g_pAllocated##pointers;\
											\
											struct pointers





//
// Thread local pointer storage, define in only one location.
//
#define IMPL_THREADLOCALPTRS(pointers)		DWORD					g_dw##pointers##TlsIndex = -1;\
											DNCRITICAL_SECTION		g_csAllocated##pointers;\
											PTHREADLOCAL_HEADER		g_pAllocated##pointers = NULL




//
// Thread local pointer initialization, call only once (DLL_PROCESS_ATTACH),
// returns TRUE if successful, FALSE otherwise.
//
#define INIT_THREADLOCALPTRS(pointers)								g_pAllocated##pointers = NULL, g_dw##pointers##TlsIndex = TlsAlloc(), ((g_dw##pointers##TlsIndex != -1) ? DNInitializeCriticalSection(&g_csAllocated##pointers) : FALSE)


//
// Total thread local pointer cleanup, call only once (DLL_PROCESS_DETACH).
//
#define DEINIT_THREADLOCALPTRS(pointers, pfnCleanup)				{\
																		PTHREADLOCAL_HEADER		pNext;\
																		\
																		\
																		if (g_dw##pointers##TlsIndex != -1)\
																		{\
																			DNDeleteCriticalSection(&g_csAllocated##pointers);\
																			\
																			TlsFree(g_dw##pointers##TlsIndex);\
																			g_dw##pointers##TlsIndex = -1;\
																		}\
																		\
																		while (g_pAllocated##pointers != NULL)\
																		{\
																			pNext = g_pAllocated##pointers->pNext;\
																			pfnCleanup((pointers *) (g_pAllocated##pointers + 1), g_pAllocated##pointers->dwThreadID);\
																			DNFree(g_pAllocated##pointers);\
																			g_pAllocated##pointers = pNext;\
																		}\
																	}


//
// Cleanup only current thread's local pointers (DLL_THREAD_DETACH).
//
#define RELEASE_CURRENTTHREAD_LOCALPTRS(pointers, pfnCleanup)		{\
																		PTHREADLOCAL_HEADER		pHeader;\
																		PTHREADLOCAL_HEADER		pNext;\
																		\
																		\
																		pHeader = (PTHREADLOCAL_HEADER) TlsGetValue(g_dw##pointers##TlsIndex);\
																		if (pHeader != NULL)\
																		{\
																			DNEnterCriticalSection(&g_csAllocated##pointers);\
																			\
																			pNext = pHeader->pNext;\
																			if (pHeader->pPrev != NULL)\
																			{\
																				pHeader->pPrev->pNext = pNext;\
																			}\
																			if (pNext != NULL)\
																			{\
																				pNext->pPrev = pHeader->pPrev;\
																			}\
																			\
																			if (pHeader == g_pAllocated##pointers)\
																			{\
																				g_pAllocated##pointers = pNext;\
																			}\
																			\
																			DNLeaveCriticalSection(&g_csAllocated##pointers);\
																			\
																			DNASSERT(pHeader->dwThreadID == GetCurrentThreadId());\
																			pfnCleanup((pointers *) (pHeader + 1), pHeader->dwThreadID);\
																			DNFree(pHeader);\
																		}\
																	}

//
// Thread local pointer retrieval function.
//
#define GET_THREADLOCALPTR(pointers, name, pptr)			{\
																PTHREADLOCAL_HEADER		pHeader;\
																\
																\
																pHeader = (PTHREADLOCAL_HEADER) TlsGetValue(g_dw##pointers##TlsIndex);\
																if (pHeader == NULL)\
																{\
																	DPFX(DPFPREP, 9, "No header for " #name ".");\
																	(*pptr) = NULL;\
																}\
																else\
																{\
																	DPFX(DPFPREP, 9, "Found header 0x%p, returning " #name " 0x%p.", pHeader, ((pointers *) (pHeader + 1))->name);\
																	(*pptr) = ((pointers *) (pHeader + 1))->name;\
																}\
															}

//
// Thread local pointer storage function.
//
#define SET_THREADLOCALPTR(pointers, name, ptr, pfResult)	{\
																PTHREADLOCAL_HEADER		pHeader;\
																\
																\
																pHeader = (PTHREADLOCAL_HEADER) TlsGetValue(g_dw##pointers##TlsIndex);\
																if (pHeader == NULL)\
																{\
																	pHeader = (PTHREADLOCAL_HEADER) DNMalloc(sizeof(THREADLOCAL_HEADER) + sizeof(pointers));\
																	if (pHeader == NULL)\
																	{\
																		(*pfResult) = FALSE;\
																	}\
																	else\
																	{\
																		memset(pHeader, 0, (sizeof(THREADLOCAL_HEADER) + sizeof(pointers)));\
																		pHeader->dwThreadID = GetCurrentThreadId();\
																		((pointers *) (pHeader + 1))->name = ptr;\
																		\
																		if (! TlsSetValue(g_dw##pointers##TlsIndex, pHeader))\
																		{\
																			DPFX(DPFPREP, 9, "Couldn't set thread local storage 0x%p!", pHeader);\
																			DNFree(pHeader);\
																			(*pfResult) = FALSE;\
																		}\
																		else\
																		{\
																			DPFX(DPFPREP, 9, "Setting 0x%p " #name " to 0x%p (create).", pHeader, ptr);\
																			\
																			DNEnterCriticalSection(&g_csAllocated##pointers);\
																			pHeader->pNext = g_pAllocated##pointers;\
																			if (g_pAllocated##pointers != NULL)\
																			{\
																				DNASSERT(g_pAllocated##pointers##->pPrev == NULL);\
																				g_pAllocated##pointers##->pPrev = pHeader;\
																			}\
																			g_pAllocated##pointers = pHeader;\
																			DNLeaveCriticalSection(&g_csAllocated##pointers);\
																			\
																			(*pfResult) = TRUE;\
																		}\
																	}\
																}\
																else\
																{\
																	DPFX(DPFPREP, 9, "Setting 0x%p " #name " to 0x%p (existing).", pHeader, ptr);\
																	DNASSERT(((pointers *) (pHeader + 1))->name == NULL);\
																	((pointers *) (pHeader + 1))->name = ptr;\
																	(*pfResult) = TRUE;\
																}\
															}



#endif	// __THREADLOCALPTRS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\appdesc.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       AppDesc.cpp
 *  Content:    Application Description Object
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  09/02/00	mjn		Created
 *  09/14/2000	rmt		Bug #44625 - CORE: Multihomed machines are not always enumerable (extra spew)
 *	01/25/01	mjn		Fixed 64-bit alignment problem when unpacking AppDesc
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


#undef DPF_MODNAME
#define DPF_MODNAME "CApplicationDesc::Initialize"

HRESULT CApplicationDesc::Initialize( void )
{
	if (!DNInitializeCriticalSection(&m_cs))
	{
		return( DPNERR_OUTOFMEMORY );
	}

	m_dwFlags = 0;

	m_dwMaxPlayers = 0;
	m_dwCurrentPlayers = 0;

	m_pwszSessionName = NULL;
	m_dwSessionNameSize = 0;

	m_pwszPassword = NULL;
	m_dwPasswordSize = 0;

	m_pvReservedData = NULL;
	m_dwReservedDataSize = 0;

	m_pvApplicationReservedData = NULL;
	m_dwApplicationReservedDataSize = 0;

	memset(&m_guidInstance,0,sizeof(GUID));
	memset(&m_guidApplication,0,sizeof(GUID));

	return( DPN_OK );
}


#undef DPF_MODNAME
#define DPF_MODNAME "CApplicationDesc::Deinitialize"

void CApplicationDesc::Deinitialize( void )
{
	if (m_pwszSessionName)
	{
		DNFree(m_pwszSessionName);
		m_pwszSessionName = NULL;
		m_dwSessionNameSize = 0;
	}

	if (m_pwszPassword)
	{
		DNFree(m_pwszPassword);
		m_pwszPassword = NULL;
		m_dwPasswordSize = 0;
	}

	if (m_pvReservedData)
	{
		DNFree(m_pvReservedData);
		m_pvReservedData = NULL;
		m_dwReservedDataSize = 0;
	}

	if (m_pvApplicationReservedData)
	{
		DNFree(m_pvApplicationReservedData);
		m_pvApplicationReservedData = NULL;
		m_dwApplicationReservedDataSize = 0;
	}

	DNDeleteCriticalSection(&m_cs);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CApplicationDesc::Pack"

HRESULT	CApplicationDesc::Pack(CPackedBuffer *const pPackedBuffer,
							   const DWORD dwFlags)
{
	HRESULT		hResultCode;
	DPN_APPLICATION_DESC	*pdpnAppDesc;

	DPFX(DPFPREP, 6,"Parameters: pPackedBuffer [0x%p], dwFlags [0x%lx]",pPackedBuffer,dwFlags);

	Lock();

	//
	//	Add structure
	//
	pdpnAppDesc = reinterpret_cast<DPN_APPLICATION_DESC*>(pPackedBuffer->GetHeadAddress());
	hResultCode = pPackedBuffer->AddToFront(NULL,sizeof(DPN_APPLICATION_DESC));

	//
	//	Add session name
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_SESSIONNAME) && (m_dwSessionNameSize > 0))
	{
		hResultCode = pPackedBuffer->AddToBack(m_pwszSessionName,m_dwSessionNameSize);
		if (hResultCode == DPN_OK)
		{
			pdpnAppDesc->pwszSessionName = static_cast<WCHAR*>(pPackedBuffer->GetTailAddress());
		}
	}
	else
	{
		if (hResultCode == DPN_OK)
		{
			pdpnAppDesc->pwszSessionName = NULL;
		}
	}

	//
	//	Add password
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_PASSWORD) && (m_dwPasswordSize > 0))
	{
		hResultCode = pPackedBuffer->AddToBack(m_pwszPassword,m_dwPasswordSize);
		if (hResultCode == DPN_OK)
		{
			pdpnAppDesc->pwszPassword = static_cast<WCHAR*>(pPackedBuffer->GetTailAddress());
		}
	}
	else
	{
		if (hResultCode == DPN_OK)
		{
			pdpnAppDesc->pwszPassword = NULL;
		}
	}

	//
	//	Add reserved data
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_RESERVEDDATA) && (m_dwReservedDataSize > 0))
	{
		hResultCode = pPackedBuffer->AddToBack(m_pvReservedData,m_dwReservedDataSize);
		if (hResultCode == DPN_OK)
		{
			pdpnAppDesc->pvReservedData = pPackedBuffer->GetTailAddress();
			pdpnAppDesc->dwReservedDataSize = m_dwReservedDataSize;
		}
	}
	else
	{
		if (hResultCode == DPN_OK)
		{
			pdpnAppDesc->pvReservedData = NULL;
			pdpnAppDesc->dwReservedDataSize = 0;
		}
	}

	//
	//	Add app reserved data
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_APPRESERVEDDATA) && (m_dwApplicationReservedDataSize > 0))
	{
		hResultCode = pPackedBuffer->AddToBack(m_pvApplicationReservedData,m_dwApplicationReservedDataSize);
		if (hResultCode == DPN_OK)
		{
			pdpnAppDesc->pvApplicationReservedData = pPackedBuffer->GetTailAddress();
			pdpnAppDesc->dwApplicationReservedDataSize = m_dwApplicationReservedDataSize;
		}
	}
	else
	{
		if (hResultCode == DPN_OK)
		{
			pdpnAppDesc->pvApplicationReservedData = NULL;
			pdpnAppDesc->dwApplicationReservedDataSize = 0;
		}
	}

	//
	//	Fill in remainder of structure (if space)
	//
	if (hResultCode == DPN_OK)
	{
		pdpnAppDesc->dwSize = sizeof(DPN_APPLICATION_DESC);
		pdpnAppDesc->dwFlags = m_dwFlags;
		pdpnAppDesc->dwMaxPlayers = m_dwMaxPlayers;
		pdpnAppDesc->dwCurrentPlayers = m_dwCurrentPlayers;
		memcpy(&pdpnAppDesc->guidInstance,&m_guidInstance,sizeof(GUID));
		memcpy(&pdpnAppDesc->guidApplication,&m_guidApplication,sizeof(GUID));
	}

	Unlock();

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CApplicationDesc::PackInfo"

HRESULT CApplicationDesc::PackInfo(CPackedBuffer *const pPackedBuffer,
								   const DWORD dwFlags)
{
	HRESULT		hResultCode;
	DPN_APPLICATION_DESC_INFO	*pInfo;

	DPFX(DPFPREP, 6,"Parameters: pPackedBuffer [0x%p], dwFlags [0x%lx]",pPackedBuffer,dwFlags);

	//
	//	Add structure
	//
	pInfo = reinterpret_cast<DPN_APPLICATION_DESC_INFO*>(pPackedBuffer->GetHeadAddress());
	hResultCode = pPackedBuffer->AddToFront(NULL,sizeof(DPN_APPLICATION_DESC_INFO));

	Lock();

	//
	//	Add session name
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_SESSIONNAME) && (m_dwSessionNameSize > 0))
	{
		hResultCode = pPackedBuffer->AddToBack(m_pwszSessionName,m_dwSessionNameSize);
		if (hResultCode == DPN_OK)
		{
			pInfo->dwSessionNameOffset = pPackedBuffer->GetTailOffset();
			pInfo->dwSessionNameSize = m_dwSessionNameSize;
		}
	}
	else
	{
		if (hResultCode == DPN_OK)
		{
			pInfo->dwSessionNameOffset = 0;
			pInfo->dwSessionNameSize = 0;
		}
	}

	//
	//	Add password
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_PASSWORD) && (m_dwPasswordSize > 0))
	{
		hResultCode = pPackedBuffer->AddToBack(m_pwszPassword,m_dwPasswordSize);
		if (hResultCode == DPN_OK)
		{
			pInfo->dwPasswordOffset = pPackedBuffer->GetTailOffset();
			pInfo->dwPasswordSize = m_dwPasswordSize;
		}
	}
	else
	{
		if (hResultCode == DPN_OK)
		{
			pInfo->dwPasswordOffset = 0;
			pInfo->dwPasswordSize = 0;
		}
	}

	//
	//	Add reserved data
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_RESERVEDDATA) && (m_dwReservedDataSize > 0))
	{
		hResultCode = pPackedBuffer->AddToBack(m_pvReservedData,m_dwReservedDataSize);
		if (hResultCode == DPN_OK)
		{
			pInfo->dwReservedDataOffset = pPackedBuffer->GetTailOffset();
			pInfo->dwReservedDataSize = m_dwReservedDataSize;
		}
	}
	else
	{
		if (hResultCode == DPN_OK)
		{
			pInfo->dwReservedDataOffset = 0;
			pInfo->dwReservedDataSize = 0;
		}
	}

	//
	//	Add app reserved data
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_APPRESERVEDDATA) && (m_dwApplicationReservedDataSize > 0))
	{
		hResultCode = pPackedBuffer->AddToBack(m_pvApplicationReservedData,m_dwApplicationReservedDataSize);
		if (hResultCode == DPN_OK)
		{
			pInfo->dwApplicationReservedDataOffset = pPackedBuffer->GetTailOffset();
			pInfo->dwApplicationReservedDataSize = m_dwApplicationReservedDataSize;
		}
	}
	else
	{
		if (hResultCode == DPN_OK)
		{
			pInfo->dwApplicationReservedDataOffset = 0;
			pInfo->dwApplicationReservedDataSize = 0;
		}
	}

	//
	//	Fill in remainder of structure (if space)
	//
	if (hResultCode == DPN_OK)
	{
		pInfo->dwFlags = m_dwFlags;
		pInfo->dwMaxPlayers = m_dwMaxPlayers;
		pInfo->dwCurrentPlayers = m_dwCurrentPlayers;
		memcpy(&pInfo->guidInstance,&m_guidInstance,sizeof(GUID));
		memcpy(&pInfo->guidApplication,&m_guidApplication,sizeof(GUID));
	}

	Unlock();

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CApplicationDesc::UnpackInfo"

HRESULT CApplicationDesc::UnpackInfo(UNALIGNED DPN_APPLICATION_DESC_INFO *const pdnAppDescInfo,
									 void *const pBufferStart,
									 const DWORD dwFlags)
{
	HRESULT		hResultCode;
	WCHAR		*pwszSessionName;
	WCHAR		*pwszPassword;
	void		*pvReservedData;
	void		*pvApplicationReservedData;

	DPFX(DPFPREP, 6,"Parameters: pdnAppDescInfo [0x%p], pBufferStart [0x%p], dwFlags [0x%lx]",pdnAppDescInfo,pBufferStart,dwFlags);

	pwszSessionName = NULL;
	pwszPassword = NULL;
	pvReservedData = NULL;
	pvApplicationReservedData = NULL;

	//
	//	We will allocate the required memory for the data fields first.
	//	If everything succeeds, we will update the object
	//

	//
	//	Session Name
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_SESSIONNAME) && (pdnAppDescInfo->dwSessionNameSize))
	{
		if ((pwszSessionName = static_cast<WCHAR*>(DNMalloc(pdnAppDescInfo->dwSessionNameSize))) == NULL)
		{
			DPFERR("Could not allocate application desc session name");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		memcpy(	pwszSessionName,
				static_cast<BYTE*>(pBufferStart) + pdnAppDescInfo->dwSessionNameOffset,
				pdnAppDescInfo->dwSessionNameSize);
	}

	//
	//	Password
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_PASSWORD) && (pdnAppDescInfo->dwPasswordSize))
	{
		if ((pwszPassword = static_cast<WCHAR*>(DNMalloc(pdnAppDescInfo->dwPasswordSize))) == NULL)
		{
			DPFERR("Could not allocate application desc password");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		memcpy(	pwszPassword,
				static_cast<BYTE*>(pBufferStart) + pdnAppDescInfo->dwPasswordOffset,
				pdnAppDescInfo->dwPasswordSize);
	}

	//
	//	Reserved Data
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_RESERVEDDATA) && (pdnAppDescInfo->dwReservedDataSize))
	{
		if ((pvReservedData = DNMalloc(pdnAppDescInfo->dwReservedDataSize)) == NULL)
		{
			DPFERR("Could not allocate application desc reserved data");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		memcpy(	pvReservedData,
				static_cast<BYTE*>(pBufferStart) + pdnAppDescInfo->dwReservedDataOffset,
				pdnAppDescInfo->dwReservedDataSize);
	}

	//
	//	Application Reserved Data
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_APPRESERVEDDATA) && (pdnAppDescInfo->dwApplicationReservedDataSize))
	{
		if ((pvApplicationReservedData = DNMalloc(pdnAppDescInfo->dwApplicationReservedDataSize)) == NULL)
		{
			DPFERR("Could not allocate application desc app reserved data");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		memcpy(	pvApplicationReservedData,
				static_cast<BYTE*>(pBufferStart) + pdnAppDescInfo->dwApplicationReservedDataOffset,
				pdnAppDescInfo->dwApplicationReservedDataSize);
	}


	//
	//	Replace old values in object
	//

	Lock();

	//
	//	Session Name
	//
	if (dwFlags & DN_APPDESCINFO_FLAG_SESSIONNAME)
	{
		if (m_pwszSessionName)
		{
			DNFree(m_pwszSessionName);
			m_pwszSessionName = NULL;
			m_dwSessionNameSize = 0;
		}
		m_pwszSessionName = pwszSessionName;
		m_dwSessionNameSize = pdnAppDescInfo->dwSessionNameSize;
	}

	//
	//	Password
	//
	if (dwFlags & DN_APPDESCINFO_FLAG_PASSWORD)
	{
		if (m_pwszPassword)
		{
			DNFree(m_pwszPassword);
			m_pwszPassword = NULL;
			m_dwPasswordSize = 0;
		}
		m_pwszPassword = pwszPassword;
		m_dwPasswordSize = pdnAppDescInfo->dwPasswordSize;
	}

	//
	//	Reserved Data
	//
	if (dwFlags & DN_APPDESCINFO_FLAG_RESERVEDDATA)
	{
		if (m_pvReservedData)
		{
			DNFree(m_pvReservedData);
			m_pvReservedData = NULL;
			m_dwReservedDataSize = 0;
		}
		m_pvReservedData = pvReservedData;
		m_dwReservedDataSize = pdnAppDescInfo->dwReservedDataSize;
	}

	//
	//	Application Reserved Data
	//
	if (dwFlags & DN_APPDESCINFO_FLAG_APPRESERVEDDATA)
	{
		if (m_pvApplicationReservedData)
		{
			DNFree(m_pvApplicationReservedData);
			m_pvApplicationReservedData = NULL;
			m_dwApplicationReservedDataSize = 0;
		}
		m_pvApplicationReservedData = pvApplicationReservedData;
		m_dwApplicationReservedDataSize = pdnAppDescInfo->dwApplicationReservedDataSize;
	}

	//
	//	Remaining fields
	//
	m_dwMaxPlayers = pdnAppDescInfo->dwMaxPlayers;
	m_dwFlags = pdnAppDescInfo->dwFlags;
	memcpy(&m_guidInstance,&pdnAppDescInfo->guidInstance,sizeof(GUID));
	memcpy(&m_guidApplication,&pdnAppDescInfo->guidApplication,sizeof(GUID));

	Unlock();

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pwszSessionName)
	{
		DNFree(pwszSessionName);
		pwszSessionName = NULL;
	}
	if (pwszPassword)
	{
		DNFree(pwszPassword);
		pwszPassword = NULL;
	}
	if (pvReservedData)
	{
		DNFree(pvReservedData);
		pvReservedData = NULL;
	}
	if (pvApplicationReservedData)
	{
		DNFree(pvApplicationReservedData);
		pvApplicationReservedData = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CApplicationDesc::Update"

HRESULT CApplicationDesc::Update(const DPN_APPLICATION_DESC *const pdnAppDesc,
								 const DWORD dwFlags)
{
	HRESULT		hResultCode;
	WCHAR		*pwszSessionName;
	DWORD		dwSessionNameSize;
	WCHAR		*pwszPassword;
	DWORD		dwPasswordSize;
	void		*pvReservedData;
	void		*pvApplicationReservedData;

	DPFX(DPFPREP, 6,"Parameters: pdnAppDesc [0x%p], dwFlags [0x%lx]",pdnAppDesc,dwFlags);

	pwszSessionName = NULL;
	dwSessionNameSize = 0;
	pwszPassword = NULL;
	dwPasswordSize = 0;
	pvReservedData = NULL;
	pvApplicationReservedData = NULL;

	//
	//	We will allocate the required memory for the data fields first.
	//	If everything succeeds, we will update the object
	//

	//
	//	Session Name
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_SESSIONNAME) && (pdnAppDesc->pwszSessionName))
	{
		dwSessionNameSize = (wcslen(pdnAppDesc->pwszSessionName) + 1) * sizeof(WCHAR);
		if ((pwszSessionName = static_cast<WCHAR*>(DNMalloc(dwSessionNameSize))) == NULL)
		{
			DPFERR("Could not allocate application desc session name");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		memcpy(	pwszSessionName,
				pdnAppDesc->pwszSessionName,
				dwSessionNameSize);
	}

	//
	//	Password
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_PASSWORD) && (pdnAppDesc->pwszPassword))
	{
		dwPasswordSize = (wcslen(pdnAppDesc->pwszPassword) + 1) * sizeof(WCHAR);
		if ((pwszPassword = static_cast<WCHAR*>(DNMalloc(dwPasswordSize))) == NULL)
		{
			DPFERR("Could not allocate application desc password");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		memcpy(	pwszPassword,
				pdnAppDesc->pwszPassword,
				dwPasswordSize);
	}

	//
	//	Reserved Data
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_RESERVEDDATA) && (pdnAppDesc->pvReservedData))
	{
		if ((pvReservedData = DNMalloc(pdnAppDesc->dwReservedDataSize)) == NULL)
		{
			DPFERR("Could not allocate application desc reserved data");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		memcpy(	pvReservedData,
				pdnAppDesc->pvReservedData,
				pdnAppDesc->dwReservedDataSize);
	}

	//
	//	Application Reserved Data
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_APPRESERVEDDATA) && (pdnAppDesc->pvApplicationReservedData))
	{
		if ((pvApplicationReservedData = DNMalloc(pdnAppDesc->dwApplicationReservedDataSize)) == NULL)
		{
			DPFERR("Could not allocate application desc app reserved data");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		memcpy(	pvApplicationReservedData,
				pdnAppDesc->pvApplicationReservedData,
				pdnAppDesc->dwApplicationReservedDataSize);
	}


	//
	//	Replace old values in object
	//

	//
	//	Session Name
	//
	if (dwFlags & DN_APPDESCINFO_FLAG_SESSIONNAME)
	{
		if (m_pwszSessionName)
		{
			DNFree(m_pwszSessionName);
			m_pwszSessionName = NULL;
			m_dwSessionNameSize = 0;
		}
		m_pwszSessionName = pwszSessionName;
		m_dwSessionNameSize = dwSessionNameSize;
	}

	//
	//	Password
	//
	if (dwFlags & DN_APPDESCINFO_FLAG_PASSWORD)
	{
		if (m_pwszPassword)
		{
			DNFree(m_pwszPassword);
			m_pwszPassword = NULL;
			m_dwPasswordSize = 0;
		}
		m_pwszPassword = pwszPassword;
		m_dwPasswordSize = dwPasswordSize;
	}

	//
	//	Reserved Data
	//
	if (dwFlags & DN_APPDESCINFO_FLAG_RESERVEDDATA)
	{
		if (m_pvReservedData)
		{
			DNFree(m_pvReservedData);
			m_pvReservedData = NULL;
			m_dwReservedDataSize = 0;
		}
		m_pvReservedData = pvReservedData;
		m_dwReservedDataSize = pdnAppDesc->dwReservedDataSize;
	}

	//
	//	Application Reserved Data
	//
	if (dwFlags & DN_APPDESCINFO_FLAG_APPRESERVEDDATA)
	{
		if (m_pvApplicationReservedData)
		{
			DNFree(m_pvApplicationReservedData);
			m_pvApplicationReservedData = NULL;
			m_dwApplicationReservedDataSize = 0;
		}
		m_pvApplicationReservedData = pvApplicationReservedData;
		m_dwApplicationReservedDataSize = pdnAppDesc->dwApplicationReservedDataSize;
	}

	//
	//	Remaining fields
	//
	m_dwMaxPlayers = pdnAppDesc->dwMaxPlayers;
	m_dwFlags = pdnAppDesc->dwFlags;
	memcpy(&m_guidInstance,&pdnAppDesc->guidInstance,sizeof(GUID));
	memcpy(&m_guidApplication,&pdnAppDesc->guidApplication,sizeof(GUID));

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pwszSessionName)
	{
		DNFree(pwszSessionName);
		pwszSessionName = NULL;
	}
	if (pwszPassword)
	{
		DNFree(pwszPassword);
		pwszPassword = NULL;
	}
	if (pvReservedData)
	{
		DNFree(pvReservedData);
		pvReservedData = NULL;
	}
	if (pvApplicationReservedData)
	{
		DNFree(pvApplicationReservedData);
		pvApplicationReservedData = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CApplicationDesc::CreateNewInstanceGuid"

HRESULT	CApplicationDesc::CreateNewInstanceGuid( void )
{
	HRESULT		hResultCode;

	hResultCode = CoCreateGuid(&m_guidInstance);

	return(hResultCode);
}

#undef DPF_SUBCOMP
#define DPF_SUBCOMP 	DN_SUBCOMP_DPNSVR

#undef DPF_MODNAME
#define DPF_MODNAME "CApplicationDesc::RegisterWithDPNSVR"

HRESULT	CApplicationDesc::RegisterWithDPNSVR( IDirectPlay8Address *const pListenAddr )
{
	HRESULT		hResultCode;

#ifdef DEBUG
	DPFX(DPFPREP,  8, "Registering w/DPNSVR" );

	char szTmpAddress[200];
	DWORD dwSize = 200;

	hResultCode = pListenAddr->lpVtbl->GetURLA( pListenAddr, szTmpAddress, &dwSize );

	if( FAILED( hResultCode ) )
	{
		DPFX(DPFPREP,  1, "Failed to get URL of listen for debug purposes hr=0x%x", hResultCode );
	}
	else
	{
		DPFX(DPFPREP,  8, "Listen on: [%s]", szTmpAddress );
	}

#endif
	
	hResultCode = DPNSVR_Register( &m_guidApplication,&m_guidInstance,pListenAddr );

	DPFX(DPFPREP,  8, "Request result hr=0x%x", hResultCode );
	
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CApplicationDesc::UnregisterWithDPNSVR"

HRESULT CApplicationDesc::UnregisterWithDPNSVR( void )
{
	HRESULT		hResultCode;

	hResultCode = DPNSVR_UnRegister( &m_guidApplication,&m_guidInstance );
	return(hResultCode);
}

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_CORE

#undef DPF_MODNAME
#define DPF_MODNAME "CApplicationDesc::IncPlayerCount"

HRESULT	CApplicationDesc::IncPlayerCount(const BOOL fCheckLimit)
{
	HRESULT		hResultCode;

	Lock();

	if ((fCheckLimit) && (m_dwMaxPlayers) && (m_dwCurrentPlayers >= m_dwMaxPlayers))
	{
		hResultCode = DPNERR_SESSIONFULL;
	}
	else
	{
		m_dwCurrentPlayers++;
		hResultCode = DPN_OK;
	}

	Unlock();

	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CApplicationDesc::DecPlayerCount"

void CApplicationDesc::DecPlayerCount( void )
{
	Lock();
	m_dwCurrentPlayers--;
	Unlock();
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessUpdateAppDesc"

HRESULT	DNProcessUpdateAppDesc(DIRECTNETOBJECT *const pdnObject,
							   DPN_APPLICATION_DESC_INFO *const pv)
{
	HRESULT				hResultCode;

	DPFX(DPFPREP, 6,"Parameters: pv [0x%p]",pv);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pv != NULL);

	hResultCode = pdnObject->ApplicationDesc.UnpackInfo(pv,
														pv,
														DN_APPDESCINFO_FLAG_SESSIONNAME | DN_APPDESCINFO_FLAG_PASSWORD |
														DN_APPDESCINFO_FLAG_RESERVEDDATA | DN_APPDESCINFO_FLAG_APPRESERVEDDATA);

	hResultCode = DNUserUpdateAppDesc(pdnObject);

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\common\strutils.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       StrUtils.h
 *  Content:    Defines the string utils
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   02/12/2000	rmt		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __STRUTILS_H
#define __STRUTILS_H

HRESULT STR_jkWideToAnsi(LPSTR lpStr,LPCWSTR lpWStr,int cchStr);
HRESULT STR_AllocAndConvertToANSI(LPSTR * ppszAnsi,LPCWSTR lpszWide);
HRESULT STR_jkAnsiToWide(LPWSTR lpWStr,LPCSTR lpStr,int cchWStr);

HRESULT	STR_WideToAnsi( const WCHAR *const pWCHARString,
						const DWORD dwWCHARStringLength,
						char *const pString,
						DWORD *const pdwStringLength );

HRESULT	STR_AnsiToWide( const char *const pString,
						const DWORD dwStringLength,
						WCHAR *const pWCHARString,
						DWORD *const pdwWCHARStringLength );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\appdesc.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       AppDesc.h
 *  Content:    Application Description Object Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  09/02/00	mjn		Created
 *	09/05/00	mjn		Added GetDPNIDMask()
 *	01/25/01	mjn		Fixed 64-bit alignment problem when unpacking AppDesc
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__APPDESC_H__
#define	__APPDESC_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_CORE

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	DN_APPDESCINFO_FLAG_SESSIONNAME		0x0001
#define DN_APPDESCINFO_FLAG_PASSWORD		0x0002
#define	DN_APPDESCINFO_FLAG_RESERVEDDATA	0x0004
#define DN_APPDESCINFO_FLAG_APPRESERVEDDATA	0x0008
#define	DN_APPDESCINFO_FLAG_CURRENTPLAYERS	0x0010

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

class CPackedBuffer;

typedef	struct DPN_APPLICATION_DESC_INFO DPN_APPLICATION_DESC_INFO;

typedef struct _DIRECTNETOBJECT DIRECTNETOBJECT;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

HRESULT	DNProcessUpdateAppDesc(DIRECTNETOBJECT *const pdnObject,
							   DPN_APPLICATION_DESC_INFO *const pv);

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for Application Description

class CApplicationDesc
{
public:
	CApplicationDesc()		// Constructor
		{
			m_Sig[0] = 'A';
			m_Sig[1] = 'P';
			m_Sig[2] = 'P';
			m_Sig[3] = 'D';
		};

	~CApplicationDesc()		// Destructor
		{
		};

	HRESULT CApplicationDesc::Initialize( void );

	void CApplicationDesc::Deinitialize( void );

	void Lock( void )
		{
			DNEnterCriticalSection( &m_cs );
		};

	void Unlock( void )
		{
			DNLeaveCriticalSection( &m_cs );
		};

	HRESULT	CApplicationDesc::Pack(CPackedBuffer *const pPackedBuffer,
								   const DWORD dwFlags);

	HRESULT CApplicationDesc::PackInfo(CPackedBuffer *const pPackedBuffer,
									   const DWORD dwFlags);

	HRESULT CApplicationDesc::UnpackInfo(UNALIGNED DPN_APPLICATION_DESC_INFO *const pdnAppDescInfo,
										 void *const pBufferStart,
										 const DWORD dwFlags);

	HRESULT CApplicationDesc::Update(const DPN_APPLICATION_DESC *const pdnAppDesc,
									 const DWORD dwFlags);

	HRESULT	CApplicationDesc::CreateNewInstanceGuid( void );

	HRESULT	CApplicationDesc::IncPlayerCount(const BOOL fCheckLimit);

	void CApplicationDesc::DecPlayerCount( void );

	HRESULT	CApplicationDesc::RegisterWithDPNSVR( IDirectPlay8Address *const pListenAddr );

	HRESULT CApplicationDesc::UnregisterWithDPNSVR( void );

	DWORD GetMaxPlayers( void )
		{
			return( m_dwMaxPlayers );
		};

	DWORD GetCurrentPlayers( void )
		{
			return( m_dwCurrentPlayers );
		};

	WCHAR *GetPassword( void )
		{
			return( m_pwszPassword );
		};

	GUID *GetInstanceGuid( void )
		{
			return( &m_guidInstance );
		};

	GUID *GetApplicationGuid( void )
		{
			return( &m_guidApplication );
		};

	BOOL IsClientServer( void )
		{
			if (m_dwFlags & DPNSESSION_CLIENT_SERVER)
			{
				return( TRUE );
			}
			return( FALSE );
		};

	BOOL AllowHostMigrate( void )
		{
			if (m_dwFlags & DPNSESSION_MIGRATE_HOST)
			{
				return( TRUE );
			}
			return( FALSE );
		};

	BOOL UseDPNSVR( void )
		{
			if (m_dwFlags & DPNSESSION_NODPNSVR)
			{
				return( FALSE );
			}
			return( TRUE );
		};

	BOOL RequirePassword( void )
		{
			if (m_dwFlags & DPNSESSION_REQUIREPASSWORD)
			{
				return( TRUE );
			}
			return( FALSE );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CApplicationDesc::IsEqualInstanceGuid"
	BOOL IsEqualInstanceGuid( const GUID *const pguidInstance )
		{
			DNASSERT( pguidInstance != NULL );

			if (!memcmp(&m_guidInstance,(UNALIGNED GUID*)pguidInstance,sizeof(GUID)))
			{
				return( TRUE );
			}
			return( FALSE );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CApplicationDesc::IsEqualApplicationGuid"
	BOOL IsEqualApplicationGuid( const GUID *const pguidApplication )
		{
			DNASSERT( pguidApplication != NULL );

			if (!memcmp(&m_guidApplication,(UNALIGNED GUID*)pguidApplication,sizeof(GUID)))
			{
				return( TRUE );
			}
			return( FALSE );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CApplicationDesc::IsEqualPassword"
	BOOL IsEqualPassword( UNALIGNED const WCHAR *const pwszPassword )
		{
//			DWORD	dwPasswordSize;
			UNALIGNED const WCHAR *p;
			WCHAR	*q;

			if ((pwszPassword == NULL) && (m_pwszPassword == NULL))
			{
				return(TRUE);
			}
			if ((pwszPassword == NULL) || (m_pwszPassword == NULL))
			{
				return(FALSE);
			}
			DNASSERT( pwszPassword != NULL );
			DNASSERT( m_pwszPassword != NULL);

			p = pwszPassword;
			q = m_pwszPassword;
			while (*p != L'\0' && *q != L'\0')
			{
				if (*p != *q)
				{
					return(FALSE);
				}
				p++;
				q++;
			}
			if (*p != *q)
			{
				return(FALSE);
			}
			return(TRUE);
/*
			dwPasswordSize = wcslen(pwszPassword);
			if (!wcscmp(m_pwszPassword,pwszPassword))
			{
				return( TRUE );
			}
			return( FALSE );
*/
		};

	DPNID GetDPNIDMask( void )
		{
			DPNID	*pdpnid;

			pdpnid = reinterpret_cast<DPNID*>(&m_guidInstance);
			return( *pdpnid );
		};

private:
	BYTE		m_Sig[4];

	DWORD		m_dwFlags;

	DWORD		m_dwMaxPlayers;
	DWORD		m_dwCurrentPlayers;

	WCHAR		*m_pwszSessionName;
	DWORD		m_dwSessionNameSize;	// in bytes

	WCHAR		*m_pwszPassword;
	DWORD		m_dwPasswordSize;		// in bytes

	void		*m_pvReservedData;
	DWORD		m_dwReservedDataSize;

	void		*m_pvApplicationReservedData;
	DWORD		m_dwApplicationReservedDataSize;

	GUID		m_guidInstance;
	GUID		m_guidApplication;

	DNCRITICAL_SECTION		m_cs;
};

#undef DPF_MODNAME

#endif	// __APPDESC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\async.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Async.cpp
 *  Content:    Async operation FPM routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/27/99	mjn		Created
 *  12/23/99	mjn		Added HOST_MIGRATE functionality
 *	12/28/99	mjn		Moved Async Op stuff to Async.h
 *	12/29/99	mjn		Reformed DN_ASYNC_OP to use hParentOp instead of lpvUserContext
 *	01/06/00	mjn		Moved NameTable stuff to NameTable.h
 *	01/07/00	mjn		Handle NULL buffer descriptors during sends
 *	01/09/00	mjn		Transfer Application Description at connect
 *	01/10/00	mjn		Added support for DN_MSG_INTERNAL_UPDATE_APPLICATION_DESC
 *	01/12/00	jtk		Added simple code to handle enum and enum response messages.
 *	01/11/00	mjn		Moved AppDesc stuff to AppDesc.h
 *						Moved connect/disconnect stuff to Connect.h
 *	01/14/00	mjn		Added pvUserContext to DN_PerformListen
 *	01/15/00	mjn		Replaced DN_COUNT_BUFFER with CRefCountBuffer
 *	01/16/00	mjn		Moved User callback stuff to User.h
 *	01/17/00	mjn		Fixed ConnectToPeer function names
 *	01/17/00	mjn		Implemented send time
 *	01/19/00	mjn		Fixed Parent Op refCount bug in MultiSend
 *	01/19/00	mjn		Replaced DN_SYNC_EVENT with CSyncEvent
 *	01/20/00	mjn		Route NameTable operations through NameTable operation list
 *	01/21/00	mjn		Added DNProcessInternalOperation
 *	01/23/00	mjn		Added support for DN_MSG_INTERNAL_HOST_DESTROY_PLAYER
 *	01/24/00	mjn		Added support for DN_MSG_INTERNAL_NAMETABLE_VERSION
 *							and DN_MSG_INTERNAL_RESYNC_VERSION
 *	01/25/00	mjn		Added support for DN_MSG_INTERNAL_HOST_MIGRATE_COMPLETE
 *	01/26/00	mjn		Implemented NameTable re-sync at host migration
 *	01/27/00	mjn		Cleaned up switch/case statements
 *	01/27/00	mjn		Added support for retention of receive buffers
 *	02/09/00	mjn		Implemented DNSEND_COMPLETEONPROCESS
 *	02/18/00	mjn		Converted DNADDRESS to IDirectPlayAddress8
 *	03/23/00	mjn		Added phrSync and pvInternal
 *	03/24/00	mjn		Add guidSP to DN_ASYNC_OP
 *  03/25/00    rmt     Added code to unregister ourselves when listens are terminated
 *  04/04/00	rmt		Added check for DPNSVR disable before attempting to unregister
 *	04/04/00	mjn		Added DNProcessTerminateSession and related code
 *  04/06/00    rmt     Added code to complete nocopy voice sends
 *	04/10/00	mjn		Use CAsyncOp for CONNECTs, LISTENs and DISCONNECTs
 *	04/11/00	mjn		Use CAsyncOp for ENUMs
 *	04/13/00	mjn		Use Protocol Interface VTBL (replaces some functions)
 *	04/14/00	mjn		DNPerformListen performs synchronous LISTENs
 *	04/16/00	mjn		Use CAsyncOp for SENDs
 *	04/17/00	mjn		Replaced BUFFERDESC with DPN_BUFFER_DESC
 *	04/17/00	mjn		Added DNCompleteAsyncHandle
 *	04/20/00	mjn		DNPerformChildSend set's child op flags to the parent's op flags
 *	04/21/00	mjn		Added DNPerformDisconnect
 *	04/23/00	mjn		Optionally return child AsyncOp in DNPerformChildSend()
 *				mjn		Removed DNSendCompleteOnProcess (better implementation)
 *	04/24/00	mjn		Added DNCreateUserHandle()
 *	04/26/00	mjn		Removed DN_ASYNC_OP and related functions
 *	04/28/00	mjn		Clear unused buffer descriptions in DN_SendTo()
 *	05/02/00	mjn		Keep a reference on the Connection during SEND's
 *	05/05/00	mjn		Return DPN_OK from DNReceiveCompleteOnProcess() to prevent holding the buffer
 *	05/08/00	vpo		Removed asserts when protocol returns non PENDING
 *	06/05/00	mjn		Removed assert in DNSendMessage
 *	06/21/00	mjn		Modified DNSendMessage() and DNCreateSendParent() to use protocol voice bit
 *	06/24/00	mjn		Added CONNECT completions and fixed DN_MSG_INTERNAL_CONNECT_FAILED processing
 *				mjn		Added code to process DN_MSG_INTERNAL_INSTRUCTED_CONNECT_FAILED
 *	07/02/00	mjn		Added DNSendGroupMessage() *@@END_MSINTERNAL
 *	07/05/00	mjn		Removed references to DN_MSG_INTERNAL_ENUM_WITH_APPLICATION_GUID,DN_MSG_INTERNAL_ENUM,DN_MSG_INTERNAL_ENUM_RESPONSE
 *	07/06/00	mjn		Only use CONNECTED connections in group sends
 *				mjn		Use SP handle instead of interface
 *	07/10/00	mjn		Added DNPerformEnumQuery()
 *				mjn		Correctly flag parent ops in groups sends and added DPNIDs to async ops for better tracking
 *	07/11/00	mjn		Added fNoLoopBack to DNSendGroupMessage()
 *				mjn		Added DNPerformNextEnumQuery(),DNPerformSPListen(),DNPerformNextListen(),DNEnumAdapterGuids(),DNPerformNextConnect()
 *	07/20/00	mjn		Fixed DN_TerminateAllListens() to better use locks
 *				mjn		Fixed connect completions and added DNCompleteConnectOperation() and DNCompleteSendConnectInfo()
 *				mjn		Changed DNPerformDisconnect() to take a CConnection and hEndPt
 *				mjn		Revamped CONNECT process and associated refcounts
 *	07/21/00	mjn		Process DN_MSG_INTERNAL_CONNECT_ATTEMPT_FAILED
 *	07/25/00	mjn		Save result code on parent only if failure in DNCompleteSendConnectInfo()
 *	07/26/00	mjn		DNPerformSPListen() fails if no valid device adapters
 *	07/26/00	mjn		Fixed locking problem with CAsyncOp::MakeChild()
 *	07/28/00	mjn		Added code to track send queue info on CConnection
 *	07/29/00	mjn		Use DNUserConnectionTerminated() rather than DN_TerminateSession()
 *				mjn		Added HRESULT to DNUserReturnBuffer()
 *				mjn		Added fUseCachedCaps to DN_SPEnsureLoaded()
 *	07/30/00	mjn		Use DNUserTerminateSession() rather than DNUserConnectionTerminated()
 *	07/31/00	mjn		Removed DN_MSG_INTERNAL_HOST_DESTROY_PLAYER
 *	07/31/00	mjn		Change DN_MSG_INTERNAL_DELETE_PLAYER to DN_MSG_INTERNAL_DESTROY_PLAYER
 *	08/02/00	mjn		Added dwFlags to DNReceiveUserData()
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/05/00	mjn		Added pParent to DNSendGroupMessage and DNSendMessage()
 *				mjn		Ensure cancelled operations don't proceed
 *				mjn		Added m_bilinkActiveList to CAsyncOp
 *				mjn		Added fInternal to DNPerformChildSend()
 *				mjn		Removed DN_TerminateAllListens()
 *				mjn		Added DNProcessFailedRequest() 
 *				mjn		Added DNCompleteRequest()
 *	08/07/00	mjn		Added code to handle peer-peer integrity checking
 *	08/08/00	mjn		Perform LISTENs on worker thread in DNPerformNextListen()
 *	08/14/00	mjn		Handle failed LISTENs in DNPerformListen()
 *	08/15/00	mjn		Changed registration with DPNSVR
 *				mjn		Allow NULL CConnection object pointer for DNPerformRequest()
 *	08/20/00	mjn		Removed fUseCachedCaps from DN_SPEnsureLoaded()
 *	08/24/00	mjn		Replace DN_NAMETABLE_OP with CNameTableOp
 *				mjn		DN_MSG_INTERNAL_INSTRUCT_CONNECT gets routed through DNNTAddOperation() in DNProcessInternalOperation()
 *	08/31/00	mjn		Release DirectNetLock for failure cases in DNPerformRequest()
 *	09/04/00	mjn		Added CApplicationDesc
 *	09/06/00	mjn		Fixed register with DPNSVR problem
 *  09/14/2000	rmt		Bug #44625: DPLAY8: CORE: Multihomed machines cannot always be enumerated
 *						Moved registration to after point where listen completes.  
 *	09/14/00	mjn		AddRef Protocol refcount when invoking protocol
 *	09/21/00	mjn		Allow NULL CConnection in DNPerformDisconnect()
 *	09/23/00	mjn		Added CSyncEvent to DN_LISTEN_OP_DATA
 *	09/27/00	mjn		Inform lobby of successfull connects from DNCompleteConnectOperation()
 *	10/11/00	mjn		Save protocol handle on AsyncOp earlier in DNPerformListen()
 *				mjn		Clean up DirectNet object in failure cases in DNCompleteConnectToHost() and DNCompleteSendConnectInfo()
 *	10/17/00	mjn		Fixed clean up for unreachable players
 *	12/11/00	mjn		Added verification of internal messages
 *	01/10/01	mjn		DNCompleteUserConnect() cancels ENUMs with DPNERR_CONNECTING
 *	01/22/01	mjn		Set connection as INVALID in DNPerformDisconnect()
 *	01/25/01	mjn		Fixed 64-bit alignment problem in received messages
 *	01/30/00	mjn		Avoid sending requests during host migration in DNPerformRequest()
 *	02/11/01	mjn		Allow complete on process requests during host migration in DNPerformRequest()
 *				mjn		Fixed CConnection::GetEndPt() to track calling thread
 *	03/30/01	mjn		Changes to prevent multiple loading/unloading of SP's
 *	04/05/01	mjn		Added DPNID parameter to DNProcessHostMigration3()
 *	04/11/01	mjn		Propegate LISTEN flags from listen parents in DNPerformSPListen() and DNPerformListen()
 *	04/13/01	mjn		Add requests to the request list in DNPerformRequest()
 *						Remove requests from request list in DNCompleteSendRequest() and DNReceiveCompleteOnProcessReply()
 *	05/07/01	vpo		Whistler 384350: "DPLAY8: CORE: Messages from server can be indicated before connect completes"
 *	05/11/01	mjn		Ensure sends not canceled before storing protocol handle in DNSendMessage()
 *	05/14/01	mjn		Fix client error handling when completing connect if server not available
 *	05/17/01	mjn		Track number of threads performing NameTable operations
 *	05/22/01	mjn		Properly set DirectNetObject as CONNECTED for successful client connect
 *	05/23/01	mjn		Prevent LISTEN's from being cancelled before completing in DNPerformListen()
 *	06/03/01	mjn		Make DISCONNECT's children of failed connect's in DNPerformDisconnect()
 *	06/08/01	mjn		Disconnect connection to host if connect was rejected in DNConnectToHostFailed()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


#undef DPF_MODNAME
#define DPF_MODNAME "DNCreateUserHandle"

HRESULT DNCreateUserHandle(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp **const ppAsyncOp)
{
	HRESULT		hResultCode;
	CAsyncOp	*pAsyncOp;

	DPFX(DPFPREP, 6,"Parameters: ppAsyncOp [0x%p]",ppAsyncOp);

	DNASSERT(pdnObject != NULL);
	DNASSERT(ppAsyncOp != NULL);

	pAsyncOp = NULL;

	if ((hResultCode = AsyncOpNew(pdnObject,&pAsyncOp)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pAsyncOp->SetOpType( ASYNC_OP_USER_HANDLE );
	pAsyncOp->MakeParent();

	if ((hResultCode = pdnObject->HandleTable.Create(pAsyncOp,NULL)) != DPN_OK)
	{
		DPFERR("Could not create Handle");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	pAsyncOp->AddRef();
	*ppAsyncOp = pAsyncOp;

	pAsyncOp->Release();
	pAsyncOp = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pAsyncOp)
	{
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	goto Exit;
}


//	DNEnumAdapterGuids
//
//	Generate a list of adapter GUIDs for multiple ENUMs,LISTENs,CONNECTs

#undef DPF_MODNAME
#define DPF_MODNAME "DNEnumAdapterGuids"

HRESULT DNEnumAdapterGuids(DIRECTNETOBJECT *const pdnObject,
						   GUID *const pguidSP,
						   const DWORD dwEnumBufferMinimumSize,
						   void **const ppvEnumBuffer,
						   DWORD *const pdwNumAdapters)
{
	HRESULT	hResultCode;
	GUID	*pguid;
	DWORD	dw;
	DWORD	dwAdapterBufferSize;
	DWORD	dwAdapterBufferCount;
	DWORD	dwNumAdapters;
	void	*pvAdapterBuffer;
	void	*pvBlock;
	DPN_SERVICE_PROVIDER_INFO	*pSPInfo;

	DPFX(DPFPREP, 6,"Parameters: pguidSP [0x%p], dwEnumBufferMinimumSize [%ld], ppvEnumBuffer [0x%p], pdwNumAdapters [0x%p]",
			pguidSP,dwEnumBufferMinimumSize,ppvEnumBuffer,pdwNumAdapters);

	DNASSERT(pdnObject != NULL);
	DNASSERT(ppvEnumBuffer != NULL);
	DNASSERT(pdwNumAdapters != NULL);

	pvBlock = NULL;
	pvAdapterBuffer = NULL;
	dwAdapterBufferSize = 0;
	dwAdapterBufferCount = 0;
	dwNumAdapters = 0;

	hResultCode = DN_EnumAdapters(	pdnObject,
									0,
									pguidSP,
									NULL,
									reinterpret_cast<DPN_SERVICE_PROVIDER_INFO*>(pvAdapterBuffer),
									&dwAdapterBufferSize,
									&dwAdapterBufferCount);
	if ((hResultCode == DPNERR_BUFFERTOOSMALL) && (dwAdapterBufferSize > 0))
	{
		if ((pvAdapterBuffer = DNMalloc(dwAdapterBufferSize)) == NULL)
		{
			DPFERR("Could not allocate space for adapter list");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}

		if ((pvBlock = MemoryBlockAlloc(pdnObject,dwEnumBufferMinimumSize + (dwAdapterBufferCount * sizeof(GUID)))) == NULL)
		{
			DPFERR("Could not allocate MemoryBlock");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}

		pguid = reinterpret_cast<GUID*>((static_cast<BYTE*>(pvBlock)) + dwEnumBufferMinimumSize);

		hResultCode = DN_EnumAdapters(	pdnObject,
										0,
										pguidSP,
										NULL,
										reinterpret_cast<DPN_SERVICE_PROVIDER_INFO*>(pvAdapterBuffer),
										&dwAdapterBufferSize,
										&dwAdapterBufferCount);
		if (hResultCode != DPN_OK)
		{
			DPFERR("Could not enumerate adapters");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
		DPFX(DPFPREP, 7,"dwAdapterBufferCount [%ld]",dwAdapterBufferCount);

		pSPInfo = reinterpret_cast<DPN_SERVICE_PROVIDER_INFO*>(pvAdapterBuffer);
		for ( dw = 0 ; dw < dwAdapterBufferCount ; dw++ )
		{
			static const GUID	InvalidGuid = { 0 };

			if (!memcmp(&InvalidGuid,&pSPInfo->guid,sizeof(GUID)))
			{
				pSPInfo++;
				continue;
			}
			memcpy(pguid,&pSPInfo->guid,sizeof(GUID));
			pguid++;
			dwNumAdapters++;
			pSPInfo++;
		}
		DNFree(pvAdapterBuffer);
		pvAdapterBuffer = NULL;

		DPFX(DPFPREP, 7,"Number of adapters [%ld]",dwNumAdapters);
	}

	*pdwNumAdapters = dwNumAdapters;
	*ppvEnumBuffer = pvBlock;
	pvBlock = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pvBlock)
	{
		MemoryBlockFree(pdnObject,pvBlock);
		pvBlock = NULL;
	}
	if (pvAdapterBuffer)
	{
		DNFree(pvAdapterBuffer);
		pvAdapterBuffer = NULL;
	}
	goto Exit;
}


//	DNPerformSPListen
//
//	LISTEN on a particular SP

#undef DPF_MODNAME
#define DPF_MODNAME "DNPerformSPListen"

HRESULT DNPerformSPListen(DIRECTNETOBJECT *const pdnObject,
						  IDirectPlay8Address *const pDeviceAddr,
						  CAsyncOp *const pListenParent,
						  CAsyncOp **const ppParent)
{
	HRESULT				hResultCode;
	CAsyncOp			*pParent;
	GUID				guidSP;
	GUID				guidAdapter;
	BOOL				fEnumAdapters;
	DPN_SP_CAPS			dnSPCaps;
	CServiceProvider	*pSP;
	CSyncEvent			*pSyncEvent;

	DPFX(DPFPREP, 6,"Parameters: pDeviceAddr [0x%p], pListenParent [0x%p], ppParent [0x%p]",
			pDeviceAddr,pListenParent,ppParent);

	DNASSERT(pdnObject != NULL);

	pParent = NULL;
	pSP = NULL;
	pSyncEvent = NULL;

	//
	//	Extract SP guid as we will probably need it
	//
	if ((hResultCode = pDeviceAddr->lpVtbl->GetSP(pDeviceAddr,&guidSP)) != DPN_OK)
	{
		DPFERR("SP not specified in Device address");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Ensure SP specified in Device address is loaded
	//
	if ((hResultCode = DN_SPEnsureLoaded(pdnObject,&guidSP,NULL,&pSP)) != DPN_OK)
	{
		DPFERR("Could not ensure SP is loaded!" );
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Get SP caps (to later see if we can ENUM on all adapters)
	//
	if ((hResultCode = DNGetActualSPCaps(pdnObject,pSP,&dnSPCaps)) != DPN_OK)
	{
		DPFERR("Could not get SP caps");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Create a parent op for LISTENs on this SP
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pParent)) != DPN_OK)
	{
		DPFERR("Could not create SP parent listen op");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pParent->SetOpType( ASYNC_OP_LISTEN );
	pParent->SetCompletion( DNCompleteListen );
	pParent->SetOpFlags( pListenParent->GetOpFlags() );
	pParent->MakeParent();

	if (pListenParent)
	{
		pListenParent->Lock();
		if (pListenParent->IsCancelled())
		{
			pListenParent->Unlock();
			pParent->SetResult( DPNERR_USERCANCEL );
			hResultCode = DPNERR_USERCANCEL;
			goto Failure;
		}
		pParent->MakeChild( pListenParent );
		pListenParent->Unlock();
	}

	//
	//	Set SP on parent
	//
	pParent->SetSP( pSP );

	//
	//	If there is no adapter specified in the device address,
	//	we will attempt to enum on each individual adapter if the SP supports it
	//
	fEnumAdapters = FALSE;
	if ((hResultCode = pDeviceAddr->lpVtbl->GetDevice( pDeviceAddr, &guidAdapter )) != DPN_OK)
	{
		DPFX(DPFPREP,1,"Could not determine adapter");
		DisplayDNError(1,hResultCode);

		if (dnSPCaps.dwFlags & DPNSPCAPS_SUPPORTSALLADAPTERS)
		{
			DPFX(DPFPREP, 3,"SP supports ENUMing on all adapters");
			fEnumAdapters = TRUE;
		}
	}

	pSP->Release();
	pSP = NULL;

	if(fEnumAdapters)
	{
		DWORD	dwNumAdapters;
		DN_LISTEN_OP_DATA	*pListenOpData;

		if ((hResultCode = DNEnumAdapterGuids(	pdnObject,
												&guidSP,
												sizeof(DN_LISTEN_OP_DATA),
												reinterpret_cast<void**>(&pListenOpData),
												&dwNumAdapters)) != DPN_OK)
		{
			DPFERR("Could not enum adapters for this SP");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
		if (dwNumAdapters == 0)
		{
			DPFERR("No adapters were found for this SP");
			hResultCode = DPNERR_INVALIDDEVICEADDRESS;
			goto Failure;
		}

		pListenOpData->dwNumAdapters = dwNumAdapters;
		pListenOpData->dwCurrentAdapter = 0;
		pListenOpData->dwCompleteAdapters = 0;
		pParent->SetOpData( pListenOpData );

		//
		//	Choose first adapter for initial LISTEN call
		//
		if ((hResultCode = pDeviceAddr->lpVtbl->SetDevice(pDeviceAddr,reinterpret_cast<GUID*>(pListenOpData + 1))) != DPN_OK)
		{
			DPFERR("Could not set device adapter");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
		pListenOpData->dwCurrentAdapter++;

		//
		//	Create a SyncEvent for multiple LISTENs
		//
		if ((hResultCode = SyncEventNew(pdnObject,&pSyncEvent)) != DPN_OK)
		{
			DPFERR("Could not create SyncEvent");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pListenOpData->pSyncEvent = pSyncEvent;
	}


	hResultCode = DNPerformListen(pdnObject,pDeviceAddr,pParent);
	if (hResultCode != DPNERR_PENDING)
	{
		DPFERR("Could not perform LISTEN");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	If there is a SyncEvent, wait for it to be set and then return it
	//
	if (pSyncEvent)
	{
		pSyncEvent->WaitForEvent(INFINITE);
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}

	//
	//	Save enum frame size
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if ((pdnObject->dwMaxFrameSize == 0) || (pdnObject->dwMaxFrameSize > (dnSPCaps.dwMaxEnumPayloadSize + sizeof(DN_ENUM_QUERY_PAYLOAD))))
	{
		pdnObject->dwMaxFrameSize = dnSPCaps.dwMaxEnumPayloadSize + sizeof(DN_ENUM_QUERY_PAYLOAD);
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	if (ppParent)
	{
		pParent->AddRef();
		*ppParent = pParent;
	}

	pParent->Release();
	pParent = NULL;

	hResultCode = DPN_OK;

Exit:
	DNASSERT( pParent == NULL );
	DNASSERT( pSP == NULL );
	DNASSERT( pSyncEvent == NULL );

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pParent)
	{
		pParent->Release();
		pParent = NULL;
	}
	if (pSP)
	{
		pSP->Release();
		pSP = NULL;
	}
	if (pSyncEvent)
	{
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}
	goto Exit;
}


//	DNPerformListen
//
//	IDirectPlayAddress8	*pDeviceInfo
//	CAsyncOp			*pParent

#undef DPF_MODNAME
#define DPF_MODNAME "DNPerformListen"

HRESULT DNPerformListen(DIRECTNETOBJECT *const pdnObject,
						IDirectPlay8Address *const pDeviceInfo,
						CAsyncOp *const pParent)
{
	HANDLE			hProtocol;
	HRESULT			hResultCode;
	CAsyncOp		*pAsyncOp;
	CSyncEvent		*pSyncEvent;
	HRESULT			hrListen;
#ifdef	DEBUG
	CHAR			DP8ABuffer[512];
	DWORD			DP8ASize;
#endif

	DPFX(DPFPREP, 6,"Parameters: pDeviceInfo [0x%p], pParent [0x%p]",pDeviceInfo,pParent);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pParent != NULL);

	hProtocol = NULL;
	pAsyncOp = NULL;
	pSyncEvent = NULL;

	// Try an initial check (might get lucky :)
	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
	{
		DPFERR("Not initialized");
		return(DPNERR_UNINITIALIZED);
	}

#ifdef	DEBUG
	DP8ASize = 512;
	pDeviceInfo->lpVtbl->GetURLA(pDeviceInfo,DP8ABuffer,&DP8ASize);
	DPFX(DPFPREP, 7,"Device Info [%s]",DP8ABuffer);
#endif
	//
	//	Set up for LISTEN
	//

	// HRESULT
	hrListen = DPNERR_GENERIC;

	// SyncEvent
	if ((hResultCode = SyncEventNew(pdnObject,&pSyncEvent)) != DPN_OK)
	{
		DPFERR("Could not create SyncEvent");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	//
	//	Async op for LISTEN
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pAsyncOp)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pAsyncOp->SetOpType( ASYNC_OP_LISTEN );
	pAsyncOp->SetSyncEvent(pSyncEvent);
	pAsyncOp->SetResultPointer( &hrListen );

	//
	//	We will set the LISTEN as not cancellable (part of our contract with the Protocol)
	//	We will set it as cancellable if the LISTEN completes successfully.
	//
	pAsyncOp->SetCannotCancel();

	pParent->Lock();
	if (pParent->IsCancelled())
	{
		pParent->Unlock();
		pAsyncOp->SetResult( DPNERR_USERCANCEL );
		hResultCode = DPNERR_USERCANCEL;
		goto Failure;
	}
	pAsyncOp->MakeChild(pParent);
	pParent->Unlock();

	//
	//	Add to active async op list
	//
	DNEnterCriticalSection(&pdnObject->csActiveList);
	pAsyncOp->m_bilinkActiveList.InsertBefore(&pdnObject->m_bilinkActiveList);
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	//
	//	Perform LISTEN
	//
	pAsyncOp->AddRef();
	hResultCode = DNPListen(pdnObject->pdnProtocolData,
							pDeviceInfo,
							pParent->GetSP()->GetHandle(),
							pParent->GetOpFlags(),
							static_cast<void*>(pAsyncOp),
							&hProtocol);
	if (hResultCode != DPNERR_PENDING)
	{
		DPFERR("Could not Listen at Protocol layer !");
		DisplayDNError(0,hResultCode);
		pAsyncOp->Release();
		goto Failure;
	}

	//
	//	Save Protocol handle
	//
	pAsyncOp->Lock();
	if (pAsyncOp->IsCancelled() && !pAsyncOp->IsComplete())
	{
		HRESULT		hrCancel;

		pAsyncOp->Unlock();
		DPFX(DPFPREP, 7,"Operation marked for cancel");
		if ((hrCancel = DNPCancelCommand(pdnObject->pdnProtocolData,hProtocol)) == DPN_OK)
		{
			hResultCode = DPNERR_USERCANCEL;
			goto Failure;
		}
		DPFERR("Could not cancel operation");
		DisplayDNError(0,hrCancel);
		pAsyncOp->Lock();
	}
	pAsyncOp->SetProtocolHandle(hProtocol);
	pAsyncOp->Unlock();

	//
	//	Wait for LISTEN to complete.
	//	DNPICompleteListen() will set pSyncEvent and hrListen.
	//	Clean up.
	//
	pSyncEvent->WaitForEvent(INFINITE);
	pAsyncOp->SetSyncEvent(NULL);
	pAsyncOp->SetResultPointer(NULL);

	if (hrListen != DPN_OK)
	{
		DPFERR("LISTEN did not succeed");
		DisplayDNError(0,hrListen);
		hResultCode = hrListen;
		goto Failure;
	}

	//
	//	Register with DPNSVR
	//
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_LOCALHOST && pdnObject->ApplicationDesc.UseDPNSVR() )
	{
		HRESULT hr;
		
		hr = DNRegisterListenWithDPNSVR(pdnObject,hProtocol);

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP, 0,"Register w/DPNSVR failed for protocol handle 0x%p hr=0x%x", hProtocol, hr );
		}
	}		

	pAsyncOp->Release();
	pAsyncOp = NULL;

	pSyncEvent->ReturnSelfToPool();
	pSyncEvent = NULL;

	//
	//	Flag object as LISTENing
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->dwFlags |= DN_OBJECT_FLAG_LISTENING;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	DNASSERT( hResultCode == DPNERR_PENDING );

	hResultCode = DPNERR_PENDING;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pAsyncOp)
	{
		DNEnterCriticalSection(&pdnObject->csActiveList);
		pAsyncOp->m_bilinkActiveList.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csActiveList);
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	if (pSyncEvent)
	{
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}
	goto Exit;
}


//	DNPerformNextListen
//
//	This will attempt to perform the next LISTEN if multiple adapters were requested

#undef DPF_MODNAME
#define DPF_MODNAME "DNPerformNextListen"

HRESULT DNPerformNextListen(DIRECTNETOBJECT *const pdnObject,
							CAsyncOp *const pAsyncOp,
							IDirectPlay8Address *const pDeviceAddr)
{
	HRESULT		hResultCode;
	CAsyncOp	*pParent;
	CWorkerJob	*pWorkerJob;
	DN_LISTEN_OP_DATA	*pListenOpData;

	DPFX(DPFPREP, 6,"Parameters: pAsyncOp [0x%p], pDeviceAddr [0x%p]",pAsyncOp,pDeviceAddr);

	pParent = NULL;
	pWorkerJob = NULL;

	pAsyncOp->Lock();
	if (pAsyncOp->GetParent())
	{
		pAsyncOp->GetParent()->AddRef();
		pParent = pAsyncOp->GetParent();
	}
	pAsyncOp->Unlock();

	//
	//	If there are any LISTENs left to perform, we will move on to the next one
	//
	if (pParent)
	{
		if (pParent->GetOpData())
		{
			pListenOpData = static_cast<DN_LISTEN_OP_DATA*>(pParent->GetOpData());
			if (pListenOpData->dwCurrentAdapter < pListenOpData->dwNumAdapters)
			{
				GUID	*pguid;

				pguid = reinterpret_cast<GUID*>(pListenOpData + 1);
				pguid += pListenOpData->dwCurrentAdapter;
				if ((hResultCode = pDeviceAddr->lpVtbl->SetDevice(pDeviceAddr,pguid)) != DPN_OK)
				{
					DPFERR("Could not set device for next adapter");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					goto Failure;
				}
				pListenOpData->dwCurrentAdapter++;

				//
				//	Perform LISTEN on worker thread
				//
				if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
				{
					DPFERR("Could not create WorkerJob");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					goto Failure;
				}
				pWorkerJob->SetJobType( WORKER_JOB_PERFORM_LISTEN );
				pWorkerJob->SetAddress( pDeviceAddr );
				pWorkerJob->SetAsyncOp( pParent );
				DNQueueWorkerJob(pdnObject,pWorkerJob);
			}
		}

		pParent->Release();
		pParent = NULL;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pParent)
	{
		pParent->Release();
		pParent = NULL;
	}
	if (pWorkerJob)
	{
		pWorkerJob->ReturnSelfToPool();
		pWorkerJob = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteListen"

void DNCompleteListen(DIRECTNETOBJECT *const pdnObject,
					  CAsyncOp *const pAsyncOp)
{
	DNASSERT(pdnObject != NULL);
	DNASSERT(pAsyncOp != NULL);

	pAsyncOp->Lock();
	if (pAsyncOp->GetOpData() != NULL)
	{
		MemoryBlockFree(pdnObject,pAsyncOp->GetOpData());
		pAsyncOp->SetOpData( NULL );
	}
	pAsyncOp->Unlock();

	if (pAsyncOp->IsChild())
	{
		DNASSERT(pAsyncOp->GetParent() != NULL);
		pAsyncOp->Orphan();
	}
	else
	{
		if (pAsyncOp->IsParent())
		{
			DNEnterCriticalSection(&pdnObject->csDirectNetObject);
			pdnObject->dwFlags &= (~DN_OBJECT_FLAG_LISTENING);
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		}
	}
}


//	DNPerformEnumQuery
//
//	Initiate an ENUM and take care of the book keeping

#undef DPF_MODNAME
#define DPF_MODNAME "DNPerformEnumQuery"

HRESULT DNPerformEnumQuery(DIRECTNETOBJECT *const pdnObject,
						   IDirectPlay8Address *const pHost,
						   IDirectPlay8Address *const pDevice,
						   const HANDLE hSPHandle,
						   DPN_BUFFER_DESC *const rgdnBufferDesc,
						   const DWORD cBufferDesc,
						   const DWORD dwRetryCount,
						   const DWORD dwRetryInterval,
						   const DWORD dwTimeOut,
						   const DWORD dwFlags,
						   void *const pvContext,
						   CAsyncOp *const pParent)
{
	HRESULT		hResultCode;
	CAsyncOp	*pAsyncOp;
	HANDLE		hProtocol;

	DPFX(DPFPREP, 6,"Parameters: pHost [0x%p], pDevice [0x%p], hSPHandle [0x%p], rgdnBufferDesc [0x%p], cBufferDesc [%ld], dwRetryCount [%ld], dwRetryInterval [%ld], dwTimeOut [%ld], dwFlags [0x%lx], pvContext [0x%p], pParent [0x%p]",
			pHost,pDevice,hSPHandle,rgdnBufferDesc,cBufferDesc,dwRetryCount,dwRetryInterval,dwTimeOut,dwFlags,pvContext,pParent);

	DNASSERT(pdnObject != NULL);
	DNASSERT(hSPHandle != NULL);

	pAsyncOp = NULL;

	//
	//	Create AsyncOp for ENUM
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pAsyncOp)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pAsyncOp->SetOpType( ASYNC_OP_ENUM_QUERY );
	pAsyncOp->SetResult( DPNERR_GENERIC );
	pAsyncOp->SetCompletion( DNCompleteEnumQuery );
	pAsyncOp->SetContext( pvContext );

	if (pParent)
	{
		pParent->Lock();
		if (pParent->IsCancelled())
		{
			pParent->Unlock();
			pAsyncOp->SetResult( DPNERR_USERCANCEL );
			hResultCode = DPNERR_USERCANCEL;
			goto Failure;
		}
		pAsyncOp->MakeChild(pParent);
		pParent->Unlock();
	}

	//
	//	Add to active AsyncOp list
	//
	DNEnterCriticalSection(&pdnObject->csActiveList);
	pAsyncOp->m_bilinkActiveList.InsertBefore(&pdnObject->m_bilinkActiveList);
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	//
	//	AddRef Protocol so that it won't go away until this completes
	//
	DNProtocolAddRef(pdnObject);

	pAsyncOp->AddRef();
	hResultCode = DNPEnumQuery(pdnObject->pdnProtocolData,
							   pHost,
							   pDevice,
							   hSPHandle,
							   rgdnBufferDesc,
							   cBufferDesc,
							   dwRetryCount,				// count of enumerations to send
							   dwRetryInterval,				// interval between enumerations
							   dwTimeOut,					// linger time after last enumeration is sent
							   dwFlags,
							   reinterpret_cast<void*>(pAsyncOp),
							   &hProtocol);
	if ( hResultCode != DPNERR_PENDING )
	{
		DPFERR( "Failed to start enuming!" );
		pAsyncOp->Release();
		DNProtocolRelease(pdnObject);
		goto Failure;
	}

	//
	//	Setup for proper clean-up
	//
	pAsyncOp->Lock();
	if (pAsyncOp->IsCancelled() && !pAsyncOp->IsComplete())
	{
		HRESULT		hrCancel;

		pAsyncOp->Unlock();
		DPFX(DPFPREP, 7,"Operation marked for cancel");
		if ((hrCancel = DNPCancelCommand(pdnObject->pdnProtocolData,hProtocol)) == DPN_OK)
		{
			hResultCode = DPNERR_USERCANCEL;
			goto Failure;
		}
		DPFERR("Could not cancel operation");
		DisplayDNError(0,hrCancel);
		pAsyncOp->Lock();
	}
	pAsyncOp->SetProtocolHandle( hProtocol );
	pAsyncOp->Unlock();

	pAsyncOp->Release();
	pAsyncOp = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pAsyncOp)
	{
		DNEnterCriticalSection(&pdnObject->csActiveList);
		pAsyncOp->m_bilinkActiveList.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csActiveList);
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	goto Exit;
}


//	DNPerformNextEnumQuery
//
//	This will attempt to perform the next ENUM if multiple adapters were requested

#undef DPF_MODNAME
#define DPF_MODNAME "DNPerformNextEnumQuery"

HRESULT DNPerformNextEnumQuery(DIRECTNETOBJECT *const pdnObject,
							   CAsyncOp *const pAsyncOp,
							   IDirectPlay8Address *const pHostAddr,
							   IDirectPlay8Address *const pDeviceAddr)
{
	HRESULT		hResultCode;
	CAsyncOp	*pParent;
	DN_ENUM_QUERY	*pEnumQuery;

	DPFX(DPFPREP, 6,"Parameters: pAsyncOp [0x%p], pHostAddr [0x%p], pDeviceAddr [0x%p]",pAsyncOp,pHostAddr,pDeviceAddr);

	pParent = NULL;

	pAsyncOp->Lock();
	if (pAsyncOp->GetParent())
	{
		pAsyncOp->GetParent()->AddRef();
		pParent = pAsyncOp->GetParent();
	}
	pAsyncOp->Unlock();

	//
	//	If there are any ENUMs left to perform, we will move on to the next one
	//
	if (pParent)
	{
		if (pParent->GetOpData())
		{
			pEnumQuery = static_cast<DN_ENUM_QUERY*>(pParent->GetOpData());
			if (pEnumQuery->dwCurrentAdapter < pEnumQuery->dwNumAdapters)
			{
				GUID	*pguid;
				DWORD	dwMultiplexFlag;

				pguid = reinterpret_cast<GUID*>(pEnumQuery + 1);
				pguid += pEnumQuery->dwCurrentAdapter;
				if ((hResultCode = pDeviceAddr->lpVtbl->SetDevice(pDeviceAddr,pguid)) != DPN_OK)
				{
					DPFERR("Could not set device for next adapter");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					goto Failure;
				}
				pEnumQuery->dwCurrentAdapter++;

				if (pEnumQuery->dwCurrentAdapter < pEnumQuery->dwNumAdapters)
				{
					dwMultiplexFlag |= DN_ENUMQUERYFLAGS_ADDITIONALMULTIPLEXADAPTERS;
				}
				else
				{
					dwMultiplexFlag = 0;
				}

				hResultCode = DNPerformEnumQuery(	pdnObject,
													pHostAddr,
													pDeviceAddr,
													pParent->GetSP()->GetHandle(),
													&pEnumQuery->BufferDesc[DN_ENUM_BUFFERDESC_QUERY_DN_PAYLOAD],
													pEnumQuery->dwBufferCount,
													pEnumQuery->dwRetryCount,
													pEnumQuery->dwRetryInterval,
													pEnumQuery->dwTimeOut,
													pParent->GetOpFlags() | dwMultiplexFlag,
													pParent->GetContext(),
													pParent );
				if (hResultCode != DPN_OK)
				{
					DPFERR("Could not start ENUM");
					DisplayDNError(0,hResultCode);
					goto Failure;
				}
			}
		}

		pParent->Release();
		pParent = NULL;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pParent)
	{
		pParent->Release();
		pParent = NULL;
	}
	goto Exit;
}


//	DNCompleteEnumQuery
//
//	Completion for AsyncOps for EnumQuery.
//	This will:
//		- free up the EnumQuery memory block associated with this AsyncOp

#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteEnumQuery"

void DNCompleteEnumQuery(DIRECTNETOBJECT *const pdnObject,
						 CAsyncOp *const pAsyncOp)
{
	DNASSERT(pdnObject != NULL);
	DNASSERT(pAsyncOp != NULL);

	if (pAsyncOp->GetOpData())
	{
		MemoryBlockFree(pdnObject,pAsyncOp->GetOpData());
		pAsyncOp->SetOpData( NULL );
	}

	if ( pAsyncOp->IsChild() )
	{
		DNASSERT(pAsyncOp->GetParent() != NULL);

		pAsyncOp->GetParent()->Lock();

		//
		//	Save HRESULT
		//
		if (pAsyncOp->GetParent()->GetResult() != DPN_OK)
		{
			pAsyncOp->GetParent()->SetResult( pAsyncOp->GetResult() );
		}

		//
		//	Release parent Handle if it exists
		//
		if (pAsyncOp->GetParent()->GetHandle() != 0)
		{
			pdnObject->HandleTable.Destroy( pAsyncOp->GetParent()->GetHandle() );
		}

		pAsyncOp->GetParent()->Unlock();
	}
}


//	DNCompleteEnumResponse
//
//	Completion for AsyncOps for EnumResponse.
//	This will:
//		- generate a RETURN_BUFFER message if there was a user payload
//		- free up the EnumResponse memory block associated with this AsyncOp

#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteEnumResponse"

void DNCompleteEnumResponse(DIRECTNETOBJECT *const pdnObject,
							CAsyncOp *const pAsyncOp)
{
	DNASSERT(pdnObject != NULL);
	DNASSERT(pAsyncOp != NULL);

	if (pAsyncOp->GetOpData())
	{
		DN_ENUM_RESPONSE	*pEnumResponse;

		//
		//	Was there a user payload on the response ?   If so, we'll need to
		//	generate a completion for the buffer.
		//
		pEnumResponse = static_cast<DN_ENUM_RESPONSE*>(pAsyncOp->GetOpData());
		if (pEnumResponse->BufferDesc[DN_ENUM_BUFFERDESC_RESPONSE_USER_PAYLOAD].pBufferData != NULL)
		{
			DNUserReturnBuffer(	pdnObject,
								DPN_OK,
								pEnumResponse->BufferDesc[DN_ENUM_BUFFERDESC_RESPONSE_USER_PAYLOAD].pBufferData,
								pEnumResponse->pvUserContext);
		}
		pEnumResponse = NULL;	// Not used any more

		MemoryBlockFree(pdnObject,pAsyncOp->GetOpData());
		pAsyncOp->SetOpData( NULL );
	}
}



//	DNPerformConnect
//
//	Initiate a connection and take care of the book keeping (create handle).
//
//	DPNID				dpnid				Target player (for ExistingPlayers connect calls)
//	IDirectPlayAddress8	*pDeviceInfo		(may be NULL - no connect performed)
//	IDirectPlayAddress8	*pRemoteAddr		(may be NULL - no connect performed)
//	DWORD				dwFlags				CONNECT op flags
//	CAsyncOp			*pParent			Parent Async Op (if it exists)

#undef DPF_MODNAME
#define DPF_MODNAME "DNPerformConnect"

HRESULT DNPerformConnect(DIRECTNETOBJECT *const pdnObject,
						 const DPNID dpnid,
						 IDirectPlay8Address *const pDeviceInfo,
						 IDirectPlay8Address *const pRemoteAddr,
						 CServiceProvider *const pSP,
						 const DWORD dwConnectFlags,
						 CAsyncOp *const pParent)
{
	HANDLE			hProtocol;
	HRESULT			hResultCode;
	CAsyncOp		*pAsyncOp;
#ifdef	DEBUG
	CHAR			DP8ABuffer[512];
	CHAR			DP8ABuffer2[512];
	DWORD			DP8ASize;
#endif

	DPFX(DPFPREP, 6,"Parameters: dpnid [0x%p], pDeviceInfo [0x%p], pRemoteAddr [0x%p], dwConnectFlags [0x%lx], pParent [0x%p]",
		dpnid,pDeviceInfo,pRemoteAddr,dwConnectFlags,pParent);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pDeviceInfo != NULL);
	DNASSERT(pRemoteAddr != NULL);
	DNASSERT(pSP != NULL);

	pAsyncOp = NULL;

#ifdef	DEBUG
	DP8ASize = 512;
	pRemoteAddr->lpVtbl->GetURLA(pRemoteAddr,DP8ABuffer,&DP8ASize);
	DPFX(DPFPREP, 7,"Remote Address [%s]",DP8ABuffer);
	DP8ASize = 512;
	pDeviceInfo->lpVtbl->GetURLA(pDeviceInfo,DP8ABuffer2,&DP8ASize);
	DPFX(DPFPREP, 7,"Device Info [%s]",DP8ABuffer2);
#endif

	//
	//	Create AsyncOp for CONNECT
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pAsyncOp)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pAsyncOp->SetOpType( ASYNC_OP_CONNECT );
	pAsyncOp->SetDPNID( dpnid );
	pAsyncOp->SetOpFlags( dwConnectFlags );
	pAsyncOp->SetSP(pSP);
	pAsyncOp->SetResult( DPNERR_NOCONNECTION );
	pAsyncOp->SetCompletion( DNCompleteConnect );

	if (pParent)
	{
		pParent->Lock();
		if (pParent->IsCancelled())
		{
			pParent->Unlock();
			pAsyncOp->SetResult( DPNERR_USERCANCEL );
			hResultCode = DPNERR_USERCANCEL;
			goto Failure;
		}
		pAsyncOp->MakeChild(pParent);
		pParent->Unlock();
	}

	//
	//	Add to active async op list
	//
	DNEnterCriticalSection(&pdnObject->csActiveList);
	pAsyncOp->m_bilinkActiveList.InsertBefore(&pdnObject->m_bilinkActiveList);
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	//
	//	AddRef Protocol so that it won't go away until this completes
	//
	DNProtocolAddRef(pdnObject);

	//
	//	Perform CONNECT
	//
	DPFX(DPFPREP, 7,"Performing connect");
	pAsyncOp->AddRef();
	hResultCode = DNPConnect(	pdnObject->pdnProtocolData,
								pDeviceInfo,
								pRemoteAddr,
								pSP->GetHandle(),
								dwConnectFlags,
								pAsyncOp,
								&hProtocol);
	if (hResultCode != DPNERR_PENDING)
	{
		DPFERR("Could not CONNECT");
		DisplayDNError(0,hResultCode);
		pAsyncOp->Release();
		DNProtocolRelease(pdnObject);
		goto Failure;
	}

	pAsyncOp->Lock();
	if (pAsyncOp->IsCancelled() && !pAsyncOp->IsComplete())
	{
		HRESULT		hrCancel;

		pAsyncOp->Unlock();
		DPFX(DPFPREP, 7,"Operation marked for cancel");
		if ((hrCancel = DNPCancelCommand(pdnObject->pdnProtocolData,hProtocol)) == DPN_OK)
		{
			hResultCode = DPNERR_USERCANCEL;
			goto Failure;
		}
		DPFERR("Could not cancel operation");
		DisplayDNError(0,hrCancel);
		pAsyncOp->Lock();
	}
	pAsyncOp->SetProtocolHandle(hProtocol);
	pAsyncOp->Unlock();

	pAsyncOp->Release();
	pAsyncOp = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pAsyncOp)
	{
		DNEnterCriticalSection(&pdnObject->csActiveList);
		pAsyncOp->m_bilinkActiveList.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csActiveList);
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	goto Exit;
}


//	DNPerformNextConnect
//
//	This will attempt to perform the next CONNECT if multiple adapters were requested

#undef DPF_MODNAME
#define DPF_MODNAME "DNPerformNextConnect"

HRESULT DNPerformNextConnect(DIRECTNETOBJECT *const pdnObject,
							 CAsyncOp *const pAsyncOp,
							 IDirectPlay8Address *const pHostAddr,
							 IDirectPlay8Address *const pDeviceAddr)
{
	HRESULT		hResultCode;
	CAsyncOp	*pParent;
	DN_CONNECT_OP_DATA	*pConnectOpData;

	DPFX(DPFPREP, 6,"Parameters: pAsyncOp [0x%p], pHostAddr [0x%p], pDeviceAddr [0x%p]",pAsyncOp,pHostAddr,pDeviceAddr);

	pParent = NULL;

	pAsyncOp->Lock();
	if (pAsyncOp->GetParent())
	{
		pAsyncOp->GetParent()->AddRef();
		pParent = pAsyncOp->GetParent();
	}
	pAsyncOp->Unlock();

	//
	//	If there are any CONNECTs left to perform, we will move on to the next one
	//
	if (pParent)
	{
		if (pParent->GetOpData())
		{
			pConnectOpData = static_cast<DN_CONNECT_OP_DATA*>(pParent->GetOpData());
			if (pConnectOpData->dwCurrentAdapter < pConnectOpData->dwNumAdapters)
			{
				GUID	*pguid;
				DWORD	dwMultiplexFlag;

				pguid = reinterpret_cast<GUID*>(pConnectOpData + 1);
				pguid += pConnectOpData->dwCurrentAdapter;
				if ((hResultCode = pDeviceAddr->lpVtbl->SetDevice(pDeviceAddr,pguid)) != DPN_OK)
				{
					DPFERR("Could not set device for next adapter");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					goto Failure;
				}
				pConnectOpData->dwCurrentAdapter++;

				if (pConnectOpData->dwCurrentAdapter < pConnectOpData->dwNumAdapters)
				{
					dwMultiplexFlag |= DN_CONNECTFLAGS_ADDITIONALMULTIPLEXADAPTERS;
				}
				else
				{
					dwMultiplexFlag = 0;
				}
				
				DNASSERT(pParent != NULL);

				hResultCode = DNPerformConnect(	pdnObject,
												NULL,
												pDeviceAddr,
												pHostAddr,
												pParent->GetSP(),
												pParent->GetOpFlags() | dwMultiplexFlag,
												pParent);
				if (hResultCode != DPN_OK)
				{
					DPFERR("Could not perform CONNECT");
					DisplayDNError(0,hResultCode);
					goto Failure;
				}
			}
		}

		pParent->Release();
		pParent = NULL;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pParent)
	{
		pParent->Release();
		pParent = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteConnect"

void DNCompleteConnect(DIRECTNETOBJECT *const pdnObject,
					   CAsyncOp *const pAsyncOp)
{
	//
	//	Save the result code on the parent if it hasn't already been set (DPN_OK or DPNERR_HOSTREJECTEDCONNECTION)
	//
	if (pAsyncOp->GetParent() && (pAsyncOp->GetResult() != DPNERR_NOCONNECTION))
	{
		pAsyncOp->GetParent()->Lock();
		if ((pAsyncOp->GetParent()->GetResult() != DPN_OK)
				&& (pAsyncOp->GetParent()->GetResult() != DPNERR_HOSTREJECTEDCONNECTION))
		{
			pAsyncOp->GetParent()->SetResult( pAsyncOp->GetResult() );
		}
		pAsyncOp->GetParent()->Unlock();
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteConnectToHost"

void DNCompleteConnectToHost(DIRECTNETOBJECT *const pdnObject,
							 CAsyncOp *const pAsyncOp)
{
	//
	//	Save the result code on the parent if there was a problem (this should be the connect operation parent)
	//
	if ((pAsyncOp->GetResult() != DPN_OK) && (pAsyncOp->GetResult() != DPNERR_NOCONNECTION))
	{
		if (pAsyncOp->GetParent())
		{
			pAsyncOp->GetParent()->Lock();
			if ((pAsyncOp->GetParent()->GetResult() != DPN_OK) && (pAsyncOp->GetParent()->GetResult() != DPNERR_HOSTREJECTEDCONNECTION))
			{
				pAsyncOp->GetParent()->SetResult( pAsyncOp->GetResult() );
			}
			pAsyncOp->GetParent()->Unlock();
		}
	}

	//
	//	Clean up DirectNet object if this fails
	//
	if (pAsyncOp->GetResult() != DPN_OK)
	{
		CAsyncOp	*pConnectParent;

		pConnectParent = NULL;

		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		pdnObject->dwFlags &= (~(DN_OBJECT_FLAG_CONNECTED|DN_OBJECT_FLAG_CONNECTING|DN_OBJECT_FLAG_HOST_CONNECTED));
		if (pdnObject->pConnectParent)
		{
			pConnectParent = pdnObject->pConnectParent;
			pdnObject->pConnectParent = NULL;
		}
		if( pdnObject->pIDP8ADevice )
		{
			pdnObject->pIDP8ADevice->lpVtbl->Release( pdnObject->pIDP8ADevice );
			pdnObject->pIDP8ADevice = NULL;
		}
		if( pdnObject->pConnectAddress )
		{
			pdnObject->pConnectAddress->lpVtbl->Release( pdnObject->pConnectAddress );
			pdnObject->pConnectAddress = NULL;
		}
		if( pdnObject->pConnectSP )
		{
			pdnObject->pConnectSP->Release();
			pdnObject->pConnectSP = NULL;
		}
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

		if (pConnectParent)
		{
			pConnectParent->Release();
			pConnectParent = NULL;
		}

		DNASSERT(pConnectParent == NULL);
	}

	//
	//	Clean up CONNECT op data
	//
	if (pAsyncOp->GetOpData() != NULL)
	{
		MemoryBlockFree(pdnObject,pAsyncOp->GetOpData());
		pAsyncOp->SetOpData( NULL );
	}

	//
	//	Detach from parent
	//	I'm not sure why we need to do this !
	//
	DNASSERT(pAsyncOp->IsChild());
	DNASSERT(pAsyncOp->GetParent());
	pAsyncOp->Orphan();
}


//
//	Completion for connect parent
//
#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteConnectOperation"

void DNCompleteConnectOperation(DIRECTNETOBJECT *const pdnObject,
								CAsyncOp *const pAsyncOp)
{
	//
	//	Save the result code on the parent (if it exists - it will be the CONNECT handle)
	//
	if (pAsyncOp->GetParent())
	{
		pAsyncOp->GetParent()->Lock();
		pAsyncOp->GetParent()->SetResult( pAsyncOp->GetResult() );
		pAsyncOp->GetParent()->SetRefCountBuffer( pAsyncOp->GetRefCountBuffer() );
		pAsyncOp->GetParent()->Unlock();

		if (pAsyncOp->GetParent()->GetHandle() != 0)
		{
			pdnObject->HandleTable.Destroy(pAsyncOp->GetParent()->GetHandle());
		}
	}

	//
	//	If the OpData of this AsyncOp is set it is a pointer to a RefCountBuffer pointer
	//	(sync connect call) and we will fill it in
	//
	if (pAsyncOp->GetOpData() && pAsyncOp->GetRefCountBuffer())
	{
		pAsyncOp->GetRefCountBuffer()->AddRef();
		*(static_cast<CRefCountBuffer**>(pAsyncOp->GetOpData())) = pAsyncOp->GetRefCountBuffer();
	}

	//
	//	If this connect succeeded, we will inform the lobby
	//
	if (pAsyncOp->GetResult() == DPN_OK)
	{
		DNUpdateLobbyStatus(pdnObject,DPLSESSION_CONNECTED);
	}
	else
	{
		DNUpdateLobbyStatus(pdnObject,DPLSESSION_COULDNOTCONNECT);
	}

	//
	//	Clear DISCONNECTING flag (in case this was aborted)
	//
	DPFX(DPFPREP, 8,"Clearing DISCONNECTING flag");
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->dwFlags &= (~DN_OBJECT_FLAG_DISCONNECTING);
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
}


//
//	Completion for connect handle given to user if Connect was called asynchronously
//
#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteUserConnect"

void DNCompleteUserConnect(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp *const pAsyncOp)
{
	CNameTableEntry	*pHostPlayer;

	pHostPlayer = NULL;

	//
	//	No longer connecting
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->dwFlags &= (~DN_OBJECT_FLAG_CONNECTING);
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Clients need to release all sends from the server that are
	//	queued once the CONNECT_COMPLETE gets indicated.
	//	We prepare to do that now.
	//
	if ((pAsyncOp->GetResult() == DPN_OK) && (pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT))
	{
		if (pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer ) == DPN_OK)
		{
			pHostPlayer->Lock();
			pHostPlayer->MakeAvailable();
			pHostPlayer->NotifyAddRef();
			pHostPlayer->SetInUse();
			pHostPlayer->Unlock();

			//
			//	We are now connected
			//
			DNEnterCriticalSection(&pdnObject->csDirectNetObject);
			pdnObject->dwFlags |= DN_OBJECT_FLAG_CONNECTED;
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		}
		else
		{
			//
			//	If we couldn't get a reference on the server (host player),
			//	then either the server has disconnected, or we are being shut down.
			//	In either case, we should return an error
			//
			DPFX(DPFPREP, 0, "Couldn't get host player reference, failing CONNECT!");
			pAsyncOp->SetResult( DPNERR_NOCONNECTION );
			if (pAsyncOp->GetRefCountBuffer())
			{
				pAsyncOp->GetRefCountBuffer()->Release();
				pAsyncOp->SetRefCountBuffer( NULL );
			}
		}
	}

	//
	//	Generate connect completion for player
	//
	DNUserConnectComplete(	pdnObject,
							pAsyncOp->GetHandle(),
							pAsyncOp->GetContext(),
							pAsyncOp->GetResult(),
							pAsyncOp->GetRefCountBuffer() );

	//
	//	Cancel ENUMs if the CONNECT succeeded and unload SP's
	//
	if (pAsyncOp->GetResult() == DPN_OK)
	{
		DNCancelActiveCommands(pdnObject,DN_CANCEL_FLAG_ENUM_QUERY,TRUE,DPNERR_CONNECTING);

		DN_SPReleaseAll(pdnObject);

		
		//
		//	Actually release queued messages if necessary
		//
		if (pHostPlayer != NULL)
		{
			pHostPlayer->PerformQueuedOperations();

			pHostPlayer->Release();
			pHostPlayer = NULL;
		}
	}

	DNASSERT( pHostPlayer == NULL );
}


//
//	Completion for NewPlayer sending connect data to the Host
//

#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteSendConnectInfo"

void DNCompleteSendConnectInfo(DIRECTNETOBJECT *const pdnObject,
							   CAsyncOp *const pAsyncOp)
{
	//
	//	Update result of this send on the CONNECT operation parent
	//
	DNASSERT(pAsyncOp->GetParent() != NULL);
	pAsyncOp->GetParent()->Lock();
	if (pAsyncOp->GetResult() != DPN_OK)
	{
		pAsyncOp->GetParent()->SetResult( pAsyncOp->GetResult() );
		//
		//	Clean up CONNECT response buffer from Host
		//
		if (pAsyncOp->GetParent()->GetRefCountBuffer())
		{
			pAsyncOp->GetParent()->GetRefCountBuffer()->Release();
			pAsyncOp->GetParent()->SetRefCountBuffer( NULL );
		}
	}
	pAsyncOp->GetParent()->Unlock();

	//
	//	Clean up DirectNet object if this fails
	//
	if (pAsyncOp->GetResult() != DPN_OK)
	{
		CAsyncOp	*pConnectParent;

		pConnectParent = NULL;

		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		pdnObject->dwFlags &= (~(DN_OBJECT_FLAG_CONNECTED|DN_OBJECT_FLAG_CONNECTING|DN_OBJECT_FLAG_HOST_CONNECTED));
		if (pdnObject->pConnectParent)
		{
			pConnectParent = pdnObject->pConnectParent;
			pdnObject->pConnectParent = NULL;
		}
		if( pdnObject->pIDP8ADevice )
		{
			pdnObject->pIDP8ADevice->lpVtbl->Release( pdnObject->pIDP8ADevice );
			pdnObject->pIDP8ADevice = NULL;
		}
		if( pdnObject->pConnectAddress )
		{
			pdnObject->pConnectAddress->lpVtbl->Release( pdnObject->pConnectAddress );
			pdnObject->pConnectAddress = NULL;
		}
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

		if (pConnectParent)
		{
			pConnectParent->Release();
			pConnectParent = NULL;
		}

		DNASSERT(pConnectParent == NULL);
	}

	//
	//	Clean up op data
	//
	if (pAsyncOp->GetOpData())
	{
		MemoryBlockFree(pdnObject,pAsyncOp->GetOpData());
		pAsyncOp->SetOpData( NULL );
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPerformDisconnect"

HRESULT DNPerformDisconnect(DIRECTNETOBJECT *const pdnObject,
							CConnection *const pConnection,
							const HANDLE hEndPt)
{
	HRESULT		hResultCode;
	HANDLE		hProtocol;
	CAsyncOp	*pAsyncOp;
	CAsyncOp	*pConnectParent;

	DPFX(DPFPREP, 6,"Parameters: pConnection [0x%p]",pConnection);

	DNASSERT(pdnObject != NULL);

	pAsyncOp = NULL;
	pConnectParent = NULL;

	if (hEndPt == NULL)
	{
		DPFERR("Ignoring NULL endpoint");
		hResultCode = DPN_OK;
		goto Failure;
	}

	//
	//	Create AsyncOp for this operation
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pAsyncOp)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pAsyncOp->SetOpType( ASYNC_OP_DISCONNECT );
	pAsyncOp->SetConnection( pConnection );
	pAsyncOp->SetCannotCancel();	// Cannot cancel DISCONNECT's

	//
	//	AddRef Protocol so that it won't go away until this completes
	//
	DNProtocolAddRef(pdnObject);

	//
	//	If there is a connect parent op, and it's hResultCode is not DPN_OK,
	//	then a connect is failing for some reason, and to prevent it from
	//	completing before this disconnect is complete, we will set the connect parent
	//	as the parent of this disconnect.
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->pConnectParent && (pdnObject->pConnectParent->GetResult() != DPN_OK))
	{
		pdnObject->pConnectParent->AddRef();
		pConnectParent = pdnObject->pConnectParent;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	if (pConnectParent)
	{
		pAsyncOp->MakeChild( pConnectParent );
		pConnectParent->Release();
		pConnectParent = NULL;
	}

	//
	//	Set connection as INVALID so that no other operations may use it anymore
	//
	pConnection->Lock();
	pConnection->SetStatus( INVALID );
	pConnection->Unlock();

	//
	//	Perform DISCONNECT
	//
	pAsyncOp->AddRef();
	hResultCode = DNPDisconnectEndPoint(pdnObject->pdnProtocolData,
										hEndPt,
										static_cast<void*>(pAsyncOp),
										&hProtocol);
	if ((hResultCode != DPN_OK) && (hResultCode != DPNERR_PENDING))
	{
		DPFERR("Could not issue DISCONNECT");
		DisplayDNError(0,hResultCode);
		DNProtocolRelease(pdnObject);
		pAsyncOp->Release();
		goto Failure;
	}

	pAsyncOp->Lock();
	pAsyncOp->SetProtocolHandle( hProtocol );
	pAsyncOp->Unlock();

	pAsyncOp->Release();
	pAsyncOp = NULL;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pAsyncOp)
	{
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	if (pConnectParent)
	{
		pConnectParent->Release();
		pConnectParent = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteAsyncHandle"

void DNCompleteAsyncHandle(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp *const pAsyncOp)
{
	DNASSERT(pdnObject != NULL);
	DNASSERT(pAsyncOp != NULL);

	DNUserAsyncComplete(pdnObject,
						pAsyncOp->GetHandle(),
						pAsyncOp->GetContext(),
						pAsyncOp->GetResult() );
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteSendHandle"

void DNCompleteSendHandle(DIRECTNETOBJECT *const pdnObject,
						  CAsyncOp *const pAsyncOp)
{
	DNASSERT(pdnObject != NULL);
	DNASSERT(pAsyncOp != NULL);

	DNUserSendComplete(	pdnObject,
						pAsyncOp->GetHandle(),
						pAsyncOp->GetContext(),
						pAsyncOp->GetStartTime(),
						pAsyncOp->GetResult() );
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteSendAsyncOp"

void DNCompleteSendAsyncOp(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp *const pAsyncOp)
{
	DNASSERT(pdnObject != NULL);
	DNASSERT(pAsyncOp != NULL);

	//
	//	Update outstanding queue info - this is only performed on children or stand-alone ops (i.e. no parent)
	//
	if ( !pAsyncOp->IsParent() && (pAsyncOp->GetConnection() != NULL))
	{
		DN_SEND_OP_DATA	*pSendOpData;

		pSendOpData = NULL;
		if (pAsyncOp->GetOpData())
		{
			pSendOpData = static_cast<DN_SEND_OP_DATA*>(pAsyncOp->GetOpData());
		}
		else
		{
			if (pAsyncOp->IsChild() && pAsyncOp->GetParent())
			{
				if (pAsyncOp->GetParent()->GetOpData())
				{
					pSendOpData = static_cast<DN_SEND_OP_DATA*>(pAsyncOp->GetParent()->GetOpData());
				}
			}
		}

		if (pSendOpData && pSendOpData->dwMsgId == DN_MSG_USER_SEND)
		{
			pAsyncOp->GetConnection()->Lock();
			if (pAsyncOp->GetOpFlags() & DN_SENDFLAGS_HIGH_PRIORITY)
			{
				pAsyncOp->GetConnection()->RemoveFromHighQueue( pSendOpData->BufferDesc[0].dwBufferSize );
			}
			else if (pAsyncOp->GetOpFlags() & DN_SENDFLAGS_LOW_PRIORITY)
			{
				pAsyncOp->GetConnection()->RemoveFromLowQueue( pSendOpData->BufferDesc[0].dwBufferSize );
			}
			else
			{
				pAsyncOp->GetConnection()->RemoveFromNormalQueue( pSendOpData->BufferDesc[0].dwBufferSize );
			}
			pAsyncOp->GetConnection()->Unlock();
		}
	}

	//
	//	Clean up
	//
	if (pAsyncOp->GetOpData())
	{
		MemoryBlockFree(pdnObject,pAsyncOp->GetOpData());
	}

	if ( pAsyncOp->IsChild() )
	{
		DNASSERT(pAsyncOp->GetParent() != NULL);

		pAsyncOp->GetParent()->Lock();

		//
		//	Save HRESULT.  Overwrite the parent's error while it's not DPN_OK.
		//
		if (pAsyncOp->GetParent()->GetResult() != DPN_OK)
		{
			pAsyncOp->GetParent()->SetResult( pAsyncOp->GetResult() );
		}

		//
		//	Release parent Handle if it exists
		//
		if ((pAsyncOp->GetParent()->GetOpType() == ASYNC_OP_USER_HANDLE) && (pAsyncOp->GetParent()->GetHandle() != 0))
		{
			pdnObject->HandleTable.Destroy( pAsyncOp->GetParent()->GetHandle() );
		}

		pAsyncOp->GetParent()->Unlock();
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteRequest"

void DNCompleteRequest(DIRECTNETOBJECT *const pdnObject,
					   CAsyncOp *const pAsyncOp)
{
	DNASSERT(pdnObject != NULL);
	DNASSERT(pAsyncOp != NULL);

	//
	//	Clean up op data
	//
	if (pAsyncOp->GetOpData() != NULL)
	{
		MemoryBlockFree(pdnObject,pAsyncOp->GetOpData());
		pAsyncOp->SetOpData( NULL );
	}

	//
	//	If the parent exists, copy the result up, and then remove them from the HandleTable
	//
	if (pAsyncOp->GetParent() != NULL)
	{
		pAsyncOp->GetParent()->Lock();
		pAsyncOp->GetParent()->SetResult( pAsyncOp->GetResult() );
		pAsyncOp->GetParent()->Unlock();

		if (pAsyncOp->GetParent()->GetHandle() != 0)
		{
			pdnObject->HandleTable.Destroy( pAsyncOp->GetParent()->GetHandle() );
		}
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteSendRequest"

void DNCompleteSendRequest(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp *const pAsyncOp)
{
	DNASSERT(pdnObject != NULL);
	DNASSERT(pAsyncOp != NULL);

	DNASSERT(pAsyncOp->GetParent() != NULL);
	if (pAsyncOp->GetResult() != DPN_OK)
	{
		//
		//	If this operation was cancelled or was NOT internal (i.e. complete on process send)
		//	remove the parent (RequestChild) AsyncOp from the HandleTable and from the request list
		//
		if ((pAsyncOp->GetResult() == DPNERR_USERCANCEL) || !pAsyncOp->IsInternal())
		{
			DNASSERT(pAsyncOp->GetParent()->GetHandle() != 0);
			DNASSERT(pAsyncOp->GetParent()->GetOpType() == ASYNC_OP_REQUEST);
			DNEnterCriticalSection(&pdnObject->csActiveList);
			pAsyncOp->GetParent()->m_bilinkActiveList.RemoveFromList();
			DNLeaveCriticalSection(&pdnObject->csActiveList);

			pdnObject->HandleTable.Destroy( pAsyncOp->GetParent()->GetHandle() );
		}
	}
	else
	{
		//
		//	Mark this operation as PLAYERLOST. If we do get an operation complete message,
		//	this result will get overwritten.
		//
		pAsyncOp->GetParent()->Lock();
		if (pAsyncOp->GetParent()->GetResult() == DPNERR_GENERIC)
		{
			pAsyncOp->GetParent()->SetResult( DPNERR_PLAYERLOST );
		}
		pAsyncOp->GetParent()->Unlock();
	}

//	DNCompleteSendAsyncOp(pdnObject,pAsyncOp);
}


//	DNSendMessage
//
//	Send structured message to given endpoint.  Internally generated sends have a header
//	associated with them.  The first few bytes of this header are a signature, indicating
//	an internal message.  User generated sends do not have a header, unless they contain
//	the signature.  In this case, the user message is escaped with a header indicating this.
//
//	For internal sends:
//	- Create message header (dwMsgId,dwParam1,dwParam2)
//	- Send message header and supplied data buffer (lpBuffDesc)
//	- Save Async Operation info to be unwound when send completes
//	- If pdnCountBuffer is specified, pBuffDesc may or may not point to its contents.
//
//	CConnection		*pConnection	Connection to send to
//	DWORD			uMsgId			Message ID
//	DNID			dnidTarget		DNID of target of this send (may be NULL)
//	DPN_BUFFER_DESC	*pBuffDesc		Pointer to array (1 or 2) buffer descriptors
//	CRefCountBuffer	*pRefCountBuffer RefCountBuffer to be AddRef'd and released on complete (may be NULL)
//	DWORD			dwTimeOut		Time Out
//	DWORD			dwSendFlags		Send flags
//	CAsyncOp		**ppAsyncOp		AsyncOp for this SEND (will be AddRef'd before returned)

#undef DPF_MODNAME
#define DPF_MODNAME "DNSendMessage"

HRESULT DNSendMessage(DIRECTNETOBJECT *const pdnObject,
					  CConnection *const pConnection,
					  const DWORD dwMsgId,
					  const DPNID dpnidTarget,
					  const DPN_BUFFER_DESC *const pdnBufferDesc,
					  CRefCountBuffer *const pRefCountBuffer,
					  const DWORD dwTimeOut,
					  const DWORD dwSendFlags,
					  CAsyncOp *const pParent,
					  CAsyncOp **const ppAsyncOp)
{
	HANDLE			hProtocol;
	HRESULT			hResultCode;
	HANDLE			hEndPt;
	CAsyncOp		*pAsyncOp;
	void			*pvBlock;
	DN_SEND_OP_DATA	*pSendOpData;
	CCallbackThread	CallbackThread;


	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP, 6,"Parameters: pConnection [0x%p], dwMsgId [0x%x], dpnidTarget [0x%x], pRefCountBuffer [0x%p], pdnBufferDesc [0x%p], dwTimeOut [%ld], dwSendFlags [0x%lx], ppAsyncOp [0x%p]",
		pConnection,dwMsgId,dpnidTarget,pRefCountBuffer,pdnBufferDesc,dwTimeOut,dwSendFlags,ppAsyncOp);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pConnection != NULL);

	pAsyncOp = NULL;
	pvBlock = NULL;

	//
	//	Create AsyncOp for SEND
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pAsyncOp)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pAsyncOp->SetOpType( ASYNC_OP_SEND );
	pAsyncOp->SetDPNID( dpnidTarget );
	pAsyncOp->SetRefCountBuffer( pRefCountBuffer );
	pAsyncOp->SetStartTime( GETTIMESTAMP() );
	if (dwMsgId & DN_MSG_INTERNAL)
	{
		//
		//	We have to set this early (before it's in the active list or a child) so that it won't
		//	be prematurely cancelled (before we get a chance to mark it INTERNAL).
		//
		pAsyncOp->SetInternal();
	}

	//
	//	Make child if parent was supplied
	//
	if (pParent)
	{
		pParent->Lock();
		if (pParent->IsCancelled())
		{
			pParent->Unlock();
			pAsyncOp->SetResult( DPNERR_USERCANCEL );
			hResultCode = DPNERR_USERCANCEL;
			goto Failure;
		}
		pAsyncOp->MakeChild( pParent );
		pParent->Unlock();
	}

	//
	//	Add to active async op list
	//
	DNEnterCriticalSection(&pdnObject->csActiveList);
	pAsyncOp->m_bilinkActiveList.InsertBefore(&pdnObject->m_bilinkActiveList);
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	//
	//	Set-up SEND op data block
	//
	if ((pvBlock = MemoryBlockAlloc(pdnObject,sizeof(DN_SEND_OP_DATA))) == NULL)
	{
		DPFERR("Could not allocate memory block");
		DNASSERT(FALSE);
		hResultCode = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	pAsyncOp->SetOpData( pvBlock );

	pSendOpData = static_cast<DN_SEND_OP_DATA*>(pvBlock);
	pSendOpData->dwMsgId = dwMsgId;
	if (dwMsgId & DN_MSG_INTERNAL)
	{
		if (dwMsgId == DN_MSG_INTERNAL_VOICE_SEND)
		{
			DNASSERT(pdnBufferDesc != NULL);
			pSendOpData->BufferDesc[0].pBufferData = pdnBufferDesc->pBufferData;
			pSendOpData->BufferDesc[0].dwBufferSize = pdnBufferDesc->dwBufferSize;
			pSendOpData->BufferDesc[1].pBufferData = NULL;
			pSendOpData->BufferDesc[1].dwBufferSize = 0;
			pSendOpData->dwNumBuffers = 1;

			pAsyncOp->SetOpFlags( dwSendFlags | DN_SENDFLAGS_SET_USER_FLAG | DN_SENDFLAGS_SET_USER_FLAG_TWO );
		}
		else
		{
			pSendOpData->BufferDesc[0].pBufferData = reinterpret_cast<BYTE*>( &(pSendOpData->dwMsgId) );
			pSendOpData->BufferDesc[0].dwBufferSize = sizeof( DWORD );
			if (pdnBufferDesc)
			{
				pSendOpData->BufferDesc[1].pBufferData = pdnBufferDesc->pBufferData;
				pSendOpData->BufferDesc[1].dwBufferSize = pdnBufferDesc->dwBufferSize;
				pSendOpData->dwNumBuffers = 2;
			}
			else
			{
				pSendOpData->BufferDesc[1].pBufferData = NULL;
				pSendOpData->BufferDesc[1].dwBufferSize = 0;
				pSendOpData->dwNumBuffers = 1;
			}

			pAsyncOp->SetOpFlags( dwSendFlags | DN_SENDFLAGS_SET_USER_FLAG );
		}
	}
	else
	{
		DNASSERT(pdnBufferDesc != NULL);
		pSendOpData->BufferDesc[0].pBufferData = pdnBufferDesc->pBufferData;
		pSendOpData->BufferDesc[0].dwBufferSize = pdnBufferDesc->dwBufferSize;
		pSendOpData->BufferDesc[1].pBufferData = NULL;
		pSendOpData->BufferDesc[1].dwBufferSize = 0;
		pSendOpData->dwNumBuffers = 1;

		pAsyncOp->SetOpFlags( dwSendFlags );

		//
		//	Update outstanding queue info - this will get cleaned up by the completion
		//
		pConnection->Lock();
		if (dwSendFlags & DN_SENDFLAGS_HIGH_PRIORITY)
		{
			pConnection->AddToHighQueue( pdnBufferDesc->dwBufferSize );
		}
		else if (dwSendFlags & DN_SENDFLAGS_LOW_PRIORITY)
		{
			pConnection->AddToLowQueue( pdnBufferDesc->dwBufferSize );
		}
		else
		{
			pConnection->AddToNormalQueue( pdnBufferDesc->dwBufferSize );
		}
		pConnection->Unlock();
	}

	if ((hResultCode = pConnection->GetEndPt(&hEndPt,&CallbackThread)) != DPN_OK)
	{
		DPFERR("Could not get end point from connection");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_CONNECTIONLOST;	// re-map this
		goto Failure;
	}
	pAsyncOp->SetConnection( pConnection );

	if (hEndPt == NULL)		//	Message for local player - Put on local message queue
	{
		//
		//	INTERNAL Message
		//
		DPFX(DPFPREP, 5,"INTERNAL Message");

		//
		//	AddRef Protocol as SendComplete will release this reference
		//
		DNProtocolAddRef(pdnObject);

		pAsyncOp->AddRef();
		hResultCode = DNWTSendInternal(	pdnObject,
										&pSendOpData->BufferDesc[0],
										pAsyncOp );

		pConnection->ReleaseEndPt(&CallbackThread);

		DNASSERT( hResultCode == DPNERR_PENDING );
	}
	else
	{
		//
		//	EXTERNAL Message
		//
		DPFX(DPFPREP, 5,"EXTERNAL Message");

		//
		//	AddRef Protocol so that it won't go away until this completes
		//
		DNProtocolAddRef(pdnObject);

		pAsyncOp->AddRef();
		hResultCode = DNPSendData(	pdnObject->pdnProtocolData,
									hEndPt,
									pSendOpData->dwNumBuffers,
									&pSendOpData->BufferDesc[0],
									dwTimeOut,
									pAsyncOp->GetOpFlags(),
									reinterpret_cast<void*>(pAsyncOp),
									&hProtocol);

		pConnection->ReleaseEndPt(&CallbackThread);

		if (hResultCode != DPNERR_PENDING)
		{
			DPFERR("Could not send data");
			DisplayDNError(0,hResultCode);
			pAsyncOp->Release();
			DNProtocolRelease(pdnObject);
			goto Failure;
		}

		pAsyncOp->Lock();
		if (pAsyncOp->IsCancelled() && !pAsyncOp->IsComplete())
		{
			HRESULT		hrCancel;

			pAsyncOp->Unlock();
			DPFX(DPFPREP, 7,"Operation marked for cancel");
			if ((hrCancel = DNPCancelCommand(pdnObject->pdnProtocolData,hProtocol)) == DPN_OK)
			{
				hResultCode = DPNERR_USERCANCEL;
				goto Failure;
			}
			DPFERR("Could not cancel operation");
			DisplayDNError(0,hrCancel);
			pAsyncOp->Lock();
		}
		pAsyncOp->SetProtocolHandle( hProtocol );
		pAsyncOp->Unlock();
	}

	if (hResultCode == DPNERR_PENDING)
	{
		//
		//	Completion
		//
		pAsyncOp->SetCompletion( DNCompleteSendAsyncOp );
		pvBlock = NULL;		// Completion will clean this up

		if (ppAsyncOp != NULL)
		{
			pAsyncOp->AddRef();
			*ppAsyncOp = pAsyncOp;
		}
	}

	pAsyncOp->Release();
	pAsyncOp = NULL;

Exit:
	// Temporary debugging purposes only, shouldn't be checked in!
#if	0
	DNMemoryTrackingValidateMemory();
#endif

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pAsyncOp)
	{
		DNEnterCriticalSection(&pdnObject->csActiveList);
		pAsyncOp->m_bilinkActiveList.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csActiveList);
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	if (pvBlock)
	{
		MemoryBlockFree(pdnObject,pvBlock);
		pvBlock = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNSendGroupMessage"

HRESULT DNSendGroupMessage(DIRECTNETOBJECT *const pdnObject,
						   CNameTableEntry *const pGroup,
						   const DWORD dwMsgId,
						   const DPN_BUFFER_DESC *const pdnBufferDesc,
						   CRefCountBuffer *const pRefCountBuffer,
						   const DWORD dwTimeOut,
						   const DWORD dwSendFlags,
						   const BOOL fNoLoopBack,
						   const BOOL fRequest,
						   CAsyncOp *const pParent,
						   CAsyncOp **const ppGroupSendParent)
{
	HRESULT		hResultCode;
	CAsyncOp	*pAsyncOp;
	CAsyncOp	*pGroupSendParent;
	CBilink		*pBilink;
	CConnection	*pConnection;
	CGroupConnection	*pGroupConnection;
	DN_GROUP_SEND_OP	*pSendOp;
	DN_GROUP_SEND_OP	*pTemp;
	DPNID				dpnidLocalPlayer;

	DPFX(DPFPREP, 4,"Parameters: pGroup [0x%p], dwMsgId [0x%lx], pdnBufferDesc [0x%p], pRefCountBuffer [0x%p], dwTimeOut [%ld], dwSendFlags [0x%lx], fNoLoopBack [%ld], fRequest [%ld], pParent [0x%p], ppGroupSendParent [0x%p]",
			pGroup,dwMsgId,pdnBufferDesc,pRefCountBuffer,dwTimeOut,dwSendFlags,fNoLoopBack,fRequest,pParent,ppGroupSendParent);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pGroup != NULL);

	pAsyncOp = NULL;
	pGroupSendParent = NULL;
	pConnection = NULL;
	pGroupConnection = NULL;

	if (fNoLoopBack)
	{
		CNameTableEntry		*pLocalPlayer;

		pLocalPlayer = NULL;
		if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
		{
			DPFERR("Could not get local player reference");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
		dpnidLocalPlayer = pLocalPlayer->GetDPNID();
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	else
	{
		dpnidLocalPlayer = 0;
	}

	//
	//	Create group send target list
	//
	pSendOp = NULL;
	pGroup->Lock();
	pBilink = pGroup->m_bilinkConnections.GetNext();
	while (pBilink != &pGroup->m_bilinkConnections)
	{
		pGroupConnection = CONTAINING_OBJECT(pBilink,CGroupConnection,m_bilink);
		if ((hResultCode = pGroupConnection->GetConnectionRef( &pConnection )) == DPN_OK)
		{
			//
			//	We will only use CONNECTED connections (not CONNECTING,DISCONNECTING, or INVALID ones)
			//
			if (pConnection->IsConnected())
			{
				if ((!fNoLoopBack) || (pConnection->GetDPNID() != dpnidLocalPlayer))
				{
					//
					//	Save this connection
					//
					pTemp = static_cast<DN_GROUP_SEND_OP*>(MemoryBlockAlloc(pdnObject,sizeof(DN_GROUP_SEND_OP)));
					if (pTemp == NULL)
					{
						pGroup->Unlock();
						DPFERR("Could not create DN_GROUP_SEND_OP");
						hResultCode = DPNERR_OUTOFMEMORY;
						goto Failure;
					}
					pConnection->AddRef();
					pTemp->pConnection = pConnection;
					pTemp->pNext = pSendOp;
					pSendOp = pTemp;
				}
			}
			pConnection->Release();
			pConnection = NULL;
		}
		pBilink = pBilink->GetNext();
	}
	pGroup->Unlock();

	//
	//	Create group send parent
	//
	if ((hResultCode = DNCreateSendParent(pdnObject,dwMsgId,pdnBufferDesc,dwSendFlags,&pGroupSendParent)) != DPN_OK)
	{
		DPFERR("Could not create SEND parent");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if (pRefCountBuffer)
	{
		pGroupSendParent->SetRefCountBuffer( pRefCountBuffer );
	}
	pGroupSendParent->SetDPNID( pGroup->GetDPNID() );

	//
	//	Make child if parent specified
	//
	if (pParent)
	{
		pParent->Lock();
		if (pParent->IsCancelled())
		{
			pParent->Unlock();
			pGroupSendParent->SetResult( DPNERR_USERCANCEL );
			hResultCode = DPNERR_USERCANCEL;
			goto Failure;
		}
		pGroupSendParent->MakeChild( pParent );
		pParent->Unlock();
	}

	//
	//	Traverse send list and perform sends
	//
	while (pSendOp)
	{
		if (fRequest)
		{
			hResultCode = DNPerformRequest(	pdnObject,
											DN_MSG_INTERNAL_REQ_PROCESS_COMPLETION,
											pdnBufferDesc,
											pSendOp->pConnection,
											pGroupSendParent,
											&pAsyncOp);
		}
		else
		{
			hResultCode = DNPerformChildSend(	pdnObject,
												pGroupSendParent,
												pSendOp->pConnection,
												dwTimeOut,
												&pAsyncOp,
												FALSE);
		}

		if (pAsyncOp != NULL)
		{
			pAsyncOp->SetDPNID( pSendOp->pConnection->GetDPNID() );
			pAsyncOp->Release();
			pAsyncOp = NULL;
		}

		//
		//	Destroy old group send op
		//
		pTemp = pSendOp;
		pSendOp = pSendOp->pNext;
		pTemp->pConnection->Release();
		pTemp->pConnection = NULL;
		MemoryBlockFree(pdnObject,pTemp);
	}

	//
	//	Pass back group send parent (if required)
	//
	if (ppGroupSendParent)
	{
		pGroupSendParent->AddRef();
		*ppGroupSendParent = pGroupSendParent;
	}

	pGroupSendParent->Release();
	pGroupSendParent = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pAsyncOp)
	{
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	if (pGroupSendParent)
	{
		pGroupSendParent->Release();
		pGroupSendParent = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCreateSendParent"

HRESULT DNCreateSendParent(DIRECTNETOBJECT *const pdnObject,
						   const DWORD dwMsgId,
						   const DPN_BUFFER_DESC *const pdnBufferDesc,
						   const DWORD dwSendFlags,
						   CAsyncOp **const ppParent)
{
	HRESULT			hResultCode;
	CAsyncOp		*pAsyncOp;
	void			*pvBlock;
	DN_SEND_OP_DATA	*pSendOpData;

	DPFX(DPFPREP, 4,"Parameters: dwMsgId [0x%lx], pdnBufferDesc [0x%p], ppParent [0x%p]",
			dwMsgId,pdnBufferDesc,ppParent);

	DNASSERT(pdnObject != NULL);
	DNASSERT(ppParent != NULL);

	pAsyncOp = NULL;
	pvBlock = NULL;

	if ((pvBlock = MemoryBlockAlloc(pdnObject,sizeof(DN_SEND_OP_DATA))) == NULL)
	{
		DPFERR("Could not allocate MemoryBlock");
		DNASSERT(FALSE);
		hResultCode = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	if ((hResultCode = AsyncOpNew(pdnObject,&pAsyncOp)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pAsyncOp->SetOpType( ASYNC_OP_SEND );
	pAsyncOp->SetOpData( pvBlock );
	pAsyncOp->MakeParent();

	pSendOpData = static_cast<DN_SEND_OP_DATA*>(pvBlock);
	pSendOpData->dwMsgId = dwMsgId;
	if (dwMsgId & DN_MSG_INTERNAL)
	{
		if (dwMsgId == DN_MSG_INTERNAL_VOICE_SEND)
		{
			DNASSERT(pdnBufferDesc != NULL);
			pSendOpData->BufferDesc[0].pBufferData = pdnBufferDesc->pBufferData;
			pSendOpData->BufferDesc[0].dwBufferSize = pdnBufferDesc->dwBufferSize;
			pSendOpData->BufferDesc[1].pBufferData = NULL;
			pSendOpData->BufferDesc[1].dwBufferSize = 0;
			pSendOpData->dwNumBuffers = 1;

			pAsyncOp->SetOpFlags( dwSendFlags | DN_SENDFLAGS_SET_USER_FLAG | DN_SENDFLAGS_SET_USER_FLAG_TWO );
		}
		else
		{
			pSendOpData->BufferDesc[0].pBufferData = reinterpret_cast<BYTE*>( &(pSendOpData->dwMsgId) );
			pSendOpData->BufferDesc[0].dwBufferSize = sizeof( DWORD );
			if (pdnBufferDesc)
			{
				pSendOpData->BufferDesc[1].pBufferData = pdnBufferDesc->pBufferData;
				pSendOpData->BufferDesc[1].dwBufferSize = pdnBufferDesc->dwBufferSize;
				pSendOpData->dwNumBuffers = 2;
			}
			else
			{
				pSendOpData->BufferDesc[1].pBufferData = NULL;
				pSendOpData->BufferDesc[1].dwBufferSize = 0;
				pSendOpData->dwNumBuffers = 1;
			}

			pAsyncOp->SetOpFlags( dwSendFlags | DN_SENDFLAGS_SET_USER_FLAG );
		}
	}
	else
	{
		DNASSERT(pdnBufferDesc != NULL);
		pSendOpData->BufferDesc[0].pBufferData = pdnBufferDesc->pBufferData;
		pSendOpData->BufferDesc[0].dwBufferSize = pdnBufferDesc->dwBufferSize;
		pSendOpData->BufferDesc[1].pBufferData = NULL;
		pSendOpData->BufferDesc[1].dwBufferSize = 0;
		pSendOpData->dwNumBuffers = 1;

		pAsyncOp->SetOpFlags( dwSendFlags );
	}

	//
	//	Completion
	//
	pAsyncOp->SetCompletion( DNCompleteSendAsyncOp );
	pvBlock = NULL;		// Completion will clean this up

	pAsyncOp->AddRef();
	*ppParent = pAsyncOp;

	pAsyncOp->Release();
	pAsyncOp = NULL;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pAsyncOp)
	{
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	if (pvBlock)
	{
		MemoryBlockFree(pdnObject,pvBlock);
		pvBlock = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPerformChildSend"

HRESULT DNPerformChildSend(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp *const pParent,
						   CConnection *const pConnection,
						   const DWORD dwTimeOut,
						   CAsyncOp **const ppChild,
						   const BOOL fInternal)
{
	HRESULT			hResultCode;
	CAsyncOp		*pAsyncOp;
	DN_SEND_OP_DATA	*pSendOpData;
	HANDLE			hEndPt;
	HANDLE			hProtocol;
	CCallbackThread	CallbackThread;

	DPFX(DPFPREP, 4,"Parameters: pParent [0x%p], pConnection [0x%p], dwTimeOut [%ld]",
			pParent,pConnection,dwTimeOut);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pParent != NULL);
	DNASSERT(pConnection != NULL);

	pAsyncOp = NULL;
	pSendOpData = static_cast<DN_SEND_OP_DATA*>(pParent->GetOpData());

	if ((hResultCode = AsyncOpNew(pdnObject,&pAsyncOp)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pAsyncOp->SetOpType( ASYNC_OP_SEND );
	pAsyncOp->SetCompletion( DNCompleteSendAsyncOp );
	pAsyncOp->SetOpFlags( pParent->GetOpFlags() );
	if (fInternal)
	{
		pAsyncOp->SetInternal();
	}

	pParent->Lock();
	if (pParent->IsCancelled())
	{
		pParent->Unlock();
		pAsyncOp->SetResult( DPNERR_USERCANCEL );
		hResultCode = DPNERR_USERCANCEL;
		goto Failure;
	}
	pAsyncOp->MakeChild( pParent );
	pParent->Unlock();

	//
	//	Add to active async op list
	//
	DNEnterCriticalSection(&pdnObject->csActiveList);
	pAsyncOp->m_bilinkActiveList.InsertBefore(&pdnObject->m_bilinkActiveList);
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	//
	//	Update outstanding queue info - this will get cleaned up by the completion
	//
	if (pSendOpData->dwMsgId == DN_MSG_USER_SEND)
	{
		pConnection->Lock();
		if (pAsyncOp->GetOpFlags() & DN_SENDFLAGS_HIGH_PRIORITY)
		{
			pConnection->AddToHighQueue( pSendOpData->BufferDesc[0].dwBufferSize );
		}
		else if (pAsyncOp->GetOpFlags() & DN_SENDFLAGS_LOW_PRIORITY)
		{
			pConnection->AddToLowQueue( pSendOpData->BufferDesc[0].dwBufferSize );
		}
		else
		{
			pConnection->AddToNormalQueue( pSendOpData->BufferDesc[0].dwBufferSize );
		}
		pConnection->Unlock();
	}

	//
	//	Save connection and get end point
	//
	if ((hResultCode = pConnection->GetEndPt(&hEndPt,&CallbackThread)) != DPN_OK)
	{
		DPFERR("Could not retrieve EndPt");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pAsyncOp->SetConnection( pConnection );

	if (hEndPt == NULL)
	{
		//
		//	INTERNAL Message
		//
		DPFX(DPFPREP, 5,"INTERNAL Message");

		//
		//	AddRef Protocol as SendComplete will release this reference
		//
		DNProtocolAddRef(pdnObject);

		pAsyncOp->AddRef();
		hResultCode = DNWTSendInternal(	pdnObject,
										&pSendOpData->BufferDesc[0],
										pAsyncOp );

		pConnection->ReleaseEndPt(&CallbackThread);

		DNASSERT(hResultCode == DPNERR_PENDING);
	}
	else
	{
		//
		//	EXTERNAL Message
		//
		DPFX(DPFPREP, 5,"EXTERNAL Message");

		//
		//	AddRef Protocol so that it won't go away until this completes
		//
		DNProtocolAddRef(pdnObject);

		pAsyncOp->AddRef();
		hResultCode = DNPSendData(	pdnObject->pdnProtocolData,
									hEndPt,
									pSendOpData->dwNumBuffers,
									&pSendOpData->BufferDesc[0],
									dwTimeOut,
									pParent->GetOpFlags(),
									reinterpret_cast<void*>(pAsyncOp),
									&hProtocol);
		pConnection->ReleaseEndPt(&CallbackThread);

		if (hResultCode != DPNERR_PENDING)
		{
			DPFERR("SEND failed at Protocol layer");
			DisplayDNError(0,hResultCode);
			pAsyncOp->Release();
			DNProtocolRelease(pdnObject);
			goto Failure;
		}

		pAsyncOp->Lock();
		if (pAsyncOp->IsCancelled() && !pAsyncOp->IsComplete())
		{
			HRESULT		hrCancel;

			pAsyncOp->Unlock();
			DPFX(DPFPREP, 7,"Operation marked for cancel");
			if ((hrCancel = DNPCancelCommand(pdnObject->pdnProtocolData,hProtocol)) == DPN_OK)
			{
				hResultCode = DPNERR_USERCANCEL;
				goto Failure;
			}
			DPFERR("Could not cancel operation");
			DisplayDNError(0,hrCancel);
			pAsyncOp->Lock();
		}
		pAsyncOp->SetProtocolHandle( hProtocol );
		pAsyncOp->Unlock();
	}

	//
	//	If the caller wants a reference on this operation, give it to them
	//
	if (ppChild != NULL)
	{
		pAsyncOp->AddRef();
		*ppChild = pAsyncOp;
	}

	pAsyncOp->Release();
	pAsyncOp = NULL;

Exit:
	// Temporary debugging purposes only, shouldn't be checked in!
#if	0
	DNMemoryTrackingValidateMemory();
#endif

	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pAsyncOp)
	{
		DNEnterCriticalSection(&pdnObject->csActiveList);
		pAsyncOp->m_bilinkActiveList.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csActiveList);
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	goto Exit;
}


//	DN_ProcessInternalOperation
//
//	Process an internal operation
//

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProcessInternalOperation"

HRESULT DNProcessInternalOperation(DIRECTNETOBJECT *const pdnObject,
								   const DWORD dwMsgId,
								   void *const pOpBuffer,
								   const DWORD dwOpBufferSize,
								   CConnection *const pConnection,
								   const HANDLE hProtocol,
								   CRefCountBuffer *const pRefCountBuffer)
{
	HRESULT				hResultCode;
	CRefCountBuffer		*pRCBuffer;
	CWorkerJob			*pWorkerJob;
	BOOL				fDecRunningOpCount;

	DPFX(DPFPREP, 6,"Parameters: dwMsgId [0x%lx], pOpBuffer [0x%p], dwOpBufferSize [%ld], pConnection [0x%p], hProtocol [0x%p], pRefCountBuffer [0x%p]",
			dwMsgId,pOpBuffer,dwOpBufferSize,pConnection,hProtocol,pRefCountBuffer);

	hResultCode = DPN_OK;
	pRCBuffer = NULL;
	pWorkerJob = NULL;
	fDecRunningOpCount = FALSE;

	//
	//	We will track the number of running operations (i.e. threads running through this function).
	//	At the start of host migration, we will need to send the new host the latest name table version,
	//	so we will need to let running operations finish, before sending in the name table version.
	//	If another thread is waiting, we will not perform any operations (other than host migration)
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if ((pdnObject->dwFlags & DN_OBJECT_FLAG_HOST_MIGRATING_WAIT) && (dwMsgId != DN_MSG_INTERNAL_HOST_MIGRATE))
	{
		DPFX(DPFPREP,7,"Already waiting for running operations - ignoring this operation");
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		hResultCode = DPN_OK;
		goto Failure;
	}
	if (dwMsgId != DN_MSG_INTERNAL_HOST_MIGRATE)
	{
		pdnObject->dwRunningOpCount++;
		fDecRunningOpCount = TRUE;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	switch(dwMsgId)
	{
		case DN_MSG_INTERNAL_PLAYER_CONNECT_INFO:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_PLAYER_CONNECT_INFO");

				if (DNVerifyPlayerConnectInfo(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				//
				//	Perform validations and send name table to player
				//
				hResultCode = DNHostConnect1(pdnObject,pOpBuffer,dwOpBufferSize,pConnection);

				hResultCode = DPN_OK;	// Ignore return code

				break;
			}

		case DN_MSG_INTERNAL_SEND_CONNECT_INFO:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_SEND_CONNECT_INFO");

				if (DNVerifyConnectInfo(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				//
				//	We will pass this stage off to the worker thread since there is a threading
				//	issue, and we cannot keep the SP's thread which was passed up to here.
				//

				if ((hResultCode = RefCountBufferNew(pdnObject,dwOpBufferSize,&pRCBuffer)) != DPN_OK)
				{
					DPFERR("Could not allocate RefCountBuffer");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					hResultCode = DPN_OK;
					goto Failure;
				}
				memcpy(pRCBuffer->GetBufferAddress(),pOpBuffer,dwOpBufferSize);

				if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
				{
					DPFERR("Could not create WorkerJob");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					hResultCode = DPN_OK;
					goto Failure;
				}
				pWorkerJob->SetJobType( WORKER_JOB_INSTALL_NAMETABLE );
				pWorkerJob->SetConnection( pConnection );
				pWorkerJob->SetRefCountBuffer( pRCBuffer );

				DNQueueWorkerJob(pdnObject,pWorkerJob);
				pWorkerJob = NULL;

				pRCBuffer->Release();
				pRCBuffer = NULL;

				break;
			}

		case DN_MSG_INTERNAL_ACK_CONNECT_INFO:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_ACK_CONNECT_INFO");

				//
				//	No verification as there is no payload with this message
				//

				//
				//	Process connect info acknowledge by host
				//
				hResultCode = DNHostConnect2(pdnObject,pConnection);	// Ignore errors

				break;
			}

		case DN_MSG_INTERNAL_SEND_PLAYER_DNID:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_SEND_PLAYER_DNID");

				if (DNVerifySendPlayerDPNID(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				//
				// Send this player's DNID to the connecting player to enable name table entry
				//
				hResultCode = DNPlayerConnect1(pdnObject,pOpBuffer,pConnection);	// Ignore errors

				break;
			}

		case DN_MSG_INTERNAL_CONNECT_FAILED:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_CONNECT_FAILED");

				if (DNVerifyConnectFailed(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				//
				//	Save reply buffer and clean up
				//
				DNConnectToHostFailed(pdnObject,pOpBuffer,dwOpBufferSize,pConnection);

				hResultCode = DPN_OK;

				break;
			}

		case DN_MSG_INTERNAL_INSTRUCT_CONNECT:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_INSTRUCT_CONNECT");

				if (DNVerifyInstructConnect(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNNTAddOperation(	pdnObject,
												DN_MSG_INTERNAL_INSTRUCT_CONNECT,
												pOpBuffer,
												dwOpBufferSize,
												hProtocol,
												pConnection->GetSP());

				break;
			}

		case DN_MSG_INTERNAL_INSTRUCTED_CONNECT_FAILED:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_INSTRUCTED_CONNECT_FAILED");

				if (DNVerifyInstructedConnectFailed(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNHostDropPlayer(	pdnObject,
												pConnection->GetDPNID(),
												pOpBuffer);	// Ignore errors

				break;
			}

		case DN_MSG_INTERNAL_CONNECT_ATTEMPT_FAILED:
			{
				UNALIGNED DN_INTERNAL_MESSAGE_CONNECT_ATTEMPT_FAILED	*pInfo;

				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_CONNECT_ATTEMPT_FAILED");

				if (DNVerifyConnectAttemptFailed(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				pInfo = static_cast<DN_INTERNAL_MESSAGE_CONNECT_ATTEMPT_FAILED*>(pOpBuffer);
				DPFX(DPFPREP, 7,"Player [0x%lx] could not connect to us",pInfo->dpnid);

				hResultCode = DNAbortConnect(pdnObject,DPNERR_PLAYERNOTREACHABLE);		// Ignore errors
				break;
			}

		case DN_MSG_INTERNAL_NAMETABLE_VERSION:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_NAMETABLE_VERSION");

				if (DNVerifyNameTableVersion(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNNTHostReceiveVersion(pdnObject,pConnection->GetDPNID(),pOpBuffer);

				break;
			}

		case DN_MSG_INTERNAL_RESYNC_VERSION:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_RESYNC_VERSION");

				if (DNVerifyResyncVersion(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNNTPlayerResyncVersion(pdnObject,pOpBuffer);

				break;
			}

		case DN_MSG_INTERNAL_REQ_NAMETABLE_OP:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_REQ_NAMETABLE_OP");

				if (DNVerifyReqNameTableOp(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNProcessHostMigration2(pdnObject,pOpBuffer);

				break;
			}

		case DN_MSG_INTERNAL_ACK_NAMETABLE_OP:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_ACK_NAMETABLE_OP");

				if (DNVerifyAckNameTableOp(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNPerformHostMigration3(pdnObject,pOpBuffer);

				break;
			}

		case DN_MSG_INTERNAL_HOST_MIGRATE:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_HOST_MIGRATE");

				if (DNVerifyHostMigrate(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNProcessHostMigration1(pdnObject,pOpBuffer);

				break;
			}

		case DN_MSG_INTERNAL_HOST_MIGRATE_COMPLETE:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_HOST_MIGRATE_COMPLETE");

				//
				//	No verification as there is no payload with this message
				//
				hResultCode = DNProcessHostMigration3(pdnObject,pConnection->GetDPNID());

				break;
			}

		case DN_MSG_INTERNAL_UPDATE_APPLICATION_DESC:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_UPDATE_APPLICATION_DESC");

				if (DNVerifyApplicationDescInfo(pOpBuffer,dwOpBufferSize,pOpBuffer) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNProcessUpdateAppDesc(pdnObject,static_cast<DPN_APPLICATION_DESC_INFO*>(pOpBuffer));

				break;
			}

		case DN_MSG_INTERNAL_ADD_PLAYER:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_ADD_PLAYER");

				if (DNVerifyNameTableEntryInfo(pOpBuffer,dwOpBufferSize,pOpBuffer) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNNTAddOperation(	pdnObject,
												DN_MSG_INTERNAL_ADD_PLAYER,
												pOpBuffer,
												dwOpBufferSize,
												hProtocol,
												pConnection->GetSP());

				break;
			}

		case DN_MSG_INTERNAL_DESTROY_PLAYER:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_DESTROY_PLAYER");

				if (DNVerifyDestroyPlayer(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNNTAddOperation(	pdnObject,
												DN_MSG_INTERNAL_DESTROY_PLAYER,
												pOpBuffer,
												dwOpBufferSize,
												hProtocol,
												pConnection->GetSP());

				break;
			}

		case DN_MSG_INTERNAL_CREATE_GROUP:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_CREATE_GROUP");

				if (DNVerifyCreateGroup(pOpBuffer,dwOpBufferSize,pOpBuffer) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNNTAddOperation(	pdnObject,
												DN_MSG_INTERNAL_CREATE_GROUP,
												pOpBuffer,
												dwOpBufferSize,
												hProtocol,
												pConnection->GetSP());

				break;
			}

		case DN_MSG_INTERNAL_DESTROY_GROUP:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_DESTROY_GROUP");

				if (DNVerifyDestroyGroup(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNNTAddOperation(	pdnObject,
												DN_MSG_INTERNAL_DESTROY_GROUP,
												pOpBuffer,
												dwOpBufferSize,
												hProtocol,
												pConnection->GetSP());

				break;
			}

		case DN_MSG_INTERNAL_ADD_PLAYER_TO_GROUP:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_ADD_PLAYER_TO_GROUP");

				if (DNVerifyAddPlayerToGroup(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNNTAddOperation(	pdnObject,
												DN_MSG_INTERNAL_ADD_PLAYER_TO_GROUP,
												pOpBuffer,
												dwOpBufferSize,
												hProtocol,
												pConnection->GetSP());

				break;
			}

		case DN_MSG_INTERNAL_DELETE_PLAYER_FROM_GROUP:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_DELETE_PLAYER_FROM_GROUP");

				if (DNVerifyDeletePlayerFromGroup(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNNTAddOperation(	pdnObject,
												DN_MSG_INTERNAL_DELETE_PLAYER_FROM_GROUP,
												pOpBuffer,
												dwOpBufferSize,
												hProtocol,
												pConnection->GetSP());

				break;
			}

		case DN_MSG_INTERNAL_UPDATE_INFO:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_UPDATE_INFO");

				if (DNVerifyUpdateInfo(pOpBuffer,dwOpBufferSize,pOpBuffer) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNNTAddOperation(	pdnObject,
												DN_MSG_INTERNAL_UPDATE_INFO,
												pOpBuffer,
												dwOpBufferSize,
												hProtocol,
												pConnection->GetSP());

				break;
			}

		case DN_MSG_INTERNAL_REQ_CREATE_GROUP:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_REQ_CREATE_GROUP");

				if (DNVerifyReqCreateGroup(pOpBuffer,dwOpBufferSize,pOpBuffer) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNHostProcessRequest(pdnObject,DN_MSG_INTERNAL_REQ_CREATE_GROUP,
						pOpBuffer,pConnection->GetDPNID());

				break;
			}

		case DN_MSG_INTERNAL_REQ_DESTROY_GROUP:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_REQ_DESTROY_GROUP");

				if (DNVerifyReqDestroyGroup(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNHostProcessRequest(pdnObject,DN_MSG_INTERNAL_REQ_DESTROY_GROUP,
						pOpBuffer,pConnection->GetDPNID());

				break;
			}

		case DN_MSG_INTERNAL_REQ_ADD_PLAYER_TO_GROUP:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_REQ_ADD_PLAYER_TO_GROUP");

				if (DNVerifyReqAddPlayerToGroup(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNHostProcessRequest(pdnObject,
						DN_MSG_INTERNAL_REQ_ADD_PLAYER_TO_GROUP,pOpBuffer,pConnection->GetDPNID());

				break;
			}

		case DN_MSG_INTERNAL_REQ_DELETE_PLAYER_FROM_GROUP:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_REQ_DELETE_PLAYER_FROM_GROUP");

				if (DNVerifyReqDeletePlayerFromGroup(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNHostProcessRequest(pdnObject,
						DN_MSG_INTERNAL_REQ_DELETE_PLAYER_FROM_GROUP,pOpBuffer,pConnection->GetDPNID());

				break;
			}

		case DN_MSG_INTERNAL_REQ_UPDATE_INFO:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_REQ_UPDATE_INFO");

				if (DNVerifyReqUpdateInfo(pOpBuffer,dwOpBufferSize,pOpBuffer) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNHostProcessRequest(pdnObject,DN_MSG_INTERNAL_REQ_UPDATE_INFO,
						pOpBuffer,pConnection->GetDPNID());

				break;
			}

		case DN_MSG_INTERNAL_VOICE_SEND:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_VOICE_SEND");

				hResultCode = Voice_Receive( pdnObject, pConnection->GetDPNID(), 0, pOpBuffer, dwOpBufferSize );	

				break;
			}

		case DN_MSG_INTERNAL_BUFFER_IN_USE:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_BUFFER_IN_USE - INVALID !");
				DNASSERT(FALSE);
				break;
			}

		case DN_MSG_INTERNAL_REQUEST_FAILED:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_REQUEST_FAILED - INVALID !");
				
				if (DNVerifyRequestFailed(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNProcessFailedRequest(pdnObject,pOpBuffer);

				break;
			}

		case DN_MSG_INTERNAL_TERMINATE_SESSION:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_TERMINATE_SESSION");

				if (DNVerifyTerminateSession(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNProcessTerminateSession(pdnObject,pOpBuffer,dwOpBufferSize);

				break;
			}

		case DN_MSG_INTERNAL_REQ_PROCESS_COMPLETION:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_REQ_PROCESS_COMPLETION");

				if (DNVerifyReqProcessCompletion(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				//
				//	Ensure requesting player in NameTable
				//
				hResultCode = DNReceiveCompleteOnProcess(pdnObject,pConnection,pOpBuffer,
						dwOpBufferSize,hProtocol,pRefCountBuffer);

				if (hResultCode != DPNERR_PENDING)
				{
					hResultCode = DPN_OK;	// Ignore errors
				}
				break;
			}

		case DN_MSG_INTERNAL_PROCESS_COMPLETION:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_PROCESS_COMPLETION");

				if (DNVerifyProcessCompletion(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNReceiveCompleteOnProcessReply(pdnObject,pOpBuffer,dwOpBufferSize);

				break;
			}

		case DN_MSG_INTERNAL_REQ_INTEGRITY_CHECK:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_REQ_INTEGRITY_CHECK");

				if (DNVerifyReqIntegrityCheck(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNHostProcessRequest(pdnObject,DN_MSG_INTERNAL_REQ_INTEGRITY_CHECK,
						pOpBuffer,pConnection->GetDPNID());

				hResultCode = DPN_OK;

				break;
			}

		case DN_MSG_INTERNAL_INTEGRITY_CHECK:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_INTEGRITY_CHECK");

				if (DNVerifyIntegrityCheck(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNProcessCheckIntegrity(pdnObject,pOpBuffer);

				hResultCode = DPN_OK;	// Ignore errors

				break;
			}

		case DN_MSG_INTERNAL_INTEGRITY_CHECK_RESPONSE:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL_INTEGRITY_CHECK_RESPONSE");

				if (DNVerifyIntegrityCheckResponse(pOpBuffer,dwOpBufferSize) != DPN_OK)
				{
					DPFERR("Invalid message - ignoring");
					hResultCode = DPN_OK;
					goto Failure;
				}

				hResultCode = DNHostFixIntegrity(pdnObject,pOpBuffer);

				hResultCode = DPN_OK;	// Ignore errors

				break;
			}

		default:
			{
				DPFX(DPFPREP, 7,"Received: DN_MSG_INTERNAL (UNKNOWN!)");
				DNASSERT(FALSE);
				hResultCode = DPNERR_UNSUPPORTED;
				break;
			}
	}

Exit:
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (fDecRunningOpCount)
	{
		pdnObject->dwRunningOpCount--;
	}
	if ((pdnObject->dwRunningOpCount == 0) && (pdnObject->dwFlags & DN_OBJECT_FLAG_HOST_MIGRATING_WAIT))
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		SetEvent(pdnObject->hRunningOpEvent);
	}
	else
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	}

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRCBuffer)
	{
		pRCBuffer->Release();
		pRCBuffer = NULL;
	}
	if (pWorkerJob)
	{
		pWorkerJob->ReturnSelfToPool();
		pWorkerJob = NULL;
	}
	goto Exit;
}



#undef DPF_MODNAME
#define DPF_MODNAME "DNPerformRequest"

HRESULT DNPerformRequest(DIRECTNETOBJECT *const pdnObject,
						 const DWORD dwMsgId,
						 const DPN_BUFFER_DESC *const pBufferDesc,
						 CConnection *const pConnection,
						 CAsyncOp *const pParent,
						 CAsyncOp **const ppRequest)
{
	DWORD			dwFlags;
	HRESULT			hResultCode;
	BOOL			fInternal;
	BOOL			fReleaseLock;
	void			*pvBlock;
	CAsyncOp		*pRequest;
	CAsyncOp		*pSend;
	CRefCountBuffer	*pRefCountBuffer;
	DN_SEND_OP_DATA	*pSendOpData;
	DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION	*pMsg;

	DPFX(DPFPREP, 6,"Parameters: dwMsgId [0x%lx], pBufferDesc [0x%p], pConnection [0x%p], pParent [0x%p], ppRequest [0x%p]",
			dwMsgId,pBufferDesc,pConnection,pParent,ppRequest);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pBufferDesc != NULL);

	pRequest = NULL;
	pSend = NULL;
	pRefCountBuffer = NULL;
	pvBlock = NULL;
	fReleaseLock = FALSE;

	//
	//	Create RefCountBuffer for this operation
	//
	hResultCode = RefCountBufferNew(pdnObject,
									pBufferDesc->dwBufferSize + sizeof(DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION),
									&pRefCountBuffer);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not create RefCountBuffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION*>(pRefCountBuffer->GetBufferAddress());
	memcpy(pMsg + 1,pBufferDesc->pBufferData,pBufferDesc->dwBufferSize);

	//
	//	Keep DirectNetObject from vanishing under us !
	//
	if ((hResultCode = DNAddRefLock(pdnObject)) != DPN_OK)
	{
		DPFERR("Aborting request - object is closing");
		hResultCode = DPN_OK;
		goto Failure;
	}
	fReleaseLock = TRUE;

	//
	//	Create REQUEST
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pRequest)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pRequest->SetOpType( ASYNC_OP_REQUEST );
	if (pParent)
	{
		pParent->Lock();
		if (pParent->IsCancelled())
		{
			pParent->Unlock();
			pRequest->SetResult( DPNERR_USERCANCEL );
			hResultCode = DPNERR_USERCANCEL;
			goto Failure;
		}
		pRequest->MakeChild( pParent );
		pParent->Unlock();
	}
	pRequest->MakeParent();
	pRequest->SetRefCountBuffer( pRefCountBuffer );

	//
	//	Need a handle for this op (to be sent to the other side who will pass it back)
	//
	if ((hResultCode = pdnObject->HandleTable.Create(pRequest,NULL)) != DPN_OK)
	{
		DPFERR("Could not create handle for this operation");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	DNASSERT(pRequest->GetHandle() != 0);

	//
	//	Set up SEND op data
	//
	if ((pvBlock = MemoryBlockAlloc(pdnObject,sizeof(DN_SEND_OP_DATA))) == NULL)
	{
		DPFERR("Could not allocate DN_REQUEST_OP_DATA");
		DNASSERT(FALSE);
		hResultCode = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	pSendOpData = static_cast<DN_SEND_OP_DATA*>(pvBlock);
	pSendOpData->dwMsgId = dwMsgId;
	pSendOpData->BufferDesc[0].pBufferData = reinterpret_cast<BYTE*>(&pSendOpData->dwMsgId);
	pSendOpData->BufferDesc[0].dwBufferSize = sizeof(DWORD);
	pSendOpData->BufferDesc[1].pBufferData = pRefCountBuffer->GetBufferAddress();
	pSendOpData->BufferDesc[1].dwBufferSize = pRefCountBuffer->GetBufferSize();
	pSendOpData->dwNumBuffers = 2;

	pRequest->SetOpFlags( DN_SENDFLAGS_RELIABLE | DN_SENDFLAGS_SET_USER_FLAG );
	pRequest->SetCompletion( DNCompleteRequest );
	pRequest->SetOpData( pvBlock );
	pRequest->SetResult( DPNERR_PLAYERLOST );
	pvBlock = NULL;		// Completion will clean up

	pMsg->hCompletionOp = pRequest->GetHandle();

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	//
	//	User messages sent with COMPLETE_ON_SEND should be allowed to be cancelled
	//
	if (dwMsgId == DN_MSG_INTERNAL_REQ_PROCESS_COMPLETION)
	{
		fInternal = FALSE;
	}
	else
	{
		fInternal = TRUE;
	}

	//
	//	We will always hand back the request, even if the send fails
	//
	if (ppRequest)
	{
		pRequest->AddRef();
		*ppRequest = pRequest;
	}

	//
	//	Unlock DirectNetObject
	//
	DNDecRefLock(pdnObject);
	fReleaseLock = FALSE;

	//
	//	Add request to the request list
	//
	DNEnterCriticalSection(&pdnObject->csActiveList);
	pRequest->m_bilinkActiveList.InsertBefore(&pdnObject->m_bilinkRequestList);
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	//
	//	Avoid operations while host migration is taking place.  This will get picked up
	//	after host migration, when completing outstanding operations
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	dwFlags = pdnObject->dwFlags;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	if (!(dwFlags & DN_OBJECT_FLAG_HOST_MIGRATING) || !fInternal)
	{

		//
		//	SEND REQUEST
		//
		if (pConnection)
		{
			hResultCode = DNPerformChildSend(	pdnObject,
												pRequest,
												pConnection,
												0,
												&pSend,
												fInternal );
			if (hResultCode != DPNERR_PENDING)
			{
				DPFERR("Could not perform child SEND");
				DisplayDNError(0,hResultCode);
				goto Failure;
			}

			//
			//	Reset SEND AsyncOp to complete apropriately.
			//
			pSend->SetCompletion( DNCompleteSendRequest );

			pSend->Release();
			pSend = NULL;
		}
	}

	pRequest->Release();
	pRequest = NULL;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (fReleaseLock)
	{
		DNDecRefLock(pdnObject);
		fReleaseLock = FALSE;
	}
	if (pRequest)
	{
		pRequest->Release();
		pRequest = NULL;
	}
	if (pSend)
	{
		pSend->Release();
		pSend = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pvBlock)
	{
		MemoryBlockFree(pdnObject,pvBlock);
		pvBlock = NULL;
	}
	goto Exit;
}


//	DNReceiveCompleteOnProcess
//
//	Receive a CompleteOnProcess message
//	Pass the message up to the application and then return a special completion message

#undef DPF_MODNAME
#define DPF_MODNAME "DNReceiveCompleteOnProcess"

HRESULT DNReceiveCompleteOnProcess(DIRECTNETOBJECT *const pdnObject,
								   CConnection *const pConnection,
								   void *const pBufferData,
								   const DWORD dwBufferSize,
								   const HANDLE hProtocol,
								   CRefCountBuffer *const pRefCountBuffer)
{
	HRESULT			hResultCode;
	PVOID			pvData;
	DWORD			dwDataSize;
	UNALIGNED DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION	*pReq;

	DPFX(DPFPREP, 4,"Parameters: pConnection [0x%p], pBufferData [0x%p], dwBufferSize [%ld], hProtocol [0x%p], pRefCountBuffer [0x%p]",
			pConnection,pBufferData,dwBufferSize,hProtocol,pRefCountBuffer);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pConnection != NULL);

	//
	//	Extract message
	//
	pReq = static_cast<DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION*>(pBufferData);
	pvData = static_cast<void*>(pReq + 1);
	dwDataSize = dwBufferSize - sizeof(DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION);

	//
	//	Pass data to application
	//
	hResultCode = DNReceiveUserData(pdnObject,
									pConnection->GetDPNID(),
									pConnection->GetSP(),
									static_cast<BYTE*>(pvData),
									dwDataSize,
									hProtocol,
									pRefCountBuffer,
									pReq->hCompletionOp,
									0);

	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DNReceiveCompleteOnProcessReply
//
//	Receive a CompleteOnProcess COMPLETION message
//	Complete the outstanding CompleteOnProcess operation

#undef DPF_MODNAME
#define DPF_MODNAME "DNReceiveCompleteOnProcessReply"

HRESULT DNReceiveCompleteOnProcessReply(DIRECTNETOBJECT *const pdnObject,
										void *const pBufferData,
										const DWORD dwBufferSize)
{
	HRESULT			hResultCode;
	CAsyncOp		*pAsyncOp;
	UNALIGNED DN_INTERNAL_MESSAGE_PROCESS_COMPLETION	*pMsg;

	DPFX(DPFPREP, 4,"Parameters: pBufferData [0x%p], dwBufferSize [%ld]",pBufferData,dwBufferSize);

	DNASSERT(pBufferData != NULL);

	pAsyncOp = NULL;

	pMsg = static_cast<DN_INTERNAL_MESSAGE_PROCESS_COMPLETION*>(pBufferData);

	//
	//	Remove async op from HandleTable and from request list
	//
	DPFX(DPFPREP, 5,"Release completion operation [0x%lx]",pMsg->hCompletionOp);
	if ((hResultCode = pdnObject->HandleTable.Find(pMsg->hCompletionOp,&pAsyncOp)) != DPN_OK)
	{
		DPFERR("Could not find handle in HandleTable");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	DNASSERT(pAsyncOp->GetOpType() == ASYNC_OP_REQUEST);
	DNEnterCriticalSection(&pdnObject->csActiveList);
	pAsyncOp->m_bilinkActiveList.RemoveFromList();
	DNLeaveCriticalSection(&pdnObject->csActiveList);
	pdnObject->HandleTable.Destroy( pAsyncOp->GetHandle() );

	//
	//	Mark this operation as completing okay
	//
	pAsyncOp->SetResult( DPN_OK );

	//
	//	This release should be the final release of the Request Child Async Op. and should
	//	DecRef the Request Parent Async Op.
	//
	pAsyncOp->Release();
	pAsyncOp = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pAsyncOp)
	{
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	goto Exit;
}


//	DNProcessTerminateSession
//
//	Process a TERMINATE_SESSION message from the Host player

#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessTerminateSession"

HRESULT DNProcessTerminateSession(DIRECTNETOBJECT *const pdnObject,
								  void *const pvBuffer,
								  const DWORD dwBufferSize)
{
	HRESULT		hResultCode;
	void		*pvTerminateData;
	UNALIGNED DN_INTERNAL_MESSAGE_TERMINATE_SESSION	*pMsg;

	DPFX(DPFPREP, 4,"Parameters: pvBuffer [0x%p], dwBufferSize [%ld]",pvBuffer,dwBufferSize);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvBuffer != NULL);

	pMsg = static_cast<DN_INTERNAL_MESSAGE_TERMINATE_SESSION*>(pvBuffer);
	if (pMsg->dwTerminateDataOffset)
	{
		pvTerminateData = static_cast<void*>(static_cast<BYTE*>(pvBuffer) + pMsg->dwTerminateDataOffset);
	}
	else
	{
		pvTerminateData = NULL;
	}

	//
	//	Inform user of termination
	//
	hResultCode = DNUserTerminateSession(pdnObject,DPNERR_HOSTTERMINATEDSESSION,pvTerminateData,pMsg->dwTerminateDataSize);

	// Terminate session
	hResultCode = DNTerminateSession(pdnObject,DPNERR_HOSTTERMINATEDSESSION);

	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\async.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       async.h
 *  Content:    Asynchronous Operations Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/28/99	mjn		Created
 *	12/29/99	mjn		Reformed DN_ASYNC_OP to use hParentOp instead of lpvUserContext
 *	01/14/00	mjn		Added pvUserContext to DN_PerformListen
 *	01/14/00	mjn		Changed DN_COUNT_BUFFER to CRefCountBuffer
 *	01/17/00	mjn		Added dwStartTime to async op structure
 *	01/19/00	mjn		Replaced DN_SYNC_EVENT with CSyncEvent
 *	01/21/00	mjn		Added DNProcessInternalOperation
 *	01/27/00	mjn		Added support for retention of receive buffers
 *	02/09/00	mjn		Implemented DNSEND_COMPLETEONPROCESS
 *	02/18/00	mjn		Converted DNADDRESS to IDirectPlayAddress8
 *	03/23/00	mjn		Added phrSync and pvInternal
 *	03/24/00	mjn		Add guidSP to DN_ASYNC_OP
 *	04/04/00	mjn		Added DNProcessTerminateSession()
 *	04/10/00	mjn		Use CAsyncOp for CONNECTs, LISTENs and DISCONNECTs
 *	04/17/00	mjn		Replaced BUFFERDESC with DPN_BUFFER_DESC
 *	04/17/00	mjn		Added DNCompleteAsyncHandle
 *	04/21/00	mjn		Added DNPerformDisconnect
 *	04/23/00	mjn		Optionally return child AsyncOp in DNPerformChildSend()
 *	04/24/00	mjn		Added DNCreateUserHandle()
 *	06/24/00	mjn		Added DNCompleteConnectToHost() and DNCompleteUserConnect()
 *	07/02/00	mjn		Added DNSendGroupMessage() and DN_GROUP_SEND_OP
 *	07/10/00	mjn		Added DNPerformEnumQuery()
 *	07/11/00	mjn		Added fNoLoopBack to DNSendGroupMessage()
 *				mjn		Added DNPerformNextEnumQuery(),DNPerformSPListen(),DNPerformNextListen(),DNEnumAdapterGuids(),DNPerformNextConnect
 *				mjn		Added DN_LISTEN_OP_DATA,DN_CONNECT_OP_DATA
 *	07/20/00	mjn		Added DNCompleteConnectOperation() and DNCompleteSendConnectInfo()
 *				mjn		Modified DNPerformDisconnect()
 *	08/05/00	mjn		Added pParent to DNSendGroupMessage and DNSendMessage()
 *				mjn		Added fInternal to DNPerformChildSend()
 *				mjn		Removed DN_TerminateAllListens()
 *				mjn		Added DNCompleteRequest()
 *	09/23/00	mjn		Added CSyncEvent to DN_LISTEN_OP_DATA
 *	10/04/00	mjn		Added dwCompleteAdapters to DN_LISTEN_OP_DATA
 *  12/05/00	RichGr  Changed DN_SEND_OP_DATA packing from 1 to default (4 on 32-bit, 8 on 64bit).
 *	03/30/00	mjn		Added service provider to DNPerformConnect()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__ASYNC_H__
#define	__ASYNC_H__

typedef struct _DIRECTNETOBJECT DIRECTNETOBJECT;


//**********************************************************************
// Constant definitions
//**********************************************************************

#define	DN_ASYNC_OP_SIG							0xdece0003

#define	DN_ASYNC_OP_FLAG_MULTI_OP				0x0001
#define DN_ASYNC_OP_FLAG_MULTI_OP_PARENT		0x0002
#define	DN_ASYNC_OP_FLAG_SYNCHRONOUS_OP			0x0010
#define	DN_ASYNC_OP_FLAG_NO_COMPLETION			0x0100
#define	DN_ASYNC_OP_FLAG_RELEASE_SP				0x1000

//
// Enumerated values for buffer descriptions.  The value DN_ASYNC_BUFFERDESC_COUNT
// must be large enough to contain account for BUFFERDESC structres possibly
// passed with this async operation
//
#define	DN_ASYNC_BUFFERDESC_HEADER				0
#define	DN_ASYNC_BUFFERDESC_DATA				1
#define	DN_ASYNC_BUFFERDESC_COUNT				3

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

class CSyncEvent;
class CRefCountBuffer;
class CServiceProvider;
class CAsyncOp;
class CConnection;
class CNameTableEntry;


typedef struct _DN_SEND_OP_DATA
{
	DWORD			dwMsgId;
	DPN_BUFFER_DESC	BufferDesc[2];
	DWORD			dwNumBuffers;
	DWORD			dwNumOutstanding;
} DN_SEND_OP_DATA;



typedef struct _DN_GROUP_SEND_OP
{
	CConnection					*pConnection;
	struct _DN_GROUP_SEND_OP	*pNext;
} DN_GROUP_SEND_OP;


typedef struct _DN_LISTEN_OP_DATA
{
	DWORD		dwNumAdapters;
	DWORD		dwCurrentAdapter;
	DWORD		dwCompleteAdapters;
	CSyncEvent	*pSyncEvent;
} DN_LISTEN_OP_DATA;


typedef struct _DN_CONNECT_OP_DATA
{
	DWORD			dwNumAdapters;
	DWORD			dwCurrentAdapter;
} DN_CONNECT_OP_DATA;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

HRESULT DNCreateUserHandle(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp **const ppAsyncOp);

HRESULT DNEnumAdapterGuids(DIRECTNETOBJECT *const pdnObject,
						   GUID *const pguidSP,
						   const DWORD dwEnumBufferMinimumSize,
						   void **const ppvEnumBuffer,
						   DWORD *const pdwNumAdapters);

HRESULT DNPerformSPListen(DIRECTNETOBJECT *const pdnObject,
						  IDirectPlay8Address *const pDeviceAddr,
						  CAsyncOp *const pListenParent,
						  CAsyncOp **const ppParent);

HRESULT DNPerformListen(DIRECTNETOBJECT *const pdnObject,
						IDirectPlay8Address *const pDeviceInfo,
						CAsyncOp *const pParent);

HRESULT DNPerformNextListen(DIRECTNETOBJECT *const pdnObject,
							CAsyncOp *const pAsyncOp,
							IDirectPlay8Address *const pDeviceAddr);

void DNCompleteListen(DIRECTNETOBJECT *const pdnObject,
					  CAsyncOp *const pAsyncOp);
/*	REMOVE
HRESULT DN_TerminateAllListens(DIRECTNETOBJECT *const pdnObject);
*/

HRESULT DNPerformEnumQuery(DIRECTNETOBJECT *const pdnObject,
						   IDirectPlay8Address *const pHost,
						   IDirectPlay8Address *const pDevice,
						   const HANDLE hSPHandle,
						   DPN_BUFFER_DESC *const rgdnBufferDesc,
						   const DWORD cBufferDesc,
						   const DWORD dwRetryCount,
						   const DWORD dwRetryInterval,
						   const DWORD dwTimeOut,
						   const DWORD dwFlags,
						   void *const pvContext,
						   CAsyncOp *const pParent);

HRESULT DNPerformNextEnumQuery(DIRECTNETOBJECT *const pdnObject,
							   CAsyncOp *const pAsyncOp,
							   IDirectPlay8Address *const pHostAddr,
							   IDirectPlay8Address *const pDeviceAddr);

void DNCompleteEnumQuery(DIRECTNETOBJECT *const pdnObject,
						 CAsyncOp *const pAsyncOp);

void DNCompleteEnumResponse(DIRECTNETOBJECT *const pdnObject,
							CAsyncOp *const pAsyncOp);

HRESULT DNPerformConnect(DIRECTNETOBJECT *const pdnObject,
						 const DPNID dpnid,
						 IDirectPlay8Address *const pDeviceInfo,
						 IDirectPlay8Address *const pRemoteAddr,
						 CServiceProvider *const pSP,
						 const DWORD dwConnectFlags,
						 CAsyncOp *const pParent);

HRESULT DNPerformNextConnect(DIRECTNETOBJECT *const pdnObject,
							 CAsyncOp *const pAsyncOp,
							 IDirectPlay8Address *const pHostAddr,
							 IDirectPlay8Address *const pDeviceAddr);

void DNCompleteConnect(DIRECTNETOBJECT *const pdnObject,
					   CAsyncOp *const pAsyncOp);

void DNCompleteConnectToHost(DIRECTNETOBJECT *const pdnObject,
							 CAsyncOp *const pAsyncOp);

void DNCompleteConnectOperation(DIRECTNETOBJECT *const pdnObject,
								CAsyncOp *const pAsyncOp);

void DNCompleteUserConnect(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp *const pAsyncOp);

void DNCompleteSendConnectInfo(DIRECTNETOBJECT *const pdnObject,
							   CAsyncOp *const pAsyncOp);

HRESULT DNPerformDisconnect(DIRECTNETOBJECT *const pdnObject,
							CConnection *const pConnection,
							const HANDLE hEndPt);

void DNCompleteAsyncHandle(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp *const pAsyncOp);

void DNCompleteSendHandle(DIRECTNETOBJECT *const pdnObject,
						  CAsyncOp *const pAsyncOp);

void DNCompleteSendAsyncOp(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp *const pAsyncOp);

void DNCompleteRequest(DIRECTNETOBJECT *const pdnObject,
					   CAsyncOp *const pAsyncOp);

void DNCompleteSendRequest(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp *const pAsyncOp);

HRESULT DNSendMessage(DIRECTNETOBJECT *const pdnObject,
					  CConnection *const pConnection,
					  const DWORD dwMsgId,
					  const DPNID dpnidTarget,
					  const DPN_BUFFER_DESC *const pdnBufferDesc,
					  CRefCountBuffer *const pRefCountBuffer,
					  const DWORD dwTimeOut,
					  const DWORD dwSendFlags,
					  CAsyncOp *const pParent,
					  CAsyncOp **const ppAsyncOp);

HRESULT DNSendGroupMessage(DIRECTNETOBJECT *const pdnObject,
						   CNameTableEntry *const pGroup,
						   const DWORD dwMsgId,
						   const DPN_BUFFER_DESC *const pdnBufferDesc,
						   CRefCountBuffer *const pRefCountBuffer,
						   const DWORD dwTimeOut,
						   const DWORD dwSendFlags,
						   const BOOL fNoLoopBack,
						   const BOOL fRequest,
						   CAsyncOp *const pParent,
						   CAsyncOp **const ppParent);

HRESULT DNPerformMultiSend(DIRECTNETOBJECT *const pdnObject,
						   const DPNHANDLE hParentOp,
						   CConnection *const pConnection,
						   const DWORD dwTimeOut);

HRESULT DNCreateSendParent(DIRECTNETOBJECT *const pdnObject,
						   const DWORD dwMsgId,
						   const DPN_BUFFER_DESC *const pdnBufferDesc,
						   const DWORD dwSendFlags,
						   CAsyncOp **const ppParent);

HRESULT DNPerformChildSend(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp *const pParent,
						   CConnection *const pConnection,
						   const DWORD dwTimeOut,
						   CAsyncOp **const ppChild,
						   const BOOL fInternal);

HRESULT DNFinishMultiOp(DIRECTNETOBJECT *const pdnObject,const DPNHANDLE hRootOp);

HRESULT DNProcessInternalOperation(DIRECTNETOBJECT *const pdnObject,
								   const DWORD dwMsgId,
								   void *const pOpBuffer,
								   const DWORD dwOpBufferSize,
								   CConnection *const pConnection,
								   const HANDLE hProtocol,
								   CRefCountBuffer *const pRefCountBuffer);

HRESULT DNPerformRequest(DIRECTNETOBJECT *const pdnObject,
						 const DWORD dwMsgId,
						 const DPN_BUFFER_DESC *const pBufferDesc,
						 CConnection *const pConnection,
						 CAsyncOp *const pParent,
						 CAsyncOp **const ppRequest);

HRESULT DNReceiveCompleteOnProcess(DIRECTNETOBJECT *const pdnObject,
								   CConnection *const pConnection,
								   void *const pBufferData,
								   const DWORD dwBufferSize,
								   const HANDLE hProtocol,
								   CRefCountBuffer *const pOrigRefCountBuffer);

HRESULT DNReceiveCompleteOnProcessReply(DIRECTNETOBJECT *const pdnObject,
										void *const pBufferData,
										const DWORD dwBufferSize);

HRESULT DNProcessTerminateSession(DIRECTNETOBJECT *const pdnObject,
								  void *const pvBuffer,
								  const DWORD dwBufferSize);

//**********************************************************************
// Class prototypes
//**********************************************************************


#endif	// __ASYNC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\asyncop.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       AsyncOp.cpp
 *  Content:    Async Operation routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  04/08/00	mjn		Created
 *	04/11/00	mjn		Added DIRECTNETOBJECT bilink for CAsyncOps
 *	05/02/00	mjn		Added m_pConnection to track Connection over life of AsyncOp
 *	07/27/00	mjn		Changed locking for parent/child bilinks
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//	CAsyncOp::ReturnSelfToPool
//
//	Return object to FPM

#undef DPF_MODNAME
#define DPF_MODNAME "CAsyncOp::ReturnSelfToPool"

void CAsyncOp::ReturnSelfToPool( void )
{
	m_pdnObject->m_pFPOOLAsyncOp->Release( this );
}



#undef DPF_MODNAME
#define DPF_MODNAME "CAsyncOp::Release"

void CAsyncOp::Release(void)
{
	LONG	lRefCount;

	DNASSERT(m_lRefCount > 0);
	lRefCount = InterlockedDecrement(const_cast<LONG*>(&m_lRefCount));

	DPFX(DPFPREP, 3,"CAsyncOp::Release [0x%p] RefCount [0x%lx]",this,lRefCount);

	if (lRefCount == 0)
	{
		DNASSERT( m_bilinkActiveList.IsEmpty() );

		//
		//	Remove from the bilink of outstanding AsyncOps
		//
		DNEnterCriticalSection(&m_pdnObject->csAsyncOperations);
		Lock();
		m_bilinkAsyncOps.RemoveFromList();
		DNLeaveCriticalSection(&m_pdnObject->csAsyncOperations);
		Unlock();

		if (m_pfnCompletion)
		{
			(m_pfnCompletion)(m_pdnObject,this);
			m_pfnCompletion = NULL;
		}
		if (m_phr)
		{
			*m_phr = m_hr;
		}
		if (m_pSyncEvent)
		{
			m_pSyncEvent->Set();
			m_pSyncEvent = NULL;
		}
		if (m_pRefCountBuffer)
		{
			m_pRefCountBuffer->Release();
			m_pRefCountBuffer = NULL;
		}
		if (m_pConnection)
		{
			m_pConnection->Release();
			m_pConnection = NULL;
		}
		if (m_pSP)
		{
			m_pSP->Release();
			m_pSP = NULL;
		}
		if (m_pParent)
		{
			Orphan();
			m_pParent->Release();
			m_pParent = NULL;
		}
		m_dwFlags = 0;
		m_lRefCount = 0;
		ReturnSelfToPool();
	}
};



#undef DPF_MODNAME
#define DPF_MODNAME "CAsyncOp::Orphan"

void CAsyncOp::Orphan( void )
{
	if (m_pParent)
	{
		m_pParent->Lock();
		m_bilinkChildren.RemoveFromList();
		m_pParent->Unlock();
	}
}



#undef DPF_MODNAME
#define DPF_MODNAME "CAsyncOp::SetConnection"

void CAsyncOp::SetConnection( CConnection *const pConnection )
{
	if (pConnection)
	{
		pConnection->AddRef();
	}
	m_pConnection = pConnection;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CAsyncOp::SetSP"

void CAsyncOp::SetSP( CServiceProvider *const pSP )
{
	if (pSP)
	{
		pSP->AddRef();
	}
	m_pSP = pSP;
}



#undef DPF_MODNAME
#define DPF_MODNAME "CAsyncOp::SetRefCountBuffer"

void CAsyncOp::SetRefCountBuffer( CRefCountBuffer *const pRefCountBuffer )
{
	if (pRefCountBuffer)
	{
		pRefCountBuffer->AddRef();
	}
	m_pRefCountBuffer = pRefCountBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\callbackthread.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       CallbackThread.h
 *  Content:    Callback Thread Object Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/05/01	mjn		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__CALLBACK_THREAD_H__
#define	__CALLBACK_THREAD_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_CORE


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	OFFSETOF
#define OFFSETOF(s,m)				( ( INT_PTR ) ( ( PVOID ) &( ( (s*) 0 )->m ) ) )
#endif

#ifndef	CONTAINING_OBJECT
#define	CONTAINING_OBJECT(b,t,m)	(reinterpret_cast<t*>(&reinterpret_cast<BYTE*>(b)[-OFFSETOF(t,m)]))
#endif

//**********************************************************************
// Structure definitions
//**********************************************************************

class CCallbackThread;

typedef struct _DIRECTNETOBJECT DIRECTNETOBJECT;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for Callback Thread objects

class CCallbackThread
{
public:
	CCallbackThread()		// Constructor
		{
			m_Sig[0] = 'C';
			m_Sig[1] = 'A';
			m_Sig[2] = 'L';
			m_Sig[3] = 'L';

			m_bilinkCallbackThreads.Initialize();
			m_dwThreadID = GetCurrentThreadId();
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CCallbackThread::~CCallbackThread"
	~CCallbackThread()		// Destructor
		{
			DNASSERT( m_bilinkCallbackThreads.IsEmpty() );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CCallbackThread::IsCurrentThread"
	BOOL IsCurrentThread( void )
		{
			if ( GetCurrentThreadId() == m_dwThreadID )
			{
				return( TRUE );
			}
			return( FALSE );
		};

	CBilink				m_bilinkCallbackThreads;

private:
	BYTE				m_Sig[4];			// Signature
	DWORD				m_dwThreadID;
};

#undef DPF_MODNAME

#endif	// __CALLBACK_THREAD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\cancel.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Cancel.cpp
 *  Content:    DirectNet Cancel Operations
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  04/07/00	mjn		Created
 *	04/08/00	mjn		Added DNCancelEnum(), DNCancelSend()
 *	04/11/00	mjn		DNCancelEnum() uses CAsyncOp
 *	04/17/00	mjn		DNCancelSend() uses CAsyncOp
 *	04/25/00	mjn		Added DNCancelConnect()
 *	07/05/00	mjn		Added code to handle invalid async ops
 *	07/08/00	mjn		Fixed CAsyncOp to contain m_bilinkParent
 *	08/05/00	mjn		Added DNCancelChildren(),DNCancelActiveCommands(),DNCanCancelCommand()
 *				mjn		Removed DNCancelEnum(),DNCancelListen(),DNCancelSend(),DNCancelConnect()
 *	08/07/00	mjn		Added DNCancelRequestCommands()
 *	08/22/00	mjn		Remove cancelled receive buffers from the active list in DNDoCancelCommand()
 *	09/02/00	mjn		Cancel active commands in reverse order (to prevent out of order messages at protocol level)
 *	01/10/01	mjn		Allow DNCancelActiveCommands() to set result code of cancelled commands
 *	02/08/01	mjn		Use SyncEvents on AsyncOps to prevent protocol completions from returning before cancels return
 *				mjn		Added DNWaitForCancel()
 *	04/13/01	mjn		DNCancelRequestCommands() uses request bilink
 *	05/23/01	mjn		Only cancel commands that are allowed to be cancelled in DNDoCancelCommand()
 *	06/03/01	mjn		Ignore uncancelable children in DNCancelChildren()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//	DNCanCancelCommand
//
//	This will determine if an operation is cancelable based on the selection flags

#undef DPF_MODNAME
#define DPF_MODNAME "DNCanCancelCommand"

BOOL DNCanCancelCommand(CAsyncOp *const pAsyncOp,
						const DWORD dwFlags)
{
	BOOL	fReturnVal;

	DPFX(DPFPREP, 8,"Parameters: pAsyncOp [0x%p], dwFlags [0x%lx]",pAsyncOp,dwFlags);

	DNASSERT(pAsyncOp != NULL);

	fReturnVal = FALSE;
	switch(pAsyncOp->GetOpType())
	{
		case ASYNC_OP_CONNECT:
			{
				if (dwFlags & DN_CANCEL_FLAG_CONNECT)
				{
					fReturnVal = TRUE;
				}
				break;
			}
		case ASYNC_OP_DISCONNECT:
			{
				if (dwFlags & DN_CANCEL_FLAG_DISCONNECT)
				{
					fReturnVal = TRUE;
				}
				break;
			}
		case ASYNC_OP_ENUM_QUERY:
			{
				if (dwFlags & DN_CANCEL_FLAG_ENUM_QUERY)
				{
					fReturnVal = TRUE;
				}
				break;
			}
		case ASYNC_OP_ENUM_RESPONSE:
			{
				if (dwFlags & DN_CANCEL_FLAG_ENUM_RESPONSE)
				{
					fReturnVal = TRUE;
				}
				break;
			}
		case ASYNC_OP_LISTEN:
			{
				if (dwFlags & DN_CANCEL_FLAG_LISTEN)
				{
					fReturnVal = TRUE;
				}
				break;
			}
		case ASYNC_OP_SEND:
			{
				if (pAsyncOp->IsInternal())
				{
					if (dwFlags & DN_CANCEL_FLAG_INTERNAL_SEND)
					{
						fReturnVal = TRUE;
					}
				}
				else
				{
					if (dwFlags & DN_CANCEL_FLAG_USER_SEND)
					{
						fReturnVal = TRUE;
					}
				}
				break;
			}
		case ASYNC_OP_RECEIVE_BUFFER:
			{
				if (dwFlags & DN_CANCEL_FLAG_RECEIVE_BUFFER)
				{
					fReturnVal = TRUE;
				}
				break;
			}
		case ASYNC_OP_REQUEST:
			{
				break;
			}
		default:
			{
				break;
			}
	}
	DPFX(DPFPREP, 8,"Returning: [%ld]",fReturnVal);
	return(fReturnVal);
}


//	DNDoCancelCommand
//
//	This will attempt to cancel a given operation based on its OpType

#undef DPF_MODNAME
#define DPF_MODNAME "DNDoCancelCommand"

HRESULT DNDoCancelCommand(DIRECTNETOBJECT *const pdnObject,
						  CAsyncOp *const pAsyncOp)
{
	HRESULT		hResultCode;

	DPFX(DPFPREP, 8,"Parameters: pAsyncOp [0x%p]",pAsyncOp);

	hResultCode = DPNERR_CANNOTCANCEL;

	switch(pAsyncOp->GetOpType())
	{
		case ASYNC_OP_CONNECT:
		case ASYNC_OP_ENUM_QUERY:
		case ASYNC_OP_ENUM_RESPONSE:
		case ASYNC_OP_LISTEN:
		case ASYNC_OP_SEND:
			{
				HANDLE	hProtocol;
				BOOL	fCanCancel;

				DNASSERT(pdnObject->pdnProtocolData != NULL );

				//
				//	If this operation has been marked as not cancellable,
				//	we will return an error
				//
				pAsyncOp->Lock();
				hProtocol = pAsyncOp->GetProtocolHandle();
				fCanCancel = !pAsyncOp->IsCannotCancel();
				pAsyncOp->Unlock();

				if (fCanCancel && (hProtocol != NULL))
				{
					DPFX(DPFPREP, 9,"Attempting to cancel AsyncOp [0x%p]",pAsyncOp);
					hResultCode = DNPCancelCommand(pdnObject->pdnProtocolData,hProtocol);
					DPFX(DPFPREP, 9,"Result of cancelling AsyncOp [0x%p] was [0x%lx]",pAsyncOp,hResultCode);
				}
				else
				{
					DPFX(DPFPREP,9,"Not allowed to cancel this operation");
					hResultCode = DPNERR_CANNOTCANCEL;
				}
				break;
			}
		case ASYNC_OP_RECEIVE_BUFFER:
			{
				if (pAsyncOp->GetHandle() != 0)
				{
					if ((hResultCode = pdnObject->HandleTable.Destroy( pAsyncOp->GetHandle() )) == DPN_OK)
					{
						//
						//	Remove from active list
						//
						DNEnterCriticalSection(&pdnObject->csActiveList);
						pAsyncOp->m_bilinkActiveList.RemoveFromList();
						DNLeaveCriticalSection(&pdnObject->csActiveList);
					}
					else
					{
						hResultCode = DPNERR_CANNOTCANCEL;
					}
				}
				break;
			}
//		case ASYNC_OP_DISCONNECT:
		case ASYNC_OP_REQUEST:
		default:
			{
				DNASSERT(FALSE);
				break;
			}
	}

	DPFX(DPFPREP, 8,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DNCancelChildren
//
//	This will mark an operation as CANCELLED to prevent new children from attaching,
//	build a cancel list of any children, and recursively call itself to cancel those children.
//	At the bottom level, if there is a Protocol handle, we will actually call DNPCancelCommand() 

#undef DPF_MODNAME
#define DPF_MODNAME "DNCancelChildren"

HRESULT DNCancelChildren(DIRECTNETOBJECT *const pdnObject,
						 CAsyncOp *const pParent)
{
	HRESULT		hResultCode;
	CBilink		*pBilink;
	CAsyncOp	*pAsyncOp;
	CAsyncOp	**CancelList;
	CSyncEvent	*pSyncEvent;
	DWORD		dwCount;
	DWORD		dwActual;

	DPFX(DPFPREP, 6,"Parameters: pParent [0x%p]",pParent);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pParent != NULL);

	pAsyncOp = NULL;
	CancelList = NULL;
	pSyncEvent = NULL;

	//
	//	Mark the parent as cancelled so that no new children can attach
	//
	pParent->Lock();
	if (pParent->IsCancelled() || pParent->IsComplete() || pParent->IsCannotCancel())
	{
		pParent->Unlock();
		DPFX(DPFPREP, 7,"Ignoring pParent [0x%p]",pParent);
		hResultCode = DPN_OK;
		goto Exit;
	}
	pParent->SetCancelled();

	//
	//	Determine size of cancel list
	//
	dwCount = 0;
	pBilink = pParent->m_bilinkParent.GetNext();
	while (pBilink != &pParent->m_bilinkParent)
	{
		pAsyncOp = CONTAINING_OBJECT(pBilink,CAsyncOp,m_bilinkChildren);
		pAsyncOp->Lock();
		if (!pAsyncOp->IsCancelled() && !pAsyncOp->IsComplete())
		{
			dwCount++;
		}
		pAsyncOp->Unlock();
		pBilink = pBilink->GetNext();
	}
	DPFX(DPFPREP, 7,"Number of cancellable children [%ld]",dwCount);

	//
	//	Create cancel list
	//
	if (dwCount > 0)
	{
		if ((CancelList = static_cast<CAsyncOp**>(DNMalloc(dwCount * sizeof(CAsyncOp*)))) == NULL)
		{
#pragma BUGBUG( minara, "Should we unflag the cancel ?" )
			pParent->Unlock();
			DPFERR("Could not allocate space for cancel list");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		dwActual = 0;
		pBilink = pParent->m_bilinkParent.GetNext();
		while (pBilink != &pParent->m_bilinkParent)
		{
			pAsyncOp = CONTAINING_OBJECT(pBilink,CAsyncOp,m_bilinkChildren);
			pAsyncOp->Lock();
			if (!pAsyncOp->IsCancelled() && !pAsyncOp->IsComplete())
			{
				DNASSERT(dwActual < dwCount);	// This list should NEVER grow !
				pAsyncOp->AddRef();
				CancelList[dwActual] = pAsyncOp;
				dwActual++;
			}
			pAsyncOp->Unlock();
			pBilink = pBilink->GetNext();
		}
		DPFX(DPFPREP, 7,"Actual number of cancellable children [%ld]",dwActual);
	}

	//
	//	Attach a sync event if this is a protocol operation
	//	This event may be cleared by the completion
	//
	if (pParent->GetProtocolHandle() != NULL)
	{
		if ((hResultCode = SyncEventNew(pdnObject,&pSyncEvent)) != DPN_OK)
		{
			DPFERR("Could not get new sync event");
			DisplayDNError(0,hResultCode);
		}
		else
		{
			pSyncEvent->Reset();
			pParent->SetCancelEvent( pSyncEvent );
			pParent->SetCancelThreadID( GetCurrentThreadId() );
			DPFX(DPFPREP,7,"Setting sync event [0x%p]",pSyncEvent);
		}
	}

	pParent->Unlock();

	//
	//	Preset the return
	//
	hResultCode = DPN_OK;

	//
	//	Call ourselves with each of the children (if there are any)
	//	and clean up (release AsyncOp children and free list)
	//
	if (CancelList)
	{
		DWORD	dw;
		HRESULT	hr;

		for (dw = 0 ; dw < dwActual ; dw++ )
		{
			hr = DNCancelChildren(pdnObject,CancelList[dw]);
			if ((hr != DPN_OK) && (hResultCode == DPN_OK))
			{
				hResultCode = hr;
			}
			CancelList[dw]->Release();
			CancelList[dw] = NULL;
		}
		DNFree(CancelList);
		CancelList = NULL;
	}

	//
	//	Cancel this operation (if we can)
	//	This will only work for CONNECTs,DISCONNECTs,ENUM_QUERYs,ENUM_RESPONSEs,LISTENs,SENDs with a protocol handle
	//
	if (pParent->GetProtocolHandle() != NULL)
	{
		HRESULT	hr;

		hr = DNDoCancelCommand(pdnObject,pParent);
		if ((hr != DPN_OK) && (hResultCode == DPN_OK))
		{
			hResultCode = hr;
		}
	}

	//
	//	Set the cancel event and clear it from the async op if it's still there
	//
	if (pSyncEvent)
	{
		pSyncEvent->Set();

		pParent->Lock();
		pSyncEvent = pParent->GetCancelEvent();
		pParent->SetCancelEvent( NULL );
		pParent->Unlock();

		if (pSyncEvent)
		{
			DPFX(DPFPREP,7,"Returning sync event [0x%p]",pSyncEvent);
			pSyncEvent->ReturnSelfToPool();
			pSyncEvent = NULL;
		}
	}

Exit:
	DNASSERT( pSyncEvent == NULL );

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (CancelList)
	{
		DNFree(CancelList);
		CancelList = NULL;
	}
	goto Exit;
}


//	DNCancelActiveCommands
//
//	This will attempt to cancel ALL operations in the active list.

#undef DPF_MODNAME
#define DPF_MODNAME "DNCancelActiveCommands"

HRESULT DNCancelActiveCommands(DIRECTNETOBJECT *const pdnObject,
							   const DWORD dwFlags,
							   const BOOL fSetResult,
							   const HRESULT hrCancel)
{
	HRESULT		hResultCode;
	CAsyncOp	*pAsyncOp;
	CAsyncOp	**CancelList;
	CBilink		*pBilink;
	DWORD		dwCount;
	DWORD		dwActual;

	DPFX(DPFPREP, 6,"Parameters: dwFlags [0x%lx], fSetResult [%ld], hrCancel [0x%lx]",dwFlags,fSetResult,hrCancel);

	DNASSERT(pdnObject != NULL);

	CancelList = NULL;

	//
	//	Prevent changes
	//
	DNEnterCriticalSection(&pdnObject->csActiveList);

	//
	//	Determine size of cancel list
	//
	dwCount = 0;
	pBilink = pdnObject->m_bilinkActiveList.GetPrev();
	while (pBilink != &pdnObject->m_bilinkActiveList)
	{
		pAsyncOp = CONTAINING_OBJECT(pBilink,CAsyncOp,m_bilinkActiveList);
		if (DNCanCancelCommand(pAsyncOp,dwFlags))
		{
			pAsyncOp->Lock();
			if (!pAsyncOp->IsCancelled() && !pAsyncOp->IsComplete())
			{
				dwCount++;
			}
			pAsyncOp->Unlock();
		}
		pBilink = pBilink->GetPrev();
	}
	DPFX(DPFPREP, 7,"Number of cancellable ops [%ld]",dwCount);

	//
	//	Create cancel list
	//
	if (dwCount > 0)
	{
		if ((CancelList = static_cast<CAsyncOp**>(DNMalloc(dwCount * sizeof(CAsyncOp*)))) == NULL)
		{
			DNLeaveCriticalSection(&pdnObject->csActiveList);
			DPFERR("Could not allocate space for cancel list");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		dwActual = 0;
		pBilink = pdnObject->m_bilinkActiveList.GetPrev();
		while (pBilink != &pdnObject->m_bilinkActiveList)
		{
			pAsyncOp = CONTAINING_OBJECT(pBilink,CAsyncOp,m_bilinkActiveList);
			if (DNCanCancelCommand(pAsyncOp,dwFlags))
			{
				pAsyncOp->Lock();
				if (!pAsyncOp->IsCancelled() && !pAsyncOp->IsComplete())
				{
					DNASSERT(dwActual < dwCount);	// This list should NEVER grow !
					pAsyncOp->AddRef();
					CancelList[dwActual] = pAsyncOp;
					dwActual++;
				}
				pAsyncOp->Unlock();
			}
			pBilink = pBilink->GetPrev();
		}
		DPFX(DPFPREP, 7,"Actual number of cancellable ops [%ld]",dwActual);
	}

	//
	//	Allow changes, though the list should not grow any more here
	//
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	//
	//	Preset the return
	//
	hResultCode = DPN_OK;

	//
	//	Cancel each operation in the cancel list operation (if we can)
	//	This will only work for CONNECTs,DISCONNECTs,ENUM_QUERYs,ENUM_RESPONSEs,LISTENs,SENDs with a protocol handle
	//
	if (CancelList)
	{
		DWORD	dw;
		HRESULT	hr;
		CSyncEvent	*pSyncEvent;

		pSyncEvent = NULL;

		for (dw = 0 ; dw < dwActual ; dw++ )
		{
			//
			//	Ensure operation has not already been cancelled
			//	If this is a protocol operation, we will add a sync event to prevent any completions from returning
			//	until we're done
			//
			DNASSERT( CancelList[dw] != NULL );
			CancelList[dw]->Lock();
			if (CancelList[dw]->IsCancelled() || CancelList[dw]->IsComplete())
			{
				CancelList[dw]->Unlock();
				CancelList[dw]->Release();
				CancelList[dw] = NULL;
				continue;
			}
			if (CancelList[dw]->GetProtocolHandle() != NULL)
			{
				if ((hr = SyncEventNew(pdnObject,&pSyncEvent)) != DPN_OK)
				{
					DPFERR("Could not get sync event");
					DisplayDNError(0,hr);
				}
				else
				{
					pSyncEvent->Reset();
					CancelList[dw]->SetCancelEvent( pSyncEvent );
					CancelList[dw]->SetCancelThreadID( GetCurrentThreadId() );
					DPFX(DPFPREP,7,"Setting sync event [0x%p]",pSyncEvent);
				}
			}
						
			CancelList[dw]->SetCancelled();
			CancelList[dw]->Unlock();

			//
			//	Perform the actual cancel
			//
			hr = DNDoCancelCommand(pdnObject,CancelList[dw]);
			if ((hr != DPN_OK) && (hResultCode == DPN_OK))
			{
				hResultCode = hr;
			}

			//
			//	If this operation was cancelled and we need to set the result, we will
			//
			if ((hr == DPN_OK) && fSetResult)
			{
				CancelList[dw]->Lock();
				CancelList[dw]->SetResult( hrCancel );
				CancelList[dw]->Unlock();
			}

			//
			//	Set the cancel event and clear it from the async op if it's still there
			//
			if (pSyncEvent)
			{
				pSyncEvent->Set();

				CancelList[dw]->Lock();
				pSyncEvent = CancelList[dw]->GetCancelEvent();
				CancelList[dw]->SetCancelEvent( NULL );
				CancelList[dw]->Unlock();

				if (pSyncEvent)
				{
					DPFX(DPFPREP,7,"Returning sync event [0x%p]",pSyncEvent);
					pSyncEvent->ReturnSelfToPool();
					pSyncEvent = NULL;
				}
			}

			CancelList[dw]->Release();
			CancelList[dw] = NULL;
		}
		DNFree(CancelList);
		CancelList = NULL;

		DNASSERT(pSyncEvent == NULL);
	}

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (CancelList)
	{
		DNFree(CancelList);
		CancelList = NULL;
	}
	goto Exit;
}


//	DNCancelRequestCommands
//
//	This will attempt to cancel REQUEST operations in the HandleTable.
//	Requests have handles which are matched up against responses.  Since these
//	typically have SEND children (which may have completed and thus vanished),
//	there is no guarantee these are not orphaned off in the HandleTable.
//	We will look through the HandleTable for them and cancel them.

#undef DPF_MODNAME
#define DPF_MODNAME "DNCancelRequestCommands"

HRESULT DNCancelRequestCommands(DIRECTNETOBJECT *const pdnObject)
{
	HRESULT		hResultCode;
	CAsyncOp	**RequestList;
	DWORD		dwCount;
	DWORD		dwActual;
	CBilink		*pBilink;

	DPFX(DPFPREP, 6,"Parameters: (none)");

	DNASSERT(pdnObject != NULL);

	RequestList = NULL;

	dwCount = 0;
	dwActual = 0;

	//
	//	Determine outstanding request list size and build it
	//
	DNEnterCriticalSection(&pdnObject->csActiveList);
	pBilink = pdnObject->m_bilinkRequestList.GetNext();
	while (pBilink != &pdnObject->m_bilinkRequestList)
	{
		dwCount++;
		pBilink = pBilink->GetNext();
	}
	if (dwCount > 0)
	{
		CAsyncOp	*pAsyncOp;

		if ((RequestList = static_cast<CAsyncOp**>(MemoryBlockAlloc(pdnObject,dwCount * sizeof(CAsyncOp*)))) == NULL)
		{
			DNLeaveCriticalSection(&pdnObject->csAsyncOperations);
			DPFERR("Could not allocate request list");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		pBilink = pdnObject->m_bilinkRequestList.GetNext();
		while (pBilink != &pdnObject->m_bilinkRequestList)
		{
			pAsyncOp = CONTAINING_OBJECT(pBilink,CAsyncOp,m_bilinkActiveList);
			DNASSERT(dwActual < dwCount);
			DNASSERT(pAsyncOp->GetOpType() == ASYNC_OP_REQUEST);
			pAsyncOp->AddRef();
			RequestList[dwActual] = pAsyncOp;
			pAsyncOp = NULL;
			dwActual++;
			pBilink = pBilink->GetNext();
		}
	}
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	//
	//	Remove requests from request list and handle table
	//
	for (dwActual = 0 ; dwActual < dwCount ; dwActual++)
	{
		DNEnterCriticalSection(&pdnObject->csActiveList);
		RequestList[dwActual]->m_bilinkActiveList.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csActiveList);

		RequestList[dwActual]->Lock();
		RequestList[dwActual]->SetResult( DPNERR_USERCANCEL );
		RequestList[dwActual]->Unlock();
		if (RequestList[dwActual]->GetHandle())
		{
			pdnObject->HandleTable.Destroy(RequestList[dwActual]->GetHandle());
		}
		RequestList[dwActual]->Release();
		RequestList[dwActual] = NULL;
	}

	//
	//	Clean up
	//
	if (RequestList)
	{
		MemoryBlockFree(pdnObject,RequestList);
		RequestList = NULL;
	}
	hResultCode = DPN_OK;

Exit:
	DNASSERT(RequestList == NULL);

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (RequestList)
	{
		MemoryBlockFree(pdnObject,RequestList);
		RequestList = NULL;
	}
	goto Exit;
}


//	DNWaitForCancel
//
//	This will strip a cancel event off an async op if it exists, wait on it, and then return it to the pool

#undef DPF_MODNAME
#define DPF_MODNAME "DNWaitForCancel"

void DNWaitForCancel(DIRECTNETOBJECT *const pdnObject,
					 CAsyncOp *const pAsyncOp)
{
	DPFX(DPFPREP, 6,"Parameters: pAsyncOp [0x%p]",pAsyncOp);

	CSyncEvent	*pSyncEvent;

	DNASSERT(pdnObject != NULL);
	DNASSERT(pAsyncOp != NULL);

	pSyncEvent = NULL;

	//
	//	Get (and clear) sync event from async op
	//
	pAsyncOp->Lock();
	pSyncEvent = pAsyncOp->GetCancelEvent();
	if (pSyncEvent)
	{
		// Only pull the SyncEvent out if we are going to wait on it
		if (pAsyncOp->GetCancelThreadID() == GetCurrentThreadId())
		{
			// The other side of this will clean it up
			DPFX(DPFPREP,7,"Cancel called on current thread - ignoring wait and continuing");
			pSyncEvent = NULL;
		}
		else
		{
			// We are pulling it out, so we will clean it up
			pAsyncOp->SetCancelEvent( NULL );
		}
	}
	pAsyncOp->Unlock();

	//
	//	If there was a sync event,
	//		- wait on it
	//		- return it to the pool
	//
	if (pSyncEvent)
	{
		DPFX(DPFPREP,7,"Waiting on sync event [0x%p]",pSyncEvent);
		pSyncEvent->WaitForEvent(INFINITE);

		DPFX(DPFPREP,7,"Returning sync event [0x%p]",pSyncEvent);
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}

	DNASSERT(pSyncEvent == NULL);

	DPFX(DPFPREP, 6,"Returning");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\asyncop.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       AsyncOp.h
 *  Content:    Async Operation Object Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  04/08/00	mjn		Created
 *	04/11/00	mjn		Added DIRECTNETOBJECT bilink for CAsyncOps
 *	04/16/00	mjn		Added ASYNC_OP_SEND and ASYNC_OP_USER_HANDLE
 *				mjn		Added SetStartTime() and GetStartTime()
 *	04/20/00	mjn		Added ASYNC_OP_RECEIVE_BUFFER
 *	04/22/00	mjn		Added ASYNC_OP_REQUEST
 *	05/02/00	mjn		Added m_pConnection to track Connection over life of AsyncOp
 *	07/08/00	mjn		Added m_bilinkParent
 *	07/17/00	mjn		Added signature to CAsyncOp
 *	07/27/00	mjn		Added m_dwReserved and changed locking for parent/child bilinks
 *	08/05/00	mjn		Added ASYNC_OP_COMPLETE,ASYNC_OP_CANCELLED,ASYNC_OP_INTERNAL flags
 *				mjn		Added m_bilinkActiveList
 *	01/09/01	mjn		Added ASYNC_OP_CANNOT_CANCEL,SetCannotCancel(),IsCannotCancel()
 *	02/08/01	mjn		Added m_pCancelEvent,m_dwCancelThreadID
 *	05/23/01	mjn		Added ClearCannotCancel()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__ASYNC_OP_H__
#define	__ASYNC_OP_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_CORE


//**********************************************************************
// Constant definitions
//**********************************************************************

#define	ASYNC_OP_CHILD			0x0001
#define	ASYNC_OP_PARENT			0x0002
#define	ASYNC_OP_CANNOT_CANCEL	0x0010
#define	ASYNC_OP_COMPLETE		0x0100
#define	ASYNC_OP_CANCELLED		0x0200
#define	ASYNC_OP_INTERNAL		0x8000

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	OFFSETOF
#define OFFSETOF(s,m)				( ( INT_PTR ) ( ( PVOID ) &( ( (s*) 0 )->m ) ) )
#endif

#ifndef	CONTAINING_OBJECT
#define	CONTAINING_OBJECT(b,t,m)	(reinterpret_cast<t*>(&reinterpret_cast<BYTE*>(b)[-OFFSETOF(t,m)]))
#endif

//**********************************************************************
// Structure definitions
//**********************************************************************

class CAsyncOp;
template< class CAsyncOp > class CLockedContextClassFixedPool;

typedef enum
{
	ASYNC_OP_CONNECT,
	ASYNC_OP_DISCONNECT,
	ASYNC_OP_ENUM_QUERY,
	ASYNC_OP_ENUM_RESPONSE,
	ASYNC_OP_LISTEN,
	ASYNC_OP_SEND,
	ASYNC_OP_RECEIVE_BUFFER,
	ASYNC_OP_REQUEST,
	ASYNC_OP_UNKNOWN,
	ASYNC_OP_USER_HANDLE
} ASYNC_OP_TYPE;

class CConnection;
class CRefCountBuffer;
class CServiceProvider;
class CSyncEvent;

typedef struct _DIRECTNETOBJECT DIRECTNETOBJECT;

typedef void (*PFNASYNCOP_COMPLETE)(DIRECTNETOBJECT *const,CAsyncOp *const);

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for Async Operations

class CAsyncOp
{
public:
	CAsyncOp()					// Constructor
		{
			m_Sig[0] = 'A';
			m_Sig[1] = 'S';
			m_Sig[2] = 'Y';
			m_Sig[3] = 'N';

			m_dwReserved = 0;
		};

	~CAsyncOp() { };			// Destructor

	BOOL FPMAlloc(void *const pvContext)
		{
			m_pdnObject = static_cast<DIRECTNETOBJECT*>(pvContext);

			if (!DNInitializeCriticalSection(&m_cs))
			{
				return(FALSE);
			}

			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CAsyncOp::FPMInitialize"
	BOOL FPMInitialize(void *const pvContext)
		{
			DNASSERT(m_pdnObject == pvContext);
			m_dwFlags = 0;
			m_lRefCount = 1;

			m_OpType = ASYNC_OP_UNKNOWN;

			m_pParent = NULL;

			m_handle = 0;
			m_dwOpFlags = 0;
			m_pvContext = NULL;
			m_hProtocol = NULL;
			m_pvOpData = NULL;

			m_dwStartTime = 0;
			m_dpnid = 0;

			m_hr = DPNERR_GENERIC;
			m_phr = NULL;

			m_pConnection = NULL;
			m_pSP = NULL;
			m_pRefCountBuffer = NULL;
			m_pSyncEvent = NULL;

			m_pCancelEvent = NULL;
			m_dwCancelThreadID = 0;

			m_pfnCompletion = NULL;

//			m_dwReserved = 0;

			m_bilinkAsyncOps.Initialize();
			m_bilinkActiveList.Initialize();
			m_bilinkParent.Initialize();
			m_bilinkChildren.Initialize();

			return(TRUE);
		};

	void FPMRelease(void *const pvContext)
		{
			m_dwFlags |= 0xffff0000;
		};

	void FPMDealloc(void *const pvContext)
		{
			DNDeleteCriticalSection(&m_cs);
		};

	void ReturnSelfToPool( void );

	#undef DPF_MODNAME
	#define DPF_MODNAME "CAsyncOp::AddRef"
	void AddRef(void)
		{
			LONG	lRefCount;

			DNASSERT(m_lRefCount > 0);
			lRefCount = InterlockedIncrement(const_cast<LONG*>(&m_lRefCount));
			DPFX(DPFPREP, 3,"CAsyncOp::AddRef [0x%lx] RefCount [0x%lx]",this,lRefCount);
		};

	void CAsyncOp::Release( void );

	void Lock( void )
		{
			DNEnterCriticalSection( &m_cs );
		};

	void Unlock( void )
		{
			DNLeaveCriticalSection( &m_cs );
		};

	void SetOpType( const ASYNC_OP_TYPE OpType )
		{
			m_OpType = OpType;
		};

	ASYNC_OP_TYPE GetOpType( void )
		{
			return( m_OpType );
		};

	void MakeParent( void )
		{
			m_dwFlags |= ASYNC_OP_PARENT;
		};

	BOOL IsParent( void )
		{
			if (m_dwFlags & ASYNC_OP_PARENT)
				return(TRUE);

			return(FALSE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CAsyncOp::MakeChild"
	void MakeChild( CAsyncOp *const pParent )
		{
			DNASSERT(pParent != NULL);

			pParent->AddRef();
			m_pParent = pParent;

			m_bilinkChildren.InsertBefore(&m_pParent->m_bilinkParent);

			m_dwFlags |= ASYNC_OP_CHILD;
		};

	BOOL IsChild( void )
		{
			if (m_dwFlags & ASYNC_OP_CHILD)
				return(TRUE);

			return(FALSE);
		};

	CAsyncOp *GetParent( void )
		{
			return( m_pParent );
		};

	void CAsyncOp::Orphan( void );

	void SetHandle( const DPNHANDLE handle )
		{
			m_handle = handle;
		};

	DPNHANDLE GetHandle( void )
		{
			return( m_handle );
		};

	void SetOpFlags( const DWORD dwOpFlags )
		{
			m_dwOpFlags = dwOpFlags;
		};

	DWORD GetOpFlags( void )
		{
			return( m_dwOpFlags );
		};

	void SetContext( void *const pvContext )
		{
			m_pvContext = pvContext;
		};

	void *GetContext( void )
		{
			return( m_pvContext );
		};

	void SetProtocolHandle( const HANDLE hProtocol )
		{
			m_hProtocol = hProtocol;
		};

	HANDLE GetProtocolHandle( void )
		{
			return( m_hProtocol );
		};

	void SetOpData( void *const pvOpData )
		{
			m_pvOpData = pvOpData;
		};

	void *GetOpData( void )
		{
			return( m_pvOpData );
		};

	void SetStartTime( const DWORD dwStartTime )
		{
			m_dwStartTime = dwStartTime;
		};

	DWORD GetStartTime( void )
		{
			return( m_dwStartTime );
		};

	void SetDPNID( const DPNID dpnid )
		{
			m_dpnid = dpnid;
		};

	DPNID GetDPNID( void )
		{
			return( m_dpnid );
		};

	void SetResult( const HRESULT hr )
		{
			m_hr = hr;
		};

	HRESULT GetResult( void )
		{
			return( m_hr );
		};

	void SetResultPointer( volatile HRESULT *const phr )
		{
			m_phr = phr;
		};

	volatile HRESULT *GetResultPointer( void )
		{
			return( m_phr );
		};

	void CAsyncOp::SetConnection( CConnection *const pConnection );

	CConnection *GetConnection (void )
		{
			return( m_pConnection );
		};

	void CAsyncOp::SetSP( CServiceProvider *const pSP );

	CServiceProvider *GetSP( void )
		{
			return( m_pSP );
		};

	void CAsyncOp::SetRefCountBuffer( CRefCountBuffer *const pRefCountBuffer );

	CRefCountBuffer *GetRefCountBuffer( void )
		{
			return( m_pRefCountBuffer );
		};

	void SetSyncEvent( CSyncEvent *const pSyncEvent )
		{
			m_pSyncEvent = pSyncEvent;
		};

	CSyncEvent *GetSyncEvent( void )
		{
			return( m_pSyncEvent );
		};

	void SetCancelEvent( CSyncEvent *const pSyncEvent )
		{
			m_pCancelEvent = pSyncEvent;
		};

	CSyncEvent *GetCancelEvent( void )
		{
			return( m_pCancelEvent );
		};

	void SetCancelThreadID( const DWORD dwCancelThreadID )
		{
			m_dwCancelThreadID = dwCancelThreadID;
		};

	DWORD GetCancelThreadID( void )
		{
			return( m_dwCancelThreadID );
		};

	void SetCompletion( PFNASYNCOP_COMPLETE pfn )
		{
			m_pfnCompletion = pfn;
		};

	void SetReserved( const DWORD dw )
		{
			m_dwReserved = dw;
		};

	void SetComplete( void )
		{
			m_dwFlags |= ASYNC_OP_COMPLETE;
		};

	BOOL IsComplete( void )
		{
			if (m_dwFlags & ASYNC_OP_COMPLETE)
			{
				return( TRUE );
			}
			return( FALSE );
		};

	void SetCancelled( void )
		{
			m_dwFlags |= ASYNC_OP_CANCELLED;
		};

	BOOL IsCancelled( void )
		{
			if (m_dwFlags & ASYNC_OP_CANCELLED)
			{
				return( TRUE );
			}
			return( FALSE );
		};

	void SetInternal( void )
		{
			m_dwFlags |= ASYNC_OP_INTERNAL;
		};

	BOOL IsInternal( void )
		{
			if (m_dwFlags & ASYNC_OP_INTERNAL)
			{
				return( TRUE );
			}
			return( FALSE );
		};

	void ClearCannotCancel( void )
		{
			m_dwFlags &= (~ASYNC_OP_CANNOT_CANCEL);
		};

	void SetCannotCancel( void )
		{
			m_dwFlags |= ASYNC_OP_CANNOT_CANCEL;
		};

	BOOL IsCannotCancel( void )
		{
			if (m_dwFlags & ASYNC_OP_CANNOT_CANCEL)
			{
				return( TRUE );
			}
			return( FALSE );
		};

	CBilink				m_bilinkAsyncOps;
	CBilink				m_bilinkActiveList;	// Active AsyncOps
	CBilink				m_bilinkParent;		// Starting point for children
	CBilink				m_bilinkChildren;	// Other children sharing this parent

private:
	BYTE				m_Sig[4];			// Signature
	DWORD	volatile	m_dwFlags;
	LONG	volatile	m_lRefCount;

	ASYNC_OP_TYPE		m_OpType;			// Operation Type

	CAsyncOp			*m_pParent;			// Parent Async Operation

	DPNHANDLE			m_handle;			// Async Operation Handle
	DWORD				m_dwOpFlags;
	PVOID				m_pvContext;
	HANDLE				m_hProtocol;		// Protocol Operation Handle
	PVOID				m_pvOpData;			// Operation specific data

	DWORD				m_dwStartTime;
	DPNID				m_dpnid;

	HRESULT	volatile	m_hr;
	volatile HRESULT	*m_phr;

	CConnection			*m_pConnection;		// Send Target connection - released

	CServiceProvider	*m_pSP;				// Service Provider - released

	CRefCountBuffer		*m_pRefCountBuffer;	// Refernce Count Buffer - released

	CSyncEvent			*m_pSyncEvent;		// Sync Event - set at release

	CSyncEvent			*m_pCancelEvent;	// Cancel event - prevent completion from returning
	DWORD				m_dwCancelThreadID;	// Cancelling thread's ID (prevent deadlocking)

	PFNASYNCOP_COMPLETE	m_pfnCompletion;	// Completion function - called

	DNCRITICAL_SECTION	m_cs;

	DIRECTNETOBJECT		*m_pdnObject;

	DWORD				m_dwReserved;		// INTERNAL - RESERVED FOR DEBUG !
};

#undef DPF_MODNAME

#endif	// __ASYNC_OP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\caps.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Caps.cpp
 *  Content:    Dplay8 caps routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/17/00	rmt		Created
 *  03/23/00	rmt		Removed unused local variables
 *  03/25/00    rmt		Updated to make calls into SP's function
 *              rmt		Updated SP calls to Initialize SP (and create if required)
 *  03/31/00    rmt		Hooked up the GetCaps/SetCaps calls to call the protocol
 *  04/17/00    rmt		Strong param validation
 *	04/19/00	mjn		Removed AddRef() for NameTableEntry in DN_GetConnectionInfoHelper()
 *	05/03/00	mjn		Use GetHostPlayerRef() rather than GetHostPlayer()
 *	06/05/00	mjn		Fixed DN_GetConnectionInfoHelper() to use GetConnectionRef
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat
 *	07/06/00	mjn		Use GetInterfaceRef for SP interface
 *				mjn		Fixed up DN_SetActualSPCaps() and DN_GetActualSPCaps()
 *	07/29/00	mjn		Fixed SetSPCaps() recursion problem
 *	07/31/00	mjn		Renamed dwDefaultEnumRetryCount to dwDefaultEnumCount in DPN_SP_CAPS
 *  08/03/2000	rmt		Bug #41244 - Wrong return codes -- part 2
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/05/00	mjn		Added dwFlags to DN_GetConnectionInfoHelper()
 *	08/20/00	mjn		DNSetActualSPCaps() uses CServiceProvider object instead of GUID
 *	01/22/01	mjn		Fixed debug text in DN_GetConnectionInfoHelper()
 *	02/12/01	mjn		Fixed CConnection::GetEndPt() to track calling thread
 *	03/30/01	mjn		Changes to prevent multiple loading/unloading of SP's
 *				mjn		Removed cached caps functionallity
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//	DN_SetCaps
//
//	Set caps
#undef DPF_MODNAME
#define DPF_MODNAME "DN_SetCaps"

STDMETHODIMP DN_SetCaps(PVOID pv,
						const DPN_CAPS *const pdnCaps,
						const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
    HRESULT             hResultCode;

	DPFX(DPFPREP, 3,"Parameters: pdnCaps [0x%p] dwFlags [0x%lx]", pdnCaps, dwFlags );

	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pv));
    	DNASSERT(pdnObject != NULL);

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
    	    if( FAILED( hResultCode = DN_ValidateSetCaps( pv, pdnCaps, dwFlags ) ) )
    	    {
    	        DPFERR( "Error validating enum group params" );
    	        DPF_RETURN( hResultCode );
    	    }
    	}

    	// Check to ensure message handler registered
    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    	{
    		DPFERR( "Object is not initialized" );
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}

    hResultCode = DNPSetProtocolCaps( pdnObject->pdnProtocolData, pdnCaps );

	DPF_RETURN(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetCaps"

STDMETHODIMP DN_GetCaps(PVOID pv,
						DPN_CAPS *const pdnCaps,
						const DWORD dwFlags)
{
	DPFX(DPFPREP, 2,"Parameters: pdnCaps [0x%p], dwFlags [0x%lx]", pdnCaps,dwFlags);

	DIRECTNETOBJECT		*pdnObject;
	HRESULT hResultCode;

	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pv));
    	DNASSERT(pdnObject != NULL);

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
    	    if( FAILED( hResultCode = DN_ValidateGetCaps( pv, pdnCaps, dwFlags ) ) )
    	    {
    	        DPFERR( "Error validating enum group params" );
    	        DPF_RETURN( hResultCode );
    	    }
    	}

    	// Check to ensure message handler registered
    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    	{
    		DPFERR( "Object is not initialized" );
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}

    hResultCode = DNPGetProtocolCaps( pdnObject->pdnProtocolData, pdnCaps );

	DPF_RETURN(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetSPCaps"

STDMETHODIMP DN_GetSPCaps(PVOID pv,
						  const GUID * const pguidSP,
						  DPN_SP_CAPS *const pdnSPCaps,
						  const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	HRESULT             hResultCode;
	CServiceProvider	*pSP;

	DPFX(DPFPREP, 2,"Parameters: pdnSPCaps [0x%p], dwFlags [0x%lx]", pdnSPCaps, dwFlags );

	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pv));
    	DNASSERT(pdnObject != NULL);

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
    	    if( FAILED( hResultCode = DN_ValidateGetSPCaps( pv, pguidSP, pdnSPCaps, dwFlags ) ) )
    	    {
    	        DPFERR( "Error validating enum group params" );
    	        DPF_RETURN( hResultCode );
    	    }
    	}

    	// Check to ensure message handler registered
    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    	{
    		DPFERR( "Object is not initialized" );
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}

	pSP = NULL;

	//
	//	Ensure SP is loaded
	//
	if ((hResultCode = DN_SPEnsureLoaded(pdnObject,pguidSP,NULL,&pSP)) != DPN_OK)
	{
		DPFERR("Could not find or load SP");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	DNASSERT( pSP != NULL );

	//
	//	Get actual SP caps
	//
	hResultCode = DNGetActualSPCaps(pdnObject,pSP,pdnSPCaps);

	pSP->Release();
	pSP = NULL;

Exit:
	DNASSERT( pSP == NULL );

	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pSP)
	{
		pSP->Release();
		pSP = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_SetSPCaps"

STDMETHODIMP DN_SetSPCaps(PVOID pv,
						  const GUID * const pguidSP,
						  const DPN_SP_CAPS *const pdnSPCaps,
						  const DWORD dwFlags)
{
	DPFX(DPFPREP, 2,"Parameters: pdnSPCaps [0x%p]", pdnSPCaps );

	DIRECTNETOBJECT		*pdnObject;
	CServiceProvider	*pSP;
    HRESULT             hResultCode;
    SPSETCAPSDATA		spSetCapsData;
    IDP8ServiceProvider	*pIDP8SP;

	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pv));
    	DNASSERT(pdnObject != NULL);

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
    	    if( FAILED( hResultCode = DN_ValidateSetSPCaps( pv, pguidSP, pdnSPCaps, dwFlags ) ) )
    	    {
    	        DPFERR( "Error validating enum group params" );
    	        DPF_RETURN( hResultCode );
    	    }
    	}

    	// Check to ensure message handler registered
    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    	{
    		DPFERR( "Object is not initialized" );
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}

	pSP = NULL;
	pIDP8SP = NULL;

	//
	//	Ensure the SP is loaded.  If it's not currently loaded, we will load it now.
	//
	if ((hResultCode = DN_SPEnsureLoaded(pdnObject,pguidSP,NULL,&pSP)) != DPN_OK)
	{
		DPFERR("Could not find or load SP");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	DNASSERT(pSP != NULL);

	//
	//	Get the SP interface
	//
	if ((hResultCode = pSP->GetInterfaceRef( &pIDP8SP )) != DPN_OK)
	{
		DPFERR("Could not get SP interface reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Set the SP caps
	//
    memset( &spSetCapsData, 0x00, sizeof( SPSETCAPSDATA ) );
    spSetCapsData.dwSize = sizeof( SPSETCAPSDATA );
    spSetCapsData.dwIOThreadCount = pdnSPCaps->dwNumThreads;
    spSetCapsData.dwBuffersPerThread = pdnSPCaps->dwBuffersPerThread;
	spSetCapsData.dwSystemBufferSize = pdnSPCaps->dwSystemBufferSize;

	if ((hResultCode = pIDP8SP->lpVtbl->SetCaps( pIDP8SP, &spSetCapsData )) != DPN_OK)
	{
		DPFERR("Could not set SP caps");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Clean up
	//
	pIDP8SP->lpVtbl->Release( pIDP8SP );
	pIDP8SP = NULL;

	pSP->Release();
	pSP = NULL;

	hResultCode = DPN_OK;

Exit:
	DNASSERT( pIDP8SP == NULL);
	DNASSERT( pSP == NULL);

	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
    return(hResultCode);

Failure:
	if (pIDP8SP)
	{
		pIDP8SP->lpVtbl->Release( pIDP8SP );
		pIDP8SP = NULL;
	}
	if (pSP)
	{
		pSP->Release();
		pSP = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetConnectionInfoHelper"

STDMETHODIMP DN_GetConnectionInfoHelper(PVOID pv,
										const DPNID dpnid,
										DPN_CONNECTION_INFO *const pdpConnectionInfo,
										BOOL fServerPlayer,
										const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
    HRESULT             hResultCode;
    CNameTableEntry     *pPlayerEntry;
    CConnection         *pConnection;
    HANDLE              hEndPoint;
	CCallbackThread		CallbackThread;

	pPlayerEntry = NULL;
	pConnection = NULL;

	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pv));
    	DNASSERT(pdnObject != NULL);

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
    	    if( FAILED( hResultCode = DN_ValidateGetConnectionInfoHelper( pv, dpnid, pdpConnectionInfo, fServerPlayer,dwFlags ) ) )
    	    {
    	        DPFERR( "Error validating enum group params" );
    	        DPF_RETURN( hResultCode );
    	    }
    	}

    	// Check to ensure message handler registered
    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    	{
    		DPFERR( "Object is not initialized" );
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    	{
    	    DPFERR("You must be connected / hosting to get connection info" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}    	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}  	

	if( fServerPlayer )
    {
		hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pPlayerEntry );
		if ( FAILED( hResultCode ) )
		{
            DPFX(DPFPREP,  0, "No host player present" );
            DPF_RETURN(DPNERR_INVALIDPLAYER);
		}
    }
    else
    {
        hResultCode = pdnObject->NameTable.FindEntry( dpnid, &pPlayerEntry );

        if( FAILED( hResultCode ) )
        {
            DPFX(DPFPREP,  0, "Could not find specified player" );
            DPF_RETURN(DPNERR_INVALIDPLAYER);
        }
    }

    if( pPlayerEntry == NULL )
    {
        DNASSERT(FALSE);
        DPFX(DPFPREP,  0, "Internal error" );
        DPF_RETURN(DPNERR_GENERIC);
    }

    if( pPlayerEntry->IsGroup() )
    {
        DPFX(DPFPREP,  0, "Cannot retrieve connection info on groups" );
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
    }

	if ((hResultCode = pPlayerEntry->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		DPFERR("Could not get connection reference");
		hResultCode = DPNERR_CONNECTIONLOST;
		goto Failure;
	}

    hResultCode = pConnection->GetEndPt(&hEndPoint,&CallbackThread);
    if( FAILED( hResultCode ) )
    {
        DPFX(DPFPREP,  0, "Unable to get endpoint hr=[0x%08x]", hResultCode );
		hResultCode = DPNERR_CONNECTIONLOST;
		goto Failure;
    }

    hResultCode = DNPGetEPCaps( hEndPoint, pdpConnectionInfo );

	pConnection->ReleaseEndPt(&CallbackThread);

    if( FAILED( hResultCode ) )
    {
        DPFX(DPFPREP,  0, "Error getting connection info hr=[0x%08x]", hResultCode );
        hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
    }

    pConnection->Release();
    pPlayerEntry->Release();

	hResultCode = DPN_OK;

Exit:
    DPF_RETURN(hResultCode);

Failure:
	if (pPlayerEntry)
	{
		pPlayerEntry->Release();
		pPlayerEntry = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetConnectionInfo"

STDMETHODIMP DN_GetConnectionInfo(PVOID pv,
								  const DPNID dpnid,
								  DPN_CONNECTION_INFO *const pdpConnectionInfo,
								  const DWORD dwFlags)
{
	DPFX(DPFPREP, 3,"Parameters: dpnid [0x%lx] pdpConnectionInfo [0x%p], dwFlags [0x%lx]", dpnid, pdpConnectionInfo,dwFlags );

    return DN_GetConnectionInfoHelper( pv, dpnid, pdpConnectionInfo, FALSE, dwFlags );
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetConnectionInfo"

STDMETHODIMP DN_GetServerConnectionInfo(PVOID pv,
										DPN_CONNECTION_INFO *const pdpConnectionInfo,
										const DWORD dwFlags)
{
	DPFX(DPFPREP, 2,"Parameters: pdpConnectionInfo [0x%p], dwFlags [0x%lx]", pdpConnectionInfo, dwFlags);

    return DN_GetConnectionInfoHelper( pv, 0, pdpConnectionInfo, TRUE, dwFlags );
}


HRESULT DNCAPS_QueryInterface( IDP8SPCallback *pSP, REFIID riid, LPVOID * ppvObj )
{
    *ppvObj = pSP;
    return DPN_OK;
}


ULONG DNCAPS_AddRef( IDP8SPCallback *pSP )
{
    return 1;
}


ULONG DNCAPS_Release( IDP8SPCallback *pSP )
{
    return 1;
}


HRESULT DNCAPS_IndicateEvent( IDP8SPCallback *pSP, SP_EVENT_TYPE spetEvent,LPVOID pvData )
{
    return DPN_OK;
}


HRESULT DNCAPS_CommandComplete( IDP8SPCallback *pSP,HANDLE hCommand,HRESULT hrResult,LPVOID pvData )
{
    return DPN_OK;
}


LPVOID dncapsspInterface[] =
{
    (LPVOID)DNCAPS_QueryInterface,
    (LPVOID)DNCAPS_AddRef,
    (LPVOID)DNCAPS_Release,
	(LPVOID)DNCAPS_IndicateEvent,
	(LPVOID)DNCAPS_CommandComplete
};


#undef DPF_MODNAME
#define DPF_MODNAME "DNSetActualSPCaps"

HRESULT DNSetActualSPCaps(DIRECTNETOBJECT *const pdnObject,
						  CServiceProvider *const pSP,
						  const DPN_SP_CAPS * const pCaps)
{
    HRESULT				hResultCode;
    SPSETCAPSDATA		spSetCapsData;
    IDP8ServiceProvider	*pIDP8SP;

	DPFX(DPFPREP, 6,"Parameters: pSP [0x%p], pCaps [0x%p]",pSP,pCaps);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pSP != NULL);
	DNASSERT(pCaps != NULL);

	pIDP8SP = NULL;

	//
	//	Get SP interface
	//
	if ((hResultCode = pSP->GetInterfaceRef( &pIDP8SP )) != DPN_OK)
	{
		DPFERR("Could not get SP interface reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Set the SP caps
	//
    memset( &spSetCapsData, 0x00, sizeof( SPSETCAPSDATA ) );
    spSetCapsData.dwSize = sizeof( SPSETCAPSDATA );
    spSetCapsData.dwIOThreadCount = pCaps->dwNumThreads;
    spSetCapsData.dwBuffersPerThread = pCaps->dwBuffersPerThread;
	spSetCapsData.dwSystemBufferSize = pCaps->dwSystemBufferSize;

	if ((hResultCode = pIDP8SP->lpVtbl->SetCaps( pIDP8SP, &spSetCapsData )) != DPN_OK)
	{
		DPFERR("Could not set SP caps");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pIDP8SP->lpVtbl->Release( pIDP8SP );
	pIDP8SP = NULL;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
    return(hResultCode);

Failure:
	if (pIDP8SP)
	{
        pIDP8SP->lpVtbl->Release(pIDP8SP);
		pIDP8SP = NULL;
	}
	goto Exit;
}


// SP should be loaded
//

#undef DPF_MODNAME
#define DPF_MODNAME "DNGetActualSPCaps"

HRESULT DNGetActualSPCaps(DIRECTNETOBJECT *const pdnObject,
						  CServiceProvider *const pSP,
						  DPN_SP_CAPS *const pCaps)
{
    HRESULT				hResultCode;
    SPGETCAPSDATA		spGetCapsData;
    IDP8ServiceProvider	*pIDP8SP;

	DPFX(DPFPREP, 4,"Parameters: pSP [0x%p], pCaps [0x%p]",pSP,pCaps);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pSP != NULL);

	pIDP8SP = NULL;

	//
	//	Get the SP interface
	//
	if ((hResultCode = pSP->GetInterfaceRef( &pIDP8SP )) != DPN_OK)
	{
		DPFERR("Could not get SP interface reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Get the SP caps
	//
    memset( &spGetCapsData, 0x00, sizeof( SPGETCAPSDATA ) );
    spGetCapsData.dwSize = sizeof( SPGETCAPSDATA );
	spGetCapsData.hEndpoint = INVALID_HANDLE_VALUE;
    if ((hResultCode = pIDP8SP->lpVtbl->GetCaps( pIDP8SP, &spGetCapsData )) != DPN_OK)
	{
		DPFERR("Could not get SP caps");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Clean up
	//
	pIDP8SP->lpVtbl->Release( pIDP8SP );
	pIDP8SP = NULL;

	//
    //	Map from SP structure to our own
	//
	pCaps->dwFlags = spGetCapsData.dwFlags;
    pCaps->dwNumThreads = spGetCapsData.dwIOThreadCount;
	pCaps->dwDefaultEnumCount = spGetCapsData.dwDefaultEnumRetryCount;
	pCaps->dwDefaultEnumRetryInterval = spGetCapsData.dwDefaultEnumRetryInterval;
	pCaps->dwDefaultEnumTimeout = spGetCapsData.dwDefaultEnumTimeout;
	pCaps->dwMaxEnumPayloadSize = spGetCapsData.dwEnumFrameSize - sizeof( DN_ENUM_QUERY_PAYLOAD );
	pCaps->dwBuffersPerThread = spGetCapsData.dwBuffersPerThread;
	pCaps->dwSystemBufferSize = spGetCapsData.dwSystemBufferSize;

	hResultCode = DPN_OK;

Exit:
	DNASSERT( pIDP8SP == NULL );

	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
    return(hResultCode);

Failure:
	if (pIDP8SP)
	{
        pIDP8SP->lpVtbl->Release(pIDP8SP);
		pIDP8SP = NULL;
	}
	goto Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\cancel.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Connect.h
 *  Content:    DirectNet Cancel Operation Header
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	04/07/00	mjn		Created
 *	04/08/00	mjn		Added DNCancelEnum(), DNCancelSend()
 *	04/11/00	mjn		DNCancelEnum() uses CAsyncOp
 *	04/17/00	mjn		DNCancelSend() uses CAsyncOp
 *	04/25/00	mjn		Added DNCancelConnect()
 *	08/05/00	mjn		Added DNCancelChildren(),DNCancelActiveCommands(),DNCanCancelCommand()
 *				mjn		Added DN_CANCEL_FLAG's
 *				mjn		Removed DNCancelEnum(),DNCancelListen(),DNCancelSend(),DNCancelConnect()
 *	08/07/00	mjn		Added DNCancelRequestCommands()
 *	01/10/01	mjn		Allow DNCancelActiveCommands() to set result code of cancelled commands
 *	02/08/01	mjn		Added DNWaitForCancel()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__CANCEL_H__
#define	__CANCEL_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	DN_CANCEL_FLAG_CONNECT			0x0001
#define	DN_CANCEL_FLAG_DISCONNECT		0x0002
#define	DN_CANCEL_FLAG_ENUM_QUERY		0x0004
#define	DN_CANCEL_FLAG_ENUM_RESPONSE	0x0008
#define	DN_CANCEL_FLAG_LISTEN			0x0010
#define	DN_CANCEL_FLAG_USER_SEND		0x0020
#define	DN_CANCEL_FLAG_INTERNAL_SEND	0x0040
#define	DN_CANCEL_FLAG_RECEIVE_BUFFER	0x0080
#define	DN_CANCEL_FLAG_REQUEST			0x0100

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

class CAsyncOp;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

BOOL DNCanCancelCommand(CAsyncOp *const pAsyncOp,
						const DWORD dwFlags);

HRESULT DNDoCancelCommand(DIRECTNETOBJECT *const pdnObject,
						  CAsyncOp *const pAsyncOp);

HRESULT DNCancelChildren(DIRECTNETOBJECT *const pdnObject,
						 CAsyncOp *const pParent);

HRESULT DNCancelActiveCommands(DIRECTNETOBJECT *const pdnObject,
							   const DWORD dwFlags,
							   const BOOL fSetResult,
							   const HRESULT hr);

HRESULT DNCancelRequestCommands(DIRECTNETOBJECT *const pdnObject);

void DNWaitForCancel(DIRECTNETOBJECT *const pdnObject,
					 CAsyncOp *const pAsyncOp);

//**********************************************************************
// Class prototypes
//**********************************************************************

#endif	// __CANCEL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\caps.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Caps.h
 *  Content:    DirectPlay8 Caps routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	03/17/00	rmt		Created
 *  03/25/00    rmt     Changed Get/SetActualSPCaps so takes interface instead of obj
 *	08/20/00	mjn		DNSetActualSPCaps() uses CServiceProvider object instead of GUID
 *	03/30/01	mjn		Removed cached caps functionallity
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__CAPS_H__
#define	__CAPS_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

class CServiceProvider;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************


STDMETHODIMP DN_SetCaps(PVOID pv,
						const DPN_CAPS *const pdnCaps,
						const DWORD dwFlags);

STDMETHODIMP DN_GetCaps(PVOID pv,
						DPN_CAPS *const pdnCaps,
						const DWORD dwFlags);

STDMETHODIMP DN_GetSPCaps(PVOID pv,
						  const GUID * const pguidSP,
						  DPN_SP_CAPS *const pdnSPCaps,
						  const DWORD dwFlags);

STDMETHODIMP DN_SetSPCaps(PVOID pv,
						  const GUID * const pguidSP,
						  const DPN_SP_CAPS *const pdnSPCaps,
						  const DWORD dwFlags);

STDMETHODIMP DN_GetConnectionInfo(PVOID pv,
								  const DPNID dpnid,
								  DPN_CONNECTION_INFO *const pdpConnectionInfo,
								  const DWORD dwFlags);

STDMETHODIMP DN_GetServerConnectionInfo(PVOID pv,
										DPN_CONNECTION_INFO *const pdpConnectionInfo,
										const DWORD dwFlags);

HRESULT DNSetActualSPCaps(DIRECTNETOBJECT *const pdnObject,
						  CServiceProvider *const pSP,
						  const DPN_SP_CAPS * const pCaps);

HRESULT DNGetActualSPCaps(DIRECTNETOBJECT *const pdnObject,
						  CServiceProvider *const pSP,
						  DPN_SP_CAPS *const pCaps);


#endif	// __CONNECT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\classfac.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ClassFac.h
 *  Content:    DirectNet class factory header file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	10/08/99	jtk		Created
 *	05/04/00	mjn		Cleaned up functions
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat and support external create funcs 
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__CLASSFAC_H__
#define	__CLASSFAC_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef struct _INTERFACE_LIST	INTERFACE_LIST;
typedef struct _OBJECT_DATA		OBJECT_DATA;

//
// COM interface for class factory
//
#undef INTERFACE				// External COM Implementation
#define INTERFACE IDirectNetClassFact
DECLARE_INTERFACE_(IDirectNetClassFact,IUnknown)
{
	STDMETHOD(QueryInterface)	(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)	(THIS) PURE;
	STDMETHOD_(ULONG,Release)	(THIS) PURE;
	STDMETHOD(CreateInstance)	(THIS_ LPUNKNOWN lpUnkOuter, REFIID riid, LPVOID *ppvObj) PURE;
	STDMETHOD(LockServer)		(THIS_ BOOL bLock) PURE;
};


typedef struct _IDirectNetClassFact {	// Internal Implementation (overlay's external imp.)
	IDirectNetClassFactVtbl	*lpVtbl;		// lpVtbl Must be first element (to match external imp.)
	DWORD					dwRefCount;
	DWORD					dwLocks;
	GUID                    clsid;
} _IDirectNetClassFact, *_LPIDirectNetClassFact;

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// VTable for class factory
//
extern IDirectNetClassFactVtbl DNCF_Vtbl;

//**********************************************************************
// Function prototypes
//**********************************************************************

//
//	DirectNet - IUnknown
//
STDMETHODIMP DN_QueryInterface(void *pInterface,
							   REFIID riid,
							   void **ppv);

STDMETHODIMP_(ULONG) DN_AddRef(void *pInterface);

STDMETHODIMP_(ULONG) DN_Release(void *pInterface);

//
//	Class Factory
//
STDMETHODIMP			DNCF_QueryInterface(IDirectNetClassFact *pInterface,REFIID riid,LPVOID *ppvObj);
STDMETHODIMP_(ULONG)	DNCF_AddRef(IDirectNetClassFact *pInterface);
STDMETHODIMP_(ULONG)	DNCF_Release(IDirectNetClassFact *pInterface);
STDMETHODIMP			DNCF_CreateInstance(IDirectNetClassFact *pInterface,LPUNKNOWN lpUnkOuter,REFIID riid,LPVOID *ppv);
STDMETHODIMP			DNCF_LockServer(IDirectNetClassFact *pInterface,BOOL bLock);

// Class Factory - supporting

HRESULT		DNCF_CreateObject(LPVOID *lplpv,REFIID riid);
HRESULT		DNCF_FreeObject(LPVOID lpv);

static	HRESULT DN_CreateInterface(OBJECT_DATA *pObject,
								   REFIID riid,
								   INTERFACE_LIST **const ppv);

INTERFACE_LIST *DN_FindInterface(void *pInterface,
								 REFIID riid);


#endif	// __CLASSFAC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\client.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Client.cpp
 *  Content:    DNET client interface routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/21/99	mjn		Created
 *	01/06/99	mjn		Moved NameTable stuff to NameTable.h
 *	01/28/00	mjn		Implemented ReturnBuffer in API
 *	02/01/00	mjn		Implemented GetCaps and SetCaps in API
 *	02/15/00	mjn		Implement INFO flags in SetClientInfo
 *	02/18/00	mjn		Converted DNADDRESS to IDirectPlayAddress8
 *  03/17/00    rmt     Added new caps functions
 *	04/06/00	mjn		Added GetServerAddress to API
 *	04/16/00	mjn		DNSendMessage uses CAsyncOp
 *  04/17/00    rmt     Added more param validation
 *              rmt     Removed required for connection from Get/SetInfo / GetAddress
 *	04/19/00	mjn		Send API call accepts a range of DPN_BUFFER_DESCs and a count
 *	04/20/00	mjn		DN_Send() calls DN_SendTo() with DPNID=0
 *	04/24/00	mjn		Updated Group and Info operations to use CAsyncOp's
 *	04/28/00	mjn		Updated DN_GetHostSendQueueInfo() to use CAsyncOp's
 *	05/03/00	mjn		Use GetHostPlayerRef() rather than GetHostPlayer()
 *	05/31/00	mjn		Added operation specific SYNC flags
 *	06/23/00	mjn		Removed dwPriority from Send() API call
 *	06/27/00	mjn		Allow priorities to be specified to GetSendQueueInfo() API call
 *	06/27/00	mjn		Added DN_ClientConnect() (without pvPlayerContext)
 *				mjn		Allow mix-n-match of priorities in GetSendQueueInfo() API call
 *	07/09/00	mjn		Cleaned up DN_SetClientInfo()
 *  07/09/00	rmt		Bug #38323 - RegisterLobby needs a DPNHANDLE parameter.
 *  07/21/2000  RichGr  IA64: Use %p format specifier for 32/64-bit pointers.
 *	10/11/00	mjn		Take locks for CNameTableEntry::PackInfo()
 *	01/22/01	mjn		Check for closing instead of disconnecting in DN_GetServerInfo()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// define appropriate types since these interface functions take 'void*' arguments!!
//
typedef	STDMETHODIMP ClientQueryInterface( IDirectPlay8Client *pInterface, REFIID riid, LPVOID *ppvObj );
typedef	STDMETHODIMP_(ULONG)	ClientAddRef( IDirectPlay8Client *pInterface );
typedef	STDMETHODIMP_(ULONG)	ClientRelease( IDirectPlay8Client *pInterface );
typedef	STDMETHODIMP ClientInitialize( IDirectPlay8Client *pInterface, LPVOID const lpvUserContext, const PFNDPNMESSAGEHANDLER lpfn, const DWORD dwFlags );
typedef STDMETHODIMP ClientEnumServiceProviders( IDirectPlay8Client *pInterface,const GUID *const pguidServiceProvider,const GUID *const pguidApplication,DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer,DWORD *const pcbEnumData,DWORD *const pcReturned,const DWORD dwFlags );
typedef	STDMETHODIMP ClientCancelAsyncOperation( IDirectPlay8Client *pInterface, const DPNHANDLE hAsyncHandle, const DWORD dwFlags );
typedef STDMETHODIMP ClientConnect( IDirectPlay8Client *pInterface,const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address *const pHostAddr,IDirectPlay8Address *const pDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,const void *const pvUserConnectData,const DWORD dwUserConnectDataSize,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags);
typedef	STDMETHODIMP ClientGetApplicationDesc( IDirectPlay8Client *pInterface,DPN_APPLICATION_DESC *const pAppDescBuffer,DWORD *const lpcbDataSize,const DWORD dwFlags );
typedef	STDMETHODIMP ClientClose(IDirectPlay8Client *pInterface,const DWORD dwFlags);
typedef STDMETHODIMP ClientEnumHosts( IDirectPlay8Client *pInterface,DPN_APPLICATION_DESC *const pApplicationDesc,IDirectPlay8Address *const dnaddrHost,IDirectPlay8Address *const dnaddrDeviceInfo,PVOID const pUserEnumData,const DWORD dwUserEnumDataSize,const DWORD dwRetryCount,const DWORD dwRetryInterval,const DWORD dwTimeOut,PVOID const pvUserContext,DPNHANDLE *const pAsyncHandle,const DWORD dwFlags );
typedef STDMETHODIMP ClientReturnBuffer( IDirectPlay8Client *pInterface, const DPNHANDLE hBufferHandle,const DWORD dwFlags);
typedef STDMETHODIMP ClientGetCaps(IDirectPlay8Client *pInterface,DPN_CAPS *const pdnCaps,const DWORD dwFlags);
typedef STDMETHODIMP ClientSetCaps(IDirectPlay8Client *pInterface,const DPN_CAPS *const pdnCaps,const DWORD dwFlags);
typedef STDMETHODIMP ClientSetSPCaps(IDirectPlay8Client *pInterface,const GUID * const pguidSP, const DPN_SP_CAPS *const pdpspCaps, const DWORD dwFlags );
typedef STDMETHODIMP ClientGetSPCaps(IDirectPlay8Client *pInterface,const GUID * const pguidSP, DPN_SP_CAPS *const pdpspCaps,const DWORD dwFlags);
typedef STDMETHODIMP ClientGetConnectionInfo(IDirectPlay8Client *pInterface,DPN_CONNECTION_INFO *const pdpConnectionInfo,const DWORD dwFlags);
typedef STDMETHODIMP ClientRegisterLobby(IDirectPlay8Client *pInterface,const DPNHANDLE dpnHandle,IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,const DWORD dwFlags);

//
// VTable for client interface
//
IDirectPlay8ClientVtbl DN_ClientVtbl =
{
	(ClientQueryInterface*)			DN_QueryInterface,
	(ClientAddRef*)					DN_AddRef,
	(ClientRelease*)				DN_Release,
	(ClientInitialize*)				DN_Initialize,
	(ClientEnumServiceProviders*)	DN_EnumServiceProviders,
	(ClientEnumHosts*)				DN_EnumHosts,
	(ClientCancelAsyncOperation*)	DN_CancelAsyncOperation,
	/*(ClientConnect*)*/			DN_ClientConnect,
									DN_Send,
	/*(ClientGetSendQueueInfo*)*/	DN_GetHostSendQueueInfo,
	(ClientGetApplicationDesc*)		DN_GetApplicationDesc,
									DN_SetClientInfo,
									DN_GetServerInfo,
									DN_GetServerAddress,
	(ClientClose*)					DN_Close,
	(ClientReturnBuffer*)			DN_ReturnBuffer,
	(ClientGetCaps*)				DN_GetCaps,
	(ClientSetCaps*)				DN_SetCaps,
    (ClientSetSPCaps*)              DN_SetSPCaps,
    (ClientGetSPCaps*)              DN_GetSPCaps,
    (ClientGetConnectionInfo*)      DN_GetServerConnectionInfo,
	(ClientRegisterLobby*)			DN_RegisterLobby
};

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


#undef DPF_MODNAME
#define DPF_MODNAME "DN_Send"

STDMETHODIMP DN_Send( IDirectPlay8Client *pInterface,
					  const DPN_BUFFER_DESC *const prgBufferDesc,
					  const DWORD cBufferDesc,
					  const DWORD dwTimeOut,
					  const PVOID pvAsyncContext,
					  DPNHANDLE *const phAsyncHandle,
					  const DWORD dwFlags)
{
	return(	DN_SendTo(	pInterface,
						0,					// DN_SendTo should translate this call to the Host player
						prgBufferDesc,
						cBufferDesc,
						dwTimeOut,
						pvAsyncContext,
						phAsyncHandle,
						dwFlags ) );
}


//	DN_ClientConnect
//
//	Call DN_Connect, but with no PlayerContext

STDMETHODIMP DN_ClientConnect(IDirectPlay8Client *pInterface,
							  const DPN_APPLICATION_DESC *const pdnAppDesc,
							  IDirectPlay8Address *const pHostAddr,
							  IDirectPlay8Address *const pDeviceInfo,
							  const DPN_SECURITY_DESC *const pdnSecurity,
							  const DPN_SECURITY_CREDENTIALS *const pdnCredentials,
							  const void *const pvUserConnectData,
							  const DWORD dwUserConnectDataSize,
							  void *const pvAsyncContext,
							  DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags)
{
	return(	DN_Connect(	pInterface,
						pdnAppDesc,
						pHostAddr,
						pDeviceInfo,
						pdnSecurity,
						pdnCredentials,
						pvUserConnectData,
						dwUserConnectDataSize,
						NULL,
						pvAsyncContext,
						phAsyncHandle,
						dwFlags ) );
}


//	DN_SetClientInfo
//
//	Set the info for the client player and propagate to server

#undef DPF_MODNAME
#define DPF_MODNAME "DN_SetClientInfo"

STDMETHODIMP DN_SetClientInfo(IDirectPlay8Client *pInterface,
							  const DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  const PVOID pvAsyncContext,
							  DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	HRESULT				hResultCode;
	DPNHANDLE			hAsyncOp;
	PWSTR				pwszName;
	DWORD				dwNameSize;
	PVOID				pvData;
	DWORD				dwDataSize;
	CNameTableEntry		*pLocalPlayer;
	BOOL				fConnected;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], pdpnPlayerInfo [0x%p], pvAsyncContext [0x%p], phAsyncHandle [0x%p], dwFlags [0x%lx]",
			pInterface,pdpnPlayerInfo,pvAsyncContext,phAsyncHandle,dwFlags);

	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    	DNASSERT(pdnObject != NULL);

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
        	if( FAILED( hResultCode = DN_ValidateSetClientInfo( pInterface , pdpnPlayerInfo, pvAsyncContext, phAsyncHandle, dwFlags ) ) )
        	{
        	    DPFX(DPFPREP,  0, "Error validating setclientinfo params hr=[0x%lx]", hResultCode );
        	    DPF_RETURN( hResultCode );
        	}
    	}

        // Check to ensure message handler registered
    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    	{
    		DPFERR( "Object is not initialized" );
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}

	pLocalPlayer = NULL;

	if ((pdpnPlayerInfo->dwInfoFlags & DPNINFO_NAME) && (pdpnPlayerInfo->pwszName))
	{
		pwszName = pdpnPlayerInfo->pwszName;
		dwNameSize = (wcslen(pwszName) + 1) * sizeof(WCHAR);
	}
	else
	{
		pwszName = NULL;
		dwNameSize = 0;
	}
	if ((pdpnPlayerInfo->dwInfoFlags & DPNINFO_DATA) && (pdpnPlayerInfo->pvData) && (pdpnPlayerInfo->dwDataSize))
	{
		pvData = pdpnPlayerInfo->pvData;
		dwDataSize = pdpnPlayerInfo->dwDataSize;
	}
	else
	{
		pvData = NULL;
		dwDataSize = 0;
	}

	//
	//	If we are connected, we will request the Host to update us.
	//	Otherwise, we will just update the DefaultPlayer.
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED)
	{
		fConnected = TRUE;
	}
	else
	{
		fConnected = FALSE;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	if (fConnected)
	{
		if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
		{
			DPFERR( "Could not get local player reference" );
			DisplayDNError(0,hResultCode);
			goto Failure;
		}

		DPFX(DPFPREP, 3,"Request host to update client info");

		hResultCode = DNRequestUpdateInfo(	pdnObject,
											pLocalPlayer->GetDPNID(),
											pwszName,
											dwNameSize,
											pvData,
											dwDataSize,
											pdpnPlayerInfo->dwInfoFlags,
											pvAsyncContext,
											&hAsyncOp,
											dwFlags);
		if (hResultCode != DPN_OK && hResultCode != DPNERR_PENDING)
		{
			DPFERR("Could not request host to update client info");
		}
		else
		{
			if (!(dwFlags & DPNSETCLIENTINFO_SYNC))
			{
				DPFX(DPFPREP, 3,"Async Handle [0x%lx]",hAsyncOp);
				*phAsyncHandle = hAsyncOp;
			}
		}

		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	else
	{
		DNASSERT(pdnObject->NameTable.GetDefaultPlayer() != NULL);

		// This function takes the lock internally
		pdnObject->NameTable.GetDefaultPlayer()->UpdateEntryInfo(pwszName,dwNameSize,pvData,dwDataSize,pdpnPlayerInfo->dwInfoFlags, FALSE);

		hResultCode = DPN_OK;
	}

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
}


//	DN_GetServerInfo
//
//	Retrieve server info from the local nametable.

#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetServerInfo"

STDMETHODIMP DN_GetServerInfo(IDirectPlay8Client *pInterface,
							  DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  DWORD *const pdwSize,
							  const DWORD dwFlags)
{
	DIRECTNETOBJECT	*pdnObject;
	HRESULT			hResultCode;
	CPackedBuffer	packedBuffer;
	CNameTableEntry	*pHostPlayer;

	DPFX(DPFPREP, 3,"Parameters: pInterface [0x%p], pdpnPlayerInfo [0x%p], pdwSize [%p], dwFlags [0x%lx]",
			pInterface,pdpnPlayerInfo,pdwSize,dwFlags);

	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    	DNASSERT(pdnObject != NULL);

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
        	if( FAILED( hResultCode = DN_ValidateGetServerInfo( pInterface , pdpnPlayerInfo, pdwSize, dwFlags ) ) )
        	{
        	    DPFX(DPFPREP,  0, "Error validating get server info hr=[0x%lx]", hResultCode );
        	    DPF_RETURN( hResultCode );
        	}
    	}

        // Check to ensure message handler registered
    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    	{
    		DPFERR( "Object is not initialized" );
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}	

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if ( !(pdnObject->dwFlags & (DN_OBJECT_FLAG_CONNECTED | DN_OBJECT_FLAG_CLOSING | DN_OBJECT_FLAG_DISCONNECTING) ) )
    	{
    	    DPFERR("You must be connected / disconnecting to use this function" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}	    	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}

	pHostPlayer = NULL;

	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef(&pHostPlayer)) != DPN_OK)
	{
		DPFERR("Could not find Host player");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	packedBuffer.Initialize(pdpnPlayerInfo,*pdwSize);

	pHostPlayer->Lock();
	hResultCode = pHostPlayer->PackInfo(&packedBuffer);
	pHostPlayer->Unlock();

	pHostPlayer->Release();
	pHostPlayer = NULL;

	if ((hResultCode == DPN_OK) || (hResultCode == DPNERR_BUFFERTOOSMALL))
	{
		*pdwSize = packedBuffer.GetSizeRequired();
	}

Exit:
	DPF_RETURN(hResultCode);

Failure:
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetHostSendQueueInfo"

STDMETHODIMP DN_GetHostSendQueueInfo(IDirectPlay8Client *pInterface,
									 DWORD *const pdwNumMsgs,
									 DWORD *const pdwNumBytes,
									 const DWORD dwFlags )
{
	DIRECTNETOBJECT		*pdnObject;
	DWORD				dwQueueFlags;
	DWORD				dwNumMsgs;
	DWORD				dwNumBytes;
	CNameTableEntry     *pNTEntry;
	CConnection			*pConnection;
	HRESULT				hResultCode;

	DPFX(DPFPREP, 3,"Parameters : pInterface [0x%p], pdwNumMsgs [0x%p], pdwNumBytes [0x%p], dwFlags [0x%lx]",
		pInterface,pdwNumMsgs,pdwNumBytes,dwFlags);

	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    	DNASSERT(pdnObject != NULL);

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
        	if( FAILED( hResultCode = DN_ValidateGetHostSendQueueInfo( pInterface , pdwNumMsgs, pdwNumBytes, dwFlags ) ) )
        	{
        	    DPFX(DPFPREP,  0, "Error validating get server info hr=[0x%lx]", hResultCode );
        	    DPF_RETURN( hResultCode );
        	}
    	}

        // Check to ensure message handler registered
    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    	{
    		DPFERR( "Object is not initialized" );
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}	

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR( "Object has not yet completed connecting / hosting" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    	{
    	    DPFERR("Object is not connected or hosting" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}
   	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}

	pNTEntry = NULL;
	pConnection = NULL;

	//
    //	Validate specified player ID and get CConnection
	//
	if((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pNTEntry )) != DPN_OK)
	{
		DPFX(DPFPREP, 0,"Could not find Host Player in NameTable");
		hResultCode = DPNERR_CONNECTIONLOST;
		goto Failure;
	}
	if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		hResultCode = DPNERR_CONNECTIONLOST;
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	Determine required queues
	//
	dwQueueFlags = dwFlags & (DPNGETSENDQUEUEINFO_PRIORITY_HIGH | DPNGETSENDQUEUEINFO_PRIORITY_NORMAL | DPNGETSENDQUEUEINFO_PRIORITY_LOW);
	if (dwQueueFlags == 0)
	{
		dwQueueFlags = (DPNGETSENDQUEUEINFO_PRIORITY_HIGH | DPNGETSENDQUEUEINFO_PRIORITY_NORMAL | DPNGETSENDQUEUEINFO_PRIORITY_LOW);
	}

	//
	//	Extract required info
	//
	dwNumMsgs = 0;
	dwNumBytes = 0;
	pConnection->Lock();
	if (dwQueueFlags & DPNGETSENDQUEUEINFO_PRIORITY_HIGH)
	{
		dwNumMsgs += pConnection->GetHighQueueNum();
		dwNumBytes += pConnection->GetHighQueueBytes();
	}
	if (dwQueueFlags & DPNGETSENDQUEUEINFO_PRIORITY_NORMAL)
	{
		dwNumMsgs += pConnection->GetNormalQueueNum();
		dwNumBytes += pConnection->GetNormalQueueBytes();
	}
	if (dwQueueFlags & DPNGETSENDQUEUEINFO_PRIORITY_LOW)
	{
		dwNumMsgs += pConnection->GetLowQueueNum();
		dwNumBytes += pConnection->GetLowQueueBytes();
	}
	pConnection->Unlock();
	pConnection->Release();
	pConnection = NULL;

	if (pdwNumMsgs)
	{
		*pdwNumMsgs = dwNumMsgs;
		DPFX(DPFPREP, 3,"Setting: *pdwNumMsgs [%ld]",dwNumMsgs);
	}
	if (pdwNumBytes)
	{
		*pdwNumBytes = dwNumBytes;
		DPFX(DPFPREP, 3,"Setting: *pdwNumBytes [%ld]",dwNumBytes);
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	goto Exit;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetServerAddress"

STDMETHODIMP DN_GetServerAddress(IDirectPlay8Client *pInterface,
								 IDirectPlay8Address **const ppAddress,
								 const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	IDirectPlay8Address	*pAddress;
	HRESULT				hResultCode;
	CNameTableEntry		*pHostPlayer;

	DPFX(DPFPREP, 3,"Parameters : pInterface [0x%p], ppAddress [0x%p], dwFlags [0x%lx]",
		pInterface,ppAddress,dwFlags);

	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    	DNASSERT(pdnObject != NULL);

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
        	if( FAILED( hResultCode = DN_ValidateGetServerAddress( pInterface,ppAddress,dwFlags ) ) )
        	{
        	    DPFX(DPFPREP,  0, "Error validating get server info hr=[0x%lx]", hResultCode );
        	    DPF_RETURN( hResultCode );
        	}
    	}

        // Check to ensure message handler registered
    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    	{
    		DPFERR( "Object is not initialized" );
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}	

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if ( !(pdnObject->dwFlags & (DN_OBJECT_FLAG_CONNECTED | DN_OBJECT_FLAG_CLOSING | DN_OBJECT_FLAG_DISCONNECTING) ) )
    	{
    	    DPFERR("You must be connected / disconnecting to use this function" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}	    	
  	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}

	pHostPlayer = NULL;

	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer )) != DPN_OK)
	{
		DPFERR("Could not find Host player");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pAddress = pHostPlayer->GetAddress();
	DNASSERT(pAddress != NULL);
	hResultCode = pAddress->lpVtbl->Duplicate(pAddress,ppAddress);

	pHostPlayer->Release();
	pHostPlayer = NULL;

Exit:
	DPF_RETURN(hResultCode);

Failure:
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	goto Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\comstuff.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       comstuff.h
 *  Content:    COM interface and object definition header file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	??/??/00	mjn		Created
 *	05/04/00	mjn		Changed dwRefCount's to lRefCount's to use InterlockedIncrement/Decrement
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef COMSTUFF_H
#define COMSTUFF_H

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

#define GET_OBJECT_FROM_INTERFACE(a)	((INTERFACE_LIST*)(a))->pObject->pvData

#if !defined(__cplusplus) && !defined(CINTERFACE)

#ifdef THIS_
#undef THIS_
#define THIS_   LPVOID this,
#endif

#ifdef THIS
#undef THIS
#define THIS    LPVOID this
#endif

#endif

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef struct _INTERFACE_LIST	INTERFACE_LIST;
typedef struct _OBJECT_DATA		OBJECT_DATA;

typedef struct _INTERFACE_LIST {
	void			*lpVtbl;
	LONG			lRefCount;
	IID				iid;
	INTERFACE_LIST	*pIntNext;
	OBJECT_DATA		*pObject;
} INTERFACE_LIST;

typedef struct _OBJECT_DATA {
	LONG			lRefCount;
	void			*pvData;
	INTERFACE_LIST	*pIntList;
} OBJECT_DATA;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

#endif // COMSTUFF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\connection.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       connection.cpp
 *  Content:    Connection routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  10/13/99	mjn		Created
 *	03/02/00	mjn		Conversion to class 
 *	04/08/00	mjn		Added ServiceProvider to Connection object
 *				mjn		Disconnect uses new CAsyncOp class
 *	04/18/00	mjn		CConnection tracks connection status better
 *	04/21/00	mjn		Disconnection through DNPerformDisconnect
 *	07/20/00	mjn		Changed Release() behaviour and beefed up Disconnect()
 *	07/28/00	mjn		Added m_bilinkConnections to CConnection
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	02/12/01	mjn		Fixed CConnection::GetEndPt() to track calling thread and added ReleaseEndPt()
 *	04/04/01	mjn		CConnection list off DirectNetObject guarded by proper critical section
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//	CConnection::ReturnSelfToPool
//
//	Return object to FPM

#undef DPF_MODNAME
#define DPF_MODNAME "CConnection::ReturnSelfToPool"

void CConnection::ReturnSelfToPool( void )
{
	DPFX(DPFPREP, 8,"Parameters: (none)");

	m_pdnObject->m_pFPOOLConnection->Release( this );

	DPFX(DPFPREP, 8,"Returning");
};



#undef DPF_MODNAME
#define DPF_MODNAME "CConnection::Release"

void CConnection::Release(void)
{
	LONG	lRefCount;

	DPFX(DPFPREP, 8,"Parameters: (none)");

	DNASSERT(m_lRefCount > 0);
	lRefCount = InterlockedDecrement(const_cast<LONG*>(&m_lRefCount));
	DPFX(DPFPREP, 3,"Connection::Release [0x%p] RefCount [0x%lx]",this,lRefCount);

	if (lRefCount == 0)
	{
		//
		//	Remove from the bilink of outstanding CConnection objects
		//
		DNEnterCriticalSection(&m_pdnObject->csConnectionList);
		m_bilinkConnections.RemoveFromList();
		DNLeaveCriticalSection(&m_pdnObject->csConnectionList);

		if (m_pSP)
		{
			m_pSP->Release();
			m_pSP = NULL;
		}
		m_dwFlags = 0;
		m_lRefCount = 0;
		m_hEndPt = NULL;
		ReturnSelfToPool();
	}

	DPFX(DPFPREP, 8,"Returning");
};


#undef DPF_MODNAME
#define DPF_MODNAME "CConnection::GetEndPt"

HRESULT CConnection::GetEndPt(HANDLE *const phEndPt,CCallbackThread *const pCallbackThread)
{
	HRESULT		hResultCode;

	DNASSERT(phEndPt != NULL);
	DNASSERT(pCallbackThread != NULL);

	Lock();
	if ((m_Status == CONNECTED) || (m_Status == CONNECTING))
	{
		//
		//	Add the calling thread to the bilink to that the endpoint will
		//	not be invalidated (through IndicateConnectionTerminated) until
		//	this thread is done with the endpoint.
		//
		pCallbackThread->m_bilinkCallbackThreads.InsertBefore(&m_bilinkCallbackThreads);
		*phEndPt = m_hEndPt;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_NOCONNECTION;
	}
	Unlock();

	return(hResultCode);
};


#undef DPF_MODNAME
#define DPF_MODNAME "CConnection::ReleaseEndPt"

void CConnection::ReleaseEndPt(CCallbackThread *const pCallbackThread)
{
	DNASSERT(pCallbackThread != NULL);

	Lock();
	pCallbackThread->m_bilinkCallbackThreads.RemoveFromList();
	if (m_dwThreadCount != 0)
	{
		//
		//	If there is a thread count,
		//		decrement it
		//		if this is the last count
		//			set the event
		//
		m_dwThreadCount--;
		if (m_dwThreadCount == 0)
		{
			DNASSERT(m_pThreadEvent != NULL);
			if (m_pThreadEvent)
			{
				m_pThreadEvent->Set();
			}
		}
	}
	Unlock();
}


#undef DPF_MODNAME
#define DPF_MODNAME "CConnection::SetSP"

void CConnection::SetSP( CServiceProvider *const pSP )
{
	DPFX(DPFPREP, 8,"Parameters: pSP [0x%p]",pSP);

	DNASSERT( pSP != NULL );

	pSP->AddRef();
	m_pSP = pSP;

	DPFX(DPFPREP, 8,"Returning");
}



//	CConnection::Disconnect
//
//	Initiate a disconnection.  If this is successful, eventually we will receive an IndicateConnectionTerminated
//	which we should use to remove a reference (from the Protocol).

#undef DPF_MODNAME
#define DPF_MODNAME "CConnection::Disconnect"

void CConnection::Disconnect( void )
{
	BOOL		fDisconnect;

	DPFX(DPFPREP, 8,"Parameters: (none)");

	DNASSERT(m_pdnObject != NULL);

	fDisconnect = FALSE;
	Lock();
	if ((m_Status == CONNECTING) || (m_Status == CONNECTED))
	{
		if (m_hEndPt != NULL)
		{
			m_Status = DISCONNECTING;
			fDisconnect = TRUE;
		}
		else
		{
			m_Status = INVALID;
		}
	}
	Unlock();

	if (fDisconnect)
	{
		DNPerformDisconnect(m_pdnObject,this,m_hEndPt);
	}

	DPFX(DPFPREP, 8,"Returning");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\common.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Common.cpp
 *  Content:    DNET common interface routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/21/99	mjn		Created
 *  12/23/99	mjn		Hand all NameTable update sends from Host to worker thread
 *  12/23/99	mjn		Fixed use of Host and AllPlayers short cut pointers
 *	12/28/99	mjn		Moved Async Op stuff to Async.h
 *	12/29/99	mjn		Reformed DN_ASYNC_OP to use hParentOp instead of lpvUserContext
 *	12/29/99	mjn		Added Instance GUID generation in DN_Host
 *	01/05/00	mjn		Return DPNERR_NOINTERFACE if CoCreateInstance fails
 *	01/06/00	mjn		Moved NameTable stuff to NameTable.h
 *	01/07/00	mjn		Implemented DNSEND_NOCOPY flag in DN_SendTo
 *	01/07/00	mjn		Moved Misc Functions to DNMisc.h
 *	01/08/00	mjn		Implemented GetApplicationDesc
 *	01/09/00	mjn		Application Description stuff
 *	01/10/00	mjn		Implemented SetApplicationDesc
 *	01/11/00	mjn		Use CPackedBuffers instead of DN_ENUM_BUFFER_INFOs
 *	01/13/00	mjn		Removed DIRECTNETOBJECT from Pack/UnpackApplicationDesc
 *	01/14/00	mjn		Added pvUserContext to Host API call
 *	01/14/00	mjn		Removed pvUserContext from DN_NAMETABLE_ENTRY
 *	01/15/00	mjn		Replaced DN_COUNT_BUFFER with CRefCountBuffer
 *	01/16/00	mjn		Moved User callback stuff to User.h
 *	01/18/00	mjn		Implemented DNGROUP_AUTODESTRUCT
 *  01/18/00	rmt		Added calls into voice layer for Close
 *	01/19/00	mjn		Replaced DN_SYNC_EVENT with CSyncEvent
 *	01/20/00	mjn		Clean up NameTable operation list in DN_Close
 *	01/23/00	mjn		Added DN_DestroyPlayer and DNTerminateSession
 *	01/28/00	mjn		Added DN_ReturnBuffer
 *	02/01/00	mjn		Added DN_GetCaps, DN_SetCaps
 *	02/01/00	mjn		Implement Player/Group context values
 *	02/09/00	mjn		Implemented DNSEND_COMPLETEONPROCESS
 *	02/15/00	mjn		Implement INFO flags in SetInfo and return context in GetInfo
 *	02/17/00	mjn		Implemented GetPlayerContext and GetGroupContext
 *	02/17/00	mjn		Reordered parameters in EnumServiceProviders,EnumHosts,Connect,Host
 *	02/18/00	mjn		Converted DNADDRESS to IDirectPlayAddress8
 *  03/17/00    rmt     Moved caps funcs to caps.h/caps.cpp
 *	03/23/00	mjn		Set group context through CreateGroup
 *				mjn		Set player context through Host and Connect
 *				mjn		Implemented RegisterLobby()
 *	03/24/00	mjn		Release SP when EnumHost completes
 *  03/25/00    rmt     Added call into DPNSVR when host begins
 *  04/04/00	rmt		Added flag to disable calls to DPNSVR and flag to disable
 *						parameter validation
 *	04/05/00	mjn		Fixed DestroyClient API call
 *	04/06/00	mjn		Added DN_GetHostAddress()
 *	04/07/00	mjn		Prevent Initialize() API from being called twice
 *				mjn		Ensure Host addresses have SP included
 *				mjn		Fixed DN_GetHostAddress() to get address
 *	04/09/00	mjn		Convert DN_Host() and DN_Connect() to use CAsyncOp
 *	04/10/00	mjn		Fixed DN_Close() to use flags
 *	04/11/00	mjn		Use CAsyncOp for ENUMs
 *				mjn		Moved ProcessEnumQuery and ProcessEnumResponse to EnumHosts.cpp
 *				mjn		DNCancelEnum() uses CAsyncOp
 *	04/12/00	mjn		DNTerminateSession() cancels outstanding ENUMs
 *				mjn		DN_Close() cancels ENUMs instead of DNTerminateSession
 *				mjn		DN_Close() clears DN_OBJECT_FLAG_DISCONNECTING
 *  04/13/00	rmt     More parameter validation
 *	04/14/00	mjn		Default Host SP to Device SP if not specified
 *				mjn		Crack LISTENs in DN_Host for DPNSVR
 *	04/16/00	mjn		DNSendMessage uses CAsyncOp
 *	04/17/00	mjn		DNCancelSend() uses CAsyncOp
 *	04/17/00	mjn		Fixed DN_EnumHosts to use Handle parent and SYNC operation
 *				mjn		DN_Close tries to cancel SENDs and ENUMs
 *	04/18/00	mjn		CConnection tracks connection status better
 *				mjn		Deinitialize HandleTable, and release addresses in DN_Close
 *				mjn		Fixed DN_GetApplicationDesc to return correct size
 *	04/19/00	mjn		Changed DN_SendTo to accept a range of DPN_BUFFER_DESCs and a count
 *				mjn		Shut down LISTENs earlier in Close sequence
 *	04/20/00	mjn		Convert ReceiveBuffers to CAsyncOp and reclaim at Close
 *				mjn		DN_SendTo() may be invoked by IDirectPlay8Client::DN_Send()
 *	04/23/00	mjn		Added parameter to DNPerformChildSend()
 *				mjn		Reimplemented SEND_COMPLETEONPROCESS
 *	04/24/00	mjn		Updated Group and Info operations to use CAsyncOp's
 *	04/25/00	mjn		Added DNCancelConnect to DN_CancelAsyncOperation
 *	04/26/00	mjn		Fixed DN_GetSendQueueInfo to use CAsyncOp's
 *	04/26/00	mjn		Removed DN_ASYNC_OP and related functions
 *	04/27/00	mjn		Cause DN_GetPlayerContext()/DN_GetGroupContext() to fail if disconnecting
 *	04/28/00	mjn		Allow a NULL Device Address in DN_Connect() - steal SP from Host Address
 *				mjn		Save user connect data to be passed during CONNECT sequence
 *				mjn		Prevent infinite loops in group SENDs
 *  05/01/00    rmt     Bug #33403 - Require DPNSESSION_CLIENT_SERVER mode in client/server mode
 *	05/01/00	mjn		Prevent unusable SPs from being enumerated.
 *	05/03/00	mjn		Use GetHostPlayerRef() rather than GetHostPlayer()
 *	05/04/00	mjn		Clean up address list in DN_Host()
 *	05/05/00	mjn		Free pvConnectData in DN_Close()
 *				mjn		Fixed leak in DN_GetHostAddress()
 *	05/16/00	mjn		Force return code from ASYNC DN_SendTo() to return DPNERR_PENDING
 *				mjn		Better locking for User notifications
 *	05/30/00	mjn		Modified logic for group sends to target connected players only
 *				mjn		ASSERT if operations cannot be cancelled in DN_Close()
 *	05/31/00	mjn		Added operation specific SYNC flags
 *	05/31/00	mjn		Prevent ALL_PLAYERS group from being enum'd in DN_EnumClientsAndGroups()
 *				mjn		Skip invalid Host addresses
 *	06/05/00	mjn		Fixed DN_SendTo to handle some errors gracefully
 *	06/19/00	mjn		DN_Connect and DN_Host enumerate adapters if ALL_ADAPTERS specified
 *	06/20/00	mjn		Fixed DN_GetHostAddress() to extract host address from LISTENs
 *				mjn		DOH!  Forgot to change a line in DN_Host() so that LISTENs use enum'd adapter rather than ALL_ADAPTER
 *	06/22/00	mjn		Replace CConnection::MakeConnected() with SetStatus()
 *	06/23/00	mjn		Removed dwPriority from DN_SendTo()
 *	06/24/00	mjn		Added parent CONNECT AsyncOp to DN_Connect()
 *				mjn		Return DPNERR_UNINITIALIZED from DN_Close() if not initialized (called twice)
 *	06/25/00	mjn		Added DNUpdateLobbyStatus(), update status for CONNECTED,DISCONNECTED
 *				mjn		Set DirectNetObject as CONNECTED earlier in DN_Host()
 *	06/26/00	mjn		Replaced DPNADDCLIENTTOGROUP_SYNC DPNADDPLAYERTOGROUP_SYNC
 *				mjn		Replaced DPNREMOVECLIENTFROMGROUP_SYNC with DPNREMOVEPLAYERFROMGROUP_SYNC
 *				mjn		Fixed for() loop counter problem - nested counters used the same variable - DOH !
 *	06/27/00	mjn		Allow priorities to be specified to GetSendQueueInfo() API calls
 *				rmt		Added abstraction for COM_Co(Un)Initialize
 *				mjn		Removed ASSERT player not found in DN_GetPlayerContext()
 *				mjn		Added DPNSEND_NONSEQUENTIAL flag to Send/SendTo
 *				mjn		Allow mix-n-match of priorities in GetSendQueueInfo() API call
 *	07/02/00	mjn		Modified DN_SendTo() to use DNSendGroupMessage()
 *	07/06/00	mjn		Added missing completions for group sends
 *				mjn		Fixed locking problem in CNameTable::MakeLocalPlayer,MakeHostPlayer,MakeAllPlayersGroup
 *				mjn		Turned DPNSEND_NONSEQUENTIAL flag back on in DN_SendTo()
 *				mjn		Use SP handle instead of interface
 *	07/07/00	mjn		Cleanup pNewHost on DirectNetObject at close
 *	07/08/00	mjn		Fixed CAsyncOp to contain m_bilinkParent
 *  07/09/00	rmt		Bug #38323 - RegisterLobby needs a DPNHANDLE parameter.
 *	07/11/00	mjn		Added NOLOOPBACK capability to group sends
 *				mjn		Fixed DN_EnumHosts() to handle multiple adapters
 *	07/12/00	mjn		Copy user data on EnumHosts()
 *	07/17/00	mjn		Removed redundant SyncEvent->Reset() in DN_Initialize
 *				mjn		Clear DN_OBJECT_FLAG_HOST_CONNECTED in DN_Close()
 *				mjn		Check correct return value of DNSendGroupMessage() in DN_SendTo()
 *  07/19/00    aarono	Bug#39751 add CancelAsyncOperation flag support.
 *	07/20/00	mjn		Cleaned up DN_Connect()
 *  07/21/00    RichGr  IA64: Use %p format specifier for 32/64-bit pointers.
 *	07/21/00	mjn		Cleaned up DN_Close() to release connection object reference
 *	07/23/00	mjn		Moved assertion in DN_CanceAsyncOperation
 *	07/25/00	mjn		Fail DN_EnumHosts() if no valid device adapters exist
 *	07/26/00	mjn		Fix error codes returned from DN_Connect(),DN_GetSendQueueInfo(),DN_DestroyGroup()
 *						DN_AddClientToGroup(),DN_RemoveClientFromGroup(),DN_SetGroupInfo()
 *						DN_GetGroupInfo(),DN_EnumGroupMembers()
 *				mjn		Fix DN_GetApplicationDesc() to always return buffer size
 *	07/26/00	mjn		Fixed locking problem with CAsyncOp::MakeChild()
 *	07/28/00	mjn		Revised DN_GetSendQueueInfo() to use queue info on CConnection objects
 *				mjn		Cleaned up DN_GetPlayerContext() and DN_GetGroupContext()
 *	07/29/00	mjn		Better clean up of pending Connect()'s during Close()
 *				mjn		Check user data size in DN_EnumHosts()
 *				mjn		Added fUseCachedCaps to DN_SPEnsureLoaded()
 *	07/30/00	mjn		Replaced DN_NAMETABLE_PENDING_OP with CPendingDeletion
 *	07/31/00	mjn		Added hrReason to DNTerminateSession()
 *				mjn		Added dwDestroyReason to DNHostDisconnect()
 *				mjn		Cleaned up DN_TerminateSession()
 *  08/03/00	rmt		Bug #41244 - Wrong return codes -- part 2 
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/05/00	mjn		Added pParent to DNSendGroupMessage and DNSendMessage()
 *				mjn		Ensure cancelled operations don't proceed
 *				mjn		Prevent hosting players from calling DN_EnumHosts()
 *				mjn		Generate TERMINATE_SESSION notification for host player
 *	08/06/00	mjn		Added CWorkerJob
 *	08/09/00	mjn		Moved no-loop-back test in DN_SendTo()
 *  08/15/00	rmt		Bug #42506 - DPLAY8: LOBBY: Automatic connection settings not being sent
 *	08/15/00	mjn		Remapped DPNERR_INVALIDENDPOINT from DPNERR_INVALIDPLAYER to DPNERR_NOCONNECTION in DN_SendTo()
 *				mjn		Addef hProtocol to DNRegisterWithDPNSVR() and removed registration from DN_Host()
 *	08/16/00	mjn		Return DPNERR_INVALIDHOSTADDRESS from DN_EnumHosts() if host address is invalid
 *	08/20/00	mjn		Removed fUseCachedCaps from DN_SPEnsureLoaded()
 *	08/23/00	mjn		Flag DirectNetObject as registered with DPNSVR
 *	08/24/00	mjn		Replace DN_NAMETABLE_OP with CNameTableOp
 *	08/29/00	mjn		Remap DPNERR_INVALIDPLAYER to DPNERR_CONNECTIONLOST in DN_SendTo()
 *	09/01/00	masonb		Modified DN_Close to call CloseHandle on hWorkerThread
 *	09/04/00	mjn		Added CApplicationDesc
 *	09/05/00	mjn		Set NameTable DPNID mask when hosting
 *	09/06/00	mjn		Fixed register with DPNSVR problem
 *  09/13/00	rmt		Bug #44625 - DPVOICE: Multihomed machines are not always enumerable
 *						Moved registration for DPNSVR into ListenComplete
 *	09/17/00	mjn		Split CNameTable.m_bilinkEntries into m_bilinkPlayers and m_bilinkGroups
 *	10/11/00	mjn		Take locks for CNameTableEntry::PackInfo()
 *	10/12/00	mjn		Set async handle completion after succeeding in DN_EnumHosts()
 *	10/17/00	mjn		Fixed clean up for unreachable players
 *	11/16/00	mjn		Fixed uninitialized variable problem in DN_CancelAsyncOperation()
 *	12/11/00	mjn		Allow API calls after TERMINATE_SESSION without calling Close() first
 *	01/09/01	mjn		CancelAsyncOperations() returns DPNERR_CANNOTCANCEL if operation doesn't allow it
 *	01/10/01	mjn		DN_Connect() cancels ENUMs with DPNERR_CONNECTING
 *	01/22/01	mjn		Check closing instead of disconnecting in getting player/group context and info
 *				mjn		Fixed debug text
 *	02/12/01	mjn		GetPlayerContext() and GetGroupContext() return DPNERR_NOTREADY if context not yet set
 *	03/30/01	mjn		Changes to prevent multiple loading/unloading of SP's
 *				mjn		Use cached enum frame size
 *	04/11/01	mjn		Save hosting flag for query for addressing when listening
 *	05/02/01	vpo		Whistler 380319: "DPLAY8: CORE: Starts listening before creating local nametable entry"
 *	05/07/01	vpo		Whistler 384350: "DPLAY8: CORE: Messages from server can be indicated before connect completes"
 *	05/14/01	mjn		Fix client error handling when completing connect if server not available
 *	05/22/01	mjn		Properly set DirectNetObject as CONNECTED for successful client connect
 *	06/03/01	mjn		Clean up connect parent in DNTerminateSession()
 *	06/12/01	mjn		Ensure DN_Initialize() returns non-DPN_OK value when creating new CSyncEvent or thread fails
 *	06/25/01	mjn		Unregister from DPNSVR in DNTerminateSession()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

extern DN_PROTOCOL_INTERFACE_VTBL g_ProtocolVTBL;

//**********************************************************************
// Function prototypes
//**********************************************************************

HRESULT DNGetHostAddressHelper(DIRECTNETOBJECT *pdnObject, 
							   IDirectPlay8Address **const prgpAddress,
							   DWORD *const pcAddress);

//
//	Store the user-supplied message handler and context value for call backs
//

#undef DPF_MODNAME
#define DPF_MODNAME "DN_Initialize"

STDMETHODIMP DN_Initialize(PVOID pInterface,
						   PVOID const pvUserContext,
						   const PFNDPNMESSAGEHANDLER pfn,
						   const DWORD dwFlags)
{
	HRESULT				hResultCode = DPN_OK;
	DIRECTNETOBJECT		*pdnObject;
	DWORD				dwThreadID;
	CSyncEvent			*pSyncEvent;
	BOOL				fApplicationDesc;
	BOOL				fNameTable;
	BOOL				fHandleTable;
	BOOL				fProtocol;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], pvUserContext [0x%p], pfn [0x%p], dwFlags [0x%lx]",
			pInterface,pvUserContext,pfn,dwFlags);
	TRY
	{
    	if( !IsValidDirectPlay8Object( pInterface ) )
    	{
    	    DPFERR("Invalid object specified" );
    	    DPF_RETURN( DPNERR_INVALIDOBJECT );
    	}

    	if( pfn == NULL )
    	{
    	    DPFERR("You must specify a callback function" );
    	    DPF_RETURN( DPNERR_INVALIDPARAM );
    	}

    	if( dwFlags & ~(DPNINITIALIZE_DISABLEPARAMVAL) )
    	{
    	    DPFERR("Invalid flags specified" );
    	    DPF_RETURN( DPNERR_INVALIDFLAGS );
    	}

    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    	DNASSERT(pdnObject != NULL);

    	// Ensure not already initialized
    	if (pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED)
    	{
    	    DPFERR("Initialize has already been called" );
    		DPF_RETURN(DPNERR_ALREADYINITIALIZED);
    	}

    	// Disable parameter validation flag if DPNINITIALIZE_DISABLEPARAMVAL
    	// is specified
    	if( dwFlags & DPNINITIALIZE_DISABLEPARAMVAL )
    	{
    		pdnObject->dwFlags &= ~(DN_OBJECT_FLAG_PARAMVALIDATION);
    	}
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}	

	fApplicationDesc = FALSE;
	fNameTable = FALSE;
	fHandleTable = FALSE;
	fProtocol = FALSE;
	pSyncEvent = NULL;

	//
	//	Lock DirectNetObject in case someone's trying something funny
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Initialize ApplicationDescription
	//
	if ((hResultCode = pdnObject->ApplicationDesc.Initialize()) != DPN_OK)
	{
		DPFERR("Could not initialize ApplicationDesc");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	fApplicationDesc = TRUE;

	//
	//	Initialize NameTable
	//
	if ((hResultCode = pdnObject->NameTable.Initialize(pdnObject)) != DPN_OK)
	{
		DPFERR("Could not initialize NameTable");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	fNameTable = TRUE;

	//
	//	Initialize HandleTable
	//
	if ((hResultCode = pdnObject->HandleTable.Initialize()) != DPN_OK)
	{
		DPFERR("Could not initialize HandleTable");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	fHandleTable = TRUE;

	//
	//	Initialize protocol and create shut-down event
	//
	DNASSERT(pdnObject->lProtocolRefCount == 0);
	if ((hResultCode = DNPProtocolInitialize( pdnObject, pdnObject->pdnProtocolData, &g_ProtocolVTBL)) != DPN_OK)
	{
		DNASSERT(hResultCode == DPNERR_OUTOFMEMORY);
		hResultCode = DPNERR_OUTOFMEMORY;
		DPFERR("DNPProtocolInitialize() failed");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pdnObject->lProtocolRefCount = 1;
	fProtocol = TRUE;

	DNASSERT( pdnObject->hProtocolShutdownEvent == NULL );
	if ((hResultCode = SyncEventNew(pdnObject,&pSyncEvent)) != DPN_OK)
	{
		DPFERR("Could not get protocol shutdown event");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Spawn worker thread
	//
	DPFX(DPFPREP, 3,"Spawning worker thread");
	if ((pdnObject->hWorkerThread = CreateThread(NULL,0,DNWorkerThreadProc,pdnObject,0,
			&dwThreadID)) == NULL)
	{
		hResultCode = DPNERR_OUTOFMEMORY;
		DPFERR("DNPProtocolInitialize() failed");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	DPFX(DPFPREP, 5,"Worker thread id [0x%lx]",dwThreadID);

	pdnObject->hProtocolShutdownEvent = pSyncEvent;
	pSyncEvent = NULL;
	pdnObject->pfnDnUserMessageHandler = pfn;
	pdnObject->pvUserContext = pvUserContext;
	pdnObject->dwFlags |= DN_OBJECT_FLAG_INITIALIZED;
	pdnObject->dwMaxFrameSize = 0;

	hResultCode = DPN_OK;

Exit:
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (fApplicationDesc)
	{
		pdnObject->ApplicationDesc.Deinitialize();
	}
	if (fNameTable)
	{
		pdnObject->NameTable.Deinitialize();
	}
	if (fHandleTable)
	{
		pdnObject->HandleTable.Deinitialize();
	}
	if (pSyncEvent)
	{
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}
	if (fProtocol)
	{
		DNProtocolRelease(pdnObject);
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_Close"

STDMETHODIMP DN_Close(PVOID pInterface,const DWORD dwFlags)
{
	HRESULT				hResultCode = DPN_OK;
	DIRECTNETOBJECT		*pdnObject;
	CBilink				*pBilink;
	CAsyncOp			*pAsyncOp;
	CConnection			*pConnection;
	CPendingDeletion	*pPending;
	CServiceProvider	*pSP;
	BOOL				fWaitForEvent;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], dwFlags [0x%lx]",pInterface,dwFlags);

	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    	DNASSERT(pdnObject != NULL);
    	
    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
        	if( !IsValidDirectPlay8Object( pInterface ) )
    	    {
    	        DPFERR("Invalid object specified " );
        	    DPF_RETURN( DPNERR_INVALIDOBJECT );
    	    }

			if (dwFlags != 0)
			{
				DPFERR("Invalid flags");
				DPF_RETURN( DPNERR_INVALIDFLAGS );
			}
    	}	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}

	pAsyncOp = NULL;
	pConnection = NULL;
	pSP = NULL;

	//
	//	Ensure this isn't being called on a callback thread
	//
	DNEnterCriticalSection(&pdnObject->csCallbackThreads);
	pBilink = pdnObject->m_bilinkCallbackThreads.GetNext();
	while (pBilink != &pdnObject->m_bilinkCallbackThreads)
	{
		if ((CONTAINING_OBJECT(pBilink,CCallbackThread,m_bilinkCallbackThreads))->IsCurrentThread())
		{
			DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
			DPFERR("Cannot call Close on a callback thread");
			hResultCode = DPNERR_NOTALLOWED;
			goto Failure;
		}
		pBilink = pBilink->GetNext();
	}
	DNLeaveCriticalSection(&pdnObject->csCallbackThreads);
	
    //
	//	Flag as closing.   Make sure this hasn't already been called.
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);

	// Ensure already initialized
	if ( !(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED) )
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);	
	    DPFERR("Object is not initialized" );
		DPF_RETURN(DPNERR_UNINITIALIZED);
	}	
	
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING)
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		DPFERR("Already closing" );
		hResultCode = DPNERR_ALREADYCLOSING;
		goto Failure;
	}
	
	pdnObject->dwFlags |= DN_OBJECT_FLAG_CLOSING;
	if (pdnObject->dwLockCount == 0)
	{
		fWaitForEvent = FALSE;
	}
	else
	{
		fWaitForEvent = TRUE;
	}

	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

#ifdef	DEBUG
	{
		CNameTableEntry	*pLocalPlayer;

		if (pdnObject->NameTable.GetLocalPlayerRef(&pLocalPlayer) == DPN_OK)
		{
			DPFX(DPFPREP, 0,"Local player was [0x%lx]",pLocalPlayer->GetDPNID());
			pLocalPlayer->Release();
		}
	}
#endif

	//
	//	If there are operations underway, we will wait for them to complete and release the lock count
	//
	if (fWaitForEvent)
	{
		if (WaitForSingleObject(pdnObject->hLockEvent,INFINITE) != WAIT_OBJECT_0)
		{
			DPFERR("WaitForSingleObject() terminated strangely");
			DNASSERT(FALSE);
		}
	}

	//
	//	Cancel connect
	//
	DPFX(DPFPREP, 3,"Checking CONNECT");
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pAsyncOp = pdnObject->pConnectParent;
	pdnObject->pConnectParent = NULL;
	pSP = pdnObject->pConnectSP;
	pdnObject->pConnectSP = NULL;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	if (pAsyncOp)
	{
		pAsyncOp->Lock();
		pConnection = pAsyncOp->GetConnection();
		pAsyncOp->SetConnection( NULL );
		pAsyncOp->Unlock();

		DPFX(DPFPREP, 3,"Canceling CONNECT");
		hResultCode = DNCancelChildren(pdnObject,pAsyncOp);
		DPFX(DPFPREP, 3,"Canceling CONNECT returned [0x%lx]",hResultCode);

		pAsyncOp->Release();
		pAsyncOp = NULL;

		if (pConnection)
		{
			pConnection->Disconnect();
			pConnection->Release();
			pConnection = NULL;
		}
	}

	if (pSP)
	{
		pSP->Release();
		pSP = NULL;
	}

	//
	//	Remove outstanding ENUMs, SENDs, RECEIVE_BUFFERs
	//
	DPFX(DPFPREP, 3,"Canceling outstanding operations");
	hResultCode = DNCancelActiveCommands(pdnObject,(  DN_CANCEL_FLAG_ENUM_QUERY
													| DN_CANCEL_FLAG_ENUM_RESPONSE
													| DN_CANCEL_FLAG_USER_SEND
													| DN_CANCEL_FLAG_INTERNAL_SEND
													| DN_CANCEL_FLAG_RECEIVE_BUFFER ),
													FALSE,
													0);
	DPFX(DPFPREP, 3,"Canceling outstanding operations returned [0x%lx]",hResultCode);

	//
	//	Cancel any REQUESTs
	//
	DPFX(DPFPREP, 3,"Canceling requests");
	hResultCode = DNCancelRequestCommands(pdnObject);
	DPFX(DPFPREP, 3,"Canceling requests returned [0x%lx]",hResultCode);

	//
	//	Terminate session.  This will remove all players from the NameTable
	//
	DPFX(DPFPREP, 3,"Terminate Session");
	if ((hResultCode = DNTerminateSession(pdnObject,DPN_OK)) != DPN_OK)
	{
		DPFERR("Could not terminate session");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
	}

	//
	//	Disconnect any indicated connections
	//
	DNEnterCriticalSection(&pdnObject->csConnectionList);
	while (pdnObject->m_bilinkIndicated.GetNext() != &pdnObject->m_bilinkIndicated)
	{
		pConnection = CONTAINING_OBJECT(pdnObject->m_bilinkIndicated.GetNext(),CConnection,m_bilinkIndicated);
		pConnection->m_bilinkIndicated.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csConnectionList);

		DNASSERT(pConnection->GetDPNID() == 0);

		pConnection->Disconnect();
		pConnection->Release();
		pConnection = NULL;

		DNEnterCriticalSection(&pdnObject->csConnectionList);
	}
	DNLeaveCriticalSection(&pdnObject->csConnectionList);

	//
	//	Release SP's
	//
	DPFX(DPFPREP, 3,"Releasing SPs");
	DN_SPReleaseAll(pdnObject);

	//
	//	Shut down protocol
	//
	DPFX(DPFPREP, 3,"Shutting down Protocol");
	DNProtocolRelease(pdnObject);
	pdnObject->hProtocolShutdownEvent->WaitForEvent(INFINITE);
	if ((hResultCode = DNPProtocolShutdown(pdnObject->pdnProtocolData)) != DPN_OK)
	{
		DPFERR("Could not shut down Protocol Layer !");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
	}
	pdnObject->hProtocolShutdownEvent->ReturnSelfToPool();
	pdnObject->hProtocolShutdownEvent = NULL;

	//
	//	Shut down worker thread
	//
	if (pdnObject->hWorkerThread)
	{
		DPFX(DPFPREP, 3,"Terminating Worker Thread");
		DNWTTerminate(pdnObject);
		WaitForSingleObject(pdnObject->hWorkerThread,INFINITE);
		CloseHandle(pdnObject->hWorkerThread);
		pdnObject->hWorkerThread = NULL;
	}

	//
	//	Deinitialize HandleTable
	//
	DPFX(DPFPREP, 3,"Deinitializing HandleTable");
	pdnObject->HandleTable.Deinitialize();

	//
	//	Deinitialize NameTable
	//
	DPFX(DPFPREP, 3,"Deinitializing NameTable");
	pdnObject->NameTable.Deinitialize();

	//
	//	Deinitialize ApplicationDescription
	//
	DPFX(DPFPREP, 3,"Deinitializing ApplicationDesc");
	pdnObject->ApplicationDesc.Deinitialize();

	//
	//	Any pending NameTable operations
	//
	pBilink = pdnObject->m_bilinkPendingDeletions.GetNext();
	while (pBilink != &pdnObject->m_bilinkPendingDeletions)
	{
		pPending = CONTAINING_OBJECT(pBilink,CPendingDeletion,m_bilinkPendingDeletions);
		pBilink = pBilink->GetNext();
		pPending->m_bilinkPendingDeletions.RemoveFromList();
		pPending->ReturnSelfToPool();
		pPending = NULL;
	}

	//
	//	Misc Clean Up
	//
	if (pdnObject->pIDP8ADevice)
	{
		pdnObject->pIDP8ADevice->lpVtbl->Release(pdnObject->pIDP8ADevice);
		pdnObject->pIDP8ADevice = NULL;
	}
	if (pdnObject->pvConnectData)
	{
		DNFree(pdnObject->pvConnectData);
		pdnObject->pvConnectData = NULL;
		pdnObject->dwConnectDataSize = 0;
	}

	if( pdnObject->pConnectAddress )
	{
		pdnObject->pConnectAddress->lpVtbl->Release( pdnObject->pConnectAddress );
		pdnObject->pConnectAddress = NULL;
	}

	if( pdnObject->pTargetList )
	{
		delete [] pdnObject->pTargetList;
		pdnObject->pTargetList = NULL;
	}

	if( pdnObject->pExpandedTargetList )
	{
		delete [] pdnObject->pExpandedTargetList;
		pdnObject->pExpandedTargetList = NULL;
	}	

	pdnObject->dpnhLobbyConnection = NULL;

	// Release our hold on the lobbiedapplication
	if( pdnObject->pIDP8LobbiedApplication) 
	{
		pdnObject->pIDP8LobbiedApplication->lpVtbl->Release(pdnObject->pIDP8LobbiedApplication);
		pdnObject->pIDP8LobbiedApplication = NULL;
	}

	//
	//	Reset DirectNet object flag
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->dwFlags &= (~( DN_OBJECT_FLAG_INITIALIZED
							| DN_OBJECT_FLAG_CLOSING
//							| DN_OBJECT_FLAG_DISCONNECTING
//							| DN_OBJECT_FLAG_HOST_CONNECTED
							| DN_OBJECT_FLAG_LOCALHOST ));
	pdnObject->dwMaxFrameSize = 0;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

Exit:
	DNASSERT( pAsyncOp == NULL );
	DNASSERT( pConnection == NULL );
	DNASSERT( pSP == NULL );

	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	goto Exit;
}


//
// Enumerate SP's if no SPGUID supplied, or SP Adapters if an SPGUID is supplied
//

#undef DPF_MODNAME
#define DPF_MODNAME "DN_EnumServiceProviders"

STDMETHODIMP DN_EnumServiceProviders( PVOID pInterface,
									  const GUID *const pguidServiceProvider,
									  const GUID *const pguidApplication,
									  DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer,
									  DWORD *const pcbEnumData,
									  DWORD *const pcReturned,
									  const DWORD dwFlags )
{
	HRESULT		        hResultCode;
	PDIRECTNETOBJECT    pdnObject;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], pguidServiceProvider [0x%p], pguidApplication [0x%p], pSPInfoBuffer [0x%p], pcbEnumData [0x%p], pcReturned [0x%p], dwFlags [0x%lx]",
		pInterface,pguidServiceProvider,pguidApplication,pSPInfoBuffer,pcbEnumData,pcReturned,dwFlags);

	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    	DNASSERT(pdnObject != NULL);

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
            if( FAILED( hResultCode = DN_ValidateEnumServiceProviders( pInterface, pguidServiceProvider, pguidApplication,
                                                                       pSPInfoBuffer, pcbEnumData, pcReturned, dwFlags ) ) )
            {
                DPFERR( "Error validating params" );
                DPF_RETURN(hResultCode);
            }
    	}

    	if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED) )
    	{
    	    DPFERR( "Object is not initialized" );
    	    DPF_RETURN( DPNERR_UNINITIALIZED );
    	}    	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}

    if (pguidServiceProvider == NULL)	// Enumerate all service providers
	{
		hResultCode = DN_EnumSP(pdnObject,dwFlags,pguidApplication,pSPInfoBuffer,pcbEnumData,pcReturned);
	}
	else	// Service provider specified - enumerate adaptors
	{
		hResultCode = DN_EnumAdapters(	pdnObject,
										dwFlags,
										pguidServiceProvider,
										pguidApplication,
										pSPInfoBuffer,
										pcbEnumData,
										pcReturned);
	}

	DPFX(DPFPREP, 3,"Set: *pcbEnumData [%ld], *pcReturned [%ld]",*pcbEnumData,*pcReturned);

	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//
//	Cancel an outstanding Async Operation.  hAsyncHandle is the operation handle returned when
//	the operation was initiated.
//

#undef DPF_MODNAME
#define DPF_MODNAME "DN_CancelAsyncOperation"

STDMETHODIMP DN_CancelAsyncOperation(PVOID pvInterface,
									 const DPNHANDLE hAsyncOp,
									 const DWORD dwFlags)
{
	HRESULT				hResultCode;
	CAsyncOp			*pHandleParent;
	CAsyncOp			*pAsyncOp;
	DIRECTNETOBJECT		*pdnObject;

	DPFX(DPFPREP, 2,"Parameters: pvInterface [0x%p], hAsyncOp [0x%lx], dwFlags [0x%lx]",
			pvInterface,hAsyncOp,dwFlags);

	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pvInterface));
    	DNASSERT(pdnObject != NULL);

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
    	    if( FAILED( hResultCode = DN_ValidateCancelAsyncOperation( pvInterface, hAsyncOp, dwFlags ) ) )
    	    {
    	        DPFERR( "Error validating params" );
    	        DPF_RETURN( hResultCode );
    	    }
    	}

    	if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED) )
    	{
    	    DPFERR( "Object is not initialized" );
    	    DPF_RETURN( DPNERR_UNINITIALIZED );
    	}    	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}

	pAsyncOp = NULL;
	pHandleParent = NULL;

	//
	//	If hAsyncOp is specified, we will cancel it.  Otherwise, we will rely on the flags to
	//	determine which operations to cancel.
	//
	if( hAsyncOp )
	{
		//
		//	Cancel single operation
		//

		if ((hResultCode = pdnObject->HandleTable.Find(hAsyncOp,&pHandleParent)) != DPN_OK)
		{
			DPFERR("Invalid USER Handle specified");
			hResultCode = DPNERR_INVALIDHANDLE;
			goto Failure;
		}
		if ( pHandleParent->GetOpType() != ASYNC_OP_USER_HANDLE )
		{
			DPFERR("Invalid USER Handle specified");
			hResultCode = DPNERR_INVALIDHANDLE;
			goto Failure;
		}

		//
		//	Some operations may be marked as CANNOT_CANCEL.  Return DPNERR_CANNOTCANCEL for these
		//
		if ( pHandleParent->IsCannotCancel() )
		{
			DPFERR("Operation not allowed to be cancelled");
			hResultCode = DPNERR_CANNOTCANCEL;
			goto Failure;
		}

		hResultCode = DNCancelChildren(pdnObject,pHandleParent);

		pHandleParent->Release();
		pHandleParent = NULL;
	}
	else
	{
		//
		//	Cancel many operations based on flags
		//
		DWORD	dwInternalFlags;
		HRESULT	hr;

		//
		//	Re-map flags
		//
		dwInternalFlags = 0;
		if (dwFlags & DPNCANCEL_ALL_OPERATIONS)
		{
			dwInternalFlags = (	DN_CANCEL_FLAG_CONNECT | DN_CANCEL_FLAG_ENUM_QUERY | DN_CANCEL_FLAG_USER_SEND );
		}
		else if (dwFlags & DPNCANCEL_CONNECT)
		{
			dwInternalFlags = DN_CANCEL_FLAG_CONNECT;
		}
		else if (dwFlags & DPNCANCEL_ENUM)
		{
			dwInternalFlags = DN_CANCEL_FLAG_ENUM_QUERY;
		}
		else if (dwFlags & DPNCANCEL_SEND)
		{
			dwInternalFlags = DN_CANCEL_FLAG_USER_SEND;
		}
		else
		{
			DNASSERT(FALSE);	// Should never get here
		}
		DPFX(DPFPREP, 3,"Re-mapped internal flags [0x%lx]",dwInternalFlags);

		//
		//	Pre-set error code
		hResultCode = DPN_OK;

		//
		//	To cancel a CONNECT, look at the DirectNetObject
		//
		if (dwInternalFlags & DN_CANCEL_FLAG_CONNECT)
		{
			DNEnterCriticalSection(&pdnObject->csDirectNetObject);
			if (pdnObject->pConnectParent)
			{
				if (pdnObject->pConnectParent->IsChild())
				{
					DNASSERT(pdnObject->pConnectParent->GetParent() != NULL);
					pdnObject->pConnectParent->GetParent()->AddRef();
					pAsyncOp = pdnObject->pConnectParent->GetParent();
				}
				else
				{
					pdnObject->pConnectParent->AddRef();
					pAsyncOp = pdnObject->pConnectParent;
				}
			}
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

			if (pAsyncOp)
			{
				DPFX(DPFPREP, 3,"Canceling CONNECT");
				hr = DNCancelChildren(pdnObject,pAsyncOp);
				if (hr != DPN_OK)
				{
					hResultCode = DPNERR_CANNOTCANCEL;
					DPFX(DPFPREP, 7,"Remapping: [0x%lx] returned by DNCancelChildren to: [0x%lx]",hr, hResultCode);
				}
				pAsyncOp->Release();
				pAsyncOp = NULL;
			}
		}

		//
		//	To cancel ENUMs and SENDs, cancel out of the active list
		//
		if (dwInternalFlags & (DN_CANCEL_FLAG_ENUM_QUERY | DN_CANCEL_FLAG_USER_SEND))
		{
			DPFX(DPFPREP, 3,"Canceling ENUMs and SENDs");
			hr = DNCancelActiveCommands(pdnObject,dwInternalFlags,FALSE,0);
			if (hr != DPN_OK)
			{
				hResultCode = DPNERR_CANNOTCANCEL;
				DPFX(DPFPREP, 7,"Remapping: [0x%lx] returned by DNCancelActiveCommands to: [0x%lx]",hr, hResultCode);
			}
		}
	}

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pAsyncOp)
	{
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	if (pHandleParent)
	{
		pHandleParent->Release();
		pHandleParent = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_Connect"

STDMETHODIMP DN_Connect( PVOID pInterface,
						 const DPN_APPLICATION_DESC *const pdnAppDesc,
						 IDirectPlay8Address *const pHostAddr,
						 IDirectPlay8Address *const pDeviceInfo,
						 const DPN_SECURITY_DESC *const pdnSecurity,
						 const DPN_SECURITY_CREDENTIALS *const pdnCredentials,
						 const void *const pvUserConnectData,
						 const DWORD dwUserConnectDataSize,
						 void *const pvPlayerContext,
						 void *const pvAsyncContext,
						 DPNHANDLE *const phAsyncHandle,
						 const DWORD dwFlags)
{
	CAsyncOp			*pHandleParent;
	CAsyncOp			*pConnectParent;
	CAsyncOp			*pAsyncOp;
	HRESULT				hResultCode;
	DIRECTNETOBJECT		*pdnObject;
	CSyncEvent			*pSyncEvent;
	HRESULT	volatile	hrOperation;
	IDirectPlay8Address	*pIHost;
	IDirectPlay8Address	*pIDevice;
	IDirectPlay8Address	*pIAdapter;
	DWORD				dwConnectFlags;
	GUID				guidSP;
	GUID				guidAdapter;
	void				*pvConnectData;
	void				*pvAdapterBuffer;
	DPN_SP_CAPS			dnSPCaps;
	BOOL				fEnumAdapters;
	DN_CONNECT_OP_DATA	*pConnectOpData;
	CRefCountBuffer		*pReply;
	CServiceProvider	*pSP;
	DWORD				dwMultiplexFlag;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], pdnAppDesc [0x%p], pHostAddr [0x%p], pDeviceInfo [0x%p], pdnSecurity [0x%p], pdnCredentials [0x%p], pvUserConnectData [0x%p], dwUserConnectDataSize [%ld], pvAsyncContext [0x%p], phAsyncHandle [0x%p], dwFlags [0x%lx]",
		pInterface,pdnAppDesc,pHostAddr,pDeviceInfo,pdnSecurity,pdnCredentials,pvUserConnectData,dwUserConnectDataSize,pvAsyncContext,phAsyncHandle,dwFlags);

	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    	DNASSERT(pdnObject != NULL);

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
    	    if( FAILED( hResultCode = DN_ValidateConnect( pInterface, pdnAppDesc, pHostAddr, pDeviceInfo,
                                                          pdnSecurity, pdnCredentials, pvUserConnectData,
                                                          dwUserConnectDataSize,pvPlayerContext,
                                                          pvAsyncContext,phAsyncHandle,dwFlags ) ) )
    	    {
    	        DPFERR( "Error validating connect params" );
    	        DPF_RETURN( hResultCode );
    	    }
    	}    	

    	// Check to ensure not already connected/connecting
    	DNEnterCriticalSection(&pdnObject->csDirectNetObject);

    	// Check to ensure message handler registered
    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    	{
    		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
    		DPFERR( "Object is not initialized" );
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}
    	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING)
    	{
    		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
    		DPFERR( "Object is already connecting" );
    		DPF_RETURN(DPNERR_CONNECTING);
    	}
    	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED)
    	{
    		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
    		DPFERR( "Object is already connected" );
    		DPF_RETURN(DPNERR_ALREADYCONNECTED);
    	}
		if (pdnObject->dwFlags & (DN_OBJECT_FLAG_CLOSING | DN_OBJECT_FLAG_DISCONNECTING))
		{
    		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
    		DPFERR( "Object is closing or disconnecting" );
    		DPF_RETURN(DPNERR_ALREADYCLOSING);
		}
    	pdnObject->dwFlags |= DN_OBJECT_FLAG_CONNECTING;
    	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}

	// Preset these so that they are properly cleaned up
	pIHost = NULL;
	pIDevice = NULL;
	pIAdapter = NULL;
	pSyncEvent = NULL;
	pHandleParent = NULL;
	pConnectParent = NULL;
	pAsyncOp = NULL;
	pvConnectData = NULL;
	pvAdapterBuffer = NULL;
	hrOperation = DPNERR_GENERIC;
	pConnectOpData = NULL;
	pReply = NULL;
	pSP = NULL;
	dwMultiplexFlag = 0;

	if ((hResultCode = pHostAddr->lpVtbl->Duplicate(pHostAddr,&pIHost)) != DPN_OK)
	{
		DPFERR("Could not duplicate host address");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	//
	//	Duplicate specified Device Address, or create a blank one if NULL
	//
	if (pDeviceInfo != NULL)
	{
		if ((hResultCode = pDeviceInfo->lpVtbl->Duplicate(pDeviceInfo,&pIDevice)) != DPN_OK)
		{
			DPFERR("Could not duplicate device info");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
	}
	else
	{
		if ((hResultCode = COM_CoCreateInstance(CLSID_DirectPlay8Address,
											NULL,
											CLSCTX_INPROC_SERVER,
											IID_IDirectPlay8Address,
											reinterpret_cast<void**>(&pIDevice))) != S_OK)
		{
			DPFERR("Could not create Device Address");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
	}

	//
	//	If there is no SP on the device address, then steal it from the Host address
	//
	if ((hResultCode = pIDevice->lpVtbl->GetSP(pIDevice,&guidSP)) != DPN_OK)
	{
		if ((hResultCode = pIHost->lpVtbl->GetSP(pIHost,&guidSP)) != DPN_OK)
		{
			DPFERR("Could not retrieve SP from Host Address");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
		if ((hResultCode = pIDevice->lpVtbl->SetSP(pIDevice,&guidSP)) != DPN_OK)
		{
			DPFERR("Could not set SP on Device Address");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
	}

	//
	//	Ensure SP is loaded
	//
	if ((hResultCode = DN_SPEnsureLoaded(pdnObject,&guidSP,NULL,&pSP)) != DPN_OK)
	{
		DPFERR("Could not find or load SP");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Get SP caps
	//
	if ((hResultCode = DNGetActualSPCaps(pdnObject,pSP,&dnSPCaps)) != DPN_OK)
	{
		DPFERR("Could not get SP caps");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Update DirectNet Application Description
	//
	pdnObject->ApplicationDesc.Lock();
	hResultCode = pdnObject->ApplicationDesc.Update(pdnAppDesc,DN_APPDESCINFO_FLAG_SESSIONNAME|DN_APPDESCINFO_FLAG_PASSWORD|
			DN_APPDESCINFO_FLAG_RESERVEDDATA|DN_APPDESCINFO_FLAG_APPRESERVEDDATA);
	pdnObject->ApplicationDesc.Unlock();

	// Connect flags to Protocol
	dwConnectFlags = 0;
	if (dwFlags & DPNCONNECT_OKTOQUERYFORADDRESSING)
	{
		dwConnectFlags |= DN_CONNECTFLAGS_OKTOQUERYFORADDRESSING;
	}

	//
	//	Create parent async op, which will be released when the ENTIRE connection is finished
	//	including nametable transfer and installation on the local machine
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pConnectParent)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pConnectParent->SetOpType( ASYNC_OP_CONNECT );
	pConnectParent->MakeParent();
	pConnectParent->SetContext( pvPlayerContext );
	pConnectParent->SetResult( DPNERR_NOCONNECTION );
	pConnectParent->SetCompletion( DNCompleteConnectOperation );
	pConnectParent->SetReserved(1);

	if (dwFlags & DPNCONNECT_SYNC)
	{
		DPFX(DPFPREP, 5,"Sync operation - create sync event");
		if ((hResultCode = SyncEventNew(pdnObject,&pSyncEvent)) != DPN_OK)
		{
			DPFERR("Could not create synchronization event");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pConnectParent->SetSyncEvent( pSyncEvent );
		pConnectParent->SetResultPointer( &hrOperation );
		pConnectParent->SetOpData( &pReply );
	}
	else
	{
		DPFX(DPFPREP, 5,"Async operation - create handle parent");
		if ((hResultCode = DNCreateUserHandle(pdnObject,&pHandleParent)) != DPN_OK)
		{
			DPFERR("Could not create handle parent");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pHandleParent->SetContext( pvAsyncContext );

		pHandleParent->Lock();
		if (pHandleParent->IsCancelled())
		{
			pHandleParent->Unlock();
			pConnectParent->SetResult( DPNERR_USERCANCEL );
			hResultCode = DPNERR_USERCANCEL;
			goto Failure;
		}
		pConnectParent->MakeChild( pHandleParent );
		pHandleParent->Unlock();
	}

	//
	//	We will need a parent op for the CONNECTs to help with clean up when the initial CONNECT stage is done
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pAsyncOp)) != DPN_OK)
	{
		DPFERR("Could not create CONNECT parent");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pAsyncOp->SetOpType( ASYNC_OP_CONNECT );
	pAsyncOp->MakeParent();
	pAsyncOp->SetResult( DPNERR_NOCONNECTION );
	pAsyncOp->SetCompletion( DNCompleteConnectToHost );
	pAsyncOp->SetOpFlags( dwConnectFlags );

	pConnectParent->Lock();
	if (pConnectParent->IsCancelled())
	{
		pConnectParent->Unlock();
		pAsyncOp->SetResult( DPNERR_USERCANCEL );
		hResultCode = DPNERR_USERCANCEL;
		goto Failure;
	}
	pAsyncOp->MakeChild( pConnectParent );
	pConnectParent->Unlock();

	//
	//	Save CONNECT data (if supplied)
	//
	if (pvUserConnectData && dwUserConnectDataSize)
	{
		if ((pvConnectData = DNMalloc(dwUserConnectDataSize)) == NULL)
		{
			DPFERR("Could not allocate CONNECT data buffer");
			DNASSERT(FALSE);
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		memcpy(pvConnectData,pvUserConnectData,dwUserConnectDataSize);
	}

	//
	//	Update DirectNet object with relevant data
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pConnectParent->AddRef();
	pdnObject->pConnectParent = pConnectParent;
	if (pvConnectData)
	{
		pdnObject->pvConnectData = pvConnectData;
		pdnObject->dwConnectDataSize = dwUserConnectDataSize;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	If there is no adapter specified in the device address,
	//	we will attempt to CONNECT on each individual adapter if the SP supports it
	//
	fEnumAdapters = FALSE;
	if ((hResultCode = pIDevice->lpVtbl->GetDevice( pIDevice, &guidAdapter )) != DPN_OK)
	{
		DPFX(DPFPREP,1,"Could not determine adapter");
		DisplayDNError(1,hResultCode);

		if (dnSPCaps.dwFlags & DPNSPCAPS_SUPPORTSALLADAPTERS)
		{
			DPFX(DPFPREP, 3,"SP supports ENUMing on all adapters");
			fEnumAdapters = TRUE;
		}
	}

	if(fEnumAdapters)
	{
		DWORD	dwNumAdapters;

		if ((hResultCode = DNEnumAdapterGuids(	pdnObject,
												&guidSP,
												sizeof(DN_CONNECT_OP_DATA),
												reinterpret_cast<void**>(&pConnectOpData),
												&dwNumAdapters)) != DPN_OK)
		{
			DPFERR("Could not enum adapters for this SP");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
		if (dwNumAdapters == 0)
		{
			DPFERR("No valid device adapters could be found");
			hResultCode = DPNERR_INVALIDDEVICEADDRESS;
			goto Failure;
		}

		pConnectOpData->dwNumAdapters = dwNumAdapters;
		pConnectOpData->dwCurrentAdapter = 0;

		if (dwNumAdapters > 1)
		{
			dwMultiplexFlag |= DN_CONNECTFLAGS_ADDITIONALMULTIPLEXADAPTERS;
		}

		//
		//	Choose first adapter for initial LISTEN call
		//
		if ((hResultCode = pIDevice->lpVtbl->SetDevice(pIDevice,reinterpret_cast<GUID*>(pConnectOpData + 1))) != DPN_OK)
		{
			DPFERR("Could not set device adapter");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
		pConnectOpData->dwCurrentAdapter++;
	}
	else
	{
		if ((pConnectOpData = static_cast<DN_CONNECT_OP_DATA*>(MemoryBlockAlloc(pdnObject,sizeof(DN_CONNECT_OP_DATA)))) == NULL)
		{
			DPFERR("Could not allocate CONNECT op data block");
			hResultCode = DPNERR_OUTOFMEMORY;
			DNASSERT(FALSE);
			goto Failure;
		}
		pConnectOpData->dwNumAdapters = 0;
		pConnectOpData->dwCurrentAdapter = 0;
	}
	pAsyncOp->SetOpData( pConnectOpData );
	pAsyncOp->SetSP( pSP );	// Set this for DNPerformNextConnect()

	//
	//	Save SP for future connects
	//
	pSP->AddRef();
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->pConnectSP)
	{
		pdnObject->pConnectSP->Release();
		pdnObject->pConnectSP = NULL;
	}
	pdnObject->pConnectSP = pSP;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	pdnObject->pConnectAddress = pIHost;
	pdnObject->pConnectAddress->lpVtbl->AddRef(pdnObject->pConnectAddress);

	//
	//	CONNECT !
	//
	hResultCode = DNPerformConnect(	pdnObject,
									NULL,
									pIDevice,
									pIHost,
									pSP,
									pAsyncOp->GetOpFlags() | dwMultiplexFlag,
									pAsyncOp);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not connect");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	pAsyncOp->Release();
	pAsyncOp = NULL;
	pConnectParent->Release();
	pConnectParent = NULL;

	pIHost->lpVtbl->Release(pIHost);
	pIHost = NULL;
	pIDevice->lpVtbl->Release(pIDevice);
	pIDevice = NULL;

	pSP->Release();
	pSP = NULL;

	if (dwFlags & DPNCONNECT_SYNC)
	{
		CNameTableEntry	*pHostPlayer;

		pHostPlayer = NULL;

		if ((hResultCode = pSyncEvent->WaitForEvent(INFINITE)) != DPN_OK)
		{
			DPFERR("DNSyncEventWait() terminated bizarrely");
			DNASSERT(FALSE);
		}
		else
		{
			hResultCode = hrOperation;
		}
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;

		//
		//	No longer connecting
		//
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		pdnObject->dwFlags &= (~DN_OBJECT_FLAG_CONNECTING);
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

		//
		//	Clients need to release all sends from the server that were
		//	queued once the CONNECT_COMPLETE gets indicated.
		//	We prepare to do that now.
		//
		if ((hrOperation == DPN_OK) && (pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT))
		{
			if (pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer ) == DPN_OK)
			{
				pHostPlayer->Lock();
				pHostPlayer->MakeAvailable();
				pHostPlayer->NotifyAddRef();
				pHostPlayer->SetInUse();
				pHostPlayer->Unlock();

				//
				//	We are now connected
				//
				DNEnterCriticalSection(&pdnObject->csDirectNetObject);
				pdnObject->dwFlags |= DN_OBJECT_FLAG_CONNECTED;
				DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
			}
			else
			{
				//
				//	If we couldn't get a reference on the server (host player),
				//	then either the server has disconnected, or we are being shut down.
				//	In either case, we should return an error
				//
				DPFX(DPFPREP, 0, "Couldn't get host player reference, failing CONNECT!");
				hrOperation = DPNERR_NOCONNECTION;
				hResultCode = hrOperation;
				if (pReply)
				{
					pReply->Release();
					pReply = NULL;
				}
			}
		}
		else
		{
			//
			//	Connect failed, or this is a peer/server interface
			//
		}


		//
		//	Generate connect completion
		//
		DNUserConnectComplete(pdnObject,0,NULL,hrOperation,pReply);
		if (pReply)
		{
			pReply->Release();
			pReply = NULL;
		}

		//
		//	Cancel ENUMs if the CONNECT succeeded and unload SP's
		//
		if (hrOperation == DPN_OK)
		{
			DNCancelActiveCommands(pdnObject,DN_CANCEL_FLAG_ENUM_QUERY,TRUE,DPNERR_CONNECTING);

			DN_SPReleaseAll(pdnObject);

		
			//
			//	Actually release queued messages if necessary
			//
			if (pHostPlayer != NULL)
			{
				pHostPlayer->PerformQueuedOperations();

				pHostPlayer->Release();
				pHostPlayer = NULL;
			}
		}

		DNASSERT( pHostPlayer == NULL );
	}
	else
	{
		pHandleParent->SetCompletion( DNCompleteUserConnect );
		if (phAsyncHandle)
		{
			*phAsyncHandle = pHandleParent->GetHandle();
		}
		pHandleParent->Release();
		pHandleParent = NULL;

		hResultCode = DPNERR_PENDING;
	}

Exit:
	DNASSERT( pSP == NULL );

	DNASSERT(hResultCode != DPNERR_INVALIDENDPOINT);

	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pSP)
	{
		pSP->Release();
		pSP = NULL;
	}
	if (pHandleParent)
	{
		pHandleParent->Release();
		pHandleParent = NULL;
	}
	if (pConnectParent)
	{
		if (pConnectParent->GetHandle())
		{
			pdnObject->HandleTable.Destroy(pConnectParent->GetHandle());
		}
		pConnectParent->Release();
		pConnectParent = NULL;
	}
	if (pAsyncOp)
	{
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	if (pIHost)
	{
		pIHost->lpVtbl->Release(pIHost);
		pIHost = NULL;
	}
	if (pIDevice)
	{
		pIDevice->lpVtbl->Release(pIDevice);
		pIDevice = NULL;
	}
	if (pIAdapter)
	{
		pIAdapter->lpVtbl->Release(pIAdapter);
		pIAdapter = NULL;
	}
	if (pSyncEvent)
	{
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}
	if (pvAdapterBuffer)
	{
		DNFree(pvAdapterBuffer);
		pvAdapterBuffer = NULL;
	}
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->pIDP8AEnum)
	{
		pdnObject->pIDP8AEnum->lpVtbl->Release(pdnObject->pIDP8AEnum);
		pdnObject->pIDP8AEnum = NULL;
	}
	if (pdnObject->pIDP8ADevice)
	{
		pdnObject->pIDP8ADevice->lpVtbl->Release(pdnObject->pIDP8ADevice);
		pdnObject->pIDP8ADevice = NULL;
	}
	if (pdnObject->pvConnectData)
	{
		DNFree(pdnObject->pvConnectData);
		pdnObject->pvConnectData = NULL;
		pdnObject->dwConnectDataSize = 0;
	}
	if( pdnObject->pConnectAddress )
	{
		pdnObject->pConnectAddress->lpVtbl->Release( pdnObject->pConnectAddress );
		pdnObject->pConnectAddress = NULL;
	}
	if (pdnObject->pConnectSP)
	{
		pdnObject->pConnectSP->Release();
		pdnObject->pConnectSP = NULL;
	}
	pdnObject->dwFlags &= (~DN_OBJECT_FLAG_CONNECTING);
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	goto Exit;
}


//	DN_GetSendQueueInfo
//
//	Get info about the user send queue.
//	This will find the CConnection for a given player and extract the required queue infor from it.

#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetSendQueueInfo"

STDMETHODIMP DN_GetSendQueueInfo(PVOID pInterface,
								 const DPNID dpnid,
								 DWORD *const pdwNumMsgs,
								 DWORD *const pdwNumBytes,
								 const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	DWORD				dwQueueFlags;
	DWORD				dwNumMsgs;
	DWORD				dwNumBytes;
	CNameTableEntry     *pNTEntry;
	CConnection			*pConnection;
	HRESULT				hResultCode;

	DNASSERT(pInterface != NULL);

	DPFX(DPFPREP, 2,"Parameters : pInterface [0x%p], dpnid [0x%lx], pdwNumMsgs [0x%p], pdwNumBytes [0x%p], dwFlags [0x%lx]",
		pInterface,dpnid,pdwNumMsgs,pdwNumBytes,dwFlags);

	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    	DNASSERT(pdnObject != NULL);

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
    	    HRESULT hrResult;
    	
    	    if( FAILED( hrResult = DN_ValidateGetSendQueueInfo( pInterface, pdwNumMsgs, pdwNumBytes, dwFlags ) ) )
    	    {
    	        DPFERR( "Error validating params" );
    	        DPF_RETURN( hrResult );
    	    }
    	}

    	// Check to ensure message handler registered
    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    	{
    		DPFERR( "Object is not initialized" );
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    		DPFERR( "Object is already connecting" );
    		DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED ) )
    	{
    	    DPFERR("Object is not connected" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}    	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}

	pNTEntry = NULL;
	pConnection = NULL;

	//
    //	Validate specified player ID and get CConnection
	//
	if((hResultCode = pdnObject->NameTable.FindEntry( dpnid, &pNTEntry )) != DPN_OK)
	{
		DPFX(DPFPREP, 0,"Could not find Player ID [0x%lx] in NameTable", dpnid );
		if ((hResultCode = pdnObject->NameTable.FindDeletedEntry(dpnid,&pNTEntry)) != DPN_OK)
		{
			DPFERR("Could not find entry in deleted list either");
			hResultCode = DPNERR_INVALIDPLAYER;
			goto Failure;
		}
		pNTEntry->Release();
		pNTEntry = NULL;
		hResultCode = DPNERR_CONNECTIONLOST;
		goto Failure;
	}
	if (pNTEntry->IsLocal() || pNTEntry->IsGroup())
	{
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}
	if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		hResultCode = DPNERR_CONNECTIONLOST;
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	Determine required queues
	//
	dwQueueFlags = dwFlags & (DPNGETSENDQUEUEINFO_PRIORITY_HIGH | DPNGETSENDQUEUEINFO_PRIORITY_NORMAL | DPNGETSENDQUEUEINFO_PRIORITY_LOW);
	if (dwQueueFlags == 0)
	{
		dwQueueFlags = (DPNGETSENDQUEUEINFO_PRIORITY_HIGH | DPNGETSENDQUEUEINFO_PRIORITY_NORMAL | DPNGETSENDQUEUEINFO_PRIORITY_LOW);
	}

	//
	//	Extract required info
	//
	dwNumMsgs = 0;
	dwNumBytes = 0;
	pConnection->Lock();
	if (dwQueueFlags & DPNGETSENDQUEUEINFO_PRIORITY_HIGH)
	{
		dwNumMsgs += pConnection->GetHighQueueNum();
		dwNumBytes += pConnection->GetHighQueueBytes();
	}
	if (dwQueueFlags & DPNGETSENDQUEUEINFO_PRIORITY_NORMAL)
	{
		dwNumMsgs += pConnection->GetNormalQueueNum();
		dwNumBytes += pConnection->GetNormalQueueBytes();
	}
	if (dwQueueFlags & DPNGETSENDQUEUEINFO_PRIORITY_LOW)
	{
		dwNumMsgs += pConnection->GetLowQueueNum();
		dwNumBytes += pConnection->GetLowQueueBytes();
	}
	pConnection->Unlock();
	pConnection->Release();
	pConnection = NULL;

	if (pdwNumMsgs)
	{
		*pdwNumMsgs = dwNumMsgs;
		DPFX(DPFPREP, 3,"Setting: *pdwNumMsgs [%ld]",dwNumMsgs);
	}
	if (pdwNumBytes)
	{
		*pdwNumBytes = dwNumBytes;
		DPFX(DPFPREP, 3,"Setting: *pdwNumBytes [%ld]",dwNumBytes);
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetApplicationDesc"

STDMETHODIMP DN_GetApplicationDesc(PVOID pInterface,
								   DPN_APPLICATION_DESC *const pAppDescBuffer,
								   DWORD *const pcbDataSize,
								   const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	HRESULT				hResultCode;
	CPackedBuffer		packedBuffer;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], pAppDescBuffer [0x%p], pcbDataSize [0x%p], dwFlags [0x%lx]",
			pInterface,pAppDescBuffer,pcbDataSize,dwFlags);

	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    	DNASSERT(pdnObject != NULL);

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
    	    if( FAILED( hResultCode = DN_ValidateGetApplicationDesc( pInterface, pAppDescBuffer, pcbDataSize, dwFlags ) ) )
    	    {
    	        DPFERR( "Failed validation getappdesc" );
    	        DPF_RETURN( hResultCode );
    	    }
        }

    	// Check to ensure message handler registered
    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    	{
    		DPFERR( "Object is not initialized" );
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}	

    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    	{
    	    DPFERR("Object is not connected or hosting" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}    	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}

	//
	//	Initialize PackedBuffer
	//
	packedBuffer.Initialize(static_cast<void*>(pAppDescBuffer),*pcbDataSize);

	//
	//	Try to pack in the application description.
	//	If it won't fit, the required size will be in the PackedBuffer.
	//
	hResultCode = pdnObject->ApplicationDesc.Pack(&packedBuffer,DN_APPDESCINFO_FLAG_SESSIONNAME|DN_APPDESCINFO_FLAG_PASSWORD|
			DN_APPDESCINFO_FLAG_RESERVEDDATA|DN_APPDESCINFO_FLAG_APPRESERVEDDATA);

	//
	//	Ensure we know what's going on
	//
	if ((hResultCode != DPN_OK) && (hResultCode != DPNERR_BUFFERTOOSMALL))
	{
		DPFERR("Unknown error occurred packing application description");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_GENERIC;
		goto Failure;
	}

	//
	//	Size of buffer
	//
	*pcbDataSize = packedBuffer.GetSizeRequired();

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_SetApplicationDesc"

STDMETHODIMP DN_SetApplicationDesc(PVOID pInterface,
								   const DPN_APPLICATION_DESC *const pdnApplicationDesc,
								   const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	HRESULT				hResultCode = DPN_OK;
	CRefCountBuffer		*pRefCountBuffer;
	CPackedBuffer		packedBuffer;
	CWorkerJob			*pWorkerJob;
	DWORD				dwAppDescInfoSize;
	DWORD				dwEnumFrameSize;
	CNameTableEntry     *pNTEntry;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], pdnApplicationDesc [0x%p], dwFlags [0x%lx]",
			pInterface,pdnApplicationDesc,dwFlags);

	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    	DNASSERT(pdnObject != NULL);

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
    	    if( FAILED( hResultCode = DN_ValidateSetApplicationDesc( pInterface, pdnApplicationDesc, dwFlags ) ) )
    	    {
    	        DPFERR( "Error validating setappdesc params" );
    	        DPF_RETURN( hResultCode );
    	    }
    	}

    	// Check to ensure message handler registered
    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    	{
    		DPFERR( "Object is not initialized" );
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}	

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR( "Object has not yet completed connecting / hosting" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if ( !DN_CHECK_LOCALHOST( pdnObject ) )
    	{
    	    DPFERR("Object is not connected or hosting" );
    	    DPF_RETURN(DPNERR_NOTHOST);
    	}
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}

	pNTEntry = NULL;
	pRefCountBuffer = NULL;
	pWorkerJob = NULL;

	//
	//	This can only be called by the host
	//
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pNTEntry )) != DPN_OK)
	{
		DPFERR("Could not get local player");
		hResultCode = DPNERR_NOTHOST;
		goto Failure;
	}
	if (!pNTEntry->IsHost())
	{
		DPFERR("Not Host player");
		hResultCode = DPNERR_NOTHOST;
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	Use cached max enum frame size
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	dwEnumFrameSize = pdnObject->dwMaxFrameSize;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	
	DNASSERT( dwEnumFrameSize >= (sizeof(DN_ENUM_RESPONSE_PAYLOAD) + sizeof(DPN_APPLICATION_DESC_INFO)) );
	if (dwEnumFrameSize < (sizeof(DN_ENUM_RESPONSE_PAYLOAD) + sizeof(DPN_APPLICATION_DESC_INFO) + pdnApplicationDesc->dwApplicationReservedDataSize))
	{
		DPFERR("Not enough room for the application reserved data");
		hResultCode = DPNERR_DATATOOLARGE;
		goto Failure;
	}

	//
	//	Update Host player's application desc first
	//
	pdnObject->ApplicationDesc.Lock();
	if (pdnApplicationDesc->dwMaxPlayers > 0)
	{
		if (pdnApplicationDesc->dwMaxPlayers < pdnObject->ApplicationDesc.GetCurrentPlayers())
		{
			DPFERR("Cannot set max players to less than the current number of players");
			pdnObject->ApplicationDesc.Unlock();
			hResultCode = DPNERR_SESSIONFULL;
			goto Failure;
		}
	}
	hResultCode = pdnObject->ApplicationDesc.Update(pdnApplicationDesc,DN_APPDESCINFO_FLAG_SESSIONNAME|
			DN_APPDESCINFO_FLAG_PASSWORD|DN_APPDESCINFO_FLAG_RESERVEDDATA|DN_APPDESCINFO_FLAG_APPRESERVEDDATA);
	pdnObject->ApplicationDesc.Unlock();
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not update Application Desciption");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Inform host application
	//
	hResultCode = DNUserUpdateAppDesc(pdnObject);

	//
	//	Get Application Description Info size
	//
	packedBuffer.Initialize(NULL,0);
	hResultCode = pdnObject->ApplicationDesc.PackInfo(&packedBuffer,DN_APPDESCINFO_FLAG_SESSIONNAME|DN_APPDESCINFO_FLAG_PASSWORD|
			DN_APPDESCINFO_FLAG_RESERVEDDATA|DN_APPDESCINFO_FLAG_APPRESERVEDDATA);
	DNASSERT(hResultCode == DPNERR_BUFFERTOOSMALL);
	dwAppDescInfoSize = packedBuffer.GetSizeRequired();

	//
	//	Create packed buffer to send to other players
	//
	if ((hResultCode = RefCountBufferNew(pdnObject,dwAppDescInfoSize,&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not create CountBuffer");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	packedBuffer.Initialize(pRefCountBuffer->GetBufferAddress(),pRefCountBuffer->GetBufferSize());
	hResultCode = pdnObject->ApplicationDesc.PackInfo(&packedBuffer,DN_APPDESCINFO_FLAG_SESSIONNAME|DN_APPDESCINFO_FLAG_PASSWORD|
			DN_APPDESCINFO_FLAG_RESERVEDDATA|DN_APPDESCINFO_FLAG_APPRESERVEDDATA);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not pack Application Description into EnumBuffer");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Notify other players
	//
	DPFX(DPFPREP, 5,"Adding UpdateApplicationDesc to Job Queue");
	if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) == DPN_OK)
	{
		pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION );
		pWorkerJob->SetSendNameTableOperationMsgId( DN_MSG_INTERNAL_UPDATE_APPLICATION_DESC );
		pWorkerJob->SetSendNameTableOperationVersion( 0 );
		pWorkerJob->SetSendNameTableOperationDPNIDExclude( 0 );
		pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

		DNQueueWorkerJob(pdnObject,pWorkerJob);
		pWorkerJob = NULL;
	}
	else
	{
		DPFERR("Could not create worker job - ignore and continue");
		DisplayDNError(0,hResultCode);
	}

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNTerminateSession"

HRESULT DNTerminateSession(DIRECTNETOBJECT *const pdnObject,
						   const HRESULT hrReason)
{
	HRESULT		hResultCode;
	BOOL		fWasConnected;
	BOOL		fWasRegistered;
	CAsyncOp	*pAsyncOp;

	DPFX(DPFPREP, 4,"Parameters: hrReason [0x%lx]",hrReason);

	DNASSERT(pdnObject != NULL);
	DNASSERT( (hrReason == DPN_OK) || (hrReason == DPNERR_HOSTTERMINATEDSESSION) || (hrReason == DPNERR_CONNECTIONLOST));

	pAsyncOp = NULL;

	//
	//	Shut down listen(s)
	//
	DPFX(DPFPREP, 3,"Checking LISTENs");
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pAsyncOp = pdnObject->pListenParent;
	pdnObject->pListenParent = NULL;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	if (pAsyncOp)
	{
		DPFX(DPFPREP, 3,"Canceling LISTENs");
		hResultCode = DNCancelChildren(pdnObject,pAsyncOp);
		DPFX(DPFPREP, 3,"Canceling LISTENs returned [0x%lx]",hResultCode);

		pAsyncOp->Release();
		pAsyncOp = NULL;
	}

	//
	//	Unregister from DPNSVR (if required)
	//
	fWasRegistered = FALSE;
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_DPNSVR_REGISTERED)
	{
		pdnObject->dwFlags &= (~DN_OBJECT_FLAG_DPNSVR_REGISTERED);
		fWasRegistered = TRUE;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	if (fWasRegistered)
	{
		pdnObject->ApplicationDesc.UnregisterWithDPNSVR();
	}

	//
	//	Flag DirectNetObject as disconnecting.  This flag will be cleared when Close() finishes.
	//
	fWasConnected = FALSE;
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED)
	{
		fWasConnected = TRUE;
		pdnObject->dwFlags &= (~DN_OBJECT_FLAG_CONNECTED);
	}
#pragma BUGBUG( minara,"How usefull is this DN_OBJECT_FLAG_DISCONNECTING flag ?" )
	pdnObject->dwFlags |= DN_OBJECT_FLAG_DISCONNECTING;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Update Lobby status
	//
	if (fWasConnected)
	{
		DNUpdateLobbyStatus(pdnObject,DPLSESSION_DISCONNECTED);
	}

	//
	//	Notify Voice
	//
	Voice_Notify( pdnObject, DVEVENT_STOPSESSION, 0, 0 );

	//
	//	Remove host migration target
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->pNewHost)
	{
		pdnObject->pNewHost->Release();
		pdnObject->pNewHost = NULL;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Delete all players from NameTable.  This will involve
	//	emptying the table and removing short-cut player pointers
	//
	DPFX(DPFPREP, 5,"Removing players from NameTable");
	pdnObject->NameTable.EmptyTable(hrReason);

	//
	//	Clean up NameTable operation list
	//
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
	{
		DPFX(DPFPREP, 5,"Cleaning up NameTable operation list");
		DNNTRemoveOperations(pdnObject,0,TRUE);
	}

	DNEnterCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Clean up CONNECT parent
	//
	if (pdnObject->pConnectParent)
	{
		pAsyncOp = pdnObject->pConnectParent;
		pdnObject->pConnectParent = NULL;
	}

	//
	//	Clean up CONNECT info and address
	//
	if (pdnObject->pvConnectData)
	{
		DNFree(pdnObject->pvConnectData);
		pdnObject->pvConnectData = NULL;
		pdnObject->dwConnectDataSize = 0;
	}
	if (pdnObject->pConnectAddress)
	{
		pdnObject->pConnectAddress->lpVtbl->Release(pdnObject->pConnectAddress);
		pdnObject->pConnectAddress = NULL;
	}
	if (pdnObject->pIDP8ADevice)
	{
		pdnObject->pIDP8ADevice->lpVtbl->Release(pdnObject->pIDP8ADevice);
		pdnObject->pIDP8ADevice = NULL;
	}
	if (pdnObject->pIDP8AEnum)
	{
		pdnObject->pIDP8AEnum->lpVtbl->Release(pdnObject->pIDP8AEnum);
		pdnObject->pIDP8AEnum = NULL;
	}

	//
	//	Clear the DISCONNECTING and HOST_CONNECTED flag
	//	and clear connection info
	//
	pdnObject->dwFlags &= ~(DN_OBJECT_FLAG_DISCONNECTING | DN_OBJECT_FLAG_HOST_CONNECTED);

	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	if (pAsyncOp)
	{
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}

	hResultCode = DPN_OK;

	DNASSERT(pAsyncOp == NULL);

	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_SendTo"

STDMETHODIMP DN_SendTo( PVOID pv,
						const DPNID dpnid,
						const DPN_BUFFER_DESC *const prgBufferDesc,
						const DWORD cBufferDesc,
						const DWORD dwTimeOut,
						void *const pvAsyncContext,
						DPNHANDLE *const phAsyncHandle,
						const DWORD dwFlags)
{
	HRESULT				hResultCode;
	HRESULT				hrSend;
	CNameTableEntry		*pNTEntry;
	CNameTableEntry		*pLocalPlayer;
	DIRECTNETOBJECT		*pdnObject;
	DWORD				dwSendFlags;
	CSyncEvent			*pSyncEvent;
	const DPN_BUFFER_DESC		*pActualBufferDesc;
	CRefCountBuffer		*pRefCountBuffer;
	DPNHANDLE			handle;
	CAsyncOp			*pAsyncOp;
	CAsyncOp			*pParent;
	CAsyncOp			*pHandleParent;
	CConnection			*pConnection;

	DPFX(DPFPREP, 2,"Parameters: dpnid [0x%lx], prgBufferDesc [0x%p], dwTimeOut [%ld], pvAsyncContext [0x%p], phAsyncHandle [0x%p], dwFlags [0x%lx]",
			dpnid,prgBufferDesc,dwTimeOut,pvAsyncContext,phAsyncHandle,dwFlags);

	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pv));
    	DNASSERT(pdnObject != NULL);

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
        	if( FAILED( hResultCode = DN_ValidateSendParams( pv , prgBufferDesc, cBufferDesc, dwTimeOut, pvAsyncContext, phAsyncHandle, dwFlags ) ) )
        	{
        	    DPFX(DPFPREP,  0, "Error validating common send params hr=[0x%lx]", hResultCode );
        	    DPF_RETURN( hResultCode );
        	}
    	}

        // Check to ensure message handler registered
    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    	{
    		DPFERR( "Object is not initialized" );
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}	

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR( "Object has not yet completed connecting / hosting" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    	{
    	    DPFERR("Object is not connected or hosting" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}

	pRefCountBuffer = NULL;
	pSyncEvent = NULL;
	pNTEntry = NULL;
	pLocalPlayer = NULL;
	pAsyncOp = NULL;
	pParent = NULL;
	pHandleParent = NULL;
	pConnection = NULL;
	handle = 0;

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT)
	{
		if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pNTEntry )) != DPN_OK)
		{
			DPFERR("Could not find Host player");
			DisplayDNError(0,hResultCode);
			hResultCode = DPNERR_INVALIDPLAYER;
			goto Failure;
		}
	}
	else
	{
		if (dpnid == 0)
		{
			if ((hResultCode = pdnObject->NameTable.GetAllPlayersGroupRef( &pNTEntry )) != DPN_OK)
			{
				DPFERR("Unable to get all players group");
				DisplayDNError(0,hResultCode);
				hResultCode = DPNERR_INVALIDGROUP;
				goto Failure;
			}
		}
		else
		{
			if (dwFlags & DPNSEND_NOLOOPBACK)
			{
				if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
				{
					DPFERR("Could not get local player reference");
					DisplayDNError(0,hResultCode);
					hResultCode = DPNERR_GENERIC;
					goto Failure;
				}
				if (dpnid == pLocalPlayer->GetDPNID())
				{
					hResultCode = DPNERR_INVALIDPARAM;
					goto Failure;
				}
				pLocalPlayer->Release();
				pLocalPlayer = NULL;
			}

			if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
			{
				DPFERR("Unable to find target player or group");
				DisplayDNError(0,hResultCode);
				//
				//	Try deleted list
				//
				if ((hResultCode = pdnObject->NameTable.FindDeletedEntry(dpnid,&pNTEntry)) != DPN_OK)
				{
					DPFERR("Could not find target in deleted list either");
					hResultCode = DPNERR_INVALIDPLAYER;
					goto Failure;
				}
				pNTEntry->Release();
				pNTEntry = NULL;

				//
				//	Target was found, but is not reachable
				//
				hResultCode = DPNERR_CONNECTIONLOST;
				goto Failure;
			}
		}
	}

	if (!(dwFlags & (DPNSEND_NOCOPY | DPNSEND_COMPLETEONPROCESS)))
	{
		if ((hResultCode = RefCountBufferNew(pdnObject,prgBufferDesc->dwBufferSize,&pRefCountBuffer)) != DPN_OK)
		{
			DPFERR("Could not allocate buffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pActualBufferDesc = pRefCountBuffer->BufferDescAddress();
		memcpy(pActualBufferDesc->pBufferData,prgBufferDesc->pBufferData,prgBufferDesc->dwBufferSize);
	}
	else
	{
		pRefCountBuffer = NULL;
		pActualBufferDesc = prgBufferDesc;
	}

	dwSendFlags = 0;
	if (dwFlags & DPNSEND_GUARANTEED)
	{
		dwSendFlags |= DN_SENDFLAGS_RELIABLE;
	}
	if (dwFlags & DPNSEND_NONSEQUENTIAL)
	{
		dwSendFlags |= DN_SENDFLAGS_NON_SEQUENTIAL;
	}
	if (dwFlags & DPNSEND_PRIORITY_HIGH)
	{
		dwSendFlags |= DN_SENDFLAGS_HIGH_PRIORITY;
	}
	if (dwFlags & DPNSEND_PRIORITY_LOW)
	{
		dwSendFlags |= DN_SENDFLAGS_LOW_PRIORITY;
	}
	if (dwFlags & DPNSEND_SYNC)
	{
		//
		//	Create SyncEvent for SYNC operation
		//
		if ((hResultCode = SyncEventNew(pdnObject,&pSyncEvent)) != DPN_OK)
		{
			DPFERR("Could not create sync event for group sends");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
	}
	else
	{
		//
		//	Create Handle for ASYNC operation
		//
		if ((hResultCode = DNCreateUserHandle(pdnObject,&pHandleParent)) != DPN_OK)
		{
			DPFERR("Could not create AsyncOp");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}

		pHandleParent->SetContext( pvAsyncContext );
		pHandleParent->SetStartTime( GETTIMESTAMP() );
		handle = pHandleParent->GetHandle();
	}

	if (pNTEntry->IsGroup())
	{
		BOOL	fRequest;
		BOOL	fNoLoopBack;

		//
		//	Perform group sends and get parent AsyncOp
		//
		if (dwFlags & DPNSEND_COMPLETEONPROCESS)
		{
			fRequest = TRUE;
		}
		else
		{
			fRequest = FALSE;
		}
		if (dwFlags & DPNSEND_NOLOOPBACK)
		{
			fNoLoopBack = TRUE;
		}
		else
		{
			fNoLoopBack = FALSE;
		}
		hResultCode = DNSendGroupMessage(	pdnObject,
											pNTEntry,
											DN_MSG_USER_SEND,
											pActualBufferDesc,
											pRefCountBuffer,
											dwTimeOut,
											dwSendFlags,
											fNoLoopBack,
											fRequest,
											pHandleParent,
											&pParent);

		if (hResultCode != DPN_OK)
		{
			DPFERR("SEND failed");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}

		//
		//	Synchronous ?
		//
		if (dwFlags & DPNSEND_SYNC)
		{
			pParent->SetSyncEvent( pSyncEvent );
			pParent->SetResultPointer( &hrSend );
			hrSend = DPNERR_GENERIC;
		}
		else
		{
			//
			//	Set async completion (if required).  We will only need this if the SEND succeeded.
			//
			if (!(dwFlags & DPNSEND_NOCOMPLETE))
			{
				pHandleParent->SetCompletion( DNCompleteSendHandle );
			}
			pHandleParent->Release();
			pHandleParent = NULL;
		}

		pParent->Release();
		pParent = NULL;
	}
	else
	{
		if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) != DPN_OK)
		{
			DPFERR("Could not get Connection reference");
			DisplayDNError(0,hResultCode);
			hResultCode = DPNERR_CONNECTIONLOST;	// re-map this
			goto Failure;
		}

		if (dwFlags & DPNSEND_COMPLETEONPROCESS)
		{
			hResultCode = DNPerformRequest(	pdnObject,
											DN_MSG_INTERNAL_REQ_PROCESS_COMPLETION,
											pActualBufferDesc,
											pConnection,
											pHandleParent,
											&pAsyncOp);
		}
		else
		{
			hResultCode = DNSendMessage(pdnObject,
										pConnection,
										DN_MSG_USER_SEND,
										dpnid,
										pActualBufferDesc,
										pRefCountBuffer,
										dwTimeOut,
										dwSendFlags,
										pHandleParent,
										&pAsyncOp);
		}

		pConnection->Release();
		pConnection = NULL;

		if (hResultCode != DPNERR_PENDING)
		{
			DPFERR("SEND failed");
			DisplayDNError(0,hResultCode);
			if (hResultCode == DPNERR_INVALIDENDPOINT)
			{
				hResultCode = DPNERR_CONNECTIONLOST;
			}
			goto Failure;
		}

		//
		//	Synchronous ?
		//
		if (dwFlags & DPNSEND_SYNC)
		{
			pAsyncOp->SetSyncEvent( pSyncEvent );
			pAsyncOp->SetResultPointer( &hrSend );
			hrSend = DPNERR_GENERIC;
#pragma TODO( minara, "We can be smarter about passing back errors - at least better than this !" )
		}
		else
		{
			//
			//	Set async completion (if required).  We will only need this if the SEND succeeded.
			//
			if (!(dwFlags & DPNSEND_NOCOMPLETE))
			{
				pHandleParent->SetCompletion( DNCompleteSendHandle );
			}
			pHandleParent->Release();
			pHandleParent = NULL;
		}

		pAsyncOp->Release();
		pAsyncOp = NULL;
	}

	pNTEntry->Release();
	pNTEntry = NULL;

	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}

	if (dwFlags & DPNSEND_SYNC)
	{
		pSyncEvent->WaitForEvent(INFINITE);
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
		hResultCode = hrSend;
	}
	else
	{
		if (phAsyncHandle != NULL)
		{
			*phAsyncHandle = handle;
		}
		hResultCode = DPNERR_PENDING;
	}

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	DNASSERT(hResultCode != DPNERR_INVALIDENDPOINT);
	return(hResultCode);

Failure:
	if (pHandleParent)
	{
		pHandleParent->Release();
		pHandleParent = NULL;
	}
	if (pAsyncOp)
	{
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	if (pParent)
	{
		pParent->Release();
		pParent = NULL;
	}
	if (handle != 0)
	{
		pdnObject->HandleTable.Destroy( handle );
		handle = 0;
	}
	if (pSyncEvent)
	{
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	goto Exit;
}


//	DN_Host

#undef DPF_MODNAME
#define DPF_MODNAME "DN_Host"

STDMETHODIMP DN_Host( PVOID pInterface,
					  const DPN_APPLICATION_DESC *const pdnAppDesc,
					  IDirectPlay8Address **const prgpDeviceInfo,
					  const DWORD cDeviceInfo,
					  const DPN_SECURITY_DESC *const pdnSecurity,
					  const DPN_SECURITY_CREDENTIALS *const pdnCredentials,
					  void *const pvPlayerContext,
					  const DWORD dwFlags)
{
	CNameTableEntry		*pHostPlayer;
	CNameTableEntry		*pAllPlayersGroup;
	DWORD				dwCurrentDevice;
	HRESULT				hResultCode;
	DIRECTNETOBJECT		*pdnObject;
	LPWSTR				lpwszPassword = NULL;
	PVOID				pvApplicationReservedData = NULL;
	IDirectPlay8Address	**prgIDevice;
	DWORD				dwListensRunning;
	CConnection			*pConnection;
	CAsyncOp			*pListenParent;
	DWORD				dwEnumFrameSize;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], pdnAppDesc [0x%p], prgpDeviceInfo [0x%p], cDeviceInfo [%ld], pdnSecurity [0x%p], pdnCredentials [0x%p], dwFlags [0x%lx]",
		pInterface,pdnAppDesc,prgpDeviceInfo,cDeviceInfo,pdnSecurity,pdnCredentials,dwFlags);

	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    	DNASSERT(pdnObject != NULL);

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
    	    if( FAILED( hResultCode = DN_ValidateHost( pInterface, pdnAppDesc, prgpDeviceInfo, cDeviceInfo,
                                                          pdnSecurity, pdnCredentials, pvPlayerContext,
                                                          dwFlags ) ) )
    	    {
    	        DPFERR( "Error validating host params" );
    	        DPF_RETURN( hResultCode );
    	    }
    	}

    	// Check to ensure message handler registered
    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    	{
    		DPFERR( "Object is not initialized" );
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	// Check to ensure not already connected
    	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED)
    	{
    	    if( DN_CHECK_LOCALHOST( pdnObject ) )
    	    {
    	        DPFERR("Object is already hosting" );
    	    	DPF_RETURN(DPNERR_HOSTING);	
    	    }
    	    else
    	    {
        	    DPFERR("Object is already connected" );
                DPF_RETURN(DPNERR_ALREADYCONNECTED);
    	    }
    	}

    	if((pdnObject->dwFlags & DN_OBJECT_FLAG_PEER) &&
     	   (pdnAppDesc->dwFlags & DPNSESSION_CLIENT_SERVER) )
        {
            DPFERR( "You cannot specify the clientserver flag in peer mode" );
            DPF_RETURN(DPNERR_INVALIDPARAM);
    	}

    	if((pdnObject->dwFlags & DN_OBJECT_FLAG_SERVER) &&
    	   !(pdnAppDesc->dwFlags & DPNSESSION_CLIENT_SERVER) )
    	{
    	    DPFERR( "You MUST specify the client/server flag for client/server mode" );
    	    DPF_RETURN(DPNERR_INVALIDPARAM);
    	}
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}

	prgIDevice = NULL;
	pListenParent = NULL;
	pConnection = NULL;
	pHostPlayer = NULL;
	pAllPlayersGroup = NULL;

	//
	//	Flag as CONNECTING to prevent other operations here
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & (DN_OBJECT_FLAG_CONNECTING | DN_OBJECT_FLAG_CONNECTED))
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		hResultCode = DPNERR_ALREADYCONNECTED;
		goto Failure;
	}
	pdnObject->dwFlags |= DN_OBJECT_FLAG_CONNECTING;

	// Adding local host flag
	pdnObject->dwFlags |= DN_OBJECT_FLAG_LOCALHOST;
	
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	
	//
	//	Copy application description to DirectNet object
	//
	pdnObject->ApplicationDesc.Lock();
	hResultCode = pdnObject->ApplicationDesc.Update(pdnAppDesc,DN_APPDESCINFO_FLAG_SESSIONNAME|DN_APPDESCINFO_FLAG_PASSWORD|
			DN_APPDESCINFO_FLAG_RESERVEDDATA|DN_APPDESCINFO_FLAG_APPRESERVEDDATA);
	pdnObject->ApplicationDesc.Unlock();
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not update application description");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	// Create Instance GUID
	//
	if ((hResultCode = pdnObject->ApplicationDesc.CreateNewInstanceGuid()) != DPN_OK)
	{
		DPFERR("Could not create instance GUID - ignore and continue");
		DisplayDNError(0,hResultCode);
	}

	//
	//	Set NameTable DPNID mask
	//
	DPFX(DPFPREP, 5,"DPNID Mask [0x%lx]",pdnObject->ApplicationDesc.GetDPNIDMask());
	pdnObject->NameTable.SetDPNIDMask( pdnObject->ApplicationDesc.GetDPNIDMask() );

	//
	// Create group "ALL PLAYERS"
	//
	if ((hResultCode = NameTableEntryNew(pdnObject,&pAllPlayersGroup)) != DPN_OK)
	{
		DPFERR("Could not create NameTableEntry");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pAllPlayersGroup->MakeGroup();

	// This function takes the lock internally
	pAllPlayersGroup->UpdateEntryInfo(	DN_ALL_PLAYERS_GROUP_NAME,
										DN_ALL_PLAYERS_GROUP_NAME_SIZE,
										NULL,
										0,
										DPNINFO_NAME|DPNINFO_DATA,
										FALSE);

	pdnObject->NameTable.MakeAllPlayersGroup(pAllPlayersGroup);

	//
	// Create local player
	//
	if ((hResultCode = NameTableEntryNew(pdnObject,&pHostPlayer)) != DPN_OK)
	{
		DPFERR("Could not create NameTableEntry");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	// This function takes the lock internally
	pHostPlayer->UpdateEntryInfo(	pdnObject->NameTable.GetDefaultPlayer()->GetName(),
								pdnObject->NameTable.GetDefaultPlayer()->GetNameSize(),
								pdnObject->NameTable.GetDefaultPlayer()->GetData(),
								pdnObject->NameTable.GetDefaultPlayer()->GetDataSize(),
								DPNINFO_NAME|DPNINFO_DATA,
								FALSE);

	pHostPlayer->SetDNETVersion( DN_VERSION_CURRENT );

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
	{
		pHostPlayer->MakePeer();
	}
	else if (pdnObject->dwFlags & DN_OBJECT_FLAG_SERVER)
	{
		pHostPlayer->MakeServer();
	}
	else
	{
		DNASSERT(FALSE);
	}

	pHostPlayer->SetContext(pvPlayerContext);
	pHostPlayer->StartConnecting();

	if ((hResultCode = pdnObject->NameTable.AddEntry(pHostPlayer)) != DPN_OK)
	{
		DPFERR("Could not add NameTableEntry to NameTable");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	// Create Host's connection (NULL end point)
	if ((hResultCode = ConnectionNew(pdnObject,&pConnection)) != DPN_OK)
	{
		DPFERR("Could not create new connection");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pConnection->SetStatus( CONNECTED );
	pConnection->MakeLocal();
	pConnection->SetEndPt(NULL);
	pConnection->SetDPNID(pHostPlayer->GetDPNID());

	pdnObject->NameTable.MakeLocalPlayer(pHostPlayer);
	pdnObject->NameTable.MakeHostPlayer(pHostPlayer);


	//
	//	Make ALL_PLAYERS group available (does not indicate anything to user).
	//
	pAllPlayersGroup->Lock();
	pAllPlayersGroup->MakeAvailable();
	pAllPlayersGroup->Unlock();
	pAllPlayersGroup->Release();
	pAllPlayersGroup = NULL;


	//
	// Don't notify user of CREATE_PLAYER yet in case starting listens fails.
	// This prevents them from having to handle CREATE_PLAYERs even in
	// the failure case.
	//
	
	//
	//	Start listens
	//

#ifdef	DEBUG
	for (dwCurrentDevice = 0 ; dwCurrentDevice < cDeviceInfo ; dwCurrentDevice++)
	{
DPFX(DPFPREP, 5,"Original Device: prgpDeviceInfo[%ld] [0x%p]",dwCurrentDevice,prgpDeviceInfo[dwCurrentDevice]);
	}
#endif

	// Duplicate address interfaces
	if ((prgIDevice = static_cast<IDirectPlay8Address**>(DNMalloc(cDeviceInfo*sizeof(IDirectPlay8Address*)))) == NULL)
	{
		DPFERR("Could not create duplicate address interface array");
		DNASSERT(FALSE);
		goto Failure;
	}
	for (dwCurrentDevice = 0 ; dwCurrentDevice < cDeviceInfo ; dwCurrentDevice++)
	{
		if ((hResultCode = (prgpDeviceInfo[dwCurrentDevice])->lpVtbl->Duplicate(prgpDeviceInfo[dwCurrentDevice],&prgIDevice[dwCurrentDevice])) != DPN_OK)
		{
			DPFERR("Could not duplicate Host address info - skipping it");
			prgIDevice[dwCurrentDevice] = NULL;
			continue;
		}
DPFX(DPFPREP, 5,"Duplicate Device: prgIDevice[%ld] [0x%p]",dwCurrentDevice,prgIDevice[dwCurrentDevice]);
	}

	// Parent Async Op
	if ((hResultCode = AsyncOpNew(pdnObject,&pListenParent)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pListenParent->SetOpType( ASYNC_OP_LISTEN );
	pListenParent->MakeParent();
	pListenParent->SetCompletion( DNCompleteListen );

	// Save query for addressing flag (if necessary)
	if (dwFlags & DPNHOST_OKTOQUERYFORADDRESSING)
	{
		pListenParent->SetOpFlags(DN_LISTENFLAGS_OKTOQUERYFORADDRESSING);
	}

	// Children op's
	dwListensRunning = 0;
	for (dwCurrentDevice = 0 ; dwCurrentDevice < cDeviceInfo ; dwCurrentDevice++)
	{
		if (prgIDevice[dwCurrentDevice] != NULL)
		{
			hResultCode = DNPerformSPListen(pdnObject,prgIDevice[dwCurrentDevice],pListenParent,NULL);
			if (hResultCode == DPN_OK)
			{
				dwListensRunning++;
			}
		}
	}

	// Make sure at least 1 listen started
	if (dwListensRunning == 0)
	{
		DPFERR("Could not start any LISTENs");
		hResultCode = DPNERR_INVALIDDEVICEADDRESS;
		goto Failure;
	}

	// Store parent LISTEN on DirectNet object
	pListenParent->AddRef();
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->pListenParent = pListenParent;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	pListenParent->Release();
	pListenParent = NULL;

	//
	//	Use cached max enum frame size
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	dwEnumFrameSize = pdnObject->dwMaxFrameSize;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	
	DNASSERT( dwEnumFrameSize >= (sizeof(DN_ENUM_RESPONSE_PAYLOAD) + sizeof(DPN_APPLICATION_DESC_INFO)) );
	if (dwEnumFrameSize < (sizeof(DN_ENUM_RESPONSE_PAYLOAD) + sizeof(DPN_APPLICATION_DESC_INFO) + pdnAppDesc->dwApplicationReservedDataSize))
	{
		DPFERR("Not enough room for the application reserved data");
		hResultCode = DPNERR_DATATOOLARGE;
		goto Failure;
	}

	//
	// Now that Listens have been successfully started, indicate the local CREATE_PLAYER.
	//

	//
	//	Update DirectNet object to be connected
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING);
	pdnObject->dwFlags &= ~DN_OBJECT_FLAG_CONNECTING;
	pdnObject->dwFlags |= DN_OBJECT_FLAG_CONNECTED;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Update Lobby status
	//
	DNUpdateLobbyStatus(pdnObject,DPLSESSION_CONNECTED);

	//
	//	One player in game (Local/Host player)
	//
	pdnObject->ApplicationDesc.IncPlayerCount(TRUE);

	//
	//	Populate local player's connection
	//
	pConnection->SetDPNID(pHostPlayer->GetDPNID());
	pdnObject->NameTable.PopulateConnection(pConnection);
	pConnection->Release();
	pConnection = NULL;

	//
	//	Unload SP's
	//
	DN_SPReleaseAll(pdnObject);

	pHostPlayer->Release();
	pHostPlayer = NULL;

	hResultCode = DPN_OK;

Exit:
	//
	//	Clean up copies of device address
	//
	if (prgIDevice)
	{
		for (dwCurrentDevice = 0 ; dwCurrentDevice < cDeviceInfo ; dwCurrentDevice++)
		{
			if (prgIDevice[dwCurrentDevice])
			{
				(prgIDevice[dwCurrentDevice])->lpVtbl->Release(prgIDevice[dwCurrentDevice]);
				prgIDevice[dwCurrentDevice] = NULL;
			}
		}
		DNFree(prgIDevice);
		prgIDevice = NULL;
	}

	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pListenParent)
	{
		pListenParent->Release();
		pListenParent = NULL;
	}
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	if (pAllPlayersGroup)
	{
		pAllPlayersGroup->Release();
		pAllPlayersGroup = NULL;
	}
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pListenParent = pdnObject->pListenParent;
	pdnObject->pListenParent = NULL;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	if (pListenParent)
	{
		DNCancelChildren(pdnObject,pListenParent);
		pListenParent->Release();
		pListenParent = NULL;
	}

	pdnObject->NameTable.EmptyTable(DPNERR_HOSTTERMINATEDSESSION);

	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->dwFlags &= ~(DN_OBJECT_FLAG_CONNECTING|DN_OBJECT_FLAG_CONNECTED|DN_OBJECT_FLAG_LOCALHOST);
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_CreateGroup"

STDMETHODIMP DN_CreateGroup(PVOID pInterface,
							const DPN_GROUP_INFO *const pdpnGroupInfo,
							void *const pvGroupContext,
							void *const pvAsyncContext,
							DPNHANDLE *const phAsyncHandle,
							const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	HRESULT				hResultCode;
	DPNHANDLE			hAsyncOp;
	PWSTR				pwszName;
	DWORD				dwNameSize;
	PVOID				pvData;
	DWORD				dwDataSize;
	CNameTableEntry		*pLocalPlayer;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], pdpnGroupInfo [0x%p], pvAsyncContext [0x%p], phAsyncHandle [0x%p], dwFlags [0x%lx]",
			pInterface,pdpnGroupInfo,pvAsyncContext,phAsyncHandle,dwFlags);

	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    	DNASSERT(pdnObject != NULL);

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
    	    if( FAILED( hResultCode = DN_ValidateCreateGroup( pInterface, pdpnGroupInfo, pvGroupContext,
    	                                                      pvAsyncContext,phAsyncHandle, dwFlags ) ) )
    	    {
    	        DPFERR( "Error validating create group params" );
    	        DPF_RETURN( hResultCode );
    	    }
    	}

    	// Check to ensure message handler registered
    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    	{
    		DPFERR( "Object is not initialized" );
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    	{
    	    DPFERR("You must be connected / hosting to create a group" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}    	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}

	pLocalPlayer = NULL;

	if ((pdpnGroupInfo->dwInfoFlags & DPNINFO_NAME) && (pdpnGroupInfo->pwszName))
	{
		pwszName = pdpnGroupInfo->pwszName;
		dwNameSize = (wcslen(pwszName) + 1) * sizeof(WCHAR);
	}
	else
	{
		pwszName = NULL;
		dwNameSize = 0;
	}
	if ((pdpnGroupInfo->dwInfoFlags & DPNINFO_DATA) && (pdpnGroupInfo->pvData) && (pdpnGroupInfo->dwDataSize))
	{
		pvData = pdpnGroupInfo->pvData;
		dwDataSize = pdpnGroupInfo->dwDataSize;
	}
	else
	{
		pvData = NULL;
		dwDataSize = 0;
	}

	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if (pLocalPlayer->IsHost())
	{
		DPFX(DPFPREP, 3,"Host is creating group");
		hResultCode = DNHostCreateGroup(pdnObject,
										pwszName,
										dwNameSize,
										pvData,
										dwDataSize,
										pdpnGroupInfo->dwInfoFlags,
										pdpnGroupInfo->dwGroupFlags,
										pvGroupContext,
										pvAsyncContext,
										pLocalPlayer->GetDPNID(),
										0,
										&hAsyncOp,
										dwFlags);
		if ((hResultCode != DPN_OK) && (hResultCode != DPNERR_PENDING))
		{
			DPFERR("Could not request host to create group");
		}
		else
		{
			if (!(dwFlags & DPNCREATEGROUP_SYNC))
			{
				DPFX(DPFPREP, 3,"Async Handle [0x%lx]",hAsyncOp);
				*phAsyncHandle = hAsyncOp;

				//
				//	Release Async HANDLE since this operation has already completed (!)
				//
				pdnObject->HandleTable.Destroy( hAsyncOp );
				hAsyncOp = 0;
			}
		}
	}
	else
	{
		DPFX(DPFPREP, 3,"Request host to create group");

		hResultCode = DNRequestCreateGroup(	pdnObject,
											pwszName,
											dwNameSize,
											pvData,
											dwDataSize,
											pdpnGroupInfo->dwGroupFlags,
											pvGroupContext,
											pvAsyncContext,
											&hAsyncOp,
											dwFlags);
		if ((hResultCode != DPN_OK) && (hResultCode != DPNERR_PENDING))
		{
			DPFERR("Could not request host to create group");
			hResultCode = DPNERR_GENERIC;
#pragma BUGBUG( minara, "This operation should be queued to re-try after host migration" )
		}
		else
		{
			if (!(dwFlags & DPNCREATEGROUP_SYNC))
			{
				DPFX(DPFPREP, 3,"Async Handle [0x%lx]",hAsyncOp);
				*phAsyncHandle = hAsyncOp;
			}
		}
	}

	pLocalPlayer->Release();
	pLocalPlayer = NULL;

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	DNASSERT(hResultCode != DPNERR_INVALIDENDPOINT);
	return(hResultCode);

Failure:
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_DestroyGroup"

STDMETHODIMP DN_DestroyGroup(PVOID pInterface,
							 const DPNID dpnidGroup,
							 PVOID const pvAsyncContext,
							 DPNHANDLE *const phAsyncHandle,
							 const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	HRESULT				hResultCode;
	DPNHANDLE			hAsyncOp;
	CNameTableEntry		*pLocalPlayer;
	CNameTableEntry		*pNTEntry;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], dpnidGroup [0x%lx], pvAsyncContext [0x%p], phAsyncHandle [0x%p], dwFlags [0x%lx]",
			pInterface,dpnidGroup,pvAsyncContext,phAsyncHandle,dwFlags);

	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    	DNASSERT(pdnObject != NULL);

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
    	    if( FAILED( hResultCode = DN_ValidateDestroyGroup( pInterface, dpnidGroup, pvAsyncContext,
    	                                                      phAsyncHandle, dwFlags ) ) )
    	    {
    	        DPFERR( "Error validating destroy group params" );
    	        DPF_RETURN( hResultCode );
    	    }
    	}

    	// Check to ensure message handler registered
    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    	{
    		DPFERR( "Object is not initialized" );
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    	{
    	    DPFERR("You must be connected / hosting to destroy a group" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}	
    	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}

	pLocalPlayer = NULL;
	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnidGroup,&pNTEntry)) != DPN_OK)
	{
	    DPFERR( "Could not find specified group" );
		DisplayDNError(0,hResultCode);
		//
		//	Try deleted list
		//
		if ((hResultCode = pdnObject->NameTable.FindDeletedEntry(dpnidGroup,&pNTEntry)) != DPN_OK)
		{
			hResultCode = DPNERR_INVALIDGROUP;
			goto Failure;
		}
		pNTEntry->Release();
		pNTEntry = NULL;
		hResultCode = DPNERR_CONNECTIONLOST;
		goto Failure;

	}
	if (!pNTEntry->IsGroup() || pNTEntry->IsAllPlayersGroup())
	{
		hResultCode = DPNERR_INVALIDGROUP;
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if (pLocalPlayer->IsHost())
	{
		DPFX(DPFPREP, 3,"Host is destroying group");
		hResultCode = DNHostDestroyGroup(	pdnObject,
											dpnidGroup,
											pvAsyncContext,
											pLocalPlayer->GetDPNID(),
											0,
											&hAsyncOp,
											dwFlags);
		if ((hResultCode != DPN_OK) && (hResultCode != DPNERR_PENDING))
		{
			DPFERR("Could not request host to destroy group");
		}
		else
		{
			if (!(dwFlags & DPNDESTROYGROUP_SYNC))
			{
				DPFX(DPFPREP, 3,"Async Handle [0x%lx]",hAsyncOp);
				*phAsyncHandle = hAsyncOp;

				//
				//	Release Async HANDLE since this operation has already completed (!)
				//
				pdnObject->HandleTable.Destroy( hAsyncOp );
				hAsyncOp = 0;
			}
		}
	}
	else
	{
		DPFX(DPFPREP, 3,"Request host to destroy group");

		hResultCode = DNRequestDestroyGroup(pdnObject,
											dpnidGroup,
											pvAsyncContext,
											&hAsyncOp,
											dwFlags);
		if (hResultCode != DPN_OK && hResultCode != DPNERR_PENDING)
		{
			DPFERR("Could not request host to destroy group");
			hResultCode = DPNERR_GENERIC;
#pragma BUGBUG( minara, "This operation should be queued to re-try after host migration" )
		}
		else
		{
			if (!(dwFlags & DPNDESTROYGROUP_SYNC))
			{
				DPFX(DPFPREP, 3,"Async Handle [0x%lx]",hAsyncOp);
				*phAsyncHandle = hAsyncOp;
			}
		}
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	DNASSERT(hResultCode != DPNERR_INVALIDENDPOINT);
	return(hResultCode);

Failure:
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_AddClientToGroup"

STDMETHODIMP DN_AddClientToGroup(PVOID pInterface,
								 const DPNID dpnidGroup,
								 const DPNID dpnidClient,
								 PVOID const pvAsyncContext,
								 DPNHANDLE *const phAsyncHandle,
								 const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	HRESULT				hResultCode;
	DPNHANDLE			hAsyncOp;
	CNameTableEntry		*pLocalPlayer;
	CNameTableEntry		*pNTEntry;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], dpnidGroup [0x%lx], dpnidClient [0x%lx], pvAsyncContext [0x%p], phAsyncHandle [0x%p], dwFlags [0x%lx]",
			pInterface,dpnidGroup,dpnidClient,pvAsyncContext,phAsyncHandle,dwFlags);

	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    	DNASSERT(pdnObject != NULL);

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
    	    if( FAILED( hResultCode = DN_ValidateAddClientToGroup( pInterface, dpnidGroup, dpnidClient, pvAsyncContext,
    	                                                      phAsyncHandle, dwFlags ) ))
    	    {
    	        DPFERR( "Error validating add client to group params" );
    	        DPF_RETURN( hResultCode );
    	    }
    	}

    	// Check to ensure message handler registered
    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    	{
    		DPFERR( "Object is not initialized" );
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    	{
    	    DPFERR("You must be connected / hosting to add a player to a group" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}    	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}

	pLocalPlayer = NULL;
	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnidGroup,&pNTEntry)) != DPN_OK)
	{
        DPFERR( "Unable to find specified group" );
		hResultCode = DPNERR_INVALIDGROUP;
		goto Failure;
	}
	if (!pNTEntry->IsGroup() || pNTEntry->IsAllPlayersGroup())
	{
	    DPFERR( "Unable to specify client or all players group for group ID" );
		hResultCode = DPNERR_INVALIDGROUP;
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnidClient,&pNTEntry)) != DPN_OK)
	{
	    DPFERR( "Unable to find specified player" );
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}
	if (pNTEntry->IsGroup())
	{
	    DPFERR( "Specified client is a group ID" );
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if (pLocalPlayer->IsHost())
	{
		DPFX(DPFPREP, 3,"Host is adding player to group");
		hResultCode = DNHostAddPlayerToGroup(	pdnObject,
												dpnidGroup,
												dpnidClient,
												pvAsyncContext,
												pLocalPlayer->GetDPNID(),
												0,
												&hAsyncOp,
												dwFlags);
		if ((hResultCode != DPN_OK) && (hResultCode != DPNERR_PENDING))
		{
			DPFERR("Could not request host to add player to group");
		}
		else
		{
			if (!(dwFlags & DPNADDPLAYERTOGROUP_SYNC))
			{
				DPFX(DPFPREP, 3,"Async Handle [0x%lx]",hAsyncOp);
				*phAsyncHandle = hAsyncOp;

				//
				//	Release Async HANDLE since this operation has already completed (!)
				//
				pdnObject->HandleTable.Destroy( hAsyncOp );
				hAsyncOp = 0;
			}
		}
	}
	else
	{
		DPFX(DPFPREP, 3,"Request host to add player to group");

		hResultCode = DNRequestAddPlayerToGroup(pdnObject,
												dpnidGroup,
												dpnidClient,
												pvAsyncContext,
												&hAsyncOp,
												dwFlags);
		if (hResultCode != DPN_OK && hResultCode != DPNERR_PENDING)
		{
			DPFERR("Could not request host to add player to group");
			hResultCode = DPNERR_GENERIC;
#pragma BUGBUG( minara, "This operation should be queued to re-try after host migration" )
		}
		else
		{
			if (!(dwFlags & DPNADDPLAYERTOGROUP_SYNC))
			{
				DPFX(DPFPREP, 3,"Async Handle [0x%lx]",hAsyncOp);
				*phAsyncHandle = hAsyncOp;
			}
		}
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	DNASSERT(hResultCode != DPNERR_INVALIDENDPOINT);
	return(hResultCode);

Failure:
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_RemoveClientFromGroup"

STDMETHODIMP DN_RemoveClientFromGroup(PVOID pInterface,
									  const DPNID dpnidGroup,
									  const DPNID dpnidClient,
									  PVOID const pvAsyncContext,
									  DPNHANDLE *const phAsyncHandle,
									  const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	HRESULT				hResultCode;
	DPNHANDLE			hAsyncOp;
	CNameTableEntry		*pLocalPlayer;
	CNameTableEntry		*pNTEntry;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], dpnidGroup [0x%lx], dpnidClient [0x%lx], pvAsyncContext [0x%p], phAsyncHandle [0x%p], dwFlags [0x%lx]",
			pInterface,dpnidGroup,dpnidClient,pvAsyncContext,phAsyncHandle,dwFlags);

	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    	DNASSERT(pdnObject != NULL);

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
    	    if( FAILED( hResultCode = DN_ValidateRemoveClientFromGroup( pInterface, dpnidGroup, dpnidClient, pvAsyncContext, phAsyncHandle, dwFlags ) ))
    	    {
    	        DPFERR( "Error validating remove client from group params" );
    	        DPF_RETURN( hResultCode );
    	    }
    	}

    	// Check to ensure message handler registered
    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    	{
    		DPFERR( "Object is not initialized" );
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    	{
    	    DPFERR("You must be connected / hosting to remove a player from a group" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}

	pLocalPlayer = NULL;
	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnidGroup,&pNTEntry)) != DPN_OK)
	{
	    DPFERR( "Could not find specified group in nametable" );
		hResultCode = DPNERR_INVALIDGROUP;
		goto Failure;
	}
	if (!pNTEntry->IsGroup() || pNTEntry->IsAllPlayersGroup())
	{
	    DPFERR( "Specified ID is not a valid group!" );
		hResultCode = DPNERR_INVALIDGROUP;
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnidClient,&pNTEntry)) != DPN_OK)
	{
	    DPFERR( "Specified client ID is not a valid client!" );
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}
	if (pNTEntry->IsGroup())
	{
	    DPFERR( "Specified client ID is a group!" );	
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if (pLocalPlayer->IsHost())
	{
		DPFX(DPFPREP, 3,"Host is deleting player from group");
		hResultCode = DNHostDeletePlayerFromGroup(	pdnObject,
													dpnidGroup,
													dpnidClient,
													pvAsyncContext,
													pLocalPlayer->GetDPNID(),
													0,
													&hAsyncOp,
													dwFlags);
		if ((hResultCode != DPN_OK) && (hResultCode != DPNERR_PENDING))
		{
			DPFERR("Could not request host to delete player from group");
		}
		else
		{
			if (!(dwFlags & DPNREMOVEPLAYERFROMGROUP_SYNC))
			{
				DPFX(DPFPREP, 3,"Async Handle [0x%lx]",hAsyncOp);
				*phAsyncHandle = hAsyncOp;

				//
				//	Release Async HANDLE since this operation has already completed (!)
				//
				pdnObject->HandleTable.Destroy( hAsyncOp );
				hAsyncOp = 0;
			}
		}
	}
	else
	{
		DPFX(DPFPREP, 3,"Request host to delete player from group");

		hResultCode = DNRequestDeletePlayerFromGroup(pdnObject,
													dpnidGroup,
													dpnidClient,
													pvAsyncContext,
													&hAsyncOp,
													dwFlags);
		if (hResultCode != DPN_OK && hResultCode != DPNERR_PENDING)
		{
			DPFERR("Could not request host to delete player from group");
			hResultCode = DPNERR_GENERIC;
#pragma BUGBUG( minara, "This operation should be queued to re-try after host migration" )
		}
		else
		{
			if (!(dwFlags & DPNREMOVEPLAYERFROMGROUP_SYNC))
			{
				DPFX(DPFPREP, 3,"Async Handle [0x%lx]",hAsyncOp);
				*phAsyncHandle = hAsyncOp;
			}
		}
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	DNASSERT(hResultCode != DPNERR_INVALIDENDPOINT);
	return(hResultCode);

Failure:
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


//	DN_SetGroupInfo

#undef DPF_MODNAME
#define DPF_MODNAME "DN_SetGroupInfo"

STDMETHODIMP DN_SetGroupInfo( PVOID pv,
							  const DPNID dpnid,
							  DPN_GROUP_INFO *const pdpnGroupInfo,
							  PVOID const pvAsyncContext,
							  DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	HRESULT				hResultCode;
	DPNHANDLE			hAsyncOp;
	PWSTR				pwszName;
	DWORD				dwNameSize;
	PVOID				pvData;
	DWORD				dwDataSize;
	CNameTableEntry		*pLocalPlayer;
	CNameTableEntry		*pNTEntry;

	DPFX(DPFPREP, 2,"Parameters: pv [0x%p], dpnid [0x%lx], pvAsyncContext [0x%p], phAsyncHandle [0x%p], dwFlags [0x%lx]",
			pv,dpnid,pdpnGroupInfo,pvAsyncContext,phAsyncHandle,dwFlags);

	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pv));
    	DNASSERT(pdnObject != NULL);

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
    	    if( FAILED( hResultCode = DN_ValidateSetGroupInfo( pv, dpnid, pdpnGroupInfo, pvAsyncContext, phAsyncHandle, dwFlags ) ) )
    	    {
    	        DPFERR( "Error validating set group info params" );
    	        DPF_RETURN( hResultCode );
    	    }
    	}

    	// Check to ensure message handler registered
    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    	{
    		DPFERR( "Object is not initialized" );
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    	{
    	    DPFERR("You must be connected / hosting to set group info" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}	    	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}
	
	pLocalPlayer = NULL;
	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
	    DPFERR( "Specified ID is not a group" );
		if ((hResultCode = pdnObject->NameTable.FindDeletedEntry(dpnid,&pNTEntry)) != DPN_OK)
		{
			hResultCode = DPNERR_INVALIDGROUP;
			goto Failure;
		}
		pNTEntry->Release();
		pNTEntry = NULL;
		hResultCode = DPNERR_CONNECTIONLOST;
		goto Failure;
	}
	if (!pNTEntry->IsGroup() || pNTEntry->IsAllPlayersGroup())
	{
	    DPFERR( "Specified ID is not a valid group" );
		hResultCode = DPNERR_INVALIDGROUP;
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	if ((pdpnGroupInfo->dwInfoFlags & DPNINFO_NAME) && (pdpnGroupInfo->pwszName))
	{
		pwszName = pdpnGroupInfo->pwszName;
		dwNameSize = (wcslen(pwszName) + 1) * sizeof(WCHAR);
	}
	else
	{
		pwszName = NULL;
		dwNameSize = 0;
	}
	if ((pdpnGroupInfo->dwInfoFlags & DPNINFO_DATA) && (pdpnGroupInfo->pvData) && (pdpnGroupInfo->dwDataSize))
	{
		pvData = pdpnGroupInfo->pvData;
		dwDataSize = pdpnGroupInfo->dwDataSize;
	}
	else
	{
		pvData = NULL;
		dwDataSize = 0;
	}

	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if (pLocalPlayer->IsHost())
	{
		DPFX(DPFPREP, 3,"Host is updating group info");
		hResultCode = DNHostUpdateInfo(	pdnObject,
										dpnid,
										pwszName,
										dwNameSize,
										pvData,
										dwDataSize,
										pdpnGroupInfo->dwInfoFlags,
										pvAsyncContext,
										pLocalPlayer->GetDPNID(),
										0,
										&hAsyncOp,
										dwFlags );
		if ((hResultCode != DPN_OK) && (hResultCode != DPNERR_PENDING))
		{
			DPFERR("Could not request host to update info");
		}
		else
		{
			if (!(dwFlags & DPNSETGROUPINFO_SYNC))
			{
				DPFX(DPFPREP, 3,"Async Handle [0x%lx]",hAsyncOp);
				*phAsyncHandle = hAsyncOp;

				//
				//	Release Async HANDLE since this operation has already completed (!)
				//
				pdnObject->HandleTable.Destroy( hAsyncOp );
				hAsyncOp = 0;
			}
		}
	}
	else
	{
		DPFX(DPFPREP, 3,"Request host to update group info");

		hResultCode = DNRequestUpdateInfo(	pdnObject,
											dpnid,
											pwszName,
											dwNameSize,
											pvData,
											dwDataSize,
											pdpnGroupInfo->dwInfoFlags,
											pvAsyncContext,
											&hAsyncOp,
											dwFlags);
		if (hResultCode != DPN_OK && hResultCode != DPNERR_PENDING)
		{
			DPFERR("Could not request host to update info");
		}
		else
		{
			if (!(dwFlags & DPNSETGROUPINFO_SYNC))
			{
				DPFX(DPFPREP, 3,"Async Handle [0x%lx]",hAsyncOp);
				*phAsyncHandle = hAsyncOp;
			}
		}
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	DNASSERT(hResultCode != DPNERR_INVALIDENDPOINT);
	return(hResultCode);

Failure:
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


//	DN_GetGroupInfo
//
//	Retrieve group name and/or data from the local nametable.
//
//	lpwszGroupName may be NULL to avoid retrieving group name
//	pdwGroupFlags may be NULL to avoid retrieving group flags
//	pvGroupData may not by NULL if *pdwDataSize is non zero

#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetGroupInfo"

STDMETHODIMP DN_GetGroupInfo(PVOID pv,
							 const DPNID dpnid,
							 DPN_GROUP_INFO *const pdpnGroupInfo,
							 DWORD *const pdwSize,
							 const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	CNameTableEntry		*pNTEntry;
	CPackedBuffer		packedBuffer;
	HRESULT				hResultCode;

	DPFX(DPFPREP, 2,"Parameters: dpnid [0x%lx], pdpnGroupInfo [0x%p], dwFlags [0x%lx]",
			dpnid,pdpnGroupInfo,dwFlags);

	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pv));
    	DNASSERT(pdnObject != NULL);

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
    	    if( FAILED( hResultCode = DN_ValidateGetGroupInfo( pv, dpnid, pdpnGroupInfo, pdwSize, dwFlags ) ) )
    	    {
    	        DPFERR( "Error validating get group info params" );
    	        DPF_RETURN( hResultCode );
    	    }
    	}

    	// Check to ensure message handler registered
    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    	{
    		DPFERR( "Object is not initialized" );
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if( !(pdnObject->dwFlags & (DN_OBJECT_FLAG_CONNECTED | DN_OBJECT_FLAG_CLOSING)) )
    	{
    	    DPFERR("You must be connected / hosting to get group info" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}	    	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}

	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
	    DPFERR( "Specified group is not valid" );
		if ((hResultCode = pdnObject->NameTable.FindDeletedEntry(dpnid,&pNTEntry)) != DPN_OK)
		{
			hResultCode = DPNERR_INVALIDGROUP;
			goto Failure;
		}
	}
	packedBuffer.Initialize(pdpnGroupInfo,*pdwSize);

	pNTEntry->Lock();
	if (!pNTEntry->IsGroup() || pNTEntry->IsAllPlayersGroup())
	{
	    DPFERR( "Specified ID is not a group" );
		pNTEntry->Unlock();
		hResultCode = DPNERR_INVALIDGROUP;
		goto Failure;
	}

	hResultCode = pNTEntry->PackInfo(&packedBuffer);

	pNTEntry->Unlock();
	pNTEntry->Release();
	pNTEntry = NULL;

	if ((hResultCode == DPN_OK) || (hResultCode == DPNERR_BUFFERTOOSMALL))
	{
		*pdwSize = packedBuffer.GetSizeRequired();
	}

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_EnumClientsAndGroups"

STDMETHODIMP DN_EnumClientsAndGroups(PVOID pInterface,
									 DPNID *const prgdpnid,
									 DWORD *const pcdpnid,
									 const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	CBilink				*pBilink;
	CNameTableEntry		*pNTEntry;
	DWORD				dwCount;
	DPNID				*pDPNID;
	BOOL				bEnum = TRUE;
	HRESULT             hResultCode;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], prgdpnid [0x%p], pcdpnid [0x%p], dwFlags [0x%lx]",
			pInterface,prgdpnid,pcdpnid,dwFlags);

	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    	DNASSERT(pdnObject != NULL);

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
    	    if( FAILED( hResultCode = DN_ValidateEnumClientsAndGroups( pInterface, prgdpnid, pcdpnid, dwFlags ) ) )
    	    {
    	        DPFERR( "Error validating enum clients and groups params" );
    	        DPF_RETURN( hResultCode );
    	    }
    	}

    	// Check to ensure message handler registered
    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    	{
    		DPFERR( "Object is not initialized" );
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    	{
    	    DPFERR("You must be connected / hosting to enumerate players and groups" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}	
    	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}

	if (prgdpnid == NULL || *pcdpnid == 0)				// Don't enum if not asked to
	{
		bEnum = FALSE;
	}

	pdnObject->NameTable.ReadLock();

	dwCount = 0;
	pDPNID = prgdpnid;

	//
	//	Enum players
	//
	if (dwFlags & DPNENUM_PLAYERS)
	{
		pBilink = pdnObject->NameTable.m_bilinkPlayers.GetNext();
		while (pBilink != &pdnObject->NameTable.m_bilinkPlayers)
		{
			pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);

			pNTEntry->Lock();
			if (pNTEntry->IsAvailable())
			{
				dwCount++;
				if (bEnum && (dwCount <= *pcdpnid))
				{
					*pDPNID++ = pNTEntry->GetDPNID();
				}
				else
				{
					bEnum = FALSE;
				}
			}
			pNTEntry->Unlock();
			pBilink = pBilink->GetNext();
		}
	}

	//
	//	Enum groups
	//
	if (dwFlags & DPNENUM_GROUPS)
	{
		pBilink = pdnObject->NameTable.m_bilinkGroups.GetNext();
		while (pBilink != &pdnObject->NameTable.m_bilinkGroups)
		{
			pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);

			pNTEntry->Lock();
			if (pNTEntry->IsAvailable() && !pNTEntry->IsAllPlayersGroup())
			{
				dwCount++;
				if (bEnum && (dwCount <= *pcdpnid))
				{
					*pDPNID++ = pNTEntry->GetDPNID();
				}
				else
				{
					bEnum = FALSE;
				}
			}
			pNTEntry->Unlock();
			pBilink = pBilink->GetNext();
		}
	}

	pdnObject->NameTable.Unlock();

	//
	//	This will NOT include players/groups in the deleted list.
	//	i.e. removed from the NameTable but for whom DESTROY_PLAYER/GROUP notifications have yet to be posted
	//
	*pcdpnid = dwCount;
	if (!bEnum && dwCount)
	{
		hResultCode = DPNERR_BUFFERTOOSMALL;
	}
	else
	{
		hResultCode = DPN_OK;
	}

	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_EnumGroupMembers"

STDMETHODIMP DN_EnumGroupMembers(PVOID pInterface,
								 const DPNID dpnid,
								 DPNID *const prgdpnid,
								 DWORD *const pcdpnid,
								 const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	CNameTableEntry		*pNTEntry;
	CGroupMember		*pGroupMember;
	CBilink				*pBilink;
	DWORD				dwCount;
	DPNID				*pDPNID;
	BOOL				bOutputBufferTooSmall = FALSE;
	HRESULT				hResultCode;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], dpnid [0x%lx], prgdpnid [0x%p], pcdpnid [0x%p], dwFlags [0x%lx]",
			pInterface,dpnid,prgdpnid,pcdpnid,dwFlags);

	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    	DNASSERT(pdnObject != NULL);

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
    	    if( FAILED( hResultCode = DN_ValidateEnumGroupMembers( pInterface, dpnid, prgdpnid, pcdpnid, dwFlags ) ) )
    	    {
    	        DPFERR( "Error validating enum group params" );
    	        DPF_RETURN( hResultCode );
    	    }
    	}

    	// Check to ensure message handler registered
    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    	{
    		DPFERR( "Object is not initialized" );
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    	{
    	    DPFERR("You must be connected / hosting to enumerate group members" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}

	pNTEntry = NULL;

	//
	// if the user didn't supply a buffer, assume that the
	// output buffer is too small
	//
	if ( ( prgdpnid == NULL ) || ( ( *pcdpnid ) == 0 ) )	
	{
		bOutputBufferTooSmall = TRUE;
	}

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not find NameTableEntry");
		if ((hResultCode = pdnObject->NameTable.FindDeletedEntry(dpnid,&pNTEntry)) != DPN_OK)
		{
			hResultCode = DPNERR_INVALIDGROUP;
			goto Failure;
		}
		pNTEntry->Release();
		pNTEntry = NULL;
		hResultCode = DPNERR_CONNECTIONLOST;
		goto Failure;
	}

	if (!pNTEntry->IsGroup() || pNTEntry->IsAllPlayersGroup())
	{
		DPFERR("Not a group dpnid!");
		hResultCode = DPNERR_INVALIDGROUP;
		goto Failure;
	}

	pNTEntry->Lock();

	dwCount = 0;
	pDPNID = prgdpnid;

	pBilink = pNTEntry->m_bilinkMembership.GetNext();
	while (pBilink != &pNTEntry->m_bilinkMembership)
	{
		pGroupMember = CONTAINING_OBJECT(pBilink,CGroupMember,m_bilinkPlayers);
		dwCount++;
		if ( ( bOutputBufferTooSmall == FALSE ) && (dwCount <= *pcdpnid))
		{
			*pDPNID++ = pGroupMember->GetPlayer()->GetDPNID();
		}
		else
		{
			bOutputBufferTooSmall = TRUE;
		}
		pBilink = pBilink->GetNext();
	}

	pNTEntry->Unlock();
	pNTEntry->Release();
	pNTEntry = NULL;

	*pcdpnid = dwCount;

	//
	// if the user's output buffer appears to be incapable receiving
	// output, double-check to make sure that the output size requirement
	// isn't zero (which is really OK), before telling them that the
	// output buffer is too small
	//
	if ( ( bOutputBufferTooSmall ) && ( dwCount != 0 ) )
	{
		hResultCode = DPNERR_BUFFERTOOSMALL;
	}
	else
	{
		hResultCode = DPN_OK;
	}

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_EnumHosts"

STDMETHODIMP DN_EnumHosts( PVOID pv,
						   DPN_APPLICATION_DESC *const pApplicationDesc,
                           IDirectPlay8Address *const pAddrHost,
						   IDirectPlay8Address *const pDeviceInfo,
						   PVOID const pUserEnumData,
						   const DWORD dwUserEnumDataSize,
						   const DWORD dwRetryCount,
						   const DWORD dwRetryInterval,
						   const DWORD dwTimeOut,
						   PVOID const pvAsyncContext,
						   DPNHANDLE *const pAsyncHandle,
						   const DWORD dwFlags )
{
	DIRECTNETOBJECT	*pdnObject;
	HRESULT		hResultCode;
	HRESULT		hrEnum;
	GUID		guidSP;
	GUID		guidAdapter;
	CAsyncOp	*pParent;
	CAsyncOp	*pHandleParent;
	CSyncEvent	*pSyncEvent;
	CServiceProvider	*pSP;
	CRefCountBuffer		*pRCBuffer;
	DN_ENUM_QUERY	*pEnumQuery;
	IDirectPlay8Address	*pIHost;
	IDirectPlay8Address	*pIDevice;
	DPNHANDLE	handle;
	DPN_SP_CAPS	dnSPCaps;
	BOOL		fEnumAdapters;
	BOOL		fHosting;
	DWORD		dwBufferCount;
	DWORD		dwEnumQueryFlags;
	DWORD		dwMultiplexFlag;
#ifdef	DEBUG
	CHAR			DP8ABuffer[512];
	DWORD			DP8ASize;
#endif

	DPFX(DPFPREP, 2,"Parameters: pApplicationDesc [0x%p], pAddrHost [0x%p], pDeviceInfo [0x%p], pUserEnumData [0x%p], dwUserEnumDataSize [%ld], dwRetryCount [%ld], dwRetryInterval [%ld], dwTimeOut [%ld], pvAsyncContext [0x%p], pAsyncHandle [0x%p], dwFlags [0x%lx]",
		pApplicationDesc,pAddrHost,pDeviceInfo,pUserEnumData,dwUserEnumDataSize,dwRetryCount,dwRetryInterval,dwTimeOut,pvAsyncContext,pAsyncHandle,dwFlags);

	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pv));
    	DNASSERT(pdnObject != NULL);

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
    	    if( FAILED( hResultCode = DN_ValidateEnumHosts( pv, pApplicationDesc, pAddrHost,
    	                                                    pDeviceInfo, pUserEnumData, dwUserEnumDataSize,
    	                                                    dwRetryCount, dwRetryInterval, dwTimeOut,
															pvAsyncContext, pAsyncHandle, dwFlags ) ) )
    	    {
    	        DPFERR( "Error validating enum hosts params" );
    	        DPF_RETURN( hResultCode );
    	    }
    	}

    	// Check to ensure message handler registered
    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    	{
    		DPFERR( "Object is not initialized" );
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}	

	//
	// initialize
	//
	hResultCode = DPN_OK;
	pParent = NULL;
	pHandleParent = NULL;
	pSyncEvent = NULL;
	pRCBuffer = NULL;
	pSP = NULL;
	pIHost = NULL;
	pIDevice = NULL;
	handle = 0;
	dwMultiplexFlag = 0;

#ifdef	DEBUG
	if (pAddrHost)
	{
		DP8ASize = 512;
		pAddrHost->lpVtbl->GetURLA(pAddrHost,DP8ABuffer,&DP8ASize);
		DPFX(DPFPREP, 4,"Host address [%s]",DP8ABuffer);
	}

	if (pDeviceInfo)
	{
		DP8ASize = 512;
		pDeviceInfo->lpVtbl->GetURLA(pDeviceInfo,DP8ABuffer,&DP8ASize);
		DPFX(DPFPREP, 4,"Device address [%s]",DP8ABuffer);
	}
#endif

	//
	//	Cannot ENUM if Hosting - I have no idea why, but VanceO insisted on it
	//
	fHosting = FALSE;
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & (DN_OBJECT_FLAG_CONNECTED | DN_OBJECT_FLAG_CONNECTING))
	{
		CNameTableEntry		*pLocalPlayer;

		pLocalPlayer = NULL;

		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) == DPN_OK)
		{
			if (pLocalPlayer->IsHost())
			{
				fHosting = TRUE;
			}
			pLocalPlayer->Release();
			pLocalPlayer = NULL;
		}
	}
	else
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	}

	if (fHosting)
	{
		hResultCode = DPNERR_HOSTING;
		goto Failure;
	}


	//
	//	Extract SP guid as we will probably need it
	//
	hResultCode = pDeviceInfo->lpVtbl->GetSP(pDeviceInfo,&guidSP);
	if ( hResultCode != DPN_OK)
	{
		DPFERR("SP not specified in Device address");
		goto Failure;
	}

	//
	//	Ensure SP specified in Device address is loaded
	//
	if ((hResultCode = DN_SPEnsureLoaded(pdnObject,&guidSP,NULL,&pSP)) != DPN_OK)
	{
		DPFERR("Could not ensure SP is loaded!");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Get SP caps to ensure payload will fit
	//
	if ((hResultCode = DNGetActualSPCaps(pdnObject,pSP,&dnSPCaps)) != DPN_OK)
	{
		DPFERR("Could not get SP caps");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Ensure payload will fit
	//
	if (dwUserEnumDataSize > dnSPCaps.dwMaxEnumPayloadSize)
	{
		DPFERR("User enum data is too large");
		hResultCode = DPNERR_ENUMQUERYTOOLARGE;
		goto Failure;
	}

	//
	//	Duplicate addresses for local usage (so we can modify them if neccessary
	//
	if (pAddrHost)
	{
		// Use supplied Host address
		if ((hResultCode = pAddrHost->lpVtbl->Duplicate(pAddrHost,&pIHost)) != DPN_OK)
		{
			DPFERR("Could not duplicate Host address");
			DisplayDNError(0,hResultCode);
			hResultCode = DPNERR_INVALIDHOSTADDRESS;
			goto Failure;
		}
	}
	else
	{
		//
		//	Create new Host address and use Device SP guid
		//
		if ((hResultCode = COM_CoCreateInstance(CLSID_DirectPlay8Address,
											NULL,
											CLSCTX_INPROC_SERVER,
											IID_IDirectPlay8Address,
											reinterpret_cast<void**>(&pIHost))) != DPN_OK)
		{
			DPFERR("Could not create Host address");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}

		if ((hResultCode = pIHost->lpVtbl->SetSP(pIHost,&guidSP)) != DPN_OK)
		{
			DPFERR("Could not set Host address SP");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
	}

	if ((hResultCode = pDeviceInfo->lpVtbl->Duplicate(pDeviceInfo,&pIDevice)) != DPN_OK)
	{
		DPFERR("Could not duplicate Device address");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

#ifdef	DEBUG
	DP8ASize = 512;
	pIHost->lpVtbl->GetURLA(pIHost,DP8ABuffer,&DP8ASize);
	DPFX(DPFPREP, 4,"Host address [%s]",DP8ABuffer);

	DP8ASize = 512;
	pIDevice->lpVtbl->GetURLA(pIDevice,DP8ABuffer,&DP8ASize);
	DPFX(DPFPREP, 4,"Device address [%s]",DP8ABuffer);
#endif

	// Enum flags to Protocol
	dwEnumQueryFlags = 0;
	if (dwFlags & DPNENUMHOSTS_OKTOQUERYFORADDRESSING)
	{
		dwEnumQueryFlags |= DN_ENUMQUERYFLAGS_OKTOQUERYFORADDRESSING;
	}
	if (dwFlags & DPNENUMHOSTS_NOBROADCASTFALLBACK)
	{
		dwEnumQueryFlags |= DN_ENUMQUERYFLAGS_NOBROADCASTFALLBACK;
	}

	//
	//	Parent for ENUMs
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pParent)) != DPN_OK)
	{
		DPFERR("Could not create ENUM parent AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pParent->MakeParent();
	pParent->SetOpType( ASYNC_OP_ENUM_QUERY );
	pParent->SetContext( pvAsyncContext );
	pParent->SetCompletion( DNCompleteEnumQuery );
	pParent->SetOpFlags( dwEnumQueryFlags );

	//
	//	Synchronous ?
	//
	if (dwFlags & DPNENUMHOSTS_SYNC)
	{
		if ((hResultCode = SyncEventNew(pdnObject,&pSyncEvent)) != DPN_OK)
		{
			DPFERR("Could not create SyncEvent");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pParent->SetSyncEvent( pSyncEvent );
		pParent->SetResultPointer( &hrEnum );
		hrEnum = DPNERR_GENERIC;
	}
	else
	{
		//
		//	Create Handle parent AsyncOp (if required)
		//
		if ((hResultCode = DNCreateUserHandle(pdnObject,&pHandleParent)) != DPN_OK)
		{
			DPFERR("Could not create AsyncOp");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pHandleParent->SetContext( pvAsyncContext );
		pHandleParent->Lock();
		if (pHandleParent->IsCancelled())
		{
			pHandleParent->Unlock();
			pParent->SetResult( DPNERR_USERCANCEL );
			hResultCode = DPNERR_USERCANCEL;
			goto Failure;
		}
		pParent->MakeChild( pHandleParent );
		handle = pHandleParent->GetHandle();
		pHandleParent->Unlock();
	}

	//
	//	Keep SP on ENUM parent
	//
	pParent->SetSP( pSP );
	pSP->Release();
	pSP = NULL;

	//
	//	If there is no adapter specified in the device address,
	//	we will attempt to enum on each individual adapter if the SP supports it
	//
	fEnumAdapters = FALSE;
	if ((hResultCode = pIDevice->lpVtbl->GetDevice( pIDevice, &guidAdapter )) != DPN_OK)
	{
		DPFX(DPFPREP,1,"Could not determine adapter");
		DisplayDNError(1,hResultCode);

		if (dnSPCaps.dwFlags & DPNSPCAPS_SUPPORTSALLADAPTERS)
		{
			DPFX(DPFPREP, 3,"SP supports ENUMing on all adapters");
			fEnumAdapters = TRUE;
		}
	}

	if(fEnumAdapters)
	{
		DWORD	dwNumAdapters;

		if ((hResultCode = DNEnumAdapterGuids(	pdnObject,
												&guidSP,
												sizeof(DN_ENUM_QUERY),
												reinterpret_cast<void**>(&pEnumQuery),
												&dwNumAdapters)) != DPN_OK)
		{
			DPFERR("Could not enum adapters for this SP");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
		if (dwNumAdapters == 0)
		{
			DPFERR("No adapters were found for this SP");
			hResultCode = DPNERR_INVALIDDEVICEADDRESS;
			goto Failure;
		}

		pEnumQuery->dwNumAdapters = dwNumAdapters;
		pEnumQuery->dwCurrentAdapter = 0;

		if (dwNumAdapters > 1)
		{
			dwMultiplexFlag |= DN_ENUMQUERYFLAGS_ADDITIONALMULTIPLEXADAPTERS;
		}
		
		pParent->SetOpData( pEnumQuery );

		//
		//	Choose first adapter for initial LISTEN call
		//
		if ((hResultCode = pIDevice->lpVtbl->SetDevice(pIDevice,reinterpret_cast<GUID*>(pEnumQuery + 1))) != DPN_OK)
		{
			DPFERR("Could not set device adapter");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
		pEnumQuery->dwCurrentAdapter++;
	}
	else
	{
		void	*pvBlock;

		if ((pvBlock = MemoryBlockAlloc(pdnObject,sizeof(DN_ENUM_QUERY))) == NULL)
		{
			DPFERR("Could not allocate MemoryBlock");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		pEnumQuery = static_cast<DN_ENUM_QUERY*>(pvBlock);
		pEnumQuery->dwNumAdapters = 0;
		pEnumQuery->dwCurrentAdapter = 0;
		pParent->SetOpData( pvBlock );
		pvBlock = NULL;
	}

	//
	//	Set up EnumQuery BufferDescriptions
	//
	//
	// When filling out the enum structure the SP requires an extra BUFFERDESC
	// to exist immediately before the one were passing with the user data.  The
	// SP will be using that extra buffer to prepend an optional header
	//

	pEnumQuery->BufferDesc[DN_ENUM_BUFFERDESC_QUERY_DN_PAYLOAD].pBufferData = reinterpret_cast<BYTE*>(&pEnumQuery->EnumQueryPayload);
	if (pApplicationDesc->guidApplication != GUID_NULL)
	{
		DPFX(DPFPREP, 7, "Object 0x%p enumerating with application GUID {%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}.",
			pdnObject,
			pApplicationDesc->guidApplication.Data1,
			pApplicationDesc->guidApplication.Data2,
			pApplicationDesc->guidApplication.Data3,
			pApplicationDesc->guidApplication.Data4[0],
			pApplicationDesc->guidApplication.Data4[1],
			pApplicationDesc->guidApplication.Data4[2],
			pApplicationDesc->guidApplication.Data4[3],
			pApplicationDesc->guidApplication.Data4[4],
			pApplicationDesc->guidApplication.Data4[5],
			pApplicationDesc->guidApplication.Data4[6],
			pApplicationDesc->guidApplication.Data4[7]);


		pEnumQuery->EnumQueryPayload.QueryType = DN_ENUM_QUERY_WITH_APPLICATION_GUID;
		memcpy(&pEnumQuery->EnumQueryPayload.guidApplication,&pApplicationDesc->guidApplication,sizeof(GUID));
		pEnumQuery->BufferDesc[DN_ENUM_BUFFERDESC_QUERY_DN_PAYLOAD].dwBufferSize = sizeof(DN_ENUM_QUERY_PAYLOAD);
	}
	else
	{
		pEnumQuery->EnumQueryPayload.QueryType = DN_ENUM_QUERY_WITHOUT_APPLICATION_GUID;
		pEnumQuery->BufferDesc[DN_ENUM_BUFFERDESC_QUERY_DN_PAYLOAD].dwBufferSize = sizeof(DN_ENUM_QUERY_PAYLOAD) - sizeof(GUID);
	}

	//
	//	Copy user data (if any)
	//
	if (pUserEnumData && dwUserEnumDataSize)
	{
		DPFX(DPFPREP,3,"User enum data specified");
		if ((hResultCode = RefCountBufferNew(pdnObject,dwUserEnumDataSize,&pRCBuffer)) != DPN_OK)
		{
			DPFERR("Could not create RefCountBuffer");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
		memcpy(pRCBuffer->GetBufferAddress(),pUserEnumData,dwUserEnumDataSize);
		pEnumQuery->BufferDesc[DN_ENUM_BUFFERDESC_QUERY_USER_PAYLOAD].pBufferData = reinterpret_cast<BYTE*>(pRCBuffer->GetBufferAddress());
		pEnumQuery->BufferDesc[DN_ENUM_BUFFERDESC_QUERY_USER_PAYLOAD].dwBufferSize = dwUserEnumDataSize;
		pParent->SetRefCountBuffer( pRCBuffer );
		dwBufferCount = DN_ENUM_BUFFERDESC_QUERY_COUNT;

		pRCBuffer->Release();
		pRCBuffer = NULL;
	}
	else
	{
		DPFX(DPFPREP,3,"User enum data not specified");
		pEnumQuery->BufferDesc[DN_ENUM_BUFFERDESC_QUERY_USER_PAYLOAD].pBufferData = NULL;
		pEnumQuery->BufferDesc[DN_ENUM_BUFFERDESC_QUERY_USER_PAYLOAD].dwBufferSize = 0;
		dwBufferCount = DN_ENUM_BUFFERDESC_QUERY_COUNT - 1;
	}


	//
	//	Set up EnumQuery misc fields
	//
	pEnumQuery->dwRetryCount = dwRetryCount;
	pEnumQuery->dwRetryInterval = dwRetryInterval;
	pEnumQuery->dwTimeOut = dwTimeOut;
	pEnumQuery->dwBufferCount = dwBufferCount;

#pragma TODO( minara, "We do not need to send each of these parameters individually - they are already in a structure !" )
	DPFX(DPFPREP,3,"Number of buffers actually used [%ld]",dwBufferCount);
	hResultCode = DNPerformEnumQuery(	pdnObject,
										pIHost,
										pIDevice,
										pParent->GetSP()->GetHandle(),
										&pEnumQuery->BufferDesc[DN_ENUM_BUFFERDESC_QUERY_DN_PAYLOAD],
										pEnumQuery->dwBufferCount,
										pEnumQuery->dwRetryCount,
										pEnumQuery->dwRetryInterval,
										pEnumQuery->dwTimeOut,
										pParent->GetOpFlags() | dwMultiplexFlag,
										pParent->GetContext(),
										pParent );
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not start ENUM");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
											
	pParent->Release();
	pParent = NULL;

	//
	//	Wait for SyncEvent or return Async Handle
	//
	if (dwFlags & DPNENUMHOSTS_SYNC)
	{
		pSyncEvent->WaitForEvent( INFINITE );
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
		hResultCode = hrEnum;
	}
	else
	{
		//
		//	Blame vanceo if this EVER returns anything other than DPN_OK at this stage
		//
		pHandleParent->SetCompletion( DNCompleteAsyncHandle );
		pHandleParent->Release();
		pHandleParent = NULL;

		*pAsyncHandle = handle;
		hResultCode = DPNERR_PENDING;
	}

	pIDevice->lpVtbl->Release(pIDevice);
	pIDevice = NULL;

	pIHost->lpVtbl->Release(pIHost);
	pIHost = NULL;

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	DNASSERT(hResultCode != DPNERR_INVALIDENDPOINT);
	return(hResultCode);

Failure:
	if (handle != 0)
	{
		pdnObject->HandleTable.Destroy( handle );
		handle = 0;
	}
	if (pParent)
	{
		pParent->Release();
		pParent = NULL;
	}
	if (pHandleParent)
	{
		pHandleParent->Release();
		pHandleParent = NULL;
	}
	if (pSyncEvent)
	{
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}
	if (pRCBuffer)
	{
		pRCBuffer->Release();
		pRCBuffer = NULL;
	}
	if (pSP)
	{
		pSP->Release();
		pSP = NULL;
	}
	if (pIHost)
	{
		pIHost->lpVtbl->Release(pIHost);
		pIHost = NULL;
	}
	if (pIDevice)
	{
		pIDevice->lpVtbl->Release(pIDevice);
		pIDevice = NULL;
	}
	goto Exit;
}


//**********************************************************************



//	DN_DestroyPlayer
//
//	Remove a player from this DirectNet session
//	This will send a termination message to the player.
//	Both the host and the player will terminate.

#undef DPF_MODNAME
#define DPF_MODNAME "DN_DestroyPlayer"

STDMETHODIMP DN_DestroyPlayer(PVOID pInterface,
							  const DPNID dpnid,
							  const void *const pvDestroyData,
							  const DWORD dwDestroyDataSize,
							  const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	HRESULT				hResultCode;
	CRefCountBuffer		*pRefCountBuffer;
	CNameTableEntry		*pNTEntry;
	CConnection			*pConnection;
	DN_INTERNAL_MESSAGE_TERMINATE_SESSION	*pMsg;

	DPFX(DPFPREP, 3,"Parameters: pInterface [0x%p], dpnid [0x%lx], pvDestroyData [0x%p], dwDestroyDataSize [%ld], dwFlags [0x%lx]",
			pInterface,dpnid,pvDestroyData,dwDestroyDataSize,dwFlags);

	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    	DNASSERT(pdnObject != NULL);

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
    	    if( FAILED( hResultCode = DN_ValidateDestroyPlayer( pInterface, dpnid, pvDestroyData, dwDestroyDataSize, dwFlags ) ) )
    	    {
    	        DPFERR( "Error validating destroy player params" );
    	        DPF_RETURN( hResultCode );
    	    }
    	}

    	// Check to ensure message handler registered
    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    	{
    		DPFERR( "Object is not initialized" );
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    	{
    	    DPFERR("You must be connected / hosting to destroy a player" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}

	pNTEntry = NULL;
	pRefCountBuffer = NULL;
	pConnection = NULL;

	if (!DN_CHECK_LOCALHOST(pdnObject))
	{
	    DPFERR( "Object is not session host, cannot destroy players" );
		DPF_RETURN(DPNERR_NOTHOST);
	}

	// Ensure DNID specified is valid
	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not find player entry");
		DisplayDNError(0,hResultCode);
		if ((hResultCode = pdnObject->NameTable.FindDeletedEntry(dpnid,&pNTEntry)) != DPN_OK)
		{
			hResultCode = DPNERR_INVALIDPLAYER;
			goto Failure;
		}
		pNTEntry->Release();
		pNTEntry = NULL;
		hResultCode = DPNERR_CONNECTIONLOST;
		goto Failure;
	}
	if (pNTEntry->IsLocal() )
	{
		DPFERR( "Cannot destroy local player" );
		hResultCode = DPNERR_INVALIDPLAYER;		
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if (pNTEntry->IsGroup())
	{
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}
	if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		DPFERR("Could not get connection ref");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_CONNECTIONLOST;
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	Build terminate message
	//
	if ((hResultCode = RefCountBufferNew(pdnObject,
			sizeof(DN_INTERNAL_MESSAGE_TERMINATE_SESSION) + dwDestroyDataSize,&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not allocate RefCountBuffer");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_TERMINATE_SESSION*>(pRefCountBuffer->GetBufferAddress());
	if (dwDestroyDataSize)
	{
		memcpy(pMsg+1,pvDestroyData,dwDestroyDataSize);
		pMsg->dwTerminateDataOffset = sizeof(DN_INTERNAL_MESSAGE_TERMINATE_SESSION);
	}
	else
	{
		pMsg->dwTerminateDataOffset = 0;
	}
	pMsg->dwTerminateDataSize = dwDestroyDataSize;

	//
	//	Send message to player to exit
	//
	hResultCode = DNSendMessage(pdnObject,
								pConnection,
								DN_MSG_INTERNAL_TERMINATE_SESSION,
								dpnid,
								pRefCountBuffer->BufferDescAddress(),
								pRefCountBuffer,
								0,
								DN_SENDFLAGS_RELIABLE,
								NULL,
								NULL);
	if (hResultCode != DPNERR_PENDING)
	{
		DPFERR("Could not send DESTROY_CLIENT message to player");
		DisplayDNError(0,hResultCode);
		if (hResultCode == DPNERR_INVALIDENDPOINT)
		{
			hResultCode = DPNERR_INVALIDPLAYER;
		}
		goto Failure;
	}

	pConnection->Release();
	pConnection = NULL;

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	//
	//	Remove from NameTable and inform other players of disconnect
	//
	hResultCode = DNHostDisconnect(pdnObject,dpnid,DPNDESTROYPLAYERREASON_HOSTDESTROYEDPLAYER);

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	DNASSERT(hResultCode != DPNERR_INVALIDENDPOINT);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	goto Exit;
}



//	DN_ReturnBuffer
//
//	Return a receive buffer which is no longer in use

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ReturnBuffer"

STDMETHODIMP DN_ReturnBuffer(PVOID pv,
							 const DPNHANDLE hBufferHandle,
							 const DWORD dwFlags)
{
	DIRECTNETOBJECT	*pdnObject;
	HRESULT			hResultCode;
	CAsyncOp		*pAsyncOp;

	DPFX(DPFPREP, 2,"Parameters: hBufferHandle [0x%lx], dwFlags [0x%lx]",hBufferHandle,dwFlags);

	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pv));
    	DNASSERT(pdnObject != NULL);

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
    	    if( FAILED( hResultCode = DN_ValidateReturnBuffer( pv, hBufferHandle, dwFlags ) ) )
    	    {
    	        DPFERR( "Error validating return buffer params" );
    	        DPF_RETURN( hResultCode );
    	    }
    	}

    	// Check to ensure message handler registered
    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    	{
    		DPFERR( "Object is not initialized" );
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    	{
    	    DPFERR("You must be connected / hosting to return a buffer" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}

	DNASSERT( pdnObject != NULL );

	pAsyncOp = NULL;

	//
	//	Find async op
	//
	if ((hResultCode = pdnObject->HandleTable.Find( hBufferHandle,&pAsyncOp )) != DPN_OK)
	{
		DPFERR("Could not find handle");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_INVALIDHANDLE;
		goto Failure;
	}

	//
	//	Ensure it's not already cancelled
	//
	pAsyncOp->Lock();
	if (pAsyncOp->IsCancelled() || pAsyncOp->IsComplete())
	{
		pAsyncOp->Unlock();
		hResultCode = DPNERR_INVALIDHANDLE;
		goto Failure;
	}
	pAsyncOp->SetComplete();
	pAsyncOp->Unlock();

	if ((hResultCode = pdnObject->HandleTable.Destroy( hBufferHandle )) == DPN_OK)
	{
		//
		//	Remove from active list
		//
		DNEnterCriticalSection(&pdnObject->csActiveList);
		pAsyncOp->m_bilinkActiveList.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csActiveList);
	}

	pAsyncOp->Release();
	pAsyncOp = NULL;

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pAsyncOp)
	{
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	goto Exit;
}


//	DN_GetPlayerContext

#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetPlayerContext"

STDMETHODIMP DN_GetPlayerContext(PVOID pv,
								 const DPNID dpnid,
								 PVOID *const ppvPlayerContext,
								 const DWORD dwFlags)
{
	HRESULT				hResultCode;
	CNameTableEntry		*pNTEntry;
	DIRECTNETOBJECT		*pdnObject;

	DPFX(DPFPREP, 2,"Parameters: pv [0x%p], dpnid [0x%lx], ppvPlayerContext [0x%p], dwFlags [0x%lx]",
			pv, dpnid,ppvPlayerContext,dwFlags);

	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pv));
    	DNASSERT(pdnObject != NULL);

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
    	    if( FAILED( hResultCode = DN_ValidateGetPlayerContext( pv, dpnid, ppvPlayerContext, dwFlags ) ) )
    	    {
    	        DPFERR( "Error validating getplayercontext params" );
    	        DPF_RETURN( hResultCode );
    	    }
    	}

    	// Check to ensure message handler registered
    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    	{
    		DPFERR( "Object is not initialized" );
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if ( !(pdnObject->dwFlags & (DN_OBJECT_FLAG_CONNECTED | DN_OBJECT_FLAG_CLOSING | DN_OBJECT_FLAG_DISCONNECTING) ) )
    	{
    	    DPFERR("You must be connected / hosting to get player context" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}	

	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not retrieve player entry");
		DisplayDNError(0,hResultCode);

		//
		//	Try deleted list
		//
		if ((hResultCode = pdnObject->NameTable.FindDeletedEntry(dpnid,&pNTEntry)) != DPN_OK)
		{
			DPFERR("Could not find player in deleted list either");
			DisplayDNError(0,hResultCode);
			hResultCode = DPNERR_INVALIDPLAYER;
			goto Failure;
		}
	}

	//
	//	Ensure this is not a group and that the player has been created
	//	There may be a period during which the player is "available" but the CREATE_PLAYER notification
	//	has not returned.  Return DPNERR_NOTREADY in this case.
	//
	pNTEntry->Lock();
	if (pNTEntry->IsGroup())
	{
		pNTEntry->Unlock();
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}
	if (!pNTEntry->IsCreated())
	{
		if (pNTEntry->IsAvailable())
		{
			hResultCode = DPNERR_NOTREADY;
		}
		else
		{
			hResultCode = DPNERR_INVALIDPLAYER;
		}
		pNTEntry->Unlock();
		goto Failure;
	}

	*ppvPlayerContext = pNTEntry->GetContext();
	pNTEntry->Unlock();
	pNTEntry->Release();
	pNTEntry = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


//	DN_GetGroupContext

#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetGroupContext"

STDMETHODIMP DN_GetGroupContext(PVOID pv,
								const DPNID dpnid,
								PVOID *const ppvGroupContext,
								const DWORD dwFlags)
{
	HRESULT				hResultCode;
	CNameTableEntry		*pNTEntry;
	DIRECTNETOBJECT		*pdnObject;

	DPFX(DPFPREP, 2,"Parameters: pv [0x%p], dpnid [0x%lx], ppvGroupContext [0x%p], dwFlags [0x%lx]",
			pv, dpnid,ppvGroupContext,dwFlags);

	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pv));
    	DNASSERT(pdnObject != NULL);

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
    	    if( FAILED( hResultCode = DN_ValidateGetGroupContext( pv, dpnid, ppvGroupContext,dwFlags ) ) )
    	    {
    	        DPFERR( "Error validating getgroupcontext params" );
    	        DPF_RETURN( hResultCode );
    	    }
    	}

    	// Check to ensure message handler registered
    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    	{
    		DPFERR( "Object is not initialized" );
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if ( !(pdnObject->dwFlags & (DN_OBJECT_FLAG_CONNECTED | DN_OBJECT_FLAG_CLOSING | DN_OBJECT_FLAG_DISCONNECTING) ) )
    	{
    	    DPFERR("You must be connected / hosting to get group context" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}	

	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not retrieve group entry");
		DisplayDNError(0,hResultCode);

		//
		//	Try deleted list
		//
		if ((hResultCode = pdnObject->NameTable.FindDeletedEntry(dpnid,&pNTEntry)) != DPN_OK)
		{
			DPFERR("Could not find player in deleted list either");
			DisplayDNError(0,hResultCode);
			hResultCode = DPNERR_INVALIDGROUP;
			goto Failure;
		}
	}

	//
	//	Ensure this is not a player and that the group has been created
	//	There may be a period during which the group is "available" but the CREATE_GROUP notification
	//	has not returned.  Return DPNERR_NOTREADY in this case.
	//
	pNTEntry->Lock();
	if (!pNTEntry->IsGroup())
	{
		pNTEntry->Unlock();
		hResultCode = DPNERR_INVALIDGROUP;
		goto Failure;
	}
	if (!pNTEntry->IsCreated())
	{
		if (pNTEntry->IsAvailable())
		{
			hResultCode = DPNERR_NOTREADY;
		}
		else
		{
			hResultCode = DPNERR_INVALIDGROUP;
		}
		pNTEntry->Unlock();
		goto Failure;
	}

	if( pNTEntry->IsAllPlayersGroup() )
	{
		pNTEntry->Unlock();
		DPFERR("Cannot getcontext for the all players group" );
		hResultCode = DPNERR_INVALIDGROUP;
		goto Failure;
	}

	*ppvGroupContext = pNTEntry->GetContext();
	pNTEntry->Unlock();
	pNTEntry->Release();
	pNTEntry = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_RegisterLobby"

STDMETHODIMP DN_RegisterLobby(PVOID pInterface,
							  const DPNHANDLE dpnhLobbyConnection, 
							  IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,
							  const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject;
	HRESULT             hResultCode;

	DPFX(DPFPREP, 3,"Parameters: pInterface [0x%p], pIDP8LobbiedApplication [0x%p], dwFlags [0x%lx]",
			pInterface,pIDP8LobbiedApplication,dwFlags);

	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    	DNASSERT(pdnObject != NULL);

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
    	    if( FAILED( hResultCode = DN_ValidateRegisterLobby( pInterface, dpnhLobbyConnection, pIDP8LobbiedApplication, dwFlags ) ) )
    	    {
    	        DPFERR( "Error validating register lobby params" );
    	        DPF_RETURN( hResultCode );
    	    }
    	}

    	// Check to ensure message handler registered
    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    	{
    		DPFERR( "Object is not initialized" );
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}

	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}	

	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
	DNASSERT(pdnObject != NULL);

	if (dwFlags == DPNLOBBY_REGISTER)
	{
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		if (pdnObject->dwFlags & DN_OBJECT_FLAG_LOBBY_AWARE)
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
			return(DPNERR_ALREADYREGISTERED);
		}
				
		pIDP8LobbiedApplication->lpVtbl->AddRef(pIDP8LobbiedApplication);

		pdnObject->pIDP8LobbiedApplication = pIDP8LobbiedApplication;
		pdnObject->dpnhLobbyConnection = dpnhLobbyConnection;
		pdnObject->dwFlags |= DN_OBJECT_FLAG_LOBBY_AWARE;
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	}
	else
	{
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_LOBBY_AWARE))
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
			return(DPNERR_NOTREGISTERED);
		}
				
		pdnObject->pIDP8LobbiedApplication->lpVtbl->Release(pdnObject->pIDP8LobbiedApplication);
		pdnObject->dpnhLobbyConnection = NULL;
		pdnObject->pIDP8LobbiedApplication = NULL;
		pdnObject->dwFlags &= (~DN_OBJECT_FLAG_LOBBY_AWARE);
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	}

	return(DPN_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNNotifyLobbyClientOfSettings"
// 
// DNNotifyLobbyClientOfSettings
//
// This function sends a connection settings update to the lobby client informing it that the lobby 
// client settings have changed.  
//
HRESULT DNNotifyLobbyClientOfSettings(
	DIRECTNETOBJECT * const pdnObject,
	IDirectPlay8LobbiedApplication *pdpLobbiedApp, 
	DPNHANDLE dpnConnection, 
	IDirectPlay8Address *pHostAddress, 
	IDirectPlay8Address *pConnectFromAddress )
{
	HRESULT						hResultCode = DPN_OK;
	DPL_CONNECTION_SETTINGS		dplConnectionSettings;
	BOOL						fIsHost = FALSE;
	CPackedBuffer				packBuffer;
	PBYTE						pBuffer = NULL;
	BOOL						fINCriticalSection = FALSE;
	CNameTableEntry				*pNTEntry = NULL;
	DWORD						dwIndex;

	fIsHost = DN_CHECK_LOCALHOST( pdnObject );

	ZeroMemory( &dplConnectionSettings, sizeof( DPL_CONNECTION_SETTINGS ) );
	dplConnectionSettings.dwSize = sizeof( DPL_CONNECTION_SETTINGS );
	dplConnectionSettings.dwFlags = (fIsHost) ? DPLCONNECTSETTINGS_HOST : 0;

	// Lock the object while we make a copy of the app desc.  
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	fINCriticalSection = TRUE;
	
	// Determine the size of buffer
	packBuffer.Initialize(NULL, 0 );
	hResultCode = pdnObject->ApplicationDesc.Pack(&packBuffer,DN_APPDESCINFO_FLAG_SESSIONNAME|DN_APPDESCINFO_FLAG_RESERVEDDATA|
			DN_APPDESCINFO_FLAG_APPRESERVEDDATA);

	if( hResultCode != DPNERR_BUFFERTOOSMALL ) 
	{
		DPFX(DPFPREP,  0, "Error getting app desc size hr=0x%x", hResultCode );
		goto NOTIFY_EXIT;
	}

	pBuffer = new BYTE[packBuffer.GetSizeRequired()];

	if( !pBuffer )
	{
		DPFX(DPFPREP,  0, "Error allocating memory for buffer" );
		hResultCode = DPNERR_OUTOFMEMORY;
		goto NOTIFY_EXIT;
	}

	packBuffer.Initialize(pBuffer,packBuffer.GetSizeRequired());
	hResultCode = pdnObject->ApplicationDesc.Pack(&packBuffer,DN_APPDESCINFO_FLAG_SESSIONNAME|DN_APPDESCINFO_FLAG_RESERVEDDATA|
			DN_APPDESCINFO_FLAG_APPRESERVEDDATA);

	if( FAILED( hResultCode ) )
	{
		DPFX(DPFPREP,  0, "Error packing app desc hr=0x%x", hResultCode );
		goto NOTIFY_EXIT;
	}

	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	fINCriticalSection = FALSE;

	memcpy( &dplConnectionSettings.dpnAppDesc, pBuffer, sizeof( DPN_APPLICATION_DESC ) );

	hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pNTEntry );

	if( FAILED( hResultCode ) )
	{
		DPFX(DPFPREP,  0, "Error getting local player hr=0x%x", hResultCode );
		goto NOTIFY_EXIT;
	}

	// Make sure player name isn't changed while we are working with the entry
	pNTEntry->Lock();
	if( pNTEntry->GetName() )
	{
		dplConnectionSettings.pwszPlayerName = new WCHAR[wcslen(pNTEntry->GetName())+1];

		if( !dplConnectionSettings.pwszPlayerName )
		{
			pNTEntry->Unlock();
			DPFX(DPFPREP,  0, "Error allocating memory" );
			goto NOTIFY_EXIT;
		}
		
		wcscpy( dplConnectionSettings.pwszPlayerName, pNTEntry->GetName() );
	}
	else
	{
		dplConnectionSettings.pwszPlayerName = NULL;		
	}
	pNTEntry->Unlock();

	// Release our reference
	pNTEntry->Release();

	// Host address field
	if( fIsHost )
	{
		dplConnectionSettings.pdp8HostAddress = NULL;

		hResultCode = DNGetHostAddressHelper( pdnObject, dplConnectionSettings.ppdp8DeviceAddresses, &dplConnectionSettings.cNumDeviceAddresses );

		if( hResultCode != DPNERR_BUFFERTOOSMALL )
		{
			dplConnectionSettings.cNumDeviceAddresses = 0;
			DPFX(DPFPREP,  0, "Could not get host addresses for lobby update hr=0x%x", hResultCode );
			goto NOTIFY_EXIT;
		}

		dplConnectionSettings.ppdp8DeviceAddresses = new IDirectPlay8Address*[dplConnectionSettings.cNumDeviceAddresses];

		if( !dplConnectionSettings.ppdp8DeviceAddresses )
		{
			DPFX(DPFPREP,  0, "Error allocating memory" );
			dplConnectionSettings.cNumDeviceAddresses = 0;
			hResultCode = DPNERR_OUTOFMEMORY;
			goto NOTIFY_EXIT;
		}

		hResultCode = DNGetHostAddressHelper( pdnObject, dplConnectionSettings.ppdp8DeviceAddresses, &dplConnectionSettings.cNumDeviceAddresses );

		if( FAILED( hResultCode ) )
		{
			dplConnectionSettings.cNumDeviceAddresses = 0;
			DPFX(DPFPREP,  0, "Could not get host addresses for lobby update hr=0x%x", hResultCode );
			goto NOTIFY_EXIT;
		}
	}
	else
	{
		dplConnectionSettings.pdp8HostAddress = pHostAddress;
		dplConnectionSettings.ppdp8DeviceAddresses = &pConnectFromAddress;
		dplConnectionSettings.cNumDeviceAddresses = 1;	
	}

	// Update the settings
	hResultCode = pdpLobbiedApp->lpVtbl->SetConnectionSettings( pdpLobbiedApp, dpnConnection, &dplConnectionSettings, 0 );

NOTIFY_EXIT:

	if( dplConnectionSettings.ppdp8DeviceAddresses && fIsHost )
	{
		for( dwIndex = 0; dwIndex < dplConnectionSettings.cNumDeviceAddresses; dwIndex++ )
		{
			dplConnectionSettings.ppdp8DeviceAddresses[dwIndex]->lpVtbl->Release( dplConnectionSettings.ppdp8DeviceAddresses[dwIndex] );
		}

		delete [] dplConnectionSettings.ppdp8DeviceAddresses;
	}

	if( dplConnectionSettings.pwszPlayerName )
		delete [] dplConnectionSettings.pwszPlayerName;

	if( fINCriticalSection ) 
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	if( pBuffer )
		delete [] pBuffer;

	return hResultCode;

}


#undef DPF_MODNAME
#define DPF_MODNAME "DNUpdateLobbyStatus"

HRESULT DNUpdateLobbyStatus(DIRECTNETOBJECT *const pdnObject,
							const DWORD dwStatus)
{
	HRESULT		hResultCode;
	IDirectPlay8LobbiedApplication	*pIDP8LobbiedApplication;
	DPNHANDLE dpnhLobbyConnection = NULL;
	IDirectPlay8Address *pHostAddress = NULL;
	IDirectPlay8Address *pConnectFromAddress = NULL;

	DPFX(DPFPREP, 4,"Parameters: dwStatus [0x%lx]",dwStatus);

	DNASSERT(pdnObject != NULL);

	pIDP8LobbiedApplication = NULL;

	//
	//	Get lobbied application interface, if it exists and other settings we need
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if ((pdnObject->dwFlags & DN_OBJECT_FLAG_LOBBY_AWARE) && (pdnObject->pIDP8LobbiedApplication))
	{
		pdnObject->pIDP8LobbiedApplication->lpVtbl->AddRef(pdnObject->pIDP8LobbiedApplication);
		pIDP8LobbiedApplication = pdnObject->pIDP8LobbiedApplication;
		dpnhLobbyConnection = pdnObject->dpnhLobbyConnection;

		pConnectFromAddress = pdnObject->pIDP8ADevice;
		pHostAddress = pdnObject->pConnectAddress;

		if( pConnectFromAddress )
		{
			pConnectFromAddress->lpVtbl->AddRef( pConnectFromAddress );			
		}

		if( pHostAddress )
		{
			pHostAddress->lpVtbl->AddRef( pHostAddress );
		}
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Update status and release object
	//
	if (pIDP8LobbiedApplication)
	{
		// If we are about to do a connection notification
		// we send the updated connection settings.  
		// 
		// This gives lobby client full picture. 
		//
		if( dwStatus == DPLSESSION_CONNECTED )
		{
			DNNotifyLobbyClientOfSettings(pdnObject, pIDP8LobbiedApplication, dpnhLobbyConnection, pHostAddress, pConnectFromAddress );
		}

		pIDP8LobbiedApplication->lpVtbl->UpdateStatus(pIDP8LobbiedApplication,dpnhLobbyConnection,dwStatus,0);

		pIDP8LobbiedApplication->lpVtbl->Release(pIDP8LobbiedApplication);
		pIDP8LobbiedApplication = NULL;

		if( pHostAddress )
		{
			pHostAddress->lpVtbl->Release( pHostAddress );
		}		

		if( pConnectFromAddress )
		{
			pConnectFromAddress->lpVtbl->Release( pConnectFromAddress );
		}
	}

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}

						
#undef DPF_MODNAME
#define DPF_MODNAME "DN_TerminateSession"

STDMETHODIMP DN_TerminateSession(PVOID pInterface,
								 void *const pvTerminateData,
								 const DWORD dwTerminateDataSize,
								 const DWORD dwFlags)
{
	HRESULT				hResultCode;
	DIRECTNETOBJECT		*pdnObject;
	CRefCountBuffer		*pRefCountBuffer;
	CWorkerJob			*pWorkerJob;
	DN_INTERNAL_MESSAGE_TERMINATE_SESSION	*pMsg;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], pvTerminateData [0x%p], dwTerminateDataSize [%ld], dwFlags [0x%lx]",
			pInterface,pvTerminateData,dwTerminateDataSize,dwFlags);

	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    	DNASSERT(pdnObject != NULL);

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
    	    if( FAILED( hResultCode = DN_ValidateTerminateSession( pInterface, pvTerminateData, dwTerminateDataSize, dwFlags ) ) )
    	    {
    	        DPFERR( "Error validating terminatesession params" );
    	        DPF_RETURN( hResultCode );
    	    }
    	}

    	// Check to ensure message handler registered
    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    	{
    		DPFERR( "Object is not initialized" );
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    	{
    	    DPFERR("You must be connected / hosting to terminate a session" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}	

	pRefCountBuffer = NULL;
	pWorkerJob = NULL;

	if (!DN_CHECK_LOCALHOST(pdnObject))
	{
	    DPFERR( "Object is not session host, cannot destroy players" );
		hResultCode = DPNERR_NOTHOST;
		goto Failure;
	}	

	//
	//	Build terminate message
	//
	if ((hResultCode = RefCountBufferNew(pdnObject,
			sizeof(DN_INTERNAL_MESSAGE_TERMINATE_SESSION) + dwTerminateDataSize,&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not allocate RefCountBuffer");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_TERMINATE_SESSION*>(pRefCountBuffer->GetBufferAddress());
	if (dwTerminateDataSize)
	{
		memcpy(pMsg+1,pvTerminateData,dwTerminateDataSize);
		pMsg->dwTerminateDataOffset = sizeof(DN_INTERNAL_MESSAGE_TERMINATE_SESSION);
	}
	else
	{
		pMsg->dwTerminateDataOffset = 0;
	}
	pMsg->dwTerminateDataSize = dwTerminateDataSize;

	//
	//	Worker job to send message to all players
	//
	if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
	{
		DPFERR("Could not allocate new WorkerJob");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION );
	pWorkerJob->SetSendNameTableOperationMsgId( DN_MSG_INTERNAL_TERMINATE_SESSION );
	pWorkerJob->SetSendNameTableOperationVersion( 0 );
	pWorkerJob->SetSendNameTableOperationDPNIDExclude( 0 );
	pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

	DNQueueWorkerJob(pdnObject,pWorkerJob);
	pWorkerJob = NULL;

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	//
	//	Terminate local session
	//
	hResultCode = DNUserTerminateSession(pdnObject,
										 DPNERR_HOSTTERMINATEDSESSION,
										 pvTerminateData,
										 dwTerminateDataSize);

	if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
	{
		DPFERR("Could not create WorkerJob");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pWorkerJob->SetJobType( WORKER_JOB_TERMINATE_SESSION );
	pWorkerJob->SetTerminateSessionReason( DPNERR_HOSTTERMINATEDSESSION );

	DNQueueWorkerJob(pdnObject,pWorkerJob);
	pWorkerJob = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	goto Exit;
}

//
//	FUnction that performs work for DN_GetHostAddress and for Lobby informs
//
#undef DPF_MODNAME
#define DPF_MODNAME "DNGetHostAddressHelper"

HRESULT DNGetHostAddressHelper(DIRECTNETOBJECT *pdnObject, 
							   IDirectPlay8Address **const prgpAddress,
							   DWORD *const pcAddress)
{
	CAsyncOp		*pListenParent;
	CAsyncOp		*pListenSP;
	CAsyncOp		*pListen;
	CBilink			*pBilinkSP;
	CBilink			*pBilink;
	DWORD			dwListenCount;
	SPGETADDRESSINFODATA	spInfoData;
	CNameTableEntry			*pLocalPlayer;
	IDirectPlay8Address		**ppAddress;
	HRESULT hResultCode;

	pListenParent = NULL;
	pListenSP = NULL;
	pListen = NULL;	
	pLocalPlayer = NULL;
	
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (	!(pdnObject->dwFlags & DN_OBJECT_FLAG_LISTENING)
		||	!pLocalPlayer->IsHost()
		||	(pdnObject->pListenParent == NULL))

	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		DPFERR("Not listening or Host player");
		hResultCode = DPNERR_NOTHOST;
		goto Failure;
	}
	pdnObject->pListenParent->AddRef();
	pListenParent = pdnObject->pListenParent;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	//
	//	Ensure that the address pointer buffer is large enough
	//
	dwListenCount = 0;
	pListenParent->Lock();	// Prevent changes while we run through
	pBilinkSP = pListenParent->m_bilinkParent.GetNext();
	while (pBilinkSP != &pListenParent->m_bilinkParent)
	{
		pListenSP = CONTAINING_OBJECT(pBilinkSP,CAsyncOp,m_bilinkChildren);

		pListenSP->Lock();

		pBilink = pListenSP->m_bilinkParent.GetNext();
		while (pBilink != &pListenSP->m_bilinkParent)
		{
			dwListenCount++;
			pBilink = pBilink->GetNext();
		}

		pListenSP->Unlock();
		pListenSP = NULL;

		pBilinkSP = pBilinkSP->GetNext();
	}

	if (dwListenCount > *pcAddress)
	{
		pListenParent->Unlock();
		*pcAddress = dwListenCount;
		hResultCode = DPNERR_BUFFERTOOSMALL;
		goto Failure;
	}

	//
	//	Get addresses of LISTENs
	//

	ppAddress = prgpAddress;
	dwListenCount = 0;
	pBilinkSP = pListenParent->m_bilinkParent.GetNext();
	while (pBilinkSP != &pListenParent->m_bilinkParent)
	{
		pListenSP = CONTAINING_OBJECT(pBilinkSP,CAsyncOp,m_bilinkChildren);

		pListenSP->Lock();

		pBilink = pListenSP->m_bilinkParent.GetNext();
		while (pBilink != &pListenSP->m_bilinkParent)
		{
			pListen = CONTAINING_OBJECT(pBilink,CAsyncOp,m_bilinkChildren);

			if (pListen->GetProtocolHandle() != NULL)
			{
				spInfoData.hEndpoint = pListen->GetProtocolHandle();
				spInfoData.Flags = SP_GET_ADDRESS_INFO_LISTEN_HOST_ADDRESSES;
				pListen = NULL;
				if ((hResultCode = DNPGetListenAddressInfo(spInfoData.hEndpoint,&spInfoData)) != DPN_OK)
				{
					DPFERR("Could not get LISTEN address - ignore and continue");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					pBilink = pBilink->GetNext();
					continue;
				}
				*ppAddress++ = spInfoData.pAddress;
				dwListenCount++;
			}

			pBilink = pBilink->GetNext();
		}

		pListenSP->Unlock();
		pListenSP = NULL;

		pBilinkSP = pBilinkSP->GetNext();
	}
	pListenParent->Unlock();

	*pcAddress = dwListenCount;

	hResultCode = DPN_OK;

	pListenParent->Release();
	pListenParent = NULL;

Exit:
	DPF_RETURN(hResultCode);

Failure:
	if (pListenParent)
	{
		pListenParent->Release();
		pListenParent = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
	
}

//
//	DN_GetHostAddress
//
//	We will determine the host addresses by examining the LISTENs which are running.
//	We do this because after Host migration, we may not be running the same LISTEN
//	we started with.

#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetHostAddress"

STDMETHODIMP DN_GetHostAddress(PVOID pInterface,
							   IDirectPlay8Address **const prgpAddress,
							   DWORD *const pcAddress,
							   const DWORD dwFlags)
{
	HRESULT			hResultCode;
	DIRECTNETOBJECT	*pdnObject;

	DPFX(DPFPREP, 3,"Parameters: pInterface [0x%p], prgpAddress [0x%p], pcAddress [0x%p], dwFlags [0x%lx]",
			pInterface,prgpAddress,pcAddress,dwFlags);

	TRY
	{
    	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
    	DNASSERT(pdnObject != NULL);

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_PARAMVALIDATION )
    	{
    	    if( FAILED( hResultCode = DN_ValidateGetHostAddress( pInterface, prgpAddress, pcAddress, dwFlags ) ) )
    	    {
    	        DPFERR( "Error validating gethostaddress params" );
    	        DPF_RETURN( hResultCode );
    	    }
    	}

    	// Check to ensure message handler registered
    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
    	{
    		DPFERR( "Object is not initialized" );
    		DPF_RETURN(DPNERR_UNINITIALIZED);
    	}

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    	{
    	    DPFERR("You must be connected / hosting to get host address" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}	
	}
	EXCEPT(EXCEPTION_EXECUTE_HANDLER)
	{
	    DPFERR("Invalid object" );
	    DPF_RETURN(DPNERR_INVALIDOBJECT);
	}	

	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
	DNASSERT(pdnObject != NULL);

	// Actually do the work and get the addresses  
	hResultCode = DNGetHostAddressHelper( pdnObject, prgpAddress, pcAddress );

	DPF_RETURN(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNRegisterWithDPNSVR"

HRESULT DNRegisterWithDPNSVR(DIRECTNETOBJECT *const pdnObject)
{
	DPFX(DPFPREP, 6,"Parameters: (none)");

	HRESULT		hResultCode;
	CAsyncOp	*pListenParent;

	hResultCode = DPNERR_GENERIC;
	pListenParent = NULL;

	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->pListenParent)
	{
		pdnObject->pListenParent->AddRef();
		pListenParent = pdnObject->pListenParent;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	if (pListenParent)
	{
		BOOL		fCoUninitialize = FALSE;
		CBilink		*pBilinkSP;
		CBilink		*pBilink;
		CAsyncOp	*pListenSP;
		CAsyncOp	*pAsyncOp;
		CAsyncOp	**ListenList;
		DWORD		dwCount;
		DWORD		dwActual;

		if (SUCCEEDED(COM_CoInitialize(NULL)))
		{
			fCoUninitialize = TRUE;
		}

		dwCount = 0;
		dwActual = 0;
		ListenList = NULL;

		pListenParent->Lock();

		pBilinkSP = pListenParent->m_bilinkParent.GetNext();
		while (pBilinkSP != &pListenParent->m_bilinkParent)
		{
			pListenSP = CONTAINING_OBJECT(pBilinkSP,CAsyncOp,m_bilinkChildren);
			pListenSP->Lock();

			pBilink = pListenSP->m_bilinkParent.GetNext();
			while (pBilink != &pListenSP->m_bilinkParent)
			{
				dwCount++;
				pBilink = pBilink->GetNext();
			}
			pListenSP->Unlock();

			pBilinkSP = pBilinkSP->GetNext();
		}

		if (dwCount > 0)
		{
			if ((ListenList = static_cast<CAsyncOp**>(DNMalloc(dwCount*sizeof(CAsyncOp*)))) != NULL)
			{
				pBilinkSP = pListenParent->m_bilinkParent.GetNext();
				while (pBilinkSP != &pListenParent->m_bilinkParent)
				{
					pListenSP = CONTAINING_OBJECT(pBilinkSP,CAsyncOp,m_bilinkChildren);
					pListenSP->Lock();

					pBilink = pListenSP->m_bilinkParent.GetNext();
					while (pBilink != &pListenSP->m_bilinkParent)
					{
						pAsyncOp = CONTAINING_OBJECT(pBilink,CAsyncOp,m_bilinkChildren);
						pAsyncOp->AddRef();
						ListenList[dwActual] = pAsyncOp;

						dwActual++;
						if (dwActual > dwCount)
						{
							DNASSERT(FALSE);
							break;
						}
						pBilink = pBilink->GetNext();
					}
					pListenSP->Unlock();
					pBilinkSP = pBilinkSP->GetNext();
				}
			}
		}

		pListenParent->Unlock();

		if ((ListenList != NULL) && (dwActual > 0))
		{
			DWORD	dw;

			for (dw = 0 ; dw < dwActual ; dw++)
			{
				if (ListenList[dw]->GetProtocolHandle() != 0)
				{
					if (DNRegisterListenWithDPNSVR(pdnObject,ListenList[dw]->GetProtocolHandle()) == DPN_OK)
					{
						hResultCode = DPN_OK;
					}
				}

				ListenList[dw]->Release();
				ListenList[dw] = NULL;
			}

			DNFree(ListenList);
			ListenList = NULL;
		}

		if (fCoUninitialize)
		{
			COM_CoUninitialize();
		}

		pListenParent->Release();
		pListenParent = NULL;
	}

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNRegisterListenWithDPNSVR"

HRESULT DNRegisterListenWithDPNSVR(DIRECTNETOBJECT *const pdnObject,
								   const HANDLE hProtocol)
{
	HRESULT	hResultCode;
	DWORD	dwRetry;
	SPGETADDRESSINFODATA	spInfo;
#ifdef	DEBUG
	CHAR	DP8ABuffer[512];
	DWORD	DP8ASize;
#endif

	DPFX(DPFPREP, 6,"Parameters: hProtocol [0x%lx]",hProtocol);

	//
	//	Determine the address we're actually listening on
	//
	spInfo.hEndpoint = hProtocol;
	spInfo.pAddress = NULL;
	spInfo.Flags = SP_GET_ADDRESS_INFO_LOCAL_ADAPTER;
	if ((hResultCode = DNPGetListenAddressInfo(hProtocol,&spInfo)) == DPN_OK)
	{
		DNASSERT(spInfo.pAddress != NULL);
#ifdef	DEBUG
		DP8ASize = 512;
		spInfo.pAddress->lpVtbl->GetURLA(spInfo.pAddress,DP8ABuffer,&DP8ASize);
		DPFX(DPFPREP, 7,"Listen address [%s]",DP8ABuffer);
#endif

		//
		//	We re-try the registration to catch the case where DPNSVR is shutting
		//	down while we are trying to register.  Unlikely but has to be handled.
		//
		for( dwRetry = 0; dwRetry < DPNSVR_REGISTER_ATTEMPTS ; dwRetry ++ )
		{
    		if ((hResultCode = pdnObject->ApplicationDesc.RegisterWithDPNSVR( spInfo.pAddress )) == DPN_OK)
			{
				//
				//	Flag registering with DPNSVR for cleanup
				//
				DNEnterCriticalSection(&pdnObject->csDirectNetObject);
				pdnObject->dwFlags |= DN_OBJECT_FLAG_DPNSVR_REGISTERED;
				DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
				break;
			}
			else
			{
    			if( dwRetry < DPNSVR_REGISTER_ATTEMPTS )
    			{
	    			DPFX(DPFPREP,  0, "Unable to register ourselves with DPNSVR hr=0x%x, retrying", hResultCode );    				
	    			Sleep( DPNSVR_REGISTER_SLEEP );    				
	    		}
				else
    			{
	    			DPFX(DPFPREP,  0, "Unable to register ourselves with DPNSVR hr=0x%x", hResultCode );
	    		}
	    	}
		}
		spInfo.pAddress->lpVtbl->Release(spInfo.pAddress);
		spInfo.pAddress = NULL;
	}

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_DumpNameTable"

STDMETHODIMP DN_DumpNameTable(PVOID pInterface,char *const Buffer)
{
	DIRECTNETOBJECT	*pdnObject;

	DNASSERT(pInterface != NULL);
	DNASSERT(Buffer != NULL);

	pdnObject = static_cast<DIRECTNETOBJECT*>(GET_OBJECT_FROM_INTERFACE(pInterface));
	DNASSERT(pdnObject != NULL);

	pdnObject->NameTable.DumpNameTable(Buffer);

#if 0
	//
	//	TEMP - for test purposes only
	//
/*	REMOVE start */
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED)
	{
		if (pdnObject->NameTable.GetLocalPlayer()->GetDPNID() == (DPNID)0x400004)
		{
			CNameTableEntry	*pNTEntry = NULL;

			if (pdnObject->NameTable.FindEntry(0x300003,&pNTEntry) == DPN_OK)
			{
				pNTEntry->GetConnection()->Disconnect();
				pNTEntry->Release();
				pNTEntry = NULL;
			}
		}
	}
/*	REMOVE end */
#endif
	return(DPN_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNAddRefLock"

HRESULT DNAddRefLock(DIRECTNETOBJECT *const pdnObject)
{
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if ((pdnObject->dwFlags & (DN_OBJECT_FLAG_CLOSING | DN_OBJECT_FLAG_DISCONNECTING)) ||
			!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		return(DPNERR_ALREADYCLOSING);
	}
	pdnObject->dwLockCount++;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	return(DPN_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNDecRefLock"

void DNDecRefLock(DIRECTNETOBJECT *const pdnObject)
{
	BOOL	fSetEvent;

	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->dwLockCount--;
	if ((pdnObject->dwLockCount == 0) && (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING))
	{
		fSetEvent = TRUE;
	}
	else
	{
		fSetEvent = FALSE;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	if (fSetEvent)
	{
		SetEvent(pdnObject->hLockEvent);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\client.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Client.h
 *  Content:    DirectNet Client interface header file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/21/99	mjn		Created
 *	10/08/99	jtk		Split from DNCore.h
 *	12/03/99	jtk		Moved COM interface definitions to DNet.h
 *	02/15/00	mjn		Implement INFO flags in SetClientInfo
 *	04/06/00	mjn		Added GetServerAddress to API
 *	04/19/00	mjn		Send API call accepts a range of DPN_BUFFER_DESCs and a count
 *	06/23/00	mjn		Removed dwPriority from Send() API call
 *	06/27/00	mjn		Added DN_ClientConnect() (without pvPlayerContext)
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__CLIENT_H__
#define	__CLIENT_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// VTable for client interface
//
extern IDirectPlay8ClientVtbl DN_ClientVtbl;

//**********************************************************************
// Function prototypes
//**********************************************************************

//
// DirectNet - IDirectNetClient
//

STDMETHODIMP DN_ClientConnect(IDirectPlay8Client *pInterface,
							  const DPN_APPLICATION_DESC *const pdnAppDesc,
							  IDirectPlay8Address *const pHostAddr,
							  IDirectPlay8Address *const pDeviceInfo,
							  const DPN_SECURITY_DESC *const pdnSecurity,
							  const DPN_SECURITY_CREDENTIALS *const pdnCredentials,
							  const void *const pvUserConnectData,
							  const DWORD dwUserConnectDataSize,
							  void *const pvAsyncContext,
							  DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags);

STDMETHODIMP DN_Send( IDirectPlay8Client *pInterface,
					  const DPN_BUFFER_DESC *const prgBufferDesc,
					  const DWORD cBufferDesc,
					  const DWORD dwTimeOut,
					  void *const pvAsyncContext,
					  DPNHANDLE *const phAsyncHandle,
					  const DWORD dwFlags);

STDMETHODIMP DN_SetClientInfo(IDirectPlay8Client *pInterface,
							  const DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  PVOID const pvAsyncContext,
							  DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags);

STDMETHODIMP DN_GetServerInfo(IDirectPlay8Client *pInterface,
							  DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  DWORD *const pdwSize,
							  const DWORD dwFlags);

STDMETHODIMP DN_GetHostSendQueueInfo(IDirectPlay8Client *pInterface,
									 DWORD *const lpdwNumMsgs,
									 DWORD *const lpdwNumBytes,
									 const DWORD dwFlags );

STDMETHODIMP DN_GetServerAddress(IDirectPlay8Client *pInterface,
								 IDirectPlay8Address **const ppAddress,
								 const DWORD dwFlags);


#endif	// __CLIENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\connection.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Connection.h
 *  Content:    Connection Object Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/29/00	mjn		Created
 *	04/08/00	mjn		Added ServiceProvider to Connection object
 *	04/18/00	mjn		CConnection tracks connection status better
 *	06/22/00	mjn		Replaced MakeConnecting(), MakeConnected(), MakeDisconnecting(), MakeInvalid() with SetStatus()
 *	07/20/00	mjn		Modified CConnection::Disconnect()
 *	07/28/00	mjn		Added send queue info structures
 *				mjn		Added m_bilinkConnections to CConnection
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/09/00	mjn		Added m_bilinkIndicated to CConnection
 *	02/12/01	mjn		Added m_bilinkCallbackThreads,m_dwThreadCount,m_pThreadEvent to track threads using m_hEndPt
 *	05/17/01	mjn		Remove unused flags
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__CONNECTION_H__
#define	__CONNECTION_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_CORE

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	CONNECTION_FLAG_LOCAL			0x00000001

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

template< class CConnection > class CLockedContextClassFixedPool;

typedef enum {
	INVALID,
	CONNECTING,
	CONNECTED,
	DISCONNECTING
} CONNECTION_STATUS;

typedef struct _USER_SEND_QUEUE_INFO
{
	DWORD	dwNumOutstanding;
	DWORD	dwBytesOutstanding;
} USER_SEND_QUEUE_INFO;

class CCallbackThread;
class CServiceProvider;
class CSyncEvent;

typedef struct _DIRECTNETOBJECT DIRECTNETOBJECT;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for RefCount buffer

class CConnection
{
public:
	CConnection()				// Constructor
		{
			m_Sig[0] = 'C';
			m_Sig[1] = 'O';
			m_Sig[2] = 'N';
			m_Sig[3] = 'N';
		};

	~CConnection() { };			// Destructor

	BOOL FPMAlloc(void *const pvContext)
		{
			if (!DNInitializeCriticalSection(&m_cs))
			{
				return(FALSE);
			}
			DebugSetCriticalSectionRecursionCount(&m_cs,0);
			m_pdnObject = static_cast<DIRECTNETOBJECT*>(pvContext);

			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CConnection::FPMInitialize"
	BOOL FPMInitialize(void *const pvContext)
		{
			DNASSERT(m_pdnObject == pvContext);
			m_dwFlags = 0;
			m_lRefCount = 1;
			m_hEndPt = NULL;
			m_dpnid = 0;
			m_pSP = NULL;
			m_Status = INVALID;
			m_dwThreadCount = 0;
			m_pThreadEvent = NULL;

			//
			//	Queue info
			//
			m_QueueInfoHigh.dwNumOutstanding = 0;
			m_QueueInfoHigh.dwBytesOutstanding = 0;
			m_QueueInfoNormal.dwNumOutstanding = 0;
			m_QueueInfoNormal.dwBytesOutstanding = 0;
			m_QueueInfoLow.dwNumOutstanding = 0;
			m_QueueInfoLow.dwBytesOutstanding = 0;

			m_bilinkConnections.Initialize();
			m_bilinkIndicated.Initialize();
			m_bilinkCallbackThreads.Initialize();

			return(TRUE);
		};

	void FPMRelease(void *const pvContext) { };

	void FPMDealloc(void *const pvContext)
		{
			DNDeleteCriticalSection(&m_cs);
		};

	void CConnection::ReturnSelfToPool( void );

	#undef DPF_MODNAME
	#define DPF_MODNAME "CConnection::AddRef"
	void AddRef(void)
		{
			LONG	lRefCount;

			DNASSERT(m_lRefCount > 0);
			lRefCount = InterlockedIncrement(const_cast<LONG*>(&m_lRefCount));
			DPFX(DPFPREP, 3,"Connection::AddRef [0x%p] RefCount [0x%lx]",this,lRefCount);
		};

	void CConnection::Release(void);

	void Lock( void )
		{
			DNEnterCriticalSection( &m_cs );
		};

	void Unlock( void )
		{
			DNLeaveCriticalSection( &m_cs );
		};

	void SetEndPt(const HANDLE hEndPt)
		{
			m_hEndPt = hEndPt;
		};

	HRESULT CConnection::GetEndPt(HANDLE *const phEndPt,CCallbackThread *const pCallbackThread);

	void CConnection::ReleaseEndPt(CCallbackThread *const pCallbackThread);

	void SetStatus( const CONNECTION_STATUS status )
		{
			m_Status = status;
		};

	BOOL IsConnecting( void )
		{
			if (m_Status == CONNECTING)
				return( TRUE );

			return( FALSE );
		};

	BOOL IsConnected( void )
		{
			if (m_Status == CONNECTED)
				return( TRUE );

			return( FALSE );
		};

	BOOL IsDisconnecting( void )
		{
			if (m_Status == DISCONNECTING)
				return( TRUE );

			return( FALSE );
		};

	BOOL IsInvalid( void )
		{
			if (m_Status == INVALID)
				return( TRUE );

			return( FALSE );
		};

	void SetDPNID(const DPNID dpnid)
		{
			m_dpnid = dpnid;
		};

	DPNID GetDPNID(void)
		{
			return(m_dpnid);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CConnection::MakeLocal"
	void MakeLocal(void)
		{
			DNASSERT(m_hEndPt == NULL);
			m_dwFlags |= CONNECTION_FLAG_LOCAL;
		};

	BOOL IsLocal(void)
		{
			if (m_dwFlags & CONNECTION_FLAG_LOCAL)
				return(TRUE);
				
			return(FALSE);
		};

	void CConnection::SetSP( CServiceProvider *const pSP );

	CServiceProvider *GetSP( void )
		{
			return( m_pSP );
		};

	void SetThreadCount( const DWORD dwCount )
		{
			m_dwThreadCount = dwCount;
		};

	void SetThreadEvent( CSyncEvent *const pSyncEvent )
		{
			m_pThreadEvent = pSyncEvent;
		};

	void CConnection::Disconnect(void);

	void CConnection::AddToHighQueue( const DWORD dwBytes )
		{
			m_QueueInfoHigh.dwNumOutstanding++;
			m_QueueInfoHigh.dwBytesOutstanding += dwBytes;
		};

	void CConnection::AddToNormalQueue( const DWORD dwBytes )
		{
			m_QueueInfoNormal.dwNumOutstanding++;
			m_QueueInfoNormal.dwBytesOutstanding += dwBytes;
		};

	void CConnection::AddToLowQueue( const DWORD dwBytes )
		{
			m_QueueInfoLow.dwNumOutstanding++;
			m_QueueInfoLow.dwBytesOutstanding += dwBytes;
		};

	void CConnection::RemoveFromHighQueue( const DWORD dwBytes )
		{
			m_QueueInfoHigh.dwNumOutstanding--;
			m_QueueInfoHigh.dwBytesOutstanding -= dwBytes;
		};

	void CConnection::RemoveFromNormalQueue( const DWORD dwBytes )
		{
			m_QueueInfoNormal.dwNumOutstanding--;
			m_QueueInfoNormal.dwBytesOutstanding -= dwBytes;
		};

	void CConnection::RemoveFromLowQueue( const DWORD dwBytes )
		{
			m_QueueInfoLow.dwNumOutstanding--;
			m_QueueInfoLow.dwBytesOutstanding -= dwBytes;
		};

	DWORD CConnection::GetHighQueueNum( void )
		{
			return( m_QueueInfoHigh.dwNumOutstanding );
		};

	DWORD CConnection::GetHighQueueBytes( void )
		{
			return( m_QueueInfoHigh.dwBytesOutstanding );
		};

	DWORD CConnection::GetNormalQueueNum( void )
		{
			return( m_QueueInfoNormal.dwNumOutstanding );
		};

	DWORD CConnection::GetNormalQueueBytes( void )
		{
			return( m_QueueInfoNormal.dwBytesOutstanding );
		};

	DWORD CConnection::GetLowQueueNum( void )
		{
			return( m_QueueInfoLow.dwNumOutstanding );
		};

	DWORD CConnection::GetLowQueueBytes( void )
		{
			return( m_QueueInfoLow.dwBytesOutstanding );
		};

	CBilink				m_bilinkConnections;
	CBilink				m_bilinkIndicated;		// Indicated connections without DPNID's (players entries)
	CBilink				m_bilinkCallbackThreads;

private:
	BYTE				m_Sig[4];

	DWORD	volatile	m_dwFlags;
	LONG	volatile	m_lRefCount;

	HANDLE	volatile	m_hEndPt;
	DPNID				m_dpnid;

	CServiceProvider	*m_pSP;

	CONNECTION_STATUS	m_Status;

	DWORD	volatile	m_dwThreadCount;
	CSyncEvent			*m_pThreadEvent;

	USER_SEND_QUEUE_INFO	m_QueueInfoHigh;
	USER_SEND_QUEUE_INFO	m_QueueInfoNormal;
	USER_SEND_QUEUE_INFO	m_QueueInfoLow;

	DIRECTNETOBJECT		*m_pdnObject;

	DNCRITICAL_SECTION	m_cs;
};

#undef DPF_MODNAME

#endif	// __CONNECTION_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\common.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Common.h
 *  Content:    DirectNet common code header file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	10/08/99	jtk		Created
 *	01/14/00	mjn		Added pvUserContext to DN_Host
 *	01/23/00	mjn		Added DN_DestroyPlayer and DNTerminateSession
 *	01/28/00	mjn		Added DN_ReturnBuffer
 *	02/01/00	mjn		Added DN_GetCaps, DN_SetCaps
 *	02/15/00	mjn		Implement INFO flags in SetInfo and return context in GetInfo
 *	02/17/00	mjn		Implemented GetPlayerContext and GetGroupContext
 *	02/17/00	mjn		Reordered parameters in EnumServiceProviders,EnumHosts,Connect,Host
 *	02/18/00	mjn		Converted DNADDRESS to IDirectPlayAddress8
 *  03/17/00    rmt     Moved caps funcs to caps.h/caps.cpp
 *	04/06/00	mjn		Added DN_GetHostAddress()
 *	04/19/00	mjn		Changed DN_SendTo to accept a range of DPN_BUFFER_DESCs and a count
 *	06/23/00	mjn		Removed dwPriority from DN_SendTo()
 *	06/25/00	mjn		Added DNUpdateLobbyStatus()
 *  07/09/00	rmt		Bug #38323 - RegisterLobby needs a DPNHANDLE parameter.
 *	07/30/00	mjn		Added hrReason to DNTerminateSession()
 *	08/15/00	mjn		Added hProtocol tp DNRegisterWithDPNSVR()
 *	03/30/01	mjn		Changes to prevent multiple loading/unloading of SP's
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__COMMON_H__
#define	__COMMON_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef	struct	_PROTOCOL_ENUM_DATA PROTOCOL_ENUM_DATA;

typedef	struct	_PROTOCOL_ENUM_RESPONSE_DATA PROTOCOL_ENUM_RESPONSE_DATA;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

STDMETHODIMP DN_Initialize(PVOID pInterface,
						   PVOID const pvUserContext,
						   const PFNDPNMESSAGEHANDLER pfn,
						   const DWORD dwFlags);

STDMETHODIMP DN_Close(PVOID pInterface,
					  const DWORD dwFlags);

STDMETHODIMP DN_EnumServiceProviders( PVOID pInterface,
									  const GUID *const pguidServiceProvider,
									  const GUID *const pguidApplication,
									  DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer,
									  DWORD *const pcbEnumData,
									  DWORD *const pcReturned,
									  const DWORD dwFlags );

STDMETHODIMP DN_CancelAsyncOperation(PVOID pvInterface,
									 const DPNHANDLE hAsyncOp,
									 const DWORD dwFlags);

STDMETHODIMP DN_Connect( PVOID pInterface,
						 const DPN_APPLICATION_DESC *const pdnAppDesc,
						 IDirectPlay8Address *const pHostAddr,
						 IDirectPlay8Address *const pDeviceInfo,
						 const DPN_SECURITY_DESC *const pdnSecurity,
						 const DPN_SECURITY_CREDENTIALS *const pdnCredentials,
						 const void *const pvUserConnectData,
						 const DWORD dwUserConnectDataSize,
						 void *const pvPlayerContext,
						 void *const pvAsyncContext,
						 DPNHANDLE *const phAsyncHandle,
						 const DWORD dwFlags);

STDMETHODIMP DN_GetSendQueueInfo(PVOID pInterface,
								 const DPNID dpnid,
								 DWORD *const pdwNumMsgs,
								 DWORD *const pdwNumBytes,
								 const DWORD dwFlags);

STDMETHODIMP DN_GetApplicationDesc(PVOID pInterface,
								   DPN_APPLICATION_DESC *const pAppDescBuffer,
								   DWORD *const pcbDataSize,
								   const DWORD dwFlags);

STDMETHODIMP DN_SetApplicationDesc(PVOID pInterface,
								   const DPN_APPLICATION_DESC *const pdnApplicationDesc,
								   const DWORD dwFlags);

STDMETHODIMP DN_SendTo( PVOID pv,
						const DPNID dpnid,
						const DPN_BUFFER_DESC *const prgBufferDesc,
						const DWORD cBufferDesc,
						const DWORD dwTimeOut,
						void *const pvAsyncContext,
						DPNHANDLE *const phAsyncHandle,
						const DWORD dwFlags);

STDMETHODIMP DN_Host( PVOID pInterface,
					  const DPN_APPLICATION_DESC *const pdnAppDesc,
					  IDirectPlay8Address **const prgpDeviceInfo,
					  const DWORD cDeviceInfo,
					  const DPN_SECURITY_DESC *const pdnSecurity,
					  const DPN_SECURITY_CREDENTIALS *const pdnCredentials,
					  void *const pvPlayerContext,
					  const DWORD dwFlags);

STDMETHODIMP DN_CreateGroup(PVOID pInterface,
							const DPN_GROUP_INFO *const pdpnGroupInfo,
							void *const pvGroupContext,
							void *const pvAsyncContext,
							DPNHANDLE *const phAsyncHandle,
							const DWORD dwFlags);

STDMETHODIMP DN_DestroyGroup(PVOID pInterface,
							 const DPNID dpnidGroup,
							 PVOID const pvAsyncContext,
							 DPNHANDLE *const phAsyncHandle,
							 const DWORD dwFlags);

STDMETHODIMP DN_AddClientToGroup(PVOID pInterface,
								 const DPNID dpnidGroup,
								 const DPNID dpnidClient,
								 PVOID const pvAsyncContext,
								 DPNHANDLE *const phAsyncHandle,
								 const DWORD dwFlags);

STDMETHODIMP DN_RemoveClientFromGroup(PVOID pInterface,
									  const DPNID dpnidGroup,
									  const DPNID dpnidClient,
									  PVOID const pvAsyncContext,
									  DPNHANDLE *const phAsyncHandle,
									  const DWORD dwFlags);

STDMETHODIMP DN_SetGroupInfo( PVOID pv,
							  const DPNID dpnid,
							  DPN_GROUP_INFO *const pdpnGroupInfo,
							  PVOID const pvAsyncContext,
							  DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags);

STDMETHODIMP DN_GetGroupInfo(PVOID pv,
							 const DPNID dpnid,
							 DPN_GROUP_INFO *const pdpnGroupInfo,
							 DWORD *const pdwSize,
							 const DWORD dwFlags);

STDMETHODIMP DN_EnumClientsAndGroups(LPVOID lpv, DPNID *const lprgdpnid, DWORD *const lpcdpnid, const DWORD dwFlags);
STDMETHODIMP DN_EnumGroupMembers(LPVOID lpv,DPNID dpnid, DPNID *const lprgdpnid, DWORD *const lpcdpnid, const DWORD dwFlags);

STDMETHODIMP DN_EnumHosts( PVOID pv,
						   DPN_APPLICATION_DESC *const pApplicationDesc,
                           IDirectPlay8Address *const pAddrHost,
						   IDirectPlay8Address *const pDeviceInfo,
						   PVOID const pUserEnumData,
						   const DWORD dwUserEnumDataSize,
						   const DWORD dwRetryCount,
						   const DWORD dwRetryInterval,
						   const DWORD dwTimeOut,
						   PVOID const pvUserContext,
						   DPNHANDLE *const pAsyncHandle,
						   const DWORD dwFlags );

STDMETHODIMP DN_DestroyPlayer(PVOID pv,
							  const DPNID dnid,
							  const void *const pvDestroyData,
							  const DWORD dwDestroyDataSize,
							  const DWORD dwFlags);

STDMETHODIMP DN_ReturnBuffer(PVOID pv,
							 const DPNHANDLE hBufferHandle,
							 const DWORD dwFlags);

STDMETHODIMP DN_GetPlayerContext(PVOID pv,
								 const DPNID dpnid,
								 PVOID *const ppvPlayerContext,
								 const DWORD dwFlags);

STDMETHODIMP DN_GetGroupContext(PVOID pv,
								const DPNID dpnid,
								PVOID *const ppvGroupContext,
								const DWORD dwFlags);

HRESULT DNTerminateSession(DIRECTNETOBJECT *const pdnObject,
						   const HRESULT hrReason);

STDMETHODIMP DN_RegisterLobby(PVOID pInterface,
							  const DPNHANDLE dpnhLobbyConnection, 
							  IDirectPlay8LobbiedApplication *const pIDP8LobbiedApplication,
							  const DWORD dwFlags);

HRESULT DNUpdateLobbyStatus(DIRECTNETOBJECT *const pdnObject,
							const DWORD dwStatus);

STDMETHODIMP DN_TerminateSession(PVOID pInterface,
								 void *const pvTerminateData,
								 const DWORD dwTerminateDataSize,
								 const DWORD dwFlags);

STDMETHODIMP DN_GetHostAddress(PVOID pInterface,
							   IDirectPlay8Address **const prgpAddress,
							   DWORD *const pcAddress,
							   const DWORD dwFlags);

HRESULT DNRegisterWithDPNSVR(DIRECTNETOBJECT *const pdnObject);

HRESULT DNRegisterListenWithDPNSVR(DIRECTNETOBJECT *const pdnObject,
								   const HANDLE hProtocol);

HRESULT DNAddRefLock(DIRECTNETOBJECT *const pdnObject);

void DNDecRefLock(DIRECTNETOBJECT *const pdnObject);

STDMETHODIMP DN_DumpNameTable(PVOID pInterface,char *const Buffer);

#endif	// __COMMON_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\connect.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Connect.h
 *  Content:    DirectNet connect and disconnect routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	01/11/00	mjn		Created
 *	01/11/00	mjn		Use CPackedBuffers instead of DN_ENUM_BUFFER_INFOs
 *	01/17/00	mjn		Fixed ConnectToPeer function names
 *	01/18/00	mjn		Moved Pack/UnpackNameTableInfo to NameTable.cpp
 *	01/18/00	mjn		Added DNAutoDestructGroups
 *	01/22/00	mjn		Added DNProcessHostDestroyPlayer
 *	03/24/00	mjn		Set player context through INDICATE_CONNECT notification
 *	04/03/00	mjn		Verify DNET version on connect
 *	04/12/00	mjn		Removed DNAutoDestructGroups - covered in NameTable.DeletePlayer()
 *	04/20/00	mjn		Added DNGetClearAddress
 *	05/23/00	mjn		Added DNConnectToPeerFailed()
 *	06/14/00	mjn		Added DNGetLocalAddress()
 *	06/24/00	mjn		Added DNHostDropPlayer()
 *	07/20/00	mjn		Structure changes and new function parameters
 *				mjn		Moved DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO and DN_INTERNAL_MESSAGE_INSTRUCTED_CONNECT_FAILED to message.h
 *	07/30/00	mjn		Renamed DNGetLocalAddress() to DNGetLocalDeviceAddress()
 *	07/31/00	mjn		Added dwDestroyReason to DNHostDisconnect()
 *	10/11/00	mjn		DNAbortConnect() takes HRESULT parameters instead of PVOID
 *	06/07/01	mjn		Added connection parameter to DNConnectToHostFailed()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__CONNECT_H__
#define	__CONNECT_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef struct {
	HRESULT	hResultCode;
} DN_RESULT_CONNECT;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

// DirectNet - Connect routines

HRESULT DNHostConnect1(DIRECTNETOBJECT *const pdnObject,
					   const PVOID pvBuffer,
					   const DWORD dwBufferSize,
					   CConnection *const pConnection);

HRESULT DNHostConnect2(DIRECTNETOBJECT *const pdnObject,
					   CConnection *const pConnection);

HRESULT DNHostVerifyConnect(DIRECTNETOBJECT *const pdnObject,
							CConnection *const pConnection,
							const DWORD dwFlags,
							const DWORD dwDNETVersion,
							UNALIGNED WCHAR *const pwszPassword,
							GUID *const pguidApplication,
							GUID *const pguidInstance,
							PVOID const pvConnectData,
							const DWORD dwConnectDataSize,
							IDirectPlay8Address *const pAddress,
							void **const ppvPlayerContext,
							void **const ppvReplyBuffer,
							DWORD *const pdwReplyBufferSize,
							void **const ppvReplyBufferContext);

HRESULT DNHostDropPlayer(DIRECTNETOBJECT *const pdnObject,
						 const DPNID dpnid,
						 void *const pvBuffer);

HRESULT DNPrepareConnectInfo(DIRECTNETOBJECT *const pdnObject,
							 CConnection *const pConnection,
							 CRefCountBuffer **const ppRefCountBuffer);

HRESULT DNConnectToHost1(DIRECTNETOBJECT *const pdnObject,
						 CConnection *const pConnection);

HRESULT DNConnectToHost2(DIRECTNETOBJECT *const pdnObject,
						 const PVOID pvData,
						 CConnection *const pConnection);

HRESULT	DNConnectToHostFailed(DIRECTNETOBJECT *const pdnObject,
							  PVOID const pvBuffer,
							  const DWORD dwBufferSize,
							  CConnection *const pConnection);

HRESULT DNAbortConnect(DIRECTNETOBJECT *const pdnObject,
					   const HRESULT hrConnect);

HRESULT	DNPlayerConnect1(DIRECTNETOBJECT *const pdnObject,
						 const PVOID pv,
						 CConnection *const pConnection);

HRESULT	DNConnectToPeer1(DIRECTNETOBJECT *const pdnObject,PVOID const pv);
HRESULT DNConnectToPeer2(DIRECTNETOBJECT *const pdnObject,PVOID const pv);

HRESULT	DNConnectToPeer3(DIRECTNETOBJECT *const pdnObject,
						 const DPNID dpnid,
						 CConnection *const pConnection);

HRESULT DNConnectToPeerFailed(DIRECTNETOBJECT *const pdnObject,
							  const DPNID dpnid);

HRESULT	DNSendConnectInfo(DIRECTNETOBJECT *const pdnObject,
						  CNameTableEntry *const pNTEntry,
						  CConnection *const pConnection,
						  void *const pvReplyBuffer,
						  const DWORD dwReplyBufferSize);

HRESULT	DNReceiveConnectInfo(DIRECTNETOBJECT *const pdnObject,
							 void *const pvBuffer,
							 CConnection *const pHostConnection,
							 DPNID *const pdpnid);

HRESULT DNAbortLocalConnect(DIRECTNETOBJECT *const pdnObject);

// DirectNet - Disconnection routines
HRESULT DNLocalDisconnectNew(DIRECTNETOBJECT *const pdnObject);

HRESULT DNPlayerDisconnectNew(DIRECTNETOBJECT *const pdnObject,
							  const DPNID dpnidDisconnecting);

HRESULT DNHostDisconnect(DIRECTNETOBJECT *const pdnObject,
						 const DPNID dpnidDisconnecting,
						 const DWORD dwDestroyReason);

HRESULT DNInstructedDisconnect(DIRECTNETOBJECT *const pdnObject,
							   PVOID pv);

HRESULT DNProcessHostDestroyPlayer(DIRECTNETOBJECT *const pdnObject,void *const pv);

HRESULT DNGetClearAddress(DIRECTNETOBJECT *const pdnObject,
						  const HANDLE hEndPt,
						  IDirectPlay8Address **const ppAddress,
						  const BOOL fPartner);

HRESULT DNGetLocalDeviceAddress(DIRECTNETOBJECT *const pdnObject,
								const HANDLE hEndPt,
								IDirectPlay8Address **const ppAddress);

#endif	// __CONNECT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\coreconnect.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Connect.cpp
 *  Content:    DNET connection routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  09/01/99	mjn		Created
 *  12/23/99	mjn		Hand all NameTable update sends from Host to worker thread
 *	12/23/99	mjn		Fixed Host and AllPlayers short-cut pointer use
 *	12/28/99	mjn		Moved Async Op stuff to Async.h
 *	12/29/99	mjn		Reformed DN_ASYNC_OP to use hParentOp instead of lpvUserContext
 *	12/29/99	mjn		Turned off Instance GUID verification - TODO - turn back on !
 *	01/06/00	mjn		Moved NameTable stuff to NameTable.h
 *	01/07/00	mjn		Moved Misc Functions to DNMisc.h
 *	01/07/00	mjn		DNHostVerifyConnect ensures connection to Host player only
 *	01/08/00	mjn		Failed connection returns HRESULT and buffer from Host
 *	01/08/00	mjn		Added group owner to NameTable
 *	01/08/00	mjn		Changed DNERR_INVALIDHOST to DNERR_NOTHOST
 *	01/08/00	mjn		Removed unused connection info
 *	01/09/00	mjn		Transfer Application Description at connect
 *	01/10/00	mjn		Fixed Application Description usage
 *	01/11/00	mjn		Use CPackedBuffers instead of DN_ENUM_BUFFER_INFOs
 *	01/13/00	mjn		Removed DIRECTNETOBJECT from Pack/UnpackApplicationDesc
 *	01/14/00	mjn		Removed pvUserContext from DN_NAMETABLE_ENTRY
 *	01/14/00	mjn		Added password to DN_APPLICATION_DESC_PACKED_INFO
 *	01/15/00	mjn		Replaced DN_COUNT_BUFFER with CRefCountBuffer
 *	01/16/00	mjn		Moved User callback stuff to User.h
 *	01/17/00	mjn		Fixed ConnectToPeer function names
 *	01/18/00	mjn		Moved Pack/UnpackNameTableInfo to NameTable.cpp
 *	01/24/00	mjn		Replaced on-wire message pointers to offsets
 *	02/01/00	mjn		Implement Player/Group context values
 *	03/23/00	mjn		Set player context through Connect
 *	03/24/00	mjn		Set player context through INDICATE_CONNECT notification
 *	04/03/00	mjn		Verify DNET version on connect
 *	04/09/00	mjn		Modified Connect process to use CAsyncOp
 *	04/16/00	mjn		DNSendMessage() uses CAsyncOp
 *	04/18/00	mjn		CConnection tracks connection status better
 *				mjn		Fixed player count problem
 *				mjn		Return connect user reply buffer
 *	04/19/00	mjn		Fixed DNConnectToHost2 to set DirectNet object flags to CONNECTED
 *				mjn		Update NameTable operations to use DN_WORKER_JOB_SEND_NAMETABLE_OPERATION
 *	04/20/00	mjn		Host queries for connecting players' address if not specified
 *	05/03/00	mjn		Prevent unrequired RETURN_BUFFER message when CONNECT fails on Host player
 *	05/03/00	mjn		Use GetHostPlayerRef() rather than GetHostPlayer()
 *	05/08/00	mjn		Host sets connecting player's Connection as soon as player entry created
 *	05/09/00	mjn		Fixed New Player connection sequence to send NAMETABLE_ACK earlier
 *	05/23/00	mjn		Added DNConnectToPeerFailed()
 *	06/14/00	mjn		Added DNGetLocalAddress()
 *	06/19/00	mjn		Fixed connect process to better handle ALL_ADAPTERS case
 *	06/22/00	mjn		NameTable::UnpackNameTableInfo() returns local players DPNID
 *				mjn		Replace CConnection::MakeConnecting(),MakeConnected() with SetStatus()
 *	06/24/00	mjn		Added DNHostDropPlayer() to handle failed existing player connects to new players
 *	06/25/00	mjn		Added code to update lobby when DISCONNECTED
 *	06/26/00	mjn		Indicate COULDNOTCONNECT to lobby if connect to Host fails
 *	06/27/00	rmt		Added abstraction for COM_Co(Un)Initialize
 *				mjn		Host will attempt to determine connecting player's address if not specified in connect block
 *	07/05/00	mjn		More robust handling of disconnecting joining players during connection process
 *	07/06/00	mjn		More connect fixes
 *	07/20/00	mjn		The CONNECT process was revamped - new completions, asyncop structure, messages
 *				mjn		Better error handling for shutdown in DNHostVerifyConnect()
 *				mjn		Fixed up DNHostDropPlayer() to inform NewPlayer of drop
 *	07/21/00	mjn		Added code to handle unreachable players during connect process
 *	07/22/00	mjn		Extract connecting player's DNET version
 *	07/25/00	mjn		Update connect parent async op's result at end of DNConnectToHost2()
 *	07/27/00	mjn		Fixed locking problem with CAsyncOp::MakeChild()
 *	07/29/00	mjn		Save connection in DNConnectToHost1() on connect parent for better clean up
 *	07/30/00	mjn		Renamed DNGetLocalAddress() to DNGetLocalDeviceAddress()
 *	07/31/00	mjn		Added hrReason to DNTerminateSession()
 *				mjn		Added dwDestroyReason to DNHostDisconnect()
 *	08/02/00	mjn		Removed unused code
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *  08/05/00	rmt		Bug #41356 - DPLAY8: CORE: Connections refused by DPlay leak address objects
 *	08/05/00	mjn		Added pParent to DNSendGroupMessage and DNSendMessage()
 *	08/06/00	mjn		Added CWorkerJob
 *	08/08/00	mjn		Mark groups created after CREATE_GROUP
 *  08/15/00	rmt		Bug #42506 - DPLAY8: LOBBY: Automatic connection settings not being sent
 *	08/25/00	mjn		Perform queued NameTable operations in DNConnectToHost2()
 *	08/28/00	mjn		Only compare major version numbers in DNHostVerifyConnect()
 *	09/04/00	mjn		Added CApplicationDesc
 *	09/05/00	mjn		Set NameTable DPNID mask when connecting
 *	09/13/00	mjn		Perform queued operations after creating group in DNConnectToHost2()
 *	09/17/00	mjn		Split CNameTable.m_bilinkEntries into m_bilinkPlayers and m_bilinkGroups
 *	09/26/00	mjn		Removed locking from CNameTable::SetVersion() and CNameTable::GetNewVersion()
 *	09/27/00	mjn		ACK nametable to Host after creating groups and local and host players
 *	10/11/00	mjn		Fixed up DNAbortConnect() and use it instead of DNConnectToHostFailed()
 *	10/17/00	mjn		Fixed clean up for unreachable players
 *	01/25/01	mjn		Fixed 64-bit alignment problem in received messages
 *	02/12/01	mjn		Fixed CConnection::GetEndPt() to track calling thread
 *	03/30/01	mjn		Changes to prevent multiple loading/unloading of SP's
 *	04/05/01	mjn		Call DNHostDisconnect() with DPNDESTROYPLAYERREASON_NORMAL in DNHostConnect1()
 *	05/07/01	vpo		Whistler 384350: "DPLAY8: CORE: Messages from server can be indicated before connect completes"
 *	05/22/01	mjn		Properly set DirectNetObject as CONNECTED for successful client connect
 *	06/03/01	mjn		Don't clean up connect parent from DirectNetObject in DNAbortConnect() (will be done in DNTerminateSession())
 *	06/08/01	mjn		Disconnect connection in DNConnectToHostFailed()
 *	06/25/01	mjn		Use connect address for host if missing when installing name table in DNConnectToHost2()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//
//	Accept a connection from a NewPlayer as the Host in peer-to-peer, or as the Server in
//	Client-Server modes.
//
//	The connection process is a multi part affair, requiring a bit of
//	synchronization between the Host and the NewPlayer.
//
//	In the first part:
//		The Host waits for the NewPlayer to send player game info
//		The Host verifies that everything is in order
//	If everything is okay:
//		The Host assigns the NewPlayer a DNID,
//		Adds the NewPlayer to the Host's NameTable,
//		Sends the NameTable to the NewPlayer,
//		Sends an ADD_PLAYER message to existing players to add NewPlayer to their NameTable's
//	Otherwise:
//		Inform NewPlayer that connection process failed
//
//	In the second part:
//		The Host awaits confirmation from the NewPlayer that the table was received AND installed.
//		The Host instructs existing players to connect to the NewPlayer
//


//	DNHostConnect1
//
//	Called once the connecting player has sent his player info.
//
//	- Verify NewPlayer and application info
//	- Assign a DNID to NewPlayer
//	- Add NewPlayer to Host's NameTable
//	- Send Name table to NewPlayer
//	- Send ADD_PLAYER message to existing players
//
//		LPVOID				lpvData			Player and application info
//		DWORD				dwBufferSize	Size of player and application info
//		HANDLE				hEndPt			End point handle

#undef DPF_MODNAME
#define DPF_MODNAME "DNHostConnect1"

HRESULT DNHostConnect1(DIRECTNETOBJECT *const pdnObject,
					   const PVOID pvBuffer,
					   const DWORD dwBufferSize,
					   CConnection *const pConnection)
{
	HRESULT		hResultCode;
	UNALIGNED WCHAR	*pwszName;
	UNALIGNED WCHAR	*pwszPassword;
	PVOID		pvData;
	PVOID		pvConnectData;
	UNALIGNED DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO	*pInfo;
	CNameTableEntry		*pNTEntry;
	CNameTableEntry		*pAllPlayersGroup;
	CPackedBuffer		packedBuffer;
	CRefCountBuffer		*pRefCountBuffer;
	CWorkerJob			*pWorkerJob;
	IDirectPlay8Address	*pAddress;
	CPackedBuffer		PackedBuffer;
	void				*pvPlayerContext;
	BOOL		bPlayerVerified;
	BOOL		fDisconnect;
	HANDLE		hEndPt;
	void		*pvReplyBuffer;
	DWORD		dwReplyBufferSize;
	void		*pvReplyBufferContext;
	CCallbackThread		CallbackThread;
#ifdef	DEBUG
	CHAR				DP8ABuffer[512];
	DWORD				DP8ASize;
#endif

	DPFX(DPFPREP, 4,"Parameters: pvBuffer [0x%p], dwBufferSize [%ld], pConnection [0x%p]",pvBuffer,dwBufferSize,pConnection);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvBuffer != NULL);
	DNASSERT(pConnection != NULL);

	pAddress = NULL;
	pRefCountBuffer = NULL;
	pNTEntry = NULL;
	pAllPlayersGroup = NULL;
	pWorkerJob = NULL;
	bPlayerVerified = FALSE;
	pvReplyBuffer = NULL;
	dwReplyBufferSize = 0;
	pvReplyBufferContext = NULL;

	//
	//	Extract player and application info
	//
	pInfo = static_cast<DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO*>(pvBuffer);
	if (pInfo->dwNameOffset)
	{
		pwszName = reinterpret_cast<UNALIGNED WCHAR*>(static_cast<BYTE*>(pvBuffer) + pInfo->dwNameOffset);
	}
	else
	{
		pwszName = NULL;
	}

	if (pInfo->dwPasswordOffset)
	{
		pwszPassword = reinterpret_cast<UNALIGNED WCHAR*>(static_cast<BYTE*>(pvBuffer) + pInfo->dwPasswordOffset);
	}
	else
	{
		pwszPassword = NULL;
	}

	if (pInfo->dwDataOffset)
	{
		pvData = static_cast<void*>(static_cast<BYTE*>(pvBuffer) + pInfo->dwDataOffset);
	}
	else
	{
		pvData = NULL;
	}

	if (pInfo->dwConnectDataOffset)
	{
		pvConnectData = (PVOID)((char *)pvBuffer + pInfo->dwConnectDataOffset);
	}
	else
	{
		pvConnectData = NULL;
	}

	if (pInfo->dwURLOffset)
	{
		if ((hResultCode = COM_CoCreateInstance(CLSID_DirectPlay8Address,
											NULL,
											CLSCTX_INPROC_SERVER,
											IID_IDirectPlay8Address,
											reinterpret_cast<void**>(&pAddress))) != S_OK)
		{
			DPFERR("Could not create IDirectPlay8Address");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			return(hResultCode);
		}

		DPFX(DPFPREP, 5,"Connecting Player URL [%s]",static_cast<char*>(pvBuffer) + pInfo->dwURLOffset);
		if ((hResultCode = pAddress->lpVtbl->BuildFromURLA(	pAddress,
															static_cast<char*>(pvBuffer) + pInfo->dwURLOffset )) != DPN_OK)
		{
			DPFERR("Could not build IDirectPlay8Address");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
	}
	else
	{
		DPFX(DPFPREP, 5,"No address URL specified - Host will have to determine it");
		if ((hResultCode = pConnection->GetEndPt(&hEndPt,&CallbackThread)) != DPN_OK)
		{
			DPFERR("Could not retrieve EndPoint from Connection");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}

		hResultCode = DNGetClearAddress(pdnObject,hEndPt,&pAddress,TRUE);

		pConnection->ReleaseEndPt(&CallbackThread);

		if (hResultCode != DPN_OK)
		{
			DPFERR("Could not determine Clear Address");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
#ifdef	DEBUG
		DP8ASize = 512;
		pAddress->lpVtbl->GetURLA(pAddress,DP8ABuffer,&DP8ASize);
		DPFX(DPFPREP, 5,"Remote Address [%s]",DP8ABuffer);
#endif
	}

#ifdef DEBUG
#ifndef IA64
	if (pwszName != NULL)
	{
		DPFX(DPFPREP, 5,"Connecting Player: Name [%S], Data Size [%ld], Connect Data Size [%ld]",
			pwszName,pInfo->dwDataSize,pInfo->dwConnectDataSize);
	}
	else
	{
		DPFX(DPFPREP, 5,"Connecting Player: No name, Data Size [%ld], Connect Data Size [%ld]",
			pInfo->dwDataSize,pInfo->dwConnectDataSize);
	}
#endif // ! IA64
#endif // DEBUG

	//
	//	Avoid alignment errors
	//
	GUID guidApplication;
	GUID guidInstance;
	guidApplication = pInfo->guidApplication;
	guidInstance = pInfo->guidInstance;

	//
	//	Ensure this connect is valid
	//
	if ((hResultCode = DNHostVerifyConnect(	pdnObject,
											pConnection,
											pInfo->dwFlags,
											pInfo->dwDNETVersion,
											pwszPassword,
											&guidApplication,
											&guidInstance,
											pvConnectData,
											pInfo->dwConnectDataSize,
											pAddress,
											&pvPlayerContext,
											&pvReplyBuffer,
											&dwReplyBufferSize,
											&pvReplyBufferContext)) != DPN_OK)
	{
		DPFX(DPFPREP, 5,"Connect failed, hResultCode = [0x%lx]",hResultCode);

		//
		//	Disconnect this connection.   We will also remove it from the indicated list.
		//
		DNEnterCriticalSection(&pdnObject->csConnectionList);
		if (!pConnection->m_bilinkIndicated.IsEmpty())
		{
			pConnection->Release();
		}
		pConnection->m_bilinkIndicated.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csConnectionList);

		pConnection->Disconnect();	// Terminate this connection

		hResultCode = DPN_OK;	// We handled everything okay !
		goto Failure;			// For clean up
	}

	bPlayerVerified = TRUE;

	//
	//	I am assuming that the player count has been updated by HostVerifyConnect.
	//	That means that until we flag the connection as CONNECTed, we will manually
	//	have to decrement it.
	//

	//
	// Create player entry
	//
	if ((hResultCode = NameTableEntryNew(pdnObject,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not get new NameTableEntry");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	// This function takes the lock internally
	pNTEntry->UpdateEntryInfo(	pwszName,
								pInfo->dwNameSize,
								pvData,
								pInfo->dwDataSize,
								DPNINFO_NAME | DPNINFO_DATA,
								FALSE);

	pNTEntry->SetDNETVersion( pInfo->dwDNETVersion );
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
	{
		pNTEntry->MakePeer();
	}
	else
	{
		pNTEntry->MakeClient();
	}

	if (pvPlayerContext)
	{
		pNTEntry->SetContext(pvPlayerContext);
	}
	pNTEntry->StartConnecting();
	pNTEntry->SetIndicated();
	pNTEntry->NotifyAddRef();
	pNTEntry->SetAddress(pAddress);
	pAddress->lpVtbl->Release(pAddress);
	pAddress = NULL;

	//
	//	Add player to NameTable
	//
	if ((hResultCode = pdnObject->NameTable.AddEntry(pNTEntry)) != DPN_OK)
	{
		pdnObject->NameTable.Unlock();
		DPFERR("Could not add entry to NameTable");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Set up connection
	//	The connection should be "CONNECTING" or a disconnect has been issued since the NewPlayer sent
	//	their connect info.  Once the DPNID is set on the connection, the standard disconnect handler
	//	will take care of clean up.  If the DPNID is NOT set on the connection, the disconnect code
	//	will just release the connection, without cleaning up the NameTable or the NameTableEntry.
	//	Since the NameTable version may have changed since the NewPlayer was added, we will need to
	//	delete the player from the NameTable (and generate a new version number).  We will flag this
	//	case, and just send out the DELETE_PLAYER message after sending out the ADD_PLAYER
	//
	pConnection->Lock();
	if (pConnection->IsConnecting())
	{
		pConnection->SetStatus( CONNECTED );
		fDisconnect = FALSE;
	}
	else
	{
		DPFX(DPFPREP, 5,"NewPlayer has disconnected while joining - send out ADD_PLAYER and then DELETE_PLAYER");
		fDisconnect = TRUE;
	}
	pConnection->SetDPNID( pNTEntry->GetDPNID() );
	pNTEntry->SetConnection( pConnection );
	pConnection->Unlock();

	//
	//	Now that this connection is part of the NameTableEntry, remove it from the indicated list.
	//
	DNEnterCriticalSection(&pdnObject->csConnectionList);
	if (!pConnection->m_bilinkIndicated.IsEmpty())
	{
		pConnection->Release();
	}
	pConnection->m_bilinkIndicated.RemoveFromList();
	DNLeaveCriticalSection(&pdnObject->csConnectionList);

	//
	//	Send name table to player
	//
	if (!fDisconnect)
	{
		hResultCode = DNSendConnectInfo(pdnObject,pNTEntry,pConnection,pvReplyBuffer,dwReplyBufferSize);
		if (hResultCode != DPN_OK && hResultCode != DPNERR_PENDING)
		{
			DPFERR("Could not send name table to player");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
#pragma TODO(minara,"Clean up here")
			goto Failure;
		}
	}
	if (pvReplyBuffer)
	{
		DNUserReturnBuffer(pdnObject,DPN_OK,pvReplyBuffer,pvReplyBufferContext);
		pvReplyBuffer = NULL;
		dwReplyBufferSize = 0;
		pvReplyBufferContext = NULL;
	}

	//
	// Setup name table entry to be passed to other players
	//
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
	{
		packedBuffer.Initialize(NULL,0);
		if ((hResultCode = pNTEntry->PackEntryInfo(&packedBuffer)) != DPNERR_BUFFERTOOSMALL)
		{
			DPFERR("Unknown error encountered trying to pack NameTableEntry");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		if ((hResultCode = RefCountBufferNew(pdnObject,packedBuffer.GetSizeRequired(),&pRefCountBuffer)) != DPN_OK)
		{
			DPFERR("Could not create new RefCountBuffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		packedBuffer.Initialize(pRefCountBuffer->GetBufferAddress(),pRefCountBuffer->GetBufferSize());
		if ((hResultCode = pNTEntry->PackEntryInfo(&packedBuffer)) != DPN_OK)
		{
			DPFERR("Could not pack NameTableEntry");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}

		//
		//	Send ADD_PLAYER messages to other players (with lower versions)
		//
		if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
		{
			DPFERR("Could not create worker thread job (add player)");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION );
		pWorkerJob->SetSendNameTableOperationMsgId( DN_MSG_INTERNAL_ADD_PLAYER );
		pWorkerJob->SetSendNameTableOperationVersion( pNTEntry->GetVersion() );
		pWorkerJob->SetSendNameTableOperationDPNIDExclude( 0 );
		pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

		DNQueueWorkerJob(pdnObject,pWorkerJob);
		pWorkerJob = NULL;

		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}

	//
	//	If we were in the process of disconnecting, we will need to clean up now
	//
	if (fDisconnect)
	{
		DNHostDisconnect(pdnObject,pNTEntry->GetDPNID(),DPNDESTROYPLAYERREASON_NORMAL);
	}

	pNTEntry->Release();
	pNTEntry = NULL;

	// Now, wait for synchronization (player has loaded name table)

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pvReplyBuffer)
	{
		//
		//	Return buffer to HostPlayer
		//
		DNUserReturnBuffer(pdnObject,DPN_OK,pvReplyBuffer,pvReplyBufferContext);
		pvReplyBuffer = NULL;
		dwReplyBufferSize = 0;
		pvReplyBufferContext = NULL;
	}
	if (bPlayerVerified)
	{
		pdnObject->ApplicationDesc.DecPlayerCount();
	}
	if (pAddress)
	{
		pAddress->lpVtbl->Release(pAddress);
		pAddress = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pAllPlayersGroup)
	{
		pAllPlayersGroup->Release();
		pAllPlayersGroup = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}

	goto Exit;
}


//	DNHostConnect2
//
//	Mark player as "available" in NameTable
//	Send INSTRUCT_CONNECT messages to the existing players to add new player
//
//		CConnection		*pConnection		Connection for connecting player
//

#undef DPF_MODNAME
#define DPF_MODNAME "DNHostConnect2"

HRESULT DNHostConnect2(DIRECTNETOBJECT *const pdnObject,
					   CConnection *const pConnection)
{
	HRESULT				hResultCode;
	DPNID				dpnid;
	CRefCountBuffer		*pRefCountBuffer;
	CNameTableEntry		*pNTEntry;
	CWorkerJob			*pWorkerJob;
	DN_INTERNAL_MESSAGE_INSTRUCT_CONNECT	*pInfo;

	DPFX(DPFPREP, 4,"Parameters: pConnection [0x%p]",pConnection);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pConnection != NULL);

	pRefCountBuffer = NULL;
	pNTEntry = NULL;
	pWorkerJob = NULL;

	pConnection->Lock();
	dpnid = pConnection->GetDPNID();
	pConnection->Unlock();

	pdnObject->NameTable.PopulateConnection(pConnection);

	//
	// Instruct existing players to connect to NewPlayer
	//
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
	{
		DPFX(DPFPREP, 5,"Instruct existing players to connect to NewPlayer [0x%lx]",dpnid);

		// Need version number of this player
		if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
		{
			DPFERR("Could not find player in nametable");
			DisplayDNError(0,hResultCode);
//			DNASSERT(FALSE);
			goto Failure;
		}

		if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_INSTRUCT_CONNECT),
				&pRefCountBuffer)) != DPN_OK)
		{
			DPFERR("Could not create CountBuffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pInfo = reinterpret_cast<DN_INTERNAL_MESSAGE_INSTRUCT_CONNECT*>(pRefCountBuffer->GetBufferAddress());
		pInfo->dpnid = dpnid;

		pdnObject->NameTable.WriteLock();
		pdnObject->NameTable.GetNewVersion( &pInfo->dwVersion );
		pdnObject->NameTable.Unlock();
		pInfo->dwVersionNotUsed = 0;

		if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
		{
			DPFERR("Could not create worker thread job (add player)");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION );
		pWorkerJob->SetSendNameTableOperationMsgId( DN_MSG_INTERNAL_INSTRUCT_CONNECT );
		pWorkerJob->SetSendNameTableOperationVersion( pInfo->dwVersion );
		pWorkerJob->SetSendNameTableOperationDPNIDExclude( 0 );
		pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

		DNQueueWorkerJob(pdnObject,pWorkerJob);
		pWorkerJob = NULL;

		pNTEntry->Release();
		pNTEntry = NULL;

		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


//	DNHostVerifyConnect
//
//	Host connection verification.  Ensure that the player connecting meets ALL criteria
//	including:
//		correct mode (client/server or peer/peer)
//		correct instance guid
//		correct application (if specified)
//		correct password (if specified)
//		correct user spec (through call-back)
//

#undef DPF_MODNAME
#define DPF_MODNAME "DNHostVerifyConnect"

HRESULT DNHostVerifyConnect(DIRECTNETOBJECT *const pdnObject,
							CConnection *const pConnection,
							const DWORD dwFlags,
							const DWORD dwDNETVersion,
							UNALIGNED WCHAR *const pwszPassword,
							GUID *const pguidApplication,
							GUID *const pguidInstance,
							PVOID const pvConnectData,
							const DWORD dwConnectDataSize,
							IDirectPlay8Address *const pAddress,
							void **const ppvPlayerContext,
							void **const ppvReplyBuffer,
							DWORD *const pdwReplyBufferSize,
							void **const ppvReplyBufferContext)
{
	HRESULT			hResultCode;
	HRESULT			hrFailure;
	PVOID			pvReplyData;
	DWORD			dwReplyDataSize;
	PVOID			pvReplyContext;
	DWORD			dwBufferSize;
	HANDLE			hEndPt;
	CNameTableEntry	*pLocalPlayer;
	CRefCountBuffer	*pRefCountBuffer;
	CPackedBuffer	packedBuffer;
	IDirectPlay8Address	*pDevice;
	DN_INTERNAL_MESSAGE_CONNECT_FAILED		*pInfo;
	BOOL			fDecPlayerCount;
	CCallbackThread	CallbackThread;
#ifdef	DEBUG
	CHAR				DP8ABuffer[512];
	DWORD				DP8ASize;
#endif

	DPFX(DPFPREP, 6,"Parameters: dwFlags [0x%lx], dwDPlay8Version [0x%lx], pwszPassword [0x%p], pguidApplication [0x%p], pguidInstance [0x%p], pvConnectData [0x%p], dwConnectDataSize [%ld]",
			dwFlags,dwDNETVersion,pwszPassword,pguidApplication,pguidInstance,pvConnectData,dwConnectDataSize);

	DNASSERT(pdnObject != NULL);
	DNASSERT(ppvReplyBuffer != NULL);
	DNASSERT(pdwReplyBufferSize != NULL);
	DNASSERT(ppvReplyBufferContext != NULL);

	pLocalPlayer = NULL;
	pRefCountBuffer = NULL;
	pvReplyData = NULL;
	dwReplyDataSize = 0;
	pvReplyContext = NULL;
	pDevice = NULL;
	fDecPlayerCount = FALSE;

	//
	//	Ensure we're not closing or host migrating
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING)
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		hResultCode = DPNERR_ALREADYCLOSING;
		goto CleanUp;
	}
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_HOST_MIGRATING)
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		hResultCode = DPNERR_NOTHOST;
		goto Failure;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Ensure we are the Host
	//
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Connection received by non-host player");
		hResultCode = DPNERR_NOTHOST;
		goto Failure;
	}
	if (!pLocalPlayer->IsHost())
	{
		DPFERR("Connection received by non-host player");
		hResultCode = DPNERR_NOTHOST;
		goto Failure;
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	//
	//	Verify Mode
	//
	if ((pdnObject->dwFlags & DN_OBJECT_FLAG_PEER) && !(dwFlags & DN_OBJECT_FLAG_PEER))
	{
		DPFX(DPFPREP, 7,"Non peer player attempting connection to peer");
		hResultCode = DPNERR_INVALIDINTERFACE;
		goto Failure;
	}
	if ((pdnObject->dwFlags & DN_OBJECT_FLAG_SERVER) && !(dwFlags & DN_OBJECT_FLAG_CLIENT))
	{
		DPFX(DPFPREP, 7,"Non client player attempting connection to server");
		hResultCode = DPNERR_INVALIDINTERFACE;
		goto Failure;
	}

	//
	//	Verify DNET version	- we will only compare the high 16-bits (major number)
	//						- we will allow different low 16-bits (minor number)
	//
	if ((dwDNETVersion & 0xffff0000) != (DN_VERSION_CURRENT & 0xffff0000))
	{
		DPFX(DPFPREP, 7,"Invalid DPlay8 version!");
		hResultCode = DPNERR_INVALIDVERSION;
		goto Failure;
	}

	//
	//	Validate instance GUID
	//
	if (pguidInstance && (*pguidInstance != GUID_NULL))
	{
		if (!pdnObject->ApplicationDesc.IsEqualInstanceGuid(pguidInstance))
		{
			DPFERR("Invalid Instance GUID specified at connection");
			hResultCode = DPNERR_INVALIDINSTANCE;
			goto Failure;
		}
	}

	//
	//	Validate application (if specified)
	//
	if (pguidApplication && (*pguidApplication != GUID_NULL))
	{
		if (!pdnObject->ApplicationDesc.IsEqualApplicationGuid(pguidApplication))
		{
			DPFERR("Invalid Application GUID specified at connection");
			hResultCode = DPNERR_INVALIDAPPLICATION;
			goto Failure;
		}
	}

	//
	//	Validate password
	//
	if (!pdnObject->ApplicationDesc.IsEqualPassword(pwszPassword))
	{
		DPFERR("Incorrect password (required) specified at connection");
		hResultCode = DPNERR_INVALIDPASSWORD;
		goto Failure;
	}

	//
	//	Get device address this connection came in on
	//
	if ((hResultCode = pConnection->GetEndPt(&hEndPt,&CallbackThread)) != DPN_OK)
	{
		DPFERR("Could not extract endpoint from CConnection");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_GENERIC;	// Is there a better one ?
		goto Failure;
	}

	hResultCode = DNGetLocalDeviceAddress(pdnObject,hEndPt,&pDevice);

	pConnection->ReleaseEndPt(&CallbackThread);

	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not determine local device address");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_GENERIC;	// Is there a better one ?
		goto Failure;
	}
#ifdef	DEBUG
		DP8ASize = 512;
		pDevice->lpVtbl->GetURLA(pDevice,DP8ABuffer,&DP8ASize);
		DPFX(DPFPREP, 5,"Local Device Address [%s]",DP8ABuffer);
#endif

	//
	//	Increment AppDesc count
	//
	hResultCode = pdnObject->ApplicationDesc.IncPlayerCount( TRUE );
	if (hResultCode != DPN_OK)
	{
		DPFX(DPFPREP, 7,"Could not add player to game");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	fDecPlayerCount = TRUE;		// only for error handling

	//
	//	Validate user specified data (through call-back)
	//
	if (pvConnectData)
	{

		DPFX(DPFPREP, 7,"dwConnectDataSize [%ld]",dwConnectDataSize);
	}
	else
	{
		DPFX(DPFPREP, 7,"No connect data given");
	}

	if ((hResultCode = DNUserIndicateConnect(	pdnObject,
												pvConnectData,
												dwConnectDataSize,
												&pvReplyData,
												&dwReplyDataSize,
												&pvReplyContext,
												pAddress,
												pDevice,
												ppvPlayerContext)) != DPN_OK)
	{
		DPFERR("Application declined connection attempt");
		hResultCode = DPNERR_HOSTREJECTEDCONNECTION;
		goto Failure;
	}

	pDevice->lpVtbl->Release(pDevice);
	pDevice = NULL;

	//
	//	Save reply buffer
	//
	if ((pvReplyData) && (dwReplyDataSize != 0))
	{
		*ppvReplyBuffer = pvReplyData;
		*pdwReplyBufferSize = dwReplyDataSize;
		*ppvReplyBufferContext = pvReplyContext;
	}
	else
	{
		*ppvReplyBuffer = NULL;
		*pdwReplyBufferSize = 0;
		*ppvReplyBufferContext = NULL;
	}

Exit:

	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:

	if (fDecPlayerCount)
	{
		pdnObject->ApplicationDesc.DecPlayerCount();
	}

	//
	//	Send a message back to the connecting player that this failed
	//
	DPFX(DPFPREP, 7,"Connect failed [0x%lx]",hResultCode);
	hrFailure = hResultCode;
	if (pvReplyData == NULL)
	{
		dwReplyDataSize = 0;	// basic validation
	}
	dwBufferSize = sizeof(DN_INTERNAL_MESSAGE_CONNECT_FAILED) + dwReplyDataSize;
	DPFX(DPFPREP, 7,"Failure buffer is [%ld] bytes",dwBufferSize);

	//
	//	Create and fill failure message buffer
	//
	if ((hResultCode = RefCountBufferNew(pdnObject,dwBufferSize,&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not create RefCountBuffer");
		DisplayDNError(0,hResultCode);
		goto CleanUp;
	}
	packedBuffer.Initialize(pRefCountBuffer->GetBufferAddress(),pRefCountBuffer->GetBufferSize());
	pInfo = reinterpret_cast<DN_INTERNAL_MESSAGE_CONNECT_FAILED*>(pRefCountBuffer->GetBufferAddress());
	if ((hResultCode = packedBuffer.AddToFront(NULL,sizeof(DN_INTERNAL_MESSAGE_CONNECT_FAILED))) != DPN_OK)
	{
		DPFERR("Could not add header to message buffer");
		DisplayDNError(0,hResultCode);
		goto CleanUp;
	}
	if (pvReplyData)
	{
		if ((hResultCode = packedBuffer.AddToBack(pvReplyData,dwReplyDataSize)) != DPN_OK)
		{
			DPFERR("Could not add reply to failure buffer");
			DisplayDNError(0,hResultCode);
			goto CleanUp;
		}
		pInfo->dwReplyOffset = packedBuffer.GetTailOffset();
		pInfo->dwReplySize = dwReplyDataSize;
		DNUserReturnBuffer(pdnObject,DPN_OK,pvReplyData,pvReplyContext);	// Return buffer
	}
	else
	{
		pInfo->dwReplyOffset = 0;
		pInfo->dwReplySize = 0;
	}
	pInfo->hResultCode = hrFailure;

	//
	//	Send failure message
	//
	hResultCode = DNSendMessage(pdnObject,
								pConnection,
								DN_MSG_INTERNAL_CONNECT_FAILED,
								NULL,
								pRefCountBuffer->BufferDescAddress(),
								pRefCountBuffer,
								0,
								DN_SENDFLAGS_RELIABLE,
								NULL,
								NULL);

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

CleanUp:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pDevice)
	{
		pDevice->lpVtbl->Release(pDevice);
		pDevice = NULL;
	}
	goto Exit;
}


//
//	DNHostDropPlayer
//
//	An existing player in a peer-peer game could not connect to a NewPlayer and is informing the
//	Host of this situation.  As a result, the Host will drop inform the NewPlayer of this and then
//	drop the NewPlayer from the game
//

#undef DPF_MODNAME
#define DPF_MODNAME "DNHostDropPlayer"

HRESULT DNHostDropPlayer(DIRECTNETOBJECT *const pdnObject,
						 const DPNID dpnid,		//	ExistingPlayer who could not connect to NewPlayer
						 void *const pvBuffer)
{
	HRESULT			hResultCode;
	CRefCountBuffer	*pRefCountBuffer;
	CNameTableEntry	*pNTEntry;
	CConnection		*pConnection;
	UNALIGNED DN_INTERNAL_MESSAGE_INSTRUCTED_CONNECT_FAILED	*pInfo;
	DN_INTERNAL_MESSAGE_CONNECT_ATTEMPT_FAILED		*pMsg;

	DPFX(DPFPREP, 4,"Parameters: pvBuffer [0x%p]",pvBuffer);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvBuffer != NULL);

	pRefCountBuffer = NULL;
	pNTEntry = NULL;
	pConnection = NULL;

	pInfo = static_cast<DN_INTERNAL_MESSAGE_INSTRUCTED_CONNECT_FAILED*>(pvBuffer);
	DPFX(DPFPREP, 5,"Connection to [0x%lx] failed",pInfo->dpnid);

	//
	//	Get connection for NewPlayer
	//
	if ((hResultCode = pdnObject->NameTable.FindEntry(pInfo->dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("NewPlayer no longer in NameTable - not to worry");
		hResultCode = DPN_OK;
		goto Failure;
	}
	if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		DPFERR("Connection for NewPlayer no longer valid - not to worry");
		hResultCode = DPN_OK;
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	Send message to NewPlayer informing them of which existing player could not connect to them
	//
	if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_CONNECT_ATTEMPT_FAILED),&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not allocate RefCountBuffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_CONNECT_ATTEMPT_FAILED*>(pRefCountBuffer->GetBufferAddress());
	pMsg->dpnid = dpnid;
	hResultCode = DNSendMessage(pdnObject,
								pConnection,
								DN_MSG_INTERNAL_CONNECT_ATTEMPT_FAILED,
								pInfo->dpnid,
								pRefCountBuffer->BufferDescAddress(),
								pRefCountBuffer,
								0,
								DN_SENDFLAGS_RELIABLE,
								NULL,
								NULL);
	if (hResultCode != DPNERR_PENDING)
	{
		DPFERR("Could not send message to NewPlayer - assume he is gone or going");
		hResultCode = DPN_OK;
		goto Failure;
	}
	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	//
	//	We will just drop (or at least attempt to drop) the connection
	//
	pConnection->Disconnect();
	pConnection->Release();
	pConnection = NULL;

	hResultCode = DNHostDisconnect(pdnObject,pInfo->dpnid,DPNDESTROYPLAYERREASON_HOSTDESTROYEDPLAYER);

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	goto Exit;
}


//
//	Perform a connection to a host player (either host in peer-to-peer or server in client-server).
//	This processes the handshaking of the name table between the host and the player.
//	The first step is to send the player and application info to the host for verification
//	The second step is to receive and process the name table from the host
//	The last step is to wait for connections from other players and populate the name table
//	It assumes that the connection to the host has already been initiated.
//

//	DNPrepareConnectInfo
//
//	Prepare the connection info block which will be sent to the Host player once a connection
//	has been established.

#undef DPF_MODNAME
#define DPF_MODNAME "DNPrepareConnectInfo"

HRESULT DNPrepareConnectInfo(DIRECTNETOBJECT *const pdnObject,
							 CConnection *const pConnection,
							 CRefCountBuffer **const ppRefCountBuffer)
{
	HRESULT				hResultCode;
	DWORD				dwSize;
	DWORD				dwPasswordSize;
	DWORD				dwAddressSize;
	HANDLE				hEndPt;
	CRefCountBuffer		*pRefCountBuffer;
	CPackedBuffer		packedBuffer;
	IDirectPlay8Address		*pAddress;
	DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO *pInfo;
	CCallbackThread		CallbackThread;
#ifdef	DEBUG
	CHAR				DP8ABuffer[512];
	DWORD				DP8ASize;
#endif

	DPFX(DPFPREP, 4,"Parameters: pConnection [0x%p], ppRefCountBuffer [0x%p]",pConnection,ppRefCountBuffer);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pConnection != NULL);
	DNASSERT(ppRefCountBuffer != NULL);

	pRefCountBuffer = NULL;
	pAddress = NULL;
	dwAddressSize = 0;

	//
	//	Get clear address
	//
	dwAddressSize = 0;
	if ((hResultCode = pConnection->GetEndPt(&hEndPt,&CallbackThread)) == DPN_OK)
	{
		if ((hResultCode = DNGetClearAddress(pdnObject,hEndPt,&pAddress,FALSE)) == DPN_OK)
		{
			if (pAddress != NULL)
			{
				// Get address URL size
				pAddress->lpVtbl->GetURLA(pAddress,NULL,&dwAddressSize);
				DNASSERT(dwAddressSize != 0);
#ifdef	DEBUG
				DP8ASize = 512;
				pAddress->lpVtbl->GetURLA(pAddress,DP8ABuffer,&DP8ASize);
				DPFX(DPFPREP, 5,"Remote Address [%s]",DP8ABuffer);
#endif
			}
		}
		pConnection->ReleaseEndPt(&CallbackThread);
	}

	// Determine total size of connection info buffer
	if (pdnObject->ApplicationDesc.GetPassword() != NULL)
		dwPasswordSize = (wcslen(pdnObject->ApplicationDesc.GetPassword()) + 1) * sizeof(WCHAR);
	else
		dwPasswordSize = 0;

	dwSize = sizeof(DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO)
			+ pdnObject->dwConnectDataSize
			+ dwAddressSize
			+ dwPasswordSize
			+ pdnObject->NameTable.GetDefaultPlayer()->GetDataSize()
			+ pdnObject->NameTable.GetDefaultPlayer()->GetNameSize();

	// Allocate connection info buffer
	DPFX(DPFPREP, 7,"Need to allocate [%ld] bytes",dwSize);
	if ((hResultCode = RefCountBufferNew(pdnObject,dwSize,&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not allocate space for connection info");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	packedBuffer.Initialize(pRefCountBuffer->GetBufferAddress(),pRefCountBuffer->GetBufferSize());
	pInfo = static_cast<DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO*>(packedBuffer.GetHeadAddress());

	// Type of interface
	pInfo->dwFlags = pdnObject->dwFlags & (DN_OBJECT_FLAG_PEER | DN_OBJECT_FLAG_CLIENT | DN_OBJECT_FLAG_SERVER);

	// Version of DIRECTNET
	pInfo->dwDNETVersion = DN_VERSION_CURRENT;

	// Name
	if (pdnObject->NameTable.GetDefaultPlayer()->GetNameSize())
	{
		if ((hResultCode = packedBuffer.AddToBack(pdnObject->NameTable.GetDefaultPlayer()->GetName(),
				pdnObject->NameTable.GetDefaultPlayer()->GetNameSize())) != DPN_OK)
		{
			DPFERR("Could not add name to connection buffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pInfo->dwNameOffset = packedBuffer.GetTailOffset();
		pInfo->dwNameSize = pdnObject->NameTable.GetDefaultPlayer()->GetNameSize();
	}
	else
	{
		pInfo->dwNameOffset = 0;
		pInfo->dwNameSize = 0;
	}

	// Player data
	if (pdnObject->NameTable.GetDefaultPlayer()->GetData() && pdnObject->NameTable.GetDefaultPlayer()->GetDataSize())
	{
		if ((hResultCode = packedBuffer.AddToBack(pdnObject->NameTable.GetDefaultPlayer()->GetData(),
				pdnObject->NameTable.GetDefaultPlayer()->GetDataSize())) != DPN_OK)
		{
			DPFERR("Could not add connect data to connection buffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pInfo->dwDataOffset = packedBuffer.GetTailOffset();
		pInfo->dwDataSize = pdnObject->NameTable.GetDefaultPlayer()->GetDataSize();
	}
	else
	{
		pInfo->dwDataOffset = 0;
		pInfo->dwDataSize = 0;
	}

	// Password
	if (dwPasswordSize)
	{
		if ((hResultCode = packedBuffer.AddToBack(pdnObject->ApplicationDesc.GetPassword(),dwPasswordSize)) != DPN_OK)
		{
			DPFERR("Could not add password to connection buffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pInfo->dwPasswordOffset = packedBuffer.GetTailOffset();
		pInfo->dwPasswordSize = dwPasswordSize;
	}
	else
	{
		pInfo->dwPasswordOffset = 0;
		pInfo->dwPasswordSize = 0;
	}

	// Connect data
	if (pdnObject->pvConnectData)
	{
		if ((hResultCode = packedBuffer.AddToBack(pdnObject->pvConnectData,pdnObject->dwConnectDataSize)) != DPN_OK)
		{
			DPFERR("Could not add connect data to connection buffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pInfo->dwConnectDataOffset = packedBuffer.GetTailOffset();
		pInfo->dwConnectDataSize = pdnObject->dwConnectDataSize;
	}
	else
	{
		pInfo->dwConnectDataOffset = 0;
		pInfo->dwConnectDataSize = 0;
	}

	// Clear address URL
	if (dwAddressSize)
	{
		if ((hResultCode = packedBuffer.AddToBack(NULL,dwAddressSize)) != DPN_OK)
		{
			DPFERR("Could not add address URL to connection buffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		if ((hResultCode = pAddress->lpVtbl->GetURLA(pAddress,
													static_cast<char*>(packedBuffer.GetTailAddress()),
													&dwAddressSize)) != DPN_OK)
		{
			DPFERR("Could not get address URL");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pInfo->dwURLOffset = packedBuffer.GetTailOffset();
		pInfo->dwURLSize = dwAddressSize;
	}
	else
	{
		pInfo->dwURLOffset = 0;
		pInfo->dwURLSize = 0;
	}

	// Instance and appplication GUIDs
	memcpy(&pInfo->guidInstance,pdnObject->ApplicationDesc.GetInstanceGuid(),sizeof(GUID));
	memcpy(&pInfo->guidApplication,pdnObject->ApplicationDesc.GetApplicationGuid(),sizeof(GUID));

	*ppRefCountBuffer = pRefCountBuffer;
	pRefCountBuffer = NULL;

	if (pAddress)
	{
		pAddress->lpVtbl->Release(pAddress);
		pAddress = NULL;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:

	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pAddress)
	{
		pAddress->lpVtbl->Release(pAddress);
		pAddress = NULL;
	}

	goto Exit;
}



//	DNConnectToHost1
//
//	After receiving protocol level connection acknowledgement, send player and application info
//		CConnection	*pConnection	Connection to host

#undef DPF_MODNAME
#define DPF_MODNAME "DNConnectToHost1"

HRESULT DNConnectToHost1(DIRECTNETOBJECT *const pdnObject,
						 CConnection *const pConnection)
{
	HRESULT				hResultCode;
	CRefCountBuffer		*pRefCountBuffer;
	CAsyncOp			*pAsyncOp;
	CAsyncOp			*pConnectParent;

	DPFX(DPFPREP, 4,"Parameters: pConnection [0x%p]",pConnection);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pConnection != NULL);

	pRefCountBuffer = NULL;
	pAsyncOp = NULL;
	pConnectParent = NULL;

	//
	//	Get connect parent (and make sure we're not closing)
	//	We will also store the CConnection on the connect parent for future clean up.
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & (DN_OBJECT_FLAG_CLOSING | DN_OBJECT_FLAG_DISCONNECTING))
	{
		DPFERR("Object is CLOSING or DISCONNECTING");
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		pConnection->Disconnect();
		hResultCode = DPN_OK;
		goto Failure;
	}
	DNASSERT(pdnObject->pConnectParent != NULL);
	pdnObject->pConnectParent->SetConnection( pConnection );	
	pdnObject->pConnectParent->AddRef();
	pConnectParent = pdnObject->pConnectParent;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Prepare connect info
	//
	if ((hResultCode = DNPrepareConnectInfo(pdnObject,pConnection,&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not prepare connect info");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	DNASSERT(pRefCountBuffer != NULL);

	//
	//	Send connect info
	//
	hResultCode = DNSendMessage(pdnObject,
								pConnection,
								DN_MSG_INTERNAL_PLAYER_CONNECT_INFO,
								0,
								pRefCountBuffer->BufferDescAddress(),
								pRefCountBuffer,
								0,
								DN_SENDFLAGS_RELIABLE,
								pConnectParent,
								&pAsyncOp);

	if (hResultCode == DPNERR_PENDING)
	{
		pAsyncOp->SetCompletion( DNCompleteSendConnectInfo );
		pAsyncOp->Release();
		pAsyncOp = NULL;

		hResultCode = DPN_OK;
	}
	else
	{
		//
		//	Save error code, clean up DirectNetObject and fail
		//
		DNAbortConnect(pdnObject,hResultCode);
	}

	pConnectParent->Release();
	pConnectParent = NULL;
	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pConnectParent)
	{
		pConnectParent->Release();
		pConnectParent = NULL;
	}
	goto Exit;
}


//	DN_ConnectToHost2
//
//	Extract and install the host supplied name table
//	Send name table acknowledgement to the host
//	Propegate ADD_PLAYER messages to the application for host and local players
//	Propegate CREATE_GROUP messages to the application for groups in the name table
//
//		PVOID		pvData			NameTable buffer
//		CConnection	*pConnection	Connection to host

#undef DPF_MODNAME
#define DPF_MODNAME "DNConnectToHost2"

HRESULT DNConnectToHost2(DIRECTNETOBJECT *const pdnObject,
						 const PVOID pvData,
						 CConnection *const pConnection)
{
	HRESULT				hResultCode;
	CNameTableEntry		*pNTEntry;
	CNameTableEntry		*pHostPlayer;
	CNameTableEntry		*pLocalPlayer;
	CNameTableOp		*pNTOp;
	CBilink				*pBilink;
	DPNID				dpnid;
	DWORD				dwFlags = NULL;
	CConnection			*pLocalConnection;
	BOOL				fNotify;
	IDirectPlay8Address	*pIDevice;
	IDirectPlay8Address	*pIHost;
	CAsyncOp			*pListenParent;
	CAsyncOp			*pConnectParent;
	HANDLE				hEndPt;
	CCallbackThread		CallbackThread;

	DPFX(DPFPREP, 4,"Parameters: pvData [0x%p], pConnection [0x%p]",pvData,pConnection);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvData != NULL);
	DNASSERT(pConnection != NULL);

	pNTEntry = NULL;
	pHostPlayer = NULL;
	pLocalPlayer = NULL;
	pLocalConnection = NULL;
	pIDevice = NULL;
	pIHost = NULL;
	pListenParent = NULL;
	pConnectParent = NULL;

	//
	//	Initial try to catch a close
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & (DN_OBJECT_FLAG_CLOSING | DN_OBJECT_FLAG_DISCONNECTING))
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		hResultCode = DPN_OK;
		goto Failure;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Extract application description and name table
	//
	if ((hResultCode = DNReceiveConnectInfo(pdnObject,pvData,pConnection,&dpnid)) != DPN_OK)
	{
		DPFERR("Could not extract name table passed by host");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Get Connection object for local player
	//
	if ((hResultCode = ConnectionNew(pdnObject,&pLocalConnection)) != DPN_OK)
	{
		DPFERR("Could not create new Connection");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	//
	//	Get Host and Local players
	//
	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer )) != DPN_OK)
	{
		DPFERR("Could not find Host player");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not find Local player");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Ensure we have an address for the Host player
	//
	if (pHostPlayer->GetAddress() == NULL)
	{
		//
		//	Use connect address if it exists
		//
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		if (pdnObject->pConnectAddress)
		{
			pdnObject->pConnectAddress->lpVtbl->AddRef(pdnObject->pConnectAddress);
			pIHost = pdnObject->pConnectAddress;
		}
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

		if (pIHost == NULL)
		{
			//
			//	No connect address was specified, so we will query for the host's address
			//
			if ((hResultCode = pConnection->GetEndPt(&hEndPt,&CallbackThread)) != DPN_OK)
			{
				DPFERR("Could not get end point from connection");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}

			hResultCode = DNGetClearAddress(pdnObject,hEndPt,&pIHost,TRUE);

			pConnection->ReleaseEndPt(&CallbackThread);

			if (hResultCode != DPN_OK)
			{
				DPFERR("Could not get clear address for Host player");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
		}
		pHostPlayer->SetAddress(pIHost);
		pIHost->lpVtbl->Release(pIHost);
		pIHost = NULL;
	}

	//
	//	Start LISTENs for CONNECTs from existing players in Peer-Peer mode
	//
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
	{
		if ((hResultCode = pConnection->GetEndPt(&hEndPt,&CallbackThread)) != DPN_OK)
		{
			DPFERR("Could not get end point from connection");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}

		hResultCode = DNGetLocalDeviceAddress(pdnObject,hEndPt,&pIDevice);

		pConnection->ReleaseEndPt(&CallbackThread);

		if (hResultCode != DPN_OK)
		{
			DPFERR("Could not get LISTEN address from endpoint");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}

		// Parent Async Op
		if ((hResultCode = AsyncOpNew(pdnObject,&pListenParent)) != DPN_OK)
		{
			DPFERR("Could not create AsyncOp");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pListenParent->SetOpType( ASYNC_OP_LISTEN );
		pListenParent->MakeParent();
		pListenParent->SetCompletion( DNCompleteListen );

		// Perform child LISTEN
		hResultCode = DNPerformSPListen(pdnObject,
										pIDevice,
										pListenParent,
										NULL);
		if (hResultCode != DPN_OK)
		{
			DPFERR("Could not perform child LISTEN");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}

		// Store parent LISTEN on DirectNet object
#pragma BUGBUG( minara, "What if we are closing down and have already terminated all listens ?" )
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		pListenParent->AddRef();
		pdnObject->pListenParent = pListenParent;
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

		pListenParent->Release();
		pListenParent = NULL;
		pIDevice->lpVtbl->Release(pIDevice);
		pIDevice = NULL;
	}

	//
	//	Indicate peer connected - we will perform this before notifying the host so that
	//	DN_OBJECT_FLAG_CONNECTED is set when existing player CONNECTs come in
	//
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
	{
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		if (pdnObject->dwFlags & (DN_OBJECT_FLAG_CLOSING | DN_OBJECT_FLAG_DISCONNECTING))
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
#pragma TODO( minara, "Shut down listen" )
			hResultCode = DPN_OK;
			goto Failure;
		}
		pdnObject->dwFlags &= (~DN_OBJECT_FLAG_CONNECTING);
		pdnObject->dwFlags |= DN_OBJECT_FLAG_CONNECTED;
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

		//
		//	Inform application of groups and players.
		//	We will inform the application of
		//		- CREATE_GROUP
		//		- ADD_PLAYER (for Local and Host players)
		//		- ADD_PLAYER_TO_GROUP
		//

		pdnObject->NameTable.ReadLock();
		pBilink = pdnObject->NameTable.m_bilinkGroups.GetNext();
		while (pBilink != &pdnObject->NameTable.m_bilinkGroups)
		{
			pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
			pNTEntry->AddRef();
			pdnObject->NameTable.Unlock();

			fNotify = FALSE;
			pNTEntry->Lock();
			if (!pNTEntry->IsAvailable() && !pNTEntry->IsDisconnecting() && !pNTEntry->IsAutoDestructGroup())
			{
				pNTEntry->MakeAvailable();
				pNTEntry->NotifyAddRef();
				pNTEntry->NotifyAddRef();
				pNTEntry->SetInUse();
				fNotify = TRUE;
			}
			pNTEntry->Unlock();

			if (fNotify)
			{
				DNASSERT(!pNTEntry->IsAllPlayersGroup());
				DNUserCreateGroup(pdnObject,pNTEntry);

				pNTEntry->PerformQueuedOperations();

				pdnObject->NameTable.PopulateGroup( pNTEntry );
			}

			pNTEntry->Release();
			pNTEntry = NULL;

			pdnObject->NameTable.ReadLock();
			if (pBilink->IsEmpty())
			{
				pBilink = pdnObject->NameTable.m_bilinkGroups.GetNext();
			}
			else
			{
				pBilink = pBilink->GetNext();
			}
		}
		pNTEntry = NULL;
		pdnObject->NameTable.Unlock();
	}

	//
	//	We will pre-set the Host connection, so that any operation from the CREATE_PLAYER notification call-back
	//	for the local player will be able to find the Host player's connection (to send messages to).  We will
	//	not, however, expose the Host player to the user yet.
	//
	pHostPlayer->Lock();
	pHostPlayer->SetConnection( pConnection );
	pHostPlayer->Unlock();

	//
	// Add Local player
	//
	pLocalConnection->SetStatus( CONNECTED );
	pLocalConnection->SetEndPt(NULL);
	pLocalConnection->MakeLocal();

	//
	//	Preset player context
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	DNASSERT(pdnObject->pConnectParent);
	if (pdnObject->pConnectParent)
	{
		pdnObject->pConnectParent->AddRef();
		pConnectParent = pdnObject->pConnectParent;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	if (pConnectParent)
	{
		pConnectParent->Lock();
		if (pConnectParent->GetContext())
		{
			pLocalPlayer->Lock();
			pLocalPlayer->SetContext(pConnectParent->GetContext());
			pLocalPlayer->Unlock();
		}
		pConnectParent->SetResult( DPN_OK );
		pConnectParent->Unlock();
		pConnectParent->Release();
		pConnectParent = NULL;
	}

	if (pdnObject->dwFlags & (DN_OBJECT_FLAG_PEER|DN_OBJECT_FLAG_SERVER))
	{
		pdnObject->ApplicationDesc.IncPlayerCount( FALSE );
		pLocalConnection->SetDPNID(pLocalPlayer->GetDPNID());
		pdnObject->NameTable.PopulateConnection(pLocalConnection);
	}
	else
	{
		pLocalPlayer->Lock();
		pLocalPlayer->SetConnection(pLocalConnection);
		pLocalPlayer->StopConnecting();
		pLocalPlayer->MakeAvailable();
		pLocalPlayer->Unlock();

		pdnObject->NameTable.DecOutstandingConnections();
	}
	pLocalConnection->Release();
	pLocalConnection = NULL;

	//
	// Add Host player
	//
	if (pdnObject->dwFlags & (DN_OBJECT_FLAG_PEER|DN_OBJECT_FLAG_SERVER))
	{
		pdnObject->ApplicationDesc.IncPlayerCount( FALSE );

		//
		//	If we have lost the connection to the host player, we will abort the connect process
		//
		pConnection->Lock();
		if (!pConnection->IsDisconnecting() && !pConnection->IsInvalid())
		{
			pConnection->SetDPNID(pHostPlayer->GetDPNID());
			pConnection->SetStatus( CONNECTED );
			pConnection->Unlock();
			pdnObject->NameTable.PopulateConnection(pConnection);
		}
		else
		{
			pConnection->Unlock();
			DNAbortConnect(pdnObject,DPNERR_CONNECTIONLOST);
			goto Failure;
		}
	}
	else
	{
		pConnection->SetStatus( CONNECTED );

		pHostPlayer->Lock();
		pHostPlayer->StopConnecting();

		//
		//	We won't make the host player available until after CONNECT_COMPLETE
		//	has been indicated and the callback has returned.
		//
		//pHostPlayer->MakeAvailable();
		
		pHostPlayer->Unlock();

		pdnObject->NameTable.DecOutstandingConnections();
	}

	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	//
	//	Process any nametable operations that might have arrived
	//
	pdnObject->NameTable.ReadLock();
	pBilink = pdnObject->NameTable.m_bilinkNameTableOps.GetNext();
	while (pBilink != &pdnObject->NameTable.m_bilinkNameTableOps)
	{
		pNTOp = CONTAINING_OBJECT(pBilink,CNameTableOp,m_bilinkNameTableOps);
		if ((pNTOp->GetVersion() == (pdnObject->NameTable.GetVersion() + 1))
				&& !pNTOp->IsInUse())
		{
			pNTOp->SetInUse();
			pdnObject->NameTable.Unlock();

			hResultCode = DNNTPerformOperation(	pdnObject,
												pNTOp->GetMsgId(),
												pNTOp->GetRefCountBuffer()->GetBufferAddress() );

			pdnObject->NameTable.ReadLock();
		}
		else
		{
			//
			//	Once we find an operation that we won't perform, there is no point continuing
			//
			break;
		}
		pBilink = pBilink->GetNext();
	}
	pdnObject->NameTable.Unlock();

	//
	//	Send conect info acknowledgement to host
	//
	hResultCode = DNSendMessage(pdnObject,
								pConnection,
								DN_MSG_INTERNAL_ACK_CONNECT_INFO,
								pHostPlayer->GetDPNID(),
								NULL,
								NULL,
								0,
								DN_SENDFLAGS_RELIABLE,
								NULL,
								NULL);
	if (hResultCode != DPNERR_PENDING)
	{
		DNAbortConnect(pdnObject,hResultCode);
		goto Failure;
	}

	pHostPlayer->Release();
	pHostPlayer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pLocalConnection)
	{
		pLocalConnection->Release();
		pLocalConnection = NULL;
	}
	if (pIDevice)
	{
		pIDevice->lpVtbl->Release(pIDevice);
		pIDevice = NULL;
	}
	if (pIHost)
	{
		pIHost->lpVtbl->Release(pIHost);
		pIHost = NULL;
	}
	if (pListenParent)
	{
		pListenParent->Release();
		pListenParent = NULL;
	}
	if (pConnectParent)
	{
		pConnectParent->Release();
		pConnectParent = NULL;
	}
	goto Exit;
}


//	DNConnectToHostFailed
//
//	Clean up if an attempt to connect to the HostPlayer fails

#undef DPF_MODNAME
#define DPF_MODNAME "DNConnectToHostFailed"

HRESULT	DNConnectToHostFailed(DIRECTNETOBJECT *const pdnObject,
							  PVOID const pvBuffer,
							  const DWORD dwBufferSize,
							  CConnection *const pConnection)
{
	CAsyncOp		*pConnectParent;
	HRESULT			hResultCode;
	CRefCountBuffer	*pRefCountBuffer;
	UNALIGNED DN_INTERNAL_MESSAGE_CONNECT_FAILED			*pInfo;

	DPFX(DPFPREP, 4,"Parameters: pvBuffer [0x%p], dwBufferSize [%ld], pConnection [0x%x]",pvBuffer,dwBufferSize,pConnection);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvBuffer != NULL || dwBufferSize == 0);

	pRefCountBuffer = NULL;
	pConnectParent = NULL;

	if (pvBuffer != NULL)
	{
		pInfo = static_cast<DN_INTERNAL_MESSAGE_CONNECT_FAILED*>(pvBuffer);
		if ((pInfo->dwReplyOffset != 0) && (pInfo->dwReplySize != 0))
		{
			//
			//	Extract reply buffer
			//
			if ((hResultCode = RefCountBufferNew(pdnObject,pInfo->dwReplySize,&pRefCountBuffer)) != DPN_OK)
			{
				DPFERR("Could not create RefCountBuffer - ignore and continue");
				DisplayDNError(0,hResultCode);
			}
			else
			{
				memcpy(	pRefCountBuffer->GetBufferAddress(),
						static_cast<BYTE*>(pvBuffer) + pInfo->dwReplyOffset,
						pInfo->dwReplySize );
			}
		}

		//
		//	Update connect operation parent with results
		//
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		DNASSERT(pdnObject->pConnectParent);
		if (pdnObject->pConnectParent)
		{
			pdnObject->pConnectParent->Lock();
			pdnObject->pConnectParent->SetResult( pInfo->hResultCode );
			pdnObject->pConnectParent->SetRefCountBuffer( pRefCountBuffer );
			pdnObject->pConnectParent->Unlock();
		}
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

		if (pRefCountBuffer)
		{
			pRefCountBuffer->Release();
			pRefCountBuffer = NULL;
		}
DPFX(DPFPREP, 0,"ConnectToHostFailed: [0x%lx]",pInfo->hResultCode);
	}

	//
	//	Release the reference on the connection since we will be dropping the link.
	//	We are safe releasing the connection here, since the protocol will prevent
	//	the Host's DISCONNECT from being passed up to us until after this thread
	//	has returned back down.
	//
	pConnection->Disconnect();

	//
	//	Clean up DirectNetObject
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->dwFlags &= (~(DN_OBJECT_FLAG_CONNECTED|DN_OBJECT_FLAG_CONNECTING|DN_OBJECT_FLAG_HOST_CONNECTED));
	if (pdnObject->pConnectParent)
	{
		pConnectParent = pdnObject->pConnectParent;
		pdnObject->pConnectParent = NULL;
	}
	if( pdnObject->pIDP8ADevice )
	{
		pdnObject->pIDP8ADevice->lpVtbl->Release( pdnObject->pIDP8ADevice );
		pdnObject->pIDP8ADevice = NULL;
	}
	if( pdnObject->pConnectAddress )
	{
		pdnObject->pConnectAddress->lpVtbl->Release( pdnObject->pConnectAddress );
		pdnObject->pConnectAddress = NULL;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	if (pConnectParent)
	{
		pConnectParent->Release();
		pConnectParent = NULL;
	}

	DPFX(DPFPREP, 4,"Returning: DPN_OK");
	return(DPN_OK);
}



//
//	DNAbortConnect
//
//	Abort the CONNECT process by cleaning up the DirectNet object and terminating the session
//

#undef DPF_MODNAME
#define DPF_MODNAME "DNAbortConnect"

HRESULT DNAbortConnect(DIRECTNETOBJECT *const pdnObject,
					   const HRESULT hrConnect)
{
	HRESULT		hResultCode;
	CAsyncOp	*pConnectParent;

	DPFX(DPFPREP, 4,"Parameters: hrConnect [0x%lx]",hrConnect);

	DNASSERT(pdnObject != NULL);

	pConnectParent = NULL;

	//
	//	Clean up DirectNetObject
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->dwFlags &= (~(DN_OBJECT_FLAG_CONNECTED|DN_OBJECT_FLAG_CONNECTING|DN_OBJECT_FLAG_HOST_CONNECTED));
	if (pdnObject->pConnectParent)
	{
		pdnObject->pConnectParent->AddRef();
		pConnectParent = pdnObject->pConnectParent;
	}

	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Set error code on connect operation completion
	//
	if (pConnectParent)
	{
		pConnectParent->Lock();
		pConnectParent->SetResult( hrConnect );
		pConnectParent->Unlock();
	}

	//
	//	Shut down
	//
	DNTerminateSession(pdnObject,DPN_OK);

	if (pConnectParent)
	{
		pConnectParent->Release();
		pConnectParent = NULL;
	}

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}



//	Player to player connection occurs at the direction of the host. (Peer-to-peer)
//
//	Once a NewPlayer has connected to the host,
//		The Host will send the NewPlayer's NameTable entry to all existing players
//	Once the NewPlayer has installed the NameTable, it informs the host
//		The Host will instruct the existing players to connect to the NewPlayer
//
//	When an existing player establishes a connection with the NewPlayer
//		The existing player send their DNID to the NewPlayer and an ADD_PLAYER to app
//		The NewPlayer activates the connecting (existing) player and sends ADD_PLAYER to app
//


//	DNPlayerConnect1
//
//	Receive an existing player's DNID.  This is called by the NewPlayer.  If valid, send an
//	ADD_PLAYER message to the application

#undef DPF_MODNAME
#define DPF_MODNAME "DNPlayerConnect1"

HRESULT	DNPlayerConnect1(DIRECTNETOBJECT *const pdnObject,
						 const PVOID pv,
						 CConnection *const pConnection)
{
	HRESULT						hResultCode;
	CNameTableEntry				*pPlayer;
	UNALIGNED DN_INTERNAL_MESSAGE_SEND_PLAYER_DPNID	*pSend;

	DPFX(DPFPREP, 4,"Parameters: pv [0x%p], pConnection [0x%p]",pv,pConnection);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pv != NULL);
	DNASSERT(pConnection != NULL);

	pPlayer = NULL;

	pSend = static_cast<DN_INTERNAL_MESSAGE_SEND_PLAYER_DPNID*>(pv);
	DNASSERT(pSend->dpnid != 0);

	DPFX(DPFPREP, 5,"Player [0x%lx] has connected",pSend->dpnid);

	if ((hResultCode = pdnObject->NameTable.FindEntry(pSend->dpnid,&pPlayer)) != DPN_OK)
	{
		DPFERR("Could not find connecting player!");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Increment players in session
	//
	pdnObject->ApplicationDesc.IncPlayerCount( FALSE );

	// Associate DNID with player's connection
	pConnection->Lock();
	pConnection->SetDPNID(pSend->dpnid);
	pConnection->SetStatus( CONNECTED );
	pConnection->Unlock();

	// Populate connection
	pdnObject->NameTable.PopulateConnection(pConnection);

	//
	//	Now that this connection is part of a NameTableEntry, remove it from the indicated list
	//
	DNEnterCriticalSection(&pdnObject->csConnectionList);
	if (!pConnection->m_bilinkIndicated.IsEmpty())
	{
		pConnection->Release();
	}
	pConnection->m_bilinkIndicated.RemoveFromList();
	DNLeaveCriticalSection(&pdnObject->csConnectionList);

	pPlayer->Release();
	pPlayer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pPlayer)
	{
		pPlayer->Release();
		pPlayer = NULL;
	}
	goto Exit;
}


//	DNConnectToPeer1
//
//	Accept the NameTable entry of the NewPlayer from the Host, and add it to the local
//	NameTable.  The Host will later provide an INSTRUCT_CONNECT message later.

#undef DPF_MODNAME
#define DPF_MODNAME "DNConnectToPeer1"

HRESULT	DNConnectToPeer1(DIRECTNETOBJECT *const pdnObject,
						 PVOID const pv)
{
	HRESULT					hResultCode;
	DN_NAMETABLE_ENTRY_INFO	*pdnNTEInfo;
	CNameTableEntry			*pNTEntry;
//	DWORD					dwVersion;

	DPFX(DPFPREP, 4,"Parameters: pv [0x%p]",pv);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pv != NULL);

	pNTEntry = NULL;

	//
	//	Create and unpack new entry
	//
	if ((hResultCode = NameTableEntryNew(pdnObject,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not create new NameTableEntry");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pdnNTEInfo = static_cast<DN_NAMETABLE_ENTRY_INFO*>(pv);
	DPFX(DPFPREP, 5,"New player DNID [0x%lx] - installing NameTable entry",pdnNTEInfo->dpnid);
	DPFX(DPFPREP, 5,"Connecting Player URL [%s]",static_cast<char*>(pv) + pdnNTEInfo->dwURLOffset);
	if ((hResultCode = pNTEntry->UnpackEntryInfo(pdnNTEInfo,static_cast<BYTE*>(pv))) != DPN_OK)
	{
		DPFERR("Could not unpack NameTableEntry");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pNTEntry->StartConnecting();

	//
	//	Add entry to NameTable
	//
	if ((hResultCode = pdnObject->NameTable.InsertEntry(pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not insert NameTableEntry into NameTable");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	//
	//	Update NameTableVersion
	//
	pdnObject->NameTable.WriteLock();
	pdnObject->NameTable.SetVersion( pdnNTEInfo->dwVersion );
	pdnObject->NameTable.Unlock();

	pNTEntry->Release();
	pNTEntry = NULL;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


//	DNConnectToPeer2
//
//	Perform a connection to the NewPlayer (as instructed by Host).
//	Once this connection has completed (DNConnectToPeer2) send this player's DNID

#undef DPF_MODNAME
#define DPF_MODNAME "DNConnectToPeer2"

HRESULT DNConnectToPeer2(DIRECTNETOBJECT *const pdnObject,
						 PVOID const pv)
{
	HRESULT				hResultCode;
	CNameTableEntry		*pNTEntry;
	CNameTableEntry		*pLocalPlayer;
	UNALIGNED DN_INTERNAL_MESSAGE_INSTRUCT_CONNECT	*pInfo;
	CServiceProvider	*pSP;

	DPFX(DPFPREP, 4,"Parameters: pv [0x%p]", pv);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pv != NULL);

	pNTEntry = NULL;
	pLocalPlayer = NULL;
	pSP = NULL;

	pInfo = static_cast<DN_INTERNAL_MESSAGE_INSTRUCT_CONNECT*>(pv);

	//
	//	Update NameTable version
	//
	pdnObject->NameTable.WriteLock();
	pdnObject->NameTable.SetVersion( pInfo->dwVersion );
	pdnObject->NameTable.Unlock();

	//
	//	Determine if this is an instruction to connect to ourselves.
	//	If it is, don't do anything other than update the NameTable version
	//
	DPFX(DPFPREP, 5,"Instructed to connect to [0x%lx]",pInfo->dpnid);
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if (pLocalPlayer->GetDPNID() == pInfo->dpnid)
	{
		DPFX(DPFPREP, 5,"Ignoring instruction to connect to self");
		hResultCode = DPN_OK;
		goto Failure;
	}

	if ((hResultCode = pdnObject->NameTable.FindEntry(pInfo->dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not find NameTableEntry");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	//
	//	We will not connect to older players.  They will connect to us.
	//
	if (pNTEntry->GetVersion() < pLocalPlayer->GetVersion())
	{
		DPFX(DPFPREP, 5,"Ignoring instruction to connect to older player");
		hResultCode = DPN_OK;
		goto Failure;
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	//
	//	Get SP (cached on DirectNet object from original Connect() to host)
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->pConnectSP != NULL)
	{
		pdnObject->pConnectSP->AddRef();
		pSP = pdnObject->pConnectSP;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	if (pSP == NULL)
	{
		DPFERR("Could not find connect SP on DirectNet object");
		hResultCode = DPNERR_GENERIC;
		goto Failure;
	}

#if 0
#pragma BUGBUG( minara, "REMOVE THIS" )
	//
	//	TEMPORARY !
	//
	hResultCode = DNConnectToPeerFailed(pdnObject,pNTEntry->GetDPNID());
	goto Failure;
#endif

	// Connect to new player
	DPFX(DPFPREP, 5,"Performing Connect");
	DNASSERT(pdnObject->pIDP8ADevice != NULL);
	hResultCode = DNPerformConnect(	pdnObject,
									pNTEntry->GetDPNID(),
									pdnObject->pIDP8ADevice,
									pNTEntry->GetAddress(),
									pSP,
									0,
									NULL);

	if (hResultCode == DPNERR_PENDING)
	{
		hResultCode = DPN_OK;
	}

	pSP->Release();
	pSP = NULL;

	pNTEntry->Release();
	pNTEntry = NULL;

Exit:
	DNASSERT( pSP == NULL );

	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pSP)
	{
		pSP->Release();
		pSP = NULL;
	}
	goto Exit;
}


//	DNConnectToPeer3
//
//	Finish the connection process to the NewPlayer.
//	Once the connection has completed send this player's DNID to NewPlayer and propegate
//	ADD_PLAYER message

#undef DPF_MODNAME
#define DPF_MODNAME "DNConnectToPeer3"

HRESULT	DNConnectToPeer3(DIRECTNETOBJECT *const pdnObject,
						 const DPNID dpnid,
						 CConnection *const pConnection)
{
	HRESULT				hResultCode;
	CNameTableEntry		*pNTEntry;
	CNameTableEntry		*pLocalPlayer;
	CRefCountBuffer		*pRefCountBuffer;
	DN_INTERNAL_MESSAGE_SEND_PLAYER_DPNID	*pSend;

	DPFX(DPFPREP, 4,"Parameters: dpnid [0x%lx], pConnection [0x%p]",dpnid,pConnection);

	DNASSERT(dpnid != NULL);
	DNASSERT(pConnection != NULL);

	pLocalPlayer = NULL;
	pNTEntry = NULL;
	pRefCountBuffer = NULL;

	//
	//	increment players in session
	//
	pdnObject->ApplicationDesc.IncPlayerCount( FALSE );

	// Associate DNID with player's end point handle
	pConnection->Lock();
	pConnection->SetDPNID(dpnid);
	pConnection->SetStatus( CONNECTED );
	pConnection->Unlock();

	//
	//	Get New Players's entry
	//
	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not find new player");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Get Local player's entry
	//
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	// Setup buffer to pass local player's DNID
	if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_SEND_PLAYER_DPNID),
			&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not allocate buffer to send connecting player DPNID");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pSend = reinterpret_cast<DN_INTERNAL_MESSAGE_SEND_PLAYER_DPNID*>(pRefCountBuffer->GetBufferAddress());
	pSend->dpnid = pLocalPlayer->GetDPNID();

	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	// Send player's DNID to new player
	hResultCode = DNSendMessage(pdnObject,
								pConnection,
								DN_MSG_INTERNAL_SEND_PLAYER_DNID,
								dpnid,
								pRefCountBuffer->BufferDescAddress(),
								pRefCountBuffer,
								0,
								DN_SENDFLAGS_RELIABLE,
								NULL,
								NULL);
	if (hResultCode != DPNERR_PENDING)
	{
		DPFERR("Could not send connecting player DPNID");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	//	Update NameTableEntry with Connection
	pdnObject->NameTable.PopulateConnection(pConnection);
	
	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	pNTEntry->Release();
	pNTEntry = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	goto Exit;
}


//	DNConnectToPeerFailed
//
//	An existing player could not connect to a NewPlayer.
//	Send a message to the Host player that this connect attempt failed

#undef DPF_MODNAME
#define DPF_MODNAME "DNConnectToPeerFailed"

HRESULT DNConnectToPeerFailed(DIRECTNETOBJECT *const pdnObject,
							  const DPNID dpnid)
{
	HRESULT			hResultCode;
	CNameTableEntry	*pHost;
	CConnection		*pConnection;
	CRefCountBuffer	*pRCBuffer;
	DN_INTERNAL_MESSAGE_INSTRUCTED_CONNECT_FAILED	*pMsg;

	DPFX(DPFPREP, 4,"Parameters: dpnid [0x%lx]",dpnid);

	DNASSERT(pdnObject != NULL);
	DNASSERT(dpnid != 0);

	pHost = NULL;
	pConnection = NULL;
	pRCBuffer = NULL;

	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHost )) != DPN_OK)
	{
		DPFERR("Could not get Host player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if ((hResultCode = pHost->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		DPFERR("Could not get Host Connection reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Create message
	//
	if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_INSTRUCTED_CONNECT_FAILED),&pRCBuffer)) != DPN_OK)
	{
		DPFERR("Could not create RefCountBuffer");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_INSTRUCTED_CONNECT_FAILED*>(pRCBuffer->GetBufferAddress());
	pMsg->dpnid = dpnid;

	//
	//	Send message
	//
	hResultCode = DNSendMessage(pdnObject,
								pConnection,
								DN_MSG_INTERNAL_INSTRUCTED_CONNECT_FAILED,
								pHost->GetDPNID(),
								pRCBuffer->BufferDescAddress(),
								pRCBuffer,
								0,
								DN_SENDFLAGS_RELIABLE,
								NULL,
								NULL);
	if (hResultCode != DPNERR_PENDING)
	{
		DPFERR("Could not send CONNECT_FAILED message - maybe OUR connection is down !");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Clean up
	//
	pHost->Release();
	pHost = NULL;
	pConnection->Release();
	pConnection = NULL;
	pRCBuffer->Release();
	pRCBuffer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pHost)
	{
		pHost->Release();
		pHost = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pRCBuffer)
	{
		pRCBuffer->Release();
		pRCBuffer = NULL;
	}
	goto Exit;
}


//	DNSendConnectInfo
//
//	Send connection info to a new player.
//	This is the Host Applcation Description and the NameTable
//	This uses an enumeration buffer.
//	The format of the buffer is:
//		<DN_INTERNAL_MESSAGE_CONNECT_INFO>
//		<DN_APPLICATION_DESC>
//		<DN_NAMETABLE_INFO>
//			<DN_NAMETABLE_ENTRY_INFO>
//			<DN_NAMETABLE_ENTRY_INFO>
//				:
//		<strings and data blocks>
//
//	DNID	dnId		DNID of new player

#undef DPF_MODNAME
#define DPF_MODNAME "DNSendConnectInfo"

HRESULT	DNSendConnectInfo(DIRECTNETOBJECT *const pdnObject,
						  CNameTableEntry *const pNTEntry,
						  CConnection *const pConnection,
						  void *const pvReplyBuffer,
						  const DWORD dwReplyBufferSize)
{
	HRESULT					hResultCode;
	CPackedBuffer			packedBuffer;
	CRefCountBuffer			*pRefCountBuffer;
	DN_INTERNAL_MESSAGE_CONNECT_INFO	*pMsg;

	DPFX(DPFPREP, 6,"Parameters: pNTEntry [0x%p], pConnection [0x%p], pvReplyBuffer [0x%p], dwReplyBufferSize [%ld]",
			pNTEntry,pConnection,pvReplyBuffer,dwReplyBufferSize);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pNTEntry != NULL);

	pRefCountBuffer = NULL;

	//
	//	Determine size of message
	//
	packedBuffer.Initialize(NULL,0);
	packedBuffer.AddToFront(NULL,sizeof(DN_INTERNAL_MESSAGE_CONNECT_INFO));
	packedBuffer.AddToBack(NULL,dwReplyBufferSize);
	pdnObject->ApplicationDesc.PackInfo(&packedBuffer,
			DN_APPDESCINFO_FLAG_SESSIONNAME|DN_APPDESCINFO_FLAG_PASSWORD|DN_APPDESCINFO_FLAG_RESERVEDDATA|
			DN_APPDESCINFO_FLAG_APPRESERVEDDATA);
	pdnObject->NameTable.PackNameTable(pNTEntry,&packedBuffer);

	//
	//	Create buffer
	//
	if ((hResultCode = RefCountBufferNew(pdnObject,packedBuffer.GetSizeRequired(),&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not allocate RefCountBuffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	packedBuffer.Initialize(pRefCountBuffer->GetBufferAddress(),pRefCountBuffer->GetBufferSize());

	//
	//	Fill in buffer
	//
	pMsg = static_cast<DN_INTERNAL_MESSAGE_CONNECT_INFO*>(packedBuffer.GetHeadAddress());
	if ((hResultCode = packedBuffer.AddToFront(NULL,sizeof(DN_INTERNAL_MESSAGE_CONNECT_INFO))) != DPN_OK)
	{
		DPFERR("Could not add CONNECT_INFO struct to packed buffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	if ((pvReplyBuffer) && (dwReplyBufferSize != 0))
	{
		if ((hResultCode = packedBuffer.AddToBack(pvReplyBuffer,dwReplyBufferSize)) != DPN_OK)
		{
			DPFERR("Could not add reply buffer to packed buffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pMsg->dwReplyOffset = packedBuffer.GetTailOffset();
		pMsg->dwReplySize = dwReplyBufferSize;
	}
	else
	{
		pMsg->dwReplyOffset = 0;
		pMsg->dwReplySize = 0;
	}

	hResultCode = pdnObject->ApplicationDesc.PackInfo(&packedBuffer,
			DN_APPDESCINFO_FLAG_SESSIONNAME|DN_APPDESCINFO_FLAG_PASSWORD|DN_APPDESCINFO_FLAG_RESERVEDDATA|
			DN_APPDESCINFO_FLAG_APPRESERVEDDATA);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not pack ApplicationDesc");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	if ((hResultCode = pdnObject->NameTable.PackNameTable(pNTEntry,&packedBuffer)) != DPN_OK)
	{
		DPFERR("Could not pack NameTable");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	// Send the name table to target
	hResultCode = DNSendMessage(pdnObject,
								pConnection,
								DN_MSG_INTERNAL_SEND_CONNECT_INFO,
								pNTEntry->GetDPNID(),
								pRefCountBuffer->BufferDescAddress(),
								pRefCountBuffer,
								0,
								DN_SENDFLAGS_RELIABLE,
								NULL,
								NULL);
	if (hResultCode != DPNERR_PENDING)
	{
		DPFERR("Could not send connect info to joining player");
		DisplayDNError(0,hResultCode);
//		DNASSERT(FALSE);
		goto Failure;
	}

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	goto Exit;
}



//	DNReceiveConnectInfo
//
//	Receive connect info from the host/server player.
//	This is the Application Description and the NameTable
//	The name table is in an enum buffer, with relative pointer references which will have
//	to be turned into absolutes.  This process requires two passes of the buffer.
//	The first pass will extract PLAYERS, and the second pass will extract groups.
//
//	PVOID				pvNTBuffer		Pointer to name table enum buffer
//	DWORD				dwNumEntries	Number of entries in the name table

#undef DPF_MODNAME
#define DPF_MODNAME "DNReceiveConnectInfo"

HRESULT	DNReceiveConnectInfo(DIRECTNETOBJECT *const pdnObject,
							 void *const pvBuffer,
							 CConnection *const pHostConnection,
							 DPNID *const pdpnid)
{
	HRESULT		hResultCode;
	void		*pvReplyBuffer;
	DWORD		dwReplyBufferSize;
	UNALIGNED DPN_APPLICATION_DESC_INFO	*pdnAppDescInfo;
	UNALIGNED DN_NAMETABLE_INFO			*pdnNTInfo;
	CRefCountBuffer				*pRefCountBuffer;
	CAsyncOp					*pConnect;
	UNALIGNED DN_INTERNAL_MESSAGE_CONNECT_INFO	*pMsg;

	DPFX(DPFPREP, 6,"Parameters: pvBuffer [0x%p], pHostConnection [0x%p], pdpnid [0x%p]",
			pvBuffer,pHostConnection,pdpnid);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pdpnid != NULL);
	DNASSERT(pvBuffer != NULL);
	DNASSERT(pHostConnection != NULL);

	pRefCountBuffer = NULL;
	pConnect = NULL;

	//
	//	Pull fixed structures from front of buffer
	//
	pMsg = static_cast<DN_INTERNAL_MESSAGE_CONNECT_INFO*>(pvBuffer);
	pdnAppDescInfo = reinterpret_cast<DPN_APPLICATION_DESC_INFO*>(pMsg + 1);
	pdnNTInfo = reinterpret_cast<DN_NAMETABLE_INFO*>(pdnAppDescInfo + 1);

	//
	//	Extract reply buffer
	//
	pvReplyBuffer = static_cast<void*>(static_cast<BYTE*>(pvBuffer) + pMsg->dwReplyOffset);
	dwReplyBufferSize = pMsg->dwReplySize;
	DPFX(DPFPREP, 7,"Reply Buffer [0x%p]=[%s] [%ld]",pvReplyBuffer,pvReplyBuffer,dwReplyBufferSize);
	if ((hResultCode = RefCountBufferNew(pdnObject,dwReplyBufferSize,&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not create RefCountBuffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	memcpy(pRefCountBuffer->GetBufferAddress(),pvReplyBuffer,dwReplyBufferSize);
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->pConnectParent)
	{
		pdnObject->pConnectParent->AddRef();
		pConnect = pdnObject->pConnectParent;
		pConnect->SetRefCountBuffer( pRefCountBuffer );
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	//
	//	Extract Application Description
	//
	DPFX(DPFPREP, 7,"Extracting Application Description");
	hResultCode = pdnObject->ApplicationDesc.UnpackInfo(pdnAppDescInfo,pvBuffer,DN_APPDESCINFO_FLAG_SESSIONNAME |
			DN_APPDESCINFO_FLAG_PASSWORD | DN_APPDESCINFO_FLAG_RESERVEDDATA | DN_APPDESCINFO_FLAG_APPRESERVEDDATA);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not unpack ApplicationDesc");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Set player count (Host and LocalPlayer)
	//
#pragma BUGBUG( minara,"What should happen here ?" )
//	dnAppDesc.dwCurrentPlayers = 2;

	//
	//	Extract NameTable
	//
	DPFX(DPFPREP, 7,"Extracting NameTable");
	DPFX(DPFPREP, 7,"Set DPNID mask to [0x%lx]",pdnObject->ApplicationDesc.GetDPNIDMask());
	pdnObject->NameTable.SetDPNIDMask( pdnObject->ApplicationDesc.GetDPNIDMask() );
	if ((hResultCode = pdnObject->NameTable.UnpackNameTableInfo(pdnNTInfo,static_cast<BYTE*>(pvBuffer),pdpnid)) != DPN_OK)
	{
		DPFERR("Could not unpack NameTable");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
	{
		//
		//	Create ALL_PLAYERS group
		//
		CNameTableEntry	*pAllPlayersGroup;

		pAllPlayersGroup = NULL;

		if ((hResultCode = NameTableEntryNew(pdnObject,&pAllPlayersGroup)) != DPN_OK)
		{
			DPFERR("Could not create NameTableEntry");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pAllPlayersGroup->MakeGroup();

		// This function takes the lock internally
		pAllPlayersGroup->UpdateEntryInfo(	DN_ALL_PLAYERS_GROUP_NAME,
											DN_ALL_PLAYERS_GROUP_NAME_SIZE,
											NULL,
											0,
											DPNINFO_NAME|DPNINFO_DATA,
											FALSE);
		
		pdnObject->NameTable.MakeAllPlayersGroup(pAllPlayersGroup);
		
		pAllPlayersGroup->Release();
		pAllPlayersGroup = NULL;

		DNASSERT(pAllPlayersGroup == NULL);
	}

	if (pConnect)
	{
		pConnect->Release();
		pConnect = NULL;
	}

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pConnect)
	{
		pConnect->SetResult( hResultCode );		// Try and salvage something !
		pConnect->Release();
		pConnect = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNGetClearAddress"

HRESULT DNGetClearAddress(DIRECTNETOBJECT *const pdnObject,
						  const HANDLE hEndPt,
						  IDirectPlay8Address **const ppAddress,
						  const BOOL fPartner)
{
	SPGETADDRESSINFODATA	spInfoData;
	HRESULT					hResultCode;
#ifdef	DEBUG
	CHAR					DP8ABuffer[512];
	DWORD					DP8ASize;
#endif

	DPFX(DPFPREP, 6,"Parameters: hEndPt [0x%p], ppAddress [0x%p], fPartner [%ld]",hEndPt,ppAddress,fPartner);

	DNASSERT(pdnObject != NULL);
	DNASSERT(hEndPt != NULL);
	DNASSERT(ppAddress != NULL);

	if (fPartner)
	{
		spInfoData.Flags = SP_GET_ADDRESS_INFO_REMOTE_HOST;
	}
	else
	{
		spInfoData.Flags = SP_GET_ADDRESS_INFO_LOCAL_HOST_PUBLIC_ADDRESS;
	}

	hResultCode = DNPCrackEndPointDescriptor(hEndPt,&spInfoData);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Unknown error from DNPCrackEndPointDescriptor");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Exit;
	}
	*ppAddress = spInfoData.pAddress;
	spInfoData.pAddress = NULL;

#ifdef	DEBUG
	if (*ppAddress)
	{
		DP8ASize = 512;
		(*ppAddress)->lpVtbl->GetURLA(*ppAddress,DP8ABuffer,&DP8ASize);
		DPFX(DPFPREP, 5,"Remote Address [%s]",DP8ABuffer);
	}
#endif

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNGetLocalDeviceAddress"

HRESULT DNGetLocalDeviceAddress(DIRECTNETOBJECT *const pdnObject,
								const HANDLE hEndPt,
								IDirectPlay8Address **const ppAddress)
{
	SPGETADDRESSINFODATA	spInfoData;
	HRESULT					hResultCode;
#ifdef	DEBUG
	CHAR					DP8ABuffer[512];
	DWORD					DP8ASize;
#endif

	DPFX(DPFPREP, 6,"Parameters: hEndPt [0x%p], ppAddress [0x%p]",hEndPt,ppAddress);

	DNASSERT(pdnObject != NULL);
	DNASSERT(hEndPt != NULL);
	DNASSERT(ppAddress != NULL);

	spInfoData.Flags = SP_GET_ADDRESS_INFO_LOCAL_ADAPTER;

	hResultCode = DNPCrackEndPointDescriptor(hEndPt,&spInfoData);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Unknown error from DNPCrackEndPointDescriptor");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Exit;
	}
	*ppAddress = spInfoData.pAddress;
	spInfoData.pAddress = NULL;

#ifdef	DEBUG
	if (*ppAddress)
	{
		DP8ASize = 512;
		(*ppAddress)->lpVtbl->GetURLA(*ppAddress,DP8ABuffer,&DP8ASize);
		DPFX(DPFPREP, 7,"Remote Address [%s]",DP8ABuffer);
	}
#endif

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\coreclassfac.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ClassFac.cpp
 *  Content:    DNET COM class factory
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/21/99	mjn		Created
 *	12/23/99	mjn		Fixed Host and AllPlayers short-cut pointer use
 *	12/28/99	mjn		Moved Async Op stuff to Async.h
 *	01/06/00	mjn		Moved NameTable stuff to NameTable.h
 *	01/08/00	mjn		Fixed DN_APPLICATION_DESC in DIRECTNETOBJECT
 *	01/13/00	mjn		Added CFixedPools and CRefCountBuffers
 *	01/14/00	mjn		Removed pvUserContext from DN_NAMETABLE_ENTRY
 *	01/15/00	mjn		Replaced DN_COUNT_BUFFER with CRefCountBuffer
 *	01/16/00	mjn		Removed User message fixed pool
 *  01/18/00	mjn		Fixed bug in ref count.
 *	01/19/00	mjn		Replaced DN_SYNC_EVENT with CSyncEvent
 *	01/19/00	mjn		Initialize structures for NameTable Operation List
 *	01/25/00	mjn		Added NameTable pending operation list
 *	01/31/00	mjn		Added Internal FPM's for RefCountBuffers
 *  03/17/00    rmt     Added calls to init/free SP Caps cache
 *	03/23/00	mjn		Implemented RegisterLobby()
 *  04/04/00	rmt		Enabled "Enable Parameter Validation" flag on object by default
 *	04/09/00	mjn		Added support for CAsyncOp
 *	04/11/00	mjn		Added DIRECTNETOBJECT bilink for CAsyncOps
 *	04/26/00	mjn		Removed DN_ASYNC_OP and related functions
 *	04/28/00	mjn		Code cleanup - removed hsAsyncHandles,blAsyncOperations
 *	05/04/00	mjn		Cleaned up and made multi-thread safe
 *  05/23/00    RichGr  IA64: Substituted %p format specifier whereever
 *                      %x was being used to format pointers.  %p is 32-bit
 *                      in a 32-bit build, and 64-bit in a 64-bit build.
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat and support external create funcs
 *	06/20/00	mjn		Fixed QueryInterface bug
 *  06/27/00	rmt		Fixed bug which was causing interfaces to always be created as peer interfaces
 *  07/05/00	rmt		Bug #38478 - Could QI for peer interfaces from client object
 *						(All interfaces could be queried from all types of objects).
 *				mjn		Initialize pConnect element of DIRECNETOBJECT to NULL
 *	07/07/00	mjn		Added pNewHost for DirectNetObject
 *	07/08/00	mjn		Call DN_Close when object is about to be free'd
 *  07/09/00	rmt		Added code to free interface set by RegisterLobby (if there is one)
 *	07/17/00	mjn		Add signature to DirectNetObject
 *  07/21/00    RichGr  IA64: Use %p format specifier for 32/64-bit pointers.
 *	07/26/00	mjn		DN_QueryInterface returns E_POINTER if NULL destination pointer specified
 *	07/28/00	mjn		Added m_bilinkConnections to DirectNetObject
 *	07/30/00	mjn		Added CPendingDeletion
 *	07/31/00	mjn		Added CQueuedMsg
 *	08/05/00	mjn		Added m_bilinkActiveList and csActiveList
 *	08/06/00	mjn		Added CWorkerJob
 *	08/23/00	mjn		Added CNameTableOp
 *	09/04/00	mjn		Added CApplicationDesc
 *  01/11/2001	rmt		MANBUG #48487 - DPLAY: Crashes if CoCreate() isn't called
 *	02/05/01	mjn		Removed unused debug members from DIRECTNETOBJECT
 *				mjn		Added CCallbackThread
 *  03/14/2001  rmt		WINBUG #342420 - Restore COM emulation layer to operation
 *	03/30/01	mjn		Changes to prevent multiple loading/unloading of SP's
 *				mjn		Added pConnectSP,dwMaxFrameSize
 *				mjn		Removed blSPCapsList
 *	04/04/01	mjn		Added voice and lobby sigs
 *	04/13/01	mjn		Added m_bilinkRequestList
 *	05/17/01	mjn		Added dwRunningOpCount,hRunningOpEvent,dwWaitingThreadID to track threads performing NameTable operations
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef	STDMETHODIMP IUnknownQueryInterface( IUnknown *pInterface, REFIID riid, LPVOID *ppvObj );
typedef	STDMETHODIMP_(ULONG)	IUnknownAddRef( IUnknown *pInterface );
typedef	STDMETHODIMP_(ULONG)	IUnknownRelease( IUnknown *pInterface );

//
// VTable for IUnknown interface
//
IUnknownVtbl  DN_UnknownVtbl =
{
	(IUnknownQueryInterface*)	DN_QueryInterface,
	(IUnknownAddRef*)			DN_AddRef,
	(IUnknownRelease*)			DN_Release
};


//
// VTable for Class Factory
//
IDirectNetClassFactVtbl DNCF_Vtbl  =
{
	DNCF_QueryInterface,
	DNCF_AddRef,
	DNCF_Release,
	DNCF_CreateInstance,
	DNCF_LockServer
};

//**********************************************************************
// Variable definitions
//**********************************************************************

extern IDirectNetClassFactVtbl DNCF_Vtbl;
extern IUnknownVtbl  DN_UnknownVtbl;
extern IDirectPlayVoiceTransportVtbl DN_VoiceTbl;

//
// Globals
//
extern	DWORD	GdwHLocks;
extern	DWORD	GdwHObjects;


//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

#undef DPF_MODNAME
#define DPF_MODNAME "DNCF_QueryInterface"

STDMETHODIMP DNCF_QueryInterface(IDirectNetClassFact *pInterface, REFIID riid,LPVOID *ppv)
{
	_LPIDirectNetClassFact	lpcfObj;
	HRESULT				hResultCode = S_OK;

    // 5/23/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPFX(DPFPREP, 2,"Parameters: pInterface [%p], riid [%p], ppv [%p]",pInterface,&riid,ppv);

	lpcfObj = (_LPIDirectNetClassFact)pInterface;
	if (IsEqualIID(riid,IID_IUnknown))
	{
		DPFX(DPFPREP, 3,"riid = IID_IUnknown");
		*ppv = pInterface;
		lpcfObj->lpVtbl->AddRef( pInterface );
	}
	else if (IsEqualIID(riid,IID_IClassFactory))
	{
		DPFX(DPFPREP, 3,"riid = IID_IClassFactory");
		*ppv = pInterface;
		lpcfObj->lpVtbl->AddRef( pInterface );
	}
	else
	{
		DPFX(DPFPREP, 3,"riid not found !");
		*ppv = NULL;
		hResultCode = E_NOINTERFACE;
	}

    // 5/23/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPFX(DPFPREP, 2,"Returning: hResultCode = [%lx], *ppv = [%p]",hResultCode,*ppv);

	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCF_AddRef"

STDMETHODIMP_(ULONG) DNCF_AddRef(IDirectNetClassFact *pInterface)
{
	_LPIDirectNetClassFact	lpcfObj;

    // 5/23/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPFX(DPFPREP, 2,"Parameters: pInterface [%p]",pInterface);

	lpcfObj = (_LPIDirectNetClassFact)pInterface;
	lpcfObj->dwRefCount++;

	DPFX(DPFPREP, 2,"Returning: lpcfObj->dwRefCount = [%lx]",lpcfObj->dwRefCount);

	return(lpcfObj->dwRefCount);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCF_Release"

STDMETHODIMP_(ULONG) DNCF_Release(IDirectNetClassFact *pInterface)
{
	_LPIDirectNetClassFact	lpcfObj;

    // 5/23/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPFX(DPFPREP, 2,"Parameters: pInterface [%p]",pInterface);

	lpcfObj = (_LPIDirectNetClassFact)pInterface;
	DPFX(DPFPREP, 3,"Original : lpcfObj->dwRefCount = %ld",lpcfObj->dwRefCount);
	lpcfObj->dwRefCount--;
	if (lpcfObj->dwRefCount == 0)
	{
        // 5/23/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
		DPFX(DPFPREP, 3,"Freeing class factory object: lpcfObj [%p]",lpcfObj);
		DNFree(lpcfObj);

		GdwHObjects--;

		return(0);
	}
	DPFX(DPFPREP, 2,"Returning: lpcfObj->dwRefCount = [%lx]",lpcfObj->dwRefCount);

	return(lpcfObj->dwRefCount);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNCF_CreateObject"

HRESULT DNCF_CreateObject(IDirectNetClassFact *pInterface, LPVOID *lplpv,REFIID riid)
{
	HRESULT				hResultCode = S_OK;
	DIRECTNETOBJECT		*pdnObject = NULL;
    _LPIDirectNetClassFact pcfObj = (_LPIDirectNetClassFact)pInterface;	

    // 5/23/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPFX(DPFPREP, 4,"Parameters: lplpv [%p]",lplpv);


	/*
	*
	*	TIME BOMB
	*
	*/

#ifndef DX_FINAL_RELEASE
{
#pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
	SYSTEMTIME st;
	GetSystemTime(&st);

	if ( st.wYear > DX_EXPIRE_YEAR || ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))) )
	{
		MessageBox(0, DX_EXPIRE_TEXT,TEXT("Microsoft Direct Play"), MB_OK);
//		return E_FAIL;
	}
}
#endif

    if( pcfObj->clsid == CLSID_DirectPlay8Client )
	{
		if( riid != IID_IDirectPlay8Client &&
			riid != IID_IUnknown &&
			riid != IID_IDirectPlayVoiceTransport )
		{
			DPFX(DPFPREP,  0, "Requesting unknown interface from client CLSID" );
			return E_NOINTERFACE;
		}
	}
	else if( pcfObj->clsid == CLSID_DirectPlay8Server )
	{
		if( riid != IID_IDirectPlay8Server &&
			riid != IID_IUnknown &&
			riid != IID_IDirectPlayVoiceTransport &&
			riid != IID_IDirectPlay8Protocol )
		{
			DPFX(DPFPREP,  0, "Requesting unknown interface from server CLSID" );
			return E_NOINTERFACE;
		}
	}
	else if( pcfObj->clsid == CLSID_DirectPlay8Peer )
	{
		if( riid != IID_IDirectPlay8Peer &&
			riid != IID_IUnknown &&
			riid != IID_IDirectPlayVoiceTransport )
		{
			DPFX(DPFPREP,  0, "Requesting unknown interface from peer CLSID" );
			return E_NOINTERFACE;
		}
	}

	// Allocate object
	pdnObject = new DIRECTNETOBJECT;
	if (pdnObject == NULL)
	{
		DPFERR("DNMalloc() failed");
		return(E_OUTOFMEMORY);
	}
    // 5/23/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPFX(DPFPREP, 0,"pdnObject [%p]",pdnObject);

	//
	//	Signatures
	//
	pdnObject->Sig[0] = 'D';
	pdnObject->Sig[1] = 'N';
	pdnObject->Sig[2] = 'E';
	pdnObject->Sig[3] = 'T';

	pdnObject->VoiceSig[0] = 'V';
	pdnObject->VoiceSig[1] = 'O';
	pdnObject->VoiceSig[2] = 'I';
	pdnObject->VoiceSig[3] = 'C';

	pdnObject->LobbySig[0] = 'L';
	pdnObject->LobbySig[1] = 'O';
	pdnObject->LobbySig[2] = 'B';
	pdnObject->LobbySig[3] = 'B';

	//
	//	Set allocatable elements to NULL to simplify free'ing later on
	//
	pdnObject->dwLockCount = 0;
	pdnObject->hLockEvent = NULL;
	pdnObject->pdnProtocolData = NULL;
	pdnObject->hWorkerEvent = NULL;
	pdnObject->hWorkerThread = NULL;
	pdnObject->pListenParent = NULL;
	pdnObject->pConnectParent = NULL;
	pdnObject->pvConnectData = NULL;
	pdnObject->dwConnectDataSize = 0;
	pdnObject->pConnectSP = NULL;
	pdnObject->pIDP8ADevice = NULL;
	pdnObject->pIDP8AEnum = NULL;
	pdnObject->pIDP8LobbiedApplication = NULL;
	pdnObject->dpnhLobbyConnection = NULL;
	pdnObject->m_pFPOOLAsyncOp = NULL;
	pdnObject->m_pFPOOLConnection = NULL;
	pdnObject->m_pFPOOLGroupConnection = NULL;
	pdnObject->m_pFPOOLGroupMember = NULL;
	pdnObject->m_pFPOOLNameTableEntry = NULL;
	pdnObject->m_pFPOOLNameTableOp = NULL;
	pdnObject->m_pFPOOLPendingDeletion = NULL;
	pdnObject->m_pFPOOLQueuedMsg = NULL;
	pdnObject->m_pFPOOLRefCountBuffer = NULL;
	pdnObject->m_pFPOOLSyncEvent = NULL;
	pdnObject->m_pFPOOLWorkerJob = NULL;
	pdnObject->m_pFPOOLMemoryBlockTiny = NULL;
	pdnObject->m_pFPOOLMemoryBlockSmall = NULL;
	pdnObject->m_pFPOOLMemoryBlockMedium = NULL;
	pdnObject->m_pFPOOLMemoryBlockLarge = NULL;
	pdnObject->m_pFPOOLMemoryBlockHuge = NULL;
	pdnObject->pNewHost = NULL;
	pdnObject->dwRunningOpCount = 0;
	pdnObject->hRunningOpEvent = NULL;
	pdnObject->dwWaitingThreadID = 0;
	pdnObject->pConnectAddress = NULL;
	pdnObject->nTargets = 0;
	pdnObject->nTargetListLen = 0;
	pdnObject->pTargetList = NULL;
	pdnObject->nExpandedTargets = 0;       
	pdnObject->nExpandedTargetListLen = 0;
	pdnObject->pExpandedTargetList = NULL;
	

	// Voice Additions
    pdnObject->lpDxVoiceNotifyClient = NULL;	
    pdnObject->lpDxVoiceNotifyServer = NULL;
	pdnObject->pTargetList = NULL;
	pdnObject->pExpandedTargetList = NULL;

	// Initialize Critical Section
	if (!DNInitializeCriticalSection(&(pdnObject->csDirectNetObject)))
	{
		DPFERR("DNInitializeCriticalSection() failed");
		DNCF_FreeObject(pdnObject);
		return(E_OUTOFMEMORY);
	}

	if (!DNInitializeCriticalSection(&(pdnObject->csServiceProviders)))
	{
		DPFERR("DNInitializeCriticalSection() failed");
		DNCF_FreeObject(pdnObject);
		return(E_OUTOFMEMORY);
	}

	if (!DNInitializeCriticalSection(&(pdnObject->csNameTableOpList)))
	{
		DPFERR("DNInitializeCriticalSection() failed");
		DNCF_FreeObject(pdnObject);
		return(E_OUTOFMEMORY);
	}

	if (!DNInitializeCriticalSection(&(pdnObject->csAsyncOperations)))
	{
		DPFERR("DNInitializeCriticalSection() failed");
		DNCF_FreeObject(pdnObject);
		return(E_OUTOFMEMORY);
	}

	if (!DNInitializeCriticalSection(&(pdnObject->csVoice)))
	{
		DPFERR("DNInitializeCriticalSection() failed");
		DNCF_FreeObject(pdnObject);
		return(E_OUTOFMEMORY);
	}

	if (!DNInitializeCriticalSection(&(pdnObject->csWorkerQueue)))
	{
		DPFERR("DNInitializeCriticalSection(worker queue) failed");
		DNCF_FreeObject(pdnObject);
		return(E_OUTOFMEMORY);
	}

	if (!DNInitializeCriticalSection(&(pdnObject->csActiveList)))
	{
		DPFERR("DNInitializeCriticalSection(csActiveList) failed");
		DNCF_FreeObject(pdnObject);
		return(E_OUTOFMEMORY);
	}

	if (!DNInitializeCriticalSection(&(pdnObject->csConnectionList)))
	{
		DPFERR("DNInitializeCriticalSection(csConnectionList) failed");
		DNCF_FreeObject(pdnObject);
		return(E_OUTOFMEMORY);
	}

	if (!DNInitializeCriticalSection(&(pdnObject->csCallbackThreads)))
	{
		DPFERR("DNInitializeCriticalSection(csCallbackThreads) failed");
		DNCF_FreeObject(pdnObject);
		return(E_OUTOFMEMORY);
	}

	pdnObject->dwFlags = DN_OBJECT_FLAG_PARAMVALIDATION;

	// Initialize Fixed Pool for AsyncOps
	pdnObject->m_pFPOOLAsyncOp = new CLockedContextClassFixedPool< CAsyncOp >;
	if (pdnObject->m_pFPOOLAsyncOp == NULL)
	{
		DPFERR("Allocating pool failed");
		DNCF_FreeObject(pdnObject);
		return(E_OUTOFMEMORY);
	}
	pdnObject->m_pFPOOLAsyncOp->Initialize(	CAsyncOp::FPMAlloc,
											CAsyncOp::FPMInitialize,
											CAsyncOp::FPMRelease,
											CAsyncOp::FPMDealloc );

	// Initialize Fixed Pool for RefCountBuffers
	pdnObject->m_pFPOOLRefCountBuffer = new CLockedContextClassFixedPool< CRefCountBuffer >;
	if (pdnObject->m_pFPOOLRefCountBuffer == NULL)
	{
		DPFERR("Allocating pool failed");
		DNCF_FreeObject(pdnObject);
		return(E_OUTOFMEMORY);
	}
	pdnObject->m_pFPOOLRefCountBuffer->Initialize(	CRefCountBuffer::FPMAlloc,
													CRefCountBuffer::FPMInitialize,
													CRefCountBuffer::FPMRelease,
													CRefCountBuffer::FPMDealloc );

	// Initialize Fixed Pool for SyncEvents
	pdnObject->m_pFPOOLSyncEvent = new CLockedContextClassFixedPool< CSyncEvent >;
	if (pdnObject->m_pFPOOLSyncEvent == NULL)
	{
		DPFERR("Allocating pool failed");
		DNCF_FreeObject(pdnObject);
		return(E_OUTOFMEMORY);
	}
	pdnObject->m_pFPOOLSyncEvent->Initialize(	CSyncEvent::FPMAlloc,
												CSyncEvent::FPMInitialize,
												CSyncEvent::FPMRelease,
												CSyncEvent::FPMDealloc );

	// Initialize Fixed Pool for Connections
	pdnObject->m_pFPOOLConnection = new CLockedContextClassFixedPool< CConnection >;
	if (pdnObject->m_pFPOOLConnection == NULL)
	{
		DPFERR("Allocating pool failed");
		DNCF_FreeObject(pdnObject);
		return(E_OUTOFMEMORY);
	}
	pdnObject->m_pFPOOLConnection->Initialize(	CConnection::FPMAlloc,
												CConnection::FPMInitialize,
												CConnection::FPMRelease,
												CConnection::FPMDealloc );

	// Initialize Fixed Pool for Group Connections
	pdnObject->m_pFPOOLGroupConnection = new CLockedContextClassFixedPool< CGroupConnection >;
	if (pdnObject->m_pFPOOLGroupConnection == NULL)
	{
		DPFERR("Allocating pool failed");
		DNCF_FreeObject(pdnObject);
		return(E_OUTOFMEMORY);
	}
	pdnObject->m_pFPOOLGroupConnection->Initialize(	CGroupConnection::FPMAlloc,
													CGroupConnection::FPMInitialize,
													CGroupConnection::FPMRelease,
													CGroupConnection::FPMDealloc );

	// Initialize Fixed Pool for Group Members
	pdnObject->m_pFPOOLGroupMember = new CLockedContextClassFixedPool< CGroupMember >;
	if (pdnObject->m_pFPOOLGroupMember == NULL)
	{
		DPFERR("Allocating pool failed");
		DNCF_FreeObject(pdnObject);
		return(E_OUTOFMEMORY);
	}
	pdnObject->m_pFPOOLGroupMember->Initialize(	CGroupMember::FPMAlloc,
												CGroupMember::FPMInitialize,
												CGroupMember::FPMRelease,
												CGroupMember::FPMDealloc );

	// Initialize Fixed Pool for NameTable Entries
	pdnObject->m_pFPOOLNameTableEntry = new CLockedContextClassFixedPool< CNameTableEntry >;
	if (pdnObject->m_pFPOOLNameTableEntry == NULL)
	{
		DPFERR("Allocating pool failed");
		DNCF_FreeObject(pdnObject);
		return(E_OUTOFMEMORY);
	}
	pdnObject->m_pFPOOLNameTableEntry->Initialize(	CNameTableEntry::FPMAlloc,
													CNameTableEntry::FPMInitialize,
													CNameTableEntry::FPMRelease,
													CNameTableEntry::FPMDealloc );

	// Initialize Fixed Pool for NameTable Ops
	pdnObject->m_pFPOOLNameTableOp = new CLockedContextClassFixedPool< CNameTableOp >;
	if (pdnObject->m_pFPOOLNameTableOp == NULL)
	{
		DPFERR("Allocating pool failed");
		DNCF_FreeObject(pdnObject);
		return(E_OUTOFMEMORY);
	}
	pdnObject->m_pFPOOLNameTableOp->Initialize(	CNameTableOp::FPMAlloc,
												CNameTableOp::FPMInitialize,
												CNameTableOp::FPMRelease,
												CNameTableOp::FPMDealloc );

	// Initialize Fixed Pool for NameTable Pending Deletions
	pdnObject->m_pFPOOLPendingDeletion = new CLockedContextClassFixedPool< CPendingDeletion >;
	if (pdnObject->m_pFPOOLPendingDeletion == NULL)
	{
		DPFERR("Allocating pool failed");
		DNCF_FreeObject(pdnObject);
		return(E_OUTOFMEMORY);
	}
	pdnObject->m_pFPOOLPendingDeletion->Initialize(	CPendingDeletion::FPMAlloc,
													CPendingDeletion::FPMInitialize,
													CPendingDeletion::FPMRelease,
													CPendingDeletion::FPMDealloc );

	// Initialize Fixed Pool for Queued Messages
	pdnObject->m_pFPOOLQueuedMsg = new CLockedContextClassFixedPool< CQueuedMsg >;
	if (pdnObject->m_pFPOOLQueuedMsg == NULL)
	{
		DPFERR("Allocating pool failed");
		DNCF_FreeObject(pdnObject);
		return(E_OUTOFMEMORY);
	}
	pdnObject->m_pFPOOLQueuedMsg->Initialize(	CQueuedMsg::FPMAlloc,
												CQueuedMsg::FPMInitialize,
												CQueuedMsg::FPMRelease,
												CQueuedMsg::FPMDealloc );

	// Initialize Fixed Pool for Worker Thread Jobs
	pdnObject->m_pFPOOLWorkerJob = new CLockedContextClassFixedPool< CWorkerJob >;
	if (pdnObject->m_pFPOOLWorkerJob == NULL)
	{
		DPFERR("Allocating pool failed");
		DNCF_FreeObject(pdnObject);
		return(E_OUTOFMEMORY);
	}
	pdnObject->m_pFPOOLWorkerJob->Initialize(	CWorkerJob::FPMAlloc,
												CWorkerJob::FPMInitialize,
												CWorkerJob::FPMRelease,
												CWorkerJob::FPMDealloc );

	// Initialize Fixed Pool for memory blocks
	pdnObject->m_pFPOOLMemoryBlockTiny = new CLockedContextClassFixedPool< CMemoryBlockTiny >;
	if (pdnObject->m_pFPOOLMemoryBlockTiny == NULL)
	{
		DPFERR("Allocating pool failed");
		DNCF_FreeObject(pdnObject);
		return(E_OUTOFMEMORY);
	}
	pdnObject->m_pFPOOLMemoryBlockTiny->Initialize(	CMemoryBlockTiny::FPMAlloc,
													CMemoryBlockTiny::FPMInitialize,
													CMemoryBlockTiny::FPMRelease,
													CMemoryBlockTiny::FPMDealloc );

	pdnObject->m_pFPOOLMemoryBlockSmall = new CLockedContextClassFixedPool< CMemoryBlockSmall >;
	if (pdnObject->m_pFPOOLMemoryBlockSmall == NULL)
	{
		DPFERR("Allocating pool failed");
		DNCF_FreeObject(pdnObject);
		return(E_OUTOFMEMORY);
	}
	pdnObject->m_pFPOOLMemoryBlockSmall->Initialize(CMemoryBlockSmall::FPMAlloc,
													CMemoryBlockSmall::FPMInitialize,
													CMemoryBlockSmall::FPMRelease,
													CMemoryBlockSmall::FPMDealloc );

	pdnObject->m_pFPOOLMemoryBlockMedium = new CLockedContextClassFixedPool< CMemoryBlockMedium >;
	if (pdnObject->m_pFPOOLMemoryBlockMedium == NULL)
	{
		DPFERR("Allocating pool failed");
		DNCF_FreeObject(pdnObject);
		return(E_OUTOFMEMORY);
	}
	pdnObject->m_pFPOOLMemoryBlockMedium->Initialize(CMemoryBlockMedium::FPMAlloc,
													CMemoryBlockMedium::FPMInitialize,
													CMemoryBlockMedium::FPMRelease,
													CMemoryBlockMedium::FPMDealloc );

	pdnObject->m_pFPOOLMemoryBlockLarge = new CLockedContextClassFixedPool< CMemoryBlockLarge >;
	if (pdnObject->m_pFPOOLMemoryBlockLarge == NULL)
	{
		DPFERR("Allocating pool failed");
		DNCF_FreeObject(pdnObject);
		return(E_OUTOFMEMORY);
	}
	pdnObject->m_pFPOOLMemoryBlockLarge->Initialize(CMemoryBlockLarge::FPMAlloc,
													CMemoryBlockLarge::FPMInitialize,
													CMemoryBlockLarge::FPMRelease,
													CMemoryBlockLarge::FPMDealloc );

	pdnObject->m_pFPOOLMemoryBlockHuge = new CLockedContextClassFixedPool< CMemoryBlockHuge >;
	if (pdnObject->m_pFPOOLMemoryBlockHuge == NULL)
	{
		DPFERR("Allocating pool failed");
		DNCF_FreeObject(pdnObject);
		return(E_OUTOFMEMORY);
	}
	pdnObject->m_pFPOOLMemoryBlockHuge->Initialize(	CMemoryBlockHuge::FPMAlloc,
													CMemoryBlockHuge::FPMInitialize,
													CMemoryBlockHuge::FPMRelease,
													CMemoryBlockHuge::FPMDealloc );

	//
	//	Create Protocol Object
	//
	if ((pdnObject->pdnProtocolData = reinterpret_cast<PProtocolData>(DNMalloc(sizeof(ProtocolData)))) == NULL)
	{
		DPFERR("DNMalloc() failed");
		DNCF_FreeObject(pdnObject);
		return(E_OUTOFMEMORY);
	}
	pdnObject->hProtocolShutdownEvent = NULL;
	pdnObject->lProtocolRefCount = 0;

	// Initialize SP List
	pdnObject->m_bilinkServiceProviders.Initialize();

	//
	//	Initialize AsyncOp List
	//
	pdnObject->m_bilinkAsyncOps.Initialize();

	//
	//	Initialize outstanding CConection list
	//
	pdnObject->m_bilinkConnections.Initialize();

	//
	//	Initialize pending deletion list
	//
	pdnObject->m_bilinkPendingDeletions.Initialize();

	//
	//	Initialize active AsyncOp list
	//
	pdnObject->m_bilinkActiveList.Initialize();

	//
	//	Initialize request AsyncOp list
	//
	pdnObject->m_bilinkRequestList.Initialize();

	//
	//	Initialize worker thread job list
	//
	pdnObject->m_bilinkWorkerJobs.Initialize();

	//
	//	Initialize indicated connection list
	//
	pdnObject->m_bilinkIndicated.Initialize();

	//
	//	Initialize callback thread list
	//
	pdnObject->m_bilinkCallbackThreads.Initialize();

	// Setup Flags
	if (IsEqualIID(riid,IID_IDirectPlay8Client))
	{
		DPFX(DPFPREP, 5,"DirectPlay8 CLIENT");
		pdnObject->dwFlags |= DN_OBJECT_FLAG_CLIENT;
	}
	else if (IsEqualIID(riid,IID_IDirectPlay8Server))
	{
		DPFX(DPFPREP, 5,"DirectPlay8 SERVER");
		pdnObject->dwFlags |= DN_OBJECT_FLAG_SERVER;
	}
	else if (IsEqualIID(riid,IID_IDirectPlay8Peer))
	{
		DPFX(DPFPREP, 5,"DirectPlay8 PEER");
		pdnObject->dwFlags |= DN_OBJECT_FLAG_PEER;
	}
	else if (IsEqualIID(riid,IID_IDirectPlay8Protocol))
	{
		DPFX(DPFPREP, 5,"IDirectPlay8Protocol");
	}
	else if( riid == IID_IUnknown )
	{
    	if( pcfObj->clsid == CLSID_DirectPlay8Client )
    	{
    		DPFX(DPFPREP, 5,"DirectPlay8 CLIENT via IUnknown");
    		pdnObject->dwFlags |= DN_OBJECT_FLAG_CLIENT;
    	}
    	else if( pcfObj->clsid == CLSID_DirectPlay8Server )
    	{
    		DPFX(DPFPREP, 5,"DirectPlay8 SERVER via IUnknown");
    		pdnObject->dwFlags |= DN_OBJECT_FLAG_SERVER;
    	}
    	else if( pcfObj->clsid == CLSID_DirectPlay8Peer )
    	{
    		DPFX(DPFPREP, 5,"DirectPlay8 PEER via IUnknown");
    		pdnObject->dwFlags |= DN_OBJECT_FLAG_PEER;
    	}
		else
		{
    		DPFX(DPFPREP, 0,"Unknown CLSID!");
    		DNASSERT( FALSE );
		}
	}
	else
	{
		DPFX(DPFPREP, 0,"Invalid DirectPlay8 Interface");
		DNCF_FreeObject(pdnObject);
		hResultCode = E_NOTIMPL;
	}

	//
	//	Create worker thread event
	//
	if ((pdnObject->hWorkerEvent = CreateEvent(NULL,TRUE,FALSE,NULL)) == NULL)
	{
		DPFERR("Could not create worker thread event");
		DNCF_FreeObject(pdnObject);
		return(DPNERR_OUTOFMEMORY);
	}

	//
	//	Create lock event
	//
	if ((pdnObject->hLockEvent = CreateEvent(NULL,TRUE,FALSE,NULL)) == NULL)
	{
		DPFERR("Unable to create lock event");
		DNCF_FreeObject(pdnObject);
		return(DPNERR_OUTOFMEMORY);
	}

	//
	//	Create running operation event (for host migration)
	//
    if ( pcfObj->clsid == CLSID_DirectPlay8Peer )
	{
		if ((pdnObject->hRunningOpEvent = CreateEvent(NULL,TRUE,FALSE,NULL)) == NULL)
		{
			DPFERR("Unable to create running operation event");
			DNCF_FreeObject(pdnObject);
			return(DPNERR_OUTOFMEMORY);
		}
	}

	*lplpv = pdnObject;

    // 5/23/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPFX(DPFPREP, 4,"Returning: hResultCode = [%lx], *lplpv = [%p]",hResultCode,*lplpv);
	return(hResultCode);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DirectPlay8Create"
HRESULT WINAPI DirectPlay8Create( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown)
{
    GUID clsid;
    
    if( pcIID == NULL ||
        !DNVALID_READPTR( pcIID, sizeof( GUID ) ) )
    {
        DPFERR( "Invalid pointer specified for interface GUID" );
        return DPNERR_INVALIDPOINTER;
    }

    if( *pcIID != IID_IDirectPlay8Client &&
        *pcIID != IID_IDirectPlay8Server &&
        *pcIID != IID_IDirectPlay8Peer )
    {
        DPFERR("Interface ID is not recognized" );
        return DPNERR_INVALIDPARAM;
    }

    if( ppvInterface == NULL || !DNVALID_WRITEPTR( ppvInterface, sizeof( void * ) ) )
    {
        DPFERR( "Invalid pointer specified to receive interface" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pUnknown != NULL )
    {
        DPFERR( "Aggregation is not supported by this object yet" );
        return DPNERR_INVALIDPARAM;
    }

    if( *pcIID == IID_IDirectPlay8Client )
    {
    	clsid = CLSID_DirectPlay8Client;
    }
    else if( *pcIID == IID_IDirectPlay8Server )
    {
    	clsid = CLSID_DirectPlay8Server;
    }
    else if( *pcIID == IID_IDirectPlay8Peer )
    {
    	clsid = CLSID_DirectPlay8Peer;
    }
    else 
    {
    	DPFERR( "Invalid IID specified" );
    	return DPNERR_INVALIDINTERFACE;
    }

    return COM_CoCreateInstance( clsid, NULL, CLSCTX_INPROC_SERVER, *pcIID, ppvInterface, TRUE );  
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCF_FreeObject"

HRESULT DNCF_FreeObject(PVOID pInterface)
{
	HRESULT				hResultCode = S_OK;
	DIRECTNETOBJECT		*pdnObject;
	
    // 5/23/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPFX(DPFPREP, 4,"Parameters: pInterface [0x%p]",pInterface);

#pragma BUGBUG(minara,"Do I need to delete the fixed pools here ?")

	if (pInterface == NULL)
	{
		return(DPNERR_INVALIDPARAM);
	}

	pdnObject = static_cast<DIRECTNETOBJECT*>(pInterface);
	DNASSERT(pdnObject != NULL);

	//
	//	No connect SP
	//
	DNASSERT(pdnObject->pConnectSP == NULL);

	//
	//	No outstanding listens
	//
	DNASSERT(pdnObject->pListenParent == NULL);

	//
	//	No outstanding connect
	//
	DNASSERT(pdnObject->pConnectParent == NULL);

	//
	//	Host migration target
	//
	DNASSERT(pdnObject->pNewHost == NULL);

	//
	//	Protocol shutdown event
	//
	DNASSERT(pdnObject->hProtocolShutdownEvent == NULL);

	//
	//	Lock event
	//
	if (pdnObject->hLockEvent)
	{
		CloseHandle(pdnObject->hLockEvent);
	}

	//
	//	Running operations
	//
	if (pdnObject->hRunningOpEvent)
	{
		CloseHandle(pdnObject->hRunningOpEvent);
	}

	//
	//	Worker Thread Queue
	//
	if (pdnObject->hWorkerEvent)
	{
		CloseHandle(pdnObject->hWorkerEvent);
	}
	DNDeleteCriticalSection(&pdnObject->csWorkerQueue);

	//
	//	Protocol
	//
	if (pdnObject->pdnProtocolData != NULL)
	{
		DNFree(pdnObject->pdnProtocolData);
	}

	// Active AsyncOp List Critical Section
	DNDeleteCriticalSection(&pdnObject->csActiveList);

	// NameTable operation list Critical Section
	DNDeleteCriticalSection(&pdnObject->csNameTableOpList);

	// Service Providers Critical Section
	DNDeleteCriticalSection(&pdnObject->csServiceProviders);

	// Async Ops Critical Section
	DNDeleteCriticalSection(&pdnObject->csAsyncOperations);

	// Connection Critical Section
	DNDeleteCriticalSection(&pdnObject->csConnectionList);

	// Voice Critical Section
	DNDeleteCriticalSection(&pdnObject->csVoice);

	// Callback Thread List Critical Section
	DNDeleteCriticalSection(&pdnObject->csCallbackThreads);

	//
	// Deinitialize and delete fixed pools
	//
	if (pdnObject->m_pFPOOLAsyncOp)
	{
		pdnObject->m_pFPOOLAsyncOp->Deinitialize();
		delete pdnObject->m_pFPOOLAsyncOp;
		pdnObject->m_pFPOOLAsyncOp = NULL;
	}

	if (pdnObject->m_pFPOOLRefCountBuffer)
	{
		pdnObject->m_pFPOOLRefCountBuffer->Deinitialize();
		delete pdnObject->m_pFPOOLRefCountBuffer;
		pdnObject->m_pFPOOLRefCountBuffer = NULL;
	}

	if (pdnObject->m_pFPOOLSyncEvent)
	{
		pdnObject->m_pFPOOLSyncEvent->Deinitialize();
		delete pdnObject->m_pFPOOLSyncEvent;
		pdnObject->m_pFPOOLSyncEvent = NULL;
	}

	if (pdnObject->m_pFPOOLConnection)
	{
		pdnObject->m_pFPOOLConnection->Deinitialize();
		delete pdnObject->m_pFPOOLConnection;
		pdnObject->m_pFPOOLConnection = NULL;
	}

	if (pdnObject->m_pFPOOLGroupConnection)
	{
		pdnObject->m_pFPOOLGroupConnection->Deinitialize();
		delete pdnObject->m_pFPOOLGroupConnection;
		pdnObject->m_pFPOOLGroupConnection = NULL;
	}

	if (pdnObject->m_pFPOOLGroupMember)
	{
		pdnObject->m_pFPOOLGroupMember->Deinitialize();
		delete pdnObject->m_pFPOOLGroupMember;
		pdnObject->m_pFPOOLGroupMember = NULL;
	}

	if (pdnObject->m_pFPOOLNameTableEntry)
	{
		pdnObject->m_pFPOOLNameTableEntry->Deinitialize();
		delete pdnObject->m_pFPOOLNameTableEntry;
		pdnObject->m_pFPOOLNameTableEntry = NULL;
	}

	if (pdnObject->m_pFPOOLNameTableOp)
	{
		pdnObject->m_pFPOOLNameTableOp->Deinitialize();
		delete pdnObject->m_pFPOOLNameTableOp;
		pdnObject->m_pFPOOLNameTableOp = NULL;
	}

	if (pdnObject->m_pFPOOLPendingDeletion)
	{
		pdnObject->m_pFPOOLPendingDeletion->Deinitialize();
		delete pdnObject->m_pFPOOLPendingDeletion;
		pdnObject->m_pFPOOLPendingDeletion = NULL;
	}

	if (pdnObject->m_pFPOOLQueuedMsg)
	{
		pdnObject->m_pFPOOLQueuedMsg->Deinitialize();
		delete pdnObject->m_pFPOOLQueuedMsg;
		pdnObject->m_pFPOOLQueuedMsg = NULL;
	}

	if (pdnObject->m_pFPOOLWorkerJob)
	{
		pdnObject->m_pFPOOLWorkerJob->Deinitialize();
		delete pdnObject->m_pFPOOLWorkerJob;
		pdnObject->m_pFPOOLWorkerJob = NULL;
	}

	if (pdnObject->m_pFPOOLMemoryBlockTiny)
	{
		pdnObject->m_pFPOOLMemoryBlockTiny->Deinitialize();
		delete pdnObject->m_pFPOOLMemoryBlockTiny;
		pdnObject->m_pFPOOLMemoryBlockTiny = NULL;
	}

	if (pdnObject->m_pFPOOLMemoryBlockSmall)
	{
		pdnObject->m_pFPOOLMemoryBlockSmall->Deinitialize();
		delete pdnObject->m_pFPOOLMemoryBlockSmall;
		pdnObject->m_pFPOOLMemoryBlockSmall = NULL;
	}

	if (pdnObject->m_pFPOOLMemoryBlockMedium)
	{
		pdnObject->m_pFPOOLMemoryBlockMedium->Deinitialize();
		delete pdnObject->m_pFPOOLMemoryBlockMedium;
		pdnObject->m_pFPOOLMemoryBlockMedium = NULL;
	}

	if (pdnObject->m_pFPOOLMemoryBlockLarge)
	{
		pdnObject->m_pFPOOLMemoryBlockLarge->Deinitialize();
		delete pdnObject->m_pFPOOLMemoryBlockLarge;
		pdnObject->m_pFPOOLMemoryBlockLarge = NULL;
	}

	if (pdnObject->m_pFPOOLMemoryBlockHuge)
	{
		pdnObject->m_pFPOOLMemoryBlockHuge->Deinitialize();
		delete pdnObject->m_pFPOOLMemoryBlockHuge;
		pdnObject->m_pFPOOLMemoryBlockHuge = NULL;
	}

	if( pdnObject->pIDP8LobbiedApplication)
	{
		pdnObject->pIDP8LobbiedApplication->lpVtbl->Release( pdnObject->pIDP8LobbiedApplication );
		pdnObject->pIDP8LobbiedApplication = NULL;
	}

	// Delete DirectNet critical section
	DNDeleteCriticalSection(&pdnObject->csDirectNetObject);

	// Enum listen address
	if (pdnObject->pIDP8AEnum != NULL)
	{
		pdnObject->pIDP8AEnum->lpVtbl->Release(pdnObject->pIDP8AEnum);
		pdnObject->pIDP8AEnum = NULL;
	}

    // 5/23/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPFX(DPFPREP, 5,"free pdnObject [%p]",pdnObject);
	delete pdnObject;

	DPFX(DPFPREP, 4,"Returning: [%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCF_CreateInstance"

STDMETHODIMP DNCF_CreateInstance(IDirectNetClassFact *pInterface,
								 LPUNKNOWN lpUnkOuter,
								 REFIID riid,
								 void **ppv)
{
	HRESULT				hResultCode;
	INTERFACE_LIST		*pIntList;
	OBJECT_DATA			*pObjectData;

    // 5/23/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPFX(DPFPREP, 6,"Parameters: pInterface [%p], lpUnkOuter [%p], riid [%p], ppv [%p]",pInterface,lpUnkOuter,&riid,ppv);

	if (pInterface == NULL)
	{
		DPFERR("Invalid COM interface specified");
		hResultCode = E_INVALIDARG;
		goto Exit;
	}
	if (lpUnkOuter != NULL)
	{
		hResultCode = CLASS_E_NOAGGREGATION;
		goto Exit;
	}
	if (ppv == NULL)
	{
		DPFERR("Invalid target interface pointer specified");
		hResultCode = E_INVALIDARG;
		goto Exit;
	}

	pObjectData = NULL;
	pIntList = NULL;

	if ((pObjectData = static_cast<OBJECT_DATA*>(DNMalloc(sizeof(OBJECT_DATA)))) == NULL)
	{
		DPFERR("Could not allocate object");
		hResultCode = E_OUTOFMEMORY;
		goto Failure;
	}

	// Object creation and initialization
	if ((hResultCode = DNCF_CreateObject(pInterface, &pObjectData->pvData,riid)) != S_OK)
	{
		DPFERR("Could not create object");
		goto Failure;
	}
	DPFX(DPFPREP, 7,"Created and initialized object");

	// Get requested interface
	if ((hResultCode = DN_CreateInterface(pObjectData,riid,&pIntList)) != S_OK)
	{
		DNCF_FreeObject(pObjectData->pvData);
		goto Failure;
	}
	DPFX(DPFPREP, 7,"Found interface");

	pObjectData->pIntList = pIntList;
	pObjectData->lRefCount = 1;
	DN_AddRef( pIntList );
	GdwHObjects++;
	*ppv = pIntList;

    // 5/23/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPFX(DPFPREP, 7,"*ppv = [0x%p]",*ppv);
	hResultCode = S_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pObjectData)
	{
		DNFree(pObjectData);
		pObjectData = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCF_LockServer"

STDMETHODIMP DNCF_LockServer(IDirectNetClassFact *pInterface,
							 BOOL bLock)
{
    // 5/23/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPFX(DPFPREP, 4,"Parameters: pInterface [%p], bLock [%lx]",pInterface,bLock);

	if (bLock)
	{
		GdwHLocks++;
	}
	else
	{
		GdwHLocks--;
	}

	return(S_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_CreateInterface"

static	HRESULT DN_CreateInterface(OBJECT_DATA *pObject,
								   REFIID riid,
								   INTERFACE_LIST **const ppv)
{
	INTERFACE_LIST	*pIntNew;
	PVOID			lpVtbl;
	HRESULT			hResultCode;

    // 5/23/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPFX(DPFPREP, 6,"Parameters: pObject [%p], riid [%p], ppv [%p]",pObject,&riid,ppv);

	DNASSERT(pObject != NULL);
	DNASSERT(ppv != NULL);

    PDIRECTNETOBJECT pdnObject = ((DIRECTNETOBJECT *)pObject->pvData);

	if (IsEqualIID(riid,IID_IUnknown))
	{
		DPFX(DPFPREP, 7,"riid = IID_IUnknown");
		lpVtbl = &DN_UnknownVtbl;
	}
	else if (IsEqualIID(riid,IID_IDirectPlayVoiceTransport))
	{
		DPFX(DPFPREP, 7,"riid = IID_IDirectPlayVoiceTransport");
		lpVtbl = &DN_VoiceTbl;
	}
	else if (IsEqualIID(riid,IID_IDirectPlay8Protocol))
	{
		DPFX(DPFPREP, 7,"riid = IID_IDirectPlay8Protocol");
		lpVtbl = &DN_ProtocolVtbl;
	}
	else if (IsEqualIID(riid,IID_IDirectPlay8Client) && 
		     pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT )
	{
		DPFX(DPFPREP, 7,"riid = IID_IDirectPlay8Client");
		lpVtbl = &DN_ClientVtbl;
	}
	else if (IsEqualIID(riid,IID_IDirectPlay8Server) && 
		     pdnObject->dwFlags & DN_OBJECT_FLAG_SERVER )
	{
		DPFX(DPFPREP, 7,"riid = IID_IDirectPlay8Server");
		lpVtbl = &DN_ServerVtbl;
	}
	else if (IsEqualIID(riid,IID_IDirectPlay8Peer) && 
		     pdnObject->dwFlags & DN_OBJECT_FLAG_PEER )
	{
		DPFX(DPFPREP, 7,"riid = IID_IDirectPlay8Peer");
		lpVtbl = &DN_PeerVtbl;
	}
	else
	{
		DPFERR("riid not found !");
		hResultCode = E_NOINTERFACE;
		goto Exit;
	}

	if ((pIntNew = static_cast<INTERFACE_LIST*>(DNMalloc(sizeof(INTERFACE_LIST)))) == NULL)
	{
		DPFERR("Could not allocate interface");
		hResultCode = E_OUTOFMEMORY;
		goto Exit;
	}
	pIntNew->lpVtbl = lpVtbl;
	pIntNew->lRefCount = 0;
	pIntNew->pIntNext = NULL;
	DBG_CASSERT( sizeof( pIntNew->iid ) == sizeof( riid ) );
	memcpy( &(pIntNew->iid), &riid, sizeof( pIntNew->iid ) );
	pIntNew->pObject = pObject;

	*ppv = pIntNew;
    // 5/23/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPFX(DPFPREP, 7,"*ppv = [0x%p]",*ppv);

	hResultCode = S_OK;

Exit:
    DPFX(DPFPREP, 6,"Returning: hResultCode = [%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_FindInterface"

INTERFACE_LIST *DN_FindInterface(void *pInterface,
								 REFIID riid)
{
	INTERFACE_LIST	*pIntList;

    // 5/23/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPFX(DPFPREP, 6,"Parameters: pInterface [%p], riid [%p]",pInterface,&riid);

	DNASSERT(pInterface != NULL);

	pIntList = (static_cast<INTERFACE_LIST*>(pInterface))->pObject->pIntList;	// Find first interface

	while (pIntList != NULL)
	{
		if (IsEqualIID(riid,pIntList->iid))
			break;
		pIntList = pIntList->pIntNext;
	}

    // 5/23/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPFX(DPFPREP, 6,"Returning: pIntList [0x%p]",pIntList);
	return(pIntList);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_QueryInterface"

STDMETHODIMP DN_QueryInterface(void *pInterface,
							   REFIID riid,
							   void **ppv)
{
	INTERFACE_LIST	*pIntList;
	INTERFACE_LIST	*pIntNew;
	HRESULT			hResultCode;

    // 5/23/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p], riid [0x%p], ppv [0x%p]",pInterface,&riid,ppv);

	if (pInterface == NULL)
	{
		DPFERR("Invalid COM interface specified");
		hResultCode = E_INVALIDARG;
		goto Exit;
	}
	if (ppv == NULL)
	{
		DPFERR("Invalid target interface pointer specified");
		hResultCode = E_POINTER;
		goto Exit;
	}

	if ((pIntList = DN_FindInterface(pInterface,riid)) == NULL)
	{	// Interface must be created
		pIntList = (static_cast<INTERFACE_LIST*>(pInterface))->pObject->pIntList;
		if ((hResultCode = DN_CreateInterface(pIntList->pObject,riid,&pIntNew)) != S_OK)
		{
			goto Exit;
		}
		pIntNew->pIntNext = pIntList;
		pIntList->pObject->pIntList = pIntNew;
		pIntList = pIntNew;
	}
	if (pIntList->lRefCount == 0)		// New interface exposed
	{
		InterlockedIncrement( &pIntList->pObject->lRefCount );
	}
	InterlockedIncrement( &pIntList->lRefCount );
	*ppv = static_cast<void*>(pIntList);
    // 5/23/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPFX(DPFPREP, 5,"*ppv = [0x%p]", *ppv);

	hResultCode = S_OK;

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_AddRef"

STDMETHODIMP_(ULONG) DN_AddRef(void *pInterface)
{
	INTERFACE_LIST	*pIntList;
	LONG			lRefCount;

    // 5/23/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p]",pInterface);

	if (pInterface == NULL)
	{
		DPFERR("Invalid COM interface specified");
		lRefCount = 0;
		goto Exit;
	}

	pIntList = static_cast<INTERFACE_LIST*>(pInterface);
	lRefCount = InterlockedIncrement( &pIntList->lRefCount );
	DPFX(DPFPREP, 5,"New lRefCount [%ld]",lRefCount);

Exit:
	DPFX(DPFPREP, 2,"Returning: lRefCount [%ld]",lRefCount);
	return(lRefCount);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_Release"

STDMETHODIMP_(ULONG) DN_Release(void *pInterface)
{
	INTERFACE_LIST	*pIntList;
	INTERFACE_LIST	*pIntCurrent;
	LONG			lRefCount;
	LONG			lObjRefCount;

    // 5/23/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPFX(DPFPREP, 2,"Parameters: pInterface [%p]",pInterface);

	if (pInterface == NULL)
	{
		DPFERR("Invalid COM interface specified");
		lRefCount = 0;
		goto Exit;
	}

	pIntList = static_cast<INTERFACE_LIST*>(pInterface);
	lRefCount = InterlockedDecrement( &pIntList->lRefCount );
	DPFX(DPFPREP, 5,"New lRefCount [%ld]",lRefCount);

	if (lRefCount == 0)
	{
		//
		//	Decrease object's interface count
		//
		lObjRefCount = InterlockedDecrement( &pIntList->pObject->lRefCount );

		//
		//	Free object and interfaces
		//
		if (lObjRefCount == 0)
		{
			//
			//	Ensure we're properly closed
			//
			DN_Close( pInterface,0 );

			// Free object here
			DPFX(DPFPREP, 5,"Free object");
			DNCF_FreeObject(pIntList->pObject->pvData);
			pIntList = pIntList->pObject->pIntList;	// Get head of interface list
			DNFree(pIntList->pObject);

			// Free Interfaces
			DPFX(DPFPREP, 5,"Free interfaces");
			while(pIntList != NULL)
			{
				pIntCurrent = pIntList;
				pIntList = pIntList->pIntNext;
				DNFree(pIntCurrent);
			}

			GdwHObjects--;
		}
	}

Exit:
	DPFX(DPFPREP, 2,"Returning: lRefCount [%ld]",lRefCount);
	return(lRefCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\corehandletable.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       HandleTable.cpp
 *  Content:    HandleTable Object
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  04/08/00	mjn		Created
 *	04/16/00	mjn		Added Update() and allow NULL data for Handles
 *	05/05/00	mjn		Clean-up old array for GrowTable() and Deinitialize()
 *	07/07/00	mjn		Fixed validation error in Find()
 *	08/07/00	mjn		Fixed uninitialization problem in Grow()
 *	08/08/00	mjn		Better validation in Find()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

#define HANDLETABLE_INDEX_MASK				0x00FFFFFF
#define HANDLETABLE_VERSION_MASK			0xFF000000
#define HANDLETABLE_VERSION_SHIFT			24

//**********************************************************************
// Macro definitions
//**********************************************************************

#define	CONSTRUCT_DPNHANDLE(i,v)	((i & HANDLETABLE_INDEX_MASK) | ((v << HANDLETABLE_VERSION_SHIFT) & HANDLETABLE_VERSION_MASK))

#define	DECODE_HANDLETABLE_INDEX(h)			(h & HANDLETABLE_INDEX_MASK)

#define	VERIFY_HANDLETABLE_VERSION(h,v)		((h & HANDLETABLE_VERSION_MASK) == (v << HANDLETABLE_VERSION_SHIFT))

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef struct _HANDLETABLE_ARRAY_ENTRY
{
	DWORD		dwVersion;
	union {
		CAsyncOp	*pAsyncOp;
		DWORD		dwIndex;
	} Entry;
} HANDLETABLE_ARRAY_ENTRY;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::Initialize"
HRESULT CHandleTable::Initialize( void )
{
	if (!DNInitializeCriticalSection(&m_cs))
	{
		return(DPNERR_OUTOFMEMORY);
	}

	m_dwNumEntries = 0;
	m_dwNumFreeEntries = 0;
	m_dwFirstFreeEntry = 0;
	m_dwLastFreeEntry = 0;
	m_dwVersion = 1;

	m_pTable = NULL;

	m_dwFlags |= HANDLETABLE_FLAG_INITIALIZED;

	return(DPN_OK);
};


#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::Deinitialize"
void CHandleTable::Deinitialize( void )
{
	Lock();
	m_dwFlags &= (~HANDLETABLE_FLAG_INITIALIZED);
	if (m_pTable)
	{
		DNFree(m_pTable);
		m_pTable = NULL;
	}
	Unlock();

	DNDeleteCriticalSection(&m_cs);
};


#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::GrowTable"
HRESULT CHandleTable::GrowTable( void )
{
	HANDLETABLE_ARRAY_ENTRY *pNewArray;
	DWORD			dwNewSize;
	DWORD			dw;

	DNASSERT(m_dwFlags & HANDLETABLE_FLAG_INITIALIZED);

	//
	//	Double table size or seed with 2 entries
	//
	if (m_dwNumEntries == 0)
	{
		dwNewSize = 2;
	}
	else
	{
		dwNewSize = m_dwNumEntries * 2;
	}

	//
	//	Allocate new array
	//
	pNewArray = static_cast<HANDLETABLE_ARRAY_ENTRY*>(DNMalloc(sizeof(HANDLETABLE_ARRAY_ENTRY) * dwNewSize));
	if (pNewArray == NULL)
	{
		return(DPNERR_OUTOFMEMORY);
	}

	//
	//	Copy old array to new array
	//
	if (m_pTable)
	{
		memcpy(pNewArray,m_pTable,m_dwNumEntries * sizeof(HANDLETABLE_ARRAY_ENTRY));
		DNFree(m_pTable);
		m_pTable = NULL;
	}
	m_pTable = pNewArray;

	//
	//	Free entries at end of new array
	//
	for (dw = m_dwNumEntries ; dw < dwNewSize - 1 ; dw++ )
	{
		m_pTable[dw].Entry.dwIndex = dw + 1;
		m_pTable[dw].dwVersion = 0;
	}
	m_pTable[dwNewSize-1].Entry.dwIndex = 0;
	m_pTable[dwNewSize-1].dwVersion = 0;

	m_dwFirstFreeEntry = m_dwNumEntries;
	if (m_dwFirstFreeEntry == 0)
	{
		m_dwFirstFreeEntry++;
	}
	m_dwLastFreeEntry = dwNewSize - 1;
	m_dwNumEntries = dwNewSize;
	m_dwNumFreeEntries = m_dwLastFreeEntry - m_dwFirstFreeEntry + 1;

	return(DPN_OK);
};



#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::Create"

HRESULT CHandleTable::Create( CAsyncOp *const pAsyncOp,
							  DPNHANDLE *const pHandle )
{
	HRESULT		hResultCode;
	DWORD		dwIndex;
	DPNHANDLE	handle;

	DNASSERT( (pAsyncOp != NULL) || (pHandle != NULL) );

	DNASSERT(m_dwFlags & HANDLETABLE_FLAG_INITIALIZED);

	Lock();

	if (m_dwNumFreeEntries == 0)
	{
		if ((hResultCode = GrowTable()) != DPN_OK)
		{
			Unlock();
			return(hResultCode);
		}
	}
	DNASSERT(m_dwNumFreeEntries != 0);
	dwIndex = m_dwFirstFreeEntry;

	handle = CONSTRUCT_DPNHANDLE(dwIndex,m_dwVersion);

	m_dwFirstFreeEntry = m_pTable[m_dwFirstFreeEntry].Entry.dwIndex;

	if (pAsyncOp)
	{
		pAsyncOp->AddRef();
	}
	m_pTable[dwIndex].Entry.pAsyncOp = pAsyncOp;
	m_pTable[dwIndex].dwVersion = m_dwVersion;

	m_dwNumFreeEntries--;
	m_dwVersion++;
	if (m_dwVersion == 0)
	{
		m_dwVersion++;	// Don't allow 0
	}

	Unlock();

DPFX(DPFPREP, 1,"Create handle [0x%lx]",handle);

	if (pAsyncOp)
	{
		pAsyncOp->Lock();
		pAsyncOp->SetHandle( handle );
		pAsyncOp->Unlock();
	}

	if (pHandle)
	{
		*pHandle = handle;
	}

	return(DPN_OK);
}



#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::Destroy"

HRESULT CHandleTable::Destroy( const DPNHANDLE handle )
{
	DWORD	dwIndex;

DPFX(DPFPREP, 1,"Create handle [0x%lx]",handle);

	DNASSERT(handle != 0);

	DNASSERT(m_dwFlags & HANDLETABLE_FLAG_INITIALIZED);

	dwIndex = DECODE_HANDLETABLE_INDEX( handle );

	if (dwIndex > m_dwNumEntries)
	{
		return(DPNERR_INVALIDHANDLE);
	}

	Lock();

	if (!VERIFY_HANDLETABLE_VERSION(handle,m_pTable[dwIndex].dwVersion))
	{
		Unlock();
		return(DPNERR_INVALIDHANDLE);
	}

	if (m_pTable[dwIndex].Entry.pAsyncOp)
	{
		m_pTable[dwIndex].Entry.pAsyncOp->Release();
	}

	m_pTable[dwIndex].Entry.dwIndex = 0;
	m_pTable[dwIndex].dwVersion = 0;

	if (m_dwNumFreeEntries == 0)
	{
		m_dwFirstFreeEntry = dwIndex;
	}
	else
	{
		m_pTable[m_dwLastFreeEntry].Entry.dwIndex = dwIndex;
	}
	m_dwLastFreeEntry = dwIndex;
	m_dwNumFreeEntries++;

	Unlock();

	return(DPN_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::Update"

HRESULT CHandleTable::Update( const DPNHANDLE handle,
							  CAsyncOp *const pAsyncOp )
{
	DWORD	dwIndex;

	DNASSERT(handle != 0);

	DNASSERT(m_dwFlags & HANDLETABLE_FLAG_INITIALIZED);

	dwIndex = DECODE_HANDLETABLE_INDEX( handle );

	if ((dwIndex == 0) || (dwIndex > m_dwNumEntries))
	{
		return(DPNERR_INVALIDHANDLE);
	}

	Lock();

	if (!VERIFY_HANDLETABLE_VERSION(handle,m_pTable[dwIndex].dwVersion))
	{
		Unlock();
		return(DPNERR_INVALIDHANDLE);
	}

	if (m_pTable[dwIndex].Entry.pAsyncOp)
	{
		m_pTable[dwIndex].Entry.pAsyncOp->Release();
		m_pTable[dwIndex].Entry.pAsyncOp = NULL;
	}

	m_pTable[dwIndex].Entry.pAsyncOp = pAsyncOp;
	if (pAsyncOp)
	{
		pAsyncOp->Lock();
		pAsyncOp->SetHandle( handle );
		pAsyncOp->Unlock();
	}

	Unlock();

	return(DPN_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::Find"

HRESULT CHandleTable::Find( const DPNHANDLE handle,
						    CAsyncOp **const ppAsyncOp )
{
	DWORD	dwIndex;

//	DNASSERT(handle != 0);
	DNASSERT(ppAsyncOp != NULL);

	DNASSERT(m_dwFlags & HANDLETABLE_FLAG_INITIALIZED);

	dwIndex = DECODE_HANDLETABLE_INDEX( handle );

	if ((dwIndex == 0) || (dwIndex >= m_dwNumEntries))
	{
		return(DPNERR_INVALIDHANDLE);
	}

	Lock();

/*
	if (!VERIFY_HANDLETABLE_VERSION(handle,m_pTable[dwIndex].dwVersion))
*/
	if ((m_pTable[dwIndex].dwVersion == 0)
			|| !VERIFY_HANDLETABLE_VERSION(handle,m_pTable[dwIndex].dwVersion)
			|| (m_pTable[dwIndex].Entry.pAsyncOp == NULL))
	{
		Unlock();
		return(DPNERR_INVALIDHANDLE);
	}

	m_pTable[dwIndex].Entry.pAsyncOp->AddRef();
	*ppAsyncOp = m_pTable[dwIndex].Entry.pAsyncOp;

	Unlock();

	return(DPN_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::Enum"

HRESULT CHandleTable::Enum( DPNHANDLE *const rgHandles,
							DWORD *const cHandles )
{
	DWORD		dw;
	HRESULT		hResultCode;
	DPNHANDLE	*p;

	DNASSERT(cHandles != NULL);
	DNASSERT(rgHandles != NULL || *cHandles == 0);

	DNASSERT(m_dwFlags & HANDLETABLE_FLAG_INITIALIZED);

	Lock();

	if (*cHandles < (m_dwNumEntries - m_dwNumFreeEntries))
	{
		hResultCode = DPNERR_BUFFERTOOSMALL;
	}
	else
	{
		p = rgHandles;
		for (dw = 0 ; dw < m_dwNumEntries ; dw++)
		{
			if (m_pTable[dw].dwVersion != 0)
			{
				DNASSERT(m_pTable[dw].Entry.pAsyncOp != NULL);

				*p = CONSTRUCT_DPNHANDLE(dw,m_pTable[dw].dwVersion);
				p++;
			}
		}
		hResultCode = DPN_OK;
	}

	*cHandles = (m_dwNumEntries - m_dwNumFreeEntries);

	Unlock();

	return(hResultCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\coredllmain.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DllMain.cpp
 *  Content:    Defines the entry point for the DLL application.
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   07/21/99	mjn		Created
 *   05/23/00   RichGr  IA64: Substituted %p format specifier whereever
 *                      %x was being used to format pointers.  %p is 32-bit
 *                      in a 32-bit build, and 64-bit in a 64-bit build. 
 *   06/27/00	rmt		Added abstraction for COM_Co(Un)Initialize
 *				rmt	    Added missing set of CLSID for classfactory object
 *   07/06/00	rmt		Making DPNET.DLL self-registering.
 *   08/15/00   RichGr  Bug #41363: Trigger timer and memory pool initialization at DLL startup,
 *                      but actually do it during the first DPlay8 object instantiation.  New functions
 *                      Pools_Pre_Init() and Pools_Deinit() are called from DNet.dll's DllMain.  
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


// Globals
extern	DWORD	GdwHLocks;
extern	DWORD	GdwHObjects;

#undef DPF_MODNAME
#define DPF_MODNAME "RegisterDefaultSettings"
//
// RegisterDefaultSettings
//
// This function registers the default settings for this module.  
//
// For DPVOICE.DLL this is making sure the compression provider sub-key is created.
//
HRESULT RegisterDefaultSettings()
{
	CRegistry creg;

	if( !creg.Open( HKEY_LOCAL_MACHINE, DPN_REG_LOCAL_SP_SUBKEY, FALSE, TRUE ) )
	{
		DPFERR( "Cannot create SP sub-area!" );
		return DPNERR_GENERIC;
	}
	else
	{
		return DPN_OK;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "UnRegisterDefaultSettings"
//
// UnRegisterDefaultSettings
//
// This function registers the default settings for this module.  
//
// For DPVOICE.DLL this is making sure the compression provider sub-key is created.
//
HRESULT UnRegisterDefaultSettings()
{
	CRegistry creg;

	if( !creg.Open( HKEY_LOCAL_MACHINE, DPN_REG_LOCAL_SP_ROOT, FALSE, TRUE ) )
	{
		DPFERR( "Cannot remove SP sub-area, does not exist" );
	}
	else
	{
		if( !creg.DeleteSubKey( &(DPN_REG_LOCAL_SP_SUB)[1] ) )
		{
			DPFERR( "Cannot remove SP sub-key, could have elements" );
		}
	}

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DllRegisterServer"
HRESULT WINAPI DllRegisterServer()
{
	HRESULT hr = S_OK;
	BOOL fFailed = FALSE;

	if( !CRegistry::Register( L"DirectPlay8.Client.1", L"DirectPlay8Client Object", 
							  L"dpnet.dll", CLSID_DirectPlay8Client, L"DirectPlay8.Client") )
	{
		DPFERR( "Could not register dp8 client object" );
		fFailed = TRUE;
	}

	if( !CRegistry::Register( L"DirectPlay8.Server.1", L"DirectPlay8Server Object", 
							  L"dpnet.dll", CLSID_DirectPlay8Server, L"DirectPlay8.Server") )
	{
		DPFERR( "Could not register dp8 Server object" );
		fFailed = TRUE;
	}

	if( !CRegistry::Register( L"DirectPlay8.Peer.1", L"DirectPlay8Peer Object", 
							  L"dpnet.dll", CLSID_DirectPlay8Peer, L"DirectPlay8.Peer") )
	{
		DPFERR( "Could not register dp8 client object" );
		fFailed = TRUE;
	}


	if( FAILED( hr = RegisterDefaultSettings() ) )
	{
		DPFX(DPFPREP,  0, "Could not register default settings hr = 0x%x", hr );
		fFailed = TRUE;
	}
	
	if( fFailed )
	{
		return E_FAIL;
	}
	else
	{
		return S_OK;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "DllUnregisterServer"
STDAPI DllUnregisterServer()
{
	HRESULT hr = S_OK;
	BOOL fFailed = FALSE;

	if( !CRegistry::UnRegister(CLSID_DirectPlay8Client) )
	{
		DPFX(DPFPREP,  0, "Failed to unregister client object" );
		fFailed = TRUE;
	}

	if( !CRegistry::UnRegister(CLSID_DirectPlay8Server) )
	{
		DPFX(DPFPREP,  0, "Failed to unregister server object" );
		fFailed = TRUE;
	}

	if( !CRegistry::UnRegister(CLSID_DirectPlay8Peer) )
	{
		DPFX(DPFPREP,  0, "Failed to unregister peer object" );
		fFailed = TRUE;
	}

	if( FAILED( hr = UnRegisterDefaultSettings() ) )
	{
		DPFX(DPFPREP,  0, "Failed to remove default settings hr=0x%x", hr );
	}

	if( fFailed )
	{
		return E_FAIL;
	}
	else
	{
		return S_OK;
	}

}




#undef DPF_MODNAME
#define DPF_MODNAME "DllMain"

BOOL APIENTRY DllMain( HANDLE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
					 )
{
	TRY
	{
		switch ( ul_reason_for_call )
		{
			case DLL_PROCESS_ATTACH:
			{
				if (DNOSIndirectionInit() == FALSE)
				{
					DPFX(DPFPREP, 0,"Failed to initialize OS indirection layer");
					return FALSE;
				}
				if (FAILED(COM_Init()))
				{
					DPFX(DPFPREP, 0,"Failed to initialize COM indirection layer");
					DNOSIndirectionDeinit();
					return FALSE;
				}
                //  Trigger timer and memory pool initialization for the Protocol 
                if (DNPPoolsInit() == FALSE)
				{
					DPFX(DPFPREP, 0,"Failed to initialize protocol pools");
					COM_Free();
					DNOSIndirectionDeinit();
					return FALSE;
				}
				break;
			}

			case DLL_PROCESS_DETACH:
			{
                DNPPoolsDeinit();
				COM_Free();
				DNOSIndirectionDeinit();
				break;
			}
		}

		return TRUE;
	}
	EXCEPT( EXCEPTION_EXECUTE_HANDLER )
	{
		DPFERR("THERE WAS AN ERROR IN DllMain()");
		return FALSE;
	}
}



#undef DPF_MODNAME
#define DPF_MODNAME "DllGetClassObject"

STDAPI DllGetClassObject(REFCLSID rclsid,REFIID riid,LPVOID *ppv)
{
	_LPIDirectNetClassFact	lpcfObj;
	HRESULT				hResultCode = S_OK;

    // 5/23/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPFX(DPFPREP, 3,"Parameters: rclsid [%p], riid [%p], ppv [%p]", &rclsid, &riid, ppv);

	// Allocate Class Factory object
	if ((lpcfObj = (_LPIDirectNetClassFact)DNMalloc(sizeof(_IDirectNetClassFact))) == NULL)
	{
		DPFERR("DNMalloc() failed");
		*ppv = NULL;
		return(E_OUTOFMEMORY);
	}

    // 5/23/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPFX(DPFPREP, 5,"lpcfObj [%p]",lpcfObj);
	lpcfObj->lpVtbl = &DNCF_Vtbl;
	lpcfObj->dwRefCount = 0;
	lpcfObj->dwLocks = 0;
	lpcfObj->clsid = rclsid;

	// Query to find the interface
#pragma	BUGBUG( johnkan, "Why is this different?" )
	DBG_CASSERT( sizeof( lpcfObj ) == sizeof( IDirectNetClassFact ) );
	if ((hResultCode = lpcfObj->lpVtbl->QueryInterface(reinterpret_cast<IDirectNetClassFact*>( lpcfObj ),riid,ppv)) != S_OK)
	{
		DNFree(lpcfObj);
	}

	// One more thing to release !
	GdwHObjects++;

    // 5/23/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPFX(DPFPREP, 3,"Return: hResultCode = [%lx], *ppv = [%p]",hResultCode,*ppv);
	return(hResultCode);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DllCanUnloadNow"

STDAPI DllCanUnloadNow(void)
{
	DPFX(DPFPREP, 3,"Parameters: (none)");

	DPFX(DPFPREP, 5,"GdwHLocks = %ld\tGdwHObjects = %ld",GdwHLocks,GdwHObjects);
	if (GdwHLocks == 0 && GdwHObjects == 0)
		return(S_OK);
	else
		return(S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\corereceive.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Receive.cpp
 *  Content:    Receive user messages
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  01/27/99	mjn		Created
 *	02/01/00	mjn		Implement Player/Group context values
 *	04/06/00	mjn		Prevent receives from being passed up until after ADD_PLAYER notification
 *	04/13/00	mjn		Fixed bug in DNReceiveUserData
 *	04/20/00	mjn		ReceiveBuffers use CAsyncOp
 *	04/26/00	mjn		Removed DN_ASYNC_OP and related functions
 *	05/03/00	mjn		Use GetHostPlayerRef() rather than GetHostPlayer()
 *	06/25/00	mjn		Always wait for sending player to be available before indicating receives from them
 *	08/02/00	mjn		Added CQueuedMsg to queue incoming messages for players who have not been indicated yet
 *				mjn		Added hCompletionOp and dwFlags to DNReceiveUserData()
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/05/00	mjn		Added pParent to DNSendGroupMessage and DNSendMessage()
 *	08/08/00	mjn		Used CNameTableEntry::IsCreated() to determine if clients or peers may receive
 *	08/31/00	mjn		AddRef DirectNetLock during receives to prevent leaking operations
 *	03/30/01	mjn		Changes to prevent multiple loading/unloading of SP's
 *				mjn		Added service provider to DNReceiveUserData()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//	DNReceiveUserData
//
//	Pass received user data to the user.
//	This is normally a simple undertaking, but since we allow the user to
//	retain ownership of the buffer, there is an added level of complexity.
//
//	We also need to handle the condition of the player receiving data from
//	another player for whom he has not received a CREATE_PLAYER notification.
//	In this case, we will queue the messages on the NameTableEntry, and
//	once the player has been indicated as created, we will drain the queue.
//	Also, if the player entry is in use, we will queue the message so that
//	the thread currently indicating up the user will process this receive for us.

#undef DPF_MODNAME
#define DPF_MODNAME "DNReceiveUserData"

HRESULT	DNReceiveUserData(DIRECTNETOBJECT *const pdnObject,
						  const DPNID dpnidSender,
						  CServiceProvider *const pSP,
						  BYTE *const pBufferData,
						  const DWORD dwBufferSize,
						  const HANDLE hProtocol,
						  CRefCountBuffer *const pRefCountBuffer,
						  const DPNHANDLE hCompletionOp,
						  const DWORD dwFlags)
{
	HRESULT			hResultCode;
	CAsyncOp		*pAsyncOp;
	DPNHANDLE		hAsyncOp;
	CNameTableEntry	*pNTEntry;
	BOOL			fQueueMsg;
	BOOL			fReleaseLock;

	DPFX(DPFPREP, 6,"Parameters: dpnidSender [0x%lx], pSP [0x%p], pBufferData [0x%p], dwBufferSize [0x%lx], hProtocol [0x%p]",
			dpnidSender,pSP,pBufferData,dwBufferSize,hProtocol);

	DNASSERT(pBufferData != NULL);
	DNASSERT(hProtocol == NULL || pRefCountBuffer == NULL);	// One or the other - not both

	hAsyncOp = 0;
	pAsyncOp = NULL;
	pNTEntry = NULL;
	fReleaseLock = FALSE;

	//
	//	Keep DirectNetObject from vanishing under us !
	//
	if ((hResultCode = DNAddRefLock(pdnObject)) != DPN_OK)
	{
		DPFERR("Aborting receive - object is closing");
		hResultCode = DPN_OK;
		goto Failure;
	}
	fReleaseLock = TRUE;

	//
	//	Find sending player's NameTableEntry
	//
	if (pdnObject->dwFlags & (DN_OBJECT_FLAG_PEER|DN_OBJECT_FLAG_SERVER))
	{
		if ((hResultCode = pdnObject->NameTable.FindEntry(dpnidSender,&pNTEntry)) != DPN_OK)
		{
			DPFERR("Player no longer in NameTable");
			DisplayDNError(0,hResultCode);

			//
			//	Try "deleted" list
			//
			if ((hResultCode = pdnObject->NameTable.FindDeletedEntry(dpnidSender,&pNTEntry)) != DPN_OK)
			{
				DPFERR("Player not in deleted list either");
				DisplayDNError(0,hResultCode);
				goto Failure;
			}
		}
	}
	else
	{
		if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pNTEntry )) != DPN_OK)
		{
			DPFERR("Could not find Host player");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
	}

	//
	//	Create an AsyncOp for this receive
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pAsyncOp)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	if ((hResultCode = pdnObject->HandleTable.Create(pAsyncOp,&hAsyncOp)) != DPN_OK)
	{
		DPFERR("Could not create Handle for AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pAsyncOp->SetOpType( ASYNC_OP_RECEIVE_BUFFER );
	pAsyncOp->SetRefCountBuffer( pRefCountBuffer );
	pAsyncOp->SetSP( pSP );

	//
	//	Add buffer to list of active AsyncOp's
	//
	DNEnterCriticalSection(&pdnObject->csActiveList);
	pAsyncOp->m_bilinkActiveList.InsertBefore(&pdnObject->m_bilinkActiveList);
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	fQueueMsg = FALSE;
	pNTEntry->Lock();
	if (pNTEntry->IsDisconnecting())
	{
		pNTEntry->Unlock();
		DPFERR("Message received from disconnecting player - ignoring");
		hResultCode = DPN_OK;
		goto Failure;
	}
	if (pNTEntry->IsInUse())
	{
		//
		//	If the player entry is in use, we will queue the message
		//
		fQueueMsg = TRUE;
	}
	else
	{
		//
		//	If the player entry is not in use, but the target player is not available (not created)
		//	we will queue the message
		//
		if (	((pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT) && !pNTEntry->IsAvailable())	||
				(!(pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT) && !pNTEntry->IsCreated())		)
		{
			fQueueMsg = TRUE;
		}
		else
		{
			//
			//	If there are other messages queued, add this to the queue
			//
			if (!pNTEntry->m_bilinkQueuedMsgs.IsEmpty())
			{
				fQueueMsg = TRUE;
			}
			else
			{
				pNTEntry->SetInUse();
			}
		}
	}

	//
	//	If required, add the message to the end of the queue, otherwise process it
	//
	if (fQueueMsg)
	{
		CQueuedMsg	*pQueuedMsg;

		pQueuedMsg = NULL;

		if ((hResultCode = QueuedMsgNew(pdnObject,&pQueuedMsg)) != DPN_OK)
		{
			pNTEntry->Unlock();
			DPFERR("Could not create queued message");
			DisplayDNError(0,hResultCode);
			hResultCode = DPN_OK;
			goto Failure;
		}
		pAsyncOp->SetProtocolHandle( hProtocol );
		pAsyncOp->SetCompletion( DNCompleteReceiveBuffer );

		pQueuedMsg->SetOpType( RECEIVE );
		pQueuedMsg->SetBuffer( pBufferData );
		pQueuedMsg->SetBufferSize( dwBufferSize );
		pQueuedMsg->SetAsyncOp( pAsyncOp );
		if (dwFlags & DN_SENDFLAGS_SET_USER_FLAG_TWO)
		{
			pQueuedMsg->MakeVoiceMessage();
		}
		if (hCompletionOp)
		{
			pQueuedMsg->SetCompletionOp( hCompletionOp );
		}
		pQueuedMsg->m_bilinkQueuedMsgs.InsertBefore( &pNTEntry->m_bilinkQueuedMsgs );
#ifdef DEBUG
		pNTEntry->m_lNumQueuedMsgs++;
		if ((pNTEntry->m_lNumQueuedMsgs % 25) == 0)
		{
			DPFX(DPFPREP, 1, "Queue now contains %d msgs from player [0x%lx], the CREATE_PLAYER might be taking a long time and sender may need to back off.", pNTEntry->m_lNumQueuedMsgs, pNTEntry->GetDPNID());
		}
#endif // DEBUG


		pNTEntry->NotifyAddRef();
		pNTEntry->Unlock();

		hResultCode = DPNERR_PENDING;
	}
	else
	{
		//
		//	Hand the message directly to the user
		//
		HRESULT		hrProcess;
		HRESULT		hr;
//		CQueuedMsg	*pQueuedMsg;

		//
		//	Hand message up and track it if the user returns DPNERR_PENDING.
		//	Otherwise, let it go
		//
		pNTEntry->NotifyAddRef();
		pNTEntry->Unlock();
		if (dwFlags & DN_SENDFLAGS_SET_USER_FLAG_TWO)
		{
			hr = Voice_Receive(	pdnObject,
								pNTEntry->GetDPNID(),
								0,
								pBufferData,
								dwBufferSize);

			pNTEntry->NotifyRelease();
		}
		else
		{
			hr = DNUserReceive(	pdnObject,
								pNTEntry,
								pBufferData,
								dwBufferSize,
								hAsyncOp);
			if (hCompletionOp != 0)
			{
				//
				//	Send completion message
				//
				CConnection	*pConnection;

				pConnection = NULL;
				if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) == DPN_OK)
				{
					hResultCode = DNSendUserProcessCompletion(pdnObject,pConnection,hCompletionOp);
				}
				pConnection->Release();
				pConnection = NULL;
			}
		}
		if (hr == DPNERR_PENDING)
		{
			if (!pRefCountBuffer)
			{
				pAsyncOp->SetProtocolHandle( hProtocol );
				pAsyncOp->SetCompletion(DNCompleteReceiveBuffer);
			}
			hrProcess = DPNERR_PENDING;
		}
		else
		{
			DNEnterCriticalSection(&pdnObject->csActiveList);
			pAsyncOp->m_bilinkActiveList.RemoveFromList();
			DNLeaveCriticalSection(&pdnObject->csActiveList);
			pAsyncOp->Lock();
			if (!pAsyncOp->IsCancelled() && !pAsyncOp->IsComplete())
			{
				pAsyncOp->SetComplete();
				pAsyncOp->Unlock();
				pdnObject->HandleTable.Destroy( hAsyncOp );
				hAsyncOp = 0;
			}
			else
			{
				pAsyncOp->Unlock();
			}
			hrProcess = DPN_OK;
		}

		//
		//	Perform any queued messages which need to be indicated up to the user
		//
		pNTEntry->PerformQueuedOperations();
		hResultCode = hrProcess;
	}



	DNDecRefLock(pdnObject);
	fReleaseLock = FALSE;

	pAsyncOp->Release();
	pAsyncOp = NULL;
	pNTEntry->Release();
	pNTEntry = NULL;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (hAsyncOp)
	{
		DNEnterCriticalSection(&pdnObject->csActiveList);
		pAsyncOp->m_bilinkActiveList.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csActiveList);
		pdnObject->HandleTable.Destroy(hAsyncOp);
		hAsyncOp = 0;
	}
	if (fReleaseLock)
	{
		DNDecRefLock(pdnObject);
		fReleaseLock = FALSE;
	}
	if (pAsyncOp)
	{
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


//	DNSendUserProcessCompletion
//
//	Send a PROCESS_COMPLETION for a user message.  This indicates that a message was received and
//	handed to the user's message handler.

#undef DPF_MODNAME
#define DPF_MODNAME "DNSendUserProcessCompletion"

HRESULT DNSendUserProcessCompletion(DIRECTNETOBJECT *const pdnObject,
									CConnection *const pConnection,
									const DPNHANDLE hCompletionOp)
{
	HRESULT			hResultCode;
	CRefCountBuffer	*pRefCountBuffer;
	DN_INTERNAL_MESSAGE_PROCESS_COMPLETION	*pMsg;

	DPFX(DPFPREP, 4,"Parameters: pConnection [0x%p], hCompletionOp [0x%lx]",pConnection,hCompletionOp);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pConnection != NULL);

	pRefCountBuffer = NULL;

	//
	//	Create process completion
	//
	if ((hResultCode = RefCountBufferNew(	pdnObject,
											sizeof(DN_INTERNAL_MESSAGE_PROCESS_COMPLETION),
											&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not create RefCountBuffer for processed response");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_PROCESS_COMPLETION*>(pRefCountBuffer->GetBufferAddress());
	pMsg->hCompletionOp = hCompletionOp;

	//
	//	SEND process completion
	//
	hResultCode = DNSendMessage(pdnObject,
								pConnection,
								DN_MSG_INTERNAL_PROCESS_COMPLETION,
								pConnection->GetDPNID(),
								pRefCountBuffer->BufferDescAddress(),
								pRefCountBuffer,
								0,
								DN_SENDFLAGS_RELIABLE,
								NULL,
								NULL);
	if (hResultCode != DPNERR_PENDING)
	{
		DPFERR("Could not SEND process completion");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNFreeProtocolBuffer"

void DNFreeProtocolBuffer(void *const pvProtocolHandle,void *const pvBuffer)
{
	DNPReleaseReceiveBuffer(pvProtocolHandle);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteReceiveBuffer"

void DNCompleteReceiveBuffer(DIRECTNETOBJECT *const pdnObject,
							 CAsyncOp *const pAsyncOp)
{
	DNASSERT(pdnObject != NULL);
	DNASSERT(pAsyncOp != NULL);

	DNASSERT(pAsyncOp->GetProtocolHandle()  != NULL);

	DNPReleaseReceiveBuffer( pAsyncOp->GetProtocolHandle() );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\corepools.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Pools.cpp
 *  Content:	Fixed Pool Wrappers
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/12/00	mjn		Created
 *	01/19/00	mjn		Added SyncEventNew()
 *	01/31/00	mjn		Added Internal FPM's for RefCountBuffers
 *	02/29/00	mjn		Added ConnectionNew()
 *	04/08/00	mjn		Added AsyncOpNew()
 *	07/28/00	mjn		Track outstanding CConnection objects
 *	07/30/00	mjn		Added PendingDeletionNew()
 *	07/31/00	mjn		Added QueuedMsgNew()
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/06/00	mjn		Added CWorkerJob
 *	08/23/00	mjn		Added CNameTableOp
 *	04/04/01	mjn		CConnection list off DirectNetObject guarded by proper critical section
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// RefCountBufferNew
//
// Entry:		DIRECTNETOBJECT *const pdnObject
//				const DWORD	dwBufferSize		- Size of buffer (may be 0)
//
// Exit:		Error Code:	DN_OK
//							DNERR_OUTOFMEMORY
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "RefCountBufferNew"

HRESULT RefCountBufferNew(DIRECTNETOBJECT *const pdnObject,
						  const DWORD dwBufferSize,
						  CRefCountBuffer **const ppNewRefCountBuffer)
{
	CRefCountBuffer	*pRCBuffer;
	HRESULT			hResultCode;

	DPFX(DPFPREP, 8,"Parameters: dwBufferSize [%ld], ppNewRefCountBuffer [0x%p]",
			dwBufferSize,ppNewRefCountBuffer);

	pRCBuffer = pdnObject->m_pFPOOLRefCountBuffer->Get(pdnObject);
	if (pRCBuffer != NULL)
	{
		if ((hResultCode = pRCBuffer->Initialize(pdnObject->m_pFPOOLRefCountBuffer,
				MemoryBlockAlloc,MemoryBlockFree,(PVOID)pdnObject,dwBufferSize)) != DPN_OK)
		{
			DPFERR("Could not initialize");
			DisplayDNError(0,hResultCode);
			pRCBuffer->Release();
			hResultCode = DPNERR_OUTOFMEMORY;
		}
		else
		{
			*ppNewRefCountBuffer = pRCBuffer;
			hResultCode = DPN_OK;
		}
	}
	else
	{
		hResultCode = DPNERR_OUTOFMEMORY;
	}

	DPFX(DPFPREP, 8,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//**********************************************************************
// ------------------------------
// SyncEventNew
//
// Entry:		DIRECTNETOBJECT *const pdnObject
//
// Exit:		Error Code:	DN_OK
//							DNERR_OUTOFMEMORY
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "SyncEventNew"

HRESULT SyncEventNew(DIRECTNETOBJECT *const pdnObject,
					 CSyncEvent **const ppNewSyncEvent)
{
	CSyncEvent		*pSyncEvent;
	HRESULT			hResultCode;

	DPFX(DPFPREP, 8,"Parameters: ppNewSyncEvent [0x%p]",ppNewSyncEvent);

	pSyncEvent = pdnObject->m_pFPOOLSyncEvent->Get(pdnObject->m_pFPOOLSyncEvent);
	if (pSyncEvent != NULL)
	{
		*ppNewSyncEvent = pSyncEvent;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_OUTOFMEMORY;
	}

	DPFX(DPFPREP, 8,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//**********************************************************************
// ------------------------------
// ConnectionNew
//
// Entry:		DIRECTNETOBJECT *const pdnObject
//
// Exit:		Error Code:	DN_OK
//							DNERR_OUTOFMEMORY
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "ConnectionNew"

HRESULT ConnectionNew(DIRECTNETOBJECT *const pdnObject,
					  CConnection **const ppNewConnection)
{
	CConnection		*pConnection;
	HRESULT			hResultCode;

	DPFX(DPFPREP, 8,"Parameters: ppNewConnection [0x%p]",ppNewConnection);

	pConnection = pdnObject->m_pFPOOLConnection->Get(pdnObject);
	if (pConnection != NULL)
	{
		*ppNewConnection = pConnection;
		hResultCode = DPN_OK;

		//
		//	Add this to the bilink of outstanding CConnections
		//
		DNEnterCriticalSection(&pdnObject->csConnectionList);
		pConnection->m_bilinkConnections.InsertBefore(&pdnObject->m_bilinkConnections);
		DNLeaveCriticalSection(&pdnObject->csConnectionList);
	}
	else
	{
		hResultCode = DPNERR_OUTOFMEMORY;
	}

	DPFX(DPFPREP, 8,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}



//**********************************************************************
// ------------------------------
// GroupConnectionNew
//
// Entry:		DIRECTNETOBJECT *const pdnObject
//
// Exit:		Error Code:	DN_OK
//							DNERR_OUTOFMEMORY
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "GroupConnectionNew"

HRESULT GroupConnectionNew(DIRECTNETOBJECT *const pdnObject,
						   CGroupConnection **const ppNewGroupConnection)
{
	CGroupConnection	*pGroupConnection;
	HRESULT				hResultCode;

	DPFX(DPFPREP, 8,"Parameters: ppNewGroupConnection [0x%p]",ppNewGroupConnection);

	pGroupConnection = pdnObject->m_pFPOOLGroupConnection->Get(pdnObject);
	if (pGroupConnection != NULL)
	{
		*ppNewGroupConnection = pGroupConnection;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_OUTOFMEMORY;
	}

	DPFX(DPFPREP, 8,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}



//**********************************************************************
// ------------------------------
// GroupMemberNew
//
// Entry:		DIRECTNETOBJECT *const pdnObject
//
// Exit:		Error Code:	DN_OK
//							DNERR_OUTOFMEMORY
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "GroupMemberNew"

HRESULT GroupMemberNew(DIRECTNETOBJECT *const pdnObject,
					   CGroupMember **const ppNewGroupMember)
{
	CGroupMember	*pGroupMember;
	HRESULT			hResultCode;

	DPFX(DPFPREP, 8,"Parameters: ppNewGroupMember [0x%p]",ppNewGroupMember);

	pGroupMember = pdnObject->m_pFPOOLGroupMember->Get(pdnObject);
	if (pGroupMember != NULL)
	{
		*ppNewGroupMember = pGroupMember;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_OUTOFMEMORY;
	}

	DPFX(DPFPREP, 8,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}



//**********************************************************************
// ------------------------------
// NameTableEntryNew
//
// Entry:		DIRECTNETOBJECT *const pdnObject
//
// Exit:		Error Code:	DN_OK
//							DNERR_OUTOFMEMORY
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "NameTableEntryNew"

HRESULT NameTableEntryNew(DIRECTNETOBJECT *const pdnObject,
						  CNameTableEntry **const ppNewNameTableEntry)
{
	CNameTableEntry	*pNewNameTableEntry;
	HRESULT			hResultCode;

	DPFX(DPFPREP, 8,"Parameters: ppNewNameTableEntry [0x%p]",ppNewNameTableEntry);

	pNewNameTableEntry = pdnObject->m_pFPOOLNameTableEntry->Get(pdnObject);
	if (pNewNameTableEntry != NULL)
	{
		*ppNewNameTableEntry = pNewNameTableEntry;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_OUTOFMEMORY;
	}

	DPFX(DPFPREP, 8,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}



//**********************************************************************
// ------------------------------
// AsyncOpNew
//
// Entry:		DIRECTNETOBJECT *const pdnObject
//
// Exit:		Error Code:	DN_OK
//							DNERR_OUTOFMEMORY
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "AsyncOpNew"

HRESULT AsyncOpNew(DIRECTNETOBJECT *const pdnObject,
				   CAsyncOp **const ppNewAsyncOp)
{
	CAsyncOp		*pAsyncOp;
	HRESULT			hResultCode;

	DPFX(DPFPREP, 8,"Parameters: ppNewAsyncOp [0x%p]",ppNewAsyncOp);

	DNASSERT(pdnObject != NULL);
	DNASSERT(ppNewAsyncOp != NULL);

	pAsyncOp = pdnObject->m_pFPOOLAsyncOp->Get(pdnObject);
	if (pAsyncOp != NULL)
	{
		*ppNewAsyncOp = pAsyncOp;
		hResultCode = DPN_OK;

		//
		//	Add this to the bilink of outstanding AsyncOps
		//
		DNEnterCriticalSection(&pdnObject->csAsyncOperations);
		pAsyncOp->m_bilinkAsyncOps.InsertBefore(&pdnObject->m_bilinkAsyncOps);
		DNLeaveCriticalSection(&pdnObject->csAsyncOperations);
	}
	else
	{
		hResultCode = DPNERR_OUTOFMEMORY;
	}

	DPFX(DPFPREP, 8,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}



//**********************************************************************
// ------------------------------
// PendingDeletionNew
//
// Entry:		DIRECTNETOBJECT *const pdnObject
//
// Exit:		Error Code:	DN_OK
//							DNERR_OUTOFMEMORY
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "PendingDeletionNew"

HRESULT PendingDeletionNew(DIRECTNETOBJECT *const pdnObject,
						   CPendingDeletion **const ppNewPendingDeletion)
{
	CPendingDeletion	*pPendingDeletion;
	HRESULT				hResultCode;

	DPFX(DPFPREP, 8,"Parameters: ppNewPendingDeletion [0x%p]",ppNewPendingDeletion);

	DNASSERT(pdnObject != NULL);
	DNASSERT(ppNewPendingDeletion != NULL);

	pPendingDeletion = pdnObject->m_pFPOOLPendingDeletion->Get(pdnObject);
	if (pPendingDeletion != NULL)
	{
		*ppNewPendingDeletion = pPendingDeletion;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_OUTOFMEMORY;
	}

	DPFX(DPFPREP, 8,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}



//**********************************************************************
// ------------------------------
// QueuedMsgNew
//
// Entry:		DIRECTNETOBJECT *const pdnObject
//
// Exit:		Error Code:	DN_OK
//							DNERR_OUTOFMEMORY
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "QueuedMsgNew"

HRESULT QueuedMsgNew(DIRECTNETOBJECT *const pdnObject,
					 CQueuedMsg **const ppNewQueuedMsg)
{
	CQueuedMsg	*pQueuedMsg;
	HRESULT				hResultCode;

	DPFX(DPFPREP, 8,"Parameters: ppNewQueuedMsg [0x%p]",ppNewQueuedMsg);

	DNASSERT(pdnObject != NULL);
	DNASSERT(ppNewQueuedMsg != NULL);

	pQueuedMsg = pdnObject->m_pFPOOLQueuedMsg->Get(pdnObject);
	if (pQueuedMsg != NULL)
	{
		*ppNewQueuedMsg = pQueuedMsg;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_OUTOFMEMORY;
	}

	DPFX(DPFPREP, 8,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}



//**********************************************************************
// ------------------------------
// WorkerJobNew
//
// Entry:		DIRECTNETOBJECT *const pdnObject
//
// Exit:		Error Code:	DN_OK
//							DNERR_OUTOFMEMORY
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "WorkerJobNew"

HRESULT WorkerJobNew(DIRECTNETOBJECT *const pdnObject,
					 CWorkerJob **const ppNewWorkerJob)
{
	CWorkerJob	*pWorkerJob;
	HRESULT				hResultCode;

	DPFX(DPFPREP, 8,"Parameters: ppNewWorkerJob [0x%p]",ppNewWorkerJob);

	DNASSERT(pdnObject != NULL);
	DNASSERT(ppNewWorkerJob != NULL);

	pWorkerJob = pdnObject->m_pFPOOLWorkerJob->Get(pdnObject);
	if (pWorkerJob != NULL)
	{
		*ppNewWorkerJob = pWorkerJob;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_OUTOFMEMORY;
	}

	DPFX(DPFPREP, 8,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}



//**********************************************************************
// ------------------------------
// NameTableOpNew
//
// Entry:		DIRECTNETOBJECT *const pdnObject
//
// Exit:		Error Code:	DN_OK
//							DNERR_OUTOFMEMORY
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "NameTableOpNew"

HRESULT NameTableOpNew(DIRECTNETOBJECT *const pdnObject,
					   CNameTableOp **const ppNewNameTableOp)
{
	CNameTableOp	*pNameTableOp;
	HRESULT			hResultCode;

	DPFX(DPFPREP, 8,"Parameters: ppNewNameTableOp [0x%p]",ppNewNameTableOp);

	DNASSERT(pdnObject != NULL);
	DNASSERT(ppNewNameTableOp != NULL);

	pNameTableOp = pdnObject->m_pFPOOLNameTableOp->Get(pdnObject);
	if (pNameTableOp != NULL)
	{
		*ppNewNameTableOp = pNameTableOp;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_OUTOFMEMORY;
	}

	DPFX(DPFPREP, 8,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\disconnect.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Disconnect.cpp
 *  Content:    DNET disconnection routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  09/15/99	mjn		Created
 *  12/23/99	mjn		Hand all NameTable update sends from Host to worker thread
 *  12/23/99	mjn		Fixed PlayerDisconnect to prevent user notification of
 *							deletion from ALL_PLAYERS group
 *  12/23/99	mjn		Added basic host migration functionality
 *	12/28/99	mjn		Complete outstanding operations in DNPlayerDisconnectNew
 *	12/28/99	mjn		Moved Async Op stuff to Async.h
 *	12/29/99	mjn		Reformed DN_ASYNC_OP to use hParentOp instead of lpvUserContext
 *	01/03/00	mjn		Added DNPrepareToDeletePlayer
 *	01/04/00	mjn		Added code to allow outstanding ops to complete at host migration
 *	01/06/99	mjn		Moved NameTable stuff to NameTable.h
 *	01/09/00	mjn		Keep number of players in Application Description
 *	01/10/00	mjn		Check AppDesc for host migration
 *	01/11/00	mjn		Use CPackedBuffers instead of DN_ENUM_BUFFER_INFOs
 *	01/15/00	mjn		Replaced DN_COUNT_BUFFER with CRefCountBuffer
 *	01/16/00	mjn		Moved User callback stuff to User.h
 *	01/18/00	mjn		Added DNAutoDestructGroups
 *	01/19/00	mjn		Replaced DN_SYNC_EVENT with CSyncEvent
 *	01/20/00	mjn		Fixed CBilink usage problem in DNLocalDisconnect
 *	01/22/00	mjn		Added DNProcessHostDestroyPlayer
 *	01/23/00	mjn		Update NameTable version for instructed disconnects
 *	01/24/00	mjn		Use DNNTUpdateVersion to update NameTable version
 *	01/25/00	mjn		Changed Host Migration to multi-step affair
 *	02/01/00	mjn		Implement Player/Group context values
 *	04/05/00	mjn		Updated DNProcessHostDestroyPlayer()
 *	04/12/00	mjn		Removed DNAutoDestructGroups - covered in NameTable.DeletePlayer()
 *				mjn		Don't set DN_OBJECT_FLAG_DISCONNECTING in DNPlayerDisconnect()
 *	04/18/00	mjn		Fixed player count problem
 *	04/19/00	mjn		Update NameTable operations to use DN_WORKER_JOB_SEND_NAMETABLE_OPERATION
 *	05/16/00	mjn		Do not take locks when clearing NameTable short-cut pointers
 *	06/06/00	mjn		Fixed DNPlayerDisconnect to always check for host migration in peer-peer mode w/ host migration flag
 *	07/07/00	mjn		Clear host migration status if new host disconnects during migration process
 *	07/20/00	mjn		Use ClearHostWithDPNID() to clear HostPlayer in DNPlayerDisconnectNew()
 *	07/29/00	mjn		Fix calls to DNUserConnectionTerminated()
 *	07/30/00	mjn		Use DNUserTerminateSession() rather than DNUserConnectionTerminated()
 *	07/31/00	mjn		Added hrReason to DNTerminateSession()
 *				mjn		Added dwDestroyReason to DNHostDisconnect()
 *				mjn		Removed DNProcessHostDestroyPlayer()
 *	07/31/00	mjn		Change DN_MSG_INTERNAL_DELETE_PLAYER to DN_MSG_INTERNAL_DESTROY_PLAYER
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/05/00	mjn		Prevent DN_MSG_INTERNAL_DESTROY_PLAYER from being sent out in client/server
 *	08/06/00	mjn		Added CWorkerJob
 *	08/07/00	mjn		Added code to request peer-peer integrity checks and clean up afterwards
 *	09/04/00	mjn		Added CApplicationDesc
 *	09/26/00	mjn		Removed locking from CNameTable::SetVersion() and CNameTable::GetNewVersion()
 *	01/25/01	mjn		Fixed 64-bit alignment problem in received messages
 *	02/12/01	mjn		Fixed CConnection::GetEndPt() to track calling thread
 *	04/13/01	mjn		Remove request for integrity check from request list in DNInstructedDisconnect()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//	DNPlayerDisconnectNew
//
//	Another player has issued a disconnect with the local player.
//	- If the disconnecting player is still in the nametable
//		- prepare to delete player
//		- Save one refcount to be released by DELETE_PLAYER from host or Close
//	- check host migration

#undef DPF_MODNAME
#define DPF_MODNAME "DNPlayerDisconnectNew"

HRESULT DNPlayerDisconnectNew(DIRECTNETOBJECT *const pdnObject,
							  const DPNID dpnid)
{
	CNameTableEntry		*pNTEntry;
	CNameTableEntry		*pLocalPlayer;
	HRESULT				hResultCode;
	DPNID				dpnidNewHost;
	BOOL				fWasHost;
	BOOL				fRequestIntegrityCheck;

	DPFX(DPFPREP, 4,"Parameters: dpnid [0x%lx]",dpnid);

	DNASSERT(pdnObject != NULL);

	pNTEntry = NULL;
	pLocalPlayer = NULL;

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT)
	{
		//
		//	The Server has disconnected
		//	We will indicate the connection terminated and shut down
		//
		DPFX(DPFPREP, 5,"Server has disconnected from this client");
		DNUserTerminateSession(pdnObject,DPNERR_CONNECTIONLOST,NULL,0);
		DNTerminateSession(pdnObject,DPNERR_CONNECTIONLOST);
	}
	else
	{
		//
		//	Another peer has disconnected from this peer
		//	We will delete this player from the NameTable
		//	We may have to ask the host to perform an integrity check
		//
		DPFX(DPFPREP, 5,"Peer has disconnected from this peer");
		if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
		{
			DPFERR("Could not find disconnecting player in NameTable");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
		fRequestIntegrityCheck = FALSE;
		pNTEntry->Lock();
		if (pNTEntry->IsAvailable())
		{
			fRequestIntegrityCheck = TRUE;
		}
		pNTEntry->Unlock();
		if (fRequestIntegrityCheck)
		{
			DNRequestIntegrityCheck(pdnObject,dpnid);
		}
		pdnObject->NameTable.DeletePlayer(dpnid,0);

		//
		//	If this was the Host, clear the short-cut pointer
		//
		fWasHost = pdnObject->NameTable.ClearHostWithDPNID( dpnid );

		//
		//	May need to clear HOST_MIGRATING flag
		//
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		if ((pdnObject->dwFlags & DN_OBJECT_FLAG_HOST_MIGRATING) && (pdnObject->pNewHost == pNTEntry))
		{
			pdnObject->dwFlags &= ~(DN_OBJECT_FLAG_HOST_MIGRATING);
			pdnObject->pNewHost->Release();
			pdnObject->pNewHost = NULL;
		}
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

		//
		//	If HostMigration flag is set, check to see if we are the new Host.
		//	Otherwise, if the disconnecting player was the Host, the session is lost.
		//
		if (pdnObject->ApplicationDesc.AllowHostMigrate())
		{
			DPFX(DPFPREP, 5,"Host-Migration was set - check for new Host");
			dpnidNewHost = 0;
			if ((hResultCode = DNFindNewHost(pdnObject,&dpnidNewHost)) == DPN_OK)
			{
				DPFX(DPFPREP, 5,"New Host [0x%lx]",dpnidNewHost);
				if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef(&pLocalPlayer)) == DPN_OK)
				{
					if (pLocalPlayer->GetDPNID() == dpnidNewHost)
					{
						DPFX(DPFPREP, 5,"Local player is new Host");
						hResultCode = DNPerformHostMigration1(pdnObject,dpnid);
					}

					pLocalPlayer->Release();
					pLocalPlayer = NULL;
				}
			}
		}
		else if (fWasHost)
		{
			DPFX(DPFPREP, 5,"Host-Migration was not set - terminating session");
			DNUserTerminateSession(pdnObject,DPNERR_CONNECTIONLOST,NULL,0);
			DNTerminateSession(pdnObject,DPNERR_CONNECTIONLOST);
		}

		pNTEntry->Release();
		pNTEntry = NULL;
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
}


//	DNHostDisconnect
//
//	A player has initiated a disconnect with the host.
//	- Remove player from the name table
//	- Propegate DELETE_PLAYER messages to each player
#pragma TODO(minara,"Use pConnection instead of dpnidDisconnecting ?")

#undef DPF_MODNAME
#define DPF_MODNAME "DNHostDisconnect"

HRESULT DNHostDisconnect(DIRECTNETOBJECT *const pdnObject,
						 const DPNID dpnidDisconnecting,
						 const DWORD dwDestroyReason)
{
	HRESULT				hResultCode;
	CRefCountBuffer		*pRefCountBuffer;
	CPendingDeletion	*pPending;
	CWorkerJob			*pWorkerJob;
	DN_INTERNAL_MESSAGE_DESTROY_PLAYER	*pMsg;

	DPFX(DPFPREP, 4,"Parameters: pdnObject [0x%p], dpnidDisconnecting [0x%lx], dwDestroyReason [0x%lx]",
			pdnObject,dpnidDisconnecting,dwDestroyReason);

	DNASSERT(pdnObject != NULL);
	DNASSERT(dpnidDisconnecting != 0);

	pRefCountBuffer = NULL;
	pPending = NULL;
	pWorkerJob = NULL;

	// Remove entry from NameTable and inform other players, only if Host is NOT migrating
	//	Otherwise, clean-up first and wait for migration to complete before informing others
	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_HOST_MIGRATING))
	{
		DWORD			dwVersion;
		CNameTableEntry	*pNTEntry;

		dwVersion = 0;
		pNTEntry = NULL;

		if ((hResultCode = pdnObject->NameTable.FindEntry(dpnidDisconnecting,&pNTEntry)) == DPN_OK)
		{
			pNTEntry->Lock();
			if (pNTEntry->GetDestroyReason() == 0)
			{
				pNTEntry->SetDestroyReason( dwDestroyReason );
			}
			pNTEntry->Unlock();
			pNTEntry->Release();
			pNTEntry = NULL;
		}
		hResultCode = pdnObject->NameTable.DeletePlayer(dpnidDisconnecting,&dwVersion);

		if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
		{
			//
			//	Prepare internal message
			//
			if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_DESTROY_PLAYER),
					&pRefCountBuffer)) != DPN_OK)
			{
				DPFERR("Could not allocate message buffer");
				DisplayDNError(0,hResultCode);
				goto Failure;
			}
			pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_DESTROY_PLAYER*>(pRefCountBuffer->GetBufferAddress());
			pMsg->dpnidLeaving = dpnidDisconnecting;
			pMsg->dwVersion = dwVersion;
			pMsg->dwVersionNotUsed = 0;
			pMsg->dwDestroyReason = dwDestroyReason;

			if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
			{
				DPFERR("Could not create worker job");
				DisplayDNError(0,hResultCode);
				goto Failure;
			}
			pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION );
			pWorkerJob->SetSendNameTableOperationMsgId( DN_MSG_INTERNAL_DESTROY_PLAYER );
			pWorkerJob->SetSendNameTableOperationVersion( dwVersion );
			pWorkerJob->SetSendNameTableOperationDPNIDExclude( dpnidDisconnecting );
			pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

			DNQueueWorkerJob(pdnObject,pWorkerJob);
			pWorkerJob = NULL;

			pRefCountBuffer->Release();
			pRefCountBuffer = NULL;
		}
	}
	else
	{
		//
		//	Put this on the Outstanding operation list
		//
		if ((hResultCode = PendingDeletionNew(pdnObject,&pPending)) == DPN_OK)
		{
			pPending->SetDPNID( dpnidDisconnecting );

			DNEnterCriticalSection(&pdnObject->csNameTableOpList);
			pPending->m_bilinkPendingDeletions.InsertBefore(&pdnObject->m_bilinkPendingDeletions);
			DNLeaveCriticalSection(&pdnObject->csNameTableOpList);

			pPending = NULL;
		}

		// See if we can continue with Host migration
		DNCheckReceivedAllVersions(pdnObject);
	}

	hResultCode = DPN_OK;

Exit:
	DPFX(DPFPREP, 4,"Returning: [0x%lx]", hResultCode);
	return(hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pPending)
	{
		pPending->ReturnSelfToPool();
		pPending = NULL;
	}
	goto Exit;
}


//	DNInstructedDisconnect
//
//	The host has instructed the local player to delete another player from the nametable
//	- If already closing
//		- ignore this message and return
//	- Prepare to delete player
//	- Release refcount of player

#undef DPF_MODNAME
#define DPF_MODNAME "DNInstructedDisconnect"

HRESULT DNInstructedDisconnect(DIRECTNETOBJECT *const pdnObject,
							   PVOID pv)
{
	HRESULT				hResultCode;
	DWORD				dwVersion;
	CNameTableEntry		*pNTEntry;
	UNALIGNED DN_INTERNAL_MESSAGE_DESTROY_PLAYER	*pInfo;

	DPFX(DPFPREP, 4,"Parameters: pv [0x%p]",pv);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pv != NULL);

	pNTEntry = NULL;

	pInfo = static_cast<DN_INTERNAL_MESSAGE_DESTROY_PLAYER*>(pv);

	DNASSERT(pInfo != NULL);
	DNASSERT(pInfo->dpnidLeaving != NULL);
	DNASSERT(pInfo->dwVersion != 0);

	DPFX(DPFPREP, 5,"Deleting player [0x%lx]",pInfo->dpnidLeaving);

	//
	//	If the player is still in the NameTable, we will preset the destroy reason.
	//	We will also use this "hint" to initiate a disconnect just in case the protocol
	//	
	if ((hResultCode = pdnObject->NameTable.FindEntry(pInfo->dpnidLeaving,&pNTEntry)) == DPN_OK)
	{
		CConnection		*pConnection;
		CCallbackThread	CallbackThread;
		HANDLE			hEndPt;

		pConnection = NULL;
		hEndPt = NULL;

		pNTEntry->Lock();
		if (pNTEntry->GetDestroyReason() == 0)
		{
			pNTEntry->SetDestroyReason( pInfo->dwDestroyReason );
		}
		pNTEntry->Unlock();

		//
		//	Attempt a disconnect
		//
		if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) == DPN_OK)
		{
			if ((hResultCode = pConnection->GetEndPt(&hEndPt,&CallbackThread)) == DPN_OK)
			{
				DNPerformDisconnect(pdnObject,pConnection,hEndPt);

				pConnection->ReleaseEndPt(&CallbackThread);
			}
			pConnection->Release();
			pConnection = NULL;
		}
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	else
	{
		//
		//	Scan oustanding op list for integrity check request for this player.
		//	If found, remove it from the request list and the handle table
		//
		CBilink		*pBilink;
		CAsyncOp	*pAsyncOp;
		DN_SEND_OP_DATA	*pSendOpData;

		pAsyncOp = NULL;
		DNEnterCriticalSection(&pdnObject->csActiveList);
		pBilink = pdnObject->m_bilinkRequestList.GetNext();
		while (pBilink != &pdnObject->m_bilinkRequestList)
		{
			pAsyncOp = CONTAINING_OBJECT(pBilink,CAsyncOp,m_bilinkActiveList);
			DNASSERT(pAsyncOp->GetOpType() == ASYNC_OP_REQUEST);
			pSendOpData = reinterpret_cast<DN_SEND_OP_DATA*>(pAsyncOp->GetOpData());
			if (pSendOpData != NULL)
			{
				if (pSendOpData->dwMsgId == DN_MSG_INTERNAL_REQ_INTEGRITY_CHECK)
				{
					UNALIGNED DN_INTERNAL_MESSAGE_REQ_INTEGRITY_CHECK	*pMsg;

					pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_INTEGRITY_CHECK*>
						(reinterpret_cast<UNALIGNED DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION*>(pSendOpData->BufferDesc[1].pBufferData) + 1);
					if (pMsg->dpnidTarget == pInfo->dpnidLeaving)
					{
						pAsyncOp->m_bilinkActiveList.RemoveFromList();
						pAsyncOp->AddRef();
						break;
					}
				}
				pSendOpData = NULL;
			}
			pAsyncOp = NULL;
			pBilink = pBilink->GetNext();
		}
		DNLeaveCriticalSection(&pdnObject->csActiveList);

		if (pAsyncOp != NULL)
		{
			DNASSERT(pAsyncOp->GetHandle() != 0);
			pdnObject->HandleTable.Destroy( pAsyncOp->GetHandle() );
			pAsyncOp->Release();
			pAsyncOp = NULL;
		}
		DNASSERT(pAsyncOp == NULL);
	}

	dwVersion = pInfo->dwVersion;
	pdnObject->NameTable.DeletePlayer(pInfo->dpnidLeaving,&dwVersion);

	//
	//	Update NameTable version
	//
	pdnObject->NameTable.WriteLock();
	pdnObject->NameTable.SetVersion(pInfo->dwVersion);
	pdnObject->NameTable.Unlock();

	hResultCode = DPN_OK;

	DPFX(DPFPREP, 4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\corevoice.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Voice.cpp
 *  Content:    DNET voice transport interface routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	01/17/00	rmt		Created
 *  01/19/00	rmt		Fixed bug in send, wasn't copying buffer
 *  01/21/00	rmt		Updated for new interface
 *  01/21/00	rmt		Updated to use locks to protect voice portion of DNet interface
 *  01/27/2000	rmt		Added concurrency protection to the interface
 *  04/04/2000  rmt     Fixed crash if transmitting during shutdown
 *  04/07/2000  rmt     Fixed Bug #32179
 *              rmt     Added support for nocopy sends
 *	04/16/00	mjn		DNSendMessage uses CAsyncOp
 *	04/20/00	mjn		DNCompleteVoiceSend calls DNCompleteSendAsyncOp to clean up
 *	04/23/00	mjn		Added parameter to DNPerformChildSend()
 *  04/28/00	rmt		Fixed possible deadlock condition
 *	04/28/00	mjn		Prevent infinite loops in group SENDs
 *	05/03/00	mjn		Use GetHostPlayerRef() rather than GetHostPlayer()
 *	05/30/00	mjn		Modified logic for group sends to target connected players only
 *	06/26/00	mjn		Added VoiceSendSpeechSync()
 *				mjn		Use Host player as sender in Client mode for Voice_Receive()
 *  06/27/00	rmt		Added support for sync sends
 *				mjn		Ensure DirectNet object is initialized and not closing when sending
 *	07/06/00	mjn		Use DNSendGroupMessage() to send group voice messages
 *	07/08/00	mjn		Send non-guaranteed voice traffic as non-sequential
 *	07/11/00	mjn		Added NOLOOPBACK capability to group sends
 *  07/21/00	rmt		Bug #36386 - Target list with groups and players may result in redundant sends
 *  07/22/00	rmt  	Bug #40296, 38858 - Crashes due to shutdown race condition
 *   				  	Now for a thread to make an indication into voice they addref the interface
 *						so that the voice core can tell when all indications have returned.  
 *  07/31/00	rodtoll	Bug #41135 - Shutdown lockup -- now does not addref if notification
 *						is a session lost.  Added AddRefs() for VoiceReceive 
 *  08/11/2000	rodtoll	Bug #42235 - DVERR_NOTRANSPORT error when attempting to host voice sample app
 *	09/04/00	mjn		Added CApplicationDesc
 *  10/06/2000	rodtoll	Bug #46693 - DPVOICE: DPLAY8: Voice Data sends do not timeout
 *  10/10/2000	rodtoll	Bug #46895 - Regression from above -- guaranteed voice sends would timeout
 *  01/04/2001	rodtoll	WinBug #94200 - Remove stray comments
 *  01/22/2001	rodtoll	WINBUG #288437 - IA64 Pointer misalignment due to wire packets
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


#define DNET_VOICE_TIMEOUT			1500

//**********************************************************************
// Function prototypes
//**********************************************************************

STDMETHODIMP VoiceAdvise( IDirectPlayVoiceTransport *pInterface, IUnknown *pUnknown, DWORD dwObjectType );
STDMETHODIMP VoiceUnAdvise( IDirectPlayVoiceTransport *pInterface, DWORD dwObjectType );
STDMETHODIMP VoiceIsGroupMember( IDirectPlayVoiceTransport *pInterface, DVID dvidGroup, DVID dvidPlayer );
STDMETHODIMP VoiceSendSpeech( IDirectPlayVoiceTransport *pInterface, DVID dvidFrom, DVID dvidTo, PDVTRANSPORT_BUFFERDESC pBufferDesc, LPVOID pvUserContext, DWORD dwFlags );
STDMETHODIMP VoiceSendSpeechAsync( IDirectPlayVoiceTransport *pInterface, DVID dvidFrom, DVID dvidTo, PDVTRANSPORT_BUFFERDESC pBufferDesc, LPVOID pvUserContext, DWORD dwFlags );
STDMETHODIMP VoiceSendSpeechSync(IDirectPlayVoiceTransport *pInterface,
									  DVID dvidFrom,
									  DVID dvidTo,
									  PDVTRANSPORT_BUFFERDESC pBufferDesc,
									  void *pvUserContext,
									  DWORD dwFlags );
STDMETHODIMP VoiceGetSessionInfo( IDirectPlayVoiceTransport *pInterface, PDVTRANSPORTINFO pdvTransportInfo );
STDMETHODIMP VoiceIsValidEntity( IDirectPlayVoiceTransport *pInterface, DVID dvidID, PBOOL pfIsValid );
STDMETHODIMP VoiceSendSpeechEx( IDirectPlayVoiceTransport *pInterface, DVID dvidFrom, DWORD dwNumTargets, UNALIGNED DVID * pdvidTargets, PDVTRANSPORT_BUFFERDESC, PVOID pvUserContext, DWORD dwFlags );
STDMETHODIMP VoiceIsValidGroup( IDirectPlayVoiceTransport *pInterface, DVID dvidID, PBOOL pfIsValid );
STDMETHODIMP VoiceIsValidPlayer( IDirectPlayVoiceTransport *pInterface, DVID dvidID, PBOOL pfIsValid );
VOID VoiceTarget_ClearTargetList( DIRECTNETOBJECT *pdnObject );
VOID VoiceTarget_ClearExpandedTargetList(DIRECTNETOBJECT *pdnObject);
HRESULT VoiceTarget_AddExpandedTargetListEntry(DIRECTNETOBJECT *pdnObject, DPNID dpid);
void VoiceTarget_AddIfNotAlreadyFound( DIRECTNETOBJECT *pdnObject, DPNID dpidID );
HRESULT VoiceTarget_ExpandTargetList(DIRECTNETOBJECT *pdnObject, DWORD nTargets, UNALIGNED DPNID * pdvidTo);


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

typedef	STDMETHODIMP VoiceQueryInterface( IDirectPlayVoiceTransport *pInterface, REFIID riid, LPVOID *ppvObj );
typedef	STDMETHODIMP_(ULONG)	VoiceAddRef( IDirectPlayVoiceTransport *pInterface );
typedef	STDMETHODIMP_(ULONG)	VoiceRelease( IDirectPlayVoiceTransport *pInterface );

IDirectPlayVoiceTransportVtbl DN_VoiceTbl =
{
	(VoiceQueryInterface*)			DN_QueryInterface,
	(VoiceAddRef*)					DN_AddRef,
	(VoiceRelease*)					DN_Release,
									VoiceAdvise,
									VoiceUnAdvise,
									VoiceIsGroupMember,
									VoiceSendSpeech,
									VoiceGetSessionInfo,
									VoiceIsValidEntity,
									VoiceSendSpeechEx,
									VoiceIsValidGroup,
									VoiceIsValidPlayer
};

//**********************************************************************
// Function definitions
//**********************************************************************

#undef DPF_MODNAME
#define DPF_MODNAME "Voice_Receive"
HRESULT Voice_Receive(PDIRECTNETOBJECT pdnObject, DVID dvidFrom, DVID dvidTo, LPVOID lpvMessage, DWORD dwMessageLen )
{
	PDIRECTPLAYVOICENOTIFY pServer;
	PDIRECTPLAYVOICENOTIFY pClient;
	CNameTableEntry	*pNTEntry;
	HRESULT			hResultCode;

    pNTEntry = NULL;

	//
	//	Ensure sender still exists in NameTable.
	//	If we are a client, the sender will be the Host player.  Otherwise, we will have to look up the player
	//	by the specified DPNID
	//
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT)
	{
		if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef(&pNTEntry)) != DPN_OK)
		{
			DPFERR("Host not in NameTable - fail");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
	}
	else
	{
		if ((hResultCode = pdnObject->NameTable.FindEntry(dvidFrom,&pNTEntry)) != DPN_OK)
		{
			DPFERR("Player not in NameTable - fail");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
	}
	if (!pNTEntry->IsAvailable())
	{
		DNASSERT(FALSE);	// Is this ever hit ?
		DPFX(DPFPREP, 7,"Waiting for connection");
//		pNTEntry->WaitUntilAvailable();
	}
	if (pNTEntry->IsDisconnecting())
	{
		DPFERR("Player is now disconnecting !");
		hResultCode = DPN_OK;
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	DNEnterCriticalSection( &pdnObject->csVoice );

	pServer = pdnObject->lpDxVoiceNotifyServer;
	pClient = pdnObject->lpDxVoiceNotifyClient;
	
	if( pServer )
		pServer->lpVtbl->AddRef( pServer );

	if( pClient )
		pClient->lpVtbl->AddRef( pClient );
	
	DNLeaveCriticalSection( &pdnObject->csVoice );

	// Ensure that voice objects created as a result of this notification
	// do not receive the notification	

	if( pClient != NULL )
        pClient->lpVtbl->ReceiveSpeechMessage(pClient, dvidFrom, dvidTo, lpvMessage, dwMessageLen );

	if( pServer != NULL )
    	pServer->lpVtbl->ReceiveSpeechMessage(pServer, dvidFrom, dvidTo, lpvMessage, dwMessageLen );

	if( pServer )
		pServer->lpVtbl->Release( pServer );

	if( pClient )
		pClient->lpVtbl->Release( pClient );	

	hResultCode = DV_OK;

Exit:
	DNASSERT(hResultCode != DPNERR_PENDING);
	return hResultCode;

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Voice_Notify"
HRESULT Voice_Notify( PDIRECTNETOBJECT pdnObject, DWORD dwMsgType, DWORD_PTR dwParam1, DWORD_PTR dwParam2, DWORD dwObjectType )
{
	PDIRECTPLAYVOICENOTIFY pServer;
	PDIRECTPLAYVOICENOTIFY pClient;
    
	DNEnterCriticalSection( &pdnObject->csVoice );

	pServer = pdnObject->lpDxVoiceNotifyServer;
	pClient = pdnObject->lpDxVoiceNotifyClient;

	if( dwMsgType != DVEVENT_STOPSESSION )
	{
	    if( pServer )
		    pServer->lpVtbl->AddRef( pServer );

	    if( pClient )
		    pClient->lpVtbl->AddRef( pClient );
	}

	DNLeaveCriticalSection( &pdnObject->csVoice );

	// Reset the target cache when nametable changes
	if(  dwMsgType == DVEVENT_ADDPLAYER || 
		dwMsgType == DVEVENT_REMOVEPLAYER ||
		dwMsgType == DVEVENT_CREATEGROUP || 
		dwMsgType == DVEVENT_DELETEGROUP ||
		dwMsgType == DVEVENT_ADDPLAYERTOGROUP ||
		dwMsgType == DVEVENT_REMOVEPLAYERFROMGROUP )
	{
		VoiceTarget_ClearTargetList( pdnObject );
	}

	// Ensure that voice objects created as a result of this notification
	// do not receive the notification	

	if( pClient != NULL  && dwObjectType & DVTRANSPORT_OBJECTTYPE_CLIENT )
        pClient->lpVtbl->NotifyEvent(pClient, dwMsgType, dwParam1, dwParam2 );

	if( pServer != NULL && dwObjectType & DVTRANSPORT_OBJECTTYPE_SERVER)
    	pServer->lpVtbl->NotifyEvent(pServer, dwMsgType, dwParam1, dwParam2 );

	if( dwMsgType != DVEVENT_STOPSESSION )
	{
		if( pClient )
			pClient->lpVtbl->Release(pClient);

		if( pServer )
			pServer->lpVtbl->Release(pServer);
	}

	return DV_OK;
}

#pragma TODO(rodtoll,"Add protection to the voice elements")
#pragma TODO(rodtoll,"Add checking for session parameters")
#undef DPF_MODNAME
#define DPF_MODNAME "VoiceAdvise"
HRESULT __stdcall VoiceAdvise( IDirectPlayVoiceTransport *pInterface, IUnknown *pUnknown, DWORD dwObjectType )
{
	PDIRECTNETOBJECT pdnObject = (PDIRECTNETOBJECT) GET_OBJECT_FROM_INTERFACE(pInterface);
	HRESULT hr;
//	DWORD dwCurrentIndex;

	DNEnterCriticalSection( &pdnObject->csVoice );

	if( dwObjectType & DVTRANSPORT_OBJECTTYPE_SERVER )
	{
	    if( pdnObject->lpDxVoiceNotifyServer != NULL )
	    {
	        DPFX(DPFPREP,  0, "There is already a server interface registered on this object" );
	        hr = DPNERR_GENERIC;
	    }
	    else
	    {
	        hr = pUnknown->lpVtbl->QueryInterface( pUnknown, IID_IDirectPlayVoiceNotify, (void **) &pdnObject->lpDxVoiceNotifyServer );

	        if( FAILED( hr ) )
	        {
	            DPFX(DPFPREP,  0, "QueryInterface failed! hr=0x%x", hr );
	        }
	        else
	        {
            	hr = pdnObject->lpDxVoiceNotifyServer->lpVtbl->Initialize(pdnObject->lpDxVoiceNotifyServer);

            	if( FAILED( hr ) )
            	{
            	    DPFX(DPFPREP,  0, "Failed to perform initialize on notify interface hr=0x%x", hr );
            	    pdnObject->lpDxVoiceNotifyServer->lpVtbl->Release( pdnObject->lpDxVoiceNotifyServer );
            	    pdnObject->lpDxVoiceNotifyServer = NULL;
            	}
	        }
	    }
	    
	}
	else if( dwObjectType & DVTRANSPORT_OBJECTTYPE_CLIENT )
	{
	    if( pdnObject->lpDxVoiceNotifyClient != NULL )
	    {
	        DPFX(DPFPREP,  0, "There is already a client interface registered on this object" );
	        hr = DPNERR_GENERIC;
	    }
	    else
	    {
	        hr = pUnknown->lpVtbl->QueryInterface( pUnknown, IID_IDirectPlayVoiceNotify, (void **) &pdnObject->lpDxVoiceNotifyClient );

	        if( FAILED( hr ) )
	        {
	            DPFX(DPFPREP,  0, "QueryInterface failed! hr=0x%x", hr );
	        }
	        else
	        {
            	hr = pdnObject->lpDxVoiceNotifyClient->lpVtbl->Initialize(pdnObject->lpDxVoiceNotifyClient);

            	if( FAILED( hr ) )
            	{
            	    DPFX(DPFPREP,  0, "Failed to perform initialize on notify interface hr=0x%x", hr );
            	    pdnObject->lpDxVoiceNotifyClient->lpVtbl->Release( pdnObject->lpDxVoiceNotifyClient );
            	    pdnObject->lpDxVoiceNotifyClient = NULL;
            	}
	        }
	    }	    
	}
	else
	{
	    DPFX(DPFPREP,  0, "Error: Invalid object type specified in advise" );
	    DNASSERT( FALSE );
	    hr = DPNERR_GENERIC;
	}

	DNLeaveCriticalSection( &pdnObject->csVoice );
	
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "VoiceUnAdvise"
HRESULT __stdcall VoiceUnAdvise( IDirectPlayVoiceTransport *pInterface, DWORD dwObjectType )
{
	PDIRECTNETOBJECT pdnObject = (PDIRECTNETOBJECT) GET_OBJECT_FROM_INTERFACE(pInterface);
//	DWORD dwIndex;
	HRESULT hr = DV_OK;

	DNEnterCriticalSection( &pdnObject->csVoice );

	if( dwObjectType & DVTRANSPORT_OBJECTTYPE_SERVER )
	{
        if( pdnObject->lpDxVoiceNotifyServer != NULL )
	    {
    	    pdnObject->lpDxVoiceNotifyServer->lpVtbl->Release( pdnObject->lpDxVoiceNotifyServer );
    	    pdnObject->lpDxVoiceNotifyServer = NULL;	    
	    }
	    else
	    {
	        DPFX(DPFPREP,  0, "No server currently registered" );
	        hr = DVERR_GENERIC;
	    }
	}
	else if( dwObjectType & DVTRANSPORT_OBJECTTYPE_CLIENT )
	{
	    if( pdnObject->lpDxVoiceNotifyClient != NULL )
	    {
    	    pdnObject->lpDxVoiceNotifyClient->lpVtbl->Release( pdnObject->lpDxVoiceNotifyClient );
    	    pdnObject->lpDxVoiceNotifyClient = NULL;	    
	    }
	    else
	    {
	        DPFX(DPFPREP,  0, "No client currently registered" );
	        hr = DVERR_GENERIC;
	    }
	}
	else
	{
	    DPFX(DPFPREP,  0, "Could not find interface to unadvise" );
	    hr = DVERR_GENERIC;
	}
	
	DNLeaveCriticalSection( &pdnObject->csVoice );

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "VoiceIsGroupMember"
HRESULT __stdcall VoiceIsGroupMember( IDirectPlayVoiceTransport *pInterface, DVID dvidGroup, DVID dvidPlayer )
{
	PDIRECTNETOBJECT	pdnObject = (PDIRECTNETOBJECT) GET_OBJECT_FROM_INTERFACE(pInterface);	
	BOOL				fResult;

	if( dvidGroup == 0 )
	{
		return DV_OK;
	}
	
	fResult = pdnObject->NameTable.IsMember(dvidGroup,dvidPlayer);

	if( fResult )
	{
		return DV_OK;
	}
	else
	{
		return E_FAIL;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNVReturnBuffer"
void DNVReturnBuffer( DIRECTNETOBJECT *const pdnObject, PDVTRANSPORT_BUFFERDESC pBufferDesc, PVOID pvContext, HRESULT hrResult )
{
	if( InterlockedDecrement( &pBufferDesc->lRefCount ) == 0 )
	{
    	DVEVENTMSG_SENDCOMPLETE dvSendComplete;

    	dvSendComplete.pvUserContext = pvContext; 
		dvSendComplete.hrSendResult = hrResult; 

    	Voice_Notify( pdnObject, DVEVENT_SENDCOMPLETE, (DWORD_PTR) &dvSendComplete, 0, pBufferDesc->dwObjectType ); 
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteVoiceSend"

void DNCompleteVoiceSend(DIRECTNETOBJECT *const pdnObject,
						 CAsyncOp *const pAsyncOp)
{
	PDVTRANSPORT_BUFFERDESC pBufferDesc = (PDVTRANSPORT_BUFFERDESC) (pAsyncOp->GetContext());

	DNVReturnBuffer( pdnObject, pBufferDesc, pAsyncOp->GetContext(), pAsyncOp->GetResult() );

	//
	//	Still need to complete the SEND to clean up
	//
	DNCompleteSendAsyncOp(pdnObject,pAsyncOp);
}

#undef DPF_MODNAME
#define DPF_MODNAME "VoiceSendSpeech"
HRESULT __stdcall VoiceSendSpeech( IDirectPlayVoiceTransport *pInterface, DVID dvidFrom, DVID dvidTo, PDVTRANSPORT_BUFFERDESC pBufferDesc, LPVOID pvUserContext, DWORD dwFlags )
{
	if( dwFlags & DVTRANSPORT_SEND_SYNC )
	{
		return VoiceSendSpeechSync( pInterface, dvidFrom, dvidTo, pBufferDesc, pvUserContext, dwFlags );
	}
	else
	{
		return VoiceSendSpeechAsync( pInterface, dvidFrom, dvidTo, pBufferDesc, pvUserContext, dwFlags );
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "VoiceSendSpeech"
HRESULT __stdcall VoiceSendSpeechAsync( IDirectPlayVoiceTransport *pInterface, DVID dvidFrom, DVID dvidTo, PDVTRANSPORT_BUFFERDESC pBufferDesc, LPVOID pvUserContext, DWORD dwFlags )
{
	HRESULT             hr;
	DWORD	            dwAsyncFlags = 0;
	DWORD	            dwSendFlags = 0;
	PDIRECTNETOBJECT    pdnObject = (PDIRECTNETOBJECT) GET_OBJECT_FROM_INTERFACE(pInterface);
	CNameTableEntry		*pNTEntry;
	CGroupConnection	*pGroupConnection;
	CAsyncOp			*pAsyncOp;
    CConnection			*pConnection;
	DWORD				dwTimeout = 0;

	pNTEntry = NULL;
	pGroupConnection = NULL;
	pAsyncOp = NULL;
	pConnection = NULL;

    if( pBufferDesc->lRefCount == 0 )
    	pBufferDesc->lRefCount = 1;	

	//
    //	Flags
	//
	if (dwFlags & DVTRANSPORT_SEND_GUARANTEED)
	{
		dwSendFlags |= DN_SENDFLAGS_RELIABLE;
	}
	else
	{
		dwSendFlags |= DN_SENDFLAGS_NON_SEQUENTIAL;
		dwTimeout = DNET_VOICE_TIMEOUT;
	}

    // Sending to ALL players
	// Retrieve NameTableEntry (use AllPlayersGroup if none specified)
	if( dvidTo == 0 )
	{
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED) || (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING))
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
			hr = DPNERR_UNINITIALIZED;
			goto Failure;
		}

		if ((hr = pdnObject->NameTable.GetAllPlayersGroupRef( &pNTEntry )) != DPN_OK)
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

            if( dwFlags & DVTRANSPORT_SEND_GUARANTEED )
            {
                DPFX(DPFPREP, 0, "ERROR: All group does not exist!" );
				hr = DPNERR_GENERIC;
				goto Failure;
            }
            else
            {
    		    DPFX(DPFPREP, 1, "All players group missing -- must be shutting down" );
				hr = DPN_OK;
				goto Failure;
            }
		}

		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

		dvidTo = pNTEntry->GetDPNID();
	}
	// Sending to server player
	else if( dvidTo == 1 )
	{
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED) || (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING))
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
			hr = DPNERR_UNINITIALIZED;
			goto Failure;
		}

		if ((hr = pdnObject->NameTable.GetHostPlayerRef( &pNTEntry )) != DPN_OK)
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	        if( dwFlags & DVTRANSPORT_SEND_GUARANTEED )
	        {
	            DPFX(DPFPREP,  0, "ERROR: No host player in session!" );
				hr = DPNERR_GENERIC;
				goto Failure;
	        }
	        else
	        {
	            DPFX(DPFPREP,  1, "Host player missing -- must be shutting down" );
				hr = DPN_OK;
				goto Failure;
	        }
		}

		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	    dvidTo = pNTEntry->GetDPNID();
	}
	else
	{
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);

		if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED) || (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING))
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
			hr = DPNERR_UNINITIALIZED;
			goto Failure;
		}

		if ((hr = pdnObject->NameTable.FindEntry(dvidTo,&pNTEntry)) != DPN_OK)
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
			DPFERR("Could not find player/group");
			goto Failure;
		}

		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	}

	if (pNTEntry->IsGroup())
	{
		hr = DNSendGroupMessage(pdnObject,
								pNTEntry,
								DN_MSG_INTERNAL_VOICE_SEND,
								reinterpret_cast<DPN_BUFFER_DESC *>(pBufferDesc),
								NULL,
								dwTimeout,
								dwSendFlags,
								FALSE,
								FALSE,
								NULL,
								&pAsyncOp );

		if (hr == DPN_OK)
		{
			pAsyncOp->SetContext( pvUserContext );
			pAsyncOp->SetCompletion( DNCompleteVoiceSend );
			pAsyncOp->Release();
			pAsyncOp = NULL;
		}
	}
	else
	{
	    hr = pNTEntry->GetConnectionRef( &pConnection );

	    if( FAILED( hr ) )
	    {
	        DPFX(DPFPREP,  0, "Getting connection for player failed hr=0x%x", hr );
			goto Failure;
	    }
	    
   		DNASSERT(pConnection != NULL);
   		
   		hr = DNSendMessage(	pdnObject,
    						pConnection,
    						DN_MSG_INTERNAL_VOICE_SEND,
    						dvidTo,
    						reinterpret_cast<DPN_BUFFER_DESC *>(pBufferDesc),
    						NULL,
    						dwTimeout,
    						dwSendFlags,
							NULL,
    						&pAsyncOp);

		if (hr == DPNERR_PENDING)
		{
			pAsyncOp->SetContext( pvUserContext );
			pAsyncOp->SetCompletion( DNCompleteVoiceSend );
			pAsyncOp->Release();
			pAsyncOp = NULL;
			hr = DPN_OK;
		}
		else if (hr == DPNERR_INVALIDENDPOINT)
		{
			hr = DPNERR_INVALIDPLAYER;
		}

        // Release our reference on the connection
		pConnection->Release();
		pConnection = NULL;
	}

	pNTEntry->Release();
	pNTEntry = NULL;

Exit:
	return hr;

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pAsyncOp)
	{
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}

	DNVReturnBuffer( pdnObject, pBufferDesc, pvUserContext, hr );
		
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "VoiceSendSpeechSync"
HRESULT __stdcall VoiceSendSpeechSync(IDirectPlayVoiceTransport *pInterface,
									  DVID dvidFrom,
									  DVID dvidTo,
									  PDVTRANSPORT_BUFFERDESC pBufferDesc,
									  void *pvUserContext,
									  DWORD dwFlags )
{
	HRESULT             hr;
	HRESULT				hrSend;
	DWORD	            dwAsyncFlags = 0;
	DWORD	            dwSendFlags = 0;
	PDIRECTNETOBJECT    pdnObject = (PDIRECTNETOBJECT) GET_OBJECT_FROM_INTERFACE(pInterface);
	CNameTableEntry		*pNTEntry;
	CGroupConnection	*pGroupConnection;
	CAsyncOp			*pAsyncOp;
    CConnection			*pConnection;
	CSyncEvent			*pSyncEvent;
	DWORD				dwTimeout = 0;
	

	pNTEntry = NULL;
	pGroupConnection = NULL;
	pAsyncOp = NULL;
	pConnection = NULL;
	pSyncEvent = NULL;

    if( pBufferDesc->lRefCount == 0 )
    	pBufferDesc->lRefCount = 1;	

	//
	//	Create Sync Event
	//
	if ((hr = SyncEventNew(pdnObject,&pSyncEvent)) != DPN_OK)
	{
		DPFERR("Could not create SyncEvent");
		DisplayDNError(0,hr);
		goto Failure;
	}
	pSyncEvent->Reset();

	//
    //	Flags
	//
	if (dwFlags & DVTRANSPORT_SEND_GUARANTEED)
	{
		dwSendFlags |= DN_SENDFLAGS_RELIABLE;
	}
	else
	{
		dwSendFlags |= DN_SENDFLAGS_NON_SEQUENTIAL;
		dwTimeout = DNET_VOICE_TIMEOUT;
	}

	//
	//	Get appropriate target
	//
	if( dvidTo == 0 )
	{
		//
		//	Sending to ALL players
		//	Retrieve NameTableEntry (use AllPlayersGroup if none specified)
		//
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);

		if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED) || (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING))
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
			hr = DPNERR_UNINITIALIZED;
			goto Failure;
		}

		if ((hr = pdnObject->NameTable.GetAllPlayersGroupRef(&pNTEntry)) != DPN_OK)
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

            if( dwFlags & DVTRANSPORT_SEND_GUARANTEED )
            {
                DPFX(DPFPREP, 0, "ERROR: All group does not exist!" );
				hr = DPNERR_GENERIC;
				goto Failure;
            }
            else
            {
    		    DPFX(DPFPREP, 1, "All players group missing -- must be shutting down" );
				hr = DPN_OK;
				goto Failure;
            }
		}

		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

		dvidTo = pNTEntry->GetDPNID();
	}
	else if( dvidTo == 1 )
	{
		//
		//	Sending to server player
		//
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);

		if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED) || (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING))
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
			hr = DPNERR_UNINITIALIZED;
			goto Failure;
		}

		if ((hr = pdnObject->NameTable.GetHostPlayerRef( &pNTEntry )) != DPN_OK)
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	        if( dwFlags & DVTRANSPORT_SEND_GUARANTEED )
	        {
	            DPFX(DPFPREP,  0, "ERROR: No host player in session!" );
				hr = DPNERR_GENERIC;
				goto Failure;
	        }
	        else
	        {
	            DPFX(DPFPREP,  1, "Host player missing -- must be shutting down" );
				hr = DPN_OK;
				goto Failure;
	        }
		}

		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	    dvidTo = pNTEntry->GetDPNID();
	}
	else
	{
		//
		//	Targeted send to some other player
		//
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);

		if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED) || (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING))
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
			hr = DPNERR_UNINITIALIZED;
			goto Failure;
		}

		if ((hr = pdnObject->NameTable.FindEntry(dvidTo,&pNTEntry)) != DPN_OK)
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
			DPFERR("Could not find player/group");
			DisplayDNError(0,hr);
			goto Failure;
		}

		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	}

	if (pNTEntry->IsGroup())
	{
		hr = DNSendGroupMessage(pdnObject,
								pNTEntry,
								DN_MSG_INTERNAL_VOICE_SEND,
								reinterpret_cast<DPN_BUFFER_DESC *>(pBufferDesc),
								NULL,
								dwTimeout,
								dwSendFlags,
								FALSE,
								FALSE,
								NULL,
								&pAsyncOp );

		if (hr == DPN_OK)
		{
			pAsyncOp->SetContext( pvUserContext );
			pAsyncOp->SetSyncEvent( pSyncEvent );
			pAsyncOp->SetResultPointer( &hrSend );
			pAsyncOp->Release();
			pAsyncOp = NULL;
		}
	}
	else
	{
	    hr = pNTEntry->GetConnectionRef( &pConnection );

	    if( FAILED( hr ) )
	    {
	        DPFX(DPFPREP,  0, "Getting connection for player failed hr=0x%x", hr );
			DisplayDNError(0,hr);
			goto Failure;
	    }
	    
   		DNASSERT(pConnection != NULL);
   		
   		hr = DNSendMessage(	pdnObject,
    						pConnection,
    						DN_MSG_INTERNAL_VOICE_SEND,
    						dvidTo,
    						reinterpret_cast<DPN_BUFFER_DESC *>(pBufferDesc),
    						NULL,
    						dwTimeout,
    						dwSendFlags,
							NULL,
    						&pAsyncOp);

		if (hr == DPNERR_PENDING)
		{
			pAsyncOp->SetContext( pvUserContext );
			pAsyncOp->SetSyncEvent( pSyncEvent );
			pAsyncOp->SetResultPointer( &hrSend );
			pAsyncOp->Release();
			pAsyncOp = NULL;

			hr = DPN_OK;
		}

        // Release our reference on the connection
		pConnection->Release();
		pConnection = NULL;
	}

	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	Wait for SENDs to complete
	//
	pSyncEvent->WaitForEvent(INFINITE);
	pSyncEvent->ReturnSelfToPool();
	pSyncEvent = NULL;
	hr = hrSend;

Exit:
	return hr;

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pSyncEvent)
	{
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}

	DNVReturnBuffer( pdnObject, pBufferDesc, pvUserContext, hr );
	
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "VoiceGetSessionInfo"
HRESULT __stdcall VoiceGetSessionInfo( IDirectPlayVoiceTransport *pInterface, PDVTRANSPORTINFO pdvTransportInfo )
{
	PDIRECTNETOBJECT pdnObject = (PDIRECTNETOBJECT) GET_OBJECT_FROM_INTERFACE(pInterface);
	CNameTableEntry	*pHostPlayer;
	CNameTableEntry	*pLocalPlayer;
	
	pHostPlayer = NULL;
	pLocalPlayer = NULL;
	pdvTransportInfo->dwFlags = 0;

	if (pdnObject->ApplicationDesc.IsClientServer())
	{
		pdvTransportInfo->dwSessionType = DVTRANSPORT_SESSION_CLIENTSERVER;
	}
	else
	{
		pdvTransportInfo->dwSessionType = DVTRANSPORT_SESSION_PEERTOPEER;
	}

	if (pdnObject->ApplicationDesc.AllowHostMigrate())
	{
		pdvTransportInfo->dwFlags |= DVTRANSPORT_MIGRATEHOST;
	} 

	pdvTransportInfo->dwMaxPlayers = pdnObject->ApplicationDesc.GetMaxPlayers();

	if (pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer ) == DPN_OK)
	{
		pdvTransportInfo->dvidLocalID = pLocalPlayer->GetDPNID();
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	else
	{
		DPFERR( "Unable to find a local player" );
		pdvTransportInfo->dvidLocalID = 0;
		return DVERR_TRANSPORTNOPLAYER;
	}

	if (pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer ) != DPN_OK)
	{
		pdvTransportInfo->dvidSessionHost = 0;
		DPFERR( "Unable to find a session host" );
//		return DVERR_TRANSPORTNOPLAYER;
	}
	else
	{
		pdvTransportInfo->dvidSessionHost = pHostPlayer->GetDPNID();	
		pHostPlayer->Release();
	}
	
	pHostPlayer = NULL;

	if( pdvTransportInfo->dvidSessionHost == pdvTransportInfo->dvidLocalID )
	{
		pdvTransportInfo->dwFlags |= DVTRANSPORT_LOCALHOST;
	}
		
	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "VoiceIsValidGroup"
HRESULT __stdcall VoiceIsValidGroup( IDirectPlayVoiceTransport *pInterface, DVID dvidID, PBOOL pfIsValid )
{
	PDIRECTNETOBJECT pdnObject = (PDIRECTNETOBJECT) GET_OBJECT_FROM_INTERFACE(pInterface);
	HRESULT hr;
	CNameTableEntry	*pNTEntry;

	hr = pdnObject->NameTable.FindEntry(dvidID,&pNTEntry);

	if( FAILED( hr ) )
	{
		*pfIsValid = FALSE;
	}
	else if( pNTEntry->IsGroup() )
	{
		pNTEntry->Release();
		pNTEntry = NULL;
		*pfIsValid = TRUE;
	}
	else
	{
		pNTEntry->Release();
		pNTEntry = NULL;
		*pfIsValid = FALSE;
	}

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "VoiceIsValidPlayer"
HRESULT __stdcall VoiceIsValidPlayer( IDirectPlayVoiceTransport *pInterface, DVID dvidID, PBOOL pfIsValid )
{
	PDIRECTNETOBJECT pdnObject = (PDIRECTNETOBJECT) GET_OBJECT_FROM_INTERFACE(pInterface);
	HRESULT hr;
	CNameTableEntry	*pNTEntry;

	hr = pdnObject->NameTable.FindEntry(dvidID,&pNTEntry);

	if( FAILED( hr ) )
	{
		*pfIsValid = FALSE;
	}
	else if( !pNTEntry->IsGroup() )
	{
		pNTEntry->Release();
		pNTEntry = NULL;
		*pfIsValid = TRUE;
	}
	else
	{
		pNTEntry->Release();
		pNTEntry = NULL;
		*pfIsValid = FALSE;
	}

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "VoiceIsValidEntity"
HRESULT __stdcall VoiceIsValidEntity( IDirectPlayVoiceTransport *pInterface, DVID dvidID, PBOOL pfIsValid )
{
	PDIRECTNETOBJECT pdnObject = (PDIRECTNETOBJECT) GET_OBJECT_FROM_INTERFACE(pInterface);
	HRESULT hr;
	CNameTableEntry	*pNTEntry;

	hr = pdnObject->NameTable.FindEntry(dvidID,&pNTEntry);

	if( FAILED( hr ) )
	{
		*pfIsValid = FALSE;
	}
	else
	{
		pNTEntry->Release();
		pNTEntry = NULL;
		*pfIsValid = TRUE;
	}

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "VoiceSendSpeechEx"
HRESULT __stdcall VoiceSendSpeechEx( IDirectPlayVoiceTransport *pInterface, DVID dvidFrom, DWORD dwNumTargets, UNALIGNED DPNID * pdvidTargets, PDVTRANSPORT_BUFFERDESC pBufferDesc, PVOID pvUserContext, DWORD dwFlags )
{
	PDIRECTNETOBJECT pdnObject = (PDIRECTNETOBJECT) GET_OBJECT_FROM_INTERFACE(pInterface);	
	
	DWORD dwIndex;
	HRESULT hr;

	DNEnterCriticalSection( &pdnObject->csVoice );

	hr= VoiceTarget_ExpandTargetList(pdnObject, dwNumTargets, pdvidTargets);

	if(hr != DPN_OK)
	{
		DNLeaveCriticalSection( &pdnObject->csVoice );		
		return hr;
	}

	pBufferDesc->lRefCount = pdnObject->nExpandedTargets;

	// Send to our expanded and duplicate removed list.
	for(dwIndex=0; dwIndex < pdnObject->nExpandedTargets; dwIndex++)
	{
		hr = VoiceSendSpeech( pInterface, dvidFrom, pdnObject->pExpandedTargetList[dwIndex], pBufferDesc, pvUserContext, dwFlags );
	}    

	DNLeaveCriticalSection( &pdnObject->csVoice );			

	return hr;
}

/////////////////////////////////////////
// Support Routinesfor VoiceSendSpeechEx //
/////////////////////////////////////////

VOID VoiceTarget_ClearTargetList( DIRECTNETOBJECT *pdnObject )
{
	pdnObject->nTargets=0;
}

VOID VoiceTarget_ClearExpandedTargetList(DIRECTNETOBJECT *pdnObject)
{
	pdnObject->nExpandedTargets=0;
}

HRESULT VoiceTarget_AddExpandedTargetListEntry(DIRECTNETOBJECT *pdnObject, DPNID dpid)
{
	#define GROW_SIZE 16
	
	PDPNID pdpid;
	
	if(pdnObject->nExpandedTargets == pdnObject->nExpandedTargetListLen){
		// Need more room, allocate another 16 entries

		pdpid=new DPNID[pdnObject->nExpandedTargetListLen+GROW_SIZE];

		if(!pdpid){
			DPFX(DPFPREP,  0, "Error allocating room for target cache" );
			return DVERR_OUTOFMEMORY;
		}
		
		if(pdnObject->pExpandedTargetList){
			memcpy(pdpid, pdnObject->pExpandedTargetList, pdnObject->nExpandedTargetListLen*sizeof(DPNID));
			if( pdnObject->pExpandedTargetList )
			{
				delete [] pdnObject->pExpandedTargetList;
				pdnObject->pExpandedTargetList = NULL;
			}
		}
		pdnObject->pExpandedTargetList = pdpid;
		pdnObject->nExpandedTargetListLen += GROW_SIZE;
	}

	pdnObject->pExpandedTargetList[pdnObject->nExpandedTargets++]=dpid;

	return DV_OK;

	#undef GROW_SIZE
}

void VoiceTarget_AddIfNotAlreadyFound( DIRECTNETOBJECT *pdnObject, DPNID dpidID )
{
	DWORD j;
	
	for(j=0;j<pdnObject->nExpandedTargets;j++)
	{
		if( pdnObject->pExpandedTargetList[j] == dpidID )
		{
			break;
		}
	}

	// It was not found, add him to the list
	if( j == pdnObject->nExpandedTargets )
	{
		VoiceTarget_AddExpandedTargetListEntry(pdnObject, dpidID);							
	}
}

HRESULT VoiceTarget_ExpandTargetList(DIRECTNETOBJECT *pdnObject, DWORD nTargets, UNALIGNED DVID * pdvidTo)
{
	HRESULT hr=DPN_OK;
	UINT i;
	CNameTableEntry *pEntry;
	CGroupMember		*pGroupMember;
	CBilink				*pBilink;

	pEntry = NULL;
	
	// See if we need to change the expanded target list or we have it cached.
	
	if(nTargets != pdnObject->nTargets || memcmp(pdvidTo, pdnObject->pTargetList, nTargets * sizeof(DVID))){

		DPFX(DPFPREP, 9, "VoiceTarget_ExpandTargetList, new list re-building cached list\n");
		
		// the target list is wrong, rebuild it.
		// First copy the new target list...
		if(nTargets > pdnObject->nTargetListLen){
			// Current list is too small, possibly non-existant, allocate one to cache the list.
			if(pdnObject->pTargetList){
				delete [] pdnObject->pTargetList;
				pdnObject->pTargetList = NULL;
			}
			pdnObject->pTargetList=new DVID[nTargets];
			if(pdnObject->pTargetList){
				pdnObject->nTargetListLen=nTargets;
			} else {
				pdnObject->nTargetListLen=0;
				pdnObject->nTargets=0;
				hr=DPNERR_OUTOFMEMORY;
				DPFX(DPFPREP, 0,"Ran out of memory trying to cache target list!\n");
				goto exit;
			}
		}
		pdnObject->nTargets = nTargets;
		memcpy(pdnObject->pTargetList, pdvidTo, nTargets*sizeof(DPNID));

		// OK we have the target list cached, now build the list we are going to send to.
		VoiceTarget_ClearExpandedTargetList(pdnObject);
		for(i=0;i<pdnObject->nTargets;i++)
		{
			hr = pdnObject->NameTable.FindEntry( pdnObject->pTargetList[i], &pEntry );

			if( SUCCEEDED( hr ) )
			{
				if( !pEntry->IsGroup() )
				{
					VoiceTarget_AddIfNotAlreadyFound( pdnObject, pdnObject->pTargetList[i] );
				}
				else
				{
					pEntry->Lock();

					pBilink = pEntry->m_bilinkMembership.GetNext();
					while (pBilink != &pEntry->m_bilinkMembership)
					{
						pGroupMember = CONTAINING_OBJECT(pBilink,CGroupMember,m_bilinkPlayers);
						VoiceTarget_AddIfNotAlreadyFound( pdnObject, pGroupMember->GetPlayer()->GetDPNID() );
										
						pBilink = pBilink->GetNext();
					}

					pEntry->Unlock();					
				}

				pEntry->Release();
				pEntry = NULL;
				
			}
			
		}

	} else {
		DPFX(DPFPREP, 9,"ExpandTargetList, using cached list\n");
	}

exit:
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\dncorei.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dncorei.h
 *  Content:    DirectPlay Core master internal header file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/28/01    masonb  Created.
 *	04/10/01	mjn		Removed Handles.h
 *
 ***************************************************************************/

#ifndef __DNCOREI_H__
#define __DNCOREI_H__

// 
// Public includes
//
#include <windows.h>

// 
// DirectPlay public includes
//
#include "dplay8.h"
#include "dpaddr.h"
#include "dvoice.h"
#include "dplobby8.h"
#include "dpsp8.h"

// 
// DirectPlay private includes
//
#include "osind.h"
#include "classbilink.h"
#include "fpm.h"
#include "dneterrors.h"
#include "dndbg.h"
#include "LockedCCFPM.h"
#include "PackBuff.h"
#include "RCBuffer.h"
#include "comutil.h"
#include "creg.h"

// 
// Protocol includes
//
#include "DNPExtern.h"
#include "dnprot.h"

//
// Dpnsvr includes
//
#include "dpnsdef.h"
#include "dpnsvrq.h"
#include "dpnsvlib.h"

// 
// DirectX private includes
//
#include "verinfo.h"

// 
// Core private includes
//
#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_CORE

#include "Async.h"
#include "AppDesc.h"
#include "AsyncOp.h"
#include "CallbackThread.h"
#include "Cancel.h"
#include "Caps.h"
#include "Classfac.h"
#include "Client.h"
#include "Common.h"
#include "Comstuff.h"
#include "Connect.h"
#include "Connection.h"
#include "DNCore.h"
#include "DPProt.h"
#include "Enum_SP.h"
#include "EnumHosts.h"
#include "GroupCon.h"
#include "GroupMem.h"
#include "HandleTable.h"
#include "MemoryFPM.h"
#include "Message.h"
#include "NameTable.h"
#include "NTEntry.h"
#include "NTOp.h"
#include "NTOpList.h"
#include "Paramval.h"
#include "Peer.h"
#include "PendingDel.h"
#include "Pools.h"
#include "Protocol.h"
#include "QueuedMsg.h"
#include "Receive.h"
#include "Request.h"
#include "Server.h"
#include "ServProv.h"
#include "SPMessages.h"
#include "SyncEvent.h"
#include "User.h"
#include "Verify.h"
#include "Voice.h"
#include "Worker.h"
#include "WorkerJob.h"

#endif // __DNCOREI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\dpprot.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		DPlay8.h
 *  Content:	DirectPlay8 include file
 *  History:
 *	Date		By		Reason
 *	==========================
 *	9/26/2000	maosnb		created - Removed from public header dplay8.h
 *
 ***************************************************************************/

#ifndef __DIRECTPLAY8PROT_H__
#define __DIRECTPLAY8PROT_H__

#include <ole2.h>			// for DECLARE_INTERFACE and HRESULT

#include "dpaddr.h"

#ifdef __cplusplus
extern "C" {
#endif


/****************************************************************************
 *
 * DirectPlay8 CLSIDs
 *
 ****************************************************************************/

//// {EBFE7B84-628D-11D2-AE0F-006097B01411}
DEFINE_GUID(IID_IDirectPlay8Protocol,
0xebfe7b84, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);


/****************************************************************************
 *
 * DirectPlay8 Interface Definitions
 *
 ****************************************************************************/

typedef struct _DN_PROTOCOL_INTERFACE_VTBL DN_PROTOCOL_INTERFACE_VTBL, *PDN_PROTOCOL_INTERFACE_VTBL;

//
// COM definition for DirectPlay8 Protocol interface
//
#undef INTERFACE				// External COM Implementation
#define INTERFACE IDirectPlay8Protocol
DECLARE_INTERFACE_(IDirectPlay8Protocol,IUnknown)
{
	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface)			(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)			(THIS) PURE;
	STDMETHOD_(ULONG,Release)			(THIS) PURE;
	/*** IDirectPlay8Protocol methods ***/
	STDMETHOD(Initialize)				(THIS_ PVOID, PDN_PROTOCOL_INTERFACE_VTBL pfVTBL) PURE;
	STDMETHOD(Shutdown)					(THIS) PURE;
	STDMETHOD(AddServiceProvider)		(THIS_ IDP8ServiceProvider *const, PHANDLE) PURE;
	STDMETHOD(RemoveServiceProvider)	(THIS_ const HANDLE) PURE;
	STDMETHOD(Connect)					(THIS_ IDirectPlay8Address *const, IDirectPlay8Address *const, const HANDLE, ULONG, PVOID, PHANDLE) PURE;
	STDMETHOD(Listen)					(THIS_ IDirectPlay8Address *const, const HANDLE, ULONG, PVOID, PHANDLE) PURE;
	STDMETHOD(SendData)					(THIS_ HANDLE, UINT, PBUFFERDESC, UINT, ULONG, PVOID, PHANDLE) PURE;
	STDMETHOD(DisconnectEP)				(THIS_ HANDLE, PVOID, PHANDLE) PURE;
	STDMETHOD(Cancel)					(THIS_ HANDLE) PURE;
	STDMETHOD(ReturnReceiveBuffers)		(THIS_ HANDLE) PURE;
	STDMETHOD(GetEndpointCaps)			(THIS_ HANDLE, PVOID) PURE;
	STDMETHOD(GetCaps)					(THIS_ PDPN_CAPS) PURE;
	STDMETHOD(SetCaps)					(THIS_ const PDPN_CAPS) PURE;
	STDMETHOD(EnumQuery)				(THIS_ IDirectPlay8Address *const, IDirectPlay8Address *const, const HANDLE, BUFFERDESC *const, const DWORD, const DWORD, const DWORD, const DWORD, const DWORD, void *const, HANDLE *const) PURE;
	STDMETHOD(EnumRespond)				(THIS_ const HANDLE, const HANDLE, BUFFERDESC *const, const DWORD, const DWORD, void *const, HANDLE *const) PURE;
	STDMETHOD(CrackEPD)					(THIS_ HANDLE hEndPoint, long Flags, IDirectPlay8Address** ppAddr) PURE;
	STDMETHOD(GetListenAddressInfo)		(THIS_ HANDLE hCommand, long Flags, IDirectPlay8Address** ppAddr) PURE;
	STDMETHOD(Debug)					(THIS_ UINT, HANDLE, PVOID) PURE;
};

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\enumhosts.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Enum.cpp
 *  Content:    Enumeration routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  04/10/00	mjn		Created
 *	04/17/00	mjn		Fixed DNCompleteEnumQuery to clean up properly
 *	04/18/00	mjn		Return User Buffer in DNProcessEnumQuery
 *	04/19/00	mjn		Removed DPN_BUFFER_DESC from DPNMSG_ENUM_HOSTS_QUERY and DPNMSG_ENUM_HOSTS_RESPONSE structs
 *	05/02/00	mjn		Allow application to reject ENUM_QUERY's
 *	06/25/00	mjn		Fixed payload problem in DNProcessEnumQuery()
 *	07/10/00	mjn		Removed DNCompleteEnumQuery() and DNCompleteEnumResponse()
 *	07/12/00	mjn		Ensure connected before replying to ENUMs
 *	07/29/00	mjn		Verify enum responses sizes
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/05/00	mjn		Ensure cancelled operations don't proceed
 *	08/29/00	mjn		Cancel EnumHosts if non-DPN_OK returned from response notification
 *	09/04/00	mjn		Added CApplicationDesc
 *	09/14/00	mjn		AddRef Protocol refcount when invoking protocol
 *	01/22/01	mjn		Add SP reference on AsyncOp in DNProcessEnumQuery()
 *	01/25/01	mjn		Fixed 64-bit alignment problem in received messages
 *	03/13/01	mjn		Don't copy user response buffer when responding to enums
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//**********************************************************************
// ------------------------------
// DNProcessEnumQuery - process enum query
//
// Entry:		Pointer to this DNet interface object
//				Pointer to the associated listen operation
//				Pointer to protocol's enum data
//
// Exit:		Nothing
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessEnumQuery"

void DNProcessEnumQuery(DIRECTNETOBJECT *const pdnObject,
						CAsyncOp *const pListen,
						const PROTOCOL_ENUM_DATA *const pEnumQueryData )
{
	HRESULT						hResultCode;
	DPNMSG_ENUM_HOSTS_QUERY		AppData;
	CPackedBuffer				PackedBuffer;
	CRefCountBuffer				*pRefCountBuffer;
	CAsyncOp					*pAsyncOp;
	HANDLE						hProtocol;
	const DN_ENUM_QUERY_PAYLOAD	*pEnumQueryPayload;
	PVOID						pvBlock;
	DN_ENUM_RESPONSE			*pEnumResponse;
	DN_ENUM_RESPONSE_PAYLOAD	*pEnumResponsePayload;
	DWORD						dwPayloadOffset;
    IDP8ServiceProvider			*pIDP8SP;
    SPGETCAPSDATA				spGetCapsData;
	CServiceProvider			*pSP;
	DWORD						dwBufferCount;
	BOOL						fNeedToReturnBuffer;

	DPFX(DPFPREP, 6,"Parameters: pListen [0x%p], pEnumQueryData [0x%p]",pListen,pEnumQueryData);

	DNASSERT( pdnObject != NULL );
	DNASSERT( pListen != NULL );
	DNASSERT( pEnumQueryData != NULL );

	pAsyncOp = NULL;
	pRefCountBuffer = NULL;
	pvBlock = NULL;
	pIDP8SP = NULL;
	pSP = NULL;
	fNeedToReturnBuffer = FALSE;		// Is this needed ?

	//
	//	Ensure we are in a position to reply to this message.
	//	We must be CONNECTED and not be HOST_MIGRATING
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) || (pdnObject->dwFlags & DN_OBJECT_FLAG_HOST_MIGRATING))
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

		DPFX(DPFPREP, 7, "Not connected or host is migrating (object 0x%p flags = 0x%x), ignoring enum.", pdnObject, pdnObject->dwFlags);
		goto Failure;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	// Check to see if this message is for this game type.  Since the application
	// GUID cannot be changed while the session is running, there's no need to
	// enter a critical section.
	//
	pEnumQueryPayload = reinterpret_cast<DN_ENUM_QUERY_PAYLOAD*>( pEnumQueryData->ReceivedData.pBufferData );
	if ( pEnumQueryPayload == NULL )
	{
		//
		// no enum payload (there needs to be at least one byte!)
		//
		DPFX(DPFPREP, 4, "No enum payload, object 0x%p ignoring enum.", pdnObject);
		goto Failure;
	}

	dwPayloadOffset = 0;
	switch ( pEnumQueryPayload->QueryType )
	{
		//
		// an application guid was specified, make sure it matches this application's
		// guid before further processing
		//
		case DN_ENUM_QUERY_WITH_APPLICATION_GUID:
		{
			if ( pEnumQueryData->ReceivedData.dwBufferSize < sizeof( DN_ENUM_QUERY_PAYLOAD ) )
			{
				DNASSERT( FALSE );
				goto Failure;
			}

			if ( !pdnObject->ApplicationDesc.IsEqualApplicationGuid( &pEnumQueryPayload->guidApplication ) )
			{
#ifndef IA64
				DPFX(DPFPREP, 7, "Application GUID {%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X} doesn't match, object 0x%p, ignoring enum.",
					pEnumQueryPayload->guidApplication.Data1,
					pEnumQueryPayload->guidApplication.Data2,
					pEnumQueryPayload->guidApplication.Data3,
					pEnumQueryPayload->guidApplication.Data4[0],
					pEnumQueryPayload->guidApplication.Data4[1],
					pEnumQueryPayload->guidApplication.Data4[2],
					pEnumQueryPayload->guidApplication.Data4[3],
					pEnumQueryPayload->guidApplication.Data4[4],
					pEnumQueryPayload->guidApplication.Data4[5],
					pEnumQueryPayload->guidApplication.Data4[6],
					pEnumQueryPayload->guidApplication.Data4[7],
					pdnObject);
#endif // ! IA64
				goto Failure;
			}

			dwPayloadOffset = sizeof( DN_ENUM_QUERY_PAYLOAD );

			break;
		}

		//
		// no application guid was specified, continue processing
		//
		case DN_ENUM_QUERY_WITHOUT_APPLICATION_GUID:
		{
			if ( pEnumQueryData->ReceivedData.dwBufferSize < ( sizeof( DN_ENUM_QUERY_PAYLOAD ) - sizeof( GUID ) ) )
			{
				DNASSERT( FALSE );
				goto Failure;
			}

			dwPayloadOffset = sizeof( DN_ENUM_QUERY_PAYLOAD ) - sizeof( GUID );

			break;
		}

		default:
		{
			DNASSERT( FALSE );
			goto Failure;
			break;
		}
	}


	//
	// buld message structure, be nice and clear the user payload pointer if
	// there is no payload
	//
	AppData.dwSize = sizeof( AppData );
	AppData.pAddressSender = pEnumQueryData->pSenderAddress;
	AppData.pAddressDevice = pEnumQueryData->pDeviceAddress;

	DPFX(DPFPREP, 7,"AppData.pAddressSender: [0x%p]",AppData.pAddressSender);
	DPFX(DPFPREP, 7,"AppData.pAddressDevice: [0x%p]",AppData.pAddressDevice);

	if (pEnumQueryData->ReceivedData.dwBufferSize > dwPayloadOffset)
	{
		DNASSERT( pEnumQueryData->ReceivedData.pBufferData );
		DNASSERT( pEnumQueryData->ReceivedData.dwBufferSize );

		AppData.pvReceivedData = static_cast<void*>(static_cast<BYTE*>(pEnumQueryData->ReceivedData.pBufferData) + dwPayloadOffset);
		AppData.dwReceivedDataSize = pEnumQueryData->ReceivedData.dwBufferSize - dwPayloadOffset;
	}
	else
	{
		AppData.pvReceivedData = NULL;
		AppData.dwReceivedDataSize = 0;
	}

	//
	//	Response Info
	//
	AppData.pvResponseData = NULL;
	AppData.dwResponseDataSize = 0;
	AppData.pvResponseContext = NULL;

	//
	//	Determine max size of response
	//		-	Get SP interface from listen SP (listen's parent)
	//		-	Get SP caps on the interface to determine the total available buffer size
	//		-	Figure out what the DNET enum response size will be
	//		-	Determine space available to user
	//
	DNASSERT(pListen->GetParent() != NULL);
	DNASSERT(pListen->GetParent()->GetSP() != NULL);
	pListen->GetParent()->GetSP()->AddRef();
	pSP = pListen->GetParent()->GetSP();
	if ((hResultCode = pSP->GetInterfaceRef( &pIDP8SP )) != DPN_OK)
	{
		DPFERR("Could not get ListenSP SP interface");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
    memset( &spGetCapsData, 0x00, sizeof( SPGETCAPSDATA ) );
    spGetCapsData.dwSize = sizeof( SPGETCAPSDATA );
	spGetCapsData.hEndpoint = INVALID_HANDLE_VALUE;
    if ((hResultCode = pIDP8SP->lpVtbl->GetCaps( pIDP8SP, &spGetCapsData )) != DPN_OK)
	{
		DPFERR("Could not get SP caps");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pIDP8SP->lpVtbl->Release( pIDP8SP );
	pIDP8SP = NULL;
	PackedBuffer.Initialize(NULL,0);
	PackedBuffer.AddToFront(NULL,sizeof(DN_ENUM_RESPONSE_PAYLOAD));
	pdnObject->ApplicationDesc.PackInfo(&PackedBuffer,DN_APPDESCINFO_FLAG_SESSIONNAME|DN_APPDESCINFO_FLAG_RESERVEDDATA|
			DN_APPDESCINFO_FLAG_APPRESERVEDDATA);
	AppData.dwMaxResponseDataSize = spGetCapsData.dwEnumFrameSize - PackedBuffer.GetSizeRequired();

	//
	// pass message to the user
	//
	hResultCode = DNUserEnumQuery(pdnObject,&AppData);

	//
	//	Only ENUMs which are accepted get responded to
	//
	if (hResultCode != DPN_OK)
	{
		DPFX(DPFPREP, 9,"EnumQuery rejected");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	// get an async operation to track the progress of the response
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pAsyncOp)) != DPN_OK)
	{
		DPFERR("Could not allocate Async Op struct for enum response");
		DisplayDNError( 0, hResultCode );
		DNASSERT( FALSE );
		goto Failure;
	}
	pAsyncOp->SetOpType( ASYNC_OP_ENUM_RESPONSE );

	//
	// compute the size needed to pack up an application description with any
	// user data and send it back
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);

	PackedBuffer.Initialize(NULL,0);
	PackedBuffer.AddToFront(NULL,sizeof(DN_ENUM_RESPONSE_PAYLOAD));
	hResultCode = pdnObject->ApplicationDesc.PackInfo(&PackedBuffer,DN_APPDESCINFO_FLAG_SESSIONNAME|
			DN_APPDESCINFO_FLAG_RESERVEDDATA|DN_APPDESCINFO_FLAG_APPRESERVEDDATA);
	DNASSERT( hResultCode == DPNERR_BUFFERTOOSMALL );

	//
	//	Ensure this enum response will fit in SP enum frame - only indicate this if there was a response
	//
	if (((AppData.pvResponseData != NULL) && (AppData.dwResponseDataSize != 0)) &&
			(PackedBuffer.GetSizeRequired() + AppData.dwResponseDataSize > spGetCapsData.dwEnumFrameSize))
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		DPFERR("Enum response is too large");
		DNUserReturnBuffer(pdnObject,DPNERR_ENUMRESPONSETOOLARGE,AppData.pvResponseData,AppData.pvResponseContext);
		goto Failure;
	}

	hResultCode = RefCountBufferNew(pdnObject,
								PackedBuffer.GetSizeRequired(),
								&pRefCountBuffer);
	if ( hResultCode != DPN_OK )
	{
		DNASSERT( FALSE );
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		goto Failure;
	}
	PackedBuffer.Initialize(pRefCountBuffer->GetBufferAddress(),
							pRefCountBuffer->GetBufferSize());
	pEnumResponsePayload = static_cast<DN_ENUM_RESPONSE_PAYLOAD*>(PackedBuffer.GetHeadAddress());
	hResultCode = PackedBuffer.AddToFront(NULL,sizeof(DN_ENUM_RESPONSE_PAYLOAD));
	if (hResultCode != DPN_OK)
	{
		DNASSERT(FALSE);
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		goto Failure;
	}
	if ((AppData.pvResponseData != NULL) && (AppData.dwResponseDataSize != 0))
	{
		pEnumResponsePayload->dwResponseOffset = pRefCountBuffer->GetBufferSize();
		pEnumResponsePayload->dwResponseSize = AppData.dwResponseDataSize;
	}
	else
	{
		pEnumResponsePayload->dwResponseOffset = 0;
		pEnumResponsePayload->dwResponseSize = 0;
	}
	pdnObject->ApplicationDesc.PackInfo(&PackedBuffer,DN_APPDESCINFO_FLAG_SESSIONNAME|DN_APPDESCINFO_FLAG_RESERVEDDATA|
			DN_APPDESCINFO_FLAG_APPRESERVEDDATA);
	if ( hResultCode != DPN_OK )
	{
		DNASSERT( FALSE );
		goto Failure;
	}

	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	// build enum response and send it down to the protocol
	//
	if ((pvBlock = MemoryBlockAlloc(pdnObject,sizeof(DN_ENUM_RESPONSE))) == NULL)
	{
		DPFERR("Could not allocate Response block");
		hResultCode = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	pEnumResponse = static_cast<DN_ENUM_RESPONSE*>(pvBlock);

	pEnumResponse->BufferDesc[DN_ENUM_BUFFERDESC_RESPONSE_DN_PAYLOAD].pBufferData = pRefCountBuffer->GetBufferAddress();
	pEnumResponse->BufferDesc[DN_ENUM_BUFFERDESC_RESPONSE_DN_PAYLOAD].dwBufferSize = pRefCountBuffer->GetBufferSize();

	pAsyncOp->SetRefCountBuffer( pRefCountBuffer );
	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	pAsyncOp->SetCompletion( DNCompleteEnumResponse );
	pAsyncOp->SetOpData(pvBlock);
	pvBlock = NULL;		// This will get cleaned up by completion

	if ((AppData.pvResponseData != NULL) && (AppData.dwResponseDataSize != 0))
	{
		pEnumResponse->BufferDesc[DN_ENUM_BUFFERDESC_RESPONSE_USER_PAYLOAD].pBufferData = static_cast<BYTE*>(AppData.pvResponseData);
		pEnumResponse->BufferDesc[DN_ENUM_BUFFERDESC_RESPONSE_USER_PAYLOAD].dwBufferSize = AppData.dwResponseDataSize;
		pEnumResponse->pvUserContext = AppData.pvResponseContext;
		dwBufferCount = DN_ENUM_BUFFERDESC_RESPONSE_COUNT;
	}
	else
	{
		pEnumResponse->BufferDesc[DN_ENUM_BUFFERDESC_RESPONSE_USER_PAYLOAD].pBufferData = NULL;
		pEnumResponse->BufferDesc[DN_ENUM_BUFFERDESC_RESPONSE_USER_PAYLOAD].dwBufferSize = 0;
		pEnumResponse->pvUserContext = NULL;
		dwBufferCount = DN_ENUM_BUFFERDESC_RESPONSE_COUNT - 1;
	}

	DNASSERT(pListen->GetParent() != NULL);
	DNASSERT(pListen->GetParent()->GetSP() != NULL);
	DNASSERT(pListen->GetParent()->GetSP()->GetHandle() != NULL);

	//
	//	AddRef Protocol so that it won't go away until this completes
	//
	DNProtocolAddRef(pdnObject);

	pAsyncOp->AddRef();
	hResultCode = DNPEnumRespond(	pdnObject->pdnProtocolData,
									pListen->GetParent()->GetSP()->GetHandle(),
									pEnumQueryData->hEnumQuery,
									&pEnumResponse->BufferDesc[DN_ENUM_BUFFERDESC_RESPONSE_DN_PAYLOAD],
									dwBufferCount,
									0,
									reinterpret_cast<void*>(pAsyncOp),
									&hProtocol);
	if ( hResultCode != DPNERR_PENDING )
	{
		pAsyncOp->Release();
		DNProtocolRelease(pdnObject);
		goto Failure;
	}

	//
	//	Save Protocol Handle
	//
	pAsyncOp->Lock();
	if (pAsyncOp->IsCancelled())
	{
		HRESULT		hrCancel;

		pAsyncOp->Unlock();
		DPFX(DPFPREP, 7,"Operation marked for cancel");
		if ((hrCancel = DNPCancelCommand(pdnObject->pdnProtocolData,hProtocol)) == DPN_OK)
		{
			hResultCode = DPNERR_USERCANCEL;
			goto Failure;
		}
		DPFERR("Could not cancel operation");
		DisplayDNError(0,hrCancel);
		pAsyncOp->Lock();
	}
	pAsyncOp->SetSP( pSP );
	pAsyncOp->SetProtocolHandle(hProtocol);
	pAsyncOp->Unlock();

	pAsyncOp->Release();
	pAsyncOp = NULL;

	pSP->Release();
	pSP = NULL;

Exit:
	DPFX(DPFPREP, 6,"Returning");
	return;

Failure:
	if (pAsyncOp)
	{
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pvBlock)
	{
		MemoryBlockFree(pdnObject,pvBlock);
		pvBlock = NULL;
	}
	if (pIDP8SP)
	{
		pIDP8SP->lpVtbl->Release(pIDP8SP);
		pIDP8SP = NULL;
	}
	if (pSP)
	{
		pSP->Release();
		pSP = NULL;
	}
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNProcessEnumResponse - process response to enum query
//
// Entry:		Pointer to this DNet interface object
//				Pointer to the associated enum operation
//				Pointer to protocol's enum response data
//
// Exit:		Nothing
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessEnumResponse"

void DNProcessEnumResponse(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp *const pAsyncOp,
						   const PROTOCOL_ENUM_RESPONSE_DATA *const pEnumResponseData )
{
	HRESULT						hResultCode;
	DPNMSG_ENUM_HOSTS_RESPONSE	AppData;
	BYTE						*pWorkingItem;
	UNALIGNED DN_ENUM_RESPONSE_PAYLOAD	*pEnumResponsePayload;
	DPN_APPLICATION_DESC		dpnAppDesc;
	UNALIGNED DPN_APPLICATION_DESC_INFO	*pInfo;


	DNASSERT( pdnObject != NULL );
	DNASSERT( pAsyncOp != NULL );
	DNASSERT( pEnumResponseData != NULL );

	pWorkingItem = pEnumResponseData->ReceivedData.pBufferData;

	//
	//	Unpack the ENUM response.
	//	It will be in the following format:
	//	<UserResponseOffset>
	//	<UserResponseSize>
	//	<AppDescInfo>
	//

	pEnumResponsePayload = reinterpret_cast<DN_ENUM_RESPONSE_PAYLOAD*>(pEnumResponseData->ReceivedData.pBufferData);

	//
	// Application Description
	//
	pInfo = reinterpret_cast<DPN_APPLICATION_DESC_INFO*>(pEnumResponsePayload + 1);
	memset(&dpnAppDesc,0,sizeof(DPN_APPLICATION_DESC));
	if (pInfo->dwSessionNameOffset)
	{
		dpnAppDesc.pwszSessionName = reinterpret_cast<WCHAR*>(pWorkingItem + pInfo->dwSessionNameOffset);
	}
	if (pInfo->dwReservedDataOffset)
	{
		dpnAppDesc.pvReservedData = static_cast<void*>(pWorkingItem + pInfo->dwReservedDataOffset);
		dpnAppDesc.dwReservedDataSize = pInfo->dwReservedDataSize;
	}
	if (pInfo->dwApplicationReservedDataOffset)
	{
		dpnAppDesc.pvApplicationReservedData = static_cast<void*>(pWorkingItem + pInfo->dwApplicationReservedDataOffset);
		dpnAppDesc.dwApplicationReservedDataSize = pInfo->dwApplicationReservedDataSize;
	}
	dpnAppDesc.guidApplication = pInfo->guidApplication;
	dpnAppDesc.guidInstance = pInfo->guidInstance;
	dpnAppDesc.dwFlags = pInfo->dwFlags;
	dpnAppDesc.dwCurrentPlayers = pInfo->dwCurrentPlayers;
	dpnAppDesc.dwMaxPlayers = pInfo->dwMaxPlayers;
	dpnAppDesc.dwSize = sizeof(DPN_APPLICATION_DESC);

	//
	//	Fill in AppData
	//
	AppData.dwSize = sizeof( AppData );
	AppData.pAddressSender = pEnumResponseData->pSenderAddress;
	AppData.pAddressDevice = pEnumResponseData->pDeviceAddress;
	AppData.pApplicationDescription = &dpnAppDesc;
	AppData.dwRoundTripLatencyMS = pEnumResponseData->dwRoundTripTime;

	if (pEnumResponsePayload->dwResponseOffset)
	{
		AppData.pvResponseData = (pEnumResponseData->ReceivedData.pBufferData + pEnumResponsePayload->dwResponseOffset);
		AppData.dwResponseDataSize = pEnumResponsePayload->dwResponseSize;
	}
	else
	{
		AppData.pvResponseData = NULL;
		AppData.dwResponseDataSize = 0;
	}
	AppData.pvUserContext = pAsyncOp->GetContext();

	//
	// pass message to the user
	//
	hResultCode = DNUserEnumResponse(pdnObject,&AppData);

	//
	//	Check to see if this is to be cancelled
	//
	if (hResultCode != DPN_OK)
	{
		CAsyncOp	*pCancelOp = NULL;

		//
		//	Get top level operation (may be async op handle)
		//
		pAsyncOp->Lock();
		pCancelOp = pAsyncOp;
		while (pCancelOp->IsChild())
		{
			DNASSERT(pCancelOp->GetParent() != NULL);
			pCancelOp = pCancelOp->GetParent();
		}
		pCancelOp->AddRef();
		pAsyncOp->Unlock();

		//
		//	Cancel
		//
		DNCancelChildren(pdnObject,pCancelOp);
		pCancelOp->Release();
		pCancelOp = NULL;
	}

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\core\dncore.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dncore.h
 *  Content:    DIRECT NET CORE HEADER FILE
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/21/99	mjn		Created
 *	10/08/99	jtk		Moved COM interfaces into separate files
 *	11/09/99	mjn		Moved Worker Thread constants/structures to separate file
 *  12/23/99	mjn		Hand all NameTable update sends from Host to worker thread
 *  12/23/99	mjn		Added host migration structures and functions
 *	12/28/99	mjn		Added DNCompleteOutstandingOperations
 *	12/28/99	mjn		Added NameTable version to Host migration message
 *	12/28/99	mjn		Moved Async Op stuff to Async.h
 *	01/03/00	mjn		Added DNPrepareToDeletePlayer
 *	01/04/00	mjn		Added code to allow outstanding ops to complete at host migration
 *	01/06/00	mjn		Moved NameTable stuff to NameTable.h
 *	01/07/00	mjn		Moved Misc Functions to DNMisc.h
 *	01/08/00	mjn		Added DN_INTERNAL_MESSAGE_CONNECT_FAILED
 *	01/08/00	mjn		Removed unused connection info
 *	01/09/00	mjn		Added Application Description routines
 *						Changed SEND/ACK NAMETABLE to SEND/ACK CONNECT INFO
 *	01/10/00	mjn		Added DNSendUpdateAppDescMessage and DN_UserUpdateAppDesc
 *	01/11/00	mjn		Use CPackedBuffers instead of DN_ENUM_BUFFER_INFOs
 *						Moved Application Description stuff to AppDesc.h
 *						Moved Connect/Disconnect stuff to Connect.h
 *	01/13/00	mjn		Added CFixedPools for CRefCountBuffers
 *	01/14/00	mjn		Removed pvUserContext from DN_NAMETABLE_ENTRY_INFO
 *	01/14/00	mjn		Moved Message stuff to Message.h
 *	01/15/00	mjn		Replaced DN_COUNT_BUFFER with CRefCountBuffer
 *	01/16/00	mjn		Modified User message handler definition
 *						Moved User call back stuff to User.h
 *	01/17/00	mjn		Added DN_MSG_INTERNAL_VOICE_SEND and DN_MSG_INTERNAL_BUFFER_IN_USE
 *	01/18/00	mjn		Moved NameTable info structures to NameTable.h
 *	01/19/00	mjn		Added structures for NameTable Operation List
 *	01/20/00	mjn		Moved internal messages to Message.h
 *	01/21/00	mjn		Removed DNAcknowledgeHostRequest
 *	01/23/00	mjn		Added DN_MSG_INTERNAL_HOST_DESTROY_PLAYER
 *	01/24/00	mjn		Implemented NameTable operation list clean up
 *	01/25/00	mjn		Changed Host Migration to multi-step affair
 *	01/26/00	mjn		Implemented NameTable re-sync at host migration
 *	01/27/00	mjn		Reordered DN_MSG_INTERNAL's
 *	01/31/00	mjn		Added Internal FPM's for RefCountBuffers
 *	02/09/00	mjn		Implemented DNSEND_COMPLETEONPROCESS
 *	03/23/00	mjn		Implemented RegisterLobby()
 *	04/04/00	mjn		Added DN_MSG_INTERNAL_TERMINATE_SESSION
 *	04/09/00	mjn		Added support for CAsyncOp
 *	04/11/00	mjn		Moved DN_INTERNAL_MESSAGE_HEADER from Async.h
 *	04/11/00	mjn		Added DIRECTNETOBJECT bilink for CAsyncOps
 *	04/23/00	mjn		Replaced DN_MSG_INTERNAL_SEND_PROCESSED with DN_MSG_INTERNAL_REQ_PROCESS_COMPLETION
 *				mjn		Replaced DN_MSG_INTERNAL_SEND_PROCESSED_COMPLETE with DN_MSG_INTERNAL_PROCESS_COMPLETION
 *	04/26/00	mjn		Removed DN_ASYNC_OP and related functions
 *	04/28/00	mjn		Code clean up - removed comments and unused consts/structs/funcs
 *	05/23/00	mjn		Added DN_MSG_INTERNAL_INSTRUCTED_CONNECT_FAILED
 *	07/05/00	mjn		Removed references to DN_MSG_INTERNAL_ENUM_WITH_APPLICATION_GUID,DN_MSG_INTERNAL_ENUM,DN_MSG_INTERNAL_ENUM_RESPONSE
 *	07/07/00	mjn		Added pNewHost as host migration target to DirectNetObject
 *  07/09/00	rmt		Bug #38323 - RegisterLobby needs a DPNHANDLE parameter.
 *	07/12/00	mjn		Moved internal messages back to Message.h
 *	07/17/00	mjn		Add signature to DirectNetObject
 *	07/28/00	mjn		Added m_bilinkConnections to DirectNetObject
 *	07/30/00	mjn		Added CPendingDeletion
 *	07/31/00	mjn		Added CQueuedMsg
 *	08/05/00	mjn		Added m_bilinkActiveList and csActiveList
 *	08/06/00	mjn		Added CWorkerJob
 *	08/09/00	mjn		Added csConnectionList and m_bilinkIndicated
 *	08/11/00	mjn		Added DN_OBJECT_FLAG_HOST_MIGRATING_2 flag (!)
 *	08/23/00	mjn		Added DN_OBJECT_FLAG_DPNSVR_REGISTERED
 *	08/23/00	mjn		Added CNameTableOp
 *	09/04/00	mjn		Added CApplicationDesc
 *  09/13/00	rmt		Bug #44625 - DPVOICE: Multihomed machines are not always enumerable (Added DN_OBJECT_FLAG_LOCALHOST flag).
 *	02/05/01	mjn		Removed unused debug members from DIRECTNETOBJECT
 *				mjn		Added CCallbackThread
 *	03/30/01	mjn		Changes to prevent multiple loading/unloading of SP's
 *				mjn		Added pConnectSP,dwMaxFrameSize
 *				mjn		Removed blSPCapsList
 *	04/04/01	mjn		Re-ordered DirectNetObject fields
 *				mjn		Revised minor version number for DirectX8.1
 *				mjn		Added voice and lobby sigs
 *	04/05/01	mjn		Added DPNID parameter to DNProcessHostMigration3()
 *	04/13/01	mjn		Added m_bilinkRequestList
 *	05/17/01	mjn		Added dwRunningOpCount,hRunningOpEvent,dwWaitingThreadID to track threads performing NameTable operations
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__DNCORE_H__
#define	__DNCORE_H__

#include "AppDesc.h"
#include "HandleTable.h"
#include "NameTable.h"

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	DN_VERSION_MAJOR					0x0000
#define	DN_VERSION_MINOR					0x0002
#define	DN_VERSION_CURRENT					((DN_VERSION_MAJOR << 16) | DN_VERSION_MINOR)

#define	DN_OBJECT_FLAG_INITIALIZED			0x80000000
#define	DN_OBJECT_FLAG_LOBBY_AWARE			0x40000000
#define	DN_OBJECT_FLAG_DPNSVR_REGISTERED	0x20000000
#define DN_OBJECT_FLAG_LOCALHOST			0x10000000
#define	DN_OBJECT_FLAG_LISTENING			0x04000000
#define	DN_OBJECT_FLAG_ENUMERATING			0x02000000
#define	DN_OBJECT_FLAG_HOST_CONNECTED		0x01000000
#define	DN_OBJECT_FLAG_CONNECTING			0x00800000
#define	DN_OBJECT_FLAG_CONNECTED			0x00400000
#define	DN_OBJECT_FLAG_DISCONNECTING		0x00200000
#define	DN_OBJECT_FLAG_CLOSING				0x00100000
#define	DN_OBJECT_FLAG_HOST_MIGRATING_WAIT	0x00040000	// Wait for running operations to finish
#define DN_OBJECT_FLAG_HOST_MIGRATING_2		0x00020000
#define DN_OBJECT_FLAG_HOST_MIGRATING		0x00010000
#define DN_OBJECT_FLAG_PARAMVALIDATION		0x00000010
#define	DN_OBJECT_FLAG_PEER					0x00000004
#define	DN_OBJECT_FLAG_CLIENT				0x00000002
#define	DN_OBJECT_FLAG_SERVER				0x00000001

#define	DN_ALL_PLAYERS_GROUP_NAME			L"ALL PLAYERS"
#define	DN_ALL_PLAYERS_GROUP_NAME_SIZE		24

#define	DN_GUID_STR_LEN						38			// {XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}
#define	DN_FLAG_STR_LEN						5			// FALSE (or TRUE or YES or NO)

#undef DPF_SUBCOMP
#define DPF_SUBCOMP	DN_SUBCOMP_CORE // Used by Debug Logging to determine sub-component

//**********************************************************************
// Macro definitions
//**********************************************************************

#define TRY 			_try
#define EXCEPT(a)		_except( a )


//**********************************************************************
// Structure definitions
//**********************************************************************

typedef struct IDirectPlay8Address	IDirectPlay8Address;				// DPNAddr.h
typedef struct IDP8ServiceProvider	IDP8ServiceProvider;				// DPSP8.h
typedef struct IDirectPlay8LobbiedApplication	IDirectPlay8LobbiedApplication;
typedef struct IDirectPlayVoiceNotify			*PDIRECTPLAYVOICENOTIFY;
typedef struct _INTERFACE_LIST		INTERFACE_LIST;	// ComStuff.h

class CServiceProvider;
class CRefCountBuffer;
template < class CRefCountBuffer > class CLockedContextClassFixedPool;
class CSyncEvent;
template < class CSyncEvent > class CLockedContextClassFixedPool;
class CConnection;
template < class CConnection > class CLockedContextClassFixedPool;
class CGroupConnection;
template < class CGroupConnection > class CLockedContextClassFixedPool;
class CGroupMember;
template < class CGroupMember > class CLockedContextClassFixedPool;
class CNameTableEntry;
template < class CNameTableEntry > class CLockedContextClassFixedPool;
class CNameTableOp;
template < class CNameTableOp > class CLockedContextClassFixedPool;
class CAsyncOp;
template < class CAsyncOp > class CLockedContextClassFixedPool;
class CPendingDeletion;
template < class CPendingDeletion > class CLockedContextClassFixedPool;
class CQueuedMsg;
template < class CQueuedMsg > class CLockedContextClassFixedPool;
class CWorkerJob;
template < class CWorkerJob > class CLockedContextClassFixedPool;
class CMemoryBlockTiny;
template < class CMemoryBlockTiny > class CLockedContextClassFixedPool;
class CMemoryBlockSmall;
template < class CMemoryBlockSmall > class CLockedContextClassFixedPool;
class CMemoryBlockMedium;
template < class CMemoryBlockMedium > class CLockedContextClassFixedPool;
class CMemoryBlockLarge;
template < class CMemoryBlockLarge > class CLockedContextClassFixedPool;
class CMemoryBlockHuge;
template < class CMemoryBlockHuge > class CLockedContextClassFixedPool;

typedef struct protocoldata	*PProtocolData;


//
// Voice Additions
//
// this is the number of clients of IDirectXVoice in this process
// this is actually a ridiculously large number of client slots.
//
#define MAX_VOICE_CLIENTS	32	

typedef struct _DIRECTNETOBJECT {
	BYTE					Sig[4];					// Signature

	//
	//	DirectNet object flags
	//	Protected by csDirectNetObject
	//
	DWORD	volatile		dwFlags;

	//
	//	User information
	//	Protected by csDirectNetObject
	//
	PVOID					pvUserContext;
	PFNDPNMESSAGEHANDLER	pfnDnUserMessageHandler;

	//
	//	Shutdown info
	//	Protected by csDirectNetObject
	//
	DWORD	volatile		dwLockCount;			// Count to prevent closing
	HANDLE					hLockEvent;				// Set when dwLockCount=0

	//
	//	Protocol information
	//	Protected by csDirectNetObject
	//
	LONG	volatile		lProtocolRefCount;		// Protocol usage
	CSyncEvent				*hProtocolShutdownEvent;// No outstanding protocol operations
	PProtocolData			pdnProtocolData;

	//
	//	Listen information
	//	Protected by csDirectNetObject
	//
	CAsyncOp				*pListenParent;			// LISTEN async op
	DWORD					dwMaxFrameSize;			// Max frame size (cached for enum payload size checks)

	//
	//	Connect information
	//	Protected by csDirectNetObject
	//
	CAsyncOp				*pConnectParent;		// CONNECT async op
	PVOID					pvConnectData;			// Connect data
	DWORD					dwConnectDataSize;
	CServiceProvider		*pConnectSP;			// SP used to connect (cached for future connects)
	IDirectPlay8Address		*pIDP8ADevice;			// SP Local Device
	IDirectPlay8Address		*pIDP8AEnum;			// Address to listen on for enums after host migration

	//
	//	Host migration information
	//	Protected by csDirectNetObject
	//
	CNameTableEntry			*pNewHost;				// Host migration target
	DWORD	volatile		dwRunningOpCount;		// Running operation count (wait for them during host migration)
	HANDLE					hRunningOpEvent;		// Running operation event (set when running ops finish)
	DWORD	volatile		dwWaitingThreadID;		// Last thread to wait for outstanding running operations

	//
	//	Outstanding callback threads	(use csCallbackThreads)
	//	Protected by csCallbackThreads
	//
	CBilink					m_bilinkCallbackThreads;

	//
	//	Outstanding CAsyncOps
	//	Protected by csAsyncOperations
	//
	CBilink					m_bilinkAsyncOps;

	//
	//	Outstanding CConnections
	//	Protected by csConnectionList
	//
	CBilink					m_bilinkConnections;
	CBilink					m_bilinkIndicated;		// Indicated connections

	//
	//	Active CAsyncOps (w/ protocol handles, no requests)
	//	Protected by csActiveList
	//
	CBilink					m_bilinkActiveList;

	//
	//	Request CAsyncOps (no active CAsyncOps)
	//	Protected by csActiveList
	//
	CBilink					m_bilinkRequestList;

	//
	//	CBilink of NameTable pending deletions
	//	Protected by csNameTableOpList
	//
	CBilink					m_bilinkPendingDeletions;

	//
	//	Protected by csServiceProviders
	//
	CBilink					m_bilinkServiceProviders;

	//
	//	Protected by csWorkerQueue
	//
	CBilink					m_bilinkWorkerJobs;
	HANDLE					hWorkerThread;			// Worker thread handle
	HANDLE					hWorkerEvent;			// Handle of event to trigger worker thread

	//
	//	Application Description
	//
	CApplicationDesc		ApplicationDesc;

	//
	//	Name Table
	//
	CNameTable				NameTable;

	//
	//	Handle Table
	//
	CHandleTable			HandleTable;

	//
	//	Fixed Pools
	//
	CLockedContextClassFixedPool< CRefCountBuffer >		*m_pFPOOLRefCountBuffer;

	CLockedContextClassFixedPool< CSyncEvent >			*m_pFPOOLSyncEvent;

	CLockedContextClassFixedPool< CConnection >			*m_pFPOOLConnection;

	CLockedContextClassFixedPool< CGroupConnection>		*m_pFPOOLGroupConnection;

	CLockedContextClassFixedPool< CGroupMember >		*m_pFPOOLGroupMember;

	CLockedContextClassFixedPool< CNameTableEntry >		*m_pFPOOLNameTableEntry;

	CLockedContextClassFixedPool< CNameTableOp >		*m_pFPOOLNameTableOp;

	CLockedContextClassFixedPool< CAsyncOp >			*m_pFPOOLAsyncOp;

	CLockedContextClassFixedPool< CPendingDeletion >	*m_pFPOOLPendingDeletion;

	CLockedContextClassFixedPool< CQueuedMsg >			*m_pFPOOLQueuedMsg;

	CLockedContextClassFixedPool< CWorkerJob >			*m_pFPOOLWorkerJob;

	CLockedContextClassFixedPool< CMemoryBlockTiny>		*m_pFPOOLMemoryBlockTiny;
	CLockedContextClassFixedPool< CMemoryBlockSmall>	*m_pFPOOLMemoryBlockSmall;
	CLockedContextClassFixedPool< CMemoryBlockMedium>	*m_pFPOOLMemoryBlockMedium;
	CLockedContextClassFixedPool< CMemoryBlockLarge>	*m_pFPOOLMemoryBlockLarge;
	CLockedContextClassFixedPool< CMemoryBlockHuge>		*m_pFPOOLMemoryBlockHuge;

	//
	//	Critical Sections
	//
	DNCRITICAL_SECTION		csDirectNetObject;		// access control critical section

	DNCRITICAL_SECTION		csCallbackThreads;		// CS to protect callback thread list CBilink

	DNCRITICAL_SECTION		csAsyncOperations;		// CS to protect outstanding async CBilink

	DNCRITICAL_SECTION		csActiveList;			// CS to protect active list of AsyncOps

	DNCRITICAL_SECTION		csConnectionList;		// CS to protect Connection list

	DNCRITICAL_SECTION		csNameTableOpList;		// CS to protect NameTable operation list

	DNCRITICAL_SECTION		csServiceProviders;		// CS to protect Service Provider list

	DNCRITICAL_SECTION		csWorkerQueue;			// CS to protect worker thread job queue

	DNCRITICAL_SECTION		csVoice;				// CS to protect voice

	//
	//	Voice Additions
	//	Protected by csVoice
	//
	BYTE					VoiceSig[4];
	PDIRECTPLAYVOICENOTIFY	lpDxVoiceNotifyServer;
	PDIRECTPLAYVOICENOTIFY  lpDxVoiceNotifyClient;

	//
	//	Send Target Cache for voice targets on DV_SendSpeechEx
	//	Protected by csVoice
	//
	DWORD					nTargets;			     // number of used entries in the target list
	DWORD					nTargetListLen;          // max number of target list entries list can hold
	PDPNID					pTargetList;	  	   // ptr to target list array
	DWORD					nExpandedTargets;        // simplified list of targets, removes dup's
	DWORD					nExpandedTargetListLen;  // max number of target list entries list can hold
	PDPNID					pExpandedTargetList;	// ptr to array of simplified list of targets

	//
	//	Lobby additions
	//
	BYTE					LobbySig[4];
	IDirectPlay8Address		*pConnectAddress;		// Connect Address (cached) for clients
	DPNHANDLE				dpnhLobbyConnection;	// Lobby Connection to update

	IDirectPlay8LobbiedApplication	*pIDP8LobbiedApplication;
	
} DIRECTNETOBJECT, *PDIRECTNETOBJECT;


//**********************************************************************
// Variable definitions
//**********************************************************************

//**************************************************