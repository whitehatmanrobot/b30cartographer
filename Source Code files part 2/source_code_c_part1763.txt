ext)    { FormatStr.printMofTxt(f,LineNo); }
        TEXT_FIELD(Indent)  
            { 
                if(Indent.size()) {
                    fprintf(f, "INDENT="); 
                    fprint_str(f, Indent);
                }
            }
        TEXT_FIELD(MsgNo)   { fprintf(f, "%d", id & 0xFFFF); }
        TEXT_FIELD(GuidNo)  { fprintf(f, "%d", id >> 16); }
        TEXT_FIELD(Guid)    { printTraceGuid(f, id >> 16); }
        TEXT_FIELD(Name)    { fprint_str(f, IdName ); }
        TEXT_FIELD(Line)    { fprintf(f, "%d", LineNo ); }
        TEXT_FIELD(MsgVal)  { fprint_str(f, msgval ); }
        TEXT_FIELD(ReorderSig)  { fprint_str(f, reorderSig ); }
        TEXT_FIELD(TypeSig) { fprint_str(f, typeSig->Name); }
        TEXT_FIELD(Count)   { fprintf(f, "%d", FormatStr.ArgCount); }
//        TEXT_FIELD(CtlMsg)  { ??? }
//        TEXT_FIELD(Enabled)
        ENUM_FIELD(Arguments, Args, VectorTag)
        TEXT_FIELD(GooPairs)
            {
                size_t k = func->nAssumedArgs;
                // print assumed arguments
                for(size_t i = 0; i < k; ++i) {
                    fprintf(f, " ");
                    fprint_str(f, func->GooId[i]);
                    fprintf(f, "=");
                    fprint_str(f, func->Goo[i]);
                }
                // print the goo we pulled out of the trace statement itself
                size_t n = min(func->GooId.size()-k, GooActualValues.size());
                for(size_t i = 0; i < n; ++i) {
                    fprintf(f, " ");
                    fprint_str(f, func->GooId[i+k]);
                    fprintf(f, "=");
                    fprint_str(f, GooActualValues[i]);
                }
            }
        TEXT_FIELD(FixedArgs) 
            {
                for(int i = 0; i < func->Args.size(); ++i) {
                    fprint_str(f, func->Args[i]);
                    fprintf(f, ", ");
                }
            }
        TEXT_FIELD(GooVals) 
            {
                for(int i = 0; i < func->Goo.size(); ++i) {
                    if (i > 0) fprintf(f,", ");
                    fprint_str(f, func->Goo[i]);
                }
            }
        TEXT_FIELD(GooArgs)
            {
                for(int i = 0; i < func->GooId.size(); ++i) {
                    if (i > 0) fprintf(f,",");
                    fprint_str(f, func->GooId[i]);
                }
            }
        TEXT_FIELD(GooId)
            {
                for(int i = 0; i < func->GooId.size(); ++i) {
                    fprintf(f,"_");
                    fprint_str(f, func->GooId[i]);
                }
            }
        TEXT_FIELD(MacroExprs) 
            {
                for(int i = 0; i < Args.size(); ++i) {
                    if (Args[i].OverrideName.size() > 0) {
                        fprintf(f,",");
                        fprint_str(f, Args[i].OverrideName);
                    } else {
                        fprintf(f, ",a%d", Args[i].No);
                    }
                }
            }
        TEXT_FIELD(MacroArgs) 
            {
                fprintf(f,"MSG");
                for(int i = 0; i < Args.size(); ++i) {
                    if (Args[i].OverrideName.size() > 0) {
//                        fprint_str(f, Args[i].OverrideName);
                    } else {
//                        if (i != 0) fprintf(f,",");
                        fprintf(f, ",a%d", i + MSGTYPBASE);
                    }
                }
            }
    END_FIELD_TABLE

    Message(){}
    Message(
        const string& idTxt,
        const string&,     
        const vector<Argument>&,
        UINT msgid,
        int lineno,
        const ParsedFormatString& fmtStr,
        const Func& aFunc
        )
    :IdName(idTxt), id(msgid), LineNo(lineno), 
     FormatStr(fmtStr),func(&aFunc)
    {
 
        
        Args.resize(FormatStr.ArgCount, Argument("",0) );

        for(int i = 0; i < FormatStr.Items.size(); ++i) {
            int no = FormatStr.Items[i].no;
            if (no > 0) {
                Args[no-1] = Argument
                    (FormatStr.Items[i].expr, FormatStr.Items[i].type);
                Args[no-1].OverrideName = FormatStr.Items[i].argName;
                Args[no-1].No = no-1 + MSGTYPBASE;
            }
        }

        if (reorder) {
            sort(Args.begin(), Args.end());
        }
        for (int j = 0; j < FormatStr.Items.size(); ++j) {
            int& no = FormatStr.Items[j].no;
            if (no > 0) {
                // find new msg no for that
                for(int k = 0; k < Args.size(); ++k) {
                    if (Args[k].No == no-1 + MSGTYPBASE) {
                        no = MSGTYPBASE + k;
                        break;
                    }
                }
//                Args[no-1].OverrideName = FormatStr.Items[i].argName;
            }
        }
        typeSig = GetTypeSig(Args, func->Unsafe());

        if (func->MsgArg) {
            reorderSig = GetReorderSig(Args);
        }
        
//        UpgradeFormatSpecifiers(Msg, 10, (typeSig.size())?0:&TypeSig); 
//        ChkArgs();
    }
};

struct File : FieldHolder {
    string _CanonicalName; // lower case, bad chars => _
    string _Path;
    string _UppercaseName; // uppercase canonical
    string _Name;
    string _BaseName;      // no extension
    ULONGLONG ModificationTime;

    //
    // Since the file is a member of the set type
    // fields that don't affect set membership should be mutables
    //
    mutable vector<Message*> Msgs;
    mutable set<string, strless> IdsFound;

    BEGIN_FIELD_TABLE(File, out)
        TEXT_FIELD(Name)          fprint_str(out, _Name );
        TEXT_FIELD(Path)          fprint_str(out, _Path );
        TEXT_FIELD(CanonicalName) fprint_str(out, _CanonicalName );
        TEXT_FIELD(UppercaseName) fprint_str(out, _UppercaseName );
        ENUM_FIELD(Messages, Msgs, VectorPtrTag)
    END_FIELD_TABLE

    File(){} // to make STL and compiler happy

    string FullFileName() const {
    	string Tmp(_Path);
    	Tmp.append(_Name);
    	return Tmp;
    }

    File(const string& FileName, const string& Path, const WIN32_FIND_DATA& FindData)
    	:_Name(FileName), _Path(Path)
   	{    
        CopyMemory(&ModificationTime, &FindData.ftLastWriteTime, sizeof(ModificationTime));
   
        // Canonicalize FileName
        // i.e. make it suitable to be a DEFINE name
        //
        // Cut the path out. Replace all non-alphanumeric symbols
        // with an underscore.

        string::size_type pos = _Name.rfind('\\');
        if (pos == string::npos) {
            // No back slash
            _CanonicalName.assign(_Name);
        } else {
            // Get only the name part
            _CanonicalName.assign(_Name.begin() + pos, _Name.end());
        }

        // strip extension for a base name 
        string::size_type ext = _CanonicalName.rfind('.');
        if (ext != string::npos) {
            // there was a "."
            _BaseName.assign(_CanonicalName.begin(),
                             _CanonicalName.begin() + ext);
        } else {
            _BaseName.assign(_CanonicalName);
        }

        // Can't have a digit in the first position
        // Let's prepend it with an underscore

        {
            char ch = _CanonicalName[0];
            if ( ch >= '0' && ch <= '9' ) {
                _CanonicalName.insert(0, '_');
            }
        }

        _UppercaseName.assign( _CanonicalName );
        
        for(UINT i = 0; i < _CanonicalName.size(); ++i) {
            char ch = _CanonicalName[i];
            if ( (ch == '_') 
              || ((ch >= 'A') && (ch <= 'Z'))
              || ((ch >= '0') && (ch <= '9')) )
            {
                // Good Character. Do nothing
            } else if ( (ch >= 'a') && (ch <= 'z') ) {
                _UppercaseName[i] = static_cast<char>(ch - 'a' + 'A');
            } else {
                _CanonicalName[i] = '_';
                _UppercaseName[i] = '_';
            }
        }
    }

    bool operator < (const File& b) const {
        return _CanonicalName.compare(b._CanonicalName) < 0;
    }
};

int Message::ArgConsumed() const 
{
    vector<Argument>::const_iterator i = Args.begin();
    int sum = 0;
    for(;i != Args.end(); ++i) {
        sum += i->Type->ArgConsumed;
    }
    return sum;
}

void Message::hash(Hasher& hash) const 
{
    vector<Argument>::const_iterator i = Args.begin();
    for(;i != Args.end(); ++i) {
        i->hash(hash);
    }
    hash.Hash(&id, sizeof(id));
    hash.Hash(IdName);
    hash.Hash(FormatStr.HostString);
}

typedef map<string, string, strless > TYPE_MAP;
typedef map<string, Message, strless > MSG_MAP;
//typedef map<string, WppTyp, strless > MACRO_MAP;
typedef map<string, Func, strless > FUNC_MAP;
typedef map<string, Group, strless> GROUP_MAP;
typedef vector< Prefix > PREFIX_VECTOR;
typedef set<File> FILES;

FILES::iterator CurrentFile;
string CurrentTpl;

string currentFileName()
    { return CurrentFile->_Name; }

void MsgMapHash(
	const MSG_MAP& msgmap,
	Hasher& hash
	)
{
	MSG_MAP::iterator i = msgmap.begin();
	for(;i != msgmap.end(); ++i) {
	    i->second.hash(hash);
	}
}

void expand(IN OUT string& str, const string& id);

BOOL
parseMsg(
    IN LPCSTR beg,
    IN LPCSTR end,
    IN OUT string& str,
    OUT LPCSTR* strend = 0
    )
{
    LPCSTR p = beg;

    for(;;) {

        if (*p == '_' || isalpha(*p)) {
            const char * id = p;
            for(;;) {
               if (++p == end) { expand(str, string(id,p)); goto done; }
               if (*p == '_' || isalpha(*p) || isdigit(*p)) continue;
               break;
            }
            expand(str, string(id,p));
        }
        if (*p == ',')  goto done;
        if (*p == '"') {
            const char * run = ++p;
            for(;;) {
                if (p == end) goto unterminated;
                if (*p == '"' && p[-1] != '\\') break;
                ++p;
            }
            str.append(run,p);
        }
        if (++p == end) break;
    }
done:
    if (str.size() == 0) {
        ReportError("parsing %s. Cannot find format string\n",
           string(beg,end).c_str() );
        return FALSE;
    }

    // eat whitespace at the end
    while (str.size() > 0 && isspace( str.end()[-1]) ) 
        { str.resize(str.size()-1); }
    // get rid of pesky trailing \n    
    if (str.size() >= 2 && str.end()[-1] == 'n' && str.end()[-2] == '\\') {
        str.resize(str.size()-2);
    }

    Flood("msg: \"%s\".\n", str.c_str() );
    if (strend) {
        *strend = p;
    }
    return TRUE;
    
unterminated:
    ReportError("Unterminated string constant\n");
     return FALSE;
}        

BOOL
parseArgs(
    IN LPCSTR beg, 
    IN LPCSTR end,
    IN OUT vector<Argument>& args
    );

#define isvar(x) ( isalnum(x) || (x == '_') )

/*
ArgType::ArgType(
	IN const WppType* wppType):Type(0),TypevString(wppType->FormatSpec), NativeType(wppType),Used(FALSE)
{
    MofType = wppType->MofType;
    ExtendedType = wppType->Extension;
}
*/
Prefix::Prefix(
    IN PSTR_PAIR str, 
    IN UINT count):FuncName(str[1].beg, str[1].end)
{
    vector<string> ArgNames;

    if (count > 2) {
        string msg;
        if (str[2].beg < str[2].end && 
            str[2].beg[0] == '"') parseMsg(str[2].beg, str[2].end, msg);
        else msg.assign(str[2].beg, str[2].end);
        FmtStr.init( msg );
    }
    if (count > 3) {
        count -= 3; str += 2;
        while (count-- > 0) {
            ++str; ArgNames.push_back( string(str->beg,str->end) );
        }
    }

    // check that sizes match //
    if (ArgNames.size() > FmtStr.ArgCount ) {
        ReportError("Prefix: Extra argument. Only %d are specified in the string\n", FmtStr.ArgCount);
        exit(1);
    }
    if (ArgNames.size() < FmtStr.ArgCount ) {
        ReportError("Prefix: Not enough args. %d are specified in the string\n", FmtStr.ArgCount);
        exit(1);
    }

    for(int i = 0; i < FmtStr.Items.size(); ++i) {
        int no = FmtStr.Items[i].no;
        if (no > 0) {
            FmtStr.Items[i].argName = ArgNames[no-1];
            FmtStr.Items[i].expr = ArgNames[no-1];
        }
    }
}

struct GuidEntry : FieldHolder {
    GUID guid;
    string comment;
    int count;

    vector<Message*> Msgs;

    void printTxt(FILE* f) const {
        fprintf(f,"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                guid.Data1,guid.Data2,guid.Data3,
                guid.Data4[0],guid.Data4[1],guid.Data4[2],guid.Data4[3],
                guid.Data4[4],guid.Data4[5],guid.Data4[6],guid.Data4[7] );
    }
    void printDat(FILE* f) const {
        fprintf(f,"{0x%08x,0x%04x,0x%04x,{0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x}}",
                guid.Data1,guid.Data2,guid.Data3,
                guid.Data4[0],guid.Data4[1],guid.Data4[2],guid.Data4[3],
                guid.Data4[4],guid.Data4[5],guid.Data4[6],guid.Data4[7] );
    }

    BEGIN_FIELD_TABLE(GuidEntry, f) 
        TEXT_FIELD(Text) { printTxt(f); }
        TEXT_FIELD(Struct) { printDat(f);}
        TEXT_FIELD(Comment) fprintf(f, "%s", comment.c_str() );
        ENUM_FIELD(Messages, Msgs, VectorPtrTag);
    END_FIELD_TABLE

    GuidEntry(){}
    GuidEntry(int cnt, const string& cmnt):count(cnt),comment(cmnt) {
        RPC_STATUS status = UuidCreate( &guid );
        if ( status != RPC_S_OK ) {
            ReportError("UuidCreate failed with error %s\n", status);
            exit(1);
        }
    }
    GuidEntry(PSTR_PAIR p, int cnt, const string& cmnt):count(cnt),comment(cmnt)
    {
        guid.Data1 =         Hex(p->beg +  0, 8);
        guid.Data2 = (USHORT)Hex(p->beg +  9, 4);
        guid.Data3 = (USHORT)Hex(p->beg + 14, 4);
        guid.Data4[0] = (UCHAR) Hex(p->beg + 19, 2);
        guid.Data4[1] = (UCHAR) Hex(p->beg + 21, 2);
        guid.Data4[2] = (UCHAR) Hex(p->beg + 24, 2);
        guid.Data4[3] = (UCHAR) Hex(p->beg + 26, 2);
        guid.Data4[4] = (UCHAR) Hex(p->beg + 28, 2);
        guid.Data4[5] = (UCHAR) Hex(p->beg + 30, 2);
        guid.Data4[6] = (UCHAR) Hex(p->beg + 32, 2);
        guid.Data4[7] = (UCHAR) Hex(p->beg + 34, 2);
    }
};

struct Guids : FieldHolder {
    UINT min_val;
    UINT max_val;

    vector<GuidEntry> guids;
    int current;
    string currentFileName;

    Guids(int lo, int hi) : min_val(lo),max_val(hi),current(0) {}
    void erase() {current = 0; guids.erase(guids.begin(), guids.end());}

    BEGIN_FIELD_TABLE(Guids, f)
        TEXT_FIELD(Count) fprintf(f, "%d", min(current+1, (signed)guids.size()) );
        DEFAULT_ENUM_FIELD(guids, VectorTag)
    END_FIELD_TABLE

    //void add_guid(PSTR_PAIR p) {  }
    ULONG getid() {
        for(;;) {
            if ( current == (signed)guids.size() ) {
            	
	            guids.push_back(GuidEntry(max_val - min_val + 1, currentFileName) );
            }
            if ( guids[current].count ) {
                ULONG ret = (max_val + 1 - guids[current].count--) | ( current << 16 );
                return ret;
            }
            ++current;
        }
    }
    void add_guids(PSTR_PAIR p, int count) {
        --count; ++p; // skip func name //
        string comment(p->beg,p->end);
        while (--count) {
            guids.push_back(GuidEntry(++p, max_val - min_val + 1, comment));
        }
    }
    void new_file(const char* fname) {
        currentFileName.assign(fname);

    	// this will force a new guid to be allocated
    	// when a new id is required

        current = static_cast<int>(guids.size()); 
    }
};

struct GenPair {
    string tpl;
    string out;

    GenPair(){} // STL pleaser
    GenPair(const string& a, const string& b)
        :tpl(a),out(b) {}
};    

//TYPE_MAP       AutoGen;
TYPE_MAP       TypeMap;
MSG_MAP        MsgMap;
//MACRO_MAP      MacroMap;
FUNC_MAP       Funcs;
GROUP_MAP      Groups;
PREFIX_VECTOR  Prefixes;
PREFIX_VECTOR  Suffixes;
//Guids          CtrlGuids(0,31);
Guids          TraceGuids(10,65535);
FILES          Files;
vector<string> ScanForMacros;
vector<string> Touch;
vector<GenPair>GenMulti;
vector<GenPair>GenSingle;
set<string, strless>    LookFor;

void printTraceGuid(FILE* f, int guidno)
{
    TraceGuids.guids[guidno].printTxt(f);
}

struct Keyword {
    int              nParams; // if < 0 then at least -nParams, otherwise = nParams //
    EZPARSE_CALLBACK handler;
    int              id;
    PVOID            context;
    Keyword(){}
    Keyword(EZPARSE_CALLBACK func,
            int n, UINT i, PVOID ctx) : nParams(n), handler(func), id(i), context(ctx) {}
};

typedef map<string, Keyword, strless> KEYWORD_MAP;

KEYWORD_MAP Keywords;

#if DEPRECATED
//BOOL   GenerateTypeTable;
string TypeTableBegin;
string TypeTableEntry;
string TypeTableEnd;
string TypeTablePrefix;
string GuidStore; 
#endif

const string CtlStr("LEVEL"); // the same as GRP
const string MakeStr("MAKESTR");
const string MsgArgStrUnsafe("(MSG,..unsafe..)");
const string MsgArgStr("(MSG,...)");
const string MsgValStr("MsgVal");
const string MsgStr("MSG");
const string ArgStr("...");
const string ArgStrUnsafe("..unsafe..");
const string IndentStr("INDENT");
const string NullStr("NULL");

bool
Files_AddFile(const string& Name, string Path, const WIN32_FIND_DATA& FindData) 
{
    if (!AllowedExtension(Name)) {
        return FALSE;
    }
    pair<FILES::iterator, bool> result = Files.insert(File(Name,Path,FindData));
    if (!result.second) {
        if (Name.compare(result.first->_Name) == 0) {
            ReportError("File %s was already in the processing list\n");
        } else {
            ReportError("Files %s and %s have the same canonical name %s\n",
                   Name.c_str(), 
                   result.first->_Name.c_str(), 
                   result.first->_CanonicalName.c_str());
        }
    }
    return result.second;
}

int
compare(const string& a, const STR_PAIR& b)
{
    return a.compare(0, a.length(), b.beg, b.end - b.beg);
}

BOOL
parseLegacy(    
    IN PSTR_PAIR strs,
    IN INT       count,
    IN INT       hole, // args - msg, usually one
    IN OUT string& Msg,
    IN OUT vector<Argument>&,
    OUT ParsedFormatString& FmtStr
    )
{
    vector<string> ArgNames;
    STR_PAIR buf = *strs;
    LPCSTR p = buf.beg, q;
    int i;

    if ( p < buf.end && buf.end[-1] == ')' ) --buf.end;
    if(!parseMsg(buf.beg, buf.end, Msg, &p)) {
        return FALSE;
    }    

    if( !FmtStr.init(Msg) ) {
        return FALSE;
    }

    ArgNames.reserve(FmtStr.ArgCount);

    if (count == 1) {

        // need to grok args from the string

        // Let's get to the first ','
        if (p == buf.end) goto success;
        while(*p != ',') if (++p ==  buf.end) goto success; 
        q = ++p;
        for(i = 0;;++i) {
            int parlevel = 0;
            // currently we don't deal with the case of commas or parents within '"'
            while (p < buf.end) {
                if (parlevel == 0 && *p == ',') break;
                if (*p == '(') ++parlevel;
                if (*p == ')') {
                    if (--parlevel < 0) 
                        {ReportError("Too many ')'\n"); return FALSE;}
                }
                ++p;
            }
            if (parlevel > 0) {
                ReportError("No closing ')'");
            }

            LPCSTR tmp = p; // remember where we were
            
            while (q < p && isspace(*q)) ++ q;
            while (q < p && isspace(p[-1])) --p;

            ArgNames.push_back( string(q,p) );

            p = tmp;
           
            if (p == buf.end) break;
            q = ++p;
        }
    } else {
        // arguments were supplied in strs
        strs += hole; count -= hole;
        while (count-- > 0) {
            ArgNames.push_back( string(strs->beg,strs->end) ); 
            ++strs; 
        }

    }

success:
    // check that sizes match //
    if ((unsigned)ArgNames.size() != (unsigned)FmtStr.ArgCount ) {
        ReportError("%d argument(s) expected, argument(s) supplied: %d\n", FmtStr.ArgCount, ArgNames.size());
        return FALSE;
    }

    for(i = 0; i < FmtStr.Items.size(); ++i) {
        int no = FmtStr.Items[i].no;
        if (no > 0) {
            FmtStr.Items[i].expr = ArgNames[no-1];
        }
    }
    return TRUE;
}

BOOL
parseArgs(
    IN LPCSTR beg, 
    IN LPCSTR end,
    IN OUT vector<Argument>& args
    )
{
    LPCSTR p = beg;
//    MACRO_MAP::iterator macro;
    TYPE_SET::iterator macro;

    for(;;) {
        while ( isspace(*p) ) {
            if (++p == end) return TRUE;
        }
        LPCSTR q = p; // id start
        while ( isvar(*p) ) {
            if (++p == end) return TRUE;
        }
        macro = TypeSet.find( string(q, p) );
        if ( macro == TypeSet.end() ) {
        	if (p == q) {
        		q = beg;
        		p = end;
        	}
            ReportError("Unknown type: %s\n", string(q, p).c_str() );
            return FALSE;
        }
        macro->second.Used = TRUE;
        while ( *p != '(') {
            if (++p == end) return TRUE;
        }
        q = p; // now q points to '('
        int level = 0;
        for (;;) {
            if (*p == '(') {
                ++level;
            } else if (*p == ')') {
                if (--level == 0) {
                    break;
                }
            }
            if (++p == end) return TRUE;
        }
        args.push_back( Argument(string(q+1,p), &macro->second) );

        if (++p == end) return TRUE;
    }
    // return TRUE; // unreachable code
}


enum {
//    ID_UseTraceGuid,
//    ID_UseCtrlGuid,
//    ID_GrpidRange,
    ID_TraceRange,
    
    ID_ProcessFiles,
    
    ID_TemplateFile,
//    ID_OutputInc,
//    ID_OutputMof,
//    ID_OutputRc,
//    ID_OutputCode,
    
    ID_TypeMacro,
    ID_TypevMacro,
    ID_Include,
    ID_UsePrefix,
    ID_UseSuffix,
    ID_NoPrefix,

//    ID_ArrayPrefix,
    ID_DefineSimpleTypePtr,
    ID_DefineSimpleType,
    ID_DefineCplxType,
    ID_CustomType,
    ID_DefineFlavor,
    ID_SeparateTraceGuidPerFile,
    ID_Touch,
    ID_ScanForMacros,
	ID_GenerateTypeTable,
//	ID_AutoGen,
	ID_Exceptions,
	ID_WppFlags,
};

void
UpdateIntVar(
    UINT*  var,
    PSTR_PAIR Str
    )
{
    LPCSTR p = Str->beg, q = Str->end;
    UINT x = 0; 

    while (p != q && isdigit(*p) ) {
        x = (x * 10) + (*p - '0');
        ++p;
    }

    *var = x;
}

void parseAssumedArgs(Func& f,LPCSTR beg, LPCSTR end)
{
    // we have a string of A=value1,B=value2,C=value3,...,F=valuen}
    // we need to put A,B,C into f.GooId, 
    // and value1, value2, value3 into f.Goo

    LPCSTR p = beg, q, stop;
    if (p >= end) return;

    Flood("Got %p %p\n", beg, end );

    for(;p < end;) {
        while (isspace(*p)) ++p; // cannot have spaces all the way. there is '}'
        if (p == end) return;
        q = p++;
        while (p < end && *p != '=') ++p;
        if (p == end) { 
            ReportError("Missing '=' in %s\n", string(beg,end).c_str() ); exit(1); }

        stop = p;
        while (--p > q && isspace(*p));
        if (p == q) { 
            ReportError("Id required before '=' in %s\n", string(beg,end).c_str() ); exit(1); }

        f.GooId.push_back( string(q,p+1) );

        p = stop + 1;
        while (isspace(*p)) ++p;  // cannot have spaces all the way. there is '}'
        q = p++;
        while (*p != '}' && *p != ',') ++p;
        stop = p;
        while (--p > q && isspace(*p));

        if (isspace(*p)) { // BUGBUG Verify that this condition is correct
            ReportError("value required after '=' in %s\n", string(beg,end).c_str() ); exit(1); }
            
        f.Goo.push_back( string(q,p+1) );

        if (*stop == '}') break;
        p = stop + 1;
    }
    f.nAssumedArgs = f.Goo.size();
}

DWORD 
ParseConfigCallback (
    IN PSTR_PAIR Str, 
    IN INT   Count, 
    IN PVOID Context,
    IN PEZPARSE_CONTEXT ParseContext
    )
{
    string Name(Str[0].beg, Str[0].end);
    KEYWORD_MAP::iterator keyword = Keywords.find(Name);

    if (Context) {
        // We need to ignore all the keywords besides ID_TypeMacro //
        if (keyword != Keywords.end() && keyword->second.id == ID_TypeMacro) {
            // proceed and do the job //
        } else {
            // Ignore everything else
            return ERROR_SUCCESS;
        }
    }

    if (keyword != Keywords.end() ) {
        if (keyword->second.nParams < 0 && Count - 1 < -keyword->second.nParams ) {
            ReportError("%s requires at least %d parameter(s)\n", 
                   Name.c_str(), -keyword->second.nParams);
            return ERROR_INVALID_PARAMETER;
        }
        if (keyword->second.nParams > 0 && Count - 1 != keyword->second.nParams ) {
            ReportError("%s requires %d parameter(s) (we have %s)\n", 
                   Name.c_str(), keyword->second.nParams, std::string(Str[1].beg, Str[Count-1].end).c_str() );
            return ERROR_INVALID_PARAMETER;
        }

        switch (keyword->second.id) {
#ifdef DEPRECATED        
        case ID_UseTraceGuid:
            TraceGuids.add_guids(Str+1, Count-1);
            break;
        case ID_UseCtrlGuid:
            CtrlGuids.add_guids(Str+1, Count-1);
            break;

        case ID_SeparateTraceGuidPerFile:
            UpdateIntVar((UINT*)(keyword->second.context), Str+1); 
            break;
        case ID_GrpidRange:
            UpdateIntVar(&CtrlGuids.min_val, Str+1); UpdateIntVar(&CtrlGuids.max_val, Str+2); 
            break;
#endif

        case ID_TraceRange:
            UpdateIntVar(&TraceGuids.min_val, Str+1); UpdateIntVar(&TraceGuids.max_val, Str+2); 
            break;

        case ID_ProcessFiles:
            while(--Count) { ++Str; Fill( string(Str->beg, Str->end) ); }
            break;

        case ID_WppFlags:
            while(--Count) { ++Str; if(*Str->beg == '-') ++Str->beg; DealWithCmdLineOptions( Str->beg, Str->end ); }
            Unusual("\n");
            break;
            
        case ID_ScanForMacros:
            while(--Count) { ++Str; ScanForMacros.push_back( string(Str->beg, Str->end) ); }
            break;
            
        case ID_Touch:
            while(--Count) { ++Str; Touch.push_back( string(Str->beg, Str->end) ); }
            break;

        case ID_DefineSimpleType:
            {
                string Name(Str[1].beg, Str[1].end);
                if (Str[4].beg < Str[4].end && *Str[4].beg == '"') Str[4].beg++;
                if (Str[4].beg < Str[4].end && Str[4].end[-1] == '"') Str[4].end--;

                if (TypeSet.find(Name) != TypeSet.end()) {
                    if (IgnoreDupTypes) {
                        return ERROR_SUCCESS;
                    }
                    ReportError("Type %s is already defined\n", Name.c_str() );
                    break;
                } 
                Flood(" type %s\n", Name.c_str());
                TypeSet[Name] = WppType( Name , // name
                                     string(Str[2].beg, Str[2].end), // c-type
                                     SimpleValueMacroStart,
                                     string(Str[3].beg, Str[3].end), // mof type
                                     "", // MofExtension
                                     string(Str[4].beg, Str[4].end), 
                                     string(Str[5].beg, Str[5].end),
                                     stoi(Str[6], "priority"),
                                     Count > 7?stoi(Str[7], "argused"):1
                                     );
                break;                             
            }
            
        case ID_DefineSimpleTypePtr:
            {
                string Name(Str[1].beg, Str[1].end);
                if (Str[4].beg < Str[4].end && *Str[4].beg == '"') Str[4].beg++;
                if (Str[4].beg < Str[4].end && Str[4].end[-1] == '"') Str[4].end--;

                if (TypeSet.find(Name) != TypeSet.end()) {
                    if (IgnoreDupTypes) {
                        return ERROR_SUCCESS;
                    }
                    ReportError("Type %s is already defined\n", Name.c_str() );
                    break;
                }
                TypeSet[Name] = WppType( Name , // name
                                     string(Str[2].beg, Str[2].end), // c-type
                                     SimplePtrMacroStart,
                                     string(Str[3].beg, Str[3].end), // mof type
                                     "", // MofExtension
                                     string(Str[4].beg, Str[4].end), 
                                     string(Str[5].beg, Str[5].end),
                                     stoi(Str[6], "priority"),
                                     Count > 7?stoi(Str[7], "argused"):1
                                     );
                break;                             
            }
            
        case ID_DefineCplxType:
            {
                string Name(Str[1].beg, Str[1].end);
                string MacroStart(Str[2].beg, Str[2].end);
                MacroStart.append("(");

                if (Str[5].beg < Str[5].end && *Str[5].beg == '"') Str[5].beg++;
                if (Str[5].beg < Str[5].end && Str[5].end[-1] == '"') Str[5].end--;
            
                if (TypeSet.find(Name) != TypeSet.end()) {
                    if (IgnoreDupTypes) {
                        return ERROR_SUCCESS;
                    }
                    ReportError("Type %s is already defined\n", Name.c_str() );
                    break;
                }
                
                TypeSet[Name] = WppType( Name , // name
                                         string(Str[3].beg, Str[3].end), // equiv type
                                         MacroStart, 
                                         string(Str[4].beg, Str[4].end), // mof type
                                         "", // MofExtension
                                         string(Str[5].beg, Str[5].end), 
                                         string(Str[6].beg, Str[6].end),
                                         stoi(Str[7], "priority"),
                                         Count > 8?stoi(Str[8], "argused"):1
                                         );
            }                                     
            break;                             
            

        case ID_DefineFlavor:
            {
                string Name(Str[1].beg, Str[1].end);
                string BaseType(Str[2].beg, Str[2].end);
                TYPE_SET::const_iterator it = TypeSet.find(BaseType);

                if (Str[4].beg < Str[4].end && *Str[4].beg == '"') Str[4].beg++;
                if (Str[4].beg < Str[4].end && Str[4].end[-1] == '"') Str[4].end--;

                if (it == TypeSet.end()) {
                    ReportError("Type Not Found %s\n", BaseType.c_str());
                    break;
                }

                if (TypeSet.find(Name) != TypeSet.end()) {
                    if (IgnoreDupTypes) {
                        return ERROR_SUCCESS;
                    }
                    ReportError("Type %s is already defined\n", Name.c_str() );
                    break;
                }

                WppType Flavor(it->second);
                Flavor.TypeName = Name;
                if (!Str[3].empty()) 
                    { Flavor.MofType.assign(Str[3].beg, Str[3].end); }
                if (!Str[4].empty()) 
                    { Flavor.FormatSpec.assign(Str[4].beg, Str[4].end); }
                TypeSet[Name] = Flavor;

                break;
            }
            
        case ID_TypeMacro: 
        case ID_CustomType:
            {
                string Name(Str[1].beg, Str[1].end);
                LPCSTR p = Str[2].beg, q = Str[2].end;                
                while (p < Str[2].end && *p != '(') ++p;
                if (p < Str[2].end) {
                    q = p-1;
                    while (q >= Str[2].beg && isspace(*q)) --q;
                    ++q;
                }
                string BaseType(Str[2].beg, q);
                TYPE_SET::const_iterator it = TypeSet.find(BaseType);

                if (it == TypeSet.end()) {
                    ReportError("Type Not Found %s\n", BaseType.c_str());
                    break;
                }

                if (TypeSet.find(Name) != TypeSet.end()) {
                    if (IgnoreDupTypes) {
                        return ERROR_SUCCESS;
                    }
                    ReportError("Type %s is already defined\n", Name.c_str() );
                    break;
                }

                if (Count == 4) {
                    if (Str[3].beg < Str[3].end && *Str[3].beg == '"') Str[3].beg++;
                    if (Str[3].beg < Str[3].end && Str[3].end[-1] == '"') Str[3].end--;
                }


                {
                    string ExtendedType;
                    LPCSTR end = Str[2].end;
                    if ( p != end ) {
                        ExtendedType.reserve(end - p);
                        do {
                            while(p != end && isspace(*p)) ++p;
                            LPCSTR q = p;
                            while(q != end && !isspace(*q)) ++q;
                            ExtendedType.append(p, q);
                            p = q;
                        } while ( p != end );
                    }
                    WppType Flavor(it->second);
                    Flavor.TypeName = Name;
                    Flavor.Extension = ExtendedType;
                    if (Count == 4) 
                        { Flavor.FormatSpec.assign(Str[3].beg,Str[3].end); }
                    
                    if (keyword->second.id == ID_TypeMacro) {
                        Flavor.Flags = WT_MACRONAME;
                    } else {
                        Flavor.Flags = 0;
                    }
                    TypeSet[Name] = Flavor;
                }
                break;
            }
/*            
        case ID_OutputInc:
        case ID_OutputCode:
        case ID_OutputMof:
        case ID_OutputRc:
        case ID_TemplateFile:
        case ID_ArrayPrefix:
            ((string*)(keyword->second.context))->assign(Str[1].beg, Str[1].end);
            break;
*/
//		case ID_AutoGen:
//			AutoGen[ string(Str[1].beg, Str[1].end) ] = string(Str[2].beg, Str[2].end);
//			break;

        case ID_Include:
            return EzParse(std::string(Str[1].beg, Str[1].end).c_str(),ParseConfigCallback,0);        

        case ID_UseSuffix:
//            RegenerateMacroMap();
            Suffixes.push_back( Prefix(Str, Count) );
            break;
        case ID_UsePrefix:
        case ID_NoPrefix:
            // We need to regenerate macro table before using prefix //
//            RegenerateMacroMap();
            Prefixes.push_back( Prefix(Str, Count) );
            break;
        default:;
            //return Keywords->handler(Str, Count, Context);
        }
        
    } else {
//        INT i;

        //
        // a macro can have a list of assumed arguments in
        // curly braces right after the name
        //
        // Ex: TraceNoise{LEVEL=Noise}(MSG,...)
        //

        Flood("Got %s\n", Name.c_str() );

        LPCSTR assumed_beg = find(Str[0].beg,Str[0].end, '{');
        LPCSTR assumed_end = find(Str[0].beg,Str[0].end, '}');

        if (assumed_beg != Str[0].end) {
            if (assumed_end == Str[0].end) {
                ReportError("No closing brace in '%s'\n",
                    Name.c_str() );
                exit(1);
            }
            Name.assign(Str[0].beg, assumed_beg);
            Noise("Real name is %s (%s)\n", Name.c_str(),
                string(assumed_beg+1, assumed_end).c_str() );
        } else if (assumed_end != Str[0].end) {
                ReportError("No openning brace in '%s'\n",
                    Name.c_str() );
                exit(1);
        }

        FUNC_MAP::iterator it = Funcs.find(Name);
        if (it != Funcs.end()) {
            ReportError("Function %s is already defined\n",
                Name.c_str() );
            exit(1);
        }
        
        Func f(Name);
        if (ParseContext->doubleParent) {
            f.SetDoubleP();
        }

        if (assumed_end > assumed_beg) {
            parseAssumedArgs(f, assumed_beg+1, assumed_end+1);
        }
        
        for (int i = 1; i < Count; ++i) {
            // check for '='
            LPCSTR div = find(Str[i].beg, Str[i].end, '=' );
            if ( div != Str[i].end ) {               
                //f.Args.push_back( string(div+1, Str[i].end) );
                f.Goo.push_back( string(Str[i].beg, div ) );
                f.GooId.push_back( string(Str[i].beg, div ) );
                f.MsgVal = static_cast<UCHAR>(i); // can I have more of those?
                continue;
            }
            if ( compare(CtlStr, Str[i]) == 0 ) {
                f.Grp = static_cast<UCHAR>(i);
                f.Goo.push_back( string(Str[i].beg, Str[i].end) );
                f.GooId.push_back( string(Str[i].beg, Str[i].end) );
//            } else if ( compare(GrpStr, Str[i]) == 0 ) {
//                f.Grp = static_cast<UCHAR>(i);
//                f.Goo.push_back( string(Str[i].beg, Str[i].end) );
        //    } else if ( compare(ArgsStr, Str[i]) == 0 ) {
//                f.Arg = static_cast<UCHAR>(i);
            } else if ( compare(MsgArgStr, Str[i]) == 0 ) {
                f.MsgArg = static_cast<UCHAR>(i); // can I have more of those?
//                f.SetLineBeg();
                continue;
            } else if ( compare(MsgArgStrUnsafe, Str[i]) == 0 ) {
                f.SetUnsafe();
                f.MsgArg = static_cast<UCHAR>(i); // can I have more of those?
                continue;
            } else if ( compare(MsgValStr, Str[i]) == 0 ) {
                f.MsgVal = static_cast<UCHAR>(i); // can I have more of those?
            } else if ( compare(MakeStr, Str[i]) == 0 ) {
                f.MsgVal = static_cast<UCHAR>(i); // can I have more of those?
                f.set(FO_NOMACRO);
//                f.SetLineBeg();
                // should i continue?
            } else if ( compare(MsgStr, Str[i]) == 0 ) {
                f.Msg = static_cast<UCHAR>(i);
                continue;
//            } else if ( compare(Msg2Str, Str[i]) == 0 ) {
//                f.Msg = static_cast<UCHAR>(i);
  //          } else if ( compare(IdStr, Str[i]) == 0 ) {
  //              f.Id = static_cast<UCHAR>(i);
//            } else if ( compare(MsgArgsStr, Str[i]) == 0 ) {
//                f.Msg = static_cast<UCHAR>(i);
//                f.VarArgs = TRUE;
            } else if ( compare(NullStr, Str[i]) == 0 ) {
                // not used
            } else if ( compare(IndentStr, Str[i]) == 0 ) {
                f.Indent = static_cast<UCHAR>(i);
            } else if ( compare(ArgStrUnsafe, Str[i]) == 0 ) {
                f.Arg = static_cast<UCHAR>(i);
                f.SetUnsafe();
                f.SetVarArgs();
                if (i != Count - 1) {
                    ReportError("func %s: '...' has to be the very last argument\n",
                        Name.c_str() );
                }
                continue;
            } else if ( compare(ArgStr, Str[i]) == 0 ) {
                f.Arg = static_cast<UCHAR>(i);
                f.SetVarArgs();
                if (i != Count - 1) {
                    ReportError("func %s: '...' has to be the very last argument\n",
                        Name.c_str() );
                }
                continue;
            } else {
                f.Goo.push_back( string(Str[i].beg, Str[i].end) );
                f.GooId.push_back( string(Str[i].beg, Str[i].end) );
            }
            f.Args.push_back( string(Str[i].beg, Str[i].end) );
        }
        f.Num = static_cast<UCHAR>(Count - 1);
        Noise(" func %s\n", Name.c_str() );
        Funcs[ Name ] = f;
    }
    return ERROR_SUCCESS;
}
#if 0
DWORD
PrintCallback (
    IN PSTR_PAIR Str, 
    IN UINT Count, 
    IN PVOID
    )
{
    UINT i;
    for (i = 0; i < Count; ++i) {
        putchar('<'); fwrite(Str[i].beg, Str[i].end - Str[i].beg, 1, stdout); putchar('>');
    }
    putchar('\n');
    return ERROR_SUCCESS;
}
#endif

void CleanupString(LPCSTR beg, LPCSTR end, OUT string& msg)
{
    LPCSTR p = beg, q;
    msg.resize(0);

    while (p < end) {
        // skip spaces
        while (p < end && isspace(*p)) ++p;
        q = p;
        if (p < end && *p == '"') {
            ++p;
            while (p < end && (*p != '"' || p[-1] != '\\')) ++p;
        }
        if (p < end) ++p; 
        msg.append(q,p);
    }
}

DWORD
ParseSrcCallback (
    IN PSTR_PAIR Str, 
    IN INT Count, 
    IN PVOID,
    IN PEZPARSE_CONTEXT ParseContext
    )
{
    string FuncName(Str[0].beg, Str[0].end);
    string msg, msgval, id, indent;
    vector<Argument> args;
    ParsedFormatString FmtStr;
    int LineNo;
    
//    UINT argno = 10;

    if (FuncName.compare("WPP_COMPONENT_NAME") == 0) {
        if (Count != 2) {
            ReportError("WPP_COMPONENT_NAME requires 1 argument.\n");
            exit(1);
        }
        ComponentName.assign(Str[1].beg, Str[1].end);
        return ERROR_SUCCESS;
    }

    // Look for special directive

    if ( LookFor.find( FuncName ) != LookFor.end() ) {
        Noise("SpecialString found %s\n", FuncName.c_str());
        CurrentFile->IdsFound.insert(FuncName);
    }

    FUNC_MAP::iterator func = Funcs.find( FuncName );

    if (func == Funcs.end() ) {
        return ERROR_SUCCESS;
    }

    if (func->second.DoubleP() && !ParseContext->doubleParent) {
        ReportError("%s requires ((args))\n", func->first.c_str() );
        exit(1);
    }
    if (!func->second.DoubleP() && ParseContext->doubleParent) {
        ReportError("%s doesn't take ((args))\n", func->first.c_str() );
        exit(1);
    }

    msg.reserve(255);
    msgval.reserve(255);

    if (func->second.VarArgs()) {
        if (Count < func->second.Num ) {
            ReportError("%s requires at least %d arguments. (Found only %d)\n", 
            	func->first.c_str(), func->second.Num, Count-1);
            return ERROR_INVALID_PARAMETER;
        }
    } else {        
        if (Count-1 != func->second.Num ) {
            ReportError("%s requires %d arguments. (Found only %d)\n", 
            	func->first.c_str(), func->second.Num, Count-1);
            return ERROR_INVALID_PARAMETER;
        }
    }
    if (func->second.LineBeg() && !func->second.DoubleP() ) {
        LineNo = EzGetLineNo(Str[0].beg, ParseContext);
    } else {
        LineNo = EzGetLineNo(ParseContext->macroEnd, ParseContext);
    }
    {
        char Num[64];
        sprintf(Num,"%d", LineNo);

        id = CurrentFile->_CanonicalName;
        id += Num;
    }

    if (GRP(func->second)) {
        PSTR_PAIR p = Str + GRP(func->second);
        string group(p->beg, p->end);
        GROUP_MAP::iterator i = Groups.find(group);
        if (i == Groups.end()) {
            Groups[ string(p->beg, p->end) ] = Group(0, string(p->beg, p->end), id);
        } else {
        	i->second.MsgIds.push_back(id);
        }
    }
    // BUGBUG make it legacy bugs
    /*
    if (ARG(func->second)) {
        PSTR_PAIR p = Str + ARG(func->second);
        if( !parseArgs(p->beg, p->end, args) ) {
            return ERROR_INVALID_PARAMETER;
        }
    }
    */


    if (func->second.MsgArg) {
        PSTR_PAIR p = Str + func->second.MsgArg;
        if (p->beg == p->end || *p->beg != '(') {
            ReportError("MsgArg argument should have form (MSG,...)\n");
            exit(1);
        }
        if (!parseLegacy(p, 1, 1, msg, args, FmtStr)) {
            return ERROR_INVALID_PARAMETER;
        }
    }

    
    if (MSG(func->second)) {
        PSTR_PAIR p = Str + MSG(func->second);
        if (func->second.VarArgs()) {
            if (!parseLegacy(p, Count-MSG(func->second), 
                    ARG(func->second) - MSG(func->second),
                    msg, args, FmtStr)) {
                return ERROR_INVALID_PARAMETER;
            }
        } else if ( !parseMsg(p->beg, p->end, msg) ) {
            return ERROR_INVALID_PARAMETER;
        }
    }

    if (func->second.Indent) {
        PSTR_PAIR p = Str + func->second.Indent;
        indent.assign(p->beg, p->end);
    }

    if (func->second.MsgVal) {
        PSTR_PAIR p = Str + func->second.MsgVal;
        CleanupString(p->beg, p->end, msgval);
        //msgval.assign(p->beg, p->end);
        string::size_type div = msgval.find('=');
        if (div != string::npos) {
            FmtStr.HostString += msgval.substr(div+1);
        } else {
            FmtStr.HostString += msgval;
        }
        msgval.append(","); // Why comma?
    }
    
    if (func->second.prefix) {
        FmtStr.insert_prefix(func->second.prefix->FmtStr);
    }
    if (func->second.suffix) {
        FmtStr.append(func->second.suffix->FmtStr);
    }
    {
        MSG_MAP::iterator i = MsgMap.find(id);
        if ( i != MsgMap.end() ) {
            // Id already exists. Can't happen //
            ReportError("Can't handle two printf statements on the same line\n");
            exit(1);
        }
        Message* Msg =
        &(MsgMap[id] = 
            Message(id, msg, args, TraceGuids.getid(), LineNo, FmtStr,
                func->second) ) ;
        Msg->msgval = msgval;    
        Msg->Indent = indent;

        for(int i = 1; i < Count; ++i) {
            if (i == func->second.Indent) 
                continue;
            if (i == func->second.MsgVal ||
               i == func->second.MsgArg ||
               i == MSG(func->second) )
            {
                break;
            }
            Msg->GooActualValues.push_back(string(Str[i].beg, Str[i].end));
        }
        
        CurrentFile->Msgs.push_back( Msg );
        TraceGuids.guids[TraceGuids.current].Msgs.push_back( Msg );
        ++MessageCount;
        if (Msg->ArgConsumed() > arglimit) {
            ReportError("Too many arguments supplied: %d > %d\n", 
            	Msg->ArgConsumed(), arglimit);
		}
    }
    return ERROR_SUCCESS;
}
/*
void RegenerateMacroMap()
    //
    // Fill Macro Map table
    //
{
    TYPE_SET::const_iterator it = TypeSet.begin();
    MacroMap.erase(MacroMap.begin(), MacroMap.end());
    for(;it != TypeSet.end(); ++it) {
        string MacroName(MacroPrefix);

        if(it->second.Flags & WT_MACRONAME) {
            MacroName.assign(it->second.TypeName);       
        } else {
            MacroName.append(it->second.TypeName);       
        }

        MacroMap[ MacroName ] = ArgType(&it->second);
    }
}
*/
void
InitKeywords()
{                               
    #define HANDLER(A,B,C,D) Keywords[B] = Keyword(0,C,ID_ ## A, D)
    
//    HANDLER( UseTraceGuid, "USETRACEGUID", -3, NULL);
//    HANDLER( UseCtrlGuid,  "USECTRLGUID", -3, NULL);
    
//    HANDLER( GrpidRange,   "GRPIDRANGE", 2, NULL);
    HANDLER( WppFlags,     "WPP_FLAGS", -1, NULL);
    HANDLER( TraceRange,   "TRACERANGE", 2, NULL);
//    HANDLER( AutoGen,      "AUTOGEN", 2, NULL);
    
    HANDLER( ProcessFiles, "PROCESSFILES", -1, NULL);
    HANDLER( Touch,        "TOUCH", -1, NULL);
    HANDLER( ScanForMacros,"SCANFORMACROS", -1, NULL);
    HANDLER( Exceptions,   "EXCEPTIONS", -2, NULL);
    
//    HANDLER( OutputInc,    "OUTPUT_H", 1,    &OutputInc);
//    HANDLER( OutputMof,    "OUTPUT_MOF", 1,  &OutputMof);
    
//    HANDLER( ArrayPrefix,  "ARRAY_PREFIX", 1, &ArrayPrefix);
    
    HANDLER( TypeMacro,    "TYPEMACRO",  2, NULL);
    HANDLER( TypevMacro,   "TYPEVMACRO", 3, NULL);
    HANDLER( Include,      "INCLUDE", 1, NULL);
    HANDLER( UsePrefix,    "USEPREFIX", -2, NULL);
    HANDLER( UseSuffix,    "USESUFFIX", -2, NULL); // 3
    HANDLER( NoPrefix,     "NOPREFIX", 1, NULL);

    HANDLER( SeparateTraceGuidPerFile, "SEPARATE_TRACE_GUID_PERFILE", 1, &SeparateTraceGuidPerFile);
    
    HANDLER( DefineSimpleTypePtr, "DEFINE_SIMPLE_TYPE_PTR",-6, NULL);
    HANDLER( DefineSimpleType,    "DEFINE_SIMPLE_TYPE",    -6, NULL);
    HANDLER( DefineCplxType,      "DEFINE_CPLX_TYPE",      -7, NULL);
    HANDLER( DefineFlavor,        "DEFINE_FLAVOR",          4, NULL);
    HANDLER( CustomType,          "CUSTOM_TYPE",           -2, NULL);

//  HANDLER( GenerateTypeTable, "GENERATE_TYPE_TABLE", 4, NULL);
}

struct iterless {
    typedef MSG_MAP::iterator ty;
    bool operator() (const ty& a, const ty&b) const { return a->second.id < b->second.id; }
};
/*
bool
FileExists(
	LPSTR fileName
	)
{
	HANDLE hFile = CreateFile(fileName, 0, 0, 0, OPEN_EXISTING, 0, 0);
	if (hFile == INVALID_HANDLE_VALUE) {
		return FALSE;
	} else {
		CloseHandle( hFile );
		return TRUE;
	}
}
*/

void
MyGetCurrentDirectory(string& str, int level = 0)
{
    char buf[4096];	
    int n;

    n = GetCurrentDirectory(sizeof(buf), buf);
    if (n == 0 || n > sizeof(buf) ) {
        ReportError("GetCurrentDirectory failed: %d\n", GetLastError());
        exit(1);
    }

    {
        char *p, *q;
        p = buf;
        while (level) {
            q = strrchr(buf, '\\');
            if (q == 0) {
                break;
            }
            *q = '_'; p = q+1;
            --level;
        }
        str.assign(p);
    }
}


ContainerAdapter<MSG_MAP, MapTag>   MsgMap_tpl("Messages", MsgMap);
ContainerAdapter<GROUP_MAP, MapTag> GroupMap_tpl("Groups", Groups);
ContainerAdapter<FUNC_MAP, MapTag>  FuncMap_tpl("Funcs", Funcs);
ContainerAdapter<set<Reorder>, VectorTag>  Reorder_tpl("Reorder", ReorderSet);
ContainerAdapter<FILES, VectorTag>  Files_tpl("Files", Files);
ContainerAdapter<TYPE_SET, MapTag>  TypeSet_tpl("TypeSet", TypeSet);
ContainerAdapter<TYPESIG_MAP, MapTag>  TypeSigSet_tpl("TypeSigSet", TypeSigMap);
StringAdapter                       CurrentDir_tpl("CurrentDir", CurrentDir);
StringAdapter                       MacroPrefix_tpl("MacroPrefix", MacroPrefix);
//StringAdapter                       GuidStore_tpl("GuidStore", GuidStore);
StringAdapter                       TemplateFile_tpl("TemplateFile", CurrentTpl);
IteratorAdapter<FILES::iterator>    CurrentFile_tpl(&CurrentFile);

struct NameAlias : FieldHolder {
    string _Name, _Alias;

    NameAlias(){} // To make STL happy
    NameAlias(const string& Name, const string& Alias): _Name(Name), _Alias(Alias){}

    bool operator < (const NameAlias& b) const { return _Name.compare(b._Name) < 0; }

    BEGIN_FIELD_TABLE(NameAlias, f)
        TEXT_FIELD(Name)  fprint_str(f, _Name);
        TEXT_FIELD(Alias) fprint_str(f, _Alias);
        TEXT_FIELD(MacroName) {
            string::size_type br = _Name.find('(');
            if (br == string::npos) {
                fprint_str(f, _Name);
            } else {
                fprint_str(f, _Name.begin(), _Name.begin() + br);
            }
        }
    END_FIELD_TABLE
};

struct Compiler : FieldHolder {
    const Hasher* Checksum;

    BEGIN_FIELD_TABLE(Compiler, f)
        TEXT_FIELD(Name)      fprintf(f, "WPP");
        TEXT_FIELD(Version)   fprintf(f, "0.01");
        TEXT_FIELD(Checksum)  if (Checksum) Checksum->print(f);
        TEXT_FIELD(Timestamp) fprintf(f, __TIMESTAMP__);
    END_FIELD_TABLE
};

struct SystemObj : FieldHolder {
    BEGIN_FIELD_TABLE(SystemObject, out)
       TEXT_FIELD(Date) { 
           SYSTEMTIME UtcTime; GetSystemTime(&UtcTime);
           fprintf(out, "%02d/%02d/%04d", UtcTime.wMonth, UtcTime.wDay, UtcTime.wYear);
       }
       TEXT_FIELD(Time) { 
           SYSTEMTIME UtcTime; GetSystemTime(&UtcTime);
           fprintf(out, "%02d:%02d:%02d", UtcTime.wHour, UtcTime.wMinute, UtcTime.wSecond);
       }
    END_FIELD_TABLE
};

struct FoundTpl: FieldHolder {
    virtual BOOL Hidden(std::string filter="") const { 
        return CurrentFile->IdsFound.find(filter) == CurrentFile->IdsFound.end();
    }
    
    BEGIN_FIELD_TABLE(FoundTpl, f)
       __f__;
    END_FIELD_TABLE 
};

FoundTpl  Found_tpl;
SystemObj System_tpl;
Compiler Compiler_tpl;

//vector<NameAlias> AutoGenMacros;
//ContainerAdapter< vector<NameAlias>, VectorTag > AutoGenMacros_tpl("AutoGenMacros", AutoGenMacros);

set<NameAlias> MacroDefinitions;
ContainerAdapter< set<NameAlias>, VectorTag > MacroDefintions_tpl("MacroDefinitions", MacroDefinitions);

void AddMacroDefinition(LPCSTR s)
{
    LPCSTR end = s + strlen(s);
    LPCSTR q = strchr(s, '=');
    
    if (q == NULL) {
        MacroDefinitions.insert( NameAlias( s , "" ) );
    } else {
        MacroDefinitions.insert( NameAlias( string(s,q) , string(q+1,end) ) );
    }
} 

void expand(IN OUT string& str, const string& id)
{
    NameAlias dummy(id, "");
    set<NameAlias>::const_iterator it = MacroDefinitions.find(dummy);
    if (it != MacroDefinitions.end()) {
        str.append(it->_Alias);
    }
}

void processGenOption(LPCSTR s) 
{
    LPCSTR end = s + strlen(s), div = strchr(s,'}'), star = strchr(s,'*');
    vector<GenPair>& v = star ? GenMulti : GenSingle;
    
    if (*s != '{') { goto usage; }
    if (div == 0)  { goto usage; }
    if (s+1 == div || div+1 == end)  { goto usage; }
    if (star) {
        if (div+1 != star) { 
            ReportError(" '*' can appear only as a first charachter of output-filename part\n");
            goto usage;
        }
        ++star;
    } else {
        star = div+1;
    }
    if (star == end) goto usage;

    v.push_back( GenPair(string(s+1, div), string(star, end)) );
    return;

usage:    
    ReportError(" use -gen:{template-fpathname}output-fpathname\n"
                " you supplied -gen:%s\n", s);
    ExitProcess(1);
}

void
PrepareSearchPaths(LPCSTR s)
{
    // 
    // split /Isdf;sdf;y into a vector of strings
    //
    while(s) 
    {
        LPCSTR semi = strchr(s, ';');
        if (semi) {
            SearchDirs.push_back(string(s,semi));
            ++semi;
        } else {
            SearchDirs.push_back(string(s));
        }
        s = semi;
        if (SearchDirs.back().size() > 0
         && SearchDirs.back().end()[-1] != '\\')
        {
            SearchDirs.back().append("\\");
        }
    }
}

// 2fb37eda-004b-4b64-a1c4-84c53cb55df5
// 0         1         2         3
// 01234567typeName1234567typeName1234567typeName12345

void processCtlOption(string s)
{
    // first let's check that the guid is OK
    if ( (s.size() == 16 * 2 + 4) 
      && (s[8] == '-') && (s[13] == '-')
      && (s[18] == '-') && s[23] == '-') 
    {
        s[8] = s[13] = s[18] = s[23] = ',';
        MacroDefinitions.insert( NameAlias( 
            string("WPP_DEFAULT_CONTROL_GUID"), s) );
    }
}

void processCfgItem(const string& s)
{
    LPCSTR beg = s.begin(), end = s.end();
    ULONG Status;
    EZPARSE_CONTEXT ParseContext;
    ZeroMemory(&ParseContext, sizeof(ParseContext) );

    ParseContext.start = beg;
    ParseContext.filename = "cmdline";
    ParseContext.scannedLineCount = 1;
    ParseContext.lastScanned = beg;
//    EzParseCurrentContext = &ParseContext;

    Status = ScanForFunctionCallsEx
        (beg, end, ParseConfigCallback, 0, &ParseContext, NO_SEMICOLON);
        
    if (Status != ERROR_SUCCESS) {
        exit(1);
    }
}

vector<string> cmdinit; // config commands specified on the command line.

void ParseConfigFromCmdline()
{
    for(int i = 0; i < cmdinit.size(); ++i) {
        processCfgItem(cmdinit[i]);
    }
}

void DealWithCmdLineOptions(LPCSTR s)
{
    Unusual(" -%s", s);
    if (lstrcmp(s,"km") == 0) {
        AddMacroDefinition("WPP_KERNEL_MODE");
        userMode = FALSE;
    } else if (lstrcmp(s,"um") == 0) {
        AddMacroDefinition("WPP_USER_MODE");
        userMode = TRUE;
    } else if (strcmp(s, "dll")==0) {
        AddMacroDefinition("WPP_DLL");
    } else if (strcmp(s, "ignoreduptypes")==0) {
        IgnoreDupTypes = TRUE;
    } else if (strncmp(s, "gen:", 4)==0) {
        processGenOption(s+4);
    } else if (strncmp(s, "gen{", 4)==0) { // I was always forgetting to put :
        processGenOption(s+3);
    } else if (strncmp(s, "ctl:", 4)==0) {
        processCtlOption(string(s+4));
    } else if (strncmp(s, "scan:", 5)==0) {
        ScanForMacros.push_back(string(s+5));
    } else if (strncmp(s, "defwpp:", 7)==0) {
        WppDefault.assign(s+7);
    } else if (strncmp(s, "v", 1)==0) {
        if ( isdigit(s[1]) ) {
            DbgLevel = s[1] - '0';
        } else {
            DbgLevel = 1;
        }
    } else if (strncmp(s, "ini:", 4)==0) {
        LocalConfig.assign(s+4);
    } else if (strncmp(s, "lookfor:", 8)==0) {
        LookFor.insert(string(s+8));
    } else if (strncmp(s, "ext:", 4)==0) {
        AllowedExtensions.assign(s+4);
    } else if (strncmp(s, "cfgdir:", 7)==0) { // OBSOLETE
        PrepareSearchPaths(s+7);
    } else if (strncmp(s, "arglimit:", 9)==0) { 
        arglimit = atoi(s+9);
    } else if (strncmp(s, "I", 1)==0) {
        PrepareSearchPaths(s+1);
    } else if (strcmp(s, "reorder")==0) {
        reorder = TRUE;
    } else if (strcmp(s, "noreorder")==0) {
        reorder = FALSE;
    } else if (strcmp(s, "donothing")==0) {
        exit(0);
    } else if (strcmp(s, "notimechk")==0) {
        CheckTimestamp = FALSE;
    } else if (strcmp(s, "noshrieks")==0) {
        noshrieks = TRUE;
    } else if (strcmp(s, "nohashchk")==0) {
        CheckHash = FALSE;
    } else if (strncmp(s, "func:",5)==0) {
        cmdinit.push_back( string(s+5) );
    } else if (strcmp(s, "md5")==0) {
        md5 = TRUE;
    } else if (strcmp(s, "nomd5")==0) {
        md5 = FALSE;
    } else if (strncmp(s, "omac:", 5)==0) {
        OutputMac.assign(s+5);
    } else if (strncmp(s, "argbase:", 8)==0) {
        ArgBase = atoi(s+8);
    } else if (strncmp(s, "odir:", 5)==0) {
        OutputDir.assign(s+5);
        if (OutputDir.size() > 0 && OutputDir.end()[-1] != '\\') {
            OutputDir.append("\\");
        }
    } else if (strncmp(s, "D", 1)==0) {
        AddMacroDefinition(s+1);
    } else {
        ReportError("Unknown cmdline option: -%s\n", s);
        exit(1);
    }

}

void parseStringAsCmdLine(
    LPCSTR beg, LPCSTR end
    )
{
    LPCSTR p = beg;
    if( end == NULL ) {
        end = beg + strlen(beg);
    }

    // need to skip spaces. " is processed specially

    for(;;) {
        while (p < end && isspace(*p)) ++p;
        if (p == end) return;
        LPCSTR q = p; // beginning of the the string
        if (*p == '"') {
            ++q; // skip openning quote
            do {
                ++p; while (p < end && *p != '"') ++p;
                if (p == end) {
                    ReportError("Unterminated string in %s\n", string(beg, end).c_str() );
                    exit(1);
                }
            }
            while (*p == '\\');
            // now p points to '"' which is not prefixed by '\'
        } else {
            while (p < end && !isspace(*p)) ++p;
        }
        if (*q != '-') {
            ReportError("Option doesn't start with '-' %s in \"%s\"\n", 
                string(q,p).c_str(), string(beg, end).c_str() );
        }        
        DealWithCmdLineOptions(q+1, p); 
        if (*p == '"') ++p;
    }        
}

enum {
    FAVOR_LOCAL_DIR   = 0x01,
    UPDATE_NAME       = 0x02,
    COMPLAIN_BITTERLY = 0x04,
};

BOOL
FileExists(
    string& fname,
    string path = "",
    ULONG options = 0)
{
    string file(path);
    file.append(fname);

    WIN32_FIND_DATA Dummy;
    HANDLE ffh = FindFirstFile(file.c_str(), &Dummy);

    if (ffh != INVALID_HANDLE_VALUE) {
        FindClose(ffh);
        Noise("found %s in %s\n", fname.c_str(), path.c_str());
        if (options & UPDATE_NAME) {
            fname = file;
        }
        return TRUE;
    }
    return FALSE;
}

void
FindFileOnPath(string& Name, ULONG Options = 0)
{
    if (Options & FAVOR_LOCAL_DIR) {
        if(FileExists(Name)) { goto found; }
    }
    int i;
    for(i = 0; i < SearchDirs.size(); ++i) {
        if(FileExists(Name, SearchDirs[i], Options))
            { goto found; }
    }
    if ( !(Options & FAVOR_LOCAL_DIR) ) {
        if(FileExists(Name)) { goto found; }
    }
    if ( Options & COMPLAIN_BITTERLY ) {
        ReportError("File %s not found\n", Name.c_str());
        exit(1);
    }
found:;
}


void InitGlobals()
{
    InitKeywords();

    MyGetCurrentDirectory(CurrentDir, 1);

//	ArrayPrefix.assign(currentDir);
//	ArrayPrefix.append("_wpp_");

	PopulateFieldMap();

    if (OutputMac.size() > 0) {
        DeleteFile( OutputMac.c_str() );
    }

    ObjectMap["Reorder"] = &Reorder_tpl;
    ObjectMap["TraceGuids"] = &TraceGuids;
//  ObjectMap["CtrlGuids"] = &CtrlGuids;
    ObjectMap["Messages"] = &MsgMap_tpl;
    ObjectMap["Groups"] = &GroupMap_tpl;
    ObjectMap["Funcs"] = &FuncMap_tpl;
//    ObjectMap["AutoMacros"] = &AutoGenMacros_tpl;
    ObjectMap["CurrentDir"] = &CurrentDir_tpl;
    ObjectMap["MacroPrefix"] = &MacroPrefix_tpl;
    ObjectMap["Compiler"] = &Compiler_tpl;
    ObjectMap["Files"] = &Files_tpl;
    ObjectMap["TypeSet"] = &TypeSet_tpl;
    ObjectMap["System"] = &System_tpl;
    ObjectMap["MacroDefinitions"] = &MacroDefintions_tpl;
    ObjectMap["TemplateFile"] = &TemplateFile_tpl;
    ObjectMap["SourceFile"] = &CurrentFile_tpl;
    ObjectMap["TypeSigSet"] = &TypeSigSet_tpl;
    ObjectMap["FOUND"] = &Found_tpl;
}

VOID ReadCommandLineArgs(int argc, char** argv) 
{
    Unusual("  tracewpp");
    for (int i = 1; i < argc; ++i) {
        char* s = argv[i];
        int len = (int)strlen(s);
        if (len > 1 && s[0] == '-') {
            DealWithCmdLineOptions(s+1);
        } else {
            Unusual("  %s", argv[i]);
            Fill( string(argv[i]));
        }
    }
    Unusual("\n");

    {
        LPCSTR p = getenv("WPP_FLAGS");
        if (p) {
            Noise("WPP_FLAGS defined: %s\n", p);
            parseStringAsCmdLine(p, NULL);
        }
    }

    
/*
    // THINK do we need revision at all?
    if (Revision.size() > 0) {
        if(SearchDirs.size() == 0) {
            ReportError("Revision can be specified only when -cfgdir directive is specified");
            ExitProcess(3);
        } else {
            if (Revision.end()[-1] != '\\') {
                Revision.append("\\");
            }
            int i, n = SearchDirs.size();
            for (i = 0; i < n; ++i) {
                SearchDirs.push_back( SearchDirs[i] );
                SearchDirs.back().append(Revision);
            }
        }
    }
*/
}

void ReadConfig()
{
    DWORD status;
    BOOL WppParsed = FALSE;
    // If default config file was specified,
    // process it
    if (WppDefault.size() > 0) {
        WppParsed = TRUE;
        Noise("parsing config file %s\n", WppDefault.c_str());
        status = EzParse(WppDefault.c_str(), ParseConfigCallback,0);
        if (status != ERROR_SUCCESS) {
            ExitProcess( status );
        }
    }
    if (LocalConfig.size() == 0) {
        if (FileExists(LOCAL_CONFIG_NAME) ) {
            WppParsed = TRUE;
            Noise("parsing config file %s\n", LOCAL_CONFIG_NAME.c_str());
            status = EzParse(LOCAL_CONFIG_NAME.c_str(),ParseConfigCallback,0);
            if (status != ERROR_SUCCESS) {
                ExitProcess( status );
            }
        }
    }
    else 
    {
        WppParsed = TRUE;
        Noise("parsing config file %s\n", LocalConfig.c_str());
        status = EzParse(LocalConfig.c_str(),ParseConfigCallback,0);
        if (status != ERROR_SUCCESS) {
            ExitProcess( status );
        }
    }

    
    if (!WppParsed) {
		ReportError("configuration file not found\n");
        ExitProcess( ERROR_FILE_NOT_FOUND );
	}

    if (Files.begin() == Files.end()) {
        Unusual("Nothing to compile\n");
        ExitProcess( ERROR_FILE_NOT_FOUND );
    }

    {
    	// Scan files for macro //
        vector<string>::iterator i;
        for (i = ScanForMacros.begin(); i != ScanForMacros.end(); ++i) {
            Noise("scanning %s... \n", i->c_str());
            EzParseEx(i->c_str(), SmartScan, ParseConfigCallback,0, 0);
		}
    }
    
    ParseConfigFromCmdline();
    
    //
    // We need to add prefix and suffix information to FuncMap 
    //
    {
        PREFIX_VECTOR::iterator i;
        Prefix * defaultPrefix = 0;
        Prefix * defaultSuffix = 0;
        string star("*");
        
        for (i = Prefixes.begin(); i != Prefixes.end(); ++i) {
            if ( 0 == i->FuncName.compare(star) ) {
                defaultPrefix = i;
            } else {
                Funcs[i->FuncName].SetPrefix(i);
            }
        }
        for (i = Suffixes.begin(); i != Suffixes.end(); ++i) {
            if ( 0 == i->FuncName.compare(star) ) {
                defaultSuffix = i;
            } else {
                Funcs[i->FuncName].SetSuffix(i);
            }
        }

        //
        // Assign the appendicies to the all other functions
        //

        FUNC_MAP::iterator j = Funcs.begin();
        for(; j != Funcs.end(); ++j) {
            if (!j->second.prefix) {
                j->second.SetPrefix( defaultPrefix );
            }
            if (!j->second.suffix) {
                j->second.SetSuffix( defaultSuffix );
            }
        }
    }

    //
    // Generates names of the log macros based on type names
    // Thus users of the tool can have LOGULONG or log_ulong 
    // or w_ulong(). Whatever they like best
    //
//    RegenerateMacroMap();
}

// used by tpl.cpp to do template include [BUGBUG] currently broken
void ProcessTemplate(LPCSTR b, LPCSTR e, void* Context)
{
    string prev(CurrentTpl);
    CurrentTpl.assign(b,e);
    FindFileOnPath(CurrentTpl, COMPLAIN_BITTERLY | UPDATE_NAME | FAVOR_LOCAL_DIR);

    EzParseEx(CurrentTpl.c_str(), processTemplate,0, Context, 0);

    CurrentTpl.assign(prev);
}

void FormOutputFileName(
    IN const string& to, 
    IN const string& suffix, 
    OUT string& OutputFile,
    OUT BOOL &StdOut
    )
{
    string::size_type backSlash = to.find('\\');
    string::size_type colon     = to.find(':');

    if (to.compare("-") == 0) {
        StdOut = TRUE;
        OutputFile.assign("-");
    } else {
        StdOut = FALSE;
        if (backSlash == string::npos && colon == string::npos) {
            // can prepend odir
            OutputFile.assign(OutputDir);
            OutputFile.append(to);
        } else {
            OutputFile.assign(to);
        }
        OutputFile.append(suffix);
    }
}

void GenerateOutput(string tpl, string to, string suffix = "")
{
    string OutputFile;
    FILE * f = 0;
    BOOL useStdOut = FALSE;

    FormOutputFileName(to, suffix, OutputFile, useStdOut);

    DefaultHasher computedHash;
    computedHash.Init();
    MsgMapHash(MsgMap, computedHash);
    computedHash.Finalize();
    Compiler_tpl.Checksum = &computedHash;

    if (md5) {
        size_t len = min(sizeof(GUID), computedHash.Size() );
        Flood("Going MD5... %d guid(s) ", TraceGuids.guids.size());
        for (int i = 0; i < TraceGuids.guids.size(); ++i) {
            // The following two lines are just needed in case
            // we ever decide DefaultHasher to be CRC32
            // If it will always be MD5 hasher, we can remove them
            ZeroMemory(&TraceGuids.guids[i].guid, sizeof(TraceGuids.guids[i].guid));
            TraceGuids.guids[i].guid.Data2 = (USHORT)i;
            
            CopyMemory(&TraceGuids.guids[i].guid, computedHash.Buf(), len);
            if (DbgLevel >= DBG_FLOOD) {
                TraceGuids.guids[i].printTxt(stdout); putchar(' ');
            }
        }
        Flood("\n");
    }

    // check whether we need to regenerate the file
    if (ErrorCount == 0 && CheckHash) {
        // Scan the beginning of the 
        FILE *inc = fopen(OutputFile.c_str(), "r");
        if (inc) {
            DefaultHasher readHash;
            char buf[128], *p = buf;
            int n = (int)fread(buf, 1, sizeof(buf)-1, inc);
            fclose(inc);
            buf[n] = 0; 
            
            while (!isalnum(*p) && *p ) ++p;

            readHash.fromString(p, buf + n);
            if (DbgLevel >= DBG_FLOOD) {
                computedHash.print(stdout); putchar(' ');
                readHash.print(stdout); putchar(' ');
            }

            if (computedHash == readHash) {
                Noise("No changes in %s.\n",
                    CurrentFile->_Name.c_str() );
                return;
            }
        }
    }

    if (ErrorCount) {
        DeleteFile(OutputFile.c_str());
        Noise("errors detected. deleting %s...\n", OutputFile.c_str());
        return;
    }

    Noise("generating %s...\n", OutputFile.c_str());

    if (useStdOut) {
        f = stdout;
    } else {
        f = fopen(OutputFile.c_str(), "w");
        if (!f) {
            ReportError("Cannot open '%s' for writing, error %d\n", OutputFile.c_str(), GetLastError() );
            ExitProcess( GetLastError() );
        }
    }
    ProcessTemplate(tpl.begin(), tpl.end(), f);
    
    if (!useStdOut) {
        fclose(f);
    }
}

void printTime(LPCSTR Name, ULONGLONG Time)
{
    FILETIME Local; ZeroMemory(&Local, sizeof(Local));
    SYSTEMTIME st; ZeroMemory(&st, sizeof(st));

    FileTimeToLocalFileTime((LPFILETIME)&Time, &Local);
    //CopyMemory(&Local, &Time, sizeof(Time));
    FileTimeToSystemTime(&Local, &st);

    printf("%s %04d/%02d/%02d %02d:%02d:%02d\n", Name, 
        st.wYear, st.wMonth, st.wDay,
        st.wHour, st.wMinute, st.wSecond);
}


void
VerifyAndUpdateTemplatesNames(
    vector<GenPair>& Gen
    )
{
    // verify that the template 
    vector<GenPair>::iterator i;
    for(i = Gen.begin();i != Gen.end();++i){
        FindFileOnPath(i->tpl, COMPLAIN_BITTERLY | UPDATE_NAME | FAVOR_LOCAL_DIR);
    }
}

int RealMain(int argc, char** argv) 
{
    InitGlobals();

    ReadCommandLineArgs(argc, argv);

    if (WppDefault.size()) {
        FindFileOnPath(WppDefault, COMPLAIN_BITTERLY | UPDATE_NAME);
    }

    ReadConfig();

    if (GenSingle.size() == 0 && GenMulti.size() == 0)
    {
        // add default template
        processGenOption(DEFAULT_GEN_OPTION);
    }

    BOOL OneAtATime = GenMulti.size() > 0;

    VerifyAndUpdateTemplatesNames(GenMulti);
    VerifyAndUpdateTemplatesNames(GenSingle);

    {
        FILES::iterator file;

        if (CheckTimestamp)
        {
            //
            // Before we do any heavyweight processing
            // let's check timestamps of source
            // and output files
            //
            
            ULONGLONG Now, MaxSrcTime, MinOutTime;
            string OutputFile;

            GetSystemTimeAsFileTime((LPFILETIME)&Now);

            MaxSrcTime = 0;
            MinOutTime = Now;
            
            for (file = Files.begin(); file != Files.end(); ++file) {
                if (file->ModificationTime == 0) {
                    Always("%s file has invalid modification time\n",
                           file->_BaseName.c_str());
                    goto out_of_date;       
                }
                if (file->ModificationTime > Now) {
                    Always("%s file modification time is in the future\n",
                           file->_BaseName.c_str());
                    goto out_of_date;
                }
                if (file->ModificationTime > MaxSrcTime) {
                    MaxSrcTime = file->ModificationTime;
                }
                
                vector<GenPair>::iterator i;
                for(i = GenMulti.begin();i != GenMulti.end();++i){
                    BOOL StdOut;
                    ULONGLONG Time;
                    
                    FormOutputFileName(file->_BaseName, i->out.c_str(),
                        OutputFile, StdOut);
                    if (StdOut) {
                        // StdOut is always out of date //
                        goto out_of_date;
                    }

                    Time = GetFileModificationTime(OutputFile);
                    if (Time == 0) {
                        goto out_of_date;
                    }
                    if (Time > Now) {
                        Always("%s file modification time is in the future\n",
                               OutputFile.c_str());
                        goto out_of_date;
                    }
                    if (Time < MinOutTime) {
                        MinOutTime = Time;
                    }
                }
            }
            vector<GenPair>::iterator i;
            for(i = GenSingle.begin();i != GenSingle.end();++i){
                BOOL StdOut;
                ULONGLONG Time;
                
                FormOutputFileName(file->_BaseName, i->out.c_str(),
                    OutputFile, StdOut);
                if (StdOut) {
                    // StdOut is always out of date //
                    goto out_of_date;
                }

                Time = GetFileModificationTime(OutputFile);
                if (Time == 0) {
                    goto out_of_date;
                }
                if (Time > Now) {
                    Always("%s file modification time is in the future\n",
                           OutputFile.c_str());
                    goto out_of_date;
                }
                if (Time < MinOutTime) {
                    MinOutTime = Time;
                }
            }
            if (MaxSrcTime <= MinOutTime) {
                
//                printTime("Src time:", MaxSrcTime);
//                printTime("Out time:", MinOutTime);
//                Noise("No Processing Required\n");
                return 0;
            }
        } // if (CheckTimestamp) //

    out_of_date:        
        //
        // Now we are ready to start scanning the source files
        //

        for (file = Files.begin(); file != Files.end(); ++file) {
            Noise("processing %s... \n", file->FullFileName().c_str());
            CurrentFile = file;
            if (SeparateTraceGuidPerFile) {
                TraceGuids.new_file( file->_Name.c_str() );
            }
            EzParseWithOptions(file->FullFileName().c_str(), ParseSrcCallback, 0, IGNORE_CPP_COMMENT);
            
            {
                vector<GenPair>::iterator i;
                for(i = GenMulti.begin();i != GenMulti.end();++i){
                    GenerateOutput(i->tpl, file->_BaseName, i->out.c_str());
                }
            }
            
            if (OneAtATime) {
                // Clear the tables for the next iteration 
                
                MsgMap.erase(MsgMap.begin(), MsgMap.end());
                TypeSigMap.erase(TypeSigMap.begin(), TypeSigMap.end());
                TraceGuids.erase();

                for (TYPE_SET::const_iterator i = TypeSet.begin(); 
                     i != TypeSet.end(); ++i)
                {
                    i->second.Used = FALSE;
                }
            }
        }
        Noise("done. Errors: %d.\n", ErrorCount);   
    }
#if 0
    // update Used field for every type in TypeSigSet
    {
        for (TYPESIG_MAP::const_iterator i = TypeSigMap.begin(); 
             i != TypeSigMap.end(); ++i)
        {
            for(int j = 0; j < i->Types.size(); ++j) {
                i->second.Types[j]->Used = TRUE;
            }
        }
    }
#endif
    // generate global files
    {
        vector<GenPair>::iterator i;
        for(i = GenSingle.begin();i != GenSingle.end();++i){
            GenerateOutput(i->tpl, i->out.c_str());
        }
    }

    return ErrorCount;
}

int __cdecl main(int argc, char** argv) 
{
    int status = 0;
    __int64 a, b;
    GetSystemTimeAsFileTime((LPFILETIME)&a);
    __try 
    {
        status = RealMain(argc, argv);
    } 
     __except(EXCEPTION_EXECUTE_HANDLER) 
    {
        status = 1;
        ReportError("Internal Error : Contact GorN\n");
    }
    {
        SYSTEMTIME st;
        GetSystemTimeAsFileTime((LPFILETIME)&b);
        b -= a;
        FileTimeToSystemTime((LPFILETIME)&b, &st);
        Always("tracewpp: %d file(s) with %d message(s), processed in %d.%03d seconds\n", 
            Files.size(), MessageCount,
            st.wSecond, st.wMilliseconds);
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\tracewpp\fieldtable.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    FieldTable.h

Abstract:

    Field Table declarations for tracewpp.exe

    field table allows tpl interpreter to
    work with data collected by during scanning of the source files.
    
Author:

    Gor Nishanov (gorn) 03-Apr-1999

Revision History:

    Gor Nishanov (gorn) 03-Apr-1999 -- hacked together to prove that this can work

ToDo:

    Clean it up

--*/

extern LPCSTR FieldNames[];

struct FieldHolder;

struct Enumerator {
    virtual void Reset(std::string Filter) = 0;
    virtual void Next(std::string Filter) = 0;
    virtual bool Valid() const = 0;
    virtual const FieldHolder* GetData() const = 0;
    virtual ~Enumerator(){}
};

struct FieldHolder {
    virtual DWORD PrintField(int fieldId, FILE* f, const Enumerator **) const = 0;
    virtual BOOL Hidden(std::string filter="") const { return FALSE; }
};

struct VectorPtrTag {};
struct VectorTag {};
struct MapTag{};
struct MapPtrTag{};

template <class T> const FieldHolder* GetFieldHolder(const T& Data, VectorPtrTag) { return Data;}
template <class T> const FieldHolder* GetFieldHolder(const T& Data, VectorTag)    { return &Data;}
template <class T> const FieldHolder* GetFieldHolder(const T& Data, MapPtrTag)    { return Data.second;}
template <class T> const FieldHolder* GetFieldHolder(const T& Data, MapTag)       { return &Data.second;}

template <class Container, class Tag>
class EnumeratorFromContainer : public Enumerator 
{
    typedef Container::const_iterator const_iterator;
    const_iterator _current, _begin, _end;
public:

    EnumeratorFromContainer(const Container& v):
        _begin(v.begin()),_end(v.end()),_current(v.begin()) {}
    
    void Reset(std::string Filter) { _current = _begin; while(Valid() && GetData()->Hidden(Filter)) ++_current;}
    void Next(std::string Filter) { ++_current; while(Valid() && GetData()->Hidden(Filter)) ++_current; }
    bool Valid() const { return _current != _end; }
    
    const FieldHolder* GetData() const { return GetFieldHolder(*_current, Tag()); }
};

template <class Container, class Tag> 
Enumerator* GetEnumFromContainer(const Container& v, Tag) {
    return new EnumeratorFromContainer< Container, Tag >( v );
}

#define DEFAULT_FID 0

#define TEXT_FIELD(FieldId) break; case fid_ ## FieldId: \
    if (__f__ == 0) { \
        printf("%s.%s can not be enumerated\n",__Object__, #FieldId); \
        exit(1); \
    }
    
#define ENUM_FIELD(FieldId,FieldName,Tag) break; case fid_ ## FieldId: \
    if (__pEnum__ == 0) { \
       printf("%s.%s is an enumeration\n",__Object__, #FieldId); \
       exit(1); \
    } \
    *__pEnum__ = GetEnumFromContainer(FieldName, Tag() );

#define DEFAULT_TEXT_FIELD break; case DEFAULT_FID: \
    if (__f__ == 0) {printf("%s can not be enumerated\n",__Object__); exit(1);}
    
#define DEFAULT_ENUM_FIELD(EnumName,Tag) break; case DEFAULT_FID: \
    if (__pEnum__ == 0) {printf("%s is an enumeration\n",__Object__); exit(1);} \
    *__pEnum__ = GetEnumFromContainer(EnumName, Tag() );

#define BEGIN_FIELD_TABLE(__ObjectName__, __Output__) \
    DWORD PrintField(int __FieldId__, FILE* __Output__, const Enumerator** __pEnum__) const \
    { \
        DWORD __status__ = ERROR_SUCCESS; \
        static char* __Object__ = #__ObjectName__; \
        FILE* __f__ = __Output__; \
        UNREFERENCED_PARAMETER(__pEnum__); \
        switch(__FieldId__) { case -1:;

#define BEGIN_FIELD_TABLE_NONAME(__Output__) \
    DWORD PrintField(int __FieldId__, FILE* __Output__, const Enumerator** __pEnum__) const \
    { \
        DWORD __status__ = ERROR_SUCCESS; \
        FILE* __f__ = __Output__; \
        UNREFERENCED_PARAMETER(__pEnum__); \
        switch(__FieldId__) { case -1:;

#define END_FIELD_TABLE \
            break;\
            default: __status__ = ERROR_NOT_FOUND; \
            ReportError("\"%s\" (%d) is not a member of \"%s\"\n",FieldNames[__FieldId__], __FieldId__,__Object__); \
            exit(1); \
        } \
        return __status__; \
    }

template <class Container, class Tag>
class ContainerAdapter : public FieldHolder {
    LPCSTR __Object__; // END_FIELD_TABLE uses __Object__ as an object name //
    Container& _container;
public:
    ContainerAdapter(LPCSTR name, Container& container):
        _container(container), __Object__(name) {}

    BEGIN_FIELD_TABLE_NONAME(out)
        TEXT_FIELD(Count) fprintf(out, "%d", _container.size());
        DEFAULT_ENUM_FIELD(_container, Tag)
    END_FIELD_TABLE    
};

class StringAdapter : public FieldHolder {
    LPCSTR __Object__; // END_FIELD_TABLE uses __Object__ as an object name //
    const std::string& _string;
public:
    StringAdapter(LPCSTR name, const std::string& string):
        __Object__(name), _string(string) {}
    
    BEGIN_FIELD_TABLE_NONAME(out)
        DEFAULT_TEXT_FIELD { fprintf(out, "%s", _string.c_str()); }
    END_FIELD_TABLE    
};

template<class Iterator>
struct IteratorAdapter : FieldHolder {
    Iterator* theRealThing;

    explicit IteratorAdapter(Iterator* aRealThing):theRealThing(aRealThing) {}

    DWORD PrintField(int fieldId, FILE* f, const Enumerator** pEnum) const {
        return (*theRealThing)->PrintField(fieldId, f, pEnum);
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\typeperf\resource.h ===
/*****************************************************************************\

    Author: Corey Morgan (coreym)

    Copyright (c) Microsoft Corporation. All rights reserved.

\*****************************************************************************/

#define    IDS_PARAM_FORMAT          113
#define    IDS_PARAM_INPUT           116
#define    IDS_PARAM_INTERVAL        119
#define    IDS_PARAM_OUTPUT          122
#define    IDS_PARAM_COUNTERS        128
#define    IDS_PARAM_SAMPLES         132
#define    IDS_PARAM_QUERY           135
#define    IDS_PARAM_QUERYX          139
#define    IDS_PARAM_SERVER          145
#define    IDS_PARAM_YES             146

#define    IDS_DEFAULT_OUTPUT        600

#define    IDS_MESSAGE_NOCOUNTERS    700
#define    IDS_MESSAGE_EXIT          701
#define    IDS_MESSAGE_CEXIT         702
#define    IDS_MESSAGE_BADFORMAT     704
#define    IDS_MESSAGE_BADCOUNTER    705

#define    IDS_EXAMPLE_COUNTERS      800
#define    IDS_EXAMPLE_QUERYALL      801
#define    IDS_EXAMPLE_FORMAT        802
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\typeperf\pdqpdh.h ===
/*****************************************************************************\

    PDQ Pdh Query Handler
  
    Author: Corey Morgan (coreym)

    Copyright (c) Microsoft Corporation. All rights reserved.
        
\*****************************************************************************/

#ifndef PDHPDQ_H_05271999
#define PDHPDQ_H_05271999

#include <pdh.h>
#include <pdhmsg.h>

#if (WINVER <= 0x400)
#define PDH_FMT_NOCAP100    (0)
#endif

#define PDQ_BASE_NAME       0x0FFFFFFF
#define PDQ_ALLOCSIZE       1024
#define PDQ_GROWSIZE        16
#define PDQ_COUNTER         PPDH_FMT_COUNTERVALUE_ITEM
#define PDQ_PROCESSOR_TIME  _T("\\Processor(_Total)\\% Processor Time")
#define PDQ_DISK_TIME       _T("\\PhysicalDisk(_Total)\\% Disk Time")
#define PDQ_DISK_IDLE       _T("\\PhysicalDisk(_Total)\\% Idle Time")
#define PDQ_PERPETUAL       (-1)
#define PDQ_PDH_CSV_HEADER  _T("\"(PDH-CSV 4.0)\"")

#define PDQ_FLAG_RETURN_ON_ERROR        1

#define PDQ_MORE_DATA(x)    (x == PDH_INSUFFICIENT_BUFFER || x == PDH_MORE_DATA)

#define PDQ_STATE_IDLE      0
#define PDQ_STATE_LOGGING   1

#define PDQ_BAD_VALUE       (-1)

#define PDQ_ERROR_RETURN( c, x )                    \
    if( ERROR_SUCCESS != x ){                       \
        BOOL bUseCritSection = c;                   \
        if( bUseCritSection ){                      \
            LeaveCriticalSection( &m_critsec );     \
        }                                           \
        return x;                                   \
    }                                               \

#define PDQ_CHECK_TERMINATE( x )   \
if( x != NULL ){                   \
    if( *x == TRUE ){              \
        goto cleanup;              \
    }                              \
}                                  \

typedef struct _PDQ_BUFFER{
    union{
        void*           buffer;
        HCOUNTER*       pCounter;
        LPTSTR*         szName;
        PDQ_COUNTER     pValue;
        LPTSTR          strBuffer;
    };
    DWORD   cbSize;
    DWORD   dwMaxElements;
    DWORD   dwNumElements;
    BOOL    bValid;
} PDQ_BUFFER, *PPDQ_BUFFER;

class CPdqPdh
{
public:
    CPdqPdh();
    ~CPdqPdh();
    
    PDH_STATUS Initialize( BOOL* pbTerminate );

    PDH_STATUS AddCounter( 
            LPTSTR strCounter, 
            LPTSTR strComputer,            
            void    (*fntError)(LPTSTR, PDH_STATUS)
    );
    
    PDH_STATUS Query();
    PDH_STATUS CollectData( ULONG index );

    LPCTSTR GetDataName( ULONG index );
    double GetData( ULONG index );
    double GetCounterValue( LPTSTR strCounter, BOOL bQuery = TRUE );
    double GetCounterValue( ULONG index, BOOL bQuery = TRUE );

    
    ULONG GetDataCount() { return m_pdhValues.dwNumElements; };
    ULONG GetCounterCount() { return m_pdhCounters.dwNumElements; };
    
    DWORD GetCountersFromFile( 
            LPTSTR szFileName, 
            LPTSTR szComputer,
            void    (*fntError)(LPTSTR, PDH_STATUS)
        );

    PDH_STATUS LogCreate( LPTSTR szLogName, DWORD fType );
    PDH_STATUS LogData();
    PDH_STATUS LogClose();
    DWORD LogStart( ULONG interval, long samples = PDQ_PERPETUAL );
    DWORD LogStop();
    DWORD GetState();
    void  SetExpand( BOOL bExpand ){ m_bExpand = bExpand; }

public:
    CRITICAL_SECTION    m_critsec;
    DWORD       m_fState;
    ULONG       m_nCollectionInterval;
    ULONG       m_nSamples;
    ULONG       m_nTotalCollected;
    HANDLE      m_hLogMutex;

private:
    HQUERY      m_hQuery;
    PDQ_BUFFER  m_pdhValues;        // PDQ_COUNTER  
    PDQ_BUFFER  m_pdhCounters;      // HCOUNTER*
    PDQ_BUFFER  m_pdhCounterNames;  // LPTSTR*
    PDQ_BUFFER  m_pdhDataNames;     // LPTSTR*
    BOOL        m_bGoodData;
    BOOL        m_bGoodNames;
    ULONG       m_nCurrentIndex;
    BOOL        m_bFirstQuery;
    BOOL        m_bInitialized;
    HLOG        m_hLog;
    TCHAR       m_strMessage[PDQ_ALLOCSIZE];
    BOOL        m_bMessage;
    HANDLE      m_hCollectionThread;
    BOOL*       m_pbTerminate;
    BOOL        m_bExpand;

private:
    DWORD GrowMemory( PPDQ_BUFFER buffer, size_t tSize, DWORD dwSize, BOOL bSave = FALSE );
    PDH_STATUS EnumPath( LPTSTR szWildCardPath );
    DWORD Add( HCOUNTER hCounter, LPTSTR szCounter );
};

#endif //PDHPDQ_H_05271999
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\typeperf\pdqpdh.cpp ===
/*****************************************************************************\

    PDQ Pdh Query Handler
  
    Author: Corey Morgan (coreym)

    Copyright (c) Microsoft Corporation. All rights reserved.
        
\*****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <assert.h>
#include "pdqpdh.h"
#include <varg.h>

CPdqPdh::CPdqPdh()
{
    m_nCurrentIndex = 0;
    m_bGoodData = FALSE;
    m_bGoodNames = FALSE;
    m_bFirstQuery = TRUE;
    m_bInitialized = FALSE;
    m_fState = PDQ_STATE_IDLE;
    m_hLog = NULL;
    m_hCollectionThread = NULL;
    m_hLogMutex = NULL;
    m_pbTerminate = NULL;
}

PDH_STATUS
CPdqPdh::Initialize( BOOL* pbTerminate )
{
    PDH_STATUS pdhStatus;
    m_pbTerminate = pbTerminate;

    if(m_bInitialized){
        return ERROR_SUCCESS;
    }

    InitializeCriticalSection( &m_critsec );
    EnterCriticalSection( &m_critsec );
    
    pdhStatus = PdhOpenQuery( 0, 0, &m_hQuery);
    PDQ_ERROR_RETURN( TRUE, pdhStatus );
    
    m_nTotalCollected = 0;
    
    ZeroMemory( &m_pdhCounters, sizeof(PDQ_BUFFER) );
    ZeroMemory( &m_pdhCounterNames, sizeof(PDQ_BUFFER) );
    ZeroMemory( &m_pdhValues, sizeof(PDQ_BUFFER) );
    ZeroMemory( &m_pdhDataNames, sizeof(PDQ_BUFFER) );

    pdhStatus = GrowMemory( &m_pdhValues, (sizeof(PDQ_COUNTER)), PDQ_ALLOCSIZE );
    PDQ_ERROR_RETURN( TRUE, pdhStatus );

    pdhStatus = GrowMemory( &m_pdhCounters, sizeof(HCOUNTER), 0 );
    PDQ_ERROR_RETURN( TRUE, pdhStatus );
    
    pdhStatus = GrowMemory( &m_pdhCounterNames, sizeof(LPTSTR*), 0 );
    PDQ_ERROR_RETURN( TRUE, pdhStatus );

    pdhStatus = GrowMemory( &m_pdhDataNames, sizeof(TCHAR), PDQ_ALLOCSIZE );
    PDQ_ERROR_RETURN( TRUE, pdhStatus );

    m_hLogMutex = CreateMutex( NULL, FALSE, NULL );

    m_bInitialized = TRUE;  
    m_bExpand = FALSE;

    LeaveCriticalSection( &m_critsec );
    return ERROR_SUCCESS;
}

CPdqPdh::~CPdqPdh()
{
    PDH_STATUS pdhStatus;
    BOOL bResult;

    __try {
        LogClose();

        pdhStatus = PdhCloseQuery (m_hQuery);
        assert (pdhStatus == ERROR_SUCCESS);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
    }

    EnterCriticalSection( &m_critsec );
    bResult = HeapValidate( GetProcessHeap(), 0, NULL );
    
    if( m_pdhCounters.buffer != NULL ){
        HeapFree( GetProcessHeap(), 0, m_pdhCounters.buffer );
        m_pdhCounters.buffer = NULL;
    }
    for(UINT i=0;i<m_pdhCounterNames.dwNumElements;i++){
        if( NULL != m_pdhCounterNames.szName[i] ){
            HeapFree( GetProcessHeap(), 0, m_pdhCounterNames.szName[i] );
            m_pdhCounterNames.szName[i] = NULL;
        }
    }
    if( m_pdhCounterNames.buffer != NULL ){
        HeapFree( GetProcessHeap(), 0, m_pdhCounterNames.buffer );
        m_pdhCounterNames.buffer = NULL;
    }
    if( m_pdhValues.buffer != NULL ){
        HeapFree( GetProcessHeap(), 0, m_pdhValues.buffer );
        m_pdhValues.buffer  = NULL;
    }
    if( m_pdhDataNames.buffer != NULL ){
        HeapFree( GetProcessHeap(), 0, m_pdhDataNames.buffer );
        m_pdhDataNames.buffer = NULL;
    }

    if( m_hLogMutex != NULL ){
        CloseHandle ( m_hLogMutex );
        m_hLogMutex = NULL;
    }
    LeaveCriticalSection( &m_critsec );
    
    DeleteCriticalSection( &m_critsec );
}

DWORD
CPdqPdh::GrowMemory( PPDQ_BUFFER buffer, size_t tSize, DWORD dwNumElements, BOOL bSave )
{
    void* pNewBlock;
    DWORD dwAlloc;
    
    if( dwNumElements == 0 ){
        dwNumElements = ((int)(buffer->dwNumElements/PDQ_GROWSIZE)+1) * PDQ_GROWSIZE;
        buffer->dwMaxElements += PDQ_GROWSIZE;
    }
    
    dwAlloc = dwNumElements * tSize;
    if( dwAlloc <= 0 ){
        return ERROR_BAD_ARGUMENTS;
    }
    
    pNewBlock = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwAlloc );

    if( NULL == pNewBlock ){
        return ERROR_OUTOFMEMORY;
    }

    if( buffer->buffer != NULL ){
        if( bSave ) CopyMemory( pNewBlock, buffer->buffer, buffer->cbSize );
        HeapFree( GetProcessHeap(), 0, buffer->buffer );
        buffer->buffer = NULL;
    }

    buffer->cbSize = dwAlloc;
    buffer->dwMaxElements = (dwAlloc / tSize);
    buffer->buffer = pNewBlock;
    
    assert( buffer->buffer != NULL);
    
    return ERROR_SUCCESS;
}

DWORD
CPdqPdh::GetCountersFromFile( LPTSTR szFileName, LPTSTR szComputer, void (*fntError)(LPTSTR, PDH_STATUS) )
{
    TCHAR buffer[PDQ_ALLOCSIZE];
    LPTSTR strCounter;
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    
    FILE* f = _tfopen( szFileName, _T("r") );

    if( !f ){
        return GetLastError();
    }
    
    while( NULL != _fgetts( buffer, PDQ_ALLOCSIZE, f ) ){
        
        PDQ_CHECK_TERMINATE( m_pbTerminate );
        
        if( buffer[0] == _T(';') || // comments
            buffer[0] == _T('#') ){
            continue;
        }
        
        Chomp(buffer);

        if( _tcsicmp( buffer, _T("NULL") ) == 0 ){
            break;
        }
        
        strCounter = _tcstok( buffer, _T("\"\n") );
        if( strCounter == NULL ){
            continue;
        }

        AddCounter( strCounter, szComputer, fntError );
    }

cleanup:
    fclose( f );

    return ERROR_SUCCESS;
}

DWORD
CPdqPdh::Add( HCOUNTER hCounter, LPTSTR szCounter )
{
    DWORD dwStatus = ERROR_SUCCESS;
  
    if( m_pdhCounters.dwNumElements == m_pdhCounters.dwMaxElements ){
        dwStatus = GrowMemory( &m_pdhCounters, sizeof(HCOUNTER), 0, true );
        PDQ_ERROR_RETURN( FALSE, dwStatus );
        
        dwStatus = GrowMemory( &m_pdhCounterNames, sizeof(LPTSTR*), 0, true);
        PDQ_ERROR_RETURN( FALSE, dwStatus );
    }
    
    m_pdhCounters.pCounter[m_pdhCounters.dwNumElements++] = hCounter;

    m_pdhCounterNames.szName[m_pdhCounterNames.dwNumElements] = 
        (LPTSTR)HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, (_tcslen( szCounter )+1)*sizeof(TCHAR) );

    if( NULL == m_pdhCounterNames.szName[m_pdhCounterNames.dwNumElements] ){
        PDQ_ERROR_RETURN( FALSE, ERROR_OUTOFMEMORY );
    }

    _tcscpy( 
            m_pdhCounterNames.szName[m_pdhCounterNames.dwNumElements++],
            szCounter
        );

    return dwStatus;
}

PDH_STATUS
CPdqPdh::AddCounter( LPTSTR strCounter, LPTSTR strComputer, void (*fntError)(LPTSTR, PDH_STATUS) )
{
    PDH_STATUS pdhStatus;
    BOOL bResult;
    HCOUNTER pCounter;
    TCHAR buffer[PDQ_ALLOCSIZE];
    LPTSTR szCounterPath;
    TCHAR strComputerName[MAX_COMPUTERNAME_LENGTH+2];
    DWORD dwSize = MAX_COMPUTERNAME_LENGTH+1;
    LPTSTR strUseComputer = NULL;
    ULONG nChars = 0;
    ULONG nWhacks = 0;

    if( strCounter == NULL ){
        return PDH_INVALID_ARGUMENT;
    }
    nChars = _tcslen( strCounter );
    if( nChars >= PDQ_ALLOCSIZE || nChars < 3 ){
        return PDH_INVALID_ARGUMENT;
    }
    
    EnterCriticalSection( &m_critsec );
    PDQ_CHECK_TERMINATE( m_pbTerminate );
    
    while( strCounter[nWhacks] == _T('\\') ){ nWhacks++; }
   
    if( 2 <= nWhacks ){
        szCounterPath = strCounter;
    }else{
        if( NULL == strComputer ){
            bResult = GetComputerName( strComputerName, &dwSize );
            if( !bResult ){
                LeaveCriticalSection( &m_critsec );
                return GetLastError();
            }
            strUseComputer = strComputerName;
        }else{
            strUseComputer = strComputer;
        }
        while( *strUseComputer == _T('\\') ){
            strUseComputer++;
        }
        nChars += _tcslen( strUseComputer ) + 4;
        if( nChars >= PDQ_ALLOCSIZE ){
            PDQ_ERROR_RETURN( TRUE, PDH_INVALID_ARGUMENT );
        }
        _stprintf( buffer, _T("\\\\%s%s%s"), 
                    strUseComputer, 
                    (nWhacks == 1) ? _T("") : _T("\\"), 
                    strCounter 
                );
        szCounterPath = buffer;
    }

    m_bFirstQuery = TRUE;
    
    PDQ_CHECK_TERMINATE( m_pbTerminate );
    
    if( m_bExpand ){

        pdhStatus = EnumPath( szCounterPath );
        PDQ_CHECK_TERMINATE( m_pbTerminate );
        
        if( ERROR_SUCCESS == pdhStatus ){

            LPTSTR str = m_pdhDataNames.strBuffer;
    
            while (*str){
                pdhStatus = PdhAddCounter(
                        m_hQuery,
                        str,
                        0,
                        &pCounter
                    );
                
                PDQ_CHECK_TERMINATE( m_pbTerminate );
                
                if( ERROR_SUCCESS != pdhStatus ){
                    if( fntError != NULL ){
                        fntError( str, pdhStatus );
                    }
                    break;
                }else{
                    pdhStatus = Add( pCounter, str);
                }
        
                str += (_tcslen(str) + 1);
            }
        }

    }else{

        pdhStatus = PdhAddCounter(
                m_hQuery,
                szCounterPath,
                0,
                &pCounter
            );

        if( ERROR_SUCCESS != pdhStatus ){
            if( fntError != NULL ){
                fntError( szCounterPath, pdhStatus );
            }
        }else{
            pdhStatus = Add( pCounter, szCounterPath );
        }
    }


cleanup:
    LeaveCriticalSection( &m_critsec );
    return ERROR_SUCCESS;
}

PDH_STATUS
CPdqPdh::LogCreate( LPTSTR szLogName, DWORD fType )
{
    PDH_STATUS pdhStatus;

    pdhStatus = PdhOpenLog(
            szLogName, 
            PDH_LOG_WRITE_ACCESS|PDH_LOG_CREATE_ALWAYS, 
            &fType,
            m_hQuery,
            0,
            _T("TYPEPERF"),
            &m_hLog 
        );


    return pdhStatus;
}
    
PDH_STATUS
CPdqPdh::LogData()
{
    PDH_STATUS pdhStatus = PDH_INVALID_HANDLE;
    
    if( m_hLog != NULL ){
        pdhStatus = PdhUpdateLog( m_hLog, NULL );
    }

    return pdhStatus;
}

PDH_STATUS
CPdqPdh::LogClose()
{
    PDH_STATUS pdhStatus = PDH_INVALID_HANDLE;

    LogStop();

    if( m_hLog != NULL ){
        pdhStatus = PdhCloseLog( m_hLog, 0 );
    }

    return pdhStatus;
}

unsigned long __stdcall PdqCollectionThread( void* pdq )
{
    CPdqPdh* pPdqPdh = (CPdqPdh*)pdq;

    if( pPdqPdh == NULL ){
        return 0;
    }
    
    DWORD dwWait;
    BOOL bRun = TRUE;

    while(bRun){

        dwWait = WaitForSingleObject( pPdqPdh->m_hLogMutex, pPdqPdh->m_nCollectionInterval );
        
        if( dwWait == WAIT_TIMEOUT && pPdqPdh->m_fState == PDQ_STATE_LOGGING ){

            pPdqPdh->LogData();
            
            if( pPdqPdh->m_nSamples != PDQ_PERPETUAL ){
                pPdqPdh->m_nSamples--;
            }
            if( pPdqPdh->m_nSamples == 0 ){
                pPdqPdh->m_fState = PDQ_STATE_IDLE;
                break;
            }

        }else{
            if( dwWait == WAIT_OBJECT_0 ){
                ReleaseMutex( pPdqPdh->m_hLogMutex );    
            }
            break;
        }
    }

    return 0;
}

DWORD
CPdqPdh::GetState()
{
    return m_fState;
}

DWORD
CPdqPdh::LogStart( ULONG interval, long samples )
{
    DWORD tid;
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwWait;

    EnterCriticalSection( &m_critsec );
    
    if( m_fState == PDQ_STATE_IDLE && m_hLog != NULL ){    

        if( NULL == m_hLogMutex ){
            return GetLastError();
        }

        dwWait = WaitForSingleObject( m_hLogMutex, 0 );

        if( WAIT_OBJECT_0 == dwWait ){
            m_nCollectionInterval = interval;
            m_nSamples = samples;

            if( m_nCollectionInterval < 1000 ){
                m_nCollectionInterval = 1000;
            }

            m_fState |= PDQ_STATE_LOGGING;
            m_hCollectionThread = CreateThread( NULL, 0, PdqCollectionThread, this, 0, &tid );
    
            if( m_hCollectionThread == NULL ){
                ReleaseMutex( m_hLogMutex );
                dwStatus = GetLastError();
            }else{
                dwStatus = ERROR_SUCCESS;
            }
        }
    }else{
        dwStatus = ERROR_TOO_MANY_OPEN_FILES;
    }

    LeaveCriticalSection( &m_critsec );
    return dwStatus;
}

DWORD 
CPdqPdh::LogStop()
{
    BOOL bResult;
    DWORD dwCode = 0;
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwWait;

    EnterCriticalSection( &m_critsec );
    
    if( m_hCollectionThread != NULL ){
        
        m_fState = PDQ_STATE_IDLE;
        ReleaseMutex( m_hLogMutex );
    
        dwWait = WaitForSingleObject( m_hLogMutex, m_nCollectionInterval*2 );
        bResult = GetExitCodeThread( m_hCollectionThread, &dwCode );
    
        if( dwCode == STILL_ACTIVE ){
            bResult = TerminateThread( m_hCollectionThread, 0 );
        }

        if( ! bResult ){
            dwStatus = GetLastError();
        }

        CloseHandle( m_hCollectionThread );
        m_hCollectionThread = NULL;
        
        if( dwWait == WAIT_OBJECT_0 ){
            ReleaseMutex( m_hLogMutex );
        }
    }
    
    LeaveCriticalSection( &m_critsec );

    return dwStatus;
}

PDH_STATUS
CPdqPdh::Query()
{
    PDH_STATUS pdhStatus;
    EnterCriticalSection( &m_critsec );

    pdhStatus = PdhCollectQueryData( m_hQuery );
    if(m_bFirstQuery){
        pdhStatus = PdhCollectQueryData( m_hQuery );
        m_bFirstQuery = FALSE;
    }

    m_nTotalCollected++;
    LeaveCriticalSection( &m_critsec );

    return pdhStatus;
}

PDH_STATUS 
CPdqPdh::CollectData( ULONG index )
{
    PDH_STATUS pdhStatus;
    EnterCriticalSection( &m_critsec );

    m_bGoodData = FALSE;
    m_bGoodNames = FALSE;
    DWORD dwItemSize = m_pdhValues.cbSize;
    if( index > m_pdhCounters.dwNumElements ){
        LeaveCriticalSection( &m_critsec );
        return ERROR_INVALID_HANDLE;
    }
    HCOUNTER hCounter = m_pdhCounters.pCounter[index];

    pdhStatus = PdhGetFormattedCounterArray(
            hCounter,
            PDH_FMT_DOUBLE|PDH_FMT_NOCAP100, 
            &dwItemSize,
            &m_pdhValues.dwNumElements,
            m_pdhValues.pValue
        );
    
    if (pdhStatus == PDH_MORE_DATA){
        dwItemSize = 0;
        pdhStatus = PdhGetFormattedCounterArray(
                m_pdhCounters.pCounter[index],
                PDH_FMT_DOUBLE|PDH_FMT_NOCAP100,
                &dwItemSize,
                &m_pdhValues.dwNumElements,
                NULL
            );
                
        pdhStatus = GrowMemory( 
                &m_pdhValues,
                sizeof(PDQ_COUNTER), 
                ++dwItemSize 
            );

        PDQ_ERROR_RETURN(TRUE, pdhStatus );

        dwItemSize = m_pdhValues.cbSize;

        pdhStatus = PdhGetFormattedCounterArray(
                m_pdhCounters.pCounter[index],
                PDH_FMT_DOUBLE|PDH_FMT_NOCAP100,
                &dwItemSize,
                &m_pdhValues.dwNumElements,
                m_pdhValues.pValue
            );
    }

    m_nCurrentIndex = index;

    PDQ_ERROR_RETURN( TRUE, pdhStatus );

    m_bGoodData = TRUE;

    LeaveCriticalSection( &m_critsec );

    return ERROR_SUCCESS;
}

double 
CPdqPdh::GetData( ULONG index )
{
    if( (m_bGoodData == TRUE) && (index < m_pdhValues.dwNumElements) ){
        return m_pdhValues.pValue[index].FmtValue.doubleValue;
    }

    return -1.0;
}

PDH_STATUS
CPdqPdh::EnumPath( LPTSTR szWildCardPath )
{
    PDH_STATUS pdhStatus;
    DWORD dwItemSize = m_pdhDataNames.dwMaxElements;

    m_pdhDataNames.dwNumElements = 0;


    do{

        ZeroMemory( m_pdhDataNames.strBuffer, m_pdhDataNames.cbSize );

        pdhStatus = PdhExpandWildCardPath(
                    NULL,
                    szWildCardPath,
                    m_pdhDataNames.strBuffer,
                    &dwItemSize,
                    0
                );

/*
        pdhStatus = PdhExpandCounterPath(
                szWildCardPath,
                (LPTSTR)m_pdhDataNames.szName,
                &dwItemSize
            );
*/
        if( PDH_MORE_DATA == pdhStatus ){
            HRESULT hr = GrowMemory( &m_pdhDataNames, sizeof(TCHAR), ++dwItemSize );
            PDQ_ERROR_RETURN( FALSE, hr );
            dwItemSize = m_pdhDataNames.cbSize;
        }


    }while( PDH_MORE_DATA == pdhStatus );

    return pdhStatus;
}

LPCTSTR 
CPdqPdh::GetDataName( ULONG index )
{
    PDH_STATUS pdhStatus;
    
    if( PDQ_BASE_NAME == index ){
        return m_pdhCounterNames.szName[m_nCurrentIndex];
    }
    if( m_bGoodNames == FALSE){
            
        pdhStatus = EnumPath( 
                m_pdhCounterNames.szName[m_nCurrentIndex] 
            );

        if( ERROR_SUCCESS != pdhStatus ){
            return m_pdhCounterNames.szName[m_nCurrentIndex];
        }
        
        m_bGoodNames = TRUE;
    }
    
    LPTSTR str = m_pdhDataNames.strBuffer;
    ULONG nCount = 0;
    
    while (*str){
        
        if( nCount++ == index ){
            return str;
        }
        
        str += _tcslen(str);
        str++;
    }
    
    return NULL;
}

double
CPdqPdh::GetCounterValue( LPTSTR strCounter, BOOL bQuery )
{
    for( unsigned int i=0;i<m_pdhCounterNames.dwNumElements;i++){
        if( _tcsstr( m_pdhCounterNames.szName[i], strCounter ) ){
            if( bQuery && (Query() != ERROR_SUCCESS) ){
                return -1;
            }
            CollectData( i );
            return GetData( 0 );
        }
    }

    return -1;
}

double
CPdqPdh::GetCounterValue( ULONG index, BOOL bQuery )
{
    if( index < m_pdhCounters.dwNumElements ){
            if( bQuery && (Query() != ERROR_SUCCESS) ){
                return -1;
            }
            CollectData( index );
            return GetData( 0 );
    }
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trans\trans.c ===
/*  trans.c - transliterate one file into another
 *
 *  Modifications:
 *      30-Apr-1987 mz  Use fmove ()
 *      13-May-1987 mz  Check for buffer overflow
 *                      Use stderr for error output
 *      14-May-1987 bw  Fix stack overflow on fREMatch call
 *                      Make stdin/stdout O_BINARY when used
 *                      Use return message from fmove()
 *                      Send debug output to stderr
 *  01-Mar-1988 mz  Add parameter to RECompile for Z syntax
 *  15-Sep-1988 bw  fREMatch became REMatch
 *
 */
#include <malloc.h>

#include <stdio.h>
#include <fcntl.h>
#include <io.h>
#include <string.h>
#include <process.h>
#include <windows.h>
#include <tools.h>
#include <remi.h>

#define BUFFERSIZE  512
#define MAXRESTACK 1024

flagType fCase = FALSE;                 /* TRUE => case is significant */
flagType fTrans = FALSE;                /* TRUE => transform file */
flagType fDebug = FALSE;

// Forward Function Declarations...
void     usage( void );
void     fatal( char * );
flagType fDoTrans( FILE *, FILE *, char * );

extern flagType RETranslate( struct patType *, char *, char * );
extern int RETranslateLength( struct patType *, char * );

struct patType *pbuf;
RE_OPCODE * REStack[MAXRESTACK];

void usage ()
{
    fatal ("Usage: trans [/c] [/t] [files]\n");
}

void fatal( p1 )
char *p1;
{
    fprintf (stderr, p1 );
    exit (1);
}

flagType fDoTrans (fhin, fhout, rbuf)
FILE *fhin, *fhout;
char *rbuf;
{
    flagType fChanged;
    static char buf[BUFFERSIZE], rpl[BUFFERSIZE];
    char * p, * np;
    int line = 0;

    fChanged = FALSE;
    if (fDebug)
        fprintf (stderr, "Replacement '%s'\n", rbuf);
    while (fgetl (buf, BUFFERSIZE, fhin) != 0) {
        line++;
        p = buf;
        if (fDebug)
            fprintf (stderr, "Input: '%s'\n", buf);
        while (!REMatch (pbuf, buf, p, REStack, MAXRESTACK, TRUE)) {
            fChanged = TRUE;
            if (fDebug)
                fprintf (stderr, " Match at %x length %x\n",
                        REStart (pbuf)-buf,
                        RELength (pbuf, 0));

            /*  Make sure translation will fit in temp buffers
             */
            if (RETranslateLength (pbuf, rbuf) >= BUFFERSIZE) {
                fprintf (stderr, "After translation, line %d too long", line);
                exit (1);
                }

            if (!RETranslate (pbuf, rbuf, rpl))
                fatal ("Invalid replacement pattern\n");

            if (fDebug)
                fprintf (stderr, " Replacement: '%s'\n", rpl);

            /*  Make sure body - match + translation still fits in buffer
             */
            if (strlen (buf) - RELength (pbuf, 0) + strlen (rpl) >= BUFFERSIZE) {
                fprintf (stderr, "After translation, line %d too long", line);
                exit (1);
                }

            np = (p = REStart (pbuf)) + strlen (rpl);
            strcat (rpl, p + RELength (pbuf, 0));
            strcpy (p, rpl);
            p = np;
            if (fDebug)
                fprintf (stderr, " Match start %x in '%s'\n", p-buf, buf);
            }
        if (!fTrans || p != buf) {
            if (fDebug)
                fprintf (stderr, " Outputting '%s'\n", buf);
            fputl (buf, strlen(buf), fhout);
            }
        }
    return fChanged;
}

__cdecl
main (
    int c,
    char *v[]
    )
{
    FILE *fhin, *fhout;
    char *p, *p1;
    flagType fChanged;

    ConvertAppToOem( c, v );
    if (c < 3)
        usage ();

    while (fSwitChr (*v[1])) {
        switch (v[1][1]) {
        case 'c':
            fCase = TRUE;
            break;
        case 'd':
            fDebug = TRUE;
            break;
        case 't':
            fTrans = TRUE;
            break;
        default:
            usage ();
            }
        SHIFT(c,v);
        }
    if ((pbuf = RECompile (v[1], fCase, TRUE)) == NULL)
        fatal ("Invalid pattern\n");
    p = v[2];
    if (c == 3) {
        _setmode(0, O_BINARY);
        _setmode(1, O_BINARY);
        fDoTrans (stdin, stdout, p);
    }
    else
        while (c != 3) {
            if ((fhin = fopen (v[3], "rb")) == NULL)
                fprintf (stderr, "trans: Cannot open %s - %s\n", v[3], error ());
            else
            if ((fhout = fopen ("trans$$$.$$$", "wb")) == NULL) {
                fprintf (stderr, "trans: Cannot create temp file - %s\n", error ());
                fclose (fhin);
                }
            else {
                printf ("%s ", v[3]);
                fChanged = fDoTrans (fhin, fhout, p);
                fclose (fhin);
                fclose (fhout);
                if (fChanged) {
                    if (p1 = fmove ("trans$$$.$$$", v[3]))
                        printf ("[%s]\n", p1);
                    else
                        printf ("[OK]\n");
                    }
                else {
                    _unlink ("trans$$$.$$$");
                    printf ("[No change]\n");
                    }
                }
            SHIFT(c,v);
            }
    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\trace\typeperf\typeperf.cpp ===
/*****************************************************************************\

    Author: Corey Morgan (coreym)

    Copyright (c) Microsoft Corporation. All rights reserved.

\*****************************************************************************/

#define WIN32_LEAN_AND_MEAN 1
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <conio.h>
#include <assert.h>
#include <tchar.h>
#include <ntverp.h>

#include "resource.h"
#include "pdqpdh.h"

#include "varg.c"

DWORD GetLogFormat( LPTSTR str, DWORD* pVal );
PDH_STATUS Query( LPTSTR strObjectQuery, BOOL bExpand );
void CounterErrorCallback( LPTSTR strCounter, PDH_STATUS pdhStatus );

#define ACTION_GROUP    1
#define QUERY_GROUP     2
#define COLLECT_GROUP   4

VARG_DECLARE_COMMANDS
    VARG_DEBUG( VARG_FLAG_OPTIONAL|VARG_FLAG_HIDDEN )
    VARG_HELP ( VARG_FLAG_OPTIONAL )
    VARG_MSZ  ( IDS_PARAM_COUNTERS, VARG_FLAG_NOFLAG, _T("") )
    VARG_STR  ( IDS_PARAM_FORMAT,   VARG_FLAG_OPTIONAL, _T("CRT") )
    VARG_STR  ( IDS_PARAM_INPUT,    VARG_FLAG_ARG_FILENAME, _T("") )
    VARG_TIME ( IDS_PARAM_INTERVAL, VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_TIME )
    VARG_STR  ( IDS_PARAM_OUTPUT,   VARG_FLAG_OPTIONAL|VARG_FLAG_ARG_FILENAME|VARG_FLAG_RCDEFAULT, IDS_DEFAULT_OUTPUT )
    VARG_STR  ( IDS_PARAM_QUERY,    VARG_FLAG_DEFAULTABLE, NULL )
    VARG_STR  ( IDS_PARAM_QUERYX,   VARG_FLAG_DEFAULTABLE, NULL )
    VARG_INT  ( IDS_PARAM_SAMPLES,  VARG_FLAG_OPTIONAL, 100 )
    VARG_INI  ( IDS_PARAM_SETTINGS, VARG_FLAG_OPTIONAL, NULL )
    VARG_STR  ( IDS_PARAM_SERVER,   VARG_FLAG_OPTIONAL, NULL )
    VARG_BOOL ( IDS_PARAM_YES,      VARG_FLAG_OPTIONAL, FALSE )
VARG_DECLARE_NAMES
    eDebug,
    eHelp,
    eCounters,
    eFormat,
    eInput,
    eInterval,
    eOutput,
    eQuery,
    eQueryX,
    eSamples,
    eSettings,
    eComputer,
    eYes,
VARG_DECLARE_FORMAT
    VARG_GROUP( eCounters,  VARG_COND(ACTION_GROUP) )
    VARG_GROUP( eInput,     VARG_COND(ACTION_GROUP) )
    VARG_GROUP( eQuery,     VARG_COND(ACTION_GROUP) )
    VARG_GROUP( eQueryX,    VARG_COND(ACTION_GROUP) )
    VARG_GROUP( eQuery,     VARG_GRPX(QUERY_GROUP, COLLECT_GROUP ) )
    VARG_GROUP( eQueryX,    VARG_GRPX(QUERY_GROUP, COLLECT_GROUP ) )
    VARG_GROUP( eQuery,     VARG_GRPX(QUERY_GROUP, QUERY_GROUP ) )
    VARG_GROUP( eQueryX,    VARG_GRPX(QUERY_GROUP, QUERY_GROUP ) )
    VARG_GROUP( eInput,     VARG_GRPX(COLLECT_GROUP, QUERY_GROUP ) )
    VARG_GROUP( eFormat,    VARG_GRPX(COLLECT_GROUP, QUERY_GROUP ) )
    VARG_GROUP( eInterval,  VARG_GRPX(COLLECT_GROUP, QUERY_GROUP ) )
    VARG_GROUP( eSamples,   VARG_GRPX(COLLECT_GROUP, QUERY_GROUP ) )
    VARG_GROUP( eCounters,  VARG_GRPX(COLLECT_GROUP, QUERY_GROUP ) )
    VARG_EXHELP( eCounters, IDS_EXAMPLE_COUNTERS )
    VARG_EXHELP( eQueryX,   IDS_EXAMPLE_QUERYALL )
    VARG_EXHELP( eFormat,   IDS_EXAMPLE_FORMAT   )
VARG_DECLARE_END    

#define LOG_TYPE_CRT    (-1)
#define LOG_TYPE_W2K    (3)
#define WINDOWS_2000    (2195)

#define TERROR_BAD_FORMAT  0xF0000001
#define TERROR_NO_COUNTERS 0xF0000002

CPdqPdh* g_pdh = NULL;
HANDLE   g_hExit = NULL;
LONG     g_bExit = FALSE;

#define CHECK_HR(hr)  if(ERROR_SUCCESS != hr){goto cleanup;}
#define CHECK_EXIT( b ) if( b ){ goto cleanup;}

BOOL __stdcall leave( DWORD /*dwType*/ )
{
    InterlockedExchange( &g_bExit, TRUE );
    if( g_hExit != NULL ){
        SetEvent( g_hExit );
    }

    return TRUE;
}

int __cdecl _tmain( int argc, LPTSTR* argv )
{
    DWORD      dwStatus  = ERROR_SUCCESS;
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    BOOL    bResult;
    ULONG   nSeconds = 1;
    DWORD   dwFormat;

    g_hExit = CreateEvent( NULL, FALSE, FALSE, NULL );

    SetConsoleCtrlHandler( leave, TRUE );

    ParseCmd( argc, argv );

    CHECK_EXIT( g_bExit );
    if( Commands[eQuery].bDefined || Commands[eQueryX].bDefined){
        if( Commands[eOutput].bDefined && !Commands[eYes].bValue ){
            dwStatus = CheckFile( Commands[eOutput].strValue, VARG_CF_PROMPT|VARG_CF_OVERWRITE );
            CHECK_HR(dwStatus);
        }

        if( Commands[eQuery].bDefined ){
            pdhStatus = Query( Commands[eQuery].strValue, FALSE );
        }else{
            pdhStatus = Query( Commands[eQueryX].strValue, TRUE );
        }
        goto cleanup;
    }

    OSVERSIONINFO VersionInfo;
    
    VersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    bResult = GetVersionEx( &VersionInfo );

    if( ! bResult ){
        ZeroMemory( &VersionInfo, sizeof( OSVERSIONINFO ) );
    }
    
    if( Commands[eInterval].bDefined ){
        nSeconds = Commands[eInterval].stValue.wSecond;
        nSeconds += (Commands[eInterval].stValue.wMinute * 60);
        nSeconds += (Commands[eInterval].stValue.wHour * 3600);
    }
    __try {

        CHECK_EXIT( g_bExit );
        g_pdh = new CPdqPdh;

        if( g_pdh == NULL ){
            dwStatus = ERROR_OUTOFMEMORY;
            goto cleanup;
        }

        g_pdh->Initialize( (INT*)&g_bExit );

        CHECK_EXIT( g_bExit );

        if( Commands[eOutput].bDefined && !Commands[eFormat].bDefined ){
            dwFormat = PDH_LOG_TYPE_CSV;
        }else{
            dwStatus = GetLogFormat( Commands[eFormat].strValue, &dwFormat );
            CHECK_HR(dwStatus);
        }

        switch( dwFormat ){
        case PDH_LOG_TYPE_CSV:
        case PDH_LOG_TYPE_TSV:
        case LOG_TYPE_CRT:
            g_pdh->SetExpand(TRUE);
            break;
        default:
            g_pdh->SetExpand(FALSE);
        }

        if( Commands[eCounters].bDefined ){
    
            LPTSTR strCounter;

            strCounter = Commands[eCounters].strValue;
            if( strCounter != NULL ){
                while( *strCounter != _T('\0') ){
                    CHECK_EXIT( g_bExit );
                    pdhStatus = g_pdh->AddCounter( strCounter, Commands[eComputer].strValue, CounterErrorCallback );
                    if( pdhStatus != ERROR_SUCCESS ){
                        PrintMessage( g_debug, IDS_MESSAGE_BADCOUNTER, strCounter, pdhStatus );
                        pdhStatus = ERROR_SUCCESS;
                    }
                    strCounter += (_tcslen( strCounter ) + 1);
                }
            }
        }

        if( Commands[eInput].bDefined ){
            CHECK_EXIT( g_bExit );
            dwStatus = g_pdh->GetCountersFromFile(
                    Commands[eInput].strValue, 
                    Commands[eComputer].strValue,
                    CounterErrorCallback );
            CHECK_EXIT( g_bExit );
        }
        
        varg_printf( g_normal, _T("\n") );

        if( Commands[eDebug].bDefined ){
            g_pdh->Query();
            for( ULONG nCounter = 0; nCounter < g_pdh->GetCounterCount(); nCounter++ ){
                CHECK_EXIT( g_bExit );
                pdhStatus = g_pdh->CollectData( nCounter );
                for( int err = 0; err<10 && pdhStatus != ERROR_SUCCESS; err++ ){
                    _sleep(10);
                    pdhStatus = g_pdh->CollectData( nCounter );
                }
                if( ERROR_SUCCESS != pdhStatus ){
                    varg_printf( g_debug, _T("<%1!4d!> %2!s!\n"), nCounter+1, g_pdh->GetDataName(PDQ_BASE_NAME) );
                    if( Commands[eDebug].nValue > 0 ){
                        PrintErrorEx( pdhStatus, _T("PDH.DLL") );
                    }
                    pdhStatus = ERROR_SUCCESS;
                }else{
                    varg_printf( g_debug, _T("[%1!4d!] %2!s!\n"), nCounter+1, g_pdh->GetDataName(PDQ_BASE_NAME) );
                    if( Commands[eDebug].nValue > 1 && g_pdh->GetDataCount() > 1 ){
                        for( ULONG i=0; i < g_pdh->GetDataCount();i++){
                            CHECK_EXIT( g_bExit );
                            varg_printf( g_debug, _T("  ->   %1!s!\n"), g_pdh->GetDataName(i) );
                        }
                    }
                }
            }
            varg_printf( g_normal, _T("\n") );
        }

        if( g_pdh->GetCounterCount() == 0){
            dwStatus = TERROR_NO_COUNTERS;
            goto cleanup;
        }

        if( dwFormat == LOG_TYPE_CRT ){
            TCHAR buffer[256];
            SYSTEMTIME stSampleTime;
            DWORD dwWait;
            varg_printf( g_normal, _T("%1!s!"), PDQ_PDH_CSV_HEADER );
            g_pdh->Query();
            for( ULONG nCounter = 0; nCounter < g_pdh->GetCounterCount(); nCounter++ ){
                pdhStatus = g_pdh->CollectData( nCounter );
                if( ERROR_SUCCESS == pdhStatus ){
                    for( ULONG i=0; i < g_pdh->GetDataCount();i++){
                        varg_printf( g_normal, _T(",\"%1!s!\""), g_pdh->GetDataName(i) );
                    }
                }
            }
            ULONG nSamples = 0;
            while( !g_bExit ){

                nSamples++;
                dwWait = WaitForSingleObject( g_hExit, nSeconds*1000 );
                if( dwWait != WAIT_TIMEOUT ){
                    break;
                }

                GetLocalTime (&stSampleTime);
                varg_printf( g_normal, _T("\n\"%1!2.2d!/%2!2.2d!/%3!4.4d! %4!2.2d!:%5!2.2d!:%6!2.2d!.%7!3.3d!\""),
                        stSampleTime.wMonth, stSampleTime.wDay, stSampleTime.wYear,
                        stSampleTime.wHour, stSampleTime.wMinute, stSampleTime.wSecond,
                        stSampleTime.wMilliseconds
                    );
        
                g_pdh->Query();
                for( ULONG nCounter = 0; nCounter < g_pdh->GetCounterCount(); nCounter++ ){
                    pdhStatus = g_pdh->CollectData( nCounter );
                    if( ERROR_SUCCESS == pdhStatus ){
                        for( ULONG i=0; i < g_pdh->GetDataCount();i++){
                            _stprintf( buffer, _T("%f"), g_pdh->GetData( i ) );
                            varg_printf( g_normal, _T(",\"%1!s!\""), buffer );
                        }
                    }else{
                        varg_printf( g_normal, _T(",\"%1!d!\""), PDQ_BAD_VALUE );
                    }
                }

                if( Commands[eSamples].bDefined && nSamples >= Commands[eSamples].nValue ){
                    break;
                }
            }
            varg_printf( g_normal, _T("\n") );
    
        }else{
            TCHAR buffer[MAXSTR];
            TCHAR drive[_MAX_DRIVE];
            TCHAR path[MAXSTR];
            TCHAR file[_MAX_FNAME];
            TCHAR ext[_MAX_EXT];
    
            _tsplitpath( Commands[eOutput].strValue, drive, path, file, ext );
            if( 0 == _tcslen( ext ) ){
                switch( dwFormat ){
                case PDH_LOG_TYPE_TSV: _tcscpy( ext, _T("tsv") ); break;
                case PDH_LOG_TYPE_CSV: _tcscpy( ext, _T("csv") ); break;
                case PDH_LOG_TYPE_SQL: break;
                case PDH_LOG_TYPE_BINARY: 
                    _tcscpy( ext, _T("blg") ); break;
                }
            }
            _tmakepath( buffer, drive, path, file, ext );
         
            if( VersionInfo.dwBuildNumber <= WINDOWS_2000 && dwFormat == PDH_LOG_TYPE_BINARY ){
                dwFormat = LOG_TYPE_W2K;
            }

            if( Commands[eOutput].bDefined && !Commands[eYes].bValue && dwFormat != PDH_LOG_TYPE_SQL ){
                dwStatus = CheckFile( buffer, VARG_CF_PROMPT|VARG_CF_OVERWRITE );
                CHECK_HR(dwStatus);
            }

            pdhStatus = g_pdh->LogCreate( buffer, dwFormat );
    
            if( ERROR_SUCCESS == pdhStatus ){

                if( Commands[eSamples].bDefined ){
                    g_pdh->LogStart( nSeconds * 1000, Commands[eSamples].nValue );
                }else{
                    g_pdh->LogStart( nSeconds * 1000 );
                }

                int loop = 0;
                TCHAR *spin = _T("|/-\\");
                DWORD dwWait;
                while( !g_bExit ){
                    _tprintf( _T("\r[%c]"), spin[loop++ % 4] );
                    dwWait = WaitForSingleObject( g_hExit, 500 );
                    if( dwWait != WAIT_TIMEOUT || g_pdh->GetState() != PDQ_STATE_LOGGING ){
                        break;
                    }
                }
            }
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        dwStatus = GetLastError();
    }
  

cleanup:    

    _tprintf( _T("\r") );
    PrintMessage( g_normal, IDS_MESSAGE_EXIT );
    _tprintf( _T("\r") );

    if( g_pdh ){
        delete g_pdh;
    }
    
    PrintMessage( g_normal, IDS_MESSAGE_CEXIT );

    switch( dwStatus ){
    case TERROR_NO_COUNTERS:
        PrintMessage( g_debug, IDS_MESSAGE_NOCOUNTERS );
        break;
    case TERROR_BAD_FORMAT:
        PrintMessage( g_debug, IDS_MESSAGE_BADFORMAT, Commands[eFormat].strValue );
        break;
    case ERROR_SUCCESS:
        if( ERROR_SUCCESS == pdhStatus ){
            PrintMessage( g_normal, IDS_MESSAGE_SUCCESS );
        }else{
            PrintErrorEx( pdhStatus, _T("PDH.DLL") );
            dwStatus = pdhStatus;
        }
        break;
    default:
        PrintError( dwStatus );
    }

    FreeCmd();

    return dwStatus;
}

void CounterErrorCallback( LPTSTR strCounter, PDH_STATUS pdhStatus )
{
    PrintMessage( g_debug, IDS_MESSAGE_BADCOUNTER, strCounter, pdhStatus );
}

DWORD
GetLogFormat( LPTSTR str, DWORD* pVal )
{
    if( str != NULL ){
        if( !_tcsicmp( str, _T("TSV")) ){
            *pVal = PDH_LOG_TYPE_TSV;
            return ERROR_SUCCESS;
        }else if( !_tcsicmp( str, _T("CSV")) ){
            *pVal = PDH_LOG_TYPE_CSV;
            return ERROR_SUCCESS;
        }else if( !_tcsicmp( str, _T("SQL")) ){
            *pVal = PDH_LOG_TYPE_SQL;
            return ERROR_SUCCESS;
        }else if( !_tcsicmp( str, _T("CRT")) ){
            *pVal = LOG_TYPE_CRT;
            return ERROR_SUCCESS;
        }else if( !_tcsicmp( str, _T("BIN")) ){
            *pVal = PDH_LOG_TYPE_BINARY;
            return ERROR_SUCCESS;
        }else if( !_tcsicmp( str, _T("BLG")) ){
            *pVal = PDH_LOG_TYPE_BINARY;
            return ERROR_SUCCESS;
        }
    }

    return TERROR_BAD_FORMAT;
}

PDH_STATUS 
Query( LPTSTR strRequest, BOOL bExpand )
{
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    
    LPTSTR strObjectQuery = NULL;
    LPTSTR strMachine = NULL;

    LPTSTR mszObjects = NULL;
    LPTSTR strObject = NULL;
    DWORD  dwObjects = 0;
    
    if( strRequest != NULL ){
        TCHAR buffer[MAXSTR];

        _tcscpy( buffer, strRequest );

        if( buffer[0] == _T('\\') && buffer[1] == _T('\\') ){
            strMachine = _tcstok( buffer, _T("\\\n") );
            strObjectQuery = _tcstok( NULL, _T("\n") );
        }else{
            strMachine = Commands[eComputer].strValue;
            if( strMachine != NULL){
                while( strMachine[0] == _T('\\') ) strMachine++;
            }
            strObjectQuery = _tcstok( buffer, _T("\\\n") );
        }
    }else{
        strMachine = Commands[eComputer].strValue;
    }
    
    FILE* f = NULL;
    if( Commands[eOutput].bDefined ){
        f = _tfopen( Commands[eOutput].strValue, _T("w") );
    }else{
        f = stdout;
    }

    if( NULL == f ){
        DWORD dwStatus = GetLastError();
        pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
        goto cleanup;
    }

    if( strObjectQuery == NULL ){
        pdhStatus = PdhEnumObjects( 
                NULL, 
                strMachine, 
                mszObjects, 
                &dwObjects, 
                PERF_DETAIL_WIZARD, 
                FALSE 
            );
    }

    if( pdhStatus == ERROR_SUCCESS || PDQ_MORE_DATA(pdhStatus) ){

        if( strObjectQuery == NULL ){
            mszObjects = (LPTSTR)VARG_ALLOC( dwObjects * sizeof(TCHAR) );
        
            if( mszObjects == NULL ){
                if( Commands[eOutput].bDefined ){
                    fclose(f);
                }
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            pdhStatus = PdhEnumObjects( 
                        NULL, 
                        strMachine, 
                        mszObjects, 
                        &dwObjects, 
                        PERF_DETAIL_WIZARD, 
                        FALSE 
                    );
            strObject = mszObjects;
        }else{
            strObject = strObjectQuery;
        }

        while( NULL != strObject && strObject[0] != _T('\0') ){

            LPTSTR mszCounters = NULL;
            LPTSTR strCounter = NULL;
            LPTSTR mszInstances = NULL;
            LPTSTR strInstance = NULL;
            DWORD  dwCounters = 0;
            DWORD  dwInstances = 0;

            CHECK_EXIT( g_bExit );

            pdhStatus = PdhEnumObjectItems( 
                        NULL, 
                        strMachine, 
                        strObject, 
                        mszCounters, 
                        &dwCounters, 
                        mszInstances, 
                        &dwInstances, 
                        PERF_DETAIL_WIZARD, 
                        0 
                    );

            if( ERROR_SUCCESS == pdhStatus || PDQ_MORE_DATA(pdhStatus) ){
                mszCounters = (LPTSTR)VARG_ALLOC( dwCounters * sizeof(TCHAR) );
                mszInstances = (LPTSTR)VARG_ALLOC( dwInstances * sizeof(TCHAR) );   

                if( mszCounters == NULL || mszInstances == NULL ){
                    VARG_FREE( mszObjects );
                    VARG_FREE( mszCounters );
                    VARG_FREE( mszInstances );
                    if( Commands[eOutput].bDefined ){
                        fclose(f);
                    }
                    return ERROR_NOT_ENOUGH_MEMORY;
                }
                
                pdhStatus = PdhEnumObjectItems( 
                            NULL, 
                            strMachine, 
                            strObject, 
                            mszCounters, 
                            &dwCounters, 
                            mszInstances,
                            &dwInstances, 
                            PERF_DETAIL_WIZARD, 
                            0 
                        );

                if( ERROR_SUCCESS == pdhStatus ){
                    strCounter = mszCounters;
                    while( NULL != strCounter && strCounter[0] != _T('\0') ){
                        strInstance = mszInstances;
                        CHECK_EXIT( g_bExit );
                        
                        if( dwInstances > 0 && _tcslen( strInstance ) ){
                            if( bExpand == FALSE ){
                                if( strMachine != NULL ){
                                    _ftprintf( f, _T("\\\\%s"), strMachine );
                                }
                                _ftprintf( f, _T("\\%s(*)\\%s\n"), strObject, strCounter );
                            }else{
                                LPTSTR strLastInstance = NULL;
                                ULONG nInstance = 0;
                                while( NULL != strInstance && strInstance[0] != _T('\0') ){
                                    CHECK_EXIT( g_bExit );
                                    if( strMachine != NULL ){
                                        _ftprintf( f, _T("\\\\%s"), strMachine );
                                    }
                                    if( strLastInstance == NULL || _tcscmp( strLastInstance, strInstance ) ){
                                        _ftprintf( f, _T("\\%s(%s)\\%s\n"), strObject, strInstance, strCounter );
                                        nInstance = 0;
                                    }else{
                                        _ftprintf( f, _T("\\%s(%s#%d)\\%s\n"), strObject, strInstance, ++nInstance, strCounter );
                                    }
                                    strLastInstance = strInstance;
                                    strInstance += _tcslen( strInstance ) + 1;
                                }
                            }

                        }else{
                            if( strMachine != NULL ){
                                _ftprintf( f, _T("\\\\%s"), strMachine );
                            }
                            _ftprintf( f, _T("\\%s\\%s\n"), strObject, strCounter );
                        }

                        
                        strCounter += _tcslen( strCounter ) + 1;
                    }
                }

                VARG_FREE( mszCounters );
                VARG_FREE( mszInstances );

            }

            if( strObjectQuery == NULL ){
                strObject += _tcslen( strObject ) + 1;
            }else{
                strObject = NULL;
            }
        }

        VARG_FREE( mszObjects );
    }
    
cleanup:

    if( Commands[eOutput].bDefined && NULL != f ){
        fclose(f);
    }

    return pdhStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tweakui\addrm.cpp ===
/*
 * addrm - Dialog box property sheet for "Add/Remove"
 */

#include "tweakui.h"

#pragma BEGIN_CONST_DATA

const static DWORD CODESEG rgdwHelp[] = {
        IDC_UNINSTALL,          IDH_UNINSTALL,
        IDC_UNINSTALLTEXT,      IDH_UNINSTALL,
        IDC_UNINSTALLNEW,       IDH_UNINSTALLNEW,
        IDC_LVDELETE,           IDH_UNINSTALLDELETE,
        IDC_UNINSTALLEDIT,      IDH_UNINSTALLEDIT,
        0,                      0,
};

#pragma END_CONST_DATA


typedef unsigned char ARIFL;            /* Random flags */
#define ariflDelPending 2       /* Delete this on apply */
#define ariflEdited 4           /* Rewrite this key */

#define ctchKeyMac  63          /* Maximum length supported by shell32 */

typedef struct ARI {            /* ari - add/remove info */
    ARIFL arifl;
    TCH tszKey[MAX_PATH];
    TCH tszCmd[MAX_PATH];
} ARI, *PARI;

#define iariPlvi(plvi) ((UINT)(plvi)->lParam)
#define pariIari(iari) (&padii->pari[iari])
#define pariPlvi(plvi) pariIari(iariPlvi(plvi))

typedef struct ADII {
    BOOL fDamaged;
    Declare_Gxa(ARI, ari);
} ADII;

ADII adii;
#define padii (&adii)

/*****************************************************************************
 *
 *  AddRm_AddKey
 *
 *  Add an add/remove entry.  We use a listview control instead of a listbox,
 *  because we need to be able to process right-clicks in order to display a
 *  context menu.
 *
 *  Returns the resulting item number.
 *
 *****************************************************************************/

int PASCAL
AddRm_AddKey(HWND hwnd, LPCTSTR ptszDesc)
{
    return LV_AddItem(hwnd, padii->cari++, ptszDesc, -1, -1);
}

/*****************************************************************************
 *
 *  AddRm_OnInitDialog
 *
 *  Create and fill the Add/Remove list box.
 *
 *****************************************************************************/

BOOL PASCAL
AddRm_OnInitDialog(HWND hwnd)
{
    padii->fDamaged = FALSE;

    if (Misc_InitPgxa(&padii->gxa, cbX(ARI))) {
        HKEY hk;
        if (_RegOpenKey(g_hkLMSMWCV, c_tszUninstall, &hk) == 0) {
            int ihk;
            PARI pari;
            for (ihk = 0;
                 (pari = (PARI)Misc_AllocPx(&padii->gxa)) &&
                 (RegEnumKey(hk, ihk, pari->tszKey, cbX(pari->tszKey)) == 0);
                 ihk++) {

                if (pari->tszKey[0]) {          /* Don't want default key */
                    TCH tszDesc[MAX_PATH];
                    if (GetRegStr(hk, pari->tszKey, c_tszDisplayName,
                                  tszDesc, cbX(tszDesc)) &&
                        GetRegStr(hk, pari->tszKey, c_tszUninstallString,
                                  pari->tszCmd, cbX(pari->tszCmd))) {
                        pari->arifl = 0;
                        AddRm_AddKey(hwnd, tszDesc);
                        if (lstrlen(pari->tszKey) > ctchKeyMac) {
                            padii->fDamaged = TRUE;
                        }
                    }
                }
            }
            RegCloseKey(hk);
        }
        return 1;
    } else {
        return 0;
    }
}

/*****************************************************************************
 *
 *  AddRm_Dirtify
 *
 *      Mark an entry as dirty.  Used when somebody does an in-place edit
 *      of an entry.
 *
 *****************************************************************************/

void PASCAL
AddRm_Dirtify(LPARAM iari)
{
    pariIari(iari)->arifl |= ariflEdited;
}

/*****************************************************************************
 *
 *      DIGRESSION
 *
 *  The Edit dialog box.
 *
 *****************************************************************************/

typedef struct AREI {           /* Add/Remove Edit Info */
    HWND hwnd;                  /* List view */
    int iItem;                  /* Item number being edited (-1 if add) */
} AREI, *PAREI;

/*****************************************************************************
 *
 *  AddRm_Edit_IsDlgItemPresent
 *
 *  Leading and trailing spaces are ignored.
 *
 *****************************************************************************/

BOOL PASCAL
AddRm_Edit_IsDlgItemPresent(HWND hdlg, int id)
{
    TCH tsz[MAX_PATH];
    GetDlgItemText(hdlg, id, tsz, cA(tsz));
    return Misc_Trim(tsz)[0];
}

/*****************************************************************************
 *
 *  AddRm_Edit_OnCommand_OnEditChange
 *
 *      Enable/disable the OK button based on whether the texts are present.
 *
 *****************************************************************************/

void PASCAL
AddRm_Edit_OnCommand_OnEditChange(HWND hdlg)
{
    EnableDlgItem(hdlg, IDOK,
                    AddRm_Edit_IsDlgItemPresent(hdlg, IDC_UNINSTALLDESC) &&
                    AddRm_Edit_IsDlgItemPresent(hdlg, IDC_UNINSTALLCMD));
}

/*****************************************************************************
 *
 *  AddRm_Edit_OnInitDialog
 *
 *      Fill in the fields with stuff.
 *
 *****************************************************************************/

void PASCAL
AddRm_Edit_OnInitDialog(HWND hdlg, PAREI parei)
{
    SetWindowLongPtr(hdlg, DWLP_USER, (LPARAM)parei);
    if (parei->iItem != -1) {
        LV_ITEM lvi;
        TCH tszDesc[MAX_PATH];
        lvi.pszText = tszDesc;
        lvi.cchTextMax = cA(tszDesc);
        Misc_LV_GetItemInfo(parei->hwnd, &lvi, parei->iItem,
                            LVIF_PARAM | LVIF_TEXT);

        SetDlgItemTextLimit(hdlg, IDC_UNINSTALLDESC, lvi.pszText, MAX_PATH);
        SetDlgItemTextLimit(hdlg, IDC_UNINSTALLCMD,
                                       pariPlvi(&lvi)->tszCmd,
                                       cA(pariPlvi(&lvi)->tszCmd));
    }
    AddRm_Edit_OnCommand_OnEditChange(hdlg);
}

/*****************************************************************************
 *
 *  AddRm_Edit_OnOk
 *
 *      Save the information back out.
 *
 *****************************************************************************/

void PASCAL
AddRm_Edit_OnOk(HWND hdlg)
{
    PAREI parei = (PAREI)GetWindowLongPtr(hdlg, DWLP_USER);
    LV_ITEM lvi;
    TCH tszDesc[MAX_PATH];
    /*
     *  Need to get the description early, so that the new entry sorts
     *  into the right place.
     */
    lvi.pszText = tszDesc;
    GetDlgItemText(hdlg, IDC_UNINSTALLDESC, lvi.pszText, cA(tszDesc));

    if (parei->iItem == -1) {
        PARI pari = (PARI)Misc_AllocPx(&padii->gxa);
        if (pari) {
            pari->arifl = 0;
            pari->tszKey[0] = TEXT('\0');
            parei->iItem = AddRm_AddKey(parei->hwnd, lvi.pszText);
            Misc_LV_SetCurSel(parei->hwnd, parei->iItem);
        } else {
            goto failed;
        }
    }
    lvi.iItem = parei->iItem;
    Misc_LV_GetItemInfo(parei->hwnd, &lvi, parei->iItem, LVIF_PARAM);

    pariPlvi(&lvi)->arifl |= ariflEdited;

    GetDlgItemText(hdlg, IDC_UNINSTALLCMD,
                   pariPlvi(&lvi)->tszCmd, cA(pariPlvi(&lvi)->tszCmd));

    lvi.mask ^= LVIF_TEXT ^ LVIF_PARAM;
    ListView_SetItem(parei->hwnd, &lvi);

    Common_SetDirty(GetParent(parei->hwnd));

    failed:;
}

/*****************************************************************************
 *
 *  AddRm_Edit_OnCommand
 *
 *****************************************************************************/

void PASCAL
AddRm_Edit_OnCommand(HWND hdlg, int id, UINT codeNotify)
{
    switch (id) {
    case IDCANCEL:
        EndDialog(hdlg, 0); break;

    case IDOK:
        AddRm_Edit_OnOk(hdlg);
        EndDialog(hdlg, 0);
        break;

    case IDC_UNINSTALLDESC:
    case IDC_UNINSTALLCMD:
        if (codeNotify == EN_CHANGE) AddRm_Edit_OnCommand_OnEditChange(hdlg);
        break;
    }
}

/*****************************************************************************
 *
 *  AddRm_Edit_DlgProc
 *
 *      Dialog procedure.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA
const static DWORD CODESEG rgdwHelpEdit[] = {
        IDC_UNINSTALLDESCTEXT,  IDH_UNINSTALLEDITDESC,
        IDC_UNINSTALLCMDTEXT,   IDH_UNINSTALLEDITCOMMAND,
        0,                      0,
};
#pragma END_CONST_DATA

/*
 * The HANDLE_WM_* macros weren't designed to be used from a dialog
 * proc, so we need to handle the messages manually.  (But carefully.)
 */

INT_PTR EXPORT
AddRm_Edit_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    switch (wm) {
    case WM_INITDIALOG: AddRm_Edit_OnInitDialog(hdlg, (PAREI)lParam); break;

    case WM_COMMAND:
        AddRm_Edit_OnCommand(hdlg,
                                (int)GET_WM_COMMAND_ID(wParam, lParam),
                                (UINT)GET_WM_COMMAND_CMD(wParam, lParam));
        break;

    case WM_CONTEXTMENU: Common_OnContextMenu(wParam, &rgdwHelpEdit[0]); break;

    default: return 0;  /* Unhandled */
    }
    return 1;           /* Handled */
}


/*****************************************************************************
 *
 *      END DIGRESSION
 *
 *****************************************************************************/


/*****************************************************************************
 *
 *  AddRm_OnEdit
 *
 *****************************************************************************/

void PASCAL
AddRm_OnEdit(HWND hwnd, int iItem)
{
    AREI arei = { hwnd, iItem };
    DialogBoxParam(hinstCur, MAKEINTRESOURCE(IDD_UNINSTALLEDIT), hwnd,
                          AddRm_Edit_DlgProc, (LPARAM)&arei);
}

/*****************************************************************************
 *
 *  AddRm_OnNew
 *
 *****************************************************************************/

#define AddRm_OnNew(hdlg) AddRm_OnEdit(GetDlgItem(hdlg, IDC_UNINSTALL), -1)

/*****************************************************************************
 *
 *  AddRm_OnDelete
 *
 *      Mark it for deletion, but don't actually nuke it until later.
 *
 *****************************************************************************/

void PASCAL
AddRm_OnDelete(HWND hwnd, int iItem)
{
    LV_ITEM lvi;
    TCH tszDesc[MAX_PATH];
    lvi.pszText = tszDesc;
    lvi.cchTextMax = cA(tszDesc);
    Misc_LV_GetItemInfo(hwnd, &lvi, iItem, LVIF_PARAM | LVIF_TEXT);
    if (MessageBoxId(GetParent(hwnd), IDS_ADDRMWARN, lvi.pszText,
                     MB_YESNO | MB_DEFBUTTON2) == IDYES) {
        pariPlvi(&lvi)->arifl |= ariflDelPending;
        ListView_DeleteItem(hwnd, iItem);
        Misc_LV_EnsureSel(hwnd, iItem);
        Common_SetDirty(GetParent(hwnd));
    }
}

/*****************************************************************************
 *
 *  AddRm_CreateUniqueKeyName
 *
 *  Find a name that doesn't yet exist.
 *
 *  Search numerically until something works, or a weird error occurs.
 *
#if 0
 *  To avoid O(n^2) behavior, we start with the number of keys.
#endif
 *
 *****************************************************************************/

BOOL PASCAL
AddRm_CreateUniqueKeyName(HKEY hkUninst, LPTSTR ptsz)
{
    BOOL fRc;
    int i;
    for (i = 0; ; i++) {
        LONG cb;
        wsprintf(ptsz, c_tszPercentU, i);
        cb = 0;
        switch (RegQueryValue(hkUninst, ptsz, 0, &cb)) {
        case ERROR_SUCCESS: break;
        case ERROR_FILE_NOT_FOUND: fRc = 1; goto done;
        default: fRc = 0; goto done;    /* Unknown error */
        }
    }
done:;
    return fRc;
}

/*****************************************************************************
 *
 *  AddRm_OnApply_DoDeletes
 *
 *      Delete the keys that are marked as "delete pending".
 *
 *      pari->tszKey[0] is TEXT('\0') if the key was never in the registry.
 *      (E.g., you "New" it, and then delete it.)
 *
 *****************************************************************************/

void PASCAL
AddRm_OnApply_DoDeletes(HKEY hkUninst)
{
    int iari;
    for (iari = 0; iari < padii->cari; iari++) {
        if (pariIari(iari)->arifl & ariflDelPending) {
            if (pariIari(iari)->tszKey[0]) {
                RegDeleteTree(hkUninst, pariIari(iari)->tszKey);
            }
        }
    }
}

/*****************************************************************************
 *
 *  AddRm_OnApply_DoEdits
 *
 *      Apply all the edits.
 *
 *****************************************************************************/

void PASCAL
AddRm_OnApply_DoEdits(HWND hdlg, HKEY hkUninst)
{
    HWND hwnd = GetDlgItem(hdlg, IDC_UNINSTALL);
    int cItems = ListView_GetItemCount(hwnd);
    LV_ITEM lvi;

    for (lvi.iItem = 0; lvi.iItem < cItems; lvi.iItem++) {
        TCH tsz[MAX_PATH];
        PARI pari;
        lvi.pszText = tsz;
        lvi.cchTextMax = cA(tsz);
        Misc_LV_GetItemInfo(hwnd, &lvi, lvi.iItem, LVIF_PARAM | LVIF_TEXT);
        pari = pariPlvi(&lvi);

        if (pari->arifl & ariflEdited) {
            HKEY hk;
            if (pari->tszKey[0] == TEXT('\0')) {
                if (AddRm_CreateUniqueKeyName(hkUninst, pari->tszKey)) {
                } else {
                    break;                      /* Error! */
                }
            }
            if (RegCreateKey(hkUninst, pari->tszKey, &hk) == 0) {
                RegSetValuePtsz(hk, c_tszDisplayName, tsz);
                RegSetValuePtsz(hk, c_tszUninstallString, pari->tszCmd);
                RegCloseKey(hk);
            }
        }
    }
}

/*****************************************************************************
 *
 *  AddRm_OnApply
 *
 *****************************************************************************/

void PASCAL
AddRm_OnApply(HWND hdlg)
{
    HKEY hkUninst;
    if (RegCreateKey(g_hkLMSMWCV, c_tszUninstall, &hkUninst) == 0) {
        AddRm_OnApply_DoDeletes(hkUninst);
        AddRm_OnApply_DoEdits(hdlg, hkUninst);
        RegCloseKey(hkUninst);
    }
}

/*****************************************************************************
 *
 *  AddRm_OnDestroy
 *
 *      Free the memory we allocated.
 *
 *****************************************************************************/

void PASCAL
AddRm_OnDestroy(HWND hdlg)
{
    Misc_FreePgxa(&padii->gxa);
}

/*****************************************************************************
 *
 *  AddRm_OnRepair
 *
 *  Take all the keys that are too long and shorten them.
 *
 *****************************************************************************/

void PASCAL
AddRm_OnRepair(HWND hdlg)
{
    if (padii->fDamaged &&
        MessageBoxId(hdlg, IDS_ASKREPAIRADDRM, g_tszName, MB_YESNO)) {
        HKEY hkUninst;

        if (RegCreateKey(g_hkLMSMWCV, c_tszUninstall, &hkUninst) == 0) {

            int iari;
            for (iari = 0; iari < padii->cari; iari++) {
                TCHAR tszNewKey[MAX_PATH];
                PARI pari = pariIari(iari);
                if (lstrlen(pari->tszKey) > ctchKeyMac &&
                    AddRm_CreateUniqueKeyName(hkUninst, tszNewKey) &&
                    Misc_RenameReg(hkUninst, 0, pari->tszKey, tszNewKey)) {
                    lstrcpy(pari->tszKey, tszNewKey);
                }
            }
            RegCloseKey(hkUninst);
        }
    }
    padii->fDamaged = FALSE;            /* Ask only once */
}

/*****************************************************************************
 *
 *  AddRm_OnCommand
 *
 *****************************************************************************/

void PASCAL
AddRm_OnCommand(HWND hdlg, int id, UINT codeNotify)
{
    switch (id) {
    case IDC_UNINSTALLNEW:
        if (codeNotify == BN_CLICKED) {
            AddRm_OnNew(hdlg);
        }
        break;

    case IDC_UNINSTALLCHECK:
        AddRm_OnRepair(hdlg);
        break;

    }
}

/*****************************************************************************
 *
 *  Oh yeah, we need this too.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

LVCI lvciAddRm[] = {
    { IDC_UNINSTALLEDIT,    AddRm_OnEdit },
    { IDC_LVDELETE,         AddRm_OnDelete },
    { 0,                    0 },
};

LVV lvvAddRm = {
    AddRm_OnCommand,
    0,                          /* AddRm_OnInitContextMenu */
    AddRm_Dirtify,
    0,                          /* AddRm_GetIcon */
    AddRm_OnInitDialog,
    AddRm_OnApply,
    AddRm_OnDestroy,
    0,                          /* AddRm_OnSelChange */
    2,                          /* iMenu */
    rgdwHelp,
    IDC_UNINSTALLEDIT,          /* Double-click action */
    lvvflCanDelete | lvvflCanRename,
    lvciAddRm,
};

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *  Our window procedure.
 *
 *****************************************************************************/

INT_PTR EXPORT
AddRm_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    switch (wm) {
    case WM_SHOWWINDOW:
        if (wParam) {
            FORWARD_WM_COMMAND(hdlg, IDC_UNINSTALLCHECK, 0, 0, PostMessage);
        }
        break;
    }

    return LV_DlgProc(&lvvAddRm, hdlg, wm, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tweakui\boot.cpp ===
/*
 * boot - Dialog box property sheet for "boot-time parameters"
 */

#include "tweakui.h"

#ifdef _X86_

#pragma BEGIN_CONST_DATA

#ifdef BOOTMENUDEFAULT
ConstString(c_tszNetwork,	"Network");
ConstString(c_tszBootMenuDefault, "BootMenuDefault");
#endif

typedef BYTE MSIOT;		/* msdos.sys ini option type */
#define msiotUint		0
#define msiotBool		1
#define msiotCombo		2

typedef const struct _MSIO {	/* msdos.sys ini option */
    const TCH CODESEG *ptszName;
    WORD id;			/* Dialog id */
    MSIOT msiot;		/* Data type */
    BYTE uiDefault;		/* The default value */
} MSIO;
typedef MSIO CODESEG *PMSIO;

MSIO CODESEG rgmsio[] = {
    { c_tszBootKeys,	 IDC_BOOTKEYS,		msiotBool,  1 },
    { c_tszBootDelay,	 IDC_BOOTDELAY, 	msiotUint,  2 },
    { c_tszBootGUI,	 IDC_BOOTGUI,		msiotBool,  1 },
    { c_tszBootMenu,	 IDC_BOOTMENU,		msiotBool,  0 },
    { c_tszBootMenuDelay,IDC_BOOTMENUDELAY,	msiotUint, 30 },
    { c_tszLogo,	 IDC_LOGO,		msiotBool,  1 },
    { c_tszBootMulti,	 IDC_BOOTMULTI, 	msiotBool,  0 },
    { c_tszAutoScan,	 IDC_SCANDISK,		msiotCombo, 1 },
};

#define pmsioMax (&rgmsio[cA(rgmsio)])

const static DWORD CODESEG rgdwHelp[] = {
	IDC_BOOTGROUP1,		IDH_GROUP,
	IDC_BOOTKEYS,		IDH_BOOTKEYS,
	IDC_BOOTDELAYTEXT,	IDH_BOOTKEYS,
	IDC_BOOTDELAY,		IDH_BOOTKEYS,
	IDC_BOOTDELAYUD,	IDH_BOOTKEYS,
	IDC_BOOTDELAYTEXT2,	IDH_BOOTKEYS,
	IDC_BOOTGUI,		IDH_BOOTGUI,
	IDC_LOGO,		IDH_LOGO,
	IDC_BOOTMULTI,		IDH_BOOTMULTI,

	IDC_BOOTMENUGROUP,	IDH_GROUP,
	IDC_BOOTMENU,		IDH_BOOTMENU,
	IDC_BOOTMENUDELAYTEXT,	IDH_BOOTMENUDELAY,
	IDC_BOOTMENUDELAY,	IDH_BOOTMENUDELAY,
	IDC_BOOTMENUDELAYUD,	IDH_BOOTMENUDELAY,
	IDC_BOOTMENUDELAYTEXT2,	IDH_BOOTMENUDELAY,
	IDC_SCANDISKTEXT,	IDH_AUTOSCAN,
	IDC_SCANDISK,		IDH_AUTOSCAN,
	IDC_RESET,		IDH_RESET,
	0,			0,
};

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *  Boot_fLogo
 *
 *	Nonzer if this machine should have the logo enabled by default.
 *
 *	The answer is yes, unless the display driver is xga.drv,
 *	because XGA cards aren't really VGA compatible, and the logo
 *	code uses VGA mode X.
 *
 *****************************************************************************/

BOOL PASCAL
Boot_fLogo(void)
{
    TCH tsz[12];

    return !(GetPrivateProfileString(c_tszBoot, c_tszDisplayDrv, c_tszNil,
				     tsz, cA(tsz), c_tszSysIni) &&
		lstrcmpi(tsz, c_tszXgaDrv) == 0);
}

/*****************************************************************************
 *
 *  Boot_GetOption
 *
 *****************************************************************************/

int PASCAL
Boot_GetOption(LPCTSTR ptszName, UINT uiDefault)
{
    return GetPrivateProfileInt(c_tszOptions, ptszName,
			        uiDefault, g_tszMsdosSys);
}

#ifdef BOOTMENUDEFAULT
/*****************************************************************************
 *
 *  Boot_GetDefaultBootMenuDefault
 *
 *	Get the default boot menu default.  This is 3 if no network,
 *	or 4 if network.
 *
 *****************************************************************************/

UINT PASCAL
Boot_GetDefaultBootMenuDefault(void)
{
    return 3 + Boot_GetOption(c_tszNetwork, 0);
}

/*****************************************************************************
 *
 *  Boot_GetBootMenuDefault
 *
 *	Get the boot menu default.
 *
 *****************************************************************************/

int PASCAL
Boot_GetBootMenuDefault(void)
{
    return Boot_GetOption(c_tszBootMenuDefault,
			  Boot_GetDefaultBootMenuDefault());
}
#endif

/*****************************************************************************
 *
 *  Boot_FindMsdosSys
 *
 *	Search the hard drives for the file X:\MSDOS.SYS.
 *
 *	There is no "Get boot drive" function in Win32, so this is the best
 *	I can do.
 *
 *	(MS-DOS function 3305h returns the boot drive.)
 *
 *****************************************************************************/

void PASCAL
Boot_FindMsdosSys(void)
{
    TCH tsz[2];			/* scratch */
    char szRoot[4];		/* Root directory thing */
    (*(LPDWORD)szRoot) = 0x005C3A40; /* @:\ */

    for (szRoot[0] = 'A'; szRoot[0] <= 'Z'; szRoot[0]++) {
	if (GetDriveTypeA(szRoot) == DRIVE_FIXED) {
	    DWORD fl;
	    if (GetVolumeInformation(szRoot, 0, 0, 0, 0, &fl, 0, 0) &&
		!(fl & FS_VOL_IS_COMPRESSED)) {
		g_tszMsdosSys[0] = (TCH)szRoot[0];
		if (GetPrivateProfileString(c_tszPaths, c_tszWinDir, 0,
					    tsz, cA(tsz), g_tszMsdosSys)) {
		    return;
		}
	    }
	}
    }
    g_tszMsdosSys[0] = TEXT('\0');
}

/*****************************************************************************
 *
 *  Boot_WriteOptionUint
 *
 *	Write an option unsigned integer to the msdos.sys file.
 *
 *****************************************************************************/

void PASCAL
Boot_WriteOptionUint(LPCTSTR ptszName, UINT ui, UINT uiDefault)
{
    if (GetPrivateProfileInt(c_tszOptions, ptszName,
			     uiDefault, g_tszMsdosSys) != ui) {
	TCH tsz[32];
	wsprintf(tsz, c_tszPercentU, ui);
	WritePrivateProfileString(c_tszOptions, ptszName, tsz, g_tszMsdosSys);
OutputDebugString(ptszName);
OutputDebugString(tsz);
    }
}

/*****************************************************************************
 *
 *  Boot_SetOptionBool
 *
 *	Propagate an option boolean to the msdos.sys file.
 *
 *****************************************************************************/

void PASCAL
Boot_SetOptionBool(HWND hdlg, PMSIO pmsio)
{
    Boot_WriteOptionUint(pmsio->ptszName, IsDlgButtonChecked(hdlg, pmsio->id),
			 pmsio->uiDefault);
}

/*****************************************************************************
 *
 *  Boot_SetOptionUint
 *
 *	Propagate an option unsigned integer to the msdos.sys file.
 *
 *****************************************************************************/

void PASCAL
Boot_SetOptionUint(HWND hdlg, PMSIO pmsio)
{
    UINT ui;
    BOOL f;

    ui = (int)GetDlgItemInt(hdlg, pmsio->id, &f, 0);
    if (f) {
        Boot_WriteOptionUint(pmsio->ptszName, ui, pmsio->uiDefault);
    }

}

/*****************************************************************************
 *
 *  Boot_SetOptionCombo
 *
 *	Propagate a combo option to the msdos.sys file.
 *
 *	Not propagating the value that is already there means that we don't
 *	set AutoScan if not running OPK2.
 *
 *****************************************************************************/

void PASCAL
Boot_SetOptionCombo(HWND hdlg, PMSIO pmsio)
{
    Boot_WriteOptionUint(pmsio->ptszName,
			 SendDlgItemMessage(hdlg, pmsio->id,
					    CB_GETCURSEL, 0, 0),
			 pmsio->uiDefault);
}


/*****************************************************************************
 *
 *  Boot_FlushIniCache
 *
 *  Make sure all changes are committed to disk.
 *
 *****************************************************************************/

INLINE void
Boot_FlushIniCache(void)
{
    WritePrivateProfileString(0, 0, 0, g_tszMsdosSys);
}

/*****************************************************************************
 *
 *  Boot_Apply
 *
 *	Write the changes to the msdos.sys file.
 *
 *****************************************************************************/

BOOL PASCAL
Boot_Apply(HWND hdlg)
{
    DWORD dwAttr = GetFileAttributes(g_tszMsdosSys);
    if (dwAttr != 0xFFFFFFFF &&
	SetFileAttributes(g_tszMsdosSys, FILE_ATTRIBUTE_NORMAL)) {
	PMSIO pmsio;
	for (pmsio = rgmsio; pmsio < pmsioMax; pmsio++) {
            HWND hwnd = GetDlgItem(hdlg, pmsio->id);
            if (hwnd) {
                switch (pmsio->msiot) {
                case msiotUint:
                    Boot_SetOptionUint(hdlg, pmsio);
                    break;

                case msiotBool:
                    Boot_SetOptionBool(hdlg, pmsio);
                    break;

                case msiotCombo:
                    Boot_SetOptionCombo(hdlg, pmsio);
                    break;
                }
            }
	}
#ifdef BOOTMENUDEFAULT
	Boot_WriteOptionUint(c_tszBootMenuDefault,
	    (UINT)SendDlgItemMessage(hdlg, IDC_BOOTMENUDEFAULT, CB_GETCURSEL,
				     0, 0L) + 1);
#endif
	Boot_FlushIniCache();
	SetFileAttributes(g_tszMsdosSys, dwAttr);
    } else {
	MessageBoxId(hdlg, IDS_ERRMSDOSSYS, g_tszName, MB_OK);
    }
    return 1;
}

/*****************************************************************************
 *
 *  Boot_OnBootKeysChange
 *
 *	When IDC_BOOTKEYS changes, enable or disable the boot delay,
 *	BootMulti, and BootMenu.
 *
 *      NOTE:  BootKeys is meaningless if BootMenu is on -- if you
 *      have the BootMenu enabled, then the menu just comes up even without
 *      pressing a key.  Fortunately, nobody yet has complained about the
 *      interaction so I'm not gonna try to expose it in the UI.
 *
 *****************************************************************************/

void PASCAL
Boot_OnBootKeysChange(HWND hdlg)
{
    BOOL f = IsDlgButtonChecked(hdlg, IDC_BOOTKEYS);
    HWND hwnd;

    hwnd = GetDlgItem(hdlg, IDC_BOOTDELAY);
    if (hwnd) {
        EnableWindow(hwnd, f);
    }
    EnableDlgItem(hdlg, IDC_BOOTMULTI, f);
    EnableDlgItem(hdlg, IDC_BOOTMENU, f);
    EnableDlgItem(hdlg, IDC_BOOTMENUDELAY, f);
}

/*****************************************************************************
 *
 *  Boot_SetDlgOption
 *
 *	Set the value of a dialog box item.
 *
 *****************************************************************************/

void PASCAL
Boot_SetDlgOption(HWND hdlg, PMSIO pmsio, UINT ui)
{
    HWND hwnd = GetDlgItem(hdlg, pmsio->id);
    if (hwnd) {
        switch (pmsio->msiot) {
        case msiotUint:
            SetDlgItemInt(hdlg, pmsio->id, ui, 0);
            break;

        case msiotBool:
            CheckDlgButton(hdlg, pmsio->id, ui);
            break;

        case msiotCombo:
            ComboBox_SetCurSel(hwnd, ui);
        }
    }
}

/*****************************************************************************
 *
 *  Boot_FactoryReset
 *
 *	Restore to original factory settings.
 *
 *	The weird one is IDC_BOOTLOGO, which
 *	varies depending on the system configuration.
 *
 *****************************************************************************/

BOOL PASCAL
Boot_FactoryReset(HWND hdlg)
{
    PMSIO pmsio;
    for (pmsio = rgmsio; pmsio < pmsioMax; pmsio++) {
	Boot_SetDlgOption(hdlg, pmsio, pmsio->uiDefault);
    }

    CheckDlgButton(hdlg, IDC_LOGO, Boot_fLogo());

#ifdef BOOTMENUDEFAULT
    SendDlgItemMessage(hdlg, IDC_BOOTMENUDEFAULT, CB_SETCURSEL,
		       (WPARAM)Boot_GetDefaultBootMenuDefault() - 1, 0L);
#endif

    Boot_OnBootKeysChange(hdlg);

    Common_SetDirty(hdlg);
    return 1;
}

/*****************************************************************************
 *
 *  Boot_OnCommand
 *
 *	Ooh, we got a command.
 *
 *****************************************************************************/

BOOL PASCAL
Boot_OnCommand(HWND hdlg, int id, UINT codeNotify)
{
    switch (id) {
    case IDC_RESET:	/* Reset to factory default */
	if (codeNotify == BN_CLICKED) return Boot_FactoryReset(hdlg);
	break;

    case IDC_BOOTKEYS:
	if (codeNotify == BN_CLICKED) Boot_OnBootKeysChange(hdlg);
	/* FALLTHROUGH */

    case IDC_BOOTGUI:
    case IDC_BOOTMENU:
    case IDC_LOGO:
    case IDC_BOOTMULTI:
	if (codeNotify == BN_CLICKED) Common_SetDirty(hdlg);
	break;

    case IDC_BOOTDELAY:
    case IDC_BOOTMENUDELAY:
	if (codeNotify == EN_CHANGE) Common_SetDirty(hdlg);
	break;

#ifdef BOOTMENUDEFAULT
    case IDC_BOOTMENUDEFAULT:
	if (codeNotify == CBN_SELCHANGE) Common_SetDirty(hdlg);
	break;
#endif

    case IDC_SCANDISK:
	if (codeNotify == CBN_SELCHANGE) Common_SetDirty(hdlg);
	break;
    }

    return 0;
}

/*****************************************************************************
 *
 *  Boot_OnNotify
 *
 *	Ooh, we got a notification.
 *
 *****************************************************************************/

BOOL PASCAL
Boot_OnNotify(HWND hdlg, NMHDR FAR *pnm)
{
    switch (pnm->code) {
    case PSN_APPLY:
	Boot_Apply(hdlg);
	break;
    }
    return 0;
}

/*****************************************************************************
 *
 *  Boot_InitDlgInt
 *
 *	Initialize a paired edit control / updown control.
 *
 *	hdlg is the dialog box itself.
 *
 *	idc is the edit control identifier.  It is assumed that idc+didcUd is
 *	the identifier for the updown control.
 *
 *	iMin and iMax are the limits of the control.
 *
 *****************************************************************************/

void PASCAL
Boot_InitDlgInt(HWND hdlg, UINT idc, int iMin, int iMax)
{
    HWND hwnd = GetDlgItem(hdlg, idc + didcEdit);
    if (hwnd) {
        Edit_LimitText(hwnd, 2);
        SendDlgItemMessage(hdlg, idc+didcUd,
                           UDM_SETRANGE, 0, MAKELPARAM(iMax, iMin));
    }
}

/*****************************************************************************
 *
 *  Boot_OnInitDialog
 *
 *	Initialize the controls.
 *
 *****************************************************************************/

BOOL NEAR PASCAL
Boot_OnInitDialog(HWND hdlg)
{
    PMSIO pmsio;
    HWND hwnd;
    UINT dids;
    TCH tsz[96];

    /*
     *	Init the Scandisk gizmo.  We need to do this even if not OPK2,
     *	so that we don't confuse the Apply.  But show it only if OPK2.
     */
    hwnd = GetDlgItem(hdlg, IDC_SCANDISK);
    for (dids = 0; dids < 3; dids++) {
	LoadString(hinstCur, IDS_SCANDISKFIRST + dids, tsz, cA(tsz));
	ComboBox_AddString(hwnd, tsz);
    }
    if (g_fOPK2) {
	ShowWindow(hwnd, 1);
	ShowWindow(GetDlgItem(hdlg, IDC_SCANDISKTEXT), 1);
    }

    for (pmsio = rgmsio; pmsio < pmsioMax; pmsio++) {
	Boot_SetDlgOption(hdlg, pmsio,
			  Boot_GetOption(pmsio->ptszName, pmsio->uiDefault));
    }

#ifdef BOOTMENUDEFAULT
    hwnd = GetDlgItem(hdlg, IDC_BOOTMENUDEFAULT);
    for (ids = IDS_BOOTMENU; ids <= IDS_BOOTMENULAST; ids++) {
	if (ids != IDS_BOOTMENUSAFENET || Boot_GetOption(c_tszNetwork, 0)) {
	    LoadString(hinstCur, ids, tsz, cA(tsz));
	    ComboBox_AddString(hwnd, tsz);
	}
    }
    ComboBox_SetCurSel(hwnd, Boot_GetBootMenuDefault() - 1);
#endif

    Boot_InitDlgInt(hdlg, IDC_BOOTDELAY, 0, 99);
    Boot_InitDlgInt(hdlg, IDC_BOOTMENUDELAY, 0, 99);
    Boot_OnBootKeysChange(hdlg);

    if (g_fMemphis) {
        DestroyWindow(GetDlgItem(hdlg, IDC_BOOTDELAYTEXT));
        DestroyWindow(GetDlgItem(hdlg, IDC_BOOTDELAY));
        DestroyWindow(GetDlgItem(hdlg, IDC_BOOTDELAYUD));
        DestroyWindow(GetDlgItem(hdlg, IDC_BOOTDELAYTEXT2));
    }

    return 1;
}

/*****************************************************************************
 *
 *  Our window procedure.
 *
 *****************************************************************************/

/*
 * The HANDLE_WM_* macros weren't designed to be used from a dialog
 * proc, so we need to handle the messages manually.  (But carefully.)
 */

INT_PTR EXPORT
Boot_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    switch (wm) {
    case WM_INITDIALOG: return Boot_OnInitDialog(hdlg);

    case WM_COMMAND:
	return Boot_OnCommand(hdlg,
			       (int)GET_WM_COMMAND_ID(wParam, lParam),
			       (UINT)GET_WM_COMMAND_CMD(wParam, lParam));
    case WM_NOTIFY:
	return Boot_OnNotify(hdlg, (NMHDR FAR *)lParam);

    case WM_HELP: Common_OnHelp(lParam, &rgdwHelp[0]); break;

    case WM_CONTEXTMENU: Common_OnContextMenu(wParam, &rgdwHelp[0]); break;

    default: return 0;	/* Unhandled */
    }
    return 1;		/* Handled */
}
#endif      // _X86_ only
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tweakui\cmd.cpp ===
/*
 * cmd - CMD.EXE settings
 */

#include "tweakui.h"
#include "winconp.h"

#pragma message("Add help for CMD!")

#pragma BEGIN_CONST_DATA

KL const c_klFileComp = { phkCU, c_tszCmdPath, c_tszFileComp };
KL const c_klDirComp  = { phkCU, c_tszCmdPath, c_tszDirComp  };
KL const c_klWordDelim = { phkCU, TEXT("Console"), TEXT("WordDelimiters") };

#define WORD_DELIM_MAX 32

const static DWORD CODESEG rgdwHelp[] = {
        IDC_COMPLETIONGROUP,    IDH_GROUP,
        IDC_FILECOMPTXT,        IDH_CMDFILECOMP,
        IDC_FILECOMP,           IDH_CMDFILECOMP,
        IDC_DIRCOMPTXT,         IDH_CMDDIRCOMP,
        IDC_DIRCOMP,            IDH_CMDDIRCOMP,
        0,                      0,
};

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *  Cmd_OnCommand
 *
 *      Ooh, we got a command.
 *
 *****************************************************************************/

BOOL PASCAL
Cmd_OnCommand(HWND hdlg, int id, UINT codeNotify)
{
    switch (codeNotify) {
    case CBN_SELCHANGE:
    case EN_CHANGE:
        PropSheet_Changed(GetParent(hdlg), hdlg); break;
    }

    return 0;
}

/*****************************************************************************
 *
 *  Cmd_InitComboBox
 *
 *  Fill the combo box with stuff
 *
 *****************************************************************************/

void PASCAL
Cmd_InitComboBox(HWND hwnd, int idc, PKL pkl)
{
    DWORD dwVal = GetDwordPkl(pkl, 0);
    DWORD dw;
    hwnd = GetDlgItem(hwnd, idc);
    for (dw = 0; dw < 32; dw++) {
        TCHAR tszName[127];
        if (LoadString(hinstCur, IDS_COMPLETION + dw, tszName, cA(tszName))) {
            int iItem = ComboBox_AddString(hwnd, tszName);
            ComboBox_SetItemData(hwnd, iItem, dw);
            if (dw == dwVal) {
                ComboBox_SetCurSel(hwnd, iItem);
            }
        }
    }
}

/*****************************************************************************
 *
 *  Cmd_OnInitDialog
 *
 *  Initialize the listview with the current restrictions.
 *
 *****************************************************************************/

BOOL PASCAL
Cmd_OnInitDialog(HWND hdlg)
{
    Cmd_InitComboBox(hdlg, IDC_FILECOMP, &c_klFileComp);
    Cmd_InitComboBox(hdlg, IDC_DIRCOMP, &c_klDirComp);

    TCHAR szDelim[WORD_DELIM_MAX];

    HWND hwndDelim = GetDlgItem(hdlg, IDC_WORDDELIM);
    Edit_LimitText(hwndDelim, WORD_DELIM_MAX);
    GetStrPkl(szDelim, cA(szDelim), &c_klWordDelim);
    SetWindowText(hwndDelim, szDelim);

    return 1;
}

/*****************************************************************************
 *
 *  Cmd_ForceConsoleRefresh
 *
 *  Launch a dummy console to tickle the console subsystem into reloading
 *  its settings.
 *
 *****************************************************************************/

void
Cmd_ForceConsoleRefresh()
{
    WinExec("cmd.exe /c ver", SW_HIDE);
}


/*****************************************************************************
 *
 *  Cmd_ApplyComboBox
 *
 *****************************************************************************/

void PASCAL
Cmd_ApplyComboBox(HWND hwnd, int idc, PKL pkl)
{
    DWORD dw, dwVal = GetDwordPkl(pkl, 0);
    int iItem;
    hwnd = GetDlgItem(hwnd, idc);
    iItem = ComboBox_GetCurSel(hwnd);
    if (iItem >= 0) {
        dw = (DWORD)ComboBox_GetItemData(hwnd, iItem);
        if (dw != dwVal) {
            SetDwordPkl2(pkl, dw);
        }
    }
}

/*****************************************************************************
 *
 *  Cmd_Apply
 *
 *****************************************************************************/

void PASCAL
Cmd_Apply(HWND hdlg)
{
    Cmd_ApplyComboBox(hdlg, IDC_FILECOMP, &c_klFileComp);
    Cmd_ApplyComboBox(hdlg, IDC_DIRCOMP, &c_klDirComp);

    TCHAR szDelim[WORD_DELIM_MAX];
    TCHAR szDelimPrev[WORD_DELIM_MAX];

    GetStrPkl(szDelimPrev, cA(szDelim), &c_klWordDelim);
    GetDlgItemText(hdlg, IDC_WORDDELIM, szDelim, cA(szDelim));
    if (lstrcmp(szDelim, szDelimPrev) != 0) {
        if (szDelim[0]) {
            SetStrPkl(&c_klWordDelim, szDelim);
        } else {
            DelPkl(&c_klWordDelim);
        }
        Cmd_ForceConsoleRefresh();
    }

}

/*****************************************************************************
 *
 *  Cmd_OnNotify
 *
 *      Ooh, we got a notification.
 *
 *****************************************************************************/

BOOL PASCAL
Cmd_OnNotify(HWND hdlg, NMHDR FAR *pnm)
{
    switch (pnm->code) {
    case PSN_APPLY:
        Cmd_Apply(hdlg);
        break;
    }
    return 0;
}

/*****************************************************************************
 *
 *  Our window procedure.
 *
 *****************************************************************************/

INT_PTR EXPORT
Cmd_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    switch (wm) {
    case WM_INITDIALOG: return Cmd_OnInitDialog(hdlg);
    case WM_COMMAND:
        return Cmd_OnCommand(hdlg,
                             (int)GET_WM_COMMAND_ID(wParam, lParam),
                             (UINT)GET_WM_COMMAND_CMD(wParam, lParam));
    case WM_NOTIFY:
        return Cmd_OnNotify(hdlg, (NMHDR FAR *)lParam);

    case WM_HELP: Common_OnHelp(lParam, &rgdwHelp[0]); break;
    case WM_CONTEXTMENU: Common_OnContextMenu(wParam, &rgdwHelp[0]); break;
    default: return 0;  /* Unhandled */
    }
    return 1;           /* Handled */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tweakui\comdlg32.cpp ===
/*
 * comdlg32 - Common Dialog settings
 *
 * NOTE! That it is safe to use Shlwapi here because all platforms that
 * support the new common dialogs come with IE5 installed.
 */

#include "tweakui.h"

#define COMDLG32_KL(nm) \
    KL const c_kl##nm = { &g_hkCUSMWCV, TEXT("Policies\\comdlg32"), TEXT(#nm) }

COMDLG32_KL(NoBackButton);
COMDLG32_KL(NoFileMru);
COMDLG32_KL(NoPlacesBar);

#define REGSTR_PATH_PLACESBAR TEXT("Policies\\comdlg32\\PlacesBar")

#define MAX_PLACES 5

const static DWORD CODESEG rgdwHelp[] = {
        IDC_SHOWBACK,           IDH_CDBACKBUTTON,
        IDC_FILEMRU,            IDH_CDFILEMRU,

        IDC_PLACESGROUP,        IDH_CDPLACESBAR,
        IDC_PLACESDEF,          IDH_CDPLACESBAR,
        IDC_PLACESHIDE,         IDH_CDPLACESBAR,
        IDC_PLACESCUSTOM,       IDH_CDPLACESBAR,
        IDC_PLACE0+0,           IDH_CDPLACESBAR,
        IDC_PLACE0+1,           IDH_CDPLACESBAR,
        IDC_PLACE0+2,           IDH_CDPLACESBAR,
        IDC_PLACE0+3,           IDH_CDPLACESBAR,
        IDC_PLACE0+4,           IDH_CDPLACESBAR,

        0,                      0,
};


/*****************************************************************************
 *
 *  Comdlg32_GetPlacePidl
 *
 *****************************************************************************/

LPITEMIDLIST
Comdlg32_GetPlacePidl(int i)
{
    PIDL pidl = NULL;

    HKEY hkPlaces;
    if (_RegOpenKey(g_hkCUSMWCV, REGSTR_PATH_PLACESBAR, &hkPlaces) == ERROR_SUCCESS) {
        TCHAR szPlaceN[8];
        wsprintf(szPlaceN, TEXT("Place%d"), i);

        DWORD dwType;
        union {
            TCHAR szPath[MAX_PATH];
            DWORD dwCsidl;
        } u;
        DWORD cbData = sizeof(u);
        DWORD dwRc = SHQueryValueEx(hkPlaces, szPlaceN, NULL, &dwType,
                                   &u, &cbData);
        if (dwRc == ERROR_SUCCESS) {
            switch (dwType) {
            case REG_DWORD:
                SHGetSpecialFolderLocation(NULL, u.dwCsidl, &pidl);
                break;

            case REG_SZ:
                pidl = pidlSimpleFromPath(u.szPath);
                break;

            }
        }
        RegCloseKey(hkPlaces);
    }

    return pidl;
}

/*****************************************************************************
 *
 *  c_rgcsidlPlace - an array of csidls that are good candidates for "Places"
 *
 *****************************************************************************/

const int c_rgcsidlPlace[] = {
    -1,                         /* CSIDL_NONE */
#ifdef IDS_CWD
    -2,                         /* CSIDL_CWD  */
#endif
    CSIDL_DESKTOP,
    CSIDL_FAVORITES,
    CSIDL_PERSONAL,
    CSIDL_MYMUSIC,
    CSIDL_MYVIDEO,
    CSIDL_DRIVES,
    CSIDL_NETWORK,
    CSIDL_HISTORY,
    CSIDL_MYPICTURES,
};

/*****************************************************************************
 *
 *  CPlace - Wangle the "place" combobox
 *
 *****************************************************************************/

class CPlace {

public:
    CPlace(HWND hwnd, HKEY hkPlaces, int iPlace);
    void Apply(HKEY hkPlaces);

private:

    HWND    _hwnd;
    int     _iPlace;
    DWORD   _dwType;            // REG_DWORD (_csidl) or REG_SZ (_szPath)
    union {
        TCHAR _szPath[MAX_PATH];
        int   _csidl;
    } _u;
    TCHAR   _szValue[8];        /* place name value */
};


/*****************************************************************************
 *
 *  CPlace::CPlace (constructor)
 *
 *  The reference data for each combo item is a csidl (integer).
 *
 *****************************************************************************/

CPlace::CPlace(HWND hwnd, HKEY hkPlaces, int iPlace) :
    _hwnd(hwnd), _iPlace(iPlace)
{
    PIDL pidlPlace = NULL;
    PIDL pidl;

    wsprintf(_szValue, TEXT("Place%d"), _iPlace);

    DWORD dwRc = ERROR_INVALID_FUNCTION; /* anything that isn't ERROR_SUCCESS */
    if (hkPlaces) {
        DWORD cbData = sizeof(_u);
        dwRc = SHQueryValueEx(hkPlaces, _szValue, NULL, &_dwType, &_u, &cbData);
#ifdef IDS_CWD
        if (dwRc == ERROR_SUCCESS && _dwType == REG_SZ && _u._szPath[0] == TEXT('\0')) {
            _dwType = REG_DWORD;
            _u._csidl = -2;
        }
#endif
    }

    /* Sigh - SHQueryValueEx trashes its inputs on failure */
    if (dwRc != ERROR_SUCCESS) {
        _dwType = REG_DWORD;
        _u._csidl = -1;             /* Default to <none> */
    }

    for (int i = 0; i < cA(c_rgcsidlPlace); i++) {
        int csidl = c_rgcsidlPlace[i];
        pidl = NULL;
        if (csidl < 0 || SUCCEEDED(SHGetSpecialFolderLocation(NULL, csidl, &pidl))) {
            TCHAR tszName[MAX_PATH];
            UINT ids;

            switch (csidl) {
            case -1: ids = IDS_NONE; break;
#ifdef IDS_CWD
            case -2: ids = IDS_CWD; break;
#endif
            default: ids = csidl + IDS_FOLDER_BASE; break;
            }
            LoadString(hinstCur, ids, tszName, cA(tszName));
            int iCombo = ComboBox_AddString(_hwnd, tszName);
            if (iCombo >= 0) {
                ComboBox_SetItemData(_hwnd, iCombo, csidl);
                if (_dwType == REG_DWORD && _u._csidl == csidl) {
                    ComboBox_SetCurSel(_hwnd, iCombo);
                }
            }
            Ole_Free(pidl);
        }
    }

    if (ComboBox_GetCurSel(_hwnd) == -1) {
        switch (_dwType) {

        case REG_SZ:
            ComboBox_SetText(_hwnd, _u._szPath);
            break;

        case REG_DWORD:
            if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, _u._csidl, &pidl))) {
                SHFILEINFO sfi;
                if (SHGetFileInfo((LPCTSTR)pidl, 0, &sfi, sizeof(sfi), SHGFI_DISPLAYNAME | SHGFI_PIDL)) {
                    ComboBox_SetText(_hwnd, sfi.szDisplayName);
                }
                Ole_Free(pidl);
            }
            break;
        }
    }
}

/*****************************************************************************
 *
 *  CPlace::Apply
 *
 *****************************************************************************/

void CPlace::Apply(HKEY hkPlaces)
{
    int iSel = ComboBox_GetCurSel(_hwnd);
    /* If the selection is -1, see if it matches any of the predefined items */
    if (iSel == -1) {
        ComboBox_GetText(_hwnd, _u._szPath, cA(_u._szPath));

        /* Special case: Blank string equals "<none>" */
        if (_u._szPath[0] == TEXT('\0')) {
            LoadString(hinstCur, IDS_NONE, _u._szPath, cA(_u._szPath));
        }

        iSel = ComboBox_GetCount(_hwnd);
        while (--iSel >= 0) {
            TCHAR szSpecial[MAX_PATH];
            ComboBox_GetLBText(_hwnd, iSel, szSpecial);
            if (lstrcmpi(szSpecial, _u._szPath) == 0) break;
        }

    }

    if (iSel >= 0) {
        int csidl = (int)ComboBox_GetItemData(_hwnd, iSel);
        switch (csidl) {
        case -1: RegDeleteValue(hkPlaces, _szValue); break;
#ifdef IDS_CWD
        case -2: SHRegSetPath(hkPlaces, NULL, _szValue, TEXT("."), 0); break;
#endif
        default: RegSetValueEx(hkPlaces, _szValue, NULL, REG_DWORD, (LPCBYTE)&csidl, sizeof(csidl)); break;
        }
    } else {
        /* text is a path, we hope */
        SHRegSetPath(hkPlaces, NULL, _szValue, _u._szPath, 0);
    }
}


/*****************************************************************************
 *
 *  Comdlg32_SetDirty
 *
 *      Make a control dirty.
 *
 *****************************************************************************/

#define Comdlg32_SetDirty   Common_SetDirty

/*****************************************************************************
 *
 *  Comdlg32_EnableDisableItems
 *
 *  If "Custom places bar" is set, then enable the combos.
 *  If any combo is set to "Custom location", then enable the Change button.
 *
 *****************************************************************************/

void
Comdlg32_EnableDisableItems(HWND hdlg)
{
    BOOL bEnableCombo = IsDlgButtonChecked(hdlg, IDC_PLACESCUSTOM);

    for (int i = 0; i < MAX_PLACES; i++)
    {
        EnableDlgItem(hdlg, IDC_PLACE0+i, bEnableCombo);
    }
}

/*****************************************************************************
 *
 *  Comdlg32_OnCommand
 *
 *      Ooh, we got a command.
 *
 *****************************************************************************/

BOOL PASCAL
Comdlg32_OnCommand(HWND hdlg, int id, UINT codeNotify)
{
    switch (id) {

    case IDC_SHOWBACK:
    case IDC_FILEMRU:
        if (codeNotify == BN_CLICKED) Comdlg32_SetDirty(hdlg);
        break;

    case IDC_PLACESDEF:
    case IDC_PLACESHIDE:
    case IDC_PLACESCUSTOM:
        if (codeNotify == BN_CLICKED) {
            Comdlg32_SetDirty(hdlg);
            Comdlg32_EnableDisableItems(hdlg);
        }
        break;

    case IDC_PLACE0+0:
    case IDC_PLACE0+1:
    case IDC_PLACE0+2:
    case IDC_PLACE0+3:
    case IDC_PLACE0+4:
        if (codeNotify == CBN_SELCHANGE ||
            codeNotify == CBN_EDITCHANGE) {
            Comdlg32_SetDirty(hdlg);
        }
        break;
    }

    return 0;
}

/*****************************************************************************
 *
 *  Comdlg32_OnInitDialog
 *
 *  Initialize the listview with the current restrictions.
 *
 *****************************************************************************/

BOOL PASCAL
Comdlg32_OnInitDialog(HWND hdlg)
{
    CheckDlgButton(hdlg, IDC_SHOWBACK, !GetDwordPkl(&c_klNoBackButton, 0));
    CheckDlgButton(hdlg, IDC_FILEMRU,  !GetDwordPkl(&c_klNoFileMru,    0));

    HKEY hkPlaces = NULL;
    _RegOpenKey(g_hkCUSMWCV, REGSTR_PATH_PLACESBAR, &hkPlaces);

    UINT idc;
    if (GetDwordPkl(&c_klNoPlacesBar, 0)) {
        idc = IDC_PLACESHIDE;
    } else if (hkPlaces) {
        idc = IDC_PLACESCUSTOM;
    } else {
        idc = IDC_PLACESDEF;
    }

    CheckRadioButton(hdlg, IDC_PLACESDEF, IDC_PLACESCUSTOM, idc);

    for (int i = 0; i < MAX_PLACES; i++) {
        HWND hwndCombo = GetDlgItem(hdlg, IDC_PLACE0+i);
        CPlace *pplace = new CPlace(hwndCombo, hkPlaces, i);
        if (pplace) {
            SetWindowLongPtr(hwndCombo, GWLP_USERDATA, (LPARAM)pplace);
        }
    }

    if (hkPlaces) {
        RegCloseKey(hkPlaces);
    }

    Comdlg32_EnableDisableItems(hdlg);

    return 1;
}

/*****************************************************************************
 *
 *  Comdlg32_Apply
 *
 *****************************************************************************/

void PASCAL
Comdlg32_Apply(HWND hdlg)
{
    SetDwordPkl2(&c_klNoBackButton, !IsDlgButtonChecked(hdlg, IDC_SHOWBACK));
    SetDwordPkl2(&c_klNoFileMru,    !IsDlgButtonChecked(hdlg, IDC_FILEMRU));

    if (IsDlgButtonChecked(hdlg, IDC_PLACESHIDE)) {
        SetDwordPkl2(&c_klNoPlacesBar, 1);
    } else if (IsDlgButtonChecked(hdlg, IDC_PLACESDEF)) {
        DelPkl(&c_klNoPlacesBar);
        RegDeleteTree(g_hkCUSMWCV, REGSTR_PATH_PLACESBAR);
    } else {
        DelPkl(&c_klNoPlacesBar);

        HKEY hkPlaces;
        if (_RegCreateKey(g_hkCUSMWCV, REGSTR_PATH_PLACESBAR, &hkPlaces) == ERROR_SUCCESS) {
            for (int i = 0; i < MAX_PLACES; i++) {
                HWND hwndCombo = GetDlgItem(hdlg, IDC_PLACE0+i);
                CPlace *pplace = (CPlace *)GetWindowLongPtr(hwndCombo, GWLP_USERDATA);
                if (pplace) {
                    pplace->Apply(hkPlaces);
                }
            }
            RegCloseKey(hkPlaces);
        }
    }
}

/*****************************************************************************
 *
 *  Comdlg32_OnNotify
 *
 *      Ooh, we got a notification.
 *
 *****************************************************************************/

BOOL PASCAL
Comdlg32_OnNotify(HWND hdlg, NMHDR FAR *pnm)
{
    switch (pnm->code) {
    case PSN_APPLY:
        Comdlg32_Apply(hdlg);
        break;
    }
    return 0;
}

/*****************************************************************************
 *
 *  Comdlg32_OnDestroy
 *
 *****************************************************************************/

void
Comdlg32_OnDestroy(HWND hdlg)
{
    for (int i = 0; i < MAX_PLACES; i++) {
        HWND hwndCombo = GetDlgItem(hdlg, IDC_PLACE0+i);
        CPlace *pplace = (CPlace *)GetWindowLongPtr(hwndCombo, GWLP_USERDATA);
        delete pplace;
    }
}


/*****************************************************************************
 *
 *  Our window procedure.
 *
 *****************************************************************************/

INT_PTR EXPORT
Comdlg32_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    switch (wm) {
    case WM_INITDIALOG: return Comdlg32_OnInitDialog(hdlg);
    case WM_COMMAND:
        return Comdlg32_OnCommand(hdlg,
                             (int)GET_WM_COMMAND_ID(wParam, lParam),
                             (UINT)GET_WM_COMMAND_CMD(wParam, lParam));
    case WM_NOTIFY:
        return Comdlg32_OnNotify(hdlg, (NMHDR FAR *)lParam);

    case WM_DESTROY:
        Comdlg32_OnDestroy(hdlg);
        break;

    case WM_HELP: Common_OnHelp(lParam, &rgdwHelp[0]); break;
    case WM_CONTEXTMENU: Common_OnContextMenu(wParam, &rgdwHelp[0]); break;
    default: return 0;  /* Unhandled */
    }
    return 1;           /* Handled */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tweakui\common.cpp ===
/*
 * common - Common user interface services
 */

#include "tweakui.h"

/*****************************************************************************
 *
 *  Common_SetDirty
 *
 *	Make a property sheet dirty.
 *
 *****************************************************************************/

void NEAR PASCAL
Common_SetDirty(HWND hdlg)
{
    PropSheet_Changed(GetParent(hdlg), hdlg);
}

/*****************************************************************************
 *
 *  Common_NeedLogoff
 *
 *	Indicate that you need to log off for the changes to take effect.
 *
 *****************************************************************************/

void NEAR PASCAL
Common_NeedLogoff(HWND hdlg)
{
    PropSheet_RestartWindows(GetParent(hdlg));
}

/*****************************************************************************
 *
 *  Common_OnHelp
 *
 *	Respond to the F1 key.
 *
 *****************************************************************************/

void PASCAL
Common_OnHelp(LPARAM lp, const DWORD CODESEG *pdwHelp)
{
    WinHelp((HWND) ((LPHELPINFO) lp)->hItemHandle, c_tszMyHelp,
            HELP_WM_HELP, (DWORD_PTR) pdwHelp);
}

/*****************************************************************************
 *
 *  Common_OnContextMenu
 *
 *	Respond to a right-click.
 *
 *****************************************************************************/

void PASCAL
Common_OnContextMenu(WPARAM wp, const DWORD CODESEG *pdwHelp)
{
    WinHelp((HWND) wp, c_tszMyHelp, HELP_CONTEXTMENU, (DWORD_PTR) pdwHelp);
}

/*****************************************************************************
 *
 *  Common_OnLvContextMenu
 *
 *	The context menu shall appear in the listview.
 *
 *	Have the callback generate the menu, then pop it up and let the
 *	window procedure's WM_COMMAND do the rest.
 *
 *****************************************************************************/

void PASCAL
Common_OnLvContextMenu(HWND hwnd, POINT pt, CMCALLBACK pfn)
{
    int iItem = Misc_LV_GetCurSel(hwnd);
    if (iItem != -1) {
	ClientToScreen(hwnd, &pt);	/* Make it screen coordinates */
	TrackPopupMenuEx(pfn(hwnd, iItem),
			 TPM_RIGHTBUTTON | TPM_VERTICAL |
			 TPM_LEFTALIGN | TPM_TOPALIGN, pt.x, pt.y,
			 GetParent(hwnd), 0);
    }
}

/*****************************************************************************
 *
 *  Common_LV_OnContextMenu
 *
 *	If the context menu came from the listview, figure out which
 *	item got clicked on.  If we find an item, pop up its context
 *	menu.  Otherwise, just do the standard help thing.
 *
 *	NOTE!  We don't use LVHT_ONITEM because ListView is broken!
 *	Watch:
 *
 *	    #define LVHT_ONITEMSTATEICON 0x0008
 *	    #define LVHT_ABOVE          0x0008
 *
 *	Oops.  This means that clicks above the item are treated as
 *	clicks on the state icon.
 *
 *	Fortunately, we reside completely in report view, so you can't
 *	legally click above the item.  The only way it can happen is
 *	if the coordinates to OnContextMenu are out of range, so we
 *	catch that up front and munge it accordingly.
 *
 *****************************************************************************/

void PASCAL
Common_LV_OnContextMenu(HWND hdlg, HWND hwnd, LPARAM lp,
		        CMCALLBACK pfn, const DWORD CODESEG *pdwHelp)
{
    if (GetDlgCtrlID(hwnd) == IDC_LISTVIEW) {
	LV_HITTESTINFO hti;
	if (lp == (LPARAM)0xFFFFFFFF) {
	    /* Pretend it was on the center of the small icon */
	    ListView_GetItemPosition(hwnd, Misc_LV_GetCurSel(hwnd),
				     &hti.pt);
	    hti.pt.x += GetSystemMetrics(SM_CXSMICON) / 2;
	    hti.pt.y += GetSystemMetrics(SM_CYSMICON) / 2;
	    Common_OnLvContextMenu(hwnd, hti.pt, pfn);
	} else {
	    Misc_LV_HitTest(hwnd, &hti, lp);
	    if ((hti.flags & LVHT_ONITEM)) {
		/* Because LV sometimes forgets to move the focus... */
		Misc_LV_SetCurSel(hwnd, hti.iItem);
		Common_OnLvContextMenu(hwnd, hti.pt, pfn);
	    } else {
		Common_OnContextMenu((WPARAM)hwnd, pdwHelp);
	    }
	}
    } else {
	Common_OnContextMenu((WPARAM)hwnd, pdwHelp);
    }
}


/*****************************************************************************
 *
 *  Common_OnLvCommand
 *
 *	Handle a WM_COMMAND that might be for the listview.
 *
 *****************************************************************************/

void PASCAL
Common_OnLvCommand(HWND hdlg, int idCmd, PLVCI rglvci, int clvci)
{
    do {
	if (idCmd == rglvci[0].id) {
	    HWND hwnd = GetDlgItem(hdlg, IDC_LISTVIEW);
	    int iItem = Misc_LV_GetCurSel(hwnd);
	    if (iItem != -1) {
		rglvci[0].pfn(hwnd, iItem);
	    }
	    break;
	}
	rglvci++;
    } while (--clvci);
}

/*****************************************************************************
 *
 *  EnableDlgItem
 *
 *	A simple wrapper.
 *
 *****************************************************************************/

void NEAR PASCAL
EnableDlgItem(HWND hdlg, UINT idc, BOOL f)
{
    EnableWindow(GetDlgItem(hdlg, idc), f);
}

/*****************************************************************************
 *
 *  EnableDlgItems
 *
 *****************************************************************************/

void NEAR PASCAL
EnableDlgItems(HWND hdlg, UINT idcFirst, UINT idcLast, BOOL f)
{
    for (; idcFirst <= idcLast; idcFirst++) {
        EnableWindow(GetDlgItem(hdlg, idcFirst), f);
    }
}

/*****************************************************************************
 *
 *  AdjustDlgItems
 *
 *****************************************************************************/

void NEAR PASCAL
AdjustDlgItems(HWND hdlg, UINT idcFirst, UINT idcLast, UINT adi)
{
    for (UINT idc = idcFirst; idc <= idcLast; idc++) {
        HWND hwnd = GetDlgItem(hdlg, idc);
        if (adi & (ADI_DISABLE | ADI_ENABLE)) {
            EnableWindow(hwnd, (adi & ADI_ENABLE) ? TRUE : FALSE);
        }
        if (adi & (ADI_HIDE | ADI_SHOW)) {
            ShowWindow(hwnd, (adi & ADI_SHOW) ? SW_SHOW : SW_HIDE);
        }
    }
}

/*****************************************************************************
 *
 *  SetDlgItemTextLimit
 *
 *	Set the dialog item text as well as limiting its size.
 *
 *****************************************************************************/

void NEAR PASCAL
SetDlgItemTextLimit(HWND hdlg, UINT id, LPCTSTR ptsz, UINT ctch)
{
    HWND hwnd = GetDlgItem(hdlg, id);
    SetWindowText(hwnd, ptsz);
    Edit_LimitText(hwnd, ctch - 1);
}

/*****************************************************************************
 *
 *  DestroyDlgItems
 *
 *****************************************************************************/

void NEAR PASCAL
DestroyDlgItems(HWND hdlg, UINT idcFirst, UINT idcLast)
{
    UINT idc;
    for (idc = idcFirst; idc <= idcLast; idc++) {
        DestroyWindow(GetDlgItem(hdlg, idc));
    }
}

/*****************************************************************************
 *
 *  GetDlgItemRect
 *
 *      Get the rect of a dialog item in client coordinates.
 *
 *****************************************************************************/

void PASCAL
GetDlgItemRect(HWND hdlg, UINT idc, LPRECT prc)
{
    GetWindowRect(GetDlgItem(hdlg, idc), prc);
    MapWindowRect(NULL, hdlg, prc);
}

/*****************************************************************************
 *
 *  MoveDlgItems
 *
 *****************************************************************************/

void PASCAL
MoveDlgItems(HWND hdlg, UINT idcTarget, UINT idcFirst, UINT idcLast)
{
    RECT rcFrom, rcTo;

    GetDlgItemRect(hdlg, idcTarget, &rcTo);
    GetDlgItemRect(hdlg, idcFirst, &rcFrom);
    int dy = rcTo.top - rcFrom.top;
    HDWP hdwp = BeginDeferWindowPos(idcLast - idcFirst + 1);
    for (UINT idc = idcFirst; idc <= idcLast; idc++) {
        GetDlgItemRect(hdlg, idc, &rcFrom);
        HWND hwnd = GetDlgItem(hdlg, idc);
        hdwp = DeferWindowPos(hdwp, hwnd, NULL,
                              rcFrom.left, rcFrom.top + dy, 0, 0,
                              SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE);
    }
    EndDeferWindowPos(hdwp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tweakui\explorer.cpp ===
/*
 * explorer - Dialog box property sheet for "explorer ui tweaks"
 */

#include "tweakui.h"

#pragma BEGIN_CONST_DATA

typedef struct SCEI {                   /* Shortcut effect info */
    PCTSTR ptszDll;
    int iIcon;
} SCEI;

const SCEI CODESEG rgscei[] = {
    { g_tszPathShell32, 29 },
    { g_tszPathMe, IDI_ALTLINK - 1 },
    { g_tszPathMe, IDI_BLANK - 1 },
};

KL const c_klHackPtui = { &g_hkLMSMWCV, c_tszAppletTweakUI, c_tszHackPtui };
KL const c_klLinkOvl = { &pcdii->hkLMExplorer, c_tszShellIcons, c_tszLinkOvl };
KL const c_klWelcome =  { &pcdii->hkCUExplorer, c_tszTips, c_tszShow };
KL const c_klAltColor =  { &pcdii->hkCUExplorer, 0, c_tszAltColor };
KL const c_klHotlight = { &c_hkCU, c_tszCplColors, c_tszHotTrackColor };
KL const c_klNoConnection = { &pcdii->hkCUExplorer, 0, TEXT("NoFileFolderConnection") };

#define clrDefAlt     RGB(0x00, 0x00, 0xFF)
#define clrDefHot     RGB(0x00, 0x00, 0xFF)

const static DWORD CODESEG rgdwHelp[] = {
        IDC_LINKGROUP,          IDH_LINKEFFECT,
        IDC_LINKARROW,          IDH_LINKEFFECT,
        IDC_LIGHTARROW,         IDH_LINKEFFECT,
        IDC_NOARROW,            IDH_LINKEFFECT,
        IDC_CUSTOMARROW,        IDH_LINKEFFECT,
        IDC_CUSTOMCHANGE,       IDH_LINKEFFECT,

        IDC_LINKBEFORETEXT,     IDH_LINKEFFECT,
        IDC_LINKBEFORE,         IDH_LINKEFFECT,
        IDC_LINKAFTERTEXT,      IDH_LINKEFFECT,
        IDC_LINKAFTER,          IDH_LINKEFFECT,
        IDC_LINKHELP,           IDH_LINKEFFECT,

        IDC_SETGROUP,           IDH_GROUP,
        IDC_CLRGROUP,           IDH_GROUP,
        IDC_COMPRESSTXT,        IDH_COMPRESSCLR,
        IDC_COMPRESSCLR,        IDH_COMPRESSCLR,
        IDC_COMPRESSBTN,        IDH_COMPRESSCLR,
        IDC_HOTTRACKTXT,        IDH_HOTTRACKCLR,
        IDC_HOTTRACKCLR,        IDH_HOTTRACKCLR,
        IDC_HOTTRACKBTN,        IDH_HOTTRACKCLR,

        IDC_RESET,              IDH_RESET,
        0,                      0,
};


#pragma END_CONST_DATA

/*****************************************************************************
 *
 *  CustomColor
 *
 *      A little class the manages the little custom color buttons.
 *
 *****************************************************************************/

class CustomColor {
public:
    void Init(HWND hwnd);
    void Destroy();
    void SetColor(COLORREF clr);
    COLORREF GetColor();

private:
    COLORREF _clr;                      /* The color */
    HWND _hwnd;                         /* Button control we party on */
    HBITMAP _hbm;                       /* Solid bitmap for button */
    RECT _rc;                           /* Rectangle dimensions of bitmap */

};

/*****************************************************************************
 *
 *  CustomColor::Init
 *
 *      Say which control is in charge.
 *
 *****************************************************************************/

void CustomColor::Init(HWND hwnd)
{
    HDC hdc;
    _hwnd = hwnd;
    GetClientRect(_hwnd, &_rc);

    hdc = GetDC(hwnd);
    if (hdc) {
        _hbm = CreateCompatibleBitmap(hdc, _rc.right, _rc.bottom);
        ReleaseDC(hwnd, hdc);
    } else {
        _hbm = NULL;
    }

    SendMessage(_hwnd, BM_SETIMAGE, IMAGE_BITMAP, (LPARAM)_hbm);
}

/*****************************************************************************
 *
 *  CustomColor::Destroy
 *
 *      Clean up the custom color stuff.
 *
 *****************************************************************************/

void
CustomColor::Destroy()
{
    if (_hwnd) {
        SendMessage(_hwnd, BM_SETIMAGE, IMAGE_BITMAP, (LPARAM)NULL);
    }
    if (_hbm) {
        DeleteObject(_hbm);
    }
}

/*****************************************************************************
 *
 *  CustomColor::SetColor
 *
 *      Set the custom color.
 *
 *****************************************************************************/

void
CustomColor::SetColor(COLORREF clr)
{
    /*
     *  Fill the bitmap with the new color.
     */
    _clr = clr;
    HDC hdc = CreateCompatibleDC(NULL);
    if (hdc) {
        HBITMAP hbmPrev = SelectBitmap(hdc, _hbm);
        SetBkColor(hdc, _clr);
        ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &_rc, NULL, 0, NULL);
        SelectObject(hdc, hbmPrev);
        DeleteDC(hdc);
    }

    /*
     *  Okay, repaint with the new bitmap.
     */
    InvalidateRect(_hwnd, NULL, TRUE);
}

/*****************************************************************************
 *
 *  CustomColor::GetColor
 *
 *      Get the custom color.
 *
 *****************************************************************************/

COLORREF __inline
CustomColor::GetColor()
{
    return _clr;
}

/*****************************************************************************
 *
 *  EDII
 *
 *****************************************************************************/

typedef struct EDII {
    HIMAGELIST himl;                    /* Private image list */
    WNDPROC wpAfter;                    /* Subclass procedure */
    UINT idcCurEffect;                  /* currently selected effect */
    BOOL fIconDirty;                    /* if the shortcut icon is dirty */
    int iIcon;                          /* Custom shortcut effect icon */
    CustomColor ccComp;                 /* Compressed files */
    CustomColor ccHot;                  /* Hot-track */
    TCH tszPathDll[MAX_PATH];           /* Custom shortcut effect dll */
} EDII, *PEDII;

EDII edii;
#define pedii (&edii)

/*****************************************************************************
 *
 *  GetRestriction
 *
 *  Determine whether a restriction is set.  Restrictions are reverse-sense,
 *  so we un-reverse them here, so that this returns 1 if the feature is
 *  enabled.
 *
 *****************************************************************************/

BOOL PASCAL
GetRestriction(LPCTSTR ptszKey)
{
    return GetRegDword(g_hkCUSMWCV, c_tszRestrictions, ptszKey, 0) == 0;
}

/*****************************************************************************
 *
 *  SetRestriction
 *
 *  Set a restriction.  Again, since restrictions are reverse-sense, we
 *  un-reverse them here, so that passing 1 enables the feature.
 *
 *****************************************************************************/

BOOL PASCAL
SetRestriction(LPCTSTR ptszKey, BOOL f)
{
    return SetRegDword(g_hkCUSMWCV, c_tszRestrictions, ptszKey, !f);
}

/*****************************************************************************
 *
 *  Explorer_HackPtui
 *
 *      Patch up a bug in comctl32, where a blank overlay image gets
 *      the wrong rectangle set into it because comctl32 gets confused
 *      when all the pixels are transparent.  As a result, the link
 *      overlay becomes THE ENTIRE IMAGELIST instead of nothing.
 *
 *      We do this by (hack!) swiping himlIcons and himlIconsSmall
 *      from SHELL32, and then (ptui!) partying DIRECTLY INTO THEM
 *      and fixing up the rectangle coordinates.
 *
 *      I'm really sorry I have to do this, but if I don't, people will
 *      just keep complaining.
 *
 *  Helper procedures:
 *
 *      Explorer_HackPtuiCough - fixes one himl COMCTL32's data structures.
 *
 *****************************************************************************/

/*
 * On entry to Explorer_HackPtuiCough, the pointer has already been
 * validated.
 */
BOOL PASCAL
Explorer_HackPtuiCough(LPBYTE lpb, LPVOID pvRef)
{
#if 0
    if (*(LPWORD)lpb == 0x4C49 &&
        *(LPDWORD)(lpb + 0x78) == 0 && *(LPDWORD)(lpb + 0x88) == 0) {
#else
    if (*(LPWORD)lpb == 0x4C49) {
#endif
        *(LPDWORD)(lpb + 0x78) = 1;
        *(LPDWORD)(lpb + 0x88) = 1;
        return 1;
    } else {
        return 0;
    }
}

void PASCAL
Explorer_HackPtui(void)
{
    if (g_fBuggyComCtl32 && GetIntPkl(0, &c_klHackPtui)) {
        if (WithSelector((DWORD_PTR)GetSystemImageList(0),
                         0x8C, (WITHPROC)Explorer_HackPtuiCough, 0, 1) &&
            WithSelector((DWORD_PTR)GetSystemImageList(SHGFI_SMALLICON),
                         0x8C, (WITHPROC)Explorer_HackPtuiCough, 0, 1)) {
            RedrawWindow(0, 0, 0, RDW_INVALIDATE | RDW_ALLCHILDREN);
        }
    }
}

/*****************************************************************************
 *
 *  Explorer_SetAfterImage
 *
 *  The link overlay image has changed, so update the "after" image, too.
 *  All we have to do is invalidate the window; our WM_PAINT handler will
 *  paint the new effect.
 *
 *****************************************************************************/

INLINE void
Explorer_SetAfterImage(HWND hdlg)
{
    InvalidateRect(GetDlgItem(hdlg, IDC_LINKAFTER), 0, 1);
}

/*****************************************************************************
 *
 *  Explorer_After_OnPaint
 *
 *  Paint the merged images.
 *
 *  I used to use ILD_TRANSPARENT, except for some reason the background
 *  wasn't erased by WM_ERASEBKGND.  (Probably because statics don't
 *  process that message.)
 *
 *****************************************************************************/

LRESULT PASCAL
Explorer_After_OnPaint(HWND hwnd)
{
    PAINTSTRUCT ps;
    HDC hdc = BeginPaint(hwnd, &ps);
    if (hdc) {
        ImageList_SetBkColor(pedii->himl, GetSysColor(COLOR_BTNFACE));
        ImageList_Draw(pedii->himl, 0, hdc, 0, 0,
                       ILD_NORMAL | INDEXTOOVERLAYMASK(1));
        EndPaint(hwnd, &ps);
    }
    return 0;
}

/*****************************************************************************
 *
 *  Explorer_After_WndProc
 *
 *  Subclass window procedure for the after-image.
 *
 *****************************************************************************/

LRESULT EXPORT
Explorer_After_WndProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp)
{
    switch (wm) {
    case WM_PAINT: return Explorer_After_OnPaint(hwnd);
    }
    return CallWindowProc(pedii->wpAfter, hwnd, wm, wp, lp);
}


/*****************************************************************************
 *
 *  Explorer_GetIconSpecFromRegistry
 *
 *  The output buffer must be MAX_PATH characters in length.
 *
 *  Returns the icon index.
 *
 *****************************************************************************/

int PASCAL
Explorer_GetIconSpecFromRegistry(LPTSTR ptszBuf)
{
    int iIcon;
    if (GetStrPkl(ptszBuf, cbCtch(MAX_PATH), &c_klLinkOvl)) {
        iIcon = ParseIconSpec(ptszBuf);
    } else {
        ptszBuf[0] = TEXT('\0');
        iIcon = 0;
    }
    return iIcon;
}

/*****************************************************************************
 *
 *  Explorer_RefreshOverlayImage
 *
 *      There was a change to the shortcut effects.  Put a new overlay
 *      image into the imagelist and update the After image as well.
 *
 *****************************************************************************/

void PASCAL
Explorer_RefreshOverlayImage(HWND hdlg)
{
    HICON hicon = ExtractIcon(hinstCur, pedii->tszPathDll, pedii->iIcon);
    if ((UINT_PTR)hicon <= 1) {
        hicon = ExtractIcon(hinstCur, g_tszPathShell32, 29); /* default */
    }
    ImageList_ReplaceIcon(pedii->himl, 1, hicon);
    SafeDestroyIcon(hicon);
    Explorer_SetAfterImage(hdlg);
}

/*****************************************************************************
 *
 *  Explorer_OnEffectChange
 *
 *      There was a change to the shortcut effects.
 *
 *      Put the new effect icon into the image list and update stuff.
 *
 *****************************************************************************/

void PASCAL
Explorer_OnEffectChange(HWND hdlg, UINT id)
{
    if (id != pedii->idcCurEffect) {
        if (id == IDC_CUSTOMARROW) {
            EnableDlgItem(hdlg, IDC_CUSTOMCHANGE, TRUE);
        } else {
            EnableDlgItem(hdlg, IDC_CUSTOMCHANGE, FALSE);
            lstrcpy(pedii->tszPathDll, rgscei[id - IDC_LINKFIRST].ptszDll);
            pedii->iIcon = rgscei[id - IDC_LINKFIRST].iIcon;
        }
        pedii->idcCurEffect = id;
        pedii->fIconDirty = 1;
        Explorer_RefreshOverlayImage(hdlg);

        Common_SetDirty(hdlg);
    }
}


/*****************************************************************************
 *
 *  Explorer_ChangeEffect
 *
 *      The user wants to customize the link effect.
 *
 *****************************************************************************/

void PASCAL
Explorer_ChangeEffect(HWND hdlg)
{
    if (PickIcon(hdlg, pedii->tszPathDll, cA(pedii->tszPathDll),
                       &pedii->iIcon)) {
        pedii->fIconDirty = 1;
        Explorer_RefreshOverlayImage(hdlg);
        Common_SetDirty(hdlg);
    }
}

#if 0
/*****************************************************************************
 *
 *  Explorer_FactoryReset
 *
 *      Restore to factory settings.
 *
 *****************************************************************************/

BOOL PASCAL
Explorer_FactoryReset(HWND hdlg)
{
    if (pedii->idcCurEffect != IDC_LINKARROW) {
        if (pedii->idcCurEffect) {
            CheckDlgButton(hdlg, pedii->idcCurEffect, 0);
        }
        CheckDlgButton(hdlg, IDC_LINKARROW, 1);
        Explorer_OnEffectChange(hdlg, IDC_LINKARROW);
    }
    CheckDlgButton(hdlg, IDC_PREFIX, 1);
    CheckDlgButton(hdlg, IDC_EXITSAVE, 1);
    CheckDlgButton(hdlg, IDC_BANNER, 1);
    CheckDlgButton(hdlg, IDC_WELCOME, 1);

    if (mit.ReadCabinetState) {
        CheckDlgButton(hdlg, IDC_MAKEPRETTY, 1);
        pedii->ccComp.SetColor(clrDefAlt);
    }

    if (GetSysColorBrush(COLOR_HOTLIGHT)) {
        pedii->ccHot.SetColor(clrDefHot);
    }

    Common_SetDirty(hdlg);

    return 1;
}
#endif

/*****************************************************************************
 *
 *  Explorer_ChangeColor
 *
 *****************************************************************************/

BOOL PASCAL
Explorer_ChangeColor(HWND hdlg, int id)
{
    CHOOSECOLOR cc;
    CustomColor *pcc = id == IDC_COMPRESSBTN ? &pedii->ccComp : &pedii->ccHot;
    DWORD rgdw[16];
    HKEY hk;

    ZeroMemory(rgdw, cbX(rgdw));
    if (RegOpenKey(HKEY_CURRENT_USER, c_tszRegPathAppearance, &hk) == 0) {
        DWORD cb = cbX(rgdw);
        RegQueryValueEx(hk, c_tszCustomColors, 0, 0, (LPBYTE)rgdw, &cb);
        RegCloseKey(hk);
    }

    cc.lStructSize = cbX(cc);
    cc.hwndOwner = hdlg;
    cc.rgbResult = pcc->GetColor();
    cc.lpCustColors = rgdw;
    cc.Flags = CC_RGBINIT;
    if (ChooseColor(&cc) && pcc->GetColor() != cc.rgbResult) {
        pcc->SetColor(cc.rgbResult);
        Common_SetDirty(hdlg);
    }
    return 1;
}

/*****************************************************************************
 *
 *  Explorer_OnCommand
 *
 *      Ooh, we got a command.
 *
 *****************************************************************************/

void PASCAL
Explorer_OnCommand(HWND hdlg, int id, UINT codeNotify)
{
    switch (id) {
    case IDC_LINKARROW:
    case IDC_LIGHTARROW:
    case IDC_NOARROW:
    case IDC_CUSTOMARROW:
        if (codeNotify == BN_CLICKED) {
            Explorer_OnEffectChange(hdlg, id);
        }
        break;

    case IDC_CUSTOMCHANGE:
        if (codeNotify == BN_CLICKED) Explorer_ChangeEffect(hdlg);
        break;

    case IDC_COMPRESSBTN:
    case IDC_HOTTRACKBTN:
        if (codeNotify == BN_CLICKED) Explorer_ChangeColor(hdlg, id);
        break;

#if 0
    case IDC_RESET:     /* Reset to factory default */
        if (codeNotify == BN_CLICKED) Explorer_FactoryReset(hdlg);
        break;
#endif
    }

}

/*****************************************************************************
 *
 *  Explorer_GetLinkPrefix
 *  Explorer_SetLinkPrefix
 *
 *****************************************************************************/

BOOL PASCAL
Explorer_GetLinkPrefix(LPARAM lParam, LPVOID pvRef)
{
    return Link_GetShortcutTo();
}

BOOL PASCAL
Explorer_SetLinkPrefix(BOOL f, LPARAM lParam, LPVOID pvRef)
{
    if (!Link_SetShortcutTo(f) && pvRef) {
        LPBOOL pf = (LPBOOL)pvRef;
        *pf = TRUE;
    }
    return TRUE;
}

/*****************************************************************************
 *
 *  Explorer_GetRestriction
 *  Explorer_GetRestrictionClassic
 *  Explorer_SetRestriction
 *
 *****************************************************************************/

BOOL PASCAL
Explorer_GetRestriction(LPARAM lParam, LPVOID pvRef)
{
    LPCTSTR pszRest = (LPCTSTR)pvRef;
    return GetRestriction(pszRest);
}

BOOL PASCAL
Explorer_GetRestrictionClassic(LPARAM lParam, LPVOID pvRef)
{
    if (g_fIE4) {
        return -1;
    } else {
        LPCTSTR pszRest = (LPCTSTR)pvRef;
        return GetRestriction(pszRest);
    }
}

BOOL PASCAL
Explorer_SetRestriction(BOOL f, LPARAM lParam, LPVOID pvRef)
{
    LPCTSTR pszRest = (LPCTSTR)pvRef;
    BOOL fRc = SetRestriction(pszRest, f);
    return fRc;
}

/*****************************************************************************
 *
 *  Explorer_GetWelcome
 *  Explorer_SetWelcome
 *
 *****************************************************************************/

BOOL PASCAL
Explorer_GetWelcome(LPARAM lParam, LPVOID pvRef)
{
    if (g_fIE4) {
        return -1;
    } else {
        return GetDwordPkl(&c_klWelcome, 1);
    }
}

BOOL PASCAL
Explorer_SetWelcome(BOOL f, LPARAM lParam, LPVOID pvRef)
{
    BOOL fRc = SetDwordPkl(&c_klWelcome, f);
    return fRc;
}

/*****************************************************************************
 *
 *  Explorer_Get8Dot3
 *  Explorer_Set8Dot3
 *
 *  The setting is valid only if ReadCabinetState exists and we are not v5.
 *
 *****************************************************************************/

BOOL PASCAL
Explorer_Get8Dot3(LPARAM lParam, LPVOID pvRef)
{
    CABINETSTATE cs;
    if (!g_fShell5 && mit.ReadCabinetState && mit.ReadCabinetState(&cs, cbX(cs))) {
        return !cs.fDontPrettyNames;
    } else {
        return -1;
    }
}

BOOL PASCAL
Explorer_Set8Dot3(BOOL f, LPARAM lParam, LPVOID pvRef)
{
    BOOL fRc = FALSE;

    CABINETSTATE cs;
    if (mit.ReadCabinetState(&cs, cbX(cs))) {
        if (cs.fDontPrettyNames == f) {
            fRc = TRUE;
        } else {
            cs.fDontPrettyNames = f;
            fRc = mit.WriteCabinetState(&cs);
            if (fRc && pvRef) {
                LPBOOL pf = (LPBOOL)pvRef;
                *pf = TRUE;
            }
        }
    }
    return fRc;
}

/*****************************************************************************
 *
 *  Explorer_GetConnectedFiles
 *  Explorer_SetConnectedFiles
 *
 *****************************************************************************/

BOOL PASCAL
Explorer_GetConnectedFiles(LPARAM lParam, LPVOID pvRef)
{
    if (g_fShell5) {
        return !GetDwordPkl(&c_klNoConnection, 0);
    } else {
        return -1;
    }
}

BOOL PASCAL
Explorer_SetConnectedFiles(BOOL f, LPARAM lParam, LPVOID pvRef)
{
    BOOL fRc = SetDwordPkl(&c_klNoConnection, !f);
    return fRc;
}

/*****************************************************************************
 *
 *  c_rgcliExplorer
 *
 *****************************************************************************/

/*
 *  Note that this needs to be in sync with the IDS_EXPLOREREFFECTS
 *  strings.
 */
CHECKLISTITEM c_rgcliExplorer[] = {
    { Explorer_GetLinkPrefix,  Explorer_SetLinkPrefix,  0,  },
    { Explorer_GetRestriction, Explorer_SetRestriction, (LPARAM)c_tszNoExitSave, },
    { Explorer_GetRestrictionClassic, Explorer_SetRestriction, (LPARAM)c_tszNoBanner,   },
    { Explorer_GetWelcome,     Explorer_SetWelcome,     0,  },
    { Explorer_Get8Dot3,       Explorer_Set8Dot3,       0,  },
    { Explorer_GetConnectedFiles,
                               Explorer_SetConnectedFiles, 0 },
};

/*****************************************************************************
 *
 *  Explorer_OnInitDialog
 *
 *  Find out which link icon people are using.
 *
 *  When we initialize the image list, we just throw something random
 *  into position 1.  Explorer_OnEffectChange will put the right thing in.
 *
 *****************************************************************************/

BOOL PASCAL
Explorer_OnInitDialog(HWND hwndList)
{
    int iscei;
    CABINETSTATE cs;
    HWND hdlg = GetParent(hwndList);

    pedii->iIcon = Explorer_GetIconSpecFromRegistry(pedii->tszPathDll);

    if (pedii->tszPathDll[0]) {
        for (iscei = 0; iscei < cA(rgscei); iscei++) {
            if (pedii->iIcon == rgscei[iscei].iIcon &&
                lstrcmpi(pedii->tszPathDll, rgscei[iscei].ptszDll) == 0) {
                break;
            }
        }
    } else {
        iscei = 0;              /* Default */
    }
    if (iscei == IDC_LINKARROW - IDC_LINKFIRST && GetIntPkl(0, &c_klHackPtui)) {
        iscei = IDC_NOARROW - IDC_LINKFIRST;
    }

    /*
     *  Don't need to listen to WM_SETTINGCHANGE because we place the
     *  icon inside a static control which will not resize dynamically.
     */
    pedii->himl = ImageList_Create(GetSystemMetrics(SM_CXICON),
                                   GetSystemMetrics(SM_CYICON), 1,
                                   2, 1);
    if (pedii->himl) {
        HICON hicon;

        hicon = (HICON)SendDlgItemMessage(hdlg, IDC_LINKBEFORE,
                                          STM_GETICON, 0, 0L);
        /* We start with whatever icon got dropped into IDC_BEFORE. */
        ImageList_AddIcon(pedii->himl, hicon);  /* zero */
        ImageList_AddIcon(pedii->himl, hicon);  /* one */

        if (pedii->tszPathDll[0]) {
            hicon = ExtractIcon(hinstCur, pedii->tszPathDll, pedii->iIcon);
            if (ImageList_AddIcon(pedii->himl, hicon) != 1) {
                /* Oh dear */
            }
            SafeDestroyIcon(hicon);
        }

        ImageList_SetOverlayImage(pedii->himl, 1, 1);
        pedii->wpAfter = SubclassWindow(GetDlgItem(hdlg, IDC_LINKAFTER),
                                        Explorer_After_WndProc);
    } else {
        /* Oh dear */
    }
    CheckDlgButton(hdlg, IDC_LINKFIRST + iscei, TRUE);

    pedii->idcCurEffect = -1;
    Explorer_OnEffectChange(hdlg, IDC_LINKFIRST + iscei);

    if (!RegCanModifyKey(pcdii->hkLMExplorer, c_tszShellIcons)) {
        EnableDlgItems(hdlg, IDC_LINKFIRST, IDC_LINKLAST, FALSE);
    }

    int iColorsLeft = 2;

    if (mit.ReadCabinetState && g_fNT) {
        pedii->ccComp.Init(GetDlgItem(hdlg, IDC_COMPRESSBTN));
        pedii->ccComp.SetColor(GetDwordPkl(&c_klAltColor, clrDefAlt));
    } else {
        DestroyDlgItems(hdlg, IDC_COMPRESSFIRST, IDC_COMPRESSLAST);
        iColorsLeft--;
    }

    /*
     *  If COLOR_HOTLIGHT is supported, then do that too.
     */
    if (GetSysColorBrush(COLOR_HOTLIGHT)) {
        pedii->ccHot.Init(GetDlgItem(hdlg, IDC_HOTTRACKBTN));
        pedii->ccHot.SetColor(GetSysColor(COLOR_HOTLIGHT));
    } else {
        DestroyDlgItems(hdlg, IDC_HOTTRACKFIRST, IDC_HOTTRACKLAST);
        iColorsLeft--;
    }

    if (!iColorsLeft) {
        DestroyDlgItems(hdlg, IDC_CLRGROUP, IDC_CLRGROUP);
    }

    pedii->fIconDirty = 0;

    Checklist_OnInitDialog(hwndList, c_rgcliExplorer, cA(c_rgcliExplorer),
                           IDS_EXPLOREREFFECTS, 0);

    PropSheet_UnChanged(GetParent(hdlg), hdlg);
    return 1;
}

/*****************************************************************************
 *
 *  Explorer_ApplyOverlay
 *
 *      This applies the overlay customization.
 *
 *      HackPtui makes life (unfortunately) difficult.  We signal that
 *      HackPtui is necessary by setting the "HackPtui" registry
 *      entry to 1.
 *
 *****************************************************************************/

void PASCAL
Explorer_ApplyOverlay(void)
{
    /*
     *  Assume that nothing special is needed.
     */
    DelPkl(&c_klLinkOvl);
    DelPkl(&c_klHackPtui);

    switch (pedii->idcCurEffect) {
    case IDC_LINKARROW:
        break;                          /* Nothing to do */

    case IDC_NOARROW:                   /* This is the tough one */
        if (g_fBuggyComCtl32) {
            SetIntPkl(1, &c_klHackPtui);
        } else {
            TCH tszBuild[MAX_PATH + 1 + 6];     /* comma + 65535 */
    default:
            wsprintf(tszBuild, c_tszSCommaU, pedii->tszPathDll, pedii->iIcon);
            SetStrPkl(&c_klLinkOvl, tszBuild);
        }
        break;
    }
    Misc_RebuildIcoCache();
    pedii->fIconDirty = 0;
}

/*****************************************************************************
 *
 *  Explorer_OnApply
 *
 *      Write the changes to the registry and force a refresh.
 *
 *      HackPtui makes life (unfortunately) difficult.  We signal that
 *      HackPtui is necessary by setting the "HackPtui" registry
 *      entry to 1.
 *
 *****************************************************************************/

void NEAR PASCAL
Explorer_OnApply(HWND hdlg)
{
    CABINETSTATE cs;
    BOOL fNeedLogoff = FALSE;

    Checklist_OnApply(hdlg, c_rgcliExplorer, &fNeedLogoff, FALSE);
    if (fNeedLogoff) {
        Common_NeedLogoff(hdlg);
    }

    if (pedii->fIconDirty) {
        Explorer_ApplyOverlay();
    }

    if (mit.ReadCabinetState) {
        if (g_fNT && pedii->ccComp.GetColor() !=
            GetDwordPkl(&c_klAltColor, clrDefAlt)) {
            SetDwordPkl(&c_klAltColor, pedii->ccComp.GetColor());
            if (g_fNT5) {
                SendNotifyMessage(HWND_BROADCAST, WM_SETTINGCHANGE, 0, 0);
            } else {
                Common_NeedLogoff(hdlg);
            }
        }
    }

    if (GetSysColorBrush(COLOR_HOTLIGHT)) {
        if (GetSysColor(COLOR_HOTLIGHT) != pedii->ccHot.GetColor()) {
            COLORREF clrHotlight = pedii->ccHot.GetColor();
            TCHAR tsz[64];
            int iColor = COLOR_HOTLIGHT;
            wsprintf(tsz, TEXT("%d %d %d"), GetRValue(clrHotlight),
                    GetGValue(clrHotlight), GetBValue(clrHotlight));
            SetStrPkl(&c_klHotlight, tsz);
            SetSysColors(1, &iColor, &clrHotlight);
        }
    }

}


/*****************************************************************************
 *
 *  Explorer_OnDestroy
 *
 *  Clean up
 *
 *****************************************************************************/

void PASCAL
Explorer_OnDestroy(HWND hdlg)
{
    ImageList_Destroy(pedii->himl);
    pedii->ccComp.Destroy();
    pedii->ccHot.Destroy();
}

/*****************************************************************************
 *
 *  Explorer_OnWhatsThis
 *
 *****************************************************************************/

void PASCAL
Explorer_OnWhatsThis(HWND hwnd, int iItem)
{
    LV_ITEM lvi;

    Misc_LV_GetItemInfo(hwnd, &lvi, iItem, LVIF_PARAM);

    WinHelp(hwnd, c_tszMyHelp, HELP_CONTEXTPOPUP, IDH_PREFIX + lvi.lParam);
}

/*****************************************************************************
 *
 *  Oh yeah, we need this too.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

LVCI lvciExplorer[] = {
    { IDC_WHATSTHIS,        Explorer_OnWhatsThis },
    { 0,                    0 },
};

LVV lvvExplorer = {
    Explorer_OnCommand,
    0,                          /* Explorer_OnInitContextMenu */
    0,                          /* Explorer_Dirtify */
    0,                          /* Explorer_GetIcon */
    Explorer_OnInitDialog,
    Explorer_OnApply,
    Explorer_OnDestroy,
    0,                          /* Explorer_OnSelChange */
    6,                          /* iMenu */
    rgdwHelp,
    0,                          /* Double-click action */
    lvvflCanCheck,              /* We need check boxes */
    lvciExplorer,
};

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *  Our window procedure.
 *
 *****************************************************************************/

INT_PTR EXPORT
Explorer_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    return LV_DlgProc(&lvvExplorer, hdlg, wm, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tweakui\expire.cpp ===
/*
 * expire - Product expiration (for pre-release versions only)
 */

#include "tweakui.h"

#ifdef	PRERELEASE

#pragma BEGIN_CONST_DATA

/*****************************************************************************
 *
 * Beta passwords
 *
 *  The beta password is simply a CRC32 of the beta ID, using the expiration
 *  date as the seed.
 *
 *****************************************************************************/

ConstString(c_tszBetaID, "BetaID");
ConstString(c_tszBetaPwd, "BetaPassword");
ConstString(c_tszBetaExpire, "BetaExpire");

KL const c_klBetaID = { &g_hkLMSMWCV, c_tszAppletTweakUI, c_tszBetaID };
KL const c_klBetaPwd = { &g_hkLMSMWCV, c_tszAppletTweakUI, c_tszBetaPwd };
KL const c_klBetaExpire = { &g_hkLMSMWCV, c_tszAppletTweakUI, c_tszBetaExpire };

/*****************************************************************************
 *
 * CRC32 table
 *
 *****************************************************************************/

typedef unsigned long HASH;

HASH const crctab[] = {
  0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL,
  0x076dc419L, 0x706af48fL, 0xe963a535L, 0x9e6495a3L,
  0x0edb8832L, 0x79dcb8a4L, 0xe0d5e91eL, 0x97d2d988L,
  0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L, 0x90bf1d91L,

  0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
  0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L,
  0x136c9856L, 0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL,
  0x14015c4fL, 0x63066cd9L, 0xfa0f3d63L, 0x8d080df5L,

  0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L, 0xa2677172L,
  0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
  0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L,
  0x32d86ce3L, 0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L,

  0x26d930acL, 0x51de003aL, 0xc8d75180L, 0xbfd06116L,
  0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L, 0xb8bda50fL,
  0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
  0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL,

  0x76dc4190L, 0x01db7106L, 0x98d220bcL, 0xefd5102aL,
  0x71b18589L, 0x06b6b51fL, 0x9fbfe4a5L, 0xe8b8d433L,
  0x7807c9a2L, 0x0f00f934L, 0x9609a88eL, 0xe10e9818L,
  0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,

  0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL,
  0x6c0695edL, 0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L,
  0x65b0d9c6L, 0x12b7e950L, 0x8bbeb8eaL, 0xfcb9887cL,
  0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L, 0xfbd44c65L,

  0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
  0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL,
  0x4369e96aL, 0x346ed9fcL, 0xad678846L, 0xda60b8d0L,
  0x44042d73L, 0x33031de5L, 0xaa0a4c5fL, 0xdd0d7cc9L,

  0x5005713cL, 0x270241aaL, 0xbe0b1010L, 0xc90c2086L,
  0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
  0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L,
  0x59b33d17L, 0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL,

  0xedb88320L, 0x9abfb3b6L, 0x03b6e20cL, 0x74b1d29aL,
  0xead54739L, 0x9dd277afL, 0x04db2615L, 0x73dc1683L,
  0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
  0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L,

  0xf00f9344L, 0x8708a3d2L, 0x1e01f268L, 0x6906c2feL,
  0xf762575dL, 0x806567cbL, 0x196c3671L, 0x6e6b06e7L,
  0xfed41b76L, 0x89d32be0L, 0x10da7a5aL, 0x67dd4accL,
  0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,

  0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L,
  0xd1bb67f1L, 0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL,
  0xd80d2bdaL, 0xaf0a1b4cL, 0x36034af6L, 0x41047a60L,
  0xdf60efc3L, 0xa867df55L, 0x316e8eefL, 0x4669be79L,

  0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
  0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL,
  0xc5ba3bbeL, 0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L,
  0xc2d7ffa7L, 0xb5d0cf31L, 0x2cd99e8bL, 0x5bdeae1dL,

  0x9b64c2b0L, 0xec63f226L, 0x756aa39cL, 0x026d930aL,
  0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
  0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L,
  0x92d28e9bL, 0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L,

  0x86d3d2d4L, 0xf1d4e242L, 0x68ddb3f8L, 0x1fda836eL,
  0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L, 0x18b74777L,
  0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
  0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L,

  0xa00ae278L, 0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L,
  0xa7672661L, 0xd06016f7L, 0x4969474dL, 0x3e6e77dbL,
  0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L, 0x37d83bf0L,
  0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,

  0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L,
  0xbad03605L, 0xcdd70693L, 0x54de5729L, 0x23d967bfL,
  0xb3667a2eL, 0xc4614ab8L, 0x5d681b02L, 0x2a6f2b94L,
  0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL, 0x2d02ef8dL

};

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *  hashFromHashPtsz
 *
 *  Take a seed and a string and hash them.
 *
 *****************************************************************************/

HASH PASCAL
hashFromHashPtsz(HASH hash, LPCTSTR ptsz)
{
    for (; *ptsz; ptsz++) {
	hash = (hash>>8) ^ crctab[(hash^*ptsz)&0xFF];
    }
    return hash;
}

/*****************************************************************************
 *
 *  hashFromEncodedPtsz
 *
 *  Take an encoded string and convert it to a hash.  The encoded string
 *  is just a base-26 encoding, with A = 0, ..., Z = 25.
 *
 *****************************************************************************/

HASH PASCAL
hashFromEncodedPtsz(LPCTSTR ptsz)
{
    HASH hash = 0;
    for (; *ptsz; ptsz++) {
	hash = (hash * 26) + (*ptsz - 'A');
    }
    return hash;
}

/*****************************************************************************
 *
 *  Expire_IsExpiredPwd
 *
 *  Returns nonzero if the password is expired.
 *
 *  The password changes each calendar month.  The seed is the PRERELEASE'th
 *  day of the month.  This ensures that people can't carry beta passwords
 *  across builds.
 *
 *****************************************************************************/

BOOL PASCAL
Expire_IsExpiredPwd(void)
{
    TCHAR tszBetaID[256];
    TCHAR tszBetaPwd[256];
    GetStrPkl(tszBetaID, cbX(tszBetaID), &c_klBetaID);
    GetStrPkl(tszBetaPwd, cbX(tszBetaPwd), &c_klBetaPwd);
    if (tszBetaID[0] && tszBetaPwd[0]) {
	SYSTEMTIME st;
	GetSystemTime(&st);
	return hashFromHashPtsz((st.wYear << 16) +
				    (st.wMonth << 8) + PRERELEASE, tszBetaID) -
						hashFromEncodedPtsz(tszBetaPwd);
    } else {
	return 1;
    }
}

/*****************************************************************************
 *
 *  Expire_OnInitDialog
 *
 *****************************************************************************/

BOOL NEAR PASCAL
Expire_OnInitDialog(HWND hdlg)
{
    TCHAR tszBetaID[256];
    DWORD cb = cA(tszBetaID);
    if (GetStrPkl(tszBetaID, cbX(tszBetaID), &c_klBetaID)||
	GetUserName(tszBetaID, &cb)) {
	AnsiLower(tszBetaID);
	SetDlgItemText(hdlg, 32, tszBetaID);
	SendDlgItemMessage(hdlg, 32, EM_SETREADONLY, 1, 0);
	SetFocus(GetDlgItem(hdlg, 33));
	return 0;
    } else {
    }
    return 1;
}

/*****************************************************************************
 *
 *  Expire_OnCommand
 *
 *****************************************************************************/

void PASCAL
Expire_OnCommand(HWND hdlg, int id, UINT codeNotify)
{
    TCHAR tszBetaID[256];
    TCHAR tszBetaPwd[256];
    switch (id) {
    case IDOK:
	GetDlgItemText(hdlg, 32, tszBetaID, cA(tszBetaID));
	GetDlgItemText(hdlg, 33, tszBetaPwd, cA(tszBetaPwd));
	SetStrPkl(&c_klBetaID, tszBetaID);
	SetStrPkl(&c_klBetaPwd, tszBetaPwd);
	EndDialog(hdlg, Expire_IsExpiredPwd()); break;

    case IDCANCEL:
	EndDialog(hdlg, 1); break;

    }
}

/*****************************************************************************
 *
 *  Expire_DlgProc
 *
 *****************************************************************************/

BOOL EXPORT
Expire_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    switch (wm) {
    case WM_INITDIALOG: return Expire_OnInitDialog(hdlg);

    case WM_COMMAND:
	Expire_OnCommand(hdlg, (int)GET_WM_COMMAND_ID(wParam, lParam),
			        (UINT)GET_WM_COMMAND_CMD(wParam, lParam));
	break;

    default: return 0;	/* Unhandled */
    }
    return 1;		/* Handled */
}


/*****************************************************************************
 *
 *  IsExpired
 *
 *  Returns nonzero if this instance has expired.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA
/*
 *  Simple caesar cipher.  Off-by-one.  We encode the URL so that a casual
 *  reader won't find them.
 *
 *  http://157.55.96.156/tweakrun.html?
 *  http://157.55.96.156/tweakexp.html?
 */
ConstString(c_tszTweakrun, "iuuq;00268/66/:7/2670uxfblsvo/iunm@");
ConstString(c_tszTweakexp, "iuuq;00268/66/:7/2670uxfblfyq/iunm@");

#pragma END_CONST_DATA

BOOL PASCAL
IsExpired(HWND hwnd)
{
    DWORD dw;
    SYSTEMTIME st;
    FILETIME ft;
    PCTSTR ptszExecMe;

    if (Expire_IsExpiredPwd()) {
	if (DialogBox(hinstCur, MAKEINTRESOURCE(IDD_BETAPASSWORD), hwnd,
			        Expire_DlgProc)) {
	    return 1;			/* Expired */
	}
    }

    /*
     *	Not expired.  See if it's time for feedback.
     */
    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &ft);
    dw = GetDwordPkl(&c_klBetaExpire, 0);
    if (dw == 0) {			/* First time */
	ptszExecMe = c_tszTweakrun;
    } else if (dw < ft.dwHighDateTime) {
	ptszExecMe = c_tszTweakexp;
    } else {
	ptszExecMe = 0;
    }
    if (ptszExecMe) {
	PTSTR ptsz;
	TCHAR tszURL[cA(c_tszTweakrun) + MAX_PATH + 1 +
		     MAX_COMPUTERNAME_LENGTH + 1];
	SetDwordPkl(&c_klBetaExpire, ft.dwHighDateTime + 1408);	/* One week */
	lstrcpy(tszURL, ptszExecMe);
	for (ptsz = tszURL; ptsz[0]; ptsz++) {
	    ptsz[0]--;
	}
	GetStrPkl(ptsz, cbCtch(MAX_PATH), &c_klBetaID);
	lstrcat(ptsz, TEXT("?"));
	dw = MAX_COMPUTERNAME_LENGTH + 1;
	GetComputerName(ptsz + lstrlen(ptsz), &dw);
	ShellExecute(0, 0, tszURL, 0, 0, SW_NORMAL);
    }
    return 0;
}

#endif	/* PRERELEASE */

#ifdef PUBLIC_PRERELEASE

/*****************************************************************************
 *
 *  IsExpired
 *
 *  Returns nonzero if this instance has expired.
 *
 *****************************************************************************/

/* August 15, 2000 */
const FILETIME c_ftExpire = { 0xC1328000, 0x01C0064B };

BOOL PASCAL
IsExpired(HWND hwnd)
{
    SYSTEMTIME st;
    FILETIME ft;

    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &ft);
    if (CompareFileTime(&ft, &c_ftExpire) >= 0) {
        MessageBox(hwnd, TEXT("This prerelease version of Tweak UI has expired"),
                   g_tszName, MB_OK);
        return TRUE;
    }

    return 0;
}

#endif  /* PUBLIC_PRERELEASE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tweakui\desktop.cpp ===
/*
 * desktop - Dialog box property sheet for "desktop customization"
 */

#include "tweakui.h"

#pragma BEGIN_CONST_DATA

#define c_tszCLSIDMyDocs TEXT("CLSID\\{450D8FBA-AD25-11D0-98A8-0800361B1103}")
#define c_tszParseMyDocs TEXT("::{450D8FBA-AD25-11D0-98A8-0800361B1103}")
#define c_tszParseMyComp TEXT("::{20D04FE0-3AEA-1069-A2D8-08002B30309D}")

KL const c_klMyDocsOrder = { &c_hkCR, c_tszCLSIDMyDocs, TEXT("SortOrderIndex") };

#define ORDER_BEFOREMYCOMP      0x48
#define ORDER_AFTERMYCOMP       0x54

const static DWORD CODESEG rgdwHelp[] = {
	IDC_ICONLVTEXT,		IDH_GROUP,
	IDC_ICONLVTEXT2,	IDH_ICONLV,
	IDC_ICONLV,		IDH_ICONLV,
	IDC_CREATENOWTEXT,	IDH_GROUP,
	IDC_CREATENOW,		IDH_CREATENOW,
	IDC_ENUMFIRSTTEXT,      IDH_DESKFIRSTICON,
	IDC_ENUMFIRST,          IDH_DESKFIRSTICON,
#if 0
	IDC_RESET,		IDH_RESET,
#endif
	0,			0,
};

#pragma END_CONST_DATA

/*
 * cchFriendlyMax should be at least MAX_PATH, because we also use it
 * to hold icon file names.
 */
#define cchFriendlyMax 256

/*
 *  Evil hack!  Since the ::{guid} hack doesn't work unless the object
 *  really exists in the name space, we pull an evil trick and just
 *  create the idlist that the shell would've made if you had asked for
 *  it...
 */
typedef struct RIDL {
    USHORT cb;		    /* Must be 20 */
    BYTE   bFlags;          /* Must be 0x1F */
    BYTE   bOrder;          /* Sorting order */
    CLSID clsid;	    /* Guid goes here */
    USHORT zero;	    /* Must be zero */
} RIDL, *PRIDL;

#define pidlPnsi(pnsi) ((PIDL)&(pnsi)->ridl)

/*
 * The only abnormal key is Network Neighborhood, since its presence
 * is controlled by a system policy...
 *
 * You need to set nsiflNever if something should not have a check
 * box next to it because it cannot be added to the namespace.
 *
 * You need to set nsiflDir for things that aren't valid namespace
 * items but should be created as directory-like objects.
 *
 * Briefcase is doubly abnormal, because it doesn't do anything at all!
 * So we just exclude him from the enumeration.
 */

typedef BYTE NSIFL;		/* Random flags */
#define nsiflNormal 1		/* Is a regular thing */
#define nsiflDir 2		/* Is a directory-like object */
#define nsiflNever 4		/* Not a valid namespace item */
#define nsiflEdited 8		/* The name has been edited */

typedef struct NSI {		/* namespace item */
    NSIFL nsifl;		/* Is this a normal regkey? */
    TCH tszClsid[ctchClsid];	/* Class id */
    RIDL ridl;			/* Regitem idlist */
} NSI, *PNSI;

#define insiPlvi(plvi) ((UINT)(plvi)->lParam)
#define pnsiInsi(insi) (&pddii->pnsi[insi])
#define pnsiPlvi(plvi) pnsiInsi(insiPlvi(plvi))

typedef struct DDII {
    Declare_Gxa(NSI, nsi);
    HKEY    hkNS;
    int     iFirstIcon;
} DDII, *PDDII;

DDII ddii;
#define pddii (&ddii)

/*****************************************************************************
 *
 *  Desktop_GetClsidAttributes
 *
 *  Return the Attributes registry key for a class id.
 *
 *****************************************************************************/

#define ctchPathShellFolder 21

DWORD PASCAL
Desktop_GetClsidAttributes(PCTSTR ptszClsid)
{
    TCH tsz[ctchPathShellFolder + ctchClsid];
    wsprintf(tsz, c_tszPathShellFolder, ptszClsid);
    return GetRegDword(hhkCR, tsz, c_tszAttributes, 0);
}

/*****************************************************************************
 *
 *  Desktop_HasSubkey
 *
 *  Return whether the key has a child key with the specified name.
 *
 *****************************************************************************/

BOOL PASCAL
Desktop_HasSubkey(HKEY hk, LPCTSTR ptszChild)
{
    HKEY hkS;
    if (_RegOpenKey(hk, ptszChild, &hkS) == 0) {
	RegCloseKey(hkS);
	return 1;
    } else {
	return 0;
    }
}

/*****************************************************************************
 *
 *  Desktop_IsNSKey
 *
 *  Determine whether the specified class is in the desktop namespace
 *  right now.
 *
 *****************************************************************************/

#define Desktop_IsNSKey(ptszClsid) Desktop_HasSubkey(pddii->hkNS, ptszClsid)

/*****************************************************************************
 *
 *  Desktop_GetNetHood
 *
 *  Determine whether the network neighborhood is visible now.
 *
 *****************************************************************************/

#define Desktop_GetNetHood() GetRestriction(c_tszNoNetHood)

/*****************************************************************************
 *
 *  Desktop_SetNetHood
 *
 *  Set the new network neighborhood visibility.
 *
 *****************************************************************************/

#define Desktop_SetNetHood(f) SetRestriction(c_tszNoNetHood, f)

/*****************************************************************************
 *
 *  Desktop_IsHereNow
 *
 *	Determine the state of the object as it is in the world today.
 *
 *****************************************************************************/

#define Desktop_IsHereNow(pnsi, ptszClsid) \
    ((pnsi->nsifl & nsiflNormal) ? Desktop_IsNSKey(ptszClsid) \
				 : Desktop_GetNetHood())

/*****************************************************************************
 *
 *  Desktop_AddNSKey
 *
 *  Okay, we've committed ourselves to adding the key to the listview.
 *  No turning back now!
 *
 *  We default to the shared desktop, so set the initial state accordingly.
 *
 *****************************************************************************/

void PASCAL
Desktop_AddNSKey(HWND hwnd, PNSI pnsi, LPCTSTR ptszClsid,
		 LPCTSTR ptszFriendly, int iImage, NSIFL nsifl)
{
    pnsi->nsifl = nsifl;
    lstrcpy(pnsi->tszClsid, ptszClsid);
    LV_AddItem(hwnd, pddii->cnsi++, ptszFriendly, iImage,
	       (nsifl & nsiflNever) ? -1 : Desktop_IsHereNow(pnsi, ptszClsid));
}

/*****************************************************************************
 *
 *  Desktop_MakeRidl
 *
 *  Initialize a RIDL from a GUID display name.
 *
 *****************************************************************************/

HRESULT PASCAL
Desktop_MakeRidl(PNSI pnsi, LPCTSTR ptszClsid)
{
    pnsi->ridl.cb = 20;	    /* Always */
    pnsi->ridl.bFlags = 0x1F;  /* Always */
    pnsi->ridl.bOrder = 0;  /* Unsorted */
    pnsi->ridl.zero = 0;    /* Always */
    return Ole_ClsidFromString(ptszClsid, &pnsi->ridl.clsid);
}

/*****************************************************************************
 *
 *  Desktop_ShouldUseNSClsid
 *
 *  Check if this is a CLSID we should bother showing.
 *
 *****************************************************************************/

const GUID c_rgguidExclude[] = {
    /*
     *  These must be rooted on a filesystem object.
     */
    { 0x85BBD920, 0x42A0, 0x1069, { 0xA2, 0xE4, 0x08, 0x00, 0x2B, 0x30, 0x30, 0x9D} }, /* Briefcase */
    { 0x1A9BA3A0, 0x143A, 0x11CF, { 0x83, 0x50, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00} }, /* Shell Favorites */
    { 0xAFDB1F70, 0x2A4C, 0x11d2, { 0x90, 0x39, 0x00, 0xC0, 0x4F, 0x8E, 0xEB, 0x3E} }, /* Offline Files Folder */
    { 0x0CD7A5C0, 0x9F37, 0x11CE, { 0xAE, 0x65, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62} }, /* Cabinet File */
    { 0x88C6C381, 0x2E85, 0x11d0, { 0x94, 0xDE, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00} }, /* ActiveX Cache Folder */
    { 0xE88DCCE0, 0xB7B3, 0x11d1, { 0xA9, 0xF0, 0x00, 0xAA, 0x00, 0x60, 0xFA, 0x31} }, /* Compressed Folder (Zip) */

    /*
     *  These simply weren't meant to be seen.
     */
    { 0x1f4de370, 0xd627, 0x11d1, { 0xba, 0x4f, 0x00, 0xa0, 0xc9, 0x1e, 0xed, 0xba} }, /* Search Results - Computers */
    { 0x63da6ec0, 0x2e98, 0x11cf, { 0x8d, 0x82, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00} }, /* Microsoft FTP Folder */

    /*
     *  These have other ways of being hidden.
     */
    { 0x450D8FBA, 0xAD25, 0x11D0, { 0x98, 0xA8, 0x08, 0x00, 0x36, 0x1B, 0x11, 0x03} }, /* My Documents */
};



    /*
     *  The Win98 "Networking and Dial-Up Connections" CLSID is excluded on NT5.
     *  (They leave it around for back compat reasons but it shouldn't be
     *  exposed to the user.)
     */
const GUID c_clsidDUN98 =
    { 0x992CFFA0, 0xF557, 0x101A, { 0x88, 0xEC, 0x00, 0xDD, 0x01, 0x0C, 0xCC, 0x48} };

const GUID c_clsidIE =
    { 0x871C5380, 0x42A0, 0x1069, { 0xA2, 0xEA, 0x08, 0x00, 0x2B, 0x30, 0x30, 0x9D} };

BOOL PASCAL
Desktop_ShouldUseNSClsid(PNSI pnsi)
{
    int i;

    for (i = 0; i < cA(c_rgguidExclude); i++) {
        if (IsEqualGUID(pnsi->ridl.clsid, c_rgguidExclude[i])) {
            return FALSE;
        }
    }

    if (g_fNT5 && IsEqualGUID(pnsi->ridl.clsid, c_clsidDUN98)) {
        return FALSE;
    }

    /*
     *  If IE5 is installed, then it already has the "Show IE on desktop"
     *  setting in its Advanced dialog.  Don't need one here.
     */
    if (IsEqualGUID(pnsi->ridl.clsid, c_clsidIE) &&
        (g_fShell5 || RegKeyExists(g_hkLMSMIE, TEXT("AdvancedOptions\\BROWSEE\\IEONDESKTOP")))) {
        return FALSE;
    }

    return TRUE;
}

/*****************************************************************************
 *
 *  Desktop_CheckNSKey
 *
 *  Check and possibly add a new namespace key.  My Computer is
 *  excluded because you can't get rid of it.  Network Neighborhood
 *  is here, although it is somewhat weird.  We handle the weirdness
 *  as it arises...
 *
 *  All that has been validated so far is that the key exists, it
 *  has a ShellEx subkey, and it has nonzero attributes.
 *
 *  We haven't yet validated that it has an icon.  We'll notice that
 *  when we try to build up the listview info.
 *
 *  And people complain that lisp has too many levels of nesting...
 *
 *****************************************************************************/

void PASCAL
Desktop_CheckNSKey(HWND hwnd, HKEY hk, LPCTSTR ptszClsid, NSIFL nsifl)
{
    PNSI pnsi = (PNSI)Misc_AllocPx(&pddii->gxa);
    if (pnsi) {
	if (SUCCEEDED(Desktop_MakeRidl(pnsi, ptszClsid)) &&
            Desktop_ShouldUseNSClsid(pnsi)) {
	    SHFILEINFO sfi;
	    if (SHGetFileInfo((LPCSTR)pidlPnsi(pnsi), 0, &sfi, cbX(sfi),
		SHGFI_PIDL | SHGFI_DISPLAYNAME | SHGFI_SYSICONINDEX |
		SHGFI_SMALLICON)) {
		/*
		 * gacky Net Hood hack.  Shell won't give me a name
		 * if I don't have one in the registry.
		 */
		if (sfi.szDisplayName[0] == 0 && !(nsifl & nsiflNormal)) {
		    LoadString(hinstCur, IDS_NETHOOD,
			       sfi.szDisplayName, cA(sfi.szDisplayName));
		}

		/*
		 *  It must have a name and must have a custom icon.
		 */
		if (sfi.szDisplayName[0] && sfi.iIcon != 3) {
		    Desktop_AddNSKey(hwnd, pnsi, ptszClsid, sfi.szDisplayName,
				     sfi.iIcon, nsifl);
		}
	    } /* couldn't get file info */
	} /* not a valid guid */
    } /* else no memory to store this entry */
}

/*****************************************************************************
 *
 *  Desktop_AddSpecialNSKey
 *
 *	Add some special namespace keys, which eluded our enumeration.
 *
 *****************************************************************************/

void PASCAL
Desktop_AddSpecialNSKey(HWND hwnd, LPCTSTR ptszClsid, NSIFL nsifl)
{
    int insi;
    HKEY hk;
    for (insi = 0; insi < pddii->cnsi; insi++) {
	if (lstrcmpi(pddii->pnsi[insi].tszClsid, ptszClsid) == 0) {
	    goto found;
	}
    }

    hk = hkOpenClsid(ptszClsid);
    if (hk) {
	Desktop_CheckNSKey(hwnd, hk, ptszClsid, nsifl);
	RegCloseKey(hk);
    }
    found:;
}

/*****************************************************************************
 *
 *  Desktop_EnumClasses
 *
 *  Locate all the classes that are possible namespace keys.
 *
 *****************************************************************************/

void PASCAL
Desktop_EnumClasses(HWND hwnd)
{
    int ihk;
    TCH tsz[ctchClsid];
    for (ihk = 0; RegEnumKey(pcdii->hkClsid, ihk, tsz, cA(tsz)) == 0; ihk++) {
	HKEY hk = hkOpenClsid(tsz);
	if (hk) {
	    if (Desktop_GetClsidAttributes(tsz)) {
		Desktop_CheckNSKey(hwnd, hk, tsz, nsiflNormal);
	    }
	    RegCloseKey(hk);
	}
    }

    Desktop_AddSpecialNSKey(hwnd, c_tszClsidNetHood, nsiflDir);
    Desktop_AddSpecialNSKey(hwnd, c_tszClsidCpl,
			    nsiflNormal | nsiflNever | nsiflDir);
    Desktop_AddSpecialNSKey(hwnd, c_tszClsidPrint,
			    nsiflNormal | nsiflNever | nsiflDir);
    Misc_LV_SetCurSel(hwnd, 0);		/* Default to top of list */
}

/*****************************************************************************
 *
 *  Desktop_OnInitDialog
 *
 *  We have much nontrivial work to do.  Fill all the list boxes with
 *  defaults.
 *
 *****************************************************************************/

BOOL PASCAL
Desktop_OnInitDialog(HWND hwnd)
{
    ZeroMemory(pddii, cbX(*pddii));

    CWaitCursor wc;

    if (Misc_InitPgxa(&pddii->gxa, cbX(NSI))) {
	if (RegCreateKey(pcdii->hkLMExplorer, c_tszDesktopNameSpace,
			 &pddii->hkNS) == 0) {
	    Desktop_EnumClasses(hwnd);
	}
    }

    /*
     *  Set the order for My Documents if it exists.
     */
    HWND hdlg = GetParent(hwnd);

    PRIDL pridl = (PRIDL)pidlFromPath(psfDesktop, c_tszParseMyDocs);
    if (pridl && (pridl->bOrder == ORDER_BEFOREMYCOMP ||
                  pridl->bOrder == ORDER_AFTERMYCOMP))
    {
        SHFILEINFO sfi;
        HWND hwndCombo = GetDlgItem(hdlg, IDC_ENUMFIRST);

        /* Item 0 = My Documents */
        SHGetFileInfo((LPCSTR)pridl, 0, &sfi, cbX(sfi), SHGFI_PIDL | SHGFI_DISPLAYNAME);
        ComboBox_AddString(hwndCombo, sfi.szDisplayName);

        /* Item 1 = My Computer */
        SHGetFileInfo(c_tszParseMyComp, 0, &sfi, cbX(sfi), SHGFI_DISPLAYNAME);
        ComboBox_AddString(hwndCombo, sfi.szDisplayName);

        pddii->iFirstIcon = pridl->bOrder == ORDER_AFTERMYCOMP;
        ComboBox_SetCurSel(hwndCombo, pddii->iFirstIcon);

    } else {
        DestroyDlgItems(hdlg, IDC_ENUMFIRSTTEXT, IDC_ENUMFIRST);
    }

    return 1;
}

/*****************************************************************************
 *
 *  Desktop_OnDestroy
 *
 *  Free the memory we allocated.
 *
 *  We also destroy the imagelist, because listview gets confused if
 *  it gets two image lists which are the same.
 *
 *****************************************************************************/

void PASCAL
Desktop_OnDestroy(HWND hdlg)
{
    Misc_FreePgxa(&pddii->gxa);
    if (pddii->hkNS) {
	RegCloseKey(pddii->hkNS);
    }
}

#if 0
/*****************************************************************************
 *
 *  Desktop_FactoryReset
 *
 *	This is scary and un-undoable, so let's do extra confirmation.
 *
 *****************************************************************************/

void PASCAL
Desktop_FactoryReset(HWND hdlg)
{
    if (MessageBoxId(hdlg, IDS_DESKTOPRESETOK,
		     tszName, MB_YESNO + MB_DEFBUTTON2) == IDYES) {
	pcdii->fRunShellInf = 1;
	Common_NeedLogoff(hdlg);
	PropSheet_Apply(GetParent(hdlg));
    }
}
#endif

/*****************************************************************************
 *
 *  Desktop_OnCreateNow
 *
 *	Somebody asked to create another one...
 *
 *	Use common dialogs to do the work.
 *
 *****************************************************************************/

void PASCAL
Desktop_OnCreateNow(HWND hwnd, int iItem)
{
    LV_ITEM lvi;
    COFN cofn;

    lvi.pszText = cofn.tsz;
    lvi.cchTextMax = cA(cofn.tsz);
    Misc_LV_GetItemInfo(hwnd, &lvi, iItem, LVIF_PARAM | LVIF_TEXT);

    InitOpenFileName(GetParent(hwnd), &cofn, IDS_ALLFILES, cofn.tsz);
    cofn.ofn.nMaxFile -= ctchClsid + 1;	/* Leave room for dot and clsid */
    cofn.ofn.Flags |= OFN_NOREADONLYRETURN;

    if (GetSaveFileName(&cofn.ofn)) {
	PNSI pnsi;
	lstrcat(cofn.tsz, c_tszDot);
	pnsi = pnsiPlvi(&lvi);
	lstrcat(cofn.tsz, pnsi->tszClsid);
	if ((pnsi->nsifl & nsiflDir) ||
	    Desktop_GetClsidAttributes(pnsi->tszClsid) & SFGAO_FOLDER) {
	    CreateDirectory(cofn.tsz, 0);
	} else {
	    fCreateNil(cofn.tsz);
	}
    }
}

/*****************************************************************************
 *
 *  Desktop_OnCommand
 *
 *****************************************************************************/

void PASCAL
Desktop_OnCommand(HWND hdlg, int id, UINT codeNotify)
{
    switch (id) {
#if 0
    case IDC_RESET:
	if (codeNotify == BN_CLICKED) {
	    Desktop_FactoryReset(hdlg);
	}
	break;
#endif

    case IDC_ENUMFIRST:
        if (codeNotify == CBN_SELCHANGE) {
            Common_SetDirty(hdlg);
        }
        break;

    }
}

/*****************************************************************************
 *
 *  Desktop_LV_Dirtify
 *
 *	Mark this item as having been renamed during the property sheet
 *	page's lifetime.
 *
 *****************************************************************************/

void PASCAL
Desktop_LV_Dirtify(LPARAM insi)
{
    pddii->pnsi[insi].nsifl |= nsiflEdited;
}

/*****************************************************************************
 *
 *  Desktop_LV_GetIcon
 *
 *	Produce the icon associated with an item.  This is called when
 *	we need to rebuild the icon list after the icon cache has been
 *	purged.
 *
 *****************************************************************************/

int PASCAL
Desktop_LV_GetIcon(LPARAM insi)
{
    SHFILEINFO sfi;
    sfi.iIcon = 0;
    SHGetFileInfo((LPCSTR)pidlPnsi(pnsiInsi(insi)), 0, &sfi, cbX(sfi),
	SHGFI_PIDL | SHGFI_SYSICONINDEX | SHGFI_SMALLICON);
    return sfi.iIcon;
}

/*****************************************************************************
 *
 *  Desktop_OnSelChange
 *
 *	Disable the "Create as File" button if we are on Net Hood.
 *
 *****************************************************************************/

void PASCAL
Desktop_OnSelChange(HWND hwnd, int iItem)
{
    PNSI pnsi = pnsiInsi(Misc_LV_GetParam(hwnd, iItem));
    EnableWindow(GetDlgItem(GetParent(hwnd), IDC_CREATENOW),
		 pnsi->nsifl & nsiflNormal);
}

/*****************************************************************************
 *
 *  Desktop_OnApply
 *
 *	Write the changes to the registry.
 *
 *****************************************************************************/

void PASCAL
Desktop_OnApply(HWND hdlg)
{
    HWND hwnd = GetDlgItem(hdlg, IDC_ICONLV);
    int cItems = ListView_GetItemCount(hwnd);
    BOOL fChanged = 0;
    LV_ITEM lvi;
    TCH tsz[cchFriendlyMax];

    lvi.pszText = tsz;
    lvi.cchTextMax = cA(tsz);

    for (lvi.iItem = 0; lvi.iItem < cItems; lvi.iItem++) {
	PNSI pnsi;
	lvi.stateMask = LVIS_STATEIMAGEMASK;
	Misc_LV_GetItemInfo(hwnd, &lvi, lvi.iItem,
			    LVIF_PARAM | LVIF_TEXT | LVIF_STATE);
	pnsi = pnsiPlvi(&lvi);

	if (Desktop_IsHereNow(pnsi, pnsi->tszClsid) != LV_IsChecked(&lvi)) {
	    fChanged = 1;
	    if (pnsi->nsifl & nsiflNormal) {
		if (LV_IsChecked(&lvi)) {
		    HKEY hk;
		    if (RegCreateKey(pddii->hkNS, pnsi->tszClsid, &hk) == 0) {
			RegSetValuePtsz(hk, 0, lvi.pszText);
			RegCloseKey(hk);
		    }
		} else {
		    RegDeleteTree(pddii->hkNS, pnsi->tszClsid);
		}
	    } else {		/* Ah, the Net Hood... */
		Desktop_SetNetHood(LV_IsChecked(&lvi));
		Common_NeedLogoff(hdlg);
		if (!LV_IsChecked(&lvi)) {
		    if (MessageBoxId(hdlg, IDS_NONETHOOD, g_tszName, MB_YESNO)
				    == IDYES) {
			WinHelp(hdlg, c_tszMyHelp, HELP_CONTEXT, IDH_NONETHOOD);
		    }
		}
	    }
	}

	/*  Not worth cacheing this */
	if (pnsi->nsifl & nsiflEdited) {
	    SetNameOfPidl(psfDesktop, pidlPnsi(pnsi), lvi.pszText);
	    SHChangeNotify(SHCNE_UPDATEIMAGE, SHCNF_DWORD,
			   IntToPtr(lvi.iImage), 0L);
	}
    }

    HWND hwndCombo = GetDlgItem(hdlg, IDC_ENUMFIRST);
    int iFirstIcon = ComboBox_GetCurSel(hwndCombo);
    if (iFirstIcon != pddii->iFirstIcon) {
        SetDwordPkl2(&c_klMyDocsOrder, iFirstIcon ? ORDER_AFTERMYCOMP : ORDER_BEFOREMYCOMP);
        pddii->iFirstIcon = iFirstIcon;
        MessageBoxId(hdlg, IDS_REORDERDESKTOP, g_tszName, MB_OK);
        fChanged = TRUE;
    }

    if (fChanged) {
	SHChangeNotify(SHCNE_ASSOCCHANGED, SHCNF_DWORD, 0L, 0L);
    }
}

/*****************************************************************************
 *
 *  Desktop_LV_OnInitContextMenu
 *
 *	Propagate the status of the Create Now button.
 *
 *****************************************************************************/

void PASCAL
Desktop_LV_OnInitContextMenu(HWND hwnd, int iItem, HMENU hmenu)
{
    Misc_EnableMenuFromHdlgId(hmenu, GetParent(hwnd), IDC_CREATENOW);
}

/*****************************************************************************
 *
 *  Oh yeah, we need this too.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

LVCI lvciDesktop[] = {
    { IDC_CREATENOW,        Desktop_OnCreateNow },
    { 0,                    0 },
};

LVV lvvDesktop = {
    Desktop_OnCommand,
    Desktop_LV_OnInitContextMenu,
    Desktop_LV_Dirtify,
    Desktop_LV_GetIcon,
    Desktop_OnInitDialog,
    Desktop_OnApply,
    Desktop_OnDestroy,
    Desktop_OnSelChange,
    1,				/* iMenu */
    rgdwHelp,
    0,				/* Double-click action */
    lvvflIcons |                /* We need icons */
    lvvflCanCheck |             /* And check boxes */
    lvvflCanRename,             /* and you can rename by clicking */
    lvciDesktop,
};

#pragma END_CONST_DATA


/*****************************************************************************
 *
 *  Our window procedure.
 *
 *****************************************************************************/

INT_PTR EXPORT
Desktop_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    return LV_DlgProc(&lvvDesktop, hdlg, wm, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tweakui\control.cpp ===
/*
 * control - Dialog box property sheet for "control panel"
 */

#include "tweakui.h"

/*
 * cchFriendlyMax is used to hold control panel file descriptions.
 */
#define cchFriendlyMax 256

typedef struct CPL {            /* control panel */
    TCHAR tszFile[MAX_PATH];    /* File name */
} CPL, *PCPL;

#define icplPlvi(plvi) ((UINT)(plvi)->lParam)
#define pcplIcpl(icpl) (&pcpii->pcpl[icpl])
#define pcplPlvi(plvi) pcplIcpl(icplPlvi(plvi))

typedef struct CPII {
    Declare_Gxa(CPL, cpl);
} CPII, *PCPII;

CPII cpii;
#define pcpii (&cpii)

TCHAR g_tszBoring[64];

#pragma BEGIN_CONST_DATA

const static DWORD CODESEG rgdwHelp[] = {
        0,                      0,
};

/*****************************************************************************
 *
 *  Control_VerQueryDescription
 *
 *  pull out the file description if we have one.
 *
 *****************************************************************************/

BOOL PASCAL
Control_VerQueryDescription(LPVOID pvData, UINT uiLang, UINT uiCharSet,
                            LPTSTR ptszBuf, UINT ctch)
{
    TCHAR tsz[128];
    LPWSTR pwsz;
    BOOL fRc;
    UINT cb;

    wsprintf(tsz, TEXT("\\StringFileInfo\\%04X%04X\\")
                  TEXT("FileDescription"), uiLang, uiCharSet);
    fRc = VerQueryValue(pvData, tsz, (LPVOID *)&pwsz, &cb);

    if (fRc && cb > 0) {
#ifdef UNICODE
        lstrcpyn(ptszBuf, pwsz, ctch);
#else
        WideCharToMultiByte(CP_ACP, 0, pwsz, cb / cbX(WCHAR),
                            ptszBuf, MAX_PATH, NULL, NULL);
        lstrcpyn(ptszBuf, (LPSTR)pwsz, ctch);
#endif
    }

    return fRc;
}


/*****************************************************************************
 *
 *  Control_GetFileDescription
 *
 *  pull out the file description if we have one.
 *
 *****************************************************************************/

void PASCAL
Control_GetFileDescription(LPTSTR ptszFile, LPTSTR ptszBuf, UINT ctch)
{
    DWORD dwHandle;
    UINT cb;

    /*
     *  Assume it doesn't work.
     */
    ptszBuf[0] = TEXT('\0');

    cb = GetFileVersionInfoSize(ptszFile, &dwHandle);
    if (cb) {
        LPVOID pvData = lAlloc(cb);
        if (pvData) {
            LPWORD rgwTrans;
            UINT uiSize;

            if (GetFileVersionInfo(ptszFile, dwHandle, cb, pvData) &&
                VerQueryValue(pvData, TEXT("\\VarFileInfo\\Translation"),
                              (LPVOID *)&rgwTrans, &uiSize)) {
                if (Control_VerQueryDescription(pvData,
                                                rgwTrans[0], rgwTrans[1],
                                                ptszBuf, ctch) ||
                    /*
                     *  Lots of people forget to set the language properly,
                     *  so we will try English/USA regardless.  And if that
                     *  doesn't work, try English/NULL because some people
                     *  do that too.
                     */
                    Control_VerQueryDescription(pvData,
                                                0x0409, 0x040E,
                                                ptszBuf, ctch) ||
                    Control_VerQueryDescription(pvData,
                                                0x0409, 0x0000,
                                                ptszBuf, ctch)) {
                }
            }
            lFree(pvData);
        }
    }
}

/*****************************************************************************
 *
 *  Control_GetShowState
 *
 *  Determine whether a *.CPL file is currently shown in the
 *  Control Panel.
 *
 *****************************************************************************/

BOOL PASCAL
Control_GetShowState(LPCTSTR ptszName)
{
    TCHAR tsz[10];

    GetPrivateProfileString(c_tszDontLoad, ptszName,
                            c_tszNil, tsz, cA(tsz), c_tszControlIni);

    return tsz[0] ? FALSE : TRUE;

}

/*****************************************************************************
 *
 *  Control_SetShowState
 *
 *  Set the registry/INI flag that tells us to hide/show the *.CPL file.
 *
 *****************************************************************************/

void PASCAL
Control_SetShowState(LPCTSTR ptszName, BOOL fShow)
{
    WritePrivateProfileString(c_tszDontLoad, ptszName,
                              fShow ? NULL : c_tszNo, c_tszControlIni);
}

/*****************************************************************************
 *
 *  Control_AddCpl
 *
 *  Add a single *.CPL to the list.
 *
 *  The display name is the CPL filename, followed by an optional
 *  parenthesized version description string.  For control panels
 *  that ship with Windows 95 whose version strings isn't very good, we substitute
 *  our own.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

LPCTSTR c_rgpszCpl[] = {
    c_tszAppWizCpl,
    c_tszDeskCpl,
    c_tszIntlCpl,
    c_tszMainCpl,
    c_tszTimeDateCpl,
};

int PASCAL
Control_AddCpl(HWND hwnd, LPTSTR ptszName)
{
    //
    //  On Windows 2000, ncpa.cpl is a stub that exists only for legacy
    //  purposes.  It does exactly the same thing as the "Network
    //  Connections" icon that already exists in the Control Panel.
    //
    if (g_fNT5 && lstrcmpi(ptszName, TEXT("ncpa.cpl")) == 0) {
        return -1;
    }

    PCPL pcpl = (PCPL)Misc_AllocPx(&pcpii->gxa);
    TCHAR tszDesc[MAX_PATH];
    TCHAR tszFull[MAX_PATH + 3 + MAX_PATH]; /* 3 = " - " */

    if (pcpl) {
        lstrcpy(pcpl->tszFile, ptszFilenameCqn(ptszName));
        CharLower(pcpl->tszFile);

        Control_GetFileDescription(ptszName, tszDesc, MAX_PATH);

        /*
         *  Now clean up various weird cases.
         */
        if (lstrcmpi(tszDesc, g_tszBoring) == 0) {
            int i;
            for (i = 0; i < cA(c_rgpszCpl); i++) {
                if (lstrcmpi(pcpl->tszFile, c_rgpszCpl[i]) == 0) {
                    LoadString(hinstCur, IDS_CPL_ADDRM + i, tszDesc, cA(tszDesc));
                    break;
                }
            }
        }

        wsprintf(tszFull, TEXT("%s - %s"), pcpl->tszFile, tszDesc);

        return LV_AddItem(hwnd, pcpii->ccpl++, tszFull, -1,
                          Control_GetShowState(pcpl->tszFile));
    } else {
        return -1;
    }
}

/*****************************************************************************
 *
 *  Control_InitControls2
 *
 *  Enumerate all the special DLLs in the MMCPL section and add them
 *  to the list.  Note that the buffer sizes are exactly the same sizes
 *  that SHELL32 uses, so we won't miss anything that the shell itself
 *  doesn't.
 *
 *****************************************************************************/

void PASCAL
Control_InitControls2(HWND hwnd)
{
    LPTSTR ptsz;
    TCHAR tszKeys[512];
    TCHAR tszName[64];

    GetPrivateProfileString(TEXT("MMCPL"), NULL, c_tszNil,
                            tszKeys, cA(tszKeys), c_tszControlIni);

    for (ptsz = tszKeys; ptsz[0]; ptsz += lstrlen(ptsz) + 1) {
        /*
         *  Some legacy keys to ignore:
         *
         *  NumApps=        <number of applets>
         *  H=              <height>
         *  W=              <width>
         *  X=              <x coordinate>
         *  Y=              <y coordinate>
         */
        if (lstrcmpi(ptsz, TEXT("NumApps")) == 0) {
            continue;
        }
        if (ptsz[1] == TEXT('\0')) {
            switch (ptsz[0]) {
            case 'H':
            case 'W':
            case 'X':
            case 'Y': continue;
            }
        }

        /*
         *  End of wacky legacy keys.
         */

        GetPrivateProfileString(TEXT("MMCPL"), ptsz, c_tszNil,
                                tszName, cA(tszName), c_tszControlIni);
        Control_AddCpl(hwnd, tszName);
    }
}

/*****************************************************************************
 *
 *  Control_InitControls3
 *
 *  Enumerate all the *.CPL files in the System folder
 *  and add them to the list.
 *
 *****************************************************************************/

void PASCAL
Control_InitControls3(HWND hwnd)
{
    WIN32_FIND_DATA wfd;
    HANDLE h;
    TCHAR tszSystemDir[MAX_PATH];
    TCHAR tszPrevDir[MAX_PATH];

    if (GetCurrentDirectory(cA(tszPrevDir), tszPrevDir) && /* For restore */
        GetSystemDirectory(tszSystemDir, MAX_PATH) &&
        SetCurrentDirectory(tszSystemDir)) {

        h = FindFirstFile(c_tszStarCpl, &wfd);
        if (h != INVALID_HANDLE_VALUE) {
            do {
                Control_AddCpl(hwnd, wfd.cFileName);
            } while (FindNextFile(h, &wfd)) ;
            FindClose(h);
        }
        SetCurrentDirectory(tszPrevDir);
    }
}

/*****************************************************************************
 *
 *  Control_OnInitDialog
 *
 *  Enumerate all the *.CPL files and add them to the list.
 *
 *****************************************************************************/

BOOL PASCAL
Control_OnInitDialog(HWND hwnd)
{
    HCURSOR hcurPrev = GetCursor();
    SetCursor(LoadCursor(0, IDC_WAIT));

    ZeroMemory(pcpii, cbX(*pcpii));

    LoadString(hinstCur, IDS_CPL_BORING, g_tszBoring, cA(g_tszBoring));

    if (Misc_InitPgxa(&pcpii->gxa, cbX(CPL))) {
        Control_InitControls2(hwnd);
        Control_InitControls3(hwnd);
    }

    SetCursor(hcurPrev);
    return 1;
}

/*****************************************************************************
 *
 *  Control_OnDestroy
 *
 *  Free the memory we allocated.
 *
 *****************************************************************************/

void PASCAL
Control_OnDestroy(HWND hdlg)
{
    Misc_FreePgxa(&pcpii->gxa);
}


/*****************************************************************************
 *
 *  Control_LV_Dirtify
 *
 *      Mark this item as having been changed during the property sheet
 *	page's lifetime.
 *
 *****************************************************************************/

void PASCAL
Control_LV_Dirtify(LPARAM icpl)
{
//    pcpii->pcpl[icpl].cplfl |= cplflEdited;
}

/*****************************************************************************
 *
 *  Control_OnApply
 *
 *      Write the changes out.
 *
 *****************************************************************************/

void PASCAL
Control_OnApply(HWND hdlg)
{
    HWND hwnd = GetDlgItem(hdlg, IDC_ICONLV);
    int cItems = ListView_GetItemCount(hwnd);
    BOOL fChanged = 0;
    LV_ITEM lvi;

    for (lvi.iItem = 0; lvi.iItem < cItems; lvi.iItem++) {
        PCPL pcpl;
        lvi.stateMask = LVIS_STATEIMAGEMASK;
        Misc_LV_GetItemInfo(hwnd, &lvi, lvi.iItem, LVIF_PARAM | LVIF_STATE);
        pcpl = pcplPlvi(&lvi);

        if (Control_GetShowState(pcpl->tszFile) != LV_IsChecked(&lvi)) {
            fChanged = 1;
            Control_SetShowState(pcpl->tszFile, LV_IsChecked(&lvi));
        }
    }

    if (fChanged) {
        ChangeNotifyCsidl(hdlg, CSIDL_CONTROLS, SHCNE_UPDATEDIR);
    }
}

/*****************************************************************************
 *
 *  Oh yeah, we need this too.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

LVV lvvControl = {
    0,                          /* Control_OnCommand */
    0,                          /* Control_LV_OnInitContextMenu */
    Control_LV_Dirtify,
    0,                          /* Control_LV_GetIcon */
    Control_OnInitDialog,
    Control_OnApply,
    Control_OnDestroy,
    0,                          /* Control_OnSelChange */
    7,                          /* iMenu */
    rgdwHelp,
    0,				/* Double-click action */
    lvvflCanCheck,              /* We need check boxes */
    NULL,
};

#pragma END_CONST_DATA


/*****************************************************************************
 *
 *  Our window procedure.
 *
 *****************************************************************************/

INT_PTR EXPORT
Control_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    return LV_DlgProc(&lvvControl, hdlg, wm, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tweakui\genthunk.cpp ===
/*
 * genthunk - Generic thunks
 */

#ifndef WIN32

#include "tweakui.h"

const char CODESEG szKernel32[] = "KERNEL32";

/*****************************************************************************
 *
 *  hwnd32Hwnd converts a 16-bit hwnd to a 32-bit hwnd.  Note that we
 *  extend with 0xFFFF to be compatible with NT.
 *
 *****************************************************************************/

#define hwnd32Hwnd(hwnd) MAKELONG(hwnd, 0xFFFF)

/*****************************************************************************
 *
 *  CallProcEx32W (a.k.a. ThunkMeHarder)
 *
 *	Generic wrapper for thunking.
 *
 *	lpszDll -> ASCIIZ DLL name
 *	lpszProc -> ASCIIZ procedure name
 *	c = number of arguments
 *	dwMask = bitmask; if argument N is a pointer, then bit c-N is set.
 *			  Yes, it's backwards.
 *	arg0, arg1, arg2, ... = arguments
 *
 *	Returns whatever the procedure returns, or 0 on error.
 *
 *	To aid in building dwMask, the macro ARGPTR(k,n) builds the
 *	appropriate bitmask that indicates that argument k of n is
 *	a pointer.  k is zero-based, of course.
 *
 *	This is pretty gross evil code that is Intel x86-specific.
 *	But hey, it's Win16.  That's to be expected.
 *
 *	CallProc32W is insane.  It's a variadic function that uses
 *	the pascal calling convention.  (It probably makes more sense
 *	when you're stoned.)
 *
 *****************************************************************************/

DWORD PASCAL GetProcAddressEx32W(DWORD hinst, LPCSTR lpsz);

DWORD WINAPI LoadLibraryEx32W(LPCSTR lpszLib, DWORD dw1, DWORD dw2);
DWORD WINAPI GetProcAddress32W(DWORD hinst, LPCSTR lpsz);
DWORD WINAPI FreeLibrary32W(DWORD hinst);
DWORD WINAPI CallProc32W(DWORD pfn, DWORD dwMask, DWORD c);

#define CallProcEx32W ThunkMeHarder
#define ARGPTR(k,n) (1<<(n-k-1))

DWORD _cdecl
ThunkMeHarder(LPCSTR lpszDll, LPCSTR lpszProc, UINT c, DWORD dwMask, ...)
{
    DWORD dwRc = 0;
    DWORD hdll, pfn;
    if (SELECTOROF(lpszDll) ?
			(HIWORD(hdll = LoadLibraryEx32W(lpszDll, 0, 0)) &&
			 HIWORD(pfn = GetProcAddressEx32W(hdll, lpszProc)))
			: (hdll = 0, pfn = (DWORD)lpszProc, 1)) {
	_asm {
	    mov	cx, c	/* cx = number of arguments */
	    xor	si, si	/* si = number of bytes pushed */
	    jcxz	PushesDone
	PushHarder:
	    _emit 0x66	    	/* 32-bit override */
	    push word ptr dwMask[4+si]
	    add	si, 4
	    loop	PushHarder
	PushesDone:
	}
	dwRc = CallProc32W(pfn, dwMask, c);
    }
    if (HIWORD(hdll)) FreeLibrary32W(hdll);
    return dwRc;
}

/*****************************************************************************
 *
 *  GetProcAddressEx32W
 *
 *  The same as GetProcAddress32W, except it also understands ordinals.
 *
 *  Yes, this is a rather close relationship we have with ThunkMeHarder,
 *  
 *
 *  (The Shell VxD does a very similar thing)
 *
 *****************************************************************************/

const char CODESEG szGetProcAddress[] = "GetProcAddress";

DWORD PASCAL
GetProcAddressEx32W(DWORD hinst, LPCSTR lpsz)
{
    if (SELECTOROF(lpsz)) {			/* Optimization */
	return GetProcAddress32W(hinst, lpsz);
    } else {
	return ThunkMeHarder(szKernel32, szGetProcAddress, 2, 0, hinst, lpsz);
    }
}

/*****************************************************************************
 *
 *  CopyFile
 *
 *****************************************************************************/

const char CODESEG szCopyFileA[] = "CopyFileA";

BOOL PASCAL
CopyFile(LPCSTR lpszSrc, LPCSTR lpszDst, BOOL fFailExists)
{
    return CallProcEx32W(szKernel32, szCopyFileA, 3, ARGPTR(0,3)|ARGPTR(1,3),
			 lpszSrc, lpszDst, (DWORD)fFailExists) != 0;
}

/*****************************************************************************
 *
 *  SHChangeNotify
 *
 *  Actually, we are slimy because we *know* that uFlags is always
 *  SHCNF_PIDL, so no parameters need to be thunked.
 *
 *****************************************************************************/

const char CODESEG szSHChangeNotify[] = "SHChangeNotify";

void PASCAL SHChangeNotify(LONG wEventId, UINT uFlags,
			   const void FAR *dwItem1, const void FAR *dwItem2)
{
    CallProcEx32W(szShell32, szSHChangeNotify, 4, 0,
		  wEventId, (DWORD)uFlags, dwItem1, dwItem2);
}

/*****************************************************************************
 *
 *  SHGetSpecialFolderLocation
 *
 *  Ignore the return value; just check the pidl.
 *
 *****************************************************************************/

const char CODESEG szSHGetSpecialFolderLocation[]
						= "SHGetSpecialFolderLocation";

void PASCAL
SHGetSpecialFolderLocation(HWND hwnd, int nFolder, PIDL FAR *ppidl)
{
    CallProcEx32W(szShell32, szSHGetSpecialFolderLocation, 3, ARGPTR(2,3),
		  hwnd32Hwnd(hwnd), (LONG)nFolder, (LPVOID)ppidl);
}

/*****************************************************************************
 *
 *  SHGetPathFromIDList
 *
 *  Ignore the return value; just check the pidl.
 *
 *****************************************************************************/

const char CODESEG szSHGetPathFromIDList[] = "SHGetPathFromIDList";

void PASCAL
SHGetPathFromIDList(PIDL pidl, LPSTR pszBuf)
{
    CallProcEx32W(szShell32, szSHGetPathFromIDList, 2, ARGPTR(1,2),
		  pidl, pszBuf);
}

/*****************************************************************************
 *
 *  ILFree
 *
 *  This is exported by ordinal.
 *
 *****************************************************************************/

void WINAPI
ILFree(PIDL pidl)
{
    CallProcEx32W(szShell32, MAKEINTRESOURCE(155), 1, 0, pidl);
}

/*****************************************************************************
 *
 *  Shell_GetImageLists
 *
 *  This is exported by ordinal.
 *
 *****************************************************************************/

BOOL PASCAL
Shell_GetImageLists(HIMAGELIST FAR *phiml, HIMAGELIST FAR *phimlSmall)
{
    return (BOOL)CallProcEx32W(szShell32, MAKEINTRESOURCE(71), 2,
			       ARGPTR(0,2)|ARGPTR(1,2), phiml, phimlSmall);
}

/*****************************************************************************
 *
 *  ExtractIconEx
 *
 *****************************************************************************/

const char CODESEG szExtractIconExA[] = "ExtractIconExA";

int PASCAL
ExtractIconEx(LPCSTR pszFile, int iIcon,
	      HICON FAR *phiconLarge, HICON FAR *phiconSmall, int nIcons)
{
    return (int)CallProcEx32W(szShell32, szExtractIconExA, 5,
			      ARGPTR(0,5)|ARGPTR(2,5)|ARGPTR(3,5),
			      pszFile, (LONG)iIcon, phiconLarge, phiconSmall,
			      (LONG)nIcons);
}

#endif /* !WIN32 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tweakui\general.cpp ===
/*
 * general - Dialog box property sheet for "general ui tweaks"
 */

#include "tweakui.h"

#pragma BEGIN_CONST_DATA

KL const c_klSmooth = { &c_hkCU, c_tszRegPathDesktop, c_tszSmoothScroll };
KL const c_klEngine = { &g_hkCUSMIE, c_tszSearchUrl, 0 };
KL const c_klPaintVersion =
                      { &c_hkCU, c_tszRegPathDesktop, c_tszPaintDesktop };

/* SOMEDAY
Software\Microsoft\Internet Explorer\RestrictUI::Toolbar, ::History
IE\Toolbar\::BackBitmap
 */

const static DWORD CODESEG rgdwHelp[] = {
	IDC_EFFECTGROUP,    IDH_GROUP,
//        IDC_ANIMATE,        IDH_ANIMATE,
//        IDC_SMOOTHSCROLL,   IDH_SMOOTHSCROLL,
//        IDC_BEEP,           IDH_BEEP,

	IDC_IE3GROUP,	    IDH_GROUP,
	IDC_IE3TXT,	    IDH_IE3ENGINE,
	IDC_IE3ENGINETXT,   IDH_IE3ENGINE,
	IDC_IE3ENGINE,	    IDH_IE3ENGINE,

        IDC_RUDEGROUP,          IDH_GROUP,
        IDC_RUDE,               IDH_RUDEAPP,
        IDC_RUDEFLASHINFINITE,  IDH_RUDEAPPFLASH,
        IDC_RUDEFLASHFINITE,    IDH_RUDEAPPFLASH,
        IDC_RUDEFLASHCOUNT,     IDH_RUDEAPPFLASH,
        IDC_RUDEFLASHUD,        IDH_RUDEAPPFLASH,
        IDC_RUDEFLASHTXT,       IDH_RUDEAPPFLASH,

	0,		    0,
};

#pragma END_CONST_DATA

/*
 * Instanced.  We're a cpl so have only one instance, but I declare
 * all the instance stuff in one place so it's easy to convert this
 * code to multiple-instance if ever we need to.
 */
typedef struct GDII {           /* general_dialog instance info */
    DWORD   dwForegroundLock;   /* Original foreground lock */
    TCHAR   tszUrl[1024];	/* Search URL */
} GDII, *PGDII;

GDII gdii;
#define pgdii (&gdii)

#define DestroyCursor(hcur) SafeDestroyIcon((HICON)(hcur))

/*****************************************************************************
 *
 *  General_GetAni
 *
 *	Determine whether minimize animations are enabled.
 *
 *	Always returns exactly 0 or 1.
 *
 *****************************************************************************/

BOOL PASCAL
General_GetAni(LPARAM lParam, LPVOID pvRef)
{
    ANIMATIONINFO anii;
    anii.cbSize = sizeof(anii);
    SystemParametersInfo(SPI_GETANIMATION, sizeof(anii), &anii, 0);
    return anii.iMinAnimate != 0;
}

/*****************************************************************************
 *
 *  General_SetAni
 *
 *	Set the new animation flag.
 *
 *****************************************************************************/

BOOL PASCAL
General_SetAni(BOOL f, LPARAM lParam, LPVOID pvRef)
{
    BOOL fRc;
    ANIMATIONINFO anii;
    anii.cbSize = sizeof(anii);
    anii.iMinAnimate = f;
    fRc = SystemParametersInfo(SPI_SETANIMATION, sizeof(anii), &anii,
                               SPIF_UPDATEINIFILE);
    if (fRc && pvRef) {
        LPBOOL pf = (LPBOOL)pvRef;
        *pf = TRUE;
    }
    return fRc;
}

/*****************************************************************************
 *
 *  General_GetSmooth
 *
 *	Determine whether smooth scrolling is enabled.
 *
 *	Always returns exactly 0 or 1.
 *
 *****************************************************************************/

BOOL PASCAL
General_GetSmooth(LPARAM lParam, LPVOID pvRef)
{
    if (g_fSmoothScroll) {
        return GetDwordPkl(&c_klSmooth, 1) != 0;
    } else {
        return -1;
    }
}

/*****************************************************************************
 *
 *  General_SetSmooth
 *
 *	Set the new smooth-scroll flag.
 *
 *****************************************************************************/

BOOL PASCAL
General_SetSmooth(BOOL f, LPARAM lParam, LPVOID pvRef)
{
    BOOL fRc = SetDwordPkl(&c_klSmooth, f);
    if (fRc && pvRef) {
        LPBOOL pf = (LPBOOL)pvRef;
        *pf = TRUE;
    }
    return fRc;
}

/*****************************************************************************
 *
 *  General_GetPntVer
 *
 *      Determine whether we should paint the version on the desktop.
 *
 *	Always returns exactly 0 or 1.
 *
 *****************************************************************************/

BOOL PASCAL
General_GetPntVer(LPARAM lParam, LPVOID pvRef)
{
    if (g_fMemphis) {
        return GetIntPkl(0, &c_klPaintVersion) != 0;
    } else if (g_fNT5) {
        return GetDwordPkl(&c_klPaintVersion, 0) != 0;
    } else {
        return -1;
    }
}

/*****************************************************************************
 *
 *  General_SetPntVer
 *
 *      Set the PaintVersion flag.
 *
 *****************************************************************************/

BOOL PASCAL
General_SetPntVer(BOOL f, LPARAM lParam, LPVOID pvRef)
{
    BOOL fRc = FALSE;
    if (g_fMemphis) {
        fRc = SetIntPkl(f, &c_klPaintVersion);
    } else if (g_fNT5) {
        fRc = SetDwordPkl2(&c_klPaintVersion, f);
    }
    if (fRc && pvRef) {
        LPBOOL pf = (LPBOOL)pvRef;
        *pf = TRUE;
    }
    return fRc;
}

/*****************************************************************************
 *
 *  General_GetSpi
 *
 *      Return the setting of an SPI.
 *
 *****************************************************************************/

BOOL PASCAL
General_GetSpi(LPARAM lParam, LPVOID pvRef)
{
    BOOL f;

    if (SystemParametersInfo((UINT)lParam, 0, &f, 0)) {
        return f;
    } else {
        return -1;
    }
}

/*****************************************************************************
 *
 *  General_SetSpiW
 *
 *      Set the SPI value in the wParam.  Only SPI_SETBEEP needs this.
 *
 *****************************************************************************/

BOOL
General_SetSpiW(BOOL f, LPARAM lParam, LPVOID pvRef)
{
    return SystemParametersInfo((UINT)(lParam+1), f, NULL, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);
}

/*****************************************************************************
 *
 *  General_SetSpi
 *
 *      Set the SPI value in the lParam.
 *
 *****************************************************************************/

BOOL
General_SetSpi(BOOL f, LPARAM lParam, LPVOID pvRef)
{
    return SystemParametersInfo((UINT)(lParam+1), 0, IntToPtr(f), SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);
}

#pragma BEGIN_CONST_DATA

/*
 *  Note that this needs to be in sync with the IDS_GENERALEFFECTS
 *  strings.
 *
 *  Note that SPI_GETGRADIENTCAPTIONS is not needed, because the
 *  standard Control Panel.Desktop.Appearance lets you munge the
 *  gradient flag.
 *
 *  SPI_SETACTIVEWINDOWTRACKING is handled over on the Mouse tab.
 */
CHECKLISTITEM c_rgcliGeneral[] = {
    { General_GetAni,    General_SetAni,    0,  },
    { General_GetSmooth, General_SetSmooth, 0,  },
    { General_GetSpi,    General_SetSpiW,   SPI_GETBEEP },
    { General_GetSpi,    General_SetSpi,    SPI_GETMENUANIMATION },
    { General_GetSpi,    General_SetSpi,    SPI_GETCOMBOBOXANIMATION },
    { General_GetSpi,    General_SetSpi,    SPI_GETLISTBOXSMOOTHSCROLLING },
    { General_GetSpi,    General_SetSpi,    SPI_GETKEYBOARDCUES },
    { General_GetSpi,    General_SetSpi,    SPI_GETHOTTRACKING },
    { General_GetSpi,    General_SetSpi,    SPI_GETMENUFADE },
    { General_GetSpi,    General_SetSpi,    SPI_GETSELECTIONFADE },
    { General_GetSpi,    General_SetSpi,    SPI_GETTOOLTIPANIMATION },
    { General_GetSpi,    General_SetSpi,    SPI_GETTOOLTIPFADE },
    { General_GetSpi,    General_SetSpi,    SPI_GETCURSORSHADOW },
    { General_GetPntVer, General_SetPntVer, 0,  },
};

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *  General_SetDirty
 *
 *	Make a control dirty.
 *
 *****************************************************************************/

void INLINE
General_SetDirty(HWND hdlg)
{
    Common_SetDirty(hdlg);
}

/*****************************************************************************
 *
 *  General_Engine_OnEditChange
 *
 *	Enable the OK button if the URL contains exactly one %s.
 *
 *****************************************************************************/

void PASCAL
General_Engine_OnEditChange(HWND hdlg)
{
    TCHAR tszUrl[cA(pgdii->tszUrl)];
    PTSTR ptsz;
    int cPercentS;
    GetDlgItemText(hdlg, IDC_SEARCHURL, tszUrl, cA(tszUrl));

    /*
     *	All appearances of "%" must be followed by "%" or "s".
     */
    cPercentS = 0;
    ptsz = tszUrl;
    while ((ptsz = ptszStrChr(ptsz, TEXT('%'))) != 0) {
	if (ptsz[1] == TEXT('%')) {
	    ptsz += 2;
	} else if (ptsz[1] == TEXT('s')) {
	    cPercentS++;
	    ptsz += 2;
	} else {
	    cPercentS = 0; break;	/* Percent-mumble */
	}
    }

    EnableWindow(GetDlgItem(hdlg, IDOK), cPercentS == 1);
}

/*****************************************************************************
 *
 *  General_Engine_OnOk
 *
 *	Save the answer.
 *
 *****************************************************************************/

void INLINE
General_Engine_OnOk(HWND hdlg)
{
    GetDlgItemText(hdlg, IDC_SEARCHURL, pgdii->tszUrl, cA(pgdii->tszUrl));
}

/*****************************************************************************
 *
 *  General_Engine_OnCommand
 *
 *	If the edit control changed, update the OK button.
 *
 *****************************************************************************/

void PASCAL
General_Engine_OnCommand(HWND hdlg, int id, UINT codeNotify)
{
    switch (id) {
    case IDCANCEL:
	EndDialog(hdlg, 0); break;

    case IDOK:
	General_Engine_OnOk(hdlg);
	EndDialog(hdlg, 1);
	break;

    case IDC_SEARCHURL:
	if (codeNotify == EN_CHANGE) General_Engine_OnEditChange(hdlg);
	break;
    }
}

/*****************************************************************************
 *
 *  General_Engine_OnInitDialog
 *
 *	Shove the current engine URL in so the user can edit it.
 *
 *****************************************************************************/

void PASCAL
General_Engine_OnInitDialog(HWND hdlg)
{
    SetDlgItemTextLimit(hdlg, IDC_SEARCHURL, pgdii->tszUrl, cA(pgdii->tszUrl));
    General_Engine_OnEditChange(hdlg);
}

/*****************************************************************************
 *
 *  General_Engine_DlgProc
 *
 *	Dialog procedure.
 *
 *****************************************************************************/

INT_PTR EXPORT
General_Engine_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    switch (wm) {
    case WM_INITDIALOG: General_Engine_OnInitDialog(hdlg); break;

    case WM_COMMAND:
	General_Engine_OnCommand(hdlg,
			        (int)GET_WM_COMMAND_ID(wParam, lParam),
			        (UINT)GET_WM_COMMAND_CMD(wParam, lParam));
	break;

    default: return 0;	/* Unhandled */
    }
    return 1;		/* Handled */
}


/*****************************************************************************
 *
 *  General_UpdateEngine
 *
 *	If the person selected "Custom", then pop up the customize dialog.
 *
 *	At any rate, put the matching URL into pgdii->tszUrl.
 *
 *****************************************************************************/

void PASCAL
General_UpdateEngine(HWND hdlg)
{
    int ieng = (int)Misc_Combo_GetCurItemData(GetDlgItem(hdlg, IDC_IE3ENGINE));

    if (ieng == 0) {
	if (DialogBox(hinstCur, MAKEINTRESOURCE(IDD_SEARCHURL), hdlg,
		      General_Engine_DlgProc)) {
	} else {
	    goto skip;
	}
    } else {
	LoadString(hinstCur, IDS_URL+ieng, pgdii->tszUrl, cA(pgdii->tszUrl));
    }

    General_SetDirty(hdlg);
    skip:;
}

/*****************************************************************************
 *
 *  General_Reset
 *
 *	Reset all controls to initial values.  This also marks
 *	the control as clean.
 *
 *      Note: This doesn't really work any more.
 *
 *****************************************************************************/

BOOL PASCAL
General_Reset(HWND hdlg)
{
    HWND hwnd;
    UINT i;
    TCHAR tsz[256];

    GetStrPkl(pgdii->tszUrl, cbX(pgdii->tszUrl), &c_klEngine);
    if (pgdii->tszUrl[0] && !g_fIE5) {
	hwnd = GetDlgItem(hdlg, IDC_IE3ENGINE);
	ComboBox_ResetContent(hwnd);
	for (i = 0; LoadString(hinstCur, IDS_ENGINE+i, tsz, cA(tsz)); i++) {
	    int iItem = ComboBox_AddString(hwnd, tsz);
	    ComboBox_SetItemData(hwnd, iItem, i);
	    if (i) LoadString(hinstCur, IDS_URL+i, tsz, cA(tsz));
	    if (i == 0 || lstrcmpi(tsz, pgdii->tszUrl) == 0) {
		ComboBox_SetCurSel(hwnd, iItem);
	    }
	}
    } else {
        AdjustDlgItems(hdlg, IDC_IE3FIRST, IDC_IE3LAST, ADI_DISABLE | ADI_HIDE);
        MoveDlgItems(hdlg, IDC_IE3GROUP, IDC_RUDEFIRST, IDC_RUDELAST);
    }

    DWORD dw;
    if (SystemParametersInfo(SPI_GETFOREGROUNDLOCKTIMEOUT, 0, &dw, 0)) {
        if (dw) {
            pgdii->dwForegroundLock = dw;
        } else {
            /* Default foreground lock timeout differs based on platform */
             pgdii->dwForegroundLock = g_fNT ? 200000 : 15000;
        }
        CheckDlgButton(hdlg, IDC_RUDE, dw != 0);

        if (SystemParametersInfo(SPI_GETFOREGROUNDFLASHCOUNT, 0, &dw, 0)) {
            if (dw) {
                CheckDlgButton(hdlg, IDC_RUDEFLASHFINITE, TRUE);
                SetDlgItemInt(hdlg, IDC_RUDEFLASHCOUNT, dw, 0);
            } else {
                /* WindMill and NT default to 3 */
                CheckDlgButton(hdlg, IDC_RUDEFLASHINFINITE, TRUE);
                SetDlgItemInt(hdlg, IDC_RUDEFLASHCOUNT, 3, 0);
            }
        } else {
            /* Win98 had the flash count hard-coded to 2 */
            SetDlgItemInt(hdlg, IDC_RUDEFLASHCOUNT, 2, 0);
            EnableDlgItems(hdlg, IDC_RUDEFLASHFIRST, IDC_RUDEFLASHLAST, FALSE);
        }
    } else {
        AdjustDlgItems(hdlg, IDC_RUDEFIRST, IDC_RUDELAST, ADI_DISABLE | ADI_HIDE);
    }

    Common_SetClean(hdlg);

    return 1;
}

/*****************************************************************************
 *
 *  General_Apply
 *
 *	Write the changes to the registry.
 *
 *****************************************************************************/

void NEAR PASCAL
General_OnApply(HWND hdlg)
{
    BOOL fSendWinIniChange = 0;
    int i;

    Checklist_OnApply(hdlg, c_rgcliGeneral, &fSendWinIniChange, FALSE);

    if (fSendWinIniChange) {
	SendMessage(HWND_BROADCAST, WM_SETTINGCHANGE, 0,
		    (LPARAM)(LPCTSTR)c_tszWindows);
    }

    if (pgdii->tszUrl[0]) {
	SetStrPkl(&c_klEngine, pgdii->tszUrl);
    }

    BOOL f = IsDlgButtonChecked(hdlg, IDC_RUDE);
    if (SystemParametersInfo(SPI_SETFOREGROUNDLOCKTIMEOUT, 0,
                             IntToPtr(f ? pgdii->dwForegroundLock : 0),
                             SPIF_UPDATEINIFILE | SPIF_SENDCHANGE)) {
        int cFlash;
        if (IsDlgButtonChecked(hdlg, IDC_RUDEFLASHINFINITE)) {
            cFlash = 0; f = TRUE;
        } else {
            cFlash = (int)GetDlgItemInt(hdlg, IDC_RUDEFLASHCOUNT, &f, FALSE);
        }
        if (f && SystemParametersInfo(SPI_SETFOREGROUNDFLASHCOUNT, 0, IntToPtr(cFlash),
                                      SPIF_UPDATEINIFILE | SPIF_SENDCHANGE)) {
            /* Happy joy */
        }
    }

    General_Reset(hdlg);
}

/*****************************************************************************
 *
 *  General_OnCommand
 *
 *	Ooh, we got a command.
 *
 *****************************************************************************/

void PASCAL
General_OnCommand(HWND hdlg, int id, UINT codeNotify)
{
    switch (id) {
    case IDC_ANIMATE:
    case IDC_SMOOTHSCROLL:
    case IDC_BEEP:
    case IDC_RUDE:
    case IDC_RUDEFLASHINFINITE:
    case IDC_RUDEFLASHFINITE:
	if (codeNotify == BN_CLICKED) General_SetDirty(hdlg);
	break;

    case IDC_IE3ENGINE:
	if (codeNotify == CBN_SELCHANGE) General_UpdateEngine(hdlg);
        break;

    case IDC_RUDEFLASHCOUNT:
        if (codeNotify == EN_CHANGE) {
            General_SetDirty(hdlg);
        }
        break;
    }
}

#if 0
/*****************************************************************************
 *
 *  General_OnNotify
 *
 *	Ooh, we got a notification.
 *
 *****************************************************************************/

BOOL PASCAL
General_OnNotify(HWND hdlg, NMHDR FAR *pnm)
{
    switch (pnm->code) {
    case PSN_APPLY:
	General_Apply(hdlg);
	break;

    }
    return 0;
}
#endif

/*****************************************************************************
 *
 *  General_OnInitDialog
 *
 *	Initialize the controls.
 *
 *****************************************************************************/

BOOL NEAR PASCAL
General_OnInitDialog(HWND hwnd)
{
    HWND hdlg = GetParent(hwnd);

    ZeroMemory(pgdii, cbX(*pgdii));

    Checklist_OnInitDialog(hwnd, c_rgcliGeneral, cA(c_rgcliGeneral),
                           IDS_GENERALEFFECTS, 0);

    SendDlgItemMessage(hdlg, IDC_RUDEFLASHUD,
                       UDM_SETRANGE, 0, MAKELPARAM(999, 1));

    General_Reset(hdlg);
    return 1;
}

/*****************************************************************************
 *
 *  General_OnWhatsThis
 *
 *****************************************************************************/

void PASCAL
General_OnWhatsThis(HWND hwnd, int iItem)
{
    LV_ITEM lvi;

    Misc_LV_GetItemInfo(hwnd, &lvi, iItem, LVIF_PARAM);

    WinHelp(hwnd, c_tszMyHelp, HELP_CONTEXTPOPUP,
            IDH_ANIMATE + lvi.lParam);
}

/*****************************************************************************
 *
 *  Oh yeah, we need this too.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

LVCI lvciGeneral[] = {
    { IDC_WHATSTHIS,        General_OnWhatsThis },
    { 0,                    0 },
};

LVV lvvGeneral = {
    General_OnCommand,
    0,                          /* General_OnInitContextMenu */
    0,                          /* General_Dirtify */
    0,                          /* General_GetIcon */
    General_OnInitDialog,
    General_OnApply,
    0,                          /* General_OnDestroy */
    0,                          /* General_OnSelChange */
    6,                          /* iMenu */
    rgdwHelp,
    0,                          /* Double-click action */
    lvvflCanCheck,              /* We need check boxes */
    lvciGeneral,
};

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *  Our window procedure.
 *
 *****************************************************************************/

INT_PTR EXPORT
General_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    return LV_DlgProc(&lvvGeneral, hdlg, wm, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tweakui\misc.cpp ===
/*
 * misc - misc stuff
 */

#include "tweakui.h"

/*****************************************************************************
 *
 *  Eschew the C runtime
 *
 *****************************************************************************/

void *  __cdecl operator new(size_t nSize)
{
    // Zero init just to save some headaches
    return((LPVOID)LocalAlloc(LPTR, nSize));
}


void  __cdecl operator delete(void *pv)
{
    LocalFree((HLOCAL)pv);
}

/*****************************************************************************
 *
 *  Misc_NextPx
 *
 *  Allocate another slot in the growable X array, returning its index.
 *  The slot is not eaten, however.
 *
 *  The array may move as a result of this call; the caller promises
 *  not to use the resulting pointer after the next alloc call.
 *
 *****************************************************************************/

PV PASCAL
Misc_AllocPx(PGXA pgxa)
{
    if (pgxa->cx >= pgxa->cxAlloc) {
	PV pv = lReAlloc(pgxa->pv, pgxa->cbx * (pgxa->cxAlloc + 5));
	if (pv) {
	    pgxa->pv = pv;
	    pgxa->cxAlloc += 5;
	} else {
	    return 0;
	}
    }
    return (PBYTE)pgxa->pv + pgxa->cbx * pgxa->cx;
}

/*****************************************************************************
 *
 *  Misc_InitPgxa
 *
 *****************************************************************************/

BOOL PASCAL
Misc_InitPgxa(PGXA pgxa, int cbx)
{
    pgxa->cbx = cbx;
    pgxa->cxAlloc = 5;
    pgxa->cx = 0;
    pgxa->pv = lAlloc(pgxa->cbx * pgxa->cxAlloc);
    return pgxa->pv ? TRUE : FALSE;
}

/*****************************************************************************
 *
 *  Misc_FreePgxa
 *
 *****************************************************************************/

void PASCAL
Misc_FreePgxa(PGXA pgxa)
{
    if (pgxa->pv) {
	lFree(pgxa->pv);
    }
}

/*****************************************************************************
 *
 *  Misc_EnableMenuFromHdlgId
 *
 *	Enable or disable a menu item based on a dialog item.
 *
 *****************************************************************************/

void PASCAL
Misc_EnableMenuFromHdlgId(HMENU hmenu, HWND hdlg, UINT idc)
{
    EnableMenuItem(hmenu, idc, MF_BYCOMMAND | (
		IsWindowEnabled(GetDlgItem(hdlg, idc)) ? 0 : MFS_GRAYED));
}

/*****************************************************************************
 *
 *  Misc_LV_GetCurSel
 *
 *	Return the selection index.
 *
 *****************************************************************************/


int PASCAL
Misc_LV_GetCurSel(HWND hwnd)
{
    return ListView_GetNextItem(hwnd, -1, LVNI_FOCUSED);
}

/*****************************************************************************
 *
 *  Misc_LV_SetCurSel
 *
 *	Set the selection index.
 *
 *****************************************************************************/

void PASCAL
Misc_LV_SetCurSel(HWND hwnd, int iIndex)
{
    ListView_SetItemState(hwnd, iIndex, LVIS_FOCUSED | LVIS_SELECTED,
					LVIS_FOCUSED | LVIS_SELECTED);
}

/*****************************************************************************
 *
 *  Misc_LV_EnsureSel
 *
 *  Make sure *something* is selected.  Try to make it iItem.
 *
 *****************************************************************************/

void PASCAL
Misc_LV_EnsureSel(HWND hwnd, int iItem)
{
    int iItemMax = ListView_GetItemCount(hwnd) - 1;
    if (iItem > iItemMax) {
	iItem = iItemMax;
    }
    Misc_LV_SetCurSel(hwnd, iItem);
}

/*****************************************************************************
 *
 *  Misc_LV_GetItemInfo
 *
 *  Grab some info out of an item.
 *
 *  The incoming LV_ITEM should have any fields initialized which are
 *  required by the mask.  (E.g., the state mask.)
 *
 *****************************************************************************/

void PASCAL
Misc_LV_GetItemInfo(HWND hwnd, LV_ITEM FAR *plvi, int iItem, UINT mask)
{
    plvi->iItem = iItem;
    plvi->iSubItem = 0;
    plvi->mask = mask;
    ListView_GetItem(hwnd, plvi);
}

/*****************************************************************************
 *
 *  Misc_LV_GetParam
 *
 *	Convert an iItem into the associated parameter.
 *
 *****************************************************************************/

LPARAM PASCAL
Misc_LV_GetParam(HWND hwnd, int iItem)
{
    LV_ITEM lvi;
    Misc_LV_GetItemInfo(hwnd, &lvi, iItem, LVIF_PARAM);
    return lvi.lParam;
}

/*****************************************************************************
 *
 *  Misc_LV_HitTest
 *
 *	Perform a hit-test on the listview.  The LPARAM parameter is
 *	the screen coordinates of the message.
 *
 *****************************************************************************/

void PASCAL
Misc_LV_HitTest(HWND hwnd, LV_HITTESTINFO FAR *phti, LPARAM lpPos)
{
    phti->pt.x = (signed short)LOWORD(lpPos);
    phti->pt.y = (signed short)HIWORD(lpPos);

    MapWindowPoints(HWND_DESKTOP, hwnd, &phti->pt, 1);

    ListView_HitTest(hwnd, phti);
}


/*****************************************************************************
 *
 *  Misc_Combo_GetCurItemData
 *
 *      Get the current item data from a combo box.
 *
 *****************************************************************************/

LRESULT PASCAL
Misc_Combo_GetCurItemData(HWND hwnd)
{
    int iItem = ComboBox_GetCurSel(hwnd);
    return ComboBox_GetItemData(hwnd, iItem);
}


/*****************************************************************************
 *
 *  Misc_Trim
 *
 *	Trim leading and trailing spaces from a string.  Returns a pointer
 *	to the first non-space character, and slaps a '\0' on top of the
 *	last trailing space.
 *
 *****************************************************************************/

LPTSTR PASCAL
Misc_Trim(LPTSTR ptsz)
{
    int ctch;

    for ( ; (unsigned)(*ptsz - 1) <= ' '; ptsz++);
    for (ctch = lstrlen(ptsz); ctch && (unsigned)ptsz[ctch-1] <= ' '; ctch--);
    if (ctch) {
	ptsz[ctch] = '\0';
    }
    return ptsz;
}

/*****************************************************************************
 *
 *  Misc_SetDrbSize
 *
 *	Set the size of the buffer in a DRB.
 *
 *****************************************************************************/

typedef struct DRB {			/* dynamically resizable buffer */
    PV pv;				/* Actual buffer */
    UINT cb;				/* Size of buffer in bytes */
} DRB, *PDRB;

void PASCAL
Misc_SetDrbSize(PDRB pdrb, UINT cb)
{
    if (pdrb->pv) {
	LocalFree(pdrb->pv);
	pdrb->pv = 0;
	pdrb->cb = 0;
    }
    if (cb) {
	pdrb->pv = LocalAlloc(LMEM_FIXED, cb);
	if (pdrb->pv) {
	    pdrb->cb = cb;
	}
    }
}

/*****************************************************************************
 *
 *  Misc_EnsureDrb
 *
 *	Make sure that the DRB can handle at least cb bytes.
 *
 *	Round up to 4K boundary for convenience.
 *
 *****************************************************************************/

BOOL PASCAL
Misc_EnsureDrb(PDRB pdrb, UINT cb)
{
    if (cb <= pdrb->cb) {
    } else {
	Misc_SetDrbSize(pdrb, (cb + 1023) & ~1023);
    }
    return pdrb->pv ? TRUE : FALSE;
}

/*****************************************************************************
 *
 *  Misc_CopyRegWorker
 *
 *  Copy a registry tree from one point to another.
 *
 *  Since this is a recursive routine, don't allocate lots of goo off the
 *  stack.
 *
 *****************************************************************************/

typedef struct RCI {			/* registry copy info */
    DRB drb;				/* Data being copied */
    TCH tszKey[ctchKeyMax];		/* Key name buffer */
} RCI, *PRCI;

BOOL PASCAL
Misc_CopyRegWorker(PRCI prci, HKEY hkSrcRoot, PCTSTR ptszSrc,
			      HKEY hkDstRoot, PCTSTR ptszDst)
{
    HKEY hkSrc, hkDst;
    BOOL fRc;
    if (_RegOpenKey(hkSrcRoot, ptszSrc, &hkSrc) == 0) {
	if (RegCreateKey(hkDstRoot, ptszDst, &hkDst) == 0) {
	    int i;

	    /*
	     *	The first loop copies the values.
	     */
	    for (i = 0; ; i++) {
                DWORD ctch = cA(prci->tszKey), cb = 0, dwType;
                switch (RegEnumValue(hkSrc, i, prci->tszKey, &ctch, 0,
				     &dwType, 0, &cb)) {
		case ERROR_NO_MORE_ITEMS: goto valuesdone;

		/*
		 *  We can get an ERROR_SUCCESS if the value length is 0.
		 */
		case ERROR_SUCCESS:
		case ERROR_MORE_DATA:
		    if (Misc_EnsureDrb(&prci->drb, cb)) {
			DWORD dwType;
			if (RegQueryValueEx(hkSrc, prci->tszKey, 0, &dwType,
                                            (LPBYTE)prci->drb.pv, &cb) == 0 &&
			    RegSetValueEx(hkDst, prci->tszKey, 0, dwType,
                                            (LPBYTE)prci->drb.pv, cb) == 0) {
			} else {
			    fRc = 0; goto stopkey;
			}
		    } else {
			fRc = 0; goto stopkey;
		    }
		    break;

		default:
		    fRc = 0; goto stopkey;
		}
	    }
	    valuesdone:;

	    /*
	     *	The second loop recurses on each subkey.
	     */
	    for (i = 0; ; i++) {
		switch (RegEnumKey(hkSrc, i, prci->tszKey, cA(prci->tszKey))) {
		case ERROR_NO_MORE_ITEMS: goto keysdone;

		/*
		 *  We can get an ERROR_SUCCESS if the subkey length is 0.
		 *  (Thought that might be illegal for other reasons, but
		 *  we'll go along with it anyway.)
		 */
		case ERROR_SUCCESS:
		case ERROR_MORE_DATA:
		    if (Misc_CopyRegWorker(prci, hkSrc, prci->tszKey,
						 hkDst, prci->tszKey)) {
		    } else {
			fRc = 0; goto stopkey;
		    }
		    break;

		default:
		    fRc = 0; goto stopkey;
		}
	    }
	    keysdone:;
            fRc = TRUE;

	    stopkey:;
	    RegCloseKey(hkDst);
	} else {
	    fRc = 0;
	}
	RegCloseKey(hkSrc);
    } else {
	fRc = 0;
    }
    return fRc;
}

/*****************************************************************************
 *
 *  Misc_CopyReg
 *
 *  Copy a registry tree from one point to another.
 *
 *****************************************************************************/

BOOL PASCAL
Misc_CopyReg(HKEY hkSrcRoot, PCTSTR ptszSrc, HKEY hkDstRoot, PCTSTR ptszDst)
{
    BOOL fRc;
    RCI rci;
    rci.drb.pv = 0;
    rci.drb.cb = 0;

    fRc = Misc_CopyRegWorker(&rci, hkSrcRoot, ptszSrc, hkDstRoot, ptszDst);

    Misc_SetDrbSize(&rci.drb, 0);

    if (fRc) {
    } else {
	/* Clean up partial copy */
	RegDeleteTree(hkDstRoot, ptszDst);
    }

    return fRc;
}

/*****************************************************************************
 *
 *  Misc_RenameReg
 *
 *  Rename a registry key by copying it and deleting the original.
 *
 *****************************************************************************/

BOOL PASCAL
Misc_RenameReg(HKEY hkRoot, PCTSTR ptszKey, PCTSTR ptszSrc, PCTSTR ptszDst)
{
    BOOL fRc;
    HKEY hk;

    if (_RegOpenKey(hkRoot, ptszKey, &hk) == 0) {
        if (Misc_CopyReg(hk, ptszSrc, hk, ptszDst)) {
            RegDeleteTree(hk, ptszSrc);
            fRc = TRUE;
        } else {
            fRc = FALSE;
        }
        RegCloseKey(hk);
    } else {
        fRc = FALSE;
    }

    return fRc;
}

/*****************************************************************************
 *
 *  lstrcatnBs
 *
 *  Like lstrcatn, but with a backslash stuck in between.
 *
 *****************************************************************************/

void PASCAL
lstrcatnBs(PTSTR ptszDst, PCTSTR ptszSrc, int ctch)
{
    int ctchDst = lstrlen(ptszDst);
    ptszDst += ctchDst;
    ctch -= ctchDst;
    if (ctch > 1) {
	ptszDst[0] = TEXT('\\');
	lstrcpyn(ptszDst + 1, ptszSrc, ctch - 1);
    }
}

/*****************************************************************************
 *
 *  Misc_GetShellIconSize
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

KL const c_klShellIconSize = { &c_hkCU, c_tszMetrics, c_tszShellIconSize };

#pragma END_CONST_DATA


UINT PASCAL
Misc_GetShellIconSize(void)
{
    return GetIntPkl(GetSystemMetrics(SM_CXICON), &c_klShellIconSize);
}

/*****************************************************************************
 *
 *  Misc_SetShellIconSize
 *
 *	Dork the shell icon size and rebuild.
 *
 *****************************************************************************/

void PASCAL
Misc_SetShellIconSize(UINT ui)
{
    SetIntPkl(ui, &c_klShellIconSize);
    SendMessage(HWND_BROADCAST, WM_SETTINGCHANGE, SPI_SETNONCLIENTMETRICS, 0L);
}

/*****************************************************************************
 *
 *  Misc_RebuildIcoCache
 *
 *	Force the shell to rebuild its icon cache.
 *
 *	Due to the way the shell works, we have to do this by changing
 *	the icon sizes, then changing it back.
 *
 *****************************************************************************/

void PASCAL
Misc_RebuildIcoCache(void)
{
    UINT cxIcon = Misc_GetShellIconSize();
    Misc_SetShellIconSize(cxIcon-1);
    Misc_SetShellIconSize(cxIcon);
    Explorer_HackPtui();
}

/*****************************************************************************
 *
 *  SetWaitCursor
 *
 *****************************************************************************/

HCURSOR SetWaitCursor(void)
{
    return SetCursor(LoadCursor(0, IDC_WAIT));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tweakui\link.cpp ===
/*
 * link - The Rundll that turns off "Shortcut to"
 *
 * This works around a bug in Shell32, where an off-by-one prevented
 * the restore of the setting from working.
 */

#include "tweakui.h"

#pragma BEGIN_CONST_DATA

KL c_klLink = { &g_hkCUSMWCV, c_tszExplorer, c_tszLink };

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *  Link_GetShortcutTo
 *
 *  Determine whether the "Shortcut to" prefix is enabled.
 *
 *****************************************************************************/

BOOL PASCAL
Link_GetShortcutTo(void)
{
    return GetDwordPkl(&c_klLink, 1) > 0;
}

/*****************************************************************************
 *
 *  fCreateNil
 *
 *	Create a zero-length file.
 *
 *****************************************************************************/

BOOL PASCAL
fCreateNil(LPCTSTR cqn)
{
    HFILE hf = _lcreat(cqn, 0);
    if (hf != -1) {
	_lclose(hf);
	return 1;
    } else {
	return 0;
    }
}

/*****************************************************************************
 *
 *  Link_Drop		-- Create a temp directory, then...
 *  Link_DropCqn	-- create a pidl for the directory, then...
 *  Link_DropPidlCqn	-- bind to the pidl, then...
 *  Link_DropPsfCqn	-- try 20 times to...
 *  Link_RenameToBang	-- rename a scratch pidl to "!"
 *
 *	(Welcome to lisp.)
 *
 *	Keep renaming a file, losing the "Shortcut to", until the shell
 *	finally gets the point, or we've tried 20 times and give up.
 *	If the shell doesn't get the point after 20 tries, it'll never
 *	learn...
 *
 *	Returns 0 if we couldn't do it.
 *
 *	We do this by creating a temporary directory within the temp
 *	directory.  In this temp-temp directory, create a file called
 *	"Shortcut to !.lnk", then keep renaming it to "!".
 *
 *	By creating it in a brand new temp dir, we are sure we won't
 *	conflict with any other files.
 *
 *****************************************************************************/

BOOL PASCAL
Link_RenameToBang(PIDL pidl, LPVOID pv)
{
    PSF psf = (PSF)pv;
    DeleteFile(c_tszBangLnk);	/* So the rename will work */
    return SetNameOfPidl(psf, pidl, c_tszBang);
}

BOOL PASCAL
Link_DropPsfCqn(PSF psf, LPVOID pv)
{
    LPCTSTR cqn = (LPCTSTR)pv;
    if (fCreateNil(c_tszBang)) {
	BOOL fRc;
	TCH tszLinkToBang[MAX_PATH];
	if (mit.SHGetNewLinkInfo(c_tszBang, cqn, tszLinkToBang, &fRc,
				 SHGNLI_PREFIXNAME)) {
	    int iter;
	    for (iter = 0; iter < 20 && Link_GetShortcutTo(); iter++) {
		fCreateNil(tszLinkToBang);
		WithPidl(psf, ptszFilenameCqn(tszLinkToBang),
			 Link_RenameToBang, psf);
	    }
	}
    }
    return !Link_GetShortcutTo();
}

BOOL PASCAL
Link_DropPidlCqn(PIDL pidl, LPVOID cqn)
{
    return WithPsf(psfDesktop, pidl, Link_DropPsfCqn, cqn);
}


BOOL PASCAL
Link_DropCqn(LPCTSTR cqn, LPVOID pv)
{
    return WithPidl(psfDesktop, cqn, Link_DropPidlCqn, (LPVOID)cqn);
}

Link_Drop(void)
{
    return WithTempDirectory(Link_DropCqn, 0);
}

/*****************************************************************************
 *
 *  Link_SetShortcutTo
 *
 *	Set or clear the "prepend "Shortcut to" to new shortcuts" flag.
 *
 *	If we need to set it, then set the registry key and ask the user
 *	to log off and back on.  There is no way to make the count go up.
 *
 *	If we need to clear it, then keep renaming "Shortcut to frob" to
 *	"frob" until the link count goes to zero.
 *
 *	Returns 0 if the user must log off and back on for the change
 *	to take effect.
 *
 *****************************************************************************/

BOOL PASCAL
Link_SetShortcutTo(BOOL fPrefix)
{
    if (fPrefix != Link_GetShortcutTo()) {
	if (fPrefix) {
	    DelPkl(&c_klLink);
	    return 0;			/* Must log off and back on */
	} else {			/* Make the count drop to zero */
            if (!g_fNT && Link_Drop()) {
		return 1;
	    } else {
		SetDwordPkl(&c_klLink, fPrefix);
					/* Oh well */
		return 0;
	    }
	}
    } else {
	return 1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tweakui\ie4.cpp ===
/*
 * ie4 - IE4 settings
 */

#include "tweakui.h"
#include <lmcons.h>
#include <lmjoin.h>
#include <lmerr.h>

#pragma BEGIN_CONST_DATA

KL const c_klSingleClick = {&g_hkCUSMWCV, c_tszExplorerAdvanced,
                                          c_tszUseDoubleClickTimer };

const static DWORD CODESEG rgdwHelp[] = {
        IDC_SETTINGSGROUP,      IDH_GROUP,
        IDC_LISTVIEW,           IDH_IE4LV,
        0,                      0,
};

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *  IE4_GetDword
 *
 *      Read a DWORD somewhere.
 *
 *      Always returns exactly 0 or 1.
 *
 *****************************************************************************/

BOOL PASCAL
IE4_GetDword(LPARAM lParam, LPVOID pvRef)
{
    PKL pkl = (PKL)lParam;

    return GetDwordPkl(pkl, TRUE) != 0;
}

/*****************************************************************************
 *
 *  IE4_SetDword
 *
 *      Save a DWORD somewhere.
 *
 *      Always given exactly 0 or 1.
 *
 *****************************************************************************/

BOOL PASCAL
IE4_SetDword(BOOL f, LPARAM lParam, LPVOID pvRef)
{
    PKL pkl = (PKL)lParam;
    PBOOL pf = (PBOOL)pvRef;

    if (pf) {
        *pf = TRUE;
    }

    return SetDwordPkl(pkl, f);
}

/*****************************************************************************
 *
 *  IE4_GetRest
 *
 *      Read a restriction.  The first character of the restriction is
 *      `+' if it is positive sense.  All restrictions default to 0.
 *
 *      Always returns exactly 0 or 1.
 *
 *****************************************************************************/

BOOL PASCAL
IE4_GetRest(LPARAM lParam, LPVOID pvRef)
{
    LPCTSTR ptszRest = (LPCTSTR)lParam;

    if (ptszRest[0] == TEXT('+')) {
        return !GetRestriction(ptszRest+1);
    } else {
        return GetRestriction(ptszRest);
    }
}

/*****************************************************************************
 *
 *  IE4_GetRest4
 *
 *      Just like IE4_GetRest, except fails if shell version 5 or better.
 *
 *****************************************************************************/

BOOL PASCAL
IE4_GetRest4(LPARAM lParam, LPVOID pvRef)
{
    if (g_fShell5) {
        return -1;
    } else {
        return IE4_GetRest(lParam, pvRef);
    }
}

/*****************************************************************************
 *
 *  IE4_GetRest5
 *
 *      Just like IE4_GetRest, except requires shell version 5 or better.
 *
 *****************************************************************************/

BOOL PASCAL
IE4_GetRest5(LPARAM lParam, LPVOID pvRef)
{
    if (g_fShell5) {
        return IE4_GetRest(lParam, pvRef);
    } else {
        return -1;
    }
}

/*****************************************************************************
 *
 *  IE4_GetRest55
 *
 *      Just like IE4_GetRest, except requires shell version 5.5 or better.
 *
 *****************************************************************************/

BOOL PASCAL
IE4_GetRest55(LPARAM lParam, LPVOID pvRef)
{
    if (g_fShell55) {
        return IE4_GetRest(lParam, pvRef);
    } else {
        return -1;
    }
}

/*****************************************************************************
 *
 *  HasComputersNearMe
 *
 *      See if "Computers Near Me" is enabled.
 *
 *      Shell 4 or lower: Disabled.
 *
 *      Shell 5 on 9x: Enabled.
 *
 *      Shell 5 on NT: Only if you are joined to a workgroup.
 *
 *****************************************************************************/

typedef NET_API_STATUS (CALLBACK *NETGETJOININFORMATION)(LPCWSTR, LPWSTR*, PNETSETUP_JOIN_STATUS);
typedef NET_API_STATUS (CALLBACK *NETAPIBUFFERFREE)(LPVOID);

BOOL s_bHasComputersNearMe = -1;

BOOL PASCAL
HasComputersNearMe(void)
{
    if (!g_fShell5) {
        return FALSE;
    }

    if (!g_fNT) {
        return TRUE;
    }

    if (s_bHasComputersNearMe < 0) {
        NETSETUP_JOIN_STATUS nsjs = NetSetupUnknownStatus;

        HINSTANCE hinst = LoadLibrary("netapi32.dll");
        if (hinst) {
            NETGETJOININFORMATION _NetGetJoinInformation =
           (NETGETJOININFORMATION)GetProcAddress(hinst, "NetGetJoinInformation");
            NETAPIBUFFERFREE _NetApiBufferFree =
           (NETAPIBUFFERFREE)GetProcAddress(hinst, "NetApiBufferFree");
            if (_NetGetJoinInformation && _NetApiBufferFree) {
                LPWSTR pszDomain;
                if (_NetGetJoinInformation(NULL, &pszDomain, &nsjs) == NERR_Success) {
                    _NetApiBufferFree(pszDomain);
                }
            }
            FreeLibrary(hinst);
        }

        s_bHasComputersNearMe = (nsjs == NetSetupWorkgroupName);
    }

    return s_bHasComputersNearMe;
}

/*****************************************************************************
 *
 *  IE4_GetRestCNM
 *
 *      Special function just for "Computers Near Me".
 *
 *****************************************************************************/

BOOL PASCAL
IE4_GetRestCNM(LPARAM lParam, LPVOID pvRef)
{
    if (HasComputersNearMe()) {
        return IE4_GetRest(lParam, pvRef);
    } else {
        return -1;
    }
}

/*****************************************************************************
 *
 *  IE4_SetRest
 *
 *      Set the new restriction setting.
 *
 *      The first character of the restriction is
 *      `+' if it is positive sense.
 *
 *****************************************************************************/

BOOL PASCAL
IE4_SetRest(BOOL f, LPARAM lParam, LPVOID pvRef)
{
    LPCTSTR ptszRest = (LPCTSTR)lParam;
    PBOOL pf = (PBOOL)pvRef;

    if (pf) {
        *pf = ptszRest ? TRUE : FALSE;
    }

    if (ptszRest[0] == TEXT('+')) {
        f = !f;
        ptszRest++;
    }
    return SetRestriction(ptszRest, f);

}

/*****************************************************************************
 *
 *  IE4_GetLinksFolderName
 *
 *****************************************************************************/

KL const c_klLinksFolder = {&g_hkCUSMIE, TEXT("Toolbar"), TEXT("LinksFolderName") };
KL const c_klLinksFolder2= {&g_hkLMSMWCV, NULL, TEXT("LinksFolderName") };

BOOL PASCAL
IE4_GetLinksFolderName(LPTSTR pszBuf, UINT cchBuf)
{
    PIDL pidl;
    BOOL fRc = FALSE;

    if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_FAVORITES, &pidl))) {
        if (SHGetPathFromIDList(pidl, pszBuf)) {
            /*
             *  Find the name of the links folder underneath Favorites.
             */
            TCHAR szLinks[MAX_PATH];
            if (!GetStrPkl(szLinks, sizeof(szLinks), &c_klLinksFolder) &&
                !GetStrPkl(szLinks, sizeof(szLinks), &c_klLinksFolder2)) {
                lstrcpy(szLinks, TEXT("Links"));
            }

            Path_Append(pszBuf, szLinks);
            fRc = TRUE;
        }

        Ole_Free(pidl);
    }

    return fRc;
}

/*****************************************************************************
 *
 *  IE4_GetFavLink
 *
 *      Say whether the Favorites\Links directory is hidden.
 *
 *      -1 = No links directory at all
 *      0  = Links is hidden
 *      1  = Links is visible
 *
 *****************************************************************************/

BOOL PASCAL
IE4_GetFavLink(LPARAM lParam, LPVOID pvRef)
{
    BOOL fRc = -1;
    TCHAR szFavLink[MAX_PATH];
    if (IE4_GetLinksFolderName(szFavLink, cA(szFavLink))) {
        DWORD dwAttrib = GetFileAttributes(szFavLink);
        if (dwAttrib != 0xFFFFFFFF) {
            fRc = !(dwAttrib & FILE_ATTRIBUTE_HIDDEN);
        }
    }
    return fRc;
}

/*****************************************************************************
 *
 *  IE4_SetFavLink
 *
 *      0  = Make links hidden
 *      1  = Make links visible
 *
 *****************************************************************************/

BOOL PASCAL
IE4_SetFavLink(BOOL f, LPARAM lParam, LPVOID pvRef)
{
    BOOL fRc = FALSE;
    PBOOL pf = (PBOOL)pvRef;

    TCHAR szFavLink[MAX_PATH];
    if (IE4_GetLinksFolderName(szFavLink, cA(szFavLink))) {
        DWORD dwAttrib = GetFileAttributes(szFavLink);
        if (dwAttrib != 0xFFFFFFFF) {
            dwAttrib &= ~FILE_ATTRIBUTE_HIDDEN;
            if (!f)
                dwAttrib |= FILE_ATTRIBUTE_HIDDEN;
            if (SetFileAttributes(szFavLink, dwAttrib)) {
                fRc = TRUE;
                *pf = TRUE;
            }
        }
    }
    return fRc;
}

/*
 *  Note that this needs to be in sync with the IDS_IE4 strings.
 */

CHECKLISTITEM c_rgcliIE4[] = {
#ifdef NOINTERNET_WORKS
    // WARNING! If you turn this on, make sure to renumber the IDS_IE4
    // strings and fix IE4_OnWhatsThis
    { IE4_GetRest,  IE4_SetRest,    (LPARAM)c_tszNoInternetIcon,        },
#endif
    { IE4_GetRest,  IE4_SetRest,    (LPARAM)c_tszNoRecentDocsHistory,   },
    { IE4_GetRest,  IE4_SetRest,    (LPARAM)c_tszNoRecentDocsMenu,      },
    { IE4_GetRest,  IE4_SetRest,    (LPARAM)c_tszNoActiveDesktop,       },
    { IE4_GetRest,  IE4_SetRest,    (LPARAM)c_tszNoActiveDesktopChanges,},

    /*
     * Sigh.  Shell5 changed the restriction key for NoFavoritesMenu.
     * Fortunately, it's in the UI so I don't need to expose it any more.
     */
    { IE4_GetRest4, IE4_SetRest,    (LPARAM)c_tszNoFavoritesMenu,       },

    { IE4_GetRest,  IE4_SetRest,    (LPARAM)c_tszClearRecentDocsOnExit, },
    { IE4_GetRest,  IE4_SetRest,    (LPARAM)c_tszClassicShell,          },
    { IE4_GetRest,  IE4_SetRest,    (LPARAM)c_tszNoLogoff,              },
    { IE4_GetDword, IE4_SetDword,   (LPARAM)&c_klSingleClick,           },
    { IE4_GetFavLink, IE4_SetFavLink, 0,                                },
    { IE4_GetRest5, IE4_SetRest,    (LPARAM)TEXT("NoSMHelp"),           },
    { IE4_GetRest5, IE4_SetRest,    (LPARAM)TEXT("NoControlPanel")      },
    { IE4_GetRest5, IE4_SetRest,    (LPARAM)TEXT("NoNetworkConnections")},
    { IE4_GetRest5, IE4_SetRest,    (LPARAM)TEXT("NoWinKeys")           },
    { IE4_GetRestCNM,IE4_SetRest,   (LPARAM)TEXT("NoComputersNearMe")   },
    { IE4_GetRest5, IE4_SetRest,    (LPARAM)TEXT("NoSMMyDocs")          },
    { IE4_GetRest55,IE4_SetRest,    (LPARAM)TEXT("NoSMMyPictures")      },
};

/*****************************************************************************
 *
 *  IE4_OnWhatsThis
 *
 *****************************************************************************/

void PASCAL
IE4_OnWhatsThis(HWND hwnd, int iItem)
{
    LV_ITEM lvi;

    Misc_LV_GetItemInfo(hwnd, &lvi, iItem, LVIF_PARAM);

    WinHelp(hwnd, c_tszMyHelp, HELP_CONTEXTPOPUP,
            IDH_ADDTODOCSMENU + lvi.lParam);
}

/*****************************************************************************
 *
 *  IE4_OnCommand
 *
 *      Ooh, we got a command.
 *
 *****************************************************************************/

void PASCAL
IE4_OnCommand(HWND hdlg, int id, UINT codeNotify)
{
}

/*****************************************************************************
 *
 *  IE4_OnInitDialog
 *
 *  Initialize the listview with the current restrictions.
 *
 *****************************************************************************/

BOOL PASCAL
IE4_OnInitDialog(HWND hwnd)
{
#if 0
    HWND hdlg = GetParent(hwnd);
    TCHAR tsz[MAX_PATH];
    int dids;

    for (dids = 0; dids < cA(c_rgrest); dids++) {
        BOOL fState;

#ifdef NOINTERNET_WORKS
        LoadString(hinstCur, IDS_IE4+dids, tsz, cA(tsz));
#else
        LoadString(hinstCur, IDS_IE4+1+dids, tsz, cA(tsz));
#endif

        fState = GetRestriction(c_rgrest[dids].ptsz);
        LV_AddItem(hwnd, dids, tsz, -1, fState);

    }
#endif

#ifdef NOINTERNET_WORKS
    Checklist_OnInitDialog(hwnd, c_rgcliIE4, cA(c_rgcliIE4), IDS_IE4, 0);
#else
    Checklist_OnInitDialog(hwnd, c_rgcliIE4, cA(c_rgcliIE4), IDS_IE4+1, 0);
#endif

    return 1;
}

/*****************************************************************************
 *
 *  IE4_OnApply
 *
 *****************************************************************************/

void PASCAL
IE4_OnApply(HWND hdlg)
{
    BOOL fChanged = FALSE;

    Checklist_OnApply(hdlg, c_rgcliIE4, &fChanged, FALSE);

    if (fChanged) {
        PIDL pidl;

        /*
         *  Tell the shell that we changed the policies.
         */
        SendMessage(HWND_BROADCAST, WM_SETTINGCHANGE, 0,
                    (LPARAM)c_tszIE4RegKeyChange);

        /*
         *  Tickle the Start Menu folder to force the Start Menu
         *  to rebuild with the new policies in effect.
         */
        if (SUCCEEDED(SHGetSpecialFolderLocation(hdlg,
                                                 CSIDL_STARTMENU, &pidl))) {
            SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_IDLIST, pidl, 0);
            Ole_Free(pidl);
        }
    }
}

/*****************************************************************************
 *
 *  Oh yeah, we need this too.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

LVCI lvciIE4[] = {
    { IDC_WHATSTHIS,        IE4_OnWhatsThis },
    { 0,                    0 },
};

LVV lvvIE4 = {
    IE4_OnCommand,
    0,                          /* IE4_OnInitContextMenu */
    0,                          /* IE4_Dirtify */
    0,                          /* IE4_GetIcon */
    IE4_OnInitDialog,
    IE4_OnApply,
    0,                          /* IE4_OnDestroy */
    0,                          /* IE4_OnSelChange */
    6,                          /* iMenu */
    rgdwHelp,
    0,                          /* Double-click action */
    lvvflCanCheck,              /* We need check boxes */
    lvciIE4,
};

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *  Our window procedure.
 *
 *****************************************************************************/

INT_PTR EXPORT
IE4_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    return LV_DlgProc(&lvvIE4, hdlg, wm, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tweakui\lvchk.cpp ===
/*
 * lvchk - common dialog proc handler for check-listview pages
 */

#include "tweakui.h"

#pragma BEGIN_CONST_DATA

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *  Checklist_OnInitDialog
 *
 *  Walk the items that can live on the checklist.
 *
 *  If the item can't report its state, then don't put it on the list.
 *
 *****************************************************************************/

void PASCAL
Checklist_OnInitDialog(HWND hwnd, PCCHECKLISTITEM rgcli, int ccli,
                       UINT ids, LPVOID pvRef)
{
    TCHAR tsz[MAX_PATH];
    int dids;

    for (dids = 0; dids < ccli; dids++) {
        BOOL f = rgcli[dids].GetCheckValue(rgcli[dids].lParam, pvRef);
        if (f >= 0) {
            LoadString(hinstCur, ids+dids, tsz, cA(tsz));
            LV_AddItem(hwnd, dids, tsz, -1, f);
        }
    }
}

/*****************************************************************************
 *
 *  Checklist_OnApply
 *
 *  Walk the items in the checklist and dork them if they have changed.
 *
 *  The fForce flag forces us to call the callback even if nothing changed.
 *
 *****************************************************************************/

void PASCAL
Checklist_OnApply(HWND hdlg, PCCHECKLISTITEM rgcli, LPVOID pvRef, BOOL fForce)
{
    HWND hwnd = GetDlgItem(hdlg, IDC_ICONLV);
    int cItems = ListView_GetItemCount(hwnd);
    LV_ITEM lvi;

    for (lvi.iItem = 0; lvi.iItem < cItems; lvi.iItem++) {
        BOOL fNew, fOld;
        lvi.stateMask = LVIS_STATEIMAGEMASK;
        Misc_LV_GetItemInfo(hwnd, &lvi, lvi.iItem, LVIF_PARAM | LVIF_STATE);
        fNew = LV_IsChecked(&lvi);
        fOld = rgcli[lvi.lParam].GetCheckValue(rgcli[lvi.lParam].lParam,
                                               pvRef);
        if (fOld >= 0 && (fForce || fNew != fOld)) {
            if (!rgcli[lvi.lParam].SetCheckValue(fNew, rgcli[lvi.lParam].lParam,
                                                 pvRef)) {
                lvi.state = INDEXTOSTATEIMAGEMASK(fOld + 1);
                ListView_SetItem(hwnd, &lvi);   /* Restore the state */
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tweakui\mycomp.cpp ===
/*
 * mycomp - Dialog box property sheet for "My Computer"
 *
 *  For now, we display only Drives.
 */

#include "tweakui.h"

#pragma BEGIN_CONST_DATA

const static DWORD CODESEG rgdwHelp[] = {
	IDC_ICONLVTEXT,		IDH_GROUP,
	IDC_ICONLVTEXT2,	IDH_MYCOMP,
	IDC_ICONLV,		IDH_MYCOMP,

        IDC_FLDGROUP,           IDH_GROUP,
        IDC_FLDNAMETXT,         IDH_FOLDERNAME,
        IDC_FLDNAMELIST,        IDH_FOLDERNAME,
        IDC_FLDLOCTXT,          IDH_FOLDERNAME,
        IDC_FLDLOC,             IDH_FOLDERNAME,
        IDC_FLDCHG,             IDH_FOLDERNAME,

	0,			0,
};

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *  CFolderDesc - Describes a single special folder
 *
 *****************************************************************************/

#define MAKEKL(nm) \
    KL const c_kl##nm = { &pcdii->hkCUExplorer, \
			  c_tszUserShellFolders, c_tsz##nm }

MAKEKL(Desktop);
MAKEKL(Programs);
MAKEKL(Personal);
MAKEKL(Favorites);
MAKEKL(Startup);
MAKEKL(Recent);
MAKEKL(SendTo);
MAKEKL(StartMenu);
MAKEKL(Templates);

KL const c_klMyMusic    = { &pcdii->hkCUExplorer, c_tszUserShellFolders, TEXT("My Music") };
KL const c_klMyVideo    = { &pcdii->hkCUExplorer, c_tszUserShellFolders, TEXT("My Video") };
KL const c_klMyPictures = { &pcdii->hkCUExplorer, c_tszUserShellFolders, TEXT("My Pictures") };

#undef MAKEKL

KL const c_klProgramFiles = { &g_hkLMSMWCV, 0, c_tszProgramFilesDir };
KL const c_klCommonFiles  = { &g_hkLMSMWCV, 0, c_tszCommonFilesDir };
KL const c_klSourcePath   = { &g_hkLMSMWCV, c_tszSetup, c_tszSourcePath };

/*
 *  HACKHACK - Fake some private CSIDL's
 *             by stealing the various CSIDL_COMMON_* values.
 */
enum {
    CSIDL_SOURCEPATH    = CSIDL_COMMON_STARTUP,
};

/*
 *  Declare as a struct so you can initialize it statically.
 */
struct CFolderDesc {        /* fldd */

    PIDL GetPidl() const;
    BOOL SetValue(LPTSTR ptsz) const;   /* returns fNeedLogoff */
    inline int GetFriendlyName(LPTSTR pszBuf, int cch) const
    {
        return LoadString(hinstCur, _csidl + IDS_FOLDER_BASE, pszBuf, cch);
    }

    UINT _csidl;
    PKL  _pkl;

    /*
     *  These are really private members, but you can't say "private"
     *  in a struct definition if you want it to be statically initializable.
     */
    static BOOL _UnexpandEnvironmentString(LPTSTR ptsz, LPCTSTR ptszEnv);
    static void _SetUserShellFolder(LPTSTR ptsz, LPCTSTR ptszSubkey);

};

/*****************************************************************************
 *
 *  CFolderDesc::GetPidl
 *
 *      Wrapper around SHGetSpecialFolderLocation that also knows how
 *      to read our hacky values.
 *
 *****************************************************************************/

PIDL
CFolderDesc::GetPidl() const
{
    HRESULT hres;
    PIDL pidl;
    TCHAR tszPath[MAX_PATH];

    switch (_csidl) {
    case CSIDL_PROGRAM_FILES:
    case CSIDL_PROGRAM_FILES_COMMON:
    case CSIDL_SOURCEPATH:
        if (GetStrPkl(tszPath, cbX(tszPath), _pkl)) {
            pidl = pidlSimpleFromPath(tszPath);
        } else {
            pidl = NULL;
        }
        break;

    default:
        if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, _csidl, &pidl))) {
        } else {
            pidl = NULL;
        }
        break;
    }

    return pidl;
}

/*****************************************************************************
 *
 *  CFolderDesc::_UnexpandEnvironmentString
 *
 *      If the string begins with the value of the environment string,
 *      then change it to said string.
 *
 *      Example:
 *              In: "C:\WINNT\SYSTEM32\FOO.TXT", "%SystemRoot%"
 *              Out: "%SystemRoot%\SYSTEM32\FOO.TXT"
 *
 *****************************************************************************/

BOOL
CFolderDesc::_UnexpandEnvironmentString(LPTSTR ptsz, LPCTSTR ptszEnv)
{
    TCHAR tszEnv[MAX_PATH];
    DWORD ctch;
    BOOL fRc;

    /*
     *  Note that NT ExpandEnvironmentStrings returns the wrong
     *  value, so we can't rely on it.
     */
    ExpandEnvironmentStrings(ptszEnv, tszEnv, cA(tszEnv));
    ctch = lstrlen(tszEnv);

    /*
     *  Source must be at least as long as the env string for
     *  us to have a chance of succeeding.  This check avoids
     *  accidentally reading past the end of the source.
     */
    if ((DWORD)lstrlen(ptsz) >= ctch) {
        if (CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE,
                          tszEnv, ctch, ptsz, ctch) == 2) {
            int ctchEnv = lstrlen(ptszEnv);
            /*
             *  Must use hmemcpy to avoid problems with overlap.
             */
            hmemcpy(ptsz + ctchEnv, ptsz + ctch,
                    cbCtch(1 + lstrlen(ptsz + ctch)));
            hmemcpy(ptsz, ptszEnv, ctchEnv);
            fRc = 1;
        } else {
            fRc = 0;
        }
    } else {
        fRc = 0;
    }
    return fRc;
}

/*****************************************************************************
 *
 *  CFolderDesc::_SetUserShellFolder
 *
 *  Don't use REG_EXPAND_SZ if the shell doesn't support it.
 *
 *****************************************************************************/

void
CFolderDesc::_SetUserShellFolder(LPTSTR ptsz, LPCTSTR ptszSubkey)
{
    HKEY hk;
    if (g_fShellSz) {
        if (!_UnexpandEnvironmentString(ptsz, TEXT("%USERPROFILE%")) &&
            !_UnexpandEnvironmentString(ptsz, TEXT("%SystemRoot%"))) {
        }
    }

    if (RegCreateKey(pcdii->hkCUExplorer, c_tszUserShellFolders, &hk) == 0) {
        RegSetValueEx(hk, ptszSubkey, 0, g_fShellSz ? REG_EXPAND_SZ
                                                    : REG_SZ, (LPBYTE)ptsz,
                      cbCtch(1 + lstrlen(ptsz)));
        RegCloseKey(hk);
    }
}

/*****************************************************************************
 *
 *  CFolderDesc::SetValue
 *
 *      Stash the puppy.
 *
 *      Returns nonzero if logoff required.
 *
 *****************************************************************************/

BOOL
CFolderDesc::SetValue(LPTSTR ptsz) const
{
    TCHAR tszDefault[MAX_PATH];
    UINT ctch;
    BOOL fNeedLogoff = FALSE;

    /*
     *  Is it already in the default location?
     *
     *  Note that the special gizmos don't have default
     *  locations.
     */
    ctch = GetWindowsDirectory(tszDefault, cA(tszDefault));
    if (ctch && tszDefault[ctch - 1] != TEXT('\\')) {
        tszDefault[ctch++] =  TEXT('\\');
    }

    if (LoadString(hinstCur, _csidl + IDS_DEFAULT_BASE,
                   &tszDefault[ctch], cA(tszDefault) - ctch)) {
        if (lstrcmpi(tszDefault, ptsz) == 0) {
            /*
             *  In default location.
             */
            DelPkl(_pkl);
        } else {
            /*
             *  In other location.
             *
             *  Note that we cannot use SetStrPkl here, because
             *  we need to set the value type to REG_EXPAND_SZ.
             *
             */
            _SetUserShellFolder(ptsz, _pkl->ptszSubkey);

        }
        fNeedLogoff = TRUE;
    } else {
        SetStrPkl(_pkl, ptsz);

        /*
         *  On NT5, Program Files and Common Files are CSIDLs,
         *  and Program Files is an environment variable!
         */
        if (g_fNT5 && (_csidl == CSIDL_PROGRAM_FILES ||
                       _csidl == CSIDL_PROGRAM_FILES_COMMON)) {
            fNeedLogoff = TRUE;
        }
    }
    return fNeedLogoff;
}

/*****************************************************************************
 *
 *  CSpecialFolders -- Wangle the "special folders" combobox
 *
 *****************************************************************************/

static const CFolderDesc c_rgfldd[] = {
    {   CSIDL_DESKTOPDIRECTORY, &c_klDesktop },
    {   CSIDL_PROGRAMS,         &c_klPrograms },
    {   CSIDL_PERSONAL,         &c_klPersonal },
    {   CSIDL_FAVORITES,        &c_klFavorites },
    {   CSIDL_STARTUP,          &c_klStartup },
    {   CSIDL_RECENT,           &c_klRecent },
    {   CSIDL_SENDTO,           &c_klSendTo },
    {   CSIDL_STARTMENU,        &c_klStartMenu },
    {   CSIDL_TEMPLATES,        &c_klTemplates },
    {   CSIDL_MYMUSIC,          &c_klMyMusic },
    {   CSIDL_MYVIDEO,          &c_klMyVideo },
    {   CSIDL_MYPICTURES,       &c_klMyPictures },
    {   CSIDL_PROGRAM_FILES,     &c_klProgramFiles },
    {   CSIDL_PROGRAM_FILES_COMMON,      &c_klCommonFiles },
    {   CSIDL_SOURCEPATH,       &c_klSourcePath },
};

#define cfldd       cA(c_rgfldd)

class CSpecialFolders {

public:
    void Init(HWND hwndCombo, HWND hwndText);
    void Resync();
    void Destroy();
    BOOL Apply();               /* returns fNeedLogoff */
    void ChangeFolder(HWND hdlg);

private:

    typedef struct FOLDERINSTANCE {
        BOOL    fEdited;
        PIDL    pidl;
    } FINST, *PFINST;

    static int CALLBACK _ChangeFolder_Callback(HWND hwnd, UINT wm, LPARAM lp, LPARAM lpRef);

    HWND    _hwndCombo;
    HWND    _hwndText;          /* IDC_FLDLOC */
    BOOL    _fWarned;           /* Did we warn about changing folders? */
    PIDL    _pidlEditing;       /* Which one is the user editing? */
    FINST   _rgfinst[cfldd];
};

/*****************************************************************************
 *
 *  CSpecialFolders::Destroy
 *
 *      Free the memory.
 *
 *****************************************************************************/

void
CSpecialFolders::Destroy()
{
    UINT i;

    for (i = 0; i < cfldd; i++) {
        _rgfinst[i].fEdited = 0;
        if (_rgfinst[i].pidl) {
            Ole_Free(_rgfinst[i].pidl);
            _rgfinst[i].pidl = 0;
        }
    }
}

/*****************************************************************************
 *
 *  CSpecialFolders::Reset
 *
 *****************************************************************************/

void
CSpecialFolders::Init(HWND hwndCombo, HWND hwndText)
{
    _hwndCombo = hwndCombo;
    _hwndText = hwndText;

    /*
     *  Free the old memory, if any.
     */
    Destroy();

    /*
     *  Set up the new combobox.
     */
    ComboBox_ResetContent(_hwndCombo);

    UINT i;
    for (i = 0; i < cfldd; i++) {
        _rgfinst[i].pidl = c_rgfldd[i].GetPidl();
        if (_rgfinst[i].pidl) {

            TCHAR tsz[MAX_PATH];
            c_rgfldd[i].GetFriendlyName(tsz, cA(tsz));
            int iItem = ComboBox_AddString(_hwndCombo, tsz);
            ComboBox_SetItemData(_hwndCombo, iItem, i);
        }
    }
    ComboBox_SetCurSel(_hwndCombo, 0);
    Resync();

}

/*****************************************************************************
 *
 *  CSpecialFolders::Resync
 *
 *      Update goo since the combo box changed.
 *
 *****************************************************************************/

void
CSpecialFolders::Resync()
{
    LRESULT icsidl = Misc_Combo_GetCurItemData(_hwndCombo);
    TCHAR tsz[MAX_PATH];

    tsz[0] = TEXT('\0');
    SHGetPathFromIDList(_rgfinst[icsidl].pidl, tsz);

    SetWindowText(_hwndText, tsz);
}

/*****************************************************************************
 *
 *  CSpecialFolders::Apply
 *
 *      Updating the Folder locations is really annoying, thanks
 *      to NT's roving profiles.
 *
 *****************************************************************************/

BOOL
CSpecialFolders::Apply()
{
    UINT i;
    BOOL fNeedLogoff = FALSE;

    for (i = 0; i < cfldd; i++) {
        if (_rgfinst[i].fEdited) {
            TCHAR tsz[MAX_PATH];

            SHGetPathFromIDList(_rgfinst[i].pidl, tsz);

            BOOL fNeedLogoffT = c_rgfldd[i].SetValue(tsz);
            fNeedLogoff |= fNeedLogoffT;
        }
    }
    return fNeedLogoff;
}

/*****************************************************************************
 *
 *  CSpecialFolders::_ChangeFolder_Callback
 *
 *      Start the user at the old location, and don't let the user pick
 *      something that collides with something else.
 *
 *****************************************************************************/

int CALLBACK
CSpecialFolders::_ChangeFolder_Callback(HWND hwnd, UINT wm, LPARAM lp, LPARAM lpRef)
{
    CSpecialFolders *self = (CSpecialFolders *)lpRef;
    int icsidl;
    TCHAR tsz[MAX_PATH];

    switch (wm) {
    case BFFM_INITIALIZED:
        SendMessage(hwnd, BFFM_SETSELECTION, 0, (LPARAM)self->_pidlEditing);
        break;

    case BFFM_SELCHANGED:
        /* Picking nothing is bad */
        if (!lp) goto bad;

        /* Picking yourself is okay; just don't pick somebody else */
        if (ComparePidls((PIDL)lp, self->_pidlEditing) == 0) goto done;

        for (icsidl = 0; icsidl < cfldd; icsidl++) {
            if (self->_rgfinst[icsidl].pidl &&
                ComparePidls(self->_rgfinst[icsidl].pidl, (PIDL)lp) == 0) {
        bad:;
                SendMessage(hwnd, BFFM_ENABLEOK, 0, 0);
                goto done;
            }
        }

        /* Don't allow a removable drive */
        tsz[1] = TEXT('\0');            /* Not a typo */
        SHGetPathFromIDList((PIDL)lp, tsz);

        if (tsz[1] == TEXT(':')) {
            tsz[3] = TEXT('\0');
            if (GetDriveType(tsz) == DRIVE_REMOVABLE) {
                goto bad;
            }
        }

        break;
    }
done:;
    return 0;
}

/*****************************************************************************
 *
 *  CSpecialFolders::ChangeFolder
 *
 *****************************************************************************/

void
CSpecialFolders::ChangeFolder(HWND hdlg)
{
  if (_fWarned ||
      MessageBoxId(hdlg, IDS_WARNFOLDERCHANGE, g_tszName,
                   MB_YESNO | MB_DEFBUTTON2) == IDYES) {

    int iItem;
    int icsidl;
    BROWSEINFO bi;
    LPITEMIDLIST pidl;
    TCHAR tsz[MAX_PATH];
    TCHAR tszTitle[MAX_PATH];
    TCHAR tszName[MAX_PATH];

    _fWarned = TRUE;

    iItem = ComboBox_GetCurSel(_hwndCombo);
    ComboBox_GetLBText(_hwndCombo, iItem, tszName);

    LoadString(hinstCur, IDS_FOLDER_PATTERN, tsz, cA(tsz));
    wsprintf(tszTitle, tsz, tszName);

    bi.hwndOwner = hdlg;
    bi.pidlRoot = 0;
    bi.pszDisplayName = tsz; /* Garbage */
    bi.lpszTitle = tszTitle;
    bi.ulFlags = BIF_RETURNONLYFSDIRS;
    bi.lpfn = _ChangeFolder_Callback;
    icsidl = (int)ComboBox_GetItemData(_hwndCombo, iItem);
    _pidlEditing = _rgfinst[icsidl].pidl;
    bi.lParam = (LPARAM)this;

    pidl = SHBrowseForFolder(&bi);

    if (pidl) {
        if (ComparePidls(pidl, _rgfinst[icsidl].pidl) != 0) {
            Ole_Free(_rgfinst[icsidl].pidl);
            _rgfinst[icsidl].pidl = (PIDL)pidl;
            _rgfinst[icsidl].fEdited = TRUE;
            Common_SetDirty(hdlg);
            Resync();
        } else {
            Ole_Free(pidl);
        }
    }
  }
}

/*****************************************************************************
 *
 *  My Computer Dialog Info
 *
 *****************************************************************************/

typedef class _MDI {           /* mdi = my computer dialog info */
public:
    DWORD dwNoDrives;
    DWORD dwValidDrives;
    CSpecialFolders _sf;
} MDI, *PMDI;

MDI mdi;
#define pdmi (&mdi)

/*****************************************************************************
 *
 *  MyComp_BuildRoot
 *
 *	Build the root directory of a drive.  The buffer must be 4 chars.
 *
 *****************************************************************************/

LPTSTR PASCAL
MyComp_BuildRoot(LPTSTR ptsz, UINT uiDrive)
{
    ptsz[0] = uiDrive + TEXT('A');
    ptsz[1] = TEXT(':');
    ptsz[2] = TEXT('\\');
    ptsz[3] = TEXT('\0');
    return ptsz;
}

/*****************************************************************************
 *
 *  MyComp_LV_GetIcon
 *
 *	Produce the icon associated with an item.  This is called when
 *	we need to rebuild the icon list after the icon cache has been
 *	purged.
 *
 *****************************************************************************/

#define idiPhantom	-11	/* Magic index for disconnected drive */

int PASCAL
MyComp_LV_GetIcon(LPARAM insi)
{
    if (pdmi->dwValidDrives & (1 << insi)) {
	SHFILEINFO sfi;
	TCHAR tszRoot[4];		/* Root directory thing */

	SHGetFileInfo(MyComp_BuildRoot(tszRoot, (UINT)insi), 0, &sfi, cbX(sfi),
		      SHGFI_SYSICONINDEX | SHGFI_SMALLICON);
	return sfi.iIcon;
    } else {
	if (g_fNT) {
	    UnicodeFromPtsz(wsz, g_tszPathShell32);
	    return mit.Shell_GetCachedImageIndex(wsz, idiPhantom, 0);
	} else {
	    return mit.Shell_GetCachedImageIndex(g_tszPathShell32,
						 idiPhantom, 0);
	}
    }
}

/*****************************************************************************
 *
 *  MyComp_OnInitDialog
 *
 *  For now, just populate with each physical local drive.
 *
 *****************************************************************************/

BOOL PASCAL
MyComp_OnInitDialog(HWND hwnd)
{
    UINT ui;
    TCHAR tszDrive[3];
    tszDrive[1] = TEXT(':');
    tszDrive[2] = TEXT('\0');

    pdmi->dwNoDrives = GetRegDword(g_hkCUSMWCV, c_tszRestrictions,
				   c_tszNoDrives, 0);
    pdmi->dwValidDrives = GetLogicalDrives();

    for (ui = 0; ui < 26; ui++) {
	int iIcon = MyComp_LV_GetIcon(ui);
	tszDrive[0] = ui + TEXT('A');
	LV_AddItem(hwnd, ui, tszDrive, iIcon, !(pdmi->dwNoDrives & (1 << ui)));
    }

    /*
     *  And initialize the special folders stuff.
     */
    HWND hdlg = GetParent(hwnd);
    pdmi->_sf.Init(GetDlgItem(hdlg, IDC_FLDNAMELIST),
                   GetDlgItem(hdlg, IDC_FLDLOC));

    return 1;
}

/*****************************************************************************
 *
 *  MyComp_OnDestroy
 *
 *  Free the memory we allocated.
 *
 *****************************************************************************/

void PASCAL
MyComp_OnDestroy(HWND hdlg)
{
    /*
     *  Destroy the special folders stuff.
     */
    pdmi->_sf.Destroy();
}

#if 0
/*****************************************************************************
 *
 *  MyComp_FactoryReset
 *
 *	This is scary and un-undoable, so let's do extra confirmation.
 *
 *****************************************************************************/

void PASCAL
MyComp_FactoryReset(HWND hdlg)
{
    if (MessageBoxId(hdlg, IDS_MyCompRESETOK,
		     tszName, MB_YESNO + MB_DEFBUTTON2) == IDYES) {
	pcdii->fRunShellInf = 1;
	Common_NeedLogoff(hdlg);
	PropSheet_Apply(GetParent(hdlg));
    }
}
#endif

/*****************************************************************************
 *
 *  MyComp_OnApply
 *
 *	Write the changes to the registry.
 *
 *****************************************************************************/

void PASCAL
MyComp_OnApply(HWND hdlg)
{
    HWND hwnd = GetDlgItem(hdlg, IDC_ICONLV);
    DWORD dwDrives = 0;
    LV_ITEM lvi;

    for (lvi.iItem = 0; lvi.iItem < 26; lvi.iItem++) {
	lvi.stateMask = LVIS_STATEIMAGEMASK;
	Misc_LV_GetItemInfo(hwnd, &lvi, lvi.iItem, LVIF_STATE);
	if (!LV_IsChecked(&lvi)) {
	    dwDrives |= 1 << lvi.iItem;
	}
    }

    if (pdmi->dwNoDrives != dwDrives) {
	DWORD dwChanged;
	UINT ui;
	TCHAR tszRoot[4];

	SetRegDword(g_hkCUSMWCV, c_tszRestrictions, c_tszNoDrives, dwDrives);

	/* Recompute GetLogicalDrives() in case new drives are here */
	dwChanged = (pdmi->dwNoDrives ^ dwDrives) & GetLogicalDrives();

	pdmi->dwNoDrives = dwDrives;
	/*
	 *  SHCNE_UPDATEDIR doesn't work for CSIDL_DRIVES because
	 *  Drivesx.c checks the restrictions only in response to a
	 *  SHCNE_ADDDRIVE.  So walk through every drive that changed
	 *  and send a SHCNE_DRIVEADD or SHCNE_DRIVEREMOVED for it.
	 */
	for (ui = 0; ui < 26; ui++) {
	    DWORD dwMask = 1 << ui;
	    if (dwChanged & dwMask) {
		MyComp_BuildRoot(tszRoot, ui);
		SHChangeNotify((dwDrives & dwMask) ? SHCNE_DRIVEREMOVED
						   : SHCNE_DRIVEADD,
			       SHCNF_PATH, tszRoot, 0L);
	    }
	}
    }

    /*
     *  And update the special folders, too.
     */
    BOOL fNeedLogoff = pdmi->_sf.Apply();
    if (fNeedLogoff) {
        Common_NeedLogoff(hdlg);
    }

}

/*****************************************************************************
 *
 *  MyComp_OnCommand
 *
 *      Ooh, we got a command.
 *
 *****************************************************************************/

void PASCAL
MyComp_OnCommand(HWND hdlg, int id, UINT codeNotify)
{
    switch (id) {

    case IDC_FLDNAMELIST:
        if (codeNotify == CBN_SELCHANGE) pdmi->_sf.Resync();
        break;

    case IDC_FLDCHG:
        if (codeNotify == BN_CLICKED) pdmi->_sf.ChangeFolder(hdlg);
        break;
    }
}

/*****************************************************************************
 *
 *  Oh yeah, we need this too.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

LVV lvvMyComp = {
    MyComp_OnCommand,
    0,
    0,                          /* MyComp_LV_Dirtify */
    MyComp_LV_GetIcon,
    MyComp_OnInitDialog,
    MyComp_OnApply,
    MyComp_OnDestroy,
    0,
    4,				/* iMenu */
    rgdwHelp,
    0,				/* Double-click action */
    lvvflIcons |                /* We need icons */
    lvvflCanCheck,              /* And check boxes */
    NULL,
};

#pragma END_CONST_DATA


/*****************************************************************************
 *
 *  Our window procedure.
 *
 *****************************************************************************/

INT_PTR EXPORT
MyComp_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    return LV_DlgProc(&lvvMyComp, hdlg, wm, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tweakui\lv.cpp ===
/*
 * lv - common dialog proc handler for listview pages
 */

#include "tweakui.h"

#pragma BEGIN_CONST_DATA

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *  LV_AddItem
 *
 *  Add an entry to the listview.
 *
 *  Returns the resulting item number.
 *
 *****************************************************************************/

int PASCAL
LV_AddItem(HWND hwnd, int ix, LPCTSTR ptszDesc, int iImage, BOOL fState)
{
    LV_ITEM lvi;
    lvi.mask = LVIF_TEXT | LVIF_PARAM;
    lvi.iItem = MAXLONG;
    lvi.iSubItem = 0;			/* Must be zero */
    lvi.pszText = (LPTSTR)ptszDesc;
    lvi.lParam = ix;			/* Take it */

    if (iImage >= 0) {
	lvi.iImage = iImage;
	lvi.mask |= LVIF_IMAGE;
    }

    if (fState >= 0) {
	lvi.state = INDEXTOSTATEIMAGEMASK(fState + 1);
	lvi.mask |= LVIF_STATE;
    }

    return ListView_InsertItem(hwnd, &lvi);
}


/*****************************************************************************
 *
 *  LV_Toggle
 *
 *  Toggle the state icon of the current selection.
 *
 *****************************************************************************/

void PASCAL
LV_Toggle(HWND hwnd, int iItem)
{
    LV_ITEM lvi;
    lvi.stateMask = LVIS_STATEIMAGEMASK;
    Misc_LV_GetItemInfo(hwnd, &lvi, iItem, LVIF_STATE);
    if (lvi.state & LVIS_STATEIMAGEMASK) {
        lvi.state ^= INDEXTOSTATEIMAGEMASK(1) ^
                     INDEXTOSTATEIMAGEMASK(2); /* toggle checkmark */
	ListView_SetItem(hwnd, &lvi);	/* Set the state */
	Common_SetDirty(GetParent(hwnd));
    }
}

/*****************************************************************************
 *
 *  LV_Rename
 *
 *	Rename an item in the list view.
 *
 *****************************************************************************/

void PASCAL
LV_Rename(HWND hwnd, int iItem)
{
    ListView_EditLabel(hwnd, iItem);
}

/*****************************************************************************
 *
 *  LV_ResizeReportColumn
 *
 *      Resize the column in the report to be as large as possible without
 *      colliding with the vertical scrollbar (if any).
 *
 *****************************************************************************/

void PASCAL
LV_ResizeReportColumn(HWND hwnd)
{
    ListView_SetColumnWidth(hwnd, 0, LVSCW_AUTOSIZE);
}

/*****************************************************************************
 *
 *  LV_OnInitDialog
 *
 *  The callback will initialize the listview.
 *
 *  Once the callback is happy, we initialize the columns.
 *
 *  All of our listviews are simple reports with but one column.
 *
 *****************************************************************************/

/* New IE5 feature we will use if available */
#define LVS_EX_LABELTIP         0x00004000
#define LVM_SETEXTENDEDLISTVIEWSTYLE (LVM_FIRST + 54)
#define ListView_SetExtendedListViewStyle(hwndLV, dw)\
        (DWORD)SNDMSG((hwndLV), LVM_SETEXTENDEDLISTVIEWSTYLE, 0, dw)

BOOL PASCAL
LV_OnInitDialog(PLVV plvv, HWND hdlg)
{
    HWND hwnd = GetDlgItem(hdlg, IDC_LISTVIEW);

    ListView_SetExtendedListViewStyle(hwnd, LVS_EX_LABELTIP);

    if (plvv->lvvfl & lvvflCanCheck) {
        ListView_SetImageList(hwnd, pcdii->himlState, LVSIL_STATE);
    }

    if (plvv->lvvfl & lvvflIcons) {
	ListView_SetImageList(hwnd, GetSystemImageList(SHGFI_SMALLICON),
						 LVSIL_SMALL);
    }

    if (plvv->OnInitDialog(hwnd)) {	/* Add the column to the report */
        LV_COLUMN col;
        col.mask = 0;
        ListView_InsertColumn(hwnd, 0, &col);
        LV_ResizeReportColumn(hwnd);
        Misc_LV_SetCurSel(hwnd, 0);
    }
    return 1;
}

/*****************************************************************************
 *
 *  LV_OnLvContextMenu
 *
 *	The context menu shall appear in the listview.
 *
 *	Allow the callback to modify the menu before we pop it up.
 *	Then let the window procedure's WM_COMMAND do the rest.
 *
 *      If lvvflCanCheck is set, we will automatically adjust IDC_LVTOGGLE
 *	to match.
 *
 *	If lvvflCanDelete is set, we will adjust IDC_LVDELETE to match.
 *
 *****************************************************************************/

void PASCAL
LV_OnLvContextMenu(PLVV plvv, HWND hdlg, HWND hwnd, POINT pt)
{
    int iItem = Misc_LV_GetCurSel(hwnd);
    if (iItem != -1) {
	HMENU hmenu;

	ClientToScreen(hwnd, &pt);	/* Make it screen coordinates */
	hmenu = GetSubMenu(pcdii->hmenu, plvv->iMenu);

        if (plvv->lvvfl & lvvflCanCheck) {
	    MENUITEMINFO mii;
	    LV_ITEM lvi;
	    lvi.stateMask = LVIS_STATEIMAGEMASK;
	    Misc_LV_GetItemInfo(hwnd, &lvi, iItem, LVIF_STATE);

	    mii.cbSize = cbX(mii);
	    mii.fMask = MIIM_STATE;
	    switch (isiPlvi(&lvi)) {
	    case isiUnchecked: mii.fState = MFS_ENABLED | MFS_UNCHECKED; break;
	    case isiChecked:   mii.fState = MFS_ENABLED | MFS_CHECKED;   break;
	    default:	       mii.fState = MFS_DISABLED;	         break;
	    }

	    SetMenuItemInfo(hmenu, IDC_LVTOGGLE, 0, &mii);
	}

	if (plvv->lvvfl & lvvflCanDelete) {
	    Misc_EnableMenuFromHdlgId(hmenu, hdlg, IDC_LVDELETE);
	}

	if (plvv->OnInitContextMenu) {
	    plvv->OnInitContextMenu(hwnd, iItem, hmenu);
	}
	TrackPopupMenuEx(hmenu, TPM_RIGHTBUTTON | TPM_VERTICAL |
			 TPM_LEFTALIGN | TPM_TOPALIGN, pt.x, pt.y, hdlg, 0);
    }
}


/*****************************************************************************
 *
 *  LV_OnContextMenu
 *
 *	If the context menu came from the listview, figure out which
 *	item got clicked on.  If we find an item, pop up its context
 *	menu.  Otherwise, just do the standard help thing.
 *
 *	NOTE!  We don't use LVHT_ONITEM because ListView is broken!
 *	Watch:
 *
 *	    #define LVHT_ONITEMSTATEICON 0x0008
 *	    #define LVHT_ABOVE          0x0008
 *
 *	Oops.  This means that clicks above the item are treated as
 *	clicks on the state icon.
 *
 *	Fortunately, we reside completely in report view, so you can't
 *	legally click above the item.  The only way it can happen is
 *	if the coordinates to OnContextMenu are out of range, so we
 *	catch that up front and munge it accordingly.
 *
 *****************************************************************************/

void PASCAL
LV_OnContextMenu(PLVV plvv, HWND hdlg, HWND hwnd, LPARAM lp)
{
    if (GetDlgCtrlID(hwnd) == IDC_LISTVIEW) {
	LV_HITTESTINFO hti;
        if ((DWORD)lp == 0xFFFFFFFF) {
	    /* Pretend it was on the center of the small icon */
	    ListView_GetItemPosition(hwnd, Misc_LV_GetCurSel(hwnd),
				     &hti.pt);
	    hti.pt.x += GetSystemMetrics(SM_CXSMICON) / 2;
	    hti.pt.y += GetSystemMetrics(SM_CYSMICON) / 2;
	    LV_OnLvContextMenu(plvv, hdlg, hwnd, hti.pt);
	} else {
	    Misc_LV_HitTest(hwnd, &hti, lp);
	    if ((hti.flags & LVHT_ONITEM)) {
		/* Because LV sometimes forgets to move the focus... */
		Misc_LV_SetCurSel(hwnd, hti.iItem);
		LV_OnLvContextMenu(plvv, hdlg, hwnd, hti.pt);
	    } else {
		Common_OnContextMenu((WPARAM)hwnd, plvv->pdwHelp);
	    }
	}
    } else {
	Common_OnContextMenu((WPARAM)hwnd, plvv->pdwHelp);
    }
}


/*****************************************************************************
 *
 *  LV_OnCommand_Dispatch
 *
 *	Dispatch a recognized command to the handler.
 *
 *****************************************************************************/

void PASCAL
LV_OnCommand_Dispatch(void (PASCAL *pfn)(HWND hwnd, int iItem), HWND hdlg)
{
    HWND hwnd = GetDlgItem(hdlg, IDC_LISTVIEW);
    int iItem = Misc_LV_GetCurSel(hwnd);
    if (iItem != -1) {
	pfn(hwnd, iItem);
    }
}

/*****************************************************************************
 *
 *  LV_OnCommand
 *
 *	Ooh, we got a command.
 *
 *	See if it's one of ours.  If not, pass it through to the handler.
 *
 *****************************************************************************/

BOOL PASCAL
LV_OnCommand(PLVV plvv, HWND hdlg, int id, UINT codeNotify)
{
    PLVCI plvci;
    switch (id) {
    case IDC_LVTOGGLE:
	LV_OnCommand_Dispatch(LV_Toggle, hdlg);
	break;

    case IDC_LVRENAME:
	if (plvv->Dirtify) LV_OnCommand_Dispatch(LV_Rename, hdlg);
	break;

    default:
        if (plvv->rglvci) {
            for (plvci = plvv->rglvci; plvci[0].id; plvci++) {
                if (id == plvci->id) {
                LV_OnCommand_Dispatch(plvci->pfn, hdlg);
                goto dispatched;
                }
            }
        }
	if (plvv->OnCommand) {
	    plvv->OnCommand(hdlg, id, codeNotify);
	}
    dispatched:;
	break;
    }

    return 0;
}

/*****************************************************************************
 *
 *  LV_OnNotify_OnClick
 *
 *	Somebody clicked or double-clicked on the listview.
 *
 *****************************************************************************/

void PASCAL
LV_OnNotify_OnClick(PLVV plvv, HWND hwnd, NMHDR FAR *pnm)
{
    LV_HITTESTINFO hti;
    Misc_LV_HitTest(hwnd, &hti, (LPARAM)GetMessagePos());

    /*
     *  A click/dblclick on the item state icon toggles.
     *
     *  A click/dblclick anywhere toggles *if* you can't rename.
     */
    if (((hti.flags & LVHT_ONITEMSTATEICON) ||
         ((hti.flags & LVHT_ONITEM) && !(plvv->lvvfl & lvvflCanRename)))) {
	Misc_LV_SetCurSel(hwnd, hti.iItem);	/* LV doesn't do this, oddly */
	LV_Toggle(hwnd, hti.iItem);
    } else if (pnm->code == NM_DBLCLK && plvv->idDblClk) {
	LV_OnCommand(plvv, GetParent(hwnd), plvv->idDblClk, 0);
    } else if (pnm->code == NM_DBLCLK && (hti.flags & LVHT_ONITEMLABEL)) {
        if (plvv->lvvfl & lvvflCanRename) {
            LV_Rename(hwnd, hti.iItem);
        }
    }
}


/*****************************************************************************
 *
 *  LV_OnNotify_OnKeyDown
 *
 *	Somebody pressed a key while focus is on a listview.
 *
 *	F2 = Rename
 *	Space = Toggle
 *	Del = Delete
 *
 *****************************************************************************/

void PASCAL
LV_OnNotify_OnKeyDown(PLVV plvv, HWND hwnd, LV_KEYDOWN FAR *lvkd)
{
    int iItem = Misc_LV_GetCurSel(hwnd);
    if (iItem != -1) {
	switch (lvkd->wVKey) {
        case VK_SPACE:
            /*
             *  But not if the ALT key is down!
             */
            if (GetKeyState(VK_MENU) >= 0) {
                LV_Toggle(hwnd, iItem);
            }
            break;

        case VK_F2:
            if (plvv->lvvfl & lvvflCanRename) {
                LV_Rename(hwnd, iItem);
            }
            break;
	case VK_DELETE:
	    LV_OnCommand(plvv, GetParent(hwnd), IDC_LVDELETE, 0); break;
	    break;
	}
    }
}

/*****************************************************************************
 *
 *  LV_OnNotify_OnBeginLabelEdit
 *
 *      Allow it to go through if label editing is permitted.
 *
 *****************************************************************************/

BOOL INLINE
LV_OnNotify_OnBeginLabelEdit(PLVV plvv, HWND hdlg, HWND hwnd)
{
    if (plvv->lvvfl & lvvflCanRename) {
        return 0;
    } else {
        SetWindowLongPtr(hdlg, DWLP_MSGRESULT, TRUE);
        return 1;
    }
}

/*****************************************************************************
 *
 *  LV_OnNotify_OnEndLabelEdit
 *
 *	Trim leading and trailing whitespace.  If there's anything left,
 *	then we'll accept it.
 *
 *****************************************************************************/

void PASCAL
LV_OnNotify_OnEndLabelEdit(PLVV plvv, HWND hwnd, LV_DISPINFO FAR *lpdi)
{
    if (lpdi->item.iItem != -1 && lpdi->item.pszText) {
	LV_ITEM lvi;
	lvi.pszText = Misc_Trim(lpdi->item.pszText);
	if (lvi.pszText[0]) {
	    Misc_LV_GetItemInfo(hwnd, &lvi, lpdi->item.iItem, LVIF_PARAM);
	    lvi.mask ^= LVIF_TEXT ^ LVIF_PARAM;
	    ListView_SetItem(hwnd, &lvi);
	    Common_SetDirty(GetParent(hwnd));
	    plvv->Dirtify(lvi.lParam);
	}
    }
}

/*****************************************************************************
 *
 *  LV_OnNotify_OnItemChanged
 *
 *	If we are being told about a new selection, call the callback.
 *
 *****************************************************************************/

void PASCAL
LV_OnNotify_OnItemChanged(PLVV plvv, HWND hwnd, NM_LISTVIEW *pnmlv)
{
    if ((pnmlv->uChanged & LVIF_STATE) && (pnmlv->uNewState & LVIS_SELECTED)) {
	if (plvv->OnSelChange) {
	    plvv->OnSelChange(hwnd, pnmlv->iItem);
	}
    }
}

/*****************************************************************************
 *
 *  LV_OnNotify
 *
 *	Ooh, we got a notification.  See if it's something we recognize.
 *
 *	NOTE!  We don't support private notifications.
 *
 *****************************************************************************/

BOOL PASCAL
LV_OnNotify(PLVV plvv, HWND hdlg, NMHDR FAR *pnm)
{
    switch (pnm->idFrom) {
    case 0:			/* Property sheet */
	switch (pnm->code) {
	case PSN_APPLY:
	    plvv->OnApply(hdlg);
	    break;
	}
	break;

    case IDC_LISTVIEW:		/* List view */
	{
	    HWND hwnd = GetDlgItem(hdlg, IDC_LISTVIEW);
	    switch (pnm->code) {
	    case NM_CLICK:
	    case NM_DBLCLK:
		LV_OnNotify_OnClick(plvv, hwnd, pnm);
		break;

	    case LVN_KEYDOWN:
		LV_OnNotify_OnKeyDown(plvv, hwnd, (LV_KEYDOWN *)pnm);
		break;

            case LVN_BEGINLABELEDIT:
                return LV_OnNotify_OnBeginLabelEdit(plvv, hdlg, hwnd);

	    case LVN_ENDLABELEDIT:
		LV_OnNotify_OnEndLabelEdit(plvv, hwnd, (LV_DISPINFO *)pnm);
		break;

	    case LVN_ITEMCHANGED:
		LV_OnNotify_OnItemChanged(plvv, hwnd, (NM_LISTVIEW *)pnm);
		break;

	    }
	}
	break;
    }
    return 0;
}

/*****************************************************************************
 *
 *  LV_OnSettingChange
 *
 *****************************************************************************/

void PASCAL
LV_OnSettingChange(PLVV plvv, HWND hdlg, WPARAM wp, LPARAM lp)
{
    HWND hwnd = GetDlgItem(hdlg, IDC_LISTVIEW);

    SendMessage(hwnd, WM_SETTINGCHANGE, wp, lp);

    if (wp == SPI_SETNONCLIENTMETRICS) {

        /*  If we have icons, then go rebuild them.  */
        if (plvv->GetIcon) {
            int iItem;
            int cItem = ListView_GetItemCount(hwnd);
            for (iItem = 0; iItem < cItem; iItem++) {
                LV_ITEM lvi;
                Misc_LV_GetItemInfo(hwnd, &lvi, iItem, LVIF_PARAM);
                lvi.iImage = plvv->GetIcon(lvi.lParam);
                lvi.mask |= LVIF_IMAGE;
                ListView_SetItem(hwnd, &lvi);
            }
        }

        /*  In case the scrollbars changed size, resize to accomodate */
        LV_ResizeReportColumn(hwnd);

        /*
         *  HACK AROUND BUG IN COMCTL32.DLL - Explicitly hide and show
         *  the window.  This tickles report view into recalculating
         *  its scrollbars.
         */
        ShowWindow(hwnd, SW_HIDE);
        ShowWindow(hwnd, SW_SHOW);
    }

    /*
     *  Note: Do not need to handle WM_SETICONTITLELOGFONT because we
     *  are in a dialog and therefore will use the dialog font, not the
     *  icon title LOGFONT.
     */
}

/*****************************************************************************
 *
 *  The common listview window procedure.
 *
 *****************************************************************************/

BOOL EXPORT
LV_DlgProc(PLVV plvv, HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    switch (wm) {
    case WM_INITDIALOG:
	return LV_OnInitDialog(plvv, hdlg);

    case WM_COMMAND:
	return LV_OnCommand(plvv, hdlg,
			        (int)GET_WM_COMMAND_ID(wParam, lParam),
			        (UINT)GET_WM_COMMAND_CMD(wParam, lParam));

    case WM_HELP: Common_OnHelp(lParam, plvv->pdwHelp); break;

    case WM_NOTIFY:
	return LV_OnNotify(plvv, hdlg, (NMHDR FAR *)lParam);

    case WM_SYSCOLORCHANGE:
	FORWARD_WM_SYSCOLORCHANGE(GetDlgItem(hdlg, IDC_LISTVIEW), SendMessage);
	break;

    case WM_DESTROY:
        if (plvv->OnDestroy) plvv->OnDestroy(hdlg);
        break;

    case WM_CONTEXTMENU:
	LV_OnContextMenu(plvv, hdlg, (HWND)wParam, lParam);
	break;

    case WM_SETTINGCHANGE:
	LV_OnSettingChange(plvv, hdlg, wParam, lParam);
	break;

    default: return 0;	/* Unhandled */
    }
    return 1;		/* Handled */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tweakui\mouse.cpp ===
/*
 * mouse - Dialog box property sheet for "mouse ui tweaks"
 */

#include "tweakui.h"

#pragma BEGIN_CONST_DATA

KL const c_klDelay = { &c_hkCU, c_tszRegPathDesktop, c_tszDelay };

const char CODESEG c_szUser[] = "USER";		/* Must be ANSI */

const static DWORD CODESEG rgdwHelp[] = {
	IDC_SPEEDTEXT,	    IDH_SPEEDHELP,
	IDC_SPEEDFAST,	    IDH_SPEEDHELP,
	IDC_SPEEDSLOW,	    IDH_SPEEDHELP,
	IDC_SPEEDTRACK,	    IDH_SPEEDHELP,
	IDC_SPEEDHELP,	    IDH_SPEEDHELP,

	IDC_SENSGROUP,	    IDH_GROUP,

	IDC_DBLCLKTEXT,	    IDH_DBLCLK,
	IDC_DBLCLK,	    IDH_DBLCLK,
	IDC_DBLCLKUD,	    IDH_DBLCLK,

	IDC_DRAGTEXT,	    IDH_DRAG,
	IDC_DRAG,	    IDH_DRAG,
	IDC_DRAGUD,	    IDH_DRAG,

	IDC_SENSHELP,	    IDH_GROUP,

	IDC_EFFECTGROUP,    IDH_GROUP,
	IDC_BEEP,	    IDH_BEEP,

/* SOMEDAY - SPI_GETMOUSEHOVERHEIGHT/WIDTH */

	IDC_WHEELGROUP,     IDH_GROUP,
	IDC_WHEELENABLE,    IDH_WHEEL,
	IDC_WHEELPAGE,      IDH_WHEEL,
	IDC_WHEELLINE,      IDH_WHEEL,
	IDC_WHEELLINENO,    IDH_WHEEL,

	IDC_TESTGROUP,	    IDH_TEST,
	IDC_TEST,	    IDH_TEST,

        IDC_XMOUSE,         IDH_XMOUSE,
        IDC_XMOUSERAISE,    IDH_XMOUSERAISE,
        IDC_XMOUSEDELAYTXT, IDH_XMOUSEDELAY,
        IDC_XMOUSEDELAY,    IDH_XMOUSEDELAY,

        IDC_TIPS,           IDH_TIPSTIP,
	IDC_RESET,	    IDH_RESET,

	0,		    0,
};

#pragma END_CONST_DATA

typedef WORD DT, FAR *LPDT;	/* typeof(dtMNDropDown) */

#ifdef WIN32
#define fLpdt (lpdt != &dtScratch)
#else
#define fLpdt (SELECTOROF(lpdt) != SELECTOROF((LPDT)&dtScratch))
#endif

/*
 * Globals
 */
DT dtScratch;		/* Point lpdt here if we are stuck */
DT dtNT;		/* Point lpdt here if we are on NT */

LPDT lpdt;		/* Where to tweak to adjust the actual dt */

/*
 * Instanced.  We're a cpl so have only one instance, but I declare
 * all the instance stuff in one place so it's easy to convert this
 * code to multiple-instance if ever we need to.
 */
typedef struct MDII {		/* Mouse_dialog instance info */
    BOOL fDrag;			/* Potential drag in progress? */
    DT dtOrig;			/* Original dt when we started */
    RECT rcTest;		/* Test area */
    RECT rcDrag;		/* Drag test rectangle */
    RECT rcDblClk;		/* Double click rectangle */
    LONG tmClick;		/* Time of previous lbutton down */
    HCURSOR hcurDrag;		/* What is being dragged? */
    BOOL fFactory;		/* Factory defaults? */
    POINT ptDblClk;		/* Double click values pending */
    POINT ptDrag;		/* Drag values pending */
    POINT ptDragStart;          /* Where the start click went down */
    int cxAspect;		/* Screen aspect ratio */
    int cyAspect;		/* Screen aspect ratio */
    int idi;			/* Which icon to use? */
} MDII, *PMDII;

MDII mdii;
#define pmdii (&mdii)

#define DestroyCursor(hcur) SafeDestroyIcon((HICON)(hcur))

/*****************************************************************************
 *
 *  Grovelling to find the dropmenu variable.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  dtDefault
 *
 *	Return the default dropmenu time, which is DoubleClickTime * 4 / 5.
 *
 *****************************************************************************/

DT PASCAL
dtDefault(void)
{
    return GetDoubleClickTime() * 4 / 5;
}

/*****************************************************************************
 *
 *  dtCur
 *
 *	Determine what the dropmenu time is, by external means.
 *
 *	It ought to be DoubleClickTime * 4 / 5, or the value in the registry.
 *
 *****************************************************************************/

INLINE DT
dtCur(void)
{
    return (DT)GetIntPkl(dtDefault(), &c_klDelay);
}

/*****************************************************************************
 *
 *  GetProcOrd
 *
 *  Win95 does not allow GetProcAddress to work on Kernel32, so we must
 *  implement it by hand.
 *
 *****************************************************************************/

/*
 * winnt.h uses these strange structure names.
 * Does anybody speak Hungarian over there?
 */
typedef IMAGE_DOS_HEADER IDH, *PIDH;
typedef IMAGE_NT_HEADERS NTH, *PINTH; /* I like how this is "HEADERS" plural */
typedef IMAGE_EXPORT_DIRECTORY EDT, *PEDT;
typedef DWORD EAT, *PEAT;
typedef IMAGE_DATA_DIRECTORY OTE, *POTE;

#define pvAdd(pv, cb) ((LPVOID)((LPSTR)(pv) + (DWORD)(cb)))
#define pvSub(pv1, pv2) (DWORD)((LPSTR)(pv1) - (LPSTR)(pv2))

#define poteExp(pinth) (&(pinth)->OptionalHeader. \
			  DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT])

FARPROC PASCAL
GetProcOrd(LPVOID lpv, UINT ord)
{
    PIDH pidh = (PIDH)lpv;
    if (!IsBadReadPtr(pidh, sizeof(*pidh)) &&
	pidh->e_magic == IMAGE_DOS_SIGNATURE) {
	PINTH pinth = (PINTH)pvAdd(pidh, pidh->e_lfanew);
	if (!IsBadReadPtr(pinth, sizeof(*pinth)) &&
	    pinth->Signature == IMAGE_NT_SIGNATURE) {
	    PEDT pedt = (PEDT)pvAdd(pidh, poteExp(pinth)->VirtualAddress);
	    if (!IsBadReadPtr(pedt, sizeof(*pedt)) &&
		(ord - pedt->Base) < pedt->NumberOfFunctions) {
		PEAT peat = (PEAT)pvAdd(pidh, pedt->AddressOfFunctions);
		FARPROC fp = (FARPROC)pvAdd(pidh, peat[ord - pedt->Base]);
		if (pvSub(fp, peat) >= poteExp(pinth)->Size) {
		    return fp;
		} else {		/* Forwarded!? */
		    return 0;
		}
	    } else {
		return 0;
	    }
	} else {
	    return 0;
	}
    } else {
	return 0;
    }
}

/*****************************************************************************
 *
 *  fGrovel
 *
 * Grovel into USER's DS to find the dropmenu time.
 * The problem is that there is no documented way of getting and setting
 * the dropmenu time without rebooting.  So we find it by (trust me)
 * disassembling the SetDoubleClickTime function and knowing that the
 * last instructions are
 *
 *	mov [xxxx], ax ; set drop menu time
 *	pop ds
 *	leave
 *	retf 2
 *
 *  Good news!  On Windows NT, there is a new SPI to do this.
 *
 *****************************************************************************/

typedef HINSTANCE (*LL16)(LPCSTR);
typedef FARPROC (*GPA16)(HINSTANCE, LPCSTR);
typedef BOOL (*FL16)(HINSTANCE);
typedef LPVOID (*MSL)(DWORD);

BOOL PASCAL
fGrovel(void)
{
    OSVERSIONINFO ovi;

    if (SystemParametersInfo(SPI_GETMENUSHOWDELAY, 0, &dtNT, 0)) {
        lpdt = &dtNT;
        return 1;
    }

#ifdef _X86_

    /* Else win95 - must grovel */
    ovi.dwOSVersionInfoSize = sizeof(ovi);
    if (GetVersionEx(&ovi) &&
	ovi.dwMajorVersion == 4 &&
	ovi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) {
	HINSTANCE hinstK32 = GetModuleHandle(c_tszKernel32);
	if (hinstK32) {
	    LL16 LoadLibrary16 = (LL16)GetProcOrd(hinstK32, 35);
	    FL16 FreeLibrary16 = (FL16)GetProcOrd(hinstK32, 36);
	    GPA16 GetProcAddress16 = (GPA16)GetProcOrd(hinstK32, 37);
	    MSL MapSL = (MSL)GetProcAddress(hinstK32, c_tszMapSL);
	    if ((DWORD)LoadLibrary16 & (DWORD)FreeLibrary16 &
		(DWORD)GetProcAddress16 & (DWORD)MapSL) {
		HINSTANCE hinst16 = LoadLibrary16(c_szUser);
		if ((UINT)hinst16 > 32) {
		    FARPROC fp = GetProcAddress16(hinst16,
						  MAKEINTRESOURCE(20));
		    if (fp) {
			LPBYTE lpSDCT;
			GetDoubleClickTime(); /* Force segment present */
			lpSDCT = (LPBYTE)MapSL((DWORD)fp);
			if (!IsBadReadPtr(lpSDCT, 84)) {
			    int i;
			    for (i = 0; i < 80; i++, lpSDCT++) {
				if (*(LPDWORD)lpSDCT == 0x02CAC91F) {
				    lpdt = (LPDT)MapSL(MAKELONG(
					     *(LPWORD)(lpSDCT - 2),
						hinst16));
				    return *lpdt == dtCur();
				}
			    }
			}
		    }
		    FreeLibrary16(hinst16);
		}
	    }
	}
    }
#endif
    return 0;
}

/*****************************************************************************
 *
 *  msDt
 *
 *	Get the actual drop time if possible.  Don't all this unless
 *	you know it'll work.
 *
 *****************************************************************************/

DT PASCAL
msDt(void)
{
    if (lpdt == &dtNT) {
	SystemParametersInfo(SPI_GETMENUSHOWDELAY, 0, &dtNT, 0);
    }
    return (DT)*lpdt;
}

/*****************************************************************************
 *
 *  SetDt
 *
 *	Set the drop time, returning TRUE if we need a reboot.
 *
 *****************************************************************************/

BOOL PASCAL
SetDt(UINT ms, DWORD spif)
{
#ifdef _X86_
    if (lpdt == &dtNT) {
#endif
	SystemParametersInfo(SPI_SETMENUSHOWDELAY, ms, 0, spif);
	return 0;
#ifdef _X86_
    } else {
	if (spif & SPIF_UPDATEINIFILE) {
	    SetIntPkl(pmdii->dtOrig, &c_klDelay);
	}
	if (fLpdt) {
	    *lpdt = (WORD)ms;
	    return 0;
	} else {
	    return 1;
	}
    }
#endif
}

/*****************************************************************************
 *
 *  fXMouse
 *
 *	Determine whether XMouse is enabled.
 *
 *	Returns 0 if disabled, 1 if enabled, or -1 if not supported.
 *
 *      Note that there are *two* ways of getting this information,
 *      depending on which flavor of NT/Win9x we are running.  So
 *      try all of them until one of them works.
 *
 *****************************************************************************/

BOOL PASCAL
fXMouse(void)
{
    BOOL fX;
    if (SystemParametersInfo(SPI_GETUSERPREFERENCE,
			     SPI_UP_ACTIVEWINDOWTRACKING, &fX, 0)) {
        return fX != 0;
    } else if (SystemParametersInfo(SPI_GETACTIVEWINDOWTRACKING,
                                    0, &fX, 0)) {
        return fX != 0;
    } else {
	return -1;
    }
}

/*****************************************************************************
 *
 *  SetXMouse
 *
 *	Set the XMouse feature.
 *
 *****************************************************************************/

INLINE void
SetXMouse(BOOL f)
{
    if (SystemParametersInfo(SPI_SETUSERPREFERENCE,
                             SPI_UP_ACTIVEWINDOWTRACKING, IntToPtr(f),
                             SPIF_UPDATEINIFILE | SPIF_SENDCHANGE)) {
    } else {
        SystemParametersInfo(SPI_SETACTIVEWINDOWTRACKING,
                             0, IntToPtr(f), SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);
    }
}

/*****************************************************************************
 *
 *  msXMouseDelay
 *
 *      Returns the XMouse hover delay, or -1 if not supported.
 *
 *****************************************************************************/

int
msXMouseDelay(void)
{
    DWORD dw;
    if (SystemParametersInfo(SPI_GETACTIVEWNDTRKTIMEOUT, 0, &dw, 0)) {
        return (int)dw;
    }
    return -1;
}

/*****************************************************************************
 *
 *  SetXMouseDelay
 *
 *****************************************************************************/

INLINE void
SetXMouseDelay(int msDelay)
{
    SystemParametersInfo(SPI_SETACTIVEWNDTRKTIMEOUT, 0, IntToPtr(msDelay),
                         SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);
}

/*****************************************************************************
 *
 *  fXMouseRaise
 *
 *      Returns 0 if autoraise disabled, 1 if enabled, or -1 if not supported.
 *
 *****************************************************************************/

BOOL PASCAL
fXMouseRaise(void)
{
    BOOL f;
    if (SystemParametersInfo(SPI_GETACTIVEWNDTRKZORDER, 0, &f, 0)) {
        return f != 0;
    } else {
        return -1;
    }
}

/*****************************************************************************
 *
 *  SetXMouseRaise
 *
 *      Set the XMouse autoraise feature.
 *
 *****************************************************************************/

INLINE void
SetXMouseRaise(BOOL f)
{
    SystemParametersInfo(SPI_SETACTIVEWNDTRKZORDER, 0, IntToPtr(f),
                         SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);
}

/*****************************************************************************
 *
 *  cxDragCur
 *
 *	Return the current horizontal drag sensitivity.
 *
 *****************************************************************************/

INLINE int
cxDragCur(void)
{
    return GetSystemMetrics(SM_CXDRAG);
}

/*****************************************************************************
 *
 *  SetCxCyDrag
 *
 *	Set the new horizontal and vertical drag tolerances.
 *
 *****************************************************************************/

INLINE void
SetCxCyDrag(int cxDrag, int cyDrag)
{
    SystemParametersInfo(SPI_SETDRAGWIDTH, (UINT)cxDrag, 0L,
			 SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);
    SystemParametersInfo(SPI_SETDRAGHEIGHT, (UINT)cyDrag, 0L,
			 SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);
}

/*****************************************************************************
 *
 *  cxDblClkCur
 *
 *	Return the current horizontal double click sensitivity.
 *	Note that GetSystemMetrics records the total width, so we
 *	need to divide by two to get the half-wit half-width.
 *
 *****************************************************************************/

INLINE int
cxDblClkCur(void)
{
    return GetSystemMetrics(SM_CXDOUBLECLK) / 2;
}

/*****************************************************************************
 *
 *  SetCxCyDblClk
 *
 *	Set the current horizontal double click sensitivity.
 *	Note that GetSystemMetrics records the total width, so we
 *	need to multiply the half-width and half-height by two.
 *
 *****************************************************************************/

INLINE void
SetCxCyDblClk(int cxDblClk, int cyDblClk)
{
    SystemParametersInfo(SPI_SETDOUBLECLKWIDTH, (UINT)cxDblClk * 2, 0L,
			 SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);
    SystemParametersInfo(SPI_SETDOUBLECLKHEIGHT, (UINT)cyDblClk * 2, 0L,
			 SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);
}

/*****************************************************************************
 *
 *  Mouse_ReloadDlgInt
 *
 *	Reload values from an edit control.
 *
 *	hdlg is the dialog box itself.
 *
 *	idc is the edit control identifier.
 *
 *	ppt -> a POINT structure which will contain the current value
 *	       in the x, and an aspect-ratio-corrected value in the y.
 *
 *  We allow the value to exceed the range, in case you 
 *  really want it.
 *
 *
 *****************************************************************************/

void PASCAL
Mouse_ReloadDlgInt(HWND hdlg, UINT idc, PPOINT ppt)
{
    BOOL f;
    LRESULT lr;
    HWND hwnd;
    int x;

    hwnd = GetDlgItem(hdlg, idc+didcUd);
    if (hwnd) {
        lr = SendMessage(hwnd, UDM_GETRANGE, 0, 0L);
        x = (int)GetDlgItemInt(hdlg, idc+didcEdit, &f, 0);
        x = max((UINT)x, HIWORD(lr)); /* Force to lower limit of range */
        ppt->x = x;
        ppt->y = MulDiv(x, pmdii->cyAspect, pmdii->cxAspect);
    }
}

/*****************************************************************************
 *
 *  Mouse_InitDlgInt
 *
 *	Initialize a paired edit control / updown control.
 *
 *	hdlg is the dialog box itself.
 *
 *	idc is the edit control identifier.  It is assumed that idc+didcUd is
 *	the identifier for the updown control.
 *
 *	xMin and xMax are the limits of the control.
 *
 *	x = initial value
 *
 *	ppt -> a POINT structure which will contain the current value
 *	       in the x, and an aspect-ratio-corrected value in the y.
 *
 *
 *****************************************************************************/

void PASCAL
Mouse_InitDlgInt(HWND hdlg, UINT idc, int xMin, int xMax, int xVal, PPOINT ppt)
{
    SendDlgItemMessage(hdlg, idc+didcEdit, EM_LIMITTEXT, 2, 0L);
    SetDlgItemInt(hdlg, idc+didcEdit, xVal, 0);

    SendDlgItemMessage(hdlg, idc+didcUd,
		       UDM_SETRANGE, 0, MAKELPARAM(xMax, xMin));

    Mouse_ReloadDlgInt(hdlg, idc, ppt);
}

/*****************************************************************************
 *
 *  The trackbar
 *
 *	The trackbar slider is piecewise linear.  It really should be
 *	exponential, but it's hard to write exp() and log() for integers.
 *
 *	Given two parallel arrays which describe the domain and range,
 *	with
 *
 *	x[N] <= x <= x[N+1]	mapping to	y[N] <= y <= y[N+1],
 *
 *	then
 *
 *	x[N] <= x <= x[N+1] maps to
 *
 *		y = y[N] + (x - x[N]) * (y[N+1] - y[N]) / (x[N+1] - x[N]).
 *
 *****************************************************************************/

/* tbt = trackbar tick */
#define tbtMax 120
#define tbtFreq 15
#define dtMax 65534		    /* Don't use 65535; that's uiErr */

const static UINT CODESEG rgtbt[] =
	{ 0, tbtMax/2, tbtMax*3/4, tbtMax*7/8, tbtMax };
const static UINT CODESEG rgdt[] =
	{ 0,      500,       2000,       5000,  dtMax };

/*****************************************************************************
 *
 *  Mouse_Interpolate
 *
 *	Perform piecewise linear interpolation.  See the formulas above.
 *
 *****************************************************************************/

UINT PASCAL
Mouse_Interpolate(UINT x, const UINT CODESEG *px, const UINT CODESEG *py)
{
    while (x > px[1]) px++, py++;
    return py[0] + MulDiv(x - px[0], py[1] - py[0], px[1] - px[0]);
}

/*****************************************************************************
 *
 *  Mouse_GetDt
 *
 *	Get the setting that the user has selected.
 *
 *	hdlg = dialog handle
 *
 *	dtMax maps to dtInfinite.
 *
 *****************************************************************************/

DT PASCAL
Mouse_GetDt(HWND hdlg)
{
    return (DT)Mouse_Interpolate(
		(UINT)SendDlgItemMessage(hdlg, IDC_SPEEDTRACK,
				         TBM_GETPOS, 0, 0L), rgtbt, rgdt);
}

/*****************************************************************************
 *
 *  Mouse_SetDt
 *
 *	Set the setting into the trackbar.
 *
 *	hdlg = dialog handle
 *
 *****************************************************************************/

void PASCAL
Mouse_SetDt(HWND hdlg, DT dt)
{
    SendDlgItemMessage(hdlg, IDC_SPEEDTRACK, TBM_SETPOS, 1,
		       Mouse_Interpolate(dt, rgdt, rgtbt));
}

/*****************************************************************************
 *
 *  Mouse_SetDirty
 *
 *	Make a control dirty.
 *
 *****************************************************************************/

void NEAR PASCAL
Mouse_SetDirty(HWND hdlg)
{
    pmdii->fFactory = 0;
    PropSheet_Changed(GetParent(hdlg), hdlg);
}

/*****************************************************************************
 *
 *  Mouse_UpdateWheel
 *
 *	Update all the wheel control controls.
 *
 *	If "Use wheel" is unchecked, then disable all the insides.
 *
 *****************************************************************************/

void PASCAL
Mouse_UpdateWheel(HWND hdlg)
{
    HWND hwnd = GetDlgItem(hdlg, IDC_WHEELENABLE);
    if (hwnd) {
	BOOL f = IsWindowEnabled(hwnd) &&
		 IsDlgButtonChecked(hdlg, IDC_WHEELENABLE);
        AdjustDlgItems(hdlg, IDC_WHEELPAGE, IDC_WHEELLAST, f ? ADI_ENABLE : ADI_DISABLE);
    }
}

/*****************************************************************************
 *
 *  Mouse_Reset
 *
 *	Reset all controls to initial values.  This also marks
 *	the control as clean.
 *
 *****************************************************************************/

BOOL PASCAL
Mouse_Reset(HWND hdlg)
{
    HWND hwnd = GetDlgItem(hdlg, IDC_SPEEDTRACK);
    BOOL f;
    SendMessage(hwnd, TBM_SETRANGE, 0, MAKELPARAM(0, tbtMax));
    SendMessage(hwnd, TBM_SETTICFREQ, tbtFreq, 0L);

    if (fLpdt) {
	pmdii->dtOrig = msDt();		/* Save for revert */
	if (pmdii->dtOrig > dtMax) {	/* Max out here */
	    pmdii->dtOrig = dtMax;
	}
    } else {
	/* just use what seems to be the current setting */
	pmdii->dtOrig = dtCur();
    }
    Mouse_SetDt(hdlg, pmdii->dtOrig);

    f = fXMouse();
    if (f >= 0) {
        CheckDlgButton(hdlg, IDC_XMOUSE, f);
        f = fXMouseRaise();
        if (f >= 0) {
            CheckDlgButton(hdlg, IDC_XMOUSERAISE, f);
        }

        int ms = msXMouseDelay();
        if (ms >= 0) {
            SetDlgItemInt(hdlg, IDC_XMOUSEDELAY, ms, FALSE);
        }
    }

    Mouse_UpdateWheel(hdlg);

    Mouse_InitDlgInt(hdlg, IDC_DBLCLK, 1, 32, cxDblClkCur(), &pmdii->ptDblClk);
    Mouse_InitDlgInt(hdlg, IDC_DRAG, 1, 32, cxDragCur(), &pmdii->ptDrag);

    return 1;
}

/*****************************************************************************
 *
 *  Mouse_Apply
 *
 *	Write the changes to the registry and into USER's DS.
 *
 *****************************************************************************/

BOOL NEAR PASCAL
Mouse_Apply(HWND hdlg)
{
    BOOL f;
    BOOL fNow;
    DWORD dwNow;
    DT dt;

    dt = Mouse_GetDt(hdlg);
    if (dt != pmdii->dtOrig) {
	pmdii->dtOrig = dt;
	if (pmdii->fFactory) {
	    /* DelPkl(&c_klDelay); */
	    dt = dtDefault();
	}
	if (SetDt(pmdii->dtOrig, SPIF_UPDATEINIFILE)) {
	    Common_NeedLogoff(hdlg);
	}
        SendNotifyMessage(HWND_BROADCAST, WM_SETTINGCHANGE, 0,
                          (LPARAM)(LPCTSTR)c_tszWindows);
    }

    if (cxDragCur() != pmdii->ptDrag.x) {
        /* This will send WM_WININICHANGE as necessary */
	SetCxCyDrag(pmdii->ptDrag.x, pmdii->ptDrag.y);
    }

    if (cxDblClkCur() != pmdii->ptDblClk.x) {
        /* This will send WM_WININICHANGE as necessary */
	SetCxCyDblClk(pmdii->ptDblClk.x, pmdii->ptDblClk.y);
    }

    fNow = fXMouse();
    if (fNow >= 0) {
	f = IsDlgButtonChecked(hdlg, IDC_XMOUSE);
	if (fNow != f) {
            /* This will send WM_WININICHANGE as necessary */
	    SetXMouse(f);
	}

        fNow = fXMouseRaise();
        f = IsDlgButtonChecked(hdlg, IDC_XMOUSERAISE);
        if (fNow != f) {
            SetXMouseRaise(f);
        }

        int msDelay = (int)GetDlgItemInt(hdlg, IDC_XMOUSEDELAY, &f, FALSE);
        int msDelayNow = msXMouseDelay();
        if (msDelay != msDelayNow) {
            SetXMouseDelay(msDelay);
        }
    }

    if (SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &dwNow, 0)) {
	if (IsWindowEnabled(GetDlgItem(hdlg, IDC_WHEELENABLE))) {
	    DWORD dw;

	    if (!IsDlgButtonChecked(hdlg, IDC_WHEELENABLE)) {
		dw = 0;
	    } else if (IsDlgButtonChecked(hdlg, IDC_WHEELPAGE)) {
		dw = WHEEL_PAGESCROLL;
	    } else {
		dw = GetDlgItemInt(hdlg, IDC_WHEELLINENO, &f, 0);
	    }

	    if (dw != dwNow) {
                SystemParametersInfo(SPI_SETWHEELSCROLLLINES, dw, 0,
                                     SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);
	    }
	}
    }

    return Mouse_Reset(hdlg);
}

/*****************************************************************************
 *
 *  Mouse_ReloadUpdowns
 *
 *	Reload the values from the updown controls and update our
 *	internals accordingly.
 *
 *****************************************************************************/

BOOL PASCAL
Mouse_ReloadUpdowns(HWND hdlg)
{
    Mouse_ReloadDlgInt(hdlg, IDC_DBLCLK, &pmdii->ptDblClk);
    Mouse_ReloadDlgInt(hdlg, IDC_DRAG, &pmdii->ptDrag);
    Mouse_SetDirty(hdlg);
    return 1;
}

/*****************************************************************************
 *
 *  Mouse_FactoryReset
 *
 *	Restore to original factory settings.
 *
 *	Droptime = DoubleClickTime * 4 / 5.
 *	Animation = !((GetSystemMetrics(SM_SLOWMACHINE) & 0x0004) &&
 *		      (GetSystemMetrics(SM_SLOWMACHINE) & 0x0001))
 *	cxDrag = 2
 *	cxDblClk = 2
 *
 *****************************************************************************/

BOOL PASCAL
Mouse_FactoryReset(HWND hdlg)
{
    Mouse_SetDirty(hdlg);

    Mouse_SetDt(hdlg, dtDefault());

    if (fXMouse() >= 0) {
	CheckDlgButton(hdlg, IDC_XMOUSE, 0);
    }

    SetDlgItemInt(hdlg, IDC_DRAG, 2, 0);
    SetDlgItemInt(hdlg, IDC_DBLCLK, 2, 0);

    Mouse_ReloadUpdowns(hdlg);

    if (GetDlgItem(hdlg, IDC_WHEELENABLE)) {
	CheckDlgButton(hdlg, IDC_WHEELENABLE, TRUE);
	CheckRadioButton(hdlg, IDC_WHEELPAGE, IDC_WHEELLINE, IDC_WHEELLINE);
	SetDlgItemInt(hdlg, IDC_WHEELLINENO, 3, 0);
    }

    pmdii->fFactory = 1;
    return 1;
}

/*****************************************************************************
 *
 *  Mouse_OnTips
 *
 *****************************************************************************/

void PASCAL
Mouse_OnTips(HWND hdlg)
{
    WinHelp(hdlg, c_tszMyHelp, HELP_FINDER, 0);
}

#ifdef IDC_BUGREPORT
/*****************************************************************************
 *
 *  Mouse_OnBugReport
 *
 *****************************************************************************/

void PASCAL
Mouse_OnBugReport(HWND hdlg)
{
    ShellExecute(hdlg, "open", "http://abject/tweakui/", "", "",
                 SW_NORMAL);
}
#endif

/*****************************************************************************
 *
 *  Mouse_OnCommand
 *
 *	Ooh, we got a command.
 *
 *****************************************************************************/

BOOL PASCAL
Mouse_OnCommand(HWND hdlg, int id, UINT codeNotify)
{
    switch (id) {
    case IDC_RESET:	/* Reset to factory default */
	if (codeNotify == BN_CLICKED) return Mouse_FactoryReset(hdlg);
	break;

    case IDC_TIPS:	/* Call up help */
	if (codeNotify == BN_CLICKED) Mouse_OnTips(hdlg);
	break;

#ifdef IDC_BUGREPORT
    case IDC_BUGREPORT:
        if (codeNotify == BN_CLICKED) Mouse_OnBugReport(hdlg);
        break;
#endif

    case IDC_XMOUSE:
    case IDC_XMOUSERAISE:
    case IDC_WHEELPAGE:
    case IDC_WHEELLINE:
	if (codeNotify == BN_CLICKED) Mouse_SetDirty(hdlg);
	break;

    case IDC_DRAG:
    case IDC_DBLCLK:
    case IDC_WHEELLINENO:
    case IDC_XMOUSEDELAY:
	if (codeNotify == EN_CHANGE) {
	    Mouse_ReloadUpdowns(hdlg);
	    Mouse_SetDirty(hdlg);
	}
	break;

    case IDC_WHEELENABLE:
	if (codeNotify == BN_CLICKED) {
	    Mouse_UpdateWheel(hdlg);
	    Mouse_SetDirty(hdlg);
	}
	break;

    }

    return 0;
}

/*****************************************************************************
 *
 *  Mouse_SetTestIcon
 *
 *	Set a new test icon, returning the previous one.
 *
 *****************************************************************************/

HCURSOR PASCAL
Mouse_SetTestIcon(HWND hdlg, UINT idi)
{
    return (HCURSOR)
	SendDlgItemMessage(hdlg, IDC_TEST, STM_SETICON,
			(WPARAM)LoadIconId(idi), 0L);
}

/*****************************************************************************
 *
 *  Mouse_StopDrag
 *
 *	Stop any drag operation in progress.
 *
 *	We must release the capture unconditionally, or a double-click
 *	will result in the mouse capture being stuck!
 *
 *****************************************************************************/

void PASCAL
Mouse_StopDrag(HWND hdlg)
{
    ReleaseCapture();	/* Always do this! */
    if (pmdii->hcurDrag) {
	SetCursor(0);	/* We're about to destroy the current cursor */
	DestroyCursor(pmdii->hcurDrag);
	pmdii->hcurDrag = 0;
	DestroyCursor(Mouse_SetTestIcon(hdlg, pmdii->idi));
    }
    pmdii->fDrag = 0;	/* not dragging */
}

/*****************************************************************************
 *
 *  Mouse_OnNotify
 *
 *	Ooh, we got a notification.
 *
 *****************************************************************************/

BOOL PASCAL
Mouse_OnNotify(HWND hdlg, NMHDR FAR *pnm)
{
    switch (pnm->code) {
    case PSN_APPLY:
	Mouse_Apply(hdlg);
	break;

    /*
     * If we are dragging, then ESC cancels the drag, not the prsht.
     * Note that we must set the message result *last*, because
     * ReleaseCapture will recursively call the dialog procedure,
     * smashing whatever used to be in the message result.
     */
    case PSN_QUERYCANCEL:
	if (pmdii->fDrag) {
	    Mouse_StopDrag(hdlg);
	    SetDlgMsgResult(hdlg, WM_NOTIFY, 1);
	}
	return 1;
    }
    return 0;
}

/*****************************************************************************
 *
 *  Mouse_OnInitDialog
 *
 *	Initialize the controls.
 *
 *****************************************************************************/

BOOL NEAR PASCAL
Mouse_OnInitDialog(HWND hdlg)
{
    UINT idc;
    DWORD dw;

    pmdii->idi = IDI_GEAR1;	/* Start with the first gear */

    pmdii->fDrag = 0;		/* not dragging */

    /* Make sure first click isn't counted as a double */
    pmdii->tmClick = 0;

    pmdii->fFactory = 0;
    pmdii->hcurDrag = 0;

    GetDlgItemRect(hdlg, IDC_TEST, &pmdii->rcTest);

    {
	HDC hdc = GetDC(0);
	if (hdc) {
	    pmdii->cxAspect = GetDeviceCaps(hdc, ASPECTX);
	    pmdii->cyAspect = GetDeviceCaps(hdc, ASPECTY);
	    ReleaseDC(0, hdc);
	    if (pmdii->cxAspect == 0) {	/* Buggy display driver */
		goto Fallback;
	    }
	} else {		/* Assume 1:1 aspect ratio */
	    Fallback:
	    pmdii->cxAspect = pmdii->cyAspect = 1;
	}
    }

    SendDlgItemMessage(hdlg, IDC_WHEELLINENO, EM_LIMITTEXT, 3, 0L);
    SetDlgItemInt(hdlg, IDC_WHEELLINENO, 3, 0);
    SendDlgItemMessage(hdlg, IDC_WHEELLINEUD,
		       UDM_SETRANGE, 0, MAKELPARAM(999, 1));
    if (SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &dw, 0)) {
	if (GetSystemMetrics(SM_MOUSEWHEELPRESENT)) {
	    CheckDlgButton(hdlg, IDC_WHEELENABLE, dw != 0);
	    if (dw == WHEEL_PAGESCROLL) {
		CheckDlgButton(hdlg, IDC_WHEELPAGE, TRUE);
	    } else {
		CheckDlgButton(hdlg, IDC_WHEELLINE, TRUE);
		if (dw) {
		    SetDlgItemInt(hdlg, IDC_WHEELLINENO, dw, 0);
		}
	    }
	} else {
            EnableDlgItem(hdlg, IDC_WHEELENABLE, 0);
	}
    } else {
        DestroyDlgItems(hdlg, IDC_WHEELFIRST, IDC_WHEELLAST);
    }

    if (fXMouse() < 0) {
        DestroyDlgItems(hdlg, IDC_XMOUSEFIRST, IDC_XMOUSELAST);
    } else {

        if (fXMouseRaise() < 0) {
            EnableDlgItem(hdlg, IDC_XMOUSERAISE, FALSE);
        }

        if (msXMouseDelay() < 0) {
            EnableDlgItem(hdlg, IDC_XMOUSEDELAY, FALSE);
            EnableDlgItem(hdlg, IDC_XMOUSEDELAYTXT, FALSE);
        }
    }

    if (fGrovel()) {
	Mouse_Reset(hdlg);
	return 1;		/* Allow focus to travel normally */
    } else {
	lpdt = &dtScratch;
	*lpdt = dtCur();	/* Gotta give it something */
	Mouse_Reset(hdlg);
	ShowWindow(GetDlgItem(hdlg, IDC_SPEEDHELP), SW_HIDE);
	return 0;
    }
}

/*****************************************************************************
 *
 *  Mouse_OnLButtonDown
 *
 *	If the left button went down in the test area, begin capturing.
 *	Also record the time the button went down, so we can do double-click
 *	fuzz testing.
 *
 *****************************************************************************/

BOOL PASCAL
Mouse_OnLButtonDown(HWND hdlg, int x, int y)
{
    POINT pt = { x, y };
    LONG tm = GetMessageTime();

    if (PtInRect(&pmdii->rcTest, pt)) {
	/*
	 *  Is this a double-click?
	 */
	if (pmdii->tmClick &&
	    (DWORD)(tm - pmdii->tmClick) < GetDoubleClickTime() &&
	    PtInRect(&pmdii->rcDblClk, pt)) {
	    pmdii->idi ^= IDI_GEAR1 ^ IDI_GEAR2;
	    DestroyCursor(Mouse_SetTestIcon(hdlg, pmdii->idi));
	    tm = 0;
	}

	SetRectPoint(&pmdii->rcDrag, pt);
	SetRectPoint(&pmdii->rcDblClk, pt);
	InflateRect(&pmdii->rcDrag, pmdii->ptDrag.x, pmdii->ptDrag.y);
	InflateRect(&pmdii->rcDblClk, pmdii->ptDblClk.x, pmdii->ptDblClk.y);

	pmdii->fDrag = 1;	/* Drag in progress */
	SetCapture(hdlg);
    }
    pmdii->tmClick = tm;
    return 1;
}

/*****************************************************************************
 *
 *  Mouse_OnMouseMove
 *
 *	If we are captured, see if we've moved far enough to act as
 *	if a drag is in progress.
 *
 *****************************************************************************/

BOOL PASCAL
Mouse_OnMouseMove(HWND hdlg, int x, int y)
{
    if (pmdii->fDrag && !pmdii->hcurDrag) {
	POINT pt = { x, y };
	if (!PtInRect(&pmdii->rcDrag, pt)) {
	    pmdii->hcurDrag = Mouse_SetTestIcon(hdlg, IDI_BLANK);

            /*
             *  Tweak the cursor position so it looks like the icon
             *  dragged from the original click point.
             */
            ICONINFO ii;
            if (GetIconInfo(pmdii->hcurDrag, &ii)) {
                DeleteObject(ii.hbmMask);
                DeleteObject(ii.hbmColor);

                /*
                 *  These formulas are heinous.
                 *
                 *  xClick = client coordinates of original click
                 *         = pmdii->rcDrag.left + pmdii->ptDrag.x
                 *
                 *  xTest  = client coordinates of start of clickable icon
                 *         = pmdii->rcTest.left
                 *
                 *  xOffset = location of click relative to icon corner
                 *          = xClick - xTest
                 *
                 *  xAdjust = amount the user's click location differs
                 *            from the actual hotspot
                 *          = ii.xHotspot - xOffset
                 *          = ii.xHotspot - xClick + xTest
                 */
                pt.x += + ii.xHotspot
                        - (pmdii->rcDrag.left + pmdii->ptDrag.x)
                        + pmdii->rcTest.left;
                pt.y += + ii.yHotspot
                        - (pmdii->rcDrag.top + pmdii->ptDrag.y)
                        + pmdii->rcTest.top;
                ClientToScreen(hdlg, &pt);
                SetCursorPos(pt.x, pt.y);
            }

	    SetCursor(pmdii->hcurDrag);
	}
    }
    return 0;
}

/*****************************************************************************
 *
 *  Mouse_OnRButtonUp
 *
 *	If the button went up in the menu test area, track a menu.
 *
 *****************************************************************************/

BOOL PASCAL
Mouse_OnRButtonUp(HWND hdlg, int x, int y)
{
    POINT pt = { x, y };
    if (PtInRect(&pmdii->rcTest, pt) && fLpdt) {
	DT dt;
	int id;

	dt = msDt();			/* Save for revert */
	SetDt(Mouse_GetDt(hdlg), 0);

	ClientToScreen(hdlg, &pt);	/* Make it screen coordinates */
	id = TrackPopupMenuEx(GetSubMenu(pcdii->hmenu, 0),
			      TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_VERTICAL |
			      TPM_LEFTALIGN | TPM_TOPALIGN, pt.x, pt.y,
			      hdlg, 0);

	SetDt(dt, 0);
	return 1;
    } else {
        return 0;			/* Do the default thing */
    }
}

/*****************************************************************************
 *
 *  Our window procedure.
 *
 *****************************************************************************/

/*
 * The HANDLE_WM_* macros weren't designed to be used from a dialog
 * proc, so we need to handle the messages manually.  (But carefully.)
 */

INT_PTR EXPORT
Mouse_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    switch (wm) {
    case WM_INITDIALOG: return Mouse_OnInitDialog(hdlg);

    /* We have only one trackbar, so we don't need to check */
    case WM_HSCROLL: Mouse_SetDirty(hdlg); return 1;

    /* We have two updowns, but reloading is cheap, so we just reload both */
    case WM_VSCROLL:
	if (GET_WM_VSCROLL_CODE(wParam, lParam) == SB_THUMBPOSITION) {
	    return Mouse_ReloadUpdowns(hdlg);
	}
	break;

    case WM_COMMAND:
	return Mouse_OnCommand(hdlg,
			       (int)GET_WM_COMMAND_ID(wParam, lParam),
			       (UINT)GET_WM_COMMAND_CMD(wParam, lParam));
    case WM_NOTIFY:
	return Mouse_OnNotify(hdlg, (NMHDR FAR *)lParam);

    case WM_LBUTTONDOWN:
    case WM_LBUTTONDBLCLK:
	return Mouse_OnLButtonDown(hdlg, LOWORD(lParam), HIWORD(lParam));

    case WM_ACTIVATE:
	if (GET_WM_ACTIVATE_STATE(wParam, lParam) == WA_INACTIVE) {
	    Mouse_StopDrag(hdlg);
	}
	break;

    case WM_LBUTTONUP:
	Mouse_StopDrag(hdlg);
	break;

    case WM_RBUTTONUP:
	return Mouse_OnRButtonUp(hdlg, LOWORD(lParam), HIWORD(lParam));

    case WM_HELP: Common_OnHelp(lParam, &rgdwHelp[0]); break;

    case WM_CONTEXTMENU: Common_OnContextMenu(wParam, &rgdwHelp[0]); break;

    case WM_MOUSEMOVE:
	return Mouse_OnMouseMove(hdlg, LOWORD(lParam), HIWORD(lParam));

    default: return 0;	/* Unhandled */
    }
    return 1;		/* Handled */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tweakui\network.cpp ===
/*
 * network - Dialog box property sheet for "network goo"
 */

#include "tweakui.h"

#pragma BEGIN_CONST_DATA

#define c_tszShutdownWithoutLogon TEXT("ShutdownWithoutLogon")

KL const c_klAutoLogon = { &g_hkLMSMWNTCV, c_tszWinlogon, c_tszAutoLogon };
KL const c_klDefUser = { &g_hkLMSMWNTCV, c_tszWinlogon, c_tszDefaultUserName };
KL const c_klDefPass = { &g_hkLMSMWNTCV, c_tszWinlogon, c_tszDefaultPassword };
KL const c_klShutdown = { &g_hkLMSMWNTCV, c_tszWinlogon, c_tszShutdownWithoutLogon };
KL const c_klRunServ = { &g_hkLMSMWCV, c_tszRunServices, g_tszName };

const static DWORD CODESEG rgdwHelp[] = {
        IDC_LOGONAUTO,      IDH_AUTOLOGON,
        IDC_LOGONUSERTXT,   IDH_AUTOLOGONUSER,
        IDC_LOGONUSER,      IDH_AUTOLOGONUSER,
        IDC_LOGONPASSTXT,   IDH_AUTOLOGONPASS,
        IDC_LOGONPASS,      IDH_AUTOLOGONPASS,
        IDC_LOGONSHUTDOWN,  IDH_LOGONSHUTDOWN,
        0,                  0,
};

/*
 * Instanced.  We're a cpl so have only one instance, but I declare
 * all the instance stuff in one place so it's easy to convert this
 * code to multiple-instance if ever we need to.
 *
 * Note: All our instance data is kept in the dialog itself; don't need this
 */
#if 0
typedef struct NDII {           /* network dialog instance info */
} NDII, *PNDII;

NDII ndii;
#define pndii (&ndii)
#endif

/* #define TAMMEB_PERF */
#ifdef TAMMEB_PERF

/*****************************************************************************
 *
 *  Network_LogQPC
 *
 *      Log the current time in "shell perf time", which is basically
 *      milliseconds, but using QPC instead of GetTickCount().
 *
 *****************************************************************************/

void
Network_LogQPC(LPCTSTR pszName)
{
    /* For perf testing, log the QPC time when we hit OK. */
    {
        TCHAR tszTemp[40];
        LARGE_INTEGER cur, freq;
        QueryPerformanceFrequency(&freq);
        QueryPerformanceCounter(&cur);
        wsprintf(tszTemp, TEXT("%d"), (DWORD)((cur.QuadPart * 1000) / freq.QuadPart));
        WritePrivateProfileString(TEXT("NetworkLogon"), pszName, tszTemp, TEXT("C:\\TWEAKUI.LOG"));
    }
}
#endif

/*****************************************************************************
 *
 *  Network_SetDirty
 *
 *      Make a control dirty.
 *
 *****************************************************************************/

#define Network_SetDirty    Common_SetDirty

/*****************************************************************************
 *
 *  Network_PklToDlgItemText
 *
 *      Read dialog item text from the registry.
 *
 *****************************************************************************/

#define ctchDlgItem 256

void PASCAL
Network_PklToDlgItemText(HWND hdlg, UINT idc, PKL pkl)
{
    TCHAR tsz[ctchDlgItem];

    GetStrPkl(tsz, cbX(tsz), pkl);
    SetDlgItemTextLimit(hdlg, idc, tsz, cA(tsz));
}

/*****************************************************************************
 *
 *  Network_DlgItemTextToPkl
 *
 *      Copy dialog item text to the registry.
 *
 *****************************************************************************/

void PASCAL
Network_DlgItemTextToPkl(HWND hdlg, UINT idc, PKL pkl)
{
    TCHAR tsz[ctchDlgItem];

    GetDlgItemText(hdlg, idc, tsz, cA(tsz));
    if (tsz[0]) {
        SetStrPkl(pkl, tsz);
    } else {
        DelPkl(pkl);
    }
}

/*****************************************************************************
 *
 *  Network_Reset
 *
 *      Reset all controls to initial values.  This also marks
 *      the control as clean.
 *
 *****************************************************************************/

BOOL PASCAL
Network_Reset(HWND hdlg)
{
    CheckDlgButton(hdlg, IDC_LOGONAUTO, GetIntPkl(0, &c_klAutoLogon));

    Network_PklToDlgItemText(hdlg, IDC_LOGONUSER, &c_klDefUser);

    if (g_fNT5) {
        WCHAR ubuf[ctchDlgItem];
        ubuf[0] = TEXT('\0');
        GetSecretDefaultPassword(ubuf, ctchDlgItem);
        SetDlgItemTextW(hdlg, IDC_LOGONPASS, ubuf);
        SendDlgItemMessageW(hdlg, IDC_LOGONPASS, EM_LIMITTEXT, cA(ubuf) - 1, 0);
        CheckDlgButton(hdlg, IDC_LOGONSHUTDOWN, GetIntPkl(0, &c_klShutdown));
    } else {
        Network_PklToDlgItemText(hdlg, IDC_LOGONPASS, &c_klDefPass);
        DestroyWindow(GetDlgItem(hdlg, IDC_LOGONSHUTDOWN));
    }

    Common_SetClean(hdlg);

    return 1;
}



/*****************************************************************************
 *
 *  Network_Apply
 *
 *      Write the changes to the registry.
 *
 *****************************************************************************/

BOOL NEAR PASCAL
Network_Apply(HWND hdlg)
{
    BOOL fAuto;

    Network_DlgItemTextToPkl(hdlg, IDC_LOGONUSER, &c_klDefUser);

    if (g_fNT5) {
        WCHAR ubuf[ctchDlgItem];
        GetDlgItemTextW(hdlg, IDC_LOGONPASS, ubuf, cA(ubuf));
        SetSecretDefaultPassword(ubuf);
        DelPkl(&c_klDefPass);           /* And delete the unsafe one */
        SetIntPkl(IsDlgButtonChecked(hdlg, IDC_LOGONSHUTDOWN), &c_klShutdown);
    } else {
        Network_DlgItemTextToPkl(hdlg, IDC_LOGONPASS, &c_klDefPass);
    }

    fAuto = IsDlgButtonChecked(hdlg, IDC_LOGONAUTO);
    if (fAuto) {
        SetIntPkl(fAuto, &c_klAutoLogon);
    } else {
        DelPkl(&c_klAutoLogon);
    }

    /*
     *  NT does this automatically, so we need to be hacky only on Win95a.
     */
    if (!g_fNT) {
        if (fAuto) {
            SetStrPkl(&c_klRunServ, c_tszFixAutoLogon);
        } else {
            DelPkl(&c_klRunServ);
        }
    }

    return Network_Reset(hdlg);
}

/*****************************************************************************
 *
 *  Network_FactoryReset
 *
 *      Autologon = false
 *      AutoUser = none
 *      AutoPass = none
 *
 *****************************************************************************/

BOOL PASCAL
Network_FactoryReset(HWND hdlg)
{
    Network_SetDirty(hdlg);

    CheckDlgButton(hdlg, IDC_LOGONAUTO, FALSE);
    SetDlgItemText(hdlg, IDC_LOGONUSER, c_tszNil);
    SetDlgItemText(hdlg, IDC_LOGONPASS, c_tszNil);
    return 1;
}

/*****************************************************************************
 *
 *  Network_OnCommand
 *
 *      Ooh, we got a command.
 *
 *****************************************************************************/

BOOL PASCAL
Network_OnCommand(HWND hdlg, int id, UINT codeNotify)
{
    switch (id) {
    case IDC_RESET:     /* Reset to factory default */
        if (codeNotify == BN_CLICKED) return Network_FactoryReset(hdlg);
        break;

    case IDC_LOGONAUTO:
    case IDC_LOGONSHUTDOWN:
        if (codeNotify == BN_CLICKED) Network_SetDirty(hdlg);
        break;

    case IDC_LOGONUSER:
    case IDC_LOGONPASS:
        if (codeNotify == EN_CHANGE) Network_SetDirty(hdlg);
        break;

    }
    return 0;
}

/*****************************************************************************
 *
 *  Network_OnNotify
 *
 *      Ooh, we got a notification.
 *
 *****************************************************************************/

BOOL PASCAL
Network_OnNotify(HWND hdlg, NMHDR FAR *pnm)
{
    switch (pnm->code) {
    case PSN_APPLY:
        Network_Apply(hdlg);
        break;

    }
    return 0;
}

/*****************************************************************************
 *
 *  Network_OnInitDialog
 *
 *      Initialize the controls.
 *
 *****************************************************************************/

BOOL INLINE
Network_OnInitDialog(HWND hdlg)
{
    if (g_fNT5) {
        DestroyWindow(GetDlgItem(hdlg, IDC_LOGONPASSUNSAFE));
    }
    return Network_Reset(hdlg);
}

/*****************************************************************************
 *
 *  Our window procedure.
 *
 *****************************************************************************/

/*
 * The HANDLE_WM_* macros weren't designed to be used from a dialog
 * proc, so we need to handle the messages manually.  (But carefully.)
 */

INT_PTR EXPORT
Network_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    switch (wm) {
    case WM_INITDIALOG: return Network_OnInitDialog(hdlg);

    case WM_COMMAND:
        return Network_OnCommand(hdlg,
                               (int)GET_WM_COMMAND_ID(wParam, lParam),
                               (UINT)GET_WM_COMMAND_CMD(wParam, lParam));
    case WM_NOTIFY:
        return Network_OnNotify(hdlg, (NMHDR FAR *)lParam);

    case WM_HELP: Common_OnHelp(lParam, &rgdwHelp[0]); break;

    case WM_CONTEXTMENU: Common_OnContextMenu(wParam, &rgdwHelp[0]); break;

    default: return 0;  /* Unhandled */
    }
    return 1;           /* Handled */
}

/*****************************************************************************
 *
 *  GetClassAtom
 *
 *****************************************************************************/

WORD PASCAL
GetClassAtom(HWND hwnd)
{
    return GetClassWord(hwnd, GCW_ATOM);
}

/*****************************************************************************
 *
 *  Network_FindVictim
 *
 *  Look arund to see if there is a window that meets the following
 *  criteria:
 *
 *      1. Is a dialog box.
 *      2. Contains two edit controls, one of which is password-protected.
 *
 *  If so, then the hwnd list is filled in with the two edit controls.
 *
 *****************************************************************************/

typedef struct AUTOLOGON {
    TCHAR tszUser[ctchDlgItem];
    TCHAR tszPass[ctchDlgItem];
} AUTOLOGON, *PAUTOLOGON;


#define GetWindowClass(hwnd)    GetClassWord(hwnd, GCW_ATOM)

HWND PASCAL
Network_FindVictim(HWND hwndEdit, HWND rghwnd[])
{
    WORD atmEdit = GetClassAtom(hwndEdit);
    HWND hdlg;

    for (hdlg = GetWindow(GetDesktopWindow(), GW_CHILD); hdlg;
         hdlg = GetWindow(hdlg, GW_HWNDNEXT)) {

        /*
         *  If we have a dialog box, study it.
         */
        if (GetClassAtom(hdlg) == 0x8002) {
            HWND hwnd, hwndUser = 0;
            for (hwnd = GetWindow(hdlg, GW_CHILD); hwnd;
                 hwnd = GetWindow(hwnd, GW_HWNDNEXT)) {

                /*
                 *  We care only about visible non-read-only edit controls.
                 */
                if (GetClassAtom(hwnd) == atmEdit) {
                    LONG ws = GetWindowLong(hwnd, GWL_STYLE);
                    if (!(ws & ES_READONLY) && (ws & WS_VISIBLE)) {
                        /*
                         *  If we haven't found a "user name",
                         *  then the first edit we find had better
                         *  not be password-protected.  If it is,
                         *  then we punt, because we're confused.
                         *
                         *  If we have found a "user name", then the
                         *  next edit we find had better be
                         *  password-protected.
                         */
                        if (hwndUser == 0) {
                            if (ws & ES_PASSWORD) goto nextdialog;
                            hwndUser = hwnd;
                        } else {
                            if (!(ws & ES_PASSWORD)) goto nextdialog;
                            rghwnd[0] = hwndUser;
                            rghwnd[1] = hwnd;
                            return hdlg;
                        }
                    }
                }
            }
        }
    nextdialog:;
    }
    return 0;
}

/*****************************************************************************
 *
 *  Network_ForceString
 *
 *  Force a string into an edit control.  We cannot use SetWindowText
 *  because that doesn't work inter-thread.
 *
 *****************************************************************************/

void PASCAL
Network_ForceString(HWND hwnd, LPCTSTR ptsz)
{
    Edit_SetSel(hwnd, 0, -1);
    FORWARD_WM_CLEAR(hwnd, SendMessage);

    for (; *ptsz && IsWindow(hwnd); ptsz++) {
        SendMessage(hwnd, WM_CHAR, *ptsz, 0L);
    }
}

/*****************************************************************************
 *
 *  Network_Snoop
 *
 *  Look to see if we have a winner.  The shift key suppresses autologon.
 *
 *****************************************************************************/

void PASCAL
Network_Snoop(HWND hwnd)
{
    HWND rghwnd[2];
    HWND hdlg;

    hdlg = Network_FindVictim(hwnd, rghwnd);
    if (hdlg && GetAsyncKeyState(VK_SHIFT) >= 0) {
        PAUTOLOGON pal = (PAUTOLOGON)GetWindowLongPtr(hwnd, GWLP_USERDATA);
        if (pal) {
            Network_ForceString(rghwnd[0], pal->tszUser);
            Network_ForceString(rghwnd[1], pal->tszPass);
            FORWARD_WM_COMMAND(hdlg, IDOK, GetDlgItem(hdlg, IDOK),
                               BN_CLICKED, PostMessage);
            PostMessage(hwnd, WM_CLOSE, 0, 0L);
#ifdef TAMMEB_PERF
            Network_LogQPC(TEXT("SuccessQPC"));
#endif
        }
    }
}

/*****************************************************************************
 *
 *  Network_WndProc
 *
 *  Window procedure for our "Keep an eye on the logon process".
 *
 *  When the timer fires, we nuke ourselves, under the assumption that the
 *  network dialog box ain't a-comin' so there's no point a-waitin' fer it.
 *
 *****************************************************************************/

LRESULT CALLBACK
Network_WndProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp)
{
    switch (wm) {

    case WM_DESTROY:
        KillTimer(hwnd, 1);
        PostQuitMessage(0);
        break;

    case WM_TIMER:
    case WM_KILLFOCUS:
        Network_Snoop(hwnd);
        PostMessage(hwnd, WM_CLOSE, 0, 0L);
        break;

    }

    return DefWindowProc(hwnd, wm, wp, lp);
}

/*****************************************************************************
 *
 *  TweakLogon
 *
 *  Rundll entry point for automatic logon.  This is run as a system service.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

void EXPORT
TweakLogon(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow)
{
    AUTOLOGON al;

    hwnd;
    hinst;
    lpszCmdLine;
    nCmdShow;

#ifdef TAMMEB_PERF
    Network_LogQPC(TEXT("StartQPC"));
#endif

    GetStrPkl(al.tszUser, cbX(al.tszUser), &c_klDefUser);
    GetStrPkl(al.tszPass, cbX(al.tszPass), &c_klDefPass);

    /*
     *  Null password is okay.  But make sure there's a user and that
     *  the feature has been enabled.  And skip it all if the shift key
     *  is down.
     */
    if (GetIntPkl(0, &c_klAutoLogon) && al.tszUser[0] &&
        GetAsyncKeyState(VK_SHIFT) >= 0) {
        MSG msg;

        /*
         *  We create our window visible but 0 x 0.
         *
         *  We use a dummy edit control because that lets us extract the
         *  class word for edit controls.
         *
         *  The GWL_USERDATA of the control points to the logon strings.
         *
         */
        hwnd = CreateWindow(TEXT("edit"), "dummy text", WS_POPUP | WS_VISIBLE,
                            0, 0, 0, 0,
                            hwnd, 0, hinstCur, 0);

        SubclassWindow(hwnd, Network_WndProc);
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)&al);

        Network_Snoop(hwnd);

        /* Thirty seconds */
        SetTimer(hwnd, 1, 30000, 0);

        while (GetMessage(&msg, 0, 0, 0)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
#ifdef TAMMEB_PERF
    Network_LogQPC(TEXT("StopQPC"));
#endif


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tweakui\pickicon.cpp ===
/*
 * pickicon - Icon picker
 */

#include "tweakui.h"

/*
 *  Instance info for the dialog.
 */
typedef struct PIDI {		/* PickIcon dialog instance */
    LPTSTR ptszIconPath;	/* Which file? */
    UINT ctchIconPath;
    int iIconIndex;		/* Which icon number? */
    int *piIconIndex;
    TCH tszCurFile[MAX_PATH];	/* The path in the list box */
} PIDI, *PPIDI;

#define cxIcon GetSystemMetrics(SM_CXICON)
#define cyIcon GetSystemMetrics(SM_CYICON)

/*****************************************************************************
 *
 *  PickIcon_ppidiHdlg
 *
 *	Extract the PPIDI from an hdlg.
 *
 *****************************************************************************/

#define PickIcon_ppidiHdlg(hdlg) ((PPIDI)GetWindowLongPtr(hdlg, DWLP_USER))

/*****************************************************************************
 *
 *  PickIcon_OnMeasureItem
 *
 *	Tell USER the size of each item.
 *
 *****************************************************************************/

void PASCAL
PickIcon_OnMeasureItem(HWND hdlg, LPMEASUREITEMSTRUCT lpmi, PPIDI ppidi)
{
    lpmi->itemWidth = cxIcon + 12;
    lpmi->itemHeight = cyIcon + 4;
}

/*****************************************************************************
 *
 *  PickIcon_OnDrawItem
 *
 *	Draw an icon.
 *
 *****************************************************************************/

void PASCAL
PickIcon_OnDrawItem(HWND hdlg, LPDRAWITEMSTRUCT lpdi, PPIDI ppidi)
{
    SetBkColor(lpdi->hDC, GetSysColor((lpdi->itemState & ODS_SELECTED) ?
					COLOR_HIGHLIGHT : COLOR_WINDOW));

    /* repaint the selection state */
    ExtTextOut(lpdi->hDC, 0, 0, ETO_OPAQUE, &lpdi->rcItem, NULL, 0, NULL);

    /* draw the icon centered in the rectangle */
    if ((int)lpdi->itemID >= 0) {
	DrawIcon(lpdi->hDC,
		(lpdi->rcItem.left + lpdi->rcItem.right - cxIcon) / 2,
		(lpdi->rcItem.bottom + lpdi->rcItem.top - cyIcon) / 2,
		(HICON)lpdi->itemData);
    }

    /* if it has the focus, draw the focus */
    if (lpdi->itemState & ODS_FOCUS) {
	DrawFocusRect(lpdi->hDC, &lpdi->rcItem);
    }
}

/*****************************************************************************
 *
 *  PickIcon_OnDeleteItem
 *
 *	USER is nuking an item.  Clean it up.
 *
 *****************************************************************************/

#define PickIcon_OnDeleteItem(hdlg, lpdi, ppidi) \
    DestroyIcon((HICON)(lpdi)->itemData)

/*****************************************************************************
 *
 *  PickIcon_FillIconList
 *
 *	Fill in all the icons.  If the user picks a bad place, we leave
 *	garbage in the path (so he can edit the name) and leave the list
 *	box blank.
 *
 *****************************************************************************/

void PickIcon_FillIconList(HWND hdlg, PPIDI ppidi)
{
    HCURSOR hcurOld = SetCursor(LoadCursor(NULL, IDC_WAIT));
    HWND hwnd = GetDlgItem(hdlg, IDC_PICKICON);
    ListBox_SetColumnWidth(hwnd, cxIcon + 12);

    ListBox_ResetContent(hwnd);

    GetDlgItemText(hdlg, IDC_PICKPATH,
		   ppidi->tszCurFile, cA(ppidi->tszCurFile));

    if (SearchPath(0, ppidi->tszCurFile, 0, cA(ppidi->tszCurFile),
		   ppidi->tszCurFile, 0)) {
	int cIcons;
	SetDlgItemText(hdlg, IDC_PICKPATH, ppidi->tszCurFile);
	cIcons = ExtractIconEx(ppidi->tszCurFile, 0, 0, 0, 0);
	if (cIcons) {
	    HICON *rgIcons = (HICON *)LocalAlloc(LPTR, cIcons * sizeof(HICON));
	    if (rgIcons) {
		cIcons = (int)ExtractIconEx(ppidi->tszCurFile, 0,
					    rgIcons, NULL, cIcons);
		if (cIcons) {
		    int iicon;
		    SendMessage(hwnd, WM_SETREDRAW, 0, 0);
		    for (iicon = 0; iicon < cIcons; iicon++) {
			ListBox_AddString(hwnd, rgIcons[iicon]);
		    }
		    if (ListBox_SetCurSel(hwnd, ppidi->iIconIndex) == LB_ERR) {
			ListBox_SetCurSel(hwnd, 0);
		    }
		    SendMessage(hwnd, WM_SETREDRAW, 1, 0);
		} else {		/* Mysteriously unable to extract */
		}
		LocalFree((HLOCAL)rgIcons);
	    } else {			/* Not enough memory to load icons */
	    }
	} else {			/* No icons in the file */
	}
    } else {				/* File not found */
    }

    InvalidateRect(hwnd, 0, 1);
    SetCursor(hcurOld);
}

/*****************************************************************************
 *
 *  PickIcon_OnInitDialog
 *
 *	Dialog init.  Populate the list box with what we came in with.
 *
 *****************************************************************************/

void PASCAL
PickIcon_OnInitDialog(HWND hdlg, PPIDI ppidi)
{
    SetWindowLongPtr(hdlg, DWLP_USER, (LPARAM)ppidi);
    SetDlgItemText(hdlg, IDC_PICKPATH,
		   lstrcpyn(ppidi->tszCurFile,
			    ppidi->ptszIconPath, cA(ppidi->tszCurFile)));
    SendDlgItemMessage(hdlg, IDC_PICKPATH, EM_LIMITTEXT,
		       ppidi->ctchIconPath, 0);
    PickIcon_FillIconList(hdlg, ppidi);
}

/*****************************************************************************
 *
 *  PickIcon_OnBrowse
 *
 *****************************************************************************/

void PASCAL
PickIcon_OnBrowse(HWND hdlg, PPIDI ppidi)
{
    DWORD dw;
    COFN cofn;
    InitOpenFileName(hdlg, &cofn, IDS_ICONFILES, ppidi->tszCurFile);
    dw = GetFileAttributes(ppidi->tszCurFile);
    if (dw == 0xFFFFFFFF || (dw & FILE_ATTRIBUTE_DIRECTORY)) {
	cofn.tsz[0] = '\0';
    }

    if (GetOpenFileName(&cofn.ofn)) {
        SetDlgItemText(hdlg, IDC_PICKPATH, cofn.tsz);
        SendMessage(hdlg, DM_SETDEFID, IDOK, 0);
	PickIcon_FillIconList(hdlg, ppidi);
    }
}

/*****************************************************************************
 *
 *  PickIcon_NameChange
 *
 *  Determine whether the thing in the edit control doesn't match the
 *  thing whose icons we are showing.
 *
 *****************************************************************************/

BOOL PASCAL
PickIcon_NameChange(HWND hdlg, PPIDI ppidi)
{
    TCH tszBuffer[MAX_PATH];
    GetDlgItemText(hdlg, IDC_PICKPATH, tszBuffer, cA(tszBuffer));
    return lstrcmpi(tszBuffer, ppidi->tszCurFile);
}

/*****************************************************************************
 *
 *  PickIcon_OnOk
 *
 *	If the name has changed, treat this as a "Okay, now reload
 *	the icons" rather than "Okay, I'm finished".
 *
 *****************************************************************************/

void PASCAL
PickIcon_OnOk(HWND hdlg, PPIDI ppidi)
{
    if (PickIcon_NameChange(hdlg, ppidi)) {
	PickIcon_FillIconList(hdlg, ppidi);
    } else {
	int iIconIndex = (int)SendDlgItemMessage(hdlg, IDC_PICKICON,
						LB_GETCURSEL, 0, 0L);
	if (iIconIndex >= 0) {	/* We have an icon */
	    *ppidi->piIconIndex = iIconIndex;
	    lstrcpyn(ppidi->ptszIconPath, ppidi->tszCurFile,
		     ppidi->ctchIconPath);
	    EndDialog(hdlg, 1);
	} else {		/* No icon, act like cancel */
	    EndDialog(hdlg, 0);
	}
    }
}

/*****************************************************************************
 *
 *  PickIcon_OnCommand
 *
 *****************************************************************************/

void PASCAL
PickIcon_OnCommand(HWND hdlg, int id, UINT codeNotify, PPIDI ppidi)
{
    switch (id) {
    case IDOK: PickIcon_OnOk(hdlg, ppidi); break;
    case IDCANCEL: EndDialog(hdlg, 0); break;

    case IDC_PICKBROWSE: PickIcon_OnBrowse(hdlg, ppidi); break;

    /*
     *	When the name changes, remove the selection highlight.
     */
    case IDC_PICKPATH:
	if (PickIcon_NameChange(hdlg, ppidi)) {
	    SendDlgItemMessage(hdlg, IDC_PICKICON, LB_SETCURSEL, (WPARAM)-1, 0);
	}
	break;

    case IDC_PICKICON:
	if (PickIcon_NameChange(hdlg, ppidi)) {
	    PickIcon_FillIconList(hdlg, ppidi);
	} else if (codeNotify == LBN_DBLCLK) {
	    PickIcon_OnOk(hdlg, ppidi);
	}
	break;
    }
}

/*****************************************************************************
 *
 *  PickIcon_DlgProc
 *
 *	Dialog procedure.
 *
 *****************************************************************************/

/*
 * The HANDLE_WM_* macros weren't designed to be used from a dialog
 * proc, so we need to handle the messages manually.  (But carefully.)
 */

INT_PTR EXPORT
PickIcon_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    PPIDI ppidi = PickIcon_ppidiHdlg(hdlg);

    switch (wm) {
    case WM_INITDIALOG: PickIcon_OnInitDialog(hdlg, (PPIDI)lParam); break;

    case WM_COMMAND:
	PickIcon_OnCommand(hdlg, (int)GET_WM_COMMAND_ID(wParam, lParam),
				 (UINT)GET_WM_COMMAND_CMD(wParam, lParam),
				 ppidi);
	break;

    case WM_DRAWITEM:
	PickIcon_OnDrawItem(hdlg, (LPDRAWITEMSTRUCT)lParam, ppidi);
	break;

    case WM_MEASUREITEM:
	PickIcon_OnMeasureItem(hdlg, (LPMEASUREITEMSTRUCT)lParam, ppidi);
	break;

    case WM_DELETEITEM:
	PickIcon_OnDeleteItem(hdlg, (LPDELETEITEMSTRUCT)lParam, ppidi);
	break;

    default: return 0;	/* Unhandled */
    }
    return 1;		/* Handled */
}


/*****************************************************************************
 *
 *  PickIconDlg
 *
 *	Ask the user to pick an icon.
 *
 *	hwnd - owner window
 *	ptszIconPath - (in) default icon file
 *		      (out) chosen icon file
 *	ctchIconPath - size of ptszIconPath buffer
 *	piIconIndex - (in) default icon index
 *		      (out) index of chosen icon
 *
 *	If the dialog box is cancelled, then no values are changed.
 *
 *****************************************************************************/

INT_PTR PASCAL
PickIcon(HWND hwnd, LPTSTR ptszIconPath, UINT ctchIconPath, int *piIconIndex)
{
    PIDI pidi;

    pidi.ptszIconPath = ptszIconPath;
    pidi.ctchIconPath = ctchIconPath;
    pidi.piIconIndex = piIconIndex;
    pidi.iIconIndex = *piIconIndex;

    return DialogBoxParam(hinstCur, MAKEINTRESOURCE(IDD_PICKICON), hwnd,
			  PickIcon_DlgProc, (LPARAM)&pidi);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tweakui\ole.cpp ===
/*
 * ole - Random OLE stuff
 *
 *  Random shell stuff is here, too.
 */

#include "tweakui.h"

/*
 * InOrder - checks that i1 <= i2 < i3.
 */
#define fInOrder(i1, i2, i3) ((unsigned)((i2)-(i1)) < (unsigned)((i3)-(i1)))

LPMALLOC pmalloc;

/*****************************************************************************
 *
 *  Ole_Free
 *
 *	Free memory via OLE.
 *
 *****************************************************************************/

void PASCAL
Ole_Free(LPVOID pv)
{
    pmalloc->Free(pv);
}

/*****************************************************************************
 *
 *  Ole_ToUnicode
 *
 *	Convert an ANSI string to Unicode.
 *
 *****************************************************************************/

int PASCAL
Ole_ToUnicode(LPOLESTR lpos, LPCSTR psz)
{
    return MultiByteToWideChar(CP_ACP, 0, psz, -1, lpos, MAX_PATH);
}

/*****************************************************************************
 *
 *  Ole_FromUnicode
 *
 *	Convert to an ANSI string from Unicode.
 *
 *****************************************************************************/

int PASCAL
Ole_FromUnicode(LPSTR psz, LPOLESTR lpos)
{
    return WideCharToMultiByte(CP_ACP, 0, lpos, -1, psz, MAX_PATH, NULL, NULL);
}

/*****************************************************************************
 *
 *  Ole_Init
 *
 *	Initialize the OLE stuff.
 *
 *****************************************************************************/

HRESULT PASCAL
Ole_Init(void)
{
    HRESULT hres;
    hres = SHGetMalloc(&pmalloc);
    if (SUCCEEDED(hres)) {
	return SHGetDesktopFolder(&psfDesktop);
    } else {
	return hres;
    }
}

/*****************************************************************************
 *
 *  Ole_Term
 *
 *	Clean up the OLE stuff.
 *
 *****************************************************************************/

void PASCAL
Ole_Term(void)
{
    if (pmalloc) Ole_Release(pmalloc);
    if (psfDesktop) Ole_Release(psfDesktop);
}

/*****************************************************************************
 *
 *  Ole_ParseHex
 *
 *	Parse a hex string encoding cb bytes (at most 4), then
 *	expect the tchDelim to appear afterwards.  If chDelim is 0,
 *	then no delimiter is expected.
 *
 *	Store the result into the indicated LPBYTE (using only the
 *	size requested), updating it, and return a pointer to the
 *	next unparsed character, or 0 on error.
 *
 *	If the incoming pointer is also 0, then return 0 immediately.
 *
 *****************************************************************************/

LPCTSTR PASCAL
Ole_ParseHex(LPCTSTR ptsz, LPBYTE *ppb, int cb, TCH tchDelim)
{
    if (ptsz) {
	int i = cb * 2;
	DWORD dwParse = 0;

	do {
	    DWORD uch;
	    uch = (unsigned char)*ptsz - '0';
	    if (uch < 10) {		/* a decimal digit */
	    } else {
		uch = (*ptsz | 0x20) - 'a';
		if (uch < 6) {		/* a hex digit */
		    uch += 10;
		} else {
		    return 0;		/* Parse error */
		}
	    }
	    dwParse = (dwParse << 4) + uch;
	    ptsz++;
	} while (--i);

	if (tchDelim && *ptsz++ != tchDelim) return 0; /* Parse error */

	for (i = 0; i < cb; i++) {
	    (*ppb)[i] = ((LPBYTE)&dwParse)[i];
	}
	*ppb += cb;
    }
    return ptsz;
}

/*****************************************************************************
 *
 *  Ole_ParseGuid
 *
 *	Parse a guid.  The format is
 *
 *	{ <dword> - <word> - <word> - <byte> <byte> -
 *			<byte> <byte> <byte> <byte> <byte> <byte> }
 *
 *****************************************************************************/

BOOL PASCAL
Ole_ClsidFromString(LPCTSTR ptsz, LPCLSID pclsid)
{
    if (lstrlen(ptsz) == ctchClsid - 1 && *ptsz == '{') {
	ptsz++;
	ptsz = Ole_ParseHex(ptsz, (LPBYTE *)&pclsid, 4, TEXT('-'));
	ptsz = Ole_ParseHex(ptsz, (LPBYTE *)&pclsid, 2, TEXT('-'));
	ptsz = Ole_ParseHex(ptsz, (LPBYTE *)&pclsid, 2, TEXT('-'));
	ptsz = Ole_ParseHex(ptsz, (LPBYTE *)&pclsid, 1,       0  );
	ptsz = Ole_ParseHex(ptsz, (LPBYTE *)&pclsid, 1, TEXT('-'));
	ptsz = Ole_ParseHex(ptsz, (LPBYTE *)&pclsid, 1,       0  );
	ptsz = Ole_ParseHex(ptsz, (LPBYTE *)&pclsid, 1,       0  );
	ptsz = Ole_ParseHex(ptsz, (LPBYTE *)&pclsid, 1,       0  );
	ptsz = Ole_ParseHex(ptsz, (LPBYTE *)&pclsid, 1,       0  );
	ptsz = Ole_ParseHex(ptsz, (LPBYTE *)&pclsid, 1,       0  );
	ptsz = Ole_ParseHex(ptsz, (LPBYTE *)&pclsid, 1, TEXT('}'));
	return ptsz ? TRUE : FALSE;
    } else {
	return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tweakui\reg.cpp ===
/*
 * reg - registry wrappers
 */

#include "tweakui.h"

#pragma BEGIN_CONST_DATA

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *  RegCanModifyKey
 *
 *	Returns nonzero if the current user has permission to modify the
 *	key.
 *
 *****************************************************************************/

BOOL PASCAL
RegCanModifyKey(HKEY hkRoot, LPCTSTR ptszSubkey)
{
    BOOL fRc;
    if (g_fNT) {
	HKEY hk;
	DWORD dw;

	if (RegCreateKeyEx(hkRoot, ptszSubkey, 0, c_tszNil,
			   REG_OPTION_NON_VOLATILE, KEY_WRITE, 0, &hk,
			   &dw) == 0) {
	    RegCloseKey(hk);
	    fRc = 1;
	} else {
	    fRc = 0;
	}
    } else {
	fRc = 1;
    }
    return fRc;
}

/*****************************************************************************
 *
 *  _RegOpenKey
 *
 *	Special version for NT that always asks for MAXIMUM_ALLOWED.
 *
 *****************************************************************************/

LONG PASCAL
_RegOpenKey(HKEY hk, LPCTSTR ptszSubKey, PHKEY phkResult)
{
    return RegOpenKeyEx(hk, ptszSubKey, 0, MAXIMUM_ALLOWED, phkResult);
}

/*****************************************************************************
 *
 *  _RegCreateKey
 *
 *	Special version for NT that always asks for MAXIMUM_ALLOWED.
 *
 *****************************************************************************/

LONG PASCAL
_RegCreateKey(HKEY hk, LPCTSTR ptszSubKey, PHKEY phkResult)
{
    DWORD dw;
    if (ptszSubKey) {
	return RegCreateKeyEx(hk, ptszSubKey, 0, c_tszNil,
			      REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED, 0,
			      phkResult, &dw);
    } else {
	return RegOpenKey(hk, ptszSubKey, phkResult);
    }
}

/*****************************************************************************
 *
 *  RegDeleteValues
 *
 *  Deletes all the values under a key.
 *
 *****************************************************************************/

void PASCAL
RegDeleteValues(HKEY hkRoot, LPCTSTR ptszSubkey)
{
    HKEY hk;
    if (_RegOpenKey(hkRoot, ptszSubkey, &hk) == 0) {
	DWORD dw, ctch;
	TCHAR tszValue[ctchKeyMax];
	dw = 0;
	while (ctch = cA(tszValue),
	       RegEnumValue(hk, dw, tszValue, &ctch, 0, 0, 0, 0) == 0) {
	    if (RegDeleteValue(hk, tszValue) == 0) {
	    } else {
		dw++;
	    }
	}
	RegCloseKey(hk);
    }
}

/*****************************************************************************
 *
 *  RegDeleteTree
 *
 *  Deletes an entire registry tree.
 *
 *  Windows 95's RegDeleteKey will delete an entire tree, but Windows NT
 *  forces you to do it yourself.
 *
 *  Note that you need to watch out for the case where a key is undeletable,
 *  in which case you must skip over the key and continue as best you can.
 *
 *****************************************************************************/

LONG PASCAL
RegDeleteTree(HKEY hkRoot, LPCTSTR ptszSubkey)
{
    HKEY hk;
    LONG lRc;
    lRc = RegOpenKey(hkRoot, ptszSubkey, &hk);
    if (lRc == 0) {
	DWORD dw;
	TCHAR tszKey[ctchKeyMax];
	dw = 0;
	while (RegEnumKey(hk, dw, tszKey, cA(tszKey)) == 0) {
	    if (RegDeleteTree(hk, tszKey) == 0) {
	    } else {
		dw++;
	    }
	}
	RegCloseKey(hk);
	lRc = RegDeleteKey(hkRoot, ptszSubkey);
	if (lRc == 0) {
	} else {	/* Couldn't delete the key; at least nuke the values */
	    RegDeleteValues(hkRoot, ptszSubkey);
	}
    }
    return lRc;
}

/*****************************************************************************
 *
 *  RegKeyExists
 *
 *****************************************************************************/

BOOL PASCAL
RegKeyExists(HKEY hkRoot, LPCTSTR ptszSubkey)
{
    LONG cb;
    return RegQueryValue(hkRoot, ptszSubkey, 0, &cb) == ERROR_SUCCESS;
}

/*****************************************************************************
 *
 *  hkOpenClsid
 *
 *	Open a class id (guid) registry key, returning the hkey.
 *
 *****************************************************************************/

HKEY PASCAL
hkOpenClsid(PCTSTR ptszClsid)
{
    HKEY hk = 0;
    _RegOpenKey(pcdii->hkClsid, ptszClsid, &hk);
    return hk;
}

/*****************************************************************************
 *
 *  GetRegStr
 *
 *	Generic wrapper that pulls out a registry key/subkey.
 *
 *****************************************************************************/

BOOL PASCAL
GetRegStr(HKEY hkRoot, LPCTSTR ptszKey, LPCTSTR ptszSubkey,
          LPTSTR ptszBuf, int cbBuf)
{
    HKEY hk;
    BOOL fRc;
    if ((UINT)cbBuf >= cbCtch(1)) {
	ptszBuf[0] = TEXT('\0');
    }
    if (hkRoot && _RegOpenKey(hkRoot, ptszKey, &hk) == 0) {
        DWORD cb = cbBuf;
        fRc = RegQueryValueEx(hk, ptszSubkey, 0, 0, (LPBYTE)ptszBuf, &cb) == 0;
	RegCloseKey(hk);
    } else {
	fRc = 0;
    }
    return fRc;
}

/*****************************************************************************
 *
 *  GetStrPkl
 *
 *	Read a registry key/subkey/string value given a key location.
 *
 *****************************************************************************/

BOOL PASCAL
GetStrPkl(LPTSTR ptszBuf, int cbBuf, PKL pkl)
{
    return GetRegStr(*pkl->phkRoot, pkl->ptszKey, pkl->ptszSubkey,
		     ptszBuf, cbBuf);
}

/*****************************************************************************
 *
 *  GetRegDword
 *
 *	Read a dword, returning the default if unable.
 *
 *****************************************************************************/

DWORD PASCAL
GetRegDword(HHK hhk, LPCSTR pszKey, LPCSTR pszSubkey, DWORD dwDefault)
{
    DWORD dw;
    if (GetRegStr(hkeyHhk(hhk), pszKey, pszSubkey, (LPTSTR)&dw, sizeof(dw))) {
	return dw;
    } else {
	return dwDefault;
    }
}

/*****************************************************************************
 *
 *  GetDwordPkl
 *
 *	Given a location, read a dword, returning the default if unable.
 *
 *****************************************************************************/

DWORD PASCAL
GetDwordPkl(PKL pkl, DWORD dwDefault)
{
    DWORD dw;
    if (GetRegStr(*pkl->phkRoot, pkl->ptszKey,
		  pkl->ptszSubkey, (LPTSTR)&dw, sizeof(dw))) {
	return dw;
    } else {
	return dwDefault;
    }
}

/*****************************************************************************
 *
 *  GetRegInt
 *
 *	Generic wrapper that pulls out a registry key/subkey as an unsigned.
 *
 *****************************************************************************/

UINT PASCAL
GetRegInt(HHK hhk, LPCSTR pszKey, LPCSTR pszSubkey, UINT uiDefault)
{
    TCH tsz[20];
    if (GetRegStr(hkeyHhk(hhk), pszKey, pszSubkey, tsz, cA(tsz))) {
	int i = iFromPtsz(tsz);
	return i == iErr ? uiDefault : (UINT)i;
    } else {
	return uiDefault;
    }
}

/*****************************************************************************
 *
 *  GetIntPkl
 *
 *	Generic wrapper that pulls out a registry key/subkey as an unsigned.
 *
 *****************************************************************************/

UINT PASCAL
GetIntPkl(UINT uiDefault, PKL pkl)
{
    return GetRegInt(*pkl->phkRoot, pkl->ptszKey, pkl->ptszSubkey, uiDefault);
}

/*****************************************************************************
 *
 *  RegSetValuePtsz
 *
 *	Generic wrapper that writes out a registry key/subkey as a string.
 *
 *****************************************************************************/

BOOL PASCAL
RegSetValuePtsz(HKEY hk, LPCSTR pszSubkey, LPCTSTR ptszVal)
{
    return RegSetValueEx(hk, pszSubkey, 0, REG_SZ, (LPBYTE)ptszVal,
                         1 + lstrlen(ptszVal)) == ERROR_SUCCESS;
}

/*****************************************************************************
 *
 *  SetRegStr
 *
 *	Generic wrapper that writes out a registry key/subkey.
 *
 *	It is an error to call this with a bad hhk.
 *
 *****************************************************************************/

BOOL PASCAL
SetRegStr(HHK hhk, LPCTSTR ptszKey, LPCTSTR ptszSubkey, LPCTSTR ptszVal)
{
    BOOL fRc = FALSE;
    HKEY hk;
    if (RegCreateKey(hkeyHhk(hhk), ptszKey, &hk) == 0) {
        fRc = RegSetValuePtsz(hk, ptszSubkey, ptszVal);
	RegCloseKey(hk);
    }
    return fRc;
}

/*****************************************************************************
 *
 *  SetStrPkl
 *
 *	Set a registry key/subkey/string value given a key location.
 *
 *	It is an error to call this with a bad hkRoot.
 *
 *****************************************************************************/

BOOL PASCAL
SetStrPkl(PKL pkl, LPCTSTR ptszVal)
{
    return SetRegStr(*pkl->phkRoot, pkl->ptszKey, pkl->ptszSubkey, ptszVal);
}


/*****************************************************************************
 *
 *  SetRegInt
 *
 *	Generic wrapper that writes out a registry key/subkey as an
 *	unsigned integer.
 *
 *****************************************************************************/

BOOL PASCAL
SetRegInt(HHK hhk, LPCSTR pszKey, LPCSTR pszSubkey, UINT ui)
{
    TCH tsz[20];
    wsprintf(tsz, c_tszPercentU, ui);
    return SetRegStr(hhk, pszKey, pszSubkey, tsz);
}

/*****************************************************************************
 *
 *  SetIntPkl
 *
 *	Writes out a registry key/subkey as an unsigned integer.
 *
 *****************************************************************************/

BOOL PASCAL
SetIntPkl(UINT ui, PKL pkl)
{
    return SetRegInt(*pkl->phkRoot, pkl->ptszKey, pkl->ptszSubkey, ui);
}

/*****************************************************************************
 *
 *  SetRegDwordEx
 *
 *	Generic wrapper that writes out a registry key/subkey as a
 *      dword, of requested type.
 *
 *****************************************************************************/

BOOL PASCAL
SetRegDwordEx(HHK hhk, LPCSTR pszKey, LPCSTR pszSubkey, DWORD dw, DWORD dwType)
{
    BOOL fRc = FALSE;
    HKEY hk;
    if (RegCreateKey(hkeyHhk(hhk), pszKey, &hk) == 0) {
        /* Bad prototype for RegSetValueEx forces me to cast */
        fRc = RegSetValueEx(hk, pszSubkey, 0, dwType, (LPBYTE)&dw, sizeof(dw)) == 0;
        RegCloseKey(hk);
    }
    return fRc;
}

/*****************************************************************************
 *
 *  SetRegDword
 *
 *	Generic wrapper that writes out a registry key/subkey as a
 *      dword, but typed as REG_BINARY (Win95 does this).
 *
 *****************************************************************************/

BOOL PASCAL
SetRegDword(HHK hhk, LPCSTR pszKey, LPCSTR pszSubkey, DWORD dw)
{
    return SetRegDwordEx(hhk, pszKey, pszSubkey, dw, REG_BINARY);
}

/*****************************************************************************
 *
 *  SetRegDword2
 *
 *	Generic wrapper that writes out a registry key/subkey as a
 *      real REG_DWORD.
 *
 *****************************************************************************/

BOOL PASCAL
SetRegDword2(HHK hhk, LPCSTR pszKey, LPCSTR pszSubkey, DWORD dw)
{
    return SetRegDwordEx(hhk, pszKey, pszSubkey, dw, REG_DWORD);
}

/*****************************************************************************
 *
 *  SetDwordPkl
 *
 *	Generic wrapper that writes out a registry key/subkey as a
 *	dword, given a key location.
 *
 *****************************************************************************/

BOOL PASCAL
SetDwordPkl(PKL pkl, DWORD dw)
{
    return SetRegDword(*pkl->phkRoot, pkl->ptszKey, pkl->ptszSubkey, dw);
}


/*****************************************************************************
 *
 *  SetDwordPkl2
 *
 *	Generic wrapper that writes out a registry key/subkey as a
 *	real REG_DWORD, given a key location.
 *
 *****************************************************************************/

BOOL PASCAL
SetDwordPkl2(PKL pkl, DWORD dw)
{
    return SetRegDword2(*pkl->phkRoot, pkl->ptszKey, pkl->ptszSubkey, dw);
}


/*****************************************************************************
 *
 *  DelPkl
 *
 *	Generic wrapper that deletes a registry key/subkey.
 *
 *****************************************************************************/

BOOL PASCAL
DelPkl(PKL pkl)
{
    BOOL fRc;
    HKEY hk;
    LONG lRc;

    lRc = _RegOpenKey(*pkl->phkRoot, pkl->ptszKey, &hk);
    switch (lRc) {
    case ERROR_SUCCESS:
        fRc = RegDeleteValue(hk, pkl->ptszSubkey) == 0;
        RegCloseKey(hk);
        break;

    case ERROR_FILE_NOT_FOUND:
    case ERROR_PATH_NOT_FOUND:
        fRc = TRUE;             /* if it doesn't exist, then that's okay */
        break;

    default:
        fRc = FALSE;
        break;
    }
    return fRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tweakui\pidl.cpp ===
/*
 * pidl - PIDLs and diddles
 *
 */

#include "tweakui.h"

#pragma BEGIN_CONST_DATA

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *  pidlFromPath
 *
 *	Create a pidl from an psf and a relative path.
 *
 *****************************************************************************/

PIDL PASCAL
pidlFromPath(LPSHELLFOLDER psf, LPCTSTR lqn)
{
    PIDL pidl;
    UnicodeFromPtsz(wsz, lqn);
    if (SUCCEEDED(psf->ParseDisplayName(0, 0, wsz, 0, &pidl, 0))) {
	return pidl;
    } else {
	return 0;
    }
}

/*****************************************************************************
 *
 *  pidlSimpleFromPath
 *
 *      Create a simple pidl from an psf and a relative path.
 *
 *****************************************************************************/

PIDL PASCAL
pidlSimpleFromPath(LPCTSTR lqn)
{
    PIDL pidl;
    if (g_fNT) {
        UnicodeFromPtsz(wsz, lqn);
        return mit.SHSimpleIDListFromPath(wsz);
    } else {
        AnsiFromPtsz(sz, lqn);
        return mit.SHSimpleIDListFromPath(sz);
    }
}

/*****************************************************************************
 *
 *  SetNameOfPidl
 *
 *	Change a pidl's name.
 *
 *****************************************************************************/

HRESULT PASCAL
SetNameOfPidl(PSF psf, PIDL pidl, LPCTSTR ptszName)
{
    UnicodeFromPtsz(wsz, ptszName);
    return psf->SetNameOf(0, pidl, wsz, 0, 0);
}

/*****************************************************************************
 *
 *  ComparePidls
 *
 *	Compare two pidls.
 *
 *****************************************************************************/

HRESULT PASCAL
ComparePidls(PIDL pidl1, PIDL pidl2)
{
    return psfDesktop->CompareIDs(0, pidl1, pidl2);
}

/*****************************************************************************
 *
 *  GetSystemImageList
 *
 *	Get the large or small image list handle.
 *
 *	The dword argument is 0 for the large image list, or
 *	SHGFI_SMALLICON for the small image list.
 *
 *****************************************************************************/

HIML PASCAL
GetSystemImageList(DWORD dw)
{
    SHFILEINFO sfi;
    return (HIML)SHGetFileInfo(g_tszPathShell32, FILE_ATTRIBUTE_DIRECTORY,
			       &sfi, sizeof(sfi), SHGFI_USEFILEATTRIBUTES |
			       SHGFI_SYSICONINDEX | dw);
}

/*****************************************************************************
 *
 *  ChangeNotifyCsidl
 *
 *      Send a SHChangeNotify based on a CSIDL.
 *
 *****************************************************************************/

STDAPI_(void)
ChangeNotifyCsidl(HWND hwnd, int csidl, LONG eventId)
{
    PIDL pidl;
    if (SUCCEEDED(SHGetSpecialFolderLocation(hwnd, csidl, &pidl))) {
        SHChangeNotify(eventId, SHCNF_IDLIST, pidl, 0L);
        Ole_Free(pidl);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tweakui\prsht.cpp ===
/*
 * prsht.c - Hacky property sheet code
 */

#include "tweakui.h"

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   Prsht_SkipDlgString |
 *
 *          Skip a thing-that-might-be-a-string in a dialog template.
 *
 *          It could be 0xFFFF, meaning that the next word is all.
 *          Or it's a unicode string.
 *
 *          Note that everything stays word-aligned, so we don't need
 *          to worry about UNALIGNEDness.
 *
 ***************************************************************************/

LPWORD PASCAL
Prsht_SkipDlgString(LPWORD pw)
{
    if (*pw == 0xFFFF) {
        pw += 2;
    } else {
        while (*pw++) {         /* Skip over the UNICODE string */
        }
    }
    return pw;
}

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   Prsht_PropertySheetCallback |
 *
 *          We also want to force single-line tabs.  We must do it
 *          here so that the margins are set up correctly.  (If we
 *          wait until WM_INITDIALOG, then when we change to
 *          single-line tabs, we get messed-up margins.)
 *
 *          We need single-line tabs because multi-line tabs cause
 *          our property sheet to be too large to fit on an 640x480
 *          screen.
 *
 *          Do this only if we are running on a 640 x 480 display.
 *
 ***************************************************************************/

typedef struct DLGFINISH {
    WORD cdit;
    short x;
    short y;
    short cx;
    short cy;
} DLGFINISH, *PDLGFINISH;

typedef struct DLGTEMPLATEEX {
    WORD wDlgVer;
    WORD wSignature;
    DWORD dwHelpID;
    DWORD dwExStyle;
    DWORD style;
    WORD cDlgItems;
    short x;
    short y;
    short cx;
    short cy;
} DLGTEMPLATEEX, *PDLGTEMPLATEEX;

typedef struct DLGITEMTEMPLATEEX {
    DWORD dwHelpID;
    DWORD dwExStyle;
    DWORD style;
    short x;
    short y;
    short cx;
    short cy;
    DWORD dwID;
} DLGITEMTEMPLATEEX, *PDLGITEMTEMPLATEEX;

typedef struct DLGITEMCOORDS {
    short x;
    short y;
    short cx;
    short cy;
} DLGITEMCOORDS, *PDLGITEMCOORDS;

WCHAR   c_wszTabClass[] = WC_TABCONTROLW;

int CALLBACK
Prsht_PropertySheetCallback(HWND hwnd, UINT pscb, LPARAM lp)
{
    LPDLGTEMPLATE pdt;
    UINT idit;
    LPWORD pw;
    BOOL fEx;
    DWORD dwStyle;
    PDLGFINISH pdf;

    hwnd;

    switch (pscb) {
    case PSCB_PRECREATE:

        if (GetSystemMetrics(SM_CYSCREEN) <= 480) {
            pdt = (LPDLGTEMPLATE)lp;

            if (pdt->style == 0xFFFF0001) {
                PDLGTEMPLATEEX pdtex= (PDLGTEMPLATEEX)lp;
                fEx = 1;
                dwStyle = pdtex->style;
                pdf = (PDLGFINISH)&pdtex->cDlgItems;
                pw = (LPWORD)(pdtex+1);
            } else {
                fEx = 0;
                dwStyle = pdt->style;
                pdf = (PDLGFINISH)&pdt->cdit;
                pw = (LPWORD)(pdt+1);
            }

            /*
             *  After the DLGTEMPLATE(EX) come three strings:
             *  the menu, the class, and the title.
             */
            pw = Prsht_SkipDlgString(pw);       /* Menu */
            pw = Prsht_SkipDlgString(pw);       /* Class */
            pw = Prsht_SkipDlgString(pw);       /* Title */

            /*
             *  Then the optional font.
             */
            if (dwStyle & DS_SETFONT) {
                pw++;                           /* Font size */
                if (fEx) {
                    pw++;                       /* Font weight */
                    pw++;                       /* Font style and charset */
                }
                pw = Prsht_SkipDlgString(pw);   /* Font name */
            }

            /*
             *  Now walk the item list looking for the tab control.
             */
            for (idit = 0; idit < pdf->cdit; idit++) {
                /* Round up to next dword; all aligned and happy again */
                LPDLGITEMTEMPLATE pdit = (LPDLGITEMTEMPLATE)(((DWORD_PTR)pw + 3) & ~3);
                PDLGITEMTEMPLATEEX pditex = (PDLGITEMTEMPLATEEX)pdit;
                PDLGITEMCOORDS pdic;

                if (fEx) {
                    pw = (LPWORD)(pditex+1);
                } else {
                    pw = (LPWORD)(pdit+1);
                }

                /* Immediately after the pdit is the class name */
                if (memcmp(pw, c_wszTabClass, cbX(c_wszTabClass)) == 0) {

                    LPDWORD pdwStyle;

                    /* Found it!  Nuke the multiline style */
                    if (fEx) {
                        pdwStyle = &pditex->style;
                        pdic = (PDLGITEMCOORDS)&pditex->x;
                    } else {
                        pdwStyle = &pdit->style;
                        pdic = (PDLGITEMCOORDS)&pdit->x;
                    }

                    *pdwStyle &= ~TCS_MULTILINE;

                    break;
                }

                /* Oh well, on to the next one */

                pw = Prsht_SkipDlgString(pw);               /* Class */
                pw = Prsht_SkipDlgString(pw);               /* Title */

                pw = (LPWORD)((LPBYTE)pw + 2 + *pw);        /* Goo */
            }
        }
        break;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tweakui\repair.cpp ===
/*
 * repair - Dialog box property sheet for "Repair"
 */

#include "tweakui.h"

#pragma BEGIN_CONST_DATA

KL const c_klRegView = { &g_hkCUSMWCV, c_tszRegedit, c_tszView };

const static DWORD CODESEG rgdwHelp[] = {
        IDC_REPAIRCOMBO,        IDH_REPAIR,
        IDC_REPAIRNOW,          IDH_REPAIR,
        IDC_REPAIRHELP,         IDH_REPAIR,
        IDC_REPAIRTEXT,         IDH_REPAIR,
        IDC_REPAIRICON,         IDH_REPAIR,
        0,                      0,
};

typedef UINT (PASCAL *REPAIRPATHPROC)(HWND hdlg, LPTSTR ptszBuf);

/*****************************************************************************
 *
 *  _Repair_FileFromResource
 *
 *	Given a resource ID and a file name, extract the c_tszExe resource
 *	into that file.
 *
 *****************************************************************************/

BOOL PASCAL
_Repair_FileFromResource(UINT idx, LPCTSTR ptszFileName)
{
    BOOL fRc;
    HRSRC hrsrc = FindResource(hinstCur, (LPCTSTR)IntToPtr(idx), c_tszExe);
    if (hrsrc) {
	HGLOBAL hglob = LoadResource(hinstCur, hrsrc);
	if (hglob) {
	    PV pv = LockResource(hglob);
	    if (pv) {
		HFILE hf = _lcreat(ptszFileName, 0);
		if (hf != HFILE_ERROR) {
		    UINT cb = SizeofResource(hinstCur, hrsrc);
		    fRc = _lwrite(hf, (char *)pv, cb) == cb;
		    _lclose(hf);
		    if (fRc) {
		    } else {
			DeleteFile(ptszFileName);
		    }
                } else {
                    fRc = 0;
                }
	    } else {
		fRc = 0;
	    }
	} else {
	    fRc = 0;
	}
    } else {
	fRc = 0;
    }
    return fRc;
}

/*****************************************************************************
 *
 *  Repair_RunSetupCqn
 *
 *	Put the Setup program into the specified directory and run it.
 *	WithTempDirectory will clean up the file when we return.
 *
 *****************************************************************************/

BOOL PASCAL
Repair_RunSetupCqn(LPCTSTR cqn, LPVOID pv)
{
    BOOL fRc;
    fRc = _Repair_FileFromResource(IDX_SETUP, c_tszSetupExe);
    if (fRc) {
	STARTUPINFO si;
	PROCESS_INFORMATION pi;
	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	fRc = CreateProcess(0, c_tszSetupExe, 0, 0, 0, 0, 0, 0, &si, &pi);
	if (fRc) {
	    CloseHandle(pi.hThread);
	    WaitForSingleObject(pi.hProcess, INFINITE);
	    CloseHandle(pi.hProcess);
	}
    }
    return fRc;
}

#ifdef _X86_

/*****************************************************************************
 *
 *  Repair_MoveFileExWininit
 *
 *	Rename a file via wininit.ini.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

TCHAR c_tszPercentSEqualsPercentS[] = TEXT("%s=%s");

#pragma END_CONST_DATA

void PASCAL
Repair_MoveFileExWininit(LPCTSTR ptszDst, LPCTSTR ptszSrc)
{
    TCHAR tszWininit[MAX_PATH];
    DWORD cb;
    LPSTR pszBuf;
    WIN32_FIND_DATA wfd;
    HANDLE h;

    if (GetWindowsDirectory(tszWininit, cA(tszWininit))) {
        lstrcatnBs(tszWininit, c_tszWininit, MAX_PATH);

        /* INI files are always in ANSI */

        h = FindFirstFile(ptszSrc, &wfd);
        if (h != INVALID_HANDLE_VALUE) {
            FindClose(h);
        } else {
            wfd.nFileSizeLow = 0;
        }
        cb = wfd.nFileSizeLow + MAX_PATH + 1 + MAX_PATH + 3;

        pszBuf = (LPSTR)lAlloc(cb);
        if (pszBuf) {
            LPSTR psz;
            if (!GetPrivateProfileSection(c_tszRename, pszBuf, cb, tszWininit)) {
                /* No such section; create one */
                /* Already done by LocalAlloc (zero-init) */
            }
            for (psz = pszBuf; psz[0]; psz += lstrlenA(psz) + 1);
            psz += wsprintf(psz, c_tszPercentSEqualsPercentS, ptszDst, ptszSrc);
            psz[1] = '\0';
            WritePrivateProfileSection(c_tszRename, pszBuf, tszWininit);
            lFree(pszBuf);
        }
    }
}

#endif

/*****************************************************************************
 *
 *  Repair_MoveFileEx
 *
 *	Try to rename the file from existing.dll to existing.bak,
 *	using MoveFileEx or wininit.ini as necessary.
 *
 *	Note that we must use the short name because that's all that
 *	wininit.ini understands.
 *
 *****************************************************************************/

void PASCAL
Repair_MoveFileEx(LPTSTR ptszSrc)
{
    TCHAR tszDst[MAX_PATH];

    GetShortPathName(ptszSrc, ptszSrc, MAX_PATH);

    lstrcpy(tszDst, ptszSrc);
    lstrcpy(tszDst + lstrlen(tszDst) - 4, c_tszDotBak);

    DeleteFile(tszDst);

    if (MoveFile(ptszSrc, tszDst)) {
	/* All done */
    } else if (MoveFileEx(ptszSrc, tszDst, MOVEFILE_DELAY_UNTIL_REBOOT)) {
	/* All done */
#ifdef _X86_
    } else if (g_fNT) {
	/* I did my best */
    } else {		/* wininit.ini for Windows 95 */
	Repair_MoveFileExWininit(tszDst, ptszSrc);
#endif
    }

}

/*****************************************************************************
 *
 *  _Repair_RunSetup
 *
 *	Check if there are any hidden DLLs on the desktop.
 *
 *	Extract the tiny little "setup" program attached via our resources,
 *	run it, delete it, then tell the user they she may need to restart
 *	the computer for the full effect to kick in.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA
TCHAR c_tszStarDotDll[] = TEXT("*.DLL");
#pragma END_CONST_DATA

UINT PASCAL
_Repair_RunSetup(HWND hdlg, REPAIRPATHPROC GetRepairPath)
{
    PIDL pidl;

    if (SUCCEEDED(SHGetSpecialFolderLocation(hdlg, CSIDL_DESKTOPDIRECTORY,
					     &pidl))) {
	HANDLE h;
	TCHAR tszDesktop[MAX_PATH];
	TCHAR tszSrc[MAX_PATH];
	WIN32_FIND_DATA wfd;

	SHGetPathFromIDList(pidl, tszDesktop);
	lstrcpy(tszSrc, tszDesktop);
	lstrcatnBsA(tszSrc, c_tszStarDotDll);
	h = FindFirstFile(tszSrc, &wfd);
	if (h != INVALID_HANDLE_VALUE) {
	    do {
		lstrcpy(tszSrc, tszDesktop);
		lstrcatnBsA(tszSrc, wfd.cFileName);
		Repair_MoveFileEx(tszSrc);
	    } while (FindNextFile(h, &wfd));
	    FindClose(h);
	}

	Ole_Free(pidl);
    }

    WithTempDirectory(Repair_RunSetupCqn, 0);

    return IDS_MAYBEREBOOT;
}

/*****************************************************************************
 *
 *  _Repair_GetFontPath
 *
 *      Obtain the path to the Fonts folder.
 *
 *****************************************************************************/

UINT PASCAL
_Repair_GetFontPath(HWND hdlg, LPTSTR ptszBuf)
{
    PIDL pidlFonts;

    if (SUCCEEDED(SHGetSpecialFolderLocation(hdlg, CSIDL_FONTS, &pidlFonts))) {
        SHGetPathFromIDListA(pidlFonts, ptszBuf);
        Ole_Free(pidlFonts);
    }

    return IDX_FONTFOLDER;
}

/*****************************************************************************
 *
 *  _Repair_GetIEPath
 *
 *      Obtain the path to some IE special folder.
 *
 *      If we can't get it from the registry, then it's just
 *      "%windir%\ptszSubdir".
 *
 *****************************************************************************/

void PASCAL
_Repair_GetIEPath(LPTSTR ptszBuf, LPCTSTR ptszKey, LPCTSTR ptszSubdir)
{
    HKEY hk;

    ptszBuf[0] = TEXT('\0');

    if (RegOpenKeyEx(g_hkLMSMWCV, ptszKey, 0, KEY_QUERY_VALUE, &hk)
        == ERROR_SUCCESS) {
        DWORD cb = cbCtch(MAX_PATH);
        DWORD dwType;
        RegQueryValueEx(hk, c_tszDirectory, 0, &dwType, (LPBYTE)ptszBuf,
                        &cb);
        RegCloseKey(hk);
        if (dwType == REG_EXPAND_SZ) {
            LPTSTR ptszTemp;
            cb = ExpandEnvironmentStrings(ptszBuf, NULL, 0);
            ptszTemp = (LPTSTR)LocalAlloc(LPTR, cb * sizeof(TCHAR));
            if (ptszTemp) {
                if (ExpandEnvironmentStrings(ptszBuf, ptszTemp, cb)) {
                    lstrcpyn(ptszBuf, ptszTemp, MAX_PATH);
                }
                LocalFree(ptszTemp);
            }
        }
    }

    if (ptszBuf[0] == TEXT('\0') &&
        GetWindowsDirectory(ptszBuf, MAX_PATH - lstrlen(ptszSubdir) - 1)) {
        ptszBuf = TweakUi_TrimTrailingBs(ptszBuf);
        *ptszBuf++ = TEXT('\\');
        lstrcpy(ptszBuf, ptszSubdir);
    }
}

/*****************************************************************************
 *
 *  _Repair_GetHistoryPath
 *
 *      Obtain the path to the URL History folder.
 *
 *      If we can't get it from the registry, then it's just
 *      "%windir%\History".
 *
 *****************************************************************************/

UINT PASCAL
_Repair_GetHistoryPath(HWND hdlg, LPTSTR ptszBuf)
{
    _Repair_GetIEPath(ptszBuf, c_tszUrlHist, c_tszHistory);
    return IDX_HISTORY;
}

/*****************************************************************************
 *
 *  _Repair_GetCachePath
 *
 *      Obtain the path to the Temporary Internet Files folder.
 *
 *      If we can't get it from the registry, then it's just
 *      "%windir%\Temporary Internet Files".
 *
 *****************************************************************************/

UINT PASCAL
_Repair_GetCachePath(HWND hdlg, LPTSTR ptszBuf)
{
    _Repair_GetIEPath(ptszBuf, c_tszIECache, c_tszTempInet);
    return IDX_TEMPINET;
}

/*****************************************************************************
 *
 *  _Repair_RepairJunction
 *
 *      Hack at a junction to make it magic again.
 *
 *****************************************************************************/

UINT PASCAL
_Repair_RepairJunction(HWND hdlg, REPAIRPATHPROC GetRepairPath)
{
    PIDL pidlFonts;
    TCHAR tsz[MAX_PATH];
    UINT ids;

    tsz[0] = TEXT('\0');

    ids = GetRepairPath(hdlg, tsz);
    if (ids && tsz[0]) {

        /* Ignore error; might already exist */
        CreateDirectory(tsz, 0);

        /* Ignore error; might not have permission to change attributes */
        SetFileAttributes(tsz, FILE_ATTRIBUTE_SYSTEM);

        lstrcpy(TweakUi_TrimTrailingBs(tsz), c_tszBSDesktopIni);

        _Repair_FileFromResource(ids, tsz);
    }
    return IDS_MAYBEREBOOT;
}

/*****************************************************************************
 *
 *  _Repair_RepairFontFolder
 *
 *      The font folder is special in that if we can find a
 *      DllRegisterServer, we will call it as well.
 *
 *****************************************************************************/

typedef HRESULT (CALLBACK *DLLREGISTERSERVER)(void);

UINT PASCAL
_Repair_RepairFontFolder(HWND hdlg, REPAIRPATHPROC GetRepairPath)
{
    UINT ids = _Repair_RepairJunction(hdlg, GetRepairPath);

    /*
     *  Do this after we do the default repair so fontext has a chance
     *  to override whatever we did.
     */
    HINSTANCE hinst = LoadLibrary("fontext.dll");
    if (hinst) {
        DLLREGISTERSERVER _DllRegisterServer =
       (DLLREGISTERSERVER)GetProcAddress(hinst, "DllRegisterServer");
        if (_DllRegisterServer) {
            _DllRegisterServer();
        }
        FreeLibrary(hinst);
    }
    return ids;
}

/*****************************************************************************
 *
 *  _Repair_RepairIconCache
 *
 *      Rebuild the icon cache.
 *
 *****************************************************************************/

UINT PASCAL
_Repair_RepairIconCache(HWND hdlg, REPAIRPATHPROC GetRepairPath)
{
    Misc_RebuildIcoCache();
    return 0;
}

/*****************************************************************************
 *
 *  _Repair_RepairRegedit
 *
 *      Nuke the saved view goo so Regedit won't be hosed.
 *
 *****************************************************************************/

UINT PASCAL
_Repair_RepairRegedit(HWND hdlg, REPAIRPATHPROC GetRepairPath)
{
    DelPkl(&c_klRegView);
    return 0;
}

/*****************************************************************************
 *
 *  _Repair_RepairAssociations
 *
 *      Rebuild the associations.
 *
 *****************************************************************************/

UINT PASCAL
_Repair_RepairAssociations(HWND hdlg, REPAIRPATHPROC GetRepairPath)
{
    if (MessageBoxId(hdlg, IDS_DESKTOPRESETOK,
                     g_tszName, MB_YESNO + MB_DEFBUTTON2) == IDYES) {
        pcdii->fRunShellInf = 1;
        Common_NeedLogoff(hdlg);
        PropSheet_Apply(GetParent(hdlg));
    }
    return 0;
}

/*****************************************************************************
 *
 *  _Repair_RepairHotkeys
 *
 *      Rebuild the Start Menu hotkey list.
 *
 *****************************************************************************/

UINT PASCAL
_Repair_RepairHotkeys(HWND hdlg, REPAIRPATHPROC GetRepairPath)
{
    SetRegStr(g_hkCUSMWCV, TEXT("RunOnce"),
                           TEXT("TweakUI_RepairHotkeys"),
                           TEXT("RUNDLL32.EXE TWEAKUI.CPL,RepairHotkeys"));
    MessageBoxId(hdlg, IDS_REPAIRLOGONOFF, g_tszName, MB_OK);
    return 0;
}

/*****************************************************************************
 *
 *  RepairHotkeys
 *
 *  Rundll entry point.
 *
 *  This must be run during RunOnce because it has to do its work while
 *  the tray does not exist.  The tray loads settings when it is created,
 *  and it saves them when it is destroyed.  So if you try to clean up
 *  the hotkeys
 *
 *****************************************************************************/

void EXPORT
RepairHotkeys(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow)
{
    RegDeleteKey(pcdii->hkCUExplorer, TEXT("Hotkeys"));
}

/*****************************************************************************
 *
 *  Repair_IsWin95
 *
 *      Nonzero if we are on Windows 95.
 *
 *****************************************************************************/

BOOL PASCAL
Repair_IsWin95(void)
{
    return !g_fNT;
}

/*****************************************************************************
 *
 *  Repair_IsIE3
 *
 *      Nonzero if we are on IE3 or better.
 *
 *****************************************************************************/

BOOL PASCAL
Repair_IsIE3(void)
{
    return g_hkCUSMIE ? TRUE : FALSE;
}

/*****************************************************************************
 *
 *  Repair_IsIE3or4
 *
 *      Nonzero if we are on IE3 or IE4, but not IE5.
 *
 *****************************************************************************/

BOOL PASCAL
Repair_IsIE3or4(void)
{
    return g_hkCUSMIE && !g_fIE5 ? TRUE : FALSE;
}

/*****************************************************************************
 *
 *  REPAIRINFO
 *
 *****************************************************************************/

typedef struct REPAIRINFO {
    BOOL (PASCAL *CanRepair)(void);
    UINT (PASCAL *Repair)(HWND hdlg, REPAIRPATHPROC GetRepairPath);
    REPAIRPATHPROC GetRepairPath;
} REPAIRINFO, *PREPAIRINFO;

/*
 *  Note that this needs to be in sync with the IDS_REPAIR strings.
 */
struct REPAIRINFO c_rgri[] = {
    {   0,
        _Repair_RepairIconCache,
        0,
    },                                  /* Rebuild Icons */

    {   0,
        _Repair_RepairFontFolder,
        _Repair_GetFontPath,
    },                                  /* Repair Font Folder */

    {   Repair_IsWin95,
        _Repair_RunSetup,
        0,
    },                                  /* Repair System Files */

    {   0,
        _Repair_RepairRegedit,
        0,
    },                                  /* Rebuild Regedit */

    {   Repair_IsWin95,
        _Repair_RepairAssociations,
        0,
    },                                  /* Repair Associations */

    {   Repair_IsIE3or4,                // Busted on IE5
        _Repair_RepairJunction,
        _Repair_GetHistoryPath,
    },                                  /* Repair URL History */

    {   Repair_IsIE3,
        _Repair_RepairJunction,
        _Repair_GetCachePath,
    },                                  /* Repair Temporary Internet Files */

    {
        0,
        _Repair_RepairHotkeys,
        0,
    },                                  /* Repair hotkeys */

};

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *  Repair_GetCurSelIndex
 *
 *      Get the index of the selected item.
 *
 *****************************************************************************/

INT_PTR PASCAL
Repair_GetCurSelIndex(HWND hdlg)
{
    HWND hwnd = GetDlgItem(hdlg, IDC_REPAIRCOMBO);
    INT_PTR iItem = ComboBox_GetCurSel(hwnd);
    if (iItem >= 0) {
        return ComboBox_GetItemData(hwnd, iItem);
    } else {
        return iItem;
    }
}

/*****************************************************************************
 *
 *  Repair_OnSelChange
 *
 *      Ooh, the selection changed.
 *
 *****************************************************************************/

void PASCAL
Repair_OnSelChange(HWND hdlg)
{
    HWND hwnd = GetDlgItem(hdlg, IDC_REPAIRCOMBO);
    int dids = (int)Repair_GetCurSelIndex(hdlg);

    if (dids >= 0) {
        TCHAR tsz[1024];

        LoadString(hinstCur, IDS_REPAIRHELP+dids, tsz, cA(tsz));
        SetDlgItemText(hdlg, IDC_REPAIRHELP, tsz);
    }

}

/*****************************************************************************
 *
 *  Repair_OnInitDialog
 *
 *	Disable the shell.inf thing on NT, because NT doesn't have one.
 *
 *****************************************************************************/

BOOL PASCAL
Repair_OnInitDialog(HWND hdlg)
{
    HWND hwnd = GetDlgItem(hdlg, IDC_REPAIRCOMBO);
    int dids;

    for (dids = 0; dids < cA(c_rgri); dids++) {
        if (c_rgri[dids].CanRepair == 0 ||
            c_rgri[dids].CanRepair()) {
            TCHAR tsz[MAX_PATH];
            int iItem;

            LoadString(hinstCur, IDS_REPAIR+dids, tsz, cA(tsz));
            iItem = ComboBox_AddString(hwnd, tsz);
            ComboBox_SetItemData(hwnd, iItem, dids);
        }
    }

    ComboBox_SetCurSel(hwnd, 0);
    Repair_OnSelChange(hdlg);
    return 1;
}

/*****************************************************************************
 *
 *  Repair_OnRepairNow
 *
 *      Ooh, go repair something.
 *
 *****************************************************************************/

void PASCAL
Repair_OnRepairNow(HWND hdlg)
{
    HWND hwnd = GetDlgItem(hdlg, IDC_REPAIRCOMBO);
    int dids = (int)Repair_GetCurSelIndex(hdlg);

    if (dids >= 0) {
        UINT ids = c_rgri[dids].Repair(hdlg, c_rgri[dids].GetRepairPath);
        if (ids) {
            MessageBoxId(hdlg, ids, g_tszName, MB_OK);
        }
    }
}

/*****************************************************************************
 *
 *  Repair_OnCommand
 *
 *	Ooh, we got a command.
 *
 *****************************************************************************/

BOOL PASCAL
Repair_OnCommand(HWND hdlg, int id, UINT codeNotify)
{
    switch (id) {
    case IDC_REPAIRCOMBO:
        if (codeNotify == CBN_SELCHANGE) {
            Repair_OnSelChange(hdlg);
        }
        break;

    case IDC_REPAIRNOW:
        if (codeNotify == BN_CLICKED) {
            Repair_OnRepairNow(hdlg);
        }
    }


#if 0
    switch (id) {

    case IDC_REBUILDCACHE:
	if (codeNotify == BN_CLICKED) {
	    Misc_RebuildIcoCache();
	    MessageBoxId(hdlg, IDS_ICONSREBUILT, g_tszName, MB_OK);
	}
	break;

    case IDC_REPAIRFONTFLD:
	if (codeNotify == BN_CLICKED) {
	    if (_Repair_RepairFontFolder(hdlg)) {
		MessageBoxId(hdlg, IDS_MAYBEREBOOT, g_tszName, MB_OK);
	    }
	}
	break;

    case IDC_REPAIRREGEDIT:
	if (codeNotify == BN_CLICKED) {
	    DelPkl(&c_klRegView);
	}
	break;

    case IDC_REPAIRASSOC:
	if (codeNotify == BN_CLICKED) {
	    if (MessageBoxId(hdlg, IDS_DESKTOPRESETOK,
			     g_tszName, MB_YESNO + MB_DEFBUTTON2) == IDYES) {
		pcdii->fRunShellInf = 1;
		Common_NeedLogoff(hdlg);
		PropSheet_Apply(GetParent(hdlg));
	    }
	}
	break;

    case IDC_REPAIRDLLS:
	if (codeNotify == BN_CLICKED) {
	    if (_Repair_RunSetup(hdlg)) {
		MessageBoxId(hdlg, IDS_MAYBEREBOOT, g_tszName, MB_OK);
	    }
	}
	break;

    }
#endif
    return 0;
}

#if 0
/*****************************************************************************
 *
 *  Repair_OnNotify
 *
 *	Ooh, we got a notification.
 *
 *****************************************************************************/

BOOL PASCAL
Repair_OnNotify(HWND hdlg, NMHDR FAR *pnm)
{
    switch (pnm->code) {
    case PSN_APPLY:
	Repair_Apply(hdlg);
	break;
    }
    return 0;
}
#endif


/*****************************************************************************
 *
 *  Our window procedure.
 *
 *****************************************************************************/

/*
 * The HANDLE_WM_* macros weren't designed to be used from a dialog
 * proc, so we need to handle the messages manually.  (But carefully.)
 */

INT_PTR EXPORT
Repair_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    switch (wm) {

    case WM_INITDIALOG: return Repair_OnInitDialog(hdlg);

    case WM_COMMAND:
	return Repair_OnCommand(hdlg,
			       (int)GET_WM_COMMAND_ID(wParam, lParam),
			       (UINT)GET_WM_COMMAND_CMD(wParam, lParam));

#if 0
    case WM_NOTIFY:
	return Repair_OnNotify(hdlg, (NMHDR FAR *)lParam);
#endif

    case WM_HELP: Common_OnHelp(lParam, &rgdwHelp[0]); break;

    case WM_CONTEXTMENU: Common_OnContextMenu(wParam, &rgdwHelp[0]); break;

    default: return 0;	/* Unhandled */
    }
    return 1;		/* Handled */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tweakui\paranoia.cpp ===
/*
 * paranoia - For paranoid people
 */

#include "tweakui.h"

/*
 * OLE.
 */
#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#define END_INTERFACE
#endif

#include <urlhist.h>

#pragma BEGIN_CONST_DATA

KL const c_klParanoia = { &g_hkCUSMWCV, c_tszAppletTweakUI, c_tszParanoia };
KL const c_klAudioPlay = { &c_hkCR, c_tszAudioCDBSShell, 0 };
KL const c_klNoAutorun =
    { &g_hkCUSMWCV, c_tszRestrictions, c_tszNoDriveTypeAutoRun };
KL const c_klFault = { &g_hkLMSMWCV, c_tszFault, c_tszLogFile };
KL const c_klHistoryDir = { &g_hkLMSMIE, c_tszMain, c_tszHistoryDir };

KL const c_klLastUser = { &c_hkLM, c_tszNetLogon, c_tszUserName };
KL const c_klNukeUser = { &g_hkLMSMWNTCV, c_tszWinlogon, c_tszDontDisplayLast };

GUID const CLSID_CUrlHistory = {
   0x3C374A40, 0xBAE4, 0x11CF, 0xBF, 0x7D, 0x00, 0xAA, 0x00, 0x69, 0x46, 0xEE
};

IID const IID_IUrlHistoryStg = {
   0x3C374A41, 0xBAE4, 0x11CF, 0xBF, 0x7D, 0x00, 0xAA, 0x00, 0x69, 0x46, 0xEE
};

const static DWORD CODESEG rgdwHelp[] = {
	IDC_CLEARGROUP,		IDH_GROUP,
        IDC_LISTVIEW,           IDH_CLEARLV,
	IDC_CLEARNOW,		IDH_CLEARNOW,
	IDC_CDROMGROUP,		IDH_GROUP,
	IDC_CDROMAUDIO,		IDH_CDROMAUDIO,
	IDC_CDROMDATA,		IDH_CDROMDATA,
	IDC_FAULTLOG,		IDH_FAULTLOG,
	0,			0,
};

#pragma END_CONST_DATA

/*
 *  Paranoia flags.
 *
 *  These must be less than 64K because we overload the lParam of
 *  the checklist structure; if it is above 64K, then it's treated
 *  as a function.
 */
#define pflRun        0x0001
#define pflFindDocs   0x0002
#define pflFindComp   0x0004
#define pflDoc        0x0008
#define pflUrl        0x0010
#define pflNetUse     0x0020
#define pflTelnet     0x0040
#define pflToDisk     0x7FFF    /* The flags that get written to disk */
#define pflNukeUser   0x8000    /* Never actually written */

typedef UINT PFL;

typedef PFL (PASCAL *CANCHANGEPROC)(void);

/*****************************************************************************
 *
 *  Paranoia_IsIEInstalled
 *
 *      Returns nonzero if IE3 is installed.
 *
 *****************************************************************************/

PFL PASCAL
Paranoia_IsIEInstalled(void)
{
    if (g_hkCUSMIE) {
        return pflUrl;
    } else {
        return 0;
    }
}

/*****************************************************************************
 *
 *  Paranoia_CanNukeUser
 *
 *      Returns nonzero if the user has permission to mess with the
 *      network logon key.
 *
 *****************************************************************************/

BOOL PASCAL
Paranoia_CanNukeUser(void)
{
    if (RegCanModifyKey(g_hkLMSMWNTCV, c_tszWinlogon)) {
        return pflNukeUser;
    } else {
        return 0;
    }
}

/*****************************************************************************
 *
 *  Paranoia_GetPfl
 *
 *      Extract a PFL bit from a PFL.  If the corresponding PFL is not
 *      supported, then return -1.
 *
 *      lParam is the pfl bit to test (or the CANCHANGE function).
 *
 *      pvRef is the pfl value to test.
 *
 *****************************************************************************/

BOOL PASCAL
Paranoia_GetPfl(LPARAM lParam, LPVOID pvRef)
{
    PFL pfl = PtrToUlong(pvRef);
    PFL pflTest = (PFL)lParam;

    if (HIWORD(lParam)) {
        CANCHANGEPROC CanChange = (CANCHANGEPROC)lParam;
        pflTest = CanChange();
    }

    if (pflTest) {
        if (pfl & pflTest) {
            return 1;
        } else {
            return 0;
        }
    } else {
        return -1;
    }
}

/*****************************************************************************
 *
 *  Paranoia_SetPfl
 *
 *      Set a PFL bit in a PFL.
 *
 *      lParam is the pfl bit to test (or the CANCHANGE function).
 *
 *      pvRef is the pfl value receive the bit.
 *
 *****************************************************************************/

BOOL PASCAL
Paranoia_SetPfl(BOOL f, LPARAM lParam, LPVOID pvRef)
{
    PFL *ppfl = (PFL *)pvRef;
    PFL pflTest = (PFL)lParam;

    if (HIWORD(lParam)) {
        CANCHANGEPROC CanChange = (CANCHANGEPROC)lParam;
        pflTest = CanChange();
    }

    /*
     *  Note that the right thing happens if pflTest == 0
     *  (i.e., nothing).
     */
    if (f) {
        *ppfl |= pflTest;
    }
    return TRUE;
}

#pragma BEGIN_CONST_DATA

/*
 *  Note that this needs to be in sync with the IDS_PARANOIA
 *  strings.
 */
CHECKLISTITEM c_rgcliParanoia[] = {
    { Paranoia_GetPfl,  Paranoia_SetPfl, pflRun, },
    { Paranoia_GetPfl,  Paranoia_SetPfl, pflFindDocs, },
    { Paranoia_GetPfl,  Paranoia_SetPfl, pflFindComp, },
    { Paranoia_GetPfl,  Paranoia_SetPfl, pflDoc, },
    { Paranoia_GetPfl,  Paranoia_SetPfl, (LPARAM)Paranoia_IsIEInstalled, },
    { Paranoia_GetPfl,  Paranoia_SetPfl, pflNetUse, },
    { Paranoia_GetPfl,  Paranoia_SetPfl, (LPARAM)Paranoia_CanNukeUser, },
    { Paranoia_GetPfl,  Paranoia_SetPfl, pflTelnet, },
};

#pragma END_CONST_DATA


/*****************************************************************************
 *
 *  Paranoia_ClearUrl
 *
 *	Clear the IE URL history.
 *
 *****************************************************************************/

void PASCAL
Paranoia_ClearUrl(void)
{
    IUrlHistoryStg *phst;
    HRESULT hres;

    RegDeleteKey(g_hkCUSMIE, c_tszTypedURLs);

    /*
     *	Also wipe out the MSN URL history.
     *
     *  Note that MSNVIEWER ignores the WM_SETTINGCHANGE message, so
     *  there is nothing we can do to tell it "Hey, I dorked your regkeys!"
     */
    RegDeleteKey(c_hkCU, c_tszMSNTypedURLs);

    /*
     *  Tell the IE address bar that its history has been wiped.
     *
     *  Note that this cannot be a SendNotifyMessage since it contains
     *  a string.
     */
    SendMessage(HWND_BROADCAST, WM_SETTINGCHANGE, 0, (LPARAM)c_tszIETypedURLs);

    /*
     *	We yielded during that broadcast.  Put the hourglass back.
     */
    SetCursor(LoadCursor(0, IDC_WAIT));

    /*
     *	Now wipe the history cache.
     */
    hres = mit.SHCoCreateInstance(0, &CLSID_CUrlHistory, 0, IID_IUrlHistoryStg,
				  (PPV)&phst);
    if (SUCCEEDED(hres)) {
	IEnumSTATURL *peurl;
	hres = phst->EnumUrls(&peurl);
	if (SUCCEEDED(hres)) {
	    STATURL su;
	    su.cbSize = cbX(su);

	    while (peurl->Next(1, &su, 0) == S_OK) {
		phst->DeleteUrl(su.pwcsUrl, 0);
		Ole_Free(su.pwcsUrl);
		if (su.pwcsTitle) {
		    Ole_Free(su.pwcsTitle);
		}
	    }

	    Ole_Release(peurl);
	}

	Ole_Release(phst);
    } else {
	/*
	 *  Couldn't do it via OLE.  Do it by brute force.
	 */
	TCHAR tszPath[MAX_PATH];
        GetStrPkl(tszPath, cbX(tszPath), &c_klHistoryDir);
	if (tszPath[0]) {
	    EmptyDirectory(tszPath, 0, 0);
	}
    }
}

/*****************************************************************************
 *
 *  Paranoia_ClearTelnet
 *
 *      Clear the telnet history.
 *
 *****************************************************************************/

LPCTSTR c_rgptszValD[] = {
    c_tszMachineD,              /* Machine1 through Machine8 */
    c_tszServiceD,              /* Service1 through Service8 */
    c_tszTermTypeD,             /* TermType1 through TermType8 */
};

void PASCAL
Paranoia_ClearTelnet(void)
{
    HKEY hk;

    if (_RegOpenKey(HKEY_CURRENT_USER, c_tszTelnet, &hk) == 0) {
        int i;
        for (i = 1; i <= 8; i++) {
            int iptsz;
            for (iptsz = 0; iptsz < cA(c_rgptszValD); iptsz++) {
                TCHAR tszValue[64];
                wsprintf(tszValue, c_rgptszValD[iptsz], i);
                RegDeleteValue(hk, tszValue);
            }
        }

        /*
         *  And then the LastMumble items.
         */
        RegDeleteValue(hk, c_tszLastMachine);
        RegDeleteValue(hk, c_tszLastService);
        RegDeleteValue(hk, c_tszLastTermType);

        RegCloseKey(hk);
    }
}

/*****************************************************************************
 *
 *  Paranoia_ClearNow
 *
 *	Clear the things that the pfl says.
 *
 *	The logon goo is kept in a separate registry key, so we pass it
 *	separately.
 *
 *      The telnet goo is weird, so we do that separately, too.
 *
 *****************************************************************************/

void PASCAL
Paranoia_ClearNow(PFL pfl)
{
    HCURSOR hcurPrev = GetCursor();

    SetCursor(LoadCursor(0, IDC_WAIT));

    if (pfl & pflRun) {
	RegDeleteValues(pcdii->hkCUExplorer, c_tszRunMRU);
    }
    if (pfl & pflFindDocs) {
	RegDeleteValues(pcdii->hkCUExplorer, c_tszFindDocsMRU);
    }
    if (pfl & pflFindComp) {
	RegDeleteValues(pcdii->hkCUExplorer, c_tszFindCompMRU);
    }
    if (pfl & pflDoc) {
	SHAddToRecentDocs(0, 0);
    }
    if (pfl & pflUrl) {
	if (g_hkCUSMIE && g_hkLMSMIE) {
	    Paranoia_ClearUrl();
	}
    }

    if (pfl & pflNetUse) {
        if (g_fNT) {
            RegDeleteValues(hkCU, c_tszNetHistoryNT);
        } else {
            RegDeleteKey(hkCU, c_tszNetHistory95);
        }
    }

    if (!g_fNT && (pfl & pflNukeUser)) {
	DelPkl(&c_klLastUser);
    }

    if (pfl & pflTelnet) {
        Paranoia_ClearTelnet();
    }

    SetCursor(hcurPrev);
}

/*****************************************************************************
 *
 *  Paranoia_GetDlgPfl
 *
 *	Compute the pfl for the dialog box.
 *
 *****************************************************************************/

PFL PASCAL
Paranoia_GetDlgPfl(HWND hdlg)
{
    PFL pfl;

    pfl = 0;
    Checklist_OnApply(hdlg, c_rgcliParanoia, &pfl, TRUE);

    return pfl;
}

/*****************************************************************************
 *
 *  Paranoia_GetRegPfl
 *
 *	Compute the pfl from the registry.
 *
 *****************************************************************************/

PFL PASCAL
Paranoia_GetRegPfl(void)
{
    PFL pfl;

    pfl = GetIntPkl(0, &c_klParanoia);
    if (GetIntPkl(0, &c_klNukeUser)) {
        pfl |= pflNukeUser;
    }
    return pfl;
}

/*****************************************************************************
 *
 *  Paranoia_CoverTracks
 *
 *****************************************************************************/

void PASCAL
Paranoia_CoverTracks(void)
{
    Paranoia_ClearNow(Paranoia_GetRegPfl());
}

/*****************************************************************************
 *
 *  Paranoia_OnWhatsThis
 *
 *****************************************************************************/

void PASCAL
Paranoia_OnWhatsThis(HWND hwnd, int iItem)
{
    LV_ITEM lvi;

    Misc_LV_GetItemInfo(hwnd, &lvi, iItem, LVIF_PARAM);

    WinHelp(hwnd, c_tszMyHelp, HELP_CONTEXTPOPUP,
            IDH_CLEARRUN + lvi.lParam);
}


/*****************************************************************************
 *
 *  Paranoia_OnCommand
 *
 *	Ooh, we got a command.
 *
 *****************************************************************************/

void PASCAL
Paranoia_OnCommand(HWND hdlg, int id, UINT codeNotify)
{
    switch (id) {
    case IDC_CLEARNOW:
	if (codeNotify == BN_CLICKED) {
	    PFL pfl = Paranoia_GetDlgPfl(hdlg);
            if (pfl) {
                Paranoia_ClearNow(pfl);
	    } else {
		MessageBoxId(hdlg, IDS_NOTHINGTOCLEAR, g_tszName, MB_OK);
	    }
	}
	break;

    case IDC_CDROMAUDIO:
    case IDC_CDROMDATA:
    case IDC_FAULTLOG:
	if (codeNotify == BN_CLICKED) Common_SetDirty(hdlg);
	break;

    }

}

/*****************************************************************************
 *
 *  Paranoia_OnInitDialog
 *
 *  Audio CD play is enabled if HKCR\AudioCD\shell = "play".
 *
 *  Fault logging is disabled on NT.
 *
 *****************************************************************************/

BOOL PASCAL
Paranoia_OnInitDialog(HWND hwnd)
{
    PFL pfl;
    HWND hdlg = GetParent(hwnd);
    TCHAR tsz[MAX_PATH];

    pfl = Paranoia_GetRegPfl();
    Checklist_OnInitDialog(hwnd, c_rgcliParanoia, cA(c_rgcliParanoia),
                           IDS_PARANOIA, IntToPtr(pfl));

    GetStrPkl(tsz, cbX(tsz), &c_klAudioPlay);
    CheckDlgButton(hdlg, IDC_CDROMAUDIO,     tsz[0]		? 1 : 0);

    CheckDlgButton(hdlg, IDC_CDROMDATA,
	(GetDwordPkl(&c_klNoAutorun, 0) & (1 << DRIVE_CDROM)) ? 0 : 1);

    if (g_fNT) {
	UINT id;
	for (id = IDC_PARANOIA95ONLYMIN; id < IDC_PARANOIA95ONLYMAX; id++) {
	    ShowWindow(GetDlgItem(hdlg, id), SW_HIDE);
	}
    } else {
	TCHAR tszPath[MAX_PATH];
	CheckDlgButton(hdlg, IDC_FAULTLOG,
		       GetStrPkl(tszPath, cbX(tszPath), &c_klFault));
    }

    return 1;
}

/*****************************************************************************
 *
 *  Paranoia_OnApply
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

TCHAR c_tszFaultLog[] = TEXT("FAULTLOG.TXT");

#pragma END_CONST_DATA

void PASCAL
Paranoia_OnApply(HWND hdlg)
{
    DWORD fl;
    PFL pfl;

    pfl = Paranoia_GetDlgPfl(hdlg);
    SetIntPkl(pfl & pflToDisk, &c_klParanoia);
    SetIntPkl((pfl & pflNukeUser) != 0, &c_klNukeUser);

    SetStrPkl(&c_klAudioPlay, IsDlgButtonChecked(hdlg, IDC_CDROMAUDIO)
						    ? c_tszPlay : c_tszNil);

    fl = GetDwordPkl(&c_klNoAutorun, 0) & ~(1 << DRIVE_CDROM);
    if (!IsDlgButtonChecked(hdlg, IDC_CDROMDATA)) {
	fl |= (1 << DRIVE_CDROM);
    }
    SetDwordPkl(&c_klNoAutorun, fl);

    if (!g_fNT) {
	if (IsDlgButtonChecked(hdlg, IDC_FAULTLOG)) {
	    TCHAR tszPath[MAX_PATH];
	    GetWindowsDirectory(tszPath, cA(tszPath) - cA(c_tszFaultLog));
	    lstrcatnBs(tszPath, c_tszFaultLog, cA(tszPath));
	    SetStrPkl(&c_klFault, tszPath);
	} else {
	    DelPkl(&c_klFault);
	}
    }
}

#if 0
/*****************************************************************************
 *
 *  Paranoia_OnNotify
 *
 *	Ooh, we got a notification.
 *
 *****************************************************************************/

BOOL PASCAL
Paranoia_OnNotify(HWND hdlg, NMHDR FAR *pnm)
{
    switch (pnm->code) {
    case PSN_APPLY:
	Paranoia_Apply(hdlg);
	break;
    }
    return 0;
}

/*****************************************************************************
 *
 *  Our window procedure.
 *
 *****************************************************************************/

/*
 * The HANDLE_WM_* macros weren't designed to be used from a dialog
 * proc, so we need to handle the messages manually.  (But carefully.)
 */

BOOL EXPORT
Paranoia_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    switch (wm) {

    case WM_INITDIALOG: return Paranoia_OnInitDialog(hdlg);

    case WM_COMMAND:
	Paranoia_OnCommand(hdlg,
		          (int)GET_WM_COMMAND_ID(wParam, lParam),
		          (UINT)GET_WM_COMMAND_CMD(wParam, lParam));
        return 0;

    case WM_NOTIFY:
	return Paranoia_OnNotify(hdlg, (NMHDR FAR *)lParam);

    case WM_HELP: Common_OnHelp(lParam, &rgdwHelp[0]); break;

    case WM_CONTEXTMENU: Common_OnContextMenu(wParam, &rgdwHelp[0]); break;

    default: return 0;	/* Unhandled */
    }
    return 1;		/* Handled */
}
#endif

/*****************************************************************************
 *
 *  Oh yeah, we need this too.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

LVCI lvciParanoia[] = {
    { IDC_WHATSTHIS,        Paranoia_OnWhatsThis },
    { 0,                    0 },
};

LVV lvvParanoia = {
    Paranoia_OnCommand,
    0,                          /* Paranoia_OnInitContextMenu */
    0,                          /* Paranoia_Dirtify */
    0,                          /* Paranoia_GetIcon */
    Paranoia_OnInitDialog,
    Paranoia_OnApply,
    0,                          /* Paranoia_OnDestroy */
    0,                          /* Paranoia_OnSelChange */
    5,                          /* iMenu */
    rgdwHelp,
    0,                          /* Double-click action */
    lvvflCanCheck,              /* We need check boxes */
    lvciParanoia,
};

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *  Our window procedure.
 *
 *****************************************************************************/

INT_PTR EXPORT
Paranoia_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    return LV_DlgProc(&lvvParanoia, hdlg, wm, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tweakui\strings.h ===
/* DON'T EDIT ANYTHING AFTER THIS POINT; IT WILL BE NUKED BY THE PERL SCRIPT */
#define c_tszNetHistoryNT (c_rgtchCommon + 0)
#define c_tszFormatRundllNT (c_rgtchCommon + 76)
#define c_tszFormatRundll (c_rgtchCommon + 151)
#define c_tszIE4RegKeyChange (c_rgtchCommon + 213)
#define c_tszIETypedURLs (c_rgtchCommon + 264)
#define c_tszSMWNTCV (c_rgtchCommon + 311)
#define c_tszSMWCV (c_rgtchCommon + 356)
#define c_tszClsidPrint (c_rgtchCommon + 398)
#define c_tszClsidCpl (c_rgtchCommon + 437)
#define c_tszClsidNetHood (c_rgtchCommon + 476)
#define c_tszSMWIE (c_rgtchCommon + 515)
#define c_tszCmdPath (c_rgtchCommon + 552)
#define c_tszMetrics (c_rgtchCommon + 589)
#define c_tszFixAutoLogon (c_rgtchCommon + 625)
#define c_tszFixLink (c_rgtchCommon + 661)
#define c_tszMSNTypedURLs (c_rgtchCommon + 696)
#define c_tszUrlHist (c_rgtchCommon + 729)
#define c_tszIECache (c_rgtchCommon + 759)
#define c_tszTelnet (c_rgtchCommon + 789)
#define c_tszRegPathAppearance (c_rgtchCommon + 815)
#define c_tszTempInet (c_rgtchCommon + 840)
#define c_tszDontDisplayLast (c_rgtchCommon + 865)
#define c_tszClearRecentDocsOnExit (c_rgtchCommon + 889)
#define c_tszNoActiveDesktopChanges (c_rgtchCommon + 912)
#define c_tszRegPathDesktop (c_rgtchCommon + 935)
#define c_tszNoRegedit (c_rgtchCommon + 957)
#define c_tszCplColors (c_rgtchCommon + 978)
#define c_tszPathShellFolder (c_rgtchCommon + 999)
#define c_tszPaintDesktop (c_rgtchCommon + 1020)
#define c_tszUseDoubleClickTimer (c_rgtchCommon + 1040)
#define c_tszNoRecentDocsHistory (c_rgtchCommon + 1060)
#define c_tszNoDriveTypeAutoRun (c_rgtchCommon + 1080)
#define c_tszDirComp (c_rgtchCommon + 1099)
#define c_tszUserShellFolders (c_rgtchCommon + 1118)
#define c_tszExplorerAdvanced (c_rgtchCommon + 1137)
#define c_tszDesktopNameSpace (c_rgtchCommon + 1155)
#define c_tszRestrictions (c_rgtchCommon + 1173)
#define c_tszHistoryDir (c_rgtchCommon + 1191)
#define c_tszUninstallTweakUI (c_rgtchCommon + 1209)
#define c_tszFindDocsMRU (c_rgtchCommon + 1227)
#define c_tszNoRecentDocsMenu (c_rgtchCommon + 1245)
#define c_tszSubVersion (c_rgtchCommon + 1262)
#define c_tszHotTrackColor (c_rgtchCommon + 1279)
#define c_tszFindCompMRU (c_rgtchCommon + 1296)
#define c_tszRegedit (c_rgtchCommon + 1312)
#define c_tszAppletTweakUI (c_rgtchCommon + 1328)
#define c_tszShellIconSize (c_rgtchCommon + 1344)
#define c_tszUninstallString (c_rgtchCommon + 1360)
#define c_tszDefaultPassword (c_rgtchCommon + 1376)
#define c_tszProgramFilesDir (c_rgtchCommon + 1392)
#define c_tszDefaultUserName (c_rgtchCommon + 1408)
#define c_tszNoFavoritesMenu (c_rgtchCommon + 1424)
#define c_tszPoliciesSystem (c_rgtchCommon + 1440)
#define c_tszNoActiveDesktop (c_rgtchCommon + 1456)
#define c_tszInfBsTweakuiInf (c_rgtchCommon + 1472)
#define c_tszCommonFilesDir (c_rgtchCommon + 1488)
#define c_tszAutoLogon (c_rgtchCommon + 1503)
#define c_tszNoInternetIcon (c_rgtchCommon + 1518)
#define c_tszNetHistory95 (c_rgtchCommon + 1533)
#define c_tszFileComp (c_rgtchCommon + 1103)
#define c_tszNoExitSave (c_rgtchCommon + 1548)
#define c_tszNoBanner (c_rgtchCommon + 1563)
#define c_tszNetLogon (c_rgtchCommon + 1577)
#define c_tszBootMenuDelay (c_rgtchCommon + 1591)
#define c_tszDelay (c_rgtchCommon + 1605)
#define c_tszAudioCDBSShell (c_rgtchCommon + 1619)
#define c_tszInfBsShellInf (c_rgtchCommon + 1633)
#define c_tszLastTermType (c_rgtchCommon + 1647)
#define c_tszCustomColors (c_rgtchCommon + 1660)
#define c_tszBSDesktopIni (c_rgtchCommon + 1673)
#define c_tszTimeDateCpl (c_rgtchCommon + 1686)
#define c_tszComCtl32Dll (c_rgtchCommon + 1699)
#define c_tszSmoothScroll (c_rgtchCommon + 1712)
#define c_tszClassicShell (c_rgtchCommon + 1725)
#define c_tszShellIcons (c_rgtchCommon + 1738)
#define c_tszWininit (c_rgtchCommon + 1750)
#define c_tszLastService (c_rgtchCommon + 1762)
#define c_tszLastMachine (c_rgtchCommon + 1774)
#define c_tszDisplayDrv (c_rgtchCommon + 1786)
#define c_tszDisplayName (c_rgtchCommon + 1798)
#define c_tszControlIni (c_rgtchCommon + 1810)
#define c_tszShell32Dll (c_rgtchCommon + 1822)
#define c_tszMyHelp (c_rgtchCommon + 1834)
#define c_tszRunServices (c_rgtchCommon + 1846)
#define c_tszTweakUICpl (c_rgtchCommon + 1858)
#define c_tszTermTypeD (c_rgtchCommon + 1870)
#define c_tszAppWizCpl (c_rgtchCommon + 1881)
#define c_tszStartMenu (c_rgtchCommon + 1892)
#define c_tszSysIni (c_rgtchCommon + 1903)
#define c_tszDontLoad (c_rgtchCommon + 1914)
#define c_tszSourcePath (c_rgtchCommon + 1925)
#define c_tszAttributes (c_rgtchCommon + 1936)
#define c_tszServiceD (c_rgtchCommon + 1947)
#define c_tszSearchUrl (c_rgtchCommon + 1957)
#define c_tszDirectory (c_rgtchCommon + 1199)
#define c_tszFavorites (c_rgtchCommon + 1967)
#define c_tszTemplates (c_rgtchCommon + 1977)
#define c_tszUninstall (c_rgtchCommon + 1987)
#define c_tszMachineD (c_rgtchCommon + 1997)
#define c_tszShellNewDash (c_rgtchCommon + 2007)
#define c_tszBootDelay (c_rgtchCommon + 2017)
#define c_tszSetupExe (c_rgtchCommon + 2027)
#define c_tszBootMulti (c_rgtchCommon + 2037)
#define c_tszNoNetHood (c_rgtchCommon + 2047)
#define c_tszTypedURLs (c_rgtchCommon + 719)
#define c_tszPersonal (c_rgtchCommon + 2057)
#define c_tszPrograms (c_rgtchCommon + 2066)
#define c_tszShellNew (c_rgtchCommon + 2075)
#define c_tszExplorer (c_rgtchCommon + 543)
#define c_tszNullFile (c_rgtchCommon + 2084)
#define c_tszKernel32 (c_rgtchCommon + 2093)
#define c_tszFileName (c_rgtchCommon + 2102)
#define c_tszWinlogon (c_rgtchCommon + 2111)
#define c_tszIntlCpl (c_rgtchCommon + 2120)
#define c_tszBootKeys (c_rgtchCommon + 2129)
#define c_tszBootMenu (c_rgtchCommon + 2138)
#define c_tszNoLogoff (c_rgtchCommon + 2147)
#define c_tszNoDrives (c_rgtchCommon + 2156)
#define c_tszUserName (c_rgtchCommon + 880)
#define c_tszAutoScan (c_rgtchCommon + 2165)
#define c_tszDeskCpl (c_rgtchCommon + 2174)
#define c_tszMainCpl (c_rgtchCommon + 2183)
#define c_tszAltColor (c_rgtchCommon + 2192)
#define c_tszLogFile (c_rgtchCommon + 2201)
#define c_tszStartup (c_rgtchCommon + 2209)
#define c_tszDesktop (c_rgtchCommon + 949)
#define c_tszBootGUI (c_rgtchCommon + 2217)
#define c_tszOptions (c_rgtchCommon + 2225)
#define c_tszXgaDrv (c_rgtchCommon + 2233)
#define c_tszVersion (c_rgtchCommon + 390)
#define c_tszWindows (c_rgtchCommon + 2241)
#define c_tszHistory (c_rgtchCommon + 1072)
#define c_tszCommand (c_rgtchCommon + 2249)
#define c_tszWinDir (c_rgtchCommon + 2257)
#define c_tszRename (c_rgtchCommon + 2264)
#define c_tszSendTo (c_rgtchCommon + 2271)
#define c_tszRunMRU (c_rgtchCommon + 2278)
#define c_tszRecent (c_rgtchCommon + 1541)
#define c_tszPaths (c_rgtchCommon + 783)
#define c_tszMapSL (c_rgtchCommon + 2285)
#define c_tszClsid (c_rgtchCommon + 2291)
#define c_tszSCommaU (c_rgtchCommon + 2297)
#define c_tszStarCpl (c_rgtchCommon + 2303)
#define c_tszSetup (c_rgtchCommon + 2309)
#define c_tszBangLnk (c_rgtchCommon + 2315)
#define c_tszFault (c_rgtchCommon + 2321)
#define c_tszData (c_rgtchCommon + 2327)
#define c_tszView (c_rgtchCommon + 2332)
#define c_tszMain (c_rgtchCommon + 2337)
#define c_tszPlay (c_rgtchCommon + 2342)
#define c_tszLink (c_rgtchCommon + 2347)
#define c_tszTips (c_rgtchCommon + 2352)
#define c_tszLogo (c_rgtchCommon + 2357)
#define c_tszBoot (c_rgtchCommon + 2362)
#define c_tszDotBak (c_rgtchCommon + 2367)
#define c_tszDotLnk (c_rgtchCommon + 2316)
#define c_tszDotInf (c_rgtchCommon + 1642)
#define c_tszShow (c_rgtchCommon + 2372)
#define c_tszRun (c_rgtchCommon + 1095)
#define c_tszExe (c_rgtchCommon + 2033)
#define c_tszUni (c_rgtchCommon + 2377)
#define c_tszPercentU (c_rgtchCommon + 2300)
#define c_tszNo (c_rgtchCommon + 2381)
#define c_tszLinkOvl (c_rgtchCommon + 2384)
#define c_tszHackPtui (c_rgtchCommon + 2387)
#define c_tszDot (c_rgtchCommon + 2389)
#define c_tszBang (c_rgtchCommon + 2391)
#define c_tszI (c_rgtchCommon + 1760)
#define c_tszBackslash (c_rgtchCommon + 2393)
#define c_tszParanoia (c_rgtchCommon + 2395)
#define c_tszNil (c_rgtchCommon + 1455)
extern TCHAR c_rgtchCommon[2397];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tweakui\secret.cpp ===
#include "tweakui.h"

/*
 *  Win9x doesn't have ntdll.dll, but since we only need one function from
 *  it, let's just define it ourselves.
 */

void _RtlInitUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString)
{
    ULONG Length;
    DestinationString->Buffer = (PWSTR)SourceString;
    Length = lstrlenW(SourceString) * sizeof(WCHAR);
    DestinationString->Length = (USHORT)Length;
    DestinationString->MaximumLength = (USHORT)(Length + sizeof(UNICODE_NULL));
}

/*
 *  Win9x also doesn't have the Lsa functions in advapi32, so we need to
 *  GetProcAddress them on the fly.
 */

FARPROC GetAdvapi32Proc(LPCSTR pszName)
{
    return GetProcAddress(GetModuleHandle("ADVAPI32"), pszName);
}

#define DELAYLOAD_FUNCTION(fn, args, nargs)                             \
                                                                        \
NTSTATUS _##fn args                                                     \
{                                                                       \
    NTSTATUS (NTAPI *fn) args =                                         \
                           (NTSTATUS (NTAPI*)args)GetAdvapi32Proc(#fn); \
    if (fn) return fn nargs;                                            \
    return STATUS_NOT_IMPLEMENTED;                                      \
}

DELAYLOAD_FUNCTION(LsaOpenPolicy, (
    IN PLSA_UNICODE_STRING SystemName OPTIONAL,
    IN PLSA_OBJECT_ATTRIBUTES ObjectAttributes,
    IN ACCESS_MASK DesiredAccess,
    IN OUT PLSA_HANDLE PolicyHandle),
    (SystemName, ObjectAttributes, DesiredAccess, PolicyHandle))

DELAYLOAD_FUNCTION(LsaRetrievePrivateData, (
    IN LSA_HANDLE PolicyHandle,
    IN PLSA_UNICODE_STRING KeyName,
    OUT PLSA_UNICODE_STRING * PrivateData),
    (PolicyHandle, KeyName, PrivateData))

DELAYLOAD_FUNCTION(LsaStorePrivateData, (
    IN LSA_HANDLE PolicyHandle,
    IN PLSA_UNICODE_STRING KeyName,
    IN PLSA_UNICODE_STRING PrivateData),
    (PolicyHandle, KeyName, PrivateData))

DELAYLOAD_FUNCTION(LsaClose, (
    IN LSA_HANDLE ObjectHandle),
    (ObjectHandle))

DELAYLOAD_FUNCTION(LsaFreeMemory, (
    IN PVOID Buffer),
    (Buffer))

/****************************************************************************/

#define DEFAULT_PASSWORD_KEY L"DefaultPassword"



NTSTATUS
GetSecretDefaultPassword(
    LPWSTR PasswordBuffer, DWORD cchBuf
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE LsaHandle = NULL;
    UNICODE_STRING SecretName;
    PUNICODE_STRING SecretValue = NULL;



    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        0L,
        (HANDLE)NULL,
        NULL
        );

    Status = _LsaOpenPolicy(
        NULL,
        &ObjectAttributes,
        POLICY_VIEW_LOCAL_INFORMATION,
        &LsaHandle
        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    _RtlInitUnicodeString(
        &SecretName,
        DEFAULT_PASSWORD_KEY
        );

    Status = _LsaRetrievePrivateData(
                LsaHandle,
                &SecretName,
                &SecretValue
                );
    if (!NT_SUCCESS(Status)) {
        _LsaClose(LsaHandle);
        return Status;
    }

    DWORD cchSecret = SecretValue->Length / sizeof(WCHAR); // does not include terminator
    lstrcpynW(PasswordBuffer, SecretValue->Buffer, min(cchBuf, cchSecret+1));

    if (SecretValue->Buffer != NULL) {
        _LsaFreeMemory(SecretValue->Buffer);
    }
    _LsaFreeMemory(SecretValue);

    _LsaClose(LsaHandle);

    return STATUS_SUCCESS;
}


NTSTATUS
SetSecretDefaultPassword(
    LPWSTR PasswordBuffer
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE LsaHandle = NULL;
    UNICODE_STRING SecretName;
    UNICODE_STRING SecretValue;



    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        0L,
        (HANDLE)NULL,
        NULL
        );

    Status = _LsaOpenPolicy(
        NULL,
        &ObjectAttributes,
        POLICY_CREATE_SECRET,
        &LsaHandle
        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    _RtlInitUnicodeString(
        &SecretName,
        DEFAULT_PASSWORD_KEY
        );

    _RtlInitUnicodeString(
        &SecretValue,
        PasswordBuffer
        );

    Status = _LsaStorePrivateData(
        LsaHandle,
        &SecretName,
        &SecretValue
        );
    if (!NT_SUCCESS(Status)) {
        _LsaClose(LsaHandle);
        return Status;
    }

    _LsaClose(LsaHandle);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tweakui\tools.cpp ===
/*
 * template - Dialog box property sheet for "Templates"
 */

#include "tweakui.h"

#define ctchProgMax 80

#pragma BEGIN_CONST_DATA

const static DWORD CODESEG rgdwHelp[] = {
	IDC_TEMPLATETEXT,	IDH_TEMPLATE,
	IDC_TEMPLATE,		IDH_TEMPLATE,
	IDC_LVDELETE,		IDH_TEMPLATEDEL,
	0,			0,
};

#pragma END_CONST_DATA

typedef struct TI {		/* ti - template info */
    BYTE isi;			/* Index to state icon */
    HKEY hkRoot;		/* Root for locating the key */
				/* HKCR or HKCR\CLSID */
    TCH tszExt[10];		/* Filename extension (for icon refresh) */
    TCH tszKey[ctchKeyMax + 6];	/* 6 = strlen("\\CLSID") */
} TI, *PTI;

#define itiPlvi(plvi) ((UINT)(plvi)->lParam)
#define ptiIti(iti) (&ptdii->pti[iti])
#define ptiPlvi(plvi) ptiIti(itiPlvi(plvi))

typedef struct TDII {
    Declare_Gxa(TI, ti);
    WNDPROC wpTemplate;
    BOOL fRundll;		/* Need to run Rundll on Apply */
} TDII, *PTDII;

TDII tdii;
#define ptdii (&tdii)

/*****************************************************************************
 *
 *  ptszStrRChr
 *
 *	Get the rightmost occurrence.
 *
 *****************************************************************************/

PTSTR PASCAL
ptszStrRChr(PCTSTR ptsz, TCH tch)
{
    PTSTR ptszRc = 0;
    for (ptsz = ptszStrChr(ptsz, tch); ptsz; ptsz = ptszStrChr(ptsz + 1, tch)) {
	ptszRc = (PTSTR)ptsz;
    }
    return ptszRc;
}

/*****************************************************************************
 *
 *  ptszFilenameCqn
 *
 *	Get the filename part of a cqn.
 *
 *****************************************************************************/

PTSTR PASCAL
ptszFilenameCqn(PCTSTR cqn)
{
    PTSTR ptsz = ptszStrRChr(cqn, TEXT('\\'));
    return ptsz ? ptsz + 1 : (PTSTR)cqn;
}

/*****************************************************************************
 *
 *  Path_Append
 *
 *      Append a filename to a directory, inserting a backslash
 *      as necessary.
 *
 *****************************************************************************/

void
Path_Append(LPTSTR ptszDir, LPCTSTR ptszFile)
{
    ptszDir = TweakUi_TrimTrailingBs(ptszDir);
    *ptszDir++ = TEXT('\\');
    lstrcpy(ptszDir, ptszFile);

}
/*****************************************************************************
 *
 *  Template_NudgeExplorer
 *
 *  Explorer doesn't recognize changes to templates until an application
 *  terminates, so we simply execute Rundll spuriously.  It realizes that
 *  there is nothing to do and exits.  This exit triggers Explorer to
 *  rebuild the filename extension list.
 *
 *  This nudge doesn't work on NT 5, so we also have to nuke the
 *  ShellNew cache.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA
ConstString(c_tszRundll, "rundll32");
#pragma END_CONST_DATA

void PASCAL
Template_NudgeExplorer(void)
{
    WinExec(c_tszRundll, SW_HIDE);

    RegDeleteTree(g_hkCUSMWCV, TEXT("Explorer\\Discardable\\PostSetup\\ShellNew"));
}

/*****************************************************************************
 *
 *  Template_SubkeyExists
 *
 *****************************************************************************/

BOOL PASCAL
Template_SubkeyExists(HKEY hk, PCTSTR ptszSubkey)
{
    return GetRegStr(hk, 0, ptszSubkey, 0, 0);
}

/*****************************************************************************
 *
 *  Template_AddTemplateInfo
 *
 *  pti must be the next ti in the array (i.e., Misc_AllocPx)
 *
 *  Returns the icon index, if successful, or -1 on error.
 *
 *****************************************************************************/

int PASCAL
Template_AddTemplateInfo(HWND hwnd, PCTSTR ptszExt, PTI pti, BOOL fCheck)
{
    int iRc;
    SHFILEINFO sfi;
    if (SHGetFileInfo(ptszExt, 0, &sfi, cbX(sfi),
	SHGFI_TYPENAME | SHGFI_USEFILEATTRIBUTES |
	SHGFI_SYSICONINDEX | SHGFI_SMALLICON)) {
	pti->isi = fCheck + 1;
	iRc = LV_AddItem(hwnd, ptdii->cti++, sfi.szTypeName, sfi.iIcon, fCheck);
    } else {
	iRc = -1;
    }
    return iRc;
}

/*****************************************************************************
 *
 *  TemplateCallbackInfo
 *
 *  Information handed to a template callback.
 *
 *  hk - The ptszShellNew subkey itself
 *
 *****************************************************************************/

typedef BOOL (PASCAL *TCICALLBACK)(struct TCI *ptci, HKEY hk,
				   PCTSTR ptszShellNew);

typedef struct TCI {
    TCICALLBACK pfn;
    PTI	pti;			/* Template info containing result */
    HWND hwnd;			/* Listview window handle */
    PCTSTR ptszExt;		/* The .ext being studied */
} TCI, *PTCI;

/*****************************************************************************
 *
 *  Template_CheckShellNew
 *
 *	Look for the ShellNew stuff (or ShellNew- if temporarily disabled).
 *
 *	Returns boolean success/failure.
 *
 *	If ptszExt exists, then we create the key, too.
 *
 *****************************************************************************/

BOOL PASCAL
Template_CheckShellNew(PTCI ptci, HKEY hkBase, PCTSTR ptszShellNew)
{
    HKEY hk;
    BOOL fRc;
    if (_RegOpenKey(hkBase, ptszShellNew, &hk) == 0) {
	if (Template_SubkeyExists(hk, c_tszNullFile) ||
	    Template_SubkeyExists(hk, c_tszFileName) ||
	    Template_SubkeyExists(hk, c_tszCommand) ||
	    Template_SubkeyExists(hk, c_tszData)) {
	    fRc = ptci->pfn(ptci, hk, ptszShellNew);
	} else {
	    fRc = 0;
	}
	RegCloseKey(hk);
    } else {
	fRc = 0;
    }
    return fRc;
}

/*****************************************************************************
 *
 *  Template_AddHkeyTemplate
 *
 *	We have a candidate location for a ShellNew.
 *
 *	There is some weirdness here.  The actual ShellNew can live at
 *	a sublevel.  For example, the ".doc" extension contains several
 *	ShellNew's:
 *
 *	HKCR\.doc = WordPad.Document.1
 *	HKCR\.doc\WordDocument\ShellNew
 *	HKCR\.doc\Word.Document.6\ShellNew
 *	HKCR\.doc\WordPad.Document.1\ShellNew
 *
 *	Based on the main value (HKCR\.doc), we choose to use the template
 *	for "Wordpad.Document.1".
 *
 *	pti->hkRoot - hkey at which to start (either HKCR or HKCR\CLSID)
 *	pti->tszKey - subkey to open (.ext or {guid})
 *
 *	pti->hkRoot\pti->tszKey = actual key to open
 *
 *	hkBase = the key at hkRoot\ptszKey
 *	hk     = the key where ShellNew actually lives
 *
 *****************************************************************************/

BOOL PASCAL
Template_AddHkeyTemplate(PTCI ptci)
{
    HKEY hkBase;
    BOOL fRc;
    PTI pti = ptci->pti;
    if (_RegOpenKey(pti->hkRoot, pti->tszKey, &hkBase) == 0) {
	TCH tszProg[ctchProgMax+1];
	if (GetRegStr(hkBase, 0, 0, tszProg, cbX(tszProg))) {
            HKEY hk = NULL;
	    if (_RegOpenKey(hkBase, tszProg, &hk) == 0) {
		lstrcatnBsA(pti->tszKey, tszProg);
	    } else {
                _RegOpenKey(hkBase, 0, &hk);    /* hk = AddRef(hkBase) */
            }
            if (hk) {
                /* Now open the ShellNew subkey or the ShellNew- subkey */
                fRc = fLorFF(Template_CheckShellNew(ptci, hk, c_tszShellNew),
                             Template_CheckShellNew(ptci, hk, c_tszShellNewDash));
                RegCloseKey(hk);
            } else {
                fRc = 0;
            }
	} else {
	    fRc = 0;
	}
    } else {
	fRc = 0;
    }
    return fRc;
}

/*****************************************************************************
 *
 *  Template_LocateExtension
 *
 *	We have a filename extension (ptci->ptszExt).
 *
 *	Get its program id (progid).
 *
 *	We look in two places.  If the progid has a registered CLSID
 *	(HKCR\progid\CLSID), then we look in HKCR\CLSID\{guid}.
 *
 *	If the CLSID fails to locate anything, then we look under
 *	HKCR\.ext directly.
 *
 *****************************************************************************/

BOOL PASCAL
Template_LocateExtension(PTCI ptci)
{
    BOOL fRc;
    PTI pti = ptci->pti = (PTI)Misc_AllocPx(&ptdii->gxa);
    if (pti) {
	TCH tszProg[ctchProgMax + ctchKeyMax + 6]; /* 6 = strlen(\\CLSID) */
	lstrcpyn(pti->tszExt, ptci->ptszExt, cA(pti->tszExt));
	if (GetRegStr(hkCR, ptci->ptszExt, 0, tszProg, cbCtch(ctchProgMax)) &&
	    tszProg[0]) {
	    /*
	     *	Make sure the progid exists, or we end up putting garbage
	     *	into the listview.
	     */
            if (RegKeyExists(hkCR, tszProg)) {

		/*
		 *  Is this an OLE class?
		 */
		lstrcatnBsA(tszProg, c_tszClsid);
		if (GetRegStr(hkCR, tszProg, 0,
			      pti->tszKey, cbX(pti->tszKey))) {
		    pti->hkRoot = pcdii->hkClsid;
		    fRc = Template_AddHkeyTemplate(ptci);
		} else {
		    fRc = 0;
		}

		/*
		 *  If we haven't succeeded yet, then try under the extension
		 *  itself.
		 */
		if (!fRc) {
		    pti->hkRoot = hkCR;
		    lstrcpyn(pti->tszKey, ptci->ptszExt, cA(pti->tszKey));
		    fRc = Template_AddHkeyTemplate(ptci);
		}
	    } else {
		fRc = 0;
	    }
	} else {
	    fRc = 0;
	}
    } else {
	fRc = 0;
    }
    return fRc;
}

/*****************************************************************************
 *
 *  Template_AddTemplates_AddMe
 *
 *	Add any templates that exist.
 *
 *	For each filename extension, get its corresponding class.
 *	Then ask Template_LocateExtension to do the rest.
 *
 *****************************************************************************/

BOOL PASCAL
Template_AddTemplates_AddMe(PTCI ptci, HKEY hk, PCTSTR ptszShellNew)
{
    return Template_AddTemplateInfo(ptci->hwnd, ptci->ptszExt,
				    ptci->pti,
				    ptszShellNew == c_tszShellNew) + 1;
}

/*****************************************************************************
 *
 *  Template_AddTemplates
 *
 *	Add any templates that exist.
 *
 *	For each filename extension, get its corresponding class.
 *	Then ask Template_LocateExtension to do the rest.
 *
 *****************************************************************************/

void PASCAL
Template_AddTemplates(HWND hwnd)
{
    int i;
    TCI tci;
    TCH tszExt[10];

    tci.pfn = Template_AddTemplates_AddMe;
    tci.hwnd = hwnd;
    tci.ptszExt = tszExt;

    HCURSOR hcurPrev = SetCursor(LoadCursor(0, IDC_WAIT));

    for (i = 0; ; i++) {
	switch (RegEnumKey(HKEY_CLASSES_ROOT, i, tszExt, cbX(tszExt))) {
	case ERROR_SUCCESS:
	    /*
	     *  Don't show ".lnk" in the templates list because it's weird.
	     */
	    if (tszExt[0] == TEXT('.') && lstrcmpi(tszExt, c_tszDotLnk)) {
		Template_LocateExtension(&tci);
	    }
	    break;

	case ERROR_MORE_DATA:		/* Can't be a .ext if > 10 */
	    break;

	default: goto endenum;
	}
    }
    endenum:;
    SetCursor(hcurPrev);
}

/*****************************************************************************
 *
 *  File template callback info
 *
 *****************************************************************************/

typedef struct FTCI {
    TCI tci;
    PCTSTR ptszSrc;
    PCTSTR ptszDst;
    PCTSTR ptszLastBS;
    PCTSTR ptszShellNew;
} FTCI, *PFTCI;

/*****************************************************************************
 *
 *  Template_CopyFile
 *
 *	Copy a file with the hourglass.
 *
 *****************************************************************************/

BOOL PASCAL
Template_CopyFile(PFTCI pftci)
{
    HCURSOR hcurPrev;
    BOOL fRc;
    hcurPrev = SetCursor(LoadCursor(0, MAKEINTRESOURCE(IDC_WAIT)));
    fRc = CopyFile(pftci->ptszSrc, pftci->ptszDst, 0);
    SetCursor(hcurPrev);
    return fRc;
}

/*****************************************************************************
 *
 *  Template_AddFileTemplate_CheckMe
 *
 *	Make sure the key isn't a Command key.
 *
 *****************************************************************************/

BOOL PASCAL
Template_AddFileTemplate_CheckMe(PTCI ptci, HKEY hk, PCTSTR ptszShellNew)
{
    PFTCI pftci = (PFTCI)ptci;
    pftci->ptszShellNew = ptszShellNew;
    if (Template_SubkeyExists(hk, c_tszCommand)) {
	ptci->ptszExt = 0;
    }
    return 1;
}

/*****************************************************************************
 *
 *  Template_IsTemplatable
 *
 *	Determine whether there is an application that can handle this
 *      extension.  We assume it's okay if the item is not self-executing.
 *
 *****************************************************************************/

BOOL PASCAL
Template_IsTemplatable(PCTSTR ptszFile)
{
    LONG cb;
    TCH tszShort[MAX_PATH];
    DWORD ctch;

    ctch = GetFullPathName(ptszFile, cA(tszShort), tszShort, NULL);
    if (ctch && ctch < MAX_PATH) {
        /* If this fails, just proceed with the value from GFPN */
        GetShortPathName(ptszFile, tszShort, cA(tszShort));

        TCH tszExe[MAX_PATH];
        if (FindExecutable(tszShort, NULL, tszExe) >= (HINSTANCE)IntToPtr(HINSTANCE_ERROR)) {
            return lstrcmpi(tszExe, tszShort) != 0;
        }
    }
    return 0;
}

/*****************************************************************************
 *
 *  Template_ReplaceTemplate
 *
 *	Replace the current template with the new one.
 *
 *****************************************************************************/

UINT PASCAL
Template_ReplaceTemplate(PFTCI pftci)
{
#define ptci (&pftci->tci)
    UINT id;
    if (ptci->ptszExt) {
	if (MessageBoxId(GetParent(ptci->hwnd), IDS_CONFIRMNEWTEMPLATE,
			 pftci->ptszSrc,
			 MB_YESNO | MB_DEFBUTTON2 | MB_SETFOREGROUND)
			== IDYES) {
	    HKEY hk;
	    lstrcatnBsA(ptci->pti->tszKey, pftci->ptszShellNew);
	    if (_RegOpenKey(ptci->pti->hkRoot, ptci->pti->tszKey, &hk) == 0) {
		if (Template_CopyFile(pftci)) {
		    RegDeleteValue(hk, c_tszNullFile);
		    RegDeleteValue(hk, c_tszData);
		    RegSetValuePtsz(hk, c_tszFileName, pftci->ptszLastBS+1);
		    id = 0;
		} else {
		    id = IDS_COPYFAIL;
		}
		RegCloseKey(hk);
	    } else {
		id = IDS_REGFAIL;
	    }
	} else {
	    id = 0;
	}
    } else {
	id = IDS_CANNOTTEMPLATE;
    }
    return id;
}
#undef ptci


/*****************************************************************************
 *
 *  Template_AddFileTemplate
 *
 *	Add the file as a new template type.
 *
 *****************************************************************************/

UINT PASCAL
Template_AddFileTemplate(HWND hwnd, PCTSTR ptszSrc)
{
#define pftci (&ftci)
    UINT id;
    FTCI ftci;
    pftci->tci.pfn = Template_AddFileTemplate_CheckMe;
    pftci->tci.hwnd = hwnd;
    pftci->ptszSrc = ptszSrc;
    pftci->ptszLastBS = ptszFilenameCqn(ptszSrc) - 1;	/* -> \filename.ext */
    if (pftci->ptszLastBS) {
	pftci->tci.ptszExt = ptszStrRChr(pftci->ptszLastBS, '.'); /* -> .ext */
	if (pftci->tci.ptszExt) {
	    HKEY hk;
	    if (_RegOpenKey(hkCR, pftci->tci.ptszExt, &hk) == 0) {
                if (Template_IsTemplatable(ptszSrc)) {
		    PTI pti;
		    TCH tszDst[MAX_PATH];
		    pftci->ptszDst = tszDst;
		    SHGetPathFromIDList(pcdii->pidlTemplates, tszDst);
		    lstrcatnBsA(tszDst, pftci->ptszLastBS+1);
		    /* Snoop at the next pti to ensure we can get it later */
		    pti = (PTI)Misc_AllocPx(&ptdii->gxa);
		    if (pti) {
			if (Template_LocateExtension(&pftci->tci)) {
			    id = Template_ReplaceTemplate(pftci);
			} else {
			    if (Template_CopyFile(pftci)) {
				HKEY hk2;
				if (RegCreateKey(hk, c_tszShellNew, &hk2) == 0) {
				    RegSetValuePtsz(hk2, c_tszFileName, pftci->ptszLastBS+1);
				    RegCloseKey(hk2);
				    Misc_LV_SetCurSel(hwnd,
					    Template_AddTemplateInfo(hwnd,
						pftci->tci.ptszExt, pti, 1));
				    Template_NudgeExplorer();
				    id = 0;	/* No problemo */
				} else {
				    id = IDS_REGFAIL;
				}
			    } else {
				id = IDS_COPYFAIL;
			    }
			}
		    } else {
			id = 0;		/* out of memory! */
		    }
		} else {
		    id = IDS_BADEXT;
		}
		RegCloseKey(hk);
	    } else {
		id = IDS_BADEXT;
	    }
	} else {
	    id = IDS_BADEXT;
	}
    } else {
	id = 0;				/* This can't happen! */
    }
    return id;
}

/*****************************************************************************
 *
 *  Tools_Template_OnDropFiles
 *
 *	Put the file into the template edit control.
 *
 *****************************************************************************/

void PASCAL
Tools_Template_OnDropFiles(HWND hwnd, HDROP hdrop)
{
    if (DragQueryFile(hdrop, (UINT)-1, 0, 0) == 1) {
	UINT id;
	TCH tszSrc[MAX_PATH];

	DragQueryFile(hdrop, 0, tszSrc, cA(tszSrc));
	id = Template_AddFileTemplate(hwnd, tszSrc);
	if (id) {
	    MessageBoxId(GetParent(hwnd), id, tszSrc, MB_OK | MB_SETFOREGROUND);
	}
    } else {
	MessageBoxId(GetParent(hwnd), IDS_TOOMANY, g_tszName,
		     MB_OK | MB_SETFOREGROUND);
    }
    DragFinish(hdrop);
}

/*****************************************************************************
 *
 *  Tools_Template_WndProc
 *
 *	Subclass procedure so we can handle drag-drop to the template
 *	edit control.
 *
 *****************************************************************************/

LRESULT EXPORT
Tools_Template_WndProc(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam)
{
    switch (wm) {
    case WM_DROPFILES:
	Tools_Template_OnDropFiles(hwnd, (HDROP)wParam);
	return 0;
    }
    return CallWindowProc(ptdii->wpTemplate, hwnd, wm, wParam, lParam);
}

/*****************************************************************************
 *
 *  Template_GetIcon
 *
 *	Produce the icon associated with an item.  This is called when
 *	we need to rebuild the icon list after the icon cache has been
 *	purged.
 *
 *****************************************************************************/

int PASCAL
Template_GetIcon(LPARAM iti)
{
    SHFILEINFO sfi;
    PTI pti = ptiIti(iti);
    sfi.iIcon = 0;
OutputDebugString(pti->tszExt);
    SHGetFileInfo(pti->tszExt, 0, &sfi, cbX(sfi),
	SHGFI_USEFILEATTRIBUTES | SHGFI_SYSICONINDEX | SHGFI_SMALLICON);
    return sfi.iIcon;
}

/*****************************************************************************
 *
 *  Template_OnInitDialog
 *
 *  Turn the "drop a file here" gizmo into a valid drop target.
 *
 *****************************************************************************/

BOOL PASCAL
Template_OnInitDialog(HWND hwnd)
{
    ptdii->wpTemplate = SubclassWindow(hwnd, Tools_Template_WndProc);
    DragAcceptFiles(hwnd, 1);

    if (Misc_InitPgxa(&ptdii->gxa, cbX(TI))) {
	Template_AddTemplates(hwnd);
    }
    return 1;
}

/*****************************************************************************
 *
 *  Template_OnDelete
 *
 *	Really nuke it.  The interaction between this and adding a new
 *	template is sufficiently weird that I don't want to try to do
 *	delayed-action.
 *
 *****************************************************************************/

void PASCAL
Template_OnDelete(HWND hwnd, int iItem)
{
    LV_ITEM lvi;
    HKEY hk;
    PTI pti;
    TCH tszDesc[MAX_PATH];
    lvi.pszText = tszDesc;
    lvi.cchTextMax = cA(tszDesc);
    Misc_LV_GetItemInfo(hwnd, &lvi, iItem, LVIF_PARAM | LVIF_TEXT);
    pti = ptiPlvi(&lvi);
    if (MessageBoxId(GetParent(hwnd), IDS_TEMPLATEDELETEWARN,
		    lvi.pszText, MB_YESNO | MB_DEFBUTTON2) == IDYES) {
	if (_RegOpenKey(pti->hkRoot, pti->tszKey, &hk) == 0) {
	    RegDeleteTree(hk, c_tszShellNewDash);
	    RegDeleteTree(hk, c_tszShellNew);
	    ListView_DeleteItem(hwnd, iItem);
	    Misc_LV_EnsureSel(hwnd, iItem);
	    Common_SetDirty(GetParent(hwnd));
	    RegCloseKey(hk);
	}
    }
}

/*****************************************************************************
 *
 *  Template_OnSelChange
 *
 *	Disable the Remove button if we can't remove the thing.
 *
 *****************************************************************************/

void PASCAL
Template_OnSelChange(HWND hwnd, int iItem)
{
    PTI pti = ptiIti(Misc_LV_GetParam(hwnd, iItem));
    HKEY hk;
    BOOL fEnable;
    if (_RegOpenKey(pti->hkRoot, pti->tszKey, &hk) == 0) {
	if (GetRegStr(hk, pti->isi == isiUnchecked ?
		c_tszShellNewDash : c_tszShellNew, c_tszCommand, 0, 0)) {
	    fEnable = 0;
	} else {
	    fEnable = 1;
	}
	RegCloseKey(hk);
    } else {
	fEnable = 0;
    }
    EnableWindow(GetDlgItem(GetParent(hwnd), IDC_LVDELETE), fEnable);
}

/*****************************************************************************
 *
 *  Template_OnApply
 *
 *****************************************************************************/

void PASCAL
Template_OnApply(HWND hdlg)
{
    HWND hwnd = GetDlgItem(hdlg, IDC_TEMPLATE);
    int cItems = ListView_GetItemCount(hwnd);
    BOOL fDirty;
    LV_ITEM lvi;

    fDirty = 0;
    for (lvi.iItem = 0; lvi.iItem < cItems; lvi.iItem++) {
	PTI pti;
	lvi.stateMask = LVIS_STATEIMAGEMASK;
	Misc_LV_GetItemInfo(hwnd, &lvi, lvi.iItem, LVIF_PARAM | LVIF_STATE);
	pti = ptiPlvi(&lvi);

	if (pti->isi != isiPlvi(&lvi)) {
	    PCTSTR ptszFrom, ptszTo;
	    if (pti->isi == isiUnchecked) {
		ptszFrom = c_tszShellNewDash;
		ptszTo   = c_tszShellNew;
	    } else {
		ptszFrom = c_tszShellNew;
		ptszTo   = c_tszShellNewDash;
	    }
            if (Misc_RenameReg(pti->hkRoot, pti->tszKey, ptszFrom, ptszTo)) {
                pti->isi = isiPlvi(&lvi);
	    }
	    fDirty = 1;
	}
    }
    if (fDirty) {
	Template_NudgeExplorer();
    }
}

/*****************************************************************************
 *
 *  Template_OnDestroy
 *
 *	Free the memory we allocated.
 *
 *****************************************************************************/

void PASCAL
Template_OnDestroy(HWND hdlg)
{
    Misc_FreePgxa(&ptdii->gxa);
}

/*****************************************************************************
 *
 *  Oh yeah, we need this too.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

LVCI lvciTemplate[] = {
    { IDC_LVDELETE,         Template_OnDelete },
    { 0,                    0 },
};

LVV lvvTemplate = {
    0,				/* Template_OnCommand */
    0,				/* Template_OnInitContextMenu */
    0,				/* Template_Dirtify */
    Template_GetIcon,
    Template_OnInitDialog,
    Template_OnApply,
    Template_OnDestroy,
    Template_OnSelChange,
    3,
    rgdwHelp,
    0,                          /* Double-click action */
    lvvflIcons |                /* We need icons */
    lvvflCanCheck |             /* And check boxes */
    lvvflCanDelete,             /* and you can delete them too */
    lvciTemplate,
};

#pragma END_CONST_DATA



/*****************************************************************************
 *
 *  Our window procedure.
 *
 *****************************************************************************/

INT_PTR EXPORT
Template_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    return LV_DlgProc(&lvvTemplate, hdlg, wm, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tweakui\strings.cpp ===
/*
 *  strings.c - all our strings that need to be encoded/decoded
 *
 *  To impede reverse-engineering, we encode all politically damaging
 *  strings so that a "strings" won't reveal anything incriminating.
 *
 *  This file is in two parts.  The first part (protected by "#ifdef
 *  PERL_INVOKED") consists of the human-readable data.  The second part
 *  is generated by a perl script and is the part that the compiler sees.
 *
 */

#ifdef PERL_INVOKED

/*
 *  This part of the file consists of our string declarations.
 */

c_tszNil, ""

/*
 *  Help file name, names of weird DLLs we need to hack, our own name.
 */
c_tszMyHelp, "TWEAKUI.HLP"
c_tszComCtl32Dll, "COMCTL32.DLL"
c_tszShell32Dll, "SHELL32.DLL"
c_tszTweakUICpl, "TWEAKUI.CPL"
c_tszWininit, "WININIT.INI"

c_tszSMWCV,	"Software\\Microsoft\\Windows\\CurrentVersion"
c_tszSMWNTCV,	"Software\\Microsoft\\Windows NT\\CurrentVersion"
c_tszSMWIE,	"Software\\Microsoft\\Internet Explorer"

/*
 *  Where we get the OPK subversion "number".
 */
c_tszSubVersion, "SubVersionNumber"

/*
 *  Where to get the IE version.
 */
c_tszVersion, "Version"

/*
 *  Where to install ourselves at startup.
 */
c_tszRun,	"Run"
c_tszRunServices,"RunServices"
c_tszBackslash,	"\\"

/*
 *  Windows 95 and Windows NT use different rundll commands to
 *  install inf files.
 */
c_tszFormatRundll, "%srundll.exe setupx.dll,InstallHinfSection Default%snstall 4 "
c_tszFormatRundllNT, "%srundll32.exe syssetup.dll,SetupInfObjectInstallAction Default%snstall 4 "
c_tszI, "I"
c_tszUni, "Uni"

/*
 *  Inf files we may need to install.
 */
c_tszInfBsShellInf, "Inf\\Shell.inf"
c_tszInfBsTweakuiInf, "Inf\\Tweakui.Inf"

/*
 *  Filename extensions.
 */
c_tszDotInf, ".inf"
c_tszDotLnk, ".lnk"
c_tszDotBak, ".bak"

/*
 * Even though we might be 16-bit, we still need to use RUNDLL32,
 * so that SHELL32 and COMCTL32 will be in context so we can patch them.
 * (Aigh!)
 */
c_tszFixLink, "RUNDLL32.EXE TWEAKUI.CPL,TweakMeUp"

/*
 * This performs the wacky goo we do for Windows 95 automatic logon.
 */
c_tszFixAutoLogon, "RUNDLL32.EXE TWEAKUI.CPL,TweakLogon"

/*
 *  Restriction keys.
 */
c_tszNoNetHood, "NoNetHood"
c_tszNoDrives, "NoDrives"
c_tszPoliciesSystem, "Policies\\System"
c_tszNoRegedit, "DisableRegistryTools"
c_tszNoInternetIcon,         "NoInternetIcon"
c_tszNoRecentDocsHistory,    "NoRecentDocsHistory"
c_tszNoRecentDocsMenu,       "NoRecentDocsMenu"
c_tszNoActiveDesktop,        "NoActiveDesktop"
c_tszNoActiveDesktopChanges, "NoActiveDesktopChanges"
c_tszNoFavoritesMenu,        "NoFavoritesMenu"
c_tszClearRecentDocsOnExit,  "+ClearRecentDocsOnExit"
c_tszClassicShell,           "ClassicShell"
c_tszNoLogoff,               "NoLogoff"

c_tszIE4RegKeyChange,        "Software\\Microsoft\\Windows\\CurrentVersion\\Policies"

/*
 *  IE4 advanced settings.
 */
c_tszExplorerAdvanced,       "Explorer\\Advanced"
c_tszUseDoubleClickTimer,    "UseDoubleClickTimer"


c_tszDesktopNameSpace, "Desktop\\NameSpace"

c_tszClsid, "CLSID"

c_tszPathShellFolder, "CLSID\\%s\\ShellFolder"
c_tszAttributes, "Attributes"

/*
 * c_tszClsidMyComp,	"{20D04FE0-3AEA-1069-A2D8-08002B30309D}"
 */
c_tszClsidNetHood,	"{208D2C60-3AEA-1069-A2D7-08002B30309D}"
c_tszClsidCpl,		"{21EC2020-3AEA-1069-A2DD-08002B30309D}"
c_tszClsidPrint,	"{2227A280-3AEA-1069-A2DE-08002B30309D}"

c_tszDot,		"."

/*
 *  Generic Windows customization keys go here.
 */

c_tszRegPathDesktop,	"Control Panel\\Desktop"
c_tszDelay,		"MenuShowDelay"
c_tszSmoothScroll,	"SmoothScroll"
c_tszWindows,		"Windows"
c_tszKernel32,		"KERNEL32"
c_tszMapSL,		"MapSL"
c_tszSearchUrl,		"SearchUrl"
c_tszPaintDesktop,      "PaintDesktopVersion"

/*
 *  Uninstall keys.
 */

c_tszUninstall,		"Uninstall"
c_tszDisplayName,	"DisplayName"
c_tszUninstallString,	"UninstallString"
c_tszUninstallTweakUI,	"Uninstall\\TweakUI"

/*
 *  MSDOS.SYS keys
 */

c_tszBoot,		"boot"
c_tszSysIni,		"system.ini"
c_tszDisplayDrv,	"display.drv"
c_tszXgaDrv,		"xga.drv"
c_tszPaths,		"Paths"
c_tszWinDir,		"WinDir"
c_tszOptions,		"Options"
c_tszBootKeys,		"BootKeys"
c_tszBootDelay,		"BootDelay"
c_tszBootGUI,		"BootGUI"
c_tszBootMenu,		"BootMenu"
c_tszBootMenuDelay,	"BootMenuDelay"
c_tszLogo,		"Logo"
c_tszBootMulti,		"BootMulti"
c_tszAutoScan,		"AutoScan"

/*
 *  Explorer keys.
 */
c_tszRegPathAppearance,	"Control Panel\\Appearance"
c_tszCustomColors,	"CustomColors"
c_tszCplColors,         "Control Panel\\Colors"

c_tszShellIcons,	"Shell Icons"
c_tszLinkOvl,		"29"
c_tszMetrics,		"Control Panel\\Desktop\\WindowMetrics"
c_tszShellIconSize,	"Shell Icon Size"
c_tszAltColor,		"AltColor"
c_tszHotTrackColor,     "HotTrackingColor"

c_tszTips,		"Tips"
c_tszShow,		"Show"

c_tszRestrictions,	"Policies\\Explorer"
c_tszNoExitSave,	"NoSaveSettings"
c_tszNoBanner,		"NoStartBanner"

c_tszAppletTweakUI,	"Applets\\TweakUI"
c_tszHackPtui,		"0"

c_tszSCommaU,		"%s,%u"
c_tszPercentU,		"%u"

/*
 *  User shell folders (and fake versions of same)
 */
c_tszUserShellFolders,	"User Shell Folders"
c_tszDesktop,		"Desktop"
c_tszPrograms,		"Programs"
c_tszRecent,		"Recent"
c_tszSendTo,		"SendTo"
c_tszPersonal,		"Personal"
c_tszStartup,		"Startup"
c_tszFavorites,		"Favorites"
c_tszStartMenu,		"Start Menu"
c_tszTemplates,		"Templates"
c_tszProgramFilesDir,   "ProgramFilesDir"
c_tszCommonFilesDir,    "CommonFilesDir"
c_tszSetup,             "Setup"
c_tszSourcePath,        "SourcePath"

/*
 *  Dorking the "Shortcut to" prefix
 */

c_tszExplorer,		"Explorer"
c_tszLink,		"Link"

c_tszBang,		"!"
c_tszBangLnk,		"!.lnk"

/*
 *  Network keys.
 */
c_tszWinlogon,		"Winlogon"
c_tszAutoLogon,		"AutoAdminLogon"
c_tszDefaultUserName,	"DefaultUserName"
c_tszDefaultPassword,	"DefaultPassword"
c_tszDontDisplayLast,	"DontDisplayLastUserName"
c_tszNetLogon,		"Network\\Logon"
c_tszUserName,		"UserName"

/*
 *  Paranoia
 */
c_tszRunMRU,		"RunMRU"
c_tszFindDocsMRU,	"Doc Find Spec MRU"
c_tszFindCompMRU,	"FindComputerMRU"
c_tszTypedURLs,		"TypedURLs"
c_tszAudioCDBSShell,	"AudioCD\\shell"
c_tszPlay,		"play"
c_tszNoDriveTypeAutoRun,"NoDriveTypeAutoRun"
c_tszFault,		"Fault"
c_tszLogFile,		"LogFile"

c_tszIETypedURLs,	"Software\\Microsoft\\Internet Explorer\\TypedURLs"
c_tszMSNTypedURLs,	"Software\\Microsoft\\MSN\\TypedURLs"
c_tszMain,		"Main"
c_tszHistoryDir,	"History_Directory"

c_tszNetHistory95,      "Network\\Recent"
c_tszNetHistoryNT,      "Software\\Microsoft\\Windows NT\\CurrentVersion\\Network\\Persistent Connections"

c_tszParanoia,		"1"

c_tszTelnet,            "Software\\Microsoft\\Telnet"
c_tszMachineD,          "Machine%d"
c_tszServiceD,          "Service%d"
c_tszTermTypeD,         "TermType%d"
c_tszLastMachine,       "LastMachine"
c_tszLastService,       "LastService"
c_tszLastTermType,      "LastTermType"

/*
 *  Repair
 */
c_tszRegedit,		"Applets\\Regedit"
c_tszView,		"View"
c_tszSetupExe,		"SETUP.EXE"
c_tszBSDesktopIni,	"\\DESKTOP.INI"
c_tszExe,		"EXE"
c_tszRename,		"rename"

/*
 *  This is relative to HKLM\Sofrware\Microsoft\Windows\CurrentVersion
 */

c_tszUrlHist,           "Internet Settings\\Url History"
c_tszIECache,           "Internet Settings\\Cache\\Paths"
c_tszDirectory,         "Directory"
c_tszHistory,           "History"
c_tszTempInet,          "Temporary Internet Files"

/*
 *  Templates
 */

c_tszShellNew,		"ShellNew"
c_tszShellNewDash,	"ShellNew-"
c_tszNullFile,		"NullFile"
c_tszFileName,		"FileName"
c_tszData,		"Data"
c_tszCommand,		"Command"

/*
 *  Control Panel
 */
c_tszDontLoad,          "don't load"
c_tszNo,                "no"
c_tszControlIni,        "control.ini"
c_tszStarCpl,           "*.cpl"
c_tszAppWizCpl,         "appwiz.cpl"
c_tszDeskCpl,           "desk.cpl"
c_tszIntlCpl,           "intl.cpl"
c_tszMainCpl,           "main.cpl"
c_tszTimeDateCpl,       "timedate.cpl"

/*
 *  Cmd
 */
c_tszCmdPath,           "Software\\Microsoft\\Command Processor"
c_tszFileComp,          "CompletionChar"
c_tszDirComp,           "PathCompletionChar"

#endif /* PERL_INVOKED */
/* DON'T EDIT ANYTHING AFTER THIS POINT; IT WILL BE NUKED BY THE PERL SCRIPT */
#include "tweakui.h"
TCHAR c_rgtchCommon[2397] = { 
0x53,
0x3c,
0x5a,
0x2e,
0x59,
0x38,
0x4a,
0x2f,
0x73,
0x3e,
0x57,
0x34,
0x46,
0x29,
0x5a,
0x35,
0x53,
0x27,
0x7b,
0x2c,
0x45,
0x2b,
0x4f,
0x20,
0x57,
0x24,
0x04,
0x4a,
0x1e,
0x42,
0x01,
0x74,
0x06,
0x74,
0x11,
0x7f,
0x0b,
0x5d,
0x38,
0x4a,
0x39,
0x50,
0x3f,
0x51,
0x0d,
0x43,
0x26,
0x52,
0x25,
0x4a,
0x38,
0x53,
0x0f,
0x5f,
0x3a,
0x48,
0x3b,
0x52,
0x21,
0x55,
0x30,
0x5e,
0x2a,
0x0a,
0x49,
0x26,
0x48,
0x26,
0x43,
0x20,
0x54,
0x3d,
0x52,
0x3c,
0x4f,
0x4f,
0x6a,
0x19,
0x6b,
0x1e,
0x70,
0x14,
0x78,
0x14,
0x27,
0x15,
0x3b,
0x5e,
0x26,
0x43,
0x63,
0x10,
0x69,
0x1a,
0x69,
0x0c,
0x78,
0x0d,
0x7d,
0x53,
0x37,
0x5b,
0x37,
0x1b,
0x48,
0x2d,
0x59,
0x2c,
0x5c,
0x15,
0x7b,
0x1d,
0x52,
0x30,
0x5a,
0x3f,
0x5c,
0x28,
0x61,
0x0f,
0x7c,
0x08,
0x69,
0x05,
0x69,
0x28,
0x4b,
0x3f,
0x56,
0x39,
0x57,
0x77,
0x33,
0x56,
0x30,
0x51,
0x24,
0x48,
0x3c,
0x19,
0x6a,
0x04,
0x77,
0x03,
0x62,
0x0e,
0x62,
0x42,
0x76,
0x56,
0x56,
0x73,
0x00,
0x72,
0x07,
0x69,
0x0d,
0x61,
0x0d,
0x23,
0x46,
0x3e,
0x5b,
0x7b,
0x08,
0x6d,
0x19,
0x6c,
0x1c,
0x64,
0x4a,
0x2e,
0x42,
0x2e,
0x02,
0x4b,
0x25,
0x56,
0x22,
0x43,
0x2f,
0x43,
0x0b,
0x62,
0x0c,
0x6a,
0x39,
0x5c,
0x3f,
0x4b,
0x22,
0x4d,
0x23,
0x03,
0x47,
0x22,
0x44,
0x25,
0x50,
0x3c,
0x48,
0x6d,
0x1e,
0x70,
0x03,
0x77,
0x16,
0x7a,
0x16,
0x36,
0x02,
0x22,
0x22,
0x71,
0x1e,
0x78,
0x0c,
0x7b,
0x1a,
0x68,
0x0d,
0x51,
0x1c,
0x75,
0x16,
0x64,
0x0b,
0x78,
0x17,
0x71,
0x05,
0x59,
0x0e,
0x67,
0x09,
0x6d,
0x02,
0x75,
0x06,
0x5a,
0x19,
0x6c,
0x1e,
0x6c,
0x09,
0x67,
0x13,
0x45,
0x20,
0x52,
0x21,
0x48,
0x27,
0x49,
0x15,
0x45,
0x2a,
0x46,
0x2f,
0x4c,
0x25,
0x40,
0x33,
0x33,
0x60,
0x0f,
0x69,
0x1d,
0x6a,
0x0b,
0x79,
0x1c,
0x40,
0x0d,
0x64,
0x07,
0x75,
0x1a,
0x69,
0x06,
0x60,
0x14,
0x48,
0x01,
0x6f,
0x1b,
0x7e,
0x0c,
0x62,
0x07,
0x73,
0x53,
0x16,
0x6e,
0x1e,
0x72,
0x1d,
0x6f,
0x0a,
0x78,
0x24,
0x70,
0x09,
0x79,
0x1c,
0x78,
0x2d,
0x7f,
0x33,
0x40,
0x40,
0x13,
0x7c,
0x1a,
0x6e,
0x19,
0x78,
0x0a,
0x6f,
0x33,
0x7e,
0x17,
0x74,
0x06,
0x69,
0x1a,
0x75,
0x13,
0x67,
0x3b,
0x6c,
0x05,
0x6b,
0x0f,
0x60,
0x17,
0x64,
0x44,
0x0a,
0x5e,
0x02,
0x41,
0x34,
0x46,
0x34,
0x51,
0x3f,
0x4b,
0x1d,
0x78,
0x0a,
0x79,
0x10,
0x7f,
0x11,
0x11,
0x42,
0x2d,
0x4b,
0x3f,
0x48,
0x29,
0x5b,
0x3e,
0x62,
0x2f,
0x46,
0x25,
0x57,
0x38,
0x4b,
0x24,
0x42,
0x36,
0x6a,
0x3d,
0x54,
0x3a,
0x5e,
0x31,
0x46,
0x35,
0x69,
0x2a,
0x5f,
0x2d,
0x5f,
0x3a,
0x54,
0x20,
0x76,
0x13,
0x61,
0x12,
0x7b,
0x14,
0x7a,
0x7a,
0x01,
0x33,
0x01,
0x33,
0x04,
0x45,
0x77,
0x4f,
0x7f,
0x52,
0x61,
0x20,
0x65,
0x24,
0x09,
0x38,
0x08,
0x3e,
0x07,
0x2a,
0x6b,
0x59,
0x1d,
0x58,
0x75,
0x45,
0x7d,
0x4d,
0x7d,
0x4f,
0x0d,
0x3e,
0x0e,
0x3d,
0x0d,
0x34,
0x70,
0x0d,
0x0d,
0x76,
0x44,
0x75,
0x30,
0x73,
0x41,
0x71,
0x43,
0x73,
0x5e,
0x6d,
0x2c,
0x69,
0x28,
0x05,
0x34,
0x04,
0x32,
0x0b,
0x26,
0x67,
0x55,
0x11,
0x55,
0x78,
0x48,
0x70,
0x40,
0x70,
0x42,
0x00,
0x33,
0x03,
0x30,
0x00,
0x39,
0x7d,
0x00,
0x00,
0x7b,
0x49,
0x79,
0x41,
0x05,
0x37,
0x74,
0x42,
0x72,
0x5f,
0x6c,
0x2d,
0x68,
0x29,
0x04,
0x35,
0x05,
0x33,
0x0a,
0x27,
0x66,
0x54,
0x10,
0x27,
0x0a,
0x3a,
0x02,
0x32,
0x02,
0x30,
0x72,
0x41,
0x71,
0x42,
0x72,
0x4b,
0x0f,
0x72,
0x72,
0x21,
0x4e,
0x28,
0x5c,
0x2b,
0x4a,
0x38,
0x5d,
0x01,
0x4c,
0x25,
0x46,
0x34,
0x5b,
0x28,
0x47,
0x21,
0x55,
0x09,
0x40,
0x2e,
0x5a,
0x3f,
0x4d,
0x23,
0x46,
0x32,
0x12,
0x57,
0x2f,
0x5f,
0x33,
0x5c,
0x2e,
0x4b,
0x39,
0x39,
0x6a,
0x05,
0x63,
0x17,
0x60,
0x01,
0x73,
0x16,
0x4a,
0x07,
0x6e,
0x0d,
0x7f,
0x10,
0x63,
0x0c,
0x6a,
0x1e,
0x42,
0x01,
0x6e,
0x03,
0x6e,
0x0f,
0x61,
0x05,
0x25,
0x75,
0x07,
0x68,
0x0b,
0x6e,
0x1d,
0x6e,
0x01,
0x73,
0x73,
0x30,
0x5f,
0x31,
0x45,
0x37,
0x58,
0x34,
0x14,
0x44,
0x25,
0x4b,
0x2e,
0x42,
0x1e,
0x5a,
0x3f,
0x4c,
0x27,
0x53,
0x3c,
0x4c,
0x10,
0x47,
0x2e,
0x40,
0x24,
0x4b,
0x3c,
0x71,
0x14,
0x60,
0x12,
0x7b,
0x18,
0x6b,
0x6b,
0x39,
0x6c,
0x22,
0x66,
0x2a,
0x66,
0x55,
0x67,
0x49,
0x0c,
0x54,
0x11,
0x31,
0x65,
0x32,
0x77,
0x36,
0x7d,
0x28,
0x61,
0x4f,
0x0c,
0x5c,
0x10,
0x3c,
0x68,
0x1f,
0x7a,
0x1b,
0x70,
0x3c,
0x53,
0x34,
0x5b,
0x35,
0x35,
0x67,
0x32,
0x7c,
0x38,
0x74,
0x38,
0x0b,
0x39,
0x17,
0x52,
0x0a,
0x4f,
0x6f,
0x3b,
0x6c,
0x29,
0x68,
0x23,
0x76,
0x3f,
0x11,
0x52,
0x02,
0x4e,
0x62,
0x36,
0x41,
0x24,
0x45,
0x2e,
0x63,
0x06,
0x53,
0x23,
0x23,
0x70,
0x1f,
0x79,
0x0d,
0x7a,
0x1b,
0x69,
0x0c,
0x50,
0x1d,
0x74,
0x17,
0x65,
0x0a,
0x79,
0x16,
0x70,
0x04,
0x58,
0x15,
0x46,
0x08,
0x54,
0x00,
0x79,
0x09,
0x6c,
0x08,
0x5d,
0x0f,
0x43,
0x30,
0x30,
0x79,
0x17,
0x63,
0x06,
0x74,
0x1a,
0x7f,
0x0b,
0x2b,
0x78,
0x1d,
0x69,
0x1d,
0x74,
0x1a,
0x7d,
0x0e,
0x52,
0x07,
0x75,
0x19,
0x39,
0x71,
0x18,
0x6b,
0x1f,
0x70,
0x02,
0x7b,
0x7b,
0x32,
0x5c,
0x28,
0x4d,
0x3f,
0x51,
0x34,
0x40,
0x60,
0x33,
0x56,
0x22,
0x56,
0x3f,
0x51,
0x36,
0x45,
0x19,
0x5a,
0x3b,
0x58,
0x30,
0x55,
0x09,
0x59,
0x38,
0x4c,
0x24,
0x57,
0x57,
0x04,
0x6b,
0x0d,
0x79,
0x0e,
0x6f,
0x1d,
0x78,
0x24,
0x69,
0x00,
0x63,
0x11,
0x7e,
0x0d,
0x62,
0x04,
0x70,
0x2c,
0x78,
0x1d,
0x71,
0x1f,
0x7a,
0x0e,
0x0e,
0x4d,
0x22,
0x4c,
0x38,
0x4a,
0x25,
0x49,
0x69,
0x39,
0x58,
0x36,
0x53,
0x3f,
0x63,
0x22,
0x52,
0x22,
0x47,
0x26,
0x54,
0x35,
0x5b,
0x38,
0x5d,
0x5d,
0x09,
0x6c,
0x01,
0x71,
0x1e,
0x6c,
0x0d,
0x7f,
0x06,
0x26,
0x6f,
0x01,
0x75,
0x10,
0x62,
0x0c,
0x69,
0x1d,
0x3d,
0x7b,
0x12,
0x7e,
0x1b,
0x68,
0x68,
0x2c,
0x43,
0x2d,
0x59,
0x1d,
0x74,
0x07,
0x77,
0x1b,
0x7a,
0x03,
0x4f,
0x2e,
0x5d,
0x29,
0x7c,
0x0f,
0x6a,
0x18,
0x56,
0x37,
0x5a,
0x3f,
0x3f,
0x14,
0x57,
0x3b,
0x5e,
0x3f,
0x4d,
0x1f,
0x7a,
0x19,
0x7c,
0x12,
0x66,
0x22,
0x4d,
0x2e,
0x5d,
0x12,
0x7c,
0x39,
0x41,
0x28,
0x5c,
0x5c,
0x12,
0x7d,
0x3c,
0x5f,
0x2b,
0x42,
0x34,
0x51,
0x15,
0x70,
0x03,
0x68,
0x1c,
0x73,
0x03,
0x40,
0x28,
0x49,
0x27,
0x40,
0x25,
0x56,
0x56,
0x15,
0x7a,
0x14,
0x60,
0x12,
0x7d,
0x11,
0x31,
0x61,
0x00,
0x6e,
0x0b,
0x67,
0x3b,
0x7f,
0x1a,
0x69,
0x02,
0x76,
0x19,
0x69,
0x69,
0x2d,
0x44,
0x37,
0x56,
0x34,
0x58,
0x3d,
0x6f,
0x0a,
0x6d,
0x04,
0x77,
0x03,
0x71,
0x08,
0x5c,
0x33,
0x5c,
0x30,
0x43,
0x43,
0x00,
0x6f,
0x01,
0x75,
0x07,
0x68,
0x04,
0x24,
0x74,
0x15,
0x7b,
0x1e,
0x72,
0x2e,
0x6d,
0x02,
0x6e,
0x01,
0x73,
0x00,
0x00,
0x43,
0x0f,
0x5c,
0x15,
0x51,
0x0d,
0x28,
0x5b,
0x07,
0x54,
0x3c,
0x59,
0x35,
0x59,
0x1f,
0x70,
0x1c,
0x78,
0x1d,
0x6f,
0x6f,
0x3f,
0x5e,
0x37,
0x59,
0x2d,
0x69,
0x0c,
0x7f,
0x14,
0x60,
0x0f,
0x7f,
0x29,
0x4c,
0x3e,
0x4d,
0x24,
0x4b,
0x25,
0x25,
0x70,
0x03,
0x66,
0x22,
0x4d,
0x38,
0x5a,
0x36,
0x53,
0x10,
0x7c,
0x15,
0x76,
0x1d,
0x49,
0x20,
0x4d,
0x28,
0x5a,
0x5a,
0x14,
0x7b,
0x29,
0x4c,
0x2f,
0x4a,
0x24,
0x50,
0x14,
0x7b,
0x18,
0x6b,
0x23,
0x4a,
0x39,
0x4d,
0x22,
0x50,
0x29,
0x29,
0x67,
0x08,
0x4c,
0x3e,
0x57,
0x21,
0x44,
0x10,
0x69,
0x19,
0x7c,
0x3d,
0x48,
0x3c,
0x53,
0x01,
0x74,
0x1a,
0x1a,
0x4a,
0x2b,
0x5f,
0x37,
0x74,
0x1b,
0x76,
0x06,
0x6a,
0x0f,
0x7b,
0x12,
0x7d,
0x13,
0x50,
0x38,
0x59,
0x2b,
0x2b,
0x7e,
0x0d,
0x68,
0x1a,
0x3a,
0x69,
0x01,
0x64,
0x08,
0x64,
0x44,
0x02,
0x6d,
0x01,
0x65,
0x00,
0x72,
0x01,
0x01,
0x44,
0x3c,
0x4c,
0x20,
0x4f,
0x3d,
0x58,
0x2a,
0x76,
0x37,
0x53,
0x25,
0x44,
0x2a,
0x49,
0x2c,
0x48,
0x48,
0x0c,
0x69,
0x1a,
0x71,
0x05,
0x6a,
0x1a,
0x46,
0x08,
0x69,
0x04,
0x61,
0x32,
0x42,
0x23,
0x40,
0x25,
0x25,
0x75,
0x1a,
0x76,
0x1f,
0x7c,
0x15,
0x70,
0x03,
0x5f,
0x1a,
0x62,
0x12,
0x7e,
0x11,
0x63,
0x06,
0x74,
0x74,
0x3c,
0x55,
0x26,
0x52,
0x3d,
0x4f,
0x36,
0x69,
0x2d,
0x44,
0x36,
0x53,
0x30,
0x44,
0x2b,
0x59,
0x20,
0x20,
0x75,
0x1b,
0x72,
0x1c,
0x6f,
0x1b,
0x7a,
0x16,
0x7a,
0x26,
0x72,
0x05,
0x60,
0x01,
0x6a,
0x3f,
0x76,
0x76,
0x32,
0x5d,
0x3e,
0x1e,
0x58,
0x31,
0x5f,
0x3b,
0x1b,
0x48,
0x38,
0x5d,
0x3e,
0x1e,
0x53,
0x01,
0x54,
0x54,
0x1a,
0x75,
0x27,
0x42,
0x21,
0x44,
0x2a,
0x5e,
0x1a,
0x75,
0x16,
0x65,
0x28,
0x4d,
0x23,
0x56,
0x56,
0x05,
0x70,
0x12,
0x44,
0x21,
0x53,
0x20,
0x49,
0x26,
0x48,
0x06,
0x73,
0x1e,
0x7c,
0x19,
0x6b,
0x6b,
0x23,
0x4c,
0x38,
0x6c,
0x1e,
0x7f,
0x1c,
0x77,
0x1e,
0x70,
0x17,
0x54,
0x3b,
0x57,
0x38,
0x4a,
0x4a,
0x0c,
0x65,
0x0b,
0x6f,
0x2c,
0x43,
0x2e,
0x5e,
0x2b,
0x5f,
0x3a,
0x48,
0x05,
0x57,
0x02,
0x02,
0x43,
0x33,
0x43,
0x2f,
0x4a,
0x3e,
0x4d,
0x11,
0x43,
0x26,
0x41,
0x24,
0x40,
0x29,
0x5d,
0x5d,
0x1c,
0x6c,
0x1c,
0x70,
0x15,
0x61,
0x12,
0x4e,
0x1a,
0x6d,
0x08,
0x69,
0x02,
0x57,
0x1e,
0x1e,
0x4d,
0x25,
0x40,
0x2c,
0x40,
0x60,
0x29,
0x4a,
0x25,
0x4b,
0x6b,
0x38,
0x51,
0x2b,
0x4e,
0x4e,
0x1b,
0x75,
0x1c,
0x72,
0x01,
0x75,
0x14,
0x78,
0x14,
0x47,
0x33,
0x41,
0x28,
0x46,
0x21,
0x21,
0x65,
0x00,
0x66,
0x07,
0x72,
0x1e,
0x6a,
0x3a,
0x5b,
0x28,
0x5b,
0x2c,
0x43,
0x31,
0x55,
0x55,
0x05,
0x77,
0x18,
0x7f,
0x0d,
0x6c,
0x01,
0x47,
0x2e,
0x42,
0x27,
0x54,
0x10,
0x79,
0x0b,
0x0b,
0x4f,
0x2a,
0x4c,
0x2d,
0x58,
0x34,
0x40,
0x15,
0x66,
0x03,
0x71,
0x3f,
0x5e,
0x33,
0x56,
0x56,
0x18,
0x77,
0x31,
0x50,
0x26,
0x49,
0x3b,
0x52,
0x26,
0x43,
0x30,
0x7d,
0x18,
0x76,
0x03,
0x03,
0x53,
0x3c,
0x50,
0x39,
0x5a,
0x33,
0x56,
0x25,
0x79,
0x2a,
0x53,
0x20,
0x54,
0x31,
0x5c,
0x5c,
0x12,
0x7d,
0x3c,
0x5f,
0x2b,
0x42,
0x34,
0x51,
0x15,
0x70,
0x03,
0x68,
0x1c,
0x73,
0x03,
0x03,
0x4a,
0x24,
0x42,
0x1e,
0x4a,
0x3d,
0x58,
0x39,
0x52,
0x27,
0x4e,
0x60,
0x29,
0x47,
0x21,
0x21,
0x62,
0x0d,
0x60,
0x0d,
0x62,
0x0c,
0x4a,
0x23,
0x4f,
0x2a,
0x59,
0x1d,
0x74,
0x06,
0x06,
0x47,
0x32,
0x46,
0x29,
0x68,
0x0c,
0x61,
0x08,
0x66,
0x2a,
0x45,
0x22,
0x4d,
0x23,
0x23,
0x6d,
0x02,
0x4b,
0x25,
0x51,
0x34,
0x46,
0x28,
0x4d,
0x39,
0x70,
0x13,
0x7c,
0x12,
0x12,
0x5c,
0x39,
0x4d,
0x3a,
0x55,
0x27,
0x4c,
0x10,
0x42,
0x27,
0x44,
0x21,
0x4f,
0x3b,
0x3b,
0x75,
0x1a,
0x49,
0x28,
0x5e,
0x3b,
0x68,
0x0d,
0x79,
0x0d,
0x64,
0x0a,
0x6d,
0x1e,
0x1e,
0x50,
0x3f,
0x6c,
0x18,
0x79,
0x0b,
0x7f,
0x3d,
0x5c,
0x32,
0x5c,
0x39,
0x4b,
0x4b,
0x05,
0x60,
0x14,
0x63,
0x0c,
0x7e,
0x15,
0x49,
0x05,
0x6a,
0x0d,
0x62,
0x0c,
0x0c,
0x4e,
0x21,
0x4e,
0x3a,
0x77,
0x12,
0x7c,
0x09,
0x4d,
0x28,
0x44,
0x25,
0x5c,
0x5c,
0x11,
0x74,
0x1a,
0x6f,
0x3c,
0x54,
0x3b,
0x4c,
0x08,
0x6d,
0x01,
0x60,
0x19,
0x19,
0x58,
0x2d,
0x49,
0x20,
0x4f,
0x0c,
0x48,
0x14,
0x67,
0x0f,
0x6a,
0x06,
0x6a,
0x6a,
0x23,
0x4d,
0x2b,
0x77,
0x24,
0x4c,
0x29,
0x45,
0x29,
0x07,
0x6e,
0x00,
0x66,
0x66,
0x2a,
0x4b,
0x38,
0x4c,
0x18,
0x7d,
0x0f,
0x62,
0x36,
0x4f,
0x3f,
0x5a,
0x5a,
0x19,
0x6c,
0x1f,
0x6b,
0x04,
0x69,
0x2a,
0x45,
0x29,
0x46,
0x34,
0x47,
0x47,
0x1b,
0x5f,
0x1a,
0x49,
0x02,
0x56,
0x19,
0x49,
0x67,
0x2e,
0x60,
0x29,
0x29,
0x5d,
0x34,
0x59,
0x3c,
0x58,
0x39,
0x4d,
0x28,
0x06,
0x65,
0x15,
0x79,
0x79,
0x3a,
0x75,
0x38,
0x7b,
0x2f,
0x63,
0x50,
0x62,
0x4c,
0x08,
0x44,
0x08,
0x08,
0x5b,
0x36,
0x59,
0x36,
0x42,
0x2a,
0x79,
0x1a,
0x68,
0x07,
0x6b,
0x07,
0x07,
0x44,
0x28,
0x49,
0x3a,
0x49,
0x20,
0x43,
0x10,
0x78,
0x1d,
0x71,
0x1d,
0x1d,
0x4e,
0x26,
0x43,
0x2f,
0x43,
0x63,
0x2a,
0x49,
0x26,
0x48,
0x3b,
0x3b,
0x6c,
0x25,
0x6b,
0x22,
0x6c,
0x25,
0x71,
0x5f,
0x16,
0x58,
0x11,
0x11,
0x5d,
0x3c,
0x4f,
0x3b,
0x68,
0x0d,
0x7f,
0x09,
0x60,
0x03,
0x66,
0x66,
0x2a,
0x4b,
0x38,
0x4c,
0x01,
0x60,
0x03,
0x6b,
0x02,
0x6c,
0x09,
0x09,
0x6d,
0x04,
0x77,
0x07,
0x6b,
0x0a,
0x73,
0x5d,
0x39,
0x4b,
0x3d,
0x3d,
0x79,
0x10,
0x63,
0x13,
0x7f,
0x1e,
0x67,
0x29,
0x48,
0x25,
0x40,
0x40,
0x23,
0x4c,
0x22,
0x56,
0x24,
0x4b,
0x27,
0x09,
0x60,
0x0e,
0x67,
0x67,
0x34,
0x7c,
0x39,
0x75,
0x39,
0x0a,
0x38,
0x16,
0x52,
0x1e,
0x52,
0x52,
0x06,
0x51,
0x14,
0x55,
0x1e,
0x4b,
0x02,
0x2c,
0x64,
0x28,
0x78,
0x78,
0x2a,
0x5f,
0x31,
0x62,
0x07,
0x75,
0x03,
0x6a,
0x09,
0x6c,
0x1f,
0x1f,
0x4b,
0x1c,
0x59,
0x18,
0x53,
0x06,
0x4f,
0x61,
0x22,
0x72,
0x3e,
0x3e,
0x6a,
0x0f,
0x7d,
0x10,
0x44,
0x3d,
0x4d,
0x28,
0x0d,
0x69,
0x69,
0x08,
0x78,
0x08,
0x7f,
0x16,
0x6c,
0x42,
0x21,
0x51,
0x3d,
0x3d,
0x6e,
0x1a,
0x7b,
0x09,
0x7d,
0x5d,
0x10,
0x75,
0x1b,
0x6e,
0x6e,
0x1d,
0x64,
0x17,
0x63,
0x06,
0x6b,
0x45,
0x2c,
0x42,
0x2b,
0x2b,
0x4f,
0x20,
0x4e,
0x69,
0x1d,
0x3d,
0x51,
0x3e,
0x5f,
0x3b,
0x3b,
0x68,
0x07,
0x72,
0x00,
0x63,
0x06,
0x56,
0x37,
0x43,
0x2b,
0x2b,
0x6a,
0x1e,
0x6a,
0x18,
0x71,
0x13,
0x66,
0x12,
0x77,
0x04,
0x04,
0x57,
0x32,
0x40,
0x36,
0x5f,
0x3c,
0x59,
0x7c,
0x18,
0x18,
0x4b,
0x2e,
0x4f,
0x3d,
0x5e,
0x36,
0x63,
0x11,
0x7d,
0x7d,
0x3b,
0x5a,
0x2c,
0x43,
0x31,
0x58,
0x2c,
0x49,
0x3a,
0x3a,
0x6e,
0x0b,
0x66,
0x16,
0x7a,
0x1b,
0x6f,
0x0a,
0x79,
0x79,
0x2c,
0x42,
0x2b,
0x45,
0x36,
0x42,
0x23,
0x4f,
0x23,
0x23,
0x6e,
0x0f,
0x6c,
0x04,
0x6d,
0x03,
0x66,
0x43,
0x27,
0x27,
0x74,
0x1c,
0x79,
0x15,
0x79,
0x37,
0x52,
0x25,
0x08,
0x08,
0x4a,
0x25,
0x4a,
0x3e,
0x7a,
0x1f,
0x73,
0x12,
0x6b,
0x6b,
0x38,
0x7d,
0x29,
0x7c,
0x2c,
0x02,
0x47,
0x1f,
0x5a,
0x5a,
0x18,
0x77,
0x18,
0x6c,
0x21,
0x54,
0x38,
0x4c,
0x25,
0x25,
0x6b,
0x04,
0x4a,
0x2f,
0x5b,
0x13,
0x7c,
0x13,
0x77,
0x77,
0x27,
0x42,
0x30,
0x43,
0x2c,
0x42,
0x23,
0x4f,
0x4f,
0x1f,
0x6d,
0x02,
0x65,
0x17,
0x76,
0x1b,
0x68,
0x68,
0x3b,
0x53,
0x36,
0x5a,
0x36,
0x78,
0x1d,
0x6a,
0x6a,
0x24,
0x51,
0x3d,
0x51,
0x17,
0x7e,
0x12,
0x77,
0x77,
0x3c,
0x79,
0x2b,
0x65,
0x20,
0x6c,
0x5f,
0x6d,
0x6d,
0x2b,
0x42,
0x2e,
0x4b,
0x05,
0x64,
0x09,
0x6c,
0x6c,
0x3b,
0x52,
0x3c,
0x50,
0x3f,
0x58,
0x37,
0x59,
0x59,
0x30,
0x5e,
0x2a,
0x46,
0x68,
0x0b,
0x7b,
0x17,
0x17,
0x55,
0x3a,
0x55,
0x21,
0x6a,
0x0f,
0x76,
0x05,
0x05,
0x47,
0x28,
0x47,
0x33,
0x7e,
0x1b,
0x75,
0x00,
0x00,
0x4e,
0x21,
0x6d,
0x02,
0x65,
0x0a,
0x6c,
0x0a,
0x0a,
0x44,
0x2b,
0x6f,
0x1d,
0x74,
0x02,
0x67,
0x14,
0x14,
0x55,
0x20,
0x54,
0x3b,
0x68,
0x0b,
0x6a,
0x04,
0x04,
0x60,
0x05,
0x76,
0x1d,
0x33,
0x50,
0x20,
0x4c,
0x4c,
0x21,
0x40,
0x29,
0x47,
0x69,
0x0a,
0x7a,
0x16,
0x16,
0x57,
0x3b,
0x4f,
0x0c,
0x63,
0x0f,
0x60,
0x12,
0x12,
0x5e,
0x31,
0x56,
0x10,
0x79,
0x15,
0x70,
0x70,
0x23,
0x57,
0x36,
0x44,
0x30,
0x45,
0x35,
0x35,
0x77,
0x18,
0x77,
0x03,
0x44,
0x11,
0x58,
0x58,
0x17,
0x67,
0x13,
0x7a,
0x15,
0x7b,
0x08,
0x08,
0x70,
0x17,
0x76,
0x58,
0x3c,
0x4e,
0x38,
0x38,
0x6f,
0x06,
0x68,
0x0c,
0x63,
0x14,
0x67,
0x67,
0x24,
0x4b,
0x26,
0x4b,
0x2a,
0x44,
0x20,
0x20,
0x77,
0x1e,
0x70,
0x34,
0x5d,
0x2f,
0x2f,
0x5d,
0x38,
0x56,
0x37,
0x5a,
0x3f,
0x3f,
0x6c,
0x09,
0x67,
0x03,
0x57,
0x38,
0x38,
0x6a,
0x1f,
0x71,
0x3c,
0x6e,
0x3b,
0x3b,
0x76,
0x17,
0x67,
0x34,
0x78,
0x78,
0x3b,
0x77,
0x24,
0x6d,
0x29,
0x29,
0x0c,
0x7f,
0x53,
0x76,
0x03,
0x03,
0x29,
0x07,
0x64,
0x14,
0x78,
0x78,
0x2b,
0x4e,
0x3a,
0x4f,
0x3f,
0x3f,
0x1e,
0x30,
0x5c,
0x32,
0x59,
0x59,
0x1f,
0x7e,
0x0b,
0x67,
0x13,
0x13,
0x57,
0x36,
0x42,
0x23,
0x23,
0x75,
0x1c,
0x79,
0x0e,
0x0e,
0x43,
0x22,
0x4b,
0x25,
0x25,
0x55,
0x39,
0x58,
0x21,
0x21,
0x6d,
0x04,
0x6a,
0x01,
0x01,
0x55,
0x3c,
0x4c,
0x3f,
0x3f,
0x73,
0x1c,
0x7b,
0x14,
0x14,
0x76,
0x19,
0x76,
0x02,
0x02,
0x2c,
0x4e,
0x2f,
0x44,
0x44,
0x17,
0x7f,
0x10,
0x67,
0x67,
0x32,
0x5c,
0x35,
0x35,
0x5b,
0x34,
0x34,
0x06,
0x3f,
0x3f,
0x0f,
0x0f,
0x21,
0x21,
0x00,
0x00,
0x5c,
0x5c,
0x6d,
0x6d,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tweakui\tweakui.h ===
/*
 *  tweakui.h
 */

/* WHEN CHANGING PRERELEASE - Rebuild expire.c, change tweakui.rcv */
/* #define PRERELEASE 6         /* REMOVE THIS FOR FINAL BUILD */
/* #define PUBLIC_PRERELEASE 1  /* REMOVE THIS FOR FINAL BUILD */

/* Translate between NT and Win9x build environments */
#if DBG
#define DEBUG       1
#endif

/* NT RTL functions */
#include <nt.h>
#include <ntrtl.h>
#include <ntlsa.h>
#include <nturtl.h>

#ifndef STRICT
#define STRICT
#endif

#ifndef WIN32_LEAN_AND_MEAN     /* build.exe will define it for us on NT */
#define WIN32_LEAN_AND_MEAN
#endif
#undef WINVER                   /* build process defines this */
#define WINVER 0x0400           /* Windows 95 compatible */
#define _WIN32_WINDOWS  0x0400  /* Windows 95 compatible */
#include <windows.h>            /* Everybody's favourite */

#ifndef RC_INVOKED
#include <windowsx.h>           /* Message crackers */
typedef const BYTE FAR *LPCBYTE; /* Mysteriously missing from Win32 */
#include <shellapi.h>
#include <shlobj.h>
#include <regstr.h>             /* REGSTR_PATH_DESKTOP */
#include <commdlg.h>
#include <cpl.h>                /* Control panel interface */
#include <shlwapi.h>            /* DLLVERSIONINFO */
#endif                          /* !RC_INVOKED */

#include <commctrl.h>           /* For trackbar and imagelist */
#include <prsht.h>              /* Property sheet stuff */

#ifdef WINNT
#include <winuserp.h>
#endif
#undef IDH_OK
#undef IDH_CANCEL
#include "tweakhlp.h"
#include "strings.h"

/*
 * DIDC - delta in IDC
 *
 *  didcEdit - the edit control in charge
 *  didcUd   - the updown control that is associated with it
 */

#define didcEdit 0
#define didcUd   1

/*
 * Dialog boxes and controls.
 */
#define IDD_GENERAL     1
#define IDD_EXPLORER    2
#define IDD_DESKTOP     3
#define IDD_TOOLS       4
#define IDD_ADDREMOVE   5
#define IDD_BOOT        6
#define IDD_REPAIR      7
#define IDD_PARANOIA    8
#define IDD_MYCOMP      9
#define IDD_MOUSE       10
#define IDD_NETWORK     11
#define IDD_IE4         12
#define IDD_CONTROL     13
#define IDD_CMD         14
#define IDD_COMDLG32    15

#define MAX_TWEAKUIPAGES 21

#define IDD_PICKICON    32
#define IDD_UNINSTALLEDIT 33
#define IDD_SEARCHURL   34

#ifdef  PRERELEASE
#define IDD_BETAPASSWORD 64
#endif

/*
 * Common to multiple
 */
#define IDC_WHATSTHIS  26       /* Display context help */
#define IDC_LVDELETE   27       /* Items can be deleted from LV */
#define IDC_LVTOGGLE   28       /* Toggle the state of the current LV item */
#define IDC_LVRENAME   29       /* Renaming the current LV item */
#define IDC_LISTVIEW   30       /* The listview goes here */
#define IDC_RESET      31

/*
 * IDD_MOUSE
 */

#define IDC_SPEEDTEXT   32
#define IDC_SPEEDFAST   33
#define IDC_SPEEDSLOW   34
#define IDC_SPEEDTRACK  35
#define IDC_SPEEDHELP   36

#define IDC_SENSGROUP   37
#define IDC_DBLCLKTEXT  38
#define IDC_DBLCLK      39
#define IDC_DBLCLKUD    40              /* IDC_DBLCLK + didcUd */
#define IDC_DRAGTEXT    41
#define IDC_DRAG        42
#define IDC_DRAGUD      43              /* IDC_DRAG + didcUd */
#define IDC_SENSHELP    44

//#define IDC_BUGREPORT 45

#define IDC_TESTGROUP   46
#define IDC_TEST        47
#define IDC_TIPS        48

#define IDC_WHEELFIRST  49
#define IDC_WHEELGROUP  49
#define IDC_WHEELENABLE 50
#define IDC_WHEELPAGE   51
#define IDC_WHEELLINE   52
#define IDC_WHEELLINENO 53
#define IDC_WHEELLINEUD 54              /* IDC_WHEELLINENO + didcUd */
#define IDC_WHEELLINESTXT 55
#define IDC_WHEELLAST   55

#define IDC_XMOUSEFIRST     56
#define IDC_XMOUSEGROUP     56
#define IDC_XMOUSE          57
#define IDC_XMOUSERAISE     58
#define IDC_XMOUSEDELAYTXT  59
#define IDC_XMOUSEDELAY     60
#define IDC_XMOUSELAST      60

/*
 * IDD_GENERAL
 */

#define IDC_EFFECTGROUP 38
#define IDC_ANIMATE     39
#define IDC_SMOOTHSCROLL 40
#define IDC_BEEP        41


#define IDC_IE3FIRST    42
#define IDC_IE3GROUP    42
#define IDC_IE3TXT      43
#define IDC_IE3ENGINETXT 44
#define IDC_IE3ENGINE   45
#define IDC_IE3LAST     45

#define IDC_RUDEFIRST   46
#define IDC_RUDEGROUP   46
#define IDC_RUDE        47
#define IDC_RUDEFLASHFIRST      48
#define IDC_RUDEFLASHINFINITE   48
#define IDC_RUDEFLASHFINITE     49
#define IDC_RUDEFLASHCOUNT      50
#define IDC_RUDEFLASHUD         51
#define IDC_RUDEFLASHTXT        52
#define IDC_RUDEFLASHLAST       52
#define IDC_RUDELAST    52

/*
 * IDD_EXPLORER
 */

#define IDC_LINKGROUP   32
#define IDC_LINKFIRST   33
#define IDC_LINKARROW   33              /* These need to be adjacent */
#define IDC_LIGHTARROW  34
#define IDC_NOARROW     35
#define IDC_CUSTOMARROW 36

#define IDC_LINKBEFORETEXT 37
#define IDC_LINKBEFORE  38
#define IDC_LINKAFTERTEXT 39
#define IDC_LINKAFTER   40
#define IDC_LINKHELP    41
#define IDC_LINKLAST    41

#define IDC_SETGROUP    45

#define IDC_CLRGROUP    48
#define IDC_COMPRESSFIRST 49
#define IDC_COMPRESSTXT 49
#define IDC_COMPRESSCLR 50
#define IDC_COMPRESSBTN 51
#define IDC_COMPRESSLAST 51
#define IDC_HOTTRACKFIRST 52
#define IDC_HOTTRACKTXT 52
#define IDC_HOTTRACKCLR 53
#define IDC_HOTTRACKBTN 54
#define IDC_HOTTRACKLAST 54

#define IDC_CUSTOMCHANGE 55

/*
 * IDD_DESKTOP
 */

#define IDC_ICONLV      IDC_LISTVIEW
#define IDC_ICONLVTEXT  32
#define IDC_ICONLVTEXT2 33
#define IDC_UNUSED34    34
#define IDC_CREATENOWTEXT 35
#define IDC_CREATENOW   36
#define IDC_SHOWONDESKTOP 37
#define IDC_ENUMFIRSTTEXT 38
#define IDC_ENUMFIRST   39
#if 0
#define IDC_RENAMELV    38
#endif

/*
 *  IDD_MYCOMP:  IDD_DESKTOP plus...
 */

#define IDC_FLDGROUP    42
#define IDC_FLDNAMETXT  43
#define IDC_FLDNAMELIST 44
#define IDC_FLDLOCTXT   45
#define IDC_FLDLOC      46
#define IDC_FLDCHG      47

/*
 * IDD_NETWORK
 */
/*efine IDC_LOGONGROUP          32   UNUSED */
#define IDC_LOGONAUTO           33
#define IDC_LOGONUSERTXT        34
#define IDC_LOGONUSER           35
#define IDC_LOGONPASSTXT        36
#define IDC_LOGONPASS           37
#define IDC_LOGONPASSUNSAFE     38
#define IDC_LOGONSHUTDOWN       39

/*
 * IDD_TOOLS
 */

#define IDC_TEMPLATE    IDC_LISTVIEW
#define IDC_TEMPLATETEXT 33

/*
 * IDD_ADDREMOVE
 */
#define IDC_UNINSTALL   IDC_LISTVIEW
#define IDC_UNINSTALLTEXT 32
#define IDC_UNINSTALLEDIT 33
#define IDC_UNINSTALLNEW 35
#define IDC_UNINSTALLCHECK      36

/*
 * IDD_BOOT
 */

#define IDC_BOOTGROUP1  32
#define IDC_BOOTKEYS    33
#define IDC_BOOTDELAYTEXT 34
#define IDC_BOOTDELAY   35
#define IDC_BOOTDELAYUD 36
#define IDC_BOOTDELAYTEXT2 37
#define IDC_BOOTGUI     38
#define IDC_LOGO        39
#define IDC_BOOTMULTI   40

#define IDC_BOOTMENUGROUP 41
#define IDC_BOOTMENU    42

//#define IDC_BOOTMENUDEFAULT xx
#define IDC_BOOTMENUDELAYTEXT 43
#define IDC_BOOTMENUDELAY 44
#define IDC_BOOTMENUDELAYUD 45
#define IDC_BOOTMENUDELAYTEXT2 47

#define IDC_SCANDISK    48
#define IDC_SCANDISKTEXT 49


/*
 * IDD_REPAIR
 */
#define IDC_REPAIRCOMBO         64
#define IDC_REPAIRNOW           65
#define IDC_REPAIRHELP          66
#define IDC_REPAIRTEXT          67
#define IDC_REPAIRICON          68

/*
 * IDD_PARANOIA
 */
#define IDC_CLEARGROUP          32
#define IDC_CLEARNOW            37
#define IDC_CDROMGROUP          38
#define IDC_CDROMAUDIO          39
#define IDC_CDROMDATA           40
#define IDC_PARANOIA95ONLYMIN   IDC_FAULTLOGGROUP
#define IDC_FAULTLOGGROUP       41
#define IDC_FAULTLOG            42
#define IDC_PARANOIA95ONLYMAX   43

/*
 * IDD_IE4
 */
#define IDC_SETTINGSGROUP       32

/*
 * IDD_CMD
 */
#define IDC_COMPLETIONGROUP     32
#define IDC_FILECOMPTXT         33
#define IDC_DIRCOMPTXT          34
#define IDC_FILECOMP            35
#define IDC_DIRCOMP             36
#define IDC_WORDDELIM           37

/*
 * IDD_COMDLG32
 */

#define IDC_SHOWBACK            32
#define IDC_FILEMRU             33
#define IDC_PLACESGROUP         34
#define IDC_PLACESDEF           35
#define IDC_PLACESHIDE          36
#define IDC_PLACESCUSTOM        37
#define IDC_PLACE0              38
//      IDC_PLACE1              39
//      IDC_PLACE2              40
//      IDC_PLACE3              41
//      IDC_PLACE4              42

/*
 * IDD_PICKICON
 */
#define IDC_PICKPATH    32
#define IDC_PICKICON    33
#define IDC_PICKBROWSE  34

/*
 * IDD_UNINSTALLEDIT
 */
#define IDC_UNINSTALLDESCTEXT   32
#define IDC_UNINSTALLDESC       33
#define IDC_UNINSTALLCMDTEXT    34
#define IDC_UNINSTALLCMD        35

/*
 * IDD_SEARCHURL
 */
#define IDC_SEARCHURL           32

/*
 * Menus
 */
#define IDM_MAIN        1

/*
 * Bitmaps
 */
#define IDB_CHECK       1

/*
 * Strings
 */
#define IDS_NAME        1
#define IDS_DESCRIPTION 2

#define IDS_ALLFILES    3

#define IDS_BADEXT      4
#define IDS_COPYFAIL    5
#define IDS_REGFAIL     6
#define IDS_CONFIRMNEWTEMPLATE 7
#define IDS_TOOMANY     8
#define IDS_CANNOTTEMPLATE 9

#define IDS_NETHOOD    10
#define IDS_LOGONOFF   11

#define IDS_ERRMSDOSSYS 12

/*
 *  Scandisk strings.
 */
#define IDS_SCANDISKFIRST   13
#define IDS_SCANDISKNEVER   13
#define IDS_SCANDISKPROMPT  14
#define IDS_SCANDISKALWAYS  15

#ifdef BOOTMENUDEFAULT
#define IDS_BOOTMENU        xx
#define IDS_BOOTMENULOGGED  14
#define IDS_BOOTMENUSAFE    15
#define IDS_BOOTMENUSAFENET 16
#define IDS_BOOTMENUSTEP    17
#define IDS_BOOTMENUCMD     18
#define IDS_BOOTMENUSAFECMD 19
#define IDS_BOOTMENUPREV    20
#define IDS_BOOTMENULAST    20
#endif

#define IDS_DESKTOPRESETOK      21
#define IDS_ICONFILES           22

#define IDS_NOTHINGTOCLEAR      23

#define IDS_BADRUN              24
#define IDS_CANTINSTALL         25
#define IDS_NONETHOOD           26
#define IDS_ADDRMWARN           27
#define IDS_FIXED               28
#define IDS_TEMPLATEDELETEWARN  29
#define IDS_MAYBEREBOOT         30
#define IDS_ICONSREBUILT        31
#define IDS_RESTRICTED          32
#define IDS_ASKREPAIRADDRM      33
#define IDS_WARNFOLDERCHANGE    34
#define IDS_REORDERDESKTOP      35
#define IDS_REPAIRLOGONOFF      36
#define IDS_NONE                37
//#define IDS_CWD                 38

#define IDS_FOLDER_PATTERN      95

#define IDS_ENGINE              160     /* 160 .. 191 */
#define IDS_URL                 192     /* 192 .. 223 */

#define IDS_PARANOIA            224     /* 224 .. 255 */

#define IDS_GENERALEFFECTS      256     /* 256 .. 287 */

#define IDS_CPL_BORING          288     /* 288 .. 319 */
#define IDS_CPL_ADDRM           289     /* Add/Remove Programs */
#define IDS_CPL_DESK            290     /* Desktop settings */
#define IDS_CPL_INTL            291     /* Regional settings */
#define IDS_CPL_MAIN            292     /* Mouse, Keyboard, PCMCIA, etc. */
#define IDS_CPL_TIMEDATE        293     /* Time/Date */

#define IDS_REPAIR              320     /* 320 .. 351 */
#define IDS_REPAIRHELP          352     /* 352 .. 383 */

#define IDS_COMPLETION          384     /* 384 .. 415 */

#define IDS_IE4                 416     /* 416 .. 479 */

#define IDS_EXPLOREREFFECTS     480     /* 480 .. 511 */

/* WARNING!  These must match the CSIDL values! */
#define IDS_FOLDER_BASE         1024
#define IDS_FOLDER_DESKTOPFOLDER (IDS_FOLDER_BASE + 0x0000)
#define IDS_FOLDER_PROGRAMS     (IDS_FOLDER_BASE + 0x0002)
#define IDS_FOLDER_PERSONAL     (IDS_FOLDER_BASE + 0x0005)
#define IDS_FOLDER_FAVORITES    (IDS_FOLDER_BASE + 0x0006)
#define IDS_FOLDER_STARTUP      (IDS_FOLDER_BASE + 0x0007)
#define IDS_FOLDER_RECENT       (IDS_FOLDER_BASE + 0x0008)
#define IDS_FOLDER_SENDTO       (IDS_FOLDER_BASE + 0x0009)
#define IDS_FOLDER_STARTMENU    (IDS_FOLDER_BASE + 0x000B)
#define IDS_FOLDER_MYMUSIC      (IDS_FOLDER_BASE + 0x000D)
#define IDS_FOLDER_MYVIDEO      (IDS_FOLDER_BASE + 0x000E)
#define IDS_FOLDER_DESKTOP      (IDS_FOLDER_BASE + 0x0010)
#define IDS_FOLDER_DRIVES       (IDS_FOLDER_BASE + 0x0011)
#define IDS_FOLDER_NETWORK      (IDS_FOLDER_BASE + 0x0012)
#define IDS_FOLDER_TEMPLATES    (IDS_FOLDER_BASE + 0x0015)
#define IDS_FOLDER_HISTORY      (IDS_FOLDER_BASE + 0x0022)
#define IDS_FOLDER_PROGRAMFILES (IDS_FOLDER_BASE + 0x0026)
#define IDS_FOLDER_MYPICTURES   (IDS_FOLDER_BASE + 0x0027)
#define IDS_FOLDER_COMMONFILES  (IDS_FOLDER_BASE + 0x002B)
#define IDS_FOLDER_SOURCEPATH   (IDS_FOLDER_BASE + 0x0018)

#define IDS_DEFAULT_BASE        1280
#define IDS_DEFAULT_PROGRAMS    (IDS_DEFAULT_BASE + 0x0002)
#define IDS_DEFAULT_PERSONAL    (IDS_DEFAULT_BASE + 0x0005)
#define IDS_DEFAULT_FAVORITES   (IDS_DEFAULT_BASE + 0x0006)
#define IDS_DEFAULT_STARTUP     (IDS_DEFAULT_BASE + 0x0007)
#define IDS_DEFAULT_RECENT      (IDS_DEFAULT_BASE + 0x0008)
#define IDS_DEFAULT_SENDTO      (IDS_DEFAULT_BASE + 0x0009)
#define IDS_DEFAULT_STARTMENU   (IDS_DEFAULT_BASE + 0x000B)
#define IDS_DEFAULT_MYMUSIC     (IDS_DEFAULT_BASE + 0x000D)
#define IDS_DEFAULT_MYVIDEO     (IDS_DEFAULT_BASE + 0x000E)
#define IDS_DEFAULT_DESKTOP     (IDS_DEFAULT_BASE + 0x0010)
#define IDS_DEFAULT_TEMPLATES   (IDS_DEFAULT_BASE + 0x0015)
#define IDS_DEFAULT_MYPICTURES  (IDS_DEFAULT_BASE + 0x0027)


/*
 * Icons
 */
#define IDI_DEFAULT     1
#define IDI_GEAR1       2
#define IDI_ALTLINK     3       /* This must remain number 3 */
#define IDI_BLANK       4       /* This must remain number 4 */

#define IDI_GEAR2       5

/*
 * Binary
 */
#define IDX_SETUP       1       /* Tiny Win16 setup.exe */
#define IDX_FONTFOLDER  2       /* desktop.ini for Font Folder */
#define IDX_TEMPINET    3       /* desktop.ini for Temporary Internet Files */
#define IDX_HISTORY     4       /* desktop.ini for History */
#define IDX_RECYCLE     5       /* desktop.ini for Recycle Bin */

#ifndef RC_INVOKED

/*****************************************************************************
 *
 *  Thinks that depend on which header files you are using.
 *
 *****************************************************************************/

#ifndef SM_MOUSEWHEELPRESENT

#define SM_MOUSEWHEELPRESENT    75

#define SPI_GETWHEELSCROLLLINES 104
#define SPI_SETWHEELSCROLLLINES 105

#endif

#ifndef SPI_GETMENUSHOWDELAY
#define SPI_GETMENUSHOWDELAY    106
#define SPI_SETMENUSHOWDELAY    107
#endif

#ifndef SPI_GETUSERPREFERENCE
#define SPI_GETUSERPREFERENCE   108
#define SPI_SETUSERPREFERENCE   109
#define SPI_UP_ACTIVEWINDOWTRACKING 0
#endif

#ifndef SPI_GETACTIVEWINDOWTRACKING
#define SPI_GETACTIVEWINDOWTRACKING         0x1000
#define SPI_SETACTIVEWINDOWTRACKING         0x1001
#define SPI_GETMENUANIMATION                0x1002
#define SPI_SETMENUANIMATION                0x1003
#define SPI_GETCOMBOBOXANIMATION            0x1004
#define SPI_SETCOMBOBOXANIMATION            0x1005
#define SPI_GETLISTBOXSMOOTHSCROLLING       0x1006
#define SPI_SETLISTBOXSMOOTHSCROLLING       0x1007
#define SPI_GETGRADIENTCAPTIONS             0x1008
#define SPI_SETGRADIENTCAPTIONS             0x1009
#define SPI_GETKEYBOARDCUES                 0x100A
#define SPI_SETKEYBOARDCUES                 0x100B
#define SPI_GETACTIVEWNDTRKZORDER           0x100C
#define SPI_SETACTIVEWNDTRKZORDER           0x100D
#define SPI_GETHOTTRACKING                  0x100E
#define SPI_SETHOTTRACKING                  0x100F
#define SPI_GETMENUFADE                     0x1012
#define SPI_SETMENUFADE                     0x1013
#define SPI_GETSELECTIONFADE                0x1014
#define SPI_SETSELECTIONFADE                0x1015
#define SPI_GETTOOLTIPANIMATION             0x1016
#define SPI_SETTOOLTIPANIMATION             0x1017
#define SPI_GETTOOLTIPFADE                  0x1018
#define SPI_SETTOOLTIPFADE                  0x1019
#define SPI_GETCURSORSHADOW                 0x101A
#define SPI_SETCURSORSHADOW                 0x101B

#define SPI_GETFOREGROUNDLOCKTIMEOUT        0x2000
#define SPI_SETFOREGROUNDLOCKTIMEOUT        0x2001
#define SPI_GETACTIVEWNDTRKTIMEOUT          0x2002
#define SPI_SETACTIVEWNDTRKTIMEOUT          0x2003
#define SPI_GETFOREGROUNDFLASHCOUNT         0x2004
#define SPI_SETFOREGROUNDFLASHCOUNT         0x2005

#endif

#ifndef COLOR_HOTLIGHT
#define COLOR_HOTLIGHT          26
#endif

#ifndef WHEEL_PAGESCROLL
#define WHEEL_PAGESCROLL        ((UINT)-1)
#endif

#ifndef UINT_MAX
#define UINT_MAX                ((UINT)-1)
#endif

/*****************************************************************************
 *
 *  I'm getting tired of writing these out the long way.
 *
 *****************************************************************************/

typedef UNALIGNED struct _ITEMIDLIST FAR *PIDL;
typedef LPSHELLFOLDER PSF;
typedef HIMAGELIST HIML;
typedef TCHAR TCH;
typedef const TCH *PCTSTR;
typedef LPVOID PV, *PPV;
typedef LPUNKNOWN PUNK;

#define hkLM HKEY_LOCAL_MACHINE
#define hkCU HKEY_CURRENT_USER
#define hkCR HKEY_CLASSES_ROOT

/*****************************************************************************
 *
 *  Goofy macros
 *
 *****************************************************************************/

#ifdef WIN32
#define EXPORT
#define CODESEG
#define BEGIN_CONST_DATA data_seg(".text", "CODE")
#define END_CONST_DATA data_seg(".data", "DATA")
#else
#define EXPORT    _loadds _far _pascal
#define CODESEG __based(__segname("_TEXT"))
#define BEGIN_CONST_DATA
#define END_CONST_DATA
#endif
#define INLINE static __inline

#define ConstString(nm, v) const TCH CODESEG nm[] = TEXT(v)
#define ConstString2(nm, v1, v2) const TCH CODESEG nm[] = TEXT(v1) TEXT(v2)
#define ExternConstString(nm) extern const TCH CODESEG nm[]

/*****************************************************************************
 *
 *  Baggage I carry everywhere
 *
 *****************************************************************************/

#define cbX(x) sizeof(x)
#define cA(a) (sizeof(a)/sizeof(a[0]))

#define cbCtch(ctch) ((ctch) * sizeof(TCH))

/*
 * lor -- Logical or.  Evaluate the first.  If the first is nonzero,
 * return it.  Otherwise, return the second.
 *
 * Unfortunately, due to the limitations of the C language, this can
 * be implemented only with a GNU extension.  In the non-GNU case,
 * we return 1 if the first is nonzero.
 */

#if defined(__GNUC__)
#define fLorFF(f1, f2) ({ typeof (f1) _f = f1; if (!_f) _f = f2; _f; })
#else
#define fLorFF(f1, f2) ((f1) ? 1 : (f2))
#endif

/*
 * limp - logical implication.  True unless the first is nonzero and
 * the second is zero.
 */
#define fLimpFF(f1, f2) fLorFF(!(f1), f2)

/*****************************************************************************
 *
 *  Common dialog wrappers
 *
 *****************************************************************************/

typedef struct COFN {           /* common open file name */
    OPENFILENAME ofn;           /* The thing COMMDLG wants */
    TCH tsz[MAX_PATH];          /* Where we build the name */
    TCH tszFilter[100];         /* File open/save filter */
} COFN, *PCOFN;

void PASCAL InitOpenFileName(HWND hwnd, PCOFN pcofn, UINT ids, LPCSTR pszInit);

/*****************************************************************************
 *
 *  Private stuff
 *
 *****************************************************************************/

#define iErr (-1)
int PASCAL iFromPtsz(LPTSTR ptsz);
LPTSTR PASCAL ptszStrChr(PCTSTR ptsz, TCH tch);
PTSTR PASCAL ptszStrRChr(PCTSTR ptsz, TCH tch);

HRESULT PASCAL Ole_Init(void);
void PASCAL Ole_Term(void);

void PASCAL Ole_Free(LPVOID pv);
#define Ole_Release(p) (p)->Release()
BOOL PASCAL Ole_ClsidFromString(LPCTSTR lpsz, LPCLSID pclsid);

#ifdef  UNICODE
int PASCAL Ole_FromUnicode(LPSTR psz, LPOLESTR lpos);
#define UnicodeFromPtsz(wsz, ptsz) LPCWSTR wsz = ptsz
#define AnsiFromPtsz(sz, ptsz) CHAR sz[MAX_PATH]; Ole_FromUnicode(sz, ptsz)
#else   /* ANSI */
int PASCAL Ole_ToUnicode(LPOLESTR lpos, LPCSTR psz);
#define UnicodeFromPtsz(wsz, ptsz) WCHAR wsz[MAX_PATH]; Ole_ToUnicode(wsz, ptsz)
#define AnsiFromPtsz(sz, ptsz) LPCSTR sz = ptsz
#endif

BOOL PASCAL SetRestriction(LPCTSTR ptszKey, BOOL f);
BOOL PASCAL GetRestriction(LPCTSTR ptszKey);

PIDL PASCAL pidlFromPath(PSF psf, LPCSTR cqn);
PIDL PASCAL pidlSimpleFromPath(LPCSTR cqn);
HRESULT PASCAL SetNameOfPidl(PSF psf, PIDL pidl, LPCSTR pszName);
HRESULT PASCAL ComparePidls(PIDL pidl1, PIDL pidl2);
HIML PASCAL GetSystemImageList(DWORD dw);
STDAPI_(void) ChangeNotifyCsidl(HWND hwnd, int csidl, LONG eventId);

BOOL PASCAL WithPidl(PSF psf, LPCSTR lqn, BOOL (*pfn)(PIDL, LPVOID), LPVOID pv);
BOOL PASCAL WithPsf(PSF psf, PIDL pidl, BOOL (*pfn)(PSF, LPVOID), LPVOID pv);
BOOL PASCAL EmptyDirectory(LPCSTR pszDir, BOOL (*pfn)(LPCSTR, LPVOID), PV pv);
BOOL PASCAL WithTempDirectory(BOOL (*pfn)(LPCSTR, LPVOID), LPVOID pv);

INT_PTR EXPORT General_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam);
INT_PTR EXPORT Mouse_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam);
INT_PTR EXPORT Explorer_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam);
INT_PTR EXPORT Desktop_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam);
INT_PTR EXPORT MyComp_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam);
INT_PTR EXPORT Network_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam);
INT_PTR EXPORT Template_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam);
INT_PTR EXPORT AddRm_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam);
INT_PTR EXPORT Boot_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam);
INT_PTR EXPORT Repair_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam);
INT_PTR EXPORT Paranoia_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam);
INT_PTR EXPORT IE4_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam);
INT_PTR EXPORT Control_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam);
INT_PTR EXPORT Cmd_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam);
INT_PTR EXPORT Comdlg32_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam);

void PASCAL Boot_FindMsdosSys(void);

BOOL PASCAL fCreateNil(LPCSTR cqn);
BOOL PASCAL Link_GetShortcutTo(void);
BOOL PASCAL Link_SetShortcutTo(BOOL f);
void PASCAL Explorer_HackPtui(void);
int PASCAL Explorer_GetIconSpecFromRegistry(LPTSTR ptszBuf);
void PASCAL Paranoia_CoverTracks(void);

INT_PTR PickIcon(HWND, LPSTR, UINT, int *);

int PASCAL MessageBoxId(HWND hwnd, UINT id, LPCSTR pszTitle, UINT fl);

PTSTR PASCAL TweakUi_TrimTrailingBs(LPTSTR ptsz);

typedef BOOL (PASCAL *WITHPROC)(LPVOID pv, LPVOID pvRef);
BOOL PASCAL WithSelector(DWORD_PTR lib, UINT cb, WITHPROC wp, LPVOID pvRef,
                         BOOL fWrite);

HICON PASCAL LoadIconId(UINT id);
void PASCAL SafeDestroyIcon(HICON hicon);

/*****************************************************************************
 *
 *  Path stuff
 *
 *****************************************************************************/

int PASCAL ParseIconSpec(LPTSTR ptszSrc);
LPTSTR PASCAL ptszFilenameCqn(PCTSTR cqn);
void Path_Append(LPTSTR ptszDir, LPCTSTR ptszFile);

/*****************************************************************************
 *
 *  common.c
 *
 *  Common property sheet handling.
 *
 *****************************************************************************/

void PASCAL Common_SetDirty(HWND hdlg);
#define Common_SetClean(hdlg)
void PASCAL Common_NeedLogoff(HWND hdlg);
void PASCAL Common_OnHelp(LPARAM lp, const DWORD CODESEG *pdwHelp);
void PASCAL Common_OnContextMenu(WPARAM wparam, const DWORD CODESEG *pdwHelp);

typedef HMENU (PASCAL *CMCALLBACK)(HWND hwnd, int iItem);
void PASCAL Common_LV_OnContextMenu(HWND hdlg, HWND hwnd, LPARAM lp,
                        CMCALLBACK pfn, const DWORD CODESEG *pdwHelp);

typedef struct LVCI {           /* common listview command info */
    int id;                     /* command identifier */
    void (PASCAL *pfn)(HWND hwnd, int iItem); /* command handler */
} LVCI, *PLVCI;

void PASCAL Common_OnLvCommand(HWND hdlg, int idCmd, PLVCI rglvci, int clvci);

void NEAR PASCAL EnableDlgItem(HWND hdlg, UINT idc, BOOL f);
void NEAR PASCAL EnableDlgItems(HWND hdlg, UINT idcFirst, UINT idcLast, BOOL f);
void NEAR PASCAL SetDlgItemTextLimit(HWND hdlg, UINT id, LPCTSTR ptsz, UINT ctch);

#define ADI_DISABLE     0x0001
#define ADI_ENABLE      0x0002
#define ADI_HIDE        0x0004
#define ADI_SHOW        0x0008
void NEAR PASCAL AdjustDlgItems(HWND hdlg, UINT idcFirst, UINT idcLast, UINT adi);

void NEAR PASCAL
DestroyDlgItems(HWND hdlg, UINT idcFirst, UINT idcLast);
void PASCAL GetDlgItemRect(HWND hdlg, UINT idc, LPRECT prc);
void PASCAL MoveDlgItems(HWND hdlg, UINT idcTarget, UINT idcFirst, UINT idcLast);

/*****************************************************************************
 *
 *  GXA - Growable "X" array
 *
 *****************************************************************************/

typedef struct {
    PVOID   pv;
    int     cx;
    int     cxAlloc;
    int     cbx;
} GXA, *PGXA;

#define Declare_Gxa(T, t)                                       \
    union {                                                     \
        GXA gxa;                                                \
        struct { P##T p##t; int c##t;                           \
                 int c##t##Alloc; int cb##t; };                 \
    }                                                           \

PVOID PASCAL Misc_AllocPx(PGXA pgxa);
BOOL PASCAL Misc_InitPgxa(PGXA pgxa, int cbx);
void PASCAL Misc_FreePgxa(PGXA pgxa);

/*****************************************************************************
 *
 *  misc.c
 *
 *****************************************************************************/

LPTSTR PASCAL Misc_Trim(LPTSTR ptsz);
BOOL PASCAL
Misc_CopyReg(HKEY hkSrcRoot, PCTSTR ptszSrc, HKEY hkDstRoot, PCTSTR ptszDst);

BOOL PASCAL
Misc_RenameReg(HKEY hkRoot, PCTSTR ptszKey, PCTSTR ptszSrc, PCTSTR ptszDst);

void PASCAL lstrcatnBs(PTSTR ptszDst, PCTSTR ptszSrc, int ctch);
#define lstrcatnBsA(a, ptsz) lstrcatnBs(a, ptsz, cA(a))

UINT PASCAL Misc_GetShellIconSize(void);
void PASCAL Misc_SetShellIconSize(UINT ui);
void PASCAL Misc_RebuildIcoCache(void);

void PASCAL Misc_EnableMenuFromHdlgId(HMENU hmenu, HWND hdlg, UINT idc);

/*****************************************************************************
 *
 *  misc.c
 *
 *  Listview stuff
 *
 *****************************************************************************/

void PASCAL Misc_LV_Init(HWND hwnd);
int PASCAL Misc_LV_GetCurSel(HWND hwnd);
void PASCAL Misc_LV_SetCurSel(HWND hwnd, int iIndex);
void PASCAL Misc_LV_EnsureSel(HWND hwnd, int iItem);
void PASCAL Misc_LV_GetItemInfo(HWND, LV_ITEM FAR *, int, UINT);
LPARAM PASCAL Misc_LV_GetParam(HWND hwnd, int iItem);
void PASCAL Misc_LV_HitTest(HWND hwnd, LV_HITTESTINFO FAR *phti, LPARAM lpPos);
LRESULT PASCAL Misc_Combo_GetCurItemData(HWND hwnd);

/*****************************************************************************
 *
 *  lv.c
 *
 *  Listview property sheet page manager
 *
 *****************************************************************************/

typedef UINT LVVFL;
#define lvvflIcons      1               /* Show icons */
#define lvvflCanCheck   2               /* Show check-box */
#define lvvflCanRename  4               /* Can rename by clicking */
#define lvvflCanDelete  8               /* Parent dialog has IDC_LVDELETE */

typedef struct LVV {
    void (PASCAL *OnCommand)(HWND hdlg, int id, UINT codeNotify);
    void (PASCAL *OnInitContextMenu)(HWND hwnd, int iItem, HMENU hmenu);
    void (PASCAL *Dirtify)(LPARAM lp);
    int (PASCAL *GetIcon)(LPARAM lp);
    BOOL (PASCAL *OnInitDialog)(HWND hwnd);
    void (PASCAL *OnApply)(HWND hdlg);
    void (PASCAL *OnDestroy)(HWND hdlg);
    void (PASCAL *OnSelChange)(HWND hwnd, int iItem);
    int iMenu;
    const DWORD CODESEG *pdwHelp;
    UINT idDblClk;
    LVVFL lvvfl;
    LVCI *rglvci;
} LVV, *PLVV;

int PASCAL
LV_AddItem(HWND hwnd, int ix, LPCTSTR ptszDesc, int iImage, BOOL fState);

BOOL EXPORT
LV_DlgProc(PLVV plvv, HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam);

/* State icon information */

#define isiNil          0               /* No state image */
#define isiUnchecked    1               /* Not checked */
#define isiChecked      2               /* Checked */

#ifndef STATEIMAGEMASKTOINDEX
#define STATEIMAGEMASKTOINDEX(i) ((i & LVIS_STATEIMAGEMASK) >> 12)
#endif
#define isiPlvi(plvi) STATEIMAGEMASKTOINDEX((plvi)->state)

/*  Checklist_OnApply assumes this returns exactly 0 or 1 */
#define LV_IsChecked(plvi) (isiPlvi(plvi) == isiChecked)

/*****************************************************************************
 *
 *  lvchk.c
 *
 *  Check-listview property sheet page manager
 *
 *****************************************************************************/

/*
 *  GetCheckValue must return exactly one of these values
 *
 *      -1  not supported on this platform
 *       0  off
 *       1  on
 *
 *  Yes, you must explicitly return 1 for on.  The reason is that if
 *  I let you return arbitrary nonzero values, you might accidentally
 *  return -1 and that would be bad.
 */
typedef BOOL (PASCAL *GETCHECKVALUE)(LPARAM lParam, LPVOID pvRef);
typedef BOOL (PASCAL *SETCHECKVALUE)(BOOL fCheck, LPARAM lParam, LPVOID pvRef);

typedef struct CHECKLISTITEM {
    GETCHECKVALUE   GetCheckValue;
    SETCHECKVALUE   SetCheckValue;
    LPARAM          lParam;
} CHECKLISTITEM, *PCHECKLISTITEM;
typedef const CHECKLISTITEM *PCCHECKLISTITEM;

void PASCAL
Checklist_OnInitDialog(HWND hwnd, PCCHECKLISTITEM rgcli, int ccli,
                       UINT ids, LPVOID pvRef);
void PASCAL
Checklist_OnApply(HWND hdlg, PCCHECKLISTITEM rgcli, LPVOID pvRef, BOOL fForce);

/*****************************************************************************
 *
 *  reg.c
 *
 *  Registry wrappers
 *
 *****************************************************************************/

typedef struct KL {                     /* Key location */
    PHKEY phkRoot;                      /* E.g., &hkCU, &pcdii->hlCUExplorer */
    PCTSTR ptszKey;                     /* E.g., "Software\\Microsoft" */
    PCTSTR ptszSubkey;                  /* E.g., "Show" */
} KL;

typedef const KL *PKL;
extern KL const c_klHackPtui;

extern HKEY CODESEG c_hkCR;             /* HKEY_CLASSES_ROOT */
extern HKEY CODESEG c_hkCU;             /* HKEY_CURRENT_USER */
extern HKEY CODESEG c_hkLM;             /* HKEY_LOCAL_MACHINE */
extern HKEY g_hkLMSMWCV;                /* HKLM\Software\MS\Win\CurrentVer */
extern HKEY g_hkCUSMWCV;                /* HKCU\Software\MS\Win\CurrentVer */
extern HKEY g_hkLMSMIE;                 /* HKLM\Software\MS\IE */
extern HKEY g_hkCUSMIE;                 /* HKCU\Software\MS\IE */

/*
 * The NT version points to HKLM\Software\MS\Win NT\CurrentVersion if we are
 * running on NT; else, it's the same as g_hkLMSMWCV.
 */
extern HKEY g_hkLMSMWNTCV;              /* HKLM\Software\MS\Win( NT)?\CV */

#define phkCU (&c_hkCU)
#define phkLM (&c_hkLM)

typedef HKEY HHK;

#define hhkHkey(hkey) hkey
#define hkeyHhk(hhk)  hhk

#define hhkLM hhkHkey(HKEY_LOCAL_MACHINE)
#define hhkCU hhkHkey(HKEY_CURRENT_USER)
#define hhkCR hhkHkey(HKEY_CLASSES_ROOT)

/*
 *  Special wrappers that are NT-friendly.
 */
BOOL PASCAL RegCanModifyKey(HKEY hkRoot, LPCTSTR ptszSubkey);

LONG PASCAL _RegOpenKey(HKEY hk, LPCTSTR lptszSubKey, PHKEY phkResult);
#undef RegOpenKey
#define RegOpenKey _RegOpenKey

LONG PASCAL _RegCreateKey(HKEY hk, LPCTSTR lptszSubKey, PHKEY phkResult);
#undef RegCreateKey
#define RegCreateKey _RegCreateKey

void PASCAL RegDeleteValues(HKEY hkRoot, LPCTSTR ptszSubkey);
LONG PASCAL RegDeleteTree(HKEY hkRoot, LPCTSTR ptszSubkey);
BOOL PASCAL RegKeyExists(HKEY hkRoot, LPCTSTR ptszSubkey);

HKEY PASCAL hkOpenClsid(PCTSTR ptszClsid);

BOOL PASCAL GetRegStr(HKEY hkey, LPCSTR pszKey, LPCTSTR ptszSubkey,
                      LPTSTR ptszBuf, int cbBuf);
BOOL PASCAL GetStrPkl(LPTSTR ptszBuf, int cbBuf, PKL pkl);

DWORD PASCAL GetRegDword(HHK hhk, LPCSTR pszKey, LPCSTR pszSubkey, DWORD dw);
DWORD PASCAL GetDwordPkl(PKL pkl, DWORD dw);

UINT PASCAL GetRegInt(HHK hhk, LPCSTR pszKey, LPCSTR pszSubkey, UINT uiDefault);
UINT PASCAL GetIntPkl(UINT uiDefault, PKL pkl);

BOOL PASCAL SetRegStr(HHK hhk, LPCTSTR ptszKey, LPCTSTR ptszSubkey,
                      LPCTSTR ptszVal);
BOOL PASCAL SetStrPkl(PKL pkl, LPCTSTR ptszVal);
BOOL PASCAL RegSetValuePtsz(HKEY hk, LPCTSTR ptszSubkey, LPCTSTR ptszVal);

BOOL PASCAL SetRegInt(HHK hhk, LPCSTR pszKey, LPCSTR pszSubkey, UINT ui);
BOOL PASCAL SetIntPkl(UINT ui, PKL pkl);

BOOL PASCAL SetRegDword(HHK hhk, LPCSTR pszKey, LPCSTR pszSubkey, DWORD dw);
BOOL PASCAL SetDwordPkl(PKL pkl, DWORD dw);

BOOL PASCAL SetRegDword2(HHK hhk, LPCSTR pszKey, LPCSTR pszSubkey, DWORD dw);
BOOL PASCAL SetDwordPkl2(PKL pkl, DWORD dw);

BOOL PASCAL DelPkl(PKL pkl);

/*****************************************************************************
 *
 *  prsht.c
 *
 *  Property sheet hacks.
 *
 *****************************************************************************/

int CALLBACK
Prsht_PropertySheetCallback(HWND hwnd, UINT pscb, LPARAM lp);

/*****************************************************************************
 *
 *  Manual import tables
 *
 *  Before expanding MIT_Contents, set MIT_Item either to
 *
 *      #define MIT_Item(a,b) a         // Emit the function type
 *  or  #define MIT_Item(a,b) b         // Emit the ordinal
 *
 *****************************************************************************/

#define MIT_Contents \
MIT_Item(BOOL (WINAPI *SHGetNewLinkInfo)(LPCSTR, LPCSTR, LPSTR, BOOL *, UINT), 179) \
MIT_Item(int (WINAPI *Shell_GetCachedImageIndex)(PV, int, UINT), 72) \
MIT_Item(BOOL (WINAPI *ReadCabinetState)(LPCABINETSTATE, int), MAKELONG(651, 1)) \
MIT_Item(BOOL (WINAPI *WriteCabinetState)(LPCABINETSTATE), MAKELONG(652, 1)) \
MIT_Item(HRESULT (WINAPI *SHCoCreateInstance)(LPCSTR, const CLSID *, PUNK, \
                                       REFIID, PPV), 102) \
MIT_Item(LPITEMIDLIST (WINAPI *SHSimpleIDListFromPath)(LPCVOID pszPath), 162) \

#define MIT_Item(a, b) a;               /* Emit the prototype */

typedef struct MIT {                    /* manual import table */
    MIT_Contents
} MIT, *PMIT;

#undef MIT_Item

extern MIT mit;

/*****************************************************************************
 *
 *  Globals
 *
 *****************************************************************************/

extern char g_tszName[80];              /* Program name goes here */
extern char g_tszMsdosSys[];            /* Boot file */

extern char g_tszPathShell32[MAX_PATH]; /* Full path to shell32.dll */
extern char g_tszPathMe[MAX_PATH];      /* Full path to myself */

extern PSF psfDesktop;                  /* Desktop IShellFolder */

extern UINT g_flWeirdStuff;
#define flbsComCtl32            1       /* Buggy ComCtl32 */
#define flbsSmoothScroll        2       /* ComCtl32 supports smoothscroll */
#define flbsOPK2                4       /* Windows 95 OPK2 */
#define flbsNT                  8       /* Windows NT */
#define flbsBadRun             16       /* I was run not via Control Panel */
#define flbsShellSz            32       /* Shell32 supports EXPAND_SZ */
#define flbsMemphis           0x0040    /* Windows 95 Memphis */
#define flbsMillennium        0x0080    /* Windows 95 Millennium */
#define flbsIE5               0x0100    /* IE5 is installed */
#define flbsNT5               0x0200    /* NT5 is installed */

#define g_fBuggyComCtl32        (g_flWeirdStuff & flbsComCtl32)
#define g_fSmoothScroll         (g_flWeirdStuff & flbsSmoothScroll)
#define g_fOPK2                 (g_flWeirdStuff & flbsOPK2)
#define g_fNT                   (g_flWeirdStuff & flbsNT)
#define g_fBadRun               (g_flWeirdStuff & flbsBadRun)
#define g_fShellSz              (g_flWeirdStuff & flbsShellSz)
#define g_fMemphis              (g_flWeirdStuff & flbsMemphis)
#define g_fMillennium           (g_flWeirdStuff & flbsMillennium)
#define g_fIE5                  (g_flWeirdStuff & flbsIE5)
#define g_fNT5                  (g_flWeirdStuff & flbsNT5)

extern HINSTANCE hinstCur;
extern DWORD g_dwShellVer;

#define g_fIE4      (g_dwShellVer >= MAKELONG(0, 0x0446)) /* 4.70 - IE4 + shell integration */
#define g_fShell5   (g_dwShellVer >= MAKELONG(0, 0x0500)) /* 5.00 - NT 5 */
#define g_fShell55  (g_dwShellVer >= MAKELONG(0, 0x0532)) /* 5.50 - Millennium or Neptune */

#define ctchClsid (1+ 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1)

#define ctchKeyMax (1+MAX_PATH)         /* According to the SDK */

/*****************************************************************************
 *
 *  Instanced
 *
 *  We're a cpl so have only one instance, but I declare
 *  all the instance stuff in one place so it's easy to convert this
 *  code to multiple-instance if ever we need to.
 *
 **************************************************************************/

typedef struct CDII {           /* common dialog instance info */
    HMENU hmenu;                /* The one menu everybody uses */
    HKEY  hkClsid;              /* HKCR\CLSID */
    HKEY  hkCUExplorer;         /* HKCU\REGSTR_PATH_EXPLORER */
    HKEY  hkLMExplorer;         /* HKLM\REGSTR_PATH_EXPLORER */
    HIML himlState;             /* Check-box state image imagelist */
    BOOL fRunShellInf;          /* Should I run shell.inf afterwards? */
    PIDL pidlTemplates;         /* Cached templates pidl */
} CDII, *PCDII;

extern CDII cdii;
#define pcdii (&cdii)

/**************************************************************************
 *
 * Local heap stuff
 *
 *  I have to do this because LocalAlloc takes the args in the order
 *  (fl, cb), but LocalReAlloc takes them in the order (cb, fl), and
 *  I invariably get them messed up.
 *
 **************************************************************************/

#define lAlloc(cb)      (void *)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cb)
#define lReAlloc(p, cb) (void *)LocalReAlloc((HLOCAL)(p), (cb), \
                                             LMEM_MOVEABLE | LMEM_ZEROINIT)
#define lFree(p)        LocalFree((HLOCAL)(p))

/*****************************************************************************
 *
 *  Set an empty rect, centered at the requested point.
 *
 *****************************************************************************/

INLINE void
SetRectPoint(LPRECT lprc, POINT pt)
{
    lprc->left = lprc->right = pt.x;
    lprc->top = lprc->bottom = pt.y;
}

/*****************************************************************************
 *
 *  Who'd 'a thunk it?
 *
 *****************************************************************************/

LPVOID PASCAL MapSL(DWORD lib);

WINSHELLAPI BOOL PASCAL Shell_GetImageLists(HIMAGELIST FAR *, HIMAGELIST FAR *);

/*****************************************************************************
 *
 *  expire.c
 *
 *****************************************************************************/

#if defined(PRERELEASE) || defined(PUBLIC_PRERELEASE)
BOOL PASCAL IsExpired(HWND hwnd);
#endif

/*****************************************************************************
 *
 *  secret.c
 *
 *****************************************************************************/

NTSTATUS
GetSecretDefaultPassword(
    LPWSTR PasswordBuffer, DWORD cchBuf
    );

NTSTATUS
SetSecretDefaultPassword(
    LPWSTR PasswordBuffer
    );

/*****************************************************************************
 *
 *  CWaitCursor
 *
 *  A little class for creating a wait cursor.
 *
 *****************************************************************************/

HCURSOR SetWaitCursor(void);

class CWaitCursor {
public:
    HCURSOR hcurPrev;
    inline CWaitCursor() { hcurPrev = SetWaitCursor(); }
    inline ~CWaitCursor() { if (hcurPrev) SetCursor(hcurPrev); }
};

#endif                          /* !RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tweakui\tweakhlp.h ===
/*
 * Shared help text.
 */
#define IDH_GROUP	 1
#define IDH_RESET        5

#define IDH_NONETHOOD	31

/*
 * IDD_GENERAL
 */

#define IDH_SPEEDHELP	32
#define IDH_DBLCLK	33
#define IDH_DRAG	34
#define IDH_TEST	37
#define IDH_XMOUSE      39
#define IDH_WHEEL       40
#define IDH_FOLDERNAME  41
#define IDH_IE3ENGINE   42
#define IDH_XMOUSERAISE 43
#define IDH_XMOUSEDELAY 44
#define IDH_RUDEAPP     45
#define IDH_RUDEAPPFLASH 46

/*
 * These items must be in order; general.c relies on it.
 */
#define IDH_ANIMATE             48
#define IDH_SMOOTHSCROLL        49
#define IDH_BEEP                50
#define IDH_MENUANIMATE         51
#define IDH_COMBOANIMATE        52
#define IDH_LBOXANIMATE         53
#define IDH_KEYBOARDCUES        54
#define IDH_HOTTRACK            55
#define IDH_MENUFADE            56
#define IDH_SELECTIONFADE       57
#define IDH_TOOLTIPANIMATION    58
#define IDH_TOOLTIPFADE         59
#define IDH_CURSORSHADOW        60
#define IDH_PAINTVERSION        61
/*
 * End of section that must be kept in order.
 */

/*
 * IDD_EXPLORER
 */

#define IDH_LINKEFFECT  64
#define IDH_TIPSTIP     65
#define IDH_COMPRESSCLR 66
#define IDH_HOTTRACKCLR 67

/*
 * These items must be in order; explorer.c relies on it.
 */
#define IDH_PREFIX          70
#define IDH_EXITSAVE        71
#define IDH_BANNER          72
#define IDH_WELCOME         73
#define IDH_MAKEPRETTY      74
#define IDH_CONNECTEDFILES  75
/*
 * End of section that must be kept in order.
 */

/*
 * IDD_DESKTOP
 */

#define IDH_ICONLV	96
#define IDH_CREATENOW	97
#define IDH_DESKFIRSTICON 98

/*
 * IDD_MYCOMP
 */

#define IDH_MYCOMP	112

/*
 * IDD_TOOLS
 */

#define IDH_TEMPLATE	128
#define IDH_TEMPLATEDEL	129

/*
 * IDD_BOOT
 */

#define	IDH_BOOTKEYS	160
#define	IDH_BOOTGUI	161
#define	IDH_LOGO	162
#define	IDH_BOOTMULTI	163
#define	IDH_BOOTMENU	164
#define	IDH_BOOTMENUDELAY 165
#define IDH_AUTOSCAN	166

/*
 * IDD_ADDREMOVE
 */

#define IDH_UNINSTALL	192
#define IDH_UNINSTALLNEW 193
#define IDH_UNINSTALLDELETE 194
#define IDH_UNINSTALLEDIT 195

/*
 * IDD_UNINSTALLEDIT
 */
#define IDH_UNINSTALLEDITDESC 224
#define IDH_UNINSTALLEDITCOMMAND 225

/*
 * IDD_REPAIR
 */
#define IDH_REPAIR              256

/*
 * IDD_PARANOIA
 */
#define IDH_CLEARLV             288
/*
 * These items must be in order; paranoia.c relies on it.
 */
#define IDH_CLEARRUN            289
#define IDH_CLEARFINDDOCS       290
#define IDH_CLEARFINDCOMP       291
#define IDH_CLEARDOC            292
#define IDH_CLEARURL            293
#define IDH_CLEARNETUSE         294
#define IDH_CLEARUSER           295
#define IDH_CLEARTELNET         296
/*
 * End of section that must be kept in order.
 */
#define IDH_CLEARNOW            300
#define IDH_CDROMAUDIO          301
#define IDH_CDROMDATA           302
#define IDH_FAULTLOG            303


/*
 * IDD_NETWORK
 */

#define IDH_AUTOLOGON		320
#define IDH_AUTOLOGONUSER	321
#define IDH_AUTOLOGONPASS	322
#define IDH_LOGONSHUTDOWN       323

/*
 *  IDD_IE4
 */
#define IDH_IE4LV               352

/*
 * These items must be in order; IE4.c relies on it.
 */
#define IDH_SHOWINTERNET        353
#define IDH_ADDTODOCSMENU       354
#define IDH_SHOWDOCSMENU        355
#define IDH_ACTIVEDESKTOP       356
#define IDH_CHANGEACTIVEDESKTOP 357
#define IDH_FAVORITESMENU       358
#define IDH_CLEARHISTORIES      359
#define IDH_NEWSHELL            360
#define IDH_LOGOFF              361
#define IDH_ACCIDENTAL2CLK      362
#define IDH_FAVLINKS            363
#define IDH_HELPONSTARTMENU     364
#define IDH_CPLONSTARTMENU      365
#define IDH_NETONSTARTMENU      366
#define IDH_WINKEYS             367
#define IDH_COMPNEARME          368
#define IDH_MYDOCSONSTARTMENU   369
#define IDH_MYPICSONSTARTMENU   370
/*
 * End of section that must be kept in order.
 */

/*
 *  IDD_CMD
 */
#define IDH_CMDFILECOMP         416
#define IDH_CMDDIRCOMP          417

/*
 *  IDD_COMDLG32
 */
#define IDH_CDBACKBUTTON        448
#define IDH_CDFILEMRU           449
#define IDH_CDPLACESBAR         450
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tweakui\tweakui.cpp ===
/*
 * tweakui - User interface customization
 */

#include "tweakui.h"
#include <string.h>

/*
 *  Because prsht.h doesn't define it.
 */

typedef struct _PROPSHEETPAGE_V1 {
        DWORD           dwSize;
        DWORD           dwFlags;
        HINSTANCE       hInstance;
        union {
            LPCSTR          pszTemplate;
            LPCDLGTEMPLATE  pResource;
        } DUMMYUNIONNAME;
        union {
            HICON       hIcon;
            LPCSTR      pszIcon;
        } DUMMYUNIONNAME2;
        LPCTSTR         pszTitle;
        DLGPROC         pfnDlgProc;
        LPARAM          lParam;
        LPFNPSPCALLBACK pfnCallback;
        UINT FAR * pcRefParent;
} PROPSHEETPAGE_V0, *LPPROPSHEETPAGE_V0;

#pragma BEGIN_CONST_DATA

HKEY CODESEG c_hkCR = hkCR;
HKEY CODESEG c_hkCU = hkCU;
HKEY CODESEG c_hkLM = hkLM;

KL const c_klNoRegedit = { &g_hkCUSMWCV, c_tszPoliciesSystem, c_tszNoRegedit };
KL const c_klIEVersion = { &g_hkLMSMIE, NULL, c_tszVersion };

#pragma END_CONST_DATA

/*
 * Globals
 */
TCH g_tszName[80];		/* Program name goes here */
TCH g_tszMsdosSys[] = TEXT("@:\\MSDOS.SYS"); /* Boot file */

TCH g_tszPathShell32[MAX_PATH];	/* Full path to shell32.dll */
TCH g_tszPathMe[MAX_PATH];	/* Full path to myself */

PSF psfDesktop;			/* Desktop IShellFolder */

HKEY g_hkLMSMWCV;		/* HKLM\Software\MS\Win\CurrentVer */
HKEY g_hkCUSMWCV;		/* HKCU\Software\MS\Win\CurrentVer */
HKEY g_hkLMSMIE;		/* HKLM\Software\MS\IE */
HKEY g_hkCUSMIE;		/* HKCU\Software\MS\IE */

HKEY g_hkLMSMWNTCV;		/* HKLM\Software\MS\Win (NT)?\CurrentVer */

HINSTANCE hinstCur;
DWORD g_dwShellVer;

UINT g_flWeirdStuff;		/* What components are weird */

#define MIT_Item(a, b) b,       /* Emit the ordinal and tag */

/*
 *  LOWORD(c_umit[iit]) == ordinal to obtain
 *  HIWORD(c_umit[iit]) == 1 if we can survive without the function
 */
const DWORD c_umit[] = {
    MIT_Contents
};
#undef MIT_Item

MIT mit;

/*
 * Instanced
 */
CDII cdii;

/*****************************************************************************
 *
 *  iFromPtsz
 *
 *	Parse an integer out of a string, skipping leading spaces.
 *	Returns iErr on error.
 *
 *****************************************************************************/

int PASCAL
iFromPtsz(LPTSTR ptsz)
{
    int i;
    int sign;

    while (*ptsz == ' ') ptsz++;
    if (*ptsz == '-') {
	sign = -1;
	ptsz++;
    } else {
	sign = 1;
    }

    for (i = 0; (unsigned)(*ptsz - '0') < 10; ptsz++) {
      i = i * 10 + (*ptsz - '0');
      if (i < 0) return iErr;
    }
    return sign * i;
}

/*****************************************************************************
 *
 *  StrChr
 *
 *	Return the first occurrence of ch in psz, or 0 if none.
 *
 *****************************************************************************/

LPTSTR PASCAL
ptszStrChr(LPCTSTR ptsz, TCH tch)
{
    for ( ; *ptsz; ptsz = CharNext(ptsz)) {
	if (*ptsz == tch) return (LPTSTR)ptsz;
    }
    return 0;
}

/*****************************************************************************
 *
 *  ParseIconSpec
 *
 *	Given an icon spec of the form "DLL,icon", parse out the icon
 *	index and return it, changing the comma to a null, so that the
 *	remaining stuff is a valid DLL name.
 *
 *	If no comma is found, then the entire string is a DLL name,
 *	and the icon index is zero.
 *
 *****************************************************************************/

int PASCAL
ParseIconSpec(LPTSTR ptszSrc)
{
    LPTSTR ptsz = ptszStrChr(ptszSrc, ',');
    if (ptsz) {
	*ptsz = '\0';
	return iFromPtsz(ptsz+1);
    } else {
	return 0;
    }
}

/*****************************************************************************
 *
 *  LoadIconId
 *
 *  Load an icon by identifier.
 *
 *****************************************************************************/

HICON PASCAL
LoadIconId(UINT id)
{
    return LoadIcon(hinstCur, MAKEINTRESOURCE(id));
}

/*****************************************************************************
 *
 *  SafeDestroyIcon
 *
 *  DestroyIcon, except it doesn't try to destroy the null icon.
 *
 *****************************************************************************/

void PASCAL
SafeDestroyIcon(HICON hicon)
{
    if (hicon) {
	DestroyIcon(hicon);
    }
}

/*****************************************************************************
 *
 *  InitOpenFileName
 *
 *  Initialize a COFN structure.
 *
 *****************************************************************************/

void PASCAL
InitOpenFileName(HWND hwnd, PCOFN pcofn, UINT ids, LPCSTR pszInit)
{
    int itchMax;
    TCH tch;

    ZeroMemory(&pcofn->ofn, sizeof(pcofn->ofn));
    pcofn->ofn.lStructSize |= sizeof(pcofn->ofn);
    pcofn->ofn.hwndOwner = hwnd;
    pcofn->ofn.lpstrFilter = pcofn->tszFilter;
    pcofn->ofn.lpstrFile = pcofn->tsz;
    pcofn->ofn.nMaxFile = MAX_PATH;
    pcofn->ofn.Flags |= OFN_HIDEREADONLY;

    /* Get the filter string */
    itchMax = LoadString(hinstCur, ids, pcofn->tszFilter, cA(pcofn->tszFilter));

    if (itchMax) {
        /* Marker character must not be DBCS */
        tch = pcofn->tszFilter[itchMax-1];
        LPTSTR ptsz = pcofn->tszFilter;
        while (ptsz < &pcofn->tszFilter[itchMax]) {
            if (*ptsz == tch) *ptsz++ = '\0';
            else ptsz = CharNext(ptsz);
        }
    }

    /* Set the initial value */
    lstrcpyn(pcofn->tsz, pszInit, cA(pcofn->tsz));
}

/*****************************************************************************
 *
 *  MessageBoxId
 *
 *  Wrapper for MessageBox that uses an id instead of a string.
 *
 *****************************************************************************/

int PASCAL
MessageBoxId(HWND hwnd, UINT id, LPCSTR pszTitle, UINT fl)
{
    char szBuf[256];
    LoadString(hinstCur, id, szBuf, cA(szBuf));
    return MessageBox(hwnd, szBuf, pszTitle, fl);
}

/*****************************************************************************
 *
 *  TweakUi_TrimTrailingBs
 *
 *	Bs stands for backslash.  Returns pointer to trailing 0.
 *
 *****************************************************************************/

PTSTR PASCAL
TweakUi_TrimTrailingBs(LPTSTR ptsz)
{
    ptsz = ptszFilenameCqn(ptsz);
    if (ptsz[0] == TEXT('\0')) {
	*--ptsz = TEXT('\0');
    } else {
	ptsz += lstrlen(ptsz);
    }
    return ptsz;
}

/*****************************************************************************
 *
 *  TweakUi_BuildPathToFile
 *
 *	Callback procedure (GetWindowsDirectory or GetSystemDirectory)
 *	generates the base directory.  Then we cat the file to the path.
 *
 *	ptszOut must be MAX_PATH bytes in length.
 *
 *****************************************************************************/

typedef UINT (CALLBACK *PATHPROC)(LPTSTR, UINT);

void PASCAL
TweakUi_BuildPathToFile(PTSTR ptszOut, PATHPROC pfn, LPCTSTR ptszFile)
{
    pfn(ptszOut, MAX_PATH);
    Path_Append(ptszOut, ptszFile);
}

/*****************************************************************************
 *
 *  BuildRundll
 *
 *	ptszOut must be 1024 bytes in length.
 *
 *	ptszInUn is "I" for DefaultInstall, and "Uni" for DefaultUninstall.
 *
 *	Builds the string
 *
 *	"<windir>\rundll.exe setupx.dll,InstallHinfSection Default<x>nstall 4 "
 *
 *	Returns a pointer to the terminating null, so you can put the
 *	inf file name into place.
 *
 *****************************************************************************/

LPTSTR PASCAL
BuildRundll(LPTSTR ptszOut, LPCTSTR ptszInUn)
{
    TCH tszWindir[MAX_PATH];
    TweakUi_BuildPathToFile(tszWindir, GetWindowsDirectory, c_tszNil);
    return ptszOut + wsprintf(ptszOut, g_fNT ?
		 c_tszFormatRundllNT : c_tszFormatRundll, tszWindir, ptszInUn);
}

/*****************************************************************************
 *
 *  RunShellInf
 *
 *	Re-run the shell.inf file to fix the registry.
 *
 *	The bad news is that CtlGetLdidPath is 16-bit, and we aren't.
 *
 *	The "good" news is that there is currently no override to
 *	put the Inf directory anywhere other than Windows\Inf, so we
 *	can hard-code the Inf subdirectory name.
 *
 *****************************************************************************/

void PASCAL
RunShellInf(HWND hwnd)
{
    TCH tszOut[1024];
    TweakUi_BuildPathToFile(BuildRundll(tszOut, c_tszI), GetWindowsDirectory,
			    c_tszInfBsShellInf);
    WinExec(tszOut, SW_NORMAL);
}

/*****************************************************************************
 *
 *  InitPpspDidDp
 *
 *	Initialize a single PROPSHEETPAGE to load the dialog resource did
 *	with dialog procedure dp.
 *
 *      We must use the original property sheet page structure because
 *      we need to run on Win95 Golden, which has the old comctl32.
 *
 *      In particular, we cannot use DS_SHELLFONT because the old comctl32
 *      does not support DIALOGEX, which DS_SHELLFONT requires.
 *
 *****************************************************************************/

void PASCAL
InitPpspResDp(LPPROPSHEETHEADER ppsh, LPCTSTR ptszDlg, DLGPROC dp)
{
    LPPROPSHEETPAGE_V0 ppsp;

#ifdef DEBUG
    if (ppsh->nPages >= MAX_TWEAKUIPAGES) {
	DebugBreak();
    }

    {
        HRSRC hrsrc = FindResource(hinstCur, ptszDlg, RT_DIALOG);
        LPDLGTEMPLATE pdt = (LPDLGTEMPLATE)LoadResource(hinstCur, hrsrc);
        if (pdt && HIWORD(pdt->style) != 0xFFFF) {
            /* Template is okay */
        } else {
            /* ERROR!  Win95 Golden does not support DIALOGEX */
            DebugBreak();
        }
    }

#endif
    ppsp = (LPPROPSHEETPAGE_V0)ppsh->ppsp;
    ppsp = &ppsp[ppsh->nPages++];

    ppsp->dwSize      = sizeof(PROPSHEETPAGE_V0);
    ppsp->dwFlags     = PSP_DEFAULT;
    ppsp->hInstance   = hinstCur;
    ppsp->pszTemplate = ptszDlg;
    ppsp->pfnDlgProc  = dp;
/*  ppsp->lParam      = ??; */		/* No refdata needed */
}

#define InitPpspDidDp(ppsh, did, dp) \
        InitPpspResDp(ppsh, MAKEINTRESOURCE(did), dp)

/*****************************************************************************
 *
 *  Open
 *
 *	Start the show.
 *
 *****************************************************************************/

void PASCAL
Open(HWND hwnd)
{
    PROPSHEETPAGE_V0 rgpsp[MAX_TWEAKUIPAGES];
    PROPSHEETHEADER psh;

    /*
     *  Make us Alt+Tab'able by removing WS_EX_TOOLWINDOW from our
     *  parent's extended window style.
     */
    SetWindowLong(hwnd, GWL_EXSTYLE,
                      (LONG)(GetWindowExStyle(hwnd) & ~WS_EX_TOOLWINDOW));

    /*
     *  Give our hidden parent an icon so the user can Alt+Tab to it.
     */
    SendMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM)
                LoadIcon(hinstCur, MAKEINTRESOURCE(IDI_DEFAULT)));

    /* Init our cached pidls */
    pcdii->pidlTemplates = NULL;
    SHGetSpecialFolderLocation(0, CSIDL_TEMPLATES, &pcdii->pidlTemplates);

    psh.dwSize      = PROPSHEETHEADER_V1_SIZE;
    psh.dwFlags     = PSH_PROPSHEETPAGE | PSH_USECALLBACK;
    psh.hwndParent  = hwnd;
    psh.pszCaption  = g_tszName;
    psh.nPages      = 0;
    psh.nStartPage  = 0;
    psh.ppsp        = (PROPSHEETPAGE*)rgpsp;
    psh.pfnCallback = Prsht_PropertySheetCallback;

    InitPpspDidDp(&psh, IDD_MOUSE, Mouse_DlgProc);
    InitPpspDidDp(&psh, IDD_GENERAL, General_DlgProc);
    InitPpspDidDp(&psh, IDD_EXPLORER, Explorer_DlgProc);

    /*
     *  Display IE4 only if IE4 is installed.
     */
    if (g_fIE4) {
        InitPpspDidDp(&psh, IDD_IE4, IE4_DlgProc);
    }

    /*
     *  Display CMD only if NT5 is installed.
     */
    if (g_fNT5) {
        InitPpspDidDp(&psh, IDD_CMD, Cmd_DlgProc);
    }

    InitPpspDidDp(&psh, IDD_DESKTOP, Desktop_DlgProc);

    /*
     * Display My Computer only if the user has permission to
     * edit the appropriate registry key.
     */
    if (RegCanModifyKey(g_hkCUSMWCV, c_tszRestrictions)) {
	InitPpspDidDp(&psh, IDD_MYCOMP, MyComp_DlgProc);
    }

    InitPpspDidDp(&psh, IDD_CONTROL, Control_DlgProc);

    /*
     * Display Network only if the user has permission to
     * edit the appropriate registry key.
     */
    if (RegCanModifyKey(g_hkLMSMWNTCV, c_tszWinlogon)) {
        InitPpspDidDp(&psh, IDD_NETWORK, Network_DlgProc);
    }

    if (pcdii->pidlTemplates) {
        InitPpspDidDp(&psh, IDD_TOOLS, Template_DlgProc);
    }

    /*
     *  Add/Remove Programs on NT5 is completely different.
     */
    if (!g_fNT5) {
        InitPpspDidDp(&psh, IDD_ADDREMOVE, AddRm_DlgProc);
    }

#ifdef _X86_
    if (g_tszMsdosSys[0] && !g_fNT && !g_fMillennium) {
	InitPpspDidDp(&psh, IDD_BOOT, Boot_DlgProc);
    }
#endif
    InitPpspDidDp(&psh, IDD_REPAIR, Repair_DlgProc);
    InitPpspDidDp(&psh, IDD_PARANOIA, Paranoia_DlgProc);

    /*
     *  Common dialog features.
     */
    if (RegCanModifyKey(g_hkCUSMWCV, TEXT("Policies")) &&
        GetProcAddress(GetModuleHandle("COMDLG32"), "PrintDlgExA"))
    {
      InitPpspDidDp(&psh, IDD_COMDLG32, Comdlg32_DlgProc);
    }


    pcdii->hmenu = LoadMenu(hinstCur, MAKEINTRESOURCE(IDM_MAIN));
    _RegOpenKey(HKEY_CLASSES_ROOT, c_tszClsid, &pcdii->hkClsid);
    pcdii->himlState = ImageList_LoadImage(hinstCur, MAKEINTRESOURCE(IDB_CHECK),
			    0, 2, CLR_NONE, IMAGE_BITMAP, LR_LOADTRANSPARENT);
    pcdii->fRunShellInf = 0;

#ifndef DEBUG
    /* Reinstall our run key in case somebody nuked it */
    SetRegStr(g_hkLMSMWCV, c_tszRun, g_tszName, c_tszFixLink);
#endif

#if defined(PRERELEASE) || defined(PUBLIC_PRERELEASE)
    if (!IsExpired(hwnd))
#endif

    switch (PropertySheet(&psh)) {
    case ID_PSRESTARTWINDOWS:
	if (pcdii->fRunShellInf) {
	    RunShellInf(hwnd);
	}
	MessageBoxId(hwnd, IDS_LOGONOFF, g_tszName, MB_OK);
	break;
    }

    RegCloseKey(pcdii->hkClsid);
    if (pcdii->hmenu)
        DestroyMenu(pcdii->hmenu);

    /* Now free them cached shell things */
    Ole_Free(pcdii->pidlTemplates);
}

/*****************************************************************************
 *
 *  TweakUi_OnBadRun
 *
 *	Somebody double-clicked our icon, but we aren't being run as
 *	a control panel.  Offer to install.
 *
 *****************************************************************************/

void PASCAL
TweakUi_OnBadRun(HWND hwnd)
{
    if (MessageBoxId(hwnd, IDS_BADRUN, g_tszName, MB_YESNO) == IDYES) {
	TCH tszOut[1024];
	PTSTR ptsz;
	ptsz = BuildRundll(tszOut, c_tszI);
	lstrcpy(ptsz, g_tszPathMe);
        PTSTR ptszExt = ptszStrRChr(ptsz, TEXT('.'));
        if (ptszExt) {
            strcpy(ptszExt, c_tszDotInf);
            if (GetFileAttributes(ptsz) != (DWORD)-1) {
                WinExec(tszOut, SW_NORMAL);
            } else {
                MessageBoxId(hwnd, IDS_CANTINSTALL, g_tszName, MB_OK);
            }
        } else {
            MessageBoxId(hwnd, IDS_CANTINSTALL, g_tszName, MB_OK);
        }
    }
}


/*****************************************************************************
 *
 *  CriticalInit
 *
 *	Here is where we put the stuff to impede reverse-engineering.
 *
 *	1.  All of our strings are encoded.  Decode them now.
 *
 *	2.  Get the shell32 internal entry points via GetProcAddress
 *	    so that a "hdr" won't see them.
 *
 *****************************************************************************/

HRESULT PASCAL
CriticalInit(void)
{
    int itch;
    int iit;
    HINSTANCE hinst;

    itch = cA(c_rgtchCommon)-1;
    do {
	c_rgtchCommon[itch] ^= c_rgtchCommon[itch-1];
    } while (--itch);

    hinst = GetModuleHandle(c_tszShell32Dll);
    for (iit = 0; iit < sizeof(mit) / sizeof(LPCSTR); iit++) {
	DWORD dwOrd = c_umit[iit];
	((FARPROC *)&mit)[iit] = GetProcAddress(hinst, MAKEINTRESOURCE(dwOrd));
	if (((FARPROC *)&mit)[iit] == 0 && !HIWORD(dwOrd)) {
	    return E_FAIL;
	}
    }
    return Ole_Init();
}

/*****************************************************************************
 *
 *  GetObjectBuild
 *
 *      Get the build number on the specified module, in the form
 *
 *              0xMMmmbbbb
 *
 *      MM = major
 *      mm = minor
 *      bbbb = build
 *
 *      The input parameter is either an OSVERSIONINFO or a DLLVERSIONINFO.
 *	Fortunately, the two are the same in the places we care about.
 *
 *****************************************************************************/

DWORD PASCAL
GetObjectBuild(LPOSVERSIONINFO posv)
{
    return MAKELONG(LOWORD(posv->dwBuildNumber),
                    MAKEWORD(posv->dwMinorVersion,
                             posv->dwMajorVersion));
}

/*****************************************************************************
 *
 *  GetModuleBuild
 *
 *      Get the build number on the specified module, in the form
 *
 *              0xMMmmbbbb
 *
 *      MM = major
 *      mm = minor
 *      bbbb = build
 *
 *      Returns 0 if DLL does not have DllGetVersion.
 *
 *****************************************************************************/

DWORD PASCAL
GetModuleBuild(LPCTSTR ptszDll)
{
    HINSTANCE hinst = GetModuleHandle(ptszDll);
    DLLGETVERSIONPROC DllGetVersion;
    DWORD dwRc;
    DllGetVersion = (DLLGETVERSIONPROC)GetProcAddress(hinst, "DllGetVersion");
    if (DllGetVersion) {
	DLLVERSIONINFO dvi;
	dvi.cbSize = sizeof(dvi);
	if (SUCCEEDED(DllGetVersion(&dvi))) {
	    dwRc = GetObjectBuild((LPOSVERSIONINFO)&dvi);
	} else {
	    dwRc = 0;
	}
    } else {
	dwRc = 0;
    }
    return dwRc;
}

/*****************************************************************************
 *
 *  CheckWin95Versions
 *
 *	Determine whether we're on Win95 OPK2 or later.  We already know
 *	that we're not Windows NT.
 *
 *****************************************************************************/

void PASCAL
CheckWin95Versions(void)
{
    BOOL fRc;
    OSVERSIONINFO osv;
    osv.dwOSVersionInfoSize = sizeof(osv);
    if (GetVersionEx(&osv)) {
        DWORD dwBuild = GetObjectBuild(&osv);
        if (dwBuild >= MAKELONG(1045, 0x0400)) {
            g_flWeirdStuff |= flbsOPK2;
            if (dwBuild >= MAKELONG(0, 0x040A)) {
                g_flWeirdStuff |= flbsMemphis;
                if (dwBuild >= MAKELONG(0, 0x045A)) {
                    g_flWeirdStuff |= flbsMillennium;
                }
            }
        }
    }
}

/*****************************************************************************
 *
 *  LibMain
 *
 *	Initialize globals.
 *
 *	Get our own name.
 *
 *	Get our own path.
 *
 *	Build path to shell32.dll.
 *
 *****************************************************************************/

BOOL FAR PASCAL LibMain(HINSTANCE hinst)
{
    if (SUCCEEDED(CriticalInit())) {
	DWORD dwBuild;
        DWORD dwVersion;

	RegCreateKey(HKEY_LOCAL_MACHINE, c_tszSMWCV, &g_hkLMSMWCV);
	RegCreateKey(HKEY_CURRENT_USER, c_tszSMWCV, &g_hkCUSMWCV);
	RegCreateKey(g_hkLMSMWCV, c_tszExplorer, &pcdii->hkLMExplorer);
	RegCreateKey(g_hkCUSMWCV, c_tszExplorer, &pcdii->hkCUExplorer);

	RegOpenKey(hkLM, c_tszSMWIE, &g_hkLMSMIE);
	RegOpenKey(hkCU, c_tszSMWIE, &g_hkCUSMIE);

	hinstCur = hinst;
	LoadString(hinst, IDS_NAME, g_tszName, cA(g_tszName));

	dwBuild = GetModuleBuild(c_tszComCtl32Dll);
	if (dwBuild == 0) {
	    g_flWeirdStuff |= flbsComCtl32;
	}

        if (dwBuild >= MAKELONG(0, 0x447)) {     /* 4.71 */
	    g_flWeirdStuff |= flbsSmoothScroll;
	}

        dwVersion = GetVersion();
        if ((LONG)dwVersion >= 0) {
            g_flWeirdStuff |= flbsNT;
            if (LOBYTE(dwVersion) >= 5) {
                g_flWeirdStuff |= flbsNT5;
            }
        } else {
            CheckWin95Versions();
        }

        g_dwShellVer = dwBuild = GetModuleBuild(c_tszShell32Dll);
        if (dwBuild || g_fNT) {
	    g_flWeirdStuff |= flbsShellSz;
        }

        /*
         *  Some things need to be turned off if IE5.  Go figure.
         *  Borrow g_tszPathMe for scratch space.
         */
        if (GetStrPkl(g_tszPathMe, cA(g_tszPathMe), &c_klIEVersion) &&
            iFromPtsz(g_tszPathMe) >= 5) {
            g_flWeirdStuff |= flbsIE5;
        }

	GetModuleFileName(hinst, g_tszPathMe, cA(g_tszPathMe));

	/*
	 *  Check if we're being run from the proper directory.
	 */
	TweakUi_BuildPathToFile(g_tszPathShell32, GetSystemDirectory,
			        c_tszTweakUICpl);
	if (lstrcmpi(g_tszPathMe, g_tszPathShell32)) {
#ifndef DEBUG
	    g_flWeirdStuff |= flbsBadRun;		/* Nope */
#endif
	}

	/*
	 *  Stash the location of shell32.
	 */
	TweakUi_BuildPathToFile(g_tszPathShell32, GetSystemDirectory,
			        c_tszShell32Dll);

	/* See if we have an msdos.sys file to tweak */

#if defined(_X86_)

	Boot_FindMsdosSys();

#endif

	/*
	 *  Build the platform-sensitive base key.
	 */
	RegCreateKey(hkLM, g_fNT ? c_tszSMWNTCV : c_tszSMWCV, &g_hkLMSMWNTCV);

	InitCommonControls();

	return 1;
    } else {
	return 0;
    }
}

/*****************************************************************************
 *
 *  LibExit
 *
 *	Clean up globals.
 *
 *****************************************************************************/

void PASCAL
LibExit(void)
{
    if (g_hkCUSMIE) {
	RegCloseKey(g_hkCUSMIE);
    }
    if (g_hkLMSMIE) {
	RegCloseKey(g_hkLMSMIE);
    }
    RegCloseKey(pcdii->hkCUExplorer);
    RegCloseKey(pcdii->hkLMExplorer);
    RegCloseKey(g_hkLMSMWCV);
    RegCloseKey(g_hkLMSMWNTCV);
    RegCloseKey(g_hkCUSMWCV);
    Ole_Term();
}

/*****************************************************************************
 *
 *  _DllMainCRTStartup
 *
 *	Hi.
 *
 *****************************************************************************/

STDAPI_(BOOL)
Entry32(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH) {
	return LibMain(hinst);
    } else if (dwReason == DLL_PROCESS_DETACH) {
	LibExit();
    }
    return TRUE;
}

/*****************************************************************************
 *
 *  CPlApplet
 *
 *	Control panel entry point.
 *
 *****************************************************************************/

LRESULT EXPORT
CPlApplet(HWND hwnd, UINT wm, LPARAM lp1, LPARAM lp2)
{
    switch (wm) {
    case CPL_INIT: return 1;		/* Yes I'm here */

    case CPL_GETCOUNT: return 1;	/* I provide one icon */

    case CPL_INQUIRE:
	if (lp1 == 0) {			/* For the zero'th icon... */
	    LPCPLINFO lpci = (LPCPLINFO)lp2;
	    lpci->idIcon = IDI_DEFAULT;
	    lpci->idName = IDS_NAME;
	    lpci->idInfo = IDS_DESCRIPTION;
	    /* lpci->lData  = 0; */	/* Garbage doesn't hurt */
	    return 1;
	} else {
	    return 0;			/* Huh? */
	}

/*
 *	Note!  Do not open if registry tools have been disabled.
 *
 *	This is particularly important for the Network page, which
 *	lets the user view passwords!
 *
 *	Make this check *before* checking for a bad run, so a
 *	user can't do an end-run by just double-clicking the CPL.
 */
    case CPL_DBLCLK:			/* Hey, somebody's knocking */
	if (GetDwordPkl(&c_klNoRegedit, 0)) {
	    MessageBoxId(hwnd, IDS_RESTRICTED, g_tszName, MB_OK);
	} else if (!g_fBadRun) {
	    Open(hwnd);
	} else {
	    TweakUi_OnBadRun(hwnd);
	}
	break;
    }

    return 0;
}

/*****************************************************************************
 *
 *  WithSelector
 *
 *  Call the callback after creating a particular selector alias to a
 *  chunk of memory.  The memory block is confirmed for read access,
 *  or for write access if fWrite is set.
 *
 *  Note that the validation doesn't work in Win16 if the data crosses
 *  a page boundary, so be careful.
 *
 *****************************************************************************/

BOOL PASCAL
WithSelector(DWORD_PTR lib, UINT cb, WITHPROC wp, LPVOID pvRef, BOOL fWrite)
{
    BOOL fRc;

#ifdef WIN32
    #define lpv (LPVOID)lib
#else
    UINT sel = AllocSelector((UINT)hinstCur);
    if (sel) {
	SetSelectorBase(sel, lib);
	SetSelectorLimit(sel, cb);
	#define lpv MAKELP(sel, 0)
#endif
	if (!IsBadReadPtr(lpv, cb) && !(fWrite && IsBadWritePtr(lpv, cb))) {
	    fRc = wp(lpv, pvRef);
	} else {
	    fRc = 0;
	}
	#undef lpv
#ifndef WIN32
	FreeSelector(sel);
    } else {
	fRc = 0;
    }
#endif
    return fRc;
}

/*****************************************************************************
 *
 *  TweakUi_OnLogon
 *
 *  This hacks around two bugs.
 *
 *  The first is a bug in Shell32, where a bad comparison causes the
 *  Link registry key not to be restored properly.  So we patch the
 *  correct value into the registry for them.
 *
 *  The second is a bug in commctrl where it gets confused by overlay
 *  bitmaps with no pixels.
 *
 *  And then we do the paranoia stuff.
 *
 *****************************************************************************/

void PASCAL
TweakUi_OnLogon(void)
{
    UINT cxIcon;

    /*
     *  This shell bug was fixed sometime before July 1997, though I
     *  can't tell exactly when.  Definitely fixed before the ShellSz
     *  support was added, so let's just use that.
     */
    if (!g_fShellSz && !Link_GetShortcutTo()) {
	Link_SetShortcutTo(1);
	Link_SetShortcutTo(0);
    }

    /*
     *	If the shell icon size is wacked out for some bizarre reason,
     *	then unwack it.  This is theoretically impossible, but somehow
     *	it happens, so we fix it ex post facto.
     */
    cxIcon = Misc_GetShellIconSize();
    if (((cxIcon + 1) & 0x1F) == 0) {
	Misc_SetShellIconSize(cxIcon + 1);
    }

    Explorer_HackPtui();
    Paranoia_CoverTracks();
}

/*****************************************************************************
 *
 *  TweakUi_OnInstall
 *
 *  Upgrade the previous version of Tweak UI.
 *
 *  1.	Fix the LinkOverlay gizmo.  If we have a buggy ComCtl32 and the
 *	overlay is set to IDI_BLANK - 1, then set HackPtui.
 *
#ifdef UPGRADE_V1_ICON
 *  2.	Rebuild the icon cache, to work around a bug in the control panel,
 *      where it doesn't update its cached image properly when the cpl changes.
#endif
 *
 *****************************************************************************/

void PASCAL
TweakUi_OnInstall(void)
{
    TCHAR tsz[MAX_PATH];

    if (g_fBuggyComCtl32 &&
	Explorer_GetIconSpecFromRegistry(tsz) == IDI_BLANK - 1 &&
	lstrcmpi(tsz, g_tszPathMe) == 0) {
	    SetIntPkl(1, &c_klHackPtui);
    }

#ifdef UPGRADE_V1_ICON
    /*
     *  We no longer try to upgrade the V1 icon because it tickles
     *  the shell icon cache in a way that may expose pre-existing
     *  corruption.
     */
    Misc_RebuildIcoCache();
#endif

}

/*****************************************************************************
 *
 *  TweakUi_OnFix
 *
 *  Put our Uninstall script back into the registry.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

KL const c_klDisplayName =
    { &g_hkLMSMWCV, c_tszUninstallTweakUI, c_tszDisplayName };
KL const c_klUninstallString =
    { &g_hkLMSMWCV, c_tszUninstallTweakUI, c_tszUninstallString };

#pragma END_CONST_DATA

void EXPORT
TweakUi_OnFix(HWND hwnd, BOOL fVerbose)
{
    TCH tszOut[1024];
    SetStrPkl(&c_klDisplayName, g_tszName);
    TweakUi_BuildPathToFile(BuildRundll(tszOut, c_tszUni), GetWindowsDirectory,
			    c_tszInfBsTweakuiInf);
    SetStrPkl(&c_klUninstallString, tszOut);
    if (fVerbose) {
	MessageBoxId(hwnd, IDS_FIXED, g_tszName, MB_OK);
    }
}

/*****************************************************************************
 *
 *  TweakMeUp
 *
 *  Rundll entry point.
 *
 *  The command line tells us what we're trying to do.
 *
 *  Null command line - User has just logged on; do logon stuff.
 *
 *  '0' - We've just been installed; upgrade the previous version.
 *	  Since unisntalling on NT is different from on Win95, we fall
 *	  through to...
 *
 *  '1' - The user wants to restore the Uninstall string.
 *
 *****************************************************************************/

void EXPORT
TweakMeUp(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow)
{
    switch (lpszCmdLine[0]) {
    case '\0': TweakUi_OnLogon(); break;
    case '0': TweakUi_OnInstall(); TweakUi_OnFix(hwnd, 0); break;
    case '1': TweakUi_OnFix(hwnd, 1); break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tz\tz.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    tz.h

Abstract:

    This is the main include file for the Windows TZ (time zone utility)

Author:

    Steve Wood (stevewo) 16-May-1989

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>
#include <io.h>
#include <fcntl.h>
#include <malloc.h>
#include <sys\types.h>
#include <sys\stat.h>

#include <tools.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tztool\afxres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXRES_H__
#define __AFXRES_H__

#ifdef RC_INVOKED
#ifndef _INC_WINDOWS
#define _INC_WINDOWS
	#include "winres.h"           // extract from windows header
#endif
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// MFC resource types (see Technical note TN024 for implementation details)

#ifndef RC_INVOKED
#define RT_DLGINIT  MAKEINTRESOURCE(240)
#define RT_TOOLBAR  MAKEINTRESOURCE(241)
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// General style bits etc

// ControlBar styles
#define CBRS_ALIGN_LEFT     0x1000L
#define CBRS_ALIGN_TOP      0x2000L
#define CBRS_ALIGN_RIGHT    0x4000L
#define CBRS_ALIGN_BOTTOM   0x8000L
#define CBRS_ALIGN_ANY      0xF000L

#define CBRS_BORDER_LEFT    0x0100L
#define CBRS_BORDER_TOP     0x0200L
#define CBRS_BORDER_RIGHT   0x0400L
#define CBRS_BORDER_BOTTOM  0x0800L
#define CBRS_BORDER_ANY     0x0F00L

#define CBRS_TOOLTIPS       0x0010L
#define CBRS_FLYBY          0x0020L
#define CBRS_FLOAT_MULTI    0x0040L
#define CBRS_BORDER_3D      0x0080L
#define CBRS_HIDE_INPLACE   0x0008L
#define CBRS_SIZE_DYNAMIC   0x0004L
#define CBRS_SIZE_FIXED     0x0002L
#define CBRS_FLOATING       0x0001L

#define CBRS_GRIPPER        0x00400000L

#define CBRS_ORIENT_HORZ    (CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM)
#define CBRS_ORIENT_VERT    (CBRS_ALIGN_LEFT|CBRS_ALIGN_RIGHT)
#define CBRS_ORIENT_ANY     (CBRS_ORIENT_HORZ|CBRS_ORIENT_VERT)

#define CBRS_ALL            0x0040FFFFL

// the CBRS_ style is made up of an alignment style and a draw border style
//  the alignment styles are mutually exclusive
//  the draw border styles may be combined
#define CBRS_NOALIGN        0x00000000L
#define CBRS_LEFT           (CBRS_ALIGN_LEFT|CBRS_BORDER_RIGHT)
#define CBRS_TOP            (CBRS_ALIGN_TOP|CBRS_BORDER_BOTTOM)
#define CBRS_RIGHT          (CBRS_ALIGN_RIGHT|CBRS_BORDER_LEFT)
#define CBRS_BOTTOM         (CBRS_ALIGN_BOTTOM|CBRS_BORDER_TOP)

/////////////////////////////////////////////////////////////////////////////
// Standard window components

// Mode indicators in status bar - these are routed like commands
#define ID_INDICATOR_EXT                0xE700  // extended selection indicator
#define ID_INDICATOR_CAPS               0xE701  // cap lock indicator
#define ID_INDICATOR_NUM                0xE702  // num lock indicator
#define ID_INDICATOR_SCRL               0xE703  // scroll lock indicator
#define ID_INDICATOR_OVR                0xE704  // overtype mode indicator
#define ID_INDICATOR_REC                0xE705  // record mode indicator
#define ID_INDICATOR_KANA               0xE706  // kana lock indicator

#define ID_SEPARATOR                    0   // special separator value

#ifndef RC_INVOKED  // code only
// Standard control bars (IDW = window ID)
#define AFX_IDW_CONTROLBAR_FIRST        0xE800
#define AFX_IDW_CONTROLBAR_LAST         0xE8FF

#define AFX_IDW_TOOLBAR                 0xE800  // main Toolbar for window
#define AFX_IDW_STATUS_BAR              0xE801  // Status bar window
#define AFX_IDW_PREVIEW_BAR             0xE802  // PrintPreview Dialog Bar
#define AFX_IDW_RESIZE_BAR              0xE803  // OLE in-place resize bar
#define AFX_IDW_REBAR                   0xE804  // COMCTL32 "rebar" Bar
#define AFX_IDW_DIALOGBAR               0xE805  // CDialogBar

// Note: If your application supports docking toolbars, you should
//  not use the following IDs for your own toolbars.  The IDs chosen
//  are at the top of the first 32 such that the bars will be hidden
//  while in print preview mode, and are not likely to conflict with
//  IDs your application may have used succesfully in the past.

#define AFX_IDW_DOCKBAR_TOP             0xE81B
#define AFX_IDW_DOCKBAR_LEFT            0xE81C
#define AFX_IDW_DOCKBAR_RIGHT           0xE81D
#define AFX_IDW_DOCKBAR_BOTTOM          0xE81E
#define AFX_IDW_DOCKBAR_FLOAT           0xE81F

// Macro for mapping standard control bars to bitmask (limit of 32)
#define AFX_CONTROLBAR_MASK(nIDC)   (1L << (nIDC - AFX_IDW_CONTROLBAR_FIRST))

// parts of Main Frame
#define AFX_IDW_PANE_FIRST              0xE900  // first pane (256 max)
#define AFX_IDW_PANE_LAST               0xE9ff
#define AFX_IDW_HSCROLL_FIRST           0xEA00  // first Horz scrollbar (16 max)
#define AFX_IDW_VSCROLL_FIRST           0xEA10  // first Vert scrollbar (16 max)

#define AFX_IDW_SIZE_BOX                0xEA20  // size box for splitters
#define AFX_IDW_PANE_SAVE               0xEA21  // to shift AFX_IDW_PANE_FIRST
#endif //!RC_INVOKED

#ifndef APSTUDIO_INVOKED

// common style for form views
#define AFX_WS_DEFAULT_VIEW             (WS_CHILD | WS_VISIBLE | WS_BORDER)

#endif //!APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
// Standard app configurable strings

// for application title (defaults to EXE name or name in constructor)
#define AFX_IDS_APP_TITLE               0xE000
// idle message bar line
#define AFX_IDS_IDLEMESSAGE             0xE001
// message bar line when in shift-F1 help mode
#define AFX_IDS_HELPMODEMESSAGE         0xE002
// document title when editing OLE embedding
#define AFX_IDS_APP_TITLE_EMBEDDING     0xE003
// company name
#define AFX_IDS_COMPANY_NAME            0xE004
// object name when server is inplace
#define AFX_IDS_OBJ_TITLE_INPLACE       0xE005

/////////////////////////////////////////////////////////////////////////////
// Standard Commands

// File commands
#define ID_FILE_NEW                     0xE100
#define ID_FILE_OPEN                    0xE101
#define ID_FILE_CLOSE                   0xE102
#define ID_FILE_SAVE                    0xE103
#define ID_FILE_SAVE_AS                 0xE104
#define ID_FILE_PAGE_SETUP              0xE105
#define ID_FILE_PRINT_SETUP             0xE106
#define ID_FILE_PRINT                   0xE107
#define ID_FILE_PRINT_DIRECT            0xE108
#define ID_FILE_PRINT_PREVIEW           0xE109
#define ID_FILE_UPDATE                  0xE10A
#define ID_FILE_SAVE_COPY_AS            0xE10B
#define ID_FILE_SEND_MAIL               0xE10C

#define ID_FILE_MRU_FIRST               0xE110
#define ID_FILE_MRU_FILE1               0xE110          // range - 16 max
#define ID_FILE_MRU_FILE2               0xE111
#define ID_FILE_MRU_FILE3               0xE112
#define ID_FILE_MRU_FILE4               0xE113
#define ID_FILE_MRU_FILE5               0xE114
#define ID_FILE_MRU_FILE6               0xE115
#define ID_FILE_MRU_FILE7               0xE116
#define ID_FILE_MRU_FILE8               0xE117
#define ID_FILE_MRU_FILE9               0xE118
#define ID_FILE_MRU_FILE10              0xE119
#define ID_FILE_MRU_FILE11              0xE11A
#define ID_FILE_MRU_FILE12              0xE11B
#define ID_FILE_MRU_FILE13              0xE11C
#define ID_FILE_MRU_FILE14              0xE11D
#define ID_FILE_MRU_FILE15              0xE11E
#define ID_FILE_MRU_FILE16              0xE11F
#define ID_FILE_MRU_LAST                0xE11F

// Edit commands
#define ID_EDIT_CLEAR                   0xE120
#define ID_EDIT_CLEAR_ALL               0xE121
#define ID_EDIT_COPY                    0xE122
#define ID_EDIT_CUT                     0xE123
#define ID_EDIT_FIND                    0xE124
#define ID_EDIT_PASTE                   0xE125
#define ID_EDIT_PASTE_LINK              0xE126
#define ID_EDIT_PASTE_SPECIAL           0xE127
#define ID_EDIT_REPEAT                  0xE128
#define ID_EDIT_REPLACE                 0xE129
#define ID_EDIT_SELECT_ALL              0xE12A
#define ID_EDIT_UNDO                    0xE12B
#define ID_EDIT_REDO                    0xE12C

// Window commands
#define ID_WINDOW_NEW                   0xE130
#define ID_WINDOW_ARRANGE               0xE131
#define ID_WINDOW_CASCADE               0xE132
#define ID_WINDOW_TILE_HORZ             0xE133
#define ID_WINDOW_TILE_VERT             0xE134
#define ID_WINDOW_SPLIT                 0xE135
#ifndef RC_INVOKED      // code only
#define AFX_IDM_WINDOW_FIRST            0xE130
#define AFX_IDM_WINDOW_LAST             0xE13F
#define AFX_IDM_FIRST_MDICHILD          0xFF00  // window list starts here
#endif //!RC_INVOKED

// Help and App commands
#define ID_APP_ABOUT                    0xE140
#define ID_APP_EXIT                     0xE141
#define ID_HELP_INDEX                   0xE142
#define ID_HELP_FINDER                  0xE143
#define ID_HELP_USING                   0xE144
#define ID_CONTEXT_HELP                 0xE145      // shift-F1
// special commands for processing help
#define ID_HELP                         0xE146      // first attempt for F1
#define ID_DEFAULT_HELP                 0xE147      // last attempt

// Misc
#define ID_NEXT_PANE                    0xE150
#define ID_PREV_PANE                    0xE151

// Format
#define ID_FORMAT_FONT                  0xE160

// OLE commands
#define ID_OLE_INSERT_NEW               0xE200
#define ID_OLE_EDIT_LINKS               0xE201
#define ID_OLE_EDIT_CONVERT             0xE202
#define ID_OLE_EDIT_CHANGE_ICON         0xE203
#define ID_OLE_EDIT_PROPERTIES          0xE204
#define ID_OLE_VERB_FIRST               0xE210     // range - 16 max
#ifndef RC_INVOKED      // code only
#define ID_OLE_VERB_LAST                0xE21F
#endif //!RC_INVOKED

// for print preview dialog bar
#define AFX_ID_PREVIEW_CLOSE            0xE300
#define AFX_ID_PREVIEW_NUMPAGE          0xE301      // One/Two Page button
#define AFX_ID_PREVIEW_NEXT             0xE302
#define AFX_ID_PREVIEW_PREV             0xE303
#define AFX_ID_PREVIEW_PRINT            0xE304
#define AFX_ID_PREVIEW_ZOOMIN           0xE305
#define AFX_ID_PREVIEW_ZOOMOUT          0xE306

// View commands (same number used as IDW used for control bar)
#define ID_VIEW_TOOLBAR                 0xE800
#define ID_VIEW_STATUS_BAR              0xE801
#define ID_VIEW_REBAR                   0xE804
#define ID_VIEW_AUTOARRANGE         0xE805
	// E810 -> E81F must be kept in order for RANGE macros
#define ID_VIEW_SMALLICON               0xE810
#define ID_VIEW_LARGEICON               0xE811
#define ID_VIEW_LIST                   0xE812
#define ID_VIEW_DETAILS                 0xE813
#define ID_VIEW_LINEUP                  0xE814
#define ID_VIEW_BYNAME                  0xE815
#define AFX_ID_VIEW_MINIMUM              ID_VIEW_SMALLICON
#define AFX_ID_VIEW_MAXIMUM              ID_VIEW_BYNAME
	// E800 -> E8FF reserved for other control bar commands

// RecordForm commands
#define ID_RECORD_FIRST                 0xE900
#define ID_RECORD_LAST                  0xE901
#define ID_RECORD_NEXT                  0xE902
#define ID_RECORD_PREV                  0xE903

/////////////////////////////////////////////////////////////////////////////
// Standard control IDs

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls

/////////////////////////////////////////////////////////////////////////////
// Standard string error/warnings

#ifndef RC_INVOKED      // code only
#define AFX_IDS_SCFIRST                 0xEF00
#endif //!RC_INVOKED

#define AFX_IDS_SCSIZE                  0xEF00
#define AFX_IDS_SCMOVE                  0xEF01
#define AFX_IDS_SCMINIMIZE              0xEF02
#define AFX_IDS_SCMAXIMIZE              0xEF03
#define AFX_IDS_SCNEXTWINDOW            0xEF04
#define AFX_IDS_SCPREVWINDOW            0xEF05
#define AFX_IDS_SCCLOSE                 0xEF06
#define AFX_IDS_SCRESTORE               0xEF12
#define AFX_IDS_SCTASKLIST              0xEF13

#define AFX_IDS_MDICHILD                0xEF1F

#define AFX_IDS_DESKACCESSORY           0xEFDA

// General strings
#define AFX_IDS_OPENFILE                0xF000
#define AFX_IDS_SAVEFILE                0xF001
#define AFX_IDS_ALLFILTER               0xF002
#define AFX_IDS_UNTITLED                0xF003
#define AFX_IDS_SAVEFILECOPY            0xF004
#define AFX_IDS_PREVIEW_CLOSE           0xF005
#define AFX_IDS_UNNAMED_FILE            0xF006
#define AFX_IDS_HIDE                    0xF011

// MFC Standard Exception Error messages
#define AFX_IDP_NO_ERROR_AVAILABLE      0xF020
#define AFX_IDS_NOT_SUPPORTED_EXCEPTION 0xF021
#define AFX_IDS_RESOURCE_EXCEPTION      0xF022
#define AFX_IDS_MEMORY_EXCEPTION        0xF023
#define AFX_IDS_USER_EXCEPTION          0xF024

// Printing and print preview strings
#define AFX_IDS_PRINTONPORT             0xF040
#define AFX_IDS_ONEPAGE                 0xF041
#define AFX_IDS_TWOPAGE                 0xF042
#define AFX_IDS_PRINTPAGENUM            0xF043
#define AFX_IDS_PREVIEWPAGEDESC         0xF044
#define AFX_IDS_PRINTDEFAULTEXT         0xF045
#define AFX_IDS_PRINTDEFAULT            0xF046
#define AFX_IDS_PRINTFILTER             0xF047
#define AFX_IDS_PRINTCAPTION            0xF048
#define AFX_IDS_PRINTTOFILE             0xF049


// OLE strings
#define AFX_IDS_OBJECT_MENUITEM         0xF080
#define AFX_IDS_EDIT_VERB               0xF081
#define AFX_IDS_ACTIVATE_VERB           0xF082
#define AFX_IDS_CHANGE_LINK             0xF083
#define AFX_IDS_AUTO                    0xF084
#define AFX_IDS_MANUAL                  0xF085
#define AFX_IDS_FROZEN                  0xF086
#define AFX_IDS_ALL_FILES               0xF087
// dynamically changing menu items
#define AFX_IDS_SAVE_MENU               0xF088
#define AFX_IDS_UPDATE_MENU             0xF089
#define AFX_IDS_SAVE_AS_MENU            0xF08A
#define AFX_IDS_SAVE_COPY_AS_MENU       0xF08B
#define AFX_IDS_EXIT_MENU               0xF08C
#define AFX_IDS_UPDATING_ITEMS          0xF08D
// COlePasteSpecialDialog defines
#define AFX_IDS_METAFILE_FORMAT         0xF08E
#define AFX_IDS_DIB_FORMAT              0xF08F
#define AFX_IDS_BITMAP_FORMAT           0xF090
#define AFX_IDS_LINKSOURCE_FORMAT       0xF091
#define AFX_IDS_EMBED_FORMAT            0xF092
// other OLE utility strings
#define AFX_IDS_PASTELINKEDTYPE         0xF094
#define AFX_IDS_UNKNOWNTYPE             0xF095
#define AFX_IDS_RTF_FORMAT              0xF096
#define AFX_IDS_TEXT_FORMAT             0xF097
// OLE datatype format error strings
#define AFX_IDS_INVALID_CURRENCY        0xF098
#define AFX_IDS_INVALID_DATETIME        0xF099
#define AFX_IDS_INVALID_DATETIMESPAN    0xF09A

// General error / prompt strings
#define AFX_IDP_INVALID_FILENAME        0xF100
#define AFX_IDP_FAILED_TO_OPEN_DOC      0xF101
#define AFX_IDP_FAILED_TO_SAVE_DOC      0xF102
#define AFX_IDP_ASK_TO_SAVE             0xF103
#define AFX_IDP_FAILED_TO_CREATE_DOC    0xF104
#define AFX_IDP_FILE_TOO_LARGE          0xF105
#define AFX_IDP_FAILED_TO_START_PRINT   0xF106
#define AFX_IDP_FAILED_TO_LAUNCH_HELP   0xF107
#define AFX_IDP_INTERNAL_FAILURE        0xF108      // general failure
#define AFX_IDP_COMMAND_FAILURE         0xF109      // command failure
#define AFX_IDP_FAILED_MEMORY_ALLOC     0xF10A
#define AFX_IDP_UNREG_DONE              0xF10B
#define AFX_IDP_UNREG_FAILURE           0xF10C
#define AFX_IDP_DLL_LOAD_FAILED         0xF10D
#define AFX_IDP_DLL_BAD_VERSION         0xF10E

// DDV parse errors
#define AFX_IDP_PARSE_INT               0xF110
#define AFX_IDP_PARSE_REAL              0xF111
#define AFX_IDP_PARSE_INT_RANGE         0xF112
#define AFX_IDP_PARSE_REAL_RANGE        0xF113
#define AFX_IDP_PARSE_STRING_SIZE       0xF114
#define AFX_IDP_PARSE_RADIO_BUTTON      0xF115
#define AFX_IDP_PARSE_BYTE              0xF116
#define AFX_IDP_PARSE_UINT              0xF117
#define AFX_IDP_PARSE_DATETIME          0xF118
#define AFX_IDP_PARSE_CURRENCY          0xF119

// CFile/CArchive error strings for user failure
#define AFX_IDP_FAILED_INVALID_FORMAT   0xF120
#define AFX_IDP_FAILED_INVALID_PATH     0xF121
#define AFX_IDP_FAILED_DISK_FULL        0xF122
#define AFX_IDP_FAILED_ACCESS_READ      0xF123
#define AFX_IDP_FAILED_ACCESS_WRITE     0xF124
#define AFX_IDP_FAILED_IO_ERROR_READ    0xF125
#define AFX_IDP_FAILED_IO_ERROR_WRITE   0xF126

// OLE errors / prompt strings
#define AFX_IDP_STATIC_OBJECT           0xF180
#define AFX_IDP_FAILED_TO_CONNECT       0xF181
#define AFX_IDP_SERVER_BUSY             0xF182
#define AFX_IDP_BAD_VERB                0xF183
#define AFX_IDS_NOT_DOCOBJECT                0xF184
#define AFX_IDP_FAILED_TO_NOTIFY        0xF185
#define AFX_IDP_FAILED_TO_LAUNCH        0xF186
#define AFX_IDP_ASK_TO_UPDATE           0xF187
#define AFX_IDP_FAILED_TO_UPDATE        0xF188
#define AFX_IDP_FAILED_TO_REGISTER      0xF189
#define AFX_IDP_FAILED_TO_AUTO_REGISTER 0xF18A
#define AFX_IDP_FAILED_TO_CONVERT       0xF18B
#define AFX_IDP_GET_NOT_SUPPORTED       0xF18C
#define AFX_IDP_SET_NOT_SUPPORTED       0xF18D
#define AFX_IDP_ASK_TO_DISCARD          0xF18E
#define AFX_IDP_FAILED_TO_CREATE        0xF18F

// MAPI errors / prompt strings
#define AFX_IDP_FAILED_MAPI_LOAD        0xF190
#define AFX_IDP_INVALID_MAPI_DLL        0xF191
#define AFX_IDP_FAILED_MAPI_SEND        0xF192

#define AFX_IDP_FILE_NONE               0xF1A0
#define AFX_IDP_FILE_GENERIC            0xF1A1
#define AFX_IDP_FILE_NOT_FOUND          0xF1A2
#define AFX_IDP_FILE_BAD_PATH           0xF1A3
#define AFX_IDP_FILE_TOO_MANY_OPEN      0xF1A4
#define AFX_IDP_FILE_ACCESS_DENIED      0xF1A5
#define AFX_IDP_FILE_INVALID_FILE       0xF1A6
#define AFX_IDP_FILE_REMOVE_CURRENT     0xF1A7
#define AFX_IDP_FILE_DIR_FULL           0xF1A8
#define AFX_IDP_FILE_BAD_SEEK           0xF1A9
#define AFX_IDP_FILE_HARD_IO            0xF1AA
#define AFX_IDP_FILE_SHARING            0xF1AB
#define AFX_IDP_FILE_LOCKING            0xF1AC
#define AFX_IDP_FILE_DISKFULL           0xF1AD
#define AFX_IDP_FILE_EOF                0xF1AE

#define AFX_IDP_ARCH_NONE               0xF1B0
#define AFX_IDP_ARCH_GENERIC            0xF1B1
#define AFX_IDP_ARCH_READONLY           0xF1B2
#define AFX_IDP_ARCH_ENDOFFILE          0xF1B3
#define AFX_IDP_ARCH_WRITEONLY          0xF1B4
#define AFX_IDP_ARCH_BADINDEX           0xF1B5
#define AFX_IDP_ARCH_BADCLASS           0xF1B6
#define AFX_IDP_ARCH_BADSCHEMA          0xF1B7

#define AFX_IDS_OCC_SCALEUNITS_PIXELS   0xF1C0

// 0xf200-0xf20f reserved

// font names and point sizes
#define AFX_IDS_STATUS_FONT             0xF230
#define AFX_IDS_TOOLTIP_FONT            0xF231
#define AFX_IDS_UNICODE_FONT            0xF232
#define AFX_IDS_MINI_FONT               0xF233

// ODBC Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_SQL_FIRST                       0xF280
#endif //!RC_INVOKED
#define AFX_IDP_SQL_CONNECT_FAIL                0xF281
#define AFX_IDP_SQL_RECORDSET_FORWARD_ONLY      0xF282
#define AFX_IDP_SQL_EMPTY_COLUMN_LIST           0xF283
#define AFX_IDP_SQL_FIELD_SCHEMA_MISMATCH       0xF284
#define AFX_IDP_SQL_ILLEGAL_MODE                0xF285
#define AFX_IDP_SQL_MULTIPLE_ROWS_AFFECTED      0xF286
#define AFX_IDP_SQL_NO_CURRENT_RECORD           0xF287
#define AFX_IDP_SQL_NO_ROWS_AFFECTED            0xF288
#define AFX_IDP_SQL_RECORDSET_READONLY          0xF289
#define AFX_IDP_SQL_SQL_NO_TOTAL                0xF28A
#define AFX_IDP_SQL_ODBC_LOAD_FAILED            0xF28B
#define AFX_IDP_SQL_DYNASET_NOT_SUPPORTED       0xF28C
#define AFX_IDP_SQL_SNAPSHOT_NOT_SUPPORTED      0xF28D
#define AFX_IDP_SQL_API_CONFORMANCE             0xF28E
#define AFX_IDP_SQL_SQL_CONFORMANCE             0xF28F
#define AFX_IDP_SQL_NO_DATA_FOUND               0xF290
#define AFX_IDP_SQL_ROW_UPDATE_NOT_SUPPORTED    0xF291
#define AFX_IDP_SQL_ODBC_V2_REQUIRED            0xF292
#define AFX_IDP_SQL_NO_POSITIONED_UPDATES       0xF293
#define AFX_IDP_SQL_LOCK_MODE_NOT_SUPPORTED     0xF294
#define AFX_IDP_SQL_DATA_TRUNCATED              0xF295
#define AFX_IDP_SQL_ROW_FETCH                   0xF296
#define AFX_IDP_SQL_INCORRECT_ODBC              0xF297
#define AFX_IDP_SQL_UPDATE_DELETE_FAILED        0xF298
#define AFX_IDP_SQL_DYNAMIC_CURSOR_NOT_SUPPORTED    0xF299
#define AFX_IDP_SQL_FIELD_NOT_FOUND             0xF29A
#define AFX_IDP_SQL_BOOKMARKS_NOT_SUPPORTED     0xF29B
#define AFX_IDP_SQL_BOOKMARKS_NOT_ENABLED       0xF29C

// ODBC Database strings
#define AFX_IDS_DELETED                         0xF29D

// DAO Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_DAO_FIRST                       0xF2B0
#endif //!RC_INVOKED
#define AFX_IDP_DAO_ENGINE_INITIALIZATION       0xF2B0
#define AFX_IDP_DAO_DFX_BIND                    0xF2B1
#define AFX_IDP_DAO_OBJECT_NOT_OPEN             0xF2B2

// ICDAORecordset::GetRows Errors
//  These are not placed in DAO Errors collection
//  and must be handled directly by MFC.
#define AFX_IDP_DAO_ROWTOOSHORT                 0xF2B3
#define AFX_IDP_DAO_BADBINDINFO                 0xF2B4
#define AFX_IDP_DAO_COLUMNUNAVAILABLE           0xF2B5

/////////////////////////////////////////////////////////////////////////////
// Strings for ISAPI support

#define AFX_IDS_HTTP_TITLE              0xF2D1
#define AFX_IDS_HTTP_NO_TEXT            0xF2D2
#define AFX_IDS_HTTP_BAD_REQUEST        0xF2D3
#define AFX_IDS_HTTP_AUTH_REQUIRED      0xF2D4
#define AFX_IDS_HTTP_FORBIDDEN          0xF2D5
#define AFX_IDS_HTTP_NOT_FOUND          0xF2D6
#define AFX_IDS_HTTP_SERVER_ERROR       0xF2D7
#define AFX_IDS_HTTP_NOT_IMPLEMENTED    0xF2D8

/////////////////////////////////////////////////////////////////////////////
// AFX implementation - control IDs (AFX_IDC)

// Parts of dialogs
#define AFX_IDC_LISTBOX                 100
#define AFX_IDC_CHANGE                  101

// for print dialog
#define AFX_IDC_PRINT_DOCNAME           201
#define AFX_IDC_PRINT_PRINTERNAME       202
#define AFX_IDC_PRINT_PORTNAME          203
#define AFX_IDC_PRINT_PAGENUM           204

// Property Sheet control id's (determined with Spy++)
#define ID_APPLY_NOW                    0x3021
#define ID_WIZBACK                      0x3023
#define ID_WIZNEXT                      0x3024
#define ID_WIZFINISH                    0x3025
#define AFX_IDC_TAB_CONTROL             0x3020

/////////////////////////////////////////////////////////////////////////////
// IDRs for standard components

#ifndef RC_INVOKED  // code only
// These are really COMMDLG dialogs, so there usually isn't a resource
// for them, but these IDs are used as help IDs.
#define AFX_IDD_FILEOPEN                28676
#define AFX_IDD_FILESAVE                28677
#define AFX_IDD_FONT                    28678
#define AFX_IDD_COLOR                   28679
#define AFX_IDD_PRINT                   28680
#define AFX_IDD_PRINTSETUP              28681
#define AFX_IDD_FIND                    28682
#define AFX_IDD_REPLACE                 28683
#endif //!RC_INVOKED

// Standard dialogs app should leave alone (0x7801->)
#define AFX_IDD_NEWTYPEDLG              30721
#define AFX_IDD_PRINTDLG                30722
#define AFX_IDD_PREVIEW_TOOLBAR         30723

// Dialogs defined for OLE2UI library
#define AFX_IDD_INSERTOBJECT            30724
#define AFX_IDD_CHANGEICON              30725
#define AFX_IDD_CONVERT                 30726
#define AFX_IDD_PASTESPECIAL            30727
#define AFX_IDD_EDITLINKS               30728
#define AFX_IDD_FILEBROWSE              30729
#define AFX_IDD_BUSY                    30730

#define AFX_IDD_OBJECTPROPERTIES        30732
#define AFX_IDD_CHANGESOURCE            30733

// Standard cursors (0x7901->)
	// AFX_IDC = Cursor resources
#define AFX_IDC_CONTEXTHELP             30977       // context sensitive help
#define AFX_IDC_MAGNIFY                 30978       // print preview zoom
#define AFX_IDC_SMALLARROWS             30979       // splitter
#define AFX_IDC_HSPLITBAR               30980       // splitter
#define AFX_IDC_VSPLITBAR               30981       // splitter
#define AFX_IDC_NODROPCRSR              30982       // No Drop Cursor
#define AFX_IDC_TRACKNWSE               30983       // tracker
#define AFX_IDC_TRACKNESW               30984       // tracker
#define AFX_IDC_TRACKNS                 30985       // tracker
#define AFX_IDC_TRACKWE                 30986       // tracker
#define AFX_IDC_TRACK4WAY               30987       // tracker
#define AFX_IDC_MOVE4WAY                30988       // resize bar (server only)

// Mini frame window bitmap ID
#define AFX_IDB_MINIFRAME_MENU          30994

// CheckListBox checks bitmap ID
#define AFX_IDB_CHECKLISTBOX_NT         30995
#define AFX_IDB_CHECKLISTBOX_95         30996

// AFX standard accelerator resources
#define AFX_IDR_PREVIEW_ACCEL           30997

// AFX standard ICON IDs (for MFC V1 apps) (0x7A01->)
#define AFX_IDI_STD_MDIFRAME            31233
#define AFX_IDI_STD_FRAME               31234

/////////////////////////////////////////////////////////////////////////////
// AFX OLE control implementation - control IDs (AFX_IDC)

// Font property page
#define AFX_IDC_FONTPROP                1000
#define AFX_IDC_FONTNAMES               1001
#define AFX_IDC_FONTSTYLES              1002
#define AFX_IDC_FONTSIZES               1003
#define AFX_IDC_STRIKEOUT               1004
#define AFX_IDC_UNDERLINE               1005
#define AFX_IDC_SAMPLEBOX               1006

// Color property page
#define AFX_IDC_COLOR_BLACK             1100
#define AFX_IDC_COLOR_WHITE             1101
#define AFX_IDC_COLOR_RED               1102
#define AFX_IDC_COLOR_GREEN             1103
#define AFX_IDC_COLOR_BLUE              1104
#define AFX_IDC_COLOR_YELLOW            1105
#define AFX_IDC_COLOR_MAGENTA           1106
#define AFX_IDC_COLOR_CYAN              1107
#define AFX_IDC_COLOR_GRAY              1108
#define AFX_IDC_COLOR_LIGHTGRAY         1109
#define AFX_IDC_COLOR_DARKRED           1110
#define AFX_IDC_COLOR_DARKGREEN         1111
#define AFX_IDC_COLOR_DARKBLUE          1112
#define AFX_IDC_COLOR_LIGHTBROWN        1113
#define AFX_IDC_COLOR_DARKMAGENTA       1114
#define AFX_IDC_COLOR_DARKCYAN          1115
#define AFX_IDC_COLORPROP               1116
#define AFX_IDC_SYSTEMCOLORS            1117

// Picture porperty page
#define AFX_IDC_PROPNAME                1201
#define AFX_IDC_PICTURE                 1202
#define AFX_IDC_BROWSE                  1203
#define AFX_IDC_CLEAR                   1204

/////////////////////////////////////////////////////////////////////////////
// IDRs for OLE control standard components

// Standard propery page dialogs app should leave alone (0x7E01->)
#define AFX_IDD_PROPPAGE_COLOR         32257
#define AFX_IDD_PROPPAGE_FONT          32258
#define AFX_IDD_PROPPAGE_PICTURE       32259

#define AFX_IDB_TRUETYPE               32384

/////////////////////////////////////////////////////////////////////////////
// Standard OLE control strings

// OLE Control page strings
#define AFX_IDS_PROPPAGE_UNKNOWN        0xFE01
#define AFX_IDS_COLOR_DESKTOP           0xFE04
#define AFX_IDS_COLOR_APPWORKSPACE      0xFE05
#define AFX_IDS_COLOR_WNDBACKGND        0xFE06
#define AFX_IDS_COLOR_WNDTEXT           0xFE07
#define AFX_IDS_COLOR_MENUBAR           0xFE08
#define AFX_IDS_COLOR_MENUTEXT          0xFE09
#define AFX_IDS_COLOR_ACTIVEBAR         0xFE0A
#define AFX_IDS_COLOR_INACTIVEBAR       0xFE0B
#define AFX_IDS_COLOR_ACTIVETEXT        0xFE0C
#define AFX_IDS_COLOR_INACTIVETEXT      0xFE0D
#define AFX_IDS_COLOR_ACTIVEBORDER      0xFE0E
#define AFX_IDS_COLOR_INACTIVEBORDER    0xFE0F
#define AFX_IDS_COLOR_WNDFRAME          0xFE10
#define AFX_IDS_COLOR_SCROLLBARS        0xFE11
#define AFX_IDS_COLOR_BTNFACE           0xFE12
#define AFX_IDS_COLOR_BTNSHADOW         0xFE13
#define AFX_IDS_COLOR_BTNTEXT           0xFE14
#define AFX_IDS_COLOR_BTNHIGHLIGHT      0xFE15
#define AFX_IDS_COLOR_DISABLEDTEXT      0xFE16
#define AFX_IDS_COLOR_HIGHLIGHT         0xFE17
#define AFX_IDS_COLOR_HIGHLIGHTTEXT     0xFE18
#define AFX_IDS_REGULAR                 0xFE19
#define AFX_IDS_BOLD                    0xFE1A
#define AFX_IDS_ITALIC                  0xFE1B
#define AFX_IDS_BOLDITALIC              0xFE1C
#define AFX_IDS_SAMPLETEXT              0xFE1D
#define AFX_IDS_DISPLAYSTRING_FONT      0xFE1E
#define AFX_IDS_DISPLAYSTRING_COLOR     0xFE1F
#define AFX_IDS_DISPLAYSTRING_PICTURE   0xFE20
#define AFX_IDS_PICTUREFILTER           0xFE21
#define AFX_IDS_PICTYPE_UNKNOWN         0xFE22
#define AFX_IDS_PICTYPE_NONE            0xFE23
#define AFX_IDS_PICTYPE_BITMAP          0xFE24
#define AFX_IDS_PICTYPE_METAFILE        0xFE25
#define AFX_IDS_PICTYPE_ICON            0xFE26
#define AFX_IDS_COLOR_PPG               0xFE28
#define AFX_IDS_COLOR_PPG_CAPTION       0xFE29
#define AFX_IDS_FONT_PPG                0xFE2A
#define AFX_IDS_FONT_PPG_CAPTION        0xFE2B
#define AFX_IDS_PICTURE_PPG             0xFE2C
#define AFX_IDS_PICTURE_PPG_CAPTION     0xFE2D
#define AFX_IDS_PICTUREBROWSETITLE      0xFE30
#define AFX_IDS_BORDERSTYLE_0           0xFE31
#define AFX_IDS_BORDERSTYLE_1           0xFE32

// OLE Control verb names
#define AFX_IDS_VERB_EDIT               0xFE40
#define AFX_IDS_VERB_PROPERTIES         0xFE41

// OLE Control internal error messages
#define AFX_IDP_PICTURECANTOPEN         0xFE83
#define AFX_IDP_PICTURECANTLOAD         0xFE84
#define AFX_IDP_PICTURETOOLARGE         0xFE85
#define AFX_IDP_PICTUREREADFAILED       0xFE86

// Standard OLE Control error strings
#define AFX_IDP_E_ILLEGALFUNCTIONCALL       0xFEA0
#define AFX_IDP_E_OVERFLOW                  0xFEA1
#define AFX_IDP_E_OUTOFMEMORY               0xFEA2
#define AFX_IDP_E_DIVISIONBYZERO            0xFEA3
#define AFX_IDP_E_OUTOFSTRINGSPACE          0xFEA4
#define AFX_IDP_E_OUTOFSTACKSPACE           0xFEA5
#define AFX_IDP_E_BADFILENAMEORNUMBER       0xFEA6
#define AFX_IDP_E_FILENOTFOUND              0xFEA7
#define AFX_IDP_E_BADFILEMODE               0xFEA8
#define AFX_IDP_E_FILEALREADYOPEN           0xFEA9
#define AFX_IDP_E_DEVICEIOERROR             0xFEAA
#define AFX_IDP_E_FILEALREADYEXISTS         0xFEAB
#define AFX_IDP_E_BADRECORDLENGTH           0xFEAC
#define AFX_IDP_E_DISKFULL                  0xFEAD
#define AFX_IDP_E_BADRECORDNUMBER           0xFEAE
#define AFX_IDP_E_BADFILENAME               0xFEAF
#define AFX_IDP_E_TOOMANYFILES              0xFEB0
#define AFX_IDP_E_DEVICEUNAVAILABLE         0xFEB1
#define AFX_IDP_E_PERMISSIONDENIED          0xFEB2
#define AFX_IDP_E_DISKNOTREADY              0xFEB3
#define AFX_IDP_E_PATHFILEACCESSERROR       0xFEB4
#define AFX_IDP_E_PATHNOTFOUND              0xFEB5
#define AFX_IDP_E_INVALIDPATTERNSTRING      0xFEB6
#define AFX_IDP_E_INVALIDUSEOFNULL          0xFEB7
#define AFX_IDP_E_INVALIDFILEFORMAT         0xFEB8
#define AFX_IDP_E_INVALIDPROPERTYVALUE      0xFEB9
#define AFX_IDP_E_INVALIDPROPERTYARRAYINDEX 0xFEBA
#define AFX_IDP_E_SETNOTSUPPORTEDATRUNTIME  0xFEBB
#define AFX_IDP_E_SETNOTSUPPORTED           0xFEBC
#define AFX_IDP_E_NEEDPROPERTYARRAYINDEX    0xFEBD
#define AFX_IDP_E_SETNOTPERMITTED           0xFEBE
#define AFX_IDP_E_GETNOTSUPPORTEDATRUNTIME  0xFEBF
#define AFX_IDP_E_GETNOTSUPPORTED           0xFEC0
#define AFX_IDP_E_PROPERTYNOTFOUND          0xFEC1
#define AFX_IDP_E_INVALIDCLIPBOARDFORMAT    0xFEC2
#define AFX_IDP_E_INVALIDPICTURE            0xFEC3
#define AFX_IDP_E_PRINTERERROR              0xFEC4
#define AFX_IDP_E_CANTSAVEFILETOTEMP        0xFEC5
#define AFX_IDP_E_SEARCHTEXTNOTFOUND        0xFEC6
#define AFX_IDP_E_REPLACEMENTSTOOLONG       0xFEC7

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXRES_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tweakui\with.cpp ===
/*
 * with - With-procedures
 *
 *  A "With-procedure" creates an object, calls the callback (passing
 *  the object), then frees the object.  The return value
 *  of the with-procedure is the value returned by the callback.
 *
 *  This encapsulates the concept of "Get something, do something with
 *  it, then free it."  Forgetting to free objects on the error path
 *  is a common mistake; by doing it this way, the act of freeing the
 *  object is done automatically.
 */

#include "tweakui.h"

#pragma BEGIN_CONST_DATA

#undef DEFINE_GUID
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
const GUID name = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }

#define DEFINE_SHLGUID(name, l, w1, w2) \
	 DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)

DEFINE_SHLGUID(IID_IShellFolder,    	0x000214E6L, 0, 0);

const CHAR CODESEG c_szStarDotStar[] = "*.*";

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *  WithPidl
 *
 *	Create a pidl from an psf and a relative path, call the callback,
 *	then free the pidl.
 *
 *	Returns 0 on error, else propagates the callback's return value
 *	through.
 *
 *****************************************************************************/

BOOL PASCAL
WithPidl(PSF psf, LPCSTR lqn, BOOL (*pfn)(PIDL, LPVOID), LPVOID pv)
{
    PIDL pidl = pidlFromPath(psf, lqn);
    if (pidl) {
	BOOL fRc = pfn(pidl, pv);
	Ole_Free(pidl);
	return fRc;
    } else {
	return 0;
    }
}

/*****************************************************************************
 *
 *  WithPsf
 *
 *	Bind to an IShellFolder, call the callback, then release the
 *	IShellFolder.
 *
 *	Returns 0 on error, else propagates the callback's return value
 *	through.
 *
 *****************************************************************************/

BOOL PASCAL
WithPsf(PSF psf, PIDL pidl, BOOL (*pfn)(PSF, LPVOID), LPVOID pv)
{
    PSF psfNew;
    if (SUCCEEDED(psf->BindToObject(pidl, 0, IID_IShellFolder, (LPVOID *)&psfNew))) {
	BOOL fRc;
	fRc = pfn(psfNew, pv);
	Ole_Release(psfNew);
	return fRc;
    } else {
	return 0;
    }
}

/*****************************************************************************
 *
 *  EmptyDirectory
 *
 *	Delete all the files in the indicated directory, first calling a
 *	function in that directory.
 *
 *****************************************************************************/

BOOL PASCAL
EmptyDirectory(LPCSTR pszDir, BOOL (*pfn)(LPCSTR, LPVOID), LPVOID pv)
{
    BOOL fRc;
    char szPrevDir[MAX_PATH];

    GetCurrentDirectory(cA(szPrevDir), szPrevDir); /* For restore */
    if (SetCurrentDirectory(pszDir)) {
	WIN32_FIND_DATA wfd;
	HANDLE h;
	if (pfn) {
	    fRc = pfn(pszDir, pv);
	}
	h = FindFirstFile(c_szStarDotStar, &wfd);
	if (h != INVALID_HANDLE_VALUE) {
	    do {
		DeleteFile(wfd.cFileName);
	    } while (FindNextFile(h, &wfd));
            FindClose(h);
	}
	SetCurrentDirectory(szPrevDir);
    }
    return fRc;
}

/*****************************************************************************
 *
 *  WithTempDirectory
 *
 *	Ask KERNEL for a unique temp name and create a temp directory there.
 *	Change to the new directory, call the callback, and then change
 *	back to the previous directory.  Remove all the files in the temp
 *	directory, then remove the temp directory.  Note that we don't
 *	implement full recursive cleanup, so if you create any subdirectories
 *	in the temp directory, you have to remove them yourself.
 *
 *	Returns 0 on error, else propagates the callback's return value
 *	through.
 *
 *****************************************************************************/

BOOL PASCAL
WithTempDirectory(BOOL (*pfn)(LPCSTR, LPVOID), LPVOID pv)
{
    BOOL fRc;
    char szTmpDir[MAX_PATH + 1 + 8 + 1 + 3 + 1];
    if (GetTempPath(MAX_PATH, szTmpDir) &&
	GetTempFileName(szTmpDir, "", 0, szTmpDir)) { /* Got a unique file */
	DeleteFile(szTmpDir);		/* Nuke the file; we want a dir */
	if (CreateDirectory(szTmpDir, 0)) {
	    fRc = EmptyDirectory(szTmpDir, pfn, pv);
	    RemoveDirectory(szTmpDir);
	} else {
	    fRc = 0;		/* Couldn't create the directory */
	}
    } else {
	fRc = 0;		/* Couldn't generate unique name */
    }
    return fRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tz\tz.c ===
/*
 * Utility program to query and set the current time zone settings
 * in the registry.
 *
 *      tz [-b Bias] [-s Name Bias Date] [-d Name Bias Date]
 *
 */

#include "tz.h"

void
Usage( void )
{
    fprintf( stderr, "usage: TZ [-b Bias] [-s Name Bias Date] [-d Name Bias Date]\n" );
    fprintf( stderr, "Where...\n" );
    fprintf( stderr, "    Default with no parameters is to display current time zone settings.\n" );
    exit( 1 );
}

char KeyValueBuffer[ 4096 ];

char *Order[] = {
    "first",

    "second",

    "third",

    "fourth",

    "last"
};

char *DayOfWeek[] = {
    "Sunday",

    "Monday",

    "Tuesday",

    "Wednesday",

    "Thursday",

    "Friday",

    "Saturday"
};

char *Months[] = {
    "January",

    "February",

    "March",

    "April",

    "May",

    "June",

    "July",

    "August",

    "September",

    "October",

    "November",

    "December"
};

#define NUMBER_DATE_TIME_FIELDS 6

BOOL
ParseTimeZoneInfo(
    IN LPSTR NameIn,
    OUT PWSTR NameOut,
    IN LPSTR BiasIn,
    OUT PLONG BiasOut,
    IN LPSTR StartIn,
    OUT PTIME_FIELDS StartOut
    )
{
    LPSTR s, s1;
    ULONG FieldIndexes[ NUMBER_DATE_TIME_FIELDS  ] = {1, 2, 0, 3, 4, 7};
    //
    // Month/Day/Year HH:MM DayOfWeek
    //

    ULONG CurrentField = 0;
    PCSHORT Fields;
    LPSTR Field;
    ULONG FieldValue;

    MultiByteToWideChar( CP_ACP,
                         0,
                         NameIn,
                         strlen( NameIn ),
                         NameOut,
                         32
                       );
    *BiasOut = atoi( BiasIn );
    s = StartIn;

    RtlZeroMemory( StartOut, sizeof( *StartOut ) );
    Fields = &StartOut->Year;
    while (*s) {
        if (CurrentField >= 7) {
            return( FALSE );
            }

        while (*s == ' ') {
            s++;
            }

        Field = s;
        while (*s) {
            if (CurrentField == (NUMBER_DATE_TIME_FIELDS-1)) {
                }
            else
            if (*s < '0' || *s > '9') {
                break;
                }

            s++;
            }

        if (*s) {
            s++;
            }

        if (CurrentField == (NUMBER_DATE_TIME_FIELDS-1)) {
            if (strlen( Field ) < 3) {
                printf( "TZ: %s invalid day of week length\n", Field );
                return FALSE;
                }

            if (StartOut->Year != 0) {
                printf( "TZ: Year must be zero to specify day of week\n" );
                return FALSE;
                }

            if (!_strnicmp( Field, "SUN", 3 )) {
                FieldValue = 0;
                }
            else
            if (!_strnicmp( Field, "MON", 3 )) {
                FieldValue = 1;
                }
            else
            if (!_strnicmp( Field, "TUE", 3 )) {
                FieldValue = 2;
                }
            else
            if (!_strnicmp( Field, "WED", 3 )) {
                FieldValue = 3;
                }
            else
            if (!_strnicmp( Field, "THU", 3 )) {
                FieldValue = 4;
                }
            else
            if (!_strnicmp( Field, "FRI", 3 )) {
                FieldValue = 5;
                }
            else
            if (!_strnicmp( Field, "SAT", 3 )) {
                FieldValue = 6;
                }
            else {
                printf( "TZ: %s invalid day of week\n", Field );
                return FALSE;
                }
            }
        else {
            FieldValue = atoi( Field );
            }

        Fields[ FieldIndexes[ CurrentField++ ] ] = (CSHORT)FieldValue;
        }

    if (StartOut->Year == 0) {
        if (StartOut->Day > 5) {
            printf( "TZ: Day must be 0 - 5 if year is zero.\n" );
            return FALSE;
            }
        }
    else
    if (StartOut->Year < 100) {
        StartOut->Year += 1900;
        }

    return TRUE;
}

int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    int i, j;
    LPSTR s, s1, s2, s3, AmPm;
    NTSTATUS Status;
    RTL_TIME_ZONE_INFORMATION tzi;
    BOOLEAN InfoModified = FALSE;

    ConvertAppToOem( argc, argv );
    if (argc < 1) {
        Usage();
        }

    Status = RtlQueryTimeZoneInformation( &tzi );
    if (!NT_SUCCESS( Status )) {
        fprintf( stderr, "TZ: Unable to query current information.\n" );
        }

    while (--argc) {
        s = *++argv;
        if (*s == '-' || *s == '/') {
            while (*++s) {
                switch( tolower( *s ) ) {
                    case 'b':
                        if (argc) {
                            --argc;
                            tzi.Bias = atoi( *++argv );
                            InfoModified = TRUE;
                            }
                        else {
                            Usage();
                            }
                        break;

                    case 's':
                        if (argc >= 3) {
                            argc -= 3;
                            s1 = *++argv;
                            s2 = *++argv;
                            s3 = *++argv;
                            if (ParseTimeZoneInfo( s1, tzi.StandardName,
                                                   s2, &tzi.StandardBias,
                                                   s3, &tzi.StandardStart
                                                 )
                               ) {
                                InfoModified = TRUE;
                                }
                            else {
                                Usage();
                                }
                            }
                        else {
                            Usage();
                            }
                        break;

                    case 'd':
                        if (argc >= 3) {
                            argc -= 3;
                            s1 = *++argv;
                            s2 = *++argv;
                            s3 = *++argv;
                            if (ParseTimeZoneInfo( s1, tzi.DaylightName,
                                                   s2, &tzi.DaylightBias,
                                                   s3, &tzi.DaylightStart
                                                 )
                               ) {
                                InfoModified = TRUE;
                                }
                            else {
                                Usage();
                                }
                            }
                        else {
                            Usage();
                            }
                        break;

                    default:    Usage();
                    }
                }
            }
        else {
            Usage();
            }
        }

    if (InfoModified) {
        Status = RtlSetTimeZoneInformation( &tzi );
        if (!NT_SUCCESS( Status )) {
            fprintf( stderr, "TZ: Unable to set new information.\n" );
            }
        }

    printf( "Time Zone Information.\n" );
    printf( "    Bias from UTC: %u:%02u\n", tzi.Bias / 60, tzi.Bias % 60 );
    printf( "    Standard time:\n" );
    printf( "        Name: %ws\n", &tzi.StandardName );
    printf( "        Bias: %d:%02d\n", tzi.StandardBias / 60, abs( tzi.StandardBias % 60 ) );

    if (tzi.StandardStart.Month != 0) {
        if (tzi.StandardStart.Hour > 12) {
            AmPm = "pm";
            tzi.StandardStart.Hour -= 12;
            }
        else {
            AmPm = "am";
            }
        printf( "        Start: %02u:%02u%s", tzi.StandardStart.Hour, tzi.StandardStart.Minute, AmPm );

        if (tzi.StandardStart.Year == 0) {
            printf( " %s %s of %s\n",
                    Order[ tzi.StandardStart.Day - 1 ],
                    DayOfWeek[ tzi.StandardStart.Weekday ],
                    Months[ tzi.StandardStart.Month - 1 ]
                  );
            }
        else {
            printf( "%s %02u, %u\n",
                    Months[ tzi.StandardStart.Month - 1 ],
                    tzi.StandardStart.Month, tzi.StandardStart.Day, tzi.StandardStart.Year
                  );
            }
        }

    printf( "    Daylight time:\n" );
    printf( "        Name: %ws\n", &tzi.DaylightName );
    printf( "        Bias: %d:%02d\n", tzi.DaylightBias / 60, abs( tzi.DaylightBias % 60 ) );

    if (tzi.DaylightStart.Month != 0) {
        if (tzi.DaylightStart.Hour > 12) {
            AmPm = "pm";
            tzi.DaylightStart.Hour -= 12;
            }
        else {
            AmPm = "am";
            }
        printf( "        Start: %02u:%02u%s", tzi.DaylightStart.Hour, tzi.DaylightStart.Minute, AmPm );

        if (tzi.DaylightStart.Year == 0) {
            printf( " %s %s of %s\n",
                    Order[ tzi.DaylightStart.Day - 1 ],
                    DayOfWeek[ tzi.DaylightStart.Weekday ],
                    Months[ tzi.DaylightStart.Month - 1 ]
                  );
            }
        else {
            printf( "%s %02u, %u\n",
                    Months[ tzi.DaylightStart.Month - 1 ],
                    tzi.DaylightStart.Month, tzi.DaylightStart.Day, tzi.DaylightStart.Year
                  );
            }
        }

    return( 0 );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tztool\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by tztool.rc
//
#define IDD_TZDLG                       101
#define IDC_TZTEMP1                     1001
#define IDC_POLLTZ                      1002
#define IDC_FAHR                        1003
#define IDC_TZSELECT                    1004
#define IDC_TZONESEL                    1005
#define IDC_CRTTEMP                     1006
#define IDC_MINTEMP                     1007
#define IDC_TZONEDETAILS                1008
#define IDC_CURTEMP                     1008
#define IDC_TZDETAILS                   1009
#define IDC_TZDETAILS2                  1010
#define IDC_PSVDETAILS                  1011
#define IDC_ACXDETAILS                  1012
#define IDC_THROTTLE                    1013
#define IDC_MINTHROTTLE                 1014
#define IDC_MAXTHROTTLE                 1015
#define IDC_CURTHROTTLE                 1016
#define IDC_MAXIDLE                     1018
#define IDC_CURIDLE                     1019
#define IDC_OPTIONS                     -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1019
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\tztool\tztool.c ===
/*
TZTool - Thermal Zone Information Tool
tztool.c
This the MAIN TZTool - C file.

Copyright (c) 1999 Microsoft Corporation

Module Name:

   TZTool - TZTool.c

Abstract:

   TZTool - Thermal Zone Information Tool

Author:

   Vincent Geglia (VincentG)

Notes:

Revision History:

    1.0 - Original version


*/

// Includes

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <stdlib.h>
#include <ntpoapi.h>
#include <commctrl.h>
#include "resource.h"
#include "wmium.h"

// Definitions

#define THERMAL_ZONE_GUID               {0xa1bc18c0, 0xa7c8, 0x11d1, {0xbf, 0x3c, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10} }
#define COOLING_PASSIVE                 0
#define COOLING_ACTIVE                  1
#define COOLING_UPDATE_TZONE            2
#define TIMER_ID                        1
#define TIMER_POLL_INTERVAL             500
#define MAX_ACTIVE_COOLING_LEVELS       10
#define MAX_THERMAL_ZONES               10

#define K_TO_F(_deg_) (((_deg_) - 2731) * 9 / 5 + 320)

GUID ThermalZoneGuid = THERMAL_ZONE_GUID;

// Structures

typedef struct _THERMAL_INFORMATION {
    ULONG           ThermalStamp;
    ULONG           ThermalConstant1;
    ULONG           ThermalConstant2;
    KAFFINITY       Processors;
    ULONG           SamplingPeriod;
    ULONG           CurrentTemperature;
    ULONG           PassiveTripPoint;
    ULONG           CriticalTripPoint;
    UCHAR           ActiveTripPointCount;
    ULONG           ActiveTripPoint[MAX_ACTIVE_COOLING_LEVELS];
} THERMAL_INFORMATION, *PTHERMAL_INFORMATION;

typedef struct _TZONE_INFO {

    THERMAL_INFORMATION ThermalInfo;
    ULONG64 TimeStamp;
    ULONG TZoneIndex;
    UCHAR TZoneName[100];
} TZONE_INFO, *PTZONE_INFO;

// Global variables

PTZONE_INFO g_TZonePtr = 0;
WMIHANDLE   g_WmiHandle;
INT         g_PollTz = 0;
BOOL        g_Fahrenheit = FALSE;

// Function declarations

INT WINAPI
WinMain (
        IN HINSTANCE hInstance,
        IN HINSTANCE hPrevInstance,
        IN PSTR CmdLine,
        IN INT CmdShow
        );

INT_PTR CALLBACK
TZoneDlgProc (
             IN HWND wnd,
             IN UINT Msg,
             IN WPARAM wParam,
             IN LPARAM lParam
             );

ULONG
UpdateTZoneData (
                IN OUT PTZONE_INFO ReturnedTZoneInfo,
                IN WMIHANDLE *Handle
                );

ULONG64
SystemTimeToUlong (
                  IN LPSYSTEMTIME SysTime
                  );

VOID
SetCoolingMode (
               IN UCHAR Mode
               );

VOID
UpgradePrivileges (
                  VOID
                  );

VOID
UpdateTZoneListBox (
                   IN HANDLE wnd
                   );

VOID
UpdateTZoneDetails (
                   IN HANDLE wnd
                   );

VOID
UpdateTZoneGauge (
                 IN HANDLE wnd
                 );

VOID
UpdateCPUGauge(
    IN HWND hwnd
    );

/*++

Routine Description:

    Windows application Entry Point

Arguments:

    <standard winmain arguments>

Return Value:

    0 if successful, otherwise error status

--*/

INT WINAPI
WinMain (
        IN HINSTANCE hInstance,
        IN HINSTANCE hPrevInstance,
        IN PSTR CmdLine,
        IN INT CmdShow
        )

{

    UCHAR text [200];
    INITCOMMONCONTROLSEX CommonCtl;
    TZONE_INFO TZones [MAX_THERMAL_ZONES];
    ULONG status = 0;


    // Initialize TZ structures

    ZeroMemory (&TZones, sizeof (TZones));
    g_TZonePtr = (PTZONE_INFO) &TZones;

    // Initialize Common Controls DLL for gauge control

    CommonCtl.dwSize = sizeof (CommonCtl);
    CommonCtl.dwICC = ICC_PROGRESS_CLASS;

    InitCommonControlsEx (&CommonCtl);

    // Open WMI data source for the TZs

    status = WmiOpenBlock ((LPGUID) &ThermalZoneGuid,
                           GENERIC_READ,
                           &g_WmiHandle);

    if (status != ERROR_SUCCESS) {

        sprintf (text,
                 "Unable to open thermal zone GUIDs.  This computer may not be equipped with thermal zones, or may not be in ACPI mode.\nError: %d",
                 status);

        MessageBox (NULL,
                    text,
                    "Fatal Error",
                    MB_ICONERROR | MB_OK);

        return status;
    }

    // In order to change the policies, we need greater access privileges

    UpgradePrivileges ();

    // Show the main dialog box

    DialogBox (hInstance,
               MAKEINTRESOURCE (IDD_TZDLG),
               NULL,
               TZoneDlgProc);

    return 0;
}

/*++

Routine Description:

    Standard Windows Dialog Message Loop

Arguments:

    <standard dialog message loop arguments>

Return Value:

    FALSE if message not handled, TRUE if message handled

--*/

INT_PTR CALLBACK
TZoneDlgProc (
             IN HWND wnd,
             IN UINT Msg,
             IN WPARAM wParam,
             IN LPARAM lParam
             )
{
    ULONG Count = 0;
    LRESULT RetVal = 0;
    switch (Msg) {

    case WM_TIMER:

        if (g_PollTz) {
            SetCoolingMode (COOLING_UPDATE_TZONE);
        }

        if (UpdateTZoneData (g_TZonePtr, g_WmiHandle)) {
            UpdateTZoneDetails (wnd);
            UpdateTZoneGauge (wnd);
        }
        UpdateCPUGauge(wnd);
        return TRUE;

    case WM_INITDIALOG:

        // Fill TZ structure with initial values

        UpdateTZoneData (g_TZonePtr, g_WmiHandle);

        // Initialize all controls

        UpdateTZoneListBox (wnd);
        UpdateTZoneDetails (wnd);
        UpdateTZoneGauge (wnd);
        UpdateCPUGauge(wnd);

        // Initialize polling timer

        SetTimer (wnd,
                  TIMER_ID,
                  TIMER_POLL_INTERVAL,
                  NULL);

        // Set gauge colors

        SendDlgItemMessage (wnd,
                            IDC_TZTEMP1,
                            PBM_SETBARCOLOR,
                            0,
                            (LPARAM) (COLORREF) (0x0000FF));

        SendDlgItemMessage (wnd,
                            IDC_TZTEMP1,
                            PBM_SETBKCOLOR,
                            0,
                            (LPARAM) (COLORREF) (0x000000));

        SendDlgItemMessage (wnd,
                            IDC_THROTTLE,
                            PBM_SETBARCOLOR,
                            0,
                            (LPARAM) (COLORREF) (0x0000FF));

        SendDlgItemMessage (wnd,
                            IDC_THROTTLE,
                            PBM_SETBKCOLOR,
                            0,
                            (LPARAM) (COLORREF) (0x000000));


        return TRUE;

    case WM_COMMAND:
        switch (LOWORD (wParam)) {


        // Cleanup and exit

        case IDOK:
            KillTimer (wnd, TIMER_ID);
            EndDialog (wnd, 0);
            return TRUE;

            // Check to see if user selected a new TZ

        case IDC_TZSELECT:
            if (HIWORD (wParam) == CBN_SELCHANGE) {
                UpdateTZoneDetails (wnd);
                UpdateTZoneGauge (wnd);
                return TRUE;
            }

        case IDC_POLLTZ:

            // Check to see if user changed the TZ Polling setting

            if (HIWORD (wParam) == BN_CLICKED) {

                RetVal = SendDlgItemMessage (wnd,
                                             IDC_POLLTZ,
                                             BM_GETCHECK,
                                             (WPARAM)0,
                                             (LPARAM)0);

                if (!g_PollTz && RetVal == BST_CHECKED) {
                    g_PollTz = TRUE;
                }

                if (g_PollTz && RetVal == BST_UNCHECKED) {
                    g_PollTz = FALSE;
                }
            }
            break;

        case IDC_FAHR:

            // Check to see if user changed the Fahrenheit setting

            if (HIWORD(wParam) == BN_CLICKED) {
                RetVal = SendDlgItemMessage(wnd,
                                            IDC_FAHR,
                                            BM_GETCHECK,
                                            0,
                                            0);
                if (!g_Fahrenheit && RetVal == BST_CHECKED) {
                    g_Fahrenheit = TRUE;
                    SetDlgItemText(wnd, IDC_MINTEMP, "37F");
                    UpdateTZoneDetails(wnd);
                    UpdateTZoneGauge(wnd);
                } else if (g_Fahrenheit && RetVal == BST_UNCHECKED) {
                    g_Fahrenheit = FALSE;
                    SetDlgItemText(wnd, IDC_MINTEMP, "276K");
                    UpdateTZoneDetails(wnd);
                    UpdateTZoneGauge(wnd);
                }
            }


        default:
            break;

        }

    default:
        break;

    }

    return 0;
}

/*++

Routine Description:

    Issue WMI call to update TZ structures

Arguments:

    ReturnedTZoneInfo - Pointer to array of TZ structures
    Handle - Handle to WMI

Return Value:

    FALSE if no TZs were updated, TRUE if one or more TZs have an update

--*/

ULONG
UpdateTZoneData (
                IN OUT PTZONE_INFO ReturnedTZoneInfo,
                IN WMIHANDLE *Handle
                )
{
    ULONG status = 0;
    ULONG BufferSize = 0;
    PWNODE_ALL_DATA WmiAllData;
    PTHERMAL_INFORMATION ThermalInfo;
    ULONG Offset = 0;
    UCHAR *AllDataBuffer = 0;
    UCHAR *InstanceName = 0;
    ULONG TZCount = 0;
    ULONG Temp = 0;
    SYSTEMTIME SysTime;
    BOOL Updated = FALSE;

    status = WmiQueryAllData (Handle,
                              &BufferSize,
                              0);

    if (status != ERROR_INSUFFICIENT_BUFFER) {
        return FALSE;
    }

    AllDataBuffer = malloc (BufferSize);

    if (!AllDataBuffer) {

        return FALSE;

    }

    status = WmiQueryAllData (Handle,
                              &BufferSize,
                              AllDataBuffer);

    if (status != ERROR_SUCCESS) {
        free (AllDataBuffer);
        return FALSE;
    }

    // BUG BUG Assuming Thermal GUID only has one instance

    while (TZCount < MAX_THERMAL_ZONES) {

        WmiAllData = (PWNODE_ALL_DATA) AllDataBuffer;

        if (WmiAllData->WnodeHeader.Flags & WNODE_FLAG_FIXED_INSTANCE_SIZE) {

            ThermalInfo = (PTHERMAL_INFORMATION) &AllDataBuffer[WmiAllData->DataBlockOffset];
        } else {

            ThermalInfo = (PTHERMAL_INFORMATION) &AllDataBuffer[WmiAllData->OffsetInstanceDataAndLength[0].OffsetInstanceData];
        }

        Offset = (ULONG) AllDataBuffer[WmiAllData->OffsetInstanceNameOffsets];

        InstanceName = (UCHAR *) &AllDataBuffer[Offset + 2];

        // Update TZone structure if timestamp has changed

        if (!ReturnedTZoneInfo[TZCount].TZoneIndex || (ThermalInfo->ThermalStamp != ReturnedTZoneInfo[TZCount].ThermalInfo.ThermalStamp)) {

            strcpy (ReturnedTZoneInfo[TZCount].TZoneName, InstanceName);
            GetSystemTime (&SysTime);
            ReturnedTZoneInfo[TZCount].TimeStamp = SystemTimeToUlong (&SysTime);
            ReturnedTZoneInfo[TZCount].TZoneIndex = TZCount + 1;
            memcpy (&ReturnedTZoneInfo[TZCount].ThermalInfo,
                    ThermalInfo,
                    sizeof (THERMAL_INFORMATION));
            Updated = TRUE;
        }

        if (!WmiAllData->WnodeHeader.Linkage) {

            break;
        }

        AllDataBuffer += WmiAllData->WnodeHeader.Linkage;

        TZCount ++;
    }

    free (AllDataBuffer);

    return Updated;
}

/*++

Routine Description:

    Convert a system time structure to a 64bit ULONG

Arguments:

    SysTime - Pointer to system time structure to compare against current time

Return Value:

    Number of elapsed seconds between SysTime and current time

--*/

ULONG64
SystemTimeToUlong (
                  IN LPSYSTEMTIME SysTime
                  )

{
    ULONG64 TimeCount = 0;

    // BUG BUG Doesn't account for leap year

    TimeCount += SysTime->wYear * 31536000;
    TimeCount += SysTime->wMonth * 2628000;
    TimeCount += SysTime->wDay * 86400;
    TimeCount += SysTime->wHour * 3600;
    TimeCount += SysTime->wMinute * 60;
    TimeCount += SysTime->wSecond;

    return TimeCount;
}

/*++

Routine Description:

    Sets the cooling mode to ACTIVE, PASSIVE, or UPDATE ONLY.  This is accomplished by
    changing the FanThrottleTolerance value in the power policy.  Setting it to maxthrottle
    effectively puts the system into PASSIVE cooling mode.  Setting it to 100% will put
    the system in ACTIVE cooling mode UNLESS the current temperature exceeds the passive
    cooling trip points.

Arguments:

    Mode - Value to select the new cooling mode

Return Value:

    None

--*/

VOID
SetCoolingMode (
               IN UCHAR Mode
               )

{
    SYSTEM_POWER_POLICY SysPolicy;
    ULONG Status = 0;
    UCHAR TempFanThrottleTolerance = 0;

    // BUG BUG - This mechanism will currently only for while the machine is on AC.

    Status = NtPowerInformation(
                               SystemPowerPolicyAc,
                               0,
                               0,
                               &SysPolicy,
                               sizeof (SysPolicy)
                               );

    if (Status != ERROR_SUCCESS) {

        return;
    }

    switch (Mode) {

    case COOLING_PASSIVE:
        SysPolicy.FanThrottleTolerance = SysPolicy.MinThrottle;
        break;

    case COOLING_ACTIVE:
        SysPolicy.FanThrottleTolerance = 100;
        break;

    case COOLING_UPDATE_TZONE:
        TempFanThrottleTolerance = SysPolicy.FanThrottleTolerance;
        SysPolicy.FanThrottleTolerance = SysPolicy.FanThrottleTolerance != SysPolicy.MinThrottle ? SysPolicy.MinThrottle : 100;
        break;

    default:
        return;
    }

    Status = NtPowerInformation(
                               SystemPowerPolicyAc,
                               &SysPolicy,
                               sizeof (SysPolicy),
                               &SysPolicy,
                               sizeof (SysPolicy)
                               );

    if (Status != ERROR_SUCCESS) {

        return;
    }

    if (Mode == COOLING_UPDATE_TZONE) {

        SysPolicy.FanThrottleTolerance = TempFanThrottleTolerance;

        Status = NtPowerInformation(
                                   SystemPowerPolicyAc,
                                   &SysPolicy,
                                   sizeof (SysPolicy),
                                   &SysPolicy,
                                   sizeof (SysPolicy)
                                   );

        if (Status != ERROR_SUCCESS) {

            return;
        }
    }

}

/*++

Routine Description:

    Upgrades the process's access permission to change system power policy

Arguments:

    None

Return Value:

    None

--*/


VOID
UpgradePrivileges (
                  VOID
                  )
{
    TOKEN_PRIVILEGES tkp;
    HANDLE hToken;

    OpenProcessToken (GetCurrentProcess(),
                      TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                      &hToken);

    LookupPrivilegeValue (NULL,
                          SE_SHUTDOWN_NAME,
                          &tkp.Privileges[0].Luid);

    tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    AdjustTokenPrivileges (hToken,
                           FALSE,
                           &tkp,
                           0,
                           NULL,
                           0);

}

/*++

Routine Description:

    Updates the entries presented in the TZ selection combo box

Arguments:

    wnd - A handle to the control's window

Return Value:

    None

--*/


VOID
UpdateTZoneListBox (
                   IN HANDLE wnd
                   )

{
    ULONG Count = 0;

    // Reset the contents

    SendDlgItemMessage (wnd,
                        IDC_TZSELECT,
                        CB_RESETCONTENT,
                        0,
                        0);

    while (Count < MAX_THERMAL_ZONES) {

        if (g_TZonePtr[Count].TZoneIndex) {

            SendDlgItemMessage (wnd,
                                IDC_TZSELECT,
                                CB_ADDSTRING,
                                0,
                                (LPARAM) g_TZonePtr[Count].TZoneName);
        } else {

            break;
        }

        Count ++;
    }

    // Automatically select first TZone

    SendDlgItemMessage (wnd,
                        IDC_TZSELECT,
                        CB_SETCURSEL,
                        0,
                        0);

}

/*++

Routine Description:

    Updates the details for the currently selected TZ

Arguments:

    wnd - A handle to the control's window

Return Value:

    None

--*/

VOID
UpdateTZoneDetails (
                   IN HANDLE wnd
                   )
{
    UCHAR text[1000], texttmp [1000];
    UCHAR CurrentTZone = 0;
    LRESULT RetVal = 0;
    UCHAR Count = 0;
    ULONG Fahrenheit;

    RetVal = SendDlgItemMessage (wnd,
                                 IDC_TZSELECT,
                                 CB_GETCURSEL,
                                 0,
                                 0);

    if (RetVal == CB_ERR) {

        return;
    }

    if (g_Fahrenheit) {
        Fahrenheit = K_TO_F(g_TZonePtr[RetVal].ThermalInfo.PassiveTripPoint);
        sprintf (text,
                 "Passive Trip Point:\t%d.%dF\nThermal Constant 1:\t%d\nThermal Constant 2:\t%d",
                 Fahrenheit / 10,
                 Fahrenheit % 10,
                 g_TZonePtr[RetVal].ThermalInfo.ThermalConstant1,
                 g_TZonePtr[RetVal].ThermalInfo.ThermalConstant2);

    } else {
        sprintf (text,
                 "Passive Trip Point:\t%d.%dK\nThermal Constant 1:\t%d\nThermal Constant 2:\t%d",
                 g_TZonePtr[RetVal].ThermalInfo.PassiveTripPoint / 10,
                 g_TZonePtr[RetVal].ThermalInfo.PassiveTripPoint % 10,
                 g_TZonePtr[RetVal].ThermalInfo.ThermalConstant1,
                 g_TZonePtr[RetVal].ThermalInfo.ThermalConstant2);
    }

    SetDlgItemText (wnd,
                    IDC_PSVDETAILS,
                    text);

    ZeroMemory (&text, sizeof (text));

    while (Count < g_TZonePtr[RetVal].ThermalInfo.ActiveTripPointCount) {
        if (g_Fahrenheit) {
            Fahrenheit = K_TO_F(g_TZonePtr[RetVal].ThermalInfo.ActiveTripPoint[Count]);
            sprintf (texttmp,
                     "Active Trip Point #%d:\t%d.%dF\n",
                     Count,
                     Fahrenheit / 10,
                     Fahrenheit % 10);
        } else {
            sprintf (texttmp,
                     "Active Trip Point #%d:\t%d.%dK\n",
                     Count,
                     g_TZonePtr[RetVal].ThermalInfo.ActiveTripPoint[Count] / 10,
                     g_TZonePtr[RetVal].ThermalInfo.ActiveTripPoint[Count] % 10);
        }

        strcat (text, texttmp);
        Count ++;
    }

    SetDlgItemText (wnd,
                    IDC_ACXDETAILS,
                    text);

}

/*++

Routine Description:

    Updates the progress bar control (temp gauge) for the currently selected TZ

Arguments:

    wnd - A handle to the control's window

Return Value:

    None

--*/

VOID
UpdateTZoneGauge (
                 IN HANDLE wnd
                 )

{
    UCHAR CurrentTZone = 0;
    LRESULT RetVal = 0;
    UCHAR text[20];
    ULONG Fahrenheit;

    RetVal = SendDlgItemMessage (wnd,
                                 IDC_TZSELECT,
                                 CB_GETCURSEL,
                                 0,
                                 0);

    if (RetVal == CB_ERR) {

        return;
    }

    if (g_Fahrenheit) {

        Fahrenheit = K_TO_F(g_TZonePtr[RetVal].ThermalInfo.CriticalTripPoint);
        sprintf (text,
                 "%d.%dF",
                 Fahrenheit / 10,
                 Fahrenheit % 10);

    } else {
        sprintf (text,
                 "%d.%dK",
                 g_TZonePtr[RetVal].ThermalInfo.CriticalTripPoint / 10,
                 g_TZonePtr[RetVal].ThermalInfo.CriticalTripPoint % 10);
    }

    SetDlgItemText (wnd,
                    IDC_CRTTEMP,
                    text);

    if (g_Fahrenheit) {

        Fahrenheit = K_TO_F(g_TZonePtr[RetVal].ThermalInfo.CurrentTemperature);
        sprintf (text,
                 "Current: %d.%dF",
                 Fahrenheit / 10,
                 Fahrenheit % 10);

    } else {
        sprintf (text,
                 "Current: %d.%dK",
                 g_TZonePtr[RetVal].ThermalInfo.CurrentTemperature / 10,
                 g_TZonePtr[RetVal].ThermalInfo.CurrentTemperature % 10);

    }
    SetDlgItemText (wnd,
                    IDC_CURTEMP,
                    text);

    SendDlgItemMessage (wnd,
                        IDC_TZTEMP1,
                        PBM_SETRANGE,
                        0,
                        MAKELPARAM(2760, g_TZonePtr[RetVal].ThermalInfo.CriticalTripPoint));

    SendDlgItemMessage (wnd,
                        IDC_TZTEMP1,
                        PBM_SETPOS,
                        (INT) g_TZonePtr[RetVal].ThermalInfo.CurrentTemperature,
                        0);
    return;
}


VOID
UpdateCPUGauge(
    IN HWND hwnd
    )
/*++

Routine Description:

    Updates the current CPU throttling gauge

Arguments:

    hwnd - Supplies the parent dialog hwnd

Return Value:

    None

--*/

{
    PROCESSOR_POWER_INFORMATION ProcInfo;
    NTSTATUS Status;
    UCHAR text[40];

    Status = NtPowerInformation(ProcessorInformation,
                                NULL,
                                0,
                                &ProcInfo,
                                sizeof(ProcInfo));
    if (NT_SUCCESS(Status)) {
        sprintf(text, "%d MHz", ProcInfo.MaxMhz);
        SetDlgItemText(hwnd, IDC_MAXTHROTTLE, text);

        sprintf(text,
                "Current %d MHz (%d %%)",
                ProcInfo.CurrentMhz,
                ProcInfo.CurrentMhz*100/ProcInfo.MaxMhz);
        SetDlgItemText(hwnd, IDC_CURTHROTTLE, text);

        //
        // update throttle gauge
        //
        SendDlgItemMessage (hwnd,
                            IDC_THROTTLE,
                            PBM_SETRANGE,
                            0,
                            MAKELPARAM(0, ProcInfo.MaxMhz));

        SendDlgItemMessage (hwnd,
                            IDC_THROTTLE,
                            PBM_SETPOS,
                            (INT) ProcInfo.CurrentMhz,
                            0);

        //
        // update idle information
        //
        sprintf(text, "C%d", ProcInfo.MaxIdleState);
        SetDlgItemText(hwnd, IDC_MAXIDLE, text);

        //
        // The current idle state reporting ranges from 0-2
        // the max idle state reporting ranges from 1-3
        // probably current is wrong and should be 0-3 representing C0-C3
        // for now add one and don't run this on an MP machine!
        //
        sprintf(text, "C%d", ProcInfo.CurrentIdleState + 1);
        SetDlgItemText(hwnd, IDC_CURIDLE, text);

    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\uixport\uixport.c ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1990-1992              **/
/**********************************************************************/

/*
    uixport.c
    This program parses the output of the "COFF -DUMP -SYMBOLS" command
    and extract all public symbols.  This is used to generate .DEF files
    for DLLs.


    FILE HISTORY:
        KeithMo     09-Aug-1992 00.00.00 Created.
        KeithMo     14-Sep-1992 00.00.01 Strip stdcall decoration from symbols.
        KeithMo     16-Oct-1992 00.00.02 Handle goofy []()* in coff output.

        DavidHov    18-Sep-1993 00.00.04 Added exclusion list processing.
                                         The exlusion list is generated
                                         mechanically and constiutes all the
                                         symbols which are not imported
                                         by any known NETUI/RAS/MAC (et al.)
                                         binary.

        DavidHov    22-Sep-1993 00.00.05 Added symbol ignore table and logic.
                                         The ignore table at this time ignores
                                         only the gigantic symbols generated
                                         by C8 when /Gf is used; these names
                                         are strings which are to be merged
                                         at link time.

        DaveWolfe   06-Jul-1994 00.01.01 (Motorola) Added -ppc option for
                                         PowerPC to strip entry point symbols
                                         generated for PPC TOC.
*/

#include <ctype.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <search.h>


//
//  This is the maximum length (in characters) of any line we'll
//  receive from COFF.  If we receive a longer line, the program
//  won't crash, but we may miss a public symbol.
//

#define MAX_LINE_FROM_COFF      2000

//
//  This is the maximum length (in characters) of any symbol we'll
//  receive from COFF.
//

#define MAX_SYMBOL              247

//
//  This is the maximum length (in characters) of any error message
//  we'll display.
//

#define MAX_ERROR_MESSAGE       256

//
//  This is the length (in characters) of the header->output copy buffer.
//

#define HEADER_COPY_BUFFER_SIZE 256



//
//  Messages.
//

char _szBanner[]                = "%s version 00.01.01\n";
char _szCannotOpenForRead[]     = "Cannot open %s for read access.";
char _szCannotOpenForWrite[]    = "Cannot open %s for write access.";
char _szErrorCopyingHeader[]    = "Error copying header to output.";
char _szInvalidSwitch[]         = "Invalid switch '%c'.\n\n";
char _szSymbolTooLong[]         = "Symbol %s exceeds max symbol length!\n";
char _szExclusionError[]        = "Error processing exclusion list file; ignored" ;
char _szExclusionEmpty[]        = "Exclusion list file specified is empty; ignored" ;


//
//  Globals.
//

char * _pszProgramName;
FILE * _fileIn;
FILE * _fileOut;
FILE * _fileHeader;
int    _fStripLeadingUnderscore;
int    _fNukeStdcallDecoration;
int    _fPowerPC;
int    _fIA64;

char * _pszExclusionListFile = NULL ;
void * _pvExclusionBlock = NULL ;
char * * _apszExclusionArray = NULL ;
int    _cExclusionItems = -1 ;
int    _cExcludedItems = 0 ;
int    _cIgnoredItems = 0 ;


  //  This table contains the prefixes of symbol names to ignore
  //  while building the DEF file.  See ValidSymbol().

static char * apszIgnore [] =
{
    "??_C@_",       //  Ignore generated string symbol names
    NULL
};


//
//  Prototypes.
//

int __cdecl main( int    cArgs,
                   char * pArgs[] );

void Cleanup( void );

void CopyHeaderToOutput( FILE * fHeader,
                         FILE * fOutput );

int ExtractSymbol( char * pszLineFromCoff,
                   char * pszSymbol );

void __cdecl FatalError( int    err,
                 char * pszFmt,
                 ... );

void __cdecl NonFatalError( char * pszFmt,
                    ... );

int IsHexNumber( char * pszHexNumber );

char * NoPath( char * pszPathName );

void ProcessCommandLine( int    cArgs,
                         char * pArgs[] );

void StripStdcallDecoration( char * pszSymbol );

void Usage( void );

   //  Create the exclusion list.

int CreateExclusionList ( char * pszFileName,
                          void * * pvData,
                          char * * * apszStrings ) ;

   //  Check the excluded symbol list for this name

int ExcludedSymbol ( char * pszSymbol ) ;

int ValidSymbol ( const char * psz ) ;

/*******************************************************************

    NAME:       main

    SYNOPSIS:   C program entrypoint.

    ENTRY:      cArgs                   - Number of command line arguments.

                pArgs                   - An array of pointers to the
                                          command line arguments.

    RETURNS:    int                     -  0 if everything ran OK,
                                          !0 if an error occurred.

    NOTES:      See the Usage() function for valid command line arguments.

    HISTORY:
        KeithMo     09-Aug-1992 Created.
        KeithMo     14-Sep-1992 Strip stdcall decoration from symbols.

********************************************************************/
int __cdecl main( int    cArgs,
                   char * pArgs[] )
{
    //
    //  A line read from COFF.
    //

    char szLineFromCoff[MAX_LINE_FROM_COFF+1];

    //
    //  A symbol extracted from the COFF line.
    //

    char szSymbol[MAX_SYMBOL+1];

    //
    //  Get the program name, for our messages.
    //

    _pszProgramName = NoPath( pArgs[0] );

    //
    //  Announce ourselves.
    //

    fprintf( stderr,
             _szBanner,
             _pszProgramName );

    //
    //  Parse the command line arguments.
    //

    ProcessCommandLine( cArgs, pArgs );

    //
    //  If requested, copy the header file before processing
    //  the COFF output.
    //

    if( _fileHeader != NULL )
    {
        CopyHeaderToOutput( _fileHeader, _fileOut );
    }

    //
    //  If an exclusion list file was specified, process it.
    //  If it's empty, ignore it.
    //

    if ( _pszExclusionListFile )
    {
        _cExclusionItems = CreateExclusionList( _pszExclusionListFile,
                                                & _pvExclusionBlock,
                                                & _apszExclusionArray ) ;

        if ( _cExclusionItems < 0 )
        {
            _pszExclusionListFile = NULL ;
           NonFatalError( _szExclusionError ) ;
        }
        else
        if ( _cExclusionItems == 0 )
        {
            _pszExclusionListFile = NULL ;
           NonFatalError( _szExclusionEmpty ) ;
        }
    }

    //
    //  Read the lines from coff, extract the symbols, and
    //  write them to the output file.
    //

    while( fgets( szLineFromCoff, MAX_LINE_FROM_COFF, _fileIn ) != NULL )
    {
        char * pszDisplay = szSymbol;

        if( !ExtractSymbol( szLineFromCoff, szSymbol ) )
        {
            continue;
        }

        if ( ! _fNukeStdcallDecoration )
        {
            StripStdcallDecoration( szSymbol );
        }

        if ( ! ValidSymbol( pszDisplay ) )
        {
            _cIgnoredItems++ ;
            continue ;
        }

        if ( _pszExclusionListFile && ExcludedSymbol( szSymbol ) )
        {
            _cExcludedItems++ ;
            continue ;
        }

        if( _fStripLeadingUnderscore && ( *pszDisplay == '_' ) )
        {
            pszDisplay++;
        }

        fprintf( _fileOut, "%s\n", pszDisplay );
    }

    fprintf( _fileOut, "\032" );

    //  Give a synopsis of exclusion file processesing.

    fprintf( stdout, "\nSymbols ignored: %ld\n", _cIgnoredItems ) ;

    if ( _pszExclusionListFile )
    {
        fprintf( stdout, "\nExcluded symbols registered: %ld, excluded: %ld\n",
                 _cExclusionItems, _cExcludedItems ) ;
    }

    //
    //  Cleanup any open files, then exit.
    //

    Cleanup();
    return 0;

}   // main



/*******************************************************************

    NAME:       Cleanup

    SYNOPSIS:   Cleanup the app just before termination.  Closes any
                open files, frees memory buffers, etc.

    HISTORY:
        KeithMo     09-Aug-1992 Created.

********************************************************************/
void Cleanup( void )
{
    if( _fileHeader != NULL )
    {
        fclose( _fileHeader );
    }

    if( _fileIn != stdin )
    {
        fclose( _fileIn );
    }

    if( _fileOut != stdout )
    {
        fclose( _fileOut );
    }

    if ( _pvExclusionBlock )
    {
        free( _pvExclusionBlock ) ;
    }

    if ( _apszExclusionArray )
    {
        free( _apszExclusionArray ) ;
    }

}   // Cleanup



/*******************************************************************

    NAME:       CopyHeaderToOutput

    SYNOPSIS:   Copies the specified header file to the output file.

    ENTRY:      fHeader                 - An open file stream (read access)
                                          to the header file.

                fOutput                 - An open file stream (write access)
                                          to the output file.

    NOTES:      If any errors occur, FatalError() is called to terminate
                the app.

    HISTORY:
        KeithMo     09-Aug-1992 Created.

********************************************************************/
void CopyHeaderToOutput( FILE * fHeader,
                         FILE * fOutput )
{
    char   achBuffer[HEADER_COPY_BUFFER_SIZE];
    size_t cbRead;

    while( ( cbRead = fread( achBuffer,
                             sizeof(char),
                             HEADER_COPY_BUFFER_SIZE,
                             fHeader ) ) != 0 )
    {
        if( fwrite( achBuffer,
                    sizeof(char),
                    cbRead,
                    fOutput ) < cbRead )
        {
            break;
        }
    }

    if( ferror( fHeader ) || ferror( fOutput ) )
    {
        FatalError( 2, _szErrorCopyingHeader );
    }

}   // CopyHeaderToOutput



/*******************************************************************

    NAME:       ExtractSymbol

    SYNOPSIS:   Extracts a public symbol from a COFF output line.

    ENTRY:      pszLineFromCoff         - A text line output from the
                                          "COFF -DUMP -SYM" command.

                                          Note:  The text in the line
                                          will be modified by the strtok()
                                          function!

                pszSymbol               - Will receive the extracted symbol,
                                          if one is found.

    RETURNS:    int                     - !0 if a symbol was extracted,
                                           0 otherwise.

    NOTES:      Here's an example of the input (output from LINK32).
                The symbol -$- indicates places where I broke the line
                for clarity.  This just one line:

               009 00000000 SECT2  notype ()    External     |    -$-
               ??0APPLICATION@@IAE@PAUHINSTANCE__@@HIIII@Z        -$-
               (protected:  __thiscall APPLICATION::APPLICATION(  -$-
               struct HINSTANCE__ *,int,unsigned int,unsigned int,-$-
               unsigned int,unsigned int))

               We choose only symbols which are part of a SECT and are
               marked as "notype" and "External"

    HISTORY:
        KeithMo     09-Aug-1992 Created.
        DavidHov    20-Oct-1993 update to new LINK32 output form.

********************************************************************/
int ExtractSymbol( char * pszLineFromCoff,
                   char * pszSymbol )
{
    char * pszDelimiters = " \t\n";
    char * pszSect       = "SECT";
    char * pszNoType     = "notype";
    char * pszExternal   = "External";
    char * pszToken;
    char * pszPotentialSymbol;
    char * pszScan;

    //
    //  Verify that the first token is a hex number.
    //

    pszToken = strtok( pszLineFromCoff, pszDelimiters );

    if( ( pszToken == NULL ) || !IsHexNumber( pszToken ) )
    {
        return 0;
    }

    //
    //  Verify that the second token is a hex number.
    //

    pszToken = strtok( NULL, pszDelimiters );

    if( ( pszToken == NULL ) || !IsHexNumber( pszToken ) )
    {
        return 0;
    }

    //
    //  The third token must be SECTn (where n is one
    //  or more hex digits).
    //

    pszToken = strtok( NULL, pszDelimiters );

    if( pszToken == NULL )
    {
        return 0;
    }

    if( (    _strnicmp( pszToken, pszSect, 4 ) )
          || ! IsHexNumber( pszToken + 4 ) )
    {
        return 0 ;
    }

    //
    //  Next, we have to have "notype"
    //
    pszToken = strtok( NULL, pszDelimiters );

    if( pszToken == NULL ||
        _stricmp( pszToken, pszNoType ) )
    {
        return 0;
    }

    //
    //  Functions have a () next, data exports don't.
    //
    pszToken = strtok( NULL, pszDelimiters );

    if( pszToken == NULL )
    {
        return 0;
    }

    if ( strcmp( pszToken, "()" ) != 0 )
    {
        return 0;
    }

    //
    //  Next, we need "External"
    //
    pszToken = strtok( NULL, pszDelimiters );

    if( pszToken == NULL )
    {
        return 0;
    }

    if( pszToken == NULL ||
        _stricmp( pszToken, pszExternal ) )
    {
        return 0;
    }

    //
    //  Now, the symbol introducer: "|"
    //
    pszToken = strtok( NULL, pszDelimiters );

    if( pszToken == NULL ||
        _stricmp( pszToken, "|" ) )
    {
        return 0;
    }

    //
    //  Finally, the mangled (decorated) symbol itself.
    //

    pszPotentialSymbol = strtok( NULL, pszDelimiters );

    if( pszPotentialSymbol == NULL )
    {
        return 0;
    }

    //
    // Strip prefix from PowerPC function symbols
    //
    if( _fPowerPC )
    {
        pszPotentialSymbol += 2 ;
    }

    //
    // Strip prefix from IA-64 function symbols
    //
    if( _fIA64 )
    {
        pszPotentialSymbol += 1 ;
    }

    if( strlen( pszPotentialSymbol ) > MAX_SYMBOL )
    {
        fprintf( stderr,
                 _szSymbolTooLong,
                 pszPotentialSymbol );

        return 0;
    }

    //
    //  Got one.
    //

    strcpy( pszSymbol, pszPotentialSymbol );
    return 1;

}   // ExtractSymbol



/*******************************************************************

    NAME:       FatalError and NonFatalError

    SYNOPSIS:   Prints an error message to stderr, then terminates
                the application.

    ENTRY:      err                     - An error code for the exit()
                                          stdlib function.

                pszFmt                  - A format string for vsprintf().

                ...                     - Any other arguments required
                                          by the format string.

    HISTORY:
        KeithMo     09-Aug-1992 Created.

********************************************************************/

void __cdecl NonFatalError (
    char * pszFmt,
    ... )
{
    char    szBuffer[MAX_ERROR_MESSAGE+1];
    va_list ArgPtr;

    va_start( ArgPtr, pszFmt );

    fprintf( stderr, "%s => ", _pszProgramName );
    vsprintf( szBuffer, pszFmt, ArgPtr );
    fprintf( stderr, "%s\n", szBuffer );

    va_end( ArgPtr );

}   // NonFatalError

void __cdecl FatalError( int    err,
                 char * pszFmt,
                 ... )
{
    char    szBuffer[MAX_ERROR_MESSAGE+1];
    va_list ArgPtr;

    va_start( ArgPtr, pszFmt );

    fprintf( stderr, "%s => ", _pszProgramName );
    vsprintf( szBuffer, pszFmt, ArgPtr );
    fprintf( stderr, "%s\n", szBuffer );

    va_end( ArgPtr );

    Cleanup();
    exit( err );

}   // FatalError



/*******************************************************************

    NAME:       IsHexNumber

    SYNOPSIS:   Determines if the specified string contains a hexadecimal
                number.

    ENTRY:      pszHexNumber            - The hex number.

    EXIT:       int                     - !0 if it *is* a hex number,
                                           0 if it isn't.

    HISTORY:
        KeithMo     12-Aug-1992 Created.

********************************************************************/
int IsHexNumber( char * pszHexNumber )
{
    int  fResult = 1;
    char ch;

    while( ch = *pszHexNumber++ )
    {
        if( !isxdigit( ch ) )
        {
            fResult = 0;
            break;
        }
    }

    return fResult;

}   // IsHexNumber



/*******************************************************************

    NAME:       NoPath

    SYNOPSIS:   Extracts the filename portion of a path.

    ENTRY:      pszPathName             - Contains a path name.  The name
                                          is not necessarily canonicalized,
                                          and may contain just a filename
                                          component.

    EXIT:       char *                  - The filename component.

    HISTORY:
        KeithMo     09-Aug-1992 Created.

********************************************************************/
char * NoPath( char * pszPathName )
{
    char * pszTmp;
    char   ch;

    pszTmp = pszPathName;

    while( ( ch = *pszPathName++ ) != '\0' )
    {
        if( ( ch == '\\' ) || ( ch == ':' ) )
        {
            pszTmp = pszPathName;
        }
    }

    return pszTmp;

}   // NoPath



/*******************************************************************

    NAME:       ProcessCommandLine

    SYNOPSIS:   Parse command line arguments, setting appropriate globals.

    ENTRY:      cArgs                   - Number of command line arguments.

                pArgs                   - An array of pointers to the
                                          command line arguments.

    NOTES:      See the Usage() function for valid command line arguments.

    HISTORY:
        KeithMo     12-Aug-1992 Broke out of main().
        DaveWolfe   06-Jul-1994 Added -ppc.

********************************************************************/
void ProcessCommandLine( int    cArgs,
                         char * pArgs[] )
{
    int  i;
    char chSwitch;

    //
    //  Setup our defaults.
    //

    _fileIn     = stdin;
    _fileOut    = stdout;
    _fileHeader = NULL;

    _fStripLeadingUnderscore = 0;
    _fNukeStdcallDecoration  = 0;
    _fPowerPC                = 0;
    _fIA64                   = 0;

    //
    //  Parse the command line arguments.
    //

    for( i = 1 ; i < cArgs ; i++ )
    {
        //
        //  Get the argument.
        //

        char * pszArg = pArgs[i];
        char * pszParam;

        //
        //  All of our valid arguments *must* start
        //  with a switch character.  Enforce this.
        //

        if( ( *pszArg != '-' ) && ( *pszArg != '/' ) )
        {
            Usage();
        }

        chSwitch = *++pszArg;

        //
        //  pszParam will either be NULL (for switches such
        //  as -s) or point to the text just past the colon
        //  (for switches such as -i:file).
        //

        if( ( pszArg[1] == ':' ) && ( pszArg[2] != '\0' ) )
        {
            pszParam = pszArg + 2;
        }
        else
        {
            pszParam = NULL;
        }

        //
        //  Check for valid arguments.
        //

        switch( chSwitch )
        {
        case 'p' :
        case 'P' :
            //
            //  -ppc
            //
            //  Strip prefix ".." from "..symbol".
            //
            if( _stricmp( pszArg, "ppc") != 0 )
            {
                Usage();
            }

            _fPowerPC = 1;
            break;

        case 'h' :
        case 'H' :
            //
            //  -h:header_file
            //
            //  If a header file has already been specified, or
            //  if there is no parameter after the switch, bag-out.
            //

            if( ( _fileHeader != NULL ) || ( pszParam == NULL ) )
            {
                Usage();
            }

            _fileHeader = fopen( pszParam, "r" );

            if( _fileHeader == NULL )
            {
                FatalError( 1, _szCannotOpenForRead, pszParam );
            }
            break;

        case 'i' :
        case 'I' :

            if (pszParam == NULL) {
                //
                //  -ia64
                //
                //  Strip prefix "." from ".symbol".
                //
                if( _stricmp( pszArg, "ia64") != 0 )
                {
                    Usage();
                }

                _fIA64 = 1;
            } else {

                //
                //  -i:input_file
                //
                //  If an input file has already been specified, or
                //  if there is no parameter after the switch, bag-out.
                //

                if( ( _fileIn != stdin ) || ( pszParam == NULL ) )
                {
                    Usage();
                }

                _fileIn = fopen( pszParam, "r" );

                if( _fileIn == NULL )
                {
                    FatalError( 1, _szCannotOpenForRead, pszParam );
                }
            }
            break;

        case 'o' :
        case 'O' :
            //
            //  -o:output_file
            //
            //  If an output file has already been specified, or
            //  if there is no parameter after the switch, bag-out.
            //

            if( ( _fileOut != stdout ) || ( pszParam == NULL ) )
            {
                Usage();
            }

            _fileOut = fopen( pszParam, "w" );

            if( _fileOut == NULL )
            {
                FatalError( 1, _szCannotOpenForWrite, pszParam );
            }
            break;

        case 's' :
        case 'S' :
            //
            //  -s
            //
            //  If this switch has already been specified, bag-out.
            //

            if( _fStripLeadingUnderscore )
            {
                Usage();
            }

            _fStripLeadingUnderscore = 1;
            break;

        case 'n' :
        case 'N' :
            _fNukeStdcallDecoration = 1 ;
            break ;

        case 'x' :
        case 'X' :
            _pszExclusionListFile = pszParam ;
            break ;

        case '?' :
            //
            //  -?
            //
            //  Give the poor user a clue.
            //

            Usage();
            break;

        default :
            //
            //  Invalid switch.
            //
            //  Tell the user the bad news, then bag-out.
            //

            fprintf( stderr, _szInvalidSwitch, chSwitch );
            Usage();
            break;
        }
    }

}   // ProcessCommandLine



/*******************************************************************

    NAME:       StripStdcallDecoration

    SYNOPSIS:   Stdcall builds use a weak form of type-safe linkage.
                This is implemented by appending "@nn" to the end
                of each symbol, where "nn" is the number of *bytes*
                passed as parameters.

                COFF, on the other hand, does *not* want to see
                this symbol decoration in .DEF files.  So, we remove
                it here.

    ENTRY:      pszSymbol               - The symbol to munge.

    NOTES:      This routine is *NOT* DBCS safe!  Do we care?

    HISTORY:
        KeithMo     14-Sep-1992 Created.

********************************************************************/
void StripStdcallDecoration( char * pszSymbol )
{
    int count = 0 ;

    //
    //  Find the last character.
    //

    pszSymbol += strlen( pszSymbol ) - 1;

    //
    //  Skip any *decimal* numbers.
    //

    while( isdigit( *pszSymbol ) )
    {
        pszSymbol--;
        count++ ;
    }

    //
    //  If we're now pointing at a "@", terminate the string here.
    //

    if( count && *pszSymbol == '@' )
    {
        *pszSymbol = '\0';
    }

}   // StripStdcallDecoration



/*******************************************************************

    NAME:       Usage

    SYNOPSIS:   Displays usage information if the user gives us a
                bogus command line.

    HISTORY:
        KeithMo     09-Aug-1992 Created.

        DaveWolfe   06-Jul-1994 Added -ppc option.

********************************************************************/
void Usage( void )
{
    fprintf( stderr, "use: %s [options]\n", _pszProgramName );
    fprintf( stderr, "\n" );
    fprintf( stderr, "Valid options are:\n" );
    fprintf( stderr, "    -i:input_file  = source file\n" );
    fprintf( stderr, "    -o:output_file = destination file\n" );
    fprintf( stderr, "    -h:header_file = header to prepend before symbols\n" );
    fprintf( stderr, "    -s             = strip first leading underscore from symbols\n" );
    fprintf( stderr, "    -n             = do not strip __stdcall decoration @nn\n" );
    fprintf( stderr, "    -x:excl_file   = name of file containing excluded symbols\n" );
    fprintf( stderr, "    -ppc           = input is PowerPC symbol dump\n" );
    fprintf( stderr, "    -ia64          = input is IA-64 symbol dump\n" );
    fprintf( stderr, "    -?             = show this help\n" );
    fprintf( stderr, "\n" );
    fprintf( stderr, "Defaults are:\n" );
    fprintf( stderr, "    input_file  = stdin\n" );
    fprintf( stderr, "    output_file = stdout\n" );
    fprintf( stderr, "    header_file = none\n" );
    fprintf( stderr, "    don't strip first leading underscore from symbol\n" );
    fprintf( stderr, "    input is not PowerPC symbol dump\n" );

    Cleanup();
    exit( 1 );

}   // Usage


/*******************************************************************

    NAME:       CreateExclusionList

    SYNOPSIS:   Reads a text file of excluded export names into memory,
                sorts it and builds a lookup table compatible with
                bsearch().

                Returns -1 if failure or the count of the number
                of items in the created array.

    HISTORY:

********************************************************************/

int __cdecl qsortStrings ( const void * pa, const void * pb )
{
    return strcmp( *((const char * *) pa), *((const char * *) pb) ) ;
}

int CreateExclusionList ( char * pszFileName,
                          void * * pvData,
                          char * * * apszStrings )
{
    int cItems, i ;
    int result = -1 ;
    long cbFileSize, cbBlockSize ;
    char * pszData = NULL,
         * psz,
         * pszNext ;

    char * * ppszArray = NULL ;

    char chRec [ MAX_LINE_FROM_COFF ] ;

    FILE * pf = NULL ;

    do
    {
        pf = fopen( pszFileName, "r" ) ;

        if ( pf == NULL )
            break;

        if (fseek( pf, 0, SEEK_END ) == -1) 
            break;
        cbFileSize = ftell( pf ) ;
        if (fseek( pf, 0, SEEK_SET ) == -1)
            break;

        cbBlockSize = cbFileSize + (cbFileSize / 2) ;

        pszData = (char *) malloc( cbBlockSize ) ;

        if ( pszData == NULL )
            break ;

        for ( cItems = 0, pszNext = pszData ;
              (!feof( pf )) && (psz = fgets( chRec, sizeof chRec, pf )) ; )
        {
            int lgt ;
            char * pszEnd ;

            while ( *psz <= ' ' && *psz != 0 )
            {
                psz++ ;
            }

            if ( (lgt = strlen( psz )) == 0 )
                continue ;

            pszEnd = psz + lgt ;

            do
            {
               --pszEnd ;
            } while ( pszEnd > psz && *pszEnd <= ' ' ) ;

            lgt = (int)(++pszEnd - psz) ;
            *pszEnd = 0 ;

            if ( pszNext + lgt - pszData >= cbBlockSize )
            {
                cItems = -1 ;
                break ;
            }

            strcpy( pszNext, psz ) ;
            pszNext += lgt+1 ;
            cItems++ ;
        }

        *pszNext = 0 ;

        if ( cItems <= 0 )
        {
            if ( cItems == 0 )
                result = 0 ;
            break ;
        }

        ppszArray = (char * *) malloc( cItems * sizeof (char *) ) ;
        if ( ppszArray == NULL )
            break ;

        for ( i = 0, pszNext = pszData ;
              *pszNext ;
              pszNext += strlen( pszNext ) + 1 )
        {
            ppszArray[i++] = pszNext ;
        }

        qsort( (void *) ppszArray,
               cItems,
               sizeof (char *),
               & qsortStrings ) ;

        result = cItems ;

    } while ( 0 ) ;

    if ( pf != NULL )
    {
        fclose( pf ) ;
    }

    if ( result <= 0 )
    {
        if ( pszData )
        {
            free( pszData ) ;
            pszData = NULL ;
        }
        if ( ppszArray )
        {
            free( ppszArray ) ;
            ppszArray = NULL ;
        }
    }

    *pvData = (void *) pszData ;
    *apszStrings = ppszArray ;

    return result ;
}

int ExcludedSymbol ( char * pszSymbol )
{
    if ( _apszExclusionArray == NULL )
    {
        return 0 ;
    }

    return bsearch( (void *) & pszSymbol,
                    (void *) _apszExclusionArray,
                    _cExclusionItems,
                    sizeof (char *),
                    & qsortStrings ) != NULL ;
}

int ValidSymbol ( const char * psz )
{
    int i = 0 ;

    for ( ; apszIgnore[i] ; i++ )
    {
        if ( _strnicmp( apszIgnore[i],
                        psz,
                        strlen( apszIgnore[i] ) ) == 0 )
            return 0 ;
    }
    return 1 ;
}

// End of UIXPORT.C
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\undel\undel.c ===
/*** UNDEL.C -  retrieve deleted files if possible ***************************
*
*       Copyright (c) 1987-1990, Microsoft Corporation.  All rights reserved.
*
* Purpose:
*  The three tools EXP, RM and UNDEL are used to delete files so
*  that they can be undeleted.  This is done my renaming the file into
*  a hidden directory called DELETED.
*
* Notes:
*  This tool allows the user to view a list of the files that have been
*  'deleted' from the current directory, and to undelete a file from
*  the list.
*
*  To view a list of undeleted files:  UNDEL
*
*  To undelete a file:  UNDEL filename [filename ...]
*
*  If more than one file by that name has been deleted, a list of the
*  deletions, by date, will be presented and the user prompted to
*  choose one.
*
*  If a file by that name exists currently, it is RM'ed before the
*  deleted file is restored.
*
* Revision History:
*  17-Oct-1990 w-barry Temporarily replaced 'rename' with 'rename_NT' until
*                      DosMove completely implemented on NT.
*  29-Jun-1990 SB Do not do index conversion if file is readonly ...
*  29-Jun-1990 SB print filename only once if one instance is to be undel'ed
*  08-Feb-1990 bw Do index file conversion in dump()
*  07-Feb-1990 bw Third arg to readNewIdxRec
*  08-Jan-1990 SB SLM version upgrading added; Add CopyRightYrs Macro
*  03-Jan-1990 SB define QH_TOPIC_NOT_FOUND
*  28-Dec-1989 SB Add #ifdef BEAUTIFY stuff
*  27-Dec-1989 SB Changes for new index file format
*  15-Dec-1989 SB Include os2.h instead of doscalls.h
*                 Qh return code 3 means 'Topic not Found'
*  14-Dec-1989 LN Update Copyright to include 1990
*  23-Oct-1989 LN Version no bumped to 1.01
*  02-Oct-1989 LN Changed Version no to 1.00
*  08-Aug-1989 bw Add Version number, update copyright
*  15-May-1989 wb Add /help
*  24-Jan-1989 bw Use C runtime rename() so fastcopy doesn't get dragged in.
*  30-Oct-1987 bw Changed 'DOS5' to 'OS2'
*  06-Apr-1987 bw Add Usage prompt for /<anything>
*  18-Oct-1990 w-barry Removed 'dead' code.
*  28-Nov-1990 w-barry Switched to Win32 API - Replaced DosQueryFSInfo() with
*                      GetDiskFreeSpace in the Dump() routine.
*
******************************************************************************/

/* I N C L U D E    Files */

#include <sys\types.h>
#include <sys\stat.h>
#include <dos.h>
#include <errno.h>
#include <fcntl.h>
#include <malloc.h>
#include <process.h>
#include <io.h>
#include <time.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include <math.h>
#include <stdlib.h>
#include <windows.h>
#include <tools.h>
#include <rm.h>

/* D E F I N E s */

#define CopyRightYrs "1987-90"
/* Need 2 steps, first to get correct values in and 2nd to paste them */
/* paste() is hacked to allow LEADING  ZEROES    */
#define paste(a, b, c) #a ".0" #b ".00" #c
#define VERSION(major, minor, buildno) paste(major, minor, buildno)
#define QH_TOPIC_NOT_FOUND 3

// Forward Function Declarations...
void       Usage( void );
void       dump( void );
void       undel( char * );
flagType   getRecord( int, int, char * );
long       pfile( char * );


/***  main - Entry point
*
* Usage:
*
*   See above
*
*************************************************************************/

__cdecl main(c, v)
int c;
char *v[];
{
    register char *p;

    ConvertAppToOem( c, v );
    SHIFT(c,v);
    if (!c)
        dump();
    else
        if (fSwitChr(**v)) {
            p = *v;
            if (!_strcmpi(++p, "help")) {
                int iRetCode = (int) _spawnlp(P_WAIT, "qh.exe", "qh", "/u",
                                        "undel.exe", NULL);
                /* for Return Code QH_TOPIC_NOT_FOUND do Usage(),
                 *   and -1 means that the spawn failed
                 */
                if (iRetCode != QH_TOPIC_NOT_FOUND && iRetCode != -1)
                    exit(0);
            }
            Usage();
        }
        while (c) {
            undel(*v);
            SHIFT(c,v);
        }
    return(0);
}


/*** pfile - Display the size and date of a file
*
* Purpose:
*
*   This is used to generate a list of files.  It displays one
*   line of list output.
*
* Input:
*   p -  File to list
*
* Output:
*
*   Returns Size of the file, or 0L if it does not exist.
*
*************************************************************************/

long pfile(p)
char *p;
{
    struct _stat sbuf;

    if (_stat(p, &sbuf)) {
        printf("%s %s\n", p, error());
        return 0L;
    }
    else {
        char *t = ctime(&sbuf.st_mtime);
        // This NULLs the \n in string returned by ctime()
        *(t+24) = '\0';
        printf("%8ld %s", sbuf.st_size, t);
        return sbuf.st_size;
    }
}


/*** getRecord - Get one file's worth of into from the index file
*
* Purpose:
*
*   A proper DELETED directory has a file called 'index' that holds a
*   list of the files that the directory contains.  This is necessary
*   because the files are named DELETED.XXX.  This function reads the
*   next file record from 'index'.
*
* Input:
*   fh - Handle of index file.
*   i  - Number of record to _read from index file
*   p  - Target buffer to place record.
*
* Output:
*
*   Returns TRUE if record _read, FALSE otherwise.
*
* Notes:
*
*   Assumes NEW format.
*
*************************************************************************/

flagType getRecord(fh, i, p)
int fh, i;
char *p;
{
    /* UNDONE: Can read the index file to a table of longs and use
     * UNDONE: this. Current stuff is to make it work [SB]
     */

    /* Seek to the beginning of the index file, past the header */
    if (_lseek(fh, (long) RM_RECLEN, SEEK_SET) == -1) {
        return FALSE;
    }
    /* Read (i - 1) records */
    if (i < 0)
        return TRUE;
    for (; i ; i--)
        if (!readNewIdxRec(fh, p, MAX_PATH))
            return FALSE;
    /* Read in the ith record, which is the one we need */
    return( (flagType)readNewIdxRec(fh, p, MAX_PATH) );
}


/*** undel - Do all the work for one file.
*
* Purpose:
*
*   Undeletes one file.
*
* Input:
*   p - Name of file
*
* Output: None
*
*************************************************************************/

void undel(p)
char *p;
{
    int fhidx,                                /* Index file handle */
        iEntry,                               /* Entry no in index file */
        iDelCount,                            /* No of times RMed */
        iDelIndex,                            /* deleted.xxx index value */
        i, j;
    char *buf, *idx;
    char *szLongName;
    char rec[RM_RECLEN];
    char *dbuf;

    buf = malloc(MAX_PATH);
    idx = malloc(MAX_PATH);
    dbuf = malloc(MAX_PATH);
    szLongName = malloc(MAX_PATH);

    pname(p);
    fileext(p, buf);
    upd(p, RM_DIR, idx);
    strcpy(szLongName, idx);
    strcat(idx, "\\");
    strcat(idx, RM_IDX);

    if ((fhidx = _open(idx, O_RDWR | O_BINARY)) == -1)
        printf("not deleted\n");
    else {
        convertIdxFile(fhidx, szLongName);
        /* scan and count number of instances deleted */
        iEntry = -1;
        iDelCount = 0;
        while (getRecord(fhidx, ++iEntry, szLongName))
            if (!_strcmpi(szLongName, buf)) {
                /* Save found entry */
                i = iEntry;
                iDelCount++;
                iDelIndex = (_lseek(fhidx, 0L, SEEK_CUR)
                             - strlen(szLongName)) / RM_RECLEN;
            }
        /* none found */
        if (iDelCount == 0)
            printf("not deleted\n");
        else {
            if (iDelCount == 1)
                iEntry = i;
            /* More than one deleted */
            else {
                printf("%s  More than one are deleted:\n\n", szLongName);
                i = iDelIndex = 0;
                iEntry = -1;
                printf("No     Size Timestamp\n\n");
                while (getRecord(fhidx, ++iEntry, szLongName))
                    if (!_strcmpi(szLongName, buf)) {
                        iDelIndex = (_lseek(fhidx, 0L, SEEK_CUR)
                                    - strlen(szLongName)) / RM_RECLEN;
                        sprintf(dbuf, "deleted.%03x", iDelIndex);
                        upd(idx, dbuf, dbuf);
                        printf("%2d ", ++i);
                        pfile(dbuf);
                        printf("\n");
                }
                while (TRUE) {
                    printf("\nEnter number to undelete(1-%d): ", iDelCount);
                    fgetl(szLongName, 80, stdin);
                    i = atoi(szLongName)-1;
                    if (i >= 0 && i < iDelCount)
                        break;
                }
                iEntry = -1;
                j = 0;
                while (getRecord(fhidx, ++iEntry, szLongName))
                    if (!_strcmpi(szLongName, buf))
                        if (j++ == i)
                            break;
                iDelIndex = (_lseek(fhidx, 0L, SEEK_CUR)
                             - strlen(szLongName)) / RM_RECLEN;
            }
            /* At this stage relevant entry is (iEntry)
             * and this corresponds to ('deleted.%03x', iDelIndex)
             */
            getRecord(fhidx, iEntry, szLongName);
            _close(fhidx);
            fdelete(p);
            printf("%s\t", szLongName);
            fflush(stdout);
            sprintf(dbuf, "deleted.%03x", iDelIndex);
            upd(idx, dbuf, dbuf);

            if (rename(dbuf, p))
                printf(" rename failed - %s\n", error());
            else {
                printf("[OK]\n");
                if ((fhidx = _open(idx, O_RDWR | O_BINARY)) != -1) {
                    long lOffPrev,        /* Offset of Previous Entry */
                         lOff;            /* Offset of current entry  */

                    getRecord(fhidx, iEntry, szLongName);
                    lOff = _lseek(fhidx, 0L, SEEK_CUR);
                    getRecord(fhidx, iEntry - 1, szLongName);
                    lOffPrev = _lseek(fhidx, 0L, SEEK_CUR);
                    for (;lOffPrev != lOff; lOffPrev += RM_RECLEN) {
                        memset((char far *)rec, 0, RM_RECLEN);
                        writeIdxRec(fhidx, rec);
                    }
                }
            }
        }
        _close(fhidx);
    }
}


/*** dump - display info about DELETED directory
*
* Purpose:
*
*   Displays info contained in INDEX file
*
* Input: None
*
* Output: None
*
*************************************************************************/

void dump()
{
    int fhidx, i;
    char *buf = (*tools_alloc)(MAX_PATH);
    char *idx = (*tools_alloc)(MAX_PATH);
    char *szName = (*tools_alloc)(MAX_PATH);
    DWORD cSecsPerClus, cBytesPerSec, cFreeClus, cTotalClus;
    int totfiles;
    long totbytes, totalloc, bPerA, l;

    sprintf(idx, "%s\\%s", RM_DIR, RM_IDX);
    sprintf (szName, "%s", RM_DIR);

    if( !GetDiskFreeSpace( NULL, &cSecsPerClus, &cBytesPerSec, &cFreeClus, &cTotalClus ) ) {
        printf(" file system query failed - %s\n", error());
    }
    bPerA = cBytesPerSec * cSecsPerClus;

    if ((fhidx = _open(idx, O_RDWR | O_BINARY)) != -1) {
        convertIdxFile(fhidx, szName);
        totalloc = totbytes = 0L;
        totfiles = 0;
        i = 0;
        while (getRecord(fhidx, i++, buf))
            if (*buf) {
                if (i == 1)
                    printf("The following have been deleted:\n\n    Size Timestamp\t\t   Filename\n\n");
#ifdef BEAUTIFY
                    //Or optionally
                    printf("    size wdy mmm dd hh:mm:ss yyyy  filename\n\n");
#endif
                strcpy(szName, buf);
                sprintf(buf, "deleted.%03x", (_lseek(fhidx, 0L, SEEK_CUR)
                        - strlen(buf)) / RM_RECLEN);
                upd(idx, buf, buf);
                totbytes += (l = pfile(buf));
                printf("  %s\n", szName);
                l = l + bPerA - 1;
                l = l / bPerA;
                l = l * bPerA;
                totalloc += l;
                totfiles++;
            }
        _close(fhidx);
        printf("\n%ld(%ld) bytes in %d deleted files\n", totalloc, totbytes, totfiles);
    }
    // Maybe the file is readonly
    else if (errno == EACCES) {
        if ((fhidx = _open(idx, O_RDONLY | O_BINARY)) != -1) {
            // Cannot convert Index file for this case
            totalloc = totbytes = 0L;
            totfiles = 0;
            i = 0;
            while (getRecord(fhidx, i++, buf))
                if (*buf) {
                    if (i == 1)
                        printf("The following have been deleted:\n\n    Size Timestamp\t\t   Filename\n\n");
#ifdef BEAUTIFY
                        //Or optionally
                        printf("    size wdy mmm dd hh:mm:ss yyyy  filename\n\n");
#endif
                    strcpy(szName, buf);
                    sprintf(buf, "deleted.%03x", (_lseek(fhidx, 0L, SEEK_CUR)
                        - strlen(buf)) / RM_RECLEN);
                    upd(idx, buf, buf);
                    totbytes += (l = pfile(buf));
                    printf("  %s\n", szName);
                    l = l + bPerA - 1;
                    l = l / bPerA;
                    l = l * bPerA;
                    totalloc += l;
                    totfiles++;
                }
            _close(fhidx);
            printf("\n%ld(%ld) bytes in %d deleted files\n", totalloc, totbytes, totfiles);
        }
    }
    free(buf);
    free(idx);
    free(szName);
}


/*** Usage - standard usage function; help user
*
* Purpose:
*
*   The usual.
*
*************************************************************************/

void Usage()
{
    printf(
"Microsoft File Undelete Utility.  Version %s\n"
"Copyright (C) Microsoft Corp %s. All rights reserved.\n\n"
"Usage: UNDEL [/help] [files]\n",
    VERSION(rmj, rmm, rup), CopyRightYrs);

    exit(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\delay\makefile.inc ===
$(O)\genstubs.log : apithnk.lst makefile.inc
    perl -n -e "s/\;.%//g;s/, */\,/g;print $_;" < apithnk.lst > $(O)\apithnk.lst
    genstubs.cmd $(O)\apithnk.lst $(O)

$(O)\godot_stubs.lib : $(O)\genstubs.log
    @type <<$(ECHO_RSP)
$(C_COMPILER) $(O)\thunk_*.c
<<NOKEEP
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$(O)/" $(USE_FC) $(USECXX_FLAG) @$(O)\cl_filenames.txt
$(EX_C_COMPILER_FLAGS)
<<NOKEEP
    link -lib -out:$@ $(O)\thunk_*.obj $(O)\alias_*.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\delay\thunk_stub.c ===
#define MERGE2(x,y,z) x##_##y##_##z
#define MERGE(x,y,z) MERGE2(x,y,z)

#define FAILMERGE2(x,y) x##y
#define FAILMERGE(x,y) FAILMERGE2(x,y)

#define MAKESTRING2(x,y) #x#y
#define MAKESTRING(x,y) MAKESTRING2(x,y)

#define MAKESTRING2x(x) #x
#define MAKESTRINGx(x) MAKESTRING2x(x)

#define DLLNAME_STR MAKESTRING(_DLLNAME_,_DLLEXT_)
#define APINAME_STR MAKESTRINGx(_APINAME_)

#define THUNKPTR MERGE(_DLLNAME_, _APINAME_, Ptr)
#define THUNKNAME MERGE(_DLLNAME_, _APINAME_, Thunk)

#define FAILPTR FAILMERGE(GodotFail, _APINAME_)

#define DIRECTAPI FAILMERGE(DirectCall_, _APINAME_)

void __stdcall ResolveThunk(char *, 
                            char *, 
                            void (__stdcall **)(void), 
                            void (__stdcall *)(void), 
                            void (__stdcall *)(void));

#define API_OVERRIDE FAILMERGE(Unicows_, _APINAME_)

void (__stdcall *API_OVERRIDE)(void);

void (__stdcall *THUNKPTR)(void);

__declspec(naked)
void
__stdcall
THUNKNAME (void)
{
    ResolveThunk(DLLNAME_STR, 
                 APINAME_STR, 
                 &THUNKPTR, 
                 (void (__stdcall *)(void))API_OVERRIDE, 
                 (void (__stdcall *)(void))FAILPTR);
    
    __asm jmp THUNKPTR;
}

__declspec(naked)
void
__stdcall
DIRECTAPI (void)
{
    __asm jmp THUNKPTR;
}

#pragma data_seg(MAKESTRINGx(MERGE(.data$,_DLLNAME_,_APINAME_)))
void (__stdcall *THUNKPTR)(void) = THUNKNAME;
#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\delay\resolve.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

//
// constants for the registry 
const char c_szReg[] = "SOFTWARE\\Microsoft\\Windows\\CurrentVersion";
const char c_szVal[] = "CommonFilesDir";
const char c_szPath[] = "\\Microsoft Shared\\MSLU\\";


//
// For our static list of DLLs we use
struct DLLMap
{
    const char *szDLLName;
    HMODULE hMod;
};

// Godot must be first in this list. The
// rest can be in any order you like.
struct DLLMap m_rgDLLMap [] = 
{
    {"unicows.dll", NULL }, 
    {"kernel32.dll", NULL },
    {"user32.dll", NULL },
    {"gdi32.dll", NULL },
    {"advapi32.dll", NULL },    // Must be kept in positon #4
    {"shell32.dll", NULL },
    {"comdlg32.dll", NULL },
    {"version.dll", NULL },
    {"mpr.dll", NULL },
    {"rasapi32.dll", NULL },
    {"winmm.dll", NULL },
    {"winspool.drv", NULL },
    {"avicap32.dll", NULL },
    {"secur32.dll", NULL },
    {"oleacc.dll", NULL },
    {"oledlg.dll", NULL }, 
    {"sensapi.dll", NULL },
    {"msvfw32.dll", NULL },
    {NULL, NULL }
};

//
// An ENUM of possible platforms
typedef enum
{
    PlatformUntested,     // Value at initialization
    PlatformUnicode,      // Unicode (Windows NT 4.0, Windows 2000, Windows XP)
    PlatformNotUnicode    // Non-Unicode (Windows 95, Windows 98, Windows ME)
} GODOTUNICODE;

// helper defines 
#define OUR_MAX_DRIVE  3   /* max. length of drive component */
#define OUR_MAX_DIR    256 /* max. length of path component */

// Get proc address forward declares
FARPROC GetProcAddressInternal(HINSTANCE, PCHAR);
PVOID ImageEntryToDataC(PVOID Base, USHORT DirectoryEntry, PULONG Size);
USHORT GetOrdinal(PSZ Name, ULONG cNames, PVOID DllBase, PULONG NameTable, PUSHORT NameOrdinalTable);

// other forward declares
HMODULE LoadGodot(void);
void driveandpathC(register const char *path, char *drive, char *dir);
BOOL strcmpiC(LPSTR sz1, LPSTR sz2);
char * strncpyC(char * dest, const char * source, size_t count);

// Our global pfn that caller can set to 
// get a callback for the loading of Godot
HMODULE (__stdcall *_PfnLoadUnicows)(void);

#pragma intrinsic(strcmp, strlen, strcat)

/*-------------------------------
    ResolveThunk

    The master loader function, used for all APIs on all platforms.
-------------------------------*/
void ResolveThunk(char *Name, char *Function, FARPROC *Ptr, FARPROC Override, FARPROC FailPtr)
{
    static GODOTUNICODE UniPlatform = PlatformUntested;
    static HINSTANCE m_hinst = 0;
    FARPROC fp = NULL;
    HMODULE hMod;
    
    if (PlatformUntested == UniPlatform)
    {
        // We do not know if we are Unicode yet; lets find out since
        // this is pretty crucial in determining where we call from

        // Use GetVersion instead of GetVersionEx; its faster and it
        // tells us the only thing we care about here: Are we on NT?
        DWORD dwVersion = GetVersion();

        if (dwVersion < 0x80000000)
            UniPlatform = PlatformUnicode;  // WinNT/Win2K/WinXP/...
        else
            UniPlatform = PlatformNotUnicode;   // Win95/Win98/WinME

    }

    if (UniPlatform == PlatformUnicode)
    {
        int iMod;

        if(m_hinst == 0)
        {
            // Init our HINST var. Since we do not know the name of the binary 
            // we are in we cannot use LoadLibrary(binaryname) and since we 
            // may not be an EXE we cannot use GetModuleHandle(NULL), either. 
            // Our method may seem like a hack, but it is the method that the 
            // Shell uses to do the same thing (per RaymondC).
            // NOTE: Only needed for the NT case
            MEMORY_BASIC_INFORMATION mbi;

            VirtualQuery(&ResolveThunk, &mbi, sizeof mbi);
            m_hinst = (HINSTANCE)mbi.AllocationBase;
        }


        // Skip the first item in the array, which is the Godot dll.
        for(iMod=1 ; m_rgDLLMap[iMod].szDLLName != NULL ; iMod++)
        {
            if(strcmp(Name, m_rgDLLMap[iMod].szDLLName) == 0)
            {
                // This is the dll: see if we have loaded it yet
                if(m_rgDLLMap[iMod].hMod == 0)
                {
                    // go ahead and load it
                    hMod = LoadLibraryA(Name);
                    if(InterlockedExchange((LPLONG)&m_rgDLLMap[iMod].hMod, (LONG)hMod) != 0)
                    {
                        // Some other thread beat us to it, lets unload our instance
                        FreeLibrary(hMod);
                    }
                }
                fp = GetProcAddressInternal(m_rgDLLMap[iMod].hMod, Function);
                break;
            }
        }
        
        // Should be impossible to get here, since we control dll names, etc.
        
    }
    else // (UniPlatform == PlatformNotUnicode)
    {
        // Check to see if they are overriding this function. 
        // If they are, use the override and we will go no further.
        if(Override)
        {
            fp = Override;
        }
        else
        {
            if(m_rgDLLMap[0].hMod == 0)
            {
                if(hMod = LoadGodot())
                {
                    if(InterlockedExchange((LPLONG)&m_rgDLLMap[0].hMod, (LONG)hMod) != 0)
                    {
                        // Some other thread beat us to it, lets unload our instance
                        FreeLibrary(hMod);
                    }
                }
            }
    
            if(m_rgDLLMap[0].hMod)
            {
                fp = GetProcAddressInternal(m_rgDLLMap[0].hMod, Function);
            }
        }
    }

    if (fp)
    {
        InterlockedExchangePointer(&(*Ptr), fp);
    }
    else
    {
        InterlockedExchangePointer(&(*Ptr), FailPtr);
    }

    // Flush cached information for the code we just modified (NT only). Note that
    // we call FlushInstructionCache on Win9x too, but only with a NULL hinst (to 
    // force the i-cache to be flushed).
    FlushInstructionCache(m_hinst, Ptr, sizeof(FARPROC));
    
    return;
}

typedef LONG (_stdcall *PFNrokea) (HKEY, LPCSTR, DWORD, REGSAM, PHKEY);
typedef LONG (_stdcall *PFNrqvea) (HKEY, LPCSTR, LPDWORD, LPDWORD, LPBYTE, LPDWORD);

/*-------------------------------
    LoadGodot

    This function will never be called on NT, and will be called
    only once on Win9x if Godot can be found. If it cannot, we will
    call it every time, but what is the point of optimizing when
    every string API is going to fail? That would be like holding
    their hand when they walked the Green Mile!
-------------------------------*/
HMODULE LoadGodot(void)
{
    HMODULE hMod = 0;

    if(_PfnLoadUnicows)
        hMod = (_PfnLoadUnicows());

    if(hMod==0)
    {
        hMod = LoadLibraryA(m_rgDLLMap[0].szDLLName);

        if(hMod)
        {
            // We want to disallow the ability to run Godot from the windows or
            // windows/system directory. The reason for this is that we want to
            // avoid a little private version of DLL Hell by having people stick
            // the DLL in such a shared location. 

            // Note that if Godot itself is in the win or winsys dir with the 
            // component, we do not fail validation; if we did, then no downlevel 
            // system component could ever use Godot!
            char szGodotPath[MAX_PATH + 1];
            char szProcessPath[MAX_PATH + 1];
            char szWindowsPath[MAX_PATH + 1];
            char szSystemPath[MAX_PATH + 1];
            char drive[OUR_MAX_DRIVE];
            char dir[OUR_MAX_DIR];

            if(0 == GetSystemDirectory(szSystemPath, MAX_PATH))
                szSystemPath[0] = 0;
            if(0 == GetWindowsDirectory(szWindowsPath, MAX_PATH))
                szWindowsPath[0] = 0;
            if(0 == GetModuleFileName(hMod, szGodotPath, MAX_PATH))
                szGodotPath[0] = 0;
            if(0 == GetModuleFileName(GetModuleHandle(NULL), szProcessPath, MAX_PATH))
                szProcessPath[0] = 0;

            driveandpathC(szProcessPath, drive, dir);
            szProcessPath[strlen(drive) + strlen(dir) + 1] = 0;
            driveandpathC(szGodotPath, drive, dir);
            szGodotPath[strlen(drive) + strlen(dir) + 1] = 0;

            if(((strcmpiC(szWindowsPath, szGodotPath) == 0) && 
               (strcmpiC(szWindowsPath, szProcessPath) != 0)) ||
               ((strcmpiC(szSystemPath, szGodotPath) == 0) &&
               (strcmpiC(szSystemPath, szProcessPath) != 0)))
            {
                // We failed validation on the library we loaded.
                // Lets pretend we never loaded anything at all.
                FreeLibrary(hMod);
                hMod = 0;
            }
        }
                
        if(!hMod)
        {
            // Our straight attempt at load failed, so now we
            // fall back and try to load via the shared location:
            //
            // $(PROGRAM FILES)\$(COMMON FILES)\Microsoft Shared\MSLU
            HKEY hkey = NULL;
            HMODULE hModAdvapi = LoadLibraryA("advapi32.dll");

            // We delay load registry functions to keep from adding 
            // an advapi32 dependency in case the user has none.
            PFNrokea pfnROKE;
            PFNrqvea pfnRQVE;

            if(InterlockedExchange((LPLONG)&m_rgDLLMap[4].hMod, (LONG)hModAdvapi) != 0)
            {
                // Some other thread beat us to it, lets unload our instance
                FreeLibrary(hModAdvapi);
                hModAdvapi = 0;
            }

            if(m_rgDLLMap[4].hMod)
            {
                pfnROKE = (PFNrokea)GetProcAddressInternal(m_rgDLLMap[4].hMod, "RegOpenKeyExA");
                pfnRQVE = (PFNrqvea)GetProcAddressInternal(m_rgDLLMap[4].hMod, "RegQueryValueExA");

                if(pfnROKE && pfnRQVE)
                {
                    if (ERROR_SUCCESS == pfnROKE(HKEY_LOCAL_MACHINE, c_szReg, 0, KEY_QUERY_VALUE, &hkey))
                    {
                        char szName[MAX_PATH + 1];
                        DWORD cb = MAX_PATH;

                        szName[0] = '\0';
                        if (ERROR_SUCCESS == pfnRQVE(hkey, c_szVal, NULL, NULL, (LPBYTE)szName, &cb)) 
                        {
                            // Call to get common files dir succeeded, lets build the path now
                            strcat(szName, c_szPath);
                            strcat(szName, m_rgDLLMap[0].szDLLName);
                            hMod = LoadLibraryA(szName);
                        }
                        RegCloseKey(hkey);
                    }
                }
            }
        }
    }

    return(hMod);
}

//
//
// Our own little GetProcAddress, taken from the actual NT 
// code base via the industrious coding skills of BryanT.
//
//

/*-------------------------------
    GetProcAddressInternal
-------------------------------*/
FARPROC GetProcAddressInternal(HINSTANCE hDll, PCHAR szName)
{
    PIMAGE_EXPORT_DIRECTORY pED;
    ULONG Size;
    PULONG NameTable, AddressTable;
    PUSHORT NameOrdinalTable;
    ULONG Ordinal, Address;

    if (!hDll || !szName) 
    {
        // Bogus args
        return NULL;
    }

    pED = (PIMAGE_EXPORT_DIRECTORY)ImageEntryToDataC(hDll, IMAGE_DIRECTORY_ENTRY_EXPORT, &Size);
    if (!pED) 
    {
        // No exports - very strange
        return NULL;
    }

    NameTable = (PULONG)((ULONG_PTR)hDll + (ULONG)pED->AddressOfNames);
    NameOrdinalTable = (PUSHORT)((ULONG_PTR)hDll + (ULONG)pED->AddressOfNameOrdinals);
    Ordinal = GetOrdinal(szName, pED->NumberOfNames, hDll, NameTable, NameOrdinalTable);
    
    if ((ULONG)Ordinal >= pED->NumberOfFunctions)
    {
        // No matches
        return NULL;
    }

    AddressTable = (PULONG)((ULONG_PTR)hDll + (ULONG)pED->AddressOfFunctions);
    Address = (ULONG_PTR)hDll + AddressTable[Ordinal];
    
    if ((Address > (ULONG_PTR)pED) && (Address < ((ULONG_PTR)pED + Size))) 
    {
        // This is a forwarder - Ignore for now.
        return NULL;
    }
    
    return (FARPROC)Address;
}

/*-------------------------------
    GetOrdinal
-------------------------------*/
USHORT GetOrdinal(PSZ Name, ULONG cNames, PVOID DllBase, PULONG NameTable, PUSHORT NameOrdinalTable)
{
    LONG High, Low, Middle, Result;

    // Lookup the import name in the name table using a binary search.
    Low = 0;
    High = cNames - 1;
    while (High >= Low) 
    {
        // Compute the next probe index and compare the import name
        // with the export name entry.
        Middle = (Low + High) >> 1;
        Result = strcmp(Name, (PCHAR)((ULONG_PTR)DllBase + NameTable[Middle]));

        if (Result < 0)
        {
            High = Middle - 1;
        }
        else if (Result > 0)
        {
            Low = Middle + 1;
        }
        else
        {
            break;
        }
    }

    // If the high index is less than the low index, then a matching
    // table entry was not found. Otherwise, get the ordinal number
    // from the ordinal table.
    if (High < Low)
        return((USHORT)-1);
    else
        return(NameOrdinalTable[Middle]);
}


/*-------------------------------
    ImageEntryToDataC
-------------------------------*/
PVOID ImageEntryToDataC(PVOID Base, USHORT Entry, PULONG Size)
{
    PIMAGE_NT_HEADERS NtHeader;
    ULONG Address;

    // Note that orindarily the line below would be a call
    // to RtlpImageNtHeader. In this case, however, we do 
    // not need to be quite so generic since we control the
    // image.
    NtHeader = (PIMAGE_NT_HEADERS)((PCHAR)Base + ((PIMAGE_DOS_HEADER)Base)->e_lfanew);
    if ((!NtHeader) ||
        (Entry >= NtHeader->OptionalHeader.NumberOfRvaAndSizes) ||
        (!(Address = NtHeader->OptionalHeader.DataDirectory[ Entry ].VirtualAddress)))
    {
        *Size = 0;
        return NULL;
    }

    *Size = NtHeader->OptionalHeader.DataDirectory[ Entry ].Size;

    return((PVOID)((ULONG_PTR)Base + Address));
}

//
//
// Our helper functions that we use to keep from having a C runtime dependency
// Note that such a dependency in unicows.lib could be a nightmare for users!
//
//

/*-------------------------------
    strcmpiC
-------------------------------*/
BOOL strcmpiC(LPSTR sz1, LPSTR sz2)
{
    return(CSTR_EQUAL == CompareStringA(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), 
                                        NORM_IGNORECASE, 
                                        sz1, 
                                        -1, 
                                        sz2, 
                                        -1));
}

/*-------------------------------
    driveandpathC

    Mostly stolen from the VC runtime's splitpath functions, though
    trimmed since we only care about the drive and the dir.
-------------------------------*/
void driveandpathC(register const char *path, char *drive, char *dir)
{
    register char *p;
    char *last_slash = '\0';
    char *dot = '\0';
    unsigned len;

    if ((strlen(path) >= (OUR_MAX_DRIVE - 2)) && (*(path + OUR_MAX_DRIVE - 2) == ':')) {
        if (drive)
        {
            strncpyC(drive, path, OUR_MAX_DRIVE - 1);
            *(drive + OUR_MAX_DRIVE-1) = '\0';
        }
        path += OUR_MAX_DRIVE - 1;
    }
    else if (drive) {
        *drive = '\0';
    }

    for (last_slash = '\0', p = (char *)path; *p; p++) 
    {
        if (*p == '/' || *p == '\\')
            last_slash = p + 1;
        else if (*p == '.')
            dot = p;
    }

    if (last_slash)
    {
        if (dir)
        {
            len = ((char *)last_slash - (char *)path) / sizeof(char);
            if ((OUR_MAX_DIR - 1) < len)
                len = (OUR_MAX_DIR - 1);
            strncpyC(dir, path, len);
            *(dir + len) = '\0';
        }
        path = last_slash;
    }
    else if (dir) {
        *dir = '\0';
    }

}

/*-------------------------------
    strncpyC

    Our little version of strncpy
-------------------------------*/
char * strncpyC(char * dest, const char * source, size_t count)
{
    char *start = dest;

    while (count && (*dest++ = *source++))    /* copy string */
        count--;

    if (count)                              /* pad out with zeroes */
        while (--count)
            *dest++ = '\0';

    return(start);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\godot\crtwrap.h ===
/*++

Copyright (c) 2000-2001,  Microsoft Corporation  All rights reserved.

Module Name:

    crtwrap.h

Abstract:
    Header file for crtwrap.c


Revision History:

    01 Mar 2000    v-michka    Created.

--*/

#ifndef CRTCOPY_H
#define CRTCOPY_H

// Forward declares
size_t __cdecl gwcslen (const wchar_t * wcs);
wchar_t * __cdecl gwcscat(wchar_t * dst, const wchar_t * src);
char * __cdecl gstrncpy(char * dest, const char * source, size_t count);
wchar_t * __cdecl gwcscpy(wchar_t * dst, const wchar_t * src);
wchar_t * __cdecl gwcsncpy(wchar_t * dest, const wchar_t * source, size_t count);
int __cdecl gwcscmp(const wchar_t * src, const wchar_t * dst);
int __cdecl gwcsncmp(const wchar_t * first, const wchar_t * last, size_t count);
wchar_t * __cdecl gwcsstr(const wchar_t * wcs1, const wchar_t * wcs2);
void __cdecl gsplitpath(register const char *path, char *drive, char *dir, char *fname, char *ext);
void __cdecl gwsplitpath(register const WCHAR *path, WCHAR *drive, WCHAR *dir, WCHAR *fname, WCHAR *ext);
int gresetstkoflw(void);
#endif // CRTCOPY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\godot\convert.h ===
/*++

Copyright (c) 2000-2001,  Microsoft Corporation  All rights reserved.

Module Name:

    convert.h

Abstract:

    Header over convert.c

    This seems like an appropriate place to explain Godot's stack strategy. Basically,
    every time we do an allocation on the stack when _GODOTSAFESTACK is defined (which
    is currently always), we do not want to take size and perf hit of over 500 SEH blocks
    and we also do not have the time to try to special case each API to try to find out
    parameter sizes or do stack probes. 

    At the same time, we cannot be crazy go lucky like VSANSI and simply allow the _alloca
    call to throw an EXCEPTION_STACK_OVERFLOW, since it is unrealistic to expect callers to
    wrap every API call in SEH blocks (just as it is for us!). Even if it were realistic,
    we cannot afford to punish users who do not writ bulletproof code. Failure is okay, but
    crashes are not.

    Therefore, in order to satify both our size/perf requirement and our safety requirement,
    we preface every call to _alloca with a call to our StackAllocCheck function. This function
    will attempt to call _alloca in a try...except block and will properly fix up the stack
    on failure. This keeps us from bloating up with hundreds of SEH blocks yet still allows
    us to have a bit more safety.

    Note that this is NOT a 100% solution, since it is vaguely possible that a multithreaded
    application has a (slim) chance of succeeding the StackAllockCheck function but then
    failing before the official (unguarded) call to _alloca due to another thread's call to 
    _alloca, initiated by the user's code (it would never be one of our calls since all of
    *ours* use this safe method). There is no real defense against this, but it is a very
    unlikely type of problem.

Revision History:

    17 Mar 2001    v-michka    Created.
    15 Apr 2001    v-michka    Put in lots of fun heap/stack stuff

--*/

#ifndef CONVERT_H
#define CONVERT_H

#define _GODOTSAFESTACK

// Is this non null and not a user atom?
#define FSTRING_VALID(x) ((ULONG_PTR)(x) > 0xffff)

// Our function for making sure stack allocations are valid
BOOL StackAllocCheck(size_t size);

// _alloca, on certain platforms, returns a raw pointer to the
// stack rather than NULL on allocations of size zero. Since this
// is sub-optimal for code that subsequently calls functions like
// strlen on the allocated block of memory, these wrappers are
// provided for use.

///////////////////////////////////////////////////////////////////////////
//
//  _STACKALLOC
//      Do an allocation from the stack. Must be a macro for obvious reasons!
//
//
#define _STACKALLOC_SAFE(siz, mem) \
        if(StackAllocCheck(siz)) \
            mem = (void *)((siz)?(_alloca(siz)):NULL); \
        else \
            mem = NULL;

#define _STACKALLOC_UNSAFE(siz, mem) \
        mem = ((siz)?(_alloca(siz)):NULL)

#ifdef _GODOTSAFESTACK
#define _STACKALLOC(siz, mem) _STACKALLOC_SAFE(siz, mem)
#else
#define _STACKALLOC(siz, mem) _STACKALLOC_UNSAFE(siz, mem)
#endif

///////////////////////////////////////////////////////////////////////////
//
//  GODOT_TO_ACP_STACKALLOC
//      Convert from Unicode to ANSI if needed, otherwise copy as if it were an Atom
//
// 
#define GODOT_TO_ACP_STACKALLOC_SAFE(src, dst) \
        if (FSTRING_VALID((LPWSTR)src)) \
        { \
            size_t cch = gwcslen((LPWSTR)(src)) + 1; \
            _STACKALLOC_SAFE(cch*g_mcs, (LPSTR)dst); \
            if(dst) \
                WideCharToMultiByte(g_acp, 0, (LPWSTR)(src), cch, (LPSTR)(dst), cch*g_mcs, NULL, NULL); \
            else \
                (LPSTR)(dst) = (LPSTR)(src); \
        } \
        else \
            (LPSTR)(dst) = (LPSTR)(src)

#define GODOT_TO_ACP_STACKALLOC_UNSAFE(src, dst) \
        if (FSTRING_VALID((LPWSTR)src)) \
        { \
            size_t cch = gwcslen((LPWSTR)(src)) + 1; \
            _STACKALLOC_UNSAFE(cch*g_mcs, (LPSTR)dst); \
            if(dst) \
                WideCharToMultiByte(g_acp, 0, (LPWSTR)(src), cch, (LPSTR)(dst), cch*g_mcs, NULL, NULL); \
            else \
                (LPSTR)(dst) = (LPSTR)(src); \
        } \
        else \
            (LPSTR)(dst) = (LPSTR)(src)

#ifdef _GODOTSAFESTACK
#define GODOT_TO_ACP_STACKALLOC(src, dst) GODOT_TO_ACP_STACKALLOC_SAFE(src, dst)
#else
#define GODOT_TO_ACP_STACKALLOC(src, dst) GODOT_TO_ACP_STACKALLOC_UNSAFE(src, dst)
#endif

///////////////////////////////////////////////////////////////////////////
//
//  GODOT_TO_CPG_STACKALLOC
//      Convert from Unicode to ANSI if needed, otherwise copy as if it were an Atom
//
// 
#define GODOT_TO_CPG_STACKALLOC_SAFE(src, dst, cpg, mcs) \
        if (FSTRING_VALID(src)) \
        { \
            size_t cch = gwcslen((LPWSTR)(src)) + 1; \
            _STACKALLOC_SAFE(cch*mcs, (LPSTR)dst); \
            if(dst) \
                WideCharToMultiByte(cpg, 0, (LPWSTR)(src), cch, (LPSTR)(dst), cch*mcs, NULL, NULL); \
            else \
                (LPSTR)(dst) = (LPSTR)(src); \
        } \
        else \
            (LPSTR)(dst) = (LPSTR)(src)

#define GODOT_TO_CPG_STACKALLOC_UNSAFE(src, dst, cpg, mcs) \
        if (FSTRING_VALID(src)) \
        { \
            size_t cch = gwcslen((LPWSTR)(src)) + 1; \
            _STACKALLOC_UNSAFE(cch*mcs, (LPSTR)dst); \
            if(dst) \
                WideCharToMultiByte(cpg, 0, (LPWSTR)(src), cch, (LPSTR)(dst), cch*mcs, NULL, NULL); \
            else \
                (LPSTR)(dst) = (LPSTR)(src); \
        } \
        else \
            (LPSTR)(dst) = (LPSTR)(src)

#ifdef _GODOTSAFESTACK
#define GODOT_TO_CPG_STACKALLOC(src, dst, cpg, mcs) GODOT_TO_CPG_STACKALLOC_SAFE(src, dst, cpg, mcs)
#else
#define GODOT_TO_CPG_STACKALLOC(src, dst, cpg, mcs) GODOT_TO_CPG_STACKALLOC_UNSAFE(src, dst, cpg, mcs)
#endif

///////////////////////////////////////////////////////////////////////////
//
// Various enums, macros and functions for heap allocation stuff
//
//

typedef enum
{
    arBadParam  = 1,
    arFailed    = 2,
    arAlloc     = 3,
    arNoAlloc   = 4
} ALLOCRETURN;


///////////////////////////////////////////////////////////////////////////
//
// Our generic heap wrappers
//
//
#define GodotHeapAlloc(mem) ((mem) ? (HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, mem)) : NULL)
#define GodotHeapFree(mem) ((mem) ? (HeapFree(GetProcessHeap(), 0, mem)) : FALSE)
#define GodotHeapReAlloc(old, mem) ((mem) ? (HeapReAlloc(GetProcessHeap(), 0, old, mem)) : NULL)

///////////////////////////////////////////////////////////////////////////
//
// wrappers/foward declares around our heap alloc/conversion 
// functions to handle common cases
//
//
#define GodotToAcpOnHeap(lpwz, lpsz) GodotToCpgCchOnHeap(lpwz, -1, lpsz, g_acp, g_mcs)
#define GodotToCpgOnHeap(lpwz, lpsz, cpg, mcs) GodotToCpgCchOnHeap(lpwz, -1, lpsz, cpg, mcs)
#define GodotToUnicodeOnHeap(lpsz, lpwz) GodotToUnicodeCpgCchOnHeap(lpsz, -1, lpwz, g_acp)
#define GodotToUnicodeCpgOnHeap(lpsz, lpwz, cpg, mcs) GodotToUnicodeCpgCchOnHeap(lpwz, -1, lpsz, cpg)
ALLOCRETURN GodotToCpgCchOnHeap(LPCWSTR lpwz, int cchMax, LPSTR * lpsz, UINT cpg, UINT mcs);
ALLOCRETURN GodotToUnicodeCpgCchOnHeap(LPCSTR lpsz, int cchMax, LPWSTR * lpwz, UINT cpg);


///////////////////////////////////////////////////////////////////////////
//
// Additional Forward declares
//
//
void DevModeAfromW(LPDEVMODEA lpdma, LPDEVMODEW lpdmw);
void DevModeWfromA(LPDEVMODEW lpdmw, LPDEVMODEA lpdma);
HGLOBAL HDevModeAfromW(HGLOBAL * lphdmw, BOOL fFree);
HGLOBAL HDevModeWfromA(HGLOBAL * lphdma, BOOL fFree);
HGLOBAL HDevNamesAfromW(HGLOBAL * lphdnw, BOOL fFree);
HGLOBAL HDevNamesWfromA(HGLOBAL * lphdna, BOOL fFree);
void LogFontAfromW(LPLOGFONTA lplfa, LPLOGFONTW lplfw);
void LogFontWfromA(LPLOGFONTW lplfw, LPLOGFONTA lplfa);
void Win32FindDataWfromA(PWIN32_FIND_DATAW w32fdw, PWIN32_FIND_DATAA w32fda);
void TextMetricWfromA(LPTEXTMETRICW lptmw, LPTEXTMETRICA lptma);
void NewTextMetricWfromA(LPNEWTEXTMETRICW lpntmw, LPNEWTEXTMETRICA lpntma);
void NewTextMetricExWfromA(NEWTEXTMETRICEXW * lpntmew, NEWTEXTMETRICEXA * lpntmea);
BOOL MenuItemInfoAfromW(LPMENUITEMINFOA lpmiia, LPCMENUITEMINFOW lpmiiw);
int GrszToGrwz(const CHAR* szFrom, WCHAR* wzTo, int cchTo);
int SzToWzCch(const CHAR *sz, WCHAR *wz, int cch);

#endif // CONVERT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\godot\convert.c ===
/*++

Copyright (c) 2000-2001,  Microsoft Corporation  All rights reserved.

Module Name:

    convert.c

Abstract:

    These functions make A->W and W->A translations of all types 
    easier. 

        StackAllocCheck
        DevModeAfromW
        DevModeWfromA
        LogFontAfromW
        Win32FindDataWfromA
        TextMetricWfromA
        NewTextMetricWfromA
        NewTextMetricExWfromA
        MenuItemInfoAfromW
        CpgFromLocale
        CbPerChOfCpg
        GrszToGrwz
        GrwzToGrsz
        SzToWzCch

Revision History:

    17 Mar 2001    v-michka    Created.

--*/

#include "precomp.h"

/*-------------------------------
    StackAllocCheck

    Verify there is room on the stack for the allocation
-------------------------------*/
BOOL StackAllocCheck(size_t size)
{
    BOOL RetVal;
    PVOID mem;

    __try 
    {
        mem = (void *)((size)?(_alloca(size)):NULL);
        RetVal = TRUE;
    }
    __except (GetExceptionCode() == EXCEPTION_STACK_OVERFLOW ? EXCEPTION_EXECUTE_HANDLER :
                                                               EXCEPTION_CONTINUE_SEARCH )
    {
        gresetstkoflw();
        mem = NULL;
        SetLastError(ERROR_STACK_OVERFLOW);
        RetVal = FALSE;
    }

    return(RetVal);
}

/*-------------------------------
    GodotToCpgCchOnHeap

    Converts the given string to Ansi.
-------------------------------*/
ALLOCRETURN GodotToCpgCchOnHeap(LPCWSTR lpwz, int cchMax, LPSTR * lpsz, UINT cpg, UINT mcs)
{
    // Parameter check
    if(!lpsz)
        return(arBadParam);
    
    if(FSTRING_VALID(lpwz))
    {
        int cch = gwcslen(lpwz);

        if(cchMax !=-1 && cchMax < cch)
            cch = cchMax;

        *lpsz = GodotHeapAlloc((cch+1)*mcs);
        if(! *lpsz)
        {
            SetLastError(ERROR_OUTOFMEMORY);
            return(arFailed);
        }

        WideCharToMultiByte(cpg, 0, lpwz, cch, *lpsz, cch*mcs, NULL, NULL);
        return(arAlloc);
    }
    else
    {
        // Copy the NULL or the ATOM. No alloc needed
        *lpsz = (LPSTR)lpwz;
        return(arNoAlloc);
    }
}

/*-------------------------------
    GodotToUnicodeCpgCchOnHeap

    Converts the given string to Unicode. 
-------------------------------*/
ALLOCRETURN GodotToUnicodeCpgCchOnHeap(LPCSTR lpsz, int cchMax, LPWSTR * lpwz, UINT cpg)
{
    // Parameter check
    if(!lpwz)
        return(arBadParam);
    
    if(FSTRING_VALID(lpsz))
    {
        int cch = lstrlenA(lpsz);

        if(cchMax !=-1 && cchMax < cch)
            cch = cchMax;

        *lpwz = GodotHeapAlloc((cch + 1)*sizeof(WCHAR));
        if(! *lpwz)
        {
            SetLastError(ERROR_OUTOFMEMORY);
            return(arFailed);
        }

        MultiByteToWideChar(cpg, 0, lpsz, cch, *lpwz, cch*sizeof(WCHAR));
        return(arAlloc);
    }
    else
    {
        // Copy the NULL or the ATOM. No alloc needed
        *lpwz = (LPWSTR)lpsz;
        return(arNoAlloc);
    }
}

/*-------------------------------
    DevModeAfromW

    The name says it all. Assumes that it is being passed already alloc'ed parameters
-------------------------------*/
void DevModeAfromW(LPDEVMODEA lpdma, LPDEVMODEW lpdmw)
{
    WideCharToMultiByte(g_acp, 0, 
                        (LPWSTR)(lpdmw->dmDeviceName), CCHDEVICENAME, 
                        (LPSTR)(lpdma->dmDeviceName), CCHDEVICENAME*g_mcs, 
                        NULL, NULL);
    memcpy(&lpdma->dmSpecVersion, 
           &lpdmw->dmSpecVersion,
           (4*sizeof(WORD) + sizeof(DWORD) + (13*sizeof(short))));
    WideCharToMultiByte(g_acp, 0, 
                        (LPWSTR)(lpdmw->dmFormName), CCHFORMNAME, 
                        (LPSTR)(lpdma->dmFormName), CCHFORMNAME*g_mcs, 
                        NULL, NULL);
    memcpy(&lpdma->dmLogPixels, &lpdmw->dmLogPixels, (sizeof(WORD) + (11*sizeof(DWORD))));
    lpdma->dmSize = CDSIZEOF_STRUCT(DEVMODEA, dmReserved2);

    // Make sure we copy the extra driver bytes.
    if (lpdmw->dmDriverExtra)
        memcpy((char*)lpdma + lpdma->dmSize, (char*)lpdmw + lpdmw->dmSize, lpdmw->dmDriverExtra);
    return;
}

/*-------------------------------
    DevModeWfromA

    The name says it all. Assumes that it is being passed already alloc'ed parameters
-------------------------------*/
void DevModeWfromA(LPDEVMODEW lpdmw, LPDEVMODEA lpdma)
{
    MultiByteToWideChar(g_acp, 0, 
                        (LPSTR)(lpdma->dmDeviceName), CCHDEVICENAME, 
                        (LPWSTR)(lpdmw->dmDeviceName), CCHDEVICENAME);
    memcpy(&lpdmw->dmSpecVersion, 
           &lpdma->dmSpecVersion,
           4*sizeof(WORD) + sizeof(DWORD) + (13*sizeof(short)));
    MultiByteToWideChar(g_acp, 0, 
                        (LPSTR)(lpdma->dmFormName), CCHFORMNAME, 
                        (LPWSTR)(lpdmw->dmFormName), CCHFORMNAME);
    memcpy(&lpdmw->dmLogPixels, &lpdma->dmLogPixels, sizeof(WORD) + (11*sizeof(DWORD)));
    lpdmw->dmSize = CDSIZEOF_STRUCT(DEVMODEW, dmReserved2);

    // Make sure we copy the extra driver bytes.
    if (lpdma->dmDriverExtra)
        memcpy((char*)lpdmw + lpdmw->dmSize, (char*)lpdma + lpdma->dmSize, lpdma->dmDriverExtra);
    return;
}

/*-------------------------------
    HDevModeAfromW

    Wrapper around DevModeAfromW that does the right thing with global 
    memory. Does not require that hdmw be set (but will not touch hdma
    unless it is).
-------------------------------*/
HGLOBAL HDevModeAfromW(HGLOBAL * lphdmw, BOOL fFree)
{
    HGLOBAL hdma = NULL;
    
    if(lphdmw && *lphdmw)
    {
        LPDEVMODEW lpdmw = (LPDEVMODEW)GlobalLock(*lphdmw);
        if(lpdmw)
        {
            if(hdma = GlobalAlloc(GHND, sizeof(DEVMODEA) + lpdmw->dmDriverExtra))
            {
                LPDEVMODEA lpdma = (LPDEVMODEA)GlobalLock(hdma);
                if(lpdma)
                {
                    DevModeAfromW(lpdma, lpdmw);
                    GlobalUnlock(hdma);
                }
                else
                    GlobalFree(hdma);
            }
            GlobalUnlock(*lphdmw);
            if(fFree)
            {
                GlobalFree(*lphdmw);
                *lphdmw = NULL;
            }
        }
    }
    return(hdma);
}

/*-------------------------------
    HDevModeWfromA

    Wrapper around DevModeWfromA that does the right thing with global 
    memory. Does not require that hdma be set (but will not touch hdma
    unless it is).
-------------------------------*/
HGLOBAL HDevModeWfromA(HGLOBAL * lphdma, BOOL fFree)
{
    HGLOBAL hdmw = NULL;
    
    if(lphdma && *lphdma)
    {
        LPDEVMODEA lpdma = (LPDEVMODEA)GlobalLock(*lphdma);
        if(lpdma)
        {
            if(hdmw = GlobalAlloc(GHND, sizeof(DEVMODEW) + lpdma->dmDriverExtra))
            {
                LPDEVMODEW lpdmw = (LPDEVMODEW)GlobalLock(hdmw);
                if(lpdmw)
                {
                    DevModeWfromA(lpdmw, lpdma);
                    GlobalUnlock(hdmw);
                }
                else
                    GlobalFree(hdmw);
            }
            GlobalUnlock(*lphdma);
            if(fFree)
            {
                GlobalFree(*lphdma);
                *lphdma = NULL;
            }
        }
    }
    return(hdmw);
}

/*-------------------------------
    HDevNamesAfromW

    The name says it all. Does not require hdnw to be set (but will not
    touch hdma unless it is).
-------------------------------*/
HGLOBAL HDevNamesAfromW(HGLOBAL * lphdnw, BOOL fFree)
{
    HGLOBAL hdna = NULL;
    
    if(lphdnw && *lphdnw)
    {
        LPDEVNAMES lpdnw = (LPDEVNAMES)GlobalLock(*lphdnw);
        if(lpdnw)
        {
            int cchDriver = gwcslen((LPCWSTR)lpdnw + lpdnw->wDriverOffset) + 1;
            int cchDevice = gwcslen((LPCWSTR)lpdnw + lpdnw->wDeviceOffset) + 1;
            int cchOutput = gwcslen((LPCWSTR)lpdnw + lpdnw->wOutputOffset) + 1;
            if(hdna = GlobalAlloc(GHND, sizeof(DEVNAMES) + 
                                   (g_mcs * (cchDriver + cchDevice + cchOutput))))
            {
                LPDEVNAMES lpdna = (LPDEVNAMES)GlobalLock(hdna);
                if(!lpdna)
                    GlobalFree(hdna);
                else
                {
                    lpdna->wDriverOffset = sizeof(DEVNAMES);
                    lpdna->wDeviceOffset = lpdna->wDriverOffset + cchDriver;
                    lpdna->wOutputOffset = lpdna->wDeviceOffset + cchDevice;
                    lpdna->wDefault = lpdna->wDefault;

                    WideCharToMultiByte(g_acp, 0, 
                                        (LPWSTR)lpdnw + lpdnw->wDriverOffset, cchDriver*g_mcs, 
                                        (LPSTR)lpdna + lpdna->wDriverOffset, cchDriver, 
                                        NULL, NULL);
                    WideCharToMultiByte(g_acp, 0, 
                                        (LPWSTR)lpdnw + lpdnw->wDeviceOffset, cchDevice*g_mcs, 
                                        (LPSTR)lpdna + lpdna->wDeviceOffset, cchDevice, 
                                        NULL, NULL);
                    WideCharToMultiByte(g_acp, 0, 
                                        (LPWSTR)lpdnw + lpdnw->wOutputOffset, cchOutput*g_mcs, 
                                        (LPSTR)lpdna + lpdna->wOutputOffset, cchOutput, 
                                        NULL, NULL);
                    GlobalUnlock(hdna);
                }
            }
            GlobalUnlock(*lphdnw);
            if(fFree)
            {
                GlobalFree(*lphdnw);
                *lphdnw = NULL;
            }
        }
    }
    return(hdna);
}

/*-------------------------------
    HDevNamesWfromA

    The name says it all. Does not require hdna to be set (but does
    not touch hdnw unless it is).
-------------------------------*/
HGLOBAL HDevNamesWfromA(HGLOBAL * lphdna, BOOL fFree)
{
    HGLOBAL hdnw = NULL; 
    
    if(lphdna && *lphdna)
    {
        LPDEVNAMES lpdna = (LPDEVNAMES)GlobalLock(*lphdna);
        if(lpdna)
        {
            int cchDriver = lstrlenA((LPCSTR)lpdna + lpdna->wDriverOffset) + 1;
            int cchDevice = lstrlenA((LPCSTR)lpdna + lpdna->wDeviceOffset) + 1;
            int cchOutput = lstrlenA((LPCSTR)lpdna + lpdna->wOutputOffset) + 1;
            if(hdnw = GlobalAlloc(GHND, sizeof(DEVNAMES) + 
                                  (sizeof(WCHAR) * (cchDriver + cchDevice + cchOutput))))
            {
                LPDEVNAMES lpdnw = (LPDEVNAMES)GlobalLock(hdnw);
                if(!lpdnw)
                    GlobalFree(hdnw);
                else
                {
                    lpdnw->wDriverOffset = sizeof(DEVNAMES) / sizeof(WCHAR);
                    lpdnw->wDeviceOffset = lpdnw->wDriverOffset + cchDriver;
                    lpdnw->wOutputOffset = lpdnw->wDeviceOffset + cchDevice;
                    lpdnw->wDefault = lpdna->wDefault;

                    MultiByteToWideChar(g_acp, 0, 
                                        (LPSTR)lpdna + lpdna->wDriverOffset, cchDriver, 
                                        (LPWSTR)lpdnw + lpdnw->wDriverOffset, cchDriver);
                    MultiByteToWideChar(g_acp, 0, 
                                        (LPSTR)lpdna + lpdna->wDeviceOffset, cchDevice, 
                                        (LPWSTR)lpdnw + lpdnw->wDeviceOffset, cchDevice);
                    MultiByteToWideChar(g_acp, 0, 
                                        (LPSTR)lpdna + lpdna->wOutputOffset, cchOutput, 
                                        (LPWSTR)lpdnw + lpdnw->wOutputOffset, cchOutput);
                    GlobalUnlock(hdnw);
                }
            }
            GlobalUnlock(*lphdna);
            if(fFree)
            {
                GlobalFree(*lphdna);
                *lphdna = NULL;
            }
        }
    }
    return(hdnw);
}

/*-------------------------------
    LogFontAfromW

    The name says it all. Assumes that it is being passed already alloc'ed parameters
-------------------------------*/
void LogFontAfromW(LPLOGFONTA lplfa, LPLOGFONTW lplfw)
{
    memcpy(lplfa, lplfw, (5*sizeof(LONG)+8*sizeof(BYTE)));
    WideCharToMultiByte(g_acp, 0, 
                        lplfw->lfFaceName, LF_FACESIZE, 
                        lplfa->lfFaceName, LF_FACESIZE, 
                        NULL, NULL);
    return;
}

/*-------------------------------
    LogFontWfromA

    The name says it all. Assumes that it is being passed already alloc'ed parameters
-------------------------------*/
void LogFontWfromA(LPLOGFONTW lplfw, LPLOGFONTA lplfa)
{
    memcpy(lplfw, lplfa, (5*sizeof(LONG)+8*sizeof(BYTE)));
    MultiByteToWideChar(g_acp, 0, lplfa->lfFaceName, LF_FACESIZE, lplfw->lfFaceName, LF_FACESIZE);
    return;
}

/*-------------------------------
    Win32FindDataWfromA

    The name says it all. Assumes that it is being passed already alloc'ed parameters
-------------------------------*/
void Win32FindDataWfromA(PWIN32_FIND_DATAW w32fdw, PWIN32_FIND_DATAA w32fda)
{
    UINT cpg = FILES_CPG;

    memcpy(w32fdw, w32fda, (3*sizeof(FILETIME)+5*sizeof(DWORD)));
    MultiByteToWideChar(cpg, 0, w32fda->cFileName, MAX_PATH, w32fdw->cFileName, MAX_PATH);
    MultiByteToWideChar(cpg, 0, w32fda->cAlternateFileName, 14, w32fdw->cAlternateFileName, 14);
    return;
}

/*-------------------------------
    TextMetricWfromA

    The name says it all. Assumes that it is being passed already alloc'ed parameters
-------------------------------*/
void TextMetricWfromA(LPTEXTMETRICW lptmw, LPTEXTMETRICA lptma)
{
    memcpy(lptmw, lptma, (11*sizeof(LONG)));
    MultiByteToWideChar(g_acp, 0, &lptma->tmFirstChar, sizeof(char), &lptmw->tmFirstChar, sizeof(WCHAR));
    MultiByteToWideChar(g_acp, 0, &lptma->tmLastChar, sizeof(char), &lptmw->tmLastChar, sizeof(WCHAR));
    MultiByteToWideChar(g_acp, 0, &lptma->tmDefaultChar, sizeof(char), &lptmw->tmDefaultChar, sizeof(WCHAR));
    MultiByteToWideChar(g_acp, 0, &lptma->tmBreakChar, sizeof(char), &lptmw->tmBreakChar, sizeof(WCHAR));
    memcpy(&lptmw->tmItalic, &lptma->tmItalic, 5*sizeof(BYTE));
    return;
}

/*-------------------------------
    NewTextMetricWfromA

    The name says it all. Assumes that it is being passed already alloc'ed parameters
-------------------------------*/
void NewTextMetricWfromA(LPNEWTEXTMETRICW lpntmw, LPNEWTEXTMETRICA lpntma)
{
    TextMetricWfromA((LPTEXTMETRICW)lpntmw, (LPTEXTMETRICA)lpntma);
    memcpy(&lpntmw->ntmFlags, &lpntma->ntmFlags, (sizeof(DWORD) + 3*sizeof(UINT)));
    return;
}

/*-------------------------------
    NewTextMetricExWfromA

    The name says it all. Assumes that it is being passed already alloc'ed parameters
-------------------------------*/
void NewTextMetricExWfromA(NEWTEXTMETRICEXW * lpntmew, NEWTEXTMETRICEXA * lpntmea)
{
    TextMetricWfromA((LPTEXTMETRICW)lpntmew, (LPTEXTMETRICA)lpntmea);
    memcpy(&lpntmew->ntmTm.ntmFlags, &lpntmea->ntmTm.ntmFlags, (sizeof(DWORD) + 3*sizeof(UINT)));
    memcpy(&lpntmew->ntmFontSig, &lpntmea->ntmFontSig, sizeof(FONTSIGNATURE));
    return;
}

/*-------------------------------
    MenuItemInfoAfromW

    The name says it all. Assumes that it is being passed already alloc'ed parameters
    If the return value is TRUE, then the dwTypeData is a heap pointer to free.
-------------------------------*/
BOOL MenuItemInfoAfromW(LPMENUITEMINFOA lpmiia, LPCMENUITEMINFOW lpmiiw)
{
    DWORD RetVal = FALSE;
    
    ZeroMemory(lpmiia, sizeof(MENUITEMINFOA));
    lpmiia->cbSize = sizeof(MENUITEMINFOA);
    lpmiia->fMask           = lpmiiw->fMask;
    lpmiia->fType           = lpmiiw->fType;
    lpmiia->fState          = lpmiiw->fState;
    lpmiia->wID             = lpmiiw->wID; 
    lpmiia->hSubMenu        = lpmiiw->hSubMenu;
    lpmiia->hbmpChecked     = lpmiiw->hbmpChecked;
    lpmiia->hbmpUnchecked   = lpmiiw->hbmpUnchecked;
    lpmiia->dwItemData      = lpmiiw->dwItemData; 
    lpmiia->hbmpItem        = lpmiiw->hbmpItem;

    // Ok, now lets take care of the "strings", though we
    // do need to find out if they are in fact strings, first!
    if(((FWIN95()) && 
          ((lpmiiw->fMask & MIIM_TYPE) && (lpmiiw->fType == MFT_STRING))) ||
      ((!FWIN95() && 
            ((lpmiiw->fMask & MIIM_STRING) || 
            ((lpmiiw->fMask & MIIM_FTYPE) && (lpmiiw->fType == MFT_STRING))))))
    {
        if (FSTRING_VALID(lpmiiw->dwTypeData))
        {
            // Ok, it looks like a string and they say its a string, so lets
            // treat it like one. Be sure not to copy more than cch.
            size_t cch = gwcslen(lpmiiw->dwTypeData)+1;

            if (cch > lpmiiw->cch)
                cch = lpmiiw->cch;
            if(arAlloc == GodotToCpgCchOnHeap(lpmiiw->dwTypeData, 
                                              cch, 
                                              &(LPSTR)(lpmiia->dwTypeData), 
                                              g_acp, 
                                              g_mcs))
            {
                RetVal = TRUE;
            }

            // Set the final length explicitly; don't set by the buffer,
            // which may be more than we actually needed on MBCS
            lpmiia->cch = lstrlenA( lpmiia->dwTypeData);
        }
        else
        {
            // Think its a string per flags but does not look like a string,
            // so copy like an atom but set cch just in case!
            lpmiia->dwTypeData = (LPSTR)lpmiiw->dwTypeData;
            lpmiia->cch = sizeof(lpmiia->dwTypeData);
        }
    }
    else
    {
        // This ain't a string, darn it! cch is 0 and that's that! Its gonna be
        // ignored anyway.
        lpmiia->dwTypeData = (LPSTR)lpmiiw->dwTypeData;
        lpmiia->cch = 0;
    }
    return(RetVal);
}

/*------------------------------------------------------------------------
    GrszToGrwz (stolen from Office!)

    Converts a group of ANSI strings into a group of Unicode strings.
    Each string in the group is terminated by a null.  Returns
    resulting length of the Unicode string stored in wzTo as a cb

    If return value is greater than cchTo, wzTo is not written to.
-------------------------------------------------------------- MIKEKELL -*/
int GrszToGrwz(const CHAR* szFrom, WCHAR* wzTo, int cchTo)
{
    int cchRet = 0;
    const char *szFromSav = szFrom;

    do
        {
        int cch = strlen(szFrom)+1;
        cchRet += MultiByteToWideChar(g_acp, 0, szFrom, cch, NULL, 0);
        szFrom += cch;
        }
    while (*szFrom);

    cchRet++;
    szFrom = szFromSav;

    if (wzTo && (cchRet <= cchTo))
        {
        do
            {
            int cchConv;
            int cch = strlen(szFrom)+1;
            cchConv = MultiByteToWideChar(g_acp, 0, szFrom, cch, wzTo, cchTo);
            szFrom += cch;
            wzTo += cchConv;
            cchTo -= cchConv;
            }
        while (*szFrom);
        *wzTo = 0;        // add extra null terminator.
        };

    return cchRet;
}

/*-------------------------------
    SzToWzCch

        Returns the unicode length of the string (including the
        null terminator).  If this length is <= cch, then it also
        converts the string storing it into wz (otherwise, wz is unchanged)
-------------------------------*/
int SzToWzCch(const CHAR *sz, WCHAR *wz, int cch)
{
    int cchNeed;

    cchNeed = MultiByteToWideChar(g_acp, 0, sz, -1, NULL, 0);
    
    if (cchNeed <= cch)
        {
        MultiByteToWideChar(g_acp, 0, sz, -1, wz, cch);
        };
    return cchNeed;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\godot\crtwrap.c ===
/*++

Copyright (c) 2000-2001,  Microsoft Corporation  All rights reserved.

Module Name:

    crtwrap.c

Abstract:
    This module is our own implementation of various CRT functions, to
    try to minimze the code size that would come from static linking 
    to the CRT (which we do not do, currently!).

Revision History:

    01 Mar 2000    v-michka    Created.

--*/

#include "precomp.h"

#define _GMAX_PATH      144      /* max. length of full pathname */
#define _GMAX_DRIVE   3      /* max. length of drive component */
#define _GMAX_DIR       130      /* max. length of path component */
#define _GMAX_FNAME   9      /* max. length of file name component */
#define _GMAX_EXT     5      /* max. length of extension component */

// A safer version of wcslen, which will actually 
// crash if you pass it a null pointer
size_t __cdecl gwcslen(const wchar_t * wcs)
{
    if(!FSTRING_VALID(wcs))
        return(0);
    else
    {
        const wchar_t *eos = wcs;
        while( *eos++ ) ;
        return( (size_t)(eos - wcs - 1) );
    }
}

wchar_t * __cdecl gwcscat(wchar_t * dst, const wchar_t * src)
{
    wchar_t * cp = dst;
    while( *cp )
        cp++;                   /* find end of dst */
    while( *cp++ = *src++ ) ;       /* Copy src to end of dst */
    return( dst );                  /* return dst */
}

char * __cdecl gstrncpy(char * dest, const char * source, size_t count)
{
    char *start = dest;

    while (count && (*dest++ = *source++))    /* copy string */
        count--;

    if (count)                              /* pad out with zeroes */
        while (--count)
            *dest++ = '\0';

    return(start);
}

wchar_t * __cdecl gwcscpy(wchar_t * dst, const wchar_t * src)
{
    wchar_t * cp = dst;
    while( *cp++ = *src++ )
        ;  /* Copy src over dst */
    return( dst );
}

wchar_t * __cdecl gwcsncpy(wchar_t * dest, const wchar_t * source, size_t count)
{
    wchar_t *start = dest;

    while (count && (*dest++ = *source++))    /* copy string */
        count--;

    if (count)                              /* pad out with zeroes */
        while (--count)
            *dest++ = L'\0';

    return(start);
}

int __cdecl gwcscmp(const wchar_t * src, const wchar_t * dst)
{
    int ret = 0 ;
    while( ! (ret = (int)(*src - *dst)) && *dst)
        ++src, ++dst;
    if ( ret < 0 )
        ret = -1 ;
    else if ( ret > 0 )
        ret = 1 ;
    return( ret );
}

int __cdecl gwcsncmp(const wchar_t * first, const wchar_t * last, size_t count)
{
    if (!count)
        return(0);

    while (--count && *first && *first == *last)
    {
        first++;
        last++;
    }

    return((int)(*first - *last));
}

wchar_t * __cdecl gwcsstr(const wchar_t * wcs1, const wchar_t * wcs2)
{
    wchar_t *cp = (wchar_t *) wcs1;
    wchar_t *s1, *s2;

    while (*cp)
    {
        s1 = cp;
        s2 = (wchar_t *) wcs2;

        while ( *s1 && *s2 && !(*s1-*s2) )
            s1++, s2++;

        if (!*s2)
            return(cp);

        cp++;
    }

    return(NULL);
}

#pragma intrinsic (strlen)

void __cdecl gsplitpath(register const char *path, char *drive, char *dir, char *fname, char *ext)
{
    register char *p;
    char *last_slash = NULL, *dot = NULL;
    unsigned len;

    if ((strlen(path) >= (_GMAX_DRIVE - 2)) && (*(path + _GMAX_DRIVE - 2) == ':')) {
        if (drive) {
            gstrncpy(drive, path, _GMAX_DRIVE - 1);
            *(drive + _GMAX_DRIVE-1) = '\0';
        }
        path += _GMAX_DRIVE - 1;
    }
    else if (drive) {
        *drive = '\0';
    }

    for (last_slash = NULL, p = (char *)path; *p; p++) {
        if (*p == '/' || *p == '\\')
            last_slash = p + 1;
        else if (*p == '.')
            dot = p;
    }

    if (last_slash) {
        if (dir) {
            len = __min(((char *)last_slash - (char *)path) / sizeof(char),
                (_GMAX_DIR - 1));
            gstrncpy(dir, path, len);
            *(dir + len) = '\0';
        }
        path = last_slash;
    }
    else if (dir) {
        *dir = '\0';
    }

    if (dot && (dot >= path)) {
        if (fname) {
            len = __min(((char *)dot - (char *)path) / sizeof(char),
                (_GMAX_FNAME - 1));
            gstrncpy(fname, path, len);
            *(fname + len) = '\0';
        }
        if (ext) {
            len = __min(((char *)p - (char *)dot) / sizeof(char),
                (_GMAX_EXT - 1));
            gstrncpy(ext, dot, len);
            *(ext + len) = '\0';
        }
    }
    else {
        if (fname) {
            len = __min(((char *)p - (char *)path) / sizeof(char),
                (_GMAX_FNAME - 1));
            gstrncpy(fname, path, len);
            *(fname + len) = '\0';
        }
        if (ext) {
            *ext = '\0';
        }
    }
}

void __cdecl gwsplitpath(register const WCHAR *path, WCHAR *drive, WCHAR *dir, WCHAR *fname, WCHAR *ext)
{
    register WCHAR *p;
    WCHAR *last_slash = NULL, *dot = NULL;
    unsigned len;

    if ((gwcslen(path) >= (_GMAX_DRIVE - 2)) && (*(path + _GMAX_DRIVE - 2) == L':')) {
        if (drive) {
            gwcsncpy(drive, path, _GMAX_DRIVE - 1);
            *(drive + _GMAX_DRIVE-1) = L'\0';
        }
        path += _GMAX_DRIVE - 1;
    }
    else if (drive) {
        *drive = L'\0';
    }

    for (last_slash = NULL, p = (WCHAR *)path; *p; p++) {
        if (*p == L'/' || *p == L'\\')
            last_slash = p + 1;
        else if (*p == L'.')
            dot = p;
    }

    if (last_slash) {
        if (dir) {
            len = __min(((char *)last_slash - (char *)path) / sizeof(WCHAR),
                (_GMAX_DIR - 1));
            gwcsncpy(dir, path, len);
            *(dir + len) = L'\0';
        }
        path = last_slash;
    }
    else if (dir) {
        *dir = L'\0';
    }

    if (dot && (dot >= path)) {
        if (fname) {
            len = __min(((char *)dot - (char *)path) / sizeof(WCHAR),
                (_GMAX_FNAME - 1));
            gwcsncpy(fname, path, len);
            *(fname + len) = L'\0';
        }
        if (ext) {
            len = __min(((char *)p - (char *)dot) / sizeof(WCHAR),
                (_GMAX_EXT - 1));
            gwcsncpy(ext, dot, len);
            *(ext + len) = L'\0';
        }
    }
    else {
        if (fname) {
            len = __min(((char *)p - (char *)path) / sizeof(WCHAR),
                (_GMAX_FNAME - 1));
            gwcsncpy(fname, path, len);
            *(fname + len) = L'\0';
        }
        if (ext) {
            *ext = L'\0';
        }
    }
}

#define MIN_STACK_REQ_WIN9X 0x11000
#define MIN_STACK_REQ_WINNT 0x2000

/***
* void gresetstkoflw(void) - Recovers from Stack Overflow
*
* Purpose:
*       Sets the guard page to its position before the stack overflow.
*
*******************************************************************************/
int gresetstkoflw(void)
{
    LPBYTE pStack, pGuard, pStackBase, pMinGuard;
    MEMORY_BASIC_INFORMATION mbi;
    SYSTEM_INFO si;
    DWORD PageSize;
    DWORD flNewProtect;
    DWORD flOldProtect;

    // Use _alloca() to get the current stack pointer

    pStack = _alloca(1);

    // Find the base of the stack.

    if (VirtualQuery(pStack, &mbi, sizeof mbi) == 0)
        return 0;
    pStackBase = mbi.AllocationBase;

    // Find the page just below where the stack pointer currently points.
    // This is the new guard page.

    GetSystemInfo(&si);
    PageSize = si.dwPageSize;

    pGuard = (LPBYTE) (((DWORD_PTR)pStack & ~(DWORD_PTR)(PageSize - 1))
                       - PageSize);

    // If the potential guard page is too close to the start of the stack
    // region, abandon the reset effort for lack of space.  Win9x has a
    // larger reserved stack requirement.
    pMinGuard = pStackBase + (FWIN9X() ? MIN_STACK_REQ_WIN9X : MIN_STACK_REQ_WINNT);

    if (pGuard < pMinGuard)
        return 0;

    if(!FWIN9X())
    {
        // On a non-Win9x system, release the stack region below the new guard
        // page.  This can't be done for Win9x because of OS limitations.
        if (pGuard > pStackBase)
            VirtualFree(pStackBase, pGuard - pStackBase, MEM_DECOMMIT);

        VirtualAlloc(pGuard, PageSize, MEM_COMMIT, PAGE_READWRITE);
    }

    // Enable the new guard page.

    flNewProtect = (FWIN9X() ? PAGE_NOACCESS : PAGE_READWRITE | PAGE_GUARD);
    return VirtualProtect(pGuard, PageSize, flNewProtect, &flOldProtect);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\godot\callback.h ===
/*++

Copyright (c) 2000-2001,  Microsoft Corporation  All rights reserved.

Module Name:

    callback.h

Abstract:

    Header file for callback.c

Revision History:

    7 Nov 2000    v-michka    Created.

--*/

#ifndef CALLBACK_H
#define CALLBACK_H

// forward declares
BOOL CALLBACK EnumCalendarInfoProc(LPSTR lpCalendarInfoString);
BOOL CALLBACK EnumCalendarInfoProcEx(LPSTR lpCalendarInfoString,CALID Calendar);
BOOL CALLBACK EnumCodePagesProc(LPSTR lpCodePageString);
BOOL CALLBACK EnumDateFormatsProc(LPSTR lpDateFormatString);
BOOL CALLBACK EnumDateFormatsProcEx(LPSTR lpDateFormatString,CALID CalendarID);
BOOL CALLBACK EnumLocalesProc(LPSTR lpLocaleString);
BOOL CALLBACK EnumTimeFormatsProc(LPSTR lpTimeFormatString);
BOOL CALLBACK PropEnumProc(HWND hwnd,LPCSTR lpszString,HANDLE hData);
BOOL CALLBACK PropEnumProcA(HWND hwnd,LPCSTR lpszString,HANDLE hData);
BOOL CALLBACK PropEnumProcEx(HWND hwnd,LPSTR lpszString,HANDLE hData,ULONG_PTR dwData);
BOOL CALLBACK PropEnumProcExA(HWND hwnd,LPSTR lpszString,HANDLE hData,ULONG_PTR dwData);
BOOL CALLBACK GrayStringProc(HDC hdc, LPARAM lpData, int cchData);

// forward declares
int CALLBACK EnumFontFamExProc(ENUMLOGFONTEXA *lpelfe,NEWTEXTMETRICEXA *lpntme,DWORD FontType,LPARAM lParam);
int CALLBACK EnumFontFamProc(ENUMLOGFONTA *lpelf,NEWTEXTMETRICA *lpntm,DWORD FontType,LPARAM lParam);
int CALLBACK EnumFontsProc(CONST LOGFONTA *lplf,CONST TEXTMETRICA *lptm,DWORD dwType,LPARAM lpData);
int CALLBACK EnumICMProfilesProcCallback(LPSTR lpszFilename,LPARAM lParam);
#endif // CALLBACK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\godot\globals.h ===
/*++

Copyright (c) 2001,  Microsoft Corporation  All rights reserved.

Module Name:

    globals.h

Abstract:

    Every project needs a globals.h

Revision History:

    7 Feb 2000    v-michka    Created.

--*/

#ifndef GLOBALS_H
#define GLOBALS_H

#include <windows.h>    // We always need a windows.h
#include <winnls.h>     // for GetLocaleInfo
#include <mbstring.h>   // for _mbslen

#define MAX_SMALL_STRING MAX_PATH

// TLS Allocation index storage
typedef struct tagGodotTlsInfo
{
    // Enumeration callback procedures, owned by the user
    CALINFO_ENUMPROCW pfnCalendarInfo;
    CALINFO_ENUMPROCEXW pfnCalendarInfoEx;
    DATEFMT_ENUMPROCW pfnDateFormats;
    DATEFMT_ENUMPROCEXW pfnDateFormatsEx;
    LOCALE_ENUMPROCW pfnLocales;
    TIMEFMT_ENUMPROCW pfnTimeFormats;
    PROPENUMPROCW pfnProp;
    PROPENUMPROCA pfnPropA;
    PROPENUMPROCEXW pfnPropEx;
    PROPENUMPROCEXA pfnPropExA;
    FONTENUMPROCW pfnFontFamilies;
    FONTENUMPROCW pfnFontFamiliesEx;
    FONTENUMPROCW pfnFonts;
    ICMENUMPROCW pfnICMProfiles;

    GRAYSTRINGPROC pfnGrayString;

    UINT cpgGrayString;

    // Pointers to the caller's version of the find/replace dialogs
    LPFINDREPLACEW lpfrwFind;
    LPFINDREPLACEW lpfrwReplace;

    // user hook for find/replace/open/save/page setup dialogs (if they exist)
    // note that the open save hooks are only for the OFN_EXPLORER 
    // type dialogs.
    LPFRHOOKPROC pfnFindText;
    LPFRHOOKPROC pfnReplaceText;
    LPOFNHOOKPROC pfnGetOpenFileName;
    LPOFNHOOKPROC pfnGetSaveFileName;
    LPPAGEPAINTHOOK pfnPagePaint;

    // Common dialog hook procedures that we do not hook to do
    // significant work with
    LPCCHOOKPROC pfnChooseColor;
    LPCFHOOKPROC pfnChooseFont;
    LPOFNHOOKPROC pfnGetOpenFileNameOldStyle;
    LPOFNHOOKPROC pfnGetSaveFileNameOldStyle;
    LPPAGESETUPHOOK pfnPageSetup;
    LPPRINTHOOKPROC pfnPrintDlg;
    LPSETUPHOOKPROC pfnPrintDlgSetup;

    // Our refcount members. Note that since they will be stored
    // on a per-thread basis, there are no synchronization issues
    // with updating them in place.
    // WARNING: Note that there are 16 of these, so we are currently
    // DWORD aligned. If you add or remove any, make sure that you
    // add the appropriate padding.
    unsigned short cCalendarInfo            : 4;
    unsigned short cCalendarInfoEx          : 4;
    unsigned short cDateFormats             : 4;
    unsigned short cDateFormatsEx           : 4;
    unsigned short cLocales                 : 4;
    unsigned short cTimeFormats             : 4;
    unsigned short cProp                    : 4;
    unsigned short cPropA                   : 4;
    unsigned short cPropEx                  : 4;
    unsigned short cPropExA                 : 4;
    unsigned short cFontFamilies            : 4;
    unsigned short cFontFamiliesEx          : 4;
    unsigned short cFonts                   : 4;
    unsigned short cICMProfiles             : 4;

    unsigned short cGrayString              : 4;

    unsigned short RESERVED                 : 4;
    
    // Pointer to our hook procedure handle
    // (see the proc, in hook.c, for more info.
    HHOOK hHook;
    
    // Pointer to dialog proc (one per thread).
    // Our DialogProc will clear it out as soon as
    // the init happens.
    DLGPROC pfnDlgProc;

} GODOTTLSINFO, *LPGODOTTLSINFO;

#define GODOTMAXREFCOUNT 15

// globals: pretty evil, but there are not many of them. :-)
extern UINT g_acp;                     // CP_ACP; it is faster to call with the actual cpg
extern UINT g_oemcp;                   // CP_OEMCP; it is faster to call with the actual cpg
extern UINT g_mcs;                     // The maximum character size (in bytes) of a character on CP_ACP
extern DWORD g_dwVersion;              // The return from GetVersion, used many places
extern UINT g_tls;                     // GODOT TLS slot - lots of thread-specific info here
extern CRITICAL_SECTION g_csThreads;   // Our critical section object for thread data (use sparingly!)
extern CRITICAL_SECTION g_csWnds;      // our critical section object for window data (use sparingly!)


// from windowsx.h
#define GET_WM_COMMAND_ID(wp, lp)               LOWORD(wp)

// culled from msointl.h, could not find them elsewhere
#define CP_JAPAN    932
#define CP_CHINA    936
#define CP_KOREA    949
#define CP_TAIWAN   950
#define CP_JOHAB   1361
#define CP_GB18030 54936

// code page translation flags
#define NLS_CP_CPINFO             0x10000000                    
#define NLS_CP_CPINFOEX           0x20000000                    
#define NLS_CP_MBTOWC             0x40000000                    
#define NLS_CP_WCTOMB             0x80000000                    

typedef enum
{
    // normal message transmitters
    mtSendMessage =             0x00000001,
    mtSendMessageCallback =     0x00000002,
    mtSendMessageTimeout =      0x00000004,
    mtSendNotifyMessage =       0x00000008,
    mtPostMessage =             0x00000010,
    mtPostThreadMessage =       0x00000020,
    mtDefWindowProc =           0x00000040,
    mtDefDlgProc =              0x00000080,
    mtDefFrameProc =            0x00000100,
    mtDefMDIChildProc =         0x00000200,
    mtBroadcastSystemMessage =  0x00000400,
    
    mtCallWindowProc =          0x00000800,
    mtCallWindowProcA =         0x00001000,

    // normal message receivers
    mtGetMessage =              0x00010000,
    mtPeekMessage =             0x00020000,

    // normal message dispatchers
    mtDispatchMessage =         0x00040000,
    mtIsDialogMessage =         0x00080000,
    mtTranslateAccelerator =    0x00100000,

    mtSendMessageAndIlk =       (mtSendMessage | 
                                 mtSendMessageCallback | 
                                 mtSendMessageTimeout | 
                                 mtSendNotifyMessage),

    mtDefWindowProcAndIlk =     (mtDefWindowProc |
                                 mtDefDlgProc |
                                 mtDefFrameProc |
                                 mtDefMDIChildProc)
} MESSAGETYPES;

typedef enum
{
    fptWndproc = 0x01,
    fptDlgproc = 0x02,
    fptUnknown = 0x03
} FAUXPROCTYPE;

UINT msgFINDMSGSTRING;
UINT msgHELPMSGSTRING;
UINT msgFILEOKSTRING;
UINT msgSHAREVISTRING; 

// MACROS to do some kinda handy things

// Many macros moved to convert.h with deal with memory allocation, etc.

// Are we dealing with a DBCS code page?
#define FDBCS_CPG(cpg) \
    (cpg == CP_JAPAN || \
     cpg == CP_KOREA || \
     cpg == CP_TAIWAN || \
     cpg == CP_CHINA || \
     cpg == CP_JOHAB || \
     cpg == CP_GB18030)

// are we on Windows 95?
#define FWIN95() \
    ((FWIN9X() && \
    ((DWORD)(HIBYTE(LOWORD(g_dwVersion))) == 0)))

// Are we on Windows 95 or 98?
#define FWIN95_OR_98() \
    ((FWIN9X() && \
    ((DWORD)(HIBYTE(LOWORD(g_dwVersion))) < 9)))

// Are we on any Win9x platform?
#define FWIN9X() \
    ((g_dwVersion >= 0x80000000) && \
    (((DWORD)(LOBYTE(LOWORD(g_dwVersion))) == 4)))

#ifndef CDSIZEOF_STRUCT
#define CDSIZEOF_STRUCT(structname, member) \ 
    (((int)((LPBYTE)(&((structname*)0)->member) - \
    ((LPBYTE)((structname*)0)))) + sizeof(((structname*)0)->member))
#endif

// Some size "constants" for RAS, based on the size changes in Millenium
#define CBRASENTRYNAMEOLDA CDSIZEOF_STRUCT(RASENTRYNAMEA,szEntryName)
#define CBRASENTRYNAMEOLDW CDSIZEOF_STRUCT(RASENTRYNAMEW,szEntryName)

#define CBRASDIALPARAMSOLDA CDSIZEOF_STRUCT(RASDIALPARAMSA,szDomain)
#define CBRASDIALPARAMSOLDW CDSIZEOF_STRUCT(RASDIALPARAMSW,szDomain)

#define CBRASDIALPARAMSNEWA CDSIZEOF_STRUCT(RASDIALPARAMSA,dwCallbackId)
#define CBRASDIALPARAMSNEWW CDSIZEOF_STRUCT(RASDIALPARAMSA,dwCallbackId)

#define CBRASENTRYOLDA CDSIZEOF_STRUCT(RASENTRYA,dwReserved2)
#define CBRASENTRYOLDW CDSIZEOF_STRUCT(RASENTRYW,dwReserved2)

#define CBRASENTRYNEWA CDSIZEOF_STRUCT(RASENTRYA,dwIdleDisconnectSeconds)
#define CBRASENTRYNEWW CDSIZEOF_STRUCT(RASENTRYW,dwIdleDisconnectSeconds)

#define CBRASCONNOLDA CDSIZEOF_STRUCT(RASCONNA,szDeviceName)
#define CBRASCONNOLDW CDSIZEOF_STRUCT(RASCONNW,szDeviceName)

#define CBRASCONNNEWA CDSIZEOF_STRUCT(RASCONNA,dwSubEntry)
#define CBRASCONNNEWW CDSIZEOF_STRUCT(RASCONNW,dwSubEntry)

#endif // GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\godot\callback.c ===
/*++

Copyright (c) 2000-2001,  Microsoft Corporation  All rights reserved.

Module Name:

    callback.c

Abstract:

    This file contains functions that wrap various enumeratation
    procedures and callback functions

    Functions found in this file:
        EnumCalendarInfoProc
        EnumCalendarInfoProcEx
        EnumDateFormatsProc
        EnumDateFormatsProcEx
        EnumFontFamExProc
        EnumFontFamProc
        EnumICMProfilesProcCallback
        EnumLocalesProc
        EnumTimeFormatsProc
        PropEnumProc
        PropEnumProcEx
        GrayStringProc

Revision History:

    7 Nov 2000    v-michka    Created.

--*/

#include "precomp.h"

/*-------------------------------
    EnumCalendarInfoProc
-------------------------------*/
BOOL CALLBACK EnumCalendarInfoProc(LPSTR lpCalendarInfoString)
{
    BOOL RetVal = FALSE;
    LPGODOTTLSINFO lpgti;
    CALINFO_ENUMPROCW lpfn;
    size_t cb = lstrlenA(lpCalendarInfoString);
    LPWSTR lpsz = GodotHeapAlloc(cb * sizeof(WCHAR));

    if(!lpsz)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }

    lpgti = GetThreadInfoSafe(TRUE);
    
    // No TLS info means no way to know what proc to call
    if(lpgti)
    {
        lpfn = lpgti->pfnCalendarInfo;
        MultiByteToWideChar(g_acp, 0, lpCalendarInfoString, -1, lpsz, cb);
    
        // Chain to the original callback function
        RetVal = (* lpfn)(lpsz);
    }

    // Cleanup and get out
    GodotHeapFree(lpsz);
    return(RetVal);
}

/*-------------------------------
    EnumCalendarInfoProcEx
-------------------------------*/
BOOL CALLBACK EnumCalendarInfoProcEx (LPSTR lpCalendarInfoString, CALID Calendar)
{
    BOOL RetVal = FALSE;
    LPGODOTTLSINFO lpgti;
    CALINFO_ENUMPROCEXW lpfn;
    size_t cb = lstrlenA(lpCalendarInfoString);
    LPWSTR lpsz = GodotHeapAlloc(cb * sizeof(WCHAR));

    if(!lpsz)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }

    lpgti = GetThreadInfoSafe(TRUE);

    // No TLS info means no way to know what proc to call
    if(lpgti)
    {
        lpfn = lpgti->pfnCalendarInfoEx;
        MultiByteToWideChar(g_acp, 0, lpCalendarInfoString, -1, lpsz, cb);
    
        // Chain to the original callback function
        RetVal = (* lpfn)(lpsz, Calendar);
    }

    // Cleanup and get out
    GodotHeapFree(lpsz);
    return(RetVal);
}

/*-------------------------------
    EnumDateFormatsProc
-------------------------------*/
BOOL CALLBACK EnumDateFormatsProc(LPSTR lpDateFormatString)
{
    BOOL RetVal = FALSE;
    LPGODOTTLSINFO lpgti;
    DATEFMT_ENUMPROCW lpfn;
    size_t cb = lstrlenA(lpDateFormatString);
    LPWSTR lpsz = GodotHeapAlloc(cb * sizeof(WCHAR));

    if(!lpsz)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }

    lpgti = GetThreadInfoSafe(TRUE);

    // No TLS info means no way to know what proc to call
    if(lpgti)
    {
        lpfn = lpgti->pfnDateFormats;
        MultiByteToWideChar(g_acp, 0, lpDateFormatString, -1, lpsz, cb);
    
        // Chain to the original callback function
        RetVal = (* lpfn)(lpsz);
    }

    // Cleanup and get out
    GodotHeapFree(lpsz);
    return(RetVal);
}

/*-------------------------------
    EnumDateFormatsProcEx
-------------------------------*/
BOOL CALLBACK EnumDateFormatsProcEx(LPSTR lpDateFormatString, CALID CalendarID)
{
    BOOL RetVal = FALSE;
    LPGODOTTLSINFO lpgti;
    DATEFMT_ENUMPROCEXW lpfn;
    size_t cb = lstrlenA(lpDateFormatString);
    LPWSTR lpsz = GodotHeapAlloc(cb * sizeof(WCHAR));

    if(!lpsz)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }

    lpgti = GetThreadInfoSafe(TRUE);

    // No TLS info means no way to know what proc to call
    if(lpgti)
    {
        lpfn = lpgti->pfnDateFormatsEx;
        MultiByteToWideChar(g_acp, 0, lpDateFormatString, -1, lpsz, cb);
    
        // Chain to the original callback function
        RetVal = (* lpfn)(lpsz, CalendarID);
    }

    // Cleanup and get out
    GodotHeapFree(lpsz);
    return(RetVal);
}

/*-------------------------------
    EnumLocalesProc
-------------------------------*/
BOOL CALLBACK EnumLocalesProc(LPSTR lpLocaleString)
{
    BOOL RetVal = FALSE;
    LPGODOTTLSINFO lpgti;
    LOCALE_ENUMPROCW lpfn;
    size_t cb = lstrlenA(lpLocaleString);
    LPWSTR lpsz = GodotHeapAlloc(cb * sizeof(WCHAR));

    if(!lpsz)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }

    lpgti = GetThreadInfoSafe(TRUE);

    // No TLS info means no way to know what proc to call
    if(lpgti)
    {
        lpfn = lpgti->pfnLocales;
        MultiByteToWideChar(g_acp, 0, lpLocaleString, -1, lpsz, cb);
    
        RetVal = (* lpfn)(lpsz);
    }

    // Cleanup and get out
    GodotHeapFree(lpsz);
    return(RetVal);
}

/*-------------------------------
    EnumTimeFormatsProc
-------------------------------*/
BOOL CALLBACK EnumTimeFormatsProc(LPSTR lpTimeFormatString)
{
    BOOL RetVal = FALSE;
    LPGODOTTLSINFO lpgti;
    TIMEFMT_ENUMPROCW lpfn;
    size_t cb = lstrlenA(lpTimeFormatString);
    LPWSTR lpsz = GodotHeapAlloc(cb * sizeof(WCHAR));

    if(!lpsz)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }

    lpgti = GetThreadInfoSafe(TRUE);

    // No TLS info means no way to know what proc to call
    if(lpgti)
    {
        lpfn = lpgti->pfnTimeFormats;
        MultiByteToWideChar(g_acp, 0, lpTimeFormatString, -1, lpsz, cb);
    
        // Chain to the original callback function
        RetVal = (* lpfn)(lpsz);
    }

    // Cleanup and get out
    GodotHeapFree(lpsz);
    return(RetVal);
}

/*-------------------------------
    PropEnumProcA
-------------------------------*/
BOOL CALLBACK PropEnumProcA(HWND hwnd, LPCSTR lpszString, HANDLE hData)
{
    BOOL RetVal = FALSE;
    LPGODOTTLSINFO lpgti;
    PROPENUMPROCA lpfn;

    if(IsInternalWindowProperty((LPWSTR)lpszString, FALSE))
        return(TRUE);

    // No TLS info means no way to know what proc to call
    if(lpgti = GetThreadInfoSafe(TRUE))
    {
        lpfn = lpgti->pfnPropA;
        RetVal = (* lpfn)(hwnd, lpszString, hData);
    }

    return(RetVal);
}

/*-------------------------------
    PropEnumProc
-------------------------------*/
BOOL CALLBACK PropEnumProc(HWND hwnd, LPCSTR lpszString, HANDLE hData)
{
    BOOL RetVal = FALSE;
    LPGODOTTLSINFO lpgti;
    PROPENUMPROCW lpfn;
    size_t cb;
    LPWSTR lpsz;

    if(IsInternalWindowProperty((LPWSTR)lpszString, FALSE))
        return(TRUE);

    cb = lstrlenA(lpszString);
    lpsz = GodotHeapAlloc(cb * sizeof(WCHAR));
    
    if(!lpsz)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }

    // No TLS info means no way to know what proc to call
    if(lpgti = GetThreadInfoSafe(TRUE))
    {
        lpfn = lpgti->pfnProp;
        MultiByteToWideChar(g_acp, 0, lpszString, -1, lpsz, cb);
    
        RetVal = (* lpfn)(hwnd, lpsz, hData);
    }

    // Cleanup and get out
    GodotHeapFree(lpsz);
    return(RetVal);
}

/*-------------------------------
    PropEnumProcEx
-------------------------------*/
BOOL CALLBACK PropEnumProcExA(HWND hwnd, LPSTR lpszString, HANDLE hData, ULONG_PTR dwData)
{
    // begin locals
    BOOL RetVal = FALSE;
    LPGODOTTLSINFO lpgti;
    PROPENUMPROCEXA lpfn;

    if(IsInternalWindowProperty((LPWSTR)lpszString, FALSE))
        return(TRUE);

    // No TLS info means no way to know what proc to call
    if(lpgti = GetThreadInfoSafe(TRUE))
    {
        lpfn = lpgti->pfnPropExA;

        // Chain to the original callback function
        RetVal = (*lpfn)(hwnd, lpszString, hData, dwData);
    }

    return(RetVal);
}

/*-------------------------------
    PropEnumProcEx
-------------------------------*/
BOOL CALLBACK PropEnumProcEx(HWND hwnd, LPSTR lpszString, HANDLE hData, ULONG_PTR dwData)
{
    // begin locals
    BOOL RetVal = FALSE;
    LPGODOTTLSINFO lpgti;
    PROPENUMPROCEXW lpfn;
    size_t cb;
    LPWSTR lpsz;

    if(IsInternalWindowProperty((LPWSTR)lpszString, FALSE))
        return(TRUE);

    cb = lstrlenA(lpszString);
    lpsz = GodotHeapAlloc(cb * sizeof(WCHAR));

    if(!lpsz)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }

    lpgti = GetThreadInfoSafe(TRUE);

    // No TLS info means no way to know what proc to call
    if(lpgti)
    {
        lpfn = lpgti->pfnPropEx;
        MultiByteToWideChar(g_acp, 0, lpszString, -1, lpsz, (cb * sizeof(WCHAR)));

        // Chain to the original callback function
        RetVal = (*lpfn)(hwnd, lpsz, hData, dwData);
    }

    // Cleanup and get out
    GodotHeapFree(lpsz);
    return(RetVal);
}

/*-------------------------------
    EnumFontFamExProc
-------------------------------*/
int CALLBACK EnumFontFamExProc(ENUMLOGFONTEXA *lpelfe, NEWTEXTMETRICEXA *lpntme, DWORD FontType, LPARAM lParam)
{
    // begin locals
    int RetVal = 0;
    LPGODOTTLSINFO lpgti;
    FONTENUMPROCW lpfnFEP;
    LOGFONTW lfW;

    lpgti = GetThreadInfoSafe(TRUE);

    // No TLS info means no way to know what proc to call
    if(lpgti)
    {
        lpfnFEP = lpgti->pfnFontFamiliesEx;
        LogFontWfromA(&lfW, (LOGFONTA *)lpelfe);

        if (FontType & TRUETYPE_FONTTYPE)
        {
            NEWTEXTMETRICEXW ntmeW;

            NewTextMetricExWfromA(&ntmeW, lpntme);

            // Chain to the original callback function
            RetVal = (*lpfnFEP)(&lfW, (LPTEXTMETRICW)&ntmeW, FontType, lParam);
        }
        else
        {
            TEXTMETRICW tmW;

            TextMetricWfromA(&tmW, (LPTEXTMETRICA)lpntme);

            // Chain to the original callback function
            RetVal = (*lpfnFEP)(&lfW, &tmW, FontType, lParam);
        }
    }

    // Cleanup and get out
    return(RetVal);
}

/*-------------------------------
    EnumFontFamProc
-------------------------------*/
int CALLBACK EnumFontFamProc(ENUMLOGFONTA *lpelf, LPNEWTEXTMETRICA lpntm, DWORD FontType, LPARAM lParam)
{
    // begin locals
    int RetVal = 0;
    LPGODOTTLSINFO lpgti;
    FONTENUMPROCW lpfnFEP;
    LOGFONTW lfW;

    lpgti = GetThreadInfoSafe(TRUE);

    // No TLS info means no way to know what proc to call
    if(lpgti)
    {
        lpfnFEP = lpgti->pfnFontFamilies;
        LogFontWfromA(&lfW, (LOGFONTA *)lpelf);

        if (FontType & TRUETYPE_FONTTYPE)
        {
            NEWTEXTMETRICW ntmW;

            NewTextMetricWfromA(&ntmW, lpntm);

            // Chain to the original callback function
            RetVal = (*lpfnFEP)(&lfW, (LPTEXTMETRICW)&ntmW, FontType, lParam);
        }
        else
        {
            TEXTMETRICW tmW;

            TextMetricWfromA(&tmW, (LPTEXTMETRICA)lpntm);

            // Chain to the original callback function
            RetVal = (*lpfnFEP)(&lfW, &tmW, FontType, lParam);
        }
    }

    return(RetVal);
}

/*-------------------------------
    EnumFontsProc
-------------------------------*/
int CALLBACK EnumFontsProc(CONST LOGFONTA *lplf, CONST TEXTMETRICA *lptm, DWORD dwType, LPARAM lpData)
{
    // begin locals
    int RetVal = 0;
    LPGODOTTLSINFO lpgti;
    FONTENUMPROCW lpfnFEP;
    TEXTMETRICW tmW;
    LOGFONTW lfW;
    
    lpgti = GetThreadInfoSafe(TRUE);

    // No TLS info means no way to know what proc to call
    if(lpgti)
    {
        lpfnFEP = lpgti->pfnFonts;
        LogFontWfromA(&lfW, (LOGFONTA *)lplf);
        TextMetricWfromA(&tmW, (TEXTMETRICA *)lptm);

        // Chain to the original callback function
        RetVal = (*lpfnFEP)(&lfW, &tmW, dwType, lpData);
    }

    return(RetVal);
}

/*-------------------------------
    EnumICMProfilesProcCallback
-------------------------------*/
int CALLBACK EnumICMProfilesProcCallback(LPSTR lpszFilename, LPARAM lParam)
{
    // begin locals
    BOOL RetVal = FALSE;
    LPGODOTTLSINFO lpgti;
    ICMENUMPROCW lpfnIEP;
    size_t cb = lstrlenA(lpszFilename);
    LPWSTR lpsz = GodotHeapAlloc(cb * sizeof(WCHAR));

    if(!lpsz)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return (FALSE);
    }

    lpgti = GetThreadInfoSafe(TRUE);

    // No TLS info means no way to know what proc to call
    if(lpgti)
    {
        lpfnIEP = lpgti->pfnICMProfiles;
        MultiByteToWideChar(g_acp, 0, lpszFilename, -1, lpsz, (cb * sizeof(WCHAR)));

        // Chain to the original callback function
        RetVal = (*lpfnIEP)(lpsz, lParam);
    }

    // Cleanup and get out
    GodotHeapFree(lpsz);
    return(RetVal);
}

/*-------------------------------
    GrayStringProc
-------------------------------*/
BOOL CALLBACK GrayStringProc(HDC hdc, LPARAM lpData, int cchData)
{
    LPGODOTTLSINFO lpgti;
    BOOL RetVal = FALSE;
    GRAYSTRINGPROC lpfn;
    LPWSTR lpsz = GodotHeapAlloc(cchData * sizeof(WCHAR));

    if(!lpsz)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return (FALSE);
    }

    // No TLS info means no way to know what proc to call
    if(lpgti = GetThreadInfoSafe(TRUE))
    {
        lpfn = lpgti->pfnGrayString;
        MultiByteToWideChar(lpgti->cpgGrayString, 0, (LPSTR)lpData, -1, lpsz, (cchData * sizeof(WCHAR)));

        // Chain to the original callback function
        RetVal = (*lpfn)(hdc, (LPARAM)lpsz, gwcslen(lpsz));
    }

    // Cleanup and get out
    GodotHeapFree(lpsz);
    return(RetVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\godot\headers.h ===
#define SECURITY_WIN32
#include <windows.h>
#include <winnls.h>
#include <winbase.h>
#include <ras.h>
#include <sensapi.h>
#include <oledlg.h>
#include <vfw.h>
#include <oleacc.h>
#include <ntsecapi.h>
#include <security.h>

// GenThnk chokes on stuff in shlobj.h, so we copy 
// enough out of it to handle a few shell APIs.
typedef struct _SHITEMID
    {
    USHORT cb;
    BYTE abID[ 1 ];
    }   SHITEMID;
typedef struct _ITEMIDLIST
    {
    SHITEMID mkid;
    }   ITEMIDLIST;
typedef ITEMIDLIST __unaligned *LPITEMIDLIST;
typedef const ITEMIDLIST __unaligned *LPCITEMIDLIST;
typedef int (CALLBACK* BFFCALLBACK)(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData);
typedef struct _browseinfoW {
    HWND        hwndOwner;
    LPCITEMIDLIST pidlRoot;
    LPWSTR       pszDisplayName;        // Return display name of item selected.
    LPCWSTR      lpszTitle;                     // text to go in the banner over the tree.
    UINT         ulFlags;                       // Flags that control the return stuff
    BFFCALLBACK  lpfn;
    LPARAM       lParam;                        // extra info that's passed back in callbacks
    int          iImage;                        // output var: where to return the Image index.
} BROWSEINFOW, *PBROWSEINFOW, *LPBROWSEINFOW;
LPITEMIDLIST __stdcall SHBrowseForFolderW(LPBROWSEINFOW lpbi);
BOOL __stdcall SHGetPathFromIDListW(LPCITEMIDLIST pidl, LPWSTR pszPath);
void __stdcall SHChangeNotify(LONG wEventId, UINT uFlags, LPCVOID dwItem1, LPCVOID dwItem2);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\godot\hook.c ===
/*++

Copyright (c) 2000-2001,  Microsoft Corporation  All rights reserved.

Module Name:

    hook.c

Abstract:

    This file contains functions that wrap various hook procedures, 
    and the helper functions that support their efforts.

    Hooks found in this file:
        WindowProc
        DialogProc
        CBTProc
        EnumChildToTagProc

    comdlg32.dll hooks:
        FRHookProcFind
        FRHookProcReplace
        OFNHookProc
        OFNHookProcSave
        PagePaintHook
        CCHookProc
        CFHookProc
        PageSetupHook
        PrintHookProc
        SetupHookProc
        OFNHookProcOldStyle
        OFNHookProcOldStyleSave

    Helper functions:    
        FRHelper
        UpdateTextAndFlags
        NotifyFindReplaceParent
        OFNHookHelper
        OFNotifyHelper
        GenericHookHelper
        RemoveFontPropIfPresent
        SetNewFileOpenProp
        SetFontProp

    Externally available helper functions:
        IsFontDialog
        IsNewFileOpenDialog
        IsCaptureWindow
        SetCaptureWindowProp

Revision History:

    27 Jan 2001    v-michka    Created.

--*/

#include "precomp.h"

// Stolen from commdlg.h
#define CCHCLOSE    9
#define iszClose    0x040d   // "Close" text for find/replace
static WCHAR m_szClose [CCHCLOSE];

// So we can keep track of font dialogs
const char m_szComdlgClass[] = "GodotComdlgClass";
ATOM m_aComdlgClass;

#define CHOOSEFONT_DIALOG   (HANDLE)1
#define NEWFILEOPEN_DIALOG  (HANDLE)2
#define CAPTURE_WINDOW      (HANDLE)3    // Not really a common dialog, but close enough

// forward declares we will need -- we must have Unicode text, so
// why write new wrappers when we have some lying around already?
UINT __stdcall GodotGetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPWSTR lpString, int nMaxCount);
int __stdcall GodotLoadStringW(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int nBufferMax);
BOOL __stdcall GodotSetWindowTextW(HWND hWnd, LPCWSTR lpString);
LRESULT __stdcall GodotSendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);

// our own forward declares
BOOL CALLBACK EnumChildToTagProc(HWND hwnd, LPARAM lParam);
UINT FRHelper(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL fFindText);
VOID UpdateTextAndFlags(HWND hDlg, LPFINDREPLACEW lpfrw, DWORD dwActionFlag, BOOL fFindText);
LRESULT NotifyFindReplaceParent(LPFINDREPLACEW lpfr, LPFRHOOKPROC lpfrhp, UINT uMsg, BOOL fFindText);
UINT_PTR OFNHookHelperOldStyle(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam, WNDPROC lpfn);
UINT_PTR OFNHookHelper(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL fOpenFile);
UINT_PTR OFNotifyHelper(HWND hdlg, WNDPROC lpfn, WPARAM wParam, LPARAM lParam);
UINT_PTR GenericHookHelper(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam, WNDPROC lpfn);
void SetFontProp(HWND hdlg);
void SetNewFileOpenProp(HWND hdlg);

/*-------------------------------
    WindowProc
    
    This is our global wrapper around *all* window
    procedrures for windows that we create or subclass.
-------------------------------*/
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT RetVal;
    WNDPROC lpfn = WndprocFromFauxWndproc(hwnd, 0, fptWndproc);

    // Chain to the user's wndproc
    RetVal = GodotDoCallback(hwnd, uMsg, wParam, lParam, lpfn, FALSE, fptWndproc);

    // If we get a final destroy message, lets unhook ourselves
    if(uMsg==WM_NCDESTROY)
        CleanupWindow(hwnd);

    return(RetVal);
}

/*-------------------------------
    DialogProc
    
    This is our global wrapper around *all* dialog
    procedrures for windows that we create or subclass.
-------------------------------*/
INT_PTR CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    DLGPROC lpfn;
    INT_PTR RetVal;
    LPGODOTTLSINFO lpgti = GetThreadInfoSafe(TRUE);

    // See if we have a DLGPROC waiting to be assigned somewhere.
    if(lpgti && lpgti->pfnDlgProc)
    {
        // Perhaps it is for *this* dialog. We must make sure it is, or else we will be 
        // assigning the proc to the wrong window! See Windows Bugs # 350862 for details.
        if(OUTSIDE_GODOT_RANGE(GetWindowLongInternal(hwndDlg, DWL_DLGPROC, TRUE)))
        {
            // Set the dlg proc and clear out the dlg proc pointer
            lpfn = (DLGPROC)SetWindowLongInternal(hwndDlg, DWL_DLGPROC, (LONG)lpgti->pfnDlgProc, TRUE);
            lpgti->pfnDlgProc = NULL;
        }
    }

    // Preprocess: also set some RetVal values, which may
    // or may not be overridden by the user's dlgproc.
    switch(uMsg)
    {
        case WM_CTLCOLORBTN:
        case WM_CTLCOLORDLG:
        case WM_CTLCOLOREDIT:
        case WM_CTLCOLORLISTBOX:
        case WM_CTLCOLORSCROLLBAR:
        case WM_CTLCOLORSTATIC:
        case WM_VKEYTOITEM:
            RetVal = (INT_PTR)(BOOL)FALSE;
            break;
            
        case WM_INITDIALOG:
            // Mark all the children now: before the client gets a 
            // chance to init controls, but afte we are sure the
            // controls exist.
            EnumChildWindows(hwndDlg, &EnumChildToTagProc, 0);
            RetVal = (INT_PTR)(BOOL)FALSE;
            break;

        case WM_CHARTOITEM:
        case WM_COMPAREITEM:
            
            // The user's proc MUST do something for these messages,
            // we have no idea what to return here!
            RetVal = 0;
            break;

        case WM_QUERYDRAGICON:
            RetVal = (INT_PTR)NULL;
            break;

        default:
            RetVal = (INT_PTR)(BOOL)FALSE;
            break;
    }
    
    // Chain to the user's dialog procedure. They ought to have one, right?
    if(lpfn = WndprocFromFauxWndproc(hwndDlg, 0, fptDlgproc))
        RetVal = GodotDoCallback(hwndDlg, uMsg, wParam, lParam, lpfn, FALSE, fptDlgproc);


    return(RetVal);
}

/*-------------------------------
    CBTProc

    This is our CBT hook that we use to get information about a window
    about to be created. We also do our window subclassing here so we 
    can be assured that we are handling the messages properly.
-------------------------------*/
LRESULT CALLBACK CBTProc(int nCode, WPARAM wParam, LPARAM lParam)
{
    LPGODOTTLSINFO lpgti = GetThreadInfoSafe(TRUE);
    HHOOK hh = (lpgti ? lpgti->hHook : NULL);

    switch(nCode)
    {
        // We only care about the window creation notification
        case HCBT_CREATEWND:
        {
            LRESULT RetVal;

            InitWindow((HWND)wParam, NULL);

            RetVal = CallNextHookEx(hh, nCode, wParam, lParam);

            // Make sure no one cancelled window creation; if they did, the
            // window will be destroyed without a WM_DESTROY call. Therefore
            // we must be sure to clean ourselves up or we will watch Windows
            // lose our global atom!
            if(RetVal != 0)
                CleanupWindow((HWND)wParam);

            // Lets unhook here, we have done our duty
            TERM_WINDOW_SNIFF(hh);
            return(RetVal);
            break;
        }

        default:
            // Should be impossible, but just in case,
            // we do a nice default sorta thing here.
            if(hh)
                return(CallNextHookEx(hh, nCode, wParam, lParam));
            else
                return(0);
            break;
    }
}

/*-------------------------------
    EnumChildToTagProc

    Tag some child windows
-------------------------------*/
BOOL CALLBACK EnumChildToTagProc(HWND hwnd, LPARAM lParam)
{
    InitWindow(hwnd, NULL);

    // Keep on enumerating
    return(TRUE);
}

/*-------------------------------
    FRHookProcFind/FRHookProcReplace
-------------------------------*/
UINT_PTR CALLBACK FRHookProcFind(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    return(FRHelper(hdlg, uiMsg, wParam, lParam, TRUE));
}
UINT_PTR CALLBACK FRHookProcReplace(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    return(FRHelper(hdlg, uiMsg, wParam, lParam, FALSE));
}

/*-------------------------------
//  OFNHookProc/OFNHookProcSave
-------------------------------*/
UINT_PTR CALLBACK OFNHookProc(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    return(OFNHookHelper(hdlg, uiMsg, wParam, lParam, TRUE));
}
UINT_PTR CALLBACK OFNHookProcSave(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    return(OFNHookHelper(hdlg, uiMsg, wParam, lParam, FALSE));
}

/*-------------------------------
//  PagePaintHook
//
//
// We use this hook to handle the WM_PSD_PAGESETUPDLG when it comes through
-------------------------------*/
UINT_PTR CALLBACK PagePaintHook(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    LPGODOTTLSINFO lpgti = GetThreadInfoSafe(TRUE);
    WNDPROC lpfnP = (lpgti ? lpgti->pfnPagePaint : NULL);

    if(uiMsg != WM_PSD_PAGESETUPDLG)
        return(GenericHookHelper(hdlg, uiMsg, wParam, lParam, lpfnP));
    else
    {
        // Ok, this is the WM_PSD_PAGESETUPDLG event. wParam is some random stuff
        // to pass on and lParam is a PAGESETUPDLGA structure that we need to turn
        // into a PAGESETUPDLGW.

        if(lpfnP)
        {
            LPPAGESETUPDLGA lppsda;
            PAGESETUPDLGW psdw;
            UINT_PTR RetVal;
            ALLOCRETURN ar = arNoAlloc;
            WNDPROC lpfnS = (lpgti ? lpgti->pfnPageSetup : NULL);

            lppsda = (LPPAGESETUPDLGA)lParam;
            psdw.lStructSize = sizeof(PAGESETUPDLGW);

            // Copy some stuff over now
            psdw.hwndOwner          = lppsda->hwndOwner;
            psdw.ptPaperSize        = lppsda->ptPaperSize;
            psdw.rtMinMargin        = lppsda->rtMinMargin;
            psdw.rtMargin           = lppsda->rtMargin;
            psdw.hInstance          = lppsda->hInstance;
            psdw.lCustData          = lppsda->lCustData;
            
            // Do NOT deallocate the HGLOBALS here, someone else might
            // need them! Passing FALSE for the fFree param accomplishes
            // this feat.
            psdw.hDevMode           = HDevModeWfromA(&(lppsda->hDevMode), FALSE);
            psdw.hDevNames          = HDevNamesWfromA(&(lppsda->hDevNames), FALSE);

            // Hide the details of our hook from them (by munging flags as 
            // necessary)
            psdw.Flags              = lppsda->Flags;
            if(lpfnP)
                psdw.Flags          &= ~PSD_ENABLEPAGEPAINTHOOK;
            psdw.lpfnPagePaintHook  = lpfnP;
            if(lpfnS)
                psdw.Flags          &= ~PSD_ENABLEPAGESETUPHOOK;
            psdw.lpfnPageSetupHook  = lpfnS;

            if(lppsda->Flags & PSD_ENABLEPAGESETUPTEMPLATE)
            {
                psdw.hPageSetupTemplate = lppsda->hPageSetupTemplate;
                ar = GodotToUnicodeOnHeap(lppsda->lpPageSetupTemplateName, 
                                          &(LPWSTR)psdw.lpPageSetupTemplateName);
            }

            RetVal = ((* lpfnP)(hdlg, WM_PSD_PAGESETUPDLG, wParam, (LPARAM)&psdw));
            if(ar==arAlloc)
                GodotHeapFree((LPWSTR)psdw.lpPageSetupTemplateName);
            lppsda->hDevMode        = HDevModeAfromW(&(psdw.hDevMode), TRUE);
            lppsda->hDevNames       = HDevNamesAfromW(&(psdw.hDevNames), TRUE);
            return(RetVal);
        }
        else
            return(FALSE);
    }
    
}

//
// Ok, here are all our almost but not quite pointless hooks that we have.
// These hooks allow us to make sure that the dialog and all the controls in
// it are tagged appropriately. See GenericHookHelper for details.
//

UINT_PTR CALLBACK CCHookProc(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    LPGODOTTLSINFO lpgti = GetThreadInfoSafe(TRUE);
    return(GenericHookHelper(hdlg, uiMsg, wParam, lParam, (lpgti ? lpgti->pfnChooseColor : NULL)));
}

UINT_PTR CALLBACK CFHookProc(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    LPGODOTTLSINFO lpgti = GetThreadInfoSafe(TRUE);

    if(uiMsg==WM_INITDIALOG)
        SetFontProp(hdlg);
    
    return(GenericHookHelper(hdlg, uiMsg, wParam, lParam, (lpgti ? lpgti->pfnChooseFont : NULL)));
}

UINT_PTR CALLBACK PageSetupHook(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    LPGODOTTLSINFO lpgti = GetThreadInfoSafe(TRUE);
    return(GenericHookHelper(hdlg, uiMsg, wParam, lParam, (lpgti ? lpgti->pfnPageSetup : NULL)));
}

UINT_PTR CALLBACK PrintHookProc(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    LPGODOTTLSINFO lpgti = GetThreadInfoSafe(TRUE);
    return(GenericHookHelper(hdlg, uiMsg, wParam, lParam, (lpgti ? lpgti->pfnPrintDlg : NULL)));
}

UINT_PTR CALLBACK SetupHookProc(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    LPGODOTTLSINFO lpgti = GetThreadInfoSafe(TRUE);
    return(GenericHookHelper(hdlg, uiMsg, wParam, lParam, (lpgti ? lpgti->pfnPrintDlgSetup : NULL)));
}

UINT_PTR CALLBACK OFNHookProcOldStyle(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    LPGODOTTLSINFO lpgti = GetThreadInfoSafe(TRUE);
    WNDPROC lpfn = (WNDPROC)(lpgti ? lpgti->pfnGetOpenFileNameOldStyle : NULL);
    return(OFNHookHelperOldStyle(hdlg, uiMsg, wParam, lParam, lpfn));
}

UINT_PTR CALLBACK OFNHookProcOldStyleSave(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    LPGODOTTLSINFO lpgti = GetThreadInfoSafe(TRUE);
    WNDPROC lpfn = (WNDPROC)(lpgti ? lpgti->pfnGetSaveFileNameOldStyle : NULL);
    return(OFNHookHelperOldStyle(hdlg, uiMsg, wParam, lParam, lpfn));
}

/*-------------------------------
//  FRHelper
//
//  Used to handle lots of the shared code between the find and replace hook functions. Note 
//  that some of it does not always apply: certain controls are hidden from the FIND dialog, etc.
//  But since all of the code other than the actual callbacks themselves is shared, this keeps
//  us from a lot of duplication.
-------------------------------*/
UINT FRHelper(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL fFindText)
{
    LPGODOTTLSINFO lpgti = GetThreadInfoSafe(TRUE);
    LPFRHOOKPROC lpfn = 0;
    UINT RetVal;

    if(!lpgti)
    {
        if(lpfn)
            return((* lpfn)(hdlg, uiMsg, wParam, lParam));
        else
            return(FALSE);
    }

    if(fFindText)
        lpfn = lpgti->pfnFindText;
    else
        lpfn = lpgti->pfnReplaceText;

    switch(uiMsg)
    {
        case WM_COMMAND:
        {
            LPFINDREPLACEW lpfr;

            if(fFindText)
                lpfr = lpgti->lpfrwFind;
            else
                lpfr = lpgti->lpfrwReplace;
        
            switch(GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:      // FIND
                    UpdateTextAndFlags(hdlg, lpfr, FR_FINDNEXT, fFindText);
                    NotifyFindReplaceParent(lpfr, lpfn, msgFINDMSGSTRING, fFindText);
                    RetVal = TRUE;
                    break;
                    
                case psh1:      // REPLACE
                case psh2:      // REPLACE ALL
                    UpdateTextAndFlags(hdlg, lpfr, (psh1 ? FR_REPLACE : FR_REPLACEALL), fFindText);
                    if (NotifyFindReplaceParent(lpfr, lpfn, msgFINDMSGSTRING, fFindText) == TRUE)
                    {
                        // Change <Cancel> button to <Close> if function
                        // returns TRUE (IDCANCEL instead of psh1).
                        // First load the string if we never have before
                        if(m_szClose[0] == 0)
                            GodotLoadStringW(GetComDlgHandle(), iszClose, m_szClose, CCHCLOSE);
                        GodotSetWindowTextW(GetDlgItem(hdlg, IDCANCEL), (LPWSTR)m_szClose);
                    }
                    RetVal = TRUE;
                    break;

                case pshHelp:   // HELP
                    if (msgHELPMSGSTRING && lpfr->hwndOwner)
                    {
                        UpdateTextAndFlags(hdlg, lpfr, 0, fFindText);
                        NotifyFindReplaceParent(lpfr, lpfn, msgHELPMSGSTRING, fFindText);
                    }
                    RetVal = TRUE;
                    break;
                   
                case IDCANCEL:  // CANCEL, both types
                case IDABORT:
                    // They are destroying the dialog, so unhook ourselves
                    // and clean up the dialog. Usually the caller will keep
                    // a FINDREPLACEW lying around, so if we do not clean up
                    // we might have some re-entrancy issues here.
                    if(lpfn)
                        lpfr->lpfnHook = lpfn;
                    else
                    {
                        lpfr->lpfnHook = NULL;
                        lpfr->Flags &= ~FR_ENABLEHOOK;
                    }

                    if(fFindText)
                    {
                        lpgti->lpfrwFind = NULL;
                        lpgti->pfnFindText = NULL;
                    }
                    else
                    {
                        lpgti->lpfrwReplace = NULL;
                        lpgti->pfnReplaceText = NULL;
                    }

                    // Fall through. We do not set the RetVal to TRUE, since  
                    // we need to make sure that comdlg32.dll cleans up

                default:    // Everything else
                    RetVal = FALSE;
                    break;
            }
            break;
        }

        case WM_INITDIALOG:
            // Mark all the children now, before the user's proc gets to them
            EnumChildWindows(hdlg, &EnumChildToTagProc, 0);
            
            // Perhaps the caller's hook will override this, but we need to cover 
            // our bases in case there the caller has no hook. The caller expects
            // us to return TRUE if they are drawing the dlg, FALSE if we are.
            RetVal = TRUE;
            break;

        default:
            RetVal = FALSE;
            break;
    }

    if(lpfn)
        RetVal = (* lpfn)(hdlg, uiMsg, wParam, lParam);
    
    return(RetVal);
}

/*-------------------------------
//  OFNHookHelperOldStyle
//
//  Almost all of the old style fileopen/save code is shared, and this function shares it!
-------------------------------*/
UINT_PTR OFNHookHelperOldStyle(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam, WNDPROC lpfn)
{
    UINT_PTR RetVal = FALSE;

    if(!msgSHAREVISTRING)
        msgSHAREVISTRING = RegisterWindowMessage(SHAREVISTRINGA);
    if(!msgFILEOKSTRING)
        msgFILEOKSTRING = RegisterWindowMessage(FILEOKSTRINGA);
    
    if(uiMsg==WM_INITDIALOG)
    {
        // Mark all the children now, before the user's proc gets to them
        EnumChildWindows(hdlg, &EnumChildToTagProc, 0);
        if(lpfn)
            RetVal = (* lpfn)(hdlg, uiMsg, wParam, lParam);
        else
            RetVal = TRUE;
    }
    else if(((uiMsg == msgFILEOKSTRING) || (uiMsg == msgSHAREVISTRING))) 
    {
        WCHAR drive[_MAX_DRIVE + 1];
        WCHAR dir[_MAX_DIR +1];
        WCHAR file[_MAX_FNAME +1];
        LPOPENFILENAMEA lpofnA = (LPOPENFILENAMEA)lParam;
        OPENFILENAMEW ofn;
        LPARAM lParamW;
        ALLOCRETURN arCustomFilter = arNoAlloc;
        ALLOCRETURN arFile = arNoAlloc;
        ALLOCRETURN arFileTitle = arNoAlloc;

        // lParam is an LPOPENFILENAMEA to be converted. Copy all the
        // members that the user might expect.
        ofn.lStructSize = OPENFILENAME_SIZE_VERSION_400W;

        arCustomFilter          = GodotToUnicodeCpgCchOnHeap(lpofnA->lpstrCustomFilter,
                                                             lpofnA->nMaxCustFilter,
                                                             &ofn.lpstrCustomFilter,
                                                             g_acp);
        ofn.nMaxCustFilter      = gwcslen(ofn.lpstrCustomFilter);
        ofn.nFilterIndex        = lpofnA->nFilterIndex;
        ofn.nMaxFile            = lpofnA->nMaxFile * sizeof(WCHAR);
        arFile                  = GodotToUnicodeCpgCchOnHeap(lpofnA->lpstrFile,
                                                             lpofnA->nMaxFile,
                                                             &ofn.lpstrFile,
                                                             g_acp);
        ofn.nMaxFile            = gwcslen(ofn.lpstrFile);
        arFileTitle             = GodotToUnicodeCpgCchOnHeap(lpofnA->lpstrFileTitle,
                                                             lpofnA->nMaxFileTitle,
                                                             &ofn.lpstrFileTitle,
                                                             g_acp);
        ofn.nMaxFileTitle       = gwcslen(ofn.lpstrFileTitle);
        ofn.Flags = lpofnA->Flags;

        // nFileOffset and nFileExtension are to provide info about the
        // file name and extension location in lpstrFile, but there is 
        // no reasonable way to get it from the return so we just recalc
        gwsplitpath(ofn.lpstrFile, drive, dir, file, NULL);
        ofn.nFileOffset = (gwcslen(drive) + gwcslen(dir));
        ofn.nFileExtension = ofn.nFileOffset + gwcslen(file);

        lParamW = (LPARAM)&ofn;

        if(lpfn)
            RetVal = (* lpfn)(hdlg, uiMsg, wParam, lParamW);

        // Free up some memory if we allocated any
        if(arCustomFilter==arAlloc)
            GodotHeapFree(ofn.lpstrCustomFilter);
        if(arFile==arAlloc)
            GodotHeapFree(ofn.lpstrFile);
        if(arFileTitle==arAlloc)
            GodotHeapFree(ofn.lpstrFileTitle);
    }
    else
    {
        if(lpfn)
            RetVal = (* lpfn)(hdlg, uiMsg, wParam, lParam);
    }

    return(RetVal);
}

/*-------------------------------
//  OFNHookHelper
//
//  Almost all of the fileopen/save code is shared, and this function shares it!
-------------------------------*/
UINT_PTR OFNHookHelper(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam, BOOL fOpenFile)
{
    UINT_PTR RetVal = 0;
    LPGODOTTLSINFO lpgti = GetThreadInfoSafe(TRUE);
    LPOFNHOOKPROC lpfn;

    if(fOpenFile)
        lpfn = (lpgti ? lpgti->pfnGetOpenFileName : NULL);
    else
        lpfn = (lpgti ? lpgti->pfnGetSaveFileName : NULL);

    if(uiMsg==WM_INITDIALOG)
    {
        HWND hwndParent;
        
        // Tag the window as a new style file open dlg
        SetNewFileOpenProp(hdlg);

        if(hwndParent = GetParent(hdlg))
            SetNewFileOpenProp(hwndParent);
        
        // Mark all the children now, before the user's proc gets to them
        EnumChildWindows(hdlg, &EnumChildToTagProc, 0);
        RetVal = TRUE;
    }

    if(lpfn)
    {
        switch(uiMsg)
        {
            case WM_NOTIFY:
                RetVal = OFNotifyHelper(hdlg, lpfn, wParam, lParam);
                break;

            default:
                RetVal = (* lpfn)(hdlg, uiMsg, wParam, lParam);
                break;
        }
    }
    
    return(RetVal);
}

/*-------------------------------
//  OSNotifyHelper
-------------------------------*/
UINT_PTR OFNotifyHelper(HWND hdlg, WNDPROC lpfn, WPARAM wParam, LPARAM lParam)
{
    UINT_PTR RetVal;
    LPOFNOTIFYA lpofnfyA = (LPOFNOTIFYA)lParam;

    switch(lpofnfyA->hdr.code)
    {
        case CDN_FILEOK:
        case CDN_FOLDERCHANGE:
        case CDN_HELP:
        case CDN_INCLUDEITEM:
        case CDN_INITDONE:
        case CDN_SELCHANGE:
        case CDN_SHAREVIOLATION:
        case CDN_TYPECHANGE:
        {
            LPOPENFILENAMEA lpofnA = lpofnfyA->lpOFN;
            OFNOTIFYW ofnfy;
            OPENFILENAMEW ofn;
            WCHAR drive[_MAX_DRIVE];
            WCHAR dir[_MAX_DIR];
            WCHAR file[_MAX_FNAME];
            ALLOCRETURN arCustomFilter = arNoAlloc;
            ALLOCRETURN arFile = arNoAlloc;
            ALLOCRETURN arFileTitle = arNoAlloc;

            ZeroMemory(&ofnfy, sizeof(OFNOTIFYW));
            ofnfy.hdr = lpofnfyA->hdr;
            ofnfy.lpOFN = &ofn;
            ofn.lStructSize         = OPENFILENAME_SIZE_VERSION_400W;
            ofn.Flags               = lpofnA->Flags;
            ofn.hwndOwner           = lpofnA->hwndOwner;
            ofn.hInstance           = lpofnA->hInstance;
            ofn.lpfnHook            =  lpfn;
            arCustomFilter          = GodotToUnicodeCpgCchOnHeap(lpofnA->lpstrCustomFilter,
                                                                 lpofnA->nMaxCustFilter,
                                                                 &ofn.lpstrCustomFilter,
                                                                 g_acp);
            ofn.nMaxCustFilter      = gwcslen(ofn.lpstrCustomFilter);
            ofn.nFilterIndex        = lpofnA->nFilterIndex;
            ofn.nMaxFile            = lpofnA->nMaxFile * sizeof(WCHAR);
            arFile                  = GodotToUnicodeCpgCchOnHeap(lpofnA->lpstrFile,
                                                                 lpofnA->nMaxFile,
                                                                 &ofn.lpstrFile,
                                                                 g_acp);
            ofn.nMaxFile            = gwcslen(ofn.lpstrFile);
            arFileTitle             = GodotToUnicodeCpgCchOnHeap(lpofnA->lpstrFileTitle,
                                                                 lpofnA->nMaxFileTitle,
                                                                 &ofn.lpstrFileTitle,
                                                                 g_acp);
            ofn.nMaxFileTitle       = gwcslen(ofn.lpstrFileTitle);
            ofn.Flags = lpofnA->Flags;

            // nFileOffset and nFileExtension are to provide info about the
            // file name and extension location in lpstrFile, but there is 
            // no reasonable way to get it from the return so we just recalc
            gwsplitpath(ofn.lpstrFile, drive, dir, file, NULL);
            ofn.nFileOffset = (gwcslen(drive) + gwcslen(dir));
            ofn.nFileExtension = ofn.nFileOffset + gwcslen(file);
            
            if(ofnfy.hdr.code == CDN_SHAREVIOLATION)
            {
                WCHAR lpwzFile[MAX_PATH];

                if(FSTRING_VALID(lpofnfyA->pszFile))
                {
                    MultiByteToWideChar(g_acp, 0, 
                                        lpofnfyA->pszFile, -1, 
                                        lpwzFile, MAX_PATH);
                    ofnfy.pszFile = lpwzFile;
                }
                RetVal = (* lpfn)(hdlg, WM_NOTIFY, wParam, (LPARAM)&ofnfy);
            }
            else
            {
                RetVal = (* lpfn)(hdlg, WM_NOTIFY, wParam, (LPARAM)&ofnfy);
            }

            // Free up some memory if we allocated any
            if(arCustomFilter==arAlloc)
                GodotHeapFree(ofn.lpstrCustomFilter);
            if(arFile==arAlloc)
                GodotHeapFree(ofn.lpstrFile);
            if(arFileTitle==arAlloc)
                GodotHeapFree(ofn.lpstrFileTitle);

            break;
        }

        default:
            RetVal = (* lpfn)(hdlg, WM_NOTIFY, wParam, lParam);
            break;
    }
    
    return(RetVal);
}

/*-------------------------------
//  GenericHookHelper
//
//  This function is to assist all the comdlg32 hook functions that serve
//  no real purpose that we know of, other than to make sure all the 
//  child controls get marked as "Unicode" controls, etc.
-------------------------------*/
UINT_PTR GenericHookHelper(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam, WNDPROC lpfn)
{
    UINT_PTR RetVal = FALSE;
    
    switch(uiMsg)
    {
        case WM_INITDIALOG:
            // Mark all the children now, before the user's proc gets to them
            EnumChildWindows(hdlg, &EnumChildToTagProc, 0);
            if(lpfn)
                RetVal = (* lpfn)(hdlg, uiMsg, wParam, lParam);
            else
                RetVal = TRUE;
            break;
            
        case WM_DESTROY:
        case WM_NCDESTROY:
        default:
            if(lpfn)
                RetVal = (* lpfn)(hdlg, uiMsg, wParam, lParam);
            break;
    }
    
    return(RetVal);
}

/*-------------------------------
//  UpdateTextAndFlags
//
//  Get the text from the control, and update the flags. Use in
//  preparation for notifying the owner window that the user has
//  done something interesting.
// 
//  Modified from find.c from the comdlg32 project in the Shell
//  depot. It definitely needed its own special spin, though!
//
//  chx1 is whether or not to match entire words
//  chx2 is whether or not case is relevant
//  chx3 is whether or not to wrap scans
-------------------------------*/
VOID UpdateTextAndFlags(HWND hDlg, LPFINDREPLACEW lpfrw, DWORD dwActionFlag, BOOL fFindText)
{
    //  Only clear flags that this routine sets.  The hook and template
    //  flags should not be anded off here.
    lpfrw->Flags &= ~((DWORD)(FR_WHOLEWORD | FR_MATCHCASE | FR_REPLACE |
                              FR_FINDNEXT | FR_REPLACEALL | FR_DOWN));
    if (IsDlgButtonChecked(hDlg, chx1))
        lpfrw->Flags |= FR_WHOLEWORD;

    if (IsDlgButtonChecked(hDlg, chx2))
        lpfrw->Flags |= FR_MATCHCASE;

    //  Set ACTION flag FR_{REPLACE,FINDNEXT,REPLACEALL}.
    lpfrw->Flags |= dwActionFlag;

    GodotGetDlgItemTextW(hDlg, edt1, lpfrw->lpstrFindWhat, lpfrw->wFindWhatLen);

    if (fFindText)
    {
        //  Assume searching down.  Check if UP button is NOT pressed, rather
        //  than if DOWN button IS.  So, if buttons have been hidden or
        //  disabled, FR_DOWN flag will be set correctly.
        if (!IsDlgButtonChecked(hDlg, rad1))
            lpfrw->Flags |= FR_DOWN;
    }
    else
    {
        GodotGetDlgItemTextW(hDlg, edt2, lpfrw->lpstrReplaceWith, lpfrw->wReplaceWithLen);
        lpfrw->Flags |= FR_DOWN;
    }
}


/*-------------------------------
//  NotifyFindReplaceParent
//
//  Let hwndOwner know what is happening, since the user has
//  performed some kind of action that they might want to 
//  know about.
//
//  Modified from find.c from the comdlg32 project in the Shell
//  depot. It definitely needed its own special spin, though!
-------------------------------*/
LRESULT NotifyFindReplaceParent(LPFINDREPLACEW lpfr, LPFRHOOKPROC lpfrhp, UINT uMsg, BOOL fFindText)
{
    LRESULT RetVal;
    DWORD Flags;

    // Cache the flags setting since we may be mucking with it
    Flags = lpfr->Flags;

    // Now, muck with the structure a bit
    // to hide our hook from the user
    if(lpfrhp)
        lpfr->lpfnHook = lpfrhp;
    else
    {
        lpfr->lpfnHook = NULL;
        Flags &= ~FR_ENABLEHOOK;
    }

    RetVal = GodotSendMessageW(lpfr->hwndOwner, uMsg, 0, (DWORD_PTR)lpfr);

    // Restore the structure to what it was
    lpfr->Flags = Flags;
    if(fFindText)
        lpfr->lpfnHook = &FRHookProcFind;
    else
        lpfr->lpfnHook = &FRHookProcReplace;
    
    return(RetVal);
}

/*-------------------------------
//  IsFontDialog
-------------------------------*/
BOOL IsFontDialog(HWND hdlg)
{
    return((BOOL)(GetPropA(hdlg, m_szComdlgClass) == CHOOSEFONT_DIALOG));
}

/*-------------------------------
//  IsNewFileOpenDialog
-------------------------------*/
BOOL IsNewFileOpenDialog(HWND hdlg)
{
    return((BOOL)(GetPropA(hdlg, m_szComdlgClass) == NEWFILEOPEN_DIALOG));
}

/*-------------------------------
//  IsCaptureWindow
-------------------------------*/
BOOL IsCaptureWindow(HWND hdlg)
{
    return((BOOL)(GetPropA(hdlg, m_szComdlgClass) == CAPTURE_WINDOW));
}

/*-------------------------------
//  RemoveComdlgPropIfPresent
-------------------------------*/
void RemoveComdlgPropIfPresent(HWND hdlg)
{
    if(GetPropA(hdlg, m_szComdlgClass) != 0)
        RemovePropA(hdlg, m_szComdlgClass);
    return;
}

/*-------------------------------
//  SetNewFileOpenProp
-------------------------------*/
void SetNewFileOpenProp(HWND hdlg)
{
    // We have to aggressively refcount our prop to keep anyone from
    // losing it. Thus we do an initial GlobalAddAtom on it and then
    // subsequently call SetPropA on it with the same string.
    if(!m_aComdlgClass)
        m_aComdlgClass = GlobalAddAtomA(m_szComdlgClass);

    SetPropA(hdlg, m_szComdlgClass, (HANDLE)NEWFILEOPEN_DIALOG);
    return;
}

/*-------------------------------
//  SetFontProp
-------------------------------*/
void SetFontProp(HWND hdlg)
{
    // We have to aggressively refcount our prop to keep anyone from
    // losing it. Thus we do an initial GlobalAddAtom on it and then
    // subsequently call SetPropA on it with the same string.
    if(!m_aComdlgClass)
        m_aComdlgClass = GlobalAddAtomA(m_szComdlgClass);

    SetPropA(hdlg, m_szComdlgClass, (HANDLE)CHOOSEFONT_DIALOG);
    return;
}

/*-------------------------------
//  SetCaptureWindowProp
-------------------------------*/
void SetCaptureWindowProp(HWND hdlg)
{
    // We have to aggressively refcount our prop to keep anyone from
    // losing it. Thus we do an initial GlobalAddAtom on it and then
    // subsequently call SetPropA on it with the same string.
    if(!m_aComdlgClass)
        m_aComdlgClass = GlobalAddAtomA(m_szComdlgClass);

    SetPropA(hdlg, m_szComdlgClass, (HANDLE)CAPTURE_WINDOW);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\godot\helpapis.c ===
/*++

Copyright (c) 2000-2001,  Microsoft Corporation  All rights reserved.

Module Name:

    helpapis.c

Abstract:

    SP_GetFmtValueW
    SP_PutNumberW
    CaseHelper
    CompareHelper
    GetOpenSaveFileHelper
    FindReplaceTextHelper
    RtlIsTextUnicode

Revision History:

    17 Mar 2001    v-michka    Created.

--*/

#include "precomp.h"

// forward declare, since win9xu.c has no header
int __stdcall GodotCompareStringW(LCID Locale, DWORD dwCmpFlags, 
                                  LPCWSTR lpString1, int cchCount1, 
                                  LPCWSTR lpString2, int cchCount2);


/*-------------------------------
    SP_GetFmtValueW

    stolen from wsprintf.c
-------------------------------*/
LPCWSTR SP_GetFmtValueW(LPCWSTR lpch, int *lpw)
{
    int ii = 0;

    /* It might not work for some locales or digit sets */
    while (*lpch >= L'0' && *lpch <= L'9') {
        ii *= 10;
        ii += (int)(*lpch - L'0');
        lpch++;
    }

    *lpw = ii;

    /*
     * return the address of the first non-digit character
     */
    return lpch;
}

/*-------------------------------
    SP_PutNumberW

    stolen from wsprintf.c
-------------------------------*/
int SP_PutNumberW(LPWSTR lpstr, ULONG64 n, int limit, DWORD radix, int uppercase)
{
    DWORD mod;
    int count = 0;

    /* It might not work for some locales or digit sets */
    if(uppercase)
        uppercase =  'A'-'0'-10;
    else
        uppercase = 'a'-'0'-10;

    if (count < limit) {
        do  {
            mod =  (ULONG)(n % radix);
            n /= radix;

            mod += '0';
            if (mod > '9')
            mod += uppercase;
            *lpstr++ = (WCHAR)mod;
            count++;
        } while((count < limit) && n);
    }

    return count;
}

/*-------------------------------
    SP_ReverseW

    stolen from wsprintf.c
-------------------------------*/
void SP_ReverseW(LPWSTR lpFirst, LPWSTR lpLast)
{
    WCHAR ch;

    while(lpLast > lpFirst){
        ch = *lpFirst;
        *lpFirst++ = *lpLast;
        *lpLast-- = ch;
    }
}

#define NLS_CP_DLL_PROC_NAME    "NlsDllCodePageTranslation"

// Must dynamically link to "NlsDllCodePageTranslation" 
// because the DLL may not be on the machine 
typedef BOOL (__stdcall *PFNgb) (DWORD, DWORD, LPSTR, int, LPWSTR, int, LPCPINFO);
static PFNgb s_pfnGB;


/*-------------------------------
    GB18030Helper

    Provider for our GB18030 support
-------------------------------*/
DWORD GB18030Helper(DWORD cpg, DWORD dw, LPSTR lpMB, int cchMB, LPWSTR lpWC, int cchWC, LPCPINFO lpCPI)
{
    HMODULE hmod = 0;

        if (s_pfnGB == NULL)
            s_pfnGB = (PFNgb)GetProcAddress(GetGB18030Handle(), NLS_CP_DLL_PROC_NAME);

        if (s_pfnGB)
            return(s_pfnGB(cpg, dw, lpMB, cchMB, lpWC, cchWC, lpCPI));
        else
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return(0);
        }
}

/*-------------------------------
    CaseHelper
-------------------------------*/
void CaseHelper(LPWSTR pchBuff, DWORD cch, BOOL fUpper)
{
    LPSTR pszA;
    int cb;
    if(!pchBuff || !cch || !*pchBuff)
        return;
    if (-1 == cch)
        cch = gwcslen(pchBuff);
        cb = 1 + g_mcs * cch;
    pszA = GodotHeapAlloc(cb+1);
    if(pszA==NULL || cb==0)
    {
        // Not much else we can do here, so bail
        SetLastError(ERROR_OUTOFMEMORY);
    }
    else
    {
        *(pszA + cb) = '\0';
        WideCharToMultiByte(g_acp, 0, pchBuff, cch, pszA, cch, NULL, NULL); 

        if(fUpper)
            CharUpperA(pszA);
        else
            CharLowerA(pszA);
    
        MultiByteToWideChar(g_acp, 0, pszA, cch, pchBuff, cch);
        GodotHeapFree(pszA);
    }
    return;
}

/*-------------------------------
    CompareHelper
-------------------------------*/
int CompareHelper(LPCWSTR lpsz1, LPCWSTR lpsz2, BOOL fCaseSensitive)
{
    int RetVal;
    DWORD dwCmpFlags = (fCaseSensitive ? NORM_IGNORECASE : 0);
    
    RetVal=GodotCompareStringW(LOCALE_USER_DEFAULT, dwCmpFlags, lpsz1, -1, lpsz2, -1);

    if(RetVal==0)
    {
        //
        // The caller is not expecting failure.  Try the system
        // default locale id.
        //
        RetVal=GodotCompareStringW(LOCALE_SYSTEM_DEFAULT, dwCmpFlags, lpsz1, -1, lpsz2, -1);
    }
    
    if(RetVal==0)
    {
        if (lpsz1 && lpsz2)
        {
            //
            // The caller is not expecting failure.  We've never had a
            // failure indicator before. Note we can still fail here in
            // an out of memory situation; what else can we do, though?
            //
            LPSTR sz1, sz2;
            ALLOCRETURN ar1, ar2;

            RetVal = 0;
            sz1 = NULL;
            ar1 = GodotToAcpOnHeap(lpsz1, &sz1);
            if(ar1 != arFailed)
            {
                sz2 = NULL;
                ar2 = GodotToAcpOnHeap(lpsz2, &sz2);
                if(ar2 != arFailed)
                {
                    if(sz1 && sz2)
                    {
                        if(fCaseSensitive)
                            RetVal = lstrcmpA(sz1, sz2);
                        else
                            RetVal = lstrcmpiA(sz1, sz2);
                    }

                    if(ar2==arAlloc)
                        GodotHeapFree(sz2);
                }

                if(ar1==arAlloc)
                    GodotHeapFree(sz1);
            }

            return(RetVal);
        }
        else if (lpsz1)
        {
            return (1);
        }
        else if (lpsz2)
        {
            return (-1);
        }
        else
        {
            return (0);
        }
    }

    return(RetVal - 2);
}

/*-------------------------------
    GetOpenSaveFileHelper

    Since 95% of the FileOpen and FileSave code is identical,
    we use one shared function for both
-------------------------------*/
BOOL GetOpenSaveFileHelper(LPOPENFILENAMEW lpofn, BOOL fOpenFile)
{
    // Begin locals
    BOOL RetVal;
    BOOL fFailedHook = FALSE;
    OPENFILENAMEA ofnA;
    LPGODOTTLSINFO lpgti;

    // Do not use sizeof(OPENFILENAMEA) since that will give us the
    // Windows 2000 structure, which would be BAAAAD (Win9x will choke
    // on the lStructSize).
    ZeroMemory(&ofnA, OPENFILENAME_SIZE_VERSION_400A);
    ofnA.lStructSize = OPENFILENAME_SIZE_VERSION_400A;

    if(!(lpgti = GetThreadInfoSafe(TRUE)))
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }

    // Do the hook handling
    if(lpofn->Flags & OFN_EXPLORER)
    {    
        if(fOpenFile)
        {
            if(lpgti->pfnGetOpenFileName)
                fFailedHook = TRUE;
            else if((lpofn->Flags & OFN_ENABLEHOOK) && lpofn->lpfnHook)
            {
                lpgti->pfnGetOpenFileName = lpofn->lpfnHook;
                ofnA.lpfnHook = &OFNHookProc;
            }
        }
        else
        {
            if(lpgti->pfnGetSaveFileName)
                fFailedHook = TRUE;
            else if((lpofn->Flags & OFN_ENABLEHOOK) && lpofn->lpfnHook)
            {
                lpgti->pfnGetSaveFileName = lpofn->lpfnHook;
                ofnA.lpfnHook = &OFNHookProcSave;
            }
        }

    }
    else
    {
        if(fOpenFile)
        {
            if(lpgti->pfnGetOpenFileNameOldStyle)
                fFailedHook = TRUE;
            else if((lpofn->Flags & OFN_ENABLEHOOK) && lpofn->lpfnHook)
            {
                lpgti->pfnGetOpenFileNameOldStyle = lpofn->lpfnHook;
                ofnA.lpfnHook = &OFNHookProcOldStyle;
            }
        }
        else
        {
            if(lpgti->pfnGetSaveFileNameOldStyle)
                fFailedHook = TRUE;
            else if((lpofn->Flags & OFN_ENABLEHOOK) && lpofn->lpfnHook)
            {
                lpgti->pfnGetSaveFileNameOldStyle = lpofn->lpfnHook;
                ofnA.lpfnHook = &OFNHookProcOldStyleSave;
            }
        }
    }

    // Check to see if we tripped over any of the hooks
    if(fFailedHook)
    {
        SetLastError(ERROR_INVALID_FILTER_PROC);
        return(FALSE);
    }
    
    if((lpofn->Flags & OFN_ENABLETEMPLATEHANDLE) || (lpofn->Flags & OFN_ENABLETEMPLATE))
        ofnA.hInstance = lpofn->hInstance;

    if(FSTRING_VALID(lpofn->lpstrFilter))
    {
        size_t lpstrFilterLen = cchUnicodeMultiSz(lpofn->lpstrFilter);
        _STACKALLOC(lpstrFilterLen*g_mcs, ofnA.lpstrFilter);
        WideCharToMultiByte(g_acp, 0, lpofn->lpstrFilter, lpstrFilterLen, (LPSTR)ofnA.lpstrFilter, lpstrFilterLen * g_mcs, NULL, NULL);
    }

    if ((lpofn->nMaxCustFilter > 0) && FSTRING_VALID(lpofn->lpstrCustomFilter))
    {
        ofnA.nMaxCustFilter = (lpofn->nMaxCustFilter*g_mcs);
        _STACKALLOC(ofnA.nMaxCustFilter, ofnA.lpstrCustomFilter);
        WideCharToMultiByte(g_acp, 0, lpofn->lpstrCustomFilter, lpofn->nMaxCustFilter, ofnA.lpstrCustomFilter, ofnA.nMaxCustFilter, NULL, NULL);
        ofnA.nFilterIndex = lpofn->nFilterIndex;
    }

    ofnA.nMaxFile = (lpofn->nMaxFile*g_mcs);
    _STACKALLOC(ofnA.nMaxFile, ofnA.lpstrFile);
    WideCharToMultiByte(g_acp, 0, lpofn->lpstrFile, lpofn->nMaxFile, ofnA.lpstrFile, ofnA.nMaxFile, NULL, NULL);

    if ((lpofn->nMaxFileTitle > 0) && (FSTRING_VALID(lpofn->lpstrFileTitle)))
    {
        ofnA.nMaxFileTitle = (lpofn->nMaxFileTitle*g_mcs);
        _STACKALLOC(ofnA.nMaxFileTitle, ofnA.lpstrFileTitle);
        WideCharToMultiByte(g_acp, 0, lpofn->lpstrFileTitle, lpofn->nMaxFileTitle, ofnA.lpstrFileTitle, ofnA.nMaxFileTitle, NULL, NULL);
    }

    if(FSTRING_VALID(ofnA.lpstrFile))
    {
        // nFileOffset and nFileExtension are to provide info about the
        // file name and extension location in lpstrFile, but there is 
        // no reasonable way to get it from the return so we just recalc
        CHAR driveA[_MAX_DRIVE];
        CHAR dirA[_MAX_DIR];
        CHAR fileA[_MAX_FNAME];
        gsplitpath(ofnA.lpstrFile, driveA, dirA, fileA, NULL);
        ofnA.nFileOffset = (lstrlenA(driveA) + lstrlenA(dirA));
        ofnA.nFileExtension = ofnA.nFileOffset + lstrlenA(fileA);
    }

    GODOT_TO_ACP_STACKALLOC(lpofn->lpstrInitialDir, ofnA.lpstrInitialDir);
    GODOT_TO_ACP_STACKALLOC(lpofn->lpstrTitle, ofnA.lpstrTitle);
    GODOT_TO_ACP_STACKALLOC(lpofn->lpstrDefExt, ofnA.lpstrDefExt);

    ofnA.lCustData = lpofn->lCustData;
    ofnA.hwndOwner = lpofn->hwndOwner;
    ofnA.Flags = lpofn->Flags;
    
    if(lpofn->Flags & OFN_ENABLETEMPLATE)
    {
        GODOT_TO_ACP_STACKALLOC(lpofn->lpTemplateName, ofnA.lpTemplateName);
    }

    // Call the 'A' version of the API, then clear the hook
    // if we are in the "Explorer" style FileOpen dlg.  
    if(fOpenFile)
    {
        INIT_WINDOW_SNIFF(lpgti->hHook);
        RetVal=GetOpenFileNameA(&ofnA);
        TERM_WINDOW_SNIFF(lpgti->hHook);
        if(lpofn->Flags & OFN_ENABLEHOOK)
        {
            if(lpofn->Flags & OFN_EXPLORER)
                lpgti->pfnGetOpenFileName = NULL;
            else
                lpgti->pfnGetOpenFileNameOldStyle = NULL;
        }
    }
    else
    {
        INIT_WINDOW_SNIFF(lpgti->hHook);
        RetVal=GetSaveFileNameA(&ofnA);
        TERM_WINDOW_SNIFF(lpgti->hHook);
        if(lpofn->Flags & OFN_ENABLEHOOK)
        {
            if(lpofn->Flags & OFN_EXPLORER)
                lpgti->pfnGetSaveFileName = NULL;
            else
                lpgti->pfnGetSaveFileNameOldStyle = NULL;
        }
    }

    // Begin postcall
    if(RetVal)
    {
        if ((ofnA.lpstrCustomFilter) && (lpofn->lpstrCustomFilter))
        {
            MultiByteToWideChar(g_acp, 0, ofnA.lpstrCustomFilter, ofnA.nMaxCustFilter, lpofn->lpstrCustomFilter, lpofn->nMaxCustFilter);
            lpofn->nFilterIndex = ofnA.nFilterIndex;
        }

        MultiByteToWideChar(g_acp, 0, ofnA.lpstrFile, ofnA.nMaxFile, lpofn->lpstrFile, lpofn->nMaxFile);
        
        if((ofnA.lpstrFileTitle) && (lpofn->lpstrFileTitle))
            MultiByteToWideChar(g_acp, 0, ofnA.lpstrFileTitle, ofnA.nMaxFileTitle, lpofn->lpstrFileTitle, lpofn->nMaxFileTitle);

        lpofn->Flags = ofnA.Flags;

        {
            // nFileOffset and nFileExtension are to provide info about the
            // file name and extension location in lpstrFile, but there is 
            // no reasonable way to get it from the return so we just recalc
            WCHAR drive[_MAX_DRIVE];
            WCHAR dir[_MAX_DIR];
            WCHAR file[_MAX_FNAME];
            gwsplitpath(lpofn->lpstrFile, drive, dir, file, NULL);
            lpofn->nFileOffset = (gwcslen(drive) + gwcslen(dir));
            lpofn->nFileExtension = lpofn->nFileOffset + gwcslen(file);
        }
        
    }
    else if (lpofn->lpstrFile) 
    {
        // There was a file, but there was no room in the buffer.
        // According to the docs, if buffer too small first 2 bytes 
        // are the required size
        memcpy(lpofn->lpstrFile, ofnA.lpstrFile, sizeof(short));
    }

    // Finished
    return RetVal;
}

/*-------------------------------
    FindReplaceTextHelper
    
    Since 95% of the FindText and ReplaceText code is identical,
    we use one shared function for both
-------------------------------*/
HWND FindReplaceTextHelper(LPFINDREPLACEW lpfr, BOOL fFind)
{
    HWND RetVal;
    LPGODOTTLSINFO lpgti;
    LPFINDREPLACEA lpfra;
    BOOL fTemplate = ((lpfr->Flags & FR_ENABLETEMPLATE) && (lpfr->lpTemplateName));
    size_t cchTemplateName = (fTemplate, gwcslen(lpfr->lpTemplateName) , 0);
    LPWSTR lpszBuffer;
    size_t cchBuffer;

    // If we cannot get out TLS info, then we cannot proceed
    if(!(lpgti = GetThreadInfoSafe(TRUE)))
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return(0);
    }

    if((fFind && lpgti->pfnFindText) ||
       (!fFind && lpgti->pfnReplaceText))
    {
        SetLastError(ERROR_INVALID_FILTER_PROC);
        return(0);
    }

    // Easier than copying, casting!
    lpfra = (LPFINDREPLACEA)lpfr;

    // First, get the max temp buffer size and allocate it
    cchBuffer = lpfr->wFindWhatLen ;
    if (!fFind && (lpfr->wReplaceWithLen > cchBuffer))
        cchBuffer = lpfr->wReplaceWithLen;
    if (fTemplate && (cchTemplateName > cchBuffer))
        cchBuffer = cchTemplateName;

    lpszBuffer = GodotHeapAlloc(cchBuffer * g_mcs);
    if(!lpszBuffer)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return(0);
    }

    // Handle the Find string
    gwcscpy(lpszBuffer, lpfr->lpstrFindWhat);
    WideCharToMultiByte(g_acp, 0, 
                        lpfr->lpstrFindWhat, lpfr->wFindWhatLen, 
                        lpfra->lpstrFindWhat, lpfra->wFindWhatLen,
                        NULL, NULL);

    if(!fFind)
    {
        //This is the replace dlg, so handle the replacement
        gwcscpy(lpszBuffer, lpfr->lpstrReplaceWith);
        WideCharToMultiByte(g_acp, 0, 
                            lpfr->lpstrReplaceWith, lpfr->wReplaceWithLen, 
                            lpfra->lpstrReplaceWith, lpfra->wReplaceWithLen,
                            NULL, NULL);
    }
    
    if(fTemplate)
    {
        // They have specified a template, so it must be converted/copied
        gwcscpy(lpszBuffer, lpfr->lpTemplateName);
        WideCharToMultiByte(g_acp, 0, 
                            lpfr->lpTemplateName, cchTemplateName, 
                            (LPSTR)lpfra->lpTemplateName, cchTemplateName * g_mcs,
                            NULL, NULL);
    }

    GodotHeapFree(lpszBuffer);

    // Since we are always setting the hook, the flags must always be munged
    lpfra->Flags |= FR_ENABLEHOOK; 

    // Now, lets set the hook, cache the caller hook if there is
    // one, cache the memory, and call the API. Which vars we use
    // here depend on which API they are calling
    if(fFind)
    {
        if((lpfr->Flags & FR_ENABLEHOOK) && (lpfr->lpfnHook))
            lpgti->pfnFindText = lpfr->lpfnHook;
        lpfra->lpfnHook = &FRHookProcFind;
        lpgti->lpfrwFind = lpfr;
        INIT_WINDOW_SNIFF(lpgti->hHook);
        RetVal=FindTextA(lpfra);
        TERM_WINDOW_SNIFF(lpgti->hHook);
        if(RetVal==0)
            lpgti->lpfrwFind = NULL;
    }
    else
    {
        if((lpfr->Flags & FR_ENABLEHOOK) && (lpfr->lpfnHook))
            lpgti->pfnReplaceText = lpfr->lpfnHook;
        lpfra->lpfnHook = &FRHookProcReplace;
        lpgti->lpfrwReplace = lpfr;
        INIT_WINDOW_SNIFF(lpgti->hHook);
        RetVal=ReplaceTextA(lpfra);
        TERM_WINDOW_SNIFF(lpgti->hHook);
        if(RetVal==0)
            lpgti->lpfrwReplace = NULL;
    }

    // It makes no sense to copy things out since there is nothing they
    // would do with the structure. So don't do anything!
    
    // Finished
    return RetVal;
}

//
//
//
//
//  Stolen from map.c, in the BASE depot
//
//
//
//

#define UNICODE_FFFF              0xFFFF
#define REVERSE_BYTE_ORDER_MARK   0xFFFE
#define BYTE_ORDER_MARK           0xFEFF

#define PARAGRAPH_SEPARATOR       0x2029
#define LINE_SEPARATOR            0x2028

#define UNICODE_TAB               0x0009
#define UNICODE_LF                0x000A
#define UNICODE_CR                0x000D
#define UNICODE_SPACE             0x0020
#define UNICODE_CJK_SPACE         0x3000

#define UNICODE_R_TAB             0x0900
#define UNICODE_R_LF              0x0A00
#define UNICODE_R_CR              0x0D00
#define UNICODE_R_SPACE           0x2000
#define UNICODE_R_CJK_SPACE       0x0030  /* Ambiguous - same as ASCII '0' */

#define ASCII_CRLF                0x0A0D

#define __max(a,b)  (((a) > (b)) ? (a) : (b))
#define __min(a,b)  (((a) < (b)) ? (a) : (b))

BOOL RtlIsTextUnicode(PVOID Buffer, ULONG Size, PULONG Result)
/*++

Routine Description:

    IsTextUnicode performs a series of inexpensive heuristic checks
    on a buffer in order to verify that it contains Unicode data.


    [[ need to fix this section, see at the end ]]

    Found            Return Result

    BOM              TRUE   BOM
    RBOM             FALSE  RBOM
    FFFF             FALSE  Binary
    NULL             FALSE  Binary
    null             TRUE   null bytes
    ASCII_CRLF       FALSE  CRLF
    UNICODE_TAB etc. TRUE   Zero Ext Controls
    UNICODE_TAB_R    FALSE  Reversed Controls
    UNICODE_ZW  etc. TRUE   Unicode specials

    1/3 as little variation in hi-byte as in lo byte: TRUE   Correl
    3/1 or worse   "                                  FALSE  AntiCorrel

Arguments:

    Buffer - pointer to buffer containing text to examine.

    Size - size of buffer in bytes.  At most 256 characters in this will
           be examined.  If the size is less than the size of a unicode
           character, then this function returns FALSE.

    Result - optional pointer to a flag word that contains additional information
             about the reason for the return value.  If specified, this value on
             input is a mask that is used to limit the factors this routine uses
             to make its decision.  On output, this flag word is set to contain
             those flags that were used to make its decision.

Return Value:

    Boolean value that is TRUE if Buffer contains unicode characters.

--*/
{
    UNALIGNED WCHAR *lpBuff = Buffer;
    PUCHAR lpb = Buffer;
    ULONG iBOM = 0;
    ULONG iCR = 0;
    ULONG iLF = 0;
    ULONG iTAB = 0;
    ULONG iSPACE = 0;
    ULONG iCJK_SPACE = 0;
    ULONG iFFFF = 0;
    ULONG iPS = 0;
    ULONG iLS = 0;

    ULONG iRBOM = 0;
    ULONG iR_CR = 0;
    ULONG iR_LF = 0;
    ULONG iR_TAB = 0;
    ULONG iR_SPACE = 0;

    ULONG iNull = 0;
    ULONG iUNULL = 0;
    ULONG iCRLF = 0;
    ULONG iTmp;
    ULONG LastLo = 0;
    ULONG LastHi = 0;
    ULONG iHi = 0;
    ULONG iLo = 0;
    ULONG HiDiff = 0;
    ULONG LoDiff = 0;
    ULONG cLeadByte = 0;
    ULONG cWeird = 0;

    ULONG iResult = 0;

    ULONG iMaxTmp = __min(256, Size / sizeof(WCHAR));

    //
    //  Special case when the size is less than or equal to 2.
    //  Make sure we don't have a character followed by a null byte.
    //
    if ((Size < 2) ||
        ((Size == 2) && (lpBuff[0] != 0) && (lpb[1] == 0)))
    {
        if (Result)
        {
            *Result = IS_TEXT_UNICODE_ASCII16 | IS_TEXT_UNICODE_CONTROLS;
        }

        return (FALSE);
    }
    else if ((Size > 2) && ((Size / sizeof(WCHAR)) <= 256))
    {
        //
        //  If the Size passed in is an even number, we don't want to
        //  use the last WCHAR because it will contain the final null
        //  byte.
        //
        if (((Size % sizeof(WCHAR)) == 0) &&
            ((lpBuff[iMaxTmp - 1] & 0xff00) == 0))
        {
            iMaxTmp--;
        }
    }

    //
    //  Check at most 256 wide characters, collect various statistics.
    //
    for (iTmp = 0; iTmp < iMaxTmp; iTmp++)
    {
        switch (lpBuff[iTmp])
        {
            case BYTE_ORDER_MARK:
                iBOM++;
                break;
            case PARAGRAPH_SEPARATOR:
                iPS++;
                break;
            case LINE_SEPARATOR:
                iLS++;
                break;
            case UNICODE_LF:
                iLF++;
                break;
            case UNICODE_TAB:
                iTAB++;
                break;
            case UNICODE_SPACE:
                iSPACE++;
                break;
            case UNICODE_CJK_SPACE:
                iCJK_SPACE++;
                break;
            case UNICODE_CR:
                iCR++;
                break;

            //
            //  The following codes are expected to show up in
            //  byte reversed files.
            //
            case REVERSE_BYTE_ORDER_MARK:
                iRBOM++;
                break;
            case UNICODE_R_LF:
                iR_LF++;
                break;
            case UNICODE_R_TAB:
                iR_TAB++;
                break;
            case UNICODE_R_CR:
                iR_CR++;
                break;
            case UNICODE_R_SPACE:
                iR_SPACE++;
                break;

            //
            //  The following codes are illegal and should never occur.
            //
            case UNICODE_FFFF:
                iFFFF++;
                break;
            case UNICODE_NULL:
                iUNULL++;
                break;

            //
            //  The following is not currently a Unicode character
            //  but is expected to show up accidentally when reading
            //  in ASCII files which use CRLF on a little endian machine.
            //
            case ASCII_CRLF:
                iCRLF++;
                break;       /* little endian */
        }

        //
        //  Collect statistics on the fluctuations of high bytes
        //  versus low bytes.
        //
        iHi = HIBYTE(lpBuff[iTmp]);
        iLo = LOBYTE(lpBuff[iTmp]);

        //
        //  Count cr/lf and lf/cr that cross two words.
        //
        if ((iLo == '\r' && LastHi == '\n') ||
            (iLo == '\n' && LastHi == '\r'))
        {
            cWeird++;
        }

        iNull += (iHi ? 0 : 1) + (iLo ? 0 : 1);   /* count Null bytes */

        HiDiff += __max(iHi, LastHi) - __min(LastHi, iHi);
        LoDiff += __max(iLo, LastLo) - __min(LastLo, iLo);

        LastLo = iLo;
        LastHi = iHi;
    }

    //
    //  Count cr/lf and lf/cr that cross two words.
    //
    if ((iLo == '\r' && LastHi == '\n') ||
        (iLo == '\n' && LastHi == '\r'))
    {
        cWeird++;
    }

    if (iHi == '\0')     /* don't count the last null */
        iNull--;
    if (iHi == 26)       /* count ^Z at end as weird */
        cWeird++;

/*
    iMaxTmp = __min(256 * sizeof(WCHAR), Size);
    if (g_mcs > 1)
    {
        for (iTmp = 0; iTmp < iMaxTmp; iTmp++)
        {
            if (NlsLeadByteInfo[lpb[iTmp]])
            {
                cLeadByte++;
                iTmp++;         // should check for trailing-byte range
            }
        }
    }
*/
    
    //
    //  Sift through the statistical evidence.
    //
    if (LoDiff < 127 && HiDiff == 0)
    {
        iResult |= IS_TEXT_UNICODE_ASCII16;         /* likely 16-bit ASCII */
    }

    if (HiDiff && LoDiff == 0)
    {
        iResult |= IS_TEXT_UNICODE_REVERSE_ASCII16; /* reverse 16-bit ASCII */
    }

    //
    //  Use leadbyte info to weight statistics.
    //
    if (!(g_mcs > 1) || cLeadByte == 0 ||
        !Result || !(*Result & IS_TEXT_UNICODE_DBCS_LEADBYTE))
    {
        iHi = 3;
    }
    else
    {
        //
        //  A ratio of cLeadByte:cb of 1:2 ==> dbcs
        //  Very crude - should have a nice eq.
        //
        iHi = __min(256, Size / sizeof(WCHAR)) / 2;
        if (cLeadByte < (iHi - 1) / 3)
        {
            iHi = 3;
        }
        else if (cLeadByte < (2 * (iHi - 1)) / 3)
        {
            iHi = 2;
        }
        else
        {
            iHi = 1;
        }
        iResult |= IS_TEXT_UNICODE_DBCS_LEADBYTE;
    }

    if (iHi * HiDiff < LoDiff)
    {
        iResult |= IS_TEXT_UNICODE_STATISTICS;
    }

    if (iHi * LoDiff < HiDiff)
    {
        iResult |= IS_TEXT_UNICODE_REVERSE_STATISTICS;
    }

    //
    //  Any control codes widened to 16 bits? Any Unicode character
    //  which contain one byte in the control code range?
    //
    if (iCR + iLF + iTAB + iSPACE + iCJK_SPACE /*+iPS+iLS*/)
    {
        iResult |= IS_TEXT_UNICODE_CONTROLS;
    }

    if (iR_LF + iR_CR + iR_TAB + iR_SPACE)
    {
        iResult |= IS_TEXT_UNICODE_REVERSE_CONTROLS;
    }

    //
    //  Any characters that are illegal for Unicode?
    //
    if ((iRBOM + iFFFF + iUNULL + iCRLF) != 0 ||
         (cWeird != 0 && cWeird >= iMaxTmp/40))
    {
        iResult |= IS_TEXT_UNICODE_ILLEGAL_CHARS;
    }

    //
    //  Odd buffer length cannot be Unicode.
    //
    if (Size & 1)
    {
        iResult |= IS_TEXT_UNICODE_ODD_LENGTH;
    }

    //
    //  Any NULL bytes? (Illegal in ANSI)
    //
    if (iNull)
    {
        iResult |= IS_TEXT_UNICODE_NULL_BYTES;
    }

    //
    //  POSITIVE evidence, BOM or RBOM used as signature.
    //
    if (*lpBuff == BYTE_ORDER_MARK)
    {
        iResult |= IS_TEXT_UNICODE_SIGNATURE;
    }
    else if (*lpBuff == REVERSE_BYTE_ORDER_MARK)
    {
        iResult |= IS_TEXT_UNICODE_REVERSE_SIGNATURE;
    }

    //
    //  Limit to desired categories if requested.
    //
    if (Result)
    {
        iResult &= *Result;
        *Result = iResult;
    }

    //
    //  There are four separate conclusions:
    //
    //  1: The file APPEARS to be Unicode     AU
    //  2: The file CANNOT be Unicode         CU
    //  3: The file CANNOT be ANSI            CA
    //
    //
    //  This gives the following possible results
    //
    //      CU
    //      +        -
    //
    //      AU       AU
    //      +   -    +   -
    //      --------  --------
    //      CA +| 0   0    2   3
    //      |
    //      -| 1   1    4   5
    //
    //
    //  Note that there are only 6 really different cases, not 8.
    //
    //  0 - This must be a binary file
    //  1 - ANSI file
    //  2 - Unicode file (High probability)
    //  3 - Unicode file (more than 50% chance)
    //  5 - No evidence for Unicode (ANSI is default)
    //
    //  The whole thing is more complicated if we allow the assumption
    //  of reverse polarity input. At this point we have a simplistic
    //  model: some of the reverse Unicode evidence is very strong,
    //  we ignore most weak evidence except statistics. If this kind of
    //  strong evidence is found together with Unicode evidence, it means
    //  its likely NOT Text at all. Furthermore if a REVERSE_BYTE_ORDER_MARK
    //  is found, it precludes normal Unicode. If both byte order marks are
    //  found it's not Unicode.
    //

    //
    //  Unicode signature : uncontested signature outweighs reverse evidence.
    //
    if ((iResult & IS_TEXT_UNICODE_SIGNATURE) &&
        !(iResult & (IS_TEXT_UNICODE_NOT_UNICODE_MASK&(~IS_TEXT_UNICODE_DBCS_LEADBYTE))))
    {
        return (TRUE);
    }

    //
    //  If we have conflicting evidence, it's not Unicode.
    //
    if (iResult & IS_TEXT_UNICODE_REVERSE_MASK)
    {
        return (FALSE);
    }

    //
    //  Statistical and other results (cases 2 and 3).
    //
    if (!(iResult & IS_TEXT_UNICODE_NOT_UNICODE_MASK) &&
         ((iResult & IS_TEXT_UNICODE_NOT_ASCII_MASK) ||
          (iResult & IS_TEXT_UNICODE_UNICODE_MASK)))
    {
        return (TRUE);
    }

    return (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\godot\hook.h ===
/*++

Copyright (c) 2000-2001,  Microsoft Corporation  All rights reserved.

Module Name:

    hook.h

Abstract:

    This file contains the declares for the functions in hook.c that callers will need

Revision History:

    27 Jan 2001    v-michka    Created.

--*/

#ifndef HOOK_H
#define HOOK_H

// Creates the window hook we use for window creation sniffing
#define INIT_WINDOW_SNIFF(h) \
    h = SetWindowsHookExA(WH_CBT, &CBTProc, NULL, GetCurrentThreadId())

// terminates our window hook if it exists
#define TERM_WINDOW_SNIFF(h) \
    if(h) \
    { \
        UnhookWindowsHookEx(h); \
        h = NULL; \
    }
    
// forward declares for hooks that do significant things
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK CBTProc(int nCode, WPARAM wParam, LPARAM lParam);
UINT_PTR CALLBACK FRHookProcFind(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);
UINT_PTR CALLBACK FRHookProcReplace(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);
UINT_PTR CALLBACK OFNHookProc(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);
UINT_PTR CALLBACK OFNHookProcSave(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);

// hooks that are only here for tagging child controls
UINT_PTR CALLBACK CCHookProc(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);
UINT_PTR CALLBACK CFHookProc(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);
UINT_PTR CALLBACK PagePaintHook(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);
UINT_PTR CALLBACK PageSetupHook(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);
UINT_PTR CALLBACK PrintHookProc(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);
UINT_PTR CALLBACK SetupHookProc(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);
UINT_PTR CALLBACK OFNHookProcOldStyle(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);
UINT_PTR CALLBACK OFNHookProcOldStyleSave(HWND hdlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);

// support functions
BOOL IsFontDialog(HWND hdlg);
BOOL IsNewFileOpenDialog(HWND hdlg);
BOOL IsCaptureWindow(HWND hdlg);
void RemoveComdlgPropIfPresent(HWND hdlg);
void SetCaptureWindowProp(HWND hdlg);

#endif // HOOK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\godot\helpapis.h ===
/*++

Copyright (c) 2000-2001,  Microsoft Corporation  All rights reserved.

Module Name:

    helpapis.h

Abstract:

    Header over util.c

    APIs found in this file:

Revision History:

    17 Mar 2001    v-michka    Created.

--*/

#ifndef HELPAPIS_H
#define HELPAPIS_H

// Forward declares


LPCWSTR SP_GetFmtValueW(LPCWSTR lpch, int *lpw);
int SP_PutNumberW(LPWSTR lpstr, ULONG64 n, int limit, DWORD radix, int uppercase);
void SP_ReverseW(LPWSTR lpFirst, LPWSTR lpLast);
DWORD GB18030Helper(DWORD cpg, DWORD dw, LPSTR lpMB, int cchMB, LPWSTR lpWC, int cchWC, LPCPINFO lpCPI);
void CaseHelper(LPWSTR pchBuff, DWORD cch, BOOL fUpper);
int CompareHelper(LPCWSTR lpsz1, LPCWSTR lpsz2, BOOL fCaseSensitive);
BOOL GetOpenSaveFileHelper(LPOPENFILENAMEW lpofn, BOOL fOpenFile);
HWND FindReplaceTextHelper(LPFINDREPLACEW lpfr, BOOL fFindText);
BOOL RtlIsTextUnicode(PVOID Buffer, ULONG Size, PULONG Result);

// These functions are in updres.c
HANDLE BeginUpdateResourceInternalW(LPCWSTR pwch, BOOL bDeleteExistingResources);
BOOL UpdateResourceInternalW(HANDLE hUpdate, LPCWSTR lpType, LPCWSTR lpName, WORD language, LPVOID lpData, ULONG cb);
BOOL EndUpdateResourceInternalW(HANDLE hUpdate, BOOL fDiscard);

#endif // HELPAPIS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\godot\precomp.h ===
/*++

Copyright (c) 2000-2001,  Microsoft Corporation  All rights reserved.

Module Name:

    precomp.h

Abstract:

    Precompiled header file

Revision History:

    1 Mar 2001    v-michka    Created.

--*/

#define SECURITY_WIN32
#include "globals.h"    // project level globals
#include "callback.h"   // enumeration callbacks
#include "threads.h"    // our thread stuff
#include "subclass.h"   // window subclassing support
#include "hook.h"       // all of our hook functions
#include "usermsgs.h"   // user messaging support
#include "util.h"       // utility functions
#include "helpapis.h"   // helper functions for specific APIs in win9xu.c
#include "convert.h"    // functions to convert structs and strings to and from Unicode
#include "crtwrap.h"    // our CRT wrappers
#include "utf.h"        // UTF-7/8 support
#include <windows.h>    // We always need a windows.h
#include <wtypes.h>     // some basic types needed
#include <ras.h>        // for the RAS functions and constants
#include <raserror.h>   // for RAS errors
#include <vfw.h>        // video capture message defines
#include <dbt.h>        // for RegisterDeviceNotification info
#include <ddeml.h>      // for HSZ, etc in DDEML calls.
#include <commctrl.h>   // needed for comctl32 message definitions
#include <shlobj.h>     // various shell defs
#include <sensapi.h>    // that connection validator function
#include <oledlg.h>     // the famous OLEUI dialogs
#include <oleacc.h>     // Accessibility
#include <mmsystem.h>   // multimedia
#include <ntsecapi.h>   // security API return types
#include <security.h>   // Used for security APIs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\godot\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.plt

FULLTARGET=$(_OBJ_DIR)\$(TARGET_DIRECTORY)

# this file is a database created by sortpp.exe after it scans the c-preprocessed  
# version of headers.h.  genthnk.exe consumes it to generate thunks.
PPMFILE=$(FULLTARGET)\winincs.ppm

# list of APIs to actually thunk.  
APILIST=api.lst

# the script to build autogenerated source files for getthnk
BLDFILES=.\bldfiles.pl

# These are the files that are to be generated by BLDFILES
APILISTW=$(FULLTARGET)\unicows.lst
FIXAW=$(FULLTARGET)\fixaw.h
DEFFILE=unicows.def

# name of generated .c files
GENFILE=Win9xU.c
FAILFILE=..\Failure.c
FAILFILEHEADER=..\Failure.h

CXX_COMPILER_NAME=$(CXX_COMPILER_NAME) -noHRESULT -DIN=__in -DOUT=__out
CPP_FLAGS=$(WOW64_CPP_FLAGS) -DSORTPP_PASS -DGUID_DEFINED

$(FULLTARGET)\winincs.pp: winincs.cpp headers.h
     -mkdir $(FULLTARGET)
     $(CXX_COMPILER_NAME) $(WOW64_CPP_FLAGS) /C @<<$(FULLTARGET)\cl.rsp /E /FC winincs.cpp >$(FULLTARGET)\winincs2.pp
$(CXX_COMPILER_FLAGS: =
)
<<NOKEEP
     idlclean.exe $(FULLTARGET)\winincs2.pp $(FULLTARGET)\winincs2.cpp
     $(CXX_COMPILER_NAME) @<<cl.rsp /E /FC $(FULLTARGET)\winincs2.cpp >$(FULLTARGET)\winincs.pp
$(CXX_COMPILER_FLAGS: =
)
<<NOKEEP

$(APILISTW) $(FIXAW) $(DEFFILE) : $(APILIST) $(BLDFILES)
     perl.exe $(BLDFILES) $**

$(PPMFILE): $(FULLTARGET)\winincs.pp
    sortpp.exe $(SORTPP_FLAGS) -m$(PPMFILE) $(FULLTARGET)\winincs.pp

$(GENFILE): $(PPMFILE) unicows.tpl $(APILISTW)
    genthnk.exe -m$(PPMFILE) -tunicows.tpl -c$(GENFILE):UnicodeWrappers -E$(APILISTW)

$(FAILFILE): $(PPMFILE) failure.tpl $(APILISTW)
    genthnk.exe -m$(PPMFILE) -tfailure.tpl -c$(FAILFILE):FailWrappers -E$(APILISTW)

$(FAILFILEHEADER): $(PPMFILE) failure.tpl $(APILISTW)
    genthnk.exe -m$(PPMFILE) -tfailure.tpl -c$(FAILFILEHEADER):FailWrapperHeaders -E$(APILISTW)

thunks: $(PPMFILE) $(FIXAW) $(GENFILE) $(FAILFILE) $(FAILFILEHEADER)

cleanfiles:
    -del $(FAILFILEHEADER)
    -del $(FAILFILE)
    -del $(GENFILE)
    -del $(PPMFILE)
    -del $(APILISTW)
    -del $(FIXAW)
    -del $(DEFFILE)

clean: cleanfiles thunks
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\godot\subclass.c ===
/*++

Copyright (c) 2000-2001,  Microsoft Corporation  All rights reserved.

Module Name:

    subclass.c

Abstract:

    This file contains functions that support our subclassing efforts. Here is how it works: 

    Each window we create must be subclassed so we can maintain the illusion of Unicodality 
    on it. We therefore store a pointer to some memory that contains all of the information 
    we need to properly call the wndproc, stored in a GODOTWND structure. Since the caller
    can actually subclass the window, we need to store a linked list of these structures. 

    NOTE: From comctl32.dll's SUBCLASS.C:

        Win95's property code is BROKEN.  If you SetProp using a text string, USER
        // adds and removes atoms for the property symmetrically, including when the
        // window is destroyed with properties lying around (good).  Unfortunately, if
        // you SetProp using a global atom, USER doesn't do things quite right in the
        // window cleanup case.  It uses the atom without adding references in SetProp
        // calls and without deleting them in RemoveProp calls (good so far).  However,
        // when a window with one of these properties lying around is cleaned up, USER
        // will delete the atom on you.  This tends to break apps that do the
        // following:
        //
        //  - MyAtom = GlobalAddAtom("foo");            // at app startup
        //  - SetProp(SomeWindow, MyAtom, MyData);
        //  - <window gets destroyed, USER deletes atom>
        //  - <time passes>
        //  - SetProp(SomeOtherWindow, MyAtom, MyData); // fails or uses random atom
        //  - GlobalDeleteAtom(MyAtom);                 // fails or deletes random atom

    In order to avoid this bug in the Win9x property code, we do not store this as an atom,
    instead choosing to use an actual string and letting the system do all the work to manage
    the propname. We also wrap all of the property functions, both A and W, to fail the 
    creation, altering, or removal of our one property. This does not solve the problem 
    completely since they can always work outside Godot and wreak havoc, but we cannot solve
    THAT without replacing USER32.DLL on the machine! We still do a call to GlobalAddAtom and 
    just do a lot of aggressive calls to refcount it this way. Slightly slower perf-wise but
    better guarantees!

    In order to make sure that the user does not directly have their wndproc called by the 
    OS (which is not Unicode!), we do not ever directly give them the true wndproc, but
    instead we give them a special pointer. Per RaymondC, addresses with 64k of the 2gb
    boundary (0x7FFF0000 - 0x7FFFFFFF) are always invalid proc addresses, and we need these IDs 
    to be invalid so that someone not going through CallWindowProc will fault right away rather 
    then calling into random memory. The first pointer for each window is always going to be 
    0x7FFFFFFF - 1, and each additional subclass a user adds via SetWindowLong will subtract 
    another number (calculated via CWnd). Since the user never could have more than 64,000 
    subclasses, this should give us plenty of room. Any time we get a call to our CallWindowProc 
    wrapper, we route these "GodotID" values appropriately. 

    Note that we also store DLGPROCs via the same means. No particular GODOTWND will ever have
    both a DLGPROC and a WNDPROC in it, but they will always have unique IDs for each one so
    we need separate GODOTWNDs here. Which one it is can be determined by the fWndproc member.

    When they add a sublass (via SetWindowLong), we add the items to the linked list using a 
    "PUSH" type operation. The most recent subclass is always on top, and the base subclass
    is always on the bottom. 

    If they unsubclass (call SetWindowLong, passing in one of our own GodotID values) in the 
    right order as they are supposed to, we simply use a "POP" type operation on our linked list.
    
    If they unsubclass in the wrong order, we have a little extra work to do. An outstanding 
    caller might still want to call via this (now invalid) godotID! To solve this problem, we 
    do not delete anything in this case but simply NULL out the userLpfn for this GODOTWND. 
    Then any time they are looking to call a godotID with no userLpfn, we simply skip down to 
    the first valid wndproc we can find.

    Sometimes, the wndproc we need to call is expecting ANSI. Perhaps they subclassed via
    SetWindowLongA, or perhaps it is the original wndproc of a system class (so that the actual
    wndproc comes from user32.dll or worse from user.exe!). Therefore we store whether the 
    prop is expecting Unicode or ANSI values.

    Functions found in this file:
        InitWindow
        CleanupWindow
        GetWindowLongInternal
        SetWindowLongInternal
        FauxWndProcOfHwnd
        GetUnicodeWindowProp
        DoesWndprocExpectAnsi
        WndprocFromFauxWndproc
        IsSystemClass
        CWnd

Revision History:

    28 Feb 2001    v-michka    Created.

--*/

#include "precomp.h"

//
// The wnd structure. We store a linked list of these, per window.
// In our most optimal case, this is a list with just one wnd in it.
// WARNING: This structure should be DWORD-aligned!
// WARNING: Do not ever change this structure in a way that would break old clients!!!
//
struct GODOTWND
{
    WNDPROC userLpfn;       // the lpfn to be calling
    UINT godotID;           // the fake pointer we hand to the user
    BYTE fUnicode : 1;      // Is the user lpfn expecting Unicode? All but system wndprocs should
    BYTE fWndproc : 1;      // wndproc or dlgproc in the userLpfn member?
    BYTE bVersion : 8;      // Version of the structure, will be 0 for now.
    ULONG Reserved : 22;    // RESERVED for future use
    struct GODOTWND* next;  // Pointer to the next GODOTWND to chain to
};

// We keep UNICODE and ANSI versions of this string for ease of comparison.
// Since we never support the user mucking with (or even seeing!) these 
// properties, and we do not want to have to convert the string just to 
// support the comparisons that we have to do.
// WARNING: You must keep these two strings in synch!!!
const char m_szMemBlock[] = "GodotMemoryBlock";
const WCHAR m_wzMemBlock[] = L"GodotMemoryBlock";
ATOM m_aMemBlock;

const WCHAR c_wzCaptureClass[] = L"ClsCapWin";
const WCHAR c_wzOleaut32Class[] = L"OLEAUT32";

// our own hack ANSI class
#define ANSIWINDOWCLASS (LPWSTR)0x00000001

// some external forward declares
int __stdcall GodotGetClassNameW(HWND hWnd, LPWSTR lpClassName, int nMaxCount);

// our forward declares
/*BOOL IsAnAnsiClass(LPCWSTR lpszClass);*/
int CWnd(struct GODOTWND* head);

/*-------------------------------
    IsInternalWindowProperty

    // If this is our special wnd prop for the memory
    // handle, return FALSE
-------------------------------*/
BOOL IsInternalWindowProperty(LPCWSTR lpsz, BOOL fUnicode)
{
    if(FSTRING_VALID(lpsz))
    {
        if(fUnicode)
            return(CompareHelper((LPCWSTR)m_wzMemBlock, lpsz, FALSE) == 0);
        else
            return((lstrcmpiA((LPCSTR)m_szMemBlock, (LPCSTR)lpsz) == 0));
    }
    else
        return(MAKEINTATOM(lpsz) == MAKEINTATOM(m_aMemBlock));
}

/*-------------------------------
    InitWindow

    Create the first GODOTWND for the window. Assumes that the lpfn passed 
    in is (in fact) the subclass.

    We use lpszClass to find out whether this is an ANSI or a Unicode window:

    1) If the caller passes ANSIWINDOWCLASS then we are sure it is ANSI
    2) If the caller is being lazy and passes NULL, then we find out the class name
    3) If they pass the class name, we check it

    NOTE: We do not put critical sections here because only the
          creating thread of a window can ever really initialize
          the window with us. Kind of a built-in guard.
-------------------------------*/
BOOL InitWindow(HWND hwnd, LPCWSTR lpszClass)
{
    if(GetPropA(hwnd, m_szMemBlock) != 0)
    {
        // Why get called twice? The only case where this ought
        // to happen is child controls of dialogs that are created
        // by the caller prior to WM_INITDIALOG. We can just skip
        // out in that case.
        return(FALSE);
    }
    else
    {
        BOOL fUnicode = TRUE;
        struct GODOTWND* newWnd;

        if(!FSTRING_VALID(lpszClass))
        {
            // no class name given; lets get it the hard way
            WCHAR * wzClassName[128]; // ATOM max is 255 bytes
            int cchClassName;

            ZeroMemory((LPWSTR)wzClassName, 128);
            cchClassName = GodotGetClassNameW(hwnd, (LPWSTR)wzClassName, 128);
            wzClassName[cchClassName - 1] = 0;

            if(lpszClass == ANSIWINDOWCLASS)
            {
                // This is our hack flag that indicates that the caller
                // is assuring us that this is an ANSI wndproc.
                if(gwcscmp(c_wzOleaut32Class, (LPWSTR)wzClassName) == 0)
                {
                    // The un-subclass-able window
                    return(FALSE);
                }

                fUnicode = FALSE;
            }
            else
            {
                if(gwcscmp(c_wzCaptureClass, (LPWSTR)wzClassName) == 0)
                {
                    // Its a capture window, so lets remember this for all time
                    SetCaptureWindowProp(hwnd);
                }

                fUnicode = TRUE;
            }
        }

        newWnd = GodotHeapAlloc(sizeof(struct GODOTWND));

        if(newWnd)
        {
            newWnd->fWndproc = TRUE;
            newWnd->godotID = ZEORETHGODOTWND - 1;

            // Do the subclass
            newWnd->userLpfn = (WNDPROC)SetWindowLongA(hwnd, GWL_WNDPROC, (LONG)&WindowProc);

            // Is this a Unicode proc? Well, it is if we have
            // not already decided it is an ANSI proc and if
            // the actual proc is in the upper 2gb of virtual
            // mem reserved for the system.
            // CONSIDER: This assumption might suck if a true
            //           system component ever used Godot!
            newWnd->fUnicode = (BYTE)(fUnicode && ((UINT)newWnd->userLpfn < LOWESTSYSMEMLOC));
            newWnd->next = NULL;

            // We have to aggressively refcount our prop to keep anyone from
            // losing it. Thus we do an initial GlobalAddAtom on it and then
            // subsequently call SetPropA on it with the same string.
            if(!m_aMemBlock)
                m_aMemBlock = GlobalAddAtomA(m_szMemBlock);
        
            // Tag the window with the prop that
            // contains our GODOTWND linked list
            if(SetPropA(hwnd, m_szMemBlock, (HANDLE)newWnd))
            {
                return(TRUE);
            }
        }

        // If we make it here, then something crucial failed
        if(newWnd)
            GodotHeapFree(newWnd);
        return(FALSE);
    }
}

/*-------------------------------
    CleanupWindow

    We need to make sure we get rid of all the members of 
    the linked list that we alloc'ed. The window is being
    destroyed.
-------------------------------*/
BOOL CleanupWindow(HWND hwnd)
{
    struct GODOTWND* current;
    struct GODOTWND* next;
    BOOL RetVal;

    __try 
    {
        EnterCriticalSection(&g_csWnds);

        current = GetPropA(hwnd, m_szMemBlock);
    
        while (current != NULL)
        {
            next = current->next;
            GodotHeapFree(current);
            current = next;
        }

        // If this is a common dlg, then the prop must be removed.
        RemoveComdlgPropIfPresent(hwnd);

        // We must do this remove; if not, then we will be causing the
        // prop to be cleaned up by the system and will ruin the other
        // windows out there.
        RetVal = (RemovePropA(hwnd, m_szMemBlock) != NULL);
    }
    __finally 
    {
        LeaveCriticalSection(&g_csWnds);
    }
    
    return(RetVal);
}

/*-------------------------------
    GetWindowLongInternal

    Our own internal version of GetWindowLong, which returns a godotID for both WNDPROC and 
    DLGPROC subclasses. If the window is not one of ours, then we just yield to the actual 
    GetWindowLong. If, however, it is one our windows but we do not have a subclass in place
    (should only be possible for cases such as nIndex==DWL_DLGPROC on non-dialogs) then we
    return 0 and set last error to ERROR_INVALID_INDEX, just like the API would do.
-------------------------------*/
LONG GetWindowLongInternal(HWND hwnd, int nIndex, BOOL fUnicode)
{
    if(nIndex==GWL_WNDPROC || nIndex==DWL_DLGPROC)
    {
        struct GODOTWND* current;
        LONG RetVal = 0;

        __try 
        {
            EnterCriticalSection(&g_csWnds);

            current = GetPropA(hwnd, m_szMemBlock);

            if(current == NULL)
            {
                // No list, so we assume this is not one of our windows
                RetVal = GetWindowLongA(hwnd, nIndex);
            }
            else
            {
                // The top relevant proc must always be valid, so we
                // can just return it. Note that we always return the 
                // GodotID, for both dlgprocs and wndprocs.
                while(current)
                {
                    if(((nIndex==GWL_WNDPROC) && current->fWndproc) ||
                       ((nIndex==DWL_DLGPROC) && !current->fWndproc))
                    {
                        RetVal = (LONG)current->godotID;
                        break;
                    }
                    current = current->next;
                }
            }
        }
        __except( EXCEPTION_EXECUTE_HANDLER ) 
        { 
            RetVal = 0;
        }

        LeaveCriticalSection(&g_csWnds);
        if(RetVal==0)
            SetLastError(ERROR_INVALID_INDEX);

        return(RetVal);
    }
    else
    {
        // No wrapper needed for non-wndproc calls
        return(GetWindowLongA(hwnd, nIndex));
    }
}

/*-------------------------------
    SetWindowLongInternal

    Our own internal version of SetWindowLong, which does the right thing with subclassing both
    WNDPROCs and DLGPROCs. Note that the only time we ever *change* the actual subclass that 
    Windows knows of is when someone subclasses a window that we did not create. Then in the case
    of a SetWindowLongA call we just leave it to the API, or in the SetWindowLongW case we hook
    up the window, starting with an ANSI proc (which is what should be there now). Otherwise, our 
    own wndproc is already in charge and the only thing that we do is shuffle who we plan to 
    call later.
    
    We always return real WNDPROCs when removing a subclass, and godotIDs when adding one.
-------------------------------*/
LONG SetWindowLongInternal(HWND hwnd, int nIndex, LONG dwNewLong, BOOL fUnicode)
{
    if(nIndex==GWL_WNDPROC || nIndex==DWL_DLGPROC)
    {
        struct GODOTWND* head;
        LONG RetVal;
        BOOL fWndproc;      // wndproc or dlgproc?
        DWORD dwProcessId = 0;

        GetWindowThreadProcessId(hwnd, &dwProcessId);
        if(GetCurrentProcessId() != dwProcessId)
        {
            // Not legal to cross the process boundary on a subclass
            SetLastError(ERROR_INVALID_WINDOW_HANDLE);
            return(0);
        }
    
        // No one can muck with wndprocs until we are done here
        EnterCriticalSection(&g_csWnds);

        RetVal = 0;
        fWndproc = (nIndex==GWL_WNDPROC);
        head = GetPropA(hwnd, m_szMemBlock);
    
        if(head == NULL)
        {
            // No list, so assume this is not (yet?) one of our windows.

            // If they called SetWindowLongA then we will yield to the API's wisdom.
            if(!fUnicode)
            {
                RetVal = SetWindowLongA(hwnd, nIndex, dwNewLong);
                LeaveCriticalSection(&g_csWnds);
                return(RetVal);
            }

            // We will now try hook up this ANSI window
            if(!InitWindow(hwnd, ANSIWINDOWCLASS))
            {
                // Window init failed, so we need to fail the subclass.
                SetLastError(ERROR_OUTOFMEMORY);
                LeaveCriticalSection(&g_csWnds);
                return(RetVal);
            }
            else
            {
                // This is a new subclass proc! We will create a Unicode
                // one atop the ANSI one that was just created.
                struct GODOTWND* current = GodotHeapAlloc(sizeof(struct GODOTWND));

                if(current == NULL)
                {
                    // Cannot allocate, so bail.
                    CleanupWindow(hwnd);
                    SetLastError(ERROR_OUTOFMEMORY);
                    LeaveCriticalSection(&g_csWnds);
                    return(RetVal);
                }
                else
                {
                    head = GetPropA(hwnd, m_szMemBlock);

                    // Lets fill up the new structure
                    current->userLpfn = (WNDPROC)dwNewLong;
                    current->fWndproc = (BYTE)fWndproc;
                    current->godotID = ZEORETHGODOTWND - (CWnd(head) + 1);
                    current->fUnicode = (BYTE)fUnicode;
                    current->next = head;
                    SetPropA(hwnd, m_szMemBlock, (HANDLE)current);
                    RetVal = current->next->godotID;
                    LeaveCriticalSection(&g_csWnds);
                    return(RetVal);
                }
            }
        }
        else
        {
            if(INSIDE_GODOT_RANGE(dwNewLong))
            {
                // This is one of our faux windows, so they are unsubclassing.
                struct GODOTWND* current = head;
                struct GODOTWND* next = current->next;

                if((next != NULL) &&
                   (next->godotID == dwNewLong) && 
                   (next->fWndproc == fWndproc))
                {
                    // Must handle the "head" case separately:
                    // basically it's just a pop operation.

                    RetVal = (LONG)current->userLpfn;
                    GodotHeapFree(current);

                    // CONSIDER: If they unsubclassed out of order, then
                    // this next godotID might not be valid. We could
                    // clean up this (next->userLpfn == NULL) case now?
                    SetPropA(hwnd, m_szMemBlock, (HANDLE)next);
                    LeaveCriticalSection(&g_csWnds);
                    return(RetVal);
                }
                
                while(current != NULL)
                {
                    next = current->next;

                    // Make sure there is a "next" wndproc, that it is
                    // both the proc and proctypethat we want
                    if((next != NULL) && 
                       (next->godotID == dwNewLong) && 
                       (next->fWndproc == fWndproc))
                    {
                        // We do not free it up since it is not at the head.
                        // It will be zombied by having a NULL userLpfn.
                        RetVal = (LONG)next->userLpfn;
                        current->userLpfn = NULL;
                        LeaveCriticalSection(&g_csWnds);
                        return(RetVal);
                    }
                    current = current->next;
                }
                
                // We never found it. Let the user know their call failed.
                // Note that this will handle cases we could have detected
                // such as trying to unsubclass the true head, trying to
                // unsubclass a dlgproc with a wndproc nIndex, etc. Since
                // they all get the same error, there was just no need.
                SetLastError(ERROR_INVALID_PARAMETER);
                RetVal = 0;
                LeaveCriticalSection(&g_csWnds);
                return(RetVal);
            }
            else
            {
                // This is a new subclass proc!
                struct GODOTWND* current = GodotHeapAlloc(sizeof(struct GODOTWND));

                if(current == NULL)
                {
                    // Cannot allocate, so bail.
                    SetLastError(ERROR_OUTOFMEMORY);
                    LeaveCriticalSection(&g_csWnds);
                    return(RetVal);
                }
                else
                {
                    // The original subclass window stays the same, we just put the
                    // new info into the linked list. We basically just do a push
                    // on it so it is at the head. The extra SetProp here will keep
                    // us from (hopefully) running into Win9x property bugs.
                    current->userLpfn = (WNDPROC)dwNewLong;
                    current->fWndproc = (BYTE)fWndproc;
                    current->godotID = ZEORETHGODOTWND - (CWnd(head) + 1);
                    current->fUnicode = (BYTE)fUnicode;
                    current->next = head;
                    SetPropA(hwnd, m_szMemBlock, (HANDLE)current);

                    // Ok, make sure we return the right previous proc
                    // based on what type of proc they asked to replace.
                    current = current->next;
                    while(current)
                    {
                        if((fWndproc == current->fWndproc) &&
                           (current->userLpfn))
                        {
                            RetVal = (LONG)current->godotID;
                            break;
                        }
                        current = current->next;
                    }
                    LeaveCriticalSection(&g_csWnds);
                    return(RetVal);
                }
            }
        }
    }
    else
    {
        // Its not even for a wndproc, so we will just ask the OS
        return(SetWindowLongA(hwnd, nIndex, dwNewLong));
    }
}

/*-------------------------------
    GetUnicodeWindowProp

    Returns TRUE if this window has 
    the UNICODE window prop set.
-------------------------------*/
BOOL GetUnicodeWindowProp(HWND hwnd)
{
    struct GODOTWND* current = GetPropA(hwnd, m_szMemBlock);
    return(current != NULL);
}

/*-------------------------------
    DoesProcExpectAnsi

    Returns TRUE if the proc for the window is the one provided 
    by the system by default, or if we marked as ANSI for any other 
    reason. Note that this proc can accept a *real* wndproc rather
    than a GodotID here; we detect either case.
-------------------------------*/
BOOL DoesProcExpectAnsi(HWND hwnd, WNDPROC godotID, FAUXPROCTYPE fpt)
{
    struct GODOTWND* wnd;
    BOOL RetVal = TRUE;

    __try 
    {
        EnterCriticalSection(&g_csWnds);
        wnd = GetPropA(hwnd, m_szMemBlock);
    
        if(wnd==NULL)
        {
            RetVal = TRUE;
        }
        else if(wnd && (godotID == 0))
        {
            while(wnd != NULL)
            {
                // UNDONE: What do we do in the (fpt==fptUnknown && godotID==0) case?
                if(((fpt==fptWndproc && wnd->fWndproc) ||
                   (fpt==fptDlgproc && !wnd->fWndproc)) &&
                   (wnd->userLpfn))
                {
                    RetVal = !wnd->fUnicode;
                    break;
                }
                wnd = wnd->next;
            }
        }
        else
        {
            while(wnd != NULL)
            {
                if(((INSIDE_GODOT_RANGE(godotID)) && (wnd->godotID == (UINT)godotID)) ||
                   ((OUTSIDE_GODOT_RANGE(godotID)) && wnd->userLpfn == godotID))
                {
                    while(wnd != NULL)
                    {
                        if(wnd->userLpfn)
                        {
                            RetVal = !wnd->fUnicode;
                            break;
                        }
                        wnd = wnd->next;
                    }
                    break;
                }
                wnd = wnd->next;
            }
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER ) 
    { 
        RetVal = TRUE;
    }

    LeaveCriticalSection(&g_csWnds);
    return(RetVal);
}

/*-------------------------------
    WndprocFromFauxWndproc

    Given a Godot ID, return a valid wndproc. Returns
    the original faux wndproc if it cannot find a valid 
    real one (probably due to there not being one!). 
-------------------------------*/
WNDPROC WndprocFromFauxWndproc(HWND hwnd, WNDPROC fauxLpfn, FAUXPROCTYPE fpt)
{
    struct GODOTWND* wnd;
    WNDPROC RetVal = fauxLpfn;
    
    __try 
    {
        EnterCriticalSection(&g_csWnds);
        wnd = GetPropA(hwnd, m_szMemBlock);

        if(fauxLpfn == 0)
        {
            // A "0" faux lpfn is a signal to just 
            // pass back the top valid userLpfn. 
            while(wnd != NULL)
            {
                if(((fpt==fptWndproc) && (wnd->fWndproc)) ||
                   ((fpt==fptDlgproc) && (!wnd->fWndproc)))
                {
                    RetVal = wnd->userLpfn;
                    break;
                }
                wnd = wnd->next;
            }
        }
        else if(OUTSIDE_GODOT_RANGE(fauxLpfn))
        {
            // Not a faux wndproc, so we will just return
            // what was passed in, and assume it is valid
        }
        else
        {
            // We iterate through our GODOTWND 
            // linked list, looking for a match.
            while (wnd != NULL)
            {
                if(wnd->godotID == (UINT)fauxLpfn)
                {
                    // Found it!!! Now we have to make sure it 
                    // is still a valid one (i.e. that user has
                    // not unsubclassed out of order!)
                    while ((wnd != NULL) && 
                           (((fpt==fptWndproc) && (wnd->fWndproc)) ||
                           ((fpt==fptDlgproc) && (!wnd->fWndproc))) ||
                           ((fpt==fptUnknown) && (wnd->userLpfn == NULL)))
                        wnd=wnd->next;
                    break;
                }
                wnd = wnd->next;
            }

            // If we do not have a wnd at this point, then there was no
            // likely candidate, so return the caller's faux wndproc.
            // Otherwiwe, pass the one we found.
            if(wnd != NULL)
                RetVal = wnd->userLpfn;
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER ) 
    { 
        RetVal = fauxLpfn;
    }

    LeaveCriticalSection(&g_csWnds);
    return(RetVal);
}

/*-------------------------------
    CWnd
    
    How big is this GODOTWND linked list?
-------------------------------*/
int CWnd(struct GODOTWND* head) 
{
    int count = 0;
    struct GODOTWND* current;
    current = head;

    for (current = head; current != NULL; current = current->next)
    {
        count++;
    }

    return(count);
}

/*
// A little system classes struct
struct ANSICLASS {
    WCHAR * wzName;
};

// These are all the documented system classes. Also, for Toolbar windows, we 
// need to mark the Unicodality as FALSE, since MFC uses the SetWindowText and 
// GetWindowText APIs for its custom draw min-caption-like things for floating 
// toolbars. This is only the low level wndproc which will get this setting,
// so it should not adversely affect anyone.
// The other common controls are added just in case anyone ELSE overloads msgs
// such as window titles for their own purposes the way that MFC decided to do.
// BASE SYSTEM CLASSES are marked with an asterick.
struct ANSICLASS m_rgwzAnsiClasses[] = {
    {L"#32768"},            // *#32768
    {L"#32769"},            // *#32769
    {L"#32770"},            // *#32770
    {L"#32771"},            // *#32771
    {WC_BUTTONW},           // *Button
    {WC_COMBOBOXW},         // *ComboBox
    {WC_COMBOBOXEXW},       // ComboBoxEx32
    {L"ComboLBox"},         // *ComboLBox
    {WC_EDITW},             // *Edit
    {WC_LISTBOXW},          // *ListBox
    {L"MDIClient"},         // *MDIClient
    {STATUSCLASSNAMEW},     // msctls_statusbar32
    {TRACKBAR_CLASSW},      // msctls_trackbar32
    {UPDOWN_CLASSW},        // msctls_updown32
    {PROGRESS_CLASSW},      // msctls_progress32
    {HOTKEY_CLASSW},        // msctls_hotkey32
    {REBARCLASSNAMEW},      // ReBarWindow32
    {WC_SCROLLBARW},        // *ScrollBar
    {WC_STATICW},           // *Static
    {WC_PAGESCROLLERW},     // SysPager
    {WC_IPADDRESSW},        // SysIPAddress32
    {DATETIMEPICK_CLASSW},  // SysDateTimePick32
    {MONTHCAL_CLASSW},      // SysMonthCal32
    {ANIMATE_CLASSW},       // SysAnimate32
    {WC_HEADERW},           // SysHeader32
    {WC_LISTVIEWW},         // SysListView32
    {WC_TREEVIEWW},         // SysTreeView32
    {WC_TABCONTROLW},       // SysTabControl32
    {TOOLBARCLASSNAMEW},    // ToolbarWindow32
    {TOOLTIPS_CLASSW},      // tooltips_class32
    {NULL}
};

//-------------------------------
//    IsAnAnsiClass
//
//    Returns TRUE if the class is a "system" class (which has
//    a default wndproc). Also returns TRUE for other classes
//    which need to be marked as "ANSI".
---------------------------------
BOOL IsAnAnsiClass(LPCWSTR lpwz)
{
    if(FSTRING_VALID(lpwz))
    {
        // PERF: We optimize by making sure that the first character matches
        //       one of the known system classes. Be sure to add the case
        //       here if you add any classes to m_rgwzAnsiClasses!
        switch(*lpwz)
            case '#':
            case 'B':
            case 'b':
            case 'C':
            case 'c':
            case 'E':
            case 'e':
            case 'L':
            case 'l':
            case 'M':
            case 'm':
            case 'R':
            case 'S':
            case 's':
            case 'T':
            case 't':
        {
        int iClass = 0;

        while(m_rgwzAnsiClasses[iClass].wzName)
        {
            if(CompareHelper(lpwz, (LPWSTR)(m_rgwzAnsiClasses[iClass].wzName), FALSE) == 0)
            {
                return(TRUE);
            }
            iClass++;
        }
        break;
        }
    }
    return(FALSE);
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\godot\subclass.h ===
/*++

Copyright (c) 2000-2001,  Microsoft Corporation  All rights reserved.

Module Name:

    subclass.h

Abstract:

    Header file for subclass.c

Revision History:

    28 Feb 2001    v-michka    Created.

UNDONE: "A" functions to consider wrapping??? We already have templates for them.
EnumPropsA
EnumPropsExA
GetPropA
GetWindowLongA
RemovePropA
SetPropA
SetWindowLongA

--*/

#ifndef SUBCLASS_H
#define SUBCLASS_H

CRITICAL_SECTION g_csWnds;   // our critical section object for window data (use sparingly!)

// All GodotIDs are the subclass procs on top of the 
// window. There will always be at least one of these 
// for every window we create.
#define ZEORETHGODOTWND 0x7FFFFFFF
#define LASTGODOTWND    0x7FFF0000

#define INSIDE_GODOT_RANGE(x) (((UINT)x > LASTGODOTWND) && ((UINT)x < ZEORETHGODOTWND))
#define OUTSIDE_GODOT_RANGE(x) (!INSIDE_GODOT_RANGE(x))

// In order to determine if an lpfn is ANSI or not, we look at the lpfn
// and assume that anything in the system area is ANSI on Win9x.
// CONSIDER: If a system component ever picks us up, this brilliant move
//           in the name of performance will no longer be such a good idea.
#define LOWESTSYSMEMLOC 0x80000000

// Forward declares
BOOL IsInternalWindowProperty(LPCWSTR lpsz, BOOL fUnicode);
BOOL InitWindow(HWND hwnd, LPCWSTR lpszClass);
BOOL GetUnicodeWindowProp(HWND hwnd);
BOOL CleanupWindow(HWND hwnd);
LONG GetWindowLongInternal(HWND hwnd, int nIndex, BOOL fUnicode);
LONG SetWindowLongInternal(HWND hwnd, int nIndex, LONG dwNewLong, BOOL fUnicode);
BOOL DoesProcExpectAnsi(HWND hwnd, WNDPROC godotID, FAUXPROCTYPE fpt);
WNDPROC WndprocFromFauxWndproc(HWND hwnd, WNDPROC fauxLpfn, FAUXPROCTYPE fpt);

#endif // SUBCLASS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\godot\threads.h ===
/*++

Copyright (c) 2000-2001,  Microsoft Corporation  All rights reserved.

Module Name:

    threads.h

Abstract:

    Header file for threads.c

Revision History:

    01 Mar 2001    v-michka    Created.

--*/

#ifndef THREADS_H
#define THREADS_H

UINT g_tls;                     // GODOT TLS slot - lots of thread-specific info here
CRITICAL_SECTION g_csThreads;   // Our critical section object for thread data (use sparingly!)

// Thread stuff
LPGODOTTLSINFO GetThreadInfoSafe(BOOL fAllocate);
void UninitThread(void);
void UninitAllThreads(void);

#endif // THREADS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\godot\threads.c ===
/*++

Copyright (c) 2000-2001,  Microsoft Corporation  All rights reserved.

Module Name:

    threads.c

Abstract:

    This file contains functions that support our threading efforts

    Functions found in this file:
        GetThreadInfoSafe
        UninitThread

Revision History:

    01 Mar 2001    v-michka    Created.

--*/

#include "precomp.h"

//
// The MEM structure. We store a linked list of these. In our
// most optimal case, this is a list with just one MEM in it.
//
struct MEM 
{
    LPGODOTTLSINFO alloc;   // the allocation to store
    struct MEM* next;       // Pointer to the next MEM to chain to
};

struct MEM* m_memHead;


/*-------------------------------
    GetThreadInfoSafe

    Returns our TLS info, and if it has never been gotten, 
    allocates it (if the caller specifies) and returns the 
    newly allocated info.
-------------------------------*/
LPGODOTTLSINFO GetThreadInfoSafe(BOOL fAllocate)
{
    LPGODOTTLSINFO lpgti = NULL;
    DWORD dwLastError = ERROR_SUCCESS;

    // Use SEH around our critical section since low memory 
    // situations can cause a STATUS_INVALID_HANDLE exception
    // to be raise. We will simply set the last error for this 
    // case so the client can always know why we failed
    // CONSIDER: Use ERROR_LOCK_FAILED or ERROR_LOCKED here?
    __try
    {
        EnterCriticalSection(&g_csThreads);
    
        lpgti = TlsGetValue(g_tls);
        dwLastError = GetLastError();

        if(!lpgti)
        {
            if(fAllocate)
            {
                struct MEM* newThreadMem;
                
                lpgti = GodotHeapAlloc(sizeof(GODOTTLSINFO));
                if(!lpgti)
                    dwLastError = ERROR_OUTOFMEMORY;
                else
                {
                    // First lets add the block to our 
                    // handy linked list of allocations.
                    if(newThreadMem = GodotHeapAlloc(sizeof(struct MEM)))
                    {
                        newThreadMem->alloc = lpgti;
                        newThreadMem->next = m_memHead;
                        m_memHead = newThreadMem;

                        // Now lets store it in the TLS slot.
                        dwLastError = GetLastError();
                        TlsSetValue(g_tls, lpgti);
                    }
                    else
                        dwLastError = ERROR_OUTOFMEMORY;

                    if(dwLastError != ERROR_SUCCESS)
                    {
                        // we failed somehow, so clean it all up
                        GodotHeapFree(lpgti);
                        m_memHead = m_memHead->next;
                        GodotHeapFree(newThreadMem);
                        lpgti = NULL;
                    }
                }
             }
            else
                dwLastError=ERROR_OUTOFMEMORY;

        }
    }

    __finally
    {
        LeaveCriticalSection(&g_csThreads);
    }

    if(lpgti == NULL)
    {
        SetLastError(dwLastError);
        return(NULL);
    }
    return(lpgti);
}


/*-------------------------------
    UninitThread
-------------------------------*/
void UninitThread(void)
{
    LPGODOTTLSINFO lpgti;

    if(g_tls)
    {
        // don't alloc if its not there!
        lpgti = GetThreadInfoSafe(FALSE);

        // Use SEH around our critical section since low memory 
        // situations can cause a STATUS_INVALID_HANDLE exception
        // to be raise. Note that if we fail to enter our CS that
        // missing out on this alloc is the least of our problems.
        // We will get a second chance at process close to free 
        // it up, if we ever get there.
        __try
        {
            EnterCriticalSection(&g_csThreads);
            if(lpgti)
            {
                struct MEM* current = m_memHead;
            
                // Clean up that ol' heap allocated memory
                GodotHeapFree(lpgti);

                while(current != NULL)
                {
                    if(current->alloc == lpgti)
                    {
                        // Must handle the head case separately
                        m_memHead = current->next;
                        current->alloc = NULL;
                        GodotHeapFree(current);
                        break;
                    }
                
                    if((current->next != NULL) && (current->next->alloc == lpgti))
                    {
                        // The next one in line is the 
                        // one we want to free up
                        current->next = current->next->next;
                        current->next->alloc = NULL;
                        GodotHeapFree(current->next);
                        break;
                    }

                    current = current->next;
                }
            
                TlsSetValue(g_tls, NULL);
            }
        }
        __finally
        {
            LeaveCriticalSection(&g_csThreads);
        }
    }

    return;
}

/*-------------------------------
    UninitAllThreads

    Deletes our entire linked list of allocations. Note that we
    can only call TlsSetValue on the current thread, not others.
    However, this function will invalidate any pointers in other
    threads so this function should NEVER be called until process
    close.
-------------------------------*/
void UninitAllThreads(void)
{
    struct MEM* current;
    struct MEM* next;

    __try
    {
        EnterCriticalSection(&g_csThreads);
        current = m_memHead;

        while (current != NULL)
        {
            next = current->next;
            GodotHeapFree(current->alloc);
            GodotHeapFree(current);
            current = next;
        }
        m_memHead = NULL;
    }
    __finally
    {
        LeaveCriticalSection(&g_csThreads);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\godot\updres.c ===
/******************************************************************************

    PROGRAM: updres.c

    PURPOSE: Contains API Entry points and routines for updating resource
        sections in exe/dll

    FUNCTIONS:

    EndUpdateResource(HANDLE, BOOL)         - end update, write changes
    UpdateResource(HANDLE, LPSTR, LPSTR, WORD, PVOID)
                        - update individual resource
    BeginUpdateResource(LPSTR)              - begin update

*******************************************************************************/


#include "precomp.h"
#include "updres.h"

#define cbPadMax    16L
char *pchPad = "PADDINGXXPADDING";
char *pchZero = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";


/****************************************************************************
**
** API entry points
**
****************************************************************************/


HANDLE BeginUpdateResourceInternalW(LPCWSTR pwch, BOOL bDeleteExistingResources)

/*++
    Routine Description
        Begins an update of resources.  Save away the name
        and current resources in a list, using EnumResourceXxx
        api set.

    Parameters:

        lpFileName - Supplies the name of the executable file that the
        resource specified by lpType/lpName/language will be updated
        in.  This file must be able to be opened for writing (ie, not
        currently executing, etc.)  The file may be fully qualified,
        or if not, the current directory is assumed.  It must be a
        valid Windows executable file.

        bDeleteExistingResources - if TRUE, existing resources are
        deleted, and only new resources will appear in the result.
        Otherwise, all resources in the input file will be in the
        output file unless specifically deleted or replaced.

    Return Value:

    NULL - The file specified was not able to be opened for writing.
    Either it was not an executable image, the executable image is
    already loaded, or the filename did not exist.  More information may
    be available via GetLastError api.

    HANDLE - A handle to be passed to the UpdateResource and
    EndUpdateResources function.
--*/

{
    HMODULE     hModule;
    PUPDATEDATA pUpdate;
    HANDLE      hUpdate;
    LPWSTR      pFileName;
    DWORD       attr;

    SetLastError(NO_ERROR);
    if (pwch == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    hUpdate = GlobalAlloc(GHND, sizeof(UPDATEDATA));
    if (hUpdate == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }
    pUpdate = (PUPDATEDATA)GlobalLock(hUpdate);
    if (pUpdate == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    pUpdate->Status = NO_ERROR;
    pUpdate->hFileName = GlobalAlloc(GHND, (gwcslen(pwch)+1)*sizeof(WCHAR));
    if (pUpdate->hFileName == NULL)
    {
        GlobalUnlock(hUpdate);
        GlobalFree(hUpdate);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }
    pFileName = (LPWSTR)GlobalLock(pUpdate->hFileName);
    if (pFileName == NULL)
    {
        GlobalUnlock(hUpdate);
        GlobalFree(hUpdate);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }
    gwcscpy(pFileName, pwch);
    GlobalUnlock(pUpdate->hFileName);

    attr = GetFileAttributesW(pFileName);
    if (attr == 0xffffffff)
    {
        GlobalUnlock(hUpdate);
        GlobalFree(hUpdate);
        return NULL;
    }
    else if (attr & (FILE_ATTRIBUTE_READONLY |
                     FILE_ATTRIBUTE_SYSTEM |
                     FILE_ATTRIBUTE_HIDDEN |
                     FILE_ATTRIBUTE_DIRECTORY))
    {
        GlobalUnlock(hUpdate);
        GlobalFree(hUpdate);
        SetLastError(ERROR_WRITE_PROTECT);
        return NULL;
    }

    if (!bDeleteExistingResources)
    {
        hModule = LoadLibraryExW(pwch, NULL,LOAD_LIBRARY_AS_DATAFILE| DONT_RESOLVE_DLL_REFERENCES);
        if (hModule == NULL)
        {
            GlobalUnlock(hUpdate);
            GlobalFree(hUpdate);
            if (GetLastError() == NO_ERROR)
                SetLastError(ERROR_BAD_EXE_FORMAT);
            return NULL;
        }
        else
            EnumResourceTypesW(hModule, (ENUMRESTYPEPROCW)EnumTypesFunc, (LONG)pUpdate);
        FreeLibrary(hModule);
    }

    if (pUpdate->Status != NO_ERROR)
    {
        GlobalUnlock(hUpdate);
        GlobalFree(hUpdate);
        // return code set by enum functions
        return NULL;
    }
    GlobalUnlock(hUpdate);
    return hUpdate;
}

BOOL UpdateResourceInternalW(HANDLE hUpdate, LPCWSTR lpType, LPCWSTR lpName, 
                             WORD language, LPVOID lpData, ULONG cb)

/*++
    Routine Description
        This routine adds, deletes or modifies the input resource
        in the list initialized by BeginUpdateResource.  The modify
        case is simple, the add is easy, the delete is hard.
        The ASCII entry point converts inputs to UNICODE.

    Parameters:

        hUpdateFile - The handle returned by the BeginUpdateResources
        function.

        lpType - Points to a null-terminated character string that
        represents the type name of the resource to be updated or
        added.  May be an integer value passed to MAKEINTRESOURCE
        macro.  For predefined resource types, the lpType parameter
        should be one of the following values:

          RT_ACCELERATOR - Accelerator table
          RT_BITMAP - Bitmap resource
          RT_DIALOG - Dialog box
          RT_FONT - Font resource
          RT_FONTDIR - Font directory resource
          RT_MENU - Menu resource
          RT_RCDATA - User-defined resource (raw data)
          RT_VERSION - Version resource
          RT_ICON - Icon resource
          RT_CURSOR - Cursor resource



        lpName - Points to a null-terminated character string that
        represents the name of the resource to be updated or added.
        May be an integer value passed to MAKEINTRESOURCE macro.

        language - Is the word value that specifies the language of the
        resource to be updated.  A complete list of values is
        available in winnls.h.

        lpData - A pointer to the raw data to be inserted into the
        executable image's resource table and data.  If the data is
        one of the predefined types, it must be valid and properly
        aligned.  If lpData is NULL, the specified resource is to be
        deleted from the executable image.

        cb - count of bytes in the data.

    Return Value:

    TRUE - The resource specified was successfully replaced in, or added
    to, the specified executable image.

    FALSE/NULL - The resource specified was not successfully added to or
    updated in the executable image.  More information may be available
    via GetLastError api.
--*/
{
    PUPDATEDATA pUpdate;
    PSDATA      Type;
    PSDATA      Name;
    PVOID       lpCopy;
    LONG        fRet;

    SetLastError(0);
    pUpdate = (PUPDATEDATA)GlobalLock(hUpdate);
    Name = AddStringOrID(lpName, pUpdate);
    if (Name == NULL)
    {
        pUpdate->Status = ERROR_NOT_ENOUGH_MEMORY;
        GlobalUnlock(hUpdate);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    Type = AddStringOrID(lpType, pUpdate);
    if (Type == NULL)
    {
        pUpdate->Status = ERROR_NOT_ENOUGH_MEMORY;
        GlobalUnlock(hUpdate);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    if (cb == 0)
    {
        lpCopy = NULL;
    }
    else
    {
        lpCopy = GodotHeapAlloc(cb);
        if (lpCopy == NULL)
        {
            pUpdate->Status = ERROR_NOT_ENOUGH_MEMORY;
            GlobalUnlock(hUpdate);
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
        RtlCopyMemory(lpCopy, lpData, cb);
    }
    fRet = AddResource(Type, Name, language, pUpdate, lpCopy, cb);
    GlobalUnlock(hUpdate);
    if (fRet == NO_ERROR)
        return TRUE;
    else
    {
        SetLastError(fRet);
        if (lpData != NULL)
            GodotHeapFree(lpData);
        return FALSE;
    }
}

/*++
    Routine Description
        Finishes the UpdateResource action.  Copies the
        input file to a temporary, adds the resources left
        in the list (hUpdate) to the exe.

    Parameters:

        hUpdateFile - The handle returned by the BeginUpdateResources
        function.

        fDiscard - If TRUE, discards all the updates, frees all memory.

    Return Value:

    FALSE - The file specified was not able to be written.  More
    information may be available via GetLastError api.

    TRUE -  The accumulated resources specified by UpdateResource calls
    were written to the executable file specified by the hUpdateFile
    handle.
--*/
BOOL EndUpdateResourceInternalW(HANDLE hUpdate, BOOL fDiscard)
{
    LPWSTR      pFileName;
    PUPDATEDATA pUpdate;
    WCHAR       pTempFileName[MAX_PATH];
    INT         cch;
    LPWSTR      p;
    LONG        rc;
    DWORD       LastError = 0;

    SetLastError(0);
    pUpdate = (PUPDATEDATA)GlobalLock(hUpdate);
    if (fDiscard)
    {
        rc = NO_ERROR;
    }
    else
    {
        pFileName = (LPWSTR)GlobalLock(pUpdate->hFileName);
        gwcscpy(pTempFileName, pFileName);
        cch = gwcslen(pTempFileName);
        p = pTempFileName + cch;
        while (*p != L'\\' && p >= pTempFileName)
            p--;
        *(p+1) = 0;
        rc = GetTempFileNameW(pTempFileName, L"RCX", 0, pTempFileName);
        if (rc == 0)
        {
            rc = GetTempPathW(MAX_PATH, pTempFileName);
            if (rc == 0)
            {
                pTempFileName[0] = L'.';
                pTempFileName[1] = L'\\';
                pTempFileName[2] = 0;
            }
            rc = GetTempFileNameW(pTempFileName, L"RCX", 0, pTempFileName);
            if (rc == 0)
            {
                rc = GetLastError();
            }
            else
            {
                rc = WriteResFile(hUpdate, pTempFileName);
                if (rc == NO_ERROR)
                {
                    DeleteFileW(pFileName);
                    MoveFileW(pTempFileName, pFileName);
                }
                else
                {
                    LastError = rc;
                    DeleteFileW(pTempFileName);
                }
            }
        }
        else
        {
            rc = WriteResFile(hUpdate, pTempFileName);
            if (rc == NO_ERROR)
            {
                DeleteFileW(pFileName);
                MoveFileW(pTempFileName, pFileName);
            }
            else
            {
                LastError = rc;
                DeleteFileW(pTempFileName);
            }
        }
        GlobalUnlock(pUpdate->hFileName);
        GlobalFree(pUpdate->hFileName);
    }

    FreeData(pUpdate);
    GlobalUnlock(hUpdate);
    GlobalFree(hUpdate);
    SetLastError(LastError);
    return(rc ? FALSE : TRUE);
}


/**********************************************************************
**
**  End of API entry points.
**
**  Beginning of private entry points for worker routines to do the
**  real work.
**
***********************************************************************/


BOOL EnumTypesFunc(HANDLE hModule, LPWSTR lpType, LONG lParam)
{
    EnumResourceNamesW(hModule, lpType, (ENUMRESNAMEPROCW)EnumNamesFunc, lParam);
    return TRUE;
}

BOOL EnumNamesFunc(HANDLE hModule, LPWSTR lpType, LPWSTR lpName, LONG lParam)
{
    EnumResourceLanguagesW(hModule, lpType, lpName, (ENUMRESLANGPROCW)EnumLangsFunc, lParam);
    return TRUE;
}

BOOL EnumLangsFunc(HANDLE hModule, LPWSTR lpType, LPWSTR lpName, WORD language, LONG lParam)
{
    HANDLE      hResInfo;
    LONG        fError;
    PSDATA      Type;
    PSDATA      Name;
    ULONG       cb;
    PVOID       lpData;
    HANDLE      hResource;
    PVOID       lpResource;

    hResInfo = FindResourceExW(hModule, lpType, lpName, language);
    if (hResInfo == NULL)
    {
        return FALSE;
    }
    else
    {
        Type = AddStringOrID(lpType, (PUPDATEDATA)lParam);
        if (Type == NULL)
        {
            ((PUPDATEDATA)lParam)->Status = ERROR_NOT_ENOUGH_MEMORY;
            return FALSE;
        }
        Name = AddStringOrID(lpName, (PUPDATEDATA)lParam);
        if (Name == NULL) 
        {
            ((PUPDATEDATA)lParam)->Status = ERROR_NOT_ENOUGH_MEMORY;
            return FALSE;
        }

        cb = SizeofResource(hModule, hResInfo);
        if (cb == 0)
        {
            return FALSE;
        }
        lpData = GodotHeapAlloc(cb);
        if (lpData == NULL)
        {
            return FALSE;
        }
        RtlZeroMemory(lpData, cb);

        hResource = LoadResource(hModule, hResInfo);
        if (hResource == NULL)
        {
            GodotHeapFree(lpData);
            return FALSE;
        }

        lpResource = (PVOID)LockResource(hResource);
        if (lpResource == NULL)
        {
            GodotHeapFree(lpData);
            return FALSE;
        }

        RtlCopyMemory(lpData, lpResource, cb);
        (VOID)UnlockResource(hResource);
        (VOID)FreeResource(hResource);

        fError = AddResource(Type, Name, language, (PUPDATEDATA)lParam, lpData, cb);
        if (fError != NO_ERROR)
        {
            ((PUPDATEDATA)lParam)->Status = ERROR_NOT_ENOUGH_MEMORY;
            return FALSE;
        }
    }

    return TRUE;
}

VOID FreeOne(PRESNAME pRes)
{
    GodotHeapFree((PVOID)pRes->OffsetToDataEntry);
    if (IS_ID == pRes->Name->discriminant)
    {
        GodotHeapFree((PVOID)pRes->Name);
    }
    if (IS_ID == pRes->Type->discriminant)
    {
        GodotHeapFree((PVOID)pRes->Type);
    }
    GodotHeapFree((PVOID)pRes);
}


VOID FreeData(PUPDATEDATA pUpd)
{
    PRESTYPE    pType;
    PRESNAME    pRes;
    PSDATA      pstring, pStringTmp;

    for (pType=pUpd->ResTypeHeadID ; pUpd->ResTypeHeadID ; pType=pUpd->ResTypeHeadID)
    {
        pUpd->ResTypeHeadID = pUpd->ResTypeHeadID->pnext;

        for (pRes=pType->NameHeadID ; pType->NameHeadID ; pRes=pType->NameHeadID )
        {
            pType->NameHeadID = pType->NameHeadID->pnext;
            FreeOne(pRes);
        }

        for (pRes=pType->NameHeadName ; pType->NameHeadName ; pRes=pType->NameHeadName ) 
        {
            pType->NameHeadName = pType->NameHeadName->pnext;
            FreeOne(pRes);
        }

        GodotHeapFree((PVOID)pType);
    }

    for (pType=pUpd->ResTypeHeadName ; pUpd->ResTypeHeadName ; pType=pUpd->ResTypeHeadName) 
    {
        pUpd->ResTypeHeadName = pUpd->ResTypeHeadName->pnext;

        for (pRes=pType->NameHeadID ; pType->NameHeadID ; pRes=pType->NameHeadID ) 
        {
            pType->NameHeadID = pType->NameHeadID->pnext;
            FreeOne(pRes);
        }

        for (pRes=pType->NameHeadName ; pType->NameHeadName ; pRes=pType->NameHeadName )
        {
            pType->NameHeadName = pType->NameHeadName->pnext;
            FreeOne(pRes);
        }

        GodotHeapFree((PVOID)pType);
    }

    pstring = pUpd->StringHead;
    while (pstring != NULL)
    {
        pStringTmp = pstring->uu.ss.pnext;
        if (pstring->discriminant == IS_STRING)
            GodotHeapFree((PVOID)pstring->szStr);
        GodotHeapFree((PVOID)pstring);
        pstring = pStringTmp;
    }

    return;
}


/*+++

    Routines to register strings

---*/

//
//  Resources are DWORD aligned and may be in any order.
//

#define TABLE_ALIGN  4
#define DATA_ALIGN  4L



PSDATA AddStringOrID(LPCWSTR lp, PUPDATEDATA pupd)
{
    USHORT cb;
    PSDATA pstring;
    PPSDATA ppstring;

    if (((ULONG)lp & 0xFFFF0000) == 0)
    {
        //
        // an ID
        //
        pstring = (PSDATA)GodotHeapAlloc(sizeof(SDATA));
        if (pstring == NULL)
            return NULL;
        RtlZeroMemory((PVOID)pstring, sizeof(SDATA));
        pstring->discriminant = IS_ID;

        pstring->uu.Ordinal = (WORD)((ULONG)lp & 0x0000ffff);
    }
    else
    {
        //
        // a string
        //
        cb = gwcslen(lp) + 1;
        ppstring = &pupd->StringHead;

        while ((pstring = *ppstring) != NULL)
        {
            if (!gwcsncmp(pstring->szStr, lp, cb))
                break;
            ppstring = &(pstring->uu.ss.pnext);
        }

        if (!pstring)
        {

            //
            // allocate a new one
            //
            pstring = (PSDATA)GodotHeapAlloc(sizeof(SDATA));
            if (pstring == NULL)
                return NULL;
            RtlZeroMemory((PVOID)pstring, sizeof(SDATA));

            pstring->szStr = (WCHAR*)GodotHeapAlloc(cb*sizeof(WCHAR));
            if (pstring->szStr == NULL)
            {
                GodotHeapFree((PVOID)pstring);
                return NULL;
            }
            pstring->discriminant = IS_STRING;
            pstring->OffsetToString = pupd->cbStringTable;

            pstring->cbData = sizeof(pstring->cbsz) + cb * sizeof(WCHAR);
            pstring->cbsz = cb - 1;     /* don't include zero terminator */
            RtlCopyMemory(pstring->szStr, lp, cb*sizeof(WCHAR));

            pupd->cbStringTable += pstring->cbData;

            pstring->uu.ss.pnext=NULL;
            *ppstring=pstring;
        }
    }

    return(pstring);
}

LONG AddResource(IN PSDATA Type, IN PSDATA Name, IN WORD Language,
                 IN PUPDATEDATA pupd, IN PVOID lpData, IN ULONG cb)
//
// add a resource into the resource directory hiearchy
//
{
    PRESTYPE  pType;
    PPRESTYPE ppType;
    PRESNAME  pName;
    PRESNAME  pNameM;
    PPRESNAME ppName = NULL;
    BOOL fTypeID=(Type->discriminant == IS_ID);
    BOOL fNameID=(Name->discriminant == IS_ID);
    BOOL fSame=FALSE;

    //
    // figure out which list to store it in
    //

    ppType = fTypeID ? &pupd->ResTypeHeadID : &pupd->ResTypeHeadName;

    //
    // Try to find the Type in the list
    //

    while ((pType=*ppType) != NULL)
    {
        if (pType->Type->uu.Ordinal == Type->uu.Ordinal)
        {
            ppName = fNameID ? &pType->NameHeadID : &pType->NameHeadName;
            break;
        }
        if (fTypeID)
        {
            if (Type->uu.Ordinal < pType->Type->uu.Ordinal)
                break;
        }
        else
        {
            if (gwcsncmp(Type->szStr, pType->Type->szStr, Type->cbsz) < 0)
                break;
        }
        ppType = &(pType->pnext);
    }

    //
    // Create a new type if needed
    //

    if (ppName == NULL)
    {
        pType = (PRESTYPE)GodotHeapAlloc(sizeof(RESTYPE));
        if (pType == NULL)
            return ERROR_NOT_ENOUGH_MEMORY;
        RtlZeroMemory((PVOID)pType, sizeof(RESTYPE));
        pType->pnext = *ppType;
        *ppType = pType;
        pType->Type = Type;
        ppName = fNameID ? &pType->NameHeadID : &pType->NameHeadName;
    }

    //
    // Find proper place for name
    //

    while ( (pName = *ppName) != NULL)
    {
        if (fNameID)
        {
            if (Name->uu.Ordinal == pName->Name->uu.Ordinal)
            {
                fSame = TRUE;
                break;
            }
            if (Name->uu.Ordinal < pName->Name->uu.Ordinal)
                break;
        }
        else
        {
            if (gwcsncmp(Name->szStr, pName->Name->szStr, Name->cbsz) == 0)
            {
                fSame = TRUE;
                break;
            }
            if (gwcsncmp(Name->szStr, pName->Name->szStr, Name->cbsz) < 0)
                break;
        }
        ppName = &(pName->pnext);
    }

    //
    // check for delete/modify
    //

    if (fSame) /* same name, new language */
    {
        if (pName->NumberOfLanguages == 1) /* one language currently ? */
        {
            if (Language == pName->LanguageId) /* REPLACE || DELETE */
            {
                pName->DataSize = cb;
                if (lpData == NULL) /* DELETE */
                {
                    return DeleteResourceFromList(pupd, pType, pName, Language, fTypeID, fNameID);
                }
                GodotHeapFree((PVOID)pName->OffsetToDataEntry);
                if (IS_ID == Type->discriminant)
                {
                    GodotHeapFree((PVOID)Type);
                }
                if (IS_ID == Name->discriminant)
                {
                    GodotHeapFree((PVOID)Name);
                }
                (PVOID)pName->OffsetToDataEntry = lpData;
                return NO_ERROR;
            }
            else
            {
                if (lpData == NULL) /* no data but new? */
                {
                    return ERROR_INVALID_PARAMETER;     /* badness */
                }
                return InsertResourceIntoLangList(pupd, Type, Name, pType, pName, 
                                                  Language, fNameID, cb, lpData);
            }
        }
        else /* many languages currently */
        {
            pNameM = pName;                     /* save head of lang list   */
            while ( (pName = *ppName) != NULL) /* find insertion point     */
            {
                if (!(fNameID ? pName->Name->uu.Ordinal == (*ppName)->Name->uu.Ordinal :
                   !gwcscmp(pName->Name->uu.ss.sz, (*ppName)->Name->uu.ss.sz)) ||
                   Language <= pName->LanguageId)      /* here? */
                    break;                              /* yes   */
                ppName = &(pName->pnext);       /* traverse language list */
            }

            if (pName && Language == pName->LanguageId) /* language found? */
            { 
                if (lpData == NULL) /* DELETE          */
                {
                    return DeleteResourceFromList(pupd, pType, pName, Language, fTypeID, fNameID);
                }

                pName->DataSize = cb;                   /* REPLACE */
                GodotHeapFree((PVOID)pName->OffsetToDataEntry);
                if (IS_ID == Type->discriminant)
                {
                    GodotHeapFree((PVOID)Type);
                }
                if (IS_ID == Name->discriminant)
                {
                    GodotHeapFree((PVOID)Name);
                }
                (PVOID)pName->OffsetToDataEntry = lpData;
                return NO_ERROR;
            }
            else /* add new language */
            {
                return InsertResourceIntoLangList(pupd, Type, Name, pType, pNameM, Language, fNameID, cb, lpData);
            }
        }
    }
    else /* unique name */
    {
        if (lpData == NULL) /* can't delete new name */
        {
            return ERROR_INVALID_PARAMETER;
        }
    }

    //
    // add new name/language
    //
    if (!fSame)
    {
        if (fNameID)
            pType->NumberOfNamesID++;
        else
            pType->NumberOfNamesName++;
    }

    pName = (PRESNAME)GodotHeapAlloc(sizeof(RESNAME));
    if (pName == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;

    RtlZeroMemory((PVOID)pName, sizeof(RESNAME));
    pName->pnext = *ppName;
    *ppName = pName;
    pName->Name = Name;
    pName->Type = Type;
    pName->NumberOfLanguages = 1;
    pName->LanguageId = Language;
    pName->DataSize = cb;
    (PVOID)pName->OffsetToDataEntry = lpData;

    return NO_ERROR;
}


BOOL DeleteResourceFromList(PUPDATEDATA pUpd, PRESTYPE pType, PRESNAME pName,
                            INT Language, INT fType, INT fName)
{
    PPRESTYPE   ppType;
    PPRESNAME   ppName;
    PRESNAME    pNameT;

    /* find previous type node */
    ppType = fType ? &pUpd->ResTypeHeadID : &pUpd->ResTypeHeadName;
    while (*ppType != pType)
    {
        ppType = &((*ppType)->pnext);
    }

    /* find previous type node */
    ppName = fName ? &pType->NameHeadID : &pType->NameHeadName;
    pNameT = NULL;
    while (*ppName != pName)
    {
        if (pNameT == NULL) /* find first Name in lang list */
        {
            if (fName)
            {
                if ((*ppName)->Name->uu.Ordinal == pName->Name->uu.Ordinal)
                {
                    pNameT = *ppName;
                }
            }
            else
            {
                if (gwcsncmp((*ppName)->Name->szStr, pName->Name->szStr, (*ppName)->Name->cbsz) == 0)
                {
                    pNameT = *ppName;
                }
            }
        }
        ppName = &((*ppName)->pnext);
    }

    if (pNameT == NULL) /* first of this name? */
    {
        pNameT = pName->pnext;  /* then (possibly) make next head of lang */
        if (pNameT != NULL)
        {
            if (fName)
            {
                if (pNameT->Name->uu.Ordinal == pName->Name->uu.Ordinal)
                {
                    pNameT->NumberOfLanguages = pName->NumberOfLanguages - 1;
                }
            }
            else
            {
                if (gwcsncmp(pNameT->Name->szStr, pName->Name->szStr, pNameT->Name->cbsz) == 0)
                {
                    pNameT->NumberOfLanguages = pName->NumberOfLanguages - 1;
                }
            }
        }
    }
    else
        pNameT->NumberOfLanguages--;

    if (pNameT)
    {
        if (pNameT->NumberOfLanguages == 0)
        {
            if (fName)
                pType->NumberOfNamesID -= 1;
            else
                pType->NumberOfNamesName -= 1;
        }
    }

    *ppName = pName->pnext;             /* link to next */
    GodotHeapFree( (PVOID)pName->OffsetToDataEntry);
    GodotHeapFree( pName);    /* and free */

    if (*ppName == NULL) /* type list completely empty? */
    {
        *ppType = pType->pnext;                 /* link to next */
        GodotHeapFree( pType);        /* and free */
    }

    return NO_ERROR;
}

BOOL InsertResourceIntoLangList(PUPDATEDATA pUpd, PSDATA Type, PSDATA Name, PRESTYPE pType,
                                PRESNAME pName, INT Language, INT fName, INT cb, PVOID lpData)
{
    PRESNAME    pNameM;
    PRESNAME    pNameNew;
    PPRESNAME   ppName;

    pNameNew = (PRESNAME)GodotHeapAlloc(sizeof(RESNAME));
    if (pNameNew == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;
    RtlZeroMemory((PVOID)pNameNew, sizeof(RESNAME));
    pNameNew->Name = Name;
    pNameNew->Type = Type;
    pNameNew->LanguageId = (WORD)Language;
    pNameNew->DataSize = cb;
    (PVOID)pNameNew->OffsetToDataEntry = lpData;

    if (Language < pName->LanguageId) /* have to add to the front */
    {
        pNameNew->NumberOfLanguages = pName->NumberOfLanguages + 1;
        pName->NumberOfLanguages = 1;

        ppName = fName ? &pType->NameHeadID : &pType->NameHeadName;

        /* don't have to look for NULL at end of list !!!                    */
        while (pName != *ppName) /* find insertion point        */
        {
            ppName = &((*ppName)->pnext);       /* traverse language list    */
        }
        pNameNew->pnext = *ppName;              /* insert                    */
        *ppName = pNameNew;
    }
    else
    {
        pNameM = pName;
        pName->NumberOfLanguages += 1;
        while((pName != NULL) &&
              (fName ? Name->uu.Ordinal == pName->Name->uu.Ordinal :
              !gwcscmp(Name->uu.ss.sz, pName->Name->uu.ss.sz))) /* find insertion point        */
        {
            if (Language <= pName->LanguageId)      /* here?                    */
                break;                                /* yes                        */
            pNameM = pName;
            pName = pName->pnext;                    /* traverse language list    */
        }
        pName = pNameM->pnext;
        pNameM->pnext = pNameNew;
        pNameNew->pnext = pName;
    }
    return NO_ERROR;
}


/*
 * Utility routines
 */

ULONG FilePos(int fh)
{
    return _llseek(fh, 0L, SEEK_CUR);
}


ULONG MuMoveFilePos(INT fh, ULONG pos)
{
    return _llseek( fh, pos, SEEK_SET );
}

ULONG MuWrite(INT fh, UCHAR*p, ULONG n)
{
    ULONG  n1;

    if ((n1 = _lwrite(fh, p, n)) != n)

    {
        return n1;
    }
    else
        return 0;
}

ULONG MuRead(INT fh, UCHAR*p, ULONG n)
{
    ULONG n1;

    if ((n1 = _lread( fh, p, n )) != n)
    {
        return n1;
    }
    else
        return 0;
}

BOOL MuCopy(INT srcfh, INT dstfh, ULONG nbytes)
{
    ULONG n;
    ULONG cb=0L;
    PUCHAR pb;

    pb = (PUCHAR)GodotHeapAlloc(BUFSIZE);
    if (pb == NULL)
        return 0;
    RtlZeroMemory((PVOID)pb, BUFSIZE);

    while (nbytes)
    {
        if (nbytes <= BUFSIZE)
            n = nbytes;
        else
            n = BUFSIZE;
        nbytes -= n;

        if (!MuRead( srcfh, pb, n ))
        {
            cb += n;
            MuWrite( dstfh, pb, n );
        }
        else
        {
            GodotHeapFree( pb);
            return cb;
        }
    }
    GodotHeapFree( pb);
    return cb;
}

VOID SetResdata(PIMAGE_RESOURCE_DATA_ENTRY pResData, ULONG offset, ULONG size)
{
    pResData->OffsetToData = offset;
    pResData->Size = size;
    pResData->CodePage = DEFAULT_CODEPAGE;
    pResData->Reserved = 0L;
}


VOID SetRestab(PIMAGE_RESOURCE_DIRECTORY pRestab, LONG time, WORD cNamed, WORD cId)
{
    pRestab->Characteristics = 0L;
    pRestab->TimeDateStamp = time;
    pRestab->MajorVersion = MAJOR_RESOURCE_VERSION;
    pRestab->MinorVersion = MINOR_RESOURCE_VERSION;
    pRestab->NumberOfNamedEntries = cNamed;
    pRestab->NumberOfIdEntries = cId;
}


PIMAGE_SECTION_HEADER FindSection(PIMAGE_SECTION_HEADER pObjBottom, 
                                  PIMAGE_SECTION_HEADER pObjTop, LPSTR pName)
{
    while (pObjBottom < pObjTop)
    {
        if (strcmp(pObjBottom->Name, pName) == 0)
            return pObjBottom;
        pObjBottom++;
    }

    return NULL;
}

ULONG AssignResourceToSection(PRESNAME *ppRes, ULONG ExtraSectionOffset, 
                              ULONG Offset, LONG Size, PLONG pSizeRsrc1)
{
    ULONG cb;

    /* Assign this res to this section */
    cb = ROUNDUP((*ppRes)->DataSize, CBLONG);
    if (Offset < ExtraSectionOffset && Offset + cb > (ULONG)Size)
    {
        *pSizeRsrc1 = Offset;
        Offset = ExtraSectionOffset;
    }
    (*ppRes)->OffsetToData = Offset;
    *ppRes = (*ppRes)->pnext;
    return Offset + cb;
}


/***************************** Main Worker Function ***************************
* LONG PEWriteResFile
*
* This function writes the resources to the named executable file.
* It assumes that resources have no fixups (even any existing resources
* that it removes from the executable.)  It places all the resources into
* one or two sections. The resources are packed tightly into the section,
* being aligned on dword boundaries.  Each section is padded to a file
* sector size (no invalid or zero-filled pages), and each
* resource is padded to the afore-mentioned dword boundary.  This
* function uses the capabilities of the NT system to enable it to easily
* manipulate the data:  to wit, it assumes that the system can allocate
* any sized piece of data, in particular the section and resource tables.
* If it did not, it might have to deal with temporary files (the system
* may have to grow the swap file, but that's what the system is for.)
*
* Return values are:
*     TRUE  - file was written succesfully.
*     FALSE - file was not written succesfully.
*
* Effects:
*
* History:
* Thur Apr 27, 1989        by     Floyd Rogers      [floydr]
*   Created.
* 12/8/89   sanfords    Added multiple section support.
* 12/11/90  floydr      Modified for new (NT) Linear Exe format
* 1/18/92   vich        Modified for new (NT) Portable Exe format
* 5/8/92    bryant    General cleanup so resonexe can work with unicode
* 6/9/92    floydr    incorporate bryan's changes
* 6/15/92   floydr    debug section separate from debug table
* 9/25/92   floydr    account for .rsrc not being last-1
* 9/28/92   floydr    account for adding lots of resources by adding
*                     a second .rsrc section.
\****************************************************************************/

/*  */
LONG PEWriteResFile(INT inpfh, INT outfh, ULONG cbOldexe, PUPDATEDATA pUpdate)
{
    IMAGE_NT_HEADERS Old;       /* original header              */
    IMAGE_NT_HEADERS New;       /* working header       */
    PRESNAME    pRes;
    PRESNAME    pResSave;
    PRESTYPE    pType;
    ULONG       clock = GetTickCount(); /* current time */
    ULONG       cbName=0;       /* count of bytes in name strings */
    ULONG       cbType=0;       /* count of bytes in type strings */
    ULONG       cTypeStr=0;     /* count of strings */
    ULONG       cNameStr=0;     /* count of strings */
    LONG        cb;             /* temp byte count and file index */
    ULONG       cTypes = 0L;    /* count of resource types      */
    ULONG       cNames = 0L;    /* Count of names for multiple languages/name */
    ULONG       cRes = 0L;      /* count of resources      */
    ULONG       cbRestab;       /* count of resources      */
    LONG        cbNew = 0L;     /* general count */
    ULONG       ibObjTab;
    ULONG       ibObjTabEnd;
    ULONG       ibNewObjTabEnd;
    ULONG       ibSave;
    ULONG       adjust=0;
    PIMAGE_SECTION_HEADER       pObjtblOld,
        pObjtblNew,
        pObjDebug,
        pObjResourceOld,
        pObjResourceNew,
        pObjResourceOldX,
        pObjDebugDirOld,
        pObjDebugDirNew,
        pObjNew,
        pObjOld,
        pObjLast;
    PUCHAR      p;
    PIMAGE_RESOURCE_DIRECTORY   pResTab;
    PIMAGE_RESOURCE_DIRECTORY   pResTabN;
    PIMAGE_RESOURCE_DIRECTORY   pResTabL;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY     pResDirL;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY     pResDirN;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY     pResDirT;
    PIMAGE_RESOURCE_DATA_ENTRY  pResData;
    PUSHORT     pResStr;
    PUSHORT     pResStrEnd;
    PSDATA      pPreviousName;
    LONG        nObjResource=-1;
    LONG        nObjResourceX=-1;
    ULONG       cbResource;
    ULONG       cbMustPad = 0;
    ULONG       ibMaxDbgOffsetOld;

    MuMoveFilePos(inpfh, cbOldexe);
    MuRead(inpfh, (PUCHAR)&Old, sizeof(IMAGE_NT_HEADERS));
    ibObjTab = cbOldexe + sizeof(ULONG) + sizeof(IMAGE_FILE_HEADER) +
                  Old.FileHeader.SizeOfOptionalHeader;
    ibObjTabEnd = ibObjTab + Old.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER);
    ibNewObjTabEnd = ibObjTabEnd;

    if (*(PUSHORT)&Old.Signature != IMAGE_NT_SIGNATURE)
        return ERROR_INVALID_EXE_SIGNATURE;

    if((Old.FileHeader.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE) == 0 &&
      (Old.FileHeader.Characteristics & IMAGE_FILE_DLL) == 0)
    {
        return ERROR_EXE_MARKED_INVALID;
    }

    /* New header is like old one.                  */
    RtlCopyMemory(&New, &Old, sizeof(IMAGE_NT_HEADERS));

    /* Read section table */
    pObjtblOld = (PIMAGE_SECTION_HEADER)GodotHeapAlloc(
                        Old.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER));
    if (pObjtblOld == NULL)
    {
        cb = ERROR_NOT_ENOUGH_MEMORY;
        goto AbortExit;
    }
    RtlZeroMemory((PVOID)pObjtblOld, Old.FileHeader.NumberOfSections*sizeof(IMAGE_SECTION_HEADER));
    MuMoveFilePos(inpfh, ibObjTab);
    MuRead(inpfh, (PUCHAR)pObjtblOld,
        Old.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER));
    pObjLast = pObjtblOld + Old.FileHeader.NumberOfSections;
    ibMaxDbgOffsetOld = 0;
    for (pObjOld=pObjtblOld ; pObjOld<pObjLast ; pObjOld++)
    {
        if (pObjOld->PointerToRawData > ibMaxDbgOffsetOld)
        {
            ibMaxDbgOffsetOld = pObjOld->PointerToRawData + pObjOld->SizeOfRawData;
        }
    }

    /*
     * First, count up the resources.  We need this information
     * to discover how much room for header information to allocate
     * in the resource section.  cRes tells us how
     * many language directory entries/tables.  cNames and cTypes
     * is used for the respective tables and/or entries.  cbName totals
     * the bytes required to store the alpha names (including the leading
     * length word).  cNameStr counts these strings.
     */

    /* first, count those in the named type list */
    cbResource = 0;
    pType = pUpdate->ResTypeHeadName;
    while (pType != NULL)
    {
        if (pType->NameHeadName != NULL || pType->NameHeadID != NULL)
        {
            cTypes++;
            cTypeStr++;
            cbType += (pType->Type->cbsz + 1) * sizeof(WORD);

            pPreviousName = NULL;
            pRes = pType->NameHeadName;
            while (pRes)
            {
                cRes++;
                if (pPreviousName == NULL || 
                    gwcsncmp(pPreviousName->szStr, pRes->Name->szStr, pRes->Name->cbsz) != 0)
                {
                    cbName += (pRes->Name->cbsz + 1) * sizeof(WORD);
                    cNameStr++;
                    cNames++;
                }
                cbResource += ROUNDUP(pRes->DataSize, CBLONG);
                pPreviousName = pRes->Name;
                pRes = pRes->pnext;
            }

            pPreviousName = NULL;
            pRes = pType->NameHeadID;
            while (pRes)
            {
                cRes++;
                if (pPreviousName == NULL || pPreviousName->uu.Ordinal != pRes->Name->uu.Ordinal)
                {
                    cNames++;
                }
                cbResource += ROUNDUP(pRes->DataSize, CBLONG);
                pPreviousName = pRes->Name;
                pRes = pRes->pnext;
            }
        }
        pType = pType->pnext;
    }

    /* second, count those in the ID type list */
    pType = pUpdate->ResTypeHeadID;
    while (pType != NULL)
    {
        if (pType->NameHeadName != NULL || pType->NameHeadID != NULL)
        {
            cTypes++;
            pPreviousName = NULL;
            pRes = pType->NameHeadName;
            while (pRes)

            {
                cRes++;
                if (pPreviousName == NULL ||
                    gwcsncmp(pPreviousName->szStr, pRes->Name->szStr, pRes->Name->cbsz) != 0)
                {
                    cNames++;
                    cbName += (pRes->Name->cbsz + 1) * sizeof(WORD);
                    cNameStr++;
                }
                cbResource += ROUNDUP(pRes->DataSize, CBLONG);
                pPreviousName = pRes->Name;
                pRes = pRes->pnext;
            }

            pPreviousName = NULL;
            pRes = pType->NameHeadID;
            while (pRes)
            {
                cRes++;
                if (pPreviousName == NULL ||
                    pPreviousName->uu.Ordinal != pRes->Name->uu.Ordinal)
                {
                    cNames++;
                }
                cbResource += ROUNDUP(pRes->DataSize, CBLONG);
                pPreviousName = pRes->Name;
                pRes = pRes->pnext;
            }
        }
        pType = pType->pnext;
    }
    cb = REMAINDER(cbName + cbType, CBLONG);

    /* Add up the number of bytes needed to store the directory.  There is
     * one type table with cTypes entries.  They point to cTypes name tables
     * that have a total of cNames entries.  Each of them points to a language
     * table and there are a total of cRes entries in all the language tables.
     * Finally, we have the space needed for the Directory string entries,
     * some extra padding to attain the desired alignment, and the space for
     * cRes data entry headers.
     */
    cbRestab =   sizeof(IMAGE_RESOURCE_DIRECTORY) +     /* root dir (types) */
    cTypes * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY) +
    cTypes * sizeof(IMAGE_RESOURCE_DIRECTORY) +     /* subdir2 (names) */
    cNames * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY) +
    cNames * sizeof(IMAGE_RESOURCE_DIRECTORY) +     /* subdir3 (langs) */
    cRes   * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY) +
    (cbName + cbType) +                             /* name/type strings */
    cb +                                            /* padding */
    cRes   * sizeof(IMAGE_RESOURCE_DATA_ENTRY);     /* data entries */

    cbResource += cbRestab;             /* add in the resource table */

    // Find any current resource sections

    pObjResourceOld = FindSection(pObjtblOld, pObjLast, ".rsrc");
    pObjResourceOldX = FindSection(pObjtblOld, pObjLast, ".rsrc1");
    if (pObjResourceOld == NULL)
    {
        cb = 0x7fffffff;                /* can fill forever */
    }
    else if (pObjResourceOld + 1 == pObjResourceOldX)
    {
        nObjResource = pObjResourceOld - pObjtblOld;
        cb = 0x7fffffff;                /* merge resource sections */
    }
    else
    {
        nObjResource = pObjResourceOld - pObjtblOld;
        cb = (pObjResourceOld+1)->VirtualAddress - pObjResourceOld->VirtualAddress;
        if (cbRestab > (ULONG)cb)
        {
            return ERROR_INVALID_DATA;
        }
    }

    /*
     * Discover where the first discardable section is.  This is where
     * we will stick any new resource section.
     *
     * Note that we are ignoring discardable sections such as .CRT -
     * this is so that we don't cause any relocation problems.
     * Let's hope that .reloc is the one we want!!!
     */
    pObjOld = FindSection(pObjtblOld, pObjLast, ".reloc");

    if (pObjResourceOld != NULL && cbResource > (ULONG)cb)
    {
        if (pObjResourceOld != NULL && pObjOld == pObjResourceOld + 1)
        {
            cb = 0x7fffffff;            /* can fill forever */
        }
        else if (pObjResourceOldX == NULL)
        {
            nObjResourceX = pObjOld - pObjtblOld;
            adjust = pObjOld->VirtualAddress - pObjResourceOld->VirtualAddress;
        }
        else /* have already merged .rsrc & .rsrc1, if possible */
        {
            nObjResourceX = pObjResourceOldX - pObjtblOld;
            adjust = pObjResourceOldX->VirtualAddress - pObjResourceOld->VirtualAddress;
        }
    }

    /*
     * Walk the type lists and figure out where the Data entry header will
     * go.  Keep a running total of the size for each data element so we
     * can store this in the section header.
     */

    /* first, those in the named type list */

    cbResource = cbRestab;      /* assign resource table to 1st rsrc section */
                /* adjust == offset to .rsrc1 */
                /* cb == size availble in .rsrc */
    cbNew = 0;                  /* count of bytes in second .rsrc */
    pType = pUpdate->ResTypeHeadName;
    while (pType != NULL)
    {
        if (pType->NameHeadName != NULL || pType->NameHeadID != NULL)
        {
            pRes = pType->NameHeadName;
            while (pRes)
            {
                cbResource = AssignResourceToSection(&pRes, adjust, cbResource, cb, &cbNew);
            }
            pRes = pType->NameHeadID;
            while (pRes)
            {
                cbResource = AssignResourceToSection(&pRes, adjust, cbResource, cb, &cbNew);
            }
        }
        pType = pType->pnext;
    }

    /* then, count those in the ID type list */

    pType = pUpdate->ResTypeHeadID;
    while (pType != NULL)
    {
        if (pType->NameHeadName != NULL || pType->NameHeadID != NULL)
        {
            pRes = pType->NameHeadName;
            while (pRes)
            {
                cbResource = AssignResourceToSection(&pRes, adjust, cbResource, cb, &cbNew);
            }
            pRes = pType->NameHeadID;
            while (pRes)
            {
                cbResource = AssignResourceToSection(&pRes, adjust, cbResource, cb, &cbNew);
            }
        }
        pType = pType->pnext;
    }
    /*
     * At this point:
     * cbResource has offset of first byte past the last resource.
     * cbNew has the count of bytes in the first resource section,
     * if there are two sections.
     */
    if (cbNew == 0)
        cbNew = cbResource;

    /*
     * Discover where the Debug info is (if any)?
     */
    pObjDebug = FindSection(pObjtblOld, pObjLast, ".debug");
    if (pObjDebug != NULL)
    {
        if (Old.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress  == 0)
        {
            return ERROR_INVALID_DATA;
        }
        if (pObjDebug != pObjLast-1)
        {
            return ERROR_INVALID_DATA;
        }
    }
    pObjDebugDirOld = NULL;
    for (pObjOld=pObjtblOld ; pObjOld<pObjLast ; pObjOld++)
    {
        if(Old.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress >= 
            pObjOld->VirtualAddress &&
           Old.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress < 
            pObjOld->VirtualAddress+pObjOld->SizeOfRawData)
        {
            pObjDebugDirOld = pObjOld;
            break;
        }
    }

    /*
     * Discover where the first discardable section is.  This is where
     * we will stick any new resource section.
     *
     * Note that we are ignoring discardable sections such as .CRT -
     * this is so that we don't cause any relocation problems.
     * Let's hope that .reloc is the one we want!!!
     */
    pObjOld = FindSection(pObjtblOld, pObjLast, ".reloc");

    if (nObjResource == -1) /* no old resource section */
    {
        if (pObjOld != NULL)
            nObjResource = pObjOld - pObjtblOld;
        else if (pObjDebug != NULL)
            nObjResource = pObjDebug - pObjtblOld;
        else
            nObjResource = New.FileHeader.NumberOfSections;
        New.FileHeader.NumberOfSections++;
    }

    if (nObjResourceX != -1)
    {
        if (pObjResourceOldX != NULL)
        {
            nObjResourceX = pObjResourceOldX - pObjtblOld;
            New.FileHeader.NumberOfSections--;
        }
        else if (pObjOld != NULL)
            nObjResourceX = pObjOld - pObjtblOld;
        else if (pObjDebug != NULL)
            nObjResourceX = pObjDebug - pObjtblOld;
        else
            nObjResourceX = New.FileHeader.NumberOfSections;
        New.FileHeader.NumberOfSections++;
    }
    else if (pObjResourceOldX != NULL) /* Was old .rsrc1 section? */
    {
        New.FileHeader.NumberOfSections--;      /* yes, delete it */
    }

    /*
     * If we had to add anything to the header (section table),
     * then we have to update the header size and rva's in the header.
     */
    adjust = (New.FileHeader.NumberOfSections -
              Old.FileHeader.NumberOfSections) * sizeof(IMAGE_SECTION_HEADER);
    cb = Old.OptionalHeader.SizeOfHeaders -
        (Old.FileHeader.NumberOfSections*sizeof(IMAGE_SECTION_HEADER) +
        sizeof(IMAGE_NT_HEADERS) + cbOldexe );
    if (adjust > (ULONG)cb)
    {
        int i;

        adjust -= cb;
        for (i = 0; i < IMAGE_NUMBEROF_DIRECTORY_ENTRIES ; i++)
        {
            if (New.OptionalHeader.DataDirectory[i].VirtualAddress &&
                New.OptionalHeader.DataDirectory[i].VirtualAddress < New.OptionalHeader.SizeOfHeaders)
            {
                New.OptionalHeader.DataDirectory[i].VirtualAddress += adjust;
            }
        }
        New.OptionalHeader.SizeOfHeaders += adjust;
    }
    else if (adjust > 0)
    {
        int i;

        //
        // Loop over DataDirectory entries and look for any entries that point to
        // information stored in the 'dead' space after the section table but before
        // the SizeOfHeaders length.
        //
        for (i = 0; i < IMAGE_NUMBEROF_DIRECTORY_ENTRIES ; i++)
        {
            if (New.OptionalHeader.DataDirectory[i].VirtualAddress &&
                New.OptionalHeader.DataDirectory[i].VirtualAddress < Old.OptionalHeader.SizeOfHeaders)
            {
                New.OptionalHeader.DataDirectory[i].VirtualAddress += adjust;
            }
        }
    }
    ibNewObjTabEnd += adjust;

    /* Allocate storage for new section table                */
    cb = New.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER);
    pObjtblNew = (PIMAGE_SECTION_HEADER)GodotHeapAlloc((short)cb);
    if (pObjtblNew == NULL)
    {
        cb = ERROR_NOT_ENOUGH_MEMORY;
        goto AbortExit;
    }
    RtlZeroMemory((PVOID)pObjtblNew, cb);
    pObjResourceNew = pObjtblNew + nObjResource;

    /*
     * copy old section table to new
     */
    adjust = 0;                 /* adjustment to virtual address */
    for (pObjOld=pObjtblOld,pObjNew=pObjtblNew ; pObjOld<pObjLast ; pObjOld++)
    {
        if (pObjOld == pObjResourceOldX)
        {
            if (nObjResourceX == -1)
            {
                // we have to move back all the other section.
                // the .rsrc1 is bigger than what we need
                // adjust must be a negative number
                adjust -= (pObjOld+1)->VirtualAddress - pObjOld->VirtualAddress;
            }
            continue;
        }
        else if (pObjNew == pObjResourceNew)
        {
            cb = ROUNDUP(cbNew, New.OptionalHeader.FileAlignment);
            if (pObjResourceOld == NULL)
            {
                adjust = ROUNDUP(cbNew, New.OptionalHeader.SectionAlignment);
                RtlZeroMemory(pObjNew, sizeof(IMAGE_SECTION_HEADER));
                strcpy(pObjNew->Name, ".rsrc");
                pObjNew->VirtualAddress = pObjOld->VirtualAddress;
                pObjNew->PointerToRawData = pObjOld->PointerToRawData;
                pObjNew->Characteristics = IMAGE_SCN_MEM_READ |
                                           /*IMAGE_SCN_MEM_WRITE | */
                                           IMAGE_SCN_CNT_INITIALIZED_DATA;
                pObjNew->SizeOfRawData = cb;
                pObjNew->Misc.VirtualSize = cbNew; //ROUNDUP(cb, New.OptionalHeader.SectionAlignment);
            }
            else
            {
                *pObjNew = *pObjOld;    /* copy obj table entry */
                pObjNew->SizeOfRawData = cb;
                pObjNew->Misc.VirtualSize = cbNew; // ROUNDUP(cb, New.OptionalHeader.SectionAlignment);
                if (pObjNew->SizeOfRawData == pObjOld->SizeOfRawData)
                {
                    adjust = 0;
                }
                else if (pObjNew->SizeOfRawData > pObjOld->SizeOfRawData)
                {
                    adjust += ROUNDUP(cbNew, New.OptionalHeader.SectionAlignment) -
                              ((pObjOld+1)->VirtualAddress-pObjOld->VirtualAddress);
                }
                else /* is smaller, but pad so will be valid */
                {
                    adjust = 0;
                    pObjNew->SizeOfRawData = pObjResourceOld->SizeOfRawData;
                    /* if legoized, the VS could be > RawSize !!! */
                    pObjNew->Misc.VirtualSize = pObjResourceOld->Misc.VirtualSize;
                    cbMustPad = pObjResourceOld->SizeOfRawData;
                }
            }
            pObjNew++;
            if (pObjResourceOld == NULL)
                goto rest_of_table;
        }
        else if (nObjResourceX != -1 && pObjNew == pObjtblNew + nObjResourceX)
        {
            RtlZeroMemory(pObjNew, sizeof(IMAGE_SECTION_HEADER));
            strcpy(pObjNew->Name, ".rsrc1");
            /*
             * Before we copy the virtual address we have to move back the
             * .reloc * virtual address. Otherwise we will keep moving the
             * reloc VirtualAddress forward.
             * We will have to move back the address of .rsrc1
             */
            if (pObjResourceOldX == NULL)
            {
                // This is the first time we have a .rsrc1
                pObjNew->VirtualAddress = pObjOld->VirtualAddress;
                pObjNew->Characteristics = IMAGE_SCN_MEM_READ |
                                           IMAGE_SCN_MEM_WRITE | 
                                           IMAGE_SCN_CNT_INITIALIZED_DATA;
                adjust = ROUNDUP(cbResource, New.OptionalHeader.SectionAlignment) +
                         pObjResourceNew->VirtualAddress - pObjNew->VirtualAddress;
            }
            else
            {
                // we already have an .rsrc1 use the position of that and
                // calculate the new adjust
                pObjNew->VirtualAddress = pObjResourceOldX->VirtualAddress;
                pObjNew->Characteristics = IMAGE_SCN_MEM_READ |
                                           IMAGE_SCN_MEM_WRITE | 
                                           IMAGE_SCN_CNT_INITIALIZED_DATA;
                // Check if we have enough room in the old .rsrc1
                // Include the full size of the section, data + roundup
                if (cbResource - (pObjResourceOldX->VirtualAddress - pObjResourceOld->VirtualAddress) <=
                    pObjOld->VirtualAddress - pObjNew->VirtualAddress )
                {
                    // we have to move back all the other section.
                    // the .rsrc1 is bigger than what we need
                    // adjust must be a negative number
                    // calc new adjust size
                    adjust = ROUNDUP(cbResource, New.OptionalHeader.SectionAlignment) +
                             pObjResourceNew->VirtualAddress - pObjOld->VirtualAddress;
                }
                else
                {
                    // we have to move the section again.
                    // The .rsrc1 is too small

                    adjust = ROUNDUP(cbResource, New.OptionalHeader.SectionAlignment) +
                    pObjResourceNew->VirtualAddress -
                    pObjOld->VirtualAddress;
                }
            }
            pObjNew++;
            goto rest_of_table;
        }
        else if (pObjNew < pObjResourceNew)
        {
            *pObjNew++ = *pObjOld;              /* copy obj table entry */
        }
        else 
        {
rest_of_table:
            *pObjNew++ = *pObjOld;
            (pObjNew-1)->VirtualAddress += adjust;
        }
    }


    pObjNew = pObjtblNew + New.FileHeader.NumberOfSections - 1;
    New.OptionalHeader.SizeOfImage = ROUNDUP(pObjNew->VirtualAddress +
                                             pObjNew->SizeOfRawData, New.OptionalHeader.SectionAlignment);

    /* allocate room to build the resource directory/tables in */
    pResTab = (PIMAGE_RESOURCE_DIRECTORY)GodotHeapAlloc(cbRestab);
    if (pResTab == NULL)
    {
        cb = ERROR_NOT_ENOUGH_MEMORY;
        goto AbortExit;
    }

    /* First, setup the "root" type directory table.  It will be followed by */
    /* Types directory entries.                                              */

    RtlZeroMemory((PVOID)pResTab, cbRestab);
    p = (PUCHAR)pResTab;
    pResTab->Characteristics = 0L;
    pResTab->TimeDateStamp = clock;
    pResTab->MajorVersion = MAJOR_RESOURCE_VERSION;
    pResTab->MinorVersion = MINOR_RESOURCE_VERSION;
    pResTab->NumberOfNamedEntries = (USHORT)cTypeStr;
    pResTab->NumberOfIdEntries = (USHORT)(cTypes - cTypeStr);

    /* Calculate the start of the various parts of the resource table.  */
    /* We need the start of the Type/Name/Language directories as well  */
    /* as the start of the UNICODE strings and the actual data nodes.   */

    pResDirT = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTab + 1);

    pResDirN = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(((PUCHAR)pResDirT) +
        cTypes * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY));

    pResDirL = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(((PUCHAR)pResDirN) +
        cTypes * sizeof(IMAGE_RESOURCE_DIRECTORY) +
        cNames * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY));

    pResData = (PIMAGE_RESOURCE_DATA_ENTRY)(((PUCHAR)pResDirL) +
        cNames * sizeof(IMAGE_RESOURCE_DIRECTORY) +
        cRes * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY));

    pResStr  = (PUSHORT)(((PUCHAR)pResData) +
        cRes * sizeof(IMAGE_RESOURCE_DATA_ENTRY));

    pResStrEnd = (PUSHORT)(((PUCHAR)pResStr) + cbName + cbType);

    /*
     * Loop over type table, building the PE resource table.
     */

    /*
     * *****************************************************************
     * This code doesn't sort the table - the TYPEINFO and RESINFO    **
     * insertion code in rcp.c (AddResType and SaveResFile) do the    **
     * insertion by ordinal type and name, so we don't have to sort   **
     * it at this point.                                              **
     * *****************************************************************
     */

    // First, add all the entries in the Types: Alpha list.

    pType = pUpdate->ResTypeHeadName;
    while (pType)
    {
        pResDirT->Name = (ULONG)((((PUCHAR)pResStr) - p) | IMAGE_RESOURCE_NAME_IS_STRING);
        pResDirT->OffsetToData = (ULONG)((((PUCHAR)pResDirN) - p) | IMAGE_RESOURCE_DATA_IS_DIRECTORY);
        pResDirT++;

        *pResStr = pType->Type->cbsz;
        gwcsncpy((WCHAR*)(pResStr+1), pType->Type->szStr, pType->Type->cbsz);
        pResStr += pType->Type->cbsz + 1;

        pResTabN = (PIMAGE_RESOURCE_DIRECTORY)pResDirN;
        SetRestab(pResTabN, clock, (USHORT)pType->NumberOfNamesName, (USHORT)pType->NumberOfNamesID);
        pResDirN = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabN + 1);

        pPreviousName = NULL;

        pRes = pType->NameHeadName;
        while (pRes)
        {
            if (pPreviousName == NULL ||
                gwcsncmp(pPreviousName->szStr, pRes->Name->szStr, pRes->Name->cbsz) != 0)
            {
                // Setup a new name directory

                pResDirN->Name = (ULONG)((((PUCHAR)pResStr)-p) | IMAGE_RESOURCE_NAME_IS_STRING);
                pResDirN->OffsetToData = (ULONG)((((PUCHAR)pResDirL)-p) | IMAGE_RESOURCE_DATA_IS_DIRECTORY);
                pResDirN++;

                // Copy the alpha name to a string entry

                *pResStr = pRes->Name->cbsz;
                gwcsncpy((WCHAR*)(pResStr+1),pRes->Name->szStr,pRes->Name->cbsz);
                pResStr += pRes->Name->cbsz + 1;

                pPreviousName = pRes->Name;

                // Setup the Language table

                pResTabL = (PIMAGE_RESOURCE_DIRECTORY)pResDirL;
                SetRestab(pResTabL, clock, (USHORT)0, (USHORT)pRes->NumberOfLanguages);
                pResDirL = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabL + 1);
            }

            // Setup a new Language directory

            pResDirL->Name = pRes->LanguageId;
            pResDirL->OffsetToData = (ULONG)(((PUCHAR)pResData) - p);
            pResDirL++;

            // Setup a new resource data entry

            SetResdata(pResData,
            pRes->OffsetToData+pObjtblNew[nObjResource].VirtualAddress,
            pRes->DataSize);
            pResData++;

            pRes = pRes->pnext;
        }

        pPreviousName = NULL;

        pRes = pType->NameHeadID;
        while (pRes)
        {
            if (pPreviousName == NULL || pPreviousName->uu.Ordinal != pRes->Name->uu.Ordinal)
            {
                // Setup the name directory to point to the next language
                // table

                pResDirN->Name = pRes->Name->uu.Ordinal;
                pResDirN->OffsetToData = (ULONG)((((PUCHAR)pResDirL)-p) | IMAGE_RESOURCE_DATA_IS_DIRECTORY);
                pResDirN++;

                pPreviousName = pRes->Name;

                // Init a new Language table

                pResTabL = (PIMAGE_RESOURCE_DIRECTORY)pResDirL;
                SetRestab(pResTabL, clock, (USHORT)0, (USHORT)pRes->NumberOfLanguages);
                pResDirL = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabL + 1);
            }

            // Setup a new language directory entry to point to the next
            // resource

            pResDirL->Name = pRes->LanguageId;
            pResDirL->OffsetToData = (ULONG)(((PUCHAR)pResData) - p);
            pResDirL++;

            // Setup a new resource data entry

            SetResdata(pResData,
            pRes->OffsetToData+pObjtblNew[nObjResource].VirtualAddress,
            pRes->DataSize);
            pResData++;

            pRes = pRes->pnext;
        }

        pType = pType->pnext;
    }

    //  Do the same thing, but this time, use the Types: ID list.
    pType = pUpdate->ResTypeHeadID;
    while (pType)
    {
        pResDirT->Name = (ULONG)pType->Type->uu.Ordinal;
        pResDirT->OffsetToData = (ULONG)((((PUCHAR)pResDirN) - p) | IMAGE_RESOURCE_DATA_IS_DIRECTORY);
        pResDirT++;

        pResTabN = (PIMAGE_RESOURCE_DIRECTORY)pResDirN;
        SetRestab(pResTabN, clock, (USHORT)pType->NumberOfNamesName, (USHORT)pType->NumberOfNamesID);
        pResDirN = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabN + 1);

        pPreviousName = NULL;

        pRes = pType->NameHeadName;
        while (pRes)
        {
            if (pPreviousName == NULL ||
                gwcsncmp(pPreviousName->szStr, pRes->Name->szStr, pRes->Name->cbsz) != 0) 
            {
                // Setup a new name directory

                pResDirN->Name = (ULONG)((((PUCHAR)pResStr)-p) | IMAGE_RESOURCE_NAME_IS_STRING);
                pResDirN->OffsetToData = (ULONG)((((PUCHAR)pResDirL)-p) | IMAGE_RESOURCE_DATA_IS_DIRECTORY);
                pResDirN++;

                // Copy the alpha name to a string entry.

                *pResStr = pRes->Name->cbsz;
                gwcsncpy((WCHAR*)(pResStr+1),pRes->Name->szStr,pRes->Name->cbsz);
                pResStr += pRes->Name->cbsz + 1;

                pPreviousName = pRes->Name;

                // Setup the Language table

                pResTabL = (PIMAGE_RESOURCE_DIRECTORY)pResDirL;
                SetRestab(pResTabL, clock, (USHORT)0, (USHORT)pRes->NumberOfLanguages);
                pResDirL = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabL + 1);
            }

            // Setup a new Language directory

            pResDirL->Name = pRes->LanguageId;
            pResDirL->OffsetToData = (ULONG)(((PUCHAR)pResData) - p);
            pResDirL++;

            // Setup a new resource data entry

            SetResdata(pResData,
            pRes->OffsetToData+pObjtblNew[nObjResource].VirtualAddress,
            pRes->DataSize);
            pResData++;

            pRes = pRes->pnext;
        }

        pPreviousName = NULL;

        pRes = pType->NameHeadID;
        while (pRes)
        {
            if (pPreviousName == NULL || pPreviousName->uu.Ordinal != pRes->Name->uu.Ordinal)
            {
                // Setup the name directory to point to the next language
                // table

                pResDirN->Name = pRes->Name->uu.Ordinal;
                pResDirN->OffsetToData = (ULONG)((((PUCHAR)pResDirL)-p) | IMAGE_RESOURCE_DATA_IS_DIRECTORY);
                pResDirN++;

                pPreviousName = pRes->Name;

                // Init a new Language table

                pResTabL = (PIMAGE_RESOURCE_DIRECTORY)pResDirL;
                SetRestab(pResTabL, clock, (USHORT)0, (USHORT)pRes->NumberOfLanguages);
                pResDirL = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabL + 1);
            }

            // Setup a new language directory entry to point to the next
            // resource

            pResDirL->Name = pRes->LanguageId;
            pResDirL->OffsetToData = (ULONG)(((PUCHAR)pResData) - p);
            pResDirL++;

            // Setup a new resource data entry

            SetResdata(pResData, pRes->OffsetToData+pObjtblNew[nObjResource].VirtualAddress, pRes->DataSize);
            pResData++;

            pRes = pRes->pnext;
        }

        pType = pType->pnext;
    }
    while (pResStr < pResStrEnd)
    {
        *pResStr++ = 0;
    }

    /*
     * copy the Old exe header and stub, and allocate room for the PE header.
     */
    MuMoveFilePos(inpfh, 0L);
    MuCopy(inpfh, outfh, cbOldexe + sizeof(IMAGE_NT_HEADERS));

    /*
     * Copy rest of file header
     */
    MuMoveFilePos(outfh, ibNewObjTabEnd + New.OptionalHeader.SizeOfHeaders -
                         Old.OptionalHeader.SizeOfHeaders);
    MuMoveFilePos(inpfh, ibObjTabEnd);
    MuCopy(inpfh, outfh, Old.OptionalHeader.SizeOfHeaders - ibNewObjTabEnd);

    /*
     * copy existing image sections
     */

    /* Align data sections on sector boundary           */
    cb = REMAINDER(New.OptionalHeader.SizeOfHeaders, New.OptionalHeader.FileAlignment);
    New.OptionalHeader.SizeOfHeaders += cb;
    while (cb >= cbPadMax)
    {
        MuWrite(outfh, pchZero, cbPadMax);
        cb -= cbPadMax;
    }
    MuWrite(outfh, pchZero, cb);

    cb = ROUNDUP(Old.OptionalHeader.SizeOfHeaders, Old.OptionalHeader.FileAlignment);
    MuMoveFilePos(inpfh, cb);

    /* copy one section at a time */
    New.OptionalHeader.SizeOfInitializedData = 0;
    for (pObjOld = pObjtblOld , pObjNew = pObjtblNew ; pObjOld < pObjLast ; pObjNew++) 
    {
        if (pObjOld == pObjResourceOldX)
            pObjOld++;
        if (pObjNew == pObjResourceNew)
        {

            /* Write new resource section */
            pObjNew->PointerToRawData = FilePos(outfh);
            New.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress = pObjResourceNew->VirtualAddress;
            New.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size = cbResource;
            ibSave = FilePos(outfh);
            MuWrite(outfh, (PUCHAR)pResTab, cbRestab);

            pResSave = WriteResSection(pUpdate, outfh, New.OptionalHeader.FileAlignment,
                                       pObjResourceNew->SizeOfRawData-cbRestab, NULL);
            cb = FilePos(outfh);
            if (cbMustPad != 0)
            {
                cbMustPad -= cb - ibSave;
                /* assumes that cbMustPad % cbpadMax == 0 */
                while (cbMustPad > 0)
                {
                    MuWrite(outfh, pchZero, cbPadMax);
                    cbMustPad -= cbPadMax;
                }
                cb = FilePos(outfh);
            }
            if (nObjResourceX == -1) 
            {
                MuMoveFilePos(outfh, ibSave);
                MuWrite(outfh, (PUCHAR)pResTab, cbRestab);
                MuMoveFilePos(outfh, cb);
                cb = FilePos(inpfh);
                MuMoveFilePos(inpfh, cb+pObjOld->SizeOfRawData);
            }
            New.OptionalHeader.SizeOfInitializedData += pObjNew->SizeOfRawData;
            if (pObjResourceOld == NULL)
            {
                pObjNew++;
                goto next_section;
            }
            else
            pObjOld++;
        }
        else if (nObjResourceX != -1 && pObjNew == pObjtblNew + nObjResourceX) 
        {

            /* Write new resource section */
            pObjNew->PointerToRawData = FilePos(outfh);
            (void)WriteResSection(pUpdate, outfh, New.OptionalHeader.FileAlignment, 0xffffffff, pResSave);
            cb = FilePos(outfh);
            pObjNew->SizeOfRawData = cb - pObjNew->PointerToRawData;
            pObjNew->Misc.VirtualSize = ROUNDUP(pObjNew->SizeOfRawData, 
                                                New.OptionalHeader.SectionAlignment);
            MuMoveFilePos(outfh, ibSave);
            MuWrite(outfh, (PUCHAR)pResTab, cbRestab);
            MuMoveFilePos(outfh, cb);
            New.OptionalHeader.SizeOfInitializedData += pObjNew->SizeOfRawData;
            pObjNew++;
            goto next_section;
        }
        else
        {
            if (pObjNew < pObjResourceNew &&
                pObjOld->PointerToRawData != 0 &&
                pObjOld->PointerToRawData != FilePos(outfh))
            {
                MuMoveFilePos(outfh, pObjOld->PointerToRawData);
            }
next_section:
            if (pObjOld->PointerToRawData != 0)
            {
                pObjNew->PointerToRawData = FilePos(outfh);
                MuMoveFilePos(inpfh, pObjOld->PointerToRawData);
                MuCopy(inpfh, outfh, pObjOld->SizeOfRawData);
            }
            if (pObjOld == pObjDebugDirOld) 
            {
                pObjDebugDirNew = pObjNew;
            }
            if ((pObjNew->Characteristics&IMAGE_SCN_CNT_INITIALIZED_DATA) != 0)
                New.OptionalHeader.SizeOfInitializedData += pObjNew->SizeOfRawData;
            pObjOld++;
        }
    }
    if (pObjResourceOldX != NULL)
        New.OptionalHeader.SizeOfInitializedData -= pObjResourceOldX->SizeOfRawData;

    /* Update the address of the relocation table */
    pObjNew = FindSection(pObjtblNew, pObjtblNew+New.FileHeader.NumberOfSections, ".reloc");
    if (pObjNew != NULL)
    {
        New.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = pObjNew->VirtualAddress;
    }

    /*
     * Write new section table out.
     */
    MuMoveFilePos(outfh, ibObjTab);
    MuWrite(outfh, (PUCHAR)pObjtblNew, New.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER));

    /* Seek to end of output file and issue truncating write */
    adjust = _llseek(outfh, 0L, SEEK_END);
    MuWrite(outfh, NULL, 0);

    /* If a debug section, fix up the debug table */
    pObjNew = FindSection(pObjtblNew, pObjtblNew+New.FileHeader.NumberOfSections, ".debug");
    cb = PatchDebug(inpfh, outfh, pObjDebug, pObjNew, pObjDebugDirOld, 
                    pObjDebugDirNew, &Old, &New, ibMaxDbgOffsetOld, &adjust);

    if (cb == NO_ERROR)
    {
        if (pObjResourceOld == NULL)
        {
            cb = (LONG)pObjResourceNew->SizeOfRawData;
        }
        else
        {
            cb = (LONG)pObjResourceOld->SizeOfRawData - (LONG)pObjResourceNew->SizeOfRawData;
        }
        cb = PatchRVAs(inpfh, outfh, pObjtblNew, cb, &New, Old.OptionalHeader.SizeOfHeaders);
    }

    /* copy NOTMAPPED debug info */
    if (pObjDebugDirOld != NULL && pObjDebug == NULL &&
        New.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size != 0)
    {
        ULONG ibt;

        ibSave = _llseek(inpfh, 0L, SEEK_END);  /* copy debug data */
        ibt = _llseek(outfh, 0L, SEEK_END);     /* to EOF */
        if (New.FileHeader.PointerToSymbolTable != 0)
            New.FileHeader.PointerToSymbolTable += ibt - adjust;
        MuMoveFilePos(inpfh, adjust);   /* returned by PatchDebug */
        MuCopy(inpfh, outfh, ibSave-adjust);
    }

    /*
     * Write updated PE header
     */
    MuMoveFilePos(outfh, (long)cbOldexe);
    MuWrite(outfh, (char*)&New, sizeof(IMAGE_NT_HEADERS));

    /* free up allocated memory */
    GodotHeapFree( pObjtblOld);
    GodotHeapFree( pResTab);

AbortExit:
    GodotHeapFree( pObjtblNew);
    return cb;
}


/***************************************************************************
 * WriteResSection
 *
 * This routine writes out the resources asked for into the current section.
 * It pads resources to dword (4-byte) boundaries.
 **************************************************************************/

PRESNAME WriteResSection(PUPDATEDATA pUpdate, INT outfh, ULONG align, ULONG cbLeft, PRESNAME pResSave)
{
    ULONG   cbB=0;            /* bytes in current section    */
    ULONG   cbT;            /* bytes in current section    */
    ULONG   size;
    PRESNAME    pRes;
    PRESTYPE    pType;
    BOOL        fName;
    PVOID       lpData;

    /* Output contents associated with each resource */
    pType = pUpdate->ResTypeHeadName;
    while (pType) {
    pRes = pType->NameHeadName;
    fName = TRUE;
loop1:
    for ( ; pRes ; pRes = pRes->pnext)
    {
        if (pResSave != NULL && pRes != pResSave)
            continue;
        pResSave = NULL;
        lpData = (PVOID)pRes->OffsetToDataEntry;

        /* if there is room in the current section, write it there */
        size = pRes->DataSize;
        if (cbLeft != 0 && cbLeft >= size) /* resource fits?   */
        {
            MuWrite(outfh, lpData, size);
            /* pad resource     */
            cbT = REMAINDER(size, CBLONG);
            MuWrite(outfh, pchPad, cbT);    /* dword    */
            cbB += size + cbT;
            cbLeft -= size + cbT;       /* less left    */
            continue;       /* next resource    */
        }
        else /* will fill up section    */
        {
            goto write_pad;
        }
    }
    if (fName)
    {
        fName = FALSE;
        pRes = pType->NameHeadID;
        goto loop1;
    }
    pType = pType->pnext;
    }

    pType = pUpdate->ResTypeHeadID;
    while (pType) 
    {
        pRes = pType->NameHeadName;
        fName = TRUE;
loop2:
        for ( ; pRes ; pRes = pRes->pnext)
        {
            if (pResSave != NULL && pRes != pResSave)
                continue;
            pResSave = NULL;
            lpData = (PVOID)pRes->OffsetToDataEntry;

            /* if there is room in the current section, write it there */
            size = pRes->DataSize;
            if (cbLeft != 0 && cbLeft >= size) /* resource fits?   */
            {
                MuWrite(outfh, lpData, size);
                /* pad resource     */
                cbT = REMAINDER(size, CBLONG);
                MuWrite(outfh, pchPad, cbT);    /* dword    */
                cbB += size + cbT;
                cbLeft -= size + cbT;       /* less left    */
                continue;       /* next resource    */
            }
            else /* will fill up section    */
            {
                goto write_pad;
            }
        }
        if (fName)
        {
            fName = FALSE;
            pRes = pType->NameHeadID;
            goto loop2;
        }
        pType = pType->pnext;
    }
    pRes = NULL;

write_pad:
    /* pad to alignment boundary */
    cbB = FilePos(outfh);
    cbT = ROUNDUP(cbB, align);
    cbLeft = cbT - cbB;
    if (cbLeft != 0)
    {
        while (cbLeft >= cbPadMax)
        {
            MuWrite(outfh, pchPad, cbPadMax);
            cbLeft -= cbPadMax;
        }
        MuWrite(outfh, pchPad, cbLeft);
    }
    return pRes;
}

LONG PatchDebug(int inpfh, int outfh, PIMAGE_SECTION_HEADER pDebugOld, PIMAGE_SECTION_HEADER pDebugNew,
                PIMAGE_SECTION_HEADER pDebugDirOld, PIMAGE_SECTION_HEADER pDebugDirNew,
                PIMAGE_NT_HEADERS pOld, PIMAGE_NT_HEADERS pNew, ULONG ibMaxDbgOffsetOld,
                PULONG pPointerToRawData)
//
// adjust debug directory table
//
{
    PIMAGE_DEBUG_DIRECTORY pDbgLast;
    PIMAGE_DEBUG_DIRECTORY pDbgSave;
    PIMAGE_DEBUG_DIRECTORY pDbg;
    ULONG       ib;
    ULONG       adjust;
    ULONG       ibNew;

    if (pDebugDirOld == NULL || pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size==0)
        return NO_ERROR;

    pDbg = (PIMAGE_DEBUG_DIRECTORY)GodotHeapAlloc(pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size);
    pDbgSave = pDbg;
    if (pDbg == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;

    if (pDebugOld)
    {
    }
    else
        adjust = *pPointerToRawData;    /* passed in EOF of new file */

    ib = pOld->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress - pDebugDirOld->VirtualAddress;
    MuMoveFilePos(inpfh, pDebugDirOld->PointerToRawData+ib);
    pDbgLast = pDbg + (pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size)/sizeof(IMAGE_DEBUG_DIRECTORY);
    MuRead(inpfh, (PUCHAR)pDbg, pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size);

    if (pDebugOld == NULL)
    {
        /* find 1st entry - use for offset */
        for (ibNew=0xffffffff ; pDbg<pDbgLast ; pDbg++)
            if (pDbg->PointerToRawData >= ibMaxDbgOffsetOld && pDbg->PointerToRawData < ibNew)
                ibNew = pDbg->PointerToRawData;

        if (ibNew != 0xffffffff)
            *pPointerToRawData = ibNew;
        else
            *pPointerToRawData = _llseek(inpfh, 0L, SEEK_END);

        for (pDbg=pDbgSave ; pDbg<pDbgLast ; pDbg++)
        {
            if (pDbg->PointerToRawData >= ibMaxDbgOffsetOld) 
                pDbg->PointerToRawData += adjust - ibNew;
        }
    }
    else
    {
        for ( ; pDbg<pDbgLast ; pDbg++)
        {
            pDbg->AddressOfRawData += pDebugNew->VirtualAddress - pDebugOld->VirtualAddress;
            pDbg->PointerToRawData += pDebugNew->PointerToRawData - pDebugOld->PointerToRawData;
        }
    }

    MuMoveFilePos(outfh, pDebugDirNew->PointerToRawData+ib);
    MuWrite(outfh, (PUCHAR)pDbgSave, pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size);
    GodotHeapFree(pDbgSave);

    return NO_ERROR;
}


//
// This routine patches various RVAs in the file to compensate
// for extra section table entries.
//
LONG PatchRVAs(int inpfh, int outfh, PIMAGE_SECTION_HEADER po32, 
               ULONG pagedelta, PIMAGE_NT_HEADERS pNew, ULONG OldSize)
{
    ULONG hdrdelta;
    ULONG offset, rvaiat, offiat, iat;
    IMAGE_EXPORT_DIRECTORY Exp;
    IMAGE_IMPORT_DESCRIPTOR Imp;
    ULONG i, cmod, cimp;

    hdrdelta = pNew->OptionalHeader.SizeOfHeaders - OldSize;
    if (hdrdelta == 0)
    {
        return NO_ERROR;
    }

    //
    // Patch export section RVAs
    //
    offset = ((pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress) == 0);
    if (offset < pNew->OptionalHeader.SizeOfHeaders)
    {
        MuMoveFilePos(inpfh, offset - hdrdelta);
        MuRead(inpfh, (PUCHAR) &Exp, sizeof(Exp));
        Exp.Name += hdrdelta;
        (ULONG)Exp.AddressOfFunctions += hdrdelta;
        (ULONG)Exp.AddressOfNames += hdrdelta;
        (ULONG)Exp.AddressOfNameOrdinals += hdrdelta;
        MuMoveFilePos(outfh, offset);
        MuWrite(outfh, (PUCHAR) &Exp, sizeof(Exp));
    }

    //
    // Patch import section RVAs
    //
    offset = ((pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress) == 0);
    if (offset < pNew->OptionalHeader.SizeOfHeaders)
    {
        for (cimp = cmod = 0; ; cmod++)
        {
            MuMoveFilePos(inpfh, offset + cmod * sizeof(Imp) - hdrdelta);
            MuRead(inpfh, (PUCHAR) &Imp, sizeof(Imp));
            if (Imp.FirstThunk == 0)
            {
                break;
            }
            Imp.Name += hdrdelta;
            MuMoveFilePos(outfh, offset + cmod * sizeof(Imp));
            MuWrite(outfh, (PUCHAR) &Imp, sizeof(Imp));

            rvaiat = (ULONG)Imp.FirstThunk;
            for (i = 0; i < pNew->FileHeader.NumberOfSections; i++)
            {
                if (rvaiat >= po32[i].VirtualAddress && 
                    rvaiat < po32[i].VirtualAddress + po32[i].SizeOfRawData)
                {
                    offiat = rvaiat - po32[i].VirtualAddress + po32[i].PointerToRawData;
                    goto found;
                }
            }
            return ERROR_INVALID_DATA;
found:
            MuMoveFilePos(inpfh, offiat - pagedelta);
            MuMoveFilePos(outfh, offiat);
            for (;;)
            {
                MuRead(inpfh, (PUCHAR) &iat, sizeof(iat));
                if (iat == 0)
                {
                    break;
                }
                if ((iat & IMAGE_ORDINAL_FLAG) == 0) // if import by name
                {
                    iat += hdrdelta;
                    cimp++;
                }
                MuWrite(outfh, (PUCHAR) &iat, sizeof(iat)); // Avoids seeking
            }
        }
    }

    return NO_ERROR;

}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  WriteResFile() -                                                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/
LONG WriteResFile(HANDLE hUpdate, WCHAR *pDstname)
{
    INT         inpfh;
    INT         outfh;
    ULONG       onewexe;
    IMAGE_DOS_HEADER    oldexe;
    PUPDATEDATA pUpdate;
    INT         rc;
    WCHAR       *pFilename;

    pUpdate = (PUPDATEDATA)GlobalLock(hUpdate);
    pFilename = (WCHAR*)GlobalLock(pUpdate->hFileName);

    /* open the original exe file */
    inpfh = (INT)CreateFileW(pFilename, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    GlobalUnlock(pUpdate->hFileName);
    if (inpfh == -1)
    {
        GlobalUnlock(hUpdate);
        return ERROR_OPEN_FAILED;
    }

    /* read the old format EXE header */
    rc = _lread(inpfh, (char*)&oldexe, sizeof(oldexe));
    if (rc != sizeof(oldexe))
    {
        _lclose(inpfh);
        GlobalUnlock(hUpdate);
        return ERROR_READ_FAULT;
    }

    /* make sure its really an EXE file */
    if (oldexe.e_magic != IMAGE_DOS_SIGNATURE)
    {
        _lclose(inpfh);
        GlobalUnlock(hUpdate);
        return ERROR_INVALID_EXE_SIGNATURE;
    }

    /* make sure theres a new EXE header floating around somewhere */
    if (!(onewexe = oldexe.e_lfanew))
    {
        _lclose(inpfh);
        GlobalUnlock(hUpdate);
        return ERROR_BAD_EXE_FORMAT;
    }

    outfh = (INT)CreateFileW(pDstname, GENERIC_READ|GENERIC_WRITE, 0, NULL, 
                             CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (outfh != -1)
    {
        rc = PEWriteResFile(inpfh, outfh, onewexe, pUpdate);
        _lclose(outfh);
    }
    _lclose(inpfh);
    GlobalUnlock(hUpdate);
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\godot\usermsgs.c ===
/*++

Copyright (c) 2000-2001,  Microsoft Corporation  All rights reserved.

Module Name:

    usermsgs.c

    APIs found in this file:
        GodotDoCallback
        GodotTransmitMessage
        GodotReceiveMessage
        GodotDispatchMessage

    Helper functions
        MapCatureMessage
        TransmitHelper

        This function does not currently handle ANSI caller to a UNICODE window.
        All other calls are handled properly.


        CONSIDER: To fully implement the capture window stuff, we would
                  need to support these callback functions:

            capErrorCallback
            capStatusCallback

Revision History:

    6 Feb 2001    v-michka    Created.

--*/

#include "precomp.h"

// Internal MFC messages
#define WM_SETMESSAGESTRING 0x0362  // wParam = nIDS (or 0),
                                    // lParam = lpszOther (or NULL)

// Must dynamically link to "BroadcastSystemMessage" because it 
// does not exist as "BroadcastSystemMessageA" on all platforms. 
typedef BOOL (__stdcall *PFNbsma) (DWORD, LPDWORD, UINT, WPARAM, LPARAM);
static PFNbsma s_pfnBSMA;

// forward declares
LRESULT TransmitHelper(MESSAGETYPES mt, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, 
                       WNDPROC lpPrevWndFunc, SENDASYNCPROC lpCallBack, ULONG_PTR dwData, 
                       UINT fuFlags, UINT uTimeout, PDWORD_PTR lpdwResult);

/*-------------------------------
    MapCaptureMessage

    Simple function that maps one message type to 
    another (A->W and W->A) for video captures
-------------------------------*/
UINT MapCaptureMessage(UINT uMsg)
{
    if(uMsg >= WM_CAP_UNICODE_START)
        return(uMsg - WM_CAP_UNICODE_START);
    else
        return(uMsg + WM_CAP_UNICODE_START);
}

/*-------------------------------
    GodotDoCallback

    Our global wrapper around callback functions; all callbacks that need random
    conversions done go through this proc. Note that all callers will be Unicode
    windows so we do not have to check for this here.
-------------------------------*/
LRESULT GodotDoCallback(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, WNDPROC lpfn, BOOL fUniSrc, FAUXPROCTYPE fpt)
{
    LRESULT RetVal = 0;
    BOOL fUniDst;

    fUniDst = (! DoesProcExpectAnsi(hWnd, lpfn, fpt));

    if(!fUniDst && !fUniSrc)
    {
        // Call through via CallWindowProcA with no conversion

        // Note that this is the only place in this entire function where we use
        // CallWindowProc, since either the user or the system is expecting ANSI.
        // Note that on Win9x, the base wndproc can be a thunked function sitting
        // in USER.EXE; only CallWindowProcA can manage that sort of detail.
        return(CallWindowProcA(lpfn, hWnd, uMsg, wParam, lParam));
    }
    else if(fUniDst && fUniSrc)
    {
        // Pure Unicode: Call directly, no conversion needed
        // Note that we do not currently use this!!!
        return((* lpfn)(hWnd, uMsg, wParam, lParam));
    }
    else if(!fUniDst && fUniSrc)
    {
        // We need to convert from Unicode to ANSI, so use
        // our own GodotTransmitMessage to do the work.
        return(GodotTransmitMessage(mtCallWindowProc, hWnd, uMsg, wParam, lParam, lpfn, 0, 0, 0, 0, 0));
    }
    else // (fUniDst && !fUniSrc)
    {
        switch(uMsg)
        {

            case WM_CHAR:
            case EM_SETPASSWORDCHAR:
            case WM_DEADCHAR:
            case WM_SYSCHAR:
            case WM_SYSDEADCHAR:
            case WM_MENUCHAR:
                if(FDBCS_CPG(g_acp))
                {
                    WPARAM wParamW = 0;
                    static CHAR s_ch[3] = "\0";
                    // We have to go through all this nonsense because DBCS characters 
                    // arrive one byte at a time. Most of this code is never used because 
                    // DBCS chars OUGHT to be handled by WM_IME_CHAR below. 
                    if(!s_ch[0])
                    {
                        // No lead byte already waiting for trail byte
                        s_ch[0] = *(char *)wParam;
                        if(IsDBCSLeadByteEx(g_acp, *(char *)wParam)) 
                        {
                            // This is a lead byte. Save it and wait for trail byte
                            RetVal = FALSE;
                        }
                        // Not a DBCS character. Convert to Unicode.
                        MultiByteToWideChar(g_acp, 0, s_ch, 1, (WCHAR *)&wParamW, 1);

                        // Reset to indicate no Lead byte waiting
                        s_ch[0] = 0 ;
                        RetVal = TRUE;
                    }
                    else 
                    {
                        // Have lead byte, wParam should contain the trail byte
                        s_ch[1] = *(char *)wParam;
                        // Convert both bytes into one Unicode character
                        MultiByteToWideChar(g_acp, 0, s_ch, 2, (WCHAR *)&wParamW, 1);

                        // Reset to non-waiting state
                        s_ch[0] = 0;
                        RetVal = TRUE;
                    }
                    break;
                }

                // Not a DBCS system, so fall through here 

            case WM_IME_CHAR:
            case WM_IME_COMPOSITION:
            {
                WPARAM wParamW = 0;
                MultiByteToWideChar(g_acp, 0, (CHAR *)&wParam, g_mcs, (WCHAR *)&wParamW, 1);
                RetVal = (* lpfn)(hWnd, uMsg, wParamW, lParam);
                WideCharToMultiByte(g_acp, 0, (WCHAR *)&wParamW, 1, (CHAR *)&wParam, g_mcs, NULL, NULL);
                break;
            }

            case WM_CHARTOITEM:
            {
                // Mask off the hiword bits, convert, then stick the hiword bits back on.
                WPARAM wParamW = 0;
                WPARAM wpT = wParam & 0xFFFF;
                MultiByteToWideChar(g_acp, 0, (CHAR *)&wpT, g_mcs, (WCHAR *)&wParamW, 1);
                RetVal = (* lpfn)(hWnd, uMsg, wParamW, lParam);
                WideCharToMultiByte(g_acp, 0, (WCHAR *)&wParamW, 1, (CHAR *)&wpT, g_mcs, NULL, NULL);
                wParam = MAKELONG(LOWORD(wpT),HIWORD(wParam));
                break;
            }

            case (WM_USER + 25):    // might be WM_CAP_FILE_SAVEDIBA
            case (WM_USER + 23):    // might be WM_CAP_FILE_SAVEASA
            case (WM_USER + 66):    // might be WM_CAP_SET_MCI_DEVICEA
            case (WM_USER + 80):    // might be WM_CAP_PAL_OPENA
            case (WM_USER + 81):    // might be WM_CAP_PAL_SAVEA
            case (WM_USER + 20):    // might be WM_CAP_FILE_SET_CAPTURE_FILEA
                if(!IsCaptureWindow(hWnd))
                {
                    // The numbers are right, but its not a capture window, so
                    // do not convert. Instead, just pass as is.
                    RetVal = (* lpfn)(hWnd, uMsg, wParam, lParam);
                }
                else
                {
                    // No memory? If the alloc fails, we eat the results.
                    LPARAM lParamW;
                    ALLOCRETURN ar = GodotToUnicodeOnHeap((LPSTR)lParam, &(LPWSTR)lParamW);
                    RetVal = (* lpfn)(hWnd, MapCaptureMessage(uMsg), wParam, lParamW);
                    if(ar == arAlloc)
                        GodotHeapFree((LPWSTR)lParamW);
                }
                break;

            case CB_ADDSTRING:
            case CB_DIR:
            case CB_FINDSTRING:
            case CB_FINDSTRINGEXACT:
            case CB_INSERTSTRING:
            case CB_SELECTSTRING:
            {
                LONG styl = GetWindowLongA(hWnd, GWL_STYLE);
                if(((styl & CBS_OWNERDRAWFIXED) || 
                   (styl & CBS_OWNERDRAWVARIABLE)) &&
                   (!(styl & CBS_HASSTRINGS)))
                {
                    // Owner draw combo box which does not have strings stored
                    // (See Windows Bugs # 356304 for details here)
                    RetVal = (* lpfn)(hWnd, uMsg, wParam, lParam);
                }
                else
                {
                    // No memory? If the alloc fails, we eat the results.
                    LPARAM lParamW;
                    ALLOCRETURN ar = GodotToUnicodeOnHeap((LPSTR)lParam, &(LPWSTR)lParamW);
                    RetVal = (* lpfn)(hWnd, uMsg, wParam, lParamW);
                    if(ar == arAlloc)
                        GodotHeapFree((LPWSTR)lParamW);
                }
            }
                break;

            case LB_ADDSTRING:
            case LB_ADDFILE:
            case LB_DIR:
            case LB_FINDSTRING:
            case LB_FINDSTRINGEXACT:
            case LB_INSERTSTRING:
            case LB_SELECTSTRING:
            {
                LONG styl = GetWindowLongA(hWnd, GWL_STYLE);
                if(((styl & LBS_OWNERDRAWFIXED) || 
                   (styl & LBS_OWNERDRAWVARIABLE)) &&
                   (!(styl & LBS_HASSTRINGS)))
                {
                    // Owner draw listbox which does not have strings stored
                    // (See Windows Bugs # 356304 for details here)
                    RetVal = (* lpfn)(hWnd, uMsg, wParam, lParam);
                }
                else
                {
                    // No memory? If the alloc fails, we eat the results.
                    LPARAM lParamW;
                    ALLOCRETURN ar = GodotToUnicodeOnHeap((LPSTR)lParam, &(LPWSTR)lParamW);
                    RetVal = (* lpfn)(hWnd, uMsg, wParam, lParamW);
                    if(ar == arAlloc)
                        GodotHeapFree((LPWSTR)lParamW);
                }
                break;
            }
            case EM_REPLACESEL:
            case WM_SETTEXT:
            case WM_DEVMODECHANGE:
            case WM_SETTINGCHANGE:
            case WM_SETMESSAGESTRING: // MFC internal msg
            {
                // No memory? If the alloc fails, we eat the results.
                LPARAM lParamW;
                ALLOCRETURN ar = GodotToUnicodeOnHeap((LPSTR)lParam, &(LPWSTR)lParamW);
                RetVal = (* lpfn)(hWnd, uMsg, wParam, lParamW);
                if(ar == arAlloc)
                    GodotHeapFree((LPWSTR)lParamW);
                break;
            }

            case WM_DDE_EXECUTE:
                // wParam is the client window hWnd, lParam is the command LPTSTR.
                // Only convert lParam if both client and server windows are Unicode
                if(GetUnicodeWindowProp((HWND)hWnd) && GetUnicodeWindowProp((HWND)wParam))
                {
                    // No memory? If the alloc fails, we eat the results.
                    LPARAM lParamW;
                    ALLOCRETURN ar = GodotToUnicodeOnHeap((LPSTR)lParam, &(LPWSTR)lParamW);
                    RetVal = (* lpfn)(hWnd, uMsg, wParam, lParamW);
                    if(ar == arAlloc)
                        GodotHeapFree((LPWSTR)lParamW);
                }
                else
                    RetVal = (* lpfn)(hWnd, uMsg, wParam, lParam);
                break;
            
            case EM_GETLINE:
            {
                // lParam is a pointer to the buffer that receives a copy of the line. Before 
                // sending the message, set the first word of this buffer to the size, in TCHARs, 
                // of the buffer. For ANSI text, this is the number of bytes; for Unicode text, 
                // this is the numer of characters. The size in the first word is overwritten by 
                // the copied line. 
                size_t cchlParam = (WORD)lParam + 1;
                LPARAM lParamW = (LPARAM)(LPWSTR)GodotHeapAlloc(cchlParam * sizeof(WCHAR));

                if(RetVal = (* lpfn)(hWnd, uMsg, wParam, lParamW))
                {
                    RetVal = WideCharToMultiByte(g_acp, 
                                                 0, 
                                                 (LPWSTR)lParamW, 
                                                 RetVal + 1, 
                                                 (LPSTR)lParam, 
                                                 cchlParam, 
                                                 NULL, 
                                                 NULL);
                    if(RetVal)
                        RetVal--;
                }
                else
                {
                    if((LPSTR)lParam)
                        *((LPSTR)lParam) = '\0';
                }

                if(lParamW)
                    GodotHeapFree((LPWSTR)lParamW);

            }
            case LB_GETTEXT:
            {
                // lParam is a pointer to the buffer that will receive the string; it is type 
                // LPTSTR which is subsequently cast to an LPARAM. The buffer must have sufficient 
                // space for the string and a terminating null character. An LB_GETTEXTLEN message 
                // can be sent before the LB_GETTEXT message to retrieve the length, in TCHARs, of 
                // the string. 
                size_t cchlParam = SendMessageA(hWnd, LB_GETTEXTLEN, wParam, 0) + 1;
                LPARAM lParamW = (LPARAM)(LPWSTR)GodotHeapAlloc(cchlParam * sizeof(WCHAR));

                if(RetVal = (* lpfn)(hWnd, uMsg, wParam, lParamW))
                {
                    RetVal = WideCharToMultiByte(g_acp, 
                                                 0, 
                                                 (LPWSTR)lParamW, 
                                                 RetVal + 1, 
                                                 (LPSTR)lParam, 
                                                 cchlParam, 
                                                 NULL, 
                                                 NULL);
                    if(RetVal)
                        RetVal--;
                }
                else
                {
                    if((LPSTR)lParam)
                        *((LPSTR)lParam) = '\0';
                }

                if(lParamW)
                    GodotHeapFree((LPWSTR)lParamW);

                break;
            }

            case CB_GETLBTEXT:
            {
                // lParam is a pointer to the buffer that will receive the string; it is type 
                // LPTSTR which is subsequently cast to an LPARAM. The buffer must have sufficient 
                // space for the string and a terminating null character. An CB_GETLBTEXTLEN message 
                // can be sent before the CB_GETLBTEXT message to retrieve the length, in TCHARs, of 
                // the string. 
                size_t cchlParam = SendMessageA(hWnd, CB_GETLBTEXTLEN, wParam, 0) + 1;
                LPARAM lParamW = (LPARAM)(LPWSTR)GodotHeapAlloc(cchlParam * sizeof(WCHAR));

                if((RetVal = (* lpfn)(hWnd, uMsg, wParam, lParamW)) && lParamW)
                {
                    RetVal = WideCharToMultiByte(g_acp, 
                                                 0, 
                                                 (LPWSTR)lParamW, 
                                                 RetVal + 1, 
                                                 (LPSTR)lParam, 
                                                 cchlParam, 
                                                 NULL, 
                                                 NULL);
                    if(RetVal)
                        RetVal--;
                }
                else
                {
                    if((LPSTR)lParam)
                        *((LPSTR)lParam) = '\0';
                }

                if(lParamW)
                    GodotHeapFree((LPWSTR)lParamW);

                break;
            }

            case (WM_USER + 67):    // might be WM_CAP_GET_MCI_DEVICEA
            case (WM_USER + 12):    // might be WM_CAP_DRIVER_GET_NAMEA
            case (WM_USER + 13):    // might be WM_CAP_DRIVER_GET_VERSIONA
            case (WM_USER + 21):    // might be WM_CAP_FILE_GET_CAPTURE_FILEA
                if(!IsCaptureWindow(hWnd))
                {
                    // The numbers are right, but its not a capture window, so
                    // do not convert. Instead, just pass as is.
                    RetVal = (* lpfn)(hWnd, uMsg, wParam, lParam);
                    break;
                }

                // If we are still here, then it is a capture message. 
                // So lets map it and fall through.
                uMsg = MapCaptureMessage(uMsg);

            case WM_GETTEXT:
            case WM_ASKCBFORMATNAME:
            {
                // wParam specifies the buffer size of the string lParam (includes the terminating null).
                LPARAM lParamW = (LPARAM)(LPWSTR)GodotHeapAlloc((UINT)wParam * sizeof(WCHAR));

                if(RetVal = (* lpfn)(hWnd, uMsg, wParam, lParamW))
                {
                    RetVal = WideCharToMultiByte(g_acp, 
                                                 0, 
                                                 (LPWSTR)lParamW, 
                                                 RetVal + 1, 
                                                 (LPSTR)lParam, 
                                                 (UINT)wParam, 
                                                 NULL, 
                                                 NULL);
                    if(RetVal)
                        RetVal--;
                }
                else
                {
                    if((LPSTR)lParam)
                        *((LPSTR)lParam) = '\0';
                }

                if(lParamW)
                    GodotHeapFree((LPWSTR)lParamW);

                break;
            }

            case (WM_USER + 1):
                if(IsFontDialog(hWnd))
                {
                    // This is a WM_CHOOSEFONT_GETLOGFONT msg
                    LPARAM lParamW = (LPARAM)(LPLOGFONTW)GodotHeapAlloc(sizeof(LOGFONTW));
                    RetVal = (* lpfn)(hWnd, uMsg, wParam, lParamW);
                    LogFontAfromW((LPLOGFONTA)lParam, (LPLOGFONTW)lParamW);
                    if(lParamW)
                        GodotHeapFree((LPWSTR)lParamW);
                }
                else
                {
                    // This would be one of the common control msgs we do not handle
                    RetVal = (* lpfn)(hWnd, uMsg, wParam, lParam);
                    break;
                }
                break;

            case (WM_USER + 100):
                if(IsNewFileOpenDialog(hWnd))
                {
                    // This is a CDM_GETSPEC msg
                    LPARAM lParamW = (LPARAM)(LPWSTR)GodotHeapAlloc(wParam * sizeof(WCHAR));
                    RetVal = (* lpfn)(hWnd, uMsg, wParam, lParamW);
                    WideCharToMultiByte(g_acp, 0, 
                                        (LPWSTR)lParamW, wParam, 
                                        (LPSTR)lParam, wParam, 
                                        NULL, NULL);
                    RetVal = lstrlenA( (LPSTR)lParam);
                    if(lParamW)
                        GodotHeapFree((LPWSTR)lParamW);
                }
                else
                {
                    RetVal = (* lpfn)(hWnd, uMsg, wParam, lParam);
                }
                break;

            case (WM_USER + 101):
                if(IsFontDialog(hWnd))
                {
                    // This is a WM_CHOOSEFONT_SETLOGFONT msg
                    LPARAM lParamW = (LPARAM)(LPLOGFONTW)GodotHeapAlloc(sizeof(LOGFONTW));
                    LogFontWfromA((LPLOGFONTW)lParamW, (LPLOGFONTA)lParam);
                    RetVal = (* lpfn)(hWnd, uMsg, wParam, lParamW);
                    if(lParamW)
                        GodotHeapFree((LPLOGFONTW)lParamW);
                }
                else if(IsNewFileOpenDialog(hWnd))
                {
                    // This is a CDM_GETFILEPATH msg
                    LPARAM lParamW = (LPARAM)(LPWSTR)GodotHeapAlloc(wParam * sizeof(WCHAR));
                    RetVal = (* lpfn)(hWnd, uMsg, wParam, lParamW);
                    WideCharToMultiByte(g_acp, 0, 
                                        (LPWSTR)lParamW, wParam, 
                                        (LPSTR)lParam, wParam, 
                                        NULL, NULL);
                    RetVal = lstrlenA( (LPSTR)lParam);
                    if(lParamW)
                        GodotHeapFree((LPWSTR)lParamW);
                }
                else
                {
                    RetVal = (* lpfn)(hWnd, uMsg, wParam, lParam);
                }
                break;

            case (WM_USER + 102):
                if(IsFontDialog(hWnd))
                {
                    // This is a WM_CHOOSEFONT_SETFLAGS msg
                    // The docs claim that lParam has a CHOOSEFONT struct but the code shows
                    // that it only has the Flags in it, so pass it as is
                    RetVal = (* lpfn)(hWnd, uMsg, wParam, lParam);
                }
                else if(IsNewFileOpenDialog(hWnd))
                {
                    // This is a CDM_GETFOLDERPATH
                    // lParam is a buffer for the path of the open folder
                    LPARAM lParamW = (LPARAM)(LPWSTR)GodotHeapAlloc(wParam * sizeof(WCHAR));
                    RetVal = (* lpfn)(hWnd, uMsg, wParam, lParamW);
                    WideCharToMultiByte(g_acp, 0, 
                                        (LPWSTR)lParamW, wParam, 
                                        (LPSTR)lParam, wParam, 
                                        NULL, NULL);
                    RetVal = lstrlenA( (LPSTR)lParam);
                    if(lParamW)
                        GodotHeapFree((LPWSTR)lParamW);
                }
                else
                {
                    RetVal = (* lpfn)(hWnd, uMsg, wParam, lParam);
                }
                break;

            case (WM_USER + 104):
                if(IsNewFileOpenDialog(hWnd))
                {
                    // This is a CDM_SETCONTROLTEXT message
                    // lParam is the control text (wParam is the control ID)

                    // No memory? If the alloc fails, we eat the results.
                    LPARAM lParamW;
                    WPARAM wParamW;
                    ALLOCRETURN ar = GodotToUnicodeOnHeap((LPSTR)lParam, &(LPWSTR)lParamW);
                    wParamW = gwcslen((LPWSTR)lParamW);
                    RetVal = (* lpfn)(hWnd, uMsg, wParamW, lParamW);
                    if(ar == arAlloc)
                        GodotHeapFree((LPWSTR)lParamW);
                }
                else
                {
                    RetVal = (* lpfn)(hWnd, uMsg, wParam, lParam);
                }
                break;

            case (WM_USER + 106):
                if(IsNewFileOpenDialog(hWnd))
                {
                    // This is a CDM_SETDEFEXT message
                    // lParam is the extension

                    // No memory? If the alloc fails, we eat the results.
                    LPARAM lParamW;
                    WPARAM wParamW;
                    ALLOCRETURN ar = GodotToUnicodeOnHeap((LPSTR)lParam, &(LPWSTR)lParamW);
                    wParamW = gwcslen((LPWSTR)lParamW);
                    RetVal = (* lpfn)(hWnd, uMsg, wParamW, lParamW);
                    if(ar == arAlloc)
                        GodotHeapFree((LPWSTR)lParamW);
                }
                else
                {
                    RetVal = (* lpfn)(hWnd, uMsg, wParam, lParam);
                }
                break;


            case WM_CREATE:
            case WM_NCCREATE:
            {
                LPCREATESTRUCTA lpcsA = (LPCREATESTRUCTA)lParam;
                CREATESTRUCTW cs;
                ALLOCRETURN arName = arNoAlloc;
                ALLOCRETURN arClass = arNoAlloc;

                ZeroMemory(&cs, sizeof(CREATESTRUCTW));
                cs.lpCreateParams   = lpcsA->lpCreateParams;
                cs.hInstance        = lpcsA->hInstance;
                cs.hMenu            = lpcsA->hMenu;
                cs.hwndParent       = lpcsA->hwndParent;
                cs.cy               = lpcsA->cy;
                cs.cx               = lpcsA->cx;
                cs.y                = lpcsA->y;
                cs.x                = lpcsA->x;
                cs.style            = lpcsA->style;
                cs.dwExStyle        = lpcsA->dwExStyle;
                arName = GodotToUnicodeOnHeap(lpcsA->lpszName, &(LPWSTR)(cs.lpszName));
                arClass = GodotToUnicodeOnHeap(lpcsA->lpszClass, &(LPWSTR)(cs.lpszClass));
            
                RetVal = (* lpfn)(hWnd, uMsg, wParam, (LPARAM)&cs);

                // Free up strings if we allocated any
                if(arName==arAlloc)
                    GodotHeapFree((LPWSTR)(cs.lpszName));
                if(arClass==arAlloc)
                    GodotHeapFree((LPWSTR)(cs.lpszClass));
                break;
            }

            case WM_MDICREATE:
            {
                // wParam is not used, lParam is a pointer to an MDICREATESTRUCT structure containing 
                // information that the system uses to create the MDI child window. 
                LPMDICREATESTRUCTA lpmcsiA = (LPMDICREATESTRUCTA)lParam;
                MDICREATESTRUCTW mcsi;
                ALLOCRETURN arTitle = arNoAlloc;
                ALLOCRETURN arClass = arNoAlloc;

                ZeroMemory(&mcsi, sizeof(MDICREATESTRUCTW));
                mcsi.hOwner = lpmcsiA->hOwner;
                mcsi.x      = lpmcsiA->x;
                mcsi.y      = lpmcsiA->y;
                mcsi.cx     = lpmcsiA->cx;
                mcsi.cy     = lpmcsiA->cy;
                mcsi.style  = lpmcsiA->style;
                mcsi.lParam = lpmcsiA->lParam;
                arTitle = GodotToUnicodeOnHeap(lpmcsiA->szTitle, &(LPWSTR)(mcsi.szTitle));
                arClass = GodotToUnicodeOnHeap(lpmcsiA->szClass, &(LPWSTR)(mcsi.szClass));

                RetVal = (* lpfn)(hWnd, uMsg, wParam, (LPARAM)&mcsi);

                // Free up strings if we allocated any
                if(arTitle==arAlloc)
                    GodotHeapFree((LPWSTR)(mcsi.szTitle));
                if(arClass==arAlloc)
                    GodotHeapFree((LPWSTR)(mcsi.szClass));

                break;
            }

            case WM_DEVICECHANGE:
            {
                switch(wParam)
                {
                    case DBT_CUSTOMEVENT:
                    case DBT_DEVICEARRIVAL:
                    case DBT_DEVICEQUERYREMOVE:
                    case DBT_DEVICEQUERYREMOVEFAILED:
                    case DBT_DEVICEREMOVECOMPLETE:
                    case DBT_DEVICEREMOVEPENDING:
                    case DBT_DEVICETYPESPECIFIC:
                    {
                        // lParam contains info about the device. We interrogate it as if it were
                        // a PDEV_BROADCAST_HDR in order to find out what it really is, then convert
                        // as needed
                        if (((PDEV_BROADCAST_HDR)lParam)->dbch_devicetype == DBT_DEVTYP_DEVICEINTERFACE)
                        {
                            PDEV_BROADCAST_DEVICEINTERFACE_A pdbdia = (PDEV_BROADCAST_DEVICEINTERFACE_A)lParam;
                            DEV_BROADCAST_DEVICEINTERFACE_W dbdi;
                            ALLOCRETURN arName = arNoAlloc;

                            ZeroMemory(&dbdi, sizeof(DEV_BROADCAST_DEVICEINTERFACE_W));
                            dbdi.dbcc_size          = sizeof(DEV_BROADCAST_DEVICEINTERFACE_W);
                            dbdi.dbcc_devicetype    = pdbdia->dbcc_devicetype;
                            dbdi.dbcc_reserved      = pdbdia->dbcc_reserved;
                            dbdi.dbcc_classguid     = pdbdia->dbcc_classguid;
                            arName = GodotToUnicodeOnHeap(pdbdia->dbcc_name, *(LPWSTR**)(dbdi.dbcc_name));

                            RetVal = (* lpfn)(hWnd, uMsg, wParam, (LPARAM)&dbdi);
                            if(arName==arAlloc)
                                GodotHeapFree(dbdi.dbcc_name);
                        }
                        else if(((PDEV_BROADCAST_HDR)lParam)->dbch_devicetype == DBT_DEVTYP_PORT)
                        {
                            PDEV_BROADCAST_PORT_A pdbpa = (PDEV_BROADCAST_PORT_A)lParam;
                            DEV_BROADCAST_PORT_W dbp;
                            ALLOCRETURN arName = arNoAlloc;

                            ZeroMemory(&dbp, sizeof(DEV_BROADCAST_PORT_W));
                            dbp.dbcp_size       = sizeof(DEV_BROADCAST_PORT_W);
                            dbp.dbcp_devicetype = pdbpa->dbcp_devicetype;
                            dbp.dbcp_reserved   = pdbpa->dbcp_reserved;
                            arName = GodotToUnicodeOnHeap(pdbpa->dbcp_name, *(LPWSTR**)(dbp.dbcp_name));

                            RetVal = (* lpfn)(hWnd, uMsg, wParam, (LPARAM)&dbp);
                            if(arName==arAlloc)
                                GodotHeapFree(dbp.dbcp_name);
                        }
                        else
                        {
                            // No changes needed! There are no strings in the other structures.
                            RetVal = (* lpfn)(hWnd, uMsg, wParam, lParam);
                        }
                        break;
                    }
                    case DBT_USERDEFINED: 
                        // No UNICODE string in this one, so fall through
                    
                    default:
                        RetVal = (* lpfn)(hWnd, uMsg, wParam, lParam);
                        break;
                }
                break;
            }

            default:
            {
                // Lets get our registered messages, if we haven't yet.
                if(!msgHELPMSGSTRING)
                    msgHELPMSGSTRING = RegisterWindowMessage(HELPMSGSTRINGA);
                if(!msgFINDMSGSTRING)
                    msgFINDMSGSTRING = RegisterWindowMessage(FINDMSGSTRINGA);

                if((uMsg == msgHELPMSGSTRING) && 
                    (((LPOPENFILENAMEA)lParam)->lStructSize == OPENFILENAME_SIZE_VERSION_400A))
                {
                    WCHAR drive[_MAX_DRIVE];
                    WCHAR dir[_MAX_DIR];
                    WCHAR file[_MAX_FNAME];
                    LPOPENFILENAMEA lpofnA = (LPOPENFILENAMEA)lParam;
                    OPENFILENAMEW ofn;
                    ALLOCRETURN arCustomFilter = arNoAlloc;
                    ALLOCRETURN arFile = arNoAlloc;
                    ALLOCRETURN arFileTitle = arNoAlloc;

                    // lParam is an LPOPENFILENAMEA to be converted. Copy all the
                    // members that the user might expect.
                    ZeroMemory(&ofn, OPENFILENAME_SIZE_VERSION_400W);
                    ofn.lStructSize         = OPENFILENAME_SIZE_VERSION_400W;
                    arCustomFilter          = GodotToUnicodeCpgCchOnHeap(lpofnA->lpstrCustomFilter,
                                                                         lpofnA->nMaxCustFilter,
                                                                         &ofn.lpstrCustomFilter,
                                                                         g_acp);
                    ofn.nMaxCustFilter      = gwcslen(ofn.lpstrCustomFilter);
                    ofn.nFilterIndex        = lpofnA->nFilterIndex;
                    ofn.nMaxFile            = lpofnA->nMaxFile * sizeof(WCHAR);
                    arFile                  = GodotToUnicodeCpgCchOnHeap(lpofnA->lpstrFile,
                                                                         lpofnA->nMaxFile,
                                                                         &ofn.lpstrFile,
                                                                         g_acp);
                    ofn.nMaxFile            = gwcslen(ofn.lpstrFile);
                    arFileTitle             = GodotToUnicodeCpgCchOnHeap(lpofnA->lpstrFileTitle,
                                                                         lpofnA->nMaxFileTitle,
                                                                         &ofn.lpstrFileTitle,
                                                                         g_acp);
                    ofn.nMaxFileTitle       = gwcslen(ofn.lpstrFileTitle);
                    ofn.Flags = lpofnA->Flags;

                    // nFileOffset and nFileExtension are to provide info about the
                    // file name and extension location in lpstrFile, but there is 
                    // no reasonable way to get it from the return so we just recalc
                    gwsplitpath(ofn.lpstrFile, drive, dir, file, NULL);
                    ofn.nFileOffset         = (gwcslen(drive) + gwcslen(dir));
                    ofn.nFileExtension      = ofn.nFileOffset + gwcslen(file);

                    RetVal = (*lpfn)(hWnd, uMsg, wParam, (LPARAM)&ofn);

                    // Free up some memory if we allocated any
                    if(arCustomFilter==arAlloc)
                        GodotHeapFree(ofn.lpstrCustomFilter);
                    if(arFile==arAlloc)
                        GodotHeapFree(ofn.lpstrFile);
                    if(arFileTitle==arAlloc)
                        GodotHeapFree(ofn.lpstrFileTitle);

                }
                else if(((uMsg == msgFINDMSGSTRING) || (uMsg == msgHELPMSGSTRING)) && 
                        ((((LPFINDREPLACEW)lParam)->lStructSize) == sizeof(FINDREPLACEA)))
                {
                    LPFINDREPLACEW lpfr = (LPFINDREPLACEW)lParam;

                    // lParam is an LPFINDREPLACEW that we passed on through. 
                    RetVal = (* lpfn)(hWnd, uMsg, wParam, lParam);

                    if((lpfr->Flags & FR_DIALOGTERM) &&
                       ((lpfr->lpfnHook == &FRHookProcFind) || (lpfr->lpfnHook == &FRHookProcReplace)))
                    {
                        // Now handle our cleanup. I do not think this should
                        // be needed, but it can't hurt to do it just in case.
                        LPGODOTTLSINFO lpgti = GetThreadInfoSafe(TRUE);

                        // They are destroying the dialog, so unhook ourselves
                        // and clean up the dialog (if we have not done it yet). 
                        if(lpfr->lpfnHook == &FRHookProcFind) 
                        {
                            // Find dialog, not yet cleaned up
                            lpfr->lpfnHook = lpgti->pfnFindText;
                            if(lpfr->lpfnHook == NULL)
                                lpfr->Flags &= ~FR_ENABLEHOOK;
                        }
                        else if(lpfr->lpfnHook == &FRHookProcReplace) 
                        {
                            // Replace dialog, not yet cleaned up
                            lpfr->lpfnHook = lpgti->pfnReplaceText;
                            if(lpfr->lpfnHook == NULL)
                                lpfr->Flags &= ~FR_ENABLEHOOK;
                        }
                    }
                }
                else if((uMsg == msgHELPMSGSTRING) && 
                        ((LPCHOOSEFONTA)lParam)->lStructSize == sizeof(CHOOSEFONTA))
                {
                    LPCHOOSEFONTA lpcfA = (LPCHOOSEFONTA)lParam;
                    CHOOSEFONTW cf;
                    LPARAM lParamW;
                    ALLOCRETURN ar = arNoAlloc;

                    // lParam is an LPCHOOSEFONTA to be converted. Copy all the
                    // members that the user might expect.
                    ZeroMemory(&cf, sizeof(CHOOSEFONTW));
                    cf.lStructSize  = sizeof(CHOOSEFONTW);
                    cf.hDC          = lpcfA->hDC;
                    LogFontWfromA(cf.lpLogFont, lpcfA->lpLogFont);
                    cf.iPointSize    = lpcfA->iPointSize;
                    cf.Flags        = lpcfA->Flags;
                    cf.rgbColors    = lpcfA->rgbColors;
                    cf.lCustData    = lpcfA->lCustData;
                    cf.nFontType    = lpcfA->nFontType;
                    cf.nSizeMin     = lpcfA->nSizeMin;
                    cf.nSizeMax     = lpcfA->nSizeMax;
                    ar = GodotToUnicodeOnHeap(lpcfA->lpszStyle, &(cf.lpszStyle));

                    lParamW = (LPARAM)&cf;

                    RetVal = (* lpfn)(hWnd, uMsg, wParam, lParamW);
                    if(ar==arAlloc)
                        GodotHeapFree((LPWSTR)cf.lpszStyle);
                }
                else
                {
                    // No translation needed, as far as we know.
                    RetVal = (* lpfn)(hWnd, uMsg, wParam, lParam);
                }
                break;
            }
        }
    return(RetVal);
    }
}

/*-------------------------------
    GodotTransmitMessage

    Our global wrapper for sending out messages (SendMessage, et. al.). 

    Its fundamental purpose: 

    1) Convert back to Ansi, as expected
    2) Call the function as specified by mt
    3) Convert to Unicode, as expected
-------------------------------*/
LRESULT GodotTransmitMessage(
    MESSAGETYPES mt,            // Type of message function
    HWND hWnd,                  // handle to window - overloaded for thread id in PostThreadMessage
    UINT Msg,                   // message
    WPARAM wParamW,             // first message parameter
    LPARAM lParamW,             // second message parameter
    WNDPROC lpPrevWndFunc,      // pointer to previous procedure - overloaded for multiple hook procs  
    SENDASYNCPROC lpCallBack,   // callback function
    ULONG_PTR dwData,           // application-defined value - overloaded for DefFrameProc as second hWnd
    UINT fuFlags,               // send options -- overloaded for BroadcastSystemMessages as dwFlags
    UINT uTimeout,              // time-out duration
    PDWORD_PTR lpdwResult       // retval for synch. -- overloaded BroadcastSystemMessages lpdwRecipients
)
{
    LRESULT retval = 0;
    WPARAM wParam = 0;
    LPARAM lParam = 0;
    size_t cchlParam;

    // Some flags we will need for our message handling
    BOOL fUnicodeProc = (! DoesProcExpectAnsi(hWnd, lpPrevWndFunc, fptUnknown));
    
    /*
        fUnicodeProc == Does the wndproc being called expect Unicode messages?
    */

    if((!fUnicodeProc) && (mt==mtCallWindowProcA) ||
        (fUnicodeProc) && ((mt==mtCallWindowProc)))
    {
        // The wndproc either expects ANSI and the caller has used one of the ANSI 
        // functions or it expects Unicode and they have used CallWindowProcW. In 
        // these cases, we do no conversions here
        retval = TransmitHelper(mt, hWnd, Msg, wParamW, lParamW, 
                                lpPrevWndFunc, lpCallBack, dwData, 
                                fuFlags, uTimeout, lpdwResult);
    }
    else
    {
        switch(Msg)
        {
            case WM_CHAR:
            case EM_SETPASSWORDCHAR:
            case WM_DEADCHAR:
            case WM_SYSCHAR:
            case WM_SYSDEADCHAR:
            case WM_MENUCHAR:
                // All these messages require the wParamW to be converted from Unicode
                wParam = 0;
                WideCharToMultiByte(g_acp, 0, (WCHAR *)&wParamW, 1, (char *)&wParam, g_mcs, NULL, NULL);

                if(FDBCS_CPG(g_acp))
                {
                    if(!wParam)
                    {
                        retval = TransmitHelper(mt, hWnd, Msg, wParam, lParamW, 
                                                lpPrevWndFunc, lpCallBack, dwData, 
                                                fuFlags, uTimeout, lpdwResult);
                        break;
                    }
                    else if(IsDBCSLeadByte(*(char *)(LOBYTE(wParam))))
                    {
                        // Ok, its a DBCS code page and wParam contains a DBCS character.
                        // we must send two WM_CHAR messages, one with each byte in it
                        char sz[2];

                        sz[0] = *(char *)LOBYTE(wParam);
                        sz[1] = *(char *)HIBYTE(wParam);
                        retval = TransmitHelper(mt, hWnd, Msg, (WPARAM)&sz[0], lParamW, 
                                                lpPrevWndFunc, lpCallBack, dwData, 
                                                fuFlags, uTimeout, lpdwResult);
                        if(retval==0)
                        {
                            // The first byte was handled, so send the second byte
                            retval = TransmitHelper(mt, hWnd, Msg, (WPARAM)&sz[1], lParamW, 
                                                    lpPrevWndFunc, lpCallBack, dwData, 
                                                    fuFlags, uTimeout, lpdwResult);
                        }
                        MultiByteToWideChar(g_acp, 0, (char *)&sz[0], g_mcs, (WCHAR *)&wParamW, 1);
                        break;
                    }
                }
/*
                if(FDBCS_CPG(g_acp) && (IsDBCSLeadByte((LOBYTE(wParam)))))
                {
                    // Ok, its a DBCS code page and wParam contains a DBCS character.
                    // we must send two WM_CHAR messages, one with each byte in it
                    retval = TransmitHelper(mt, hWnd, Msg, (WPARAM)LOBYTE(wParam), lParamW, 
                                            lpPrevWndFunc, lpCallBack, dwData, 
                                            fuFlags, uTimeout, lpdwResult);
                    if(retval==0)
                    {
                        // The first byte was handled, so send the second byte
                        retval = TransmitHelper(mt, hWnd, Msg, (WPARAM)HIBYTE(wParam), lParamW, 
                                                lpPrevWndFunc, lpCallBack, dwData, 
                                                fuFlags, uTimeout, lpdwResult);
                    }
                    break;
                }
*/
                // Not a DBCS code page, or at least not a DBCS character, so we just fall through now.
                
            case WM_IME_CHAR:
            case WM_IME_COMPOSITION:
                retval = TransmitHelper(mt, hWnd, Msg, wParam, lParamW, 
                                        lpPrevWndFunc, lpCallBack, dwData, 
                                        fuFlags, uTimeout, lpdwResult);
                MultiByteToWideChar(g_acp, 0, (char *)&wParam, g_mcs, (WCHAR *)&wParamW, 1);
                break;

            case WM_CHARTOITEM:
            {
                // Mask off the hiword bits, convert, then stick the hiword bits back on.
                WPARAM wpT = wParamW & 0xFFFF;
                WideCharToMultiByte(g_acp, 0, (WCHAR *)&wpT, 1, (char *)&wParam, g_mcs, NULL, NULL);
                retval = TransmitHelper(mt, hWnd, Msg, wParam, lParamW, 
                                        lpPrevWndFunc, lpCallBack, dwData, 
                                        fuFlags, uTimeout, lpdwResult);
                MultiByteToWideChar(g_acp, 0, (char *)&wParam, g_mcs, (WCHAR *)&wpT, 1);
                wParamW = MAKELONG(LOWORD(wpT),HIWORD(wParamW));
                break;
            }

            case (WM_USER + 125):   // might be WM_CAP_FILE_SAVEDIBW:
            case (WM_USER + 123):   // might be WM_CAP_FILE_SAVEASW:
            case (WM_USER + 166):   // might be WM_CAP_SET_MCI_DEVICEW:
            case (WM_USER + 180):   // might be WM_CAP_PAL_OPENW:
            case (WM_USER + 181):   // might be WM_CAP_PAL_SAVEW:
            case (WM_USER + 120):   // might be WM_CAP_FILE_SET_CAPTURE_FILEW:
                if(!IsCaptureWindow(hWnd))
                {
                    // The numbers are right, but its not a capture window, so
                    // do not convert. Instead, just pass as is.
                    retval = TransmitHelper(mt, hWnd, Msg, wParamW, lParamW, lpPrevWndFunc, 
                                            lpCallBack, dwData, fuFlags, uTimeout, lpdwResult);
                }
                else
                {
                    // No memory? If the alloc fails, we eat the results.
                    ALLOCRETURN ar = GodotToAcpOnHeap((LPWSTR)lParamW, &(LPSTR)lParam);
                    if(ar != arFailed)
                    {
                        Msg = MapCaptureMessage(Msg);
                        retval = TransmitHelper(mt, hWnd, Msg, wParamW, lParam, lpPrevWndFunc, 
                                                lpCallBack, dwData, fuFlags, uTimeout, lpdwResult);
                    }
                    if(ar == arAlloc)
                        GodotHeapFree((LPSTR)lParam);
                }
                break;

            case CB_ADDSTRING:
            case CB_DIR:
            case CB_FINDSTRING:
            case CB_FINDSTRINGEXACT:
            case CB_INSERTSTRING:
            case CB_SELECTSTRING:
            {
                LONG styl = GetWindowLongA(hWnd, GWL_STYLE);
                if(((styl & CBS_OWNERDRAWFIXED) || 
                   (styl & CBS_OWNERDRAWVARIABLE)) &&
                   (!(styl & CBS_HASSTRINGS)))
                {
                    // Owner draw combo box which does not have strings stored
                    // (See Windows Bugs # 356304 for details here)
                    retval = TransmitHelper(mt, hWnd, Msg, wParamW, lParamW, lpPrevWndFunc, 
                                            lpCallBack, dwData, fuFlags, uTimeout, lpdwResult);
                }
                else
                {
                    // No memory? If the alloc fails, we eat the results.
                    ALLOCRETURN ar = GodotToAcpOnHeap((LPWSTR)lParamW, &(LPSTR)lParam);
                    retval = TransmitHelper(mt, hWnd, Msg, wParamW, lParam, lpPrevWndFunc, 
                                            lpCallBack, dwData, fuFlags, uTimeout, lpdwResult);
                    if(ar == arAlloc)
                        GodotHeapFree((LPSTR)lParam);
                }
                break;
            }

            case LB_ADDFILE:
            case LB_ADDSTRING:
            case LB_DIR:
            case LB_FINDSTRING:
            case LB_FINDSTRINGEXACT:
            case LB_INSERTSTRING:
            case LB_SELECTSTRING:
            {
                LONG styl = GetWindowLongA(hWnd, GWL_STYLE);
                if(((styl & LBS_OWNERDRAWFIXED) || 
                   (styl & LBS_OWNERDRAWVARIABLE)) &&
                   (!(styl & LBS_HASSTRINGS)))
                {
                    // Owner draw listbox which does not have strings stored
                    // (See Windows Bugs # 356304 for details here)
                    retval = TransmitHelper(mt, hWnd, Msg, wParamW, lParamW, lpPrevWndFunc, 
                                            lpCallBack, dwData, fuFlags, uTimeout, lpdwResult);
                }
                else
                {
                    // No memory? If the alloc fails, we eat the results.
                    ALLOCRETURN ar = GodotToAcpOnHeap((LPWSTR)lParamW, &(LPSTR)lParam);
                    retval = TransmitHelper(mt, hWnd, Msg, wParamW, lParam, lpPrevWndFunc, 
                                            lpCallBack, dwData, fuFlags, uTimeout, lpdwResult);
                    if(ar == arAlloc)
                        GodotHeapFree((LPSTR)lParam);
                }
                break;
            }

            case EM_REPLACESEL:
            case WM_SETTEXT:
            case WM_DEVMODECHANGE:
            case WM_SETTINGCHANGE:
            case WM_SETMESSAGESTRING: // MFC internal msg
            {
                // All these messages require a string in lParam to be converted from Unicode

                // No memory? If the alloc fails, we eat the results.
                ALLOCRETURN ar = GodotToAcpOnHeap((LPWSTR)lParamW, &(LPSTR)lParam);
                retval = TransmitHelper(mt, hWnd, Msg, wParamW, lParam, lpPrevWndFunc, 
                                        lpCallBack, dwData, fuFlags, uTimeout, lpdwResult);
                if(ar == arAlloc)
                    GodotHeapFree((LPSTR)lParam);
                break;
            }

            case WM_DDE_EXECUTE:
                // wParam is the client window hWnd, lParam is the command LPTSTR.
                // Only convert lParam if both client and server windows are Unicode
                if(GetUnicodeWindowProp((HWND)wParamW))
                {
                    // No memory? If the alloc fails, we eat the results.
                    ALLOCRETURN ar = GodotToAcpOnHeap((LPWSTR)lParamW, &(LPSTR)lParam);
                    retval = TransmitHelper(mt, hWnd, Msg, wParamW, lParam, lpPrevWndFunc, 
                                            lpCallBack, dwData, fuFlags, uTimeout, lpdwResult);
                    if(ar == arAlloc)
                        GodotHeapFree((LPSTR)lParam);
                }
                else
                    retval = TransmitHelper(mt, hWnd, Msg, wParamW, lParam, 
                                            lpPrevWndFunc, lpCallBack, dwData, 
                                            fuFlags, uTimeout, lpdwResult);
                break;
            
            case EM_GETLINE:
                // lParam is a pointer to the buffer that receives a copy of the line. Before 
                // sending the message, set the first word of this buffer to the size, in TCHARs, 
                // of the buffer. For ANSI text, this is the number of bytes; for Unicode text, 
                // this is the numer of characters. The size in the first word is overwritten by 
                // the copied line. 
                cchlParam = (WORD)lParamW;
                lParam = (LPARAM)(LPSTR)GodotHeapAlloc(cchlParam * g_mcs);
                retval = TransmitHelper(mt, hWnd, Msg, wParamW, lParam, lpPrevWndFunc, 
                                        lpCallBack, dwData, fuFlags, uTimeout, lpdwResult);
                if(retval)
                {
                    retval = MultiByteToWideChar(g_acp, 
                                                 0, 
                                                 (LPSTR)lParam, 
                                                 retval + 1, 
                                                 (LPWSTR)lParamW, 
                                                 cchlParam);
                    if(retval)
                        retval--;
                }
                else
                {
                    if((LPWSTR)lParamW)
                        *((LPWSTR)lParamW) = L'\0';
                }

                if(lParam)
                    GodotHeapFree((LPSTR)lParam);
                break;
                
            case LB_GETTEXT:
                // lParam is a pointer to the buffer that will receive the string; it is type 
                // LPTSTR which is subsequently cast to an LPARAM. The buffer must have sufficient 
                // space for the string and a terminating null character. An LB_GETTEXTLEN message 
                // can be sent before the LB_GETTEXT message to retrieve the length, in TCHARs, of 
                // the string. 
                cchlParam = SendMessageA(hWnd, LB_GETTEXTLEN, wParamW, 0) + 1;
                lParam = (LPARAM)(LPSTR)GodotHeapAlloc(cchlParam * g_mcs);
                retval = TransmitHelper(mt, hWnd, Msg, wParamW, lParam, lpPrevWndFunc, 
                                        lpCallBack, dwData, fuFlags, uTimeout, lpdwResult);
                if(retval)
                {
                    retval = MultiByteToWideChar(g_acp, 
                                                 0, 
                                                 (LPSTR)lParam, 
                                                 retval + 1, 
                                                 (LPWSTR)lParamW, 
                                                 cchlParam);
                    if(retval)
                        retval--;
                }
                else
                {
                    if((LPWSTR)lParamW)
                        *((LPWSTR)lParamW) = L'\0';
                }

                if(lParam)
                    GodotHeapFree((LPSTR)lParam);
                break;

            case LB_GETTEXTLEN:
                retval = TransmitHelper(mt, hWnd, Msg, wParamW, lParamW, 
                                        lpPrevWndFunc, lpCallBack, dwData, 
                                        fuFlags, uTimeout, lpdwResult);
                if(FDBCS_CPG(g_acp))
                {
                    // In the DBCS case, LB_GETTEXTLEN returns number of bytes, but
                    // we need to get the number of characters for the Unicode case.
                    LPSTR lpsz = GodotHeapAlloc(retval + 1);
                    if(lpsz)
                    {
                        cchlParam = TransmitHelper(mt, hWnd, LB_GETTEXT, (WPARAM)(retval + 1), (LPARAM)lpsz, 
                                                lpPrevWndFunc, lpCallBack, dwData, 
                                                fuFlags, uTimeout, lpdwResult);
                        if(cchlParam > 0)
                        {
                            LPWSTR lpwz = GodotHeapAlloc((cchlParam + 1) * sizeof(WCHAR));
                            size_t cch = (cchlParam + 1) * sizeof(WCHAR);
                            retval = MultiByteToWideChar(g_acp, 0, lpsz, cchlParam, lpwz, cch);
                            if(lpwz)
                                GodotHeapFree(lpwz);
                        }
                        GodotHeapFree(lpsz);
                    }
                }
                break;

            case CB_GETLBTEXT:
                // lParam is a pointer to the buffer that will receive the string; it is type 
                // LPTSTR which is subsequently cast to an LPARAM. The buffer must have sufficient 
                // space for the string and a terminating null character. An CB_GETLBTEXTLEN message 
                // can be sent before the CB_GETLBTEXT message to retrieve the length, in TCHARs, of 
                // the string. 
                cchlParam = SendMessageA(hWnd, CB_GETLBTEXTLEN, wParamW, 0) + 1;
                lParam = (LPARAM)(LPSTR)GodotHeapAlloc(cchlParam * g_mcs);
                retval = TransmitHelper(mt, hWnd, Msg, wParamW, lParam, lpPrevWndFunc, 
                                        lpCallBack, dwData, fuFlags, uTimeout, lpdwResult);
                if(retval)
                {
                    retval = MultiByteToWideChar(g_acp, 
                                                 0, 
                                                 (LPSTR)lParam, 
                                                 retval + 1, 
                                                 (LPWSTR)lParamW, 
                                                 cchlParam);
                    if(retval)
                        retval--;
                }
                else
                {
                    if((LPWSTR)lParamW)
                        *((LPWSTR)lParamW) = L'\0';
                }
                if(lParam)
                    GodotHeapFree((LPSTR)lParam);
                break;

            case CB_GETLBTEXTLEN:
                retval = TransmitHelper(mt, hWnd, Msg, wParamW, lParamW, 
                                        lpPrevWndFunc, lpCallBack, dwData, 
                                        fuFlags, uTimeout, lpdwResult);
                if(FDBCS_CPG(g_acp))
                {
                    // In the DBCS case, CB_GETLBTEXTLEN returns number of bytes, but
                    // we need to get the number of characters for the Unicode case.
                    LPSTR lpsz = GodotHeapAlloc(retval + 1);
                    if(lpsz)
                    {
                        cchlParam = TransmitHelper(mt, hWnd, CB_GETLBTEXT, (WPARAM)(retval + 1), (LPARAM)lpsz, 
                                                lpPrevWndFunc, lpCallBack, dwData, 
                                                fuFlags, uTimeout, lpdwResult);
                        if(cchlParam > 0)
                        {
                            LPWSTR lpwz = GodotHeapAlloc((cchlParam + 1) * sizeof(WCHAR));
                            if(lpwz)
                            {
                                size_t cch = (cchlParam + 1) * sizeof(WCHAR);
                                retval = MultiByteToWideChar(g_acp, 0, lpsz, cchlParam, lpwz, cch);
                                GodotHeapFree(lpwz);
                            }
                        }
                        GodotHeapFree(lpsz);
                    }
                }
                break;

            case (WM_USER + 167):   // might be WM_CAP_GET_MCI_DEVICEW
            case (WM_USER + 112):   // might be WM_CAP_DRIVER_GET_NAMEW:
            case (WM_USER + 113):   // might be WM_CAP_DRIVER_GET_VERSIONW:
            case (WM_USER + 121):   // might be WM_CAP_FILE_GET_CAPTURE_FILEW:
                if(!IsCaptureWindow(hWnd))
                {
                    // The numbers are right, but its not a capture window, so
                    // do not convert. Instead, just pass as is.
                    retval = TransmitHelper(mt, hWnd, Msg, wParamW, lParamW, lpPrevWndFunc, 
                                            lpCallBack, dwData, fuFlags, uTimeout, lpdwResult);
                    break;
                }

                // If we are still here, then it is a capture message. So lets map
                // it and faill through.
                Msg = MapCaptureMessage(Msg);

                
            case WM_GETTEXT:
                // wParam specifies the size of the buffer in the string in lParam
                cchlParam = (size_t)wParamW;
                lParam = (LPARAM)(LPSTR)GodotHeapAlloc(cchlParam * g_mcs);
                retval = TransmitHelper(mt, hWnd, Msg, wParamW, lParam, lpPrevWndFunc, 
                                        lpCallBack, dwData, fuFlags, uTimeout, lpdwResult);
                if(retval)
                {
                    retval = MultiByteToWideChar(g_acp, 
                                                 0, 
                                                 (LPSTR)lParam, 
                                                 retval + 1, 
                                                 (LPWSTR)lParamW, 
                                                 cchlParam);
                    if(retval)
                        retval--;
                }
                else
                {
                    if((LPWSTR)lParamW)
                        *((LPWSTR)lParamW) = L'\0';
                }
                if(lParam)
                    GodotHeapFree((LPSTR)lParam);
                break;

            case WM_GETTEXTLENGTH:
                retval = TransmitHelper(mt, hWnd, Msg, wParamW, lParamW, 
                                        lpPrevWndFunc, lpCallBack, dwData, 
                                        fuFlags, uTimeout, lpdwResult);
                if(FDBCS_CPG(g_acp))
                {
                    // In the DBCS case, WM_GETTEXTLENGTH returns number of bytes, but
                    // we need to get the number of characters for the Unicode case.
                    // If any of the allocs fail, we will live with the less than perfect
                    // result we have in hand
                    LPSTR lpsz = GodotHeapAlloc(retval + 1);
                    if(lpsz)
                    {
                        cchlParam = TransmitHelper(mt, hWnd, WM_GETTEXT, (WPARAM)(retval + 1), (LPARAM)lpsz, 
                                                lpPrevWndFunc, lpCallBack, dwData, 
                                                fuFlags, uTimeout, lpdwResult);
                        if(cchlParam > 0)
                        {
                            LPWSTR lpwz = GodotHeapAlloc((cchlParam + 1) * sizeof(WCHAR));
                            if(lpwz)
                            {
                                size_t cch = (cchlParam + 1) * sizeof(WCHAR);
                                retval = MultiByteToWideChar(g_acp, 0, lpsz, cchlParam, lpwz, cch);
                                GodotHeapFree(lpwz);
                            }
                        }
                        GodotHeapFree(lpsz);
                    }
                }
                break;

            case (WM_USER + 1):
                if(IsFontDialog(hWnd))
                {
                    // This is a WM_CHOOSEFONT_GETLOGFONT msg
                    LOGFONTA lfa;
                    lParam = (LPARAM)&lfa;
                    retval = TransmitHelper(mt, hWnd, Msg, wParamW, lParam, 
                                            lpPrevWndFunc, lpCallBack, dwData, 
                                            fuFlags, uTimeout, lpdwResult);
                    LogFontWfromA((LPLOGFONTW)lParamW, (LPLOGFONTA)lParam);
                }
                else
                {
                    // This would be one of the common control msgs we do not handle
                    retval = TransmitHelper(mt, hWnd, Msg, wParamW, lParamW, 
                                            lpPrevWndFunc, lpCallBack, dwData, 
                                            fuFlags, uTimeout, lpdwResult);
                    break;
                }
                break;

            case (WM_USER + 100):
                if(IsNewFileOpenDialog(hWnd))
                {
                    // This is a CDM_GETSPEC msg
                    wParam = wParamW * g_mcs;
                    (LPSTR)lParam = (LPSTR)GodotHeapAlloc(wParam);
                    retval = TransmitHelper(mt, hWnd, Msg, wParam, lParam, 
                                            lpPrevWndFunc, lpCallBack, dwData, 
                                            fuFlags, uTimeout, lpdwResult);
                    MultiByteToWideChar(g_acp, 0, (LPSTR)lParam, wParam, (LPWSTR)lParamW, wParamW);
                    retval = gwcslen((LPWSTR)lParamW);
                    if(lParam)
                        GodotHeapFree((LPSTR)lParam);
                }
                else
                {
                    retval = TransmitHelper(mt, hWnd, Msg, wParamW, lParamW, 
                                            lpPrevWndFunc, lpCallBack, dwData, 
                                            fuFlags, uTimeout, lpdwResult);
                }
                break;

            case (WM_USER + 101):
                if(IsFontDialog(hWnd))
                {
                    // This is a WM_CHOOSEFONT_SETLOGFONT msg
                    LOGFONTA lfa;

                    lParam = (LPARAM)&lfa;
                    LogFontAfromW((LPLOGFONTA)lParam, (LPLOGFONTW)lParamW);
                    retval = TransmitHelper(mt, hWnd, Msg, wParamW, lParam, 
                                             lpPrevWndFunc, lpCallBack, dwData, 
                                             fuFlags, uTimeout, lpdwResult);
                }
                else if(IsNewFileOpenDialog(hWnd))
                {
                    // This is a CDM_GETFILEPATH msg
                    wParam = wParamW * g_mcs;
                    (LPSTR)lParam = (LPSTR)GodotHeapAlloc(wParam);
                    retval = TransmitHelper(mt, hWnd, Msg, wParam, lParam, 
                                            lpPrevWndFunc, lpCallBack, dwData, 
                                            fuFlags, uTimeout, lpdwResult);
                    MultiByteToWideChar(g_acp, 0, (LPSTR)lParam, wParam, (LPWSTR)lParamW, wParamW);
                    retval = gwcslen((LPWSTR)lParamW);
                    if(lParam)
                        GodotHeapFree((LPSTR)lParam);
                }
                else
                {
                    retval = TransmitHelper(mt, hWnd, Msg, wParamW, lParamW, 
                                            lpPrevWndFunc, lpCallBack, dwData, 
                                            fuFlags, uTimeout, lpdwResult);
                }
                break;

            case (WM_USER + 102):
                if(IsFontDialog(hWnd))
                {
                    // This is a WM_CHOOSEFONT_SETFLAGS msg
                    // The docs claim that lParam has a CHOOSEFONT struct but the code shows
                    // that it only has the Flags in it
                    retval = TransmitHelper(mt, hWnd, Msg, wParamW, lParamW, 
                                             lpPrevWndFunc, lpCallBack, dwData, 
                                             fuFlags, uTimeout, lpdwResult);
                }
                else if(IsNewFileOpenDialog(hWnd))
                {
                    // This is a CDM_GETFOLDERPATH
                    // lParam is a buffer for the path of the open folder
                    wParam = wParamW * g_mcs;
                    (LPSTR)lParam = (LPSTR)GodotHeapAlloc(wParam);
                    retval = TransmitHelper(mt, hWnd, Msg, wParam, lParam, 
                                            lpPrevWndFunc, lpCallBack, dwData, 
                                            fuFlags, uTimeout, lpdwResult);
                    MultiByteToWideChar(g_acp, 0, (LPSTR)lParam, wParam, (LPWSTR)lParamW, wParamW);
                    retval = gwcslen((LPWSTR)lParamW);
                    if(lParam)
                        GodotHeapFree((LPSTR)lParam);
                }
                else
                {
                    retval = TransmitHelper(mt, hWnd, Msg, wParamW, lParamW, 
                                            lpPrevWndFunc, lpCallBack, dwData, 
                                            fuFlags, uTimeout, lpdwResult);
                }
                break;

            case (WM_USER + 104):
                if(IsNewFileOpenDialog(hWnd))
                {
                    // This is a CDM_SETCONTROLTEXT message
                    // lParam is the control text (wParam is the control ID)

                    // No memory? If the alloc fails, we eat the results.
                    ALLOCRETURN ar = GodotToAcpOnHeap((LPWSTR)lParamW, &(LPSTR)lParam);
                    retval = TransmitHelper(mt, hWnd, Msg, wParamW, lParam, lpPrevWndFunc, 
                                            lpCallBack, dwData, fuFlags, uTimeout, lpdwResult);
                    if(ar == arAlloc)
                        GodotHeapFree((LPSTR)lParam);
                }
                else
                {
                    retval = TransmitHelper(mt, hWnd, Msg, wParamW, lParamW, 
                                            lpPrevWndFunc, lpCallBack, dwData, 
                                            fuFlags, uTimeout, lpdwResult);
                }
                break;

            case (WM_USER + 106):
                if(IsNewFileOpenDialog(hWnd))
                {
                    // This is a CDM_SETDEFEXT message
                    // lParam is the extension

                    // No memory? If the alloc fails, we eat the results.
                    ALLOCRETURN ar = GodotToAcpOnHeap((LPWSTR)lParamW, &(LPSTR)lParam);
                    retval = TransmitHelper(mt, hWnd, Msg, wParamW, lParam, lpPrevWndFunc, 
                                            lpCallBack, dwData, fuFlags, uTimeout, lpdwResult);
                    if(ar == arAlloc)
                        GodotHeapFree((LPSTR)lParam);
                }
                else
                {
                    retval = TransmitHelper(mt, hWnd, Msg, wParamW, lParamW, 
                                            lpPrevWndFunc, lpCallBack, dwData, 
                                            fuFlags, uTimeout, lpdwResult);
                }
                break;

            case EM_GETPASSWORDCHAR:
            {
                // All these messages require that the (single char) retval be converted to Unicode
                // CONSIDER: is this always single character?
                LRESULT retvalA = TransmitHelper(mt, hWnd, Msg, wParamW, lParamW, 
                                         lpPrevWndFunc, lpCallBack, dwData, 
                                         fuFlags, uTimeout, lpdwResult);
                MultiByteToWideChar(g_acp, 0, 
                                    (char *)&retvalA, 
                                    g_mcs, 
                                    (WCHAR *)&retval, 
                                    sizeof(WCHAR));
                break;
            }

            case WM_CREATE:
            case WM_NCCREATE:
            {
                LPCREATESTRUCTW lpcs = (LPCREATESTRUCTW)lParamW;
                CREATESTRUCTA csA;
                ALLOCRETURN arClass = arNoAlloc;
                ALLOCRETURN arName = arNoAlloc;

                ZeroMemory(&csA, sizeof(CREATESTRUCTA));
                csA.lpCreateParams  = lpcs->lpCreateParams;
                csA.hInstance       = lpcs->hInstance;
                csA.hMenu           = lpcs->hMenu;
                csA.hwndParent      = lpcs->hwndParent;
                csA.cy              = lpcs->cy;
                csA.cx              = lpcs->cx;
                csA.y               = lpcs->y;
                csA.x               = lpcs->x;
                csA.style           = lpcs->style;
                csA.dwExStyle       = lpcs->dwExStyle;
                arClass = GodotToAcpOnHeap(lpcs->lpszClass, &(LPSTR)(csA.lpszClass));
                arName = GodotToAcpOnHeap(lpcs->lpszName, &(LPSTR)(csA.lpszName));
                lParam = (LPARAM)&csA;
            
                retval = TransmitHelper(mt, hWnd, Msg, wParamW, lParam, 
                                        lpPrevWndFunc, lpCallBack, dwData, 
                                        fuFlags, uTimeout, lpdwResult);
                if(arClass==arAlloc)
                    GodotHeapFree((LPSTR)csA.lpszClass);
                if(arName==arAlloc)
                    GodotHeapFree((LPSTR)csA.lpszName);
                break;
            }
            
        case WM_MDICREATE:
            // wParam is not used, lParam is a pointer to an MDICREATESTRUCT structure containing 
            // information that the system uses to create the MDI child window. 
            {
                LPMDICREATESTRUCTW lpmcsi = (LPMDICREATESTRUCTW)lParamW;
                MDICREATESTRUCTA mcsiA;
                ALLOCRETURN arClass = arNoAlloc;
                ALLOCRETURN arTitle = arNoAlloc;
                
                ZeroMemory(&mcsiA, sizeof(MDICREATESTRUCTA));
                mcsiA.hOwner    = lpmcsi->hOwner;
                mcsiA.x         = lpmcsi->x;
                mcsiA.y         = lpmcsi->y;
                mcsiA.cx        = lpmcsi->cx;
                mcsiA.cy        = lpmcsi->cy;
                mcsiA.style     = lpmcsi->style;
                mcsiA.lParam    = lpmcsi->lParam;
                arClass = GodotToAcpOnHeap(lpmcsi->szClass, &(LPSTR)(mcsiA.szClass));
                arTitle = GodotToAcpOnHeap(lpmcsi->szTitle, &(LPSTR)(mcsiA.szTitle));

                retval = TransmitHelper(mt, hWnd, Msg, wParamW, (LPARAM)&mcsiA, 
                                         lpPrevWndFunc, lpCallBack, dwData, 
                                         fuFlags, uTimeout, lpdwResult);
                if(arClass==arAlloc)
                    GodotHeapFree((LPSTR)mcsiA.szClass);
                if(arTitle==arAlloc)
                    GodotHeapFree((LPSTR)mcsiA.szTitle);
            }
            break;

        default:
            // Lets get our registered messages, if we haven't yet.
            if(!msgHELPMSGSTRING)
                msgHELPMSGSTRING = RegisterWindowMessage(HELPMSGSTRINGA);
            if(!msgFINDMSGSTRING)
                msgFINDMSGSTRING = RegisterWindowMessage(FINDMSGSTRINGA);

            if(((Msg == msgFINDMSGSTRING) || (Msg == msgHELPMSGSTRING)) && 
                    ((((LPFINDREPLACEW)lParamW)->lStructSize) == sizeof(FINDREPLACEA)))
            {
                LPFINDREPLACEW lpfr;
                
                // No translation needed
                retval = TransmitHelper(mt, hWnd, Msg, wParamW, lParamW, 
                                        lpPrevWndFunc, lpCallBack, dwData, 
                                        fuFlags, uTimeout, lpdwResult);

                lpfr = (LPFINDREPLACEW)lParamW;
                
                if((lpfr->Flags & FR_DIALOGTERM) &&
                   ((lpfr->lpfnHook == &FRHookProcFind) || (lpfr->lpfnHook == &FRHookProcReplace)))
                {
                    // Now handle our cleanup. I do not think this should
                    // be needed, but it can't hurt to do it just in case.
                    LPGODOTTLSINFO lpgti = GetThreadInfoSafe(TRUE);

                    // They are destroying the dialog, so unhook ourselves
                    // and clean up the dialog (if we have not done it yet). 
                    if(lpfr->lpfnHook == &FRHookProcFind) 
                    {
                        // Find dialog, not yet cleaned up
                        lpfr->lpfnHook = lpgti->pfnFindText;
                        if(lpfr->lpfnHook == NULL)
                            lpfr->Flags &= ~FR_ENABLEHOOK;
                    }
                    else if(lpfr->lpfnHook == &FRHookProcReplace) 
                    {
                        // Replace dialog, not yet cleaned up
                        lpfr->lpfnHook = lpgti->pfnReplaceText;
                        if(lpfr->lpfnHook == NULL)
                            lpfr->Flags &= ~FR_ENABLEHOOK;
                    }
                }
            }
            else if((Msg == msgHELPMSGSTRING) && 
                    ((LPCHOOSEFONTA)lParamW)->lStructSize == sizeof(CHOOSEFONTA))
            {
                LPCHOOSEFONTW lpcf = (LPCHOOSEFONTW)lParamW;
                CHOOSEFONTA cfA;
                ALLOCRETURN ar = arNoAlloc;

                // lParam is an LPCHOOSEFONTW to be converted. Copy all the
                // members that the user might expect.
                ZeroMemory(&cfA, sizeof(CHOOSEFONTA));
                cfA.lStructSize     = sizeof(CHOOSEFONTA);
                cfA.hDC             = lpcf->hDC;
                LogFontAfromW(cfA.lpLogFont, lpcf->lpLogFont);
                cfA.iPointSize      = lpcf->iPointSize;
                cfA.Flags           = lpcf->Flags;
                cfA.rgbColors       = lpcf->rgbColors;
                cfA.lCustData       = lpcf->lCustData;
                ar = GodotToAcpOnHeap(lpcf->lpszStyle, &(cfA.lpszStyle));
                cfA.nFontType       = lpcf->nFontType;
                cfA.nSizeMin        = lpcf->nSizeMin;
                cfA.nSizeMax        = lpcf->nSizeMax;

                retval = TransmitHelper(mt, hWnd, Msg, wParamW, (LPARAM)&cfA, lpPrevWndFunc, 
                                        lpCallBack, dwData, fuFlags, uTimeout, lpdwResult);
                if(ar==arAlloc)
                    GodotHeapFree(cfA.lpszStyle);
                break;
            }
            else
            {
                // No translation needed
                retval = TransmitHelper(mt, hWnd, Msg, wParamW, lParamW, lpPrevWndFunc, 
                                        lpCallBack, dwData, fuFlags, uTimeout, lpdwResult);
                break;
            }
        }
    }

    return (retval);
}

/*-------------------------------
    TransmitHelper

    Our helper function that handles the proper one of 
    the twelve functions that call GodotTransmitMessage
-------------------------------*/
LRESULT TransmitHelper(
    MESSAGETYPES mt,
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam,
    WNDPROC lpPrevWndFunc,  
    SENDASYNCPROC lpCallBack,
    ULONG_PTR dwData,
    UINT fuFlags,
    UINT uTimeout,
    PDWORD_PTR lpdwResult
)
{
    LRESULT RetVal;

    switch(mt)
    {
    case mtSendMessage:
    {
        // We have to special case the WM_MDICREATE case, because it creates a window and we 
        // thus have to do the hook, etc. Note that currently it is only done in SendMessage, 
        // not in any other call -- this matches the docs, and we cannot risk hitting a 
        // recursive situation here.
        if(Msg==WM_MDICREATE)
        {
            LPGODOTTLSINFO lpgti = GetThreadInfoSafe(TRUE);

            if(lpgti)
                INIT_WINDOW_SNIFF(lpgti->hHook);

            RetVal=SendMessageA(hWnd, Msg, wParam, lParam);

            if(lpgti)
                TERM_WINDOW_SNIFF(lpgti->hHook);
        }
        else
        {
            RetVal=SendMessageA(hWnd, Msg, wParam, lParam);
        }

        break;
    }
    case mtSendMessageCallback:
        RetVal=(LRESULT)SendMessageCallbackA(hWnd, Msg, wParam, lParam, lpCallBack, dwData);
        break;
    case mtSendMessageTimeout:
        RetVal=SendMessageTimeoutA(hWnd, Msg, wParam, lParam, fuFlags, uTimeout, lpdwResult);
        break;
    case mtSendNotifyMessage:
        RetVal=(LRESULT)SendNotifyMessageA(hWnd, Msg, wParam, lParam);
        break;
    case mtPostMessage:
        RetVal=(LRESULT)PostMessageA(hWnd, Msg, wParam, lParam);
        break;
    case mtPostThreadMessage:
        // hWnd is overloaded in this case to be the thread ID
        RetVal=(LRESULT)PostThreadMessageA((DWORD)hWnd, Msg, wParam, lParam);
        break;
    case mtCallWindowProc:
    case mtCallWindowProcA:
    {
        WNDPROC lpfn = WndprocFromFauxWndproc(hWnd, lpPrevWndFunc, fptUnknown);
        
        // If the wndproc was not a "faux" one or if the wndproc
        // is expecting ANSI (or both!), then use CallWindowProcA,
        // since that is what the wndproc would expect. Otherwise,
        // use Unicode and call the function directly.
        if((lpfn==lpPrevWndFunc) || (DoesProcExpectAnsi(hWnd, lpfn, fptUnknown)))
        {
            if(lpfn)
                RetVal=((CallWindowProcA)(lpfn, hWnd, Msg, wParam, lParam));
        }
        else
        {
            if(lpfn)
                RetVal=((* lpfn)(hWnd, Msg, wParam, lParam));
        }
        break;
    }
    case mtDefWindowProc:
        RetVal=DefWindowProcA(hWnd, Msg, wParam, lParam);
        break;
    case mtDefDlgProc:
        RetVal=DefDlgProcA(hWnd, Msg, wParam, lParam);
        break;
    case mtDefFrameProc:
        // dwData is overload in this case to ve the second hWnd param
        RetVal=DefFrameProcA(hWnd, (HWND)dwData, Msg, wParam, lParam);
        break;
    case mtDefMDIChildProc:
        RetVal=DefMDIChildProcA(hWnd, Msg, wParam, lParam);
        break;
    case mtBroadcastSystemMessage:
        if (s_pfnBSMA == NULL)
        {
            s_pfnBSMA = (PFNbsma)GetProcAddress(GetUserHandle(), "BroadcastSystemMessageA");
            if (s_pfnBSMA == NULL)
                s_pfnBSMA = (PFNbsma)GetProcAddress(GetUserHandle(), "BroadcastSystemMessage");
        }

        if (s_pfnBSMA)
            // fuFlags is overloaded here as the dwFlags broadcast options
            // lpdwResult is overloaded here as the passed in lpdwRecipients
            RetVal=(s_pfnBSMA((DWORD)fuFlags, lpdwResult, Msg, wParam, lParam));
        else
        {
            // Should be impossible!!!
            SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
            RetVal=(-1);
        }
        break;
    default:
        // Should also be impossible!!!
        RetVal=(0);
        break;
    }

    return(RetVal);
}

/*-------------------------------
    GodotReceiveMessage

        Our global wrapper for getting messages (GetMessage, et. al.). Does all precall
        and postcall conversions needed for any string values that are used
-------------------------------*/
BOOL GodotReceiveMessage(MESSAGETYPES mt, LPMSG lpMsg, HWND hWnd, UINT wMin, UINT wMax, UINT wRemoveMsg)
{
    BOOL retval;
    MSG MsgA;

    // call stuff
    switch(mt)
    {
    case mtGetMessage:
        retval = (GetMessageA)(&MsgA, hWnd, wMin, wMax);
        break;
    case mtPeekMessage:
        retval = (PeekMessageA)(&MsgA, hWnd, wMin, wMax, wRemoveMsg);
        break;
    }

    // Copy some defaults (we will override for specific messages, as needed)
    lpMsg->wParam = MsgA.wParam;
    lpMsg->lParam = MsgA.lParam;
    lpMsg->hwnd = MsgA.hwnd;
    lpMsg->message = MsgA.message;
    lpMsg->time = MsgA.time;
    lpMsg->pt.x = MsgA.pt.x;
    lpMsg->pt.y = MsgA.pt.y;

    // The caller is always expecting Unicode here, so we must ALWAYS convert.
    switch(MsgA.message)
    {
        case EM_SETPASSWORDCHAR:
        case WM_CHAR:
        case WM_DEADCHAR:
        case WM_SYSCHAR:
        case WM_SYSDEADCHAR:
        case WM_MENUCHAR:
        case WM_IME_CHAR:
        case WM_IME_COMPOSITION:
            // All these messages require the wParam to be converted to Unicode
            MultiByteToWideChar(g_acp, 0, (char *)&(MsgA.wParam), g_mcs, (WCHAR *)&(lpMsg->wParam), 1);
            break;

        case WM_CHARTOITEM:
        {
            // Mask off the hiword bits, convert, then stick the hiword bits back on.
            WPARAM wpT = MsgA.wParam & 0xFFFF;
            MultiByteToWideChar(g_acp, 0, (char *)&(wpT), g_mcs, (WCHAR *)&(lpMsg->wParam), 1);
            lpMsg->wParam = MAKELONG(LOWORD(wpT),HIWORD(MsgA.wParam));
            break;
        }

        case CB_ADDSTRING:
        case CB_DIR:
        case CB_FINDSTRING:
        case CB_FINDSTRINGEXACT:
        case CB_INSERTSTRING:
        case CB_SELECTSTRING:
        {
            LONG styl = GetWindowLongA(hWnd, GWL_STYLE);
            if(!(((styl & CBS_OWNERDRAWFIXED) || 
               (styl & CBS_OWNERDRAWVARIABLE)) &&
               (!(styl & CBS_HASSTRINGS))))
            {
                // Owner draw combo box which does not have strings stored
                // (See Windows Bugs # 356304 for details here)
                if(FSTRING_VALID((LPSTR)(MsgA.lParam)))
                {
                    MultiByteToWideChar(g_acp, 0, 
                                        (LPSTR)(MsgA.lParam), ((MsgA.wParam) * g_mcs), 
                                        (LPWSTR)(lpMsg->lParam), MsgA.wParam);
                }
            }
        }
            break;

        case LB_ADDSTRING:
        case LB_ADDFILE:
        case LB_DIR:
        case LB_FINDSTRING:
        case LB_FINDSTRINGEXACT:
        case LB_INSERTSTRING:
        case LB_SELECTSTRING:
        {
            LONG styl = GetWindowLongA(hWnd, GWL_STYLE);
            if(!(((styl & LBS_OWNERDRAWFIXED) || 
               (styl & LBS_OWNERDRAWVARIABLE)) &&
               (!(styl & LBS_HASSTRINGS))))
            {
                // Owner draw listbox which does not have strings stored
                // (See Windows Bugs # 356304 for details here)
                if(FSTRING_VALID((LPSTR)(MsgA.lParam)))
                {
                    MultiByteToWideChar(g_acp, 0, 
                                        (LPSTR)(MsgA.lParam), ((MsgA.wParam) * g_mcs), 
                                        (LPWSTR)(lpMsg->lParam), MsgA.wParam);
                }
            }
        }
            break;

            case EM_REPLACESEL:
            case WM_SETTEXT:
            case WM_DEVMODECHANGE:
            case WM_SETTINGCHANGE:
            case WM_SETMESSAGESTRING: // MFC internal msg
                if(FSTRING_VALID((LPSTR)(MsgA.lParam)))
                {
                    // All these messages require the lParam to be converted to Unicode
                    // CONSIDER: Is that string buffer size right?
                    MultiByteToWideChar(g_acp, 0, 
                                        (LPSTR)(MsgA.lParam), ((MsgA.wParam) * g_mcs), 
                                        (LPWSTR)(lpMsg->lParam), MsgA.wParam);
                }


        case WM_DDE_EXECUTE:
            // wParam is the client window hWnd, lParam is the command LPTSTR.
            // Only convert lParam if both client and server windows are Unicode
            if(GetUnicodeWindowProp((HWND)lpMsg->wParam))
            {
                MultiByteToWideChar(g_acp, 0, 
                                    (LPSTR)(MsgA.lParam), ((MsgA.wParam) * g_mcs), 
                                    (LPWSTR)(lpMsg->lParam), MsgA.wParam);
            }
            break;
    }
    
    // Get out of here
    return (retval);

}

/*-------------------------------
    GodotDispatchMessage

    Handles all the message dispatch functions
-------------------------------*/
LRESULT GodotDispatchMessage(MESSAGETYPES mt, HWND hDlg, HACCEL hAccTable, LPMSG lpMsg)
{
    // Begin locals
    LRESULT RetVal;
    ALLOCRETURN ar = arNoAlloc;
    MSG MsgA;

    // We will override some of these params later, as needed
    MsgA.wParam = lpMsg->wParam;
    MsgA.lParam = lpMsg->lParam;
    MsgA.hwnd = lpMsg->hwnd;
    MsgA.message = lpMsg->message;
    MsgA.time = lpMsg->time;
    MsgA.pt = lpMsg->pt;
    
    // The caller is always passing Unicode here, so we must ALWAYS convert.
    switch(lpMsg->message)
    {
        case EM_SETPASSWORDCHAR:
        case WM_CHAR:
        case WM_DEADCHAR:
        case WM_SYSCHAR:
        case WM_SYSDEADCHAR:
        case WM_MENUCHAR:
        case WM_IME_CHAR:
        case WM_IME_COMPOSITION:
            // All these messages require the wParam to be converted from Unicode
            WideCharToMultiByte(g_acp, 0, 
                                (WCHAR *)&(lpMsg->wParam), 1, 
                                (CHAR *)&(MsgA.wParam), g_mcs, NULL, NULL);
            break;

        case WM_CHARTOITEM:
        {
            // Mask off the hiword bits, convert, then stick the hiword bits back on.
            WPARAM wpT = lpMsg->wParam & 0xFFFF;
            WideCharToMultiByte(g_acp, 0, 
                                (WCHAR *)&(wpT), 1, 
                                (CHAR *)&(MsgA.wParam), g_mcs, NULL, NULL);
            MsgA.wParam = MAKELONG(LOWORD(wpT),HIWORD(lpMsg->wParam));
            break;
        }

        case CB_ADDSTRING:
        case LB_ADDFILE:
        case CB_DIR:
        case CB_FINDSTRING:
        case CB_FINDSTRINGEXACT:
        case CB_INSERTSTRING:
        case CB_SELECTSTRING:
        {
            LONG styl = GetWindowLongA(hDlg, GWL_STYLE);
            if(!(((styl & CBS_OWNERDRAWFIXED) || 
               (styl & CBS_OWNERDRAWVARIABLE)) &&
               (!(styl & CBS_HASSTRINGS))))
            {
                // Owner draw combobox which does not have strings stored
                // (See Windows Bugs # 356304 for details here)
                ar = GodotToAcpOnHeap((LPWSTR)(lpMsg->lParam), &(LPSTR)(MsgA.lParam));
            }
            break;
        }
                
        case LB_ADDSTRING:
        case LB_DIR:
        case LB_FINDSTRING:
        case LB_FINDSTRINGEXACT:
        case LB_INSERTSTRING:
        case LB_SELECTSTRING:
        {
            LONG styl = GetWindowLongA(hDlg, GWL_STYLE);
            if(!(((styl & LBS_OWNERDRAWFIXED) || 
               (styl & LBS_OWNERDRAWVARIABLE)) &&
               (!(styl & LBS_HASSTRINGS))))
            {
                // Owner draw listbox which does not have strings stored
                // (See Windows Bugs # 356304 for details here)
                ar = GodotToAcpOnHeap((LPWSTR)(lpMsg->lParam), &(LPSTR)(MsgA.lParam));
            }
            break;
        }

        case EM_REPLACESEL:
        case WM_SETTEXT:
        case WM_DEVMODECHANGE:
        case WM_SETTINGCHANGE:
        case WM_SETMESSAGESTRING: // MFC internal msg
            // All these messages require the lParam to be converted from Unicode
            // It is a full string, so lets treat it as such.
            ar = GodotToAcpOnHeap((LPWSTR)(lpMsg->lParam), &(LPSTR)(MsgA.lParam));
            break;

        case WM_DDE_EXECUTE:
            // wParam is the client window hWnd, lParam is the command LPTSTR.
            // Only convert lParam if both client and server windows are Unicode
            if(GetUnicodeWindowProp((HWND)lpMsg->wParam))
            {
                ar = GodotToAcpOnHeap((LPWSTR)(lpMsg->lParam), &(LPSTR)(MsgA.lParam));
            }
            break;
    }
    
    switch(mt)
    {
        case mtDispatchMessage:
            RetVal=DispatchMessageA(&MsgA);
            break;
        case mtIsDialogMessage:
            RetVal=(LRESULT)IsDialogMessageA(hDlg, &MsgA);
            break;
        case mtTranslateAccelerator:
            RetVal = (LRESULT)TranslateAcceleratorA(hDlg, hAccTable, &MsgA);
            break;
    }

    // If we used some heap memory then free it now
    if(ar == arAlloc)
        GodotHeapFree((LPSTR)(MsgA.lParam));

    return(RetVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\godot\usermsgs.h ===
/*++

Copyright (c) 2000-2001,  Microsoft Corporation  All rights reserved.

Module Name:

    usermsgs.h

Abstract:

    Header file for usrmsgs.c

Revision History:

    6 Feb 2001    v-michka    Created.

--*/

#ifndef USERMSGS_H
#define USERMSGS_H

// forward declares
LRESULT GodotDoCallback(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, WNDPROC lpfn, BOOL fUniSrc, FAUXPROCTYPE fpt);
LRESULT GodotTransmitMessage(MESSAGETYPES mt, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, WNDPROC lpPrevWndFunc, SENDASYNCPROC lpCallBack, ULONG_PTR dwData, UINT fuFlags, UINT uTimeout, PDWORD_PTR lpdwResult);
BOOL GodotReceiveMessage(MESSAGETYPES mt, LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);  
LRESULT GodotDispatchMessage(MESSAGETYPES mt, HWND hDlg, HACCEL hAccTable, LPMSG lpMsg);

#endif // USERMSGS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\godot\utf.c ===
/*++

Copyright (c) 1991-2001,  Microsoft Corporation  All rights reserved.

Module Name:

    utf.c

Abstract:

    This file contains functions that convert UTF strings to Unicode
    strings and Unicode string to UTF strings.

    External Routines found in this file:
      UTFCPInfo
      UTFToUnicode
      UnicodeToUTF

Revision History:

    02-06-96    JulieB    Created.
    03-20-99    SamerA    Surrogate support.
    01-23-01    v-michka  Ported to Godot
    03-16-01    v-michka  Ported UTF-8 corrigendum compliance version
    05-01-01    v-michka  Picked up yslin's UTF-7/8 Whistler bug fixes: 371215/381323/381433/376403
--*/


//
//  Include Files.
//

#include "precomp.h"

// v-michka: cut some stuff out of utf.c. Since it is holding the forward
// declares for callers of functions in *this* file, there were problems
// with duplicate definitions. Its all part of not using nls.h for forward
// declares

#define ASCII                 0x007f

#define SHIFT_IN              '+'     // beginning of a shift sequence
#define SHIFT_OUT             '-'     // end       of a shift sequence

#define UTF8_2_MAX            0x07ff  // max UTF8 2-byte sequence (32 * 64 = 2048)
#define UTF8_1ST_OF_2         0xc0    // 110x xxxx
#define UTF8_1ST_OF_3         0xe0    // 1110 xxxx
#define UTF8_1ST_OF_4         0xf0    // 1111 xxxx
#define UTF8_TRAIL            0x80    // 10xx xxxx

#define HIGHER_6_BIT(u)       ((u) >> 12)
#define MIDDLE_6_BIT(u)       (((u) & 0x0fc0) >> 6)
#define LOWER_6_BIT(u)        ((u) & 0x003f)

#define BIT7(a)               ((a) & 0x80)
#define BIT6(a)               ((a) & 0x40)

#define HIGH_SURROGATE_START  0xd800
#define HIGH_SURROGATE_END    0xdbff
#define LOW_SURROGATE_START   0xdc00
#define LOW_SURROGATE_END     0xdfff

#define NlsStrLenW(wz) gwcslen(wz)

// content from utf.h in the Whistler project:

//
//  Convert one Unicode to 2 2/3 Base64 chars in a shifted sequence.
//  Each char represents a 6-bit portion of the 16-bit Unicode char.
//
CONST char cBase64[] =

  "ABCDEFGHIJKLMNOPQRSTUVWXYZ"  // A : 000000 .... 011001  ( 0 - 25)
  "abcdefghijklmnopqrstuvwxyz"  // a : 011010 .... 110011  (26 - 51)
  "0123456789"                  // 0 : 110100 .... 111101  (52 - 61)
  "+/";                         // + : 111110, / : 111111  (62 - 63)

//
//  To determine if an ASCII char needs to be shifted.
//    1 :     to be shifted
//    0 : not to be shifted
//
CONST BOOLEAN fShiftChar[] =
{
  0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1,    // Null, Tab, LF, CR
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,    // Space '() +,-./
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,    // 0123456789:    ?
  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  ABCDEFGHIJKLMNO
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,    // PQRSTUVWXYZ
  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  abcdefghijklmno
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1     // pqrstuvwxyz
};

/////////////////////////
//                     //
//  UTF-7 -> Unicode   //
//                     //
/////////////////////////

//
//  Convert a Base64 char in a shifted sequence to a 6-bit portion of a
//  Unicode char.
//  -1 means it is not a Base64
//
CONST char nBitBase64[] =
{
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,   //            +   /
  52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1,   // 0123456789
  -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,   //  ABCDEFGHIJKLMNO
  15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,   // PQRSTUVWXYZ
  -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,   //  abcdefghijklmno
  41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1    // pqrstuvwxyz
};




//
//  Forward Declarations.
//

int
UTF7ToUnicode(
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest);

int
UTF8ToUnicode(
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest,
    DWORD dwFlags);

int
UnicodeToUTF7(
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPSTR lpDestStr,
    int cchDest);

int
UnicodeToUTF8(
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPSTR lpDestStr,
    int cchDest);


/////////////////////////
//                     //
//  Unicode -> UTF-7   //
//                     //
/////////////////////////

//-------------------------------------------------------------------------//
//                           EXTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//

////////////////////////////////////////////////////////////////////////////
//
//  UTFCPInfo
//
//  Gets the CPInfo for the given UTF code page.
//
//  10-23-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL UTFCPInfo(
    UINT CodePage,
    LPCPINFO lpCPInfo,
    BOOL fExVer)
{
    int ctr;


    //
    //  Invalid Parameter Check:
    //     - validate code page
    //     - lpCPInfo is NULL
    //
    if ( (CodePage < CP_UTF7) || (CodePage > CP_UTF8) ||
         (lpCPInfo == NULL) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    switch (CodePage)
    {
        case ( CP_UTF7 ) :
        {
            lpCPInfo->MaxCharSize = 5;
            break;
        }
        case ( CP_UTF8 ) :
        {
            lpCPInfo->MaxCharSize = 4;
            break;
        }
    }

    (lpCPInfo->DefaultChar)[0] = '?';
    (lpCPInfo->DefaultChar)[1] = (BYTE)0;

    for (ctr = 0; ctr < MAX_LEADBYTES; ctr++)
    {
        (lpCPInfo->LeadByte)[ctr] = (BYTE)0;
    }

    if (fExVer)
    {
        LPCPINFOEXW lpCPInfoEx = (LPCPINFOEXW)lpCPInfo;

        lpCPInfoEx->UnicodeDefaultChar = L'?';
        lpCPInfoEx->CodePage = CodePage;
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  UTFToUnicode
//
//  Maps a UTF character string to its wide character string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int UTFToUnicode(
    UINT CodePage,
    DWORD dwFlags,
    LPCSTR lpMultiByteStr,
    int cbMultiByte,
    LPWSTR lpWideCharStr,
    int cchWideChar)
{
    int rc = 0;


    //
    //  Invalid Parameter Check:
    //     - validate code page
    //     - length of MB string is 0
    //     - wide char buffer size is negative
    //     - MB string is NULL
    //     - length of WC string is NOT zero AND
    //         (WC string is NULL OR src and dest pointers equal)
    //
    if ( (CodePage < CP_UTF7) || (CodePage > CP_UTF8) ||
         (cbMultiByte == 0) || (cchWideChar < 0) ||
         (lpMultiByteStr == NULL) ||
         ((cchWideChar != 0) &&
          ((lpWideCharStr == NULL) ||
           (lpMultiByteStr == (LPSTR)lpWideCharStr))) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Invalid Flags Check:
    //     - UTF7: flags not 0.
    //     - UTF8: flags not 0 nor MB_ERR_INVALID_CHARS.
    //
    if (CodePage == CP_UTF8) 
    {
        // UTF8        
        if ((dwFlags & ~MB_ERR_INVALID_CHARS) != 0)
        {
            SetLastError(ERROR_INVALID_FLAGS);
            return (0);
        }
    } 
    else if (dwFlags != 0)
    {
        // UTF7
        SetLastError(ERROR_INVALID_FLAGS);
        return (0);
    }

    //
    //  If cbMultiByte is -1, then the string is null terminated and we
    //  need to get the length of the string.  Add one to the length to
    //  include the null termination.  (This will always be at least 1.)
    //
    if (cbMultiByte <= -1)
    {
        cbMultiByte = strlen(lpMultiByteStr) + 1;
    }

    switch (CodePage)
    {
        case ( CP_UTF7 ) :
        {
            rc = UTF7ToUnicode( lpMultiByteStr,
                                cbMultiByte,
                                lpWideCharStr,
                                cchWideChar );
            break;
        }
        case ( CP_UTF8 ) :
        {
            rc = UTF8ToUnicode( lpMultiByteStr,
                                cbMultiByte,
                                lpWideCharStr,
                                cchWideChar,
                                dwFlags);
            break;
        }
    }

    return (rc);
}


////////////////////////////////////////////////////////////////////////////
//
//  UnicodeToUTF
//
//  Maps a Unicode character string to its UTF string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int UnicodeToUTF(
    UINT CodePage,
    DWORD dwFlags,
    LPCWSTR lpWideCharStr,
    int cchWideChar,
    LPSTR lpMultiByteStr,
    int cbMultiByte,
    LPCSTR lpDefaultChar,
    LPBOOL lpUsedDefaultChar)
{
    int rc = 0;


    //
    //  Invalid Parameter Check:
    //     - validate code page
    //     - length of WC string is 0
    //     - multibyte buffer size is negative
    //     - WC string is NULL
    //     - length of WC string is NOT zero AND
    //         (MB string is NULL OR src and dest pointers equal)
    //     - lpDefaultChar and lpUsedDefaultChar not NULL
    //
    if ( (CodePage < CP_UTF7) || (CodePage > CP_UTF8) ||
         (cchWideChar == 0) || (cbMultiByte < 0) ||
         (lpWideCharStr == NULL) ||
         ((cbMultiByte != 0) &&
          ((lpMultiByteStr == NULL) ||
           (lpWideCharStr == (LPWSTR)lpMultiByteStr))) ||
         (lpDefaultChar != NULL) || (lpUsedDefaultChar != NULL) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Invalid Flags Check:
    //     - flags not 0
    //
    if (dwFlags != 0)
    {
        SetLastError(ERROR_INVALID_FLAGS);
        return (0);
    }

    //
    //  If cchWideChar is -1, then the string is null terminated and we
    //  need to get the length of the string.  Add one to the length to
    //  include the null termination.  (This will always be at least 1.)
    //
    if (cchWideChar <= -1)
    {
        cchWideChar = NlsStrLenW(lpWideCharStr) + 1;
    }

    switch (CodePage)
    {
        case ( CP_UTF7 ) :
        {
            rc = UnicodeToUTF7( lpWideCharStr,
                                cchWideChar,
                                lpMultiByteStr,
                                cbMultiByte );
            break;
        }
        case ( CP_UTF8 ) :
        {
            rc = UnicodeToUTF8( lpWideCharStr,
                                cchWideChar,
                                lpMultiByteStr,
                                cbMultiByte );
            break;
        }
    }

    return (rc);
}




//-------------------------------------------------------------------------//
//                           INTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  UTF7ToUnicode
//
//  Maps a UTF-7 character string to its wide character string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int UTF7ToUnicode(
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest)
{
    //CHAR is signed, so we have to cast lpSrcStr to an unsigned char below.
    BYTE* pUTF7 = (BYTE*)lpSrcStr;    
    BOOL fShift = FALSE;
    DWORD dwBit = 0;              // 32-bit buffer to hold temporary bits
    int iPos = 0;                 // 6-bit position pointer in the buffer
    int cchWC = 0;                // # of Unicode code points generated


    while ((cchSrc--) && ((cchDest == 0) || (cchWC < cchDest)))
    {
        if (*pUTF7 > ASCII)
        {
            //
            //  Error - non ASCII char, so zero extend it.
            //
            if (cchDest)
            {
                lpDestStr[cchWC] = (WCHAR)*pUTF7;
            }
            cchWC++;
            // Terminate the shifted sequence.
            fShift = FALSE;
        }
        else if (!fShift)
        {
            //
            //  Not in shifted sequence.
            //
            if (*pUTF7 == SHIFT_IN)
            {
                if (cchSrc && (pUTF7[1] == SHIFT_OUT))
                {
                    //
                    //  "+-" means "+"
                    //
                    if (cchDest)
                    {
                        lpDestStr[cchWC] = (WCHAR)*pUTF7;
                    }
                    pUTF7++;
                    cchSrc--;
                    cchWC++;
                }
                else
                {
                    //
                    //  Start a new shift sequence.
                    //
                    fShift = TRUE;
                }
            }
            else
            {
                //
                //  No need to shift.
                //
                if (cchDest)
                {
                    lpDestStr[cchWC] = (WCHAR)*pUTF7;
                }
                cchWC++;
            }
        }
        else
        {
            //
            //  Already in shifted sequence.
            //
            if (nBitBase64[*pUTF7] == -1)
            {
                //
                //  Any non Base64 char also ends shift state.
                //
                if (*pUTF7 != SHIFT_OUT)
                {
                    //
                    //  Not "-", so write it to the buffer.
                    //
                    if (cchDest)
                    {
                        lpDestStr[cchWC] = (WCHAR)*pUTF7;
                    }
                    cchWC++;
                }

                //
                //  Reset bits.
                //
                fShift = FALSE;
                dwBit = 0;
                iPos = 0;
            }
            else
            {
                //
                //  Store the bits in the 6-bit buffer and adjust the
                //  position pointer.
                //
                dwBit |= ((DWORD)nBitBase64[*pUTF7]) << (26 - iPos);
                iPos += 6;
            }

            //
            //  Output the 16-bit Unicode value.
            //
            while (iPos >= 16)
            {
                if (cchDest)
                {
                    if (cchWC < cchDest)
                    {
                        lpDestStr[cchWC] = (WCHAR)(dwBit >> 16);
                    }
                    else
                    {
                        break;
                    }
                }
                cchWC++;

                dwBit <<= 16;
                iPos -= 16;
            }
            if (iPos >= 16)
            {
                //
                //  Error - buffer too small.
                //
                cchSrc++;
                break;
            }
        }

        pUTF7++;
    }

    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest && (cchSrc >= 0))
    {
        if (cchSrc == 0 && fShift && *(pUTF7--) == SHIFT_OUT)
        {
            //
            // Do nothing here.
            // If we are in shift-in mode previously, and the last byte is a shift-out byte ('-'),
            // we should absorb this byte.  So don't set error.
            //
        } else
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return (0);
        }
    }

    //
    //  Return the number of Unicode characters written.
    //
    return (cchWC);
}


////////////////////////////////////////////////////////////////////////////
//
//  UTF8ToUnicode
//
//  Maps a UTF-8 character string to its wide character string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int UTF8ToUnicode(
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest,
    DWORD dwFlags
    )
{
    int nTB = 0;                   // # trail bytes to follow
    int cchWC = 0;                 // # of Unicode code points generated
    LPCSTR pUTF8 = lpSrcStr;
    DWORD dwSurrogateChar;         // Full surrogate char
    BOOL bSurrogatePair = FALSE;   // Indicate we'r collecting a surrogate pair
    BOOL bCheckInvalidBytes = (dwFlags & MB_ERR_INVALID_CHARS);
    char UTF8;


    while ((cchSrc--) && ((cchDest == 0) || (cchWC < cchDest)))
    {
        //
        //  See if there are any trail bytes.
        //
        if (BIT7(*pUTF8) == 0)
        {
            //
            //  Found ASCII.
            //
            if (cchDest)
            {
                lpDestStr[cchWC] = (WCHAR)*pUTF8;
            }
            nTB = bSurrogatePair = 0;
            cchWC++;
        }
        else if (BIT6(*pUTF8) == 0)
        {
            //
            //  Found a trail byte.
            //  Note : Ignore the trail byte if there was no lead byte.
            //
            if (nTB != 0)
            {
                //
                //  Decrement the trail byte counter.
                //
                nTB--;

                if (bSurrogatePair)
                {
                    dwSurrogateChar <<= 6;
                    dwSurrogateChar |= LOWER_6_BIT(*pUTF8);

                    if (nTB == 0)
                    {
                        if (cchDest)
                        {
                            if ((cchWC + 1) < cchDest)
                            {
                                lpDestStr[cchWC]   = (WCHAR)
                                                     (((dwSurrogateChar - 0x10000) >> 10) + HIGH_SURROGATE_START);

                                lpDestStr[cchWC+1] = (WCHAR)
                                                     ((dwSurrogateChar - 0x10000)%0x400 + LOW_SURROGATE_START);
                            }
                            else
                            {
                                // Error : Buffer too small
                                cchSrc++;
                                break;
                            }
                        }

                        cchWC += 2;
                        bSurrogatePair = FALSE;
                    }
                }
                else
                {
                    //
                    //  Make room for the trail byte and add the trail byte
                    //  value.
                    //
                    if (cchDest)
                    {
                        lpDestStr[cchWC] <<= 6;
                        lpDestStr[cchWC] |= LOWER_6_BIT(*pUTF8);
                        
                    }

                    if (nTB == 0)
                    {
                        //
                        //  End of sequence.  Advance the output counter.
                        //
                        cchWC++;
                    }
                }
            }
            else
            {
                if (bCheckInvalidBytes) 
                {
                    SetLastError(ERROR_NO_UNICODE_TRANSLATION);
                    return (0);
                }
                // error - not expecting a trail byte. That is, there is a trailing byte without leading byte.
                bSurrogatePair = FALSE;
            }
        }
        else
        {
            //
            //  Found a lead byte.
            //
            if (nTB > 0)
            {
                // error - A leading byte before the previous sequence is completed.
                if (bCheckInvalidBytes) 
                {
                    SetLastError(ERROR_NO_UNICODE_TRANSLATION);
                    return (0);
                }            
                //
                //  Error - previous sequence not finished.
                //
                nTB = 0;
                bSurrogatePair = FALSE;
                // Put this character back so that we can start over another sequence.
                cchSrc++;
                pUTF8--;
            }
            else
            {
                //
                //  Calculate the number of bytes to follow.
                //  Look for the first 0 from left to right.
                //
                UTF8 = *pUTF8;
                while (BIT7(UTF8) != 0)
                {
                    UTF8 <<= 1;
                    nTB++;
                }

                //
                // Check for non-shortest form.
                // 
                switch (nTB) {
                    case 1:
                        nTB = 0;
                        break;
                    case 2:
                        // Make sure that bit 8 ~ bit 11 is not all zero.
                        // 110XXXXx 10xxxxxx
                        if ((*pUTF8 & 0x1e) == 0)
                        {
                            nTB = 0;
                        }
                        break;
                    case 3:
                        // Look ahead to check for non-shortest form.
                        // 1110XXXX 10Xxxxxx 10xxxxxx
                        if (cchSrc >= 2)
                        {
                            if (((*pUTF8 & 0x0f) == 0) && (*(pUTF8 + 1) & 0x20) == 0)
                            {
                                nTB = 0;
                            }
                        }
                        break;
                    case 4:                    
                        //
                        // This is a surrogate unicode pair
                        //
                        if (cchSrc >= 3)
                        {
                            WORD word = (((WORD)*pUTF8) << 8) | *(pUTF8 + 1);
                            // Look ahead to check for non-shortest form.
                            // 11110XXX 10XXxxxx 10xxxxxx 10xxxxxx                        
                            // Check for the 5 bits are not all zero.
                            // 0x0730 == 00000111 11000000
                            if ((word & 0x0730) == 0) 
                            {
                                nTB = 0;
                            } else if ((word & 0x0400) == 0x0400)
                            {
                                // The 21st bit is 1.
                                // Make sure that the resulting Unicode is within the valid surrogate range.
                                // The 4 byte code sequence can hold up to 21 bits, and the maximum valid code point ragne
                                // that Unicode (with surrogate) could represent are from U+000000 ~ U+10FFFF.
                                // Therefore, if the 21 bit (the most significant bit) is 1, we should verify that the 17 ~ 20
                                // bit are all zero.
                                // I.e., in 11110XXX 10XXxxxx 10xxxxxx 10xxxxxx,
                                // XXXXX can only be 10000.

                                // 0x0330 = 0000 0011 0011 0000
                                if ((word & 0x0330) != 0) 
                                {
                                    nTB = 0;
                                }                            
                            } else
                            { 
                                dwSurrogateChar = UTF8 >> nTB;
                                bSurrogatePair = TRUE;
                            }
                        }                        
                        break;
                    default:                    
                        // 
                        // If the bits is greater than 4, this is an invalid
                        // UTF8 lead byte.
                        //
                        nTB = 0;
                        break;
                }

                if (nTB != 0) 
                {
                    //
                    //  Store the value from the first byte and decrement
                    //  the number of bytes to follow.
                    //
                    if (cchDest)
                    {
                        lpDestStr[cchWC] = UTF8 >> nTB;
                    }
                    nTB--;
                } else 
                {
                    if (bCheckInvalidBytes) 
                    {
                        SetLastError(ERROR_NO_UNICODE_TRANSLATION);
                        return (0);
                    }                 
                }
            }
        }
        pUTF8++;
    }

    if ((bCheckInvalidBytes && nTB != 0) || (cchWC == 0)) 
    {
        // About (cchWC == 0):
        // Because we now throw away non-shortest form, it is possible that we generate 0 chars.
        // In this case, we have to set error to ERROR_NO_UNICODE_TRANSLATION so that we conform
        // to the spec of MultiByteToWideChar.
        SetLastError(ERROR_NO_UNICODE_TRANSLATION);
        return (0);
    }
    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest && (cchSrc >= 0))
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }


    //
    //  Return the number of Unicode characters written.
    //
    return (cchWC);
}


////////////////////////////////////////////////////////////////////////////
//
//  UnicodeToUTF7
//
//  Maps a Unicode character string to its UTF-7 string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int UnicodeToUTF7(
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPSTR lpDestStr,
    int cchDest)
{
    LPCWSTR lpWC = lpSrcStr;
    BOOL fShift = FALSE;
    DWORD dwBit = 0;              // 32-bit buffer
    int iPos = 0;                 // 6-bit position in buffer
    int cchU7 = 0;                // # of UTF7 chars generated


    while ((cchSrc--) && ((cchDest == 0) || (cchU7 < cchDest)))
    {
        if ((*lpWC > ASCII) || (fShiftChar[*lpWC]))
        {
            //
            //  Need shift.  Store 16 bits in buffer.
            //
            dwBit |= ((DWORD)*lpWC) << (16 - iPos);
            iPos += 16;

            if (!fShift)
            {
                //
                //  Not in shift state, so add "+".
                //
                if (cchDest)
                {
                    lpDestStr[cchU7] = SHIFT_IN;
                }
                cchU7++;

                //
                //  Go into shift state.
                //
                fShift = TRUE;
            }

            //
            //  Output 6 bits at a time as Base64 chars.
            //
            while (iPos >= 6)
            {
                if (cchDest)
                {
                    if (cchU7 < cchDest)
                    {
                        //
                        //  26 = 32 - 6
                        //
                        lpDestStr[cchU7] = cBase64[(int)(dwBit >> 26)];
                    }
                    else
                    {
                        break;
                    }
                }

                cchU7++;
                dwBit <<= 6;           // remove from bit buffer
                iPos -= 6;             // adjust position pointer
            }
            if (iPos >= 6)
            {
                //
                //  Error - buffer too small.
                //
                cchSrc++;
                break;
            }
        }
        else
        {
            //
            //  No need to shift.
            //
            if (fShift)
            {
                //
                //  End the shift sequence.
                //
                fShift = FALSE;

                if (iPos != 0)
                {
                    //
                    //  Some bits left in dwBit.
                    //
                    if (cchDest)
                    {
                        if ((cchU7 + 1) < cchDest)
                        {
                            lpDestStr[cchU7++] = cBase64[(int)(dwBit >> 26)];
                            lpDestStr[cchU7++] = SHIFT_OUT;
                        }
                        else
                        {
                            //
                            //  Error - buffer too small.
                            //
                            cchSrc++;
                            break;
                        }
                    }
                    else
                    {
                        cchU7 += 2;
                    }

                    dwBit = 0;         // reset bit buffer
                    iPos  = 0;         // reset postion pointer
                }
                else
                {
                    //
                    //  Simply end the shift sequence.
                    //
                    if (cchDest)
                    {
                        lpDestStr[cchU7++] = SHIFT_OUT;
                    }
                    else
                    {
                        cchU7++;
                    }
                }
            }

            //
            //  Write the character to the buffer.
            //  If the character is "+", then write "+-".
            //
            if (cchDest)
            {
                if (cchU7 < cchDest)
                {
                    lpDestStr[cchU7++] = (char)*lpWC;

                    if (*lpWC == SHIFT_IN)
                    {
                        if (cchU7 < cchDest)
                        {
                            lpDestStr[cchU7++] = SHIFT_OUT;
                        }
                        else
                        {
                            //
                            //  Error - buffer too small.
                            //
                            cchSrc++;
                            break;
                        }
                    }
                }
                else
                {
                    //
                    //  Error - buffer too small.
                    //
                    cchSrc++;
                    break;
                }
            }
            else
            {
                cchU7++;

                if (*lpWC == SHIFT_IN)
                {
                    cchU7++;
                }
            }
        }

        lpWC++;
    }

    //
    //  See if we're still in the shift state.
    //
    if (fShift)
    {
        if (iPos != 0)
        {
            //
            //  Some bits left in dwBit.
            //
            if (cchDest)
            {
                if ((cchU7 + 1) < cchDest)
                {
                    lpDestStr[cchU7++] = cBase64[(int)(dwBit >> 26)];
                    lpDestStr[cchU7++] = SHIFT_OUT;
                }
                else
                {
                    //
                    //  Error - buffer too small.
                    //
                    cchSrc++;
                }
            }
            else
            {
                cchU7 += 2;
            }
        }
        else
        {
            //
            //  Simply end the shift sequence.
            //
            if (cchDest)
            {
                lpDestStr[cchU7++] = SHIFT_OUT;
            }
            else
            {
                cchU7++;
            }
        }
    }

    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest && (cchSrc >= 0))
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Return the number of UTF-7 characters written.
    //
    return (cchU7);
}


////////////////////////////////////////////////////////////////////////////
//
//  UnicodeToUTF8
//
//  Maps a Unicode character string to its UTF-8 string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int UnicodeToUTF8(
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPSTR lpDestStr,
    int cchDest)
{
    LPCWSTR lpWC = lpSrcStr;
    int     cchU8 = 0;                // # of UTF8 chars generated
    DWORD   dwSurrogateChar;
    WCHAR   wchHighSurrogate = 0;
    BOOL    bHandled;


    while ((cchSrc--) && ((cchDest == 0) || (cchU8 < cchDest)))
    {
        bHandled = FALSE;

        //
        // Check if high surrogate is available
        //
        if ((*lpWC >= HIGH_SURROGATE_START) && (*lpWC <= HIGH_SURROGATE_END))
        {
            if (cchDest)
            {
                // Another high surrogate, then treat the 1st as normal
                // Unicode character.
                if (wchHighSurrogate)
                {
                    if ((cchU8 + 2) < cchDest)
                    {
                        lpDestStr[cchU8++] = UTF8_1ST_OF_3 | HIGHER_6_BIT(wchHighSurrogate);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | MIDDLE_6_BIT(wchHighSurrogate);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(wchHighSurrogate);
                    }
                    else
                    {
                        // not enough buffer
                        cchSrc++;
                        break;
                    }
                }
            }
            else
            {
                cchU8 += 3;
            }
            wchHighSurrogate = *lpWC;
            bHandled = TRUE;
        }

        if (!bHandled && wchHighSurrogate)
        {
            if ((*lpWC >= LOW_SURROGATE_START) && (*lpWC <= LOW_SURROGATE_END))
            {
                 // wheee, valid surrogate pairs

                 if (cchDest)
                 {
                     if ((cchU8 + 3) < cchDest)
                     {
                         dwSurrogateChar = (((wchHighSurrogate-0xD800) << 10) + (*lpWC - 0xDC00) + 0x10000);

                         lpDestStr[cchU8++] = (UTF8_1ST_OF_4 |
                                               (unsigned char)(dwSurrogateChar >> 18));           // 3 bits from 1st byte

                         lpDestStr[cchU8++] =  (UTF8_TRAIL |
                                                (unsigned char)((dwSurrogateChar >> 12) & 0x3f)); // 6 bits from 2nd byte

                         lpDestStr[cchU8++] = (UTF8_TRAIL |
                                               (unsigned char)((dwSurrogateChar >> 6) & 0x3f));   // 6 bits from 3rd byte

                         lpDestStr[cchU8++] = (UTF8_TRAIL |
                                               (unsigned char)(0x3f & dwSurrogateChar));          // 6 bits from 4th byte
                     }
                     else
                     {
                        // not enough buffer
                        cchSrc++;
                        break;
                     }
                 }
                 else
                 {
                     // we already counted 3 previously (in high surrogate)
                     cchU8 += 1;
                 }

                 bHandled = TRUE;
            }
            else
            {
                 // Bad Surrogate pair : ERROR
                 // Just process wchHighSurrogate , and the code below will
                 // process the current code point
                 if (cchDest)
                 {
                     if ((cchU8 + 2) < cchDest)
                     {
                        lpDestStr[cchU8++] = UTF8_1ST_OF_3 | HIGHER_6_BIT(wchHighSurrogate);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | MIDDLE_6_BIT(wchHighSurrogate);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(wchHighSurrogate);
                     }
                     else
                     {
                        // not enough buffer
                        cchSrc++;
                        break;
                     }
                 }
            }

            wchHighSurrogate = 0;
        }

        if (!bHandled)
        {
            if (*lpWC <= ASCII)
            {
                //
                //  Found ASCII.
                //
                if (cchDest)
                {
                    lpDestStr[cchU8] = (char)*lpWC;
                }
                cchU8++;
            }
            else if (*lpWC <= UTF8_2_MAX)
            {
                //
                //  Found 2 byte sequence if < 0x07ff (11 bits).
                //
                if (cchDest)
                {
                    if ((cchU8 + 1) < cchDest)
                    {
                        //
                        //  Use upper 5 bits in first byte.
                        //  Use lower 6 bits in second byte.
                        //
                        lpDestStr[cchU8++] = UTF8_1ST_OF_2 | (*lpWC >> 6);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(*lpWC);
                    }
                    else
                    {
                        //
                        //  Error - buffer too small.
                        //
                        cchSrc++;
                        break;
                    }
                }
                else
                {
                    cchU8 += 2;
                }
            }
            else
            {
                //
                //  Found 3 byte sequence.
                //
                if (cchDest)
                {
                    if ((cchU8 + 2) < cchDest)
                    {
                        //
                        //  Use upper  4 bits in first byte.
                        //  Use middle 6 bits in second byte.
                        //  Use lower  6 bits in third byte.
                        //
                        lpDestStr[cchU8++] = UTF8_1ST_OF_3 | HIGHER_6_BIT(*lpWC);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | MIDDLE_6_BIT(*lpWC);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(*lpWC);
                    }
                    else
                    {
                        //
                        //  Error - buffer too small.
                        //
                        cchSrc++;
                        break;
                    }
                }
                else
                {
                    cchU8 += 3;
                }
            }
        }

        lpWC++;
    }

    //
    // If the last character was a high surrogate, then handle it as a normal
    // unicode character.
    //
    if ((cchSrc < 0) && (wchHighSurrogate != 0))
    {
        if (cchDest)
        {
            if ((cchU8 + 2) < cchDest)
            {
                lpDestStr[cchU8++] = UTF8_1ST_OF_3 | HIGHER_6_BIT(wchHighSurrogate);
                lpDestStr[cchU8++] = UTF8_TRAIL    | MIDDLE_6_BIT(wchHighSurrogate);
                lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(wchHighSurrogate);
            }
            else
            {
                cchSrc++;
            }
        }
    }

    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest && (cchSrc >= 0))
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Return the number of UTF-8 characters written.
    //
    return (cchU8);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\godot\utf.h ===
/*++

Copyright (c) 1991-2001,  Microsoft Corporation  All rights reserved.

Module Name:

    utf.h

Abstract:

    This file contains the header information for the UTF module of NLS.

Revision History:

    02-06-96    JulieB    Created.
    01-23-01    v-michka  Ported to Godot

--*/

// v-michka: the one define we need from nls.h!
#define NLS_CP_ALGORITHM_RANGE    60000     // begin code page Algorithm range

// v-michka: Some random forward declares that really ought to go elsewhere
int UTFToUnicode(UINT CodePage,DWORD dwFlags,LPCSTR lpMultiByteStr,int cbMultiByte,LPWSTR lpWideCharStr,int cchWideChar);
int UnicodeToUTF(UINT CodePage,DWORD dwFlags,LPCWSTR lpWideCharStr,int cchWideChar,LPSTR lpMultiByteStr,int cbMultiByte,LPCSTR lpDefaultChar,LPBOOL lpUsedDefaultChar);
BOOL UTFCPInfo(UINT CodePage,LPCPINFO lpCPInfo,BOOL fExVer);

// moved almost everything to utf.c except the bare stuff needed for external callers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\godot\updres.h ===
/*++

(C) Copyright Microsoft Corporation 1988-2001

Module Name:

    updres.h

Author:

    Floyd A Rogers 2/7/92

Revision History:
        Floyd Rogers
        Created

        v-michka    Ported to Godot
--*/

#define DEFAULT_CODEPAGE 1252
#define MAJOR_RESOURCE_VERSION 4
#define MINOR_RESOURCE_VERSION 0

#define BUTTONCODE      0x80
#define EDITCODE        0x81
#define STATICCODE      0x82
#define LISTBOXCODE     0x83
#define SCROLLBARCODE   0x84
#define COMBOBOXCODE    0x85

#define SEEK_SET    0
#define SEEK_CUR    1
#define SEEK_END    2
#define MAXSTR      (256+1)

//
// An ID_WORD indicates the following WORD is an ordinal rather
// than a string
//
#define ID_WORD 0xffff

typedef struct MY_STRING
{
    ULONG discriminant;       // long to make the rest of the struct aligned
    union u
    {
        struct
        {
            struct MY_STRING *pnext;
            ULONG  ulOffsetToString;
            USHORT cbD;
            USHORT cb;
            WCHAR  *sz;
        } ss;
        WORD     Ordinal;
    } uu;
} SDATA, *PSDATA, **PPSDATA;

#define IS_STRING 1
#define IS_ID     2

// defines to make dereferencing easier
#define OffsetToString uu.ss.ulOffsetToString
#define cbData         uu.ss.cbD
#define cbsz           uu.ss.cb
#define szStr          uu.ss.sz

typedef struct _RESNAME
{
    struct _RESNAME *pnext; // The first three fields should be the
    PSDATA          Name;   // same in both res structures
    ULONG           OffsetToData;

    PSDATA          Type;
    ULONG           SectionNumber;
    ULONG           DataSize;
    ULONG           OffsetToDataEntry;
    USHORT          ResourceNumber;
    USHORT          NumberOfLanguages;
    WORD            LanguageId;
}RESNAME, *PRESNAME, **PPRESNAME;

typedef struct _RESTYPE
{
    struct _RESTYPE *pnext; // The first three fields should be the
    PSDATA          Type;   // same in both res structures
    ULONG           OffsetToData;

    struct _RESNAME *NameHeadID;
    struct _RESNAME *NameHeadName;
    ULONG           NumberOfNamesID;
    ULONG           NumberOfNamesName;
} RESTYPE, *PRESTYPE, **PPRESTYPE;

typedef struct _UPDATEDATA
{
    ULONG           cbStringTable;
    PSDATA          StringHead;
    PRESNAME        ResHead;
    PRESTYPE        ResTypeHeadID;
    PRESTYPE        ResTypeHeadName;
    LONG            Status;
    HANDLE          hFileName;
} UPDATEDATA, *PUPDATEDATA;

//
// Round up a byte count to a power of 2:
//
#define ROUNDUP(cbin, align) (((cbin) + (align) - 1) & ~((align) - 1))

//
// Return the remainder, given a byte count and a power of 2:
//
#define REMAINDER(cbin,align) (((align)-((cbin)&((align)-1)))&((align)-1))

#define CBLONG        (sizeof(LONG))
#define BUFSIZE        (4L * 1024L)

/* functions for adding/deleting resources to update list */
LONG AddResource(IN PSDATA Type, IN PSDATA Name, IN WORD Language, IN PUPDATEDATA pupd, IN PVOID lpData, IN ULONG cb);
PSDATA AddStringOrID(LPCWSTR lp, PUPDATEDATA pupd);
BOOL InsertResourceIntoLangList(PUPDATEDATA pUpd, PSDATA Type, PSDATA Name, PRESTYPE pType, PRESNAME pName, INT idLang, INT fName, INT cb, PVOID lpData);
BOOL DeleteResourceFromList(PUPDATEDATA pUpd, PRESTYPE pType, PRESNAME pName, INT idLang, INT fType, INT fName);

/* Prototypes for Enumeration done in BeginUpdateResource */
BOOL EnumTypesFunc(HANDLE hModule, LPWSTR lpType, LONG lParam);
BOOL EnumNamesFunc(HANDLE hModule, LPWSTR lpName, LPWSTR lpType, LONG lParam);
BOOL EnumLangsFunc(HANDLE hModule, LPWSTR lpType, LPWSTR lpName, WORD languages, LONG lParam);

/* Prototypes for general worker functions in updres.c */
LONG WriteResFile(IN HANDLE hUpdate, IN WCHAR *pDstname);
VOID FreeData(PUPDATEDATA pUpd);
PRESNAME WriteResSection(PUPDATEDATA pUpdate, INT outfh, ULONG align, ULONG cbLeft, PRESNAME pResSave);
LONG PatchRVAs(int inpfh, int outfh, PIMAGE_SECTION_HEADER po32, ULONG pagedelta, PIMAGE_NT_HEADERS pNew, ULONG OldSize);
LONG PatchDebug(int inpfh, int outfh, PIMAGE_SECTION_HEADER po32DebugOld, PIMAGE_SECTION_HEADER po32DebugNew, PIMAGE_SECTION_HEADER po32DebugDirOld, PIMAGE_SECTION_HEADER po32DebugDirNew, PIMAGE_NT_HEADERS pOld, PIMAGE_NT_HEADERS pNew, ULONG ibMaxDbgOffsetOld, PULONG pPointerToRawData);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\godot\winincs.cpp ===
#include "headers.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\godot\util.c ===
/*++

Copyright (c) 2000-2001,  Microsoft Corporation  All rights reserved.

Module Name:

    util.c

Abstract:

    Several utility functions we need are thrown in here for kicks.

        MiniAtoI
        CpgFromLocale
        CbPerChOfCpg
        GetKernelHandle
        GetUserHandle
        GetAdvapiHandle
        GetRasHandle
        GetOtherRasHandle
        GetComDlgHandle
        cchUnicodeMultiSz
        cbAnsiMultiSz

Revision History:

    17 Mar 2001    v-michka    Created.

--*/

#include "precomp.h"

// forward declares
void LoadLibrarySafe(HMODULE * phMod, char * Library);

// our remembered handles for various DLLs we dynamically load from
// CONSIDER: Maybe we could free up the one handle we have for each
//           library? We cannot do this in DllMain according to PSDK
//           docs, but maybe it is worth doing if we are being 
//           unloaded anyway by the caller?
static HMODULE m_hModGB18030 = 0;
static HMODULE m_hModComDlg = 0;
static HMODULE m_hModOtherRas = 0;
static HMODULE m_hModRas = 0;
static HMODULE m_hModAdvapi = 0;
static HMODULE m_hModUser = 0;
static HMODULE m_hModKernel = 0;
static HMODULE m_hModSensapi = 0;
static HMODULE m_hModOleAcc = 0;

/*-------------------------------
    CpgFromLocale

    Given a locale, returns the appropriate codepage to use
    for conversions
-------------------------------*/
UINT CpgFromLocale(LCID Locale)
{
    char lpLCData[6];    // Max of this param, per PSDK docs
    
    if (GetLocaleInfoA(Locale, LOCALE_IDEFAULTANSICODEPAGE, lpLCData, 6))
        return(MiniAtoI(lpLCData));

    return(g_acp);
}

/*-------------------------------
    CpgOemFromLocale

    Given a locale, returns the appropriate OEM codepage to use
    for conversions
-------------------------------*/
UINT CpgOemFromLocale(LCID Locale)
{
    char lpLCData[6];    // Max of this param, per PSDK docs
    
    if (GetLocaleInfoA(Locale, LOCALE_IDEFAULTCODEPAGE, lpLCData, 6))
        return(MiniAtoI(lpLCData));

    return(g_oemcp);
}

#pragma intrinsic (strlen)

/*-------------------------------
    MiniAtoI

    Our baby version of the atoi function. Since we know that we always have
    full digits with no white space, we can be nicer about this than the
    VC runtime version is (since they have so many special cases).
-------------------------------*/
UINT MiniAtoI(const char * lpsz)
{
    size_t cch = (lpsz ? strlen(lpsz) : 0);
    UINT RetVal = 0;
    UINT mod = 1;
    UINT ich;
    char ch;

    for(ich = 1 ; ich <= cch ; ich++)
    {
        ch = lpsz[cch - ich];
        RetVal += ((ch - '0') * mod);
        mod *= 10;
    }
    return(RetVal);
}

/*-------------------------------
    CbPerChOfCpg

    Given a code page, returns the maximum number of bytes 
    that can be needed for a single character.
-------------------------------*/
UINT CbPerChOfCpg(UINT cpg)
{
    CPINFO cpi;

    if(GetCPInfo(cpg, &cpi))
        return(cpi.MaxCharSize);

    // We should not fail here, but if we do, default to requiring a big
    // buffer, just to be safe.
    return(2);
}

/*-------------------------------
    CpgFromHdc

    Given a device context handle, returns the code page to 
    use. This is something that a lot of GDI functions do.
-------------------------------*/
UINT CpgFromHdc(HDC hdc)
{
    int chs;
    CHARSETINFO csi;

    chs = GetTextCharset(hdc);
    if(TranslateCharsetInfo(&(DWORD)chs, &csi, TCI_SRCCHARSET))
        return(csi.ciACP);
    else
        return(g_acp);
}

/*-------------------------------
    GetUserHandle
-------------------------------*/
HMODULE GetUserHandle(void)
{
    if (!m_hModUser)
    {
        m_hModUser = GetModuleHandleA("user32");
        if (!m_hModUser)
            LoadLibrarySafe(&m_hModUser, "user32");
    }
    return(m_hModUser);
}

/*-------------------------------
    GetComDlgHandle
-------------------------------*/
HMODULE GetComDlgHandle(void)
{
    if (!m_hModComDlg)
        LoadLibrarySafe(&m_hModComDlg, "comdlg32.dll");

    return m_hModComDlg;
}

/*-------------------------------
    GetGB18030Handle
-------------------------------*/
HMODULE GetGB18030Handle(void)
{
    if (!m_hModGB18030)
        LoadLibrarySafe(&m_hModGB18030, "c_gb18030.dll");

    return m_hModGB18030;
}

/*-------------------------------
    GetKernelProc
    
    We do not need to call LoadLibrary since we are sure it is 
    loaded (it is loaded into every process!)
-------------------------------*/
FARPROC GetKernelProc(LPCSTR Function)
{
    if (!m_hModKernel)
        m_hModKernel = GetModuleHandleA("kernel32");
    return(GetProcAddress(m_hModKernel, Function));
}

/*-------------------------------
    GetUserProc
-------------------------------*/
FARPROC GetUserProc(LPCSTR Function)
{
    return(GetProcAddress(GetUserHandle(), Function));
}

/*-------------------------------
    GetAdvapiProc
-------------------------------*/
FARPROC GetAdvapiProc(LPCSTR Function)
{
    if (!m_hModAdvapi)
    {
        m_hModAdvapi = GetModuleHandleA("advapi32");
        if (!m_hModAdvapi)
            LoadLibrarySafe(&m_hModAdvapi, "advapi32");
    }
    return(GetProcAddress(m_hModAdvapi, Function));
}

/*-------------------------------
    GetOleAccProc
-------------------------------*/
FARPROC GetOleAccProc(LPCSTR Function)
{
    if (!m_hModOleAcc)
        LoadLibrarySafe(&m_hModOleAcc, "oleacc.dll");
    return(GetProcAddress(m_hModOleAcc, Function));
}

/*-------------------------------
    GetSensApiProc
-------------------------------*/
FARPROC GetSensApiProc(LPCSTR Function)
{
    if (!m_hModSensapi)
        LoadLibrarySafe(&m_hModSensapi, "sensapi.dll");
    return(GetProcAddress(m_hModSensapi, Function));
}

/*-------------------------------
    GetRasProc

    All RAS procs are in some DLL but we do not know
    which one; therefore, we use this wrapper to get
    the procs
-------------------------------*/
FARPROC GetRasProc(LPCSTR Function)
{
    FARPROC RetVal;

    if (!m_hModRas)
        LoadLibrarySafe(&m_hModRas, "rasapi32.dll");
    RetVal = GetProcAddress(m_hModRas, Function);

    if(RetVal==0)
    {
        if (!m_hModOtherRas)
            LoadLibrarySafe(&m_hModOtherRas, "rnaph.dll");
        RetVal = GetProcAddress(m_hModOtherRas, Function);
    }

    return(RetVal);
}

/*-------------------------------
    LoadLibrarySafe

    Keeps us from ever LoadLibrarying more than one
    time in multithreaded scenarios.
-------------------------------*/
void LoadLibrarySafe(HMODULE * phMod, char * Library)
{
    HMODULE hModT = LoadLibraryA(Library);

    if(InterlockedExchange((LPLONG)&(*phMod), (LONG)hModT) != 0)
    {
        // Some other thread beat us to it, lets unload our instance
        FreeLibrary(hModT);
    }
}


//----------------------------------------------------------------------------
// There are strings which are blocks of strings end to end with a trailing '\0'
// to indicate the true end.  These strings are used with the REG_MULTI_SZ
// option of the Reg... routines and the lpstrFilter field of the OPENFILENAME
// structure used in the GetOpenFileName and GetSaveFileName routines.  To help
// in converting these strings here are two routines which calculate the size
// of the Unicode and ANSI versions (including all '\0's!):

// Stolen from VSANSI

//----------------------------------------------------------------
// Return size of WCHAR string list in WCHARs.
size_t cchUnicodeMultiSz(LPCWSTR lpsz)
{
    LPCWSTR pch = lpsz;
    for (;;)
    {
        if (*pch)
            pch++;
        else
        {
            pch++;
            if (!*pch)
                break;
        }
    }
    return 1 + (pch - lpsz);
}

//----------------------------------------------------------------
// Return size of ANSI string list in bytes.
size_t cbAnsiMultiSz(LPCSTR lpsz)
{
    LPCSTR pch = lpsz;
    for (;;)
    {
        if (*pch)
            pch++;
        else
        {
            pch++;
            // Break if we've reached the double Null
            if (!*pch)
                break;
        }
    }
    return 1 + (pch - lpsz);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\godot\util.h ===
/*++

Copyright (c) 2000-2001,  Microsoft Corporation  All rights reserved.

Module Name:

    util.h

Abstract:

    Header over util.c

    APIs found in this file:

Revision History:

    7 Nov 2000    v-michka    Created.

--*/

#ifndef UTIL_H
#define UTIL_H

// helpful utility macros
#define FILES_CPG (AreFileApisANSI() ? g_acp : g_oemcp)

// Misc. helpful utility functions
UINT CpgFromLocale(LCID Locale);
UINT CpgOemFromLocale(LCID Locale);
UINT CbPerChOfCpg(UINT cpg);
UINT MiniAtoI(const char * lpsz);
UINT CpgFromHdc(HDC hdc);
size_t cchUnicodeMultiSz(LPCWSTR lpsz);
size_t cbAnsiMultiSz(LPCSTR lpsz);

// Our handle/function grabbers. I am afraid to call them 
// "helpers" since we never free the dlls that they load.
HMODULE GetUserHandle(void);
HMODULE GetComDlgHandle(void);
HMODULE GetGB18030Handle(void);
FARPROC GetKernelProc(LPCSTR Function);
FARPROC GetUserProc(LPCSTR Function);
FARPROC GetAdvapiProc(LPCSTR Function);
FARPROC GetOleAccProc(LPCSTR Function);
FARPROC GetSensApiProc(LPCSTR Function);
FARPROC GetRasProc(LPCSTR Function);

#endif // UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\ctrltest\godot\ctrltest.cpp ===
// ctrltest.cpp : Dialogs and Controls test applet
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "ctrltest.h"

/////////////////////////////////////////////////////////////////////////////
// Main Window

// The OnTest routines are in the source files containing the particular
// dialog that they are working with.  For example OnTestDerivedEdit is
// in file dertest.cpp

BEGIN_MESSAGE_MAP(CTestWindow, CFrameWnd)
	//{{AFX_MSG_MAP(CTestWindow)
	ON_COMMAND(IDM_TEST_DERIVED_EDIT, OnTestDerivedEdit)
	ON_COMMAND(IDM_TEST_WNDCLASS_EDIT, OnTestWndClassEdit)
	ON_COMMAND(IDM_TEST_SUB_EDIT, OnTestSubclassedEdit)
	ON_COMMAND(IDM_TEST_BITMAP_BUTTON1, OnTestBitmapButton1)
	ON_COMMAND(IDM_TEST_BITMAP_BUTTON2, OnTestBitmapButton2)
	ON_COMMAND(IDM_TEST_BITMAP_BUTTON3, OnTestBitmapButton3)
	ON_COMMAND(IDM_TEST_CUSTOM_LIST, OnTestCustomList)
	ON_COMMAND(IDM_TEST_SPIN_EDIT, OnTestSpinEdit)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CTestWindow::SetupMenus()
{
	if ((GetSystemMetrics(SM_PENWINDOWS)) == NULL)
	{
		CMenu* pMenu = GetMenu();
		ASSERT(pMenu != NULL);
		pMenu->EnableMenuItem(IDM_TEST_PENEDIT_CODE, MF_DISABLED|MF_GRAYED);
		pMenu->EnableMenuItem(IDM_TEST_PENEDIT_TEMPLATE, MF_DISABLED|MF_GRAYED);
		pMenu->EnableMenuItem(IDM_TEST_PENEDIT_FEATURES, MF_DISABLED|MF_GRAYED);
	}
	// do not test for spin control until the user tries it
	// if the custom control DLL is not present, the test spin
	//  control menu item will be disabled in 'OnTestSpinEdit'.

	// custom menu tests
	AttachCustomMenu();
}

/////////////////////////////////////////////////////////////////////////////
// Application class

class CTestApp : public CWinApp
{
public:
	CTestApp();

	virtual BOOL InitInstance();
	//{{AFX_MSG(CTestApp)
	afx_msg void OnAppAbout();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP();
};

CTestApp::CTestApp()
{
	// Place all significant initialization in InitInstance
}


BEGIN_MESSAGE_MAP(CTestApp, CWinApp)
	//{{AFX_MSG_MAP(CTestApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CTestApp NEAR theTestApp;

BOOL CTestApp::InitInstance()
{
	//SetDialogBkColor();   // Gray dialog backgrounds
	Enable3dControls();

	CTestWindow* pMainWnd = new CTestWindow;
	if (!pMainWnd->Create(NULL, _T("Control Test App"),
	  WS_OVERLAPPEDWINDOW, CFrameWnd::rectDefault, NULL,
	  MAKEINTRESOURCE(AFX_IDI_STD_FRAME)/*menu*/))
		return FALSE;

	pMainWnd->m_bAutoMenuEnable = FALSE;    // do manual menu enabling
	pMainWnd->SetupMenus();
	pMainWnd->ShowWindow(m_nCmdShow);
	m_pMainWnd = pMainWnd;      // store in CWinApp member
	return TRUE;
}

void CTestApp::OnAppAbout()
{
	CDialog(_T("ABOUTBOX")).DoModal();
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\ctrltest\godot\bbutton.cpp ===
// bbutton.cpp : bitmap button test
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "ctrltest.h"

/////////////////////////////////////////////////////////////////////////////
// BitmapButton Test dialog #1

// In this example we pass the bitmap resource names to LoadBitmaps
//  OnInitDialog is used to Subclass the buttons so the dialog
//  controls get attached to the MFC WndProc for C++ message map dispatch.

class CBMTest1Dlg : public CDialog
{
protected:
	CBitmapButton button1, button2;
public:
	//{{AFX_DATA(CBMTest1Dlg)
		enum { IDD = IDM_TEST_BITMAP_BUTTON1 };
	//}}AFX_DATA
	CBMTest1Dlg();

	BOOL OnInitDialog();
	//{{AFX_MSG(CBMTest1Dlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CBMTest1Dlg, CDialog)
	//{{AFX_MSG_MAP(CBMTest1Dlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


CBMTest1Dlg::CBMTest1Dlg()
	: CDialog(CBMTest1Dlg::IDD)
{
	// NOTE: The obsolete MFC V1 CBitmapButton constructor with 3 arguments is
	//  replaced by a call to LoadBitmaps.
	if (!button1.LoadBitmaps(_T("Image1Up"), _T("Image1Down"), _T("Image1Focus")) ||
		!button2.LoadBitmaps(_T("Image2Up"), _T("Image2Down"), _T("Image2Focus")))
	{
		TRACE0("Failed to load bitmaps for buttons\n");
		AfxThrowResourceException();
	}
}

BOOL CBMTest1Dlg::OnInitDialog()
{
	// each dialog control has special bitmaps
	VERIFY(button1.SubclassDlgItem(IDOK, this));
	button1.SizeToContent();
	VERIFY(button2.SubclassDlgItem(IDCANCEL, this));
	button2.SizeToContent();

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// BitmapButton Test dialog #2

// In this example we use the CBitmapButton AutoLoad member function.
//  Autoload uses the text/title of the button as the base resource name.
//  For this trivial example the buttons are called "OK" and "CANCEL",
//  which use the bitmaps "OKU", "OKD", "OKF", "CANCELU", "CANCELD"
//  and "CANCELF" respectively for the up, down and focused images.

#define ID_BUTTON_MIN       IDOK
#define N_BUTTONS   (IDCANCEL - ID_BUTTON_MIN + 1)

class CBMTest2Dlg : public CDialog
{
protected:
	// array of buttons constructed with no attached bitmap images
	CBitmapButton buttons[N_BUTTONS];
public:
	//{{AFX_DATA(CBMTest2Dlg)
		enum { IDD = IDM_TEST_BITMAP_BUTTON2 };
	//}}AFX_DATA
	CBMTest2Dlg()
		: CDialog(CBMTest2Dlg::IDD)
		{ }

	BOOL OnInitDialog();
	//{{AFX_MSG(CBMTest2Dlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CBMTest2Dlg, CDialog)
	//{{AFX_MSG_MAP(CBMTest2Dlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CBMTest2Dlg::OnInitDialog()
{
	// load bitmaps for all the bitmap buttons (does SubclassButton as well)
	for (int i = 0; i < N_BUTTONS; i++)
		VERIFY(buttons[i].AutoLoad(ID_BUTTON_MIN + i, this));
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// BitmapButton Test dialog #3

// This is an extension of test dialog 2 using AutoLoad using the disabled
//   state with the "X" suffix.
// Here we use bitmap buttons to select a number between 1 and 10.
// The "PREV" and "NEXT" buttons change the number.  These buttons are
//  disabled when the number hits the limits.

class CBMTest3Dlg : public CDialog
{
protected:
	// construct
	CBitmapButton okButton;
	CBitmapButton prevButton;
	CBitmapButton nextButton;

public:
	int m_nNumber;
	//{{AFX_DATA(CBMTest3Dlg)
		enum { IDD = IDM_TEST_BITMAP_BUTTON3 };
	//}}AFX_DATA

	CBMTest3Dlg()
		: CDialog(CBMTest3Dlg::IDD)
		{ }

	BOOL OnInitDialog();
	void Update();

	//{{AFX_MSG(CBMTest3Dlg)
	afx_msg void OnNextNumber();
	afx_msg void OnPrevNumber();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

BOOL CBMTest3Dlg::OnInitDialog()
{
	// load bitmaps for all the bitmap buttons (does SubclassButton as well)
	VERIFY(okButton.AutoLoad(IDOK, this));
	VERIFY(prevButton.AutoLoad(ID_PREV, this));
	VERIFY(nextButton.AutoLoad(ID_NEXT, this));
	Update();
	return TRUE;
}

BEGIN_MESSAGE_MAP(CBMTest3Dlg, CDialog)
	//{{AFX_MSG_MAP(CBMTest3Dlg)
	ON_COMMAND(ID_PREV, OnPrevNumber)
	ON_COMMAND(ID_NEXT, OnNextNumber)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CBMTest3Dlg::OnPrevNumber()
{
	m_nNumber--;
	Update();
}

void CBMTest3Dlg::OnNextNumber()
{
	m_nNumber++;
	Update();
}

void CBMTest3Dlg::Update()
{
	SetDlgItemInt(IDC_NUMBEROUT, m_nNumber);
	prevButton.EnableWindow(m_nNumber > 1);
	nextButton.EnableWindow(m_nNumber < 10);
	// move focus to active button
	if (!prevButton.IsWindowEnabled())
		nextButton.SetFocus();
	else if (!nextButton.IsWindowEnabled())
		prevButton.SetFocus();
}

/////////////////////////////////////////////////////////////////////////////
// Test driver routines

void CTestWindow::OnTestBitmapButton1()
{
	CBMTest1Dlg dlg;
	dlg.DoModal();
}

void CTestWindow::OnTestBitmapButton2()
{
	CBMTest2Dlg dlg;
	dlg.DoModal();
}

void CTestWindow::OnTestBitmapButton3()
{
	CBMTest3Dlg dlg;
	dlg.m_nNumber = 5;
	dlg.DoModal();

	CString strYouChose;
	strYouChose.LoadString(IDS_YOU_CHOSE);
	CString strMsg;
	strMsg.Format(strYouChose, dlg.m_nNumber);
	AfxMessageBox(strMsg);
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\ctrltest\godot\ctrltest.h ===
// ctrltest.h : main window class interface
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "resource.h"
#include "res\otherids.h"

/////////////////////////////////////////////////////////////////////////////
// ColorMenu - used for custom menu test
//   included here to show how it should be embedded as a member of the
//   main frame window that uses it.  The implementation is in custmenu.cpp

class CColorMenu : public CMenu
{
public:
// Operations
	void AppendColorMenuItem(UINT nID, COLORREF color);

// Implementation
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMIS);
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDIS);
	CColorMenu();
	virtual ~CColorMenu();
};

/////////////////////////////////////////////////////////////////////////////
// Main Window
//   used as the context for running all the tests

class CTestWindow : public CFrameWnd
{
public:
	// construction helpers
	void SetupMenus();

protected:
	// custom menu tests implementation in custmenu.cpp
	void AttachCustomMenu();
	CColorMenu  m_colorMenu;
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);

// Implementation
	//{{AFX_MSG(CTestWindow)
	afx_msg void OnTestDerivedEdit();           // simple test
	afx_msg void OnTestWndClassEdit();          // simple test
	afx_msg void OnTestSubclassedEdit();        // simple test
	afx_msg void OnTestBitmapButton1();         // custom control
	afx_msg void OnTestBitmapButton2();         // custom control
	afx_msg void OnTestBitmapButton3();         // custom control
	afx_msg void OnTestCustomList();            // custom control
	afx_msg void OnTestSpinEdit();          // custom control
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\ctrltest\godot\custlist.cpp ===
// custlist.cpp : custom listbox
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "ctrltest.h"

/////////////////////////////////////////////////////////////////////////////
// Custom Listbox - containing colors

class CColorListBox : public CListBox
{
public:
// Operations
	void AddColorItem(COLORREF color);

// Implementation
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMIS);
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDIS);
	virtual int CompareItem(LPCOMPAREITEMSTRUCT lpCIS);
};

void CColorListBox::AddColorItem(COLORREF color)
{
	// add a listbox item
	AddString((LPCTSTR) color);
		// Listbox does not have the LBS_HASSTRINGS style, so the
		//  normal listbox string is used to store an RGB color
}

/////////////////////////////////////////////////////////////////////////////

#define COLOR_ITEM_HEIGHT   20

void CColorListBox::MeasureItem(LPMEASUREITEMSTRUCT lpMIS)
{
	// all items are of fixed size
	// must use LBS_OWNERDRAWVARIABLE for this to work
	lpMIS->itemHeight = COLOR_ITEM_HEIGHT;
}

void CColorListBox::DrawItem(LPDRAWITEMSTRUCT lpDIS)
{
	CDC* pDC = CDC::FromHandle(lpDIS->hDC);
	COLORREF cr = (COLORREF)lpDIS->itemData; // RGB in item data

	if (lpDIS->itemAction & ODA_DRAWENTIRE)
	{
		// Paint the color item in the color requested
		CBrush br(cr);
		pDC->FillRect(&lpDIS->rcItem, &br);
	}

	if ((lpDIS->itemState & ODS_SELECTED) &&
		(lpDIS->itemAction & (ODA_SELECT | ODA_DRAWENTIRE)))
	{
		// item has been selected - hilite frame
		COLORREF crHilite = RGB(255-GetRValue(cr),
						255-GetGValue(cr), 255-GetBValue(cr));
		CBrush br(crHilite);
		pDC->FrameRect(&lpDIS->rcItem, &br);
	}

	if (!(lpDIS->itemState & ODS_SELECTED) &&
		(lpDIS->itemAction & ODA_SELECT))
	{
		// Item has been de-selected -- remove frame
		CBrush br(cr);
		pDC->FrameRect(&lpDIS->rcItem, &br);
	}
}

int CColorListBox::CompareItem(LPCOMPAREITEMSTRUCT lpCIS)
{
	COLORREF cr1 = (COLORREF)lpCIS->itemData1;
	COLORREF cr2 = (COLORREF)lpCIS->itemData2;
	if (cr1 == cr2)
		return 0;       // exact match

	// first do an intensity sort, lower intensities go first
	int intensity1 = GetRValue(cr1) + GetGValue(cr1) + GetBValue(cr1);
	int intensity2 = GetRValue(cr2) + GetGValue(cr2) + GetBValue(cr2);
	if (intensity1 < intensity2)
		return -1;      // lower intensity goes first
	else if (intensity1 > intensity2)
		return 1;       // higher intensity goes second

	// if same intensity, sort by color (blues first, reds last)
	if (GetBValue(cr1) > GetBValue(cr2))
		return -1;
	else if (GetGValue(cr1) > GetGValue(cr2))
		return -1;
	else if (GetRValue(cr1) > GetRValue(cr2))
		return -1;
	else
		return 1;
}

/////////////////////////////////////////////////////////////////////////////
// Dialog class

class CCustListDlg : public CDialog
{
protected:
	CColorListBox  m_colors;
public:
	//{{AFX_DATA(CCustListDlg)
		enum { IDD = IDD_CUSTOM_LIST };
	//}}AFX_DATA
	CCustListDlg()
		: CDialog(CCustListDlg::IDD)
		{ }

	// access to controls is through inline helpers
	BOOL OnInitDialog();

	//{{AFX_MSG(CCustListDlg)
		virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP();
};

BEGIN_MESSAGE_MAP(CCustListDlg, CDialog)
	//{{AFX_MSG_MAP(CCustListDlg)
	ON_LBN_DBLCLK(IDC_LISTBOX1, OnOK)       // double click for OK
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CCustListDlg::OnInitDialog()
{
	// subclass the control
	VERIFY(m_colors.SubclassDlgItem(IDC_LISTBOX1, this));

	// add 8 colors to the listbox (primary + secondary color only)
	for (int red = 0; red <= 255; red += 255)
		for (int green = 0; green <= 255; green += 255)
			for (int blue = 0; blue <= 255; blue += 255)
				m_colors.AddColorItem(RGB(red, green, blue));

	return TRUE;
}

void CCustListDlg::OnOK()
{
	// get the final color
	int nIndex = m_colors.GetCurSel();
	if (nIndex == -1)
	{
		CString str;
		str.LoadString(IDS_PLEASE_SELECT_COLOR);
		MessageBox(str);
		m_colors.SetFocus();
		return;
	}
	DWORD color = m_colors.GetItemData(nIndex);

#ifdef _DEBUG
	// normally do something with it...
	TRACE1("final color RGB = 0x%06lX\n", color);
#endif

	EndDialog(IDOK);
}

/////////////////////////////////////////////////////////////////////////////
// Run the test

void CTestWindow::OnTestCustomList()
{
	TRACE0("running dialog with custom listbox (owner draw)\n");
	CCustListDlg dlg;
	dlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\ctrltest\godot\custmenu.cpp ===
// custmenu.cpp : custom menu
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "ctrltest.h"

/////////////////////////////////////////////////////////////////////////////

// for owner draw menus, the CMenu object is embedded in the main frame window
//  the CMenu stays attached to the HMENU while it is running so that
//  owner draw messages are delegated to this class.
//  Since we attach the HMENU to a menu bar (with ModifyMenu below), we
//  don't want to delete the menu twice - so we detach on the destructor.

CColorMenu::CColorMenu()
{
	VERIFY(CreateMenu());
}

CColorMenu::~CColorMenu()
{
	Detach();
	ASSERT(m_hMenu == NULL);    // defaul CMenu::~CMenu will destroy
}

void CColorMenu::AppendColorMenuItem(UINT nID, COLORREF color)
{
	VERIFY(AppendMenu(MF_ENABLED | MF_OWNERDRAW, nID, (LPCTSTR)color));
}

/////////////////////////////////////////////////////////////////////////////

#define COLOR_BOX_WIDTH     20
#define COLOR_BOX_HEIGHT    20


void CColorMenu::MeasureItem(LPMEASUREITEMSTRUCT lpMIS)
{
	// all items are of fixed size
	lpMIS->itemWidth = COLOR_BOX_WIDTH;
	lpMIS->itemHeight = COLOR_BOX_HEIGHT;
}

void CColorMenu::DrawItem(LPDRAWITEMSTRUCT lpDIS)
{
	CDC* pDC = CDC::FromHandle(lpDIS->hDC);
	COLORREF cr = (COLORREF)lpDIS->itemData; // RGB in item data

	if (lpDIS->itemAction & ODA_DRAWENTIRE)
	{
		// Paint the color item in the color requested
		CBrush br(cr);
		pDC->FillRect(&lpDIS->rcItem, &br);
	}

	if ((lpDIS->itemState & ODS_SELECTED) &&
		(lpDIS->itemAction & (ODA_SELECT | ODA_DRAWENTIRE)))
	{
		// item has been selected - hilite frame
		COLORREF crHilite = RGB(255-GetRValue(cr),
						255-GetGValue(cr), 255-GetBValue(cr));
		CBrush br(crHilite);
		pDC->FrameRect(&lpDIS->rcItem, &br);
	}

	if (!(lpDIS->itemState & ODS_SELECTED) &&
		(lpDIS->itemAction & ODA_SELECT))
	{
		// Item has been de-selected -- remove frame
		CBrush br(cr);
		pDC->FrameRect(&lpDIS->rcItem, &br);
	}
}

/////////////////////////////////////////////////////////////////////////////
// custom menu test - menu ids: index of color.

static COLORREF colors[] = {
	0x00000000,     // black
	0x00FF0000,     // blue
	0x0000FF00,     // green
	0x00FFFF00,     // cyan
	0x000000FF,     // red
	0x00FF00FF,     // magenta
	0x0000FFFF,     // yellow
	0x00FFFFFF      // white
};
const int nColors = sizeof(colors)/sizeof(colors[0]);


/////////////////////////////////////////////////////////////////////////////

// Call AttachCustomMenu once
//   it will replace the menu item with the ID  'IDM_TEST_CUSTOM_MENU'
//   with a color menu popup
// Replace the specified menu item with a color popup
void CTestWindow::AttachCustomMenu()
{
	// now add a few new menu items

	for (int iColor = 0; iColor < nColors; iColor++)
		m_colorMenu.AppendColorMenuItem(IDS_COLOR_NAME_FIRST + iColor, colors[iColor]);

	// Replace the specified menu item with a color popup
	//  (note: will only work once)
	CMenu* pMenuBar = GetMenu();
	ASSERT(pMenuBar != NULL);
	TCHAR szString[256];     // don't change the string

	pMenuBar->GetMenuString(IDM_TEST_CUSTOM_MENU, szString, sizeof(szString),
		MF_BYCOMMAND);
	VERIFY(GetMenu()->ModifyMenu(IDM_TEST_CUSTOM_MENU, MF_BYCOMMAND | MF_POPUP,
		(UINT)m_colorMenu.m_hMenu, szString));
}

/////////////////////////////////////////////////////////////////////////////


BOOL CTestWindow::OnCommand(WPARAM wParam, LPARAM lParam)
{
	if (wParam < IDS_COLOR_NAME_FIRST || wParam >= IDS_COLOR_NAME_FIRST + nColors)
		return CFrameWnd::OnCommand(wParam, lParam);        // default

	// special color selected
	CString strYouPicked;
	strYouPicked.LoadString(IDS_YOU_PICKED_COLOR);

	CString strColor;
	strColor.LoadString(wParam);

	CString strMsg;
	strMsg.Format(strYouPicked, (LPCTSTR)strColor);

	CString strMenuTest;
	strMenuTest.LoadString(IDS_MENU_TEST);

	MessageBox(strMsg, strMenuTest);

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\ctrltest\godot\dertest.cpp ===
// deredit.cpp : C++ derived Edit control example
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "ctrltest.h"

#include "paredit.h"

/////////////////////////////////////////////////////////////////////////////

class CDerEditDlg : public CDialog
{
protected:
	CFont*  m_pFont;
	// construct
	CParsedEdit m_edit1, m_edit2, m_edit3, m_edit4;
	CStatic m_static1, m_static2, m_static3, m_static4;
public:
	//{{AFX_DATA(CDerEditDlg)
		enum { IDD = IDD_DERIVED_EDIT };
	//}}AFX_DATA
	CDerEditDlg()
		: CDialog(CDerEditDlg::IDD)
		{ }

	void OnSetFont(CFont* pFont)
			{ m_pFont = pFont; }

	BOOL OnInitDialog();
	//{{AFX_MSG(CDerEditDlg)
		virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CDerEditDlg, CDialog)
	//{{AFX_MSG_MAP(CDerEditDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CDerEditDlg::OnInitDialog()
	// create children on InitDialog
	//  (not in CDerEditDlg constructor since the dialog has
	//    no attached HWND in the constructor)
{
	// This is an example of the _incorrect_ way to create a dialog
	// The following code show you what you should _not_ do:
	//    1) do not use hard coded numbers for coordinates and sizes
	//     (these will break when the font sizes changes and are
	//     hard to edit and maintain).
	//    2) do not put strings in code, they should be in resources.
	//    3) as you can see below the programming steps required
	//     to create controls, pass the correct creation parameters,
	//     and set the appropriate font, is complicated and error prone.
	//    4) localization of the controls would require changes to the
	//     sources for the captions, font, coordinates, and sizes.

	const int yStart = 8;
	const int height = 30;

	CPoint whereLabel(10, yStart);
	CSize sizeLabel(80, 24);

	CPoint whereEdit(90, yStart);
	CSize sizeEdit(140, 24);

	m_static1.Create(_T("Letters:"), WS_VISIBLE | WS_CHILD | SS_LEFT,
		CRect(whereLabel, sizeLabel), this, (UINT)-1);
	m_static1.SetFont(m_pFont);
	whereLabel.y += height;
	m_edit1.Create(WS_VISIBLE | WS_CHILD | WS_TABSTOP | WS_BORDER |
		PES_LETTERS,
		CRect(whereEdit, sizeEdit), this, IDC_EDIT1);
	m_edit1.SetFont(m_pFont);
	whereEdit.y += height;

	m_static2.Create(_T("Numbers:"), WS_VISIBLE | WS_CHILD | SS_LEFT,
		CRect(whereLabel, sizeLabel), this, (UINT)-1);
	m_static2.SetFont(m_pFont);
	whereLabel.y += height;
	m_edit2.Create(WS_VISIBLE | WS_CHILD | WS_TABSTOP | WS_BORDER |
		PES_NUMBERS,
		CRect(whereEdit, sizeEdit), this, IDC_EDIT2);
	m_edit2.SetFont(m_pFont);
	whereEdit.y += height;

	m_static3.Create(_T("Either:"), WS_VISIBLE | WS_CHILD | SS_LEFT,
		CRect(whereLabel, sizeLabel), this, (UINT)-1);
	m_static3.SetFont(m_pFont);
	whereLabel.y += height;
	m_edit3.Create(WS_VISIBLE | WS_CHILD | WS_TABSTOP | WS_BORDER |
		PES_LETTERS | PES_NUMBERS,
		CRect(whereEdit, sizeEdit), this, IDC_EDIT3);
	m_edit3.SetFont(m_pFont);
	whereEdit.y += height;

	m_static4.Create(_T("Anything:"), WS_VISIBLE | WS_CHILD | SS_LEFT,
		CRect(whereLabel, sizeLabel), this, (UINT)-1);
	m_static4.SetFont(m_pFont);
	whereLabel.y += height;
	m_edit4.Create(WS_VISIBLE | WS_CHILD | WS_TABSTOP | WS_BORDER |
		PES_ALL,
		CRect(whereEdit, sizeEdit), this, IDC_EDIT4);
	m_edit4.SetFont(m_pFont);
	whereEdit.y += height;

	// change the dialog height so everything fits
	int yBottom = whereEdit.y + height * 2; // extra space
	CRect rect;
	GetWindowRect(rect);
	VERIFY(SetWindowPos(NULL, -1, -1, rect.Width(), yBottom,
		SWP_NOMOVE|SWP_NOZORDER|SWP_NOREDRAW|SWP_NOACTIVATE));

	// set focus to first one
	m_edit1.SetFocus();
	return FALSE;   // focus set
}

void CDerEditDlg::OnOK()
{
#ifdef _DEBUG
	// dump results, normally you would do something with these
	CString s;
	m_edit1.GetWindowText(s);
	TRACE(_T("edit1 = '%s'\n"), s);
	m_edit2.GetWindowText(s);
	TRACE(_T("edit2 = '%s'\n"), s);
	m_edit3.GetWindowText(s);
	TRACE(_T("edit3 = '%s'\n"), s);
	m_edit4.GetWindowText(s);
	TRACE(_T("edit4 = '%s'\n"), s);
#endif

	EndDialog(IDOK);
}

/////////////////////////////////////////////////////////////////////////////
// Run the test

void CTestWindow::OnTestDerivedEdit()
{
	TRACE(_T("running dialog with special derived CParsedEdit controls in it\n"));
	CDerEditDlg dlg;
	dlg.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\ctrltest\godot\paredit.cpp ===
// paredit.cpp: C++ derived edit control for numbers/letters etc
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "ctrltest.h"

#include "paredit.h"

/////////////////////////////////////////////////////////////////////////////
// ParsedEdit

CParsedEdit::CParsedEdit()
{
	m_wParseStyle = 0;
}

BEGIN_MESSAGE_MAP(CParsedEdit, CEdit)
	//{{AFX_MSG_MAP(CParsedEdit)
	ON_WM_CHAR()
	ON_WM_VSCROLL()     // for associated spin controls
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// Creating from C++ code

BOOL CParsedEdit::Create(DWORD dwStyle, const RECT& rect,
		CWnd* pParentWnd, UINT nID)
{
	m_wParseStyle = LOWORD(dwStyle);
	// figure out edit control style
	DWORD dwEditStyle = MAKELONG(ES_LEFT, HIWORD(dwStyle));
	return CWnd::Create(_T("EDIT"), NULL, dwEditStyle, rect, pParentWnd, nID);
}

/////////////////////////////////////////////////////////////////////////////
// Aliasing on top of an existing Edit control

BOOL CParsedEdit::SubclassEdit(UINT nID, CWnd* pParent, WORD wParseStyle)
{
	m_wParseStyle = wParseStyle;
	return SubclassDlgItem(nID, pParent);
}

/////////////////////////////////////////////////////////////////////////////
// Input character filter

void CParsedEdit::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	WORD type;

	if (nChar < 0x20)
		type = PES_ALL;                         // always allow control chars
	else if (IsCharAlphaNumeric((TCHAR)nChar) && !IsCharAlpha((TCHAR)nChar))
		type = PES_NUMBERS;
	else if (IsCharAlpha((TCHAR)nChar))
		type = PES_LETTERS;
	else
		type = PES_OTHERCHARS;

	if (m_wParseStyle & type)
	{
		CEdit::OnChar(nChar, nRepCnt, nFlags);  // permitted
	}
	else
	{
		// illegal character - inform parent
		OnBadInput();
	}
}

/////////////////////////////////////////////////////////////////////////////
// Spin controls will send scroll messages

void CParsedEdit::OnVScroll(UINT nSBCode, UINT, CScrollBar*)
{
	int nDelta = 0;
	if (nSBCode == SB_LINEDOWN)
		nDelta = -1;
	else if (nSBCode == SB_LINEUP)
		nDelta = +1;
	else
		return; // nothing special

	// set the focus to this edit item and select it all
	SetFocus();

	//Get the number in the control.
	BOOL bOk;
	int nOld = GetParent()->GetDlgItemInt(GetDlgCtrlID(), &bOk);
	if (bOk)
	{
		// The MuScrl32 control also supports range checking
		// for this example, we just prevent overflow
		int nNew = nOld + nDelta;
		if (nNew >= 0 && nNew <= 32767)
			GetParent()->SetDlgItemInt(GetDlgCtrlID(), nNew);
		else
			bOk = FALSE;
	}

	if (!bOk)
		OnBadInput();
	SetSel(0, -1);
}

/////////////////////////////////////////////////////////////////////////////
// default bad input handler, beep (unless parent notification
//    returns -1.  Most parent dialogs will return 0 or 1 for command
//    handlers (i.e. Beep is the default)

void CParsedEdit::OnBadInput()
{
	if (GetParent()->SendMessage(WM_COMMAND,
		MAKELONG(GetDlgCtrlID(), PEN_ILLEGALCHAR), (LPARAM)m_hWnd) != -1)
	{
		MessageBeep((UINT)-1);
	}
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\ctrltest\godot\paredit2.cpp ===
// paredit2.cpp : code needed to export CParsedEdit as a WndClass
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "ctrltest.h"

#include "paredit.h"
#include <ctl3d.h>

/////////////////////////////////////////////////////////////////////////////
// The C++ class CParsedEdit can be made visible to the dialog manager
//   by registering a window class for it
// The C++ class 'CParsedEditExported' is used to implement the
//   creation and destruction of a C++ object as if it were just
//   a normal Windows control.
// In order to hook in the class creation we must provide a special
//   WndProc to create the C++ object and override the PostNcDestroy
//   message to destroy it

class CParsedEditExported : public CParsedEdit      // WNDCLASS exported class
{
public:
	CParsedEditExported() { };
	BOOL RegisterControlClass();

// Implementation: (all is implementation since the public interface of
//    this class is identical to CParsedEdit)
protected:
	virtual void PostNcDestroy();
	static LRESULT CALLBACK EXPORT WndProcHook(HWND, UINT, WPARAM, LPARAM);
	static WNDPROC lpfnSuperEdit;

	friend class CParsedEdit;       // for RegisterControlClass

	//{{AFX_MSG(CParsedEditExported)
	afx_msg int OnNcCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP();
};

/////////////////////////////////////////////////////////////////////////////
// Special create hooks

LRESULT CALLBACK EXPORT
CParsedEditExported::WndProcHook(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	// create new item and attach it
	CParsedEditExported* pEdit = new CParsedEditExported();
	pEdit->Attach(hWnd);

	// set up wndproc to AFX one, and call it
	pEdit->m_pfnSuper = CParsedEditExported::lpfnSuperEdit;
	::SetWindowLong(hWnd, GWL_WNDPROC, (DWORD)AfxWndProc);

	// Since this window is really an edit control but does not
	//  have "edit" as its class name, to make it work correctly
	//  with CTL3D, we have to tell CTL3D that is "really is" an
	//  edit control.  This uses a relatively new API in CTL3D
	//  called Ctl3dSubclassCtlEx.
	pEdit->SubclassCtl3d(CTL3D_EDIT_CTL);

	// then call it for this first message
#ifdef STRICT
	return ::CallWindowProc(AfxWndProc, hWnd, msg, wParam, lParam);
#else
	return ::CallWindowProc((FARPROC)AfxWndProc, hWnd, msg, wParam, lParam);
#endif
}

BEGIN_MESSAGE_MAP(CParsedEditExported, CParsedEdit)
	//{{AFX_MSG_MAP(CParsedEditExported)
	ON_WM_NCCREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

int CParsedEditExported::OnNcCreate(LPCREATESTRUCT lpCreateStruct)
{
	// special create hook
	// example of stripping the sub-style bits from the style specified
	//   in the dialog template to use for some other reason
	m_wParseStyle = LOWORD(lpCreateStruct->style);
	DWORD dwEditStyle = MAKELONG(ES_LEFT, HIWORD(lpCreateStruct->style));

	::SetWindowLong(m_hWnd, GWL_STYLE, dwEditStyle);
	lpCreateStruct->style = dwEditStyle;
	return CParsedEdit::OnNcCreate(lpCreateStruct);
}

void CParsedEditExported::PostNcDestroy()
{
	// needed to clean up the C++ CWnd object
	delete this;
}

/////////////////////////////////////////////////////////////////////////////
// Routine to register the class

WNDPROC CParsedEditExported::lpfnSuperEdit = NULL;

BOOL CParsedEdit::RegisterControlClass()
{
	WNDCLASS wcls;

	// check to see if class already registered
	static const TCHAR szClass[] = _T("paredit");
	if (::GetClassInfo(AfxGetInstanceHandle(), szClass, &wcls))
	{
		// name already registered - ok if it was us
		return (wcls.lpfnWndProc == (WNDPROC)CParsedEditExported::WndProcHook);
	}

	// Use standard "edit" control as a template.
	VERIFY(::GetClassInfo(NULL, _T("edit"), &wcls));
	CParsedEditExported::lpfnSuperEdit = wcls.lpfnWndProc;

	// set new values
	wcls.lpfnWndProc = CParsedEditExported::WndProcHook;
	wcls.hInstance = AfxGetInstanceHandle();
	wcls.lpszClassName = szClass;
	return (RegisterClass(&wcls) != 0);
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\ctrltest\godot\spintest.cpp ===
// spintest.cpp : New control example - Uses MicroScroll32
//                custom control DLL from MuScrl32 sample
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "ctrltest.h"

#include "paredit.h"

/////////////////////////////////////////////////////////////////////////////
// Example of a dialog with special controls in it

#define NUM_EDIT        4
#define IDC_EDIT_MIN    IDC_EDIT1
#define IDC_BUTTON_MAX  IDC_BUTTON4
	// IDC_EDIT1->IDC_EDIT4 and IDC_BUTTON1->IDC_BUTTON4 must be contiguous

class CSpinEditDlg : public CDialog
{
protected:
	CParsedEdit edit[NUM_EDIT];
public:
	//{{AFX_DATA(CSpinEditDlg)
		enum { IDD = IDD_SPIN_EDIT };
	//}}AFX_DATA
	CSpinEditDlg()
		: CDialog(CSpinEditDlg::IDD)
			{ }

	BOOL OnInitDialog();
	//{{AFX_MSG(CSpinEditDlg)
		virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CSpinEditDlg, CDialog)
	//{{AFX_MSG_MAP(CSpinEditDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CSpinEditDlg::OnInitDialog()
{
	int value = 1;
	for (int i = 0; i < NUM_EDIT; i++)
	{
		// associate button with edit item
		CSpinButtonCtrl* pSpin = (CSpinButtonCtrl*)GetDlgItem(IDC_BUTTON_MAX - i);
		ASSERT(pSpin != NULL);
			pSpin->SetPos(value++);     // 1, 2, 3, 4
	}
	return TRUE;
}

void CSpinEditDlg::OnOK()
{
	int values[NUM_EDIT];
	UINT nID = 0;
	BOOL bOk = TRUE;
	for (int i = 0; bOk && i < NUM_EDIT; i++)
	{
		nID = IDC_EDIT_MIN + i;
		values[i] = GetDlgItemInt(nID, &bOk);
	}

	if (!bOk)
	{
		// report illegal value
		CString str;
		str.LoadString(IDS_ILLEGAL_VALUE);
		MessageBox(str);
		CEdit& badEdit = *(CEdit*)GetDlgItem(nID);
		badEdit.SetSel(0, -1);
		badEdit.SetFocus();
		return;     // don't end dialog
	}

#ifdef _DEBUG
	// dump results, normally you would do something with these
	TRACE0("Final values:\n");
	for (i = 0; i < NUM_EDIT; i++)
		TRACE1("\t%d\n", values[i]);
#endif
	EndDialog(IDOK);
}

/////////////////////////////////////////////////////////////////////////////
// Run the test

void CTestWindow::OnTestSpinEdit()
{
	TRACE0("running dialog with spin controls in it\n");
	CSpinEditDlg dlg;
	dlg.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\ctrltest\godot\stdafx.cpp ===
// stdafx.cpp : pre-compiled header and types file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\ctrltest\godot\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ctrltest.rc
//
#define IDS_YOU_CHOSE                   1
#define IDS_PLEASE_SELECT_COLOR         2
#define IDM_TEST_BITMAP_BUTTON1         400
#define IDM_TEST_BITMAP_BUTTON2         401
#define IDM_TEST_BITMAP_BUTTON3         402
#define IDM_TEST_CUSTOM_LIST            403
#define IDM_TEST_CUSTOM_MENU            405
#define IDM_TEST_DERIVED_EDIT           406
#define IDM_TEST_PENEDIT_CODE           407
#define IDM_TEST_PENEDIT_FEATURES       408
#define IDM_TEST_PENEDIT_TEMPLATE       409
#define IDM_TEST_SPIN_EDIT              410
#define IDM_TEST_SUB_EDIT               411
#define IDM_TEST_WNDCLASS_EDIT          412
#define IDD_CUSTOM_LIST                 500
#define IDD_DERIVED_EDIT                501
#define IDD_SUB_EDIT                    505
#define IDD_SUB_PENEDIT                 506
#define IDC_NUMBEROUT                   1000
#define IDS_COLOR_NAME_FIRST            2000
#define IDS_COLOR_NAME_BLUE             2001
#define IDS_COLOR_NAME_GREEN            2002
#define IDS_COLOR_NAME_CYAN             2003
#define IDS_COLOR_NAME_RED              2004
#define IDS_COLOR_NAME_MAGENTA          2005
#define IDS_COLOR_NAME_YELLOW           2006
#define IDS_COLOR_NAME_WHITE            2007
#define IDS_YOU_PICKED_COLOR            2008
#define IDS_MENU_TEST                   2009
#define IDS_ILLEGAL_VALUE               2010
#define IDS_MUSCRL32_DLL_REQUIRED       2011
#define IDS_WNDCLASS_NOT_REGISTERED     2012
#define IDC_EDIT1                       2101
#define IDC_EDIT2                       2102
#define IDC_EDIT3                       2103
#define IDC_EDIT4                       2104
#define IDC_LISTBOX1                    2301
#define ID_PREV                         0x8000
#define ID_NEXT                         0x8001

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         57667
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\ctrltest\old\bbutton.cpp ===
// bbutton.cpp : bitmap button test
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "ctrltest.h"

/////////////////////////////////////////////////////////////////////////////
// BitmapButton Test dialog #1

// In this example we pass the bitmap resource names to LoadBitmaps
//  OnInitDialog is used to Subclass the buttons so the dialog
//  controls get attached to the MFC WndProc for C++ message map dispatch.

class CBMTest1Dlg : public CDialog
{
protected:
	CBitmapButton button1, button2;
public:
	//{{AFX_DATA(CBMTest1Dlg)
		enum { IDD = IDM_TEST_BITMAP_BUTTON1 };
	//}}AFX_DATA
	CBMTest1Dlg();

	BOOL OnInitDialog();
	//{{AFX_MSG(CBMTest1Dlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CBMTest1Dlg, CDialog)
	//{{AFX_MSG_MAP(CBMTest1Dlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


CBMTest1Dlg::CBMTest1Dlg()
	: CDialog(CBMTest1Dlg::IDD)
{
	// NOTE: The obsolete MFC V1 CBitmapButton constructor with 3 arguments is
	//  replaced by a call to LoadBitmaps.
	if (!button1.LoadBitmaps(_T("Image1Up"), _T("Image1Down"), _T("Image1Focus")) ||
		!button2.LoadBitmaps(_T("Image2Up"), _T("Image2Down"), _T("Image2Focus")))
	{
		TRACE0("Failed to load bitmaps for buttons\n");
		AfxThrowResourceException();
	}
}

BOOL CBMTest1Dlg::OnInitDialog()
{
	// each dialog control has special bitmaps
	VERIFY(button1.SubclassDlgItem(IDOK, this));
	button1.SizeToContent();
	VERIFY(button2.SubclassDlgItem(IDCANCEL, this));
	button2.SizeToContent();

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// BitmapButton Test dialog #2

// In this example we use the CBitmapButton AutoLoad member function.
//  Autoload uses the text/title of the button as the base resource name.
//  For this trivial example the buttons are called "OK" and "CANCEL",
//  which use the bitmaps "OKU", "OKD", "OKF", "CANCELU", "CANCELD"
//  and "CANCELF" respectively for the up, down and focused images.

#define ID_BUTTON_MIN       IDOK
#define N_BUTTONS   (IDCANCEL - ID_BUTTON_MIN + 1)

class CBMTest2Dlg : public CDialog
{
protected:
	// array of buttons constructed with no attached bitmap images
	CBitmapButton buttons[N_BUTTONS];
public:
	//{{AFX_DATA(CBMTest2Dlg)
		enum { IDD = IDM_TEST_BITMAP_BUTTON2 };
	//}}AFX_DATA
	CBMTest2Dlg()
		: CDialog(CBMTest2Dlg::IDD)
		{ }

	BOOL OnInitDialog();
	//{{AFX_MSG(CBMTest2Dlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CBMTest2Dlg, CDialog)
	//{{AFX_MSG_MAP(CBMTest2Dlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CBMTest2Dlg::OnInitDialog()
{
	// load bitmaps for all the bitmap buttons (does SubclassButton as well)
	for (int i = 0; i < N_BUTTONS; i++)
		VERIFY(buttons[i].AutoLoad(ID_BUTTON_MIN + i, this));
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// BitmapButton Test dialog #3

// This is an extension of test dialog 2 using AutoLoad using the disabled
//   state with the "X" suffix.
// Here we use bitmap buttons to select a number between 1 and 10.
// The "PREV" and "NEXT" buttons change the number.  These buttons are
//  disabled when the number hits the limits.

class CBMTest3Dlg : public CDialog
{
protected:
	// construct
	CBitmapButton okButton;
	CBitmapButton prevButton;
	CBitmapButton nextButton;

public:
	int m_nNumber;
	//{{AFX_DATA(CBMTest3Dlg)
		enum { IDD = IDM_TEST_BITMAP_BUTTON3 };
	//}}AFX_DATA

	CBMTest3Dlg()
		: CDialog(CBMTest3Dlg::IDD)
		{ }

	BOOL OnInitDialog();
	void Update();

	//{{AFX_MSG(CBMTest3Dlg)
	afx_msg void OnNextNumber();
	afx_msg void OnPrevNumber();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

BOOL CBMTest3Dlg::OnInitDialog()
{
	// load bitmaps for all the bitmap buttons (does SubclassButton as well)
	VERIFY(okButton.AutoLoad(IDOK, this));
	VERIFY(prevButton.AutoLoad(ID_PREV, this));
	VERIFY(nextButton.AutoLoad(ID_NEXT, this));
	Update();
	return TRUE;
}

BEGIN_MESSAGE_MAP(CBMTest3Dlg, CDialog)
	//{{AFX_MSG_MAP(CBMTest3Dlg)
	ON_COMMAND(ID_PREV, OnPrevNumber)
	ON_COMMAND(ID_NEXT, OnNextNumber)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CBMTest3Dlg::OnPrevNumber()
{
	m_nNumber--;
	Update();
}

void CBMTest3Dlg::OnNextNumber()
{
	m_nNumber++;
	Update();
}

void CBMTest3Dlg::Update()
{
	SetDlgItemInt(IDC_NUMBEROUT, m_nNumber);
	prevButton.EnableWindow(m_nNumber > 1);
	nextButton.EnableWindow(m_nNumber < 10);
	// move focus to active button
	if (!prevButton.IsWindowEnabled())
		nextButton.SetFocus();
	else if (!nextButton.IsWindowEnabled())
		prevButton.SetFocus();
}

/////////////////////////////////////////////////////////////////////////////
// Test driver routines

void CTestWindow::OnTestBitmapButton1()
{
	CBMTest1Dlg dlg;
	dlg.DoModal();
}

void CTestWindow::OnTestBitmapButton2()
{
	CBMTest2Dlg dlg;
	dlg.DoModal();
}

void CTestWindow::OnTestBitmapButton3()
{
	CBMTest3Dlg dlg;
	dlg.m_nNumber = 5;
	dlg.DoModal();

	CString strYouChose;
	strYouChose.LoadString(IDS_YOU_CHOSE);
	CString strMsg;
	strMsg.Format(strYouChose, dlg.m_nNumber);
	AfxMessageBox(strMsg);
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\ctrltest\old\ctrltest.cpp ===
// ctrltest.cpp : Dialogs and Controls test applet
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "ctrltest.h"

/////////////////////////////////////////////////////////////////////////////
// Main Window

// The OnTest routines are in the source files containing the particular
// dialog that they are working with.  For example OnTestDerivedEdit is
// in file dertest.cpp

BEGIN_MESSAGE_MAP(CTestWindow, CFrameWnd)
	//{{AFX_MSG_MAP(CTestWindow)
	ON_COMMAND(IDM_TEST_DERIVED_EDIT, OnTestDerivedEdit)
	ON_COMMAND(IDM_TEST_WNDCLASS_EDIT, OnTestWndClassEdit)
	ON_COMMAND(IDM_TEST_SUB_EDIT, OnTestSubclassedEdit)
	ON_COMMAND(IDM_TEST_BITMAP_BUTTON1, OnTestBitmapButton1)
	ON_COMMAND(IDM_TEST_BITMAP_BUTTON2, OnTestBitmapButton2)
	ON_COMMAND(IDM_TEST_BITMAP_BUTTON3, OnTestBitmapButton3)
	ON_COMMAND(IDM_TEST_CUSTOM_LIST, OnTestCustomList)
	ON_COMMAND(IDM_TEST_SPIN_EDIT, OnTestSpinEdit)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CTestWindow::SetupMenus()
{
	if ((GetSystemMetrics(SM_PENWINDOWS)) == NULL)
	{
		CMenu* pMenu = GetMenu();
		ASSERT(pMenu != NULL);
		pMenu->EnableMenuItem(IDM_TEST_PENEDIT_CODE, MF_DISABLED|MF_GRAYED);
		pMenu->EnableMenuItem(IDM_TEST_PENEDIT_TEMPLATE, MF_DISABLED|MF_GRAYED);
		pMenu->EnableMenuItem(IDM_TEST_PENEDIT_FEATURES, MF_DISABLED|MF_GRAYED);
	}
	// do not test for spin control until the user tries it
	// if the custom control DLL is not present, the test spin
	//  control menu item will be disabled in 'OnTestSpinEdit'.

	// custom menu tests
	AttachCustomMenu();
}

/////////////////////////////////////////////////////////////////////////////
// Application class

class CTestApp : public CWinApp
{
public:
	CTestApp();

	virtual BOOL InitInstance();
	//{{AFX_MSG(CTestApp)
	afx_msg void OnAppAbout();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP();
};

CTestApp::CTestApp()
{
	// Place all significant initialization in InitInstance
}


BEGIN_MESSAGE_MAP(CTestApp, CWinApp)
	//{{AFX_MSG_MAP(CTestApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CTestApp NEAR theTestApp;

BOOL CTestApp::InitInstance()
{
	//SetDialogBkColor();   // Gray dialog backgrounds
	Enable3dControls();

	CTestWindow* pMainWnd = new CTestWindow;
	if (!pMainWnd->Create(NULL, _T("Control Test App"),
	  WS_OVERLAPPEDWINDOW, CFrameWnd::rectDefault, NULL,
	  MAKEINTRESOURCE(AFX_IDI_STD_FRAME)/*menu*/))
		return FALSE;

	pMainWnd->m_bAutoMenuEnable = FALSE;    // do manual menu enabling
	pMainWnd->SetupMenus();
	pMainWnd->ShowWindow(m_nCmdShow);
	m_pMainWnd = pMainWnd;      // store in CWinApp member
	return TRUE;
}

void CTestApp::OnAppAbout()
{
	CDialog(_T("ABOUTBOX")).DoModal();
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\ctrltest\old\ctrltest.h ===
// ctrltest.h : main window class interface
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "resource.h"
#include "res\otherids.h"

/////////////////////////////////////////////////////////////////////////////
// ColorMenu - used for custom menu test
//   included here to show how it should be embedded as a member of the
//   main frame window that uses it.  The implementation is in custmenu.cpp

class CColorMenu : public CMenu
{
public:
// Operations
	void AppendColorMenuItem(UINT nID, COLORREF color);

// Implementation
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMIS);
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDIS);
	CColorMenu();
	virtual ~CColorMenu();
};

/////////////////////////////////////////////////////////////////////////////
// Main Window
//   used as the context for running all the tests

class CTestWindow : public CFrameWnd
{
public:
	// construction helpers
	void SetupMenus();

protected:
	// custom menu tests implementation in custmenu.cpp
	void AttachCustomMenu();
	CColorMenu  m_colorMenu;
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);

// Implementation
	//{{AFX_MSG(CTestWindow)
	afx_msg void OnTestDerivedEdit();           // simple test
	afx_msg void OnTestWndClassEdit();          // simple test
	afx_msg void OnTestSubclassedEdit();        // simple test
	afx_msg void OnTestBitmapButton1();         // custom control
	afx_msg void OnTestBitmapButton2();         // custom control
	afx_msg void OnTestBitmapButton3();         // custom control
	afx_msg void OnTestCustomList();            // custom control
	afx_msg void OnTestSpinEdit();          // custom control
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\ctrltest\godot\paredit.h ===
// paredit.h: C++ derived edit control for numbers/letters etc
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


/////////////////////////////////////////////////////////////////////////////
// CParsedEdit is a specialized CEdit control that only allows characters
//  of a given type.
// This class is used in 3 different ways in the samples

class CParsedEdit : public CEdit
{
protected:
	WORD    m_wParseStyle;      // C++ member data
public:
// Construction
	CParsedEdit();

	// explicit construction (see DERTEST.CPP)
	BOOL Create(DWORD dwStyle /* includes PES_ style*/, const RECT& rect,
		CWnd* pParentWnd, UINT nID);

	// subclassed construction (see SUBTEST.CPP)
	BOOL SubclassEdit(UINT nID, CWnd* pParent, WORD wParseStyle);

	// for WNDCLASS Registered window
	static BOOL RegisterControlClass();

// Overridables
	virtual void OnBadInput();

// Implementation
protected:
	//{{AFX_MSG(CParsedEdit)
	afx_msg void OnChar(UINT, UINT, UINT); // for character validation
	afx_msg void OnVScroll(UINT, UINT, CScrollBar*); // for spin buttons
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////
// Parsed edit control sub-styles

#define PES_NUMBERS         0x0001
#define PES_LETTERS         0x0002
#define PES_OTHERCHARS      0x0004
#define PES_ALL             0xFFFF

/////////////////////////////////////////////////////////////////////////////
// Extra control notifications

// above the range for normal EN_ messages
#define PEN_ILLEGALCHAR     0x8000
			// sent to parent when illegal character hit
			// return 0 if you want parsed edit to beep

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\ctrltest\old\custlist.cpp ===
// custlist.cpp : custom listbox
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "ctrltest.h"

/////////////////////////////////////////////////////////////////////////////
// Custom Listbox - containing colors

class CColorListBox : public CListBox
{
public:
// Operations
	void AddColorItem(COLORREF color);

// Implementation
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMIS);
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDIS);
	virtual int CompareItem(LPCOMPAREITEMSTRUCT lpCIS);
};

void CColorListBox::AddColorItem(COLORREF color)
{
	// add a listbox item
	AddString((LPCTSTR) color);
		// Listbox does not have the LBS_HASSTRINGS style, so the
		//  normal listbox string is used to store an RGB color
}

/////////////////////////////////////////////////////////////////////////////

#define COLOR_ITEM_HEIGHT   20

void CColorListBox::MeasureItem(LPMEASUREITEMSTRUCT lpMIS)
{
	// all items are of fixed size
	// must use LBS_OWNERDRAWVARIABLE for this to work
	lpMIS->itemHeight = COLOR_ITEM_HEIGHT;
}

void CColorListBox::DrawItem(LPDRAWITEMSTRUCT lpDIS)
{
	CDC* pDC = CDC::FromHandle(lpDIS->hDC);
	COLORREF cr = (COLORREF)lpDIS->itemData; // RGB in item data

	if (lpDIS->itemAction & ODA_DRAWENTIRE)
	{
		// Paint the color item in the color requested
		CBrush br(cr);
		pDC->FillRect(&lpDIS->rcItem, &br);
	}

	if ((lpDIS->itemState & ODS_SELECTED) &&
		(lpDIS->itemAction & (ODA_SELECT | ODA_DRAWENTIRE)))
	{
		// item has been selected - hilite frame
		COLORREF crHilite = RGB(255-GetRValue(cr),
						255-GetGValue(cr), 255-GetBValue(cr));
		CBrush br(crHilite);
		pDC->FrameRect(&lpDIS->rcItem, &br);
	}

	if (!(lpDIS->itemState & ODS_SELECTED) &&
		(lpDIS->itemAction & ODA_SELECT))
	{
		// Item has been de-selected -- remove frame
		CBrush br(cr);
		pDC->FrameRect(&lpDIS->rcItem, &br);
	}
}

int CColorListBox::CompareItem(LPCOMPAREITEMSTRUCT lpCIS)
{
	COLORREF cr1 = (COLORREF)lpCIS->itemData1;
	COLORREF cr2 = (COLORREF)lpCIS->itemData2;
	if (cr1 == cr2)
		return 0;       // exact match

	// first do an intensity sort, lower intensities go first
	int intensity1 = GetRValue(cr1) + GetGValue(cr1) + GetBValue(cr1);
	int intensity2 = GetRValue(cr2) + GetGValue(cr2) + GetBValue(cr2);
	if (intensity1 < intensity2)
		return -1;      // lower intensity goes first
	else if (intensity1 > intensity2)
		return 1;       // higher intensity goes second

	// if same intensity, sort by color (blues first, reds last)
	if (GetBValue(cr1) > GetBValue(cr2))
		return -1;
	else if (GetGValue(cr1) > GetGValue(cr2))
		return -1;
	else if (GetRValue(cr1) > GetRValue(cr2))
		return -1;
	else
		return 1;
}

/////////////////////////////////////////////////////////////////////////////
// Dialog class

class CCustListDlg : public CDialog
{
protected:
	CColorListBox  m_colors;
public:
	//{{AFX_DATA(CCustListDlg)
		enum { IDD = IDD_CUSTOM_LIST };
	//}}AFX_DATA
	CCustListDlg()
		: CDialog(CCustListDlg::IDD)
		{ }

	// access to controls is through inline helpers
	BOOL OnInitDialog();

	//{{AFX_MSG(CCustListDlg)
		virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP();
};

BEGIN_MESSAGE_MAP(CCustListDlg, CDialog)
	//{{AFX_MSG_MAP(CCustListDlg)
	ON_LBN_DBLCLK(IDC_LISTBOX1, OnOK)       // double click for OK
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CCustListDlg::OnInitDialog()
{
	// subclass the control
	VERIFY(m_colors.SubclassDlgItem(IDC_LISTBOX1, this));

	// add 8 colors to the listbox (primary + secondary color only)
	for (int red = 0; red <= 255; red += 255)
		for (int green = 0; green <= 255; green += 255)
			for (int blue = 0; blue <= 255; blue += 255)
				m_colors.AddColorItem(RGB(red, green, blue));

	return TRUE;
}

void CCustListDlg::OnOK()
{
	// get the final color
	int nIndex = m_colors.GetCurSel();
	if (nIndex == -1)
	{
		CString str;
		str.LoadString(IDS_PLEASE_SELECT_COLOR);
		MessageBox(str);
		m_colors.SetFocus();
		return;
	}
	DWORD color = m_colors.GetItemData(nIndex);

#ifdef _DEBUG
	// normally do something with it...
	TRACE1("final color RGB = 0x%06lX\n", color);
#endif

	EndDialog(IDOK);
}

/////////////////////////////////////////////////////////////////////////////
// Run the test

void CTestWindow::OnTestCustomList()
{
	TRACE0("running dialog with custom listbox (owner draw)\n");
	CCustListDlg dlg;
	dlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\ctrltest\old\custmenu.cpp ===
// custmenu.cpp : custom menu
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "ctrltest.h"

/////////////////////////////////////////////////////////////////////////////

// for owner draw menus, the CMenu object is embedded in the main frame window
//  the CMenu stays attached to the HMENU while it is running so that
//  owner draw messages are delegated to this class.
//  Since we attach the HMENU to a menu bar (with ModifyMenu below), we
//  don't want to delete the menu twice - so we detach on the destructor.

CColorMenu::CColorMenu()
{
	VERIFY(CreateMenu());
}

CColorMenu::~CColorMenu()
{
	Detach();
	ASSERT(m_hMenu == NULL);    // defaul CMenu::~CMenu will destroy
}

void CColorMenu::AppendColorMenuItem(UINT nID, COLORREF color)
{
	VERIFY(AppendMenu(MF_ENABLED | MF_OWNERDRAW, nID, (LPCTSTR)color));
}

/////////////////////////////////////////////////////////////////////////////

#define COLOR_BOX_WIDTH     20
#define COLOR_BOX_HEIGHT    20


void CColorMenu::MeasureItem(LPMEASUREITEMSTRUCT lpMIS)
{
	// all items are of fixed size
	lpMIS->itemWidth = COLOR_BOX_WIDTH;
	lpMIS->itemHeight = COLOR_BOX_HEIGHT;
}

void CColorMenu::DrawItem(LPDRAWITEMSTRUCT lpDIS)
{
	CDC* pDC = CDC::FromHandle(lpDIS->hDC);
	COLORREF cr = (COLORREF)lpDIS->itemData; // RGB in item data

	if (lpDIS->itemAction & ODA_DRAWENTIRE)
	{
		// Paint the color item in the color requested
		CBrush br(cr);
		pDC->FillRect(&lpDIS->rcItem, &br);
	}

	if ((lpDIS->itemState & ODS_SELECTED) &&
		(lpDIS->itemAction & (ODA_SELECT | ODA_DRAWENTIRE)))
	{
		// item has been selected - hilite frame
		COLORREF crHilite = RGB(255-GetRValue(cr),
						255-GetGValue(cr), 255-GetBValue(cr));
		CBrush br(crHilite);
		pDC->FrameRect(&lpDIS->rcItem, &br);
	}

	if (!(lpDIS->itemState & ODS_SELECTED) &&
		(lpDIS->itemAction & ODA_SELECT))
	{
		// Item has been de-selected -- remove frame
		CBrush br(cr);
		pDC->FrameRect(&lpDIS->rcItem, &br);
	}
}

/////////////////////////////////////////////////////////////////////////////
// custom menu test - menu ids: index of color.

static COLORREF colors[] = {
	0x00000000,     // black
	0x00FF0000,     // blue
	0x0000FF00,     // green
	0x00FFFF00,     // cyan
	0x000000FF,     // red
	0x00FF00FF,     // magenta
	0x0000FFFF,     // yellow
	0x00FFFFFF      // white
};
const int nColors = sizeof(colors)/sizeof(colors[0]);


/////////////////////////////////////////////////////////////////////////////

// Call AttachCustomMenu once
//   it will replace the menu item with the ID  'IDM_TEST_CUSTOM_MENU'
//   with a color menu popup
// Replace the specified menu item with a color popup
void CTestWindow::AttachCustomMenu()
{
	// now add a few new menu items

	for (int iColor = 0; iColor < nColors; iColor++)
		m_colorMenu.AppendColorMenuItem(IDS_COLOR_NAME_FIRST + iColor, colors[iColor]);

	// Replace the specified menu item with a color popup
	//  (note: will only work once)
	CMenu* pMenuBar = GetMenu();
	ASSERT(pMenuBar != NULL);
	TCHAR szString[256];     // don't change the string

	pMenuBar->GetMenuString(IDM_TEST_CUSTOM_MENU, szString, sizeof(szString),
		MF_BYCOMMAND);
	VERIFY(GetMenu()->ModifyMenu(IDM_TEST_CUSTOM_MENU, MF_BYCOMMAND | MF_POPUP,
		(UINT)m_colorMenu.m_hMenu, szString));
}

/////////////////////////////////////////////////////////////////////////////


BOOL CTestWindow::OnCommand(WPARAM wParam, LPARAM lParam)
{
	if (wParam < IDS_COLOR_NAME_FIRST || wParam >= IDS_COLOR_NAME_FIRST + nColors)
		return CFrameWnd::OnCommand(wParam, lParam);        // default

	// special color selected
	CString strYouPicked;
	strYouPicked.LoadString(IDS_YOU_PICKED_COLOR);

	CString strColor;
	strColor.LoadString(wParam);

	CString strMsg;
	strMsg.Format(strYouPicked, (LPCTSTR)strColor);

	CString strMenuTest;
	strMenuTest.LoadString(IDS_MENU_TEST);

	MessageBox(strMsg, strMenuTest);

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\ctrltest\old\dertest.cpp ===
// deredit.cpp : C++ derived Edit control example
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "ctrltest.h"

#include "paredit.h"

/////////////////////////////////////////////////////////////////////////////

class CDerEditDlg : public CDialog
{
protected:
	CFont*  m_pFont;
	// construct
	CParsedEdit m_edit1, m_edit2, m_edit3, m_edit4;
	CStatic m_static1, m_static2, m_static3, m_static4;
public:
	//{{AFX_DATA(CDerEditDlg)
		enum { IDD = IDD_DERIVED_EDIT };
	//}}AFX_DATA
	CDerEditDlg()
		: CDialog(CDerEditDlg::IDD)
		{ }

	void OnSetFont(CFont* pFont)
			{ m_pFont = pFont; }

	BOOL OnInitDialog();
	//{{AFX_MSG(CDerEditDlg)
		virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CDerEditDlg, CDialog)
	//{{AFX_MSG_MAP(CDerEditDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CDerEditDlg::OnInitDialog()
	// create children on InitDialog
	//  (not in CDerEditDlg constructor since the dialog has
	//    no attached HWND in the constructor)
{
	// This is an example of the _incorrect_ way to create a dialog
	// The following code show you what you should _not_ do:
	//    1) do not use hard coded numbers for coordinates and sizes
	//     (these will break when the font sizes changes and are
	//     hard to edit and maintain).
	//    2) do not put strings in code, they should be in resources.
	//    3) as you can see below the programming steps required
	//     to create controls, pass the correct creation parameters,
	//     and set the appropriate font, is complicated and error prone.
	//    4) localization of the controls would require changes to the
	//     sources for the captions, font, coordinates, and sizes.

	const int yStart = 8;
	const int height = 30;

	CPoint whereLabel(10, yStart);
	CSize sizeLabel(80, 24);

	CPoint whereEdit(90, yStart);
	CSize sizeEdit(140, 24);

	m_static1.Create(_T("Letters:"), WS_VISIBLE | WS_CHILD | SS_LEFT,
		CRect(whereLabel, sizeLabel), this, (UINT)-1);
	m_static1.SetFont(m_pFont);
	whereLabel.y += height;
	m_edit1.Create(WS_VISIBLE | WS_CHILD | WS_TABSTOP | WS_BORDER |
		PES_LETTERS,
		CRect(whereEdit, sizeEdit), this, IDC_EDIT1);
	m_edit1.SetFont(m_pFont);
	whereEdit.y += height;

	m_static2.Create(_T("Numbers:"), WS_VISIBLE | WS_CHILD | SS_LEFT,
		CRect(whereLabel, sizeLabel), this, (UINT)-1);
	m_static2.SetFont(m_pFont);
	whereLabel.y += height;
	m_edit2.Create(WS_VISIBLE | WS_CHILD | WS_TABSTOP | WS_BORDER |
		PES_NUMBERS,
		CRect(whereEdit, sizeEdit), this, IDC_EDIT2);
	m_edit2.SetFont(m_pFont);
	whereEdit.y += height;

	m_static3.Create(_T("Either:"), WS_VISIBLE | WS_CHILD | SS_LEFT,
		CRect(whereLabel, sizeLabel), this, (UINT)-1);
	m_static3.SetFont(m_pFont);
	whereLabel.y += height;
	m_edit3.Create(WS_VISIBLE | WS_CHILD | WS_TABSTOP | WS_BORDER |
		PES_LETTERS | PES_NUMBERS,
		CRect(whereEdit, sizeEdit), this, IDC_EDIT3);
	m_edit3.SetFont(m_pFont);
	whereEdit.y += height;

	m_static4.Create(_T("Anything:"), WS_VISIBLE | WS_CHILD | SS_LEFT,
		CRect(whereLabel, sizeLabel), this, (UINT)-1);
	m_static4.SetFont(m_pFont);
	whereLabel.y += height;
	m_edit4.Create(WS_VISIBLE | WS_CHILD | WS_TABSTOP | WS_BORDER |
		PES_ALL,
		CRect(whereEdit, sizeEdit), this, IDC_EDIT4);
	m_edit4.SetFont(m_pFont);
	whereEdit.y += height;

	// change the dialog height so everything fits
	int yBottom = whereEdit.y + height * 2; // extra space
	CRect rect;
	GetWindowRect(rect);
	VERIFY(SetWindowPos(NULL, -1, -1, rect.Width(), yBottom,
		SWP_NOMOVE|SWP_NOZORDER|SWP_NOREDRAW|SWP_NOACTIVATE));

	// set focus to first one
	m_edit1.SetFocus();
	return FALSE;   // focus set
}

void CDerEditDlg::OnOK()
{
#ifdef _DEBUG
	// dump results, normally you would do something with these
	CString s;
	m_edit1.GetWindowText(s);
	TRACE(_T("edit1 = '%s'\n"), s);
	m_edit2.GetWindowText(s);
	TRACE(_T("edit2 = '%s'\n"), s);
	m_edit3.GetWindowText(s);
	TRACE(_T("edit3 = '%s'\n"), s);
	m_edit4.GetWindowText(s);
	TRACE(_T("edit4 = '%s'\n"), s);
#endif

	EndDialog(IDOK);
}

/////////////////////////////////////////////////////////////////////////////
// Run the test

void CTestWindow::OnTestDerivedEdit()
{
	TRACE(_T("running dialog with special derived CParsedEdit controls in it\n"));
	CDerEditDlg dlg;
	dlg.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\ctrltest\godot\stdafx.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#define VC_EXTRALEAN

#include <afxwin.h>
#include <afxext.h> // for bitmap button
#include <afxcmn.h> // for spin control
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\ctrltest\old\paredit.cpp ===
// paredit.cpp: C++ derived edit control for numbers/letters etc
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "ctrltest.h"

#include "paredit.h"

/////////////////////////////////////////////////////////////////////////////
// ParsedEdit

CParsedEdit::CParsedEdit()
{
	m_wParseStyle = 0;
}

BEGIN_MESSAGE_MAP(CParsedEdit, CEdit)
	//{{AFX_MSG_MAP(CParsedEdit)
	ON_WM_CHAR()
	ON_WM_VSCROLL()     // for associated spin controls
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// Creating from C++ code

BOOL CParsedEdit::Create(DWORD dwStyle, const RECT& rect,
		CWnd* pParentWnd, UINT nID)
{
	m_wParseStyle = LOWORD(dwStyle);
	// figure out edit control style
	DWORD dwEditStyle = MAKELONG(ES_LEFT, HIWORD(dwStyle));
	return CWnd::Create(_T("EDIT"), NULL, dwEditStyle, rect, pParentWnd, nID);
}

/////////////////////////////////////////////////////////////////////////////
// Aliasing on top of an existing Edit control

BOOL CParsedEdit::SubclassEdit(UINT nID, CWnd* pParent, WORD wParseStyle)
{
	m_wParseStyle = wParseStyle;
	return SubclassDlgItem(nID, pParent);
}

/////////////////////////////////////////////////////////////////////////////
// Input character filter

void CParsedEdit::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	WORD type;

	if (nChar < 0x20)
		type = PES_ALL;                         // always allow control chars
	else if (IsCharAlphaNumeric((TCHAR)nChar) && !IsCharAlpha((TCHAR)nChar))
		type = PES_NUMBERS;
	else if (IsCharAlpha((TCHAR)nChar))
		type = PES_LETTERS;
	else
		type = PES_OTHERCHARS;

	if (m_wParseStyle & type)
	{
		CEdit::OnChar(nChar, nRepCnt, nFlags);  // permitted
	}
	else
	{
		// illegal character - inform parent
		OnBadInput();
	}
}

/////////////////////////////////////////////////////////////////////////////
// Spin controls will send scroll messages

void CParsedEdit::OnVScroll(UINT nSBCode, UINT, CScrollBar*)
{
	int nDelta = 0;
	if (nSBCode == SB_LINEDOWN)
		nDelta = -1;
	else if (nSBCode == SB_LINEUP)
		nDelta = +1;
	else
		return; // nothing special

	// set the focus to this edit item and select it all
	SetFocus();

	//Get the number in the control.
	BOOL bOk;
	int nOld = GetParent()->GetDlgItemInt(GetDlgCtrlID(), &bOk);
	if (bOk)
	{
		// The MuScrl32 control also supports range checking
		// for this example, we just prevent overflow
		int nNew = nOld + nDelta;
		if (nNew >= 0 && nNew <= 32767)
			GetParent()->SetDlgItemInt(GetDlgCtrlID(), nNew);
		else
			bOk = FALSE;
	}

	if (!bOk)
		OnBadInput();
	SetSel(0, -1);
}

/////////////////////////////////////////////////////////////////////////////
// default bad input handler, beep (unless parent notification
//    returns -1.  Most parent dialogs will return 0 or 1 for command
//    handlers (i.e. Beep is the default)

void CParsedEdit::OnBadInput()
{
	if (GetParent()->SendMessage(WM_COMMAND,
		MAKELONG(GetDlgCtrlID(), PEN_ILLEGALCHAR), (LPARAM)m_hWnd) != -1)
	{
		MessageBeep((UINT)-1);
	}
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\ctrltest\old\paredit2.cpp ===
// paredit2.cpp : code needed to export CParsedEdit as a WndClass
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "ctrltest.h"

#include "paredit.h"
#include <ctl3d.h>

/////////////////////////////////////////////////////////////////////////////
// The C++ class CParsedEdit can be made visible to the dialog manager
//   by registering a window class for it
// The C++ class 'CParsedEditExported' is used to implement the
//   creation and destruction of a C++ object as if it were just
//   a normal Windows control.
// In order to hook in the class creation we must provide a special
//   WndProc to create the C++ object and override the PostNcDestroy
//   message to destroy it

class CParsedEditExported : public CParsedEdit      // WNDCLASS exported class
{
public:
	CParsedEditExported() { };
	BOOL RegisterControlClass();

// Implementation: (all is implementation since the public interface of
//    this class is identical to CParsedEdit)
protected:
	virtual void PostNcDestroy();
	static LRESULT CALLBACK EXPORT WndProcHook(HWND, UINT, WPARAM, LPARAM);
	static WNDPROC lpfnSuperEdit;

	friend class CParsedEdit;       // for RegisterControlClass

	//{{AFX_MSG(CParsedEditExported)
	afx_msg int OnNcCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP();
};

/////////////////////////////////////////////////////////////////////////////
// Special create hooks

LRESULT CALLBACK EXPORT
CParsedEditExported::WndProcHook(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	// create new item and attach it
	CParsedEditExported* pEdit = new CParsedEditExported();
	pEdit->Attach(hWnd);

	// set up wndproc to AFX one, and call it
	pEdit->m_pfnSuper = CParsedEditExported::lpfnSuperEdit;
	::SetWindowLong(hWnd, GWL_WNDPROC, (DWORD)AfxWndProc);

	// Since this window is really an edit control but does not
	//  have "edit" as its class name, to make it work correctly
	//  with CTL3D, we have to tell CTL3D that is "really is" an
	//  edit control.  This uses a relatively new API in CTL3D
	//  called Ctl3dSubclassCtlEx.
	pEdit->SubclassCtl3d(CTL3D_EDIT_CTL);

	// then call it for this first message
#ifdef STRICT
	return ::CallWindowProc(AfxWndProc, hWnd, msg, wParam, lParam);
#else
	return ::CallWindowProc((FARPROC)AfxWndProc, hWnd, msg, wParam, lParam);
#endif
}

BEGIN_MESSAGE_MAP(CParsedEditExported, CParsedEdit)
	//{{AFX_MSG_MAP(CParsedEditExported)
	ON_WM_NCCREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

int CParsedEditExported::OnNcCreate(LPCREATESTRUCT lpCreateStruct)
{
	// special create hook
	// example of stripping the sub-style bits from the style specified
	//   in the dialog template to use for some other reason
	m_wParseStyle = LOWORD(lpCreateStruct->style);
	DWORD dwEditStyle = MAKELONG(ES_LEFT, HIWORD(lpCreateStruct->style));

	::SetWindowLong(m_hWnd, GWL_STYLE, dwEditStyle);
	lpCreateStruct->style = dwEditStyle;
	return CParsedEdit::OnNcCreate(lpCreateStruct);
}

void CParsedEditExported::PostNcDestroy()
{
	// needed to clean up the C++ CWnd object
	delete this;
}

/////////////////////////////////////////////////////////////////////////////
// Routine to register the class

WNDPROC CParsedEditExported::lpfnSuperEdit = NULL;

BOOL CParsedEdit::RegisterControlClass()
{
	WNDCLASS wcls;

	// check to see if class already registered
	static const TCHAR szClass[] = _T("paredit");
	if (::GetClassInfo(AfxGetInstanceHandle(), szClass, &wcls))
	{
		// name already registered - ok if it was us
		return (wcls.lpfnWndProc == (WNDPROC)CParsedEditExported::WndProcHook);
	}

	// Use standard "edit" control as a template.
	VERIFY(::GetClassInfo(NULL, _T("edit"), &wcls));
	CParsedEditExported::lpfnSuperEdit = wcls.lpfnWndProc;

	// set new values
	wcls.lpfnWndProc = CParsedEditExported::WndProcHook;
	wcls.hInstance = AfxGetInstanceHandle();
	wcls.lpszClassName = szClass;
	return (RegisterClass(&wcls) != 0);
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\ctrltest\old\paredit.h ===
// paredit.h: C++ derived edit control for numbers/letters etc
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


/////////////////////////////////////////////////////////////////////////////
// CParsedEdit is a specialized CEdit control that only allows characters
//  of a given type.
// This class is used in 3 different ways in the samples

class CParsedEdit : public CEdit
{
protected:
	WORD    m_wParseStyle;      // C++ member data
public:
// Construction
	CParsedEdit();

	// explicit construction (see DERTEST.CPP)
	BOOL Create(DWORD dwStyle /* includes PES_ style*/, const RECT& rect,
		CWnd* pParentWnd, UINT nID);

	// subclassed construction (see SUBTEST.CPP)
	BOOL SubclassEdit(UINT nID, CWnd* pParent, WORD wParseStyle);

	// for WNDCLASS Registered window
	static BOOL RegisterControlClass();

// Overridables
	virtual void OnBadInput();

// Implementation
protected:
	//{{AFX_MSG(CParsedEdit)
	afx_msg void OnChar(UINT, UINT, UINT); // for character validation
	afx_msg void OnVScroll(UINT, UINT, CScrollBar*); // for spin buttons
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////
// Parsed edit control sub-styles

#define PES_NUMBERS         0x0001
#define PES_LETTERS         0x0002
#define PES_OTHERCHARS      0x0004
#define PES_ALL             0xFFFF

/////////////////////////////////////////////////////////////////////////////
// Extra control notifications

// above the range for normal EN_ messages
#define PEN_ILLEGALCHAR     0x8000
			// sent to parent when illegal character hit
			// return 0 if you want parsed edit to beep

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\ctrltest\godot\subtest.cpp ===
// subedit.cpp : SubClassed Edit control example
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "ctrltest.h"

#include "paredit.h"

/////////////////////////////////////////////////////////////////////////////
// Dialog class

class CSubEditDlg : public CDialog
{
protected:
	CParsedEdit edit1, edit2, edit3, edit4;
public:
	//{{AFX_DATA(CSubEditDlg)
		enum { IDD = IDD_SUB_EDIT };
	//}}AFX_DATA
	CSubEditDlg()
		: CDialog(CSubEditDlg::IDD)
			{ }

	BOOL OnInitDialog();
	//{{AFX_MSG(CSubEditDlg)
		virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CSubEditDlg, CDialog)
	//{{AFX_MSG_MAP(CSubEditDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CSubEditDlg::OnInitDialog()
{
	edit1.SubclassEdit(IDC_EDIT1, this, PES_LETTERS);
	edit2.SubclassEdit(IDC_EDIT2, this, PES_NUMBERS);
	edit3.SubclassEdit(IDC_EDIT3, this, PES_NUMBERS | PES_LETTERS);
	edit4.SubclassEdit(IDC_EDIT4, this, PES_ALL);
	return TRUE;
}

void CSubEditDlg::OnOK()
{
#ifdef _DEBUG
	// dump results, normally you would do something with these
	CString s;
	edit1.GetWindowText(s);
	TRACE1("edit1 = '%s'\n", s);
	edit2.GetWindowText(s);
	TRACE1("edit2 = '%s'\n", s);
	edit3.GetWindowText(s);
	TRACE1("edit3 = '%s'\n", s);
	edit4.GetWindowText(s);
	TRACE1("edit4 = '%s'\n", s);
#endif

	EndDialog(IDOK);
}

/////////////////////////////////////////////////////////////////////////////
// Run the test

void CTestWindow::OnTestSubclassedEdit()
{
	TRACE0("running dialog containing edit items aliased to ParsedEdits\n");
	CSubEditDlg dlg;
	dlg.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\ctrltest\old\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ctrltest.rc
//
#define IDS_YOU_CHOSE                   1
#define IDS_PLEASE_SELECT_COLOR         2
#define IDM_TEST_BITMAP_BUTTON1         400
#define IDM_TEST_BITMAP_BUTTON2         401
#define IDM_TEST_BITMAP_BUTTON3         402
#define IDM_TEST_CUSTOM_LIST            403
#define IDM_TEST_CUSTOM_MENU            405
#define IDM_TEST_DERIVED_EDIT           406
#define IDM_TEST_PENEDIT_CODE           407
#define IDM_TEST_PENEDIT_FEATURES       408
#define IDM_TEST_PENEDIT_TEMPLATE       409
#define IDM_TEST_SPIN_EDIT              410
#define IDM_TEST_SUB_EDIT               411
#define IDM_TEST_WNDCLASS_EDIT          412
#define IDD_CUSTOM_LIST                 500
#define IDD_DERIVED_EDIT                501
#define IDD_SUB_EDIT                    505
#define IDD_SUB_PENEDIT                 506
#define IDC_NUMBEROUT                   1000
#define IDS_COLOR_NAME_FIRST            2000
#define IDS_COLOR_NAME_BLUE             2001
#define IDS_COLOR_NAME_GREEN            2002
#define IDS_COLOR_NAME_CYAN             2003
#define IDS_COLOR_NAME_RED              2004
#define IDS_COLOR_NAME_MAGENTA          2005
#define IDS_COLOR_NAME_YELLOW           2006
#define IDS_COLOR_NAME_WHITE            2007
#define IDS_YOU_PICKED_COLOR            2008
#define IDS_MENU_TEST                   2009
#define IDS_ILLEGAL_VALUE               2010
#define IDS_MUSCRL32_DLL_REQUIRED       2011
#define IDS_WNDCLASS_NOT_REGISTERED     2012
#define IDC_EDIT1                       2101
#define IDC_EDIT2                       2102
#define IDC_EDIT3                       2103
#define IDC_EDIT4                       2104
#define IDC_LISTBOX1                    2301
#define ID_PREV                         0x8000
#define ID_NEXT                         0x8001

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         57667
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\ctrltest\old\spintest.cpp ===
// spintest.cpp : New control example - Uses MicroScroll32
//                custom control DLL from MuScrl32 sample
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "ctrltest.h"

#include "paredit.h"

/////////////////////////////////////////////////////////////////////////////
// Example of a dialog with special controls in it

#define NUM_EDIT        4
#define IDC_EDIT_MIN    IDC_EDIT1
#define IDC_BUTTON_MAX  IDC_BUTTON4
	// IDC_EDIT1->IDC_EDIT4 and IDC_BUTTON1->IDC_BUTTON4 must be contiguous

class CSpinEditDlg : public CDialog
{
protected:
	CParsedEdit edit[NUM_EDIT];
public:
	//{{AFX_DATA(CSpinEditDlg)
		enum { IDD = IDD_SPIN_EDIT };
	//}}AFX_DATA
	CSpinEditDlg()
		: CDialog(CSpinEditDlg::IDD)
			{ }

	BOOL OnInitDialog();
	//{{AFX_MSG(CSpinEditDlg)
		virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CSpinEditDlg, CDialog)
	//{{AFX_MSG_MAP(CSpinEditDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CSpinEditDlg::OnInitDialog()
{
	int value = 1;
	for (int i = 0; i < NUM_EDIT; i++)
	{
		// associate button with edit item
		CSpinButtonCtrl* pSpin = (CSpinButtonCtrl*)GetDlgItem(IDC_BUTTON_MAX - i);
		ASSERT(pSpin != NULL);
			pSpin->SetPos(value++);     // 1, 2, 3, 4
	}
	return TRUE;
}

void CSpinEditDlg::OnOK()
{
	int values[NUM_EDIT];
	UINT nID = 0;
	BOOL bOk = TRUE;
	for (int i = 0; bOk && i < NUM_EDIT; i++)
	{
		nID = IDC_EDIT_MIN + i;
		values[i] = GetDlgItemInt(nID, &bOk);
	}

	if (!bOk)
	{
		// report illegal value
		CString str;
		str.LoadString(IDS_ILLEGAL_VALUE);
		MessageBox(str);
		CEdit& badEdit = *(CEdit*)GetDlgItem(nID);
		badEdit.SetSel(0, -1);
		badEdit.SetFocus();
		return;     // don't end dialog
	}

#ifdef _DEBUG
	// dump results, normally you would do something with these
	TRACE0("Final values:\n");
	for (i = 0; i < NUM_EDIT; i++)
		TRACE1("\t%d\n", values[i]);
#endif
	EndDialog(IDOK);
}

/////////////////////////////////////////////////////////////////////////////
// Run the test

void CTestWindow::OnTestSpinEdit()
{
	TRACE0("running dialog with spin controls in it\n");
	CSpinEditDlg dlg;
	dlg.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\ctrltest\old\stdafx.cpp ===
// stdafx.cpp : pre-compiled header and types file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\ctrltest\old\stdafx.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#define VC_EXTRALEAN

#include <afxwin.h>
#include <afxext.h> // for bitmap button
#include <afxcmn.h> // for spin control
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\ctrltest\old\subtest.cpp ===
// subedit.cpp : SubClassed Edit control example
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "ctrltest.h"

#include "paredit.h"

/////////////////////////////////////////////////////////////////////////////
// Dialog class

class CSubEditDlg : public CDialog
{
protected:
	CParsedEdit edit1, edit2, edit3, edit4;
public:
	//{{AFX_DATA(CSubEditDlg)
		enum { IDD = IDD_SUB_EDIT };
	//}}AFX_DATA
	CSubEditDlg()
		: CDialog(CSubEditDlg::IDD)
			{ }

	BOOL OnInitDialog();
	//{{AFX_MSG(CSubEditDlg)
		virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CSubEditDlg, CDialog)
	//{{AFX_MSG_MAP(CSubEditDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CSubEditDlg::OnInitDialog()
{
	edit1.SubclassEdit(IDC_EDIT1, this, PES_LETTERS);
	edit2.SubclassEdit(IDC_EDIT2, this, PES_NUMBERS);
	edit3.SubclassEdit(IDC_EDIT3, this, PES_NUMBERS | PES_LETTERS);
	edit4.SubclassEdit(IDC_EDIT4, this, PES_ALL);
	return TRUE;
}

void CSubEditDlg::OnOK()
{
#ifdef _DEBUG
	// dump results, normally you would do something with these
	CString s;
	edit1.GetWindowText(s);
	TRACE1("edit1 = '%s'\n", s);
	edit2.GetWindowText(s);
	TRACE1("edit2 = '%s'\n", s);
	edit3.GetWindowText(s);
	TRACE1("edit3 = '%s'\n", s);
	edit4.GetWindowText(s);
	TRACE1("edit4 = '%s'\n", s);
#endif

	EndDialog(IDOK);
}

/////////////////////////////////////////////////////////////////////////////
// Run the test

void CTestWindow::OnTestSubclassedEdit()
{
	TRACE0("running dialog containing edit items aliased to ParsedEdits\n");
	CSubEditDlg dlg;
	dlg.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\ctrltest\godot\wclstest.cpp ===
// wclsedit.cpp : registered WNDCLASS Edit control example
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "ctrltest.h"

#include "paredit.h"

/////////////////////////////////////////////////////////////////////////////
// Dialog class

class CWclsEditDlg : public CDialog
{
public:
	//{{AFX_DATA(CWclsEditDlg)
		enum { IDD = IDD_WNDCLASS_EDIT };
	//}}AFX_DATA
	CWclsEditDlg()
		: CDialog(CWclsEditDlg::IDD)
		{ }

	// access to controls is through inline helpers
	CEdit&  Edit1()
				{ return *(CEdit*)GetDlgItem(IDC_EDIT1); }
	CEdit&  Edit2()
				{ return *(CEdit*)GetDlgItem(IDC_EDIT2); }
	CEdit&  Edit3()
				{ return *(CEdit*)GetDlgItem(IDC_EDIT3); }
	CEdit&  Edit4()
				{ return *(CEdit*)GetDlgItem(IDC_EDIT4); }

	BOOL OnInitDialog();
	//{{AFX_MSG(CWclsEditDlg)
	virtual void OnOK();
	afx_msg void OnIllegalChar();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP();
};

BOOL CWclsEditDlg::OnInitDialog()
{
	// nothing special to do
	return TRUE;
}

void CWclsEditDlg::OnOK()
{
#ifdef _DEBUG
	// dump results, normally you would do something with these
	CString s;
	Edit1().GetWindowText(s);
	TRACE1("edit1 = '%s'\n", s);
	Edit2().GetWindowText(s);
	TRACE1("edit2 = '%s'\n", s);
	Edit3().GetWindowText(s);
	TRACE1("edit3 = '%s'\n", s);
	Edit4().GetWindowText(s);
	TRACE1("edit4 = '%s'\n", s);
#endif

	EndDialog(IDOK);
}

/////////////////////////////////////////////////////////////////////////////
// Handle custom control notification here

BEGIN_MESSAGE_MAP(CWclsEditDlg, CDialog)
	//{{AFX_MSG_MAP(CWclsEditDlg)
	ON_CONTROL(PEN_ILLEGALCHAR, IDC_EDIT1, OnIllegalChar)
	ON_CONTROL(PEN_ILLEGALCHAR, IDC_EDIT2, OnIllegalChar)
	ON_CONTROL(PEN_ILLEGALCHAR, IDC_EDIT3, OnIllegalChar)
	ON_CONTROL(PEN_ILLEGALCHAR, IDC_EDIT4, OnIllegalChar)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


void  CWclsEditDlg::OnIllegalChar()
{
	TRACE0("Don't do that!\n");
	// add extra reporting here...
}

/////////////////////////////////////////////////////////////////////////////
// Run the test

void CTestWindow::OnTestWndClassEdit()
{
	TRACE0("running dialog containing WNDCLASS special edit items\n");
	if (!CParsedEdit::RegisterControlClass())
	{
		CString strMsg;
		strMsg.LoadString(IDS_WNDCLASS_NOT_REGISTERED);
		MessageBox(strMsg);
		return;
	}
	CWclsEditDlg dlg;
	dlg.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\hello\godot\stdafx.cpp ===
// stdafx.cpp : pre-compiled header and types file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\ctrltest\godot\res\otherids.h ===
//{{NO_DEPENDENCIES}}
//
// Copyright (C) 1998 Microsoft Corporation
// All rights reserved.
//
// Read-only resource IDs uses by RES\CTRLTEST.RC2

#define IDC_ALC_FIRST                   1100
#define IDC_BUTTON1                     2201
#define IDC_BUTTON2                     2202
#define IDC_BUTTON3                     2203
#define IDC_BUTTON4                     2204
#define IDC_CONFIGURE                   1000
#define IDC_LEFTHANDED                  1001
#define IDD_PENEDIT_CONFIGURE           502
#define IDD_PENEDIT_FEATURES            503
#define IDD_SPIN_EDIT                   504
#define IDD_WNDCLASS_EDIT               507
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\ctrltest\old\res\otherids.h ===
//{{NO_DEPENDENCIES}}
//
// Copyright (C) 1998 Microsoft Corporation
// All rights reserved.
//
// Read-only resource IDs uses by RES\CTRLTEST.RC2

#define IDC_ALC_FIRST                   1100
#define IDC_BUTTON1                     2201
#define IDC_BUTTON2                     2202
#define IDC_BUTTON3                     2203
#define IDC_BUTTON4                     2204
#define IDC_CONFIGURE                   1000
#define IDC_LEFTHANDED                  1001
#define IDD_PENEDIT_CONFIGURE           502
#define IDD_PENEDIT_FEATURES            503
#define IDD_SPIN_EDIT                   504
#define IDD_WNDCLASS_EDIT               507
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\ctrltest\old\wclstest.cpp ===
// wclsedit.cpp : registered WNDCLASS Edit control example
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "ctrltest.h"

#include "paredit.h"

/////////////////////////////////////////////////////////////////////////////
// Dialog class

class CWclsEditDlg : public CDialog
{
public:
	//{{AFX_DATA(CWclsEditDlg)
		enum { IDD = IDD_WNDCLASS_EDIT };
	//}}AFX_DATA
	CWclsEditDlg()
		: CDialog(CWclsEditDlg::IDD)
		{ }

	// access to controls is through inline helpers
	CEdit&  Edit1()
				{ return *(CEdit*)GetDlgItem(IDC_EDIT1); }
	CEdit&  Edit2()
				{ return *(CEdit*)GetDlgItem(IDC_EDIT2); }
	CEdit&  Edit3()
				{ return *(CEdit*)GetDlgItem(IDC_EDIT3); }
	CEdit&  Edit4()
				{ return *(CEdit*)GetDlgItem(IDC_EDIT4); }

	BOOL OnInitDialog();
	//{{AFX_MSG(CWclsEditDlg)
	virtual void OnOK();
	afx_msg void OnIllegalChar();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP();
};

BOOL CWclsEditDlg::OnInitDialog()
{
	// nothing special to do
	return TRUE;
}

void CWclsEditDlg::OnOK()
{
#ifdef _DEBUG
	// dump results, normally you would do something with these
	CString s;
	Edit1().GetWindowText(s);
	TRACE1("edit1 = '%s'\n", s);
	Edit2().GetWindowText(s);
	TRACE1("edit2 = '%s'\n", s);
	Edit3().GetWindowText(s);
	TRACE1("edit3 = '%s'\n", s);
	Edit4().GetWindowText(s);
	TRACE1("edit4 = '%s'\n", s);
#endif

	EndDialog(IDOK);
}

/////////////////////////////////////////////////////////////////////////////
// Handle custom control notification here

BEGIN_MESSAGE_MAP(CWclsEditDlg, CDialog)
	//{{AFX_MSG_MAP(CWclsEditDlg)
	ON_CONTROL(PEN_ILLEGALCHAR, IDC_EDIT1, OnIllegalChar)
	ON_CONTROL(PEN_ILLEGALCHAR, IDC_EDIT2, OnIllegalChar)
	ON_CONTROL(PEN_ILLEGALCHAR, IDC_EDIT3, OnIllegalChar)
	ON_CONTROL(PEN_ILLEGALCHAR, IDC_EDIT4, OnIllegalChar)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


void  CWclsEditDlg::OnIllegalChar()
{
	TRACE0("Don't do that!\n");
	// add extra reporting here...
}

/////////////////////////////////////////////////////////////////////////////
// Run the test

void CTestWindow::OnTestWndClassEdit()
{
	TRACE0("running dialog containing WNDCLASS special edit items\n");
	if (!CParsedEdit::RegisterControlClass())
	{
		CString strMsg;
		strMsg.LoadString(IDS_WNDCLASS_NOT_REGISTERED);
		MessageBox(strMsg);
		return;
	}
	CWclsEditDlg dlg;
	dlg.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\hello\godot\hello.h ===
// hello.h : Declares the class interfaces for the application.
//         Hello is a simple program which consists of a main window
//         and an "About" dialog which can be invoked by a menu choice.
//         It is intended to serve as a starting-point for new
//         applications.
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __HELLO_H__
#define __HELLO_H__

/////////////////////////////////////////////////////////////////////////////

// CMainWindow:
// See hello.cpp for the code to the member functions and the message map.
//
class CMainWindow : public CFrameWnd
{
public:
	CMainWindow();

	//{{AFX_MSG( CMainWindow )
	afx_msg void OnPaint();
	afx_msg void OnAbout();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

// CTheApp:
// See hello.cpp for the code to the InitInstance member function.
//
class CTheApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
};

/////////////////////////////////////////////////////////////////////////////

#endif // __HELLO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\hello\godot\stdafx.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#define VC_EXTRALEAN

#include <afxwin.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\hello\godot\hello.cpp ===
// hello.cpp : Defines the class behaviors for the application.
//           Hello is a simple program which consists of a main window
//           and an "About" dialog which can be invoked by a menu choice.
//           It is intended to serve as a starting-point for new
//           applications.
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "resource.h"

#include "hello.h"

/////////////////////////////////////////////////////////////////////////////

// theApp:
// Just creating this application object runs the whole application.
//
CTheApp NEAR theApp;

/////////////////////////////////////////////////////////////////////////////

// CMainWindow constructor:
// Create the window with the appropriate style, size, menu, etc.
//
CMainWindow::CMainWindow()
{
	LoadFrame(IDR_MAINFRAME);
}

// OnPaint:
// This routine draws the string "Hello, Windows!" in the center of the
// client area.  It is called whenever Windows sends a WM_PAINT message.
// Note that creating a CPaintDC automatically does a BeginPaint and
// an EndPaint call is done when it is destroyed at the end of this
// function.  CPaintDC's constructor needs the window (this).
//
void CMainWindow::OnPaint()
{
	CRect rect;
	GetClientRect(rect);

	CPaintDC dc(this);
	dc.SetTextAlign(TA_BASELINE | TA_CENTER);
	dc.SetTextColor(::GetSysColor(COLOR_WINDOWTEXT));
	dc.SetBkMode(TRANSPARENT);
	CString s;
	s.LoadString(IDS_HELLO);
	dc.TextOut((rect.right / 2), (rect.bottom / 2), s);
}

// OnAbout:
// This member function is called when a WM_COMMAND message with an
// ID_APP_ABOUT code is received by the CMainWindow class object.   The
// message map below is responsible for this routing.
//
// We create a ClDialog object using the "AboutBox" resource (see
// hello.rc), and invoke it.
//
void CMainWindow::OnAbout()
{
	CDialog about(IDD_ABOUTBOX);
	about.DoModal();
}

// CMainWindow message map:
// Associate messages with member functions.
//
// It is implied that the ON_WM_PAINT macro expects a member function
// "void OnPaint()".
//
// It is implied that members connected with the ON_COMMAND macro
// receive no arguments and are void of return type, e.g., "void OnAbout()".
//
BEGIN_MESSAGE_MAP( CMainWindow, CFrameWnd )
	//{{AFX_MSG_MAP( CMainWindow )
	ON_WM_PAINT()
	ON_COMMAND(ID_APP_ABOUT, OnAbout)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTheApp

// InitInstance:
// When any CTheApp object is created, this member function is automatically
// called.  Any data may be set up at this point.
//
// Also, the main window of the application should be created and shown here.
// Return TRUE if the initialization is successful.
//
BOOL CTheApp::InitInstance()
{
	TRACE0("CTheApp::InitInstance\n");

	Enable3dControls(); // use 3d controls in dialogs

	m_pMainWnd = new CMainWindow;
	m_pMainWnd->ShowWindow(m_nCmdShow);
	m_pMainWnd->UpdateWindow();

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\hello\old\stdafx.cpp ===
// stdafx.cpp : pre-compiled header and types file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\hello\old\stdafx.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#define VC_EXTRALEAN

#include <afxwin.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\hello\godot\resource.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by HELLO.RC
//
#define IDR_MAINFRAME                   128
#define IDS_HELLO                       129
#define IDD_ABOUTBOX                    130

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\hello\old\hello.h ===
// hello.h : Declares the class interfaces for the application.
//         Hello is a simple program which consists of a main window
//         and an "About" dialog which can be invoked by a menu choice.
//         It is intended to serve as a starting-point for new
//         applications.
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __HELLO_H__
#define __HELLO_H__

/////////////////////////////////////////////////////////////////////////////

// CMainWindow:
// See hello.cpp for the code to the member functions and the message map.
//
class CMainWindow : public CFrameWnd
{
public:
	CMainWindow();

	//{{AFX_MSG( CMainWindow )
	afx_msg void OnPaint();
	afx_msg void OnAbout();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

// CTheApp:
// See hello.cpp for the code to the InitInstance member function.
//
class CTheApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
};

/////////////////////////////////////////////////////////////////////////////

#endif // __HELLO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\hello\old\hello.cpp ===
// hello.cpp : Defines the class behaviors for the application.
//           Hello is a simple program which consists of a main window
//           and an "About" dialog which can be invoked by a menu choice.
//           It is intended to serve as a starting-point for new
//           applications.
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "resource.h"

#include "hello.h"

/////////////////////////////////////////////////////////////////////////////

// theApp:
// Just creating this application object runs the whole application.
//
CTheApp NEAR theApp;

/////////////////////////////////////////////////////////////////////////////

// CMainWindow constructor:
// Create the window with the appropriate style, size, menu, etc.
//
CMainWindow::CMainWindow()
{
	LoadFrame(IDR_MAINFRAME);
}

// OnPaint:
// This routine draws the string "Hello, Windows!" in the center of the
// client area.  It is called whenever Windows sends a WM_PAINT message.
// Note that creating a CPaintDC automatically does a BeginPaint and
// an EndPaint call is done when it is destroyed at the end of this
// function.  CPaintDC's constructor needs the window (this).
//
void CMainWindow::OnPaint()
{
	CRect rect;
	GetClientRect(rect);

	CPaintDC dc(this);
	dc.SetTextAlign(TA_BASELINE | TA_CENTER);
	dc.SetTextColor(::GetSysColor(COLOR_WINDOWTEXT));
	dc.SetBkMode(TRANSPARENT);
	CString s;
	s.LoadString(IDS_HELLO);
	dc.TextOut((rect.right / 2), (rect.bottom / 2), s);
}

// OnAbout:
// This member function is called when a WM_COMMAND message with an
// ID_APP_ABOUT code is received by the CMainWindow class object.   The
// message map below is responsible for this routing.
//
// We create a ClDialog object using the "AboutBox" resource (see
// hello.rc), and invoke it.
//
void CMainWindow::OnAbout()
{
	CDialog about(IDD_ABOUTBOX);
	about.DoModal();
}

// CMainWindow message map:
// Associate messages with member functions.
//
// It is implied that the ON_WM_PAINT macro expects a member function
// "void OnPaint()".
//
// It is implied that members connected with the ON_COMMAND macro
// receive no arguments and are void of return type, e.g., "void OnAbout()".
//
BEGIN_MESSAGE_MAP( CMainWindow, CFrameWnd )
	//{{AFX_MSG_MAP( CMainWindow )
	ON_WM_PAINT()
	ON_COMMAND(ID_APP_ABOUT, OnAbout)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTheApp

// InitInstance:
// When any CTheApp object is created, this member function is automatically
// called.  Any data may be set up at this point.
//
// Also, the main window of the application should be created and shown here.
// Return TRUE if the initialization is successful.
//
BOOL CTheApp::InitInstance()
{
	TRACE0("CTheApp::InitInstance\n");

	Enable3dControls(); // use 3d controls in dialogs

	m_pMainWnd = new CMainWindow;
	m_pMainWnd->ShowWindow(m_nCmdShow);
	m_pMainWnd->UpdateWindow();

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\hello\old\resource.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by HELLO.RC
//
#define IDR_MAINFRAME                   128
#define IDS_HELLO                       129
#define IDD_ABOUTBOX                    130

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\mdidocvw\godot\bncdoc.cpp ===
// BounceDoc.cpp : implementation file
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "MDI.h"
#include "BncDoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBounceDoc

IMPLEMENT_DYNCREATE(CBounceDoc, CDocument)

CBounceDoc::CBounceDoc()
{
}

BOOL CBounceDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;

	m_clrBall = RGB(0, 0, 255);
	m_bFastSpeed = FALSE;

	m_bBlue= 1;
	m_bWhite= m_bRed= 0;
	m_bGreen= m_bBlack= m_bCustom= 0;

	return TRUE;
}

CBounceDoc::~CBounceDoc()
{
}


BEGIN_MESSAGE_MAP(CBounceDoc, CDocument)
	//{{AFX_MSG_MAP(CBounceDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CBounceDoc diagnostics

#ifdef _DEBUG
void CBounceDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CBounceDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CBounceDoc serialization

void CBounceDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
	}
	else
	{
	}
}

/////////////////////////////////////////////////////////////////////////////
// CBounceDoc commands
void CBounceDoc::SetCustomBallColor(COLORREF clr)
{
	m_clrBall= clr;
	UpdateAllViews(NULL);
}

void CBounceDoc::SetBallRadius(CSize radius)
{
	m_sizeRadius= radius;
	UpdateAllViews(NULL);
}

void CBounceDoc::ClearAllColors()
{
	m_bBlack= m_bBlue= m_bRed= 0;
	m_bWhite= m_bGreen= m_bCustom= 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\helloapp\godot\helloapp.cpp ===
// helloapp.cpp : Minimal MFC Windows app.
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include <afxwin.h>

#ifdef MINIMAL

// Stub out non-critical CRT initialization functions
extern "C" void _setenvp() { }
extern "C" void _setargv() { }

// Define a window class derived from CWnd
class CHelloWindow : public CWnd
{
public:
	CHelloWindow()
	{
		CreateEx(WS_EX_CLIENTEDGE,
			AfxRegisterWndClass(0, ::LoadCursor(NULL, IDC_ARROW), (HBRUSH)(COLOR_WINDOW+1)),
			_T("Hello World!"), WS_OVERLAPPEDWINDOW,
			CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, 0);
	}
};

#else

// Define a window class derived from CFrameWnd
class CHelloWindow : public CFrameWnd
{
public:
	CHelloWindow()
		{ Create(NULL, _T("Hello World!"), WS_OVERLAPPEDWINDOW, rectDefault); }
};

#endif

// Define an application class derived from CWinApp
class CHelloApp : public CWinApp
{
public:
	virtual BOOL InitInstance()
	{
		m_pMainWnd = new CHelloWindow();
		m_pMainWnd->ShowWindow(m_nCmdShow);
		m_pMainWnd->UpdateWindow();
		return TRUE;
	}
};

CHelloApp HelloApp;  // HelloApp's constructor initializes and runs the app
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\helloapp\old\helloapp.cpp ===
// helloapp.cpp : Minimal MFC Windows app.
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include <afxwin.h>

#ifdef MINIMAL

// Stub out non-critical CRT initialization functions
extern "C" void _setenvp() { }
extern "C" void _setargv() { }

// Define a window class derived from CWnd
class CHelloWindow : public CWnd
{
public:
	CHelloWindow()
	{
		CreateEx(WS_EX_CLIENTEDGE,
			AfxRegisterWndClass(0, ::LoadCursor(NULL, IDC_ARROW), (HBRUSH)(COLOR_WINDOW+1)),
			_T("Hello World!"), WS_OVERLAPPEDWINDOW,
			CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, 0);
	}
};

#else

// Define a window class derived from CFrameWnd
class CHelloWindow : public CFrameWnd
{
public:
	CHelloWindow()
		{ Create(NULL, _T("Hello World!"), WS_OVERLAPPEDWINDOW, rectDefault); }
};

#endif

// Define an application class derived from CWinApp
class CHelloApp : public CWinApp
{
public:
	virtual BOOL InitInstance()
	{
		m_pMainWnd = new CHelloWindow();
		m_pMainWnd->ShowWindow(m_nCmdShow);
		m_pMainWnd->UpdateWindow();
		return TRUE;
	}
};

CHelloApp HelloApp;  // HelloApp's constructor initializes and runs the app
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\mdidocvw\godot\bncvw.cpp ===
// BounceVw.cpp : implementation file
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "MDI.h"

#include "BncDoc.h"
#include "BncVw.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define ABS(x) ((x) < 0? -(x) : (x) > 0? (x) : 0)

/////////////////////////////////////////////////////////////////////////////
// CBounceView

IMPLEMENT_DYNCREATE(CBounceView, CView)

CBounceView::CBounceView()
{
}

CBounceView::~CBounceView()
{
}


BEGIN_MESSAGE_MAP(CBounceView, CView)
	//{{AFX_MSG_MAP(CBounceView)
	ON_COMMAND(ID_CUSTOM, OnCustomColor)
	ON_COMMAND(ID_SPEED_FAST, OnFast)
	ON_COMMAND(ID_SPEED_SLOW, OnSlow)
	ON_WM_CREATE()
	ON_WM_SIZE()
	ON_WM_TIMER()
	ON_UPDATE_COMMAND_UI(ID_SPEED_FAST, OnUpdateFast)
	ON_UPDATE_COMMAND_UI(ID_SPEED_SLOW, OnUpdateSlow)
	ON_UPDATE_COMMAND_UI(ID_CUSTOM, OnUpdateCustom)
	ON_UPDATE_COMMAND_UI(ID_BLACK, OnUpdateBlack)
	ON_UPDATE_COMMAND_UI(ID_BLUE, OnUpdateBlue)
	ON_UPDATE_COMMAND_UI(ID_GREEN, OnUpdateGreen)
	ON_UPDATE_COMMAND_UI(ID_RED, OnUpdateRed)
	ON_UPDATE_COMMAND_UI(ID_WHITE, OnUpdateWhite)
	ON_COMMAND(ID_BLACK, OnColor)
	ON_COMMAND(ID_BLUE, OnColor)
	ON_COMMAND(ID_GREEN, OnColor)
	ON_COMMAND(ID_RED, OnColor)
	ON_COMMAND(ID_WHITE, OnColor)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CBounceView drawing

void CBounceView::OnDraw(CDC* pDC)
{
	CDocument* pDoc = GetDocument();

// NOTE: Because the animation depends on timer events
// and resizing of the window, the rendering code is
// mostly found in the MakeNewBall function; called by handlers
// for WM_TIMER and WM_SIZE commands. These handlers make the code easier
// to read. However, the side-effect is that the ball will not be
// rendered when the document is printed because there is no rendering
// code in the OnDraw override.

}

/////////////////////////////////////////////////////////////////////////////
// CBounceView diagnostics

#ifdef _DEBUG
void CBounceView::AssertValid() const
{
	CView::AssertValid();
}

void CBounceView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}

CBounceDoc* CBounceView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CBounceDoc)));
	return (CBounceDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CBounceView message handlers

void CBounceView::ChangeSpeed()
{
	CBounceDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

// re-create the timer
	KillTimer(1);
	if (!SetTimer(1, pDoc->m_bFastSpeed ? 0 : 100, NULL))
	{
		AfxMessageBox(_T("Not enough timers available for this window"),
			MB_ICONEXCLAMATION | MB_OK);
		DestroyWindow();
	}
}

void CBounceView::MakeNewBall()
{

// Computes the attributes of the ball bitmap using
// aspect and window size

	CBounceDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	CSize radius, move, total;
	CBitmap* pbmBall;

	pbmBall = &(pDoc->m_bmBall);
	radius = pDoc->m_sizeRadius;
	move = pDoc->m_sizeMove;

	total.cx = (radius.cx + ABS(move.cx)) << 1;
	total.cy = (radius.cy + ABS(move.cy)) << 1;
	pDoc->m_sizeTotal = total;

	if (pbmBall->m_hObject != NULL)
		pbmBall->DeleteObject();        //get rid of old bitmap

	CClientDC dc(this);
	CDC dcMem;
	dcMem.CreateCompatibleDC(&dc);

	pbmBall->CreateCompatibleBitmap(&dc, total.cx, total.cy);
	ASSERT(pbmBall->m_hObject != NULL);

	CBitmap* pOldBitmap = dcMem.SelectObject(pbmBall);

	// draw a rectangle in the background (window) color

	CRect rect(0, 0, total.cx, total.cy);
	CBrush brBackground(::GetSysColor(COLOR_WINDOW));
	dcMem.FillRect(rect, &brBackground);

	CBrush brCross(HS_DIAGCROSS, 0L);
	CBrush* pOldBrush = dcMem.SelectObject(&brCross);

	dcMem.SetBkColor(pDoc->m_clrBall);
	dcMem.Ellipse(ABS(move.cx), ABS(move.cy),
		total.cx - ABS(move.cx),
		total.cy - ABS(move.cy));

	dcMem.SelectObject(pOldBrush);
	dcMem.SelectObject(pOldBitmap);
	dcMem.DeleteDC();
}

void CBounceView::OnFast()
{
	CBounceDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	pDoc->m_bFastSpeed = TRUE;
	ChangeSpeed();
}

void CBounceView::OnSlow()
{
	CBounceDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	pDoc->m_bFastSpeed = FALSE;
	ChangeSpeed();
}

int CBounceView::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CView::OnCreate(lpCreateStruct) == -1)
		return -1;

	CBounceDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	if (!SetTimer(1, 100 /* start slow */, NULL))
	{
		MessageBox(_T("Not enough timers available for this window."),
				_T("MDI:Bounce"), MB_ICONEXCLAMATION | MB_OK);

		// signal creation failure...
		return -1;
	}

	// Get the aspect ratio of the device the ball will be drawn
	// on and then update the document data with the correct value.

	CDC* pDC = GetDC();
	CPoint aspect;
	aspect.x = pDC->GetDeviceCaps(ASPECTX);
	aspect.y = pDC->GetDeviceCaps(ASPECTY);
	ReleaseDC(pDC);
	pDoc->m_ptPixel = aspect;

	// Note that we could call MakeNewBall here (which should be called
	// whenever the ball's speed, color or size has been changed), but the
	// OnSize member function is always called after the OnCreate. Since
	// the OnSize member has to call MakeNewBall anyway, we don't here.

	return 0;
}

void CBounceView::OnSize(UINT nType, int cx, int cy)
{
	CView::OnSize(nType, cx, cy);

	CBounceDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	LONG lScale;
	CPoint center, ptPixel;

	center.x = cx >> 1;
	center.y = cy >> 1;
	center.x += cx >> 3; // make the ball a little off-center
	pDoc->m_ptCenter = center;

	CSize radius, move;

	// Because the window size has changed, re-calculate
	// the ball's dimensions.

	ptPixel = pDoc->m_ptPixel;

	lScale = min((LONG)cx * ptPixel.x,
		(LONG)cy * ptPixel.y) >> 4;

	radius.cx = (int)(lScale / ptPixel.x);
	radius.cy = (int)(lScale / ptPixel.y);
	pDoc->m_sizeRadius = radius;

	//Re-calculate the ball's rate of movement.

	move.cx = max(1, radius.cy >> 2);
	move.cy = max(1, radius.cy >> 2);
	pDoc->m_sizeMove = move;

	// Redraw ball.

	MakeNewBall();
}

void CBounceView::OnTimer(UINT nIDEvent)
{
	//Time to redraw the ball.

	CBounceDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	CBitmap* pbmBall;
	pbmBall = &(pDoc->m_bmBall);

	if (pbmBall->m_hObject == NULL)
		return;     // no bitmap for the ball

	// Get the current dimensions and create
	// a compatible DC to work with.

	CRect rcClient;
	GetClientRect(rcClient);

	CClientDC dc(this);
	CBitmap* pbmOld = NULL;

	CDC dcMem;
	dcMem.CreateCompatibleDC(&dc);
	pbmOld = dcMem.SelectObject(pbmBall);

	CPoint center;
	CSize total, move, radius;

	// Get the current dimensions and create
	// a compatible DC to work with.

	center = pDoc->m_ptCenter;
	radius = pDoc->m_sizeRadius;
	total = pDoc->m_sizeTotal;
	move = pDoc->m_sizeMove;

	// Now that the ball has been updated, draw it
	// by BitBlt'ing to the view.

	dc.BitBlt(center.x - total.cx / 2, center.y - total.cy / 2,
			total.cx, total.cy, &dcMem, 0, 0, SRCCOPY);

	// Move ball and check for collisions

	center += move;
	pDoc->m_ptCenter = center;

	if ((center.x + radius.cx >= rcClient.right) ||
		(center.x - radius.cx <= 0))
	{
		move.cx = -move.cx;
	}

	if ((center.y + radius.cy >= rcClient.bottom) ||
		(center.y - radius.cy <= 0))
	{
		move.cy = -move.cy;
	}
	pDoc->m_sizeMove = move;

	dcMem.SelectObject(pbmOld);
	dcMem.DeleteDC();
}

void CBounceView::OnUpdateFast(CCmdUI* pCmdUI)
{
	CBounceDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	pCmdUI->SetCheck(pDoc->m_bFastSpeed);

}

void CBounceView::OnUpdateSlow(CCmdUI* pCmdUI)
{
	CBounceDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	pCmdUI->SetCheck(!pDoc->m_bFastSpeed);
}

void CBounceView::OnCustomColor()
{
	CBounceDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	CColorDialog dlgColor(pDoc->m_clrBall);
	if (dlgColor.DoModal() == IDOK)
	{
		pDoc->SetCustomBallColor(dlgColor.GetColor());
		pDoc->ClearAllColors();
		pDoc->m_bCustom = TRUE;
		MakeNewBall();
	}
}

void CBounceView::OnUpdateCustom(CCmdUI* pCmdUI)
{
	CBounceDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	pCmdUI->SetCheck(pDoc->m_bCustom);
}

void CBounceView::MixColors()
{
// This function will take the current color selections, mix
// them, and use the result as the current color of the ball.

	CBounceDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	COLORREF tmpClr;
	int r, g, b;
	BOOL bSetColor;

	bSetColor = pDoc->m_bRed || pDoc->m_bGreen || pDoc->m_bBlue
		|| pDoc->m_bWhite || pDoc->m_bBlack;
	if(!bSetColor && pDoc->m_bCustom)
		return;

	r = g = b = 0;

	if(pDoc->m_bRed)
		r = 255;
	if(pDoc->m_bGreen)
		g = 255;
	if(pDoc->m_bBlue)
		b = 255;
	tmpClr = RGB(r, g, b);

// NOTE: Because a simple algorithm is used to mix colors
// if the current selection contains black or white, the
// result will be black or white; respectively. This is due
// to the additive method for mixing the colors

	if(pDoc->m_bWhite)
		tmpClr = RGB(255, 255, 255);

	if((pDoc->m_bBlack))
		tmpClr = RGB(0, 0, 0);

	// Once the color has been determined, update document
	// data, and force repaint of all views.

	if(!bSetColor)
		pDoc->m_bBlack = TRUE;
	 pDoc->m_clrBall = tmpClr;
	 pDoc->m_bCustom = FALSE;
	 MakeNewBall();
}
void CBounceView::OnUpdateBlack(CCmdUI* pCmdUI)
{
	CBounceDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	pCmdUI->SetCheck(pDoc->m_bBlack);
}

void CBounceView::OnUpdateWhite(CCmdUI* pCmdUI)
{
	CBounceDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	pCmdUI->SetCheck(pDoc->m_bWhite);
}

void CBounceView::OnUpdateBlue(CCmdUI* pCmdUI)
{
	CBounceDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	pCmdUI->SetCheck(pDoc->m_bBlue);
}

void CBounceView::OnUpdateGreen(CCmdUI* pCmdUI)
{
	CBounceDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	pCmdUI->SetCheck(pDoc->m_bGreen);
}

void CBounceView::OnUpdateRed(CCmdUI* pCmdUI)
{
	CBounceDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	pCmdUI->SetCheck(pDoc->m_bRed);
}

void CBounceView::OnColor()
{
	CBounceDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	UINT m_nIDColor;

	m_nIDColor = LOWORD(GetCurrentMessage()->wParam);

// Determines the color being modified
// and then updates the color state

	switch(m_nIDColor)
	{
	 case ID_BLACK:
		pDoc->ClearAllColors();
		pDoc->m_bBlack = !(pDoc->m_bBlack);
		break;
	 case ID_WHITE:
		pDoc->ClearAllColors();
		pDoc->m_bWhite = !(pDoc->m_bWhite);
		break;
	 case ID_RED:
		pDoc->m_bRed = !(pDoc->m_bRed);
		pDoc->m_bBlack = FALSE;
		pDoc->m_bWhite = FALSE;
		break;
	 case ID_GREEN:
		pDoc->m_bGreen = !(pDoc->m_bGreen);
		pDoc->m_bBlack = FALSE;
		pDoc->m_bWhite = FALSE;
		break;
	 case ID_BLUE:
		pDoc->m_bBlue = !(pDoc->m_bBlue);
		pDoc->m_bBlack = FALSE;
		pDoc->m_bWhite = FALSE;
		break;
	 default:
		 AfxMessageBox(IDS_UNKCOLOR);
		 return;
	}
	MixColors();
}

BOOL CBounceView::PreCreateWindow(CREATESTRUCT& cs)
{
	if (!CView::PreCreateWindow(cs))
		return FALSE;

	cs.lpszClass = AfxRegisterWndClass(CS_DBLCLKS | CS_HREDRAW | CS_VREDRAW,
			AfxGetApp()->LoadStandardCursor(IDC_SIZENS),
			(HBRUSH)(COLOR_WINDOW+1));

	if (cs.lpszClass != NULL)
		return TRUE;
	else
		return FALSE;
}

void CBounceView::OnInitialUpdate()
{
	CView::OnInitialUpdate();

	MixColors();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\mdidocvw\godot\bncdoc.h ===
// BounceDoc.h : header file
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CBounceDoc document

class CBounceDoc : public CDocument
{
protected:
	CBounceDoc();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CBounceDoc)

// Attributes
public:
	// bounce window client area and bouncing ball color/size parameters
	COLORREF m_clrBall;

	BOOL m_bFastSpeed;          // current speed

	CPoint m_ptPixel;           // pixel size
	CSize m_sizeRadius;         // radius of ball
	CSize m_sizeMove;           // move speed
	CSize m_sizeTotal;          // total size for ball bitmap
	CPoint m_ptCenter;          // current center for the ball

	//state of color buttons
	BOOL m_bBlack;
	BOOL m_bWhite;
	BOOL m_bBlue;
	BOOL m_bRed;
	BOOL m_bGreen;
	BOOL m_bCustom;

	// for replicating bouncing ball
	CBitmap m_bmBall;

// Operations
public:
	void SetCustomBallColor(COLORREF clr);
	void SetBallRadius(CSize radius);
	void ClearAllColors();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBounceDoc)
	public:
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
	protected:
	virtual BOOL OnNewDocument();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CBounceDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CBounceDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\mdidocvw\godot\bncvw.h ===
// BounceVw.h : header file
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CBounceView view

class CBounceView : public CView
{
protected:
	CBounceView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CBounceView)

// Attributes
public:

// Operations
public:
	void MakeNewBall();
	void ChangeSpeed();
	CBounceDoc* GetDocument();
	void MixColors();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBounceView)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CBounceView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CBounceView)
	afx_msg void OnCustomColor();
	afx_msg void OnFast();
	afx_msg void OnSlow();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnTimer(UINT nIDEvent);
	afx_msg void OnUpdateFast(CCmdUI* pCmdUI);
	afx_msg void OnUpdateSlow(CCmdUI* pCmdUI);
	afx_msg void OnUpdateCustom(CCmdUI* pCmdUI);
	afx_msg void OnUpdateBlack(CCmdUI* pCmdUI);
	afx_msg void OnUpdateBlue(CCmdUI* pCmdUI);
	afx_msg void OnUpdateGreen(CCmdUI* pCmdUI);
	afx_msg void OnUpdateRed(CCmdUI* pCmdUI);
	afx_msg void OnUpdateWhite(CCmdUI* pCmdUI);
	afx_msg void OnColor();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in HelloVw.cpp
inline CBounceDoc* CBounceView::GetDocument()
   { return (CBounceDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\mdidocvw\godot\bncfrm.cpp ===
// BncFrm.cpp : implementation file
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "MDI.h"
#include "BncFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBounceFrame

IMPLEMENT_DYNCREATE(CBounceFrame, CMDIChildWnd)

CBounceFrame::CBounceFrame()
{
}

CBounceFrame::~CBounceFrame()
{
}


BEGIN_MESSAGE_MAP(CBounceFrame, CMDIChildWnd)
	//{{AFX_MSG_MAP(CBounceFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CBounceFrame message handlers
BOOL CBounceFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	return CMDIChildWnd::PreCreateWindow(cs);
}

BOOL CBounceFrame::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CMDIFrameWnd* pParentWnd, CCreateContext* pContext)
{
	return CMDIChildWnd::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, pContext);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\mdidocvw\godot\hellofrm.cpp ===
// HelloFrm.cpp : implementation of the CHelloFrame class
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "MDI.h"

#include "HelloFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CHelloFrame

IMPLEMENT_DYNCREATE(CHelloFrame, CMDIChildWnd)

BEGIN_MESSAGE_MAP(CHelloFrame, CMDIChildWnd)
	//{{AFX_MSG_MAP(CHelloFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHelloFrame construction/destruction

CHelloFrame::CHelloFrame()
{
}

CHelloFrame::~CHelloFrame()
{
}

BOOL CHelloFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	return CMDIChildWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CHelloFrame diagnostics

#ifdef _DEBUG
void CHelloFrame::AssertValid() const
{
	CMDIChildWnd::AssertValid();
}

void CHelloFrame::Dump(CDumpContext& dc) const
{
	CMDIChildWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CHelloFrame message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\mdidocvw\godot\hellodoc.cpp ===
// HelloDoc.cpp : implementation of the CHelloDoc class
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "MDI.h"

#include "HelloDoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CHelloDoc

IMPLEMENT_DYNCREATE(CHelloDoc, CDocument)

BEGIN_MESSAGE_MAP(CHelloDoc, CDocument)
	//{{AFX_MSG_MAP(CHelloDoc)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHelloDoc construction/destruction

CHelloDoc::CHelloDoc()
{
}

CHelloDoc::~CHelloDoc()
{
}

BOOL CHelloDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;

// initialization of document's data

	m_clrText = RGB(0, 0, 255);
	m_str = _T("Hello, world!");

// initialization of button states for each color

	m_bBlue = 1;
	m_bBlack = 0;
	m_bGreen = 0;
	m_bRed = 0;
	m_bWhite = 0;
	m_bCustom = 0;

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CHelloDoc serialization

void CHelloDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
	}
	else
	{
	}
}

/////////////////////////////////////////////////////////////////////////////
// CHelloDoc diagnostics

#ifdef _DEBUG
void CHelloDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CHelloDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CHelloDoc commands

void CHelloDoc::SetStrColor(COLORREF clr)
{
	m_clrText = clr;
	UpdateAllViews(NULL);
}

void CHelloDoc::SetCustomStrColor(COLORREF clr)
{
	m_clrText = clr;
	UpdateAllViews(NULL);
}

void CHelloDoc::ClearAllColors()
{
	m_bBlack = m_bBlue = m_bRed = 0;
	m_bWhite = m_bGreen = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\mdidocvw\godot\hellodoc.h ===
// HelloDoc.h : interface of the CHelloDoc class
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////

class CHelloDoc : public CDocument
{
protected: // create from serialization only
	CHelloDoc();
	DECLARE_DYNCREATE(CHelloDoc)

// Attributes
public:
	// hello window color/text parameters
	COLORREF m_clrText;
	CString m_str;

	//state of color buttons
	BOOL m_bBlack;
	BOOL m_bRed;
	BOOL m_bBlue;
	BOOL m_bGreen;
	BOOL m_bWhite;
	BOOL m_bCustom;

// Operations
public:
	void ClearAllColors();  //resets all color states to NULL
	void SetStrColor(COLORREF clr);
	void SetCustomStrColor(COLORREF clr);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHelloDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CHelloDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CHelloDoc)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\mdidocvw\godot\bncfrm.h ===
// BncFrm.h : header file
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CBounceFrame frame

class CBounceFrame : public CMDIChildWnd
{
	DECLARE_DYNCREATE(CBounceFrame)
protected:
	CBounceFrame();           // protected constructor used by dynamic creation

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBounceFrame)
	public:
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_OVERLAPPEDWINDOW, const RECT& rect = rectDefault, CMDIFrameWnd* pParentWnd = NULL, CCreateContext* pContext = NULL);
	protected:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CBounceFrame();

	// Generated message map functions
	//{{AFX_MSG(CBounceFrame)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\mdidocvw\godot\mainfrm.cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


#include "stdafx.h"
#include "MDI.h"

#include "MainFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

static UINT indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (!m_wndToolBar.Create(this) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("Failed to create toolbar\n");
		return -1;      // fail to create
	}

// set button styles for colors to TBBS_CHECKBOX

	m_wndToolBar.SetButtonStyle(6, TBBS_CHECKBOX);
	m_wndToolBar.SetButtonStyle(7, TBBS_CHECKBOX);
	m_wndToolBar.SetButtonStyle(10, TBBS_CHECKBOX);
	m_wndToolBar.SetButtonStyle(11, TBBS_CHECKBOX);
	m_wndToolBar.SetButtonStyle(12, TBBS_CHECKBOX);

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}

	m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC);

	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);

// Add title for toolbar
	m_wndToolBar.SetWindowText(_T("Standard"));

	return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	return CMDIFrameWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CMDIFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CMDIFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\mdidocvw\godot\hellofrm.h ===
// HelloFrm.h : interface of the CHelloFrame class
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////

class CHelloFrame : public CMDIChildWnd
{
	DECLARE_DYNCREATE(CHelloFrame)
public:
	CHelloFrame();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHelloFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CHelloFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
	//{{AFX_MSG(CHelloFrame)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\mdidocvw\godot\hellovw.cpp ===
// HelloVw.cpp : implementation of the CHelloView class
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "MDI.h"

#include "HelloDoc.h"
#include "HelloVw.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CHelloView

IMPLEMENT_DYNCREATE(CHelloView, CView)

BEGIN_MESSAGE_MAP(CHelloView, CView)
	//{{AFX_MSG_MAP(CHelloView)
	ON_UPDATE_COMMAND_UI(ID_BLUE, OnUpdateBlue)
	ON_UPDATE_COMMAND_UI(ID_GREEN, OnUpdateGreen)
	ON_UPDATE_COMMAND_UI(ID_RED, OnUpdateRed)
	ON_UPDATE_COMMAND_UI(ID_WHITE, OnUpdateWhite)
	ON_UPDATE_COMMAND_UI(ID_BLACK, OnUpdateBlack)
	ON_COMMAND(ID_CUSTOM, OnCustom)
	ON_UPDATE_COMMAND_UI(ID_CUSTOM, OnUpdateCustom)
	ON_COMMAND(ID_BLACK, OnColor)
	ON_COMMAND(ID_BLUE, OnColor)
	ON_COMMAND(ID_GREEN, OnColor)
	ON_COMMAND(ID_RED, OnColor)
	ON_COMMAND(ID_WHITE, OnColor)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHelloView construction/destruction

CHelloView::CHelloView()
{
}

CHelloView::~CHelloView()
{
}

BOOL CHelloView::PreCreateWindow(CREATESTRUCT& cs)
{
	return CView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CHelloView drawing

void CHelloView::OnDraw(CDC* pDC)
{
	CHelloDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	CRect rect;
	COLORREF clr = pDoc->m_clrText;
	CString tmpStr = pDoc->m_str;

	pDC->SetTextColor(clr);
	pDC->SetBkColor(::GetSysColor(COLOR_WINDOW));
	GetClientRect(rect);
	pDC->DrawText(tmpStr, -1, rect,
		DT_SINGLELINE | DT_CENTER | DT_VCENTER);
}

/////////////////////////////////////////////////////////////////////////////
// CHelloView diagnostics

#ifdef _DEBUG
void CHelloView::AssertValid() const
{
	CView::AssertValid();
}

void CHelloView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}

CHelloDoc* CHelloView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CHelloDoc)));
	return (CHelloDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CHelloView message handlers

// Update handlers for each color
void CHelloView::OnUpdateBlue(CCmdUI* pCmdUI)
{
	CHelloDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	pCmdUI->SetCheck(pDoc->m_bBlue);
}

void CHelloView::OnUpdateGreen(CCmdUI* pCmdUI)
{
	CHelloDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	pCmdUI->SetCheck(pDoc->m_bGreen);
}

void CHelloView::OnUpdateRed(CCmdUI* pCmdUI)
{
	CHelloDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	pCmdUI->SetCheck(pDoc->m_bRed);
}

void CHelloView::OnUpdateWhite(CCmdUI* pCmdUI)
{
	CHelloDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	pCmdUI->SetCheck(pDoc->m_bWhite);
}

void CHelloView::OnUpdateBlack(CCmdUI* pCmdUI)
{
	CHelloDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	pCmdUI->SetCheck(pDoc->m_bBlack);
}

void CHelloView::MixColors()
{
	CHelloDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	COLORREF tmpClr;
	int r, g, b;
	BOOL bSetColor;

	// Determine which colors are currently chosen.

	bSetColor = pDoc->m_bRed || pDoc->m_bGreen || pDoc->m_bBlue
		|| pDoc->m_bWhite || pDoc->m_bBlack;

	// If the current color is custom, ignore mix request.

	if(!bSetColor && pDoc->m_bCustom)
		return;

	// Set color value to black and then add the necessary colors.

	r = g = b = 0;

	if(pDoc->m_bRed)
	 r = 255;
	if(pDoc->m_bGreen)
	 g = 255;
	if(pDoc->m_bBlue)
	 b = 255;
	tmpClr = RGB(r, g, b);

// NOTE: Because a simple algorithm is used to mix colors
// if the current selection contains black or white, the
// result will be black or white; respectively. This is due
// to the additive method for mixing the colors.

	if(pDoc->m_bBlack)
	 tmpClr = RGB(0, 0, 0);

	if(pDoc->m_bWhite)
	 tmpClr = RGB(255, 255, 255);

	// Once the color has been determined, update document
	// data, and force repaint of all views.

	if(!bSetColor)
		pDoc->m_bBlack = TRUE;
	pDoc->m_clrText = tmpClr;
	pDoc->m_bCustom = FALSE;
	pDoc->UpdateAllViews(NULL);
}

void CHelloView::OnCustom()
{
	CHelloDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	CColorDialog dlgColor(pDoc->m_clrText);
	if (dlgColor.DoModal() == IDOK)
	{
		pDoc->m_clrText = dlgColor.GetColor();
		pDoc->ClearAllColors();
		pDoc->m_bCustom = TRUE;
		pDoc->UpdateAllViews(NULL);
	}
}

void CHelloView::OnUpdateCustom(CCmdUI* pCmdUI)
{
	CHelloDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	pCmdUI->SetCheck(pDoc->m_bCustom);
}

void CHelloView::OnColor()
{
	CHelloDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	UINT m_nIDColor;

	m_nIDColor = LOWORD(GetCurrentMessage()->wParam);

// Determines the color being modified
// and then updates the color state

	switch(m_nIDColor)
	{
	 case ID_BLACK:
		pDoc->ClearAllColors();
		pDoc->m_bBlack = !(pDoc->m_bBlack);
		break;
	 case ID_WHITE:
		pDoc->ClearAllColors();
		pDoc->m_bWhite = !(pDoc->m_bWhite);
		break;
	 case ID_RED:
		pDoc->m_bRed = !(pDoc->m_bRed);
		pDoc->m_bBlack = FALSE;
		pDoc->m_bWhite = FALSE;
		break;
	 case ID_GREEN:
		pDoc->m_bGreen = !(pDoc->m_bGreen);
		pDoc->m_bBlack = FALSE;
		pDoc->m_bWhite = FALSE;
		break;
	 case ID_BLUE:
		pDoc->m_bBlue = !(pDoc->m_bBlue);
		pDoc->m_bBlack = FALSE;
		pDoc->m_bWhite = FALSE;
		break;
	 default:
		 AfxMessageBox(IDS_UNKCOLOR);
		 return;
	}
	MixColors();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\mdidocvw\godot\hellovw.h ===
// HelloVw.h : interface of the CHelloView class
//
/////////////////////////////////////////////////////////////////////////////


// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

class CHelloView : public CView
{
protected: // create from serialization only
	CHelloView();
	DECLARE_DYNCREATE(CHelloView)

// Attributes
public:
	CHelloDoc* GetDocument();

// Operations
public:
	void MixColors();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHelloView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CHelloView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CHelloView)
	afx_msg void OnUpdateBlue(CCmdUI* pCmdUI);
	afx_msg void OnUpdateGreen(CCmdUI* pCmdUI);
	afx_msg void OnUpdateRed(CCmdUI* pCmdUI);
	afx_msg void OnUpdateWhite(CCmdUI* pCmdUI);
	afx_msg void OnUpdateBlack(CCmdUI* pCmdUI);
	afx_msg void OnCustom();
	afx_msg void OnUpdateCustom(CCmdUI* pCmdUI);
	afx_msg void OnColor();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in HelloVw.cpp
inline CHelloDoc* CHelloView::GetDocument()
   { return (CHelloDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\mdidocvw\old\bncdoc.cpp ===
// BounceDoc.cpp : implementation file
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "MDI.h"
#include "BncDoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBounceDoc

IMPLEMENT_DYNCREATE(CBounceDoc, CDocument)

CBounceDoc::CBounceDoc()
{
}

BOOL CBounceDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;

	m_clrBall = RGB(0, 0, 255);
	m_bFastSpeed = FALSE;

	m_bBlue= 1;
	m_bWhite= m_bRed= 0;
	m_bGreen= m_bBlack= m_bCustom= 0;

	return TRUE;
}

CBounceDoc::~CBounceDoc()
{
}


BEGIN_MESSAGE_MAP(CBounceDoc, CDocument)
	//{{AFX_MSG_MAP(CBounceDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CBounceDoc diagnostics

#ifdef _DEBUG
void CBounceDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CBounceDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CBounceDoc serialization

void CBounceDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
	}
	else
	{
	}
}

/////////////////////////////////////////////////////////////////////////////
// CBounceDoc commands
void CBounceDoc::SetCustomBallColor(COLORREF clr)
{
	m_clrBall= clr;
	UpdateAllViews(NULL);
}

void CBounceDoc::SetBallRadius(CSize radius)
{
	m_sizeRadius= radius;
	UpdateAllViews(NULL);
}

void CBounceDoc::ClearAllColors()
{
	m_bBlack= m_bBlue= m_bRed= 0;
	m_bWhite= m_bGreen= m_bCustom= 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\mdidocvw\old\bncdoc.h ===
// BounceDoc.h : header file
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CBounceDoc document

class CBounceDoc : public CDocument
{
protected:
	CBounceDoc();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CBounceDoc)

// Attributes
public:
	// bounce window client area and bouncing ball color/size parameters
	COLORREF m_clrBall;

	BOOL m_bFastSpeed;          // current speed

	CPoint m_ptPixel;           // pixel size
	CSize m_sizeRadius;         // radius of ball
	CSize m_sizeMove;           // move speed
	CSize m_sizeTotal;          // total size for ball bitmap
	CPoint m_ptCenter;          // current center for the ball

	//state of color buttons
	BOOL m_bBlack;
	BOOL m_bWhite;
	BOOL m_bBlue;
	BOOL m_bRed;
	BOOL m_bGreen;
	BOOL m_bCustom;

	// for replicating bouncing ball
	CBitmap m_bmBall;

// Operations
public:
	void SetCustomBallColor(COLORREF clr);
	void SetBallRadius(CSize radius);
	void ClearAllColors();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBounceDoc)
	public:
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
	protected:
	virtual BOOL OnNewDocument();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CBounceDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CBounceDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\mdidocvw\old\bncfrm.cpp ===
// BncFrm.cpp : implementation file
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "MDI.h"
#include "BncFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBounceFrame

IMPLEMENT_DYNCREATE(CBounceFrame, CMDIChildWnd)

CBounceFrame::CBounceFrame()
{
}

CBounceFrame::~CBounceFrame()
{
}


BEGIN_MESSAGE_MAP(CBounceFrame, CMDIChildWnd)
	//{{AFX_MSG_MAP(CBounceFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CBounceFrame message handlers
BOOL CBounceFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	return CMDIChildWnd::PreCreateWindow(cs);
}

BOOL CBounceFrame::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CMDIFrameWnd* pParentWnd, CCreateContext* pContext)
{
	return CMDIChildWnd::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, pContext);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\mdidocvw\old\bncfrm.h ===
// BncFrm.h : header file
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CBounceFrame frame

class CBounceFrame : public CMDIChildWnd
{
	DECLARE_DYNCREATE(CBounceFrame)
protected:
	CBounceFrame();           // protected constructor used by dynamic creation

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBounceFrame)
	public:
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_OVERLAPPEDWINDOW, const RECT& rect = rectDefault, CMDIFrameWnd* pParentWnd = NULL, CCreateContext* pContext = NULL);
	protected:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CBounceFrame();

	// Generated message map functions
	//{{AFX_MSG(CBounceFrame)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\mdidocvw\godot\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MDI.rc
//
#define IDM_BOUNCE                      10
#define IDM_HELLO                       11
#define ID_BLACK                        20
#define IDM_BLACK                       20
#define ID_RED                          21
#define IDM_RED                         21
#define ID_GREEN                        22
#define IDM_GREEN                       22
#define ID_BLUE                         23
#define IDM_BLUE                        23
#define ID_WHITE                        24
#define IDM_WHITE                       24
#define ID_CUSTOM                       25
#define IDM_CUSTOM                      25
#define IDM_FAST                        30
#define IDM_SLOW                        31
#define IDD_ABOUTBOX                    100
#define IDR_MAINFRAME                   128
#define IDR_HELLOTYPE                   129
#define IDS_TIMER                       130
#define IDR_BOUNCETYPE                  31234
#define ID_FILE_NEWHELLO                32771
#define ID_FILE_NEWBOUNCE               32772
#define ID_SPEED_SLOW                   32778
#define ID_SPEED_FAST                   32779
#define IDS_NOHELLOTEMPLATE             32780
#define ID_FAST                         32781
#define IDS_NOBOUNCETEMPLATE            32781
#define IDS_STANDARD                    32782
#define ID_MIX                          32783
#define IDS_UNKCOLOR                    32784

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        131
#define _APS_NEXT_COMMAND_VALUE         32785
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\mdidocvw\godot\mdi.cpp ===
// MDI.cpp : Defines the class behaviors for the application.
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "MDI.h"

#include "MainFrm.h"
#include "HelloFrm.h"
#include "HelloDoc.h"
#include "HelloVw.h"

//Added for Bounce document
#include "BncFrm.h"
#include "BncDoc.h"
#include "BncVw.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMDIApp

BEGIN_MESSAGE_MAP(CMDIApp, CWinApp)
	//{{AFX_MSG_MAP(CMDIApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
	ON_COMMAND(ID_FILE_NEWHELLO, OnNewHello)
	ON_COMMAND(ID_FILE_NEWBOUNCE, OnNewBounce)
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMDIApp construction

CMDIApp::CMDIApp()
{
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CMDIApp object

CMDIApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CMDIApp initialization

BOOL CMDIApp::InitInstance()
{
	// Register the application's document templates.  Document templates
	// serve as the connection between documents, frame windows and views.

	CMultiDocTemplate* pDocTemplate;
	pDocTemplate = new CMultiDocTemplate(
		IDR_HELLOTYPE,
		RUNTIME_CLASS(CHelloDoc),
		RUNTIME_CLASS(CHelloFrame), // custom MDI child frame
		RUNTIME_CLASS(CHelloView));
	AddDocTemplate(pDocTemplate);

// Add Bounce template to list

	CMultiDocTemplate* pBounceTemplate;
	pBounceTemplate = new CMultiDocTemplate(
		IDR_BOUNCETYPE,
		RUNTIME_CLASS(CBounceDoc),
		RUNTIME_CLASS(CBounceFrame), // custom MDI child frame
		RUNTIME_CLASS(CBounceView));
	AddDocTemplate(pBounceTemplate);

	// create main MDI Frame window
	CMainFrame* pMainFrame = new CMainFrame;
	if (!pMainFrame->LoadFrame(IDR_MAINFRAME))
		return FALSE;
	m_pMainWnd = pMainFrame;

	// The main window has been initialized, so show and update it.
	pMainFrame->ShowWindow(m_nCmdShow);
	pMainFrame->UpdateWindow();

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CMDIApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// other globals

// Color array maps colors to top-level Color menu

COLORREF NEAR colorArray[] =
{
	RGB (0, 0, 0),
	RGB (255, 0, 0),
	RGB (0, 255, 0),
	RGB (0, 0, 255),
	RGB (255, 255, 255)
};
/////////////////////////////////////////////////////////////////////////////
// CMDIApp commands

// The following two command handlers provides an
// alternative way to open documents by hiding the fact
// that the application has multiple templates. The
// default method uses a dialog with a listing of
// possible types to choose from.

void CMDIApp::OnNewHello()
{

// Searches template list for a document type
// containing the "Hello" string

	POSITION curTemplatePos = GetFirstDocTemplatePosition();

	while(curTemplatePos != NULL)
	{
		CDocTemplate* curTemplate =
			GetNextDocTemplate(curTemplatePos);
		CString str;
		curTemplate->GetDocString(str, CDocTemplate::docName);
		if(str == _T("Hello"))
		{
			curTemplate->OpenDocumentFile(NULL);
			return;
		}
	}
	AfxMessageBox(IDS_NOHELLOTEMPLATE);
}

void CMDIApp::OnNewBounce()
{
// Searches template list for a document type
// containing the "Bounce" string

	POSITION curTemplatePos = GetFirstDocTemplatePosition();

	while(curTemplatePos != NULL)
	{
		CDocTemplate* curTemplate =
			GetNextDocTemplate(curTemplatePos);
		CString str;
		curTemplate->GetDocString(str, CDocTemplate::docName);
		if(str == _T("Bounce"))
		{
			curTemplate->OpenDocumentFile(NULL);
			return;
		}
	}
	AfxMessageBox(IDS_NOBOUNCETEMPLATE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\mdidocvw\godot\mdi.h ===
// MDI.h : main header file for the MDI application
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMDIApp:
// See MDI.cpp for the implementation of this class
//

class CMDIApp : public CWinApp
{
public:
	CMDIApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMDIApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CMDIApp)
	afx_msg void OnAppAbout();
	afx_msg void OnNewHello();
	afx_msg void OnNewBounce();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

extern COLORREF  colorArray[]; //used to store the 5 basic colors
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\mdidocvw\old\bncvw.h ===
// BounceVw.h : header file
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CBounceView view

class CBounceView : public CView
{
protected:
	CBounceView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CBounceView)

// Attributes
public:

// Operations
public:
	void MakeNewBall();
	void ChangeSpeed();
	CBounceDoc* GetDocument();
	void MixColors();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBounceView)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CBounceView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CBounceView)
	afx_msg void OnCustomColor();
	afx_msg void OnFast();
	afx_msg void OnSlow();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnTimer(UINT nIDEvent);
	afx_msg void OnUpdateFast(CCmdUI* pCmdUI);
	afx_msg void OnUpdateSlow(CCmdUI* pCmdUI);
	afx_msg void OnUpdateCustom(CCmdUI* pCmdUI);
	afx_msg void OnUpdateBlack(CCmdUI* pCmdUI);
	afx_msg void OnUpdateBlue(CCmdUI* pCmdUI);
	afx_msg void OnUpdateGreen(CCmdUI* pCmdUI);
	afx_msg void OnUpdateRed(CCmdUI* pCmdUI);
	afx_msg void OnUpdateWhite(CCmdUI* pCmdUI);
	afx_msg void OnColor();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in HelloVw.cpp
inline CBounceDoc* CBounceView::GetDocument()
   { return (CBounceDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\mdidocvw\old\hellodoc.cpp ===
// HelloDoc.cpp : implementation of the CHelloDoc class
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "MDI.h"

#include "HelloDoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CHelloDoc

IMPLEMENT_DYNCREATE(CHelloDoc, CDocument)

BEGIN_MESSAGE_MAP(CHelloDoc, CDocument)
	//{{AFX_MSG_MAP(CHelloDoc)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHelloDoc construction/destruction

CHelloDoc::CHelloDoc()
{
}

CHelloDoc::~CHelloDoc()
{
}

BOOL CHelloDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;

// initialization of document's data

	m_clrText = RGB(0, 0, 255);
	m_str = _T("Hello, world!");

// initialization of button states for each color

	m_bBlue = 1;
	m_bBlack = 0;
	m_bGreen = 0;
	m_bRed = 0;
	m_bWhite = 0;
	m_bCustom = 0;

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CHelloDoc serialization

void CHelloDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
	}
	else
	{
	}
}

/////////////////////////////////////////////////////////////////////////////
// CHelloDoc diagnostics

#ifdef _DEBUG
void CHelloDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CHelloDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CHelloDoc commands

void CHelloDoc::SetStrColor(COLORREF clr)
{
	m_clrText = clr;
	UpdateAllViews(NULL);
}

void CHelloDoc::SetCustomStrColor(COLORREF clr)
{
	m_clrText = clr;
	UpdateAllViews(NULL);
}

void CHelloDoc::ClearAllColors()
{
	m_bBlack = m_bBlue = m_bRed = 0;
	m_bWhite = m_bGreen = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\mdidocvw\old\hellodoc.h ===
// HelloDoc.h : interface of the CHelloDoc class
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////

class CHelloDoc : public CDocument
{
protected: // create from serialization only
	CHelloDoc();
	DECLARE_DYNCREATE(CHelloDoc)

// Attributes
public:
	// hello window color/text parameters
	COLORREF m_clrText;
	CString m_str;

	//state of color buttons
	BOOL m_bBlack;
	BOOL m_bRed;
	BOOL m_bBlue;
	BOOL m_bGreen;
	BOOL m_bWhite;
	BOOL m_bCustom;

// Operations
public:
	void ClearAllColors();  //resets all color states to NULL
	void SetStrColor(COLORREF clr);
	void SetCustomStrColor(COLORREF clr);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHelloDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CHelloDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CHelloDoc)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\mdidocvw\old\hellofrm.cpp ===
// HelloFrm.cpp : implementation of the CHelloFrame class
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "MDI.h"

#include "HelloFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CHelloFrame

IMPLEMENT_DYNCREATE(CHelloFrame, CMDIChildWnd)

BEGIN_MESSAGE_MAP(CHelloFrame, CMDIChildWnd)
	//{{AFX_MSG_MAP(CHelloFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHelloFrame construction/destruction

CHelloFrame::CHelloFrame()
{
}

CHelloFrame::~CHelloFrame()
{
}

BOOL CHelloFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	return CMDIChildWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CHelloFrame diagnostics

#ifdef _DEBUG
void CHelloFrame::AssertValid() const
{
	CMDIChildWnd::AssertValid();
}

void CHelloFrame::Dump(CDumpContext& dc) const
{
	CMDIChildWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CHelloFrame message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\mdidocvw\godot\mainfrm.h ===
// MainFrm.h : interface of the CMainFrame class
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////

class CMainFrame : public CMDIFrameWnd
{
	DECLARE_DYNAMIC(CMainFrame)
public:
	CMainFrame();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CStatusBar  m_wndStatusBar;
	CToolBar    m_wndToolBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\mdidocvw\old\hellofrm.h ===
// HelloFrm.h : interface of the CHelloFrame class
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////

class CHelloFrame : public CMDIChildWnd
{
	DECLARE_DYNCREATE(CHelloFrame)
public:
	CHelloFrame();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHelloFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CHelloFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
	//{{AFX_MSG(CHelloFrame)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\mdidocvw\old\hellovw.cpp ===
// HelloVw.cpp : implementation of the CHelloView class
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "MDI.h"

#include "HelloDoc.h"
#include "HelloVw.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CHelloView

IMPLEMENT_DYNCREATE(CHelloView, CView)

BEGIN_MESSAGE_MAP(CHelloView, CView)
	//{{AFX_MSG_MAP(CHelloView)
	ON_UPDATE_COMMAND_UI(ID_BLUE, OnUpdateBlue)
	ON_UPDATE_COMMAND_UI(ID_GREEN, OnUpdateGreen)
	ON_UPDATE_COMMAND_UI(ID_RED, OnUpdateRed)
	ON_UPDATE_COMMAND_UI(ID_WHITE, OnUpdateWhite)
	ON_UPDATE_COMMAND_UI(ID_BLACK, OnUpdateBlack)
	ON_COMMAND(ID_CUSTOM, OnCustom)
	ON_UPDATE_COMMAND_UI(ID_CUSTOM, OnUpdateCustom)
	ON_COMMAND(ID_BLACK, OnColor)
	ON_COMMAND(ID_BLUE, OnColor)
	ON_COMMAND(ID_GREEN, OnColor)
	ON_COMMAND(ID_RED, OnColor)
	ON_COMMAND(ID_WHITE, OnColor)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHelloView construction/destruction

CHelloView::CHelloView()
{
}

CHelloView::~CHelloView()
{
}

BOOL CHelloView::PreCreateWindow(CREATESTRUCT& cs)
{
	return CView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CHelloView drawing

void CHelloView::OnDraw(CDC* pDC)
{
	CHelloDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	CRect rect;
	COLORREF clr = pDoc->m_clrText;
	CString tmpStr = pDoc->m_str;

	pDC->SetTextColor(clr);
	pDC->SetBkColor(::GetSysColor(COLOR_WINDOW));
	GetClientRect(rect);
	pDC->DrawText(tmpStr, -1, rect,
		DT_SINGLELINE | DT_CENTER | DT_VCENTER);
}

/////////////////////////////////////////////////////////////////////////////
// CHelloView diagnostics

#ifdef _DEBUG
void CHelloView::AssertValid() const
{
	CView::AssertValid();
}

void CHelloView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}

CHelloDoc* CHelloView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CHelloDoc)));
	return (CHelloDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CHelloView message handlers

// Update handlers for each color
void CHelloView::OnUpdateBlue(CCmdUI* pCmdUI)
{
	CHelloDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	pCmdUI->SetCheck(pDoc->m_bBlue);
}

void CHelloView::OnUpdateGreen(CCmdUI* pCmdUI)
{
	CHelloDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	pCmdUI->SetCheck(pDoc->m_bGreen);
}

void CHelloView::OnUpdateRed(CCmdUI* pCmdUI)
{
	CHelloDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	pCmdUI->SetCheck(pDoc->m_bRed);
}

void CHelloView::OnUpdateWhite(CCmdUI* pCmdUI)
{
	CHelloDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	pCmdUI->SetCheck(pDoc->m_bWhite);
}

void CHelloView::OnUpdateBlack(CCmdUI* pCmdUI)
{
	CHelloDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	pCmdUI->SetCheck(pDoc->m_bBlack);
}

void CHelloView::MixColors()
{
	CHelloDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	COLORREF tmpClr;
	int r, g, b;
	BOOL bSetColor;

	// Determine which colors are currently chosen.

	bSetColor = pDoc->m_bRed || pDoc->m_bGreen || pDoc->m_bBlue
		|| pDoc->m_bWhite || pDoc->m_bBlack;

	// If the current color is custom, ignore mix request.

	if(!bSetColor && pDoc->m_bCustom)
		return;

	// Set color value to black and then add the necessary colors.

	r = g = b = 0;

	if(pDoc->m_bRed)
	 r = 255;
	if(pDoc->m_bGreen)
	 g = 255;
	if(pDoc->m_bBlue)
	 b = 255;
	tmpClr = RGB(r, g, b);

// NOTE: Because a simple algorithm is used to mix colors
// if the current selection contains black or white, the
// result will be black or white; respectively. This is due
// to the additive method for mixing the colors.

	if(pDoc->m_bBlack)
	 tmpClr = RGB(0, 0, 0);

	if(pDoc->m_bWhite)
	 tmpClr = RGB(255, 255, 255);

	// Once the color has been determined, update document
	// data, and force repaint of all views.

	if(!bSetColor)
		pDoc->m_bBlack = TRUE;
	pDoc->m_clrText = tmpClr;
	pDoc->m_bCustom = FALSE;
	pDoc->UpdateAllViews(NULL);
}

void CHelloView::OnCustom()
{
	CHelloDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	CColorDialog dlgColor(pDoc->m_clrText);
	if (dlgColor.DoModal() == IDOK)
	{
		pDoc->m_clrText = dlgColor.GetColor();
		pDoc->ClearAllColors();
		pDoc->m_bCustom = TRUE;
		pDoc->UpdateAllViews(NULL);
	}
}

void CHelloView::OnUpdateCustom(CCmdUI* pCmdUI)
{
	CHelloDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	pCmdUI->SetCheck(pDoc->m_bCustom);
}

void CHelloView::OnColor()
{
	CHelloDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	UINT m_nIDColor;

	m_nIDColor = LOWORD(GetCurrentMessage()->wParam);

// Determines the color being modified
// and then updates the color state

	switch(m_nIDColor)
	{
	 case ID_BLACK:
		pDoc->ClearAllColors();
		pDoc->m_bBlack = !(pDoc->m_bBlack);
		break;
	 case ID_WHITE:
		pDoc->ClearAllColors();
		pDoc->m_bWhite = !(pDoc->m_bWhite);
		break;
	 case ID_RED:
		pDoc->m_bRed = !(pDoc->m_bRed);
		pDoc->m_bBlack = FALSE;
		pDoc->m_bWhite = FALSE;
		break;
	 case ID_GREEN:
		pDoc->m_bGreen = !(pDoc->m_bGreen);
		pDoc->m_bBlack = FALSE;
		pDoc->m_bWhite = FALSE;
		break;
	 case ID_BLUE:
		pDoc->m_bBlue = !(pDoc->m_bBlue);
		pDoc->m_bBlack = FALSE;
		pDoc->m_bWhite = FALSE;
		break;
	 default:
		 AfxMessageBox(IDS_UNKCOLOR);
		 return;
	}
	MixColors();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\mdidocvw\old\mainfrm.cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


#include "stdafx.h"
#include "MDI.h"

#include "MainFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

static UINT indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (!m_wndToolBar.Create(this) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("Failed to create toolbar\n");
		return -1;      // fail to create
	}

// set button styles for colors to TBBS_CHECKBOX

	m_wndToolBar.SetButtonStyle(6, TBBS_CHECKBOX);
	m_wndToolBar.SetButtonStyle(7, TBBS_CHECKBOX);
	m_wndToolBar.SetButtonStyle(10, TBBS_CHECKBOX);
	m_wndToolBar.SetButtonStyle(11, TBBS_CHECKBOX);
	m_wndToolBar.SetButtonStyle(12, TBBS_CHECKBOX);

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}

	m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC);

	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);

// Add title for toolbar
	m_wndToolBar.SetWindowText(_T("Standard"));

	return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	return CMDIFrameWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CMDIFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CMDIFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\mdidocvw\old\hellovw.h ===
// HelloVw.h : interface of the CHelloView class
//
/////////////////////////////////////////////////////////////////////////////


// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

class CHelloView : public CView
{
protected: // create from serialization only
	CHelloView();
	DECLARE_DYNCREATE(CHelloView)

// Attributes
public:
	CHelloDoc* GetDocument();

// Operations
public:
	void MixColors();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHelloView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CHelloView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CHelloView)
	afx_msg void OnUpdateBlue(CCmdUI* pCmdUI);
	afx_msg void OnUpdateGreen(CCmdUI* pCmdUI);
	afx_msg void OnUpdateRed(CCmdUI* pCmdUI);
	afx_msg void OnUpdateWhite(CCmdUI* pCmdUI);
	afx_msg void OnUpdateBlack(CCmdUI* pCmdUI);
	afx_msg void OnCustom();
	afx_msg void OnUpdateCustom(CCmdUI* pCmdUI);
	afx_msg void OnColor();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in HelloVw.cpp
inline CHelloDoc* CHelloView::GetDocument()
   { return (CHelloDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\mdidocvw\old\mainfrm.h ===
// MainFrm.h : interface of the CMainFrame class
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////

class CMainFrame : public CMDIFrameWnd
{
	DECLARE_DYNAMIC(CMainFrame)
public:
	CMainFrame();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CStatusBar  m_wndStatusBar;
	CToolBar    m_wndToolBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\mdidocvw\old\mdi.cpp ===
// MDI.cpp : Defines the class behaviors for the application.
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "MDI.h"

#include "MainFrm.h"
#include "HelloFrm.h"
#include "HelloDoc.h"
#include "HelloVw.h"

//Added for Bounce document
#include "BncFrm.h"
#include "BncDoc.h"
#include "BncVw.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMDIApp

BEGIN_MESSAGE_MAP(CMDIApp, CWinApp)
	//{{AFX_MSG_MAP(CMDIApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
	ON_COMMAND(ID_FILE_NEWHELLO, OnNewHello)
	ON_COMMAND(ID_FILE_NEWBOUNCE, OnNewBounce)
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMDIApp construction

CMDIApp::CMDIApp()
{
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CMDIApp object

CMDIApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CMDIApp initialization

BOOL CMDIApp::InitInstance()
{
	// Register the application's document templates.  Document templates
	// serve as the connection between documents, frame windows and views.

	CMultiDocTemplate* pDocTemplate;
	pDocTemplate = new CMultiDocTemplate(
		IDR_HELLOTYPE,
		RUNTIME_CLASS(CHelloDoc),
		RUNTIME_CLASS(CHelloFrame), // custom MDI child frame
		RUNTIME_CLASS(CHelloView));
	AddDocTemplate(pDocTemplate);

// Add Bounce template to list

	CMultiDocTemplate* pBounceTemplate;
	pBounceTemplate = new CMultiDocTemplate(
		IDR_BOUNCETYPE,
		RUNTIME_CLASS(CBounceDoc),
		RUNTIME_CLASS(CBounceFrame), // custom MDI child frame
		RUNTIME_CLASS(CBounceView));
	AddDocTemplate(pBounceTemplate);

	// create main MDI Frame window
	CMainFrame* pMainFrame = new CMainFrame;
	if (!pMainFrame->LoadFrame(IDR_MAINFRAME))
		return FALSE;
	m_pMainWnd = pMainFrame;

	// The main window has been initialized, so show and update it.
	pMainFrame->ShowWindow(m_nCmdShow);
	pMainFrame->UpdateWindow();

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CMDIApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// other globals

// Color array maps colors to top-level Color menu

COLORREF NEAR colorArray[] =
{
	RGB (0, 0, 0),
	RGB (255, 0, 0),
	RGB (0, 255, 0),
	RGB (0, 0, 255),
	RGB (255, 255, 255)
};
/////////////////////////////////////////////////////////////////////////////
// CMDIApp commands

// The following two command handlers provides an
// alternative way to open documents by hiding the fact
// that the application has multiple templates. The
// default method uses a dialog with a listing of
// possible types to choose from.

void CMDIApp::OnNewHello()
{

// Searches template list for a document type
// containing the "Hello" string

	POSITION curTemplatePos = GetFirstDocTemplatePosition();

	while(curTemplatePos != NULL)
	{
		CDocTemplate* curTemplate =
			GetNextDocTemplate(curTemplatePos);
		CString str;
		curTemplate->GetDocString(str, CDocTemplate::docName);
		if(str == _T("Hello"))
		{
			curTemplate->OpenDocumentFile(NULL);
			return;
		}
	}
	AfxMessageBox(IDS_NOHELLOTEMPLATE);
}

void CMDIApp::OnNewBounce()
{
// Searches template list for a document type
// containing the "Bounce" string

	POSITION curTemplatePos = GetFirstDocTemplatePosition();

	while(curTemplatePos != NULL)
	{
		CDocTemplate* curTemplate =
			GetNextDocTemplate(curTemplatePos);
		CString str;
		curTemplate->GetDocString(str, CDocTemplate::docName);
		if(str == _T("Bounce"))
		{
			curTemplate->OpenDocumentFile(NULL);
			return;
		}
	}
	AfxMessageBox(IDS_NOBOUNCETEMPLATE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\mdidocvw\godot\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  MDI.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\mdidocvw\godot\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>         // MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\mdidocvw\old\mdi.h ===
// MDI.h : main header file for the MDI application
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMDIApp:
// See MDI.cpp for the implementation of this class
//

class CMDIApp : public CWinApp
{
public:
	CMDIApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMDIApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CMDIApp)
	afx_msg void OnAppAbout();
	afx_msg void OnNewHello();
	afx_msg void OnNewBounce();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

extern COLORREF  colorArray[]; //used to store the 5 basic colors
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\mdidocvw\old\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MDI.rc
//
#define IDM_BOUNCE                      10
#define IDM_HELLO                       11
#define ID_BLACK                        20
#define IDM_BLACK                       20
#define ID_RED                          21
#define IDM_RED                         21
#define ID_GREEN                        22
#define IDM_GREEN                       22
#define ID_BLUE                         23
#define IDM_BLUE                        23
#define ID_WHITE                        24
#define IDM_WHITE                       24
#define ID_CUSTOM                       25
#define IDM_CUSTOM                      25
#define IDM_FAST                        30
#define IDM_SLOW                        31
#define IDD_ABOUTBOX                    100
#define IDR_MAINFRAME                   128
#define IDR_HELLOTYPE                   129
#define IDS_TIMER                       130
#define IDR_BOUNCETYPE                  31234
#define ID_FILE_NEWHELLO                32771
#define ID_FILE_NEWBOUNCE               32772
#define ID_SPEED_SLOW                   32778
#define ID_SPEED_FAST                   32779
#define IDS_NOHELLOTEMPLATE             32780
#define ID_FAST                         32781
#define IDS_NOBOUNCETEMPLATE            32781
#define IDS_STANDARD                    32782
#define ID_MIX                          32783
#define IDS_UNKCOLOR                    32784

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        131
#define _APS_NEXT_COMMAND_VALUE         32785
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\mdidocvw\old\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>         // MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\mdidocvw\old\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  MDI.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\mdidocvw\old\bncvw.cpp ===
// BounceVw.cpp : implementation file
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "MDI.h"

#include "BncDoc.h"
#include "BncVw.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define ABS(x) ((x) < 0? -(x) : (x) > 0? (x) : 0)

/////////////////////////////////////////////////////////////////////////////
// CBounceView

IMPLEMENT_DYNCREATE(CBounceView, CView)

CBounceView::CBounceView()
{
}

CBounceView::~CBounceView()
{
}


BEGIN_MESSAGE_MAP(CBounceView, CView)
	//{{AFX_MSG_MAP(CBounceView)
	ON_COMMAND(ID_CUSTOM, OnCustomColor)
	ON_COMMAND(ID_SPEED_FAST, OnFast)
	ON_COMMAND(ID_SPEED_SLOW, OnSlow)
	ON_WM_CREATE()
	ON_WM_SIZE()
	ON_WM_TIMER()
	ON_UPDATE_COMMAND_UI(ID_SPEED_FAST, OnUpdateFast)
	ON_UPDATE_COMMAND_UI(ID_SPEED_SLOW, OnUpdateSlow)
	ON_UPDATE_COMMAND_UI(ID_CUSTOM, OnUpdateCustom)
	ON_UPDATE_COMMAND_UI(ID_BLACK, OnUpdateBlack)
	ON_UPDATE_COMMAND_UI(ID_BLUE, OnUpdateBlue)
	ON_UPDATE_COMMAND_UI(ID_GREEN, OnUpdateGreen)
	ON_UPDATE_COMMAND_UI(ID_RED, OnUpdateRed)
	ON_UPDATE_COMMAND_UI(ID_WHITE, OnUpdateWhite)
	ON_COMMAND(ID_BLACK, OnColor)
	ON_COMMAND(ID_BLUE, OnColor)
	ON_COMMAND(ID_GREEN, OnColor)
	ON_COMMAND(ID_RED, OnColor)
	ON_COMMAND(ID_WHITE, OnColor)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CBounceView drawing

void CBounceView::OnDraw(CDC* pDC)
{
	CDocument* pDoc = GetDocument();

// NOTE: Because the animation depends on timer events
// and resizing of the window, the rendering code is
// mostly found in the MakeNewBall function; called by handlers
// for WM_TIMER and WM_SIZE commands. These handlers make the code easier
// to read. However, the side-effect is that the ball will not be
// rendered when the document is printed because there is no rendering
// code in the OnDraw override.

}

/////////////////////////////////////////////////////////////////////////////
// CBounceView diagnostics

#ifdef _DEBUG
void CBounceView::AssertValid() const
{
	CView::AssertValid();
}

void CBounceView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}

CBounceDoc* CBounceView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CBounceDoc)));
	return (CBounceDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CBounceView message handlers

void CBounceView::ChangeSpeed()
{
	CBounceDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

// re-create the timer
	KillTimer(1);
	if (!SetTimer(1, pDoc->m_bFastSpeed ? 0 : 100, NULL))
	{
		AfxMessageBox(_T("Not enough timers available for this window"),
			MB_ICONEXCLAMATION | MB_OK);
		DestroyWindow();
	}
}

void CBounceView::MakeNewBall()
{

// Computes the attributes of the ball bitmap using
// aspect and window size

	CBounceDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	CSize radius, move, total;
	CBitmap* pbmBall;

	pbmBall = &(pDoc->m_bmBall);
	radius = pDoc->m_sizeRadius;
	move = pDoc->m_sizeMove;

	total.cx = (radius.cx + ABS(move.cx)) << 1;
	total.cy = (radius.cy + ABS(move.cy)) << 1;
	pDoc->m_sizeTotal = total;

	if (pbmBall->m_hObject != NULL)
		pbmBall->DeleteObject();        //get rid of old bitmap

	CClientDC dc(this);
	CDC dcMem;
	dcMem.CreateCompatibleDC(&dc);

	pbmBall->CreateCompatibleBitmap(&dc, total.cx, total.cy);
	ASSERT(pbmBall->m_hObject != NULL);

	CBitmap* pOldBitmap = dcMem.SelectObject(pbmBall);

	// draw a rectangle in the background (window) color

	CRect rect(0, 0, total.cx, total.cy);
	CBrush brBackground(::GetSysColor(COLOR_WINDOW));
	dcMem.FillRect(rect, &brBackground);

	CBrush brCross(HS_DIAGCROSS, 0L);
	CBrush* pOldBrush = dcMem.SelectObject(&brCross);

	dcMem.SetBkColor(pDoc->m_clrBall);
	dcMem.Ellipse(ABS(move.cx), ABS(move.cy),
		total.cx - ABS(move.cx),
		total.cy - ABS(move.cy));

	dcMem.SelectObject(pOldBrush);
	dcMem.SelectObject(pOldBitmap);
	dcMem.DeleteDC();
}

void CBounceView::OnFast()
{
	CBounceDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	pDoc->m_bFastSpeed = TRUE;
	ChangeSpeed();
}

void CBounceView::OnSlow()
{
	CBounceDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	pDoc->m_bFastSpeed = FALSE;
	ChangeSpeed();
}

int CBounceView::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CView::OnCreate(lpCreateStruct) == -1)
		return -1;

	CBounceDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	if (!SetTimer(1, 100 /* start slow */, NULL))
	{
		MessageBox(_T("Not enough timers available for this window."),
				_T("MDI:Bounce"), MB_ICONEXCLAMATION | MB_OK);

		// signal creation failure...
		return -1;
	}

	// Get the aspect ratio of the device the ball will be drawn
	// on and then update the document data with the correct value.

	CDC* pDC = GetDC();
	CPoint aspect;
	aspect.x = pDC->GetDeviceCaps(ASPECTX);
	aspect.y = pDC->GetDeviceCaps(ASPECTY);
	ReleaseDC(pDC);
	pDoc->m_ptPixel = aspect;

	// Note that we could call MakeNewBall here (which should be called
	// whenever the ball's speed, color or size has been changed), but the
	// OnSize member function is always called after the OnCreate. Since
	// the OnSize member has to call MakeNewBall anyway, we don't here.

	return 0;
}

void CBounceView::OnSize(UINT nType, int cx, int cy)
{
	CView::OnSize(nType, cx, cy);

	CBounceDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	LONG lScale;
	CPoint center, ptPixel;

	center.x = cx >> 1;
	center.y = cy >> 1;
	center.x += cx >> 3; // make the ball a little off-center
	pDoc->m_ptCenter = center;

	CSize radius, move;

	// Because the window size has changed, re-calculate
	// the ball's dimensions.

	ptPixel = pDoc->m_ptPixel;

	lScale = min((LONG)cx * ptPixel.x,
		(LONG)cy * ptPixel.y) >> 4;

	radius.cx = (int)(lScale / ptPixel.x);
	radius.cy = (int)(lScale / ptPixel.y);
	pDoc->m_sizeRadius = radius;

	//Re-calculate the ball's rate of movement.

	move.cx = max(1, radius.cy >> 2);
	move.cy = max(1, radius.cy >> 2);
	pDoc->m_sizeMove = move;

	// Redraw ball.

	MakeNewBall();
}

void CBounceView::OnTimer(UINT nIDEvent)
{
	//Time to redraw the ball.

	CBounceDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	CBitmap* pbmBall;
	pbmBall = &(pDoc->m_bmBall);

	if (pbmBall->m_hObject == NULL)
		return;     // no bitmap for the ball

	// Get the current dimensions and create
	// a compatible DC to work with.

	CRect rcClient;
	GetClientRect(rcClient);

	CClientDC dc(this);
	CBitmap* pbmOld = NULL;

	CDC dcMem;
	dcMem.CreateCompatibleDC(&dc);
	pbmOld = dcMem.SelectObject(pbmBall);

	CPoint center;
	CSize total, move, radius;

	// Get the current dimensions and create
	// a compatible DC to work with.

	center = pDoc->m_ptCenter;
	radius = pDoc->m_sizeRadius;
	total = pDoc->m_sizeTotal;
	move = pDoc->m_sizeMove;

	// Now that the ball has been updated, draw it
	// by BitBlt'ing to the view.

	dc.BitBlt(center.x - total.cx / 2, center.y - total.cy / 2,
			total.cx, total.cy, &dcMem, 0, 0, SRCCOPY);

	// Move ball and check for collisions

	center += move;
	pDoc->m_ptCenter = center;

	if ((center.x + radius.cx >= rcClient.right) ||
		(center.x - radius.cx <= 0))
	{
		move.cx = -move.cx;
	}

	if ((center.y + radius.cy >= rcClient.bottom) ||
		(center.y - radius.cy <= 0))
	{
		move.cy = -move.cy;
	}
	pDoc->m_sizeMove = move;

	dcMem.SelectObject(pbmOld);
	dcMem.DeleteDC();
}

void CBounceView::OnUpdateFast(CCmdUI* pCmdUI)
{
	CBounceDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	pCmdUI->SetCheck(pDoc->m_bFastSpeed);

}

void CBounceView::OnUpdateSlow(CCmdUI* pCmdUI)
{
	CBounceDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	pCmdUI->SetCheck(!pDoc->m_bFastSpeed);
}

void CBounceView::OnCustomColor()
{
	CBounceDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	CColorDialog dlgColor(pDoc->m_clrBall);
	if (dlgColor.DoModal() == IDOK)
	{
		pDoc->SetCustomBallColor(dlgColor.GetColor());
		pDoc->ClearAllColors();
		pDoc->m_bCustom = TRUE;
		MakeNewBall();
	}
}

void CBounceView::OnUpdateCustom(CCmdUI* pCmdUI)
{
	CBounceDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	pCmdUI->SetCheck(pDoc->m_bCustom);
}

void CBounceView::MixColors()
{
// This function will take the current color selections, mix
// them, and use the result as the current color of the ball.

	CBounceDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	COLORREF tmpClr;
	int r, g, b;
	BOOL bSetColor;

	bSetColor = pDoc->m_bRed || pDoc->m_bGreen || pDoc->m_bBlue
		|| pDoc->m_bWhite || pDoc->m_bBlack;
	if(!bSetColor && pDoc->m_bCustom)
		return;

	r = g = b = 0;

	if(pDoc->m_bRed)
		r = 255;
	if(pDoc->m_bGreen)
		g = 255;
	if(pDoc->m_bBlue)
		b = 255;
	tmpClr = RGB(r, g, b);

// NOTE: Because a simple algorithm is used to mix colors
// if the current selection contains black or white, the
// result will be black or white; respectively. This is due
// to the additive method for mixing the colors

	if(pDoc->m_bWhite)
		tmpClr = RGB(255, 255, 255);

	if((pDoc->m_bBlack))
		tmpClr = RGB(0, 0, 0);

	// Once the color has been determined, update document
	// data, and force repaint of all views.

	if(!bSetColor)
		pDoc->m_bBlack = TRUE;
	 pDoc->m_clrBall = tmpClr;
	 pDoc->m_bCustom = FALSE;
	 MakeNewBall();
}
void CBounceView::OnUpdateBlack(CCmdUI* pCmdUI)
{
	CBounceDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	pCmdUI->SetCheck(pDoc->m_bBlack);
}

void CBounceView::OnUpdateWhite(CCmdUI* pCmdUI)
{
	CBounceDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	pCmdUI->SetCheck(pDoc->m_bWhite);
}

void CBounceView::OnUpdateBlue(CCmdUI* pCmdUI)
{
	CBounceDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	pCmdUI->SetCheck(pDoc->m_bBlue);
}

void CBounceView::OnUpdateGreen(CCmdUI* pCmdUI)
{
	CBounceDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	pCmdUI->SetCheck(pDoc->m_bGreen);
}

void CBounceView::OnUpdateRed(CCmdUI* pCmdUI)
{
	CBounceDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	pCmdUI->SetCheck(pDoc->m_bRed);
}

void CBounceView::OnColor()
{
	CBounceDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	UINT m_nIDColor;

	m_nIDColor = LOWORD(GetCurrentMessage()->wParam);

// Determines the color being modified
// and then updates the color state

	switch(m_nIDColor)
	{
	 case ID_BLACK:
		pDoc->ClearAllColors();
		pDoc->m_bBlack = !(pDoc->m_bBlack);
		break;
	 case ID_WHITE:
		pDoc->ClearAllColors();
		pDoc->m_bWhite = !(pDoc->m_bWhite);
		break;
	 case ID_RED:
		pDoc->m_bRed = !(pDoc->m_bRed);
		pDoc->m_bBlack = FALSE;
		pDoc->m_bWhite = FALSE;
		break;
	 case ID_GREEN:
		pDoc->m_bGreen = !(pDoc->m_bGreen);
		pDoc->m_bBlack = FALSE;
		pDoc->m_bWhite = FALSE;
		break;
	 case ID_BLUE:
		pDoc->m_bBlue = !(pDoc->m_bBlue);
		pDoc->m_bBlack = FALSE;
		pDoc->m_bWhite = FALSE;
		break;
	 default:
		 AfxMessageBox(IDS_UNKCOLOR);
		 return;
	}
	MixColors();
}

BOOL CBounceView::PreCreateWindow(CREATESTRUCT& cs)
{
	if (!CView::PreCreateWindow(cs))
		return FALSE;

	cs.lpszClass = AfxRegisterWndClass(CS_DBLCLKS | CS_HREDRAW | CS_VREDRAW,
			AfxGetApp()->LoadStandardCursor(IDC_SIZENS),
			(HBRUSH)(COLOR_WINDOW+1));

	if (cs.lpszClass != NULL)
		return TRUE;
	else
		return FALSE;
}

void CBounceView::OnInitialUpdate()
{
	CView::OnInitialUpdate();

	MixColors();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\oclient\godot\frame.h ===
// frame.h : interface of the CMainFrame class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

class CMainFrame : public CMDIFrameWnd
{
	DECLARE_DYNAMIC(CMainFrame)
public:
	CMainFrame();

// Attributes
public:
	CPalette m_palette;

// Operations
public:
	BOOL SelectPalette(BOOL bBackground);

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Control bar embedded members
protected:
	CStatusBar  m_wndStatusBar;
	CToolBar    m_wndToolBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnWindowTileHorz();
	afx_msg void OnPaletteChanged(CWnd* pFocusWnd);
	afx_msg BOOL OnQueryNewPalette();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\oclient\godot\frame.cpp ===
// frame.cpp : implementation of the CMainFrame class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.



#include "stdafx.h"
#include "oclient.h"

#include "frame.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
	ON_WM_CREATE()
	ON_COMMAND(ID_WINDOW_TILE_HORZ, OnWindowTileHorz)
	ON_WM_PALETTECHANGED()
	ON_WM_QUERYNEWPALETTE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// arrays of IDs used to initialize control bars

// toolbar buttons - IDs are command buttons
static UINT BASED_CODE buttons[] =
{
	// same order as in the bitmap 'toolbar.bmp'
	ID_FILE_NEW,
	ID_FILE_OPEN,
	ID_FILE_SAVE,
		ID_SEPARATOR,
	ID_EDIT_CUT,
	ID_EDIT_COPY,
	ID_EDIT_PASTE,
		ID_SEPARATOR,
	ID_FILE_PRINT,
	ID_APP_ABOUT,
	ID_CONTEXT_HELP,
};

static UINT BASED_CODE indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};


/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (!m_wndToolBar.Create(this) ||
		!m_wndToolBar.LoadBitmap(IDR_MAINFRAME) ||
		!m_wndToolBar.SetButtons(buttons,
		  sizeof(buttons)/sizeof(UINT)))
	{
		TRACE0("Failed to create toolbar\n");
		return -1;      // fail to create
	}

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}
	EnableDocking(CBRS_ALIGN_ANY);
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);
	CDC* pDC = GetDC();
	m_palette.CreateHalftonePalette(pDC);
	ReleaseDC(pDC);
	return 0;
}

CMainFrame::~CMainFrame()
{
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CMDIFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CMDIFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame commands

void CMainFrame::OnWindowTileHorz()
{
	if (GetKeyState(VK_SHIFT) < 0)
		OnMDIWindowCmd(ID_WINDOW_TILE_VERT);
	else
		OnMDIWindowCmd(ID_WINDOW_TILE_HORZ);
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

void CMainFrame::OnPaletteChanged(CWnd* pFocusWnd)
{
	CMDIFrameWnd::OnPaletteChanged(pFocusWnd);
	if (pFocusWnd != this)
		SelectPalette(TRUE);
}

BOOL CMainFrame::OnQueryNewPalette()
{
	if (CMDIFrameWnd::OnQueryNewPalette())
		return TRUE;
	return SelectPalette(FALSE);
}

BOOL CMainFrame::SelectPalette(BOOL bBackground)
{
	if (m_palette.m_hObject == NULL)
		return FALSE;

	CDC* pDC = GetDC();
	CPalette* pOldPal = pDC->SelectPalette(&m_palette, bBackground);
	UINT nPalChg = pDC->RealizePalette();
	pDC->SelectPalette(pOldPal, TRUE); // background
	ReleaseDC(pDC);

	if (nPalChg > 0)
		InvalidateRect(NULL, TRUE);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\oclient\godot\mainview.cpp ===
// mainview.cpp : implementation of the CMainView class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


#include "stdafx.h"
#include "oclient.h"

#include "maindoc.h"
#include "mainview.h"
#include "rectitem.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainView

CBrush NEAR CMainView::m_brHatch;
CLIPFORMAT CMainView::m_cfObjectDescriptor=NULL;

IMPLEMENT_DYNCREATE(CMainView, CScrollView)

BEGIN_MESSAGE_MAP(CMainView, CScrollView)
	//{{AFX_MSG_MAP(CMainView)
	ON_COMMAND(ID_EDIT_PASTE, OnPaste)
	ON_COMMAND(ID_EDIT_PASTE_LINK, OnPasteLink)
	ON_COMMAND(ID_OLE_INSERT_NEW, OnInsertObject)
	ON_UPDATE_COMMAND_UI(ID_EDIT_CLEAR, OnUpdateEditMenu)
	ON_COMMAND(ID_EDIT_CLEAR, OnEditClear)
	ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
	ON_COMMAND(ID_EDIT_CUT, OnEditCut)
	ON_WM_LBUTTONDBLCLK()
	ON_WM_LBUTTONDOWN()
	ON_WM_SETCURSOR()
	ON_WM_RBUTTONDOWN()
	ON_WM_CHAR()
	ON_WM_SETFOCUS()
	ON_WM_CREATE()
	ON_WM_SIZE()
	ON_COMMAND(ID_OBJECT_DISPLAYCONTENT, OnObjectDisplayContent)
	ON_UPDATE_COMMAND_UI(ID_OBJECT_DISPLAYCONTENT, OnUpdateObjectDisplayContent)
	ON_COMMAND(ID_OBJECT_DISPLAYASICON, OnObjectDisplayAsIcon)
	ON_UPDATE_COMMAND_UI(ID_OBJECT_DISPLAYASICON, OnUpdateObjectDisplayAsIcon)
	ON_COMMAND(ID_EDIT_PASTE_SPECIAL, OnPasteSpecial)
	ON_UPDATE_COMMAND_UI(ID_EDIT_CLONE, OnUpdateEditClone)
	ON_COMMAND(ID_EDIT_CLONE, OnEditClone)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE_SPECIAL, OnUpdateEditPaste)
	ON_COMMAND(ID_OBJECT_RESETSIZE, OnObjectResetsize)
	ON_COMMAND(ID_CANCEL_INPLACE, OnCancelInplace)
	ON_WM_DESTROY()
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, OnUpdateEditPaste)
	ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateEditMenu)
	ON_UPDATE_COMMAND_UI(ID_EDIT_CUT, OnUpdateEditMenu)
	ON_UPDATE_COMMAND_UI(ID_OBJECT_RESETSIZE, OnUpdateEditMenu)
	ON_COMMAND(ID_OLE_CHANGE_SOURCE, OnOleChangeSource)
	ON_UPDATE_COMMAND_UI(ID_OLE_CHANGE_SOURCE, OnUpdateOleChangeSource)
	ON_COMMAND(ID_OLE_EDIT_PROPERTIES, OnOleEditProperties)
	ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_PROPERTIES, OnUpdateOleEditProperties)
	//}}AFX_MSG_MAP
	// Standard printing commands
	ON_COMMAND(ID_FILE_PRINT, CScrollView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, CScrollView::OnFilePrintPreview)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMainView construction/destruction

CMainView::CMainView()
{
	if (m_brHatch.m_hObject == NULL)
		m_brHatch.CreateHatchBrush(HS_DIAGCROSS, RGB(0,0,0));
	if (m_cfObjectDescriptor == NULL)
		m_cfObjectDescriptor =
			(CLIPFORMAT)::RegisterClipboardFormat(_T("Object Descriptor"));

	m_pSelection = NULL;
	m_prevDropEffect = DROPEFFECT_NONE;
	m_bInDrag = FALSE;
}

CMainView::~CMainView()
{
}

void CMainView::OnInitialUpdate()
{
	CScrollView::OnInitialUpdate();

	// We can't pass MM_ANISOTROPIC to SetScrollSizes so we have to convert to MM_TEXT
	CSize size = GetDocument()->GetDocumentSize();
	CClientDC dc(NULL);
	size.cx = MulDiv(size.cx, dc.GetDeviceCaps(LOGPIXELSX), 100);
	size.cy = MulDiv(size.cy, dc.GetDeviceCaps(LOGPIXELSY), 100);
	SetScrollSizes(MM_TEXT, size);
}

/////////////////////////////////////////////////////////////////////////////
// CMainView drawing

void CMainView::OnPrepareDC(CDC* pDC, CPrintInfo* pInfo)
{
	CScrollView::OnPrepareDC(pDC, pInfo);
	// set up a reasonable default context
	pDC->SetTextColor(::GetSysColor(COLOR_WINDOWTEXT));
	pDC->SetBkColor(::GetSysColor(COLOR_WINDOW));

	// LOENGLISH units are based on physical inches
	// We want logical inches so we have to do it differently
	pDC->SetMapMode(MM_ANISOTROPIC);
	pDC->SetViewportExt(
		pDC->GetDeviceCaps(LOGPIXELSX), pDC->GetDeviceCaps(LOGPIXELSY));
	pDC->SetWindowExt(100,-100);
}

void CMainView::SetupTracker(CRectTracker* pTracker, CRectItem* pItem,
	CRect* pTrueRect)
{
	ASSERT(pTracker != NULL);
	ASSERT(pItem != NULL);

	pTracker->m_rect = pItem->GetRect();
	DocToClient(pTracker->m_rect);

	// set minimum size for our OLE items
	pTracker->m_sizeMin.cx = 8;
	pTracker->m_sizeMin.cy = 8;

	pTracker->m_nStyle = 0;

	// setup resize handles if item is selected
	if (pItem == m_pSelection)
		pTracker->m_nStyle |= CRectTracker::resizeInside;

	// put correct border depending on item type
	if (pItem->GetType() == OT_LINK)
		pTracker->m_nStyle |= CRectTracker::dottedLine;
	else
		pTracker->m_nStyle |= CRectTracker::solidLine;

	// put hatching over the item if it is currently open
	if (pItem->GetItemState() == COleClientItem::openState ||
		pItem->GetItemState() == COleClientItem::activeUIState)
	{
		pTracker->m_nStyle |= CRectTracker::hatchInside;
	}

	if (pTrueRect != NULL)
		pTracker->GetTrueRect(pTrueRect);
}

void CMainView::OnDraw(CDC* pDC)
{
	CMainDoc* pDoc = GetDocument();

	ASSERT_VALID(pDC);

	if (!pDC->IsPrinting())
	{
		m_brHatch.UnrealizeObject();
		CPoint point(0, 0);
		pDC->LPtoDP(&point);
		pDC->SetBrushOrg(point.x % 8, point.y % 8);

		CRect rcClip;
		GetClientRect(&rcClip);
		ClientToDoc(rcClip);
		CSize docSize = pDoc->GetDocumentSize();
		if (rcClip.right > docSize.cx)
		{
			CRect rcFill(rcClip);
			rcFill.left = max(rcFill.left,docSize.cx);
			pDC->FillRect(rcFill,&m_brHatch);
		}
		if (rcClip.bottom < -docSize.cy)
		{
			CRect rcFill(rcClip);
			rcFill.top = min(rcFill.top, -docSize.cy);
			pDC->FillRect(rcFill,&m_brHatch);
		}
	}

	// Draw all the CRectItems
	POSITION pos = pDoc->GetStartPosition();
	while (pos != NULL)
	{
		CRectItem* pItem = DYNAMIC_DOWNCAST(CRectItem, pDoc->GetNextItem(pos));
		if (pItem != NULL)
		{
			pItem->Draw(pDC, pItem->GetRect());

			if (!pDC->IsPrinting())
			{
				// draw the tracker
				CRectTracker tracker;
				CRect rectTrue;
				SetupTracker(&tracker, pItem, &rectTrue);
				ClientToDoc(rectTrue);
				if (pDC->RectVisible(&rectTrue))
					tracker.Draw(pDC);
			}
		}
	}
}

// pHint is the deleted item or NULL if deselect/delete all
void CMainView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint)
{
	if (pHint == NULL && lHint == 0)
	{
		// some sort of clear all
		m_pSelection = NULL;
	}

	if (pHint != NULL && pHint->IsKindOf(RUNTIME_CLASS(CRectItem)))
	{
		// just invalidate the one item
		InvalidateItem((CRectItem*)pHint);

		// clear selection if pointing to deleted item
		if (lHint == 1 && pHint == m_pSelection)
		{
			// specific case of pHint being deleted
			m_pSelection = NULL;
		}
	}
	else if (lHint != 0)
	{
		// invalidate arbitrary rectangle
		InvalidateRect((CRect*)lHint);
	}
	else
	{
		// complete update
		CScrollView::OnUpdate(pSender, lHint, pHint);
	}
}

void CMainView::InvalidateItem(CRectItem* pItem)
{
	if (m_nMapMode != 0)
	{
		CRectTracker tracker;
		CRect rect;
		SetupTracker(&tracker, pItem, &rect);
		InvalidateRect(&rect);
	}
}

BOOL CMainView::OnScrollBy(CSize sizeScroll, BOOL bDoScroll)
{
	// remove drag/drop feedback before scrolling
	if (bDoScroll && m_prevDropEffect != DROPEFFECT_NONE)
	{
		CClientDC dc(this);
		dc.DrawFocusRect(CRect(m_dragPoint, m_dragSize));
			// erase previous focus rect
		m_prevDropEffect = DROPEFFECT_NONE;
	}

	// do the scroll
	if (!CScrollView::OnScrollBy(sizeScroll, bDoScroll))
		return FALSE;

	// update the position of any in-place active item
	if (bDoScroll)
	{
		UpdateActiveItem();
		UpdateWindow();
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMainView printing

BOOL CMainView::OnPreparePrinting(CPrintInfo* pInfo)
{
	// default preparation
	return DoPreparePrinting(pInfo);
}

/////////////////////////////////////////////////////////////////////////////
// Selection support

BOOL CMainView::IsSelected(const CObject* pDocItem) const
{
	return (pDocItem == m_pSelection);
}

void CMainView::SetSelection(CRectItem* pNewSel, BOOL bSafeSelect)
{
	if (pNewSel != NULL && pNewSel == m_pSelection)
		return;

	// deactivate any in-place active item on this view!
	COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
	if (pActiveItem != NULL && pNewSel != pActiveItem)
	{
		if (bSafeSelect)
			return;
		// if we found one, deactivate it
		pActiveItem->Close();
		ASSERT(GetDocument()->GetInPlaceActiveItem(this) == NULL);
	}
	if (m_pSelection != NULL) // invalidate the old item
		InvalidateItem(m_pSelection);
	if ((m_pSelection = pNewSel) != NULL) // invalidate the new item
		InvalidateItem(m_pSelection);
}

/////////////////////////////////////////////////////////////////////////////
// CMainView diagnostics

#ifdef _DEBUG
void CMainView::AssertValid() const
{
	CScrollView::AssertValid();
}

void CMainView::Dump(CDumpContext& dc) const
{
	CScrollView::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// Main 'Edit' menu commands

void CMainView::OnUpdateEditMenu(CCmdUI* pCmdUI)
{
	// most Edit menu commands are enabled only if we have a selection
	//  and there are no in-place activations for this view
	pCmdUI->Enable(m_pSelection != NULL &&
		GetDocument()->GetInPlaceActiveItem(this) == NULL);
}

void CMainView::OnEditCut()
{
	ASSERT(m_pSelection != NULL);
	TRY
	{
		m_pSelection->CopyToClipboard(TRUE);
		OnEditClear();
	}
	CATCH_ALL(e)
	{
		AfxMessageBox(IDP_CLIPBOARD_CUT_FAILED);
	}
	END_CATCH_ALL
}

void CMainView::OnEditCopy()
{
	ASSERT(m_pSelection != NULL);
	TRY
	{
		m_pSelection->CopyToClipboard(TRUE);
	}
	CATCH_ALL(e)
	{
		AfxMessageBox(IDP_CLIPBOARD_COPY_FAILED);
	}
	END_CATCH_ALL
}

void CMainView::OnEditClear()
{
	if (m_pSelection != NULL)
		GetDocument()->DeleteItem(m_pSelection);
}

void CMainView::OnPaste()
{
	if (DoPasteItem(FALSE, NULL, NULL) == NULL)
		AfxMessageBox(IDP_GET_FROM_CLIPBOARD_FAILED);
}

void CMainView::OnPasteLink()
{
	if (DoPasteItem(TRUE, NULL, NULL) == NULL)
		AfxMessageBox(IDP_GET_FROM_CLIPBOARD_FAILED);
}

void CMainView::DoPasteNative(
	COleDataObject* pDataObject, CPoint* pPoint, CRectItem* pItem)
{
	// get file refering to clipboard data
	CFile* pFile = pDataObject->GetFileData(CMainDoc::m_cfPrivate);
	if (pFile == NULL)
		{
		// if the file failed to open, throw an exception
		// to force cleanup in DoPasteItem.  the exact
		// type of exception thrown here is unimportant...

		AfxThrowFileException(CFileException::generic);
		}

	CArchive ar(pFile, CArchive::load);
	TRY
	{
		// connect the file to an archive and read the data
		ar.m_pDocument = GetDocument(); // for COleClientItem serialize
		pItem->Serialize(ar);
	}
	CATCH_ALL(e)
	{
		ar.Close();
		delete pFile;
		THROW_LAST();
	}
	END_CATCH_ALL

	ar.Close();
	delete pFile;

	// adjust position to that specified by point
	if (pPoint != NULL)
		pItem->m_ptPos = *pPoint;
}

void CMainView::DoPasteStandard(BOOL bLink, COleDataObject* pDataObject,
	CPoint* pPoint, CRectItem* pItem, CLIPFORMAT cfFormat)
{
	if (bLink)      // paste link
	{
		if (!pItem->CreateLinkFromData(pDataObject))
			AfxThrowMemoryException();  // any exception will do
	}
	// paste embedded
	else if (!pItem->CreateFromData(pDataObject) &&
		!pItem->CreateStaticFromData(pDataObject, OLERENDER_DRAW, cfFormat))
	{
		AfxThrowMemoryException();      // any exception will do
	}

	// copy the current iconic representation
	FORMATETC fmtetc;
	fmtetc.cfFormat = CF_METAFILEPICT;
	fmtetc.dwAspect = DVASPECT_ICON;
	fmtetc.ptd = NULL;
	fmtetc.tymed = TYMED_MFPICT;
	fmtetc.lindex = 1;
	HGLOBAL hObj = pDataObject->GetGlobalData(CF_METAFILEPICT, &fmtetc);
	if (hObj != NULL)
	{
		pItem->SetIconicMetafile(hObj);
		// the following code is an easy way to free a metafile pict
		STGMEDIUM stgMed;
		memset(&stgMed, 0, sizeof(stgMed));
		stgMed.tymed = TYMED_MFPICT;
		stgMed.hGlobal = hObj;
		ReleaseStgMedium(&stgMed);
	}

	// set the current drawing aspect
	hObj = pDataObject->GetGlobalData(m_cfObjectDescriptor);
	if (hObj != NULL)
	{
		ASSERT(hObj != NULL);
		// got CF_OBJECTDESCRIPTOR ok.  Lock it down and extract size.
		LPOBJECTDESCRIPTOR pObjDesc = (LPOBJECTDESCRIPTOR)GlobalLock(hObj);
		ASSERT(pObjDesc != NULL);
		pItem->SetDrawAspect((DVASPECT)pObjDesc->dwDrawAspect);
		GlobalUnlock(hObj);
		GlobalFree(hObj);
	}

	// set top-left based on point of drop
	if (pPoint != NULL)
		pItem->m_ptPos = *pPoint;

	// get size from drag/drop operation
	CSize size;
	if (GetObjectInfo(pDataObject, &size, NULL) && size.cx != 0 && size.cy != 0)
	{
		// use size obtained from object instead of default
		size.cx = MulDiv(size.cx, 10, 254);
		size.cy = -MulDiv(size.cy, 10, 254);
		pItem->SetSize(size);
		CSize sizeExtent;
		pItem->GetCachedExtent(&sizeExtent);
		pItem->SetBaseSize(sizeExtent);
	}
	else
	{
		// no extent from CF_OBJECTDESCRIPTOR, use extent from object
		pItem->UpdateExtent();
	}
}


// Helper for paste/pastelink
//
//                  bLink       pDataObject     pPoint              cfFormat
//  EditPaste       FALSE       NULL(clipboard) NULL(default)       0
//  Drag/Drop       TRUE/FALSE  X               X                   0
//  PasteLink       TRUE        NULL(clipboard) NULL(default)       0
//  PasteSpecial    TRUE/FALSE  X               NULL(default)       X
CRectItem* CMainView::DoPasteItem(BOOL bLink, COleDataObject* pDataObject,
	CPoint* pPoint, CLIPFORMAT cfFormat)
{
	BeginWaitCursor();

	CRectItem* pItem = GetDocument()->CreateItem();
	ASSERT_VALID(pItem);
	BOOL bAllowAdjust = (pPoint == NULL) ? TRUE : FALSE;

	// use clipboard data if not doing drag/drop
	COleDataObject clipboardData;
	if (pDataObject == NULL)
	{
		clipboardData.AttachClipboard();
		pDataObject = &clipboardData;
	}

	TRY
	{
		if (cfFormat == CMainDoc::m_cfPrivate)
		{
			// if format specified (i.e. PasteSpecial) then use that one
			DoPasteNative(pDataObject, pPoint, pItem);
		}
		else if (!bLink && cfFormat == 0 &&
			pDataObject->IsDataAvailable(CMainDoc::m_cfPrivate))
		{
			// if we're not pasting a link, cfFormat was unspecified,
			// and private format is available use it
			DoPasteNative(pDataObject, pPoint, pItem);
		}
		// otherwise perform a standard paste
		else if (bAllowAdjust)
		{
			CPoint ptDef(10, -10);
			DoPasteStandard(bLink, pDataObject, &ptDef, pItem, cfFormat);
		}
		else
		{
			DoPasteStandard(bLink, pDataObject, pPoint, pItem, cfFormat);
		}

		if (bAllowAdjust)
		{
			// allow document to adjust position of item so that it doesn't
			// lay directly over an item of the same size
			// this only occurs if the drop point is not specified
			GetDocument()->AdjustItemPosition(pItem);
		}
	}
	CATCH_ALL(e)
	{
		// general cleanup
		TRACE0("failed to embed/link an OLE object\n");
		pItem->Delete();
		pItem = NULL;
	}
	END_CATCH_ALL

	// set the selection with bSafeSelect = TRUE
	SetSelection(pItem, TRUE);

	// update the document and views
	GetDocument()->SetModifiedFlag();
	GetDocument()->UpdateAllViews(NULL, 0, pItem);      // including this view

	EndWaitCursor();

	return pItem;
}

/////////////////////////////////////////////////////////////////////////////
// Insert New Object and Activate Object

void CMainView::OnInsertObject()
{
	COleInsertDialog dlg;
	if (dlg.DoModal() != IDOK)
		return;

	BeginWaitCursor();

	CRectItem* pItem = NULL;
	TRY
	{
		// create item from dialog results
		pItem = GetDocument()->CreateItem();
		if (!dlg.CreateItem(pItem))
			AfxThrowMemoryException();  // any exception will do

		// try to get initial presentation data
		pItem->UpdateLink();
		pItem->UpdateExtent();

		// if insert new object -- initially show the object
		if (dlg.GetSelectionType() == COleInsertDialog::createNewItem)
			pItem->DoVerb(OLEIVERB_SHOW, this);

		SetSelection(pItem);
	}
	CATCH_ALL(e)
	{
		// cleanup item, if allocated
		if (pItem != NULL)
			GetDocument()->DeleteItem(pItem);

		AfxMessageBox(IDP_FAILED_TO_CREATE);
	}
	END_CATCH_ALL

	EndWaitCursor();
}

void CMainView::OnLButtonDblClk(UINT, CPoint)
{
	// Double click will activate the main verb
	if (m_pSelection != NULL)
	{
		BeginWaitCursor();
		LONG iVerb = OLEIVERB_PRIMARY;
		if (GetKeyState(VK_CONTROL) < 0)
			iVerb = OLEIVERB_OPEN;
		m_pSelection->DoVerb(iVerb, this);
		EndWaitCursor();
	}
}

/////////////////////////////////////////////////////////////////////////////
// Hit detection, moving and resizing items

CRectItem* CMainView::GetHitItem(CPoint point)
{
	CMainDoc* pDoc = GetDocument();
	CRectItem* pItemHit = NULL;

	// Find the item hit by the mouse
	POSITION pos = pDoc->GetStartPosition();
	while (pos != NULL)
	{
		CRectItem* pItem = DYNAMIC_DOWNCAST(CRectItem, pDoc->GetNextItem(pos));
		if (pItem != NULL)
		{
			CRectTracker tracker;
			SetupTracker(&tracker, pItem);
			if (tracker.HitTest(point) >= 0)
			{
				pItemHit = pItem;
				// items later in the list are drawn on top - so keep looking
			}
		}
	}
	return pItemHit;
}

void CMainView::DocToClient(CRect& rect)
{
	CClientDC dc(this);
	OnPrepareDC(&dc);
	dc.LPtoDP(&rect); // convert logical rect to device rect
	rect.NormalizeRect();
}

void CMainView::ClientToDoc(CRect& rect)
{
	CClientDC dc(this);
	OnPrepareDC(&dc);
	dc.DPtoLP(&rect); // convert device rect to logical rect
}

void CMainView::DocToClient(CSize& size)
{
	CClientDC dc(this);
	OnPrepareDC(&dc);
	dc.LPtoDP(&size); // convert logical size to device size
	size.cx = abs(size.cx);
	size.cy = abs(size.cy);
}

void CMainView::ClientToDoc(CSize& size)
{
	CClientDC dc(this);
	OnPrepareDC(&dc);
	dc.DPtoLP(&size); // convert device rect to logical rect
	size.cx = abs(size.cx);
	size.cy = abs(size.cy);
}

void CMainView::DocToClient(CPoint& point)
{
	CClientDC dc(this);
	OnPrepareDC(&dc);
	dc.LPtoDP(&point); // convert logical point to device point
}

void CMainView::ClientToDoc(CPoint& point)
{
	CClientDC dc(this);
	OnPrepareDC(&dc);
	dc.DPtoLP(&point); // convert device point to logical point
}

void CMainView::OnLButtonDown(UINT /*nFlags*/, CPoint point)
{
	CRectItem* pItemHit = GetHitItem(point);
	SetSelection(pItemHit);
	if (pItemHit == NULL)
		return;

	CRect rectLimit;
	GetClientRect(rectLimit);

	CRectTracker tracker;
	SetupTracker(&tracker, pItemHit);

	UpdateWindow(); // update before entering the tracker
	if (tracker.HitTest(point) == CRectTracker::hitMiddle) // moving, not sizing
	{
		// determine mouse position offset from the item itself
		CRect rect = pItemHit->GetRect();
		DocToClient(rect);
		CPoint ptOffset(point.x - rect.left, point.y - rect.top);

		// determine sensitivity rectangle (determines when drag starts)
		CRect rectDrag(rect.left, rect.top, rect.left+1, rect.top+1);

		// execute the drag/drop operation
		m_bInDrag = TRUE;
		ClientToScreen(&rect);  // must be in screen co-ordinates
		ClientToScreen(&rectDrag);
		DROPEFFECT dropEffect = pItemHit->DoDragDrop(rect, ptOffset,
			TRUE, DROPEFFECT_COPY|DROPEFFECT_MOVE, &rectDrag);
		if (m_bInDrag == FALSE) // move in same window
			return;
		m_bInDrag = FALSE;

		if (dropEffect == DROPEFFECT_MOVE)
		{
			// the item was moved (essentially a copy w/delete)
			pItemHit->Invalidate();
			if (m_pSelection == pItemHit)
				m_pSelection = NULL;
			GetDocument()->DeleteItem(pItemHit);
		}
	}
	else if (tracker.Track(this, point))
	{
		ClientToDoc(tracker.m_rect);
		pItemHit->Move(tracker.m_rect);
		GetDocument()->SetModifiedFlag();
	}
}

BOOL CMainView::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
{
	if (pWnd == this && m_pSelection != NULL)
	{
		// give the tracker for the selection a chance
		CRectTracker tracker;
		SetupTracker(&tracker, m_pSelection);
		if (tracker.SetCursor(this, nHitTest))
			return TRUE;
	}
	return CScrollView::OnSetCursor(pWnd, nHitTest, message);
}

/////////////////////////////////////////////////////////////////////////////
// Right mouse for popup context sensitive menu

void CMainView::OnRButtonDown(UINT, CPoint point)
{
	// make sure window is active
	GetParentFrame()->ActivateFrame();

	SetSelection(GetHitItem(point));    // reselect item if appropriate
	UpdateWindow();

	if (m_pSelection != NULL)
	{
		CMenu bar;
		if (bar.LoadMenu(ID_OBJECT_POPUP_MENU))
		{
			CMenu& popup = *bar.GetSubMenu(0);
			ASSERT(popup.m_hMenu != NULL);

			ClientToScreen(&point);
			popup.TrackPopupMenu(TPM_RIGHTBUTTON,
				point.x, point.y,
				AfxGetMainWnd()); // route commands through main window
		}
	}
}

void CMainView::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	MessageBeep(0);     // to test for proper focus transfer

	CScrollView::OnChar(nChar, nRepCnt, nFlags);
}

void CMainView::OnSetFocus(CWnd* pOldWnd)
{
	COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
	if (pActiveItem != NULL &&
		pActiveItem->GetItemState() == COleClientItem::activeUIState)
	{
		// need to set focus to this item if it is in the same view
		CWnd* pWnd = pActiveItem->GetInPlaceWindow();
		if (pWnd != NULL)
		{
			pWnd->SetFocus();
			return;
		}
	}

	CScrollView::OnSetFocus(pOldWnd);
}

void CMainView::OnSize(UINT nType, int cx, int cy)
{
	CScrollView::OnSize(nType, cx, cy);

	UpdateActiveItem();
}

/////////////////////////////////////////////////////////////////////////////
// support for drag/drop

int CMainView::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CScrollView::OnCreate(lpCreateStruct) == -1)
		return -1;

	// register drop target
	m_dropTarget.Register(this);

	return 0;
}

BOOL CMainView::OnDrop(COleDataObject* pDataObject,
	DROPEFFECT dropEffect, CPoint point)
{
	ASSERT_VALID(this);

	// clean up focus rect
	OnDragLeave();

	// offset point as appropriate for dragging
	GetObjectInfo(pDataObject, &m_dragSize, &m_dragOffset);
	CClientDC dc(NULL);
	dc.HIMETRICtoDP(&m_dragSize);
	dc.HIMETRICtoDP(&m_dragOffset);
	point -= m_dragOffset;

	// if move within the view
	ClientToDoc(point);
	if ((dropEffect & DROPEFFECT_MOVE) && m_bInDrag)
	{
		ASSERT(m_pSelection != NULL);
		m_bInDrag = FALSE; // signal drag code that a move happened
		// set top-left based on point of drop
		CRect rect = m_pSelection->GetRect();
		if (rect.TopLeft() != point) // if moved
		{
			m_pSelection->Move(CRect(point,rect.Size()));
			GetDocument()->SetModifiedFlag();
		}
	}
	// check and paste link
	else if ((dropEffect & DROPEFFECT_LINK) && DoPasteItem(TRUE, pDataObject, &point))
		return TRUE;

	// paste embedding/static
	else if (DoPasteItem(FALSE, pDataObject, &point))
		return TRUE;

	return FALSE;
}

BOOL CMainView::GetObjectInfo(COleDataObject* pDataObject,
	CSize* pSize, CSize* pOffset)
{
	ASSERT(pSize != NULL);

	// get object descriptor data
	HGLOBAL hObjDesc = pDataObject->GetGlobalData(m_cfObjectDescriptor);
	if (hObjDesc == NULL)
	{
		if (pOffset != NULL)
			*pOffset = CSize(0, 0); // fill in defaults instead
		*pSize = CSize(0, 0);
		return FALSE;
	}
	ASSERT(hObjDesc != NULL);

	// otherwise, got CF_OBJECTDESCRIPTOR ok.  Lock it down and extract size.
	LPOBJECTDESCRIPTOR pObjDesc = (LPOBJECTDESCRIPTOR)GlobalLock(hObjDesc);
	ASSERT(pObjDesc != NULL);
	pSize->cx = (int)pObjDesc->sizel.cx;
	pSize->cy = (int)pObjDesc->sizel.cy;
	if (pOffset != NULL)
	{
		pOffset->cx = (int)pObjDesc->pointl.x;
		pOffset->cy = (int)pObjDesc->pointl.y;
	}
	GlobalUnlock(hObjDesc);
	GlobalFree(hObjDesc);

	// successfully retrieved pSize & pOffset info
	return TRUE;
}

DROPEFFECT CMainView::OnDragEnter(COleDataObject* pDataObject,
	DWORD grfKeyState, CPoint point)
{
	ASSERT(m_prevDropEffect == DROPEFFECT_NONE);

	GetObjectInfo(pDataObject, &m_dragSize, &m_dragOffset);
	CClientDC dc(NULL);
	dc.HIMETRICtoDP(&m_dragSize);
	dc.HIMETRICtoDP(&m_dragOffset);

	return OnDragOver(pDataObject, grfKeyState, point);
}

DROPEFFECT CMainView::OnDragOver(COleDataObject*,
	DWORD grfKeyState, CPoint point)
{
	point -= m_dragOffset;  // adjust target rect by original cursor offset

	// check for point outside logical area -- i.e. in hatched region
	// GetTotalSize() returns the size passed to SetScrollSizes
	CRect rectScroll(CPoint(0, 0), GetTotalSize());

	CRect rectItem(point,m_dragSize);
	if (rectItem.IsRectEmpty())
	{
		// some apps might have a null size in the object descriptor...
		rectItem.InflateRect(1,1);
	}
	rectItem.OffsetRect(GetDeviceScrollPosition());

	DROPEFFECT de = DROPEFFECT_NONE;
	CRect rectTemp;
	if (rectTemp.IntersectRect(rectScroll, rectItem))
	{
		// check for force link
		if ((grfKeyState & (MK_CONTROL|MK_SHIFT)) == (MK_CONTROL|MK_SHIFT))
			de = DROPEFFECT_LINK;
		// check for force copy
		else if ((grfKeyState & MK_CONTROL) == MK_CONTROL)
			de = DROPEFFECT_COPY;
		// check for force move
		else if ((grfKeyState & MK_ALT) == MK_ALT)
			de = DROPEFFECT_MOVE;
		// default -- recommended action is move
		else
			de = DROPEFFECT_MOVE;
	}

	if (point == m_dragPoint)
		return de;

	// otherwise, cursor has moved -- need to update the drag feedback
	CClientDC dc(this);
	if (m_prevDropEffect != DROPEFFECT_NONE)
	{
		// erase previous focus rect
		dc.DrawFocusRect(CRect(m_dragPoint, m_dragSize));
	}
	m_prevDropEffect = de;
	if (m_prevDropEffect != DROPEFFECT_NONE)
	{
		m_dragPoint = point;
		dc.DrawFocusRect(CRect(point, m_dragSize));
	}
	return de;
}

void CMainView::OnDragLeave()
{
	CClientDC dc(this);
	if (m_prevDropEffect != DROPEFFECT_NONE)
	{
		dc.DrawFocusRect(CRect(m_dragPoint,m_dragSize)); // erase previous focus rect
		m_prevDropEffect = DROPEFFECT_NONE;
	}
}

/////////////////////////////////////////////////////////////////////////////
// Commands for switching display aspects

void CMainView::OnObjectDisplayContent()
{
	if (m_pSelection == NULL)
		return;
	ASSERT_VALID(m_pSelection);
	m_pSelection->Invalidate();
	m_pSelection->SetDrawAspect(DVASPECT_CONTENT);
	m_pSelection->UpdateExtent();
	m_pSelection->Invalidate();
}

void CMainView::OnUpdateObjectDisplayContent(CCmdUI* pCmdUI)
{
	if (m_pSelection == NULL)
	{
		pCmdUI->Enable(FALSE);
		return;
	}
	ASSERT_VALID(m_pSelection);
	pCmdUI->SetCheck(m_pSelection->GetDrawAspect() == DVASPECT_CONTENT);
	pCmdUI->Enable(TRUE);
}

void CMainView::OnObjectDisplayAsIcon()
{
	if (m_pSelection == NULL)
		return;
	ASSERT_VALID(m_pSelection);
	m_pSelection->Invalidate();
	m_pSelection->SetDrawAspect(DVASPECT_ICON);
	m_pSelection->UpdateExtent();
	m_pSelection->Invalidate();
}

void CMainView::OnUpdateObjectDisplayAsIcon(CCmdUI* pCmdUI)
{
	if (m_pSelection == NULL)
	{
		pCmdUI->Enable(FALSE);
		return;
	}
	ASSERT_VALID(m_pSelection);
	pCmdUI->SetCheck(m_pSelection->GetDrawAspect() == DVASPECT_ICON);
	pCmdUI->Enable(TRUE);
}

void CMainView::UpdateActiveItem()
{
	// when there is an active item visible, sizing the window may cause
	//  more/less of the in-place object to become visible.
	//  (ie. the clipping rectangle changes with the size of the window)
	// a container supporting scrolling would also have to do this
	//  when scrolling the contents of the window.

	COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
	if (pActiveItem != NULL &&
		pActiveItem->GetItemState() == COleClientItem::activeUIState &&
		pActiveItem->GetActiveView() == this)
	{
		// this will update the item rectangles by calling
		//  OnGetPosRect & OnGetClipRect.
		pActiveItem->SetItemRects();
	}
}

void CMainView::OnUpdateEditClone(CCmdUI* pCmdUI)
{
	pCmdUI->Enable(m_pSelection != NULL);
}

void CMainView::OnEditClone()
{
	if (m_pSelection == NULL)
		return;

	BeginWaitCursor();

	CRectItem* pItem = NULL;
	TRY
	{
		// create item from dialog results
		pItem = GetDocument()->CreateItem();
		if (!pItem->CreateCloneFrom(m_pSelection))
			AfxThrowMemoryException();  // any exception will do

		// offset it so we can see the clone easier
		CRect rect(20, 20, 0, 0);
		ClientToDoc(rect);
		pItem->m_ptPos.x += rect.left;
		pItem->m_ptPos.y += rect.top;
		ASSERT_VALID(pItem);
	}
	CATCH_ALL(e)
	{
		// cleanup item, if allocated
		if (pItem != NULL)
			GetDocument()->DeleteItem(pItem);

		AfxMessageBox(IDP_FAILED_TO_CREATE);
	}
	END_CATCH_ALL

	EndWaitCursor();
}

void CMainView::OnPasteSpecial()
{
	COlePasteSpecialDialog dlg;
	dlg.AddFormat(CMainDoc::m_cfPrivate, TYMED_HGLOBAL,
		IDS_PRIVATE_CF_DESCR, FALSE, FALSE);
	dlg.AddStandardFormats();
	if (dlg.DoModal() != IDOK)
		return;

	CRectItem* pItem = NULL;
	TRY
	{
		// Get the clipboard format of the selected
		CLIPFORMAT cf = dlg.m_ps.arrPasteEntries[dlg.m_ps.nSelectedIndex].fmtetc.cfFormat;
		if (cf == CMainDoc::m_cfPrivate)
		{
			BOOL bLink = dlg.GetSelectionType() ==
				COlePasteSpecialDialog::pasteLink;
			COleDataObject dataObject;
			dataObject.Attach(dlg.m_ps.lpSrcDataObj, FALSE);
			pItem = DoPasteItem(bLink, &dataObject, NULL, cf);

			// try to get initial presentation data
			pItem->UpdateLink();
		}
		else
		{
			pItem = GetDocument()->CreateItem();
			if (!dlg.CreateItem(pItem))
			{
				TRACE0("Warning: paste special failed to create item.\n");
				AfxThrowMemoryException();
			}

			// try to get initial presentation data
			pItem->UpdateLink();

			// try to get initial extent
			pItem->UpdateExtent();

			// allow document to offset item to avoid direct superimposition
			GetDocument()->AdjustItemPosition(pItem);

			// set the selection with bSafeSelect = TRUE
			SetSelection(pItem, TRUE);
			GetDocument()->SetModifiedFlag();
			GetDocument()->UpdateAllViews(NULL, 0, pItem);
		}
	}
	CATCH_ALL(e)
	{
		// cleanup item, if allocated
		if (pItem != NULL)
			GetDocument()->DeleteItem(pItem);
		AfxMessageBox(IDP_FAILED_TO_CREATE);
		return;
	}
	END_CATCH_ALL
}

void CMainView::OnUpdateEditPaste(CCmdUI* pCmdUI)
{
	// determine if private or standard OLE formats are on the clipboard
	COleDataObject dataObj;
	BOOL bEnable = dataObj.AttachClipboard() &&
		(dataObj.IsDataAvailable(CMainDoc::m_cfPrivate) ||
		 COleClientItem::CanCreateFromData(&dataObj));

	// enable command based on availability
	pCmdUI->Enable(bEnable);
}

void CMainView::OnObjectResetsize()
{
	ASSERT(m_pSelection != NULL);
	m_pSelection->ResetSize();
}

void CMainView::OnCancelInplace()
{
	// deactivate the inplace active item on this frame/view
	COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
	if (pActiveItem != NULL)
		pActiveItem->Deactivate();
	ASSERT(GetDocument()->GetInPlaceActiveItem(this) == NULL);
}

void CMainView::OnDestroy()
{
	CScrollView::OnDestroy();

	// deactivate the inplace active item on this view
	COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
	if (pActiveItem != NULL && pActiveItem->GetActiveView() == this)
	{
		pActiveItem->Deactivate();
		ASSERT(GetDocument()->GetInPlaceActiveItem(this) == NULL);
	}
}

void CMainView::OnUpdateOleEditProperties(CCmdUI* pCmdUI)
{
	pCmdUI->Enable(m_pSelection != NULL);
}

// edit properties dialog specific to OCLIENT
class COlePropertiesEx : public COlePropertiesDialog
{
public:
	COlePropertiesEx(COleClientItem* pItem,
		UINT nScaleMin = 10, UINT nScaleMax = 500, CWnd* pParentWnd = NULL)
		: COlePropertiesDialog(pItem, nScaleMin, nScaleMax, pParentWnd)
		{ }

	virtual BOOL OnApplyScale(
		COleClientItem* pItem, int nCurrentScale, BOOL bRelativeToOrig);
};

BOOL COlePropertiesEx::OnApplyScale(
	COleClientItem* pItem, int nCurrentScale, BOOL bRelativeToOrig)
{
	if (nCurrentScale != -1)
	{
		ASSERT_VALID(pItem);
		CRectItem* pRectItem = (CRectItem*)pItem;
		ASSERT_KINDOF(CRectItem, pRectItem);

		// reset to original size if necessary
		if (bRelativeToOrig)
			pRectItem->ResetSize();

		// update extent to reflect scaling factor
		pRectItem->Invalidate();
		CSize size = pRectItem->GetSize();
		size.cx = MulDiv(size.cx, nCurrentScale, 100);
		size.cy = MulDiv(size.cy, nCurrentScale, 100);
		pRectItem->SetSize(size);
		pRectItem->Invalidate();
	}
	return TRUE;
}

void CMainView::OnOleEditProperties()
{
	ASSERT(m_pSelection != NULL);

	COlePropertiesEx dlg(m_pSelection);
	dlg.DoModal();
}

void CMainView::OnUpdateOleChangeSource(CCmdUI* pCmdUI)
{
	pCmdUI->Enable(m_pSelection != NULL && m_pSelection->GetType() == OT_LINK);
}

void CMainView::OnOleChangeSource()
{
	ASSERT(m_pSelection != NULL && m_pSelection->GetType() == OT_LINK);

	COleChangeSourceDialog dlg(m_pSelection);
	dlg.DoModal();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\oclient\godot\maindoc.cpp ===
// maindoc.cpp : implementation of the CMainDoc class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


#include "stdafx.h"
#include "oclient.h"

#include "maindoc.h"
#include "rectitem.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// private clipboard format
CLIPFORMAT CMainDoc::m_cfPrivate = NULL;

/////////////////////////////////////////////////////////////////////////////
// CMainDoc

IMPLEMENT_DYNCREATE(CMainDoc, COleLinkingDoc)

BEGIN_MESSAGE_MAP(CMainDoc, COleLinkingDoc)
	//{{AFX_MSG_MAP(CMainDoc)
	ON_COMMAND(ID_EDIT_CLEAR_ALL, OnEditClearAll)
	ON_UPDATE_COMMAND_UI(ID_EDIT_CLEAR_ALL, OnUpdateEditClearAll)
	//}}AFX_MSG_MAP
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, OnUpdatePasteMenu)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE_LINK, OnUpdatePasteLinkMenu)
	ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_LINKS, OnUpdateEditLinksMenu)
	ON_COMMAND(ID_OLE_EDIT_LINKS, OnEditLinks)
	ON_UPDATE_COMMAND_UI(ID_OLE_VERB_FIRST, OnUpdateObjectVerbMenu)
	ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_CHANGE_ICON, OnUpdateEditChangeIcon)
	ON_COMMAND(ID_OLE_EDIT_CHANGE_ICON, OnEditChangeIcon)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMainDoc construction/destruction

CMainDoc::CMainDoc() : m_sizeDoc(800,1050) // document size is 8x10.5
{
	EnableCompoundFile();

	m_bNeedUpdate = TRUE;
	if (m_cfPrivate == NULL)
		m_cfPrivate = (CLIPFORMAT)
			::RegisterClipboardFormat(_T("MFC OClient Sample"));
}

CMainDoc::~CMainDoc()
{
}

CSize &CMainDoc::GetDocumentSize()
{
	return m_sizeDoc;
}

void CMainDoc::OnShowViews(BOOL bVisible)
{
	COleLinkingDoc::OnShowViews(bVisible);

	if (bVisible && m_bNeedUpdate)
	{
		// update embedded links in this document before showing the window
		COleUpdateDialog dlg(this);
		dlg.DoModal();
		m_bNeedUpdate = FALSE;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMainDoc item management

CRectItem* CMainDoc::CreateItem()
{
	return new CRectItem(this); // does 'AddItem' automatically
}

// safe delete that notifies views
void CMainDoc::DeleteItem(CRectItem* pItem)
{
	ASSERT(pItem->GetDocument() == this);

	SetModifiedFlag();
	UpdateAllViews(NULL, 1, pItem); // pItem will be deleted
	pItem->Delete();    // does a 'RemoveItem' & 'delete this' automatically
}

/////////////////////////////////////////////////////////////////////////////
// CMainDoc serialization

void CMainDoc::Serialize(CArchive& ar)
{
// NOTE: New easier to use serialization model -- even for OLE objects!
	WORD wMagic = 0x0DAF;
	if (ar.IsStoring())
	{
		if (HasBlankItems() &&
			AfxMessageBox(IDP_SAVEINCOMPLETE, MB_YESNO|MB_ICONQUESTION) != IDYES)
		{
			TRACE0("Aborting save -- incomplete items found!\n");
			AfxThrowArchiveException(CArchiveException::generic);
		}
		ar << wMagic;
	}
	else
	{
		WORD w;
		ar >> w;

		if (w != wMagic)
		{
			TRACE0("invalid magic number at start of file\n");
			AfxThrowArchiveException(CArchiveException::generic);
		}
	}

	// serialize the rest of the document (OLE items)
	COleLinkingDoc::Serialize(ar);
}

/////////////////////////////////////////////////////////////////////////////
// CMainDoc commands

void CMainDoc::OnEditClearAll()
{
	// delete all items in the document (also removes sub-storages)
	POSITION pos = GetStartPosition();
	while (pos != NULL)
	{
		CRectItem* pItem = (CRectItem*)GetNextItem(pos);
		ASSERT_KINDOF(CRectItem, pItem);
		pItem->Delete();
	}

	// everything is gone now!
	SetModifiedFlag();
	UpdateAllViews(NULL);
}


void CMainDoc::OnUpdateEditClearAll(CCmdUI* pCmdUI)
{
	// Enable ClearAll if there is anything to clear
	pCmdUI->Enable(GetStartPosition() != NULL);
}

void CMainDoc::AdjustItemPosition(CRectItem* pItem)
{
	POSITION pos = GetStartPosition();
	while (pos != NULL)
	{
		CRectItem* pRectItem = (CRectItem*)GetNextItem(pos);
		ASSERT_KINDOF(CRectItem, pItem);
		if (pRectItem != pItem && pRectItem->GetRect() == pItem->GetRect())
		{
			pItem->m_ptPos.x += 10;
			pItem->m_ptPos.y -= 10;
			pos = GetStartPosition();
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMainDoc diagnostics

#ifdef _DEBUG
void CMainDoc::AssertValid() const
{
	COleLinkingDoc::AssertValid();
}

void CMainDoc::Dump(CDumpContext& dc) const
{
	COleLinkingDoc::Dump(dc);
}
#endif //_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\oclient\godot\oclient.cpp ===
// oclient.cpp : Defines the class behaviors for the application.
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


#include "stdafx.h"
#include <stddef.h>
#include "oclient.h"

#include "frame.h"
#include "maindoc.h"
#include "mainview.h"
#include "splitfra.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// The one and only COleClientApp object

COleClientApp NEAR theApp;

// this is the GUID for OCLIENT documents
static const GUID BASED_CODE clsid =
	{ 0x00021842, 0, 0, { 0xC0, 0, 0, 0, 0, 0, 0, 0x46 } };

/////////////////////////////////////////////////////////////////////////////
// COleClientApp

BEGIN_MESSAGE_MAP(COleClientApp, CWinApp)
	//{{AFX_MSG_MAP(COleClientApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
	// Standard print setup command
	ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
	// Global help commands
	ON_COMMAND(ID_HELP_INDEX, CWinApp::OnHelpIndex)
	ON_COMMAND(ID_HELP_USING, CWinApp::OnHelpUsing)
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
	ON_COMMAND(ID_DEFAULT_HELP, CWinApp::OnHelpIndex)
	ON_COMMAND(ID_CONTEXT_HELP, CWinApp::OnContextHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COleClientApp construction
// Place all significant initialization in InitInstance

COleClientApp::COleClientApp()
{
}

/////////////////////////////////////////////////////////////////////////////
// COleClientApp initialization

BOOL COleClientApp::InitInstance()
{
#if defined(_DEBUG) && !defined(_AFX_NO_DEBUG_CRT)
	// turn on extra memory tracking
	afxMemDF |= checkAlwaysMemDF;
#endif

	// Initialize OLE 2.0 libraries
	if (!AfxOleInit())
	{
		AfxMessageBox(IDP_AFXOLEINIT_FAILED);
		return FALSE;
	}

	// Standard initialization
	Enable3dControls();    // enable 3d controls in dialogs
	LoadStdProfileSettings();  // Load standard INI file options (including MRU)

	// Register document templates
	CMultiDocTemplate* pDocTemplate = new CMultiDocTemplate(IDR_OCLIENTTYPE,
			RUNTIME_CLASS(CMainDoc),
			RUNTIME_CLASS(CSplitFrame),
			RUNTIME_CLASS(CMainView));
	pDocTemplate->SetContainerInfo(IDR_OCLIENTTYPE_CNTR_IP);
	AddDocTemplate(pDocTemplate);

	// create main MDI Frame window
	CMainFrame* pMainFrame = new CMainFrame;
	if (!pMainFrame->LoadFrame(IDR_MAINFRAME))
		return FALSE;
	m_pMainWnd = pMainFrame;

	// enable file manager drag/drop and DDE Execute open
	m_pMainWnd->DragAcceptFiles();

	EnableShellOpen();
	RegisterShellFileTypes(TRUE);

	// connect the COleTemplate server to the document template
	m_server.ConnectTemplate(clsid, pDocTemplate, FALSE);
	COleTemplateServer::RegisterAll();
		// Note: MDI applications register all class objects regardless of
		//  the /Embedding on the command line.

	// Parse command line for standard shell commands, DDE, file open
	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);

	if (RunEmbedded())
	{
		// application was run with /Embedding flag.  Instead of showing
		//  the window, the application waits to receive OLE requests.
		return TRUE;
	}
	// always update system registry when run non-embedded
	m_server.UpdateRegistry(OAT_CONTAINER);

	// Dispatch commands specified on the command line
	if (!ProcessShellCommand(cmdInfo))
		return FALSE;

	pMainFrame->ShowWindow(m_nCmdShow);
	pMainFrame->UpdateWindow();

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// COleClientApp commands

void COleClientApp::OnAppAbout()
{
	CDialog(IDD_ABOUTBOX).DoModal();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\oclient\godot\maindoc.h ===
// maindoc.h : interface of the CMainDoc class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


class CRectItem;

class CMainDoc : public COleLinkingDoc
{
protected: // create from serialization only
	CMainDoc();
	DECLARE_DYNCREATE(CMainDoc)

// Attributes
public:
	static CLIPFORMAT m_cfPrivate;
	CSize m_sizeDoc;
	CSize& GetDocumentSize();
	BOOL m_bNeedUpdate;

// Operations
public:
	CRectItem* CreateItem();    // this document only stores CRectItems
	void DeleteItem(CRectItem* pItem);
	void AdjustItemPosition(CRectItem* pItem);

// Implementation
public:
	virtual ~CMainDoc();
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
	virtual void OnShowViews(BOOL bVisible);

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
	//{{AFX_MSG(CMainDoc)
	afx_msg void OnEditClearAll();
	afx_msg void OnUpdateEditClearAll(CCmdUI* pCmdUI);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\oclient\godot\mainview.h ===
// mainview.h : interface of the CMainView class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


class CRectItem;

class CMainView : public CScrollView
{
protected: // create from serialization only
	CMainView();
	DECLARE_DYNCREATE(CMainView)

// Attributes
public:
	CMainDoc* GetDocument()
	{
		ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CMainDoc)));
		return (CMainDoc*) m_pDocument;
	}

	CRectItem* GetSelection() const
		{ return m_pSelection; } // Just the top-most window
	// set bSafeSelect to TRUE when there is a chance that an inplace
	// active item could be deactivated before finishing
	void SetSelection(CRectItem* pNewSel, BOOL bSafeSelect = FALSE);

// Operations
public:
	CRectItem* DoPasteItem(BOOL bLink, COleDataObject* pDataObject,
		CPoint* pPoint, CLIPFORMAT cfFormat = 0);
	void ClientToDoc(CRect &rc);
	void DocToClient(CRect &rc);
	void ClientToDoc(CPoint &pt);
	void DocToClient(CPoint &pt);
	void ClientToDoc(CSize &sz);
	void DocToClient(CSize &sz);
	void UpdateActiveItem();


// Implementation
protected:
	BOOL m_bInDrag;
	CRectItem* m_pSelection;
	COleDropTarget m_dropTarget;
	CPoint m_dragPoint;
	CSize m_dragSize;
	CSize m_dragOffset;
	DROPEFFECT m_prevDropEffect;
	static CLIPFORMAT m_cfObjectDescriptor;
	static CBrush NEAR m_brHatch;

	CRectItem* GetHitItem(CPoint point);
	BOOL GetObjectInfo(COleDataObject* pDataObject,
		CSize* pSize, CSize* pOffset);
	void DoPasteNative(COleDataObject* pDataObject, CPoint* pPoint,
		CRectItem* pItem);
	void DoPasteStandard(BOOL bLink, COleDataObject* pDataObject,
		CPoint* pPoint, CRectItem* pItem, CLIPFORMAT cfFormat = 0);

public:
	virtual ~CMainView();
	virtual void OnPrepareDC(CDC* pDC, CPrintInfo* pInfo = NULL);
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual void OnInitialUpdate();
	virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// special scroll handling
	virtual BOOL OnScrollBy(CSize sizeScroll, BOOL bDoScroll = TRUE);

	// drag drop implementation
	virtual BOOL OnDrop(COleDataObject* pDataObject,
		DROPEFFECT dropEffect, CPoint point);
	virtual DROPEFFECT OnDragEnter(COleDataObject* pDataObject,
		DWORD grfKeyState, CPoint point);
	virtual DROPEFFECT OnDragOver(COleDataObject* pDataObject,
		DWORD grfKeyState, CPoint point);
	virtual void OnDragLeave();

	// Printing support
protected:
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);

	// OLE Client support
	virtual BOOL IsSelected(const CObject* pDocItem) const;
	BOOL DoCopySelection();
	void SetupTracker(CRectTracker* pTracker, CRectItem* pItem,
		CRect* pTrueRect = NULL);
	void InvalidateItem(CRectItem* pItem);

// Generated message map functions
protected:
	//{{AFX_MSG(CMainView)
	afx_msg void OnPaste();
	afx_msg void OnPasteLink();
	afx_msg void OnInsertObject();
	afx_msg void OnUpdateEditMenu(CCmdUI* pCmdUI);
	afx_msg void OnEditClear();
	afx_msg void OnEditCopy();
	afx_msg void OnEditCut();
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnObjectDisplayContent();
	afx_msg void OnUpdateObjectDisplayContent(CCmdUI* pCmdUI);
	afx_msg void OnObjectDisplayAsIcon();
	afx_msg void OnUpdateObjectDisplayAsIcon(CCmdUI* pCmdUI);
	afx_msg void OnPasteSpecial();
	afx_msg void OnUpdateEditClone(CCmdUI* pCmdUI);
	afx_msg void OnEditClone();
	afx_msg void OnUpdateEditPaste(CCmdUI* pCmdUI);
	afx_msg void OnObjectResetsize();
	afx_msg void OnCancelInplace();
	afx_msg void OnDestroy();
	afx_msg void OnUpdateOleEditProperties(CCmdUI* pCmdUI);
	afx_msg void OnOleEditProperties();
	afx_msg void OnUpdateOleChangeSource(CCmdUI* pCmdUI);
	afx_msg void OnOleChangeSource();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\oclient\godot\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by oclient.rc
//
#define IDR_MAINFRAME                   2
#define IDR_OCLIENTTYPE                 3
#define IDD_ABOUTBOX                    100
#define IDP_BUSY                        101
#define ID_OBJECT_POPUP_MENU            102
#define IDS_PRIVATE_CF_DESCR            102
#define IDR_OCLIENTTYPE_CNTR_IP         104
#define IDP_CLIPBOARD_CUT_FAILED        0x201
#define IDP_CLIPBOARD_COPY_FAILED       0x202
#define IDP_GET_FROM_CLIPBOARD_FAILED   0x203
#define IDP_FAILED_TO_CREATE            0x204
#define IDP_SAVEINCOMPLETE              0x205
#define IDP_CLIPBOARD_ZERO_SIZE         0x206
#define IDP_AFXOLEINIT_FAILED           519
#define ID_OBJECT_TRACK_SIZE            2000
#define ID_CANCEL_INPLACE               2002
#define ID_OBJECT_DISPLAYCONTENT        2003
#define ID_OBJECT_DISPLAYASICON         2004
#define ID_OBJECT_CHANGEICON            2005
#define ID_EDIT_CLONE                   2006
#define ID_OBJECT_RESETSIZE             2009
#define ID_OLE_CHANGE_SOURCE            2012

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        106
#define _APS_NEXT_COMMAND_VALUE         2013
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           200
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\oclient\godot\splitfra.cpp ===
// splitfra.cpp : implementation of the CSplitFrame class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


#include "stdafx.h"
#include "oclient.h"
#include "splitfra.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSplitFrame

IMPLEMENT_DYNCREATE(CSplitFrame, CMDIChildWnd)

CSplitFrame::CSplitFrame()
{
}

CSplitFrame::~CSplitFrame()
{
}

BOOL CSplitFrame::OnCreateClient(LPCREATESTRUCT /*lpcs*/, CCreateContext* pContext)
{
	return m_wndSplitter.Create(this,
		2, 2,       // TODO: adjust the number of rows, columns
		CSize(10, 10),  // TODO: adjust the minimum pane size
		pContext);
}

BEGIN_MESSAGE_MAP(CSplitFrame, CMDIChildWnd)
	//{{AFX_MSG_MAP(CSplitFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSplitFrame message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\oclient\godot\oclient.h ===
// oclient.h : main header file for the OCLIENT application
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// COleClientApp: See oclient.cpp for the implementation of this class

class COleClientApp : public CWinApp
{
public:
	COleClientApp();

// Overrides
	virtual BOOL InitInstance();

// Implementation
protected:
	COleTemplateServer m_server;

	//{{AFX_MSG(COleClientApp)
	afx_msg void OnAppAbout();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\oclient\godot\rectitem.cpp ===
// rectitem.cpp : implementation of the CRectItem class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


#include "stdafx.h"
#include <afxpriv.h>
#include "oclient.h"

#include "maindoc.h"
#include "mainview.h"
#include "rectitem.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_SERIAL(CRectItem, COleClientItem, 0)

CRectItem::CRectItem(COleDocument* pContainer) : COleClientItem(pContainer) ,
	m_ptPos(10, -10), m_sizeContent(0,0), m_sizeIcon(0,0),
	m_sizeContentExtent(0, 0), m_sizeIconExtent(0, 0)
{
}

CRectItem::CRectItem() : m_ptPos(10, -10), m_sizeContent(0,0), m_sizeIcon(0,0),
	m_sizeContentExtent(0, 0), m_sizeIconExtent(0, 0)
{
}

CRectItem::~CRectItem()
{
}

void CRectItem::Invalidate(CView* pNotThisView)
{
	GetDocument()->UpdateAllViews(pNotThisView, 0, this);
}

/////////////////////////////////////////////////////////////////////////////

CSize CRectItem::GetSize()
{
	DVASPECT dv = GetDrawAspect();
	if (dv == DVASPECT_ICON)
		return m_sizeIcon;
	else
		return m_sizeContent;
}

CSize CRectItem::GetBaseSize()
{
	DVASPECT dv = GetDrawAspect();
	if (dv == DVASPECT_ICON)
		return m_sizeIconExtent;
	else
		return m_sizeContentExtent;
}

void CRectItem::SetSize(CSize size)
{
	DVASPECT dv = GetDrawAspect();
	if (dv == DVASPECT_ICON)
		m_sizeIcon = size;
	else
		m_sizeContent = size;
}

void CRectItem::SetBaseSize(CSize size)
{
	DVASPECT dv = GetDrawAspect();
	if (dv == DVASPECT_ICON)
		m_sizeIconExtent = size;
	else
		m_sizeContentExtent = size;
}

void CRectItem::SetRect(CRect& rect)
{
	m_ptPos = rect.TopLeft();
	SetSize(rect.Size());
}

BOOL CRectItem::UpdateExtent()
{
	// get size in pixels
	CSize size;
	if (!GetCachedExtent(&size))
		return FALSE;       // blank
	Invalidate();   // invalidate the old size/position
	CSize sizeBase = GetBaseSize();
	if (size == sizeBase) // no change
		return FALSE;
	// if new object (i.e. m_extent is empty) setup position
	if (sizeBase == CSize(0,0))
	{
		// convert to document coords
		CSize sizeNew(MulDiv(size.cx, 10, 254), - MulDiv(size.cy, 10, 254));
		SetSize(sizeNew);
	}
	else
	{
		if (!IsInPlaceActive() && size != sizeBase)
		{
			// data changed and not inplace, so scale up rect as well
			CSize sizeCur = GetSize();
			sizeCur.cx = MulDiv(sizeCur.cx, size.cx, sizeBase.cx);
			sizeCur.cy = - MulDiv(-sizeCur.cy, size.cy, sizeBase.cy);
			SetSize(sizeCur);
		}
	}
	SetBaseSize(size);
	Invalidate();   // as well as the new size/position
	return TRUE;
}

BOOL CRectItem::OnChangeItemPosition(const CRect& rectPos)
{
	CMainView* pView = GetActiveView();
	if (pView == NULL)
		return FALSE;
	ASSERT_VALID(pView);

	CRect rc = rectPos;
	pView->ClientToDoc(rc);

	if (rc != GetRect())
	{
		// invalidate old item
		Invalidate();
		// update to new rectangle
		SetRect(rc);

		GetDocument()->SetModifiedFlag();
		CSize sizeExtent;
		GetCachedExtent(&sizeExtent);
		SetBaseSize(sizeExtent);

		// and invalidate new
		Invalidate();
	}
	return COleClientItem::OnChangeItemPosition(rectPos);
}

void CRectItem::OnActivate()
{
	// allow only one inplace active item per frame
	CMainView* pView = GetActiveView();
	ASSERT_VALID(pView);
	COleClientItem* pItem = GetDocument()->GetInPlaceActiveItem(pView);
	if (pItem != NULL && pItem != this)
		pItem->Close();

	COleClientItem::OnActivate();

	// set selection to an item when it becomes active
	pView->SetSelection(this);
}

void CRectItem::OnDeactivateUI(BOOL bUndoable)
{
	COleClientItem::OnDeactivateUI(bUndoable);

	// hide the object if it is not an outside-in object
	DWORD dwMisc = 0;
	m_lpObject->GetMiscStatus(GetDrawAspect(), &dwMisc);
	if (dwMisc & OLEMISC_INSIDEOUT)
		DoVerb(OLEIVERB_HIDE, NULL);
}

void CRectItem::OnChange(OLE_NOTIFICATION nCode, DWORD dwParam)
{
	COleClientItem::OnChange(nCode, dwParam);
	switch(nCode)
	{
		case OLE_CHANGED:
			UpdateExtent();
			Invalidate();
			break;
		case OLE_CHANGED_ASPECT:
		case OLE_CHANGED_STATE:
			Invalidate();
			break;
	}
}

void CRectItem::OnGetItemPosition(CRect& rPosition)
{
	ASSERT_VALID(this);

	if (GetSize() == CSize(0,0))
		UpdateExtent();

	// copy m_rect, which is in document coordinates
	rPosition = GetRect();
	CMainView* pView = GetActiveView();
	ASSERT_VALID(pView);
	pView->DocToClient(rPosition);
}

void CRectItem::Move(CRect &rc)
{
	// invalidate old rect
	Invalidate();
	// invalidate new
	SetRect(rc);
	Invalidate();

	// update item rect when in-place active
	if (IsInPlaceActive())
		SetItemRects();
}

void CRectItem::Serialize(CArchive& ar)
{
	CRect rect;

	// IMPORTANT: when using "easy" serialize -- call base class FIRST!
	//  (not strictly necessary, but a good idea)
	COleClientItem::Serialize(ar);

	// now store/retrieve data specific to CRectItem
	if (ar.IsStoring())
	{
		WORD w = 0x5500;        // magic value
		ar << w << m_ptPos << m_sizeIcon << m_sizeIconExtent <<
			m_sizeContent << m_sizeContentExtent;
	}
	else
	{
		WORD w;
		ar >> w >> m_ptPos >> m_sizeIcon >> m_sizeIconExtent >>
			m_sizeContent >> m_sizeContentExtent;
		if (w != 0x5500)
		{
			TRACE0("Bad magic number in front of an item wnd\n");
			AfxThrowArchiveException(CArchiveException::generic);
		}
	}
}

void CRectItem::ResetSize()
{
	ASSERT_VALID(this);
	Invalidate();
	SetBaseSize(CSize(0, 0));
	UpdateExtent();
}

// OnGetClipboardData is used by CopyToClipboard and DoDragDrop
COleDataSource* CRectItem::OnGetClipboardData(
	BOOL bIncludeLink, LPPOINT lpOffset, LPSIZE lpSize)
{
	ASSERT_VALID(this);

	COleDataSource* pDataSource = new COleDataSource;
	TRY
	{
		GetNativeClipboardData(pDataSource);
		GetClipboardData(pDataSource, bIncludeLink, lpOffset, lpSize);
	}
	CATCH_ALL(e)
	{
		delete pDataSource;
		THROW_LAST();
	}
	END_CATCH_ALL

	ASSERT_VALID(pDataSource);
	return pDataSource;
}

void CRectItem::GetNativeClipboardData(COleDataSource* pDataSource)
{
	ASSERT_VALID(this);
	ASSERT_VALID(GetDocument());

	// Create a shared file and associate a CArchive with it
	CSharedFile file;
	CArchive ar(&file, CArchive::store);

	// Serialize selected objects to the archive
	Serialize(ar);
	ar.Close();
	pDataSource->CacheGlobalData(CMainDoc::m_cfPrivate, file.Detach());
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\oclient\godot\stdafx.cpp ===
// stdafx.cpp : pre-compiled header and types file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\oclient\godot\splitfra.h ===
// splitfra.h : main header file for the CSplitFrame class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


/////////////////////////////////////////////////////////////////////////////
// CSplitFrame frame with splitter

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

class CSplitFrame : public CMDIChildWnd
{
	DECLARE_DYNCREATE(CSplitFrame)
protected:
	CSplitFrame();          // protected constructor used by dynamic creation

// Attributes
protected:
	CSplitterWnd    m_wndSplitter;
public:

// Operations
public:

// Implementation
public:
	virtual ~CSplitFrame();
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);

	// Generated message map functions
	//{{AFX_MSG(CSplitFrame)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\oclient\godot\rectitem.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


// class CRectItem - main COleClientItem bounded by a rectangle

class CMainDoc;
class CMainView;

class CRectItem : public COleClientItem
{
	DECLARE_SERIAL(CRectItem)
	CRectItem();

public:
	CRectItem(COleDocument* pContainer);
	~CRectItem();

// Attributes
	CPoint m_ptPos;             //position in document
	CSize GetSize();            //current size
	void SetSize(CSize size);
	CSize GetBaseSize();        //base size
	void SetBaseSize(CSize size);
	CRect GetRect()             //current rect
		{ return CRect(m_ptPos, GetSize()); }
	void SetRect(CRect& rect);

	CMainDoc* GetDocument()
		{ return (CMainDoc*)COleClientItem::GetDocument(); }
	CMainView* GetActiveView()
		{ return (CMainView*)COleClientItem::GetActiveView(); }

// Operations
	void Dirty()
		{ GetDocument()->SetModifiedFlag(); }
	void Invalidate(CView* pNotThisView = NULL);
	BOOL UpdateExtent();
	void Move(CRect &rc);
	void ResetSize();
	void GetNativeClipboardData(COleDataSource *pDataSource);

	virtual void Serialize(CArchive& ar); // from CObject - public to call directly

// Overridables
protected:
	virtual void OnChange(OLE_NOTIFICATION wNotification, DWORD dwParam);
	virtual BOOL OnChangeItemPosition(const CRect& rectPos);
	virtual void OnActivate();
	virtual COleDataSource* OnGetClipboardData(BOOL bIncludeLink,
		LPPOINT lpOffset, LPSIZE lpSize);
	virtual void OnDeactivateUI(BOOL bUndoable);

public:
	virtual void OnGetItemPosition(CRect& rPosition);
protected:
	CSize m_sizeIcon;           //current size
	CSize m_sizeContent;        //current size
	CSize m_sizeIconExtent;     //default size
	CSize m_sizeContentExtent;  //default size
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\oclient\godot\stdafx.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN

#include <afxwin.h>
#include <afxext.h>
#include <afxole.h>
#include <afxodlgs.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\oclient\old\frame.cpp ===
// frame.cpp : implementation of the CMainFrame class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.



#include "stdafx.h"
#include "oclient.h"

#include "frame.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
	ON_WM_CREATE()
	ON_COMMAND(ID_WINDOW_TILE_HORZ, OnWindowTileHorz)
	ON_WM_PALETTECHANGED()
	ON_WM_QUERYNEWPALETTE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// arrays of IDs used to initialize control bars

// toolbar buttons - IDs are command buttons
static UINT BASED_CODE buttons[] =
{
	// same order as in the bitmap 'toolbar.bmp'
	ID_FILE_NEW,
	ID_FILE_OPEN,
	ID_FILE_SAVE,
		ID_SEPARATOR,
	ID_EDIT_CUT,
	ID_EDIT_COPY,
	ID_EDIT_PASTE,
		ID_SEPARATOR,
	ID_FILE_PRINT,
	ID_APP_ABOUT,
	ID_CONTEXT_HELP,
};

static UINT BASED_CODE indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};


/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (!m_wndToolBar.Create(this) ||
		!m_wndToolBar.LoadBitmap(IDR_MAINFRAME) ||
		!m_wndToolBar.SetButtons(buttons,
		  sizeof(buttons)/sizeof(UINT)))
	{
		TRACE0("Failed to create toolbar\n");
		return -1;      // fail to create
	}

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}
	EnableDocking(CBRS_ALIGN_ANY);
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);
	CDC* pDC = GetDC();
	m_palette.CreateHalftonePalette(pDC);
	ReleaseDC(pDC);
	return 0;
}

CMainFrame::~CMainFrame()
{
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CMDIFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CMDIFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame commands

void CMainFrame::OnWindowTileHorz()
{
	if (GetKeyState(VK_SHIFT) < 0)
		OnMDIWindowCmd(ID_WINDOW_TILE_VERT);
	else
		OnMDIWindowCmd(ID_WINDOW_TILE_HORZ);
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

void CMainFrame::OnPaletteChanged(CWnd* pFocusWnd)
{
	CMDIFrameWnd::OnPaletteChanged(pFocusWnd);
	if (pFocusWnd != this)
		SelectPalette(TRUE);
}

BOOL CMainFrame::OnQueryNewPalette()
{
	if (CMDIFrameWnd::OnQueryNewPalette())
		return TRUE;
	return SelectPalette(FALSE);
}

BOOL CMainFrame::SelectPalette(BOOL bBackground)
{
	if (m_palette.m_hObject == NULL)
		return FALSE;

	CDC* pDC = GetDC();
	CPalette* pOldPal = pDC->SelectPalette(&m_palette, bBackground);
	UINT nPalChg = pDC->RealizePalette();
	pDC->SelectPalette(pOldPal, TRUE); // background
	ReleaseDC(pDC);

	if (nPalChg > 0)
		InvalidateRect(NULL, TRUE);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\oclient\old\frame.h ===
// frame.h : interface of the CMainFrame class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

class CMainFrame : public CMDIFrameWnd
{
	DECLARE_DYNAMIC(CMainFrame)
public:
	CMainFrame();

// Attributes
public:
	CPalette m_palette;

// Operations
public:
	BOOL SelectPalette(BOOL bBackground);

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Control bar embedded members
protected:
	CStatusBar  m_wndStatusBar;
	CToolBar    m_wndToolBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnWindowTileHorz();
	afx_msg void OnPaletteChanged(CWnd* pFocusWnd);
	afx_msg BOOL OnQueryNewPalette();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\oclient\old\maindoc.cpp ===
// maindoc.cpp : implementation of the CMainDoc class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


#include "stdafx.h"
#include "oclient.h"

#include "maindoc.h"
#include "rectitem.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// private clipboard format
CLIPFORMAT CMainDoc::m_cfPrivate = NULL;

/////////////////////////////////////////////////////////////////////////////
// CMainDoc

IMPLEMENT_DYNCREATE(CMainDoc, COleLinkingDoc)

BEGIN_MESSAGE_MAP(CMainDoc, COleLinkingDoc)
	//{{AFX_MSG_MAP(CMainDoc)
	ON_COMMAND(ID_EDIT_CLEAR_ALL, OnEditClearAll)
	ON_UPDATE_COMMAND_UI(ID_EDIT_CLEAR_ALL, OnUpdateEditClearAll)
	//}}AFX_MSG_MAP
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, OnUpdatePasteMenu)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE_LINK, OnUpdatePasteLinkMenu)
	ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_LINKS, OnUpdateEditLinksMenu)
	ON_COMMAND(ID_OLE_EDIT_LINKS, OnEditLinks)
	ON_UPDATE_COMMAND_UI(ID_OLE_VERB_FIRST, OnUpdateObjectVerbMenu)
	ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_CHANGE_ICON, OnUpdateEditChangeIcon)
	ON_COMMAND(ID_OLE_EDIT_CHANGE_ICON, OnEditChangeIcon)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMainDoc construction/destruction

CMainDoc::CMainDoc() : m_sizeDoc(800,1050) // document size is 8x10.5
{
	EnableCompoundFile();

	m_bNeedUpdate = TRUE;
	if (m_cfPrivate == NULL)
		m_cfPrivate = (CLIPFORMAT)
			::RegisterClipboardFormat(_T("MFC OClient Sample"));
}

CMainDoc::~CMainDoc()
{
}

CSize &CMainDoc::GetDocumentSize()
{
	return m_sizeDoc;
}

void CMainDoc::OnShowViews(BOOL bVisible)
{
	COleLinkingDoc::OnShowViews(bVisible);

	if (bVisible && m_bNeedUpdate)
	{
		// update embedded links in this document before showing the window
		COleUpdateDialog dlg(this);
		dlg.DoModal();
		m_bNeedUpdate = FALSE;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMainDoc item management

CRectItem* CMainDoc::CreateItem()
{
	return new CRectItem(this); // does 'AddItem' automatically
}

// safe delete that notifies views
void CMainDoc::DeleteItem(CRectItem* pItem)
{
	ASSERT(pItem->GetDocument() == this);

	SetModifiedFlag();
	UpdateAllViews(NULL, 1, pItem); // pItem will be deleted
	pItem->Delete();    // does a 'RemoveItem' & 'delete this' automatically
}

/////////////////////////////////////////////////////////////////////////////
// CMainDoc serialization

void CMainDoc::Serialize(CArchive& ar)
{
// NOTE: New easier to use serialization model -- even for OLE objects!
	WORD wMagic = 0x0DAF;
	if (ar.IsStoring())
	{
		if (HasBlankItems() &&
			AfxMessageBox(IDP_SAVEINCOMPLETE, MB_YESNO|MB_ICONQUESTION) != IDYES)
		{
			TRACE0("Aborting save -- incomplete items found!\n");
			AfxThrowArchiveException(CArchiveException::generic);
		}
		ar << wMagic;
	}
	else
	{
		WORD w;
		ar >> w;

		if (w != wMagic)
		{
			TRACE0("invalid magic number at start of file\n");
			AfxThrowArchiveException(CArchiveException::generic);
		}
	}

	// serialize the rest of the document (OLE items)
	COleLinkingDoc::Serialize(ar);
}

/////////////////////////////////////////////////////////////////////////////
// CMainDoc commands

void CMainDoc::OnEditClearAll()
{
	// delete all items in the document (also removes sub-storages)
	POSITION pos = GetStartPosition();
	while (pos != NULL)
	{
		CRectItem* pItem = (CRectItem*)GetNextItem(pos);
		ASSERT_KINDOF(CRectItem, pItem);
		pItem->Delete();
	}

	// everything is gone now!
	SetModifiedFlag();
	UpdateAllViews(NULL);
}


void CMainDoc::OnUpdateEditClearAll(CCmdUI* pCmdUI)
{
	// Enable ClearAll if there is anything to clear
	pCmdUI->Enable(GetStartPosition() != NULL);
}

void CMainDoc::AdjustItemPosition(CRectItem* pItem)
{
	POSITION pos = GetStartPosition();
	while (pos != NULL)
	{
		CRectItem* pRectItem = (CRectItem*)GetNextItem(pos);
		ASSERT_KINDOF(CRectItem, pItem);
		if (pRectItem != pItem && pRectItem->GetRect() == pItem->GetRect())
		{
			pItem->m_ptPos.x += 10;
			pItem->m_ptPos.y -= 10;
			pos = GetStartPosition();
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMainDoc diagnostics

#ifdef _DEBUG
void CMainDoc::AssertValid() const
{
	COleLinkingDoc::AssertValid();
}

void CMainDoc::Dump(CDumpContext& dc) const
{
	COleLinkingDoc::Dump(dc);
}
#endif //_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\oclient\old\maindoc.h ===
// maindoc.h : interface of the CMainDoc class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


class CRectItem;

class CMainDoc : public COleLinkingDoc
{
protected: // create from serialization only
	CMainDoc();
	DECLARE_DYNCREATE(CMainDoc)

// Attributes
public:
	static CLIPFORMAT m_cfPrivate;
	CSize m_sizeDoc;
	CSize& GetDocumentSize();
	BOOL m_bNeedUpdate;

// Operations
public:
	CRectItem* CreateItem();    // this document only stores CRectItems
	void DeleteItem(CRectItem* pItem);
	void AdjustItemPosition(CRectItem* pItem);

// Implementation
public:
	virtual ~CMainDoc();
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
	virtual void OnShowViews(BOOL bVisible);

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
	//{{AFX_MSG(CMainDoc)
	afx_msg void OnEditClearAll();
	afx_msg void OnUpdateEditClearAll(CCmdUI* pCmdUI);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\oclient\godot\uss.cpp ===
//
// File:    UnicowsSupport.c
// Date:    22 March 2001
// Purpose: This file contains functions that supplement the Unicode wrapper layer
//

#define UNICODE

#include "atlbase.h"

#include "oledlg.h"

static const char CDCommonFilesKey [] = "Software\\My Company",
                  CDCommonFilesValueName [] = "UnicowsLocation",
                  UnicowsName [] = "\\unicows.dll";

static HMODULE __stdcall LoadUnicows (void)
{
    HMODULE hUnicows = 0;

    HKEY hKey = 0;

    LONG errCode = RegOpenKeyExA (HKEY_LOCAL_MACHINE,
                                  CDCommonFilesKey,
                                  0,
                                  KEY_READ,
                                  &hKey);

    if (errCode == ERROR_SUCCESS)
    {
        DWORD dwType = 0,
              cbData = 0;

        errCode = RegQueryValueExA (hKey,
                                    CDCommonFilesValueName,
                                    0,
                                    &dwType,
                                    0,
                                    &cbData);

        if (errCode == ERROR_SUCCESS && dwType == REG_SZ)
        {
            char *unicowsPath = (char *)alloca (cbData + strlen (UnicowsName));

            errCode = RegQueryValueExA (hKey,
                                        CDCommonFilesValueName,
                                        0,
                                        &dwType,
                                        (BYTE *)unicowsPath,
                                        &cbData);

            if (errCode == ERROR_SUCCESS)
            {
                if (unicowsPath [strlen (unicowsPath) - 1] == '\\')
                    strcat (unicowsPath, UnicowsName + 1);
                else
                    strcat (unicowsPath, UnicowsName);

                hUnicows = LoadLibraryA (unicowsPath);
            }
        }

        RegCloseKey (hKey);
    }

    if (hUnicows == 0)
    {
        MessageBoxA (0, "Unicode wrapper not found", "My Company", MB_ICONSTOP | MB_OK);

        _exit (-1);
    }

    return hUnicows;
}

extern "C" HMODULE (__stdcall *_PfnLoadUnicows) (void) = &LoadUnicows; 

//
// Wrappers for functions not handled by Godot
//


static BOOL __stdcall UserOleUIAddVerbMenuW(
  LPOLEOBJECT lpOleObj,  //Pointer to the object
  LPCWSTR lpszShortType,  //Pointer to the short name corresponding 
                          // to the object
  HMENU hMenu,            //Handle to the menu to modify
  UINT uPos,              //Position of the menu item.
  UINT uIDVerbMin,        //Value at which to start the verbs
  UINT uIDVerbMax,        //Maximum identifier value for object verbs
  BOOL bAddConvert,       //Whether to add convert item
  UINT idConvert,         //Value to use for the convert item
  HMENU FAR * lphMenu     //Pointer to the cascading verb menu, if 
                          // created
)
{
    USES_CONVERSION;

    return OleUIAddVerbMenuA (lpOleObj,
                              W2CA (lpszShortType),
                              hMenu,
                              uPos,
                              uIDVerbMin,
                              uIDVerbMax,
                              bAddConvert,
                              idConvert,
                              lphMenu);
}

extern "C" FARPROC Unicows_OleUIAddVerbMenuW = (FARPROC)&UserOleUIAddVerbMenuW;

static UINT __stdcall UserOleUIInsertObjectW (LPOLEUIINSERTOBJECTW lpouiiow)
{
    UINT result = OLEUI_CANCEL;

    OLEUIINSERTOBJECTA ouiioa;

    ATLASSERT (sizeof (OLEUIINSERTOBJECTA) == sizeof (OLEUIINSERTOBJECTW));

    memcpy (&ouiioa, lpouiiow, sizeof (OLEUIINSERTOBJECTA));

    ATLASSERT (lpouiiow->lpszCaption == 0);
    ATLASSERT (lpouiiow->lpszTemplate == 0);

    ouiioa.lpszFile = (char *)alloca (ouiioa.cchFile + 1);

    ouiioa.lpszFile [0] = '\0';

    result = OleUIInsertObjectA(&ouiioa);

    if (result == OLEUI_SUCCESS)
    {
        USES_CONVERSION;

        wchar_t *lpszFile = lpouiiow->lpszFile;

        memcpy (lpouiiow, &ouiioa, sizeof (OLEUIINSERTOBJECTW));

        lpouiiow->lpszFile = lpszFile;

        wcscpy (lpouiiow->lpszFile, A2CW (ouiioa.lpszFile));
    }

    return result;
}

extern "C" FARPROC Unicows_OleUIInsertObjectW = (FARPROC)&UserOleUIInsertObjectW;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\oclient\old\mainview.h ===
// mainview.h : interface of the CMainView class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


class CRectItem;

class CMainView : public CScrollView
{
protected: // create from serialization only
	CMainView();
	DECLARE_DYNCREATE(CMainView)

// Attributes
public:
	CMainDoc* GetDocument()
	{
		ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CMainDoc)));
		return (CMainDoc*) m_pDocument;
	}

	CRectItem* GetSelection() const
		{ return m_pSelection; } // Just the top-most window
	// set bSafeSelect to TRUE when there is a chance that an inplace
	// active item could be deactivated before finishing
	void SetSelection(CRectItem* pNewSel, BOOL bSafeSelect = FALSE);

// Operations
public:
	CRectItem* DoPasteItem(BOOL bLink, COleDataObject* pDataObject,
		CPoint* pPoint, CLIPFORMAT cfFormat = 0);
	void ClientToDoc(CRect &rc);
	void DocToClient(CRect &rc);
	void ClientToDoc(CPoint &pt);
	void DocToClient(CPoint &pt);
	void ClientToDoc(CSize &sz);
	void DocToClient(CSize &sz);
	void UpdateActiveItem();


// Implementation
protected:
	BOOL m_bInDrag;
	CRectItem* m_pSelection;
	COleDropTarget m_dropTarget;
	CPoint m_dragPoint;
	CSize m_dragSize;
	CSize m_dragOffset;
	DROPEFFECT m_prevDropEffect;
	static CLIPFORMAT m_cfObjectDescriptor;
	static CBrush NEAR m_brHatch;

	CRectItem* GetHitItem(CPoint point);
	BOOL GetObjectInfo(COleDataObject* pDataObject,
		CSize* pSize, CSize* pOffset);
	void DoPasteNative(COleDataObject* pDataObject, CPoint* pPoint,
		CRectItem* pItem);
	void DoPasteStandard(BOOL bLink, COleDataObject* pDataObject,
		CPoint* pPoint, CRectItem* pItem, CLIPFORMAT cfFormat = 0);

public:
	virtual ~CMainView();
	virtual void OnPrepareDC(CDC* pDC, CPrintInfo* pInfo = NULL);
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual void OnInitialUpdate();
	virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// special scroll handling
	virtual BOOL OnScrollBy(CSize sizeScroll, BOOL bDoScroll = TRUE);

	// drag drop implementation
	virtual BOOL OnDrop(COleDataObject* pDataObject,
		DROPEFFECT dropEffect, CPoint point);
	virtual DROPEFFECT OnDragEnter(COleDataObject* pDataObject,
		DWORD grfKeyState, CPoint point);
	virtual DROPEFFECT OnDragOver(COleDataObject* pDataObject,
		DWORD grfKeyState, CPoint point);
	virtual void OnDragLeave();

	// Printing support
protected:
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);

	// OLE Client support
	virtual BOOL IsSelected(const CObject* pDocItem) const;
	BOOL DoCopySelection();
	void SetupTracker(CRectTracker* pTracker, CRectItem* pItem,
		CRect* pTrueRect = NULL);
	void InvalidateItem(CRectItem* pItem);

// Generated message map functions
protected:
	//{{AFX_MSG(CMainView)
	afx_msg void OnPaste();
	afx_msg void OnPasteLink();
	afx_msg void OnInsertObject();
	afx_msg void OnUpdateEditMenu(CCmdUI* pCmdUI);
	afx_msg void OnEditClear();
	afx_msg void OnEditCopy();
	afx_msg void OnEditCut();
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnObjectDisplayContent();
	afx_msg void OnUpdateObjectDisplayContent(CCmdUI* pCmdUI);
	afx_msg void OnObjectDisplayAsIcon();
	afx_msg void OnUpdateObjectDisplayAsIcon(CCmdUI* pCmdUI);
	afx_msg void OnPasteSpecial();
	afx_msg void OnUpdateEditClone(CCmdUI* pCmdUI);
	afx_msg void OnEditClone();
	afx_msg void OnUpdateEditPaste(CCmdUI* pCmdUI);
	afx_msg void OnObjectResetsize();
	afx_msg void OnCancelInplace();
	afx_msg void OnDestroy();
	afx_msg void OnUpdateOleEditProperties(CCmdUI* pCmdUI);
	afx_msg void OnOleEditProperties();
	afx_msg void OnUpdateOleChangeSource(CCmdUI* pCmdUI);
	afx_msg void OnOleChangeSource();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\oclient\old\oclient.cpp ===
// oclient.cpp : Defines the class behaviors for the application.
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


#include "stdafx.h"
#include <stddef.h>
#include "oclient.h"

#include "frame.h"
#include "maindoc.h"
#include "mainview.h"
#include "splitfra.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// The one and only COleClientApp object

COleClientApp NEAR theApp;

// this is the GUID for OCLIENT documents
static const GUID BASED_CODE clsid =
	{ 0x00021842, 0, 0, { 0xC0, 0, 0, 0, 0, 0, 0, 0x46 } };

/////////////////////////////////////////////////////////////////////////////
// COleClientApp

BEGIN_MESSAGE_MAP(COleClientApp, CWinApp)
	//{{AFX_MSG_MAP(COleClientApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
	// Standard print setup command
	ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
	// Global help commands
	ON_COMMAND(ID_HELP_INDEX, CWinApp::OnHelpIndex)
	ON_COMMAND(ID_HELP_USING, CWinApp::OnHelpUsing)
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
	ON_COMMAND(ID_DEFAULT_HELP, CWinApp::OnHelpIndex)
	ON_COMMAND(ID_CONTEXT_HELP, CWinApp::OnContextHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COleClientApp construction
// Place all significant initialization in InitInstance

COleClientApp::COleClientApp()
{
}

/////////////////////////////////////////////////////////////////////////////
// COleClientApp initialization

BOOL COleClientApp::InitInstance()
{
#if defined(_DEBUG) && !defined(_AFX_NO_DEBUG_CRT)
	// turn on extra memory tracking
	afxMemDF |= checkAlwaysMemDF;
#endif

	// Initialize OLE 2.0 libraries
	if (!AfxOleInit())
	{
		AfxMessageBox(IDP_AFXOLEINIT_FAILED);
		return FALSE;
	}

	// Standard initialization
	Enable3dControls();    // enable 3d controls in dialogs
	LoadStdProfileSettings();  // Load standard INI file options (including MRU)

	// Register document templates
	CMultiDocTemplate* pDocTemplate = new CMultiDocTemplate(IDR_OCLIENTTYPE,
			RUNTIME_CLASS(CMainDoc),
			RUNTIME_CLASS(CSplitFrame),
			RUNTIME_CLASS(CMainView));
	pDocTemplate->SetContainerInfo(IDR_OCLIENTTYPE_CNTR_IP);
	AddDocTemplate(pDocTemplate);

	// create main MDI Frame window
	CMainFrame* pMainFrame = new CMainFrame;
	if (!pMainFrame->LoadFrame(IDR_MAINFRAME))
		return FALSE;
	m_pMainWnd = pMainFrame;

	// enable file manager drag/drop and DDE Execute open
	m_pMainWnd->DragAcceptFiles();

	EnableShellOpen();
	RegisterShellFileTypes(TRUE);

	// connect the COleTemplate server to the document template
	m_server.ConnectTemplate(clsid, pDocTemplate, FALSE);
	COleTemplateServer::RegisterAll();
		// Note: MDI applications register all class objects regardless of
		//  the /Embedding on the command line.

	// Parse command line for standard shell commands, DDE, file open
	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);

	if (RunEmbedded())
	{
		// application was run with /Embedding flag.  Instead of showing
		//  the window, the application waits to receive OLE requests.
		return TRUE;
	}
	// always update system registry when run non-embedded
	m_server.UpdateRegistry(OAT_CONTAINER);

	// Dispatch commands specified on the command line
	if (!ProcessShellCommand(cmdInfo))
		return FALSE;

	pMainFrame->ShowWindow(m_nCmdShow);
	pMainFrame->UpdateWindow();

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// COleClientApp commands

void COleClientApp::OnAppAbout()
{
	CDialog(IDD_ABOUTBOX).DoModal();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\oclient\old\oclient.h ===
// oclient.h : main header file for the OCLIENT application
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// COleClientApp: See oclient.cpp for the implementation of this class

class COleClientApp : public CWinApp
{
public:
	COleClientApp();

// Overrides
	virtual BOOL InitInstance();

// Implementation
protected:
	COleTemplateServer m_server;

	//{{AFX_MSG(COleClientApp)
	afx_msg void OnAppAbout();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\oclient\old\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by oclient.rc
//
#define IDR_MAINFRAME                   2
#define IDR_OCLIENTTYPE                 3
#define IDD_ABOUTBOX                    100
#define IDP_BUSY                        101
#define ID_OBJECT_POPUP_MENU            102
#define IDS_PRIVATE_CF_DESCR            102
#define IDR_OCLIENTTYPE_CNTR_IP         104
#define IDP_CLIPBOARD_CUT_FAILED        0x201
#define IDP_CLIPBOARD_COPY_FAILED       0x202
#define IDP_GET_FROM_CLIPBOARD_FAILED   0x203
#define IDP_FAILED_TO_CREATE            0x204
#define IDP_SAVEINCOMPLETE              0x205
#define IDP_CLIPBOARD_ZERO_SIZE         0x206
#define IDP_AFXOLEINIT_FAILED           519
#define ID_OBJECT_TRACK_SIZE            2000
#define ID_CANCEL_INPLACE               2002
#define ID_OBJECT_DISPLAYCONTENT        2003
#define ID_OBJECT_DISPLAYASICON         2004
#define ID_OBJECT_CHANGEICON            2005
#define ID_EDIT_CLONE                   2006
#define ID_OBJECT_RESETSIZE             2009
#define ID_OLE_CHANGE_SOURCE            2012

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        106
#define _APS_NEXT_COMMAND_VALUE         2013
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           200
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\oclient\old\mainview.cpp ===
// mainview.cpp : implementation of the CMainView class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


#include "stdafx.h"
#include "oclient.h"

#include "maindoc.h"
#include "mainview.h"
#include "rectitem.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainView

CBrush NEAR CMainView::m_brHatch;
CLIPFORMAT CMainView::m_cfObjectDescriptor=NULL;

IMPLEMENT_DYNCREATE(CMainView, CScrollView)

BEGIN_MESSAGE_MAP(CMainView, CScrollView)
	//{{AFX_MSG_MAP(CMainView)
	ON_COMMAND(ID_EDIT_PASTE, OnPaste)
	ON_COMMAND(ID_EDIT_PASTE_LINK, OnPasteLink)
	ON_COMMAND(ID_OLE_INSERT_NEW, OnInsertObject)
	ON_UPDATE_COMMAND_UI(ID_EDIT_CLEAR, OnUpdateEditMenu)
	ON_COMMAND(ID_EDIT_CLEAR, OnEditClear)
	ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
	ON_COMMAND(ID_EDIT_CUT, OnEditCut)
	ON_WM_LBUTTONDBLCLK()
	ON_WM_LBUTTONDOWN()
	ON_WM_SETCURSOR()
	ON_WM_RBUTTONDOWN()
	ON_WM_CHAR()
	ON_WM_SETFOCUS()
	ON_WM_CREATE()
	ON_WM_SIZE()
	ON_COMMAND(ID_OBJECT_DISPLAYCONTENT, OnObjectDisplayContent)
	ON_UPDATE_COMMAND_UI(ID_OBJECT_DISPLAYCONTENT, OnUpdateObjectDisplayContent)
	ON_COMMAND(ID_OBJECT_DISPLAYASICON, OnObjectDisplayAsIcon)
	ON_UPDATE_COMMAND_UI(ID_OBJECT_DISPLAYASICON, OnUpdateObjectDisplayAsIcon)
	ON_COMMAND(ID_EDIT_PASTE_SPECIAL, OnPasteSpecial)
	ON_UPDATE_COMMAND_UI(ID_EDIT_CLONE, OnUpdateEditClone)
	ON_COMMAND(ID_EDIT_CLONE, OnEditClone)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE_SPECIAL, OnUpdateEditPaste)
	ON_COMMAND(ID_OBJECT_RESETSIZE, OnObjectResetsize)
	ON_COMMAND(ID_CANCEL_INPLACE, OnCancelInplace)
	ON_WM_DESTROY()
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, OnUpdateEditPaste)
	ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateEditMenu)
	ON_UPDATE_COMMAND_UI(ID_EDIT_CUT, OnUpdateEditMenu)
	ON_UPDATE_COMMAND_UI(ID_OBJECT_RESETSIZE, OnUpdateEditMenu)
	ON_COMMAND(ID_OLE_CHANGE_SOURCE, OnOleChangeSource)
	ON_UPDATE_COMMAND_UI(ID_OLE_CHANGE_SOURCE, OnUpdateOleChangeSource)
	ON_COMMAND(ID_OLE_EDIT_PROPERTIES, OnOleEditProperties)
	ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_PROPERTIES, OnUpdateOleEditProperties)
	//}}AFX_MSG_MAP
	// Standard printing commands
	ON_COMMAND(ID_FILE_PRINT, CScrollView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, CScrollView::OnFilePrintPreview)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMainView construction/destruction

CMainView::CMainView()
{
	if (m_brHatch.m_hObject == NULL)
		m_brHatch.CreateHatchBrush(HS_DIAGCROSS, RGB(0,0,0));
	if (m_cfObjectDescriptor == NULL)
		m_cfObjectDescriptor =
			(CLIPFORMAT)::RegisterClipboardFormat(_T("Object Descriptor"));

	m_pSelection = NULL;
	m_prevDropEffect = DROPEFFECT_NONE;
	m_bInDrag = FALSE;
}

CMainView::~CMainView()
{
}

void CMainView::OnInitialUpdate()
{
	CScrollView::OnInitialUpdate();

	// We can't pass MM_ANISOTROPIC to SetScrollSizes so we have to convert to MM_TEXT
	CSize size = GetDocument()->GetDocumentSize();
	CClientDC dc(NULL);
	size.cx = MulDiv(size.cx, dc.GetDeviceCaps(LOGPIXELSX), 100);
	size.cy = MulDiv(size.cy, dc.GetDeviceCaps(LOGPIXELSY), 100);
	SetScrollSizes(MM_TEXT, size);
}

/////////////////////////////////////////////////////////////////////////////
// CMainView drawing

void CMainView::OnPrepareDC(CDC* pDC, CPrintInfo* pInfo)
{
	CScrollView::OnPrepareDC(pDC, pInfo);
	// set up a reasonable default context
	pDC->SetTextColor(::GetSysColor(COLOR_WINDOWTEXT));
	pDC->SetBkColor(::GetSysColor(COLOR_WINDOW));

	// LOENGLISH units are based on physical inches
	// We want logical inches so we have to do it differently
	pDC->SetMapMode(MM_ANISOTROPIC);
	pDC->SetViewportExt(
		pDC->GetDeviceCaps(LOGPIXELSX), pDC->GetDeviceCaps(LOGPIXELSY));
	pDC->SetWindowExt(100,-100);
}

void CMainView::SetupTracker(CRectTracker* pTracker, CRectItem* pItem,
	CRect* pTrueRect)
{
	ASSERT(pTracker != NULL);
	ASSERT(pItem != NULL);

	pTracker->m_rect = pItem->GetRect();
	DocToClient(pTracker->m_rect);

	// set minimum size for our OLE items
	pTracker->m_sizeMin.cx = 8;
	pTracker->m_sizeMin.cy = 8;

	pTracker->m_nStyle = 0;

	// setup resize handles if item is selected
	if (pItem == m_pSelection)
		pTracker->m_nStyle |= CRectTracker::resizeInside;

	// put correct border depending on item type
	if (pItem->GetType() == OT_LINK)
		pTracker->m_nStyle |= CRectTracker::dottedLine;
	else
		pTracker->m_nStyle |= CRectTracker::solidLine;

	// put hatching over the item if it is currently open
	if (pItem->GetItemState() == COleClientItem::openState ||
		pItem->GetItemState() == COleClientItem::activeUIState)
	{
		pTracker->m_nStyle |= CRectTracker::hatchInside;
	}

	if (pTrueRect != NULL)
		pTracker->GetTrueRect(pTrueRect);
}

void CMainView::OnDraw(CDC* pDC)
{
	CMainDoc* pDoc = GetDocument();

	ASSERT_VALID(pDC);

	if (!pDC->IsPrinting())
	{
		m_brHatch.UnrealizeObject();
		CPoint point(0, 0);
		pDC->LPtoDP(&point);
		pDC->SetBrushOrg(point.x % 8, point.y % 8);

		CRect rcClip;
		GetClientRect(&rcClip);
		ClientToDoc(rcClip);
		CSize docSize = pDoc->GetDocumentSize();
		if (rcClip.right > docSize.cx)
		{
			CRect rcFill(rcClip);
			rcFill.left = max(rcFill.left,docSize.cx);
			pDC->FillRect(rcFill,&m_brHatch);
		}
		if (rcClip.bottom < -docSize.cy)
		{
			CRect rcFill(rcClip);
			rcFill.top = min(rcFill.top, -docSize.cy);
			pDC->FillRect(rcFill,&m_brHatch);
		}
	}

	// Draw all the CRectItems
	POSITION pos = pDoc->GetStartPosition();
	while (pos != NULL)
	{
		CRectItem* pItem = DYNAMIC_DOWNCAST(CRectItem, pDoc->GetNextItem(pos));
		if (pItem != NULL)
		{
			pItem->Draw(pDC, pItem->GetRect());

			if (!pDC->IsPrinting())
			{
				// draw the tracker
				CRectTracker tracker;
				CRect rectTrue;
				SetupTracker(&tracker, pItem, &rectTrue);
				ClientToDoc(rectTrue);
				if (pDC->RectVisible(&rectTrue))
					tracker.Draw(pDC);
			}
		}
	}
}

// pHint is the deleted item or NULL if deselect/delete all
void CMainView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint)
{
	if (pHint == NULL && lHint == 0)
	{
		// some sort of clear all
		m_pSelection = NULL;
	}

	if (pHint != NULL && pHint->IsKindOf(RUNTIME_CLASS(CRectItem)))
	{
		// just invalidate the one item
		InvalidateItem((CRectItem*)pHint);

		// clear selection if pointing to deleted item
		if (lHint == 1 && pHint == m_pSelection)
		{
			// specific case of pHint being deleted
			m_pSelection = NULL;
		}
	}
	else if (lHint != 0)
	{
		// invalidate arbitrary rectangle
		InvalidateRect((CRect*)lHint);
	}
	else
	{
		// complete update
		CScrollView::OnUpdate(pSender, lHint, pHint);
	}
}

void CMainView::InvalidateItem(CRectItem* pItem)
{
	if (m_nMapMode != 0)
	{
		CRectTracker tracker;
		CRect rect;
		SetupTracker(&tracker, pItem, &rect);
		InvalidateRect(&rect);
	}
}

BOOL CMainView::OnScrollBy(CSize sizeScroll, BOOL bDoScroll)
{
	// remove drag/drop feedback before scrolling
	if (bDoScroll && m_prevDropEffect != DROPEFFECT_NONE)
	{
		CClientDC dc(this);
		dc.DrawFocusRect(CRect(m_dragPoint, m_dragSize));
			// erase previous focus rect
		m_prevDropEffect = DROPEFFECT_NONE;
	}

	// do the scroll
	if (!CScrollView::OnScrollBy(sizeScroll, bDoScroll))
		return FALSE;

	// update the position of any in-place active item
	if (bDoScroll)
	{
		UpdateActiveItem();
		UpdateWindow();
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMainView printing

BOOL CMainView::OnPreparePrinting(CPrintInfo* pInfo)
{
	// default preparation
	return DoPreparePrinting(pInfo);
}

/////////////////////////////////////////////////////////////////////////////
// Selection support

BOOL CMainView::IsSelected(const CObject* pDocItem) const
{
	return (pDocItem == m_pSelection);
}

void CMainView::SetSelection(CRectItem* pNewSel, BOOL bSafeSelect)
{
	if (pNewSel != NULL && pNewSel == m_pSelection)
		return;

	// deactivate any in-place active item on this view!
	COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
	if (pActiveItem != NULL && pNewSel != pActiveItem)
	{
		if (bSafeSelect)
			return;
		// if we found one, deactivate it
		pActiveItem->Close();
		ASSERT(GetDocument()->GetInPlaceActiveItem(this) == NULL);
	}
	if (m_pSelection != NULL) // invalidate the old item
		InvalidateItem(m_pSelection);
	if ((m_pSelection = pNewSel) != NULL) // invalidate the new item
		InvalidateItem(m_pSelection);
}

/////////////////////////////////////////////////////////////////////////////
// CMainView diagnostics

#ifdef _DEBUG
void CMainView::AssertValid() const
{
	CScrollView::AssertValid();
}

void CMainView::Dump(CDumpContext& dc) const
{
	CScrollView::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// Main 'Edit' menu commands

void CMainView::OnUpdateEditMenu(CCmdUI* pCmdUI)
{
	// most Edit menu commands are enabled only if we have a selection
	//  and there are no in-place activations for this view
	pCmdUI->Enable(m_pSelection != NULL &&
		GetDocument()->GetInPlaceActiveItem(this) == NULL);
}

void CMainView::OnEditCut()
{
	ASSERT(m_pSelection != NULL);
	TRY
	{
		m_pSelection->CopyToClipboard(TRUE);
		OnEditClear();
	}
	CATCH_ALL(e)
	{
		AfxMessageBox(IDP_CLIPBOARD_CUT_FAILED);
	}
	END_CATCH_ALL
}

void CMainView::OnEditCopy()
{
	ASSERT(m_pSelection != NULL);
	TRY
	{
		m_pSelection->CopyToClipboard(TRUE);
	}
	CATCH_ALL(e)
	{
		AfxMessageBox(IDP_CLIPBOARD_COPY_FAILED);
	}
	END_CATCH_ALL
}

void CMainView::OnEditClear()
{
	if (m_pSelection != NULL)
		GetDocument()->DeleteItem(m_pSelection);
}

void CMainView::OnPaste()
{
	if (DoPasteItem(FALSE, NULL, NULL) == NULL)
		AfxMessageBox(IDP_GET_FROM_CLIPBOARD_FAILED);
}

void CMainView::OnPasteLink()
{
	if (DoPasteItem(TRUE, NULL, NULL) == NULL)
		AfxMessageBox(IDP_GET_FROM_CLIPBOARD_FAILED);
}

void CMainView::DoPasteNative(
	COleDataObject* pDataObject, CPoint* pPoint, CRectItem* pItem)
{
	// get file refering to clipboard data
	CFile* pFile = pDataObject->GetFileData(CMainDoc::m_cfPrivate);
	if (pFile == NULL)
		{
		// if the file failed to open, throw an exception
		// to force cleanup in DoPasteItem.  the exact
		// type of exception thrown here is unimportant...

		AfxThrowFileException(CFileException::generic);
		}

	CArchive ar(pFile, CArchive::load);
	TRY
	{
		// connect the file to an archive and read the data
		ar.m_pDocument = GetDocument(); // for COleClientItem serialize
		pItem->Serialize(ar);
	}
	CATCH_ALL(e)
	{
		ar.Close();
		delete pFile;
		THROW_LAST();
	}
	END_CATCH_ALL

	ar.Close();
	delete pFile;

	// adjust position to that specified by point
	if (pPoint != NULL)
		pItem->m_ptPos = *pPoint;
}

void CMainView::DoPasteStandard(BOOL bLink, COleDataObject* pDataObject,
	CPoint* pPoint, CRectItem* pItem, CLIPFORMAT cfFormat)
{
	if (bLink)      // paste link
	{
		if (!pItem->CreateLinkFromData(pDataObject))
			AfxThrowMemoryException();  // any exception will do
	}
	// paste embedded
	else if (!pItem->CreateFromData(pDataObject) &&
		!pItem->CreateStaticFromData(pDataObject, OLERENDER_DRAW, cfFormat))
	{
		AfxThrowMemoryException();      // any exception will do
	}

	// copy the current iconic representation
	FORMATETC fmtetc;
	fmtetc.cfFormat = CF_METAFILEPICT;
	fmtetc.dwAspect = DVASPECT_ICON;
	fmtetc.ptd = NULL;
	fmtetc.tymed = TYMED_MFPICT;
	fmtetc.lindex = 1;
	HGLOBAL hObj = pDataObject->GetGlobalData(CF_METAFILEPICT, &fmtetc);
	if (hObj != NULL)
	{
		pItem->SetIconicMetafile(hObj);
		// the following code is an easy way to free a metafile pict
		STGMEDIUM stgMed;
		memset(&stgMed, 0, sizeof(stgMed));
		stgMed.tymed = TYMED_MFPICT;
		stgMed.hGlobal = hObj;
		ReleaseStgMedium(&stgMed);
	}

	// set the current drawing aspect
	hObj = pDataObject->GetGlobalData(m_cfObjectDescriptor);
	if (hObj != NULL)
	{
		ASSERT(hObj != NULL);
		// got CF_OBJECTDESCRIPTOR ok.  Lock it down and extract size.
		LPOBJECTDESCRIPTOR pObjDesc = (LPOBJECTDESCRIPTOR)GlobalLock(hObj);
		ASSERT(pObjDesc != NULL);
		pItem->SetDrawAspect((DVASPECT)pObjDesc->dwDrawAspect);
		GlobalUnlock(hObj);
		GlobalFree(hObj);
	}

	// set top-left based on point of drop
	if (pPoint != NULL)
		pItem->m_ptPos = *pPoint;

	// get size from drag/drop operation
	CSize size;
	if (GetObjectInfo(pDataObject, &size, NULL) && size.cx != 0 && size.cy != 0)
	{
		// use size obtained from object instead of default
		size.cx = MulDiv(size.cx, 10, 254);
		size.cy = -MulDiv(size.cy, 10, 254);
		pItem->SetSize(size);
		CSize sizeExtent;
		pItem->GetCachedExtent(&sizeExtent);
		pItem->SetBaseSize(sizeExtent);
	}
	else
	{
		// no extent from CF_OBJECTDESCRIPTOR, use extent from object
		pItem->UpdateExtent();
	}
}


// Helper for paste/pastelink
//
//                  bLink       pDataObject     pPoint              cfFormat
//  EditPaste       FALSE       NULL(clipboard) NULL(default)       0
//  Drag/Drop       TRUE/FALSE  X               X                   0
//  PasteLink       TRUE        NULL(clipboard) NULL(default)       0
//  PasteSpecial    TRUE/FALSE  X               NULL(default)       X
CRectItem* CMainView::DoPasteItem(BOOL bLink, COleDataObject* pDataObject,
	CPoint* pPoint, CLIPFORMAT cfFormat)
{
	BeginWaitCursor();

	CRectItem* pItem = GetDocument()->CreateItem();
	ASSERT_VALID(pItem);
	BOOL bAllowAdjust = (pPoint == NULL) ? TRUE : FALSE;

	// use clipboard data if not doing drag/drop
	COleDataObject clipboardData;
	if (pDataObject == NULL)
	{
		clipboardData.AttachClipboard();
		pDataObject = &clipboardData;
	}

	TRY
	{
		if (cfFormat == CMainDoc::m_cfPrivate)
		{
			// if format specified (i.e. PasteSpecial) then use that one
			DoPasteNative(pDataObject, pPoint, pItem);
		}
		else if (!bLink && cfFormat == 0 &&
			pDataObject->IsDataAvailable(CMainDoc::m_cfPrivate))
		{
			// if we're not pasting a link, cfFormat was unspecified,
			// and private format is available use it
			DoPasteNative(pDataObject, pPoint, pItem);
		}
		// otherwise perform a standard paste
		else if (bAllowAdjust)
		{
			CPoint ptDef(10, -10);
			DoPasteStandard(bLink, pDataObject, &ptDef, pItem, cfFormat);
		}
		else
		{
			DoPasteStandard(bLink, pDataObject, pPoint, pItem, cfFormat);
		}

		if (bAllowAdjust)
		{
			// allow document to adjust position of item so that it doesn't
			// lay directly over an item of the same size
			// this only occurs if the drop point is not specified
			GetDocument()->AdjustItemPosition(pItem);
		}
	}
	CATCH_ALL(e)
	{
		// general cleanup
		TRACE0("failed to embed/link an OLE object\n");
		pItem->Delete();
		pItem = NULL;
	}
	END_CATCH_ALL

	// set the selection with bSafeSelect = TRUE
	SetSelection(pItem, TRUE);

	// update the document and views
	GetDocument()->SetModifiedFlag();
	GetDocument()->UpdateAllViews(NULL, 0, pItem);      // including this view

	EndWaitCursor();

	return pItem;
}

/////////////////////////////////////////////////////////////////////////////
// Insert New Object and Activate Object

void CMainView::OnInsertObject()
{
	COleInsertDialog dlg;
	if (dlg.DoModal() != IDOK)
		return;

	BeginWaitCursor();

	CRectItem* pItem = NULL;
	TRY
	{
		// create item from dialog results
		pItem = GetDocument()->CreateItem();
		if (!dlg.CreateItem(pItem))
			AfxThrowMemoryException();  // any exception will do

		// try to get initial presentation data
		pItem->UpdateLink();
		pItem->UpdateExtent();

		// if insert new object -- initially show the object
		if (dlg.GetSelectionType() == COleInsertDialog::createNewItem)
			pItem->DoVerb(OLEIVERB_SHOW, this);

		SetSelection(pItem);
	}
	CATCH_ALL(e)
	{
		// cleanup item, if allocated
		if (pItem != NULL)
			GetDocument()->DeleteItem(pItem);

		AfxMessageBox(IDP_FAILED_TO_CREATE);
	}
	END_CATCH_ALL

	EndWaitCursor();
}

void CMainView::OnLButtonDblClk(UINT, CPoint)
{
	// Double click will activate the main verb
	if (m_pSelection != NULL)
	{
		BeginWaitCursor();
		LONG iVerb = OLEIVERB_PRIMARY;
		if (GetKeyState(VK_CONTROL) < 0)
			iVerb = OLEIVERB_OPEN;
		m_pSelection->DoVerb(iVerb, this);
		EndWaitCursor();
	}
}

/////////////////////////////////////////////////////////////////////////////
// Hit detection, moving and resizing items

CRectItem* CMainView::GetHitItem(CPoint point)
{
	CMainDoc* pDoc = GetDocument();
	CRectItem* pItemHit = NULL;

	// Find the item hit by the mouse
	POSITION pos = pDoc->GetStartPosition();
	while (pos != NULL)
	{
		CRectItem* pItem = DYNAMIC_DOWNCAST(CRectItem, pDoc->GetNextItem(pos));
		if (pItem != NULL)
		{
			CRectTracker tracker;
			SetupTracker(&tracker, pItem);
			if (tracker.HitTest(point) >= 0)
			{
				pItemHit = pItem;
				// items later in the list are drawn on top - so keep looking
			}
		}
	}
	return pItemHit;
}

void CMainView::DocToClient(CRect& rect)
{
	CClientDC dc(this);
	OnPrepareDC(&dc);
	dc.LPtoDP(&rect); // convert logical rect to device rect
	rect.NormalizeRect();
}

void CMainView::ClientToDoc(CRect& rect)
{
	CClientDC dc(this);
	OnPrepareDC(&dc);
	dc.DPtoLP(&rect); // convert device rect to logical rect
}

void CMainView::DocToClient(CSize& size)
{
	CClientDC dc(this);
	OnPrepareDC(&dc);
	dc.LPtoDP(&size); // convert logical size to device size
	size.cx = abs(size.cx);
	size.cy = abs(size.cy);
}

void CMainView::ClientToDoc(CSize& size)
{
	CClientDC dc(this);
	OnPrepareDC(&dc);
	dc.DPtoLP(&size); // convert device rect to logical rect
	size.cx = abs(size.cx);
	size.cy = abs(size.cy);
}

void CMainView::DocToClient(CPoint& point)
{
	CClientDC dc(this);
	OnPrepareDC(&dc);
	dc.LPtoDP(&point); // convert logical point to device point
}

void CMainView::ClientToDoc(CPoint& point)
{
	CClientDC dc(this);
	OnPrepareDC(&dc);
	dc.DPtoLP(&point); // convert device point to logical point
}

void CMainView::OnLButtonDown(UINT /*nFlags*/, CPoint point)
{
	CRectItem* pItemHit = GetHitItem(point);
	SetSelection(pItemHit);
	if (pItemHit == NULL)
		return;

	CRect rectLimit;
	GetClientRect(rectLimit);

	CRectTracker tracker;
	SetupTracker(&tracker, pItemHit);

	UpdateWindow(); // update before entering the tracker
	if (tracker.HitTest(point) == CRectTracker::hitMiddle) // moving, not sizing
	{
		// determine mouse position offset from the item itself
		CRect rect = pItemHit->GetRect();
		DocToClient(rect);
		CPoint ptOffset(point.x - rect.left, point.y - rect.top);

		// determine sensitivity rectangle (determines when drag starts)
		CRect rectDrag(rect.left, rect.top, rect.left+1, rect.top+1);

		// execute the drag/drop operation
		m_bInDrag = TRUE;
		ClientToScreen(&rect);  // must be in screen co-ordinates
		ClientToScreen(&rectDrag);
		DROPEFFECT dropEffect = pItemHit->DoDragDrop(rect, ptOffset,
			TRUE, DROPEFFECT_COPY|DROPEFFECT_MOVE, &rectDrag);
		if (m_bInDrag == FALSE) // move in same window
			return;
		m_bInDrag = FALSE;

		if (dropEffect == DROPEFFECT_MOVE)
		{
			// the item was moved (essentially a copy w/delete)
			pItemHit->Invalidate();
			if (m_pSelection == pItemHit)
				m_pSelection = NULL;
			GetDocument()->DeleteItem(pItemHit);
		}
	}
	else if (tracker.Track(this, point))
	{
		ClientToDoc(tracker.m_rect);
		pItemHit->Move(tracker.m_rect);
		GetDocument()->SetModifiedFlag();
	}
}

BOOL CMainView::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
{
	if (pWnd == this && m_pSelection != NULL)
	{
		// give the tracker for the selection a chance
		CRectTracker tracker;
		SetupTracker(&tracker, m_pSelection);
		if (tracker.SetCursor(this, nHitTest))
			return TRUE;
	}
	return CScrollView::OnSetCursor(pWnd, nHitTest, message);
}

/////////////////////////////////////////////////////////////////////////////
// Right mouse for popup context sensitive menu

void CMainView::OnRButtonDown(UINT, CPoint point)
{
	// make sure window is active
	GetParentFrame()->ActivateFrame();

	SetSelection(GetHitItem(point));    // reselect item if appropriate
	UpdateWindow();

	if (m_pSelection != NULL)
	{
		CMenu bar;
		if (bar.LoadMenu(ID_OBJECT_POPUP_MENU))
		{
			CMenu& popup = *bar.GetSubMenu(0);
			ASSERT(popup.m_hMenu != NULL);

			ClientToScreen(&point);
			popup.TrackPopupMenu(TPM_RIGHTBUTTON,
				point.x, point.y,
				AfxGetMainWnd()); // route commands through main window
		}
	}
}

void CMainView::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	MessageBeep(0);     // to test for proper focus transfer

	CScrollView::OnChar(nChar, nRepCnt, nFlags);
}

void CMainView::OnSetFocus(CWnd* pOldWnd)
{
	COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
	if (pActiveItem != NULL &&
		pActiveItem->GetItemState() == COleClientItem::activeUIState)
	{
		// need to set focus to this item if it is in the same view
		CWnd* pWnd = pActiveItem->GetInPlaceWindow();
		if (pWnd != NULL)
		{
			pWnd->SetFocus();
			return;
		}
	}

	CScrollView::OnSetFocus(pOldWnd);
}

void CMainView::OnSize(UINT nType, int cx, int cy)
{
	CScrollView::OnSize(nType, cx, cy);

	UpdateActiveItem();
}

/////////////////////////////////////////////////////////////////////////////
// support for drag/drop

int CMainView::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CScrollView::OnCreate(lpCreateStruct) == -1)
		return -1;

	// register drop target
	m_dropTarget.Register(this);

	return 0;
}

BOOL CMainView::OnDrop(COleDataObject* pDataObject,
	DROPEFFECT dropEffect, CPoint point)
{
	ASSERT_VALID(this);

	// clean up focus rect
	OnDragLeave();

	// offset point as appropriate for dragging
	GetObjectInfo(pDataObject, &m_dragSize, &m_dragOffset);
	CClientDC dc(NULL);
	dc.HIMETRICtoDP(&m_dragSize);
	dc.HIMETRICtoDP(&m_dragOffset);
	point -= m_dragOffset;

	// if move within the view
	ClientToDoc(point);
	if ((dropEffect & DROPEFFECT_MOVE) && m_bInDrag)
	{
		ASSERT(m_pSelection != NULL);
		m_bInDrag = FALSE; // signal drag code that a move happened
		// set top-left based on point of drop
		CRect rect = m_pSelection->GetRect();
		if (rect.TopLeft() != point) // if moved
		{
			m_pSelection->Move(CRect(point,rect.Size()));
			GetDocument()->SetModifiedFlag();
		}
	}
	// check and paste link
	else if ((dropEffect & DROPEFFECT_LINK) && DoPasteItem(TRUE, pDataObject, &point))
		return TRUE;

	// paste embedding/static
	else if (DoPasteItem(FALSE, pDataObject, &point))
		return TRUE;

	return FALSE;
}

BOOL CMainView::GetObjectInfo(COleDataObject* pDataObject,
	CSize* pSize, CSize* pOffset)
{
	ASSERT(pSize != NULL);

	// get object descriptor data
	HGLOBAL hObjDesc = pDataObject->GetGlobalData(m_cfObjectDescriptor);
	if (hObjDesc == NULL)
	{
		if (pOffset != NULL)
			*pOffset = CSize(0, 0); // fill in defaults instead
		*pSize = CSize(0, 0);
		return FALSE;
	}
	ASSERT(hObjDesc != NULL);

	// otherwise, got CF_OBJECTDESCRIPTOR ok.  Lock it down and extract size.
	LPOBJECTDESCRIPTOR pObjDesc = (LPOBJECTDESCRIPTOR)GlobalLock(hObjDesc);
	ASSERT(pObjDesc != NULL);
	pSize->cx = (int)pObjDesc->sizel.cx;
	pSize->cy = (int)pObjDesc->sizel.cy;
	if (pOffset != NULL)
	{
		pOffset->cx = (int)pObjDesc->pointl.x;
		pOffset->cy = (int)pObjDesc->pointl.y;
	}
	GlobalUnlock(hObjDesc);
	GlobalFree(hObjDesc);

	// successfully retrieved pSize & pOffset info
	return TRUE;
}

DROPEFFECT CMainView::OnDragEnter(COleDataObject* pDataObject,
	DWORD grfKeyState, CPoint point)
{
	ASSERT(m_prevDropEffect == DROPEFFECT_NONE);

	GetObjectInfo(pDataObject, &m_dragSize, &m_dragOffset);
	CClientDC dc(NULL);
	dc.HIMETRICtoDP(&m_dragSize);
	dc.HIMETRICtoDP(&m_dragOffset);

	return OnDragOver(pDataObject, grfKeyState, point);
}

DROPEFFECT CMainView::OnDragOver(COleDataObject*,
	DWORD grfKeyState, CPoint point)
{
	point -= m_dragOffset;  // adjust target rect by original cursor offset

	// check for point outside logical area -- i.e. in hatched region
	// GetTotalSize() returns the size passed to SetScrollSizes
	CRect rectScroll(CPoint(0, 0), GetTotalSize());

	CRect rectItem(point,m_dragSize);
	if (rectItem.IsRectEmpty())
	{
		// some apps might have a null size in the object descriptor...
		rectItem.InflateRect(1,1);
	}
	rectItem.OffsetRect(GetDeviceScrollPosition());

	DROPEFFECT de = DROPEFFECT_NONE;
	CRect rectTemp;
	if (rectTemp.IntersectRect(rectScroll, rectItem))
	{
		// check for force link
		if ((grfKeyState & (MK_CONTROL|MK_SHIFT)) == (MK_CONTROL|MK_SHIFT))
			de = DROPEFFECT_LINK;
		// check for force copy
		else if ((grfKeyState & MK_CONTROL) == MK_CONTROL)
			de = DROPEFFECT_COPY;
		// check for force move
		else if ((grfKeyState & MK_ALT) == MK_ALT)
			de = DROPEFFECT_MOVE;
		// default -- recommended action is move
		else
			de = DROPEFFECT_MOVE;
	}

	if (point == m_dragPoint)
		return de;

	// otherwise, cursor has moved -- need to update the drag feedback
	CClientDC dc(this);
	if (m_prevDropEffect != DROPEFFECT_NONE)
	{
		// erase previous focus rect
		dc.DrawFocusRect(CRect(m_dragPoint, m_dragSize));
	}
	m_prevDropEffect = de;
	if (m_prevDropEffect != DROPEFFECT_NONE)
	{
		m_dragPoint = point;
		dc.DrawFocusRect(CRect(point, m_dragSize));
	}
	return de;
}

void CMainView::OnDragLeave()
{
	CClientDC dc(this);
	if (m_prevDropEffect != DROPEFFECT_NONE)
	{
		dc.DrawFocusRect(CRect(m_dragPoint,m_dragSize)); // erase previous focus rect
		m_prevDropEffect = DROPEFFECT_NONE;
	}
}

/////////////////////////////////////////////////////////////////////////////
// Commands for switching display aspects

void CMainView::OnObjectDisplayContent()
{
	if (m_pSelection == NULL)
		return;
	ASSERT_VALID(m_pSelection);
	m_pSelection->Invalidate();
	m_pSelection->SetDrawAspect(DVASPECT_CONTENT);
	m_pSelection->UpdateExtent();
	m_pSelection->Invalidate();
}

void CMainView::OnUpdateObjectDisplayContent(CCmdUI* pCmdUI)
{
	if (m_pSelection == NULL)
	{
		pCmdUI->Enable(FALSE);
		return;
	}
	ASSERT_VALID(m_pSelection);
	pCmdUI->SetCheck(m_pSelection->GetDrawAspect() == DVASPECT_CONTENT);
	pCmdUI->Enable(TRUE);
}

void CMainView::OnObjectDisplayAsIcon()
{
	if (m_pSelection == NULL)
		return;
	ASSERT_VALID(m_pSelection);
	m_pSelection->Invalidate();
	m_pSelection->SetDrawAspect(DVASPECT_ICON);
	m_pSelection->UpdateExtent();
	m_pSelection->Invalidate();
}

void CMainView::OnUpdateObjectDisplayAsIcon(CCmdUI* pCmdUI)
{
	if (m_pSelection == NULL)
	{
		pCmdUI->Enable(FALSE);
		return;
	}
	ASSERT_VALID(m_pSelection);
	pCmdUI->SetCheck(m_pSelection->GetDrawAspect() == DVASPECT_ICON);
	pCmdUI->Enable(TRUE);
}

void CMainView::UpdateActiveItem()
{
	// when there is an active item visible, sizing the window may cause
	//  more/less of the in-place object to become visible.
	//  (ie. the clipping rectangle changes with the size of the window)
	// a container supporting scrolling would also have to do this
	//  when scrolling the contents of the window.

	COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
	if (pActiveItem != NULL &&
		pActiveItem->GetItemState() == COleClientItem::activeUIState &&
		pActiveItem->GetActiveView() == this)
	{
		// this will update the item rectangles by calling
		//  OnGetPosRect & OnGetClipRect.
		pActiveItem->SetItemRects();
	}
}

void CMainView::OnUpdateEditClone(CCmdUI* pCmdUI)
{
	pCmdUI->Enable(m_pSelection != NULL);
}

void CMainView::OnEditClone()
{
	if (m_pSelection == NULL)
		return;

	BeginWaitCursor();

	CRectItem* pItem = NULL;
	TRY
	{
		// create item from dialog results
		pItem = GetDocument()->CreateItem();
		if (!pItem->CreateCloneFrom(m_pSelection))
			AfxThrowMemoryException();  // any exception will do

		// offset it so we can see the clone easier
		CRect rect(20, 20, 0, 0);
		ClientToDoc(rect);
		pItem->m_ptPos.x += rect.left;
		pItem->m_ptPos.y += rect.top;
		ASSERT_VALID(pItem);
	}
	CATCH_ALL(e)
	{
		// cleanup item, if allocated
		if (pItem != NULL)
			GetDocument()->DeleteItem(pItem);

		AfxMessageBox(IDP_FAILED_TO_CREATE);
	}
	END_CATCH_ALL

	EndWaitCursor();
}

void CMainView::OnPasteSpecial()
{
	COlePasteSpecialDialog dlg;
	dlg.AddFormat(CMainDoc::m_cfPrivate, TYMED_HGLOBAL,
		IDS_PRIVATE_CF_DESCR, FALSE, FALSE);
	dlg.AddStandardFormats();
	if (dlg.DoModal() != IDOK)
		return;

	CRectItem* pItem = NULL;
	TRY
	{
		// Get the clipboard format of the selected
		CLIPFORMAT cf = dlg.m_ps.arrPasteEntries[dlg.m_ps.nSelectedIndex].fmtetc.cfFormat;
		if (cf == CMainDoc::m_cfPrivate)
		{
			BOOL bLink = dlg.GetSelectionType() ==
				COlePasteSpecialDialog::pasteLink;
			COleDataObject dataObject;
			dataObject.Attach(dlg.m_ps.lpSrcDataObj, FALSE);
			pItem = DoPasteItem(bLink, &dataObject, NULL, cf);

			// try to get initial presentation data
			pItem->UpdateLink();
		}
		else
		{
			pItem = GetDocument()->CreateItem();
			if (!dlg.CreateItem(pItem))
			{
				TRACE0("Warning: paste special failed to create item.\n");
				AfxThrowMemoryException();
			}

			// try to get initial presentation data
			pItem->UpdateLink();

			// try to get initial extent
			pItem->UpdateExtent();

			// allow document to offset item to avoid direct superimposition
			GetDocument()->AdjustItemPosition(pItem);

			// set the selection with bSafeSelect = TRUE
			SetSelection(pItem, TRUE);
			GetDocument()->SetModifiedFlag();
			GetDocument()->UpdateAllViews(NULL, 0, pItem);
		}
	}
	CATCH_ALL(e)
	{
		// cleanup item, if allocated
		if (pItem != NULL)
			GetDocument()->DeleteItem(pItem);
		AfxMessageBox(IDP_FAILED_TO_CREATE);
		return;
	}
	END_CATCH_ALL
}

void CMainView::OnUpdateEditPaste(CCmdUI* pCmdUI)
{
	// determine if private or standard OLE formats are on the clipboard
	COleDataObject dataObj;
	BOOL bEnable = dataObj.AttachClipboard() &&
		(dataObj.IsDataAvailable(CMainDoc::m_cfPrivate) ||
		 COleClientItem::CanCreateFromData(&dataObj));

	// enable command based on availability
	pCmdUI->Enable(bEnable);
}

void CMainView::OnObjectResetsize()
{
	ASSERT(m_pSelection != NULL);
	m_pSelection->ResetSize();
}

void CMainView::OnCancelInplace()
{
	// deactivate the inplace active item on this frame/view
	COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
	if (pActiveItem != NULL)
		pActiveItem->Deactivate();
	ASSERT(GetDocument()->GetInPlaceActiveItem(this) == NULL);
}

void CMainView::OnDestroy()
{
	CScrollView::OnDestroy();

	// deactivate the inplace active item on this view
	COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
	if (pActiveItem != NULL && pActiveItem->GetActiveView() == this)
	{
		pActiveItem->Deactivate();
		ASSERT(GetDocument()->GetInPlaceActiveItem(this) == NULL);
	}
}

void CMainView::OnUpdateOleEditProperties(CCmdUI* pCmdUI)
{
	pCmdUI->Enable(m_pSelection != NULL);
}

// edit properties dialog specific to OCLIENT
class COlePropertiesEx : public COlePropertiesDialog
{
public:
	COlePropertiesEx(COleClientItem* pItem,
		UINT nScaleMin = 10, UINT nScaleMax = 500, CWnd* pParentWnd = NULL)
		: COlePropertiesDialog(pItem, nScaleMin, nScaleMax, pParentWnd)
		{ }

	virtual BOOL OnApplyScale(
		COleClientItem* pItem, int nCurrentScale, BOOL bRelativeToOrig);
};

BOOL COlePropertiesEx::OnApplyScale(
	COleClientItem* pItem, int nCurrentScale, BOOL bRelativeToOrig)
{
	if (nCurrentScale != -1)
	{
		ASSERT_VALID(pItem);
		CRectItem* pRectItem = (CRectItem*)pItem;
		ASSERT_KINDOF(CRectItem, pRectItem);

		// reset to original size if necessary
		if (bRelativeToOrig)
			pRectItem->ResetSize();

		// update extent to reflect scaling factor
		pRectItem->Invalidate();
		CSize size = pRectItem->GetSize();
		size.cx = MulDiv(size.cx, nCurrentScale, 100);
		size.cy = MulDiv(size.cy, nCurrentScale, 100);
		pRectItem->SetSize(size);
		pRectItem->Invalidate();
	}
	return TRUE;
}

void CMainView::OnOleEditProperties()
{
	ASSERT(m_pSelection != NULL);

	COlePropertiesEx dlg(m_pSelection);
	dlg.DoModal();
}

void CMainView::OnUpdateOleChangeSource(CCmdUI* pCmdUI)
{
	pCmdUI->Enable(m_pSelection != NULL && m_pSelection->GetType() == OT_LINK);
}

void CMainView::OnOleChangeSource()
{
	ASSERT(m_pSelection != NULL && m_pSelection->GetType() == OT_LINK);

	COleChangeSourceDialog dlg(m_pSelection);
	dlg.DoModal();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\oclient\old\rectitem.cpp ===
// rectitem.cpp : implementation of the CRectItem class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


#include "stdafx.h"
#include <afxpriv.h>
#include "oclient.h"

#include "maindoc.h"
#include "mainview.h"
#include "rectitem.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_SERIAL(CRectItem, COleClientItem, 0)

CRectItem::CRectItem(COleDocument* pContainer) : COleClientItem(pContainer) ,
	m_ptPos(10, -10), m_sizeContent(0,0), m_sizeIcon(0,0),
	m_sizeContentExtent(0, 0), m_sizeIconExtent(0, 0)
{
}

CRectItem::CRectItem() : m_ptPos(10, -10), m_sizeContent(0,0), m_sizeIcon(0,0),
	m_sizeContentExtent(0, 0), m_sizeIconExtent(0, 0)
{
}

CRectItem::~CRectItem()
{
}

void CRectItem::Invalidate(CView* pNotThisView)
{
	GetDocument()->UpdateAllViews(pNotThisView, 0, this);
}

/////////////////////////////////////////////////////////////////////////////

CSize CRectItem::GetSize()
{
	DVASPECT dv = GetDrawAspect();
	if (dv == DVASPECT_ICON)
		return m_sizeIcon;
	else
		return m_sizeContent;
}

CSize CRectItem::GetBaseSize()
{
	DVASPECT dv = GetDrawAspect();
	if (dv == DVASPECT_ICON)
		return m_sizeIconExtent;
	else
		return m_sizeContentExtent;
}

void CRectItem::SetSize(CSize size)
{
	DVASPECT dv = GetDrawAspect();
	if (dv == DVASPECT_ICON)
		m_sizeIcon = size;
	else
		m_sizeContent = size;
}

void CRectItem::SetBaseSize(CSize size)
{
	DVASPECT dv = GetDrawAspect();
	if (dv == DVASPECT_ICON)
		m_sizeIconExtent = size;
	else
		m_sizeContentExtent = size;
}

void CRectItem::SetRect(CRect& rect)
{
	m_ptPos = rect.TopLeft();
	SetSize(rect.Size());
}

BOOL CRectItem::UpdateExtent()
{
	// get size in pixels
	CSize size;
	if (!GetCachedExtent(&size))
		return FALSE;       // blank
	Invalidate();   // invalidate the old size/position
	CSize sizeBase = GetBaseSize();
	if (size == sizeBase) // no change
		return FALSE;
	// if new object (i.e. m_extent is empty) setup position
	if (sizeBase == CSize(0,0))
	{
		// convert to document coords
		CSize sizeNew(MulDiv(size.cx, 10, 254), - MulDiv(size.cy, 10, 254));
		SetSize(sizeNew);
	}
	else
	{
		if (!IsInPlaceActive() && size != sizeBase)
		{
			// data changed and not inplace, so scale up rect as well
			CSize sizeCur = GetSize();
			sizeCur.cx = MulDiv(sizeCur.cx, size.cx, sizeBase.cx);
			sizeCur.cy = - MulDiv(-sizeCur.cy, size.cy, sizeBase.cy);
			SetSize(sizeCur);
		}
	}
	SetBaseSize(size);
	Invalidate();   // as well as the new size/position
	return TRUE;
}

BOOL CRectItem::OnChangeItemPosition(const CRect& rectPos)
{
	CMainView* pView = GetActiveView();
	if (pView == NULL)
		return FALSE;
	ASSERT_VALID(pView);

	CRect rc = rectPos;
	pView->ClientToDoc(rc);

	if (rc != GetRect())
	{
		// invalidate old item
		Invalidate();
		// update to new rectangle
		SetRect(rc);

		GetDocument()->SetModifiedFlag();
		CSize sizeExtent;
		GetCachedExtent(&sizeExtent);
		SetBaseSize(sizeExtent);

		// and invalidate new
		Invalidate();
	}
	return COleClientItem::OnChangeItemPosition(rectPos);
}

void CRectItem::OnActivate()
{
	// allow only one inplace active item per frame
	CMainView* pView = GetActiveView();
	ASSERT_VALID(pView);
	COleClientItem* pItem = GetDocument()->GetInPlaceActiveItem(pView);
	if (pItem != NULL && pItem != this)
		pItem->Close();

	COleClientItem::OnActivate();

	// set selection to an item when it becomes active
	pView->SetSelection(this);
}

void CRectItem::OnDeactivateUI(BOOL bUndoable)
{
	COleClientItem::OnDeactivateUI(bUndoable);

	// hide the object if it is not an outside-in object
	DWORD dwMisc = 0;
	m_lpObject->GetMiscStatus(GetDrawAspect(), &dwMisc);
	if (dwMisc & OLEMISC_INSIDEOUT)
		DoVerb(OLEIVERB_HIDE, NULL);
}

void CRectItem::OnChange(OLE_NOTIFICATION nCode, DWORD dwParam)
{
	COleClientItem::OnChange(nCode, dwParam);
	switch(nCode)
	{
		case OLE_CHANGED:
			UpdateExtent();
			Invalidate();
			break;
		case OLE_CHANGED_ASPECT:
		case OLE_CHANGED_STATE:
			Invalidate();
			break;
	}
}

void CRectItem::OnGetItemPosition(CRect& rPosition)
{
	ASSERT_VALID(this);

	if (GetSize() == CSize(0,0))
		UpdateExtent();

	// copy m_rect, which is in document coordinates
	rPosition = GetRect();
	CMainView* pView = GetActiveView();
	ASSERT_VALID(pView);
	pView->DocToClient(rPosition);
}

void CRectItem::Move(CRect &rc)
{
	// invalidate old rect
	Invalidate();
	// invalidate new
	SetRect(rc);
	Invalidate();

	// update item rect when in-place active
	if (IsInPlaceActive())
		SetItemRects();
}

void CRectItem::Serialize(CArchive& ar)
{
	CRect rect;

	// IMPORTANT: when using "easy" serialize -- call base class FIRST!
	//  (not strictly necessary, but a good idea)
	COleClientItem::Serialize(ar);

	// now store/retrieve data specific to CRectItem
	if (ar.IsStoring())
	{
		WORD w = 0x5500;        // magic value
		ar << w << m_ptPos << m_sizeIcon << m_sizeIconExtent <<
			m_sizeContent << m_sizeContentExtent;
	}
	else
	{
		WORD w;
		ar >> w >> m_ptPos >> m_sizeIcon >> m_sizeIconExtent >>
			m_sizeContent >> m_sizeContentExtent;
		if (w != 0x5500)
		{
			TRACE0("Bad magic number in front of an item wnd\n");
			AfxThrowArchiveException(CArchiveException::generic);
		}
	}
}

void CRectItem::ResetSize()
{
	ASSERT_VALID(this);
	Invalidate();
	SetBaseSize(CSize(0, 0));
	UpdateExtent();
}

// OnGetClipboardData is used by CopyToClipboard and DoDragDrop
COleDataSource* CRectItem::OnGetClipboardData(
	BOOL bIncludeLink, LPPOINT lpOffset, LPSIZE lpSize)
{
	ASSERT_VALID(this);

	COleDataSource* pDataSource = new COleDataSource;
	TRY
	{
		GetNativeClipboardData(pDataSource);
		GetClipboardData(pDataSource, bIncludeLink, lpOffset, lpSize);
	}
	CATCH_ALL(e)
	{
		delete pDataSource;
		THROW_LAST();
	}
	END_CATCH_ALL

	ASSERT_VALID(pDataSource);
	return pDataSource;
}

void CRectItem::GetNativeClipboardData(COleDataSource* pDataSource)
{
	ASSERT_VALID(this);
	ASSERT_VALID(GetDocument());

	// Create a shared file and associate a CArchive with it
	CSharedFile file;
	CArchive ar(&file, CArchive::store);

	// Serialize selected objects to the archive
	Serialize(ar);
	ar.Close();
	pDataSource->CacheGlobalData(CMainDoc::m_cfPrivate, file.Detach());
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\oclient\old\rectitem.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


// class CRectItem - main COleClientItem bounded by a rectangle

class CMainDoc;
class CMainView;

class CRectItem : public COleClientItem
{
	DECLARE_SERIAL(CRectItem)
	CRectItem();

public:
	CRectItem(COleDocument* pContainer);
	~CRectItem();

// Attributes
	CPoint m_ptPos;             //position in document
	CSize GetSize();            //current size
	void SetSize(CSize size);
	CSize GetBaseSize();        //base size
	void SetBaseSize(CSize size);
	CRect GetRect()             //current rect
		{ return CRect(m_ptPos, GetSize()); }
	void SetRect(CRect& rect);

	CMainDoc* GetDocument()
		{ return (CMainDoc*)COleClientItem::GetDocument(); }
	CMainView* GetActiveView()
		{ return (CMainView*)COleClientItem::GetActiveView(); }

// Operations
	void Dirty()
		{ GetDocument()->SetModifiedFlag(); }
	void Invalidate(CView* pNotThisView = NULL);
	BOOL UpdateExtent();
	void Move(CRect &rc);
	void ResetSize();
	void GetNativeClipboardData(COleDataSource *pDataSource);

	virtual void Serialize(CArchive& ar); // from CObject - public to call directly

// Overridables
protected:
	virtual void OnChange(OLE_NOTIFICATION wNotification, DWORD dwParam);
	virtual BOOL OnChangeItemPosition(const CRect& rectPos);
	virtual void OnActivate();
	virtual COleDataSource* OnGetClipboardData(BOOL bIncludeLink,
		LPPOINT lpOffset, LPSIZE lpSize);
	virtual void OnDeactivateUI(BOOL bUndoable);

public:
	virtual void OnGetItemPosition(CRect& rPosition);
protected:
	CSize m_sizeIcon;           //current size
	CSize m_sizeContent;        //current size
	CSize m_sizeIconExtent;     //default size
	CSize m_sizeContentExtent;  //default size
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\oclient\old\splitfra.cpp ===
// splitfra.cpp : implementation of the CSplitFrame class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


#include "stdafx.h"
#include "oclient.h"
#include "splitfra.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSplitFrame

IMPLEMENT_DYNCREATE(CSplitFrame, CMDIChildWnd)

CSplitFrame::CSplitFrame()
{
}

CSplitFrame::~CSplitFrame()
{
}

BOOL CSplitFrame::OnCreateClient(LPCREATESTRUCT /*lpcs*/, CCreateContext* pContext)
{
	return m_wndSplitter.Create(this,
		2, 2,       // TODO: adjust the number of rows, columns
		CSize(10, 10),  // TODO: adjust the minimum pane size
		pContext);
}

BEGIN_MESSAGE_MAP(CSplitFrame, CMDIChildWnd)
	//{{AFX_MSG_MAP(CSplitFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSplitFrame message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\oclient\old\splitfra.h ===
// splitfra.h : main header file for the CSplitFrame class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


/////////////////////////////////////////////////////////////////////////////
// CSplitFrame frame with splitter

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

class CSplitFrame : public CMDIChildWnd
{
	DECLARE_DYNCREATE(CSplitFrame)
protected:
	CSplitFrame();          // protected constructor used by dynamic creation

// Attributes
protected:
	CSplitterWnd    m_wndSplitter;
public:

// Operations
public:

// Implementation
public:
	virtual ~CSplitFrame();
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);

	// Generated message map functions
	//{{AFX_MSG(CSplitFrame)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\oclient\old\stdafx.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN

#include <afxwin.h>
#include <afxext.h>
#include <afxole.h>
#include <afxodlgs.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\unicows\samples\oclient\old\stdafx.cpp ===
// stdafx.cpp : pre-compiled header and types file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\units\units.c ===
#include <windows.h>
#include <stdio.h>
#include <signal.h>
#include <float.h>
#include <time.h>
#include <malloc.h>
#include <stdlib.h>
#include <math.h>

static char Name[] = "Ken Reneris. Units ala Unix style";



#define DBL     double
#define MAXTYPE 5

extern  UCHAR *UnitTab[];
UCHAR   token[] = " \t\n";

typedef struct _UNIT {
    struct _UNIT    *Next;

    PSZ             UnitName;
    PSZ             Conversion;
} UNIT, *PUNIT;

PUNIT       UnitList;
BOOLEAN     Muund;

typedef struct _HALFVALUE {
    DBL         Accum;

    ULONG       NoType;
    struct {
        PUNIT       Unit;
        ULONG       Pow;
    } Type [MAXTYPE];

} HALFVALUE, *PHALFVALUE;

typedef struct _FULLVALUE {
    ULONG       Fuzz;
    HALFVALUE   Nom;
    HALFVALUE   Dom;
} FULLVALUE, *PFULLVALUE;

struct {
    PSZ         Prefix;
    ULONG       stringlen;
    DBL         Scaler;
} BuiltInScalers[] = {
    "giga",     4, 1000000000.0,
    "mega",     4,    1000000.0,
    "kilo",     4,       1000.0,
    "centi",    5,          0.01,
    "milli",    5,          0.001,
    "micro",    5,          0.000001,
    "nano",     4,          0.000000001,
    "decinano", 8,          0.0000000001,
    NULL
};

struct {
    PSZ         BaseType;
    PSZ         DefaultDump;
} BuiltInDumps[] = {
    "sec",   "hour second millisec microsec nttime nanosec",
    "bit",   "terabyte gigabyte megabyte kilobyte dword byte bit",
    "meter", "km meter cm mm micron mile feet yard inch",
    "kg",    "kb gram kilokg milligram ton lb ounce dram",
    NULL
};

#define ASSERT(_exp_)   if (_exp_) { AssertFailed (__FILE__, __LINE__); }



PVOID   zalloc (IN ULONG len);
PSZ     StrDup (IN PSZ String);
VOID    ReadUnitTab (VOID);
PUNIT   LookupUnit (PSZ UnitName);
VOID    DumpValue (IN PFULLVALUE Value);
VOID    InitializeValue (IN PFULLVALUE Value);
VOID    ConvertValue (PFULLVALUE, PSZ, PFULLVALUE, PSZ);
BOOLEAN ProcessString (PUNIT, PSZ, PFULLVALUE);
PSZ     CopyUnitName (PSZ Out, PSZ String);
PSZ     CopyWord (PSZ Out, PSZ String);
PSZ     SkipSpace (PSZ String);
BOOLEAN MatchPattern (PUCHAR String, PUCHAR Pattern);
VOID    ReduceTypes (IN OUT PHALFVALUE MValue, IN OUT PHALFVALUE DValue);
VOID    AddTypes (IN OUT PHALFVALUE Dest, IN PHALFVALUE Child);
BOOLEAN DumpMatchingTypes (PSZ Str);
VOID    GetInput (PSZ Desc, PSZ Str);
VOID    AssertFailed (PSZ FileName, ULONG LineNo);


void __cdecl main(int argc, char **argv)
{
    UCHAR       have[80], want[80], want2[200];
    FULLVALUE   hValue, wValue;
    PSZ         p;
    ULONG       i;

    ReadUnitTab ();

    if (argc > 1) {
        //
        // Arguments on the command line.  Argv[1] is "have"
        //

        argv++;
        argc -= 2;
        strcpy (have, *(argv++));

        if (DumpMatchingTypes (have)) {
            exit (0);
        }

        if (!ProcessString (NULL, have, &hValue)) {
            printf ("Usage: Units [have] [want]\n");
            exit   (1);
        }

        //
        // If no Argv[2], then check for default dump
        //

        if (!argc  &&  hValue.Nom.NoType) {
            for (i=0; BuiltInDumps[i].BaseType; i++) {
                if (strcmp (BuiltInDumps[i].BaseType, hValue.Nom.Type[0].Unit->UnitName) == 0) {

                    //
                    // Dump defaults
                    //

                    p = BuiltInDumps[i].DefaultDump;
                    while (*p) {
                        p = CopyWord(want, p);

                        if (ProcessString (NULL, want, &wValue)) {
                            ConvertValue (&hValue, have, &wValue, want);
                        }
                    }
                    break;
                }
            }
        }

        //
        // Dump argv[2..n]
        //

        for ( ; argc; argc--, argv++) {
            if (!ProcessString (NULL, *argv, &wValue)) {
                exit (1);
            }

            ConvertValue (&hValue, have, &wValue, *argv);
        }

        exit (1);
    }

    //
    // Interactive... ask "have" & "want"
    //

    for (; ;) {
        for (; ;) {
            GetInput ("You have: ", have);
            if (ProcessString (NULL, have, &hValue)) {
                break;
            }
        }

        GetInput ("You want: ", want2);
        p = want2;
        do {
            p = CopyWord (want, p);

            if (ProcessString (NULL, want, &wValue)) {
                ConvertValue (&hValue, have, &wValue, want);
            }
        } while (*p);
        printf ("\n");
    }

    return ;
}

VOID
GetInput (
    PSZ     Desc,
    PSZ     Str
    )
{
    for (; ;) {
        printf (Desc);
        if (!gets(Str)) {
            exit(1);
        }
        _strlwr (Str);

        if (strcmp (Str, "q") == 0) {
            exit (1);
        }

        if (!DumpMatchingTypes (Str)) {
            break;
        }
    }
}

BOOLEAN DumpMatchingTypes (PSZ Str)
{
    PSZ         Title, Line;
    ULONG       LineNo;
    UCHAR       UnitName[80];
    BOOLEAN     DumpTitle;

    if (!strchr (Str, '*') && !strchr (Str, '?')  && !strchr(Str, '[')) {
        return FALSE;
    }

    //
    // Dump matching known unitnames
    //

    printf ("\nKnown types/groups matching: %s\n", Str);
    Title = NULL;
    for (LineNo = 0; UnitTab[LineNo]; LineNo++) {
        Line = UnitTab[LineNo];
        if (Line[0] == '/') {
            Title = Line;
            DumpTitle = MatchPattern (Title, Str);
        }

        CopyUnitName (UnitName, Line);
        if (!UnitName[0]) {
            continue;
        }

        if (MatchPattern (UnitName, Str) || DumpTitle) {
            if (Title) {
                printf ("%s\n", Title);
                Title = NULL;
            }
            printf ("    %s\n", Line);

        }
    }
    printf ("\n");
    return TRUE;
}



PSZ SkipSpace (PSZ String)
{
    while (*String && (*String == ' ' ||  *String < ' ' ||  *String == '^')) {
        String ++;
    }

    return String;
}

PSZ CopyNumber (PSZ Out, PSZ String)
{
    while (*String >= '0' && *String <= '9' || *String == '.') {
        *(Out++) = *(String++);
    }

    *Out = 0;
    return String;
}

PSZ CopyWord (PSZ Out, PSZ String)
{
    UCHAR   c;

    while (*String) {
        if (*String <= ' ') {
            break;
        }

        *(Out++) = *(String++);
    }

    *Out = 0;
    return SkipSpace (String);
}



PSZ CopyUnitName (PSZ Out, PSZ String)
{
    UCHAR   c;

    while (c = *String) {
        if (c >= '0'  &&  c <= '9'  ||  c == '.') {
            break;
        }

        if (c == '-'  ||  c == '+'  ||  c == '/'  ||  c == ' ') {
            break;
        }

        if (c == '^'  ||  c < ' ') {
            String++;
            continue;
        }

        *(Out++) = *(String++);
    }

    *Out = 0;
    return String;
}


VOID
AssertFailed (PSZ FileName, ULONG LineNo)
{
    printf ("Assert failed - file %s line %d\n", FileName, LineNo);
    exit (1);
}


PSZ
GetBaseType (
    IN PSZ          Out,
    IN PHALFVALUE   HValue
    )
{
    ULONG       i;

    if (HValue->NoType == 0) {
        Out += sprintf (Out, "constant");
    } else {
        for (i=0; i < HValue->NoType; i++) {
            Out += sprintf (Out, "%s%s", i ? "-" : "", HValue->Type[i].Unit->UnitName);
            if (HValue->Type[i].Pow != 1) {
                Out += sprintf (Out, "^%d", HValue->Type[i].Pow);
            }
        }
    }
    return Out;
}

VOID
GetBaseTypes (
    OUT PSZ     Out,
    IN PFULLVALUE   Value
    )
/**
 *  Returns ascii dump of values data type
 */
{
    PUNIT   Unit;
    ULONG   i;

    Out = GetBaseType (Out, &Value->Nom);

    if (Value->Dom.NoType) {
        Out += sprintf (Out, "/");
        Out  = GetBaseType (Out, &Value->Dom);
    }
}

VOID
DumpValue (
    IN PFULLVALUE   Value
    )
{
    UCHAR   s[80];

    GetBaseTypes (s, Value);
    printf ("%g/%g type %s\n", Value->Nom.Accum, Value->Dom.Accum, s);
}

VOID
SortType (
    IN PHALFVALUE   Value
    )
{
    ULONG   i, j;
    ULONG   hpow;
    PUNIT   hunit;


    //
    // Sort by lowest power, then alphabetical
    //

    for (i=0; i < Value->NoType; i++) {
        for (j=i+1; j < Value->NoType; j++) {
            if (Value->Type[i].Pow > Value->Type[j].Pow ||
               (Value->Type[i].Pow == Value->Type[j].Pow  &&
                strcmp (Value->Type[i].Unit->UnitName, Value->Type[j].Unit->UnitName) > 0)) {

                // swap
                hpow  = Value->Type[i].Pow;
                hunit = Value->Type[i].Unit;
                Value->Type[i].Pow  = Value->Type[j].Pow;
                Value->Type[i].Unit = Value->Type[j].Unit;
                Value->Type[j].Pow  = hpow;
                Value->Type[j].Unit = hunit;
            }
        }
    }
}


VOID
FormatDbl (
    OUT PSZ     s,
    IN  DBL     Value
    )
/**
 * Function to print double "Value" into string "s".  This
 * functions sole purpose is to get a better readable reresentation
 * of the value into ascii
 */
{
    PSZ     p1, p2, dp;
    UCHAR   t[80];
    LONG    i;

    i = 18 - sprintf (t, "%.1f", Value);
    if (i < 0) {
        i = 0;
    }
    sprintf (t, "%.*f", i, Value);

    //
    // strip off trailing zeros
    //

    for (dp=t; *dp; dp++) {
        if (*dp == '.') {
            for (p1=p2=dp+1; *p2; p2++) {
                if (*p2 != '0') {
                    p1 = p2;
                }
            }

            p1[1] = 0;
            if (p1 == dp+1  &&  p1[0] == '0') {
                // it's ".0" remove the whole thing
                *dp = 0;
            }

            break;
        }
    }

    i = (LONG)(dp - t);     // # of digits before decimal point
    i = i % 3;
    if (i == 0) {
        i = 3;
    }

    //
    // Copy to decimal point while adding commas
    //

    for (p1=s, p2=t; *p2 && *p2 != '.'; p2++) {
        if (i-- == 0) {
            *(p1++) = ',';
            i = 2;
        }

        *(p1++) = *p2;
    }

    //
    // Copy remainer
    //

    do {
        *(p1++) = *p2;
    } while (*(p2++));

    //
    // Did result == 0?  Probabily lost precision
    //

    if (strcmp (s, "0") == 0) {
        sprintf (s, "%.18g", Value);
    }
}


VOID
ConvertValue (
    IN PFULLVALUE   hValue,
    IN PSZ      have,
    IN PFULLVALUE   wValue,
    IN PSZ      want
    )
{
    DBL         ans;
    UCHAR       s1[80], s2[80], cf[80];
    FULLVALUE   Junk1, Junk2;
    BOOLEAN     flag;
    DBL         hAccum, wAccum;
    PSZ         p1, p2, p3, p4, p5;

    have   = SkipSpace(have);
    want   = SkipSpace(want);
    hAccum = hValue->Nom.Accum / hValue->Dom.Accum;
    wAccum = wValue->Nom.Accum / wValue->Dom.Accum;
    ans    = hAccum / wAccum;

    p3     = "";
    p5     = NULL;

    //
    // See if types match by checking if they cancle each other out
    //

    Junk1 = *hValue;
    Junk2 = *wValue;
    AddTypes (&Junk1.Nom, &Junk2.Dom);
    AddTypes (&Junk1.Dom, &Junk2.Nom);
    ReduceTypes (&Junk1.Nom, &Junk1.Dom);

    if (Junk1.Nom.NoType + Junk1.Dom.NoType != 0) {

        //
        // See if types are inverse
        //

        Junk1 = *hValue;
        Junk2 = *wValue;
        AddTypes (&Junk1.Nom, &Junk2.Nom);
        AddTypes (&Junk1.Dom, &Junk2.Dom);
        ReduceTypes (&Junk1.Nom, &Junk1.Dom);

        if (Junk1.Nom.NoType + Junk1.Dom.NoType == 0) {

            // inverse result
            ans = 1.0 / (hAccum / (1.0 / wAccum));
            p5  = "Warning";

        } else {

            // types are not conforming
            p5 = "Conformance";
        }
    }

    cf[0] = 0;
    if (p5) {
        SortType (&hValue->Nom);
        SortType (&hValue->Dom);
        SortType (&wValue->Nom);
        SortType (&wValue->Dom);
        GetBaseTypes (s1, hValue);
        GetBaseTypes (s2, wValue);
        sprintf (cf, "    (%s: %s -> %s)", p5, s1, s2);
    }

    FormatDbl (s1, ans);            // fancy
    sprintf (s2, "%.g", ans);       // bland

    p1 = (have[0] >= 'a'  &&  have[0] <= 'z') ? "1" : "";
    p2 = (hValue->Fuzz | wValue->Fuzz) ? "(fuzzy) " : "",
    printf ("    %s%s -> %s %s%s%s%s\n", p1, have, s1, p2, p3, want, cf);

    p4 = strchr (s2, 'e');
    if (p4   &&  !strchr(s1,'e')  &&  atoi(p4+2) > 9) {
        // print bland answer as well
        printf ("    %s%s -> %s %s%s%s%s\n", p1, have, s2, p2, p3, want, cf);
    }
}

BOOLEAN
ProcessString (
    IN PUNIT    Unit,
    IN PSZ      String,
    OUT PFULLVALUE  ReturnValue
    )
{
    UCHAR       s[80], c;
    ULONG       i, j;
    FULLVALUE   ChildValue;
    PHALFVALUE  MValue, DValue, hldvalue;

    ReturnValue->Fuzz = 0;
    MValue = &ReturnValue->Nom;
    DValue = &ReturnValue->Dom;

    MValue->Accum  = 1.0;
    MValue->NoType = 0;

    DValue->Accum  = 1.0;
    DValue->NoType = 0;

    String = SkipSpace(String);
    c = *String;

    if (c == '*') {
        //
        // This is a base value
        //

        MValue->NoType = 1;
        MValue->Type[0].Unit = Unit;
        MValue->Type[0].Pow  = 1;
        return TRUE;
    }

    if (c >= '0' &&  c <= '9'  ||  c == '.') {
        //
        // Constant multiplcation
        //

        String = CopyNumber (s, String);
        String = SkipSpace(String);
        MValue->Accum *= atof(s);
    }

    if (*String == '|') {
        //
        // Constant Division
        //

        String++;
        String = CopyNumber (s, String);
        if (s[0]) {
            DValue->Accum *= atof(s);
        }
    }

    if (*String == '+'  ||  *String == '-') {
        //
        // 10^x
        //

        s[0] = *(String++);
        String = CopyNumber (s+1, String);
        MValue->Accum *= pow (10.0, atof(s));
    }

    for (; ;) {
        String = SkipSpace(String);
        if (!*String) {
            break;
        }

        switch (*String) {
            case '/':
                // flip denominator & numerator
                hldvalue = MValue;
                MValue   = DValue;
                DValue   = hldvalue;
                String++;
                continue;       // get next token

            case '-':
                // skip these
                String++;
                continue;

            default:
                break;
        }

        //
        // Find sub unit type
        //

        String = CopyUnitName (s, String);
        Unit   = LookupUnit (s);
        if (!Unit) {

            //
            // Check for common scaler prefix on keyword
            //

            for (i=0; BuiltInScalers[i].Prefix; i++) {
                if (strncmp (s,
                        BuiltInScalers[i].Prefix,
                        BuiltInScalers[i].stringlen) == 0) {

                    // Scale the value & skip word prefix
                    MValue->Accum *= BuiltInScalers[i].Scaler;
                    Unit = LookupUnit (s + BuiltInScalers[i].stringlen);
                    break;
                }
            }

            if (!Unit) {
                printf ("Unit type '%s' unkown\n", s);
                return FALSE;
            }
        }


        //
        // Get conversion value for this component
        //

        if (!ProcessString (Unit, Unit->Conversion, &ChildValue)) {
            return FALSE;
        }

        if (strcmp (Unit->UnitName, "fuzz") == 0) {
            ReturnValue->Fuzz = 1;
        }

        if (*String >= '1'  &&  *String <= '9') {
            // raise power
            i = *(String++) - '0';

            ChildValue.Nom.Accum = pow (ChildValue.Nom.Accum, i);
            ChildValue.Dom.Accum = pow (ChildValue.Dom.Accum, i);

            for (j=0; j < ChildValue.Nom.NoType; j++) {
                ChildValue.Nom.Type[j].Pow *= i;
            }

            for (j=0; j < ChildValue.Dom.NoType; j++) {
                ChildValue.Dom.Type[i].Pow *= i;
            }
        }

        //
        // Merge values from child
        //

        ReturnValue->Fuzz |= ChildValue.Fuzz;
        MValue->Accum *= ChildValue.Nom.Accum;
        DValue->Accum *= ChildValue.Dom.Accum;

        //
        // Merge data types from child
        //

        AddTypes (MValue, &ChildValue.Nom);
        AddTypes (DValue, &ChildValue.Dom);
        ReduceTypes (MValue, DValue);
    }
    return TRUE;
}


VOID
AddTypes (
    IN OUT PHALFVALUE   Dest,
    IN PHALFVALUE       Child
    )
/**
 *  Add's types from Child to Dest.  If the data type already exist in
 *  dest then it's power is raised; otherwise the new type is added to the list
 *
 */
{
    ULONG   i, j;

    for (i=0; i < Child->NoType; i++) {
        for (j=0; j < Dest->NoType; j++) {
            if (Child->Type[i].Unit == Dest->Type[j].Unit) {
                // unit already is destionation - move it
                Dest->Type[j].Pow  += Child->Type[i].Pow;
                Child->Type[i].Unit = NULL;
                Child->Type[i].Pow  = 0;
            }
        }

        if (Child->Type[i].Unit) {
            // unit not in destionation - add it
            j = (Dest->NoType++);
            ASSERT (j >= MAXTYPE);
            Dest->Type[j].Unit = Child->Type[i].Unit;
            Dest->Type[j].Pow  = Child->Type[i].Pow;
        }
    }
}

VOID
ReduceTypes (
    IN OUT PHALFVALUE   MValue,
    IN OUT PHALFVALUE   DValue
    )
/**
 *  Divides & cancles data types.
 */
{
    ULONG       i, j, k;
    BOOLEAN     Restart;

    Restart = TRUE;
    while (Restart) {
        Restart = FALSE;

        for (i=0; i < MValue->NoType; i++) {
            for (j=0; j < DValue->NoType; j++) {
                if (MValue->Type[i].Unit == DValue->Type[j].Unit) {
                    // matching types - reduce
                    MValue->Type[i].Pow -= DValue->Type[j].Pow;
                    DValue->Type[j].Unit = NULL;
                    DValue->Type[j].Pow  = 0;
                }

                if (DValue->Type[j].Pow == 0) {
                    // pull this type out of the denominator
                    for (k=j+1; k < DValue->NoType; k++) {
                        DValue->Type[k-1] = DValue->Type[k];
                    }
                    DValue->NoType -= 1;
                    Restart = TRUE;
                    continue;
                }
            }

            if (MValue->Type[i].Pow == 0) {
                // pull this type out of the numerator
                for (k=i+1; k < DValue->NoType; k++) {
                    DValue->Type[k-1] = DValue->Type[k];
                }
                MValue->NoType -= 1;
                Restart = TRUE;
                continue;
            }
        }
    }
}



VOID
ReadUnitTab (VOID)
{
    UCHAR       Line[80], s[80];
    ULONG       LineNo;
    PUNIT       Unit;
    PSZ         p, p1;

    for (LineNo = 0; UnitTab[LineNo]; LineNo++) {
        strcpy (Line, UnitTab[LineNo]);

        //
        // Strip off trailing blanks
        //

        for (p=p1=Line; *p; p++) {
            if (*p != ' ') {
                p1 = p;
            }
        }
        p1[1] = 0;

        //
        // First word is type of unit
        //

        p = SkipSpace (Line);
        if (*p == 0  ||  *p == '/') {
            continue;
        }

        p = CopyUnitName (s, p);
        Unit = zalloc (sizeof(UNIT));
        Unit->UnitName = StrDup (s);

        //
        // Rest of line is Conversion string
        //

        p = SkipSpace (p);
        Unit->Conversion = StrDup (p);

        //
        // Add Unit to list of all known units
        //

        Unit->Next = UnitList;
        UnitList = Unit;
    }
}

PUNIT LookupUnit (PSZ UnitName)
{
    PUNIT   Unit;
    UCHAR   Name[40];
    ULONG   i;

    for (i=0; UnitName[i]; i++) {
        Name[i] = UnitName[i];
        if (Name[i] >= '0'  &&  Name[i] <= '9') {
            break;
        }
    }

    Name[i] = 0;
    for (Unit=UnitList; Unit; Unit = Unit->Next) {
        if (strcmp (Unit->UnitName, Name) == 0) {
            break;
        }
    }

    return Unit;
}


PSZ StrDup (IN PSZ String)
{
    ULONG   len;
    PSZ     p;

    // allocate & duplicate string

    len = strlen(String)+1;
    p   = malloc (len);
    if (!p) {
        printf ("Out of memory\n");
        exit (1);
    }

    memcpy (p, String, len);
    return p;
}


PVOID zalloc (IN ULONG len)
{
    PVOID   p;

    // allocate & zero memory

    p = malloc (len);
    if (!p) {
        printf ("Out of memory\n");
        exit (1);
    }

    memset (p, 0, len);
    return p;
}




/*** MatchPattern - check if string matches pattern
 *
 *   Supports:
 *        *      - Matches any number of characters (including zero)
 *        ?      - Matches any 1 character
 *        [set]  - Matches any charater to charater in set
 *                   (set can be a list or range)
 *
 */

BOOLEAN MatchPattern (PUCHAR String, PUCHAR Pattern)
{
    UCHAR   c, p, l;

    for (; ;) {
        switch (p = *Pattern++) {
            case 0:                             // end of pattern
                return *String ? FALSE : TRUE;  // if end of string TRUE

            case '*':
                while (*String) {               // match zero or more char
                    if (MatchPattern (String++, Pattern))
                        return TRUE;
                }
                return MatchPattern (String, Pattern);

            case '?':
                if (*String++ == 0)             // match any one char
                    return FALSE;                   // not end of string
                break;

            case '[':
                if ( (c = *String++) == 0)      // match char set
                    return FALSE;                   // syntax

                c = (UCHAR)tolower(c);
                l = 0;
                while (p = *Pattern++) {
                    if (p == ']')               // if end of char set, then
                        return FALSE;           // no match found

                    if (p == '-') {             // check a range of chars?
                        p = *Pattern;           // get high limit of range
                        if (p == 0  ||  p == ']')
                            return FALSE;           // syntax

                        if (c >= l  &&  c <= p)
                            break;              // if in range, move on
                    }

                    l = p;
                    if (c == p)                 // if char matches this element
                        break;                  // move on
                }

                while (p  &&  p != ']')         // got a match in char set
                    p = *Pattern++;             // skip to end of set

                break;

            default:
                c = *String++;
                if (tolower(c) != p)            // check for exact char
                    return FALSE;                   // not a match

                break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\units\unittab.c ===
#include <stdio.h>

//
// From wingnut
//

char *UnitTab[] = {
"/ dimensions                                   ",
"meter                  *a*                     ",
"kg                     *b*                     ",
"sec                    *c*                     ",
"coul                   *d*                     ",
"candela                *e*                     ",
"dollar                 *f*                     ",
"radian                 *g*                     ",
"bit                    *h*                     ",
"erlang                 *i*                     ",
"degC                   *j*                     ",
"                                               ",
"/ constants                                    ",
"                                               ",
"fuzz                   1                       ",
"pi                     3.14159265358979323846  ",
"c                      2.997925+8 m/sec fuzz   ",
"g                      9.80665 m/sec2          ",
"au                     1.49597871+11 m fuzz    ",
"mole                   6.022169+23 fuzz        ",
"e                      1.6021917-19 coul fuzz  ",
"energy                 c2                      ",
"force                  g                       ",
"mercury                1.33322+5 kg/m2-sec2    ",
"hg                     mercury                 ",
"                                               ",
"/ dimensionless                                ",
"                                               ",
"degree                 1|180 pi-radian         ",
"circle                 2 pi-radian             ",
"turn                   2 pi-radian             ",
"grade                  .9 degree               ",
"arcdeg                 1 degree                ",
"arcmin                 1|60 arcdeg             ",
"ccs                    1|36 erlang             ",
"arcsec                 1|60 arcmin             ",
"                                               ",
"steradian              radian2                 ",
"sphere                 4 pi-steradian          ",
"sr                     steradian               ",
"                                               ",
"/ Time                                         ",
"                                               ",
"second                 sec                     ",
"s                      sec                     ",
"minute                 60 sec                  ",
"min                    minute                  ",
"hour                   60 min                  ",
"hr                     hour                    ",
"day                    24 hr                   ",
"da                     day                     ",
"week                   7 day                   ",
"year                   365.24219879 day fuzz   ",
"yr                     year                    ",
"month                  1|12 year               ",
"ms                     millisec                ",
"us                     microsec                ",
"                                               ",
"/ Mass                                         ",
"                                               ",
"gram                   millikg                 ",
"gm                     gram                    ",
"mg                     milligram               ",
"metricton              kilokg                  ",
"                                               ",
"/ Avoirdupois                                  ",
"                                               ",
"lb                     .45359237 kg            ",
"lbf                    lb g                    ",
"ounce                  1|16 lb                 ",
"oz                     ounce                   ",
"dram                   1|16 oz                 ",
"dr                     dram                    ",
"grain                  1|7000 lb               ",
"gr                     grain                   ",
"shortton               2000 lb                 ",
"ton                    shortton                ",
"longton                2240 lb                 ",
"                                               ",
"/ Apothecary                                   ",
"                                               ",
"scruple                20 grain                ",
"apdram                 60 grain                ",
"apounce                480 grain               ",
"appound                5760 grain              ",
"                                               ",
"/ Length                                       ",
"                                               ",
"m                      meter                   ",
"cm                     centimeter              ",
"mm                     millimeter              ",
"km                     kilometer               ",
"nm                     nanometer               ",
"micron                 micrometer              ",
"angstrom               decinanometer           ",
"                                               ",
"inch                   2.54 cm                 ",
"in                     inch                    ",
"foot                   12 in                   ",
"feet                   foot                    ",
"ft                     foot                    ",
"yard                   3 ft                    ",
"yd                     yard                    ",
"rod                    5.5 yd                  ",
"rd                     rod                     ",
"mile                   5280 ft                 ",
"mi                     mile                    ",
"                                               ",
"british                1200|3937 m/ft          ",
"nmile                  1852m                   ",
"                                               ",
"acre                   4840 yd2                ",
"                                               ",
"cc                     cm3                     ",
"liter                  kilocc                  ",
"ml                     milliliter              ",
"                                               ",
"/ US Liquid                                    ",
"                                               ",
"gallon                 231 in3                 ",
"imperial               1.20095                 ",
"gal                    gallon                  ",
"quart                  1|4 gal                 ",
"qt                     quart                   ",
"pint                   1|2 qt                  ",
"pt                     pint                    ",
"                                               ",
"floz                   1|16 pt                 ",
"fldr                   1|8 floz                ",
"                                               ",
"/ US Dry                                       ",
"                                               ",
"dry                    268.8025 in3/gallon fuzz",
"peck                   8 dry-quart             ",
"pk                     peck                    ",
"bushel                 4 peck                  ",
"bu                     bushel                  ",
"                                               ",
"/ British                                      ",
"                                               ",
"brgallon               277.420 in3 fuzz        ",
"brquart                1|4 brgallon            ",
"brpint                 1|2 brquart             ",
"brfloz                 1|20 brpint             ",
"brpeck                 554.84 in3 fuzz         ",
"brbushel               4 brpeck                ",
"                                               ",
"/ Energy Work                                  ",
"                                               ",
"newton                 kg-m/sec2               ",
"nt                     newton                  ",
"joule                  nt-m                    ",
"cal                    4.1868 joule            ",
"                                               ",
"/ Electrical                                   ",
"                                               ",
"coulomb                coul                    ",
"ampere                 coul/sec                ",
"amp                    ampere                  ",
"watt                   joule/sec               ",
"volt                   watt/amp                ",
"ohm                    volt/amp                ",
"mho                    /ohm                    ",
"farad                  coul/volt               ",
"henry                  sec2/farad              ",
"weber                  volt-sec                ",
"                                               ",
"/ Light                                        ",
"                                               ",
"cd                     candela                 ",
"lumen                  cd sr                   ",
"lux                    cd sr/m2                ",
"                                               ",
"/ Money                                        ",
"/ epoch April 28, 1994 wall st j               ",
"                                               ",
"$                       dollar                 ",
"britainpound           1.5135  $               ",
"canadadollar            .72322 $               ",
"francefranc             .17545 $               ",
"japanyen                .00987 $               ",
"mexicopeso              .30581 $               ",
"netherlandsguilder      .53576 $               ",
"switzerlandfranc        .70822 $               ",
"germanymark             .60158 $               ",
#if 0       // 1977 - might as well not be here
"/ epoch May 18, 1977 wall st j                  ",
"argentinapeso           .0030 $                ",
"australiadollar        1.1065 $                ",
"austriaschilling        .0597 $                ",
"belgiumfranc            .0277 $                ",
"brazilcruzeiro          .0733 $                ",
"britainpound           1.7187 $                ",
"canadadollar            .9550 $                ",
"colombiapeso            .0276 $                ",
"denmarkkrone            .1663 $                ",
"equadorsucre            .0365 $                ",
"finlandmarkka           .2456 $                ",
"francefranc             .2021 $                ",
"greecedrachma           .0272 $                ",
"hongkongdollar          .2134 $                ",
"indiarupee              .1145 $                ",
"indonesiarupiah         .00259 $               ",
"iranrial                .0143 $                ",
"iraqdinar              3.41 $                  ",
"israelpound             .1105 $                ",
"italylira               .001130 $              ",
"japanyen                .003607 $              ",
"lebanonpound            .3285 $                ",
"malaysiadollar          .4032 $                ",
"mexicopeso              .0445 $                ",
"netherlandsguilder      .4080 $                ",
"newzealanddollar        .9665 $                ",
"norwaykrone             .1899 $                ",
"pakistanrupee           .1025 $                ",
"perusol                 .0129 $                ",
"phillippinespeso        .1345 $                ",
"portugalescudo          .0259 $                ",
"saudiarabiariyal        .2860 $                ",
"singaporedollar         .4061 $                ",
"southafricarand        1.1522 $                ",
"southkoreawon           .0021 $                ",
"spainpeseta             .01451 $               ",
"swedenkrona             .2296 $                ",
"switzerlandfranc        .3970 $                ",
"thailandbhat            .050 $                 ",
"uruguaypeso             .2330 $                ",
"venezuelabolivar        .2335 $                ",
"germanymark             .4243 $                ",
"                                               ",
"bolivar                venezuelabolivar        ",
"peseta                 spainpeseta             ",
"rand                   southafricarand         ",
"escudo                 portugalescudo          ",
"sol                    perusol                 ",
"dinar                  iraqdinar               ",
"rial                   iranrial                ",
"rupee                  indiarupee              ",
"drachma                greecedrachma           ",
"markka                 finlandmarkka           ",
"sucre                  equadorsucre            ",
"cruzeiro               brazilcruzeiro          ",
#endif
"                                               ",
"mark                   germanymark             ",
"guilder                netherlandsguilder      ",
"peso                   mexicopeso              ",
"yen                    japanyen                ",
"lira                   italylira               ",
"franc                  francefranc             ",
"pound                  britainpound            ",
"poundsterling          britainpound            ",
"                                               ",
"/ Trivia                                       ",
"                                               ",
"%                      1|100                   ",
"admiraltyknot          6080 ft/hr              ",
"apostilb               cd/pi-m2                ",
"are                    1+2 m2                  ",
"arpentcan              27.52 mi                ",
"arpentlin              191.835 ft              ",
"astronomicalunit       au                      ",
"atmosphere             1.01325+5 nt/m2         ",
"atm                    atmosphere              ",
"atomicmassunit         1.66044-27 kg fuzz      ",
"amu                    atomicmassunit          ",
"bag                    94 lb                   ",
"bakersdozen            13                      ",
"bar                    1+5 nt/m2               ",
"barie                  1-1 nt/m2               ",
"barleycorn             1|3 in                  ",
"barn                   1-28 m2                 ",
"barrel                 42 gal                  ",
"barye                  1-1 nt/m2               ",
"bev                    1+9 e-volt              ",
"biot                   10 amp                  ",
"blondel                cd/pi-m2                ",
"boardfoot              144 in3                 ",
"bolt                   40 yd                   ",
"bottommeasure          1|40 in                 ",
"britishthermalunit     1.05506+3 joule fuzz    ",
"btu                    britishthermalunit      ",
"refrigeration          12000 btu/ton-hour      ",
"buck                   dollar                  ",
"cable                  720 ft                  ",
"caliber                1-2 in                  ",
"calorie                cal                     ",
"carat                  205 mg                  ",
"cent                   centidollar             ",
"cental                 100 lb                  ",
"centesimalminute       1-2 grade               ",
"centesimalsecond       1-4 grade               ",
"century                100 year                ",
"cfs                    ft3/sec                 ",
"chain                  66 ft                   ",
"circularinch           1|4 pi-in2              ",
"circularmil            1-6|4 pi-in2            ",
"clusec                 1-8 mm-hg m3/s          ",
"coomb                  4 bu                    ",
"cord                   128 ft3                 ",
"cordfoot               cord                    ",
"crith                  9.06-2 gm               ",
"cubit                  18 in                   ",
"cup                    1|2 pt                  ",
"curie                  3.7+10 /sec             ",
"dalton                 amu                     ",
"decade                 10 yr                   ",
"dipotre                /m                      ",
"displacementton        35 ft3                  ",
"doppelzentner          100 kg                  ",
"dozen                  12                      ",
"drop                   .03 cm3                 ",
"dyne                   cm-gm/sec2              ",
"electronvolt           e-volt                  ",
"ell                    45 in                   ",
"engineerschain         100 ft                  ",
"engineerslink          100|100 ft              ",
"equivalentfootcandle   lumen/pi-ft2            ",
"equivalentlux          lumen/pi-m2             ",
"equivalentphot         cd/pi-cm2               ",
"erg                    cm2-gm/sec2             ",
"ev                     e-volt                  ",
"faraday                9.652+4 coul            ",
"fathom                 6 ft                    ",
"fermi                  1-15 m                  ",
"fifth                  4|5 qt                  ",
"fin                    5 dollar                ",
"finger                 7|8 in                  ",
"firkin                 9 gal                   ",
"footcandle             lumen/ft2               ",
"footlambert            cd/pi-ft2               ",
"fortnight              14 da                   ",
"franklin               3.33564-10 coul         ",
"frigorie               kilocal                 ",
"furlong                220 yd                  ",
"galileo                1-2 m/sec2              ",
"gamma                  1-9 weber/m2            ",
"gauss                  1-4 weber/m2            ",
"geodeticfoot           british-ft              ",
"geographicalmile       1852 m                  ",
"gilbert                7.95775-1 amp           ",
"gill                   1|4 pt                  ",
"gross                  144                     ",
"gunterschain           22 yd                   ",
"hand                   4 in                    ",
"hectare                1+4 m2                  ",
"hefnercandle           .92 cd                  ",
"hertz                  /sec                    ",
"hogshead               2 barrel                ",
"hd                     hogshead                ",
"homestead              1|4 mi2                 ",
"horsepower             550 ft-lb-g/sec         ",
"hp                     horsepower              ",
"hyl                    gm force sec2/m         ",
"hz                     /sec                    ",
"imaginarycubicfoot     1.4 ft3                 ",
"jeroboam               4|5 gal                 ",
"karat                  1|24                    ",
"kcal                   kilocal                 ",
"kcalorie               kilocal                 ",
"kev                    1+3 e-volt              ",
"key                    kg                      ",
"khz                    1+3 /sec                ",
"kilderkin              18 gal                  ",
"knot                   nmile/hr                ",
"lambert                cd/pi-cm2               ",
"langley                cal/cm2                 ",
"last                   80 bu                   ",
"league                 3 mi                    ",
"lightyear              c-yr                    ",
"line                   1|12 in                 ",
"link                   66|100 ft               ",
"longhundredweight      112 lb                  ",
"longquarter            28 lb                   ",
"lusec                  1-6 mm-hg m3/s          ",
"mach                   331.46 m/sec            ",
"magnum                 2 qt                    ",
"marineleague           3 nmile                 ",
"maxwell                1-8 weber               ",
"metriccarat            200 mg                  ",
"mev                    1+6 e-volt              ",
"mgd                    megagal/day             ",
"mh                     millihenry              ",
"mhz                    1+6 /sec                ",
"mil                    1-2 in                  ",
"millenium              1000 year               ",
"minersinch             1.5 ft3/min             ",
"minim                  1|60 fldr               ",
"mo                     month                   ",
"mpg                    mile/gal                ",
"mph                    mile/hr                 ",
"nail                   1|16 yd                 ",
"nauticalmile           nmile                   ",
"nit                    cd/m2                   ",
"noggin                 1|8 qt                  ",
"nox                    1-3 lux                 ",
"ns                     nanosec                 ",
"nttime                 100 nanosec             ",
"oersted                2.5+2 pi-amp/m          ",
"oe                     oersted                 ",
"pace                   36 in                   ",
"palm                   3 in                    ",
"parasang               3.5 mi                  ",
"parsec                 au-radian/arcsec        ",
"pascal                 nt/m2                   ",
"pc                     parsec                  ",
"pennyweight            1|20 oz                 ",
"percent                %                       ",
"perch                  rd                      ",
"pf                     picofarad               ",
"phot                   lumen/cm2               ",
"pica                   1|6 in                  ",
"pieze                  1+3 nt/m2               ",
"pipe                   4 barrel                ",
"point                  1|72 in                 ",
"poise                  gm/cm-sec               ",
"pole                   rd                      ",
"poundal                ft-lb/sec2              ",
"pdl                    poundal                 ",
"proof                  1|200                   ",
"psi                    lb-g/in2                ",
"quarter                9 in                    ",
"quartersection         1|4 mi2                 ",
"quintal                100 kg                  ",
"quire                  25                      ",
"rad                    100 erg/gm              ",
"ream                   500                     ",
"registerton            100 ft3                 ",
"rehoboam               156 floz                ",
"rhe                    10 m2/nt-sec            ",
"rontgen                2.58-4 curie/kg         ",
"rood                   1.21+3 yd               ",
"rope                   20 ft                   ",
"rutherford             1+6 /sec                ",
"rydberg                1.36054+1 ev            ",
"sabin                  1 ft2                   ",
"sack                   3 bu                    ",
"seam                   8 bu                    ",
"section                mi2                     ",
"shippington            40 ft3                  ",
"shorthundredweight     100 lb                  ",
"shortquarter           25 lb                   ",
"siemens                /ohm                    ",
"sigma                  microsec                ",
"skein                  120 yd                  ",
"skot                   1-3 apostilb            ",
"slug                   lb-g-sec2/ft            ",
"span                   9 in                    ",
"spat                   4 pi sr                 ",
"spindle                14400 yd                ",
"square                 100 ft2                 ",
"stere                  m3                      ",
"sthene                 1+3 nt                  ",
"stilb                  cd/cm2                  ",
"stoke                  1-4 m2/sec              ",
"stone                  14 lb                   ",
"strike                 2 bu                    ",
"surveyfoot             british-ft              ",
"surveyorschain         66 ft                   ",
"surveyorslink          66|100 ft               ",
"tablespoon             4 fldr                  ",
"teaspoon               4|3 fldr                ",
"tesla                  weber/m2                ",
"therm                  1+5 btu                 ",
"thermie                1+6 cal                 ",
"timberfoot             ft3                     ",
"tnt                    4.6+6 m2/sec2           ",
"tonne                  1+6 gm                  ",
"torr                   mm hg                   ",
"township               36 mi2                  ",
"tun                    8 barrel                ",
"water                  .22491|2.54 kg/m2-sec2  ",
"wey                    40 bu                   ",
"weymass                252 lb                  ",
"Xunit                  1.00202-13m             ",
"k                      1.38047-16 erg/degC     ",
"                                               ",
"/ Computer                                     ",
"                                               ",
"byte                   8 bit                   ",
"word                   2 byte                  ",
"dword                  4 byte                  ",
"qword                  8 byte                  ",
"quadword               qword                   ",
"paragraph              16 byte                 ",
"kilobyte               1024 byte               ",
"kb                     kilobyte                ",
"megabyte               1024 kb                 ",
"mb                     megabyte                ",
"gigabyte               1024 mb                 ",
"gb                     gigabyte                ",
"terabyte               1024 gb                 ",
"tb                     terabyte                ",
NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\upd\upd.c ===
/*
 *  UPD: update
 *
 * HISTORY:
 *
 *   4/13/86  danl  Fix /d bug.  Print warning on eq time ne length
 *   4/11/86  danl  Remove test for length just before copyfile
 *   4/09/86  danl  Converted to ztools\lib
 *   5/07/86  danl  Add msg if no such source found
 *   5/29/86  danl  Add /s flag
 *   6/02/86  danl  Add /g flag
 *   6/04/86  danl  Allow %n with /g flag
 *   6/10/86  danl  Allow blank lines in /g file, # are not echo'd
 *   6/12/86  danl  Output \n and ends of lines
 *   6/26/86  danl  Convert from fatal to usage
 *   7/01/86  danl  Add /a flag
 *  12/04/86  danl  Add /p flag
 *  12/24/86  danl  Use malloc for pPat
 *   2/24/87  brianwi Use findclose()
 *   2/25/87  brianwi Add 'echo' and 'rem' to /g files
 *  07-Apr-87 danl    Add fAnyUpd
 *  13-Apr-87 brianwi Issue error message if source dir invalid
 *  07-May-87 danl    Add /e switch
 *  22-May-87 brianwi Fix descent from root directory bug
 *  20-Aug-87 brianwi Fix Null Pointer with /o ( free(pPat) in walk() )
 */
#include <malloc.h>
#include <math.h>
#include <ctype.h>
#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <io.h>
#include <string.h>
#include <stdio.h>
#include <process.h>
#include <ctype.h>
#include <math.h>
#include <stdlib.h>
#include <windows.h>
#include <tools.h>

// Forward Function Declarations...
int savespec( char * );
int copyfile( char *, struct findType *, char * );
void walk( char *, struct findType *, void *);
void RecWalk( char *, struct findType *, void * );
void saveext( char * );
void __cdecl usage( char *, ... );
void getfile( int, char ** );


char const rgstrUsage[] = {
    "Usage: UPD [/nxdfvosape] {src directories}+ dest directory [{wildcard specs}*]\n"
    "       UPD /g file\n"
    "    Options:\n"
    "       -n  No saving of replaced files to deleted directory\n"
    "       -x  eXclude files, see tools.ini\n"
    "       -d  Descend into subdirectories\n"
    "       -f  Files differ, then update\n"
    "       -v  Verbose\n"
    "       -o  Only files already existing in dest are updated\n"
    "       -s  Subdirectory DEBUG has priority\n"
    "       -a  Archive bit on source should NOT be reset\n"
    "       -p  Print actions, but do nothing\n"
    "       -e  Exit codes 1-error or no src else 0\n"
    "           Default is 1-update done 0-no updates done\n"
    "       -g  Get params from file\n"
    };

#define BUFLEN  MAX_PATH
#define MAXSPEC 32
#define MAXFIL  256
#define MAXARGV 20

char *exclude[MAXFIL], dir[BUFLEN];
unsigned _stack = 4096;
flagType fInGetfile = FALSE;
flagType _fExpand = FALSE;
flagType fDescend = FALSE;
flagType fAll = FALSE;
flagType fExclude = FALSE;
flagType fDel = TRUE;
flagType fVerbose = FALSE;
flagType fOnly = FALSE;
flagType fSubDebug = FALSE;     /* TRUE => priority to subdir DEBUG */
flagType fArchiveReset = TRUE;
flagType fPrintOnly = FALSE;
flagType fErrorExit = FALSE;    /* TRUE => exit (1) errors or no src else 0 */
flagType fNoSrc = FALSE;        /* TRUE => "No src msg emitted" */

int numexcl = 0;
int cCopied = 0;
int fAnyUpd = 0;
int nWildSpecs = 0;
char *wildSpecs[MAXSPEC];
struct findType buf;
char source[BUFLEN], dest[BUFLEN], srcDebug[BUFLEN];

/* for use by getfile */
char *argv[MAXARGV];
char bufIn[BUFLEN];
char strLine[BUFLEN];
char ekoLine[BUFLEN]; /* undestroyed copy of line for echo */


savespec (p)
char *p;
{
    char namebuf[ 16 ];
    int i;

    buf.fbuf.dwFileAttributes = 0;
    namebuf[ 0 ] = 0;
    if (strchr(p, '\\') || strchr(p, ':' ) )
        return FALSE;
    ffirst( p, FILE_ATTRIBUTE_DIRECTORY, &buf );
    findclose( &buf );
    if ( /* !HASATTR( buf.attr, FILE_ATTRIBUTE_DIRECTORY ) && */
        filename( p, namebuf )
    ) {
        fileext( p, namebuf);
        upper( namebuf );
        for (i=0; i<nWildSpecs; i++)
            if (!strcmp( namebuf, wildSpecs[ i ]))
                return TRUE;

        if (nWildSpecs < MAXSPEC) {
            wildSpecs[ nWildSpecs++ ]  = _strdup (namebuf);
            return TRUE;
            }
        else
            usage( "Too many wild card specifications - ", namebuf, 0 );
        }

    return FALSE;
}


copyfile( src, srctype, dst )
char *src, *dst;
struct findType *srctype;
{
    int i;
    char *result, temp[ 20 ]; /* temp for storing file names */
    flagType fNewfile = FALSE;

    if ( fExclude ) {
        fileext( src, temp );

        for (i = 0; i< numexcl; i++) {
            if( !_strcmpi( exclude[i], temp ) ) {
                return( FALSE );
            }
        }
    }
    fflush( stdout );
        /* if the file already exists, fdelete will return 0; then don't    */
        /* notify the user that a file transfer has taken place.  Otherwise */
        /* a new file has been created so tell the user about it.           */
    printf( "  %s => %s", src, dst );
    fAnyUpd = 1;
    if ( !fPrintOnly ) {
        if (fDel) fNewfile = (flagType)((fdelete(dst)) ? TRUE : FALSE );
        if (!(result = fcopy( src, dst ))) {
            if (fArchiveReset)
                SetFileAttributes( src, srctype->fbuf.dwFileAttributes & ~FILE_ATTRIBUTE_ARCHIVE );
            if (fVerbose || fNewfile) printf( " [OK]" );
            }
        else
            printf( " %s - %s", result, error() );
    }
    else
        printf ( " [no upd]" );
    printf( "\n" );
    fflush( stdout );
    return TRUE;
}

void
walk (
    char            *p,
    struct findType *b,
    void            *dummy
    )
{
    int fNotFound;
    char *pPat;
    char *pT = p;
    struct findType *bT = b;
    struct findType bufT;

    if( strcmp( bT->fbuf.cFileName, "." ) &&
        strcmp( bT->fbuf.cFileName, ".." )
      ) {
        if (HASATTR (bT->fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {
                /* do nothing if you find a dir */
        } else if( !HASATTR( bT->fbuf.dwFileAttributes, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM  ) ) {
            //
            //  Note: windows does not support FILE_ATTRIBUTE_VOLUME_LABEL, so
            //        it was removed from above
            //
            pPat = malloc ( BUFLEN );
            if (pPat) {
                strcpy( pPat, dest );
                if (*(strend( pPat ) - 1) != '\\') {
                    strcat( pPat, "\\" );
                }
                fileext( pT, strend ( pPat ) );
    
                /* ffirst == 0 => file found */
    
                if (fOnly && ffirst( pPat, -1, &buf ) )  {
                    free ( pPat );
                    return;
                }
                if (fOnly) {
                    findclose( &buf );
                }
    
                /* so far we know src\file and dest\file exist */
                if (fSubDebug) {
                    /* now check to see if src\DEBUG\file exists */
                    drive(pT, srcDebug);
                    path(pT, srcDebug + strlen(srcDebug));
                    strcat(srcDebug + strlen(srcDebug), "debug\\");
                    fileext(pT, srcDebug + strlen(srcDebug));
                    if( !ffirst( srcDebug, -1, &bufT ) ) {
                        findclose( &bufT );
                        /* it exists so use it for the compares below */
                        pT = srcDebug;
                        bT = &bufT;
                    }
                }
    
                cCopied++;
    
                if( ( fNotFound = ffirst( pPat, -1, &buf ) ) ||
                    ( CompareFileTime( &buf.fbuf.ftLastWriteTime, &bT->fbuf.ftLastWriteTime ) < 0 ) ||
                    ( fAll &&
                      CompareFileTime( &buf.fbuf.ftLastWriteTime, &bT->fbuf.ftLastWriteTime ) > 0
                    )
                  ) {
                    copyfile( pT, bT, pPat );
                } else if( !fNotFound &&
                           CompareFileTime( &buf.fbuf.ftLastWriteTime, &bT->fbuf.ftLastWriteTime ) == 0 &&
                           buf.fbuf.nFileSizeLow != bT->fbuf.nFileSizeLow
                         ) {
                    printf("\n\007UPD: warning - %s not copied\n", pT);
                    printf("\007UPD: warning - same time, different length in src & dest\n", pT);
                }
                findclose( &buf );
                free ( pPat );
            }
        }
    }
    dummy;
}

/*  a first walking routine, just copies the files on given directory */
/*  doesn't deal with nested subdirectories.  Ie split the process up into */
/*  two parts, first deal with files on current directory, then deal with */
/*  subdirectories as necessary. */



/* only called when fDescend is true */
void
RecWalk (
    char            *p,
    struct findType *b,
    void            *dummy
    )
{
    char *pPat;
    char *pDestEnd;
    int i;

    if (strcmp (b->fbuf.cFileName, ".") && strcmp (b->fbuf.cFileName, ".."))
        if (HASATTR (b->fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY) && 
            !HASATTR (b->fbuf.dwFileAttributes, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM)) 
        {
            /* ignore Hidden and System directories */
            pPat = malloc ( BUFLEN );
            if (pPat) {
                if ( (pDestEnd = strend(dest))[-1] != '\\' )
                    strcat(pDestEnd, "\\");
                fileext(p, strend(pDestEnd));
                sprintf( pPat, "%s\\*.*", p);
                forfile( pPat, FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM, RecWalk, NULL );
                for (i=0; i<nWildSpecs; i++) {
                     sprintf( pPat, "%s\\%s", p, wildSpecs[ i ] );
                     forfile( pPat, FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM, walk, NULL );
                     }
                *pDestEnd = '\0';
                free ( pPat );
            }
        }
    dummy;
}


void
saveext (p)
char *p;
{
    upper (p) ;
    if (numexcl < MAXFIL)
        exclude [numexcl++]  = _strdup (p);
}


void __cdecl usage( char *p, ... )
{
    char **rgstr;

    rgstr = &p;
    if (*rgstr) {
        fprintf (stderr, "UPD: ");
        while (*rgstr)
            fprintf (stderr, "%s", *rgstr++);
        fprintf (stderr, "\n");
        }
    fputs(rgstrUsage, stderr);

    exit ((fErrorExit ? 1 : 0));
}


__cdecl
main (c, v)
int c;
char *v[];
{
    int i, j, k;
    FILE *fh;
    char *p, *p1, namebuf[ BUFLEN ];

    _fExpand = FALSE;
    fDescend = FALSE;
    fAll = FALSE;
    fExclude = FALSE;
    fDel = TRUE;
    fOnly = FALSE;
    fSubDebug = FALSE;
    fArchiveReset = TRUE;
    fPrintOnly = FALSE;
    numexcl = 0;
    cCopied = 0;
    nWildSpecs = 0;

    if (!fInGetfile)
        SHIFT(c, v);    /* Flush the command name */
    /*
     * 13-SEPT-90   w-barry
     * Added test for arguments remaining before test for switch char.
     */
    while( c && fSwitChr ( *v[ 0 ] ) ) {
        p = v[ 0 ];
        SHIFT(c, v);
        while (*++p)
            switch (tolower(*p)) {
                case 'a':
                    fArchiveReset = FALSE;
                    break;
                case 'g':
                    if (fInGetfile)
                        usage( "/g allowed only on command line", 0);
                    getfile(c, v);
                    break;
                case 'e':
                    fErrorExit = TRUE;
                case 'x':
                    fExclude = TRUE;
                    break;
                case 'v':
                    fVerbose = TRUE;
                    break;
                case 'd':
                    fDescend = TRUE;
                    break;
                case 'f':
                    fAll = TRUE;
                    break;
                case 'n':
                    fDel = FALSE;
                    break;
                case 'o':
                    fOnly = TRUE;
                    break;
                case 'p':
                    fPrintOnly = TRUE;
                    break;
                case 's':
                    fSubDebug = TRUE;
                    break;
                default:
                    usage( "Invalid switch - ", p, 0);
                }
        }

    if (fSubDebug && fDescend) {
        printf("UPD: /s and /d both specified, /d ignored\n");
        fDescend = FALSE;
        }

    if (fExclude)
        if  ((fh = swopen ("$USER:\\tools.ini", "upd")) ) {
           while (swread (p1 = dir, BUFLEN, fh)) {
                while  (*(p = strbskip (p1, " ")))  {
                    if  (*(p1 = strbscan (p, " ")))
                        *p1++ = 0;
                    saveext (p) ;
                    }
                }
            swclose (fh) ;
            }

        /* Must be at least one source dir and the dest dir. */
    if (c < 2)
        usage( 0 );

        /* Save away any wildcard specs at end of argument list */
    for (i=c-1; i>=2; i--)
        if (!savespec( v[ i ] ))
            break;
        else
            c--;

        /* Still must be at least one source dir and the dest dir. */
    if (c < 2)
        usage( 0 );

        /* Make sure destination is a valid directory */

    rootpath( v[ c-1 ], dest );
    if (ffirst( dest, FILE_ATTRIBUTE_DIRECTORY, &buf ) == -1)
        usage( "Destination directory does not exist - ", v[ c-1 ], 0 );
    else {
        findclose( &buf );
        c--;
        }

    if (!nWildSpecs)
        savespec( "*.*" );

    if (fVerbose) {
        printf( "Copying all files matching:" );
        for (i=0; i<nWildSpecs; i++)
            printf( "  %s", wildSpecs[ i ] );
        printf( "\n" );
        printf( "To destination directory:    %s\n", dest );
        printf( "From the following source directories:\n" );
        }
    for (i=0; i<c; i++) {
        if (rootpath( v[ i ], namebuf )) {
            printf( "\aSource directory does not exist - %s\n", v[ i ]);
            continue;
        }

        if (fVerbose) printf( "  %s\n", namebuf );

        if (namebuf[k = strlen( namebuf ) - 1] == '\\')
            namebuf[k] = '\0';

        for (j=0; j<nWildSpecs; j++) {
            sprintf( source, "%s\\%s", namebuf, wildSpecs[ j ] );
            cCopied = 0;
            forfile( source, FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM, walk, NULL );
            if (!cCopied) {
                printf( "UPD: no src file matching %s\\%s\n", namebuf, wildSpecs[ j ] );
                fNoSrc = 1;
                }
            }
        if (fDescend) {
            sprintf( source, "%s\\*.*", namebuf );
            forfile( source, FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM, RecWalk, NULL );
            }
/*        if (fVerbose) printf( "\n" ); */
        }

    if (!fInGetfile)
        return( (int)fErrorExit ? (int)fNoSrc : fAnyUpd );

    return 0;
}

/*  call if UPD /g getfile, reads lines from getfile and for each line
    calls main */

void getfile(c, v)
int c;
char *v[];
{
    FILE *fp;
    int cargv = 0;
    int i, j;
    char *p;

    ConvertAppToOem( c, v );
    if( c == 0 ) {
        usage("no getfile specified", 0);
    }
    fInGetfile = TRUE;
    if( ( fp = fopen( *v, "r" ) ) == (FILE *)NULL ) {
        usage("error opening ", *v, 0);
    }
    SHIFT(c, v);

    /*
     * 13-SEPT-90   w-barry
     *      Changed open to fopen and switched to fgets instead of assembly
     * routines 'getl' and 'getlinit'.
     *
     * getlinit((char far *)bufIn, BUFLEN, fh);
     * while (getl(strLine, BUFLEN) != NULL) {
     */
    while( fgets( strLine, BUFLEN, fp ) != NULL ) {
        if( *strLine == '#' )
            continue;
        if( *strLine == ';') {
            printf( "%s\n", strLine );
            continue;
            }
        /* fgets doesn't strip the trailing \n */
        *strbscan(strLine, "\n") = '\0';
        cargv = 0;
        /* convert strLine into argv */
        p = strbskip(strLine, " ");
        strcpy (ekoLine, p + 5);
        while (*p) {
            argv[cargv++] = p;
            p = strbscan(p, " ");
            if (*p)
                *p++ = '\0';
            p = strbskip(p, " ");
            }

        if (!_stricmp (argv[0], "rem")) continue;
        if (!_stricmp (argv[0], "echo"))
        {
            if      (!_stricmp (argv[1], "on" ))
            {
                fVerbose = TRUE;
                printf ("Verbose On\n");
            }
            else if (!_stricmp (argv[1], "off"))
                 {
                     fVerbose = FALSE;
                     printf ("Verbose Off\n");
                 }
            else printf ("%s\n", ekoLine);
            continue;
        }

        for (i = 0; i < cargv; i++) {
            if (*(p = argv[i]) == '%') {
                if ((j = atoi(++p)) < c)
                    argv[i] = v[j];
                else
                    usage("bad arg ", argv[i], 0);
                }
            }

        if (cargv)
            main(cargv, argv);
        }
    fclose( fp );

    exit( (int)fErrorExit ? (int)fNoSrc : fAnyUpd );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\updrn\updrn.c ===
/*
 *  UPDRN: UPD with rename
 *
 * HISTORY:
 *  manis : 22-May-87 : first written and released
 *  29-May-87   danl    Added explicit test for only two args
 *                      Removed rootpath tests
 *                      Added string.h
 *                      Don't remove trailing '\' from args to /g
 *  12-Jun-87   brianwi Get around FAPI one-open dir limitation
 */

#include <malloc.h>
#include <math.h>
#include <ctype.h>
#include <fcntl.h>
#include <string.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <io.h>
#include <stdio.h>
#include <process.h>
#include <ctype.h>
#include <math.h>
#include <stdlib.h>
#include <windows.h>
#include <tools.h>

// Forward Function Declarations..
void docopy( char *, struct findType * );
int setup( char *, int, void (*)() );
void __cdecl usage( char *, ... );
void getfile( int, char ** );


char const rgstrUsage[] = {
    "Usage: UPDRN [/fnvape] srcfile destfile\n"
    "       UPDRN /g file {arg}*\n"
    "\n"
    "   /f  Files differ, then copy\n"
    "   /n  No saving of replaced file to deleted directory\n"
    "   /v  Verbose\n"
    "   /a  Archive bit on source should NOT be reset\n"
    "   /p  Print actions, but do nothing\n"
    "   /e  Exit codes 1-error or no src else 0\n"
    "       Default is 1-copy done 0-no copy done\n"
    "   /g  Get params from file\n"
    };

#define BUFLEN  MAX_PATH
#define MAXARGV 20

unsigned _stack = 4096;
flagType fInGetfile = FALSE;
flagType fAll = FALSE;
flagType fDel = TRUE;
flagType fVerbose = FALSE;
flagType fArchiveReset = TRUE;
flagType fPrintOnly = FALSE;
flagType fErrorExit = FALSE;    /* TRUE => exit (1) errors or no src else 0 */
flagType fNoSrc = FALSE;        /* TRUE => "No src msg emitted" */

int cCopied = 0;
int fAnyUpd = 0;
struct findType buf;
char source[BUFLEN], dest[BUFLEN] ;

/* for use by getfile */
char *argv[MAXARGV];
char bufIn[BUFLEN];
char strLine[BUFLEN];
char ekoLine[BUFLEN]; /* undestroyed copy of line for echo */


void copyfile(src, srctype, dst)
char *src, *dst;
struct findType *srctype;
{
    char *result;
    flagType fNewfile = FALSE;

    /* if the file already exists, fdelete will return 0; then don't */
    /* notify the user that a file transfer has taken place.Otherwise*/
    /* a new file has been created so tell the user about it.        */

    printf("  %s => %s", src, dst);
    fAnyUpd = 1;
    if (!fPrintOnly) {
        if( fDel ) {
           fNewfile = (flagType)( (fdelete(dst)) ? TRUE : FALSE );
        }
        if (!(result = fcopy(src, dst))) {
            if (fArchiveReset)
                SetFileAttributes( src, srctype->fbuf.dwFileAttributes & ~FILE_ATTRIBUTE_ARCHIVE );
            if (fVerbose || fNewfile) printf(" [OK]");
            }
        else
            printf(" %s - %s", result, error());
    }
    else
        printf (" [no copy]");
    printf("\n");
    fflush(stdout);
}

void docopy (p, b)
/* copy source file to destination file based on time stamps */
/* and different switches.                                   */
char *p;
struct findType *b;
{
    int fNotFound;
    char *pPat;
    char *pT = p;
    struct findType *bT = b;

    pPat = malloc (BUFLEN);
    if (pPat) {
        strcpy(pPat, dest);
    
        cCopied++;
    
        if( ( fNotFound = ffirst(pPat, ~(FILE_ATTRIBUTE_DIRECTORY), &buf)) ||
            ( CompareFileTime( &buf.fbuf.ftLastWriteTime, &bT->fbuf.ftLastWriteTime ) < 0 ) ||
             ( fAll &&
               CompareFileTime( &buf.fbuf.ftLastWriteTime, &bT->fbuf.ftLastWriteTime ) > 0
             )
          ) {
             copyfile(pT, bT, pPat);
        }
        else if( !fNotFound &&
                 CompareFileTime( &buf.fbuf.ftLastWriteTime, &bT->fbuf.ftLastWriteTime ) == 0 &&
                 buf.fbuf.nFileSizeLow != bT->fbuf.nFileSizeLow
               ) {
            printf("\n\007UPDRN: warning - %s not copied\n", pT);
            printf("\007UPDRN: warning - same time, different length in src & dest\n", pT);
        }
    
        findclose( &buf );
        free (pPat);
    }
}

setup(pat, attr, rtn)
/* set up buffer for find first call. if the source file is valid */
/* and ffirst call is successful, call the routine "rtn".         */
char *pat;
int attr;
void (*rtn)();
{
    struct findType *fbuf;
    char *buf;

        if ((fbuf=(struct findType *)malloc(sizeof (*fbuf) + MAX_PATH ))==NULL)
        return FALSE;

    if (ffirst (pat, attr, fbuf)) {
        free ((char *) fbuf);
        return FALSE;
        }

        if ((buf = (char *)malloc(MAX_PATH)) == NULL) {
        free ((char *) fbuf);
        return FALSE;
        }

    drive (pat, buf);
    path (pat, strend (buf));
    pat = strend (buf);

    strcpy (pat, fbuf->fbuf.cFileName);
    _strlwr (pat);
    findclose (fbuf);
    (*rtn) (buf, fbuf);


    free (buf);
    free ((char *) fbuf);

    return TRUE;
}

void __cdecl usage( char *p, ... )
/* prints error messages */
{
    char **rgstr;

    rgstr = &p;
    if (*rgstr) {
        fprintf (stderr, "UPDRN: ");
        while (*rgstr)
            fprintf (stderr, "%s", *rgstr++);
        fprintf (stderr, "\n");
        }
    fputs (rgstrUsage, stderr);

    exit ((fErrorExit ? 1 : 0));
}

int
__cdecl
main (c, v)
int c;
char *v[];
{
    char *p, namebuf[ BUFLEN ];

    fAll = FALSE;
    fDel = TRUE;
    fArchiveReset = TRUE;
    fPrintOnly = FALSE;
    cCopied = 0;

    if (!fInGetfile)
        ConvertAppToOem( c, v );
        SHIFT(c, v);    /* Flush the command name */
    while( c && fSwitChr( *v[0] ) ) {
        p = v[ 0 ];
        SHIFT(c, v);
        while (*++p)
            switch (tolower(*p)) {
                case 'a':
                    fArchiveReset = FALSE;
                    break;
                case 'g':
                    if (fInGetfile)
                        usage("/g allowed only on command line", 0);
                    getfile(c, v);
                    break;
                case 'e':
                    fErrorExit = TRUE;
                    break;
                case 'v':
                    fVerbose = TRUE;
                    break;
                case 'f':
                    fAll = TRUE;
                    break;
                case 'n':
                    fDel = FALSE;
                    break;
                case 'p':
                    fPrintOnly = TRUE;
                    break;
                default:
                    usage("Invalid switch - ", p, 0);
                }
        }

        /* Must be at one source file and dest file. */
    if (c != 2)
        usage(0);

        /* Make sure source and destination dirs are valid */
        /* Wildcards not allowed                           */

    rootpath( v[1], dest );
    rootpath( v[0], source);

    if (!filename(source, namebuf))
        usage("Source file name not specified - ", source, 0);

    if (fileext(source, namebuf))
       if (strpbrk(namebuf,"*")!=NULL)
           usage("Wild cards not allowed - ", source, 0);

    if (fileext(dest, namebuf)){
     if (strpbrk(namebuf,"*")!=NULL)
        usage("Wild cards not allowed - ", dest, 0);
    }
    else
        usage("Destination file not specified - ", dest, 0);

    /* now compcopy the source file to dest file. source
       file has subset of the attributes specified      */

    if (fVerbose) {
       printf("Comparing and copying srcfile:   %s\n", source);
       printf("          To destination file:   %s\n", dest);
    }

    cCopied = 0;
    setup(source, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_ARCHIVE, (void ( *)())docopy);
    if (!cCopied) {
        printf("UPDRN: no src file matching %s\n", source);
        fNoSrc = 1;
    }

    if (!fInGetfile)
        return( (int)fErrorExit ? (int)fNoSrc : fAnyUpd );

    return 0;
}

/*  call if UPDRN /g getfile, reads lines from getfile and for each line
    calls main */

void getfile(c, v)
int c;
char *v[];
{
    int cargv = 0;
    FILE *fp;
    int i, j;
    char *p, *p2;
    char lbuf[BUFLEN];

    /*
     * 13-SEPT-90   w-barry
     *
     * Change open() to fopen() and replace assembly routines getl() and
     * getlinit() with fgets.
     */
    if (c == 0)
        usage("no getfile specified", 0);
    fInGetfile = TRUE;
    if( ( fp = fopen( *v, "r" ) ) == NULL ) {
        usage("error opening ", *v, 0);
    }
    SHIFT(c, v);
/*  getlinit((char far *)bufIn, BUFLEN, fh);
 *  while (getl(strLine, BUFLEN) != NULL) {
 */

    while( fgets( strLine, BUFLEN, fp ) != NULL ) {
        if (*strLine == '#')
            continue;
        if (*strLine == ';') {
            printf("%s\n", strLine);
            continue;
            }
        /* fgets doesn't remove \n */
        *strbscan(strLine, "\n") = '\0';
        cargv = 0;
        /* convert strLine into argv */
        p = strbskip(strLine, " ");
        strcpy (ekoLine, p + 5);
        while (*p) {
            argv[cargv++] = p;
            p = strbscan(p, " ");
            if (*p)
                *p++ = '\0';
            p = strbskip(p, " ");
            }

        if (!_stricmp (argv[0], "rem")) continue;
        if (!_stricmp (argv[0], "echo"))
        {
            if      (!_stricmp (argv[1], "on"))
            {
                fVerbose = TRUE;
                printf ("Verbose On\n");
            }
            else if (!_stricmp (argv[1], "off"))
                 {
                     fVerbose = FALSE;
                     printf ("Verbose Off\n");
                 }
            else printf ("%s\n", ekoLine);
            continue;
        }

     /* replace the arguments in the file : %0, %1 etc     */
     /* with the arguments from the command line           */
     /* lbuf : holds the strings formed by replacing %0 etc*/

        p2 = lbuf;
        for (i = 0; i < cargv; i++) {
            if (*(p = argv[i]) == '%') {
                if ((j = atoi(++p)) < c) {
                    strcpy(p2, v[j]);
                    argv[i] = strcat(p2,++p);
                    p2 += strlen(argv[i])+1;
                }
                else
                    usage("bad arg ", argv[i], 0);
                }
            }

        if (cargv)
            main(cargv, argv);
    }
    fclose( fp );
    exit( (int)fErrorExit ? (int)fNoSrc : fAnyUpd );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\uwdump\uwdump.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    uwdump.c

Abstract:

    This module implements a program which dumps the function table and
    unwind data for a specified executable file. It is an AMD64 specific
    program.

Author:

    David N. Cutler (davec) 6-Feb-2001

Environment:

    User mode.

Revision History:

    None.

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

//
// Define AMD64 exception handling structures and function prototypes.
//
// Define unwind operation codes.
//

typedef enum _UNWIND_OP_CODES {
    UWOP_PUSH_NONVOL = 0,
    UWOP_ALLOC_LARGE,
    UWOP_ALLOC_SMALL,
    UWOP_SET_FPREG,
    UWOP_SAVE_NONVOL,
    UWOP_SAVE_NONVOL_FAR,
    UWOP_SAVE_XMM,
    UWOP_SAVE_XMM_FAR,
    UWOP_SAVE_XMM128,
    UWOP_SAVE_XMM128_FAR,
    UWOP_PUSH_MACHFRAME
} UNWIND_OP_CODES, *PUNWIND_OP_CODES;

//
// Define unwind code structure.
//

typedef union _UNWIND_CODE {
    struct {
        UCHAR CodeOffset;
        UCHAR UnwindOp : 4;
        UCHAR OpInfo : 4;
    };

    USHORT FrameOffset;
} UNWIND_CODE, *PUNWIND_CODE;

//
// Define unwind information flags.
//

#define UNW_FLAG_NHANDLER 0x0
#define UNW_FLAG_EHANDLER 0x1
#define UNW_FLAG_UHANDLER 0x2
#define UNW_FLAG_CHAININFO 0x4

//
// Define unwind information structure.
//

typedef struct _UNWIND_INFO {
    UCHAR Version : 3;
    UCHAR Flags : 5;
    UCHAR SizeOfProlog;
    UCHAR CountOfCodes;
    UCHAR FrameRegister : 4;
    UCHAR FrameOffset : 4;
    UNWIND_CODE UnwindCode[1];

//
// The unwind codes are followed by an optional DWORD aligned field that
// contains the exception handler address or the address of chained unwind
// information. If an exception handler address is specified, then it is
// followed by the language specified exception handler data.
//
//  union {
//      ULONG ExceptionHandler;
//      ULONG FunctionEntry;
//  };
//
//  ULONG ExceptionData[];
//

} UNWIND_INFO, *PUNWIND_INFO;

//
// Define function table entry - a function table entry is generated for
// each frame function.
//

typedef struct _RUNTIME_FUNCTION {
    ULONG BeginAddress;
    ULONG EndAddress;
    ULONG UnwindData;
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;

//
// Scope table structure definition.
//

typedef struct _SCOPE_ENTRY {
    ULONG BeginAddress;
    ULONG EndAddress;
    ULONG HandlerAddress;
    ULONG JumpTarget;
} SCOPE_ENTRY;

typedef struct _SCOPE_TABLE {
    ULONG Count;
    struct
    {
        ULONG BeginAddress;
        ULONG EndAddress;
        ULONG HandlerAddress;
        ULONG JumpTarget;
    } ScopeRecord[1];
} SCOPE_TABLE, *PSCOPE_TABLE;

//
// Define register names.
//

PCHAR Register[] = {"rax", "rcx", "rdx", "rbx", "rsp", "rbp", "rsi", "rdi",
                    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
                    "xmm0", "xmm1", "xmm2", "xmm3", "xmm4", "xmm5", "xxm6",
                    "xmm7", "xmm8", "xmm9", "xmm10", "xmm11", "xmm12",
                    "xmm13", "xxm14", "xmm15"};

//
// Define the sector size and header buffer.
//

#define SECTOR_SIZE 512
CHAR LocalBuffer[SECTOR_SIZE * 2];

//
// Define input file stream.
//

FILE * InputFile;

//
// This gobal indicates whether we are processing an executable or an obj.
//

BOOLEAN IsObj;

//
// Define forward referenced prototypes.
//

VOID
DumpPdata (
    IN ULONG NumberOfSections,
    IN PIMAGE_SECTION_HEADER SectionHeaders,
    IN PIMAGE_SECTION_HEADER PdataHeader
    );

VOID
DumpUData (
    IN ULONG NumberOfSections,
    IN PIMAGE_SECTION_HEADER SectionHeaders,
    IN ULONG Virtual
    );

PIMAGE_SECTION_HEADER
FindSectionHeader (
    IN ULONG NumberOfSections,
    IN PIMAGE_SECTION_HEADER SectionHeaders,
    IN PCHAR SectionName
    );

VOID
ReadData (
    IN ULONG Position,
    OUT PVOID Buffer,
    IN ULONG Count
    );

USHORT
ReadWord (
    IN ULONG Position
    );

ULONG
ReadDword (
    IN ULONG Position
    );

//
// Main program.
//

int
__cdecl
main(
    int argc,
    char **argv
    )

{

    PIMAGE_FILE_HEADER FileHeader;
    PCHAR FileName;
    ULONG Index;
    PIMAGE_NT_HEADERS NtHeaders;
    ULONG NumberOfSections;
    PIMAGE_SECTION_HEADER PDataHeader;
    PIMAGE_SECTION_HEADER SectionHeaders;

    if (argc < 2) {
        printf("no executable file specified\n");

    } else {

        //
        // Open the input file.
        //

        FileName = argv[1];
        InputFile = fopen(FileName, "rb");
        if (InputFile != NULL) {

            //
            // Read the file header.
            //

            if (fread(&LocalBuffer[0],
                      sizeof(CHAR),
                      SECTOR_SIZE * 2,
                      InputFile) == (SECTOR_SIZE * 2)) {

                //
                // Get the NT header address.
                //

                NtHeaders = RtlImageNtHeader(&LocalBuffer[0]);
                if (NtHeaders != NULL) {
                    IsObj = FALSE;
                    FileHeader = &NtHeaders->FileHeader;
                } else {
                    IsObj = TRUE;
                    FileHeader = (PIMAGE_FILE_HEADER)LocalBuffer;
                }

                printf("FileHeader->Machine %d\n",FileHeader->Machine);

                if (FileHeader->Machine == IMAGE_FILE_MACHINE_AMD64) {

                    //
                    // Look up the .pdata section.
                    //

                    NumberOfSections = FileHeader->NumberOfSections;

                    SectionHeaders =
                        (PIMAGE_SECTION_HEADER)((PUCHAR)(FileHeader + 1) +
                                                FileHeader->SizeOfOptionalHeader);

                    PDataHeader = FindSectionHeader(NumberOfSections,
                                                    SectionHeaders,
                                                    ".pdata");

                    if (PDataHeader != NULL) {
                        printf("Dumping Unwind Information for file %s\n\n", FileName);
                        DumpPdata(NumberOfSections,
                                  &SectionHeaders[0],
                                  PDataHeader);

                        return 0;
                    }

                    printf("no .pdata section in image\n");

                } else {
                    printf("the specified file is not an amd64 executable\n");
                }

            } else {
                printf("premature end of file encountered on input file\n");
            }

            fclose(InputFile);

        } else {
            printf("can't open input file %s\n", FileName);
        }
    }

    return 0;
}

VOID
DumpPdata (
    IN ULONG NumberOfSections,
    IN PIMAGE_SECTION_HEADER SectionHeaders,
    IN PIMAGE_SECTION_HEADER PdataHeader
    )

{

    RUNTIME_FUNCTION Entry;
    ULONG Number;
    ULONG Offset;
    ULONG SectionSize;

    //
    // Dump a .pdata function table entry and then dump the associated
    // unwind data.
    //

    if (IsObj == FALSE) {
        SectionSize = PdataHeader->Misc.VirtualSize;
    } else {
        SectionSize = PdataHeader->SizeOfRawData;
    }

    Number = 1;
    Offset = 0;
    do {

        //
        // Read and dump the next function table entry.
        //

        ReadData(PdataHeader->PointerToRawData + Offset,
                 &Entry,
                 sizeof(RUNTIME_FUNCTION));

        printf(".pdata entry %d 0x%08lX 0x%08lX\n",
               Number,
               Entry.BeginAddress,
               Entry.EndAddress);

        //
        // Dump the unwind data assoicated with the function table entry.
        //

        DumpUData(NumberOfSections, SectionHeaders, Entry.UnwindData);

        //
        // Increment the entry number and update the offset to the next
        // function table entry.
        //

        Number += 1;
        Offset += sizeof(RUNTIME_FUNCTION);
    } while (Offset < SectionSize);

    //
    // Function offset and size of raw data should be equal if there is
    // the correct amount of data in the .pdata section.
    //

    if (Offset != SectionSize) {
        printf("incorrect size of raw data in .pdata, 0x%lx\n",
               PdataHeader->SizeOfRawData);
    }

    return;
}

VOID
DumpUData (
    IN ULONG NumberOfSections,
    IN PIMAGE_SECTION_HEADER SectionHeaders,
    IN ULONG Virtual
    )

{

    ULONG Allocation;
    ULONG Count;
    ULONG Displacement;
    ULONG FrameOffset = 0;
    ULONG FrameRegister = 0;
    ULONG Handler;
    ULONG Index;
    ULONG Offset;
    SCOPE_ENTRY ScopeEntry;
    UNWIND_CODE UnwindCode;
    UNWIND_INFO UnwindInfo;
    PIMAGE_SECTION_HEADER XdataHeader;

    //
    // Locate the section that contains the unwind data.
    //

    printf("\n");
    printf("  Unwind data: 0x%08lX\n\n", Virtual);

    if (IsObj == FALSE) {
        XdataHeader = SectionHeaders;
        for (Index = 0; Index < NumberOfSections; Index += 1) {
            if ((XdataHeader->VirtualAddress <= Virtual) &&
                (Virtual < (XdataHeader->VirtualAddress + XdataHeader->Misc.VirtualSize))) {
                break;
            }
    
            XdataHeader += 1;
        }
    
        if (Index == NumberOfSections) {
            printf("    unwind data address outside of image\n\n");
            return;
        }

        Offset = Virtual -
                 XdataHeader->VirtualAddress +
                 XdataHeader->PointerToRawData; 

    } else {

        //
        // This is an .obj, so there is only one Xdata header
        //

        XdataHeader = FindSectionHeader(NumberOfSections,
                                        SectionHeaders,
                                        ".xdata");

        Offset = Virtual + XdataHeader->PointerToRawData;
    }

    //
    // Read unwind information.
    //

    ReadData(Offset,
             &UnwindInfo,
             sizeof(UNWIND_INFO) - sizeof(UNWIND_CODE));

    //
    // Dump unwind version.
    //

    printf("    Unwind version: %d\n", UnwindInfo.Version);

    //
    // Dump unwind flags.
    //

    printf("    Unwind Flags: ");
    if ((UnwindInfo.Flags & UNW_FLAG_EHANDLER) != 0) {
        printf("EHANDLER ");
    }

    if ((UnwindInfo.Flags & UNW_FLAG_UHANDLER) != 0) {
        printf("UHANDLER ");
    }

    if ((UnwindInfo.Flags & UNW_FLAG_CHAININFO) != 0) {
        printf("CHAININFO");
    }

    if (UnwindInfo.Flags == 0) {
        printf("None");
    }

    printf("\n");

    //
    // Dump size of prologue.
    //

    printf("    Size of prologue: 0x%02lX\n", UnwindInfo.SizeOfProlog);

    //
    // Dump number of unwind codes.
    //

    printf("    Count of codes: %d\n", UnwindInfo.CountOfCodes);

    //
    // Dump frame register if specified.
    //

    if (UnwindInfo.FrameRegister != 0) {
        FrameOffset = UnwindInfo.FrameOffset * 16;
        FrameRegister = UnwindInfo.FrameRegister;
        printf("    Frame register: %s\n", Register[FrameRegister]);
        printf("    Frame offset: 0x%lx\n", FrameOffset);
    }

    //
    // Dump the unwind codes.
    //

    Offset += sizeof(UNWIND_INFO) - sizeof(UNWIND_CODE);
    if (UnwindInfo.CountOfCodes != 0) {
        printf("    Unwind codes:\n\n");
        Count = UnwindInfo.CountOfCodes;
        do {
            Count -= 1;
            UnwindCode.FrameOffset = ReadWord(Offset);
            Offset += sizeof(USHORT);
            printf("      Code offset: 0x%02lX, ", UnwindCode.CodeOffset);
            switch (UnwindCode.UnwindOp) {
            case UWOP_PUSH_NONVOL:
                printf("PUSH_NONVOL, register=%s\n", Register[UnwindCode.OpInfo]);
                break;

            case UWOP_ALLOC_LARGE:
                Count -= 1;
                Allocation = ReadWord(Offset);
                Offset += sizeof(USHORT);
                if (UnwindCode.OpInfo == 0) {
                    Allocation *= 8;

                } else {
                    Count -= 1;
                    Allocation = (Allocation << 16) + ReadWord(Offset);
                    Offset += sizeof(USHORT);
                }

                printf("ALLOC_LARGE, size=0x%lX\n", Allocation);
                break;

            case UWOP_ALLOC_SMALL:
                Allocation = (UnwindCode.OpInfo * 8) + 8;
                printf("ALLOC_SMALL, size=0x%lX\n", Allocation);
                break;

            case UWOP_SET_FPREG:
                printf("SET_FPREG, register=%s, offset=0x%02lX\n",
                       Register[FrameRegister], FrameOffset);
                break;

            case UWOP_SAVE_NONVOL:
                Count -= 1;
                Displacement = ReadWord(Offset) * 8;
                Offset += sizeof(USHORT);
                printf("SAVE_NONVOL, register=%s offset=0x%lX\n",
                       Register[UnwindCode.OpInfo],
                       Displacement);
                break;

            case UWOP_SAVE_NONVOL_FAR:
                Count -= 2;
                Displacement = ReadWord(Offset) << 16;
                Offset += sizeof(USHORT);
                Displacement = Displacement + ReadWord(Offset);
                Offset += sizeof(USHORT);
                printf("SAVE_NONVOL_FAR, register=%s offset=0x%lX\n",
                       Register[UnwindCode.OpInfo],
                       Displacement);
                break;

            case UWOP_SAVE_XMM:
                Count -= 1;
                Displacement = ReadWord(Offset) * 8;
                Offset += sizeof(USHORT);
                printf("SAVE_XMM, register=%s offset=0x%lX\n",
                       Register[UnwindCode.OpInfo + 16],
                       Displacement);
                break;

            case UWOP_SAVE_XMM_FAR:
                Count -= 2;
                Displacement = ReadWord(Offset) << 16;
                Offset += sizeof(USHORT);
                Displacement = Displacement + ReadWord(Offset);
                Offset += sizeof(USHORT);
                printf("SAVE_XMM_FAR, register=%s offset=0x%lX\n",
                       Register[UnwindCode.OpInfo + 16],
                       Displacement);
                break;

            case UWOP_SAVE_XMM128:
                Count -= 1;
                Displacement = ReadWord(Offset) * 16;
                Offset += sizeof(USHORT);
                printf("SAVE_XMM128, register=%s offset=0x%lX\n",
                       Register[UnwindCode.OpInfo + 16],
                       Displacement);
                break;

            case UWOP_SAVE_XMM128_FAR:
                Count -= 2;
                Displacement = ReadWord(Offset) << 16;
                Offset += sizeof(USHORT);
                Displacement = Displacement + ReadWord(Offset);
                Offset += sizeof(USHORT);
                printf("SAVE_XMM128_FAR, register=%s offset=0x%lX\n",
                       Register[UnwindCode.OpInfo + 16],
                       Displacement);
                break;

            case UWOP_PUSH_MACHFRAME:
                if (UnwindCode.OpInfo == 0) {
                    printf("PUSH_MACHFRAME without error code\n");

                } else {
                    printf("PUSH_MACHFRAME with error code\n");
                }

                break;
            }

        } while (Count != 0);
    }

    //
    // Dump exception data if there is an excpetion or termination
    // handler.
    //

    if (((UnwindInfo.Flags & UNW_FLAG_EHANDLER) != 0) ||
        ((UnwindInfo.Flags & UNW_FLAG_UHANDLER) != 0)) {

        if ((UnwindInfo.CountOfCodes & 1) != 0) {
            Offset += sizeof(USHORT);
        }

        Handler = ReadDword(Offset);
        Offset += sizeof(ULONG);
        Count = ReadDword(Offset);
        Offset += sizeof(ULONG);
        printf("\n");
        printf("    Language specific handler: 0x%08lX\n", Handler);
        printf("    Count of scope table entries: %d\n\n", Count);
        if (Count != 0) {
            printf("         Begin       End      Handler    Target\n");
            do {
                ReadData(Offset, &ScopeEntry, sizeof(SCOPE_ENTRY));
                printf("      0x%08lX 0x%08lX 0x%08lX 0x%08lX\n",
                       ScopeEntry.BeginAddress,
                       ScopeEntry.EndAddress,
                       ScopeEntry.HandlerAddress,
                       ScopeEntry.JumpTarget);

                Count -= 1;
                Offset += sizeof(SCOPE_ENTRY);
            } while (Count != 0);
        }
    }

    printf("\n");
    return;
}

PIMAGE_SECTION_HEADER
FindSectionHeader (
    IN ULONG NumberOfSections,
    IN PIMAGE_SECTION_HEADER SectionHeaders,
    IN PCHAR SectionName
    )
{
    ULONG RemainingSections;
    PIMAGE_SECTION_HEADER SectionHeader;

    SectionHeader = SectionHeaders;
    RemainingSections = NumberOfSections;

    while (RemainingSections > 0) {

        if (strncmp(SectionHeader->Name,
                    SectionName,
                    IMAGE_SIZEOF_SHORT_NAME) == 0) {

            return SectionHeader;
        }

        RemainingSections -= 1;
        SectionHeader += 1;
    }

    return NULL;
}

VOID
ReadData (
    IN ULONG Position,
    OUT PVOID Buffer,
    IN ULONG Count
    )

{

    if (fseek(InputFile,
              Position,
              SEEK_SET) == 0) {

        if (fread((PCHAR)Buffer,
                  1,
                  Count,
                  InputFile) == Count) {

           return;
        }
    }

    printf("premature end of file encounterd on inpout file\n");
    exit(0);
}

USHORT
ReadWord (
    IN ULONG Position
    )

{

    USHORT Buffer;

    ReadData(Position, &Buffer, sizeof(USHORT));
    return Buffer;
}

ULONG
ReadDword (
    IN ULONG Position
    )

{

    ULONG Buffer;

    ReadData(Position, &Buffer, sizeof(ULONG));
    return Buffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vdmperf\calcperf.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

   CalcPerf.c

Abstract:

   calculate perfoemance statistics

Author:



Environment:

   Win32

Revision History:

   10-20-91     Initial version



--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include "calcperf.h"

SYSTEM_VDM_INSTEMUL_INFO PerfInfo;
SYSTEM_VDM_INSTEMUL_INFO PreviousPerfInfo;

//
//  make the maximum for pages available a "grow only" max. (since the
//  amount of memory in a machine is limited. Set to 1 Mbytes here.
//

ULONG                                       PgAvailMax = 16384;
ULONG                                       PreviousInterruptCount;
ULONG                                       InterruptCount;


ULONG
InitPerfInfo()
/*++

Routine Description:

    Initialize data for perf measurements

Arguments:

   None

Return Value:

    Number of system processors (0 if error)

Revision History:

      10-21-91      Initial code

--*/

{
    NTSTATUS Status;

    Status = NtQuerySystemInformation(
                SystemVdmInstemulInformation,
                &PerfInfo,
                sizeof(PerfInfo),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        ExitProcess(1);
        }

    PreviousPerfInfo = PerfInfo;

    return(0);
}





BOOL
CalcCpuTime(
   PDISPLAY_ITEM    PerfListItem
   )

/*++

Routine Description:

   calculate and return %cpu time and time periods

Arguments:

   None

Return Value:


Revision History:

      10-21-91      Initial code

--*/

{
    NTSTATUS Status;

    Status = NtQuerySystemInformation(
                SystemVdmInstemulInformation,
                &PerfInfo,
                sizeof(PerfInfo),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        ExitProcess(1);
        }


    PerfListItem[IX_PUSHF].ChangeScale  = UpdatePerfInfo(
                    &PerfListItem[IX_PUSHF].TotalTime[0],
                    delta(OpcodePUSHF),
                    &PerfListItem[IX_PUSHF].Max);

    PerfListItem[IX_POPF].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[IX_POPF].TotalTime[0],
                    delta(OpcodePOPF),
                    &PerfListItem[IX_POPF].Max);

    PerfListItem[IX_IRET].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[IX_IRET].TotalTime[0],
                    delta(OpcodeIRET),
                    &PerfListItem[IX_IRET].Max);

    PerfListItem[IX_HLT].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[IX_HLT].TotalTime[0],
                    delta(OpcodeHLT),
                    &PerfListItem[IX_HLT].Max);

    PerfListItem[IX_CLI].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[IX_CLI].TotalTime[0],
                    delta(OpcodeCLI),
                    &PerfListItem[IX_CLI].Max);

    PerfListItem[IX_STI].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[IX_STI].TotalTime[0],
                    delta(OpcodeSTI),
                    &PerfListItem[IX_STI].Max);

    PerfListItem[IX_BOP].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[IX_BOP].TotalTime[0],
                    delta(BopCount),
                    &PerfListItem[IX_BOP].Max);

    PerfListItem[IX_SEGNOTP].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[IX_SEGNOTP].TotalTime[0],
                    delta(SegmentNotPresent),
                    &PerfListItem[IX_SEGNOTP].Max);

    PerfListItem[IX_VDMOPCODEF].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[IX_VDMOPCODEF].TotalTime[0],
                    delta(VdmOpcode0F),
                    &PerfListItem[IX_VDMOPCODEF].Max);

    PerfListItem[IX_INB].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[IX_INB].TotalTime[0],
                    delta(OpcodeINB),
                    &PerfListItem[IX_INB].Max);

    PerfListItem[IX_INW].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[IX_INW].TotalTime[0],
                    delta(OpcodeINW),
                    &PerfListItem[IX_INW].Max);

    PerfListItem[IX_OUTB].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[IX_OUTB].TotalTime[0],
                    delta(OpcodeOUTB),
                    &PerfListItem[IX_OUTB].Max);

    PerfListItem[IX_OUTW].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[IX_OUTW].TotalTime[0],
                    delta(OpcodeOUTW),
                    &PerfListItem[IX_OUTW].Max);

    PerfListItem[IX_INSW].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[IX_INSW].TotalTime[0],
                    delta(OpcodeINSW),
                    &PerfListItem[IX_INSW].Max);

    PerfListItem[IX_OUTSB].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[IX_OUTSB].TotalTime[0],
                    delta(OpcodeOUTSB),
                    &PerfListItem[IX_OUTSB].Max);

    PerfListItem[IX_OUTSW].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[IX_OUTSW].TotalTime[0],
                    delta(OpcodeOUTSW),
                    &PerfListItem[IX_OUTSW].Max);

    PreviousPerfInfo = PerfInfo;

    return(TRUE);
}


BOOL
UpdatePerfInfo(
   PULONG    DataPointer,
   ULONG     NewDataValue,
   PULONG    OldMaxValue
   )

/*++

Routine Description:

    Shift array of DATA_LIST_LENGTH USORTS and add the new value to the
    start of list

Arguments:

    DataPointer  - Pointer to the start of a DATA_LIST_LENGTH array
    NewDataValue - Data element to be added
    OldMaxValue  - Scale value

Return Value:

    TRUE is MaxValue must be increased or decreased

Revision History:

      10-21-91      Initial code

--*/

{
    ULONG   Index;
    ULONG   ScanMax;

    //
    //  Shift DataArray while keeping track of the max value
    //


    //
    //  Set temp max to 100 to init a minimum maximum
    //

    ScanMax = 100;

    for (Index=DATA_LIST_LENGTH-1;Index>=1;Index--) {

        DataPointer[Index] = DataPointer[Index-1];



        if (DataPointer[Index] > ScanMax) {
            ScanMax = DataPointer[Index];
        }
    }

    //
    // add and check first value
    //

    DataPointer[0] = NewDataValue;

    if (NewDataValue > ScanMax) {
        ScanMax = NewDataValue;
    }

    //
    //  If OldMaxValue = NULL then do not do a max limit check
    //

    if (OldMaxValue == NULL) {
        return(FALSE);
    }


    //
    //  If Max values changed then undate the new max
    //  value and return TRUE.
    //

    if (ScanMax != *OldMaxValue) {
        *OldMaxValue = ScanMax;
        return(TRUE);
    }

    return(FALSE);

}



VOID
InitListData(
   PDISPLAY_ITEM    PerfListItem,
   ULONG            NumberOfItems
   )

/*++

Routine Description:

    Init all perf data structures

Arguments:

    PerfListItem  - array of all perf categories
    NumberOfItems - Number of items to init

Return Value:


Revision History:

      10-21-91      Initial code

--*/

{
    ULONG   ListIndex,DataIndex;


    for (ListIndex=0;ListIndex<NumberOfItems;ListIndex++) {
        PerfListItem[ListIndex].Max = 100;
        PerfListItem[ListIndex].ChangeScale = FALSE;
        for (DataIndex=0;DataIndex<DATA_LIST_LENGTH;DataIndex++) {
            PerfListItem[ListIndex].TotalTime[DataIndex] = 0;
            PerfListItem[ListIndex].KernelTime[DataIndex] = 0;
            PerfListItem[ListIndex].UserTime[DataIndex] = 0;
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vdmperf\calcperf.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    perfmtrp.h

Abstract:

    This module contains NT/Win32 Perfmtr private data and types

Author:

    Mark Enstrom (marke) 28-Mar-1991

Revision History:

--*/

#ifndef _CALCPERFH_INCLUDED_
#define _CALCPERFH_INCLUDED_

#define MAX_PROCESSOR 8
#define DATA_LIST_LENGTH 100
#define DELAY_SECONDS 2

//
// Hi-Tech macro to figure out how much a field has changed by.
//

#define delta(FLD) (PerfInfo.FLD - PreviousPerfInfo.FLD)

//
// display const
//

#define IX_PUSHF        0
#define IX_POPF         1
#define IX_IRET         2
#define IX_HLT          3
#define IX_CLI          4
#define IX_STI          5
#define IX_BOP          6
#define IX_SEGNOTP      7
#define IX_VDMOPCODEF   8
#define IX_INTNN        9
#define IX_INTO         10
#define IX_INB          11
#define IX_INW          12
#define IX_OUTB         13
#define IX_OUTW         14
#define IX_INSB         15
#define IX_INSW         16
#define IX_OUTSB        17
#define IX_OUTSW        18

#define SAVE_SUBJECTS  19
#define BORDER_WIDTH   2
#define INDENT_WIDTH   8
#define GRAPH_WIDTH    130
#define GRAPH_HEIGHT   40
#define PERF_METER_CPU_CYCLE 10

//
//  time constant for sampling performance
//

#define PERF_TIME_DELAY 1000

//
//  types of display modes
//

#define DISPLAY_MODE_CPU_ONLY   0
#define DISPLAY_MODE_CPU        10
#define DISPLAY_MODE_VM         20
#define DISPLAY_MODE_CACHE      30
#define DISPLAY_MODE_POOL       40
#define DISPLAY_MODE_IO         50
#define DISPLAY_MODE_LPC        60
#define DISPLAY_MODE_SVR        70

//
// structure to save screen statistics
//

typedef struct _CPU_DATA_LIST
{
    PUCHAR   KernelTime;
    PUCHAR   UserTime;
    PUCHAR   TotalTime;
} CPU_DATA_LIST,*PCPU_DATA_LIST;



typedef struct _PERF_DATA_LIST
{
    PULONG  PerfData;
} PERF_DATA_LIST,*PPERF_DATA_LIST;

//
//  This info packet is associated with each
//  performance item
//

typedef struct tagDISPLAYITEM
{
    HDC     MemoryDC;
    HBITMAP MemoryBitmap;
    ULONG   Max;
    ULONG   PositionX;
    ULONG   PositionY;
    ULONG   Width;
    ULONG   Height;
    ULONG   NumberOfElements;
    ULONG   CurrentDrawingPos;
    RECT    Border;
    RECT    GraphBorder;
    RECT    TextBorder;
    BOOL    Display;
    BOOL    ChangeScale;
    ULONG   KernelTime[DATA_LIST_LENGTH];
    ULONG   UserTime[DATA_LIST_LENGTH];
    ULONG   TotalTime[DATA_LIST_LENGTH];
} DISPLAY_ITEM,*PDISPLAY_ITEM;

//
// flag to activate each menu selection
//

#define DISPLAY_INACTIVE 0
#define DISPLAY_ACTIVE   1


//
//  Keep book-keeping info for all processors
//

typedef struct _CPU_VALUE
{
        LARGE_INTEGER   KernelTime;
        LARGE_INTEGER   UserTime;
        LARGE_INTEGER   IdleTime;
        ULONG           InterruptCount;
} CPU_VALUE,*PCPU_VALUE;



BOOL
UpdatePerfInfo(
   PULONG   DataPointer,
   ULONG    NewDataValue,
   PULONG   OldMaxValue
   );


VOID
InitListData(
   PDISPLAY_ITEM    PerfListItem,
   ULONG            NumberOfItems
   );

#endif /* _CALCPERFH_INCLUDED */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vdmperf\draw.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    Draw.c

Abstract:

   Win32 application to display performance statictics. This routine implements
   graphics output for display windows.

Author:

   Mark Enstrom  (marke)

Environment:

   Win32

Revision History:

   10-07-92     Initial version



--*/

//
// set variable to define global variables
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <math.h>
#include <errno.h>
#include "vdmperf.h"

extern DISPLAY_ITEM    PerfDataList[SAVE_SUBJECTS];
extern VDMPERF_INFO    VdmperfInfo;
extern PUCHAR          PerfNames[];



BOOLEAN
FitPerfWindows(
    IN  HWND            hWnd,
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItems,
    IN  ULONG           NumberOfWindows
    )

/*++

Routine Description:

    Calculate all parameters to fit the given number of
    windows into the app window. Fill out the data structure
    for each sub-window

Arguments:

    hDC             -   Screen context
    DisplayItems    -   List of display structures
    NumberOfWindows -   Number of sub-windows

Return Value:

    Status

Revision History:

      02-17-91      Initial code

--*/

{
    RECT    ClientRect;
    int     cx,cy;
    UINT    Index;
    int     ActiveWindows,IndexX,IndexY;
    int     WindowsX,WindowsY,WindowWidth,WindowHeight;
    int     LastRowWidth,LoopWidth;
    double  fWindowsX,fActiveWindows,fcx,fcy;

    //
    //  Find out the client area bounds
    //

    GetClientRect(hWnd,&ClientRect);

    cx = ClientRect.right;
    cy = ClientRect.bottom - 2;   // subtract 2 to give a little more border

    //
    //  Find out how many perf windows are active
    //

    ActiveWindows = 0;

    for (Index=0;Index<NumberOfWindows;Index++) {
        if (DisplayItems[Index].Display == TRUE) {
            ActiveWindows++;
        }
    }

    //
    // Return if there are no active windows to display
    //

    if (ActiveWindows == 0) {
        return(TRUE);
    }


    //
    //  Now convert the window dimensions to floating point and
    //  then take the square root of the window dimension to find
    //  out the number of windows in the x direction
    //

    fActiveWindows = 1.0 * ActiveWindows;

    fcx = 1.0 * cx;
    fcy = 1.0 * cy;

    if (fcy != 0.0) {
        fWindowsX = sqrt((fcx * fActiveWindows) / fcy);
    }   else {

        //
        // If fcy = 0 then return since this is an error condition that
        // would cause a divide by zero.
        //

        return(FALSE);
    }

    //
    // convert back to integer
    //

    WindowsX = (int)fWindowsX;

    if (WindowsX == 0) {
        WindowsX = 1;
    } else if (WindowsX > ActiveWindows) {
        WindowsX = ActiveWindows;
    }

    WindowsY = ActiveWindows / WindowsX;

    //
    //  Add on extra line to Y to take care of the left over windows ie:
    //  if there are 15 active windows and the x number = 7 then y = 2 with 1
    //  left over.
    //

    Index = ActiveWindows - (WindowsX * WindowsY);

    if (Index > 0) {
        WindowsY++;
        LastRowWidth = cx / Index;
    } else {
        LastRowWidth = cx / WindowsX;
    }

    WindowWidth  = cx / WindowsX;
    WindowHeight = cy / WindowsY;

    //
    // Assign positions for each active window
    //

    Index  = 0;

    for (IndexY=0;IndexY<WindowsY;IndexY++) {
        for (IndexX=0;IndexX<WindowsX;IndexX++) {

            //
            // Find the next active display item
            //

            while ((DisplayItems[Index].Display != TRUE) && (Index < NumberOfWindows)) {
                Index++;
            }

            //
            //  Add y fixup for last row
            //

            if (IndexY == WindowsY - 1) {
                LoopWidth = LastRowWidth;
            } else {
                LoopWidth = WindowWidth;
            }


            DisplayItems[Index].PositionX = LoopWidth  * IndexX;
            DisplayItems[Index].PositionY = WindowHeight * IndexY + 1;  // +1 for more top border
            DisplayItems[Index].Width     = LoopWidth - 1;
            DisplayItems[Index].Height    = WindowHeight - 1;

            //
            // Last Column fix-up to use all of window.
            //

            if (IndexX == WindowsX - 1) {
                DisplayItems[Index].Width = cx - DisplayItems[Index].PositionX - 1;
            }

            //
            //
            //

            Index++;

            if (Index >= NumberOfWindows) {
                break;
            }

        }


        if (Index >= NumberOfWindows) {
            break;
        }


    }

    return(TRUE);
}



VOID
CalcDrawFrame(
    PDISPLAY_ITEM   DisplayItem
    )
/*++

Routine Description:

    Calculate all borders for graphics windows

Arguments:

    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    LONG    x1,x2,y1,y2;
    LONG    gx1,gx2,gy1,gy2;
    LONG    tx1,tx2,ty1,ty2;
    LONG    GraphHeight,TextHeight;
    BOOLEAN TextWindow;

    double  fx1,fx2,fy1;

    //
    // Draw a 3-d stand out box around item window
    //

    x1 = DisplayItem->PositionX + 2;
    x2 = DisplayItem->PositionX + DisplayItem->Width - 2;
    y1 = DisplayItem->PositionY + 2;
    y2 = DisplayItem->PositionY + DisplayItem->Height - 2;

    //
    // find out in there is enough space for a text window
    //

    if ((y2 - y1 - 12) > 30) {

        TextWindow = TRUE;

        //
        // Calculate dimensions for a text window and a graphics window
        //
        // fx1 = portion of the window - bordres and free space
        //
        // fx2 = fraction of window used for graphics
        //
        // fy1 = fraction of winddow used for text
        //

        fx1 = (y2 - y1 - 10);

        fx2 = fx1 * 0.6666;
        fy1 = fx1 * 0.3333;

        GraphHeight = (LONG)fx2;
        TextHeight  = (LONG)fy1;

        if (TextHeight > 20) {
            GraphHeight += TextHeight-20;
            TextHeight = 20;
        }

        //
        // Calculate window boundaries
        //

        gx1 = x1 + 4;
        gx2 = x2 - 4;
        gy1 = y1 + 4;
        gy2 = y1 + 4 + GraphHeight + 1;

        tx1 = x1 + 4;
        tx2 = x2 - 4;
        ty1 = gy2 + 1 + 2 + 1;  // border,free space,border
        ty2 = gy2 + TextHeight + 1;

    }   else {

        TextWindow = FALSE;
        GraphHeight = y2 - y1 - 10;
        gx1 = x1 + 4;
        gx2 = x2 - 4;
        gy1 = y1 + 4;
        gy2 = y2 - 4;
        tx1 = tx2 = ty1 = ty2 = 0;

    }

    //
    // Fill in structures for drawing text and graphics
    //

    DisplayItem->Border.left        = x1;
    DisplayItem->Border.right       = x2;
    DisplayItem->Border.top         = y1;
    DisplayItem->Border.bottom      = y2;

    DisplayItem->GraphBorder.left   = gx1;
    DisplayItem->GraphBorder.right  = gx2;
    DisplayItem->GraphBorder.top    = gy1;
    DisplayItem->GraphBorder.bottom = gy2;

    DisplayItem->TextBorder.left    = tx1;
    DisplayItem->TextBorder.right   = tx2;
    DisplayItem->TextBorder.top     = ty1;
    DisplayItem->TextBorder.bottom  = ty2;
}




VOID
DrawFrame(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    )
/*++

Routine Description:

    Draw the window frame for a performance window

Arguments:

    hDC         - Device Context for window
    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    RECT    DrawRect;
    LONG    x1,x2,y1,y2;
    LONG    gx1,gx2,gy1,gy2;
    LONG    tx1,tx2,ty1,ty2;

    //
    // Draw a 3-d stand out box around item window
    //

    x1 = DisplayItem->Border.left;
    x2 = DisplayItem->Border.right;
    y1 = DisplayItem->Border.top;
    y2 = DisplayItem->Border.bottom;

    gx1 = DisplayItem->GraphBorder.left;
    gx2 = DisplayItem->GraphBorder.right;
    gy1 = DisplayItem->GraphBorder.top;
    gy2 = DisplayItem->GraphBorder.bottom;

    tx1 = DisplayItem->TextBorder.left;
    tx2 = DisplayItem->TextBorder.right;
    ty1 = DisplayItem->TextBorder.top;
    ty2 = DisplayItem->TextBorder.bottom;

    //
    // Draw top border in light shade
    //

    DrawRect.left   = x1;
    DrawRect.right  = x2;
    DrawRect.top    = y1;
    DrawRect.bottom = y1 + 2;

    FillRect(hDC,&DrawRect,VdmperfInfo.hLightBrush);

    //
    // Draw Left border in light shade
    //

    DrawRect.left   = x1;
    DrawRect.right  = x1 + 2;
    DrawRect.top    = y1;
    DrawRect.bottom = y2;

    FillRect(hDC,&DrawRect,VdmperfInfo.hLightBrush);

    //
    // Draw right border in dark shade
    //


    DrawRect.left   = x2 - 2;
    DrawRect.right  = x2;
    DrawRect.top    = y1;
    DrawRect.bottom = y2;

    FillRect(hDC,&DrawRect,VdmperfInfo.hDarkBrush);

    //
    // draw bottom in dark shade
    //

    DrawRect.left   = x1;
    DrawRect.right  = x2;
    DrawRect.top    = y2-2;
    DrawRect.bottom = y2;

    FillRect(hDC,&DrawRect,VdmperfInfo.hDarkBrush);

    //
    // Draw graphics area single border
    //

    //
    // Draw top border in dark shade
    //

    DrawRect.left   = gx1;
    DrawRect.right  = gx2;
    DrawRect.top    = gy1;
    DrawRect.bottom = gy1+1;

    FillRect(hDC,&DrawRect,VdmperfInfo.hDarkBrush);

    //
    // Draw Left border in Dark shade
    //

    DrawRect.left   = gx1;
    DrawRect.right  = gx1 + 1;
    DrawRect.top    = gy1;
    DrawRect.bottom = gy2;

    FillRect(hDC,&DrawRect,VdmperfInfo.hDarkBrush);

    //
    // Draw right border in Light shade
    //


    DrawRect.left   = gx2 - 1;
    DrawRect.right  = gx2;
    DrawRect.top    = gy1;
    DrawRect.bottom = gy2;

    FillRect(hDC,&DrawRect,VdmperfInfo.hLightBrush);

    //
    // draw bottom in Light shade
    //

    DrawRect.left   = gx1;
    DrawRect.right  = gx2;
    DrawRect.top    = gy2-1;
    DrawRect.bottom = gy2;

    FillRect(hDC,&DrawRect,VdmperfInfo.hLightBrush);

    if (tx2 > 0) {

        //
        // Draw top border in Dark shade
        //

        DrawRect.left   = tx1;
        DrawRect.right  = tx2;
        DrawRect.top    = ty1;
        DrawRect.bottom = ty1 + 1;

        FillRect(hDC,&DrawRect,VdmperfInfo.hDarkBrush);

        //
        // Draw Left border in Dark shade
        //

        DrawRect.left   = tx1;
        DrawRect.right  = tx1 + 1;
        DrawRect.top    = ty1;
        DrawRect.bottom = ty2;

        FillRect(hDC,&DrawRect,VdmperfInfo.hDarkBrush);

        //
        // Draw right border in Light shade
        //


        DrawRect.left   = tx2 - 1;
        DrawRect.right  = tx2;
        DrawRect.top    = ty1;
        DrawRect.bottom = ty2;

        FillRect(hDC,&DrawRect,VdmperfInfo.hLightBrush);

        //
        // draw bottom in Light shade
        //

        DrawRect.left   = tx1;
        DrawRect.right  = tx2;
        DrawRect.top    = ty2-1;
        DrawRect.bottom = ty2;

        FillRect(hDC,&DrawRect,VdmperfInfo.hLightBrush);

    }
}




VOID
DrawPerfText(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem,
    UINT            Item
    )
/*++

Routine Description:

    Draw text into the perf window

Arguments:

    hDC         - Device Context for window
    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    RECT    TextRect;
    UCHAR   TextStr[50];
    UINT    FontSize;

    //
    // Check that text display is enabled
    //

    if (DisplayItem->TextBorder.right == 0) {
        return;
    }

    TextRect.left = DisplayItem->TextBorder.left +1;
    TextRect.right = DisplayItem->TextBorder.right -1;
    TextRect.top = DisplayItem->TextBorder.top +1;
    TextRect.bottom = DisplayItem->TextBorder.bottom -1;

    FillRect(hDC,&TextRect,VdmperfInfo.hBackground);

    SetBkColor(hDC,RGB(192,192,192));

    //
    //  Decide which font to draw with
    //

    FontSize =  TextRect.bottom - TextRect.top;

    if (FontSize >= 15) {
        VdmperfInfo.hOldFont = SelectObject(hDC,VdmperfInfo.LargeFont);
    } else if (FontSize > 10) {
        VdmperfInfo.hOldFont = SelectObject(hDC,VdmperfInfo.MediumFont);
    } else {
        VdmperfInfo.hOldFont = SelectObject(hDC,VdmperfInfo.SmallFont);
    }

    DrawText(
                hDC,
                PerfNames[Item],
                strlen(PerfNames[Item]),
                &TextRect,
                DT_LEFT | DT_VCENTER | DT_SINGLELINE
             );


    //
    // Build the numeric value
    //

    wsprintf(TextStr,"   %li",DisplayItem->TotalTime[0]);

    DrawText(
                hDC,
                TextStr,
                strlen(TextStr),
                &TextRect,
                DT_RIGHT | DT_VCENTER | DT_SINGLELINE
             );




    SelectObject(hDC,VdmperfInfo.hOldFont);

}





VOID
DrawPerfGraph(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    )
/*++

Routine Description:

    Draw graphics into the perf window

Arguments:

    hDC         - Device Context for window
    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    RECT    GraphRect,MemGraphRect;
    ULONG   Scale,i,GraphWidth,GraphHeight;



    GraphRect.left   = DisplayItem->GraphBorder.left   + 1;
    GraphRect.right  = DisplayItem->GraphBorder.right  - 1;
    GraphRect.top    = DisplayItem->GraphBorder.top    + 1;
    GraphRect.bottom = DisplayItem->GraphBorder.bottom - 1;

    GraphWidth  = GraphRect.right  - GraphRect.left -1;
    GraphHeight = GraphRect.bottom - GraphRect.top -1;

    //
    // Memory bitmap is zero-offset for all windows, add 1 to make fillrect fill out
    // to right and bottom edge
    //

    MemGraphRect.left   = 0;
    MemGraphRect.right  = GraphWidth +1;
    MemGraphRect.top    = 0;
    MemGraphRect.bottom = GraphHeight +1;

    FillRect(DisplayItem->MemoryDC,&MemGraphRect,VdmperfInfo.hBackground);

    MemGraphRect.right  = GraphWidth;
    MemGraphRect.bottom = GraphHeight;

    if (DisplayItem->Max == 0) {
        DisplayItem->Max = 1;
    }

    //
    // calculate scale from data to perf window
    //

    //
    //  Outline object in green
    //



    SelectObject(DisplayItem->MemoryDC,VdmperfInfo.hRedPen);

    //
    // X scale factor (100 items in x space). Scale can not be less than 1
    //

    Scale = (GraphWidth -1)/ DATA_LIST_LENGTH;
    if (Scale == 0) {
        Scale = 1;
    }


    MoveToEx(DisplayItem->MemoryDC,
             MemGraphRect.right,
             MemGraphRect.bottom - (DisplayItem->TotalTime[0] * GraphHeight)/ DisplayItem->Max,
             (LPPOINT)NULL);




    for (i=1;((i<DATA_LIST_LENGTH) && i*Scale < GraphWidth);i++) {
        LineTo(DisplayItem->MemoryDC,
               MemGraphRect.right - Scale * i,
               MemGraphRect.bottom - (DisplayItem->TotalTime[i] * GraphHeight)/DisplayItem->Max);

    }

    //
    //  Draw UserTime if needed
    //

    if (DisplayItem->NumberOfElements>1) {

        //
        // Select kernel pen
        //

        SelectObject(DisplayItem->MemoryDC,VdmperfInfo.hRedPen);

        MoveToEx(DisplayItem->MemoryDC,
             MemGraphRect.right,
             MemGraphRect.bottom - (DisplayItem->KernelTime[0] * GraphHeight)/ DisplayItem->Max,
             (LPPOINT)NULL);




        for (i=1;((i<DATA_LIST_LENGTH) && i*Scale < GraphWidth);i++) {
            LineTo(DisplayItem->MemoryDC,
                    MemGraphRect.right - Scale * i,
                    MemGraphRect.bottom - (DisplayItem->KernelTime[i] * GraphHeight)/DisplayItem->Max
               );

        }

        //
        // Select User Pen
        //

        SelectObject(DisplayItem->MemoryDC,VdmperfInfo.hGreenPen);

        MoveToEx(DisplayItem->MemoryDC,
             MemGraphRect.right,
             MemGraphRect.bottom - (DisplayItem->UserTime[0] * GraphHeight)/ DisplayItem->Max,
             (LPPOINT)NULL);

        for (i=1;((i<DATA_LIST_LENGTH) && i * Scale < GraphWidth);i++) {
            LineTo(DisplayItem->MemoryDC,
               MemGraphRect.right - Scale * i,
               MemGraphRect.bottom - (DisplayItem->UserTime[i] * GraphHeight)/DisplayItem->Max);

        }
    }


    BitBlt(
            hDC,
            GraphRect.left,
            GraphRect.top,
            GraphWidth+1,
            GraphHeight+1,
            DisplayItem->MemoryDC,
            0,
            0,
            SRCCOPY);


}

VOID
ShiftPerfGraph(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    )
/*++

Routine Description:

    Shift memory bitmap 1 location left then draw the 1 new data point.
    BitBlt this to the screen.


Arguments:

    hDC         - Device Context for window
    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    RECT    GraphRect,MemGraphRect,FillArea;
    ULONG   Scale,GraphWidth,GraphHeight;



    GraphRect.left   = DisplayItem->GraphBorder.left   + 1;
    GraphRect.right  = DisplayItem->GraphBorder.right  - 1;
    GraphRect.top    = DisplayItem->GraphBorder.top    + 1;
    GraphRect.bottom = DisplayItem->GraphBorder.bottom - 1;

    GraphWidth  = GraphRect.right  - GraphRect.left -1;
    GraphHeight = GraphRect.bottom - GraphRect.top -1;

    //
    // Memory bitmap is zero-offset for all windows, add 1 to make fillrect fill out
    // to right and bottom edge
    //

    MemGraphRect.left   = 0;
    MemGraphRect.right  = GraphWidth;
    MemGraphRect.top    = 0;
    MemGraphRect.bottom = GraphHeight;

    if (DisplayItem->Max == 0) {
        DisplayItem->Max = 1;
    }

    //
    // calculate scale from data to perf window
    //
    // X scale factor (100 items in x space). Scale can not be less than 1
    //

    Scale = (GraphWidth -1)/ DATA_LIST_LENGTH;
    if (Scale == 0) {
        Scale = 1;
    }

    //
    // Shift memory image left by scale
    //


    BitBlt( DisplayItem->MemoryDC,
            0,
            0,
            GraphWidth+1 - Scale,
            GraphHeight+1,
            DisplayItem->MemoryDC,
            Scale,
            0,
            SRCCOPY);


    //
    // Fill The new area on the right of the screen
    //

    FillArea.left   = GraphWidth +1 - Scale;
    FillArea.right  = GraphWidth +1;
    FillArea.top    = 0;
    FillArea.bottom = GraphHeight +1;

    FillRect(DisplayItem->MemoryDC,&FillArea,VdmperfInfo.hBackground);


    //
    // Draw the 1 new data point
    //

    SelectObject(DisplayItem->MemoryDC,VdmperfInfo.hRedPen);

    MoveToEx(DisplayItem->MemoryDC,
             MemGraphRect.right,
             MemGraphRect.bottom - (DisplayItem->TotalTime[0] * GraphHeight)/ DisplayItem->Max,
             (LPPOINT)NULL);




    LineTo(DisplayItem->MemoryDC,
            MemGraphRect.right - Scale,
            MemGraphRect.bottom - (DisplayItem->TotalTime[1] * GraphHeight)/DisplayItem->Max);


    //
    //  Draw UserTime if needed
    //

    if (DisplayItem->NumberOfElements>1) {

        //
        // Select kernel pen
        //

        SelectObject(DisplayItem->MemoryDC,VdmperfInfo.hRedPen);

        MoveToEx(DisplayItem->MemoryDC,
             MemGraphRect.right,
             MemGraphRect.bottom - (DisplayItem->KernelTime[0] * GraphHeight)/ DisplayItem->Max,
             (LPPOINT)NULL);




        LineTo(
                DisplayItem->MemoryDC,
                MemGraphRect.right - Scale,
                MemGraphRect.bottom - (DisplayItem->KernelTime[1] * GraphHeight)/DisplayItem->Max
              );

        //
        // Select User Pen
        //

        SelectObject(DisplayItem->MemoryDC,VdmperfInfo.hGreenPen);

        MoveToEx(
                    DisplayItem->MemoryDC,
                    MemGraphRect.right,
                    MemGraphRect.bottom - (DisplayItem->UserTime[0] * GraphHeight)/ DisplayItem->Max,
                    (LPPOINT)NULL
                 );

        LineTo(
                DisplayItem->MemoryDC,
                MemGraphRect.right - Scale,
                MemGraphRect.bottom - (DisplayItem->UserTime[1] * GraphHeight)/DisplayItem->Max
              );

    }


    BitBlt(
            hDC,
            GraphRect.left,
            GraphRect.top,
            GraphWidth+1,
            GraphHeight+1,
            DisplayItem->MemoryDC,
            0,
            0,
            SRCCOPY);


}



BOOLEAN
CreateMemoryContext(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    )
/*++

Routine Description:

    Create a memory context and a memory bitmap for each perf window



Arguments:

    hDC         - Device Context for window
    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{

    int     Width;
    int     Height;

    if (DisplayItem->Display == TRUE) {

        //
        //  Calculate width of memory bitmap needed
        //

        Width  = DisplayItem->GraphBorder.right - DisplayItem->GraphBorder.left;
        Height = DisplayItem->GraphBorder.bottom - DisplayItem->GraphBorder.top;

        if ((Width<=0) || (Height <= 0)) {

            //
            // Disable this window that is to small to be seen
            //

            DisplayItem->Display = FALSE;

            return(TRUE);
        }

        //
        //  Create DC and Bitmap
        //

        DisplayItem->MemoryDC     = CreateCompatibleDC(hDC);

        if (DisplayItem->MemoryDC == NULL) {
            return(FALSE);
        }

        //DbgPrint("Createcompatiblebitmap %i %i\n",Width,Height);

        DisplayItem->MemoryBitmap = CreateCompatibleBitmap(hDC,Width,Height);

        if (DisplayItem->MemoryBitmap == 0) {
            return(FALSE);
        }

        SelectObject(DisplayItem->MemoryDC,DisplayItem->MemoryBitmap);

    }

    return(TRUE);
}



VOID
DeleteMemoryContext(
    PDISPLAY_ITEM   DisplayItem
    )
/*++

Routine Description:

    Delete memory bitmap and context

Arguments:

    hDC         - Device Context for window
    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{

    if (DisplayItem->MemoryDC != NULL) {
        DeleteDC(DisplayItem->MemoryDC);
    }

    if (DisplayItem->MemoryBitmap != NULL) {
        DeleteObject(DisplayItem->MemoryBitmap);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vdmperf\vdmperf.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

   Vdmperf.c

Abstract:

   Win32 application to display VDM performance statictics.

Author:

   Mark Lucovsky (stolen from Mark Enstrom  (marke) winperf)

Environment:

   Win32

Revision History:

   11-05-92     Initial version



--*/

//
// set variable to define global variables
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <errno.h>
#include "vdmperf.h"



//
// global handles
//

HANDLE  hInst;


//
// Selected Display Mode (read from wp2.ini), default set here.
//

DISPLAY_ITEM    PerfDataList[SAVE_SUBJECTS];
VDMPERF_INFO    VdmperfInfo;


//
// Window names
//

PUCHAR PerfNames[] = {
    "PUSHF",
    "POPF",
    "IRET",
    "HLT",
    "CLI",
    "STI",
    "BOP",
    "SEG_NOT_P",
    "VDMOPCODEF",
    "INTNN",
    "INTO",
    "INB",
    "INW",
    "OUTB",
    "OUTW",
    "INSB",
    "INSW",
    "OUTSB",
    "OUTSW"
};





int
__cdecl
main(USHORT argc, CHAR **argv)
/*++

Routine Description:

   Windows entry point routine


Arguments:

Return Value:

   status of operation

Revision History:

      03-21-91      Initial code

--*/
{

//
//
//

   HANDLE   hInstance     = MGetInstHandle();
   HANDLE   hPrevInstance = (HANDLE)NULL;
   LPSTR    lpCmdLine     = MGetCmdLine();
   INT      nCmdShow      = SW_SHOWDEFAULT;
   USHORT   _argc         = argc;
   CHAR     **_argv       = argv;
   MSG      msg;
   HBRUSH   BackBrush;


    //
    // check for other instances of this program
    //

    BackBrush = CreateSolidBrush(RGB(192,192,192));

    if (!InitApplication(hInstance,BackBrush)) {
        DbgPrint("Init Application fails\n");
        return (FALSE);
    }


    //
    // Perform initializations that apply to a specific instance
    //

    if (!InitInstance(hInstance, nCmdShow)){
        DbgPrint("Init Instance failed\n");
        return (FALSE);
    }

    //
    // Acquire and dispatch messages until a WM_QUIT message is received.
    //


    while (GetMessage(&msg,        // message structure
            (HWND)NULL,            // handle of window receiving the message
            0,                     // lowest message to examine
            0))                    // highest message to examine
        {
        TranslateMessage(&msg);    // Translates virtual key codes
        DispatchMessage(&msg);     // Dispatches message to window
    }

    DeleteObject(BackBrush);

    return ((INT)msg.wParam);           // Returns the value from PostQuitMessage
}




BOOL
InitApplication(
    HANDLE  hInstance,
    HBRUSH  hBackground)

/*++

Routine Description:

   Initializes window data and registers window class.

Arguments:

   hInstance   - current instance
   hBackground - background fill brush

Return Value:

   status of operation

Revision History:

      02-17-91      Initial code

--*/

{
    WNDCLASS  wc;
    BOOL      ReturnStatus;

    //
    // Fill in window class structure with parameters that describe the
    // main window.
    //

    wc.style         = CS_DBLCLKS;                          // Class style(s).
    wc.lpfnWndProc   = (WNDPROC)MainWndProc;                // Function to retrieve messages for
                                                            // windows of this class.
    wc.cbClsExtra    = 0;                                   // No per-class extra data.
    wc.cbWndExtra    = 0;                                   // No per-window extra data.
    wc.hInstance     = hInstance;                           // Application that owns the class.
    wc.hIcon         = LoadIcon(hInstance,                  //
                            MAKEINTRESOURCE(WINPERF_ICON)); // Load Winperf icon
    wc.hCursor       = LoadCursor((HANDLE)NULL, IDC_ARROW); // Load default cursor
    wc.hbrBackground = hBackground;;                        // Use background passed to routine
    wc.lpszMenuName  = "vdmperfMenu";                       // Name of menu resource in .RC file.
    wc.lpszClassName = "VdmPerfClass";                      // Name used in call to CreateWindow.

    ReturnStatus = RegisterClass(&wc);

    return(ReturnStatus);

}





BOOL
InitInstance(
    HANDLE          hInstance,
    int             nCmdShow
    )

/*++

Routine Description:

   Save instance handle and create main window. This function performs
   initialization tasks that cannot be shared by multiple instances.

Arguments:

    hInstance - Current instance identifier.
    nCmdShow  - Param for first ShowWindow() call.

Return Value:

   status of operation

Revision History:

      02-17-91      Initial code

--*/

{


    DWORD   WindowStyle;

    //
    // Save the instance handle in a static variable, which will be used in
    // many subsequent calls from this application to Windows.
    //

    hInst = hInstance;

    //
    // init the window position and size to be in the upper corner of
    // the screen, 200x100
    //


    //
    //  What I want here is a way to get the WINDOW dimensions
    //

    VdmperfInfo.WindowPositionX = 640 - 200;
    VdmperfInfo.WindowPositionY = 0;
    VdmperfInfo.WindowSizeX     = 200;
    VdmperfInfo.WindowSizeY     = 100;

    //
    //  read profile data from .ini file
    //

    InitProfileData(&VdmperfInfo);

    VdmperfInfo.hMenu = LoadMenu(hInstance,"vdmperfMenu");

    //
    // Create a main window for this application instance.
    //

    VdmperfInfo.hWndMain = CreateWindow(
        "VdmPerfClass",                 // See RegisterClass() call.
        "VDM Perf",                   // Text for window title bar.
        WS_OVERLAPPEDWINDOW,            // window style
        VdmperfInfo.WindowPositionX,   // Default horizontal position.
        VdmperfInfo.WindowPositionY,   // Default vertical position.
        VdmperfInfo.WindowSizeX,       // Default width.
        VdmperfInfo.WindowSizeY,       // Default height.
        (HWND)NULL,                     // Overlapped windows have no parent.
        (HMENU)NULL,                    // Use the window class menu.
        hInstance,                      // This instance owns this window.
        (LPVOID)NULL                    // Pointer not needed.
    );

    //
    // Decide on whether or not to display the menu and caption
    // based on the window class read from the .ini file
    //

    if (VdmperfInfo.DisplayMode==STYLE_ENABLE_MENU) {
        VdmperfInfo.DisplayMenu = TRUE;
    } else {
        VdmperfInfo.DisplayMenu = FALSE;
        WindowStyle = GetWindowLong(VdmperfInfo.hWndMain,GWL_STYLE);
        WindowStyle = (WindowStyle &  (~STYLE_ENABLE_MENU)) | STYLE_DISABLE_MENU;
        SetWindowPos(VdmperfInfo.hWndMain, (HWND)NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_DRAWFRAME);
        SetWindowLong(VdmperfInfo.hWndMain,GWL_STYLE,WindowStyle);
        SetMenu(VdmperfInfo.hWndMain,NULL);
    }

    //
    // If window could not be created, return "failure"
    //

    if (!VdmperfInfo.hWndMain) {
      return (FALSE);
    }

    //
    // Make the window visible; update its client area; and return "success"
    //

    SetFocus(VdmperfInfo.hWndMain);
    ShowWindow(VdmperfInfo.hWndMain, SW_SHOWNORMAL);
    UpdateWindow(VdmperfInfo.hWndMain);

    return (TRUE);

}



LRESULT
APIENTRY
MainWndProc(
   HWND   hWnd,
   UINT   message,
   WPARAM wParam,
   LPARAM lParam
   )

/*++

Routine Description:

   Process messages.

Arguments:

   hWnd    - window hande
   message - type of message
   wParam  - additional information
   lParam  - additional information

Return Value:

   status of operation


Revision History:

      02-17-91      Initial code

--*/

{
    PAINTSTRUCT   ps;

    //
    //   process each message
    //

    switch (message) {

        //
        // create window
        //

        case WM_CREATE:
        {
            HDC hDC = GetDC(hWnd);
            BOOLEAN   Fit;
            UINT      Index;


            //
            // make brushes and pens
            //

            VdmperfInfo.hBluePen     = CreatePen(PS_SOLID,1,RGB(0,0,128));
            VdmperfInfo.hRedPen      = CreatePen(PS_SOLID,1,RGB(255,0,0));
            VdmperfInfo.hGreenPen    = CreatePen(PS_SOLID,1,RGB(0,255,0));
            VdmperfInfo.hDotPen      = CreatePen(PS_DOT,1,RGB(0,0,0));

            VdmperfInfo.hBackground  = CreateSolidBrush(RGB(192,192,192));
            VdmperfInfo.hLightBrush  = CreateSolidBrush(RGB(255,255,255));
            VdmperfInfo.hDarkBrush   = CreateSolidBrush(RGB(128,128,128));
            VdmperfInfo.hRedBrush    = CreateSolidBrush(RGB(255,000,000));
            VdmperfInfo.hGreenBrush  = CreateSolidBrush(RGB(000,255,000));
            VdmperfInfo.hBlueBrush   = CreateSolidBrush(RGB(000,000,255));

            //
            //  create thee fonts using NT default font families
            //

            VdmperfInfo.SmallFont      = CreateFont(8,
                                 0,
                                 0,
                                 0,
                                 400,
                                 FALSE,
                                 FALSE,
                                 FALSE,
                                 ANSI_CHARSET,
                                 OUT_DEFAULT_PRECIS,
                                 CLIP_DEFAULT_PRECIS,
                                 DRAFT_QUALITY,
                                 DEFAULT_PITCH,
                                 "Small Fonts");

            VdmperfInfo.MediumFont      = CreateFont(10,
                                 0,
                                 0,
                                 0,
                                 400,
                                 FALSE,
                                 FALSE,
                                 FALSE,
                                 ANSI_CHARSET,
                                 OUT_DEFAULT_PRECIS,
                                 CLIP_DEFAULT_PRECIS,
                                 DRAFT_QUALITY,
                                 DEFAULT_PITCH,
                                 "Times New Roman");

            VdmperfInfo.LargeFont      = CreateFont(14,
                                 0,
                                 0,
                                 0,
                                 400,
                                 FALSE,
                                 FALSE,
                                 FALSE,
                                 ANSI_CHARSET,
                                 OUT_DEFAULT_PRECIS,
                                 CLIP_DEFAULT_PRECIS,
                                 DRAFT_QUALITY,
                                 DEFAULT_PITCH,
                                 "Times New Roman");


            //
            // create a system timer event to call performance gathering routines by.
            //

            VdmperfInfo.TimerId = SetTimer(hWnd,(UINT)TIMER_ID,(UINT)1000 * DELAY_SECONDS,(TIMERPROC)NULL);

            //
            // init display variables
            //

            InitPerfWindowDisplay(hWnd,hDC,PerfDataList,SAVE_SUBJECTS);

            //
            //  Fit the perf windows into the main window
            //

            Fit = FitPerfWindows(hWnd,hDC,PerfDataList,SAVE_SUBJECTS);

            if (!Fit) {
                DbgPrint("FitPerfWindows Fails         !\n");
            }

            for (Index=0;Index<SAVE_SUBJECTS;Index++) {
                CalcDrawFrame(&PerfDataList[Index]);


                if (!CreateMemoryContext(hDC,&PerfDataList[Index])) {
                    MessageBox(hWnd,"Error Allocating Memory","Vdmperf",MB_OK);
                    DestroyWindow(hWnd);
                    break;
                }

            }

            //
            // init performance routines
            //

            InitPerfInfo();

            //
            // release the DC handle
            //

            ReleaseDC(hWnd,hDC);

      }
      break;

      //
      // re-size
      //

      case WM_SIZE:

      {
            int     i;
            HDC     hDC = GetDC(hWnd);
            RECT    ClientRect;
            BOOLEAN Fit;

            //
            // get size of cleint area
            //

            GetWindowRect(hWnd,&ClientRect);

            VdmperfInfo.WindowPositionX = ClientRect.left;
            VdmperfInfo.WindowPositionY = ClientRect.top;
            VdmperfInfo.WindowSizeX     = ClientRect.right  - ClientRect.left;
            VdmperfInfo.WindowSizeY     = ClientRect.bottom - ClientRect.top;

            Fit = FitPerfWindows(hWnd,hDC,PerfDataList,SAVE_SUBJECTS);

            if (!Fit) {
                DbgPrint("WM_SIZE error, FitPerf returns FALSE\n");
            }

            for (i=0;i<SAVE_SUBJECTS;i++) {
                DeleteMemoryContext(&PerfDataList[i]);
                CalcDrawFrame(&PerfDataList[i]);

                if (!CreateMemoryContext(hDC,&PerfDataList[i])) {
                    MessageBox(hWnd,"Error Allocating Memory","Vdmperf",MB_OK);
                    DestroyWindow(hWnd);
                    break;
                }
            }

            //
            // force window to be re-painted
            //

            InvalidateRect(hWnd,(LPRECT)NULL,TRUE);

            //
            // release the DC handle
            //

            ReleaseDC(hWnd,hDC);


      }
      break;

      case WM_MOVE:
      {
            HDC     hDC = GetDC(hWnd);
            RECT    ClientRect;

            //
            // get size of cleint area
            //

            GetWindowRect(hWnd,&ClientRect);

            VdmperfInfo.WindowPositionX = ClientRect.left;
            VdmperfInfo.WindowPositionY = ClientRect.top;
            VdmperfInfo.WindowSizeX     = ClientRect.right  - ClientRect.left;
            VdmperfInfo.WindowSizeY     = ClientRect.bottom - ClientRect.top;

            ReleaseDC(hWnd,hDC);
      }

      break;


      //
      // command from application menu
      //

      case WM_COMMAND:


            switch (wParam){

               //
               // exit window
               //

               case IDM_EXIT:

                  DestroyWindow(hWnd);
                  break;

               //
               // about command
               //

            case IDM_SELECT:
            {
                HDC     hDC = GetDC(hWnd);
                int     Index;
                BOOLEAN fit;

                if (DialogBox(hInst,MAKEINTRESOURCE(IDM_SEL_DLG),hWnd,SelectDlgProc) == DIALOG_SUCCESS) {

                    fit = FitPerfWindows(hWnd,hDC,PerfDataList,SAVE_SUBJECTS);

                    if (!fit) {
                        DbgPrint("Fit Fails\n");
                    }

                    for (Index=0;Index<SAVE_SUBJECTS;Index++) {
                        DeleteMemoryContext(&PerfDataList[Index]);
                        CalcDrawFrame(&PerfDataList[Index]);

                        if (!CreateMemoryContext(hDC,&PerfDataList[Index])) {
                            MessageBox(hWnd,"Error Allocating Memory","Vdmperf",MB_OK);
                            DestroyWindow(hWnd);
                            break;
                        }


                    }
                    InvalidateRect(hWnd,(LPRECT)NULL,TRUE);
                }

                ReleaseDC(hWnd,hDC);

            }
            break;


            default:

                return (DefWindowProc(hWnd, message, wParam, lParam));
            }

            break;

        case WM_PAINT:

            //
            // repaint the window
            //

            {
                int i;
                HDC hDC = BeginPaint(hWnd,&ps);

                SelectObject(hDC,GetStockObject(NULL_BRUSH));

                for (i=0;i<SAVE_SUBJECTS;i++) {

                    if (PerfDataList[i].Display == TRUE) {

                        DrawFrame(hDC,&PerfDataList[i]);

                        DrawPerfText(hDC,&PerfDataList[i],i);
                        DrawPerfGraph(hDC,&PerfDataList[i]);

                    }
                }

                EndPaint(hWnd,&ps);
            }
            break;


        case WM_TIMER:
        {
            int i;
            HDC hDC = GetDC(hWnd);

            CalcCpuTime(PerfDataList);

            //
            // update all performance information
            //


            for (i=0;i<SAVE_SUBJECTS;i++) {

                if (PerfDataList[i].Display == TRUE) {

                    DrawPerfText(hDC,&PerfDataList[i],i);

                    if (PerfDataList[i].ChangeScale) {
                        DrawPerfGraph(hDC,&PerfDataList[i]);
                    } else {
                        ShiftPerfGraph(hDC,&PerfDataList[i]);
                    }

                }
            }

            ReleaseDC(hWnd,hDC);

        }
        break;

        //
        // handle a double click
        //

        case WM_NCLBUTTONDBLCLK:
        case WM_LBUTTONDBLCLK:
        {
            DWORD   WindowStyle;


            //
            // get old window style, take out caption and menu
            //

            if (!IsIconic(hWnd)) {

                if (VdmperfInfo.DisplayMenu) {
                    WindowStyle = GetWindowLong(hWnd,GWL_STYLE);
                    WindowStyle = (WindowStyle &  (~STYLE_ENABLE_MENU)) | STYLE_DISABLE_MENU;
                    SetMenu(hWnd,NULL);
                    SetWindowLong(hWnd,GWL_STYLE,WindowStyle);
                    SetWindowPos(hWnd, (HWND)NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_DRAWFRAME);
                    ShowWindow(hWnd,SW_SHOW);
                    VdmperfInfo.DisplayMode=STYLE_DISABLE_MENU;
                    VdmperfInfo.DisplayMenu = FALSE;

                } else {
                    WindowStyle = GetWindowLong(hWnd,GWL_STYLE);
                    WindowStyle = (WindowStyle & (~STYLE_DISABLE_MENU)) | STYLE_ENABLE_MENU;
                    SetMenu(hWnd,VdmperfInfo.hMenu);
                    SetWindowLong(hWnd,GWL_STYLE,WindowStyle);
                    SetWindowPos(hWnd, (HWND)NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_DRAWFRAME);
                    ShowWindow(hWnd,SW_SHOW);
                    VdmperfInfo.DisplayMode=STYLE_ENABLE_MENU;
                    VdmperfInfo.DisplayMenu = TRUE;
                }
            } else {
                DefWindowProc(hWnd, message, wParam, lParam);
            }

        }
        break;

        //
        //  enable dragging with mouse in non-client
        //

        case WM_NCHITTEST:
        {

            lParam = DefWindowProc(hWnd, message, wParam, lParam);
            if ((VdmperfInfo.DisplayMenu==FALSE) && (lParam == HTCLIENT)) {
                return(HTCAPTION);
            } else {
                return(lParam);
            }


        }
        break;

        case WM_DESTROY:
        {
            UINT    Index;

            //
            // Save profile info
            //

            SaveProfileData(&VdmperfInfo);

            //
            // Delete Windows Objects
            //

            KillTimer(hWnd,TIMER_ID);

            DeleteObject(VdmperfInfo.hBluePen);
            DeleteObject(VdmperfInfo.hRedPen);
            DeleteObject(VdmperfInfo.hGreenPen);
            DeleteObject(VdmperfInfo.hBackground);
            DeleteObject(VdmperfInfo.hLightBrush);
            DeleteObject(VdmperfInfo.hDarkBrush);

            for (Index=0;Index<SAVE_SUBJECTS;Index++ ) {
                DeleteMemoryContext(&PerfDataList[Index]);
            }

            //
            // Destroy window
            //

            PostQuitMessage(0);
         }
         break;


        default:

            //
            // Passes message on if unproccessed
            //

            return (DefWindowProc(hWnd, message, wParam, lParam));
    }
    return (0);
}



INT_PTR
APIENTRY SelectDlgProc(
   HWND hDlg,
   unsigned message,
   WPARAM wParam,
   LPARAM lParam
   )

/*++

Routine Description:

   Process message for select dialog box.

Arguments:

   hDlg    - window handle of the dialog box
   message - type of message
   wParam  - message-specific information
   lParam  - message-specific information

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    UINT    ButtonState;
    UINT    Index;

    switch (message) {

    case WM_INITDIALOG:

        //
        // Init Buttons with PerfDataList Structure
        //

        for (Index=0;Index<SAVE_SUBJECTS;Index++) {
            int Idm;
            switch ( Index ) {
                case IX_PUSHF       : Idm = IDM_PUSHF     ; break;
                case IX_POPF        : Idm = IDM_POPF      ; break;
                case IX_IRET        : Idm = IDM_IRET      ; break;
                case IX_HLT         : Idm = IDM_HLT       ; break;
                case IX_CLI         : Idm = IDM_CLI       ; break;
                case IX_STI         : Idm = IDM_STI       ; break;
                case IX_BOP         : Idm = IDM_BOP       ; break;
                case IX_SEGNOTP     : Idm = IDM_SEGNOTP   ; break;
                case IX_VDMOPCODEF  : Idm = IDM_VDMOPCODEF; break;
                case IX_INTNN       : Idm = IDM_INTNN     ; break;
                case IX_INTO        : Idm = IDM_INTO      ; break;
                case IX_INB         : Idm = IDM_INB       ; break;
                case IX_INW         : Idm = IDM_INW       ; break;
                case IX_OUTB        : Idm = IDM_OUTB      ; break;
                case IX_OUTW        : Idm = IDM_OUTW      ; break;
                case IX_INSB        : Idm = IDM_INSB      ; break;
                case IX_INSW        : Idm = IDM_INSW      ; break;
                case IX_OUTSB       : Idm = IDM_OUTSB     ; break;
                case IX_OUTSW       : Idm = IDM_OUTSW     ; break;
                }

            //
            // Set or clear radio button based on display variable
            //

            if (PerfDataList[Index].Display == TRUE) {
                CheckDlgButton(hDlg,Idm,1);
            } else {
                CheckDlgButton(hDlg,Idm,0);
            }

        }

        return (TRUE);

    case WM_COMMAND:

           switch(wParam) {

               //
               // end function
               //

           case IDOK:

                //DbgPrint("IDOK: Check button states\n");

                for (Index=0;Index<SAVE_SUBJECTS;Index++) {
                    int Idm;
                    switch ( Index ) {
                        case IX_PUSHF       : Idm = IDM_PUSHF     ; break;
                        case IX_POPF        : Idm = IDM_POPF      ; break;
                        case IX_IRET        : Idm = IDM_IRET      ; break;
                        case IX_HLT         : Idm = IDM_HLT       ; break;
                        case IX_CLI         : Idm = IDM_CLI       ; break;
                        case IX_STI         : Idm = IDM_STI       ; break;
                        case IX_BOP         : Idm = IDM_BOP       ; break;
                        case IX_SEGNOTP     : Idm = IDM_SEGNOTP   ; break;
                        case IX_VDMOPCODEF  : Idm = IDM_VDMOPCODEF; break;
                        case IX_INTNN       : Idm = IDM_INTNN     ; break;
                        case IX_INTO        : Idm = IDM_INTO      ; break;
                        case IX_INB         : Idm = IDM_INB       ; break;
                        case IX_INW         : Idm = IDM_INW       ; break;
                        case IX_OUTB        : Idm = IDM_OUTB      ; break;
                        case IX_OUTW        : Idm = IDM_OUTW      ; break;
                        case IX_INSB        : Idm = IDM_INSB      ; break;
                        case IX_INSW        : Idm = IDM_INSW      ; break;
                        case IX_OUTSB       : Idm = IDM_OUTSB     ; break;
                        case IX_OUTSW       : Idm = IDM_OUTSW     ; break;
                        }
                   ButtonState = IsDlgButtonChecked(hDlg,Idm);
                   if (ButtonState == 1) {
                       PerfDataList[Index].Display = TRUE;
                       VdmperfInfo.DisplayElement[Index] = 1;
                   } else {
                       PerfDataList[Index].Display = FALSE;
                       VdmperfInfo.DisplayElement[Index] = 0;
                   }

                }


                EndDialog(hDlg, DIALOG_SUCCESS);
                return (TRUE);

           case IDCANCEL:

                EndDialog(hDlg, DIALOG_CANCEL );
                return (TRUE);


            case IDM_PUSHF     :
            case IDM_POPF      :
            case IDM_IRET      :
            case IDM_HLT       :
            case IDM_CLI       :
            case IDM_STI       :
            case IDM_SEGNOTP   :
            case IDM_BOP       :
            case IDM_VDMOPCODEF:
            case IDM_INTNN     :
            case IDM_INTO      :
            case IDM_INB       :
            case IDM_INW       :
            case IDM_OUTB      :
            case IDM_OUTW      :
            case IDM_INSB      :
            case IDM_INSW      :
            case IDM_OUTSB     :
            case IDM_OUTSW     :

                   //
                   // Turn on or off button
                   //

                   ButtonState = IsDlgButtonChecked(hDlg,(UINT)wParam);

                   //DbgPrint("ButtonState = %i\n",ButtonState);

                   if (ButtonState == 0) {

                       //
                       // Set Button
                       //

                       ButtonState = 1;

                   }  else if (ButtonState == 1) {

                       //
                       // Clear Button
                       //

                       ButtonState = 0;

                   } else {

                       ButtonState = 0;
                   }

                   CheckDlgButton(hDlg,(UINT)wParam,ButtonState);
                   return(TRUE);
        }

    }
    return (FALSE);
}




VOID
InitProfileData(PVDMPERF_INFO pVdmperfInfo)

/*++

Routine Description:

    Attempt tp read the following fields from the vdmperf.ini file

Arguments:

    WindowPositionX - Window initial x position
    WindowPositionY - Window initial y position
    WindowSizeX     - Window initial width
    WindowSizey     - Window Initial height
    DisplayMode     - Window initial display mode

Return Value:


    None, values are set to default before a call to this operation. If there is a problem then
    default:values are left unchanged.

Revision History:

      02-17-91      Initial code

--*/

{
    DWORD   PositionX,PositionY,SizeX,SizeY,Mode,Index,Element[SAVE_SUBJECTS];
    UCHAR   TempStr[256];

    PositionX = GetPrivateProfileInt("vdmperf","PositionX"  ,pVdmperfInfo->WindowPositionX,"vdmperf.ini");
    PositionY = GetPrivateProfileInt("vdmperf","PositionY"  ,pVdmperfInfo->WindowPositionY,"vdmperf.ini");
    SizeX     = GetPrivateProfileInt("vdmperf","SizeX"      ,pVdmperfInfo->WindowSizeX    ,"vdmperf.ini");
    SizeY     = GetPrivateProfileInt("vdmperf","SizeY"      ,pVdmperfInfo->WindowSizeY    ,"vdmperf.ini");

    //
    // read the first deiplay element with default 1
    //

    Element[0] = GetPrivateProfileInt("vdmperf","DisplayElement0",1,"vdmperf.ini");

    //
    // read the rest of the display elements with default 0
    //

    for (Index=1;Index<SAVE_SUBJECTS;Index++) {
        wsprintf(TempStr,"DisplayElement%i",Index);
        Element[Index] = GetPrivateProfileInt("vdmperf",TempStr,0,"vdmperf.ini");
    }

    Mode      = GetPrivateProfileInt("vdmperf","DisplayMode",pVdmperfInfo->DisplayMode    ,"vdmperf.ini");

    pVdmperfInfo->WindowPositionX = PositionX;
    pVdmperfInfo->WindowPositionY = PositionY;
    pVdmperfInfo->WindowSizeX     = SizeX;
    pVdmperfInfo->WindowSizeY     = SizeY;

    for (Index=0;Index<SAVE_SUBJECTS;Index++) {
        pVdmperfInfo->DisplayElement[Index] = Element[Index];
    }
    pVdmperfInfo->DisplayMode     = Mode;
}




VOID
SaveProfileData(PVDMPERF_INFO pVdmperfInfo)

/*++

Routine Description:

    Save profile data

Arguments:

    WindowPositionX - Window initial x position
    WindowPositionY - Window initial y position
    WindowSizeX     - Window initial width
    WindowSizey     - Window Initial height
    DisplayMode     - Window initial display mode

Return Value:


    None.

Revision History:

      02-17-91      Initial code

--*/

{
    UCHAR    TempStr[50],TempName[50];
    UINT     Index;

    wsprintf(TempStr,"%i",pVdmperfInfo->WindowPositionX);
    WritePrivateProfileString("vdmperf","PositionX",TempStr,"vdmperf.ini");

    wsprintf(TempStr,"%i",pVdmperfInfo->WindowPositionY);
    WritePrivateProfileString("vdmperf","PositionY",TempStr,"vdmperf.ini");

    wsprintf(TempStr,"%i",pVdmperfInfo->WindowSizeX);
    WritePrivateProfileString("vdmperf","SizeX",TempStr,"vdmperf.ini");

    wsprintf(TempStr,"%i",pVdmperfInfo->WindowSizeY);
    WritePrivateProfileString("vdmperf","SizeY",TempStr,"vdmperf.ini");

    for (Index=0;Index<SAVE_SUBJECTS;Index++) {
        wsprintf(TempStr,"%li",pVdmperfInfo->DisplayElement[Index]);
        wsprintf(TempName,"DisplayElement%li",Index);
        WritePrivateProfileString("vdmperf",TempName,TempStr,"vdmperf.ini");

    }


    wsprintf(TempStr,"%li",pVdmperfInfo->DisplayMode);
    WritePrivateProfileString("vdmperf","DisplayMode",TempStr,"vdmperf.ini");

}









BOOLEAN
InitPerfWindowDisplay(
    IN  HWND            hWnd,
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItems,
    IN  ULONG           NumberOfWindows
    )

/*++

Routine Description:

    Init All perf windows to active, init data

Arguments:

    hDC             -   Screen context
    DisplayItems    -   List of display structures
    NumberOfWindows -   Number of sub-windows

Return Value:

    Status

Revision History:

      02-17-91      Initial code

--*/
{
    int     Index1;
    UINT    Index;

    for (Index=0;Index<NumberOfWindows;Index++) {

        if (VdmperfInfo.DisplayElement[Index] == 0) {
            DisplayItems[Index].Display = FALSE;
        } else {
            DisplayItems[Index].Display = TRUE;
        }

        DisplayItems[Index].CurrentDrawingPos = 0;

        DisplayItems[Index].NumberOfElements = 1;

        for (Index1=0;Index1<DATA_LIST_LENGTH;Index1++) {
            DisplayItems[Index].KernelTime[Index1] = 0;
            DisplayItems[Index].UserTime[Index1] = 0;
            DisplayItems[Index].TotalTime[Index1] = 0;
        }
    }

    return(TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\csetpage.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: CSetPage.cpp
// author: DMihai
// created: 11/1/00
//
// Description:
//

#include "stdafx.h"
#include "verifier.h"

#include "CSetPage.h"
#include "VrfUtil.h"
#include "VGlobal.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Change this if you add/remove/change order 
// of radio buttons on this page
//

#define FIRST_RADIO_BUTTON_ID   IDC_CUSTSETT_PREDEF_RADIO

//
// Help IDs
//

static DWORD MyHelpIds[] =
{
    IDC_CUSTSETT_PREDEF_RADIO,      IDH_DV_EnablePredefined,
    IDC_CUSTSETT_FULLLIST_RADIO,    IDH_DV_IndividualSettings,
    IDC_CUSTSETT_TYPICAL_CHECK,     IDH_DV_Standard,
    IDC_CUSTSETT_EXCESS_CHECK,      IDH_DV_Rigorous,
    IDC_CUSTSETT_LOWRES_CHECK,      IDH_DV_LowResource,
    0,                              0
};

/////////////////////////////////////////////////////////////////////////////
// CCustSettPage property page

IMPLEMENT_DYNCREATE(CCustSettPage, CVerifierPropertyPage)

CCustSettPage::CCustSettPage() 
    : CVerifierPropertyPage( CCustSettPage::IDD )
{
    //{{AFX_DATA_INIT(CCustSettPage)
	m_bTypicalTests = FALSE;
	m_bExcessiveTests = FALSE;
	m_bLowResTests = FALSE;
	m_nCrtRadio = -1;
	//}}AFX_DATA_INIT
}

CCustSettPage::~CCustSettPage()
{
}

void CCustSettPage::DoDataExchange(CDataExchange* pDX)
{
    CVerifierPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CCustSettPage)
    DDX_Control(pDX, IDC_CUSTSETT_NEXT_DESCR_STATIC, m_NextDescription);
    DDX_Control(pDX, IDC_CUSTSETT_TYPICAL_CHECK, m_TypicalTestsCheck);
    DDX_Control(pDX, IDC_CUSTSETT_LOWRES_CHECK, m_LowresTestsCheck);
    DDX_Control(pDX, IDC_CUSTSETT_EXCESS_CHECK, m_ExcessTestsCheck);
    DDX_Check(pDX, IDC_CUSTSETT_TYPICAL_CHECK, m_bTypicalTests);
    DDX_Check(pDX, IDC_CUSTSETT_EXCESS_CHECK, m_bExcessiveTests);
    DDX_Check(pDX, IDC_CUSTSETT_LOWRES_CHECK, m_bLowResTests);
    DDX_Radio(pDX, IDC_CUSTSETT_PREDEF_RADIO, m_nCrtRadio);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCustSettPage, CVerifierPropertyPage)
    //{{AFX_MSG_MAP(CCustSettPage)
    ON_BN_CLICKED(IDC_CUSTSETT_FULLLIST_RADIO, OnFulllistRadio)
    ON_BN_CLICKED(IDC_CUSTSETT_PREDEF_RADIO, OnPredefRadio)
    ON_WM_CONTEXTMENU()
    ON_MESSAGE( WM_HELP, OnHelp )
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
VOID CCustSettPage::EnablePredefCheckboxes( BOOL bEnable )
{
    m_TypicalTestsCheck.EnableWindow( bEnable );
    m_LowresTestsCheck.EnableWindow( bEnable );
    m_ExcessTestsCheck.EnableWindow( bEnable );
}

/////////////////////////////////////////////////////////////////////////////
// CCustSettPage message handlers


/////////////////////////////////////////////////////////////////////////////
LRESULT CCustSettPage::OnWizardNext() 
{
    LRESULT lNextPageId;

    //
    // Let's assume we cannot continue
    //

    lNextPageId = -1;

    if( UpdateData() == TRUE )
    {
        if( IDC_CUSTSETT_PREDEF_RADIO - FIRST_RADIO_BUTTON_ID == m_nCrtRadio )
        {
            //
            // Use predefined settings
            //

            if( FALSE == m_bTypicalTests     &&
                FALSE == m_bExcessiveTests   && 
                FALSE == m_bLowResTests )
            {
                //
                // No tests are currently selected - we cannot continue
                //

                VrfErrorResourceFormat( IDS_NO_TESTS_SELECTED );
            }
            else
            {
                //
                // Set our data according to the GUI
                //

                //
                // Use predefined settings
                //

                g_NewVerifierSettings.m_SettingsBits.EnableTypicalTests( m_bTypicalTests );
    
                g_NewVerifierSettings.m_SettingsBits.EnableExcessiveTests( m_bExcessiveTests );

                g_NewVerifierSettings.m_SettingsBits.EnableLowResTests( m_bLowResTests );

                //
                // Go to the next page
                //

                lNextPageId = IDD_DRVSET_PAGE;
            }
        }
        else
        {
            //
            // Select the tests to be performed from a full list
            //

            lNextPageId = IDD_FULL_LIST_SETT_PAGE;
        }
    }

    if( -1 != lNextPageId )
    {
        //
        // Have some valid custom settings and we are going to the next page
        //

        g_NewVerifierSettings.m_SettingsBits.m_SettingsType = CSettingsBits::SettingsTypeCustom;
    }

    GoingToNextPageNotify( lNextPageId );
    
	return lNextPageId;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CCustSettPage::OnInitDialog() 
{
    //
    // Don't try to reconstruct the current data from the registry
    // to the GUI because it's too hard. Always start with standard tests.
    //

    m_nCrtRadio = IDC_CUSTSETT_PREDEF_RADIO - FIRST_RADIO_BUTTON_ID;

    m_bTypicalTests     = TRUE;
    m_bExcessiveTests   = FALSE;
    m_bLowResTests      = FALSE;

	CVerifierPropertyPage::OnInitDialog();

    VrfSetWindowText( m_NextDescription, IDS_TAS_PAGE_NEXT_DESCR_PREDEFINED );
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////////////
void CCustSettPage::OnFulllistRadio() 
{
    EnablePredefCheckboxes( FALSE );

    VrfSetWindowText( m_NextDescription, IDS_TAS_PAGE_NEXT_DESCR_LIST );
}

/////////////////////////////////////////////////////////////////////////////
void CCustSettPage::OnPredefRadio() 
{
    EnablePredefCheckboxes( TRUE );

    VrfSetWindowText( m_NextDescription, IDS_TAS_PAGE_NEXT_DESCR_PREDEFINED );
}

/////////////////////////////////////////////////////////////
BOOL CCustSettPage::OnSetActive() 
{
    m_pParentSheet->SetWizardButtons( PSWIZB_NEXT |
                                      PSWIZB_BACK );
	
	return CVerifierPropertyPage::OnSetActive();
}
/////////////////////////////////////////////////////////////
LONG CCustSettPage::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp( 
        (HWND) lpHelpInfo->hItemHandle,
        g_szVerifierHelpFile,
        HELP_WM_HELP,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}

/////////////////////////////////////////////////////////////////////////////
void CCustSettPage::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    ::WinHelp( 
        pWnd->m_hWnd,
        g_szVerifierHelpFile,
        HELP_CONTEXTMENU,
        (DWORD_PTR) MyHelpIds );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\cmdline.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: CmdLine.h
// author: DMihai
// created: 11/1/00
//
// Description:
//  

#ifndef __CMD_LINE_H_INCLUDED__
#define __CMD_LINE_H_INCLUDED__

/////////////////////////////////////////////////////////////////////////////
//
// Execute command line
//

DWORD CmdLineExecute( INT argc, 
                      TCHAR *argv[] );

/////////////////////////////////////////////////////////////////////////////
//
// See if the user asked for help and print out the help strings
// 

BOOL CmdLineExecuteIfHelp( INT argc, 
                           TCHAR *argv[] );

/////////////////////////////////////////////////////////////////////////////
//
// Print out help information
//

VOID CmdLinePrintHelpInformation();

/////////////////////////////////////////////////////////////////////////////
//
// See if the user asked to reset all the existing verifier settings
// 

BOOL CmdLineFindResetSwitch( INT argc,
                             TCHAR *argv[] );


/////////////////////////////////////////////////////////////////////////////
//
// See if we need to start logging statistics
//

BOOL CmdLineExecuteIfLog( INT argc,
                          TCHAR *argv[] );

/////////////////////////////////////////////////////////////////////////////
//
// See if we need to start logging statistics
//

BOOL CmdLineExecuteIfQuery( INT argc,
                            TCHAR *argv[] );


/////////////////////////////////////////////////////////////////////////////
//
// See if we need to dump the statistics to the console
//

BOOL CmdLineExecuteIfQuerySettings( INT argc,
                                    TCHAR *argv[] );

/////////////////////////////////////////////////////////////////////////////
//
// Get the new flags, drivers and volatile 
// if they have been specified
//

VOID CmdLineGetFlagsDriversVolatile( INT argc,
                                     TCHAR *argv[],
                                     DWORD &dwNewFlags,
                                     BOOL &bHaveNewFlags,
                                     CStringArray &astrNewDrivers,
                                     BOOL &bHaveNewDrivers,
                                     BOOL &bHaveVolatile,
                                     BOOL &bVolatileAddDriver );    // TRUE if /adddriver, FALSE if /removedriver

/////////////////////////////////////////////////////////////////////////////
//
// Everything that follows after /driver, /adddriver, /removedriver
// should be driver names. Extract these from the command line
//

VOID CmdLineGetDriversFromArgv(  INT argc,
                                 TCHAR *argv[],
                                 INT nFirstDriverArgIndex,
                                 CStringArray &astrNewDrivers,
                                 BOOL &bHaveNewDrivers );

#endif //#ifndef __CMD_LINE_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\cdlpage.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: CDLPage.h
// author: DMihai
// created: 11/1/00
//
// Description:
//

#if !defined(AFX_CDLPAGE_H__7A756DBE_9A1C_4558_80EA_53E7AC45A6A4__INCLUDED_)
#define AFX_CDLPAGE_H__7A756DBE_9A1C_4558_80EA_53E7AC45A6A4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// CDLPage.h : header file
//

#include "VerfPage.h"

/////////////////////////////////////////////////////////////////////////////
// CConfirmDriverListPage dialog

class CConfirmDriverListPage : public CVerifierPropertyPage
{
	DECLARE_DYNCREATE(CConfirmDriverListPage)

// Construction
public:
	CConfirmDriverListPage();
	~CConfirmDriverListPage();

public:
    //
    // Methods
    //

    VOID SetParentSheet( CPropertySheet *pParentSheet )
    {
        m_pParentSheet = pParentSheet;
        ASSERT( m_pParentSheet != NULL );
    }

    BOOL SetContextStrings( ULONG uTitleResId );

    VOID SortTheList();
    BOOL GetColumnStrValue( LPARAM lItemData, 
                            CString &strName );

    static int CALLBACK StringCmpFunc( LPARAM lParam1,
                                       LPARAM lParam2,
                                       LPARAM lParamSort);

protected:
    VOID SetupListHeader();
    VOID FillTheList();

    VOID AddListItem( INT_PTR nIndexInArray, CDriverData *pCrtDrvData );

protected:
    //
    // Dialog Data
    //

    CPropertySheet      *m_pParentSheet;

    CString             m_strTitle;

    INT m_nSortColumnIndex;        // driver name (0) or provider name (1)
    BOOL m_bAscendSortDrvName;     // sort ascendent the driver names
    BOOL m_bAscendSortProvName;    // sort ascendent the provider names


	//{{AFX_DATA(CConfirmDriverListPage)
	enum { IDD = IDD_CONFIRM_DRIVERS_PAGE };
	CStatic	m_NextDescription;
	CButton	m_TitleStatic;
	CListCtrl	m_DriversList;
	//}}AFX_DATA

protected:
    //
    // Overrides
    //

    //
    // All the property pages derived from this class should 
    // provide these methods.
    //

    virtual ULONG GetDialogId() const { return IDD; }

    //
    // ClassWizard generate virtual function overrides
    //

    //{{AFX_VIRTUAL(CConfirmDriverListPage)
    public:
    virtual BOOL OnSetActive();
    virtual BOOL OnWizardFinish();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CConfirmDriverListPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnColumnclickConfdrvList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg LONG OnHelp( WPARAM wParam, LPARAM lParam );
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CDLPAGE_H__7A756DBE_9A1C_4558_80EA_53E7AC45A6A4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\csetpage.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: CSetPage.h
// author: DMihai
// created: 11/1/00
//
// Description:
//  

#if !defined(AFX_CSETPAGE_H__4DAAEAE1_F3E9_42D0_B0F5_5FAC8C40A12B__INCLUDED_)
#define AFX_CSETPAGE_H__4DAAEAE1_F3E9_42D0_B0F5_5FAC8C40A12B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// CSetPage.h : header file
//

#include "vsetting.h"
#include "VerfPage.h"

/////////////////////////////////////////////////////////////////////////////
// CCustSettPage dialog

class CCustSettPage : public CVerifierPropertyPage
{
	DECLARE_DYNCREATE(CCustSettPage)

public:
    //
    // Construction
    //

	CCustSettPage();
	~CCustSettPage();

    //
    // Methods
    //

    VOID SetParentSheet( CPropertySheet *pParentSheet )
    {
        m_pParentSheet = pParentSheet;
        ASSERT( m_pParentSheet != NULL );
    }

protected:
    //
    // Methods
    //
    
    VOID EnablePredefCheckboxes( BOOL bEnable );

protected:
    //
    // Data
    //

    CPropertySheet      *m_pParentSheet;

    //
    // Dialog Data
    //

	//{{AFX_DATA(CCustSettPage)
	enum { IDD = IDD_CUSTSETT_PAGE };
	CStatic	m_NextDescription;
	CButton	m_TypicalTestsCheck;
	CButton	m_LowresTestsCheck;
	CButton	m_ExcessTestsCheck;
	BOOL	m_bTypicalTests;
	BOOL	m_bExcessiveTests;
	BOOL	m_bIndividialTests;
	BOOL	m_bLowResTests;
	int		m_nCrtRadio;
	//}}AFX_DATA


    //
    // Overrides
    //

    //
    // All the property pages derived from this class should 
    // provide these methods.
    //

    virtual ULONG GetDialogId() const { return IDD; }

    //
    // ClassWizard generated virtual function overrides
    //

    //{{AFX_VIRTUAL(CCustSettPage)
    public:
    virtual LRESULT OnWizardNext();
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CCustSettPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnFulllistRadio();
    afx_msg void OnPredefRadio();
    afx_msg LONG OnHelp( WPARAM wParam, LPARAM lParam );
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CSETPAGE_H__4DAAEAE1_F3E9_42D0_B0F5_5FAC8C40A12B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vdmperf\vdmperf.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    winperf.h

Abstract:

   This module contains the definit

Author:

    Mark Lucovsky (markl) 28-Mar-1991

Revision History:

--*/

#ifndef _WINPERFH_INCLUDED_
#define _WINPERFH_INCLUDED_

#define DIALOG_SUCCESS  100
#define DIALOG_CANCEL   0

#define IDM_EXIT        1100
#define IDM_SELECT      1101
#define IDM_ALL         1103
#define TIMER_ID        1001
#define IDM_IO_GRP      1002
#define IDM_OP_GRP      1003
#define IDM_SEL_DLG     1004
#define IDM_STYLE_GRP   1005


#define IDM_INSB        101
#define IDM_INSW        102
#define IDM_OUTSB       103
#define IDM_OUTSW       104
#define IDM_INB         105
#define IDM_INW         106
#define IDM_OUTB        107
#define IDM_OUTW        108
#define IDM_VDMOPCODEF  109
#define IDM_PUSHF       110
#define IDM_POPF        111
#define IDM_INTNN       112
#define IDM_INTO        113
#define IDM_IRET        114
#define IDM_HLT         115
#define IDM_CLI         116
#define IDM_STI         117
#define IDM_BOP         118
#define IDM_SEGNOTP     119

#define WINPERF_ICON 1011


#include "calcperf.h"

typedef struct _VDMPERF_INFO
{
    DWORD   WindowPositionX;
    DWORD   WindowPositionY;
    DWORD   WindowSizeX;
    DWORD   WindowSizeY;
    DWORD   DisplayElement[SAVE_SUBJECTS];
    DWORD   DisplayMode;
    HPEN    hBluePen;
    HPEN    hRedPen;
    HPEN    hGreenPen;
    HPEN    hDotPen;
    HBRUSH  hBackground;
    HBRUSH  hRedBrush;
    HBRUSH  hGreenBrush;
    HBRUSH  hBlueBrush;
    HBRUSH  hLightBrush;
    HBRUSH  hDarkBrush;
    HFONT   LargeFont;
    HFONT   MediumFont;
    HFONT   SmallFont;
    HFONT   hOldFont;
    HMENU   hMenu;
    HWND    hWndMain;
    UINT_PTR TimerId;
    BOOL    DisplayMenu;
} VDMPERF_INFO,*PVDMPERF_INFO;

BOOL
InitApplication(
   HANDLE hInstance,
   HBRUSH hBackground
   );

BOOL
InitInstance(
    HANDLE          hInstance,
    int             nCmdShow
    );

LRESULT APIENTRY
MainWndProc(
   HWND  hWnd,
   UINT  message,
   WPARAM DWORD,
   LPARAM lParam
   );



INT_PTR APIENTRY
CpuWndProc(
   HWND  hWnd,
   UINT  message,
   WPARAM DWORD,
   LPARAM lParam
   );


INT_PTR
APIENTRY About(
   HWND     hDlg,
   unsigned message,
   WPARAM   DWORD,
   LPARAM   lParam
   );

#include <port1632.h>


VOID
UpdateCpuMeter(
   IN   HDC    hDC,
   IN   SHORT  cxClient,
   IN   SHORT  cyClient
   );

VOID
DrawCpuMeter(
   IN   HDC    hDC,
   IN   SHORT  cxClient,
   IN   SHORT  cyClient,
   IN   ULONG DisplayItem
   );

VOID
ReScalePerfWindow(
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItem
    );

BOOL
CalcCpuTime(
   PDISPLAY_ITEM    PerfListItem
   );

ULONG
InitPerfInfo(VOID);


VOID
InitProfileData(PVDMPERF_INFO pVdmperfInfo);

VOID
SaveProfileData(PVDMPERF_INFO pVdmperfInfo);

VOID
DrawPerfWindow(
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItem
    );


VOID
UpdatePerfWindow(
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItem
    );

//
//  change style constants
//

#define STYLE_ENABLE_MENU  WS_OVERLAPPEDWINDOW
#define STYLE_DISABLE_MENU (WS_THICKFRAME+WS_BORDER)


LONG APIENTRY
DbgWndProc(
   HWND   hWnd,
   UINT   message,
   DWORD  wParam,
   LONG   lParam
   );



BOOLEAN
FitPerfWindows(
    IN  HWND            hWnd,
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItems,
    IN  ULONG           NumberOfWindows
    );


BOOLEAN
InitPerfWindowDisplay(
    IN  HWND            hWnd,
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItems,
    IN  ULONG           NumberOfWindows
    );



INT_PTR
APIENTRY SelectDlgProc(
   HWND hDlg,
   unsigned message,
   WPARAM wParam,
   LPARAM lParam
   );

VOID
DrawFrame(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    );

VOID
CalcDrawFrame(
    PDISPLAY_ITEM   DisplayItem
    );

VOID
DrawPerfText(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem,
    UINT            Item
    );

VOID
DrawPerfGraph(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    );


BOOLEAN
CreateMemoryContext(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    );

VOID
DeleteMemoryContext(
    PDISPLAY_ITEM   DisplayItem
    );


VOID
ShiftPerfGraph(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    );

VOID
DrawCpuBarGraph(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem,
    UINT            Item
    );

#endif /* _WINPERFH_INCLUDED_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\cdlpage.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//

//
// module: CDLPage.cpp
// author: DMihai
// created: 11/1/00
//

#include "stdafx.h"
#include "verifier.h"

#include "CDLPage.h"
#include "VrfUtil.h"
#include "VGlobal.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Help IDs
//

static DWORD MyHelpIds[] =
{
    IDC_CONFDRV_LIST,               IDH_DV_UnsignedDriversList,
    0,                              0
};

/////////////////////////////////////////////////////////////////////////////
// CConfirmDriverListPage property page

IMPLEMENT_DYNCREATE(CConfirmDriverListPage, CVerifierPropertyPage)

CConfirmDriverListPage::CConfirmDriverListPage() 
    : CVerifierPropertyPage(CConfirmDriverListPage::IDD)
{
	//{{AFX_DATA_INIT(CConfirmDriverListPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    m_pParentSheet = NULL;

    m_nSortColumnIndex = 0;
    m_bAscendSortDrvName = FALSE;
    m_bAscendSortProvName = FALSE;
}

CConfirmDriverListPage::~CConfirmDriverListPage()
{
}

void CConfirmDriverListPage::DoDataExchange(CDataExchange* pDX)
{
    CVerifierPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CConfirmDriverListPage)
	DDX_Control(pDX, IDC_CONFDRV_NEXT_DESCR_STATIC, m_NextDescription);
	DDX_Control(pDX, IDC_CONFDRV_TITLE_STATIC, m_TitleStatic);
	DDX_Control(pDX, IDC_CONFDRV_LIST, m_DriversList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConfirmDriverListPage, CVerifierPropertyPage)
	//{{AFX_MSG_MAP(CConfirmDriverListPage)
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_CONFDRV_LIST, OnColumnclickConfdrvList)
    ON_WM_CONTEXTMENU()
    ON_MESSAGE( WM_HELP, OnHelp )
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
VOID CConfirmDriverListPage::SetupListHeader()
{
    LVCOLUMN lvColumn;
    CString strName;
    CString strDescription;
    CRect rectWnd;
    
    VERIFY( strName.LoadString( IDS_NAME ) );
    VERIFY( strDescription.LoadString( IDS_DESCRIPTION ) );

    //
    // list's regtangle
    //

    m_DriversList.GetClientRect( &rectWnd );
  
    //
    // Column 0
    //

    memset( &lvColumn, 0, sizeof( lvColumn ) );
    lvColumn.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;
    
    lvColumn.iSubItem = 0;
    lvColumn.pszText = strName.GetBuffer( strName.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.30 );
    VERIFY( m_DriversList.InsertColumn( 0, &lvColumn ) != -1 );
    strName.ReleaseBuffer();

    //
    // Column 1
    //

    lvColumn.iSubItem = 1;
    lvColumn.pszText = strDescription.GetBuffer( strDescription.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.65 );
    VERIFY( m_DriversList.InsertColumn( 1, &lvColumn ) != -1 );
    strDescription.ReleaseBuffer();
}

/////////////////////////////////////////////////////////////////////////////
VOID CConfirmDriverListPage::FillTheList()
{
    INT_PTR nDriversNo;
    INT_PTR nCrtDriverIndex;
    CDriverData *pCrtDrvData;
    const CDriverDataArray &DrvDataArray = g_NewVerifierSettings.m_DriversSet.m_aDriverData;

    m_DriversList.DeleteAllItems();

    //
    // Parse the driver data array
    //

    nDriversNo = DrvDataArray.GetSize();

    for( nCrtDriverIndex = 0; nCrtDriverIndex < nDriversNo; nCrtDriverIndex += 1)
    {
        pCrtDrvData = DrvDataArray.GetAt( nCrtDriverIndex );

        ASSERT_VALID( pCrtDrvData );

        if( g_NewVerifierSettings.m_DriversSet.ShouldDriverBeVerified( pCrtDrvData ) )
        {
            AddListItem( nCrtDriverIndex, 
                         pCrtDrvData );
        }
    }
}


/////////////////////////////////////////////////////////////////////////////
VOID CConfirmDriverListPage::AddListItem( INT_PTR nIndexInArray, CDriverData *pCrtDrvData )
{
    INT nActualIndex;
    LVITEM lvItem;

    ASSERT_VALID( pCrtDrvData );

    ZeroMemory( &lvItem, sizeof( lvItem ) );

    //
    // LVITEM's member pszText is not a const pointer 
    // so we need to GetBuffer here :-(
    //

    //
    // Sub-item 0
    //

    lvItem.pszText = pCrtDrvData->m_strName.GetBuffer( pCrtDrvData->m_strName.GetLength() + 1 );
    
    if( NULL == lvItem.pszText )
    {
        goto Done;
    }

    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.lParam = nIndexInArray;
    lvItem.iItem = m_DriversList.GetItemCount();
    lvItem.iSubItem = 0;
    
    nActualIndex = m_DriversList.InsertItem( &lvItem );
    
    pCrtDrvData->m_strName.ReleaseBuffer();

    if( nActualIndex < 0 )
    {
        //
        // Could not add an item in the list - give up
        //

        goto Done;
    }

    //
    // Sub-item 1
    //

    lvItem.pszText = pCrtDrvData->m_strFileDescription.GetBuffer( 
        pCrtDrvData->m_strFileDescription.GetLength() + 1 );
    
    if( NULL == lvItem.pszText )
    {
        goto Done;
    }

    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = nActualIndex;
    lvItem.iSubItem = 1;

    m_DriversList.SetItem( &lvItem );

    pCrtDrvData->m_strFileDescription.ReleaseBuffer();

Done:
    //
    // All done
    //

    NOTHING;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CConfirmDriverListPage::SetContextStrings( ULONG uTitleResId )
{
    return m_strTitle.LoadString( uTitleResId );
}

/////////////////////////////////////////////////////////////
VOID CConfirmDriverListPage::SortTheList()
{
    m_DriversList.SortItems( StringCmpFunc, (LPARAM)this );
}

/////////////////////////////////////////////////////////////
int CALLBACK CConfirmDriverListPage::StringCmpFunc( LPARAM lParam1,
                                                    LPARAM lParam2,
                                                    LPARAM lParamSort)
{
    int nCmpRez = 0;
    BOOL bSuccess;
    CString strName1;
    CString strName2;

    CConfirmDriverListPage *pThis = (CConfirmDriverListPage *)lParamSort;
    ASSERT_VALID( pThis );

    //
    // Get the first name
    //

    bSuccess = pThis->GetColumnStrValue( lParam1, 
                                         strName1 );

    if( FALSE == bSuccess )
    {
        goto Done;
    }

    //
    // Get the second name
    //

    bSuccess = pThis->GetColumnStrValue( lParam2, 
                                         strName2 );

    if( FALSE == bSuccess )
    {
        goto Done;
    }

    //
    // Compare the names
    //

    nCmpRez = strName1.CompareNoCase( strName2 );
    
    if( 0 == pThis->m_nSortColumnIndex )
    {
        //
        // Sort by driver name
        //

        if( FALSE != pThis->m_bAscendSortDrvName )
        {
            nCmpRez *= -1;
        }
    }
    else
    {
        //
        // Sort by provider name
        //

        if( FALSE != pThis->m_bAscendSortProvName )
        {
            nCmpRez *= -1;
        }
    }

Done:

    return nCmpRez;

}
/////////////////////////////////////////////////////////////
BOOL CConfirmDriverListPage::GetColumnStrValue( LPARAM lItemData, 
                                                CString &strName )
{
    CDriverData *pCrtDrvData;

    pCrtDrvData = g_NewVerifierSettings.m_DriversSet.m_aDriverData.GetAt( (INT_PTR) lItemData );

    ASSERT_VALID( pCrtDrvData );
    
    if( 0 == m_nSortColumnIndex )
    {
        //
        // Sort by driver name
        //

        strName = pCrtDrvData->m_strName;
    }
    else
    {
        //
        // Sort by provider name
        //

        strName = pCrtDrvData->m_strCompanyName;
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CConfirmDriverListPage::OnSetActive() 
{
    INT nItemsInList;
    BOOL bResult;

    m_TitleStatic.SetWindowText( m_strTitle );

    FillTheList();
    SortTheList();
    
    nItemsInList = m_DriversList.GetItemCount();

    if( nItemsInList < 1 )
    {
        //
        // No drivers have been selected to be verified
        //

        bResult = FALSE;
    }
    else
    {
        //
        // This is the last step of the wizard
        //

        m_pParentSheet->SetWizardButtons(   PSWIZB_BACK |
                                            PSWIZB_FINISH );

        bResult = CVerifierPropertyPage::OnSetActive();
    }

    return bResult;
}

/////////////////////////////////////////////////////////////////////////////
// CConfirmDriverListPage message handlers

BOOL CConfirmDriverListPage::OnInitDialog() 
{
	CVerifierPropertyPage::OnInitDialog();
	
    //
    // Setup the list
    //

    m_DriversList.SetExtendedStyle( 
        LVS_EX_FULLROWSELECT | m_DriversList.GetExtendedStyle() );

    SetupListHeader();

    VrfSetWindowText( m_NextDescription, IDS_CONFDRV_PAGE_NEXT_DESCR_FINISH );

    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
BOOL CConfirmDriverListPage::OnWizardFinish() 
{
	CVerifierPropertyPage::OnWizardFinish();

    return g_NewVerifierSettings.SaveToRegistry();
}

/////////////////////////////////////////////////////////////////////////////
void CConfirmDriverListPage::OnColumnclickConfdrvList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	
    if( 0 != pNMListView->iSubItem )
    {
        //
        // Clicked on the provider name column
        //

        if( m_nSortColumnIndex == pNMListView->iSubItem )
        {
            //
            // Change the current ascend/descend order for this column
            //

            m_bAscendSortProvName = !m_bAscendSortProvName;
        }
    }
    else
    {
        //
        // Clicked on the driver name column
        //

        if( m_nSortColumnIndex == pNMListView->iSubItem )
        {
            //
            // Change the current ascend/descend order for this column
            //

            m_bAscendSortDrvName = !m_bAscendSortDrvName;
        }
    }

    m_nSortColumnIndex = pNMListView->iSubItem;

    SortTheList();

    *pResult = 0;
}

/////////////////////////////////////////////////////////////
LONG CConfirmDriverListPage::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp( 
        (HWND) lpHelpInfo->hItemHandle,
        g_szVerifierHelpFile,
        HELP_WM_HELP,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}

/////////////////////////////////////////////////////////////////////////////
void CConfirmDriverListPage::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    ::WinHelp( 
        pWnd->m_hWnd,
        g_szVerifierHelpFile,
        HELP_CONTEXTMENU,
        (DWORD_PTR) MyHelpIds );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\dcntpage.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: DCntPage.cpp
// author: DMihai
// created: 11/1/00
//
// Description:
//

#include "stdafx.h"
#include "verifier.h"

#include "DCntPage.h"
#include "VrfUtil.h"
#include "VGlobal.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Timer ID
//

#define REFRESH_TIMER_ID    0x1234

//
// Help IDs
//

static DWORD MyHelpIds[] =
{
    IDC_PERDRVC_DRIVER_COMBO,       IDH_DV_Counters_DriverList,
    IDC_PERDRVC_LIST,               IDH_DV_DriverCounters,
    0,                              0
};

/////////////////////////////////////////////////////////////////////////////
// CDriverCountersPage property page

IMPLEMENT_DYNCREATE(CDriverCountersPage, CVerifierPropertyPage)

CDriverCountersPage::CDriverCountersPage() : CVerifierPropertyPage(CDriverCountersPage::IDD)
{
	//{{AFX_DATA_INIT(CDriverCountersPage)
	//}}AFX_DATA_INIT

    m_nSortColumnIndex = 0;
    m_bAscendSortName = FALSE;
    m_bAscendSortValue = FALSE;

    m_uTimerHandler = 0;

    m_pParentSheet = NULL;
}

CDriverCountersPage::~CDriverCountersPage()
{
}

void CDriverCountersPage::DoDataExchange(CDataExchange* pDX)
{
    if( ! pDX->m_bSaveAndValidate )
    {
        //
        // Query the kernel
        //

        VrfGetRuntimeVerifierData( &m_RuntimeVerifierData );
    }

    CVerifierPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CDriverCountersPage)
    DDX_Control(pDX, IDC_PERDRVC_DRIVER_COMBO, m_DriversCombo);
    DDX_Control(pDX, IDC_PERDRVC_NEXT_DESCR_STATIC, m_NextDescription);
    DDX_Control(pDX, IDC_PERDRVC_LIST, m_CountersList);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDriverCountersPage, CVerifierPropertyPage)
    //{{AFX_MSG_MAP(CDriverCountersPage)
    ON_WM_TIMER()
    ON_CBN_SELENDOK(IDC_PERDRVC_DRIVER_COMBO, OnSelendokDriverCombo)
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_PERDRVC_LIST, OnColumnclickPerdrvcList)
    ON_WM_CONTEXTMENU()
    ON_MESSAGE( WM_HELP, OnHelp )
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////

VOID CDriverCountersPage::SetupListHeader()
{
    LVCOLUMN lvColumn;
    CRect rectWnd;
    CString strCounter, strValue;
    
    VERIFY( strCounter.LoadString( IDS_COUNTER ) );
    VERIFY( strValue.LoadString( IDS_VALUE ) );

    //
    // List's regtangle
    //

    m_CountersList.GetClientRect( &rectWnd );
    
    //
    // Column 0 - counter
    //

    ZeroMemory( &lvColumn, sizeof( lvColumn ) );
    lvColumn.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;
    
    lvColumn.iSubItem = 0;
    lvColumn.pszText = strCounter.GetBuffer( strCounter.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.50 );
    VERIFY( m_CountersList.InsertColumn( 0, &lvColumn ) != -1 );
    strCounter.ReleaseBuffer();

    //
    // Column 1
    //

    lvColumn.iSubItem = 1;
    lvColumn.pszText = strValue.GetBuffer( strValue.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.47 );
    VERIFY( m_CountersList.InsertColumn( 1, &lvColumn ) != -1 );
    strValue.ReleaseBuffer();
}

/////////////////////////////////////////////////////////////
VOID CDriverCountersPage::FillTheList()
{
    CRuntimeDriverData *pRuntimeDriverData;

    pRuntimeDriverData = GetCurrentDrvRuntimeData();

    AddAllListItems( pRuntimeDriverData );
}

/////////////////////////////////////////////////////////////
VOID CDriverCountersPage::AddAllListItems( CRuntimeDriverData *pRuntimeDriverData )
{
    if( NULL != pRuntimeDriverData )
    {
        ASSERT_VALID( pRuntimeDriverData );

        //
        // N.B.
        //
        // If you change this order then you need to change GetCounterValue as well
        //

        AddCounterInList( 0, IDS_CURRENTPAGEDPOOLALLOCATIONS_LIST, pRuntimeDriverData->CurrentPagedPoolAllocations );
        AddCounterInList( 1, IDS_PEAKPAGEDPOOLALLOCATIONS_LIST, pRuntimeDriverData->PeakPagedPoolAllocations );
        AddCounterInList( 2, IDS_PAGEDPOOLUSAGEINBYTES_LIST, pRuntimeDriverData->PagedPoolUsageInBytes );
        AddCounterInList( 3, IDS_PEAKPAGEDPOOLUSAGEINBYTES_LIST, pRuntimeDriverData->PeakPagedPoolUsageInBytes );

        AddCounterInList( 4, IDS_CURRENTNONPAGEDPOOLALLOCATIONS_LIST, pRuntimeDriverData->CurrentNonPagedPoolAllocations );
        AddCounterInList( 5, IDS_PEAKNONPAGEDPOOLALLOCATIONS_LIST, pRuntimeDriverData->PeakNonPagedPoolAllocations );
        AddCounterInList( 6, IDS_NONPAGEDPOOLUSAGEINBYTES_LIST, pRuntimeDriverData->NonPagedPoolUsageInBytes );
        AddCounterInList( 7, IDS_PEAKNONPAGEDPOOLUSAGEINBYTES_LIST, pRuntimeDriverData->PeakNonPagedPoolUsageInBytes );
    }
    else
    {
        //
        // N.B.
        //
        // If you change this order then you need to change GetCounterValue as well
        //

        AddCounterInList( 0, IDS_CURRENTPAGEDPOOLALLOCATIONS_LIST );
        AddCounterInList( 1, IDS_PEAKPAGEDPOOLALLOCATIONS_LIST );
        AddCounterInList( 2, IDS_PAGEDPOOLUSAGEINBYTES_LIST );
        AddCounterInList( 3, IDS_PEAKPAGEDPOOLUSAGEINBYTES_LIST );

        AddCounterInList( 4, IDS_CURRENTNONPAGEDPOOLALLOCATIONS_LIST );
        AddCounterInList( 5, IDS_PEAKNONPAGEDPOOLALLOCATIONS_LIST );
        AddCounterInList( 6, IDS_NONPAGEDPOOLUSAGEINBYTES_LIST );
        AddCounterInList( 7, IDS_PEAKNONPAGEDPOOLUSAGEINBYTES_LIST );
    }
}

/////////////////////////////////////////////////////////////
VOID CDriverCountersPage::RefreshTheList()
{
    INT nListItems;
    INT nCrtListItem;
    INT_PTR nCrtCounterIndex;
    SIZE_T sizeValue;
    CRuntimeDriverData *pRuntimeDriverData;

    pRuntimeDriverData = GetCurrentDrvRuntimeData();

    nListItems = m_CountersList.GetItemCount();

    if( NULL != pRuntimeDriverData )
    {
        for( nCrtListItem = 0; nCrtListItem < nListItems; nCrtListItem += 1 )
        {
            nCrtCounterIndex = m_CountersList.GetItemData( nCrtListItem );

            sizeValue = GetCounterValue( nCrtCounterIndex, pRuntimeDriverData );

            UpdateCounterValueInList( nCrtListItem, sizeValue );
        }
    }
    else
    {
        //
        // N.B.
        //
        // If you change this order then you need to
        // change AddAllListItems as well
        //

        for( nCrtListItem = 0; nCrtListItem < nListItems; nCrtListItem += 1 )
        {
            UpdateCounterValueInList( nCrtListItem, g_szVoidText );
        }
    }

    SortTheList();
}

/////////////////////////////////////////////////////////////
INT CDriverCountersPage::AddCounterInList( INT nItemData, 
                                           ULONG  uIdResourceString )
{
    INT nActualIndex;
    LVITEM lvItem;
    CString strName;

    nActualIndex = -1;

    VERIFY( strName.LoadString( uIdResourceString ) );

    ZeroMemory( &lvItem, sizeof( lvItem ) );

    //
    // LVITEM's member pszText is not a const pointer 
    // so we need to GetBuffer here :-(
    //

    //
    // Sub-item 0 - counter's name
    //

    lvItem.pszText = strName.GetBuffer( strName.GetLength() + 1 );
    
    if( NULL == lvItem.pszText )
    {
        goto Done;
    }

    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.lParam = nItemData;
    lvItem.iItem = m_CountersList.GetItemCount();

    nActualIndex = m_CountersList.InsertItem( &lvItem );

    if( nActualIndex < 0 )
    {
        //
        // Could not add an item in the list - give up
        //

        goto Done;
    }

Done:
    //
    // All done
    //

    return nActualIndex;
}

/////////////////////////////////////////////////////////////
VOID CDriverCountersPage::AddCounterInList( INT nItemData, 
                                            ULONG  uIdResourceString,
                                            SIZE_T sizeValue )
{
    INT nActualIndex;

    nActualIndex = AddCounterInList( nItemData, uIdResourceString );

    if( nActualIndex < 0 )
    {
        //
        // Could not add an item in the list - give up
        //

        goto Done;
    }

    //
    // Sub-item 1 - counter's value
    //
    
    UpdateCounterValueInList( nActualIndex,
                              sizeValue );

Done:
    //
    // All done
    //

    NOTHING;
}

/////////////////////////////////////////////////////////////
SIZE_T CDriverCountersPage::GetCounterValue( INT_PTR nCounterIndex, CRuntimeDriverData *pRuntimeDriverData /*= NULL*/ )
{
    SIZE_T sizeValue;

    if( NULL == pRuntimeDriverData )
    {
        pRuntimeDriverData = GetCurrentDrvRuntimeData();
    }

    if( NULL == pRuntimeDriverData )
    {
        //
        // No driver is curently selected in the combo
        //

        return 0;
    }
    
    //
    // N.B. 
    //
    // If you change this switch statement you need to change AddAllListItems as well
    //

    switch( nCounterIndex )
    {
    case 0:
        sizeValue = pRuntimeDriverData->CurrentPagedPoolAllocations;
        break;

    case 1:
        sizeValue = pRuntimeDriverData->PeakPagedPoolAllocations;
        break;

    case 2:
        sizeValue = pRuntimeDriverData->PagedPoolUsageInBytes;
        break;

    case 3:
        sizeValue = pRuntimeDriverData->PeakPagedPoolUsageInBytes;
        break;

    case 4:
        sizeValue = pRuntimeDriverData->CurrentNonPagedPoolAllocations;
        break;

    case 5:
        sizeValue = pRuntimeDriverData->PeakNonPagedPoolAllocations;
        break;

    case 6:
        sizeValue = pRuntimeDriverData->NonPagedPoolUsageInBytes;
        break;

    case 7:
        sizeValue = pRuntimeDriverData->PeakNonPagedPoolUsageInBytes;
        break;

    default:
        //
        // Oops, how did we get here ?!?
        //

        ASSERT( FALSE );

        sizeValue = 0;

        break;
    }

    return sizeValue;
}

/////////////////////////////////////////////////////////////
BOOL CDriverCountersPage::GetCounterName( LPARAM lItemData, 
                                          TCHAR *szCounterName,
                                          ULONG uCounterNameBufferLen )
{
    INT nItemIndex;
    BOOL bResult;
    LVFINDINFO FindInfo;
    LVITEM lvItem;

    bResult = FALSE;

    ZeroMemory( &FindInfo, sizeof( FindInfo ) );
    FindInfo.flags = LVFI_PARAM;
    FindInfo.lParam = lItemData;

    nItemIndex = m_CountersList.FindItem( &FindInfo );

    if( nItemIndex < 0 || nItemIndex > 7 )
    {
        ASSERT( FALSE );
    }
    else
    {
        //
        // Found our item - get the name
        //

        ZeroMemory( &lvItem, sizeof( lvItem ) );

        lvItem.mask = LVIF_TEXT;
        lvItem.iItem = nItemIndex;
        lvItem.iSubItem = 0;
        lvItem.pszText = szCounterName;
        lvItem.cchTextMax = uCounterNameBufferLen;

        bResult = m_CountersList.GetItem( &lvItem );
        
        if( bResult == FALSE )
        {
            //
            // Could not get the current item's attributes?!?
            //

            ASSERT( FALSE );
        }
    }

    return bResult;
}


/////////////////////////////////////////////////////////////
VOID CDriverCountersPage::UpdateCounterValueInList( INT nItemIndex,
                                                    LPTSTR szValue )
{
    LVITEM lvItem;

    //
    // Update the list item
    //

    ZeroMemory( &lvItem, sizeof( lvItem ) );
    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = nItemIndex;
    lvItem.iSubItem = 1;
    lvItem.pszText = szValue;
    VERIFY( m_CountersList.SetItem( &lvItem ) );
}


/////////////////////////////////////////////////////////////
VOID CDriverCountersPage::UpdateCounterValueInList( INT nItemIndex,
                                                    SIZE_T sizeValue )
{
    TCHAR szValue[ 32 ];

#ifndef _WIN64

    //
    // 32 bit SIZE_T
    //

    _sntprintf( szValue,
                ARRAY_LENGTH( szValue ),
                _T( "%u" ),
                sizeValue );

#else

    //
    // 64 bit SIZE_T
    //

    _sntprintf( szValue,
                ARRAY_LENGTH( szValue ),
                _T( "%I64u" ),
                sizeValue );

#endif

    szValue[ ARRAY_LENGTH( szValue ) - 1 ] = 0;

    UpdateCounterValueInList( nItemIndex,
                              szValue );
                              
}

/////////////////////////////////////////////////////////////
VOID CDriverCountersPage::RefreshCombo()
{
    BOOL *pbAlreadyInCombo;
    CRuntimeDriverData *pRuntimeDriverData;
    INT_PTR nDrivers;
    INT_PTR nCrtDriver;
    INT nCrtSelectedItem;
    INT nCrtItemIndex;
    INT nComboItemCount;
    INT nActualIndex;
    CString strCurrentDriverName;
    CString strDriverName;

    nDrivers = m_RuntimeVerifierData.m_RuntimeDriverDataArray.GetSize();

    if( 0 >= nDrivers )
    {
        //
        // No drivers are currently verified - delete the combo-box content
        //

        m_DriversCombo.ResetContent();
        m_DriversCombo.SetCurSel( CB_ERR );
        m_DriversCombo.EnableWindow( FALSE );

        OnSelendokDriverCombo();
    }
    else
    {
        nCrtSelectedItem = 0;
        nComboItemCount = m_DriversCombo.GetCount();

        //
        // Note the currently selected driver name
        //

        GetCurrentSelDriverName( strCurrentDriverName );

        //
        // Allocate an array of BOOL values, one for each driver in
        // our runtime data array
        //

        pbAlreadyInCombo = new BOOL[ nDrivers ];

        if( NULL == pbAlreadyInCombo )
        {
            goto Done;
        }

        for( nCrtDriver = 0; nCrtDriver < nDrivers; nCrtDriver++ )
        {
            pbAlreadyInCombo[ nCrtDriver ] = FALSE;
        }

        //
        // Parse all the items currently in the combo-box
        //

        for( nCrtItemIndex = 0; nCrtItemIndex < nComboItemCount; nCrtItemIndex++ )
        {
            m_DriversCombo.GetLBText( nCrtItemIndex, strDriverName );

            //
            // Parse all the currently verified drivers
            //

            for( nCrtDriver = 0; nCrtDriver < nDrivers; nCrtDriver++ )
            {
                pRuntimeDriverData = m_RuntimeVerifierData.m_RuntimeDriverDataArray.GetAt( nCrtDriver );

                ASSERT_VALID( pRuntimeDriverData );

                if( strDriverName.CompareNoCase( pRuntimeDriverData->m_strName ) == 0 )
                {
                    pbAlreadyInCombo[ nCrtDriver ] = TRUE;

                    break;
                }
            }

            if( nCrtDriver >= nDrivers )
            {
                //
                // We need to delete the current combo item because
                // the corresponfing driver is no longer verified 
                //

                m_DriversCombo.DeleteString( nCrtItemIndex );

                nCrtItemIndex--;
                nComboItemCount--;
            }
        }

        //
        // Add the new items in the combo
        //

        for( nCrtDriver = 0; nCrtDriver < nDrivers; nCrtDriver++ )
        {
            if( FALSE == pbAlreadyInCombo[ nCrtDriver ] )
            {
                pRuntimeDriverData = m_RuntimeVerifierData.m_RuntimeDriverDataArray.GetAt( nCrtDriver );

                ASSERT_VALID( pRuntimeDriverData );

                nActualIndex = m_DriversCombo.AddString( pRuntimeDriverData->m_strName );

                if( nActualIndex != CB_ERR )
                {   
                    m_DriversCombo.SetItemData( nActualIndex, nCrtDriver );
                }   
            }
        }

        delete [] pbAlreadyInCombo;

        //
        // Restore the old current selection in the combo
        //

        nComboItemCount = m_DriversCombo.GetCount();

        for( nCrtItemIndex = 0; nCrtItemIndex < nComboItemCount; nCrtItemIndex++ )
        {
            m_DriversCombo.GetLBText( nCrtItemIndex, strDriverName );

            if( strDriverName.CompareNoCase( strCurrentDriverName ) == 0 )
            {
                nCrtSelectedItem = nCrtItemIndex;
                break;
            }
        }

        m_DriversCombo.SetCurSel( nCrtSelectedItem );
        OnSelendokDriverCombo();
     }

Done:

    NOTHING;
}

/////////////////////////////////////////////////////////////
VOID CDriverCountersPage::RefreshInfo() 
{
    if( UpdateData( FALSE ) )
    {
        //
        // Refresh the combo content - this will also 
        // refresh the counters list
        //

        RefreshCombo();
    }
}

/////////////////////////////////////////////////////////////
VOID CDriverCountersPage::GetCurrentSelDriverName( CString &strName )
{
    INT nCrtSel;

    nCrtSel = m_DriversCombo.GetCurSel();

    if( CB_ERR != nCrtSel )
    {
        m_DriversCombo.GetLBText( nCrtSel, strName );
    }
    else
    {
        strName.Empty();
    }
}

/////////////////////////////////////////////////////////////
CRuntimeDriverData *CDriverCountersPage::GetCurrentDrvRuntimeData()
{
    INT nCrtComboSelection;
    INT_PTR nCrtDriverIndex;
    CRuntimeDriverData *pRuntimeDriverData;

    pRuntimeDriverData = NULL;

    nCrtDriverIndex = -1;

    nCrtComboSelection = m_DriversCombo.GetCurSel();
    
    if( nCrtComboSelection != CB_ERR )
    {
        nCrtDriverIndex = m_DriversCombo.GetItemData( nCrtComboSelection );

        if( nCrtDriverIndex >= 0 && nCrtDriverIndex < m_RuntimeVerifierData.m_RuntimeDriverDataArray.GetSize() )
        {
            pRuntimeDriverData = m_RuntimeVerifierData.m_RuntimeDriverDataArray.GetAt( nCrtDriverIndex );

            ASSERT_VALID( pRuntimeDriverData );
        }
    }

    return pRuntimeDriverData;
}

/////////////////////////////////////////////////////////////
VOID CDriverCountersPage::SortTheList()
{
    if( 0 != m_nSortColumnIndex )
    {
        //
        // Sort by counter value - this is probably not very useful
        // but we are providing it to be consistent with all
        // the lists being sortable by any column
        //

        m_CountersList.SortItems( CounterValueCmpFunc, (LPARAM)this );
    }
    else
    {
        //
        // Sort by driver name
        //

        m_CountersList.SortItems( CounterNameCmpFunc, (LPARAM)this );
    }
}

/////////////////////////////////////////////////////////////
int CALLBACK CDriverCountersPage::CounterValueCmpFunc( LPARAM lParam1,
                                                       LPARAM lParam2,
                                                       LPARAM lParamSort)
{
    SIZE_T size1;
    SIZE_T size2;
    int nCmpRez = 0;

    CDriverCountersPage *pThis = (CDriverCountersPage *)lParamSort;
    ASSERT_VALID( pThis );

    size1 = pThis->GetCounterValue( (INT) lParam1 );
    size2 = pThis->GetCounterValue( (INT) lParam2 );

    if( size1 > size2 )
    {
        nCmpRez = 1;
    }
    else
    {
        if( size1 < size2 )
        {
            nCmpRez = -1;
        }
    }

    if( FALSE != pThis->m_bAscendSortValue )
    {
        nCmpRez *= -1;
    }

    return nCmpRez;
}

/////////////////////////////////////////////////////////////
int CALLBACK CDriverCountersPage::CounterNameCmpFunc( LPARAM lParam1,
                                                    LPARAM lParam2,
                                                    LPARAM lParamSort)
{
    int nCmpRez = 0;
    BOOL bSuccess;
    TCHAR szCounterName1[ _MAX_PATH ];
    TCHAR szCounterName2[ _MAX_PATH ];

    CDriverCountersPage *pThis = (CDriverCountersPage *)lParamSort;
    ASSERT_VALID( pThis );

    //
    // Get the first counter name
    //

    bSuccess = pThis->GetCounterName( lParam1, 
                                      szCounterName1,
                                      ARRAY_LENGTH( szCounterName1 ) );

    if( FALSE == bSuccess )
    {
        goto Done;
    }

    //
    // Get the second counter name
    //

    bSuccess = pThis->GetCounterName( lParam2, 
                                      szCounterName2,
                                      ARRAY_LENGTH( szCounterName2 ) );

    if( FALSE == bSuccess )
    {
        goto Done;
    }

    //
    // Compare the names
    //

    nCmpRez = _tcsicmp( szCounterName1, szCounterName2 );
    
    if( FALSE != pThis->m_bAscendSortName )
    {
        nCmpRez *= -1;
    }

Done:

    return nCmpRez;
}


/////////////////////////////////////////////////////////////
// CDriverCountersPage message handlers

BOOL CDriverCountersPage::OnInitDialog() 
{
    CPropertyPage::OnInitDialog();

    //
    // Setup the settings bits list
    //

    m_CountersList.SetExtendedStyle( 
        LVS_EX_FULLROWSELECT | m_CountersList.GetExtendedStyle() );

    m_CountersList.SetBkColor( ::GetSysColor( COLOR_3DFACE ) );
    m_CountersList.SetTextBkColor( ::GetSysColor( COLOR_3DFACE ) );

    SetupListHeader();
    FillTheList();
    SortTheList();

    RefreshCombo();

    VrfSetWindowText( m_NextDescription, IDS_DCNT_PAGE_NEXT_DESCR );

    VERIFY( m_uTimerHandler = SetTimer( REFRESH_TIMER_ID, 
                                        5000,
                                        NULL ) );

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////
VOID CDriverCountersPage::OnTimer(UINT nIDEvent) 
{
    if( nIDEvent == REFRESH_TIMER_ID )
    {
        ASSERT_VALID( m_pParentSheet );

        if( m_pParentSheet->GetActivePage() == this )
        {
            //
            // Refresh the displayed data 
            //

            RefreshInfo();
        }
    }

    CPropertyPage::OnTimer(nIDEvent);
}

/////////////////////////////////////////////////////////////////////////////
BOOL CDriverCountersPage::OnSetActive() 
{
    ASSERT_VALID( m_pParentSheet );

    m_pParentSheet->SetWizardButtons(   PSWIZB_BACK |
                                        PSWIZB_FINISH );
    	
	return CVerifierPropertyPage::OnSetActive();
}

/////////////////////////////////////////////////////////////
void CDriverCountersPage::OnSelendokDriverCombo() 
{
    RefreshTheList();
}

/////////////////////////////////////////////////////////////
void CDriverCountersPage::OnColumnclickPerdrvcList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	
    if( 0 != pNMListView->iSubItem )
    {
        //
        // Clicked on the counter value column
        //

        if( m_nSortColumnIndex == pNMListView->iSubItem )
        {
            //
            // Change the current ascend/descend order for this column
            //

            m_bAscendSortValue = !m_bAscendSortValue;
        }
    }
    else
    {
        //
        // Clicked on the counter name column
        //

        if( m_nSortColumnIndex == pNMListView->iSubItem )
        {
            //
            // Change the current ascend/descend order for this column
            //

            m_bAscendSortName = !m_bAscendSortName;
        }
    }

    m_nSortColumnIndex = pNMListView->iSubItem;

    SortTheList();

    *pResult = 0;
}

/////////////////////////////////////////////////////////////
LONG CDriverCountersPage::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp( 
        (HWND) lpHelpInfo->hItemHandle,
        g_szVerifierHelpFile,
        HELP_WM_HELP,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}

/////////////////////////////////////////////////////////////////////////////
void CDriverCountersPage::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    ::WinHelp( 
        pWnd->m_hWnd,
        g_szVerifierHelpFile,
        HELP_CONTEXTMENU,
        (DWORD_PTR) MyHelpIds );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\cmdline.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: CmdLine.cpp
// author: DMihai
// created: 11/1/00
//
// Description:
//

#include "stdafx.h"
#include "verifier.h"

#include "CmdLine.h"
#include "VrfUtil.h"
#include "VGlobal.h"

/////////////////////////////////////////////////////////////////////////////
//
// Execute command line
//

DWORD CmdLineExecute( INT argc, TCHAR *argv[] )
{
    BOOL bFoundCmdLineSwitch;
    BOOL bHaveNewFlags;
    BOOL bHaveNewDrivers;
    BOOL bHaveVolatile;
    BOOL bVolatileAddDriver;
    DWORD dwExitCode;
    DWORD dwNewFlags;
    INT_PTR nDrivers;
    INT_PTR nCrtDriver;
    CStringArray astrNewDrivers;
    CString strAllDrivers;

    dwExitCode = EXIT_CODE_SUCCESS;

    //
    // See if the user asked for help
    // 

    bFoundCmdLineSwitch = CmdLineExecuteIfHelp( argc,
                                                argv );

    if( TRUE == bFoundCmdLineSwitch )
    {
        //
        // We are done printing out the help strings
        //

        goto Done;
    }

    //
    // See if the user asked to reset all the existing verifier settings
    // 

    bFoundCmdLineSwitch = CmdLineFindResetSwitch( argc,
                                                  argv );

    if( TRUE == bFoundCmdLineSwitch )
    {
        if( VrfDeleteAllVerifierSettings() )
        {
            if( g_bSettingsSaved )
            {
                //
                // Had some non-void verifier settings before 
                //

                dwExitCode = EXIT_CODE_REBOOT_NEEDED;
            }
            else
            {
                //
                // Nothing has changed
                //

                dwExitCode = EXIT_CODE_SUCCESS;
            }
        }
        else
        {
            dwExitCode = EXIT_CODE_ERROR;
        }

        //
        // We are deleting the settings
        //

        goto Done;
    }

    //
    // See if we need to start logging statistics
    //

    bFoundCmdLineSwitch = CmdLineExecuteIfLog( argc,
                                               argv );

    if( TRUE == bFoundCmdLineSwitch )
    {
        //
        // We are done logging
        //

        goto Done;
    }

    //
    // See if the user asked to dump the current statistics 
    // to the console
    // 

    bFoundCmdLineSwitch = CmdLineExecuteIfQuery( argc,
                                                 argv );

    if( TRUE == bFoundCmdLineSwitch )
    {
        //
        // We are done with the query
        //

        goto Done;
    }

    //
    // See if the user asked to dump the current registry settings 
    // 

    bFoundCmdLineSwitch = CmdLineExecuteIfQuerySettings( argc,
                                                         argv );

    if( TRUE == bFoundCmdLineSwitch )
    {
        //
        // We are done with the settings query
        //

        goto Done;
    }

    //
    // Get the new flags, drivers and volatile 
    // if they have been specified
    //

    bHaveNewFlags = FALSE;
    bHaveNewDrivers = FALSE;
    bHaveVolatile = FALSE;

    CmdLineGetFlagsDriversVolatile(
        argc,
        argv,
        dwNewFlags,
        bHaveNewFlags,
        astrNewDrivers,
        bHaveNewDrivers,
        bHaveVolatile,
        bVolatileAddDriver );

    if( bHaveNewFlags || bHaveNewDrivers )
    {
        //
        // Some new drivers and/or flags have been specified
        //

        if( FALSE != bHaveVolatile )
        {
            //
            // Have new volative settings
            //

            if( bHaveNewFlags )
            {
                VrfSetNewFlagsVolatile( dwNewFlags );
            }
            else
            {
                if( astrNewDrivers.GetSize() > 0 )
                {
                    //
                    // Have some new drivers to add or remove
                    // from the verify list
                    //

                    if( bVolatileAddDriver )
                    {
                        //
                        // Add some drivers
                        //

                        VrfAddDriversVolatile( astrNewDrivers );
                    }
                    else
                    {
                        //
                        // Remove some drivers
                        //

                        VrfRemoveDriversVolatile( astrNewDrivers );
                    }
                }
            }
        }
        else
        {
            //
            // Have new persistent settings (registry)
            //

            //
            // Try to get the old settings
            //

            VrtLoadCurrentRegistrySettings( g_bAllDriversVerified,
                                            g_astrVerifyDriverNamesRegistry,
                                            g_dwVerifierFlagsRegistry );

            if( bHaveNewDrivers )
            {
                //
                // Concat all the new driver names in only one string,
                // separated with spaces
                //

                nDrivers = astrNewDrivers.GetSize();

                for( nCrtDriver = 0; nCrtDriver < nDrivers; nCrtDriver += 1 )
                {
                    if( strAllDrivers.GetLength() > 0 )
                    {
                        strAllDrivers += _T( ' ' );
                    }

                    strAllDrivers += astrNewDrivers.ElementAt( nCrtDriver );
                }
            }

            //
            // If:
            //
            // - we are switching to "all drivers verified" OR
            // - we are switching to a new set of drivers to be verified OR
            // - we are switching to other verifier flags
            //

            if( ( bHaveNewDrivers && 
                  strAllDrivers.CompareNoCase( _T( "*" ) ) == 0 && 
                  TRUE != g_bAllDriversVerified )       ||

                ( bHaveNewDrivers && 
                  strAllDrivers.CompareNoCase( _T( "*" ) ) != 0 && 
                  VrfIsDriversSetDifferent( strAllDrivers, g_astrVerifyDriverNamesRegistry ) ) ||

                ( bHaveNewFlags && dwNewFlags != g_dwVerifierFlagsRegistry ) )
            {
                //
                // These are different settings from what we had before
                //

                VrfWriteVerifierSettings( bHaveNewDrivers,
                                          strAllDrivers,
                                          bHaveNewFlags,
                                          dwNewFlags );
            }
            else
            {
                //
                // The new settings are the same as previous
                //

                VrfMesssageFromResource( IDS_NO_SETTINGS_WERE_CHANGED );
            }

            if( g_bSettingsSaved )
            {
                VrfMesssageFromResource( IDS_NEW_SETTINGS );

                VrfDumpRegistrySettingsToConsole();
            }
        }
    }

Done:

    return dwExitCode;
}


/////////////////////////////////////////////////////////////////////////////
//
// See if the user asked for help and print out the help strings
// 

BOOL CmdLineExecuteIfHelp( INT argc, 
                           TCHAR *argv[] )
{
    BOOL bPrintedHelp;
    TCHAR szCmdLineSwitch[ 64 ];

    bPrintedHelp = FALSE;

    VERIFY( VrfLoadString( IDS_HELP_CMDLINE_SWITCH,
                           szCmdLineSwitch,
                           ARRAY_LENGTH( szCmdLineSwitch ) ) );

    //
    // Search for help switch in the command line
    //

    if( argc == 2 && _tcsicmp( argv[ 1 ], szCmdLineSwitch) == 0)
    {
        CmdLinePrintHelpInformation();

        bPrintedHelp = TRUE;
    }

    return bPrintedHelp;
}

/////////////////////////////////////////////////////////////////////////////
VOID CmdLinePrintHelpInformation()
{
    VrfTPrintfResourceFormat( IDS_HELP_LINE1, VER_PRODUCTVERSION_STR );

    puts( VER_LEGALCOPYRIGHT_STR );

    VrfPrintStringFromResources( IDS_HELP_LINE3 );
    VrfPrintStringFromResources( IDS_HELP_LINE4 );
    VrfPrintStringFromResources( IDS_HELP_LINE5 );
    VrfPrintStringFromResources( IDS_HELP_LINE6 );
    VrfPrintStringFromResources( IDS_HELP_LINE7 );
    VrfPrintStringFromResources( IDS_HELP_LINE8 );
    VrfPrintStringFromResources( IDS_HELP_LINE9 );
    VrfPrintStringFromResources( IDS_HELP_LINE10 );
    VrfPrintStringFromResources( IDS_HELP_LINE11 );
    VrfPrintStringFromResources( IDS_HELP_LINE12 );
    VrfPrintStringFromResources( IDS_HELP_LINE13 );
    VrfPrintStringFromResources( IDS_HELP_LINE14 );
    VrfPrintStringFromResources( IDS_HELP_LINE15 );
    VrfPrintStringFromResources( IDS_HELP_LINE16 );
    VrfPrintStringFromResources( IDS_HELP_LINE17 );
    VrfPrintStringFromResources( IDS_HELP_LINE18 );
    VrfPrintStringFromResources( IDS_HELP_LINE19 );
    VrfPrintStringFromResources( IDS_HELP_LINE20 );
    VrfPrintStringFromResources( IDS_HELP_LINE21 );
    VrfPrintStringFromResources( IDS_HELP_LINE22 );
    VrfPrintStringFromResources( IDS_HELP_LINE23 );
    VrfPrintStringFromResources( IDS_HELP_LINE24 );
    VrfPrintStringFromResources( IDS_HELP_LINE25 );
    VrfPrintStringFromResources( IDS_HELP_LINE26 );
    VrfPrintStringFromResources( IDS_HELP_LINE27 );
    VrfPrintStringFromResources( IDS_HELP_LINE28 );
    VrfPrintStringFromResources( IDS_HELP_LINE29 );
    VrfPrintStringFromResources( IDS_HELP_LINE30 );
    VrfPrintStringFromResources( IDS_HELP_LINE31 );
}

/////////////////////////////////////////////////////////////////////////////
//
// See if the user asked to reset all the existing verifier settings
// 

BOOL CmdLineFindResetSwitch( INT argc,
                             TCHAR *argv[] )
{
    BOOL bFound;
    TCHAR szCmdLineOption[ 64 ];

    bFound = FALSE;

    if( 2 == argc )
    {
        VERIFY( VrfLoadString( IDS_RESET_CMDLINE_SWITCH,
                               szCmdLineOption,
                               ARRAY_LENGTH( szCmdLineOption ) ) );

        bFound = ( _tcsicmp( argv[ 1 ], szCmdLineOption) == 0 );
    }

    return bFound;
}

/////////////////////////////////////////////////////////////////////////////
//
// See if we need to start logging statistics
//

BOOL CmdLineExecuteIfLog( INT argc,
                          TCHAR *argv[] )
{
    INT nCrtArg;
    BOOL bStartLogging;
    LPCTSTR szLogFileName;
    DWORD dwLogMillisec;
    FILE *file;
    TCHAR szLogCmdLineOption[ 64 ];
    TCHAR szIntervalCmdLineOption[ 64 ];

    bStartLogging = FALSE;

    szLogFileName = NULL;

    if( argc < 2 )
    {
        //
        // Need at least /log LOG_FILE_NAME IN THE CMD LINE
        //

        goto Done;
    }
    
    //
    // Default log period - 30 sec
    //

    dwLogMillisec = 30000; 

    VERIFY( VrfLoadString( IDS_LOG_CMDLINE_SWITCH,
                           szLogCmdLineOption,
                           ARRAY_LENGTH( szLogCmdLineOption ) ) );

    VERIFY( VrfLoadString( IDS_INTERVAL_CMDLINE_SWITCH,
                           szIntervalCmdLineOption,
                           ARRAY_LENGTH( szIntervalCmdLineOption ) ) );


    for( nCrtArg = 1; nCrtArg < argc - 1; nCrtArg += 1 )
    {
        if( _tcsicmp( argv[ nCrtArg ], szLogCmdLineOption) == 0 )
        {
            //
            // Start logging
            //

            bStartLogging = TRUE;

            szLogFileName = argv[ nCrtArg + 1 ];
        }
        else
        {
            if( _tcsicmp( argv[ nCrtArg ], szIntervalCmdLineOption) == 0 )
            {
                //
                // Logging period
                //

                dwLogMillisec = _ttoi( argv[ nCrtArg + 1 ] ) * 1000;
            }
        }
    }

    if( TRUE == bStartLogging )
    {
        ASSERT( szLogFileName != NULL );

        while( TRUE )
        {
            //
            // Open the file
            //

            file = _tfopen( szLogFileName, TEXT("a+") );

            if( file == NULL )
            {
                //
                // print a error message
                //

                VrfTPrintfResourceFormat(
                    IDS_CANT_APPEND_FILE,
                    szLogFileName );

                break;
            }

            //
            // Dump current information
            //

            if( ! VrfDumpStateToFile ( file ) ) 
            {
                //
                // Insufficient disk space ?
                //

                VrfTPrintfResourceFormat(
                    IDS_CANT_WRITE_FILE,
                    szLogFileName );
            }

            fflush( file );

            VrfFTPrintf(
                file,
                TEXT("\n\n") );

            //
            // Close the file
            //

            fclose( file );

            //
            // Sleep
            //

            Sleep( dwLogMillisec );
        }
    }

Done:
    return bStartLogging;
}

/////////////////////////////////////////////////////////////////////////////
//
// See if we need to dump the statistics to the console
//

BOOL CmdLineExecuteIfQuery( INT argc,
                            TCHAR *argv[] )
{
    BOOL bFoundCmdLineSwitch;
    TCHAR szCmdLineSwitch[ 64 ];

    bFoundCmdLineSwitch = FALSE;

    VERIFY( VrfLoadString( IDS_QUERY_CMDLINE_SWITCH,
                           szCmdLineSwitch,
                           ARRAY_LENGTH( szCmdLineSwitch ) ) );

    //
    // Search for our switch in the command line
    //

    if( argc == 2 && _tcsicmp( argv[1], szCmdLineSwitch) == 0)
    {
        bFoundCmdLineSwitch = TRUE;

        VrfDumpStateToFile( stdout );
    }

    return bFoundCmdLineSwitch;
}

/////////////////////////////////////////////////////////////////////////////
//
// See if we need to dump the statistics to the console
//

BOOL CmdLineExecuteIfQuerySettings( INT argc,
                                    TCHAR *argv[] )
{
    BOOL bFoundCmdLineSwitch;
    TCHAR szCmdLineSwitch[ 64 ];

    bFoundCmdLineSwitch = FALSE;

    VERIFY( VrfLoadString( IDS_QUERYSETT_CMDLINE_SWITCH,
                           szCmdLineSwitch,
                           ARRAY_LENGTH( szCmdLineSwitch ) ) );

    //
    // Search for our switch in the command line
    //

    if( argc == 2 && _tcsicmp( argv[1], szCmdLineSwitch) == 0)
    {
        bFoundCmdLineSwitch = TRUE;

        VrfDumpRegistrySettingsToConsole();
    }

    return bFoundCmdLineSwitch;
}

/////////////////////////////////////////////////////////////////////////////
//
// Get the new flags, drivers and volatile 
// if they have been specified
//

VOID CmdLineGetFlagsDriversVolatile( INT argc,
                                     TCHAR *argv[],
                                     DWORD &dwNewFlags,
                                     BOOL &bHaveNewFlags,
                                     CStringArray &astrNewDrivers,
                                     BOOL &bHaveNewDrivers,
                                     BOOL &bHaveVolatile,
                                     BOOL &bVolatileAddDriver )
{
    INT nCrtArg;
    NTSTATUS Status;
    UNICODE_STRING ustrFlags;
    TCHAR szFlagsCmdLineOption[ 64 ];
    TCHAR szAllCmdLineOption[ 64 ];
    TCHAR szVolatileCmdLineOption[ 64 ];
    TCHAR szDriversCmdLineOption[ 64 ];
    TCHAR szAddDriversCmdLineOption[ 64 ];
    TCHAR szRemoveDriversCmdLineOption[ 64 ];
    TCHAR szStandardCmdLineOption[ 64 ];
#ifndef UNICODE
    //
    // ANSI
    //

    INT nNameLength;
    LPWSTR szUnicodeName;
#endif //#ifndef UNICODE
 
    astrNewDrivers.RemoveAll();

    bHaveNewFlags = FALSE;
    bHaveNewDrivers = FALSE;
    bHaveVolatile = FALSE;

    //
    // Load the switches from the resources
    //

    VERIFY( VrfLoadString( IDS_FLAGS_CMDLINE_SWITCH,
                           szFlagsCmdLineOption,
                           ARRAY_LENGTH( szFlagsCmdLineOption ) ) );

    VERIFY( VrfLoadString( IDS_ALL_CMDLINE_SWITCH,
                           szAllCmdLineOption,
                           ARRAY_LENGTH( szAllCmdLineOption ) ) );

    VERIFY( VrfLoadString( IDS_DONTREBOOT_CMDLINE_SWITCH,
                           szVolatileCmdLineOption,
                           ARRAY_LENGTH( szVolatileCmdLineOption ) ) );

    VERIFY( VrfLoadString( IDS_DRIVER_CMDLINE_SWITCH,
                           szDriversCmdLineOption,
                           ARRAY_LENGTH( szDriversCmdLineOption ) ) );

    VERIFY( VrfLoadString( IDS_ADDDRIVER_CMDLINE_SWITCH,
                           szAddDriversCmdLineOption,
                           ARRAY_LENGTH( szAddDriversCmdLineOption ) ) );

    VERIFY( VrfLoadString( IDS_REMOVEDRIVER_CMDLINE_SWITCH,
                           szRemoveDriversCmdLineOption,
                           ARRAY_LENGTH( szRemoveDriversCmdLineOption ) ) );

    VERIFY( VrfLoadString( IDS_STANDARD_CMDLINE_SWITCH,
                           szStandardCmdLineOption,
                           ARRAY_LENGTH( szStandardCmdLineOption ) ) );
    //
    // Parse all the cmd line arguments, looking for ours
    //

    for( nCrtArg = 1; nCrtArg < argc; nCrtArg += 1 )
    {
        if( _tcsicmp( argv[ nCrtArg ], szFlagsCmdLineOption) == 0 )
        {
            if( nCrtArg < argc - 1 )
            {
                //
                // Not the last cmd line arg - look for the flags next
                //
                
#ifdef UNICODE
                //
                // UNICODE
                //
                
                RtlInitUnicodeString( &ustrFlags,
                                      argv[ nCrtArg + 1 ] );

#else
                //
                // ANSI
                //

                nNameLength = strlen( argv[ nCrtArg + 1 ] );

                szUnicodeName = new WCHAR[ nNameLength + 1 ];

                if( NULL == szUnicodeName )
                {
                    VrfErrorResourceFormat( IDS_NOT_ENOUGH_MEMORY );

                    goto DoneWithFlags;
                }

                MultiByteToWideChar( CP_ACP, 
                                     0, 
                                     argv[ nCrtArg + 1 ], 
                                     -1, 
                                     szUnicodeName, 
                                     nNameLength + 1 );

                RtlInitUnicodeString( &ustrFlags,
                                      szUnicodeName );
#endif 
                Status = RtlUnicodeStringToInteger( &ustrFlags,
                                                    0,
                                                    &dwNewFlags );

                if( NT_SUCCESS( Status ) )
                {
                    bHaveNewFlags = TRUE;
                }

#ifndef UNICODE
                //
                // ANSI
                //

                ASSERT( NULL != szUnicodeName );

                delete [] szUnicodeName;
                
                szUnicodeName = NULL;

DoneWithFlags:
                NOTHING;
#endif 
            }
        }
        else if( _tcsicmp( argv[ nCrtArg ], szAllCmdLineOption) == 0 )
        {
            //
            // Verify all drivers
            //

            bHaveVolatile = FALSE;

            astrNewDrivers.Add( _T( '*' ) );

            bHaveNewDrivers = TRUE;
        }
        else if( _tcsicmp( argv[ nCrtArg ], szStandardCmdLineOption) == 0 )
        {
            //
            // Standard verifier flags
            //

            dwNewFlags = VrfGetStandardFlags();

            bHaveNewFlags = TRUE;
        }
        else if( _tcsicmp( argv[ nCrtArg ], szVolatileCmdLineOption) == 0 )
        {
            //
            // Volatile
            //

            bHaveVolatile = TRUE;
        }
        else if( _tcsicmp( argv[ nCrtArg ], szDriversCmdLineOption) == 0 )
        {
            //
            // /Driver
            //

            bHaveVolatile = FALSE;

            CmdLineGetDriversFromArgv( argc,
                                       argv,
                                       nCrtArg + 1,
                                       astrNewDrivers,
                                       bHaveNewDrivers );

            //
            // All done - all the rest of argumentshave been driver names
            //

            break;
        }
        else if( bHaveVolatile && _tcsicmp( argv[ nCrtArg ], szAddDriversCmdLineOption) == 0 )
        {
            //
            // /adddriver
            //

            bVolatileAddDriver = TRUE;

            CmdLineGetDriversFromArgv( argc,
                                       argv,
                                       nCrtArg + 1,
                                       astrNewDrivers,
                                       bHaveNewDrivers );

            //
            // All done - all the rest of argumentshave been driver names
            //

            break;
        }
        else if( bHaveVolatile && _tcsicmp( argv[ nCrtArg ], szRemoveDriversCmdLineOption) == 0 )
        {
            //
            // /removedriver
            //

            bVolatileAddDriver = FALSE;

            CmdLineGetDriversFromArgv( argc,
                                       argv,
                                       nCrtArg + 1,
                                       astrNewDrivers,
                                       bHaveNewDrivers );

            //
            // All done - all the rest of arguments have been driver names
            //

            break;
        }
    }

    //
    // If we have new drivers look if they are miniports
    //

    if( bHaveNewDrivers )
    {
        VrfAddMiniports( astrNewDrivers );
    }
}

/////////////////////////////////////////////////////////////////////////////
//
// Everything that follows after /driver, /adddriver, /removedriver
// should be driver names. Extract these from the command line
//

VOID CmdLineGetDriversFromArgv(  INT argc,
                                 TCHAR *argv[],
                                 INT nFirstDriverArgIndex,
                                 CStringArray &astrNewDrivers,
                                 BOOL &bHaveNewDrivers )
{
    INT nDriverArg;

    bHaveNewDrivers = FALSE;
    astrNewDrivers.RemoveAll();

    //
    // Everything in the command line from here on should be driver names
    //

    for( nDriverArg = nFirstDriverArgIndex; nDriverArg < argc; nDriverArg += 1 )
    {
        astrNewDrivers.Add( argv[ nDriverArg ] );
    }

    bHaveNewDrivers = ( astrNewDrivers.GetSize() > 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\dsetpage.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: DSetPage.cpp
// author: DMihai
// created: 11/1/00
//
// Description:
//

#include "stdafx.h"
#include "verifier.h"

#include "DSetPage.h"
#include "VSheet.h"
#include "VrfUtil.h"
#include "VGlobal.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Change this if you add/remove/change order 
// of radio buttons on this page
//

#define FIRST_RADIO_BUTTON_ID   IDC_DRVSET_NOTSIGNED_RADIO

//
// Help IDs
//

static DWORD MyHelpIds[] =
{
    IDC_DRVSET_NOTSIGNED_RADIO,     IDH_DV_SelectUnsigned,
    IDC_DRVSET_OLDVER_RADIO,        IDH_DV_SelectOlderversions,
    IDC_DRVSET_ALLDRV_RADIO,        IDH_DV_SelectAll,
    IDC_DRVSET_NAMESLIST_RADIO,     IDH_DV_SelectFromList,
    0,                              0
};

/////////////////////////////////////////////////////////////////////////////
// CDriverSetPage property page

IMPLEMENT_DYNCREATE(CDriverSetPage, CVerifierPropertyPage)

CDriverSetPage::CDriverSetPage() 
    : CVerifierPropertyPage( CDriverSetPage::IDD )
{
    //{{AFX_DATA_INIT(CDriverSetPage)
	m_nCrtRadio = -1;
	//}}AFX_DATA_INIT
}

CDriverSetPage::~CDriverSetPage()
{
}

void CDriverSetPage::DoDataExchange(CDataExchange* pDX)
{
	CVerifierPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDriverSetPage)
	DDX_Control(pDX, IDC_DRVSET_NEXT_DESCR_STATIC, m_NextDescription);
	DDX_Radio(pDX, IDC_DRVSET_NOTSIGNED_RADIO, m_nCrtRadio);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDriverSetPage, CVerifierPropertyPage)
	//{{AFX_MSG_MAP(CDriverSetPage)
	ON_BN_CLICKED(IDC_DRVSET_ALLDRV_RADIO, OnAlldrvRadio)
	ON_BN_CLICKED(IDC_DRVSET_NAMESLIST_RADIO, OnNameslistRadio)
	ON_BN_CLICKED(IDC_DRVSET_NOTSIGNED_RADIO, OnNotsignedRadio)
	ON_BN_CLICKED(IDC_DRVSET_OLDVER_RADIO, OnOldverRadio)
    ON_WM_CONTEXTMENU()
    ON_MESSAGE( WM_HELP, OnHelp )
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CDriverSetPage message handlers

/////////////////////////////////////////////////////////////////////////////
LRESULT CDriverSetPage::OnWizardBack() 
{
    //
    // Kill a possible active worker thread
    //

    g_SlowProgressDlg.KillWorkerThread();
	
	return CVerifierPropertyPage::OnWizardBack();
}

/////////////////////////////////////////////////////////////////////////////
LRESULT CDriverSetPage::OnWizardNext() 
{
    LRESULT lNextPageId;
    BOOL bHaveDriversToVerify;

    //
    // Kill a possible active worker thread
    //

    g_SlowProgressDlg.KillWorkerThread();

    //
    // Let's assume we cannot continue
    //

    lNextPageId = -1;

    if( UpdateData() == TRUE )
    {
        //
        // Look if we already have loaded the list of drivers
        // with version information, etc. and if we need it
        //

        ASSERT( IDC_DRVSET_ALLDRV_RADIO - FIRST_RADIO_BUTTON_ID != m_nCrtRadio );

        if( TRUE != g_NewVerifierSettings.m_DriversSet.m_bDriverDataInitialized )
        {
            if( NULL == g_SlowProgressDlg.m_hWnd )
            {
                //
                // This is the first time we are showing the 
                // "slow progress" dialog so create it first
                //

                g_SlowProgressDlg.Create( CSlowProgressDlg::IDD, AfxGetMainWnd() );
            }

            //
            // Show the dialog
            //

            g_SlowProgressDlg.ShowWindow( SW_SHOW );

            //
            // Start the worker thread to do the work in background
            // while the initial thread updates the GUI. If the thread ends
            // successfully it will press our "Next" button at the end, after setting
            // g_NewVerifierSettings.m_DriversSet.m_bDriverDataInitialized to TRUE
            //

            g_SlowProgressDlg.StartWorkerThread( CSlowProgressDlg::LoadDriverDataWorkerThread,
                                                 IDS_LOADING_DRIVER_INFORMATION );

            //
            // Wait for the "next" button again
            //

            goto Done;
        }

        //
        // We have already loaded information (name, version, etc.) about 
        // the currently loaded drivers if have gotten to this point
        //

        //
        // Select the set of drivers corresponding to user's selection
        //

        switch( m_nCrtRadio )
        {
        case IDC_DRVSET_NAMESLIST_RADIO - FIRST_RADIO_BUTTON_ID:
            
            //
            // Custom list of drivers
            //

            g_NewVerifierSettings.m_DriversSet.m_DriverSetType = CDriversSet::DriversSetCustom;

            lNextPageId = IDD_SELECT_DRIVERS_PAGE;
            
            break;

        case IDC_DRVSET_OLDVER_RADIO - FIRST_RADIO_BUTTON_ID:
            //
            // Drivers compiled for old versions of Windows
            //

            //
            // The list of drivers is ready because we waited the 
            // worker thread to finish up execution - go to the next page
            //

            g_NewVerifierSettings.m_DriversSet.m_DriverSetType = CDriversSet::DriversSetOldOs;
            
            bHaveDriversToVerify = g_NewVerifierSettings.m_DriversSet.ShouldVerifySomeDrivers();

            if( TRUE == bHaveDriversToVerify )
            {
                //
                // We have at least one old driver to verify
                //

                lNextPageId = IDD_CONFIRM_DRIVERS_PAGE;

                //
                // Set the title of the driver list confirmation page
                //

                ASSERT_VALID( m_pParentSheet );

                m_pParentSheet->SetContextStrings( IDS_OLD_DRIVERS_LIST );
            }
            else
            {
                //
                // We don't have any old drivers currently installed
                //

                VrfMesssageFromResource( IDS_NO_OLD_DRIVERS_FOUND );
            }

            break;

        case IDC_DRVSET_NOTSIGNED_RADIO - FIRST_RADIO_BUTTON_ID:
            //
            // Not signed drivers
            //

            if( FALSE == g_NewVerifierSettings.m_DriversSet.m_bUnsignedDriverDataInitialized ) 
            {
                //
                // We should have displayed the "slow progress" dialog 
                // at least once before (when we have loaded the list of drivers)
                // so we don't even try to create the modeless dialog.
                //

                ASSERT( NULL != g_SlowProgressDlg.m_hWnd );
                
                //
                // Show the dialog though
                //

                g_SlowProgressDlg.ShowWindow( SW_SHOW );
                
                //
                // Start the worker thread to do the work in background
                // while the initial thread updates the GUI. If the thread ends
                // successfully it will press our "Next" button at the end, after setting
                // g_NewVerifierSettings.m_DriversSet.m_bDriverDataInitialized to TRUE
                //

                g_SlowProgressDlg.StartWorkerThread( CSlowProgressDlg::SearchUnsignedDriversWorkerThread,
                                                     IDS_SEARCHING_FOR_UNSIGNED_DRIVERS );

                //
                // Wait for the "next" button again
                //

                goto Done;
            }
            else
            {
                g_NewVerifierSettings.m_DriversSet.m_DriverSetType = CDriversSet::DriversSetNotSigned;

                bHaveDriversToVerify = g_NewVerifierSettings.m_DriversSet.ShouldVerifySomeDrivers();

                if( TRUE == bHaveDriversToVerify )
                {
                    //
                    // The list of drivers is ready - go to the next page
                    //

                    lNextPageId = IDD_CONFIRM_DRIVERS_PAGE;

                    //
                    // Set the title of the driver list confirmation page
                    //

                    ASSERT_VALID( m_pParentSheet );

                    m_pParentSheet->SetContextStrings( IDS_UNSIGNED_DRIVERS_LIST );
                }
                else
                {
                    //
                    // We don't have any unsigned drivers currently installed
                    //

                    VrfMesssageFromResource( IDS_NO_UNSIGNED_DRIVERS_FOUND );
                }
            }
            break;

        case CDriversSet::DriversSetAllDrivers:
            
            //
            // We should have only a "Finish" button
            // if "all drivers" is selected, not a "Next" button. 
            // This is a bug!
            //

        default:
            ASSERT( FALSE );
            break;
        }
    }

    GoingToNextPageNotify( lNextPageId );

Done:
    return lNextPageId;
}


/////////////////////////////////////////////////////////////////////////////
BOOL CDriverSetPage::OnWizardFinish() 
{
    BOOL bFinish;

    bFinish = FALSE;

    if( UpdateData( TRUE ) == TRUE )
    {
        //
        // If the user has pressed the "Finish" button that
        // would mean that she selected "all drivers" to be verified
        //

        ASSERT( IDC_DRVSET_ALLDRV_RADIO - FIRST_RADIO_BUTTON_ID == m_nCrtRadio );

        g_NewVerifierSettings.m_DriversSet.m_DriverSetType = CDriversSet::DriversSetAllDrivers;
        
        bFinish = g_NewVerifierSettings.SaveToRegistry();
    }
	
	CVerifierPropertyPage::OnWizardFinish();

    return bFinish;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CDriverSetPage::OnSetActive() 
{
    if( IDC_DRVSET_ALLDRV_RADIO - FIRST_RADIO_BUTTON_ID == m_nCrtRadio )
    {
        m_pParentSheet->SetWizardButtons(   PSWIZB_BACK | PSWIZB_FINISH );
    }
    else
    {
        m_pParentSheet->SetWizardButtons(   PSWIZB_BACK | PSWIZB_NEXT );
    }
	
	return CVerifierPropertyPage::OnSetActive();
}

/////////////////////////////////////////////////////////////////////////////
BOOL CDriverSetPage::OnInitDialog() 
{
    //
    // Don't try to reconstruct the current data from the registry
    // to the GUI because it's too hard. Always start with the 
    // default radio button: unsigned drivers
    //

    m_nCrtRadio = IDC_DRVSET_NOTSIGNED_RADIO - FIRST_RADIO_BUTTON_ID;
	
	CVerifierPropertyPage::OnInitDialog();

    VrfSetWindowText( m_NextDescription, IDS_DRVSET_PAGE_NEXT_DESCR_UNSIGNED );

    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////////////
void CDriverSetPage::OnAlldrvRadio() 
{
    ASSERT_VALID( m_pParentSheet );

    m_pParentSheet->SetWizardButtons(   PSWIZB_BACK | PSWIZB_FINISH );

    VrfSetWindowText( m_NextDescription, IDS_DRVSET_PAGE_NEXT_DESCR_ALL );
}

void CDriverSetPage::OnNameslistRadio() 
{
    ASSERT_VALID( m_pParentSheet );
    
    m_pParentSheet->SetWizardButtons(   PSWIZB_BACK | PSWIZB_NEXT );

    VrfSetWindowText( m_NextDescription, IDS_DRVSET_PAGE_NEXT_DESCR_NAMELIST );
}

void CDriverSetPage::OnNotsignedRadio() 
{
    ASSERT_VALID( m_pParentSheet );
    
    m_pParentSheet->SetWizardButtons(   PSWIZB_BACK | PSWIZB_NEXT );

    VrfSetWindowText( m_NextDescription, IDS_DRVSET_PAGE_NEXT_DESCR_UNSIGNED );
}

void CDriverSetPage::OnOldverRadio() 
{
    ASSERT_VALID( m_pParentSheet );

    m_pParentSheet->SetWizardButtons(   PSWIZB_BACK | PSWIZB_NEXT );

    VrfSetWindowText( m_NextDescription, IDS_DRVSET_PAGE_NEXT_DESCR_OLD );
}

/////////////////////////////////////////////////////////////
void CDriverSetPage::OnCancel() 
{
    g_SlowProgressDlg.KillWorkerThread();
	
	CVerifierPropertyPage::OnCancel();
}

/////////////////////////////////////////////////////////////
LONG CDriverSetPage::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp( 
        (HWND) lpHelpInfo->hItemHandle,
        g_szVerifierHelpFile,
        HELP_WM_HELP,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}

/////////////////////////////////////////////////////////////////////////////
void CDriverSetPage::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    ::WinHelp( 
        pWnd->m_hWnd,
        g_szVerifierHelpFile,
        HELP_CONTEXTMENU,
        (DWORD_PTR) MyHelpIds );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\dsetpage.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: DSetPage.h
// author: DMihai
// created: 11/1/00
//
// Description:
//  

#if !defined(AFX_DSETPAGE_H__FCB7F146_7EE5_4A08_B7B4_ECE172A70098__INCLUDED_)
#define AFX_DSETPAGE_H__FCB7F146_7EE5_4A08_B7B4_ECE172A70098__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DSetPage.h : header file
//

#include "vsetting.h"
#include "VerfPage.h"

//
// Forward declarations
//

class CVerifierPropSheet;

/////////////////////////////////////////////////////////////////////////////
// CDriverSetPage dialog

class CDriverSetPage : public CVerifierPropertyPage
{
	DECLARE_DYNCREATE(CDriverSetPage)

public:
    //
    // Construction/destruction
    //

	CDriverSetPage();
	~CDriverSetPage();

    //
    // Methods
    //

    VOID SetParentSheet( CVerifierPropSheet *pParentSheet )
    {
        m_pParentSheet = pParentSheet;
        ASSERT( m_pParentSheet != NULL );
    }

protected:
    //
    // Dialog Data
    //

    CVerifierPropSheet      *m_pParentSheet;

    //{{AFX_DATA(CDriverSetPage)
	enum { IDD = IDD_DRVSET_PAGE };
	CStatic	m_NextDescription;
	int		m_nCrtRadio;
	//}}AFX_DATA

    //
    // Overrides
    //

    //
    // All the property pages derived from this class should 
    // provide these methods.
    //

    virtual ULONG GetDialogId() const { return IDD; }

    //
    // ClassWizard generated virtual function overrides
    //

    //{{AFX_VIRTUAL(CDriverSetPage)
    public:
    virtual LRESULT OnWizardNext();
    virtual BOOL OnWizardFinish();
    virtual BOOL OnSetActive();
    virtual void OnCancel();
    virtual LRESULT OnWizardBack();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
    // Generated message map functions
    //{{AFX_MSG(CDriverSetPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnAlldrvRadio();
    afx_msg void OnNameslistRadio();
    afx_msg void OnNotsignedRadio();
    afx_msg void OnOldverRadio();
    afx_msg LONG OnHelp( WPARAM wParam, LPARAM lParam );
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DSETPAGE_H__FCB7F146_7EE5_4A08_B7B4_ECE172A70098__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\flpage.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: FLPage.cpp
// author: DMihai
// created: 11/1/00
//
// Description:
//

#include "stdafx.h"
#include "verifier.h"

#include "FLPage.h"
#include "VrfUtil.h"
#include "VGlobal.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Help IDs
//

static DWORD MyHelpIds[] =
{
    IDC_FLSETT_LIST,                IDH_DV_SettingsEnabled_TestType_FullList,
    0,                              0
};

/////////////////////////////////////////////////////////////////////////////
// CFullListSettingsPage property page

IMPLEMENT_DYNCREATE(CFullListSettingsPage, CVerifierPropertyPage)

CFullListSettingsPage::CFullListSettingsPage() 
    : CVerifierPropertyPage(CFullListSettingsPage::IDD)
{
	//{{AFX_DATA_INIT(CFullListSettingsPage)
	//}}AFX_DATA_INIT

    m_nSortColumnIndex = 1;
    m_bAscendSortSelected = FALSE;
    m_bAscendSortName = TRUE;

    m_bIoVerif = FALSE;
	m_bIrqLevel = FALSE;
	m_bLowRes = FALSE;
	m_bPoolTrack = FALSE;
	m_bSPool = FALSE;
	m_bDeadlock = FALSE;
	m_bDMA = FALSE;
	m_bEnhIoVerif = FALSE;
}

CFullListSettingsPage::~CFullListSettingsPage()
{
}

void CFullListSettingsPage::DoDataExchange(CDataExchange* pDX)
{

	CVerifierPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFullListSettingsPage)
	DDX_Control(pDX, IDC_FLSETT_LIST, m_SettingsList);
	DDX_Control(pDX, IDC_FLSETT_NEXT_DESCR_STATIC, m_NextDescription);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFullListSettingsPage, CVerifierPropertyPage)
	//{{AFX_MSG_MAP(CFullListSettingsPage)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_FLSETT_LIST, OnColumnclickFlsettList)
    ON_WM_CONTEXTMENU()
    ON_MESSAGE( WM_HELP, OnHelp )
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
VOID CFullListSettingsPage::SetupListHeader()
{
    CString strTitle;
    CRect rectWnd;
    LVCOLUMN lvColumn;

    //
    // The list's rectangle 
    //

    m_SettingsList.GetClientRect( &rectWnd );

    ZeroMemory( &lvColumn, 
               sizeof( lvColumn ) );

    lvColumn.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;

    //
    // Column 0
    //

    VERIFY( strTitle.LoadString( IDS_ENABLED_QUESTION ) );

    lvColumn.iSubItem = 0;
    lvColumn.pszText = strTitle.GetBuffer( strTitle.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.12 );
    VERIFY( m_SettingsList.InsertColumn( 0, &lvColumn ) != -1 );
    strTitle.ReleaseBuffer();

    //
    // Column 1
    //

    VERIFY( strTitle.LoadString( IDS_SETTING ) );

    lvColumn.iSubItem = 1;
    lvColumn.pszText = strTitle.GetBuffer( strTitle.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.87 );
    VERIFY( m_SettingsList.InsertColumn( 1, &lvColumn ) != -1 );
    strTitle.ReleaseBuffer();
}

/////////////////////////////////////////////////////////////////////////////
VOID CFullListSettingsPage::FillTheList()
{
    //
    // N.B.
    //
    // If you change the first parameter (verifier bit index) 
    // then you need to change GetNewVerifierFlags as well
    //

    AddListItem( 0, IDS_SPECIAL_POOL );
    AddListItem( 1, IDS_POOL_TRACKING );
    AddListItem( 2, IDS_FORCE_IRQL_CHECKING );
    AddListItem( 3, IDS_IO_VERIFICATION );
    AddListItem( 4, IDS_ENH_IO_VERIFICATION );
    AddListItem( 5, IDS_DEADLOCK_DETECTION );
    AddListItem( 6, IDS_DMA_CHECHKING );
    AddListItem( 7, IDS_LOW_RESOURCE_SIMULATION );
}

/////////////////////////////////////////////////////////////////////////////
BOOL CFullListSettingsPage::GetNewVerifierFlags()
{
    //
    // N.B.
    //
    // If you change this order then you need to
    // change FillTheList as well
    //

    m_bSPool        = GetCheckFromItemData( 0 );
    m_bPoolTrack    = GetCheckFromItemData( 1 );
    m_bIrqLevel     = GetCheckFromItemData( 2 );
    m_bIoVerif      = GetCheckFromItemData( 3 );
    m_bEnhIoVerif   = GetCheckFromItemData( 4 );
    m_bDeadlock     = GetCheckFromItemData( 5 );
    m_bDMA          = GetCheckFromItemData( 6 );
    m_bLowRes       = GetCheckFromItemData( 7 );

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CFullListSettingsPage::GetCheckFromItemData( INT nItemData )
{
    BOOL bChecked = FALSE;
    INT nItemIndex;
    LVFINDINFO FindInfo;

    ZeroMemory( &FindInfo, sizeof( FindInfo ) );
    FindInfo.flags = LVFI_PARAM;
    FindInfo.lParam = nItemData;

    nItemIndex = m_SettingsList.FindItem( &FindInfo );

    if( nItemIndex >= 0 )
    {
        bChecked = m_SettingsList.GetCheck( nItemIndex );
    }

    return bChecked;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CFullListSettingsPage::GetBitNameFromItemData( LPARAM lParam,
                                                    TCHAR *szName,
                                                    ULONG uNameBufferLength )
{
    BOOL bSuccess = FALSE;
    INT nItemIndex;
    LVFINDINFO FindInfo;
    LVITEM lvItem;

    ZeroMemory( &FindInfo, sizeof( FindInfo ) );
    FindInfo.flags = LVFI_PARAM;
    FindInfo.lParam = lParam;

    nItemIndex = m_SettingsList.FindItem( &FindInfo );

    if( nItemIndex >= 0 )
    {
        //
        // Found it
        //

        ZeroMemory( &lvItem, sizeof( lvItem ) );

        lvItem.mask = LVIF_TEXT;
        lvItem.iItem = nItemIndex;
        lvItem.iSubItem = 1;
        lvItem.pszText = szName;
        lvItem.cchTextMax = uNameBufferLength;

        bSuccess = m_SettingsList.GetItem( &lvItem );
        
        if( FALSE == bSuccess )
        {
            //
            // Could not get the current item's attributes?!?
            //

            ASSERT( FALSE );
        }
    }

    return bSuccess;
}


/////////////////////////////////////////////////////////////////////////////
VOID CFullListSettingsPage::AddListItem( INT nItemData, 
                                         ULONG uIdResourceString )
{
    INT nActualIndex;
    LVITEM lvItem;
    CString strName;

    ZeroMemory( &lvItem, sizeof( lvItem ) );

    //
    // LVITEM's member pszText is not a const pointer 
    // so we need to GetBuffer here :-(
    //

    //
    // Sub-item 0 - enabled/diabled - empty text and a checkbox
    //

    lvItem.pszText = g_szVoidText;
    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.lParam = nItemData;
    lvItem.iItem = m_SettingsList.GetItemCount();

    nActualIndex = m_SettingsList.InsertItem( &lvItem );

    if( nActualIndex < 0 )
    {
        //
        // Could not add an item in the list - give up
        //

        goto Done;
    }

    m_SettingsList.SetCheck( nActualIndex, FALSE );

    //
    // Sub-item 1 - feature name
    //

    VERIFY( strName.LoadString( uIdResourceString ) );

    lvItem.pszText = strName.GetBuffer( strName.GetLength() + 1 );
    
    if( NULL == lvItem.pszText )
    {
        goto Done;
    }

    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = nActualIndex;
    lvItem.iSubItem = 1;
    
    VERIFY( m_SettingsList.SetItem( &lvItem ) );

    strName.ReleaseBuffer();

Done:
    //
    // All done
    //

    NOTHING;
}

/////////////////////////////////////////////////////////////
VOID CFullListSettingsPage::SortTheList()
{
    if( 0 != m_nSortColumnIndex )
    {
        //
        // Sort by settings name
        //

        m_SettingsList.SortItems( StringCmpFunc, (LPARAM)this );
    }
    else
    {
        //
        // Sort by selected status
        //

        m_SettingsList.SortItems( CheckedStatusCmpFunc, (LPARAM)this );
    }
}

/////////////////////////////////////////////////////////////
int CALLBACK CFullListSettingsPage::StringCmpFunc( LPARAM lParam1,
                                                   LPARAM lParam2,
                                                   LPARAM lParamSort)
{
    int nCmpRez = 0;
    BOOL bSuccess;
    TCHAR szBitName1[ _MAX_PATH ];
    TCHAR szBitName2[ _MAX_PATH ];

    CFullListSettingsPage *pThis = (CFullListSettingsPage *)lParamSort;
    ASSERT_VALID( pThis );

    ASSERT( 0 != pThis->m_nSortColumnIndex );

    //
    // Get the first name
    //

    bSuccess = pThis->GetBitNameFromItemData( lParam1, 
                                              szBitName1,
                                              ARRAY_LENGTH( szBitName1 ) );

    if( FALSE == bSuccess )
    {
        goto Done;
    }

    //
    // Get the second name
    //

    bSuccess = pThis->GetBitNameFromItemData( lParam2, 
                                              szBitName2,
                                              ARRAY_LENGTH( szBitName2 ) );

    if( FALSE == bSuccess )
    {
        goto Done;
    }

    //
    // Compare the names
    //

    nCmpRez = _tcsicmp( szBitName1, szBitName2 );
    
    if( FALSE != pThis->m_bAscendSortName )
    {
        nCmpRez *= -1;
    }

Done:

    return nCmpRez;

}

/////////////////////////////////////////////////////////////
int CALLBACK CFullListSettingsPage::CheckedStatusCmpFunc( LPARAM lParam1,
                                                       LPARAM lParam2,
                                                       LPARAM lParamSort)
{
    int nCmpRez = 0;
    INT nItemIndex;
    BOOL bVerified1;
    BOOL bVerified2;
    LVFINDINFO FindInfo;

    CFullListSettingsPage *pThis = (CFullListSettingsPage *)lParamSort;
    ASSERT_VALID( pThis );

    ASSERT( 0 == pThis->m_nSortColumnIndex );

    //
    // Find the first item
    //

    ZeroMemory( &FindInfo, sizeof( FindInfo ) );
    FindInfo.flags = LVFI_PARAM;
    FindInfo.lParam = lParam1;

    nItemIndex = pThis->m_SettingsList.FindItem( &FindInfo );

    if( nItemIndex < 0 )
    {
        ASSERT( FALSE );

        goto Done;
    }

    bVerified1 = pThis->m_SettingsList.GetCheck( nItemIndex );

    //
    // Find the second item
    //

    FindInfo.flags = LVFI_PARAM;
    FindInfo.lParam = lParam2;

    nItemIndex = pThis->m_SettingsList.FindItem( &FindInfo );

    if( nItemIndex < 0 )
    {
        ASSERT( FALSE );

        goto Done;
    }

    bVerified2 = pThis->m_SettingsList.GetCheck( nItemIndex );

    //
    // Compare them
    //
    
    if( bVerified1 != bVerified2 )
    {
        if( FALSE != bVerified1 )
        {
            nCmpRez = 1;
        }
        else
        {
            nCmpRez = -1;
        }

        if( FALSE != pThis->m_bAscendSortSelected )
        {
            nCmpRez *= -1;
        }
    }

Done:

    return nCmpRez;

}

/////////////////////////////////////////////////////////////////////////////
// CFullListSettingsPage message handlers

LRESULT CFullListSettingsPage::OnWizardNext() 
{
    LRESULT lNextPageId;

    //
    // Let's assume we cannot continue
    //

    lNextPageId = -1;

    if( GetNewVerifierFlags() == TRUE )
    {
        if( FALSE == m_bIoVerif     &&
            FALSE == m_bIrqLevel    &&
            FALSE == m_bLowRes      &&
            FALSE == m_bPoolTrack   &&
            FALSE == m_bSPool       && 
            FALSE == m_bDeadlock    &&
            FALSE == m_bDMA         &&
            FALSE == m_bEnhIoVerif )
        {
            //
            // No tests are currently selected - we cannot continue
            //

            VrfErrorResourceFormat( IDS_NO_TESTS_SELECTED );
        }
        else
        {
            //
            // Set our data according to the GUI
            //

            ASSERT( CSettingsBits::SettingsTypeCustom == 
                    g_NewVerifierSettings.m_SettingsBits.m_SettingsType );

            g_NewVerifierSettings.m_SettingsBits.m_bSpecialPoolEnabled    = m_bSPool;
            g_NewVerifierSettings.m_SettingsBits.m_bForceIrqlEnabled      = m_bIrqLevel;
            g_NewVerifierSettings.m_SettingsBits.m_bLowResEnabled         = m_bLowRes;
            g_NewVerifierSettings.m_SettingsBits.m_bPoolTrackingEnabled   = m_bPoolTrack;
            g_NewVerifierSettings.m_SettingsBits.m_bIoEnabled             = m_bIoVerif;
            g_NewVerifierSettings.m_SettingsBits.m_bDeadlockDetectEnabled = m_bDeadlock;
            g_NewVerifierSettings.m_SettingsBits.m_bDMAVerifEnabled       = m_bDMA;
            g_NewVerifierSettings.m_SettingsBits.m_bEnhIoEnabled          = m_bEnhIoVerif;

            //
            // Go to the next page
            //

            lNextPageId = IDD_DRVSET_PAGE;
        }
    }
	
    GoingToNextPageNotify( lNextPageId );

    return lNextPageId;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CFullListSettingsPage::OnInitDialog() 
{
	CVerifierPropertyPage::OnInitDialog();

    //
    // setup the list
    //

    m_SettingsList.SetExtendedStyle( 
        LVS_EX_FULLROWSELECT | LVS_EX_CHECKBOXES | m_SettingsList.GetExtendedStyle() );

    SetupListHeader();
    FillTheList();
	
    VrfSetWindowText( m_NextDescription, IDS_FLSETT_PAGE_NEXT_DESCR );
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////////////
void CFullListSettingsPage::OnColumnclickFlsettList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	
    if( 0 != pNMListView->iSubItem )
    {
        //
        // Clicked on the name column
        //

        if( m_nSortColumnIndex == pNMListView->iSubItem )
        {
            //
            // Change the current ascend/descend order for this column
            //

            m_bAscendSortName = !m_bAscendSortName;
        }
    }
    else
    {
        //
        // Clicked on the selected status column
        //

        if( m_nSortColumnIndex == pNMListView->iSubItem )
        {
            //
            // Change the current ascend/descend order for this column
            //

            m_bAscendSortSelected = !m_bAscendSortSelected;
        }
    }

    m_nSortColumnIndex = pNMListView->iSubItem;

    SortTheList();

    *pResult = 0;
}

/////////////////////////////////////////////////////////////
LONG CFullListSettingsPage::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp( 
        (HWND) lpHelpInfo->hItemHandle,
        g_szVerifierHelpFile,
        HELP_WM_HELP,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}

/////////////////////////////////////////////////////////////////////////////
void CFullListSettingsPage::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    ::WinHelp( 
        pWnd->m_hWnd,
        g_szVerifierHelpFile,
        HELP_CONTEXTMENU,
        (DWORD_PTR) MyHelpIds );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\dcntpage.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: DCntPage.h
// author: DMihai
// created: 11/1/00
//
// Description:
//

#if !defined(AFX_DCNTPAGE_H__49C83C54_F12D_4A9C_A6F3_D25F988B337D__INCLUDED_)
#define AFX_DCNTPAGE_H__49C83C54_F12D_4A9C_A6F3_D25F988B337D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DCntPage.h : header file
//

#include "VerfPage.h"

/////////////////////////////////////////////////////////////////////////////
// CDriverCountersPage dialog

class CDriverCountersPage : public CVerifierPropertyPage
{
	DECLARE_DYNCREATE(CDriverCountersPage)

public:
    //
    // Construction
    //

	CDriverCountersPage();
	~CDriverCountersPage();

    //
    // Methods
    //

    VOID SetParentSheet( CPropertySheet *pParentSheet )
    {
        m_pParentSheet = pParentSheet;
        ASSERT( m_pParentSheet != NULL );
    }

    VOID SetupListHeader();

    VOID FillTheList();
    VOID AddAllListItems( CRuntimeDriverData *pRuntimeDriverData );
    VOID RefreshTheList();
    
    INT AddCounterInList( INT nItemData, 
                          ULONG  uIdResourceString );

    VOID AddCounterInList( INT nItemData, 
                           ULONG  uIdResourceString,
                           SIZE_T sizeValue );
    
    SIZE_T GetCounterValue( INT_PTR nCounterIndex,
                            CRuntimeDriverData *pRuntimeDriverData = NULL);

    BOOL   GetCounterName( LPARAM lItemData, 
                           TCHAR *szCounterName,
                           ULONG uCounterNameBufferLen );

    VOID UpdateCounterValueInList( INT nItemIndex,
                                   LPTSTR szValue );
    VOID UpdateCounterValueInList( INT nItemIndex,
                                   SIZE_T sizeValue );


    VOID RefreshInfo();
    VOID RefreshCombo();
    
    VOID GetCurrentSelDriverName( CString &strName );
    CRuntimeDriverData *GetCurrentDrvRuntimeData();

    VOID SortTheList();

    static int CALLBACK CounterValueCmpFunc(
        LPARAM lParam1,
        LPARAM lParam2,
        LPARAM lParamSort);

    static int CALLBACK CounterNameCmpFunc(
        LPARAM lParam1,
        LPARAM lParam2,
        LPARAM lParamSort);

protected:
    //
    // Data
    //

    CPropertySheet      *m_pParentSheet;

    //
    // Dialog Data
    //

    INT m_nSortColumnIndex;     // counter name (0) or counter value (1)
    BOOL m_bAscendSortName;     // sort ascendent the counter names
    BOOL m_bAscendSortValue;    // sort ascendent the counter values

    UINT_PTR m_uTimerHandler;   // timer handler, returned by SetTimer()

    //
    // Runtime data (obtained from the kernel)
    //

    CRuntimeVerifierData m_RuntimeVerifierData; 

    //
    // Dialog data
    //

    //{{AFX_DATA(CDriverCountersPage)
	enum { IDD = IDD_PERDRIVER_COUNTERS_PAGE };
	CComboBox	m_DriversCombo;
	CStatic	m_NextDescription;
	CListCtrl	m_CountersList;
    int m_nUpdateIntervalIndex;
	//}}AFX_DATA

protected:
    //
    // Overrides
    //

    //
    // All the property pages derived from this class should 
    // provide these methods.
    //

    virtual ULONG GetDialogId() const { return IDD; }

    //
    // ClassWizard generate virtual function overrides
    //

    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CDriverCountersPage)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
    // Generated message map functions
    //{{AFX_MSG(CDriverCountersPage)
    virtual BOOL OnInitDialog();
    afx_msg VOID OnTimer(UINT nIDEvent);
    afx_msg void OnSelendokDriverCombo();
    afx_msg void OnColumnclickPerdrvcList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg LONG OnHelp( WPARAM wParam, LPARAM lParam );
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DCNTPAGE_H__49C83C54_F12D_4A9C_A6F3_D25F988B337D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\dstspage.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: DStsPage.h
// author: DMihai
// created: 11/1/00
//
// Description:
//  

#if !defined(AFX_DRIVERSTATUSPAGE_H__24C9AD87_924A_4E7B_99D3_A69947701E74__INCLUDED_)
#define AFX_DRIVERSTATUSPAGE_H__24C9AD87_924A_4E7B_99D3_A69947701E74__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DriverStatusPage.h : header file
//

#include "VerfPage.h"

/////////////////////////////////////////////////////////////////////////////
// CDriverStatusPage dialog

class CDriverStatusPage : public CVerifierPropertyPage
{
	DECLARE_DYNCREATE(CDriverStatusPage)

// Construction
public:
	CDriverStatusPage();
	~CDriverStatusPage();

protected:
    //
    // Data
    //

    CPropertySheet *m_pParentSheet;

    //
    // Runtime data (obtained from the kernel)
    //

    CRuntimeVerifierData m_RuntimeVerifierData; 

    //
    // Driver list sort parameters
    //

    INT m_nSortColumnIndexDrv;      // sort by name (0) or by status (1)
    BOOL m_bAscendDrvNameSort;      // sort ascendent by name
    BOOL m_bAscendDrvStatusSort;    // sort ascendent by status

    //
    // Settings bits sort parameters
    //

    INT m_nSortColumnIndexSettbits; // sort by enabled/disabled (0) or by bit name (1)
    BOOL m_bAscendSortEnabledBits;  // sort ascendent by enabled/disabled
    BOOL m_bAscendSortNameBits;     // sort ascendent by bit name

    //
    // Timer handler, returned by SetTimer()
    //

    UINT_PTR m_uTimerHandler;   

    BOOL m_bTimerBlocked;

    //
    // Dialog Data
    //

	//{{AFX_DATA(CDriverStatusPage)
	enum { IDD = IDD_DRVSTATUS_STAT_PAGE };
	CListCtrl	m_SettBitsList;
	CStatic	m_NextDescription;
    CListCtrl	m_DriversList;
	//}}AFX_DATA
public:
    //
    // Methods
    //

    VOID SetParentSheet( CPropertySheet *pParentSheet )
    {
        m_pParentSheet = pParentSheet;
        ASSERT( m_pParentSheet != NULL );
    }

protected:

    VOID RefreshInfo();

    //
    // Driver status list control methods
    //

    VOID SetupListHeaderDrivers();
    VOID FillTheListDrivers();
    VOID UpdateStatusColumnDrivers( INT_PTR nItemIndex, INT_PTR nCrtDriver );
    VOID SortTheListDrivers();

    static int CALLBACK DrvStatusCmpFunc(
        LPARAM lParam1,
        LPARAM lParam2,
        LPARAM lParamSort);

    static int CALLBACK DrvNameCmpFunc(
        LPARAM lParam1,
        LPARAM lParam2,
        LPARAM lParamSort);

    //
    // Settings bits list control methods
    //

    VOID SetupListHeaderSettBits();
    VOID FillTheListSettBits();
    VOID AddListItemSettBits( INT nItemData, BOOL bEnabled, ULONG uIdResourceString );
    VOID UpdateStatusColumnSettBits( INT nIndexInList, BOOL bEnabled );
    VOID RefreshListSettBits();
    VOID SortTheListSettBits();

    BOOL SettbitsGetBitName( LPARAM lItemData, 
                             TCHAR *szBitName,
                             ULONG uBitNameBufferLen );

    BOOL IsSettBitEnabled( INT_PTR nBitIndex );

    static int CALLBACK SettbitsEnabledCmpFunc(
        LPARAM lParam1,
        LPARAM lParam2,
        LPARAM lParamSort);

    static int CALLBACK SettbitsNameCmpFunc(
        LPARAM lParam1,
        LPARAM lParam2,
        LPARAM lParamSort);

protected:
    //
    // Overrides
    //

    //
    // All the property pages derived from this class should 
    // provide these methods.
    //

    virtual ULONG GetDialogId() const { return IDD; }

    //
    // ClassWizard generate virtual function overrides
    //

    //{{AFX_VIRTUAL(CDriverStatusPage)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	protected:
    virtual VOID DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CDriverStatusPage)
    virtual BOOL OnInitDialog();
    afx_msg VOID OnColumnclickCrtstatDriversList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg VOID OnTimer(UINT nIDEvent);
	afx_msg void OnChsettButton();
	afx_msg void OnAdddrvButton();
	afx_msg void OnRemdrvtButton();
	afx_msg void OnColumnclickCrtstatSettbitsList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg LONG OnHelp( WPARAM wParam, LPARAM lParam );
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DRIVERSTATUSPAGE_H__24C9AD87_924A_4E7B_99D3_A69947701E74__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\dstspage.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: DStsPage.cpp
// author: DMihai
// created: 11/1/00
//
// Description:
//

#include "stdafx.h"
#include <Cderr.h>
#include "verifier.h"

#include "DStsPage.h"
#include "VrfUtil.h"
#include "VGlobal.h"
#include "VBitsDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Timer ID
//

#define REFRESH_TIMER_ID    0x1234

//
// Help IDs
//

static DWORD MyHelpIds[] =
{
    IDC_CRTSTAT_SETTBITS_LIST,      IDH_DV_CurrentSettings,
    IDC_CRTSTAT_DRIVERS_LIST,       IDH_DV_CurrentVerifiedDrivers,
    IDC_CRTSTAT_CHSETT_BUTTON,      IDH_DV_Changebut,
    IDC_CRTSTAT_ADDDRV_BUTTON,      IDH_DV_Addbut,
    IDC_CRTSTAT_REMDRVT_BUTTON,     IDH_DV_Removebut,
    0,                              0
};

/////////////////////////////////////////////////////////////////////////////
// CDriverStatusPage property page

IMPLEMENT_DYNCREATE(CDriverStatusPage, CVerifierPropertyPage)

CDriverStatusPage::CDriverStatusPage() : CVerifierPropertyPage(CDriverStatusPage::IDD)
{
	//{{AFX_DATA_INIT(CDriverStatusPage)
    //}}AFX_DATA_INIT

    m_uTimerHandler = 0;

    //
    // Driver list sort parameters
    //

    m_nSortColumnIndexDrv = 0;
    m_bAscendDrvNameSort = FALSE;
    m_bAscendDrvStatusSort = FALSE;

    //
    // Settings bits sort parameters
    //

    m_nSortColumnIndexSettbits = 1;
    m_bAscendSortEnabledBits = FALSE;
    m_bAscendSortNameBits = FALSE;

    m_pParentSheet = NULL;
}

CDriverStatusPage::~CDriverStatusPage()
{
}

VOID CDriverStatusPage::DoDataExchange(CDataExchange* pDX)
{
    if( ! pDX->m_bSaveAndValidate )
    {
        //
        // Query the kernel
        //

        if( TRUE != VrfGetRuntimeVerifierData( &m_RuntimeVerifierData )     ||
            m_RuntimeVerifierData.m_RuntimeDriverDataArray.GetSize() == 0 )
        {
            //
            // Don't have any verified drivers currently
            //

            //
            // Clear all settings bits just in case the kernel
            // didn't return them to us all zero ;-)
            //

            m_RuntimeVerifierData.m_bSpecialPool    = FALSE;
            m_RuntimeVerifierData.m_bPoolTracking   = FALSE;
            m_RuntimeVerifierData.m_bForceIrql      = FALSE;
            m_RuntimeVerifierData.m_bIo             = FALSE;
            m_RuntimeVerifierData.m_bEnhIo          = FALSE;
            m_RuntimeVerifierData.m_bDeadlockDetect = FALSE;
            m_RuntimeVerifierData.m_bDMAVerif       = FALSE;
            m_RuntimeVerifierData.m_bLowRes         = FALSE;
        }
    }

    CVerifierPropertyPage::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(CDriverStatusPage)
	DDX_Control(pDX, IDC_CRTSTAT_SETTBITS_LIST, m_SettBitsList);
	DDX_Control(pDX, IDC_CRTSTAT_NEXT_DESCR_STATIC, m_NextDescription);
    DDX_Control(pDX, IDC_CRTSTAT_DRIVERS_LIST, m_DriversList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDriverStatusPage, CVerifierPropertyPage)
	//{{AFX_MSG_MAP(CDriverStatusPage)
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_CRTSTAT_DRIVERS_LIST, OnColumnclickCrtstatDriversList)
    ON_WM_TIMER()
	ON_BN_CLICKED(IDC_CRTSTAT_CHSETT_BUTTON, OnChsettButton)
	ON_BN_CLICKED(IDC_CRTSTAT_ADDDRV_BUTTON, OnAdddrvButton)
	ON_BN_CLICKED(IDC_CRTSTAT_REMDRVT_BUTTON, OnRemdrvtButton)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_CRTSTAT_SETTBITS_LIST, OnColumnclickCrtstatSettbitsList)
    ON_WM_CONTEXTMENU()
    ON_MESSAGE( WM_HELP, OnHelp )
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////
VOID CDriverStatusPage::RefreshInfo() 
{
    if( UpdateData( FALSE ) )
    {
        //
        // Refresh the settings bits list
        //

        RefreshListSettBits();
        //SortTheListSettBits();

        //
        // Refresh the drivers list
        //

        FillTheListDrivers();
        SortTheListDrivers();
    }
}

/////////////////////////////////////////////////////////////
//
// Driver status list control methods
//

VOID CDriverStatusPage::SetupListHeaderDrivers()
{
    LVCOLUMN lvColumn;
    CRect rectWnd;
    CString strDrivers, strStatus;
    VERIFY( strDrivers.LoadString( IDS_DRIVERS ) );
    VERIFY( strStatus.LoadString( IDS_STATUS ) );

    //
    // List's regtangle
    //

    m_DriversList.GetClientRect( &rectWnd );
    
    //
    // Column 0
    //

    ZeroMemory( &lvColumn, sizeof( lvColumn ) );
    lvColumn.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;
    
    lvColumn.iSubItem = 0;
    lvColumn.pszText = strDrivers.GetBuffer( strDrivers.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.50 );
    VERIFY( m_DriversList.InsertColumn( 0, &lvColumn ) != -1 );
    strDrivers.ReleaseBuffer();

    //
    // Column 1
    //

    lvColumn.iSubItem = 1;
    lvColumn.pszText = strStatus.GetBuffer( strStatus.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.44 );
    VERIFY( m_DriversList.InsertColumn( 1, &lvColumn ) != -1 );
    strStatus.ReleaseBuffer();
}

/////////////////////////////////////////////////////////////
VOID CDriverStatusPage::FillTheListDrivers()
{
    LVITEM lvItem;
    int nActualIndex; 
    BOOL *pbAlreadyInList;
    int nItemCount;
    int nCrtListItem;
    INT_PTR nCrtVerifiedDriver;
    INT_PTR nDriversNo;
    TCHAR szDriverName[ _MAX_PATH ];
    BOOL bResult;
    CString strText;

    //
    // The number of drivers currently verified
    //

    nDriversNo = m_RuntimeVerifierData.m_RuntimeDriverDataArray.GetSize();

    if( nDriversNo == 0 )
    {
        //
        // Clear the list
        //

        VERIFY( m_DriversList.DeleteAllItems() );
    }
    else
    {
        //
        // There are some drivers currently verified
        //

        pbAlreadyInList = new BOOL[ nDriversNo ];
        
        if( pbAlreadyInList == NULL )
        {
            return;
        }
        
        for( nCrtVerifiedDriver = 0; nCrtVerifiedDriver < nDriversNo; nCrtVerifiedDriver+= 1)
        {
            pbAlreadyInList[ nCrtVerifiedDriver ] = FALSE;
        }

        //
        // Parse all the current list items
        //

        nItemCount = m_DriversList.GetItemCount();

        for( nCrtListItem = 0; nCrtListItem < nItemCount; nCrtListItem+= 1 )
        {
            //
            // Get the current driver's name from the list
            //

            ZeroMemory( &lvItem, sizeof( lvItem ) );

            lvItem.mask = LVIF_TEXT;
            lvItem.iItem = nCrtListItem;
            lvItem.iSubItem = 0;
            lvItem.pszText = szDriverName;
            lvItem.cchTextMax = ARRAY_LENGTH( szDriverName );

            bResult = m_DriversList.GetItem( &lvItem );
            if( bResult == FALSE )
            {
                //
                // Could not get the current item's attributes?!?
                //

                ASSERT( FALSE );

                //
                // Remove this item from the list
                //

                VERIFY( m_DriversList.DeleteItem( nCrtListItem ) );

                nCrtListItem -= 1;
                nItemCount -= 1;
            }
            else
            {
                //
                // see is the current driver is still in m_RuntimeVerifierData
                //

                for( nCrtVerifiedDriver = 0; nCrtVerifiedDriver < nDriversNo; nCrtVerifiedDriver+= 1)
                {
                    if( m_RuntimeVerifierData.m_RuntimeDriverDataArray.GetAt( nCrtVerifiedDriver )
                        ->m_strName.CompareNoCase( szDriverName ) == 0 )
                    {
                        //
                        // Update the item's data with the current index in the array
                        //

                        lvItem.mask = LVIF_PARAM;
                        lvItem.lParam = nCrtVerifiedDriver;
                        
                        VERIFY( m_DriversList.SetItem( &lvItem ) != -1 );

                        //
                        // Update the second column
                        //

                        UpdateStatusColumnDrivers( nCrtListItem, nCrtVerifiedDriver ); 

                        //
                        // Mark the current driver as updated
                        //

                        pbAlreadyInList[ nCrtVerifiedDriver ] = TRUE;

                        break;
                    }
                }

                //
                // If the driver is no longer verified, remove it from the list
                //

                if( nCrtVerifiedDriver >= nDriversNo )
                {
                    VERIFY( m_DriversList.DeleteItem( nCrtListItem ) );

                    nCrtListItem -= 1;
                    nItemCount -= 1;
                }
            }
        }

        //
        // Add the drivers that were not in the list before this update
        //

        for( nCrtVerifiedDriver = 0; nCrtVerifiedDriver < nDriversNo; nCrtVerifiedDriver += 1)
        {
            if( ! pbAlreadyInList[ nCrtVerifiedDriver ] )
            {
                // 
                // Add a new item for this
                //

                ZeroMemory( &lvItem, sizeof( lvItem ) );

                //
                // sub-item 0
                //

                lvItem.mask = LVIF_TEXT | LVIF_PARAM;
                lvItem.lParam = nCrtVerifiedDriver;
                lvItem.iItem = m_DriversList.GetItemCount();
                lvItem.iSubItem = 0;
                
                strText = m_RuntimeVerifierData.m_RuntimeDriverDataArray.GetAt( nCrtVerifiedDriver )->m_strName;
                
                lvItem.pszText = strText.GetBuffer( strText.GetLength() + 1 );

                if( NULL != lvItem.pszText  )
                {
                    nActualIndex = m_DriversList.InsertItem( &lvItem );
                    
                    VERIFY( nActualIndex != -1 );

                    strText.ReleaseBuffer();

                    //
                    // sub-item 1
                    //

                    UpdateStatusColumnDrivers( nActualIndex, nCrtVerifiedDriver ); 
                }
            }
        }

        delete pbAlreadyInList;
    }
}

/////////////////////////////////////////////////////////////
VOID CDriverStatusPage::UpdateStatusColumnDrivers( INT_PTR nItemIndex, INT_PTR nCrtDriver )
{
    CRuntimeDriverData *pCrtDriverData;
    LVITEM lvItem;
    CString strStatus;

    ASSERT( nItemIndex >= 0 && 
            nItemIndex < m_RuntimeVerifierData.m_RuntimeDriverDataArray.GetSize() &&
            nItemIndex < m_DriversList.GetItemCount() &&
            nCrtDriver >= 0 &&
            nCrtDriver < m_RuntimeVerifierData.m_RuntimeDriverDataArray.GetSize() &&
            nCrtDriver < m_DriversList.GetItemCount() );

    pCrtDriverData = m_RuntimeVerifierData.m_RuntimeDriverDataArray.GetAt( nCrtDriver );

    ASSERT_VALID( pCrtDriverData );

    //
    // Determine what's the appropriate value for the second column
    //

    if( ! pCrtDriverData->Loads )
    {
        VERIFY( strStatus.LoadString( IDS_NEVER_LOADED ) );
    }
    else
    {
        if( pCrtDriverData->Loads == pCrtDriverData->Unloads )
        {
            VERIFY( strStatus.LoadString( IDS_UNLOADED ) );
        }
        else
        {
            if( pCrtDriverData->Loads > pCrtDriverData->Unloads )
            {
                VERIFY( strStatus.LoadString( IDS_LOADED ) );
            }
            else
            {
                ASSERT( FALSE );
                VERIFY( strStatus.LoadString( IDS_UNKNOWN ) );
            }
        }
    }

    //
    // Update the list item
    //

    ZeroMemory( &lvItem, sizeof( lvItem ) );
    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = (INT)nItemIndex;
    lvItem.iSubItem = 1;
    lvItem.pszText = strStatus.GetBuffer( strStatus.GetLength() + 1 );
    VERIFY( m_DriversList.SetItem( &lvItem ) );
    strStatus.ReleaseBuffer();
}

/////////////////////////////////////////////////////////////
int CALLBACK CDriverStatusPage::DrvStatusCmpFunc(
    LPARAM lParam1, 
    LPARAM lParam2, 
    LPARAM lParamSort)
{
    UINT uIndex1 = (UINT)lParam1;
    UINT uIndex2 = (UINT)lParam2;
    int nCmpRez = 0;
    CRuntimeDriverData *pDriverData1;
    CRuntimeDriverData *pDriverData2;

    CDriverStatusPage *pThis = (CDriverStatusPage *)lParamSort;
    ASSERT_VALID( pThis );

    //
    // Difference between loads and unloads #
    //

    pDriverData1 = pThis->m_RuntimeVerifierData.m_RuntimeDriverDataArray.GetAt( uIndex1 );

    ASSERT_VALID( pDriverData1 );

    pDriverData2 = pThis->m_RuntimeVerifierData.m_RuntimeDriverDataArray.GetAt( uIndex2 );

    ASSERT_VALID( pDriverData2 );

    LONG lLoadDiff1 = (LONG) pDriverData1->Loads - (LONG) pDriverData1->Unloads;
    LONG lLoadDiff2 = (LONG) pDriverData2->Loads - (LONG) pDriverData2->Unloads;

    if( lLoadDiff1 == lLoadDiff2 )
    {
        //
        // Both loaded or both not loaded
        //

        if( pDriverData1->Loads == pDriverData2->Loads )
        {
            //
            // Loaded same number of times
            //

            nCmpRez = 0;
        }
        else
        {
            if( pDriverData1->Loads > pDriverData2->Loads )
            {
                nCmpRez = 2;
            }
            else
            {
                nCmpRez = -2;
            }
        }
    }
    else
    {
        if( lLoadDiff1 > lLoadDiff2 )
        {
            nCmpRez = 1;
        }
        else
        {
            nCmpRez = -1;
        }
    }

    if( FALSE != pThis->m_bAscendDrvStatusSort )
    {
        nCmpRez *= -1;
    }

    return nCmpRez;
}

/////////////////////////////////////////////////////////////
int CALLBACK CDriverStatusPage::DrvNameCmpFunc(
    LPARAM lParam1, 
    LPARAM lParam2, 
    LPARAM lParamSort)
{
    int nCmpRez = 0;
    UINT uIndex1 = (UINT)lParam1;
    UINT uIndex2 = (UINT)lParam2;
    CRuntimeDriverData *pDriverData1;
    CRuntimeDriverData *pDriverData2;

    CDriverStatusPage *pThis = (CDriverStatusPage *)lParamSort;
    ASSERT_VALID( pThis );

    pDriverData1 = pThis->m_RuntimeVerifierData.m_RuntimeDriverDataArray.GetAt( uIndex1 );

    ASSERT_VALID( pDriverData1 );

    pDriverData2 = pThis->m_RuntimeVerifierData.m_RuntimeDriverDataArray.GetAt( uIndex2 );

    ASSERT_VALID( pDriverData2 );

    nCmpRez = pDriverData1->m_strName.CompareNoCase( pDriverData2->m_strName );
    
    if( FALSE != pThis->m_bAscendDrvNameSort )
    {
        nCmpRez *= -1;
    }

    return nCmpRez;
}

/////////////////////////////////////////////////////////////
//
// Settings bits list control methods
//

VOID CDriverStatusPage::SetupListHeaderSettBits()
{
    CString strTitle;
    CRect rectWnd;
    LVCOLUMN lvColumn;

    //
    // The list's rectangle 
    //

    m_SettBitsList.GetClientRect( &rectWnd );

    ZeroMemory( &lvColumn, 
               sizeof( lvColumn ) );

    lvColumn.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;

    //
    // Column 0
    //

    VERIFY( strTitle.LoadString( IDS_ENABLED_QUESTION ) );

    lvColumn.iSubItem = 0;
    lvColumn.pszText = strTitle.GetBuffer( strTitle.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.25 );
    VERIFY( m_SettBitsList.InsertColumn( 0, &lvColumn ) != -1 );
    strTitle.ReleaseBuffer();

    //
    // Column 1
    //

    VERIFY( strTitle.LoadString( IDS_SETTING ) );

    lvColumn.iSubItem = 1;
    lvColumn.pszText = strTitle.GetBuffer( strTitle.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.75 );
    VERIFY( m_SettBitsList.InsertColumn( 1, &lvColumn ) != -1 );
    strTitle.ReleaseBuffer();
}

/////////////////////////////////////////////////////////////
VOID CDriverStatusPage::FillTheListSettBits()
{
    //
    // N.B. 
    //
    // If you change the first parameter (index - stored in the item's data) 
    // you need to change the switch statement in IsSettBitEnabled as well
    //

    AddListItemSettBits( 0, m_RuntimeVerifierData.m_bSpecialPool,  IDS_SPECIAL_POOL  );
    AddListItemSettBits( 1, m_RuntimeVerifierData.m_bPoolTracking, IDS_POOL_TRACKING );
    AddListItemSettBits( 2, m_RuntimeVerifierData.m_bForceIrql,    IDS_FORCE_IRQL_CHECKING );
    AddListItemSettBits( 3, m_RuntimeVerifierData.m_bIo,           IDS_IO_VERIFICATION );
    AddListItemSettBits( 4, m_RuntimeVerifierData.m_bEnhIo,        IDS_ENH_IO_VERIFICATION );
    AddListItemSettBits( 5, m_RuntimeVerifierData.m_bDeadlockDetect, IDS_DEADLOCK_DETECTION );
    AddListItemSettBits( 6, m_RuntimeVerifierData.m_bDMAVerif,     IDS_DMA_CHECHKING );
    AddListItemSettBits( 7, m_RuntimeVerifierData.m_bLowRes,       IDS_LOW_RESOURCE_SIMULATION );
}

/////////////////////////////////////////////////////////////
VOID CDriverStatusPage::RefreshListSettBits()
{
    INT nListItems;
    INT nCrtListItem;
    INT_PTR nCrtVerifierBit;
    BOOL bEnabled;
 
    nListItems = m_SettBitsList.GetItemCount();

    for( nCrtListItem = 0; nCrtListItem < nListItems; nCrtListItem += 1 )
    {
        nCrtVerifierBit = m_SettBitsList.GetItemData( nCrtListItem );

        bEnabled = IsSettBitEnabled( nCrtVerifierBit );

        UpdateStatusColumnSettBits( nCrtListItem, bEnabled );
    }
}

/////////////////////////////////////////////////////////////////////////////
BOOL CDriverStatusPage::SettbitsGetBitName( LPARAM lItemData, 
                                            TCHAR *szBitName,
                                            ULONG uBitNameBufferLen )
{
    INT nItemIndex;
    BOOL bResult;
    LVFINDINFO FindInfo;
    LVITEM lvItem;

    bResult = FALSE;

    ZeroMemory( &FindInfo, sizeof( FindInfo ) );
    FindInfo.flags = LVFI_PARAM;
    FindInfo.lParam = lItemData;

    nItemIndex = m_SettBitsList.FindItem( &FindInfo );

    if( nItemIndex < 0 || nItemIndex > 7 )
    {
        ASSERT( FALSE );
    }
    else
    {
        //
        // Found our item - get the name
        //

        ZeroMemory( &lvItem, sizeof( lvItem ) );

        lvItem.mask = LVIF_TEXT;
        lvItem.iItem = nItemIndex;
        lvItem.iSubItem = 1;
        lvItem.pszText = szBitName;
        lvItem.cchTextMax = uBitNameBufferLen;

        bResult = m_SettBitsList.GetItem( &lvItem );
        
        if( FALSE == bResult )
        {
            //
            // Could not get the current item's attributes?!?
            //

            ASSERT( FALSE );
        }
    }

    return bResult;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CDriverStatusPage::IsSettBitEnabled( INT_PTR nBitIndex )
{
    BOOL bEnabled;

    //
    // N.B. 
    //
    // If you change this switch statement you need to change FillTheListSettBits as well
    //

    switch( nBitIndex )
    {
    case 0:
        bEnabled = m_RuntimeVerifierData.m_bSpecialPool;
        break;

    case 1:
        bEnabled = m_RuntimeVerifierData.m_bPoolTracking;
        break;

    case 2:
        bEnabled = m_RuntimeVerifierData.m_bForceIrql;
        break;

    case 3:
        bEnabled = m_RuntimeVerifierData.m_bIo;
        break;

    case 4:
        bEnabled = m_RuntimeVerifierData.m_bEnhIo;
        break;

    case 5:
        bEnabled = m_RuntimeVerifierData.m_bDeadlockDetect;
        break;

    case 6:
        bEnabled = m_RuntimeVerifierData.m_bDMAVerif;
        break;

    case 7:
        bEnabled = m_RuntimeVerifierData.m_bLowRes;
        break;

    default:
        //
        // Oops, how did we get here ?!?
        //

        ASSERT( FALSE );

        bEnabled = FALSE;

        break;
    }

    return bEnabled;
}

/////////////////////////////////////////////////////////////////////////////
VOID CDriverStatusPage::AddListItemSettBits( INT nItemData, BOOL bEnabled, ULONG uIdResourceString )
{
    INT nActualIndex;
    LVITEM lvItem;
    CString strText;

    ZeroMemory( &lvItem, sizeof( lvItem ) );

    //
    // LVITEM's member pszText is not a const pointer 
    // so we need to GetBuffer here :-(
    //

    //
    // Sub-item 0 - enabled/diabled 
    //

    if( FALSE == bEnabled )
    {
        VERIFY( strText.LoadString( IDS_NO ) );
    }
    else
    {
        VERIFY( strText.LoadString( IDS_YES ) );
    }

    lvItem.pszText = strText.GetBuffer( strText.GetLength() + 1 );

    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.lParam = nItemData;
    
    lvItem.iItem = m_SettBitsList.GetItemCount();

    nActualIndex = m_SettBitsList.InsertItem( &lvItem );

    strText.ReleaseBuffer();

    if( nActualIndex < 0 )
    {
        //
        // Could not add an item in the list - give up
        //

        goto Done;
    }

    //
    // Sub-item 1 - feature name
    //

    VERIFY( strText.LoadString( uIdResourceString ) );

    lvItem.pszText = strText.GetBuffer( strText.GetLength() + 1 );
    
    if( NULL == lvItem.pszText )
    {
        goto Done;
    }

    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = nActualIndex;
    lvItem.iSubItem = 1;
    
    VERIFY( m_SettBitsList.SetItem( &lvItem ) );

    strText.ReleaseBuffer();

Done:
    //
    // All done
    //

    NOTHING;
}

/////////////////////////////////////////////////////////////
VOID CDriverStatusPage::UpdateStatusColumnSettBits( INT nItemIndex, BOOL bEnabled )
{
    LVITEM lvItem;
    CString strText;

    ASSERT( nItemIndex < m_SettBitsList.GetItemCount() );

    if( FALSE == bEnabled )
    {
        VERIFY( strText.LoadString( IDS_NO ) );
    }
    else
    {
        VERIFY( strText.LoadString( IDS_YES ) );
    }

    ZeroMemory( &lvItem, sizeof( lvItem ) );
    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = nItemIndex;
    lvItem.iSubItem = 0;
    lvItem.pszText = strText.GetBuffer( strText.GetLength() + 1 );
    VERIFY( m_SettBitsList.SetItem( &lvItem ) );
    strText.ReleaseBuffer();
}

/////////////////////////////////////////////////////////////
int CALLBACK CDriverStatusPage::SettbitsNameCmpFunc(
    LPARAM lParam1, 
    LPARAM lParam2, 
    LPARAM lParamSort)
{
    int nCmpRez = 0;
    BOOL bSuccess;
    TCHAR szBitName1[ _MAX_PATH ];
    TCHAR szBitName2[ _MAX_PATH ];

    CDriverStatusPage *pThis = (CDriverStatusPage *)lParamSort;
    ASSERT_VALID( pThis );

    //
    // Get the first bit name
    //

    bSuccess = pThis->SettbitsGetBitName( lParam1, 
                                          szBitName1,
                                          ARRAY_LENGTH( szBitName1 ) );

    if( FALSE == bSuccess )
    {
        goto Done;
    }

    //
    // Get the second bit name
    //

    bSuccess = pThis->SettbitsGetBitName( lParam2, 
                                          szBitName2,
                                          ARRAY_LENGTH( szBitName2 ) );

    if( FALSE == bSuccess )
    {
        goto Done;
    }

    //
    // Compare the names
    //

    nCmpRez = _tcsicmp( szBitName1, szBitName2 );
    
    if( FALSE != pThis->m_bAscendSortNameBits )
    {
        nCmpRez *= -1;
    }

Done:

    return nCmpRez;
}

/////////////////////////////////////////////////////////////
int CALLBACK CDriverStatusPage::SettbitsEnabledCmpFunc(
    LPARAM lParam1,
    LPARAM lParam2,
    LPARAM lParamSort)
{
    int nCmpRez = 0;
    BOOL bEnabled1;
    BOOL bEnabled2;

    CDriverStatusPage *pThis = (CDriverStatusPage *)lParamSort;
    ASSERT_VALID( pThis );

    bEnabled1 = pThis->IsSettBitEnabled( (INT) lParam1 );
    bEnabled2 = pThis->IsSettBitEnabled( (INT) lParam2 );

    if( bEnabled1 == bEnabled2 )
    {
        nCmpRez = 0;
    }
    else
    {
        if( FALSE == bEnabled1 )
        {
            nCmpRez = -1;
        }
        else
        {
            nCmpRez = 1;
        }
    }

    if( FALSE != pThis->m_bAscendSortEnabledBits )
    {
        nCmpRez *= -1;
    }

    return nCmpRez;
}

/////////////////////////////////////////////////////////////
//
// Other methods
//

/////////////////////////////////////////////////////////////
VOID CDriverStatusPage::SortTheListDrivers()
{
    if( 0 != m_nSortColumnIndexDrv )
    {
        //
        // Sort by status
        //

        m_DriversList.SortItems( DrvStatusCmpFunc, (LPARAM)this );
    }
    else
    {
        //
        // Sort by driver name
        //

        m_DriversList.SortItems( DrvNameCmpFunc, (LPARAM)this );
    }
}

/////////////////////////////////////////////////////////////
VOID CDriverStatusPage::SortTheListSettBits()
{
    if( 0 != m_nSortColumnIndexSettbits )
    {
        //
        // Sort by bit name
        //

        m_SettBitsList.SortItems( SettbitsNameCmpFunc, (LPARAM)this );
    }
    else
    {
        //
        // Sort by enabled/disabled
        //

        m_SettBitsList.SortItems( SettbitsEnabledCmpFunc, (LPARAM)this );
    }
}

/////////////////////////////////////////////////////////////
// CDriverStatusPage message handlers

BOOL CDriverStatusPage::OnInitDialog() 
{
    CPropertyPage::OnInitDialog();

    m_bTimerBlocked = FALSE;

    //
    // Setup the settings bits list
    //

    m_SettBitsList.SetExtendedStyle( 
        LVS_EX_FULLROWSELECT | m_SettBitsList.GetExtendedStyle() );

    m_SettBitsList.SetBkColor( ::GetSysColor( COLOR_3DFACE ) );
    m_SettBitsList.SetTextBkColor( ::GetSysColor( COLOR_3DFACE ) );

    SetupListHeaderSettBits();
    FillTheListSettBits();
    //SortTheListSettBits();

    //
    // Setup the drivers list
    //

    m_DriversList.SetExtendedStyle( 
        LVS_EX_FULLROWSELECT | m_DriversList.GetExtendedStyle() );

    m_DriversList.SetBkColor( ::GetSysColor( COLOR_3DFACE ) );
    m_DriversList.SetTextBkColor( ::GetSysColor( COLOR_3DFACE ) );

    SetupListHeaderDrivers();
    FillTheListDrivers();
    SortTheListDrivers();

    VrfSetWindowText( m_NextDescription, IDS_CRTSTAT_PAGE_NEXT_DESCR );

    VERIFY( m_uTimerHandler = SetTimer( REFRESH_TIMER_ID, 
                                        5000,
                                        NULL ) );

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////
VOID CDriverStatusPage::OnColumnclickCrtstatDriversList(NMHDR* pNMHDR, 
                                                   LRESULT* pResult) 
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    if( 0 != pNMListView->iSubItem )
    {
        //
        // Clicked on the status column
        //

        if( m_nSortColumnIndexDrv == pNMListView->iSubItem )
        {
            //
            // Change the current ascend/descend order for this column
            //

            m_bAscendDrvStatusSort = !m_bAscendDrvStatusSort;
        }
    }
    else
    {
        //
        // Clicked on the driver name column
        //

        if( m_nSortColumnIndexDrv == pNMListView->iSubItem )
        {
            //
            // Change the current ascend/descend order for this column
            //

            m_bAscendDrvNameSort = !m_bAscendDrvNameSort;
        }
    }

    m_nSortColumnIndexDrv = pNMListView->iSubItem;

    SortTheListDrivers();

    *pResult = 0;
}

/////////////////////////////////////////////////////////////
VOID CDriverStatusPage::OnTimer(UINT nIDEvent) 
{
    if( m_bTimerBlocked != TRUE && nIDEvent == REFRESH_TIMER_ID )
    {
        ASSERT_VALID( m_pParentSheet );

        if( m_pParentSheet->GetActivePage() == this )
        {
            //
            // Refresh the displayed data 
            //

            RefreshInfo();
        }
    }

    CPropertyPage::OnTimer(nIDEvent);
}

/////////////////////////////////////////////////////////////////////////////
BOOL CDriverStatusPage::OnSetActive() 
{
    ASSERT_VALID( m_pParentSheet );

    m_pParentSheet->SetWizardButtons(   PSWIZB_BACK |
                                        PSWIZB_NEXT );
    	
	return CVerifierPropertyPage::OnSetActive();
}

/////////////////////////////////////////////////////////////////////////////
LRESULT CDriverStatusPage::OnWizardNext() 
{
    GoingToNextPageNotify( IDD_GLOBAL_COUNTERS_PAGE );

	return IDD_GLOBAL_COUNTERS_PAGE;
}

/////////////////////////////////////////////////////////////////////////////
void CDriverStatusPage::OnChsettButton() 
{
    CVolatileBitsDlg dlg;
    
    if( IDOK == dlg.DoModal() )
    {
        RefreshInfo();
    }
}

/////////////////////////////////////////////////////////////////////////////
#define VRF_MAX_CHARS_FOR_OPEN  4096

void CDriverStatusPage::OnAdddrvButton() 
{
    POSITION pos;
    BOOL bEnabledSome = FALSE;
    DWORD dwRetValue;
    DWORD dwOldMaxFileName = 0;
    DWORD dwErrorCode;
    int nFileNameStartIndex;
    INT_PTR nResult;
    TCHAR szDriversDir[ _MAX_PATH ];
    TCHAR szAppTitle[ _MAX_PATH ];
    TCHAR *szFilesBuffer = NULL;
    TCHAR *szOldFilesBuffer = NULL;
    CString strPathName;
    CString strFileName;

    CFileDialog fileDlg( 
        TRUE,                               // open file
        _T( "sys" ),                        // default extension
        NULL,                               // no initial file name
        OFN_ALLOWMULTISELECT    |           // multiple selection
        OFN_HIDEREADONLY        |           // hide the "open read-only" checkbox
        OFN_NONETWORKBUTTON     |           // no network button
        OFN_NOTESTFILECREATE    |           // don't test for write protection, a full disk, etc.
        OFN_SHAREAWARE,                     // don't check the existance of file with OpenFile
        _T( "Drivers (*.sys)|*.sys||" ) );  // only one filter

    //
    // check the max length for the returned string
    //

    if( fileDlg.m_ofn.nMaxFile < VRF_MAX_CHARS_FOR_OPEN )
    {
        //
        // allocate a new buffer for the file names
        // 

        szFilesBuffer = new TCHAR[ VRF_MAX_CHARS_FOR_OPEN ];
        szFilesBuffer[ 0 ] = (TCHAR)0;

        if( szFilesBuffer != NULL )
        {
            //
            // Save the old buffer address and length
            //

            dwOldMaxFileName = fileDlg.m_ofn.nMaxFile;
            szOldFilesBuffer = fileDlg.m_ofn.lpstrFile;
            
            //
            // Set the new buffer address and length
            //

            fileDlg.m_ofn.lpstrFile = szFilesBuffer;
            fileDlg.m_ofn.nMaxFile = VRF_MAX_CHARS_FOR_OPEN;
        }
    }

    //
    // Dialog title
    //

    if( VrfLoadString(
        IDS_APPTITLE,
        szAppTitle,
        ARRAY_LENGTH( szAppTitle ) ) )
    {
        fileDlg.m_ofn.lpstrTitle = szAppTitle;
    }

    //
    // We change directory first time we try this to %windir%\system32\drivers
    //

    dwRetValue = ExpandEnvironmentStrings(
        _T( "%windir%\\system32\\drivers" ),
        szDriversDir,
        ARRAY_LENGTH( szDriversDir ) );

    if( dwRetValue > 0 && dwRetValue <= ARRAY_LENGTH( szDriversDir ) )
    {
        fileDlg.m_ofn.lpstrInitialDir = szDriversDir;
    }

    //
    // Show the file selection dialog
    //

    nResult = fileDlg.DoModal();

    switch( nResult )
    {
    case IDOK:
        break;

    case IDCANCEL:
        goto cleanup;

    default:
        dwErrorCode = CommDlgExtendedError();

        if( dwErrorCode == FNERR_BUFFERTOOSMALL )
        {
            VrfErrorResourceFormat(
                IDS_TOO_MANY_FILES_SELECTED );
        }
        else
        {
            VrfErrorResourceFormat(
                IDS_CANNOT_OPEN_FILES,
                dwErrorCode );
        }

        goto cleanup;
    }

    //
    // Block the timer
    //

    m_bTimerBlocked = TRUE;

    //
    // Parse all the selected files and try to enable them for verification
    //

    pos = fileDlg.GetStartPosition();

    while( pos != NULL )
    {
        //
        // Get the full path for the next file
        //

        strPathName = fileDlg.GetNextPathName( pos );

        //
        // Split only the file name, without the directory
        //

        nFileNameStartIndex = strPathName.ReverseFind( _T( '\\' ) );
        
        if( nFileNameStartIndex < 0 )
        {
            //
            // This shoudn't happen but you never know :-)
            //

            nFileNameStartIndex = 0;
        }
        else
        {
            //
            // skip the backslash
            //

            nFileNameStartIndex += 1;
        }

        strFileName = strPathName.Right( strPathName.GetLength() - nFileNameStartIndex );

        //
        // Try to add this driver to the current verification list
        //

        if( VrfAddDriverVolatile( strFileName ) )
        {
            bEnabledSome = TRUE;
        }
    }

    //
    // Enable the timer
    //

    m_bTimerBlocked = FALSE;

    //
    // Refresh
    //

    if( bEnabledSome == TRUE )
    {
        RefreshInfo();
    }

cleanup:
    if( szFilesBuffer != NULL )
    {
        fileDlg.m_ofn.nMaxFile = dwOldMaxFileName;
        fileDlg.m_ofn.lpstrFile = szOldFilesBuffer;

        delete szFilesBuffer;
    }
}

/////////////////////////////////////////////////////////////////////////////
void CDriverStatusPage::OnRemdrvtButton() 
{
    INT nItems;
    INT nCrtItem;
    INT_PTR nIndexInArray;
    CRuntimeDriverData *pRuntimeDriverData;
    BOOL bDisabledSome = FALSE;

    //
    // Block the timer
    //

    m_bTimerBlocked = TRUE;

    //
    // The number of items in the list
    //

    nItems = m_DriversList.GetItemCount();
    
    //
    // Parse all the items, looking for the selected ones.
    //

    for( nCrtItem = 0; nCrtItem < nItems; nCrtItem += 1 )
    {
        if( m_DriversList.GetItemState( nCrtItem, LVIS_SELECTED ) & LVIS_SELECTED )
        {
            //
            // Get the index of the corresponding entry in the array
            //

            nIndexInArray = (UINT)m_DriversList.GetItemData( nCrtItem );

            //
            // sanity checks
            //

            if( nIndexInArray >= m_RuntimeVerifierData.m_RuntimeDriverDataArray.GetSize() )
            {
                ASSERT( FALSE );
                continue;
            }

            pRuntimeDriverData = m_RuntimeVerifierData.m_RuntimeDriverDataArray.GetAt( nIndexInArray );
            ASSERT_VALID( pRuntimeDriverData );

            if( VrfRemoveDriverVolatile( pRuntimeDriverData->m_strName ) )
            {
                bDisabledSome = TRUE;
            }
        }
    }

    //
    // Enable the timer
    //

    m_bTimerBlocked = FALSE;

    //
    // If we disabled some drivers' verification we need to refresh the list
    //

    if( bDisabledSome )
    {
        RefreshInfo();
    }
}

/////////////////////////////////////////////////////////////////////////////
void CDriverStatusPage::OnColumnclickCrtstatSettbitsList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	
    if( 0 != pNMListView->iSubItem )
    {
        //
        // Clicked on the bit name column
        //

        if( m_nSortColumnIndexSettbits == pNMListView->iSubItem )
        {
            //
            // Change the current ascend/descend order for this column
            //

            m_bAscendSortNameBits = !m_bAscendSortNameBits;
        }
    }
    else
    {
        //
        // Clicked on the enabled/disabled column
        //

        if( m_nSortColumnIndexSettbits == pNMListView->iSubItem )
        {
            //
            // Change the current ascend/descend order for this column
            //

            m_bAscendSortEnabledBits = !m_bAscendSortEnabledBits;
        }
    }

    m_nSortColumnIndexSettbits = pNMListView->iSubItem;

    SortTheListSettBits();

    *pResult = 0;
}

/////////////////////////////////////////////////////////////////////////////
LONG CDriverStatusPage::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp( 
        (HWND) lpHelpInfo->hItemHandle,
        g_szVerifierHelpFile,
        HELP_WM_HELP,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}

/////////////////////////////////////////////////////////////////////////////
void CDriverStatusPage::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    ::WinHelp( 
        pWnd->m_hWnd,
        g_szVerifierHelpFile,
        HELP_CONTEXTMENU,
        (DWORD_PTR) MyHelpIds );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\flpage.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: FLPage.h
// author: DMihai
// created: 11/1/00
//
// Description:
//  

#if !defined(AFX_FLPAGE_H__3D3D85C5_AC1B_4D20_8FF1_1D2EE9908ACC__INCLUDED_)
#define AFX_FLPAGE_H__3D3D85C5_AC1B_4D20_8FF1_1D2EE9908ACC__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// FLPage.h : header file
//

#include "VerfPage.h"

/////////////////////////////////////////////////////////////////////////////
// CFullListSettingsPage dialog

class CFullListSettingsPage : public CVerifierPropertyPage
{
	DECLARE_DYNCREATE(CFullListSettingsPage)

public:
    //
    // Construction
    //

	CFullListSettingsPage();
	~CFullListSettingsPage();

    //
    // Methods
    //

    VOID SetParentSheet( CPropertySheet *pParentSheet )
    {
        m_pParentSheet = pParentSheet;
        ASSERT( m_pParentSheet != NULL );
    }

    VOID SetupListHeader();
    VOID FillTheList();
    VOID AddListItem( INT nItemData, 
                      ULONG uIdResourceString );

    BOOL GetNewVerifierFlags();
    BOOL GetCheckFromItemData( INT nItemData );
    BOOL GetBitNameFromItemData( LPARAM lParam,
                                 TCHAR *szName,
                                 ULONG uNameBufferLength );

    VOID SortTheList();
    BOOL GetColumnStrValue( LPARAM lItemData, 
                            CString &strName );

    static int CALLBACK StringCmpFunc( LPARAM lParam1,
                                       LPARAM lParam2,
                                       LPARAM lParamSort);

    static int CALLBACK CheckedStatusCmpFunc( LPARAM lParam1,
                                              LPARAM lParam2,
                                              LPARAM lParamSort);

protected:
    //
    // Data
    //

    CPropertySheet      *m_pParentSheet;

    INT m_nSortColumnIndex;        // selected status (0) or settings name (1)
    BOOL m_bAscendSortSelected;    // sort ascendent the selected status
    BOOL m_bAscendSortName;        // sort ascendent the settings name

    //
    // Dialog Data
    //

    BOOL m_bSPool;
    BOOL m_bPoolTrack;
    BOOL m_bIrqLevel;
    BOOL m_bIoVerif;
    BOOL m_bEnhIoVerif;
    BOOL m_bDeadlock;
    BOOL m_bDMA;
    BOOL m_bLowRes;

    //{{AFX_DATA(CFullListSettingsPage)
	enum { IDD = IDD_FULL_LIST_SETT_PAGE };
	CListCtrl	m_SettingsList;
	CStatic	m_NextDescription;
	//}}AFX_DATA


    //
    // Overrides
    //

    //
    // All the property pages derived from this class should 
    // provide these methods.
    //

    virtual ULONG GetDialogId() const { return IDD; }

    //
    // ClassWizard generated virtual function overrides
    //

    //{{AFX_VIRTUAL(CFullListSettingsPage)
    public:
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CFullListSettingsPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnColumnclickFlsettList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg LONG OnHelp( WPARAM wParam, LPARAM lParam );
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FLPAGE_H__3D3D85C5_AC1B_4D20_8FF1_1D2EE9908ACC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\gcntpage.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: GCntPage.cpp
// author: DMihai
// created: 11/1/00
//
// Description:
//

#include "stdafx.h"
#include "verifier.h"

#include "GCntPage.h"
#include "VrfUtil.h"
#include "VGlobal.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Timer ID
//

#define REFRESH_TIMER_ID    0x1234

//
// Help IDs
//

static DWORD MyHelpIds[] =
{
    IDC_GLOBC_LIST,                 IDH_DV_GlobalCounters,
    0,                              0
};

/////////////////////////////////////////////////////////////////////////////
// CGlobalCountPage property page

IMPLEMENT_DYNCREATE(CGlobalCountPage, CVerifierPropertyPage)

CGlobalCountPage::CGlobalCountPage() : CVerifierPropertyPage(CGlobalCountPage::IDD)
{
	//{{AFX_DATA_INIT(CGlobalCountPage)
	//}}AFX_DATA_INIT

    m_nSortColumnIndex = 0;
    m_bAscendSortName = FALSE;
    m_bAscendSortValue = FALSE;

    m_uTimerHandler = 0;

    m_pParentSheet = NULL;
}

CGlobalCountPage::~CGlobalCountPage()
{
}

void CGlobalCountPage::DoDataExchange(CDataExchange* pDX)
{
    static BOOL bShownPoolCoverageWarning = FALSE;

    if( ! pDX->m_bSaveAndValidate )
    {
        //
        // Query the kernel
        //

        VrfGetRuntimeVerifierData( &m_RuntimeVerifierData );

        if( FALSE == bShownPoolCoverageWarning )
        {
            bShownPoolCoverageWarning = CheckAndShowPoolCoverageWarning();
        }
    }

    CVerifierPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CGlobalCountPage)
    DDX_Control(pDX, IDC_GLOBC_LIST, m_CountersList);
    DDX_Control(pDX, IDC_GLOBC_NEXT_DESCR_STATIC, m_NextDescription);
    //}}AFX_DATA_MAP
}



BEGIN_MESSAGE_MAP(CGlobalCountPage, CVerifierPropertyPage)
    //{{AFX_MSG_MAP(CGlobalCountPage)
    ON_WM_TIMER()
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_GLOBC_LIST, OnColumnclickGlobcList)
    ON_WM_CONTEXTMENU()
    ON_MESSAGE( WM_HELP, OnHelp )
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////

VOID CGlobalCountPage::SetupListHeader()
{
    LVCOLUMN lvColumn;
    CRect rectWnd;
    CString strCounter, strValue;
    
    VERIFY( strCounter.LoadString( IDS_COUNTER ) );
    VERIFY( strValue.LoadString( IDS_VALUE ) );

    //
    // List's regtangle
    //

    m_CountersList.GetClientRect( &rectWnd );
    
    //
    // Column 0 - counter
    //

    ZeroMemory( &lvColumn, sizeof( lvColumn ) );
    lvColumn.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;
    
    lvColumn.iSubItem = 0;
    lvColumn.pszText = strCounter.GetBuffer( strCounter.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.50 );
    VERIFY( m_CountersList.InsertColumn( 0, &lvColumn ) != -1 );
    strCounter.ReleaseBuffer();

    //
    // Column 1
    //

    lvColumn.iSubItem = 1;
    lvColumn.pszText = strValue.GetBuffer( strValue.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.47 );
    VERIFY( m_CountersList.InsertColumn( 1, &lvColumn ) != -1 );
    strValue.ReleaseBuffer();
}

/////////////////////////////////////////////////////////////
VOID CGlobalCountPage::FillTheList()
{
    //
    // N.B.
    //
    // If you change the first parameter (index - stored in the item's data) 
    // you need to change the switch statement in GetCounterValue as well
    //

    AddCounterInList( 0, IDS_ALLOCATIONSATTEMPTED_LIST,   m_RuntimeVerifierData.AllocationsAttempted );
    AddCounterInList( 1, IDS_ALLOCATIONSSUCCEEDED_LIST,   m_RuntimeVerifierData.AllocationsSucceeded );
    AddCounterInList( 2, IDS_ALLOCATIONSSUCCEEDEDSPECIALPOOL_LIST,    m_RuntimeVerifierData.AllocationsSucceededSpecialPool );
    AddCounterInList( 3, IDS_ALLOCATIONSWITHNOTAG_LIST,   m_RuntimeVerifierData.AllocationsWithNoTag );
    AddCounterInList( 4, IDS_UNTRACKEDPOOL_LIST,          m_RuntimeVerifierData.UnTrackedPool );
    AddCounterInList( 5, IDS_ALLOCATIONSFAILED_LIST,      m_RuntimeVerifierData.AllocationsFailed );
    AddCounterInList( 6, IDS_ALLOCATIONSFAILEDDELIBERATELY_LIST,      m_RuntimeVerifierData.AllocationsFailedDeliberately );
    AddCounterInList( 7, IDS_RAISEIRQLS_LIST,             m_RuntimeVerifierData.RaiseIrqls );
    AddCounterInList( 8, IDS_ACQUIRESPINLOCKS_LIST,       m_RuntimeVerifierData.AcquireSpinLocks );
    AddCounterInList( 9, IDS_SYNCHRONIZEEXECUTIONS_LIST,  m_RuntimeVerifierData.SynchronizeExecutions );
    AddCounterInList( 10, IDS_TRIMS_LIST,                 m_RuntimeVerifierData.Trims );
}

/////////////////////////////////////////////////////////////
VOID CGlobalCountPage::RefreshTheList()
{
    INT nListItems;
    INT nCrtListItem;
    INT_PTR nCrtCounterIndex;
    SIZE_T sizeValue;
 
    nListItems = m_CountersList.GetItemCount();

    for( nCrtListItem = 0; nCrtListItem < nListItems; nCrtListItem += 1 )
    {
        nCrtCounterIndex = m_CountersList.GetItemData( nCrtListItem );

        sizeValue = GetCounterValue( nCrtCounterIndex );

        UpdateCounterValueInList( nCrtListItem, sizeValue );
    }
}

/////////////////////////////////////////////////////////////
VOID CGlobalCountPage::SortTheList()
{
    if( 0 != m_nSortColumnIndex )
    {
        //
        // Sort by counter value - this is probably not very useful
        // but we are providing it to be consistent with all
        // the lists being sortable by any column
        //

        m_CountersList.SortItems( CounterValueCmpFunc, (LPARAM)this );
    }
    else
    {
        //
        // Sort by driver name
        //

        m_CountersList.SortItems( CounterNameCmpFunc, (LPARAM)this );
    }
}

/////////////////////////////////////////////////////////////
SIZE_T CGlobalCountPage::GetCounterValue( INT_PTR nCounterIndex )
{
    SIZE_T sizeValue;

    //
    // N.B. 
    //
    // If you change this switch statement you need to change FillTheList as well
    //

    switch( nCounterIndex )
    {
    case 0:
        sizeValue = m_RuntimeVerifierData.AllocationsAttempted;
        break;

    case 1:
        sizeValue = m_RuntimeVerifierData.AllocationsSucceeded;
        break;

    case 2:
        sizeValue = m_RuntimeVerifierData.AllocationsSucceededSpecialPool;
        break;

    case 3:
        sizeValue = m_RuntimeVerifierData.AllocationsWithNoTag;
        break;

    case 4:
        sizeValue = m_RuntimeVerifierData.UnTrackedPool;
        break;

    case 5:
        sizeValue = m_RuntimeVerifierData.AllocationsFailed;
        break;

    case 6:
        sizeValue = m_RuntimeVerifierData.AllocationsFailedDeliberately;
        break;

    case 7:
        sizeValue = m_RuntimeVerifierData.RaiseIrqls;
        break;

    case 8:
        sizeValue = m_RuntimeVerifierData.AcquireSpinLocks;
        break;

    case 9:
        sizeValue = m_RuntimeVerifierData.SynchronizeExecutions;
        break;

    case 10:
        sizeValue = m_RuntimeVerifierData.Trims;
        break;

    default:
        //
        // Oops, how did we get here ?!?
        //

        ASSERT( FALSE );

        sizeValue = 0;

        break;
    }

    return sizeValue;
}

/////////////////////////////////////////////////////////////
BOOL CGlobalCountPage::GetCounterName( LPARAM lItemData, 
                                       TCHAR *szCounterName,
                                       ULONG uCounterNameBufferLen )
{
    INT nItemIndex;
    BOOL bResult;
    LVFINDINFO FindInfo;
    LVITEM lvItem;

    bResult = FALSE;

    ZeroMemory( &FindInfo, sizeof( FindInfo ) );
    FindInfo.flags = LVFI_PARAM;
    FindInfo.lParam = lItemData;

    nItemIndex = m_CountersList.FindItem( &FindInfo );

    if( nItemIndex < 0 || nItemIndex > 10 )
    {
        ASSERT( FALSE );
    }
    else
    {
        //
        // Found our item - get the name
        //

        ZeroMemory( &lvItem, sizeof( lvItem ) );

        lvItem.mask = LVIF_TEXT;
        lvItem.iItem = nItemIndex;
        lvItem.iSubItem = 0;
        lvItem.pszText = szCounterName;
        lvItem.cchTextMax = uCounterNameBufferLen;

        bResult = m_CountersList.GetItem( &lvItem );
        
        if( bResult == FALSE )
        {
            //
            // Could not get the current item's attributes?!?
            //

            ASSERT( FALSE );
        }
    }

    return bResult;
}

/////////////////////////////////////////////////////////////
VOID CGlobalCountPage::AddCounterInList( INT nItemData, 
                                         ULONG  uIdResourceString,
                                         SIZE_T sizeValue )
{
    INT nActualIndex;
    LVITEM lvItem;
    CString strName;

    VERIFY( strName.LoadString( uIdResourceString ) );

    ZeroMemory( &lvItem, sizeof( lvItem ) );

    //
    // LVITEM's member pszText is not a const pointer 
    // so we need to GetBuffer here :-(
    //

    //
    // Sub-item 0 - counter's name
    //

    lvItem.pszText = strName.GetBuffer( strName.GetLength() + 1 );
    
    if( NULL == lvItem.pszText )
    {
        goto Done;
    }

    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.lParam = nItemData;
    lvItem.iItem = m_CountersList.GetItemCount();

    nActualIndex = m_CountersList.InsertItem( &lvItem );

    if( nActualIndex < 0 )
    {
        //
        // Could not add an item in the list - give up
        //

        goto Done;
    }

    //
    // Sub-item 1 - counter's value
    //
    
    UpdateCounterValueInList( nActualIndex,
                              sizeValue );

Done:
    //
    // All done
    //

    NOTHING;
}

/////////////////////////////////////////////////////////////
VOID CGlobalCountPage::RefreshInfo() 
{
    if( UpdateData( FALSE ) )
    {
        //
        // Refresh the settings bits list
        //

        RefreshTheList();
    }
}

/////////////////////////////////////////////////////////////
VOID CGlobalCountPage::UpdateCounterValueInList( INT nItemIndex,
                                                 SIZE_T sizeValue )
{
    TCHAR szValue[ 32 ];
    LVITEM lvItem;

#ifndef _WIN64

    //
    // 32 bit SIZE_T
    //

    _sntprintf( szValue,
                ARRAY_LENGTH( szValue ),
                _T( "%u" ),
                sizeValue );

#else

    //
    // 64 bit SIZE_T
    //

    _sntprintf( szValue,
                ARRAY_LENGTH( szValue ),
                _T( "%I64u" ),
                sizeValue );

#endif

    szValue[ ARRAY_LENGTH( szValue ) - 1 ] = 0;

    //
    // Update the list item
    //

    ZeroMemory( &lvItem, sizeof( lvItem ) );
    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = nItemIndex;
    lvItem.iSubItem = 1;
    lvItem.pszText = szValue;
    VERIFY( m_CountersList.SetItem( &lvItem ) );
}


/////////////////////////////////////////////////////////////
//
// Other methods
//

/////////////////////////////////////////////////////////////
#define MIN_MEM_SIZE_TO_DISABLE_WARNING 0x80000000  // 2 Gb
#define MIN_ALLOCATIONS_SIGNIFICANT     100
#define MIN_PERCENTAGE_AVOID_WARNING    95

BOOL CGlobalCountPage::CheckAndShowPoolCoverageWarning()
{
    BOOL bWarningDisplayed;
    ULONGLONG ullPercentageCoverage;
    TCHAR *szMessage;
    CString strMsgFormat;
    CString strWarnMsg;

    bWarningDisplayed = FALSE;

    if( m_RuntimeVerifierData.m_bSpecialPool &&
        m_RuntimeVerifierData.AllocationsSucceeded >= MIN_ALLOCATIONS_SIGNIFICANT  )
    {
        // 
        // Special pool verification is enabled &&
        // There is a significant number of allocations
        //

        ASSERT( m_RuntimeVerifierData.AllocationsSucceeded >= m_RuntimeVerifierData.AllocationsSucceededSpecialPool );

        //
        // The coverage percentage
        //

        ullPercentageCoverage = 
            ( (ULONGLONG)m_RuntimeVerifierData.AllocationsSucceededSpecialPool * (ULONGLONG) 100 ) / 
              (ULONGLONG)m_RuntimeVerifierData.AllocationsSucceeded;

        ASSERT( ullPercentageCoverage <= 100 );

        if( ullPercentageCoverage < MIN_PERCENTAGE_AVOID_WARNING )
        {
            //
            // Warn the user
            //

            if( strMsgFormat.LoadString( IDS_COVERAGE_WARNING_FORMAT ) )
            {
                szMessage = strWarnMsg.GetBuffer( strMsgFormat.GetLength() + 32 );

                if( szMessage != NULL )
                {
                    _stprintf( szMessage, (LPCTSTR)strMsgFormat, ullPercentageCoverage );
                    strWarnMsg.ReleaseBuffer();

                    AfxMessageBox( strWarnMsg,
                                   MB_OK | MB_ICONINFORMATION );
                }
            }
            else
            {
                ASSERT( FALSE );
            }

            bWarningDisplayed = TRUE;
        }
    }

    return bWarningDisplayed;
}

/////////////////////////////////////////////////////////////
int CALLBACK CGlobalCountPage::CounterValueCmpFunc( LPARAM lParam1,
                                                    LPARAM lParam2,
                                                    LPARAM lParamSort)
{
    SIZE_T size1;
    SIZE_T size2;
    int nCmpRez = 0;

    CGlobalCountPage *pThis = (CGlobalCountPage *)lParamSort;
    ASSERT_VALID( pThis );

    size1 = pThis->GetCounterValue( (INT) lParam1 );
    size2 = pThis->GetCounterValue( (INT) lParam2 );

    if( size1 > size2 )
    {
        nCmpRez = 1;
    }
    else
    {
        if( size1 < size2 )
        {
            nCmpRez = -1;
        }
    }

    if( FALSE != pThis->m_bAscendSortValue )
    {
        nCmpRez *= -1;
    }

    return nCmpRez;
}

/////////////////////////////////////////////////////////////
int CALLBACK CGlobalCountPage::CounterNameCmpFunc( LPARAM lParam1,
                                                   LPARAM lParam2,
                                                   LPARAM lParamSort)
{
    int nCmpRez = 0;
    BOOL bSuccess;
    TCHAR szCounterName1[ _MAX_PATH ];
    TCHAR szCounterName2[ _MAX_PATH ];

    CGlobalCountPage *pThis = (CGlobalCountPage *)lParamSort;
    ASSERT_VALID( pThis );

    //
    // Get the first counter name
    //

    bSuccess = pThis->GetCounterName( lParam1, 
                                      szCounterName1,
                                      ARRAY_LENGTH( szCounterName1 ) );

    if( FALSE == bSuccess )
    {
        goto Done;
    }

    //
    // Get the second counter name
    //

    bSuccess = pThis->GetCounterName( lParam2, 
                                      szCounterName2,
                                      ARRAY_LENGTH( szCounterName2 ) );

    if( FALSE == bSuccess )
    {
        goto Done;
    }

    //
    // Compare the names
    //

    nCmpRez = _tcsicmp( szCounterName1, szCounterName2 );
    
    if( FALSE != pThis->m_bAscendSortName )
    {
        nCmpRez *= -1;
    }

Done:

    return nCmpRez;
}

/////////////////////////////////////////////////////////////
// CGlobalCountPage message handlers

BOOL CGlobalCountPage::OnInitDialog() 
{
    CPropertyPage::OnInitDialog();

    //
    // Setup the settings bits list
    //

    m_CountersList.SetExtendedStyle( 
        LVS_EX_FULLROWSELECT | m_CountersList.GetExtendedStyle() );

    m_CountersList.SetBkColor( ::GetSysColor( COLOR_3DFACE ) );
    m_CountersList.SetTextBkColor( ::GetSysColor( COLOR_3DFACE ) );

    SetupListHeader();
    FillTheList();
    SortTheList();

    VrfSetWindowText( m_NextDescription, IDS_GCNT_PAGE_NEXT_DESCR );

    VERIFY( m_uTimerHandler = SetTimer( REFRESH_TIMER_ID, 
                                        5000,
                                        NULL ) );

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////
VOID CGlobalCountPage::OnTimer(UINT nIDEvent) 
{
    if( nIDEvent == REFRESH_TIMER_ID )
    {
        ASSERT_VALID( m_pParentSheet );

        if( m_pParentSheet->GetActivePage() == this )
        {
            //
            // Refresh the displayed data 
            //

            RefreshInfo();
        }
    }

    CPropertyPage::OnTimer(nIDEvent);
}

/////////////////////////////////////////////////////////////////////////////
BOOL CGlobalCountPage::OnSetActive() 
{
    ASSERT_VALID( m_pParentSheet );

    m_pParentSheet->SetWizardButtons(   PSWIZB_BACK |
                                        PSWIZB_NEXT );
    	
	return CVerifierPropertyPage::OnSetActive();
}

/////////////////////////////////////////////////////////////////////////////
LRESULT CGlobalCountPage::OnWizardNext() 
{
    GoingToNextPageNotify( IDD_PERDRIVER_COUNTERS_PAGE );

	return IDD_PERDRIVER_COUNTERS_PAGE;
}

/////////////////////////////////////////////////////////////////////////////
void CGlobalCountPage::OnColumnclickGlobcList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	
    if( 0 != pNMListView->iSubItem )
    {
        //
        // Clicked on the counter value column
        //

        if( m_nSortColumnIndex == pNMListView->iSubItem )
        {
            //
            // Change the current ascend/descend order for this column
            //

            m_bAscendSortValue = !m_bAscendSortValue;
        }
    }
    else
    {
        //
        // Clicked on the counter name column
        //

        if( m_nSortColumnIndex == pNMListView->iSubItem )
        {
            //
            // Change the current ascend/descend order for this column
            //

            m_bAscendSortName = !m_bAscendSortName;
        }
    }

    m_nSortColumnIndex = pNMListView->iSubItem;

    SortTheList();

    *pResult = 0;
}

/////////////////////////////////////////////////////////////
LONG CGlobalCountPage::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp( 
        (HWND) lpHelpInfo->hItemHandle,
        g_szVerifierHelpFile,
        HELP_WM_HELP,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}

/////////////////////////////////////////////////////////////////////////////
void CGlobalCountPage::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    ::WinHelp( 
        pWnd->m_hWnd,
        g_szVerifierHelpFile,
        HELP_CONTEXTMENU,
        (DWORD_PTR) MyHelpIds );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\regpage.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: RegPage.cpp
// author: DMihai
// created: 11/1/00
//
// Description:
//

#include "stdafx.h"
#include "verifier.h"

#include "RegPage.h"
#include "VGlobal.h"
#include "VrfUtil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Help IDs
//

static DWORD MyHelpIds[] =
{
    IDC_REGSETT_SETTBITS_LIST,      IDH_DV_SettingsEnabled_TestType,
    IDC_REGSETT_DRIVERS_LIST,       IDH_DV_VerifyAllDrivers_NameDesc,
    0,                              0
};

/////////////////////////////////////////////////////////////////////////////
// CCrtRegSettingsPage property page

IMPLEMENT_DYNCREATE(CCrtRegSettingsPage, CVerifierPropertyPage)

CCrtRegSettingsPage::CCrtRegSettingsPage() 
    : CVerifierPropertyPage(CCrtRegSettingsPage::IDD)
{
	//{{AFX_DATA_INIT(CCrtRegSettingsPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    //
    // Driver list sort parameters
    //

    m_nSortColumnIndexDrv = 0;
    m_bAscendDrvNameSort = FALSE;
    m_bAscendDrvDescrSort = FALSE;

    //
    // Settings bits sort parameters
    //

    m_nSortColumnIndexSettbits = 1;
    m_bAscendSortEnabledBits = FALSE;
    m_bAscendSortNameBits = FALSE;

    m_pParentSheet = NULL;
}

CCrtRegSettingsPage::~CCrtRegSettingsPage()
{
}

void CCrtRegSettingsPage::DoDataExchange(CDataExchange* pDX)
{
    CVerifierPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CCrtRegSettingsPage)
    DDX_Control(pDX, IDC_REGSETT_VERIFIED_DRV_STATIC, m_VerifiedDrvStatic);
    DDX_Control(pDX, IDC_REGSETT_NEXT_DESCR_STATIC, m_NextDescription);
    DDX_Control(pDX, IDC_REGSETT_SETTBITS_LIST, m_SettBitsList);
    DDX_Control(pDX, IDC_REGSETT_DRIVERS_LIST, m_DriversList);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCrtRegSettingsPage, CVerifierPropertyPage)
    //{{AFX_MSG_MAP(CCrtRegSettingsPage)
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_REGSETT_DRIVERS_LIST, OnColumnclickDriversList)
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_REGSETT_SETTBITS_LIST, OnColumnclickRegsettSettbitsList)
    ON_WM_CONTEXTMENU()
    ON_MESSAGE( WM_HELP, OnHelp )
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////
//
// Driver status list control methods
//

VOID CCrtRegSettingsPage::SetupListHeaderDrivers()
{
    LVCOLUMN lvColumn;
    CRect rectWnd;
    CString strName;
    CString strDescription;

    VERIFY( strName.LoadString( IDS_NAME ) );
    VERIFY( strDescription.LoadString( IDS_DESCRIPTION ) );

    //
    // List's regtangle
    //

    m_DriversList.GetClientRect( &rectWnd );
    
    //
    // Column 0
    //

    ZeroMemory( &lvColumn, sizeof( lvColumn ) );
    lvColumn.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;
    
    lvColumn.iSubItem = 0;
    lvColumn.pszText = strName.GetBuffer( strName.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.30 );
    VERIFY( m_DriversList.InsertColumn( 0, &lvColumn ) != -1 );
    strName.ReleaseBuffer();

    //
    // Column 1
    //

    lvColumn.iSubItem = 1;
    lvColumn.pszText = strDescription.GetBuffer( strDescription.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.70 );
    VERIFY( m_DriversList.InsertColumn( 1, &lvColumn ) != -1 );
    strDescription.ReleaseBuffer();
}

/////////////////////////////////////////////////////////////
VOID CCrtRegSettingsPage::FillTheListDrivers()
{
    LVITEM lvItem;
    int nActualIndex; 
    BOOL *pbAlreadyInList;
    int nItemCount;
    int nCrtListItem;
    INT_PTR nCrtVerifiedDriver;
    INT_PTR nDriversNo;
    TCHAR szDriverName[ _MAX_PATH ];
    BOOL bResult;
    CString strText;

    if( g_bAllDriversVerified )
    {
        VERIFY( m_DriversList.DeleteAllItems() );
        goto Done;
    }

    //
    // The number of drivers marked to be verified in the registry
    //

    nDriversNo = g_astrVerifyDriverNamesRegistry.GetSize();

    if( nDriversNo == 0 )
    {
        //
        // Clear the list
        //

        VERIFY( m_DriversList.DeleteAllItems() );
        goto Done;
    }

    //
    // There are some drivers marked to be verified in the registry
    //

    pbAlreadyInList = new BOOL[ nDriversNo ];
    
    if( pbAlreadyInList == NULL )
    {
        goto Done;
    }
    
    for( nCrtVerifiedDriver = 0; nCrtVerifiedDriver < nDriversNo; nCrtVerifiedDriver++)
    {
        pbAlreadyInList[ nCrtVerifiedDriver ] = FALSE;
    }

    //
    // Parse all the current list items
    //

    nItemCount = m_DriversList.GetItemCount();

    for( nCrtListItem = 0; nCrtListItem < nItemCount; nCrtListItem++ )
    {
        //
        // Get the current driver's name from the list
        //

        ZeroMemory( &lvItem, sizeof( lvItem ) );

        lvItem.mask = LVIF_TEXT;
        lvItem.iItem = nCrtListItem;
        lvItem.iSubItem = 0;
        lvItem.pszText = szDriverName;
        lvItem.cchTextMax = ARRAY_LENGTH( szDriverName );

        bResult = m_DriversList.GetItem( &lvItem );
        
        if( bResult == FALSE )
        {
            //
            // Could not get the current item's attributes?!?
            //

            ASSERT( FALSE );

            //
            // Remove this item from the list
            //

            VERIFY( m_DriversList.DeleteItem( nCrtListItem ) );

            nCrtListItem -= 1;
            nItemCount -= 1;
        }
        else
        {
            //
            // See is the current driver is still in g_astrVerifyDriverNamesRegistry
            //

            for( nCrtVerifiedDriver = 0; nCrtVerifiedDriver < nDriversNo; nCrtVerifiedDriver++)
            {
                if( g_astrVerifyDriverNamesRegistry.GetAt( nCrtVerifiedDriver ).CompareNoCase( szDriverName ) == 0 )
                {
                    //
                    // update the item's data with the current index in the array
                    //

                    lvItem.mask = LVIF_PARAM;
                    lvItem.lParam = nCrtVerifiedDriver;
                    
                    VERIFY( m_DriversList.SetItem( &lvItem ) != -1 );

                    //
                    // update the second column
                    //

                    UpdateDescriptionColumnDrivers( nCrtListItem, nCrtVerifiedDriver ); 

                    //
                    // mark the current driver as updated
                    //

                    pbAlreadyInList[ nCrtVerifiedDriver ] = TRUE;

                    break;
                }
            }

            //
            // If the driver is no longer verified, remove it from the list
            //

            if( nCrtVerifiedDriver >= nDriversNo )
            {
                VERIFY( m_DriversList.DeleteItem( nCrtListItem ) );

                nCrtListItem -= 1;
                nItemCount -= 1;
            }
        }
    }

    //
    // Add the drivers that were not in the list before this update
    //

    for( nCrtVerifiedDriver = 0; nCrtVerifiedDriver < nDriversNo; nCrtVerifiedDriver++)
    {
        if( ! pbAlreadyInList[ nCrtVerifiedDriver ] )
        {
            // 
            // add a new item for this
            //

            ZeroMemory( &lvItem, sizeof( lvItem ) );

            //
            // sub-item 0
            //

            lvItem.mask = LVIF_TEXT | LVIF_PARAM;
            lvItem.lParam = nCrtVerifiedDriver;
            lvItem.iItem = m_DriversList.GetItemCount();
            lvItem.iSubItem = 0;
            
            strText = g_astrVerifyDriverNamesRegistry.GetAt( nCrtVerifiedDriver );
            
            lvItem.pszText = strText.GetBuffer( strText.GetLength() + 1 );

            if( NULL != lvItem.pszText  )
            {
                nActualIndex = m_DriversList.InsertItem( &lvItem );
                
                VERIFY( nActualIndex != -1 );

                strText.ReleaseBuffer();

                //
                // sub-item 1
                //

                UpdateDescriptionColumnDrivers( nActualIndex, nCrtVerifiedDriver ); 
            }
        }
    }

    ASSERT( NULL != pbAlreadyInList );
    delete pbAlreadyInList;

Done:

    NOTHING;
}

/////////////////////////////////////////////////////////////
VOID CCrtRegSettingsPage::UpdateDescriptionColumnDrivers( INT_PTR nItemIndex, INT_PTR nCrtDriver )
{
    INT_PTR nInstalledDrivers;
    INT_PTR nCrtInstalledDriver;
    INT_PTR nNewDriverDataIndex;
    LVITEM lvItem;
    CString strDescription;
    CString strCrtDriverName;
    CDriverData *pCrtDriverData;
    CDriverDataArray &DriverDataArray = g_NewVerifierSettings.m_DriversSet.m_aDriverData;

    ASSERT( nItemIndex >= 0 && 
            nItemIndex < g_astrVerifyDriverNamesRegistry.GetSize() &&
            nItemIndex < m_DriversList.GetItemCount() &&
            nCrtDriver >= 0 &&
            nCrtDriver < g_astrVerifyDriverNamesRegistry.GetSize() &&
            nCrtDriver < m_DriversList.GetItemCount() );

    strCrtDriverName = g_astrVerifyDriverNamesRegistry.GetAt( nCrtDriver );

    ASSERT( strCrtDriverName.GetLength() > 0 );

    //
    // Search for this driver name in our g_NewVerifierSettings to get
    // the description
    //
    
    nInstalledDrivers = g_NewVerifierSettings.m_DriversSet.m_aDriverData.GetSize();

    for( nCrtInstalledDriver = 0; nCrtInstalledDriver < nInstalledDrivers; nCrtInstalledDriver += 1 )
    {
        pCrtDriverData = DriverDataArray.GetAt( nCrtInstalledDriver );

        ASSERT_VALID( pCrtDriverData );

        if( strCrtDriverName.CompareNoCase( pCrtDriverData->m_strName ) == 0 )
        {
            //
            // Found the driver version information
            //

            strDescription = pCrtDriverData->m_strFileDescription;

            break;
        }
    }

    if( nCrtInstalledDriver >= nInstalledDrivers )
    {
        //
        // Don't have already version information for this driver.
        // It may be one of the drivers that's not currently loaded so
        // try to get the version info.
        //

        nNewDriverDataIndex = g_NewVerifierSettings.m_DriversSet.AddNewDriverData( strCrtDriverName, TRUE );

        if( nNewDriverDataIndex >= 0 )
        {
            //
            // Force refreshing the unsigned driver data 
            //

            g_NewVerifierSettings.m_DriversSet.m_bUnsignedDriverDataInitialized = FALSE;

            //
            // Get the version information
            //

            pCrtDriverData = DriverDataArray.GetAt( nNewDriverDataIndex );

            ASSERT_VALID( pCrtDriverData );
            ASSERT( strCrtDriverName.CompareNoCase( pCrtDriverData->m_strName ) == 0 );

            strDescription = pCrtDriverData->m_strFileDescription;
        }
    }

    if( strDescription.GetLength() == 0 )
    {
        //
        // Didn't find the version info for this driver
        //

        VERIFY( strDescription.LoadString( IDS_UNKNOWN ) );
    }

    //
    // Update the list item
    //

    ZeroMemory( &lvItem, sizeof( lvItem ) );
    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = (INT)nItemIndex;
    lvItem.iSubItem = 1;
    lvItem.pszText = strDescription.GetBuffer( strDescription.GetLength() + 1 );
    VERIFY( m_DriversList.SetItem( &lvItem ) );
    strDescription.ReleaseBuffer();
}

/////////////////////////////////////////////////////////////
int CALLBACK CCrtRegSettingsPage::DrvStringCmpFunc(
    LPARAM lParam1, 
    LPARAM lParam2, 
    LPARAM lParamSort)
{
    CCrtRegSettingsPage *pThis = (CCrtRegSettingsPage *)lParamSort;
    ASSERT_VALID( pThis );

    return pThis->ListStrCmpFunc( lParam1,
                                  lParam2,
                                  pThis->m_DriversList,
                                  pThis->m_nSortColumnIndexDrv,
                                  (0 == pThis->m_nSortColumnIndexDrv) ? 
                                        pThis->m_bAscendDrvNameSort : pThis->m_bAscendDrvDescrSort );
}

/////////////////////////////////////////////////////////////
int CALLBACK CCrtRegSettingsPage::SettbitsStringCmpFunc(
    LPARAM lParam1, 
    LPARAM lParam2, 
    LPARAM lParamSort)
{
    CCrtRegSettingsPage *pThis = (CCrtRegSettingsPage *)lParamSort;
    ASSERT_VALID( pThis );

    return pThis->ListStrCmpFunc( lParam1,
                                  lParam2,
                                  pThis->m_SettBitsList,
                                  pThis->m_nSortColumnIndexSettbits,
                                  (0 == pThis->m_nSortColumnIndexSettbits) ? 
                                        pThis->m_bAscendSortEnabledBits : pThis->m_bAscendSortNameBits );
}

/////////////////////////////////////////////////////////////
int CCrtRegSettingsPage::ListStrCmpFunc(
    LPARAM lParam1, 
    LPARAM lParam2, 
    CListCtrl &theList,
    INT nSortColumnIndex,
    BOOL bAscending )
{
    int nCmpRez = 0;
    BOOL bSuccess;
    TCHAR szName1[ _MAX_PATH ];
    TCHAR szName2[ _MAX_PATH ];

    //
    // Get the first name
    //

    bSuccess = GetNameFromItemData( theList,
                                    nSortColumnIndex,
                                    lParam1,
                                    szName1,
                                    ARRAY_LENGTH( szName1 ) );

    if( FALSE == bSuccess )
    {
        ASSERT( FALSE );

        goto Done;
    }

    //
    // Get the second name
    //

    bSuccess = GetNameFromItemData( theList,
                                    nSortColumnIndex,
                                    lParam2,
                                    szName2,
                                    ARRAY_LENGTH( szName2 ) );

    if( FALSE == bSuccess )
    {
        ASSERT( FALSE );

        goto Done;
    }

    //
    // Compare the names
    //

    nCmpRez = _tcsicmp( szName1, szName2 );

    if( FALSE != bAscending )
    {
        nCmpRez *= -1;
    }

Done:

    return nCmpRez;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CCrtRegSettingsPage::GetNameFromItemData( CListCtrl &theList,
                                               INT nColumnIndex,
                                               LPARAM lParam,
                                               TCHAR *szName,
                                               ULONG uNameBufferLength )
{
    BOOL bSuccess = FALSE;
    INT nItemIndex;
    LVFINDINFO FindInfo;
    LVITEM lvItem;

    ZeroMemory( &FindInfo, sizeof( FindInfo ) );
    FindInfo.flags = LVFI_PARAM;
    FindInfo.lParam = lParam;

    nItemIndex = theList.FindItem( &FindInfo );

    if( nItemIndex >= 0 )
    {
        //
        // Found it
        //

        ZeroMemory( &lvItem, sizeof( lvItem ) );

        lvItem.mask = LVIF_TEXT;
        lvItem.iItem = nItemIndex;
        lvItem.iSubItem = nColumnIndex;
        lvItem.pszText = szName;
        lvItem.cchTextMax = uNameBufferLength;

        bSuccess = theList.GetItem( &lvItem );
        
        if( FALSE == bSuccess )
        {
            //
            // Could not get the current item's attributes?!?
            //

            ASSERT( FALSE );
        }
    }

    return bSuccess;
}

/////////////////////////////////////////////////////////////
//
// Settings bits list control methods
//

VOID CCrtRegSettingsPage::SetupListHeaderDriversSettBits()
{
    CString strTitle;
    CRect rectWnd;
    LVCOLUMN lvColumn;

    //
    // The list's rectangle 
    //

    m_SettBitsList.GetClientRect( &rectWnd );

    ZeroMemory( &lvColumn, 
               sizeof( lvColumn ) );

    lvColumn.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;

    //
    // Column 0
    //

    VERIFY( strTitle.LoadString( IDS_ENABLED_QUESTION ) );

    lvColumn.iSubItem = 0;
    lvColumn.pszText = strTitle.GetBuffer( strTitle.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.25 );
    VERIFY( m_SettBitsList.InsertColumn( 0, &lvColumn ) != -1 );
    strTitle.ReleaseBuffer();

    //
    // Column 1
    //

    VERIFY( strTitle.LoadString( IDS_SETTING ) );

    lvColumn.iSubItem = 1;
    lvColumn.pszText = strTitle.GetBuffer( strTitle.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.75 );
    VERIFY( m_SettBitsList.InsertColumn( 1, &lvColumn ) != -1 );
    strTitle.ReleaseBuffer();
}

/////////////////////////////////////////////////////////////
VOID CCrtRegSettingsPage::FillTheListSettBits()
{
    //
    // N.B. 
    //
    // If you change this order you need to change IsSettBitEnabled as well
    //

    AddListItemSettBits( 0, 0 != ( g_dwVerifierFlagsRegistry & DRIVER_VERIFIER_SPECIAL_POOLING),           IDS_SPECIAL_POOL  );
    AddListItemSettBits( 1, 0 != ( g_dwVerifierFlagsRegistry & DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS),    IDS_POOL_TRACKING );
    AddListItemSettBits( 2, 0 != ( g_dwVerifierFlagsRegistry & DRIVER_VERIFIER_FORCE_IRQL_CHECKING),       IDS_FORCE_IRQL_CHECKING );
    AddListItemSettBits( 3, 0 != ( g_dwVerifierFlagsRegistry & DRIVER_VERIFIER_IO_CHECKING),               IDS_IO_VERIFICATION );
    AddListItemSettBits( 4, 0 != ( g_dwVerifierFlagsRegistry & DRIVER_VERIFIER_ENHANCED_IO_CHECKING),      IDS_ENH_IO_VERIFICATION );
    AddListItemSettBits( 5, 0 != ( g_dwVerifierFlagsRegistry & DRIVER_VERIFIER_DEADLOCK_DETECTION),        IDS_DEADLOCK_DETECTION );
    AddListItemSettBits( 6, 0 != ( g_dwVerifierFlagsRegistry & DRIVER_VERIFIER_DMA_VERIFIER),              IDS_DMA_CHECHKING );
    AddListItemSettBits( 7, 0 != ( g_dwVerifierFlagsRegistry & DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES),IDS_LOW_RESOURCE_SIMULATION );
}

/////////////////////////////////////////////////////////////
VOID CCrtRegSettingsPage::RefreshListSettBits()
{
    INT nListItems;
    INT nCrtListItem;
    INT_PTR nCrtVerifierBit;
    BOOL bEnabled;
 
    nListItems = m_SettBitsList.GetItemCount();

    for( nCrtListItem = 0; nCrtListItem < nListItems; nCrtListItem += 1 )
    {
        nCrtVerifierBit = m_SettBitsList.GetItemData( nCrtListItem );

        bEnabled = IsSettBitEnabled( nCrtVerifierBit );

        UpdateStatusColumnSettBits( nCrtListItem, bEnabled );
    }
}

/////////////////////////////////////////////////////////////////////////////
BOOL CCrtRegSettingsPage::IsSettBitEnabled( INT_PTR nBitIndex )
{
    BOOL bEnabled;

    //
    // N.B. 
    //
    // If you change this switch statement you need to change FillTheListSettBits as well
    //

    switch( nBitIndex )
    {
    case 0:
        bEnabled = ( 0 != ( g_dwVerifierFlagsRegistry & DRIVER_VERIFIER_SPECIAL_POOLING) );
        break;

    case 1:
        bEnabled = ( 0 != ( g_dwVerifierFlagsRegistry & DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS) );
        break;

    case 2:
        bEnabled = ( 0 != ( g_dwVerifierFlagsRegistry & DRIVER_VERIFIER_FORCE_IRQL_CHECKING) );
        break;

    case 3:
        bEnabled = ( 0 != ( g_dwVerifierFlagsRegistry & DRIVER_VERIFIER_IO_CHECKING) );
        break;

    case 4:
        bEnabled = ( 0 != ( g_dwVerifierFlagsRegistry & DRIVER_VERIFIER_ENHANCED_IO_CHECKING) );
        break;

    case 5:
        bEnabled = ( 0 != ( g_dwVerifierFlagsRegistry & DRIVER_VERIFIER_DEADLOCK_DETECTION) );
        break;

    case 6:
        bEnabled = ( 0 != ( g_dwVerifierFlagsRegistry & DRIVER_VERIFIER_DMA_VERIFIER) );
        break;

    case 7:
        bEnabled = ( 0 != ( g_dwVerifierFlagsRegistry & DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES) );
        break;

    default:
        //
        // Oops, how did we get here ?!?
        //

        ASSERT( FALSE );

        bEnabled = FALSE;

        break;
    }

    return bEnabled;
}


/////////////////////////////////////////////////////////////////////////////
VOID CCrtRegSettingsPage::AddListItemSettBits( INT nItemData,
                                               BOOL bEnabled, 
                                               ULONG uIdResourceString )
{
    INT nActualIndex;
    LVITEM lvItem;
    CString strText;

    ZeroMemory( &lvItem, sizeof( lvItem ) );

    //
    // LVITEM's member pszText is not a const pointer 
    // so we need to GetBuffer here :-(
    //

    //
    // Sub-item 0 - enabled/diabled 
    //

    if( FALSE == bEnabled )
    {
        VERIFY( strText.LoadString( IDS_NO ) );
    }
    else
    {
        VERIFY( strText.LoadString( IDS_YES ) );
    }

    lvItem.pszText = strText.GetBuffer( strText.GetLength() + 1 );

    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.lParam = nItemData;
    lvItem.iItem = m_SettBitsList.GetItemCount();

    nActualIndex = m_SettBitsList.InsertItem( &lvItem );

    strText.ReleaseBuffer();

    if( nActualIndex < 0 )
    {
        //
        // Could not add an item in the list - give up
        //

        goto Done;
    }

    //
    // Sub-item 1 - feature name
    //

    VERIFY( strText.LoadString( uIdResourceString ) );

    lvItem.pszText = strText.GetBuffer( strText.GetLength() + 1 );
    
    if( NULL == lvItem.pszText )
    {
        goto Done;
    }

    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = nActualIndex;
    lvItem.iSubItem = 1;
    
    VERIFY( m_SettBitsList.SetItem( &lvItem ) );

    strText.ReleaseBuffer();

Done:
    //
    // All done
    //

    NOTHING;
}

/////////////////////////////////////////////////////////////
VOID CCrtRegSettingsPage::UpdateStatusColumnSettBits( INT nItemIndex, BOOL bEnabled )
{
    LVITEM lvItem;
    CString strText;

    ASSERT( nItemIndex < m_SettBitsList.GetItemCount() );

    if( FALSE == bEnabled )
    {
        VERIFY( strText.LoadString( IDS_NO ) );
    }
    else
    {
        VERIFY( strText.LoadString( IDS_YES ) );
    }

    ZeroMemory( &lvItem, sizeof( lvItem ) );
    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = nItemIndex;
    lvItem.iSubItem = 0;
    lvItem.pszText = strText.GetBuffer( strText.GetLength() + 1 );
    VERIFY( m_SettBitsList.SetItem( &lvItem ) );
    strText.ReleaseBuffer();
}

/////////////////////////////////////////////////////////////
//
// Other methods
//

/////////////////////////////////////////////////////////////
VOID CCrtRegSettingsPage::SortTheListDrivers()
{
    m_DriversList.SortItems( DrvStringCmpFunc, (LPARAM)this );
}

/////////////////////////////////////////////////////////////
VOID CCrtRegSettingsPage::SortTheListSettBits()
{
    m_SettBitsList.SortItems( SettbitsStringCmpFunc, (LPARAM)this );
}

/////////////////////////////////////////////////////////////
// CCrtRegSettingsPage message handlers

BOOL CCrtRegSettingsPage::OnInitDialog() 
{
    CPropertyPage::OnInitDialog();

    //
    // Setup the settings bits list
    //

    m_SettBitsList.SetExtendedStyle( 
        LVS_EX_FULLROWSELECT | m_SettBitsList.GetExtendedStyle() );

    m_SettBitsList.SetBkColor( ::GetSysColor( COLOR_3DFACE ) );
    m_SettBitsList.SetTextBkColor( ::GetSysColor( COLOR_3DFACE ) );

    SetupListHeaderDriversSettBits();
    FillTheListSettBits();
    //SortTheListSettBits();

    //
    // Setup the drivers list
    //

    m_DriversList.SetExtendedStyle( 
        LVS_EX_FULLROWSELECT | m_DriversList.GetExtendedStyle() );

    m_DriversList.SetBkColor( ::GetSysColor( COLOR_3DFACE ) );
    m_DriversList.SetTextBkColor( ::GetSysColor( COLOR_3DFACE ) );

    SetupListHeaderDrivers();

    VrfSetWindowText( m_NextDescription, IDS_REGSETT_PAGE_NEXT_DESCR );

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////////////
BOOL CCrtRegSettingsPage::OnSetActive() 
{
    CString strDriversToVerify;
    ASSERT_VALID( m_pParentSheet );

    m_pParentSheet->SetWizardButtons(   PSWIZB_BACK |
                                        PSWIZB_FINISH );
    
    //
    // Update the settings list
    //
    
    RefreshListSettBits();

    //
    // Update the drivers list
    //

    FillTheListDrivers();
    SortTheListDrivers();

    //
    // Verify all or verify selected drivers
    //

    if( g_bAllDriversVerified )
    {
        VERIFY( strDriversToVerify.LoadString( IDS_ALL_LOADED_DRIVERS ) );
    }
    else
    {
        VERIFY( strDriversToVerify.LoadString( IDS_FOLLOWING_DRIVERS ) );
    }
        
    m_VerifiedDrvStatic.SetWindowText( strDriversToVerify );

    return CVerifierPropertyPage::OnSetActive();
}

/////////////////////////////////////////////////////////////
VOID CCrtRegSettingsPage::OnColumnclickDriversList(NMHDR* pNMHDR, 
                                                   LRESULT* pResult) 
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    if( 0 == pNMListView->iSubItem )
    {
        if( m_nSortColumnIndexDrv == pNMListView->iSubItem )
        {
            m_bAscendDrvNameSort = !m_bAscendDrvNameSort;
        }
    }
    else
    {
        if( m_nSortColumnIndexDrv == pNMListView->iSubItem )
        {
            m_bAscendDrvDescrSort = !m_bAscendDrvDescrSort;
        }
    }

    m_nSortColumnIndexDrv = pNMListView->iSubItem;

    SortTheListDrivers();

    *pResult = 0;
}

/////////////////////////////////////////////////////////////
void CCrtRegSettingsPage::OnColumnclickRegsettSettbitsList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    if( 0 == pNMListView->iSubItem )
    {
        if( m_nSortColumnIndexSettbits == pNMListView->iSubItem )
        {
            m_bAscendSortEnabledBits = !m_bAscendSortEnabledBits;
        }
    }
    else
    {
        if( m_nSortColumnIndexSettbits == pNMListView->iSubItem )
        {
            m_bAscendSortNameBits = !m_bAscendSortNameBits;
        }
    }

    m_nSortColumnIndexSettbits = pNMListView->iSubItem;

    SortTheListSettBits();

    *pResult = 0;
}

/////////////////////////////////////////////////////////////
LONG CCrtRegSettingsPage::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp( 
        (HWND) lpHelpInfo->hItemHandle,
        g_szVerifierHelpFile,
        HELP_WM_HELP,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}

/////////////////////////////////////////////////////////////////////////////
void CCrtRegSettingsPage::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    ::WinHelp( 
        pWnd->m_hWnd,
        g_szVerifierHelpFile,
        HELP_CONTEXTMENU,
        (DWORD_PTR) MyHelpIds );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\progctrl.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: ProgCtrl.cpp
// author: DMihai
// created: 11/1/00
//
// Description:
//

#include "stdafx.h"
#include "verifier.h"
#include "ProgCtrl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CVrfProgressCtrl

CVrfProgressCtrl::CVrfProgressCtrl()
{
}

CVrfProgressCtrl::~CVrfProgressCtrl()
{
}


BEGIN_MESSAGE_MAP(CVrfProgressCtrl, CProgressCtrl)
	//{{AFX_MSG_MAP(CVrfProgressCtrl)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CVrfProgressCtrl message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\helpids.h ===
// Driver Verifier "Select a Task" screen

#define	IDH_DV_Settings_standard		800100
#define	IDH_DV_Settings_custom			800105
#define	IDH_DV_Settings_deleteexisting		800110
#define	IDH_DV_Settings_displayexisting		800115
#define	IDH_DV_Settings_displaycurrent		800120

// Driver Verifier "Select what driver to verify" screen

#define	IDH_DV_SelectUnsigned			800125
#define	IDH_DV_SelectOlderversions		800130
#define	IDH_DV_SelectAll			800135
#define	IDH_DV_SelectFromList			800140

// Driver Verifier "The list of unsigned drivers chosen to be verified" screen

#define	IDH_DV_UnsignedDriversList		800150

// Driver Verifier "Create custom settings" screen

#define	IDH_DV_EnablePredefined			800155
#define	IDH_DV_Standard				800160
#define	IDH_DV_Rigorous				800165
#define	IDH_DV_LowResource			800170
#define	IDH_DV_IndividualSettings		800175

// Driver Verifier "Select drivers to verify" screen

#define	IDH_DV_SelectDriversToVerify		800180
#define	IDH_DV_Addbut_UnloadedDrivers		800185

// Driver Verifier "Settings and verified drivers" screen

#define	IDH_DV_SettingsEnabled_TestType		800190
#define	IDH_DV_VerifyAllDrivers_NameDesc	800195

// Driver Verifier "Select individual settings from this full list" screen

#define	IDH_DV_SettingsEnabled_TestType_FullList		800198

// Driver Verifier "Current settings and verified drivers (run time info)" screen

#define	IDH_DV_CurrentSettings			800200
#define	IDH_DV_CurrentVerifiedDrivers		800205
#define	IDH_DV_Changebut			800210
#define	IDH_DV_Addbut				800215
#define	IDH_DV_Removebut			800220

// Driver Verifier "Global counters" screen

#define	IDH_DV_GlobalCounters			800225

// Driver Verifier "Counters specific to each of the currently verified drivers" screen

#define	IDH_DV_Counters_DriverList		800230
#define	IDH_DV_DriverCounters			800235
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\regpage.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: RegPage.h
// author: DMihai
// created: 11/1/00
//
// Description:
//

#if !defined(AFX_REGPAGE_H__CB260019_060D_45DC_8BB3_95DB1CB7B8F4__INCLUDED_)
#define AFX_REGPAGE_H__CB260019_060D_45DC_8BB3_95DB1CB7B8F4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// RegPage.h : header file
//

#include "VerfPage.h"

/////////////////////////////////////////////////////////////////////////////
// CCrtRegSettingsPage dialog

class CCrtRegSettingsPage : public CVerifierPropertyPage
{
	DECLARE_DYNCREATE(CCrtRegSettingsPage)

    //
    // Construction
    //
public:
	CCrtRegSettingsPage();
	~CCrtRegSettingsPage();

protected:
    //
    // Data
    //

    CPropertySheet *m_pParentSheet;

    //
    // Runtime data (obtained from the kernel)
    //

    CRuntimeVerifierData m_RuntimeVerifierData; 

    //
    // Driver list sort parameters
    //

    INT m_nSortColumnIndexDrv;      // sort by name (0) or by status (1)
    BOOL m_bAscendDrvNameSort;      // sort ascendent by name
    BOOL m_bAscendDrvDescrSort;     // sort ascendent by description

    //
    // Settings bits sort parameters
    //

    INT m_nSortColumnIndexSettbits; // sort by enabled/disabled (0) or by bit name (1)
    BOOL m_bAscendSortEnabledBits;  // sort ascendent by enabled/disabled
    BOOL m_bAscendSortNameBits;     // sort ascendent by bit name

    //
    // Dialog Data
    //

    //{{AFX_DATA(CCrtRegSettingsPage)
	enum { IDD = IDD_CRT_REGISTRY_SETTINGS_PAGE };
	CStatic	m_VerifiedDrvStatic;
	CStatic	m_NextDescription;
	CListCtrl	m_SettBitsList;
	CListCtrl	m_DriversList;
	//}}AFX_DATA

public:
    //
    // Methods
    //

    VOID SetParentSheet( CPropertySheet *pParentSheet )
    {
        m_pParentSheet = pParentSheet;
        ASSERT( m_pParentSheet != NULL );
    }

protected:
    //
    // Drivers list control methods
    //

    VOID SetupListHeaderDrivers();
    VOID FillTheListDrivers();
    VOID UpdateDescriptionColumnDrivers( INT_PTR nItemIndex, INT_PTR nCrtDriver );
    VOID SortTheListDrivers();
    VOID SortTheListSettBits();

    BOOL IsSettBitEnabled( INT_PTR nBitIndex );

    static int CALLBACK DrvStringCmpFunc(
        LPARAM lParam1,
        LPARAM lParam2,
        LPARAM lParamSort);

    static int CALLBACK SettbitsStringCmpFunc(
        LPARAM lParam1,
        LPARAM lParam2,
        LPARAM lParamSort);

    int ListStrCmpFunc(
        LPARAM lParam1, 
        LPARAM lParam2, 
        CListCtrl &theList,
        INT nSortColumnIndex,
        BOOL bAscending );

    BOOL GetNameFromItemData( CListCtrl &theList,
                              INT nColumnIndex,
                              LPARAM lParam,
                              TCHAR *szName,
                              ULONG uNameBufferLength );

    //
    // Settings bits list control methods
    //

    VOID SetupListHeaderDriversSettBits();
    VOID FillTheListSettBits();

    VOID AddListItemSettBits( INT nItemData,
                              BOOL bEnabled, 
                              ULONG uIdResourceString );
    
    VOID UpdateStatusColumnSettBits( INT nIndexInList, BOOL bEnabled );

    VOID RefreshListSettBits();

protected:
    //
    // Overrides
    //

    //
    // All the property pages derived from this class should 
    // provide these methods.
    //

    virtual ULONG GetDialogId() const { return IDD; }

    //
    // ClassWizard generate virtual function overrides
    //

    //{{AFX_VIRTUAL(CCrtRegSettingsPage)
    protected:
    virtual BOOL OnSetActive();
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
    // Generated message map functions
    //{{AFX_MSG(CCrtRegSettingsPage)
    virtual BOOL OnInitDialog();
    afx_msg VOID OnColumnclickDriversList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnColumnclickRegsettSettbitsList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg LONG OnHelp( WPARAM wParam, LPARAM lParam );
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_REGPAGE_H__CB260019_060D_45DC_8BB3_95DB1CB7B8F4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\progctrl.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: ProgCtrl.h
// author: DMihai
// created: 11/1/00
//
// Description:
//  

#if !defined(AFX_PROGCTRL_H__3F75E128_8721_4421_B96B_9961A9A3C5B0__INCLUDED_)
#define AFX_PROGCTRL_H__3F75E128_8721_4421_B96B_9961A9A3C5B0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ProgCtrl.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CVrfProgressCtrl window

class CVrfProgressCtrl : public CProgressCtrl
{
// Construction
public:
	CVrfProgressCtrl();

// Attributes
public:

// Operations
public:
    void SetRange32( INT_PTR nLower, INT_PTR nUpper )
    {
        ASSERT( ::IsWindow( m_hWnd ) );
        ::PostMessage( m_hWnd, PBM_SETRANGE32, (WPARAM) nLower, (LPARAM) nUpper);
    }

    int SetStep( INT_PTR nStep )
    {
        ASSERT(::IsWindow( m_hWnd) ); 
        return (int) ::PostMessage( m_hWnd, PBM_SETSTEP, nStep, 0L);
    }

    int SetPos(INT_PTR nPos)
    {
        ASSERT( ::IsWindow( m_hWnd ) );
        return (int) ::PostMessage(m_hWnd, PBM_SETPOS, nPos, 0L); 
    }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CVrfProgressCtrl)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CVrfProgressCtrl();

	// Generated message map functions
protected:
	//{{AFX_MSG(CVrfProgressCtrl)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROGCTRL_H__3F75E128_8721_4421_B96B_9961A9A3C5B0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\gcntpage.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: GCntPage.h
// author: DMihai
// created: 11/1/00
//
// Description:
//

#if !defined(AFX_GCNTPAGE_H__45E55738_381A_49A1_B2A7_6DD5B0BBFF9C__INCLUDED_)
#define AFX_GCNTPAGE_H__45E55738_381A_49A1_B2A7_6DD5B0BBFF9C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// GCntPage.h : header file
//

#include "VerfPage.h"

/////////////////////////////////////////////////////////////////////////////
// CGlobalCountPage dialog

class CGlobalCountPage : public CVerifierPropertyPage
{
	DECLARE_DYNCREATE(CGlobalCountPage)

public:
    //
    // Construction
    //
	
    CGlobalCountPage();
	~CGlobalCountPage();

public:
    //
    // Methods
    //

    VOID SetParentSheet( CPropertySheet *pParentSheet )
    {
        m_pParentSheet = pParentSheet;
        ASSERT( m_pParentSheet != NULL );
    }

protected:
    VOID SetupListHeader();

    VOID FillTheList();
    VOID RefreshTheList();
    VOID SortTheList();
    
    VOID AddCounterInList( INT nItemData, 
                           ULONG  uIdResourceString,
                           SIZE_T sizeValue );
    
    SIZE_T GetCounterValue( INT_PTR nCounterIndex );
    
    BOOL   GetCounterName( LPARAM lItemData, 
                           TCHAR *szCounterName,
                           ULONG uCounterNameBufferLen );

    VOID RefreshInfo();

    VOID UpdateCounterValueInList( INT nItemIndex,
                                   SIZE_T sizeValue );

    VOID OnRefreshTimerChanged();

    BOOL CheckAndShowPoolCoverageWarning();

    static int CALLBACK CounterValueCmpFunc(
        LPARAM lParam1,
        LPARAM lParam2,
        LPARAM lParamSort);

    static int CALLBACK CounterNameCmpFunc(
        LPARAM lParam1,
        LPARAM lParam2,
        LPARAM lParamSort);

protected:
    //
    // Data
    //

    CPropertySheet      *m_pParentSheet;

    //
    // Dialog Data
    //

    INT m_nSortColumnIndex;     // counter name (0) or counter value (1)
    BOOL m_bAscendSortName;     // sort ascendent the counter names
    BOOL m_bAscendSortValue;    // sort ascendent the counter values


    UINT_PTR m_uTimerHandler;   // timer handler, returned by SetTimer()

    //
    // Runtime data (obtained from the kernel)
    //

    CRuntimeVerifierData m_RuntimeVerifierData; 

    //
    // Dialog data
    //

    //{{AFX_DATA(CGlobalCountPage)
	enum { IDD = IDD_GLOBAL_COUNTERS_PAGE };
	CListCtrl	m_CountersList;
	CStatic	m_NextDescription;
	//}}AFX_DATA

protected:
    //
    // Overrides
    //

    //
    // All the property pages derived from this class should 
    // provide these methods.
    //

    virtual ULONG GetDialogId() const { return IDD; }

    //
    // ClassWizard generate virtual function overrides
    //

    //{{AFX_VIRTUAL(CGlobalCountPage)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CGlobalCountPage)
    virtual BOOL OnInitDialog();
    afx_msg VOID OnTimer(UINT nIDEvent);
    afx_msg void OnColumnclickGlobcList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg LONG OnHelp( WPARAM wParam, LPARAM lParam );
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GCNTPAGE_H__45E55738_381A_49A1_B2A7_6DD5B0BBFF9C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\sdrvpage.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: SDrvPage.cpp
// author: DMihai
// created: 11/1/00
//
// Description:
//

#include "stdafx.h"
#include <Cderr.h>
#include "verifier.h"

#include "SDrvPage.h"
#include "VrfUtil.h"
#include "VGlobal.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Help IDs
//

static DWORD MyHelpIds[] =
{
    IDC_SELDRV_LIST,                IDH_DV_SelectDriversToVerify,
    IDC_SELDRV_ADD_BUTTON,          IDH_DV_Addbut_UnloadedDrivers,
    0,                              0
};

/////////////////////////////////////////////////////////////////////////////
// CSelectDriversPage property page

IMPLEMENT_DYNCREATE(CSelectDriversPage, CVerifierPropertyPage)

CSelectDriversPage::CSelectDriversPage() 
    : CVerifierPropertyPage(CSelectDriversPage::IDD)
{
	//{{AFX_DATA_INIT(CSelectDriversPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    m_pParentSheet = NULL;

    m_nSortColumnIndex = 1;
    m_bAscendSortVerified = FALSE;
    m_bAscendSortDrvName = FALSE;
    m_bAscendSortProvName = FALSE;
    m_bAscendSortVersion = FALSE;
}

CSelectDriversPage::~CSelectDriversPage()
{
}

void CSelectDriversPage::DoDataExchange(CDataExchange* pDX)
{
    CVerifierPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CSelectDriversPage)
    DDX_Control(pDX, IDC_SELDRV_NEXT_DESCR_STATIC, m_NextDescription);
    DDX_Control(pDX, IDC_SELDRV_LIST, m_DriversList);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSelectDriversPage, CVerifierPropertyPage)
    //{{AFX_MSG_MAP(CSelectDriversPage)
    ON_BN_CLICKED(IDC_SELDRV_ADD_BUTTON, OnAddButton)
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_SELDRV_LIST, OnColumnclickSeldrvList)
    ON_WM_CONTEXTMENU()
    ON_MESSAGE( WM_HELP, OnHelp )
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
VOID CSelectDriversPage::SetupListHeader()
{
    CString strTitle;
    CRect rectWnd;
    LVCOLUMN lvColumn;

    //
    // The list's rectangle 
    //

    m_DriversList.GetClientRect( &rectWnd );

    ZeroMemory( &lvColumn, 
               sizeof( lvColumn ) );

    lvColumn.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;

    //
    // Column 0
    //

    VERIFY( strTitle.LoadString( IDS_VERIFICATION_STATUS ) );

    lvColumn.iSubItem = 0;
    lvColumn.pszText = strTitle.GetBuffer( strTitle.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.08 );
    VERIFY( m_DriversList.InsertColumn( 0, &lvColumn ) != -1 );
    strTitle.ReleaseBuffer();

    //
    // Column 1
    //

    VERIFY( strTitle.LoadString( IDS_DRIVERS ) );

    lvColumn.iSubItem = 1;
    lvColumn.pszText = strTitle.GetBuffer( strTitle.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.20 );
    VERIFY( m_DriversList.InsertColumn( 1, &lvColumn ) != -1 );
    strTitle.ReleaseBuffer();

    //
    // Column 2
    //

    VERIFY( strTitle.LoadString( IDS_PROVIDER ) );

    lvColumn.iSubItem = 2;
    lvColumn.pszText = strTitle.GetBuffer( strTitle.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.47 );
    VERIFY( m_DriversList.InsertColumn( 2, &lvColumn ) != -1 );
    strTitle.ReleaseBuffer();

    //
    // Column 3
    //

    VERIFY( strTitle.LoadString( IDS_VERSION ) );

    lvColumn.iSubItem = 3;
    lvColumn.pszText = strTitle.GetBuffer( strTitle.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.22 );
    VERIFY( m_DriversList.InsertColumn( 3, &lvColumn ) != -1 );
    strTitle.ReleaseBuffer();
}

/////////////////////////////////////////////////////////////////////////////
VOID CSelectDriversPage::FillTheList()
{
    INT_PTR nDriversNo;
    INT_PTR nCrtDriverIndex;
    CDriverData *pCrtDrvData;
    const CDriverDataArray &DrvDataArray = g_NewVerifierSettings.m_DriversSet.m_aDriverData;

    m_DriversList.DeleteAllItems();

    //
    // Parse the driver data array
    //

    nDriversNo = DrvDataArray.GetSize();

    for( nCrtDriverIndex = 0; nCrtDriverIndex < nDriversNo; nCrtDriverIndex += 1)
    {
        pCrtDrvData = DrvDataArray.GetAt( nCrtDriverIndex );

        ASSERT_VALID( pCrtDrvData );

        AddListItem( nCrtDriverIndex, 
                     pCrtDrvData );
    }
}

/////////////////////////////////////////////////////////////////////////////
INT CSelectDriversPage::AddListItem( INT_PTR nIndexInArray, CDriverData *pCrtDrvData )
{
    INT nActualIndex;
    LVITEM lvItem;

    ASSERT_VALID( pCrtDrvData );

    nActualIndex = -1;

    ZeroMemory( &lvItem, sizeof( lvItem ) );

    //
    // LVITEM's member pszText is not a const pointer 
    // so we need to GetBuffer here :-(
    //

    //
    // Sub-item 0 - verification status - empty text and a checkbox
    //

    lvItem.pszText = g_szVoidText;
    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.lParam = nIndexInArray;
    lvItem.iItem = m_DriversList.GetItemCount();

    nActualIndex = m_DriversList.InsertItem( &lvItem );

    if( nActualIndex < 0 )
    {
        //
        // Could not add an item in the list - give up
        //

        goto Done;
    }

    m_DriversList.SetCheck( nActualIndex, FALSE );

    //
    // Sub-item 1 - driver name
    //

    lvItem.pszText = pCrtDrvData->m_strName.GetBuffer( pCrtDrvData->m_strName.GetLength() + 1 );
    
    if( NULL == lvItem.pszText )
    {
        goto Done;
    }

    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = nActualIndex;
    lvItem.iSubItem = 1;
    
    VERIFY( m_DriversList.SetItem( &lvItem ) );

    pCrtDrvData->m_strName.ReleaseBuffer();

    //
    // Sub-item 2 - provider
    //

    lvItem.pszText = pCrtDrvData->m_strCompanyName.GetBuffer( 
        pCrtDrvData->m_strCompanyName.GetLength() + 1 );
    
    if( NULL == lvItem.pszText )
    {
        goto Done;
    }

    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = nActualIndex;
    lvItem.iSubItem = 2;

    VERIFY( m_DriversList.SetItem( &lvItem ) );
    
    pCrtDrvData->m_strCompanyName.ReleaseBuffer();

    //
    // Sub-item 3 - version
    //

    lvItem.pszText = pCrtDrvData->m_strFileVersion.GetBuffer( 
        pCrtDrvData->m_strFileVersion.GetLength() + 1 );
    
    if( NULL == lvItem.pszText )
    {
        goto Done;
    }

    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = nActualIndex;
    lvItem.iSubItem = 3;

    VERIFY( m_DriversList.SetItem( &lvItem ) );
    
    pCrtDrvData->m_strFileVersion.ReleaseBuffer();

Done:
    //
    // All done
    //

    return nActualIndex;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CSelectDriversPage::GetNewVerifiedDriversList()
{
    INT nListItemCount; 
    INT nCrtListItem;
    INT_PTR nCrtDriversArrayIndex;
    BOOL bVerified;
    CDriverData *pCrtDrvData;
    const CDriverDataArray &DrvDataArray = g_NewVerifierSettings.m_DriversSet.m_aDriverData;
    CDriverData::VerifyDriverTypeEnum VerifyStatus;
    
    nListItemCount = m_DriversList.GetItemCount();

    for( nCrtListItem = 0; nCrtListItem < nListItemCount; nCrtListItem += 1 )
    {
        //
        // Verification status for the current list item
        //

        bVerified = m_DriversList.GetCheck( nCrtListItem );

        if( bVerified )
        {
            VerifyStatus = CDriverData::VerifyDriverYes;
        }
        else
        {
            VerifyStatus = CDriverData::VerifyDriverNo;
        }

        //
        // Set the right verify state in our driver array 
        //

        nCrtDriversArrayIndex = m_DriversList.GetItemData( nCrtListItem );

        pCrtDrvData = DrvDataArray.GetAt( nCrtDriversArrayIndex );

        ASSERT_VALID( pCrtDrvData );

        pCrtDrvData->m_VerifyDriverStatus = VerifyStatus;
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////
VOID CSelectDriversPage::SortTheList()
{
    if( 0 != m_nSortColumnIndex )
    {
        //
        // Sort by driver name, provider or version
        //

        m_DriversList.SortItems( StringCmpFunc, (LPARAM)this );
    }
    else
    {
        //
        // Sort by verified status
        //

        m_DriversList.SortItems( CheckedStatusCmpFunc, (LPARAM)this );
    }
}

/////////////////////////////////////////////////////////////
int CALLBACK CSelectDriversPage::StringCmpFunc( LPARAM lParam1,
                                                    LPARAM lParam2,
                                                    LPARAM lParamSort)
{
    int nCmpRez = 0;
    BOOL bSuccess;
    CString strName1;
    CString strName2;

    CSelectDriversPage *pThis = (CSelectDriversPage *)lParamSort;
    ASSERT_VALID( pThis );

    ASSERT( 0 != pThis->m_nSortColumnIndex );

    //
    // Get the first name
    //

    bSuccess = pThis->GetColumnStrValue( lParam1, 
                                         strName1 );

    if( FALSE == bSuccess )
    {
        goto Done;
    }

    //
    // Get the second name
    //

    bSuccess = pThis->GetColumnStrValue( lParam2, 
                                         strName2 );

    if( FALSE == bSuccess )
    {
        goto Done;
    }

    //
    // Compare the names
    //

    nCmpRez = strName1.CompareNoCase( strName2 );
    
    switch( pThis->m_nSortColumnIndex )
    {
    case 1:
        //
        // Sort by driver name
        //

        if( FALSE != pThis->m_bAscendSortDrvName )
        {
            nCmpRez *= -1;
        }

        break;

    case 2:
        //
        // Sort by provider name
        //

        if( FALSE != pThis->m_bAscendSortProvName )
        {
            nCmpRez *= -1;
        }

        break;

    case 3:
        //
        // Sort by version
        //

        if( FALSE != pThis->m_bAscendSortVersion )
        {
            nCmpRez *= -1;
        }

        break;

    default:
        //
        // Oops - how did we get here ?!?
        //

        ASSERT( FALSE );
        break;
    }

Done:

    return nCmpRez;

}

/////////////////////////////////////////////////////////////
int CALLBACK CSelectDriversPage::CheckedStatusCmpFunc( LPARAM lParam1,
                                                       LPARAM lParam2,
                                                       LPARAM lParamSort)
{
    int nCmpRez = 0;
    INT nItemIndex;
    BOOL bVerified1;
    BOOL bVerified2;
    LVFINDINFO FindInfo;

    CSelectDriversPage *pThis = (CSelectDriversPage *)lParamSort;
    ASSERT_VALID( pThis );

    ASSERT( 0 == pThis->m_nSortColumnIndex );

    //
    // Find the first item
    //

    ZeroMemory( &FindInfo, sizeof( FindInfo ) );
    FindInfo.flags = LVFI_PARAM;
    FindInfo.lParam = lParam1;

    nItemIndex = pThis->m_DriversList.FindItem( &FindInfo );

    if( nItemIndex < 0 )
    {
        ASSERT( FALSE );

        goto Done;
    }

    bVerified1 = pThis->m_DriversList.GetCheck( nItemIndex );

    //
    // Find the second item
    //

    FindInfo.flags = LVFI_PARAM;
    FindInfo.lParam = lParam2;

    nItemIndex = pThis->m_DriversList.FindItem( &FindInfo );

    if( nItemIndex < 0 )
    {
        ASSERT( FALSE );

        goto Done;
    }

    bVerified2 = pThis->m_DriversList.GetCheck( nItemIndex );

    //
    // Compare them
    //
    
    if( bVerified1 != bVerified2 )
    {
        if( FALSE != bVerified1 )
        {
            nCmpRez = 1;
        }
        else
        {
            nCmpRez = -1;
        }

        if( FALSE != pThis->m_bAscendSortVerified )
        {
            nCmpRez *= -1;
        }
    }

Done:

    return nCmpRez;

}

/////////////////////////////////////////////////////////////
BOOL CSelectDriversPage::GetColumnStrValue( LPARAM lItemData, 
                                                CString &strName )
{
    CDriverData *pCrtDrvData;

    pCrtDrvData = g_NewVerifierSettings.m_DriversSet.m_aDriverData.GetAt( (INT_PTR) lItemData );

    ASSERT_VALID( pCrtDrvData );
    
    switch( m_nSortColumnIndex )
    {
    case 1:
        //
        // Sort by driver name
        //

        strName = pCrtDrvData->m_strName;
        
        break;

    case 2:
        //
        // Sort by provider name
        //

        strName = pCrtDrvData->m_strCompanyName;

        break;

    case 3:
        //
        // Sort by version
        //

        strName = pCrtDrvData->m_strFileVersion;

        break;

    default:
        //
        // Oops - how did we get here ?!?
        //

        ASSERT( FALSE );
        break;

    }
    
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CSelectDriversPage::OnSetActive() 
{
    //
    // The wizard has at least one more step (display the summarry)
    //

    m_pParentSheet->SetWizardButtons(   PSWIZB_BACK |
                                        PSWIZB_FINISH );

    return CVerifierPropertyPage::OnSetActive();
}

/////////////////////////////////////////////////////////////////////////////
// CSelectDriversPage message handlers

BOOL CSelectDriversPage::OnInitDialog() 
{
	CVerifierPropertyPage::OnInitDialog();

    //
    // setup the list
    //

    m_DriversList.SetExtendedStyle( 
        LVS_EX_FULLROWSELECT | LVS_EX_CHECKBOXES | m_DriversList.GetExtendedStyle() );

    SetupListHeader();
    FillTheList();
    SortTheList();

    //
    // Display the description of the next step
    //

    VrfSetWindowText( m_NextDescription, IDS_SELDRV_PAGE_NEXT_DESCR_FINISH );

    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////////////
BOOL CSelectDriversPage::OnWizardFinish() 
{
    BOOL bExitTheApp;

    bExitTheApp = FALSE;

    if( GetNewVerifiedDriversList() )
    {
        if( FALSE == g_NewVerifierSettings.m_DriversSet.ShouldVerifySomeDrivers() )
        {
            VrfErrorResourceFormat( IDS_SELECT_AT_LEAST_ONE_DRIVER );

            goto Done;
        }

        g_NewVerifierSettings.SaveToRegistry();
	    
        //
        // Exit the app
        //

	    bExitTheApp = CVerifierPropertyPage::OnWizardFinish();
    }

Done:

    return bExitTheApp;
}

/////////////////////////////////////////////////////////////////////////////
#define VRF_MAX_CHARS_FOR_OPEN  4096

void CSelectDriversPage::OnAddButton() 
{
    POSITION pos;
    DWORD dwRetValue;
    DWORD dwOldMaxFileName = 0;
    DWORD dwErrorCode;
    INT nFileNameStartIndex;
    INT nNewListItemIndex;
    INT_PTR nResult;
    INT_PTR nNewDriverDataIndex;
    CDriverData *pNewDrvData;
    TCHAR szDriversDir[ _MAX_PATH ];
    TCHAR szAppTitle[ _MAX_PATH ];
    TCHAR *szFilesBuffer = NULL;
    TCHAR *szOldFilesBuffer = NULL;
    CString strPathName;
    CString strFileName;

    CFileDialog fileDlg( 
        TRUE,                               // open file
        _T( "sys" ),                        // default extension
        NULL,                               // no initial file name
        OFN_ALLOWMULTISELECT    |           // multiple selection
        OFN_HIDEREADONLY        |           // hide the "open read-only" checkbox
        OFN_NONETWORKBUTTON     |           // no network button
        OFN_NOTESTFILECREATE    |           // don't test for write protection, a full disk, etc.
        OFN_SHAREAWARE,                     // don't check the existance of file with OpenFile
        _T( "Drivers (*.sys)|*.sys||" ) );  // only one filter

    //
    // check the max length for the returned string
    //

    if( fileDlg.m_ofn.nMaxFile < VRF_MAX_CHARS_FOR_OPEN )
    {
        //
        // allocate a new buffer for the file names
        // 

        szFilesBuffer = new TCHAR[ VRF_MAX_CHARS_FOR_OPEN ];
        szFilesBuffer[ 0 ] = (TCHAR)0;

        if( szFilesBuffer != NULL )
        {
            //
            // Save the old buffer address and length
            //

            dwOldMaxFileName = fileDlg.m_ofn.nMaxFile;
            szOldFilesBuffer = fileDlg.m_ofn.lpstrFile;
            
            //
            // Set the new buffer address and length
            //

            fileDlg.m_ofn.lpstrFile = szFilesBuffer;
            fileDlg.m_ofn.nMaxFile = VRF_MAX_CHARS_FOR_OPEN;
        }
    }

    //
    // Dialog title
    //

    if( VrfLoadString(
        IDS_APPTITLE,
        szAppTitle,
        ARRAY_LENGTH( szAppTitle ) ) )
    {
        fileDlg.m_ofn.lpstrTitle = szAppTitle;
    }

    //
    // We change directory first time we try this to %windir%\system32\drivers
    //

    dwRetValue = ExpandEnvironmentStrings(
        _T( "%windir%\\system32\\drivers" ),
        szDriversDir,
        ARRAY_LENGTH( szDriversDir ) );

    if( dwRetValue > 0 && dwRetValue <= ARRAY_LENGTH( szDriversDir ) )
    {
        fileDlg.m_ofn.lpstrInitialDir = szDriversDir;
    }

    //
    // Show the file selection dialog
    //

    nResult = fileDlg.DoModal();

    switch( nResult )
    {
    case IDOK:
        break;

    case IDCANCEL:
        goto cleanup;

    default:
        dwErrorCode = CommDlgExtendedError();

        if( dwErrorCode == FNERR_BUFFERTOOSMALL )
        {
            VrfErrorResourceFormat(
                IDS_TOO_MANY_FILES_SELECTED );
        }
        else
        {
            VrfErrorResourceFormat(
                IDS_CANNOT_OPEN_FILES,
                dwErrorCode );
        }

        goto cleanup;
    }

    //
    // Parse all the selected files and try to enable them for verification
    //

    pos = fileDlg.GetStartPosition();

    while( pos != NULL )
    {
        //
        // Get the full path for the next file
        //

        strPathName = fileDlg.GetNextPathName( pos );

        //
        // Split only the file name, without the directory
        //

        nFileNameStartIndex = strPathName.ReverseFind( _T( '\\' ) );
        
        if( nFileNameStartIndex < 0 )
        {
            //
            // This shoudn't happen but you never know :-)
            //

            nFileNameStartIndex = 0;
        }
        else
        {
            //
            // skip the backslash
            //

            nFileNameStartIndex += 1;
        }

        strFileName = strPathName.Right( strPathName.GetLength() - nFileNameStartIndex );

        //
        // Try to add this driver to our global driver list
        //

        if( g_NewVerifierSettings.m_DriversSet.IsDriverNameInList( strFileName ) )
        {
            VrfErrorResourceFormat( IDS_DRIVER_IS_ALREADY_IN_LIST,
                                    (LPCTSTR) strFileName );
        }
        else
        {
            nNewDriverDataIndex = g_NewVerifierSettings.m_DriversSet.AddNewDriverData( strFileName, TRUE );

            if( nNewDriverDataIndex >= 0 )
            {
                //
                // Force refreshing the unsigned driver data 
                //

                g_NewVerifierSettings.m_DriversSet.m_bUnsignedDriverDataInitialized = FALSE;

                //
                // Add a new item to our list, for the new driver
                //

                pNewDrvData = g_NewVerifierSettings.m_DriversSet.m_aDriverData.GetAt( nNewDriverDataIndex );
            
                ASSERT_VALID( pNewDrvData );

                nNewListItemIndex = AddListItem( nNewDriverDataIndex, 
                                                 pNewDrvData );

                if( nNewListItemIndex >= 0 )
                {
                    m_DriversList.EnsureVisible( nNewListItemIndex, TRUE );
                }
            }
        }
    }

cleanup:
    if( szFilesBuffer != NULL )
    {
        fileDlg.m_ofn.nMaxFile = dwOldMaxFileName;
        fileDlg.m_ofn.lpstrFile = szOldFilesBuffer;

        delete szFilesBuffer;
    }
}

/////////////////////////////////////////////////////////////////////////////
void CSelectDriversPage::OnColumnclickSeldrvList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    switch( pNMListView->iSubItem )
    {
    case 0:
        //
        // Clicked on the "verified" column
        //

        if( m_nSortColumnIndex == pNMListView->iSubItem )
        {
            //
            // Change the current ascend/descend order for this column
            //

            m_bAscendSortVerified = !m_bAscendSortVerified;
        }

        break;

    case 1:
        //
        // Clicked on the driver name column
        //

        if( m_nSortColumnIndex == pNMListView->iSubItem )
        {
            //
            // Change the current ascend/descend order for this column
            //

            m_bAscendSortDrvName = !m_bAscendSortDrvName;
        }

        break;

    case 2:
        //
        // Clicked on the provider column
        //

        if( m_nSortColumnIndex == pNMListView->iSubItem )
        {
            //
            // Change the current ascend/descend order for this column
            //

            m_bAscendSortProvName = !m_bAscendSortProvName;
        }

        break;

    case 3:
        //
        // Clicked on the version column
        //

        if( m_nSortColumnIndex == pNMListView->iSubItem )
        {
            //
            // Change the current ascend/descend order for this column
            //

            m_bAscendSortVersion = !m_bAscendSortVersion;
        }

        break;

    default:
        //
        // Oops - how did we get here ?!?
        //

        ASSERT( FALSE );
        goto Done;
    }

    m_nSortColumnIndex = pNMListView->iSubItem;

    SortTheList();

Done:

	*pResult = 0;
}

/////////////////////////////////////////////////////////////
LONG CSelectDriversPage::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp( 
        (HWND) lpHelpInfo->hItemHandle,
        g_szVerifierHelpFile,
        HELP_WM_HELP,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}

/////////////////////////////////////////////////////////////////////////////
void CSelectDriversPage::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    ::WinHelp( 
        pWnd->m_hWnd,
        g_szVerifierHelpFile,
        HELP_CONTEXTMENU,
        (DWORD_PTR) MyHelpIds );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\slowdlg.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: SlowDlg.cpp
// author: DMihai
// created: 11/1/00
//
// Description:
//

#include "stdafx.h"
#include "verifier.h"

#include "SlowDlg.h"
#include "VrfUtil.h"
#include "VGlobal.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSlowProgressDlg dialog


CSlowProgressDlg::CSlowProgressDlg( CWnd* pParent /*=NULL*/ )
	: CDialog(CSlowProgressDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSlowProgressDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    m_hWorkerThread = NULL;

    //
    // Create the event used for killing the worker thread
    //

    m_hKillThreadEvent = CreateEvent(
        NULL,
        TRUE,
        FALSE,
        NULL );
}

CSlowProgressDlg::~CSlowProgressDlg()
{
    if( NULL != m_hKillThreadEvent )
    {
        CloseHandle( m_hKillThreadEvent );
    }
}

void CSlowProgressDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSlowProgressDlg)
	DDX_Control(pDX, IDC_UNSIGNED_PROGRESS, m_ProgressCtl);
	DDX_Control(pDX, IDC_UNSIGNED_STATIC, m_CurrentActionStatic);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSlowProgressDlg, CDialog)
	//{{AFX_MSG_MAP(CSlowProgressDlg)
	ON_BN_CLICKED(IDC_UNSIGNED_CANCEL_BUTTON, OnCancelButton)
	ON_WM_SHOWWINDOW()
	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI CSlowProgressDlg::LoadDriverDataWorkerThread( PVOID p )
{
    CSlowProgressDlg *pThis;
    
    pThis = (CSlowProgressDlg *)p;
    
    //
    // Cannot ASSERT_VALID for a CWnd from a thread that didn't create the window in MFC...
    //
    
    ASSERT( NULL != pThis );
    
    //
    // Load all the drivers information (name, version, etc.)
    // if we haven't don that already
    //

    g_NewVerifierSettings.m_DriversSet.LoadAllDriversData( pThis->m_hKillThreadEvent,
                                                           pThis->m_ProgressCtl );

    //
    // Done - hide the "slow progress" dialog and press the wizard "next" button
    //

    pThis->ShowWindow( SW_HIDE );

    if( g_NewVerifierSettings.m_DriversSet.m_bDriverDataInitialized )
    {
        AfxGetMainWnd()->PostMessage(PSM_PRESSBUTTON, (WPARAM)PSBTN_NEXT, 0) ;
    }

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI CSlowProgressDlg::SearchUnsignedDriversWorkerThread( PVOID p )
{
    CSlowProgressDlg *pThis;
    
    pThis = (CSlowProgressDlg *)p;
    
    //
    // Cannot ASSERT_VALID for a CWnd from a thread that didn't create the window in MFC...
    //
    
    ASSERT( NULL != pThis );
   
    //
    // Find out the unsigned drivers if we didn't do that already
    //

    g_NewVerifierSettings.m_DriversSet.FindUnsignedDrivers( pThis->m_hKillThreadEvent,
                                                                  pThis->m_ProgressCtl );

    //
    // Done - hide the "slow progress" dialog and press the wizard "next" button
    //

    pThis->ShowWindow( SW_HIDE );

    if( g_NewVerifierSettings.m_DriversSet.m_bUnsignedDriverDataInitialized )
    {
        AfxGetMainWnd()->PostMessage(PSM_PRESSBUTTON, (WPARAM)PSBTN_NEXT, 0) ;
    }

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CSlowProgressDlg::StartWorkerThread( LPTHREAD_START_ROUTINE pThreadStart,
                                          ULONG uMessageResourceId )
{
    DWORD dwThreadId;
    CString strWorkMessage;

    //
    // Load a description of the current "work item"
    // and show it to the user
    //

    VERIFY( strWorkMessage.LoadString( uMessageResourceId ) );
    m_CurrentActionStatic.SetWindowText( strWorkMessage );
    m_CurrentActionStatic.RedrawWindow();

    //
    // Kill a possible currently running worker thread
    //

    KillWorkerThread();

    ASSERT( NULL == m_hWorkerThread );
    
    //
    // Make sure the "kill thread" event is not signaled
    //

    if( NULL != m_hKillThreadEvent )
    {
        ResetEvent( m_hKillThreadEvent );
    }

    //
    // Create the new worker thread
    //

    m_hWorkerThread = CreateThread( 
        NULL,
        0,
        pThreadStart,
        this,
        0,
        &dwThreadId );

    if( NULL == m_hWorkerThread )
    {
        //
        // Could not create the worker thread - bail out
        //

        VrfErrorResourceFormat( IDS_NOT_ENOUGH_MEMORY );

        PostMessage( WM_COMMAND,
                     IDC_UNSIGNED_CANCEL_BUTTON );

        return FALSE;
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
VOID CSlowProgressDlg::KillWorkerThread()
{
    DWORD dwWaitResult;
    MSG msg;

    if( NULL != m_hWorkerThread )
    {
        if( NULL != m_hKillThreadEvent )
        {
            //
            // Ask the worker thread to die asap
            //

            SetEvent( m_hKillThreadEvent );
        }

        //
        // Wait forever for a decent death from the worker thread.
        //
        // We cannot TerminateThread on our worker thread because
        // it could be killed while holding locks (e.g. the heap lock)
        // and that would deadlock our whole process.
        //

        while( m_hWorkerThread != NULL )
        {
            dwWaitResult = MsgWaitForMultipleObjects( 1,
                                                      &m_hWorkerThread, 
                                                      FALSE,
                                                      INFINITE,
                                                      QS_ALLINPUT );

            ASSERT( NULL != WAIT_FAILED );

            if( WAIT_OBJECT_0 != dwWaitResult )
            {
                //
                // Our thread didn't exit but we have some messages to dispatch.
                //

                while( PeekMessage( &msg, NULL, NULL, NULL, PM_REMOVE ) )
                {
                    TranslateMessage( &msg );
                    DispatchMessage( &msg );
                }

                //
                // During the DispatchMessage above we could process another 
                // click of the Cancel button or the Back button of the wizard. 
                // The KillWorkerThread recursive call will wait until the worker 
                // thread dies then will sets m_hWorkerThread to NULL. 
                // So we need to check for m_hWorkerThread != NULL before each new
                // MsgWaitForMultipleObjects.
                //
            }
            else
            {
                //
                // The worker thread finished execution.
                //

                break;
            }
        }

        if( m_hWorkerThread != NULL )
        {
            //
            // Close the thread handle
            //

            CloseHandle( m_hWorkerThread );

            m_hWorkerThread = NULL;
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
// CSlowProgressDlg message handlers

void CSlowProgressDlg::OnCancelButton() 
{
    KillWorkerThread();

    ShowWindow( SW_HIDE );
}

/////////////////////////////////////////////////////////////////////////////
void CSlowProgressDlg::OnShowWindow(BOOL bShow, UINT nStatus) 
{
    CDialog::OnShowWindow(bShow, nStatus);
	
    if( TRUE == bShow )
    {
        CenterWindow();
    }
}

/////////////////////////////////////////////////////////////////////////////
BOOL CSlowProgressDlg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\taspage.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: taspage.cpp
// author: DMihai
// created: 11/1/00
//
// Description:
//

#include "stdafx.h"
#include "verifier.h"

#include "taspage.h"
#include "VrfUtil.h"
#include "VGlobal.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Change this if you add/remove/change order 
// of radio buttons on this page
//

#define FIRST_RADIO_BUTTON_ID   IDC_TAS_TYPICAL_RADIO

//
// Help IDs
//

static DWORD MyHelpIds[] =
{
    IDC_TAS_TYPICAL_RADIO,          IDH_DV_Settings_standard,
    IDC_TAS_ADVANCED_RADIO,         IDH_DV_Settings_custom,
    IDC_TAS_DELETE_RADIO,           IDH_DV_Settings_deleteexisting,
    IDC_TAS_VIEWREGISTRY_RADIO,     IDH_DV_Settings_displaycurrent,
    IDC_TAS_STATISTICS_RADIO,       IDH_DV_Settings_displayexisting,
    0,                              0
};

/////////////////////////////////////////////////////////////////////////////
// CTypAdvStatPage

IMPLEMENT_DYNCREATE(CTypAdvStatPage, CVerifierPropertyPage)

CTypAdvStatPage::CTypAdvStatPage()
    : CVerifierPropertyPage( CTypAdvStatPage::IDD )
{
 	//{{AFX_DATA_INIT(CTypAdvStatPage)
	m_nCrtRadio = -1;
	//}}AFX_DATA_INIT
}


CTypAdvStatPage::~CTypAdvStatPage()
{
}

/////////////////////////////////////////////////////////////////////////////
//
// DDX support
//

void CTypAdvStatPage::DoDataExchange(CDataExchange* pDX) 
{
	CVerifierPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTypAdvStatPage)
	DDX_Control(pDX, IDC_TAS_NEXT_DESCR_STATIC, m_NextDescription);
	DDX_Radio(pDX, IDC_TAS_TYPICAL_RADIO, m_nCrtRadio);
	//}}AFX_DATA_MAP
}

/////////////////////////////////////////////////////////////////////////////
//
// Message map
//

BEGIN_MESSAGE_MAP(CTypAdvStatPage, CVerifierPropertyPage)
	//{{AFX_MSG_MAP(CTypAdvStatPage)
	ON_BN_CLICKED(IDC_TAS_DELETE_RADIO, OnDeleteRadio)
	ON_BN_CLICKED(IDC_TAS_ADVANCED_RADIO, OnAdvancedRadio)
	ON_BN_CLICKED(IDC_TAS_STATISTICS_RADIO, OnStatisticsRadio)
	ON_BN_CLICKED(IDC_TAS_TYPICAL_RADIO, OnTypicalRadio)
	ON_BN_CLICKED(IDC_TAS_VIEWREGISTRY_RADIO, OnViewregistryRadio)
    ON_WM_CONTEXTMENU()
    ON_MESSAGE( WM_HELP, OnHelp )
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//
// All the property pages derived from this class should 
// provide these methods.
//

ULONG CTypAdvStatPage::GetDialogId() const
{
    return CTypAdvStatPage::IDD;
}

/////////////////////////////////////////////////////////////////////////////
// CTypAdvStatPage message handlers


LRESULT CTypAdvStatPage::OnWizardNext() 
{
    LRESULT lNextPageId;

    //
    // Kill a possible active worker thread
    //

    g_SlowProgressDlg.KillWorkerThread();

    //
    // Let's assume we cannot continue
    //

    lNextPageId = -1;

    if( UpdateData() == TRUE )
    {
        switch( m_nCrtRadio )
        {
        case IDC_TAS_TYPICAL_RADIO - FIRST_RADIO_BUTTON_ID:
            
            //
            // Set typical settings and go to driver selection page
            //

            g_NewVerifierSettings.m_SettingsBits.m_SettingsType = CSettingsBits::SettingsTypeTypical;
            g_NewVerifierSettings.m_SettingsBits.SetTypicalOnly();
            
            lNextPageId = IDD_DRVSET_PAGE;

            break;

        case IDC_TAS_ADVANCED_RADIO - FIRST_RADIO_BUTTON_ID:

            //
            // Start building custom settings (advanced, for developers)
            //

            g_NewVerifierSettings.m_SettingsBits.m_SettingsType = CSettingsBits::SettingsTypeCustom;

            lNextPageId = IDD_CUSTSETT_PAGE;

            break;

        case IDC_TAS_VIEWREGISTRY_RADIO - FIRST_RADIO_BUTTON_ID:

            //
            // Display the current registry settings
            //

            //
            // Load the current verified drivers string and flags from the registry
            //

            if( TRUE != VrtLoadCurrentRegistrySettings( g_bAllDriversVerified,
                                                        g_astrVerifyDriverNamesRegistry,
                                                        g_dwVerifierFlagsRegistry ) )
            {
                goto Done;
            }

            //
            // Look if we already have loaded the list of drivers
            // with version information, etc. and if we need it
            //

            if( TRUE != g_NewVerifierSettings.m_DriversSet.m_bDriverDataInitialized )
            {
                if( NULL == g_SlowProgressDlg.m_hWnd )
                {
                    //
                    // This is the first time we are showing the 
                    // "slow progress" dialog so create it first
                    //

                    g_SlowProgressDlg.Create( CSlowProgressDlg::IDD, AfxGetMainWnd() );
                }

                //
                // Show the dialog
                //

                g_SlowProgressDlg.ShowWindow( SW_SHOW );

                //
                // Start the worker thread to do the work in background
                // while the initial thread updates the GUI. If the thread ends
                // successfully it will press our "Next" button at the end, after setting
                // g_NewVerifierSettings.m_DriversSet.m_bDriverDataInitialized to TRUE
                //

                g_SlowProgressDlg.StartWorkerThread( CSlowProgressDlg::LoadDriverDataWorkerThread,
                                                     IDS_LOADING_DRIVER_INFORMATION );

                //
                // Wait for the "next" button again
                //

                goto Done;
            }

            //
            // We have already loaded information (name, version, etc.) about 
            // the currently loaded drivers if have gotten to this point.
            //
            // Go to the next page.
            //

            lNextPageId = IDD_CRT_REGISTRY_SETTINGS_PAGE;

            break;

        case IDC_TAS_STATISTICS_RADIO - FIRST_RADIO_BUTTON_ID:

            //
            // The user wants just statistics - nothing to change
            //
                
            lNextPageId = IDD_DRVSTATUS_STAT_PAGE;

            break;

        default:
            //
            // Oops. how did we get here?
            //
            // We shouldn't have had a "Next" button for the 
            // "delete settings" selection
            //

            ASSERT( FALSE );
        }
    }

    GoingToNextPageNotify( lNextPageId );

Done:
    return lNextPageId;
}

/////////////////////////////////////////////////////////////////////////////
void CTypAdvStatPage::OnDeleteRadio() 
{
    ASSERT_VALID( m_pParentSheet );

    m_pParentSheet->SetWizardButtons(
        PSWIZB_FINISH );

    VrfSetWindowText( m_NextDescription, IDS_TAS_PAGE_NEXT_DESCR_DELETE );
}

void CTypAdvStatPage::OnAdvancedRadio() 
{
    ASSERT_VALID( m_pParentSheet );

    m_pParentSheet->SetWizardButtons(
        PSWIZB_NEXT );

    VrfSetWindowText( m_NextDescription, IDS_TAS_PAGE_NEXT_DESCR_CUSTOM );
}

void CTypAdvStatPage::OnStatisticsRadio() 
{
    ASSERT_VALID( m_pParentSheet );

    m_pParentSheet->SetWizardButtons(
        PSWIZB_NEXT );

    VrfSetWindowText( m_NextDescription, IDS_TAS_PAGE_NEXT_DESCR_STATISTICS );
}


void CTypAdvStatPage::OnTypicalRadio() 
{
    ASSERT_VALID( m_pParentSheet );

    m_pParentSheet->SetWizardButtons(
        PSWIZB_NEXT );

    VrfSetWindowText( m_NextDescription, IDS_TAS_PAGE_NEXT_DESCR_STANDARD );
}

void CTypAdvStatPage::OnViewregistryRadio() 
{
    ASSERT_VALID( m_pParentSheet );

    m_pParentSheet->SetWizardButtons(
        PSWIZB_NEXT );

    VrfSetWindowText( m_NextDescription, IDS_TAS_PAGE_NEXT_DESCR_REGISTRY );
}

/////////////////////////////////////////////////////////////////////////////
BOOL CTypAdvStatPage::OnSetActive() 
{
    ASSERT_VALID( m_pParentSheet );

    m_pParentSheet->SetWizardButtons(
        PSWIZB_NEXT );

	return CVerifierPropertyPage::OnSetActive();
}

/////////////////////////////////////////////////////////////////////////////
BOOL CTypAdvStatPage::OnWizardFinish() 
{
    BOOL bFinish;
    INT nResponse;

    //
    // Kill a possible active worker thread
    //

    g_SlowProgressDlg.KillWorkerThread();


    bFinish = FALSE;

    if( TRUE == UpdateData( TRUE ) )
    {
        //
        // This must have been the "delete settings" selection
        // if we had a "Finish" button.
        //

        ASSERT( IDC_TAS_DELETE_RADIO - FIRST_RADIO_BUTTON_ID == m_nCrtRadio );

        nResponse = AfxMessageBox( IDS_DELETE_ALL_SETTINGS,
                                   MB_YESNO );
        
        if( IDYES == nResponse )
        {
            VrfDeleteAllVerifierSettings();

            bFinish = CVerifierPropertyPage::OnWizardFinish();
        }
    }
	
	return bFinish;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CTypAdvStatPage::OnInitDialog() 
{
    //
    // Don't try to reconstruct the current data from the registry
    // to the GUI because it's too hard. Always start with the typical settings
    //

    m_nCrtRadio = IDC_TAS_TYPICAL_RADIO - FIRST_RADIO_BUTTON_ID;

    CVerifierPropertyPage::OnInitDialog();

    VrfSetWindowText( m_NextDescription, IDS_TAS_PAGE_NEXT_DESCR_STANDARD );
		
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////
LONG CTypAdvStatPage::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp( 
        (HWND) lpHelpInfo->hItemHandle,
        g_szVerifierHelpFile,
        HELP_WM_HELP,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}

/////////////////////////////////////////////////////////////////////////////
void CTypAdvStatPage::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    ::WinHelp( 
        pWnd->m_hWnd,
        g_szVerifierHelpFile,
        HELP_CONTEXTMENU,
        (DWORD_PTR) MyHelpIds );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\taspage.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: paspage.h
// author: DMihai
// created: 11/1/00
//
// Description:
//  

#if !defined(AFX_TASPAGE_H__6F4DFFE1_A07F_403D_A580_CCB25C729FC2__INCLUDED_)
#define AFX_TASPAGE_H__6F4DFFE1_A07F_403D_A580_CCB25C729FC2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// taspage.h : header file
//

#include "vsetting.h"
#include "VerfPage.h"

/////////////////////////////////////////////////////////////////////////////
// CTypAdvStatPage

class CTypAdvStatPage : public CVerifierPropertyPage
{
	DECLARE_DYNCREATE(CTypAdvStatPage)

public:
    //
    // Construction/destruction
    //

    CTypAdvStatPage();
    ~CTypAdvStatPage();


    //
    // Methods
    //

    VOID SetParentSheet( CPropertySheet *pParentSheet )
    {
        m_pParentSheet = pParentSheet;
        ASSERT( m_pParentSheet != NULL );
    }


protected:
    //
    // Data
    //

    CPropertySheet      *m_pParentSheet;

    //
    // Overrides
    //

    //
    // All the property pages derived from this class should 
    // provide these methods.
    //

    virtual ULONG GetDialogId() const;

    //
	// ClassWizard generated virtual function overrides
    //

	//{{AFX_VIRTUAL(CTypAdvStatPage)
	public:
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
	virtual BOOL OnWizardFinish();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);
	//}}AFX_VIRTUAL

    //
    // Dialog Data
    //

    //{{AFX_DATA(CTypAdvStatPage)
	enum { IDD = IDD_TAS_PAGE };
	CStatic	m_NextDescription;
	int		m_nCrtRadio;
	//}}AFX_DATA

protected:
    //
    // Generated message map functions
    //

    //{{AFX_MSG(CTypAdvStatPage)
	afx_msg void OnDeleteRadio();
	afx_msg void OnAdvancedRadio();
	afx_msg void OnStatisticsRadio();
	afx_msg void OnTypicalRadio();
	virtual BOOL OnInitDialog();
	afx_msg void OnViewregistryRadio();
    afx_msg LONG OnHelp( WPARAM wParam, LPARAM lParam );
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TASPAGE_H__6F4DFFE1_A07F_403D_A580_CCB25C729FC2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\sdrvpage.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: SDrvPage.h
// author: DMihai
// created: 11/1/00
//
// Description:
//  

#if !defined(AFX_SDRIVPAGE_H__48B5863F_CB55_47F8_9084_1F5459093728__INCLUDED_)
#define AFX_SDRIVPAGE_H__48B5863F_CB55_47F8_9084_1F5459093728__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SDrivPage.h : header file
//

#include "VerfPage.h"

/////////////////////////////////////////////////////////////////////////////
// CSelectDriversPage dialog

class CSelectDriversPage : public CVerifierPropertyPage
{
	DECLARE_DYNCREATE(CSelectDriversPage)

// Construction
public:
	CSelectDriversPage();
	~CSelectDriversPage();

public:
    //
    // Methods
    //

    VOID SetParentSheet( CPropertySheet *pParentSheet )
    {
        m_pParentSheet = pParentSheet;
        ASSERT( m_pParentSheet != NULL );
    }

protected:
    //
    // Methods
    //

    VOID SetupListHeader();
    VOID FillTheList();

    INT AddListItem( INT_PTR nIndexInArray, CDriverData *pCrtDrvData );

    BOOL GetNewVerifiedDriversList();

    VOID SortTheList();
    BOOL GetColumnStrValue( LPARAM lItemData, 
                            CString &strName );

    static int CALLBACK StringCmpFunc( LPARAM lParam1,
                                       LPARAM lParam2,
                                       LPARAM lParamSort);

    static int CALLBACK CheckedStatusCmpFunc( LPARAM lParam1,
                                              LPARAM lParam2,
                                              LPARAM lParamSort);

protected:
    //
    // Data
    //

    CPropertySheet      *m_pParentSheet;

    INT m_nSortColumnIndex;        // verified status (0), driver name (1), provider name (2), version (3)
    BOOL m_bAscendSortVerified;    // sort ascendent the verified status
    BOOL m_bAscendSortDrvName;     // sort ascendent the driver names
    BOOL m_bAscendSortProvName;    // sort ascendent the provider names
    BOOL m_bAscendSortVersion;     // sort ascendent the version

    //
    // Dialog Data
    //

	//{{AFX_DATA(CSelectDriversPage)
	enum { IDD = IDD_SELECT_DRIVERS_PAGE };
	CStatic	m_NextDescription;
	CListCtrl	m_DriversList;
	//}}AFX_DATA


protected:
    //
    // Overrides
    //

    //
    // All the property pages derived from this class should 
    // provide these methods.
    //

    virtual ULONG GetDialogId() const { return IDD; }

    //
    // ClassWizard generate virtual function overrides
    //

    //{{AFX_VIRTUAL(CSelectDriversPage)
    public:
    virtual BOOL OnSetActive();
    virtual BOOL OnWizardFinish();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CSelectDriversPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnAddButton();
    afx_msg void OnColumnclickSeldrvList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg LONG OnHelp( WPARAM wParam, LPARAM lParam );
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SDRIVPAGE_H__48B5863F_CB55_47F8_9084_1F5459093728__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\stdafx.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: stdafx.h
// author: DMihai
// created: 11/1/00
//
// Description:
//  
// Include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#if !defined(AFX_STDAFX_H__E24BD541_BD54_42E0_BD79_8417041B8DA1__INCLUDED_)
#define AFX_STDAFX_H__E24BD541_BD54_42E0_BD79_8417041B8DA1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//
// Use MFC ASSERT macro
//

#ifdef ASSERT
#undef ASSERT
#endif

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <locale.h>
#include <capi.h>
#include <softpub.h>
#include <Imagehlp.h>

#include <ntverp.h>
#include <common.ver>

#include "helpids.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__E24BD541_BD54_42E0_BD79_8417041B8DA1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\slowdlg.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: SlowDlg.h
// author: DMihai
// created: 11/1/00
//
// Description:
//  

#if !defined(AFX_SIGNDLG_H__54E81D3F_0B31_477A_ABA7_E880D1F0F2BC__INCLUDED_)
#define AFX_SIGNDLG_H__54E81D3F_0B31_477A_ABA7_E880D1F0F2BC__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SignDlg.h : header file
//

#include "VSetting.h"
#include "ProgCtrl.h"

/////////////////////////////////////////////////////////////////////////////
// CSlowProgressDlg dialog

class CSlowProgressDlg : public CDialog
{
// Construction
public:
	CSlowProgressDlg(CWnd* pParent = NULL);   // standard constructor
    virtual ~CSlowProgressDlg();

public:
    VOID KillWorkerThread();
    BOOL StartWorkerThread( LPTHREAD_START_ROUTINE pThreadStart,
                            ULONG uMessageResourceId );

    static DWORD WINAPI LoadDriverDataWorkerThread( PVOID p );
    static DWORD WINAPI SearchUnsignedDriversWorkerThread( PVOID p );

public:
    //
    // Data
    //

    //
    // Worker thread handle
    //

    HANDLE m_hWorkerThread;

    //
    // Event used to kill our worker thread
    //

    HANDLE m_hKillThreadEvent;

public:
// Dialog Data
	//{{AFX_DATA(CSlowProgressDlg)
	enum { IDD = IDD_BUILDING_UNSIGNED_LIST_DIALOG };
	CVrfProgressCtrl	m_ProgressCtl;
	CStatic	m_CurrentActionStatic;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSlowProgressDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSlowProgressDlg)
	afx_msg void OnCancelButton();
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SIGNDLG_H__54E81D3F_0B31_477A_ABA7_E880D1F0F2BC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\vbitsdlg.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: VBitsDlg.cpp
// author: DMihai
// created: 11/1/00
//
// Description:
//


#include "stdafx.h"
#include "verifier.h"

#include "VBitsDlg.h"
#include "VGlobal.h"
#include "VrfUtil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CVolatileBitsDlg dialog


CVolatileBitsDlg::CVolatileBitsDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CVolatileBitsDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CVolatileBitsDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CVolatileBitsDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CVolatileBitsDlg)
	DDX_Control(pDX, IDC_VOLBITS_LIST, m_SettingsList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CVolatileBitsDlg, CDialog)
	//{{AFX_MSG_MAP(CVolatileBitsDlg)
	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
VOID CVolatileBitsDlg::SetupListHeader()
{
    CString strTitle;
    CRect rectWnd;
    LVCOLUMN lvColumn;

    //
    // The list's rectangle 
    //

    m_SettingsList.GetClientRect( &rectWnd );

    ZeroMemory( &lvColumn, 
               sizeof( lvColumn ) );

    lvColumn.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;

    //
    // Column 0
    //

    VERIFY( strTitle.LoadString( IDS_ENABLED_QUESTION ) );

    lvColumn.iSubItem = 0;
    lvColumn.pszText = strTitle.GetBuffer( strTitle.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.20 );
    VERIFY( m_SettingsList.InsertColumn( 0, &lvColumn ) != -1 );
    strTitle.ReleaseBuffer();

    //
    // Column 1
    //

    VERIFY( strTitle.LoadString( IDS_SETTING ) );

    lvColumn.iSubItem = 1;
    lvColumn.pszText = strTitle.GetBuffer( strTitle.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.79 );
    VERIFY( m_SettingsList.InsertColumn( 1, &lvColumn ) != -1 );
    strTitle.ReleaseBuffer();
}

/////////////////////////////////////////////////////////////////////////////
VOID CVolatileBitsDlg::FillTheList( DWORD dwVerifierBits )
{
    //
    // N.B.
    //
    // If you change this order then you need to
    // change GetNewVerifierFlags as well
    //

    AddListItem( IDS_SPECIAL_POOL,          ( ( dwVerifierBits & DRIVER_VERIFIER_SPECIAL_POOLING ) != 0 ) );
    AddListItem( IDS_FORCE_IRQL_CHECKING,   ( ( dwVerifierBits & DRIVER_VERIFIER_FORCE_IRQL_CHECKING ) != 0 ) );
    AddListItem( IDS_LOW_RESOURCE_SIMULATION,( ( dwVerifierBits & DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES ) != 0 ) );
}

/////////////////////////////////////////////////////////////////////////////
DWORD CVolatileBitsDlg::GetNewVerifierFlags()
{
    //
    // N.B.
    //
    // If you change this order then you need to
    // change FillTheList as well
    //

    DWORD dwNewFlags;

    dwNewFlags = 0;

    if( m_SettingsList.GetCheck( 0 ) )
    {
        dwNewFlags |= DRIVER_VERIFIER_SPECIAL_POOLING;
    }

    if( m_SettingsList.GetCheck( 1 ) )
    {
        dwNewFlags |= DRIVER_VERIFIER_FORCE_IRQL_CHECKING;
    }

    if( m_SettingsList.GetCheck( 2 ) )
    {
        dwNewFlags |= DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES;
    }

    return dwNewFlags;
}

/////////////////////////////////////////////////////////////////////////////
VOID CVolatileBitsDlg::AddListItem( ULONG uIdResourceString, BOOL bInitiallyEnabled )
{
    INT nActualIndex;
    LVITEM lvItem;
    CString strName;

    ZeroMemory( &lvItem, sizeof( lvItem ) );

    //
    // LVITEM's member pszText is not a const pointer 
    // so we need to GetBuffer here :-(
    //

    //
    // Sub-item 0 - enabled/diabled - empty text and a checkbox
    //

    lvItem.pszText = g_szVoidText;
    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = m_SettingsList.GetItemCount();

    nActualIndex = m_SettingsList.InsertItem( &lvItem );

    if( nActualIndex < 0 )
    {
        //
        // Could not add an item in the list - give up
        //

        goto Done;
    }

    m_SettingsList.SetCheck( nActualIndex, bInitiallyEnabled );

    //
    // Sub-item 1 - feature name
    //

    VERIFY( strName.LoadString( uIdResourceString ) );

    lvItem.pszText = strName.GetBuffer( strName.GetLength() + 1 );
    
    if( NULL == lvItem.pszText )
    {
        goto Done;
    }

    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = nActualIndex;
    lvItem.iSubItem = 1;
    
    VERIFY( m_SettingsList.SetItem( &lvItem ) );

    strName.ReleaseBuffer();

Done:
    //
    // All done
    //

    NOTHING;
}

/////////////////////////////////////////////////////////////////////////////
// CVolatileBitsDlg message handlers

BOOL CVolatileBitsDlg::OnInitDialog() 
{
    CRuntimeVerifierData RuntimeVerifierData;
    
    //
    // Start with the current settings
    //

    VrfGetRuntimeVerifierData( &RuntimeVerifierData );

	CDialog::OnInitDialog();

    m_SettingsList.SetExtendedStyle( 
        LVS_EX_FULLROWSELECT | LVS_EX_CHECKBOXES | m_SettingsList.GetExtendedStyle() );

    SetupListHeader();
    FillTheList( RuntimeVerifierData.Level );
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////////////
void CVolatileBitsDlg::OnOK() 
{
    DWORD dwNewVerifierBits;

    dwNewVerifierBits = GetNewVerifierFlags();

    if( VrfSetNewFlagsVolatile( dwNewVerifierBits ) )
    {
		CDialog::OnOK();
    }

    //
    // If VrfSetNewFlagsVolatile fails we wait for the Cancel button
    //
}

/////////////////////////////////////////////////////////////////////////////
BOOL CVolatileBitsDlg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\verfpage.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: VerfPage.cpp
// author: DMihai
// created: 11/1/00
//
// Description:
//

#include "stdafx.h"
#include "verifier.h"
#include "VerfPage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Previous page IDs - used for implementing the "back"
// button functionality
//

CPtrArray g_aPageIds;

//
// The one and only "slow progress" dialog
//

CSlowProgressDlg g_SlowProgressDlg;

/////////////////////////////////////////////////////////////////////////////
// CVerifierPropertyPage property page

IMPLEMENT_DYNAMIC(CVerifierPropertyPage, CPropertyPage)

CVerifierPropertyPage::CVerifierPropertyPage(ULONG uDialogId) : 
    CPropertyPage( uDialogId )
{
	//{{AFX_DATA_INIT(CVerifierPropertyPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CVerifierPropertyPage::~CVerifierPropertyPage()
{
}

BEGIN_MESSAGE_MAP(CVerifierPropertyPage, CPropertyPage)
	//{{AFX_MSG_MAP(CVerifierPropertyPage)
	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
ULONG CVerifierPropertyPage::GetDialogId() const
{ 
    //
    // Oops, how did we get here ?!?
    // This is a virtual pure function.
    //

    //ASSERT( FALSE ); 

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
// Return the previous page ID, based on our history array
// and remove it from the array because will activate. Called
// by our property pages when the "back" button is clicked
//

ULONG CVerifierPropertyPage::GetAndRemovePreviousDialogId()
{
    ULONG uPrevId;
    INT_PTR nPageIdsArraySize;

    nPageIdsArraySize = g_aPageIds.GetSize();

    ASSERT( nPageIdsArraySize > 0 );

    uPrevId = PtrToUlong( g_aPageIds.GetAt( nPageIdsArraySize - 1 ) );

    g_aPageIds.RemoveAt( nPageIdsArraySize - 1 ); 

    return uPrevId;
}

/////////////////////////////////////////////////////////////////////////////
//
// Property pages derived from this class should notify us 
// whenever we go to a next page to record the current page ID in 
// the global array g_aPageIds
//

VOID CVerifierPropertyPage::GoingToNextPageNotify( LRESULT lNextPageId )
{
    ULONG uMyDialogId;

    if( -1 != lNextPageId )
    {
        //
        // Will go to the next page. Add our ID to the global IDs array 
        // used for implementing the "back" button functionality.
        //

        uMyDialogId = GetDialogId();

        ASSERT( ( 0 == g_aPageIds.GetSize() ) || ( ULongToPtr( uMyDialogId ) != g_aPageIds.GetAt( g_aPageIds.GetSize() - 1 ) ) );

        g_aPageIds.Add( ULongToPtr( uMyDialogId ) );
    }
}

/////////////////////////////////////////////////////////////////////////////
//
// Use this to kill any currently running worker threads
//

BOOL CVerifierPropertyPage::OnQueryCancel( )
{
    g_SlowProgressDlg.KillWorkerThread();

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
LRESULT CVerifierPropertyPage::OnWizardBack() 
{
    return GetAndRemovePreviousDialogId();
}

/////////////////////////////////////////////////////////////////////////////
// CVerifierPropertyPage message handlers

BOOL CVerifierPropertyPage::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by verifier.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDS_ABOUTBOX                    101
#define IDS_APPTITLE                    102
#define IDS_CANNOT_LOAD_APP_TITLE       103
#define IDS_NOT_ENOUGH_MEMORY           104
#define IDS_NO_TESTS_SELECTED           105
#define IDS_CANNOT_GET_SYSTEM_DIRECTORY 106
#define IDS_NO_DRIVERS_FOUND            107
#define IDS_CANNOT_GET_CURRENT_DIRECTORY 108
#define IDS_CANNOT_SET_CURRENT_DIRECTORY 109
#define IDS_CANT_GET_ACTIVE_DRVLIST     110
#define IDS_NAME                        111
#define IDS_DESCRIPTION                 112
#define IDS_LOADING_DRIVER_INFORMATION  113
#define IDS_SEARCHING_FOR_UNSIGNED_DRIVERS 114
#define IDS_UNSIGNED_DRIVERS_LIST       115
#define IDS_OLD_DRIVERS_LIST            116
#define IDS_UNKNOWN                     117
#define IDS_SETTINGS_TYPE               118
#define IDS_TYPICAL                     119
#define IDS_CUSTOM                      120
#define IDS_DRIVERS_BUILT_FOR_OLD_WINDOWS 121
#define IDS_UNSIGNED                    122
#define IDS_ALL                         123
#define IDS_DRIVERS                     124
#define IDS_VERIFICATION_STATUS         125
#define IDS_PROVIDER                    126
#define IDS_VERSION                     127
#define IDR_MAINFRAME                   128
#define IDS_DRIVERS_TO_VERIFY           128
#define IDS_DISABLED                    129
#define IDS_ENABLED                     130
#define IDS_TAS_PAGE_NEXT_DESCR_STANDARD 131
#define IDS_TAS_PAGE_NEXT_DESCR_CUSTOM  132
#define IDS_TAS_PAGE_NEXT_DESCR_STATISTICS 133
#define IDS_TAS_PAGE_NEXT_DESCR_DELETE  134
#define IDS_DELETE_ALL_SETTINGS         135
#define IDS_DRVSET_PAGE_NEXT_DESCR_UNSIGNED 136
#define IDS_DRVSET_PAGE_NEXT_DESCR_ALL  137
#define IDS_DRVSET_PAGE_NEXT_DESCR_NAMELIST 138
#define IDS_DRVSET_PAGE_NEXT_DESCR_OLD  139
#define IDD_VOLATILE_BITS_DIALOG        139
#define IDS_CONFDRV_PAGE_NEXT_DESCR_FINISH 140
#define IDS_SELDRV_PAGE_NEXT_DESCR_FINISH 141
#define IDS_TAS_PAGE_NEXT_DESCR_PREDEFINED 142
#define IDS_TAS_PAGE_NEXT_DESCR_LIST    143
#define IDS_FLSETT_PAGE_NEXT_DESCR      144
#define IDS_ACCESS_IS_DENIED            145
#define IDS_REGOPENKEYEX_FAILED         146
#define IDS_REGSETVALUEEX_FAILED        147
#define IDS_NO_OLD_DRIVERS_FOUND        148
#define IDS_NO_UNSIGNED_DRIVERS_FOUND   149
#define IDS_REGDELETEVALUE_FAILED       150
#define IDS_STATUS                      151
#define IDS_NEVER_LOADED                152
#define IDS_UNLOADED                    153
#define IDS_LOADED                      154
#define IDS_COVERAGE_WARNING_FORMAT     155
#define IDS_QUERY_SYSINFO_FAILED        158
#define IDS_CRTSTAT_PAGE_NEXT_DESCR     159
#define IDS_HELP_CMDLINE_SWITCH         160
#define IDS_HELP_LINE1                  161
#define IDS_HELP_LINE3                  162
#define IDS_HELP_LINE4                  163
#define IDS_HELP_LINE5                  164
#define IDS_HELP_LINE6                  165
#define IDS_HELP_LINE7                  166
#define IDS_HELP_LINE8                  167
#define IDS_HELP_LINE9                  168
#define IDS_HELP_LINE10                 169
#define IDS_HELP_LINE11                 170
#define IDS_HELP_LINE12                 171
#define IDS_HELP_LINE13                 172
#define IDS_HELP_LINE14                 173
#define IDS_HELP_LINE15                 174
#define IDS_HELP_LINE16                 175
#define IDS_HELP_LINE17                 176
#define IDS_HELP_LINE18                 177
#define IDS_HELP_LINE19                 178
#define IDS_HELP_LINE20                 179
#define IDS_HELP_LINE21                 180
#define IDS_HELP_LINE22                 181
#define IDS_HELP_LINE23                 182
#define IDS_HELP_LINE24                 183
#define IDS_HELP_LINE25                 184
#define IDS_HELP_LINE26                 185
#define IDS_HELP_LINE27                 186
#define IDS_HELP_LINE28                 187
#define IDS_HELP_LINE29                 188
#define IDS_HELP_LINE30                 189
#define IDS_HELP_LINE31                 190
#define IDS_RESET_CMDLINE_SWITCH        191
#define IDS_LOG_CMDLINE_SWITCH          192
#define IDS_INTERVAL_CMDLINE_SWITCH     193
#define IDS_CANT_APPEND_FILE            194
#define IDS_CANT_WRITE_FILE             195
#define IDS_CANTGET_VERIF_STATE         196
#define IDS_NO_DRIVER_VERIFIED          197
#define IDS_LEVEL                       198
#define IDS_RAISEIRQLS                  199
#define IDS_ACQUIRESPINLOCKS            200
#define IDS_SYNCHRONIZEEXECUTIONS       201
#define IDS_ALLOCATIONSATTEMPTED        202
#define IDS_ALLOCATIONSSUCCEEDED        203
#define IDS_ALLOCATIONSSUCCEEDEDSPECIALPOOL 204
#define IDS_ALLOCATIONSWITHNOTAG        205
#define IDS_ALLOCATIONSFAILED           206
#define IDS_ALLOCATIONSFAILEDDELIBERATELY 207
#define IDS_TRIMS                       208
#define IDS_UNTRACKEDPOOL               209
#define IDS_THE_VERIFIED_DRIVERS        210
#define IDS_NAME_LOADS_UNLOADS          211
#define IDS_CURRENTPAGEDPOOLALLOCATIONS 212
#define IDS_CURRENTNONPAGEDPOOLALLOCATIONS 213
#define IDS_PEAKPAGEDPOOLALLOCATIONS    214
#define IDS_PEAKNONPAGEDPOOLALLOCATIONS 215
#define IDS_PAGEDPOOLUSAGEINBYTES       216
#define IDS_NONPAGEDPOOLUSAGEINBYTES    217
#define IDS_PEAKPAGEDPOOLUSAGEINBYTES   218
#define IDS_PEAKNONPAGEDPOOLUSAGEINBYTES 219
#define IDS_QUERY_CMDLINE_SWITCH        220
#define IDS_FLAGS_CMDLINE_SWITCH        221
#define IDS_ALL_CMDLINE_SWITCH          222
#define IDS_DONTREBOOT_CMDLINE_SWITCH   223
#define IDS_DRIVER_CMDLINE_SWITCH       224
#define IDS_ADDDRIVER_CMDLINE_SWITCH    225
#define IDS_REMOVEDRIVER_CMDLINE_SWITCH 226
#define IDS_CANNOT_CHANGE_SETTING_ON_FLY 227
#define IDS_VERIFIER_ADD_NOT_SUPPORTED  228
#define IDS_DYN_ADD_NOT_SUPPORTED       229
#define IDS_DYN_ADD_ALREADY_LOADED      230
#define IDS_DYN_ADD_INSUF_RESOURCES     231
#define IDS_DYN_ADD_ACCESS_DENIED       232
#define IDS_DYN_ADD_MISC_ERROR          233
#define IDS_VERIFIER_REMOVE_NOT_SUPPORTED 234
#define IDS_DYN_REMOVE_ALREADY_LOADED   235
#define IDS_DYN_REMOVE_INSUF_RESOURCES  236
#define IDS_DYN_REMOVE_ACCESS_DENIED    237
#define IDS_DYN_REMOVE_MISC_ERROR       238
#define IDS_NO_SETTINGS_WERE_CHANGED    239
#define IDS_CHANGED_SETTINGS_ARE        240
#define IDS_SPECIAL_POOL_ENABLED_NOW    241
#define IDS_SPECIAL_POOL_DISABLED_NOW   242
#define IDS_FORCE_IRQLCHECK_ENABLED_NOW 243
#define IDS_FORCE_IRQLCHECK_DISABLED_NOW 244
#define IDS_FAULT_INJECTION_ENABLED_NOW 245
#define IDS_POOL_TRACK_ENABLED_NOW      246
#define IDS_POOL_TRACK_DISABLED_NOW     247
#define IDS_IO_CHECKING_ENABLED_NOW     248
#define IDS_IO_CHECKING_DISABLED_NOW    249
#define IDS_CHANGES_ACTIVE_ONLY_BEFORE_REBOOT 250
#define IDS_FAULT_INJECTION_DISABLED_NOW 251
#define IDS_REBOOT                      255
#define IDS_SELECT_AT_LEAST_ONE_DRIVER  256
#define IDS_ENABLED_QUESTION            257
#define IDS_SETTING                     258
#define IDS_SPECIAL_POOL                259
#define IDS_POOL_TRACKING               260
#define IDS_IO_VERIFICATION             261
#define IDS_ENH_IO_VERIFICATION         262
#define IDS_FORCE_IRQL_CHECKING         263
#define IDS_DEADLOCK_DETECTION          264
#define IDS_DMA_CHECHKING               265
#define IDS_LOW_RESOURCE_SIMULATION     266
#define IDS_YES                         267
#define IDS_NO                          268
#define IDS_STANDARD_CMDLINE_SWITCH     269
#define IDS_REGQUERYVALUEEX_FAILED      272
#define IDS_REGSETT_PAGE_NEXT_DESCR     273
#define IDS_ALL_LOADED_DRIVERS          274
#define IDS_FOLLOWING_DRIVERS           275
#define IDS_COUNTER                     276
#define IDS_VALUE                       277
#define IDS_GCNT_PAGE_NEXT_DESCR        278
#define IDS_ALLOCATIONSATTEMPTED_LIST   279
#define IDS_ALLOCATIONSSUCCEEDED_LIST   280
#define IDS_ALLOCATIONSSUCCEEDEDSPECIALPOOL_LIST 281
#define IDS_ALLOCATIONSWITHNOTAG_LIST   282
#define IDS_UNTRACKEDPOOL_LIST          283
#define IDS_ALLOCATIONSFAILED_LIST      284
#define IDS_ALLOCATIONSFAILEDDELIBERATELY_LIST 285
#define IDS_RAISEIRQLS_LIST             286
#define IDS_ACQUIRESPINLOCKS_LIST       287
#define IDS_SYNCHRONIZEEXECUTIONS_LIST  288
#define IDS_TRIMS_LIST                  289
#define IDS_CURRENTPAGEDPOOLALLOCATIONS_LIST 290
#define IDS_PEAKPAGEDPOOLALLOCATIONS_LIST 291
#define IDS_PAGEDPOOLUSAGEINBYTES_LIST  292
#define IDS_PEAKPAGEDPOOLUSAGEINBYTES_LIST 293
#define IDS_CURRENTNONPAGEDPOOLALLOCATIONS_LIST 294
#define IDS_PEAKNONPAGEDPOOLALLOCATIONS_LIST 295
#define IDS_NONPAGEDPOOLUSAGEINBYTES_LIST 296
#define IDS_PEAKNONPAGEDPOOLUSAGEINBYTES_LIST 297
#define IDS_DCNT_PAGE_NEXT_DESCR        298
#define IDS_TOO_MANY_FILES_SELECTED     299
#define IDS_CANNOT_OPEN_FILES           300
#define IDS_DRIVER_IS_ALREADY_IN_LIST   301
#define IDS_QUERYSETT_CMDLINE_SWITCH    302
#define IDS_VERIFIED_DRIVERS            303
#define IDS_NEW_SETTINGS                304
#define IDS_NONE                        305
#define IDS_TAS_PAGE_NEXT_DESCR_REGISTRY 306
#define IDD_CRT_REGISTRY_SETTINGS_PAGE  601
#define IDD_DRVSTATUS_STAT_PAGE         602
#define IDD_FULL_LIST_SETT_PAGE         603
#define IDD_SELECT_DRIVERS_PAGE         604
#define IDD_CONFIRM_DRIVERS_PAGE        605
#define IDD_DRVSET_PAGE                 606
#define IDD_TAS_PAGE                    607
#define IDD_CUSTSETT_PAGE               608
#define IDD_GLOBAL_COUNTERS_PAGE        609
#define IDD_BUILDING_UNSIGNED_LIST_DIALOG 610
#define IDD_PERDRIVER_COUNTERS_PAGE     611
#define IDC_DRVSET_NOTSIGNED_RADIO      1004
#define IDC_DRVSET_OLDVER_RADIO         1005
#define IDC_DRVSET_ALLDRV_RADIO         1006
#define IDC_DRVSET_NAMESLIST_RADIO      1007
#define IDC_CUSTSETT_TYPICAL_CHECK      1008
#define IDC_CUSTSETT_EXCESS_CHECK       1009
#define IDC_CUSTSETT_LOWRES_CHECK       1010
#define IDC_UNSIGNED_PROGRESS           1012
#define IDC_UNSIGNED_STATIC             1013
#define IDC_UNSIGNED_CANCEL_BUTTON      1014
#define IDC_CONFDRV_LIST                1015
#define IDC_CONFDRV_TITLE_STATIC        1016
#define IDC_SELDRV_TITLE_STATIC         1019
#define IDC_SELDRV_LIST                 1020
#define IDC_CUSTSETT_PREDEF_RADIO       1022
#define IDC_CUSTSETT_FULLLIST_RADIO     1023
#define IDC_TAS_NEXT_DESCR_STATIC       1024
#define IDC_DRVSET_NEXT_DESCR_STATIC    1025
#define IDC_CONFDRV_NEXT_DESCR_STATIC   1026
#define IDC_SELDRV_NEXT_DESCR_STATIC    1027
#define IDC_CUSTSETT_NEXT_DESCR_STATIC  1028
#define IDC_CRTSTAT_NEXT_DESCR_STATIC   1029
#define IDC_FLSETT_NEXT_DESCR_STATIC    1030
#define IDC_FLSETT_LIST                 1031
#define IDC_CRTSTAT_DRIVERS_LIST        1032
#define IDC_CRTSTAT_SPECPOOL_EDIT       1033
#define IDC_CRTSTAT_IRQLCHCK_EDIT       1034
#define IDC_CRTSTAT_FAULTINJ_EDIT       1035
#define IDC_CRTSTAT_POOLT_EDIT          1036
#define IDC_CRTSTAT_IOVERIF_EDIT        1037
#define IDC_CRTSTAT_DEADLOCK_EDIT       1038
#define IDC_CRTSTAT_ENHIO_EDIT          1039
#define IDC_CRTSTAT_DMA_EDIT            1040
#define IDC_CRTSTAT_WARN_MSG            1041
#define IDC_CRTSTAT_SETTBITS_LIST       1042
#define IDC_REGSETT_NEXT_DESCR_STATIC   1043
#define IDC_REGSETT_SETTBITS_LIST       1044
#define IDC_REGSETT_DRIVERS_LIST        1045
#define IDC_TAS_TYPICAL_RADIO           1050
#define IDC_TAS_ADVANCED_RADIO          1051
#define IDC_TAS_DELETE_RADIO            1052
#define IDC_TAS_VIEWREGISTRY_RADIO      1053
#define IDC_TAS_STATISTICS_RADIO        1054
#define IDC_REGSETT_VERIFIED_DRV_STATIC 1061
#define IDC_GLOBC_NEXT_DESCR_STATIC     1062
#define IDC_GLOBC_LIST                  1063
#define IDC_PERDRVC_DRIVER_COMBO        1064
#define IDC_PERDRVC_LIST                1065
#define IDC_PERDRVC_NEXT_DESCR_STATIC   1066
#define IDC_VOLBITS_LIST                1067
#define IDC_CRTSTAT_CHSETT_BUTTON       1068
#define IDC_CRTSTAT_ADDDRV_BUTTON       1069
#define IDC_SELDRV_ADD_BUTTON           1069
#define IDC_CRTSTAT_REMDRVT_BUTTON      1070

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        140
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1070
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\verfpage.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: VerfPage.h
// author: DMihai
// created: 11/1/00
//
// Description:
//  

#if !defined(AFX_VERFPAGE_H__FCFF7AE3_57F4_4762_BEBD_F84C571B533A__INCLUDED_)
#define AFX_VERFPAGE_H__FCFF7AE3_57F4_4762_BEBD_F84C571B533A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// VerfPage.h : header file
//

#include "SlowDlg.h"

//
// The one and only "slow progress" dialog
//

extern CSlowProgressDlg g_SlowProgressDlg;

/////////////////////////////////////////////////////////////////////////////
// CVerifierPropertyPage dialog

class CVerifierPropertyPage : public CPropertyPage
{
    DECLARE_DYNAMIC(CVerifierPropertyPage)

// Construction
public:
	CVerifierPropertyPage( ULONG uDialogId );
	~CVerifierPropertyPage();

protected:
    //
    // All the property pages derived from this class should 
    // provide these methods.
    //

    virtual ULONG GetDialogId() const = 0;

    //
    // Return the previous page ID, based on our history array
    // and remove it from the array because will activate. Called
    // by our property pages when the "back" button is clicked
    //

    ULONG GetAndRemovePreviousDialogId();

    //
    // Property pages derived from this class should notify us 
    // whenever we go to a next page to record the current page ID in 
    // the global array m_aPageIds
    //

    VOID GoingToNextPageNotify( LRESULT lNextPageId );

protected:
    //
    // Overrides
    //

    //
    // Use this to kill any currently running worker threads
    //

    virtual BOOL OnQueryCancel( );

    //
	// ClassWizard generate virtual function overrides
    //

	//{{AFX_VIRTUAL(CVerifierPropertyPage)
	virtual LRESULT OnWizardBack();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CVerifierPropertyPage)
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_VERFPAGE_H__FCFF7AE3_57F4_4762_BEBD_F84C571B533A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\verifier.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: verifier.cpp 
// author: DMihai
// created: 11/1/00
//
// Description
//
// Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "verifier.h"

#include "vsheet.h"
#include "vrfutil.h"
#include "vglobal.h"
#include "CmdLine.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CVerifierApp

BEGIN_MESSAGE_MAP(CVerifierApp, CWinApp)
	//{{AFX_MSG_MAP(CVerifierApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CVerifierApp construction

CVerifierApp::CVerifierApp()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance

    CString strAppName;

    if( VrfLoadString( IDS_APPTITLE, strAppName ) )
    {
        m_pszAppName = _tcsdup( (LPCTSTR)strAppName );
    }
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CVerifierApp object

CVerifierApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CVerifierApp initialization

BOOL CVerifierApp::InitInstance()
{
	DWORD dwExitCode;
    BOOL bGlobalDataInitialized;
    static CVerifierPropSheet MainDlg;

	//
	// Assume program will run fine and will not change any settings
	//

	dwExitCode = EXIT_CODE_SUCCESS;

    bGlobalDataInitialized = VerifInitalizeGlobalData();

	if( TRUE != bGlobalDataInitialized )
	{
		//
		// Cannot run the app
		//

		dwExitCode = EXIT_CODE_ERROR;

		goto ExitApp;
	}

    //
    // Check for command line arguments
    //

    if( __argc > 1 )
    {
        //
        // Run just in command line mode
        //

        _tsetlocale( LC_ALL, _T( ".OCP" ) );

        g_bCommandLineMode = TRUE;

        dwExitCode = CmdLineExecute( __argc, __targv );

        goto ExitApp;
    }
    else
    {
        FreeConsole();
    }

	//
	// Standard MFC initialization
	//

	AfxEnableControlContainer();

    //
    // Create our brush used to fill out the background of our steps lists
    //

    g_hDialogColorBrush = GetSysColorBrush( COLOR_3DFACE );

    //
    // There is only one property sheet in this program so we declared it static
    //

	m_pMainWnd = &MainDlg;
	
	MainDlg.DoModal();

    if( g_bSettingsSaved )
    {
        dwExitCode = EXIT_CODE_REBOOT_NEEDED;
    }
    else
    {
        dwExitCode = EXIT_CODE_SUCCESS;
    }
    
    goto ExitApp;

ExitApp:

    //
    // All done, exit the app
    //
	
	exit( dwExitCode );

    //
    // not reached
    // 

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\vbitsdlg.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: VBitsDlg.h
// author: DMihai
// created: 11/1/00
//
// Description:
//

#if !defined(AFX_VBITSDLG_H__AEF2E123_B664_41DC_9257_21CA6DF54CF6__INCLUDED_)
#define AFX_VBITSDLG_H__AEF2E123_B664_41DC_9257_21CA6DF54CF6__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// VBitsDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CVolatileBitsDlg dialog

class CVolatileBitsDlg : public CDialog
{
public:
    //
    // Construction
    //

	CVolatileBitsDlg(CWnd* pParent = NULL);   // standard constructor

protected:
    //
    // Methods
    //

    VOID SetupListHeader();
    VOID FillTheList( DWORD dwVerifierBits );
    VOID AddListItem( ULONG uIdResourceString, BOOL bInitiallyEnabled );

    DWORD GetNewVerifierFlags();

protected:
    //
    // Data
    //

    //
    // Dialog Data
    //

	//{{AFX_DATA(CVolatileBitsDlg)
	enum { IDD = IDD_VOLATILE_BITS_DIALOG };
	CListCtrl	m_SettingsList;
	//}}AFX_DATA


protected:
    //
    // Overrides
    //

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CVolatileBitsDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CVolatileBitsDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_VBITSDLG_H__AEF2E123_B664_41DC_9257_21CA6DF54CF6__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\verifier.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: verifier.h
// author: DMihai
// created: 11/1/00
//
// Description:
//  
// Main header file for the VERIFIER application
//

#if !defined(AFX_VERIFIER_H__0B3398A6_AD3D_482C_B915_670BA4D7F6E1__INCLUDED_)
#define AFX_VERIFIER_H__0B3398A6_AD3D_482C_B915_670BA4D7F6E1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols


//
// Exit codes for cmd line execution
//

#define EXIT_CODE_SUCCESS       0
#define EXIT_CODE_ERROR         1
#define EXIT_CODE_REBOOT_NEEDED 2


/////////////////////////////////////////////////////////////////////////////
// CVerifierApp:
// See verifier.cpp for the implementation of this class
//

class CVerifierApp : public CWinApp
{
public:
	CVerifierApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CVerifierApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CVerifierApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_VERIFIER_H__0B3398A6_AD3D_482C_B915_670BA4D7F6E1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\vglobal.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: VGlobal.cpp
// author: DMihai
// created: 11/1/00
//
// Description
//

#include "stdafx.h"
#include "verifier.h"

#include "vglobal.h"
#include "VrfUtil.h"

//
// Help file name
//

TCHAR g_szVerifierHelpFile[] = _T( "verifier.hlp" );

//
// Application name ("Driver Verifier Manager")
//

CString g_strAppName;

//
// Exe module handle - used for loading resources
//

HMODULE g_hProgramModule;

//
// GUI mode or command line mode?
//

BOOL g_bCommandLineMode = FALSE;

//
// Brush used to fill out the background of our steps lists
//

HBRUSH g_hDialogColorBrush = NULL;

//
// Path to %windir%\system32\drivers
//

CString g_strSystemDir;

//
// Path to %windir%\system32\drivers
//

CString g_strDriversDir;

//
// Initial current directory
//

CString g_strInitialCurrentDirectory;

//
// Filled out by CryptCATAdminAcquireContext
//

HCATADMIN g_hCatAdmin = NULL;

//
// Highest user address - used to filter out user-mode stuff
// returned by NtQuerySystemInformation ( SystemModuleInformation )
//

PVOID g_pHighestUserAddress;

//
// Did we enable the debugprivilege already?
//

BOOL g_bPrivegeEnabled = FALSE;

//
// Need to reboot ?
//

BOOL g_bSettingsSaved = FALSE;

//
// Dummy text used to insert an item in a list control with checkboxes
//

TCHAR g_szVoidText[] = _T( "" );

//
// New registry settings
//

CVerifierSettings   g_NewVerifierSettings;

//
// Are all drivers verified? (loaded from the registry)
//

BOOL g_bAllDriversVerified;

//
// Drivers to be verified names (loaded from the registry)
// We have data in this array only if g_bAllDriversVerified == FALSE.
//

CStringArray g_astrVerifyDriverNamesRegistry;

//
// Verifier flags (loaded from the registry)
//

DWORD g_dwVerifierFlagsRegistry;

////////////////////////////////////////////////////////////////
BOOL VerifInitalizeGlobalData( VOID )
{
    BOOL bSuccess;
    LPTSTR szDirectory;
    ULONG uCharacters;
    MEMORYSTATUSEX MemoryStatusEx;

    //
    // Exe module handle - used for loading resources
    //

    g_hProgramModule = GetModuleHandle( NULL );

	bSuccess = FALSE;

	//
	// Load the app name from the resources
	//

	TRY
	{
		bSuccess = VrfLoadString( IDS_APPTITLE,
                                  g_strAppName );

		if( TRUE != bSuccess )
		{
			VrfErrorResourceFormat( IDS_CANNOT_LOAD_APP_TITLE );
		}
	}
	CATCH( CMemoryException, pMemException )
	{
		VrfErrorResourceFormat( IDS_NOT_ENOUGH_MEMORY );
	}
    END_CATCH

    if( TRUE != bSuccess )
    {
        goto Done;
    }

    //
    // Save the %windir%\system32 and %windir%\system32\drivers 
    // paths in some global variables
    //

    szDirectory = g_strSystemDir.GetBuffer( MAX_PATH );

    if( NULL == szDirectory )
    {
        VrfErrorResourceFormat( IDS_NOT_ENOUGH_MEMORY );

        goto Done;
    }

    uCharacters = GetSystemDirectory( szDirectory,
                                      MAX_PATH );

    g_strSystemDir.ReleaseBuffer();

    if( uCharacters == 0 || uCharacters >= MAX_PATH )
    {
        VrfErrorResourceFormat( IDS_CANNOT_GET_SYSTEM_DIRECTORY );

        bSuccess = FALSE;

        goto Done;
    }

    g_strDriversDir = g_strSystemDir + "\\drivers" ;

    //
    // Save the initial current directory
    //

    szDirectory = g_strInitialCurrentDirectory.GetBuffer( MAX_PATH );

    if( NULL == szDirectory )
    {
        VrfErrorResourceFormat( IDS_NOT_ENOUGH_MEMORY );

        goto Done;
    }

    uCharacters = GetCurrentDirectory( MAX_PATH,
                                       szDirectory );

    g_strInitialCurrentDirectory.ReleaseBuffer();

    if( uCharacters == 0 || uCharacters >= MAX_PATH )
    {
        VrfErrorResourceFormat( IDS_CANNOT_GET_CURRENT_DIRECTORY );

        bSuccess = FALSE;

        goto Done;
    }

    //
    // We need the highest user-mode address to filter out user-mode stuff
    // returned by NtQuerySystemInformation ( SystemModuleInformation )
    //

    ZeroMemory( &MemoryStatusEx,
                sizeof( MemoryStatusEx ) );

    MemoryStatusEx.dwLength = sizeof( MemoryStatusEx );

    bSuccess = GlobalMemoryStatusEx( &MemoryStatusEx );

    if( TRUE != bSuccess )
    {
        goto Done;
    }

    g_pHighestUserAddress = (PVOID) MemoryStatusEx.ullTotalVirtual;

Done:

    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\vsetting.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: VSetting.cpp
// author: DMihai
// created: 11/1/00
//
// Description
//
// Implementation of the CVerifierSettings class.
//


#include "stdafx.h"
#include "verifier.h"

#include "VSetting.h"
#include "VrfUtil.h"
#include "VGlobal.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


//////////////////////////////////////////////////////////////////////
// CDriverData Class
//////////////////////////////////////////////////////////////////////
CDriverData::CDriverData()
{
    m_SignedStatus = SignedNotVerifiedYet;
    m_VerifyDriverStatus = VerifyDriverNo;
}

CDriverData::CDriverData( const CDriverData &DriverData )
{
    m_strName           = DriverData.m_strName;
    m_SignedStatus      = DriverData.m_SignedStatus;
    m_VerifyDriverStatus= DriverData.m_VerifyDriverStatus;
}

CDriverData::CDriverData( LPCTSTR szDriverName )
{
    m_SignedStatus = SignedNotVerifiedYet;
    m_VerifyDriverStatus = VerifyDriverNo;

    m_strName = szDriverName;
}

CDriverData::~CDriverData()
{
}

//////////////////////////////////////////////////////////////////////
BOOL CDriverData::LoadDriverHeaderData()
{
    //
    // N.B. 
    //
    // The imagehlp functions are not multithreading safe 
    // (see Whistler bug #88373) so if we want to use them from more than
    // one thread we will have to aquire some critical section before.
    //
    // Currently only one thread is using the imagehlp APIs in this app
    // (CSlowProgressDlg::LoadDriverDataWorkerThread) so we don't need
    // our synchronization.
    //

    LPTSTR szDriverName;
    LPTSTR szDriversDir;
    PLOADED_IMAGE pLoadedImage;
    BOOL bSuccess;
    BOOL bUnloaded;

    bSuccess = FALSE;

    ASSERT( m_strName.GetLength() > 0 );

    //
    // ImageLoad doesn't know about const pointers so
    // we have to GetBuffer here :-(
    //

    szDriverName = m_strName.GetBuffer( m_strName.GetLength() + 1 );

    if( NULL == szDriverName )
    {
        goto Done;
    }

    szDriversDir = g_strDriversDir.GetBuffer( g_strDriversDir.GetLength() + 1 );

    if( NULL == szDriversDir )
    {
        m_strName.ReleaseBuffer();

        goto Done;
    }

    //
    // Load the image
    //

    pLoadedImage = VrfImageLoad( szDriverName,
                                 szDriversDir );

    if( NULL == pLoadedImage )
    {
        //
        // Could not load the image from %windir%\system32\drivers
        // Try again from the PATH
        //

        pLoadedImage = VrfImageLoad( szDriverName,
                                     NULL );
    }

    //
    // Give our string buffers back to MFC
    //

    m_strName.ReleaseBuffer();
    g_strDriversDir.ReleaseBuffer();

    if( NULL == pLoadedImage )
    {
        //
        // We couldn't load this image - bad luck
        //

        TRACE( _T( "ImageLoad failed for %s, error %u\n" ),
            (LPCTSTR) m_strName,
            GetLastError() );

        goto Done;
    }

    //
    // Keep the OS and image version information (4 means NT 4 etc.)
    //

    m_wMajorOperatingSystemVersion = 
        pLoadedImage->FileHeader->OptionalHeader.MajorOperatingSystemVersion;

    m_wMajorImageVersion = 
        pLoadedImage->FileHeader->OptionalHeader.MajorImageVersion;

    //
    // Check if the current driver is a miniport
    //

    VrfIsDriverMiniport( pLoadedImage,
                         m_strMiniportName );

    //
    // Clean-up
    //

    bUnloaded = ImageUnload( pLoadedImage );

    //
    // If ImageUnload fails we cannot do much about it...
    //

    ASSERT( bUnloaded );

    bSuccess = TRUE;

Done:

    return bSuccess;
}


//////////////////////////////////////////////////////////////////////
BOOL CDriverData::LoadDriverVersionData()
{
    BOOL bResult;
    PVOID pWholeVerBlock;
    PVOID pTranslationInfoBuffer;
    LPCTSTR szVariableValue;
    LPTSTR szDriverPath;
    DWORD dwWholeBlockSize;
    DWORD dwDummyHandle;
    UINT uInfoLengthInTChars;
    TCHAR szLocale[ 32 ];
    TCHAR szBlockName[ 64 ];
    CString strDriverPath;

    bResult = FALSE;

    //
    // Get the size of the file info block
    //
    // GetFileVersionInfoSize doesn't know about 
    // const pointers so we need to GetBuffer here :-(
    //

    strDriverPath = g_strDriversDir + '\\' + m_strName;

    szDriverPath = strDriverPath.GetBuffer( strDriverPath.GetLength() + 1 );

    if( NULL == szDriverPath )
    {
        goto InitializeWithDefaults;
    }

    dwWholeBlockSize = GetFileVersionInfoSize(
        szDriverPath,
        &dwDummyHandle );

    strDriverPath.ReleaseBuffer();

    if( dwWholeBlockSize == 0 )
    {
        //
        // Couldn't find the binary in %windir%\system32\drivers
        // Try %windir%\system32 too
        //

        strDriverPath = g_strSystemDir + '\\' + m_strName;

        szDriverPath = strDriverPath.GetBuffer( strDriverPath.GetLength() + 1 );

        if( NULL == szDriverPath )
        {
            goto InitializeWithDefaults;
        }

        dwWholeBlockSize = GetFileVersionInfoSize(
            szDriverPath,
            &dwDummyHandle );

        strDriverPath.ReleaseBuffer();

        if( dwWholeBlockSize == 0 )
        {
            //
            // Couldn't read version information
            //

            goto InitializeWithDefaults;
        }
    }

    //
    // Allocate the buffer for the version information
    //

    pWholeVerBlock = malloc( dwWholeBlockSize );

    if( pWholeVerBlock == NULL )
    {
        goto InitializeWithDefaults;
    }

    //
    // Get the version information
    //
    // GetFileVersionInfo doesn't know about 
    // const pointers so we need to GetBuffer here :-(
    //

    szDriverPath = strDriverPath.GetBuffer( strDriverPath.GetLength() + 1 );

    if( NULL == szDriverPath )
    {
        free( pWholeVerBlock );

        goto InitializeWithDefaults;
    }

    bResult = GetFileVersionInfo(
        szDriverPath,
        dwDummyHandle,
        dwWholeBlockSize,
        pWholeVerBlock );

    strDriverPath.ReleaseBuffer();

    if( bResult != TRUE )
    {
        free( pWholeVerBlock );

        goto InitializeWithDefaults;
    }

    //
    // Get the locale info
    //

    bResult = VerQueryValue(
        pWholeVerBlock,
        _T( "\\VarFileInfo\\Translation" ),
        &pTranslationInfoBuffer,
        &uInfoLengthInTChars );

    if( TRUE != bResult || NULL == pTranslationInfoBuffer )
    {
        free( pWholeVerBlock );

        goto InitializeWithDefaults;
    }

    //
    // Locale info comes back as two little endian words.
    // Flip 'em, 'cause we need them big endian for our calls.
    //

    _stprintf(
        szLocale,
        _T( "%02X%02X%02X%02X" ),
		HIBYTE( LOWORD ( * (LPDWORD) pTranslationInfoBuffer) ),
		LOBYTE( LOWORD ( * (LPDWORD) pTranslationInfoBuffer) ),
		HIBYTE( HIWORD ( * (LPDWORD) pTranslationInfoBuffer) ),
		LOBYTE( HIWORD ( * (LPDWORD) pTranslationInfoBuffer) ) );

    //
    // Get the file version
    //

    _stprintf(
        szBlockName,
        _T( "\\StringFileInfo\\%s\\FileVersion" ),
        szLocale );

    bResult = VerQueryValue(
        pWholeVerBlock,
        szBlockName,
        (PVOID*) &szVariableValue,
        &uInfoLengthInTChars );

    if( TRUE != bResult || 0 == uInfoLengthInTChars )
    {
        //
        // Couldn't find the version
        //

        VERIFY( m_strFileVersion.LoadString( IDS_UNKNOWN ) );
    }
    else
    {
        //
        // Found the version
        //

        m_strFileVersion = szVariableValue;
    }

    //
    // Get the company name
    //

    _stprintf(
        szBlockName,
        _T( "\\StringFileInfo\\%s\\CompanyName" ),
        szLocale );

    bResult = VerQueryValue(
        pWholeVerBlock,
        szBlockName,
        (PVOID*) &szVariableValue,
        &uInfoLengthInTChars );

    if( TRUE != bResult || uInfoLengthInTChars == 0 )
    {
        //
        // Coudln't find the company name
        //

        m_strCompanyName.LoadString( IDS_UNKNOWN );
    }
    else
    {
        m_strCompanyName = szVariableValue;
    }

    //
    // Get the FileDescription
    //

    _stprintf(
        szBlockName,
        _T( "\\StringFileInfo\\%s\\FileDescription" ),
        szLocale );

    bResult = VerQueryValue(
        pWholeVerBlock,
        szBlockName,
        (PVOID*) &szVariableValue,
        &uInfoLengthInTChars );

    if( TRUE != bResult || uInfoLengthInTChars == 0 )
    {
        //
        // Coudln't find the FileDescription
        //

        m_strFileDescription.LoadString( IDS_UNKNOWN );
    }
    else
    {
        m_strFileDescription = szVariableValue;
    }

    //
    // clean-up
    //

    free( pWholeVerBlock );

    goto Done;

InitializeWithDefaults:
    
    m_strCompanyName.LoadString( IDS_UNKNOWN );
    m_strFileVersion.LoadString( IDS_UNKNOWN );
    m_strFileDescription.LoadString( IDS_UNKNOWN );

Done:
    //
    // We always return TRUE from this function because 
    // the app will work fine without the version info - 
    // it's just something that we would like to be able to display
    //

    return TRUE;
}

//////////////////////////////////////////////////////////////////////
BOOL CDriverData::LoadDriverImageData()
{
    BOOL bResult1;
    BOOL bResult2;

    bResult1 = LoadDriverHeaderData();
    bResult2 = LoadDriverVersionData();

    return ( bResult1 && bResult2 );
}

//////////////////////////////////////////////////////////////////////
void CDriverData::AssertValid() const
{
    ASSERT( SignedNotVerifiedYet    == m_SignedStatus ||
            SignedYes               == m_SignedStatus ||
            SignedNo                == m_SignedStatus );

    ASSERT( VerifyDriverNo          == m_VerifyDriverStatus  ||
            VerifyDriverYes         == m_VerifyDriverStatus  );

    CObject::AssertValid();
}

//////////////////////////////////////////////////////////////////////
// CDriverDataArray Class
//////////////////////////////////////////////////////////////////////

CDriverDataArray::~CDriverDataArray()
{
    DeleteAll();
}

//////////////////////////////////////////////////////////////////////
VOID CDriverDataArray::DeleteAll()
{
    INT_PTR nArraySize;
    CDriverData *pCrtDriverData;

    nArraySize = GetSize();

    while( nArraySize > 0 )
    {
        nArraySize -= 1;

        pCrtDriverData = GetAt( nArraySize );

        ASSERT_VALID( pCrtDriverData );

        delete pCrtDriverData;
    }

    RemoveAll();
}

//////////////////////////////////////////////////////////////////////
CDriverData *CDriverDataArray::GetAt( INT_PTR nIndex ) const
{
    return (CDriverData *)CObArray::GetAt( nIndex );
}

//////////////////////////////////////////////////////////////////////
CDriverDataArray &CDriverDataArray::operator = (const CDriverDataArray &DriversDataArray)
{
    INT_PTR nNewArraySize;
    CDriverData *pCopiedDriverData;
    CDriverData *pNewDriverData;

    DeleteAll();

    nNewArraySize = DriversDataArray.GetSize();

    while( nNewArraySize > 0 )
    {
        nNewArraySize -= 1;
        
        pCopiedDriverData = DriversDataArray.GetAt( nNewArraySize );
        ASSERT_VALID( pCopiedDriverData );

        pNewDriverData = new CDriverData( *pCopiedDriverData );

        if( NULL != pNewDriverData )
        {
            ASSERT_VALID( pNewDriverData );

            Add( pNewDriverData );
        }
        else
        {
            VrfErrorResourceFormat( IDS_NOT_ENOUGH_MEMORY );
            goto Done;
        }
    }

Done:
    //
    // All done, assert that our data is consistent
    //

    ASSERT_VALID( this );

    return *this;
}


//////////////////////////////////////////////////////////////////////
// CDriversSet Class
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDriversSet::CDriversSet()
{
    m_DriverSetType = DriversSetNotSigned;
    m_bDriverDataInitialized = FALSE;
    m_bUnsignedDriverDataInitialized = FALSE; 
}

CDriversSet::~CDriversSet()
{

}

//////////////////////////////////////////////////////////////////////
BOOL CDriversSet::FindUnsignedDrivers( HANDLE hAbortEvent,
                                       CVrfProgressCtrl &ProgressCtl)
{
    INT_PTR nAllDriverNames;
    INT_PTR nCrtDriverName;
    DWORD dwWaitResult;
    BOOL bSigned;
    BOOL bChangedCurrentDirectory;
    CDriverData *pDriverData;

    ProgressCtl.SetRange32(0, 100);
    ProgressCtl.SetStep( 1 );
    ProgressCtl.SetPos( 0 );

    bChangedCurrentDirectory = FALSE;

    if( TRUE != m_bUnsignedDriverDataInitialized )
    {
        ASSERT( TRUE == m_bDriverDataInitialized );

        //
        // We are going to check all drivers's signature
        // so change directory to %windir%\system32\drivers first
        // 

        bChangedCurrentDirectory = SetCurrentDirectory( g_strDriversDir );

        if( TRUE != bChangedCurrentDirectory )
        {
            VrfErrorResourceFormat( IDS_CANNOT_SET_CURRENT_DIRECTORY,
                                    (LPCTSTR) g_strDriversDir );
        }

        //
        // The unsigned drivers data is not initialized yet.
        // Try to initialize it now.
        //

        nAllDriverNames = m_aDriverData.GetSize();

        ProgressCtl.SetRange32(0, nAllDriverNames );

        for( nCrtDriverName = 0; nCrtDriverName < nAllDriverNames; nCrtDriverName+=1 )
        {
            if( NULL != hAbortEvent )
            {
                //
                // Check if the thread has to die
                //

                dwWaitResult = WaitForSingleObject( hAbortEvent,
                                                    0 );

                if( WAIT_OBJECT_0 == dwWaitResult )
                {
                    //
                    // We have to die...
                    //

                    TRACE( _T( "CDriversSet::FindUnsignedDrivers : aborting at driver %d of %d\n" ),
                        nCrtDriverName,
                        nAllDriverNames );

                    goto Done;
                }
            }

            pDriverData = m_aDriverData.GetAt( nCrtDriverName );

            ASSERT_VALID( pDriverData );

            //
            // If we already checked the signature of this driver before
            // don't spend any more time on it - use the cached data
            //

            if( CDriverData::SignedNotVerifiedYet == pDriverData->m_SignedStatus )
            {
                bSigned = IsDriverSigned( pDriverData->m_strName );

                if( TRUE != bSigned )
                {
                    //
                    // This driver is not signed
                    //

                    pDriverData->m_SignedStatus = CDriverData::SignedNo;

                }
                else
                {
                    //
                    // This driver is signed
                    //

                    pDriverData->m_SignedStatus = CDriverData::SignedYes;
                }
            }

            ProgressCtl.StepIt();
        }
        
        m_bUnsignedDriverDataInitialized = TRUE;
    }

Done:

    if( TRUE == bChangedCurrentDirectory )
    {
        SetCurrentDirectory( g_strInitialCurrentDirectory );
    }

    return m_bUnsignedDriverDataInitialized;
}

//////////////////////////////////////////////////////////////////////
BOOL CDriversSet::LoadAllDriversData( HANDLE hAbortEvent,
                                      CVrfProgressCtrl	&ProgressCtl )
{
    ULONG uBufferSize;
    ULONG uCrtModule;
    PVOID pBuffer;
    INT nCrtModuleNameLength;
    INT nBackSlashIndex;
    INT_PTR nDrvDataIndex;
    NTSTATUS Status;
    LPTSTR szCrtModuleName;
    DWORD dwWaitResult;
    CString strCrModuleName;
    CDriverData *pDriverData;
    PRTL_PROCESS_MODULES Modules;

    ProgressCtl.SetPos( 0 );
    ProgressCtl.SetRange32( 0, 100 );
    ProgressCtl.SetStep( 1 );

    m_aDriverData.DeleteAll();

    if( TRUE != m_bDriverDataInitialized )
    {
        for( uBufferSize = 0x10000; TRUE; uBufferSize += 0x1000) 
        {
            //
            // Allocate a new buffer
            //

            pBuffer = new BYTE[ uBufferSize ];

            if( NULL == pBuffer ) 
            {
                goto Done;
            }

            //
            // Query the kernel
            //

            Status = NtQuerySystemInformation ( SystemModuleInformation,
                                                pBuffer,
                                                uBufferSize,
                                                NULL);

            if( ! NT_SUCCESS( Status ) ) 
            {
                delete pBuffer;

                if (Status == STATUS_INFO_LENGTH_MISMATCH) 
                {
                    //
                    // Try with a bigger buffer
                    //

                    continue;
                }
                else 
                {
                    //
                    // Fatal error - we cannot query
                    //

                    VrfErrorResourceFormat( IDS_CANT_GET_ACTIVE_DRVLIST,
                                            Status );

                    goto Done;
                }
            }
            else 
            {
                //
                // Got all the information we needed
                //

                break;
            }
        }

        Modules = (PRTL_PROCESS_MODULES)pBuffer;

        ProgressCtl.SetRange32(0, Modules->NumberOfModules );

        for( uCrtModule = 0; uCrtModule < Modules->NumberOfModules; uCrtModule += 1 ) 
        {
            //
            // Check if the user wants to abort this long file processing...
            //

            if( NULL != hAbortEvent )
            {
                //
                // Check if the thread has to die
                //

                dwWaitResult = WaitForSingleObject( hAbortEvent,
                                                    0 );

                if( WAIT_OBJECT_0 == dwWaitResult )
                {
                    //
                    // We have to die...
                    //

                    TRACE( _T( "CDriversSet::LoadAllDriversData : aborting at driver %u of %u\n" ),
                           uCrtModule,
                           (ULONG) Modules->NumberOfModules );

                    delete pBuffer;

                    goto Done;
                }
            }

            if( Modules->Modules[uCrtModule].ImageBase < g_pHighestUserAddress )
            {
                //
                // This is a user-mode module - we don't care about it
                //

                ProgressCtl.StepIt();

                continue;
            }

            //
            // Add this driver to our list
            //

            nCrtModuleNameLength = strlen( (const char*)&Modules->Modules[uCrtModule].FullPathName[0] );

            szCrtModuleName = strCrModuleName.GetBuffer( nCrtModuleNameLength + 1 );

            if( NULL == szCrtModuleName )
            {
                VrfErrorResourceFormat( IDS_NOT_ENOUGH_MEMORY );

                goto Done;
            }

#ifdef UNICODE

            MultiByteToWideChar( CP_ACP, 
                                 0, 
                                 (const char*)&Modules->Modules[uCrtModule].FullPathName[0],
                                 -1, 
                                 szCrtModuleName, 
                                 ( nCrtModuleNameLength + 1 ) * sizeof( TCHAR ) );

#else
            strcpy( szCrtModuleName, 
                    (const char*)&Modules->Modules[uCrtModule].FullPathName[0] );
#endif

            strCrModuleName.ReleaseBuffer();

            //
            // Keep only the file name, without the path
            //
            // It turns out that NtQuerySystemInformation ( SystemModuleInformation )
            // can return the path in several different formats
            //
            // E.g.
            //
            // \winnt\system32\ntoskrnl.exe
            // acpi.sys
            // \winnt\system32\drivers\battc.sys
            // \systemroot\system32\drivers\videoprt.sys
            //

            nBackSlashIndex = strCrModuleName.ReverseFind( _T( '\\' ) );
            
            if( nBackSlashIndex > 0 )
            {
                strCrModuleName = strCrModuleName.Right( nCrtModuleNameLength - nBackSlashIndex - 1 );
            }

            //
            // Add a data entry for this driver
            //

            strCrModuleName.MakeLower();

            nDrvDataIndex = AddNewDriverData( strCrModuleName );

            //
            // Deal with the kernel and HAL differently
            //

            if( ( uCrtModule == 0 || uCrtModule == 1 ) && nDrvDataIndex >= 0)
            {
                pDriverData = m_aDriverData.GetAt( nDrvDataIndex );

                ASSERT_VALID( pDriverData );

                if( 0 == uCrtModule )
                {
                    //
                    // This is the kernel
                    //

                    pDriverData->m_strReservedName = _T( "ntoskrnl.exe" );
                }
                else
                {
                    //
                    // This is the kernel
                    //

                    pDriverData->m_strReservedName = _T( "hal.dll" );
                }
            }

            ProgressCtl.StepIt();
        }

        delete pBuffer;

        m_bDriverDataInitialized = TRUE;
    }
    
Done:

    return m_bDriverDataInitialized;
}

//////////////////////////////////////////////////////////////////////
BOOL CDriversSet::ShouldDriverBeVerified( const CDriverData *pDriverData ) const
{
    BOOL bResult;

    bResult = FALSE;

    switch( m_DriverSetType )
    {
    case DriversSetNotSigned:
        bResult = ( CDriverData::SignedNo == pDriverData->m_SignedStatus );
        break;

    case DriversSetOldOs:
        bResult = ( 0 != pDriverData->m_wMajorOperatingSystemVersion && 5 > pDriverData->m_wMajorOperatingSystemVersion ) ||
                  ( 0 != pDriverData->m_wMajorImageVersion && 5 > pDriverData->m_wMajorImageVersion );
        break;

    case DriversSetAllDrivers:
        bResult = TRUE;
        break;

    case DriversSetCustom:
        bResult = ( CDriverData::VerifyDriverYes == pDriverData->m_VerifyDriverStatus );
        break;
        
    default:
        //
        // Oops, how did we get here?!?
        //

        ASSERT( FALSE );
    }

    return bResult;
}

//////////////////////////////////////////////////////////////////////
BOOL CDriversSet::ShouldVerifySomeDrivers( ) const
{
    INT_PTR nDrivers;
    INT_PTR nCrtDriver;
    CDriverData *pDriverData;
    BOOL bShouldVerifySome;

    bShouldVerifySome = FALSE;

    nDrivers = m_aDriverData.GetSize();

    for( nCrtDriver = 0; nCrtDriver < nDrivers; nCrtDriver += 1 )
    {
         pDriverData = m_aDriverData.GetAt( nCrtDriver );

         ASSERT_VALID( pDriverData );

         if( ShouldDriverBeVerified( pDriverData ) )
         {
             bShouldVerifySome = TRUE;
             break;
         }
    }

    return bShouldVerifySome;
}

//////////////////////////////////////////////////////////////////////
BOOL CDriversSet::GetDriversToVerify( CString &strDriversToVerify )
{
    INT_PTR nDriversNo;
    INT_PTR nCrtDriver;
    CDriverData *pCrtDrvData;

    if( DriversSetAllDrivers == m_DriverSetType )
    {
        //
        // Verify all drivers
        //

        strDriversToVerify = _T( '*' );
    }
    else
    {
        //
        // Parse all the drivers list and see which ones should be verified
        //

        strDriversToVerify = _T( "" );

        nDriversNo = m_aDriverData.GetSize();

        for( nCrtDriver = 0; nCrtDriver < nDriversNo; nCrtDriver += 1 )
        {
            pCrtDrvData = m_aDriverData.GetAt( nCrtDriver );

            ASSERT_VALID( pCrtDrvData );

            if( ShouldDriverBeVerified( pCrtDrvData ) )
            {
                if( pCrtDrvData->m_strReservedName.GetLength() > 0 )
                {
                    //
                    // Kernel or HAL
                    //

                    VrfAddDriverNameNoDuplicates( pCrtDrvData->m_strReservedName,
                                                  strDriversToVerify );        
                }
                else
                {
                    //
                    // Regular driver
                    //

                    VrfAddDriverNameNoDuplicates( pCrtDrvData->m_strName,
                                                  strDriversToVerify );        
                }

                if( pCrtDrvData->m_strMiniportName.GetLength() > 0 )
                {
                    //
                    // This is a miniport - auto-enable the corresponding driver
                    //

                    TRACE( _T( "Auto-enabling %s\n" ), pCrtDrvData->m_strMiniportName );

                    VrfAddDriverNameNoDuplicates( pCrtDrvData->m_strMiniportName,
                                                  strDriversToVerify );        
                }
            }
        }
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////
INT_PTR CDriversSet::AddNewDriverData( LPCTSTR szDriverName, BOOL bForceIfFileNotFound /*= FALSE*/)
{
    INT_PTR nIndexInArray;
    CDriverData *pNewDriverData;
    BOOL bSuccess;

    ASSERT( IsDriverNameInList( szDriverName ) == FALSE );

    nIndexInArray = -1;

    pNewDriverData = new CDriverData( szDriverName );
    
    if( NULL != pNewDriverData )
    {
        bSuccess = pNewDriverData->LoadDriverImageData();

        if( FALSE != bForceIfFileNotFound || FALSE != bSuccess )
        {
            TRY
            {
                nIndexInArray = m_aDriverData.Add( pNewDriverData );
            }
	        CATCH( CMemoryException, pMemException )
	        {
		        VrfErrorResourceFormat( IDS_NOT_ENOUGH_MEMORY );
                nIndexInArray = -1;

                //
                // Clean-up the allocation since we cannot add it to our list
                //

                delete pNewDriverData;
            }
            END_CATCH
        }
        else
        {
            //
            // Could not load driver version, OS version etc.
            // Bad luck, we will not show this driver anyway in the lists, etc.
            //

            delete pNewDriverData;
        }

    }

    return nIndexInArray;
}

//////////////////////////////////////////////////////////////////////
//
// Is this driver name already in our list?
//

BOOL CDriversSet::IsDriverNameInList( LPCTSTR szDriverName )
{
    INT_PTR nDrivers;
    INT_PTR nCrtDriver;
    CDriverData *pCrtDriverData;
    BOOL bIsInList;

    bIsInList = FALSE;

    nDrivers = m_aDriverData.GetSize();

    for( nCrtDriver = 0; nCrtDriver < nDrivers; nCrtDriver += 1 )
    {
        pCrtDriverData = m_aDriverData.GetAt( nCrtDriver );

        ASSERT_VALID( pCrtDriverData );

        if( pCrtDriverData->m_strName.CompareNoCase( szDriverName ) == 0 )
        {
            bIsInList = TRUE;

            break;
        }
    }

    return bIsInList;
}

//////////////////////////////////////////////////////////////////////
//
// Operators
//

CDriversSet & CDriversSet::operator = (const CDriversSet &DriversSet)
{
    m_DriverSetType                     = DriversSet.m_DriverSetType;
    m_aDriverData                       = DriversSet.m_aDriverData;
    m_bDriverDataInitialized            = DriversSet.m_bDriverDataInitialized;
    m_bUnsignedDriverDataInitialized    = DriversSet.m_bUnsignedDriverDataInitialized;

    ::CopyStringArray(
        DriversSet.m_astrNotInstalledDriversToVerify,
        m_astrNotInstalledDriversToVerify );

    //
    // All done - assert that our data is consistent
    //

    ASSERT_VALID( this );

    return *this;
}

//////////////////////////////////////////////////////////////////////
//
// Overrides
//

void CDriversSet::AssertValid() const
{
    ASSERT( DriversSetCustom    == m_DriverSetType ||
            DriversSetOldOs     == m_DriverSetType ||
            DriversSetNotSigned == m_DriverSetType ||
            DriversSetAllDrivers== m_DriverSetType );

    ASSERT( TRUE    == m_bDriverDataInitialized ||
            FALSE   == m_bDriverDataInitialized );

    ASSERT( TRUE    == m_bUnsignedDriverDataInitialized ||
            FALSE   == m_bUnsignedDriverDataInitialized );

    m_aDriverData.AssertValid();
    m_astrNotInstalledDriversToVerify.AssertValid();

    CObject::AssertValid();
}


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
// CSettingsBits Class
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSettingsBits::CSettingsBits()
{
    m_SettingsType = SettingsTypeTypical;
}

CSettingsBits::~CSettingsBits()
{

}

//////////////////////////////////////////////////////////////////////
//
// Operators
//

CSettingsBits & CSettingsBits::operator = (const CSettingsBits &SettingsBits)
{
    m_SettingsType          = SettingsBits.m_SettingsType;

    m_bSpecialPoolEnabled   = SettingsBits.m_bSpecialPoolEnabled;
    m_bForceIrqlEnabled     = SettingsBits.m_bForceIrqlEnabled;
    m_bLowResEnabled        = SettingsBits.m_bLowResEnabled;
    m_bPoolTrackingEnabled  = SettingsBits.m_bPoolTrackingEnabled;
    m_bIoEnabled            = SettingsBits.m_bIoEnabled;
    m_bDeadlockDetectEnabled= SettingsBits.m_bDeadlockDetectEnabled;
    m_bDMAVerifEnabled      = SettingsBits.m_bDMAVerifEnabled;
    m_bEnhIoEnabled         = SettingsBits.m_bEnhIoEnabled;

    //
    // All done, assert that our data is consistent
    //

    ASSERT_VALID( this );

    return *this;
}

//////////////////////////////////////////////////////////////////////
//
// Overrides
//

void CSettingsBits::AssertValid() const
{
    CObject::AssertValid();
}

//////////////////////////////////////////////////////////////////////
VOID CSettingsBits::SetTypicalOnly()
{
    m_SettingsType = SettingsTypeTypical;

    m_bSpecialPoolEnabled   = TRUE;
    m_bForceIrqlEnabled     = TRUE;
    m_bPoolTrackingEnabled  = TRUE;
    m_bIoEnabled            = TRUE;
    m_bDeadlockDetectEnabled= TRUE;
    m_bDMAVerifEnabled      = TRUE;
    
    //
    // Low resource simulation
    //

    m_bLowResEnabled        = FALSE;

    //
    // Extreme or spurious tests
    //

    m_bEnhIoEnabled         = FALSE;
}

//////////////////////////////////////////////////////////////////////
VOID CSettingsBits::EnableTypicalTests( BOOL bEnable )
{
    ASSERT( SettingsTypeTypical == m_SettingsType ||
            SettingsTypeCustom  == m_SettingsType );

    m_bSpecialPoolEnabled   = ( FALSE != bEnable );
    m_bForceIrqlEnabled     = ( FALSE != bEnable );
    m_bPoolTrackingEnabled  = ( FALSE != bEnable );
    m_bIoEnabled            = ( FALSE != bEnable );
    m_bDeadlockDetectEnabled= ( FALSE != bEnable );
    m_bDMAVerifEnabled      = ( FALSE != bEnable );
}

//////////////////////////////////////////////////////////////////////
VOID CSettingsBits::EnableExcessiveTests( BOOL bEnable )
{
    m_bEnhIoEnabled         = ( FALSE != bEnable );
}

//////////////////////////////////////////////////////////////////////
VOID CSettingsBits::EnableLowResTests( BOOL bEnable )
{
    m_bLowResEnabled        = ( FALSE != bEnable );
}

//////////////////////////////////////////////////////////////////////
BOOL CSettingsBits::GetVerifierFlags( DWORD &dwVerifyFlags )
{
    dwVerifyFlags = 0;

    if( FALSE != m_bSpecialPoolEnabled )
    {
        dwVerifyFlags |= DRIVER_VERIFIER_SPECIAL_POOLING;
    }

    if( FALSE != m_bForceIrqlEnabled )
    {
        dwVerifyFlags |= DRIVER_VERIFIER_FORCE_IRQL_CHECKING;
    }

    if( FALSE != m_bLowResEnabled )
    {
        dwVerifyFlags |= DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES;
    }

    if( FALSE != m_bPoolTrackingEnabled )
    {
        dwVerifyFlags |= DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS;
    }

    if( FALSE != m_bIoEnabled )
    {
        dwVerifyFlags |= DRIVER_VERIFIER_IO_CHECKING;
    }

    if( FALSE != m_bDeadlockDetectEnabled )
    {
        dwVerifyFlags |= DRIVER_VERIFIER_DEADLOCK_DETECTION;
    }

    if( FALSE != m_bDMAVerifEnabled )
    {
        dwVerifyFlags |= DRIVER_VERIFIER_DMA_VERIFIER;
    }

    if( FALSE != m_bEnhIoEnabled )
    {
        dwVerifyFlags |= DRIVER_VERIFIER_ENHANCED_IO_CHECKING;
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
// CVerifierSettings Class
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CVerifierSettings::CVerifierSettings()
{
}

CVerifierSettings::~CVerifierSettings()
{
}

//////////////////////////////////////////////////////////////////////
CVerifierSettings &CVerifierSettings::operator = (const CVerifierSettings &VerifSettings)
{
    m_SettingsBits = VerifSettings.m_SettingsBits;
    m_DriversSet   = VerifSettings.m_DriversSet;

    //
    // All done - assert that our data is consistent
    //

    ASSERT_VALID( this );

    return *this;
}

//////////////////////////////////////////////////////////////////////
BOOL CVerifierSettings::SaveToRegistry()
{
    DWORD dwVerifyFlags;
    DWORD dwPrevFlags;
    BOOL bSuccess;
    CString strDriversToVerify;
    CString strPrevVerifiedDrivers;

    dwVerifyFlags = 0;

    //
    // Get the list of drivers to verify 
    //

    bSuccess = m_DriversSet.GetDriversToVerify( strDriversToVerify ) &&
               m_SettingsBits.GetVerifierFlags( dwVerifyFlags );
    
    if( bSuccess )
    {
        //
        // Have something to write to the registry
        //

        //
        // Try to get the old settings
        //

        dwPrevFlags = 0;

        VrfReadVerifierSettings( strPrevVerifiedDrivers,
                                 dwPrevFlags );

        if( strDriversToVerify.CompareNoCase( strPrevVerifiedDrivers ) != 0 ||
            dwVerifyFlags != dwPrevFlags )
        {
            VrfWriteVerifierSettings( TRUE,
                                     strDriversToVerify,
                                     TRUE,
                                     dwVerifyFlags );
        }
        else
        {
            VrfMesssageFromResource( IDS_NO_SETTINGS_WERE_CHANGED );
        }
    }
    
    return bSuccess;
}

//////////////////////////////////////////////////////////////////////
//
// Overrides
//

void CVerifierSettings::AssertValid() const
{
    m_SettingsBits.AssertValid();
    m_DriversSet.AssertValid();

    CObject::AssertValid();
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//
// Runtime data - queried from the kernel
//
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
//
// class CRuntimeDriverData
//

CRuntimeDriverData::CRuntimeDriverData()
{
    Loads = 0;
    Unloads = 0;

    CurrentPagedPoolAllocations = 0;
    CurrentNonPagedPoolAllocations = 0;
    PeakPagedPoolAllocations = 0;
    PeakNonPagedPoolAllocations = 0;

    PagedPoolUsageInBytes = 0;
    NonPagedPoolUsageInBytes = 0;
    PeakPagedPoolUsageInBytes = 0;
    PeakNonPagedPoolUsageInBytes = 0;
}

//////////////////////////////////////////////////////////////////////
//
// class CRuntimeDriverDataArray
//

CRuntimeDriverDataArray::~CRuntimeDriverDataArray()
{
    DeleteAll();
}

//////////////////////////////////////////////////////////////////////
CRuntimeDriverData *CRuntimeDriverDataArray::GetAt( INT_PTR nIndex )
{
    CRuntimeDriverData *pRetVal = (CRuntimeDriverData *)CObArray::GetAt( nIndex );

    ASSERT_VALID( pRetVal );

    return pRetVal;
}

//////////////////////////////////////////////////////////////////////
VOID CRuntimeDriverDataArray::DeleteAll()
{
    INT_PTR nArraySize;
    CRuntimeDriverData *pCrtDriverData;

    nArraySize = GetSize();

    while( nArraySize > 0 )
    {
        nArraySize -= 1;

        pCrtDriverData = GetAt( nArraySize );

        ASSERT_VALID( pCrtDriverData );

        delete pCrtDriverData;
    }

    RemoveAll();
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//
// class CRuntimeVerifierData
//

CRuntimeVerifierData::CRuntimeVerifierData()
{
    FillWithDefaults();
}

//////////////////////////////////////////////////////////////////////
VOID CRuntimeVerifierData::FillWithDefaults()
{
    m_bSpecialPool      = FALSE;
    m_bPoolTracking     = FALSE;
    m_bForceIrql        = FALSE;
    m_bIo               = FALSE;
    m_bEnhIo            = FALSE;
    m_bDeadlockDetect   = FALSE;
    m_bDMAVerif         = FALSE;
    m_bLowRes           = FALSE;

    RaiseIrqls                      = 0;
    AcquireSpinLocks                = 0;
    SynchronizeExecutions           = 0;
    AllocationsAttempted            = 0;

    AllocationsSucceeded            = 0;
    AllocationsSucceededSpecialPool = 0;
    AllocationsWithNoTag;

    Trims                           = 0;
    AllocationsFailed               = 0;
    AllocationsFailedDeliberately   = 0;

    UnTrackedPool                   = 0;

    Level = 0;

    m_RuntimeDriverDataArray.DeleteAll();
}

//////////////////////////////////////////////////////////////////////
BOOL CRuntimeVerifierData::IsDriverVerified( LPCTSTR szDriveName )
{
    CRuntimeDriverData *pCrtDriverData;
    INT_PTR nDrivers;
    BOOL bFound;

    bFound = FALSE;

    nDrivers = m_RuntimeDriverDataArray.GetSize();

    while( nDrivers > 0 )
    {
        nDrivers -= 1;

        pCrtDriverData = m_RuntimeDriverDataArray.GetAt( nDrivers );

        ASSERT_VALID( pCrtDriverData );

        if( 0 == pCrtDriverData->m_strName.CompareNoCase( szDriveName ) )
        {
            bFound = TRUE;
            break;
        }
    }

    return bFound;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\vsheet.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: VSheet.h
// author: DMihai
// created: 11/1/00
//
// Description:
//  

#if !defined(AFX_VSHEET_H__74939F02_3402_4E14_8B25_6B791960958B__INCLUDED_)
#define AFX_VSHEET_H__74939F02_3402_4E14_8B25_6B791960958B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "vsetting.h"
#include "taspage.h"
#include "dsetpage.h"
#include "csetpage.h"
#include "CDLPage.h"
#include "SDrvPage.h"
#include "FLPage.h"
#include "DStsPage.h"
#include "RegPage.h"
#include "GCntPage.h"
#include "DCntPage.h"

/////////////////////////////////////////////////////////////////////////////
// CVerifierPropSheet dialog

class CVerifierPropSheet : public CPropertySheet
{
// Construction
public:
	CVerifierPropSheet();	

protected:
	HICON m_hIcon;

	//
	// Typical Settings/Advanced Settings/Statistics page
	//

    CTypAdvStatPage     m_TypAdvStatPage;

    //
    // Driver Set page
    //

    CDriverSetPage      m_DriverSetPage;

    //
    // Custom Settings page
    //

    CCustSettPage       m_CustSettPage;

    //
    // Confirm the list of verified drivers page
    //

    CConfirmDriverListPage m_ConfDriversListPage;

    //
    // Select custom set of drivers page
    //

    CSelectDriversPage  m_SelectDriversPage;

    //
    // Full list of settings page
    //

    CFullListSettingsPage m_FullListSettingsPage;

    //
    // Driver Status page
    //

    CDriverStatusPage m_DriverStatusPage;

    //
    // Current registry settings page
    //

    CCrtRegSettingsPage m_CrtRegSettingsPage;

    //
    // Global counters page
    //

    CGlobalCountPage m_GlobalCountPage;

    //
    // Per-driver counters page
    //

    CDriverCountersPage m_DriverCountersPage;

	//
	// Dialog Data
	//

	//{{AFX_DATA(CVerifierPropSheet)
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

public:

    BOOL SetContextStrings( ULONG uTitleResId );

    VOID HideHelpButton();

protected:
    //
    // Methods
    //


    //
    // ClassWizard generated virtual function overrides
    //

    //{{AFX_VIRTUAL(CVerifierPropSheet)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
    virtual BOOL OnInitDialog();
    //}}AFX_VIRTUAL

    //
    // Generated message map functions
    //

    //{{AFX_MSG(CVerifierPropSheet)
    afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
    afx_msg void OnPaint();
    afx_msg HCURSOR OnQueryDragIcon();
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_VSHEET_H__74939F02_3402_4E14_8B25_6B791960958B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\vrfutil.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: VrfUtil.h
// author: DMihai
// created: 11/1/00
//
// Description:
//

#ifndef __VRF_UTIL_H_INCLUDED__
#define __VRF_UTIL_H_INCLUDED__

//
// ARRAY_LENGTH macro
//

#ifndef ARRAY_LENGTH
#define ARRAY_LENGTH( array )   ( sizeof( array ) / sizeof( array[ 0 ] ) )
#endif //#ifndef ARRAY_LENGTH

//
// Forward declarations
//

class CRuntimeVerifierData;

///////////////////////////////////////////////////////////////////////////
//
// Report an error using a dialog box or a console message.
// The message format string is loaded from the resources.
//

void __cdecl VrfErrorResourceFormat( UINT uIdResourceFormat,
                                     ... );

///////////////////////////////////////////////////////////////////////////
//
// Print out a message to the console
// The message string is loaded from the resources.
//

void __cdecl VrfTPrintfResourceFormat( UINT uIdResourceFormat,
                                       ... );

///////////////////////////////////////////////////////////////////////////
//
// Print out a simple (non-formatted) message to the console
// The message string is loaded from the resources.
//

void __cdecl VrfPrintStringFromResources( UINT uIdString );

///////////////////////////////////////////////////////////////////////////
//
// Report an error using a dialog box or a console message.
// The message string is loaded from the resources.
//

void __cdecl VrfMesssageFromResource( UINT uIdString );


///////////////////////////////////////////////////////////////////////////
//
// Load a string from resources.
// Return TRUE if we successfully loaded and FALSE if not.
//
// N.B. CString::LoadString doesn't work in cmd line mode
//

BOOL VrfLoadString( ULONG uIdResource,
                    TCHAR *szBuffer,
                    ULONG uBufferLength );

///////////////////////////////////////////////////////////////////////////
//
// Load a string from resources.
// Return TRUE if we successfully loaded and FALSE if not.
//
// N.B. CString::LoadString doesn't work in cmd line mode
//

BOOL VrfLoadString( ULONG uIdResource,
                    CString &strText );

///////////////////////////////////////////////////////////////////////////
VOID CopyStringArray( const CStringArray &strArraySource,
                      CStringArray &strArrayDest );


/////////////////////////////////////////////////////////////////////////////
BOOL IsDriverSigned( LPCTSTR szDriverName );

/////////////////////////////////////////////////////////////////////////////
BOOL VrfSetWindowText( CWnd &Wnd,
                       ULONG uIdResourceString );

/////////////////////////////////////////////////////////////////////////////
BOOL VrfWriteVerifierSettings( BOOL bHaveNewDrivers,
                               const CString &strDriversToVerify,
                               BOOL bHaveNewFlags,
                               DWORD dwVerifyFlags );

/////////////////////////////////////////////////////////////////////////////
BOOL VrfWriteRegistryDwordValue( HKEY hKey,
                                 LPCTSTR szValueName,
                                 DWORD dwValue );

/////////////////////////////////////////////////////////////////////////////
BOOL VrfWriteRegistryStringValue( HKEY hKey,
                                  LPCTSTR szValueName,
                                  LPCTSTR szValue );

/////////////////////////////////////////////////////////////////////////////
BOOL VrfReadVerifierSettings( CString &strDriversToVerify,
                              DWORD &dwVerifyFlags );

/////////////////////////////////////////////////////////////////////////////
BOOL VrtLoadCurrentRegistrySettings( BOOL &bAllDriversVerified,
                                     CStringArray &astrDriversToVerify,
                                     DWORD &dwVerifyFlags );

/////////////////////////////////////////////////////////////////////////////
BOOL VrfIsDriversSetDifferent( CString strAllDrivers1, 
                               const CStringArray &astrVerifyDriverNames2 );

/////////////////////////////////////////////////////////////////////////////
VOID VrfSplitDriverNamesSpaceSeparated( CString strAllDrivers,
                                        CStringArray &astrVerifyDriverNames );

/////////////////////////////////////////////////////////////////////////////
BOOL VrfReadRegistryDwordValue( HKEY hKey,
                                LPCTSTR szValueName,
                                DWORD &dwValue );

/////////////////////////////////////////////////////////////////////////////
BOOL VrfReadRegistryStringValue( HKEY hKey,
                                 LPCTSTR szValueName,
                                 CString &strDriversToVerify );

/////////////////////////////////////////////////////////////////////////////
BOOL VrfDeleteAllVerifierSettings();

/////////////////////////////////////////////////////////////////////////////
BOOL VrfGetRuntimeVerifierData( CRuntimeVerifierData *pRuntimeVerifierData );

/////////////////////////////////////////////////////////////////////////////
PLOADED_IMAGE VrfImageLoad( LPTSTR szBinaryName,
                            LPTSTR szDirectory );

/////////////////////////////////////////////////////////////////////////////
BOOL VrfDumpStateToFile( FILE *file );
                         
/////////////////////////////////////////////////////////////////////////////
BOOL __cdecl VrfFTPrintf( FILE *file,
                          LPCTSTR szFormat,
                          ... );

/////////////////////////////////////////////////////////////////////////////
BOOL __cdecl VrfFTPrintfResourceFormat( FILE *file,
                                        UINT uIdResourceFormat,
                                        ... );

/////////////////////////////////////////////////////////////////////////////
BOOL VrfOuputStringFromResources( UINT uIdString,
                                  FILE *file );

/////////////////////////////////////////////////////////////////////////////
BOOL VrfSetNewFlagsVolatile( DWORD dwNewFlags );

/////////////////////////////////////////////////////////////////////////////
BOOL VrfAddDriversVolatile( const CStringArray &astrNewDrivers );

/////////////////////////////////////////////////////////////////////////////
BOOL VrfAddDriverVolatile( const CString &strCrtDriver );

/////////////////////////////////////////////////////////////////////////////
BOOL VrfRemoveDriversVolatile( const CStringArray &astrNewDrivers );

/////////////////////////////////////////////////////////////////////////////
BOOL VrfRemoveDriverVolatile( const CString &strDriverName );

/////////////////////////////////////////////////////////////////////////////
BOOL VrfEnableDebugPrivilege();

/////////////////////////////////////////////////////////////////////////////
VOID VrfDumpChangedSettings( UINT OldFlags,
                             UINT NewFlags,
                             INT_PTR nDriversVerified );

/////////////////////////////////////////////////////////////////////////////
DWORD VrfGetStandardFlags();

/////////////////////////////////////////////////////////////////////////////
VOID VrfAddMiniports( CStringArray &astrVerifiedDrivers );

/////////////////////////////////////////////////////////////////////////////
BOOL VrfIsDriverMiniport( CString &strCrtDriver,
                          CString &strLinkedDriver );

/////////////////////////////////////////////////////////////////////////////
BOOL VrfIsDriverMiniport( PLOADED_IMAGE pLoadedImage,
                          CString &strLinkedDriver );

/////////////////////////////////////////////////////////////////////////////
VOID VrfDumpRegistrySettingsToConsole();

/////////////////////////////////////////////////////////////////////////////
BOOL VrfIsNameAlreadyInList( LPCTSTR szDrive