/* 0x01695C */,
  0x01D02000l /* 0x016960 */,
  0x7A833BA0l /* 0x016964 */,
  0x3CD0E801l /* 0x016968 */,
  0x0B043F80l /* 0x01696C */,
  0x0600C06El /* 0x016970 */,
  0x28C0C600l /* 0x016974 */,
  0x9BE41E30l /* 0x016978 */,
  0xA6EC2010l /* 0x01697C */,
  0x1D3029C0l /* 0x016980 */,
  0x601AA6ECl /* 0x016984 */,
  0x201A93F8l /* 0x016988 */,
  0xA30796F8l /* 0x01698C */,
  0x40D018D0l /* 0x016990 */,
  0xA8004060l /* 0x016994 */,
  0x12D078D0l /* 0x016998 */,
  0xC0D76000l /* 0x01699C */,
  0x69C70500l /* 0x0169A0 */,
  0xA6E041B7l /* 0x0169A4 */,
  0x81B7A8C7l /* 0x0169A8 */,
  0x41B75BC7l /* 0x0169AC */,
  0x2800A6E0l /* 0x0169B0 */,
  0x4601D0DFl /* 0x0169B4 */,
  0x01D07000l /* 0x0169B8 */,
  0x3F8037A0l /* 0x0169BC */,
  0x00C0C600l /* 0x0169C0 */,
  0xA3E000C0l /* 0x0169C4 */,
  0x2870EB04l /* 0x0169C8 */,
  0xACE82010l /* 0x0169CC */,
  0xA8C769C7l /* 0x0169D0 */,
  0x02181DC8l /* 0x0169D4 */,
  0x02181D28l /* 0x0169D8 */,
  0xE9018602l /* 0x0169DC */,
  0x202510D5l /* 0x0169E0 */,
  0x96090602l /* 0x0169E4 */,
  0x14D0A307l /* 0x0169E8 */,
  0x20100070l /* 0x0169EC */,
  0x9605BCE8l /* 0x0169F0 */,
  0xA3079709l /* 0x0169F4 */,
  0x20100C70l /* 0x0169F8 */,
  0x9705C2E8l /* 0x0169FC */,
  0x97012EF3l /* 0x016A00 */,
  0x46F3D2F8l /* 0x016A04 */,
  0xD9C598C5l /* 0x016A08 */,
  0xDEE86017l /* 0x016A0C */,
  0x00D02400l /* 0x016A10 */,
  0x80251DC8l /* 0x016A14 */,
  0x01B8C025l /* 0x016A18 */,
  0xDEE0CDF8l /* 0x016A1C */,
  0x6017E5F2l /* 0x016A20 */,
  0x2400DEE8l /* 0x016A24 */,
  0x1DC800D0l /* 0x016A28 */,
  0x00264026l /* 0x016A2C */,
  0x8025C025l /* 0x016A30 */,
  0xD8F801B8l /* 0x016A34 */,
  0x2870EB04l /* 0x016A38 */,
  0xB5F92010l /* 0x016A3C */,
  0x9701EAE0l /* 0x016A40 */,
  0xEFF1E7F8l /* 0x016A44 */,
  0x6017EAE0l /* 0x016A48 */,
  0xE5F2EAF8l /* 0x016A4C */,
  0x970440D8l /* 0x016A50 */,
  0xC0D080D0l /* 0x016A54 */,
  0x40D100D1l /* 0x016A58 */,
  0x86A00585l /* 0x016A5C */,
  0x06A1C6A0l /* 0x016A60 */,
  0xC58146A1l /* 0x016A64 */,
  0x061B1DCBl /* 0x016A68 */,
  0x06AB1E5Bl /* 0x016A6C */,
  0x068C4582l /* 0x016A70 */,
  0x49063F80l /* 0x016A74 */,
  0xD780E4F1l /* 0x016A78 */,
  0x8D013F80l /* 0x016A7C */,
  0x0D02CD01l /* 0x016A80 */,
  0x8D024D02l /* 0x016A84 */,
  0x0D03CD02l /* 0x016A88 */,
  0x8D034D03l /* 0x016A8C */,
  0x0D04CD03l /* 0x016A90 */,
  0x8D044D04l /* 0x016A94 */,
  0x0D05CD04l /* 0x016A98 */,
  0x17804D05l /* 0x016A9C */,
  0x06844582l /* 0x016AA0 */,
  0x47E99E01l /* 0x016AA4 */,
  0x100002C8l /* 0x016AA8 */,
  0xAE211EF9l /* 0x016AAC */,
  0xAF23EE21l /* 0x016AB0 */,
  0x22E1EF23l /* 0x016AB4 */,
  0xF021B021l /* 0x016AB8 */,
  0xF123B123l /* 0x016ABC */,
  0x100003C8l /* 0x016AC0 */,
  0x2E222AF9l /* 0x016AC4 */,
  0x2F246E22l /* 0x016AC8 */,
  0x2EE16F24l /* 0x016ACC */,
  0x70223022l /* 0x016AD0 */,
  0x71243124l /* 0x016AD4 */,
  0x100004C8l /* 0x016AD8 */,
  0xAE2236F9l /* 0x016ADC */,
  0xAF24EE22l /* 0x016AE0 */,
  0x3AE1EF24l /* 0x016AE4 */,
  0xF022B022l /* 0x016AE8 */,
  0xF124B124l /* 0x016AEC */,
  0x100005C8l /* 0x016AF0 */,
  0x2E2342F9l /* 0x016AF4 */,
  0x2F256E23l /* 0x016AF8 */,
  0x46E16F25l /* 0x016AFC */,
  0x70233023l /* 0x016B00 */,
  0x71253125l /* 0x016B04 */,
  0xAE2157E1l /* 0x016B08 */,
  0x2E22EE21l /* 0x016B0C */,
  0xB0226E22l /* 0x016B10 */,
  0x3023F022l /* 0x016B14 */,
  0xAF237023l /* 0x016B18 */,
  0x2F24EF23l /* 0x016B1C */,
  0xB1246F24l /* 0x016B20 */,
  0x3125F124l /* 0x016B24 */,
  0x12F27125l /* 0x016B28 */,
  0x970141F2l /* 0x016B2C */,
  0x70F25EF9l /* 0x016B30 */,
  0x60E1A6F2l /* 0x016B34 */,
  0xB3F291F2l /* 0x016B38 */,
  0x1BC07FB7l /* 0x016B3C */,
  0xAEED1D30l /* 0x016B40 */,
  0xBFB740D7l /* 0x016B44 */,
  0xE9018602l /* 0x016B48 */,
  0x060210D5l /* 0x016B4C */,
  0xAEE99701l /* 0x016B50 */,
  0x99E99C01l /* 0x016B54 */,
  0xD303AEE1l /* 0x016B58 */,
  0x25D075E9l /* 0x016B5C */,
  0x75F91E30l /* 0x016B60 */,
  0x9EC18BD7l /* 0x016B64 */,
  0x7CE5AB17l /* 0x016B68 */,
  0x7CEDB417l /* 0x016B6C */,
  0x83F9D303l /* 0x016B70 */,
  0x24D0E704l /* 0x016B74 */,
  0x94D0E704l /* 0x016B78 */,
  0xCCD0E704l /* 0x016B7C */,
  0xAB170AF3l /* 0x016B80 */,
  0xB41791E5l /* 0x016B84 */,
  0xE7048FFDl /* 0x016B88 */,
  0xE70428D0l /* 0x016B8C */,
  0xE704A0D0l /* 0x016B90 */,
  0x0AF3DCD0l /* 0x016B94 */,
  0xD303AEE1l /* 0x016B98 */,
  0xE704AEE9l /* 0x016B9C */,
  0xE70428D0l /* 0x016BA0 */,
  0xE70498D0l /* 0x016BA4 */,
  0x0AF3D0D0l /* 0x016BA8 */,
  0x9EC1AEE1l /* 0x016BAC */,
  0x81B18111l /* 0x016BB0 */,
  0x94D0E704l /* 0x016BB4 */,
  0xCCD0E704l /* 0x016BB8 */,
  0xA6E99D01l /* 0x016BBC */,
  0x98D0E704l /* 0x016BC0 */,
  0xD0D0E704l /* 0x016BC4 */,
  0x24D0E704l /* 0x016BC8 */,
  0x9EC10AF3l /* 0x016BCC */,
  0xE7048111l /* 0x016BD0 */,
  0x0AF328D0l /* 0x016BD4 */,
  0x1E3028C0l /* 0x016BD8 */,
  0xB5E5E3ECl /* 0x016BDC */,
  0x1D3029C0l /* 0x016BE0 */,
  0xC582E3F4l /* 0x016BE4 */,
  0x1DCB0680l /* 0x016BE8 */,
  0x1E5B061Bl /* 0x016BEC */,
  0xBDE96017l /* 0x016BF0 */,
  0xA407EFF1l /* 0x016BF4 */,
  0x407008D0l /* 0x016BF8 */,
  0x40607FB0l /* 0x016BFC */,
  0xDEE59C37l /* 0x016C00 */,
  0x00D0EA04l /* 0x016C04 */,
  0x22100070l /* 0x016C08 */,
  0x4602D0F9l /* 0x016C0C */,
  0x06021AC8l /* 0x016C10 */,
  0x20D02300l /* 0x016C14 */,
  0xD4F92030l /* 0x016C18 */,
  0x24D06105l /* 0x016C1C */,
  0x406041D0l /* 0x016C20 */,
  0x18D0A307l /* 0x016C24 */,
  0x406040D0l /* 0x016C28 */,
  0x50D0A900l /* 0x016C2C */,
  0x600012D0l /* 0x016C30 */,
  0x0500C0D7l /* 0x016C34 */,
  0x78D0A800l /* 0x016C38 */,
  0x600012D0l /* 0x016C3C */,
  0x0500C0D7l /* 0x016C40 */,
  0x16003798l /* 0x016C44 */,
  0x4601E4E9l /* 0x016C48 */,
  0x00D02200l /* 0x016C4C */,
  0x3F8037A0l /* 0x016C50 */,
  0x8601C600l /* 0x016C54 */,
  0x6017C507l /* 0x016C58 */,
  0x2400F6E9l /* 0x016C5C */,
  0x802500D0l /* 0x016C60 */,
  0xC507C025l /* 0x016C64 */,
  0x0FEAA017l /* 0x016C68 */,
  0x09EA9C01l /* 0x016C6C */,
  0x00D0E402l /* 0x016C70 */,
  0x1EC80026l /* 0x016C74 */,
  0x06FA1000l /* 0x016C78 */,
  0x403620D0l /* 0x016C7C */,
  0x00D0E402l /* 0x016C80 */,
  0x0FE24026l /* 0x016C84 */,
  0x402620D0l /* 0x016C88 */,
  0xA8050FE2l /* 0x016C8C */,
  0x002600D0l /* 0x016C90 */,
  0x00D0E402l /* 0x016C94 */,
  0x98C54026l /* 0x016C98 */,
  0xC507D9C5l /* 0x016C9C */,
  0x00D8A000l /* 0x016CA0 */,
  0x17FA9C01l /* 0x016CA4 */,
  0x97001004l /* 0x016CA8 */,
  0xA0A02AEAl /* 0x016CAC */,
  0x0A083F80l /* 0x016CB0 */,
  0x12044676l /* 0x016CB4 */,
  0x47760A08l /* 0x016CB8 */,
  0x3F80E0A0l /* 0x016CBC */,
  0x14041208l /* 0x016CC0 */,
  0x48760A08l /* 0x016CC4 */,
  0x0A081204l /* 0x016CC8 */,
  0x13044976l /* 0x016CCC */,
  0x2EFA9200l /* 0x016CD0 */,
  0x40EA9600l /* 0x016CD4 */,
  0x3F8020A1l /* 0x016CD8 */,
  0x12081408l /* 0x016CDC */,
  0x4A760A08l /* 0x016CE0 */,
  0x0A081204l /* 0x016CE4 */,
  0x60A14B76l /* 0x016CE8 */,
  0x12083F80l /* 0x016CEC */,
  0x0A081404l /* 0x016CF0 */,
  0x12044C76l /* 0x016CF4 */,
  0x4D760A08l /* 0x016CF8 */,
  0xA000C507l /* 0x016CFC */,
  0x9C0120D8l /* 0x016D00 */,
  0x100446FAl /* 0x016D04 */,
  0x59EA9700l /* 0x016D08 */,
  0x3F80A0A0l /* 0x016D0C */,
  0x4E760A08l /* 0x016D10 */,
  0x0A081204l /* 0x016D14 */,
  0xE0A04F76l /* 0x016D18 */,
  0x14043F80l /* 0x016D1C */,
  0x0A081208l /* 0x016D20 */,
  0x12045076l /* 0x016D24 */,
  0x51760A08l /* 0x016D28 */,
  0x92001304l /* 0x016D2C */,
  0x96005DFAl /* 0x016D30 */,
  0x20A16FEAl /* 0x016D34 */,
  0x14083F80l /* 0x016D38 */,
  0x0A081208l /* 0x016D3C */,
  0x12045276l /* 0x016D40 */,
  0x53760A08l /* 0x016D44 */,
  0x3F8060A1l /* 0x016D48 */,
  0x12081404l /* 0x016D4C */,
  0x54760A08l /* 0x016D50 */,
  0x0A081204l /* 0x016D54 */,
  0xC5075576l /* 0x016D58 */,
  0x1CD8A300l /* 0x016D5C */,
  0x03DE7D07l /* 0x016D60 */,
  0x9C0140C0l /* 0x016D64 */,
  0x04D07AFAl /* 0x016D68 */,
  0x10044050l /* 0x016D6C */,
  0x3F805AA0l /* 0x016D70 */,
  0x56660A08l /* 0x016D74 */,
  0x85EA9C01l /* 0x016D78 */,
  0xFFDFFE0Fl /* 0x016D7C */,
  0x20D04040l /* 0x016D80 */,
  0xFF0F8AE2l /* 0x016D84 */,
  0x4040FFDDl /* 0x016D88 */,
  0x00D0E402l /* 0x016D8C */,
  0x5AA08025l /* 0x016D90 */,
  0x0A083F80l /* 0x016D94 */,
  0x80355666l /* 0x016D98 */,
  0xA300C507l /* 0x016D9C */,
  0x7D071DD8l /* 0x016DA0 */,
  0x40C007DEl /* 0x016DA4 */,
  0x3F805AA0l /* 0x016DA8 */,
  0x59660A08l /* 0x016DAC */,
  0xFFDDFF0Fl /* 0x016DB0 */,
  0x5AA04040l /* 0x016DB4 */,
  0x0A083F80l /* 0x016DB8 */,
  0x60005766l /* 0x016DBC */,
  0x402600D0l /* 0x016DC0 */,
  0xC507C025l /* 0x016DC4 */,
  0x1CD8A300l /* 0x016DC8 */,
  0xABFA9C01l /* 0x016DCC */,
  0x7D071004l /* 0x016DD0 */,
  0x40C00BDEl /* 0x016DD4 */,
  0x3F805AA0l /* 0x016DD8 */,
  0x57660A08l /* 0x016DDC */,
  0xA300C507l /* 0x016DE0 */,
  0x7D030DD8l /* 0x016DE4 */,
  0x40C00FDEl /* 0x016DE8 */,
  0x3F805AA0l /* 0x016DEC */,
  0x58660A08l /* 0x016DF0 */,
  0xFFDDFF0Fl /* 0x016DF4 */,
  0x5AA04040l /* 0x016DF8 */,
  0x0A083F80l /* 0x016DFC */,
  0x24005666l /* 0x016E00 */,
  0x002600D0l /* 0x016E04 */,
  0xC5078025l /* 0x016E08 */,
  0x04D0E704l /* 0x016E0C */,
  0x60104070l /* 0x016E10 */,
  0x01C8C8EAl /* 0x016E14 */,
  0x20783CB8l /* 0x016E18 */,
  0x3F48EF0Fl /* 0x016E1C */,
  0xAC04D7EAl /* 0x016E20 */,
  0x00681028l /* 0x016E24 */,
  0x0068DAE2l /* 0x016E28 */,
  0x00683CB0l /* 0x016E2C */,
  0x0178C507l /* 0x016E30 */,
  0x00D0E402l /* 0x016E34 */,
  0xE3FA1000l /* 0x016E38 */,
  0x403060D0l /* 0x016E3C */,
  0x100801C0l /* 0x016E40 */,
  0xCB17C507l /* 0x016E44 */,
  0xF2E25F57l /* 0x016E48 */,
  0x5F57CB17l /* 0x016E4C */,
  0x00DFFF07l /* 0x016E50 */,
  0x40C600C6l /* 0x016E54 */,
  0x80C5C0C5l /* 0x016E58 */,
  0xFCFAD303l /* 0x016E5C */,
  0xE704C8F2l /* 0x016E60 */,
  0x406024D0l /* 0x016E64 */,
  0x20C6DBF2l /* 0x016E68 */,
  0x403660C6l /* 0x016E6C */,
  0x04FB9201l /* 0x016E70 */,
  0xE704C8F2l /* 0x016E74 */,
  0x406028D0l /* 0x016E78 */,
  0xA0C5DBF2l /* 0x016E7C */,
  0xC035E0C5l /* 0x016E80 */,
  0x2300DDC7l /* 0x016E84 */,
  0xD5177F47l /* 0x016E88 */,
  0xC507E017l /* 0x016E8C */,
  0x407006C8l /* 0x016E90 */,
  0x3CB001C0l /* 0x016E94 */,
  0x08180818l /* 0x016E98 */,
  0x02700068l /* 0x016E9C */,
  0x26FB2010l /* 0x016EA0 */,
  0x20D0E704l /* 0x016EA4 */,
  0x1AEB0230l /* 0x016EA8 */,
  0x1DFBA111l /* 0x016EAC */,
  0x42604360l /* 0x016EB0 */,
  0xE7042DE3l /* 0x016EB4 */,
  0x807004D0l /* 0x016EB8 */,
  0x7CB04060l /* 0x016EBC */,
  0x9030AC04l /* 0x016EC0 */,
  0xC5078160l /* 0x016EC4 */,
  0x3CB04260l /* 0x016EC8 */,
  0xAC048070l /* 0x016ECC */,
  0x42205030l /* 0x016ED0 */,
  0xC5074060l /* 0x016ED4 */,
  0x18702707l /* 0x016ED8 */,
  0x40D02605l /* 0x016EDC */,
  0xEECB817Bl /* 0x016EE0 */,
  0x2605C02Bl /* 0x016EE4 */,
  0x017C44D0l /* 0x016EE8 */,
  0x402C70CCl /* 0x016EEC */,
  0x50D02605l /* 0x016EF0 */,
  0x58C60176l /* 0x016EF4 */,
  0x40702E00l /* 0x016EF8 */,
  0x44FB5830l /* 0x016EFC */,
  0x20702707l /* 0x016F00 */,
  0xC5074026l /* 0x016F04 */,
  0x4AEB9D01l /* 0x016F08 */,
  0x7CB63CB6l /* 0x016F0C */,
  0x65FFA017l /* 0x016F10 */,
  0x5CEB9C01l /* 0x016F14 */,
  0x10001EC8l /* 0x016F18 */,
  0x20D053EBl /* 0x016F1C */,
  0xE4024026l /* 0x016F20 */,
  0x002600D0l /* 0x016F24 */,
  0x59FB1000l /* 0x016F28 */,
  0x01B84026l /* 0x016F2C */,
  0x65E355FBl /* 0x016F30 */,
  0xA8051EC8l /* 0x016F34 */,
  0xE40200D0l /* 0x016F38 */,
  0x002640D0l /* 0x016F3C */,
  0x01B84126l /* 0x016F40 */,
  0xC50761FBl /* 0x016F44 */,
  0x6B05C1F1l /* 0x016F48 */,
  0x807A00D0l /* 0x016F4C */,
  0x6F0540F1l /* 0x016F50 */,
  0x23005070l /* 0x016F54 */,
  0x21F87F30l /* 0x016F58 */,
  0x94706A05l /* 0x016F5C */,
  0x63906280l /* 0x016F60 */,
  0x21EC4230l /* 0x016F64 */,
  0x6390E281l /* 0x016F68 */,
  0x21EC6010l /* 0x016F6C */,
  0x21E85103l /* 0x016F70 */,
  0x510B4601l /* 0x016F74 */,
  0x290540D0l /* 0x016F78 */,
  0x26055860l /* 0x016F7C */,
  0x18083C78l /* 0x016F80 */,
  0x3C682605l /* 0x016F84 */,
  0x35F1C600l /* 0x016F88 */,
  0x2DE8A01Al /* 0x016F8C */,
  0xC0DCA400l /* 0x016F90 */,
  0x80DC6000l /* 0x016F94 */,
  0x12D02000l /* 0x016F98 */,
  0x48D0A700l /* 0x016F9C */,
  0x25000500l /* 0x016FA0 */,
  0x3F3000D0l /* 0x016FA4 */,
  0x250036E8l /* 0x016FA8 */,
  0x3F3011D0l /* 0x016FAC */,
  0x57F136E8l /* 0x016FB0 */,
  0x10D06D05l /* 0x016FB4 */,
  0xC3C0C070l /* 0x016FB8 */,
  0xC06093F1l /* 0x016FBC */,
  0x78D06C05l /* 0x016FC0 */,
  0xDD118170l /* 0x016FC4 */,
  0x81608720l /* 0x016FC8 */,
  0x10D06F05l /* 0x016FCC */,
  0x20100070l /* 0x016FD0 */,
  0xE40007F9l /* 0x016FD4 */,
  0xE378E8D8l /* 0x016FD8 */,
  0x57E89801l /* 0x016FDC */,
  0xA4D02B00l /* 0x016FE0 */,
  0x7FC08270l /* 0x016FE4 */,
  0x0600EBC0l /* 0x016FE8 */,
  0x6EDE3100l /* 0x016FEC */,
  0x3FB00210l /* 0x016FF0 */,
  0x7FC8CC03l /* 0x016FF4 */,
  0xE506C0DFl /* 0x016FF8 */,
  0x00782CD0l /* 0x016FFC */,
  0x00681304l /* 0x017000 */,
  0x1CD02C00l /* 0x017004 */,
  0x7FB04070l /* 0x017008 */,
  0x0FD04060l /* 0x01700C */,
  0x404041B0l /* 0x017010 */,
  0xE6004210l /* 0x017014 */,
  0x012000D0l /* 0x017018 */,
  0x25004068l /* 0x01701C */,
  0x213011D0l /* 0x017020 */,
  0xA1C8BFE8l /* 0x017024 */,
  0x00D0EC0Fl /* 0x017028 */,
  0x75E82140l /* 0x01702C */,
  0x62C09C18l /* 0x017030 */,
  0xFFE450B0l /* 0x017034 */,
  0x00D06200l /* 0x017038 */,
  0x62004020l /* 0x01703C */,
  0x01300BD0l /* 0x017040 */,
  0x4500FFFCl /* 0x017044 */,
  0x94E08BE0l /* 0x017048 */,
  0x9DE094E0l /* 0x01704C */,
  0xA9E0A3E0l /* 0x017050 */,
  0xAAE0A9E0l /* 0x017054 */,
  0xABE0FFE0l /* 0x017058 */,
  0x2000B7E0l /* 0x01705C */,
  0x2B3000D0l /* 0x017060 */,
  0x220021E9l /* 0x017064 */,
  0x2B3038D0l /* 0x017068 */,
  0xCDE021E9l /* 0x01706C */,
  0x00D02000l /* 0x017070 */,
  0x21E92B30l /* 0x017074 */,
  0x38D02200l /* 0x017078 */,
  0x21E92B30l /* 0x01707C */,
  0xAB05D0E0l /* 0x017080 */,
  0x00782CD0l /* 0x017084 */,
  0x11081204l /* 0x017088 */,
  0xA2050068l /* 0x01708C */,
  0x207820D8l /* 0x017090 */,
  0xD6F81000l /* 0x017094 */,
  0xFFE0D3E0l /* 0x017098 */,
  0x2200DCE0l /* 0x01709C */,
  0x2C303ED0l /* 0x0170A0 */,
  0xE01AB1E8l /* 0x0170A4 */,
  0xA800FAF8l /* 0x0170A8 */,
  0x12D040D0l /* 0x0170AC */,
  0xDFD76900l /* 0x0170B0 */,
  0xE11A0500l /* 0x0170B4 */,
  0xAC00FAF8l /* 0x0170B8 */,
  0x12D078D0l /* 0x0170BC */,
  0xC0D76000l /* 0x0170C0 */,
  0x2BC00500l /* 0x0170C4 */,
  0x30302200l /* 0x0170C8 */,
  0xC7E82310l /* 0x0170CC */,
  0xCAE82810l /* 0x0170D0 */,
  0x6000FAE0l /* 0x0170D4 */,
  0xDFE008DAl /* 0x0170D8 */,
  0x00DA6000l /* 0x0170DC */,
  0x6100E8E0l /* 0x0170E0 */,
  0xDFE02FDAl /* 0x0170E4 */,
  0x05DA6300l /* 0x0170E8 */,
  0x6100DFE0l /* 0x0170EC */,
  0xE8E013DAl /* 0x0170F0 */,
  0x1ADA6100l /* 0x0170F4 */,
  0x6600E8E0l /* 0x0170F8 */,
  0xF1E021DAl /* 0x0170FC */,
  0x07DA6400l /* 0x017100 */,
  0xD2D7F1E0l /* 0x017104 */,
  0x40D0A800l /* 0x017108 */,
  0xA800C407l /* 0x01710C */,
  0x12D048D0l /* 0x017110 */,
  0x0500E8C7l /* 0x017114 */,
  0xA800D2D7l /* 0x017118 */,
  0xC40740D0l /* 0x01711C */,
  0x50D0A800l /* 0x017120 */,
  0xE8C712D0l /* 0x017124 */,
  0xD2D70500l /* 0x017128 */,
  0x40D0A800l /* 0x01712C */,
  0xA800C407l /* 0x017130 */,
  0x12D058D0l /* 0x017134 */,
  0x0500E8C7l /* 0x017138 */,
  0x0CD0AC05l /* 0x01713C */,
  0x63104070l /* 0x017140 */,
  0x220007E9l /* 0x017144 */,
  0x60107470l /* 0x017148 */,
  0x260507E5l /* 0x01714C */,
  0x40D024D0l /* 0x017150 */,
  0xC0DF4060l /* 0x017154 */,
  0x21E9E01Al /* 0x017158 */,
  0x38D02200l /* 0x01715C */,
  0x21E92B30l /* 0x017160 */,
  0x33D02200l /* 0x017164 */,
  0x21E92B30l /* 0x017168 */,
  0x60706505l /* 0x01716C */,
  0x1BF96010l /* 0x017170 */,
  0x10D06F05l /* 0x017174 */,
  0x7FD02300l /* 0x017178 */,
  0xA7004060l /* 0x01717C */,
  0x12D058D0l /* 0x017180 */,
  0xC5D76000l /* 0x017184 */,
  0x6F050500l /* 0x017188 */,
  0x40D010D0l /* 0x01718C */,
  0x62004060l /* 0x017190 */,
  0x6B0557DAl /* 0x017194 */,
  0x406A14D0l /* 0x017198 */,
  0x21004601l /* 0x01719C */,
  0x38A000D0l /* 0x0171A0 */,
  0xA800C600l /* 0x0171A4 */,
  0x12D040D0l /* 0x0171A8 */,
  0xDFD76900l /* 0x0171AC */,
  0x46010500l /* 0x0171B0 */,
  0x63906280l /* 0x0171B4 */,
  0xC6003F80l /* 0x0171B8 */,
  0x14D06A05l /* 0x0171BC */,
  0x01300070l /* 0x0171C0 */,
  0xC50712EDl /* 0x0171C4 */,
  0xA2814601l /* 0x0171C8 */,
  0x3F806390l /* 0x0171CC */,
  0x6A05C600l /* 0x0171D0 */,
  0x007030D0l /* 0x0171D4 */,
  0x01300310l /* 0x0171D8 */,
  0x460151E5l /* 0x0171DC */,
  0x00D02100l /* 0x0171E0 */,
  0xC60038A0l /* 0x0171E4 */,
  0x4601C507l /* 0x0171E8 */,
  0x01D02100l /* 0x0171EC */,
  0xC60038A0l /* 0x0171F0 */,
  0x6B05C507l /* 0x0171F4 */,
  0x097248D2l /* 0x0171F8 */,
  0x62804601l /* 0x0171FC */,
  0x23903F80l /* 0x017200 */,
  0xC6003F80l /* 0x017204 */,
  0x12E52110l /* 0x017208 */,
  0x0CD06B05l /* 0x01720C */,
  0x60104070l /* 0x017210 */,
  0x87D271F9l /* 0x017214 */,
  0xA0420D98l /* 0x017218 */,
  0x28D871E9l /* 0x01721C */,
  0x08080A38l /* 0x017220 */,
  0x41D08D02l /* 0x017224 */,
  0x46014060l /* 0x017228 */,
  0x3F806280l /* 0x01722C */,
  0x3F802390l /* 0x017230 */,
  0x2110C600l /* 0x017234 */,
  0x090A12E5l /* 0x017238 */,
  0x3FB28D02l /* 0x01723C */,
  0xA0120962l /* 0x017240 */,
  0x48C071E9l /* 0x017244 */,
  0x096200D2l /* 0x017248 */,
  0x85ED6210l /* 0x01724C */,
  0xA11271E1l /* 0x017250 */,
  0x40D071F9l /* 0x017254 */,
  0x0CD06B05l /* 0x017258 */,
  0x090A4060l /* 0x01725C */,
  0x3F803684l /* 0x017260 */,
  0x2BCBF4AAl /* 0x017264 */,
  0xF4AACD0Al /* 0x017268 */,
  0x6800C507l /* 0x01726C */,
  0x619100D1l /* 0x017270 */,
  0x95F94441l /* 0x017274 */,
  0x23912283l /* 0x017278 */,
  0x02111E11l /* 0x01727C */,
  0x63912281l /* 0x017280 */,
  0x44115E11l /* 0x017284 */,
  0x45860531l /* 0x017288 */,
  0x4691BFD1l /* 0x01728C */,
  0x46415511l /* 0x017290 */,
  0x42117EB1l /* 0x017294 */,
  0x03110531l /* 0x017298 */,
  0x8D915FD1l /* 0x01729C */,
  0x06218541l /* 0x0172A0 */,
  0xC331C4C1l /* 0x0172A4 */,
  0x2281BCF5l /* 0x0172A8 */,
  0xDE10E390l /* 0x0172AC */,
  0x2280C410l /* 0x0172B0 */,
  0x9E11A391l /* 0x0172B4 */,
  0x83318211l /* 0x0172B8 */,
  0xC6218311l /* 0x0172BC */,
  0xE010C4C0l /* 0x0172C0 */,
  0xC620C0F5l /* 0x0172C4 */,
  0x6F00C507l /* 0x0172C8 */,
  0x46013CD0l /* 0x0172CC */,
  0x80398059l /* 0x0172D0 */,
  0x14D02400l /* 0x0172D4 */,
  0xC6008059l /* 0x0172D8 */,
  0x0000C507l /* 0x0172DC */,
  0x32F241D0l /* 0x0172E0 */,
  0x35F240D0l /* 0x0172E4 */,
  0x40D07FE0l /* 0x0172E8 */,
  0x40D032F2l /* 0x0172EC */,
  0x610535F2l /* 0x0172F0 */,
  0x7FE06860l /* 0x0172F4 */,
  0x610540D0l /* 0x0172F8 */,
  0x61055860l /* 0x0172FC */,
  0x61055060l /* 0x017300 */,
  0x6E056860l /* 0x017304 */,
  0x40D05860l /* 0x017308 */,
  0x40D032F2l /* 0x01730C */,
  0x7FE035F2l /* 0x017310 */,
  0x32F240D0l /* 0x017314 */,
  0x35F240D0l /* 0x017318 */,
  0x68606105l /* 0x01731C */,
  0x150400D8l /* 0x017320 */,
  0x7FE0BCF2l /* 0x017324 */,
  0x81DCC0DFl /* 0x017328 */,
  0x40D300D3l /* 0x01732C */,
  0xC0DF47E0l /* 0x017330 */,
  0x7FE081DCl /* 0x017334 */,
  0x6878EA04l /* 0x017338 */,
  0x40D380DCl /* 0x01733C */,
  0x47E001D3l /* 0x017340 */,
  0xEA04ACE0l /* 0x017344 */,
  0xE2F16878l /* 0x017348 */,
  0x230643D0l /* 0x01734C */,
  0x7FE04C60l /* 0x017350 */,
  0x8AD6C0D5l /* 0x017354 */,
  0xEA048BF1l /* 0x017358 */,
  0x2B006878l /* 0x01735C */,
  0x7FB07870l /* 0x017360 */,
  0x78602B00l /* 0x017364 */,
  0x00D341D3l /* 0x017368 */,
  0x4AF380DCl /* 0x01736C */,
  0x6E05F5F0l /* 0x017370 */,
  0x6E05C873l /* 0x017374 */,
  0x6C058C73l /* 0x017378 */,
  0x407128D0l /* 0x01737C */,
  0x406107F2l /* 0x017380 */,
  0xABE8A011l /* 0x017384 */,
  0xEFF0E9F2l /* 0x017388 */,
  0x54D02805l /* 0x01738C */,
  0x06210171l /* 0x017390 */,
  0xFFDFFF07l /* 0x017394 */,
  0x01610041l /* 0x017398 */,
  0x62E8A01Cl /* 0x01739C */,
  0x63E0CEF1l /* 0x0173A0 */,
  0x6E05E2F1l /* 0x0173A4 */,
  0x6E054863l /* 0x0173A8 */,
  0x6C050C63l /* 0x0173AC */,
  0xA1108470l /* 0x0173B0 */,
  0x6E05ACE8l /* 0x0173B4 */,
  0x60105870l /* 0x0173B8 */,
  0x26057FF8l /* 0x0173BC */,
  0x22102470l /* 0x0173C0 */,
  0xD4037FF8l /* 0x0173C4 */,
  0x64057FE8l /* 0x0173C8 */,
  0x60104070l /* 0x0173CC */,
  0x54B0ACE8l /* 0x0173D0 */,
  0x18C84602l /* 0x0173D4 */,
  0x01380602l /* 0x0173D8 */,
  0xEA04ACECl /* 0x0173DC */,
  0x76F16878l /* 0x0173E0 */,
  0xA5E8A010l /* 0x0173E4 */,
  0xA010E5F0l /* 0x0173E8 */,
  0x6418ABE8l /* 0x0173EC */,
  0x0BF18CF8l /* 0x0173F0 */,
  0xA9E8A010l /* 0x0173F4 */,
  0xA01063F1l /* 0x0173F8 */,
  0x55F1ACE8l /* 0x0173FC */,
  0xACE8A010l /* 0x017400 */,
  0x630541D0l /* 0x017404 */,
  0x6B055060l /* 0x017408 */,
  0x21100070l /* 0x01740C */,
  0xA7009FE8l /* 0x017410 */,
  0x12D050D0l /* 0x017414 */,
  0xC0D76000l /* 0x017418 */,
  0xA7000500l /* 0x01741C */,
  0x12D060D0l /* 0x017420 */,
  0xC0D76000l /* 0x017424 */,
  0xC1D50500l /* 0x017428 */,
  0x8BF180D6l /* 0x01742C */,
  0xB6F2ACE0l /* 0x017430 */,
  0xB6F2ACE0l /* 0x017434 */,
  0xA8D6E70Fl /* 0x017438 */,
  0x24F18BF1l /* 0x01743C */,
  0xC7F0C4F2l /* 0x017440 */,
  0x58706E05l /* 0x017444 */,
  0xBCF86010l /* 0x017448 */,
  0x68D06B00l /* 0x01744C */,
  0x600012D0l /* 0x017450 */,
  0x0500C0D7l /* 0x017454 */,
  0x280538F2l /* 0x017458 */,
  0x2805C87Cl /* 0x01745C */,
  0x06008C7Cl /* 0x017460 */,
  0x12D02000l /* 0x017464 */,
  0x48D0A700l /* 0x017468 */,
  0xEF040500l /* 0x01746C */,
  0x20103070l /* 0x017470 */,
  0xEF04DAE8l /* 0x017474 */,
  0x60106870l /* 0x017478 */,
  0x2A03DAF8l /* 0x01747C */,
  0xA28100D0l /* 0x017480 */,
  0x3F806390l /* 0x017484 */,
  0xDBE40130l /* 0x017488 */,
  0x30706A05l /* 0x01748C */,
  0xE0EC0130l /* 0x017490 */,
  0x4602C507l /* 0x017494 */,
  0x7FD6EF0Fl /* 0x017498 */,
  0xC5070602l /* 0x01749C */,
  0xEA044602l /* 0x0174A0 */,
  0x06026476l /* 0x0174A4 */,
  0x80D0C507l /* 0x0174A8 */,
  0x6390A281l /* 0x0174AC */,
  0x6A053F80l /* 0x0174B0 */,
  0x01303070l /* 0x0174B4 */,
  0x81D0EEECl /* 0x0174B8 */,
  0x6D05C507l /* 0x0174BC */,
  0x46305470l /* 0x0174C0 */,
  0x80D1F4ECl /* 0x0174C4 */,
  0x6218C507l /* 0x0174C8 */,
  0xA40402F9l /* 0x0174CC */,
  0x250040D0l /* 0x0174D0 */,
  0x12002078l /* 0x0174D4 */,
  0xE400FFE8l /* 0x0174D8 */,
  0x6A0540D0l /* 0x0174DC */,
  0x0AE17460l /* 0x0174E0 */,
  0x0AF96318l /* 0x0174E4 */,
  0x30702505l /* 0x0174E8 */,
  0x00202801l /* 0x0174EC */,
  0x34606A05l /* 0x0174F0 */,
  0xEA04C507l /* 0x0174F4 */,
  0x70104070l /* 0x0174F8 */,
  0x280522E9l /* 0x0174FC */,
  0xEF065871l /* 0x017500 */,
  0x05C0D872l /* 0x017504 */,
  0x20E90B30l /* 0x017508 */,
  0x30B00BC0l /* 0x01750C */,
  0x68D02B01l /* 0x017510 */,
  0x1EED4030l /* 0x017514 */,
  0x08D0EF00l /* 0x017518 */,
  0x22F90530l /* 0x01751C */,
  0xC50780D0l /* 0x017520 */,
  0xC50781D0l /* 0x017524 */,
  0x49F99503l /* 0x017528 */,
  0x40702805l /* 0x01752C */,
  0x54E96010l /* 0x017530 */,
  0x4C70E700l /* 0x017534 */,
  0x49F96010l /* 0x017538 */,
  0x7470E506l /* 0x01753C */,
  0x45F96010l /* 0x017540 */,
  0x78702B00l /* 0x017544 */,
  0x45E96010l /* 0x017548 */,
  0x58706405l /* 0x01754C */,
  0x49E96010l /* 0x017550 */,
  0x6070EA04l /* 0x017554 */,
  0x70402300l /* 0x017558 */,
  0x60302300l /* 0x01755C */,
  0x650149F9l /* 0x017560 */,
  0x11001478l /* 0x017564 */,
  0x270549F9l /* 0x017568 */,
  0x20103870l /* 0x01756C */,
  0x40D054F9l /* 0x017570 */,
  0x40602805l /* 0x017574 */,
  0x0478EB04l /* 0x017578 */,
  0x51E91100l /* 0x01757C */,
  0x12001D0Bl /* 0x017580 */,
  0x1C0B54E9l /* 0x017584 */,
  0x6E05C507l /* 0x017588 */,
  0x20101870l /* 0x01758C */,
  0x530361F9l /* 0x017590 */,
  0x280561E9l /* 0x017594 */,
  0x20100470l /* 0x017598 */,
  0x80D061E9l /* 0x01759C */,
  0x81D0C507l /* 0x0175A0 */,
  0x6E05C507l /* 0x0175A4 */,
  0x20101870l /* 0x0175A8 */,
  0x610574E9l /* 0x0175AC */,
  0x7FB04C70l /* 0x0175B0 */,
  0x4C606105l /* 0x0175B4 */,
  0x74F95603l /* 0x0175B8 */,
  0x08716105l /* 0x0175BC */,
  0x74ED0131l /* 0x0175C0 */,
  0xC50780D0l /* 0x0175C4 */,
  0xC50781D0l /* 0x0175C8 */,
  0x46024601l /* 0x0175CC */,
  0x060215C8l /* 0x0175D0 */,
  0x6B05C600l /* 0x0175D4 */,
  0x40D02470l /* 0x0175D8 */,
  0x01B06020l /* 0x0175DC */,
  0x80D07EF9l /* 0x0175E0 */,
  0x38706A05l /* 0x0175E4 */,
  0x6A050130l /* 0x0175E8 */,
  0x04303471l /* 0x0175EC */,
  0x81D08AFDl /* 0x0175F0 */,
  0x2905C507l /* 0x0175F4 */,
  0x60105870l /* 0x0175F8 */,
  0xEA04A0E9l /* 0x0175FC */,
  0x22100070l /* 0x017600 */,
  0xA4009AF9l /* 0x017604 */,
  0x36A830D8l /* 0x017608 */,
  0x34983F80l /* 0x01760C */,
  0xA0F91800l /* 0x017610 */,
  0x47F2DFCCl /* 0x017614 */,
  0xA010F3C7l /* 0x017618 */,
  0xA5E1CDE9l /* 0x01761C */,
  0x74702905l /* 0x017620 */,
  0x01301AC0l /* 0x017624 */,
  0x41D0CDEDl /* 0x017628 */,
  0x4060EF04l /* 0x01762C */,
  0x510B4601l /* 0x017630 */,
  0xEA04C600l /* 0x017634 */,
  0x62186878l /* 0x017638 */,
  0x03D7B1E9l /* 0x01763C */,
  0x03D7B2E1l /* 0x017640 */,
  0x18712505l /* 0x017644 */,
  0x14702505l /* 0x017648 */,
  0xBBE52011l /* 0x01764C */,
  0xCDE51C30l /* 0x017650 */,
  0x1C30BEE1l /* 0x017654 */,
  0xCDE501B0l /* 0x017658 */,
  0xCDF95203l /* 0x01765C */,
  0xCBF96218l /* 0x017660 */,
  0x25054601l /* 0x017664 */,
  0x41B06C70l /* 0x017668 */,
  0x6C602505l /* 0x01766C */,
  0x6010C600l /* 0x017670 */,
  0x5207CDF9l /* 0x017674 */,
  0xC507970Bl /* 0x017678 */,
  0x2870EA04l /* 0x01767C */,
  0xD8F92210l /* 0x017680 */,
  0x230642D0l /* 0x017684 */,
  0x22004C60l /* 0x017688 */,
  0xDFE140D0l /* 0x01768C */,
  0xDDF92310l /* 0x017690 */,
  0x40D02001l /* 0x017694 */,
  0xEF00DFE1l /* 0x017698 */,
  0x6A0548D0l /* 0x01769C */,
  0xC5077060l /* 0x0176A0 */,
  0xFBE96318l /* 0x0176A4 */,
  0x00EA6218l /* 0x0176A8 */,
  0x08712007l /* 0x0176AC */,
  0x60D06400l /* 0x0176B0 */,
  0xF2E92011l /* 0x0176B4 */,
  0x60D06900l /* 0x0176B8 */,
  0xF2E92111l /* 0x0176BC */,
  0x60D06E00l /* 0x0176C0 */,
  0x0C712007l /* 0x0176C4 */,
  0xF9E92111l /* 0x0176C8 */,
  0xF9E92411l /* 0x0176CC */,
  0x411003E2l /* 0x0176D0 */,
  0x6B0503E2l /* 0x0176D4 */,
  0x21006070l /* 0x0176D8 */,
  0x03E24020l /* 0x0176DC */,
  0x60706B05l /* 0x0176E0 */,
  0x6A055F10l /* 0x0176E4 */,
  0x06007060l /* 0x0176E8 */,
  0x6800C507l /* 0x0176EC */,
  0x2192C0D1l /* 0x0176F0 */,
  0x09FA0742l /* 0x0176F4 */,
  0xE3916283l /* 0x0176F8 */,
  0xC211DE11l /* 0x0176FC */,
  0x23926282l /* 0x017700 */,
  0x04121E12l /* 0x017704 */,
  0x4586C831l /* 0x017708 */,
  0x06927FD2l /* 0x01770C */,
  0x09421512l /* 0x017710 */,
  0x02123EB2l /* 0x017714 */,
  0xC311C831l /* 0x017718 */,
  0x4D921FD2l /* 0x01771C */,
  0xC9214842l /* 0x017720 */,
  0x853187C1l /* 0x017724 */,
  0x628230F6l /* 0x017728 */,
  0x5E116391l /* 0x01772C */,
  0x62814411l /* 0x017730 */,
  0x5E126392l /* 0x017734 */,
  0x45324212l /* 0x017738 */,
  0x89214312l /* 0x01773C */,
  0xC50747C1l /* 0x017740 */,
  0x44606C05l /* 0x017744 */,
  0x6E05C507l /* 0x017748 */,
  0xC5075860l /* 0x01774C */,
  0x00D06105l /* 0x017750 */,
  0x3FB10071l /* 0x017754 */,
  0x56030061l /* 0x017758 */,
  0x6D0546FAl /* 0x01775C */,
  0x44306070l /* 0x017760 */,
  0x40D046EEl /* 0x017764 */,
  0x6860A307l /* 0x017768 */,
  0x4601C507l /* 0x01776C */,
  0x00D02100l /* 0x017770 */,
  0xC60038A0l /* 0x017774 */,
  0x3C782605l /* 0x017778 */,
  0xA6FA1300l /* 0x01777C */,
  0x60752E05l /* 0x017780 */,
  0xA4752E05l /* 0x017784 */,
  0x7BFA6015l /* 0x017788 */,
  0x7BFA6015l /* 0x01778C */,
  0x20702905l /* 0x017790 */,
  0x58702805l /* 0x017794 */,
  0xA4EA4030l /* 0x017798 */,
  0x3CB04075l /* 0x01779C */,
  0x15C08075l /* 0x0177A0 */,
  0x19101610l /* 0x0177A4 */,
  0x7FD02100l /* 0x0177A8 */,
  0xEF0F0140l /* 0x0177AC */,
  0x41457FD0l /* 0x0177B0 */,
  0x56C05F15l /* 0x0177B4 */,
  0x3FD12300l /* 0x0177B8 */,
  0x97154440l /* 0x0177BC */,
  0x07D12000l /* 0x0177C0 */,
  0x88158445l /* 0x0177C4 */,
  0x87158125l /* 0x0177C8 */,
  0x2E058025l /* 0x0177CC */,
  0x2E056065l /* 0x0177D0 */,
  0x4601A465l /* 0x0177D4 */,
  0xC2924391l /* 0x0177D8 */,
  0xC6003F80l /* 0x0177DC */,
  0xFFDFFF00l /* 0x0177E0 */,
  0xEF07C042l /* 0x0177E4 */,
  0x00D67F41l /* 0x0177E8 */,
  0x68D62F00l /* 0x0177EC */,
  0xBFD4EF07l /* 0x0177F0 */,
  0x52465241l /* 0x0177F4 */,
  0x20085921l /* 0x0177F8 */,
  0x454440D4l /* 0x0177FC */,
  0x51145241l /* 0x017800 */,
  0xD822D122l /* 0x017804 */,
  0xBFD4EF07l /* 0x017808 */,
  0x52455241l /* 0x01780C */,
  0x20085531l /* 0x017810 */,
  0x454440D4l /* 0x017814 */,
  0x51145241l /* 0x017818 */,
  0xD632D132l /* 0x01781C */,
  0xA4E6E012l /* 0x017820 */,
  0xA6FEE512l /* 0x017824 */,
  0xC50780D0l /* 0x017828 */,
  0x290540D0l /* 0x01782C */,
  0x46015860l /* 0x017830 */,
  0x3CD02605l /* 0x017834 */,
  0x18080078l /* 0x017838 */,
  0x00681708l /* 0x01783C */,
  0x280554D0l /* 0x017840 */,
  0xC6007460l /* 0x017844 */,
  0xC50781D0l /* 0x017848 */,
  0x21004601l /* 0x01784C */,
  0x38A000D0l /* 0x017850 */,
  0xC507C600l /* 0x017854 */,
  0x14D0E506l /* 0x017858 */,
  0x40704601l /* 0x01785C */,
  0x40606050l /* 0x017860 */,
  0xC507C600l /* 0x017864 */,
  0xE8EA9E03l /* 0x017868 */,
  0x60706205l /* 0x01786C */,
  0x20D12000l /* 0x017870 */,
  0xE0EE0131l /* 0x017874 */,
  0x2470A701l /* 0x017878 */,
  0x60100078l /* 0x01787C */,
  0x2282E8EAl /* 0x017880 */,
  0x60106390l /* 0x017884 */,
  0xE8E66030l /* 0x017888 */,
  0x20716B05l /* 0x01788C */,
  0x011144C1l /* 0x017890 */,
  0x05215F11l /* 0x017894 */,
  0xE8E60131l /* 0x017898 */,
  0xE8E21D07l /* 0x01789C */,
  0xE8FA5103l /* 0x0178A0 */,
  0x04D0EB04l /* 0x0178A4 */,
  0x11000078l /* 0x0178A8 */,
  0x1D0BE8EAl /* 0x0178AC */,
  0xEA04C507l /* 0x0178B0 */,
  0x62186878l /* 0x0178B4 */,
  0x08D7F1EAl /* 0x0178B8 */,
  0xE8D6A801l /* 0x0178BC */,
  0x03D7F4E2l /* 0x0178C0 */,
  0xC0D6A801l /* 0x0178C4 */,
  0x49EB9E03l /* 0x0178C8 */,
  0x49EBA11Cl /* 0x0178CC */,
  0x49EB6013l /* 0x0178D0 */,
  0x1C76A701l /* 0x0178D4 */,
  0x29001D16l /* 0x0178D8 */,
  0x20166070l /* 0x0178DC */,
  0x290005F7l /* 0x0178E0 */,
  0x01302470l /* 0x0178E4 */,
  0x58200026l /* 0x0178E8 */,
  0xA7017882l /* 0x0178EC */,
  0x50602074l /* 0x0178F0 */,
  0x6B053CB4l /* 0x0178F4 */,
  0xEA042076l /* 0x0178F8 */,
  0x63186878l /* 0x0178FC */,
  0xEF0F14EBl /* 0x017900 */,
  0x194660D6l /* 0x017904 */,
  0x3CB41066l /* 0x017908 */,
  0x60D02505l /* 0x01790C */,
  0x5BC00166l /* 0x017910 */,
  0x1EEF5030l /* 0x017914 */,
  0x28D4A701l /* 0x017918 */,
  0x2064A701l /* 0x01791C */,
  0x40FB6318l /* 0x017920 */,
  0x6470A701l /* 0x017924 */,
  0x6830A701l /* 0x017928 */,
  0x10C15D10l /* 0x01792C */,
  0x2831A701l /* 0x017930 */,
  0x01311D11l /* 0x017934 */,
  0x38B12EF7l /* 0x017938 */,
  0x3DE72611l /* 0x01793C */,
  0x50C004D1l /* 0x017940 */,
  0x6830A701l /* 0x017944 */,
  0x44305D10l /* 0x017948 */,
  0x78B038F7l /* 0x01794C */,
  0xA7014310l /* 0x017950 */,
  0xA7016820l /* 0x017954 */,
  0x25056460l /* 0x017958 */,
  0x48E31461l /* 0x01795C */,
  0x54702505l /* 0x017960 */,
  0x01311CC1l /* 0x017964 */,
  0x7FB048EBl /* 0x017968 */,
  0x54602505l /* 0x01796C */,
  0xC5073882l /* 0x017970 */,
  0x3CD06F00l /* 0x017974 */,
  0x80594601l /* 0x017978 */,
  0x24008039l /* 0x01797C */,
  0x805914D0l /* 0x017980 */,
  0xC507C600l /* 0x017984 */,
  0x5C712805l /* 0x017988 */,
  0x18712805l /* 0x01798C */,
  0x14D02805l /* 0x017990 */,
  0x26008071l /* 0x017994 */,
  0x25103070l /* 0x017998 */,
  0x22100DE8l /* 0x01799C */,
  0x04C01CF8l /* 0x0179A0 */,
  0x4AE90530l /* 0x0179A4 */,
  0x38B005C0l /* 0x0179A8 */,
  0xC311C071l /* 0x0179AC */,
  0x2CD02805l /* 0x0179B0 */,
  0x87C0C061l /* 0x0179B4 */,
  0x4AED8630l /* 0x0179B8 */,
  0x0DE099F1l /* 0x0179BC */,
  0x08706E05l /* 0x0179C0 */,
  0x4AE92010l /* 0x0179C4 */,
  0x053004C0l /* 0x0179C8 */,
  0x05C04AE9l /* 0x0179CC */,
  0xC07138B0l /* 0x0179D0 */,
  0x2805C311l /* 0x0179D4 */,
  0xC0612CD0l /* 0x0179D8 */,
  0x87C060F1l /* 0x0179DC */,
  0x39E48630l /* 0x0179E0 */,
  0xFF073CE8l /* 0x0179E4 */,
  0x80C0FFDFl /* 0x0179E8 */,
  0xA4F18730l /* 0x0179EC */,
  0x4AE50230l /* 0x0179F0 */,
  0x4AE50630l /* 0x0179F4 */,
  0xA4F13CE0l /* 0x0179F8 */,
  0x4AE58020l /* 0x0179FC */,
  0x04C099F1l /* 0x017A00 */,
  0x53E80530l /* 0x017A04 */,
  0x38B005C0l /* 0x017A08 */,
  0x03120072l /* 0x017A0C */,
  0x883086C0l /* 0x017A10 */,
  0x53E41CE8l /* 0x017A14 */,
  0xFFDFFF07l /* 0x017A18 */,
  0x863080C0l /* 0x017A1C */,
  0x01D8A4F1l /* 0x017A20 */,
  0x46E50230l /* 0x017A24 */,
  0x083002D8l /* 0x017A28 */,
  0x460146E5l /* 0x017A2C */,
  0x15C84602l /* 0x017A30 */,
  0xC6000602l /* 0x017A34 */,
  0x6B0520C3l /* 0x017A38 */,
  0x807028D0l /* 0x017A3C */,
  0x023000D0l /* 0x017A40 */,
  0x6B050013l /* 0x017A44 */,
  0x007018D0l /* 0x017A48 */,
  0x7BE82010l /* 0x017A4C */,
  0x74E82110l /* 0x017A50 */,
  0x6BE82210l /* 0x017A54 */,
  0x83E82310l /* 0x017A58 */,
  0x0CC07BE0l /* 0x017A5C */,
  0x1F100113l /* 0x017A60 */,
  0x1F100023l /* 0x017A64 */,
  0x1E100023l /* 0x017A68 */,
  0x86E00023l /* 0x017A6C */,
  0x01130CC0l /* 0x017A70 */,
  0x00231B10l /* 0x017A74 */,
  0x00231E10l /* 0x017A78 */,
  0x0CC086E0l /* 0x017A7C */,
  0x00231F10l /* 0x017A80 */,
  0x00231F10l /* 0x017A84 */,
  0x00231F10l /* 0x017A88 */,
  0x0CC086E0l /* 0x017A8C */,
  0x00331C10l /* 0x017A90 */,
  0x290538B3l /* 0x017A94 */,
  0x006334D0l /* 0x017A98 */,
  0x56104CC0l /* 0x017A9C */,
  0x0CC05B10l /* 0x017AA0 */,
  0xBFD4EF07l /* 0x017AA4 */,
  0x8AC31240l /* 0x017AA8 */,
  0xEF0749C3l /* 0x017AAC */,
  0x5343FFD4l /* 0x017AB0 */,
  0x40331340l /* 0x017AB4 */,
  0x80D42008l /* 0x017AB8 */,
  0x53438D44l /* 0x017ABC */,
  0x92339114l /* 0x017AC0 */,
  0x46018133l /* 0x017AC4 */,
  0x0294C393l /* 0x017AC8 */,
  0xC60010C4l /* 0x017ACC */,
  0xFFDFFF00l /* 0x017AD0 */,
  0x1D100044l /* 0x017AD4 */,
  0x2605C043l /* 0x017AD8 */,
  0x40743CD0l /* 0x017ADC */,
  0x0DC7CEC6l /* 0x017AE0 */,
  0xFFD4EF07l /* 0x017AE4 */,
  0xD3431347l /* 0x017AE8 */,
  0x20080F37l /* 0x017AEC */,
  0x9C4480D4l /* 0x017AF0 */,
  0x91141347l /* 0x017AF4 */,
  0xD036D236l /* 0x017AF8 */,
  0x9CC65BC6l /* 0x017AFC */,
  0xCEF46016l /* 0x017B00 */,
  0x1AC559C5l /* 0x017B04 */,
  0x80D640D6l /* 0x017B08 */,
  0xFFD4EF07l /* 0x017B0C */,
  0x13459346l /* 0x017B10 */,
  0x20089436l /* 0x017B14 */,
  0x9A4480D4l /* 0x017B18 */,
  0x91149346l /* 0x017B1C */,
  0x55365236l /* 0x017B20 */,
  0xF2F840B4l /* 0x017B24 */,
  0x40D02004l /* 0x017B28 */,
  0xEF0700D0l /* 0x017B2C */,
  0x1340FFD4l /* 0x017B30 */,
  0x1A309346l /* 0x017B34 */,
  0x80D42008l /* 0x017B38 */,
  0x13408044l /* 0x017B3C */,
  0x52309114l /* 0x017B40 */,
  0xF2F45930l /* 0x017B44 */,
  0x00D02004l /* 0x017B48 */,
  0x04D80410l /* 0x017B4C */,
  0x504040C0l /* 0x017B50 */,
  0x08D849F9l /* 0x017B54 */,
  0x4E4040C0l /* 0x017B58 */,
  0x1BC849F9l /* 0x017B5C */,
  0xF0F85700l /* 0x017B60 */,
  0xACE00054l /* 0x017B64 */,
  0xACE08053l /* 0x017B68 */,
  0x68D02905l /* 0x017B6C */,
  0x29054170l /* 0x017B70 */,
  0x007024D0l /* 0x017B74 */,
  0xDE14C1C4l /* 0x017B78 */,
  0x814483D4l /* 0x017B7C */,
  0x00C58E14l /* 0x017B80 */,
  0x94541F15l /* 0x017B84 */,
  0x0ED52C00l /* 0x017B88 */,
  0x06004601l /* 0x017B8C */,
  0xFDA4BCA4l /* 0x017B90 */,
  0x14653F80l /* 0x017B94 */,
  0xC6000600l /* 0x017B98 */,
  0xDE14D0C4l /* 0x017B9C */,
  0x904483D4l /* 0x017BA0 */,
  0x0FC58E14l /* 0x017BA4 */,
  0x94541F15l /* 0x017BA8 */,
  0x12D52C00l /* 0x017BAC */,
  0x06004601l /* 0x017BB0 */,
  0xFDA4BCA4l /* 0x017BB4 */,
  0x14653F80l /* 0x017BB8 */,
  0xC6000600l /* 0x017BBC */,
  0xBC632905l /* 0x017BC0 */,
  0x78632905l /* 0x017BC4 */,
  0x30642905l /* 0x017BC8 */,
  0xEC632905l /* 0x017BCC */,
  0xC4662A05l /* 0x017BD0 */,
  0x00672A05l /* 0x017BD4 */,
  0x30D02600l /* 0x017BD8 */,
  0x26100070l /* 0x017BDC */,
  0x24102FE9l /* 0x017BE0 */,
  0xA70035F9l /* 0x017BE4 */,
  0x12D068D0l /* 0x017BE8 */,
  0xC0D76000l /* 0x017BEC */,
  0xE9F10500l /* 0x017BF0 */,
  0x18D02905l /* 0x017BF4 */,
  0x20100070l /* 0x017BF8 */,
  0x4AE13CE9l /* 0x017BFC */,
  0x290540D0l /* 0x017C00 */,
  0x40601CD0l /* 0x017C04 */,
  0x290540D0l /* 0x017C08 */,
  0x406014D0l /* 0x017C0C */,
  0x4AE1ADF1l /* 0x017C10 */,
  0x0DE0F3F1l /* 0x017C14 */,
  0xF3F199F1l /* 0x017C18 */,
  0x28054601l /* 0x017C1C */,
  0x200034D0l /* 0x017C20 */,
  0x406054D0l /* 0x017C24 */,
  0xC6000600l /* 0x017C28 */,
  0x3CD02605l /* 0x017C2C */,
  0x17080078l /* 0x017C30 */,
  0x6B050068l /* 0x017C34 */,
  0x40703CD0l /* 0x017C38 */,
  0xC0773CB0l /* 0x017C3C */,
  0x12D02000l /* 0x017C40 */,
  0x05002010l /* 0x017C44 */,
  0x407205C0l /* 0x017C48 */,
  0x46013CB0l /* 0x017C4C */,
  0x95038072l /* 0x017C50 */,
  0x64056CF9l /* 0x017C54 */,
  0x060028D8l /* 0x017C58 */,
  0x60607D90l /* 0x017C5C */,
  0x3FD8EF0Fl /* 0x017C60 */,
  0xC600A042l /* 0x017C64 */,
  0x700010D8l /* 0x017C68 */,
  0x40C001D0l /* 0x017C6C */,
  0x01300940l /* 0x017C70 */,
  0x20D848F9l /* 0x017C74 */,
  0x00D02400l /* 0x017C78 */,
  0x48E90A40l /* 0x017C7C */,
  0x161009C0l /* 0x017C80 */,
  0x21001910l /* 0x017C84 */,
  0x01407FD0l /* 0x017C88 */,
  0x7FD0EF0Fl /* 0x017C8C */,
  0x5F124142l /* 0x017C90 */,
  0x23004AC0l /* 0x017C94 */,
  0x4240BFD0l /* 0x017C98 */,
  0x20009712l /* 0x017C9C */,
  0x824287D0l /* 0x017CA0 */,
  0x81228812l /* 0x017CA4 */,
  0x80228712l /* 0x017CA8 */,
  0x28D02905l /* 0x017CAC */,
  0x29058062l /* 0x017CB0 */,
  0x406224D0l /* 0x017CB4 */,
  0x70B1C507l /* 0x017CB8 */,
  0x28D02B01l /* 0x017CBC */,
  0xA0ED0530l /* 0x017CC0 */,
  0x48D1EF00l /* 0x017CC4 */,
  0x1CD02805l /* 0x017CC8 */,
  0xC5074061l /* 0x017CCC */,
  0x24D02900l /* 0x017CD0 */,
  0x29000070l /* 0x017CD4 */,
  0x417060D0l /* 0x017CD8 */,
  0x03100130l /* 0x017CDC */,
  0x2605C507l /* 0x017CE0 */,
  0x407024D0l /* 0x017CE4 */,
  0xC1F96210l /* 0x017CE8 */,
  0x0070EA04l /* 0x017CEC */,
  0xC1E92210l /* 0x017CF0 */,
  0xC1E92410l /* 0x017CF4 */,
  0x28D06405l /* 0x017CF8 */,
  0x6405C070l /* 0x017CFC */,
  0x807034D0l /* 0x017D00 */,
  0xC1E9C230l /* 0x017D04 */,
  0x42D0C507l /* 0x017D08 */,
  0x0EC04410l /* 0x017D0C */,
  0x8ED01210l /* 0x017D10 */,
  0x40200240l /* 0x017D14 */,
  0x48107FB0l /* 0x017D18 */,
  0x0EC04810l /* 0x017D1C */,
  0xBFD0EF07l /* 0x017D20 */,
  0x01100240l /* 0x017D24 */,
  0x7FB04020l /* 0x017D28 */,
  0x01100DC0l /* 0x017D2C */,
  0x46013FB0l /* 0x017D30 */,
  0x03A042A0l /* 0x017D34 */,
  0x6B05C600l /* 0x017D38 */,
  0x407010D0l /* 0x017D3C */,
  0x40607FB0l /* 0x017D40 */,
  0x140811C8l /* 0x017D44 */,
  0x3CD02605l /* 0x017D48 */,
  0x60C40068l /* 0x017D4C */,
  0x620540D0l /* 0x017D50 */,
  0x406008D0l /* 0x017D54 */,
  0x4601C507l /* 0x017D58 */,
  0xC21DDE1Dl /* 0x017D5C */,
  0x2A05C600l /* 0x017D60 */,
  0x40D020D0l /* 0x017D64 */,
  0x80D74060l /* 0x017D68 */,
  0x2A05C507l /* 0x017D6C */,
  0x407018D0l /* 0x017D70 */,
  0x40607FB0l /* 0x017D74 */,
  0x1CD02A05l /* 0x017D78 */,
  0x60504070l /* 0x017D7C */,
  0xBFD0EF00l /* 0x017D80 */,
  0x0C184240l /* 0x017D84 */,
  0x40606050l /* 0x017D88 */,
  0x0000C507l /* 0x017D8C */,
  0x28054601l /* 0x017D90 */,
  0x200034D0l /* 0x017D94 */,
  0x406054D0l /* 0x017D98 */,
  0xC6000600l /* 0x017D9C */,
  0x3CD02605l /* 0x017DA0 */,
  0x17080078l /* 0x017DA4 */,
  0x6B050068l /* 0x017DA8 */,
  0x40703CD0l /* 0x017DAC */,
  0xC0773CB0l /* 0x017DB0 */,
  0x12D02000l /* 0x017DB4 */,
  0x05002010l /* 0x017DB8 */,
  0xAD0030F0l /* 0x017DBC */,
  0x200068D0l /* 0x017DC0 */,
  0xE017D2D7l /* 0x017DC4 */,
  0x6805C407l /* 0x017DC8 */,
  0x3FB02C70l /* 0x017DCC */,
  0x2C606805l /* 0x017DD0 */,
  0x20706505l /* 0x017DD4 */,
  0x26E82010l /* 0x017DD8 */,
  0x2C706505l /* 0x017DDC */,
  0x26E82010l /* 0x017DE0 */,
  0x24706C05l /* 0x017DE4 */,
  0x26F82110l /* 0x017DE8 */,
  0x0C706505l /* 0x017DEC */,
  0x10606505l /* 0x017DF0 */,
  0x00D001D0l /* 0x017DF4 */,
  0x14606505l /* 0x017DF8 */,
  0x58D0AF00l /* 0x017DFC */,
  0x600012D0l /* 0x017E00 */,
  0x0500C0D7l /* 0x017E04 */,
  0x30D02705l /* 0x017E08 */,
  0x60104070l /* 0x017E0C */,
  0x12D02000l /* 0x017E10 */,
  0xC0D76000l /* 0x017E14 */,
  0x0500E017l /* 0x017E18 */,
  0x3CD06F00l /* 0x017E1C */,
  0x80594601l /* 0x017E20 */,
  0x24008039l /* 0x017E24 */,
  0x805914D0l /* 0x017E28 */,
  0xC507C600l /* 0x017E2C */,
  0x40D003F3l /* 0x017E30 */,
  0x68602705l /* 0x017E34 */,
  0x80D6AD00l /* 0x017E38 */,
  0x2070AC05l /* 0x017E3C */,
  0x16E82210l /* 0x017E40 */,
  0x1C70E700l /* 0x017E44 */,
  0x16F82010l /* 0x017E48 */,
  0x0070E705l /* 0x017E4C */,
  0x2DFB2010l /* 0x017E50 */,
  0x2C706205l /* 0x017E54 */,
  0x2DFB2010l /* 0x017E58 */,
  0x30D06C05l /* 0x017E5C */,
  0x7CB04070l /* 0x017E60 */,
  0x26054060l /* 0x017E64 */,
  0xAC05A477l /* 0x017E68 */,
  0xAC050C7Al /* 0x017E6C */,
  0x6005607Al /* 0x017E70 */,
  0xA2054077l /* 0x017E74 */,
  0xAC05E078l /* 0x017E78 */,
  0xA205A478l /* 0x017E7C */,
  0x60054C76l /* 0x017E80 */,
  0xAC05FC76l /* 0x017E84 */,
  0x6005807Al /* 0x017E88 */,
  0x40D1A06Al /* 0x017E8C */,
  0x34782E00l /* 0x017E90 */,
  0x3F482F00l /* 0x017E94 */,
  0x70D02300l /* 0x017E98 */,
  0x40E8110Cl /* 0x017E9C */,
  0x60D02700l /* 0x017EA0 */,
  0x40E8110Cl /* 0x017EA4 */,
  0x43F8D103l /* 0x017EA8 */,
  0x43E041B1l /* 0x017EAC */,
  0x43E8D103l /* 0x017EB0 */,
  0x27057FB1l /* 0x017EB4 */,
  0x80D04861l /* 0x017EB8 */,
  0x0070A205l /* 0x017EBC */,
  0x20302500l /* 0x017EC0 */,
  0xA20551ECl /* 0x017EC4 */,
  0x24000470l /* 0x017EC8 */,
  0x51E42C30l /* 0x017ECC */,
  0xE80481D0l /* 0x017ED0 */,
  0x40D0B060l /* 0x017ED4 */,
  0x7060A307l /* 0x017ED8 */,
  0x40606105l /* 0x017EDC */,
  0x70606D05l /* 0x017EE0 */,
  0x58606E05l /* 0x017EE4 */,
  0x68606105l /* 0x017EE8 */,
  0x5860A307l /* 0x017EEC */,
  0x74606D05l /* 0x017EF0 */,
  0x70606205l /* 0x017EF4 */,
  0xA8672605l /* 0x017EF8 */,
  0x78D0A800l /* 0x017EFC */,
  0x48602805l /* 0x017F00 */,
  0x40D06000l /* 0x017F04 */,
  0x4C602805l /* 0x017F08 */,
  0x640540D0l /* 0x017F0C */,
  0x43B04C60l /* 0x017F10 */,
  0x48606405l /* 0x017F14 */,
  0xA30741D0l /* 0x017F18 */,
  0xA2056860l /* 0x017F1C */,
  0x24004470l /* 0x017F20 */,
  0x013020D0l /* 0x017F24 */,
  0x230083F4l /* 0x017F28 */,
  0x60104870l /* 0x017F2C */,
  0xA20583E8l /* 0x017F30 */,
  0x90014860l /* 0x017F34 */,
  0x600594F8l /* 0x017F38 */,
  0x63104470l /* 0x017F3C */,
  0xEF0494E8l /* 0x017F40 */,
  0x21103070l /* 0x017F44 */,
  0xEF0491F8l /* 0x017F48 */,
  0x20103470l /* 0x017F4C */,
  0x693094E8l /* 0x017F50 */,
  0x10E394F8l /* 0x017F54 */,
  0x99E89001l /* 0x017F58 */,
  0x00D241D7l /* 0x017F5C */,
  0x631AA5E0l /* 0x017F60 */,
  0x41D79EF8l /* 0x017F64 */,
  0xA5E000D2l /* 0x017F68 */,
  0x14722F05l /* 0x017F6C */,
  0x621A40D7l /* 0x017F70 */,
  0x41D7A5E8l /* 0x017F74 */,
  0x600500D2l /* 0x017F78 */,
  0x2F054067l /* 0x017F7C */,
  0x60051462l /* 0x017F80 */,
  0x02D7446Al /* 0x017F84 */,
  0xB9E89001l /* 0x017F88 */,
  0xB3E86216l /* 0x017F8C */,
  0xB3E86116l /* 0x017F90 */,
  0x6011B9E0l /* 0x017F94 */,
  0xE316CCF8l /* 0x017F98 */,
  0x03D7CCE8l /* 0x017F9C */,
  0x231ACCE0l /* 0x017FA0 */,
  0xE2C4C2F8l /* 0x017FA4 */,
  0xCCE81301l /* 0x017FA8 */,
  0xCCF89001l /* 0x017FAC */,
  0xCCE003D7l /* 0x017FB0 */,
  0x2C782705l /* 0x017FB4 */,
  0x1300E0C4l /* 0x017FB8 */,
  0x9001CAE8l /* 0x017FBC */,
  0x03D7CAF8l /* 0x017FC0 */,
  0xAC682705l /* 0x017FC4 */,
  0x74702E00l /* 0x017FC8 */,
  0x7F402F00l /* 0x017FCC */,
  0xA0D02700l /* 0x017FD0 */,
  0xEEF88130l /* 0x017FD4 */,
  0xD9E82317l /* 0x017FD8 */,
  0xDCE82217l /* 0x017FDC */,
  0xE216E9E0l /* 0x017FE0 */,
  0xDEE0E9F8l /* 0x017FE4 */,
  0xE9F8E316l /* 0x017FE8 */,
  0x54702705l /* 0x017FEC */,
  0x27057FB0l /* 0x017FF0 */,
  0x27055460l /* 0x017FF4 */,
  0x81309870l /* 0x017FF8 */,
  0x41D0ECECl /* 0x017FFC */,
  0x40D0EFE0l /* 0x018000 */,
  0x54602705l /* 0x018004 */,
  0xEFE042D0l /* 0x018008 */,
  0x81C140D0l /* 0x01800C */,
  0x44602705l /* 0x018010 */,
  0x900100D6l /* 0x018014 */,
  0x601728F9l /* 0x018018 */,
  0xE10528E9l /* 0x01801C */,
  0x60106470l /* 0x018020 */,
  0xAC0528F9l /* 0x018024 */,
  0x63106070l /* 0x018028 */,
  0x611101F9l /* 0x01802C */,
  0x320028E9l /* 0x018030 */,
  0x38A001D0l /* 0x018034 */,
  0xE6053F80l /* 0x018038 */,
  0x017078D0l /* 0x01803C */,
  0x014041D0l /* 0x018040 */,
  0x40D00210l /* 0x018044 */,
  0x0FE9D503l /* 0x018048 */,
  0x015042D0l /* 0x01804C */,
  0x17E9631Al /* 0x018050 */,
  0x611A41D0l /* 0x018054 */,
  0x40D01AE9l /* 0x018058 */,
  0xD7141AE1l /* 0x01805C */,
  0x534041D0l /* 0x018060 */,
  0x41D00150l /* 0x018064 */,
  0x22004010l /* 0x018068 */,
  0x814096D0l /* 0x01806C */,
  0x28E9A010l /* 0x018070 */,
  0x630501D6l /* 0x018074 */,
  0x40703CD0l /* 0x018078 */,
  0x40607FB0l /* 0x01807C */,
  0x34676005l /* 0x018080 */,
  0x58205CC0l /* 0x018084 */,
  0x78606005l /* 0x018088 */,
  0x00D03200l /* 0x01808C */,
  0x3F8038A0l /* 0x018090 */,
  0x421059C0l /* 0x018094 */,
  0x88D02107l /* 0x018098 */,
  0x82748120l /* 0x01809C */,
  0x3DF9E316l /* 0x0180A0 */,
  0x5F1052C0l /* 0x0180A4 */,
  0x621A8124l /* 0x0180A8 */,
  0xFEF140E9l /* 0x0180AC */,
  0x3C676005l /* 0x0180B0 */,
  0x5FF96117l /* 0x0180B4 */,
  0x58F9211Al /* 0x0180B8 */,
  0x0070AC05l /* 0x0180BC */,
  0x58F92010l /* 0x0180C0 */,
  0x56F99503l /* 0x0180C4 */,
  0x00706505l /* 0x0180C8 */,
  0x007034B0l /* 0x0180CC */,
  0x01404FD0l /* 0x0180D0 */,
  0x5FE92F10l /* 0x0180D4 */,
  0x58F92C10l /* 0x0180D8 */,
  0x59E141D0l /* 0x0180DC */,
  0x270540D0l /* 0x0180E0 */,
  0x807000D0l /* 0x0180E4 */,
  0x90602805l /* 0x0180E8 */,
  0xEA044060l /* 0x0180EC */,
  0x62104070l /* 0x0180F0 */,
  0x601179E9l /* 0x0180F4 */,
  0x27007BE5l /* 0x0180F8 */,
  0x10003478l /* 0x0180FC */,
  0x27057BF9l /* 0x018100 */,
  0x60104070l /* 0x018104 */,
  0xED0479F9l /* 0x018108 */,
  0x60104870l /* 0x01810C */,
  0xAC0579F9l /* 0x018110 */,
  0x63106070l /* 0x018114 */,
  0x611179F9l /* 0x018118 */,
  0xA21179F9l /* 0x01811C */,
  0x40D07BE9l /* 0x018120 */,
  0x41D07CE1l /* 0x018124 */,
  0x68606205l /* 0x018128 */,
  0x88F9211Al /* 0x01812C */,
  0x68702F05l /* 0x018130 */,
  0x6C602F05l /* 0x018134 */,
  0x2F0540D0l /* 0x018138 */,
  0x9CE16860l /* 0x01813C */,
  0x28D02F05l /* 0x018140 */,
  0x7FB04070l /* 0x018144 */,
  0x221A4060l /* 0x018148 */,
  0x2F0597F9l /* 0x01814C */,
  0x2F057070l /* 0x018150 */,
  0x40D07460l /* 0x018154 */,
  0x70602F05l /* 0x018158 */,
  0x2F059CE1l /* 0x01815C */,
  0x407030D0l /* 0x018160 */,
  0x40607FB0l /* 0x018164 */,
  0xA0E9A017l /* 0x018168 */,
  0xC1E96017l /* 0x01816C */,
  0xBAF9A017l /* 0x018170 */,
  0xB9E96017l /* 0x018174 */,
  0xB9F9211Al /* 0x018178 */,
  0x1070EB04l /* 0x01817C */,
  0xADF92310l /* 0x018180 */,
  0xEE0441D0l /* 0x018184 */,
  0x00D27C60l /* 0x018188 */,
  0x14622F05l /* 0x01818C */,
  0xC4E181D7l /* 0x018190 */,
  0x2CD8AB05l /* 0x018194 */,
  0x11002078l /* 0x018198 */,
  0x82D7B9F9l /* 0x01819C */,
  0xF9E1C4E1l /* 0x0181A0 */,
  0xC4F9A117l /* 0x0181A4 */,
  0xBFF9231Al /* 0x0181A8 */,
  0x82D7F9E1l /* 0x0181AC */,
  0x0852C4E1l /* 0x0181B0 */,
  0x10E3C4E9l /* 0x0181B4 */,
  0x24D02605l /* 0x0181B8 */,
  0x62058067l /* 0x0181BC */,
  0x80D05470l /* 0x0181C0 */,
  0x94606205l /* 0x0181C4 */,
  0xDEE96010l /* 0x0181C8 */,
  0x58706205l /* 0x0181CC */,
  0xD7F9231Al /* 0x0181D0 */,
  0x8130AAC0l /* 0x0181D4 */,
  0xDEE9A110l /* 0x0181D8 */,
  0xAAC0DAE1l /* 0x0181DC */,
  0xDEED8130l /* 0x0181E0 */,
  0x260540D0l /* 0x0181E4 */,
  0xF9E16460l /* 0x0181E8 */,
  0xE7F9621Al /* 0x0181EC */,
  0xAD0040D0l /* 0x0181F0 */,
  0x12D060D0l /* 0x0181F4 */,
  0xC0D76000l /* 0x0181F8 */,
  0x40D00500l /* 0x0181FC */,
  0xEA04FBF1l /* 0x018200 */,
  0x24100070l /* 0x018204 */,
  0xAD00F3F9l /* 0x018208 */,
  0x12D078D0l /* 0x01820C */,
  0xC0D76000l /* 0x018210 */,
  0xAD000500l /* 0x018214 */,
  0x12D070D0l /* 0x018218 */,
  0xC0D76000l /* 0x01821C */,
  0x41D00500l /* 0x018220 */,
  0x2F05E8E1l /* 0x018224 */,
  0xC5076060l /* 0x018228 */,
  0xC472AC05l /* 0x01822C */,
  0x8872AC05l /* 0x018230 */,
  0x640540D2l /* 0x018234 */,
  0x60105070l /* 0x018238 */,
  0x65053CEAl /* 0x01823C */,
  0xEF020074l /* 0x018240 */,
  0x4B307FD0l /* 0x018244 */,
  0x40D011EAl /* 0x018248 */,
  0x7C606405l /* 0x01824C */,
  0x8AC033E2l /* 0x018250 */,
  0x7FD02300l /* 0x018254 */,
  0xE80F8142l /* 0x018258 */,
  0x814040D0l /* 0x01825C */,
  0x82529F10l /* 0x018260 */,
  0x64058212l /* 0x018264 */,
  0x81627CD0l /* 0x018268 */,
  0x33EAA012l /* 0x01826C */,
  0xCAC04AC0l /* 0x018270 */,
  0xEF0F8172l /* 0x018274 */,
  0x2400BF42l /* 0x018278 */,
  0x825280D0l /* 0x01827C */,
  0xC1727CB0l /* 0x018280 */,
  0xFF42EF00l /* 0x018284 */,
  0x80D02402l /* 0x018288 */,
  0x7CB0C252l /* 0x01828C */,
  0x40D00174l /* 0x018290 */,
  0x95034360l /* 0x018294 */,
  0x65053CFAl /* 0x018298 */,
  0x20140064l /* 0x01829C */,
  0x50743CEAl /* 0x0182A0 */,
  0x44646505l /* 0x0182A4 */,
  0x23008BC0l /* 0x0182A8 */,
  0x81407FD0l /* 0x0182AC */,
  0x47D0D712l /* 0x0182B0 */,
  0xC812C142l /* 0x0182B4 */,
  0xC712C222l /* 0x0182B8 */,
  0x97108AC0l /* 0x0182BC */,
  0x7FD02100l /* 0x0182C0 */,
  0xC2228140l /* 0x0182C4 */,
  0xBFD02300l /* 0x0182C8 */,
  0x87128242l /* 0x0182CC */,
  0xB8622D05l /* 0x0182D0 */,
  0xFC622D05l /* 0x0182D4 */,
  0x08732E05l /* 0x0182D8 */,
  0x4C732E05l /* 0x0182DC */,
  0x80732E05l /* 0x0182E0 */,
  0xC4732E05l /* 0x0182E4 */,
  0xFFDFFF0Fl /* 0x0182E8 */,
  0x00430210l /* 0x0182EC */,
  0xAC058043l /* 0x0182F0 */,
  0x017A4CD0l /* 0x0182F4 */,
  0x9EFA231Al /* 0x0182F8 */,
  0x6AFAA012l /* 0x0182FC */,
  0x76EAE012l /* 0x018300 */,
  0x3CD02605l /* 0x018304 */,
  0x13080078l /* 0x018308 */,
  0x40D00068l /* 0x01830C */,
  0x3CD02705l /* 0x018310 */,
  0x0AC34060l /* 0x018314 */,
  0xC1E24BC3l /* 0x018318 */,
  0x4070AC05l /* 0x01831C */,
  0x91FA6010l /* 0x018320 */,
  0x7C702705l /* 0x018324 */,
  0x91EA6010l /* 0x018328 */,
  0x406040D0l /* 0x01832C */,
  0x11734601l /* 0x018330 */,
  0x7D930600l /* 0x018334 */,
  0xC6003F80l /* 0x018338 */,
  0x20080111l /* 0x01833C */,
  0x8CC000D0l /* 0x018340 */,
  0x91108040l /* 0x018344 */,
  0xEF074253l /* 0x018348 */,
  0x00433FD0l /* 0x01834C */,
  0x40D0C1E2l /* 0x018350 */,
  0x7C602705l /* 0x018354 */,
  0x20081223l /* 0x018358 */,
  0x4C3040D0l /* 0x01835C */,
  0x7FB3C1EEl /* 0x018360 */,
  0x40D02008l /* 0x018364 */,
  0xC1E20133l /* 0x018368 */,
  0xA2FAA013l /* 0x01836C */,
  0xAAEAE013l /* 0x018370 */,
  0x4FC30EC3l /* 0x018374 */,
  0x3CD02605l /* 0x018378 */,
  0x13080078l /* 0x01837C */,
  0xB3E20068l /* 0x018380 */,
  0x20081223l /* 0x018384 */,
  0x4C3040D0l /* 0x018388 */,
  0x7FB3B3EEl /* 0x01838C */,
  0x40D02008l /* 0x018390 */,
  0xA0120133l /* 0x018394 */,
  0xE012B7FAl /* 0x018398 */,
  0x2605BFEAl /* 0x01839C */,
  0x00783CD0l /* 0x0183A0 */,
  0x00681308l /* 0x0183A4 */,
  0xCBC38AC3l /* 0x0183A8 */,
  0x80D3C1E2l /* 0x0183AC */,
  0x6012C0D3l /* 0x0183B0 */,
  0x6105F6FAl /* 0x0183B4 */,
  0x60107470l /* 0x0183B8 */,
  0x2A05F6FAl /* 0x0183BC */,
  0x2A055070l /* 0x0183C0 */,
  0xEF079470l /* 0x0183C4 */,
  0x55407FD5l /* 0x0183C8 */,
  0x4C301543l /* 0x0183CC */,
  0x00D52008l /* 0x0183D0 */,
  0x55400145l /* 0x0183D4 */,
  0x94301115l /* 0x0183D8 */,
  0xA0108D30l /* 0x0183DC */,
  0xC1D0F6E6l /* 0x0183E0 */,
  0xEF0700D1l /* 0x0183E4 */,
  0x15417FD5l /* 0x0183E8 */,
  0x01315540l /* 0x0183EC */,
  0x00D52008l /* 0x0183F0 */,
  0x15410445l /* 0x0183F4 */,
  0xD4301115l /* 0x0183F8 */,
  0xE010C230l /* 0x0183FC */,
  0x41D2F6E6l /* 0x018400 */,
  0x08732E05l /* 0x018404 */,
  0x4C732E05l /* 0x018408 */,
  0xF3EA231Al /* 0x01840C */,
  0xC0D380D3l /* 0x018410 */,
  0x80D264E2l /* 0x018414 */,
  0x64E2C0D2l /* 0x018418 */,
  0x08632E05l /* 0x01841C */,
  0x4C632E05l /* 0x018420 */,
  0x10632A05l /* 0x018424 */,
  0x54632A05l /* 0x018428 */,
  0x80632E05l /* 0x01842C */,
  0xC4632E05l /* 0x018430 */,
  0x6F00C507l /* 0x018434 */,
  0x46013CD0l /* 0x018438 */,
  0x80398059l /* 0x01843C */,
  0x14D02400l /* 0x018440 */,
  0xC6008059l /* 0x018444 */,
  0x0000C507l /* 0x018448 */,
  0x0C7AAC05l /* 0x01844C */,
  0xC4712705l /* 0x018450 */,
  0x00706005l /* 0x018454 */,
  0x07E92010l /* 0x018458 */,
  0x10F8231Al /* 0x01845C */,
  0x201014F1l /* 0x018460 */,
  0x01D010E8l /* 0x018464 */,
  0x20602F05l /* 0x018468 */,
  0x3471EF04l /* 0x01846C */,
  0x3070EF04l /* 0x018470 */,
  0x014041D0l /* 0x018474 */,
  0x231A2BE8l /* 0x018478 */,
  0x10E31AF8l /* 0x01847C */,
  0x1EF8221Al /* 0x018480 */,
  0x10FB2111l /* 0x018484 */,
  0x2BE82211l /* 0x018488 */,
  0x74D02605l /* 0x01848C */,
  0x20100170l /* 0x018490 */,
  0x01B028E8l /* 0x018494 */,
  0x10E30160l /* 0x018498 */,
  0x3870EF04l /* 0x01849C */,
  0x2A000160l /* 0x0184A0 */,
  0x2100A071l /* 0x0184A4 */,
  0x063000D0l /* 0x0184A8 */,
  0x270582F8l /* 0x0184AC */,
  0x20100070l /* 0x0184B0 */,
  0xE70077E8l /* 0x0184B4 */,
  0x20102470l /* 0x0184B8 */,
  0xE70047E8l /* 0x0184BC */,
  0x26056070l /* 0x0184C0 */,
  0x1FD0B870l /* 0x0184C4 */,
  0x41108040l /* 0x0184C8 */,
  0xA1109F10l /* 0x0184CC */,
  0x5F103FECl /* 0x0184D0 */,
  0x78606005l /* 0x0184D4 */,
  0x2E0582E0l /* 0x0184D8 */,
  0x2E058470l /* 0x0184DC */,
  0x2E054070l /* 0x0184E0 */,
  0x2E050C70l /* 0x0184E4 */,
  0xEF07C870l /* 0x0184E8 */,
  0x48403FD2l /* 0x0184EC */,
  0x4330C840l /* 0x0184F0 */,
  0xC0D12008l /* 0x0184F4 */,
  0x4840C141l /* 0x0184F8 */,
  0x8730D111l /* 0x0184FC */,
  0xA0108030l /* 0x018500 */,
  0x39E05EECl /* 0x018504 */,
  0x0FD05510l /* 0x018508 */,
  0xFF004040l /* 0x01850C */,
  0x8040FFDFl /* 0x018510 */,
  0x42208410l /* 0x018514 */,
  0x1E1001C0l /* 0x018518 */,
  0x5F104020l /* 0x01851C */,
  0x38772605l /* 0x018520 */,
  0x00471FD0l /* 0x018524 */,
  0x74FC2117l /* 0x018528 */,
  0x1F174110l /* 0x01852C */,
  0x70EC2117l /* 0x018530 */,
  0x78606005l /* 0x018534 */,
  0x260582E0l /* 0x018538 */,
  0x60053877l /* 0x01853C */,
  0x63107470l /* 0x018540 */,
  0x5CC080F8l /* 0x018544 */,
  0x01275F10l /* 0x018548 */,
  0x38676005l /* 0x01854C */,
  0x48D06405l /* 0x018550 */,
  0x2CD02005l /* 0x018554 */,
  0x22100070l /* 0x018558 */,
  0x8DECBFE4l /* 0x01855C */,
  0x04B000D0l /* 0x018560 */,
  0x00D08FE0l /* 0x018564 */,
  0x016005B0l /* 0x018568 */,
  0xFC702005l /* 0x01856C */,
  0x6405DC10l /* 0x018570 */,
  0x2005CC60l /* 0x018574 */,
  0xA410AC70l /* 0x018578 */,
  0xE105BFF8l /* 0x01857C */,
  0xA010A470l /* 0x018580 */,
  0xAC05BFF8l /* 0x018584 */,
  0xA3108C70l /* 0x018588 */,
  0x2705BFF8l /* 0x01858C */,
  0xA310B470l /* 0x018590 */,
  0xE010BCF8l /* 0x018594 */,
  0x6B05BCE8l /* 0x018598 */,
  0x60104070l /* 0x01859C */,
  0xAD00B4E8l /* 0x0185A0 */,
  0x6000C8DCl /* 0x0185A4 */,
  0x200080DCl /* 0x0185A8 */,
  0xA70012D0l /* 0x0185AC */,
  0x050048D0l /* 0x0185B0 */,
  0x2070AC05l /* 0x0185B4 */,
  0xBCF82310l /* 0x0185B8 */,
  0xABC00DF1l /* 0x0185BC */,
  0xB8FC8330l /* 0x0185C0 */,
  0xA30740D0l /* 0x0185C4 */,
  0xEF046860l /* 0x0185C8 */,
  0x24102070l /* 0x0185CC */,
  0x01D0CCF8l /* 0x0185D0 */,
  0x20602F05l /* 0x0185D4 */,
  0x58D0AD00l /* 0x0185D8 */,
  0x600012D0l /* 0x0185DC */,
  0x0500C0D7l /* 0x0185E0 */,
  0x6871EB04l /* 0x0185E4 */,
  0xE8E86011l /* 0x0185E8 */,
  0xD3E8211Al /* 0x0185EC */,
  0xEB04DFE0l /* 0x0185F0 */,
  0x40702CD0l /* 0x0185F4 */,
  0xDDF86010l /* 0x0185F8 */,
  0x415142D0l /* 0x0185FC */,
  0x6861EB04l /* 0x018600 */,
  0x41B0E8E0l /* 0x018604 */,
  0x01D04060l /* 0x018608 */,
  0x20602F05l /* 0x01860C */,
  0x58D0AD00l /* 0x018610 */,
  0x600012D0l /* 0x018614 */,
  0x0500C0D7l /* 0x018618 */,
  0x6470E105l /* 0x01861C */,
  0x07F96010l /* 0x018620 */,
  0x48702705l /* 0x018624 */,
  0x07F96110l /* 0x018628 */,
  0x6070AC05l /* 0x01862C */,
  0x07F96310l /* 0x018630 */,
  0xFAF8E111l /* 0x018634 */,
  0x600582D0l /* 0x018638 */,
  0x07E1B860l /* 0x01863C */,
  0x07F9E211l /* 0x018640 */,
  0x50702705l /* 0x018644 */,
  0x63107FB0l /* 0x018648 */,
  0x81D005E5l /* 0x01864C */,
  0xB8606005l /* 0x018650 */,
  0x270540D0l /* 0x018654 */,
  0xAD005060l /* 0x018658 */,
  0x12D050D0l /* 0x01865C */,
  0xC0D76000l /* 0x018660 */,
  0x090C0500l /* 0x018664 */,
  0x3F803684l /* 0x018668 */,
  0xCD0AF4AAl /* 0x01866C */,
  0xC507F4AAl /* 0x018670 */,
  0x5C702605l /* 0x018674 */,
  0x2CF96010l /* 0x018678 */,
  0x48702705l /* 0x01867C */,
  0x2CF96010l /* 0x018680 */,
  0x2CE9D103l /* 0x018684 */,
  0x7C702507l /* 0x018688 */,
  0x2CF96010l /* 0x01868C */,
  0x60702005l /* 0x018690 */,
  0x28E96010l /* 0x018694 */,
  0x2FE102D0l /* 0x018698 */,
  0x6470E105l /* 0x01869C */,
  0x2EF96010l /* 0x0186A0 */,
  0x2FE100D0l /* 0x0186A4 */,
  0xC50701D0l /* 0x0186A8 */,
  0x90D6AD00l /* 0x0186AC */,
  0x64702605l /* 0x0186B0 */,
  0x0AE86210l /* 0x0186B4 */,
  0x60702F05l /* 0x0186B8 */,
  0x0FF96010l /* 0x0186BC */,
  0x08732E05l /* 0x0186C0 */,
  0x4C732E05l /* 0x0186C4 */,
  0x38752D05l /* 0x0186C8 */,
  0x7C752D05l /* 0x0186CC */,
  0x1F170DC7l /* 0x0186D0 */,
  0xCD46C1D6l /* 0x0186D4 */,
  0xCC56CF16l /* 0x0186D8 */,
  0x72D72B00l /* 0x0186DC */,
  0x06004601l /* 0x0186E0 */,
  0x3DA7FCA6l /* 0x0186E4 */,
  0x5D673F80l /* 0x0186E8 */,
  0xC6000600l /* 0x0186EC */,
  0x3C782605l /* 0x0186F0 */,
  0x59F81100l /* 0x0186F4 */,
  0x44706205l /* 0x0186F8 */,
  0x59E86010l /* 0x0186FC */,
  0x6470E105l /* 0x018700 */,
  0x54F86010l /* 0x018704 */,
  0x4070EA04l /* 0x018708 */,
  0x36F86210l /* 0x01870C */,
  0x5070EB04l /* 0x018710 */,
  0x54E86110l /* 0x018714 */,
  0x3C782605l /* 0x018718 */,
  0x54F81900l /* 0x01871C */,
  0x43904601l /* 0x018720 */,
  0x3F808290l /* 0x018724 */,
  0xFF00C600l /* 0x018728 */,
  0x8040FFDFl /* 0x01872C */,
  0x7F40EF07l /* 0x018730 */,
  0x270501D0l /* 0x018734 */,
  0xEF072460l /* 0x018738 */,
  0x5C403FD7l /* 0x01873C */,
  0x54301C45l /* 0x018740 */,
  0xC0D62008l /* 0x018744 */,
  0x5C40C146l /* 0x018748 */,
  0x9B30D116l /* 0x01874C */,
  0x2DE79530l /* 0x018750 */,
  0x270500D0l /* 0x018754 */,
  0x62052460l /* 0x018758 */,
  0x27050460l /* 0x01875C */,
  0x20103870l /* 0x018760 */,
  0x64056CF8l /* 0x018764 */,
  0x64056870l /* 0x018768 */,
  0xEF0FB070l /* 0x01876C */,
  0xC230FFD0l /* 0x018770 */,
  0x42306CE8l /* 0x018774 */,
  0x26056CE8l /* 0x018778 */,
  0x15043C78l /* 0x01877C */,
  0x3C682605l /* 0x018780 */,
  0x2F054601l /* 0x018784 */,
  0x2F050874l /* 0x018788 */,
  0xE6054C74l /* 0x01878C */,
  0x06007870l /* 0x018790 */,
  0xFF00C600l /* 0x018794 */,
  0x4044FFDFl /* 0x018798 */,
  0x3FD0EF07l /* 0x01879C */,
  0x2F050044l /* 0x0187A0 */,
  0xC0D09070l /* 0x0187A4 */,
  0x41B0C220l /* 0x0187A8 */,
  0x2F057EF4l /* 0x0187AC */,
  0xCDC5E460l /* 0x0187B0 */,
  0x40D08CC5l /* 0x0187B4 */,
  0x3FD7EF07l /* 0x0187B8 */,
  0xDC409C45l /* 0x0187BC */,
  0x20088335l /* 0x0187C0 */,
  0xD646C0D6l /* 0x0187C4 */,
  0xD1169C45l /* 0x0187C8 */,
  0xC135DB35l /* 0x0187CC */,
  0xB4652E05l /* 0x0187D0 */,
  0xF8652E05l /* 0x0187D4 */,
  0xD8742F05l /* 0x0187D8 */,
  0xDC712F05l /* 0x0187DC */,
  0x90C051C0l /* 0x0187E0 */,
  0x3FD7EF07l /* 0x0187E4 */,
  0x9C459C40l /* 0x0187E8 */,
  0x20089630l /* 0x0187EC */,
  0xC246C0D6l /* 0x0187F0 */,
  0xD1169C40l /* 0x0187F4 */,
  0x57305B30l /* 0x0187F8 */,
  0x68602A05l /* 0x0187FC */,
  0xA4602A05l /* 0x018800 */,
  0xC7F46010l /* 0x018804 */,
  0x3FD7EF07l /* 0x018808 */,
  0x1C449C45l /* 0x01880C */,
  0x20089035l /* 0x018810 */,
  0xD646C0D6l /* 0x018814 */,
  0xD1169C45l /* 0x018818 */,
  0xD135DB35l /* 0x01881C */,
  0x3FD62700l /* 0x018820 */,
  0x0F161746l /* 0x018824 */,
  0x2E051656l /* 0x018828 */,
  0x47F13C66l /* 0x01882C */,
  0xDC712F05l /* 0x018830 */,
  0xEDFCD831l /* 0x018834 */,
  0x270007E1l /* 0x018838 */,
  0x01463FD6l /* 0x01883C */,
  0x02560F16l /* 0x018840 */,
  0x3C662E05l /* 0x018844 */,
  0x2F0547F1l /* 0x018848 */,
  0xD834D874l /* 0x01884C */,
  0x07E1D4FCl /* 0x018850 */,
  0x201015F1l /* 0x018854 */,
  0x27050FF9l /* 0x018858 */,
  0x20120872l /* 0x01885C */,
  0xAC05E3E8l /* 0x018860 */,
  0x63106070l /* 0x018864 */,
  0x41D0E3F8l /* 0x018868 */,
  0x78606005l /* 0x01886C */,
  0xAC050FE1l /* 0x018870 */,
  0x231A0C7Al /* 0x018874 */,
  0x2B000FF9l /* 0x018878 */,
  0x7FB06870l /* 0x01887C */,
  0x68602B00l /* 0x018880 */,
  0xEA0410E3l /* 0x018884 */,
  0x62104070l /* 0x018888 */,
  0xA205F9E8l /* 0x01888C */,
  0x23100C70l /* 0x018890 */,
  0x2705F9F8l /* 0x018894 */,
  0x23103470l /* 0x018898 */,
  0x15F10FE9l /* 0x01889C */,
  0x0FF92010l /* 0x0188A0 */,
  0x24E95003l /* 0x0188A4 */,
  0xA2804601l /* 0x0188A8 */,
  0x20102390l /* 0x0188AC */,
  0x2010C600l /* 0x0188B0 */,
  0x500B0FE5l /* 0x0188B4 */,
  0x64F124E1l /* 0x0188B8 */,
  0x3C782605l /* 0x0188BC */,
  0x20181208l /* 0x0188C0 */,
  0x26050FF9l /* 0x0188C4 */,
  0xAD003C68l /* 0x0188C8 */,
  0x12D058D0l /* 0x0188CC */,
  0xC0D76000l /* 0x0188D0 */,
  0x00D00500l /* 0x0188D4 */,
  0x7C702605l /* 0x0188D8 */,
  0x22F96010l /* 0x0188DC */,
  0x60702F05l /* 0x0188E0 */,
  0x22F96010l /* 0x0188E4 */,
  0x70702600l /* 0x0188E8 */,
  0x23F96010l /* 0x0188EC */,
  0xC50701D0l /* 0x0188F0 */,
  0x08722705l /* 0x0188F4 */,
  0x34E92012l /* 0x0188F8 */,
  0x2078A205l /* 0x0188FC */,
  0x30F91000l /* 0x018900 */,
  0x44702705l /* 0x018904 */,
  0x34F96110l /* 0x018908 */,
  0x600543D0l /* 0x01890C */,
  0x07E17860l /* 0x018910 */,
  0x2C706205l /* 0x018914 */,
  0x46F92010l /* 0x018918 */,
  0x620541D0l /* 0x01891C */,
  0x62054C60l /* 0x018920 */,
  0x26056C60l /* 0x018924 */,
  0x62106870l /* 0x018928 */,
  0x2B0046F9l /* 0x01892C */,
  0x7FB06C70l /* 0x018930 */,
  0x6C602B00l /* 0x018934 */,
  0x62052DE3l /* 0x018938 */,
  0x60104870l /* 0x01893C */,
  0x2F0563F9l /* 0x018940 */,
  0x18300070l /* 0x018944 */,
  0x260563EDl /* 0x018948 */,
  0x20183C78l /* 0x01894C */,
  0x120463F9l /* 0x018950 */,
  0x3C682605l /* 0x018954 */,
  0x6E0541D0l /* 0x018958 */,
  0x26007C60l /* 0x01895C */,
  0x44107870l /* 0x018960 */,
  0x58602F05l /* 0x018964 */,
  0x7C702600l /* 0x018968 */,
  0x2F054410l /* 0x01896C */,
  0xC5075C60l /* 0x018970 */,
  0x44702F05l /* 0x018974 */,
  0xD8C098C0l /* 0x018978 */,
  0xDF109F10l /* 0x01897C */,
  0x6DED8130l /* 0x018980 */,
  0x2F05C1C0l /* 0x018984 */,
  0x26005870l /* 0x018988 */,
  0x02C1B870l /* 0x01898C */,
  0x01314330l /* 0x018990 */,
  0x42C076E5l /* 0x018994 */,
  0x58602F05l /* 0x018998 */,
  0x5C702F05l /* 0x01899C */,
  0xB8702600l /* 0x0189A0 */,
  0x433002C1l /* 0x0189A4 */,
  0x81E50131l /* 0x0189A8 */,
  0x2F0542C0l /* 0x0189AC */,
  0xC5075C60l /* 0x0189B0 */,
  0x7CD02507l /* 0x0189B4 */,
  0x60104170l /* 0x0189B8 */,
  0xA20510E8l /* 0x0189BC */,
  0x007004D0l /* 0x0189C0 */,
  0x6CD02400l /* 0x0189C4 */,
  0x10EC4030l /* 0x0189C8 */,
  0x04D02D05l /* 0x0189CC */,
  0x406042D0l /* 0x0189D0 */,
  0x98D6AD00l /* 0x0189D4 */,
  0x0CDAAC05l /* 0x0189D8 */,
  0x2F05287Al /* 0x0189DC */,
  0x5D7760D7l /* 0x0189E0 */,
  0x640540D0l /* 0x0189E4 */,
  0x406000D0l /* 0x0189E8 */,
  0x1CD0E700l /* 0x0189EC */,
  0x20100070l /* 0x0189F0 */,
  0xE70583F8l /* 0x0189F4 */,
  0x007000D0l /* 0x0189F8 */,
  0x2DFB2010l /* 0x0189FC */,
  0x0C70A205l /* 0x018A00 */,
  0x3AF82310l /* 0x018A04 */,
  0x0070A205l /* 0x018A08 */,
  0x28302500l /* 0x018A0C */,
  0x26053AE4l /* 0x018A10 */,
  0x20101C70l /* 0x018A14 */,
  0x231A3AF8l /* 0x018A18 */,
  0xE80477E8l /* 0x018A1C */,
  0x417050D0l /* 0x018A20 */,
  0x77E86310l /* 0x018A24 */,
  0x04D02607l /* 0x018A28 */,
  0x8DC34073l /* 0x018A2C */,
  0x2070AC05l /* 0x018A30 */,
  0x53E82310l /* 0x018A34 */,
  0x08702705l /* 0x018A38 */,
  0x4AE82110l /* 0x018A3C */,
  0x2470ED04l /* 0x018A40 */,
  0x53F82110l /* 0x018A44 */,
  0x70D02300l /* 0x018A48 */,
  0x50E8D103l /* 0x018A4C */,
  0x5ED02400l /* 0x018A50 */,
  0x4230A9D0l /* 0x018A54 */,
  0x77B34123l /* 0x018A58 */,
  0xD40391F0l /* 0x018A5C */,
  0x2D052DEBl /* 0x018A60 */,
  0x407004D0l /* 0x018A64 */,
  0x61FC6010l /* 0x018A68 */,
  0x50D32300l /* 0x018A6C */,
  0x406041B0l /* 0x018A70 */,
  0x250768E0l /* 0x018A74 */,
  0x40703CD0l /* 0x018A78 */,
  0x68F86110l /* 0x018A7C */,
  0x50D32300l /* 0x018A80 */,
  0x00D06405l /* 0x018A84 */,
  0x46024063l /* 0x018A88 */,
  0x060218C8l /* 0x018A8C */,
  0x77EC0D38l /* 0x018A90 */,
  0x2070AC05l /* 0x018A94 */,
  0x2DFB2310l /* 0x018A98 */,
  0x6BE8A013l /* 0x018A9C */,
  0x26052DE3l /* 0x018AA0 */,
  0x407024D0l /* 0x018AA4 */,
  0x83F86210l /* 0x018AA8 */,
  0x603070D0l /* 0x018AAC */,
  0x620583ECl /* 0x018AB0 */,
  0x41D030D0l /* 0x018AB4 */,
  0x60174060l /* 0x018AB8 */,
  0xAD008BF8l /* 0x018ABC */,
  0x12D060D0l /* 0x018AC0 */,
  0xC0D76000l /* 0x018AC4 */,
  0x41D00500l /* 0x018AC8 */,
  0x4C606205l /* 0x018ACC */,
  0x6C606205l /* 0x018AD0 */,
  0x200510E3l /* 0x018AD4 */,
  0xA010AC70l /* 0x018AD8 */,
  0xAC05A7E8l /* 0x018ADC */,
  0x27050C7Al /* 0x018AE0 */,
  0x231A7470l /* 0x018AE4 */,
  0x63109EF8l /* 0x018AE8 */,
  0xA0E0A7F8l /* 0x018AEC */,
  0xA7E86310l /* 0x018AF0 */,
  0xA5F8A210l /* 0x018AF4 */,
  0x50D32000l /* 0x018AF8 */,
  0x2000A7E0l /* 0x018AFC */,
  0xC50760D3l /* 0x018B00 */,
  0xB8D6AD00l /* 0x018B04 */,
  0x1071EB04l /* 0x018B08 */,
  0x7CF82111l /* 0x018B0C */,
  0x0871ED04l /* 0x018B10 */,
  0x7CF82011l /* 0x018B14 */,
  0x23916280l /* 0x018B18 */,
  0x24001811l /* 0x018B1C */,
  0x443340D3l /* 0x018B20 */,
  0x20F12DEFl /* 0x018B24 */,
  0x39F12EF1l /* 0x018B28 */,
  0x29001D15l /* 0x018B2C */,
  0x40713CD0l /* 0x018B30 */,
  0x3C716205l /* 0x018B34 */,
  0x7CE80531l /* 0x018B38 */,
  0xE4F0F9F0l /* 0x018B3C */,
  0xC0D5C0D4l /* 0x018B40 */,
  0x2300C9F0l /* 0x018B44 */,
  0x8843BFD3l /* 0x018B48 */,
  0x581648C6l /* 0x018B4C */,
  0x07D188C7l /* 0x018B50 */,
  0x88C58447l /* 0x018B54 */,
  0x0FD19C15l /* 0x018B58 */,
  0x16C18445l /* 0x018B5C */,
  0x69050211l /* 0x018B60 */,
  0xC4712821l /* 0x018B64 */,
  0xD81107C3l /* 0x018B68 */,
  0x3FD12300l /* 0x018B6C */,
  0x08CA0443l /* 0x018B70 */,
  0x01D11D1Al /* 0x018B74 */,
  0xF1F0044Al /* 0x018B78 */,
  0x03D0C0D0l /* 0x018B7C */,
  0xDE130F40l /* 0x018B80 */,
  0x8FC4C213l /* 0x018B84 */,
  0xFFB3BEB4l /* 0x018B88 */,
  0xFEB38F72l /* 0x018B8C */,
  0x2010CF72l /* 0x018B90 */,
  0x21104FE8l /* 0x018B94 */,
  0x221055E8l /* 0x018B98 */,
  0x23105BE8l /* 0x018B9C */,
  0xAAF063E8l /* 0x018BA0 */,
  0xC302C810l /* 0x018BA4 */,
  0x41B683F0l /* 0x018BA8 */,
  0xAAF068E8l /* 0x018BAC */,
  0x83F0C302l /* 0x018BB0 */,
  0x68E841B6l /* 0x018BB4 */,
  0xAAF0FFB0l /* 0x018BB8 */,
  0x8302C810l /* 0x018BBC */,
  0x41B683F0l /* 0x018BC0 */,
  0xD81068E8l /* 0x018BC4 */,
  0xAAF0FFB0l /* 0x018BC8 */,
  0x83F08302l /* 0x018BCC */,
  0xFFB041B6l /* 0x018BD0 */,
  0x06004601l /* 0x018BD4 */,
  0xFDA2BCA2l /* 0x018BD8 */,
  0x92623F80l /* 0x018BDC */,
  0xC6000600l /* 0x018BE0 */,
  0xFEB3BCB4l /* 0x018BE4 */,
  0xFEB38F72l /* 0x018BE8 */,
  0x6016CF72l /* 0x018BEC */,
  0x4FE078E8l /* 0x018BF0 */,
  0x81B1FFB4l /* 0x018BF4 */,
  0x20E07CE8l /* 0x018BF8 */,
  0x70D0AD00l /* 0x018BFC */,
  0x600012D0l /* 0x018C00 */,
  0x0500C0D7l /* 0x018C04 */,
  0x17C1C507l /* 0x018C08 */,
  0x44C30C21l /* 0x018C0C */,
  0x89E44733l /* 0x018C10 */,
  0x02110731l /* 0x018C14 */,
  0x3C21A301l /* 0x018C18 */,
  0x57C30471l /* 0x018C1C */,
  0xA3014213l /* 0x018C20 */,
  0x4D737C23l /* 0x018C24 */,
  0x96E8201Al /* 0x018C28 */,
  0x98E00D21l /* 0x018C2C */,
  0x00010DC0l /* 0x018C30 */,
  0x7FD3EF0Fl /* 0x018C34 */,
  0x57C30D41l /* 0x018C38 */,
  0xA3014213l /* 0x018C3C */,
  0xA7017C23l /* 0x018C40 */,
  0x4D3A58DAl /* 0x018C44 */,
  0x0D61A4E4l /* 0x018C48 */,
  0x17C1FFB5l /* 0x018C4C */,
  0xA9E40731l /* 0x018C50 */,
  0xC507C0D5l /* 0x018C54 */,
  0x021117C1l /* 0x018C58 */,
  0x3C21A301l /* 0x018C5C */,
  0x00D0C470l /* 0x018C60 */,
  0xC0101E30l /* 0x018C64 */,
  0x3FD12300l /* 0x018C68 */,
  0xC507C440l /* 0x018C6C */,
  0x29007FB1l /* 0x018C70 */,
  0x45337473l /* 0x018C74 */,
  0x2900BDECl /* 0x018C78 */,
  0x7FB17071l /* 0x018C7C */,
  0x47B1C507l /* 0x018C80 */,
  0x70732900l /* 0x018C84 */,
  0xC7FC4533l /* 0x018C88 */,
  0x74712900l /* 0x018C8C */,
  0x7FB144B1l /* 0x018C90 */,
  0x1FC6C507l /* 0x018C94 */,
  0x7EB10572l /* 0x018C98 */,
  0xB6F04572l /* 0x018C9C */,
  0x620541B1l /* 0x018CA0 */,
  0x7FB17C61l /* 0x018CA4 */,
  0x011113C1l /* 0x018CA8 */,
  0xA0010211l /* 0x018CAC */,
  0x84701C21l /* 0x018CB0 */,
  0x13C14202l /* 0x018CB4 */,
  0x3FB10111l /* 0x018CB8 */,
  0xA0010211l /* 0x018CBC */,
  0x44701C21l /* 0x018CC0 */,
  0xD8C70102l /* 0x018CC4 */,
  0xC50700C0l /* 0x018CC8 */,
  0x3CD1A301l /* 0x018CCC */,
  0x5CD3A001l /* 0x018CD0 */,
  0x04600D70l /* 0x018CD4 */,
  0x7CB33CB1l /* 0x018CD8 */,
  0x18D0A701l /* 0x018CDC */,
  0xE8F80430l /* 0x018CE0 */,
  0xD4C3C507l /* 0x018CE4 */,
  0xC923DB23l /* 0x018CE8 */,
  0x1C310FC1l /* 0x018CEC */,
  0xDD33F8E4l /* 0x018CF0 */,
  0x1FC6C507l /* 0x018CF4 */,
  0x04746305l /* 0x018CF8 */,
  0x05707FB1l /* 0x018CFC */,
  0x7EB140C4l /* 0x018D00 */,
  0xBFF00571l /* 0x018D04 */,
  0x08111810l /* 0x018D08 */,
  0x10310051l /* 0x018D0C */,
  0x62050EE9l /* 0x018D10 */,
  0x41B13C70l /* 0x018D14 */,
  0x7CE80530l /* 0x018D18 */,
  0xFDE07FB1l /* 0x018D1C */,
  0x05717EB1l /* 0x018D20 */,
  0x2DD0EB0Fl /* 0x018D24 */,
  0x003142B1l /* 0x018D28 */,
  0x7EB1FDF8l /* 0x018D2C */,
  0x230091C1l /* 0x018D30 */,
  0x80413FD0l /* 0x018D34 */,
  0x7EB1B6F0l /* 0x018D38 */,
  0xD8C7B6F0l /* 0x018D3C */,
  0xC50700C0l /* 0x018D40 */,
  0x00706B05l /* 0x018D44 */,
  0x2DF92110l /* 0x018D48 */,
  0xF8DCAD00l /* 0x018D4C */,
  0x80DC6000l /* 0x018D50 */,
  0x12D02000l /* 0x018D54 */,
  0x48D0A700l /* 0x018D58 */,
  0xC5070500l /* 0x018D5C */,
  0xE3962281l /* 0x018D60 */,
  0xC416DE16l /* 0x018D64 */,
  0x23972280l /* 0x018D68 */,
  0x02171E17l /* 0x018D6C */,
  0x5B375CC7l /* 0x018D70 */,
  0x6800C507l /* 0x018D74 */,
  0x619300D1l /* 0x018D78 */,
  0x3BF94443l /* 0x018D7C */,
  0x23912283l /* 0x018D80 */,
  0x02111E11l /* 0x018D84 */,
  0x63932281l /* 0x018D88 */,
  0x44135E13l /* 0x018D8C */,
  0x45860D31l /* 0x018D90 */,
  0x46933FD4l /* 0x018D94 */,
  0x50435513l /* 0x018D98 */,
  0x42137EB3l /* 0x018D9C */,
  0x03110D31l /* 0x018DA0 */,
  0x0D945FD3l /* 0x018DA4 */,
  0x10210D44l /* 0x018DA8 */,
  0x543544C5l /* 0x018DAC */,
  0x228162F5l /* 0x018DB0 */,
  0x1E152395l /* 0x018DB4 */,
  0x22800415l /* 0x018DB8 */,
  0x1E142394l /* 0x018DBC */,
  0x14340214l /* 0x018DC0 */,
  0x50250314l /* 0x018DC4 */,
  0x201504C5l /* 0x018DC8 */,
  0x102566F5l /* 0x018DCC */,
  0x0000C507l /* 0x018DD0 */,
  0x6870EB04l /* 0x018DD4 */,
  0x68F86010l /* 0x018DD8 */,
  0x7071E804l /* 0x018DDC */,
  0x4C76A205l /* 0x018DE0 */,
  0xA0702D00l /* 0x018DE4 */,
  0x2C70E804l /* 0x018DE8 */,
  0x1CF82010l /* 0x018DEC */,
  0x1CE86316l /* 0x018DF0 */,
  0x2071E804l /* 0x018DF4 */,
  0x68E88430l /* 0x018DF8 */,
  0x00D9FE01l /* 0x018DFC */,
  0x740140C0l /* 0x018E00 */,
  0x80C000D6l /* 0x018E04 */,
  0x35E0C0C0l /* 0x018E08 */,
  0x2471E804l /* 0x018E0C */,
  0x2AF88430l /* 0x018E10 */,
  0x68E86011l /* 0x018E14 */,
  0x80702E00l /* 0x018E18 */,
  0x40702D00l /* 0x018E1C */,
  0x68018130l /* 0x018E20 */,
  0x68E88030l /* 0x018E24 */,
  0x00DE7702l /* 0x018E28 */,
  0xB50140C0l /* 0x018E2C */,
  0x80C000D4l /* 0x018E30 */,
  0x6111C0C0l /* 0x018E34 */,
  0x260535E8l /* 0x018E38 */,
  0x4601D870l /* 0x018E3C */,
  0x1588108Al /* 0x018E40 */,
  0x10D0C600l /* 0x018E44 */,
  0x0C60A407l /* 0x018E48 */,
  0xED0400D0l /* 0x018E4C */,
  0x01D03860l /* 0x018E50 */,
  0x30602707l /* 0x018E54 */,
  0x20612D00l /* 0x018E58 */,
  0x2061EB04l /* 0x018E5C */,
  0x2D000131l /* 0x018E60 */,
  0x63160061l /* 0x018E64 */,
  0xE80455E8l /* 0x018E68 */,
  0x20102C70l /* 0x018E6C */,
  0x013155F8l /* 0x018E70 */,
  0x00612E00l /* 0x018E74 */,
  0x08612605l /* 0x018E78 */,
  0xE80462E0l /* 0x018E7C */,
  0x2E006870l /* 0x018E80 */,
  0x61114060l /* 0x018E84 */,
  0x680160F8l /* 0x018E88 */,
  0x442040D0l /* 0x018E8C */,
  0x40602E00l /* 0x018E90 */,
  0x48602605l /* 0x018E94 */,
  0x98602707l /* 0x018E98 */,
  0x9C602707l /* 0x018E9C */,
  0xE0602707l /* 0x018EA0 */,
  0x0C7AAC05l /* 0x018EA4 */,
  0x607AAC05l /* 0x018EA8 */,
  0x40776005l /* 0x018EAC */,
  0x18746C05l /* 0x018EB0 */,
  0x40746505l /* 0x018EB4 */,
  0x84746505l /* 0x018EB8 */,
  0x2870EB04l /* 0x018EBC */,
  0xD3F92010l /* 0x018EC0 */,
  0x3070EF04l /* 0x018EC4 */,
  0x014041D0l /* 0x018EC8 */,
  0x82E82010l /* 0x018ECC */,
  0x3470EF04l /* 0x018ED0 */,
  0x89E82210l /* 0x018ED4 */,
  0x1070EB04l /* 0x018ED8 */,
  0x89E82210l /* 0x018EDC */,
  0x89E82310l /* 0x018EE0 */,
  0x6C05ADE0l /* 0x018EE4 */,
  0x6C05106Al /* 0x018EE8 */,
  0x2E05146Al /* 0x018EEC */,
  0x2E0508D0l /* 0x018EF0 */,
  0x407090D0l /* 0x018EF4 */,
  0x3CB04260l /* 0x018EF8 */,
  0x4070BCB0l /* 0x018EFC */,
  0x6D054260l /* 0x018F00 */,
  0x6D055C70l /* 0x018F04 */,
  0x61056060l /* 0x018F08 */,
  0x61054470l /* 0x018F0C */,
  0x2D004860l /* 0x018F10 */,
  0x2D004070l /* 0x018F14 */,
  0xE705A070l /* 0x018F18 */,
  0x110C0478l /* 0x018F1C */,
  0x02C0AAE8l /* 0x018F20 */,
  0x40C081C0l /* 0x018F24 */,
  0x8C602605l /* 0x018F28 */,
  0x5D576BE2l /* 0x018F2C */,
  0x231A5BE9l /* 0x018F30 */,
  0x6C05DDF8l /* 0x018F34 */,
  0x9503106Al /* 0x018F38 */,
  0x6405BDF8l /* 0x018F3C */,
  0x64057864l /* 0x018F40 */,
  0x4270B4D0l /* 0x018F44 */,
  0x70606405l /* 0x018F48 */,
  0x25078264l /* 0x018F4C */,
  0x61107C70l /* 0x018F50 */,
  0x631ACBE8l /* 0x018F54 */,
  0x2705CBF8l /* 0x018F58 */,
  0x63107470l /* 0x018F5C */,
  0x41D0CBF8l /* 0x018F60 */,
  0x7060A307l /* 0x018F64 */,
  0x26051F07l /* 0x018F68 */,
  0x26050873l /* 0x018F6C */,
  0x8CC30C63l /* 0x018F70 */,
  0x44702607l /* 0x018F74 */,
  0xD8F86010l /* 0x018F78 */,
  0x74706D05l /* 0x018F7C */,
  0xDAE86010l /* 0x018F80 */,
  0xDBE081D1l /* 0x018F84 */,
  0xEEF280D1l /* 0x018F88 */,
  0x631A5BE1l /* 0x018F8C */,
  0x2705E7F8l /* 0x018F90 */,
  0x63107470l /* 0x018F94 */,
  0x41D0E7E8l /* 0x018F98 */,
  0x7060A307l /* 0x018F9C */,
  0x6C051F07l /* 0x018FA0 */,
  0x407014D0l /* 0x018FA4 */,
  0x50606C05l /* 0x018FA8 */,
  0x9503006Al /* 0x018FAC */,
  0x6405FDF8l /* 0x018FB0 */,
  0x64057070l /* 0x018FB4 */,
  0x6405A870l /* 0x018FB8 */,
  0xE010DC70l /* 0x018FBC */,
  0xEF0FFDE8l /* 0x018FC0 */,
  0xC130FFD0l /* 0x018FC4 */,
  0x8130FDE8l /* 0x018FC8 */,
  0x260502F9l /* 0x018FCC */,
  0x00783CD0l /* 0x018FD0 */,
  0x00681508l /* 0x018FD4 */,
  0x14F99503l /* 0x018FD8 */,
  0xB4D06405l /* 0x018FDC */,
  0x6405C270l /* 0x018FE0 */,
  0x6405F060l /* 0x018FE4 */,
  0x407020D0l /* 0x018FE8 */,
  0x80644260l /* 0x018FEC */,
  0x24D06405l /* 0x018FF0 */,
  0x64054070l /* 0x018FF4 */,
  0x40647860l /* 0x018FF8 */,
  0x74706D05l /* 0x018FFC */,
  0x1AE96010l /* 0x019000 */,
  0x1BE181D1l /* 0x019004 */,
  0xEEF280D1l /* 0x019008 */,
  0xB8722505l /* 0x01900C */,
  0xFC722505l /* 0x019010 */,
  0xEF044AC3l /* 0x019014 */,
  0x22103470l /* 0x019018 */,
  0x26054DE9l /* 0x01901C */,
  0xA217A477l /* 0x019020 */,
  0x20024DE9l /* 0x019024 */,
  0x38A001D0l /* 0x019028 */,
  0x40702D00l /* 0x01902C */,
  0xA0702D00l /* 0x019030 */,
  0x0478E705l /* 0x019034 */,
  0x42E9110Cl /* 0x019038 */,
  0x45E9120Cl /* 0x01903C */,
  0x00702E00l /* 0x019040 */,
  0x42F9100Cl /* 0x019044 */,
  0x42C380C3l /* 0x019048 */,
  0xC1C28DC2l /* 0x01904C */,
  0x00D02002l /* 0x019050 */,
  0x4EE138A0l /* 0x019054 */,
  0x42C381C3l /* 0x019058 */,
  0x82C347E1l /* 0x01905C */,
  0x200241C3l /* 0x019060 */,
  0x38A000D0l /* 0x019064 */,
  0x8DC2CEC2l /* 0x019068 */,
  0x8BC34EE1l /* 0x01906C */,
  0x4C632605l /* 0x019070 */,
  0x60706005l /* 0x019074 */,
  0x64606005l /* 0x019078 */,
  0xBC622505l /* 0x01907C */,
  0xF8622505l /* 0x019080 */,
  0x8BC20AC0l /* 0x019084 */,
  0x2D00C0C2l /* 0x019088 */,
  0x407000D0l /* 0x01908C */,
  0x67E94D30l /* 0x019090 */,
  0x20D02D00l /* 0x019094 */,
  0x4D304070l /* 0x019098 */,
  0x2E0067E9l /* 0x01909C */,
  0x3AB000D0l /* 0x0190A0 */,
  0xBC702D05l /* 0x0190A4 */,
  0x9E10C2C0l /* 0x0190A8 */,
  0x434043D0l /* 0x0190AC */,
  0x2D054E10l /* 0x0190B0 */,
  0xDF10F870l /* 0x0190B4 */,
  0x46014350l /* 0x0190B8 */,
  0x7CA00600l /* 0x0190BC */,
  0x3F80BDA0l /* 0x0190C0 */,
  0x06000060l /* 0x0190C4 */,
  0x2605C600l /* 0x0190C8 */,
  0x2505CC73l /* 0x0190CC */,
  0x2505B872l /* 0x0190D0 */,
  0x221AFC72l /* 0x0190D4 */,
  0x600598F9l /* 0x0190D8 */,
  0x41504070l /* 0x0190DC */,
  0x26058CE9l /* 0x0190E0 */,
  0x26058462l /* 0x0190E4 */,
  0x9CE18062l /* 0x0190E8 */,
  0x93E9611Al /* 0x0190EC */,
  0xC0632605l /* 0x0190F0 */,
  0x84622605l /* 0x0190F4 */,
  0x26059CE1l /* 0x0190F8 */,
  0x26058062l /* 0x0190FC */,
  0x9CE1C463l /* 0x019100 */,
  0x80622605l /* 0x019104 */,
  0xC4622605l /* 0x019108 */,
  0xCEE96017l /* 0x01910C */,
  0x01D02002l /* 0x019110 */,
  0x610538A0l /* 0x019114 */,
  0x407020D0l /* 0x019118 */,
  0xA9E96010l /* 0x01911C */,
  0x406040D0l /* 0x019120 */,
  0x2B00BDE1l /* 0x019124 */,
  0x60106470l /* 0x019128 */,
  0xE705BDE9l /* 0x01912C */,
  0x2D008063l /* 0x019130 */,
  0x407000D0l /* 0x019134 */,
  0xBBE94E30l /* 0x019138 */,
  0x20D02D00l /* 0x01913C */,
  0x4E304070l /* 0x019140 */,
  0x2E00BBE9l /* 0x019144 */,
  0x2B0000D0l /* 0x019148 */,
  0x60051460l /* 0x01914C */,
  0xE6053877l /* 0x019150 */,
  0x2E053C67l /* 0x019154 */,
  0x2E0508D0l /* 0x019158 */,
  0x407090D0l /* 0x01915C */,
  0x3CB04260l /* 0x019160 */,
  0x4070BCB0l /* 0x019164 */,
  0x20024260l /* 0x019168 */,
  0x38A000D0l /* 0x01916C */,
  0x4C70AC05l /* 0x019170 */,
  0x74602705l /* 0x019174 */,
  0x6D0501E2l /* 0x019178 */,
  0x6D055C70l /* 0x01917C */,
  0x61056060l /* 0x019180 */,
  0x61054470l /* 0x019184 */,
  0xEB044860l /* 0x019188 */,
  0xE705A073l /* 0x01918C */,
  0xEB048063l /* 0x019190 */,
  0x26056473l /* 0x019194 */,
  0x2D004C63l /* 0x019198 */,
  0x407000D0l /* 0x01919C */,
  0xEFE94D30l /* 0x0191A0 */,
  0x20D02D00l /* 0x0191A4 */,
  0x4D304070l /* 0x0191A8 */,
  0x2E00EFE9l /* 0x0191AC */,
  0x2B0000D0l /* 0x0191B0 */,
  0xEC041460l /* 0x0191B4 */,
  0x21103870l /* 0x0191B8 */,
  0x2D0001FAl /* 0x0191BC */,
  0x007818D0l /* 0x0191C0 */,
  0x11041004l /* 0x0191C4 */,
  0x2D000068l /* 0x0191C8 */,
  0x007838D0l /* 0x0191CC */,
  0x11041004l /* 0x0191D0 */,
  0x2D000068l /* 0x0191D4 */,
  0x407000D0l /* 0x0191D8 */,
  0x0DEA4F30l /* 0x0191DC */,
  0x20D02D00l /* 0x0191E0 */,
  0x4F304070l /* 0x0191E4 */,
  0x2E000DEAl /* 0x0191E8 */,
  0x80C000D0l /* 0x0191EC */,
  0x58D02000l /* 0x0191F0 */,
  0x00780120l /* 0x0191F4 */,
  0x0348C3D0l /* 0x0191F8 */,
  0x03D1E9C0l /* 0x0191FC */,
  0xC210C440l /* 0x019200 */,
  0xAC050358l /* 0x019204 */,
  0x43C0E470l /* 0x019208 */,
  0x44400AD1l /* 0x01920C */,
  0x01D14310l /* 0x019210 */,
  0xC440D710l /* 0x019214 */,
  0xC150C510l /* 0x019218 */,
  0xA2050358l /* 0x01921C */,
  0xE010E870l /* 0x019220 */,
  0x17042AEAl /* 0x019224 */,
  0xC070AC05l /* 0x019228 */,
  0xC810C810l /* 0x01922C */,
  0xAC050358l /* 0x019230 */,
  0xC810CC70l /* 0x019234 */,
  0x00680358l /* 0x019238 */,
  0x200002C0l /* 0x01923C */,
  0x2A050C20l /* 0x019240 */,
  0x8060B070l /* 0x019244 */,
  0x27003AB0l /* 0x019248 */,
  0x60105870l /* 0x01924C */,
  0x270052EAl /* 0x019250 */,
  0x28005C70l /* 0x019254 */,
  0x424080D0l /* 0x019258 */,
  0x2B0548EAl /* 0x01925C */,
  0x59F240D0l /* 0x019260 */,
  0x5C702700l /* 0x019264 */,
  0x80D06000l /* 0x019268 */,
  0x52EA4240l /* 0x01926C */,
  0x2B053CB0l /* 0x019270 */,
  0x59F250D0l /* 0x019274 */,
  0x30D0ED04l /* 0x019278 */,
  0x2B053EB0l /* 0x01927C */,
  0x59F260D0l /* 0x019280 */,
  0x81706BE2l /* 0x019284 */,
  0x7CB08810l /* 0x019288 */,
  0x8350C170l /* 0x01928C */,
  0xC1707CB0l /* 0x019290 */,
  0x7CB0C810l /* 0x019294 */,
  0xC1504170l /* 0x019298 */,
  0xFCA04601l /* 0x01929C */,
  0x3F80BDA0l /* 0x0192A0 */,
  0xC600C060l /* 0x0192A4 */,
  0x6105C507l /* 0x0192A8 */,
  0x41D010D0l /* 0x0192AC */,
  0x8C70AC05l /* 0x0192B0 */,
  0x73FAA310l /* 0x0192B4 */,
  0x406043D0l /* 0x0192B8 */,
  0x270541D0l /* 0x0192BC */,
  0x41D06860l /* 0x0192C0 */,
  0x6460EF04l /* 0x0192C4 */,
  0xA4772605l /* 0x0192C8 */,
  0x87FAA217l /* 0x0192CC */,
  0x2B00560Bl /* 0x0192D0 */,
  0x60106470l /* 0x0192D4 */,
  0x01D086EAl /* 0x0192D8 */,
  0x3C60EE04l /* 0x0192DC */,
  0x560788E2l /* 0x0192E0 */,
  0x24D02B00l /* 0x0192E4 */,
  0x7FB04070l /* 0x0192E8 */,
  0x40D04060l /* 0x0192EC */,
  0x4C606205l /* 0x0192F0 */,
  0x34D06105l /* 0x0192F4 */,
  0x41B04070l /* 0x0192F8 */,
  0x40D096EEl /* 0x0192FC */,
  0x22004060l /* 0x019300 */,
  0x14002C78l /* 0x019304 */,
  0x9503ACFAl /* 0x019308 */,
  0x6405CBFAl /* 0x01930C */,
  0xEF0F7070l /* 0x019310 */,
  0x8130BFD0l /* 0x019314 */,
  0x6405ACEAl /* 0x019318 */,
  0x4230B470l /* 0x01931C */,
  0xE605ACEAl /* 0x019320 */,
  0x00781CD0l /* 0x019324 */,
  0x00681308l /* 0x019328 */,
  0x78706405l /* 0x01932C */,
  0xCBEA6010l /* 0x019330 */,
  0x46016CB0l /* 0x019334 */,
  0x62008170l /* 0x019338 */,
  0x0600A660l /* 0x01933C */,
  0x6200C600l /* 0x019340 */,
  0x7CB02C70l /* 0x019344 */,
  0x02308170l /* 0x019348 */,
  0x4601CBEAl /* 0x01934C */,
  0x2478E506l /* 0x019350 */,
  0xE5061104l /* 0x019354 */,
  0xE5062468l /* 0x019358 */,
  0x17041478l /* 0x01935C */,
  0x1468E506l /* 0x019360 */,
  0x6200C600l /* 0x019364 */,
  0xAD00AC60l /* 0x019368 */,
  0x270580D6l /* 0x01936C */,
  0xA800B066l /* 0x019370 */,
  0x600078DCl /* 0x019374 */,
  0x6B0500DCl /* 0x019378 */,
  0x20100070l /* 0x01937C */,
  0xAE00E0EAl /* 0x019380 */,
  0x6000C0DCl /* 0x019384 */,
  0x200080DCl /* 0x019388 */,
  0xA70012D0l /* 0x01938C */,
  0x050048D0l /* 0x019390 */,
  0xE8FA621Al /* 0x019394 */,
  0x78D0A800l /* 0x019398 */,
  0x600012D0l /* 0x01939C */,
  0x0500C0D7l /* 0x0193A0 */,
  0x40D0AE00l /* 0x0193A4 */,
  0x600012D0l /* 0x0193A8 */,
  0x0500C0D7l /* 0x0193AC */,
  0x70706205l /* 0x0193B0 */,
  0x0CFB6010l /* 0x0193B4 */,
  0xF9FAA011l /* 0x0193B8 */,
  0x9C706D05l /* 0x0193BC */,
  0xC4706105l /* 0x0193C0 */,
  0xA20506E3l /* 0x0193C4 */,
  0x23100C70l /* 0x0193C8 */,
  0x6D0502FBl /* 0x0193CC */,
  0x6E05BC70l /* 0x0193D0 */,
  0x06E3C470l /* 0x0193D4 */,
  0xB8706D05l /* 0x0193D8 */,
  0xC0706E05l /* 0x0193DC */,
  0xA0606D05l /* 0x0193E0 */,
  0xC8606105l /* 0x0193E4 */,
  0x0FFBA010l /* 0x0193E8 */,
  0xA30740D0l /* 0x0193EC */,
  0xC5076860l /* 0x0193F0 */,
  0x28D02705l /* 0x0193F4 */,
  0x406041D0l /* 0x0193F8 */,
  0x80D6AD00l /* 0x0193FC */,
  0x30D02705l /* 0x019400 */,
  0x6B058066l /* 0x019404 */,
  0x007000D0l /* 0x019408 */,
  0x27EB2010l /* 0x01940C */,
  0xF0DCA800l /* 0x019410 */,
  0x80DC6000l /* 0x019414 */,
  0x12D02000l /* 0x019418 */,
  0x48D0A700l /* 0x01941C */,
  0xA8000500l /* 0x019420 */,
  0x12D070D0l /* 0x019424 */,
  0xC0D76000l /* 0x019428 */,
  0x27050500l /* 0x01942C */,
  0x806630D0l /* 0x019430 */,
  0xA7000600l /* 0x019434 */,
  0x12D058D0l /* 0x019438 */,
  0xC5D76000l /* 0x01943C */,
  0x27050500l /* 0x019440 */,
  0x806630D0l /* 0x019444 */,
  0xA7000600l /* 0x019448 */,
  0x12D058D0l /* 0x01944C */,
  0xC0D76000l /* 0x019450 */,
  0x00000500l /* 0x019454 */,
  0xB0D6AD00l /* 0x019458 */,
  0x30D8A400l /* 0x01945C */,
  0x3F8036A8l /* 0x019460 */,
  0x1E003498l /* 0x019464 */,
  0x14002AE8l /* 0x019468 */,
  0x62802AE8l /* 0x01946C */,
  0xA3903F80l /* 0x019470 */,
  0x28003F80l /* 0x019474 */,
  0x407008D0l /* 0x019478 */,
  0x2AEC8130l /* 0x01947C */,
  0xE3064601l /* 0x019480 */,
  0x407008D0l /* 0x019484 */,
  0x14D0E306l /* 0x019488 */,
  0x14084060l /* 0x01948C */,
  0xC1D64602l /* 0x019490 */,
  0x24000602l /* 0x019494 */,
  0xB6A0B0D0l /* 0x019498 */,
  0x34A83F80l /* 0x01949C */,
  0x14D0E506l /* 0x0194A0 */,
  0x9A044078l /* 0x0194A4 */,
  0xC6004068l /* 0x0194A8 */,
  0x14D06A05l /* 0x0194AC */,
  0x6A050070l /* 0x0194B0 */,
  0x417050D0l /* 0x0194B4 */,
  0x2DEF0130l /* 0x0194B8 */,
  0x50D0AF00l /* 0x0194BC */,
  0x600012D0l /* 0x0194C0 */,
  0x0500C0D7l /* 0x0194C4 */,
  0x90D6AF00l /* 0x0194C8 */,
  0x00D03001l /* 0x0194CC */,
  0x650540CCl /* 0x0194D0 */,
  0x417144D0l /* 0x0194D4 */,
  0x2CD06405l /* 0x0194D8 */,
  0xA0118071l /* 0x0194DC */,
  0x601114E8l /* 0x0194E0 */,
  0x46C014E8l /* 0x0194E4 */,
  0x14E84530l /* 0x0194E8 */,
  0x6AF01DF0l /* 0x0194EC */,
  0x2CD06405l /* 0x0194F0 */,
  0xAD004061l /* 0x0194F4 */,
  0x12D048D0l /* 0x0194F8 */,
  0xC0D76000l /* 0x0194FC */,
  0x22000500l /* 0x019500 */,
  0x14002C78l /* 0x019504 */,
  0xE70069F8l /* 0x019508 */,
  0x407008D0l /* 0x01950C */,
  0x69E86010l /* 0x019510 */,
  0x24D0E105l /* 0x019514 */,
  0x60104070l /* 0x019518 */,
  0x280569F8l /* 0x01951C */,
  0x407010D0l /* 0x019520 */,
  0x69E86010l /* 0x019524 */,
  0x4601BCB1l /* 0x019528 */,
  0x06000672l /* 0x01952C */,
  0x3F80FD91l /* 0x019530 */,
  0xC111C600l /* 0x019534 */,
  0x00D02008l /* 0x019538 */,
  0x804088C0l /* 0x01953C */,
  0xC2519110l /* 0x019540 */,
  0x3FD0EF07l /* 0x019544 */,
  0x46010042l /* 0x019548 */,
  0x3F808392l /* 0x01954C */,
  0x3F804292l /* 0x019550 */,
  0xFF00C600l /* 0x019554 */,
  0x4042FFDFl /* 0x019558 */,
  0x3FD0EF07l /* 0x01955C */,
  0x80D08042l /* 0x019560 */,
  0x54D02601l /* 0x019564 */,
  0x3FD7EF07l /* 0x019568 */,
  0x5C401C42l /* 0x01956C */,
  0x20080132l /* 0x019570 */,
  0xC846C0D6l /* 0x019574 */,
  0xD1161C42l /* 0x019578 */,
  0xC231DB31l /* 0x01957C */,
  0x3FD7EF07l /* 0x019580 */,
  0x1C429C42l /* 0x019584 */,
  0x20088832l /* 0x019588 */,
  0xCA46C0D6l /* 0x01958C */,
  0xD1169C42l /* 0x019590 */,
  0x47325B32l /* 0x019594 */,
  0xC5072DE7l /* 0x019598 */,
  0x270541D0l /* 0x01959C */,
  0x40603CD0l /* 0x0195A0 */,
  0x0000C507l /* 0x0195A4 */,
  0x20084601l /* 0x0195A8 */,
  0x228401D0l /* 0x0195AC */,
  0x23A03F80l /* 0x0195B0 */,
  0xC6003F80l /* 0x0195B4 */,
  0x28706505l /* 0x0195B8 */,
  0x65053FB0l /* 0x0195BC */,
  0x68052860l /* 0x0195C0 */,
  0x68050470l /* 0x0195C4 */,
  0x02D00060l /* 0x0195C8 */,
  0x24606C05l /* 0x0195CC */,
  0x34706705l /* 0x0195D0 */,
  0x230040D0l /* 0x0195D4 */,
  0x4060BCD0l /* 0x0195D8 */,
  0x81B03CB0l /* 0x0195DC */,
  0x00D019F8l /* 0x0195E0 */,
  0x18606505l /* 0x0195E4 */,
  0x4C716505l /* 0x0195E8 */,
  0xF4716705l /* 0x0195EC */,
  0x65054761l /* 0x0195F0 */,
  0x01D0C861l /* 0x0195F4 */,
  0x04606905l /* 0x0195F8 */,
  0x460148F0l /* 0x0195FC */,
  0x00D02007l /* 0x019600 */,
  0x3F802284l /* 0x019604 */,
  0x3F8023A0l /* 0x019608 */,
  0xC6003F80l /* 0x01960C */,
  0xCD0A090Cl /* 0x019610 */,
  0x34F8E01Al /* 0x019614 */,
  0x20D0AF00l /* 0x019618 */,
  0x30602705l /* 0x01961C */,
  0x680501D0l /* 0x019620 */,
  0x00D02460l /* 0x019624 */,
  0x20606805l /* 0x019628 */,
  0x58D0A800l /* 0x01962C */,
  0x600012D0l /* 0x019630 */,
  0x0500C2D7l /* 0x019634 */,
  0x40D0A006l /* 0x019638 */,
  0x3F802284l /* 0x01963C */,
  0x3F8063A0l /* 0x019640 */,
  0x40D0E807l /* 0x019644 */,
  0xA1908601l /* 0x019648 */,
  0x81403F80l /* 0x01964C */,
  0x200350F8l /* 0x019650 */,
  0x4A1040D0l /* 0x019654 */,
  0x3F804AA0l /* 0x019658 */,
  0x3F800584l /* 0x01965C */,
  0x3F8046A0l /* 0x019660 */,
  0x45C04601l /* 0x019664 */,
  0x42105B10l /* 0x019668 */,
  0x60302000l /* 0x01966C */,
  0x6DE86DECl /* 0x019670 */,
  0x3F802280l /* 0x019674 */,
  0xDE10E390l /* 0x019678 */,
  0x4320C210l /* 0x01967C */,
  0x228172E0l /* 0x019680 */,
  0xDE10E390l /* 0x019684 */,
  0x4320C410l /* 0x019688 */,
  0x3F802283l /* 0x01968C */,
  0x3F8063A0l /* 0x019690 */,
  0xC6003F80l /* 0x019694 */,
  0x3F804586l /* 0x019698 */,
  0x3F800680l /* 0x01969C */,
  0x3F801780l /* 0x0196A0 */,
  0x0A800D80l /* 0x0196A4 */,
  0x05843F80l /* 0x0196A8 */,
  0x06803F80l /* 0x0196AC */,
  0xE4803F80l /* 0x0196B0 */,
  0x64803F80l /* 0x0196B4 */,
  0x46013F80l /* 0x0196B8 */,
  0xA3902281l /* 0x0196BC */,
  0x84109E10l /* 0x0196C0 */,
  0x3F802280l /* 0x0196C4 */,
  0xDE10E390l /* 0x0196C8 */,
  0xC230C210l /* 0x0196CC */,
  0x3F80E280l /* 0x0196D0 */,
  0x9E10A390l /* 0x0196D4 */,
  0x81308210l /* 0x0196D8 */,
  0x83209CF4l /* 0x0196DC */,
  0x40D02100l /* 0x0196E0 */,
  0x62808130l /* 0x0196E4 */,
  0xA3A03F80l /* 0x0196E8 */,
  0x3F802283l /* 0x0196EC */,
  0x5E106390l /* 0x0196F0 */,
  0xE2804210l /* 0x0196F4 */,
  0xA3903F80l /* 0x0196F8 */,
  0x82109E10l /* 0x0196FC */,
  0xAFF44230l /* 0x019700 */,
  0x20014320l /* 0x019704 */,
  0x423080D0l /* 0x019708 */,
  0x3F80A280l /* 0x01970C */,
  0xC60063A0l /* 0x019710 */,
  0xC1D0A004l /* 0x019714 */,
  0x3F802284l /* 0x019718 */,
  0x3F80E3A0l /* 0x01971C */,
  0x8D00C907l /* 0x019720 */,
  0x8D00C907l /* 0x019724 */,
  0x8D00C907l /* 0x019728 */,
  0x8D00C907l /* 0x01972C */,
  0x85409FD0l /* 0x019730 */,
  0xCEE8A010l /* 0x019734 */,
  0x86019D10l /* 0x019738 */,
  0xCD00090Al /* 0x01973C */,
  0xC9EC81B0l /* 0x019740 */,
  0x0000C507l /* 0x019744 */,
  0x6805B2F1l /* 0x019748 */,
  0x20102070l /* 0x01974C */,
  0x69050EE8l /* 0x019750 */,
  0x1F0C0078l /* 0x019754 */,
  0x650590F8l /* 0x019758 */,
  0x65059071l /* 0x01975C */,
  0x85614871l /* 0x019760 */,
  0x04706905l /* 0x019764 */,
  0x17E82010l /* 0x019768 */,
  0xC0636905l /* 0x01976C */,
  0x690500D0l /* 0x019770 */,
  0x65050460l /* 0x019774 */,
  0xAC054871l /* 0x019778 */,
  0x62146074l /* 0x01977C */,
  0xE1F027E8l /* 0x019780 */,
  0x18706505l /* 0x019784 */,
  0x65053FB0l /* 0x019788 */,
  0x20001860l /* 0x01978C */,
  0x100C24D8l /* 0x019790 */,
  0x090C8AE8l /* 0x019794 */,
  0xE011CD01l /* 0x019798 */,
  0xFDF045F8l /* 0x01979C */,
  0x0C706505l /* 0x0197A0 */,
  0x35F80630l /* 0x0197A4 */,
  0x20706805l /* 0x0197A8 */,
  0x52E82010l /* 0x0197AC */,
  0x856190E0l /* 0x0197B0 */,
  0x20D0AF00l /* 0x0197B4 */,
  0x30602705l /* 0x0197B8 */,
  0x48616505l /* 0x0197BC */,
  0x680500D0l /* 0x0197C0 */,
  0xA8002060l /* 0x0197C4 */,
  0x12D058D0l /* 0x0197C8 */,
  0xC2D76000l /* 0x0197CC */,
  0x62800500l /* 0x0197D0 */,
  0x63903F80l /* 0x0197D4 */,
  0x52FC6010l /* 0x0197D8 */,
  0x33D82200l /* 0x0197DC */,
  0x6CE8170Cl /* 0x0197E0 */,
  0x170C3CB8l /* 0x0197E4 */,
  0x27E08AE8l /* 0x0197E8 */,
  0x14706905l /* 0x0197EC */,
  0x69053FB0l /* 0x0197F0 */,
  0x02D01460l /* 0x0197F4 */,
  0x14606505l /* 0x0197F8 */,
  0x5CB15CB1l /* 0x0197FC */,
  0x70616805l /* 0x019800 */,
  0x18706505l /* 0x019804 */,
  0x650501B0l /* 0x019808 */,
  0x00D01860l /* 0x01980C */,
  0x08606805l /* 0x019810 */,
  0x0C606805l /* 0x019814 */,
  0x65058571l /* 0x019818 */,
  0x90E09061l /* 0x01981C */,
  0x2100FDF0l /* 0x019820 */,
  0x46C08031l /* 0x019824 */,
  0x65051BF1l /* 0x019828 */,
  0x5CB19061l /* 0x01982C */,
  0x70616805l /* 0x019830 */,
  0xCD01090Cl /* 0x019834 */,
  0x76F8E011l /* 0x019838 */,
  0x20D0AF00l /* 0x01983C */,
  0x30602705l /* 0x019840 */,
  0x680501D0l /* 0x019844 */,
  0x64B12060l /* 0x019848 */,
  0x48616505l /* 0x01984C */,
  0x58D0A800l /* 0x019850 */,
  0x600012D0l /* 0x019854 */,
  0x0500C2D7l /* 0x019858 */,
  0x6505FDF0l /* 0x01985C */,
  0x5CB19061l /* 0x019860 */,
  0x70616805l /* 0x019864 */,
  0x270500D0l /* 0x019868 */,
  0x65052860l /* 0x01986C */,
  0x68051C60l /* 0x019870 */,
  0x65052060l /* 0x019874 */,
  0x20102C70l /* 0x019878 */,
  0x00D0D0E8l /* 0x01987C */,
  0x2C606505l /* 0x019880 */,
  0x24606505l /* 0x019884 */,
  0x3C602505l /* 0x019888 */,
  0x38602505l /* 0x01988C */,
  0x18606905l /* 0x019890 */,
  0x1C606805l /* 0x019894 */,
  0x10606905l /* 0x019898 */,
  0x0C606905l /* 0x01989C */,
  0x08606805l /* 0x0198A0 */,
  0x0C606805l /* 0x0198A4 */,
  0x01D02002l /* 0x0198A8 */,
  0xE70538A0l /* 0x0198AC */,
  0x20180478l /* 0x0198B0 */,
  0x6705C0E8l /* 0x0198B4 */,
  0x017060D0l /* 0x0198B8 */,
  0xBEE8100Cl /* 0x0198BC */,
  0xB9E07CB0l /* 0x0198C0 */,
  0x016000D0l /* 0x0198C4 */,
  0x0078E705l /* 0x0198C8 */,
  0xCDE82018l /* 0x0198CC */,
  0x60D06705l /* 0x0198D0 */,
  0x100C0170l /* 0x0198D4 */,
  0x7CB0CBE8l /* 0x0198D8 */,
  0x00D0C6E0l /* 0x0198DC */,
  0x20020160l /* 0x0198E0 */,
  0x38A000D0l /* 0x0198E4 */,
  0x00706905l /* 0x0198E8 */,
  0x7C706805l /* 0x0198EC */,
  0xD8E82010l /* 0x0198F0 */,
  0x3C606805l /* 0x0198F4 */,
  0x690501D0l /* 0x0198F8 */,
  0xAF000860l /* 0x0198FC */,
  0x12D070D0l /* 0x019900 */,
  0xC0D76000l /* 0x019904 */,
  0xAC050500l /* 0x019908 */,
  0x7CB14070l /* 0x01990C */,
  0x7CB14560l /* 0x019910 */,
  0x4C70AC05l /* 0x019914 */,
  0x24706805l /* 0x019918 */,
  0xEFF82010l /* 0x01991C */,
  0xEFF86110l /* 0x019920 */,
  0x456042D0l /* 0x019924 */,
  0x680500D0l /* 0x019928 */,
  0x7CB12460l /* 0x01992C */,
  0x7CB17CB1l /* 0x019930 */,
  0x7CB14564l /* 0x019934 */,
  0x0870AC05l /* 0x019938 */,
  0x7CB10560l /* 0x01993C */,
  0x6800C507l /* 0x019940 */,
  0xA19040D0l /* 0x019944 */,
  0xFFF88140l /* 0x019948 */,
  0x63902283l /* 0x01994C */,
  0x42105E10l /* 0x019950 */,
  0xA3902281l /* 0x019954 */,
  0x84109E10l /* 0x019958 */,
  0x45864230l /* 0x01995C */,
  0x8690FFD0l /* 0x019960 */,
  0x83409510l /* 0x019964 */,
  0x8210BEB0l /* 0x019968 */,
  0x43104230l /* 0x01996C */,
  0xCD909FD0l /* 0x019970 */,
  0x4320C240l /* 0x019974 */,
  0x063001C0l /* 0x019978 */,
  0x228126F5l /* 0x01997C */,
  0x9E11A391l /* 0x019980 */,
  0x22808411l /* 0x019984 */,
  0xDE10E390l /* 0x019988 */,
  0xC630C210l /* 0x01998C */,
  0x0320C310l /* 0x019990 */,
  0xA01181C1l /* 0x019994 */,
  0x83212AF5l /* 0x019998 */,
  0xA006C507l /* 0x01999C */,
  0x228440D0l /* 0x0199A0 */,
  0x63A03F80l /* 0x0199A4 */,
  0xE8073F80l /* 0x0199A8 */,
  0x860140D0l /* 0x0199AC */,
  0x3F80A190l /* 0x0199B0 */,
  0x33F98140l /* 0x0199B4 */,
  0x40D02003l /* 0x0199B8 */,
  0x4AA04A10l /* 0x0199BC */,
  0x05843F80l /* 0x0199C0 */,
  0x46A03F80l /* 0x0199C4 */,
  0x46013F80l /* 0x0199C8 */,
  0x5B1046C0l /* 0x0199CC */,
  0x20004210l /* 0x0199D0 */,
  0x50ED6030l /* 0x0199D4 */,
  0x228050E9l /* 0x0199D8 */,
  0xE3903F80l /* 0x0199DC */,
  0xC210DE10l /* 0x0199E0 */,
  0x55E14320l /* 0x0199E4 */,
  0xE3902281l /* 0x0199E8 */,
  0xC410DE10l /* 0x0199EC */,
  0x22834320l /* 0x0199F0 */,
  0x63A03F80l /* 0x0199F4 */,
  0x3F803F80l /* 0x0199F8 */,
  0x4586C600l /* 0x0199FC */,
  0x06803F80l /* 0x019A00 */,
  0x17803F80l /* 0x019A04 */,
  0x0D803F80l /* 0x019A08 */,
  0x3F800A80l /* 0x019A0C */,
  0x3F800584l /* 0x019A10 */,
  0x3F800680l /* 0x019A14 */,
  0x3F80E480l /* 0x019A18 */,
  0x3F806480l /* 0x019A1C */,
  0x22814601l /* 0x019A20 */,
  0x9E10A390l /* 0x019A24 */,
  0x22808410l /* 0x019A28 */,
  0xE3903F80l /* 0x019A2C */,
  0xC210DE10l /* 0x019A30 */,
  0xE280C230l /* 0x019A34 */,
  0xA3903F80l /* 0x019A38 */,
  0x82109E10l /* 0x019A3C */,
  0x7FF58130l /* 0x019A40 */,
  0x21008320l /* 0x019A44 */,
  0x813040D0l /* 0x019A48 */,
  0x3F806280l /* 0x019A4C */,
  0x2283A3A0l /* 0x019A50 */,
  0x63903F80l /* 0x019A54 */,
  0x42105E10l /* 0x019A58 */,
  0x3F80E280l /* 0x019A5C */,
  0x9E10A390l /* 0x019A60 */,
  0x42308210l /* 0x019A64 */,
  0x432092F5l /* 0x019A68 */,
  0x80D02001l /* 0x019A6C */,
  0xA2804230l /* 0x019A70 */,
  0x63A03F80l /* 0x019A74 */,
  0xA004C600l /* 0x019A78 */,
  0x2284C1D0l /* 0x019A7C */,
  0xE3A03F80l /* 0x019A80 */,
  0xC9073F80l /* 0x019A84 */,
  0xC9078D00l /* 0x019A88 */,
  0xC9078D00l /* 0x019A8C */,
  0xC9078D00l /* 0x019A90 */,
  0x9FD08D00l /* 0x019A94 */,
  0xA0108640l /* 0x019A98 */,
  0x9D10B1E9l /* 0x019A9C */,
  0x090A8601l /* 0x019AA0 */,
  0x81B0CD00l /* 0x019AA4 */,
  0xC507ACEDl /* 0x019AA8 */,
  0x6405C0D3l /* 0x019AAC */,
  0x60105070l /* 0x019AB0 */,
  0x0C00B8F9l /* 0x019AB4 */,
  0xAC05E7E9l /* 0x019AB8 */,
  0xAC050472l /* 0x019ABC */,
  0xEF024872l /* 0x019AC0 */,
  0x48307FD0l /* 0x019AC4 */,
  0x89C0E7F9l /* 0x019AC8 */,
  0x7FD02300l /* 0x019ACC */,
  0xE80F4142l /* 0x019AD0 */,
  0x814040D0l /* 0x019AD4 */,
  0x42529F10l /* 0x019AD8 */,
  0x64054212l /* 0x019ADC */,
  0x49C07C62l /* 0x019AE0 */,
  0x4172C9C0l /* 0x019AE4 */,
  0x3FD0EF0Fl /* 0x019AE8 */,
  0x24004042l /* 0x019AEC */,
  0x425280D0l /* 0x019AF0 */,
  0x01727CB0l /* 0x019AF4 */,
  0x3FD0EF00l /* 0x019AF8 */,
  0x24020042l /* 0x019AFC */,
  0x025280D0l /* 0x019B00 */,
  0xC1737CB0l /* 0x019B04 */,
  0xC0636505l /* 0x019B08 */,
  0x65050F74l /* 0x019B0C */,
  0x40D00464l /* 0x019B10 */,
  0xC5074360l /* 0x019B14 */,
  0x7CD36F00l /* 0x019B18 */,
  0x8D594601l /* 0x019B1C */,
  0x24008D39l /* 0x019B20 */,
  0x8D5954D3l /* 0x019B24 */,
  0xC507C600l /* 0x019B28 */,
  0x4C712605l /* 0x019B2C */,
  0x690500D0l /* 0x019B30 */,
  0xAF000860l /* 0x019B34 */,
  0x270530D0l /* 0x019B38 */,
  0x66053060l /* 0x019B3C */,
  0xAC052870l /* 0x019B40 */,
  0x80C04C70l /* 0x019B44 */,
  0x11E80130l /* 0x019B48 */,
  0x660526E0l /* 0x019B4C */,
  0xAC052C70l /* 0x019B50 */,
  0x80C06070l /* 0x019B54 */,
  0x19E80130l /* 0x019B58 */,
  0x660526E0l /* 0x019B5C */,
  0xAC052470l /* 0x019B60 */,
  0x80C04070l /* 0x019B64 */,
  0x2CE80130l /* 0x019B68 */,
  0x310026E0l /* 0x019B6C */,
  0x02107ADEl /* 0x019B70 */,
  0xCC033FB0l /* 0x019B74 */,
  0x70D0AF00l /* 0x019B78 */,
  0x600012D0l /* 0x019B7C */,
  0x0500C0D7l /* 0x019B80 */,
  0x78D0A800l /* 0x019B84 */,
  0x600012D0l /* 0x019B88 */,
  0x0500C0D7l /* 0x019B8C */,
  0x01D02002l /* 0x019B90 */,
  0xE70538A0l /* 0x019B94 */,
  0x20100070l /* 0x019B98 */,
  0x66051DF8l /* 0x019B9C */,
  0x80723070l /* 0x019BA0 */,
  0x1DE8A012l /* 0x019BA4 */,
  0x8062E705l /* 0x019BA8 */,
  0x406040D0l /* 0x019BAC */,
  0x40703CB0l /* 0x019BB0 */,
  0xE6053CB0l /* 0x019BB4 */,
  0x67057C60l /* 0x019BB8 */,
  0x100C20D8l /* 0x019BBC */,
  0x66051BF8l /* 0x019BC0 */,
  0x660538D0l /* 0x019BC4 */,
  0x68053060l /* 0x019BC8 */,
  0x3FB02870l /* 0x019BCC */,
  0x28606805l /* 0x019BD0 */,
  0x08706905l /* 0x019BD4 */,
  0x52F82010l /* 0x019BD8 */,
  0x14706605l /* 0x019BDC */,
  0x66053FB0l /* 0x019BE0 */,
  0x26051460l /* 0x019BE4 */,
  0x67058C72l /* 0x019BE8 */,
  0xB4B1B471l /* 0x019BEC */,
  0x680541D2l /* 0x019BF0 */,
  0x0A301470l /* 0x019BF4 */,
  0x00D039F8l /* 0x019BF8 */,
  0x14606805l /* 0x019BFC */,
  0x067852E0l /* 0x019C00 */,
  0x43E81A0Cl /* 0x019C04 */,
  0x6805A4B1l /* 0x019C08 */,
  0x160C3078l /* 0x019C0C */,
  0x7FB252E4l /* 0x019C10 */,
  0xB1F239E0l /* 0x019C14 */,
  0xF1E96112l /* 0x019C18 */,
  0x9CB18CB1l /* 0x019C1C */,
  0xB0616805l /* 0x019C20 */,
  0x650541B2l /* 0x019C24 */,
  0x00D85862l /* 0x019C28 */,
  0x08686805l /* 0x019C2C */,
  0x0C686805l /* 0x019C30 */,
  0x58706605l /* 0x019C34 */,
  0x65E86010l /* 0x019C38 */,
  0x02D582D4l /* 0x019C3C */,
  0x660500D0l /* 0x019C40 */,
  0x66051860l /* 0x019C44 */,
  0xA1119C71l /* 0x019C48 */,
  0xC3D361F8l /* 0x019C4C */,
  0xC6C3B7E1l /* 0x019C50 */,
  0xCF73F8B3l /* 0x019C54 */,
  0x6905B7E1l /* 0x019C58 */,
  0x20101070l /* 0x019C5C */,
  0x690570F8l /* 0x019C60 */,
  0xA0128C72l /* 0x019C64 */,
  0x08F270E8l /* 0x019C68 */,
  0x10606905l /* 0x019C6C */,
  0x58716505l /* 0x019C70 */,
  0x680541B1l /* 0x019C74 */,
  0xB4B1B071l /* 0x019C78 */,
  0x00D340D3l /* 0x019C7C */,
  0x00D2C0D1l /* 0x019C80 */,
  0x601180D3l /* 0x019C84 */,
  0x84B1EBE4l /* 0x019C88 */,
  0xB4B10671l /* 0x019C8C */,
  0x88B18674l /* 0x019C90 */,
  0xE011C671l /* 0x019C94 */,
  0x23119FF8l /* 0x019C98 */,
  0x680594F8l /* 0x019C9C */,
  0x20180078l /* 0x019CA0 */,
  0x2013E4E8l /* 0x019CA4 */,
  0x88B1E4F8l /* 0x019CA8 */,
  0xB8B10678l /* 0x019CAC */,
  0xE4E42218l /* 0x019CB0 */,
  0x9BE082D3l /* 0x019CB4 */,
  0x9BE82013l /* 0x019CB8 */,
  0x02D080D3l /* 0x019CBC */,
  0x0660BCB1l /* 0x019CC0 */,
  0xC4C384B1l /* 0x019CC4 */,
  0x06C312C5l /* 0x019CC8 */,
  0x2013E4E0l /* 0x019CCC */,
  0xA013A3E8l /* 0x019CD0 */,
  0xBCB1EBE8l /* 0x019CD4 */,
  0x84B10670l /* 0x019CD8 */,
  0xDCE82110l /* 0x019CDC */,
  0xDCE82311l /* 0x019CE0 */,
  0xDCE8A113l /* 0x019CE4 */,
  0x0C706805l /* 0x019CE8 */,
  0xB6E82010l /* 0x019CEC */,
  0x680500D0l /* 0x019CF0 */,
  0x66050C60l /* 0x019CF4 */,
  0xBFE0CC74l /* 0x019CF8 */,
  0x08706805l /* 0x019CFC */,
  0xC5E82010l /* 0x019D00 */,
  0x680500D0l /* 0x019D04 */,
  0x66050860l /* 0x019D08 */,
  0x6905C874l /* 0x019D0C */,
  0x41D30C72l /* 0x019D10 */,
  0xC3D301D3l /* 0x019D14 */,
  0x01D0EBE0l /* 0x019D18 */,
  0x0660BCB1l /* 0x019D1C */,
  0x00D084B1l /* 0x019D20 */,
  0x18606805l /* 0x019D24 */,
  0x00786805l /* 0x019D28 */,
  0xD6E82018l /* 0x019D2C */,
  0x211119F2l /* 0x019D30 */,
  0x4670D6F8l /* 0x019D34 */,
  0x4C606905l /* 0x019D38 */,
  0xFAF14670l /* 0x019D3C */,
  0x00786805l /* 0x019D40 */,
  0x70F82018l /* 0x019D44 */,
  0xE4E8A013l /* 0x019D48 */,
  0xE7E8A113l /* 0x019D4C */,
  0x69050672l /* 0x019D50 */,
  0x81B30C62l /* 0x019D54 */,
  0x9CB141B1l /* 0x019D58 */,
  0x04D07BE0l /* 0x019D5C */,
  0x0660BCB1l /* 0x019D60 */,
  0x201384B1l /* 0x019D64 */,
  0x8CC1F1E9l /* 0x019D68 */,
  0x60D26705l /* 0x019D6C */,
  0xA0128972l /* 0x019D70 */,
  0x670547F9l /* 0x019D74 */,
  0x190C30D8l /* 0x019D78 */,
  0x7CB2F9E8l /* 0x019D7C */,
  0x6805F0E0l /* 0x019D80 */,
  0x20180078l /* 0x019D84 */,
  0xE31316E9l /* 0x019D88 */,
  0x680516F9l /* 0x019D8C */,
  0xA0129472l /* 0x019D90 */,
  0x680516E9l /* 0x019D94 */,
  0x21101870l /* 0x019D98 */,
  0x61130FE5l /* 0x019D9C */,
  0xE70516E9l /* 0x019DA0 */,
  0x4A304470l /* 0x019DA4 */,
  0xD40335F9l /* 0x019DA8 */,
  0x00D035E9l /* 0x019DAC */,
  0x14606805l /* 0x019DB0 */,
  0x690541D0l /* 0x019DB4 */,
  0x49E15860l /* 0x019DB8 */,
  0x58716505l /* 0x019DBC */,
  0x670541B1l /* 0x019DC0 */,
  0x34B03470l /* 0x019DC4 */,
  0x35E96011l /* 0x019DC8 */,
  0xA0128072l /* 0x019DCC */,
  0x3CB032E9l /* 0x019DD0 */,
  0x04B04070l /* 0x019DD4 */,
  0x35E96210l /* 0x019DD8 */,
  0x35E96410l /* 0x019DDC */,
  0x35E96110l /* 0x019DE0 */,
  0x406040D0l /* 0x019DE4 */,
  0x34706805l /* 0x019DE8 */,
  0x68053FB0l /* 0x019DEC */,
  0x49E13460l /* 0x019DF0 */,
  0x41B124B0l /* 0x019DF4 */,
  0xAF001CE1l /* 0x019DF8 */,
  0x270530D0l /* 0x019DFC */,
  0x68053060l /* 0x019E00 */,
  0x3FB03870l /* 0x019E04 */,
  0x38606805l /* 0x019E08 */,
  0x00D02002l /* 0x019E0C */,
  0xA10038A0l /* 0x019E10 */,
  0x12D048D0l /* 0x019E14 */,
  0xC0D76000l /* 0x019E18 */,
  0x00D00500l /* 0x019E1C */,
  0x26050960l /* 0x019E20 */,
  0x60138C62l /* 0x019E24 */,
  0x866261F9l /* 0x019E28 */,
  0x5EE9E113l /* 0x019E2C */,
  0x5EF9A013l /* 0x019E30 */,
  0x1CB006C0l /* 0x019E34 */,
  0x74706705l /* 0x019E38 */,
  0xF1ED4030l /* 0x019E3C */,
  0x60104070l /* 0x019E40 */,
  0x3CB053E9l /* 0x019E44 */,
  0x806080D0l /* 0x019E48 */,
  0x61E9E313l /* 0x019E4C */,
  0x231507C2l /* 0x019E50 */,
  0xE21371E9l /* 0x019E54 */,
  0x221571F9l /* 0x019E58 */,
  0x26056CE9l /* 0x019E5C */,
  0x2605C461l /* 0x019E60 */,
  0x75E1C061l /* 0x019E64 */,
  0x80622605l /* 0x019E68 */,
  0xC4612605l /* 0x019E6C */,
  0x260575E1l /* 0x019E70 */,
  0x2605C061l /* 0x019E74 */,
  0xAC050462l /* 0x019E78 */,
  0x2D00CC63l /* 0x019E7C */,
  0x407000D0l /* 0x019E80 */,
  0x83E94A30l /* 0x019E84 */,
  0x20D02D00l /* 0x019E88 */,
  0x4A304070l /* 0x019E8C */,
  0x2E0083E9l /* 0x019E90 */,
  0x2B0000D0l /* 0x019E94 */,
  0xE3131460l /* 0x019E98 */,
  0x6C05A8F9l /* 0x019E9C */,
  0x6805D063l /* 0x019EA0 */,
  0x3FB01870l /* 0x019EA4 */,
  0x18606805l /* 0x019EA8 */,
  0x94F92315l /* 0x019EAC */,
  0xA30741D0l /* 0x019EB0 */,
  0x1F077060l /* 0x019EB4 */,
  0x9FF96013l /* 0x019EB8 */,
  0xBCB101D0l /* 0x019EBC */,
  0x84B10660l /* 0x019EC0 */,
  0x69054670l /* 0x019EC4 */,
  0x20101870l /* 0x019EC8 */,
  0x4AC0A4F9l /* 0x019ECC */,
  0x4C602605l /* 0x019ED0 */,
  0x54606805l /* 0x019ED4 */,
  0x690500D0l /* 0x019ED8 */,
  0xFAF11860l /* 0x019EDC */,
  0xADE96013l /* 0x019EE0 */,
  0x81D1D3C2l /* 0x019EE4 */,
  0x8CB1AFE1l /* 0x019EE8 */,
  0x2AF2C672l /* 0x019EEC */,
  0xB7F92115l /* 0x019EF0 */,
  0x660501D0l /* 0x019EF4 */,
  0x66051860l /* 0x019EF8 */,
  0x22159C61l /* 0x019EFC */,
  0xE313C1F9l /* 0x019F00 */,
  0x86C2C8E9l /* 0x019F04 */,
  0x8A72B4B2l /* 0x019F08 */,
  0x80622605l /* 0x019F0C */,
  0x090CC8E1l /* 0x019F10 */,
  0xE01ACD0Al /* 0x019F14 */,
  0xE81AC8E9l /* 0x019F18 */,
  0x26E0C1EDl /* 0x019F1C */,
  0x28D0AF00l /* 0x019F20 */,
  0x30602705l /* 0x019F24 */,
  0xD5E9E313l /* 0x019F28 */,
  0x00786805l /* 0x019F2C */,
  0xD5E92018l /* 0x019F30 */,
  0x680540D0l /* 0x019F34 */,
  0x20025460l /* 0x019F38 */,
  0x38A000D0l /* 0x019F3C */,
  0xA0616605l /* 0x019F40 */,
  0xE8636605l /* 0x019F44 */,
  0x2C656605l /* 0x019F48 */,
  0x660500D0l /* 0x019F4C */,
  0x53304C70l /* 0x019F50 */,
  0x01D0E4F9l /* 0x019F54 */,
  0xE9E9A111l /* 0x019F58 */,
  0x3CB006C0l /* 0x019F5C */,
  0x66050070l /* 0x019F60 */,
  0xA8002460l /* 0x019F64 */,
  0x12D040D0l /* 0x019F68 */,
  0xDFD76900l /* 0x019F6C */,
  0x20020500l /* 0x019F70 */,
  0x38A000D0l /* 0x019F74 */,
  0x78D0AF00l /* 0x019F78 */,
  0x600012D0l /* 0x019F7C */,
  0x0500C0D7l /* 0x019F80 */,
  0x34706605l /* 0x019F84 */,
  0x67054060l /* 0x019F88 */,
  0x100C18D8l /* 0x019F8C */,
  0x660504FAl /* 0x019F90 */,
  0x05E238D0l /* 0x019F94 */,
  0x660538B0l /* 0x019F98 */,
  0xC5073460l /* 0x019F9C */,
  0x60D06705l /* 0x019FA0 */,
  0x8AC00170l /* 0x019FA4 */,
  0x11FA8030l /* 0x019FA8 */,
  0x01D08160l /* 0x019FAC */,
  0x6705C507l /* 0x019FB0 */,
  0x110C30D8l /* 0x019FB4 */,
  0x7CB017EAl /* 0x019FB8 */,
  0x00D00AE2l /* 0x019FBC */,
  0x1FC4C507l /* 0x019FC0 */,
  0x0C706905l /* 0x019FC4 */,
  0x29EA2010l /* 0x019FC8 */,
  0x50706905l /* 0x019FCC */,
  0x29EA6010l /* 0x019FD0 */,
  0x690540D0l /* 0x019FD4 */,
  0x69055060l /* 0x019FD8 */,
  0x80C24C60l /* 0x019FDC */,
  0x0504B1F2l /* 0x019FE0 */,
  0x40D0A006l /* 0x019FE4 */,
  0x3F802284l /* 0x019FE8 */,
  0x3F8063A0l /* 0x019FEC */,
  0x40D0E807l /* 0x019FF0 */,
  0xA1908601l /* 0x019FF4 */,
  0x81403F80l /* 0x019FF8 */,
  0x200332FAl /* 0x019FFC */,
  0x4A1040D0l /* 0x01A000 */,
  0x3F804AA0l /* 0x01A004 */,
  0x3F800584l /* 0x01A008 */,
  0x3F8046A0l /* 0x01A00C */,
  0x4BC04601l /* 0x01A010 */,
  0x42105B10l /* 0x01A014 */,
  0x60302000l /* 0x01A018 */,
  0x4FEA4FEEl /* 0x01A01C */,
  0x3F802280l /* 0x01A020 */,
  0xDE10E390l /* 0x01A024 */,
  0x4320C210l /* 0x01A028 */,
  0x228154E2l /* 0x01A02C */,
  0xDE10E390l /* 0x01A030 */,
  0x4320C410l /* 0x01A034 */,
  0x3F802283l /* 0x01A038 */,
  0x3F8063A0l /* 0x01A03C */,
  0xC6003F80l /* 0x01A040 */,
  0x3F804586l /* 0x01A044 */,
  0x3F800680l /* 0x01A048 */,
  0x3F801780l /* 0x01A04C */,
  0x0A800D80l /* 0x01A050 */,
  0x05843F80l /* 0x01A054 */,
  0x06803F80l /* 0x01A058 */,
  0xE4803F80l /* 0x01A05C */,
  0x64803F80l /* 0x01A060 */,
  0x46013F80l /* 0x01A064 */,
  0xA3902281l /* 0x01A068 */,
  0x84109E10l /* 0x01A06C */,
  0x3F802280l /* 0x01A070 */,
  0xDE10E390l /* 0x01A074 */,
  0xC230C210l /* 0x01A078 */,
  0x3F80E280l /* 0x01A07C */,
  0x9E10A390l /* 0x01A080 */,
  0x81308210l /* 0x01A084 */,
  0x83207EF6l /* 0x01A088 */,
  0x40D02100l /* 0x01A08C */,
  0x62808130l /* 0x01A090 */,
  0xA3A03F80l /* 0x01A094 */,
  0x3F802283l /* 0x01A098 */,
  0x5E106390l /* 0x01A09C */,
  0xE2804210l /* 0x01A0A0 */,
  0xA3903F80l /* 0x01A0A4 */,
  0x82109E10l /* 0x01A0A8 */,
  0x91F64230l /* 0x01A0AC */,
  0x20014320l /* 0x01A0B0 */,
  0x423080D0l /* 0x01A0B4 */,
  0x3F80A280l /* 0x01A0B8 */,
  0xC60063A0l /* 0x01A0BC */,
  0xC1D0A004l /* 0x01A0C0 */,
  0x3F802284l /* 0x01A0C4 */,
  0x3F80E3A0l /* 0x01A0C8 */,
  0x8D00C907l /* 0x01A0CC */,
  0x8D00C907l /* 0x01A0D0 */,
  0x8D00C907l /* 0x01A0D4 */,
  0x8D00C907l /* 0x01A0D8 */,
  0x8B409FD0l /* 0x01A0DC */,
  0xB0EAA010l /* 0x01A0E0 */,
  0x86019D10l /* 0x01A0E4 */,
  0xCD00090Al /* 0x01A0E8 */,
  0xABEE81B0l /* 0x01A0EC */,
  0xA012C507l /* 0x01A0F0 */,
  0x6705C2EAl /* 0x01A0F4 */,
  0x670530D8l /* 0x01A0F8 */,
  0x017060D0l /* 0x01A0FC */,
  0xC1EA2010l /* 0x01A100 */,
  0x80308AC0l /* 0x01A104 */,
  0x110CC2EAl /* 0x01A108 */,
  0x7CB0C2EAl /* 0x01A10C */,
  0x8162B7E2l /* 0x01A110 */,
  0x6F00C507l /* 0x01A114 */,
  0x46013CD0l /* 0x01A118 */,
  0x80398059l /* 0x01A11C */,
  0x14D02400l /* 0x01A120 */,
  0xC6008059l /* 0x01A124 */,
  0x0000C507l /* 0x01A128 */,
  0x50716505l /* 0x01A12C */,
  0x680500D0l /* 0x01A130 */,
  0x68050860l /* 0x01A134 */,
  0x65050C60l /* 0x01A138 */,
  0x60155475l /* 0x01A13C */,
  0x680591F8l /* 0x01A140 */,
  0x20100070l /* 0x01A144 */,
  0x670591E8l /* 0x01A148 */,
  0x64B37473l /* 0x01A14C */,
  0x0D7078B3l /* 0x01A150 */,
  0x231048B3l /* 0x01A154 */,
  0x4D7291F8l /* 0x01A158 */,
  0x680501D0l /* 0x01A15C */,
  0x64B30860l /* 0x01A160 */,
  0x0D7078B3l /* 0x01A164 */,
  0x231048B3l /* 0x01A168 */,
  0x4D7091F8l /* 0x01A16C */,
  0x01D08D72l /* 0x01A170 */,
  0x0C606805l /* 0x01A174 */,
  0xCD7264B3l /* 0x01A178 */,
  0x8AC449C4l /* 0x01A17C */,
  0xE3952281l /* 0x01A180 */,
  0xC415DE15l /* 0x01A184 */,
  0xA3982280l /* 0x01A188 */,
  0x82189E18l /* 0x01A18C */,
  0x173622C6l /* 0x01A190 */,
  0x45C00316l /* 0x01A194 */,
  0x3AEC4B30l /* 0x01A198 */,
  0x58208CE8l /* 0x01A19C */,
  0x58344124l /* 0x01A1A0 */,
  0x58243EF4l /* 0x01A1A4 */,
  0x98348124l /* 0x01A1A8 */,
  0x982442F4l /* 0x01A1AC */,
  0x200089C3l /* 0x01A1B0 */,
  0x47F4A033l /* 0x01A1B4 */,
  0x9B139823l /* 0x01A1B8 */,
  0x97238213l /* 0x01A1BC */,
  0x61B84BC8l /* 0x01A1C0 */,
  0x42185B18l /* 0x01A1C4 */,
  0xD1C35728l /* 0x01A1C8 */,
  0xE0332000l /* 0x01A1CC */,
  0xD82354F4l /* 0x01A1D0 */,
  0xC213DB13l /* 0x01A1D4 */,
  0xC1D0D723l /* 0x01A1D8 */,
  0x8CE89E0Cl /* 0x01A1DC */,
  0xC0D05CECl /* 0x01A1E0 */,
  0xC0D82400l /* 0x01A1E4 */,
  0x66E8E010l /* 0x01A1E8 */,
  0x0E3021C0l /* 0x01A1EC */,
  0x900D8CE8l /* 0x01A1F0 */,
  0xC0C866FCl /* 0x01A1F4 */,
  0x0E3022C0l /* 0x01A1F8 */,
  0x6BFC900Dl /* 0x01A1FC */,
  0x22C0C0C8l /* 0x01A200 */,
  0x900D0F30l /* 0x01A204 */,
  0xC0C870FCl /* 0x01A208 */,
  0x4601C4B8l /* 0x01A20C */,
  0x2ED06500l /* 0x01A210 */,
  0xCA0836A0l /* 0x01A214 */,
  0x06000E7Dl /* 0x01A218 */,
  0x2ED0E500l /* 0x01A21C */,
  0xCA0836A0l /* 0x01A220 */,
  0x06000F6Dl /* 0x01A224 */,
  0xFCB8C600l /* 0x01A228 */,
  0x9E0CA323l /* 0x01A22C */,
  0x1E0D8CE8l /* 0x01A230 */,
  0x97C387ECl /* 0x01A234 */,
  0xE323C1D0l /* 0x01A238 */,
  0x8BEC1F0Dl /* 0x01A23C */,
  0x5CE0D7C3l /* 0x01A240 */,
  0x48646605l /* 0x01A244 */,
  0x8C646605l /* 0x01A248 */,
  0x00D051C1l /* 0x01A24C */,
  0x14606805l /* 0x01A250 */,
  0x6215C1F0l /* 0x01A254 */,
  0x01D199F8l /* 0x01A258 */,
  0x62F152F1l /* 0x01A25C */,
  0x00D02002l /* 0x01A260 */,
  0x23A02284l /* 0x01A264 */,
  0xA7E86215l /* 0x01A268 */,
  0x50716505l /* 0x01A26C */,
  0x6115C1F0l /* 0x01A270 */,
  0x00D1A7E8l /* 0x01A274 */,
  0xAF0052F1l /* 0x01A278 */,
  0x270518D0l /* 0x01A27C */,
  0x01D03060l /* 0x01A280 */,
  0x28602705l /* 0x01A284 */,
  0x1C606505l /* 0x01A288 */,
  0x650540D5l /* 0x01A28C */,
  0x61155465l /* 0x01A290 */,
  0xAF00BBF8l /* 0x01A294 */,
  0x12D058D0l /* 0x01A298 */,
  0xC0D76000l /* 0x01A29C */,
  0xA1000500l /* 0x01A2A0 */,
  0x12D048D0l /* 0x01A2A4 */,
  0xC0D76000l /* 0x01A2A8 */,
  0xA0060500l /* 0x01A2AC */,
  0x228480D1l /* 0x01A2B0 */,
  0xA3A13F80l /* 0x01A2B4 */,
  0xE8073F80l /* 0x01A2B8 */,
  0x860180D1l /* 0x01A2BC */,
  0x3F80E191l /* 0x01A2C0 */,
  0xC9F8C641l /* 0x01A2C4 */,
  0x80D12003l /* 0x01A2C8 */,
  0x8AA18A11l /* 0x01A2CC */,
  0x05843F80l /* 0x01A2D0 */,
  0x86A13F80l /* 0x01A2D4 */,
  0x46013F80l /* 0x01A2D8 */,
  0x9B1185C1l /* 0x01A2DC */,
  0x20008211l /* 0x01A2E0 */,
  0xE6ECA031l /* 0x01A2E4 */,
  0x2280E6E8l /* 0x01A2E8 */,
  0x23923F80l /* 0x01A2EC */,
  0x02121E12l /* 0x01A2F0 */,
  0xEBE08821l /* 0x01A2F4 */,
  0x23922281l /* 0x01A2F8 */,
  0x04121E12l /* 0x01A2FC */,
  0x22838821l /* 0x01A300 */,
  0xA3A13F80l /* 0x01A304 */,
  0x3F803F80l /* 0x01A308 */,
  0x4586C600l /* 0x01A30C */,
  0x06803F80l /* 0x01A310 */,
  0x17803F80l /* 0x01A314 */,
  0x0D803F80l /* 0x01A318 */,
  0x3F800A80l /* 0x01A31C */,
  0x3F800584l /* 0x01A320 */,
  0x3F800680l /* 0x01A324 */,
  0x3F80E480l /* 0x01A328 */,
  0x3F806480l /* 0x01A32C */,
  0x22814601l /* 0x01A330 */,
  0xDE11E391l /* 0x01A334 */,
  0x2280C411l /* 0x01A338 */,
  0x23923F80l /* 0x01A33C */,
  0x02121E12l /* 0x01A340 */,
  0xE2800732l /* 0x01A344 */,
  0xE3913F80l /* 0x01A348 */,
  0xC211DE11l /* 0x01A34C */,
  0x15F5C631l /* 0x01A350 */,
  0x2100C821l /* 0x01A354 */,
  0xC63180D1l /* 0x01A358 */,
  0x3F806280l /* 0x01A35C */,
  0x2283E3A1l /* 0x01A360 */,
  0xA3913F80l /* 0x01A364 */,
  0x82119E11l /* 0x01A368 */,
  0x3F80E280l /* 0x01A36C */,
  0xDE11E391l /* 0x01A370 */,
  0x8731C211l /* 0x01A374 */,
  0x882128F5l /* 0x01A378 */,
  0xC0D12001l /* 0x01A37C */,
  0xA2808731l /* 0x01A380 */,
  0xA3A13F80l /* 0x01A384 */,
  0xA004C600l /* 0x01A388 */,
  0x228401D2l /* 0x01A38C */,
  0x23A23F80l /* 0x01A390 */,
  0xC9073F80l /* 0x01A394 */,
  0xC907CD01l /* 0x01A398 */,
  0xC907CD01l /* 0x01A39C */,
  0xC907CD01l /* 0x01A3A0 */,
  0xDFD1CD01l /* 0x01A3A4 */,
  0xE011C541l /* 0x01A3A8 */,
  0xDD1147E9l /* 0x01A3AC */,
  0x090A8601l /* 0x01A3B0 */,
  0xC1B10D02l /* 0x01A3B4 */,
  0xC50742EDl /* 0x01A3B8 */,
  0x3CD36F00l /* 0x01A3BC */,
  0x8C594601l /* 0x01A3C0 */,
  0x24008C39l /* 0x01A3C4 */,
  0x8C5914D3l /* 0x01A3C8 */,
  0xC507C600l /* 0x01A3CC */,
  0x090CDFC4l /* 0x01A3D0 */,
  0x2011CD0Al /* 0x01A3D4 */,
  0x62F158E9l /* 0x01A3D8 */,
  0x33D82200l /* 0x01A3DC */,
  0x61E92B38l /* 0x01A3E0 */,
  0x61E904B8l /* 0x01A3E4 */,
  0x61E901B8l /* 0x01A3E8 */,
  0xC50453E1l /* 0x01A3EC */,
  0xA0061FC5l /* 0x01A3F0 */,
  0x228401D0l /* 0x01A3F4 */,
  0x48F123A0l /* 0x01A3F8 */,
  0x2390A280l /* 0x01A3FC */,
  0x63ED2010l /* 0x01A400 */,
  0x00000505l /* 0x01A404 */,
  0x18D0A105l /* 0x01A408 */,
  0x21120072l /* 0x01A40C */,
  0x2212B8E9l /* 0x01A410 */,
  0x6F05DFE9l /* 0x01A414 */,
  0x00700CD0l /* 0x01A418 */,
  0x16F82010l /* 0x01A41C */,
  0x18D02F02l /* 0x01A420 */,
  0x7CD02100l /* 0x01A424 */,
  0x16F2A0D0l /* 0x01A428 */,
  0x6CD02000l /* 0x01A42C */,
  0x16F281D0l /* 0x01A430 */,
  0x0D9041D0l /* 0x01A434 */,
  0x1CE80140l /* 0x01A438 */,
  0x0D004908l /* 0x01A43C */,
  0xBFD0EF00l /* 0x01A440 */,
  0x23F881B0l /* 0x01A444 */,
  0xC1DF2002l /* 0x01A448 */,
  0x890823E2l /* 0x01A44C */,
  0x20100D00l /* 0x01A450 */,
  0x22101EE8l /* 0x01A454 */,
  0x00C21EE8l /* 0x01A458 */,
  0x890845D0l /* 0x01A45C */,
  0x23100D00l /* 0x01A460 */,
  0x41B025F8l /* 0x01A464 */,
  0x21122BF8l /* 0x01A468 */,
  0xEF00BEE9l /* 0x01A46C */,
  0x07D2FFD1l /* 0x01A470 */,
  0x3CB00D90l /* 0x01A474 */,
  0xEBF10042l /* 0x01A478 */,
  0xA105EBF1l /* 0x01A47C */,
  0x0CB110D0l /* 0x01A480 */,
  0xA7010061l /* 0x01A484 */,
  0x06001C61l /* 0x01A488 */,
  0x0D084908l /* 0x01A48C */,
  0xE051C111l /* 0x01A490 */,
  0x4D078908l /* 0x01A494 */,
  0xDD51C211l /* 0x01A498 */,
  0xCD004908l /* 0x01A49C */,
  0xC351C111l /* 0x01A4A0 */,
  0x10D62000l /* 0x01A4A4 */,
  0x70D1A005l /* 0x01A4A8 */,
  0x60004567l /* 0x01A4AC */,
  0xC56140D1l /* 0x01A4B0 */,
  0x4D050909l /* 0x01A4B4 */,
  0x8908D5C1l /* 0x01A4B8 */,
  0xC2114D02l /* 0x01A4BC */,
  0x4908C951l /* 0x01A4C0 */,
  0xC1118D01l /* 0x01A4C4 */,
  0x4908C651l /* 0x01A4C8 */,
  0xC1110D08l /* 0x01A4CC */,
  0x8908E051l /* 0x01A4D0 */,
  0xC2118D05l /* 0x01A4D4 */,
  0x8908D651l /* 0x01A4D8 */,
  0xC211CD05l /* 0x01A4DC */,
  0x4908D751l /* 0x01A4E0 */,
  0xC1110D08l /* 0x01A4E4 */,
  0x4908E051l /* 0x01A4E8 */,
  0xC1110D08l /* 0x01A4EC */,
  0x8908E051l /* 0x01A4F0 */,
  0xC2110D08l /* 0x01A4F4 */,
  0x6000E051l /* 0x01A4F8 */,
  0xC56144D1l /* 0x01A4FC */,
  0x48D1A105l /* 0x01A500 */,
  0xA0050568l /* 0x01A504 */,
  0x456548D1l /* 0x01A508 */,
  0x4CD1A005l /* 0x01A50C */,
  0xA0054562l /* 0x01A510 */,
  0x856550D1l /* 0x01A514 */,
  0x54D1A005l /* 0x01A518 */,
  0x5DC0C565l /* 0x01A51C */,
  0x60D1A005l /* 0x01A520 */,
  0x110C0578l /* 0x01A524 */,
  0x241897E8l /* 0x01A528 */,
  0x60C797E8l /* 0x01A52C */,
  0x70D1A005l /* 0x01A530 */,
  0x50D84567l /* 0x01A534 */,
  0xE0102126l /* 0x01A538 */,
  0xC9079EF8l /* 0x01A53C */,
  0x212650D8l /* 0x01A540 */,
  0xB4F86F15l /* 0x01A544 */,
  0x68D1A005l /* 0x01A548 */,
  0x60C50578l /* 0x01A54C */,
  0x6CD1A005l /* 0x01A550 */,
  0x60C20578l /* 0x01A554 */,
  0x60D1A005l /* 0x01A558 */,
  0x60C70578l /* 0x01A55C */,
  0x64D1A005l /* 0x01A560 */,
  0x21180578l /* 0x01A564 */,
  0xA0C5B3E8l /* 0x01A568 */,
  0x80D5B4E0l /* 0x01A56C */,
  0x01E96317l /* 0x01A570 */,
  0xCCE86015l /* 0x01A574 */,
  0x01B815C8l /* 0x01A578 */,
  0x60120218l /* 0x01A57C */,
  0x6112C4E8l /* 0x01A580 */,
  0xEA06CCE8l /* 0x01A584 */,
  0x602160D1l /* 0x01A588 */,
  0xD0E0C574l /* 0x01A58C */,
  0x68D1E906l /* 0x01A590 */,
  0xC5746021l /* 0x01A594 */,
  0xD0E8A011l /* 0x01A598 */,
  0xD0E0F8B4l /* 0x01A59C */,
  0x70D1E806l /* 0x01A5A0 */,
  0xC5746021l /* 0x01A5A4 */,
  0xDCE8A315l /* 0x01A5A8 */,
  0xE6E86415l /* 0x01A5AC */,
  0xE6E86615l /* 0x01A5B0 */,
  0xEDE46715l /* 0x01A5B4 */,
  0xE9FC6915l /* 0x01A5B8 */,
  0xE3FC6E15l /* 0x01A5BC */,
  0xE6FC6215l /* 0x01A5C0 */,
  0xE9FC6515l /* 0x01A5C4 */,
  0xE3FC6A15l /* 0x01A5C8 */,
  0x6112EDE0l /* 0x01A5CC */,
  0xEDE0E9E8l /* 0x01A5D0 */,
  0xF5E86212l /* 0x01A5D4 */,
  0x1BD5F1E0l /* 0x01A5D8 */,
  0x78D6E506l /* 0x01A5DC */,
  0x1ED5F8E0l /* 0x01A5E0 */,
  0x48D6E606l /* 0x01A5E4 */,
  0x08D5F8E0l /* 0x01A5E8 */,
  0x58D6E606l /* 0x01A5EC */,
  0x0CD5F8E0l /* 0x01A5F0 */,
  0x60D6E606l /* 0x01A5F4 */,
  0xFCE8A115l /* 0x01A5F8 */,
  0x23E1A0D6l /* 0x01A5FC */,
  0x97C641D8l /* 0x01A600 */,
  0x8216A126l /* 0x01A604 */,
  0x20D523E1l /* 0x01A608 */,
  0x1AE96015l /* 0x01A60C */,
  0x0BE96112l /* 0x01A610 */,
  0x0EE96012l /* 0x01A614 */,
  0x48D1ED06l /* 0x01A618 */,
  0xEB0610E1l /* 0x01A61C */,
  0x10E158D1l /* 0x01A620 */,
  0x50D1EC06l /* 0x01A624 */,
  0x01B815C8l /* 0x01A628 */,
  0x60210218l /* 0x01A62C */,
  0xE014C574l /* 0x01A630 */,
  0xA1111AF9l /* 0x01A634 */,
  0xF8B41AF9l /* 0x01A638 */,
  0x1EE9A115l /* 0x01A63C */,
  0x23E194C6l /* 0x01A640 */,
  0x97C641D8l /* 0x01A644 */,
  0x8216A126l /* 0x01A648 */,
  0xA00523E1l /* 0x01A64C */,
  0x056658D1l /* 0x01A650 */,
  0x5CD1A005l /* 0x01A654 */,
  0xA0058566l /* 0x01A658 */,
  0xC5647CD1l /* 0x01A65C */,
  0x40D1A105l /* 0x01A660 */,
  0xA0054566l /* 0x01A664 */,
  0x856564D1l /* 0x01A668 */,
  0x68D1A005l /* 0x01A66C */,
  0xA0054565l /* 0x01A670 */,
  0x45626CD1l /* 0x01A674 */,
  0x5CD1A105l /* 0x01A678 */,
  0xA0050565l /* 0x01A67C */,
  0x456760D1l /* 0x01A680 */,
  0x60D16B05l /* 0x01A684 */,
  0x1D1813C8l /* 0x01A688 */,
  0xA1050568l /* 0x01A68C */,
  0x807110D0l /* 0x01A690 */,
  0xA0219D11l /* 0x01A694 */,
  0x23906282l /* 0x01A698 */,
  0x04101E10l /* 0x01A69C */,
  0x62818021l /* 0x01A6A0 */,
  0x9E10A390l /* 0x01A6A4 */,
  0x46C08210l /* 0x01A6A8 */,
  0x56E54230l /* 0x01A6AC */,
  0x81C14020l /* 0x01A6B0 */,
  0xC640C3D0l /* 0x01A6B4 */,
  0x46018331l /* 0x01A6B8 */,
  0x06000671l /* 0x01A6BC */,
  0x58117D91l /* 0x01A6C0 */,
  0xE310C600l /* 0x01A6C4 */,
  0xFF0371E9l /* 0x01A6C8 */,
  0x4FD0FFDFl /* 0x01A6CC */,
  0xC331C2D1l /* 0x01A6D0 */,
  0x181182E9l /* 0x01A6D4 */,
  0x85C00041l /* 0x01A6D8 */,
  0x84108C10l /* 0x01A6DC */,
  0x40D10251l /* 0x01A6E0 */,
  0x67F9C1B1l /* 0x01A6E4 */,
  0x84C082E1l /* 0x01A6E8 */,
  0xEC0F8810l /* 0x01A6EC */,
  0x804000D0l /* 0x01A6F0 */,
  0x4601BCB1l /* 0x01A6F4 */,
  0x06000671l /* 0x01A6F8 */,
  0x58117D91l /* 0x01A6FC */,
  0x05C1C600l /* 0x01A700 */,
  0x3FD02300l /* 0x01A704 */,
  0x02510041l /* 0x01A708 */,
  0x00D044C1l /* 0x01A70C */,
  0xEF0F0830l /* 0x01A710 */,
  0x001830D8l /* 0x01A714 */,
  0x140C2041l /* 0x01A718 */,
  0x94E18CF9l /* 0x01A71C */,
  0x30D8EF07l /* 0x01A720 */,
  0x140C0018l /* 0x01A724 */,
  0x200294E9l /* 0x01A728 */,
  0x23E2CBDFl /* 0x01A72C */,
  0x58D16B05l /* 0x01A730 */,
  0x231809C8l /* 0x01A734 */,
  0x20029CF9l /* 0x01A738 */,
  0x23E2CCDFl /* 0x01A73C */,
  0xA1ED2118l /* 0x01A740 */,
  0x02D8A0E9l /* 0x01A744 */,
  0x056801B8l /* 0x01A748 */,
  0x3F80A281l /* 0x01A74C */,
  0x3F806390l /* 0x01A750 */,
  0x1D1013C0l /* 0x01A754 */,
  0x80D02100l /* 0x01A758 */,
  0x06000220l /* 0x01A75C */,
  0xB8FD0130l /* 0x01A760 */,
  0xA10541D0l /* 0x01A764 */,
  0x406018D0l /* 0x01A768 */,
  0x58D0A700l /* 0x01A76C */,
  0x600012D0l /* 0x01A770 */,
  0x0500F3D7l /* 0x01A774 */,
  0x68D0A900l /* 0x01A778 */,
  0x600012D0l /* 0x01A77C */,
  0x0500C0D7l /* 0x01A780 */,
  0x0C706F05l /* 0x01A784 */,
  0x6F053FB0l /* 0x01A788 */,
  0x25050C60l /* 0x01A78C */,
  0x06D068D0l /* 0x01A790 */,
  0xC9070160l /* 0x01A794 */,
  0xC90A4D00l /* 0x01A798 */,
  0xD3C0CD04l /* 0x01A79C */,
  0xC5B04908l /* 0x01A7A0 */,
  0x60D16B05l /* 0x01A7A4 */,
  0x53204570l /* 0x01A7A8 */,
  0xE0104560l /* 0x01A7AC */,
  0x090AD9E9l /* 0x01A7B0 */,
  0xC1B04D00l /* 0x01A7B4 */,
  0xA700D5F9l /* 0x01A7B8 */,
  0x12D058D0l /* 0x01A7BC */,
  0xFAD76000l /* 0x01A7C0 */,
  0xA0050500l /* 0x01A7C4 */,
  0x45707CD1l /* 0x01A7C8 */,
  0x6B055D10l /* 0x01A7CC */,
  0xC57460D1l /* 0x01A7D0 */,
  0x45605320l /* 0x01A7D4 */,
  0xC5B0D3C0l /* 0x01A7D8 */,
  0x6800D3E1l /* 0x01A7DC */,
  0xA19040D0l /* 0x01A7E0 */,
  0xEDF98140l /* 0x01A7E4 */,
  0x63906283l /* 0x01A7E8 */,
  0x42105E10l /* 0x01A7EC */,
  0xA3906282l /* 0x01A7F0 */,
  0x84109E10l /* 0x01A7F4 */,
  0x45864230l /* 0x01A7F8 */,
  0x8690FFD0l /* 0x01A7FC */,
  0x83409510l /* 0x01A800 */,
  0x8210BEB0l /* 0x01A804 */,
  0x43104230l /* 0x01A808 */,
  0xCD909FD0l /* 0x01A80C */,
  0x4320C240l /* 0x01A810 */,
  0x443141C1l /* 0x01A814 */,
  0x628214F6l /* 0x01A818 */,
  0x1E112391l /* 0x01A81C */,
  0x62810411l /* 0x01A820 */,
  0xDE10E390l /* 0x01A824 */,
  0xC430C210l /* 0x01A828 */,
  0x4321C310l /* 0x01A82C */,
  0xC50701C1l /* 0x01A830 */,
  0x06004601l /* 0x01A834 */,
  0x3D803C80l /* 0x01A838 */,
  0x006F4A00l /* 0x01A83C */,
  0xC6000600l /* 0x01A840 */,
  0x3CB00120l /* 0x01A844 */,
  0x16EE81B0l /* 0x01A848 */,
  0x4601C507l /* 0x01A84C */,
  0x01D07000l /* 0x01A850 */,
  0x3F8037A0l /* 0x01A854 */,
  0x00C0C600l /* 0x01A858 */,
  0x29E200C0l /* 0x01A85C */,
  0x28D02900l /* 0x01A860 */,
  0x6F05007Al /* 0x01A864 */,
  0xC676BCD1l /* 0x01A868 */,
  0x80D1A005l /* 0x01A86C */,
  0xA0050677l /* 0x01A870 */,
  0x467284D1l /* 0x01A874 */,
  0x40D82400l /* 0x01A878 */,
  0x1DC869A8l /* 0x01A87C */,
  0x004801D0l /* 0x01A880 */,
  0x2AA80618l /* 0x01A884 */,
  0x458600C0l /* 0x01A888 */,
  0x17C800C0l /* 0x01A88C */,
  0x16580218l /* 0x01A890 */,
  0x5DC80118l /* 0x01A894 */,
  0x624881D8l /* 0x01A898 */,
  0x06182158l /* 0x01A89C */,
  0x01180618l /* 0x01A8A0 */,
  0x215841D8l /* 0x01A8A4 */,
  0x01180218l /* 0x01A8A8 */,
  0x215840D8l /* 0x01A8AC */,
  0x41D80118l /* 0x01A8B0 */,
  0x06A82158l /* 0x01A8B4 */,
  0x2F023F80l /* 0x01A8B8 */,
  0x40D198D1l /* 0x01A8BC */,
  0xC0D0C0D1l /* 0x01A8C0 */,
  0x40D100D2l /* 0x01A8C4 */,
  0x08D82000l /* 0x01A8C8 */,
  0x200027A8l /* 0x01A8CC */,
  0x29A813D8l /* 0x01A8D0 */,
  0x00D82000l /* 0x01A8D4 */,
  0x40D12AA8l /* 0x01A8D8 */,
  0x2F0200D1l /* 0x01A8DC */,
  0x631798D1l /* 0x01A8E0 */,
  0x201156E8l /* 0x01A8E4 */,
  0x211154E8l /* 0x01A8E8 */,
  0x29024AF8l /* 0x01A8EC */,
  0x4CE090D8l /* 0x01A8F0 */,
  0x90D82B02l /* 0x01A8F4 */,
  0x2A80A980l /* 0x01A8F8 */,
  0x3CD82100l /* 0x01A8FC */,
  0xE27A0A08l /* 0x01A900 */,
  0x06003F80l /* 0x01A904 */,
  0x57E03FB1l /* 0x01A908 */,
  0xC0D03DB1l /* 0x01A90C */,
  0x69840600l /* 0x01A910 */,
  0x2A803F80l /* 0x01A914 */,
  0x3F802984l /* 0x01A918 */,
  0x7BE86317l /* 0x01A91C */,
  0x63F8E010l /* 0x01A920 */,
  0x89073F8Cl /* 0x01A924 */,
  0x00C000C0l /* 0x01A928 */,
  0x00C000C0l /* 0x01A92C */,
  0x00C000C0l /* 0x01A930 */,
  0x00C000C0l /* 0x01A934 */,
  0x00C000C0l /* 0x01A938 */,
  0x00C08601l /* 0x01A93C */,
  0x00C000C0l /* 0x01A940 */,
  0x00C000C0l /* 0x01A944 */,
  0x00C000C0l /* 0x01A948 */,
  0x00C000C0l /* 0x01A94C */,
  0x7F8C00C0l /* 0x01A950 */,
  0x42D899E0l /* 0x01A954 */,
  0x89073F8Cl /* 0x01A958 */,
  0x00C000C0l /* 0x01A95C */,
  0x00C000C0l /* 0x01A960 */,
  0x00C000C0l /* 0x01A964 */,
  0x00C000C0l /* 0x01A968 */,
  0x00C000C0l /* 0x01A96C */,
  0x00C08601l /* 0x01A970 */,
  0x00C000C0l /* 0x01A974 */,
  0x00C000C0l /* 0x01A978 */,
  0x00C000C0l /* 0x01A97C */,
  0x00C000C0l /* 0x01A980 */,
  0x7F8C00C0l /* 0x01A984 */,
  0x7CF441B8l /* 0x01A988 */,
  0x2A806984l /* 0x01A98C */,
  0x3F8D2984l /* 0x01A990 */,
  0x06007F8Dl /* 0x01A994 */,
  0x3F802984l /* 0x01A998 */,
  0x0BD82000l /* 0x01A99C */,
  0x3F8027A8l /* 0x01A9A0 */,
  0x00C000C0l /* 0x01A9A4 */,
  0x00C000C0l /* 0x01A9A8 */,
  0x860100C0l /* 0x01A9AC */,
  0x3F8EBF8Dl /* 0x01A9B0 */,
  0x97F1C0D1l /* 0x01A9B4 */,
  0x00C000C0l /* 0x01A9B8 */,
  0x00C000C0l /* 0x01A9BC */,
  0x060000C0l /* 0x01A9C0 */,
  0x00C08601l /* 0x01A9C4 */,
  0x00C000C0l /* 0x01A9C8 */,
  0x00C000C0l /* 0x01A9CC */,
  0x00C000C0l /* 0x01A9D0 */,
  0x00C000C0l /* 0x01A9D4 */,
  0x860100C0l /* 0x01A9D8 */,
  0x6783BF8Cl /* 0x01A9DC */,
  0xE0113F80l /* 0x01A9E0 */,
  0x74F1C4E8l /* 0x01A9E4 */,
  0xE811FFB1l /* 0x01A9E8 */,
  0x8601ABF8l /* 0x01A9EC */,
  0x23002984l /* 0x01A9F0 */,
  0x2A987FD8l /* 0x01A9F4 */,
  0x19182148l /* 0x01A9F8 */,
  0x000801D0l /* 0x01A9FC */,
  0x2AA80718l /* 0x01AA00 */,
  0x74F13F80l /* 0x01AA04 */,
  0x05C87FB1l /* 0x01AA08 */,
  0x1CF91000l /* 0x01AA0C */,
  0xDBF82212l /* 0x01AA10 */,
  0x0600FF8Dl /* 0x01AA14 */,
  0x21002980l /* 0x01AA18 */,
  0x27A000D0l /* 0x01AA1C */,
  0xEAE82012l /* 0x01AA20 */,
  0xE7E82112l /* 0x01AA24 */,
  0x20D0B80Bl /* 0x01AA28 */,
  0xB40BECE0l /* 0x01AA2C */,
  0xECE020D0l /* 0x01AA30 */,
  0x20D0B00Bl /* 0x01AA34 */,
  0x3F802CA0l /* 0x01AA38 */,
  0x092028C0l /* 0x01AA3C */,
  0x7CD82100l /* 0x01AA40 */,
  0x00C000C0l /* 0x01AA44 */,
  0x00C000C0l /* 0x01AA48 */,
  0xC06A4A08l /* 0x01AA4C */,
  0x22000600l /* 0x01AA50 */,
  0x460100D8l /* 0x01AA54 */,
  0x60254602l /* 0x01AA58 */,
  0x01F99E03l /* 0x01AA5C */,
  0x0602A025l /* 0x01AA60 */,
  0x6022C600l /* 0x01AA64 */,
  0x38D06A05l /* 0x01AA68 */,
  0x09C80070l /* 0x01AA6C */,
  0x0BE5100Cl /* 0x01AA70 */,
  0x060040D2l /* 0x01AA74 */,
  0x00C000C0l /* 0x01AA78 */,
  0x00D03008l /* 0x01AA7C */,
  0x29A00210l /* 0x01AA80 */,
  0x7F8E2782l /* 0x01AA84 */,
  0x98D12F02l /* 0x01AA88 */,
  0x00D82200l /* 0x01AA8C */,
  0xA1F12027l /* 0x01AA90 */,
  0x24E13FB2l /* 0x01AA94 */,
  0xA8D1E102l /* 0x01AA98 */,
  0x00D82200l /* 0x01AA9C */,
  0x24EDE036l /* 0x01AAA0 */,
  0xD0D66F00l /* 0x01AAA4 */,
  0x2A802984l /* 0x01AAA8 */,
  0x99F82312l /* 0x01AAAC */,
  0xFFB000D2l /* 0x01AAB0 */,
  0x58F8E410l /* 0x01AAB4 */,
  0x2311C0D0l /* 0x01AAB8 */,
  0x6F0541F8l /* 0x01AABC */,
  0x40700CD0l /* 0x01AAC0 */,
  0x40607FB0l /* 0x01AAC4 */,
  0xBCD16F05l /* 0x01AAC8 */,
  0xA005C666l /* 0x01AACC */,
  0x066780D1l /* 0x01AAD0 */,
  0x84D1A005l /* 0x01AAD4 */,
  0xA1054662l /* 0x01AAD8 */,
  0x867290D1l /* 0x01AADC */,
  0xA105AFF1l /* 0x01AAE0 */,
  0x866290D1l /* 0x01AAE4 */,
  0xBCD1A005l /* 0x01AAE8 */,
  0xCB33C673l /* 0x01AAEC */,
  0x4FE55AE9l /* 0x01AAF0 */,
  0x0D004908l /* 0x01AAF4 */,
  0x4AF9C1B3l /* 0x01AAF8 */,
  0x46015AE1l /* 0x01AAFC */,
  0xC2DF2002l /* 0x01AB00 */,
  0x01D07000l /* 0x01AB04 */,
  0x3F8037A0l /* 0x01AB08 */,
  0x00C0C600l /* 0x01AB0C */,
  0x57E100C0l /* 0x01AB10 */,
  0x00C000C0l /* 0x01AB14 */,
  0x24D0A105l /* 0x01AB18 */,
  0x20100070l /* 0x01AB1C */,
  0xA70067F9l /* 0x01AB20 */,
  0x12D058D0l /* 0x01AB24 */,
  0xFAD76000l /* 0x01AB28 */,
  0xA7000500l /* 0x01AB2C */,
  0x12D058D0l /* 0x01AB30 */,
  0xECD76000l /* 0x01AB34 */,
  0xA9000500l /* 0x01AB38 */,
  0x12D060D0l /* 0x01AB3C */,
  0xC0D76000l /* 0x01AB40 */,
  0x0C000500l /* 0x01AB44 */,
  0x06C82984l /* 0x01AB48 */,
  0x20001B28l /* 0x01AB4C */,
  0x4A084CD8l /* 0x01AB50 */,
  0x0600E06Al /* 0x01AB54 */,
  0x00D8A000l /* 0x01AB58 */,
  0x93F91B38l /* 0x01AB5C */,
  0xA0004601l /* 0x01AB60 */,
  0x062800D8l /* 0x01AB64 */,
  0x1ED06700l /* 0x01AB68 */,
  0x0B0336A0l /* 0x01AB6C */,
  0x0600207Dl /* 0x01AB70 */,
  0x1ED0E700l /* 0x01AB74 */,
  0x0B0336A0l /* 0x01AB78 */,
  0x0600066Dl /* 0x01AB7C */,
  0xC0D600C0l /* 0x01AB80 */,
  0x2000C600l /* 0x01AB84 */,
  0xE12650D8l /* 0x01AB88 */,
  0x2984C507l /* 0x01AB8C */,
  0x1C2806C8l /* 0x01AB90 */,
  0x40D82200l /* 0x01AB94 */,
  0xE07A4A08l /* 0x01AB98 */,
  0x21274118l /* 0x01AB9C */,
  0xA0000600l /* 0x01ABA0 */,
  0x1C3800D8l /* 0x01ABA4 */,
  0xA000A8F5l /* 0x01ABA8 */,
  0x203700D8l /* 0x01ABAC */,
  0x2980C507l /* 0x01ABB0 */,
  0x27983F80l /* 0x01ABB4 */,
  0xA9F91000l /* 0x01ABB8 */,
  0x6800C507l /* 0x01ABBC */,
  0x619300D3l /* 0x01ABC0 */,
  0xB1F94C43l /* 0x01ABC4 */,
  0x23936283l /* 0x01ABC8 */,
  0x02131E13l /* 0x01ABCC */,
  0x63936282l /* 0x01ABD0 */,
  0x44135E13l /* 0x01ABD4 */,
  0x45860D33l /* 0x01ABD8 */,
  0x4693BFD3l /* 0x01ABDC */,
  0x4E435513l /* 0x01ABE0 */,
  0x42137EB3l /* 0x01ABE4 */,
  0x03130D33l /* 0x01ABE8 */,
  0x8D935FD3l /* 0x01ABEC */,
  0x0E238D43l /* 0x01ABF0 */,
  0xCA32CCC2l /* 0x01ABF4 */,
  0x6282D8F5l /* 0x01ABF8 */,
  0x9E12A392l /* 0x01ABFC */,
  0x62818412l /* 0x01AC00 */,
  0x9E13A393l /* 0x01AC04 */,
  0x8A338213l /* 0x01AC08 */,
  0xCE228313l /* 0x01AC0C */,
  0xC5078CC2l /* 0x01AC10 */,
  0xCC0B0600l /* 0x01AC14 */,
  0x0000C507l /* 0x01AC18 */,
  0x00000000l /* 0x01AC1C */,
  0x00000000l /* 0x01AC20 */,
  0x00000000l /* 0x01AC24 */,
  0x00000000l /* 0x01AC28 */,
  0xA0050602l /* 0x01AC2C */,
  0x907510D4l /* 0x01AC30 */,
  0x14D4A005l /* 0x01AC34 */,
  0xA005D075l /* 0x01AC38 */,
  0x107618D4l /* 0x01AC3C */,
  0x1CD4A005l /* 0x01AC40 */,
  0xA0059076l /* 0x01AC44 */,
  0x507730D4l /* 0x01AC48 */,
  0x00D4A105l /* 0x01AC4C */,
  0xA0055076l /* 0x01AC50 */,
  0x507508D4l /* 0x01AC54 */,
  0x1CD4A105l /* 0x01AC58 */,
  0xA0051075l /* 0x01AC5C */,
  0xD0743CD4l /* 0x01AC60 */,
  0x18D0A105l /* 0x01AC64 */,
  0x406040D0l /* 0x01AC68 */,
  0x34D42300l /* 0x01AC6C */,
  0x11C05074l /* 0x01AC70 */,
  0x40244114l /* 0x01AC74 */,
  0xA7825E14l /* 0x01AC78 */,
  0x99E96317l /* 0x01AC7C */,
  0x40D140DBl /* 0x01AC80 */,
  0x80D180D2l /* 0x01AC84 */,
  0x1978C0D1l /* 0x01AC88 */,
  0xBFD8EF0Fl /* 0x01AC8C */,
  0x21002248l /* 0x01AC90 */,
  0x20C27FD8l /* 0x01AC94 */,
  0x60C32142l /* 0x01AC98 */,
  0x7FD85913l /* 0x01AC9C */,
  0xA0C36143l /* 0x01ACA0 */,
  0xA0139313l /* 0x01ACA4 */,
  0xA4134CE8l /* 0x01ACA8 */,
  0xA31349E8l /* 0x01ACAC */,
  0x890846E8l /* 0x01ACB0 */,
  0x4EE04D02l /* 0x01ACB4 */,
  0x4D02C908l /* 0x01ACB8 */,
  0x09094EE0l /* 0x01ACBC */,
  0x4EE04D02l /* 0x01ACC0 */,
  0x40D22000l /* 0x01ACC4 */,
  0x38D4E506l /* 0x01ACC8 */,
  0x021808C8l /* 0x01ACCC */,
  0x0E262024l /* 0x01ACD0 */,
  0x5AF86012l /* 0x01ACD4 */,
  0x612B41D8l /* 0x01ACD8 */,
  0x6FE040D8l /* 0x01ACDC */,
  0x5F1209C8l /* 0x01ACE0 */,
  0x09244212l /* 0x01ACE4 */,
  0x10005072l /* 0x01ACE8 */,
  0x230065E8l /* 0x01ACEC */,
  0x61427FD8l /* 0x01ACF0 */,
  0x581266E0l /* 0x01ACF4 */,
  0x10D849C8l /* 0x01ACF8 */,
  0x6DE42138l /* 0x01ACFC */,
  0x49284118l /* 0x01AD00 */,
  0x0FD86FE0l /* 0x01AD04 */,
  0xA3156048l /* 0x01AD08 */,
  0x05C887E8l /* 0x01AD0C */,
  0x89F41A38l /* 0x01AD10 */,
  0xBFB2A121l /* 0x01AD14 */,
  0x10000AC8l /* 0x01AD18 */,
  0x89C47BE8l /* 0x01AD1C */,
  0x46013DE0l /* 0x01AD20 */,
  0x52524812l /* 0x01AD24 */,
  0x05C8A980l /* 0x01AD28 */,
  0x011820B8l /* 0x01AD2C */,
  0x2AA80B18l /* 0x01AD30 */,
  0xC6006BA2l /* 0x01AD34 */,
  0xA12198E0l /* 0x01AD38 */,
  0x60128EE0l /* 0x01AD3C */,
  0x81D88DF8l /* 0x01AD40 */,
  0xE121622Bl /* 0x01AD44 */,
  0x481289C4l /* 0x01AD48 */,
  0xA9805252l /* 0x01AD4C */,
  0x20B805C8l /* 0x01AD50 */,
  0x0B180118l /* 0x01AD54 */,
  0x6BA22AA8l /* 0x01AD58 */,
  0x622181D8l /* 0x01AD5C */,
  0x60D805C8l /* 0x01AD60 */,
  0xAAE82138l /* 0x01AD64 */,
  0x143805C8l /* 0x01AD68 */,
  0x05C8A7F4l /* 0x01AD6C */,
  0x3DE40D38l /* 0x01AD70 */,
  0x62268218l /* 0x01AD74 */,
  0x40D22FE0l /* 0x01AD78 */,
  0x87E040D8l /* 0x01AD7C */,
  0x06C88721l /* 0x01AD80 */,
  0x20260318l /* 0x01AD84 */,
  0x021806C8l /* 0x01AD88 */,
  0x14C12026l /* 0x01AD8C */,
  0xB5E8A315l /* 0x01AD90 */,
  0x2D310111l /* 0x01AD94 */,
  0x04260111l /* 0x01AD98 */,
  0x60D804C8l /* 0x01AD9C */,
  0xCAE40CB8l /* 0x01ADA0 */,
  0x4D038909l /* 0x01ADA4 */,
  0xCD038909l /* 0x01ADA8 */,
  0x4F534613l /* 0x01ADAC */,
  0x4B182982l /* 0x01ADB0 */,
  0x6BA36AA8l /* 0x01ADB4 */,
  0x7EB85518l /* 0x01ADB8 */,
  0xBAE020C1l /* 0x01ADBC */,
  0xECE82011l /* 0x01ADC0 */,
  0x06B804C8l /* 0x01ADC4 */,
  0x84C8DBF4l /* 0x01ADC8 */,
  0x8808A0B8l /* 0x01ADCC */,
  0x0CD04D03l /* 0x01ADD0 */,
  0x40130430l /* 0x01ADD4 */,
  0x4B182982l /* 0x01ADD8 */,
  0x6BA36AA8l /* 0x01ADDC */,
  0x8909ECE0l /* 0x01ADE0 */,
  0x46134D03l /* 0x01ADE4 */,
  0xE8E806B1l /* 0x01ADE8 */,
  0xA0B884C8l /* 0x01ADEC */,
  0xCD038808l /* 0x01ADF0 */,
  0x043006D0l /* 0x01ADF4 */,
  0x4F53C013l /* 0x01ADF8 */,
  0x4B182982l /* 0x01ADFC */,
  0x6BA36AA8l /* 0x01AE00 */,
  0x00000000l /* 0x01AE04 */,
  0x00000000l /* 0x01AE08 */,
  0x20000000l /* 0x01AE0C */,
  0x80DB00D4l /* 0x01AE10 */,
  0x40D180D2l /* 0x01AE14 */,
  0x2982A0D8l /* 0x01AE18 */,
  0x3F80AAA8l /* 0x01AE1C */,
  0x3FD8EF0Fl /* 0x01AE20 */,
  0xE040EB90l /* 0x01AE24 */,
  0xA980BEB8l /* 0x01AE28 */,
  0x20B805C8l /* 0x01AE2C */,
  0x2AA80118l /* 0x01AE30 */,
  0x7FD8EF0Fl /* 0x01AE34 */,
  0x21422B92l /* 0x01AE38 */,
  0x230008C8l /* 0x01AE3C */,
  0x21487FD8l /* 0x01AE40 */,
  0x12F92018l /* 0x01AE44 */,
  0x00D3C0D2l /* 0x01AE48 */,
  0x46E140D3l /* 0x01AE4C */,
  0x8FE9A61Bl /* 0x01AE50 */,
  0x2EC883C3l /* 0x01AE54 */,
  0x0AD00118l /* 0x01AE58 */,
  0x1EE92030l /* 0x01AE5C */,
  0x003800D8l /* 0x01AE60 */,
  0x801320C0l /* 0x01AE64 */,
  0xA04303D8l /* 0x01AE68 */,
  0xA313BFBBl /* 0x01AE6C */,
  0xA2133FE9l /* 0x01AE70 */,
  0xA11338E9l /* 0x01AE74 */,
  0x890930E9l /* 0x01AE78 */,
  0x8909CD02l /* 0x01AE7C */,
  0x89090D03l /* 0x01AE80 */,
  0x12D84D03l /* 0x01AE84 */,
  0x46E12026l /* 0x01AE88 */,
  0xCD028909l /* 0x01AE8C */,
  0x89090BC3l /* 0x01AE90 */,
  0x0CD84D03l /* 0x01AE94 */,
  0x46E12026l /* 0x01AE98 */,
  0xCD028909l /* 0x01AE9C */,
  0x4BC30BC3l /* 0x01AEA0 */,
  0x202606D8l /* 0x01AEA4 */,
  0x890946E1l /* 0x01AEA8 */,
  0x8909CD02l /* 0x01AEAC */,
  0x4CC30D03l /* 0x01AEB0 */,
  0x20260CD8l /* 0x01AEB4 */,
  0x56E96014l /* 0x01AEB8 */,
  0x7ED82000l /* 0x01AEBC */,
  0x9B0CD122l /* 0x01AEC0 */,
  0xE1C24EF5l /* 0x01AEC4 */,
  0x9C0C1123l /* 0x01AEC8 */,
  0x21C352F5l /* 0x01AECC */,
  0x9D0C5123l /* 0x01AED0 */,
  0x61C356F5l /* 0x01AED4 */,
  0x0AC8BFB2l /* 0x01AED8 */,
  0x62E91000l /* 0x01AEDC */,
  0xCCC1CBCBl /* 0x01AEE0 */,
  0xA315CDC8l /* 0x01AEE4 */,
  0x08C862E9l /* 0x01AEE8 */,
  0x0CE11818l /* 0x01AEEC */,
  0xEF52C812l /* 0x01AEF0 */,
  0x07530813l /* 0x01AEF4 */,
  0x63534813l /* 0x01AEF8 */,
  0x05C8A980l /* 0x01AEFC */,
  0x0B180118l /* 0x01AF00 */,
  0xEBA22AA8l /* 0x01AF04 */,
  0x10C86980l /* 0x01AF08 */,
  0x0B180118l /* 0x01AF0C */,
  0x2BA32AA8l /* 0x01AF10 */,
  0x20B810C8l /* 0x01AF14 */,
  0x0B180118l /* 0x01AF18 */,
  0x6BA32AA8l /* 0x01AF1C */,
  0xA3153FB4l /* 0x01AF20 */,
  0xBFB27EF9l /* 0x01AF24 */,
  0x05C87FB1l /* 0x01AF28 */,
  0x60D82000l /* 0x01AF2C */,
  0xFFE42138l /* 0x01AF30 */,
  0x00D86980l /* 0x01AF34 */,
  0x23002AA8l /* 0x01AF38 */,
  0x29023CD8l /* 0x01AF3C */,
  0x0A0850D8l /* 0x01AF40 */,
  0x0600E16Al /* 0x01AF44 */,
  0x298210E2l /* 0x01AF48 */,
  0xEB90AAA8l /* 0x01AF4C */,
  0xEF0F3F80l /* 0x01AF50 */,
  0xE0403FD8l /* 0x01AF54 */,
  0x80DBBEB8l /* 0x01AF58 */,
  0x40D114E1l /* 0x01AF5C */,
  0x80D180D2l /* 0x01AF60 */,
  0x0909C0D1l /* 0x01AF64 */,
  0x04D84D02l /* 0x01AF68 */,
  0x60122026l /* 0x01AF6C */,
  0x41D8A5E9l /* 0x01AF70 */,
  0xA3156122l /* 0x01AF74 */,
  0x05C8BCE9l /* 0x01AF78 */,
  0xBEF51A38l /* 0x01AF7C */,
  0x41D88921l /* 0x01AF80 */,
  0x4AC8A122l /* 0x01AF84 */,
  0xB2E99000l /* 0x01AF88 */,
  0x9DE189C4l /* 0x01AF8C */,
  0x52528814l /* 0x01AF90 */,
  0x05C8A980l /* 0x01AF94 */,
  0x011820B8l /* 0x01AF98 */,
  0x2AA80B18l /* 0x01AF9C */,
  0xC9E16BA2l /* 0x01AFA0 */,
  0xBFE18921l /* 0x01AFA4 */,
  0x89C4C921l /* 0x01AFA8 */,
  0x52528814l /* 0x01AFAC */,
  0x05C8A980l /* 0x01AFB0 */,
  0x011820B8l /* 0x01AFB4 */,
  0x2AA80B18l /* 0x01AFB8 */,
  0x41D86BA2l /* 0x01AFBC */,
  0x05C86121l /* 0x01AFC0 */,
  0xCFE91438l /* 0x01AFC4 */,
  0x87219DE1l /* 0x01AFC8 */,
  0x031806C8l /* 0x01AFCC */,
  0x06C82026l /* 0x01AFD0 */,
  0x20260218l /* 0x01AFD4 */,
  0x80D240D1l /* 0x01AFD8 */,
  0x05C8A980l /* 0x01AFDC */,
  0x011820B8l /* 0x01AFE0 */,
  0x00C02AA8l /* 0x01AFE4 */,
  0x7FD8EF0Fl /* 0x01AFE8 */,
  0x21422B92l /* 0x01AFEC */,
  0x181808C8l /* 0x01AFF0 */,
  0xE8F92018l /* 0x01AFF4 */,
  0xF3E1C0D2l /* 0x01AFF8 */,
  0xCD028909l /* 0x01AFFC */,
  0x60143AB6l /* 0x01B000 */,
  0x2000F3E9l /* 0x01B004 */,
  0xD1227ED8l /* 0x01B008 */,
  0xF3F59B0Cl /* 0x01B00C */,
  0xBFB2E1C2l /* 0x01B010 */,
  0x90004AC8l /* 0x01B014 */,
  0xCBCBFFE9l /* 0x01B018 */,
  0xFFE9A315l /* 0x01B01C */,
  0x230008C8l /* 0x01B020 */,
  0x21487FD8l /* 0x01B024 */,
  0xC81BE4E1l /* 0x01B028 */,
  0xA980EF52l /* 0x01B02C */,
  0x011805C8l /* 0x01B030 */,
  0x2AA80B18l /* 0x01B034 */,
  0xA315EBA2l /* 0x01B038 */,
  0x41D80BFAl /* 0x01B03C */,
  0x7FB1A122l /* 0x01B040 */,
  0x143805C8l /* 0x01B044 */,
  0x10E2D8E5l /* 0x01B048 */,
  0x16EA6015l /* 0x01B04C */,
  0x533058C0l /* 0x01B050 */,
  0x1FE216FEl /* 0x01B054 */,
  0x18D4A005l /* 0x01B058 */,
  0xA9001066l /* 0x01B05C */,
  0x12D070D0l /* 0x01B060 */,
  0xC0D76000l /* 0x01B064 */,
  0xE4000500l /* 0x01B068 */,
  0x207828D8l /* 0x01B06C */,
  0x2BEA1D00l /* 0x01B070 */,
  0x93C058C0l /* 0x01B074 */,
  0x89DE3100l /* 0x01B078 */,
  0x3FB00210l /* 0x01B07C */,
  0x2002CC03l /* 0x01B080 */,
  0x7000C0DFl /* 0x01B084 */,
  0x37A001D0l /* 0x01B088 */,
  0x00C03F80l /* 0x01B08C */,
  0x31E200C0l /* 0x01B090 */,
  0x04D0EE06l /* 0x01B094 */,
  0x7FB04070l /* 0x01B098 */,
  0x41D006ECl /* 0x01B09C */,
  0x45864060l /* 0x01B0A0 */,
  0x3F808684l /* 0x01B0A4 */,
  0x00D0EE06l /* 0x01B0A8 */,
  0x60104070l /* 0x01B0AC */,
  0xEF061AF8l /* 0x01B0B0 */,
  0x40D02CD0l /* 0x01B0B4 */,
  0xEF064060l /* 0x01B0B8 */,
  0x406030D0l /* 0x01B0BC */,
  0x00D0EE06l /* 0x01B0C0 */,
  0x406041D0l /* 0x01B0C4 */,
  0x2CD0EF06l /* 0x01B0C8 */,
  0x20100070l /* 0x01B0CC */,
  0xAA0025FCl /* 0x01B0D0 */,
  0x12D058D0l /* 0x01B0D4 */,
  0xC0D76000l /* 0x01B0D8 */,
  0xAA000500l /* 0x01B0DC */,
  0x12D040D0l /* 0x01B0E0 */,
  0xC0D76000l /* 0x01B0E4 */,
  0x00000500l /* 0x01B0E8 */,
  0x08D0EE06l /* 0x01B0EC */,
  0x7FB04070l /* 0x01B0F0 */,
  0x41D006ECl /* 0x01B0F4 */,
  0xEA044060l /* 0x01B0F8 */,
  0x407000D0l /* 0x01B0FC */,
  0x11F87010l /* 0x01B100 */,
  0x10D0EF06l /* 0x01B104 */,
  0x406040D0l /* 0x01B108 */,
  0x2805AEE0l /* 0x01B10C */,
  0x807118D0l /* 0x01B110 */,
  0x18D0EF06l /* 0x01B114 */,
  0x06C04071l /* 0x01B118 */,
  0x24E80530l /* 0x01B11C */,
  0x30B005C0l /* 0x01B120 */,
  0x68D02B01l /* 0x01B124 */,
  0x22EC4030l /* 0x01B128 */,
  0x08D0EF00l /* 0x01B12C */,
  0x2AF80630l /* 0x01B130 */,
  0x58D0A700l /* 0x01B134 */,
  0x600012D0l /* 0x01B138 */,
  0x0500ECD7l /* 0x01B13C */,
  0x2CD0EE06l /* 0x01B140 */,
  0x2C000070l /* 0x01B144 */,
  0x201020D2l /* 0x01B148 */,
  0x200433E8l /* 0x01B14C */,
  0xC5C100D2l /* 0x01B150 */,
  0x47C340D2l /* 0x01B154 */,
  0x2010BEF0l /* 0x01B158 */,
  0x41D24DE8l /* 0x01B15C */,
  0xC7C30AC3l /* 0x01B160 */,
  0x2010BEF0l /* 0x01B164 */,
  0x42D24DE8l /* 0x01B168 */,
  0x47C48AC3l /* 0x01B16C */,
  0x2010BEF0l /* 0x01B170 */,
  0x43D24DE8l /* 0x01B174 */,
  0xC7C40AC4l /* 0x01B178 */,
  0x2010BEF0l /* 0x01B17C */,
  0x44D24DE8l /* 0x01B180 */,
  0x090A8AC4l /* 0x01B184 */,
  0x090ACD02l /* 0x01B188 */,
  0x0D00C812l /* 0x01B18C */,
  0xC909C052l /* 0x01B190 */,
  0x0D00C712l /* 0x01B194 */,
  0x01B2C052l /* 0x01B198 */,
  0x4908B4E4l /* 0x01B19C */,
  0x0D00C112l /* 0x01B1A0 */,
  0xCDC1C052l /* 0x01B1A4 */,
  0x0C300BC0l /* 0x01B1A8 */,
  0x621273E8l /* 0x01B1AC */,
  0xCFC157E4l /* 0x01B1B0 */,
  0x0E300BC0l /* 0x01B1B4 */,
  0x631273E8l /* 0x01B1B8 */,
  0xD1C157E4l /* 0x01B1BC */,
  0x10300BC0l /* 0x01B1C0 */,
  0x641273E8l /* 0x01B1C4 */,
  0xD3C157E4l /* 0x01B1C8 */,
  0x12300BC0l /* 0x01B1CC */,
  0xF8B157F8l /* 0x01B1D0 */,
  0xF8B14770l /* 0x01B1D4 */,
  0x28D02B01l /* 0x01B1D8 */,
  0x7CEC0730l /* 0x01B1DC */,
  0xC8D1EF00l /* 0x01B1E0 */,
  0x073006C0l /* 0x01B1E4 */,
  0xF8B1B4E8l /* 0x01B1E8 */,
  0x81308770l /* 0x01B1EC */,
  0x200287F4l /* 0x01B1F0 */,
  0x051000D0l /* 0x01B1F4 */,
  0xEF068020l /* 0x01B1F8 */,
  0x806010D0l /* 0x01B1FC */,
  0x58104BC0l /* 0x01B200 */,
  0x23005810l /* 0x01B204 */,
  0x40403FD0l /* 0x01B208 */,
  0x34D0EF06l /* 0x01B20C */,
  0xEF0F4060l /* 0x01B210 */,
  0xC0423FD0l /* 0x01B214 */,
  0x38D0EF06l /* 0x01B218 */,
  0x9CECE012l /* 0x01B21C */,
  0xC0D22008l /* 0x01B220 */,
  0xEE06C062l /* 0x01B224 */,
  0x407014D0l /* 0x01B228 */,
  0x40607FB0l /* 0x01B22C */,
  0xEF06C8B1l /* 0x01B230 */,
  0xC06118D0l /* 0x01B234 */,
  0x2CD0EE06l /* 0x01B238 */,
  0x406040D0l /* 0x01B23C */,
  0x14D0EF06l /* 0x01B240 */,
  0x406040D0l /* 0x01B244 */,
  0x48D0AA00l /* 0x01B248 */,
  0x600012D0l /* 0x01B24C */,
  0x0500C0D7l /* 0x01B250 */,
  0x2CD0EE06l /* 0x01B254 */,
  0x406041D0l /* 0x01B258 */,
  0x58D0A700l /* 0x01B25C */,
  0x600012D0l /* 0x01B260 */,
  0x0500E4D7l /* 0x01B264 */,
  0x8772F4B1l /* 0x01B268 */,
  0x2B01FCB1l /* 0x01B26C */,
  0x473068D0l /* 0x01B270 */,
  0xEF00C7ECl /* 0x01B274 */,
  0x00D0C8D1l /* 0x01B278 */,
  0x473046C0l /* 0x01B27C */,
  0x01D0CCE8l /* 0x01B280 */,
  0x0000C507l /* 0x01B284 */,
  0x0CD0EE06l /* 0x01B288 */,
  0x60104070l /* 0x01B28C */,
  0x40607FB0l /* 0x01B290 */,
  0x2CD0EA04l /* 0x01B294 */,
  0x406042D0l /* 0x01B298 */,
  0x14D0EF06l /* 0x01B29C */,
  0x60104070l /* 0x01B2A0 */,
  0x490883EDl /* 0x01B2A4 */,
  0x3CD0EF06l /* 0x01B2A8 */,
  0x40624D02l /* 0x01B2AC */,
  0x00D06000l /* 0x01B2B0 */,
  0x49084062l /* 0x01B2B4 */,
  0x00D02007l /* 0x01B2B8 */,
  0x80628D02l /* 0x01B2BC */,
  0x04D06000l /* 0x01B2C0 */,
  0x49088062l /* 0x01B2C4 */,
  0x49094D00l /* 0x01B2C8 */,
  0x04D02007l /* 0x01B2CC */,
  0xC062CD02l /* 0x01B2D0 */,
  0x08D06000l /* 0x01B2D4 */,
  0x8908C062l /* 0x01B2D8 */,
  0x08D02007l /* 0x01B2DC */,
  0xC061CD01l /* 0x01B2E0 */,
  0x0CD06000l /* 0x01B2E4 */,
  0x8908C061l /* 0x01B2E8 */,
  0x0CD02007l /* 0x01B2EC */,
  0xC06BCD0Bl /* 0x01B2F0 */,
  0x10D06000l /* 0x01B2F4 */,
  0x4908C06Bl /* 0x01B2F8 */,
  0xC9084D00l /* 0x01B2FC */,
  0x10D02007l /* 0x01B300 */,
  0x006C0D0Cl /* 0x01B304 */,
  0x14D06000l /* 0x01B308 */,
  0x090A006Cl /* 0x01B30C */,
  0x60000D03l /* 0x01B310 */,
  0x006318D0l /* 0x01B314 */,
  0x5FD02000l /* 0x01B318 */,
  0x5C104C40l /* 0x01B31C */,
  0x20D02300l /* 0x01B320 */,
  0x1B100C40l /* 0x01B324 */,
  0x44D00130l /* 0x01B328 */,
  0x42104030l /* 0x01B32C */,
  0x18D02007l /* 0x01B330 */,
  0x81DC4060l /* 0x01B334 */,
  0x78E5E011l /* 0x01B338 */,
  0x78EDE211l /* 0x01B33C */,
  0x78E5E01Bl /* 0x01B340 */,
  0x78EDE11Bl /* 0x01B344 */,
  0x78E5201Cl /* 0x01B348 */,
  0x78ED271Cl /* 0x01B34C */,
  0x75E8201Cl /* 0x01B350 */,
  0x85E8211Cl /* 0x01B354 */,
  0x98E8221Cl /* 0x01B358 */,
  0xABE8231Cl /* 0x01B35C */,
  0xBEE8241Cl /* 0x01B360 */,
  0xD1E8251Cl /* 0x01B364 */,
  0xDEE8261Cl /* 0x01B368 */,
  0xE5E8271Cl /* 0x01B36C */,
  0x6F0078E1l /* 0x01B370 */,
  0x48DC58D3l /* 0x01B374 */,
  0xECE8E011l /* 0x01B378 */,
  0x5AD36F00l /* 0x01B37C */,
  0xE1114ADCl /* 0x01B380 */,
  0x6F00ECE8l /* 0x01B384 */,
  0x4CDC5AD3l /* 0x01B388 */,
  0xECE8E211l /* 0x01B38C */,
  0x6F0078E1l /* 0x01B390 */,
  0x200058D3l /* 0x01B394 */,
  0xE01150DCl /* 0x01B398 */,
  0x6F00ECE8l /* 0x01B39C */,
  0x20005AD3l /* 0x01B3A0 */,
  0xE11154DCl /* 0x01B3A4 */,
  0x6F00ECE8l /* 0x01B3A8 */,
  0x200054D3l /* 0x01B3AC */,
  0xE21158DCl /* 0x01B3B0 */,
  0x78E1ECE8l /* 0x01B3B4 */,
  0x54D36F00l /* 0x01B3B8 */,
  0x58DC2000l /* 0x01B3BC */,
  0xECE8E011l /* 0x01B3C0 */,
  0x5AD36F00l /* 0x01B3C4 */,
  0x5EDC2000l /* 0x01B3C8 */,
  0xECE8E111l /* 0x01B3CC */,
  0x4ED36F00l /* 0x01B3D0 */,
  0x64DC2000l /* 0x01B3D4 */,
  0xECE8E211l /* 0x01B3D8 */,
  0x6F0078E1l /* 0x01B3DC */,
  0x200050D3l /* 0x01B3E0 */,
  0xE01160DCl /* 0x01B3E4 */,
  0x6F00ECE8l /* 0x01B3E8 */,
  0x200050D3l /* 0x01B3EC */,
  0xE11168DCl /* 0x01B3F0 */,
  0x6F00ECE8l /* 0x01B3F4 */,
  0x200048D3l /* 0x01B3F8 */,
  0xE2115CDCl /* 0x01B3FC */,
  0x78E1ECE8l /* 0x01B400 */,
  0x50D36F00l /* 0x01B404 */,
  0x68DC2000l /* 0x01B408 */,
  0xECE8E011l /* 0x01B40C */,
  0x50D36F00l /* 0x01B410 */,
  0x72DC2000l /* 0x01B414 */,
  0xECE8E111l /* 0x01B418 */,
  0x5AD36F00l /* 0x01B41C */,
  0x7CDC2000l /* 0x01B420 */,
  0xECE8E211l /* 0x01B424 */,
  0x6F0078E1l /* 0x01B428 */,
  0x200048D3l /* 0x01B42C */,
  0xE01170DCl /* 0x01B430 */,
  0x6F00ECE8l /* 0x01B434 */,
  0x20005AD3l /* 0x01B438 */,
  0xE1117CDCl /* 0x01B43C */,
  0x78E1ECE8l /* 0x01B440 */,
  0x44D36F00l /* 0x01B444 */,
  0x78DC2000l /* 0x01B448 */,
  0xECE8E011l /* 0x01B44C */,
  0x6F0078E1l /* 0x01B450 */,
  0x210040D3l /* 0x01B454 */,
  0xE01140DCl /* 0x01B458 */,
  0x78E1ECE8l /* 0x01B45C */,
  0x2CD02007l /* 0x01B460 */,
  0x40634070l /* 0x01B464 */,
  0x30D02007l /* 0x01B468 */,
  0x406C8070l /* 0x01B46C */,
  0xF9F84D30l /* 0x01B470 */,
  0xF9F8B130l /* 0x01B474 */,
  0x2B0000E1l /* 0x01B478 */,
  0x407038D0l /* 0x01B47C */,
  0x00FD6210l /* 0x01B480 */,
  0x78E182DCl /* 0x01B484 */,
  0xBAB38DC3l /* 0x01B488 */,
  0x00D0EA04l /* 0x01B48C */,
  0x30100070l /* 0x01B490 */,
  0xEF060DE9l /* 0x01B494 */,
  0x007010D0l /* 0x01B498 */,
  0x0DE92010l /* 0x01B49C */,
  0x4EC080C3l /* 0x01B4A0 */,
  0x4D3046B0l /* 0x01B4A4 */,
  0x4EC313E9l /* 0x01B4A8 */,
  0x6B0546B3l /* 0x01B4AC */,
  0x40C020D0l /* 0x01B4B0 */,
  0x24D06F00l /* 0x01B4B4 */,
  0x6B050160l /* 0x01B4B8 */,
  0x41D024D0l /* 0x01B4BC */,
  0xEB044060l /* 0x01B4C0 */,
  0x407004D0l /* 0x01B4C4 */,
  0x404020D0l /* 0x01B4C8 */,
  0xE01B2EF9l /* 0x01B4CC */,
  0xC4DB29E9l /* 0x01B4D0 */,
  0x0CD02007l /* 0x01B4D4 */,
  0xEE06C06Bl /* 0x01B4D8 */,
  0x50D034D0l /* 0x01B4DC */,
  0x32E14060l /* 0x01B4E0 */,
  0x34D0EE06l /* 0x01B4E4 */,
  0x406040D0l /* 0x01B4E8 */,
  0xE01B40D0l /* 0x01B4EC */,
  0xE41B38E9l /* 0x01B4F0 */,
  0x43D038E9l /* 0x01B4F4 */,
  0x18D06B05l /* 0x01B4F8 */,
  0xEE064060l /* 0x01B4FC */,
  0x407034D0l /* 0x01B500 */,
  0x4CFD6010l /* 0x01B504 */,
  0x701081D0l /* 0x01B508 */,
  0x83D056E9l /* 0x01B50C */,
  0x56E97410l /* 0x01B510 */,
  0x781084D0l /* 0x01B514 */,
  0x81D056E9l /* 0x01B518 */,
  0x56E150D0l /* 0x01B51C */,
  0x50D081D0l /* 0x01B520 */,
  0x56E9E011l /* 0x01B524 */,
  0x54D083D0l /* 0x01B528 */,
  0x56E9E111l /* 0x01B52C */,
  0x58D084D0l /* 0x01B530 */,
  0x5AF9E41Bl /* 0x01B534 */,
  0x50D081D0l /* 0x01B538 */,
  0x30D0EA04l /* 0x01B53C */,
  0x6B054060l /* 0x01B540 */,
  0x80601CD0l /* 0x01B544 */,
  0x28D06B05l /* 0x01B548 */,
  0x701082D0l /* 0x01B54C */,
  0x83D066E9l /* 0x01B550 */,
  0xEF068060l /* 0x01B554 */,
  0x406324D0l /* 0x01B558 */,
  0x28D0EF06l /* 0x01B55C */,
  0xEF06406Cl /* 0x01B560 */,
  0x4DC02CD0l /* 0x01B564 */,
  0x40604110l /* 0x01B568 */,
  0x58D0AA00l /* 0x01B56C */,
  0x600012D0l /* 0x01B570 */,
  0x0500C0D7l /* 0x01B574 */,
  0x20D0EE06l /* 0x01B578 */,
  0x7FB04070l /* 0x01B57C */,
  0x20074060l /* 0x01B580 */,
  0x4EC0B46Cl /* 0x01B584 */,
  0x83ED46B0l /* 0x01B588 */,
  0x6F004DC0l /* 0x01B58C */,
  0x0CB024D0l /* 0x01B590 */,
  0xC1C080C0l /* 0x01B594 */,
  0x8BE54230l /* 0x01B598 */,
  0x422040D0l /* 0x01B59C */,
  0xEF06C130l /* 0x01B5A0 */,
  0xC06014D0l /* 0x01B5A4 */,
  0x0D00090Al /* 0x01B5A8 */,
  0x90ED41B0l /* 0x01B5AC */,
  0x2CD0EF06l /* 0x01B5B0 */,
  0x406040D0l /* 0x01B5B4 */,
  0x58D0A700l /* 0x01B5B8 */,
  0x600012D0l /* 0x01B5BC */,
  0x0500E4D7l /* 0x01B5C0 */,
  0xFCFF0F00l /* 0x01B5C4 */,
  0x00000000l /* 0x01B5C8 */,
  0x10000000l /* 0x01B5CC */,
  0xF4FF0F00l /* 0x01B5D0 */,
  0xD8FF0F00l /* 0x01B5D4 */,
  0x20000000l /* 0x01B5D8 */,
  0x48000000l /* 0x01B5DC */,
  0xB8FF0F00l /* 0x01B5E0 */,
  0x8CFF0F00l /* 0x01B5E4 */,
  0x8C000000l /* 0x01B5E8 */,
  0xA8000000l /* 0x01B5EC */,
  0x00FF0F00l /* 0x01B5F0 */,
  0x20FF0F00l /* 0x01B5F4 */,
  0xAC010000l /* 0x01B5F8 */,
  0x0C010000l /* 0x01B5FC */,
  0x58FD0F00l /* 0x01B600 */,
  0xE4FE0F00l /* 0x01B604 */,
  0xFC030000l /* 0x01B608 */,
  0xF4000000l /* 0x01B60C */,
  0x48FA0F00l /* 0x01B610 */,
  0x90FF0F00l /* 0x01B614 */,
  0xE8070000l /* 0x01B618 */,
  0x68FF0F00l /* 0x01B61C */,
  0x74F50F00l /* 0x01B620 */,
  0x64020000l /* 0x01B624 */,
  0xA00D0000l /* 0x01B628 */,
  0xCCFA0F00l /* 0x01B62C */,
  0xE8EE0F00l /* 0x01B630 */,
  0x58090000l /* 0x01B634 */,
  0xD8140000l /* 0x01B638 */,
  0xC4F00F00l /* 0x01B63C */,
  0x3CE70F00l /* 0x01B640 */,
  0x70170000l /* 0x01B644 */,
  0xB01C0000l /* 0x01B648 */,
  0x20DD0F00l /* 0x01B64C */,
  0x94DF0F00l /* 0x01B650 */,
  0x28330000l /* 0x01B654 */,
  0xD4230000l /* 0x01B658 */,
  0x4CB40F00l /* 0x01B65C */,
  0x54D90F00l /* 0x01B660 */,
  0x6C750000l /* 0x01B664 */,
  0xD8280000l /* 0x01B668 */,
  0xB02E0F00l /* 0x01B66C */,
  0xCCD50F00l /* 0x01B670 */,
  0x2C890200l /* 0x01B674 */,
  0xA02A0400l /* 0x01B678 */,
  0x2C890200l /* 0x01B67C */,
  0xCCD50F00l /* 0x01B680 */,
  0xB02E0F00l /* 0x01B684 */,
  0xD8280000l /* 0x01B688 */,
  0x6C750000l /* 0x01B68C */,
  0x54D90F00l /* 0x01B690 */,
  0x4CB40F00l /* 0x01B694 */,
  0xD4230000l /* 0x01B698 */,
  0x28330000l /* 0x01B69C */,
  0x94DF0F00l /* 0x01B6A0 */,
  0x20DD0F00l /* 0x01B6A4 */,
  0xB01C0000l /* 0x01B6A8 */,
  0x70170000l /* 0x01B6AC */,
  0x3CE70F00l /* 0x01B6B0 */,
  0xC4F00F00l /* 0x01B6B4 */,
  0xD8140000l /* 0x01B6B8 */,
  0x58090000l /* 0x01B6BC */,
  0xE8EE0F00l /* 0x01B6C0 */,
  0xCCFA0F00l /* 0x01B6C4 */,
  0xA00D0000l /* 0x01B6C8 */,
  0x64020000l /* 0x01B6CC */,
  0x74F50F00l /* 0x01B6D0 */,
  0x68FF0F00l /* 0x01B6D4 */,
  0xE8070000l /* 0x01B6D8 */,
  0x90FF0F00l /* 0x01B6DC */,
  0x48FA0F00l /* 0x01B6E0 */,
  0xF4000000l /* 0x01B6E4 */,
  0xFC030000l /* 0x01B6E8 */,
  0xE4FE0F00l /* 0x01B6EC */,
  0x58FD0F00l /* 0x01B6F0 */,
  0x0C010000l /* 0x01B6F4 */,
  0xAC010000l /* 0x01B6F8 */,
  0x20FF0F00l /* 0x01B6FC */,
  0x00FF0F00l /* 0x01B700 */,
  0xA8000000l /* 0x01B704 */,
  0x8C000000l /* 0x01B708 */,
  0x8CFF0F00l /* 0x01B70C */,
  0xB8FF0F00l /* 0x01B710 */,
  0x48000000l /* 0x01B714 */,
  0x20000000l /* 0x01B718 */,
  0xD8FF0F00l /* 0x01B71C */,
  0xF4FF0F00l /* 0x01B720 */,
  0x10000000l /* 0x01B724 */,
  0x00000000l /* 0x01B728 */,
  0xFCFF0F00l /* 0x01B72C */,
  0x10D0EE06l /* 0x01B730 */,
  0x7FB04070l /* 0x01B734 */,
  0x80D34060l /* 0x01B738 */,
  0x80DB40D3l /* 0x01B73C */,
  0x30D0EA04l /* 0x01B740 */,
  0x38130073l /* 0x01B744 */,
  0x341314E8l /* 0x01B748 */,
  0x321314E8l /* 0x01B74C */,
  0x301314E8l /* 0x01B750 */,
  0x10D314E8l /* 0x01B754 */,
  0x38D0EF06l /* 0x01B758 */,
  0x20078071l /* 0x01B75C */,
  0xC07108D0l /* 0x01B760 */,
  0x0CD02007l /* 0x01B764 */,
  0x2007C07Bl /* 0x01B768 */,
  0x007C10D0l /* 0x01B76C */,
  0x28D0EF06l /* 0x01B770 */,
  0xEF06407Cl /* 0x01B774 */,
  0xC0722CD0l /* 0x01B778 */,
  0x14D02007l /* 0x01B77C */,
  0x23004071l /* 0x01B780 */,
  0x407034D0l /* 0x01B784 */,
  0x00702007l /* 0x01B788 */,
  0x32E82010l /* 0x01B78C */,
  0x60D02100l /* 0x01B790 */,
  0x83D06010l /* 0x01B794 */,
  0x5E108140l /* 0x01B798 */,
  0x013000D0l /* 0x01B79C */,
  0x02200210l /* 0x01B7A0 */,
  0x58D04021l /* 0x01B7A4 */,
  0x42E8E211l /* 0x01B7A8 */,
  0xE11154D0l /* 0x01B7AC */,
  0x50D042E8l /* 0x01B7B0 */,
  0x01300CC0l /* 0x01B7B4 */,
  0x5E1045C0l /* 0x01B7B8 */,
  0x02100120l /* 0x01B7BC */,
  0x414143D0l /* 0x01B7C0 */,
  0x20074021l /* 0x01B7C4 */,
  0x40611CD0l /* 0x01B7C8 */,
  0x40DB00DBl /* 0x01B7CC */,
  0xB9F8E41Bl /* 0x01B7D0 */,
  0x29842782l /* 0x01B7D4 */,
  0xAA002A80l /* 0x01B7D8 */,
  0x417050D0l /* 0x01B7DC */,
  0xAED02000l /* 0x01B7E0 */,
  0x84B08210l /* 0x01B7E4 */,
  0xC17A8A00l /* 0x01B7E8 */,
  0x7CB04220l /* 0x01B7EC */,
  0x8A0084B0l /* 0x01B7F0 */,
  0x4601C17Al /* 0x01B7F4 */,
  0x01D06400l /* 0x01B7F8 */,
  0x3F8038A0l /* 0x01B7FC */,
  0x6500C600l /* 0x01B800 */,
  0x460153DFl /* 0x01B804 */,
  0x47D02000l /* 0x01B808 */,
  0x0B1001D0l /* 0x01B80C */,
  0x36A00150l /* 0x01B810 */,
  0xA010B490l /* 0x01B814 */,
  0x00D0EF06l /* 0x01B818 */,
  0xEF068060l /* 0x01B81C */,
  0x806C04D0l /* 0x01B820 */,
  0x8FDC6600l /* 0x01B824 */,
  0xE20076A0l /* 0x01B828 */,
  0x34A005D0l /* 0x01B82C */,
  0x2100C600l /* 0x01B830 */,
  0x27A000D0l /* 0x01B834 */,
  0x00D03008l /* 0x01B838 */,
  0x29A00210l /* 0x01B83C */,
  0x20D02007l /* 0x01B840 */,
  0xEEC0807Bl /* 0x01B844 */,
  0x14D02602l /* 0x01B848 */,
  0xE010C0CAl /* 0x01B84C */,
  0x60D0B3FCl /* 0x01B850 */,
  0xC13081C0l /* 0x01B854 */,
  0x83C097F4l /* 0x01B858 */,
  0x82108120l /* 0x01B85C */,
  0x20D0F00Bl /* 0x01B860 */,
  0x48106DC0l /* 0x01B864 */,
  0x6CA04050l /* 0x01B868 */,
  0x00C03F80l /* 0x01B86C */,
  0x00C000C0l /* 0x01B870 */,
  0x00C000C0l /* 0x01B874 */,
  0x00C000C0l /* 0x01B878 */,
  0x04B002C0l /* 0x01B87C */,
  0xEB7A0A00l /* 0x01B880 */,
  0x02C0C22Al /* 0x01B884 */,
  0x402B1F10l /* 0x01B888 */,
  0x3FD02300l /* 0x01B88C */,
  0x0600404Bl /* 0x01B890 */,
  0xF00B8FE0l /* 0x01B894 */,
  0x6DC000D0l /* 0x01B898 */,
  0x40504810l /* 0x01B89C */,
  0x20076CA0l /* 0x01B8A0 */,
  0xC0D020D0l /* 0x01B8A4 */,
  0x2900C060l /* 0x01B8A8 */,
  0x407A28D0l /* 0x01B8AC */,
  0x2CD02900l /* 0x01B8B0 */,
  0xEF06807Al /* 0x01B8B4 */,
  0xC07A30D0l /* 0x01B8B8 */,
  0xC9F8E01Al /* 0x01B8BC */,
  0x4601E9CAl /* 0x01B8C0 */,
  0x3BCA4602l /* 0x01B8C4 */,
  0x0602152Al /* 0x01B8C8 */,
  0x28C0C600l /* 0x01B8CC */,
  0xD4E42A30l /* 0x01B8D0 */,
  0x292A2A3Al /* 0x01B8D4 */,
  0x28302BC0l /* 0x01B8D8 */,
  0xE8CADDE8l /* 0x01B8DC */,
  0x28D0EE06l /* 0x01B8E0 */,
  0x7FB04070l /* 0x01B8E4 */,
  0xAA004060l /* 0x01B8E8 */,
  0x12D060D0l /* 0x01B8EC */,
  0xC0D76000l /* 0x01B8F0 */,
  0x00000500l /* 0x01B8F4 */,
  0x31300BC0l /* 0x01B8F8 */,
  0xC5C034E5l /* 0x01B8FC */,
  0xE010DE10l /* 0x01B900 */,
  0xF0100DE4l /* 0x01B904 */,
  0xCFB016E4l /* 0x01B908 */,
  0xF1B0C510l /* 0x01B90C */,
  0x80D016E0l /* 0x01B910 */,
  0x432050D0l /* 0x01B914 */,
  0x14EC6010l /* 0x01B918 */,
  0xC1C090D0l /* 0x01B91C */,
  0xC250C510l /* 0x01B920 */,
  0xE41B00D8l /* 0x01B924 */,
  0x64001CF8l /* 0x01B928 */,
  0x38A000D0l /* 0x01B92C */,
  0x4AD26700l /* 0x01B930 */,
  0x0AD2E700l /* 0x01B934 */,
  0xA8D276A2l /* 0x01B938 */,
  0x88D22300l /* 0x01B93C */,
  0x2F4003D0l /* 0x01B940 */,
  0x811228E8l /* 0x01B944 */,
  0x31300BC0l /* 0x01B948 */,
  0xB131F9E4l /* 0x01B94C */,
  0xC907B131l /* 0x01B950 */,
  0xC813CD03l /* 0x01B954 */,
  0x0FC4D813l /* 0x01B958 */,
  0x3BE8201Cl /* 0x01B95C */,
  0x0D04C907l /* 0x01B960 */,
  0x18140814l /* 0x01B964 */,
  0x3BE8211Cl /* 0x01B968 */,
  0xC907B4F1l /* 0x01B96C */,
  0xC815CD05l /* 0x01B970 */,
  0x17C6D815l /* 0x01B974 */,
  0x49E8201Cl /* 0x01B978 */,
  0x0D06C907l /* 0x01B97C */,
  0x18160816l /* 0x01B980 */,
  0x49E8211Cl /* 0x01B984 */,
  0xE111B4F1l /* 0x01B988 */,
  0xE2114EE8l /* 0x01B98C */,
  0x8BE06DE8l /* 0x01B990 */,
  0xC4130909l /* 0x01B994 */,
  0xC0530D00l /* 0x01B998 */,
  0x5CE8201Cl /* 0x01B99C */,
  0x04140909l /* 0x01B9A0 */,
  0x00540D00l /* 0x01B9A4 */,
  0x5DE8211Cl /* 0x01B9A8 */,
  0x5DE0BBF1l /* 0x01B9AC */,
  0x09090FC4l /* 0x01B9B0 */,
  0x0D00C415l /* 0x01B9B4 */,
  0x201CC055l /* 0x01B9B8 */,
  0x09096BE8l /* 0x01B9BC */,
  0x0D000416l /* 0x01B9C0 */,
  0x211C0056l /* 0x01B9C4 */,
  0xBBF18BE8l /* 0x01B9C8 */,
  0x17C68BE0l /* 0x01B9CC */,
  0x090A8BE0l /* 0x01B9D0 */,
  0x0D00C813l /* 0x01B9D4 */,
  0x201CC053l /* 0x01B9D8 */,
  0x090A7BE8l /* 0x01B9DC */,
  0x0D000814l /* 0x01B9E0 */,
  0x211C0054l /* 0x01B9E4 */,
  0xC2F17CE8l /* 0x01B9E8 */,
  0x0FC47CE0l /* 0x01B9EC */,
  0xC815090Al /* 0x01B9F0 */,
  0xC0550D00l /* 0x01B9F4 */,
  0x8AE8201Cl /* 0x01B9F8 */,
  0x0816090Al /* 0x01B9FC */,
  0x00560D00l /* 0x01BA00 */,
  0x8BE8211Cl /* 0x01BA04 */,
  0x8BE0C2F1l /* 0x01BA08 */,
  0x1FD017C6l /* 0x01BA0C */,
  0xC0130340l /* 0x01BA10 */,
  0xC0150014l /* 0x01BA14 */,
  0x03C00016l /* 0x01BA18 */,
  0xC0131B10l /* 0x01BA1C */,
  0xC0150014l /* 0x01BA20 */,
  0x03D00016l /* 0x01BA24 */,
  0x21100540l /* 0x01BA28 */,
  0x2210A0E8l /* 0x01BA2C */,
  0x2310B1E8l /* 0x01BA30 */,
  0xD2E0C2E8l /* 0x01BA34 */,
  0x0FC0DF13l /* 0x01BA38 */,
  0xC023DF13l /* 0x01BA3C */,
  0x17C0DF15l /* 0x01BA40 */,
  0xC025DF15l /* 0x01BA44 */,
  0x10C01F14l /* 0x01BA48 */,
  0x00241F14l /* 0x01BA4C */,
  0x18C01F16l /* 0x01BA50 */,
  0x00261F16l /* 0x01BA54 */,
  0xDF13D2E0l /* 0x01BA58 */,
  0xDE130FC0l /* 0x01BA5C */,
  0xDF15C023l /* 0x01BA60 */,
  0xDE1517C0l /* 0x01BA64 */,
  0x1F14C025l /* 0x01BA68 */,
  0x1E1410C0l /* 0x01BA6C */,
  0x1F160024l /* 0x01BA70 */,
  0x1E1618C0l /* 0x01BA74 */,
  0xD2E00026l /* 0x01BA78 */,
  0x0FC0DF13l /* 0x01BA7C */,
  0xC023DD13l /* 0x01BA80 */,
  0x17C0DF15l /* 0x01BA84 */,
  0xC025DD15l /* 0x01BA88 */,
  0x10C01F14l /* 0x01BA8C */,
  0x00241D14l /* 0x01BA90 */,
  0x18C01F16l /* 0x01BA94 */,
  0x00261D16l /* 0x01BA98 */,
  0xDAF83013l /* 0x01BA9C */,
  0x34A4F4A3l /* 0x01BAA0 */,
  0x34A6F4A5l /* 0x01BAA4 */,
  0xEBE078B3l /* 0x01BAA8 */,
  0x90108FC0l /* 0x01BAAC */,
  0xF4A3B4A0l /* 0x01BAB0 */,
  0x901090C0l /* 0x01BAB4 */,
  0x34A4B4A0l /* 0x01BAB8 */,
  0x901097C0l /* 0x01BABC */,
  0xF4A5B4A0l /* 0x01BAC0 */,
  0x901098C0l /* 0x01BAC4 */,
  0x34A6B4A0l /* 0x01BAC8 */,
  0x3FD070B3l /* 0x01BACC */,
  0xEFEC0D30l /* 0x01BAD0 */,
  0xF13205F1l /* 0x01BAD4 */,
  0x28EC81B2l /* 0x01BAD8 */,
  0xF9E4A011l /* 0x01BADC */,
  0x3070EE06l /* 0x01BAE0 */,
  0x0E30BFB3l /* 0x01BAE4 */,
  0x05F121ECl /* 0x01BAE8 */,
  0xFAF82018l /* 0x01BAEC */,
  0x01D06400l /* 0x01BAF0 */,
  0xAA0038A0l /* 0x01BAF4 */,
  0x12D068D0l /* 0x01BAF8 */,
  0xC0D76000l /* 0x01BAFC */,
  0xE41B0500l /* 0x01BB00 */,
  0x60133AE9l /* 0x01BB04 */,
  0x21002EFDl /* 0x01BB08 */,
  0x0DC080D0l /* 0x01BB0C */,
  0x0FF50230l /* 0x01BB10 */,
  0x2AC08DC0l /* 0x01BB14 */,
  0x02302B30l /* 0x01BB18 */,
  0x022015F5l /* 0x01BB1C */,
  0x460180C0l /* 0x01BB20 */,
  0x02C036A2l /* 0x01BB24 */,
  0x0A0004B0l /* 0x01BB28 */,
  0x02C02B6Dl /* 0x01BB2C */,
  0x00221F10l /* 0x01BB30 */,
  0xC6000600l /* 0x01BB34 */,
  0x2BC0C22Al /* 0x01BB38 */,
  0x25E52A30l /* 0x01BB3C */,
  0x4601E9CAl /* 0x01BB40 */,
  0x460202CAl /* 0x01BB44 */,
  0xA8256825l /* 0x01BB48 */,
  0xC6000602l /* 0x01BB4C */,
  0x05E14233l /* 0x01BB50 */,
  0x4AD26700l /* 0x01BB54 */,
  0x0AD2E700l /* 0x01BB58 */,
  0xC50776A2l /* 0x01BB5C */,
  0x48D0AA00l /* 0x01BB60 */,
  0x650012D0l /* 0x01BB64 */,
  0x0500F8D7l /* 0x01BB68 */,
  0x4DFD6013l /* 0x01BB6C */,
  0x604043D0l /* 0x01BB70 */,
  0x46013CF9l /* 0x01BB74 */,
  0xEF0036A2l /* 0x01BB78 */,
  0x0D203CD0l /* 0x01BB7C */,
  0x54D02602l /* 0x01BB80 */,
  0x016D0A00l /* 0x01BB84 */,
  0x11040600l /* 0x01BB88 */,
  0x40D34DC8l /* 0x01BB8C */,
  0x6700C600l /* 0x01BB90 */,
  0xE7004AD2l /* 0x01BB94 */,
  0x76A20AD2l /* 0x01BB98 */,
  0x1300C507l /* 0x01BB9C */,
  0x13085BE9l /* 0x01BBA0 */,
  0x460220DAl /* 0x01BBA4 */,
  0xA8256825l /* 0x01BBA8 */,
  0x10008602l /* 0x01BBAC */,
  0x14045FE9l /* 0x01BBB0 */,
  0x12008EE1l /* 0x01BBB4 */,
  0x120875E9l /* 0x01BBB8 */,
  0x0DD02100l /* 0x01BBBC */,
  0x75ED2E30l /* 0x01BBC0 */,
  0xD705C0D8l /* 0x01BBC4 */,
  0xF00FE9A8l /* 0x01BBC8 */,
  0x2CCA00D0l /* 0x01BBCC */,
  0x2850081Al /* 0x01BBD0 */,
  0x03502100l /* 0x01BBD4 */,
  0x2CA03F80l /* 0x01BBD8 */,
  0x90BB1004l /* 0x01BBDC */,
  0x1100870Fl /* 0x01BBE0 */,
  0x11088EE9l /* 0x01BBE4 */,
  0xF00B1204l /* 0x01BBE8 */,
  0x2DCA20D0l /* 0x01BBEC */,
  0x005A081Al /* 0x01BBF0 */,
  0xEF002CAAl /* 0x01BBF4 */,
  0x21203CD0l /* 0x01BBF8 */,
  0x26023F80l /* 0x01BBFC */,
  0x0A00D4D7l /* 0x01BC00 */,
  0x5F18DF7Al /* 0x01BC04 */,
  0x2300612Bl /* 0x01BC08 */,
  0x5F187F4Bl /* 0x01BC0C */,
  0x40D8A12Bl /* 0x01BC10 */,
  0x1008870Fl /* 0x01BC14 */,
  0x18DAEE06l /* 0x01BC18 */,
  0x96F91400l /* 0x01BC1C */,
  0x1CDAEE06l /* 0x01BC20 */,
  0x3FB02870l /* 0x01BC24 */,
  0x14082860l /* 0x01BC28 */,
  0x20D0B00Bl /* 0x01BC2C */,
  0x081A2CCAl /* 0x01BC30 */,
  0x2CAA005Al /* 0x01BC34 */,
  0x20003F80l /* 0x01BC38 */,
  0xEF0020DAl /* 0x01BC3C */,
  0x28203CD0l /* 0x01BC40 */,
  0xA8E1A7E1l /* 0x01BC44 */,
  0xEB6A0A00l /* 0x01BC48 */,
  0x2BC0E82Al /* 0x01BC4C */,
  0xAFE52A30l /* 0x01BC50 */,
  0x282BE9CAl /* 0x01BC54 */,
  0x3F4B2300l /* 0x01BC58 */,
  0x870F1304l /* 0x01BC5C */,
  0x02B030C0l /* 0x01BC60 */,
  0x8D05C907l /* 0x01BC64 */,
  0xB6F501B0l /* 0x01BC68 */,
  0x30C0C507l /* 0x01BC6C */,
  0x090902B0l /* 0x01BC70 */,
  0x01B08D05l /* 0x01BC74 */,
  0xC507BDF5l /* 0x01BC78 */,
  0x02B030C0l /* 0x01BC7C */,
  0x8D05090Al /* 0x01BC80 */,
  0xC4F501B0l /* 0x01BC84 */,
  0x0000C507l /* 0x01BC88 */,
  0x30D0EF06l /* 0x01BC8C */,
  0xEF06C06Al /* 0x01BC90 */,
  0xC0622CD0l /* 0x01BC94 */,
  0x38D0EF06l /* 0x01BC98 */,
  0x20078061l /* 0x01BC9C */,
  0x806B20D0l /* 0x01BCA0 */,
  0x35FCA01Bl /* 0x01BCA4 */,
  0x14D02602l /* 0x01BCA8 */,
  0xA01BC0C0l /* 0x01BCAC */,
  0x60D035FCl /* 0x01BCB0 */,
  0x813B81C0l /* 0x01BCB4 */,
  0xAEC019F4l /* 0x01BCB8 */,
  0x82108120l /* 0x01BCBC */,
  0x20D0B00Bl /* 0x01BCC0 */,
  0x48106CC0l /* 0x01BCC4 */,
  0x6CA04050l /* 0x01BCC8 */,
  0x00C03F80l /* 0x01BCCC */,
  0x00C000C0l /* 0x01BCD0 */,
  0x00C000C0l /* 0x01BCD4 */,
  0x00C000C0l /* 0x01BCD8 */,
  0x04B002C0l /* 0x01BCDC */,
  0xC36A0A00l /* 0x01BCE0 */,
  0x02C0C220l /* 0x01BCE4 */,
  0x002B1F10l /* 0x01BCE8 */,
  0x3FD02300l /* 0x01BCEC */,
  0x0600004Bl /* 0x01BCF0 */,
  0xF00B11E0l /* 0x01BCF4 */,
  0x2CA000D0l /* 0x01BCF8 */,
  0x64F8E41Bl /* 0x01BCFC */,
  0xEE064601l /* 0x01BD00 */,
  0x407038D0l /* 0x01BD04 */,
  0x76826010l /* 0x01BD08 */,
  0x3F8074A0l /* 0x01BD0C */,
  0x3CD0EE06l /* 0x01BD10 */,
  0xE01CC07Cl /* 0x01BD14 */,
  0x01D06000l /* 0x01BD18 */,
  0x600038A0l /* 0x01BD1C */,
  0x37A000D0l /* 0x01BD20 */,
  0xC6003F80l /* 0x01BD24 */,
  0x00C000C0l /* 0x01BD28 */,
  0xEF064601l /* 0x01BD2C */,
  0x407000D0l /* 0x01BD30 */,
  0xF6816010l /* 0x01BD34 */,
  0x3F8074A0l /* 0x01BD38 */,
  0x04D0EF06l /* 0x01BD3C */,
  0xA01C807Cl /* 0x01BD40 */,
  0x01D02400l /* 0x01BD44 */,
  0x240038A0l /* 0x01BD48 */,
  0x37A000D0l /* 0x01BD4C */,
  0xC6003F80l /* 0x01BD50 */,
  0x80ECA011l /* 0x01BD54 */,
  0x24D0EE06l /* 0x01BD58 */,
  0x7FB04070l /* 0x01BD5C */,
  0xEF064060l /* 0x01BD60 */,
  0x40703CD0l /* 0x01BD64 */,
  0xA1056010l /* 0x01BD68 */,
  0x406008D0l /* 0x01BD6C */,
  0x18D02007l /* 0x01BD70 */,
  0x60104070l /* 0x01BD74 */,
  0x14D02007l /* 0x01BD78 */,
  0xEF064060l /* 0x01BD7C */,
  0x200838D0l /* 0x01BD80 */,
  0x806180D1l /* 0x01BD84 */,
  0x00C086E0l /* 0x01BD88 */,
  0x58D0A700l /* 0x01BD8C */,
  0x600012D0l /* 0x01BD90 */,
  0x0500ECD7l /* 0x01BD94 */,
  0x58D0A700l /* 0x01BD98 */,
  0x600012D0l /* 0x01BD9C */,
  0x0500FAD7l /* 0x01BDA0 */,
  0x8870E900l /* 0x01BDA4 */,
  0xE900BFB0l /* 0x01BDA8 */,
  0xEA048860l /* 0x01BDAC */,
  0x2805A871l /* 0x01BDB0 */,
  0x6B054075l /* 0x01BDB4 */,
  0xE111DC71l /* 0x01BDB8 */,
  0xE4110FE4l /* 0x01BDBC */,
  0xC1D110FCl /* 0x01BDC0 */,
  0x2C75EA04l /* 0x01BDC4 */,
  0x15F8A211l /* 0x01BDC8 */,
  0x6B0506D5l /* 0x01BDCC */,
  0xA010B870l /* 0x01BDD0 */,
  0x02D51AE8l /* 0x01BDD4 */,
  0x2200D4C4l /* 0x01BDD8 */,
  0xC1D0B070l /* 0x01BDDC */,
  0x21E88340l /* 0x01BDE0 */,
  0x2900C2D4l /* 0x01BDE4 */,
  0x29006872l /* 0x01BDE8 */,
  0xEE04AC72l /* 0x01BDEC */,
  0xA2149474l /* 0x01BDF0 */,
  0x230055F8l /* 0x01BDF4 */,
  0x9E10AC70l /* 0x01BDF8 */,
  0x98606B05l /* 0x01BDFC */,
  0x36E8A010l /* 0x01BE00 */,
  0x38E8A110l /* 0x01BE04 */,
  0x3AE8A210l /* 0x01BE08 */,
  0x3CE8A310l /* 0x01BE0C */,
  0x3DE00CD1l /* 0x01BE10 */,
  0x3DE008D1l /* 0x01BE14 */,
  0x3DE00ED1l /* 0x01BE18 */,
  0x46010AD1l /* 0x01BE1C */,
  0x30D02001l /* 0x01BE20 */,
  0x3F8000A0l /* 0x01BE24 */,
  0x2878E700l /* 0x01BE28 */,
  0x53E81500l /* 0x01BE2C */,
  0x6E0508B1l /* 0x01BE30 */,
  0x23002061l /* 0x01BE34 */,
  0x87109070l /* 0x01BE38 */,
  0x01980221l /* 0x01BE3C */,
  0x53E81600l /* 0x01BE40 */,
  0x00D82100l /* 0x01BE44 */,
  0x01A12051l /* 0x01BE48 */,
  0x8AC0C600l /* 0x01BE4C */,
  0x6A058930l /* 0x01BE50 */,
  0xEB04B860l /* 0x01BE54 */,
  0x10000478l /* 0x01BE58 */,
  0xA21165F8l /* 0x01BE5C */,
  0xA3117CE8l /* 0x01BE60 */,
  0xE70065F8l /* 0x01BE64 */,
  0x97006878l /* 0x01BE68 */,
  0xA2147CF8l /* 0x01BE6C */,
  0x9E0369E8l /* 0x01BE70 */,
  0x7882C5E8l /* 0x01BE74 */,
  0x80D03F80l /* 0x01BE78 */,
  0xB4602505l /* 0x01BE7C */,
  0x6700D2D7l /* 0x01BE80 */,
  0xC40740D0l /* 0x01BE84 */,
  0x25004AC6l /* 0x01BE88 */,
  0x37F28CD6l /* 0x01BE8C */,
  0x250049C6l /* 0x01BE90 */,
  0x37F290D6l /* 0x01BE94 */,
  0xC4E09E0Bl /* 0x01BE98 */,
  0x7EE8A214l /* 0x01BE9C */,
  0x250581D0l /* 0x01BEA0 */,
  0xA311AC60l /* 0x01BEA4 */,
  0x25059DE8l /* 0x01BEA8 */,
  0xA110B470l /* 0x01BEAC */,
  0x81D0C5E8l /* 0x01BEB0 */,
  0xB4602505l /* 0x01BEB4 */,
  0x3F807882l /* 0x01BEB8 */,
  0x6600D2D7l /* 0x01BEBC */,
  0xC40770D0l /* 0x01BEC0 */,
  0xA4702900l /* 0x01BEC4 */,
  0x250042C6l /* 0x01BEC8 */,
  0x37F298D6l /* 0x01BECC */,
  0xA0702900l /* 0x01BED0 */,
  0x250042C6l /* 0x01BED4 */,
  0x37F2AAD6l /* 0x01BED8 */,
  0x2505BBE0l /* 0x01BEDC */,
  0xA210B470l /* 0x01BEE0 */,
  0x82D0C5E8l /* 0x01BEE4 */,
  0xB4602505l /* 0x01BEE8 */,
  0xA10580D0l /* 0x01BEEC */,
  0x7882A460l /* 0x01BEF0 */,
  0xD2D73F80l /* 0x01BEF4 */,
  0x78D06600l /* 0x01BEF8 */,
  0x2900C407l /* 0x01BEFC */,
  0x8270A4D0l /* 0x01BF00 */,
  0x250042C6l /* 0x01BF04 */,
  0x37F28DD6l /* 0x01BF08 */,
  0xA0D02900l /* 0x01BF0C */,
  0x42C68270l /* 0x01BF10 */,
  0x9FD62500l /* 0x01BF14 */,
  0x9E0737F2l /* 0x01BF18 */,
  0x250580D0l /* 0x01BF1C */,
  0xE506A460l /* 0x01BF20 */,
  0xE5068C60l /* 0x01BF24 */,
  0x990B9060l /* 0x01BF28 */,
  0x1D078AD4l /* 0x01BF2C */,
  0xD3E81100l /* 0x01BF30 */,
  0xD2E81000l /* 0x01BF34 */,
  0xD2F8A211l /* 0x01BF38 */,
  0x90702400l /* 0x01BF3C */,
  0xD2E8A010l /* 0x01BF40 */,
  0xD3F8A210l /* 0x01BF44 */,
  0x1C074EF2l /* 0x01BF48 */,
  0xD7E81200l /* 0x01BF4C */,
  0xEA0449F2l /* 0x01BF50 */,
  0xE2147C78l /* 0x01BF54 */,
  0xE414E2E8l /* 0x01BF58 */,
  0xE614E1E8l /* 0x01BF5C */,
  0x9A04E2F8l /* 0x01BF60 */,
  0x9904E2E0l /* 0x01BF64 */,
  0xE5E8A211l /* 0x01BF68 */,
  0x9F04E6E0l /* 0x01BF6C */,
  0xE9F89E03l /* 0x01BF70 */,
  0xD108D004l /* 0x01BF74 */,
  0x87C0D208l /* 0x01BF78 */,
  0x8A1081B0l /* 0x01BF7C */,
  0x42588710l /* 0x01BF80 */,
  0xA211D408l /* 0x01BF84 */,
  0xF5E0F4E8l /* 0x01BF88 */,
  0xE1C8D404l /* 0x01BF8C */,
  0x44782505l /* 0x01BF90 */,
  0xC4682505l /* 0x01BF94 */,
  0xE0D7F801l /* 0x01BF98 */,
  0x23404048l /* 0x01BF9C */,
  0x01E94038l /* 0x01BFA0 */,
  0xA2118BD4l /* 0x01BFA4 */,
  0x14C215E9l /* 0x01BFA8 */,
  0x01B21F12l /* 0x01BFAC */,
  0x25050912l /* 0x01BFB0 */,
  0xE1110062l /* 0x01BFB4 */,
  0x210010E9l /* 0x01BFB8 */,
  0x7AC480DEl /* 0x01BFBC */,
  0x1EE144B4l /* 0x01BFC0 */,
  0xA0DE2000l /* 0x01BFC4 */,
  0x44B47AC4l /* 0x01BFC8 */,
  0x90DE1EE1l /* 0x01BFCC */,
  0x441453C4l /* 0x01BFD0 */,
  0x14C244B4l /* 0x01BFD4 */,
  0x091201B2l /* 0x01BFD8 */,
  0x00622505l /* 0x01BFDC */,
  0xA21193C0l /* 0x01BFE0 */,
  0x9F1022E9l /* 0x01BFE4 */,
  0xFAC081B0l /* 0x01BFE8 */,
  0xC3CDC4B0l /* 0x01BFEC */,
  0x89108A10l /* 0x01BFF0 */,
  0xA284C25Dl /* 0x01BFF4 */,
  0x02D12200l /* 0x01BFF8 */,
  0x9E10BAC0l /* 0x01BFFC */,
  0x23A10231l /* 0x01C000 */,
  0x8C702505l /* 0x01C004 */,
  0x4C642505l /* 0x01C008 */,
  0x37E99130l /* 0x01C00C */,
  0x25058CD4l /* 0x01C010 */,
  0x06000062l /* 0x01C014 */,
  0x3F807884l /* 0x01C018 */,
  0x280049C6l /* 0x01C01C */,
  0x37F29CD6l /* 0x01C020 */,
  0x28004AC6l /* 0x01C024 */,
  0x37F298D6l /* 0x01C028 */,
  0x280048C6l /* 0x01C02C */,
  0x00D795D6l /* 0x01C030 */,
  0x51C623F2l /* 0x01C034 */,
  0xABD62800l /* 0x01C038 */,
  0x23F200D7l /* 0x01C03C */,
  0x3F803884l /* 0x01C040 */,
  0x0078EB04l /* 0x01C044 */,
  0x55E99E03l /* 0x01C048 */,
  0x6B051004l /* 0x01C04C */,
  0x20111871l /* 0x01C050 */,
  0x22115DE9l /* 0x01C054 */,
  0x211160E9l /* 0x01C058 */,
  0x200066E9l /* 0x01C05C */,
  0x66E12058l /* 0x01C060 */,
  0x20582100l /* 0x01C064 */,
  0x200066E1l /* 0x01C068 */,
  0x045800D1l /* 0x01C06C */,
  0x250520C3l /* 0x01C070 */,
  0xA3110863l /* 0x01C074 */,
  0xA2116DE9l /* 0x01C078 */,
  0x85D071E9l /* 0x01C07C */,
  0xA8602505l /* 0x01C080 */,
  0x81D074E1l /* 0x01C084 */,
  0xA8602505l /* 0x01C088 */,
  0xE9E9A014l /* 0x01C08C */,
  0x8870E900l /* 0x01C090 */,
  0x80202001l /* 0x01C094 */,
  0x8860E900l /* 0x01C098 */,
  0x57003398l /* 0x01C09C */,
  0x66C699F9l /* 0x01C0A0 */,
  0x1D071C07l /* 0x01C0A4 */,
  0xF873E400l /* 0x01C0A8 */,
  0xF8800600l /* 0x01C0AC */,
  0x04F282D0l /* 0x01C0B0 */,
  0x9A1390C3l /* 0x01C0B4 */,
  0x9C108EC0l /* 0x01C0B8 */,
  0x9E108223l /* 0x01C0BC */,
  0x8FC08223l /* 0x01C0C0 */,
  0x0EC804F2l /* 0x01C0C4 */,
  0x98D02400l /* 0x01C0C8 */,
  0x20C1520Cl /* 0x01C0CC */,
  0x01B12011l /* 0x01C0D0 */,
  0x460196EDl /* 0x01C0D4 */,
  0xD605D705l /* 0x01C0D8 */,
  0xF3A89E09l /* 0x01C0DC */,
  0xD7093F80l /* 0x01C0E0 */,
  0xF3A8D609l /* 0x01C0E4 */,
  0x6E043F80l /* 0x01C0E8 */,
  0x11C1BCD0l /* 0x01C0EC */,
  0x3CB10111l /* 0x01C0F0 */,
  0x427C0A01l /* 0x01C0F4 */,
  0x20070600l /* 0x01C0F8 */,
  0x33A100D1l /* 0x01C0FC */,
  0x970B3EA3l /* 0x01C100 */,
  0x100B520Bl /* 0x01C104 */,
  0x4602110Bl /* 0x01C108 */,
  0x060280D5l /* 0x01C10C */,
  0x00D1A006l /* 0x01C110 */,
  0x2B0033A1l /* 0x01C114 */,
  0x7EA37ED3l /* 0x01C118 */,
  0x00D12006l /* 0x01C11C */,
  0x210033A1l /* 0x01C120 */,
  0x3EA108D1l /* 0x01C124 */,
  0x0A013CD1l /* 0x01C128 */,
  0xBCD06E04l /* 0x01C12C */,
  0x0600827Cl /* 0x01C130 */,
  0x37864601l /* 0x01C134 */,
  0xC6003F80l /* 0x01C138 */,
  0xBC70E400l /* 0x01C13C */,
  0x04F20600l /* 0x01C140 */,
  0x3F803886l /* 0x01C144 */,
  0x4EF249F2l /* 0x01C148 */,
  0x1C0019C8l /* 0x01C14C */,
  0x1C07D8E9l /* 0x01C150 */,
  0xDBE91D00l /* 0x01C154 */,
  0x46011D07l /* 0x01C158 */,
  0xE0D02001l /* 0x01C15C */,
  0xC0D0C0A0l /* 0x01C160 */,
  0xC1A0C1B0l /* 0x01C164 */,
  0xB880C600l /* 0x01C168 */,
  0xEE0480D4l /* 0x01C16C */,
  0x51079464l /* 0x01C170 */,
  0xF3A8F2E1l /* 0x01C174 */,
  0x46013F80l /* 0x01C178 */,
  0x00D12007l /* 0x01C17C */,
  0x3EA333A1l /* 0x01C180 */,
  0xC6003F80l /* 0x01C184 */,
  0xFBF99E03l /* 0x01C188 */,
  0x46024601l /* 0x01C18C */,
  0x95C53BCEl /* 0x01C190 */,
  0xC6000602l /* 0x01C194 */,
  0x80D0FBE1l /* 0x01C198 */,
  0x9C606E05l /* 0x01C19C */,
  0xEB0412D0l /* 0x01C1A0 */,
  0xEB044870l /* 0x01C1A4 */,
  0x0500CC77l /* 0x01C1A8 */,
  0x3F807886l /* 0x01C1AC */,
  0x10D16C02l /* 0x01C1B0 */,
  0x0DEA01B1l /* 0x01C1B4 */,
  0x13003798l /* 0x01C1B8 */,
  0x200108EAl /* 0x01C1BC */,
  0xC0A0E0D0l /* 0x01C1C0 */,
  0xC410C190l /* 0x01C1C4 */,
  0x00D4DC10l /* 0x01C1C8 */,
  0x01800334l /* 0x01C1CC */,
  0x19EE81B0l /* 0x01C1D0 */,
  0x3886C507l /* 0x01C1D4 */,
  0x6C023F80l /* 0x01C1D8 */,
  0x01B110D1l /* 0x01C1DC */,
  0x379804EAl /* 0x01C1E0 */,
  0x1DFA1300l /* 0x01C1E4 */,
  0xB6A604E2l /* 0x01C1E8 */,
  0x59C799C6l /* 0x01C1EC */,
  0x46165616l /* 0x01C1F0 */,
  0x59375C17l /* 0x01C1F4 */,
  0x5D565E17l /* 0x01C1F8 */,
  0x5D5660D7l /* 0x01C1FC */,
  0x9D467FD7l /* 0x01C200 */,
  0x1A570617l /* 0x01C204 */,
  0x8056200Dl /* 0x01C208 */,
  0xB4A674A6l /* 0x01C20C */,
  0xB6A6C507l /* 0x01C210 */,
  0x59C799C6l /* 0x01C214 */,
  0x46165016l /* 0x01C218 */,
  0x59375617l /* 0x01C21C */,
  0x5D565E17l /* 0x01C220 */,
  0x5D5670D7l /* 0x01C224 */,
  0xBF46EF00l /* 0x01C228 */,
  0x8056200Dl /* 0x01C22C */,
  0xB4A674A6l /* 0x01C230 */,
  0x6015C507l /* 0x01C234 */,
  0xC5074CEAl /* 0x01C238 */,
  0xC5071C0Bl /* 0x01C23C */,
  0x51EA6015l /* 0x01C240 */,
  0x1D0BC507l /* 0x01C244 */,
  0x0000C507l /* 0x01C248 */,
  0xA01540CEl /* 0x01C24C */,
  0x85E547EDl /* 0x01C250 */,
  0x6EFD6015l /* 0x01C254 */,
  0x6EF91D03l /* 0x01C258 */,
  0x6EE95203l /* 0x01C25C */,
  0x47E99D03l /* 0x01C260 */,
  0x1CD02505l /* 0x01C264 */,
  0xE011C071l /* 0x01C268 */,
  0x9D0B44F9l /* 0x01C26C */,
  0xC061C1B1l /* 0x01C270 */,
  0xBF156EE1l /* 0x01C274 */,
  0xA01550EDl /* 0x01C278 */,
  0xD6C18CE9l /* 0x01C27C */,
  0x44B956C9l /* 0x01C280 */,
  0x61E101D2l /* 0x01C284 */,
  0x56E99703l /* 0x01C288 */,
  0x58D9970Bl /* 0x01C28C */,
  0x58E1DCD1l /* 0x01C290 */,
  0xE0D15CD9l /* 0x01C294 */,
  0x0C000C00l /* 0x01C298 */,
  0x383200C2l /* 0x01C29C */,
  0x5FE50732l /* 0x01C2A0 */,
  0xC82161E1l /* 0x01C2A4 */,
  0x87354829l /* 0x01C2A8 */,
  0xB87C4A09l /* 0x01C2AC */,
  0xE411072El /* 0x01C2B0 */,
  0x970768F9l /* 0x01C2B4 */,
  0x8BED2012l /* 0x01C2B8 */,
  0x0C000C00l /* 0x01C2BC */,
  0x8BE100CEl /* 0x01C2C0 */,
  0x80D500D0l /* 0x01C2C4 */,
  0x210083B5l /* 0x01C2C8 */,
  0xC021E8D1l /* 0x01C2CC */,
  0x00D22004l /* 0x01C2D0 */,
  0x3E8033A2l /* 0x01C2D4 */,
  0x3E803E80l /* 0x01C2D8 */,
  0x20063E80l /* 0x01C2DC */,
  0x33A000D0l /* 0x01C2E0 */,
  0x5CD9FEA1l /* 0x01C2E4 */,
  0x86F52010l /* 0x01C2E8 */,
  0x44B93CB0l /* 0x01C2EC */,
  0x5CD986E1l /* 0x01C2F0 */,
  0x3CD06E04l /* 0x01C2F4 */,
  0x807C4A09l /* 0x01C2F8 */,
  0x26E2BFB5l /* 0x01C2FC */,
  0xE4D1A701l /* 0x01C300 */,
  0x25704779l /* 0x01C304 */,
  0x6EE92110l /* 0x01C308 */,
  0x97F92010l /* 0x01C30C */,
  0x20722505l /* 0x01C310 */,
  0x00CEB0E1l /* 0x01C314 */,
  0x256000D0l /* 0x01C318 */,
  0x25727CB9l /* 0x01C31C */,
  0xA8017CB9l /* 0x01C320 */,
  0x253000D0l /* 0x01C324 */,
  0xA701A3EDl /* 0x01C328 */,
  0x476968D9l /* 0x01C32C */,
  0x384003D0l /* 0x01C330 */,
  0x40C9003El /* 0x01C334 */,
  0xC3D14829l /* 0x01C338 */,
  0xE6414749l /* 0x01C33C */,
  0xA5598739l /* 0x01C340 */,
  0x6FF90730l /* 0x01C344 */,
  0xC0D1A006l /* 0x01C348 */,
  0x6F01F3A1l /* 0x01C34C */,
  0xFEA1FED1l /* 0x01C350 */,
  0xC0D12004l /* 0x01C354 */,
  0xA10FF3A1l /* 0x01C358 */,
  0xFEA1F2D1l /* 0x01C35C */,
  0xDFD1E804l /* 0x01C360 */,
  0x7E80FEA1l /* 0x01C364 */,
  0x3EA20312l /* 0x01C368 */,
  0x88251D12l /* 0x01C36C */,
  0x00D02006l /* 0x01C370 */,
  0x38B233A0l /* 0x01C374 */,
  0x50E13EA2l /* 0x01C378 */,
  0xA01540CEl /* 0x01C37C */,
  0x7AE53CEDl /* 0x01C380 */,
  0x63FD6015l /* 0x01C384 */,
  0x63E95203l /* 0x01C388 */,
  0x81F91D03l /* 0x01C38C */,
  0x45EDBF15l /* 0x01C390 */,
  0x81FDA015l /* 0x01C394 */,
  0x56C9D6C1l /* 0x01C398 */,
  0x01D244B9l /* 0x01C39C */,
  0x970356E1l /* 0x01C3A0 */,
  0x970B4BE9l /* 0x01C3A4 */,
  0xDCD158D9l /* 0x01C3A8 */,
  0x5CD94DE1l /* 0x01C3AC */,
  0x0C00E0D1l /* 0x01C3B0 */,
  0x00C20C00l /* 0x01C3B4 */,
  0x07323832l /* 0x01C3B8 */,
  0x56E154E5l /* 0x01C3BC */,
  0x4829C821l /* 0x01C3C0 */,
  0x4A098735l /* 0x01C3C4 */,
  0x072EB87Cl /* 0x01C3C8 */,
  0x5DF9E411l /* 0x01C3CC */,
  0x20129707l /* 0x01C3D0 */,
  0x0C0080EDl /* 0x01C3D4 */,
  0x00CE0C00l /* 0x01C3D8 */,
  0x00D080E1l /* 0x01C3DC */,
  0x83B580D5l /* 0x01C3E0 */,
  0xE8D12100l /* 0x01C3E4 */,
  0x2004C021l /* 0x01C3E8 */,
  0x33A200D2l /* 0x01C3EC */,
  0x3E803E80l /* 0x01C3F0 */,
  0x3E803E80l /* 0x01C3F4 */,
  0x00D02006l /* 0x01C3F8 */,
  0xFEA133A0l /* 0x01C3FC */,
  0x20105CD9l /* 0x01C400 */,
  0x3CB07BF5l /* 0x01C404 */,
  0x7BE144B9l /* 0x01C408 */,
  0x6E045CD9l /* 0x01C40C */,
  0x4A093CD0l /* 0x01C410 */,
  0xBFB5807Cl /* 0x01C414 */,
  0xA70126E2l /* 0x01C418 */,
  0x25706479l /* 0x01C41C */,
  0x63E92110l /* 0x01C420 */,
  0x63E92010l /* 0x01C424 */,
  0x00D000CEl /* 0x01C428 */,
  0x7CB92560l /* 0x01C42C */,
  0x7CB92572l /* 0x01C430 */,
  0x28D0A801l /* 0x01C434 */,
  0x94ED2530l /* 0x01C438 */,
  0x68D9A701l /* 0x01C43C */,
  0x6469A701l /* 0x01C440 */,
  0x384003D0l /* 0x01C444 */,
  0x40C9003El /* 0x01C448 */,
  0xC3D14829l /* 0x01C44C */,
  0xE6414749l /* 0x01C450 */,
  0xA5598739l /* 0x01C454 */,
  0x872588C5l /* 0x01C458 */,
  0x0730A535l /* 0x01C45C */,
  0x25C0A8E9l /* 0x01C460 */,
  0x64E10730l /* 0x01C464 */,
  0x63F91D03l /* 0x01C468 */,
  0xC0D1A006l /* 0x01C46C */,
  0x2701F3A1l /* 0x01C470 */,
  0xFEA1FED1l /* 0x01C474 */,
  0xC0D12004l /* 0x01C478 */,
  0xA10FF3A1l /* 0x01C47C */,
  0xFEA1F2D1l /* 0x01C480 */,
  0xDFD1E804l /* 0x01C484 */,
  0x2505FEA1l /* 0x01C488 */,
  0xFEA1E871l /* 0x01C48C */,
  0x3EA20312l /* 0x01C490 */,
  0x20061D12l /* 0x01C494 */,
  0xF3A1C0D1l /* 0x01C498 */,
  0x3EA238B2l /* 0x01C49C */,
  0x000045E1l /* 0x01C4A0 */,
  0x7AC940CEl /* 0x01C4A4 */,
  0x6C1944B9l /* 0x01C4A8 */,
  0xD30638F9l /* 0x01C4AC */,
  0x54F95103l /* 0x01C4B0 */,
  0x16303AC0l /* 0x01C4B4 */,
  0xC1D154EDl /* 0x01C4B8 */,
  0x55F91D03l /* 0x01C4BC */,
  0xB87C4A09l /* 0x01C4C0 */,
  0xBA353A2El /* 0x01C4C4 */,
  0x3FD02700l /* 0x01C4C8 */,
  0x5EF93840l /* 0x01C4CC */,
  0x00D02505l /* 0x01C4D0 */,
  0x002E0070l /* 0x01C4D4 */,
  0x0C000C00l /* 0x01C4D8 */,
  0x5EED3830l /* 0x01C4DC */,
  0x0C000C00l /* 0x01C4E0 */,
  0x5EE100CEl /* 0x01C4E4 */,
  0xD302C0D1l /* 0x01C4E8 */,
  0x5CD958E9l /* 0x01C4EC */,
  0x3CD06E04l /* 0x01C4F0 */,
  0x807C4A09l /* 0x01C4F4 */,
  0x42F9E011l /* 0x01C4F8 */,
  0x000026E2l /* 0x01C4FC */,
  0x200040CEl /* 0x01C500 */,
  0xA015A0DEl /* 0x01C504 */,
  0x20003DFDl /* 0x01C508 */,
  0x4A095CD9l /* 0x01C50C */,
  0x3A2EB87Cl /* 0x01C510 */,
  0x26E2BA35l /* 0x01C514 */,
  0x53E29409l /* 0x01C518 */,
  0xA8009405l /* 0x01C51C */,
  0x12D048D0l /* 0x01C520 */,
  0xC0D76000l /* 0x01C524 */,
  0xA8000500l /* 0x01C528 */,
  0x12D048D0l /* 0x01C52C */,
  0xC8D76000l /* 0x01C530 */,
  0xE01A0500l /* 0x01C534 */,
  0xA80067FAl /* 0x01C538 */,
  0x12D058D0l /* 0x01C53C */,
  0xC2D76000l /* 0x01C540 */,
  0x2BC00500l /* 0x01C544 */,
  0x73D02200l /* 0x01C548 */,
  0x72FA0130l /* 0x01C54C */,
  0x48D0A800l /* 0x01C550 */,
  0x600012D0l /* 0x01C554 */,
  0x0500C8D7l /* 0x01C558 */,
  0x7AFA2510l /* 0x01C55C */,
  0x50D0A800l /* 0x01C560 */,
  0x600012D0l /* 0x01C564 */,
  0x0500C0D7l /* 0x01C568 */,
  0x93FA2410l /* 0x01C56C */,
  0xE50600D0l /* 0x01C570 */,
  0x460114D0l /* 0x01C574 */,
  0x51040078l /* 0x01C578 */,
  0xC6000068l /* 0x01C57C */,
  0x620541D0l /* 0x01C580 */,
  0x406000D0l /* 0x01C584 */,
  0x10D06F05l /* 0x01C588 */,
  0x77D02200l /* 0x01C58C */,
  0xA1004060l /* 0x01C590 */,
  0x12D050D0l /* 0x01C594 */,
  0xC0D76000l /* 0x01C598 */,
  0x20000500l /* 0x01C59C */,
  0x96E259DCl /* 0x01C5A0 */,
  0x3FC0F1CFl /* 0x01C5A4 */,
  0xA4000600l /* 0x01C5A8 */,
  0x12D040D0l /* 0x01C5AC */,
  0xC0D76000l /* 0x01C5B0 */,
  0x2D050500l /* 0x01C5B4 */,
  0xA800C067l /* 0x01C5B8 */,
  0x12D060D0l /* 0x01C5BC */,
  0xD0D76900l /* 0x01C5C0 */,
  0x2D050500l /* 0x01C5C4 */,
  0xF2E2C077l /* 0x01C5C8 */,
  0xA0D0C907l /* 0x01C5CC */,
  0x2780C0DBl /* 0x01C5D0 */,
  0x2A80E980l /* 0x01C5D4 */,
  0x0D00A980l /* 0x01C5D8 */,
  0xB5EAA110l /* 0x01C5DC */,
  0x40C0C907l /* 0x01C5E0 */,
  0x60105810l /* 0x01C5E4 */,
  0x6BA0CBEAl /* 0x01C5E8 */,
  0x01304810l /* 0x01C5EC */,
  0xD1EA2010l /* 0x01C5F0 */,
  0x81B02BA0l /* 0x01C5F4 */,
  0x2782B1EEl /* 0x01C5F8 */,
  0x2A80A980l /* 0x01C5FC */,
  0x21003F80l /* 0x01C600 */,
  0x4A007CD0l /* 0x01C604 */,
  0x0600DE6Al /* 0x01C608 */,
  0x2400C507l /* 0x01C60C */,
  0x50D0CADBl /* 0x01C610 */,
  0xB9EE01BCl /* 0x01C614 */,
  0x240096E2l /* 0x01C618 */,
  0x10D0CDDBl /* 0x01C61C */,
  0xBEEE01BCl /* 0x01C620 */,
  0x07D096E2l /* 0x01C624 */,
  0x20400D98l /* 0x01C628 */,
  0x28D8E1EAl /* 0x01C62C */,
  0x08080038l /* 0x01C630 */,
  0x20100D00l /* 0x01C634 */,
  0xC907F0FAl /* 0x01C638 */,
  0x0D0002D8l /* 0x01C63C */,
  0xE9FA2010l /* 0x01C640 */,
  0x3FB8090Al /* 0x01C644 */,
  0x2318E3E2l /* 0x01C648 */,
  0x2110F0E6l /* 0x01C64C */,
  0x090AF0FAl /* 0x01C650 */,
  0xF2E200D8l /* 0x01C654 */,
  0x090C01D8l /* 0x01C658 */,
  0x3F803684l /* 0x01C65C */,
  0xCD0AF4AAl /* 0x01C660 */,
  0xC507F4AAl /* 0x01C664 */,
  0x2200F1F2l /* 0x01C668 */,
  0x2B3033D0l /* 0x01C66C */,
  0x940108E8l /* 0x01C670 */,
  0x84E100F8l /* 0x01C674 */,
  0x20D06C05l /* 0x01C678 */,
  0x01D82000l /* 0x01C67C */,
  0x03DC0068l /* 0x01C680 */,
  0x090B50DCl /* 0x01C684 */,
  0xAD0500D0l /* 0x01C688 */,
  0x1E60B0D7l /* 0x01C68C */,
  0x92059105l /* 0x01C690 */,
  0x4D019009l /* 0x01C694 */,
  0xAD05090Bl /* 0x01C698 */,
  0x1E60B4D7l /* 0x01C69C */,
  0x87E96011l /* 0x01C6A0 */,
  0x05C08D01l /* 0x01C6A4 */,
  0xEA0446C0l /* 0x01C6A8 */,
  0x827080D0l /* 0x01C6AC */,
  0x2DF8A210l /* 0x01C6B0 */,
  0x1AC84602l /* 0x01C6B4 */,
  0x23000602l /* 0x01C6B8 */,
  0xA030A0D0l /* 0x01C6BC */,
  0xED0436F8l /* 0x01C6C0 */,
  0xA1108870l /* 0x01C6C4 */,
  0xAB0542E8l /* 0x01C6C8 */,
  0xAB051CD8l /* 0x01C6CC */,
  0x40E0A4D0l /* 0x01C6D0 */,
  0xA1D02300l /* 0x01C6D4 */,
  0x3CE8A030l /* 0x01C6D8 */,
  0x5F101F10l /* 0x01C6DC */,
  0x20D8AB05l /* 0x01C6E0 */,
  0xA8D0AB05l /* 0x01C6E4 */,
  0x42602060l /* 0x01C6E8 */,
  0xA0110909l /* 0x01C6EC */,
  0xCD018FE9l /* 0x01C6F0 */,
  0xE0110909l /* 0x01C6F4 */,
  0xE41197E9l /* 0x01C6F8 */,
  0x0D029FEDl /* 0x01C6FC */,
  0x0D00490Al /* 0x01C700 */,
  0x0910490Al /* 0x01C704 */,
  0x40524D02l /* 0x01C708 */,
  0x4908A7E9l /* 0x01C70C */,
  0x21180D08l /* 0x01C710 */,
  0x890AAFF9l /* 0x01C714 */,
  0x49088D02l /* 0x01C718 */,
  0x4908CD02l /* 0x01C71C */,
  0x20130D03l /* 0x01C720 */,
  0xA70563E8l /* 0x01C724 */,
  0xAAF280D7l /* 0x01C728 */,
  0x49089109l /* 0x01C72C */,
  0x20100D00l /* 0x01C730 */,
  0x3EB36CE8l /* 0x01C734 */,
  0x80D7A905l /* 0x01C738 */,
  0x9209AAF2l /* 0x01C73C */,
  0x2118D7F2l /* 0x01C740 */,
  0x2200BAE9l /* 0x01C744 */,
  0x13002C78l /* 0x01C748 */,
  0x220078E8l /* 0x01C74C */,
  0x2B3033D0l /* 0x01C750 */,
  0xD7F278F8l /* 0x01C754 */,
  0x35D02200l /* 0x01C758 */,
  0x5BF92B30l /* 0x01C75C */,
  0xB4F9E012l /* 0x01C760 */,
  0x51DC03DCl /* 0x01C764 */,
  0x0D000909l /* 0x01C768 */,
  0xC0F92110l /* 0x01C76C */,
  0x8D03090Al /* 0x01C770 */,
  0xCD034908l /* 0x01C774 */,
  0x0D048908l /* 0x01C778 */,
  0x20148908l /* 0x01C77C */,
  0x0D00C3E9l /* 0x01C780 */,
  0x40210C10l /* 0x01C784 */,
  0x0D008908l /* 0x01C788 */,
  0x80210C10l /* 0x01C78C */,
  0x4D04090Bl /* 0x01C790 */,
  0x0D084908l /* 0x01C794 */,
  0xCBF92118l /* 0x01C798 */,
  0x0D00090Al /* 0x01C79C */,
  0x80220A10l /* 0x01C7A0 */,
  0x8D044908l /* 0x01C7A4 */,
  0xCD048908l /* 0x01C7A8 */,
  0x0D054909l /* 0x01C7AC */,
  0x460163C3l /* 0x01C7B0 */,
  0x3F803A83l /* 0x01C7B4 */,
  0x7A837B81l /* 0x01C7B8 */,
  0x80D7A205l /* 0x01C7BC */,
  0x0B0F3F80l /* 0x01C7C0 */,
  0x0600DE6El /* 0x01C7C4 */,
  0x4601C600l /* 0x01C7C8 */,
  0x3F803A83l /* 0x01C7CC */,
  0x7A837B81l /* 0x01C7D0 */,
  0xB0D72E00l /* 0x01C7D4 */,
  0x0B053F80l /* 0x01C7D8 */,
  0x0600DE6El /* 0x01C7DC */,
  0xC212C600l /* 0x01C7E0 */,
  0x2F000B53l /* 0x01C7E4 */,
  0x1E6388D7l /* 0x01C7E8 */,
  0x2118D7F2l /* 0x01C7EC */,
  0x2200D3E9l /* 0x01C7F0 */,
  0x13002C78l /* 0x01C7F4 */,
  0x2200CFE8l /* 0x01C7F8 */,
  0x2B3033D0l /* 0x01C7FC */,
  0xD7F2CFF8l /* 0x01C800 */,
  0x2200C2E0l /* 0x01C804 */,
  0x2B3035D0l /* 0x01C808 */,
  0x03DC44F9l /* 0x01C80C */,
  0x090952DCl /* 0x01C810 */,
  0x22100D00l /* 0x01C814 */,
  0xC90814F9l /* 0x01C818 */,
  0x49088D02l /* 0x01C81C */,
  0xD6EDA512l /* 0x01C820 */,
  0x41D301D3l /* 0x01C824 */,
  0xCD0281D3l /* 0x01C828 */,
  0xF6E8E012l /* 0x01C82C */,
  0x0D03090Al /* 0x01C830 */,
  0x2013090Al /* 0x01C834 */,
  0x2713DEE9l /* 0x01C838 */,
  0x4D03E6EDl /* 0x01C83C */,
  0x6013090Al /* 0x01C840 */,
  0x6813EEE9l /* 0x01C844 */,
  0x8D03F6EDl /* 0x01C848 */,
  0xFEE9A013l /* 0x01C84C */,
  0x06EEA713l /* 0x01C850 */,
  0xCD03890Bl /* 0x01C854 */,
  0x0D084908l /* 0x01C858 */,
  0x2118890Bl /* 0x01C85C */,
  0x0D040EFAl /* 0x01C860 */,
  0x3A834601l /* 0x01C864 */,
  0xBB823F80l /* 0x01C868 */,
  0xAB057A83l /* 0x01C86C */,
  0x3F8080D7l /* 0x01C870 */,
  0xDE6E0B06l /* 0x01C874 */,
  0xC6000600l /* 0x01C878 */,
  0x8ED72F00l /* 0x01C87C */,
  0x06004601l /* 0x01C880 */,
  0xFDA33CA4l /* 0x01C884 */,
  0x06001E64l /* 0x01C888 */,
  0xC2E0C600l /* 0x01C88C */,
  0xD0F92510l /* 0x01C890 */,
  0x4D018908l /* 0x01C894 */,
  0x8D010909l /* 0x01C898 */,
  0x35F96111l /* 0x01C89C */,
  0xCD01890Bl /* 0x01C8A0 */,
  0x0D084908l /* 0x01C8A4 */,
  0x2118890Bl /* 0x01C8A8 */,
  0x0D0213FAl /* 0x01C8AC */,
  0x4D024909l /* 0x01C8B0 */,
  0x60124909l /* 0x01C8B4 */,
  0x8D0218EAl /* 0x01C8B8 */,
  0xA0124909l /* 0x01C8BC */,
  0xCD021DEAl /* 0x01C8C0 */,
  0xE0124909l /* 0x01C8C4 */,
  0x0D0322EAl /* 0x01C8C8 */,
  0x27EA2013l /* 0x01C8CC */,
  0x631143E1l /* 0x01C8D0 */,
  0x490843F9l /* 0x01C8D4 */,
  0x60134D03l /* 0x01C8D8 */,
  0x49083DE9l /* 0x01C8DC */,
  0xC9088D03l /* 0x01C8E0 */,
  0xC908CD03l /* 0x01C8E4 */,
  0x20140D04l /* 0x01C8E8 */,
  0xC2E02CEAl /* 0x01C8EC */,
  0x32D02200l /* 0x01C8F0 */,
  0x4BF92B30l /* 0x01C8F4 */,
  0x9FF2C0D0l /* 0x01C8F8 */,
  0x2200C5E0l /* 0x01C8FC */,
  0x2B3038D0l /* 0x01C900 */,
  0xA80055F9l /* 0x01C904 */,
  0x12D050D0l /* 0x01C908 */,
  0xC0D76000l /* 0x01C90C */,
  0xA8000500l /* 0x01C910 */,
  0x12D058D0l /* 0x01C914 */,
  0xC0D76000l /* 0x01C918 */,
  0x3DB00500l /* 0x01C91C */,
  0x06B067E9l /* 0x01C920 */,
  0x69F1BDF9l /* 0x01C924 */,
  0x9FF2C0D0l /* 0x01C928 */,
  0x38D02200l /* 0x01C92C */,
  0x4FE92B30l /* 0x01C930 */,
  0x69F131E2l /* 0x01C934 */,
  0x90054FE1l /* 0x01C938 */,
  0x460163C3l /* 0x01C93C */,
  0x3F803A83l /* 0x01C940 */,
  0x7A837B81l /* 0x01C944 */,
  0x80D7A205l /* 0x01C948 */,
  0x0B083F80l /* 0x01C94C */,
  0x0600DE6El /* 0x01C950 */,
  0x4601C600l /* 0x01C954 */,
  0x3F803A83l /* 0x01C958 */,
  0x7A837B81l /* 0x01C95C */,
  0xB0D72E00l /* 0x01C960 */,
  0x0B053F80l /* 0x01C964 */,
  0x0600DE6El /* 0x01C968 */,
  0xC507C600l /* 0x01C96C */,
  0x40DC2400l /* 0x01C970 */,
  0x240034E2l /* 0x01C974 */,
  0xA205C1DBl /* 0x01C978 */,
  0x5E7180D7l /* 0x01C97C */,
  0x1EEC01BCl /* 0x01C980 */,
  0x240034E2l /* 0x01C984 */,
  0xA205C2DBl /* 0x01C988 */,
  0x9E7184D7l /* 0x01C98C */,
  0x45EC01BCl /* 0x01C990 */,
  0x240034E2l /* 0x01C994 */,
  0xA205C3DBl /* 0x01C998 */,
  0xDE7188D7l /* 0x01C99C */,
  0x49EC01BCl /* 0x01C9A0 */,
  0x240034E2l /* 0x01C9A4 */,
  0xA205C4DBl /* 0x01C9A8 */,
  0xDE7188D7l /* 0x01C9AC */,
  0x4BEC01BCl /* 0x01C9B0 */,
  0x240034E2l /* 0x01C9B4 */,
  0xA205C5DBl /* 0x01C9B8 */,
  0x5E7290D7l /* 0x01C9BC */,
  0x53EC01BCl /* 0x01C9C0 */,
  0x240034E2l /* 0x01C9C4 */,
  0x01BCC6DBl /* 0x01C9C8 */,
  0x34E257ECl /* 0x01C9CC */,
  0xC7DB2400l /* 0x01C9D0 */,
  0x01BCC0D2l /* 0x01C9D4 */,
  0x34E27EECl /* 0x01C9D8 */,
  0x4EDC2400l /* 0x01C9DC */,
  0x240034E2l /* 0x01C9E0 */,
  0x34E250DCl /* 0x01C9E4 */,
  0x51DC2400l /* 0x01C9E8 */,
  0x240034E2l /* 0x01C9EC */,
  0xA205D2DBl /* 0x01C9F0 */,
  0x1E74ACD7l /* 0x01C9F4 */,
  0x8DEC01BCl /* 0x01C9F8 */,
  0x240034E2l /* 0x01C9FC */,
  0x01BCD3DBl /* 0x01CA00 */,
  0x34E29AECl /* 0x01CA04 */,
  0x61DC2400l /* 0x01CA08 */,
  0x240034E2l /* 0x01CA0C */,
  0x34E260DCl /* 0x01CA10 */,
  0xE2DB2400l /* 0x01CA14 */,
  0x80D7AB05l /* 0x01CA18 */,
  0x01BC9E72l /* 0x01CA1C */,
  0x34E2DEECl /* 0x01CA20 */,
  0xE3DB2400l /* 0x01CA24 */,
  0x88D7AB05l /* 0x01CA28 */,
  0x01BC1E73l /* 0x01CA2C */,
  0x34E2E9ECl /* 0x01CA30 */,
  0xE4DB2400l /* 0x01CA34 */,
  0x88D7AB05l /* 0x01CA38 */,
  0x01BC1E73l /* 0x01CA3C */,
  0x34E2EBECl /* 0x01CA40 */,
  0xE5DB2400l /* 0x01CA44 */,
  0x8CD7AB05l /* 0x01CA48 */,
  0x01BC5E73l /* 0x01CA4C */,
  0x34E2EFECl /* 0x01CA50 */,
  0xE6DB2400l /* 0x01CA54 */,
  0x8CD7AB05l /* 0x01CA58 */,
  0x01BC5E73l /* 0x01CA5C */,
  0x34E2F1ECl /* 0x01CA60 */,
  0xE7DB2400l /* 0x01CA64 */,
  0x90D7AB05l /* 0x01CA68 */,
  0x01BC9E73l /* 0x01CA6C */,
  0x34E2F4ECl /* 0x01CA70 */,
  0xE8DB2400l /* 0x01CA74 */,
  0x90D7AB05l /* 0x01CA78 */,
  0x01BC9E73l /* 0x01CA7C */,
  0x34E2F6ECl /* 0x01CA80 */,
  0xE9DB2400l /* 0x01CA84 */,
  0xFDEC01BCl /* 0x01CA88 */,
  0x240034E2l /* 0x01CA8C */,
  0x01BCEADBl /* 0x01CA90 */,
  0x34E223EDl /* 0x01CA94 */,
  0xEBDB2400l /* 0x01CA98 */,
  0x29ED01BCl /* 0x01CA9C */,
  0x240034E2l /* 0x01CAA0 */,
  0x01BCECDBl /* 0x01CAA4 */,
  0x34E22DEDl /* 0x01CAA8 */,
  0xEDDB2400l /* 0x01CAAC */,
  0x31ED01BCl /* 0x01CAB0 */,
  0x240034E2l /* 0x01CAB4 */,
  0x01BCEEDBl /* 0x01CAB8 */,
  0x34E234EDl /* 0x01CABC */,
  0xEFDB2400l /* 0x01CAC0 */,
  0x43ED01BCl /* 0x01CAC4 */,
  0x240034E2l /* 0x01CAC8 */,
  0x34E271DCl /* 0x01CACC */,
  0x3FC0F1CFl /* 0x01CAD0 */,
  0xA4000600l /* 0x01CAD4 */,
  0x12D040D0l /* 0x01CAD8 */,
  0xC0D76000l /* 0x01CADC */,
  0x00000500l /* 0x01CAE0 */,
  0x24D06C05l /* 0x01CAE4 */,
  0x01D82000l /* 0x01CAE8 */,
  0x62050068l /* 0x01CAEC */,
  0x200014D0l /* 0x01CAF0 */,
  0x006800D8l /* 0x01CAF4 */,
  0x53DC03DCl /* 0x01CAF8 */,
  0xA2054908l /* 0x01CAFC */,
  0xDE78A0D7l /* 0x01CB00 */,
  0x49098D02l /* 0x01CB04 */,
  0xDE689305l /* 0x01CB08 */,
  0x8909CD02l /* 0x01CB0C */,
  0x6EECF712l /* 0x01CB10 */,
  0x49080D03l /* 0x01CB14 */,
  0x1EB00CC0l /* 0x01CB18 */,
  0x74EC1DB0l /* 0x01CB1C */,
  0x89090D08l /* 0x01CB20 */,
  0x7AF82118l /* 0x01CB24 */,
  0x89094D03l /* 0x01CB28 */,
  0x0DC00DC0l /* 0x01CB2C */,
  0x1DB01EB0l /* 0x01CB30 */,
  0x8D037FECl /* 0x01CB34 */,
  0x0EC04908l /* 0x01CB38 */,
  0x1DB01EB0l /* 0x01CB3C */,
  0x0D0085ECl /* 0x01CB40 */,
  0x01104908l /* 0x01CB44 */,
  0x0D008022l /* 0x01CB48 */,
  0x80220210l /* 0x01CB4C */,
  0x3A834601l /* 0x01CB50 */,
  0xBB823F80l /* 0x01CB54 */,
  0xAB057A83l /* 0x01CB58 */,
  0x3F80ACD7l /* 0x01CB5C */,
  0xDE6E0B04l /* 0x01CB60 */,
  0xC6000600l /* 0x01CB64 */,
  0xEA04D7F2l /* 0x01CB68 */,
  0x007000D0l /* 0x01CB6C */,
  0x4FF82210l /* 0x01CB70 */,
  0x30D8A400l /* 0x01CB74 */,
  0x3F8036A8l /* 0x01CB78 */,
  0x18003498l /* 0x01CB7C */,
  0x211851F8l /* 0x01CB80 */,
  0x90018BE8l /* 0x01CB84 */,
  0x22005AF8l /* 0x01CB88 */,
  0x2B3032D0l /* 0x01CB8C */,
  0xC1D065F8l /* 0x01CB90 */,
  0x53E09FF2l /* 0x01CB94 */,
  0x35D02200l /* 0x01CB98 */,
  0x5FF82B30l /* 0x01CB9C */,
  0x2200F1F2l /* 0x01CBA0 */,
  0x2B3032D0l /* 0x01CBA4 */,
  0xC1D065F8l /* 0x01CBA8 */,
  0x97F09FF2l /* 0x01CBAC */,
  0x8C606505l /* 0x01CBB0 */,
  0x58D0A800l /* 0x01CBB4 */,
  0x600012D0l /* 0x01CBB8 */,
  0x0500C0D7l /* 0x01CBBC */,
  0xF2DB2400l /* 0x01CBC0 */,
  0x01BCC0D2l /* 0x01CBC4 */,
  0x8EE018ECl /* 0x01CBC8 */,
  0xF3DB2400l /* 0x01CBCC */,
  0x01BC00D3l /* 0x01CBD0 */,
  0x8EE01EECl /* 0x01CBD4 */,
  0xF4DB2400l /* 0x01CBD8 */,
  0x22EC01BCl /* 0x01CBDC */,
  0x24008EE0l /* 0x01CBE0 */,
  0x40D3F5DBl /* 0x01CBE4 */,
  0x29EC01BCl /* 0x01CBE8 */,
  0x24008EE0l /* 0x01CBEC */,
  0x80D3F6DBl /* 0x01CBF0 */,
  0x2FEC01BCl /* 0x01CBF4 */,
  0x25008EE0l /* 0x01CBF8 */,
  0x8EE040DCl /* 0x01CBFC */,
  0x3FC0F1CFl /* 0x01CC00 */,
  0xA4000600l /* 0x01CC04 */,
  0x12D040D0l /* 0x01CC08 */,
  0xC0D76000l /* 0x01CC0C */,
  0x68000500l /* 0x01CC10 */,
  0x619100D1l /* 0x01CC14 */,
  0x99F84441l /* 0x01CC18 */,
  0x23912283l /* 0x01CC1C */,
  0x02111E11l /* 0x01CC20 */,
  0x63912281l /* 0x01CC24 */,
  0x44115E11l /* 0x01CC28 */,
  0x45860531l /* 0x01CC2C */,
  0x4691BFD1l /* 0x01CC30 */,
  0x46415511l /* 0x01CC34 */,
  0x42117EB1l /* 0x01CC38 */,
  0x03110531l /* 0x01CC3C */,
  0x8D915FD1l /* 0x01CC40 */,
  0x06218541l /* 0x01CC44 */,
  0xC230C4C0l /* 0x01CC48 */,
  0x2281C0F4l /* 0x01CC4C */,
  0x9E10A390l /* 0x01CC50 */,
  0x22808410l /* 0x01CC54 */,
  0x9E11A391l /* 0x01CC58 */,
  0x82318211l /* 0x01CC5C */,
  0xC6208311l /* 0x01CC60 */,
  0xA01084C0l /* 0x01CC64 */,
  0x8620C4F4l /* 0x01CC68 */,
  0x0000C507l /* 0x01CC6C */,
  0xC7F9E01Al /* 0x01CC70 */,
  0xBC702900l /* 0x01CC74 */,
  0xBC606205l /* 0x01CC78 */,
  0x2A058230l /* 0x01CC7C */,
  0x9E60B0D7l /* 0x01CC80 */,
  0x2B050CD0l /* 0x01CC84 */,
  0x9E6080D7l /* 0x01CC88 */,
  0x01B0BCB7l /* 0x01CC8C */,
  0x03DC0DF8l /* 0x01CC90 */,
  0xAD0555DCl /* 0x01CC94 */,
  0xAD05B076l /* 0x01CC98 */,
  0x1AC5F076l /* 0x01CC9C */,
  0x9AC55BC5l /* 0x01CCA0 */,
  0x1AC6DBC5l /* 0x01CCA4 */,
  0x75F15BC6l /* 0x01CCA8 */,
  0xA0D7A205l /* 0x01CCAC */,
  0xED04DE78l /* 0x01CCB0 */,
  0x20100870l /* 0x01CCB4 */,
  0x1FD056F8l /* 0x01CCB8 */,
  0x20400D98l /* 0x01CCBC */,
  0x281055E8l /* 0x01CCC0 */,
  0x301049E8l /* 0x01CCC4 */,
  0x38103DE8l /* 0x01CCC8 */,
  0xD0E135E8l /* 0x01CCCC */,
  0x8D01C907l /* 0x01CCD0 */,
  0xCD01C907l /* 0x01CCD4 */,
  0x090AC507l /* 0x01CCD8 */,
  0x30F04D01l /* 0x01CCDC */,
  0x42118908l /* 0x01CCE0 */,
  0x40510D00l /* 0x01CCE4 */,
  0x890A58E0l /* 0x01CCE8 */,
  0xC9084D01l /* 0x01CCEC */,
  0xC9080D02l /* 0x01CCF0 */,
  0x30F04D02l /* 0x01CCF4 */,
  0x4D12490Bl /* 0x01CCF8 */,
  0x40520D00l /* 0x01CCFC */,
  0x890A5CE0l /* 0x01CD00 */,
  0xC9084D01l /* 0x01CD04 */,
  0xC90A0D02l /* 0x01CD08 */,
  0x30F04D02l /* 0x01CD0C */,
  0x45124909l /* 0x01CD10 */,
  0x40520D00l /* 0x01CD14 */,
  0x30F05CE0l /* 0x01CD18 */,
  0x4D01890Al /* 0x01CD1C */,
  0x0D02C908l /* 0x01CD20 */,
  0x4D02C907l /* 0x01CD24 */,
  0xCAE92012l /* 0x01CD28 */,
  0xCDED2312l /* 0x01CD2C */,
  0x68E89301l /* 0x01CD30 */,
  0xA2059309l /* 0x01CD34 */,
  0xDE68A0D7l /* 0x01CD38 */,
  0xD3F92112l /* 0x01CD3C */,
  0xEB0E80D2l /* 0x01CD40 */,
  0x2112EED2l /* 0x01CD44 */,
  0x900196E8l /* 0x01CD48 */,
  0x09097AF8l /* 0x01CD4C */,
  0x27100D00l /* 0x01CD50 */,
  0x2212D6F9l /* 0x01CD54 */,
  0x090996E8l /* 0x01CD58 */,
  0x27100D00l /* 0x01CD5C */,
  0x96E0DBF9l /* 0x01CD60 */,
  0x8D024908l /* 0x01CD64 */,
  0x8D00C908l /* 0x01CD68 */,
  0xE0E9A010l /* 0x01CD6C */,
  0x2212CFD0l /* 0x01CD70 */,
  0x49088DE8l /* 0x01CD74 */,
  0xC9080D00l /* 0x01CD78 */,
  0x40004AC0l /* 0x01CD7C */,
  0x81524110l /* 0x01CD80 */,
  0xE010CD00l /* 0x01CD84 */,
  0xC1B0E6E9l /* 0x01CD88 */,
  0xC412C3C2l /* 0x01CD8C */,
  0x81B0C352l /* 0x01CD90 */,
  0xC252C412l /* 0x01CD94 */,
  0xC252C412l /* 0x01CD98 */,
  0x0D004908l /* 0x01CD9C */,
  0x9DE82010l /* 0x01CDA0 */,
  0x0D00090Al /* 0x01CDA4 */,
  0xD7F296E0l /* 0x01CDA8 */,
  0x93F99001l /* 0x01CDAC */,
  0x35D02200l /* 0x01CDB0 */,
  0xEFF92B30l /* 0x01CDB4 */,
  0x56DC06DCl /* 0x01CDB8 */,
  0x0D000909l /* 0x01CDBC */,
  0x28100909l /* 0x01CDC0 */,
  0x0D00F2F9l /* 0x01CDC4 */,
  0x20100909l /* 0x01CDC8 */,
  0x2A10F5E9l /* 0x01CDCC */,
  0x2F10B3E4l /* 0x01CDD0 */,
  0x01B0F5F9l /* 0x01CDD4 */,
  0x0D00C0C2l /* 0x01CDD8 */,
  0x20100909l /* 0x01CDDC */,
  0x2A10FBE9l /* 0x01CDE0 */,
  0x2F10BDE4l /* 0x01CDE4 */,
  0x01B0FBF9l /* 0x01CDE8 */,
  0xC0220410l /* 0x01CDEC */,
  0x09090D00l /* 0x01CDF0 */,
  0x01EA2010l /* 0x01CDF4 */,
  0xC8E42A10l /* 0x01CDF8 */,
  0x01FA2F10l /* 0x01CDFC */,
  0x081001B0l /* 0x01CE00 */,
  0x0D00C022l /* 0x01CE04 */,
  0x20108908l /* 0x01CE08 */,
  0x2A1007EAl /* 0x01CE0C */,
  0x2F10D3E4l /* 0x01CE10 */,
  0x01B007FAl /* 0x01CE14 */,
  0xC0220C10l /* 0x01CE18 */,
  0x89080D03l /* 0x01CE1C */,
  0x890A4D03l /* 0x01CE20 */,
  0x0DEA6013l /* 0x01CE24 */,
  0x4EC88D03l /* 0x01CE28 */,
  0x3A834601l /* 0x01CE2C */,
  0x7B813F80l /* 0x01CE30 */,
  0xAC057A83l /* 0x01CE34 */,
  0x3F8080D7l /* 0x01CE38 */,
  0xDE6E0B09l /* 0x01CE3C */,
  0xC6000600l /* 0x01CE40 */,
  0x1C622F00l /* 0x01CE44 */,
  0x04E99000l /* 0x01CE48 */,
  0xCD034908l /* 0x01CE4C */,
  0x0D04C908l /* 0x01CE50 */,
  0x4D044908l /* 0x01CE54 */,
  0x8D04C909l /* 0x01CE58 */,
  0xCD04090Al /* 0x01CE5C */,
  0x3A834601l /* 0x01CE60 */,
  0xFB833F80l /* 0x01CE64 */,
  0xAC057A83l /* 0x01CE68 */,
  0x3F80A8D7l /* 0x01CE6C */,
  0xDE6E0B04l /* 0x01CE70 */,
  0xC6000600l /* 0x01CE74 */,
  0x2118D7F2l /* 0x01CE78 */,
  0x220015EAl /* 0x01CE7C */,
  0x2B3035D0l /* 0x01CE80 */,
  0x03DC8CF9l /* 0x01CE84 */,
  0x090957DCl /* 0x01CE88 */,
  0x23100D00l /* 0x01CE8C */,
  0x490831F9l /* 0x01CE90 */,
  0x60114D01l /* 0x01CE94 */,
  0xA70519E9l /* 0x01CE98 */,
  0xAAF280D7l /* 0x01CE9C */,
  0x49089109l /* 0x01CEA0 */,
  0x20100D00l /* 0x01CEA4 */,
  0x7EB122E9l /* 0x01CEA8 */,
  0x80D7A905l /* 0x01CEAC */,
  0x9209AAF2l /* 0x01CEB0 */,
  0x0D004908l /* 0x01CEB4 */,
  0x40211E10l /* 0x01CEB8 */,
  0x0D004908l /* 0x01CEBC */,
  0x40211D10l /* 0x01CEC0 */,
  0xBCD7AC05l /* 0x01CEC4 */,
  0xA2055E61l /* 0x01CEC8 */,
  0xDE68A0D7l /* 0x01CECC */,
  0x271004E1l /* 0x01CED0 */,
  0xC90782F9l /* 0x01CED4 */,
  0xA8D7A205l /* 0x01CED8 */,
  0x0D051E70l /* 0x01CEDC */,
  0x94C64908l /* 0x01CEE0 */,
  0x21180D08l /* 0x01CEE4 */,
  0xC9071BFAl /* 0x01CEE8 */,
  0x49084D05l /* 0x01CEEC */,
  0x2110D5C6l /* 0x01CEF0 */,
  0xAC0546E9l /* 0x01CEF4 */,
  0x5E70A0D7l /* 0x01CEF8 */,
  0x21180D08l /* 0x01CEFC */,
  0x211020FAl /* 0x01CF00 */,
  0x93004EF9l /* 0x01CF04 */,
  0x50E173E9l /* 0x01CF08 */,
  0x73F96310l /* 0x01CF0C */,
  0x8D05C907l /* 0x01CF10 */,
  0x96C64908l /* 0x01CF14 */,
  0x21180D08l /* 0x01CF18 */,
  0xC90725FAl /* 0x01CF1C */,
  0x4908CD05l /* 0x01CF20 */,
  0x0D08D7C6l /* 0x01CF24 */,
  0x2AFA2118l /* 0x01CF28 */,
  0x63F92110l /* 0x01CF2C */,
  0x73E99900l /* 0x01CF30 */,
  0x930065E1l /* 0x01CF34 */,
  0xC90773E9l /* 0x01CF38 */,
  0x49080D06l /* 0x01CF3C */,
  0x0D0898C6l /* 0x01CF40 */,
  0x2FFA2118l /* 0x01CF44 */,
  0xCD05C907l /* 0x01CF48 */,
  0xD9C64908l /* 0x01CF4C */,
  0x21180D08l /* 0x01CF50 */,
  0x75F134FAl /* 0x01CF54 */,
  0x460104E1l /* 0x01CF58 */,
  0x3F803A83l /* 0x01CF5C */,
  0x7A833B85l /* 0x01CF60 */,
  0x98D7AD05l /* 0x01CF64 */,
  0x0B073F80l /* 0x01CF68 */,
  0x0600DE6El /* 0x01CF6C */,
  0xC507C600l /* 0x01CF70 */,
  0x85F92A10l /* 0x01CF74 */,
  0x291004E1l /* 0x01CF78 */,
  0x04E188F9l /* 0x01CF7C */,
  0x18FA2410l /* 0x01CF80 */,
  0x04E104E1l /* 0x01CF84 */,
  0x32D02200l /* 0x01CF88 */,
  0xACF92B30l /* 0x01CF8C */,
  0x9FF2C2D0l /* 0x01CF90 */,
  0x460107E1l /* 0x01CF94 */,
  0x3F803A83l /* 0x01CF98 */,
  0x7A837B81l /* 0x01CF9C */,
  0x80D7AC05l /* 0x01CFA0 */,
  0x0B063F80l /* 0x01CFA4 */,
  0x0600DE6El /* 0x01CFA8 */,
  0x2F00C600l /* 0x01CFAC */,
  0x22001C62l /* 0x01CFB0 */,
  0x2B3035D0l /* 0x01CFB4 */,
  0xF1F2A6F9l /* 0x01CFB8 */,
  0x32D02200l /* 0x01CFBC */,
  0xACF92B30l /* 0x01CFC0 */,
  0x9FF2C2D0l /* 0x01CFC4 */,
  0x3CFAE11Al /* 0x01CFC8 */,
  0x78D0AC00l /* 0x01CFCC */,
  0x600012D0l /* 0x01CFD0 */,
  0x0500C0D7l /* 0x01CFD4 */,
  0xBCF92810l /* 0x01CFD8 */,
  0x50D0A800l /* 0x01CFDC */,
  0x600012D0l /* 0x01CFE0 */,
  0x0500C0D7l /* 0x01CFE4 */,
  0xC4F92310l /* 0x01CFE8 */,
  0x48D0A800l /* 0x01CFEC */,
  0x600012D0l /* 0x01CFF0 */,
  0x0500C8D7l /* 0x01CFF4 */,
  0x39FA2710l /* 0x01CFF8 */,
  0x25007CE2l /* 0x01CFFC */,
  0x3FE251DCl /* 0x01D000 */,
  0x52DC2500l /* 0x01D004 */,
  0x25003FE2l /* 0x01D008 */,
  0x3FE253DCl /* 0x01D00C */,
  0x54DC2500l /* 0x01D010 */,
  0x25003FE2l /* 0x01D014 */,
  0x3FE255DCl /* 0x01D018 */,
  0xD6DB2500l /* 0x01D01C */,
  0x73EC01BCl /* 0x01D020 */,
  0x25003FE2l /* 0x01D024 */,
  0x01BCD7DBl /* 0x01D028 */,
  0x3FE279ECl /* 0x01D02C */,
  0xD8DB2500l /* 0x01D030 */,
  0x01BC8FD0l /* 0x01D034 */,
  0x3FE280ECl /* 0x01D038 */,
  0xD9DB2500l /* 0x01D03C */,
  0x01BCCFD0l /* 0x01D040 */,
  0x3FE28DECl /* 0x01D044 */,
  0x60DC2500l /* 0x01D048 */,
  0x25003FE2l /* 0x01D04C */,
  0x3FE261DCl /* 0x01D050 */,
  0x62DC2500l /* 0x01D054 */,
  0x25003FE2l /* 0x01D058 */,
  0x0FD0E3DBl /* 0x01D05C */,
  0xB3EC01BCl /* 0x01D060 */,
  0x25003FE2l /* 0x01D064 */,
  0x0FD0E4DBl /* 0x01D068 */,
  0xBDEC01BCl /* 0x01D06C */,
  0x25003FE2l /* 0x01D070 */,
  0x0FD0E5DBl /* 0x01D074 */,
  0xC8EC01BCl /* 0x01D078 */,
  0x25003FE2l /* 0x01D07C */,
  0x0FD0E6DBl /* 0x01D080 */,
  0xD3EC01BCl /* 0x01D084 */,
  0x25003FE2l /* 0x01D088 */,
  0x01BCE7DBl /* 0x01D08C */,
  0x3FE2DCECl /* 0x01D090 */,
  0xE7DF2500l /* 0x01D094 */,
  0x25003FE2l /* 0x01D098 */,
  0x3FE270DCl /* 0x01D09C */,
  0x71DC2500l /* 0x01D0A0 */,
  0x25003FE2l /* 0x01D0A4 */,
  0x01BCF8DBl /* 0x01D0A8 */,
  0x3FE23DEDl /* 0x01D0AC */,
  0xF9DB2500l /* 0x01D0B0 */,
  0x49ED01BCl /* 0x01D0B4 */,
  0x25003FE2l /* 0x01D0B8 */,
  0x01BCFADBl /* 0x01D0BC */,
  0x3FE257EDl /* 0x01D0C0 */,
  0xFBDB2500l /* 0x01D0C4 */,
  0x5EED01BCl /* 0x01D0C8 */,
  0x25003FE2l /* 0x01D0CC */,
  0x01BCFCDBl /* 0x01D0D0 */,
  0x3FE26CEDl /* 0x01D0D4 */,
  0xFDDB2500l /* 0x01D0D8 */,
  0x73ED01BCl /* 0x01D0DC */,
  0x20003FE2l /* 0x01D0E0 */,
  0x3FE259DCl /* 0x01D0E4 */,
  0x5ADC2000l /* 0x01D0E8 */,
  0xF1CF3FE2l /* 0x01D0EC */,
  0x06003FC0l /* 0x01D0F0 */,
  0x40D0A400l /* 0x01D0F4 */,
  0x600012D0l /* 0x01D0F8 */,
  0x0500C0D7l /* 0x01D0FC */,
  0x2900090Al /* 0x01D100 */,
  0xE210BC77l /* 0x01D104 */,
  0x2D056AFAl /* 0x01D108 */,
  0x2A05C860l /* 0x01D10C */,
  0x81D0B067l /* 0x01D110 */,
  0xB8602C05l /* 0x01D114 */,
  0x2B058230l /* 0x01D118 */,
  0x2B05B060l /* 0x01D11C */,
  0x2A0540D0l /* 0x01D120 */,
  0x4260B4D0l /* 0x01D124 */,
  0xBCB070B0l /* 0x01D128 */,
  0x6CB04260l /* 0x01D12C */,
  0x4260BCB0l /* 0x01D130 */,
  0x6A00CC10l /* 0x01D134 */,
  0x601771D7l /* 0x01D138 */,
  0x80D04407l /* 0x01D13C */,
  0xBC602C05l /* 0x01D140 */,
  0x44074407l /* 0x01D144 */,
  0x44074407l /* 0x01D148 */,
  0x2C0581D0l /* 0x01D14C */,
  0x0D00BC60l /* 0x01D150 */,
  0x2010090Al /* 0x01D154 */,
  0x44077FEAl /* 0x01D158 */,
  0x8D0079E2l /* 0x01D15C */,
  0xA010090Al /* 0x01D160 */,
  0x003088EAl /* 0x01D164 */,
  0x02C04407l /* 0x01D168 */,
  0x79E24407l /* 0x01D16C */,
  0x090A8D00l /* 0x01D170 */,
  0x95EAA110l /* 0x01D174 */,
  0x44070030l /* 0x01D178 */,
  0x88EAA010l /* 0x01D17C */,
  0x44070030l /* 0x01D180 */,
  0x440702C0l /* 0x01D184 */,
  0xE2F279E2l /* 0x01D188 */,
  0x7CD02900l /* 0x01D18C */,
  0xBEB08170l /* 0x01D190 */,
  0x46018167l /* 0x01D194 */,
  0xFCA00600l /* 0x01D198 */,
  0x6DD0EB0Fl /* 0x01D19C */,
  0x3F807DA0l /* 0x01D1A0 */,
  0xC600C260l /* 0x01D1A4 */,
  0x54D0E506l /* 0x01D1A8 */,
  0x01784601l /* 0x01D1AC */,
  0x01681C04l /* 0x01D1B0 */,
  0xA800C600l /* 0x01D1B4 */,
  0x12D040D0l /* 0x01D1B8 */,
  0xE7D76A00l /* 0x01D1BC */,
  0xC0D60500l /* 0x01D1C0 */,
  0x440780D6l /* 0x01D1C4 */,
  0xC0C6E9F2l /* 0x01D1C8 */,
  0x4407C816l /* 0x01D1CC */,
  0xC026E9F2l /* 0x01D1D0 */,
  0xE9F24407l /* 0x01D1D4 */,
  0x881680C6l /* 0x01D1D8 */,
  0xE9F24407l /* 0x01D1DC */,
  0x1C378026l /* 0x01D1E0 */,
  0x06004601l /* 0x01D1E4 */,
  0xFDA6BCA6l /* 0x01D1E8 */,
  0xBEB73F80l /* 0x01D1EC */,
  0xC6009E66l /* 0x01D1F0 */,
  0x2900BEB7l /* 0x01D1F4 */,
  0x5E307470l /* 0x01D1F8 */,
  0x2900D1FAl /* 0x01D1FC */,
  0x2900B077l /* 0x01D200 */,
  0x5E307870l /* 0x01D204 */,
  0x2900DFFAl /* 0x01D208 */,
  0xEF0F7AD0l /* 0x01D20C */,
  0x4601BFD6l /* 0x01D210 */,
  0xBDA6BCA6l /* 0x01D214 */,
  0x81663F80l /* 0x01D218 */,
  0x2017C600l /* 0x01D21C */,
  0xB1E2E8FAl /* 0x01D220 */,
  0x74D06A00l /* 0x01D224 */,
  0xE8EA5D30l /* 0x01D228 */,
  0xC2E201D7l /* 0x01D22C */,
  0xFFB0C507l /* 0x01D230 */,
  0x0000C507l /* 0x01D234 */,
  0xA205C0D8l /* 0x01D238 */,
  0x10002078l /* 0x01D23C */,
  0xD20509E8l /* 0x01D240 */,
  0x46D82400l /* 0x01D244 */,
  0xAC050BE0l /* 0x01D248 */,
  0x11006478l /* 0x01D24C */,
  0xA70510F8l /* 0x01D250 */,
  0x12E0C0D2l /* 0x01D254 */,
  0xC0D2A305l /* 0x01D258 */,
  0x17F81200l /* 0x01D25C */,
  0x00D3A905l /* 0x01D260 */,
  0xA50519E0l /* 0x01D264 */,
  0xAC0500D3l /* 0x01D268 */,
  0xAC055873l /* 0x01D26C */,
  0x21100C70l /* 0x01D270 */,
  0x221025E8l /* 0x01D274 */,
  0x04D024E8l /* 0x01D278 */,
  0x25E09F05l /* 0x01D27C */,
  0x80C39E05l /* 0x01D280 */,
  0x9600C0D3l /* 0x01D284 */,
  0x20002CE8l /* 0x01D288 */,
  0xC05310D0l /* 0x01D28C */,
  0x31E89400l /* 0x01D290 */,
  0x08D02000l /* 0x01D294 */,
  0xAC05C053l /* 0x01D298 */,
  0x43DA2070l /* 0x01D29C */,
  0x611A404Al /* 0x01D2A0 */,
  0x621A3CE8l /* 0x01D2A4 */,
  0x9C053FE8l /* 0x01D2A8 */,
  0x40E89900l /* 0x01D2AC */,
  0x405A10D0l /* 0x01D2B0 */,
  0x9D0540E0l /* 0x01D2B4 */,
  0x48E89700l /* 0x01D2B8 */,
  0x00D03002l /* 0x01D2BC */,
  0x2000C058l /* 0x01D2C0 */,
  0x405A04D0l /* 0x01D2C4 */,
  0x4DE89800l /* 0x01D2C8 */,
  0x08D02000l /* 0x01D2CC */,
  0x9500405Al /* 0x01D2D0 */,
  0xD00550E8l /* 0x01D2D4 */,
  0x5DE8D201l /* 0x01D2D8 */,
  0x1478AC05l /* 0x01D2DC */,
  0x59E81000l /* 0x01D2E0 */,
  0x00D02400l /* 0x01D2E4 */,
  0x1100405Al /* 0x01D2E8 */,
  0x01D85DE8l /* 0x01D2EC */,
  0x00D85EE0l /* 0x01D2F0 */,
  0x10D0A307l /* 0x01D2F4 */,
  0x86020068l /* 0x01D2F8 */,
  0x0602C1D5l /* 0x01D2FC */,
  0x6CF8D201l /* 0x01D300 */,
  0x1C78AC05l /* 0x01D304 */,
  0xE0C58602l /* 0x01D308 */,
  0x0602C215l /* 0x01D30C */,
  0xC076A205l /* 0x01D310 */,
  0xDC16F1B6l /* 0x01D314 */,
  0x0477A205l /* 0x01D318 */,
  0x2870A205l /* 0x01D31C */,
  0x7EF8D201l /* 0x01D320 */,
  0x7EE82110l /* 0x01D324 */,
  0x1B1721B7l /* 0x01D328 */,
  0x80E89C01l /* 0x01D32C */,
  0x80E00117l /* 0x01D330 */,
  0x1C1731B7l /* 0x01D334 */,
  0x9C015CC0l /* 0x01D338 */,
  0x411084F8l /* 0x01D33C */,
  0x3CD0E704l /* 0x01D340 */,
  0x40D04060l /* 0x01D344 */,
  0x1C702605l /* 0x01D348 */,
  0x9BF82010l /* 0x01D34C */,
  0x9BE89F01l /* 0x01D350 */,
  0x0C70A205l /* 0x01D354 */,
  0x9BF82310l /* 0x01D358 */,
  0x3C702507l /* 0x01D35C */,
  0x9BF82010l /* 0x01D360 */,
  0x3070E804l /* 0x01D364 */,
  0x9BF82010l /* 0x01D368 */,
  0xA30741D0l /* 0x01D36C */,
  0x45864C60l /* 0x01D370 */,
  0xC6A58602l /* 0x01D374 */,
  0x07800602l /* 0x01D378 */,
  0x46AA0580l /* 0x01D37C */,
  0x46A34581l /* 0x01D380 */,
  0x86A3C580l /* 0x01D384 */,
  0xC5821780l /* 0x01D388 */,
  0x88D20680l /* 0x01D38C */,
  0xB4F8D201l /* 0x01D390 */,
  0x1C70AC05l /* 0x01D394 */,
  0xB4E401B0l /* 0x01D398 */,
  0xB0E09F12l /* 0x01D39C */,
  0x18100B70l /* 0x01D3A0 */,
  0x0A500810l /* 0x01D3A4 */,
  0x27820B60l /* 0x01D3A8 */,
  0x2A80A980l /* 0x01D3AC */,
  0x21003F80l /* 0x01D3B0 */,
  0x4A007CD0l /* 0x01D3B4 */,
  0x0600CB7Al /* 0x01D3B8 */,
  0x00D0B000l /* 0x01D3BC */,
  0x3F802AA0l /* 0x01D3C0 */,
  0xCC7A4A00l /* 0x01D3C4 */,
  0x300C0600l /* 0x01D3C8 */,
  0x021000D0l /* 0x01D3CC */,
  0x278027A0l /* 0x01D3D0 */,
  0x29A02FD0l /* 0x01D3D4 */,
  0x29842A80l /* 0x01D3D8 */,
  0x00D0B002l /* 0x01D3DC */,
  0x20012AA0l /* 0x01D3E0 */,
  0x29A000D0l /* 0x01D3E4 */,
  0x00D83900l /* 0x01D3E8 */,
  0x3F802AA0l /* 0x01D3EC */,
  0x39002B80l /* 0x01D3F0 */,
  0x2AA000D0l /* 0x01D3F4 */,
  0x6B803F80l /* 0x01D3F8 */,
  0x00D0300Cl /* 0x01D3FC */,
  0x27A00210l /* 0x01D400 */,
  0x20D82980l /* 0x01D404 */,
  0xEBE8D201l /* 0x01D408 */,
  0x27A81404l /* 0x01D40C */,
  0xA307E8A3l /* 0x01D410 */,
  0x20100C70l /* 0x01D414 */,
  0x9C01FBE8l /* 0x01D418 */,
  0xAB00F6E8l /* 0x01D41C */,
  0xF8E000D0l /* 0x01D420 */,
  0x00D0AA00l /* 0x01D424 */,
  0x1B802CA0l /* 0x01D428 */,
  0xAA0003E1l /* 0x01D42C */,
  0x2CA000D0l /* 0x01D430 */,
  0x02E99C01l /* 0x01D434 */,
  0x03E11B80l /* 0x01D438 */,
  0xA3075B80l /* 0x01D43C */,
  0x007030D0l /* 0x01D440 */,
  0x09E92010l /* 0x01D444 */,
  0x4601D105l /* 0x01D448 */,
  0xE200F681l /* 0x01D44C */,
  0x34A005D0l /* 0x01D450 */,
  0xE300B681l /* 0x01D454 */,
  0x34A005D0l /* 0x01D458 */,
  0xE1DC6000l /* 0x01D45C */,
  0x82DC6000l /* 0x01D460 */,
  0x40DF6000l /* 0x01D464 */,
  0x8602C600l /* 0x01D468 */,
  0x060240D5l /* 0x01D46C */,
  0x4601D505l /* 0x01D470 */,
  0x00D06600l /* 0x01D474 */,
  0x38A037A0l /* 0x01D478 */,
  0xC6003F80l /* 0x01D47C */,
  0x18D0A307l /* 0x01D480 */,
  0x60104070l /* 0x01D484 */,
  0x7FB05FF5l /* 0x01D488 */,
  0x60104060l /* 0x01D48C */,
  0xA30033E9l /* 0x01D490 */,
  0x12D078D0l /* 0x01D494 */,
  0xC0D76000l /* 0x01D498 */,
  0x6CC70500l /* 0x01D49C */,
  0x20005A17l /* 0x01D4A0 */,
  0xAC47BFD7l /* 0x01D4A4 */,
  0x01B01CC0l /* 0x01D4A8 */,
  0x48F91E30l /* 0x01D4AC */,
  0x0070EA04l /* 0x01D4B0 */,
  0x48E92210l /* 0x01D4B4 */,
  0x48E92410l /* 0x01D4B8 */,
  0x04D02800l /* 0x01D4BC */,
  0x61054070l /* 0x01D4C0 */,
  0x406018D0l /* 0x01D4C4 */,
  0x6CAB0780l /* 0x01D4C8 */,
  0x34D0A307l /* 0x01D4CC */,
  0xE0580078l /* 0x01D4D0 */,
  0x0C70A307l /* 0x01D4D4 */,
  0x58F92010l /* 0x01D4D8 */,
  0x68D0A800l /* 0x01D4DC */,
  0x640012D0l /* 0x01D4E0 */,
  0x0500EDD7l /* 0x01D4E4 */,
  0xA900ABF2l /* 0x01D4E8 */,
  0x12D048D0l /* 0x01D4EC */,
  0xD8D76400l /* 0x01D4F0 */,
  0x60100500l /* 0x01D4F4 */,
  0xA30766E9l /* 0x01D4F8 */,
  0x007834D0l /* 0x01D4FC */,
  0x6FE1E058l /* 0x01D500 */,
  0xD50300D8l /* 0x01D504 */,
  0x20006BE9l /* 0x01D508 */,
  0xA30720D8l /* 0x01D50C */,
  0x006834D0l /* 0x01D510 */,
  0x6A05E058l /* 0x01D514 */,
  0x6A053870l /* 0x01D518 */,
  0x20303478l /* 0x01D51C */,
  0x2878EA04l /* 0x01D520 */,
  0xE0C18602l /* 0x01D524 */,
  0x22180602l /* 0x01D528 */,
  0x1F108AF9l /* 0x01D52C */,
  0x38786B05l /* 0x01D530 */,
  0x8AF92018l /* 0x01D534 */,
  0x00C81E10l /* 0x01D538 */,
  0x00281E18l /* 0x01D53C */,
  0x1C1820C0l /* 0x01D540 */,
  0x20C00028l /* 0x01D544 */,
  0x20201818l /* 0x01D548 */,
  0x860200C8l /* 0x01D54C */,
  0x6A0520C2l /* 0x01D550 */,
  0x6405B071l /* 0x01D554 */,
  0x807408D0l /* 0x01D558 */,
  0x0CD06405l /* 0x01D55C */,
  0x0602C074l /* 0x01D560 */,
  0x9EF9D201l /* 0x01D564 */,
  0x28D0A307l /* 0x01D568 */,
  0x61104070l /* 0x01D56C */,
  0xD7059EF9l /* 0x01D570 */,
  0xE9018602l /* 0x01D574 */,
  0x060210D5l /* 0x01D578 */,
  0x18D0A307l /* 0x01D57C */,
  0x60104070l /* 0x01D580 */,
  0xA307C0F9l /* 0x01D584 */,
  0x20103070l /* 0x01D588 */,
  0x9F01CEE9l /* 0x01D58C */,
  0xD201CEE9l /* 0x01D590 */,
  0xE105CEF9l /* 0x01D594 */,
  0x20102470l /* 0x01D598 */,
  0x2005CEF9l /* 0x01D59C */,
  0x24102C70l /* 0x01D5A0 */,
  0x6BC0CEF9l /* 0x01D5A4 */,
  0x01C077B0l /* 0x01D5A8 */,
  0xC5F51C30l /* 0x01D5AC */,
  0xE11A01C7l /* 0x01D5B0 */,
  0xC5E1CEE9l /* 0x01D5B4 */,
  0x1C77A307l /* 0x01D5B8 */,
  0x40D0C1CAl /* 0x01D5BC */,
  0x73F24060l /* 0x01D5C0 */,
  0x82B7ABC7l /* 0x01D5C4 */,
  0xA3078BF2l /* 0x01D5C8 */,
  0x20100C70l /* 0x01D5CC */,
  0xF1E1F8E9l /* 0x01D5D0 */,
  0x1C67A307l /* 0x01D5D4 */,
  0x2605C1DAl /* 0x01D5D8 */,
  0x40700CD0l /* 0x01D5DC */,
  0x10D02605l /* 0x01D5E0 */,
  0x73F24060l /* 0x01D5E4 */,
  0xA40740D0l /* 0x01D5E8 */,
  0x406004D0l /* 0x01D5EC */,
  0x0C70A307l /* 0x01D5F0 */,
  0xF8E92010l /* 0x01D5F4 */,
  0x0C6CE804l /* 0x01D5F8 */,
  0x5C60E704l /* 0x01D5FC */,
  0x6060E704l /* 0x01D600 */,
  0x9D01D30Bl /* 0x01D604 */,
  0xE804F1F9l /* 0x01D608 */,
  0x807010D0l /* 0x01D60C */,
  0xF1E9A310l /* 0x01D610 */,
  0xF1F9D203l /* 0x01D614 */,
  0xABF24BF2l /* 0x01D618 */,
  0x48D0A900l /* 0x01D61C */,
  0x640012D0l /* 0x01D620 */,
  0x0500FED7l /* 0x01D624 */,
  0x68D0A800l /* 0x01D628 */,
  0x650012D0l /* 0x01D62C */,
  0x0500D3D7l /* 0x01D630 */,
  0xC0D02000l /* 0x01D634 */,
  0xB50100D1l /* 0x01D638 */,
  0x40C100D4l /* 0x01D63C */,
  0xA3D12000l /* 0x01D640 */,
  0xA4D0E204l /* 0x01D644 */,
  0x016142C0l /* 0x01D648 */,
  0x41617CB0l /* 0x01D64C */,
  0x033006C0l /* 0x01D650 */,
  0xE4021CFEl /* 0x01D654 */,
  0x01D00021l /* 0x01D658 */,
  0x20100340l /* 0x01D65C */,
  0xE30218EAl /* 0x01D660 */,
  0x19E26021l /* 0x01D664 */,
  0xFFB060B1l /* 0x01D668 */,
  0x08E2B8B0l /* 0x01D66C */,
  0xC0D02000l /* 0x01D670 */,
  0x2870E804l /* 0x01D674 */,
  0x40C100C1l /* 0x01D678 */,
  0x00DD3200l /* 0x01D67C */,
  0x90712A00l /* 0x01D680 */,
  0x402146C0l /* 0x01D684 */,
  0x94D0AC04l /* 0x01D688 */,
  0x90712A00l /* 0x01D68C */,
  0x42C08111l /* 0x01D690 */,
  0x03D005C8l /* 0x01D694 */,
  0x21100340l /* 0x01D698 */,
  0x100434EEl /* 0x01D69C */,
  0x20000168l /* 0x01D6A0 */,
  0x062023D0l /* 0x01D6A4 */,
  0x4BFE0330l /* 0x01D6A8 */,
  0x034003D0l /* 0x01D6AC */,
  0x45EA2010l /* 0x01D6B0 */,
  0x47EA2110l /* 0x01D6B4 */,
  0x45EA2210l /* 0x01D6B8 */,
  0x5C216B08l /* 0x01D6BC */,
  0x7CB148E2l /* 0x01D6C0 */,
  0x64B148E2l /* 0x01D6C4 */,
  0xB8B0FFB0l /* 0x01D6C8 */,
  0xAC042DE2l /* 0x01D6CC */,
  0xC0D094D0l /* 0x01D6D0 */,
  0x90712A00l /* 0x01D6D4 */,
  0x44D08111l /* 0x01D6D8 */,
  0xB8B04220l /* 0x01D6DC */,
  0xAC0402C0l /* 0x01D6E0 */,
  0x01601030l /* 0x01D6E4 */,
  0x2000FFB0l /* 0x01D6E8 */,
  0x062023D0l /* 0x01D6EC */,
  0x51EE0330l /* 0x01D6F0 */,
  0x422044D0l /* 0x01D6F4 */,
  0x016000D0l /* 0x01D6F8 */,
  0xE70444B0l /* 0x01D6FC */,
  0xAC044860l /* 0x01D700 */,
  0xE70414D0l /* 0x01D704 */,
  0x40D00460l /* 0x01D708 */,
  0x4C60E704l /* 0x01D70C */,
  0x5460E704l /* 0x01D710 */,
  0x5060E704l /* 0x01D714 */,
  0x5860E704l /* 0x01D718 */,
  0x2707C507l /* 0x01D71C */,
  0x26051870l /* 0x01D720 */,
  0x817B40D0l /* 0x01D724 */,
  0xC02BEECBl /* 0x01D728 */,
  0x44D02605l /* 0x01D72C */,
  0x70CC017Cl /* 0x01D730 */,
  0x2605402Cl /* 0x01D734 */,
  0x017650D0l /* 0x01D738 */,
  0x2E0058C6l /* 0x01D73C */,
  0x58304070l /* 0x01D740 */,
  0x270789FAl /* 0x01D744 */,
  0x40262070l /* 0x01D748 */,
  0x9D01C507l /* 0x01D74C */,
  0x3CB68FEAl /* 0x01D750 */,
  0xA0177CB6l /* 0x01D754 */,
  0x9C01AAFEl /* 0x01D758 */,
  0x1EC8A1EAl /* 0x01D75C */,
  0x98EA1000l /* 0x01D760 */,
  0x402620D0l /* 0x01D764 */,
  0x00D0E402l /* 0x01D768 */,
  0x10000026l /* 0x01D76C */,
  0x40269EFAl /* 0x01D770 */,
  0x9AFA01B8l /* 0x01D774 */,
  0x1EC8AAE2l /* 0x01D778 */,
  0x00D0A805l /* 0x01D77C */,
  0x40D0E402l /* 0x01D780 */,
  0x41260026l /* 0x01D784 */,
  0xA6FA01B8l /* 0x01D788 */,
  0x9105C507l /* 0x01D78C */,
  0xC2C0A5D0l /* 0x01D790 */,
  0xC9EA9C01l /* 0x01D794 */,
  0xB6FAD103l /* 0x01D798 */,
  0xE3D080D0l /* 0x01D79C */,
  0xC9E29109l /* 0x01D7A0 */,
  0x5870E804l /* 0x01D7A4 */,
  0xC9EA6110l /* 0x01D7A8 */,
  0x10702A00l /* 0x01D7AC */,
  0x5C70E804l /* 0x01D7B0 */,
  0xC9E64030l /* 0x01D7B4 */,
  0x0110A4D0l /* 0x01D7B8 */,
  0x81308020l /* 0x01D7BC */,
  0xC2C09F10l /* 0x01D7C0 */,
  0xC1B0C120l /* 0x01D7C4 */,
  0xC8109109l /* 0x01D7C8 */,
  0x83CAC250l /* 0x01D7CC */,
  0xBF4AEC03l /* 0x01D7D0 */,
  0x0000C507l /* 0x01D7D4 */,
  0x870F2980l /* 0x01D7D8 */,
  0x63158602l /* 0x01D7DC */,
  0x62150BE8l /* 0x01D7E0 */,
  0x61150EE8l /* 0x01D7E4 */,
  0x298016E8l /* 0x01D7E8 */,
  0x970518E0l /* 0x01D7EC */,
  0x870F41D5l /* 0x01D7F0 */,
  0xD5059605l /* 0x01D7F4 */,
  0x15E8D401l /* 0x01D7F8 */,
  0xD4094906l /* 0x01D7FC */,
  0x18E0D509l /* 0x01D800 */,
  0x94052980l /* 0x01D804 */,
  0x870F7FB5l /* 0x01D808 */,
  0x06844582l /* 0x01D80C */,
  0xE1DC6000l /* 0x01D810 */,
  0x9ADF6500l /* 0x01D814 */,
  0xC600A9E0l /* 0x01D818 */,
  0x86988581l /* 0x01D81C */,
  0x23E8A018l /* 0x01D820 */,
  0x41E8D601l /* 0x01D824 */,
  0x1901D609l /* 0x01D828 */,
  0x28002EE8l /* 0x01D82C */,
  0xD1E0C6DFl /* 0x01D830 */,
  0x41E81F01l /* 0x01D834 */,
  0x06994580l /* 0x01D838 */,
  0x3F49EF0Fl /* 0x01D83C */,
  0x2CC001B9l /* 0x01D840 */,
  0x100E1A10l /* 0x01D844 */,
  0xD3033EE8l /* 0x01D848 */,
  0x28003EF8l /* 0x01D84C */,
  0xD1E0C3DFl /* 0x01D850 */,
  0x46804580l /* 0x01D854 */,
  0x19011F09l /* 0x01D858 */,
  0xC600D6F8l /* 0x01D85C */,
  0x8EE8D201l /* 0x01D860 */,
  0x8EE81601l /* 0x01D864 */,
  0x1070A307l /* 0x01D868 */,
  0x8EE82010l /* 0x01D86C */,
  0x068C4582l /* 0x01D870 */,
  0x1F013F80l /* 0x01D874 */,
  0x4BF152E8l /* 0x01D878 */,
  0x1ED06D00l /* 0x01D87C */,
  0xD78036A0l /* 0x01D880 */,
  0x0D003F80l /* 0x01D884 */,
  0x0D0067F2l /* 0x01D888 */,
  0x0D0067F2l /* 0x01D88C */,
  0x0D0067F2l /* 0x01D890 */,
  0x0D0067F2l /* 0x01D894 */,
  0x0D000D00l /* 0x01D898 */,
  0x0D000D00l /* 0x01D89C */,
  0x0D0067F2l /* 0x01D8A0 */,
  0x0D0067F2l /* 0x01D8A4 */,
  0x0D0067F2l /* 0x01D8A8 */,
  0x0D0067F2l /* 0x01D8AC */,
  0x0D000D00l /* 0x01D8B0 */,
  0x97800D00l /* 0x01D8B4 */,
  0x0D003F80l /* 0x01D8B8 */,
  0x0D0067F2l /* 0x01D8BC */,
  0x0D0067F2l /* 0x01D8C0 */,
  0x17800D00l /* 0x01D8C4 */,
  0x29C90580l /* 0x01D8C8 */,
  0x00D02400l /* 0x01D8CC */,
  0x06A90009l /* 0x01D8D0 */,
  0x4BF13F80l /* 0x01D8D4 */,
  0x3F809780l /* 0x01D8D8 */,
  0x0D000D00l /* 0x01D8DC */,
  0x67F20D00l /* 0x01D8E0 */,
  0x67F20D00l /* 0x01D8E4 */,
  0x05801780l /* 0x01D8E8 */,
  0x458246AAl /* 0x01D8EC */,
  0x9FE00684l /* 0x01D8F0 */,
  0x9FE81F01l /* 0x01D8F4 */,
  0x94E81401l /* 0x01D8F8 */,
  0x17051409l /* 0x01D8FC */,
  0x45821209l /* 0x01D900 */,
  0x30D96000l /* 0x01D904 */,
  0x3F8006A9l /* 0x01D908 */,
  0x45824BF1l /* 0x01D90C */,
  0x07800684l /* 0x01D910 */,
  0x1801B3E0l /* 0x01D914 */,
  0x0581A6E8l /* 0x01D918 */,
  0x46901FD0l /* 0x01D91C */,
  0x6CA04040l /* 0x01D920 */,
  0xA9F81401l /* 0x01D924 */,
  0x86020780l /* 0x01D928 */,
  0x460217C9l /* 0x01D92C */,
  0xB1E8D001l /* 0x01D930 */,
  0xB1E81401l /* 0x01D934 */,
  0x45861106l /* 0x01D938 */,
  0x210006A9l /* 0x01D93C */,
  0x002B00D0l /* 0x01D940 */,
  0x2CC9C581l /* 0x01D944 */,
  0x06021A19l /* 0x01D948 */,
  0xBFE41B39l /* 0x01D94C */,
  0x244B3FD9l /* 0x01D950 */,
  0x46023FBBl /* 0x01D954 */,
  0x01D02200l /* 0x01D958 */,
  0x06AB38A0l /* 0x01D95C */,
  0xD5013F80l /* 0x01D960 */,
  0x4906CAE8l /* 0x01D964 */,
  0xCBE0D509l /* 0x01D968 */,
  0x8602D405l /* 0x01D96C */,
  0x4602A2C5l /* 0x01D970 */,
  0x46019805l /* 0x01D974 */,
  0x6900870Fl /* 0x01D978 */,
  0x00C09EDFl /* 0x01D97C */,
  0x870F4601l /* 0x01D980 */,
  0x63003ECAl /* 0x01D984 */,
  0x46019BDFl /* 0x01D988 */,
  0xABC8870Fl /* 0x01D98C */,
  0xCD0A090Cl /* 0x01D990 */,
  0x1BE9AB38l /* 0x01D994 */,
  0x81B8ABC8l /* 0x01D998 */,
  0x5CCB0BE5l /* 0x01D99C */,
  0x0BFD623Bl /* 0x01D9A0 */,
  0x6C4B7FDBl /* 0x01D9A4 */,
  0xEDE8AD38l /* 0x01D9A8 */,
  0xC4DF2800l /* 0x01D9AC */,
  0xD7015EE2l /* 0x01D9B0 */,
  0x86020EE9l /* 0x01D9B4 */,
  0xA2814601l /* 0x01D9B8 */,
  0xC600A398l /* 0x01D9BC */,
  0x0EFD8638l /* 0x01D9C0 */,
  0x95C84602l /* 0x01D9C4 */,
  0x88388602l /* 0x01D9C8 */,
  0xA2050EEDl /* 0x01D9CC */,
  0xA3188C78l /* 0x01D9D0 */,
  0x56030AE9l /* 0x01D9D4 */,
  0xE4110AF9l /* 0x01D9D8 */,
  0x4ADB0AF9l /* 0x01D9DC */,
  0x0AE96B3Bl /* 0x01D9E0 */,
  0x6B3B54DBl /* 0x01D9E4 */,
  0x0EE10AE9l /* 0x01D9E8 */,
  0x9A059B05l /* 0x01D9EC */,
  0x2AE19805l /* 0x01D9F0 */,
  0x1BE9D101l /* 0x01D9F4 */,
  0x1BE91F03l /* 0x01D9F8 */,
  0x4BCB4602l /* 0x01D9FC */,
  0x98C80602l /* 0x01DA00 */,
  0x623B8602l /* 0x01DA04 */,
  0x403BA805l /* 0x01DA08 */,
  0x49090EFDl /* 0x01DA0C */,
  0x6CAB4D0Bl /* 0x01DA10 */,
  0x480B61DBl /* 0x01DA14 */,
  0x8D0869DBl /* 0x01DA18 */,
  0x1FF91001l /* 0x01DA1C */,
  0xC5814601l /* 0x01DA20 */,
  0x078006ABl /* 0x01DA24 */,
  0xD6054906l /* 0x01DA28 */,
  0xC6000602l /* 0x01DA2C */,
  0x4601050Al /* 0x01DA30 */,
  0xDADC6000l /* 0x01DA34 */,
  0x20003A83l /* 0x01DA38 */,
  0x3BA001D0l /* 0x01DA3C */,
  0xE8017A83l /* 0x01DA40 */,
  0x3F803CD0l /* 0x01DA44 */,
  0xC07E0B04l /* 0x01DA48 */,
  0x81C80600l /* 0x01DA4C */,
  0x9780C600l /* 0x01DA50 */,
  0x86A00585l /* 0x01DA54 */,
  0x06A1C6A0l /* 0x01DA58 */,
  0xC58146A1l /* 0x01DA5C */,
  0x458206ABl /* 0x01DA60 */,
  0x3F80068Cl /* 0x01DA64 */,
  0x00C04906l /* 0x01DA68 */,
  0x490649E1l /* 0x01DA6C */,
  0x16023799l /* 0x01DA70 */,
  0x22004CE9l /* 0x01DA74 */,
  0x37A000D0l /* 0x01DA78 */,
  0x2BCBC507l /* 0x01DA7C */,
  0xACC701BBl /* 0x01DA80 */,
  0x650040D7l /* 0x01DA84 */,
  0x1BE11ADAl /* 0x01DA88 */,
  0x5AE99801l /* 0x01DA8C */,
  0x46019809l /* 0x01DA90 */,
  0x56C88602l /* 0x01DA94 */,
  0xACC60602l /* 0x01DA98 */,
  0x9400C600l /* 0x01DA9C */,
  0xD3016EE9l /* 0x01DAA0 */,
  0x9780C6E9l /* 0x01DAA4 */,
  0x8D003F80l /* 0x01DAA8 */,
  0x0D01CD00l /* 0x01DAAC */,
  0xC6E14D01l /* 0x01DAB0 */,
  0x3F809780l /* 0x01DAB4 */,
  0xCD008D00l /* 0x01DAB8 */,
  0x4D010D01l /* 0x01DABC */,
  0x3F80D780l /* 0x01DAC0 */,
  0xCD018D01l /* 0x01DAC4 */,
  0x4D020D02l /* 0x01DAC8 */,
  0xCD028D02l /* 0x01DACC */,
  0x4D030D03l /* 0x01DAD0 */,
  0xCD038D03l /* 0x01DAD4 */,
  0x4D040D04l /* 0x01DAD8 */,
  0xCD048D04l /* 0x01DADC */,
  0x4D050D05l /* 0x01DAE0 */,
  0xAAE9D201l /* 0x01DAE4 */,
  0xAAE99600l /* 0x01DAE8 */,
  0x1070A307l /* 0x01DAEC */,
  0xAAE92010l /* 0x01DAF0 */,
  0x1ED0ED00l /* 0x01DAF4 */,
  0x6BF236A0l /* 0x01DAF8 */,
  0x6BF280C1l /* 0x01DAFC */,
  0x6BF2C0C1l /* 0x01DB00 */,
  0x6BF200C2l /* 0x01DB04 */,
  0x6BF240C2l /* 0x01DB08 */,
  0x6BF280C3l /* 0x01DB0C */,
  0x6BF2C0C3l /* 0x01DB10 */,
  0x6BF200C4l /* 0x01DB14 */,
  0x6BF240C4l /* 0x01DB18 */,
  0x6BF280C0l /* 0x01DB1C */,
  0x6BF2C0C0l /* 0x01DB20 */,
  0x6BF200C1l /* 0x01DB24 */,
  0xC6E140C1l /* 0x01DB28 */,
  0xB8F99F00l /* 0x01DB2C */,
  0xB8F99700l /* 0x01DB30 */,
  0xB8E99600l /* 0x01DB34 */,
  0xC7C286C2l /* 0x01DB38 */,
  0x49C308C3l /* 0x01DB3C */,
  0xCFC48EC4l /* 0x01DB40 */,
  0x51C510C5l /* 0x01DB44 */,
  0xBDE99E01l /* 0x01DB48 */,
  0xBDF99700l /* 0x01DB4C */,
  0x9F009704l /* 0x01DB50 */,
  0x9C01C6E9l /* 0x01DB54 */,
  0x9104C2E9l /* 0x01DB58 */,
  0xC6E99F01l /* 0x01DB5C */,
  0x44C1C2C0l /* 0x01DB60 */,
  0xC5821780l /* 0x01DB64 */,
  0x22000680l /* 0x01DB68 */,
  0x38A000D0l /* 0x01DB6C */,
  0x16FA9400l /* 0x01DB70 */,
  0x01EA9E01l /* 0x01DB74 */,
  0x100002C8l /* 0x01DB78 */,
  0xAE21D8F9l /* 0x01DB7C */,
  0xAF23EE21l /* 0x01DB80 */,
  0xDCE1EF23l /* 0x01DB84 */,
  0xF021B021l /* 0x01DB88 */,
  0xF123B123l /* 0x01DB8C */,
  0x100003C8l /* 0x01DB90 */,
  0x2E22E4F9l /* 0x01DB94 */,
  0x2F246E22l /* 0x01DB98 */,
  0xE8E16F24l /* 0x01DB9C */,
  0x70223022l /* 0x01DBA0 */,
  0x71243124l /* 0x01DBA4 */,
  0x100004C8l /* 0x01DBA8 */,
  0xAE22F0F9l /* 0x01DBAC */,
  0xAF24EE22l /* 0x01DBB0 */,
  0xF4E1EF24l /* 0x01DBB4 */,
  0xF022B022l /* 0x01DBB8 */,
  0xF124B124l /* 0x01DBBC */,
  0x100005C8l /* 0x01DBC0 */,
  0x2E23FCF9l /* 0x01DBC4 */,
  0x2F256E23l /* 0x01DBC8 */,
  0x00E26F25l /* 0x01DBCC */,
  0x70233023l /* 0x01DBD0 */,
  0x71253125l /* 0x01DBD4 */,
  0xAE2111E2l /* 0x01DBD8 */,
  0x2E22EE21l /* 0x01DBDC */,
  0xB0226E22l /* 0x01DBE0 */,
  0x3023F022l /* 0x01DBE4 */,
  0xAF237023l /* 0x01DBE8 */,
  0x2F24EF23l /* 0x01DBEC */,
  0xB1246F24l /* 0x01DBF0 */,
  0x3125F124l /* 0x01DBF4 */,
  0xA7F27125l /* 0x01DBF8 */,
  0x16FA9401l /* 0x01DBFC */,
  0x9305DEF2l /* 0x01DC00 */,
  0x19FA6017l /* 0x01DC04 */,
  0x960186F2l /* 0x01DC08 */,
  0x15F319EAl /* 0x01DC0C */,
  0x94099609l /* 0x01DC10 */,
  0x23FA9400l /* 0x01DC14 */,
  0x23FA9301l /* 0x01DC18 */,
  0x9309DEF2l /* 0x01DC1C */,
  0x38D0AE00l /* 0x01DC20 */,
  0x2CFA9901l /* 0x01DC24 */,
  0x2CEA9A01l /* 0x01DC28 */,
  0x9905490Fl /* 0x01DC2C */,
  0x55000D98l /* 0x01DC30 */,
  0x01B037FAl /* 0x01DC34 */,
  0x460137EEl /* 0x01DC38 */,
  0x0698C582l /* 0x01DC3C */,
  0x37EA1000l /* 0x01DC40 */,
  0xC6000680l /* 0x01DC44 */,
  0x26EA9701l /* 0x01DC48 */,
  0x970948F3l /* 0x01DC4C */,
  0x1BC07FB7l /* 0x01DC50 */,
  0x50EE1D30l /* 0x01DC54 */,
  0x40D7BFB7l /* 0x01DC58 */,
  0x04B01CC0l /* 0x01DC5C */,
  0x50FA1E30l /* 0x01DC60 */,
  0x0070EA04l /* 0x01DC64 */,
  0x50EA2210l /* 0x01DC68 */,
  0x50EA2410l /* 0x01DC6C */,
  0x04702800l /* 0x01DC70 */,
  0x18606105l /* 0x01DC74 */,
  0x58FA9A01l /* 0x01DC78 */,
  0x1E301CC0l /* 0x01DC7C */,
  0x28005AEDl /* 0x01DC80 */,
  0x5EE2C5DFl /* 0x01DC84 */,
  0x50D0A900l /* 0x01DC88 */,
  0x600012D0l /* 0x01DC8C */,
  0x0500C0D7l /* 0x01DC90 */,
  0x4601D30Bl /* 0x01DC94 */,
  0x01D07000l /* 0x01DC98 */,
  0x3F8037A0l /* 0x01DC9C */,
  0x00C0C600l /* 0x01DCA0 */,
  0x34A065E2l /* 0x01DCA4 */,
  0x34A01010l /* 0x01DCA8 */,
  0x3490C507l /* 0x01DCAC */,
  0x48107490l /* 0x01DCB0 */,
  0x01204810l /* 0x01DCB4 */,
  0x0D98C507l /* 0x01DCB8 */,
  0x77FA5500l /* 0x01DCBC */,
  0x0D08C907l /* 0x01DCC0 */,
  0x20D871E2l /* 0x01DCC4 */,
  0x01B000D0l /* 0x01DCC8 */,
  0x01B80EA0l /* 0x01DCCC */,
  0xC9077AEEl /* 0x01DCD0 */,
  0xC9070D08l /* 0x01DCD4 */,
  0xC9070D08l /* 0x01DCD8 */,
  0xC9070D08l /* 0x01DCDC */,
  0xC5070D08l /* 0x01DCE0 */,
  0x8DFAA017l /* 0x01DCE4 */,
  0xA4EA9D01l /* 0x01DCE8 */,
  0x7CB63CB6l /* 0x01DCEC */,
  0x9C01A4E2l /* 0x01DCF0 */,
  0xE4029EEAl /* 0x01DCF4 */,
  0x002600D0l /* 0x01DCF8 */,
  0x10001EC8l /* 0x01DCFC */,
  0x20D09BFAl /* 0x01DD00 */,
  0xE4024036l /* 0x01DD04 */,
  0x402600D0l /* 0x01DD08 */,
  0x20D0A4E2l /* 0x01DD0C */,
  0xA4E24026l /* 0x01DD10 */,
  0x00D0A805l /* 0x01DD14 */,
  0xE4020026l /* 0x01DD18 */,
  0x402600D0l /* 0x01DD1C */,
  0xD9C598C5l /* 0x01DD20 */,
  0x4601C507l /* 0x01DD24 */,
  0x00D8A000l /* 0x01DD28 */,
  0xADFA9100l /* 0x01DD2C */,
  0x97001004l /* 0x01DD30 */,
  0xA0A0C3EAl /* 0x01DD34 */,
  0x0A083F80l /* 0x01DD38 */,
  0x12044676l /* 0x01DD3C */,
  0x47760A08l /* 0x01DD40 */,
  0xE0A0C600l /* 0x01DD44 */,
  0x12083F80l /* 0x01DD48 */,
  0x46011404l /* 0x01DD4C */,
  0x48760A08l /* 0x01DD50 */,
  0x0A081204l /* 0x01DD54 */,
  0xC6004976l /* 0x01DD58 */,
  0x92001304l /* 0x01DD5C */,
  0x9600C7FAl /* 0x01DD60 */,
  0x20A1DCEAl /* 0x01DD64 */,
  0x14083F80l /* 0x01DD68 */,
  0x46011208l /* 0x01DD6C */,
  0x4A760A08l /* 0x01DD70 */,
  0x0A081204l /* 0x01DD74 */,
  0xC6004B76l /* 0x01DD78 */,
  0x3F8060A1l /* 0x01DD7C */,
  0x14041208l /* 0x01DD80 */,
  0x0A084601l /* 0x01DD84 */,
  0x12044C76l /* 0x01DD88 */,
  0x4D760A08l /* 0x01DD8C */,
  0xC507C600l /* 0x01DD90 */,
  0xA0004601l /* 0x01DD94 */,
  0x910020D8l /* 0x01DD98 */,
  0x1004E4FAl /* 0x01DD9C */,
  0xFAEA9700l /* 0x01DDA0 */,
  0x3F80A0A0l /* 0x01DDA4 */,
  0x4E760A08l /* 0x01DDA8 */,
  0x0A081204l /* 0x01DDAC */,
  0xC6004F76l /* 0x01DDB0 */,
  0x3F80E0A0l /* 0x01DDB4 */,
  0x12081404l /* 0x01DDB8 */,
  0x0A084601l /* 0x01DDBC */,
  0x12045076l /* 0x01DDC0 */,
  0x51760A08l /* 0x01DDC4 */,
  0x1304C600l /* 0x01DDC8 */,
  0xFEFA9200l /* 0x01DDCC */,
  0x13EB9600l /* 0x01DDD0 */,
  0x3F8020A1l /* 0x01DDD4 */,
  0x12081408l /* 0x01DDD8 */,
  0x0A084601l /* 0x01DDDC */,
  0x12045276l /* 0x01DDE0 */,
  0x53760A08l /* 0x01DDE4 */,
  0x60A1C600l /* 0x01DDE8 */,
  0x14043F80l /* 0x01DDEC */,
  0x46011208l /* 0x01DDF0 */,
  0x54760A08l /* 0x01DDF4 */,
  0x0A081204l /* 0x01DDF8 */,
  0xC6005576l /* 0x01DDFC */,
  0x4601C507l /* 0x01DE00 */,
  0x1CD8A300l /* 0x01DE04 */,
  0x02DE7D07l /* 0x01DE08 */,
  0x940040C0l /* 0x01DE0C */,
  0x01D01FFBl /* 0x01DE10 */,
  0x9C014050l /* 0x01DE14 */,
  0x930023EBl /* 0x01DE18 */,
  0x04D026EBl /* 0x01DE1C */,
  0x10044050l /* 0x01DE20 */,
  0x3F805AA0l /* 0x01DE24 */,
  0x56660A08l /* 0x01DE28 */,
  0x9C011C04l /* 0x01DE2C */,
  0x930039EBl /* 0x01DE30 */,
  0xFF0F34EBl /* 0x01DE34 */,
  0x4040FFDDl /* 0x01DE38 */,
  0x3EE304D0l /* 0x01DE3C */,
  0xFFDFFE0Fl /* 0x01DE40 */,
  0x20D04040l /* 0x01DE44 */,
  0xFF0F3EE3l /* 0x01DE48 */,
  0x4040FFDDl /* 0x01DE4C */,
  0x00D0E402l /* 0x01DE50 */,
  0x5AA08025l /* 0x01DE54 */,
  0x0A083F80l /* 0x01DE58 */,
  0x80355666l /* 0x01DE5C */,
  0x80252400l /* 0x01DE60 */,
  0xC507C600l /* 0x01DE64 */,
  0xA3014601l /* 0x01DE68 */,
  0x9C011CD8l /* 0x01DE6C */,
  0x10044EFBl /* 0x01DE70 */,
  0x0ADE7D07l /* 0x01DE74 */,
  0x940040C0l /* 0x01DE78 */,
  0x01D055FBl /* 0x01DE7C */,
  0x5AA04050l /* 0x01DE80 */,
  0x0A083F80l /* 0x01DE84 */,
  0x24005766l /* 0x01DE88 */,
  0xC600C025l /* 0x01DE8C */,
  0x0000C507l /* 0x01DE90 */,
  0x00000000l /* 0x01DE94 */,
  0x00000000l /* 0x01DE98 */,
  0x00000000l /* 0x01DE9C */,
  0x00000000l /* 0x01DEA0 */,
  0x00000000l /* 0x01DEA4 */,
  0x00000000l /* 0x01DEA8 */,
  0x00000000l /* 0x01DEAC */,
  0x00000000l /* 0x01DEB0 */,
  0x00000000l /* 0x01DEB4 */,
  0x00000000l /* 0x01DEB8 */,
  0x00000000l /* 0x01DEBC */,
  0x00000000l /* 0x01DEC0 */,
  0x870F2980l /* 0x01DEC4 */,
  0x63158602l /* 0x01DEC8 */,
  0x62150BE8l /* 0x01DECC */,
  0x61150EE8l /* 0x01DED0 */,
  0x298016E8l /* 0x01DED4 */,
  0x970518E0l /* 0x01DED8 */,
  0x870F41D5l /* 0x01DEDC */,
  0xD5059605l /* 0x01DEE0 */,
  0x15E8D401l /* 0x01DEE4 */,
  0xD4094906l /* 0x01DEE8 */,
  0x18E0D509l /* 0x01DEEC */,
  0x94052980l /* 0x01DEF0 */,
  0x870F7FB5l /* 0x01DEF4 */,
  0x06844582l /* 0x01DEF8 */,
  0xE1DC6000l /* 0x01DEFC */,
  0x85DF6500l /* 0x01DF00 */,
  0xC60067E0l /* 0x01DF04 */,
  0x86988581l /* 0x01DF08 */,
  0x23E8A018l /* 0x01DF0C */,
  0x41E8D601l /* 0x01DF10 */,
  0x1901D609l /* 0x01DF14 */,
  0x28002EE8l /* 0x01DF18 */,
  0x8FE0C6DFl /* 0x01DF1C */,
  0x41E81F01l /* 0x01DF20 */,
  0x06994580l /* 0x01DF24 */,
  0x3F49EF0Fl /* 0x01DF28 */,
  0x2CC001B9l /* 0x01DF2C */,
  0x100E1A10l /* 0x01DF30 */,
  0xD3033EE8l /* 0x01DF34 */,
  0x28003EF8l /* 0x01DF38 */,
  0x8FE0C3DFl /* 0x01DF3C */,
  0x46804580l /* 0x01DF40 */,
  0x19011F09l /* 0x01DF44 */,
  0xC60094F8l /* 0x01DF48 */,
  0x55E81F01l /* 0x01DF4C */,
  0x4AE81401l /* 0x01DF50 */,
  0x17051409l /* 0x01DF54 */,
  0x45821209l /* 0x01DF58 */,
  0x30D96000l /* 0x01DF5C */,
  0x3F8006A9l /* 0x01DF60 */,
  0x458236F1l /* 0x01DF64 */,
  0x07800684l /* 0x01DF68 */,
  0x1FD071E0l /* 0x01DF6C */,
  0x5CE81801l /* 0x01DF70 */,
  0x46900581l /* 0x01DF74 */,
  0x6CA04040l /* 0x01DF78 */,
  0x40406C90l /* 0x01DF7C */,
  0x63E89C01l /* 0x01DF80 */,
  0x63F81301l /* 0x01DF84 */,
  0x6CA060B0l /* 0x01DF88 */,
  0x67F81401l /* 0x01DF8C */,
  0x86020780l /* 0x01DF90 */,
  0x460217C9l /* 0x01DF94 */,
  0x6FE8D001l /* 0x01DF98 */,
  0x6FE81401l /* 0x01DF9C */,
  0x45861106l /* 0x01DFA0 */,
  0x210006A9l /* 0x01DFA4 */,
  0x002B00D0l /* 0x01DFA8 */,
  0x2CC9C581l /* 0x01DFAC */,
  0x06021A19l /* 0x01DFB0 */,
  0x7DE41B39l /* 0x01DFB4 */,
  0x244B3FD9l /* 0x01DFB8 */,
  0x46023FBBl /* 0x01DFBC */,
  0x01D02200l /* 0x01DFC0 */,
  0x06AB38A0l /* 0x01DFC4 */,
  0xD5013F80l /* 0x01DFC8 */,
  0x490688E8l /* 0x01DFCC */,
  0x89E0D509l /* 0x01DFD0 */,
  0x8602D405l /* 0x01DFD4 */,
  0x4602A2C5l /* 0x01DFD8 */,
  0x46019805l /* 0x01DFDC */,
  0x6900870Fl /* 0x01DFE0 */,
  0x00C0AEDFl /* 0x01DFE4 */,
  0x870F4601l /* 0x01DFE8 */,
  0x62003ECAl /* 0x01DFEC */,
  0x460199DFl /* 0x01DFF0 */,
  0xABC8870Fl /* 0x01DFF4 */,
  0xCD0A090Cl /* 0x01DFF8 */,
  0xDAE8AB38l /* 0x01DFFC */,
  0x81B8ABC8l /* 0x01E000 */,
  0x5CCBD7E4l /* 0x01E004 */,
  0xD7FC623Bl /* 0x01E008 */,
  0x6C4B7FDBl /* 0x01E00C */,
  0xABE8AD38l /* 0x01E010 */,
  0xC4DF2800l /* 0x01E014 */,
  0xAAC86EE2l /* 0x01E018 */,
  0x9E389818l /* 0x01E01C */,
  0xBFD8DAE8l /* 0x01E020 */,
  0xBFB8AA48l /* 0x01E024 */,
  0xDAE89E38l /* 0x01E028 */,
  0x46018602l /* 0x01E02C */,
  0xA398A281l /* 0x01E030 */,
  0x8638C600l /* 0x01E034 */,
  0x4602DAFCl /* 0x01E038 */,
  0x860295C8l /* 0x01E03C */,
  0xDAEC8838l /* 0x01E040 */,
  0x94782607l /* 0x01E044 */,
  0xCAF8A018l /* 0x01E048 */,
  0x9078E804l /* 0x01E04C */,
  0xD6F8A318l /* 0x01E050 */,
  0xD6F8D503l /* 0x01E054 */,
  0xD6E8D203l /* 0x01E058 */,
  0x8078E804l /* 0x01E05C */,
  0xA278BCB8l /* 0x01E060 */,
  0x06029018l /* 0x01E064 */,
  0x623B5ECBl /* 0x01E068 */,
  0xDAE452BBl /* 0x01E06C */,
  0x9A059B05l /* 0x01E070 */,
  0x15E19805l /* 0x01E074 */,
  0x06F99101l /* 0x01E078 */,
  0x6C4B7FDBl /* 0x01E07C */,
  0x02F9D303l /* 0x01E080 */,
  0xAA48BFD8l /* 0x01E084 */,
  0x06E9A018l /* 0x01E088 */,
  0x06F9623Bl /* 0x01E08C */,
  0x22844601l /* 0x01E090 */,
  0x40DB2002l /* 0x01E094 */,
  0xC60063ABl /* 0x01E098 */,
  0xA800A198l /* 0x01E09C */,
  0xECF88048l /* 0x01E0A0 */,
  0x22834601l /* 0x01E0A4 */,
  0xC600A398l /* 0x01E0A8 */,
  0x82189E18l /* 0x01E0AC */,
  0xA868E801l /* 0x01E0B0 */,
  0x22844601l /* 0x01E0B4 */,
  0x530581D8l /* 0x01E0B8 */,
  0x2002A3A8l /* 0x01E0BC */,
  0xA3A881D8l /* 0x01E0C0 */,
  0x06E1C600l /* 0x01E0C4 */,
  0x9818AAC8l /* 0x01E0C8 */,
  0xD7EC623Bl /* 0x01E0CC */,
  0x4D0B4909l /* 0x01E0D0 */,
  0x61DB6CABl /* 0x01E0D4 */,
  0x69DB480Bl /* 0x01E0D8 */,
  0x10018D08l /* 0x01E0DC */,
  0x46010AF9l /* 0x01E0E0 */,
  0x06ABC581l /* 0x01E0E4 */,
  0x49060780l /* 0x01E0E8 */,
  0x0602D605l /* 0x01E0EC */,
  0x050AC600l /* 0x01E0F0 */,
  0x60004601l /* 0x01E0F4 */,
  0x3A83DADCl /* 0x01E0F8 */,
  0x01D02000l /* 0x01E0FC */,
  0x7A833BA0l /* 0x01E100 */,
  0x3CD0E801l /* 0x01E104 */,
  0x0B043F80l /* 0x01E108 */,
  0x0600C07El /* 0x01E10C */,
  0xC60081C8l /* 0x01E110 */,
  0x05859780l /* 0x01E114 */,
  0xC6A086A0l /* 0x01E118 */,
  0x46A106A1l /* 0x01E11C */,
  0x06ABC581l /* 0x01E120 */,
  0x068C4582l /* 0x01E124 */,
  0x49063F80l /* 0x01E128 */,
  0x34E100C0l /* 0x01E12C */,
  0x37994906l /* 0x01E130 */,
  0x37E91602l /* 0x01E134 */,
  0x00D02200l /* 0x01E138 */,
  0xC50737A0l /* 0x01E13C */,
  0x01BB2BCBl /* 0x01E140 */,
  0x40D7ACC7l /* 0x01E144 */,
  0x05DA6500l /* 0x01E148 */,
  0x9801DAE0l /* 0x01E14C */,
  0x980945E9l /* 0x01E150 */,
  0x86024601l /* 0x01E154 */,
  0x060256C8l /* 0x01E158 */,
  0xC600ACC6l /* 0x01E15C */,
  0x59E99400l /* 0x01E160 */,
  0x8DE9D301l /* 0x01E164 */,
  0x3F809780l /* 0x01E168 */,
  0xCD008D00l /* 0x01E16C */,
  0x4D010D01l /* 0x01E170 */,
  0x97808DE1l /* 0x01E174 */,
  0x8D003F80l /* 0x01E178 */,
  0x0D01CD00l /* 0x01E17C */,
  0xD7804D01l /* 0x01E180 */,
  0x8D013F80l /* 0x01E184 */,
  0x0D02CD01l /* 0x01E188 */,
  0x8D024D02l /* 0x01E18C */,
  0x0D03CD02l /* 0x01E190 */,
  0x8D034D03l /* 0x01E194 */,
  0x0D04CD03l /* 0x01E198 */,
  0x8D044D04l /* 0x01E19C */,
  0x0D05CD04l /* 0x01E1A0 */,
  0x9F004D05l /* 0x01E1A4 */,
  0x97007FF9l /* 0x01E1A8 */,
  0x96007FF9l /* 0x01E1AC */,
  0x86C27FE9l /* 0x01E1B0 */,
  0x08C3C7C2l /* 0x01E1B4 */,
  0x8EC449C3l /* 0x01E1B8 */,
  0x10C5CFC4l /* 0x01E1BC */,
  0x9E0151C5l /* 0x01E1C0 */,
  0x970084E9l /* 0x01E1C4 */,
  0x970484F9l /* 0x01E1C8 */,
  0x8DE99F00l /* 0x01E1CC */,
  0x89E99C01l /* 0x01E1D0 */,
  0x9F019104l /* 0x01E1D4 */,
  0xC2C08DE9l /* 0x01E1D8 */,
  0x178044C1l /* 0x01E1DC */,
  0x0680C582l /* 0x01E1E0 */,
  0x00D02200l /* 0x01E1E4 */,
  0x940038A0l /* 0x01E1E8 */,
  0xAE21AAF9l /* 0x01E1EC */,
  0x2E22EE21l /* 0x01E1F0 */,
  0xB0226E22l /* 0x01E1F4 */,
  0x3023F022l /* 0x01E1F8 */,
  0xAF237023l /* 0x01E1FC */,
  0x2F24EF23l /* 0x01E200 */,
  0xB1246F24l /* 0x01E204 */,
  0x3125F124l /* 0x01E208 */,
  0xD7F27125l /* 0x01E20C */,
  0xAAF99401l /* 0x01E210 */,
  0x93050EF3l /* 0x01E214 */,
  0xBBF96017l /* 0x01E218 */,
  0xB9F99101l /* 0x01E21C */,
  0x2A403FD0l /* 0x01E220 */,
  0xB9ED1E30l /* 0x01E224 */,
  0x18102AC0l /* 0x01E228 */,
  0xB9E51E30l /* 0x01E22C */,
  0xAAF39205l /* 0x01E230 */,
  0x9209BBE1l /* 0x01E234 */,
  0x9601A7F3l /* 0x01E238 */,
  0x45F3BBE9l /* 0x01E23C */,
  0x94099609l /* 0x01E240 */,
  0xC5F99400l /* 0x01E244 */,
  0xC5F99301l /* 0x01E248 */,
  0x93090EF3l /* 0x01E24C */,
  0x38D0AE00l /* 0x01E250 */,
  0xDAF99901l /* 0x01E254 */,
  0xDAE99A01l /* 0x01E258 */,
  0xD8F99101l /* 0x01E25C */,
  0xD8F99B01l /* 0x01E260 */,
  0xD8F9D303l /* 0x01E264 */,
  0x2A403FD0l /* 0x01E268 */,
  0xD8E92010l /* 0x01E26C */,
  0x77E29A09l /* 0x01E270 */,
  0x9905490Fl /* 0x01E274 */,
  0x55000D98l /* 0x01E278 */,
  0x01B0E5F9l /* 0x01E27C */,
  0x4601E5EDl /* 0x01E280 */,
  0x0698C582l /* 0x01E284 */,
  0xE5E91000l /* 0x01E288 */,
  0xC6000680l /* 0x01E28C */,
  0xC8E99701l /* 0x01E290 */,
  0x970968F3l /* 0x01E294 */,
  0x1BC07FB7l /* 0x01E298 */,
  0x43EE1D30l /* 0x01E29C */,
  0xBFB19EC1l /* 0x01E2A0 */,
  0x14EA9C01l /* 0x01E2A4 */,
  0xF6E99201l /* 0x01E2A8 */,
  0x0CFAD303l /* 0x01E2AC */,
  0x24D0E704l /* 0x01E2B0 */,
  0x94D0E704l /* 0x01E2B4 */,
  0xCCD0E704l /* 0x01E2B8 */,
  0x3FD0CCF3l /* 0x01E2BC */,
  0x1E302A40l /* 0x01E2C0 */,
  0x2AC00CEEl /* 0x01E2C4 */,
  0x1E301810l /* 0x01E2C8 */,
  0xE7042AF6l /* 0x01E2CC */,
  0xE70428D0l /* 0x01E2D0 */,
  0xE704A0D0l /* 0x01E2D4 */,
  0x12E2DCD0l /* 0x01E2D8 */,
  0x28D0E704l /* 0x01E2DC */,
  0x98D0E704l /* 0x01E2E0 */,
  0xD0D0E704l /* 0x01E2E4 */,
  0x2AE2CCF3l /* 0x01E2E8 */,
  0x81B18111l /* 0x01E2EC */,
  0x24D0E704l /* 0x01E2F0 */,
  0x94D0E704l /* 0x01E2F4 */,
  0xCCD0E704l /* 0x01E2F8 */,
  0x22EA9D01l /* 0x01E2FC */,
  0x98D0E704l /* 0x01E300 */,
  0xD0D0E704l /* 0x01E304 */,
  0x01D0CCF3l /* 0x01E308 */,
  0x2AEA0640l /* 0x01E30C */,
  0xE70481B1l /* 0x01E310 */,
  0x18E228D0l /* 0x01E314 */,
  0x1E301CC0l /* 0x01E318 */,
  0x33FA01B0l /* 0x01E31C */,
  0x33EAD303l /* 0x01E320 */,
  0xAA47BFD7l /* 0x01E324 */,
  0xBFB781B7l /* 0x01E328 */,
  0x1CC040D7l /* 0x01E32C */,
  0x1E3004B0l /* 0x01E330 */,
  0xEA0443FAl /* 0x01E334 */,
  0x22100070l /* 0x01E338 */,
  0x241043EAl /* 0x01E33C */,
  0x280043EAl /* 0x01E340 */,
  0x61050470l /* 0x01E344 */,
  0x9A011860l /* 0x01E348 */,
  0x1CC04BFAl /* 0x01E34C */,
  0x45ED1E30l /* 0x01E350 */,
  0xC5DF2800l /* 0x01E354 */,
  0xD3036EE2l /* 0x01E358 */,
  0x9B0168EAl /* 0x01E35C */,
  0xE70468FAl /* 0x01E360 */,
  0xAC041C70l /* 0x01E364 */,
  0xE7041030l /* 0x01E368 */,
  0x817058D0l /* 0x01E36C */,
  0x5FEAA010l /* 0x01E370 */,
  0x0278BCB0l /* 0x01E374 */,
  0x02680058l /* 0x01E378 */,
  0x2070E704l /* 0x01E37C */,
  0xD30B0160l /* 0x01E380 */,
  0xCD0A090Cl /* 0x01E384 */,
  0x68EAE01Al /* 0x01E388 */,
  0x2FD02200l /* 0x01E38C */,
  0x60EE2B30l /* 0x01E390 */,
  0x50D0A900l /* 0x01E394 */,
  0x600012D0l /* 0x01E398 */,
  0x0500C0D7l /* 0x01E39C */,
  0x4601D30Bl /* 0x01E3A0 */,
  0x01D07000l /* 0x01E3A4 */,
  0x3F8037A0l /* 0x01E3A8 */,
  0x00C0C600l /* 0x01E3AC */,
  0x1CC075E2l /* 0x01E3B0 */,
  0x1E3001B0l /* 0x01E3B4 */,
  0x28007EFEl /* 0x01E3B8 */,
  0x6EE2C5DFl /* 0x01E3BC */,
  0xE801B9F2l /* 0x01E3C0 */,
  0xC2F26870l /* 0x01E3C4 */,
  0x00D895F2l /* 0x01E3C8 */,
  0x22845304l /* 0x01E3CC */,
  0xB4F223A8l /* 0x01E3D0 */,
  0xEA4AFFDAl /* 0x01E3D4 */,
  0x090CFFBAl /* 0x01E3D8 */,
  0x2B300D00l /* 0x01E3DC */,
  0xD3078BFAl /* 0x01E3E0 */,
  0x2A4B3FDBl /* 0x01E3E4 */,
  0x06DA6700l /* 0x01E3E8 */,
  0x230006E1l /* 0x01E3EC */,
  0x22814830l /* 0x01E3F0 */,
  0x1E182398l /* 0x01E3F4 */,
  0x6D050418l /* 0x01E3F8 */,
  0x01380870l /* 0x01E3FC */,
  0x4020A0FEl /* 0x01E400 */,
  0x23982283l /* 0x01E404 */,
  0x02181E18l /* 0x01E408 */,
  0x013863A0l /* 0x01E40C */,
  0x0028A8EEl /* 0x01E410 */,
  0x63906280l /* 0x01E414 */,
  0x42105E10l /* 0x01E418 */,
  0x63A06020l /* 0x01E41C */,
  0x21010130l /* 0x01E420 */,
  0xA2800030l /* 0x01E424 */,
  0xC50723A0l /* 0x01E428 */,
  0x32002284l /* 0x01E42C */,
  0x23A001D8l /* 0x01E430 */,
  0x2284BDE2l /* 0x01E434 */,
  0x00D0A002l /* 0x01E438 */,
  0x219023A0l /* 0x01E43C */,
  0x0040A800l /* 0x01E440 */,
  0xC507BDFAl /* 0x01E444 */,
  0x55000D98l /* 0x01E448 */,
  0xC907C8FAl /* 0x01E44C */,
  0xC2E20D08l /* 0x01E450 */,
  0x00D020D8l /* 0x01E454 */,
  0x0EA001B0l /* 0x01E458 */,
  0xCBEE01B8l /* 0x01E45C */,
  0x0D08C907l /* 0x01E460 */,
  0x0D08C907l /* 0x01E464 */,
  0x0D08C907l /* 0x01E468 */,
  0x0D08C907l /* 0x01E46C */,
  0x4601C507l /* 0x01E470 */,
  0x00D8A000l /* 0x01E474 */,
  0xDDFA9100l /* 0x01E478 */,
  0x97001004l /* 0x01E47C */,
  0xA0A0F3EAl /* 0x01E480 */,
  0x0A083F80l /* 0x01E484 */,
  0x12044676l /* 0x01E488 */,
  0x47760A08l /* 0x01E48C */,
  0xE0A0C600l /* 0x01E490 */,
  0x12083F80l /* 0x01E494 */,
  0x46011404l /* 0x01E498 */,
  0x48760A08l /* 0x01E49C */,
  0x0A081204l /* 0x01E4A0 */,
  0xC6004976l /* 0x01E4A4 */,
  0x92001304l /* 0x01E4A8 */,
  0x9600F7FAl /* 0x01E4AC */,
  0x20A10CEBl /* 0x01E4B0 */,
  0x14083F80l /* 0x01E4B4 */,
  0x46011208l /* 0x01E4B8 */,
  0x4A760A08l /* 0x01E4BC */,
  0x0A081204l /* 0x01E4C0 */,
  0xC6004B76l /* 0x01E4C4 */,
  0x3F8060A1l /* 0x01E4C8 */,
  0x14041208l /* 0x01E4CC */,
  0x0A084601l /* 0x01E4D0 */,
  0x12044C76l /* 0x01E4D4 */,
  0x4D760A08l /* 0x01E4D8 */,
  0xC507C600l /* 0x01E4DC */,
  0xA0004601l /* 0x01E4E0 */,
  0x910020D8l /* 0x01E4E4 */,
  0x100414FBl /* 0x01E4E8 */,
  0x2AEB9700l /* 0x01E4EC */,
  0x3F80A0A0l /* 0x01E4F0 */,
  0x4E760A08l /* 0x01E4F4 */,
  0x0A081204l /* 0x01E4F8 */,
  0xC6004F76l /* 0x01E4FC */,
  0x3F80E0A0l /* 0x01E500 */,
  0x12081404l /* 0x01E504 */,
  0x0A084601l /* 0x01E508 */,
  0x12045076l /* 0x01E50C */,
  0x51760A08l /* 0x01E510 */,
  0x1304C600l /* 0x01E514 */,
  0x2EFB9200l /* 0x01E518 */,
  0x43EB9600l /* 0x01E51C */,
  0x3F8020A1l /* 0x01E520 */,
  0x12081408l /* 0x01E524 */,
  0x0A084601l /* 0x01E528 */,
  0x12045276l /* 0x01E52C */,
  0x53760A08l /* 0x01E530 */,
  0x60A1C600l /* 0x01E534 */,
  0x14043F80l /* 0x01E538 */,
  0x46011208l /* 0x01E53C */,
  0x54760A08l /* 0x01E540 */,
  0x0A081204l /* 0x01E544 */,
  0xC6005576l /* 0x01E548 */,
  0x4601C507l /* 0x01E54C */,
  0x1DD8A300l /* 0x01E550 */,
  0x06DE7D07l /* 0x01E554 */,
  0x940040C0l /* 0x01E558 */,
  0x01D04FFBl /* 0x01E55C */,
  0x5AA04050l /* 0x01E560 */,
  0x0A083F80l /* 0x01E564 */,
  0x1C045966l /* 0x01E568 */,
  0xFFDDFF0Fl /* 0x01E56C */,
  0x5AA04040l /* 0x01E570 */,
  0x0A083F80l /* 0x01E574 */,
  0x24005766l /* 0x01E578 */,
  0x402600D0l /* 0x01E57C */,
  0x9201C025l /* 0x01E580 */,
  0xD30366EBl /* 0x01E584 */,
  0xC03565FBl /* 0x01E588 */,
  0x403666E3l /* 0x01E58C */,
  0xC507C600l /* 0x01E590 */,
  0xA3004601l /* 0x01E594 */,
  0x7D030DD8l /* 0x01E598 */,
  0x40C00EDEl /* 0x01E59C */,
  0x72FB9400l /* 0x01E5A0 */,
  0x405001D0l /* 0x01E5A4 */,
  0x3F805AA0l /* 0x01E5A8 */,
  0x58660A08l /* 0x01E5AC */,
  0xFF0F1C04l /* 0x01E5B0 */,
  0x4040FFDDl /* 0x01E5B4 */,
  0x3F805AA0l /* 0x01E5B8 */,
  0x56660A08l /* 0x01E5BC */,
  0x00D02400l /* 0x01E5C0 */,
  0x80250026l /* 0x01E5C4 */,
  0x66EB9201l /* 0x01E5C8 */,
  0x88FBD303l /* 0x01E5CC */,
  0x66E38035l /* 0x01E5D0 */,
  0x66E30036l /* 0x01E5D4 */,
  0x04D0E704l /* 0x01E5D8 */,
  0x60104070l /* 0x01E5DC */,
  0x01C88AEBl /* 0x01E5E0 */,
  0x20783CB8l /* 0x01E5E4 */,
  0x3F48EF0Fl /* 0x01E5E8 */,
  0xAC0499EBl /* 0x01E5EC */,
  0x00681028l /* 0x01E5F0 */,
  0x00689CE3l /* 0x01E5F4 */,
  0x00683CB0l /* 0x01E5F8 */,
  0x0178C507l /* 0x01E5FC */,
  0x00D0E402l /* 0x01E600 */,
  0xA5FB1000l /* 0x01E604 */,
  0x403060D0l /* 0x01E608 */,
  0x100801C0l /* 0x01E60C */,
  0xCB17C507l /* 0x01E610 */,
  0xB4E35F57l /* 0x01E614 */,
  0x5F57CB17l /* 0x01E618 */,
  0x00DFFF07l /* 0x01E61C */,
  0x40C600C6l /* 0x01E620 */,
  0x80C5C0C5l /* 0x01E624 */,
  0xBEFBD303l /* 0x01E628 */,
  0xE7048AF3l /* 0x01E62C */,
  0x406024D0l /* 0x01E630 */,
  0x20C69DF3l /* 0x01E634 */,
  0x403660C6l /* 0x01E638 */,
  0xC6FB9201l /* 0x01E63C */,
  0xE7048AF3l /* 0x01E640 */,
  0x406028D0l /* 0x01E644 */,
  0xA0C59DF3l /* 0x01E648 */,
  0xC035E0C5l /* 0x01E64C */,
  0x2300DDC7l /* 0x01E650 */,
  0xD5177F47l /* 0x01E654 */,
  0xC507E017l /* 0x01E658 */,
  0x407006C8l /* 0x01E65C */,
  0x3CB001C0l /* 0x01E660 */,
  0x08180818l /* 0x01E664 */,
  0x02700068l /* 0x01E668 */,
  0xE8FB2010l /* 0x01E66C */,
  0x20D0E704l /* 0x01E670 */,
  0xDCEB0230l /* 0x01E674 */,
  0xDFFBA111l /* 0x01E678 */,
  0x42604360l /* 0x01E67C */,
  0xE704EFE3l /* 0x01E680 */,
  0x807004D0l /* 0x01E684 */,
  0x7CB04060l /* 0x01E688 */,
  0x9030AC04l /* 0x01E68C */,
  0xC5078160l /* 0x01E690 */,
  0x3CB04260l /* 0x01E694 */,
  0xAC048070l /* 0x01E698 */,
  0x42205030l /* 0x01E69C */,
  0xC5074060l /* 0x01E6A0 */,
  0x610541D0l /* 0x01E6A4 */,
  0x2F056860l /* 0x01E6A8 */,
  0x56075460l /* 0x01E6AC */,
  0xB4726A05l /* 0x01E6B0 */,
  0xF0726A05l /* 0x01E6B4 */,
  0x2873EA04l /* 0x01E6B8 */,
  0x78736A05l /* 0x01E6BC */,
  0x70D0A800l /* 0x01E6C0 */,
  0x48602805l /* 0x01E6C4 */,
  0x40D06000l /* 0x01E6C8 */,
  0x4C602805l /* 0x01E6CC */,
  0x84F03BF0l /* 0x01E6D0 */,
  0x01D82000l /* 0x01E6D4 */,
  0x2EEC2B38l /* 0x01E6D8 */,
  0x6FD82200l /* 0x01E6DC */,
  0x21F46B38l /* 0x01E6E0 */,
  0x10C02EE0l /* 0x01E6E4 */,
  0x2CF82B30l /* 0x01E6E8 */,
  0x0070EA04l /* 0x01E6EC */,
  0x2CE82210l /* 0x01E6F0 */,
  0x44702800l /* 0x01E6F4 */,
  0x58606105l /* 0x01E6F8 */,
  0x17E050F0l /* 0x01E6FC */,
  0x610540D0l /* 0x01E700 */,
  0x40D05860l /* 0x01E704 */,
  0x68606105l /* 0x01E708 */,
  0xA9005607l /* 0x01E70C */,
  0x12D058D0l /* 0x01E710 */,
  0xC0D76000l /* 0x01E714 */,
  0xA2050500l /* 0x01E718 */,
  0xA2050474l /* 0x01E71C */,
  0x1001A078l /* 0x01E720 */,
  0xA2054DF8l /* 0x01E724 */,
  0x21102870l /* 0x01E728 */,
  0x21B44DE8l /* 0x01E72C */,
  0xAC051B14l /* 0x01E730 */,
  0x23102070l /* 0x01E734 */,
  0x01144FF8l /* 0x01E738 */,
  0x31B44FE0l /* 0x01E73C */,
  0xC5071C14l /* 0x01E740 */,
  0xA398A281l /* 0x01E744 */,
  0x83FC8B38l /* 0x01E748 */,
  0x95C84602l /* 0x01E74C */,
  0x6B050602l /* 0x01E750 */,
  0x40D02470l /* 0x01E754 */,
  0x01B06220l /* 0x01E758 */,
  0x0DC05AECl /* 0x01E75C */,
  0x0A300130l /* 0x01E760 */,
  0x241383FCl /* 0x01E764 */,
  0x280574F8l /* 0x01E768 */,
  0xEF06D873l /* 0x01E76C */,
  0x0FC09873l /* 0x01E770 */,
  0x83E80E30l /* 0x01E774 */,
  0x30B00EC0l /* 0x01E778 */,
  0x68D02B01l /* 0x01E77C */,
  0x72EC4030l /* 0x01E780 */,
  0x08D0EF00l /* 0x01E784 */,
  0x83E80F30l /* 0x01E788 */,
  0x6C0540D0l /* 0x01E78C */,
  0x41D04460l /* 0x01E790 */,
  0x58606E05l /* 0x01E794 */,
  0x610540D0l /* 0x01E798 */,
  0xA7004C60l /* 0x01E79C */,
  0x12D050D0l /* 0x01E7A0 */,
  0xC0D76000l /* 0x01E7A4 */,
  0xC5070500l /* 0x01E7A8 */,
  0x3684090Cl /* 0x01E7AC */,
  0xF4AA3F80l /* 0x01E7B0 */,
  0xF4AACD0Al /* 0x01E7B4 */,
  0x0000C507l /* 0x01E7B8 */,
  0x0074EC04l /* 0x01E7BC */,
  0x00712E00l /* 0x01E7C0 */,
  0x6471EB04l /* 0x01E7C4 */,
  0xC074A205l /* 0x01E7C8 */,
  0xA205DC14l /* 0x01E7CC */,
  0x21140475l /* 0x01E7D0 */,
  0x1F1511E8l /* 0x01E7D4 */,
  0x11E82214l /* 0x01E7D8 */,
  0xEB041F15l /* 0x01E7DC */,
  0xEB047872l /* 0x01E7E0 */,
  0x80D0BC72l /* 0x01E7E4 */,
  0x8060ED04l /* 0x01E7E8 */,
  0x8460ED04l /* 0x01E7EC */,
  0x00D0E402l /* 0x01E7F0 */,
  0x4AC080D0l /* 0x01E7F4 */,
  0x60105C10l /* 0x01E7F8 */,
  0x802024E8l /* 0x01E7FC */,
  0x21F841B0l /* 0x01E800 */,
  0x0FD02000l /* 0x01E804 */,
  0x02100A40l /* 0x01E808 */,
  0x09C08020l /* 0x01E80C */,
  0x06101E10l /* 0x01E810 */,
  0xC4C08020l /* 0x01E814 */,
  0xEC04C220l /* 0x01E818 */,
  0x2300F060l /* 0x01E81C */,
  0x0221BF40l /* 0x01E820 */,
  0xBEB184C1l /* 0x01E824 */,
  0xD3C294C4l /* 0x01E828 */,
  0x2300C5C1l /* 0x01E82C */,
  0x44D03FD0l /* 0x01E830 */,
  0x40D4C0D0l /* 0x01E834 */,
  0x40D0A900l /* 0x01E838 */,
  0x48602805l /* 0x01E83C */,
  0x48D06100l /* 0x01E840 */,
  0x4C602805l /* 0x01E844 */,
  0xE7F2D0F2l /* 0x01E848 */,
  0x2300B3F2l /* 0x01E84C */,
  0x44D03FD0l /* 0x01E850 */,
  0xE0B18770l /* 0x01E854 */,
  0x6410E0B1l /* 0x01E858 */,
  0x631057E8l /* 0x01E85C */,
  0x621061E8l /* 0x01E860 */,
  0x61106BE8l /* 0x01E864 */,
  0x02C375E8l /* 0x01E868 */,
  0x00439010l /* 0x01E86C */,
  0xCC208040l /* 0x01E870 */,
  0x8810C220l /* 0x01E874 */,
  0x41B00223l /* 0x01E878 */,
  0x42C34CE0l /* 0x01E87C */,
  0x40439010l /* 0x01E880 */,
  0xCD208040l /* 0x01E884 */,
  0x8810C220l /* 0x01E888 */,
  0x41B04223l /* 0x01E88C */,
  0x82C34CE0l /* 0x01E890 */,
  0x80439010l /* 0x01E894 */,
  0xCE208040l /* 0x01E898 */,
  0x8810C220l /* 0x01E89C */,
  0x41B08223l /* 0x01E8A0 */,
  0xC2C34CE0l /* 0x01E8A4 */,
  0xC0439010l /* 0x01E8A8 */,
  0xCF208040l /* 0x01E8AC */,
  0xDD10C220l /* 0x01E8B0 */,
  0xC0D04324l /* 0x01E8B4 */,
  0xC2238810l /* 0x01E8B8 */,
  0xA9E82214l /* 0x01E8BC */,
  0x00438CC0l /* 0x01E8C0 */,
  0x02239810l /* 0x01E8C4 */,
  0x8DC01F13l /* 0x01E8C8 */,
  0x98104043l /* 0x01E8CC */,
  0x5F134223l /* 0x01E8D0 */,
  0x80438EC0l /* 0x01E8D4 */,
  0x82239810l /* 0x01E8D8 */,
  0x8FC09F13l /* 0x01E8DC */,
  0x9810C043l /* 0x01E8E0 */,
  0xDF13C223l /* 0x01E8E4 */,
  0x0D230813l /* 0x01E8E8 */,
  0x3DA34601l /* 0x01E8EC */,
  0x4E234813l /* 0x01E8F0 */,
  0x4F234813l /* 0x01E8F4 */,
  0x06607CA3l /* 0x01E8F8 */,
  0xC6003F80l /* 0x01E8FC */,
  0xA0B144D0l /* 0x01E900 */,
  0xC1B2A0B1l /* 0x01E904 */,
  0x70B14CF8l /* 0x01E908 */,
  0x4601C6E0l /* 0x01E90C */,
  0x08133DA3l /* 0x01E910 */,
  0x0D230813l /* 0x01E914 */,
  0x06603CA3l /* 0x01E918 */,
  0xC6003F80l /* 0x01E91C */,
  0xA0B1A0B1l /* 0x01E920 */,
  0x06704601l /* 0x01E924 */,
  0x8813BDA3l /* 0x01E928 */,
  0x8F238813l /* 0x01E92C */,
  0x0660BCA3l /* 0x01E930 */,
  0xC6003F80l /* 0x01E934 */,
  0xA0B1A0B1l /* 0x01E938 */,
  0x3FD02300l /* 0x01E93C */,
  0xC1B244D0l /* 0x01E940 */,
  0x78B14CF8l /* 0x01E944 */,
  0x45407FD0l /* 0x01E948 */,
  0x50B1CFF8l /* 0x01E94C */,
  0x50B150B1l /* 0x01E950 */,
  0xE40250B1l /* 0x01E954 */,
  0xC5C14021l /* 0x01E958 */,
  0x7FD03CB1l /* 0x01E95C */,
  0xDAF84440l /* 0x01E960 */,
  0x10B110B1l /* 0x01E964 */,
  0x10B110B1l /* 0x01E968 */,
  0x0021E402l /* 0x01E96C */,
  0xBEB184C1l /* 0x01E970 */,
  0x2300D3C2l /* 0x01E974 */,
  0x44D03FD0l /* 0x01E978 */,
  0xA01481B4l /* 0x01E97C */,
  0x00D046F8l /* 0x01E980 */,
  0x59B43FB0l /* 0x01E984 */,
  0xE4EC54B4l /* 0x01E988 */,
  0x270050C0l /* 0x01E98C */,
  0x9F10A0D0l /* 0x01E990 */,
  0x61105F10l /* 0x01E994 */,
  0x40D4EBF8l /* 0x01E998 */,
  0x02307FB4l /* 0x01E99C */,
  0x94C4F0ECl /* 0x01E9A0 */,
  0x75009F14l /* 0x01E9A4 */,
  0x2D0080D1l /* 0x01E9A8 */,
  0xE804A070l /* 0x01E9AC */,
  0x81306070l /* 0x01E9B0 */,
  0x7900FFE8l /* 0x01E9B4 */,
  0xC0C000D5l /* 0x01E9B8 */,
  0x021100C1l /* 0x01E9BC */,
  0x44C11F10l /* 0x01E9C0 */,
  0x2470EB04l /* 0x01E9C4 */,
  0xEB044021l /* 0x01E9C8 */,
  0xE4022471l /* 0x01E9CC */,
  0x80D000D0l /* 0x01E9D0 */,
  0x5B104AC0l /* 0x01E9D4 */,
  0x13E96010l /* 0x01E9D8 */,
  0x41B08020l /* 0x01E9DC */,
  0x200010F9l /* 0x01E9E0 */,
  0x0A401FD0l /* 0x01E9E4 */,
  0x80200110l /* 0x01E9E8 */,
  0x1E1009C0l /* 0x01E9EC */,
  0x80200610l /* 0x01E9F0 */,
  0x422044C0l /* 0x01E9F4 */,
  0x7460EC04l /* 0x01E9F8 */,
  0xBF402300l /* 0x01E9FC */,
  0x84C10221l /* 0x01EA00 */,
  0xC5C1BEB1l /* 0x01EA04 */,
  0x40D0A900l /* 0x01EA08 */,
  0x48602805l /* 0x01EA0C */,
  0x70D06400l /* 0x01EA10 */,
  0x4C602805l /* 0x01EA14 */,
  0xE7F2D0F2l /* 0x01EA18 */,
  0x2214B3F2l /* 0x01EA1C */,
  0xD3C23CE9l /* 0x01EA20 */,
  0xE0B1E0B1l /* 0x01EA24 */,
  0x2300F8B1l /* 0x01EA28 */,
  0x22003FD0l /* 0x01EA2C */,
  0x43E140D0l /* 0x01EA30 */,
  0xC112D3C2l /* 0x01EA34 */,
  0x2300FCB1l /* 0x01EA38 */,
  0x21003FD0l /* 0x01EA3C */,
  0x077340D0l /* 0x01EA40 */,
  0x4773C121l /* 0x01EA44 */,
  0x8CC3C121l /* 0x01EA48 */,
  0x00439013l /* 0x01EA4C */,
  0xCDC38043l /* 0x01EA50 */,
  0x4043D013l /* 0x01EA54 */,
  0x8813C043l /* 0x01EA58 */,
  0x46018F23l /* 0x01EA5C */,
  0xC813BDA3l /* 0x01EA60 */,
  0xC813CC23l /* 0x01EA64 */,
  0xFCA3CD23l /* 0x01EA68 */,
  0x3F800660l /* 0x01EA6C */,
  0xA0B1C600l /* 0x01EA70 */,
  0xC1B2A0B1l /* 0x01EA74 */,
  0x5D1043F9l /* 0x01EA78 */,
  0x3FD04121l /* 0x01EA7C */,
  0x6AF90540l /* 0x01EA80 */,
  0x50B150B1l /* 0x01EA84 */,
  0x50B150B1l /* 0x01EA88 */,
  0x4021E402l /* 0x01EA8C */,
  0x3CB1C5C1l /* 0x01EA90 */,
  0x04403FD0l /* 0x01EA94 */,
  0x10B175F9l /* 0x01EA98 */,
  0x10B110B1l /* 0x01EA9C */,
  0xE40210B1l /* 0x01EAA0 */,
  0x84C10021l /* 0x01EAA4 */,
  0x81B4BEB1l /* 0x01EAA8 */,
  0xEB042EF9l /* 0x01EAAC */,
  0x1F103C70l /* 0x01EAB0 */,
  0x4470A205l /* 0x01EAB4 */,
  0x21145F10l /* 0x01EAB8 */,
  0x5F1085E9l /* 0x01EABC */,
  0x85E92214l /* 0x01EAC0 */,
  0x01205F10l /* 0x01EAC4 */,
  0xA90040C3l /* 0x01EAC8 */,
  0x280540D0l /* 0x01EACC */,
  0x66004860l /* 0x01EAD0 */,
  0x280551D0l /* 0x01EAD4 */,
  0xD0F24C60l /* 0x01EAD8 */,
  0xB3F2E7F2l /* 0x01EADC */,
  0x18C84602l /* 0x01EAE0 */,
  0x60C00602l /* 0x01EAE4 */,
  0x8FE54D30l /* 0x01EAE8 */,
  0xB0D16E00l /* 0x01EAEC */,
  0x40D22100l /* 0x01EAF0 */,
  0xFCD12000l /* 0x01EAF4 */,
  0x00712E00l /* 0x01EAF8 */,
  0xEB0440D5l /* 0x01EAFC */,
  0xEC046071l /* 0x01EB00 */,
  0x04303070l /* 0x01EB04 */,
  0x23004021l /* 0x01EB08 */,
  0x40407FD0l /* 0x01EB0C */,
  0x20000121l /* 0x01EB10 */,
  0x01403FD0l /* 0x01EB14 */,
  0xA205C031l /* 0x01EB18 */,
  0x80C20070l /* 0x01EB1C */,
  0x21149E12l /* 0x01EB20 */,
  0x94C2B7F9l /* 0x01EB24 */,
  0x9F12BBE1l /* 0x01EB28 */,
  0xBBE92214l /* 0x01EB2C */,
  0x2B009F12l /* 0x01EB30 */,
  0x211454D0l /* 0x01EB34 */,
  0x1F10C3E9l /* 0x01EB38 */,
  0xC3E92214l /* 0x01EB3C */,
  0x40301F10l /* 0x01EB40 */,
  0xC1C24410l /* 0x01EB44 */,
  0xA205D522l /* 0x01EB48 */,
  0x02100470l /* 0x01EB4C */,
  0xD0E92114l /* 0x01EB50 */,
  0x22141F10l /* 0x01EB54 */,
  0x1F10D0E9l /* 0x01EB58 */,
  0xED0400C3l /* 0x01EB5C */,
  0x82158475l /* 0x01EB60 */,
  0xEC041633l /* 0x01EB64 */,
  0x01E22863l /* 0x01EB68 */,
  0x0B214B21l /* 0x01EB6C */,
  0x0070A205l /* 0x01EB70 */,
  0x9E1280C2l /* 0x01EB74 */,
  0xE2F92114l /* 0x01EB78 */,
  0xE6E194C2l /* 0x01EB7C */,
  0x22149F12l /* 0x01EB80 */,
  0x9F12E6E9l /* 0x01EB84 */,
  0x45407FD0l /* 0x01EB88 */,
  0x2E00F9E9l /* 0x01EB8C */,
  0x00310070l /* 0x01EB90 */,
  0x00C14431l /* 0x01EB94 */,
  0x00D0E402l /* 0x01EB98 */,
  0x40210021l /* 0x01EB9C */,
  0x3070EC04l /* 0x01EBA0 */,
  0x40D02300l /* 0x01EBA4 */,
  0x01214040l /* 0x01EBA8 */,
  0x21004121l /* 0x01EBAC */,
  0x0C3000D0l /* 0x01EBB0 */,
  0xFCD1FFEDl /* 0x01EBB4 */,
  0xCCC101E2l /* 0x01EBB8 */,
  0x4601C4B1l /* 0x01EBBC */,
  0x3F80B6A1l /* 0x01EBC0 */,
  0x047DCA01l /* 0x01EBC4 */,
  0xA0000600l /* 0x01EBC8 */,
  0x065000D0l /* 0x01EBCC */,
  0x3F8036A0l /* 0x01EBD0 */,
  0x056DCA01l /* 0x01EBD4 */,
  0xC6000600l /* 0x01EBD8 */,
  0x15FE81B2l /* 0x01EBDC */,
  0x49210921l /* 0x01EBE0 */,
  0x073301E2l /* 0x01EBE4 */,
  0x201304B3l /* 0x01EBE8 */,
  0x2100D8EDl /* 0x01EBEC */,
  0x200040D2l /* 0x01EBF0 */,
  0xEB04FCD1l /* 0x01EBF4 */,
  0xEB042471l /* 0x01EBF8 */,
  0x74016071l /* 0x01EBFC */,
  0x2D0000D6l /* 0x01EC00 */,
  0xE804A070l /* 0x01EC04 */,
  0x81306070l /* 0x01EC08 */,
  0xB5012BEAl /* 0x01EC0C */,
  0x402100D4l /* 0x01EC10 */,
  0xEC0480C0l /* 0x01EC14 */,
  0x04303470l /* 0x01EC18 */,
  0x23004021l /* 0x01EC1C */,
  0x40407FD0l /* 0x01EC20 */,
  0x3FD02000l /* 0x01EC24 */,
  0x01210140l /* 0x01EC28 */,
  0x84C4C031l /* 0x01EC2C */,
  0xA205C5C4l /* 0x01EC30 */,
  0x80C20070l /* 0x01EC34 */,
  0x21149E12l /* 0x01EC38 */,
  0x94C243FAl /* 0x01EC3C */,
  0x9F1247E2l /* 0x01EC40 */,
  0x47EA2214l /* 0x01EC44 */,
  0x2B009F12l /* 0x01EC48 */,
  0x211454D0l /* 0x01EC4C */,
  0x1F104FEAl /* 0x01EC50 */,
  0x4FEA2214l /* 0x01EC54 */,
  0x40301F10l /* 0x01EC58 */,
  0xC1C24410l /* 0x01EC5C */,
  0xA205D522l /* 0x01EC60 */,
  0x01100470l /* 0x01EC64 */,
  0x5CEA2114l /* 0x01EC68 */,
  0x22141F10l /* 0x01EC6C */,
  0x1F105CEAl /* 0x01EC70 */,
  0xED0400C3l /* 0x01EC74 */,
  0x81158475l /* 0x01EC78 */,
  0xEC041633l /* 0x01EC7C */,
  0x8EE22860l /* 0x01EC80 */,
  0x0B214B21l /* 0x01EC84 */,
  0x0070A205l /* 0x01EC88 */,
  0x9E1280C2l /* 0x01EC8C */,
  0x6EFA2114l /* 0x01EC90 */,
  0x72E294C2l /* 0x01EC94 */,
  0x22149F12l /* 0x01EC98 */,
  0x9F1272EAl /* 0x01EC9C */,
  0x45407FD0l /* 0x01ECA0 */,
  0xEB0486EAl /* 0x01ECA4 */,
  0x00312470l /* 0x01ECA8 */,
  0x00C14431l /* 0x01ECAC */,
  0x00D0E402l /* 0x01ECB0 */,
  0x40210021l /* 0x01ECB4 */,
  0x3470EC04l /* 0x01ECB8 */,
  0x40D02300l /* 0x01ECBC */,
  0x01214040l /* 0x01ECC0 */,
  0x86E24121l /* 0x01ECC4 */,
  0x00D02100l /* 0x01ECC8 */,
  0x8CEE0C30l /* 0x01ECCC */,
  0x8EE2FCD1l /* 0x01ECD0 */,
  0xC4B1CCC1l /* 0x01ECD4 */,
  0xB6A14601l /* 0x01ECD8 */,
  0xCA013F80l /* 0x01ECDC */,
  0x0600047Dl /* 0x01ECE0 */,
  0x00D0A000l /* 0x01ECE4 */,
  0x36A00650l /* 0x01ECE8 */,
  0xCA013F80l /* 0x01ECEC */,
  0x0600056Dl /* 0x01ECF0 */,
  0x81B2C600l /* 0x01ECF4 */,
  0x0921A2FEl /* 0x01ECF8 */,
  0x8EE24921l /* 0x01ECFC */,
  0x04B30733l /* 0x01ED00 */,
  0x23F364EEl /* 0x01ED04 */,
  0x7070EB04l /* 0x01ED08 */,
  0xADF65130l /* 0x01ED0C */,
  0xEB0440D0l /* 0x01ED10 */,
  0xA7007060l /* 0x01ED14 */,
  0x12D058D0l /* 0x01ED18 */,
  0xDAD76000l /* 0x01ED1C */,
  0xEB040500l /* 0x01ED20 */,
  0xEB047872l /* 0x01ED24 */,
  0xEC04BC72l /* 0x01ED28 */,
  0xEC040074l /* 0x01ED2C */,
  0xEC044471l /* 0x01ED30 */,
  0xEC040871l /* 0x01ED34 */,
  0xEC04CC71l /* 0x01ED38 */,
  0xEC049071l /* 0x01ED3C */,
  0xEC04D472l /* 0x01ED40 */,
  0xEC045874l /* 0x01ED44 */,
  0xEC049C74l /* 0x01ED48 */,
  0xEC04E074l /* 0x01ED4C */,
  0xEC042475l /* 0x01ED50 */,
  0xEC046870l /* 0x01ED54 */,
  0xC507AC70l /* 0x01ED58 */,
  0x4461EC04l /* 0x01ED5C */,
  0x0861EC04l /* 0x01ED60 */,
  0xCC61EC04l /* 0x01ED64 */,
  0x9061EC04l /* 0x01ED68 */,
  0xD462EC04l /* 0x01ED6C */,
  0x5864EC04l /* 0x01ED70 */,
  0x9C64EC04l /* 0x01ED74 */,
  0xE064EC04l /* 0x01ED78 */,
  0x2465EC04l /* 0x01ED7C */,
  0x6860EC04l /* 0x01ED80 */,
  0xAC60EC04l /* 0x01ED84 */,
  0x6A05C507l /* 0x01ED88 */,
  0xA2813070l /* 0x01ED8C */,
  0x00382398l /* 0x01ED90 */,
  0x460222FFl /* 0x01ED94 */,
  0x060215C8l /* 0x01ED98 */,
  0x24706B05l /* 0x01ED9C */,
  0x602040D0l /* 0x01EDA0 */,
  0xF3EE01B0l /* 0x01EDA4 */,
  0x38706A05l /* 0x01EDA8 */,
  0x6A050130l /* 0x01EDAC */,
  0x01307470l /* 0x01EDB0 */,
  0xEA0422FFl /* 0x01EDB4 */,
  0x24102870l /* 0x01EDB8 */,
  0x280512FBl /* 0x01EDBC */,
  0xEF065871l /* 0x01EDC0 */,
  0x05C0D870l /* 0x01EDC4 */,
  0x22EB0330l /* 0x01EDC8 */,
  0x30B003C0l /* 0x01EDCC */,
  0x68D02B01l /* 0x01EDD0 */,
  0x10EF4030l /* 0x01EDD4 */,
  0x08D0EF00l /* 0x01EDD8 */,
  0x22EB0530l /* 0x01EDDC */,
  0x6C0540D0l /* 0x01EDE0 */,
  0x56074460l /* 0x01EDE4 */,
  0x6E0541D0l /* 0x01EDE8 */,
  0x40D05860l /* 0x01EDEC */,
  0x4C606105l /* 0x01EDF0 */,
  0x50D0A700l /* 0x01EDF4 */,
  0x600012D0l /* 0x01EDF8 */,
  0x0500C0D7l /* 0x01EDFC */,
  0x00D8C507l /* 0x01EE00 */,
  0x1104C0D0l /* 0x01EE04 */,
  0x20D06C05l /* 0x01EE08 */,
  0x60104070l /* 0x01EE0C */,
  0x13042DEBl /* 0x01EE10 */,
  0x6C05C060l /* 0x01EE14 */,
  0x407024D0l /* 0x01EE18 */,
  0x3CEB6010l /* 0x01EE1C */,
  0xC0601204l /* 0x01EE20 */,
  0x54D0E506l /* 0x01EE24 */,
  0x00D0B000l /* 0x01EE28 */,
  0x01404170l /* 0x01EE2C */,
  0x14043CEBl /* 0x01EE30 */,
  0xE5064601l /* 0x01EE34 */,
  0x407014D0l /* 0x01EE38 */,
  0x40606050l /* 0x01EE3C */,
  0xC507C600l /* 0x01EE40 */,
  0x66004601l /* 0x01EE44 */,
  0x38A001D0l /* 0x01EE48 */,
  0x00D06600l /* 0x01EE4C */,
  0x3F8037A0l /* 0x01EE50 */,
  0x2000C600l /* 0x01EE54 */,
  0xF6810CD0l /* 0x01EE58 */,
  0xB68134A0l /* 0x01EE5C */,
  0x768234A0l /* 0x01EE60 */,
  0x3F8034A0l /* 0x01EE64 */,
  0x49DF2000l /* 0x01EE68 */,
  0x28E89B01l /* 0x01EE6C */,
  0xA3076BC0l /* 0x01EE70 */,
  0x40D05860l /* 0x01EE74 */,
  0x4C606105l /* 0x01EE78 */,
  0x6C0540D0l /* 0x01EE7C */,
  0x41D04460l /* 0x01EE80 */,
  0x58606E05l /* 0x01EE84 */,
  0x50D0A700l /* 0x01EE88 */,
  0x600012D0l /* 0x01EE8C */,
  0x0500C0D7l /* 0x01EE90 */,
  0x01D02000l /* 0x01EE94 */,
  0x32EC2B30l /* 0x01EE98 */,
  0x2FD02200l /* 0x01EE9C */,
  0x32E42B30l /* 0x01EEA0 */,
  0x28E0D4F0l /* 0x01EEA4 */,
  0x690501D0l /* 0x01EEA8 */,
  0x40D00860l /* 0x01EEAC */,
  0x58606105l /* 0x01EEB0 */,
  0x3FF89F01l /* 0x01EEB4 */,
  0x3FF89E01l /* 0x01EEB8 */,
  0xA30741D0l /* 0x01EEBC */,
  0xAC054860l /* 0x01EEC0 */,
  0x9C014C70l /* 0x01EEC4 */,
  0x9D0148F8l /* 0x01EEC8 */,
  0xE80448F8l /* 0x01EECC */,
  0x57E010D0l /* 0x01EED0 */,
  0x0C70A205l /* 0x01EED4 */,
  0x58F82310l /* 0x01EED8 */,
  0x3C702507l /* 0x01EEDC */,
  0x58E82110l /* 0x01EEE0 */,
  0x58F86310l /* 0x01EEE4 */,
  0x10D0E804l /* 0x01EEE8 */,
  0xA3108070l /* 0x01EEEC */,
  0x406058E8l /* 0x01EEF0 */,
  0x2870EB04l /* 0x01EEF4 */,
  0x024082D0l /* 0x01EEF8 */,
  0x72F82210l /* 0x01EEFC */,
  0x00D06005l /* 0x01EF00 */,
  0x20100070l /* 0x01EF04 */,
  0xAC0567E8l /* 0x01EF08 */,
  0x23102070l /* 0x01EF0C */,
  0x260572F8l /* 0x01EF10 */,
  0x00783CD0l /* 0x01EF14 */,
  0x00681908l /* 0x01EF18 */,
  0x40D0A900l /* 0x01EF1C */,
  0x600012D0l /* 0x01EF20 */,
  0x0500C0D7l /* 0x01EF24 */,
  0x5060E804l /* 0x01EF28 */,
  0xEF0442D0l /* 0x01EF2C */,
  0xEB046460l /* 0x01EF30 */,
  0x22101070l /* 0x01EF34 */,
  0x23107DE8l /* 0x01EF38 */,
  0x40D08BF8l /* 0x01EF3C */,
  0x7C60E306l /* 0x01EF40 */,
  0x620541D0l /* 0x01EF44 */,
  0xA9F04460l /* 0x01EF48 */,
  0xE705C9F0l /* 0x01EF4C */,
  0x20100070l /* 0x01EF50 */,
  0xBEF085F8l /* 0x01EF54 */,
  0xEF0497E0l /* 0x01EF58 */,
  0x41D03070l /* 0x01EF5C */,
  0x20100140l /* 0x01EF60 */,
  0xEF0497E8l /* 0x01EF64 */,
  0x22103470l /* 0x01EF68 */,
  0xA9F097F8l /* 0x01EF6C */,
  0x40D0C9F0l /* 0x01EF70 */,
  0x18D06105l /* 0x01EF74 */,
  0x61054060l /* 0x01EF78 */,
  0x406010D0l /* 0x01EF7C */,
  0x3CD02605l /* 0x01EF80 */,
  0x19080078l /* 0x01EF84 */,
  0xA9000068l /* 0x01EF88 */,
  0x12D058D0l /* 0x01EF8C */,
  0xC0D76000l /* 0x01EF90 */,
  0x63050500l /* 0x01EF94 */,
  0x41D014D0l /* 0x01EF98 */,
  0x26054060l /* 0x01EF9C */,
  0x807010D0l /* 0x01EFA0 */,
  0x00D0E705l /* 0x01EFA4 */,
  0x2D008060l /* 0x01EFA8 */,
  0x407000D0l /* 0x01EFAC */,
  0xBAE84230l /* 0x01EFB0 */,
  0x20D02D00l /* 0x01EFB4 */,
  0x54D02B00l /* 0x01EFB8 */,
  0xC5070160l /* 0x01EFBC */,
  0x74D0ED04l /* 0x01EFC0 */,
  0xED040170l /* 0x01EFC4 */,
  0x016078D0l /* 0x01EFC8 */,
  0x74D0ED04l /* 0x01EFCC */,
  0x016000D0l /* 0x01EFD0 */,
  0xEA04C507l /* 0x01EFD4 */,
  0x007000D0l /* 0x01EFD8 */,
  0x97F82210l /* 0x01EFDC */,
  0x04D0E306l /* 0x01EFE0 */,
  0x10080078l /* 0x01EFE4 */,
  0xC5070068l /* 0x01EFE8 */,
  0x3684090Cl /* 0x01EFEC */,
  0xF4AA3F80l /* 0x01EFF0 */,
  0xF4AACD0Al /* 0x01EFF4 */,
  0x0000C507l /* 0x01EFF8 */,
  0x10D06D05l /* 0x01EFFC */,
  0xC3C0C070l /* 0x01F000 */,
  0xC06083F0l /* 0x01F004 */,
  0x78D06C05l /* 0x01F008 */,
  0xDD118170l /* 0x01F00C */,
  0x81608720l /* 0x01F010 */,
  0xF0616200l /* 0x01F014 */,
  0x6C706C05l /* 0x01F018 */,
  0x30D8A400l /* 0x01F01C */,
  0x3F8036A8l /* 0x01F020 */,
  0xEA043498l /* 0x01F024 */,
  0x22100070l /* 0x01F028 */,
  0x27007DF8l /* 0x01F02C */,
  0x20101470l /* 0x01F030 */,
  0x6D057DE8l /* 0x01F034 */,
  0x02200870l /* 0x01F038 */,
  0x7DE40130l /* 0x01F03C */,
  0x0C70AC05l /* 0x01F040 */,
  0x2BF82310l /* 0x01F044 */,
  0x7DE81700l /* 0x01F048 */,
  0x7DEC4230l /* 0x01F04C */,
  0x19003AE0l /* 0x01F050 */,
  0x3AE02EE8l /* 0x01F054 */,
  0x7DE81700l /* 0x01F058 */,
  0x7DEC4230l /* 0x01F05C */,
  0x17081904l /* 0x01F060 */,
  0x30D02400l /* 0x01F064 */,
  0x3F8036A0l /* 0x01F068 */,
  0x7DE034A8l /* 0x01F06C */,
  0xE10541D0l /* 0x01F070 */,
  0x17086460l /* 0x01F074 */,
  0x24001908l /* 0x01F078 */,
  0x36A030D0l /* 0x01F07C */,
  0x34A83F80l /* 0x01F080 */,
  0x20702A00l /* 0x01F084 */,
  0x38606E05l /* 0x01F088 */,
  0x0470EA04l /* 0x01F08C */,
  0x60E82110l /* 0x01F090 */,
  0x48D0B1F0l /* 0x01F094 */,
  0x60602A00l /* 0x01F098 */,
  0x520B5107l /* 0x01F09C */,
  0x43904601l /* 0x01F0A0 */,
  0x3F808290l /* 0x01F0A4 */,
  0x2905C600l /* 0x01F0A8 */,
  0x40600CD0l /* 0x01F0AC */,
  0x80603CB0l /* 0x01F0B0 */,
  0x290540D0l /* 0x01F0B4 */,
  0x7DE04860l /* 0x01F0B8 */,
  0x24001304l /* 0x01F0BC */,
  0x36A030D0l /* 0x01F0C0 */,
  0x34A83F80l /* 0x01F0C4 */,
  0x6C0540D0l /* 0x01F0C8 */,
  0x46016C60l /* 0x01F0CC */,
  0x1478E506l /* 0x01F0D0 */,
  0xE5061F04l /* 0x01F0D4 */,
  0xE5061468l /* 0x01F0D8 */,
  0x10042878l /* 0x01F0DC */,
  0x2868E506l /* 0x01F0E0 */,
  0xA400C600l /* 0x01F0E4 */,
  0x36A830D8l /* 0x01F0E8 */,
  0x34983F80l /* 0x01F0EC */,
  0x75E81400l /* 0x01F0F0 */,
  0xA700B1F0l /* 0x01F0F4 */,
  0x12D058D0l /* 0x01F0F8 */,
  0xDAD76000l /* 0x01F0FC */,
  0x68000500l /* 0x01F100 */,
  0x619100D1l /* 0x01F104 */,
  0x85F84441l /* 0x01F108 */,
  0x23912283l /* 0x01F10C */,
  0x02111E11l /* 0x01F110 */,
  0x63912281l /* 0x01F114 */,
  0x44115E11l /* 0x01F118 */,
  0x45860531l /* 0x01F11C */,
  0x4691BFD1l /* 0x01F120 */,
  0x46415511l /* 0x01F124 */,
  0x42117EB1l /* 0x01F128 */,
  0x03110531l /* 0x01F12C */,
  0x8D915FD1l /* 0x01F130 */,
  0x06218541l /* 0x01F134 */,
  0xC331C4C1l /* 0x01F138 */,
  0x2281ACF4l /* 0x01F13C */,
  0xDE10E390l /* 0x01F140 */,
  0x2280C410l /* 0x01F144 */,
  0x9E11A391l /* 0x01F148 */,
  0x83318211l /* 0x01F14C */,
  0xC6218311l /* 0x01F150 */,
  0xE010C4C0l /* 0x01F154 */,
  0xC620B0F4l /* 0x01F158 */,
  0x4601C507l /* 0x01F15C */,
  0x1478E506l /* 0x01F160 */,
  0xE5061D04l /* 0x01F164 */,
  0xE5061468l /* 0x01F168 */,
  0x10043078l /* 0x01F16C */,
  0x3068E506l /* 0x01F170 */,
  0xC507C600l /* 0x01F174 */,
  0x60702005l /* 0x01F178 */,
  0x0AF86110l /* 0x01F17C */,
  0x40D0E000l /* 0x01F180 */,
  0x600012D0l /* 0x01F184 */,
  0x0500C0D7l /* 0x01F188 */,
  0x260700D4l /* 0x01F18C */,
  0x407030D0l /* 0x01F190 */,
  0x60100064l /* 0x01F194 */,
  0x280718F8l /* 0x01F198 */,
  0x20102070l /* 0x01F19C */,
  0x00D01DE8l /* 0x01F1A0 */,
  0x20602807l /* 0x01F1A4 */,
  0xE70501D4l /* 0x01F1A8 */,
  0x20110071l /* 0x01F1AC */,
  0xA20519F8l /* 0x01F1B0 */,
  0xA2054074l /* 0x01F1B4 */,
  0xEB048474l /* 0x01F1B8 */,
  0x60106870l /* 0x01F1BC */,
  0x2A002BE8l /* 0x01F1C0 */,
  0x9130BCD0l /* 0x01F1C4 */,
  0x2B002BECl /* 0x01F1C8 */,
  0xA20550D4l /* 0x01F1CC */,
  0xA3138873l /* 0x01F1D0 */,
  0xA41332E8l /* 0x01F1D4 */,
  0x82D332E8l /* 0x01F1D8 */,
  0xC0732200l /* 0x01F1DC */,
  0x38F8E213l /* 0x01F1E0 */,
  0x83D3C1D3l /* 0x01F1E4 */,
  0x3BFCE213l /* 0x01F1E8 */,
  0xFEB3C0D3l /* 0x01F1EC */,
  0xE50500D8l /* 0x01F1F0 */,
  0x00D0ACD0l /* 0x01F1F4 */,
  0x240000D3l /* 0x01F1F8 */,
  0x52306CD0l /* 0x01F1FC */,
  0x01D34EE4l /* 0x01F200 */,
  0x4EE8D103l /* 0x01F204 */,
  0x70D02300l /* 0x01F208 */,
  0x54F85230l /* 0x01F20C */,
  0x54E002D3l /* 0x01F210 */,
  0x60D02400l /* 0x01F214 */,
  0x54F85230l /* 0x01F218 */,
  0x01D003D3l /* 0x01F21C */,
  0x20130260l /* 0x01F220 */,
  0x27055FF8l /* 0x01F224 */,
  0x60104870l /* 0x01F228 */,
  0x04D35FE8l /* 0x01F22C */,
  0x5FEC6010l /* 0x01F230 */,
  0xEB0405D3l /* 0x01F234 */,
  0x60186878l /* 0x01F238 */,
  0x4CC86BE8l /* 0x01F23C */,
  0x631800D3l /* 0x01F240 */,
  0x01D36BECl /* 0x01F244 */,
  0x6BEC6018l /* 0x01F248 */,
  0x40D200D3l /* 0x01F24C */,
  0x4AD02A00l /* 0x01F250 */,
  0x72EC5130l /* 0x01F254 */,
  0x7AE040D1l /* 0x01F258 */,
  0x6CD02400l /* 0x01F25C */,
  0x78E45230l /* 0x01F260 */,
  0x7AE042D1l /* 0x01F264 */,
  0x7AE041D1l /* 0x01F268 */,
  0x80D085C1l /* 0x01F26C */,
  0x87F8E313l /* 0x01F270 */,
  0x87F8A213l /* 0x01F274 */,
  0x6878E700l /* 0x01F278 */,
  0x86E89100l /* 0x01F27C */,
  0x87E083D3l /* 0x01F280 */,
  0x260781D0l /* 0x01F284 */,
  0x2507A460l /* 0x01F288 */,
  0x447028D1l /* 0x01F28C */,
  0xAF058463l /* 0x01F290 */,
  0x047038D1l /* 0x01F294 */,
  0x4E30C463l /* 0x01F298 */,
  0x0F3096F8l /* 0x01F29C */,
  0x96E098E8l /* 0x01F2A0 */,
  0x11041004l /* 0x01F2A4 */,
  0x6CD02400l /* 0x01F2A8 */,
  0xAFEC5230l /* 0x01F2AC */,
  0x4F314EC1l /* 0x01F2B0 */,
  0x6211AFE8l /* 0x01F2B4 */,
  0x6111A9E8l /* 0x01F2B8 */,
  0xE213AFF8l /* 0x01F2BC */,
  0xC3D0A7E8l /* 0x01F2C0 */,
  0xC1D0AAE0l /* 0x01F2C4 */,
  0xC2D0AAE0l /* 0x01F2C8 */,
  0x411146C1l /* 0x01F2CC */,
  0x43214621l /* 0x01F2D0 */,
  0x4AD1BAE0l /* 0x01F2D4 */,
  0xB9E82113l /* 0x01F2D8 */,
  0x22134BD1l /* 0x01F2DC */,
  0x4ED1B9E8l /* 0x01F2E0 */,
  0xB9E82313l /* 0x01F2E4 */,
  0x45C240D1l /* 0x01F2E8 */,
  0x6C782200l /* 0x01F2EC */,
  0xEDF89900l /* 0x01F2F0 */,
  0x68706205l /* 0x01F2F4 */,
  0xF0F82413l /* 0x01F2F8 */,
  0x00706505l /* 0x01F2FC */,
  0xC8E82014l /* 0x01F300 */,
  0x38706405l /* 0x01F304 */,
  0xCFE82010l /* 0x01F308 */,
  0x007034B0l /* 0x01F30C */,
  0x20101C10l /* 0x01F310 */,
  0x4CD1EDF8l /* 0x01F314 */,
  0xD6F86010l /* 0x01F318 */,
  0x6472ED04l /* 0x01F31C */,
  0xD8E86312l /* 0x01F320 */,
  0xD8E055D1l /* 0x01F324 */,
  0x64606205l /* 0x01F328 */,
  0x220045C2l /* 0x01F32C */,
  0x62104470l /* 0x01F330 */,
  0x4EC0ECF8l /* 0x01F334 */,
  0xECE84F30l /* 0x01F338 */,
  0x62054FD1l /* 0x01F33C */,
  0x60106470l /* 0x01F340 */,
  0xED04EBF8l /* 0x01F344 */,
  0x63126472l /* 0x01F348 */,
  0x56D1FCE8l /* 0x01F34C */,
  0x6205FCE0l /* 0x01F350 */,
  0xF2E06460l /* 0x01F354 */,
  0x64606205l /* 0x01F358 */,
  0xFCF82513l /* 0x01F35C */,
  0x53D153D2l /* 0x01F360 */,
  0x38D02900l /* 0x01F364 */,
  0xFCEC1130l /* 0x01F368 */,
  0x54D154D2l /* 0x01F36C */,
  0x6478ED04l /* 0x01F370 */,
  0x04F96318l /* 0x01F374 */,
  0x64786205l /* 0x01F378 */,
  0x0DE96018l /* 0x01F37C */,
  0x09F96111l /* 0x01F380 */,
  0x52D14DD2l /* 0x01F384 */,
  0x60110DE1l /* 0x01F388 */,
  0x4DD20DF9l /* 0x01F38C */,
  0x20054DD1l /* 0x01F390 */,
  0x61106070l /* 0x01F394 */,
  0x210518F9l /* 0x01F398 */,
  0x40711C70l /* 0x01F39C */,
  0x00D345C2l /* 0x01F3A0 */,
  0x58612807l /* 0x01F3A4 */,
  0x1CD12507l /* 0x01F3A8 */,
  0x44614470l /* 0x01F3AC */,
  0x24D12507l /* 0x01F3B0 */,
  0x84640470l /* 0x01F3B4 */,
  0x32F94530l /* 0x01F3B8 */,
  0x28D12807l /* 0x01F3BC */,
  0x44624470l /* 0x01F3C0 */,
  0x32F94930l /* 0x01F3C4 */,
  0x32F91230l /* 0x01F3C8 */,
  0x1C702300l /* 0x01F3CC */,
  0x2CD12807l /* 0x01F3D0 */,
  0x04604470l /* 0x01F3D4 */,
  0x59E90130l /* 0x01F3D8 */,
  0xC5C01104l /* 0x01F3DC */,
  0x84F140D1l /* 0x01F3E0 */,
  0x08D12907l /* 0x01F3E4 */,
  0x60D02907l /* 0x01F3E8 */,
  0x047086D0l /* 0x01F3EC */,
  0x7CB00160l /* 0x01F3F0 */,
  0x81B03CB1l /* 0x01F3F4 */,
  0x49C13BF9l /* 0x01F3F8 */,
  0x280784F1l /* 0x01F3FC */,
  0x290770D0l /* 0x01F400 */,
  0x86D008D1l /* 0x01F404 */,
  0x01600470l /* 0x01F408 */,
  0x3CB17CB0l /* 0x01F40C */,
  0x48F981B0l /* 0x01F410 */,
  0x230043C1l /* 0x01F414 */,
  0x60105C70l /* 0x01F418 */,
  0x601158E9l /* 0x01F41C */,
  0x631158E9l /* 0x01F420 */,
  0x7DB158EDl /* 0x01F424 */,
  0x270084F1l /* 0x01F428 */,
  0x12301FD0l /* 0x01F42C */,
  0x23006AE5l /* 0x01F430 */,
  0x123030D0l /* 0x01F434 */,
  0xE20564E5l /* 0x01F438 */,
  0x6DE12860l /* 0x01F43C */,
  0x20D02400l /* 0x01F440 */,
  0xE2051230l /* 0x01F444 */,
  0x6DE12860l /* 0x01F448 */,
  0xE20500D0l /* 0x01F44C */,
  0xAD052860l /* 0x01F450 */,
  0x2100B8D0l /* 0x01F454 */,
  0x4601DCD0l /* 0x01F458 */,
  0x3F803A83l /* 0x01F45C */,
  0x3F803B80l /* 0x01F460 */,
  0x3F807A83l /* 0x01F464 */,
  0xC26ECA00l /* 0x01F468 */,
  0xC6000600l /* 0x01F46C */,
  0x1868AF05l /* 0x01F470 */,
  0x48D0AE00l /* 0x01F474 */,
  0x600012D0l /* 0x01F478 */,
  0x0500C0D7l /* 0x01F47C */,
  0x7CD06007l /* 0x01F480 */,
  0x8AE9D103l /* 0x01F484 */,
  0x6CD06207l /* 0x01F488 */,
  0x45204211l /* 0x01F48C */,
  0xE1058170l /* 0x01F490 */,
  0x816078D0l /* 0x01F494 */,
  0x64074211l /* 0x01F498 */,
  0x052218D2l /* 0x01F49C */,
  0x2300C871l /* 0x01F4A0 */,
  0xC0413FD0l /* 0x01F4A4 */,
  0x90D02907l /* 0x01F4A8 */,
  0xAE00C261l /* 0x01F4AC */,
  0x007130D0l /* 0x01F4B0 */,
  0x58104870l /* 0x01F4B4 */,
  0x29074420l /* 0x01F4B8 */,
  0x426088D0l /* 0x01F4BC */,
  0x48703CB2l /* 0x01F4C0 */,
  0x01215810l /* 0x01F4C4 */,
  0x0261BCB0l /* 0x01F4C8 */,
  0xAE0000D1l /* 0x01F4CC */,
  0x007038D0l /* 0x01F4D0 */,
  0x3CB20021l /* 0x01F4D4 */,
  0x2300C871l /* 0x01F4D8 */,
  0xC0413FD0l /* 0x01F4DC */,
  0x9CD02907l /* 0x01F4E0 */,
  0x4870C261l /* 0x01F4E4 */,
  0x01215810l /* 0x01F4E8 */,
  0x94D02907l /* 0x01F4EC */,
  0x01310261l /* 0x01F4F0 */,
  0x48703CB2l /* 0x01F4F4 */,
  0x01215810l /* 0x01F4F8 */,
  0x0261BCB0l /* 0x01F4FC */,
  0x0000C507l /* 0x01F500 */,
  0xAD054601l /* 0x01F504 */,
  0x2100B8D0l /* 0x01F508 */,
  0x3A83DCD0l /* 0x01F50C */,
  0x3B803F80l /* 0x01F510 */,
  0x7A833F80l /* 0x01F514 */,
  0xCA003F80l /* 0x01F518 */,
  0x0600C27El /* 0x01F51C */,
  0xAF05C600l /* 0x01F520 */,
  0x25071878l /* 0x01F524 */,
  0x80D078D0l /* 0x01F528 */,
  0x2B008160l /* 0x01F52C */,
  0x913080D0l /* 0x01F530 */,
  0x280021E8l /* 0x01F534 */,
  0x913090D0l /* 0x01F538 */,
  0x250021E8l /* 0x01F53C */,
  0x9130A0D0l /* 0x01F540 */,
  0x81D023F8l /* 0x01F544 */,
  0x29008160l /* 0x01F548 */,
  0x9130B8D0l /* 0x01F54C */,
  0x80D02BECl /* 0x01F550 */,
  0xD0D02B00l /* 0x01F554 */,
  0x28003EE0l /* 0x01F558 */,
  0x913080D0l /* 0x01F55C */,
  0x81D033ECl /* 0x01F560 */,
  0xE0D02800l /* 0x01F564 */,
  0x26003EE0l /* 0x01F568 */,
  0x9130A0D0l /* 0x01F56C */,
  0x82D03BECl /* 0x01F570 */,
  0xE0D02700l /* 0x01F574 */,
  0x83D03EE0l /* 0x01F578 */,
  0xE0D02500l /* 0x01F57C */,
  0x02C202C1l /* 0x01F580 */,
  0x42D080D1l /* 0x01F584 */,
  0x260742D1l /* 0x01F588 */,
  0xA010A470l /* 0x01F58C */,
  0x4FC049E8l /* 0x01F590 */,
  0x42B04EC1l /* 0x01F594 */,
  0x81C04210l /* 0x01F598 */,
  0x81208110l /* 0x01F59C */,
  0x421142B1l /* 0x01F5A0 */,
  0x84208520l /* 0x01F5A4 */,
  0x2C078210l /* 0x01F5A8 */,
  0x230060D0l /* 0x01F5AC */,
  0x20101C70l /* 0x01F5B0 */,
  0x2E075BE8l /* 0x01F5B4 */,
  0x422040D0l /* 0x01F5B8 */,
  0x2A008170l /* 0x01F5BC */,
  0x113000D0l /* 0x01F5C0 */,
  0x8BD066F8l /* 0x01F5C4 */,
  0x7AE8E213l /* 0x01F5C8 */,
  0x7AE091D0l /* 0x01F5CC */,
  0x00D02500l /* 0x01F5D0 */,
  0x72F81130l /* 0x01F5D4 */,
  0x250701D0l /* 0x01F5D8 */,
  0x86D03860l /* 0x01F5DC */,
  0x7AF8E213l /* 0x01F5E0 */,
  0x7AE08AD0l /* 0x01F5E4 */,
  0x00D02600l /* 0x01F5E8 */,
  0x7AF81130l /* 0x01F5EC */,
  0xE2138CD0l /* 0x01F5F0 */,
  0x84D07AE8l /* 0x01F5F4 */,
  0x60702005l /* 0x01F5F8 */,
  0x82E86110l /* 0x01F5FC */,
  0x200500D0l /* 0x01F600 */,
  0xAAE03060l /* 0x01F604 */,
  0x18702105l /* 0x01F608 */,
  0xC1D08070l /* 0x01F60C */,
  0xF0602005l /* 0x01F610 */,
  0x10D12807l /* 0x01F614 */,
  0x84604470l /* 0x01F618 */,
  0xA8F84230l /* 0x01F61C */,
  0x14D12807l /* 0x01F620 */,
  0x28074470l /* 0x01F624 */,
  0x04601870l /* 0x01F628 */,
  0xA8F84030l /* 0x01F62C */,
  0x0C702105l /* 0x01F630 */,
  0x4C702807l /* 0x01F634 */,
  0xA8F84030l /* 0x01F638 */,
  0x04702105l /* 0x01F63C */,
  0x44702807l /* 0x01F640 */,
  0xA8F84030l /* 0x01F644 */,
  0x08702105l /* 0x01F648 */,
  0x48702807l /* 0x01F64C */,
  0xAAE84030l /* 0x01F650 */,
  0x10041104l /* 0x01F654 */,
  0xA211C2C4l /* 0x01F658 */,
  0x2507BCF8l /* 0x01F65C */,
  0x447018D1l /* 0x01F660 */,
  0x42308460l /* 0x01F664 */,
  0x2114BBF8l /* 0x01F668 */,
  0x2507BCE8l /* 0x01F66C */,
  0x047020D1l /* 0x01F670 */,
  0x11304464l /* 0x01F674 */,
  0x1004BCE8l /* 0x01F678 */,
  0x2F078210l /* 0x01F67C */,
  0x022120D1l /* 0x01F680 */,
  0x23004470l /* 0x01F684 */,
  0x8140BFD0l /* 0x01F688 */,
  0xEF0F01C1l /* 0x01F68C */,
  0x18117FD0l /* 0x01F690 */,
  0xAE000141l /* 0x01F694 */,
  0xE91410D0l /* 0x01F698 */,
  0xAE00D7E4l /* 0x01F69C */,
  0xED1418D0l /* 0x01F6A0 */,
  0xAE00D7E4l /* 0x01F6A4 */,
  0xF31420D0l /* 0x01F6A8 */,
  0xAE00D7E4l /* 0x01F6AC */,
  0x007028D0l /* 0x01F6B0 */,
  0x2A070021l /* 0x01F6B4 */,
  0x4601D0D0l /* 0x01F6B8 */,
  0x3FB1FEB0l /* 0x01F6BC */,
  0x3C900470l /* 0x01F6C0 */,
  0x3F807D91l /* 0x01F6C4 */,
  0x7DA13CA0l /* 0x01F6C8 */,
  0x03603F80l /* 0x01F6CC */,
  0xC6000600l /* 0x01F6D0 */,
  0x3DB1FEB0l /* 0x01F6D4 */,
  0x03600470l /* 0x01F6D8 */,
  0x50702A07l /* 0x01F6DC */,
  0x80D0EC0Fl /* 0x01F6E0 */,
  0x98108140l /* 0x01F6E4 */,
  0x88B0C2C0l /* 0x01F6E8 */,
  0x00D03001l /* 0x01F6EC */,
  0x2A078050l /* 0x01F6F0 */,
  0xC4B0AC60l /* 0x01F6F4 */,
  0x2A073CB1l /* 0x01F6F8 */,
  0x016158D0l /* 0x01F6FC */,
  0x7CB00321l /* 0x01F700 */,
  0x03210161l /* 0x01F704 */,
  0x01617CB0l /* 0x01F708 */,
  0x7CB00321l /* 0x01F70C */,
  0x2A070161l /* 0x01F710 */,
  0x3FB110D1l /* 0x01F714 */,
  0x84704601l /* 0x01F718 */,
  0x7D900600l /* 0x01F71C */,
  0xC6003F80l /* 0x01F720 */,
  0x813091C0l /* 0x01F724 */,
  0x812015F5l /* 0x01F728 */,
  0x41C342C0l /* 0x01F72C */,
  0x9E108DC0l /* 0x01F730 */,
  0x821081B0l /* 0x01F734 */,
  0x00D02008l /* 0x01F738 */,
  0x2A070220l /* 0x01F73C */,
  0x046028D1l /* 0x01F740 */,
  0x2A07BFB1l /* 0x01F744 */,
  0x2B0714D1l /* 0x01F748 */,
  0x20004CD0l /* 0x01F74C */,
  0xA11187D0l /* 0x01F750 */,
  0x2B072FE9l /* 0x01F754 */,
  0xA21168D0l /* 0x01F758 */,
  0x2A072FE9l /* 0x01F75C */,
  0x047070D0l /* 0x01F760 */,
  0x7CB00160l /* 0x01F764 */,
  0x81B03CB1l /* 0x01F768 */,
  0x08C12FF9l /* 0x01F76C */,
  0x3CE9A311l /* 0x01F770 */,
  0x47E8A211l /* 0x01F774 */,
  0x7AE080D0l /* 0x01F778 */,
  0xB9D22100l /* 0x01F77C */,
  0x42E9D103l /* 0x01F780 */,
  0x83D22200l /* 0x01F784 */,
  0xD0D22B00l /* 0x01F788 */,
  0x64702607l /* 0x01F78C */,
  0x59F96110l /* 0x01F790 */,
  0x93D02300l /* 0x01F794 */,
  0x5CD02800l /* 0x01F798 */,
  0x50E9D103l /* 0x01F79C */,
  0x9DD02300l /* 0x01F7A0 */,
  0x38712507l /* 0x01F7A4 */,
  0x56E92011l /* 0x01F7A8 */,
  0xBAB04CB0l /* 0x01F7AC */,
  0xC1C282C2l /* 0x01F7B0 */,
  0x25076EE1l /* 0x01F7B4 */,
  0x60107870l /* 0x01F7B8 */,
  0x48D06EE9l /* 0x01F7BC */,
  0x2B008122l /* 0x01F7C0 */,
  0x2B00C0D2l /* 0x01F7C4 */,
  0x4D3050D0l /* 0x01F7C8 */,
  0x2B0068F9l /* 0x01F7CC */,
  0x6EE140D3l /* 0x01F7D0 */,
  0x68D02500l /* 0x01F7D4 */,
  0x6EF94D30l /* 0x01F7D8 */,
  0x60D32500l /* 0x01F7DC */,
  0x1C702300l /* 0x01F7E0 */,
  0x96E92010l /* 0x01F7E4 */,
  0xC0D22A00l /* 0x01F7E8 */,
  0xA1D22200l /* 0x01F7EC */,
  0x7AE9D103l /* 0x01F7F0 */,
  0xABD22200l /* 0x01F7F4 */,
  0x78702507l /* 0x01F7F8 */,
  0x82E96010l /* 0x01F7FC */,
  0x812248D0l /* 0x01F800 */,
  0xF2D22900l /* 0x01F804 */,
  0x64702607l /* 0x01F808 */,
  0x96F96110l /* 0x01F80C */,
  0xE0D22700l /* 0x01F810 */,
  0xB1D22300l /* 0x01F814 */,
  0x8EE9D103l /* 0x01F818 */,
  0xBBD22300l /* 0x01F81C */,
  0x78702507l /* 0x01F820 */,
  0x96E96010l /* 0x01F824 */,
  0x812246D0l /* 0x01F828 */,
  0xD6D22700l /* 0x01F82C */,
  0xB8622707l /* 0x01F830 */,
  0x60702005l /* 0x01F834 */,
  0xA4F96110l /* 0x01F838 */,
  0x6C702005l /* 0x01F83C */,
  0xA4F96410l /* 0x01F840 */,
  0xFAD22A00l /* 0x01F844 */,
  0x81D22200l /* 0x01F848 */,
  0x4BC08AC0l /* 0x01F84C */,
  0x41B08210l /* 0x01F850 */,
  0x42204C10l /* 0x01F854 */,
  0x84D02507l /* 0x01F858 */,
  0x51C04260l /* 0x01F85C */,
  0xB9D12100l /* 0x01F860 */,
  0xB4E9D103l /* 0x01F864 */,
  0x83D12200l /* 0x01F868 */,
  0x90D02B00l /* 0x01F86C */,
  0x9F108130l /* 0x01F870 */,
  0x82108620l /* 0x01F874 */,
  0x4C1041B0l /* 0x01F878 */,
  0x25074220l /* 0x01F87C */,
  0x426088D0l /* 0x01F880 */,
  0xC4E92014l /* 0x01F884 */,
  0xE7E91000l /* 0x01F888 */,
  0x18D1AD05l /* 0x01F88C */,
  0x48104470l /* 0x01F890 */,
  0x80D05810l /* 0x01F894 */,
  0x84608130l /* 0x01F898 */,
  0x20D1AD05l /* 0x01F89C */,
  0x60104470l /* 0x01F8A0 */,
  0x4810E1E9l /* 0x01F8A4 */,
  0x80D05810l /* 0x01F8A8 */,
  0x84608130l /* 0x01F8AC */,
  0x28D1AD05l /* 0x01F8B0 */,
  0x60104470l /* 0x01F8B4 */,
  0x4810E4E9l /* 0x01F8B8 */,
  0x80D05810l /* 0x01F8BC */,
  0x84608130l /* 0x01F8C0 */,
  0xAD05E7E1l /* 0x01F8C4 */,
  0x846020D1l /* 0x01F8C8 */,
  0x28D1AD05l /* 0x01F8CC */,
  0x4DC08460l /* 0x01F8D0 */,
  0x80702200l /* 0x01F8D4 */,
  0xF0E5A110l /* 0x01F8D8 */,
  0x250780D0l /* 0x01F8DC */,
  0xF3E1B060l /* 0x01F8E0 */,
  0x813091C0l /* 0x01F8E4 */,
  0x25078110l /* 0x01F8E8 */,
  0x84602CD1l /* 0x01F8EC */,
  0x18D1AD05l /* 0x01F8F0 */,
  0x5E114471l /* 0x01F8F4 */,
  0x20D1AD05l /* 0x01F8F8 */,
  0x5E104470l /* 0x01F8FC */,
  0x41214A10l /* 0x01F900 */,
  0x28D1AD05l /* 0x01F904 */,
  0xDE11C471l /* 0x01F908 */,
  0xD010C5C0l /* 0x01F90C */,
  0xC321C411l /* 0x01F910 */,
  0x7FD0EF0Fl /* 0x01F914 */,
  0xC7C04141l /* 0x01F918 */,
  0x00D06505l /* 0x01F91C */,
  0x0CD12605l /* 0x01F920 */,
  0x16EA2014l /* 0x01F924 */,
  0x04D1E705l /* 0x01F928 */,
  0x38D06405l /* 0x01F92C */,
  0x20100070l /* 0x01F930 */,
  0x34B01CEAl /* 0x01F934 */,
  0x1C100070l /* 0x01F938 */,
  0x6C782200l /* 0x01F93C */,
  0x21EA9900l /* 0x01F940 */,
  0xE10501D0l /* 0x01F944 */,
  0x04712C60l /* 0x01F948 */,
  0x40D5E205l /* 0x01F94C */,
  0xC4D5E205l /* 0x01F950 */,
  0xB4D12607l /* 0x01F954 */,
  0x24D22707l /* 0x01F958 */,
  0x40D02D00l /* 0x01F95C */,
  0x84308170l /* 0x01F960 */,
  0xB4B144EAl /* 0x01F964 */,
  0xE2053CB2l /* 0x01F968 */,
  0xE20548D5l /* 0x01F96C */,
  0x2D00CCD5l /* 0x01F970 */,
  0x817060D0l /* 0x01F974 */,
  0x44EA8430l /* 0x01F978 */,
  0x3CB2B4B1l /* 0x01F97C */,
  0x50D5E205l /* 0x01F980 */,
  0xD4D5E205l /* 0x01F984 */,
  0x40D02E00l /* 0x01F988 */,
  0x04702507l /* 0x01F98C */,
  0x78B01760l /* 0x01F990 */,
  0x70B081C0l /* 0x01F994 */,
  0x66FA2014l /* 0x01F998 */,
  0xAD054601l /* 0x01F99C */,
  0x1E101870l /* 0x01F9A0 */,
  0xAD050660l /* 0x01F9A4 */,
  0x1E102070l /* 0x01F9A8 */,
  0x0660BCB1l /* 0x01F9AC */,
  0x2870AD05l /* 0x01F9B0 */,
  0xBCB11E10l /* 0x01F9B4 */,
  0x27070660l /* 0x01F9B8 */,
  0x047030D1l /* 0x01F9BC */,
  0x65EA2010l /* 0x01F9C0 */,
  0x27070860l /* 0x01F9C4 */,
  0x00D03460l /* 0x01F9C8 */,
  0xC6000460l /* 0x01F9CC */,
  0x06004601l /* 0x01F9D0 */,
  0x7CA1BEB0l /* 0x01F9D4 */,
  0x3F80FDA0l /* 0x01F9D8 */,
  0x06004261l /* 0x01F9DC */,
  0xC170C600l /* 0x01F9E0 */,
  0xC210DE10l /* 0x01F9E4 */,
  0x24D12407l /* 0x01F9E8 */,
  0x20008470l /* 0x01F9EC */,
  0x844003D1l /* 0x01F9F0 */,
  0xE050C250l /* 0x01F9F4 */,
  0xC1604601l /* 0x01F9F8 */,
  0x64D02407l /* 0x01F9FC */,
  0x834083D0l /* 0x01FA00 */,
  0xE1058160l /* 0x01FA04 */,
  0x15602C70l /* 0x01FA08 */,
  0x80D0C600l /* 0x01FA0C */,
  0x6CD02400l /* 0x01FA10 */,
  0x8BE65230l /* 0x01FA14 */,
  0x250781D0l /* 0x01FA18 */,
  0x80603CD0l /* 0x01FA1C */,
  0x220000D5l /* 0x01FA20 */,
  0x20100070l /* 0x01FA24 */,
  0x23009CFAl /* 0x01FA28 */,
  0x20100870l /* 0x01FA2C */,
  0xA20599FAl /* 0x01FA30 */,
  0x23100870l /* 0x01FA34 */,
  0x9DE29CFAl /* 0x01FA38 */,
  0x280701D5l /* 0x01FA3C */,
  0x20001C65l /* 0x01FA40 */,
  0x201012D0l /* 0x01FA44 */,
  0xF0C771C0l /* 0x01FA48 */,
  0x3F800600l /* 0x01FA4C */,
  0x00000500l /* 0x01FA50 */,
  0x3879ED04l /* 0x01FA54 */,
  0xDFEB1002l /* 0x01FA58 */,
  0xCC70EE04l /* 0x01FA5C */,
  0x581043C0l /* 0x01FA60 */,
  0xDBEF6010l /* 0x01FA64 */,
  0x7C71ED04l /* 0x01FA68 */,
  0x4870EE04l /* 0x01FA6C */,
  0xEE04C120l /* 0x01FA70 */,
  0xEE048470l /* 0x01FA74 */,
  0x45C00071l /* 0x01FA78 */,
  0xCAFB1102l /* 0x01FA7C */,
  0x44300221l /* 0x01FA80 */,
  0xD4E3CDFFl /* 0x01FA84 */,
  0x44300231l /* 0x01FA88 */,
  0x05C1D4E7l /* 0x01FA8C */,
  0xED0440D0l /* 0x01FA90 */,
  0x41D07860l /* 0x01FA94 */,
  0x7460EE04l /* 0x01FA98 */,
  0x0061EE04l /* 0x01FA9C */,
  0xA4071811l /* 0x01FAA0 */,
  0xE0100C61l /* 0x01FAA4 */,
  0x2400DFEBl /* 0x01FAA8 */,
  0xEE04C030l /* 0x01FAAC */,
  0x6A00CC60l /* 0x01FAB0 */,
  0xD3E150D0l /* 0x01FAB4 */,
  0x64716F05l /* 0x01FAB8 */,
  0x2470E105l /* 0x01FABC */,
  0xDFEB2010l /* 0x01FAC0 */,
  0x40702705l /* 0x01FAC4 */,
  0xBFFB6010l /* 0x01FAC8 */,
  0x64702A00l /* 0x01FACC */,
  0x74302000l /* 0x01FAD0 */,
  0x6F05DFEBl /* 0x01FAD4 */,
  0x60105470l /* 0x01FAD8 */,
  0x6A05DFEBl /* 0x01FADC */,
  0x6A057070l /* 0x01FAE0 */,
  0x01302C70l /* 0x01FAE4 */,
  0x01D0DFEFl /* 0x01FAE8 */,
  0x18606F05l /* 0x01FAEC */,
  0x6F057FB1l /* 0x01FAF0 */,
  0x05302870l /* 0x01FAF4 */,
  0xE506E0EFl /* 0x01FAF8 */,
  0x10062479l /* 0x01FAFC */,
  0x2469E506l /* 0x01FB00 */,
  0x1479E506l /* 0x01FB04 */,
  0xE5061706l /* 0x01FB08 */,
  0x00D01469l /* 0x01FB0C */,
  0x620001B0l /* 0x01FB10 */,
  0x40D12C60l /* 0x01FB14 */,
  0x64616F05l /* 0x01FB18 */,
  0xCC70A407l /* 0x01FB1C */,
  0x5C702200l /* 0x01FB20 */,
  0x5D101FD0l /* 0x01FB24 */,
  0x581081C0l /* 0x01FB28 */,
  0x404001C1l /* 0x01FB2C */,
  0x19118040l /* 0x01FB30 */,
  0x02210511l /* 0x01FB34 */,
  0x01210511l /* 0x01FB38 */,
  0x03210511l /* 0x01FB3C */,
  0x3FB10111l /* 0x01FB40 */,
  0x10A028D0l /* 0x01FB44 */,
  0x6C0015A1l /* 0x01FB48 */,
  0xD3E148D0l /* 0x01FB4C */,
  0x508F930Bl /* 0x01FB50 */,
  0x1580158Cl /* 0x01FB54 */,
  0xD5809080l /* 0x01FB58 */,
  0x24D0E605l /* 0x01FB5C */,
  0xE0051699l /* 0x01FB60 */,
  0x3F802069l /* 0x01FB64 */,
  0xBFD06F00l /* 0x01FB68 */,
  0x10020249l /* 0x01FB6C */,
  0x3CB0C2EBl /* 0x01FB70 */,
  0x24C6100Al /* 0x01FB74 */,
  0x01364070l /* 0x01FB78 */,
  0x38B01F16l /* 0x01FB7C */,
  0xA4238073l /* 0x01FB80 */,
  0x00D5F800l /* 0x01FB84 */,
  0x260710A0l /* 0x01FB88 */,
  0x220028D0l /* 0x01FB8C */,
  0xC070A0D0l /* 0x01FB90 */,
  0xDBEBE010l /* 0x01FB94 */,
  0x006900D9l /* 0x01FB98 */,
  0x3CB0C260l /* 0x01FB9C */,
  0xBCB0C070l /* 0x01FBA0 */,
  0xC270C260l /* 0x01FBA4 */,
  0xDFEBE010l /* 0x01FBA8 */,
  0x2B00C1D0l /* 0x01FBAC */,
  0xC06020D0l /* 0x01FBB0 */,
  0x169041D0l /* 0x01FBB4 */,
  0xEBFB4040l /* 0x01FBB8 */,
  0x6E0780D3l /* 0x01FBBC */,
  0xD50B08D0l /* 0x01FBC0 */,
  0x6F07EEE3l /* 0x01FBC4 */,
  0xD50718D0l /* 0x01FBC8 */,
  0xD07300C4l /* 0x01FBCC */,
  0x2200108Fl /* 0x01FBD0 */,
  0x15A000D0l /* 0x01FBD4 */,
  0x60D06700l /* 0x01FBD8 */,
  0x0000D3E1l /* 0x01FBDC */,
  0x54D02200l /* 0x01FBE0 */,
  0x60104170l /* 0x01FBE4 */,
  0xE605BCEBl /* 0x01FBE8 */,
  0x007024D0l /* 0x01FBEC */,
  0x3DB01F10l /* 0x01FBF0 */,
  0x01364030l /* 0x01FBF4 */,
  0x28D0ED04l /* 0x01FBF8 */,
  0x60104070l /* 0x01FBFC */,
  0x40D0DFEBl /* 0x01FC00 */,
  0xED044060l /* 0x01FC04 */,
  0xED04A4D0l /* 0x01FC08 */,
  0x407020D0l /* 0x01FC0C */,
  0xCCEB6410l /* 0x01FC10 */,
  0xF0E34260l /* 0x01FC14 */,
  0x00D0EA04l /* 0x01FC18 */,
  0x20100070l /* 0x01FC1C */,
  0xF3F3F0FBl /* 0x01FC20 */,
  0xD8EB6010l /* 0x01FC24 */,
  0xDCEB6110l /* 0x01FC28 */,
  0xDAEB6210l /* 0x01FC2C */,
  0xDDE343D0l /* 0x01FC30 */,
  0xDDE342D0l /* 0x01FC34 */,
  0x426041D0l /* 0x01FC38 */,
  0xE705F0E3l /* 0x01FC3C */,
  0x007000D0l /* 0x01FC40 */,
  0xF0EB2010l /* 0x01FC44 */,
  0x00D06005l /* 0x01FC48 */,
  0x21100070l /* 0x01FC4C */,
  0xF3F3ECFBl /* 0x01FC50 */,
  0xF0FB6310l /* 0x01FC54 */,
  0xED0441D0l /* 0x01FC58 */,
  0x406028D0l /* 0x01FC5C */,
  0x68D06700l /* 0x01FC60 */,
  0x2B00D3E1l /* 0x01FC64 */,
  0x007010D0l /* 0x01FC68 */,
  0x242018D9l /* 0x01FC6C */,
  0x64C00079l /* 0x01FC70 */,
  0x03D05E10l /* 0x01FC74 */,
  0xC5074040l /* 0x01FC78 */,
  0x38D0E605l /* 0x01FC7C */,
  0x06008070l /* 0x01FC80 */,
  0xF2EBD403l /* 0x01FC84 */,
  0x3CB0D40Bl /* 0x01FC88 */,
  0x3CB08070l /* 0x01FC8C */,
  0x6205C0D2l /* 0x01FC90 */,
  0xC070EC62l /* 0x01FC94 */,
  0xC4FBE010l /* 0x01FC98 */,
  0x50D02B00l /* 0x01FC9C */,
  0xD0E3C172l /* 0x01FCA0 */,
  0xC0629407l /* 0x01FCA4 */,
  0x40703CB0l /* 0x01FCA8 */,
  0x64606505l /* 0x01FCAC */,
  0x2B00C060l /* 0x01FCB0 */,
  0x00D354D0l /* 0x01FCB4 */,
  0x34632507l /* 0x01FCB8 */,
  0xC1620179l /* 0x01FCBC */,
  0x016944B0l /* 0x01FCC0 */,
  0x38B024C0l /* 0x01FCC4 */,
  0x38B0C0C2l /* 0x01FCC8 */,
  0x3CB00079l /* 0x01FCCC */,
  0x3CB04070l /* 0x01FCD0 */,
  0x0159C070l /* 0x01FCD4 */,
  0xE506E4EBl /* 0x01FCD8 */,
  0x017954D0l /* 0x01FCDC */,
  0x01695506l /* 0x01FCE0 */,
  0xF4602407l /* 0x01FCE4 */,
  0x100203C9l /* 0x01FCE8 */,
  0x2507EEEBl /* 0x01FCEC */,
  0xC1706CD0l /* 0x01FCF0 */,
  0xC1607CB0l /* 0x01FCF4 */,
  0x110A100Al /* 0x01FCF8 */,
  0xF5E30069l /* 0x01FCFC */,
  0x240700D9l /* 0x01FD00 */,
  0x24073469l /* 0x01FD04 */,
  0x6700B060l /* 0x01FD08 */,
  0xD3E170D0l /* 0x01FD0C */,
  0xC472E705l /* 0x01FD10 */,
  0x00D0E205l /* 0x01FD14 */,
  0x40702D00l /* 0x01FD18 */,
  0xC0EB4B30l /* 0x01FD1C */,
  0x08D0E205l /* 0x01FD20 */,
  0x60702D00l /* 0x01FD24 */,
  0xC0EB4B30l /* 0x01FD28 */,
  0x10D0E205l /* 0x01FD2C */,
  0x3C60E105l /* 0x01FD30 */,
  0xF4D02407l /* 0x01FD34 */,
  0x03C9C370l /* 0x01FD38 */,
  0xCAFB1002l /* 0x01FD3C */,
  0xE4EB1102l /* 0x01FD40 */,
  0x70702005l /* 0x01FD44 */,
  0xE1FB6110l /* 0x01FD48 */,
  0x200540D0l /* 0x01FD4C */,
  0x41D07060l /* 0x01FD50 */,
  0x74602005l /* 0x01FD54 */,
  0x4C702105l /* 0x01FD58 */,
  0x4C602807l /* 0x01FD5C */,
  0x44702105l /* 0x01FD60 */,
  0x44602807l /* 0x01FD64 */,
  0x48702105l /* 0x01FD68 */,
  0x48602807l /* 0x01FD6C */,
  0x40D0E4E3l /* 0x01FD70 */,
  0x74602005l /* 0x01FD74 */,
  0x78D06700l /* 0x01FD78 */,
  0x0000D3E1l /* 0x01FD7C */,
  0x74D02507l /* 0x01FD80 */,
  0xA2108170l /* 0x01FD84 */,
  0xBFB0B8EBl /* 0x01FD88 */,
  0x81B08160l /* 0x01FD8C */,
  0xC472E705l /* 0x01FD90 */,
  0x34D02607l /* 0x01FD94 */,
  0x24D12707l /* 0x01FD98 */,
  0x40702D00l /* 0x01FD9C */,
  0xCAEB4B30l /* 0x01FDA0 */,
  0x3CB134B0l /* 0x01FDA4 */,
  0x60702D00l /* 0x01FDA8 */,
  0xCAEB4B30l /* 0x01FDAC */,
  0x3CB134B0l /* 0x01FDB0 */,
  0x02208210l /* 0x01FDB4 */,
  0x25078074l /* 0x01FDB8 */,
  0x8324F070l /* 0x01FDBC */,
  0x48702200l /* 0x01FDC0 */,
  0xDBEB6010l /* 0x01FDC4 */,
  0xD7FB6110l /* 0x01FDC8 */,
  0x220083C4l /* 0x01FDCC */,
  0x5E104C70l /* 0x01FDD0 */,
  0xC1108134l /* 0x01FDD4 */,
  0x80B092C0l /* 0x01FDD8 */,
  0x80D4E1F7l /* 0x01FDDC */,
  0x8330E4E3l /* 0x01FDE0 */,
  0x83C4E4FFl /* 0x01FDE4 */,
  0xEFEB9403l /* 0x01FDE8 */,
  0x20100470l /* 0x01FDEC */,
  0x00D0EFEBl /* 0x01FDF0 */,
  0xA4070460l /* 0x01FDF4 */,
  0x27070C60l /* 0x01FDF8 */,
  0x2F053460l /* 0x01FDFC */,
  0xC39008D0l /* 0x01FE00 */,
  0xC0603F80l /* 0x01FE04 */,
  0xC2903CB0l /* 0x01FE08 */,
  0xC0603F80l /* 0x01FE0C */,
  0x58D06A00l /* 0x01FE10 */,
  0x0000D3E1l /* 0x01FE14 */,
  0x6205900Bl /* 0x01FE18 */,
  0x24072479l /* 0x01FE1C */,
  0x81B0B070l /* 0x01FE20 */,
  0xD407B8FBl /* 0x01FE24 */,
  0xB860E605l /* 0x01FE28 */,
  0xC472E705l /* 0x01FE2C */,
  0x7C702507l /* 0x01FE30 */,
  0x2707D20Bl /* 0x01FE34 */,
  0x2E001C70l /* 0x01FE38 */,
  0x8B308070l /* 0x01FE3C */,
  0x2005E1FBl /* 0x01FE40 */,
  0xA010A470l /* 0x01FE44 */,
  0x2D00CCEBl /* 0x01FE48 */,
  0xE1E3C072l /* 0x01FE4C */,
  0x20702707l /* 0x01FE50 */,
  0x8C70A205l /* 0x01FE54 */,
  0xE1FBA310l /* 0x01FE58 */,
  0xDC702605l /* 0x01FE5C */,
  0xE1FBE010l /* 0x01FE60 */,
  0xE1EB6110l /* 0x01FE64 */,
  0xB070E804l /* 0x01FE68 */,
  0xE1FBA010l /* 0x01FE6C */,
  0x2019D207l /* 0x01FE70 */,
  0x9007FBEBl /* 0x01FE74 */,
  0x80D0FBE3l /* 0x01FE78 */,
  0xE5EBD503l /* 0x01FE7C */,
  0x611084D0l /* 0x01FE80 */,
  0x2019F0EBl /* 0x01FE84 */,
  0x80D0EBEBl /* 0x01FE88 */,
  0xED04F0E3l /* 0x01FE8C */,
  0xE310E470l /* 0x01FE90 */,
  0x80D0F0EBl /* 0x01FE94 */,
  0x0B20C222l /* 0x01FE98 */,
  0x611000C3l /* 0x01FE9C */,
  0xD503F8FBl /* 0x01FEA0 */,
  0x04B3F8EBl /* 0x01FEA4 */,
  0x58D06800l /* 0x01FEA8 */,
  0x6800D3E1l /* 0x01FEAC */,
  0xD3E148D0l /* 0x01FEB0 */,
  0x4601C600l /* 0x01FEB4 */,
  0x4CD0E704l /* 0x01FEB8 */,
  0xB9FB9003l /* 0x01FEBC */,
  0xB9EBD503l /* 0x01FEC0 */,
  0x01707CB0l /* 0x01FEC4 */,
  0xBFFB2010l /* 0x01FEC8 */,
  0x50D06800l /* 0x01FECC */,
  0x3CB0D3E1l /* 0x01FED0 */,
  0x02C98070l /* 0x01FED4 */,
  0xA1109010l /* 0x01FED8 */,
  0xEF0FE0EBl /* 0x01FEDC */,
  0x20193F49l /* 0x01FEE0 */,
  0xAC04BCEBl /* 0x01FEE4 */,
  0x01691029l /* 0x01FEE8 */,
  0xC0C004B0l /* 0x01FEEC */,
  0x88D0E704l /* 0x01FEF0 */,
  0xC2604270l /* 0x01FEF4 */,
  0xD7FB6010l /* 0x01FEF8 */,
  0xC26084B0l /* 0x01FEFC */,
  0x7CB0DCE3l /* 0x01FF00 */,
  0xAC0403C0l /* 0x01FF04 */,
  0x01601030l /* 0x01FF08 */,
  0x80D0FCB0l /* 0x01FF0C */,
  0xB0E38360l /* 0x01FF10 */,
  0x04B0D207l /* 0x01FF14 */,
  0x0460E804l /* 0x01FF18 */,
  0x0060E804l /* 0x01FF1C */,
  0x0860E804l /* 0x01FF20 */,
  0xE4020079l /* 0x01FF24 */,
  0x100200D0l /* 0x01FF28 */,
  0x60D0F0FBl /* 0x01FF2C */,
  0x01C04030l /* 0x01FF30 */,
  0x24C3100Al /* 0x01FF34 */,
  0xC032E4C2l /* 0x01FF38 */,
  0x6800CBC4l /* 0x01FF3C */,
  0xD3E158D0l /* 0x01FF40 */,
  0xE804D20Bl /* 0x01FF44 */,
  0xC2728CD0l /* 0x01FF48 */,
  0x00D4B501l /* 0x01FF4C */,
  0x00C30B20l /* 0x01FF50 */,
  0xBCEBD503l /* 0x01FF54 */,
  0x3CB3FCB2l /* 0x01FF58 */,
  0x6800CBC4l /* 0x01FF5C */,
  0xD3E158D0l /* 0x01FF60 */,
  0x34792407l /* 0x01FF64 */,
  0x84702200l /* 0x01FF68 */,
  0xBCFB1002l /* 0x01FF6C */,
  0x10D02607l /* 0x01FF70 */,
  0x8060C070l /* 0x01FF74 */,
  0xDDEBC230l /* 0x01FF78 */,
  0xE4D02407l /* 0x01FF7C */,
  0x100A0379l /* 0x01FF80 */,
  0x2B070369l /* 0x01FF84 */,
  0xA2100CD0l /* 0x01FF88 */,
  0x2A07CBEBl /* 0x01FF8C */,
  0xA11030D0l /* 0x01FF90 */,
  0x2B07CBEBl /* 0x01FF94 */,
  0x2C0728D0l /* 0x01FF98 */,
  0x2000C4D0l /* 0x01FF9C */,
  0x807046D0l /* 0x01FFA0 */,
  0x3CB08360l /* 0x01FFA4 */,
  0x41B0FCB0l /* 0x01FFA8 */,
  0x2200CFF7l /* 0x01FFAC */,
  0xE010C470l /* 0x01FFB0 */,
  0x2507DDFBl /* 0x01FFB4 */,
  0x25078870l /* 0x01FFB8 */,
  0x26078060l /* 0x01FFBC */,
  0xE110D070l /* 0x01FFC0 */,
  0x80D4E2EBl /* 0x01FFC4 */,
  0x40702507l /* 0x01FFC8 */,
  0xA8702200l /* 0x01FFCC */,
  0xF2EBA010l /* 0x01FFD0 */,
  0xFC702707l /* 0x01FFD4 */,
  0x82108320l /* 0x01FFD8 */,
  0x4C105410l /* 0x01FFDC */,
  0x25074220l /* 0x01FFE0 */,
  0x426080D0l /* 0x01FFE4 */,
  0x78D06A00l /* 0x01FFE8 */,
  0x0000D3E1l /* 0x01FFEC */,
  0x34702005l /* 0x01FFF0 */,
  0xB6FB2110l /* 0x01FFF4 */,
  0x8C742807l /* 0x01FFF8 */,
  0x84D02C07l /* 0x01FFFC */,
  0x1CD02C07l /* 0x020000 */,
  0x1081C070l /* 0x020004 */,
  0x15A00270l /* 0x020008 */,
  0x24073F80l /* 0x02000C */,
  0x2005BC64l /* 0x020010 */,
  0x21103470l /* 0x020014 */,
  0x12C0CAFBl /* 0x020018 */,
  0x014043D0l /* 0x02001C */,
  0x80200210l /* 0x020020 */,
  0x0271BCB0l /* 0x020024 */,
  0x14D02507l /* 0x020028 */,
  0x00618070l /* 0x02002C */,
  0xEBEB8430l /* 0x020030 */,
  0x7FD02700l /* 0x020034 */,
  0x6B07C140l /* 0x020038 */,
  0xC60048D1l /* 0x02003C */,
  0xE0EB2011l /* 0x020040 */,
  0x05600470l /* 0x020044 */,
  0x7CB13CB1l /* 0x020048 */,
  0xDAF7C4B0l /* 0x02004C */,
  0x48D16B07l /* 0x020050 */,
  0x2C07D081l /* 0x020054 */,
  0xC0701CD0l /* 0x020058 */,
  0xCA00C3C0l /* 0x02005C */,
  0x06008575l /* 0x020060 */,
  0x2C074601l /* 0x020064 */,
  0x417458D0l /* 0x020068 */,
  0x40D06800l /* 0x02006C */,
  0x0000D3E1l /* 0x020070 */,
  0x40D06800l /* 0x020074 */,
  0x0000D3E1l /* 0x020078 */,
  0x3C70E105l /* 0x02007C */,
  0xE1054070l /* 0x020080 */,
  0x3CB06860l /* 0x020084 */,
  0x25070070l /* 0x020088 */,
  0x24070060l /* 0x02008C */,
  0x22003479l /* 0x020090 */,
  0x817044D0l /* 0x020094 */,
  0x110200D1l /* 0x020098 */,
  0x2A00CBFBl /* 0x02009C */,
  0x68102070l /* 0x0200A0 */,
  0x2607CBEBl /* 0x0200A4 */,
  0xC5704CD1l /* 0x0200A8 */,
  0xC2308560l /* 0x0200AC */,
  0x2407EBEBl /* 0x0200B0 */,
  0x0379E4D0l /* 0x0200B4 */,
  0x0369110Al /* 0x0200B8 */,
  0x70D12807l /* 0x0200BC */,
  0xDDEBA110l /* 0x0200C0 */,
  0xD9EBA210l /* 0x0200C4 */,
  0x60D12907l /* 0x0200C8 */,
  0xE105DDE3l /* 0x0200CC */,
  0x29073871l /* 0x0200D0 */,
  0x260748D1l /* 0x0200D4 */,
  0x29071C61l /* 0x0200D8 */,
  0xC6D078D0l /* 0x0200DC */,
  0x01600570l /* 0x0200E0 */,
  0x7CB17CB0l /* 0x0200E4 */,
  0xE2FBC1B0l /* 0x0200E8 */,
  0x60D06A00l /* 0x0200EC */,
  0x2705D3E1l /* 0x0200F0 */,
  0x20100870l /* 0x0200F4 */,
  0xE105F5EBl /* 0x0200F8 */,
  0xE1052870l /* 0x0200FC */,
  0x100E3079l /* 0x020100 */,
  0x6A00E8FBl /* 0x020104 */,
  0xD3E170D0l /* 0x020108 */,
  0x08712705l /* 0x02010C */,
  0x220000D0l /* 0x020110 */,
  0xA2058470l /* 0x020114 */,
  0xE1052079l /* 0x020118 */,
  0xE1056871l /* 0x02011C */,
  0x23007061l /* 0x020120 */,
  0xD103F0D0l /* 0x020124 */,
  0x2400C1EBl /* 0x020128 */,
  0xA110DED0l /* 0x02012C */,
  0xA210CDEBl /* 0x020130 */,
  0xA205D7EBl /* 0x020134 */,
  0x5F104470l /* 0x020138 */,
  0x813083C0l /* 0x02013C */,
  0xA0109F10l /* 0x020140 */,
  0x2011E5F7l /* 0x020144 */,
  0x1002D5FFl /* 0x020148 */,
  0x6011D5FBl /* 0x02014C */,
  0x30D0D5EBl /* 0x020150 */,
  0x80D0C030l /* 0x020154 */,
  0x2011E5E3l /* 0x020158 */,
  0x1002E3FFl /* 0x02015C */,
  0x6011E3FBl /* 0x020160 */,
  0x2807E3EBl /* 0x020164 */,
  0x61105C70l /* 0x020168 */,
  0x24D0D3EBl /* 0x02016C */,
  0x2607C030l /* 0x020170 */,
  0xC2309C70l /* 0x020174 */,
  0x1F10C230l /* 0x020178 */,
  0x18602607l /* 0x02017C */,
  0x94602607l /* 0x020180 */,
  0xC8602607l /* 0x020184 */,
  0x68D06A00l /* 0x020188 */,
  0x0000D3E1l /* 0x02018C */,
  0x2607C600l /* 0x020190 */,
  0x62054870l /* 0x020194 */,
  0x10022479l /* 0x020198 */,
  0xED04C4FBl /* 0x02019C */,
  0x23192479l /* 0x0201A0 */,
  0xE505C4FBl /* 0x0201A4 */,
  0x20102C70l /* 0x0201A8 */,
  0x2507C4FBl /* 0x0201AC */,
  0x20193C79l /* 0x0201B0 */,
  0x7FB0C7EBl /* 0x0201B4 */,
  0x260742B0l /* 0x0201B8 */,
  0x29074860l /* 0x0201BC */,
  0x60107870l /* 0x0201C0 */,
  0x2A07F9EBl /* 0x0201C4 */,
  0x6E070071l /* 0x0201C8 */,
  0x0170C8D0l /* 0x0201CC */,
  0xFCB00360l /* 0x0201D0 */,
  0x04B17CB0l /* 0x0201D4 */,
  0x2907CFEFl /* 0x0201D8 */,
  0x2A077C70l /* 0x0201DC */,
  0x6F070071l /* 0x0201E0 */,
  0x0170D8D0l /* 0x0201E4 */,
  0xFCB00360l /* 0x0201E8 */,
  0x04B17CB0l /* 0x0201EC */,
  0x2A07DBEFl /* 0x0201F0 */,
  0x2A074470l /* 0x0201F4 */,
  0xA0070C71l /* 0x0201F8 */,
  0x0170E8D0l /* 0x0201FC */,
  0xFCB00360l /* 0x020200 */,
  0x04B17CB0l /* 0x020204 */,
  0x2A07E7EFl /* 0x020208 */,
  0x2A074870l /* 0x02020C */,
  0xA1070C71l /* 0x020210 */,
  0x0170F8D0l /* 0x020214 */,
  0xFCB00360l /* 0x020218 */,
  0x04B17CB0l /* 0x02021C */,
  0x4601F3EFl /* 0x020220 */,
  0x70D06A00l /* 0x020224 */,
  0x0000D3E1l /* 0x020228 */,
  0x1E1012C0l /* 0x02022C */,
  0x03402000l /* 0x020230 */,
  0x80702507l /* 0x020234 */,
  0x90890220l /* 0x020238 */,
  0x9C1415A0l /* 0x02023C */,
  0xD2038614l /* 0x020240 */,
  0xE704C3EBl /* 0x020244 */,
  0xE7043463l /* 0x020248 */,
  0xE704F062l /* 0x02024C */,
  0x07D0F864l /* 0x020250 */,
  0x80548314l /* 0x020254 */,
  0x2B0080D1l /* 0x020258 */,
  0x007020D0l /* 0x02025C */,
  0xF6EB2010l /* 0x020260 */,
  0x20D02200l /* 0x020264 */,
  0xD2EBD503l /* 0x020268 */,
  0x24D02200l /* 0x02026C */,
  0x60114071l /* 0x020270 */,
  0xE000F6EBl /* 0x020274 */,
  0x10A000D0l /* 0x020278 */,
  0xD08585C0l /* 0x02027C */,
  0x0B02B0B0l /* 0x020280 */,
  0xB4B04275l /* 0x020284 */,
  0x30018270l /* 0x020288 */,
  0x50873CD0l /* 0x02028C */,
  0x82750A00l /* 0x020290 */,
  0x3A830600l /* 0x020294 */,
  0x7A833B88l /* 0x020298 */,
  0x0B033F80l /* 0x02029C */,
  0x0600C57El /* 0x0202A0 */,
  0x908680C1l /* 0x0202A4 */,
  0xBFD22F00l /* 0x0202A8 */,
  0x84421591l /* 0x0202AC */,
  0x3F8064A0l /* 0x0202B0 */,
  0x03758A00l /* 0x0202B4 */,
  0x60D06800l /* 0x0202B8 */,
  0x0000D3E1l /* 0x0202BC */,
  0x1870E205l /* 0x0202C0 */,
  0xB9EB2010l /* 0x0202C4 */,
  0x1C70E205l /* 0x0202C8 */,
  0xE2053FB0l /* 0x0202CC */,
  0x24071C60l /* 0x0202D0 */,
  0x20112C71l /* 0x0202D4 */,
  0xE605C2EBl /* 0x0202D8 */,
  0x5F106470l /* 0x0202DC */,
  0xC7E30131l /* 0x0202E0 */,
  0x14712607l /* 0x0202E4 */,
  0x18702607l /* 0x0202E8 */,
  0x26070021l /* 0x0202EC */,
  0x26070461l /* 0x0202F0 */,
  0xE2054871l /* 0x0202F4 */,
  0x40312870l /* 0x0202F8 */,
  0x4A114421l /* 0x0202FC */,
  0x04C00551l /* 0x020300 */,
  0x78814601l /* 0x020304 */,
  0x36D12900l /* 0x020308 */,
  0x3881DCF3l /* 0x02030C */,
  0x6800C600l /* 0x020310 */,
  0xD3E168D0l /* 0x020314 */,
  0x40C00600l /* 0x020318 */,
  0x1610C0C0l /* 0x02031C */,
  0x80D0EF00l /* 0x020320 */,
  0x20000240l /* 0x020324 */,
  0x0250B0D0l /* 0x020328 */,
  0x20005410l /* 0x02032C */,
  0x42408FD0l /* 0x020330 */,
  0xEF000150l /* 0x020334 */,
  0xC240BFD0l /* 0x020338 */,
  0x80D0200Dl /* 0x02033C */,
  0x36A18350l /* 0x020340 */,
  0x34A03F80l /* 0x020344 */,
  0xB4A03F80l /* 0x020348 */,
  0xC5073F80l /* 0x02034C */,
  0x34702005l /* 0x020350 */,
  0xBFFB2110l /* 0x020354 */,
  0x44702807l /* 0x020358 */,
  0x2807C122l /* 0x02035C */,
  0x01234870l /* 0x020360 */,
  0x20702A00l /* 0x020364 */,
  0x18402000l /* 0x020368 */,
  0x00D0C2FBl /* 0x02036C */,
  0x24602005l /* 0x020370 */,
  0x2B00CBC4l /* 0x020374 */,
  0xD50318D0l /* 0x020378 */,
  0x80D0CAFBl /* 0x02037C */,
  0xCCE38060l /* 0x020380 */,
  0x806081D0l /* 0x020384 */,
  0x68D3A007l /* 0x020388 */,
  0xD2EBD503l /* 0x02038C */,
  0x78D3A107l /* 0x020390 */,
  0x1CD9E605l /* 0x020394 */,
  0x13022479l /* 0x020398 */,
  0xAF05F6EBl /* 0x02039C */,
  0xC0C020D0l /* 0x0203A0 */,
  0x00D0E005l /* 0x0203A4 */,
  0xE005C060l /* 0x0203A8 */,
  0x270004D0l /* 0x0203AC */,
  0x11023479l /* 0x0203B0 */,
  0xD503E7FBl /* 0x0203B4 */,
  0xE005E7EBl /* 0x0203B8 */,
  0x40C010D0l /* 0x0203BC */,
  0x30D0AF05l /* 0x0203C0 */,
  0x80608170l /* 0x0203C4 */,
  0x3CB07CB0l /* 0x0203C8 */,
  0x80608170l /* 0x0203CC */,
  0x3CD0AF05l /* 0x0203D0 */,
  0x6800C076l /* 0x0203D4 */,
  0xD3E170D0l /* 0x0203D8 */,
  0x00D02400l /* 0x0203DC */,
  0x680010A0l /* 0x0203E0 */,
  0xD3E170D0l /* 0x0203E4 */,
  0x0C702607l /* 0x0203E8 */,
  0xB9FB2210l /* 0x0203EC */,
  0x1C702607l /* 0x0203F0 */,
  0xB9EB2010l /* 0x0203F4 */,
  0xE6053CB4l /* 0x0203F8 */,
  0x13021C79l /* 0x0203FC */,
  0xE005C6EBl /* 0x020400 */,
  0x15192079l /* 0x020404 */,
  0x004903D0l /* 0x020408 */,
  0x00D0C9EBl /* 0x02040C */,
  0x1C60E605l /* 0x020410 */,
  0x40D06900l /* 0x020414 */,
  0x9307D3E1l /* 0x020418 */,
  0x00D92004l /* 0x02041C */,
  0x34D0AF05l /* 0x020420 */,
  0x007064C0l /* 0x020424 */,
  0x20005710l /* 0x020428 */,
  0x4240BFD0l /* 0x02042C */,
  0xA0D04610l /* 0x020430 */,
  0x64A04250l /* 0x020434 */,
  0x7FD02700l /* 0x020438 */,
  0x02190149l /* 0x02043C */,
  0x51065606l /* 0x020440 */,
  0x3F801E06l /* 0x020444 */,
  0x0A0940C0l /* 0x020448 */,
  0x2008C174l /* 0x02044C */,
  0x10A000D0l /* 0x020450 */,
  0x15D02C00l /* 0x020454 */,
  0x300110A0l /* 0x020458 */,
  0x40C03CD0l /* 0x02045C */,
  0x1CD0AF05l /* 0x020460 */,
  0x06000070l /* 0x020464 */,
  0x4A003F80l /* 0x020468 */,
  0x06008075l /* 0x02046C */,
  0x78D06800l /* 0x020470 */,
  0x0000D3E1l /* 0x020474 */,
  0xE0055082l /* 0x020478 */,
  0x007000D0l /* 0x02047C */,
  0x40750B04l /* 0x020480 */,
  0x90830600l /* 0x020484 */,
  0x959383D0l /* 0x020488 */,
  0x50849B40l /* 0x02048C */,
  0x81504CD0l /* 0x020490 */,
  0xE01695A0l /* 0x020494 */,
  0xD084E6EBl /* 0x020498 */,
  0x0DD03004l /* 0x02049C */,
  0x5BC00210l /* 0x0204A0 */,
  0x42105E10l /* 0x0204A4 */,
  0x0A003F80l /* 0x0204A8 */,
  0x06004175l /* 0x0204AC */,
  0xFF03508Cl /* 0x0204B0 */,
  0x1599FFDFl /* 0x0204B4 */,
  0x95932019l /* 0x0204B8 */,
  0x21008043l /* 0x0204BC */,
  0x01497FD0l /* 0x0204C0 */,
  0xDAEB1002l /* 0x0204C4 */,
  0xE6E3C0D6l /* 0x0204C8 */,
  0x5BC0E426l /* 0x0204CC */,
  0x3CD02800l /* 0x0204D0 */,
  0x40300070l /* 0x0204D4 */,
  0x6A05E6FFl /* 0x0204D8 */,
  0x00703CD0l /* 0x0204DC */,
  0xE6E3C036l /* 0x0204E0 */,
  0x40D06900l /* 0x0204E4 */,
  0x0000D3E1l /* 0x0204E8 */,
  0x210060C1l /* 0x0204EC */,
  0x40701CD0l /* 0x0204F0 */,
  0xBAFB6010l /* 0x0204F4 */,
  0x41D02004l /* 0x0204F8 */,
  0x3F8077A0l /* 0x0204FC */,
  0x00D92291l /* 0x020500 */,
  0x00D8C0D0l /* 0x020504 */,
  0x6390A280l /* 0x020508 */,
  0xC4EF6010l /* 0x02050C */,
  0x10045006l /* 0x020510 */,
  0x88D02B00l /* 0x020514 */,
  0xE2814260l /* 0x020518 */,
  0x60106390l /* 0x02051C */,
  0x5006CDEFl /* 0x020520 */,
  0xBCB01104l /* 0x020524 */,
  0x20184260l /* 0x020528 */,
  0xE506D4EBl /* 0x02052C */,
  0x00681CD0l /* 0x020530 */,
  0x628000D8l /* 0x020534 */,
  0x60106390l /* 0x020538 */,
  0x1806DBEFl /* 0x02053C */,
  0xA2811004l /* 0x020540 */,
  0x6A056390l /* 0x020544 */,
  0x60106C60l /* 0x020548 */,
  0x1806E3EFl /* 0x02054C */,
  0x20181104l /* 0x020550 */,
  0xE506E8EBl /* 0x020554 */,
  0x006820D0l /* 0x020558 */,
  0x14D0E506l /* 0x02055C */,
  0x01594070l /* 0x020560 */,
  0x22A10069l /* 0x020564 */,
  0x40D03F80l /* 0x020568 */,
  0xF3FBD503l /* 0x02056C */,
  0x2B0041D0l /* 0x020570 */,
  0x406018D0l /* 0x020574 */,
  0x690005C8l /* 0x020578 */,
  0xD3E148D0l /* 0x02057C */,
  0x18D02200l /* 0x020580 */,
  0x40C00070l /* 0x020584 */,
  0x48105010l /* 0x020588 */,
  0xBFD02300l /* 0x02058C */,
  0x42508040l /* 0x020590 */,
  0xEC0F4810l /* 0x020594 */,
  0x804080D0l /* 0x020598 */,
  0x42509810l /* 0x02059C */,
  0x10A02AD0l /* 0x0205A0 */,
  0x3F8055A0l /* 0x0205A4 */,
  0xC0D000D9l /* 0x0205A8 */,
  0x6870EB04l /* 0x0205AC */,
  0xE8FB6010l /* 0x0205B0 */,
  0xE0EB9403l /* 0x0205B4 */,
  0x6C051106l /* 0x0205B8 */,
  0x417050D0l /* 0x0205BC */,
  0xE8FB6110l /* 0x0205C0 */,
  0x20D06C05l /* 0x0205C4 */,
  0x60104070l /* 0x0205C8 */,
  0x1306D9EBl /* 0x0205CC */,
  0x6C05C060l /* 0x0205D0 */,
  0x407024D0l /* 0x0205D4 */,
  0xE8EB6010l /* 0x0205D8 */,
  0xC0601206l /* 0x0205DC */,
  0x54D0E506l /* 0x0205E0 */,
  0x00D0B000l /* 0x0205E4 */,
  0x01404170l /* 0x0205E8 */,
  0x1406E8EBl /* 0x0205EC */,
  0x14D0E506l /* 0x0205F0 */,
  0x64504070l /* 0x0205F4 */,
  0x69004060l /* 0x0205F8 */,
  0xD3E150D0l /* 0x0205FC */,
  0x00D0EA04l /* 0x020600 */,
  0x02B00070l /* 0x020604 */,
  0xEA04CFFBl /* 0x020608 */,
  0x007004D0l /* 0x02060C */,
  0xCFFB01B0l /* 0x020610 */,
  0x3CD0E206l /* 0x020614 */,
  0x41B04070l /* 0x020618 */,
  0x40B04060l /* 0x02061C */,
  0xE406CFFBl /* 0x020620 */,
  0x407008D0l /* 0x020624 */,
  0x40607FB0l /* 0x020628 */,
  0x54D0A400l /* 0x02062C */,
  0x01301D90l /* 0x020630 */,
  0xDF80CEFFl /* 0x020634 */,
  0x3F803F80l /* 0x020638 */,
  0x6900D2F3l /* 0x02063C */,
  0xD3E158D0l /* 0x020640 */,
  0x3F80B580l /* 0x020644 */,
  0x26A007D0l /* 0x020648 */,
  0x3F801E80l /* 0x02064C */,
  0x40D06000l /* 0x020650 */,
  0x3F8066A0l /* 0x020654 */,
  0x60D02400l /* 0x020658 */,
  0x3F8066A0l /* 0x02065C */,
  0x70D02400l /* 0x020660 */,
  0x3F8066A0l /* 0x020664 */,
  0x40D06800l /* 0x020668 */,
  0x3F8066A0l /* 0x02066C */,
  0x3F80F580l /* 0x020670 */,
  0x3CD0E206l /* 0x020674 */,
  0x40604AD0l /* 0x020678 */,
  0x0000C507l /* 0x02067C */,
  0x00D0EA04l /* 0x020680 */,
  0x02B00070l /* 0x020684 */,
  0xEA04ECFBl /* 0x020688 */,
  0x007004D0l /* 0x02068C */,
  0xECFB01B0l /* 0x020690 */,
  0x30D9A400l /* 0x020694 */,
  0x3F8036A9l /* 0x020698 */,
  0x1B023499l /* 0x02069C */,
  0x2B00ECEBl /* 0x0206A0 */,
  0x007924D0l /* 0x0206A4 */,
  0x2CD02E05l /* 0x0206A8 */,
  0x00694070l /* 0x0206AC */,
  0xD1FB110El /* 0x0206B0 */,
  0x30D02E05l /* 0x0206B4 */,
  0x41B04070l /* 0x0206B8 */,
  0x4060D6EBl /* 0x0206BC */,
  0x2E05ECE3l /* 0x0206C0 */,
  0x03D070D0l /* 0x0206C4 */,
  0xECE30160l /* 0x0206C8 */,
  0x14D0E506l /* 0x0206CC */,
  0x00794601l /* 0x0206D0 */,
  0x00691D06l /* 0x0206D4 */,
  0x2A00C600l /* 0x0206D8 */,
  0x48D020D0l /* 0x0206DC */,
  0xA4004060l /* 0x0206E0 */,
  0x36A930D9l /* 0x0206E4 */,
  0x34993F80l /* 0x0206E8 */,
  0x24001B0Al /* 0x0206EC */,
  0x36A030D0l /* 0x0206F0 */,
  0x34A93F80l /* 0x0206F4 */,
  0x20792A00l /* 0x0206F8 */,
  0xF4EB2219l /* 0x0206FC */,
  0x2C792200l /* 0x020700 */,
  0xF7EB1002l /* 0x020704 */,
  0x68D06900l /* 0x020708 */,
  0x6900F9E3l /* 0x02070C */,
  0xD3E160D0l /* 0x020710 */,
  0x68D1A105l /* 0x020714 */,
  0x20792500l /* 0x020718 */,
  0xF0FB1702l /* 0x02071C */,
  0x4070EA04l /* 0x020720 */,
  0xF0EB6310l /* 0x020724 */,
  0x2470E105l /* 0x020728 */,
  0x40702705l /* 0x02072C */,
  0x27050150l /* 0x020730 */,
  0x01506470l /* 0x020734 */,
  0xF0FB2010l /* 0x020738 */,
  0xACD0A105l /* 0x02073C */,
  0x1D994270l /* 0x020740 */,
  0xEFFB110El /* 0x020744 */,
  0xFF0FE290l /* 0x020748 */,
  0xA105FCDFl /* 0x02074C */,
  0x4270B4D0l /* 0x020750 */,
  0x2399E280l /* 0x020754 */,
  0xE2A00049l /* 0x020758 */,
  0xEFFB110El /* 0x02075C */,
  0xB8D0A105l /* 0x020760 */,
  0x22824270l /* 0x020764 */,
  0x00492399l /* 0x020768 */,
  0x110EE2A0l /* 0x02076C */,
  0x0571EFFBl /* 0x020770 */,
  0xE4003FB1l /* 0x020774 */,
  0x44306C70l /* 0x020778 */,
  0x00D1F1EFl /* 0x02077C */,
  0x70000561l /* 0x020780 */,
  0x38A000D0l /* 0x020784 */,
  0xAFDF2700l /* 0x020788 */,
  0xC0DF2001l /* 0x02078C */,
  0x0269870Fl /* 0x020790 */,
  0x056100D1l /* 0x020794 */,
  0xFDEBD503l /* 0x020798 */,
  0x70706100l /* 0x02079C */,
  0x10706205l /* 0x0207A0 */,
  0x50606205l /* 0x0207A4 */,
  0xE7004030l /* 0x0207A8 */,
  0x69005460l /* 0x0207AC */,
  0xD3E168D0l /* 0x0207B0 */,
  0x8CD06205l /* 0x0207B4 */,
  0xA0108270l /* 0x0207B8 */,
  0x2605E3FBl /* 0x0207BC */,
  0x00793CD0l /* 0x0207C0 */,
  0xE3EB9403l /* 0x0207C4 */,
  0xE3FB1302l /* 0x0207C8 */,
  0x94D02905l /* 0x0207CC */,
  0xA0108270l /* 0x0207D0 */,
  0x6405C9FBl /* 0x0207D4 */,
  0xC07028D0l /* 0x0207D8 */,
  0x807024B0l /* 0x0207DC */,
  0xC9FBC230l /* 0x0207E0 */,
  0x2E05E3E3l /* 0x0207E4 */,
  0x007110D0l /* 0x0207E8 */,
  0x40713CB0l /* 0x0207EC */,
  0xD3FB2011l /* 0x0207F0 */,
  0xD3FB6011l /* 0x0207F4 */,
  0xECF3E3E3l /* 0x0207F8 */,
  0x03A142A1l /* 0x0207FC */,
  0x290541D0l /* 0x020800 */,
  0x40601CD0l /* 0x020804 */,
  0x620540D0l /* 0x020808 */,
  0x406008D0l /* 0x02080C */,
  0x3CD06105l /* 0x020810 */,
  0x7FB04070l /* 0x020814 */,
  0xD2034060l /* 0x020818 */,
  0x6900E8FBl /* 0x02081C */,
  0xD3E170D0l /* 0x020820 */,
  0x40D06A00l /* 0x020824 */,
  0xD3E1D3E1l /* 0x020828 */,
  0x441042D0l /* 0x02082C */,
  0x921085C0l /* 0x020830 */,
  0x8340CFD0l /* 0x020834 */,
  0x8350C1D0l /* 0x020838 */,
  0x4F104220l /* 0x02083C */,
  0xEF074110l /* 0x020840 */,
  0x4241BFD0l /* 0x020844 */,
  0x41214111l /* 0x020848 */,
  0x01114351l /* 0x02084C */,
  0xC5070351l /* 0x020850 */,
  0xACD06005l /* 0x020854 */,
  0x60104270l /* 0x020858 */,
  0x2B00E9EBl /* 0x02085C */,
  0x6F05E470l /* 0x020860 */,
  0x03301C70l /* 0x020864 */,
  0x40D0C0EBl /* 0x020868 */,
  0x60054260l /* 0x02086C */,
  0xE9E37060l /* 0x020870 */,
  0xC4EB41B0l /* 0x020874 */,
  0xE9E34260l /* 0x020878 */,
  0x40D04260l /* 0x02087C */,
  0x70606005l /* 0x020880 */,
  0x68706005l /* 0x020884 */,
  0x60057FB0l /* 0x020888 */,
  0x65056860l /* 0x02088C */,
  0x20102070l /* 0x020890 */,
  0x2505D5FBl /* 0x020894 */,
  0xE7053C70l /* 0x020898 */,
  0x2D000060l /* 0x02089C */,
  0x407000D0l /* 0x0208A0 */,
  0xDCEB4230l /* 0x0208A4 */,
  0x20D02D00l /* 0x0208A8 */,
  0x54D02B00l /* 0x0208AC */,
  0xE5060160l /* 0x0208B0 */,
  0x10062479l /* 0x0208B4 */,
  0x2469E506l /* 0x0208B8 */,
  0x1479E506l /* 0x0208BC */,
  0xE5061706l /* 0x0208C0 */,
  0xE2901469l /* 0x0208C4 */,
  0x63902282l /* 0x0208C8 */,
  0xE2A06010l /* 0x0208CC */,
  0x20D16205l /* 0x0208D0 */,
  0x1CD06205l /* 0x0208D4 */,
  0x40608070l /* 0x0208D8 */,
  0xF9FB8130l /* 0x0208DC */,
  0x7FB04470l /* 0x0208E0 */,
  0x40D0FAE3l /* 0x0208E4 */,
  0x69004460l /* 0x0208E8 */,
  0xD3E178D0l /* 0x0208EC */,
  0x6870EB04l /* 0x0208F0 */,
  0xFAFB6010l /* 0x0208F4 */,
  0x4070EA04l /* 0x0208F8 */,
  0xFAEB6310l /* 0x0208FC */,
  0x24712B00l /* 0x020900 */,
  0xFAE72411l /* 0x020904 */,
  0x62806291l /* 0x020908 */,
  0x41C06390l /* 0x02090C */,
  0x6A0562A1l /* 0x020910 */,
  0x01301C70l /* 0x020914 */,
  0x40D0CBEFl /* 0x020918 */,
  0x70606005l /* 0x02091C */,
  0x6C606005l /* 0x020920 */,
  0x01D0FAE3l /* 0x020924 */,
  0x14606F05l /* 0x020928 */,
  0x2C706005l /* 0x02092C */,
  0xFAFB2010l /* 0x020930 */,
  0x0470E705l /* 0x020934 */,
  0x40702E00l /* 0x020938 */,
  0xFAFB0130l /* 0x02093C */,
  0x60706005l /* 0x020940 */,
  0xA4706005l /* 0x020944 */,
  0xA1108130l /* 0x020948 */,
  0x6005FAFBl /* 0x02094C */,
  0x407030D0l /* 0x020950 */,
  0xE9EB6010l /* 0x020954 */,
  0xFAFB6110l /* 0x020958 */,
  0x406040D0l /* 0x02095C */,
  0x2A00F1E3l /* 0x020960 */,
  0x74D0A470l /* 0x020964 */,
  0xF1FB4230l /* 0x020968 */,
  0x406042D0l /* 0x02096C */,
  0x6F05FAE3l /* 0x020970 */,
  0x60051C61l /* 0x020974 */,
  0x60106C70l /* 0x020978 */,
  0x42D0FAFBl /* 0x02097C */,
  0x6C606005l /* 0x020980 */,
  0x40D06A00l /* 0x020984 */,
  0x0000D3E1l /* 0x020988 */,
  0x78706205l /* 0x02098C */,
  0xB7EB6010l /* 0x020990 */,
  0x620541B0l /* 0x020994 */,
  0x26057860l /* 0x020998 */,
  0x00793CD0l /* 0x02099C */,
  0xC1EB1402l /* 0x0209A0 */,
  0x1CD02905l /* 0x0209A4 */,
  0x60104070l /* 0x0209A8 */,
  0xFF00D8EBl /* 0x0209AC */,
  0x4390FFDFl /* 0x0209B0 */,
  0x82903F80l /* 0x0209B4 */,
  0xEF078040l /* 0x0209B8 */,
  0x40403FD0l /* 0x0209BC */,
  0x9F10C2C0l /* 0x0209C0 */,
  0xC44001D1l /* 0x0209C4 */,
  0x4350CF10l /* 0x0209C8 */,
  0x36D02B00l /* 0x0209CC */,
  0x3F807CA0l /* 0x0209D0 */,
  0x3F80BDA0l /* 0x0209D4 */,
  0x06000060l /* 0x0209D8 */,
  0x2CD06100l /* 0x0209DC */,
  0x7FB04070l /* 0x0209E0 */,
  0x94034060l /* 0x0209E4 */,
  0x6205EBEBl /* 0x0209E8 */,
  0x40700CD0l /* 0x0209EC */,
  0xEBFB6010l /* 0x0209F0 */,
  0x38D02705l /* 0x0209F4 */,
  0x60104070l /* 0x0209F8 */,
  0x41B0EBEBl /* 0x0209FC */,
  0x940B4060l /* 0x020A00 */,
  0x6A001F0Bl /* 0x020A04 */,
  0xD3E148D0l /* 0x020A08 */,
  0x14D0E506l /* 0x020A0C */,
  0x16060079l /* 0x020A10 */,
  0xBAF30069l /* 0x020A14 */,
  0x00D87600l /* 0x020A18 */,
  0x870F38A0l /* 0x020A1C */,
  0x2CD02A00l /* 0x020A20 */,
  0xA0108070l /* 0x020A24 */,
  0xE506FBFBl /* 0x020A28 */,
  0x280014D0l /* 0x020A2C */,
  0x807040D0l /* 0x020A30 */,
  0xC240C170l /* 0x020A34 */,
  0x80D0FBEBl /* 0x020A38 */,
  0xF070E506l /* 0x020A3C */,
  0xD8602300l /* 0x020A40 */,
  0xB060E506l /* 0x020A44 */,
  0x2CD0E506l /* 0x020A48 */,
  0x44D02B00l /* 0x020A4C */,
  0xC160C070l /* 0x020A50 */,
  0x04B08060l /* 0x020A54 */,
  0xC07044B0l /* 0x020A58 */,
  0x8060C160l /* 0x020A5C */,
  0x44B004B0l /* 0x020A60 */,
  0xC160C070l /* 0x020A64 */,
  0x04B08060l /* 0x020A68 */,
  0xC07044B0l /* 0x020A6C */,
  0x8060C160l /* 0x020A70 */,
  0x44B004B0l /* 0x020A74 */,
  0xC160C070l /* 0x020A78 */,
  0x04B08060l /* 0x020A7C */,
  0xC07044B0l /* 0x020A80 */,
  0x8060C160l /* 0x020A84 */,
  0x44B004B0l /* 0x020A88 */,
  0xC160C070l /* 0x020A8C */,
  0x22008060l /* 0x020A90 */,
  0x18022C79l /* 0x020A94 */,
  0x2001FBFBl /* 0x020A98 */,
  0xC0A0C3D0l /* 0x020A9C */,
  0xC5073F80l /* 0x020AA0 */,
  0x2470E005l /* 0x020AA4 */,
  0x85E92310l /* 0x020AA8 */,
  0x38D02705l /* 0x020AAC */,
  0x20100070l /* 0x020AB0 */,
  0xE0054CF9l /* 0x020AB4 */,
  0x00783CD0l /* 0x020AB8 */,
  0x20F81D00l /* 0x020ABC */,
  0x34D06100l /* 0x020AC0 */,
  0x20100070l /* 0x020AC4 */,
  0xE60518F8l /* 0x020AC8 */,
  0x40D01CD0l /* 0x020ACC */,
  0x20E04060l /* 0x020AD0 */,
  0x20E81200l /* 0x020AD4 */,
  0xE6054601l /* 0x020AD8 */,
  0x48D01CD0l /* 0x020ADC */,
  0xC6004060l /* 0x020AE0 */,
  0x20D0E705l /* 0x020AE4 */,
  0xEF054070l /* 0x020AE8 */,
  0x8130B4D0l /* 0x020AEC */,
  0xE7052BE4l /* 0x020AF0 */,
  0x8130A4D0l /* 0x020AF4 */,
  0xE70533FCl /* 0x020AF8 */,
  0x8060A4D0l /* 0x020AFC */,
  0x3CD06E05l /* 0x020B00 */,
  0x406041D0l /* 0x020B04 */,
  0xE0054CE1l /* 0x020B08 */,
  0x00783CD0l /* 0x020B0C */,
  0x72E81000l /* 0x020B10 */,
  0x20D0E705l /* 0x020B14 */,
  0x80700070l /* 0x020B18 */,
  0x30D3E005l /* 0x020B1C */,
  0xE0058C60l /* 0x020B20 */,
  0x8C6028D3l /* 0x020B24 */,
  0x407034B0l /* 0x020B28 */,
  0x4CE96010l /* 0x020B2C */,
  0x20D0E705l /* 0x020B30 */,
  0x3CB00070l /* 0x020B34 */,
  0x81C04070l /* 0x020B38 */,
  0xEF079F10l /* 0x020B3C */,
  0x8340FFD0l /* 0x020B40 */,
  0xD710C1C0l /* 0x020B44 */,
  0xC710D810l /* 0x020B48 */,
  0x8350C810l /* 0x020B4C */,
  0xEF009610l /* 0x020B50 */,
  0x81407FD0l /* 0x020B54 */,
  0x40703CB0l /* 0x020B58 */,
  0xFFD02300l /* 0x020B5C */,
  0x5710C140l /* 0x020B60 */,
  0x404007D0l /* 0x020B64 */,
  0x43504810l /* 0x020B68 */,
  0x42504C10l /* 0x020B6C */,
  0xD4D0E105l /* 0x020B70 */,
  0xE5058370l /* 0x020B74 */,
  0x806020D0l /* 0x020B78 */,
  0x14D0E105l /* 0x020B7C */,
  0xE1054060l /* 0x020B80 */,
  0x40601CD0l /* 0x020B84 */,
  0x24D0E105l /* 0x020B88 */,
  0x20100070l /* 0x020B8C */,
  0x460187F8l /* 0x020B90 */,
  0xFFDFFF00l /* 0x020B94 */,
  0xC2908390l /* 0x020B98 */,
  0xC510C040l /* 0x020B9C */,
  0x9610C600l /* 0x020BA0 */,
  0x80401FD0l /* 0x020BA4 */,
  0xE105C250l /* 0x020BA8 */,
  0xC06020D0l /* 0x020BAC */,
  0x2E0596E0l /* 0x020BB0 */,
  0x407010D0l /* 0x020BB4 */,
  0x20005610l /* 0x020BB8 */,
  0x40403FD0l /* 0x020BBC */,
  0x14D02E05l /* 0x020BC0 */,
  0xC510C070l /* 0x020BC4 */,
  0xE105C150l /* 0x020BC8 */,
  0xC06020D0l /* 0x020BCC */,
  0xD8F81900l /* 0x020BD0 */,
  0x1CD0E105l /* 0x020BD4 */,
  0xFF0F4070l /* 0x020BD8 */,
  0x4040FFDFl /* 0x020BDC */,
  0x24D0E205l /* 0x020BE0 */,
  0x01300070l /* 0x020BE4 */,
  0xE005AEF4l /* 0x020BE8 */,
  0x81D01CD0l /* 0x020BEC */,
  0xE5058060l /* 0x020BF0 */,
  0x8270A0D0l /* 0x020BF4 */,
  0x14D0E105l /* 0x020BF8 */,
  0x85E18060l /* 0x020BFC */,
  0x10D0E105l /* 0x020C00 */,
  0x01300070l /* 0x020C04 */,
  0xE005B8FCl /* 0x020C08 */,
  0x82D01CD0l /* 0x020C0C */,
  0x85E18060l /* 0x020C10 */,
  0x20D0E705l /* 0x020C14 */,
  0x38B00070l /* 0x020C18 */,
  0x54000078l /* 0x020C1C */,
  0xE105D8F8l /* 0x020C20 */,
  0x007014D0l /* 0x020C24 */,
  0xA0D0E505l /* 0x020C28 */,
  0x81308270l /* 0x020C2C */,
  0xE005CCFCl /* 0x020C30 */,
  0x83D01CD0l /* 0x020C34 */,
  0x85E18060l /* 0x020C38 */,
  0x34D0E005l /* 0x020C3C */,
  0x20100070l /* 0x020C40 */,
  0x0130D8E8l /* 0x020C44 */,
  0xE005D8F4l /* 0x020C48 */,
  0x84D01CD0l /* 0x020C4C */,
  0x85E18060l /* 0x020C50 */,
  0x14D0E105l /* 0x020C54 */,
  0xE1054070l /* 0x020C58 */,
  0xC370E0D0l /* 0x020C5C */,
  0x4CE5C130l /* 0x020C60 */,
  0x3CD8E005l /* 0x020C64 */,
  0x11002078l /* 0x020C68 */,
  0xE20546E9l /* 0x020C6C */,
  0x20101870l /* 0x020C70 */,
  0xE105F3F8l /* 0x020C74 */,
  0x41704CD0l /* 0x020C78 */,
  0xEFECC130l /* 0x020C7C */,
  0x01D0FEE0l /* 0x020C80 */,
  0x1860E205l /* 0x020C84 */,
  0xE1054CE1l /* 0x020C88 */,
  0xC1304C70l /* 0x020C8C */,
  0xE205FEFCl /* 0x020C90 */,
  0x21001C70l /* 0x020C94 */,
  0x403064D0l /* 0x020C98 */,
  0x4CE1FEFCl /* 0x020C9C */,
  0xE20500D0l /* 0x020CA0 */,
  0x46011860l /* 0x020CA4 */,
  0x1C60E205l /* 0x020CA8 */,
  0xE005C600l /* 0x020CAC */,
  0x20783CD8l /* 0x020CB0 */,
  0x46E91100l /* 0x020CB4 */,
  0x03C152F1l /* 0x020CB8 */,
  0x081152F1l /* 0x020CBC */,
  0xEF0CC450l /* 0x020CC0 */,
  0x033024D0l /* 0x020CC4 */,
  0xE00518F5l /* 0x020CC8 */,
  0x85D01CD0l /* 0x020CCC */,
  0x85E18060l /* 0x020CD0 */,
  0x34D0E005l /* 0x020CD4 */,
  0x20100070l /* 0x020CD8 */,
  0xE7052BF9l /* 0x020CDC */,
  0x007020D0l /* 0x020CE0 */,
  0x407034B0l /* 0x020CE4 */,
  0x2BE94330l /* 0x020CE8 */,
  0x28D0E005l /* 0x020CEC */,
  0xE0054070l /* 0x020CF0 */,
  0x406030D0l /* 0x020CF4 */,
  0xE0054CE1l /* 0x020CF8 */,
  0xC0602CD0l /* 0x020CFC */,
  0x03C152F1l /* 0x020D00 */,
  0x081152F1l /* 0x020D04 */,
  0xE105C450l /* 0x020D08 */,
  0xC06000D0l /* 0x020D0C */,
  0x28D0E005l /* 0x020D10 */,
  0x03220072l /* 0x020D14 */,
  0x3CD02800l /* 0x020D18 */,
  0x08300070l /* 0x020D1C */,
  0x6A0543EDl /* 0x020D20 */,
  0x00703CD0l /* 0x020D24 */,
  0xE0050032l /* 0x020D28 */,
  0x006230D0l /* 0x020D2C */,
  0x2000C600l /* 0x020D30 */,
  0x6B0012D0l /* 0x020D34 */,
  0x050070D0l /* 0x020D38 */,
  0x2000C600l /* 0x020D3C */,
  0x6C0012D0l /* 0x020D40 */,
  0x050040D0l /* 0x020D44 */,
  0xF072E005l /* 0x020D48 */,
  0x5E104BC0l /* 0x020D4C */,
  0x83D04210l /* 0x020D50 */,
  0x74E98B40l /* 0x020D54 */,
  0x6DE981B0l /* 0x020D58 */,
  0x65E981B0l /* 0x020D5C */,
  0xC1707FB0l /* 0x020D60 */,
  0x23000600l /* 0x020D64 */,
  0xC1407FD0l /* 0x020D68 */,
  0x7FB07BE1l /* 0x020D6C */,
  0x0600C170l /* 0x020D70 */,
  0x2300D810l /* 0x020D74 */,
  0xC1407FD0l /* 0x020D78 */,
  0x7DB07BE1l /* 0x020D7C */,
  0x0600C170l /* 0x020D80 */,
  0x7FD02300l /* 0x020D84 */,
  0x7BE1C140l /* 0x020D88 */,
  0xC1707DB0l /* 0x020D8C */,
  0xD8100600l /* 0x020D90 */,
  0x7FD02300l /* 0x020D94 */,
  0xFFB2C140l /* 0x020D98 */,
  0x3C702800l /* 0x020D9C */,
  0x82ED0B30l /* 0x020DA0 */,
  0xF8722800l /* 0x020DA4 */,
  0xF062E005l /* 0x020DA8 */,
  0x4601C507l /* 0x020DAC */,
  0xE00500D0l /* 0x020DB0 */,
  0xE7052460l /* 0x020DB4 */,
  0x407020D0l /* 0x020DB8 */,
  0x80D074B0l /* 0x020DBC */,
  0x7CB08160l /* 0x020DC0 */,
  0xB4D0EF05l /* 0x020DC4 */,
  0x96ED8130l /* 0x020DC8 */,
  0x64D0E705l /* 0x020DCC */,
  0x01704060l /* 0x020DD0 */,
  0x70D0E005l /* 0x020DD4 */,
  0xE0050160l /* 0x020DD8 */,
  0x016068D0l /* 0x020DDC */,
  0x7CD0E005l /* 0x020DE0 */,
  0x12080178l /* 0x020DE4 */,
  0x11041004l /* 0x020DE8 */,
  0x40D00168l /* 0x020DEC */,
  0x34D0E005l /* 0x020DF0 */,
  0x4CE14060l /* 0x020DF4 */,
  0x4070EA04l /* 0x020DF8 */,
  0x09E86410l /* 0x020DFC */,
  0x12D02000l /* 0x020E00 */,
  0x60D06B00l /* 0x020E04 */,
  0x20000500l /* 0x020E08 */,
  0x6C0012D0l /* 0x020E0C */,
  0x050058D0l /* 0x020E10 */,
  0xE00580D3l /* 0x020E14 */,
  0x00702CD0l /* 0x020E18 */,
  0x40D0E105l /* 0x020E1C */,
  0x01304170l /* 0x020E20 */,
  0xE0050EECl /* 0x020E24 */,
  0x8BD01CD0l /* 0x020E28 */,
  0xFBE28060l /* 0x020E2C */,
  0x30D0E005l /* 0x020E30 */,
  0xE105C072l /* 0x020E34 */,
  0xC06208D0l /* 0x020E38 */,
  0x03C1C8F2l /* 0x020E3C */,
  0x0811C8F2l /* 0x020E40 */,
  0xE105C450l /* 0x020E44 */,
  0x40701CD0l /* 0x020E48 */,
  0x3FD3EF0Fl /* 0x020E4C */,
  0xE005CC40l /* 0x020E50 */,
  0x00783CD0l /* 0x020E54 */,
  0x2BF81E00l /* 0x020E58 */,
  0x2BE8E010l /* 0x020E5C */,
  0x1CD0E005l /* 0x020E60 */,
  0x806086D0l /* 0x020E64 */,
  0x4320FBE2l /* 0x020E68 */,
  0x14D0E105l /* 0x020E6C */,
  0xE1054060l /* 0x020E70 */,
  0x007020D0l /* 0x020E74 */,
  0x3BF40130l /* 0x020E78 */,
  0x08D0E105l /* 0x020E7C */,
  0xE0054070l /* 0x020E80 */,
  0x406030D0l /* 0x020E84 */,
  0xC8F2AAE2l /* 0x020E88 */,
  0xC8F203C1l /* 0x020E8C */,
  0xC4500811l /* 0x020E90 */,
  0x3CD0E005l /* 0x020E94 */,
  0x11000078l /* 0x020E98 */,
  0xE1054DF8l /* 0x020E9C */,
  0x407004D0l /* 0x020EA0 */,
  0x406004B0l /* 0x020EA4 */,
  0xC0603CB0l /* 0x020EA8 */,
  0xE1055FE0l /* 0x020EAC */,
  0xC06004D0l /* 0x020EB0 */,
  0xE0051108l /* 0x020EB4 */,
  0x00683CD0l /* 0x020EB8 */,
  0x1CD02307l /* 0x020EBC */,
  0x3CD0E005l /* 0x020EC0 */,
  0x9A004078l /* 0x020EC4 */,
  0x40D05FF8l /* 0x020EC8 */,
  0x3CD0AF05l /* 0x020ECC */,
  0xC8F24060l /* 0x020ED0 */,
  0x2AD06100l /* 0x020ED4 */,
  0x7FD82300l /* 0x020ED8 */,
  0xE810E140l /* 0x020EDC */,
  0x03202FF6l /* 0x020EE0 */,
  0x050041C0l /* 0x020EE4 */,
  0x7AE072E0l /* 0x020EE8 */,
  0x8DE082E0l /* 0x020EEC */,
  0xA6E09AE0l /* 0x020EF0 */,
  0x0EE2B2E1l /* 0x020EF4 */,
  0xE005BFB3l /* 0x020EF8 */,
  0x1D043C78l /* 0x020EFC */,
  0xE0051204l /* 0x020F00 */,
  0x5FE03C68l /* 0x020F04 */,
  0xE005BFB3l /* 0x020F08 */,
  0x1D083C78l /* 0x020F0C */,
  0xE0051204l /* 0x020F10 */,
  0x5FE03C68l /* 0x020F14 */,
  0x3CD0E005l /* 0x020F18 */,
  0x12080078l /* 0x020F1C */,
  0xE6050068l /* 0x020F20 */,
  0x00781CD0l /* 0x020F24 */,
  0x00681308l /* 0x020F28 */,
  0xBEB35FE0l /* 0x020F2C */,
  0x03C1C8F2l /* 0x020F30 */,
  0x0811C8F2l /* 0x020F34 */,
  0xAF05C450l /* 0x020F38 */,
  0xEF0F20D0l /* 0x020F3C */,
  0xC1407FD0l /* 0x020F40 */,
  0x5FE0C060l /* 0x020F44 */,
  0xC8F2BCB3l /* 0x020F48 */,
  0xC8F203C1l /* 0x020F4C */,
  0xC4500811l /* 0x020F50 */,
  0x7FD0EF0Fl /* 0x020F54 */,
  0xAF05C140l /* 0x020F58 */,
  0x5FE0E460l /* 0x020F5C */,
  0xC8F2B8B3l /* 0x020F60 */,
  0xC8F203C1l /* 0x020F64 */,
  0x08110811l /* 0x020F68 */,
  0x0351C810l /* 0x020F6C */,
  0xC450C8F2l /* 0x020F70 */,
  0x2F0043C0l /* 0x020F74 */,
  0xC343FFD3l /* 0x020F78 */,
  0x541043C0l /* 0x020F7C */,
  0x0FD02B00l /* 0x020F80 */,
  0xBFF40F30l /* 0x020F84 */,
  0x1CD0E005l /* 0x020F88 */,
  0x806087D0l /* 0x020F8C */,
  0xC133FBE2l /* 0x020F90 */,
  0xE700FFB3l /* 0x020F94 */,
  0x12002878l /* 0x020F98 */,
  0x03C8CBE8l /* 0x020F9C */,
  0xCBE81000l /* 0x020FA0 */,
  0x01D02001l /* 0x020FA4 */,
  0xD103C020l /* 0x020FA8 */,
  0x200AD0E8l /* 0x020FAC */,
  0xC0200AD0l /* 0x020FB0 */,
  0x28D0AF05l /* 0x020FB4 */,
  0xC8F2C060l /* 0x020FB8 */,
  0xC8F203C1l /* 0x020FBC */,
  0x08110811l /* 0x020FC0 */,
  0x0351C810l /* 0x020FC4 */,
  0xC450C8F2l /* 0x020FC8 */,
  0x7FD12F00l /* 0x020FCC */,
  0x27004341l /* 0x020FD0 */,
  0xD1035FD0l /* 0x020FD4 */,
  0x2800E5E8l /* 0x020FD8 */,
  0x45307ED0l /* 0x020FDC */,
  0xE005ECF4l /* 0x020FE0 */,
  0x88D01CD0l /* 0x020FE4 */,
  0xFBE28060l /* 0x020FE8 */,
  0x0CD02300l /* 0x020FEC */,
  0x49304072l /* 0x020FF0 */,
  0x43C04921l /* 0x020FF4 */,
  0x2F005410l /* 0x020FF8 */,
  0x40403FD0l /* 0x020FFC */,
  0x0F3003D0l /* 0x021000 */,
  0x0FD002F5l /* 0x021004 */,
  0x04F50F30l /* 0x021008 */,
  0x3FD02000l /* 0x02100C */,
  0x06F50F30l /* 0x021010 */,
  0x08E104D4l /* 0x021014 */,
  0x08E101D4l /* 0x021018 */,
  0x08E102D4l /* 0x02101C */,
  0x08E103D4l /* 0x021020 */,
  0x05C080D0l /* 0x021024 */,
  0x3FB00130l /* 0x021028 */,
  0x900050C8l /* 0x02102C */,
  0x80C011E9l /* 0x021030 */,
  0x91009F10l /* 0x021034 */,
  0x802014E9l /* 0x021038 */,
  0x18E99200l /* 0x02103C */,
  0x80200110l /* 0x021040 */,
  0x2C70E005l /* 0x021044 */,
  0x21F50230l /* 0x021048 */,
  0x1CD0E005l /* 0x02104C */,
  0x80608CD0l /* 0x021050 */,
  0x2700FBE2l /* 0x021054 */,
  0x91007478l /* 0x021058 */,
  0x05C82AE9l /* 0x02105C */,
  0x10000138l /* 0x021060 */,
  0x41B12AE9l /* 0x021064 */,
  0x27054920l /* 0x021068 */,
  0x21100870l /* 0x02106C */,
  0xE0053FF9l /* 0x021070 */,
  0x15003C78l /* 0x021074 */,
  0x05C33FF9l /* 0x021078 */,
  0x4CC31D13l /* 0x02107C */,
  0x4C231F13l /* 0x021080 */,
  0x1D130DC3l /* 0x021084 */,
  0xEF0F4C23l /* 0x021088 */,
  0x4D207E43l /* 0x02108C */,
  0x22004D21l /* 0x021090 */,
  0x827094D0l /* 0x021094 */,
  0x4DE9A010l /* 0x021098 */,
  0x24D0E605l /* 0x02109C */,
  0x1F100070l /* 0x0210A0 */,
  0x80303DB0l /* 0x0210A4 */,
  0x42208110l /* 0x0210A8 */,
  0xE1054221l /* 0x0210AC */,
  0x60137473l /* 0x0210B0 */,
  0x27055AE9l /* 0x0210B4 */,
  0x61134873l /* 0x0210B8 */,
  0x20005AF9l /* 0x0210BC */,
  0x402030D0l /* 0x0210C0 */,
  0x40224021l /* 0x0210C4 */,
  0x093000D0l /* 0x0210C8 */,
  0x40C281E5l /* 0x0210CC */,
  0x3FD06F00l /* 0x0210D0 */,
  0x200D4042l /* 0x0210D4 */,
  0x405200D0l /* 0x0210D8 */,
  0x280330D0l /* 0x0210DC */,
  0x460100D3l /* 0x0210E0 */,
  0x87D02900l /* 0x0210E4 */,
  0x3F80B6A0l /* 0x0210E8 */,
  0x3F8034A0l /* 0x0210EC */,
  0x3F8074A2l /* 0x0210F0 */,
  0x3F8034A3l /* 0x0210F4 */,
  0x00C0C600l /* 0x0210F8 */,
  0x29004601l /* 0x0210FC */,
  0xB6A08FD0l /* 0x021100 */,
  0x34A03F80l /* 0x021104 */,
  0x74A23F80l /* 0x021108 */,
  0x34A33F80l /* 0x02110C */,
  0xC6003F80l /* 0x021110 */,
  0x6F00A3E1l /* 0x021114 */,
  0x40423FD0l /* 0x021118 */,
  0x00D0200Dl /* 0x02111C */,
  0x30D04052l /* 0x021120 */,
  0x00D32802l /* 0x021124 */,
  0x29004601l /* 0x021128 */,
  0xB6A087D0l /* 0x02112C */,
  0x34A03F80l /* 0x021130 */,
  0x74A23F80l /* 0x021134 */,
  0x34A33F80l /* 0x021138 */,
  0xC6003F80l /* 0x02113C */,
  0x460100C0l /* 0x021140 */,
  0x8FD02900l /* 0x021144 */,
  0x3F80B6A0l /* 0x021148 */,
  0x3F8034A0l /* 0x02114C */,
  0x3F8074A2l /* 0x021150 */,
  0x3F8034A3l /* 0x021154 */,
  0x2000C600l /* 0x021158 */,
  0xD10328D0l /* 0x02115C */,
  0x2000A9E9l /* 0x021160 */,
  0x40202AD0l /* 0x021164 */,
  0x4C104021l /* 0x021168 */,
  0xC1C04550l /* 0x02116C */,
  0x6CD0AF05l /* 0x021170 */,
  0x5FE0C160l /* 0x021174 */,
  0xC8F2B0B3l /* 0x021178 */,
  0xC8F203C1l /* 0x02117C */,
  0xC4500811l /* 0x021180 */,
  0x2CD0E005l /* 0x021184 */,
  0x03300070l /* 0x021188 */,
  0xE005C2F5l /* 0x02118C */,
  0x89D01CD0l /* 0x021190 */,
  0xFBE28060l /* 0x021194 */,
  0x28D0E005l /* 0x021198 */,
  0xC1204070l /* 0x02119C */,
  0x3CD02800l /* 0x0211A0 */,
  0x03300070l /* 0x0211A4 */,
  0x6A05CFEDl /* 0x0211A8 */,
  0x00703CD0l /* 0x0211AC */,
  0xE005C030l /* 0x0211B0 */,
  0xC06008D0l /* 0x0211B4 */,
  0xC14043D0l /* 0x0211B8 */,
  0xC810C810l /* 0x0211BC */,
  0xE005C610l /* 0x0211C0 */,
  0x007804D0l /* 0x0211C4 */,
  0x12045404l /* 0x0211C8 */,
  0x55081304l /* 0x0211CC */,
  0x57085608l /* 0x0211D0 */,
  0xC060E050l /* 0x0211D4 */,
  0x03C1C8F2l /* 0x0211D8 */,
  0x0811C8F2l /* 0x0211DC */,
  0xE005C450l /* 0x0211E0 */,
  0x00702CD0l /* 0x0211E4 */,
  0xF1F50330l /* 0x0211E8 */,
  0x1CD0E005l /* 0x0211EC */,
  0x80608AD0l /* 0x0211F0 */,
  0xE005FBE2l /* 0x0211F4 */,
  0xC1206870l /* 0x0211F8 */,
  0x3C702800l /* 0x0211FC */,
  0xFBED0330l /* 0x021200 */,
  0x3C706A05l /* 0x021204 */,
  0xE005C030l /* 0x021208 */,
  0x43D0D460l /* 0x02120C */,
  0xC810C140l /* 0x021210 */,
  0xC610C810l /* 0x021214 */,
  0x1078E005l /* 0x021218 */,
  0x12045404l /* 0x02121C */,
  0x55081304l /* 0x021220 */,
  0x57085608l /* 0x021224 */,
  0xE005E050l /* 0x021228 */,
  0x5FE0D060l /* 0x02122C */,
  0x03C1C8F2l /* 0x021230 */,
  0x0811C8F2l /* 0x021234 */,
  0xE005C450l /* 0x021238 */,
  0xAF057070l /* 0x02123C */,
  0x83D07C60l /* 0x021240 */,
  0xE0058140l /* 0x021244 */,
  0x02510471l /* 0x021248 */,
  0x0461E005l /* 0x02124C */,
  0x1071E005l /* 0x021250 */,
  0xE0050251l /* 0x021254 */,
  0xC2B01061l /* 0x021258 */,
  0x2800C120l /* 0x02125C */,
  0x03303C70l /* 0x021260 */,
  0x6A052CEEl /* 0x021264 */,
  0xC0303C70l /* 0x021268 */,
  0xF060E005l /* 0x02126C */,
  0xE0055FE0l /* 0x021270 */,
  0x1E003C78l /* 0x021274 */,
  0xBF133BFAl /* 0x021278 */,
  0x1E04FBFAl /* 0x02127C */,
  0x3C68E005l /* 0x021280 */,
  0xE00540D8l /* 0x021284 */,
  0x0EC86468l /* 0x021288 */,
  0x4BEA1000l /* 0x02128C */,
  0x34706100l /* 0x021290 */,
  0x48FA2010l /* 0x021294 */,
  0x3C78E005l /* 0x021298 */,
  0x48FA1D00l /* 0x02129C */,
  0x49E280D3l /* 0x0212A0 */,
  0xE60588D3l /* 0x0212A4 */,
  0x61009C63l /* 0x0212A8 */,
  0x60106470l /* 0x0212AC */,
  0xE7055BFAl /* 0x0212B0 */,
  0x38B02070l /* 0x0212B4 */,
  0x54000078l /* 0x0212B8 */,
  0x540869EAl /* 0x0212BC */,
  0x40D00068l /* 0x0212C0 */,
  0x6060E505l /* 0x0212C4 */,
  0x40D05EE2l /* 0x0212C8 */,
  0x64606100l /* 0x0212CC */,
  0x34D02106l /* 0x0212D0 */,
  0x6CD02107l /* 0x0212D4 */,
  0xC1708FD0l /* 0x0212D8 */,
  0x3CB0C060l /* 0x0212DC */,
  0x81B07CB0l /* 0x0212E0 */,
  0xE10563F6l /* 0x0212E4 */,
  0xE1054070l /* 0x0212E8 */,
  0x42308470l /* 0x0212EC */,
  0xE005AAFAl /* 0x0212F0 */,
  0x10043C78l /* 0x0212F4 */,
  0xE0051104l /* 0x0212F8 */,
  0xE0053C68l /* 0x0212FC */,
  0x15003C78l /* 0x021300 */,
  0x1C0086EAl /* 0x021304 */,
  0xE50686FAl /* 0x021308 */,
  0x46011478l /* 0x02130C */,
  0xE5065304l /* 0x021310 */,
  0x23001468l /* 0x021314 */,
  0xE5063FD8l /* 0x021318 */,
  0xC6001868l /* 0x02131C */,
  0x3C78E005l /* 0x021320 */,
  0x1E081C08l /* 0x021324 */,
  0xE0051404l /* 0x021328 */,
  0xC6003C68l /* 0x02132C */,
  0x2070E705l /* 0x021330 */,
  0x40D034B0l /* 0x021334 */,
  0xE0054060l /* 0x021338 */,
  0xE7057460l /* 0x02133C */,
  0x40C020D0l /* 0x021340 */,
  0xB0B08070l /* 0x021344 */,
  0x34D0EF05l /* 0x021348 */,
  0xA1EE0230l /* 0x02134C */,
  0x24D0E705l /* 0x021350 */,
  0x816080C0l /* 0x021354 */,
  0x20D0E705l /* 0x021358 */,
  0x41704070l /* 0x02135C */,
  0x30D0E005l /* 0x021360 */,
  0xC3E24060l /* 0x021364 */,
  0x3C78E005l /* 0x021368 */,
  0xBEEA1500l /* 0x02136C */,
  0xBEFA1C00l /* 0x021370 */,
  0xE0051C04l /* 0x021374 */,
  0x46013C68l /* 0x021378 */,
  0x1478E506l /* 0x02137C */,
  0xE5065304l /* 0x021380 */,
  0x23001468l /* 0x021384 */,
  0xE5063FD8l /* 0x021388 */,
  0xC6001868l /* 0x02138C */,
  0x3CD0E005l /* 0x021390 */,
  0x10080078l /* 0x021394 */,
  0x20000068l /* 0x021398 */,
  0x6C0012D0l /* 0x02139C */,
  0x050040D0l /* 0x0213A0 */,
  0xF072E005l /* 0x0213A4 */,
  0x5E104BC0l /* 0x0213A8 */,
  0x83D04210l /* 0x0213AC */,
  0xEAEA8B40l /* 0x0213B0 */,
  0xE3EA81B0l /* 0x0213B4 */,
  0xDBEA81B0l /* 0x0213B8 */,
  0xC1707FB0l /* 0x0213BC */,
  0x23000600l /* 0x0213C0 */,
  0xC1407FD0l /* 0x0213C4 */,
  0x7FB0F1E2l /* 0x0213C8 */,
  0x0600C170l /* 0x0213CC */,
  0x2300D810l /* 0x0213D0 */,
  0xC1407FD0l /* 0x0213D4 */,
  0x7DB0F1E2l /* 0x0213D8 */,
  0x0600C170l /* 0x0213DC */,
  0x7FD02300l /* 0x0213E0 */,
  0xF1E2C140l /* 0x0213E4 */,
  0xC1707DB0l /* 0x0213E8 */,
  0xD8100600l /* 0x0213EC */,
  0x7FD02300l /* 0x0213F0 */,
  0xFFB2C140l /* 0x0213F4 */,
  0x3C702800l /* 0x0213F8 */,
  0xF8EE0B30l /* 0x0213FC */,
  0xF8722800l /* 0x021400 */,
  0xF062E005l /* 0x021404 */,
  0xE705C507l /* 0x021408 */,
  0x407020D0l /* 0x02140C */,
  0x80D074B0l /* 0x021410 */,
  0x7CB08160l /* 0x021414 */,
  0xB4D0EF05l /* 0x021418 */,
  0x08EF8130l /* 0x02141C */,
  0x64D0E705l /* 0x021420 */,
  0x01704060l /* 0x021424 */,
  0x3060E005l /* 0x021428 */,
  0x2860E005l /* 0x02142C */,
  0xE0054601l /* 0x021430 */,
  0x10043C78l /* 0x021434 */,
  0xE0051104l /* 0x021438 */,
  0xC6003C68l /* 0x02143C */,
  0xE60540D0l /* 0x021440 */,
  0xE0055C60l /* 0x021444 */,
  0xC3E27460l /* 0x021448 */,
  0x3C78E005l /* 0x02144C */,
  0x34F81100l /* 0x021450 */,
  0x20D0E705l /* 0x021454 */,
  0xB0B08070l /* 0x021458 */,
  0x34D0EF05l /* 0x02145C */,
  0x0FEC0230l /* 0x021460 */,
  0x24D0E705l /* 0x021464 */,
  0x02C080C0l /* 0x021468 */,
  0x407034B0l /* 0x02146C */,
  0x31E86010l /* 0x021470 */,
  0x407008B0l /* 0x021474 */,
  0x9F1081C0l /* 0x021478 */,
  0xFFD0EF07l /* 0x02147C */,
  0xC1C08340l /* 0x021480 */,
  0xD810D710l /* 0x021484 */,
  0xC810C710l /* 0x021488 */,
  0x96108350l /* 0x02148C */,
  0x7FD0EF00l /* 0x021490 */,
  0x3CB08140l /* 0x021494 */,
  0x23004070l /* 0x021498 */,
  0xC140FFD0l /* 0x02149C */,
  0x07D05710l /* 0x0214A0 */,
  0x48104040l /* 0x0214A4 */,
  0x4C104350l /* 0x0214A8 */,
  0xE0054250l /* 0x0214AC */,
  0x406034D0l /* 0x0214B0 */,
  0x79EA5303l /* 0x0214B4 */,
  0x2200530Bl /* 0x0214B8 */,
  0x15002C78l /* 0x0214BC */,
  0x460142F8l /* 0x0214C0 */,
  0x14D0E506l /* 0x0214C4 */,
  0x52040078l /* 0x0214C8 */,
  0xC6000068l /* 0x0214CC */,
  0x280540D0l /* 0x0214D0 */,
  0x406004D0l /* 0x0214D4 */,
  0x80D840D8l /* 0x0214D8 */,
  0x20D02800l /* 0x0214DC */,
  0x64058073l /* 0x0214E0 */,
  0x417058D0l /* 0x0214E4 */,
  0x20007AB0l /* 0x0214E8 */,
  0x8E208CD0l /* 0x0214EC */,
  0xC2734601l /* 0x0214F0 */,
  0xC600C163l /* 0x0214F4 */,
  0x20007CB0l /* 0x0214F8 */,
  0x8E2090D0l /* 0x0214FC */,
  0xC2734601l /* 0x021500 */,
  0xC600C163l /* 0x021504 */,
  0x94D02000l /* 0x021508 */,
  0x46018E20l /* 0x02150C */,
  0x0600C273l /* 0x021510 */,
  0x3F803D94l /* 0x021514 */,
  0xE013C600l /* 0x021518 */,
  0x20146CF8l /* 0x02151C */,
  0x90046CF8l /* 0x021520 */,
  0xA0D02F00l /* 0x021524 */,
  0x46018E20l /* 0x021528 */,
  0x0600C273l /* 0x02152C */,
  0x3F803D94l /* 0x021530 */,
  0xE013C600l /* 0x021534 */,
  0x20147AF8l /* 0x021538 */,
  0x91047AF8l /* 0x02153C */,
  0xA4D02F00l /* 0x021540 */,
  0x46018E20l /* 0x021544 */,
  0x0600C273l /* 0x021548 */,
  0x3F803D94l /* 0x02154C */,
  0xE013C600l /* 0x021550 */,
  0x201488F8l /* 0x021554 */,
  0x920488F8l /* 0x021558 */,
  0xA8D02F00l /* 0x02155C */,
  0x46018E20l /* 0x021560 */,
  0x0600C273l /* 0x021564 */,
  0x3F803D94l /* 0x021568 */,
  0xE013C600l /* 0x02156C */,
  0x201496F8l /* 0x021570 */,
  0x930496F8l /* 0x021574 */,
  0xA0D02100l /* 0x021578 */,
  0xBDB08E20l /* 0x02157C */,
  0x83D0C273l /* 0x021580 */,
  0xE113C243l /* 0x021584 */,
  0xE105A1FCl /* 0x021588 */,
  0xE105F473l /* 0x02158C */,
  0xC413F463l /* 0x021590 */,
  0x7EB04F58l /* 0x021594 */,
  0xE2054168l /* 0x021598 */,
  0x7AB06060l /* 0x02159C */,
  0x94D02000l /* 0x0215A0 */,
  0x46018E20l /* 0x0215A4 */,
  0xC163C273l /* 0x0215A8 */,
  0x7CB0C600l /* 0x0215AC */,
  0xACD02F00l /* 0x0215B0 */,
  0x46018E20l /* 0x0215B4 */,
  0xC163C273l /* 0x0215B8 */,
  0x7CB0C600l /* 0x0215BC */,
  0x80D02000l /* 0x0215C0 */,
  0x46018E20l /* 0x0215C4 */,
  0xC163C273l /* 0x0215C8 */,
  0x6405C600l /* 0x0215CC */,
  0x41705CD0l /* 0x0215D0 */,
  0x60007EB0l /* 0x0215D4 */,
  0x8E2080D0l /* 0x0215D8 */,
  0xC2734601l /* 0x0215DC */,
  0xC600C163l /* 0x0215E0 */,
  0x60007CB0l /* 0x0215E4 */,
  0x8E2084D0l /* 0x0215E8 */,
  0xC2734601l /* 0x0215EC */,
  0xC600C163l /* 0x0215F0 */,
  0x20702800l /* 0x0215F4 */,
  0x41D06000l /* 0x0215F8 */,
  0x40700120l /* 0x0215FC */,
  0x80703EB0l /* 0x021600 */,
  0x3FD05610l /* 0x021604 */,
  0x86104040l /* 0x021608 */,
  0xFF0F8150l /* 0x02160C */,
  0x8040FFDFl /* 0x021610 */,
  0x9060E105l /* 0x021614 */,
  0x20702800l /* 0x021618 */,
  0x45D06000l /* 0x02161C */,
  0x40700120l /* 0x021620 */,
  0x80703EB0l /* 0x021624 */,
  0x3FD05610l /* 0x021628 */,
  0x86104040l /* 0x02162C */,
  0xFF0F8150l /* 0x021630 */,
  0x8040FFDFl /* 0x021634 */,
  0xA460E205l /* 0x021638 */,
  0x38706100l /* 0x02163C */,
  0x28EB2010l /* 0x021640 */,
  0x20D02800l /* 0x021644 */,
  0x21004070l /* 0x021648 */,
  0x4220A0D0l /* 0x02164C */,
  0x0CD02307l /* 0x021650 */,
  0x02D14060l /* 0x021654 */,
  0x43D0FEF1l /* 0x021658 */,
  0xE105C140l /* 0x02165C */,
  0x27052C70l /* 0x021660 */,
  0xA0108870l /* 0x021664 */,
  0x20101AE9l /* 0x021668 */,
  0xE01016F9l /* 0x02166C */,
  0x25071AE9l /* 0x021670 */,
  0x1AE12460l /* 0x021674 */,
  0x1AF9E010l /* 0x021678 */,
  0xE4602507l /* 0x02167C */,
  0x27E9E110l /* 0x021680 */,
  0x21EBE010l /* 0x021684 */,
  0xE00527E1l /* 0x021688 */,
  0x00783CD0l /* 0x02168C */,
  0x1A041504l /* 0x021690 */,
  0x00681708l /* 0x021694 */,
  0xE00579E2l /* 0x021698 */,
  0x00783CD0l /* 0x02169C */,
  0x1A041504l /* 0x0216A0 */,
  0x18081708l /* 0x0216A4 */,
  0x00681908l /* 0x0216A8 */,
  0x220741D0l /* 0x0216AC */,
  0x02D17060l /* 0x0216B0 */,
  0x43C2FEF1l /* 0x0216B4 */,
  0xFEF102D1l /* 0x0216B8 */,
  0xD6104612l /* 0x0216BC */,
  0x3FD02000l /* 0x0216C0 */,
  0xC950C040l /* 0x0216C4 */,
  0xD0602307l /* 0x0216C8 */,
  0xFEF102D1l /* 0x0216CC */,
  0x02D143C2l /* 0x0216D0 */,
  0x4612FEF1l /* 0x0216D4 */,
  0x2000D610l /* 0x0216D8 */,
  0xC0403FD0l /* 0x0216DC */,
  0x2307C950l /* 0x0216E0 */,
  0x02D1D460l /* 0x0216E4 */,
  0x43C2FEF1l /* 0x0216E8 */,
  0xFEF102D1l /* 0x0216EC */,
  0x3FD8EF0Fl /* 0x0216F0 */,
  0x5DF9190Cl /* 0x0216F4 */,
  0x5DF9130Cl /* 0x0216F8 */,
  0x3CD0E005l /* 0x0216FC */,
  0x19040078l /* 0x021700 */,
  0x46120068l /* 0x021704 */,
  0x2000D610l /* 0x021708 */,
  0xC0403FD0l /* 0x02170C */,
  0x2307C950l /* 0x021710 */,
  0x02D1D860l /* 0x021714 */,
  0x2307FEF1l /* 0x021718 */,
  0x03C3DC60l /* 0x02171C */,
  0x43D01413l /* 0x021720 */,
  0x20130143l /* 0x021724 */,
  0xE20574F9l /* 0x021728 */,
  0x00782070l /* 0x02172C */,
  0x00681408l /* 0x021730 */,
  0x0CD02307l /* 0x021734 */,
  0x7FB04070l /* 0x021738 */,
  0x01D14060l /* 0x02173C */,
  0xE110FEF1l /* 0x021740 */,
  0x200021E7l /* 0x021744 */,
  0x211364D0l /* 0x021748 */,
  0x52D088E9l /* 0x02174C */,
  0x88E92213l /* 0x021750 */,
  0x23134CD0l /* 0x021754 */,
  0x21E388E9l /* 0x021758 */,
  0x21E74330l /* 0x02175C */,
  0x20D02307l /* 0x021760 */,
  0xE010C060l /* 0x021764 */,
  0xE20594F9l /* 0x021768 */,
  0x00782070l /* 0x02176C */,
  0x00681408l /* 0x021770 */,
  0xFEF101D1l /* 0x021774 */,
  0xE4602307l /* 0x021778 */,
  0x0CD02307l /* 0x02177C */,
  0x7FB04070l /* 0x021780 */,
  0x02D14060l /* 0x021784 */,
  0x2307FEF1l /* 0x021788 */,
  0x02D1E860l /* 0x02178C */,
  0x2307FEF1l /* 0x021790 */,
  0x02D1EC60l /* 0x021794 */,
  0x2307FEF1l /* 0x021798 */,
  0x02D1F060l /* 0x02179C */,
  0x2407FEF1l /* 0x0217A0 */,
  0x02D1C460l /* 0x0217A4 */,
  0x2407FEF1l /* 0x0217A8 */,
  0x02D1C860l /* 0x0217AC */,
  0x2307FEF1l /* 0x0217B0 */,
  0x02D1F460l /* 0x0217B4 */,
  0x2307FEF1l /* 0x0217B8 */,
  0x02D1F860l /* 0x0217BC */,
  0x2407FEF1l /* 0x0217C0 */,
  0x02D1CC60l /* 0x0217C4 */,
  0x2407FEF1l /* 0x0217C8 */,
  0x02D1D060l /* 0x0217CC */,
  0x2307FEF1l /* 0x0217D0 */,
  0x02D1FC60l /* 0x0217D4 */,
  0x2407FEF1l /* 0x0217D8 */,
  0x02D1C060l /* 0x0217DC */,
  0x2407FEF1l /* 0x0217E0 */,
  0x02D1D460l /* 0x0217E4 */,
  0x2407FEF1l /* 0x0217E8 */,
  0x2000D860l /* 0x0217EC */,
  0x2113A4D2l /* 0x0217F0 */,
  0x92D2DCE9l /* 0x0217F4 */,
  0xDCE92213l /* 0x0217F8 */,
  0x23138CD2l /* 0x0217FC */,
  0x21E3DCE9l /* 0x021800 */,
  0x9C622407l /* 0x021804 */,
  0x01B30AC0l /* 0x021808 */,
  0x8022E3E9l /* 0x02180C */,
  0xA304DFE1l /* 0x021810 */,
  0x40C314D0l /* 0x021814 */,
  0xFEF103D1l /* 0x021818 */,
  0x03D1CD60l /* 0x02181C */,
  0x7CB3FEF1l /* 0x021820 */,
  0x02D1CD60l /* 0x021824 */,
  0x7CB3FEF1l /* 0x021828 */,
  0x02D1CD60l /* 0x02182C */,
  0x7CB3FEF1l /* 0x021830 */,
  0x2307CD60l /* 0x021834 */,
  0x40700CD0l /* 0x021838 */,
  0x406078B0l /* 0x02183C */,
  0x81B27CB3l /* 0x021840 */,
  0x79E2E6F9l /* 0x021844 */,
  0x0CD02307l /* 0x021848 */,
  0x45C04071l /* 0x02184C */,
  0x42105E10l /* 0x021850 */,
  0x854083D0l /* 0x021854 */,
  0x823184D1l /* 0x021858 */,
  0x34EA82B1l /* 0x02185C */,
  0x53EA81B1l /* 0x021860 */,
  0x62EA81B1l /* 0x021864 */,
  0x19FA2111l /* 0x021868 */,
  0x23000170l /* 0x02186C */,
  0xC040FFD0l /* 0x021870 */,
  0x23077FB1l /* 0x021874 */,
  0x40610CD0l /* 0x021878 */,
  0xC170C507l /* 0x02187C */,
  0x3FD02300l /* 0x021880 */,
  0x04C0C040l /* 0x021884 */,
  0x031001B0l /* 0x021888 */,
  0xC01001B0l /* 0x02188C */,
  0x4421C110l /* 0x021890 */,
  0x0CD02307l /* 0x021894 */,
  0x45C04061l /* 0x021898 */,
  0x42105E10l /* 0x02189C */,
  0x41707DB0l /* 0x0218A0 */,
  0x30D00600l /* 0x0218A4 */,
  0x031101B1l /* 0x0218A8 */,
  0x40100420l /* 0x0218AC */,
  0xC507C150l /* 0x0218B0 */,
  0xEF0F0170l /* 0x0218B4 */,
  0xC040FFD0l /* 0x0218B8 */,
  0x42EE2211l /* 0x0218BC */,
  0x3DFA2111l /* 0x0218C0 */,
  0x4421D810l /* 0x0218C4 */,
  0x0CD02307l /* 0x0218C8 */,
  0xC5074061l /* 0x0218CC */,
  0x4421C810l /* 0x0218D0 */,
  0x0CD02307l /* 0x0218D4 */,
  0x45C04061l /* 0x0218D8 */,
  0x42105E10l /* 0x0218DC */,
  0x41707DB0l /* 0x0218E0 */,
  0x23000600l /* 0x0218E4 */,
  0x58103FD0l /* 0x0218E8 */,
  0xC1504040l /* 0x0218EC */,
  0x4421C507l /* 0x0218F0 */,
  0x0CD02307l /* 0x0218F4 */,
  0xC1704061l /* 0x0218F8 */,
  0x031158D0l /* 0x0218FC */,
  0x61EA4430l /* 0x021900 */,
  0x013000D0l /* 0x021904 */,
  0xC0103FB0l /* 0x021908 */,
  0xC507DF10l /* 0x02190C */,
  0x23074421l /* 0x021910 */,
  0x40610CD0l /* 0x021914 */,
  0xC1707DB0l /* 0x021918 */,
  0x23110600l /* 0x02191C */,
  0x22116FEAl /* 0x021920 */,
  0xD8106EEAl /* 0x021924 */,
  0xC810C507l /* 0x021928 */,
  0x417042B0l /* 0x02192C */,
  0x58100600l /* 0x021930 */,
  0x3FD02300l /* 0x021934 */,
  0xC1504040l /* 0x021938 */,
  0xE005C507l /* 0x02193C */,
  0x00783CD0l /* 0x021940 */,
  0x21EB1500l /* 0x021944 */,
  0x48702300l /* 0x021948 */,
  0x84FA6010l /* 0x02194C */,
  0x4870A205l /* 0x021950 */,
  0x93FA6210l /* 0x021954 */,
  0x1C702307l /* 0x021958 */,
  0x47D01810l /* 0x02195C */,
  0x27100140l /* 0x021960 */,
  0x20108FEAl /* 0x021964 */,
  0x41D028FBl /* 0x021968 */,
  0x70602207l /* 0x02196C */,
  0x22001CE3l /* 0x021970 */,
  0x60104070l /* 0x021974 */,
  0x2200EEFAl /* 0x021978 */,
  0x407004D0l /* 0x02197C */,
  0xBFFA6110l /* 0x021980 */,
  0x1CD02307l /* 0x021984 */,
  0x43C0C070l /* 0x021988 */,
  0x07D05810l /* 0x02198C */,
  0x64104040l /* 0x021990 */,
  0x2207AAE6l /* 0x021994 */,
  0x41D030D0l /* 0x021998 */,
  0x1CE34060l /* 0x02199C */,
  0x5C1043C0l /* 0x0219A0 */,
  0x404007D0l /* 0x0219A4 */,
  0xB5E66410l /* 0x0219A8 */,
  0x30D02207l /* 0x0219AC */,
  0x406042D0l /* 0x0219B0 */,
  0x43C01CE3l /* 0x0219B4 */,
  0x404007D0l /* 0x0219B8 */,
  0x28E76410l /* 0x0219BC */,
  0x30D02207l /* 0x0219C0 */,
  0x406043D0l /* 0x0219C4 */,
  0x23071CE3l /* 0x0219C8 */,
  0xC0701CD0l /* 0x0219CC */,
  0x581043C0l /* 0x0219D0 */,
  0x404007D0l /* 0x0219D4 */,
  0xD1FE6110l /* 0x0219D8 */,
  0xD1EA6410l /* 0x0219DC */,
  0xD1EA6510l /* 0x0219E0 */,
  0x30D02207l /* 0x0219E4 */,
  0x406041D0l /* 0x0219E8 */,
  0x43C01CE3l /* 0x0219EC */,
  0x07D05C10l /* 0x0219F0 */,
  0x61104040l /* 0x0219F4 */,
  0x6410E0FEl /* 0x0219F8 */,
  0x6510E0EAl /* 0x0219FC */,
  0x2207E0EAl /* 0x021A00 */,
  0x42D030D0l /* 0x021A04 */,
  0x1CE34060l /* 0x021A08 */,
  0x07D043C0l /* 0x021A0C */,
  0x61104040l /* 0x021A10 */,
  0x641028FFl /* 0x021A14 */,
  0x651028EBl /* 0x021A18 */,
  0x220728EBl /* 0x021A1C */,
  0x43D030D0l /* 0x021A20 */,
  0x1CE34060l /* 0x021A24 */,
  0x1CD02307l /* 0x021A28 */,
  0x43C0C070l /* 0x021A2C */,
  0x07D05810l /* 0x021A30 */,
  0x60104040l /* 0x021A34 */,
  0x221000EBl /* 0x021A38 */,
  0x241000EBl /* 0x021A3C */,
  0x220700EBl /* 0x021A40 */,
  0x41D030D0l /* 0x021A44 */,
  0x1CE34060l /* 0x021A48 */,
  0x5C1043C0l /* 0x021A4C */,
  0x404007D0l /* 0x021A50 */,
  0x0FEB6010l /* 0x021A54 */,
  0x0FEB2210l /* 0x021A58 */,
  0x0FEB2410l /* 0x021A5C */,
  0x30D02207l /* 0x021A60 */,
  0x406042D0l /* 0x021A64 */,
  0x43C01CE3l /* 0x021A68 */,
  0x404007D0l /* 0x021A6C */,
  0x28EB6010l /* 0x021A70 */,
  0x28EB2210l /* 0x021A74 */,
  0x28EB2410l /* 0x021A78 */,
  0x30D02207l /* 0x021A7C */,
  0x406043D0l /* 0x021A80 */,
  0x12D02000l /* 0x021A84 */,
  0x50D06C00l /* 0x021A88 */,
  0xE0050500l /* 0x021A8C */,
  0x00783CD0l /* 0x021A90 */,
  0x1A081508l /* 0x021A94 */,
  0x00681908l /* 0x021A98 */,
  0x50D0A100l /* 0x021A9C */,
  0x600012D0l /* 0x021AA0 */,
  0x0500C0D7l /* 0x021AA4 */,
  0x24E85303l /* 0x021AA8 */,
  0xFFD1EF0Fl /* 0x021AAC */,
  0xA8732800l /* 0x021AB0 */,
  0x0CD12600l /* 0x021AB4 */,
  0x04700E21l /* 0x021AB8 */,
  0x46013CB1l /* 0x021ABC */,
  0x06004470l /* 0x021AC0 */,
  0x47407D90l /* 0x021AC4 */,
  0x80C0C600l /* 0x021AC8 */,
  0xFFD02300l /* 0x021ACC */,
  0x90108340l /* 0x021AD0 */,
  0xFFD0EF03l /* 0x021AD4 */,
  0x42500340l /* 0x021AD8 */,
  0x68D16200l /* 0x021ADC */,
  0x46017EB1l /* 0x021AE0 */,
  0x7CA00600l /* 0x021AE4 */,
  0x3F803DA0l /* 0x021AE8 */,
  0xC6004560l /* 0x021AEC */,
  0x12D02000l /* 0x021AF0 */,
  0x78D06B00l /* 0x021AF4 */,
  0x00000500l /* 0x021AF8 */,
  0x64702605l /* 0x021AFC */,
  0xC9FB6210l /* 0x021B00 */,
  0x2870EB04l /* 0x021B04 */,
  0xC9FB2010l /* 0x021B08 */,
  0x74702805l /* 0x021B0C */,
  0xC7EF41B0l /* 0x021B10 */,
  0x601540D0l /* 0x021B14 */,
  0xC1D0C7FBl /* 0x021B18 */,
  0xD4602905l /* 0x021B1C */,
  0x3C792605l /* 0x021B20 */,
  0x26051706l /* 0x021B24 */,
  0x28053C69l /* 0x021B28 */,
  0x61057460l /* 0x021B2C */,
  0x20191879l /* 0x021B30 */,
  0x2119D7EBl /* 0x021B34 */,
  0xA000D4EFl /* 0x021B38 */,
  0x37A001D0l /* 0x021B3C */,
  0xD7E33F80l /* 0x021B40 */,
  0x610501B9l /* 0x021B44 */,
  0xE0001869l /* 0x021B48 */,
  0xD3E148D0l /* 0x021B4C */,
  0xF8732005l /* 0x021B50 */,
  0x3C732005l /* 0x021B54 */,
  0xA20501D4l /* 0x021B58 */,
  0x2B000071l /* 0x021B5C */,
  0x053140D1l /* 0x021B60 */,
  0x02D415F4l /* 0x021B64 */,
  0xA205DF13l /* 0x021B68 */,
  0x24000471l /* 0x021B6C */,
  0x05316CD1l /* 0x021B70 */,
  0x03D415F4l /* 0x021B74 */,
  0x40D31F13l /* 0x021B78 */,
  0x1C110CC1l /* 0x021B7C */,
  0x1FE82011l /* 0x021B80 */,
  0x80D1AD00l /* 0x021B84 */,
  0x01B14623l /* 0x021B88 */,
  0x0CC11CECl /* 0x021B8C */,
  0x06418FD1l /* 0x021B90 */,
  0x42134423l /* 0x021B94 */,
  0x0CC180D3l /* 0x021B98 */,
  0x20111B11l /* 0x021B9C */,
  0xAD002EE8l /* 0x021BA0 */,
  0x862380D1l /* 0x021BA4 */,
  0x2BEC01B1l /* 0x021BA8 */,
  0x9FD10CC1l /* 0x021BAC */,
  0x1F110641l /* 0x021BB0 */,
  0x82138423l /* 0x021BB4 */,
  0x2300C213l /* 0x021BB8 */,
  0x20110871l /* 0x021BBC */,
  0xA2053BF8l /* 0x021BC0 */,
  0x06D20871l /* 0x021BC4 */,
  0x3FFC2211l /* 0x021BC8 */,
  0x220000D2l /* 0x021BCC */,
  0x21110071l /* 0x021BD0 */,
  0x3DB244E8l /* 0x021BD4 */,
  0x04712200l /* 0x021BD8 */,
  0x4CE82011l /* 0x021BDC */,
  0x21113FB2l /* 0x021BE0 */,
  0x3FB24CE8l /* 0x021BE4 */,
  0x241240D2l /* 0x021BE8 */,
  0x251251E8l /* 0x021BEC */,
  0x7CB252F8l /* 0x021BF0 */,
  0xE8712005l /* 0x021BF4 */,
  0x5BE8E111l /* 0x021BF8 */,
  0x5AF8E211l /* 0x021BFC */,
  0x5BE07FB2l /* 0x021C00 */,
  0x21147EB2l /* 0x021C04 */,
  0x7FB25EE8l /* 0x021C08 */,
  0x20D12105l /* 0x021C0C */,
  0x421149C1l /* 0x021C10 */,
  0x85C14421l /* 0x021C14 */,
  0xE11180D2l /* 0x021C18 */,
  0xE21185E8l /* 0x021C1C */,
  0xBCB277F8l /* 0x021C20 */,
  0x85F82114l /* 0x021C24 */,
  0xED04B4B2l /* 0x021C28 */,
  0x23112471l /* 0x021C2C */,
  0x620575F8l /* 0x021C30 */,
  0x20112471l /* 0x021C34 */,
  0xBCB288E8l /* 0x021C38 */,
  0xB8B288E0l /* 0x021C3C */,
  0x85F82114l /* 0x021C40 */,
  0xED04B0B2l /* 0x021C44 */,
  0x23112471l /* 0x021C48 */,
  0x620583F8l /* 0x021C4C */,
  0x20112471l /* 0x021C50 */,
  0xBCB288E8l /* 0x021C54 */,
  0x231488E0l /* 0x021C58 */,
  0xBCB288F8l /* 0x021C5C */,
  0x00D12205l /* 0x021C60 */,
  0x32008422l /* 0x021C64 */,
  0x38A001D0l /* 0x021C68 */,
  0x20053F80l /* 0x021C6C */,
  0x2105EC61l /* 0x021C70 */,
  0x21058863l /* 0x021C74 */,
  0x21054463l /* 0x021C78 */,
  0x2105CC63l /* 0x021C7C */,
  0x21059C62l /* 0x021C80 */,
  0x32009861l /* 0x021C84 */,
  0x38A000D0l /* 0x021C88 */,
  0xAE003F80l /* 0x021C8C */,
  0x12D040D0l /* 0x021C90 */,
  0xCAD76000l /* 0x021C94 */,
  0x00000500l /* 0x021C98 */,
  0x20706505l /* 0x021C9C */,
  0xDCEB2010l /* 0x021CA0 */,
  0x2C706505l /* 0x021CA4 */,
  0xDCFB2010l /* 0x021CA8 */,
  0x0070E705l /* 0x021CAC */,
  0xD2FB2010l /* 0x021CB0 */,
  0xF0706605l /* 0x021CB4 */,
  0x20110371l /* 0x021CB8 */,
  0xE705D2EBl /* 0x021CBC */,
  0x40D00061l /* 0x021CC0 */,
  0xFCB04360l /* 0x021CC4 */,
  0xE6054370l /* 0x021CC8 */,
  0xFCB07C60l /* 0x021CCC */,
  0x20D96705l /* 0x021CD0 */,
  0xD0FB130El /* 0x021CD4 */,
  0xF8D06605l /* 0x021CD8 */,
  0xF0606605l /* 0x021CDC */,
  0x24716505l /* 0x021CE0 */,
  0x650500D0l /* 0x021CE4 */,
  0xE7052460l /* 0x021CE8 */,
  0x04300470l /* 0x021CEC */,
  0xDFF3DCEBl /* 0x021CF0 */,
  0x58D06B00l /* 0x021CF4 */,
  0x2011D3E1l /* 0x021CF8 */,
  0x6705F0EBl /* 0x021CFC */,
  0x670530D9l /* 0x021D00 */,
  0x017060D0l /* 0x021D04 */,
  0xEFEB2010l /* 0x021D08 */,
  0x803084C0l /* 0x021D0C */,
  0x110EF0EBl /* 0x021D10 */,
  0x7CB0F0EBl /* 0x021D14 */,
  0x0161E5E3l /* 0x021D18 */,
  0x0000C507l /* 0x021D1C */,
  0x3CD0E005l /* 0x021D20 */,
  0x15000078l /* 0x021D24 */,
  0x140055E9l /* 0x021D28 */,
  0x1B0055E9l /* 0x021D2C */,
  0x620555F9l /* 0x021D30 */,
  0x407008D0l /* 0x021D34 */,
  0x55F96010l /* 0x021D38 */,
  0x24D0E105l /* 0x021D3C */,
  0x20100070l /* 0x021D40 */,
  0x460123F8l /* 0x021D44 */,
  0x3F808390l /* 0x021D48 */,
  0x3F80C290l /* 0x021D4C */,
  0xC510C600l /* 0x021D50 */,
  0xFFDFFF00l /* 0x021D54 */,
  0x9610C040l /* 0x021D58 */,
  0x1FD02000l /* 0x021D5C */,
  0xC2508040l /* 0x021D60 */,
  0x2E052FE0l /* 0x021D64 */,
  0x407010D0l /* 0x021D68 */,
  0x20005610l /* 0x021D6C */,
  0x40403FD0l /* 0x021D70 */,
  0x14D02E05l /* 0x021D74 */,
  0xC510C070l /* 0x021D78 */,
  0xE005C150l /* 0x021D7C */,
  0x00783CD0l /* 0x021D80 */,
  0x3EF81900l /* 0x021D84 */,
  0x18D02307l /* 0x021D88 */,
  0x43304070l /* 0x021D8C */,
  0x23073EFCl /* 0x021D90 */,
  0x407014D0l /* 0x021D94 */,
  0x55ED4330l /* 0x021D98 */,
  0x3CD0E005l /* 0x021D9C */,
  0x19000078l /* 0x021DA0 */,
  0x1B0055F9l /* 0x021DA4 */,
  0xE00555F9l /* 0x021DA8 */,
  0x00783CD0l /* 0x021DAC */,
  0x55E91500l /* 0x021DB0 */,
  0x28D02307l /* 0x021DB4 */,
  0x3FD04075l /* 0x021DB8 */,
  0x55E94045l /* 0x021DBC */,
  0x55307FD0l /* 0x021DC0 */,
  0x220756F8l /* 0x021DC4 */,
  0x40752CD0l /* 0x021DC8 */,
  0xA41583D5l /* 0x021DCC */,
  0x22075DF8l /* 0x021DD0 */,
  0x83D56C75l /* 0x021DD4 */,
  0x200088E0l /* 0x021DD8 */,
  0x553064D0l /* 0x021DDC */,
  0x210088F4l /* 0x021DE0 */,
  0x413540D0l /* 0x021DE4 */,
  0x22076CF8l /* 0x021DE8 */,
  0x60157475l /* 0x021DEC */,
  0x220788F8l /* 0x021DF0 */,
  0x88E06C75l /* 0x021DF4 */,
  0x75F86115l /* 0x021DF8 */,
  0x78752207l /* 0x021DFC */,
  0x88F86015l /* 0x021E00 */,
  0x6C752207l /* 0x021E04 */,
  0x621588E0l /* 0x021E08 */,
  0x22077EF8l /* 0x021E0C */,
  0x60157C75l /* 0x021E10 */,
  0x220788F8l /* 0x021E14 */,
  0x88E06C75l /* 0x021E18 */,
  0x87F86315l /* 0x021E1C */,
  0x40752307l /* 0x021E20 */,
  0x88F86015l /* 0x021E24 */,
  0x6C752207l /* 0x021E28 */,
  0x41D588E0l /* 0x021E2C */,
  0x6C652207l /* 0x021E30 */,
  0x7C656100l /* 0x021E34 */,
  0x70702207l /* 0x021E38 */,
  0x611080D0l /* 0x021E3C */,
  0x240797E8l /* 0x021E40 */,
  0x84109C70l /* 0x021E44 */,
  0x97E86210l /* 0x021E48 */,
  0xA3048110l /* 0x021E4C */,
  0x022014D0l /* 0x021E50 */,
  0x41B595C2l /* 0x021E54 */,
  0x15204415l /* 0x021E58 */,
  0xC4C00071l /* 0x021E5C */,
  0xD210D810l /* 0x021E60 */,
  0xC14043D0l /* 0x021E64 */,
  0x941184C1l /* 0x021E68 */,
  0x2F00C4C1l /* 0x021E6C */,
  0xC1417FD0l /* 0x021E70 */,
  0x3CB08141l /* 0x021E74 */,
  0x3CB04071l /* 0x021E78 */,
  0x74D02207l /* 0x021E7C */,
  0xA0108070l /* 0x021E80 */,
  0x8AC0B4F8l /* 0x021E84 */,
  0x81609810l /* 0x021E88 */,
  0x80707CB0l /* 0x021E8C */,
  0xBBF8A010l /* 0x021E90 */,
  0x20008AC0l /* 0x021E94 */,
  0xA0403FD8l /* 0x021E98 */,
  0x3CB08160l /* 0x021E9C */,
  0x80707CB0l /* 0x021EA0 */,
  0xC5F8A010l /* 0x021EA4 */,
  0x98108AC0l /* 0x021EA8 */,
  0x7CB08160l /* 0x021EAC */,
  0xA0108070l /* 0x021EB0 */,
  0x8AC0CCF8l /* 0x021EB4 */,
  0x3FD82000l /* 0x021EB8 */,
  0x8160A040l /* 0x021EBC */,
  0xDEE8A515l /* 0x021EC0 */,
  0x581045C0l /* 0x021EC4 */,
  0x83D05210l /* 0x021EC8 */,
  0x61104240l /* 0x021ECC */,
  0xA115F2E8l /* 0x021ED0 */,
  0xA315DEE8l /* 0x021ED4 */,
  0x50E1F2E8l /* 0x021ED8 */,
  0x3CD0E005l /* 0x021EDC */,
  0x50000078l /* 0x021EE0 */,
  0x01D1E5E8l /* 0x021EE4 */,
  0x1611E9E0l /* 0x021EE8 */,
  0x43D01411l /* 0x021EEC */,
  0x23070141l /* 0x021EF0 */,
  0x01B12CD0l /* 0x021EF4 */,
  0x04200311l /* 0x021EF8 */,
  0x3CB0C070l /* 0x021EFC */,
  0x0DE1C072l /* 0x021F00 */,
  0x14D0E506l /* 0x021F04 */,
  0x00784601l /* 0x021F08 */,
  0x00685304l /* 0x021F0C */,
  0x18D0E506l /* 0x021F10 */,
  0xC6008062l /* 0x021F14 */,
  0x14111611l /* 0x021F18 */,
  0x014143D0l /* 0x021F1C */,
  0x04D02407l /* 0x021F20 */,
  0x031101B1l /* 0x021F24 */,
  0xC0700420l /* 0x021F28 */,
  0xC0723CB0l /* 0x021F2C */,
  0x3CD0E005l /* 0x021F30 */,
  0x1B040078l /* 0x021F34 */,
  0x05C20068l /* 0x021F38 */,
  0x45C21412l /* 0x021F3C */,
  0x3FD02F00l /* 0x021F40 */,
  0xD1034042l /* 0x021F44 */,
  0xB6B117E9l /* 0x021F48 */,
  0x2002F6B1l /* 0x021F4C */,
  0x415240D0l /* 0x021F50 */,
  0x20D0AF05l /* 0x021F54 */,
  0x06000073l /* 0x021F58 */,
  0x40733CB0l /* 0x021F5C */,
  0xFFB10600l /* 0x021F60 */,
  0x7FD0EF0Fl /* 0x021F64 */,
  0xBFD0EF00l /* 0x021F68 */,
  0x65004601l /* 0x021F6C */,
  0x36A00AD0l /* 0x021F70 */,
  0x34A23F80l /* 0x021F74 */,
  0xB4A174A2l /* 0x021F78 */,
  0xF4A2F4A0l /* 0x021F7C */,
  0x34A3F4A1l /* 0x021F80 */,
  0xB4A074A3l /* 0x021F84 */,
  0x3F8074A0l /* 0x021F88 */,
  0xA204C600l /* 0x021F8C */,
  0xE500BCD0l /* 0x021F90 */,
  0x46010AD0l /* 0x021F94 */,
  0x3F8036A0l /* 0x021F98 */,
  0x026D0B04l /* 0x021F9C */,
  0xC6000600l /* 0x021FA0 */,
  0x7CD0A204l /* 0x021FA4 */,
  0x3CD0AF05l /* 0x021FA8 */,
  0x54E14060l /* 0x021FAC */,
  0x000000C0l /* 0x021FB0 */,
  0x00C000C0l /* 0x021FB4 */,
  0x00C000C0l /* 0x021FB8 */,
  0x00C000C0l /* 0x021FBC */,
  0xAF0540D0l /* 0x021FC0 */,
  0x40603CD0l /* 0x021FC4 */,
  0xA10055E1l /* 0x021FC8 */,
  0x12D050D0l /* 0x021FCC */,
  0xC0D76000l /* 0x021FD0 */,
  0x00000500l /* 0x021FD4 */,
  0x0010D002l /* 0x021FD8 */,
  0x00800000l /* 0x021FDC */,
  0x00000000l /* 0x021FE0 */,
  0x00FE0100l /* 0x021FE4 */,
  0x00000000l /* 0x021FE8 */,
  0xDF110000l /* 0x021FEC */,
  0x44C60100l /* 0x021FF0 */,
  0x03DE0300l /* 0x021FF4 */,
  0xDE110000l /* 0x021FF8 */,
  0x9A340100l /* 0x021FFC */,
  0x08BC0300l /* 0x022000 */,
  0xEF070000l /* 0x022004 */,
  0xE3880000l /* 0x022008 */,
  0x08BE0300l /* 0x02200C */,
  0x011C6801l /* 0x022010 */,
  0x00400200l /* 0x022014 */,
  0x00000000l /* 0x022018 */,
  0x00FE0100l /* 0x02201C */,
  0x00000000l /* 0x022020 */,
  0xE8070000l /* 0x022024 */,
  0x952A0100l /* 0x022028 */,
  0x03D00300l /* 0x02202C */,
  0xDF110000l /* 0x022030 */,
  0x44C60100l /* 0x022034 */,
  0x03DE0300l /* 0x022038 */,
  0xEF070000l /* 0x02203C */,
  0xE3880000l /* 0x022040 */,
  0x08BE0300l /* 0x022044 */,
  0xDE110000l /* 0x022048 */,
  0x9A340100l /* 0x02204C */,
  0x08BC0300l /* 0x022050 */,
  0x00000000l /* 0x022054 */,
  0xFF000000l /* 0x022058 */,
  0x00000000l /* 0x02205C */,
  0xEF070000l /* 0x022060 */,
  0xE3880000l /* 0x022064 */,
  0x08BE0300l /* 0x022068 */,
  0x03000000l /* 0x02206C */,
  0xE2CA0300l /* 0x022070 */,
  0xF6810000l /* 0x022074 */,
  0x02341C02l /* 0x022078 */,
  0x00600600l /* 0x02207C */,
  0x00000000l /* 0x022080 */,
  0x00FE0100l /* 0x022084 */,
  0x00000000l /* 0x022088 */,
  0xF5030000l /* 0x02208C */,
  0xE0800000l /* 0x022090 */,
  0x03CE0300l /* 0x022094 */,
  0xE8070000l /* 0x022098 */,
  0x952A0100l /* 0x02209C */,
  0x03D00300l /* 0x0220A0 */,
  0xE7070000l /* 0x0220A4 */,
  0x40C00100l /* 0x0220A8 */,
  0x01EA0300l /* 0x0220AC */,
  0xDF110000l /* 0x0220B0 */,
  0x44C60100l /* 0x0220B4 */,
  0x03DE0300l /* 0x0220B8 */,
  0x00000000l /* 0x0220BC */,
  0xFF000000l /* 0x0220C0 */,
  0x00000000l /* 0x0220C4 */,
  0xEF070000l /* 0x0220C8 */,
  0xE3880000l /* 0x0220CC */,
  0x08BE0300l /* 0x0220D0 */,
  0xDE110000l /* 0x0220D4 */,
  0x9A340100l /* 0x0220D8 */,
  0x08BC0300l /* 0x0220DC */,
  0xDE110000l /* 0x0220E0 */,
  0x9A340100l /* 0x0220E4 */,
  0x08BC0300l /* 0x0220E8 */,
  0x04000000l /* 0x0220EC */,
  0xE2CA0300l /* 0x0220F0 */,
  0xF5810000l /* 0x0220F4 */,
  0x00000000l /* 0x0220F8 */,
  0xFF000000l /* 0x0220FC */,
  0x00000000l /* 0x022100 */,
  0xEF070000l /* 0x022104 */,
  0xE3880000l /* 0x022108 */,
  0x08BE0300l /* 0x02210C */,
  0xEF070000l /* 0x022110 */,
  0xE3880000l /* 0x022114 */,
  0x08BE0300l /* 0x022118 */,
  0x00000000l /* 0x02211C */,
  0x97D20300l /* 0x022120 */,
  0xE92F0100l /* 0x022124 */,
  0x04000000l /* 0x022128 */,
  0xE2CA0300l /* 0x02212C */,
  0xF5810000l /* 0x022130 */,
  0x00000000l /* 0x022134 */,
  0xFF000000l /* 0x022138 */,
  0x00000000l /* 0x02213C */,
  0x0328D002l /* 0x022140 */,
  0xABAA0400l /* 0x022144 */,
  0x2FE00300l /* 0x022148 */,
  0x2F840100l /* 0x02214C */,
  0x00E00300l /* 0x022150 */,
  0x00F00300l /* 0x022154 */,
  0x71540100l /* 0x022158 */,
  0x00DA0300l /* 0x02215C */,
  0xED010000l /* 0x022160 */,
  0xAAE20000l /* 0x022164 */,
  0xF8010000l /* 0x022168 */,
  0x09EC0300l /* 0x02216C */,
  0x60680100l /* 0x022170 */,
  0x01D80300l /* 0x022174 */,
  0xEFFF0300l /* 0x022178 */,
  0x9E000100l /* 0x02217C */,
  0xFBF30300l /* 0x022180 */,
  0xED050000l /* 0x022184 */,
  0xBF7E0000l /* 0x022188 */,
  0xF1450000l /* 0x02218C */,
  0xF3FB0300l /* 0x022190 */,
  0x90200100l /* 0x022194 */,
  0xFDE70300l /* 0x022198 */,
  0xEC050000l /* 0x02219C */,
  0xBB9E0000l /* 0x0221A0 */,
  0xF4290000l /* 0x0221A4 */,
  0xFD010000l /* 0x0221A8 */,
  0xB91E0000l /* 0x0221AC */,
  0xF8870000l /* 0x0221B0 */,
  0xEC030000l /* 0x0221B4 */,
  0xB4C00000l /* 0x0221B8 */,
  0xF6130000l /* 0x0221BC */,
  0xFC010000l /* 0x0221C0 */,
  0xBE320000l /* 0x0221C4 */,
  0xF9690000l /* 0x0221C8 */,
  0xFF010000l /* 0x0221CC */,
  0x97F80300l /* 0x0221D0 */,
  0xF7EF0000l /* 0x0221D4 */,
  0x0428E001l /* 0x0221D8 */,
  0x56550400l /* 0x0221DC */,
  0x00000000l /* 0x0221E0 */,
  0x00FE0100l /* 0x0221E4 */,
  0x00000000l /* 0x0221E8 */,
  0xF0050000l /* 0x0221EC */,
  0xCAB80000l /* 0x0221F0 */,
  0x03CA0300l /* 0x0221F4 */,
  0xE5070000l /* 0x0221F8 */,
  0x5C940100l /* 0x0221FC */,
  0x02E00300l /* 0x022200 */,
  0xDF110000l /* 0x022204 */,
  0x44C60100l /* 0x022208 */,
  0x03DE0300l /* 0x02220C */,
  0xFA050000l /* 0x022210 */,
  0xFB280000l /* 0x022214 */,
  0x05E00300l /* 0x022218 */,
  0x02000000l /* 0x02221C */,
  0x79DA0300l /* 0x022220 */,
  0xE6650100l /* 0x022224 */,
  0xDE110000l /* 0x022228 */,
  0x9A340100l /* 0x02222C */,
  0x08BC0300l /* 0x022230 */,
  0x03000000l /* 0x022234 */,
  0xF2D40300l /* 0x022238 */,
  0xFA4D0000l /* 0x02223C */,
  0xF5050000l /* 0x022240 */,
  0xF3540000l /* 0x022244 */,
  0x06CC0300l /* 0x022248 */,
  0xEF070000l /* 0x02224C */,
  0xE3880000l /* 0x022250 */,
  0x08BE0300l /* 0x022254 */,
  0x03000000l /* 0x022258 */,
  0xB3CA0300l /* 0x02225C */,
  0xECF30000l /* 0x022260 */,
  0x01000000l /* 0x022264 */,
  0xFDE60300l /* 0x022268 */,
  0xFE230000l /* 0x02226C */,
  0x05402001l /* 0x022270 */,
  0x34330800l /* 0x022274 */,
  0x00000000l /* 0x022278 */,
  0x00FE0100l /* 0x02227C */,
  0x00000000l /* 0x022280 */,
  0xE4070000l /* 0x022284 */,
  0x73700100l /* 0x022288 */,
  0x01DA0300l /* 0x02228C */,
  0xF8030000l /* 0x022290 */,
  0xEC600000l /* 0x022294 */,
  0x03D00300l /* 0x022298 */,
  0xE8070000l /* 0x02229C */,
  0x30D80100l /* 0x0222A0 */,
  0x01F00300l /* 0x0222A4 */,
  0xED030000l /* 0x0222A8 */,
  0xB8E60000l /* 0x0222AC */,
  0x03C80300l /* 0x0222B0 */,
  0xDF110000l /* 0x0222B4 */,
  0x44C60100l /* 0x0222B8 */,
  0x03DE0300l /* 0x0222BC */,
  0xE70B0000l /* 0x0222C0 */,
  0xCACC0000l /* 0x0222C4 */,
  0x09B60300l /* 0x0222C8 */,
  0x01000000l /* 0x0222CC */,
  0xFFF00300l /* 0x0222D0 */,
  0xFF130000l /* 0x0222D4 */,
  0xDC110000l /* 0x0222D8 */,
  0x89560100l /* 0x0222DC */,
  0x07C20300l /* 0x0222E0 */,
  0xF7030000l /* 0x0222E4 */,
  0xF54A0000l /* 0x0222E8 */,
  0x06D00300l /* 0x0222EC */,
  0xDE110000l /* 0x0222F0 */,
  0x9A340100l /* 0x0222F4 */,
  0x08BC0300l /* 0x0222F8 */,
  0xFA030000l /* 0x0222FC */,
  0xFB2E0000l /* 0x022300 */,
  0x04DE0300l /* 0x022304 */,
  0x03000000l /* 0x022308 */,
  0xD6C80300l /* 0x02230C */,
  0xF3A10000l /* 0x022310 */,
  0xEB090000l /* 0x022314 */,
  0xD7AA0000l /* 0x022318 */,
  0x09B80300l /* 0x02231C */,
  0x02000000l /* 0x022320 */,
  0xFBE20300l /* 0x022324 */,
  0xFD2B0000l /* 0x022328 */,
  0xEF070000l /* 0x02232C */,
  0xE3880000l /* 0x022330 */,
  0x08BE0300l /* 0x022334 */,
  0x02000000l /* 0x022338 */,
  0xF5D80300l /* 0x02233C */,
  0xFB450000l /* 0x022340 */,
  0x02000000l /* 0x022344 */,
  0x85D60300l /* 0x022348 */,
  0xE74F0100l /* 0x02234C */,
  0xFE010000l /* 0x022350 */,
  0xFE160000l /* 0x022354 */,
  0x02EE0300l /* 0x022358 */,
  0x03000000l /* 0x02235C */,
  0xC8C80300l /* 0x022360 */,
  0xF0C30000l /* 0x022364 */,
  0x0640B001l /* 0x022368 */,
  0xCD4C0800l /* 0x02236C */,
  0x00000000l /* 0x022370 */,
  0x00FE0100l /* 0x022374 */,
  0x00000000l /* 0x022378 */,
  0xED030000l /* 0x02237C */,
  0xB8E60000l /* 0x022380 */,
  0x03C80300l /* 0x022384 */,
  0xE8070000l /* 0x022388 */,
  0x30D80100l /* 0x02238C */,
  0x01F00300l /* 0x022390 */,
  0xF8030000l /* 0x022394 */,
  0xEC600000l /* 0x022398 */,
  0x03D00300l /* 0x02239C */,
  0xE4070000l /* 0x0223A0 */,
  0x73700100l /* 0x0223A4 */,
  0x01DA0300l /* 0x0223A8 */,
  0xDF110000l /* 0x0223AC */,
  0x44C60100l /* 0x0223B0 */,
  0x03DE0300l /* 0x0223B4 */,
  0xF7030000l /* 0x0223B8 */,
  0xF54A0000l /* 0x0223BC */,
  0x06D00300l /* 0x0223C0 */,
  0xDC110000l /* 0x0223C4 */,
  0x89560100l /* 0x0223C8 */,
  0x07C20300l /* 0x0223CC */,
  0x01000000l /* 0x0223D0 */,
  0xFFF00300l /* 0x0223D4 */,
  0xFF130000l /* 0x0223D8 */,
  0xE70B0000l /* 0x0223DC */,
  0xCACC0000l /* 0x0223E0 */,
  0x09B60300l /* 0x0223E4 */,
  0xDE110000l /* 0x0223E8 */,
  0x9A340100l /* 0x0223EC */,
  0x08BC0300l /* 0x0223F0 */,
  0x02000000l /* 0x0223F4 */,
  0xFBE20300l /* 0x0223F8 */,
  0xFD2B0000l /* 0x0223FC */,
  0xEB090000l /* 0x022400 */,
  0xD7AA0000l /* 0x022404 */,
  0x09B80300l /* 0x022408 */,
  0x03000000l /* 0x02240C */,
  0xD6C80300l /* 0x022410 */,
  0xF3A10000l /* 0x022414 */,
  0xFA030000l /* 0x022418 */,
  0xFB2E0000l /* 0x02241C */,
  0x04DE0300l /* 0x022420 */,
  0xEF070000l /* 0x022424 */,
  0xE3880000l /* 0x022428 */,
  0x08BE0300l /* 0x02242C */,
  0x03000000l /* 0x022430 */,
  0xC7C80300l /* 0x022434 */,
  0xF0C50000l /* 0x022438 */,
  0xFE010000l /* 0x02243C */,
  0xFE160000l /* 0x022440 */,
  0x02EE0300l /* 0x022444 */,
  0x02000000l /* 0x022448 */,
  0x86D40300l /* 0x02244C */,
  0xE6510100l /* 0x022450 */,
  0x02000000l /* 0x022454 */,
  0xF5D80300l /* 0x022458 */,
  0xFB450000l /* 0x02245C */,
  0x07641001l /* 0x022460 */,
  0x00300E00l /* 0x022464 */,
  0x00000000l /* 0x022468 */,
  0x00FE0100l /* 0x02246C */,
  0x00000000l /* 0x022470 */,
  0xE4070000l /* 0x022474 */,
  0x6A800100l /* 0x022478 */,
  0x01DC0300l /* 0x02247C */,
  0xF5030000l /* 0x022480 */,
  0xE2800000l /* 0x022484 */,
  0x03CA0300l /* 0x022488 */,
  0xEE050000l /* 0x02248C */,
  0x1BF20100l /* 0x022490 */,
  0x00F80300l /* 0x022494 */,
  0xE8050000l /* 0x022498 */,
  0x962C0100l /* 0x02249C */,
  0x02D00300l /* 0x0224A0 */,
  0xFC010000l /* 0x0224A4 */,
  0xF9360000l /* 0x0224A8 */,
  0x02DC0300l /* 0x0224AC */,
  0xE5070000l /* 0x0224B0 */,
  0x40C40100l /* 0x0224B4 */,
  0x01EA0300l /* 0x0224B8 */,
  0xEE030000l /* 0x0224BC */,
  0xC0D40000l /* 0x0224C0 */,
  0x03C80300l /* 0x0224C4 */,
  0xDE130000l /* 0x0224C8 */,
  0x44C60100l /* 0x0224CC */,
  0x04DC0300l /* 0x0224D0 */,
  0xE50D0000l /* 0x0224D4 */,
  0xC3DE0000l /* 0x0224D8 */,
  0x09B40300l /* 0x0224DC */,
  0x00000000l /* 0x0224E0 */,
  0xFF000000l /* 0x0224E4 */,
  0x00000000l /* 0x0224E8 */,
  0xDA130000l /* 0x0224EC */,
  0x6F860100l /* 0x0224F0 */,
  0x06CA0300l /* 0x0224F4 */,
  0xEF070000l /* 0x0224F8 */,
  0xE3880000l /* 0x0224FC */,
  0x08BE0300l /* 0x022500 */,
  0x03000000l /* 0x022504 */,
  0xF8DC0300l /* 0x022508 */,
  0xFB390000l /* 0x02250C */,
  0xDE110000l /* 0x022510 */,
  0x9A340100l /* 0x022514 */,
  0x08BC0300l /* 0x022518 */,
  0xF8050000l /* 0x02251C */,
  0xF73E0000l /* 0x022520 */,
  0x06D40300l /* 0x022524 */,
  0xDE110000l /* 0x022528 */,
  0x9A340100l /* 0x02252C */,
  0x08BC0300l /* 0x022530 */,
  0xF8050000l /* 0x022534 */,
  0xF73E0000l /* 0x022538 */,
  0x06D40300l /* 0x02253C */,
  0x04000000l /* 0x022540 */,
  0xE2CA0300l /* 0x022544 */,
  0xF5810000l /* 0x022548 */,
  0xE50D0000l /* 0x02254C */,
  0xC3DE0000l /* 0x022550 */,
  0x09B40300l /* 0x022554 */,
  0x00000000l /* 0x022558 */,
  0xFF000000l /* 0x02255C */,
  0x00000000l /* 0x022560 */,
  0x03000000l /* 0x022564 */,
  0xC1C60300l /* 0x022568 */,
  0xEED70000l /* 0x02256C */,
  0xEF070000l /* 0x022570 */,
  0xE3880000l /* 0x022574 */,
  0x08BE0300l /* 0x022578 */,
  0x03000000l /* 0x02257C */,
  0xF8DC0300l /* 0x022580 */,
  0xFB390000l /* 0x022584 */,
  0xEE090000l /* 0x022588 */,
  0xE3880000l /* 0x02258C */,
  0x09BC0300l /* 0x022590 */,
  0x03000000l /* 0x022594 */,
  0xF8DC0300l /* 0x022598 */,
  0xFB390000l /* 0x02259C */,
  0xDE110000l /* 0x0225A0 */,
  0x9A340100l /* 0x0225A4 */,
  0x08BC0300l /* 0x0225A8 */,
  0xF8050000l /* 0x0225AC */,
  0xF73E0000l /* 0x0225B0 */,
  0x06D40300l /* 0x0225B4 */,
  0x04000000l /* 0x0225B8 */,
  0xE2CA0300l /* 0x0225BC */,
  0xF5810000l /* 0x0225C0 */,
  0x02000000l /* 0x0225C4 */,
  0x6BDC0300l /* 0x0225C8 */,
  0xE4830100l /* 0x0225CC */,
  0x00000000l /* 0x0225D0 */,
  0xFF000000l /* 0x0225D4 */,
  0x00000000l /* 0x0225D8 */,
  0x03000000l /* 0x0225DC */,
  0xC1C60300l /* 0x0225E0 */,
  0xEED70000l /* 0x0225E4 */,
  0x087CD800l /* 0x0225E8 */,
  0x67261200l /* 0x0225EC */,
  0x00000000l /* 0x0225F0 */,
  0x00FE0100l /* 0x0225F4 */,
  0x00000000l /* 0x0225F8 */,
  0xE4070000l /* 0x0225FC */,
  0x4FAC0100l /* 0x022600 */,
  0x01E60300l /* 0x022604 */,
  0xED030000l /* 0x022608 */,
  0xB8E60000l /* 0x02260C */,
  0x03C80300l /* 0x022610 */,
  0xFD010000l /* 0x022614 */,
  0xFB2A0000l /* 0x022618 */,
  0x02E20300l /* 0x02261C */,
  0xE8070000l /* 0x022620 */,
  0x30DA0100l /* 0x022624 */,
  0x00F00300l /* 0x022628 */,
  0xE8050000l /* 0x02262C */,
  0x962C0100l /* 0x022630 */,
  0x02D00300l /* 0x022634 */,
  0xF8010000l /* 0x022638 */,
  0xED600000l /* 0x02263C */,
  0x03D00300l /* 0x022640 */,
  0xF1050000l /* 0x022644 */,
  0x15F60100l /* 0x022648 */,
  0x00FA0300l /* 0x02264C */,
  0xE4070000l /* 0x022650 */,
  0x73700100l /* 0x022654 */,
  0x01DA0300l /* 0x022658 */,
  0xF3030000l /* 0x02265C */,
  0xD69E0000l /* 0x022660 */,
  0x03C80300l /* 0x022664 */,
  0xDE130000l /* 0x022668 */,
  0x44C60100l /* 0x02266C */,
  0x04DC0300l /* 0x022670 */,
  0xE00F0000l /* 0x022674 */,
  0xAB120100l /* 0x022678 */,
  0x09B80300l /* 0x02267C */,
  0xF6050000l /* 0x022680 */,
  0xF54C0000l /* 0x022684 */,
  0x06CE0300l /* 0x022688 */,
  0x03000000l /* 0x02268C */,
  0xF6D60300l /* 0x022690 */,
  0xFA450000l /* 0x022694 */,
  0xDC130000l /* 0x022698 */,
  0x89560100l /* 0x02269C */,
  0x07C00300l /* 0x0226A0 */,
  0xEE090000l /* 0x0226A4 */,
  0xE3880000l /* 0x0226A8 */,
  0x09BC0300l /* 0x0226AC */,
  0x01000000l /* 0x0226B0 */,
  0xFFF00300l /* 0x0226B4 */,
  0xFE150000l /* 0x0226B8 */,
  0xDB130000l /* 0x0226BC */,
  0x66940100l /* 0x0226C0 */,
  0x05CE0300l /* 0x0226C4 */,
  0xE70B0000l /* 0x0226C8 */,
  0xCACC0000l /* 0x0226CC */,
  0x09B60300l /* 0x0226D0 */,
  0xFD030000l /* 0x0226D4 */,
  0xFE160000l /* 0x0226D8 */,
  0x03EC0300l /* 0x0226DC */,
  0xDD110000l /* 0x0226E0 */,
  0x9B360100l /* 0x0226E4 */,
  0x08BA0300l /* 0x0226E8 */,
  0xF2070000l /* 0x0226EC */,
  0xED680000l /* 0x0226F0 */,
  0x08C40300l /* 0x0226F4 */,
  0x02000000l /* 0x0226F8 */,
  0xFCE20300l /* 0x0226FC */,
  0xFC2B0000l /* 0x022700 */,
  0x03000000l /* 0x022704 */,
  0xB9C80300l /* 0x022708 */,
  0xECE90000l /* 0x02270C */,
  0xEB0B0000l /* 0x022710 */,
  0xD7AA0000l /* 0x022714 */,
  0x09B60300l /* 0x022718 */,
  0x00000000l /* 0x02271C */,
  0xFF000000l /* 0x022720 */,
  0x00000000l /* 0x022724 */,
  0x04000000l /* 0x022728 */,
  0xD6C60300l /* 0x02272C */,
  0xF2A30000l /* 0x022730 */,
  0xE30D0000l /* 0x022734 */,
  0xBBF00000l /* 0x022738 */,
  0x09B60300l /* 0x02273C */,
  0xFA030000l /* 0x022740 */,
  0xFA300000l /* 0x022744 */,
  0x05DC0300l /* 0x022748 */,
  0x03000000l /* 0x02274C */,
  0xEDCE0300l /* 0x022750 */,
  0xF8630000l /* 0x022754 */,
  0xEE090000l /* 0x022758 */,
  0xE3880000l /* 0x02275C */,
  0x09BC0300l /* 0x022760 */,
  0x01000000l /* 0x022764 */,
  0xFFF00300l /* 0x022768 */,
  0xFE150000l /* 0x02276C */,
  0x04000000l /* 0x022770 */,
  0xC8C60300l /* 0x022774 */,
  0xEFC50000l /* 0x022778 */,
  0x00000000l /* 0x02277C */,
  0x56F40300l /* 0x022780 */,
  0xF0810100l /* 0x022784 */,
  0xFD030000l /* 0x022788 */,
  0xFE160000l /* 0x02278C */,
  0x03EC0300l /* 0x022790 */,
  0x04000000l /* 0x022794 */,
  0xE2CA0300l /* 0x022798 */,
  0xF5810000l /* 0x02279C */,
  0x02000000l /* 0x0227A0 */,
  0x86D40300l /* 0x0227A4 */,
  0xE5530100l /* 0x0227A8 */,
  0xF6050000l /* 0x0227AC */,
  0xF54C0000l /* 0x0227B0 */,
  0x06CE0300l /* 0x0227B4 */,
  0x03000000l /* 0x0227B8 */,
  0xF5D60300l /* 0x0227BC */,
  0xFA450000l /* 0x0227C0 */,
  0x03000000l /* 0x0227C4 */,
  0xA8CA0300l /* 0x0227C8 */,
  0xEA0D0100l /* 0x0227CC */,
  0x00000000l /* 0x0227D0 */,
  0x09404002l /* 0x0227D4 */,
  0x67660800l /* 0x0227D8 */,
  0x00000000l /* 0x0227DC */,
  0x00FE0100l /* 0x0227E0 */,
  0x00000000l /* 0x0227E4 */,
  0xF8030000l /* 0x0227E8 */,
  0xEC600000l /* 0x0227EC */,
  0x03D00300l /* 0x0227F0 */,
  0xED030000l /* 0x0227F4 */,
  0xB8E60000l /* 0x0227F8 */,
  0x03C80300l /* 0x0227FC */,
  0xE4070000l /* 0x022800 */,
  0x73700100l /* 0x022804 */,
  0x01DA0300l /* 0x022808 */,
  0xE8070000l /* 0x02280C */,
  0x30D80100l /* 0x022810 */,
  0x01F00300l /* 0x022814 */,
  0xDE130000l /* 0x022818 */,
  0x44C60100l /* 0x02281C */,
  0x04DC0300l /* 0x022820 */,
  0x01000000l /* 0x022824 */,
  0xFFF00300l /* 0x022828 */,
  0xFE150000l /* 0x02282C */,
  0xF6050000l /* 0x022830 */,
  0xF54C0000l /* 0x022834 */,
  0x06CE0300l /* 0x022838 */,
  0xE70B0000l /* 0x02283C */,
  0xCBCC0000l /* 0x022840 */,
  0x09B60300l /* 0x022844 */,
  0xDC130000l /* 0x022848 */,
  0x89560100l /* 0x02284C */,
  0x07C00300l /* 0x022850 */,
  0xDD110000l /* 0x022854 */,
  0x9B360100l /* 0x022858 */,
  0x08BA0300l /* 0x02285C */,
  0x04000000l /* 0x022860 */,
  0xD6C60300l /* 0x022864 */,
  0xF2A30000l /* 0x022868 */,
  0x02000000l /* 0x02286C */,
  0xFCE20300l /* 0x022870 */,
  0xFC2B0000l /* 0x022874 */,
  0xFA030000l /* 0x022878 */,
  0xFC300000l /* 0x02287C */,
  0x05DC0300l /* 0x022880 */,
  0xEB0B0000l /* 0x022884 */,
  0xD7AA0000l /* 0x022888 */,
  0x08B80300l /* 0x02288C */,
  0xEE090000l /* 0x022890 */,
  0xE3880000l /* 0x022894 */,
  0x09BC0300l /* 0x022898 */,
  0x02000000l /* 0x02289C */,
  0x86D40300l /* 0x0228A0 */,
  0xE5530100l /* 0x0228A4 */,
  0x04000000l /* 0x0228A8 */,
  0xC8C60300l /* 0x0228AC */,
  0xEFC50000l /* 0x0228B0 */,
  0x03000000l /* 0x0228B4 */,
  0xF6D60300l /* 0x0228B8 */,
  0xFA450000l /* 0x0228BC */,
  0xFD030000l /* 0x0228C0 */,
  0xFE160000l /* 0x0228C4 */,
  0x03EC0300l /* 0x0228C8 */,
  0x0A884701l /* 0x0228CC */,
  0x2F3A1400l /* 0x0228D0 */,
  0x00000000l /* 0x0228D4 */,
  0x00FE0100l /* 0x0228D8 */,
  0x00000000l /* 0x0228DC */,
  0xE6050000l /* 0x0228E0 */,
  0x864C0100l /* 0x0228E4 */,
  0x02D40300l /* 0x0228E8 */,
  0xFD030000l /* 0x0228EC */,
  0xFA280000l /* 0x0228F0 */,
  0x02E40300l /* 0x0228F4 */,
  0xE4070000l /* 0x0228F8 */,
  0x66860100l /* 0x0228FC */,
  0x01DE0300l /* 0x022900 */,
  0xF9030000l /* 0x022904 */,
  0xEE580000l /* 0x022908 */,
  0x03D20300l /* 0x02290C */,
  0xE5070000l /* 0x022910 */,
  0x47B80100l /* 0x022914 */,
  0x01E80300l /* 0x022918 */,
  0xF4030000l /* 0x02291C */,
  0xDC8E0000l /* 0x022920 */,
  0x03C60300l /* 0x022924 */,
  0xE9070000l /* 0x022928 */,
  0x2CDC0100l /* 0x02292C */,
  0x01F20300l /* 0x022930 */,
  0xEF030000l /* 0x022934 */,
  0xC3CC0000l /* 0x022938 */,
  0x03C80300l /* 0x02293C */,
  0xF2050000l /* 0x022940 */,
  0x14F40100l /* 0x022944 */,
  0x01FA0300l /* 0x022948 */,
  0xEA050000l /* 0x02294C */,
  0xA60C0100l /* 0x022950 */,
  0x02CC0300l /* 0x022954 */,
  0xDE130000l /* 0x022958 */,
  0x44C60100l /* 0x02295C */,
  0x04DC0300l /* 0x022960 */,
  0xEB090000l /* 0x022964 */,
  0xD8A80000l /* 0x022968 */,
  0x09B80300l /* 0x02296C */,
  0x03000000l /* 0x022970 */,
  0xF3D60300l /* 0x022974 */,
  0xFA4B0000l /* 0x022978 */,
  0xE40D0000l /* 0x02297C */,
  0xBFE80000l /* 0x022980 */,
  0x09B40300l /* 0x022984 */,
  0x02000000l /* 0x022988 */,
  0xFEEA0300l /* 0x02298C */,
  0xFE1B0000l /* 0x022990 */,
  0xDE110000l /* 0x022994 */,
  0xA1280100l /* 0x022998 */,
  0x08BA0300l /* 0x02299C */,
  0xFF010000l /* 0x0229A0 */,
  0xFF0C0000l /* 0x0229A4 */,
  0x01F60300l /* 0x0229A8 */,
  0xDB130000l /* 0x0229AC */,
  0x82640100l /* 0x0229B0 */,
  0x07C20300l /* 0x0229B4 */,
  0xF8030000l /* 0x0229B8 */,
  0xFA3A0000l /* 0x0229BC */,
  0x05D60300l /* 0x0229C0 */,
  0xDB130000l /* 0x0229C4 */,
  0x619C0100l /* 0x0229C8 */,
  0x05D00300l /* 0x0229CC */,
  0xF2070000l /* 0x0229D0 */,
  0xEB6E0000l /* 0x0229D4 */,
  0x08C20300l /* 0x0229D8 */,
  0xDD110000l /* 0x0229DC */,
  0x9B360100l /* 0x0229E0 */,
  0x08BA0300l /* 0x0229E4 */,
  0xFD010000l /* 0x0229E8 */,
  0xFF160000l /* 0x0229EC */,
  0x02EE0300l /* 0x0229F0 */,
  0x03000000l /* 0x0229F4 */,
  0xB6C80300l /* 0x0229F8 */,
  0xECEF0000l /* 0x0229FC */,
  0xF7050000l /* 0x022A00 */,
  0xF6440000l /* 0x022A04 */,
  0x06D20300l /* 0x022A08 */,
  0x04000000l /* 0x022A0C */,
  0xD1C60300l /* 0x022A10 */,
  0xF1AF0000l /* 0x022A14 */,
  0xF0070000l /* 0x022A18 */,
  0xE77C0000l /* 0x022A1C */,
  0x08C00300l /* 0x022A20 */,
  0x04000000l /* 0x022A24 */,
  0xE8CC0300l /* 0x022A28 */,
  0xF6710000l /* 0x022A2C */,
  0xE90B0000l /* 0x022A30 */,
  0xD1BA0000l /* 0x022A34 */,
  0x09B60300l /* 0x022A38 */,
  0x03000000l /* 0x022A3C */,
  0xF7DA0300l /* 0x022A40 */,
  0xFB3D0000l /* 0x022A44 */,
  0xE20F0000l /* 0x022A48 */,
  0xB7F80000l /* 0x022A4C */,
  0x09B60300l /* 0x022A50 */,
  0x01000000l /* 0x022A54 */,
  0xFFF20300l /* 0x022A58 */,
  0xFF110000l /* 0x022A5C */,
  0xEE090000l /* 0x022A60 */,
  0xE3880000l /* 0x022A64 */,
  0x09BC0300l /* 0x022A68 */,
  0x03000000l /* 0x022A6C */,
  0xEDCE0300l /* 0x022A70 */,
  0xF7650000l /* 0x022A74 */,
  0x01000000l /* 0x022A78 */,
  0x60E00300l /* 0x022A7C */,
  0xE4970100l /* 0x022A80 */,
  0x02000000l /* 0x022A84 */,
  0xFBDE0300l /* 0x022A88 */,
  0xFC310000l /* 0x022A8C */,
  0x02000000l /* 0x022A90 */,
  0x80D40300l /* 0x022A94 */,
  0xE65D0100l /* 0x022A98 */,
  0x01000000l /* 0x022A9C */,
  0xFFF80300l /* 0x022AA0 */,
  0xFF090000l /* 0x022AA4 */,
  0x03000000l /* 0x022AA8 */,
  0xA0CC0300l /* 0x022AAC */,
  0xE91D0100l /* 0x022AB0 */,
  0xFC030000l /* 0x022AB4 */,
  0xFD200000l /* 0x022AB8 */,
  0x04E40300l /* 0x022ABC */,
  0x03000000l /* 0x022AC0 */,
  0xBFC60300l /* 0x022AC4 */,
  0xEDDD0000l /* 0x022AC8 */,
  0xF5050000l /* 0x022ACC */,
  0xF3520000l /* 0x022AD0 */,
  0x07CC0300l /* 0x022AD4 */,
  0x04000000l /* 0x022AD8 */,
  0xD8C80300l /* 0x022ADC */,
  0xF39B0000l /* 0x022AE0 */,
  0x0B708002l /* 0x022AE4 */,
  0xC8711000l /* 0x022AE8 */,
  0x00000000l /* 0x022AEC */,
  0x00FE0100l /* 0x022AF0 */,
  0x00000000l /* 0x022AF4 */,
  0xFD030000l /* 0x022AF8 */,
  0xF92E0000l /* 0x022AFC */,
  0x02E00300l /* 0x022B00 */,
  0xF7030000l /* 0x022B04 */,
  0xE86C0000l /* 0x022B08 */,
  0x03CE0300l /* 0x022B0C */,
  0xF1030000l /* 0x022B10 */,
  0xCDB40000l /* 0x022B14 */,
  0x03C80300l /* 0x022B18 */,
  0xEB050000l /* 0x022B1C */,
  0xAA020100l /* 0x022B20 */,
  0x03CA0300l /* 0x022B24 */,
  0xE5070000l /* 0x022B28 */,
  0x81540100l /* 0x022B2C */,
  0x02D60300l /* 0x022B30 */,
  0xE4070000l /* 0x022B34 */,
  0x5A9A0100l /* 0x022B38 */,
  0x01E20300l /* 0x022B3C */,
  0xE7070000l /* 0x022B40 */,
  0x36D00100l /* 0x022B44 */,
  0x01EE0300l /* 0x022B48 */,
  0xF0050000l /* 0x022B4C */,
  0x17F20100l /* 0x022B50 */,
  0x01FA0300l /* 0x022B54 */,
  0xDE130000l /* 0x022B58 */,
  0x44C60100l /* 0x022B5C */,
  0x04DC0300l /* 0x022B60 */,
  0x03000000l /* 0x022B64 */,
  0xF7D80300l /* 0x022B68 */,
  0xFB3F0000l /* 0x022B6C */,
  0x01000000l /* 0x022B70 */,
  0xFFF60300l /* 0x022B74 */,
  0xFF0B0000l /* 0x022B78 */,
  0xFB030000l /* 0x022B7C */,
  0xFC280000l /* 0x022B80 */,
  0x04E00300l /* 0x022B84 */,
  0xF3070000l /* 0x022B88 */,
  0xED660000l /* 0x022B8C */,
  0x08C40300l /* 0x022B90 */,
  0xEA0B0000l /* 0x022B94 */,
  0xD4B20000l /* 0x022B98 */,
  0x09B60300l /* 0x022B9C */,
  0xE20F0000l /* 0x022BA0 */,
  0xB4FE0000l /* 0x022BA4 */,
  0x09B60300l /* 0x022BA8 */,
  0xDC110000l /* 0x022BAC */,
  0x8F4C0100l /* 0x022BB0 */,
  0x08BE0300l /* 0x022BB4 */,
  0xDB130000l /* 0x022BB8 */,
  0x67920100l /* 0x022BBC */,
  0x06CC0300l /* 0x022BC0 */,
  0xDD110000l /* 0x022BC4 */,
  0x9B360100l /* 0x022BC8 */,
  0x08BA0300l /* 0x022BCC */,
  0x03000000l /* 0x022BD0 */,
  0xBCC80300l /* 0x022BD4 */,
  0xEDE10000l /* 0x022BD8 */,
  0x04000000l /* 0x022BDC */,
  0xDCC80300l /* 0x022BE0 */,
  0xF3930000l /* 0x022BE4 */,
  0x03000000l /* 0x022BE8 */,
  0xF3D40300l /* 0x022BEC */,
  0xFA4D0000l /* 0x022BF0 */,
  0x01000000l /* 0x022BF4 */,
  0xFFEE0300l /* 0x022BF8 */,
  0xFE170000l /* 0x022BFC */,
  0xFC030000l /* 0x022C00 */,
  0xFE1C0000l /* 0x022C04 */,
  0x03E80300l /* 0x022C08 */,
  0xF5050000l /* 0x022C0C */,
  0xF1580000l /* 0x022C10 */,
  0x07CA0300l /* 0x022C14 */,
  0xEC090000l /* 0x022C18 */,
  0xDBA00000l /* 0x022C1C */,
  0x09B80300l /* 0x022C20 */,
  0xE30D0000l /* 0x022C24 */,
  0xBCEE0000l /* 0x022C28 */,
  0x09B60300l /* 0x022C2C */,
  0xEE090000l /* 0x022C30 */,
  0xE3880000l /* 0x022C34 */,
  0x09BC0300l /* 0x022C38 */,
  0x01000000l /* 0x022C3C */,
  0x67DE0300l /* 0x022C40 */,
  0xE48B0100l /* 0x022C44 */,
  0x02000000l /* 0x022C48 */,
  0x8ED20300l /* 0x022C4C */,
  0xE7410100l /* 0x022C50 */,
  0x03000000l /* 0x022C54 */,
  0xB5C80300l /* 0x022C58 */,
  0xEBF30000l /* 0x022C5C */,
  0x04000000l /* 0x022C60 */,
  0xD6C60300l /* 0x022C64 */,
  0xF2A30000l /* 0x022C68 */,
  0x03000000l /* 0x022C6C */,
  0xEFD00300l /* 0x022C70 */,
  0xF85D0000l /* 0x022C74 */,
  0x02000000l /* 0x022C78 */,
  0xFDE80300l /* 0x022C7C */,
  0xFD210000l /* 0x022C80 */,
  0xFE010000l /* 0x022C84 */,
  0xFF100000l /* 0x022C88 */,
  0x02F20300l /* 0x022C8C */,
  0xF6050000l /* 0x022C90 */,
  0xF54A0000l /* 0x022C94 */,
  0x06D00300l /* 0x022C98 */,
  0x0CB88001l /* 0x022C9C */,
  0x45441C00l /* 0x022CA0 */,
  0x00000000l /* 0x022CA4 */,
  0x00FE0100l /* 0x022CA8 */,
  0x00000000l /* 0x022CAC */,
  0xE9050000l /* 0x022CB0 */,
  0xA2160100l /* 0x022CB4 */,
  0x02CC0300l /* 0x022CB8 */,
  0xF6030000l /* 0x022CBC */,
  0x0DFC0100l /* 0x022CC0 */,
  0x00FC0300l /* 0x022CC4 */,
  0xED030000l /* 0x022CC8 */,
  0xB8E60000l /* 0x022CCC */,
  0x03C80300l /* 0x022CD0 */,
  0xEE050000l /* 0x022CD4 */,
  0x1DEE0100l /* 0x022CD8 */,
  0x00F80300l /* 0x022CDC */,
  0xF1030000l /* 0x022CE0 */,
  0xCCB60000l /* 0x022CE4 */,
  0x03C80300l /* 0x022CE8 */,
  0xE8070000l /* 0x022CEC */,
  0x30D80100l /* 0x022CF0 */,
  0x01F00300l /* 0x022CF4 */,
  0xF5010000l /* 0x022CF8 */,
  0xDE8A0000l /* 0x022CFC */,
  0x03CA0300l /* 0x022D00 */,
  0xE5070000l /* 0x022D04 */,
  0x45BC0100l /* 0x022D08 */,
  0x00EA0300l /* 0x022D0C */,
  0xF8030000l /* 0x022D10 */,
  0xEC600000l /* 0x022D14 */,
  0x03D00300l /* 0x022D18 */,
  0xE4070000l /* 0x022D1C */,
  0x5B980100l /* 0x022D20 */,
  0x01E20300l /* 0x022D24 */,
  0xFC010000l /* 0x022D28 */,
  0xF73A0000l /* 0x022D2C */,
  0x02DC0300l /* 0x022D30 */,
  0xE4070000l /* 0x022D34 */,
  0x73700100l /* 0x022D38 */,
  0x01DA0300l /* 0x022D3C */,
  0xFE010000l /* 0x022D40 */,
  0xFE1A0000l /* 0x022D44 */,
  0x01EC0300l /* 0x022D48 */,
  0xE6050000l /* 0x022D4C */,
  0x8B440100l /* 0x022D50 */,
  0x02D20300l /* 0x022D54 */,
  0xDE130000l /* 0x022D58 */,
  0x44C60100l /* 0x022D5C */,
  0x04DC0300l /* 0x022D60 */,
  0xF1070000l /* 0x022D64 */,
  0xEA740000l /* 0x022D68 */,
  0x08C00300l /* 0x022D6C */,
  0xDB130000l /* 0x022D70 */,
  0x5BA60100l /* 0x022D74 */,
  0x05D20300l /* 0x022D78 */,
  0xF6050000l /* 0x022D7C */,
  0xF54C0000l /* 0x022D80 */,
  0x06CE0300l /* 0x022D84 */,
  0xDA130000l /* 0x022D88 */,
  0x72820100l /* 0x022D8C */,
  0x06C80300l /* 0x022D90 */,
  0xFB030000l /* 0x022D94 */,
  0xFC280000l /* 0x022D98 */,
  0x04E00300l /* 0x022D9C */,
  0xDC130000l /* 0x022DA0 */,
  0x88580100l /* 0x022DA4 */,
  0x07C00300l /* 0x022DA8 */,
  0xFF010000l /* 0x022DAC */,
  0xFF0A0000l /* 0x022DB0 */,
  0x01F80300l /* 0x022DB4 */,
  0xDE110000l /* 0x022DB8 */,
  0x9F2C0100l /* 0x022DBC */,
  0x08BA0300l /* 0x022DC0 */,
  0x01000000l /* 0x022DC4 */,
  0xFFF00300l /* 0x022DC8 */,
  0xFE150000l /* 0x022DCC */,
  0xE20F0000l /* 0x022DD0 */,
  0xB5FE0000l /* 0x022DD4 */,
  0x09B40300l /* 0x022DD8 */,
  0x02000000l /* 0x022DDC */,
  0xFADE0300l /* 0x022DE0 */,
  0xFC330000l /* 0x022DE4 */,
  0xE60D0000l /* 0x022DE8 */,
  0xC9CE0000l /* 0x022DEC */,
  0x09B60300l /* 0x022DF0 */,
  0x03000000l /* 0x022DF4 */,
  0xF1D20300l /* 0x022DF8 */,
  0xF9550000l /* 0x022DFC */,
  0xEB090000l /* 0x022E00 */,
  0xDAA40000l /* 0x022E04 */,
  0x09B80300l /* 0x022E08 */,
  0xDD110000l /* 0x022E0C */,
  0x9B360100l /* 0x022E10 */,
  0x08BA0300l /* 0x022E14 */,
  0x01000000l /* 0x022E18 */,
  0xFFF40300l /* 0x022E1C */,
  0xFF0F0000l /* 0x022E20 */,
  0xE10F0000l /* 0x022E24 */,
  0xB0080100l /* 0x022E28 */,
  0x09B60300l /* 0x022E2C */,
  0x02000000l /* 0x022E30 */,
  0xFCE20300l /* 0x022E34 */,
  0xFC2B0000l /* 0x022E38 */,
  0xE50D0000l /* 0x022E3C */,
  0xC5DA0000l /* 0x022E40 */,
  0x09B40300l /* 0x022E44 */,
  0x03000000l /* 0x022E48 */,
  0xF4D40300l /* 0x022E4C */,
  0xF94D0000l /* 0x022E50 */,
  0xEA0B0000l /* 0x022E54 */,
  0xD7AA0000l /* 0x022E58 */,
  0x09B80300l /* 0x022E5C */,
  0x04000000l /* 0x022E60 */,
  0xE6CC0300l /* 0x022E64 */,
  0xF6750000l /* 0x022E68 */,
  0xF0070000l /* 0x022E6C */,
  0xE6800000l /* 0x022E70 */,
  0x08BE0300l /* 0x022E74 */,
  0x04000000l /* 0x022E78 */,
  0xD7C60300l /* 0x022E7C */,
  0xF2A10000l /* 0x022E80 */,
  0xF5050000l /* 0x022E84 */,
  0xF2560000l /* 0x022E88 */,
  0x07CA0300l /* 0x022E8C */,
  0x03000000l /* 0x022E90 */,
  0xC5C60300l /* 0x022E94 */,
  0xEECF0000l /* 0x022E98 */,
  0xF9030000l /* 0x022E9C */,
  0xFB320000l /* 0x022EA0 */,
  0x05DA0300l /* 0x022EA4 */,
  0x03000000l /* 0x022EA8 */,
  0xB0C80300l /* 0x022EAC */,
  0xEBFD0000l /* 0x022EB0 */,
  0xFE010000l /* 0x022EB4 */,
  0xFF120000l /* 0x022EB8 */,
  0x02F00300l /* 0x022EBC */,
  0xEE090000l /* 0x022EC0 */,
  0xE3880000l /* 0x022EC4 */,
  0x09BC0300l /* 0x022EC8 */,
  0x04000000l /* 0x022ECC */,
  0xDAC80300l /* 0x022ED0 */,
  0xF3970000l /* 0x022ED4 */,
  0xF4050000l /* 0x022ED8 */,
  0xF0600000l /* 0x022EDC */,
  0x07C60300l /* 0x022EE0 */,
  0x04000000l /* 0x022EE4 */,
  0xC8C60300l /* 0x022EE8 */,
  0xEFC50000l /* 0x022EEC */,
  0xF8030000l /* 0x022EF0 */,
  0xFA3A0000l /* 0x022EF4 */,
  0x05D60300l /* 0x022EF8 */,
  0x03000000l /* 0x022EFC */,
  0xB4C80300l /* 0x022F00 */,
  0xECF30000l /* 0x022F04 */,
  0xFD030000l /* 0x022F08 */,
  0xFE160000l /* 0x022F0C */,
  0x03EC0300l /* 0x022F10 */,
  0x03000000l /* 0x022F14 */,
  0x9ECC0300l /* 0x022F18 */,
  0xE8230100l /* 0x022F1C */,
  0x00000000l /* 0x022F20 */,
  0xFFFA0300l /* 0x022F24 */,
  0x00080000l /* 0x022F28 */,
  0x02000000l /* 0x022F2C */,
  0x87D20300l /* 0x022F30 */,
  0xE6510100l /* 0x022F34 */,
  0x02000000l /* 0x022F38 */,
  0xFDE60300l /* 0x022F3C */,
  0xFD230000l /* 0x022F40 */,
  0x02000000l /* 0x022F44 */,
  0x6FDC0300l /* 0x022F48 */,
  0xE47B0100l /* 0x022F4C */,
  0x03000000l /* 0x022F50 */,
  0xF6D80300l /* 0x022F54 */,
  0xFA430000l /* 0x022F58 */,
  0x01000000l /* 0x022F5C */,
  0x58E40300l /* 0x022F60 */,
  0xE4A30100l /* 0x022F64 */,
  0x03000000l /* 0x022F68 */,
  0xEBCE0300l /* 0x022F6C */,
  0xF7690000l /* 0x022F70 */,
  0x00000000l /* 0x022F74 */,
  0x11C49501l /* 0x022F78 */,
  0x00481E00l /* 0x022F7C */,
  0x00000000l /* 0x022F80 */,
  0x00FE0100l /* 0x022F84 */,
  0x00000000l /* 0x022F88 */,
  0xEB050000l /* 0x022F8C */,
  0xAB000100l /* 0x022F90 */,
  0x03CA0300l /* 0x022F94 */,
  0xEE050000l /* 0x022F98 */,
  0x1CF00100l /* 0x022F9C */,
  0x00F80300l /* 0x022FA0 */,
  0xF2030000l /* 0x022FA4 */,
  0xD1AA0000l /* 0x022FA8 */,
  0x03C80300l /* 0x022FAC */,
  0xE5070000l /* 0x022FB0 */,
  0x40C40100l /* 0x022FB4 */,
  0x00EC0300l /* 0x022FB8 */,
  0xF9010000l /* 0x022FBC */,
  0xEE5A0000l /* 0x022FC0 */,
  0x03D20300l /* 0x022FC4 */,
  0xE4070000l /* 0x022FC8 */,
  0x6A800100l /* 0x022FCC */,
  0x01DC0300l /* 0x022FD0 */,
  0xFE010000l /* 0x022FD4 */,
  0xFE1A0000l /* 0x022FD8 */,
  0x01EC0300l /* 0x022FDC */,
  0xE8050000l /* 0x022FE0 */,
  0x962C0100l /* 0x022FE4 */,
  0x02D00300l /* 0x022FE8 */,
  0xF6030000l /* 0x022FEC */,
  0x0DFC0100l /* 0x022FF0 */,
  0x00FC0300l /* 0x022FF4 */,
  0xEE030000l /* 0x022FF8 */,
  0xC0D40000l /* 0x022FFC */,
  0x03C80300l /* 0x023000 */,
  0xE9070000l /* 0x023004 */,
  0x2DDC0100l /* 0x023008 */,
  0x00F20300l /* 0x02300C */,
  0xF6010000l /* 0x023010 */,
  0xE2800000l /* 0x023014 */,
  0x03CA0300l /* 0x023018 */,
  0xE4070000l /* 0x02301C */,
  0x55A20100l /* 0x023020 */,
  0x01E40300l /* 0x023024 */,
  0xFC010000l /* 0x023028 */,
  0xF8380000l /* 0x02302C */,
  0x02DC0300l /* 0x023030 */,
  0xE5070000l /* 0x023034 */,
  0x80560100l /* 0x023038 */,
  0x02D60300l /* 0x02303C */,
  0xDE130000l /* 0x023040 */,
  0x44C60100l /* 0x023044 */,
  0x04DC0300l /* 0x023048 */,
  0xF3070000l /* 0x02304C */,
  0xEF620000l /* 0x023050 */,
  0x07C60300l /* 0x023054 */,
  0xDA130000l /* 0x023058 */,
  0x6F860100l /* 0x02305C */,
  0x06CA0300l /* 0x023060 */,
  0xFC030000l /* 0x023064 */,
  0xFD1E0000l /* 0x023068 */,
  0x03E80300l /* 0x02306C */,
  0xDD110000l /* 0x023070 */,
  0x9A360100l /* 0x023074 */,
  0x08BC0300l /* 0x023078 */,
  0x02000000l /* 0x02307C */,
  0xFEEC0300l /* 0x023080 */,
  0xFE190000l /* 0x023084 */,
  0xE50D0000l /* 0x023088 */,
  0xC2E00000l /* 0x02308C */,
  0x09B40300l /* 0x023090 */,
  0x03000000l /* 0x023094 */,
  0xEFD20300l /* 0x023098 */,
  0xF9590000l /* 0x02309C */,
  0xEE090000l /* 0x0230A0 */,
  0xE28A0000l /* 0x0230A4 */,
  0x09BC0300l /* 0x0230A8 */,
  0xDB130000l /* 0x0230AC */,
  0x58AA0100l /* 0x0230B0 */,
  0x05D40300l /* 0x0230B4 */,
  0xF8050000l /* 0x0230B8 */,
  0xF73E0000l /* 0x0230BC */,
  0x06D40300l /* 0x0230C0 */,
  0xDB130000l /* 0x0230C4 */,
  0x83620100l /* 0x0230C8 */,
  0x07C20300l /* 0x0230CC */,
  0x00000000l /* 0x0230D0 */,
  0xFF020000l /* 0x0230D4 */,
  0x00FE0300l /* 0x0230D8 */,
  0xE00F0000l /* 0x0230DC */,
  0xAD100100l /* 0x0230E0 */,
  0x09B60300l /* 0x0230E4 */,
  0x03000000l /* 0x0230E8 */,
  0xF8DE0300l /* 0x0230EC */,
  0xFC350000l /* 0x0230F0 */,
  0xE90B0000l /* 0x0230F4 */,
  0xD2B80000l /* 0x0230F8 */,
  0x09B60300l /* 0x0230FC */,
  0xDD110000l /* 0x023100 */,
  0x9B360100l /* 0x023104 */,
  0x08BA0300l /* 0x023108 */,
  0x02000000l /* 0x02310C */,
  0xFDEC0300l /* 0x023110 */,
  0xFE1B0000l /* 0x023114 */,
  0xE50D0000l /* 0x023118 */,
  0xC2E00000l /* 0x02311C */,
  0x09B40300l /* 0x023120 */,
  0x03000000l /* 0x023124 */,
  0xF0D00300l /* 0x023128 */,
  0xF85B0000l /* 0x02312C */,
  0xEE090000l /* 0x023130 */,
  0xE28A0000l /* 0x023134 */,
  0x09BC0300l /* 0x023138 */,
  0x04000000l /* 0x02313C */,
  0xD3C60300l /* 0x023140 */,
  0xF2A90000l /* 0x023144 */,
  0xF8050000l /* 0x023148 */,
  0xF73E0000l /* 0x02314C */,
  0x06D40300l /* 0x023150 */,
  0x03000000l /* 0x023154 */,
  0xAECA0300l /* 0x023158 */,
  0xEA010100l /* 0x02315C */,
  0x00000000l /* 0x023160 */,
  0xFF020000l /* 0x023164 */,
  0x00FE0300l /* 0x023168 */,
  0xE00F0000l /* 0x02316C */,
  0xAE0E0100l /* 0x023170 */,
  0x09B60300l /* 0x023174 */,
  0x03000000l /* 0x023178 */,
  0xF9DC0300l /* 0x02317C */,
  0xFC350000l /* 0x023180 */,
  0xE90B0000l /* 0x023184 */,
  0xD2B80000l /* 0x023188 */,
  0x09B60300l /* 0x02318C */,
  0x04000000l /* 0x023190 */,
  0xE3CA0300l /* 0x023194 */,
  0xF57F0000l /* 0x023198 */,
  0xF3070000l /* 0x02319C */,
  0xEE640000l /* 0x0231A0 */,
  0x08C40300l /* 0x0231A4 */,
  0x03000000l /* 0x0231A8 */,
  0xC3C60300l /* 0x0231AC */,
  0xEED30000l /* 0x0231B0 */,
  0xFC030000l /* 0x0231B4 */,
  0xFD200000l /* 0x0231B8 */,
  0x03E60300l /* 0x0231BC */,
  0xEE090000l /* 0x0231C0 */,
  0xE3880000l /* 0x0231C4 */,
  0x09BC0300l /* 0x0231C8 */,
  0x04000000l /* 0x0231CC */,
  0xD3C60300l /* 0x0231D0 */,
  0xF1AB0000l /* 0x0231D4 */,
  0xF8050000l /* 0x0231D8 */,
  0xF83C0000l /* 0x0231DC */,
  0x06D40300l /* 0x0231E0 */,
  0x03000000l /* 0x0231E4 */,
  0xADCA0300l /* 0x0231E8 */,
  0xEA030100l /* 0x0231EC */,
  0x00000000l /* 0x0231F0 */,
  0xFF000000l /* 0x0231F4 */,
  0x00000000l /* 0x0231F8 */,
  0x02000000l /* 0x0231FC */,
  0x82D40300l /* 0x023200 */,
  0xE6590100l /* 0x023204 */,
  0x03000000l /* 0x023208 */,
  0xF8DC0300l /* 0x02320C */,
  0xFC370000l /* 0x023210 */,
  0x01000000l /* 0x023214 */,
  0x57E40300l /* 0x023218 */,
  0xE4A50100l /* 0x02321C */,
  0x04000000l /* 0x023220 */,
  0xE3CA0300l /* 0x023224 */,
  0xF57F0000l /* 0x023228 */,
  0xF3070000l /* 0x02322C */,
  0xEE620000l /* 0x023230 */,
  0x08C60300l /* 0x023234 */,
  0x03000000l /* 0x023238 */,
  0xC2C60300l /* 0x02323C */,
  0xEFD30000l /* 0x023240 */,
  0xFC030000l /* 0x023244 */,
  0xFD200000l /* 0x023248 */,
  0x03E60300l /* 0x02324C */,
  0x03000000l /* 0x023250 */,
  0x99CE0300l /* 0x023254 */,
  0xE82B0100l /* 0x023258 */,
  0x01000000l /* 0x02325C */,
  0xFFEE0300l /* 0x023260 */,
  0xFE170000l /* 0x023264 */,
  0x02000000l /* 0x023268 */,
  0x6EDA0300l /* 0x02326C */,
  0xE47F0100l /* 0x023270 */,
  0x03000000l /* 0x023274 */,
  0xF0D20300l /* 0x023278 */,
  0xF9570000l /* 0x02327C */,
  0x0E4C5802l /* 0x023280 */,
  0xAB6A0A00l /* 0x023284 */,
  0xDE130000l /* 0x023288 */,
  0x44C60100l /* 0x02328C */,
  0x04DC0300l /* 0x023290 */,
  0x02000000l /* 0x023294 */,
  0xFDE60300l /* 0x023298 */,
  0xFD230000l /* 0x02329C */,
  0xFB030000l /* 0x0232A0 */,
  0xFC280000l /* 0x0232A4 */,
  0x04E00300l /* 0x0232A8 */,
  0xEE090000l /* 0x0232AC */,
  0xE3880000l /* 0x0232B0 */,
  0x09BC0300l /* 0x0232B4 */,
  0xE20F0000l /* 0x0232B8 */,
  0xB5FC0000l /* 0x0232BC */,
  0x09B60300l /* 0x0232C0 */,
  0xDB130000l /* 0x0232C4 */,
  0x7D6C0100l /* 0x0232C8 */,
  0x07C40300l /* 0x0232CC */,
  0xDE130000l /* 0x0232D0 */,
  0x44C60100l /* 0x0232D4 */,
  0x04DC0300l /* 0x0232D8 */,
  0x02000000l /* 0x0232DC */,
  0xFDE60300l /* 0x0232E0 */,
  0xFD230000l /* 0x0232E4 */,
  0xFB030000l /* 0x0232E8 */,
  0xFC280000l /* 0x0232EC */,
  0x04E00300l /* 0x0232F0 */,
  0xEE090000l /* 0x0232F4 */,
  0xE3880000l /* 0x0232F8 */,
  0x09BC0300l /* 0x0232FC */,
  0xE20F0000l /* 0x023300 */,
  0xB5FC0000l /* 0x023304 */,
  0x09B60300l /* 0x023308 */,
  0xDB130000l /* 0x02330C */,
  0x7D6C0100l /* 0x023310 */,
  0x07C40300l /* 0x023314 */,
  0xDD110000l /* 0x023318 */,
  0x9B360100l /* 0x02331C */,
  0x08BA0300l /* 0x023320 */,
  0x04000000l /* 0x023324 */,
  0xCDC60300l /* 0x023328 */,
  0xF0B90000l /* 0x02332C */,
  0x03000000l /* 0x023330 */,
  0xF3D40300l /* 0x023334 */,
  0xF94F0000l /* 0x023338 */,
  0x00000000l /* 0x02333C */,
  0xFF000000l /* 0x023340 */,
  0x00000000l /* 0x023344 */,
  0xF5050000l /* 0x023348 */,
  0xF2560000l /* 0x02334C */,
  0x07CA0300l /* 0x023350 */,
  0xE80B0000l /* 0x023354 */,
  0xCEC20000l /* 0x023358 */,
  0x09B60300l /* 0x02335C */,
  0xEE090000l /* 0x023360 */,
  0xE3880000l /* 0x023364 */,
  0x09BC0300l /* 0x023368 */,
  0x02000000l /* 0x02336C */,
  0x7AD60300l /* 0x023370 */,
  0xE5690100l /* 0x023374 */,
  0x03000000l /* 0x023378 */,
  0xB4C80300l /* 0x02337C */,
  0xEBF50000l /* 0x023380 */,
  0x04000000l /* 0x023384 */,
  0xE2CA0300l /* 0x023388 */,
  0xF5810000l /* 0x02338C */,
  0x02000000l /* 0x023390 */,
  0xFDE60300l /* 0x023394 */,
  0xFD230000l /* 0x023398 */,
  0xFB030000l /* 0x02339C */,
  0xFC280000l /* 0x0233A0 */,
  0x04E00300l /* 0x0233A4 */,
  0x0F709001l /* 0x0233A8 */,
  0x1D471000l /* 0x0233AC */,
  0x00000000l /* 0x0233B0 */,
  0x00FE0100l /* 0x0233B4 */,
  0x00000000l /* 0x0233B8 */,
  0xEB050000l /* 0x0233BC */,
  0xAA020100l /* 0x0233C0 */,
  0x03CA0300l /* 0x0233C4 */,
  0xF0050000l /* 0x0233C8 */,
  0x17F20100l /* 0x0233CC */,
  0x01FA0300l /* 0x0233D0 */,
  0xF1030000l /* 0x0233D4 */,
  0xCDB40000l /* 0x0233D8 */,
  0x03C80300l /* 0x0233DC */,
  0xE7070000l /* 0x0233E0 */,
  0x36D00100l /* 0x0233E4 */,
  0x01EE0300l /* 0x0233E8 */,
  0xF7030000l /* 0x0233EC */,
  0xE86C0000l /* 0x0233F0 */,
  0x03CE0300l /* 0x0233F4 */,
  0xE4070000l /* 0x0233F8 */,
  0x5A9A0100l /* 0x0233FC */,
  0x01E20300l /* 0x023400 */,
  0xFD030000l /* 0x023404 */,
  0xF92E0000l /* 0x023408 */,
  0x02E00300l /* 0x02340C */,
  0xE5070000l /* 0x023410 */,
  0x81540100l /* 0x023414 */,
  0x02D60300l /* 0x023418 */,
  0xDE130000l /* 0x02341C */,
  0x44C60100l /* 0x023420 */,
  0x04DC0300l /* 0x023424 */,
  0xF3070000l /* 0x023428 */,
  0xEE640000l /* 0x02342C */,
  0x08C40300l /* 0x023430 */,
  0xDA130000l /* 0x023434 */,
  0x6A8E0100l /* 0x023438 */,
  0x06CC0300l /* 0x02343C */,
  0xFB030000l /* 0x023440 */,
  0xFC280000l /* 0x023444 */,
  0x04E00300l /* 0x023448 */,
  0xDC110000l /* 0x02344C */,
  0x91480100l /* 0x023450 */,
  0x08BE0300l /* 0x023454 */,
  0x01000000l /* 0x023458 */,
  0xFFF80300l /* 0x02345C */,
  0xFF0B0000l /* 0x023460 */,
  0xE20F0000l /* 0x023464 */,
  0xB4FE0000l /* 0x023468 */,
  0x09B60300l /* 0x02346C */,
  0x03000000l /* 0x023470 */,
  0xF7DA0300l /* 0x023474 */,
  0xFB3D0000l /* 0x023478 */,
  0xEA0B0000l /* 0x02347C */,
  0xD4B20000l /* 0x023480 */,
  0x09B60300l /* 0x023484 */,
  0xDD110000l /* 0x023488 */,
  0x9B360100l /* 0x02348C */,
  0x08BA0300l /* 0x023490 */,
  0x01000000l /* 0x023494 */,
  0xFFEE0300l /* 0x023498 */,
  0xFE170000l /* 0x02349C */,
  0xE40D0000l /* 0x0234A0 */,
  0xBEEA0000l /* 0x0234A4 */,
  0x09B40300l /* 0x0234A8 */,
  0x03000000l /* 0x0234AC */,
  0xF4D40300l /* 0x0234B0 */,
  0xF94D0000l /* 0x0234B4 */,
  0x04000000l /* 0x0234B8 */,
  0x4FD80300l /* 0x0234BC */,
  0xDDBB0100l /* 0x0234C0 */,
  0x00120000l /* 0x0234C4 */,
  0xE4090000l /* 0x0234C8 */,
  0x48B80100l /* 0x0234CC */,
  0x02E80300l /* 0x0234D0 */,
  0x2DEA0300l /* 0x0234D4 */,
  0xE5E90100l /* 0x0234D8 */,
  0x030E0000l /* 0x0234DC */,
  0xBEC60300l /* 0x0234E0 */,
  0xEDDF0000l /* 0x0234E4 */,
  0xFC030000l /* 0x0234E8 */,
  0xFE1C0000l /* 0x0234EC */,
  0x03E80300l /* 0x0234F0 */,
  0xEE090000l /* 0x0234F4 */,
  0xE58C0000l /* 0x0234F8 */,
  0x09BC0300l /* 0x0234FC */,
  0x04000000l /* 0x023500 */,
  0xD4C60300l /* 0x023504 */,
  0xF2A70000l /* 0x023508 */,
  0xF7050000l /* 0x02350C */,
  0xF6460000l /* 0x023510 */,
  0x06D00300l /* 0x023514 */,
  0x03000000l /* 0x023518 */,
  0xB4C80300l /* 0x02351C */,
  0xECF30000l /* 0x023520 */,
  0xFE010000l /* 0x023524 */,
  0xFF0E0000l /* 0x023528 */,
  0x02F40300l /* 0x02352C */,
  0x02000000l /* 0x023530 */,
  0x8DD00300l /* 0x023534 */,
  0xE53D0100l /* 0x023538 */,
  0x02000000l /* 0x02353C */,
  0xFDE60300l /* 0x023540 */,
  0xFD230000l /* 0x023544 */,
  0x01000000l /* 0x023548 */,
  0x68DE0300l /* 0x02354C */,
  0xE4890100l /* 0x023550 */,
  0x03000000l /* 0x023554 */,
  0xEFD00300l /* 0x023558 */,
  0xF85D0000l /* 0x02355C */,
  0x1010D002l /* 0x023560 */,
  0x00800100l /* 0x023564 */,
  0x3F2E0000l /* 0x023568 */,
  0x3FA80000l /* 0x02356C */,
  0x002E0000l /* 0x023570 */,
  0x351C0000l /* 0x023574 */,
  0x48A60000l /* 0x023578 */,
  0x02400000l /* 0x02357C */,
  0x2A0E0000l /* 0x023580 */,
  0x4F9E0000l /* 0x023584 */,
  0x07540000l /* 0x023588 */,
  0x20040000l /* 0x02358C */,
  0x53900000l /* 0x023590 */,
  0x0E6A0000l /* 0x023594 */,
  0x1164D002l /* 0x023598 */,
  0x00900E00l /* 0x02359C */,
  0x15F20300l /* 0x0235A0 */,
  0x15C80100l /* 0x0235A4 */,
  0x00F20300l /* 0x0235A8 */,
  0x00FA0300l /* 0x0235AC */,
  0x31BC0100l /* 0x0235B0 */,
  0x01E60300l /* 0x0235B4 */,
  0xF2010000l /* 0x0235B8 */,
  0x519C0100l /* 0x0235BC */,
  0x02DA0300l /* 0x0235C0 */,
  0xEA050000l /* 0x0235C4 */,
  0x74680100l /* 0x0235C8 */,
  0x03D20300l /* 0x0235CC */,
  0xE7070000l /* 0x0235D0 */,
  0x962C0100l /* 0x0235D4 */,
  0x03CE0300l /* 0x0235D8 */,
  0xE9070000l /* 0x0235DC */,
  0xB4E80000l /* 0x0235E0 */,
  0x02D40300l /* 0x0235E4 */,
  0xED050000l /* 0x0235E8 */,
  0xCEA20000l /* 0x0235EC */,
  0x00E40300l /* 0x0235F0 */,
  0xF3030000l /* 0x0235F4 */,
  0xDE620000l /* 0x0235F8 */,
  0xFD010000l /* 0x0235FC */,
  0xF2010000l /* 0x023600 */,
  0x519C0100l /* 0x023604 */,
  0x02DA0300l /* 0x023608 */,
  0xEA050000l /* 0x02360C */,
  0x74680100l /* 0x023610 */,
  0x03D20300l /* 0x023614 */,
  0xE7070000l /* 0x023618 */,
  0x962C0100l /* 0x02361C */,
  0x03CE0300l /* 0x023620 */,
  0xE9070000l /* 0x023624 */,
  0xB4E80000l /* 0x023628 */,
  0x02D40300l /* 0x02362C */,
  0xED050000l /* 0x023630 */,
  0xCEA20000l /* 0x023634 */,
  0x00E40300l /* 0x023638 */,
  0xF3030000l /* 0x02363C */,
  0xDE620000l /* 0x023640 */,
  0xFD010000l /* 0x023644 */,
  0xFE010000l /* 0x023648 */,
  0xE4200000l /* 0x02364C */,
  0xFE210000l /* 0x023650 */,
  0x00000000l /* 0x023654 */,
  0xDD000000l /* 0x023658 */,
  0xFC4F0000l /* 0x02365C */,
  0xE7070000l /* 0x023660 */,
  0x962C0100l /* 0x023664 */,
  0x03CE0300l /* 0x023668 */,
  0xE9070000l /* 0x02366C */,
  0xB4E80000l /* 0x023670 */,
  0x02D40300l /* 0x023674 */,
  0xED050000l /* 0x023678 */,
  0xCEA20000l /* 0x02367C */,
  0x00E40300l /* 0x023680 */,
  0xF3030000l /* 0x023684 */,
  0xDE620000l /* 0x023688 */,
  0xFD010000l /* 0x02368C */,
  0xFE010000l /* 0x023690 */,
  0xE4200000l /* 0x023694 */,
  0xFE210000l /* 0x023698 */,
  0x00000000l /* 0x02369C */,
  0xDD000000l /* 0x0236A0 */,
  0xFC4F0000l /* 0x0236A4 */,
  0x00000000l /* 0x0236A8 */,
  0xCBEE0300l /* 0x0236AC */,
  0xF98B0000l /* 0x0236B0 */,
  0x00000000l /* 0x0236B4 */,
  0xAEE80300l /* 0x0236B8 */,
  0xF6D10000l /* 0x0236BC */,
  0xED050000l /* 0x0236C0 */,
  0xCEA20000l /* 0x0236C4 */,
  0x00E40300l /* 0x0236C8 */,
  0xF3030000l /* 0x0236CC */,
  0xDE620000l /* 0x0236D0 */,
  0xFD010000l /* 0x0236D4 */,
  0xFE010000l /* 0x0236D8 */,
  0xE4200000l /* 0x0236DC */,
  0xFE210000l /* 0x0236E0 */,
  0x00000000l /* 0x0236E4 */,
  0xDD000000l /* 0x0236E8 */,
  0xFC4F0000l /* 0x0236EC */,
  0x00000000l /* 0x0236F0 */,
  0xCBEE0300l /* 0x0236F4 */,
  0xF98B0000l /* 0x0236F8 */,
  0xF4010000l /* 0x0236FC */,
  0x685C0100l /* 0x023700 */,
  0x00EC0300l /* 0x023704 */,
  0xF4010000l /* 0x023708 */,
  0x8C180100l /* 0x02370C */,
  0x00E80300l /* 0x023710 */,
  0xF6010000l /* 0x023714 */,
  0xAED00000l /* 0x023718 */,
  0xAEE80300l /* 0x02371C */,
  0x00000000l /* 0x023720 */,
  0x1334B400l /* 0x023724 */,
  0x00200600l /* 0x023728 */,
  0x00000000l /* 0x02372C */,
  0x00FE0100l /* 0x023730 */,
  0x00000000l /* 0x023734 */,
  0xE5090000l /* 0x023738 */,
  0x40C20100l /* 0x02373C */,
  0x01EA0300l /* 0x023740 */,
  0xE7070000l /* 0x023744 */,
  0x962C0100l /* 0x023748 */,
  0x03CE0300l /* 0x02374C */,
  0xF5030000l /* 0x023750 */,
  0xE1800000l /* 0x023754 */,
  0x04CA0300l /* 0x023758 */,
  0x14645A00l /* 0x02375C */,
  0x00100E00l /* 0x023760 */,
  0x00000000l /* 0x023764 */,
  0x00FE0100l /* 0x023768 */,
  0x00000000l /* 0x02376C */,
  0xEE070000l /* 0x023770 */,
  0x1CF00100l /* 0x023774 */,
  0x00F60300l /* 0x023778 */,
  0xE5090000l /* 0x02377C */,
  0x40C20100l /* 0x023780 */,
  0x01EA0300l /* 0x023784 */,
  0xE3070000l /* 0x023788 */,
  0x6A800100l /* 0x02378C */,
  0x02DC0300l /* 0x023790 */,
  0xE7070000l /* 0x023794 */,
  0x962C0100l /* 0x023798 */,
  0x03CE0300l /* 0x02379C */,
  0xEE050000l /* 0x0237A0 */,
  0xC0D40000l /* 0x0237A4 */,
  0x03C60300l /* 0x0237A8 */,
  0xF5030000l /* 0x0237AC */,
  0xE1800000l /* 0x0237B0 */,
  0x04CA0300l /* 0x0237B4 */,
  0xFB010000l /* 0x0237B8 */,
  0xF8380000l /* 0x0237BC */,
  0x03DC0300l /* 0x0237C0 */,
  0x15C48700l /* 0x0237C4 */,
  0x00181E00l /* 0x0237C8 */,
  0x00000000l /* 0x0237CC */,
  0x00FE0100l /* 0x0237D0 */,
  0x00000000l /* 0x0237D4 */,
  0xE8070000l /* 0x0237D8 */,
  0x2DE00100l /* 0x0237DC */,
  0x00F00300l /* 0x0237E0 */,
  0xE3070000l /* 0x0237E4 */,
  0x6A800100l /* 0x0237E8 */,
  0x02DC0300l /* 0x0237EC */,
  0xEA050000l /* 0x0237F0 */,
  0xAB020100l /* 0x0237F4 */,
  0x03CA0300l /* 0x0237F8 */,
  0xF5030000l /* 0x0237FC */,
  0xE0820000l /* 0x023800 */,
  0x04CA0300l /* 0x023804 */,
  0xFE010000l /* 0x023808 */,
  0xFE1A0000l /* 0x02380C */,
  0x02EA0300l /* 0x023810 */,
  0xEE070000l /* 0x023814 */,
  0x1BF40100l /* 0x023818 */,
  0x00F80300l /* 0x02381C */,
  0xE3090000l /* 0x023820 */,
  0x53A60100l /* 0x023824 */,
  0x01E40300l /* 0x023828 */,
  0xE7070000l /* 0x02382C */,
  0x952E0100l /* 0x023830 */,
  0x03CE0300l /* 0x023834 */,
  0xF1030000l /* 0x023838 */,
  0xD1AC0000l /* 0x02383C */,
  0x04C60300l /* 0x023840 */,
  0xFB010000l /* 0x023844 */,
  0xF83A0000l /* 0x023848 */,
  0x03DA0300l /* 0x02384C */,
  0xF7030000l /* 0x023850 */,
  0x0BFE0100l /* 0x023854 */,
  0x00FC0300l /* 0x023858 */,
  0xE5090000l /* 0x02385C */,
  0x3EC60100l /* 0x023860 */,
  0x01EA0300l /* 0x023864 */,
  0xE5070000l /* 0x023868 */,
  0x7E5A0100l /* 0x02386C */,
  0x02D60300l /* 0x023870 */,
  0xED050000l /* 0x023874 */,
  0xBEDA0000l /* 0x023878 */,
  0x03C60300l /* 0x02387C */,
  0xF8010000l /* 0x023880 */,
  0xEE5E0000l /* 0x023884 */,
  0x03D00300l /* 0x023888 */,
  0x16884100l /* 0x02388C */,
  0xA30B1400l /* 0x023890 */,
  0x00000000l /* 0x023894 */,
  0x00FE0100l /* 0x023898 */,
  0x00000000l /* 0x02389C */,
  0xF2050000l /* 0x0238A0 */,
  0x13F80100l /* 0x0238A4 */,
  0x00FA0300l /* 0x0238A8 */,
  0xE9070000l /* 0x0238AC */,
  0x2BE00100l /* 0x0238B0 */,
  0x00F20300l /* 0x0238B4 */,
  0xE4090000l /* 0x0238B8 */,
  0x46BA0100l /* 0x0238BC */,
  0x01E80300l /* 0x0238C0 */,
  0xE3070000l /* 0x0238C4 */,
  0x658A0100l /* 0x0238C8 */,
  0x01DE0300l /* 0x0238CC */,
  0xE5070000l /* 0x0238D0 */,
  0x854E0100l /* 0x0238D4 */,
  0x02D40300l /* 0x0238D8 */,
  0xE9050000l /* 0x0238DC */,
  0xA5100100l /* 0x0238E0 */,
  0x03CA0300l /* 0x0238E4 */,
  0xEE050000l /* 0x0238E8 */,
  0xC2D00000l /* 0x0238EC */,
  0x03C60300l /* 0x0238F0 */,
  0xF3030000l /* 0x0238F4 */,
  0xDA940000l /* 0x0238F8 */,
  0x04C80300l /* 0x0238FC */,
  0xF8010000l /* 0x023900 */,
  0xEF5C0000l /* 0x023904 */,
  0x03D00300l /* 0x023908 */,
  0xFC010000l /* 0x02390C */,
  0xFC2A0000l /* 0x023910 */,
  0x02E20300l /* 0x023914 */,
  0x68040000l /* 0x023918 */,
  0x43040000l /* 0x02391C */,
  0x67040000l /* 0x023920 */,
  0x00200200l /* 0x023924 */,
  0x68040000l /* 0x023928 */,
  0x41040000l /* 0x02392C */,
  0x65040000l /* 0x023930 */,
  0x00200200l /* 0x023934 */,
  0x68040000l /* 0x023938 */,
  0x641C0000l /* 0x02393C */,
  0xC2110000l /* 0x023940 */,
  0xE7020000l /* 0x023944 */,
  0x00200300l /* 0x023948 */,
  0x68040000l /* 0x02394C */,
  0x631C0000l /* 0x023950 */,
  0xC0110000l /* 0x023954 */,
  0xE6020000l /* 0x023958 */,
  0x00200300l /* 0x02395C */,
  0x68040000l /* 0x023960 */,
  0x64040000l /* 0x023964 */,
  0x42140000l /* 0x023968 */,
  0xE7020000l /* 0x02396C */,
  0x00200300l /* 0x023970 */,
  0x68040000l /* 0x023974 */,
  0x63040000l /* 0x023978 */,
  0x40140000l /* 0x02397C */,
  0xE6030000l /* 0x023980 */,
  0x00200300l /* 0x023984 */,
  0x68140000l /* 0x023988 */,
  0xC2120000l /* 0x02398C */,
  0xC4110000l /* 0x023990 */,
  0x67000000l /* 0x023994 */,
  0x00200300l /* 0x023998 */,
  0x00000000l /* 0x02399C */,
  0x68040000l /* 0x0239A0 */,
  0x40140000l /* 0x0239A4 */,
  0x42120000l /* 0x0239A8 */,
  0xC4000000l /* 0x0239AC */,
  0xE7130000l /* 0x0239B0 */,
  0x00200300l /* 0x0239B4 */,
  0x68140000l /* 0x0239B8 */,
  0xC2130000l /* 0x0239BC */,
  0xE6120000l /* 0x0239C0 */,
  0x41120000l /* 0x0239C4 */,
  0xE4110000l /* 0x0239C8 */,
  0xC0100000l /* 0x0239CC */,
  0x43000000l /* 0x0239D0 */,
  0xE6130000l /* 0x0239D4 */,
  0xC2120000l /* 0x0239D8 */,
  0x65120000l /* 0x0239DC */,
  0xC0110000l /* 0x0239E0 */,
  0xC4100000l /* 0x0239E4 */,
  0x67000000l /* 0x0239E8 */,
  0x00200C00l /* 0x0239EC */,
  0x68040000l /* 0x0239F0 */,
  0x40140000l /* 0x0239F4 */,
  0x43130000l /* 0x0239F8 */,
  0xE7120000l /* 0x0239FC */,
  0xC2110000l /* 0x023A00 */,
  0x65110000l /* 0x023A04 */,
  0x41000000l /* 0x023A08 */,
  0x44140000l /* 0x023A0C */,
  0x67130000l /* 0x023A10 */,
  0xC3120000l /* 0x023A14 */,
  0xE6110000l /* 0x023A18 */,
  0x41110000l /* 0x023A1C */,
  0x65000000l /* 0x023A20 */,
  0x00200C00l /* 0x023A24 */,
  0x68140000l /* 0x023A28 */,
  0xC2120000l /* 0x023A2C */,
  0x44010000l /* 0x023A30 */,
  0xC7130000l /* 0x023A34 */,
  0x41120000l /* 0x023A38 */,
  0xC4000000l /* 0x023A3C */,
  0x66130000l /* 0x023A40 */,
  0xC1110000l /* 0x023A44 */,
  0x43000000l /* 0x023A48 */,
  0xE6120000l /* 0x023A4C */,
  0x40010000l /* 0x023A50 */,
  0xC3130000l /* 0x023A54 */,
  0x65120000l /* 0x023A58 */,
  0xC0000000l /* 0x023A5C */,
  0x42130000l /* 0x023A60 */,
  0xC5110000l /* 0x023A64 */,
  0x67000000l /* 0x023A68 */,
  0x00201000l /* 0x023A6C */,
  0x00000000l /* 0x023A70 */,
  0x68040000l /* 0x023A74 */,
  0x40140000l /* 0x023A78 */,
  0x41120000l /* 0x023A7C */,
  0xC4000000l /* 0x023A80 */,
  0x66130000l /* 0x023A84 */,
  0xC1110000l /* 0x023A88 */,
  0x43000000l /* 0x023A8C */,
  0xC6120000l /* 0x023A90 */,
  0x40010000l /* 0x023A94 */,
  0xC3130000l /* 0x023A98 */,
  0x65120000l /* 0x023A9C */,
  0xC0000000l /* 0x023AA0 */,
  0x42130000l /* 0x023AA4 */,
  0xC5110000l /* 0x023AA8 */,
  0x67000000l /* 0x023AAC */,
  0xC2120000l /* 0x023AB0 */,
  0x44010000l /* 0x023AB4 */,
  0xE7130000l /* 0x023AB8 */,
  0x00201000l /* 0x023ABC */,
  0x68140000l /* 0x023AC0 */,
  0x41130000l /* 0x023AC4 */,
  0x65130000l /* 0x023AC8 */,
  0x00200200l /* 0x023ACC */,
  0x68140000l /* 0x023AD0 */,
  0x43110000l /* 0x023AD4 */,
  0x67110000l /* 0x023AD8 */,
  0x00200200l /* 0x023ADC */,
  0x68140000l /* 0x023AE0 */,
  0xC1120000l /* 0x023AE4 */,
  0x44120000l /* 0x023AE8 */,
  0x67110000l /* 0x023AEC */,
  0xC3100000l /* 0x023AF0 */,
  0x66000000l /* 0x023AF4 */,
  0xC7130000l /* 0x023AF8 */,
  0xE5120000l /* 0x023AFC */,
  0x40120000l /* 0x023B00 */,
  0x43110000l /* 0x023B04 */,
  0xE7100000l /* 0x023B08 */,
  0x42000000l /* 0x023B0C */,
  0xE5130000l /* 0x023B10 */,
  0x00200C00l /* 0x023B14 */,
  0x68140000l /* 0x023B18 */,
  0x42000000l /* 0x023B1C */,
  0xE6130000l /* 0x023B20 */,
  0x41130000l /* 0x023B24 */,
  0x64120000l /* 0x023B28 */,
  0xC0110000l /* 0x023B2C */,
  0x43110000l /* 0x023B30 */,
  0x66000000l /* 0x023B34 */,
  0xC2130000l /* 0x023B38 */,
  0x65130000l /* 0x023B3C */,
  0x40120000l /* 0x023B40 */,
  0xC4110000l /* 0x023B44 */,
  0x67110000l /* 0x023B48 */,
  0x00200C00l /* 0x023B4C */,
  0x68140000l /* 0x023B50 */,
  0xC2130000l /* 0x023B54 */,
  0xE6120000l /* 0x023B58 */,
  0x41120000l /* 0x023B5C */,
  0xE4110000l /* 0x023B60 */,
  0xC0100000l /* 0x023B64 */,
  0x43000000l /* 0x023B68 */,
  0xE6130000l /* 0x023B6C */,
  0xC2120000l /* 0x023B70 */,
  0x65120000l /* 0x023B74 */,
  0xC0110000l /* 0x023B78 */,
  0xC4100000l /* 0x023B7C */,
  0x67100000l /* 0x023B80 */,
  0x00200C00l /* 0x023B84 */,
  0x68140000l /* 0x023B88 */,
  0x40130000l /* 0x023B8C */,
  0xC3120000l /* 0x023B90 */,
  0xE7110000l /* 0x023B94 */,
  0x42110000l /* 0x023B98 */,
  0xE5000000l /* 0x023B9C */,
  0xC1130000l /* 0x023BA0 */,
  0x44130000l /* 0x023BA4 */,
  0xE7120000l /* 0x023BA8 */,
  0xC3110000l /* 0x023BAC */,
  0x66110000l /* 0x023BB0 */,
  0xC1000000l /* 0x023BB4 */,
  0xE5130000l /* 0x023BB8 */,
  0x00200C00l /* 0x023BBC */,
  0x68040000l /* 0x023BC0 */,
  0x68040000l /* 0x023BC4 */,
  0x43040000l /* 0x023BC8 */,
  0x67040000l /* 0x023BCC */,
  0x00200200l /* 0x023BD0 */,
  0x68140000l /* 0x023BD4 */,
  0x41120000l /* 0x023BD8 */,
  0x65120000l /* 0x023BDC */,
  0x00200200l /* 0x023BE0 */,
  0x68140000l /* 0x023BE4 */,
  0xC2030000l /* 0x023BE8 */,
  0x66040000l /* 0x023BEC */,
  0x63040000l /* 0x023BF0 */,
  0x40040000l /* 0x023BF4 */,
  0x65140000l /* 0x023BF8 */,
  0x00200500l /* 0x023BFC */,
  0x68040000l /* 0x023C00 */,
  0x64040000l /* 0x023C04 */,
  0x41040000l /* 0x023C08 */,
  0x66040000l /* 0x023C0C */,
  0x42040000l /* 0x023C10 */,
  0x67040000l /* 0x023C14 */,
  0x00200500l /* 0x023C18 */,
  0x68040000l /* 0x023C1C */,
  0x631C0000l /* 0x023C20 */,
  0xC0100000l /* 0x023C24 */,
  0x64110000l /* 0x023C28 */,
  0xC1110000l /* 0x023C2C */,
  0x65120000l /* 0x023C30 */,
  0x42120000l /* 0x023C34 */,
  0xE6120000l /* 0x023C38 */,
  0x43130000l /* 0x023C3C */,
  0xE7030000l /* 0x023C40 */,
  0x00200900l /* 0x023C44 */,
  0x68040000l /* 0x023C48 */,
  0x421C0000l /* 0x023C4C */,
  0xE6100000l /* 0x023C50 */,
  0x43110000l /* 0x023C54 */,
  0xE7110000l /* 0x023C58 */,
  0x63120000l /* 0x023C5C */,
  0xC0120000l /* 0x023C60 */,
  0x64130000l /* 0x023C64 */,
  0xC1030000l /* 0x023C68 */,
  0x65040000l /* 0x023C6C */,
  0x00200900l /* 0x023C70 */,
  0x48040000l /* 0x023C74 */,
  0x68140000l /* 0x023C78 */,
  0xC0010000l /* 0x023C7C */,
  0xC2130000l /* 0x023C80 */,
  0xC4010000l /* 0x023C84 */,
  0xE6130000l /* 0x023C88 */,
  0x00200400l /* 0x023C8C */,
  0x48140000l /* 0x023C90 */,
  0xE8000000l /* 0x023C94 */,
  0xC1120000l /* 0x023C98 */,
  0xC3000000l /* 0x023C9C */,
  0xC5120000l /* 0x023CA0 */,
  0xE7000000l /* 0x023CA4 */,
  0x00200400l /* 0x023CA8 */,
  0x68140000l /* 0x023CAC */,
  0x68140000l /* 0x023CB0 */,
  0x40010000l /* 0x023CB4 */,
  0x40020000l /* 0x023CB8 */,
  0x41130000l /* 0x023CBC */,
  0x42000000l /* 0x023CC0 */,
  0x43010000l /* 0x023CC4 */,
  0x44020000l /* 0x023CC8 */,
  0x45130000l /* 0x023CCC */,
  0x46000000l /* 0x023CD0 */,
  0x67010000l /* 0x023CD4 */,
  0x00200800l /* 0x023CD8 */,
  0x68140000l /* 0x023CDC */,
  0x68140000l /* 0x023CE0 */,
  0xC0000000l /* 0x023CE4 */,
  0xC0010000l /* 0x023CE8 */,
  0xC1020000l /* 0x023CEC */,
  0xC2130000l /* 0x023CF0 */,
  0xC3000000l /* 0x023CF4 */,
  0xC4010000l /* 0x023CF8 */,
  0xC5020000l /* 0x023CFC */,
  0xC6130000l /* 0x023D00 */,
  0xE7000000l /* 0x023D04 */,
  0x00200800l /* 0x023D08 */,
  0x68040000l /* 0x023D0C */,
  0x641C0000l /* 0x023D10 */,
  0xC2110000l /* 0x023D14 */,
  0xE7020000l /* 0x023D18 */,
  0x00200300l /* 0x023D1C */,
  0x68140000l /* 0x023D20 */,
  0xC2020000l /* 0x023D24 */,
  0x671C0000l /* 0x023D28 */,
  0xE4110000l /* 0x023D2C */,
  0x00200300l /* 0x023D30 */,
  0x68040000l /* 0x023D34 */,
  0x64040000l /* 0x023D38 */,
  0x41040000l /* 0x023D3C */,
  0x65140000l /* 0x023D40 */,
  0xC2120000l /* 0x023D44 */,
  0x67130000l /* 0x023D48 */,
  0x00200500l /* 0x023D4C */,
  0x68140000l /* 0x023D50 */,
  0xC1120000l /* 0x023D54 */,
  0x66030000l /* 0x023D58 */,
  0x63040000l /* 0x023D5C */,
  0x40040000l /* 0x023D60 */,
  0x65140000l /* 0x023D64 */,
  0x00200500l /* 0x023D68 */,
  0x68040000l /* 0x023D6C */,
  0x641C0000l /* 0x023D70 */,
  0x41110000l /* 0x023D74 */,
  0xE5110000l /* 0x023D78 */,
  0xC2120000l /* 0x023D7C */,
  0x67030000l /* 0x023D80 */,
  0x00200500l /* 0x023D84 */,
  0x68040000l /* 0x023D88 */,
  0x421C0000l /* 0x023D8C */,
  0x67110000l /* 0x023D90 */,
  0x64120000l /* 0x023D94 */,
  0x41130000l /* 0x023D98 */,
  0xE5030000l /* 0x023D9C */,
  0x00200500l /* 0x023DA0 */,
  0x68140000l /* 0x023DA4 */,
  0xC2130000l /* 0x023DA8 */,
  0xE6120000l /* 0x023DAC */,
  0x41120000l /* 0x023DB0 */,
  0xE4110000l /* 0x023DB4 */,
  0xC0100000l /* 0x023DB8 */,
  0x43000000l /* 0x023DBC */,
  0xE6130000l /* 0x023DC0 */,
  0xC2120000l /* 0x023DC4 */,
  0x65120000l /* 0x023DC8 */,
  0xC0110000l /* 0x023DCC */,
  0xC4100000l /* 0x023DD0 */,
  0x67100000l /* 0x023DD4 */,
  0x00200C00l /* 0x023DD8 */,
  0xC1110000l /* 0x023DDC */,
  0x44110000l /* 0x023DE0 */,
  0xE7000000l /* 0x023DE4 */,
  0xC3130000l /* 0x023DE8 */,
  0x66130000l /* 0x023DEC */,
  0xC1120000l /* 0x023DF0 */,
  0xC5110000l /* 0x023DF4 */,
  0x60110000l /* 0x023DF8 */,
  0xC3000000l /* 0x023DFC */,
  0xE7130000l /* 0x023E00 */,
  0x42130000l /* 0x023E04 */,
  0xE5120000l /* 0x023E08 */,
  0x00200C00l /* 0x023E0C */,
  0x68040000l /* 0x023E10 */,
  0x631C0000l /* 0x023E14 */,
  0xC0100000l /* 0x023E18 */,
  0x64110000l /* 0x023E1C */,
  0xC1110000l /* 0x023E20 */,
  0x65120000l /* 0x023E24 */,
  0x42120000l /* 0x023E28 */,
  0xE6120000l /* 0x023E2C */,
  0x43130000l /* 0x023E30 */,
  0xE7030000l /* 0x023E34 */,
  0x00200900l /* 0x023E38 */,
  0x68140000l /* 0x023E3C */,
  0x41120000l /* 0x023E40 */,
  0xE6120000l /* 0x023E44 */,
  0x42130000l /* 0x023E48 */,
  0xE7030000l /* 0x023E4C */,
  0x431C0000l /* 0x023E50 */,
  0xE7100000l /* 0x023E54 */,
  0x64110000l /* 0x023E58 */,
  0xC0110000l /* 0x023E5C */,
  0x65120000l /* 0x023E60 */,
  0x00200900l /* 0x023E64 */,
  0x68140000l /* 0x023E68 */,
  0x68140000l /* 0x023E6C */,
  0x41120000l /* 0x023E70 */,
  0x43000000l /* 0x023E74 */,
  0x45120000l /* 0x023E78 */,
  0x67000000l /* 0x023E7C */,
  0x00200400l /* 0x023E80 */,
  0x00000000l /* 0x023E84 */,
  0x00000000l /* 0x023E88 */,
  0x48040000l /* 0x023E8C */,
  0x68140000l /* 0x023E90 */,
  0x48010000l /* 0x023E94 */,
  0x68130000l /* 0x023E98 */,
  0x42010000l /* 0x023E9C */,
  0x44130000l /* 0x023EA0 */,
  0x66010000l /* 0x023EA4 */,
  0x40130000l /* 0x023EA8 */,
  0x00200400l /* 0x023EAC */,
  0x68140000l /* 0x023EB0 */,
  0x68140000l /* 0x023EB4 */,
  0x41120000l /* 0x023EB8 */,
  0x43000000l /* 0x023EBC */,
  0x45120000l /* 0x023EC0 */,
  0x67000000l /* 0x023EC4 */,
  0x00200400l /* 0x023EC8 */,
  0x00000000l /* 0x023ECC */,
  0x00000000l /* 0x023ED0 */,
  0x48140000l /* 0x023ED4 */,
  0x68010000l /* 0x023ED8 */,
  0x42130000l /* 0x023EDC */,
  0x44010000l /* 0x023EE0 */,
  0x66130000l /* 0x023EE4 */,
  0x40010000l /* 0x023EE8 */,
  0x00200400l /* 0x023EEC */,
  0x00000000l /* 0x023EF0 */,
  0x00000000l /* 0x023EF4 */,
  0x48040000l /* 0x023EF8 */,
  0x68140000l /* 0x023EFC */,
  0x40010000l /* 0x023F00 */,
  0x41020000l /* 0x023F04 */,
  0x42130000l /* 0x023F08 */,
  0x43000000l /* 0x023F0C */,
  0x44010000l /* 0x023F10 */,
  0x45020000l /* 0x023F14 */,
  0x46130000l /* 0x023F18 */,
  0x67000000l /* 0x023F1C */,
  0x00200800l /* 0x023F20 */,
  0x00000000l /* 0x023F24 */,
  0x00000000l /* 0x023F28 */,
  0x00000000l /* 0x023F2C */,
  0x48040000l /* 0x023F30 */,
  0x68140000l /* 0x023F34 */,
  0x40000000l /* 0x023F38 */,
  0xC0000000l /* 0x023F3C */,
  0xC0010000l /* 0x023F40 */,
  0xC0020000l /* 0x023F44 */,
  0xC1130000l /* 0x023F48 */,
  0xC2000000l /* 0x023F4C */,
  0xC3010000l /* 0x023F50 */,
  0xC4020000l /* 0x023F54 */,
  0xC5130000l /* 0x023F58 */,
  0xC6000000l /* 0x023F5C */,
  0xE7010000l /* 0x023F60 */,
  0x00200800l /* 0x023F64 */,
  0x48140000l /* 0x023F68 */,
  0x68140000l /* 0x023F6C */,
  0xC1000000l /* 0x023F70 */,
  0xC2010000l /* 0x023F74 */,
  0xC3020000l /* 0x023F78 */,
  0xC4130000l /* 0x023F7C */,
  0xC5000000l /* 0x023F80 */,
  0xC6010000l /* 0x023F84 */,
  0xE7020000l /* 0x023F88 */,
  0xC0130000l /* 0x023F8C */,
  0x00200800l /* 0x023F90 */,
  0x00000000l /* 0x023F94 */,
  0x00000000l /* 0x023F98 */,
  0x08000800l /* 0x023F9C */,
  0x08080800l /* 0x023FA0 */,
  0x08008000l /* 0x023FA4 */,
  0x00000800l /* 0x023FA8 */,
  0x10085000l /* 0x023FAC */,
  0x08000800l /* 0x023FB0 */,
  0x08080800l /* 0x023FB4 */,
  0x10085000l /* 0x023FB8 */,
  0x08000800l /* 0x023FBC */,
  0x08080800l /* 0x023FC0 */,
  0x10085000l /* 0x023FC4 */,
  0x08000800l /* 0x023FC8 */,
  0x08080800l /* 0x023FCC */,
  0x10085000l /* 0x023FD0 */,
  0x08000800l /* 0x023FD4 */,
  0x08080800l /* 0x023FD8 */,
  0x30008000l /* 0x023FDC */,
  0x00000800l /* 0x023FE0 */,
  0x10085000l /* 0x023FE4 */,
  0x08080800l /* 0x023FE8 */,
  0x10081000l /* 0x023FEC */,
  0x10085000l /* 0x023FF0 */,
  0x08000800l /* 0x023FF4 */,
  0x10081000l /* 0x023FF8 */,
  0x18008000l /* 0x023FFC */,
  0x00000800l /* 0x024000 */,
  0x10081000l /* 0x024004 */,
  0x10085000l /* 0x024008 */,
  0x08080800l /* 0x02400C */,
  0x10081000l /* 0x024010 */,
  0x10005000l /* 0x024014 */,
  0x08080800l /* 0x024018 */,
  0x18008000l /* 0x02401C */,
  0x00000800l /* 0x024020 */,
  0x10085000l /* 0x024024 */,
  0x08000800l /* 0x024028 */,
  0x08080800l /* 0x02402C */,
  0x08080800l /* 0x024030 */,
  0x10005000l /* 0x024034 */,
  0x08080800l /* 0x024038 */,
  0x08000800l /* 0x02403C */,
  0x08080800l /* 0x024040 */,
  0x20008000l /* 0x024044 */,
  0x00000800l /* 0x024048 */,
  0x10005000l /* 0x02404C */,
  0x08080800l /* 0x024050 */,
  0x08080800l /* 0x024054 */,
  0x08000800l /* 0x024058 */,
  0x10085000l /* 0x02405C */,
  0x08080800l /* 0x024060 */,
  0x08000800l /* 0x024064 */,
  0x08080800l /* 0x024068 */,
  0x20008000l /* 0x02406C */,
  0x00000000l /* 0x024070 */,
  0x10081000l /* 0x024074 */,
  0x08000800l /* 0x024078 */,
  0x08080800l /* 0x02407C */,
  0x0C008000l /* 0x024080 */,
  0x00000000l /* 0x024084 */,
  0x10081000l /* 0x024088 */,
  0x08000800l /* 0x02408C */,
  0x08080800l /* 0x024090 */,
  0x0C008000l /* 0x024094 */,
  0x00000000l /* 0x024098 */,
  0x10081000l /* 0x02409C */,
  0x08080800l /* 0x0240A0 */,
  0x10081000l /* 0x0240A4 */,
  0x10081000l /* 0x0240A8 */,
  0x08000800l /* 0x0240AC */,
  0x10081000l /* 0x0240B0 */,
  0x18008000l /* 0x0240B4 */,
  0x00000000l /* 0x0240B8 */,
  0x10081000l /* 0x0240BC */,
  0x10081000l /* 0x0240C0 */,
  0x08080800l /* 0x0240C4 */,
  0x10081000l /* 0x0240C8 */,
  0x10001000l /* 0x0240CC */,
  0x08080800l /* 0x0240D0 */,
  0x18008000l /* 0x0240D4 */,
  0x00000000l /* 0x0240D8 */,
  0x10081000l /* 0x0240DC */,
  0x08000800l /* 0x0240E0 */,
  0x08080800l /* 0x0240E4 */,
  0x08080800l /* 0x0240E8 */,
  0x10001000l /* 0x0240EC */,
  0x08080800l /* 0x0240F0 */,
  0x08000800l /* 0x0240F4 */,
  0x08080800l /* 0x0240F8 */,
  0x20008000l /* 0x0240FC */,
  0x00000000l /* 0x024100 */,
  0x10001000l /* 0x024104 */,
  0x08080800l /* 0x024108 */,
  0x08080800l /* 0x02410C */,
  0x08000800l /* 0x024110 */,
  0x10081000l /* 0x024114 */,
  0x08080800l /* 0x024118 */,
  0x08000800l /* 0x02411C */,
  0x08080800l /* 0x024120 */,
  0x20008000l /* 0x024124 */,
  0x04040000l /* 0x024128 */,
  0x04000000l /* 0x02412C */,
  0x04000000l /* 0x024130 */,
  0x00040000l /* 0x024134 */,
  0x0C008000l /* 0x024138 */,
  0x00000000l /* 0x02413C */,
  0x00040000l /* 0x024140 */,
  0x04000000l /* 0x024144 */,
  0x04000000l /* 0x024148 */,
  0x00000000l /* 0x02414C */,
  0x04040000l /* 0x024150 */,
  0x0C008000l /* 0x024154 */,
  0x04040000l /* 0x024158 */,
  0x04000000l /* 0x02415C */,
  0x04040000l /* 0x024160 */,
  0x04000000l /* 0x024164 */,
  0x04040000l /* 0x024168 */,
  0x04000000l /* 0x02416C */,
  0x00000000l /* 0x024170 */,
  0x04040000l /* 0x024174 */,
  0x04000000l /* 0x024178 */,
  0x04040000l /* 0x02417C */,
  0x04000000l /* 0x024180 */,
  0x04000000l /* 0x024184 */,
  0x00040000l /* 0x024188 */,
  0x30008000l /* 0x02418C */,
  0x00040000l /* 0x024190 */,
  0x04000000l /* 0x024194 */,
  0x04000000l /* 0x024198 */,
  0x04040000l /* 0x02419C */,
  0x04000000l /* 0x0241A0 */,
  0x04040000l /* 0x0241A4 */,
  0x00000000l /* 0x0241A8 */,
  0x04000000l /* 0x0241AC */,
  0x04040000l /* 0x0241B0 */,
  0x04000000l /* 0x0241B4 */,
  0x04040000l /* 0x0241B8 */,
  0x04000000l /* 0x0241BC */,
  0x00040000l /* 0x0241C0 */,
  0x30008000l /* 0x0241C4 */,
  0x04040000l /* 0x0241C8 */,
  0x04000000l /* 0x0241CC */,
  0x00000000l /* 0x0241D0 */,
  0x04040000l /* 0x0241D4 */,
  0x04000000l /* 0x0241D8 */,
  0x00000000l /* 0x0241DC */,
  0x04040000l /* 0x0241E0 */,
  0x04000000l /* 0x0241E4 */,
  0x00000000l /* 0x0241E8 */,
  0x04040000l /* 0x0241EC */,
  0x00000000l /* 0x0241F0 */,
  0x04000000l /* 0x0241F4 */,
  0x04040000l /* 0x0241F8 */,
  0x00000000l /* 0x0241FC */,
  0x04000000l /* 0x024200 */,
  0x04000000l /* 0x024204 */,
  0x00040000l /* 0x024208 */,
  0x40008000l /* 0x02420C */,
  0x00000000l /* 0x024210 */,
  0x00040000l /* 0x024214 */,
  0x04000000l /* 0x024218 */,
  0x04000000l /* 0x02421C */,
  0x00000000l /* 0x024220 */,
  0x04040000l /* 0x024224 */,
  0x04000000l /* 0x024228 */,
  0x00000000l /* 0x02422C */,
  0x04040000l /* 0x024230 */,
  0x00000000l /* 0x024234 */,
  0x04000000l /* 0x024238 */,
  0x04040000l /* 0x02423C */,
  0x00000000l /* 0x024240 */,
  0x04000000l /* 0x024244 */,
  0x04000000l /* 0x024248 */,
  0x00040000l /* 0x02424C */,
  0x04000000l /* 0x024250 */,
  0x00000000l /* 0x024254 */,
  0x04040000l /* 0x024258 */,
  0x40008000l /* 0x02425C */,
  0x00000000l /* 0x024260 */,
  0x04040000l /* 0x024264 */,
  0x04000000l /* 0x024268 */,
  0x04040000l /* 0x02426C */,
  0x04000000l /* 0x024270 */,
  0x04040000l /* 0x024274 */,
  0x04000000l /* 0x024278 */,
  0x04040000l /* 0x02427C */,
  0x04000000l /* 0x024280 */,
  0x04040000l /* 0x024284 */,
  0x04000000l /* 0x024288 */,
  0x04040000l /* 0x02428C */,
  0x04000000l /* 0x024290 */,
  0x04040000l /* 0x024294 */,
  0x04000000l /* 0x024298 */,
  0x04040000l /* 0x02429C */,
  0x04000000l /* 0x0242A0 */,
  0x40008000l /* 0x0242A4 */,
  0x00000000l /* 0x0242A8 */,
  0x04040000l /* 0x0242AC */,
  0x04000000l /* 0x0242B0 */,
  0x04000000l /* 0x0242B4 */,
  0x04040000l /* 0x0242B8 */,
  0x04000000l /* 0x0242BC */,
  0x00040000l /* 0x0242C0 */,
  0x04000000l /* 0x0242C4 */,
  0x04040000l /* 0x0242C8 */,
  0x04000000l /* 0x0242CC */,
  0x04000000l /* 0x0242D0 */,
  0x04040000l /* 0x0242D4 */,
  0x00000000l /* 0x0242D8 */,
  0x30008000l /* 0x0242DC */,
  0x00000000l /* 0x0242E0 */,
  0x04040000l /* 0x0242E4 */,
  0x00000000l /* 0x0242E8 */,
  0x04040000l /* 0x0242EC */,
  0x04000000l /* 0x0242F0 */,
  0x04040000l /* 0x0242F4 */,
  0x04000000l /* 0x0242F8 */,
  0x04000000l /* 0x0242FC */,
  0x00040000l /* 0x024300 */,
  0x04000000l /* 0x024304 */,
  0x04040000l /* 0x024308 */,
  0x04000000l /* 0x02430C */,
  0x04000000l /* 0x024310 */,
  0x30008000l /* 0x024314 */,
  0x00000000l /* 0x024318 */,
  0x08080800l /* 0x02431C */,
  0x08000800l /* 0x024320 */,
  0x08080800l /* 0x024324 */,
  0x08000800l /* 0x024328 */,
  0x08080800l /* 0x02432C */,
  0x00000000l /* 0x024330 */,
  0x08000800l /* 0x024334 */,
  0x08080800l /* 0x024338 */,
  0x08000800l /* 0x02433C */,
  0x08080800l /* 0x024340 */,
  0x08000800l /* 0x024344 */,
  0x00000000l /* 0x024348 */,
  0x30008000l /* 0x02434C */,
  0x00000000l /* 0x024350 */,
  0x08080800l /* 0x024354 */,
  0x08000800l /* 0x024358 */,
  0x08000800l /* 0x02435C */,
  0x08080800l /* 0x024360 */,
  0x08000800l /* 0x024364 */,
  0x00080000l /* 0x024368 */,
  0x08000800l /* 0x02436C */,
  0x08000800l /* 0x024370 */,
  0x08080800l /* 0x024374 */,
  0x08000800l /* 0x024378 */,
  0x08080800l /* 0x02437C */,
  0x00000000l /* 0x024380 */,
  0x30008000l /* 0x024384 */,
  0x00000000l /* 0x024388 */,
  0x08000800l /* 0x02438C */,
  0x08080800l /* 0x024390 */,
  0x08008000l /* 0x024394 */,
  0x08080800l /* 0x024398 */,
  0x08000800l /* 0x02439C */,
  0x08080800l /* 0x0243A0 */,
  0x08008000l /* 0x0243A4 */,
  0x04040000l /* 0x0243A8 */,
  0x04000000l /* 0x0243AC */,
  0x04040000l /* 0x0243B0 */,
  0x08040000l /* 0x0243B4 */,
  0x04000000l /* 0x0243B8 */,
  0x04040000l /* 0x0243BC */,
  0x14008000l /* 0x0243C0 */,
  0x04040000l /* 0x0243C4 */,
  0x04000000l /* 0x0243C8 */,
  0x04040000l /* 0x0243CC */,
  0x08040000l /* 0x0243D0 */,
  0x04000000l /* 0x0243D4 */,
  0x04040000l /* 0x0243D8 */,
  0x14008000l /* 0x0243DC */,
  0x00000800l /* 0x0243E0 */,
  0x10085000l /* 0x0243E4 */,
  0x08000800l /* 0x0243E8 */,
  0x08080800l /* 0x0243EC */,
  0x08000800l /* 0x0243F0 */,
  0x08080800l /* 0x0243F4 */,
  0x08000800l /* 0x0243F8 */,
  0x08080800l /* 0x0243FC */,
  0x08000800l /* 0x024400 */,
  0x08080800l /* 0x024404 */,
  0x24008000l /* 0x024408 */,
  0x00000800l /* 0x02440C */,
  0x10005000l /* 0x024410 */,
  0x08080800l /* 0x024414 */,
  0x08000800l /* 0x024418 */,
  0x08080800l /* 0x02441C */,
  0x08080800l /* 0x024420 */,
  0x08000800l /* 0x024424 */,
  0x08080800l /* 0x024428 */,
  0x08000800l /* 0x02442C */,
  0x08080800l /* 0x024430 */,
  0x24008000l /* 0x024434 */,
  0x00000000l /* 0x024438 */,
  0x04040000l /* 0x02443C */,
  0x00000000l /* 0x024440 */,
  0x04000000l /* 0x024444 */,
  0x00000000l /* 0x024448 */,
  0x04040000l /* 0x02444C */,
  0x10008000l /* 0x024450 */,
  0x04000000l /* 0x024454 */,
  0x00040000l /* 0x024458 */,
  0x04000000l /* 0x02445C */,
  0x00000000l /* 0x024460 */,
  0x04000000l /* 0x024464 */,
  0x00040000l /* 0x024468 */,
  0x10008000l /* 0x02446C */,
  0x00000000l /* 0x024470 */,
  0x04040000l /* 0x024474 */,
  0x00000000l /* 0x024478 */,
  0x00000000l /* 0x02447C */,
  0x04000000l /* 0x024480 */,
  0x00000000l /* 0x024484 */,
  0x00000000l /* 0x024488 */,
  0x00000000l /* 0x02448C */,
  0x04000000l /* 0x024490 */,
  0x00000000l /* 0x024494 */,
  0x00040000l /* 0x024498 */,
  0x20008000l /* 0x02449C */,
  0x00000000l /* 0x0244A0 */,
  0x04040000l /* 0x0244A4 */,
  0x00000000l /* 0x0244A8 */,
  0x00000000l /* 0x0244AC */,
  0x00000000l /* 0x0244B0 */,
  0x04000000l /* 0x0244B4 */,
  0x00000000l /* 0x0244B8 */,
  0x00000000l /* 0x0244BC */,
  0x00000000l /* 0x0244C0 */,
  0x04000000l /* 0x0244C4 */,
  0x00040000l /* 0x0244C8 */,
  0x20008000l /* 0x0244CC */,
  0x00000800l /* 0x0244D0 */,
  0x10085000l /* 0x0244D4 */,
  0x08000800l /* 0x0244D8 */,
  0x08080800l /* 0x0244DC */,
  0x0C008000l /* 0x0244E0 */,
  0x08080000l /* 0x0244E4 */,
  0x08001800l /* 0x0244E8 */,
  0x10084000l /* 0x0244EC */,
  0x08080800l /* 0x0244F0 */,
  0x0C008000l /* 0x0244F4 */,
  0x00000000l /* 0x0244F8 */,
  0x08080800l /* 0x0244FC */,
  0x10081000l /* 0x024500 */,
  0x08000800l /* 0x024504 */,
  0x08080800l /* 0x024508 */,
  0x08000800l /* 0x02450C */,
  0x14008000l /* 0x024510 */,
  0x08080800l /* 0x024514 */,
  0x08000800l /* 0x024518 */,
  0x08080800l /* 0x02451C */,
  0x08080800l /* 0x024520 */,
  0x10001000l /* 0x024524 */,
  0x08080800l /* 0x024528 */,
  0x14008000l /* 0x02452C */,
  0x00000000l /* 0x024530 */,
  0x00080800l /* 0x024534 */,
  0x10085000l /* 0x024538 */,
  0x08000800l /* 0x02453C */,
  0x08080800l /* 0x024540 */,
  0x08000800l /* 0x024544 */,
  0x08080800l /* 0x024548 */,
  0x14008000l /* 0x02454C */,
  0x00000000l /* 0x024550 */,
  0x00080800l /* 0x024554 */,
  0x10005000l /* 0x024558 */,
  0x08080800l /* 0x02455C */,
  0x08080800l /* 0x024560 */,
  0x08000800l /* 0x024564 */,
  0x08080800l /* 0x024568 */,
  0x14008000l /* 0x02456C */,
  0x00000000l /* 0x024570 */,
  0x08080800l /* 0x024574 */,
  0x08000800l /* 0x024578 */,
  0x08080800l /* 0x02457C */,
  0x08000800l /* 0x024580 */,
  0x08080800l /* 0x024584 */,
  0x00000000l /* 0x024588 */,
  0x08000800l /* 0x02458C */,
  0x08080800l /* 0x024590 */,
  0x08000800l /* 0x024594 */,
  0x08080800l /* 0x024598 */,
  0x08000800l /* 0x02459C */,
  0x00000000l /* 0x0245A0 */,
  0x30008000l /* 0x0245A4 */,
  0x08080800l /* 0x0245A8 */,
  0x08000800l /* 0x0245AC */,
  0x08000800l /* 0x0245B0 */,
  0x00080000l /* 0x0245B4 */,
  0x08000800l /* 0x0245B8 */,
  0x08080800l /* 0x0245BC */,
  0x08000800l /* 0x0245C0 */,
  0x08000800l /* 0x0245C4 */,
  0x08080800l /* 0x0245C8 */,
  0x00000000l /* 0x0245CC */,
  0x08080800l /* 0x0245D0 */,
  0x08000800l /* 0x0245D4 */,
  0x08080800l /* 0x0245D8 */,
  0x30008000l /* 0x0245DC */,
  0x00000800l /* 0x0245E0 */,
  0x10085000l /* 0x0245E4 */,
  0x08000800l /* 0x0245E8 */,
  0x08080800l /* 0x0245EC */,
  0x08000800l /* 0x0245F0 */,
  0x08080800l /* 0x0245F4 */,
  0x08000800l /* 0x0245F8 */,
  0x08080800l /* 0x0245FC */,
  0x08000800l /* 0x024600 */,
  0x08080800l /* 0x024604 */,
  0x24008000l /* 0x024608 */,
  0x08081000l /* 0x02460C */,
  0x08000800l /* 0x024610 */,
  0x08080800l /* 0x024614 */,
  0x08000800l /* 0x024618 */,
  0x08080800l /* 0x02461C */,
  0x10005000l /* 0x024620 */,
  0x08080800l /* 0x024624 */,
  0x08080800l /* 0x024628 */,
  0x08000800l /* 0x02462C */,
  0x08080800l /* 0x024630 */,
  0x24008000l /* 0x024634 */,
  0x00000000l /* 0x024638 */,
  0x08080800l /* 0x02463C */,
  0x08000800l /* 0x024640 */,
  0x00000000l /* 0x024644 */,
  0x08000800l /* 0x024648 */,
  0x00080800l /* 0x02464C */,
  0x10008000l /* 0x024650 */,
  0x00000000l /* 0x024654 */,
  0x00000000l /* 0x024658 */,
  0x00000000l /* 0x02465C */,
  0x08000800l /* 0x024660 */,
  0x00000000l /* 0x024664 */,
  0x08080800l /* 0x024668 */,
  0x00000000l /* 0x02466C */,
  0x08000800l /* 0x024670 */,
  0x00080800l /* 0x024674 */,
  0x08000800l /* 0x024678 */,
  0x10008000l /* 0x02467C */,
  0x08000800l /* 0x024680 */,
  0x00080800l /* 0x024684 */,
  0x08000800l /* 0x024688 */,
  0x00000800l /* 0x02468C */,
  0x08080800l /* 0x024690 */,
  0x00000800l /* 0x024694 */,
  0x10008000l /* 0x024698 */,
  0x00000000l /* 0x02469C */,
  0x00000000l /* 0x0246A0 */,
  0x00000800l /* 0x0246A4 */,
  0x08080800l /* 0x0246A8 */,
  0x00000800l /* 0x0246AC */,
  0x00000800l /* 0x0246B0 */,
  0x08000800l /* 0x0246B4 */,
  0x00000800l /* 0x0246B8 */,
  0x00000800l /* 0x0246BC */,
  0x00000800l /* 0x0246C0 */,
  0x08000800l /* 0x0246C4 */,
  0x00080800l /* 0x0246C8 */,
  0x20008000l /* 0x0246CC */,
  0x00000000l /* 0x0246D0 */,
  0x00000000l /* 0x0246D4 */,
  0x00000000l /* 0x0246D8 */,
  0x00000800l /* 0x0246DC */,
  0x08080800l /* 0x0246E0 */,
  0x00000800l /* 0x0246E4 */,
  0x00000800l /* 0x0246E8 */,
  0x00000800l /* 0x0246EC */,
  0x00000800l /* 0x0246F0 */,
  0x08000800l /* 0x0246F4 */,
  0x00000800l /* 0x0246F8 */,
  0x00000800l /* 0x0246FC */,
  0x00000800l /* 0x024700 */,
  0x08000800l /* 0x024704 */,
  0x00000800l /* 0x024708 */,
  0x00080800l /* 0x02470C */,
  0x20008000l /* 0x024710 */,
  0x08000800l /* 0x024714 */,
  0x00080800l /* 0x024718 */,
  0x00000800l /* 0x02471C */,
  0x00000800l /* 0x024720 */,
  0x08000800l /* 0x024724 */,
  0x00000800l /* 0x024728 */,
  0x00000800l /* 0x02472C */,
  0x00000800l /* 0x024730 */,
  0x08080800l /* 0x024734 */,
  0x00000800l /* 0x024738 */,
  0x20008000l /* 0x02473C */,
  0x00000000l /* 0x024740 */,
  0x5F445644l /* 0x024744 */,
  0x5F4C4552l /* 0x024748 */,
  0x30332E32l /* 0x02474C */,
  0x0000000Al /* 0x024750 */
};

struct tagMicrocode_Ptr_List
{
  unsigned long *Microcode_Seg_Add;	// Segment Table Address
  unsigned long  Microcode_Seg_Len;	// Segment Length in DWORDs
} Microcode_Ptr_List[] =
{
 { Microcode_Data0, 37326L }
};

unsigned long Microcode_List_Len = 1;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dxr2\en_hw.h ===
//******************************************************************************/
//*                                                                            *
//*    en_hw.h -                                                               *
//*                                                                            *
//*    Copyright (c) C-Cube Microsystems 1996                                  *
//*    All Rights Reserved.                                                    *
//*                                                                            *
//*    Use of C-Cube Microsystems code is governed by terms and conditions     *
//*    stated in the accompanying licensing statement.                         *
//*                                                                            *
//******************************************************************************/


void InitializeHost(PPORT_CONFIGURATION_INFORMATION ConfigInfo);
BOOL InitializeOutputStream( PHW_STREAM_REQUEST_BLOCK pSrb );
void ProcessVideoFormat( PKSDATAFORMAT pfmt, PHW_DEVICE_EXTENSION pHwDevExt );
void OpenOutputStream(PHW_STREAM_REQUEST_BLOCK pSrb);
void CloseOutputStream();
void UnIntializeOutputStream(PHW_STREAM_REQUEST_BLOCK pSrb);
void CloseOutputStream(PHW_STREAM_REQUEST_BLOCK pSrb);
void InitDevProp(PHW_STREAM_REQUEST_BLOCK pSrb);
void DisableThresholdInt();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dxr2\headers.h ===
/******************************************************************************\
*                                                                              *
*      HEADERS.H       -     Hardware abstraction level library.                *
*                                                                              *
*      Copyright (c) C-Cube Microsystems 1996                                  *
*      All Rights Reserved.                                                    *
*                                                                              *
*      Use of C-Cube Microsystems code is governed by terms and conditions     *
*      stated in the accompanying licensing statement.                         *
*                                                                              *
\******************************************************************************/

// STREAM_NUMBER_CONTROL
#define SELECT_STREAM_NUMBER
//#define ZERO_STREAM_NUMBER

// MICROCODE
//#define MICROCODE_ACCEPTS_ANY_STREAM

#ifdef DEBUG
#ifndef _DEBUG
#define _DEBUG
#endif
#if !defined( DBG ) || DBG != 1
#ifdef DBG

#undef DBG
#endif
#define DBG 1
#endif
#ifdef NDEBUG
#error NDEBUG shouldn't be defined
#endif
#else			// #ifdef DEBUG
#ifdef _DEBUG
#undef _DEBUG
#endif
#ifdef DBG
#undef DBG
#endif
#ifndef NDEBUG
#define NDEBUG
#endif
#endif			// #ifdef DEBUG

#ifdef USE_MONOCHROMEMONITOR
#if	USE_MONOCHROMEMONITOR != 1
#undef USE_MONOCHROMEMONITOR
#endif
#endif

#include <strmini.h>

#if defined(ENCORE)
enum ColorKeyType
{
	CK_NOCOLORKEY = 0,
	CK_INDEX = 0x1,
	CK_RGB = 0x2
};
typedef struct tagCOLORKEY
{
	DWORD KeyType;
	DWORD PaletteIndex;
	COLORREF LowColorValue;
	COLORREF HighColorValue;
} COLORKEY;
#endif

#include <ksmedia.h>
#include "zivawdm.h"
#include "adapter.h"
#include "monovxd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dxr2\en_hw.c ===
/******************************************************************************\
*                                                                              *
*      En_Hw.C       -     Hardware abstraction level library.                *
*                                                                              *
*      Copyright (c) C-Cube Microsystems 1998                                  *
*      All Rights Reserved.                                                    *
*                                                                              *
*      Use of C-Cube Microsystems code is governed by terms and conditions     *
*      stated in the accompanying licensing statement.                         *
*                                                                              *
\******************************************************************************/

#include "Headers.h"
#include "avwinwdm.h"
#include "anlgstrm.h"
#include "vidstrm.h"
#include "audstrm.h"
#include "sbpstrm.h"

#include "HwIf.h"

void InitializeHost(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	PPORT_CONFIGURATION_INFORMATION ConfigInfo = pSrb->CommandData.ConfigInfo;
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)ConfigInfo->HwDeviceExtension;
	DWORD dwDeviceID;
	
	
	pHwDevExt->dwDVDAMCCBaseAddress			= ConfigInfo->AccessRanges[0].RangeStart.LowPart;
	pHwDevExt->dwHostAccessRangeLength		= ConfigInfo->AccessRanges[0].RangeLength;
	pHwDevExt->dwDVDHostBaseAddress			= 0x8000;
	pHwDevExt->dwDVDCFifoBaseAddress		= 0; // This address is not being used...
	pHwDevExt->dwDVD6807BaseAddress			= pHwDevExt->dwDVDHostBaseAddress + 0x80;
	pHwDevExt->dwDVDFPGABaseAddress			= pHwDevExt->dwDVDHostBaseAddress + 0x40;

		// Initialize the hardware
	ASSERT( ConfigInfo->AdapterInterfaceType == PCIBus );
	pHwDevExt->bIsVxp524	= TRUE;
	pHwDevExt->nVGAMode		= TRUE;
	pHwDevExt->dwColorKey	= 0;
	// Now we are going to determine what kind of chip we are dealing with. Check device
	// and vendor ID of our device on PCI bus
	if( StreamClassReadWriteConfig( pSrb->HwDeviceExtension, TRUE,
									&dwDeviceID, 0, sizeof( dwDeviceID ) ) == TRUE )
	{
		// This is vendor ID, should be AuraVision's 0x11D1
		ASSERT( LOWORD( dwDeviceID ) == 0x11D1 );
		// This is device ID. It could be 524 or 526
		if( HIWORD( dwDeviceID ) != 0x01F7 )		// This doesn't happen to be 524
			pHwDevExt->bIsVxp524 = FALSE;
	}


	
}

BOOL InitializeOutputStream( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	BOOL bReturn;
	if(AnalogInitialize( pSrb ))
		bReturn = TRUE;
	else
		bReturn = FALSE;
	return bReturn;
}

void OpenOutputStream(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
	++pHwDevExt->nAnalogStreamOpened;
	AnalogOpenStream( pSrb );
}
void Close_OutputStream(PHW_DEVICE_EXTENSION pHwDevExt)
{
	--pHwDevExt->nAnalogStreamOpened;
}
void UnIntializeOutputStream(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	AnalogUninitialize( pSrb );
}
void CloseOutputStream(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	AnalogCloseStream( pSrb );
}
void InitDevProp(PHW_STREAM_REQUEST_BLOCK pSrb,PKSPROPERTY_SET psEncore)
{
	PHW_STREAM_HEADER pStrHdr = &(pSrb->CommandData.StreamBuffer->StreamHeader);
	pStrHdr->NumDevPropArrayEntries	= SIZEOF_ARRAY( psEncore );
	pStrHdr->DevicePropertiesArray	= (PKSPROPERTY_SET)psEncore;
}
void DisableThresholdInt()
{
	
}

BOOL Aborted()
{
	return FALSE;
}

void EnableVideo(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
	PHW_STREAM_EXTENSION pStreamExt = (PHW_STREAM_EXTENSION)pSrb->StreamObject->HwStreamExtension;
	if( pStreamExt->bVideoEnabled == FALSE )
	{
		if( !AV_EnableVideo() )
		{
			DebugPrint(( DebugLevelWarning, "AuraVision's AV_DisableVideo() failed" ));
			pSrb->Status = STATUS_IO_DEVICE_ERROR;
		}
		else
			pStreamExt->bVideoEnabled = TRUE;
	}
}
BOOL SetTVSystem(WORD wFormat)
{
	return TRUE;
}
TV_SetEncoderType(WORD wEncType)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dxr2\fpga.h ===
/******************************************************************************\
*                                                                              *
*      FPGA.H        -     FPGA support.                                       *
*                                                                              *
*      Copyright (c) C-Cube Microsystems 1996                                  *
*      All Rights Reserved.                                                    *
*                                                                              *
*      Use of C-Cube Microsystems code is governed by terms and conditions     *
*      stated in the accompanying licensing statement.                         *
*                                                                              *
\******************************************************************************/

#ifndef _FPGA_H_
#define _FPGA_H_

//-------------------------------------------------------------------
// FPGA BITS DEFINITION
//-------------------------------------------------------------------
#if defined(OVATION)
#define FPGA_I2C_CLOCK          0x01
#define FPGA_I2C_DATA           0x02
#define FPGA_I2C_DIRECTION      0x04
#define FPGA_AUDIO_CS           0x08
#define FPGA_SECTOR_START       0x10
#define FPGA_DECRIPTION_BYPASS  0x20
#define FPGA_BUS_MASTER         0x40
#define FPGA_GP_OUTPUT          0x80

#define FPGA_FORCE_BM           0x0100
#endif  // OVATION

#if defined(ENCORE)
/* These are for the Creative board */

#define   ZIVA_NO_RESET       0x1   //  0 Reset 1 Normal
#define   CP_NO_RESET         0x2   //  Ditto
#define   RESERVED            0x4
#define   DMA_NO_RESET        0x8   //  Ditto

/* The BGNI is the same with FPGA_SECTOR_START */
#define   BGNI_ON             0x10  //  1 BGNI count on
#define FPGA_SECTOR_START       0x10

#define		FPGA_STATE_MACHINE	0x20	//	1 On 0 Off
#define   ZIVA_INT            0x40  //  0 Enable 1 Disable
#define   AUDIO_STROBE        0x80  //  0 Select 1 Not-Select

// Version control
#define FPGA_VERSION          0x0C  // bits 2 and 3 are version control bits
#define FPGA_VERSION_1_0      0x0C
#define FPGA_VERSION_2_0      0x04
#endif  // ENCORE


BOOL FPGA_Init( DWORD dwFPGABase );
void FPGA_Set( WORD wMask );
void FPGA_Clear( WORD wMask );
void FPGA_Write( WORD wData );
WORD FPGA_Read();

#ifndef LOBYTE
#define LOBYTE(w)           ((BYTE)(w))
#define HIBYTE(w)           ((BYTE)(((WORD)(w) >> 8) & 0xFF))
#endif

#endif  // _FPGA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dxr2\hli.h ===
/******************************************************************************\
*                                                                              *
*      HLI.H - Highlight related code header file.                             *
*                                                                              *
*      Copyright (c) C-Cube Microsystems 1996                                  *
*      All Rights Reserved.                                                    *
*                                                                              *
*      Use of C-Cube Microsystems code is governed by terms and conditions     *
*      stated in the accompanying licensing statement.                         *
*                                                                              *
\******************************************************************************/

#ifndef _HLI_H_
#define _HLI_H_

void HighlightSetPropIfAdapterReady( PHW_DEVICE_EXTENSION pHwDevExt );

#endif  // _HLI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dxr2\hwif.h ===
/******************************************************************************\
*                                                                              *
*      HWIF.H       -     Hardware abstraction level library.                *
*                                                                              *
*      Copyright (c) C-Cube Microsystems 1996                                  *
*      All Rights Reserved.                                                    *
*                                                                              *
*      Use of C-Cube Microsystems code is governed by terms and conditions     *
*      stated in the accompanying licensing statement.                         *
*                                                                              *
\******************************************************************************/

void InitializeHost(PHW_STREAM_REQUEST_BLOCK pSrb );
BOOL InitializeOutputStream( PHW_STREAM_REQUEST_BLOCK pSrb );
void ProcessVideoFormat( PKSDATAFORMAT pfmt, PHW_DEVICE_EXTENSION pHwDevExt );
void OpenOutputStream(PHW_STREAM_REQUEST_BLOCK pSrb);
void Close_OutputStream(PHW_DEVICE_EXTENSION pHwDevExt);
void UnIntializeOutputStream(PHW_STREAM_REQUEST_BLOCK pSrb);
void CloseOutputStream(PHW_STREAM_REQUEST_BLOCK pSrb);
void InitDevProp(PHW_STREAM_REQUEST_BLOCK pSrb,PKSPROPERTY_SET psEncore);
void DisableThresholdInt();
BOOL Aborted();
void EnableVideo(PHW_STREAM_REQUEST_BLOCK pSrb);
void Close_OutputStream();
void XferData(PHW_STREAM_REQUEST_BLOCK pSrb,PHW_DEVICE_EXTENSION pHwDevExt,DWORD dwPageToSend,
							DWORD dwCurrentSample);
void FinishCurrentPacketAndSendNextOne( PHW_DEVICE_EXTENSION pHwDevExt );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dxr2\hli.c ===
/******************************************************************************\
*                                                                              *
*      HLI.C - Highlight related code.                                         *
*                                                                              *
*      Copyright (c) C-Cube Microsystems 1996                                  *
*      All Rights Reserved.                                                    *
*                                                                              *
*      Use of C-Cube Microsystems code is governed by terms and conditions     *
*      stated in the accompanying licensing statement.                         *
*                                                                              *
\******************************************************************************/

#include "Headers.h"
#pragma hdrstop
#include "hli.h"
#include "cl6100.h"

#define TIMEOUT_COUNT     10
static DWORD dwTimeOut = TIMEOUT_COUNT;

BOOL bJustHighLight = FALSE;

extern void UpdateOrdinalNumber(IN PHW_DEVICE_EXTENSION pHwDevExt);
static void HighlightSetProp( PHW_DEVICE_EXTENSION pHwDevExt );

/*
** HighlightSetPropIfAdapterReady ()
**
**   Set property handling routine for the Highlight.
**
** Arguments:
**
**   pSrb -> property command block
**   pSrb->CommandData.PropertyInfo describes the requested property
**
** Returns:
**
** Side Effects:
*/
void HighlightSetPropIfAdapterReady( PHW_DEVICE_EXTENSION pHwDevExt )
{
//	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
	PKSPROPERTY_SPHLI hli = &(pHwDevExt->hli);

	if ( hli->StartPTM == 0 )
	{
		//
		// Make sure that the next real Highlight is not executed before
		// valid SPU is received (and before it's time).
		//

		pHwDevExt->bValidSPU = FALSE;

		//
		// Set HLI here to clean up the screen.
		//

		HighlightSetProp( pHwDevExt );
		pHwDevExt->bHliPending = FALSE;
	}
	else
	{

		if ( ( !pHwDevExt->bValidSPU || (hli->StartPTM > DVD_GetSTC()) ) && dwTimeOut  )
		{
			MonoOutStr( " !!! Schedule HLI CB !!! " );

			dwTimeOut--;

			StreamClassScheduleTimer( NULL, pHwDevExt,
				                    100000,
					                (PHW_TIMER_ROUTINE)HighlightSetPropIfAdapterReady,
						            pHwDevExt );
			if(pHwDevExt->bTimerScheduled)		//temp fix //sri
			{
				pHwDevExt->bTimerScheduled = FALSE;
				MonoOutStr("CallAdapterSend");
				UpdateOrdinalNumber(pHwDevExt);
				AdapterSendData(pHwDevExt);
			}

      

		}
		else
		{
			//
			// This set most likely will be called when menu is already ON.
			//
			HighlightSetProp( pHwDevExt );
			pHwDevExt->bHliPending = FALSE;
		}
	}
}

/*
** HighlightSetProp ()
**
**   Set property handling routine for the Highlight.
**
** Arguments:
**
**   pSrb -> property command block
**   pSrb->CommandData.PropertyInfo describes the requested property
**
** Returns:
**
** Side Effects:
*/
static void HighlightSetProp( PHW_DEVICE_EXTENSION pHwDevExt )
{
  DWORD dwContrast;
  DWORD dwColor;
  DWORD dwYGeom;
  DWORD dwXGeom;
  PKSPROPERTY_SPHLI hli = &(pHwDevExt->hli);

  dwColor    =  ( (DWORD)(hli->ColCon.emph1col) <<  8) +
                ( (DWORD)(hli->ColCon.emph2col) << 12) +
                ( (DWORD)(hli->ColCon.backcol)  <<  0) +
                ( (DWORD)(hli->ColCon.patcol)   <<  4);

  dwContrast =  ( (DWORD)(hli->ColCon.emph1con) <<  8) +
                ( (DWORD)(hli->ColCon.emph2con) << 12) +
                ( (DWORD)(hli->ColCon.backcon)  <<  0) +
                ( (DWORD)(hli->ColCon.patcon)   <<  4);

  dwYGeom    = ( ((DWORD)(hli->StartY)) << 12) + (hli->StopY);

  dwXGeom    = ( ((DWORD)(hli->StartX)) << 12) + (hli->StopX);

  MonoOutChar('<');
  MonoOutULong( hli->StartPTM );
  MonoOutChar('-');
  MonoOutULong( hli->EndPTM );
  MonoOutChar('>');
  DVD_GetSTC();

  //bJustHighLight = TRUE;

  if((dwXGeom == 0)&& (dwYGeom==0))
		return;

  if ( !DVD_HighLight2( dwContrast, dwColor, dwYGeom, dwXGeom ) )
  {
    MonoOutStr( " !!!! DVD_HighLight2 has failed !!!! " );
  }

  //
  // Restore the Timeout counter
  //
  dwTimeOut = TIMEOUT_COUNT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dxr2\misc.h ===
/******************************************************************************\
*                                                                              *
*      MISC.H      -     Hardware abstraction level library.                *
*                                                                              *
*      Copyright (c) C-Cube Microsystems 1996                                  *
*      All Rights Reserved.                                                    *
*                                                                              *
*      Use of C-Cube Microsystems code is governed by terms and conditions     *
*      stated in the accompanying licensing statement.                         *
*                                                                              *
\******************************************************************************/

void  DelayNoYield(int nIOCycles);
DWORD BRD_GetDramParam(DWORD dwParamId);
void ReleaseClockEvents(PHW_DEVICE_EXTENSION pdevex,BOOL fMarkInterval);
void UserDataEvents(PHW_DEVICE_EXTENSION pHwDevExt);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dxr2\monovxd.h ===
/******************************************************************************\
*                                                                              *
*      MONOVXD.H     -     Monochrome monitor output.                          *
*                                                                              *
*      Copyright (c) C-Cube Microsystems 1996                                  *
*      All Rights Reserved.                                                    *
*                                                                              *
*      Use of C-Cube Microsystems code is governed by terms and conditions     *
*      stated in the accompanying licensing statement.                         *
*                                                                              *
\******************************************************************************/

#ifndef __MONOVXD_H__
#define __MONOVXD_H__

#if !defined( DEBUG ) & !defined( _DEBUG )
// Use monochrome stuff only for debug versions
#ifdef USE_MONOCHROMEMONITOR
#undef USE_MONOCHROMEMONITOR
#endif
#endif


#ifdef USE_MONOCHROMEMONITOR
	void MonoOutInit();
	void MonoOutChar( char c );
	void MonoOutStr( LPSTR szStr );
	void MonoOutInt( int val );
	void MonoOutHex( int val );
	void MonoOutULong( DWORD val );
	void MonoOutULongHex( DWORD val );
	BOOL MonoOutSetBlink( BOOL bNewValue );
	BOOL MonoOutSetUnderscore( BOOL bNewValue );
#else
	#define MonoOutInit()
	#define MonoOutChar( c )
	#define MonoOutStr( szStr )
	#define MonoOutInt( val )
	#define MonoOutHex( val )
	#define MonoOutULong( val )
	#define MonoOutULongHex( val )
	#define MonoOutSetBlink( bNewValue )
	#define MonoOutSetUnderscore( bNewValue )
#endif			// #ifdef USE_MONOCHROMEMONITOR


#endif			// #ifndef __MONOVXD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dxr2\mvstub.h ===
/******************************************************************************
*
*	$RCSfile: MVStub.h $
*	$Source: u:/si/VXP/Wdm/Encore/MVision/MVStub.h $
*	$Author: Max $
*	$Date: 1998/11/05 23:15:44 $
*	$Revision: 1.2 $
*
*	Written by:		Max Paklin
*	Purpose:		Declaration of MacroVision SET procedure
*
*******************************************************************************
*
*	Copyright  1996-97, AuraVision Corporation. All rights reserved.
*
*	AuraVision Corporation makes no warranty of any kind, express or implied,
*	with regard to this software. In no event shall AuraVision Corporation
*	be liable for incidental or consequential damages in connection with or
*	arising from the furnishing, performance, or use of this software.
*
*******************************************************************************/

#ifndef __MVSTUB_H__
#define __MVSTUB_H__

#ifdef __cplusplus
extern "C" {
#endif

#ifndef TRUE
#define FALSE	0
#define TRUE	(!FALSE)
#endif


// Exported function that takes care of setting MacroVision level
// Prototype:
//		int __stdcall SetMacroVisionLevel( int nFormat, unsigned long ulLevel );
// Parameters:
//		nFormat		- TRUE (=1) stands for NTSC, FALSE (=0) - for PAL
//		ulLevel		- MacroVision level to set
// Return vale:
//		TRUE (=1)	- success
//		FALSE (=0)	- hardware failure
int __stdcall SetMacroVisionLevel( int nFormat, unsigned long ulLevel );


// Functions are exported by WDM for using by stub. Provide service for
// programming video decoder using I2C protocol (set/get register)
// Prototype:
//		int __stdcall SetI2CRegister( unsigned int uID, unsigned int uIndex, unsigned int uData );
// Parameters:
//		uID			- external chip ID
//		uIndex		- external chip register index
//		uData		- data to be programmed
// Return value:
//		TRUE (=1)	- success
//		FALSE (=0)	- hardware failure

int __stdcall SetI2CRegister( unsigned int uID, unsigned int uIndex, unsigned int uData );
// Prototype:
//		unsigned int __stdcall GetI2CRegister( unsigned int uID, unsigned int uIndex );
// Parameters:
//		uID			- external chip ID
//		uIndex		- external chip register index
// Return value:
//		[value]		- value that currently stored in specified encoder register
unsigned int __stdcall GetI2CRegister( unsigned int uID, unsigned int uIndex );


#ifdef __cplusplus
}
#endif

#endif				// #ifndef __MVSTUB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dxr2\mpinit.c ===
/******************************************************************************\
*                                                                              *
*      MpInit.C       -     Hardware abstraction level library.                *
*                                                                              *
*      Copyright (c) C-Cube Microsystems 1998                                  *
*      All Rights Reserved.                                                    *
*                                                                              *
*      Use of C-Cube Microsystems code is governed by terms and conditions     *
*      stated in the accompanying licensing statement.                         *
*                                                                              *
\******************************************************************************/

#include "Headers.h"
#pragma hdrstop


/*
** DriverEntry()
**
** This routine is called when the mini driver is first loaded.  The driver
** should then call the StreamClassRegisterAdapter function to register with
** the stream class driver
**
** Arguments:
**
**  Context1:  The context arguments are private plug and play structures
**             used by the stream class driver to find the resources for this
**             adapter
**  Context2:
**
** Returns:
**
** This routine returns an NT_STATUS value indicating the result of the
** registration attempt. If a value other than STATUS_SUCCESS is returned, the
** minidriver will be unloaded.
**
** Side Effects:  none
*/

#pragma alloc_text( init, DriverEntry )

NTSTATUS DriverEntry( IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath )
{
	HW_INITIALIZATION_DATA HwInitData;  // Hardware Initialization data structure
	LONG lStatus;

	DebugPrint(( DebugLevelVerbose, "ZiVA: Begin DriverEntry\n" ));
	RtlZeroMemory( &HwInitData, sizeof( HwInitData ) );

	HwInitData.HwInitializationDataSize		= sizeof( HwInitData );
	HwInitData.HwInterrupt					= HwInterrupt;		// IRQ handling routine

	// data handling routines
	HwInitData.HwReceivePacket				= AdapterReceivePacket;
	HwInitData.HwCancelPacket				= AdapterCancelPacket;
	HwInitData.HwRequestTimeoutHandler		= AdapterTimeoutPacket;
	HwInitData.DeviceExtensionSize			= sizeof( HW_DEVICE_EXTENSION );
	HwInitData.PerRequestExtensionSize		= 0;
	HwInitData.FilterInstanceExtensionSize	= 0;
	HwInitData.PerStreamExtensionSize		= 16;//sizeof( HW_STREAM_EXTENSION );
	HwInitData.BusMasterDMA					= TRUE;
	HwInitData.Dma24BitAddresses			= FALSE;
	HwInitData.BufferAlignment				= 4;
	HwInitData.TurnOffSynchronization		= FALSE;
	HwInitData.DmaBufferSize				= DISC_KEY_SIZE;

	// Attempt to register with the streaming class driver.  Note, this will
	// result in calls to the HW_INITIALIZE routine.
	DebugPrint(( DebugLevelVerbose, "ZiVA: call to StreamClassRegisterAdapter()\n" ));
	lStatus = StreamClassRegisterAdapter( DriverObject, RegistryPath, &HwInitData );
	DebugPrint(( DebugLevelVerbose, "ZiVA: StreamClassRegisterAdapter() returned ::> %lX\n", lStatus ));
	DebugPrint(( DebugLevelVerbose, "ZiVA: End DriverEntry\n" ));

	return lStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dxr2\registry.h ===
/************************************************************************
// Copyright (c) 1998. C-Cube Microsystems.
// All Rights Reserved.
// This source code and related information are copyrighted
// proprietory technology of C-Cube Microsystems,
// ("C-Cube") released under a specific license for its
// confidentiality and protection as C-Cube's trade secret.        
// 
// Unauthorized disclosure, exposure, duplication, copying,
// distribution or any other use than that specifically    
// authorized by C-Cube is strictly prohibited.          
//
// Filename: RegistryApi.h
//
// Description:
// 	This module contains registry related functions.
//
//                     C H A N G E   R E C O R D
//
//   Date   Initials          Description
// --------	-------- 	-----------------------------------------------
// 06/10/98	Satish		Created this file.
// 08/06/98	Landon		Converted to WDM Driver.
// 09/09/98	Satish		Changed wcsicmp to _wcsicmp.
// 10/30/98	JChapman	Merged with code for multiple board support
//
************************************************************************/
#ifndef _REGAPI_HEADER
#define _REGAPI_HEADER

#ifdef __cplusplus
extern "C" {
#endif

#ifndef DRIVER

#ifndef DllExport
#define DllExport	__declspec (dllexport)
#endif

#else

#ifdef DllExport
#undef DllExport
#endif

#define DllExport

#endif

// My own UNICODE independant definitions

#ifdef UNICODE
#define STRCPY wcscpy
#define STRCAT wcscat
#define STRCMP wcscmp
#define STRLEN wcslen
#define STRICMP _wcsicmp
#else
#define STRCPY strcpy
#define STRCAT strcat
#define STRCMP strcmp
#define STRLEN strlen
#define STRICMP stricmp
#endif

//----------------------
// Constant definitions
//----------------------
#ifndef DRIVER

#define DEFAULT_REGISTY_PATH	TEXT("SOFTWARE\\C-Cube Microsystems\\2Real")

#else

#define DEFAULT_REGISTY_PATH	TEXT("SOFTWARE\\C-Cube Microsystems\\2Real")

#endif
//----------------------------
// External data declarations 
//----------------------------


//----------------------------
// Function declarations.
//----------------------------
int						// Return value read from registry.
REG_GetPrivateProfileInt(			// Read int value from registry.
	PTSTR	pszSection,				// Pointer to section.
	PTSTR	pszEntry,				// Pointer to entry.
	int		nDefault,				// Default value.
	HANDLE	pszPath);				// Registry path. If NULL default path is used.

BOOL						// Return TRUE on success, else FALSE.
REG_WritePrivateProfileInt(			// Write int value to registry.
	PTSTR	pszSection,				// Pointer to section.
	PTSTR	pszEntry,				// Pointer to entry.
	int		nValue,					// Value to be written.
	HANDLE	pszPath);				// Registry path. If NULL default path is used.

long						// Return value read from registry.
REG_GetPrivateProfileLong(			// Read int value from registry.
	PTSTR	pszSection,				// Pointer to section.
	PTSTR	pszEntry,				// Pointer to entry.
	long	lDefault,				// Default value.
	HANDLE	pszPath);				// Registry path. If NULL default path is used.

BOOL						// Return TRUE on success, else FALSE.
REG_WritePrivateProfileLong(		// Write int value to registry.
	PTSTR	pszSection,				// Pointer to section.
	PTSTR	pszEntry,				// Pointer to entry.
	long	lValue,					// Value to be written.
	HANDLE	pszPath);				// Registry path. If NULL default path is used.

BOOL						// Return # of chars read.
REG_GetPrivateProfileString(		// Read string from registry.
	PTSTR	pszSection,				// Pointer to section.
	PTSTR	pszEntry,				// Pointer to entry.
	PTSTR	pszDefault,				// Pointer to default string.
	PTSTR	pString,				// Pointer to get the string.
	int		nStringSize,			// string size in bytes.
	HANDLE	pszPath);				// Registry path. If NULL default path is used.

BOOL 						// Return # of chars written.
REG_WritePrivateProfileString(		// Write the string to registry.
	PTSTR	pszSection,				// Pointer to section.
	PTSTR	pszEntry,				// Pointer to entry.
	PTSTR	pString,				// Pointer to get the string.
	HANDLE	pszPath);				// Registry path. If NULL default path is used.


#ifndef DRIVER

#endif

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dxr2\monovxd.c ===
/******************************************************************************\
*                                                                              *
*      MONOVXD.C     -     _________________________________________.          *
*                                                                              *
*      Copyright (c) C-Cube Microsystems 1996                                  *
*      All Rights Reserved.                                                    *
*                                                                              *
*      Use of C-Cube Microsystems code is governed by terms and conditions     *
*      stated in the accompanying licensing statement.                         *
*                                                                              *
\******************************************************************************/


#ifdef VTOOLSD
#include <vtoolsc.h>
#include "monovxd.h"
#else
#include "Headers.h"
#pragma hdrstop
#endif
#ifdef USE_MONOCHROMEMONITOR
#include "xtoa.c"

/******************************************************************************\
*                                                                              *
*                           MONOCHROME MONITOR OUTPUT                          *
*                                                                              *
\******************************************************************************/

#define MONO_LINES      25
#define MONO_COLUMNS    80
#define MONO_ROW        ( MONO_COLUMNS * 2 )
#define MONO_ATTR_NORMAL       0x07
#define MONO_ATTR_HIGHLIGHT    0x08
#define MONO_ATTR_BLINK        0x80

static int		wOffset;
static char		bAttr;
static char*	mono_addr = NULL;

NTHALAPI
BOOLEAN
HalTranslateBusAddress(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );
void MonoOutInit()
{
	int i;

#ifdef VTOOLSD
	mono_addr = (char*)MapPhysToLinear( (PVOID)0xB0000, 4096, 0 );
#else
	// Oh, man! Wind95 times are gone!
	//mono_addr = (char*)0xB0000;
	{
		PHYSICAL_ADDRESS paIn, paOut;
		ULONG ulMemory;
        paIn.LowPart = 0xB0000;
        paIn.HighPart = 0;
		HalTranslateBusAddress( Isa, 0, paIn, &ulMemory, &paOut );
		mono_addr = (char*)MmMapIoSpace( paOut, 4096, MmNonCached );
		if( mono_addr == (char*)0xFFFFFFFF )
			mono_addr = NULL;
	}
#endif

	if( mono_addr )
	{
		for ( i = 0 ; i < MONO_LINES * MONO_ROW; *(char*)(mono_addr + i++) = ' ' )
			;
		wOffset = 0;
		bAttr = MONO_ATTR_NORMAL;
	}
}



void MonoOutChar( char c )
{
	int i;

	if( mono_addr )
	{
		if ( c == '\n' )
		{
			// Fill the rest of the line with spaces
			for ( i = 0 ; i < ( MONO_ROW - wOffset % MONO_ROW ) ;
				*( char * )( mono_addr + wOffset + i++ ) = ' ' );

			wOffset += MONO_ROW - wOffset % MONO_ROW;
		}
		else
		{
			*( char * )( mono_addr + wOffset++ ) = c;
			*( char * )( mono_addr + wOffset++ ) = bAttr;
		}

		if ( wOffset >= MONO_LINES * MONO_ROW )
		{
			wOffset = 0;
			bAttr ^= MONO_ATTR_HIGHLIGHT;
		}
	}
}



void MonoOutStr( char * szStr )
{
	if ( ! szStr )
		return;

	while ( *szStr )
		MonoOutChar( *szStr++ );
}

void MonoOutInt( int val )
{
	char buff[ 12 ];

#if 1//def VTOOLSD
	_itoa( val, buff, 10 );
#else
	buff[0] = '?';
	buff[1] = 0;
#endif
	MonoOutStr( buff );
}

void MonoOutHex( int val )
{
	char buff[ 12 ];

#if 1//def VTOOLSD
	_itoa( val, buff, 16 );
#else
	buff[0] = '?';
	buff[1] = 0;
#endif
	MonoOutStr( buff );
}


void MonoOutULong( DWORD val )
{
    char buff[ 12 ];

#if 1//def VTOOLSD
	_ltoa( val, buff, 10 );
#else
	buff[0] = '?';
	buff[1] = 0;
#endif
	MonoOutStr( buff );
}

void MonoOutULongHex( DWORD val )
{
	char buff[ 12 ];

#if 1//def VTOOLSD
	_ltoa( val, buff, 16 );
#else
	buff[0] = '?';
	buff[1] = 0;
#endif
	MonoOutStr( buff );
}

BOOL MonoOutSetBlink( BOOL bNewValue )
{
	BOOL bOldValue = (bAttr & MONO_ATTR_BLINK)?TRUE:FALSE;

	if ( bNewValue )
		bAttr |= MONO_ATTR_BLINK;
	else
		bAttr &= ~MONO_ATTR_BLINK;

	return bOldValue;
}

BOOL MonoOutSetUnderscore( BOOL bNewValue )
{
	BOOL bOldValue = ((bAttr & MONO_ATTR_NORMAL) == 1)?TRUE:FALSE;

	bAttr &= 0xf9;       // only blink and highlight remain
	if ( bNewValue )
		bAttr |= 1;
	else
		bAttr |= 2;

	return bOldValue;
}
#endif			// #ifdef USE_MONOCHROMEMONITOR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dxr2\registry.c ===
/******************************************************************************\
*                                                                              *
*      RegistryAPi.C  -     Adapter control related code.                          *
*                                                                              *
*      Copyright (c) C-Cube Microsystems 1996 - 1999                                 *
*      All Rights Reserved.                                                    *
*                                                                              *
*      Use of C-Cube Microsystems code is governed by terms and conditions     *
*      stated in the accompanying licensing statement.                         *
*                                                                              *
\******************************************************************************/

// C related include files.
#include <strmini.h>

// typedef HANDLE  HKEY;


#include "Registry.h"


static BOOL
GetRegistryKey(						// Get registry key
	PTSTR	pszSection,				// Pointer to section.
	PTSTR	pszEntry,				// Pointer to entry.
	HANDLE	pszPath,				// Registry Key Handle. If NULL default path is used.
	HKEY *	phKey);					// Pointer to receive the key.

int			// Return value read from registry.
REG_GetPrivateProfileInt(			// Read int value from registry.
	PTSTR	pszSection,				// Pointer to section.
	PTSTR	pszEntry,				// Pointer to entry.
	int		nDefault,				// Default value.
	HANDLE	pszPath)				// Registry Key Handle If NULL default path is used.
{
	HKEY hKey = NULL;

	DWORD dwType = REG_DWORD;
	DWORD dwSize = sizeof(DWORD);
	DWORD dwData = 0;
	LPBYTE lpData = (LPBYTE)&dwData;

	RTL_QUERY_REGISTRY_TABLE query[] = 
	{
		{
			NULL,    
			RTL_QUERY_REGISTRY_DIRECT,    
			pszEntry,
			(PVOID)lpData,  
			dwType,
			NULL,
			0
		},
		{
			NULL,    
			0,    
			NULL,
			NULL,  
			0,
			NULL,
			0
		}
	};

	if (pszEntry == NULL)
		return 0;

	if (!GetRegistryKey(pszSection, pszEntry, pszPath, &hKey))
		return nDefault;

#ifdef UNICODE
    
	if (!NT_SUCCESS(RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
										   (PCWSTR)hKey,	// key handle
										   query,
										   NULL,
										   NULL)))
#endif

		return nDefault;

	ZwClose( hKey );
	return (int)dwData;
}

BOOL			// Return TRUE on success, else FALSE.
REG_WritePrivateProfileInt(			// Write int value to registry.
	PTSTR	pszSection,				// Pointer to section.
	PTSTR	pszEntry,				// Pointer to entry.
	int		nValue,					// Value to be written.
	HANDLE	pszPath)				// Registry Key Handle. If NULL default path is used.
{
	HKEY hKey = NULL;

	DWORD dwType = REG_DWORD;
	DWORD dwSize = sizeof(DWORD);
	DWORD dwData = (DWORD)nValue;

	if (pszEntry == NULL)
		return FALSE;

	if (!GetRegistryKey(pszSection, pszEntry, pszPath, &hKey))
		return FALSE;

#ifdef UNICODE
	if (!NT_SUCCESS(RtlWriteRegistryValue(RTL_REGISTRY_HANDLE, 
										  (PCWSTR)hKey,
										  pszEntry, 
										  dwType, 
										  (PVOID)&dwData, 
										  dwSize)))
#endif

		return FALSE;

	ZwClose( hKey );
	return TRUE;
}

long			// Return value read from registry.
REG_GetPrivateProfileLong(			// Read int value from registry.
	PTSTR	pszSection,				// Pointer to section.
	PTSTR	pszEntry,				// Pointer to entry.
	long	lDefault,				// Default value.
	HANDLE	pszPath)				// Registry path. If NULL default path is used.
{
	HKEY hKey = NULL;

	DWORD dwType = REG_DWORD;
	DWORD dwSize = sizeof(DWORD);
	DWORD dwData = 0;
	LPBYTE lpData = (LPBYTE)&dwData;

	RTL_QUERY_REGISTRY_TABLE query[] = 
	{
		{
			NULL,    
			RTL_QUERY_REGISTRY_DIRECT,    
			pszEntry,
			(PVOID)lpData,  
			dwType,
			&lDefault,
			sizeof(long)
		},
		{
			NULL,    
			0,    
			NULL,
			NULL,  
			0,
			NULL,
			0
		}
		
	};

	if (pszEntry == NULL)
		return 0;


	if (!GetRegistryKey(pszSection, pszEntry, pszPath, &hKey))
		return lDefault;

#ifdef UNICODE
    
	if (!NT_SUCCESS(RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
										   (PCWSTR)hKey,	// key handle
										   query,
										   NULL,
										   NULL)))
#endif
		return lDefault;

	ZwClose( hKey );
	return (long)dwData;
}

BOOL			// Return TRUE on success, else FALSE.
REG_WritePrivateProfileLong(		// Write long value to registry.
	PTSTR	pszSection,				// Pointer to section.
	PTSTR	pszEntry,				// Pointer to entry.
	long	lValue,					// Value to be written.
	HANDLE	pszPath)				// Registry path. If NULL default path is used.
{
	HKEY hKey = NULL;

	DWORD dwType = REG_DWORD;
	DWORD dwSize = sizeof(DWORD);
	DWORD dwData = (DWORD)lValue;

	if (pszEntry == NULL)
		return FALSE;

	if (!GetRegistryKey(pszSection, pszEntry, pszPath, &hKey))
		return FALSE;

#ifdef UNICODE
	if (!NT_SUCCESS(RtlWriteRegistryValue(RTL_REGISTRY_HANDLE,
										  (PCWSTR)hKey, 
										  pszEntry, 
										  dwType, 
										  (PVOID)&dwData, 
										  dwSize)))
#endif
		return FALSE;

	ZwClose( hKey );
	return TRUE;
}


BOOL								// Return # of chars read.
REG_GetPrivateProfileString(		// Read string from registry.
	PTSTR	pszSection,				// Pointer to section.
	PTSTR	pszEntry,				// Pointer to entry.
	PTSTR	pszDefault,				// Pointer to default string.
	PTSTR	pString,				// Pointer to get the string.
	int		nStringSize,			// string size in bytes.
	HANDLE	pszPath)				// Registry path. If NULL default path is used.
{
	HKEY hKey = NULL;

	DWORD dwType = REG_SZ;
	DWORD dwSize = (DWORD)nStringSize;
	DWORD dwData = (DWORD)pString;
	LPBYTE lpData = (LPBYTE)&dwData;

	UNICODE_STRING string = {
		(USHORT)0,
		(USHORT)dwSize,
		pString
	};

	RTL_QUERY_REGISTRY_TABLE query[] = 
	{
		{
			NULL,    
			RTL_QUERY_REGISTRY_DIRECT,    
			pszEntry,
			(PVOID)&string,  
			dwType,
			pszDefault,
			STRLEN(pszDefault) * sizeof(WCHAR)
		},
		{
			NULL,    
			0,    
			NULL,
			NULL,  
			0,
			NULL,
			0
		}
	};

	if (pszEntry == NULL)
		return 0;

	if (!GetRegistryKey(pszSection, pszEntry, pszPath, &hKey))
		return 0;

    
	if (!NT_SUCCESS(RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
										   (PCWSTR)hKey,
										   query,
										   NULL,
										   NULL)))

		return 0;

	ZwClose( hKey );
	return (int)(STRLEN(pString));
}

int			// Return # of chars written.
REG_WritePrivateProfileString(		// Write the string to registry.
	PTSTR	pszSection,				// Pointer to section.
	PTSTR	pszEntry,				// Pointer to entry.
	PTSTR	pString,				// Pointer to get the string.
	HANDLE	pszPath)				// Registry path. If NULL default path is used.
{
	HKEY hKey = NULL;

	DWORD dwType = REG_SZ;
	DWORD dwSize = (DWORD)(STRLEN(pString));
	DWORD dwData = (DWORD)pString;

	if (pszEntry == NULL)
		return 0;

	//if (!GetRegistryKey(pszSection, pszEntry, pszPath, &hKey))
	//	return 0;


	if (!NT_SUCCESS(RtlWriteRegistryValue(RTL_REGISTRY_HANDLE,
										  (PCWSTR)hKey, 
										  pszEntry, 
										  dwType, 
										  (PVOID)dwData, // note string IS address
										  dwSize)))
		return 0;

	ZwClose( hKey );
	return (int)(STRLEN(pString));
}

static BOOL				// Return TRUE on success, else FALSE
GetRegistryKey(						// Get registry key
	PTSTR	pszSection,				// Pointer to section.
	PTSTR	pszEntry,				// Pointer to entry.
	HANDLE	pszPath,				// Registry path. If NULL default path is used.
	HKEY *	phKey)					// Pointer to receive the key.
{
	NTSTATUS ntStatus;
	BOOL	 fRet=TRUE;
	UNICODE_STRING ustr;
	OBJECT_ATTRIBUTES objectAttributes;


	RtlInitUnicodeString( &ustr, pszSection);
	
	InitializeObjectAttributes(
			&objectAttributes,
			&ustr,
			OBJ_CASE_INSENSITIVE,
			pszPath,
			NULL);
	
	//ntStatus = ZwCreateKey( phKey,
	//				        KEY_ALL_ACCESS,
	//				        &objectAttributes,
	//				        0,
	//				        NULL,
	//				        REG_OPTION_NON_VOLATILE,
	//				        NULL);
	//
	// Only open existing key
	//
	ntStatus = ZwOpenKey( phKey,
						  KEY_ALL_ACCESS,
						  &objectAttributes);
	

	if ( !NT_SUCCESS( ntStatus )) {
		*phKey = NULL;
		fRet = FALSE;
	}

	return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dxr2\streamin.c ===
/******************************************************************************\
*                                                                              *
*      Streaming.C       -     Hardware abstraction level library.                *
*                                                                              *
*      Copyright (c) C-Cube Microsystems 1998                                  *
*      All Rights Reserved.                                                    *
*                                                                              *
*      Use of C-Cube Microsystems code is governed by terms and conditions     *
*      stated in the accompanying licensing statement.                         *
*                                                                              *
\******************************************************************************/

#include "headers.h"
#include "bmaster.h"
#include "cl6100.h"
#include "Hwif.h"
#include "boardio.h"



BOOL IsThereDataToSend(PHW_STREAM_REQUEST_BLOCK pSrb,DWORD dwPageToSend,DWORD dwCurrentSample)
{
	PKSSCATTER_GATHER			pSGList;
	DWORD						dwCount;
	
	if( (pSGList = pSrb->ScatterGatherBuffer) && (dwCount = pSGList[dwPageToSend].Length) )
		return TRUE;
	else
		return FALSE;
}


void XferData(PHW_STREAM_REQUEST_BLOCK pSrb,PHW_DEVICE_EXTENSION pHwDevExt,DWORD dwPageToSend,
							DWORD dwCurrentSample)
{
	PKSSCATTER_GATHER			pSGList;
	DWORD						dwCount;
	
	if( (pSGList = pSrb->ScatterGatherBuffer) && (dwCount = pSGList[dwPageToSend].Length) )
	{
		IssuePendingCommands(pHwDevExt);
		if( (dwCount )&& (dwCount <= 2048) )
		{
			DWORD* pdwPhysAddress = (DWORD*)pSGList[dwPageToSend].PhysicalAddress.LowPart;
			// Fire the data
			

			if(pSrb == pHwDevExt->pCurrentVideoSrb)
			{
				pHwDevExt->dwVideoDataUsed -= dwCount;	
			}
			else if(pSrb == pHwDevExt->pCurrentAudioSrb)
			{
				pHwDevExt->dwAudioDataUsed -= dwCount;	
			}
			else if(pSrb == pHwDevExt->pCurrentSubPictureSrb)
			{
				pHwDevExt->dwSubPictureDataUsed -= dwCount;	
			}


			if( !BMA_Send( pdwPhysAddress, dwCount ) )
					MonoOutStr("ZiVA: !!!! BMA_Send() has failed\n" );
			else
			{
				PKSSTREAM_HEADER pHeader;
				pHeader = (PKSSTREAM_HEADER)(pSrb->CommandData.DataBufferArray)+
							dwCurrentSample;
			
			
				pHwDevExt->bInterruptPending = TRUE;
//tmp				MonoOutULong(pHeader->TypeSpecificFlags >> 16);
//tmp				MonoOutStr("(");

			}
		}
		else
		{
			MonoOutStr("dwCount is 0");
			FinishCurrentPacketAndSendNextOne( pHwDevExt );
			
			
		}
	}
	else
	{
		MonoOutStr("NoDataToSend");
		FinishCurrentPacketAndSendNextOne( pHwDevExt );
	}

}

/*
** HwInterrupt()
**
**   Routine is called when an interrupt at the IRQ level specified by the
**   ConfigInfo structure passed to the HwInitialize routine is received.
**
**   Note: IRQs may be shared, so the device should ensure the IRQ received
**         was expected
**
** Arguments:
**
**  pHwDevExt - the device extension for the hardware interrupt
**
** Returns:
**
** Side Effects:  none
*/
BOOLEAN STREAMAPI HwInterrupt( IN PHW_DEVICE_EXTENSION pHwDevExt )
{
	BOOLEAN bMyIRQ = FALSE;

	if(!pHwDevExt->bInitialized)
		return FALSE;

	if(pHwDevExt->bInterruptPending == FALSE)
		MonoOutStr("{");

//tmp	MonoOutStr("+");

	if( BMA_Complete() )
	{
//tmp		if(pHwDevExt->bInterruptPending == FALSE)
//tmp			MonoOutStr("}");
//tmp		MonoOutStr(")");
		bMyIRQ = TRUE;
		
		pHwDevExt->bInterruptPending = FALSE;
		FinishCurrentPacketAndSendNextOne( pHwDevExt );
		
//		 dvd_CheckCFIFO();//sri

	}
	else 
	{
//tmp		if(pHwDevExt->bInterruptPending == FALSE)
//tmp			MonoOutStr("]");

		if(Aborted())
		{
			MonoOutStr("HWInt : Abort");
			bMyIRQ = TRUE;
			pHwDevExt->bInterruptPending = FALSE;
//			FinishCurrentPacketAndSendNextOne( pHwDevExt );
		}


	}
	

	if( BRD_CheckDecoderInterrupt() )
	{
		INTSOURCES IntSrc;
		DVD_Isr( &IntSrc );
//		MonoOutStr( "DI" );
		bMyIRQ = TRUE;
	}

	// Returning FALSE indicates that this was not an IRQ for this device, and
	// the IRQ dispatcher will pass the IRQ down the chain to the next handler
	// for this IRQ level
	return bMyIRQ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dxr2\streamin.h ===
//******************************************************************************/
//*                                                                            *
//*    streaming.h -                                                           *
//*                                                                            *
//*    Copyright (c) C-Cube Microsystems 1996                                  *
//*    All Rights Reserved.                                                    *
//*                                                                            *
//*    Use of C-Cube Microsystems code is governed by terms and conditions     *
//*    stated in the accompanying licensing statement.                         *
//*                                                                            *
//******************************************************************************/


UINT AdapterPrepareDataForSending( PHW_DEVICE_EXTENSION pHwDevExt,
									PHW_STREAM_REQUEST_BLOCK pCurrentStreamSrb,
									DWORD dwCurrentStreamSample,
									PHW_STREAM_REQUEST_BLOCK* ppSrb, DWORD* pdwSample,
									DWORD* dwCurrentSample,DWORD dwCurrentPage,
									LONG* pdwDataUsed);
BOOL IsThereDataToSend(PHW_STREAM_REQUEST_BLOCK pSrb,DWORD dwPageToSend,DWORD dwCurrentSample);

void XferData(PHW_STREAM_REQUEST_BLOCK pSrb,PHW_DEVICE_EXTENSION pHwDevExt,DWORD dwPageToSend,
			  DWORD dwCurrentSample);
void FinishCurrentPacketAndSendNextOne( PHW_DEVICE_EXTENSION pHwDevExt );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dxr2\tc6807af.c ===
//******************************************************************************/
//*                                                                            *
//*    tc6807af.c -                                                            *
//*                                                                            *
//*    Copyright (c) C-Cube Microsystems 1996                                  *
//*    All Rights Reserved.                                                    *
//*                                                                            *
//*    Use of C-Cube Microsystems code is governed by terms and conditions     *
//*    stated in the accompanying licensing statement.                         *
//*                                                                            *
//******************************************************************************/


//
//  TC6907AF.C  Digital Copy-Protection for DVD
//
/////////////////////////////////////////////////////////////////////
#ifdef VTOOLSD
#include <vtoolsc.h>
#include "monovxd.h"
#else
#include "Headers.h"
#pragma hdrstop
#endif

#include "cl6100.h"
#include "tc6807af.h"
#include "fpga.h"
#include "bmaster.h"
#include "boardio.h"

//-------------------------------------------------------------------
//  TC6907AF REGISTERS DECLARATION
//-------------------------------------------------------------------
#define COM         0x00
#define CNT_1       0x01
#define CNT_2       0x02
#define SD_STS      0x03
#define DEPT_1      0x04
#define DEPT_2      0x05

#define ETKG_0      0x10
#define ETKG_1      0x11
#define ETKG_2      0x12
#define ETKG_3      0x13
#define ETKG_4      0x14
#define ETKG_5      0x15

#define CHGG_0      0x30
#define CHGG_1      0x31
#define CHGG_2      0x32
#define CHGG_3      0x33
#define CHGG_4      0x34
#define CHGG_5      0x35
#define CHGG_6      0x36
#define CHGG_7      0x37
#define CHGG_8      0x38
#define CHGG_9      0x39

#define RSPG_0      0x40
#define RSPG_1      0x41
#define RSPG_2      0x42
#define RSPG_3      0x43
#define RSPG_4      0x44

// COM register bits
#define END         0x80
#define ERR         0x40

// CNT_1 register bits
#define RQ1         0x01
#define RQ2         0x02
#define ENBEND      0x04
#define ENBERR      0x08
#define CLINT       0x10

// CNT_2 register bits
#define THR         0x01
#define EB1         0x02
#define EB2         0x04
#define CDV16       0x08
#define AJSCK       0x10
#define SCR1        0x20
#define SCR2        0x40
#define SCR3        0x80

// Commands
#define NOP         0x00
#define DEC_RAND    0x12
#define DEC_DKY     0x15
#define DRV_AUTH    0x17
#define DEC_AUTH    0x18
#define DEC_DT      0x23
#define DEC_DTK     0x25

//-------------------------------------------------------------------
//  GLOBAL VARIABLES DECLARATION
//-------------------------------------------------------------------
DWORD  gdwIndex = 0;
DWORD  gdwData  = 0;

//-------------------------------------------------------------------
//  STATIC FUNCTIONS DECLARATION
//-------------------------------------------------------------------
BOOL tc6807af_GetChallengeData( BYTE * CHG );
BOOL tc6807af_SendChallengeData( BYTE * CHG );
BOOL tc6807af_GetResponseData( BYTE * RSP );
BOOL tc6807af_SendResponseData( BYTE * RSP );
BOOL tc6807af_SendDiskKeyData( BYTE * pBuffer );
BOOL tc6807af_SendTitleKeyData( BYTE * pBuffer );
BOOL tc6807af_SetDecryptionMode( BYTE * SR_FLAG );
BOOL tc6807af_NewCommand( BYTE Command );
void  tc6807af_WriteReg( BYTE byReg, BYTE byValue );
BYTE tc6807af_ReadReg( BYTE byReg );

//
//  TC6807AF_Initialize
//
/////////////////////////////////////////////////////////////////////
BOOL TC6807AF_Initialize( DWORD dwBaseAddress )
 {
  MonoOutStr( "  TC6807AF_Initialize " );
  MonoOutHex( dwBaseAddress );

  gdwIndex = dwBaseAddress;
  gdwData  = dwBaseAddress + 1;

  //tc6807af_WriteReg( CNT_1, ENBERR | ENBEND | RQ1 | RQ2 );

  // Step 1.
  tc6807af_WriteReg( CNT_2, 0|CDV16 );

  // Step 2.
  //tc6807af_WriteReg( CNT_2, AJSCK );
  /*
  tc6807af_WriteReg( CNT_2, 0 );
  tc6807af_WriteReg( CNT_2, AJSCK );
  tc6807af_WriteReg( CNT_2, 0 );
  tc6807af_WriteReg( CNT_2, AJSCK );
  tc6807af_WriteReg( CNT_2, 0 );
  tc6807af_WriteReg( CNT_2, AJSCK );
  tc6807af_WriteReg( CNT_2, 0 );
  tc6807af_WriteReg( CNT_2, AJSCK );
  tc6807af_WriteReg( CNT_2, 0 );
  tc6807af_WriteReg( CNT_2, AJSCK );
  tc6807af_WriteReg( CNT_2, 0 );
  tc6807af_WriteReg( CNT_2, AJSCK );
  tc6807af_WriteReg( CNT_2, 0 );
  tc6807af_WriteReg( CNT_2, AJSCK );
  tc6807af_WriteReg( CNT_2, 0 );
  */
  // Step 3.
  tc6807af_WriteReg( CNT_1, CLINT );

  // Step 4.
  tc6807af_WriteReg( DEPT_1, 0 );
  tc6807af_WriteReg( DEPT_2, 0 );
  tc6807af_WriteReg( CNT_2, AJSCK|SCR1 );

  // Step 5.
  tc6807af_WriteReg( CNT_1, RQ1 | RQ2 );
  tc6807af_WriteReg( CNT_2, AJSCK|SCR1|EB2|EB1|THR );

  MonoOutStr( "  " );
  return TRUE;
 }

//
//  TC6807AF_Reset
//
/////////////////////////////////////////////////////////////////////
BOOL TC6807AF_Reset()
 {
  return TRUE;
 }

//
//  TC6807AF_Authenticate
//
/////////////////////////////////////////////////////////////////////
BOOL TC6807AF_Authenticate( WORD wFunction, BYTE * pbyDATA )
 {
  switch ( wFunction )
  {
  case TC6807AF_GET_CHALLENGE:
    return tc6807af_GetChallengeData( pbyDATA );

  case TC6807AF_SEND_CHALLENGE:
    return tc6807af_SendChallengeData( pbyDATA );

  case TC6807AF_GET_RESPONSE:
    return tc6807af_GetResponseData( pbyDATA );

  case TC6807AF_SEND_RESPONSE:
    return tc6807af_SendResponseData( pbyDATA );

  case TC6807AF_SEND_DISK_KEY:
    return tc6807af_SendDiskKeyData( pbyDATA );

  case TC6807AF_SEND_TITLE_KEY:
    return tc6807af_SendTitleKeyData( pbyDATA );

  case TC6807AF_SET_DECRYPTION_MODE:
    return tc6807af_SetDecryptionMode( pbyDATA );
  }

  return FALSE;
 }


/******************************************************************************/
/******************* STATIC FUNCTIONS IMPLEMENTATION **************************/
/******************************************************************************/


//
//  tc6807af_GetChallengeData
//
/////////////////////////////////////////////////////////////////////
BOOL tc6807af_GetChallengeData( BYTE * CHG )
 {
  MonoOutStr( " [DEC_RAND:" );

  if ( !tc6807af_NewCommand( DEC_RAND ) )
    return FALSE;


  CHG[0] = tc6807af_ReadReg( CHGG_0 );
  CHG[1] = tc6807af_ReadReg( CHGG_1 );
  CHG[2] = tc6807af_ReadReg( CHGG_2 );
  CHG[3] = tc6807af_ReadReg( CHGG_3 );
  CHG[4] = tc6807af_ReadReg( CHGG_4 );
  CHG[5] = tc6807af_ReadReg( CHGG_5 );
  CHG[6] = tc6807af_ReadReg( CHGG_6 );
  CHG[7] = tc6807af_ReadReg( CHGG_7 );
  CHG[8] = tc6807af_ReadReg( CHGG_8 );
  CHG[9] = tc6807af_ReadReg( CHGG_9 );

  MonoOutStr( "] " );
  return TRUE;
 }

//
//  tc6807af_SendChallengeData
//
/////////////////////////////////////////////////////////////////////
BOOL tc6807af_SendChallengeData( BYTE * CHG )
 {
  MonoOutStr( " [DEC_AUTH:" );

  tc6807af_WriteReg( CHGG_0, CHG[0] );
  tc6807af_WriteReg( CHGG_1, CHG[1] );
  tc6807af_WriteReg( CHGG_2, CHG[2] );
  tc6807af_WriteReg( CHGG_3, CHG[3] );
  tc6807af_WriteReg( CHGG_4, CHG[4] );
  tc6807af_WriteReg( CHGG_5, CHG[5] );
  tc6807af_WriteReg( CHGG_6, CHG[6] );
  tc6807af_WriteReg( CHGG_7, CHG[7] );
  tc6807af_WriteReg( CHGG_8, CHG[8] );
  tc6807af_WriteReg( CHGG_9, CHG[9] );

  if ( !tc6807af_NewCommand( DEC_AUTH ) )
    return FALSE;

  return TRUE;
 }

//
//  tc6807af_GetResponseData
//
/////////////////////////////////////////////////////////////////////
BOOL tc6807af_GetResponseData( BYTE * RSP )
 {
  MonoOutStr( " [GetResponseData" );

  RSP[0] = tc6807af_ReadReg( RSPG_0 );
  RSP[1] = tc6807af_ReadReg( RSPG_1 );
  RSP[2] = tc6807af_ReadReg( RSPG_2 );
  RSP[3] = tc6807af_ReadReg( RSPG_3 );
  RSP[4] = tc6807af_ReadReg( RSPG_4 );

  MonoOutStr( "] " );
  return TRUE;
 }

//
//  tc6807af_SendResponseData
//
/////////////////////////////////////////////////////////////////////
BOOL tc6807af_SendResponseData( BYTE * RSP )
 {
  MonoOutStr( " [DRV_AUTH:" );

  tc6807af_WriteReg( RSPG_0, RSP[0] );
  tc6807af_WriteReg( RSPG_1, RSP[1] );
  tc6807af_WriteReg( RSPG_2, RSP[2] );
  tc6807af_WriteReg( RSPG_3, RSP[3] );
  tc6807af_WriteReg( RSPG_4, RSP[4] );

  if ( !tc6807af_NewCommand( DRV_AUTH ) )
    return FALSE;

  return TRUE;
 }

//
//  tc6807af_SendDiskKeyData
//
/////////////////////////////////////////////////////////////////////
BOOL tc6807af_SendDiskKeyData( BYTE * pBuffer )
 {
  DWORD physAddress;
  DWORD dwTimeout = 10000;
  BYTE  byValue;
  int i;

  MonoOutStr( " [DEC_DKY:" );
  //tc6807af_WriteReg( CNT_1, ENBERR | ENBEND | RQ1 );
  tc6807af_WriteReg( CNT_1, RQ1 );
  tc6807af_WriteReg( CNT_2, SCR1 | EB2 );
  tc6807af_WriteReg( COM, DEC_DKY );
  tc6807af_WriteReg( CNT_1, RQ2|RQ1 );
  tc6807af_WriteReg( CNT_2, SCR1 | EB2|EB1 );

  MonoOutStr( "DiskKey:" );
  MonoOutULongHex( *((DWORD *)pBuffer) );
  MonoOutStr( " pBuffer:" );
  MonoOutULongHex( (DWORD)pBuffer );

  // Send one sector
#ifdef VTOOLSD
  CopyPageTable( (DWORD)pBuffer >> 12, 1, (PVOID*)&physAddress, 0 );
  physAddress = (physAddress & 0xfffff000) + (((DWORD)pBuffer) & 0xfff);
#else
  physAddress = (DWORD)pBuffer;
#endif

  FPGA_Set( FPGA_SECTOR_START );

  for ( i=0; i<32; i++ )
  {
    if ( !BMA_Send( (DWORD *) (physAddress+i*64), 64 ) )
      return FALSE;

    dwTimeout = 10000;
    while ( !BMA_Complete() )
    {
      //dvd_SetRequestEnable();

      if ( !(--dwTimeout) )
      {
        MonoOutStr( " BMA did not complete " );
        return FALSE;
      }
    }

    dvd_SetRequestEnable();
  }


  FPGA_Clear( FPGA_SECTOR_START );
  //tc6807af_WriteReg( CNT_1, CLINT );

  dwTimeout = 400000;
  while ( --dwTimeout )
  {
    byValue = tc6807af_ReadReg( COM );
    if ( byValue & END )
    {
      //tc6807af_WriteReg( CNT_1, CLINT | RQ1 );
      if ( byValue & ERR )
      {
        //tc6807af_WriteReg( CNT_1, CLINT | RQ1 );
        MonoOutStr( "ERR] " );
        return FALSE;
      }
      MonoOutStr( "End] " );
      return TRUE;
    }

  }

  //tc6807af_WriteReg( CNT_1, CLINT | RQ1 );
  MonoOutStr( "Timeout] " );
  return FALSE;
 }

//
//  tc6807af_SendTilteKeyData
//
/////////////////////////////////////////////////////////////////////
BOOL tc6807af_SendTitleKeyData( BYTE * ETK )
 {
  DWORD dwTimeout = 100000;
  BYTE  byValue;

  MonoOutStr( " [DEC_DTK:" );

  tc6807af_WriteReg( ETKG_0, ETK[0] );
  tc6807af_WriteReg( ETKG_1, ETK[1] );
  tc6807af_WriteReg( ETKG_2, ETK[2] );
  tc6807af_WriteReg( ETKG_3, ETK[3] );
  tc6807af_WriteReg( ETKG_4, ETK[4] );
  tc6807af_WriteReg( ETKG_5, ETK[5] );

  tc6807af_WriteReg( COM, NOP );
  tc6807af_WriteReg( COM, DEC_DTK );

  while ( --dwTimeout )
  {
    byValue = tc6807af_ReadReg( COM );
    if ( byValue & END )
    {
      if ( byValue & ERR )
      {
        MonoOutStr( "ERR] " );
        return FALSE;
      }
      MonoOutStr( "End] " );
      return TRUE;
    }

  }

  MonoOutStr( "Timeout] " );
  return FALSE;
 }

//
//  tc6807af_SetDecryptionMode
//
/////////////////////////////////////////////////////////////////////
BOOL tc6807af_SetDecryptionMode( BYTE * SR_FLAG )
 {
  DWORD dwTimeout = 100000;
  BYTE  byValue;

  MonoOutStr( " [DEC_DT:" );

  if ( *SR_FLAG )
  {
    //tc6807af_WriteReg( CNT_2, EB2 );
    tc6807af_WriteReg( COM, NOP );
    tc6807af_WriteReg( COM, DEC_DT );

    MonoOutStr( "] " );
    return TRUE;

    while ( --dwTimeout )
    {
      byValue = tc6807af_ReadReg( COM );
      if ( byValue & END )
      {
        if ( byValue & ERR )
        {
          MonoOutStr( "ERR] " );
          return FALSE;
        }
        MonoOutStr( "End] " );
        return TRUE;
      }

    }

    MonoOutStr( "Timeout] " );
    return FALSE;
  }
  else
  {
    tc6807af_WriteReg( CNT_2, SCR1 | EB2 | EB1 | THR );
    MonoOutStr( "Pass Through] " );
    return TRUE;
  }

 }


/******************************************************************************/
/******************* LOW LEVEL FUNCTIONS IMPLEMENTATION ***********************/
/******************************************************************************/

//
//  tc6807af_NewCommand
//
/////////////////////////////////////////////////////////////////////
BOOL tc6807af_NewCommand( BYTE Command )
 {
  DWORD dwTimeout = 10000;
  BYTE  byValue;

  tc6807af_WriteReg( COM, Command );

  if ( (Command == NOP) || (Command == DEC_RAND) )
    return TRUE;

  while ( --dwTimeout )
  {
    byValue = tc6807af_ReadReg( COM );
    if ( byValue & END )
    {
      if ( byValue & ERR )
      {
        MonoOutStr( "ERR] " );
        return FALSE;
      }
      MonoOutStr( "End] " );
      return TRUE;
    }
  }

  MonoOutStr( "Timeout] " );
  return FALSE;
 }


//
//  tc6807af_WriteReg
//
/////////////////////////////////////////////////////////////////////
void  tc6807af_WriteReg( BYTE byReg, BYTE byValue )
 {
  BRD_WriteByte( gdwIndex, byReg );
  BRD_WriteByte( gdwData, byValue );
 }

//
//  tc6807af_ReadReg
//
/////////////////////////////////////////////////////////////////////
BYTE tc6807af_ReadReg( BYTE byReg )
 {
  BRD_WriteByte( gdwIndex, byReg );
  return BRD_ReadByte( gdwData );
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dxr2\sbpstrm.h ===
/******************************************************************************\
*                                                                              *
*      SBPSTRM.H  -     Subpicture stream control related code header file     *
*                                                                              *
*      Copyright (c) C-Cube Microsystems 1996                                  *
*      All Rights Reserved.                                                    *
*                                                                              *
*      Use of C-Cube Microsystems code is governed by terms and conditions     *
*      stated in the accompanying licensing statement.                         *
*                                                                              *
\******************************************************************************/
#ifndef _SBPSTRM_H_
#define _SBPSTRM_H_

VOID STREAMAPI SubpictureReceiveCtrlPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI SubpictureReceiveDataPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);

#endif  // _SBPSTRM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dxr2\services.h ===
//******************************************************************************/
//*                                                                            *
//*    services.h -                                                            *
//*                                                                            *
//*    Copyright (c) C-Cube Microsystems 1996                                  *
//*    All Rights Reserved.                                                    *
//*                                                                            *
//*    Use of C-Cube Microsystems code is governed by terms and conditions     *
//*    stated in the accompanying licensing statement.                         *
//*                                                                            *
//******************************************************************************/


//
//	VxDJmp
//
#ifdef VXD
#include <vtoolsc.h>
#endif

#ifndef _SERVICES_H_
#define _SERVICES_H_

#define LPBYTE		BYTE FAR * 


#define ZVDVXD_Major        1
#define ZVDVXD_Minor        0
#define ZVDVXD_DeviceID     0x3180
#define ZVDVXD_Init_Order   0x7f000000


#define EXCA_BASE	0x800
#define EXCA_WS_EN	0x11
#define EXCA_WS_PLUS 0x13
#define WS_ON 0x80
#define WS_OFF 0xC0
#define WS_PLUS_0 0x00
#define WS_PLUS_1 0x40
#define WS_PLUS_2 0x80
#define WS_PLUS_3 0xC0



// Return Defines

#define ZVDVXD_OK			0x00000000
#define ZVDVXD_NOTREADY                 0x00000001
#define ZVDVXD_FAIL			0x00000002


// Structures
#pragma pack( 1 )
typedef struct tagRESINFO
{
	WORD wNumMemWindows;					// Num memory windows
    DWORD dwMemBase[16];					// memory window base
    DWORD dwMemLength[16];					// memory window length

    WORD wNumIOPorts;						// num IO ports
    WORD wIOPortBase[16];					// IO port base
    WORD wIOPortLength[16];					// IO port length

    WORD wNumIRQChannels;					// num IRQ info
    BYTE bIRQChannel[16];					// IRQ list

    WORD wNumDMAChannels;					// num DMA channels
    BYTE bDMAChannel[16];					// DMA list

	WORD wSocket;							// Socket
}
RESINFO, *PRESINFO, FAR *LPRESINFO;
#pragma

typedef struct _tagPCICINFO
{
	CHAR lpzRoot[64];						// Device root location
	CHAR lpzVendorID[256];					// Vendor ID string
}
PCICINFO, *PPCICINFO, FAR *LPPCICINFO;



// Prototypes

DWORD _cdecl ZVDVXD_GetResInfo( DWORD dwDevice, LPRESINFO lpResInfo );
DWORD _cdecl ZVDVXD_EnablePCIC( DWORD dwDevice );
DWORD _cdecl ZVDVXD_DisablePCIC( DWORD dwDevice );
DWORD _cdecl ZVDVXD_GetPCICInfo( DWORD dwDevice, LPPCICINFO lpPCICInfo );
DWORD _cdecl ZVDVXD_GetExCAReg( DWORD dwDevice, WORD wReg, LPBYTE lpbValue );
DWORD _cdecl ZVDVXD_SetExCAReg( DWORD dwDevice, WORD wReg, BYTE bValue );
DWORD _cdecl ZVDVXD_GetPCIReg( DWORD dwDevice, WORD wReg, LPBYTE lpbValue );
DWORD _cdecl ZVDVXD_SetPCIReg( DWORD dwDevice, WORD wReg, BYTE bValue );


// Service Table
#ifdef VXD
Begin_VxD_Service_Table(ZVDVXD)
	VxD_Service(ZVDVXD_GetResInfo)
	VxD_Service(ZVDVXD_EnablePCIC)
	VxD_Service(ZVDVXD_DisablePCIC)
	VxD_Service(ZVDVXD_GetPCICInfo)
	VxD_Service(ZVDVXD_GetExCAReg)
	VxD_Service(ZVDVXD_SetExCAReg)
	VxD_Service(ZVDVXD_GetPCIReg)
	VxD_Service(ZVDVXD_SetPCIReg)
End_VxD_Service_Table
#endif

#endif  _SERVICES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dxr2\sbpstrm.c ===
/******************************************************************************\
*                                                                              *
*      SBPSTRM.C  -     Subpicture stream control related code.                *
*                                                                              *
*      Copyright (c) C-Cube Microsystems 1996                                  *
*      All Rights Reserved.                                                    *
*                                                                              *
*      Use of C-Cube Microsystems code is governed by terms and conditions     *
*      stated in the accompanying licensing statement.                         *
*                                                                              *
\******************************************************************************/

#include "Headers.h"
#pragma hdrstop
#include "hli.h"
#include "copyprot.h"
#include "sbpstrm.h"
#include "bmaster.h"
#include "cl6100.h"

//*****************************************************************************
//  STATIC FUNCTIONS DECLARATION
//*****************************************************************************
static VOID SubpictureSendPacket(PHW_STREAM_REQUEST_BLOCK pSrb);
static void SubpictureQueryAccept(PHW_STREAM_REQUEST_BLOCK pSrb);
static void SetSubpictureProperty( PHW_STREAM_REQUEST_BLOCK pSrb );
static void GetSubpictureProperty( PHW_STREAM_REQUEST_BLOCK pSrb );
static void SetSubPictureRateChange( PHW_STREAM_REQUEST_BLOCK pSrb );
static void GetSubPictureRateChange( PHW_STREAM_REQUEST_BLOCK pSrb );

extern BOOL bJustHighLight;


/*
** SubpictureReceiveCtrlPacket()
**
**   Receives packet commands that control the Subpicture stream
**
** Arguments:
**
**   pSrb - The stream request block for the Subpicture stream
**
** Returns:
**
** Side Effects:  none
*/
VOID STREAMAPI SubpictureReceiveCtrlPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pdevext = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;

	DebugPrint(( DebugLevelVerbose, "ZiVA: Begin SubpictureReceiveCtrlPacket->" ));
	switch( pSrb->Command )
	{
	case SRB_SET_STREAM_STATE:
		DebugPrint(( DebugLevelVerbose, "SRB_SET_STREAM_STATE\n" ));
		AdapterSetState( pSrb );
		break;

	case SRB_GET_STREAM_PROPERTY:
		DebugPrint(( DebugLevelVerbose, "SRB_GET_STREAM_PROPERTY\n" ));
		GetSubpictureProperty( pSrb );
		break;

	case SRB_SET_STREAM_PROPERTY:
		DebugPrint(( DebugLevelVerbose, "SRB_SET_STREAM_PROPERTY\n" ));
		SetSubpictureProperty( pSrb );
		break;

	case SRB_PROPOSE_DATA_FORMAT:
		DebugPrint(( DebugLevelVerbose, "SRB_PROPOSE_DATA_FORMAT\n" ));
		SubpictureQueryAccept( pSrb );
		break;

	case SRB_OPEN_MASTER_CLOCK:
	case SRB_CLOSE_MASTER_CLOCK:
	case SRB_INDICATE_MASTER_CLOCK:
		//hMaster = pSrb->CommandData.MasterClockHandle;
		pSrb->Status = STATUS_SUCCESS;
		break;

	case SRB_BEGIN_FLUSH :            // beginning flush state
		MonoOutStr(" Sbp : SRB_BEGIN_FLUSH ");
#ifndef DECODER_DVDPC		
		pdevext->bInterruptPending = FALSE;
#endif
		
		if (pdevext->pCurrentSubPictureSrb)
		{
			ZivaHw_Abort();		
//			adapterUpdateNextSrbOrderNumberOnDiscardSrb(pdevext->pCurrentSubPictureSrb);
			pdevext->pCurrentSubPictureSrb->Status =  STATUS_SUCCESS;
			
			AdapterReleaseRequest( pdevext->pCurrentSubPictureSrb );
			pdevext->pCurrentSubPictureSrb = NULL;
			pdevext->dwCurrentSubPictureSample = 0;
			pdevext->dwCurrentSubPicturePage = 0;
		}

		pSrb->Status = STATUS_SUCCESS;
		break;
	case SRB_END_FLUSH:              // ending flush state
		MonoOutStr(" Sbp : SRB_END_FLUSH ");
//		ZivaHw_Play();
		pdevext->bPlayCommandPending = TRUE;
		pSrb->Status = STATUS_SUCCESS;
		
		if (pdevext->pCurrentSubPictureSrb)
		{
			pdevext->pCurrentSubPictureSrb->Status =  STATUS_SUCCESS;
			
			AdapterReleaseRequest( pdevext->pCurrentSubPictureSrb );
			pdevext->pCurrentSubPictureSrb = NULL;
			pdevext->dwCurrentSubPictureSample = 0;
			pdevext->dwCurrentSubPicturePage = 0;
		}


		pdevext->bEndFlush = TRUE;
//		FinishCurrentPacketAndSendNextOne( pdevext );
		break;


	default:
		DebugPrint(( DebugLevelInfo, "!!!! UNKNOWN COMMAND !!!! :::> %X\n", pSrb->Command ));
		pSrb->Status = STATUS_NOT_IMPLEMENTED;
	}

	AdapterReleaseRequest( pSrb );
	DebugPrint(( DebugLevelVerbose, "ZiVA: End SubpictureReceiveCtrlPacket\n" ));
}


/*
** SubpictureReceiveDataPacket()
**
**   Receives Subpicture data packets
**
** Arguments:
**
**   pSrb - Stream request block for the Subpicture device
**
** Returns:
**
** Side Effects:  none
*/
VOID STREAMAPI SubpictureReceiveDataPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pdevext = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;

	switch( pSrb->Command )
	{
	case SRB_WRITE_DATA:
		if(bJustHighLight)
		{
			pSrb->TimeoutCounter = pSrb->TimeoutOriginal = pSrb->TimeoutCounter / 5;
			bJustHighLight = FALSE;
			MonoOutStr("SP TimeOut Counter Reduced");
		}

		SubpictureSendPacket( pSrb );
		break;

	default:
		DebugPrint(( DebugLevelWarning, "!!!! UNKNOWN COMMAND !!!! :::> %X\n", pSrb->Command ));
		pSrb->Status = STATUS_NOT_IMPLEMENTED;
		AdapterReleaseRequest( pSrb );
	}

}


DWORD PTStoSTC( BYTE *pPts )
{
	return (((DWORD)*(pPts+1)) << 22) +
			(((DWORD)*(pPts+2)) << 14) +
			(((DWORD)*(pPts+3)) << 7) +
			(((DWORD)*(pPts+4)) >> 1);
}


#if 0
static BOOLEAN PreparePageTable(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	DWORD i = 0;
	DWORD k = 0;
	DWORD j = 0;
	PKSSCATTER_GATHER	pSGList;
	DWORD dwSum = 0;
	PHW_DEVICE_EXTENSION	pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;

	if(pSrb == NULL)
	{
#ifdef DEBUG
		MonoOutStr("PreparePageTable::pSrb is NULL");
#endif
		return FALSE;
	}
	
	pSGList = pSrb->ScatterGatherBuffer;

	if(pSGList == NULL)
	{
#ifdef DEBUG
		MonoOutStr("PreparePageTable::pSGList is NULL");
#endif
		return FALSE;
	}
	
	while( j < pSrb->NumberOfBuffers)
	{
		dwSum = 0;
		k = 0;
		do
		{
			dwSum += pSGList[i].Length;
			i++;
			k++;

		}while(dwSum < pHwDevExt->SubPictureBufferSize[j]);

		pHwDevExt->SubPicturePageTable[j] = k;
		j++;
		if(j > 50)
		{
#ifdef DEBUG
			MonoOutStr("PreparePageTable::ArrayCrossingLimit");
#endif
			return FALSE;
		}
		

	}
	return TRUE;
}
#endif


/*
** SubpictureSendPacket()
**
**   Routine to initialise the stream data packet handling
**
** Arguments:
**
**   pSrb - Pointer to the stream request block
**
** Returns:
**
** Side Effects:  none
*/
static VOID SubpictureSendPacket( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION	pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
	KSSTREAM_HEADER*		pHeader;
	BYTE*					pData;
	ULONG					ulSample;
	static BOOL				bStreamNumberCouldBeChanged = FALSE;
	static WORD				wCurrentStreamNumber = 0;


	if (CheckAndReleaseIfCtrlPkt(pSrb))
		return;

	pHeader = (PKSSTREAM_HEADER)pSrb->CommandData.DataBufferArray;
	// Lets check what we've got in this Srb
	for( ulSample = 0; ulSample < pSrb->NumberOfBuffers; ulSample++, pHeader++ )
	{
		pData = pHeader->Data;

#ifdef DEBUG
		if( pHeader->OptionsFlags & ~(KSSTREAM_HEADER_OPTIONSF_SPLICEPOINT			|
										KSSTREAM_HEADER_OPTIONSF_PREROLL			|
										KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY	|
										KSSTREAM_HEADER_OPTIONSF_TYPECHANGED		|
										KSSTREAM_HEADER_OPTIONSF_TIMEVALID			|
										KSSTREAM_HEADER_OPTIONSF_TIMEDISCONTINUITY	|
										KSSTREAM_HEADER_OPTIONSF_FLUSHONPAUSE		|
										KSSTREAM_HEADER_OPTIONSF_DURATIONVALID		|
										KSSTREAM_HEADER_OPTIONSF_LOOPEDDATA) )
			DebugPrint(( DebugLevelWarning, "ZiVA: !!!!!!!!! NEW KSSTREAM_HEADER_OPTIONSF_ ADDED !!!!!!!!!\n" ));

		MonoOutChar('S');
		MonoOutULong(( pHeader->TypeSpecificFlags) >> 16 );
		MonoOutChar( '.' );
#endif		// DEBUG


		if(pHwDevExt->dwFirstSbpOrdNum == -1)
		{
			pHwDevExt->dwFirstSbpOrdNum = (pHeader->TypeSpecificFlags) >> 16;
			MonoOutStr("FirstSbpBuffer");
			MonoOutULong( (pHeader->TypeSpecificFlags) >> 16 );
			
		}

		//		pHwDevExt->SubPictureBufferSize[ulSample] = pHeader->DataUsed;

		if( pHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY )
		{
			MonoOutStr( " S->DISCONT " );
			bStreamNumberCouldBeChanged = TRUE;
		}
		if( pHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TYPECHANGED )
		{
			DebugPrint(( DebugLevelVerbose, "ZiVA: Processing Subpicture stream format.\n" ));
			MonoOutStr( " S->TYPECHANGED " );
			bStreamNumberCouldBeChanged = TRUE;
		}

		// Check for the stream number
#ifndef ZERO_STREAM_NUMBER
		if( bStreamNumberCouldBeChanged )
#endif
		{
			if( pData && pHeader->DataUsed )
			{
				WORD wStuffingLength;
				WORD wPesHeaderLength;
				WORD wOffset;
				WORD wNewStream;

				if(pHeader->DataUsed < 23)
				{
					pHwDevExt->bStreamNumberCouldBeChanged = FALSE;
					continue;
				}

				// Find the location of the stream ID and number
				wStuffingLength = *(pData+13) & 0x03;
				wPesHeaderLength = *(pData+22);
				wOffset = 22;

				if ( wPesHeaderLength >= 5 )
				{
					// PTS is present here
					DWORD dwPTS = PTStoSTC( pData+23 );
					MonoOutChar('=');
					MonoOutULong( dwPTS );
					MonoOutChar('=');
					DVD_GetSTC();
				}

				wOffset = wOffset + wPesHeaderLength;
				wOffset = wOffset + wStuffingLength + 1;

				if(pHeader->DataUsed < wOffset)
				{
					pHwDevExt->bStreamNumberCouldBeChanged = FALSE;
					continue;
				}


				// Get Stream Number
				//WORD wNewStream = *(pData+31);
				wNewStream = *(pData+wOffset);

				if( (wNewStream & 0xE0) == 0x20 )
				{
#ifndef ZERO_STREAM_NUMBER
					*(pData+wOffset) = wNewStream & 0xE0;
#else
					if( (wNewStream & 0x1F) != wCurrentStreamNumber )
					{
						wCurrentStreamNumber = wNewStream & 0x1F;
#ifndef MICROCODE_ACCEPTS_ANY_STREAM
						DVD_SetStreams( 1, wCurrentStreamNumber );   // Select the current stream number
#endif
					}
					bStreamNumberCouldBeChanged = FALSE;
#endif  // ZERO_STREAM_NUMBER
				}
				else
					MonoOutStr( " !!! SubPicture Pack with wrong ID !!! " );

				// Also note that valid SPU most likely was received here
				pHwDevExt->bValidSPU = TRUE;
			}
		}
	}

	//  Register this Srb
    if( pHwDevExt->pCurrentSubPictureSrb )
	{
		DebugPrint(( DebugLevelVerbose, "ZiVA: !!!!!!!!!!! ERROR: Subpicture slot is not empty !!!!!!!!!!\n" ));
		MonoOutStr("!!!!!!!SPSlotIsNotEmpty!!!!!!!!");
	}
//	if(!PreparePageTable(pSrb))
//		MonoOutStr("!!!Sp PageTable prepfailed");
	pHwDevExt->pCurrentSubPictureSrb = pSrb;
	AdapterSendData( pHwDevExt );
}

/*
** SetSubpictureProperty()
**
**
**
** Arguments:
**
**   pSrb - Pointer to the stream request block
**
** Returns:
**
** Side Effects:  none
*/
static void SetSubpictureProperty( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
	PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

	pSrb->Status = STATUS_SUCCESS;
	if( IsEqualGUID( &KSPROPSETID_DvdSubPic, &pSPD->Property->Set ) )
	{	// KSPROPSETID_DvdSubPic
		switch ( pSrb->CommandData.PropertyInfo->Property->Id )
		{
		// look for the palette property
		case KSPROPERTY_DVDSUBPIC_PALETTE:
			{
				PKSPROPERTY_SPPAL pSpPal = (PKSPROPERTY_SPPAL)pSrb->CommandData.PropertyInfo->PropertyInfo;
				DWORD dwPalettes[16];
				int i;

				for ( i=0; i<16; i++ )
					dwPalettes[i] = ((DWORD)(pSpPal->sppal[i].Y) << 16) +
									((DWORD)(pSpPal->sppal[i].U)) +
									((DWORD)(pSpPal->sppal[i].V) << 8);
				if ( !DVD_SetPalette( dwPalettes ) )
					pSrb->Status = STATUS_IO_DEVICE_ERROR;
			}
			break;

		// look for HLI property
		case KSPROPERTY_DVDSUBPIC_HLI:
//			if(!pHwDevExt->bHliPending)
			{	// Copy HLI to the Device Extensions
				MonoOutStr("HC");
				pHwDevExt->bHliPending = TRUE;
				pHwDevExt->hli = *(PKSPROPERTY_SPHLI)pSrb->CommandData.PropertyInfo->PropertyInfo;
				HighlightSetPropIfAdapterReady( pHwDevExt );
			}
			break;

		case KSPROPERTY_DVDSUBPIC_COMPOSIT_ON:
			if (*((PKSPROPERTY_COMPOSIT_ON)pSrb->CommandData.PropertyInfo->PropertyInfo))
			{
				if ( !DVD_SetSubPictureMute( FALSE ) )
					pSrb->Status = STATUS_IO_DEVICE_ERROR;
			}
			else
			{
				if ( !DVD_SetSubPictureMute( TRUE ) )
					pSrb->Status = STATUS_IO_DEVICE_ERROR;
			}
			break;

		default:
			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;
		}
	}
	else if( IsEqualGUID( &KSPROPSETID_CopyProt, &pSPD->Property->Set ) )
	{	// KSPROPSETID_CopyProt
		CopyProtSetPropIfAdapterReady( pSrb );
	}
	else if( IsEqualGUID( &KSPROPSETID_TSRateChange, &pSPD->Property->Set ) )
	{	// this is a transfer rate change property go handle it there
		SetSubPictureRateChange( pSrb );
	}
}

/*
** GetSubpictureProperty()
**
**
**
** Arguments:
**
**   pSrb - Pointer to the stream request block
**
** Returns:
**
** Side Effects:  none
*/
static void GetSubpictureProperty( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION phwdevext = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
	PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

	if( IsEqualGUID( &KSPROPSETID_CopyProt, &pSPD->Property->Set ) )
	{	// this is a copy protection property go handle it there
		CopyProtGetProp( pSrb );
	}
	else if( IsEqualGUID( &KSPROPSETID_TSRateChange, &pSPD->Property->Set ) )
	{	// this is a transfer rate change property go handle it there
		GetSubPictureRateChange( pSrb );
	}
	else
		pSrb->Status = STATUS_NOT_IMPLEMENTED;
}


static void GetSubPictureRateChange( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;

	DebugPrint(( DebugLevelVerbose, "ZiVA:  GetSubPictureRateChange()->" ));
	switch( pSrb->CommandData.PropertyInfo->Property->Id )
	{
	case KS_AM_RATE_SimpleRateChange:
		{
			KS_AM_SimpleRateChange* pRateChange;

			DebugPrint(( DebugLevelVerbose, "KS_AM_RATE_SimpleRateChange\n" ));
			pSrb->ActualBytesTransferred = sizeof( KS_AM_RATE_SimpleRateChange );
			pRateChange = (KS_AM_SimpleRateChange*)pSrb->CommandData.PropertyInfo->PropertyInfo;
			pRateChange->StartTime = 0/*pHwDevExt->SubPictureStartTime*/;
			pRateChange->Rate = 10000 /*pHwDevExt->SubPictureRate*/;
		}
		pSrb->Status = STATUS_SUCCESS;
		break;

	case KS_AM_RATE_ExactRateChange:
		DebugPrint(( DebugLevelVerbose, "KS_AM_RATE_ExactRateChange (NOT IMPLEMENTED)\n" ));
		pSrb->Status = STATUS_NOT_IMPLEMENTED;
		break;

	case KS_AM_RATE_MaxFullDataRate:
		{
			KS_AM_MaxFullDataRate* pMaxRate;

			DebugPrint(( DebugLevelVerbose, "KS_AM_RATE_MaxFullDataRate\n" ));
			pSrb->ActualBytesTransferred = sizeof (KS_AM_RATE_MaxFullDataRate);
			pMaxRate = (KS_AM_MaxFullDataRate*)pSrb->CommandData.PropertyInfo->PropertyInfo;
			*pMaxRate = 10000 /*pHwDevExt->SubPictureMaxFullRate*/;
		}
		pSrb->Status = STATUS_SUCCESS;
		break;

	case KS_AM_RATE_Step:
		DebugPrint(( DebugLevelVerbose, "KS_AM_RATE_Step (NOT IMPLEMENTED)\n" ));
		pSrb->Status = STATUS_NOT_IMPLEMENTED;
	}
}

static void SetSubPictureRateChange( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;

	DebugPrint(( DebugLevelVerbose, "ZiVA:  SetSubPictureRateChange()->" ));
	switch( pSrb->CommandData.PropertyInfo->Property->Id )
	{
	case KS_AM_RATE_SimpleRateChange:
		{
			KS_AM_SimpleRateChange* pRateChange;
			REFERENCE_TIME NewStartTime;
			LONG NewRate;

			DebugPrint(( DebugLevelVerbose, "KS_AM_RATE_SimpleRateChange\n" ));
			pRateChange = (KS_AM_SimpleRateChange*)pSrb->CommandData.PropertyInfo->PropertyInfo;
			NewStartTime = pRateChange->StartTime;
			NewRate = ( pRateChange->Rate < 0 ) ? -pRateChange->Rate : pRateChange->Rate;

			DebugPrint(( DebugLevelVerbose, "ZiVA: Received Data\r\n" ));
			DebugPrint(( DebugLevelVerbose, "ZiVA:   StartTime     = 0x%08x\r\n", NewStartTime ));
			DebugPrint(( DebugLevelVerbose, "ZiVA:   Rate          = 0x%08x\r\n", NewRate ));
			//pHwDevExt->SubPictureInterceptTime =
			//	(pHwDevExt->SubPictureInterceptTime-NewStartTime)*
			//	pHwDevExt->SubPictureRate/NewRate + NewStartTime;

			/* We will rely on the video stream
			if( NewRate == 10000 )
				ZivaHw_Play();
			else
				ZivaHw_Scan();
			pHwDevExt->SubPictureRate = NewRate;
			if( NewRate == 10000 )
			{
				pHwDevExt->SubPictureInterceptTime = 0;
				pHwDevExt->SubPictureStartTime = 0;
			}
			else
			{
				pHwDevExt->SubPictureInterceptTime = (-NewStartTime) * 10000 / NewRate + NewStartTime;
				pHwDevExt->SubPictureStartTime = NewStartTime;
			}
			SetRateChange( pHwDevExt, 0x01 );*/
		}
		pSrb->Status = STATUS_SUCCESS;
		break;

	case KS_AM_RATE_ExactRateChange :
		pSrb->Status = STATUS_NOT_IMPLEMENTED;
		break;

	case KS_AM_RATE_MaxFullDataRate :
		pSrb->Status = STATUS_NOT_IMPLEMENTED;
		break;

	case KS_AM_RATE_Step :
		pSrb->Status = STATUS_NOT_IMPLEMENTED;
		break;
	}
}


/*
** SubpictureQueryAccept()
**
**
**
** Arguments:
**
**   pSrb - Pointer to the stream request block
**
** Returns:
**
** Side Effects:  none
*/
static void SubpictureQueryAccept( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PKSDATAFORMAT pfmt = pSrb->CommandData.OpenFormat;
	KS_MPEGVIDEOINFO2* pblock = (KS_MPEGVIDEOINFO2*)((PBYTE)pfmt + sizeof( KSDATAFORMAT ));

	DebugPrint(( DebugLevelVerbose, "ZiVA: Begin SubpictureQueryAccept()\n" ));
	// pick up the format block and examine it. Default to not implemented
	pSrb->Status = STATUS_SUCCESS;

	if( pfmt->FormatSize != sizeof( KSDATAFORMAT ) + sizeof( KS_MPEGVIDEOINFO2 ) )
		return;

/*	switch( pblock->hdr.dwPixAspectRatio )
	{
	case PixAspectRatio_NTSC4x3:
	case PixAspectRatio_NTSC16x9:
		pSrb->Status = STATUS_SUCCESS;
		return;

	default:
		return;
	}*/
	DebugPrint(( DebugLevelVerbose, "ZiVA: End SubpictureQueryAccept()\n" ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dxr2\strminfo.h ===
/******************************************************************************\
*                                                                              *
*      STRMINFO.H - All streams deskription for the device.                    *
*                                                                              *
*      Copyright (c) C-Cube Microsystems 1996                                  *
*      All Rights Reserved.                                                    *
*                                                                              *
*      Use of C-Cube Microsystems code is governed by terms and conditions     *
*      stated in the accompanying licensing statement.                         *
*                                                                              *
\******************************************************************************/

#ifndef _STRMINFO_H_
#define _STRMINFO_H_

#include <strmini.h>

//---------------------------------------------------------------------------
// Create an array that holds the list of all of the streams supported
//---------------------------------------------------------------------------

typedef struct _ALL_STREAM_INFO {
    HW_STREAM_INFORMATION   hwStreamInfo;
    HW_STREAM_OBJECT        hwStreamObject;
} ALL_STREAM_INFO, *PALL_STREAM_INFO;

static ALL_STREAM_INFO Streams [] =
{
    // -----------------------------------------------------------------
    // The MPEG Video input stream
    // -----------------------------------------------------------------
    {
        // HW_STREAM_INFORMATION -------------------------------------------
        {
            1,                                      // NumberOfPossibleInstances
            KSPIN_DATAFLOW_IN,                      // DataFlow
            TRUE,                                   // DataAccessible
            NUM_VIDEO_IN_FORMATS,                   // NumberOfFormatArrayEntries
            ZivaVideoInFormatArray,                 // StreamFormatsArray
            0,                                      // ClassReserved[0]
            0,                                      // ClassReserved[1]
            0,                                      // ClassReserved[2]
            0,                                      // ClassReserved[3]
            2,         // NumStreamPropArrayEntries
            (PKSPROPERTY_SET)mpegVidPropSet,        // StreamPropertiesArray
            0,                                      // NumStreamEventArrayEntries;
            0,                                      // StreamEventsArray;
            NULL,                  // Category
            NULL,                  // Name
            0,                                      // MediumsCount
            NULL,                                   // Mediums
        },

        // HW_STREAM_OBJECT ------------------------------------------------
        {
            sizeof (HW_STREAM_OBJECT),              // SizeOfThisPacket
            0,                                      // StreamNumber
            0,                                      // HwStreamExtension
            VideoReceiveDataPacket,                 // HwReceiveDataPacket
            VideoReceiveCtrlPacket,                 // HwReceiveControlPacket
            { NULL, 0 },                            // HW_CLOCK_OBJECT
            TRUE,                                   // Dma
            TRUE,                                   // Pio
            0,                                      // HwDeviceExtension
            0,                                      // StreamHeaderMediaSpecific
            0,                                      // StreamHeaderWorkspace
            FALSE,                                  // Allocator
            NULL,                                   // HwEventRoutine
            { 0, 0 },                               // Reserved[2]
        }
    },

    // -----------------------------------------------------------------
    // The compressed Audio input stream
    // -----------------------------------------------------------------
    {
        // HW_STREAM_INFORMATION -------------------------------------------
        {
            1,                                      // NumberOfPossibleInstances
            KSPIN_DATAFLOW_IN,                      // DataFlow
            TRUE,                                   // DataAccessible.
            NUM_AUDIO_IN_FORMATS,                   // NumberOfFormatArrayEntries
            ZivaAudioInFormatArray,                 // StreamFormatsArray
            0,                                      // ClassReserved[0]
            0,                                      // ClassReserved[1]
            0,                                      // ClassReserved[2]
            0,                                      // ClassReserved[3]
            2, // cool. Fix hardcoded value         // NumStreamPropArrayEntries
            (PKSPROPERTY_SET)audPropSet,            // StreamPropertiesArray
            0,                                      // NumStreamEventArrayEntries
            0,                                      // StreamEventsArray
            NULL,                                   // Category
            NULL,                                   // Name
            0,                                      // MediumsCount
            NULL,                                   // Mediums
        },

        // HW_STREAM_OBJECT ------------------------------------------------
        {
            sizeof (HW_STREAM_OBJECT),              // SizeOfThisPacket
            0,                                      // StreamNumber
            0,                                      // HwStreamExtension
            AudioReceiveDataPacket,                 // HwReceiveDataPacket
            AudioReceiveCtrlPacket,                 // HwReceiveControlPacket
            { AudioClockFunction,                   // HW_CLOCK_OBJECT
              CLOCK_SUPPORT_CAN_SET_ONBOARD_CLOCK |
              CLOCK_SUPPORT_CAN_READ_ONBOARD_CLOCK |
              CLOCK_SUPPORT_CAN_RETURN_STREAM_TIME,
              {0,0} },
            TRUE,                                   // Dma
            TRUE,                                   // Pio
            0,                                      // HwDeviceExtension
            0,                                      // StreamHeaderMediaSpecific
            0,                                      // StreamHeaderWorkspace
            FALSE,                                  // Allocator
            (PHW_EVENT_ROUTINE) AudioEventFunction, // HwEventRoutine
            { 0, 0 },                               // Reserved[2]
        }
    },

    // -----------------------------------------------------------------
    // The Subpicture input stream
    // -----------------------------------------------------------------
    {
        // HW_STREAM_INFORMATION -------------------------------------------
        {
            1,                                      // NumberOfPossibleInstances
            KSPIN_DATAFLOW_IN,                      // DataFlow
            TRUE,                                   // DataAccessible
            NUM_SUBPICTURE_IN_FORMATS,              // NumberOfFormatArrayEntries
            ZivaSubPictureInFormatArray,            // StreamFormatsArray
            0,                                      // ClassReserved[0]
            0,                                      // ClassReserved[1]
            0,                                      // ClassReserved[2]
            0,                                      // ClassReserved[3]
            2,         // NumStreamPropArrayEntries
            (PKSPROPERTY_SET)SPPropSet,             // StreamPropertiesArray
            0,                                      // NumStreamEventArrayEntries;
            0,                                      // StreamEventsArray;
            NULL,                                   // Category
            NULL,                                   // Name
            0,                                      // MediumsCount
            NULL,                                   // Mediums
        },

        // HW_STREAM_OBJECT ------------------------------------------------
        {
            sizeof (HW_STREAM_OBJECT),              // SizeOfThisPacket
            0,                                      // StreamNumber
            0,                                      // HwStreamExtension
            SubpictureReceiveDataPacket,            // HwReceiveDataPacket
            SubpictureReceiveCtrlPacket,            // HwReceiveControlPacket
            { NULL, 0 },                            // HW_CLOCK_OBJECT
            TRUE,                                   // Dma
            TRUE,                                   // Pio
            0,                                      // HwDeviceExtension
            0,                                      // StreamHeaderMediaSpecific
            0,                                      // StreamHeaderWorkspace
            FALSE,                                  // Allocator
            NULL,                                   // HwEventRoutine
            { 0, 0 },                               // Reserved[2]
        }
    },

    // -----------------------------------------------------------------
    // The TV Video Output Stream
    // -----------------------------------------------------------------
    {
        // HW_STREAM_INFORMATION -------------------------------------------
        {
            1,                                      // NumberOfPossibleInstances
            KSPIN_DATAFLOW_OUT,                     // DataFlow
            FALSE,                                  // DataAccessible
            NUM_ANALOG_VIDEO_FORMATS,               // NumberOfFormatArrayEntries
            AnalogVideoFormats,                     // StreamFormatsArray
            0,                                      // ClassReserved[0]
            0,                                      // ClassReserved[1]
            0,                                      // ClassReserved[2]
            0,                                      // ClassReserved[3]
            0,                                      // NumStreamPropArrayEntries
            0,                                      // StreamPropertiesArray
            0,                                      // NumStreamEventArrayEntries;
            0,                                      // StreamEventsArray;
            &AnalogVideoStreamPinName,              // Category
            &AnalogVideoStreamPinName,              // Name
            1,                                      // MediumsCount
            &CrossbarMediums[3],                    // Mediums
        },

        // HW_STREAM_OBJECT ------------------------------------------------
        {
            sizeof (HW_STREAM_OBJECT),              // SizeOfThisPacket
            0,                                      // StreamNumber
            0,                                      // HwStreamExtension
            VideoReceiveDataPacket,                 // HwReceiveDataPacket
            VideoReceiveCtrlPacket,                 // HwReceiveControlPacket
            NULL,                                   // HW_CLOCK_OBJECT.HWClockFunction
            0,                                      // HW_CLOCK_OBJECT.ClockSupportFlags
            FALSE,                                  // Dma
            TRUE,                                   // Pio
            0,                                      // HwDeviceExtension
            0,                                      // StreamHeaderMediaSpecific
            0,                                      // StreamHeaderWorkspace
            FALSE,                                  // Allocator
            NULL,                                   // HwEventRoutine
        },

    }
    // -----------------------------------------------------------------
    // The TV Port output stream
    // -----------------------------------------------------------------
    {
        // HW_STREAM_INFORMATION -------------------------------------------
        {
            1,                                      // NumberOfPossibleInstances
            KSPIN_DATAFLOW_OUT,                     // DataFlow
            FALSE,                                  // DataAccessible.
            NUM_NTSC_OUT_FORMATS,                   // NumberOfFormatArrayEntries
            ZivaNTSCOutFormatArray,                 // StreamFormatsArray
            0,                                      // ClassReserved[0]
            0,                                      // ClassReserved[1]
            0,                                      // ClassReserved[2]
            0,                                      // ClassReserved[3]
            0, // cool. Fix hardcoded value         // NumStreamPropArrayEntries
            NULL,                                   // StreamPropertiesArray
            SIZEOF_ARRAY(VPVBIEventSet),            // NumStreamEventArrayEntries
            VPVBIEventSet,                          // StreamEventsArray
            &VPVBIPinName,                          // Category
            &VPVBIPinName,                          // Name
            0,                                      // MediumsCount
            NULL,                                   // Mediums
        },

        // HW_STREAM_OBJECT ------------------------------------------------
        {
            sizeof (HW_STREAM_OBJECT),              // SizeOfThisPacket
            0,                                      // StreamNumber
            0,                                      // HwStreamExtension
            VideoReceiveDataPacket,                 // HwReceiveDataPacket
            VideoReceiveCtrlPacket,                 // HwReceiveControlPacket
            { NULL, 0 },                            // HW_CLOCK_OBJECT
            FALSE,                                  // Dma
            FALSE,                                   // Pio
            0,                                      // HwDeviceExtension
            0,                                      // StreamHeaderMediaSpecific
            0,                                      // StreamHeaderWorkspace
            FALSE,                                  // Allocator
            VPVBIStreamEventProc,                   // HwEventRoutine;
            { 0, 0 },                               // Reserved[2]
        }
    },

};

#define DRIVER_STREAM_COUNT (sizeof (Streams) / sizeof (ALL_STREAM_INFO))

//---------------------------------------------------------------------------
// Topology
//---------------------------------------------------------------------------

// Categories define what the device does.

static GUID Categories[] = {
    STATIC_KSCATEGORY_VIDEO,
    STATIC_KSCATEGORY_CAPTURE,
    STATIC_KSCATEGORY_CROSSBAR,
};

#define NUMBER_OF_CATEGORIES  SIZEOF_ARRAY (Categories)

static KSTOPOLOGY Topology = {
    NUMBER_OF_CATEGORIES,               // CategoriesCount
    (GUID*) &Categories,                // Categories
    0,                                  // TopologyNodesCount
    NULL,                               // TopologyNodes
    0,                                  // TopologyConnectionsCount
    NULL,                               // TopologyConnections
    NULL,                               // TopologyNodesNames
    0,                                  // Reserved
};

//---------------------------------------------------------------------------
// The Main stream header
//---------------------------------------------------------------------------

static HW_STREAM_HEADER StreamHeader =
{
    DRIVER_STREAM_COUNT,                // NumberOfStreams
    sizeof (HW_STREAM_INFORMATION),     // Future proofing
    0,                                  // NumDevPropArrayEntries set at init time
    NULL,                               // DevicePropertiesArray  set at init time
    0,                                  // NumDevEventArrayEntries;
    NULL,                               // DeviceEventsArray;
    &Topology                           // Pointer to Device Topology
};

#endif // _STRMINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dxr2\vidstrm.h ===
/******************************************************************************\
*                                                                              *
*      VIDSTRM.H  -     Video stream control related code header file          *
*                                                                              *
*      Copyright (c) C-Cube Microsystems 1996                                  *
*      All Rights Reserved.                                                    *
*                                                                              *
*      Use of C-Cube Microsystems code is governed by terms and conditions     *
*      stated in the accompanying licensing statement.                         *
*                                                                              *
\******************************************************************************/
#ifndef _VIDSTRM_H_
#define _VIDSTRM_H_

VOID STREAMAPI VideoReceiveCtrlPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI VideoReceiveDataPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);

#endif  // _VIDSTRM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dxr2\vpestrm.c ===
//******************************************************************************/
//*                                                                            *
//*    vpestrm.c -                                                             *
//*                                                                            *
//*    Copyright (c) C-Cube Microsystems 1996                                  *
//*    All Rights Reserved.                                                    *
//*                                                                            *
//*    Use of C-Cube Microsystems code is governed by terms and conditions     *
//*    stated in the accompanying licensing statement.                         *
//*                                                                            *
//******************************************************************************/


#include "headers.h"
#include "adapter.h"

#include <vidstrm.h>

#include <vpestrm.h>


HANDLE	hMaster;
HANDLE	hClk;

#define DDVPTYPE_E_HREFH_VREFL \
	0x92783220L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8

#define DDVPTYPE_E_HREFL_VREFH \
	0xA07A02E0L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8

#define DDVPTYPE_BROOKTREE \
	0x1352A560L,0xDA61,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8

#define DDVPTYPE_PHILIPS \
	0x332CF160L,0xDA61,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8

#define DDVPCONNECT_INTERLACED			0x00000020l
#define DDVPCONNECT_HALFLINE			0x00000010l

GUID g_ZvGuid = {DDVPTYPE_E_HREFL_VREFL};
//GUID g_S3Guid = {DDVPTYPE_E_HREFL_VREFL};
GUID g_ZvGuid2 = {DDVPTYPE_E_HREFH_VREFL};

GUID g_ATIGuid2 = {DDVPTYPE_E_HREFH_VREFH};

GUID g_ATIGuid3 = {DDVPTYPE_E_HREFL_VREFH};

GUID g_ATIGuid4 = {DDVPTYPE_BROOKTREE};
GUID g_ATIGuid5 = {DDVPTYPE_PHILIPS};

//GUID g_ATIGuid = {0x1352A560L,0xDA61,0x11CF,0x9B,0x06,0x00,0xA0,0xC  9,0x03,0xA3,0xB8};	// DDVPTYPE_BROOKTREE
GUID g_ATIGuid = {0xFCA326A0L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8};



// define this macro to facilitate giving the pixel format
#define MKFOURCC(ch0, ch1, ch2, ch3)    ((DWORD)(BYTE)(ch0) |           \
					((DWORD)(BYTE)(ch1) << 8) |     \
					((DWORD)(BYTE)(ch2) << 16) |    \
					((DWORD)(BYTE)(ch3) << 24 ))


#ifdef VPE_CROP
#define TOP_CROP	20
#else
#define TOP_CROP	18
#endif

/*
** VpeReceiveDataPacket()
*/
VOID STREAMAPI VpeReceiveDataPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;

	DebugPrint( (DebugLevelVerbose, "VpeReceiveDataPacket---------\r\n") );

	switch( pSrb->Command ){
		case SRB_READ_DATA:
			DebugPrint( (DebugLevelVerbose, "SRB_READ_DATA\r\n") );

			pSrb->ActualBytesTransferred = 0;
			pSrb->Status = STATUS_SUCCESS;
			break;

		case SRB_WRITE_DATA:
			DebugPrint( (DebugLevelTrace, "SRB_WRITE_DATA\r\n") );
//			TRAP;

			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;

		default:
			DebugPrint( (DebugLevelTrace, "default %d(0x%x)\r\n", pSrb->Command, pSrb->Command ) );
//			TRAP;

			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;
	}

	StreamClassStreamNotification( ReadyForNextStreamDataRequest,
									pSrb->StreamObject );

	StreamClassStreamNotification( StreamRequestComplete,
									pSrb->StreamObject,
									pSrb );
}

/*
** VpeReceiveCtrlPacket()
*/
VOID STREAMAPI VpeReceiveCtrlPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
	DebugPrint( (DebugLevelTrace, "VpeReceiveCtrlPacket---------\r\n") );

	switch( pSrb->Command ){
		case SRB_SET_STREAM_STATE:
			DebugPrint( (DebugLevelTrace, "SRB_SET_STREAM_STATE\r\n") );

			AdapterSetState( pSrb );
			break;

		case SRB_GET_STREAM_STATE:
			DebugPrint( (DebugLevelTrace, "SRB_GET_STREAM_STATE\r\n") );
			pSrb->Status = STATUS_SUCCESS;
			break;

		case SRB_GET_STREAM_PROPERTY:
			DebugPrint( (DebugLevelTrace, " SRB_GET_STREAM_PROPERTY\r\n") );

			GetVpeProperty( pSrb );

			if( pSrb->Status != STATUS_PENDING ) {
				StreamClassStreamNotification( ReadyForNextStreamControlRequest,
												pSrb->StreamObject );

				StreamClassStreamNotification( StreamRequestComplete,
												pSrb->StreamObject,
												pSrb );
			}

			return;

		case SRB_SET_STREAM_PROPERTY:
			DebugPrint( (DebugLevelTrace, " SRB_SET_STREAM_PROPERTY\r\n") );

			SetVpeProperty( pSrb );

			break;

		case SRB_OPEN_MASTER_CLOCK:
			DebugPrint( (DebugLevelTrace, " SRB_OPEN_MASTER_CLOCK\r\n") );

			hMaster = pSrb->CommandData.MasterClockHandle;

			pSrb->Status = STATUS_SUCCESS;
			break;

		case SRB_CLOSE_MASTER_CLOCK:
			DebugPrint( (DebugLevelTrace, " SRB_CLOSE_MASTER_CLOCK\r\n") );

			hMaster = pSrb->CommandData.MasterClockHandle;

			pSrb->Status = STATUS_SUCCESS;
			break;

		case SRB_INDICATE_MASTER_CLOCK:
			DebugPrint( (DebugLevelTrace, " SRB_INDICATE_MASTER_CLOCK\r\n") );

			hClk = pSrb->CommandData.MasterClockHandle;

			pSrb->Status = STATUS_SUCCESS;
			break;

		case SRB_UNKNOWN_STREAM_COMMAND:
			DebugPrint( (DebugLevelTrace, " SRB_UNKNOWN_STREAM_COMMAND\r\n") );
//			TRAP;

			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;

		case SRB_SET_STREAM_RATE:
			DebugPrint( (DebugLevelTrace, " SRB_SET_STREAM_RATE\r\n") );
//			TRAP;

			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;

		case SRB_PROPOSE_DATA_FORMAT:
			DebugPrint( (DebugLevelTrace, " SRB_PROPOSE_DATA_FORMAT\r\n") );
//			TRAP;

			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;

		default:
			DebugPrint( (DebugLevelTrace, " default %d(0x%x)\r\n", pSrb->Command, pSrb->Command ) );
//			TRAP;

			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;
	}

	StreamClassStreamNotification( ReadyForNextStreamControlRequest,
									pSrb->StreamObject );

	StreamClassStreamNotification( StreamRequestComplete,
									pSrb->StreamObject,
									pSrb );
}



void GetVpeProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
	DWORD dwInputBufferSize;
	DWORD dwOutputBufferSize;
#ifdef EZDVD
   	DWORD dwNumConnectInfo = 2;
#else
	DWORD dwNumConnectInfo = 2;
#endif
	
	DWORD dwNumVideoFormat = 1;
	DWORD dwFieldWidth = 720;
	DWORD dwFieldHeight = 240;


	// the pointers to which the input buffer will be cast to
	LPDDVIDEOPORTCONNECT pConnectInfo;
	LPDDPIXELFORMAT pVideoFormat;
	PKSVPMAXPIXELRATE pMaxPixelRate;
	PKS_AMVPDATAINFO pVpdata;
	DWORD	dwMicroSecPerField;

	// LPAMSCALINGINFO pScaleFactor;

	//
	// NOTE:  ABSOLUTELY DO NOT use pmulitem, until it is determined that
	// the stream property descriptor describes a multiple item, or you will
	// pagefault.
	//

	PKSMULTIPLE_ITEM  pmulitem =
		&(((PKSMULTIPLE_DATA_PROP)pSrb->CommandData.PropertyInfo->Property)->MultipleItem);

	//
	// NOTE: same goes for this one as above.
	//

	PKS_AMVPSIZE pdim = 
		&(((PKSVPSIZE_PROP)pSrb->CommandData.PropertyInfo->Property)->Size);

	if( pSrb->CommandData.PropertyInfo->PropertySetID ) {
//		TRAP;
		pSrb->Status = STATUS_NO_MATCH;
		return;
	}

	if(pHwDevExt->VidSystem == NTSC)
	{
		dwFieldHeight = 240;
		dwMicroSecPerField = 16666;
	}
	else
	{
		dwFieldHeight = 288;
		dwMicroSecPerField = 20000;
	}

	dwInputBufferSize = pSrb->CommandData.PropertyInfo->PropertyInputSize;
	dwOutputBufferSize = pSrb->CommandData.PropertyInfo->PropertyOutputSize;

	pSrb->Status = STATUS_SUCCESS;

	switch( pSrb->CommandData.PropertyInfo->Property->Id ) {
	  case KSPROPERTY_VPCONFIG_NUMCONNECTINFO:
		DebugPrint( (DebugLevelTrace, " KSPROPERTY_VPCONFIG_NUMCONNECTINFO\r\n") );

		// check that the size of the output buffer is correct
		ASSERT(dwInputBufferSize >= sizeof(DWORD));

		pSrb->ActualBytesTransferred = sizeof(DWORD);

		*(PULONG) pSrb->CommandData.PropertyInfo->PropertyInfo
					= dwNumConnectInfo;
		break;

	  case KSPROPERTY_VPCONFIG_NUMVIDEOFORMAT:
		DebugPrint( (DebugLevelTrace, " KSPROPERTY_VPCONFIG_NUMVIDEOFORMAT\r\n") );

		// check that the size of the output buffer is correct
		ASSERT(dwInputBufferSize >= sizeof(DWORD));

		pSrb->ActualBytesTransferred = sizeof(DWORD);

		*(PULONG) pSrb->CommandData.PropertyInfo->PropertyInfo
				= dwNumVideoFormat;

		break;

	  case KSPROPERTY_VPCONFIG_GETCONNECTINFO:
		DebugPrint( (DebugLevelTrace, " KSPROPERTY_VPCONFIG_GETCONNECTINFO\r\n") );

		if (pmulitem->Count > dwNumConnectInfo ||
			pmulitem->Size != sizeof (DDVIDEOPORTCONNECT) ||
			dwOutputBufferSize < 
			(pmulitem->Count * sizeof (DDVIDEOPORTCONNECT)))

		{
			DebugPrint(( DebugLevelTrace, "  pmulitem->Count %d\r\n", pmulitem->Count ));
			DebugPrint(( DebugLevelTrace, "  pmulitem->Size %d\r\n", pmulitem->Size ));
			DebugPrint(( DebugLevelTrace, " dwOutputBufferSize %d\r\n", dwOutputBufferSize ));
			DebugPrint(( DebugLevelTrace, " sizeof(DDVIDEOPORTCONNECT) %d\r\n", sizeof(DDVIDEOPORTCONNECT) ));

//			TRAP;

			//
			// buffer size is invalid, so error the call
			//

			pSrb->Status = STATUS_INVALID_BUFFER_SIZE;

			return;
		}


		//
		// specify the number of bytes written
		//

		pSrb->ActualBytesTransferred = pmulitem->Count*sizeof(DDVIDEOPORTCONNECT);

		pConnectInfo = (LPDDVIDEOPORTCONNECT)(pSrb->CommandData.PropertyInfo->PropertyInfo);

#ifdef EZDVD
		// S3
		pConnectInfo->dwSize = sizeof (DDVIDEOPORTCONNECT);
		// Revisit.  Create new entry for ZV
		//pConnectInfo->dwPortWidth = 8;
		pConnectInfo->dwPortWidth = 16;
		pConnectInfo->guidTypeID = g_ATIGuid3;
		pConnectInfo->dwFlags = DDVPCONNECT_INTERLACED;// | DDVPCONNECT_HALFLINE; // 0x4;;
		pConnectInfo->dwReserved1 = 0;

		pConnectInfo++;
		pConnectInfo->dwSize = sizeof (DDVIDEOPORTCONNECT);
		// Revisit.  Create new entry for ZV
		//pConnectInfo->dwPortWidth = 8;
		pConnectInfo->dwPortWidth = 16;
		pConnectInfo->guidTypeID = g_ZvGuid2;
		pConnectInfo->dwFlags = DDVPCONNECT_INTERLACED;// | DDVPCONNECT_HALFLINE; // 0x4;0x3F;
		pConnectInfo->dwReserved1 = 0;



#else

		// S3
		pConnectInfo->dwSize = sizeof (DDVIDEOPORTCONNECT);
		pConnectInfo->dwPortWidth = 8;
		pConnectInfo->guidTypeID = g_ZvGuid;
		pConnectInfo->dwFlags = 0x3F;
		pConnectInfo->dwReserved1 = 0;

		pConnectInfo++;

		// ATI
		pConnectInfo->dwSize = sizeof (DDVIDEOPORTCONNECT);
		pConnectInfo->dwPortWidth = 8;
		pConnectInfo->guidTypeID = g_ATIGuid;
		pConnectInfo->dwFlags = DDVPCONNECT_INTERLACED | DDVPCONNECT_HALFLINE; // 0x4;
			                        
		
//		pConnectInfo->dwFlags = DDVPCONNECT_INTERLACED|
//
//			                        DDVPCONNECT_HALFLINE;

		pConnectInfo->dwReserved1 = 0;
		
/*		pConnectInfo++;
		
		pConnectInfo->dwSize = sizeof (DDVIDEOPORTCONNECT);
		pConnectInfo->dwPortWidth = 8;
		pConnectInfo->guidTypeID = g_ZvGuid2;
		pConnectInfo->dwFlags = 0x4;
		pConnectInfo->dwReserved1 = 0;
		
		pConnectInfo++;

		pConnectInfo->dwSize = sizeof (DDVIDEOPORTCONNECT);
		pConnectInfo->dwPortWidth = 8;
		pConnectInfo->guidTypeID = g_ATIGuid2;
		pConnectInfo->dwFlags = 0x4;
		pConnectInfo->dwReserved1 = 0;
		
		pConnectInfo++;

		pConnectInfo->dwSize = sizeof (DDVIDEOPORTCONNECT);
		pConnectInfo->dwPortWidth = 8;
		pConnectInfo->guidTypeID = g_ATIGuid3;
		pConnectInfo->dwFlags = 0x4;
		pConnectInfo->dwReserved1 = 0;
		
		pConnectInfo++;

		pConnectInfo->dwSize = sizeof (DDVIDEOPORTCONNECT);
		pConnectInfo->dwPortWidth = 8;
		pConnectInfo->guidTypeID = g_ATIGuid4;
		pConnectInfo->dwFlags = 0x4;
		pConnectInfo->dwReserved1 = 0;
		
		pConnectInfo++;

		pConnectInfo->dwSize = sizeof (DDVIDEOPORTCONNECT);
		pConnectInfo->dwPortWidth = 8;
		pConnectInfo->guidTypeID = g_ATIGuid5;
		pConnectInfo->dwFlags = 0x4;
		pConnectInfo->dwReserved1 = 0;
		
*/		





#endif
		break;

	  case KSPROPERTY_VPCONFIG_VPDATAINFO:
		DebugPrint(( DebugLevelTrace, "KSPROPERTY_VPCONFIG_VPDATAINFO\r\n" ));

		//
		// specify the number of bytes written
		//

		pSrb->ActualBytesTransferred = sizeof(KS_AMVPDATAINFO);

		//
		// cast the buffer to the porper type
		//
		pVpdata = (PKS_AMVPDATAINFO)pSrb->CommandData.PropertyInfo->PropertyInfo;

		*pVpdata = pHwDevExt->VPFmt;
		pVpdata->dwSize = sizeof (KS_AMVPDATAINFO);

		pVpdata->dwMicrosecondsPerField	= dwMicroSecPerField;//80;//60;//17;

		ASSERT( pVpdata->dwNumLinesInVREF == 0 );

		pVpdata->dwNumLinesInVREF		= 0;
#ifdef EZDVD
			DebugPrint(( DebugLevelTrace, "Set for ATI AMC\r\n" ));
			// ATI AMC
			pVpdata->bEnableDoubleClock		= FALSE;
			pVpdata->bEnableVACT			= FALSE;
			pVpdata->bDataIsInterlaced		= TRUE;
			pVpdata->lHalfLinesOdd  		= 0;
			pVpdata->lHalfLinesEven  		= 0;
			pVpdata->bFieldPolarityInverted	= FALSE;

			pVpdata->amvpDimInfo.dwFieldWidth	= 720;
			pVpdata->amvpDimInfo.dwFieldHeight	= dwFieldHeight;//+18 ;//24-+18//240 + 2;

			pVpdata->amvpDimInfo.rcValidRegion.left		= 0;
			pVpdata->amvpDimInfo.rcValidRegion.top		= 18;//2;
			pVpdata->amvpDimInfo.rcValidRegion.right	= 720;//720 - 8;
			pVpdata->amvpDimInfo.rcValidRegion.bottom	= dwFieldHeight+18;//240+18;//240 + 2;

            pVpdata->amvpDimInfo.dwVBIWidth     = pVpdata->amvpDimInfo.dwFieldWidth;
			pVpdata->amvpDimInfo.dwVBIHeight    = 0;//pVpdata->amvpDimInfo.rcValidRegion.top;
			pVpdata->dwPictAspectRatioX = 720;
            pVpdata->dwPictAspectRatioY = dwFieldHeight * 2;	

#else


		if( pHwDevExt->VideoPort == 4 ) {
			DebugPrint(( DebugLevelTrace, "Set for S3 LPB\r\n" ));
			// S3 LPB
			pVpdata->bEnableDoubleClock		= FALSE;
			pVpdata->bEnableVACT			= FALSE;
			pVpdata->bDataIsInterlaced		= TRUE;
			pVpdata->lHalfLinesOdd  		= 0;
			pVpdata->lHalfLinesEven  		= 0;
			pVpdata->bFieldPolarityInverted	= FALSE;

			pVpdata->amvpDimInfo.dwFieldWidth	= 720 + 158/2;
			pVpdata->amvpDimInfo.dwFieldHeight	= dwFieldHeight+1;//240 + 1;

			pVpdata->amvpDimInfo.rcValidRegion.left		= 158/2;
			pVpdata->amvpDimInfo.rcValidRegion.top		= 1;
			pVpdata->amvpDimInfo.rcValidRegion.right	= 720 + 158/2 - 4;
			pVpdata->amvpDimInfo.rcValidRegion.bottom	= dwFieldHeight+1;//240 + 1;

            pVpdata->amvpDimInfo.dwVBIWidth     = pVpdata->amvpDimInfo.dwFieldWidth;
			pVpdata->amvpDimInfo.dwVBIHeight    = pVpdata->amvpDimInfo.rcValidRegion.top;

			pVpdata->dwPictAspectRatioX = 720;
            pVpdata->dwPictAspectRatioY = dwFieldHeight * 2;	

		}
		else if( pHwDevExt->VideoPort == 7 ) {
			DebugPrint(( DebugLevelTrace, "Set for ATI AMC\r\n" ));
			// ATI AMC
			pVpdata->bEnableDoubleClock		= FALSE;
			pVpdata->bEnableVACT			= FALSE;
			pVpdata->bDataIsInterlaced		= TRUE;
			pVpdata->lHalfLinesOdd  		= 0;
			pVpdata->lHalfLinesEven  		= 0;
			pVpdata->bFieldPolarityInverted	= FALSE;

			pVpdata->amvpDimInfo.dwFieldWidth	= 720;
			pVpdata->amvpDimInfo.dwFieldHeight	= dwFieldHeight;//+TOP_CROP;//240+18 ;//240 + 2;

			pVpdata->amvpDimInfo.rcValidRegion.left		= 0;
			pVpdata->amvpDimInfo.rcValidRegion.top		= TOP_CROP;//2;
			pVpdata->amvpDimInfo.rcValidRegion.right	= 720;//720 - 8;
			pVpdata->amvpDimInfo.rcValidRegion.bottom	= dwFieldHeight+TOP_CROP;//240+18;//240 + 2;

            pVpdata->amvpDimInfo.dwVBIWidth     = pVpdata->amvpDimInfo.dwFieldWidth;
			pVpdata->amvpDimInfo.dwVBIHeight    = 20;//pVpdata->amvpDimInfo.rcValidRegion.top;
			pVpdata->dwPictAspectRatioX = 720;
            pVpdata->dwPictAspectRatioY = dwFieldHeight * 2;	
		}
#endif
		break ;

	  case KSPROPERTY_VPCONFIG_MAXPIXELRATE:
		DebugPrint( (DebugLevelTrace, "KSPROPERTY_VPCONFIG_MAXPIXELRATE\r\n") );

		//
		// NOTE:
		// this property is special.  And has another different
		// input property!
		//

		if (dwInputBufferSize < sizeof (KSVPSIZE_PROP))
		{
//			TRAP;

			pSrb->Status = STATUS_INVALID_BUFFER_SIZE;

			return;
		}

		pSrb->ActualBytesTransferred = sizeof(KSVPMAXPIXELRATE);

		// cast the buffer to the porper type
		pMaxPixelRate = (PKSVPMAXPIXELRATE)pSrb->CommandData.PropertyInfo->PropertyInfo;

		// tell the app that the pixel rate is valid for these dimensions
		pMaxPixelRate->Size.dwWidth  	= dwFieldWidth;
		pMaxPixelRate->Size.dwHeight 	= dwFieldHeight;
		pMaxPixelRate->MaxPixelsPerSecond	= 13500000;//1300;

		break;

	  case KSPROPERTY_VPCONFIG_INFORMVPINPUT:

		pSrb->Status = STATUS_NOT_IMPLEMENTED;

		break ;

	  case KSPROPERTY_VPCONFIG_GETVIDEOFORMAT:
		DebugPrint(( DebugLevelTrace, "KSPROPERTY_VPCONFIG_GETVIDEOFORMAT\r\n" ));

		//
		// check that the size of the output buffer is correct
		//

		if (pmulitem->Count > dwNumConnectInfo ||
			pmulitem->Size != sizeof (DDPIXELFORMAT) ||
			dwOutputBufferSize < 
			(pmulitem->Count * sizeof (DDPIXELFORMAT)))

		{
			DebugPrint(( DebugLevelTrace, "pmulitem->Count %d\r\n", pmulitem->Count ));
			DebugPrint(( DebugLevelTrace, "pmulitem->Size %d\r\n", pmulitem->Size ));
			DebugPrint(( DebugLevelTrace, "dwOutputBufferSize %d\r\n", dwOutputBufferSize ));
			DebugPrint(( DebugLevelTrace, "sizeof(DDPIXELFORMAT) %d\r\n", sizeof(DDPIXELFORMAT) ));

//			TRAP;

			//
			// buffer size is invalid, so error the call
			//

			pSrb->Status = STATUS_INVALID_BUFFER_SIZE;

			return;
		}


		//
		// specify the number of bytes written
		//

		pSrb->ActualBytesTransferred = pmulitem->Count*sizeof(DDPIXELFORMAT);

		pVideoFormat = (LPDDPIXELFORMAT)(pSrb->CommandData.PropertyInfo->PropertyInfo);

		if( pHwDevExt->VideoPort == 4 ) {
			DebugPrint(( DebugLevelTrace, "Set for S3 LPB\r\n" ));
			// S3 LPB
			pVideoFormat->dwSize= sizeof (DDPIXELFORMAT);
			pVideoFormat->dwFlags = DDPF_FOURCC;//|DDPF_INTERLACED;
			pVideoFormat->dwFourCC = MKFOURCC( 'Y', 'U', 'Y', '2' );
			pVideoFormat->dwYUVBitCount = 16;
		}
		else if( pHwDevExt->VideoPort == 7 ) {
			DebugPrint(( DebugLevelTrace, "Set for ATI AMC\r\n" ));
			// ATI AMC
			pVideoFormat->dwSize= sizeof (DDPIXELFORMAT);
			pVideoFormat->dwFlags = DDPF_FOURCC;//|DDPF_INTERLACED;
			pVideoFormat->dwYUVBitCount = 16;
			pVideoFormat->dwFourCC = MKFOURCC( 'U', 'Y', 'V', 'Y' );
			// Not needed?
			pVideoFormat->dwYBitMask = (DWORD)0xFF00FF00;
			pVideoFormat->dwUBitMask = (DWORD)0x000000FF;
			pVideoFormat->dwVBitMask = (DWORD)0x00FF0000;
		}
//		else
//			TRAP;

		break;

	  case KSPROPERTY_VPCONFIG_DECIMATIONCAPABILITY:

		//
		// indicate that we can decimate anything, especially if it's late.
		//

		pSrb->ActualBytesTransferred = sizeof (BOOL);
		*((PBOOL)pSrb->CommandData.PropertyInfo->PropertyInfo) = TRUE;

		break;

	  default:
		DebugPrint( (DebugLevelTrace, "PropertySetID 0 default %d(0x%x)\r\n", pSrb->CommandData.PropertyInfo->Property->Id, pSrb->CommandData.PropertyInfo->Property->Id ) );
//		TRAP;

		pSrb->Status = STATUS_NOT_IMPLEMENTED;

		break;
	}
}

void SetVpeProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
	DWORD dwInputBufferSize;
	DWORD dwOutputBufferSize;
	DWORD *lpdwOutputBufferSize;

	ULONG index;

	PKS_AMVPSIZE pDim;

	if( pSrb->CommandData.PropertyInfo->PropertySetID ) {
//		TRAP;
		pSrb->Status = STATUS_NO_MATCH;
		return;
	}

	dwInputBufferSize  = pSrb->CommandData.PropertyInfo->PropertyInputSize;
	dwOutputBufferSize = pSrb->CommandData.PropertyInfo->PropertyOutputSize;
	lpdwOutputBufferSize = &(pSrb->ActualBytesTransferred);

	pSrb->Status = STATUS_SUCCESS;

	switch( pSrb->CommandData.PropertyInfo->Property->Id ) {
	  case KSPROPERTY_VPCONFIG_SETCONNECTINFO:
		DebugPrint( (DebugLevelTrace, "KSPROPERTY_VPCONFIG_SETCONNECTINFO\r\n") );

		//
		// pSrb->CommandData.PropertInfo->PropertyInfo
		// points to a ULONG which is an index into the array of
		// connectinfo structs returned to the caller from the
		// Get call to ConnectInfo.
		//
		// Since the sample only supports one connection type right
		// now, we will ensure that the requested index is 0.
		//

		//
		// at this point, we would program the hardware to use
		// the right connection information for the videoport.
		// since we are only supporting one connection, we don't
		// need to do anything, so we will just indicate success
		//

		index = *((ULONG *)(pSrb->CommandData.PropertyInfo->PropertyInfo));

		DebugPrint(( DebugLevelTrace, "%d\r\n", index ));

		if( index == 0 ) {
			pHwDevExt->VideoPort = 4;	// S3 LPB
//			pHwDevExt->DAck.PCIF_SET_DIGITAL_OUT( pHwDevExt->VideoPort );
		}
		else {//if( index == 1 ) {
			pHwDevExt->VideoPort = 7;	// ATI AMC
//			pHwDevExt->DAck.PCIF_SET_DIGITAL_OUT( pHwDevExt->VideoPort );

		}
//		else
//			TRAP;

		break;

	  case KSPROPERTY_VPCONFIG_DDRAWHANDLE:
		DebugPrint( (DebugLevelTrace, "KSPROPERTY_VPCONFIG_DDRAWHANDLE\r\n") );

		pHwDevExt->ddrawHandle =
			(*(PULONG)pSrb->CommandData.PropertyInfo->PropertyInfo);

		break;

	  case KSPROPERTY_VPCONFIG_VIDEOPORTID:
		DebugPrint( (DebugLevelTrace, "KSPROPERTY_VPCONFIG_VIDEOPORTID\r\n") );

		pHwDevExt->VidPortID =
			(*(PULONG)pSrb->CommandData.PropertyInfo->PropertyInfo);

		break;

	  case KSPROPERTY_VPCONFIG_DDRAWSURFACEHANDLE:
		DebugPrint( (DebugLevelTrace, "KSPROPERTY_VPCONFIG_DDRAWSURFACEHANDLE\r\n") );

		pHwDevExt->SurfaceHandle =
			(*(PULONG)pSrb->CommandData.PropertyInfo->PropertyInfo);

		break;

	  case KSPROPERTY_VPCONFIG_SETVIDEOFORMAT:
		DebugPrint(( DebugLevelTrace, "KSPROPERTY_VPCONFIG_SETVIDEOFORMAT\r\n" ));

		//
		// pSrb->CommandData.PropertInfo->PropertyInfo
		// points to a ULONG which is an index into the array of
		// VIDEOFORMAT structs returned to the caller from the
		// Get call to FORMATINFO
		//
		// Since the sample only supports one FORMAT type right
		// now, we will ensure that the requested index is 0.
		//

		//
		// at this point, we would program the hardware to use
		// the right connection information for the videoport.
		// since we are only supporting one connection, we don't
		// need to do anything, so we will just indicate success
		//

		index = *((ULONG *)(pSrb->CommandData.PropertyInfo->PropertyInfo));

		DebugPrint(( DebugLevelTrace, "%d\r\n", index ));

		break;

	  case KSPROPERTY_VPCONFIG_INFORMVPINPUT:
		DebugPrint( (DebugLevelTrace, "KSPROPERTY_VPCONFIG_INFORMVPINPUT\r\n") );

		//
		// These are the preferred formats for the VPE client
		//
		// they are multiple properties passed in, return success
		//

		pSrb->Status = STATUS_NOT_IMPLEMENTED;

		break;

	  case KSPROPERTY_VPCONFIG_INVERTPOLARITY:
		DebugPrint( (DebugLevelTrace, "KSPROPERTY_VPCONFIG_INVERTPOLARITY\r\n") );

		//
		// Toggles the global polarity flag, telling the output
		// of the VPE port to be inverted.  Since this hardware
		// does not support this feature, we will just return
		// success for now, although this should be returning not
		// implemented
		//

		break;

	  case KSPROPERTY_VPCONFIG_SCALEFACTOR:
		DebugPrint( (DebugLevelTrace, "KSPROPERTY_VPCONFIG_SCALEFACTOR\r\n") );

		//
		// the sizes for the scaling factor are passed in, and the
		// image dimensions should be scaled appropriately
		//

		//
		// if there is a horizontal scaling available, do it here.
		//

//		TRAP;

		pDim =(PKS_AMVPSIZE)(pSrb->CommandData.PropertyInfo->PropertyInfo);

		break;

	  default:
		DebugPrint( (DebugLevelTrace, "PropertySetID 0 default %d(0x%x)\r\n", pSrb->CommandData.PropertyInfo->Property->Id, pSrb->CommandData.PropertyInfo->Property->Id ) );
//		TRAP;

		pSrb->Status = STATUS_NOT_IMPLEMENTED;

		break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dxr2\vidstrm.c ===
/******************************************************************************\
*                                                                              *
*      VIDSTRM.C  -     Video stream control related code.                     *
*                                                                              *
*      Copyright (c) C-Cube Microsystems 1996                                  *
*      All Rights Reserved.                                                    *
*                                                                              *
*      Use of C-Cube Microsystems code is governed by terms and conditions     *
*      stated in the accompanying licensing statement.                         *
*                                                                              *
\******************************************************************************/

#include "Headers.h"
#pragma hdrstop
#include "vidstrm.h"
#include "copyprot.h"
#include "bmaster.h"
#include "vpestrm.h"
#include "ccaption.h"

extern BOOL bJustHighLight;
extern GUID MY_KSEVENTSETID_VPNOTIFY ;
typedef struct _STREAMEX {
	BOOL EventCount; 
	KSSTATE state;
	HANDLE hClk;

}STREAMEX, *PSTREAMEX;


//*****************************************************************************
//  STATIC FUNCTIONS DECLARATION
//*****************************************************************************
static VOID GetVideoProperty( PHW_STREAM_REQUEST_BLOCK pSrb );
static VOID SetVideoProperty( PHW_STREAM_REQUEST_BLOCK pSrb );
static void GetVideoRateChange( PHW_STREAM_REQUEST_BLOCK pSrb );
static void SetVideoRateChange( PHW_STREAM_REQUEST_BLOCK pSrb );
static VOID VideoSendPacket( PHW_STREAM_REQUEST_BLOCK pSrb );
static void VideoQueryAccept( PHW_STREAM_REQUEST_BLOCK pSrb );


/*
** VideoReceiveCtrlPacket()
**
**   Receives packet commands that control the video stream
**
** Arguments:
**
**   pSrb - The stream request block for the video stream
**
** Returns:
**
** Side Effects:  none
*/
VOID STREAMAPI VideoReceiveCtrlPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pdevext = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;

	DebugPrint(( DebugLevelVerbose, "ZiVA: Begin VideoReceiveCtrlPacket->" ));
	switch( pSrb->Command )
	{
	case SRB_SET_STREAM_STATE:
		DebugPrint(( DebugLevelVerbose, "SRB_SET_STREAM_STATE\n" ));
		AdapterSetState( pSrb );
		break;

	case SRB_GET_STREAM_PROPERTY:
		DebugPrint(( DebugLevelVerbose, "SRB_GET_STREAM_PROPERTY\n" ));
		GetVideoProperty( pSrb );
		break;

	case SRB_SET_STREAM_PROPERTY:
		DebugPrint(( DebugLevelVerbose, "SRB_SET_STREAM_PROPERTY\n" ));
		SetVideoProperty( pSrb );
		break;

	case SRB_PROPOSE_DATA_FORMAT:
		DebugPrint(( DebugLevelVerbose, "SRB_PROPOSE_DATA_FORMAT\n" ));
		VideoQueryAccept( pSrb );
		break;

	case SRB_OPEN_MASTER_CLOCK:
	case SRB_CLOSE_MASTER_CLOCK:
	case SRB_INDICATE_MASTER_CLOCK:
		//
		// these should be stored individually on a per stream basis
		//
		//hMaster = pSrb->CommandData.MasterClockHandle;
		pSrb->Status = STATUS_SUCCESS;
		break;

	case SRB_BEGIN_FLUSH :            // beginning flush state
		MonoOutStr(" Vid : SRB_BEGIN_FLUSH ");
#ifndef DECODE_DVDPC
		pdevext->bInterruptPending = FALSE;
#endif
		
		if (pdevext->pCurrentVideoSrb != NULL)
		{
			ZivaHw_Abort();	
//			adapterUpdateNextSrbOrderNumberOnDiscardSrb(pdevext->pCurrentVideoSrb);
			pdevext->pCurrentVideoSrb->Status =  STATUS_SUCCESS;
			
			AdapterReleaseRequest( pdevext->pCurrentVideoSrb );
			pdevext->pCurrentVideoSrb = NULL;
			pdevext->dwCurrentVideoSample = 0;
			pdevext->dwCurrentVideoPage = 0;
		}

		pSrb->Status = STATUS_SUCCESS;
		break;
	case SRB_END_FLUSH :              // ending flush state
		MonoOutStr(" Vid : SRB_END_FLUSH ");
		pSrb->Status = STATUS_SUCCESS;
		if (pdevext->pCurrentVideoSrb != NULL)
		{
			
//			adapterUpdateNextSrbOrderNumberOnDiscardSrb(pdevext->pCurrentVideoSrb);
			pdevext->pCurrentVideoSrb->Status =  STATUS_SUCCESS;
			
			AdapterReleaseRequest( pdevext->pCurrentVideoSrb );
			pdevext->pCurrentVideoSrb = NULL;
			pdevext->dwCurrentVideoSample = 0;
			pdevext->dwCurrentVideoPage = 0;
		}

//		ZivaHw_Play();
		pdevext->bPlayCommandPending = TRUE;
		pdevext->bEndFlush = TRUE;
//		FinishCurrentPacketAndSendNextOne( pdevext );
		break;




	default:
		//TRAP
		DebugPrint(( DebugLevelVerbose, "!!!! UNKNOWN COMMAND !!!! :::> %X\n", pSrb->Command ));
		pSrb->Status = STATUS_NOT_IMPLEMENTED;
	}
	
	AdapterReleaseRequest( pSrb );
	DebugPrint(( DebugLevelVerbose, "ZiVA: End VideoReceiveCtrlPacket\n" ));
}


/*
** VideoReceiveDataPacket()
**
**   Receives video data packets
**
** Arguments:
**
**   pSrb - Stream request block for the video device
**
** Returns:
**
** Side Effects:  none
*/
VOID STREAMAPI VideoReceiveDataPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pdevext = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;


	switch( pSrb->Command )
	{
	case SRB_WRITE_DATA:

		if(bJustHighLight)
		{
			pSrb->TimeoutCounter = pSrb->TimeoutOriginal = pSrb->TimeoutCounter / 5;
			bJustHighLight = FALSE;
			MonoOutStr("Video TimeOut Counter Reduced");
		}
		VideoSendPacket( pSrb );

		break;

	default:
		DebugPrint(( DebugLevelWarning, "!!!! UNKNOWN COMMAND !!!! :::> %X\n", pSrb->Command ));
		pSrb->Status = STATUS_NOT_IMPLEMENTED;
		MonoOutStr("!!!! UNKNOWN COMMAND !!!!");
		AdapterReleaseRequest( pSrb );
	}
}


/*
** GetVideoProperty()
**
**    Routine to process video property requests
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/
static VOID GetVideoProperty(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	PHW_DEVICE_EXTENSION phwdevext = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
	PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

	DebugPrint(( DebugLevelVerbose, "ZiVA: Begin GetVideoProperty()\n" ));
	if( IsEqualGUID( &KSPROPSETID_CopyProt, &pSPD->Property->Set ) )
	{	// this is a copy protection property go handle it there
		CopyProtGetProp( pSrb );
	}
	else if( IsEqualGUID( &KSPROPSETID_TSRateChange, &pSPD->Property->Set ) )
	{	// this is a transfer rate change property go handle it there
		GetVideoRateChange( pSrb );
	}

	DebugPrint(( DebugLevelVerbose, "ZiVA: End GetVideoProperty()\n" ));
}

/*
** SetVideoProperty()
**
**    Routine to process video property requests
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/
static VOID SetVideoProperty( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION phwdevext = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
	PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

	DebugPrint(( DebugLevelVerbose, "ZiVA: Begin GetVideoProperty()\n" ));
	if( IsEqualGUID( &KSPROPSETID_CopyProt, &pSPD->Property->Set ) )
	{	// this is a copy protection property go handle it there
		CopyProtSetPropIfAdapterReady( pSrb );
	}
	else if( IsEqualGUID( &KSPROPSETID_TSRateChange, &pSPD->Property->Set ) )
	{	// this is a transfer rate change property go handle it there
		SetVideoRateChange( pSrb );
	}

	DebugPrint(( DebugLevelVerbose, "ZiVA: End GetVideoProperty()\n" ));
}

static void GetVideoRateChange( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;

	DebugPrint(( DebugLevelVerbose, "ZiVA:  GetVideoRateChange()->" ));
	switch( pSrb->CommandData.PropertyInfo->Property->Id )
	{
	case KS_AM_RATE_SimpleRateChange:
		{
			KS_AM_SimpleRateChange* pRateChange;

			DebugPrint(( DebugLevelVerbose, "KS_AM_RATE_SimpleRateChange\n" ));
			pSrb->ActualBytesTransferred = sizeof( KS_AM_RATE_SimpleRateChange );
			pRateChange = (KS_AM_SimpleRateChange*)pSrb->CommandData.PropertyInfo->PropertyInfo;
			pRateChange->StartTime = 0/*pHwDevExt->VideoStartTime*/;
			pRateChange->Rate = 10000 /*pHwDevExt->VideoRate*/;
		}
		pSrb->Status = STATUS_SUCCESS;
		break;

	case KS_AM_RATE_ExactRateChange:
		DebugPrint(( DebugLevelVerbose, "KS_AM_RATE_ExactRateChange (NOT IMPLEMENTED)\n" ));
		pSrb->Status = STATUS_NOT_IMPLEMENTED;
		break;

	case KS_AM_RATE_MaxFullDataRate:
		{
			KS_AM_MaxFullDataRate* pMaxRate;

			DebugPrint(( DebugLevelVerbose, "KS_AM_RATE_MaxFullDataRate\n" ));
			pSrb->ActualBytesTransferred = sizeof( KS_AM_RATE_MaxFullDataRate );
			pMaxRate = (KS_AM_MaxFullDataRate*)pSrb->CommandData.PropertyInfo->PropertyInfo;
			*pMaxRate = 10000 /*pHwDevExt->VideoMaxFullRate*/;
		}
		pSrb->Status = STATUS_SUCCESS;
		break;

	case KS_AM_RATE_Step:
		DebugPrint(( DebugLevelVerbose, "KS_AM_RATE_Step (NOT IMPLEMENTED)\n" ));
		pSrb->Status = STATUS_NOT_IMPLEMENTED;
	}
}

static void SetVideoRateChange( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
	DebugPrint(( DebugLevelVerbose, "ZiVA:  SetVideoRateChange()->" ));

	switch( pSrb->CommandData.PropertyInfo->Property->Id )
	{
	case KS_AM_RATE_SimpleRateChange:
		{
			KS_AM_SimpleRateChange* pRateChange;
			REFERENCE_TIME NewStartTime;
			LONG NewRate;

			DebugPrint(( DebugLevelVerbose, "KS_AM_RATE_SimpleRateChange\n" ));
			MonoOutStr("KS_AM_RATE_SimpleRateChange");		//sri
			pRateChange = (KS_AM_SimpleRateChange*)pSrb->CommandData.PropertyInfo->PropertyInfo;
			NewStartTime = pRateChange->StartTime;
			NewRate = (pRateChange->Rate < 0) ? -pRateChange->Rate : pRateChange->Rate;

			DebugPrint(( DebugLevelVerbose, "ZiVA: Received Data\r\n" ));
			DebugPrint(( DebugLevelVerbose, "ZiVA:   StartTime = 0x%08x\r\n", NewStartTime ));
			DebugPrint(( DebugLevelVerbose, "ZiVA:   Rate      = 0x%08x\r\n", NewRate ));
			
			pHwDevExt->bScanCommandPending = TRUE;

			if( pHwDevExt->NewRate  > 10000)
				pHwDevExt->bRateChangeFromSlowMotion = TRUE;

			pHwDevExt->NewRate = NewRate;


		}
		pSrb->Status = STATUS_SUCCESS;
		break;

	case KS_AM_RATE_ExactRateChange :
		pSrb->Status = STATUS_NOT_IMPLEMENTED;
		break;

	case KS_AM_RATE_MaxFullDataRate :
		pSrb->Status = STATUS_NOT_IMPLEMENTED;
		break;

	case KS_AM_RATE_Step :
		pSrb->Status = STATUS_NOT_IMPLEMENTED;
		break;
	}
}

#if 0
static BOOLEAN PreparePageTable(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	DWORD i = 0;
	DWORD k = 0;
	DWORD j = 0;
	PKSSCATTER_GATHER	pSGList;
	DWORD dwSum = 0;
	PHW_DEVICE_EXTENSION	pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;

	if(pSrb == NULL)
	{
#ifdef DEBUG
		MonoOutStr("PreparePageTable::pSrb is NULL");
#endif
		return FALSE;
	}
	
	pSGList = pSrb->ScatterGatherBuffer;

	if(pSGList == NULL)
	{
#ifdef DEBUG
		MonoOutStr("PreparePageTable::pSGList is NULL");
#endif
		return FALSE;
	}
	
	while( j < pSrb->NumberOfBuffers)
	{
		dwSum = 0;
		k = 0;
		do
		{
			dwSum += pSGList[i].Length;
			i++;
			k++;

		}while(dwSum < pHwDevExt->VidBufferSize[j]);

		pHwDevExt->VideoPageTable[j] = k;
		j++;
		if(j > 50)
		{
#ifdef DEBUG
			MonoOutStr("PreparePageTable::ArrayCrossingLimit");
#endif
			return FALSE;
		}
		

	}
	return TRUE;
}

#endif


/*
** VideoSendPacket()
**
**   Routine to initialise the stream data packet handling
**
** Arguments:
**
**   pSrb - Pointer to the stream request block
**
** Returns:
**
** Side Effects:  none
*/
static VOID VideoSendPacket(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	PHW_DEVICE_EXTENSION	pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
	
	ULONG					ulSample;
	KSSTREAM_HEADER*		pHeader;


	if (CheckAndReleaseIfCtrlPkt(pSrb))
		return;

	pHeader = (PKSSTREAM_HEADER)pSrb->CommandData.DataBufferArray;
	for( ulSample = 0; ulSample < pSrb->NumberOfBuffers; ulSample++, pHeader++ )
	{
    // Check header flags

#ifdef DEBUG
		if( pHeader->OptionsFlags & ~(KSSTREAM_HEADER_OPTIONSF_SPLICEPOINT			|
										KSSTREAM_HEADER_OPTIONSF_PREROLL			|
										KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY	|
										KSSTREAM_HEADER_OPTIONSF_TYPECHANGED		|
										KSSTREAM_HEADER_OPTIONSF_TIMEVALID			|
										KSSTREAM_HEADER_OPTIONSF_TIMEDISCONTINUITY	|
										KSSTREAM_HEADER_OPTIONSF_FLUSHONPAUSE		|
										KSSTREAM_HEADER_OPTIONSF_DURATIONVALID		|
										KSSTREAM_HEADER_OPTIONSF_LOOPEDDATA) )
		DebugPrint(( DebugLevelWarning, "ZiVA: !!!!!!!!! NEW KSSTREAM_HEADER_OPTIONSF_ ADDED !!!!!!!!!\n" ));
	
//tmp		MonoOutChar('V');
//tmp		MonoOutULong( (pHeader->TypeSpecificFlags) >> 16 );
//tmp		MonoOutChar( '.' );
//		MonoOutStr("PHTime");
//		MonoOutULong( pHeader->PresentationTime );

		pHwDevExt->VideoSTC = pHeader->PresentationTime.Time;
#endif	
		if(pHwDevExt->dwFirstVideoOrdNum == -1)
		{
			pHwDevExt->dwFirstVideoOrdNum = (pHeader->TypeSpecificFlags) >> 16;
			MonoOutStr("FirstVidioBuffer");
			MonoOutULong( (pHeader->TypeSpecificFlags) >> 16 );
			
		}

		//	pHwDevExt->VidBufferSize[ulSample] = pHeader->DataUsed;

		if(pHwDevExt->bToBeDiscontinued)
		{
		//	wVideoDiscOrderNumber = (pHeader->TypeSpecificFlags) >> 16;
			pHwDevExt->bToBeDiscontinued = FALSE;
			pHwDevExt->bDiscontinued = TRUE;
		}

		// #ifdef DEBUG

		if( pHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_FLUSHONPAUSE )
		{
			MonoOutStr(" V->FLUSHONPAUSE ");
			
		}


		if( pHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY )
		{
			MonoOutStr(" V->DISCONT ");
			
//			wVideoDiscOrderNumber = (pHeader->TypeSpecificFlags) >> 16;
			pHwDevExt->bToBeDiscontinued = TRUE;
			pHwDevExt->bDiscontinued = TRUE;
			CCSendDiscontinuity(pHwDevExt);
		}


		if( pHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TYPECHANGED )
		{

			DebugPrint(( DebugLevelVerbose, "ZiVA: Processing video stream format.\n" ));
			MonoOutStr( " V->TYPECHANGED " );

			
//#if defined (DECODER_DVDPC) || defined(EZDVD)
			if ( pHeader->DataUsed >= sizeof(KSDATAFORMAT) + sizeof(KS_MPEGVIDEOINFO2) )
			{
				ProcessVideoFormat( (PKSDATAFORMAT)pHeader->Data, pHwDevExt );
			}
//#endif
		}
	}

	//  Register this Srb
#ifdef DEBUG
	if( pHwDevExt->pCurrentVideoSrb )
	{
		MonoOutStr("!!!!!!!VideoSlotNotEmpty!!!!!");
		DebugPrint(( DebugLevelWarning, "ZiVA: !!!!!!!!!!! ERROR: Video slot is not empty !!!!!!!!!!\n" ));
	}
#endif  // DEBUG
	pHwDevExt->pCurrentVideoSrb = pSrb;
	AdapterSendData( pHwDevExt );
}


/*
** VideoQueryAccept()
**
**
**
** Arguments:
**
**   pSrb - Pointer to the stream request block
**
** Returns:
**
** Side Effects:  none
*/
static void VideoQueryAccept( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PKSDATAFORMAT		pfmt	= pSrb->CommandData.OpenFormat;
	KS_MPEGVIDEOINFO2*	pblock	= (KS_MPEGVIDEOINFO2*)((BYTE*)pfmt + sizeof( KSDATAFORMAT ));

	DebugPrint(( DebugLevelVerbose, "ZiVA: Begin VideoQueryAccept()\n" ));

	// pick up the format block and examine it. Default to not implemented
	pSrb->Status = STATUS_SUCCESS;
	if( pfmt->FormatSize != sizeof( KSDATAFORMAT ) + sizeof( KS_MPEGVIDEOINFO2 ) )
		pSrb->Status = STATUS_NOT_IMPLEMENTED;

	DebugPrint(( DebugLevelVerbose, "ZiVA: End VideoQueryAccept()\n" ));
}


void SetDisplayModeAndAspectRatio(PHW_DEVICE_EXTENSION pHwDevExt,KS_MPEGVIDEOINFO2 * VidFmt)
{

	if( pHwDevExt->VPFmt.dwPictAspectRatioX == 4 && pHwDevExt->VPFmt.dwPictAspectRatioY == 3 )
	{
		ZivaHW_ForceCodedAspectRatio(0);
		if( VidFmt->dwFlags & KS_MPEG2_SourceIsLetterboxed )
		{
			if( VidFmt->dwFlags & KS_MPEG2_DoPanScan )
			{
				ZivaHw_SetDisplayMode( 0,1);
			}
			else
			{
				ZivaHw_SetDisplayMode( 0,2);
			}
		}
		else if( VidFmt->dwFlags & KS_MPEG2_DoPanScan )
		{
			ZivaHw_SetDisplayMode( 0,1);
		}
		else
		{
			ZivaHw_SetDisplayMode( 0,2);	
			
		}
	}
	else if (pHwDevExt->VPFmt.dwPictAspectRatioX == 16 && pHwDevExt->VPFmt.dwPictAspectRatioY == 9 )
	{
		ZivaHW_ForceCodedAspectRatio(3);
		if( VidFmt->dwFlags & KS_MPEG2_SourceIsLetterboxed )
		{
			if( VidFmt->dwFlags & KS_MPEG2_DoPanScan )
			{
				ZivaHw_SetDisplayMode( 0,1);
			}
			else
			{
				ZivaHw_SetDisplayMode( 0,2);
			}
		}
		else if( VidFmt->dwFlags & KS_MPEG2_DoPanScan )
		{
			ZivaHw_SetDisplayMode( 0,1);
		}
		else
		{
			ZivaHw_SetDisplayMode( 0,2);	
			
		}

	}
}

void SetVideoSystem(PHW_DEVICE_EXTENSION pHwDevExt, DWORD biHeight)
{
	static WORD VidSystem=-1;
	if((biHeight == 576)||(biHeight == 288))
		pHwDevExt->VidSystem = PAL;
	else
		pHwDevExt->VidSystem = NTSC;
	if(VidSystem != pHwDevExt->VidSystem)
		ZivaHw_SetVideoMode(pHwDevExt);
	VidSystem = pHwDevExt->VidSystem;
}
void ProcessVideoFormat( PKSDATAFORMAT pfmt, PHW_DEVICE_EXTENSION pHwDevExt )
{
	
	KS_MPEGVIDEOINFO2 * VidFmt = (KS_MPEGVIDEOINFO2 *)((ULONG)pfmt + sizeof  (KSDATAFORMAT));

	if( pfmt->FormatSize != sizeof(KSDATAFORMAT) + sizeof(KS_MPEGVIDEOINFO2) ) 
		return;
		

	pHwDevExt->VPFmt.dwPictAspectRatioX = VidFmt->hdr.dwPictAspectRatioX;
	pHwDevExt->VPFmt.dwPictAspectRatioY = VidFmt->hdr.dwPictAspectRatioY;

	SetDisplayModeAndAspectRatio(pHwDevExt,VidFmt);

	SetVideoSystem(pHwDevExt,VidFmt->hdr.bmiHeader.biHeight);


	if( VidFmt->dwFlags & KS_MPEG2_DoPanScan )
		DebugPrint(( DebugLevelTrace, "KS_MPEG2_DoPanScan\r\n" ));
	if( VidFmt->dwFlags & KS_MPEG2_DVDLine21Field1 )
		DebugPrint(( DebugLevelTrace, "KS_MPEG2_DVDLine21Field1\r\n" ));
	if( VidFmt->dwFlags & KS_MPEG2_DVDLine21Field2 )
		DebugPrint(( DebugLevelTrace, "KS_MPEG2_DVDLine21Field2\r\n" ));
	if( VidFmt->dwFlags & KS_MPEG2_SourceIsLetterboxed )
		DebugPrint(( DebugLevelTrace, "KS_MPEG2_SourceIsLetterboxed\r\n" ));
	if( VidFmt->dwFlags & KS_MPEG2_FilmCameraMode )
		DebugPrint(( DebugLevelTrace, "KS_MPEG2_FilmCameraMode\r\n" ));

	if (VidFmt->dwFlags & KS_MPEG2_DoPanScan)
	{
//		TRAP;

		//
		// under pan scan for DVD for NTSC, we must be going to a 540 by
		// 480 bit image, from a 720 x 480 (or 704 x 480)  We will
		// use this as the base starting dimensions.  If the Sequence
		// header provides other sizes, then those should be updated,
		// and the Video port connection should be updated when the
		// sequence header is received.
		//

		//
		// change the picture aspect ratio.  Since we will be stretching
		// from 540 to 720 in the horizontal direction, our aspect ratio
		// will 
		//

		pHwDevExt->VPFmt.dwPictAspectRatioX = (VidFmt->hdr.dwPictAspectRatioX * (54000 / 72));
		pHwDevExt->VPFmt.dwPictAspectRatioY = VidFmt->hdr.dwPictAspectRatioY * 1000;

	}

	//
	// call the IVPConfig interface here
	//
#if defined(DECODER_DVDPC) || defined(EZDVD)
	if (pHwDevExt->pstroYUV &&
			((PSTREAMEX)(pHwDevExt->pstroYUV->HwStreamExtension))->EventCount)
	{
		StreamClassStreamNotification(
			SignalMultipleStreamEvents,
			pHwDevExt->pstroYUV,
			&MY_KSEVENTSETID_VPNOTIFY,
			KSEVENT_VPNOTIFY_FORMATCHANGE
			);

	}
#endif
}
/*
** CycEvent ()
**
**    receives notification for stream event enable/ disable
**
** Arguments:}
**
**
**
** Returns:
**
** Side Effects:
*/

#if defined(DECODER_DVDPC) || defined(EZDVD)

NTSTATUS STREAMAPI CycEvent( PHW_EVENT_DESCRIPTOR pEvent )
{
	PSTREAMEX pstrm = (PSTREAMEX)( pEvent->StreamObject->HwStreamExtension );

	//DebugPrint( (DebugLevelTrace, "CycEvent\r\n") );

	if( pEvent->Enable ) {
		pstrm ->EventCount++;
	}
	else {
		pstrm ->EventCount--;
	}

	return( STATUS_SUCCESS );
}




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dxr2\tc6807af.h ===
/******************************************************************************\
*                                                                              *
*      TC6807af.h       -     Hardware abstraction level library.                *
*                                                                              *
*      Copyright (c) C-Cube Microsystems 1996                                  *
*      All Rights Reserved.                                                    *
*                                                                              *
*      Use of C-Cube Microsystems code is governed by terms and conditions     *
*      stated in the accompanying licensing statement.                         *
*                                                                              *
\******************************************************************************/

//
//  TC6807AF.H  Digital Copy-Protection for DVD
//
/////////////////////////////////////////////////////////////////////

#define TC6807AF_GET_CHALLENGE            1
#define TC6807AF_SEND_CHALLENGE           2
#define TC6807AF_GET_RESPONSE             3
#define TC6807AF_SEND_RESPONSE            4
#define TC6807AF_SEND_DISK_KEY            5
#define TC6807AF_SEND_TITLE_KEY           6
#define TC6807AF_SET_DECRYPTION_MODE      7

BOOL TC6807AF_Initialize( DWORD dwBaseAddress );
BOOL TC6807AF_Reset();
BOOL TC6807AF_Authenticate( WORD wFunction, BYTE * pbyDATA );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dxr2\xtoa.c ===
/******************************************************************************\
*                                                                             *
*      XTOA.C     -     Digit to string convertion functions.                 *
*                                                                             *
*      Copyright (c) C-Cube Microsystems 1996                                 *
*      All Rights Reserved.                                                   *
*                                                                             *
*      Use of C-Cube Microsystems code is governed by terms and conditions    *
*      stated in the accompanying licensing statement.                        *
*                                                                             *
\******************************************************************************/

static char digits[] = "0123456789ABCDEF";

char *_itoa( unsigned int value, char *string, unsigned int radix )
{
  char result[265];
  int  pos;
  int  index;
  int  dig;

  pos = 0;

  do
  {
    dig = value % radix;
	//if ( dig )
      result[pos++] = digits[dig];
    value -= dig;

    dig = value / radix;
	value = dig;
  } while ( dig >= (int)radix );

  if ( dig )
    result[pos++] = digits[dig];
/*
  if ( pos == 0 )
	result[pos++] = '0';
*/
  result[pos] = 0;

  index = 0;
  do
  {
	string[index++] = result[--pos];
  } while( pos );

  string[index] = 0;

  return string;
}

char *_ltoa( unsigned long value, char *string, unsigned long radix )
{
  char result[265];
  int  pos;
  int  index;
  long dig;

  pos = 0;

  do
  {
    dig = value % radix;
	//if ( dig )
      result[pos++] = digits[dig];
    value -= dig;

    dig = value / radix;
	value = dig;
  } while ( dig >= (int)radix );

  if ( dig )
    result[pos++] = digits[dig];
/*
  if ( pos == 0 )
	result[pos++] = '0';
*/
  result[pos] = 0;

  index = 0;
  do
  {
	string[index++] = result[--pos];
  } while( pos );

  string[index] = 0;

  return string;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dxr2\vpestrm.h ===
/******************************************************************************\
*                                                                              *
*      VPESTRM.H      -     Hardware abstraction level library.                *
*                                                                              *
*      Copyright (c) C-Cube Microsystems 1996                                  *
*      All Rights Reserved.                                                    *
*                                                                              *
*      Use of C-Cube Microsystems code is governed by terms and conditions     *
*      stated in the accompanying licensing statement.                         *
*                                                                              *
\******************************************************************************/

#ifndef _VPESTRM_H_
#define _VPESTRM_H_




VOID STREAMAPI VpeReceiveDataPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID STREAMAPI VpeReceiveCtrlPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
NTSTATUS STREAMAPI CycEvent( PHW_EVENT_DESCRIPTOR pEvent );

void GetVpeProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb );
void SetVpeProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb );
void ProcessVideoFormat( PKSDATAFORMAT pfmt, PHW_DEVICE_EXTENSION pHwDevExt );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dxr2\zivaguid.h ===
/******************************************************************************\
*                                                                              *
*      ZIVAGUID.H       -     .													*
*                                                                              *
*      Copyright (c) C-Cube Microsystems 1996                                  *
*      All Rights Reserved.                                                    *
*                                                                              *
*      Use of C-Cube Microsystems code is governed by terms and conditions     *
*      stated in the accompanying licensing statement.                         *
*                                                                              *
\******************************************************************************/
/*
    ZIVAGUID.H

    This module contains definitions for the stream types
    that this mini driver supports.
    This information is used by the Enumerate Stream types routine.

*/

#ifndef _ZIVAGUID_H_
#define _ZIVAGUID_H_

#include <ksmedia.h>
#include <wingdi.h>

#define IsEqualGUID2(guid1, guid2) \
	(!memcmp((guid1), (guid2), sizeof(GUID)))



#if defined(ENCORE)
#include "AvInt.h"
#include "AvKsProp.h"
#else
KSPIN_MEDIUM VPMedium = {
	STATIC_KSMEDIUMSETID_VPBus,
	0,
	0
};
#endif



//-------------------------------------------------------------------
// ZiVA STREAM TYPE FORMATS
//-------------------------------------------------------------------
KSDATAFORMAT ZivaFormatDVDVideo =
{
    sizeof (KSDATAFORMAT),
    0,
    0,
    0,
    STATIC_KSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK,
	STATIC_KSDATAFORMAT_SUBTYPE_MPEG2_VIDEO,
    STATIC_KSDATAFORMAT_SPECIFIER_MPEG2_VIDEO
    
};

KSDATAFORMAT ZivaFormatMpeg2PACKVideo = 
{
    sizeof (KSDATAFORMAT),
    0,
    0,
    0,
	STATIC_KSDATAFORMAT_TYPE_STANDARD_PACK_HEADER,
    STATIC_KSDATAFORMAT_SUBTYPE_MPEG2_VIDEO,
    STATIC_KSDATAFORMAT_SPECIFIER_MPEG2_VIDEO
    
};


//
// define our time event structure
//
typedef struct _MYTIME
{
	KSEVENT_TIME_INTERVAL tim;
	LONGLONG LastTime;
} MYTIME, *PMYTIME;

//
// define the events associated with the master clock
//
KSEVENT_ITEM ClockEventItm[] =
{
	{
		KSEVENT_CLOCK_POSITION_MARK,		// position mark event supported
		sizeof( KSEVENT_TIME_MARK ),		// requires this data as input
		sizeof( KSEVENT_TIME_MARK ),		// allocate space to copy the data
		NULL,
		NULL,
		NULL
	},
	{
		KSEVENT_CLOCK_INTERVAL_MARK,		// interval mark event supported
		sizeof( KSEVENT_TIME_INTERVAL ),	// requires interval data as input
		sizeof( MYTIME ),					// we use an additional workspace of
											// size longlong for processing this event
		NULL,
		NULL,
		NULL
	}
};

KSEVENT_SET ClockEventSet[] =
{
	{
		&KSEVENTSETID_Clock,
		SIZEOF_ARRAY(ClockEventItm),
		ClockEventItm,
	}
};

#ifndef ENCORE
KSEVENT_ITEM VPEventItm[] =
{
	{
		KSEVENT_VPNOTIFY_FORMATCHANGE,
		0,
		0,
		NULL,
		NULL,
		NULL
	}
};

GUID MY_KSEVENTSETID_VPNOTIFY = { STATIC_KSEVENTSETID_VPNotify };

KSEVENT_SET VPEventSet[] =
{
	{
		&MY_KSEVENTSETID_VPNOTIFY,
		SIZEOF_ARRAY( VPEventItm ),
		VPEventItm,
	}
};
#endif

KSDATAFORMAT ZivaFormatAC3Audio =
{
	sizeof( KSDATAFORMAT ),
	0,
	0,
	0,
	STATIC_KSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK,
	STATIC_KSDATAFORMAT_SUBTYPE_AC3_AUDIO,
	STATIC_KSDATAFORMAT_SPECIFIER_WAVEFORMATEX
};
KSDATAFORMAT ZivaFormatAC3Audio2 = {
    sizeof (KSDATAFORMAT),
    0,
    0,
    0,
    STATIC_KSDATAFORMAT_TYPE_STANDARD_PACK_HEADER,
    STATIC_KSDATAFORMAT_SUBTYPE_AC3_AUDIO,
    STATIC_KSDATAFORMAT_SPECIFIER_WAVEFORMATEX
	};



KSDATAFORMAT ZivaFormatPCMAudio =
{
	sizeof( KSDATAFORMAT ),
	0,
	0,
	0,
	STATIC_KSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK,
	STATIC_KSDATAFORMAT_SUBTYPE_LPCM_AUDIO,
	STATIC_KSDATAFORMAT_SPECIFIER_WAVEFORMATEX
};

KSDATAFORMAT ZivaFormatSubPicture =
{
	sizeof( KSDATAFORMAT ),
	0,
	0,
	0,
	STATIC_KSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK,
	STATIC_KSDATAFORMAT_SUBTYPE_SUBPICTURE,
	STATIC_GUID_NULL
};


#ifdef ENCORE
#define DefWidth     720
#define DefHeight    480
KS_DATARANGE_VIDEO2 ZivaFormatAnalogOverlayOutDataRange =
{
	// KSDATARANGE
	{   
		sizeof( KS_DATARANGE_VIDEO2 ),			// FormatSize
		0,										// Flags
		0,										// SampleSize
		0,										// Reserved

		STATIC_KSDATAFORMAT_TYPE_VIDEO,			// aka. MEDIATYPE_Video
		STATIC_KSDATAFORMAT_SUBTYPE_OVERLAY,
		STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO2// aka. FORMAT_VideoInfo2
	},

	TRUE,				// BOOL,  bFixedSizeSamples (all samples same size?)
	TRUE,				// BOOL,  bTemporalCompression (all I frames?)
	0,					// Reserved (was StreamDescriptionFlags)
	0,					// Reserved (was MemoryAllocationFlags   (KS_VIDEO_ALLOC_*))

    // _KS_VIDEO_STREAM_CONFIG_CAPS  
    {
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO2, // GUID
        KS_AnalogVideo_NTSC_M |
        KS_AnalogVideo_PAL_B,                    // AnalogVideoStandard
        720,480,        // InputSize, (the inherent size of the incoming signal
	                //             with every digitized pixel unique)
        720,480,        // MinCroppingSize, smallest rcSrc cropping rect allowed
        720,480,        // MaxCroppingSize, largest  rcSrc cropping rect allowed
        8,              // CropGranularityX, granularity of cropping size
        1,              // CropGranularityY
        8,              // CropAlignX, alignment of cropping rect 
        1,              // CropAlignY;
        720, 480,       // MinOutputSize, smallest bitmap stream can produce
        720, 480,       // MaxOutputSize, largest  bitmap stream can produce
        8,              // OutputGranularityX, granularity of output bitmap size
        1,              // OutputGranularityY;
        0,              // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,              // StretchTapsY
        0,              // ShrinkTapsX 
        0,              // ShrinkTapsY 
        333667,         // MinFrameInterval, 100 nS units
        640000000,      // MaxFrameInterval, 100 nS units
        8 * 3 * 30 * 160 * 120,  // MinBitsPerSecond;
        8 * 3 * 30 * 720 * 480   // MaxBitsPerSecond;
    }, 

	//------- KS_VIDEOINFOHEADER2
	{
		{ 0,0,0,0 },    //    RECT            rcSource;          // The bit we really want to use
		{ 0,0,0,0 },    //    RECT            rcTarget;          // Where the video should go
		DefWidth * DefHeight * 2 * 30L,  //    DWORD     dwBitRate;         // Approximate bit data rate
		0L,                       // DWORD           dwBitErrorRate;    // Bit error rate for this stream
		333667,                   // REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)

		0,                        // DWORD dwInterlaceFlags;   // use AMINTERLACE_* defines. Reject connection if undefined bits are not 0
		0,                        // DWORD dwCopyProtectFlags; // use AMCOPYPROTECT_* defines. Reject connection if undefined bits are not 0
		4,                        // DWORD dwPictAspectRatioX; // X dimension of picture aspect ratio, e.g. 16 for 16x9 display
		3,                        // DWORD dwPictAspectRatioY; // Y dimension of picture aspect ratio, e.g.  9 for 16x9 display
		0,                        // DWORD dwReserved1;        // must be 0; reject connection otherwise
		0,                        // DWORD dwReserved2;        // must be 0; reject connection otherwise

		//---------- KS_BITMAPINFOHEADER
		{
			sizeof( KS_BITMAPINFOHEADER ), //    DWORD      biSize;
			DefWidth,                   //    LONG       biWidth;
			DefHeight,                  //    LONG       biHeight;
			1,                          //    WORD       biPlanes;
			16,                         //    WORD       biBitCount;
			DDPF_FOURCC,                //    DWORD      biCompression;
			0/*DefWidth * DefHeight * 2*/,   //    DWORD      biSizeImage;
			0,                          //    LONG       biXPelsPerMeter;
			0,                          //    LONG       biYPelsPerMeter;
			0,                          //    DWORD      biClrUsed;
			0                           //    DWORD      biClrImportant;
		}
	}
}; 

KS_DATAFORMAT_VIDEOINFOHEADER2 ZivaFormatAnalogOverlayOut =
{
	//------- KSDATAFORMAT
	{
		sizeof( KS_DATAFORMAT_VIDEOINFOHEADER2 ),
		0,
		DefWidth * DefHeight * 2,
		0,
		STATIC_KSDATAFORMAT_TYPE_VIDEO,
		STATIC_KSDATAFORMAT_SUBTYPE_OVERLAY,
		STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO2
	},

	//------- KS_VIDEOINFOHEADER2
	{
		{ 0,0,0,0 },    //    RECT            rcSource;          // The bit we really want to use
		{ 0,0,0,0 },    //    RECT            rcTarget;          // Where the video should go
		DefWidth * DefHeight * 2 * 30L,  //    DWORD     dwBitRate;         // Approximate bit data rate
		0L,                       // DWORD           dwBitErrorRate;    // Bit error rate for this stream
		333667,                   // REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)

		0,                        // DWORD dwInterlaceFlags;   // use AMINTERLACE_* defines. Reject connection if undefined bits are not 0
		0,                        // DWORD dwCopyProtectFlags; // use AMCOPYPROTECT_* defines. Reject connection if undefined bits are not 0
		4,                        // DWORD dwPictAspectRatioX; // X dimension of picture aspect ratio, e.g. 16 for 16x9 display
		3,                        // DWORD dwPictAspectRatioY; // Y dimension of picture aspect ratio, e.g.  9 for 16x9 display
		0,                        // DWORD dwReserved1;        // must be 0; reject connection otherwise
		0,                        // DWORD dwReserved2;        // must be 0; reject connection otherwise

		//---------- KS_BITMAPINFOHEADER
		{
			sizeof( KS_BITMAPINFOHEADER ), //    DWORD      biSize;
			DefWidth,                   //    LONG       biWidth;
			DefHeight,                  //    LONG       biHeight;
			1,                          //    WORD       biPlanes;
			16,                         //    WORD       biBitCount;
			DDPF_FOURCC,                //    DWORD      biCompression;
			0/*DefWidth * DefHeight * 2*/,   //    DWORD      biSizeImage;
			0,                          //    LONG       biXPelsPerMeter;
			0,                          //    LONG       biYPelsPerMeter;
			0,                          //    DWORD      biClrUsed;
			0                           //    DWORD      biClrImportant;
		}
	}
};
#endif			// #ifdef ENCORE
KSDATAFORMAT ZivaFormatVPEOut =
{
	sizeof( KSDATAFORMAT ),
	0,
	0,
	0,
	STATIC_KSDATAFORMAT_TYPE_VIDEO,
	STATIC_KSDATAFORMAT_SUBTYPE_VPVideo,
	STATIC_KSDATAFORMAT_SPECIFIER_NONE
};
//#endif			// #ifdef ENCORE


KSDATAFORMAT hwfmtiCCOut
    = {
	sizeof(KSDATAFORMAT),
    0,
	200,
	0,
    STATIC_KSDATAFORMAT_TYPE_AUXLine21Data,
	STATIC_KSDATAFORMAT_SUBTYPE_Line21_GOPPacket,
//	STATIC_KSDATAFORMAT_SUBTYPE_Line21_BytePair,
//    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO
    STATIC_KSDATAFORMAT_SPECIFIER_NONE
    };

PKSDATAFORMAT CCInfo[] = {   // CC output formats array
    &hwfmtiCCOut
};

#define NUM_CC_OUT_FORMATS	(SIZEOF_ARRAY( CCInfo ))
//-------------------------------------------------------------------
// ZiVA STREAM FORMAT ARRAYS
//-------------------------------------------------------------------

//------- Video In
PKSDATAFORMAT ZivaVideoInFormatArray[] =
{
	&ZivaFormatDVDVideo,
	&ZivaFormatMpeg2PACKVideo
};
#define NUM_VIDEO_IN_FORMATS (SIZEOF_ARRAY( ZivaVideoInFormatArray ))

//------- Audio In
PKSDATAFORMAT ZivaAudioInFormatArray[] =
{
	&ZivaFormatAC3Audio,
	&ZivaFormatAC3Audio2,
	&ZivaFormatPCMAudio
	//&ZivaFormatMpegAudio
};
#define NUM_AUDIO_IN_FORMATS (SIZEOF_ARRAY( ZivaAudioInFormatArray ))

//------- Subpicture In
PKSDATAFORMAT ZivaSubPictureInFormatArray[] =
{
	&ZivaFormatSubPicture
};
#define NUM_SUBPICTURE_IN_FORMATS (SIZEOF_ARRAY( ZivaSubPictureInFormatArray ))
//------- Video Out
PKSDATAFORMAT ZivaVideoOutFormatArray[] =
{
#ifdef ENCORE
	(PKSDATAFORMAT)&ZivaFormatAnalogOverlayOutDataRange
#else			// #ifdef ENCORE
	(PKSDATAFORMAT)&ZivaFormatVPEOut
#endif			// #ifdef ENCORE
};
#define NUM_VIDEO_OUT_FORMATS (SIZEOF_ARRAY( ZivaVideoOutFormatArray ))


//-------------------------------------------------------------------
// ZiVA STREAM PROPERTY ITEMS
//-------------------------------------------------------------------
static const KSPROPERTY_ITEM mpegVidPropItm[] =
{
	{
		KSPROPERTY_DVDSUBPIC_PALETTE,		// subpicture palette property
		FALSE,								// get palette not supported
		sizeof( KSPROPERTY ),
		sizeof( KSPROPERTY_SPPAL ),			// minimum size of data requested
		(PFNKSHANDLER)FALSE,				// set palette is not supported
		NULL,
		0,
		NULL,
		NULL,
		0
	}
};

//
// define the subpicture property items supported
//
static const KSPROPERTY_ITEM spPropItm[] =
{
	{
		KSPROPERTY_DVDSUBPIC_PALETTE,		// subpicture palette property
		FALSE,								// get palette not supported
		sizeof( KSPROPERTY ),
		sizeof( KSPROPERTY_SPPAL ),			// minimum size of data requested
		(PFNKSHANDLER)TRUE,					// set palette is supported
		NULL,
		0,
		NULL,
		NULL,
		0
	},

	{
		KSPROPERTY_DVDSUBPIC_HLI,			// subpicture highlight property
		FALSE,								// get highlight is not supported
		sizeof( KSPROPERTY ),
		sizeof( KSPROPERTY_SPHLI ),			// minimum size of data requested
		(PFNKSHANDLER)TRUE,					// set highlight is supported
		NULL,
		0,
		NULL,
		NULL,
		0
	},

	{
		KSPROPERTY_DVDSUBPIC_COMPOSIT_ON,	// subpicture enable status property
		FALSE,								// get enable status not supported
		sizeof( KSPROPERTY ),
		sizeof( KSPROPERTY_COMPOSIT_ON ),	// minimum size of data requested
		(PFNKSHANDLER)TRUE,					// set enable status is supported
		NULL,
		0,
		NULL,
		NULL,
		0
	}
};

static const KSPROPERTY_ITEM audPropItm[] =
{
	{
		KSPROPERTY_AUDDECOUT_MODES,			// available audio decoder output formats property
		(PFNKSHANDLER)TRUE,					// get available modes is supported
		sizeof( KSPROPERTY ),
		sizeof( ULONG ),					// minimum size of data requested
		(PFNKSHANDLER)FALSE,				// set available modes is not supported
		NULL,
		0,
		NULL,
		NULL,
		0
	},

	{
		KSPROPERTY_AUDDECOUT_CUR_MODE,		// current audio decoder output format property
		(PFNKSHANDLER) TRUE,				// get current mode is supported
		sizeof( KSPROPERTY ),
		sizeof( ULONG ),					// minimum size of data requested
		(PFNKSHANDLER)TRUE,					// set current modes is supported
		NULL,
		0,
		NULL,
		NULL,
		0
	}
};

//
// define the copy protection property support
//
static const KSPROPERTY_ITEM psMacrovision[] =
{
	{
		KSPROPERTY_COPY_MACROVISION,		// support for setting macrovision level
		(PFNKSHANDLER)FALSE,				// get not supported
		sizeof( KSPROPERTY ),
		sizeof( KS_COPY_MACROVISION ),
		(PFNKSHANDLER)TRUE,					// set MACROVISION level supported
		NULL,
		0,
		NULL,
		NULL,
		0
	}
};

static const KSPROPERTY_ITEM CopyProtPropItm[] =
{
	{
		KSPROPERTY_DVDCOPY_CHLG_KEY,		// DVD authentication challenge key
		(PFNKSHANDLER)TRUE,					// get property on challenge key requests the
											// decoder to provide it's challenge key
		sizeof( KSPROPERTY ),
		sizeof( KS_DVDCOPY_CHLGKEY ),		// minimum size of data requested
		(PFNKSHANDLER)TRUE,					// set palette is supported
		NULL,
		0,
		NULL,
		NULL,
		0
	},

	{
		KSPROPERTY_DVDCOPY_DVD_KEY1,		// DVD authentication DVD drive key property
		FALSE,								// get Key not supported
		sizeof( KSPROPERTY ),
		sizeof( KS_DVDCOPY_BUSKEY ),		// minimum size of data requested
		(PFNKSHANDLER)TRUE,					// set key provides the key for the decoder
		NULL,
		0,
		NULL,
		NULL,
		0
	},

	{
		KSPROPERTY_DVDCOPY_DEC_KEY2,		// DVD authentication DVD decoder key property
		(PFNKSHANDLER)TRUE,					// get Key requests the decoder key, in
											// response to a previous set challenge key
		sizeof( KSPROPERTY ),
		sizeof( KS_DVDCOPY_BUSKEY ),		// minimum size of data requested
		(PFNKSHANDLER)FALSE,				// set key is not valid
		NULL,
		0,
		NULL,
		NULL,
		0
	},

	{
		KSPROPERTY_DVDCOPY_REGION,			// DVD region request the minidriver shall
											// fit in exactly one region bit, corresponding
											// to the region that the decoder is currently in
		(PFNKSHANDLER)TRUE,
		sizeof( KSPROPERTY ),
		sizeof( KS_DVDCOPY_REGION ),		// minimum size of data requested
		(PFNKSHANDLER)FALSE,				// set key is not valid
		NULL,
		0,
		NULL,
		NULL,
		0
	},

	{
		KSPROPERTY_DVDCOPY_TITLE_KEY,		// DVD authentication DVD title key property
		FALSE,								// get Key not supported
		sizeof( KSPROPERTY ),
		sizeof( KS_DVDCOPY_TITLEKEY ),		// minimum size of data requested
		(PFNKSHANDLER)TRUE,					// set key provides the key for the decoder
		NULL,
		0,
		NULL,
		NULL,
		0
	},

	{
		KSPROPERTY_DVDCOPY_DISC_KEY,		// DVD authentication DVD disc key property
		FALSE,								// get Key not supported
		sizeof( KSPROPERTY ),
		sizeof( KS_DVDCOPY_DISCKEY ),		// minimum size of data requested
		(PFNKSHANDLER)TRUE,					// set key provides the key for the decoder
		NULL,
		0,
		NULL,
		NULL,
		0
	},

	{
		KSPROPERTY_DVDCOPY_SET_COPY_STATE,	// DVD authentication DVD disc key property
		(PFNKSHANDLER)TRUE,					// get Key not supported
		sizeof( KSPROPERTY ),
		sizeof( KS_DVDCOPY_SET_COPY_STATE ),// minimum size of data requested
		(PFNKSHANDLER)TRUE,					// set key provides the key for the decoder
		NULL,
		0,
		NULL,
		NULL,
		0
	}
#if 0
#ifdef DECODER_DVDPC
	,
	{
		KSPROPERTY_COPY_MACROVISION,		// support for setting macrovision level
		(PFNKSHANDLER)FALSE,				// get not supported
		sizeof( KSPROPERTY ),
		sizeof( KS_COPY_MACROVISION ),
		(PFNKSHANDLER)TRUE,					// set MACROVISION level supported
		NULL,
		0,
		NULL,
		NULL,
		0
	}
#endif	
#endif
};


// ------------------------------------------------------------------------
// Array of all of the property sets supported by video streams
// ------------------------------------------------------------------------
#ifdef ENCORE
DEFINE_KSPROPERTY_TABLE( psOverlayUpdate )
{
	DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_INTERESTS( (PFNKSHANDLER)TRUE ),
    DEFINE_KSPROPERTY_ITEM
	(
		KSPROPERTY_OVERLAYUPDATE_COLORKEY,
        (PFNKSHANDLER)TRUE,
        sizeof( KSPROPERTY ),
        sizeof( COLORKEY ),
        (PFNKSHANDLER)TRUE,
        NULL, 0, NULL, NULL, 0
	),
	DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_VIDEOPOSITION( (PFNKSHANDLER)TRUE ),
	DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_DISPLAYCHANGE( (PFNKSHANDLER)TRUE ),
	DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_COLORREF( (PFNKSHANDLER)TRUE )
};

DEFINE_KSPROPERTY_SET_TABLE( VideoOutPropSet )
{
	DEFINE_KSPROPERTY_SET
	(
		&KSPROPSETID_OverlayUpdate,
		SIZEOF_ARRAY( psOverlayUpdate ),
		psOverlayUpdate,
		0,
		NULL
	)
};
#else
static const KSPROPERTY_ITEM VideoPortPropItm[] =
{
	{
		KSPROPERTY_VPCONFIG_NUMCONNECTINFO,
		(PFNKSHANDLER) TRUE,
		sizeof(KSPROPERTY),
		sizeof(ULONG),
		(PFNKSHANDLER) FALSE,
		NULL,
		0,
		NULL,
		NULL,
		0
	},

	{
		KSPROPERTY_VPCONFIG_NUMVIDEOFORMAT,
		(PFNKSHANDLER) TRUE,
		sizeof(KSPROPERTY),
		sizeof(ULONG),
		(PFNKSHANDLER) FALSE,
		NULL,
		0,
		NULL,
		NULL,
		0
	},

	{
		KSPROPERTY_VPCONFIG_GETCONNECTINFO,
		(PFNKSHANDLER) TRUE,
		sizeof (KSMULTIPLE_DATA_PROP),  // minimum property input size
		sizeof (ULONG),
		(PFNKSHANDLER)FALSE,
		NULL,
		0,
		NULL,
		NULL,
		0
	},

	{
		KSPROPERTY_VPCONFIG_SETCONNECTINFO,
		(PFNKSHANDLER) FALSE,
		sizeof (KSPROPERTY),  			// minimum property input size
		sizeof (ULONG),    				// minimum buffer size
		(PFNKSHANDLER)TRUE,
		NULL,
		0,
		NULL,
		NULL,
		0
	},

	{
		KSPROPERTY_VPCONFIG_VPDATAINFO,
		(PFNKSHANDLER) TRUE,
		sizeof (KSPROPERTY),
		sizeof (KS_AMVPDATAINFO),
		(PFNKSHANDLER)FALSE,
		NULL,
		0,
		NULL,
		NULL,
		0
	},

	{
		KSPROPERTY_VPCONFIG_MAXPIXELRATE,
		(PFNKSHANDLER) TRUE,
		sizeof (KSVPSIZE_PROP),
		sizeof (KSVPMAXPIXELRATE),
		(PFNKSHANDLER)FALSE,
		NULL,
		0,
		NULL,
		NULL,
		0
	},

	{
		KSPROPERTY_VPCONFIG_INFORMVPINPUT,
		(PFNKSHANDLER) TRUE,
		sizeof (PKSPROPERTY),
		sizeof (DDPIXELFORMAT),    // could be 0 too
		(PFNKSHANDLER)FALSE,
		NULL,
		0,
		NULL,
		NULL,
		0
	},

	{
		KSPROPERTY_VPCONFIG_DDRAWHANDLE,
		(PFNKSHANDLER)FALSE,
		sizeof (PKSPROPERTY),
		sizeof (ULONG),    // could be 0 too
		(PFNKSHANDLER) TRUE,
		NULL,
		0,
		NULL,
		NULL,
		0
	},

	{
		KSPROPERTY_VPCONFIG_VIDEOPORTID,
		(PFNKSHANDLER)FALSE,
		sizeof (PKSPROPERTY),
		sizeof (ULONG),    // could be 0 too
		(PFNKSHANDLER) TRUE,
		NULL,
		0,
		NULL,
		NULL,
		0
	},

	{
		KSPROPERTY_VPCONFIG_DDRAWSURFACEHANDLE,
		(PFNKSHANDLER)FALSE,
		sizeof (PKSPROPERTY),
		sizeof (ULONG),    // could be 0 too
		(PFNKSHANDLER) TRUE,
		NULL,
		0,
		NULL,
		NULL,
		0
	},

	{
		KSPROPERTY_VPCONFIG_GETVIDEOFORMAT,
		(PFNKSHANDLER) TRUE,
		sizeof (KSMULTIPLE_DATA_PROP), 		// for _GET; KSPROPERTY for _SET
		sizeof (ULONG),        		// could be 4 or more
		(PFNKSHANDLER)FALSE,
		NULL,
		0,
		NULL,
		NULL,
		0
	},

	{
		KSPROPERTY_VPCONFIG_SETVIDEOFORMAT,
		(PFNKSHANDLER) FALSE,
		sizeof (KSPROPERTY),  			// minimum property input size
		sizeof (ULONG),    				// minimum buffer size
		(PFNKSHANDLER)TRUE,
		NULL,
		0,
		NULL,
		NULL,
		0
	},

	{
		KSPROPERTY_VPCONFIG_INVERTPOLARITY,
		(PFNKSHANDLER)TRUE,
		sizeof (KSPROPERTY),
		0,
		(PFNKSHANDLER)FALSE,
		NULL,
		0,
		NULL,
		NULL,
		0
	},

	{
		KSPROPERTY_VPCONFIG_DECIMATIONCAPABILITY,
		(PFNKSHANDLER)TRUE,
		sizeof(KSPROPERTY),
		//sizeof (KSVPCONTEXT_PROP),
		sizeof (BOOL),
		(PFNKSHANDLER)FALSE,
		NULL,
		0,
		NULL,
		NULL,
		0
	},

	{
		KSPROPERTY_VPCONFIG_SCALEFACTOR,
		(PFNKSHANDLER)TRUE,
		sizeof (KSPROPERTY),
		sizeof (KS_AMVPSIZE),
		(PFNKSHANDLER)FALSE,
		NULL,
		0,
		NULL,
		NULL,
		0
	}
};
GUID vpePropSetid = {STATIC_KSPROPSETID_VPConfig};
static KSPROPERTY_SET VideoPortPropSet[] =
{
    &vpePropSetid,
    SIZEOF_ARRAY(VideoPortPropItm),
    (PKSPROPERTY_ITEM) VideoPortPropItm
};
#endif			// #ifdef ENCORE

#define NUM_VIDEO_OUT_PROPERTY_ITEMS (SIZEOF_ARRAY (VideoOutPropSet))

// Rate Change

static const KSPROPERTY_ITEM RateChangePropItm[] =
{
	{
		KS_AM_RATE_SimpleRateChange,
		(PFNKSHANDLER) TRUE,
		sizeof (KSPROPERTY),
		sizeof (KS_AM_SimpleRateChange),
		(PFNKSHANDLER) TRUE,
		NULL,
		0,
		NULL,
		NULL,
		0,
	},

	{
		KS_AM_RATE_ExactRateChange,
		(PFNKSHANDLER) FALSE,
		sizeof (KSPROPERTY),
		sizeof (KS_AM_ExactRateChange),
		(PFNKSHANDLER) FALSE,
		NULL,
		0,
		NULL,
		NULL,
		0,
	},

	{
		KS_AM_RATE_MaxFullDataRate,
		(PFNKSHANDLER) TRUE,
		sizeof (KSPROPERTY),
		sizeof (KS_AM_MaxFullDataRate),
		(PFNKSHANDLER) FALSE,
		NULL,
		0,
		NULL,
		NULL,
		0,
	},

	{
		KS_AM_RATE_Step,
		(PFNKSHANDLER) FALSE,
		sizeof (KSPROPERTY),
		sizeof (KS_AM_Step),
		(PFNKSHANDLER) TRUE,
		NULL,
		0,
		NULL,
		NULL,
		0,
	}
};



//
// define the array of video property sets supported
//


DEFINE_KSPROPERTY_SET_TABLE( mpegVidPropSet )
{
	DEFINE_KSPROPERTY_SET
	(
		&KSPROPSETID_Mpeg2Vid,
		SIZEOF_ARRAY(mpegVidPropItm),
		(PKSPROPERTY_ITEM)mpegVidPropItm,
		0,
		NULL
	),
	DEFINE_KSPROPERTY_SET
	(
		&KSPROPSETID_CopyProt,
		SIZEOF_ARRAY(CopyProtPropItm),
		(PKSPROPERTY_ITEM)CopyProtPropItm,
		0,
		NULL
	),
	DEFINE_KSPROPERTY_SET
	(
		&KSPROPSETID_TSRateChange,
		SIZEOF_ARRAY(RateChangePropItm),
		(PKSPROPERTY_ITEM)RateChangePropItm,
		0,
		NULL
	)
};

#define NUM_VIDEO_IN_PROPERTY_ITEMS (SIZEOF_ARRAY (mpegVidPropSet))

//
// define the array of audio property sets supported
//

DEFINE_KSPROPERTY_SET_TABLE( audPropSet )
{
	DEFINE_KSPROPERTY_SET
	(
		&KSPROPSETID_AudioDecoderOut,
		SIZEOF_ARRAY(audPropItm),
		(PKSPROPERTY_ITEM)audPropItm,
		0,
		NULL
	),
	DEFINE_KSPROPERTY_SET
	(
		&KSPROPSETID_CopyProt,
		SIZEOF_ARRAY(CopyProtPropItm),
		(PKSPROPERTY_ITEM)CopyProtPropItm,
		0,
		NULL
	),
	DEFINE_KSPROPERTY_SET
	(
		&KSPROPSETID_TSRateChange,
		SIZEOF_ARRAY(RateChangePropItm),
		(PKSPROPERTY_ITEM)RateChangePropItm,
		0,
		NULL
	),
};

#define NUM_AUDIO_IN_PROPERTY_ITEMS (SIZEOF_ARRAY (audPropSet))

//
// define the array of subpicture property sets supported
//

DEFINE_KSPROPERTY_SET_TABLE( SPPropSet )
{
	DEFINE_KSPROPERTY_SET
	(
		&KSPROPSETID_DvdSubPic,
		SIZEOF_ARRAY(spPropItm),
		(PKSPROPERTY_ITEM)spPropItm,
		0,
		NULL
	),
	DEFINE_KSPROPERTY_SET
	(
		&KSPROPSETID_CopyProt,
		SIZEOF_ARRAY(CopyProtPropItm),
		(PKSPROPERTY_ITEM)CopyProtPropItm,
		0,
		NULL
	),
	DEFINE_KSPROPERTY_SET
	(
		&KSPROPSETID_TSRateChange,
		SIZEOF_ARRAY(RateChangePropItm),
		(PKSPROPERTY_ITEM)RateChangePropItm,
		0,
		NULL
	),
};

#define NUM_SUBPICTURE_IN_PROPERTY_ITEMS (SIZEOF_ARRAY (SPPropSet))


#ifdef ENCORE
DEFINE_AV_PROPITEM_RANGE_STEP( ColorBrightness, 15, 0, 255, 128 )
DEFINE_AV_PROPITEM_RANGE_STEP( ColorContrast, 1, 0, 31, 15 )
DEFINE_AV_PROPITEM_RANGE_STEP( ColorSaturation, 1, 0, 31, 15 )
DEFINE_AV_PROPITEM_RANGE_STEP( ColorSolarization, 8, 0, 128, 0 )
DEFINE_AV_PROPITEM_RANGE_STEP( ColorSharpness, 1, 0, 1, 0 )
DEFINE_AV_PROPITEM_RANGE_STEP( ColorGamma, 64, 256, 4096, 1024 )
DEFINE_KSPROPERTY_TABLE( psVideoProcAmp )
{
	ADD_AV_PROPITEM_RANGE_U( ColorBrightness,	KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS ),
	ADD_AV_PROPITEM_RANGE_U( ColorContrast,		KSPROPERTY_VIDEOPROCAMP_CONTRAST ),
	ADD_AV_PROPITEM_RANGE_U( ColorSaturation,	KSPROPERTY_VIDEOPROCAMP_SATURATION ),
	ADD_AV_PROPITEM_RANGE_U( ColorSharpness,	KSPROPERTY_VIDEOPROCAMP_SHARPNESS ),
	ADD_AV_PROPITEM_RANGE_U( ColorGamma,		KSPROPERTY_VIDEOPROCAMP_GAMMA ),
	ADD_AV_PROPITEM_RANGE_U( ColorSolarization,	KSPROPERTY_VIDEOPROCAMP_BACKLIGHT_COMPENSATION )
};

DEFINE_AV_PROPITEM_RANGE( AlignXPosition,	0,		1023,	170 )
DEFINE_AV_PROPITEM_RANGE( AlignYPosition,	0,		1023,	36 )
DEFINE_AV_PROPITEM_RANGE( AlignInputDelay,	-15,	16,		5 )
DEFINE_AV_PROPITEM_RANGE( AlignWidthRatio,	1,		4000,	456 )
DEFINE_AV_PROPITEM_RANGE( AlignClockDelay,	0,		3,		3 )
DEFINE_AV_PROPITEM_RANGE( AlignCropLeft,	0,		1023,	20 )
DEFINE_AV_PROPITEM_RANGE( AlignCropTop,		0,		1023,	100 )
DEFINE_AV_PROPITEM_RANGE( AlignCropRight,	0,		1023,	20 )
DEFINE_AV_PROPITEM_RANGE( AlignCropBottom,	0,		1023,	40 )
DEFINE_AV_KSPROPERTY_TABLE( psAlign )
{
	ADD_AV_PROPITEM_RANGE_U( AlignXPosition,	AVKSPROPERTY_ALIGN_XPOSITION ),
	ADD_AV_PROPITEM_RANGE_U( AlignYPosition,	AVKSPROPERTY_ALIGN_YPOSITION ),
	ADD_AV_PROPITEM_RANGE_U( AlignInputDelay,	AVKSPROPERTY_ALIGN_INPUTDELAY ),
	ADD_AV_PROPITEM_RANGE_U( AlignWidthRatio,	AVKSPROPERTY_ALIGN_WIDTHRATIO ),
	ADD_AV_PROPITEM_RANGE_U( AlignClockDelay,	AVKSPROPERTY_ALIGN_CLOCKDELAY ),
	ADD_AV_PROPITEM_RANGE_U( AlignCropLeft,		AVKSPROPERTY_ALIGN_CROPLEFT ),
	ADD_AV_PROPITEM_RANGE_U( AlignCropTop,		AVKSPROPERTY_ALIGN_CROPTOP ),
	ADD_AV_PROPITEM_RANGE_U( AlignCropRight,	AVKSPROPERTY_ALIGN_CROPRIGHT ),
	ADD_AV_PROPITEM_RANGE_U( AlignCropBottom,	AVKSPROPERTY_ALIGN_CROPBOTTOM ),
//	ADD_AV_PROPITEM( AVKSPROPERTY_ALIGN_AUTOALIGNENABLED )
};

DEFINE_AV_KSPROPERTY_TABLE( psKey )
{
	ADD_AV_PROPITEM( AVKSPROPERTY_KEY_MODE ),
	ADD_AV_PROPITEM_TYPE( AVKSPROPERTY_KEY_KEYCOLORS, AVKSPROPERTY_KEY )
};

DEFINE_AV_PROPITEM_RANGE( DoveAlphaMixing,	0, 63, 0 )
DEFINE_AV_PROPITEM_RANGE( DoveFadingTime,	1, 8, 4 )
DEFINE_AV_KSPROPERTY_TABLE( psDove )
{
	ADD_AV_PROPITEM_READ( AVKSPROPERTY_DOVE_VERSION ),
	ADD_AV_PROPITEM( AVKSPROPERTY_DOVE_DAC ),
	ADD_AV_PROPITEM_RANGE_U( DoveAlphaMixing,	AVKSPROPERTY_DOVE_ALPHAMIXING ),
	ADD_AV_PROPITEM_RANGE_U( DoveFadingTime,	AVKSPROPERTY_DOVE_FADINGTIME ),
	ADD_AV_PROPITEM_WRITE( AVKSPROPERTY_DOVE_FADEIN ),
	ADD_AV_PROPITEM_WRITE( AVKSPROPERTY_DOVE_FADEOUT ),
	ADD_AV_PROPITEM_WRITE( AVKSPROPERTY_DOVE_AUTO )
};

DEFINE_AV_PROPITEM_RANGE( MiscSkewRise, 0, 15, 2 )
DEFINE_AV_KSPROPERTY_TABLE( psMisc )
{
	ADD_AV_PROPITEM( AVKSPROPERTY_MISC_NEGATIVE ),
	ADD_AV_PROPITEM_RANGE_U( MiscSkewRise, AVKSPROPERTY_MISC_SKEWRISE ),
	ADD_AV_PROPITEM( AVKSPROPERTY_MISC_FILTER )
};


DEFINE_KSPROPERTY_TABLE( psPin )
{
	DEFINE_KSPROPERTY_ITEM_PIN_CINSTANCES( TRUE )
};


DEFINE_KSPROPERTY_SET_TABLE( psEncore )
{
	DEFINE_KSPROPERTY_SET
	(
		&PROPSETID_VIDCAP_VIDEOPROCAMP,
		SIZEOF_ARRAY( psVideoProcAmp ),
		psVideoProcAmp,
		0, 
		NULL
	),

	DEFINE_KSPROPERTY_SET
	(
		&KSPROPSETID_Pin,
		SIZEOF_ARRAY( psPin ),
		(PKSPROPERTY_ITEM)psPin,
		0,
		NULL
	),

	DEFINE_KSPROPERTY_SET
	(
		&KSPROPSETID_CopyProt,
		SIZEOF_ARRAY( psMacrovision ),
		(PKSPROPERTY_ITEM)psMacrovision,
		0,
		NULL
	),
	DEFINE_AV_KSPROPERTY_SET( AVKSPROPSETID_Align,	psAlign ),
	DEFINE_AV_KSPROPERTY_SET( AVKSPROPSETID_Key,	psKey ),
	DEFINE_AV_KSPROPERTY_SET( AVKSPROPSETID_Dove,	psDove ),
	DEFINE_AV_KSPROPERTY_SET( AVKSPROPSETID_Misc,	psMisc )
};
#endif				// #ifdef ENCORE


// CC

static /* const */ KSPROPERTY_ITEM CCPropItm[] = {
	{
		KSPROPERTY_CONNECTION_ALLOCATORFRAMING,	// support for setting CC buffer size
		(PFNKSHANDLER) TRUE, 					// get supported
		sizeof (KSPROPERTY),
		sizeof (KSALLOCATOR_FRAMING),
		(PFNKSHANDLER) FALSE,					// we only provide the allocator requirments
		NULL,
		0,
		NULL,
		NULL,
		0
	},
	{
		KSPROPERTY_CONNECTION_STATE,			// support for setting CC buffer size
		(PFNKSHANDLER) TRUE, 					// get supported
		sizeof (KSPROPERTY),
		sizeof (KSSTATE),
		(PFNKSHANDLER) FALSE,					// we only provide the allocator requirments
		NULL,
		0,
		NULL,
		NULL,
		0
	}
};

static /* const */ KSPROPERTY_SET CCPropSet[] = {
	&KSPROPSETID_Connection,
	SIZEOF_ARRAY(CCPropItm),
	(PKSPROPERTY_ITEM) CCPropItm
};


static const KSTOPOLOGY Topology =
{
	1,
	(GUID*)&KSCATEGORY_DATADECOMPRESSOR,
	0,
	NULL,
	0,
	NULL
};


typedef struct tagALL_STREAM_INFO {
	HW_STREAM_INFORMATION	hwStreamInfo;
	HW_STREAM_OBJECT		hwStreamObject;
} ALL_STREAM_INFO, *PALL_STREAM_INFO;

static ALL_STREAM_INFO infoStreams[] =
{
	{	// Input MPEG2 video stream
		{	// HW_STREAM_INFORMATION
			1,								// NumberOfPossibleInstances
			KSPIN_DATAFLOW_IN,				// DataFlow
			TRUE,							// DataAccessible
			NUM_VIDEO_IN_FORMATS,			// NumberOfFormatArrayEntries
			ZivaVideoInFormatArray,			// StreamFormatsArray
			0, 0, 0, 0,						// ClassReserved
			NUM_VIDEO_IN_PROPERTY_ITEMS,	// NumStreamPropArrayEntries
			(PKSPROPERTY_SET)mpegVidPropSet,// StreamPropertiesArray
			0,								// NumStreamEventArrayEntries;
			0,								// StreamEventsArray;
			(GUID*)&GUID_NULL,				// Category
			(GUID*)&GUID_NULL,				// Name
			0,								// MediumsCount
			NULL,							// Mediums
			FALSE							// BridgeStream
		},
		{	// HW_STREAM_OBJECT
			sizeof( HW_STREAM_OBJECT ),		// SizeOfThisPacket
			ZivaVideo,						// StreamNumber
			0,								// HwStreamExtension
			VideoReceiveDataPacket,			// HwReceiveDataPacket
			VideoReceiveCtrlPacket,			// HwReceiveControlPacket
			{ NULL, 0 },					// HW_CLOCK_OBJECT
#ifndef EZDVD
			TRUE,							// Dma
			TRUE,							// Pio
#else
			FALSE,							// Dma
			TRUE,							// Pio
#endif
			0,								// HwDeviceExtension
			0,								// StreamHeaderMediaSpecific
			0,								// StreamHeaderWorkspace 
			FALSE,							// Allocator 
			NULL,							// HwEventRoutine
			{ 0, 0 }						// Reserved[2]
		}
	},

	{	// Input AC3 audio stream
		{	// HW_STREAM_INFORMATION
			1,								// NumberOfPossibleInstances
			KSPIN_DATAFLOW_IN,				// DataFlow
			TRUE,							// DataAccessible
			NUM_AUDIO_IN_FORMATS,			// NumberOfFormatArrayEntries
			ZivaAudioInFormatArray,			// StreamFormatsArray
			0, 0, 0, 0,						// ClassReserved
			NUM_AUDIO_IN_PROPERTY_ITEMS,	// NumStreamPropArrayEntries
			(PKSPROPERTY_SET)audPropSet,	// StreamPropertiesArray
			SIZEOF_ARRAY( ClockEventSet ),	// NumStreamEventArrayEntries;
			ClockEventSet,					// StreamEventsArray;
			(GUID*)&GUID_NULL,				// Category
			(GUID*)&GUID_NULL,				// Name
			0,								// MediumsCount
			NULL,							// Mediums
			FALSE							// BridgeStream
		},
		{	// HW_STREAM_OBJECT
			sizeof( HW_STREAM_OBJECT ),		// SizeOfThisPacket
			ZivaAudio,						// StreamNumber
			0,								// HwStreamExtension
			AudioReceiveDataPacket,			// HwReceiveDataPacket
			AudioReceiveCtrlPacket,			// HwReceiveControlPacket
			{								// HW_CLOCK_OBJECT
				AudioClockFunction,
				CLOCK_SUPPORT_CAN_SET_ONBOARD_CLOCK |
				CLOCK_SUPPORT_CAN_READ_ONBOARD_CLOCK |
				CLOCK_SUPPORT_CAN_RETURN_STREAM_TIME
			},
#ifndef EZDVD
			TRUE,							// Dma
			TRUE,							// Pio
#else
			FALSE,							// Dma
			TRUE,							// Pio
#endif
			0,								// HwDeviceExtension
			0,								// StreamHeaderMediaSpecific
			0,								// StreamHeaderWorkspace 
			FALSE,							// Allocator 
			AudioEventFunction,				// HwEventRoutine
			{ 0, 0 }						// Reserved[2]
		}
	},

	{	// Input subpicture stream
		{	// HW_STREAM_INFORMATION
			1,								// NumberOfPossibleInstances
			KSPIN_DATAFLOW_IN,				// DataFlow
			TRUE,							// DataAccessible
			NUM_SUBPICTURE_IN_FORMATS,		// NumberOfFormatArrayEntries
			ZivaSubPictureInFormatArray,	// StreamFormatsArray
			0, 0, 0, 0,						// ClassReserved
			NUM_SUBPICTURE_IN_PROPERTY_ITEMS,//NumStreamPropArrayEntries
			(PKSPROPERTY_SET)SPPropSet,		// StreamPropertiesArray
			0,								// NumStreamEventArrayEntries;
			NULL,							// StreamEventsArray;
			(GUID*)&GUID_NULL,				// Category
			(GUID*)&GUID_NULL,				// Name
			0,								// MediumsCount
			NULL,							// Mediums
			FALSE							// BridgeStream
		},
		{	// HW_STREAM_OBJECT
			sizeof( HW_STREAM_OBJECT ),		// SizeOfThisPacket
			ZivaSubpicture,					// StreamNumber
			0,								// HwStreamExtension
			SubpictureReceiveDataPacket,	// HwReceiveDataPacket
			SubpictureReceiveCtrlPacket,	// HwReceiveControlPacket
			{ NULL, 0 },					// HW_CLOCK_OBJECT
#ifndef EZDVD
			TRUE,							// Dma
			TRUE,							// Pio
#else
			FALSE,							// Dma
			TRUE,							// Pio
#endif
			0,								// HwDeviceExtension
			0,								// StreamHeaderMediaSpecific
			0,								// StreamHeaderWorkspace 
			FALSE,							// Allocator 
			NULL,							// HwEventRoutine
			{ 0, 0 }						// Reserved[2]
		}
	},

#if defined(ENCORE)
	{	// Output analog video stream
		{	// HW_STREAM_INFORMATION
			2,								// NumberOfPossibleInstances
			KSPIN_DATAFLOW_OUT,				// DataFlow
			FALSE,							// DataAccessible
			NUM_VIDEO_OUT_FORMATS,			// NumberOfFormatArrayEntries
			ZivaVideoOutFormatArray,		// StreamFormatsArray
			0, 0, 0, 0,						// ClassReserved
			NUM_VIDEO_OUT_PROPERTY_ITEMS,	// NumStreamPropArrayEntries
			(PKSPROPERTY_SET)VideoOutPropSet,//StreamPropertiesArray

			0,								// NumStreamEventArrayEntries;
			NULL,							// StreamEventsArray;

			(GUID*)&GUID_NULL,				// Category
			(GUID*)&GUID_NULL,				// Name
			0,								// MediumsCount
			NULL,							// Mediums
			FALSE							// BridgeStream
		},
		{	// HW_STREAM_OBJECT
			sizeof( HW_STREAM_OBJECT ),		// SizeOfThisPacket
			ZivaAnalog,						// StreamNumber
			0,								// HwStreamExtension
			AnalogReceiveDataPacket,		// HwReceiveDataPacket
			AnalogReceiveCtrlPacket,		// HwReceiveControlPacket
			{ NULL, 0 },					// HW_CLOCK_OBJECT
			TRUE,							// Dma
			FALSE,							// Pio
			0,								// HwDeviceExtension
			sizeof( KS_FRAME_INFO ),		// StreamHeaderMediaSpecific
			0,								// StreamHeaderWorkspace 
			FALSE,							// Allocator 
			NULL,							// HwEventRoutine
			{ 0, 0 }						// Reserved[2]
		}
	}
#elif defined(DECODER_DVDPC) || defined(EZDVD)
	
	{	// Output VPE video stream
		{	// HW_STREAM_INFORMATION
			1,								// NumberOfPossibleInstances
			KSPIN_DATAFLOW_OUT,				// DataFlow
			TRUE,							// DataAccessible
			NUM_VIDEO_OUT_FORMATS,			// NumberOfFormatArrayEntries
			ZivaVideoOutFormatArray,		// StreamFormatsArray
			0, 0, 0, 0,						// ClassReserved
			1,								// NumStreamPropArrayEntries
			(PKSPROPERTY_SET)VideoPortPropSet,//StreamPropertiesArray

			SIZEOF_ARRAY( VPEventSet ),		// NumStreamEventArrayEntries;
			VPEventSet,						// StreamEventsArray;
			(GUID*)&GUID_NULL,				// Category
			(GUID*)&GUID_NULL,				// Name
			1,								// MediumsCount
			&VPMedium,						// Mediums
			FALSE							// BridgeStream
		},
		{	// HW_STREAM_OBJECT
			sizeof( HW_STREAM_OBJECT ),		// SizeOfThisPacket
			ZivaYUV,						// StreamNumber
			0,								// HwStreamExtension
			VpeReceiveDataPacket,			// HwReceiveDataPacket
			VpeReceiveCtrlPacket,			// HwReceiveControlPacket
			{ NULL, 0 },					// HW_CLOCK_OBJECT
			FALSE,							// Dma
			TRUE,							// Pio
			0,								// HwDeviceExtension
			0,								// StreamHeaderMediaSpecific
			0,								// StreamHeaderWorkspace 
			FALSE,							// Allocator 
			NULL,							// HwEventRoutine
			{ 0, 0 }						// Reserved[2]
		}
	}
#endif
#ifndef OVATION
	,
	{	// Output CC
		{	// HW_STREAM_INFORMATION
			1,								// NumberOfPossibleInstances
			KSPIN_DATAFLOW_OUT,				// DataFlow
			TRUE,							// DataAccessible
			NUM_CC_OUT_FORMATS,				// NumberOfFormatArrayEntries
			CCInfo,							// StreamFormatsArray
			0, 0, 0, 0,						// ClassReserved
			1,								// NumStreamPropArrayEntries
			(PKSPROPERTY_SET)CCPropSet,		// StreamPropertiesArray
			0,								// NumStreamEventArrayEntries;
			0,								// StreamEventsArray;
			(GUID*)&GUID_NULL,				// Category
			(GUID*)&GUID_NULL,				// Name
			0,								// MediumsCount
			NULL,							// Mediums
			FALSE							// BridgeStream
		},
		{	// HW_STREAM_OBJECT
			sizeof( HW_STREAM_OBJECT ),		// SizeOfThisPacket
			ZivaCCOut,						// StreamNumber
			0,								// HwStreamExtension
			CCReceiveDataPacket,			// HwReceiveDataPacket
			CCReceiveCtrlPacket,			// HwReceiveControlPacket
			{ NULL, 0 },					// HW_CLOCK_OBJECT
			FALSE,							// Dma
			TRUE,							// Pio
			0,								// HwDeviceExtension
			0,								// StreamHeaderMediaSpecific
			0,								// StreamHeaderWorkspace 
			FALSE,							// Allocator 
			NULL,							// HwEventRoutine
			{ 0, 0 }						// Reserved[2]
		}
	}
#endif
};




#endif  // _ZIVAGUID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dxr2\vtoolsc.h ===
// Just dummy file to make dependecies checker satisfied
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\jbs\bt856.c ===
//
// MODULE  : BT856.C
//	PURPOSE : BrookTree BT856 Initialization code
//	AUTHOR  : JBS Yadawa
// CREATED :  7/20/96
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//

#include "stdefs.h"
#include "i2c.h"
#include "bt856.h"
#define BTI2CADR	0x88
#define I2CBYTECNT	10                         
static BYTE StdSeq[8][I2CBYTECNT] =  {{0xce, 0, 0, 0, 0, 0, 0, 0, 0xF2, 0x04},
							   {0xce, 0, 0, 0, 0, 0, 0, 0, 0x02, 0x10},
							   {0xce, 0, 0, 0, 0, 0, 0, 0, 0x02, 0x00},
							   {0xce, 0, 0, 0, 0, 0, 0, 0, 0x0A, 0x00},
							   {0xce, 0, 0, 0, 0, 0, 0, 0, 0xF6, 0x04},
							   {0xce, 0, 0, 0, 0, 0, 0, 0, 0x16, 0x10},
							   {0xce, 0, 0, 0, 0, 0, 0, 0, 0x06, 0x00},
							   {0xce, 0, 0, 0, 0, 0, 0, 0, 0x0E, 0x00}};

void FARAPI BTInitEnc(void)
{
	I2CInitBus();
	I2CSettleBus();
}

void FARAPI BTSetVideoStandard(VSTANDARD std)
{                                    
	I2CSendSeq(BTI2CADR,I2CBYTECNT, StdSeq[std]); 
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\jbs\bt856.h ===
//
// MODULE  : BT856.H
//	PURPOSE : Board specific code goes here
//	AUTHOR  : JBS Yadawa
// CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//

#ifndef __BT856_H__
#define __BT856_H__
typedef enum tagStd {
	NTSC_PLAY = 0,
	NTSC_TEST,
	NTSC_EXT,
	NTSC_CAPT,
	PAL_PLAY,
	PAL_TEST,
	PAL_EXT,
	PAL_CAPT
} VSTANDARD;
void FARAPI BTInitEnc(void);
void FARAPI BTSetVideoStandard(VSTANDARD std);
#endif// __BT856_H__

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\jbs\board.h ===
//
// MODULE  : BOARD.H
//	PURPOSE : Board specific code goes here
//	AUTHOR  : JBS Yadawa
// CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//

#ifndef __BOARD_H
#define __BOARD_H
// BOARD.H

#include "stdefs.h"

#ifdef __cplusplus
extern "C" {
#endif

BOOL FARAPI BoardOpen(DWORD lLocalIOBaseAddress);
void FARAPI BoardHardReset(void);
BYTE FARAPI BoardReadAudio(BYTE Register);
BYTE FARAPI BoardReadVideo(BYTE Register);
void FARAPI BoardWriteAudio(BYTE Register, BYTE Value);
void FARAPI BoardWriteVideo(BYTE Register, BYTE Value);
void FARAPI BoardSendAudio(LPBYTE Buffer, WORD Size);
void FARAPI BoardSendVideo(LPWORD Buffer, WORD Size);
void FARAPI BoardAudioSetSamplingFrequency(DWORD Frequency);
void FARAPI BoardVideoSetDisplayMode(BYTE Mode);
void FARAPI BoardEnterInterrupt(void);
void FARAPI BoardLeaveInterrupt(void);
void FARAPI BoardDisableIRQ(void);
void FARAPI BoardEnableIRQ(void);
void FARAPI BoardWriteEPLD(BYTE Reg, BYTE Data);
BOOL FARAPI BoardClose(void);
BOOL FARAPI BoardReadGPIOReg(BYTE Bit);
void FARAPI BoardWriteGPIOReg(BYTE Bit, BOOL Val);

#ifdef __cplusplus
}
#endif
//------------------------------- End of File --------------------------------
#endif // #ifndef __BOARD_H




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dxr2\zivawdm.h ===
/******************************************************************************\
*                                                                              *
*      ZIVAWDM.H  -     ZiVA hardware control API.                             *
*                                                                              *
*      Copyright (c) C-Cube Microsystems 1996                                  *
*      All Rights Reserved.                                                    *
*                                                                              *
*      Use of C-Cube Microsystems code is governed by terms and conditions     *
*      stated in the accompanying licensing statement.                         *
*                                                                              *
\******************************************************************************/

#ifndef _ZIVAWDM_H_
#define _ZIVAWDM_H_

#ifdef GATEWAY
#define LRCK_DELAY
#endif

#define AUTHENTICATION_TIMEOUT_COUNT 200

#define ZIVA_STREAM_TYPE_MPEG_PROGRAM           0 // DVD MPEG-2 program stream
#define ZIVA_STREAM_TYPE_MPEG_SYSTEM            1 // MPEG-1 system stream
#define ZIVA_STREAM_TYPE_CDROM_MPEG             2 // VideoCD CD-ROM sector stream
#define ZIVA_STREAM_TYPE_CDDA                   3 // CD-DA PCM sector stream
#define ZIVA_STREAM_TYPE_AUDIO_ELEMENTARY    0x10 // Audio elementary stream
#define ZIVA_STREAM_TYPE_VIDEO_ELEMENTARY    0x11 // Video elementary stream

#define NTSC	1
#define PAL		2

typedef enum _ZIVA_STREAM
{
	ZivaVideo = 0,
	ZivaAudio,
	ZivaSubpicture,
#if defined (ENCORE)
	ZivaAnalog,
#elif defined(DECODER_DVDPC)|| defined(EZDVD)
	ZivaYUV,
#endif

	ZivaCCOut,
	ZivaNumberOfStreams
} ZIVA_STREAM, *PZIVA_STREAM;

#define DISC_KEY_SIZE         2048

typedef enum _ZIVA_STATE
{
	ZIVA_STATE_PLAY = 0,
	ZIVA_STATE_PAUSE,
	ZIVA_STATE_STOP,
	ZIVA_STATE_SCAN,
	ZIVA_STATE_STEP,
	ZIVA_STATE_SLOWMOTION
} ZIVA_STATE;

typedef struct _INT_STATUS_INFO
{
	DWORD dwStatus;   // Interrupt status
	DWORD dwButton;
	DWORD dwError;
	DWORD dwBuffer;
	DWORD dwUnderflow;
	DWORD dwAOR;
	DWORD dwAEE;
} INT_STATUS_INFO, * PINT_STATUS_INFO;

typedef struct _HW_DEVICE_EXTENSION
{
	ULONG				dwDVDHostBaseAddress;		// Board base address
	ULONG				dwHostAccessRangeLength;	// and its length
	ULONG				dwDVDCFifoBaseAddress;
	ULONG				dwDVDAMCCBaseAddress;
	ULONG				dwDVDFPGABaseAddress;
	ULONG				dwDVD6807BaseAddress;

	BOOLEAN				bVideoStreamOpened;
	BOOLEAN				bAudioStreamOpened;
	BOOLEAN				bSubPictureStreamOpened;
	BOOLEAN				bOverlayInitialized;
	int					nAnalogStreamOpened;
	int					iTotalOpenedStreams;

	BOOLEAN				bVideoCanAuthenticate;
	BOOLEAN				bAudioCanAuthenticate;
	BOOLEAN				bSubPictureCanAuthenticate;
	int					iStreamToAuthenticateOn;

	BOOLEAN				bValidSPU;

	KSPROPERTY_SPHLI	hli;
	PHW_STREAM_REQUEST_BLOCK pCurrentVideoSrb;		// Currently DMAing Video Srb
	DWORD				dwCurrentVideoSample;		// Currently DMAing Video Sample (page)

	PHW_STREAM_REQUEST_BLOCK pCurrentAudioSrb;		// Currently DMAing Audio Srb
	DWORD				dwCurrentAudioSample;		// Currently DMAing Audio Sample (page)

	PHW_STREAM_REQUEST_BLOCK pCurrentSubPictureSrb;	// Currently DMAing SubPicture Srb
	DWORD				dwCurrentSubPictureSample;	// Currently DMAing SubPicture Sample (page)

	ZIVA_STREAM			CurrentlySentStream;		// Currently DMAing Stream

	WORD				wNextSrbOrderNumber;

	BOOLEAN				bInterruptPending;
	BOOLEAN				bPlayCommandPending;
	BOOLEAN				bScanCommandPending;
	BOOLEAN				bSlowCommandPending;
	BOOLEAN				bEndFlush;
	BOOL				bTimerScheduled;


	int					nTimeoutCount;
	int					nStopCount, nPauseCount, nPlayCount;
#ifdef ENCORE
	BOOL				bIsVxp524;
	int					nVGAMode;		// TRUE - current, FALSE - new, (-1) - new VGA!
	DWORD				dwColorKey;
	
#endif
	ULONG				VideoPort;
	PHW_STREAM_OBJECT	pstroYUV;
	KS_AMVPDATAINFO		VPFmt;
	ULONG				ddrawHandle;
	ULONG				VidPortID;
	ULONG				SurfaceHandle;
//#endif

	PUCHAR				pDiscKeyBufferLinear;
	STREAM_PHYSICAL_ADDRESS pDiscKeyBufferPhysical;
	PDEVICE_OBJECT		pPhysicalDeviceObj;

	ULONG				NewRate;
	BOOLEAN				bToBeDiscontinued;
	BOOLEAN				bDiscontinued;
	BOOLEAN				bAbortAtPause;
	BOOLEAN				bRateChangeFromSlowMotion;
	DWORD				dwCurrentVideoPage;
	DWORD				dwCurrentAudioPage;
	DWORD				dwCurrentSubPicturePage;
	LONG				dwVideoDataUsed;
	LONG				dwAudioDataUsed;
	LONG				dwSubPictureDataUsed;
	BOOLEAN				bMove;
/*	DWORD				VidBufferSize[50];
	DWORD				VideoPageTable[50];
	DWORD				AudBufferSize[50];
	DWORD				AudioPageTable[50];
	DWORD				SubPictureBufferSize[50];
	DWORD				SubPicturePageTable[50];*/
	BOOLEAN				bStreamNumberCouldBeChanged;
	WORD				wCurrentStreamNumber;
	BOOLEAN				bSwitchDecryptionOn;
	ZIVA_STATE			zInitialState;
	PHW_STREAM_OBJECT	pstroCC;

	DWORD				gdwCount;
	BYTE 				*gbpCurData;
	BOOLEAN				bHliPending;

	DWORD				dwFirstVideoOrdNum;
	DWORD				dwFirstAudioOrdNum;
	DWORD				dwFirstSbpOrdNum;

	PHW_STREAM_OBJECT	pstroAud;
	DWORD				dwVSyncCount;
	LONG				nApsMode;
	WORD				VidSystem;
	ULONG				ulLevel;
	BOOL				fAtleastOne;
	DWORD				dwPrevSTC;
	BOOL				bTrickModeToPlay;

	STREAM_SYSTEM_TIME			VideoSTC;
	ULONGLONG			prevStrm;
	BOOL				fFirstSTC;
	ULONG				cCCRec, cCCDeq, cCCCB ,cCCQ;
	struct _HW_DEVICE_EXTENSION *pCCDevEx;
	PHW_STREAM_REQUEST_BLOCK pSrbQ;
	DWORD dwUserDataBuffer[ 160 ];
	DWORD dwUserDataSize;
	BOOL fReSync;
	BOOL bInitialized;

	

} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;

typedef struct _HW_STREAM_EXTENSION
{
	KSSTATE	ksState;
	BOOL	bCanBeRun;
	BOOL	bVideoEnabled;
} HW_STREAM_EXTENSION, *PHW_STREAM_EXTENSION;


BOOL _stdcall ZivaHw_Initialize( PHW_DEVICE_EXTENSION pHwDevExt );
BOOL _stdcall ZivaHW_LoadUCode();
BOOL _stdcall ZivaHw_Play();
BOOL _stdcall ZivaHw_Scan();
BOOL _stdcall ZivaHw_SlowMotion( WORD wRatio );
BOOL _stdcall ZivaHw_Pause();
BOOL ZivaHw_Reset();
BOOL ZivaHw_Abort();
ZIVA_STATE ZivaHw_GetState();
BOOL ZivaHW_GetNotificationDirect( PINT_STATUS_INFO pInfo );
BOOL ZivaHw_FlushBuffers( );
void ZivaHW_ForceCodedAspectRatio(WORD wRatio);
void ZivaHw_SetDisplayMode( WORD wDisplay, WORD wMode );
void ZivaHw_SetVideoMode(PHW_DEVICE_EXTENSION pHwDevExt);
BOOL ZivaHw_GetUserData(PHW_DEVICE_EXTENSION pHwDevExt);

#endif  // _ZIVAWDM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\jbs\board.c ===
//
// MODULE  : BOARD.C
//	PURPOSE : Board specific code goes here
//	AUTHOR  : JBS Yadawa
// CREATED :  7/20/96
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//
#include "common.h"
#include "strmini.h"
#include "stdefs.h"
#include "board.h"
#include "debug.h"
#include "common.h"
#include "i20reg.h"
#include "bt856.h"
#include "memio.h"
#include "codedma.h"

#define POSTOFFICEREG 	0x200
#define INCTL			0x01
#define AUXCTL			0x02
#define INTR_CTRL 		0x40
#define INTR_STATUS		0x3C

static BYTE PrevVideoAdr = 0xFF;
static BYTE GPIOReg;


BYTE FARAPI BoardReadAudio(BYTE Reg)
{
	BYTE 	NewVideoAdr = Reg & 0x7E;
	DWORD PoReg=0;

  	HostDisableIT();
	if(NewVideoAdr != PrevVideoAdr)
	{
		PrevVideoAdr = NewVideoAdr;
		PoReg = NewVideoAdr | 0x00830000;
		memOutDword(POSTOFFICEREG, PoReg);
		while(memInDword(POSTOFFICEREG)&02000000L);
	}
	if(Reg&0x80)
	{
		if(Reg&0x01)
			PoReg = 0x00150000;
		else
			PoReg = 0x00140000;
	}
	else
	{
		if(Reg&0x01)
			PoReg = 0x00110000;
		else
			PoReg = 0x00100000;
	}
	memOutDword(POSTOFFICEREG, PoReg);
	while(memInDword(POSTOFFICEREG)&02000000L);
	
	PoReg = memInDword(POSTOFFICEREG);
	HostEnableIT();
	return ((BYTE)PoReg);
}

BYTE FARAPI BoardReadVideo(BYTE Reg)
{
	BYTE 	NewVideoAdr = Reg & 0x7E;
	DWORD PoReg=0;

  	HostDisableIT();
	if(NewVideoAdr != PrevVideoAdr)
	{
		PrevVideoAdr = NewVideoAdr;
		PoReg = NewVideoAdr | 0x00830000;
		memOutDword(POSTOFFICEREG, PoReg);
		while(memInDword(POSTOFFICEREG)&02000000L);
	}
	if(Reg&0x80)
	{
		if(Reg&0x01)
			PoReg = 0x00150000;
		else
			PoReg = 0x00140000;
	}
	else
	{
		if(Reg&0x01)
			PoReg = 0x00110000;
		else
			PoReg = 0x00100000;
	}
	memOutDword(POSTOFFICEREG, PoReg);
	while(memInDword(POSTOFFICEREG)&02000000L);
	
	PoReg = memInDword(POSTOFFICEREG);
	HostEnableIT();
	return ((BYTE)PoReg);
}

void FARAPI BoardWriteAudio(BYTE Reg, BYTE Data)
{
	BYTE 	NewVideoAdr = Reg & 0x7E;
	DWORD PoReg=0;

  	HostDisableIT();
	if(NewVideoAdr != PrevVideoAdr)
	{
		PrevVideoAdr = NewVideoAdr;
		PoReg = NewVideoAdr | 0x00830000;
		memOutDword(POSTOFFICEREG, PoReg);
		while(memInDword(POSTOFFICEREG)&02000000L);
	}
	if(Reg&0x80)
	{
		if(Reg&0x01)
			PoReg = Data | 0x00970000;
		else
			PoReg = Data | 0x00960000;
	}
	else
	{
		if(Reg&0x01)
			PoReg = Data | 0x00930000;
		else
			PoReg = Data | 0x00920000;
	}
	memOutDword(POSTOFFICEREG, PoReg);
	while(memInDword(POSTOFFICEREG)&02000000L);
	HostEnableIT();
	
}

void FARAPI BoardWriteVideo(BYTE Reg, BYTE Data)
{
	BYTE 	NewVideoAdr = Reg & 0x7E;
	DWORD PoReg=0;

  	HostDisableIT();
	if(NewVideoAdr != PrevVideoAdr)
	{
		PrevVideoAdr = NewVideoAdr;
		PoReg = NewVideoAdr | 0x00830000;
		memOutDword(POSTOFFICEREG, PoReg);
		while(memInDword(POSTOFFICEREG)&02000000L);
	}
	if(Reg&0x80)
	{
		if(Reg&0x01)
			PoReg = Data | 0x00970000;
		else
			PoReg = Data | 0x00960000;
	}
	else
	{
		if(Reg&0x01)
			PoReg = Data | 0x00930000;
		else
			PoReg = Data | 0x00920000;
	}
	memOutDword(POSTOFFICEREG, PoReg);
	while(memInDword(POSTOFFICEREG)&02000000L);
	HostEnableIT();
	
}

void FARAPI BoardSendAudio(LPBYTE lpBuffer, WORD size)
{
}

void FARAPI BoardSendVideo(WORD  * Buffer, WORD Size)
{
}

void FARAPI BoardEnableIRQ(void)
{   
	memOutByte(INTR_CTRL+3,0x71);
//      DPF((Trace,"PCI Intr = %x", memInByte(INTR_CTRL+3)));

}

void FARAPI BoardDisableIRQ(void)
{  
	memOutByte(INTR_CTRL+3,0x00);
//      DPF((Trace,"PCI Intr = %x", memInByte(INTR_CTRL+3)));
}


void FARAPI BoardAudioSetSamplingFrequency(DWORD Frequency)
{
}


void FARAPI BoardEnterInterrupt(void)
{
}

void FARAPI BoardLeaveInterrupt(void)
{
//	memOutByte(INTR_STATUS+3,0xFF);
//      DPF((Trace,"PCI Intr = %x", memInByte(INTR_STATUS+3)));
}                                          

BOOL FARAPI BoardOpen(DWORD Base)
{                   
	static char dbgstr[120];
	PrevVideoAdr = 0xFF;

        DPF((Trace,"Allocating Memory Base!!\n"));
	if(!AllocMemoryBase(Base, 0x1000))
	{                
                DPF((Trace,"Can not covert Physical to Linear"));
		return FALSE;
	}
	
	DPF((Trace, "GPIO = %lx", memInDword(I20_GPREG)));
	memOutDword(I20_GPREG, 0x000000ff);
	Delay(100);
	memOutDword(I20_GPREG, 0x010000ff);
	Delay(100);
	memOutDword(I20_GPREG, 0x000000ff);
	Delay(100);

	memOutDword(I20_GPREG, 0x010000ff);
	Delay(4000);
	DPF((Trace, "GPIO = %lx", memInDword(I20_GPREG)));
	// Gen Purpose Directions
	// 	O		 I		  O	  O		O		 O		  I	  I
	// SPIDO SPIDI SPICLK SPIEN SRESET STIRST STIREQ AXREQ
 	memOutByte(I20_GPREG, 0x43);
	// 	0		 0		  1	  1		0		 0		  0	  0
	// SPIDO SPIDI SPICLK SPIEN SRESET STIRST STIREQ AXREQ
	memOutByte(I20_GBREG+3, 0x30);
	Delay(100);
	// 	0		 0		  0	  1		0		 0		  0	  0
	// SPIDO SPIDI SPICLK SPIEN SRESET STIRST STIREQ AXREQ
	memOutByte(I20_GBREG+3, 0x10);
	Delay(100);
	BoardWriteEPLD(INCTL, 0x01);
	Delay(100);
	BoardWriteEPLD(AUXCTL, 0x00);
	Delay(100);
	// 	0		 0		  0	  1		1		 1		  0	  0
	// SPIDO SPIDI SPICLK SPIEN SRESET STIRST STIREQ AXREQ
	memOutByte(I20_GBREG+3, 0x1C);
	GPIOReg = 0x1C;     
	
	Delay(100);                   
	memOutByte(I20_GBREG, 0x00);
	Delay(100);                   
	memOutByte(I20_GBREG+1, 0x00);
	Delay(100);                   
	
	BoardWriteEPLD(INCTL, 0x01);
	Delay(100);
	BoardWriteEPLD(AUXCTL, 0x00);
	Delay(100);                           
	BTInitEnc();
	BTSetVideoStandard(NTSC_PLAY);        
	BTInitEnc();
	BTSetVideoStandard(NTSC_PLAY);        

	
	return TRUE;
}

BOOL FARAPI BoardClose(void)
{
	FreeMemoryBase();
	return TRUE;
}

void FARAPI Delay(DWORD Microseconds)
{
/*
	DWORD i, j;

	for (i = 0; i < Microseconds*20; i++)
		j = inp(0x0070)%2; // the action of reading takes about 1s
*/
    KeStallExecutionProcessor(Microseconds);

}

void FARAPI BoardWriteEPLD(BYTE Reg, BYTE Data)
{
	DWORD PoReg=0;

  	HostDisableIT();
	PoReg = Data | 0x00800000 | ((DWORD)(Reg&0x07) << 16);
	memOutDword(POSTOFFICEREG, PoReg);
	while(memInDword(POSTOFFICEREG)&02000000L);
	HostEnableIT();
	
}                  


void FARAPI BoardWriteGPIOReg(BYTE Bit, BOOL Val)
{
	BYTE x;
	if(Val)
	{
		x = 1 << Bit;
		GPIOReg |= x;
		memOutByte(I20_GBREG+3, GPIOReg);
	}
	else
	{
		x = 1 << Bit;
		x = ~x;
		GPIOReg &= x;
		memOutByte(I20_GBREG+3, GPIOReg);
	}
}

BOOL FARAPI BoardReadGPIOReg(BYTE Bit)
{
	BYTE x;
	x =  memInByte(I20_GBREG+3);

	return ((x>> Bit)&0x01);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\jbs\codedma.c ===
//
// MODULE  : CODEDMA.C
//	PURPOSE : Compressed Data DMA Transfer
//	AUTHOR  : JBS Yadawa
// CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//
#include "common.h"
#include "strmini.h"
#include "stdefs.h"
#include "i20reg.h"
#include "memio.h"
#include "codedma.h"
#include "debug.h"
#include "sti3520A.h"

CODEDMA CodeDma;
LPCODEDMA lpCodeDma;

#define ALLOCATE_DMA_BUFFER	0x8107
#define RELEASE_DMA_BUFFER	0x8108
#define COPY_TO_DMA_BUFFER	0x8109

BOOL NEARAPI InitCodeCtl(DWORD);
void NEARAPI StartTransfer(void);
void NEARAPI StopTransfer(void);
void NEARAPI FlushTransfer(void);
WORD NEARAPI GetTransferLocation(void);
DWORD NEARAPI  GetCodeMemBase(void);
DWORD NEARAPI GetCodeControlReg(void);
BOOL NEARAPI OpenCodeCtrl(void);


BOOL FARAPI CodeDmaOpen(BYTE *pDmaBuf, DWORD PhysicalAddress)
{   
	                         
	lpCodeDma = &CodeDma;
	lpCodeDma->WritePtr = 0;	
	lpCodeDma->TransferCompleted = TRUE;
        lpCodeDma->lpBuf = pDmaBuf;
        return InitCodeCtl(PhysicalAddress);
}

BOOL FARAPI CodeDmaFlush(void)
{     
	StopTransfer();
	FlushTransfer();             
	lpCodeDma->WritePtr = 0;	
	lpCodeDma->TransferCompleted = TRUE;
	return TRUE;
}		                         



BOOL FARAPI CodeDmaClose(void)
{                      
	return TRUE;
}

BOOL NEARAPI InitCodeCtl(DWORD PhysicalAddress)
{
	lpCodeDma->CodeCtl = 0x10200002;
	memOutDword(I20_CODECTL, lpCodeDma->CodeCtl);
	lpCodeDma->CodeCtl = 0x00200002;
	memOutDword(I20_CODECTL, lpCodeDma->CodeCtl);
        memOutDword(I20_CODEMB, PhysicalAddress);
	return TRUE;
}   

void NEARAPI StartTransfer(void)
{
	lpCodeDma->CodeCtl |= 0x00000080;
	memOutDword(I20_CODECTL, lpCodeDma->CodeCtl);
}

void NEARAPI StopTransfer(void)
{
	lpCodeDma->CodeCtl &= (~(0x00000080L));
	memOutDword(I20_CODECTL, lpCodeDma->CodeCtl);
}

void NEARAPI FlushTransfer(void)
{                      
	lpCodeDma->CodeCtl |= 0x10000000;
	memOutDword(I20_CODECTL, lpCodeDma->CodeCtl);
	lpCodeDma->CodeCtl &= (~0x10000000);
	memOutDword(I20_CODECTL, lpCodeDma->CodeCtl);
}

WORD NEARAPI GetTransferLocation(void)
{
	DWORD xx;
	xx = memInDword(I20_CODEMP);
	return (WORD)(xx&0xFFFF);
}


DWORD FARAPI CodeDmaSendData(BYTE *lpData, DWORD Size)
{
	DWORD Remaining, Next;

        if(!lpCodeDma->TransferCompleted)
                return 0L;

	if(lpCodeDma->WritePtr + Size < DMA_BUFFER_SIZE)
	{
                RtlCopyMemory((BYTE  *)(lpCodeDma->lpBuf+lpCodeDma->WritePtr), lpData, Size);
		lpCodeDma->WritePtr += Size;    
                return Size;
	}

        else
        {
		
                if(!VideoIsEnoughPlace(DMA_BUFFER_SIZE*2))
                        return 0;

		Next = DMA_BUFFER_SIZE - lpCodeDma->WritePtr;
                if(Next)
                        RtlCopyMemory((BYTE *)(lpCodeDma->lpBuf+lpCodeDma->WritePtr), lpData, Next);
                memOutDword(I20_CODEMP, 0);
                lpCodeDma->TransferCompleted = FALSE;
                lpCodeDma->WritePtr=0;                   
                StartTransfer();
                return Next;             
	}                             
}

void FARAPI CodeDmaStopTransfer(void)
{                                  
}

void FARAPI CodeDmaStartTransfer(void)
{
}

void FARAPI CodeDmaInterrupt(void)
{
	StopTransfer();
	lpCodeDma->TransferCompleted = TRUE;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\dxr2\zivawdm.c ===
/******************************************************************************\
*                                                                              *
*      ZIVAWDM.C  -     ZiVA hardware control API.                             *
*                                                                              *
*      Copyright (c) C-Cube Microsystems 1996                                  *
*      All Rights Reserved.                                                    *
*                                                                              *
*      Use of C-Cube Microsystems code is governed by terms and conditions     *
*      stated in the accompanying licensing statement.                         *
*                                                                              *
\******************************************************************************/

#include "Headers.h"
#pragma hdrstop
#include "boardio.h"
#include "cl6100.h"

#include "tc6807af.h"
#include "fpga.h"
#include "audiodac.h"

#if defined(DECODER_DVDPC)
#include "lukecfg.h"
#include "mvis.h"
#include "dataxfer.h"
#elif defined(ENCORE) || defined(OVATION)
#include "bmaster.h"
#elif defined(EZDVD)
#include "Hostcfg.h"
#include "dataxfer.h"
#include "mvis.h"
#endif
#if defined(ENCORE) 
#include "mvstub.h"
#endif

#if defined (LOAD_UCODE_FROM_FILE)
#include "RegistryApi.h"
unsigned char UcodeBuff[150 * 1024];	// Ucode for for loading from file. // test
#else
#if defined(DECODER_DVDPC)
#include "cobra_ux.h"
#else//if defined(ENCORE) || defined(OVATION)
#include "dvd1_ux.h"
//#elif defined(EZDVD)
//#include "ezdvd_ux.h"
#endif

#endif	//LOAD_UCODE_FROM_FILE

//*******************************************************************
//  Local Types Declaration
//*******************************************************************
typedef enum _PLAY_STATE_COMMAND {
	CMD_PLAY = 0,
	CMD_PAUSE,
	CMD_STOP,
	CMD_SCAN,
	CMD_STEP,
	CMD_SLOWMOTION,
	CMD_NONE
} PLAY_STATE_COMMAND;

//*******************************************************************
//  Global Variables Declaration
//*******************************************************************
PLAY_STATE_COMMAND  gLastCommand = CMD_STOP;
BOOL  bPlaybackJustStarted = FALSE;

#if defined (LOAD_UCODE_FROM_FILE)
BOOL
ZivaHW_LoadUCodeFromFile(				// Load the microcode based on the microcode Id specified.
    PHW_DEVICE_EXTENSION pHwDevExt);                      // is pHwDevExt
#endif

//
//  ZivaHW_Initialize
//
///////////////////////////////////////////////////////////////////////////////
BOOL _stdcall ZivaHw_Initialize( PHW_DEVICE_EXTENSION pHwDevExt )
{

#if defined(DECODER_DVDPC)
	DWORD dwDVDAMCCBaseAddress,dwDVDIrq;
#endif
	MonoOutInit();

#if defined(DECODER_DVDPC)
	if (!InitLukeCfg(&dwDVDAMCCBaseAddress, &dwDVDIrq))
		return FALSE;
	InitMvis(pHwDevExt -> dwDVDAMCCBaseAddress);
	TV_SetEncoderType(1);
    if (!DataTransfer_Init( pHwDevExt -> dwDVDAMCCBaseAddress,dwDVDIrq))
	{
		MonoOutStr( " Cannot Initialize the AMCC for Bus Mastering " );
		return FALSE;
	}

#elif defined(ENCORE)

  // Initialize Bus Master first
  if ( !BMA_Init( pHwDevExt -> dwDVDAMCCBaseAddress, pHwDevExt->bIsVxp524 ) )
  {
    MonoOutStr( " Cannot Initialize the AMCC for Bus Mastering " );
    return FALSE;
  }
	if ( !FPGA_Init( pHwDevExt -> dwDVDFPGABaseAddress ) )
	{
		MonoOutStr( " Cannot Initialize the FPGA " );
		return FALSE;
	}

  
#elif defined(OVATION)

	// Initialize FPGA
	if ( !FPGA_Init( pHwDevExt -> dwDVDFPGABaseAddress ) )
	{
		MonoOutStr( " Cannot Initialize the FPGA " );
		return FALSE;
	}
	  // Initialize Bus Master
	if ( !BMA_Init( pHwDevExt -> dwDVDAMCCBaseAddress ) )
	{
		MonoOutStr( " Cannot Initialize the AMCC for Bus Mastering " );
		return FALSE;
	}

#elif defined(EZDVD)

	if (!InitHost(&(pHwDevExt -> dwDVDFPGABaseAddress), NULL))
		return FALSE;
	BRD_Init(pHwDevExt -> dwDVDAMCCBaseAddress, 0);
	InitMvis(0);//parameter ignored
#endif

  // Initialize DVD1 chip
	if ( !DVD_Initialize( pHwDevExt -> dwDVDHostBaseAddress, pHwDevExt -> dwDVDCFifoBaseAddress ) )
	{
		MonoOutStr( " Cannot Initialize the DVD1 chip (Board not found at specified address: " );
		MonoOutULongHex( pHwDevExt -> dwDVDHostBaseAddress );
		MonoOutStr( ") " );
		return FALSE;
	}

	if ( ( DVD_GetHWVersion() == DVD_HW_VERSION_1_0 ) )
	{
#ifdef OVATION
		if ( !TC6807AF_Initialize( pHwDevExt -> dwDVD6807BaseAddress ) )
		{
			MonoOutStr( " Cannot Initialize the TC6807AF chip at specified address: " );
			MonoOutULongHex( pHwDevExt -> dwDVD6807BaseAddress );
			MonoOutStr( ") " );
			return FALSE;
		}
#endif
	}

	//
	// Disable ZiVA's host interrupt
	//
	BRD_CloseDecoderInterruptPass();

  //
  // Load Decoder's firmware
  //
#if defined (LOAD_UCODE_FROM_FILE)
	if ( !ZivaHW_LoadUCodeFromFile(pHwDevExt) )
	{
		MonoOutStr(" !!! Ucode Load from file failed. !!!");
			return FALSE;
	}

#else
	if ( !ZivaHW_LoadUCode( ) )
		return FALSE;
#endif

#if defined( OVATION )
	ADAC_Init( pHwDevExt -> dwDVDFPGABaseAddress );
#elif (DECODER_DVDPC)
	ADAC_Init( pHwDevExt -> dwDVDAMCCBaseAddress );
#else
	ADAC_Init( (pHwDevExt -> dwDVD6807BaseAddress) - 2 );
#endif  // OVATION

  // Set default sampling frequency to 48 KHz (AC-3 audio)
	ADAC_SetSamplingFrequency( ADAC_SAMPLING_FREQ_48 );

  
#if 0
	// Set interrupt mask for events that we are going to use	
	if ( !DVD_IntEnable( CL6100_INT_MASK_UND|CL6100_INT_MASK_ERR ) )	
		return FALSE;
#endif

#if 0
	DebugPrint((DebugLevelVerbose,"\nCF_intrpt: %lX", DVD_ReadReg( 0x1c ) ));
	DebugPrint((DebugLevelVerbose," CF_count: %lX", DVD_ReadReg( 0x1d ) ));
	DebugPrint((DebugLevelVerbose," CF_command: %lX", DVD_ReadReg( 0x1f ) ));
	DebugPrint((DebugLevelVerbose," Host_contrl: %lX", DVD_ReadReg( 0 ) ));

	DebugPrint((DebugLevelVerbose,"\nDRAM_SUBP_FIFO_ST: %lX", DVD_ReadDRAM( 0x1722*4 ) ));
	DebugPrint((DebugLevelVerbose," RD_PTR: %lX", DVD_ReadDRAM( 0x1721*4 ) ));
	DebugPrint((DebugLevelVerbose," WR_PTR: %lX", DVD_ReadDRAM( 0x1720*4 ) ));
#endif
	return TRUE;  
}

//
//  CL6100SD_LoadUCode
//
///////////////////////////////////////////////////////////////////////////////

#if defined (LOAD_UCODE_FROM_FILE)
BOOL LoadUcode(BYTE * pbtUcode)
{
  // White sub picture palettes.
	DWORD dwPalletes[16] = {	0x00b08080,
								0x00b08080,
								0x00b08080,
								0x00b08080,
								0x00b08080,
								0x00b08080,
								0x00b08080,
								0x00b08080,
								0x00b08080,
								0x00b08080,
								0x00b08080,
								0x00b08080,
								0x00b08080,
								0x00b08080,
								0x00b08080,
								0x00b08080 };

#if defined(DECODER_DVDPC) || defined(EZDVD)
	DataTransfer_Reset();
#else
	BMA_Reset();
	FPGA_Clear( FPGA_SECTOR_START );
#endif

	if ( !DVD_LoadUCode( pbtUcode) )
		return FALSE;

	// Initialize sub picture palettes to white
	DVD_SetPalette( dwPalletes );

	
	return TRUE;
}
#else
BOOL _stdcall ZivaHW_LoadUCode( )
{
  // White sub picture palettes.
	DWORD dwPalletes[16] = {	0x00b08080,
								0x00b08080,
								0x00b08080,
								0x00b08080,
								0x00b08080,
								0x00b08080,
								0x00b08080,
								0x00b08080,
								0x00b08080,
								0x00b08080,
								0x00b08080,
								0x00b08080,
								0x00b08080,
								0x00b08080,
								0x00b08080,
								0x00b08080 };

#if defined(DECODER_DVDPC) || defined(EZDVD)
	DataTransfer_Reset();
#else
	BMA_Reset();
	FPGA_Clear( FPGA_SECTOR_START );
#endif

	if ( !DVD_LoadUCode( (BYTE *)(Microcode_Ptr_List[0].Microcode_Seg_Add) ) )
		return FALSE;

	// Initialize sub picture palettes to white
	DVD_SetPalette( dwPalletes );

	
	return TRUE;
}
#endif

//
//  ZivaHw_Play
//
///////////////////////////////////////////////////////////////////////////////
BOOL _stdcall ZivaHw_Play( )
{
	BOOL bStatus = FALSE;

	// Set interrupt mask for events that we are going to use
//#ifndef EZDVD
#ifdef DEBUG
	DVD_IntEnable( CL6100_INT_MASK_VSYNC|CL6100_INT_MASK_UND|CL6100_INT_MASK_ERR
					|CL6100_INT_MASK_USR );	//sri
#else
	DVD_IntEnable( CL6100_INT_MASK_VSYNC|CL6100_INT_MASK_USR );
#endif
//#endif
    

	if (gLastCommand == CMD_PAUSE ||
		gLastCommand == CMD_SCAN ||
		gLastCommand == CMD_SLOWMOTION )
	{
		gLastCommand = CMD_PLAY;
		bStatus = DVD_Resume( );
		//	bStatus = DVD_Play( );
	}
	else if ( gLastCommand != CMD_PLAY )
	{
		bPlaybackJustStarted = TRUE;
		gLastCommand = CMD_PLAY;
		bStatus = DVD_Play( );
	}
	else
		bStatus = TRUE;

	return bStatus;
}

//
//  ZivaHw_Scan
//
///////////////////////////////////////////////////////////////////////////////
BOOL _stdcall ZivaHw_Scan( )
{
	BOOL bStatus = FALSE;

	if ( gLastCommand != CMD_SCAN )
	{
		if ( gLastCommand != CMD_STOP )
			ZivaHw_Abort( );

		gLastCommand = CMD_SCAN;
		bStatus = DVD_Scan( 0, 0 );
	}
	else
		bStatus = TRUE;

	return bStatus;
}

//
//  ZivaHw_SLowMotion
//
///////////////////////////////////////////////////////////////////////////////
BOOL _stdcall ZivaHw_SlowMotion( WORD wRatio )
{
	BOOL bStatus = FALSE;

	if ( gLastCommand != CMD_SLOWMOTION )
	{
		gLastCommand = CMD_SLOWMOTION;
		bStatus = DVD_SlowMotion( wRatio );
	}
	else
		bStatus = TRUE;

	return bStatus;
}

//
//  ZivaHw_Pause
//
///////////////////////////////////////////////////////////////////////////////
BOOL _stdcall ZivaHw_Pause( )
{
	if (gLastCommand == CMD_PLAY ||
		gLastCommand == CMD_SCAN ||
		gLastCommand == CMD_SLOWMOTION )
	{
		gLastCommand = CMD_PAUSE;
		return DVD_Pause( );
	}

	return TRUE;
}

//
//  ZivaHw_Reset
//
///////////////////////////////////////////////////////////////////////////////
BOOL ZivaHw_Reset( )
{
//#ifndef EZDVD
#ifdef DEBUG
	DVD_IntDisable( CL6100_INT_MASK_VSYNC|CL6100_INT_MASK_UND|CL6100_INT_MASK_ERR
					|CL6100_INT_MASK_USR );	//sri
#else
	DVD_IntDisable( CL6100_INT_MASK_VSYNC|CL6100_INT_MASK_USR );	//sri
#endif
//#endif

	DVD_Reset( );
#if defined(DECODER_DVDPC) || defined(EZDVD)
	DataTransfer_Reset();
#else
	BMA_Reset();
	FPGA_Clear( FPGA_SECTOR_START );
#endif

	gLastCommand = CMD_STOP;

	return TRUE;
}

//
//  ZivaHw_Abort
//
///////////////////////////////////////////////////////////////////////////////
BOOL ZivaHw_Abort( )
{
	BOOL bStatus = FALSE;
	//INT_STATUS_INFO Info;
	//DWORD dwTimeout = 100000;
	// Set interrupt mask for events that we are going to use
//#ifndef EZDVD
#ifdef DEBUG
	DVD_IntDisable( CL6100_INT_MASK_VSYNC|CL6100_INT_MASK_UND|CL6100_INT_MASK_ERR
		|CL6100_INT_MASK_USR );	//sri
#else
	DVD_IntDisable( CL6100_INT_MASK_VSYNC|CL6100_INT_MASK_USR );	//sri
#endif
//#endif
  
	if ( gLastCommand != CMD_STOP )
	{
		gLastCommand = CMD_STOP;

	#if defined(DECODER_DVDPC) || defined(EZDVD)
		DataTransfer_Reset();
	#else
		BMA_Reset();
		FPGA_Clear( FPGA_SECTOR_START );
	#endif	
		
		bStatus = DVD_Abort( ); 
	
	}
	else
		bStatus = TRUE;

	return bStatus;
}

//
//  ZivaHw_FlushBuffers
//
///////////////////////////////////////////////////////////////////////////////
BOOL ZivaHw_FlushBuffers( )
{

    gLastCommand = CMD_NONE;	// Allow any next command
	
	DVD_Abort( );
#if defined(DECODER_DVDPC) || defined(EZDVD)
	DataTransfer_Reset();
#else
    BMA_Reset();
    FPGA_Clear( FPGA_SECTOR_START );
#endif

	

	return TRUE;
}



//
//  ZivaHw_GetState
//
///////////////////////////////////////////////////////////////////////////////
ZIVA_STATE ZivaHw_GetState( )
{
	ZIVA_STATE zState;

	if ( gLastCommand == CMD_PLAY )
		zState = ZIVA_STATE_PLAY;
	else if ( gLastCommand == CMD_PAUSE )
		zState = ZIVA_STATE_PAUSE;
	else if ( gLastCommand == CMD_STOP )
		zState = ZIVA_STATE_STOP;
	else if ( gLastCommand == CMD_SCAN )
		zState = ZIVA_STATE_SCAN;
	else if ( gLastCommand == CMD_STEP )
		zState = ZIVA_STATE_STEP;
	else if ( gLastCommand == CMD_SLOWMOTION )
		zState = ZIVA_STATE_SLOWMOTION;

	return zState;
}


//
//  ZivaHW_GetNotificationDirect
//
/////////////////////////////////////////////////////////////////////
BOOL ZivaHW_GetNotificationDirect( PINT_STATUS_INFO pInfo )
{
  INTSOURCES IntSrc;

  //MonoOutStr("[Get notification direct ");

  pInfo -> dwStatus    = DVD_Isr( &IntSrc );

  pInfo -> dwButton    = IntSrc.DVDIntHLI;
  pInfo -> dwError     = IntSrc.DVDIntERR;
  pInfo -> dwBuffer    = IntSrc.DVDIntBUFF;
  pInfo -> dwUnderflow = IntSrc.DVDIntUND;
  pInfo -> dwAOR       = IntSrc.DVDIntAOR;
  pInfo -> dwAEE       = IntSrc.DVDIntAEE;

  //MonoOutStr("]");
  return TRUE;
}

void ZivaHW_ForceCodedAspectRatio(WORD wRatio)
{
	DVD_ForceCodedAspectRatio(wRatio);
}

void ZivaHw_SetDisplayMode( WORD wDisplay, WORD wMode )
{
	DVD_SetDisplayMode(wDisplay,wMode );
}
void ZivaHw_SetVideoMode(PHW_DEVICE_EXTENSION pHwDevExt)
{
#if defined (DECODER_DVDPC) || defined(EZDVD)
//	TV_SetEncoderType(1);
	SetTVSystem(pHwDevExt->VidSystem);
	DVD_NewPlayMode( ZIVA_STREAM_TYPE_MPEG_PROGRAM, pHwDevExt->VidSystem );
#else if(ENCORE)
	BOOL bSystem = pHwDevExt->VidSystem == PAL ? FALSE:TRUE;
	SetMacroVisionLevel( bSystem, pHwDevExt->ulLevel );
	DVD_NewPlayMode( ZIVA_STREAM_TYPE_MPEG_PROGRAM, pHwDevExt->VidSystem );
#endif


}


#if defined (LOAD_UCODE_FROM_FILE)

#define ENTRY_UCODE_FILE			L"Microcode"
#define ENTRY_DEFAULT_UCODE_FILE	L"Dvd1.Ux"

BOOL
ZivaHW_LoadUCodeFromFile(				// Load the microcode based on the microcode Id specified.
    PHW_DEVICE_EXTENSION pHwDevExt)                      // is pHwDevExt

{
    NTSTATUS            status;
    HANDLE hKeyPdo;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    UNICODE_STRING      uniFileName;
    HANDLE              hFile;
    IO_STATUS_BLOCK     iosb;
	FILE_STANDARD_INFORMATION	FileInfo;
	PUCHAR				pFileDataPtr, pSaveFileDataPtr;

	WCHAR			pSection[] = L"FileNames";
	WCHAR			pwchUXFileName[255];
	BOOL			fResult = FALSE;
    /*
	WCHAR pwchEncUXFileName[255];// = L"\\SystemRoot\\system32\\drivers\\c3m2_enc.ux"; 
    WCHAR pwchDecUXFileName[255];// = L"\\SystemRoot\\system32\\drivers\\c3m2_dec.ux"; 
	short	sLength;
	WCHAR				pSection[] = L"FileNames";
	*/
	MonoOutStr("Loading Ucode from File ");
	
    status = IoOpenDeviceRegistryKey( pHwDevExt->pPhysicalDeviceObj, // my real PDO
	                              PLUGPLAY_REGKEY_DRIVER,   // pertinent to my device
	                              KEY_ALL_ACCESS,           // all acess
	                              &hKeyPdo);                // handle returned


	if ( !NT_SUCCESS( status )) 
	{
		MonoOutStr("Failed to obtain Key handle ");
		return  FALSE;
	}


	if (!REG_GetPrivateProfileString(
										pSection, 
										ENTRY_UCODE_FILE, 
										ENTRY_DEFAULT_UCODE_FILE, 
										pwchUXFileName, 
										sizeof(pwchUXFileName), 
										hKeyPdo))
	{
		MonoOutStr("Failed to obtain Ucode file name form registry ");
		return  FALSE;

	}

	pSaveFileDataPtr = pFileDataPtr = NULL;

	uniFileName.Length = wcslen(pwchUXFileName) * sizeof(WCHAR);
	uniFileName.MaximumLength = wcslen(pwchUXFileName) * sizeof(WCHAR);
	uniFileName.Buffer = pwchUXFileName;

	//
	// Read the Microcode file and load it.
	//
	// Open the file.
    InitializeObjectAttributes(
		&ObjectAttributes,
		&uniFileName,
		OBJ_CASE_INSENSITIVE,
		NULL,
		NULL);

    status = ZwCreateFile(
                &hFile,
                GENERIC_READ, // || SYNCHRONIZE,
                &ObjectAttributes,
                &iosb,
                NULL,               // allocate size
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT, //FILE_SEQUENTIAL_ONLY, use sync no alert
                NULL,               // eabuffer
                0);                 // ealength

    if ( !NT_SUCCESS( status )) 
	{
		MonoOutStr("Can not create ucode file\n");
        hFile = NULL;
		return fResult;
    }

	
	// Get file lengh and allocate memory to read complete file.
	status =  ZwQueryInformationFile(hFile, &iosb, &FileInfo, sizeof(FileInfo), FileStandardInformation);
    if ( !NT_SUCCESS( status )) 
	{
		MonoOutStr(" Can not get ucode file length ");
		ZwClose( hFile );
        hFile = NULL;
		return fResult;
    }
#if 0
	pFileDataPtr = ExAllocatePool(PagedPool , FileInfo.EndOfFile.LowPart);
	if (pFileDataPtr == NULL)
	{
		MonoOutStr(" Can not allocate pFileDataPtr ");
		ZwClose( hFile );
        hFile = NULL;
		return fResult;
	}
#endif
	pFileDataPtr = UcodeBuff;

	pSaveFileDataPtr = pFileDataPtr;
	// Read all the data from the file into buffer allocated.
    status = ZwReadFile(
                hFile,
                NULL,               // event
                NULL,               // apcroutine
                NULL,               // apc context
                &iosb,
                pFileDataPtr,
                FileInfo.EndOfFile.LowPart, 
                NULL,               //FILE_USE_FILE_POINTER_POSITION
                NULL);              // key

    if ( !NT_SUCCESS( status ) || iosb.Information <= 0 ) 
	{
		MonoOutStr(" Can not read ucode file ");
		ZwClose( hFile );
        hFile = NULL;
		ExFreePool(pSaveFileDataPtr);
		pFileDataPtr = NULL;
        return fResult;
    }

	if (LoadUcode(pFileDataPtr))
		fResult = TRUE;

	// Close the file and release the allocated buffer.
	ZwClose( hFile );
    hFile = NULL;
#if 0
	ExFreePool(pSaveFileDataPtr);
	pFileDataPtr = NULL;
#endif

	return fResult;
}
#endif


DWORD SwapDWORD(DWORD dwData)
{
	 dwData = (((dwData & 0x000000FF) << 24) | ((dwData & 0x0000FF00) << 8)
			|((dwData & 0x00FF0000) >> 8)|((dwData & 0xFF000000) >> 24));
	 return dwData;
}



BOOL ZivaHw_GetUserData(PHW_DEVICE_EXTENSION pHwDevExt)
{
	DWORD dwUserReadPtr;
	DWORD dwUserWritePtr;
	DWORD UserDataBufferStart;
	DWORD UserDataBufferEnd;
	int i =0;
	BOOL fCCData = FALSE;
	DWORD dwData=0;
	DWORD dwUserDataBufferSize=0;

	

	dwUserReadPtr  = DVD_ReadDRAM( USER_DATA_READ );
    dwUserWritePtr = DVD_ReadDRAM( USER_DATA_WRITE );
	UserDataBufferStart = DVD_ReadDRAM( USER_DATA_BUFFER_START );
	UserDataBufferEnd = DVD_ReadDRAM( USER_DATA_BUFFER_END );
    
	// Check for DRAM Buffer Overflow
    if ( dwUserReadPtr == 0xFFFFFFFF )
    {
        // Set Read Ptr
        DVD_WriteDRAM( USER_DATA_READ, dwUserWritePtr );
		MonoOutStr(" UsrBufferOverFlow ");
		pHwDevExt->fReSync = TRUE;
		return fCCData;
       
    }
	else
	{
		if(pHwDevExt->fReSync)
		{
			dwData = DVD_ReadDRAM( dwUserReadPtr );
			if( (dwData & 0xFFFF0000 ) == 0xFEED0000)
			{
				MonoOutStr(" ReSync After Overflow ");
				pHwDevExt->fReSync = FALSE;
			}
			else
				return fCCData;
		}

		pHwDevExt->dwUserDataBuffer[i++] = 0xB2010000;
		while( dwUserReadPtr != dwUserWritePtr )
		{
			
			dwData = DVD_ReadDRAM( dwUserReadPtr );
 			if(dwData == 0x434301F8)
			{
				MonoOutStr(" CCID ");
				fCCData = TRUE;
			}

			if( (dwData & 0xFFFF0000 ) == 0xFEED0000)
			{
				MonoOutStr(" Feed ");
				pHwDevExt->dwUserDataSize = dwData & 0x00000FFF;
				MonoOutStr(" SizeSpecifiedByFirst3Bytes ");
				MonoOutULong(pHwDevExt->dwUserDataSize);

			}
			else
			{
				pHwDevExt->dwUserDataBuffer[ i] = SwapDWORD(dwData);
				i++;
			}
				
			

			

			 

			// Adjust Data Pointer
			dwUserReadPtr += 4L;
			

			if ( dwUserReadPtr >= UserDataBufferEnd)
				dwUserReadPtr = UserDataBufferStart;
		}
	}
	DVD_WriteDRAM( USER_DATA_READ, dwUserReadPtr );
	dwUserDataBufferSize = i*4 ; 
	MonoOutStr(" DataReadFromUserBuffer ");
	MonoOutULong(dwUserDataBufferSize);



	return (fCCData);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\jbs\bt866.c ===
//
// MODULE  : BT866.C
//	PURPOSE : BrookTree Initialization code
//	AUTHOR  : JBS Yadawa
// CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//

#include "common.h"
#include "stdefs.h"
#include "i2c.h"
#include "bt856.h"
#define BTI2CADR	0x88
#define I2CBYTECNT	10                         

static BYTE Seq1[3] = {0x60,0,0};
static BYTE Seq2[13] = {0x62,0,0,0,0,0,0,0,0,0,0,0,0};
static BYTE Seq3[3] = {0x80,0,0};
static BYTE Seq4[13] = {0x82,0,0,0,0,0,0,0,0,0,0,0,0};
static BYTE Seq5[3] = {0xa0,0,0};
static BYTE Seq6[13] = {0xa2,0,0,0,0,0,0,0,0,0,0,0,0};
static BYTE Seq7[4] = {0xc2,0,0,0};
static BYTE Seq8[2] = {0xc8,0xcc};
static BYTE Seq9[2] = {0xca,0x91};
static BYTE Seq10[2] = {0xcc,0x20};
static BYTE Seq11[10] = {0xce,0,0,0,0,0x58,0x59,0x3e,0xe0,0x02};
static BYTE Seq12[13] = {0xe0,0,0,0,0,0,0,0,0,0,0,0,0};

void FARAPI BTInitEnc(void)
{
	I2CInitBus();
	I2CSettleBus();
}

void FARAPI BTSetVideoStandard(VSTANDARD std)
{                                    
	I2CSendSeq(BTI2CADR,3, Seq1); 
	I2CSendSeq(BTI2CADR,13, Seq2); 
	I2CSendSeq(BTI2CADR,3, Seq3); 
	I2CSendSeq(BTI2CADR,13, Seq4); 
	I2CSendSeq(BTI2CADR,3, Seq5); 
	I2CSendSeq(BTI2CADR,13, Seq6); 
	I2CSendSeq(BTI2CADR,4, Seq7); 
	I2CSendSeq(BTI2CADR,2, Seq8); 
	I2CSendSeq(BTI2CADR,2, Seq9); 
	I2CSendSeq(BTI2CADR,2, Seq10); 
	I2CSendSeq(BTI2CADR,10, Seq11); 
	I2CSendSeq(BTI2CADR,13, Seq12); 
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\jbs\codedma.h ===
//
// MODULE  : CODEDMA.H
//	PURPOSE : Code dma code
//	AUTHOR  : JBS Yadawa
// CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//

#ifndef __CODEDMA_H__
#define __CODEDMA_H__
#include "stdefs.h"

typedef struct DMADescriptor {
		DWORD			regionSize;
		DWORD			offset;
		WORD			selector;
		WORD			bufferID;
		DWORD			physical;
} DDS,  * LPDDS;

typedef struct tagCodeDma {
        BYTE  *      lpBuf;
	DWORD 		lpLog;
	DWORD 		CodeCtl;
	BOOL 		TransferCompleted;
	DWORD		WritePtr;
} CODEDMA,  *LPCODEDMA;

#define DMA_BUFFER_SIZE  8192
void FARAPI CodeDmaInterrupt(void);
BOOL FARAPI CodeDmaClose(void);
BOOL FARAPI CodeDmaOpen(BYTE *, DWORD);
DWORD FARAPI CodeDmaSendData(BYTE *pPacket, DWORD uLen);
void FARAPI CodeDmaStopTransfer(void);
BOOL FARAPI CodeDmaFlush(void);


#endif //__CODEDMA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\jbs\common.h ===
//
// MODULE  : COMMON.H
//	PURPOSE : Common definitions and functions
//	AUTHOR  : JBS Yadawa
// CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//

#ifndef __COMMON_H
#define __COMMON_H
//----------------------------------------------------------------------------
// COMMON.H
//----------------------------------------------------------------------------
// Description : small description of the goal of the module
//----------------------------------------------------------------------------
// Copyright SGS Thomson Microelectronics  !  Version alpha  !  Jan 1st, 1995
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                               Include files
//----------------------------------------------------------------------------
#include "strmini.h"
#include "stdefs.h"
#include "board.h"
#include "staudio.h"

#ifdef __cplusplus
extern "C" {
#endif

//----------------------------------------------------------------------------
//                             Exported Constants
//----------------------------------------------------------------------------
#define EVAL3520A
#define ON TRUE
#define OFF FALSE

// Card related definitions
//#define LSB      0x100         // to reach lsb register (A0 = 1)
#define LSB      1         // to reach lsb register (A0 = 1)
#define DATA_IN  0x18

//temp JBS
#define ERROR_CARD_NOT_FOUND 		      1
#define ERROR_NOT_ENOUGH_MEMORY       2
#define ERROR_COMMAND_NOT_IMPLEMENTED 3
#define DEFAULT_BASEIO                0x180
#define ERR_SKIP		                  0x116

#define TRAP _asm int 3;

// Audio States
#define AUDIO_POWER_UP  0 /* After reset */
#define AUDIO_INIT      1 /* Initialisation + test of the decoders */
#define AUDIO_STC_INIT  2 /* STC of audio decoder initialized */
#define AUDIO_DECODE    3 /* Normal decode */
#define AUDIO_FAST      4 /* "fast forward": use fast variable */
#define AUDIO_SLOW      5 /* Slow down mode: use tempo variable */
#define AUDIO_STEP      6 /* Used fo Step by step decoding */
#define AUDIO_PAUSE     7 /* Audio decoder has been pause  */

#define CTRL_AUDIO      0
#define CTRL_VIDEO      1
#define CTRL_BOTH       2

// STD definitions
#define STAUDIO         45
#define STVIDEO         35
#define STUFF           0
#define BOTH_AV         55

// Buffer Constants
//YOUUSS
//#define MAX_HEAD_SIZE   206  // Maximum Header Size is 206
//#define BUFFER_SIZE     16384 // Buffer Size is 16 kbytes

#define MAX_HEAD_SIZE   206  // Maximum Header Size is 206
#define BUFFER_SIZE     16384 // Buffer Size is 16 kbytes
#define AUDIO_BUFFER_SIZE     4096 // Audio Buffer Size is 4 kbytes
#define VIDEO_BUFFER_SIZE     16384 // Buffer Size is 16 kbytes

#define MAX_BUF_SIZE    BUFFER_SIZE + MAX_HEAD_SIZE // Maximum Buffer Size is 16 kbytes + 206 bytes

/* define the states of the video decoder */
typedef enum tagState {
	StatePowerup=0,
	StateInit,
	StateStartup,
	StatePause,
	StateDecode,
	StateFast,
	StateSlow,
	StateStep,
	StateWaitForDTS
}STATE;

typedef enum tagPlayMode {
	PlayModeSlow = 0,
	PlayModeNormal,
	PlayModeFast 
}PLAYMODE;


#define NO_ERROR        0                                  /* No error after the test */
#define NOT_DONE        1                                  /* requested action not done */

// ERRORS
/* Control related messages */
#define NOT_INITIALIZED 0x10  /* Control sequencer not initialized */
#define NO_FILE         0x11  /* No file opened */
#define ERRCLASS        0x12  /* Error for creation of the board class */
#define ERRCONTCLASS    0x13  /* Error for creation of the control class */

/* Video related messages */
#define NEW_ERR_V       0x100 /* Not possible to allocate Video instance */
#define BAD_REG_V       0x101 /* Bad access to video registers */
#define BAD_MEM_V       0x102 /* Bad memory test */
#define NO_IT_V         0x103 /* No video interrupt */
#define SMALL_BUF       0x104
#define TEMP_REF        0x105
#define FRAME_RATE      0x106
#define PICT_HEAD       0x107
#define FULL_BUF        0x108
#define TIME_OUT        0x109
#define BUF_EMPTY       0x10A
#define MAIN_PROF       0x10B
#define CHROMA          0x10C
#define HIGH_CCIR601    0x10D
#define HIGH_BIT_RATE   0x10E
#define DC_PREC         0x10F
#define BAD_EXT         0x110
#define S_C_ERR         0x111
#define DECCRASH        0x112 /* Decoder crashed after time-out */
#define NEW_ERR_FIF     0x113 /* Not possible to allocate Video instance */
#define ERR_FIFO_FULL   0x114
#define ERR_FIFO_EMPTY  0x115

/* Audio related messages */
#define NEW_ERR_A       0x200 /* Not possible to allocate Audio instance */
#define BAD_REG_A       0x201 /* Bad access to audio registers */
#define NO_IT_A         0x202 /* No audio interrupt */

#define NEW_ERR_D       0x300 /* Not possible to allocate Demux instance */
#define FILE_NOT_FOUND  0x301
#define NOT_ENOUGH_RAM  0x302 /* Not enough RAM available to load the bit stream */
typedef enum tagStreamType {
	VIDEO_STREAM=0x303 ,
	AUDIO_STREAM,
	VIDEO_PACKET,
	AUDIO_PACKET,
	VIDEO_PES,
	AUDIO_PES,
	SYSTEM_STREAM,
	DUAL_PES,
	DUAL_ES	
} STREAMTYPE;

#define END_OF_FILE     			0x30C /* all the file has been read */
#define END_OF_AUDIO_FILE     0x340 /* all the audio file has been read */
#define END_OF_VIDEO_FILE     0x380 /* all the video file has been read */
#define OK              			0x30D /* eof not reached            */
#define BAD_STREAM      			0x30E /* Not valid stream detected */

#define TOO_MANY_FILES  			0x30F  /* NbFiles > 2 */
#define TOO_FEW_FILES  				0x310  /* NbFiles < 1 */
#define VIDEO_FILE_NOT_FOUND  0x311  /* Cannot open Video File */
#define AUDIO_FILE_NOT_FOUND  0x312  /* Cannot open Video File */

/* Card related messages */
#define NEW_ERR_CARD    0x400 /* Not possible to allocate Card instance */
#define BAD_CARD_COM    0x401 /* Access to the command reg on board not possible */
#define BAD_CARD_TIME   0x402 /* Access to the time base not possible */
#define BAD_IT_VAL      0x403 /* requested interrupt not supported on this board */

/*MPEG Stream Related messages*/
#define NEW_ERR_M       0x500 /* Not possible to allocate Mpeg instance */

typedef struct bitstream_info
{
	BOOL modeMPEG2;    /* mpeg2 - TRUE = MPEG2 */
	BYTE      progSeq;      /* progressive_seq */
	BYTE      firstGOP[30]; /* gop_struct[30] - first GOP structure */
	WORD     countGOP;     /* count_gop */
	WORD     horSize;      /* hor_size */
	WORD     verSize;      /* vert_size */
	WORD     horDimension; /* hor_dim */
	WORD     verDimension; /* vert_dim */
	WORD     pixelRatio;   /* pixel_ratio */
	WORD     frameRate;    /* frame_rate */
	WORD     displayMode;  /* 1 if NTSC 0 if PAL */
	DWORD     bitRate;      /* bit_rate - bit rate from sequence header */
} BITSTREAM,  *P_BITSTREAM;

typedef struct image
{
	BYTE      pict_type;
	BYTE      pict_struc;
	WORD     tempRef;
	BYTE      first_field;
	BYTE      nb_display_field;
	int     pan_hor_offset[3];
	int     pan_vert_offset[3];
	int     buffer;
	DWORD     dwPTS;
	BOOL validPTS;
}  PICTURE,  *P_PICTURE;

typedef struct
{
	BYTE Skip ; // 2 bit field equivalent to CMD.SKP[1.0]
	BYTE Cmv;   //1 bit
	BYTE Tff;   //1 bit
	BYTE Rpt;   //1 bit
	BYTE Exe;   //1 bit
	BYTE Ovw;   //1 bit
	BYTE Ffh;   //4 bits
	BYTE Bfh;   //4 bits
	BYTE Pct;   //2 bits
	BYTE Seq;   //1 bit
	BYTE Ivf;
	BYTE Azz;
	BYTE Qst;
	BYTE Frm;
	BYTE Dcp;   //2 bits
	BYTE Pst;   //2 bits
	BYTE Ffv;   //2 bits
	BYTE Bfv;   //4 bits
	BYTE Mp2;//MP2;
} INSTRUCTION,  *PINSTRUCTION;

typedef struct {
	BYTE	        Ppr1;		   /* VID_PPR1 register value 3520a*/
	BYTE		      Ppr2;		   /* VID_PPR2 register value 3520a*/
	BYTE          Tis;		   /* VID_TIS register value 3520a*/
	BYTE          Pfh;		   /* VID_PFH register value 3520a*/
	BYTE          Pfv;		   /* VID_PFV register value 3520a*/
	BOOL			InvertedField; /* True when start dec on incorrect pol in to save R/2P in 3520a*/
	BYTE				  FistVsyncAfterVbv;// State variable gives first vsync to vbv position

	WORD         Ccf ;		   /* CTL register value*/
	BOOL			HalfRes;
	WORD         Ins1;		   /* INS1 register value*/
	WORD         Ins2;		   /* INS2 register value*/
	WORD         Cmd ;		   /* CMD register value*/

	INSTRUCTION NextInstr; /* Next Instruction ( contains all fields of instruction) */
	INSTRUCTION ZeroInstr; /* Next Instruction ( contains all fields of instruction) */
	WORD         Ctl ;		   /* CTL register value*/
	WORD         Gcf ;		   /* GCF register value*/
	WORD 				VideoBufferSize;// Size of Video Bit Buffer
	WORD 				AudioBufferSize;// Size of Audio Bit Buffer

	WORD         VideoState;

	WORD         ActiveState;
	WORD         DecodeMode;

	BITSTREAM   StreamInfo;
	BOOL     notInitDone;  /* not_init_done - TRUE = still init'ing */
	BOOL     useSRC;       /* switch_SRC - use sample rate converter */
	BYTE          currField;    /* cur_field */
	BYTE          fieldMode;    /* field_mode */
	BOOL     displaySecondField; /* change display to second in step by step */
	BOOL     perFrame;           /* indicates step by step decoding */
//	BOOL     pictureDecoded;
	BOOL     fastForward;    /* fast - TRUE = decode fast */
	BOOL     VsyncInterrupt; /* true = Vsync interrupt, FALSE = other interrupt */
	BOOL     FirstDTS;
	WORD         VsyncNumber;    /* number of consecutive Vsync without Dsync */
	BYTE          skipMode;       /* skip - 0, 1, 2, 3 */
	WORD         NotSkipped;
	WORD         intMask;        /* maskit_3500 - interrupt mask */
	WORD         intStatus;      /* int_stat_reg - interrupt status register */
	WORD         hdrFirstWord;   /* read_val - Contain the read data fifo */
	WORD         hdrNextWord;    /* shift_val -  Special case of header position = 8 */
	WORD         GOPindex;       /* gop_index */
	WORD         vbvReached;     /* vbv_done */
	WORD         vbvDelay;                  /* vbv_delay */
	WORD         decSlowDown;    /* tempo - slow down the decoder */
	WORD         currTempRef;    /* temp_ref - display temporal reference */
	WORD         frameStoreAttr; /* attr_fs */
	WORD         Xdo;            /* horizontal origin */
	WORD         Ydo;            /* vertical origin */
	WORD         Xd1;            /* horizontal end */
	WORD         Yd1;            /* vertical end */
	WORD         vbvBufferSize;  /* vbv_buffer_size */
	WORD         currCommand;    /* command */
	WORD         seqDispExt;     /* seq_display */
	int         currDCF;        /* DCF_val */
	int         halfVerFilter;  /* DCF_val_Half */
	int         fullVerFilter;  /* DCF_val_Full */
	BYTE          hdrHours;       /* hours */
	BYTE          hdrMinutes;     /* minutes */
	BYTE          hdrSeconds;     /* seconds */
	BYTE          pictTimeCode;   /* time_code_picture */
	BYTE          hdrPos;         /* point_posit - position of header to read */
	WORD         decAddr;        /* adcard_dec - decoder board address */
	WORD         needDataInBuff; /* empty */
	WORD         errCode;        /* err_nu */
	WORD         defaultTbl;     /* def_tab */
	WORD         nextInstr1;     /* make_ins1 */
	WORD         nextInstr2;     /* make_ins2 */
	WORD         currPictCount;  /* pict_count */
	WORD         latestPanHor;   /* latest_pan_hor */
	WORD         latestPanVer;   /* latest_pan_vert */
	int         pictDispIndex;  /* cnt_display */
	WORD         LastPipeReset;  /* last pipe reset in case of error */
	WORD         LastBufferLevel;/* last bit buffer level */
	DWORD         LastCdCount;    /* last CD count read */
	DWORD         LastScdCount;   /* last SCD count */
	WORD					BufferA;        /* 1st frame storage address*/
	WORD					BufferB;        /* 2d frame storage address*/
	WORD					BufferC;        /* 3d frame storage address*/
	PICTURE     pictArray[4];   /* pict_buf[4] */
	P_PICTURE   pDecodedPict;   /* decoded_pict_ptr */
	P_PICTURE   pCurrDisplay;   /* cur_display_ptr */
	P_PICTURE   pNextDisplay;   /* next_display_ptr */
} VIDEO,  *PVIDEO;

typedef struct
{
	WORD             OriginX;
	WORD             OriginY;
	WORD             EndX;
	WORD             EndY;
	BOOL         bAudioDecoding;
	BOOL         bVideoDecoding;
	VIDEO Video;
	AUDIO Audio;
	PVIDEO pVideo;
	PAUDIO pAudio;
}CARD,  *PCARD;
void FARAPI Delay(DWORD Microseconds);

typedef struct {
	WORD CtrlState;
	WORD ErrorMsg;
	WORD DecodeMode;   /* defines the way decoding is performed */
	WORD SlowRatio;    /* defines the slow down ratio (if any) */
	WORD ActiveState;  /* Memorise the active state in case of pause */
	BOOL AudioOn;
	BOOL VideoOn;
} CTRL,  *PCTRL;

extern PCARD pCard;

#ifdef __cplusplus
}
#endif

//------------------------------- End of File --------------------------------
#endif // #ifndef __COMMON_H



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\jbs\debug.h ===
//
// MODULE  : DEBUG.H
//	PURPOSE : Debugging functions 
//	AUTHOR  : JBS Yadawa
// CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//

#ifndef __DEBUG_H__
#define __DEBUG_H__
#include "stdefs.h"
#define DPF(x) DebugPrint(x)
// #define DPF(x)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\jbs\dmpeg.c ===
//
// MODULE  : DMPEG.C
//	PURPOSE : Entry point to lowlevel driver
//	AUTHOR  : JBS Yadawa
// CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//

#include "common.h"
#include "dmpeg.h"
#include "memio.h"
#include "codedma.h"
#include "sti3520A.h"
#include "staudio.h"
#include "board.h" 
#include "error.h"
#include "debug.h"
#include "i20reg.h"
#include "zac3.h"
#include "staudio.h"

#define CTRL_POWER_UP   0 // After reset
#define CTRL_INIT       1 // Initialisation + test of the decoders
#define CTRL_READY      2 // File openned
#define CTRL_INIT_SYNC  3 // Initial sync.: defines start of audio and video
#define CTRL_DECODE     4 // Normal decode
#define CTRL_IDLE       5 // idle state

#define SLOW_MODE       0
#define PLAY_MODE       1
#define FAST_MODE       2


CARD Card,  *pCard = NULL;
CTRL Ctrl,  *pCtrl;
DWORD OldlatchedSTC;
DWORD OldvideoPTS;

static BOOL Avsync;
static BOOL synchronizing;

static BYTE *tmpBuf;
static ULONG tmpBase;
static DWORD tmpAdr;

static BYTE I20Intr;
static BOOL IntCtrl(void);
static BYTE	Irq;

BOOL dmpgOpen(ULONG Base, BYTE *DmaBuf, DWORD PhysicalAddress)
{
	BOOL Found=FALSE;


    tmpBuf  = DmaBuf;
    tmpBase = Base;
    tmpAdr  = PhysicalAddress;

 	if(!BoardOpen(Base))
	{
                DPF((Trace,"Board initialization failed!!\n"));
	}
    // Open Audio and Video
	pCard = &Card;
	pCard->pVideo = &(pCard->Video);
	VideoOpen();
	pCard->pAudio = &(pCard->Audio);
	AudioOpen (pCard->pAudio);
	pCtrl = &Ctrl;
	pCtrl->ErrorMsg = NO_ERROR;
	pCtrl->CtrlState = CTRL_POWER_UP;
	pCtrl->AudioOn = FALSE;
	pCtrl->VideoOn = FALSE;
	Avsync = FALSE;

	BoardDisableIRQ();
	VideoInitDecoder(DUAL_PES);// Initialise video in PES by default
	pCtrl->CtrlState = CTRL_INIT_SYNC;
    VideoInitPesParser(VIDEO_STREAM);
    InitAC3Decoder();
    AudioInitPesParser(AUDIO_STREAM);
	BoardEnableIRQ();
	VideoMaskInt ();	   // Restore Video interrupt mask
    DPF((Trace,"Calling Code DMA open!!\n"));
    return CodeDmaOpen(DmaBuf, PhysicalAddress);
}

BOOL dmpgClose(void)
{
        DPF((Trace,"dmpgClose!!\n"));
	if(pCard == NULL)
		return FALSE;
	VideoClose( );
	AudioClose( );
	BoardClose();
	CodeDmaClose();
	return TRUE;
	
}


BOOL dmpgPlay()
{
        DPF((Trace,"dmpgPlay!!\n"));
	if(pCard == NULL)
		return FALSE;

	VideoRestoreInt ();	   // Restore Video interrupt mask
	pCtrl->DecodeMode = PLAY_MODE;
    AudioSetMode(pCtrl->DecodeMode, 0);
	VideoSetMode(pCtrl->DecodeMode, 0);
	if (pCtrl->CtrlState == CTRL_IDLE)
		pCtrl->CtrlState = CTRL_DECODE;
	VideoDecode();
    AudioDecode();
	AC3Command(AC3_UNMUTE); //ckw
	AC3Command(AC3_PLAY); //ckw
	AudioTransfer(TRUE); //ckw

	return TRUE;

}

void dmpgReset(void)
{
        dmpgPause();
        dmpgSeek();
        VideoMaskInt();
}

BOOL    dmpgPause(void)
{
        DPF((Trace,"dmpgPause!!\n"));

	if(pCard == NULL)
		return FALSE;
	switch(pCtrl->CtrlState) 
	{
		case CTRL_POWER_UP:
		case CTRL_INIT:
		case CTRL_READY:
			break;
		case CTRL_INIT_SYNC:
			AudioPause();
			VideoPause();
                        AudioTransfer(FALSE); //ckw
                        AC3Command(AC3_MUTE); //ckw
			pCtrl->AudioOn = FALSE;
			pCtrl->VideoOn = FALSE;
			pCtrl->ActiveState = CTRL_INIT_SYNC;
			pCtrl->CtrlState = CTRL_IDLE;
			break;
	case CTRL_DECODE:
			AudioPause();
			VideoPause();
                        AudioTransfer(FALSE); //ckw
                        AC3Command(AC3_MUTE); //ckw

			pCtrl->ActiveState = CTRL_DECODE;
			pCtrl->CtrlState = CTRL_IDLE;
			break;
	case CTRL_IDLE:
		break;
	}

	return TRUE;
}

BOOL    dmpgSeek(void)
{

        DPF((Trace,"dmpgSeek!!\n"));
	if(pCard == NULL)
		return FALSE;
		
	CodeDmaFlush();
	pCtrl->CtrlState = CTRL_INIT_SYNC;
	VideoSeekDecoder(DUAL_PES);
	return TRUE;
}

BOOL    dmpgStop(void)
{

    DPF((Trace,"dmpgStop!!\n"));
	if(pCard == NULL)
		return FALSE;
    VideoMaskInt();
    dmpgPause();
//    dmpgClose();
//    dmpgOpen(tmpBase, tmpBuf, tmpAdr);

	return TRUE;
}

UINT dmpgSendVideo(BYTE *pPacket, DWORD uLen)
{
//        DPF((Trace,"dmpgSendVideo!!\n"));
        UINT uRet;

	if(pCard == NULL)
		return FALSE;                                 
    
    
        uRet = (UINT)CodeDmaSendData(pPacket, uLen);

        return uRet;
}

UINT dmpgSendAudio(BYTE *pPacket, DWORD uLen)
{

        LONG abl, abf;

//        DPF((Trace,"dmpgSendAudio!!\n"));
    	if(pCard == NULL)
                return 0;
        abl = VideoGetABL();
        if((LONG)pCard->pVideo->AudioBufferSize - abl <= 2L)
        {
//            DebugPrint((DebugLevelTrace, "Audio Buffer FULL!!\n"));
            return 0;
        }

        abf = (pCard->pVideo->AudioBufferSize - abl -1) << 8;
//        DebugPrint((DebugLevelError,"SendAudio : %X %X %X %X %X %X, BBL = %x Size = %x\n",pPacket[0], pPacket[1], pPacket[2], pPacket[3], pPacket[4], pPacket[5], abl, pCard->pVideo->AudioBufferSize));
        if(abf < uLen)
        {
                SendAC3Data(pPacket, abf);
                return abf;
        }
        else
        {
                SendAC3Data(pPacket, uLen);
                return uLen;
        }
}

BOOL dmpgInterrupt(void)
{
	BOOL bRet = FALSE;

	I20Intr = memInByte(I20_INTRSTATUS);	
	memOutByte(I20_INTRSTATUS, I20Intr);

	if(I20Intr & IFLAG_CODEDMA)
	{   
		bRet = TRUE;
		CodeDmaInterrupt();
	}

	if(I20Intr & IFLAG_GIRQ1)
	{
		bRet = TRUE;
		IntCtrl();
	}
	return bRet;
}

void dmpgEnableIRQ()
{
   DPF((Trace,"IrqEnabled!!\n"));
   VideoRestoreInt();
   BoardEnableIRQ();
}

void dmpgDisableIRQ()
{
   DPF((Trace,"IrqDisabled!!\n"));
   VideoMaskInt();
   BoardDisableIRQ();
}

void CtrlInitSync(void)
{
	switch (pCtrl->CtrlState) {
	case CTRL_INIT_SYNC:
		/*
		Initial synchronisation: the video decoder is always started.
		In case of system stream, the STC is initialised in interrupt with first
		video PTS available the video state becomes VIDEO_DECODE
		When the STC becomes equal (or higher) than the first Audio PTS the audio
		decoding can be enabled
		In case of Audio only bitstreams the video is stopped and audio enabled
		In case of Video only bitstreams, the video decoding continues while
		audio is disabled
		*/
		if (VideoGetState() == StateDecode) {
			// the STC is initialized in interrupt with (first video PTS - 3 fields)
			DWORD             Stc;
			DWORD             PtsAudio;
			Stc = AudioGetSTC();
			if (AudioIsFirstPTS()) {
				PtsAudio = AudioGetPTS();
//				if (Stc >= PtsAudio)
				{
//					AudioDecode();
					pCtrl->CtrlState = CTRL_DECODE;
				}
			}
		}
		pCtrl->ErrorMsg = VideoGetErrorMsg();
		break;

	case CTRL_DECODE:	// Audio and Video decoders are running
		if (pCtrl->ErrorMsg == NO_ERROR)
			pCtrl->ErrorMsg = VideoGetErrorMsg();
		if (pCtrl->ErrorMsg == NO_ERROR)
			pCtrl->ErrorMsg = AudioGetErrorMsg();
		break;

	default :
		break;
	}
}


static BOOL IntCtrl(void)
{
	long     diff;
	WORD			lattency;
	BOOL	STIntr = FALSE;

	BoardEnterInterrupt();
	VideoMaskInt();
//	AudioMaskInt();

//	STIntr|=AudioAudioInt();
	STIntr = VideoVideoInt();

	if (Avsync) {
		CtrlInitSync();
		if (VideoIsFirstDTS()) {
			// True only on the start of decode of the first picture with an assoicated valid PTS
			DWORD FirstStc;

			FirstStc = VideoGetFirstDTS();
			AudioInitSTC(FirstStc);
			synchronizing = 0;
		}

		if (AudioGetState() == AUDIO_DECODE) {
			if (VideoIsFirstField()) {
				synchronizing++;
				if (synchronizing >= 20)
				{
					// We must verify the synchronisation of the video on the audio STC
					DWORD latchedSTC, videoPTS;
					WORD mode;

					latchedSTC = AudioGetVideoSTC();
					videoPTS = VideoGetPTS();
					mode =pCard->pVideo->StreamInfo.displayMode;
					lattency = 2200;	 /* 1.5 field duration for 60 Hz video */
					if (mode == 0) {
						lattency = 2700; /* 1.5 field duration for 50 Hz video */
					}
					diff = latchedSTC - videoPTS;
					OldlatchedSTC = latchedSTC;
					OldvideoPTS = videoPTS;

					//---- If desynchronized
					if (labs(diff) > (long)lattency) {
						if (diff < 0)
						{
							VideoRepeat ();
						}
						else
						{
							VideoSkip ();
						}
					}
					synchronizing = 0;
				}
			}
		}
	}

	BoardLeaveInterrupt();
	VideoRestoreInt();
//	AudioRestoreInt();
	return STIntr;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\jbs\error.h ===
//
// MODULE  : ERROR.H
//	PURPOSE : Error handling
//	AUTHOR  : JBS Yadawa
// CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//

#include "common.h"

#ifndef __ERROR_H
#define __ERROR_H
typedef enum {
	ERR_ERROR = 0,
	ERR_NO_ERROR,
	ERR_CM_NOT_PRESENT,
	ERR_CM_VERSION_NOT_OK,
	ERR_BOARD_NOT_FOUND,
	ERR_PCI_BIOS_NOT_PRESENT,
	ERR_INVALID_ADDRESS,
	ERR_NO_ADDRESS_AFFECTED,
	ERR_ADDRESS_IS_NOT_IO,
	ERR_CANNOT_ACCESS_PCI_CONFIG_DATA,
	ERR_NO_IRQ_AFFECTED,
	ERR_NOT_ENOUGH_MEMORY,
	ERR_NOT_ENOUGH_XMS_MEMORY,
	ERR_XMS_DRIVER_NOT_PRESENT,
	ERR_NOT_AN_MPEG_STREAM,
	ERR_BAD_STREAM,
	ERR_FILE_NOT_FOUND,
	ERR_NO_TEMPORAL_REFERENCE,
	ERR_HIGHER_THAN_CCIR601,
	ERR_MEM_WRITE_FIFO_NEVER_EMPTY,
	ERR_BIT_BUFFER_EMPTY,
	ERR_PICTURE_HEADER,
	ERR_FRAME_RATE_NOT_SUPPORTED,
	ERR_PROFILE_NOT_SUPPORTED,
	ERR_LEVEL_NOT_SUPPORTED,
	ERR_CHROMA_FORMAT_NOT_SUPPORTED,
	ERR_BITRATE_TO_HIGH,
	ERR_INTRA_DC_PRECISION,
	ERR_BAD_EXTENSION_SC,
	ERR_NO_VIDEO_INTR,
	ERR_NO_AUDIO_INTR,
	ERR_UNKNOWN_SC,
	ERR_BIT_BUFFER_FULL,
	ERR_HEADER_FIFO_EMPTY,
	ERR_PCI9060_REG_TEST_FAILED,
	ERR_ALTERA_REG_TEST_FAILED,
	ERR_VIDEO_REG_TEST_FAILED,
	ERR_AUDIO_REG_TEST_FAILED,
	ERR_TEST_MEMORY_FAILED,
	ERR_PLL_PROGRAMATION_FAILED,
	ERR_READ_FAILED,
	ERR_NOT_AN_EEPROM_FILE,
	ERR_FILE_NOT_FOUND_SUSIE_YUV,
	ERR_CD_VIDEO_PORT_TEST_FAILED,
	ERR_CD_VIDEO_MCI_TEST_FAILED,
	ERR_MCI_AUDIO_CD_TEST_FAILED,

	ERR_LAST_ERROR
} ERRORCODE;

void FARAPI ClearErrCode(void);
#ifdef ERROR
	#define ClearError() ClearErrCode()
#else
	#define ClearError()
#endif
void FARAPI SetErrCode(ERRORCODE lErrorCode);
#ifdef ERROR
	#define SetErrorCode(ErrorCode) SetErrCode(ErrorCode)
#else
	#define SetErrorCode(ErrorCode)
#endif

ERRORCODE FARAPI GetErrorCode(void);

void FARAPI DisplayErrMessage();
#ifdef ERROR
	#define DisplayErrorMessage() DisplayErrMessage()
#else
	#define DisplayErrMessage()
#endif
#endif // #ifndef __ERROR_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\jbs\debug.c ===
//
// MODULE  : DEBUG.C
//	PURPOSE : Debugging functions
//	AUTHOR  : JBS Yadawa
// CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\jbs\dmpeg.h ===
//
// MODULE  : DMPEG.H
//	PURPOSE : Lowlevel Entry point
//	AUTHOR  : JBS Yadawa
// CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//

#ifndef __DMPEG_H__
#define __DMPEG_H__
BOOL dmpgOpen(ULONG,BYTE *, DWORD);
BOOL dmpgClose(VOID);
BOOL dmpgPlay(VOID);
BOOL dmpgPause(VOID);
BOOL dmpgStop(VOID);
UINT dmpgSendVideo(BYTE *pPacket, DWORD uLen);
UINT dmpgSendAudio(BYTE *pPacket, DWORD uLen);
void dmpgVideoReset(void);
BOOL dmpgSeek(void);
void dmpgReset(void);
void dmpgDisableIRQ();
void dmpgEnableIRQ();
BOOL dmpgInterrupt();
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\jbs\i20reg.h ===
//
// MODULE  : I20REG.H
//	PURPOSE : PCI Registers
//	AUTHOR  : JBS Yadawa
// CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//

#ifndef __I20REG_H__
#define __I20REG_H__

#define ZVENDOR_ID 	0x11de
#define ZDEVICE_ID	0x6120
#define ADRSPACE		0x1000
#define INCTL			0x01
#define AUXCTL			0x02          

#define I20_GPREG	0x28
#define I20_GBREG	0x2C

#define I20_CODECTL	0x34
#define I20_CODEMP	0x38
#define I20_CODEMB	0x30

#define I20_INTRSTATUS	0x3F
#define I20_INTRCTRL		0x43
#define IFLAG_CODEDMA	0x10
#define IFLAG_GIRQ1		0x40
#define IFLAG_GIRQ0		0x20


#endif //__I20REG_H__

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\jbs\i2c.h ===
//
// MODULE  : I2C.H
//	PURPOSE : I2C Interface
//	AUTHOR  : JBS Yadawa
// CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//

#ifndef __I2C_H__
#define __I2C_H__
void FARAPI I2CInitBus(void);
void FARAPI I2CSendSeq(WORD unit, WORD num, BYTE  *data);
void FARAPI I2CSettleBus(void);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\jbs\error.c ===
//
// MODULE  : ERROR.C
//	PURPOSE : Error handling and display
//	AUTHOR  : JBS Yadawa
// CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//

#include <string.h>
#include <stdlib.h>
//#include "stdefs.h"
#include "error.h"
#include "debug.h"

struct {
	ERRORCODE Code;
	char     *Message;
} ErrorList[] = {
	{ERR_ERROR,                         "Error not specified !"},
	{ERR_NO_ERROR,                      "No error !"},
	{ERR_CM_NOT_PRESENT,                "Intel's Configuration Manager is not installed on your system !"},
	{ERR_CM_VERSION_NOT_OK,             "The Intel's Configuration Manager version installed on your computer is not supported !"},
	{ERR_BOARD_NOT_FOUND,               "The EVAL3520(A) board can not be found on your system !"},
	{ERR_PCI_BIOS_NOT_PRESENT,          "There is no PCI BIOS on your PC !"},
	{ERR_INVALID_ADDRESS,               "The board address is not valid !"},
	{ERR_NO_ADDRESS_AFFECTED,           "Address board has not been configured by PCI/PnP BIOS !"},
	{ERR_ADDRESS_IS_NOT_IO,             "The board address is not valid !"},
	{ERR_CANNOT_ACCESS_PCI_CONFIG_DATA, "Your PCI BIOS is not working as expected !"},
	{ERR_NO_IRQ_AFFECTED,               "IRQ Board has not been configured by PCI/PnP BIOS !"},
	{ERR_NOT_ENOUGH_MEMORY,             "Not enough memory available !"},
	{ERR_NOT_ENOUGH_XMS_MEMORY,         "Not enough XMS memory available !"},
	{ERR_XMS_DRIVER_NOT_PRESENT,        "XMS driver (HIMEM.SYS or equivalent) not installed !"},
	{ERR_NOT_AN_MPEG_STREAM,            "Not an MPEG stream !"},
	{ERR_BAD_STREAM,                    "Bad MPEG stream !"},
	{ERR_FILE_NOT_FOUND,                "Specified file not found !"},
	{ERR_NO_TEMPORAL_REFERENCE,         "No temporal frame corresponding to the displayed one !"},
	{ERR_HIGHER_THAN_CCIR601,           "Stream resolution is higher than CCIR601 !"},
	{ERR_MEM_WRITE_FIFO_NEVER_EMPTY,    "Memory write FIFO becomes never empty !"},
	{ERR_BIT_BUFFER_EMPTY,              "Video compressed data bit buffer is empty !"},
	{ERR_PICTURE_HEADER,                "Picture header not followed by a start code !"},
	{ERR_FRAME_RATE_NOT_SUPPORTED,      "Frame rate not supported by this application !"},
	{ERR_PROFILE_NOT_SUPPORTED,         "Profile not supported !"},
	{ERR_LEVEL_NOT_SUPPORTED,           "Level not supported !"},
	{ERR_CHROMA_FORMAT_NOT_SUPPORTED,   "Chroma format not supported !"},
	{ERR_BITRATE_TO_HIGH,               "Bit rate is to high for this application !"},
	{ERR_INTRA_DC_PRECISION,            "Intra DC precision..."},
	{ERR_BAD_EXTENSION_SC,              "Invalid extension start code !"},
	{ERR_NO_VIDEO_INTR,                 "Video interrupt is not working !"},
	{ERR_NO_AUDIO_INTR,                 "Audio interrupt is not working !"},
	{ERR_UNKNOWN_SC,                    "Unknown MPEG start code !"},
	{ERR_BIT_BUFFER_FULL,               "Video compressed data Bit buffer full !"},
	{ERR_HEADER_FIFO_EMPTY,             "Header FIFO is empty !"},
	{ERR_PCI9060_REG_TEST_FAILED,       "PCI9060 registers test failed !"},
	{ERR_ALTERA_REG_TEST_FAILED,        "ALTERA registers test failed !"},
	{ERR_VIDEO_REG_TEST_FAILED,         "Video registers test failed !"},
	{ERR_AUDIO_REG_TEST_FAILED,         "Audio registers test failed !"},
	{ERR_TEST_MEMORY_FAILED,            "Memory test failed !"},
	{ERR_PLL_PROGRAMATION_FAILED,       "Built in PLL programmation failed !"},
	{ERR_READ_FAILED,                   "Fail during a file read !"},
	{ERR_NOT_AN_EEPROM_FILE,            "Not an EEPROM file !"},
	{ERR_FILE_NOT_FOUND_SUSIE_YUV,      "File <susie.yuv> not found !"},
	{ERR_CD_VIDEO_PORT_TEST_FAILED,     "CD video port test failed !"},
	{ERR_CD_VIDEO_MCI_TEST_FAILED,      "CD video port test while MCI test failed !"},
	{ERR_MCI_AUDIO_CD_TEST_FAILED,      "MCI test while audio CD test failed !"},
	{ERR_LAST_ERROR,                    "This message should never be displayed !"}
};

static ERRORCODE gErrorCode = ERR_NO_ERROR;

//----------------------------------------------------------------------------
// Explicitly clear the error code
//----------------------------------------------------------------------------
void FARAPI ClearErrCode(void)
{
	gErrorCode = ERR_NO_ERROR;
}

//----------------------------------------------------------------------------
// Set the error code
//----------------------------------------------------------------------------
void FARAPI SetErrCode(ERRORCODE lErrorCode)
{
	if (gErrorCode == ERR_NO_ERROR)
		gErrorCode = lErrorCode;
}

//----------------------------------------------------------------------------
// Get the current error code
//----------------------------------------------------------------------------
ERRORCODE FARAPI GetErrorCode(void)
{
	return gErrorCode;
}

//----------------------------------------------------------------------------
// Display the error message matching the current error
//----------------------------------------------------------------------------
/*
void FARAPI DisplayErrMessage()
{
	WORD Position;

	//---- Look for the error message matching gErrorCode
	Position = 0;
	while (ErrorList[Position].Code != ERR_LAST_ERROR) {
		if (ErrorList[Position].Code == gErrorCode) {
			DPF(("ERROR => %s", ErrorList[Position].Message));
			ClearErrCode();
			return ;
		}
		Position++;
	}

}

*/

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\jbs\i2c.c ===
//
// MODULE  : I2C.C
//	PURPOSE : I2C Interface
//	AUTHOR  : JBS Yadawa
// CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//

#include "common.h"
#include "stdefs.h"
#include "memio.h"
#include "i2c.h"
#include "board.h"


#define I2CREG		0x44
#define SCL			0x01
#define SDA			0x02

BYTE i2cShadow;

void NEARAPI I2CSendBit(BOOL Data);
void NEARAPI I2CStart(void);
void NEARAPI I2CStop(void);
void NEARAPI I2CSendByte(BYTE data);
void NEARAPI I2CSendDataByte(BYTE data);
void NEARAPI I2CGetBit(BOOL  * data);
void NEARAPI I2CGetByte(BYTE  *data);
void NEARAPI I2CGetDataByte(BYTE  *data);

void FARAPI I2CInitBus(void)
{
	i2cShadow = 0;
	i2cShadow = SDA;
	memOutByte(I2CREG, i2cShadow);
	i2cShadow |= SCL;
	memOutByte(I2CREG, i2cShadow);
	
}

void FARAPI I2CSettleBus(void)
{
	int i;
	BOOL b;

	i2cShadow &= (~SDA);
	memOutByte(I2CREG, i2cShadow);
	Delay(50);
	i2cShadow &= (~SCL);
	i2cShadow = 0x00;
	memOutByte(I2CREG, i2cShadow);
	Delay(50);
	i2cShadow |= SCL;
	for(i=0; i<100; i++)
	{
		memOutByte(I2CREG, i2cShadow);
		Delay(50);
		memOutByte(I2CREG, i2cShadow);
		Delay(50);
	}
	i2cShadow |= SDA;
	memOutByte(I2CREG, i2cShadow);
	i2cShadow |= SCL;
	memOutByte(I2CREG, i2cShadow);
	Delay(50);
	b = memInByte(I2CREG);
	b = b >> 1;
	i = 0;
	while ((i < 2000) && (!b))
	{
		i2cShadow &= (!SCL);
		memOutByte(I2CREG, i2cShadow);
		i2cShadow |= SDA;
		memOutByte(I2CREG, i2cShadow);
		Delay(50);		
		i2cShadow |= SCL;
		memOutByte(I2CREG, i2cShadow);
		i2cShadow |= SDA;
		memOutByte(I2CREG, i2cShadow);
		Delay(50);		
		i++;
		b = memInByte(I2CREG) >> 1;
	}
	if(i >= 2000)
	{
//		MessageBox(GetFocus(), "I2C Bus is unstable!!","STHal", MB_OK);
	}
}

void NEARAPI I2CSendBit(BOOL Data)
{
	if(Data)
	{
		i2cShadow |= SDA;
		memOutByte(I2CREG, i2cShadow);
	}
	else
	{
		i2cShadow &= SCL;
		memOutByte(I2CREG, i2cShadow);
	}
	Delay(50);

	i2cShadow |= SCL;
	memOutByte(I2CREG, i2cShadow);
	Delay(50);
	i2cShadow &= SDA;
	memOutByte(I2CREG, i2cShadow);
	Delay(50);

}
extern volatile BYTE  *lpBase; 
volatile BYTE *i2cptr;

void NEARAPI I2CStart(void)
{   
	i2cShadow = 0;
	i2cShadow |= SDA;
	memOutByte(I2CREG, i2cShadow);
	i2cShadow |= SCL;
	memOutByte(I2CREG, i2cShadow);
	Delay(50);                           
	
	i2cShadow = memInByte(I2CREG);
	if(!(i2cShadow&(SDA|SCL)))
	{
//		MessageBox(GetFocus(), "I2C Bus Busy", "STHal", MB_OK);
	}
	i2cShadow &= SCL;
	memOutByte(I2CREG, i2cShadow);
	Delay(50);
	i2cShadow = 0x00;
	memOutByte(I2CREG, i2cShadow);
	Delay(50);
		
}

void NEARAPI I2CStop(void)
{
	i2cShadow &= SCL;
	memOutByte(I2CREG, i2cShadow);
	Delay(50);
	i2cShadow |= SCL;
	memOutByte(I2CREG, i2cShadow);
	Delay(50);
	i2cShadow |= SDA;
	memOutByte(I2CREG, i2cShadow);
	Delay(50);

}

void NEARAPI I2CSendByte(BYTE data)
{
	int i;
	for(i=7; i>=0; i--)
	{
		if(data & (1 << i))
			I2CSendBit(TRUE);
		else
			I2CSendBit(FALSE);
	}
}

void NEARAPI I2CSendDataByte(BYTE data)
{
	BOOL ack;
	I2CSendByte(data);
	I2CGetBit(&ack);
	if(ack)
	{
//		MessageBox(GetFocus(), "No Ack after send byte", "sthal", MB_OK);
	}
}

void NEARAPI I2CGetBit(BOOL  * data)
{
	i2cShadow |= SDA;
	memOutByte(I2CREG, i2cShadow);
	Delay(50);
	i2cShadow |= SCL;
	memOutByte(I2CREG, i2cShadow);
	Delay(50);
	i2cShadow = memInByte(I2CREG);
	Delay(50);
	i2cShadow &= SDA;
	memOutByte(I2CREG, i2cShadow);
	Delay(50);
	*data = (i2cShadow >> 1);	

}


void NEARAPI I2CGetByte(BYTE  *data)
{
	int 	i;
	BOOL	b;

	*data = 0x00;
	for (i = 7;  i >= 0;  i--)
	{
		I2CGetBit(&b);
		if(b)
			*data |= (1 << i);
	}
	
}

void NEARAPI I2CGetDataByte(BYTE  *data)
{
	I2CGetByte(data);
	I2CSendBit(TRUE);
}

void FARAPI I2CSendSeq(WORD unit, WORD num, BYTE  *data)
{
	WORD i;

	I2CStart();
	I2CSendDataByte((BYTE)(unit));
	for(i=0; i < num; i++)
	{
		I2CSendDataByte((BYTE)data[i]);
	}
	I2CStop();                                           
	
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\jbs\irq.c ===
//
// MODULE  : IRQ.C
//	PURPOSE : PIC programming
//	AUTHOR  : JBS Yadawa
// CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//

#include "stdefs.h"
#include <conio.h>
#include "irq.h"
#include "debug.h"

#define MASK1   0x21   // PIC 1 mask register
#define MASK2   0xA1   // PIC 2 mask register
#define EOI1    0x20   // PIC 1 eoi register
#define EOI2    0xA0   // PIC 2 eoi register
#define EOI     0x20   // Value to write in EOI1 or EOI2

//---- Interrupt number constants
#define IRQ0INT 0x08   // IRQ 0 is mapped on INT 0x08
#define IRQ8INT 0x70   // IRQ 8 is mapped on INT 0x70
#define SWITCH  8      // 1st PIC manages IRQ0-7, 2nd PIC manages IRQ8-15

//---- Processor Flag mask constant
#define IFFLAG  0x0200 // i80x86 Interrupt Flag mask

static BOOL ITAlreadyDisabled = FALSE; // Holds current P state of IT masking
static WORD Count = 0;

static BYTE NEARAPI HostGetITMask(BYTE IRQ);
static void NEARAPI HostSetITMask(BYTE IRQ, BYTE Mask);

void FARAPI HostDisableIT(void)
{
	_asm {
		push ax                  // saves ax
		pushf                    // push the flag register on the stack
		pop  ax                  // pop it in ax
		test ax, IFFLAG          // Test the Interrupt Flag (IF) bit
		pop  ax                  // restore ax
		jz   Disabled            // if not set goto Disabled
		cli                      // disable interrupts
	}
	ITAlreadyDisabled = FALSE; // Interrupts were not already disable
	return ;

Disabled :
	ITAlreadyDisabled = TRUE;  // Interrupts were already disable
}


void FARAPI HostEnableIT(void)
{
	if (!ITAlreadyDisabled)
		_enable();                 // enable interrupts (i80x86 sti instruction)
}

static void NEARAPI HostSetVect(BYTE SWInt, INTRFNPTR ISR)
{
	WORD FnSeg;
	WORD FnOff;


	FnSeg = FP_SEG(ISR);
	FnOff = FP_OFF(ISR);
	_asm {
		push ds
		mov	 dx, FnOff
		mov	 ds, FnSeg
		mov	 al, SWInt
		mov	 ah, 0x25
		int	 0x21
		pop	 ds
	}
}


static INTRFNPTR NEARAPI HostGetVect(BYTE SWInt)
{
	WORD FnSeg;
	WORD FnOff;

	_asm {
		push es
		mov	 al, SWInt
		mov	 ah, 0x35
		int	 0x21
		mov	 FnSeg, es
		mov	 FnOff, bx
		pop	 es
	}
	return (INTRFNPTR)(MK_FP(FnSeg, FnOff));
}


INTRFNPTR FARAPI HostSaveAndSetITVector(BYTE IRQ, INTRFNPTR ISR)
{
	BYTE      SWInt;
	INTRFNPTR OldISR;

	//---- If IRQ is managed by PIC2, Converts the IRQ to a SWInt (vector) nbr
	if (IRQ >= SWITCH)
		SWInt = IRQ8INT + (IRQ - SWITCH);
	else
		SWInt = IRQ0INT + IRQ;

	//---- Keep the old handler / set the new one
	HostDisableIT();
	OldISR = HostGetVect(SWInt);
	HostSetVect(SWInt, ISR);
	HostEnableIT();

	return OldISR;
}


void FARAPI HostRestoreITVector(BYTE IRQ, INTRFNPTR OldISR)
{
	BYTE INT;

	//---- If IRQ is managed by PIC2, Converts the IRQ to an INT (vector) nbr
	if (IRQ >= SWITCH)
		INT = IRQ8INT - SWITCH + IRQ;
	else
		INT = IRQ0INT + IRQ;

	//---- Set the old vector
	HostDisableIT();
	HostSetVect(INT, OldISR);
	HostEnableIT();
}

void FARAPI HostAcknowledgeIT(BYTE IRQ)
{
	//---- If the IRQ is managed by PIC2
	if (IRQ >= SWITCH)
		_outp(EOI2, EOI);

	//---- For PIC1 and PIC2
	_outp(EOI1, EOI);
}

static BYTE NEARAPI HostGetITMask(BYTE IRQ)
{
	BYTE Mask;

	HostDisableIT();
	if (IRQ >= SWITCH)
		Mask = _inp(MASK2); // PIC2
	else
		Mask = _inp(MASK1); // PIC1
	HostEnableIT();

	return Mask;
}

static void NEARAPI HostSetITMask(BYTE IRQ, BYTE Mask)
{
	HostDisableIT();
	if (IRQ >= SWITCH)
		_outp(MASK2, Mask); // PIC2
	else
		_outp(MASK1, Mask); // PIC1
	HostEnableIT();
}

void FARAPI HostMaskIT(BYTE IRQ)
{
	//---- If the IRQ is managed by PIC2
	HostDisableIT();
	if (IRQ >= SWITCH)
		_outp(MASK2, (BYTE)(_inp(MASK2) | (1 << (IRQ - SWITCH)))) ; // PIC2
	else
		_outp(MASK1, (BYTE)(_inp(MASK1) | (1 << IRQ))) ;            // PIC1
	HostEnableIT();
}

void FARAPI HostUnmaskIT(BYTE IRQ)
{
	//---- If the IRQ is managed by PIC2
	HostDisableIT();
	if (IRQ >= SWITCH)
		_outp(MASK2, (BYTE)(_inp(MASK2) & ~(1 << (IRQ - SWITCH)))) ; // PIC2
	else
		_outp(MASK1, (BYTE)(_inp(MASK1) & ~(1 << IRQ))) ;            // PIC1
	HostEnableIT();
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\jbs\irq.h ===
//
// MODULE  : IRQ.H
//	PURPOSE : PIC code
//	AUTHOR  : JBS Yadawa
// CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//

#ifndef __IRQ_H
#define __IRQ_H
//----------------------------------------------------------------------------
// IRQ.H
//----------------------------------------------------------------------------
// Description : small description of the goal of the module
//----------------------------------------------------------------------------
// Copyright SGS Thomson Microelectronics  !  Version alpha  !  Jan 1st, 1995
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                               Include files
//----------------------------------------------------------------------------
#include "stdefs.h"

#ifdef __cplusplus
extern "C" {
#endif

//----------------------------------------------------------------------------
//                               Exported Types
//----------------------------------------------------------------------------
typedef void (interrupt * INTRFNPTR)(void);
INTRFNPTR FARAPI HostSaveAndSetITVector(BYTE IRQ, INTRFNPTR ISR);
void FARAPI HostRestoreITVector(BYTE IRQ, INTRFNPTR OldISR);
void FARAPI HostAcknowledgeIT(BYTE IRQ);
void FARAPI HostMaskIT(BYTE IRQ);
void FARAPI HostUnmaskIT(BYTE IRQ);
void FARAPI HostDisableIT(void);
void FARAPI HostEnableIT(void);
#ifdef __cplusplus
}
#endif

//------------------------------- End of File --------------------------------
#endif // #ifndef __IRQ_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\jbs\memio.c ===
//
// MODULE  : MEMIO.C
//	PURPOSE : Memory mapped IO
//	AUTHOR  : JBS Yadawa
// CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//

#include "common.h"
#include "stdefs.h"
#include <conio.h>
#include "memio.h"

volatile PUCHAR   lpBase = NULL;
volatile PUSHORT lpWordPtr = NULL;
volatile PULONG   lpDwordPtr = NULL;

    
BOOL FARAPI AllocMemoryBase(DWORD addr, DWORD memsize)
{
	lpBase = (volatile PUCHAR)addr;
	lpWordPtr = (volatile PUSHORT)addr;
	lpDwordPtr = (volatile PULONG)addr;
	return TRUE;
}


BOOL FARAPI FreeMemoryBase(void)
{
	lpBase = NULL;
	return TRUE;
}


void FARAPI memOutByte(WORD reg, BYTE Val)
{
	lpBase[reg] = Val;
}

void FARAPI memOutWord(WORD reg, WORD Val)
{
	lpWordPtr[reg>>1] = Val;
}

void FARAPI memOutDword(WORD reg, DWORD Val)
{
	lpDwordPtr[reg>>2] = Val;
}

BYTE FARAPI memInByte(WORD reg)
{
	return lpBase[reg];
}      

WORD FARAPI memInWord(WORD reg)
{
	return lpWordPtr[reg>>1];
}

DWORD FARAPI memInDword(WORD reg)
{
	return lpDwordPtr[reg>>2];
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\jbs\memio.h ===
//
// MODULE  : MEMIO.H
//	PURPOSE : Memory Mapped IO
//	AUTHOR  : JBS Yadawa
// CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//

#ifndef __MEMIO_H__
#define __MEMIO_H__

BOOL FARAPI AllocMemoryBase(DWORD addr, DWORD memsize);
BOOL FARAPI FreeMemoryBase(void);
void FARAPI memOutByte(WORD reg, BYTE Val);
void FARAPI memOutWord(WORD reg, WORD Val);
void FARAPI memOutDword(WORD reg, DWORD Val);
BYTE FARAPI memInByte(WORD reg);
BYTE FARAPI memInByte(WORD reg);
WORD FARAPI memInWord(WORD reg);
DWORD FARAPI memInDword(WORD reg);
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\jbs\mpaudio.c ===
/*******************************************************************
*
*				 MPAUDIO.C
*
*				 Copyright (C) 1995 SGS-THOMSON Microelectronics.
*
*
*				 PORT/MINIPORT Interface Audio Routines
*
*******************************************************************/
#include "common.h"
#include "strmini.h"
#include "mpst.h"
#include "mpinit.h"
#include "mpaudio.h"
#include "debug.h"
#include "dmpeg.h"

void StubMpegEnableIRQ(PHW_STREAM_OBJECT pstrm);

ULONG miniPortCancelAudio(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;
	// TBD
	pMrb->Status = STATUS_SUCCESS;
	if(pHwDevExt->AudioDeviceExt.pCurrentSRB != NULL)
	{
#if 0
		// Still to send a packet
		pHwDevExt->AudioDeviceExt.pCurrentSRB->Status = MrbStatusCancelled;
      //MpegPortNotification(RequestComplete,AudioDevice,pHwDevExt,
			pHwDevExt->AudioDeviceExt.pCurrentSRB);
      //MpegPortNotification(NextRequest,AudioDevice,pHwDevExt);
		// Now kill the timer
      //MpegPortNotification(RequestTimerCall, AudioDevice,
                             pHwDevExt, NULL, 0);
		pHwDevExt->AudioDeviceExt.pCurrentSRB = NULL;
#endif
	}
	return dwErrCode; 	

}
ULONG miniPortAudioEnable(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;
	pHwDevExt = pHwDevExt;// Remove Warning 
	pMrb = pMrb; // Remove Warning 
//        mpstEnableAudio(TRUE);
	return dwErrCode; 	
}

VOID miniPortAudioGetProperty(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	PHW_DEVICE_EXTENSION phwdevext =
		((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);

	pSrb->Status = STATUS_SUCCESS;

	mpstCtrlCommandComplete(pSrb);
}

VOID miniPortAudioSetState(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	PHW_DEVICE_EXTENSION phwdevext =
		((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);

	pSrb->Status = STATUS_SUCCESS;

	mpstCtrlCommandComplete(pSrb);

}


ULONG miniPortAudioDisable(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	pHwDevExt = pHwDevExt;// Remove Warning 
	pMrb = pMrb; // Remove Warning 
//        mpstEnableAudio(FALSE);
	return dwErrCode; 	
}


ULONG miniPortAudioEndOfStream(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

    StreamClassStreamNotification(ReadyForNextStreamDataRequest,
				pMrb->StreamObject);
	
	StreamClassStreamNotification(StreamRequestComplete,
			pMrb->StreamObject,
			pMrb);

	pMrb->Status = STATUS_SUCCESS;  

	return dwErrCode; 	
}


ULONG miniPortAudioGetAttribute(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	pHwDevExt = pHwDevExt;// Remove Warning
#ifdef DEFINEME
	switch(pMrb->CommandData.pAttribute->Attribute)
	{
	// STB
		case MpegAttrAudioBass 					:						
		case MpegAttrAudioChannel 				:						
		case MpegAttrAudioMode	 				:						
		case MpegAttrMaximumAudioAttribute 	:						
		case MpegAttrAudioTreble 				:						
	         pMrb->Status = ;  
		break;

	// TBI
		case MpegAttrAudioVolumeLeft 	:						
            pMrb->CommandData.pAttribute->Value = 20;
				break;
		case MpegAttrAudioVolumeRight 	:						
            pMrb->CommandData.pAttribute->Value = 20;
			break;
	}
#endif
	return dwErrCode; 	
}


ULONG miniPortAudioGetStc(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;
	pHwDevExt = pHwDevExt; // Remove Warning 
	pMrb = pMrb; // Remove Warning 
#if 0
	// TBI
   *pMrb->CommandData.pPresentationDelta = pHwDevExt->AudioDeviceExt.audioSTC;
//   pMrb->Status = MrbStatusUnsupportedComand;
#endif
	return dwErrCode; 	
}



ULONG miniPortAudioPause(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	pMrb = pMrb; // Remove Warning 
//        mpstAudioPause();
	pHwDevExt->AudioDeviceExt.DeviceState = KSSTATE_PAUSE;
	return dwErrCode; 	
}

ULONG miniPortAudioPlay(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;
	pHwDevExt = pHwDevExt; // Remove Warning
	pMrb = pMrb; 
	pHwDevExt->AudioDeviceExt.DeviceState = KSSTATE_RUN;
	return dwErrCode; 	
}


ULONG miniPortAudioQueryInfo (PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

#ifdef DEFINEME
	pMrb -> CommandData.pDeviceInfo->DeviceState = 
			pHwDevExt->AudioDeviceExt.DeviceState;
	pMrb -> CommandData.pDeviceInfo->DecoderBufferSize = 
			mpstAudioDecoderBufferSize();
	pMrb -> CommandData.pDeviceInfo->DecoderBufferFullness = 
			mpstAudioDecoderBufferFullness();
#endif
	return dwErrCode; 	
}



ULONG miniPortAudioReset(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	// TBC
	pHwDevExt->AudioDeviceExt.DeviceState = KSSTATE_PAUSE;
	pMrb->Status = STATUS_SUCCESS;  
	return dwErrCode; 	
}


ULONG miniPortAudioSetAttribute(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	pHwDevExt = pHwDevExt; // Remove Warning 
#ifdef DEFINEME
	switch(pMrb->CommandData.pAttribute->Attribute)
	{
		case MpegAttrAudioBass 			:						
		case MpegAttrAudioChannel 		:						
		case MpegAttrAudioMode	 		:						
		case MpegAttrAudioTreble 		:						
			dwErrCode = ERROR_COMMAND_NOT_IMPLEMENTED;
		break;

	// TBI
		case MpegAttrMaximumAudioAttribute 	:						
		case MpegAttrAudioVolumeLeft 	:						
		case MpegAttrAudioVolumeRight	:						
			dwErrCode = ERROR_COMMAND_NOT_IMPLEMENTED;
			break;

    }
#endif
	return dwErrCode; 	
}


ULONG miniPortAudioSetStc(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;
	pHwDevExt = pHwDevExt; // Remove Warning 
	pMrb = pMrb; // Remove Warning 
#if 0
	// TBI
//   pMrb->Status = MrbStatusUnsupportedComand;
#endif
	return dwErrCode; 	
}


ULONG miniPortAudioStop (PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	// TBC
	if(pHwDevExt->AudioDeviceExt.pCurrentSRB != NULL)
	{
		// Still to send a packet
		pHwDevExt->AudioDeviceExt.pCurrentSRB->Status = STATUS_CANCELLED;     
      //MpegPortNotification(RequestComplete,AudioDevice,pHwDevExt,
	  //      pHwDevExt->AudioDeviceExt.pCurrentSRB);
      //MpegPortNotification(NextRequest,AudioDevice,pHwDevExt);

		// Now kill the timer
      //MpegPortNotification(RequestTimerCall, AudioDevice,
        //                     pHwDevExt, NULL, 0);
		pHwDevExt->AudioDeviceExt.pCurrentSRB = NULL;
	}

	pHwDevExt->AudioDeviceExt.DeviceState = KSSTATE_PAUSE;
	pMrb->Status = STATUS_SUCCESS;  
	return dwErrCode; 	
}




void AudioPacketStub(PHW_STREAM_OBJECT pstrm)
{


        dmpgDisableIRQ();

	StreamClassCallAtNewPriority(pstrm, pstrm->HwDeviceExtension,
							   Dispatch,
                        AudioTimerCallBack, pstrm);
}
VOID miniPortAudioPacket(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	PHW_DEVICE_EXTENSION pHwDevExt =
	 ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);

        PAUDIO_DEVICE_EXTENSION paudex = 
         &(((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension)->AudioDeviceExt);

	 //
	 // set up for initial parsing of the scatter gather packet.
	 //
 
         paudex->cPacket = paudex->cOffs = 0;

         if (!pSrb->CommandData.DataBuffer) {
             TRAP
             return(miniPortAudioEndOfStream(pSrb, pHwDevExt));
         }

         paudex->pPacket = &(pSrb->CommandData.DataBuffer->DataPacket);

         paudex->pCurrentSRB = pSrb;
 
         AudioPacketStub(pSrb->StreamObject);

}


VOID AudioTimerCallBack(PHW_STREAM_OBJECT pstrm)
{
    PHW_DEVICE_EXTENSION pdevext = pstrm->HwDeviceExtension;
    PHW_STREAM_REQUEST_BLOCK pSrb;

	ULONG	uSent;
        PAUDIO_DEVICE_EXTENSION paudex = &(pdevext->AudioDeviceExt);

        pSrb = paudex->pCurrentSRB;
//        dmpgEnableIRQ();

	if (!pSrb)
	{
		TRAP

		return;
	}

	do
	{

                uSent = mpstAudioPacket(pSrb);

                paudex->cOffs += uSent;

		//
		// check if we finished this packet.  If so, go on to the
		// next packet
		//

                if (paudex->cOffs >=
                        paudex->pPacket->DataPacketLength)
		{
                        paudex->pPacket++;



			//
			// reset the packet offset
			//

                        paudex->cOffs = 0;
                        paudex->cPacket = (ULONG)paudex->cPacket
                                + sizeof (KSDATA_PACKET);

			//
			// if we have finished all the packets, then we are done
			//

                        if (paudex->cPacket >=
				 pSrb->CommandData.DataBuffer->DataHeader.DataSize)           
			{

				pSrb->Status = STATUS_SUCCESS;
                                paudex->pCurrentSRB = 0;

				mpstCommandComplete(pSrb);

				return;

			}
		}

	} while (uSent);


	//
	// request a timer callback
	//

    StreamClassScheduleTimer(pstrm, pstrm->HwDeviceExtension,
                             AUDIO_PACKET_TIMER, AudioPacketStub, pstrm);
     
                                StreamClassCallAtNewPriority(pstrm, 
                                                    pstrm->HwDeviceExtension,
                                                    High,
                                                  StubMpegEnableIRQ,
                                                  pstrm);

}



ULONG mpstAudioPacket(PHW_STREAM_REQUEST_BLOCK pSrb)
{
        PAUDIO_DEVICE_EXTENSION paudex = 
         &(((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension)->AudioDeviceExt);
	PUCHAR pPacket;
	ULONG	uLen;
        PUCHAR p;

        ULONG cPacket;

        #define MAX_SIZE        8192

	//
	// find out how many bytes we can squeeze in
	//

        uLen = MAX_SIZE; //(BUF_FULL - VideoGetBBL()) * 256;
        if(!paudex->pPacket)
                return 0;

        if(paudex -> cOffs == 0)
        {

                p = (PUCHAR)(paudex->pPacket->DataPacket);
                paudex->cOffs = p[8]+13;

        }
        cPacket = paudex->pPacket->DataPacketLength - paudex->cOffs;

	uLen = uLen > cPacket ? cPacket : uLen;

        if(uLen > MAX_SIZE)
                uLen = MAX_SIZE;

// AVSYNC BUG to be fixed here.
// Dont Latch PTS every time.

	if (uLen)
	{

		//
		// send the bytes that we can fit
		//

                return dmpgSendAudio((LPBYTE)(((ULONG)paudex->pPacket->DataPacket) + paudex->cOffs), uLen);
	}

	return uLen;	
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\jbs\mpaudio.h ===
/*******************************************************************
*
*				 MPAUDIO.H
*
*				 Copyright (C) 1995 SGS-THOMSON Microelectronics.
*
*
*				 Prototypes for NPAUDIO.C
*
*******************************************************************/

#ifndef __MPAUDIO_H__
#define __MPAUDIO_H__
VOID miniPortAudioGetProperty(PHW_STREAM_REQUEST_BLOCK pSrb);
VOID miniPortAudioSetState(PHW_STREAM_REQUEST_BLOCK pSrb);

ULONG miniPortAudioStop (PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortAudioSetStc(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortAudioReset(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortAudioSetAttribute(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortAudioQueryInfo (PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortAudioPlay(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortAudioPause(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
VOID miniPortAudioPacket(PHW_STREAM_REQUEST_BLOCK pSrb);
ULONG miniPortAudioGetStc(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortAudioGetAttribute(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortAudioEndOfStream(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortAudioDisable(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortAudioEnable(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortCancelAudio(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
#endif //__MPAUDIO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\jbs\mpinit.c ===
/*******************************************************************
*
*				 MPINIT.C
*
*				 Copyright (C) 1995 SGS-THOMSON Microelectronics.
*
*
*				 PORT/MINIPORT Interface init routines
*
*******************************************************************/

#include "common.h"
#include "strmini.h"
#include <ntddk.h>
#include <windef.h>

#include "ksguid.h"

#include "uuids.h"
#include "mpeg2ids.h"

#include "mpinit.h"
#include "mpst.h"
#include "mpvideo.h"
#include "mpaudio.h"
#include "debug.h"
#include "mpegprop.h"
#include "mpegguid.h"
#include "dmpeg.h"

#define DMA_BUFFER_SIZE 8192

// Few globals here, should be put in the
// structure
BOOL bInitialized = FALSE;
VOID STREAMAPI StreamReceiveAudioPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID DummyTime(PHW_DEVICE_EXTENSION de);
VOID DummyHigh(PHW_DEVICE_EXTENSION de);
VOID DummyLow(PHW_DEVICE_EXTENSION de);

/********************************************************************
*		Function Name : DriverEntry
* 		Args : Context1 and Context2
* 		Returns : Return of MpegPortInitialize
*		Purpose : Entry Point into the MINIPORT Driver.
*
*		Revision History : Last modified on 25/8/95 by JBS
********************************************************************/
ULONG DriverEntry ( PVOID Arg1, PVOID Arg2 )
{

	HW_INITIALIZATION_DATA HwInitData;

	 DebugPrint((DebugLevelVerbose,"ST MPEG2 MiniDriver DriverEntry"));
         
//	 MpegPortZeroMemory(&HwInitData, sizeof(HwInitData));
	 HwInitData.HwInitializationDataSize = sizeof(HwInitData);

	//
	// Entry points for Port Driver
	//

	HwInitData.HwUnInitialize 	= HwUnInitialize;
	HwInitData.HwInterrupt		= HwInterrupt;

	HwInitData.HwReceivePacket	= AdapterReceivePacket;
	HwInitData.HwCancelPacket	= AdapterCancelPacket;
	HwInitData.HwRequestTimeoutHandler	= AdapterTimeoutPacket;

	HwInitData.DeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);
	HwInitData.PerRequestExtensionSize = sizeof(MRP_EXTENSION);
	HwInitData.FilterInstanceExtensionSize = 0;
        HwInitData.PerStreamExtensionSize = sizeof(STREAMEX);         // random size for code testing
        HwInitData.BusMasterDMA = FALSE;  
        HwInitData.Dma24BitAddresses = FALSE;
	HwInitData.BufferAlignment = 3;
    HwInitData.TurnOffSynchronization = FALSE;
        HwInitData.DmaBufferSize = DMA_BUFFER_SIZE;

	DebugPrint((DebugLevelVerbose,"SGS: call to portinitialize"));

	return (StreamClassRegisterAdapter(Arg1, Arg2,&HwInitData));

}

VOID AdapterCancelPacket(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	PHW_DEVICE_EXTENSION  pdevex = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
	BOOL fRestart = FALSE;  // determines whether this requires a restart
	BOOL fReset = FALSE;	// indicates we need to reset the device

	PHW_STREAM_REQUEST_BLOCK pSrbTmp;



	//
	// need to find this packet, pull it off our queues, and cancel it
	//

	if (pdevex->pCurSrb == pSrb)
	{
		pdevex->pCurSrb = NULL;
		fRestart = TRUE;
	}

	//
	// look for it in the main device queues
	//

	for (pSrbTmp = CONTAINING_RECORD((&(pdevex->pSrbQ)),
			HW_STREAM_REQUEST_BLOCK, NextSRB);
			pSrbTmp->NextSRB && pSrbTmp->NextSRB != pSrb;
			pSrbTmp = pSrbTmp->NextSRB);

	if (pSrbTmp->NextSRB ==pSrb)
	{

		TRAP

		pSrbTmp->NextSRB == pSrb->NextSRB;
	}

	if (pdevex->VideoDeviceExt.pCurrentSRB == pSrb)
	{

		StreamClassScheduleTimer(pSrb->StreamObject, pdevex,
             0, VideoPacketStub, pSrb->StreamObject);
		
		pdevex->VideoDeviceExt.pCurrentSRB = NULL;

		//
		// cancel the video timer
		//

		fRestart = TRUE;
		fReset = TRUE;
	}

	if (pdevex->AudioDeviceExt.pCurrentSRB == pSrb)
	{
		TRAP

		pdevex->AudioDeviceExt.pCurrentSRB = NULL;
		fRestart = TRUE;
	}

	if (fReset)
	{
		miniPortVideoReset(pSrb, pSrb->HwDeviceExtension);
	}

	pSrb->Status = STATUS_CANCELLED;

	switch (pSrb->Flags & (SRB_HW_FLAGS_DATA_TRANSFER |
				SRB_HW_FLAGS_STREAM_REQUEST))
	{
		//
		// find all stream commands, and do stream notifications
		//

	case SRB_HW_FLAGS_STREAM_REQUEST | SRB_HW_FLAGS_DATA_TRANSFER:

		StreamClassStreamNotification(ReadyForNextStreamDataRequest,
				pSrb->StreamObject);
	
		StreamClassStreamNotification(StreamRequestComplete,
				pSrb->StreamObject,
				pSrb);

		break;

	case SRB_HW_FLAGS_STREAM_REQUEST:

		TRAP

		mpstCtrlCommandComplete(pSrb);

		break;

	default:


		//
		// must be a device request
		//

		StreamClassDeviceNotification(ReadyForNextDeviceRequest,
				pSrb->HwDeviceExtension);
	
		StreamClassDeviceNotification(DeviceRequestComplete,
				pSrb->HwDeviceExtension,
				pSrb);

	}

	if (fRestart)
	{
		StreamStartCommand(pdevex);  
	}

}

VOID AdapterTimeoutPacket(PHW_STREAM_REQUEST_BLOCK pSrb)
{

	//
	// if we timeout while playing, then we need to consider this
	// condition an error, and reset the hardware, and reset everything
	//

	TRAP

	//
	// if we are not playing, and this is a CTRL request, we still
	// need to reset everything
	//

}

VOID AdapterOpenStream(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	PSTREAMEX strm = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;

	//
	// for now, just return success
	//

	pSrb->Status = STATUS_SUCCESS;

	switch (pSrb->StreamObject->StreamNumber)
	{
	case 0:

		//
		// this is the video stream
		//

		strm->pfnWriteData = (PFN_WRITE_DATA)miniPortVideoPacket;
		strm->pfnSetState = (PFN_WRITE_DATA)miniPortSetState;
		strm->pfnGetProp = (PFN_WRITE_DATA)miniPortGetProperty;
                pSrb->StreamObject->ReceiveDataPacket = (PVOID)StreamReceiveDataPacket;
		break;

        case 1:

		//
                // this is the audio stream
		//

		strm->pfnWriteData = (PFN_WRITE_DATA)miniPortAudioPacket;
                pSrb->StreamObject->ReceiveDataPacket = (PVOID)StreamReceiveAudioPacket;
                strm->pfnSetState = (PFN_WRITE_DATA)miniPortAudioSetState;
                strm->pfnGetProp = (PFN_WRITE_DATA)miniPortAudioGetProperty;
                break;

        default:

		TRAP

                pSrb->Status = STATUS_NOT_IMPLEMENTED;

	}

    pSrb->StreamObject->ReceiveControlPacket = (PVOID)StreamReceiveCtrlPacket;
        //pSrb->StreamObject->Dma = FALSE;
	pSrb->StreamObject->Pio = TRUE;

	StreamClassDeviceNotification(ReadyForNextDeviceRequest,
			pSrb->HwDeviceExtension);

	StreamClassDeviceNotification(DeviceRequestComplete,
			pSrb->HwDeviceExtension,
			pSrb);

/*
	 //
	 // switch on GUID
	 //

	 default:

		 //
		 // we don't own this GUID, so just fail the open stream
		 // call
		 //
		 */
}




VOID STREAMAPI AdapterReceivePacket(IN PHW_STREAM_REQUEST_BLOCK pSrb)
{
	PHW_DEVICE_EXTENSION pdevext =
	 ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);

	//
	// determine the type of packet.
	//

	switch (pSrb->Command)
	{

	case SRB_OPEN_STREAM:

		AdapterOpenStream(pSrb);

		break;

	case SRB_GET_STREAM_INFO:

		AdapterStreamInfo(pSrb);

		break;

	case SRB_INITIALIZE_DEVICE:

		HwInitialize(pSrb);

		break;

	case SRB_TURN_POWER_ON:
	case SRB_TURN_POWER_OFF:

	 pSrb->Status = STATUS_SUCCESS;
 
	 StreamClassDeviceNotification(ReadyForNextDeviceRequest,
			 pSrb->HwDeviceExtension);
 
	 StreamClassDeviceNotification(DeviceRequestComplete,
			 pSrb->HwDeviceExtension,
			 pSrb);
    break;
	default:

		TRAP


	 pSrb->Status = STATUS_NOT_SUPPORTED;
 
	 StreamClassDeviceNotification(ReadyForNextDeviceRequest,
			 pSrb->HwDeviceExtension);
 
	 StreamClassDeviceNotification(DeviceRequestComplete,
			 pSrb->HwDeviceExtension,
			 pSrb);
	}
/*
	 //
	 // switch on GUID
	 //

	 default:

		 //
		 // we don't own this GUID, so just fail the open stream
		 // call
		 //
		 */
}
KSDATAFORMAT hwfmtiMpeg2Vid
     = {
    sizeof (KSDATAFORMAT),
    0,
	 {0xe06d8020, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea},
	//MEDIATYPE_MPEG2_PES,
    //	MEDIASUBTYPE_MPEG2_VIDEO,
    {0xe06d8026, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea},
	//FORMAT_MPEG2Video,
	{0xe06d80e3, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea}
	};
KSDATAFORMAT hwfmtiMpeg2Aud
    = {
	sizeof (KSDATAFORMAT),
    0,
	//MEDIATYPE_MPEG2_PES,
	 {0xe06d8020, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea},
	//MEDIASUBTYPE_DOLBY_AC3_AUDIO,
    {0xe06d802c, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea},
	//FORMAT_WaveFormatEx
	 {0x05589f81, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x000, 0x55, 0x59, 0x5a},
	};

KSDATAFORMAT hwfmtiMpeg2Out;
    /* = {
	};
*/

static const KSPROPERTY_ITEM mpegVidPropItm[]={
	{0,
	TRUE,
	sizeof (KSPROPERTY),
	sizeof (BUF_LVL_DATA),
	FALSE,
	0,
	0,
	NULL,
	0,
	NULL
	}};

static const KSPROPERTY_SET mpegVidPropSet[] = {
		&KSPROPSETID_Mpeg2Vid,
		SIZEOF_ARRAY(mpegVidPropItm),
		(PKSPROPERTY_ITEM)mpegVidPropItm
		};


VOID AdapterStreamInfo(PHW_STREAM_REQUEST_BLOCK pSrb)
{

	PHW_DEVICE_EXTENSION pdevext =
	 ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);

	 PHW_STREAM_INFORMATION pstrinfo = &(pSrb->CommandData.StreamBuffer->StreamInfo);
     PBOOLEAN RelatedStreams;

	 ULONG ulTmp;

         pSrb->CommandData.StreamBuffer->StreamHeader.NumberOfStreams = 3;

	 //
	 // set up the stream info structures for the MPEG2 video
	 //

	 pstrinfo->NumberOfPossibleInstances = 1;
	 pstrinfo->DataFlow = KSPIN_DATAFLOW_IN;
	 pstrinfo->DataAccessible = TRUE;
	 pstrinfo->FormatInfo = &hwfmtiMpeg2Vid;

     RelatedStreams = (PBOOLEAN) (pstrinfo+
        pSrb->CommandData.StreamBuffer->StreamHeader.NumberOfStreams);

	 pstrinfo->RelatedStreams = RelatedStreams;

     RelatedStreams[0] = TRUE;  // related to self
	 RelatedStreams[1] = FALSE;
	 RelatedStreams[2] = TRUE;

     RelatedStreams += 4;

	 //
	 // set the property information
	 //

         pstrinfo->NumStreamPropArrayEntries = 0;
	 pstrinfo->StreamPropertiesArray = mpegVidPropSet;

	 pstrinfo++;

	 //
	 // set up the stream info structures for the MPEG2 audio
	 //

	 pstrinfo->NumberOfPossibleInstances = 1;
	 pstrinfo->DataFlow = KSPIN_DATAFLOW_IN;
         pstrinfo->DataAccessible = TRUE;
	 pstrinfo->FormatInfo = &hwfmtiMpeg2Aud;

	 pstrinfo->RelatedStreams = RelatedStreams;

	 pstrinfo->RelatedStreams[0] = FALSE;
	 pstrinfo->RelatedStreams[1] = TRUE;  // related to self
	 pstrinfo->RelatedStreams[2] = TRUE;

     RelatedStreams += 4;

	 pstrinfo++;

	 //
	 // set up the stream info structures for the MPEG2 NTSC stream
	 //

	 pstrinfo->NumberOfPossibleInstances = 1;
	 pstrinfo->DataFlow = KSPIN_DATAFLOW_OUT;
	 pstrinfo->DataAccessible = FALSE;
	 pstrinfo->FormatInfo = &hwfmtiMpeg2Out;
 
	 pstrinfo->RelatedStreams = RelatedStreams;

	 pstrinfo->RelatedStreams[0] = TRUE;
	 pstrinfo->RelatedStreams[1] = TRUE;
	 pstrinfo->RelatedStreams[2] = TRUE;  // related to self
 
	 pSrb->Status = STATUS_SUCCESS;
 
	 StreamClassDeviceNotification(ReadyForNextDeviceRequest,
			 pSrb->HwDeviceExtension);
 
	 StreamClassDeviceNotification(DeviceRequestComplete,
			 pSrb->HwDeviceExtension,
			 pSrb);
 

}

VOID STREAMAPI StreamReceiveDataPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb)
{
	PHW_DEVICE_EXTENSION pdevext =
	 ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);

//         DEBUG_ASSERT(pdevext);

	 //
	// determine the type of packet.
	//

	switch (pSrb->Command)
	{
	case SRB_WRITE_DATA:
		//
		// put it on the queue, and start dequeing if necessary
		//

		Enqueue(pSrb, pdevext);

		if (!pdevext->pCurSrb)
		{
			StreamStartCommand(pdevext);
		}

		break;

	default:

		//
		// invalid / unsupported command. Fail it as such
		//

		TRAP

		pSrb->Status = STATUS_NOT_IMPLEMENTED;
	
		StreamClassStreamNotification(ReadyForNextStreamDataRequest,
				pSrb->StreamObject);
	
		StreamClassStreamNotification(StreamRequestComplete,
				pSrb->StreamObject,
				pSrb);


	}
}


VOID STREAMAPI StreamReceiveAudioPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb)
{
	PHW_DEVICE_EXTENSION pdevext =
	 ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);

	 //
	// determine the type of packet.
	//

	pSrb->Status = STATUS_SUCCESS;

        ((PSTREAMEX)pSrb->StreamObject->HwStreamExtension)
                         ->pfnWriteData(pSrb);


}

VOID STREAMAPI StreamReceiveCtrlPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb)
{
	PHW_DEVICE_EXTENSION pdevext =
	 ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);

  //       DEBUG_ASSERT(pdevext);

	//
	// determine the type of packet.
	//

	switch (pSrb->Command)
	{
		case SRB_SET_STREAM_STATE:

			((PSTREAMEX)pSrb->StreamObject->HwStreamExtension)
				->pfnSetState(pSrb);

			break;

		case SRB_GET_STREAM_PROPERTY:

			((PSTREAMEX)pSrb->StreamObject->HwStreamExtension)
				->pfnGetProp(pSrb);

            break;

		default:

			//
			// invalid / unsupported command. Fail it as such
			//
	
			TRAP
	
			pSrb->Status = STATUS_NOT_IMPLEMENTED;
		
			mpstCtrlCommandComplete(pSrb);			

	}
}

VOID mpstCtrlCommandComplete(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	StreamClassStreamNotification(
			ReadyForNextStreamControlRequest,
			pSrb->StreamObject);

	StreamClassStreamNotification(StreamRequestComplete,
			pSrb->StreamObject,
			pSrb);
}
			
#if 0

VOID STREAMAPI StreamReceiveDataPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb)
{
	PHW_DEVICE_EXTENSION pdevext =
	 ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);

	 DEBUG_ASSERT(pdevext);

	// determine the type of packet.
	//

	switch (pSrb->Command)
	{
	case SRB_WRITE_DATA:
	case SRB_SET_STREAM_STATE:

		//
		// put it on the queue, and start dequeing if necessary
		//

		Enqueue(pSrb, pdevext);

		if (!pdevext->pCurSrb)
		{
			StreamStartCommand(pdevext);
		}

		break;

	default:

		//
		// invalid / unsupported command. Fail it as such
		//

		TRAP

		pSrb->Status = STATUS_NOT_IMPLEMENTED;
	
		StreamClassStreamNotification(ReadyForNextStreamRequest,
				pSrb->StreamObject);
	
		StreamClassStreamNotification(StreamRequestComplete,
				pSrb->StreamObject,
				pSrb);


	}
/*
	 //
	 // switch on GUID
	 //

	 default:

		 //
		 // we don't own this GUID, so just fail the open stream
		 // call
		 //
		 */
}

#endif

void Enqueue (PHW_STREAM_REQUEST_BLOCK pSrb,
		PHW_DEVICE_EXTENSION pdevext)
{

	PHW_STREAM_REQUEST_BLOCK pSrbTmp;

	//
	// enqueue the given SRB on the device extension queue
	//

	for (pSrbTmp = CONTAINING_RECORD((&(pdevext->pSrbQ)),
			HW_STREAM_REQUEST_BLOCK, NextSRB);
			pSrbTmp->NextSRB;
			pSrbTmp = pSrbTmp->NextSRB);


	pSrbTmp->NextSRB = pSrb;
	pSrb->NextSRB = NULL;
	
}

PHW_STREAM_REQUEST_BLOCK Dequeue(PHW_DEVICE_EXTENSION pdevext)
{
	PHW_STREAM_REQUEST_BLOCK pRet = NULL;

	if (pdevext->pSrbQ)
	{
		pRet = pdevext->pSrbQ;
		pdevext->pSrbQ = pRet->NextSRB;
	}

	return(pRet);
}


VOID StreamStartCommand (PHW_DEVICE_EXTENSION pdevext)
{

	PHW_STREAM_REQUEST_BLOCK pSrb;

	//
	// See if there is something to dequeue
	//

	if (!(pSrb=Dequeue(pdevext)))
	{
		return;
	}

	pdevext->pCurSrb = pSrb;

	switch (pSrb->Command)
	{
	case SRB_WRITE_DATA:

		((PSTREAMEX)pSrb->StreamObject->HwStreamExtension)
				->pfnWriteData(pSrb);

		break;

	default:

		TRAP

	}

}

VOID AdapterCloseStream(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    DEBUG_BREAKPOINT();
 /*
	 //
	 // switch on GUID
	 //

	 default:

		 //
		 // we don't own this GUID, so just fail the open stream
		 // call
		 //
		 */
}
         
/********************************************************************
*		Function Name : HwInitialize
* 		Args : Pointer to Device Ext. 
* 		Returns : TRUE if sucessful, FALSE otherwise
*		Purpose : Initialize the Board, Setup IRQ, Initialize the
* 					 Control and Card structures.
*
*		Revision History : Last modified on 19/8/95 by JBS
********************************************************************/

NTSTATUS HwInitialize (
		 IN PHW_STREAM_REQUEST_BLOCK pSrb)
{
        NTSTATUS Stat;
        STREAM_PHYSICAL_ADDRESS adr;
        ULONG   Size;
        ULONG i;
        PUCHAR  pDmaBuf;


	PPORT_CONFIGURATION_INFORMATION ConfigInfo = pSrb->CommandData.ConfigInfo;
	PHW_DEVICE_EXTENSION pHwDevExt =
	      (PHW_DEVICE_EXTENSION)ConfigInfo->HwDeviceExtension;

        DebugPrint((DebugLevelVerbose,"Entry : HwInitialize()\n"));
        bInitialized = TRUE;

        if (ConfigInfo->NumberOfAccessRanges < 1)
	{
		DebugPrint((DebugLevelVerbose,"ST3520: illegal config info"));

		pSrb->Status = STATUS_NO_SUCH_DEVICE;
      goto exit;
	}

    //
    // testing only !!!!
    //

    StreamClassCallAtNewPriority(NULL, pHwDevExt, Low, DummyLow, pHwDevExt);

    StreamClassScheduleTimer(NULL, pHwDevExt,  1*1000*1000, DummyTime, pHwDevExt);


        DebugPrint((DebugLevelVerbose, "No of access ranges = %lx", ConfigInfo->NumberOfAccessRanges));
        pHwDevExt->ioBaseLocal          = (PUSHORT)(ConfigInfo->AccessRanges[0].RangeStart.LowPart);
        DebugPrint((DebugLevelVerbose, "Memory Range = %lx\n", pHwDevExt->ioBaseLocal));
        DebugPrint((DebugLevelVerbose, "IRQ = %lx\n", ConfigInfo->BusInterruptLevel));
        pHwDevExt->Irq  = (USHORT)(ConfigInfo->BusInterruptLevel);
	pHwDevExt->VideoDeviceExt.videoSTC = 0;
	pHwDevExt->AudioDeviceExt.audioSTC = 0;
	pHwDevExt->AudioDeviceExt.pCurrentSRB = NULL;
	pHwDevExt->VideoDeviceExt.pCurrentSRB = NULL;
	pHwDevExt->VideoDeviceExt.DeviceState = -1;
	pHwDevExt->AudioDeviceExt.DeviceState = -1;
	pHwDevExt->AudioDeviceExt.pCurrentSRB = NULL;
	pHwDevExt->VideoDeviceExt.pCurrentSRB = NULL;
	pHwDevExt->VideoDeviceExt.pCurrentSRB = NULL;
	pHwDevExt->AudioDeviceExt.pCurrentSRB = NULL;
	pHwDevExt->VideoDeviceExt.DeviceState = KSSTATE_PAUSE;
	pHwDevExt->AudioDeviceExt.DeviceState = KSSTATE_PAUSE;

	ConfigInfo->StreamDescriptorSize = 3 * (sizeof (HW_STREAM_INFORMATION) +
			4 * sizeof (BOOLEAN)) + sizeof (HW_STREAM_HEADER);
        Stat = STATUS_SUCCESS;

        pDmaBuf = StreamClassGetDmaBuffer(pHwDevExt);
        adr = StreamClassGetPhysicalAddress(pHwDevExt, NULL, pDmaBuf, DmaBuffer, &Size);
        if(dmpgOpen((ULONG)(pHwDevExt->ioBaseLocal), pDmaBuf, (ULONG)(adr.LowPart)))
                Stat = STATUS_SUCCESS;
        else
                Stat = STATUS_NO_SUCH_DEVICE;
        DebugPrint((DebugLevelVerbose,"Exit : HwInitialize()\n"));

		  pSrb->Status = Stat;

exit:
	     StreamClassDeviceNotification(ReadyForNextDeviceRequest,
			 pSrb->HwDeviceExtension);
 
	     StreamClassDeviceNotification(DeviceRequestComplete,
			 pSrb->HwDeviceExtension,
			 pSrb);
}

VOID DummyLow(PHW_DEVICE_EXTENSION pHwDevEx)
{

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    StreamClassCallAtNewPriority(NULL, pHwDevEx, LowToHigh, DummyHigh, pHwDevEx);
}
   
VOID DummyHigh(PHW_DEVICE_EXTENSION de)
{
    ASSERT(KeGetCurrentIrql() > DISPATCH_LEVEL);
	DebugPrint((DebugLevelError,"Went from Low to High!!!"));
    

}

VOID DummyTime(PHW_DEVICE_EXTENSION de)
{

    ASSERT(KeGetCurrentIrql() > DISPATCH_LEVEL);
	DebugPrint((DebugLevelError,"Timer fired!!!"));
}

/********************************************************************
*		Function Name : HwUnInitialize
* 		Args : Pointer to Device Ext. 
* 		Returns : TRUE if sucessful, FALSE otherwise
*		Purpose : Uninitialize the H/W and data initialized 
*	 				 by HwInitialize Function
*
*		Revision History : Last modified on 15/7/95 JBS
********************************************************************/

BOOLEAN HwUnInitialize ( IN PVOID DeviceExtension)
{
        dmpgClose();
	return TRUE;
}
#if 0
/********************************************************************
*		Function Name : HwFindAdapter
* 		Args : Pointer to Device Ext, Bus Information, ArgString,
*				 port configuration information, Again
* 		Returns : MP_FOUND, NOT FOUND OR ERROR
*		Purpose : Finds the H/W Adapter on the system
*
*		Revision History : Last modified on 15/7/95 by JBS
********************************************************************/
MP_RETURN_CODES	HwFindAdapter (
					IN PVOID DeviceExtension,
					IN PVOID HwContext, 
					IN PVOID BusInformation,
					IN PCHAR ArgString, 
					IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
					OUT PBOOLEAN Again
					)
{
	// Code to find the adapter has to be added.	- JBS

    ULONG   ioAddress;
    ULONG   IrqLevel; // Temp code to be put in HW_DEV_EXT
    PUSHORT  ioBase;
	PHW_DEVICE_EXTENSION	pHwDevExt = (PHW_DEVICE_EXTENSION)DeviceExtension;
   *Again = FALSE; // Only one card is allowed in the system
   DebugPrint((DebugLevelVerbose, "Entry : HwFindAparter()\n"));
	if(ConfigInfo->Length != sizeof(PORT_CONFIGURATION_INFORMATION))
	{
                DebugPrint((DebugLevelError,"Find Adapter : Different Size!!"));
		return MP_RETURN_BAD_CONFIG;		
	}

	 ConfigInfo->DmaChannels[VideoDevice].DmaChannel = MP_UNINITIALIZED_VALUE;
	 ConfigInfo->DmaChannels[AudioDevice].DmaChannel = MP_UNINITIALIZED_VALUE;

    if(ConfigInfo->AccessRanges[0].RangeLength == 0){
        // IO Base was not specified in the registry
        DebugPrint((DebugLevelError, "FindAdapter: IO Base not specified\n"));
        return MP_RETURN_INSUFFICIENT_RESOURCES;
    }

//       DebugPrint((DebugLevelVerbose,"3520 Address Physical = %lx\n", ConfigInfo->AccessRanges[2].RangeStart));
//       DebugPrint((DebugLevelVerbose,"PCI9060 Address Physical = %lx\n", ConfigInfo->AccessRanges[1].RangeStart));

    ioAddress = MPEG_PORT_CONVERT_PHYSICAL_ADDRESS_TO_ULONG(
                                ConfigInfo->AccessRanges[2].RangeStart
                                );
    ConfigInfo->AccessRanges[0].RangeStart = ConfigInfo->AccessRanges[2].RangeStart ;
         DebugPrint((DebugLevelVerbose,"3520 Base Address = %lx\n", ioAddress));

    if( (ConfigInfo->Interrupts[VideoDevice].BusInterruptLevel == MP_UNINITIALIZED_VALUE) &&
        (ConfigInfo->Interrupts[AudioDevice].BusInterruptLevel == MP_UNINITIALIZED_VALUE) &&
        DebugPrint((DebugLevelError, "FindAdapter: Interrupt not specfied correctly\n"));
        return MP_RETURN_INVALID_INTERRUPT;
    }

    IrqLevel = ConfigInfo->Interrupts[VideoDevice].BusInterruptLevel;
         DebugPrint((DebugLevelVerbose,"Video Interrupt = %lx\n", IrqLevel));

//    ConfigInfo->Interrupts[AudioDevice].BusInterruptLevel = IrqLevel;
    ioBase = MpegPortGetDeviceBase(
                    pHwDevExt,                  // HwDeviceExtension
                    ConfigInfo->AdapterInterfaceType,   // AdapterInterfaceType
                    ConfigInfo->SystemIoBusNumber,      // SystemIoBusNumber
                    ConfigInfo->AccessRanges[0].RangeStart,
                    0x4,                    // NumberOfBytes
                    TRUE                   // InIoSpace - Memory mapped
                    );

  DebugPrint((DebugLevelVerbose,"3520 Base Address  = %lx\n", ioBase));
	pHwDevExt->ioBaseLocal		= ioBase;

    ioBase = MpegPortGetDeviceBase(
                    pHwDevExt,                  // HwDeviceExtension
                    ConfigInfo->AdapterInterfaceType,   // AdapterInterfaceType
                    ConfigInfo->SystemIoBusNumber,      // SystemIoBusNumber
                    ConfigInfo->AccessRanges[1].RangeStart,
                    0x4,                    // NumberOfBytes
                    TRUE                               // InIoSpace - Memory mapped
                    );

  DebugPrint((DebugLevelVerbose,"PCI9060 Address = %lx\n", ioBase));

	pHwDevExt->ioBasePCI9060 = ioBase;
	pHwDevExt->Irq	= IrqLevel;
	pHwDevExt->VideoDeviceExt.videoSTC = 0;
	pHwDevExt->AudioDeviceExt.audioSTC = 0;
	pHwDevExt->AudioDeviceExt.pCurrentSRB = NULL;
	pHwDevExt->VideoDeviceExt.pCurrentSRB = NULL;
	pHwDevExt->VideoDeviceExt.DeviceState = -1;
	pHwDevExt->AudioDeviceExt.DeviceState = -1;
	pHwDevExt->AudioDeviceExt.pCurrentSRB = NULL;
	pHwDevExt->VideoDeviceExt.pCurrentSRB = NULL;
	 DebugPrint((DebugLevelVerbose, "Exit : HwFindAparter()"));

	return MP_RETURN_FOUND;

}

#endif
/********************************************************************
*		Function Name : HwInterrupt
* 		Args : Pointer to Device Ext.
* 		Returns : TRUE or FALSE 
*		Purpose : Called by port driver if there is an interrupt
* 					 on the IRQ line. Must return False if it does not
*               Processes the interrupt
*
*		Revision History : Last modified on 15/7/95 by JBS
********************************************************************/
BOOLEAN HwInterrupt ( IN PVOID pDeviceExtension )
{
	// Call the interrupt handler should check if the interrupt belongs to
	BOOLEAN bRetValue;

        if(!bInitialized)
            return FALSE;

        bRetValue = dmpgInterrupt();

        return bRetValue;
}

/********************************************************************
*		Function Name : HwStartIo
* 		Args : Pointer to Device Ext, Mini-Port Request Block (MRB)
* 		Returns : TRUE or FALSE 
*		Purpose : Main fuction which accepts the MRBs from port Driver
*	 				 Port driver calls this function for all the commands
*					 it wants to execute
*
*		Revision History : Last modified on 15/7/95 JBS
********************************************************************/
BOOLEAN	HwStartIo (
				IN PVOID DeviceExtension, 
				PHW_STREAM_REQUEST_BLOCK pMrb
				)
{
	pMrb->Status = STATUS_SUCCESS;  
	switch (pMrb->Command)
	{
#if 0
		case MrbCommandAudioCancel :
					miniPortCancelAudio(pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;

		case MrbCommandVideoCancel	:
					miniPortCancelVideo(pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;
		case MrbCommandVideoClearBuffer :
					miniPortClearVideoBuffer(pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
			  break;

		case MrbCommandAudioEndOfStream	:
					miniPortAudioEndOfStream(pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;
		case MrbCommandVideoEndOfStream	:
					miniPortVideoEndOfStream(pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;
		case MrbCommandAudioGetProperty			:
					miniPortAudioGetAttribute (pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;
			

		case MrbCommandVideoGetProperty			:
					miniPortVideoGetAttribute (pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;

		case MrbCommandAudioGetOnboardClock					:
					miniPortAudioGetStc(pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;
		case MrbCommandVideoGetOnboardClock					:
					miniPortVideoGetStc(pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;

		case MrbCommandAudioPacket					:
					miniPortAudioPacket(pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;
		case MrbCommandVideoPacket					:
					miniPortVideoPacket(pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;
		case MrbCommandAudioPause					:
					miniPortAudioPause(pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;

		case MrbCommandVideoPause					:
					miniPortVideoPause(pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;

		case MrbCommandAudioPlay					:
					miniPortAudioPlay(pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;

		case MrbCommandVideoPlay					:
					miniPortVideoPlay(pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;
			
		case MrbCommandAudioQueryDevice				:
					miniPortAudioQueryInfo (pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;

		case MrbCommandVideoQueryDevice				:
					miniPortVideoQueryInfo (pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;
			
		case MrbCommandAudioReset					:
					miniPortAudioReset (pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;

		case MrbCommandVideoReset					:
					miniPortVideoReset (pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;

		case MrbCommandAudioSetProperty			:
					miniPortAudioSetAttribute ( pMrb , (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;

		case MrbCommandAudioUpdateOnboardClock					:
					miniPortAudioSetStc ( pMrb , (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;
		case MrbCommandVideoUpdateOnboardClock					:
					miniPortVideoSetStc ( pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;

		case MrbCommandAudioStop					:
					miniPortAudioStop( pMrb , (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;

		case MrbCommandVideoStop					:
					miniPortVideoStop( pMrb , (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;
#endif
	}
	return TRUE;
}



VOID HostDisableIT(VOID)
{
		// Has to be implemented !! - JBS
}

VOID HostEnableIT(VOID)
{
		// Has to be implemented !! - JBS

}	



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\jbs\mpinit.h ===
/*******************************************************************
*
*				 MPINIT.H
*
*				 Copyright (C) 1995 SGS-THOMSON Microelectronics.
*
*
*				 Prototypes for MPINIT.C
*
*******************************************************************/
#ifndef __MPINIT_H__
#define __MPINIT_H__
#define NO_ERROR 0
#ifndef NULL
#define NULL 0
#endif
#define ERROR_CARD_NOT_FOUND 		1
#define ERROR_NOT_ENOUGH_MEMORY  2
#define ERROR_COMMAND_NOT_IMPLEMENTED 3
// BGP #define VIDEO_PACKET_TIMER (10*1000)
#define VIDEO_PACKET_TIMER (5*1000)
#define AUDIO_PACKET_TIMER (10*1000)
#define MEM_WINDOW_SIZE (128*1024)
typedef struct _VIDEO_DEVICE_EXTENSION {
   BOOLEAN 						EOSInProgress;      // End Of Stream ha been sent to device
	KSSTATE 		DeviceState;
	STREAM_SYSTEM_TIME			videoSTC;
	PHW_STREAM_REQUEST_BLOCK  	pCurrentSRB;
   ULONG   						StarvationCount;        // number of times device was starved since last reset
	ULONG	cPacket;									// current packet in process
	ULONG	cOffs;										// offset into the current packet
	PKSDATA_PACKET pPacket;
	PVOID pDMABuf;
} VIDEO_DEVICE_EXTENSION, *PVIDEO_DEVICE_EXTENSION;

typedef struct _AUDIO_DEVICE_EXTENSION {
	STREAM_SYSTEM_TIME		audioSTC;
	KSSTATE 	DeviceState;
	PHW_STREAM_REQUEST_BLOCK  pCurrentSRB;
   ULONG   					StarvationCount;        // number of times device was starved since last reset
	ULONG	  					ByteSent;
	ULONG	cPacket;									// current packet in process
	ULONG	cOffs;										// offset into the current packet
	PKSDATA_PACKET pPacket;
} AUDIO_DEVICE_EXTENSION, *PAUDIO_DEVICE_EXTENSION;

typedef struct _HW_DEVICE_EXTENSION {
	KSSTATE stState;
	PUSHORT  					ioBaseLocal;
	PUSHORT  					ioBasePCI9060;
	USHORT						Irq;
	BOOLEAN						bVideoInt;
	BOOLEAN						bAudioInt;
	PHW_STREAM_REQUEST_BLOCK	AudioQ;
	PHW_STREAM_REQUEST_BLOCK	VideoQ;
	VIDEO_DEVICE_EXTENSION 	VideoDeviceExt;
	AUDIO_DEVICE_EXTENSION 	AudioDeviceExt;
	PHW_STREAM_REQUEST_BLOCK pCurSrb;
	PHW_STREAM_REQUEST_BLOCK pSrbQ;
} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;

typedef VOID (*PFN_WRITE_DATA)  (PHW_STREAM_REQUEST_BLOCK pSrb);

typedef struct _STREAMEX {
	PFN_WRITE_DATA pfnWriteData;
	PFN_WRITE_DATA pfnSetState;
	PFN_WRITE_DATA pfnGetProp;
} STREAMEX, *PSTREAMEX;

typedef struct _MRP_EXTENSION {

    ULONG           Status;
} MRP_EXTENSION, * PMRP_EXTENSION;

NTSTATUS HwInitialize (IN PHW_STREAM_REQUEST_BLOCK pSrb );
BOOLEAN HwUnInitialize ( IN PVOID DeviceExtension);
BOOLEAN HwInterrupt ( IN PVOID pDeviceExtension );
VOID AudioEnableInterrupts(IN PVOID pHwDeviceExtension);
VOID STEnableInterrupts( IN PVOID pHwDeviceExtension );
VOID STDeferredCallback ( IN PVOID pHwDeviceExtension );
VOID TmpDeferredCallback ( IN PVOID pHwDeviceExtension );
VOID AudioTimerCallBack(IN PHW_DEVICE_EXTENSION pDeviceExtension);
ULONG DriverEntry (PVOID Context1, PVOID Context2);

// Function Prototype for the locally defined functions

BOOLEAN HwStartIo (
				IN PVOID DeviceExtension,
				PHW_STREAM_REQUEST_BLOCK pMrb
				);


VOID AdapterOpenStream(PHW_STREAM_REQUEST_BLOCK pSrb);

VOID AdapterCloseStream(PHW_STREAM_REQUEST_BLOCK pSrb);

VOID STREAMAPI AdapterReceivePacket(IN PHW_STREAM_REQUEST_BLOCK Srb);
VOID STREAMAPI AdapterCancelPacket(IN PHW_STREAM_REQUEST_BLOCK Srb);
VOID STREAMAPI AdapterTimeoutPacket(IN PHW_STREAM_REQUEST_BLOCK Srb);

VOID HostDisableIT(VOID);
VOID HostEnableIT(VOID);


PHW_STREAM_REQUEST_BLOCK Dequeue(PHW_DEVICE_EXTENSION pdevext);

VOID STREAMAPI StreamReceiveDataPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI StreamReceiveCtrlPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);

VOID AdapterStreamInfo(PHW_STREAM_REQUEST_BLOCK pSrb);

VOID StreamStartCommand (PHW_DEVICE_EXTENSION pdevext);

void Enqueue (PHW_STREAM_REQUEST_BLOCK pSrb, PHW_DEVICE_EXTENSION pdevext);

#endif //__MPINIT_H__

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\jbs\mpovrlay.h ===
/*******************************************************************
*
*				 MPVIDEO.H
*
*				 Copyright (C) 1995 SGS-THOMSON Microelectronics.
*
*
*				 Prototypes for MPVIDEO.C
*
*******************************************************************/

#ifndef __MPOVRLAY_H__
#define __MPOVRLAY_H__

ULONG miniPortOverlayUpdateClut (PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortOverlaySetVgaKey (PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortOverlaySetMode(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortOverlaySetDestination(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortOverlaySetBitMask(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortOverlaySetAttribute(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortOverlaySetAlignment(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortOverlayGetVgaKey(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortOverlayGetMode(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortOverlayGetDestination(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortOverlayGetAttribute(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortOverlayGetAlignment(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
#endif //__MPOVRLAY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\jbs\mpovrlay.c ===
/*******************************************************************
*
*				 MPOVRLAY.C
*
*				 Copyright (C) 1995 SGS-THOMSON Microelectronics.
*
*
*				 PORT/MINIPORT Interface Overlay Routines
*
*******************************************************************/

#include "common.h"
#include "mpst.h"
#include "mpinit.h"
#include "mpovrlay.h"
#include "debug.h"

ULONG miniPortOverlayGetAllignment(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	// STB
	pHwDevExt = pHwDevExt; // Remove Warning 
	pMrb = pMrb; // Remove Warning 
	 DEBUG_PRINT((DebugLevelVerbose,"mrbOverlayGetAlnmnt"));
	dwErrCode = ERROR_COMMAND_NOT_IMPLEMENTED;
	return dwErrCode; 	
}


ULONG miniPortOverlayGetAttribute(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	// STB
	pHwDevExt = pHwDevExt; // Remove Warning 
	pMrb = pMrb; // Remove Warning 
	 DEBUG_PRINT((DebugLevelVerbose,"mrbOverlayGetAttr"));
   pMrb->Status = MrbStatusUnsupportedComand;
	return dwErrCode; 	
}

ULONG miniPortOverlayGetAlignment (PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	// STB
	pHwDevExt = pHwDevExt; // Remove Warning 
	pMrb = pMrb; // Remove Warning 
	 DEBUG_PRINT((DebugLevelVerbose,"mrbOverlayGetAlignment"));
	dwErrCode = ERROR_COMMAND_NOT_IMPLEMENTED;
	return dwErrCode; 	
}

ULONG miniPortOverlayGetDestination(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	// STB
	pHwDevExt = pHwDevExt; // Remove Warning 
	pMrb = pMrb; // Remove Warning 
	 DEBUG_PRINT((DebugLevelVerbose,"mrbOverlayGetDest"));
	dwErrCode = ERROR_COMMAND_NOT_IMPLEMENTED;
	return dwErrCode; 	
}


ULONG miniPortOverlayGetMode(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	// STB
	pMrb = pMrb; // Remove Warning 
	pHwDevExt = pHwDevExt; // Remove Warning 
	 DEBUG_PRINT((DebugLevelVerbose,"mrbOverlayGetMode"));
	dwErrCode = ERROR_COMMAND_NOT_IMPLEMENTED;
	return dwErrCode; 	
}


ULONG miniPortOverlayGetVgaKey(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	// STB
	pHwDevExt = pHwDevExt; // Remove Warning 
	pMrb = pMrb; // Remove Warning 
	 DEBUG_PRINT((DebugLevelVerbose,"mrbOverlayGetVgaKey"));
	dwErrCode = ERROR_COMMAND_NOT_IMPLEMENTED;
	return dwErrCode; 	
}


ULONG miniPortOverlaySetAlignment(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	// STB
	 DEBUG_PRINT((DebugLevelVerbose,"mrbOverlaySetAlignment"));
	pHwDevExt = pHwDevExt; // Remove Warning 
	pMrb = pMrb; // Remove Warning 
	dwErrCode = ERROR_COMMAND_NOT_IMPLEMENTED;
	return dwErrCode; 	
}


ULONG miniPortOverlaySetAttribute(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	// STB
	pHwDevExt = pHwDevExt; // Remove Warning 
	pMrb = pMrb; // Remove Warning 
	 DEBUG_PRINT((DebugLevelVerbose,"mrbOverlaySetAttr"));
	dwErrCode = ERROR_COMMAND_NOT_IMPLEMENTED;
	return dwErrCode; 	
}

ULONG miniPortOverlaySetBitMask(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	// STB
	pHwDevExt = pHwDevExt; // Remove Warning 
	pMrb = pMrb; // Remove Warning 
	 DEBUG_PRINT((DebugLevelVerbose,"mrbOverlaySetBitMask"));
	dwErrCode = ERROR_COMMAND_NOT_IMPLEMENTED;
	return dwErrCode; 	
}

ULONG miniPortOverlaySetDestination(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	// STB
	 DEBUG_PRINT((DebugLevelVerbose,"mrbOverlaySetDestination"));
	pHwDevExt = pHwDevExt; // Remove Warning 
	pMrb = pMrb; // Remove Warning 
	dwErrCode = ERROR_COMMAND_NOT_IMPLEMENTED;
	return dwErrCode; 	
}


ULONG miniPortOverlaySetMode(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	pHwDevExt = pHwDevExt; // Remove Warning 
	pMrb = pMrb; // Remove Warning 
	// STB
	 DEBUG_PRINT((DebugLevelVerbose,"mrbOverlaySetMode"));
	dwErrCode = ERROR_COMMAND_NOT_IMPLEMENTED;
	return dwErrCode; 	
}

ULONG miniPortOverlaySetVgaKey (PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	// STB
	pHwDevExt = pHwDevExt; // Remove Warning 
	pMrb = pMrb; // Remove Warning 
	 DEBUG_PRINT((DebugLevelVerbose,"mrbOverlaySetVgaKey"));
	dwErrCode = ERROR_COMMAND_NOT_IMPLEMENTED;
	return dwErrCode; 	
}


ULONG miniPortOverlayUpdateClut (PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	// STB
	 DEBUG_PRINT((DebugLevelVerbose,"mrbOverlayUpdateClut"));
	pHwDevExt = pHwDevExt; // Remove Warning 
	pMrb = pMrb; // Remove Warning 
	dwErrCode = ERROR_COMMAND_NOT_IMPLEMENTED;
	return dwErrCode; 	
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\jbs\mpvideo.h ===
/*******************************************************************
*
*				 MPVIDEO.H
*
*				 Copyright (C) 1995 SGS-THOMSON Microelectronics.
*
*
*				 Prototypes for MPVIDEO.C
*
*******************************************************************/

#ifndef __MPVIDEO_H__
#define __MPVIDEO_H__

VOID VideoEnableInterrupts(IN PVOID);
VOID VideoTimerCallBack(PHW_STREAM_OBJECT pstrm);
ULONG miniPortVideoStop (PHW_STREAM_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
ULONG miniPortVideoSetStc(PHW_STREAM_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
ULONG miniPortVideoSetAttribute(PHW_STREAM_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
ULONG miniPortVideoQueryInfo (PHW_STREAM_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
ULONG miniPortVideoPlay(PHW_STREAM_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
ULONG miniPortVideoPause(PHW_STREAM_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
VOID miniPortVideoPacket(PHW_STREAM_REQUEST_BLOCK);
ULONG miniPortVideoGetStc(PHW_STREAM_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
ULONG miniPortVideoGetAttribute(PHW_STREAM_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
ULONG miniPortVideoEndOfStream(PHW_STREAM_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
ULONG miniPortVideoDisable(PHW_STREAM_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
ULONG miniPortVideoEnable(PHW_STREAM_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
ULONG miniPortClearVideoBuffer(PHW_STREAM_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
ULONG miniPortCancelVideo(PHW_STREAM_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
ULONG miniPortVideoReset(PHW_STREAM_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
VOID miniPortSetState(PHW_STREAM_REQUEST_BLOCK pSrb);
VOID mpstCtrlCommandComplete(PHW_STREAM_REQUEST_BLOCK pSrb);
void VideoPacketStub(PHW_STREAM_OBJECT pstrm);
VOID miniPortGetProperty(PHW_STREAM_REQUEST_BLOCK pSrb);
void StubMpegEnableIRQ(PHW_STREAM_OBJECT pstrm);

#endif //__MPVIDEO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\jbs\mpvideo.c ===
/*******************************************************************
*
*				 MPVIDEO.C
*
*				 Copyright (C) 1995 SGS-THOMSON Microelectronics.
*
*
*				 PORT/MINIPORT Interface Video Routines
*
*******************************************************************/

#include "common.h"
#include "strmini.h"
#include "mpst.h"
#include "mpinit.h"
#include "mpvideo.h"
#include "debug.h"
#include "dmpeg.h"

void mpstCommandComplete(PHW_STREAM_REQUEST_BLOCK pSrb);

ULONG miniPortCancelVideo(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;
	// TBD
	pMrb->Status = STATUS_SUCCESS;

	if(pHwDevExt->VideoDeviceExt.pCurrentSRB != NULL)
	{
		// Still to send a packet
		pHwDevExt->VideoDeviceExt.pCurrentSRB->Status = STATUS_CANCELLED;
      //MpegPortNotification(RequestComplete,VideoDevice,pHwDevExt,
//			pHwDevExt->VideoDeviceExt.pCurrentSRB);
      //MpegPortNotification(NextRequest,VideoDevice,pHwDevExt);
		// Now kill the timer
      //MpegPortNotification(RequestTimerCall, VideoDevice,
  //                           pHwDevExt, NULL, 0);
		pHwDevExt->VideoDeviceExt.pCurrentSRB = NULL;
	}

	return dwErrCode; 	
}

ULONG miniPortClearVideoBuffer(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	// STB
	pHwDevExt = pHwDevExt; // Remove Warning 
	pMrb = pMrb; // Remove Warning 
	dwErrCode = ERROR_COMMAND_NOT_IMPLEMENTED;
	return dwErrCode; 	
}

ULONG miniPortVideoEnable(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	pHwDevExt = pHwDevExt; // Remove Warning 
	pMrb = pMrb; // Remove Warning 
//        mpstEnableVideo ( TRUE );
	return dwErrCode; 	
}


ULONG miniPortVideoDisable(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	pHwDevExt = pHwDevExt; // Remove Warning 
	pMrb = pMrb; // Remove Warning 
//        mpstEnableVideo(FALSE);
	return dwErrCode; 	
}

ULONG miniPortVideoEndOfStream(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

    miniPortVideoStop(pMrb, pHwDevExt);

	return dwErrCode; 	
}


ULONG miniPortVideoGetAttribute(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	pHwDevExt = pHwDevExt; // Remove Warning 
#ifdef DEFINEME
	switch(pMrb->CommandData.pAttribute->Attribute)
	{
	// STB
		case MpegAttrVideoAGC 			:						
		case MpegAttrVideoChannel 		:						
		case MpegAttrVideoClamp	 		:						
		case MpegAttrVideoCoring 		:						
		case MpegAttrVideoGain	 		:						
		case MpegAttrVideoGenLock 		:						
		case MpegAttrVideoHue	 		:						
		case MpegAttrVideoMode	 		:						
		case MpegAttrVideoSaturation	:						
		case MpegAttrVideoSharpness 	:						
		case MpegAttrVideoSignalType	:						
         pMrb->Status = STATUS_INVALID_PARAMETER;
		break;
	}
#endif 
	return dwErrCode; 	
}


ULONG miniPortVideoGetStc(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	pHwDevExt = pHwDevExt; // Remove Warning 
	pMrb = pMrb; // Remove Warning 
#if 0
	// TBI
   *pMrb->CommandData.pPresentationDelta = pHwDevExt->VideoDeviceExt.videoSTC;
//   pMrb->Status = STATUS_INVALID_PARAMETER;
#endif
	return dwErrCode; 	
}

void VideoPacketStub(PHW_STREAM_OBJECT pstrm)
{


	//
	// VideoTimerCallBack(pSrb->StreamObject);
	//

        dmpgDisableIRQ();

	StreamClassCallAtNewPriority(pstrm, pstrm->HwDeviceExtension,
							   Dispatch,
                        VideoTimerCallBack, pstrm);

}

VOID miniPortVideoPacket(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	ULONG dwErrCode = NO_ERROR;
	ULONG uSent=0;

	PHW_DEVICE_EXTENSION pHwDevExt =
	 ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);

	PVIDEO_DEVICE_EXTENSION pvidex = 
	 &(((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension)->VideoDeviceExt);

	 //
	 // set up for initial parsing of the scatter gather packet.
	 //
 
	 pvidex->cPacket = pvidex->cOffs = 0;

     if (!pSrb->CommandData.DataBuffer) {

       return(miniPortVideoEndOfStream(pSrb, pHwDevExt));
     }

	 pvidex->pPacket = &(pSrb->CommandData.DataBuffer->DataPacket);

	 pvidex->pCurrentSRB = pSrb;
 
	 pHwDevExt->VideoDeviceExt.videoSTC =
		 pvidex->pPacket->PresentationDelta;

	 VideoPacketStub(pSrb->StreamObject);

}

VOID miniPortGetProperty(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	PHW_DEVICE_EXTENSION phwdevext =
		((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);

	TRAP

	switch (pSrb->CommandData.PropertyInfo->PropertySetID)
	{
	case 0:

		TRAP

//                mpstGetVidLvl(pSrb);

		break;

	default:

        break;


	}
	pSrb->Status = STATUS_SUCCESS;

	mpstCtrlCommandComplete(pSrb);
}

VOID miniPortSetState(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	PHW_DEVICE_EXTENSION phwdevext =
		((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);

	switch (pSrb->CommandData.StreamState)  
	{
	case KSSTATE_STOP:

        miniPortVideoStop(pSrb, phwdevext);
		break;


	case KSSTATE_PAUSE:

		miniPortVideoPause(pSrb, phwdevext);

		break;

	case KSSTATE_RUN:

		miniPortVideoPlay(pSrb, phwdevext);

	}
	pSrb->Status = STATUS_SUCCESS;

	mpstCtrlCommandComplete(pSrb);

}

ULONG miniPortVideoPause(PHW_STREAM_REQUEST_BLOCK pSrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;
	pSrb = pSrb; // Remove Warning 
//        mpstVideoPause ();
        dmpgPause();
	pHwDevExt->VideoDeviceExt.DeviceState = KSSTATE_PAUSE;
	return dwErrCode; 	
}

ULONG miniPortVideoPlay(PHW_STREAM_REQUEST_BLOCK pSrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

//        mpstVideoPlay();
        DebugPrint((DebugLevelVerbose, "Calling Play!!!!"));
        dmpgPlay();
	pHwDevExt->VideoDeviceExt.DeviceState = KSSTATE_RUN;
	pSrb = pSrb; // Remove Warning 
	return dwErrCode; 	
}

ULONG miniPortVideoQueryInfo (PHW_STREAM_REQUEST_BLOCK pSrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

#ifdef DEFINEME
	pSrb -> CommandData.pDeviceInfo->DeviceState = 
				pHwDevExt->VideoDeviceExt.DeviceState;

	pSrb -> CommandData.pDeviceInfo->DecoderBufferSize = mpstVideoDecoderBufferSize();
	pSrb -> CommandData.pDeviceInfo->DecoderBufferFullness = mpstVideoDecoderBufferFullness();
#endif
	return dwErrCode; 	
}

ULONG miniPortVideoReset(PHW_STREAM_REQUEST_BLOCK pSrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	// TBC
//        mpstVideoReset();
        dmpgSeek();
	pHwDevExt->VideoDeviceExt.DeviceState = KSSTATE_PAUSE;
	pSrb->Status = STATUS_SUCCESS;
	return dwErrCode; 	
}


ULONG miniPortVideoSetAttribute(PHW_STREAM_REQUEST_BLOCK pSrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	pHwDevExt = pHwDevExt; // Remove Warning 
	// STB

#ifdef DEFINEME
	switch(pSrb->CommandData.pAttribute->Attribute)
	{
		case MpegAttrVideoAGC 			:						
		case MpegAttrVideoChannel 		:						
		case MpegAttrVideoClamp	 		:						
		case MpegAttrVideoCoring 		:						
		case MpegAttrVideoGain	 		:						
		case MpegAttrVideoGenLock 		:						
		case MpegAttrVideoHue	 		:						
		case MpegAttrVideoMode	 		:						
		case MpegAttrVideoSaturation	:						
		case MpegAttrVideoSharpness 	:						
		case MpegAttrVideoSignalType	:						
			dwErrCode = ERROR_COMMAND_NOT_IMPLEMENTED;
		break;
	}
#endif
	return dwErrCode; 	
}

ULONG miniPortVideoSetStc(PHW_STREAM_REQUEST_BLOCK pSrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;
	pHwDevExt = pHwDevExt; // Remove Warning 
	pSrb = pSrb; // Remove Warning 
#if 0
	// TBI
//   pSrb->Status = STATUS_INVALID_PARAMETER;
#endif
	return dwErrCode; 	
}


ULONG miniPortVideoStop (PHW_STREAM_REQUEST_BLOCK pSrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	// TBC
	pHwDevExt->VideoDeviceExt.DeviceState = KSSTATE_PAUSE;
	if(pHwDevExt->VideoDeviceExt.pCurrentSRB != NULL)
	{
		// Still to send a packet
		pHwDevExt->VideoDeviceExt.pCurrentSRB->Status = STATUS_CANCELLED;

		StreamClassStreamNotification(ReadyForNextStreamDataRequest,
				pHwDevExt->VideoDeviceExt.pCurrentSRB->StreamObject);
	
		StreamClassStreamNotification(StreamRequestComplete,
				pHwDevExt->VideoDeviceExt.pCurrentSRB->StreamObject,
				pHwDevExt->VideoDeviceExt.pCurrentSRB);
   

		//
		// request a timer callback
		//
	
		StreamClassScheduleTimer(pSrb->StreamObject, pSrb->HwDeviceExtension,
             0, VideoPacketStub, pSrb->StreamObject);


		pHwDevExt->VideoDeviceExt.pCurrentSRB =
		  pHwDevExt->pCurSrb = NULL;

	}
//        mpstVideoStop();
        dmpgStop();
	pSrb->Status = STATUS_SUCCESS;
	return dwErrCode; 	
}


VOID VideoTimerCallBack(PHW_STREAM_OBJECT pstrm)
{
    PHW_DEVICE_EXTENSION pdevext = pstrm->HwDeviceExtension;
    PHW_STREAM_REQUEST_BLOCK pSrb;

	ULONG	uSent;
	PVIDEO_DEVICE_EXTENSION pvidex = &(pdevext->VideoDeviceExt);

	pSrb = pvidex->pCurrentSRB;
//        dmpgEnableIRQ();

	if (!pSrb)
	{
		TRAP

		return;
	}

	do
	{

		uSent = mpstVideoPacket(pSrb);

		pvidex->cOffs += uSent;

		//
		// check if we finished this packet.  If so, go on to the
		// next packet
		//

		if (pvidex->cOffs >=
			pvidex->pPacket->DataPacketLength)
		{
			pvidex->pPacket++;



			//
			// reset the packet offset
			//

			pvidex->cOffs = 0;
			pvidex->cPacket = (ULONG)pvidex->cPacket
				+ sizeof (KSDATA_PACKET);

			//
			// if we have finished all the packets, then we are done
			//

			if (pvidex->cPacket >=
				 pSrb->CommandData.DataBuffer->DataHeader.DataSize)           
			{

				pSrb->Status = STATUS_SUCCESS;
				pvidex->pCurrentSRB = 0;

                                mpstCommandComplete(pSrb);
                                StreamClassCallAtNewPriority(pstrm, 
                                                    pstrm->HwDeviceExtension,
                                                    High,
                                                  StubMpegEnableIRQ,
                                                  pstrm);

				return;

			}
		}

	} while (uSent);


	//
	// request a timer callback
	//

    StreamClassScheduleTimer(pstrm, pstrm->HwDeviceExtension,
                             VIDEO_PACKET_TIMER, VideoPacketStub, pstrm);
        
                                StreamClassCallAtNewPriority(pstrm, 
                                                    pstrm->HwDeviceExtension,
                                                    High,
                                                  StubMpegEnableIRQ,
                                                  pstrm);
		

}

void StubMpegEnableIRQ(PHW_STREAM_OBJECT pstrm)
{
    dmpgEnableIRQ();

}


ULONG mpstVideoPacket(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	PVIDEO_DEVICE_EXTENSION pvidex = 
	 &(((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension)->VideoDeviceExt);
	PUCHAR pPacket;
	ULONG	uLen;
        ULONG cPacket;
        PUCHAR  p;

        #define MAX_SIZE        8192

	//
	// find out how many bytes we can squeeze in
	//

        uLen = MAX_SIZE; //(BUF_FULL - VideoGetBBL()) * 256;

        if(pvidex -> cOffs == 0)
        {

                p = (PUCHAR)(pvidex->pPacket->DataPacket);
                pvidex->cOffs = p[8]+9;

        }

        cPacket = pvidex->pPacket->DataPacketLength - pvidex->cOffs;

	uLen = uLen > cPacket ? cPacket : uLen;

        if(uLen > MAX_SIZE)
                uLen = MAX_SIZE;

// AVSYNC BUG to be fixed here.
// Dont Latch PTS every time.

	if (uLen)
	{

		//
		// send the bytes that we can fit
		//

                return dmpgSendVideo((PDWORD)(((ULONG)pvidex->pPacket->DataPacket) + pvidex->cOffs), uLen);
	}

	return uLen;	
}


/////////////////////////////////////////////////////////////////////////
//
//			  Function : mpstCommandComplete
//			  Args : SRB
//			  Returns : none
//
//			  Purpose:
//				Performs a completion callback on a given request,
//				and then dequeues any outstanding requests
//
//			  Last Modified 10.1.96 by JBS
//
/////////////////////////////////////////////////////////////////////////
void mpstCommandComplete(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	 PHW_STREAM_REQUEST_BLOCK pNextSrb;
	PHW_DEVICE_EXTENSION pHwDevExt = 
	 ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);

	 //
	 // see if there is a request outstanding on either queue.
	 // if there is, go ahead and start it.
	 //

	 //
	 //  Note: this code cannot be re-entered!
	 //


	 pHwDevExt ->pCurSrb = 0;

	 StreamStartCommand(pHwDevExt);

	 //
	 // now, go ahead and complete this request
	 //

	
	 StreamClassStreamNotification(ReadyForNextStreamDataRequest,
			 pSrb->StreamObject);
 
	 StreamClassStreamNotification(StreamRequestComplete,
			 pSrb->StreamObject,
			 pSrb);

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\jbs\mpst.h ===
///////////////////////////////////////////////////////////////////////////
//
//						File : mpst.h
//
//		 Prototype for mpst.c
//		 i/f between Miniport Layer and core driver
//
//
///////////////////////////////////////////////////////////////////////////
#ifndef __MPST_H__
#define __MPST_H__
#include "mpinit.h" 
typedef struct tagBusInfo
{
   ULONG 			NumberOfAccessRanges;         
   INTERFACE_TYPE AdapterInterfaceType; 
   USHORT 			VendorIdLength;              //   size in bytes of VendorId
	 PVOID  			VendorId;                    //   points to ASCII byte string identifying
   USHORT 			DeviceIdLength;              //   size in bytes of DeviceId
   PVOID  			DeviceId;                    //   points to ASCII byte string identifying
	 BOOLEAN 			NoDynamicRelocation;        // On dynamically configurable I/O busses, when set
} BUSINFO, *PBUSINFO;

typedef struct tagBoardInfo
{
	PUSHORT	ioBasePCI9060; // Eval3520 PCI Specific address
	PUSHORT	ioBaseLocal;  // Base address
	UCHAR   Irq;
} BOARDINFO, *PBOARDINFO;

BOOLEAN mpstDriverEntry (OUT PBUSINFO pBusInfo);
BOOLEAN mpstHwFindAdaptor (OUT PBOARDINFO pBoardInfo);
BOOLEAN mpstHwInitialize(PHW_DEVICE_EXTENSION pHwDevExt);
BOOLEAN mpstHwUnInitialize(VOID);
BOOLEAN mpstHwInterrupt(VOID);
VOID mpstEnableVideo (BOOLEAN bFlag);
ULONG mpstVideoPacket(PHW_STREAM_REQUEST_BLOCK pMrb);
VOID mpstVideoPause(VOID);
VOID mpstVideoPlay(VOID);
VOID mpstVideoStop(VOID);
ULONG mpstVideoDecoderBufferSize(VOID);
ULONG mpstVideoDecoderBufferFullness(VOID);
VOID mpstVideoReset(VOID);
VOID mpstEnableAudio (BOOLEAN bFlag);
ULONG mpstSendAudio(UCHAR *pData, ULONG uLen);
VOID mpstAudioPause(VOID);
VOID mpstAudioPlay(VOID);
VOID mpstAudioStop(VOID);
ULONG mpstAudioDecoderBufferSize(VOID);
ULONG mpstAudioDecoderBufferFullness(VOID);
VOID mpstAudioReset(VOID);
VOID portWritePortBuffer16(IN PUSHORT Port, IN PUSHORT Data, ULONG Size);
void mpstGetVidLvl(PHW_STREAM_REQUEST_BLOCK pSrb);
#endif // __MPST_H__


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\jbs\pnp.h ===
//
// MODULE  : PNP.H
//	PURPOSE : Plug n Play
//	AUTHOR  : JBS Yadawa
// CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//

#ifndef __PnP_H__
#define __PnP_H__

BOOL FARAPI HostGetBoardConfig(WORD wDeviceID,WORD wVendorID,LPBYTE IRQ,LPDWORD Base);
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\jbs\staudio.c ===
//
// MODULE  : STAUDIO.C
//	PURPOSE : Audio Routines
//	AUTHOR  : JBS Yadawa
// CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//

#include "common.h"
#include "stdefs.h"
#include "staudio.h"
#include "debug.h"
#include "error.h"
#include "board.h"
#include "sti3520A.h"
#include <dos.h> ///////////

static PAUDIO pAudio;
#define SLOW_MODE	0
#define PLAY_MODE	1
#define FAST_MODE	2

#define IT_A        0 // interrupt detected

void AudioOpen(PAUDIO pAud)
{                         
	pAudio = pAud;
	pAudio->AudioState = AUDIO_POWER_UP;
	pAudio->IntAudio = NO_IT_A;
	pAudio->MaskItAudio = 0;
	pAudio->ErrorMsg = NO_ERROR;
	pAudio->FirstPTS = FALSE;			   // First PTS not reached yet
	pAudio->mute = FALSE;
	pAudio->Stepped = FALSE;
	pAudio->FrameCount = 0;
}

void AudioClose(void)
{
}

void AudioInitDecoder(WORD StreamType)
{   
/*
#if 0
	pAudio->StrType = StreamType;
	switch(pAudio->AudioState) {
	case AUDIO_POWER_UP:
		BoardWriteAudio(RESET, 1);	   // reset the decoder
//ALTERAClearPendingAudioIT(); // Clear pending audio interrupt generated by soft reset
		BoardWriteAudio(INTR_EN, 0);  // disable all interupts
		BoardWriteAudio(INTR_EN + LSB, 0);
		BoardWriteAudio(PLAY, 0);	   // disable play output
		BoardWriteAudio(MUTE, 0);	   // do not mute output. LRclk and Sclk Stopped here
		BoardWriteAudio(INVERT_SCLK, 0);	// standard
		BoardWriteAudio(INVERT_LRCLK, 1);// standard
#ifndef VALID3520
		//**************************************************************
		// Philips TDA1311 is a 16 bit DAC (oversampling 1x, 2x, 4x, 8x)
		// -> LRCLK = SCLK / 32
		// -> SCLK  = PCMCLK / 8 (8 times oversampling => PCM_DIV = 3)
		// => PCMCLK = 256 * Sampling Frequency
		//**************************************************************
		BoardWriteAudio(PCM_DIV, 3);
		BoardWriteAudio(PCM_ORD, 0);	// MSB first
		BoardWriteAudio(PCM_18,  0);	// 16 bits of PCM data
		BoardWriteAudio(FORMAT,  0);	// I2S output format
		BoardWriteAudio(DIF,     0);	// Optionnal in 16 bit output
#else
		//**************************************************************
		// Crystal CS4330 is an 18 bit DAC (oversampling 1x, 4x, 6x, 8x)
		// -> LRCLK = SCLK / 64
		// -> SCLK  = PCMCLK / 4 (4 times oversampling => PCM_DIV = 1)
		// => PCMCLK = 256 * Sampling Frequency
		//**************************************************************
		BoardWriteAudio(PCM_DIV, 1);
		BoardWriteAudio(PCM_ORD, 0);
		BoardWriteAudio(PCM_18,  1);	// 18 bits of PCM data
		BoardWriteAudio(FORMAT,  0);	// I2S output format
		BoardWriteAudio(DIF,     0);	// Optionnal in 16 bit
#endif
		BoardWriteAudio(STR_SEL,  0);	// Default Stream Type is audio elem stream
		BoardWriteAudio(CRC_ECM,  1);	// mute on CRC error correction
		BoardWriteAudio(SYNC_ECM, 1);	// mute if Sync lost
		BoardWriteAudio(SYNCHRO_CONFIRM, 1);	// synchro confirmation mode
		BoardWriteAudio(SYNC_REG, 0x3F);	// layer, bitrate, fs fields not used
		BoardWriteAudio(PACKET_SYNC_CHOICE, 0);// multiplexed stream
		BoardWriteAudio(LATENCY, 0x0);   // Low Lattency decoding
		BoardWriteAudio(SYNC_LCK, 0x2);	// locked after 2 good Sync
		BoardWriteAudio(SIN_EN, 0x01);	  // Serial data input to enable bit buffer access
		BoardWriteAudio(AUDIO_ID_EN, 0x0);// ignore audio stream ID
		BoardWriteAudio(AUDIO_ID, 0x0);	 // audio stream ID ignored
		BoardWriteAudio(FREE_FORM_H, 0x0);// not free format
		BoardWriteAudio(FREE_FORM_L, 0x0);
		BoardWriteAudio(DUAL_REG, 0);  // Select Stereo Mode
		AudioSetSTCParameters(44100UL);
		BoardAudioSetSamplingFrequency(44100UL);
		pAudio->FrameCount = 0;	   // Reset Frame Count.
		pAudio->AudioState = AUDIO_INIT;
		break;
	default:
		break;
	}
#else
		BoardWriteAudio(0xF0, 1);	   // reset the decoder
		BoardWriteAudio(0xC6, 0);	   
		BoardWriteAudio(0xEF, 1);	   
		BoardWriteAudio(PCM_DIV, 2);
		BoardWriteAudio(0x9f, 0);
		BoardWriteAudio(0x99, 0);
		BoardWriteAudio(0xB6, 3);
		BoardWriteAudio(0x9e, 0);
		BoardWriteAudio(0xa0, 0);
		BoardWriteAudio(0x91, 0);
		BoardWriteAudio(0xb8, 0);
		BoardWriteAudio(0x96, 1);
		BoardWriteAudio(0xd3, 0);
		BoardWriteAudio(0xac, 0);
		BoardWriteAudio(0xc4, 0);
		BoardWriteAudio(0xc2, 1);
		BoardWriteAudio(0xAE, 1);

#endif	
*/
}

WORD AudioTestReg(void)
{     
#if 0
	WORD ReadValue;
	BoardWriteAudio(ATTEN_L, 0x55);
	BoardWriteAudio(ATTEN_R, 0xAA);
	ReadValue = BoardReadAudio(ATTEN_L);
	if ((ReadValue & 0x3F) != 0x15)
		goto Error;
	ReadValue = BoardReadAudio(ATTEN_R);
	if ((ReadValue & 0x3F) != 0x2A)
		goto Error;

	return NO_ERROR;

Error :
	SetErrorCode(ERR_AUDIO_REG_TEST_FAILED);
	return BAD_REG_A;
#else
	return NO_ERROR;
#endif
}

WORD AudioTest(void)
{   
#if 0
	WORD TestResult;
	TestResult = AudioTestReg();
	if (TestResult != NO_ERROR)
		return TestResult;
	else {
#ifdef DOSAPP
		if (AudioTestInt(pAudio) == NO_IT_A)
			return NO_IT_A;
		else
#endif
			return NO_ERROR;
	}
#else
	return NO_ERROR;
#endif	
}

WORD AudioTestInt(void)
{
	WORD err = NO_ERROR;
#if 0
	U8  Threshold;
	WORD a = 0;

	pAudio->MaskItAudio = FIFT;
	Threshold = BoardReadAudio(FIFO_IN_TRESHOLD);
	//---- Configure audio
	BoardWriteAudio(PLAY,  0x00);
	BoardWriteAudio(FIFO_IN_TRESHOLD, 0x01);
	//---- Enable FIFO full interrupt
	BoardWriteAudio(INTR_EN, 0x00);
	BoardWriteAudio(INTR_EN + LSB, 0x10);
	//---- Write a byte to force an interrupt
	BoardWriteAudio(DATA_IN, 0x00);
	// wait for occurrence of first audio interrupt
	while (pAudio->IntAudio == NO_IT_A) {
		Delay(1000);
		a++;						  /* incremented every 1 ms */
		if (a >= 1000) {
			DPF((Trace, "AudioTestInt failed !!"));
			SetErrorCode(ERR_NO_AUDIO_INTR);
			err = NO_IT_A; 	/* No interrupt */
			break;
		}
	}
	// Restore Interrupt mask
	pAudio->MaskItAudio = 0;
	AudioMaskInt();
	BoardWriteAudio(FIFO_IN_TRESHOLD, Threshold);
	BoardReadAudio(INTR);		   /* to clear audio interrupts flags */
#endif	
	return err;
}

// Set the decoding mode and parameters

void AudioSetMode(WORD Mode, WORD param)
{     
#if 0
	pAudio->DecodeMode = Mode;
	switch (pAudio->DecodeMode) {
	case PLAY_MODE:
		BoardWriteAudio(MUTE, 0);
		pAudio->fastForward = 0;
		pAudio->decSlowDown = 0;
		break;
	case FAST_MODE:
		pAudio->fastForward = 1;
		pAudio->decSlowDown = 0;
		break;
	case SLOW_MODE:
		pAudio->fastForward = 0;
		pAudio->decSlowDown = param;
		break;
	}
#endif	
}

// Decode
void AudioDecode(void)
{     
#if 0
	switch (pAudio->AudioState)	{
	case AUDIO_POWER_UP:
		break;
	case AUDIO_INIT:
		// Change in synchro + buffer over BALF +PTS
		pAudio->MaskItAudio = SYNC|BOF|PCMU|CRC| PTS;
		BoardWriteAudio(INTR_EN, (BYTE)(pAudio->MaskItAudio & 0xFF));
		BoardWriteAudio(INTR_EN + LSB, (BYTE)(pAudio->MaskItAudio >> 8 ));
//yg		BoardWriteAudio(MUTE, 1); 	// This Starts SClk and LRClk outputs
		BoardWriteAudio(PLAY, 1);	// Start decoding Output is Mute
		pAudio->AudioState = AUDIO_STC_INIT;
		break;
	case AUDIO_STC_INIT:
		pAudio->AudioState = AUDIO_DECODE;
		BoardWriteAudio(PLAY, 1);	// Restart decoding (decoding had been stopped when first audio PTS detected)
		BoardWriteAudio(MUTE, 0);	// Stop Muting output
		break;
	case AUDIO_DECODE:
		break;
	case AUDIO_PAUSE:
	case AUDIO_STEP:
		BoardWriteAudio(PLAY, 1);
		BoardWriteAudio(MUTE, 0);
		pAudio->AudioState = AUDIO_DECODE;
		break;
	}
#endif	
}

void AudioStep(void)
{     
#if 0
	BoardWriteAudio(MUTE, 0);
	BoardWriteAudio(PLAY, 1);
	pAudio->AudioState = AUDIO_STEP;
	pAudio->Stepped = FALSE;
#endif	
}

void AudioStop(void)
{     
#if 0
	switch(pAudio->AudioState) {
	case AUDIO_POWER_UP:
		break;
	case AUDIO_INIT:
		break;
	case AUDIO_STC_INIT:
	case AUDIO_DECODE:
		pAudio->AudioState = AUDIO_POWER_UP;
		AudioInitDecoder(pAudio, pAudio->StrType);
		break;
	}
#endif	
}

void AudioPause(void)
{     
#if 0
	switch(pAudio->AudioState) {
	case AUDIO_POWER_UP: /* After reset */
	case AUDIO_INIT:		 /* Initialisation + test of the decoders */
	case AUDIO_STC_INIT: /* STC of audio decoder initialized */
	case AUDIO_DECODE:	 /* Normal decode */
		BoardWriteAudio(MUTE, 1);
		BoardWriteAudio(PLAY, 0);
		pAudio->AudioState = AUDIO_PAUSE;
		break;
	}
#endif	
}

WORD AudioGetState(void)
{
	return ( pAudio->AudioState);
}

void AudioSetSTCParameters(DWORD SampFreq)
{   
#if 0
	// Note :
	// STCCLK = PCMCLK (fixed inside STi3520A)
	// (PCMCLK * inc) / div = 90kHz
	switch(SampFreq){
	case 32000UL:
		// PCMCLK = 256 * 32   = 8192 kHz,    inc = 45, div = 4096 -> 90kHz
		BoardWriteAudio(STC_INC,  45);
		BoardWriteAudio(STC_DIVH, 0x10);
		BoardWriteAudio(STC_DIVL, 0x00);
		break;

	case 44100UL:
		// PCMCLK = 256 * 44.1 = 11289.6 kHz, inc = 25, div = 3136 -> 90kHz
		BoardWriteAudio(STC_INC,  25);
		BoardWriteAudio(STC_DIVH, 0x0C);
		BoardWriteAudio(STC_DIVL, 0x40);
		break;

	case 48000UL:
		// PCMCLK = 256 * 48   = 12288 kHz,   inc = 15, div = 2048 -> 90kHz
		BoardWriteAudio(STC_INC,  15);
		BoardWriteAudio(STC_DIVH, 0x08);
		BoardWriteAudio(STC_DIVL, 0x00);
		break;

	default :
		break;
	}

	BoardWriteAudio(STC_CTL, 0x40);	// Load STC_VID on rising edge of VSYNC
#endif	
}
DWORD AudioGetSTC(void)
{   
#if 0
	DWORD  stc;
	WORD	 j;

	BoardWriteAudio(STC_CTL, 0x44);	// load current STC value to STC
	for ( j = 0; j < 0xF; j++)
		;
	stc = ( BoardReadAudio(STC_3 ) & 0xFFL ) << 24;
	stc = stc | ( ( BoardReadAudio(STC_2 ) & 0xFFL ) << 16);
	stc = stc | ( ( BoardReadAudio(STC_1 ) & 0xFFL ) << 8);
	stc = stc | ( BoardReadAudio(STC_0 ) & 0xFFL);
	return ( stc);
#else
	return 0;
#endif	
}

DWORD AudioGetVideoSTC(void)
{            
#if 0
	DWORD stc;
	WORD	j;

	BoardWriteAudio(STC_CTL, 0x48);	// load STC_VID to STC, Mode 0 mapping
//	BoardWriteAudio(STC_CTL, 0x44);  accu
//	BoardWriteAudio(STC_CTL, 0x50);
	for ( j = 0; j < 0xF; j++)
		;
/*
	stc = ( BoardReadAudio(STC_3 ) & 0xFFL ) << 24;
	stc = stc | ((BoardReadAudio(STC_2) & 0xFFL ) << 16);
	stc = stc | ((BoardReadAudio(STC_1) & 0xFFL ) << 8);
	stc = stc | ((BoardReadAudio(STC_0) & 0xFFL ));
*/
	stc =       ( BoardReadAudio(STC_0) & 0xFFL ) << 0;
	stc = stc | ((BoardReadAudio(STC_1) & 0xFFL ) << 8);
	stc = stc | ((BoardReadAudio(STC_2) & 0xFFL ) << 16);
	stc = stc | ((BoardReadAudio(STC_3) & 0xFFL ) << 24);
	return stc;
#else 
	return 0;
#endif	
}

void AudioInitSTC(DWORD stc)
{            
#if 0
	BoardWriteAudio(STC_0, (U8)(stc & 0xFFL));
	stc >>= 8;
	BoardWriteAudio(STC_1, (U8)(stc & 0xFFL));
	stc >>= 8;
	BoardWriteAudio(STC_2, (U8)(stc & 0xFFL));
	stc >>= 8;
	BoardWriteAudio(STC_3, (U8)(stc & 0xFFL));
	BoardWriteAudio(STC_CTL, 0x41);	// load STC to accumulator,
#endif	
}

DWORD AudioGetPTS(void)
{
	return pAudio->PtsAudio;
}

WORD AudioGetErrorMsg(void)
{
	return pAudio->ErrorMsg;
}

void AudioSetRightVolume(WORD volume)
{   
#if 0
	BoardWriteAudio(ATTEN_R, (BYTE)volume);
#endif
}

void AudioSetLeftVolume(WORD volume)
{     
#if 0
	BoardWriteAudio(ATTEN_L, (BYTE)volume);
#endif
}

void AudioMute(void)
{   
#if 0
	if (pAudio->mute) {
		BoardWriteAudio(MUTE, 0);
		pAudio->mute = FALSE;
	}
	else {
		BoardWriteAudio(MUTE, 1);
		pAudio->mute = TRUE;
	}
#endif	
}

BOOL AudioIsFirstPTS(void)
{
	return pAudio->FirstPTS;
}

void AudioSetStreamType(WORD StrType)
{   
#if 0
	BoardWriteAudio(STR_SEL, (BYTE)StrType);
#endif
}
void AudioInitPesParser (WORD StreamType)
{     
#if 0
	switch(StreamType)
	{
		case SYSTEM_STREAM:
		case VIDEO_PACKET:
		case AUDIO_PACKET:
		case VIDEO_PES:
		case AUDIO_PES:

			 BoardWriteAudio( STR_SEL, 1);
		break;
		case DUAL_PES:
			 BoardWriteAudio( STR_SEL, 4);
		break;
		case DUAL_ES:
			 BoardWriteAudio( STR_SEL, 0);
		break;
		case VIDEO_STREAM:
		case AUDIO_STREAM:
			 BoardWriteAudio( STR_SEL, 0);
		break;

	}
#endif	
}
void AudioMaskInt(void)
{     
#if 0
	BoardWriteAudio(INTR_EN, 0);
	BoardWriteAudio(INTR_EN + LSB, 0);
#endif
}

void AudioRestoreInt(void)
{   
#if 0
//HostDisplay(DISPLAY_FASTEST, "!%x!", pAudio->MaskItAudio);
	BoardWriteAudio(INTR_EN, (BYTE)(pAudio->MaskItAudio & 0xFF));
	BoardWriteAudio(INTR_EN + LSB, (BYTE)(pAudio->MaskItAudio >> 8));
#endif
}

BOOL AudioAudioInt(void)
{   
#if 0
	WORD     int_stat_reg, i;
	BOOLEAN	bAudioIntr = FALSE;

	// Read the interrupt status register
	int_stat_reg = BoardReadAudio(INTR);
	i = BoardReadAudio(INTR + LSB);
	i = i << 8;
	int_stat_reg = ( int_stat_reg & 0xFF ) | i;
	int_stat_reg = int_stat_reg & pAudio->MaskItAudio;	/* Mask the IT not used */
	if(int_stat_reg)
		bAudioIntr = TRUE;

	/******************************************************/
	/** FIFO FULL used to test audio interrupt generation**/
	/******************************************************/
	if (int_stat_reg & FIFT) {
		pAudio->IntAudio = IT_A;
	}
	/******************************************************/
	/**                   CHANGE SYNCHRO                 **/
	/******************************************************/
	if (int_stat_reg & SYNC) {
		i = BoardReadAudio(SYNC_ST);	// Synchronization status
		if ((i & 0x3) == 3)	{	   // Locked
		// Disable Change in synchro
			pAudio->MaskItAudio = pAudio->MaskItAudio & NSYNC;
			// Next Interrupt should be change in sampling freq
			pAudio->MaskItAudio = pAudio->MaskItAudio | SAMP;
		}
	}

	/******************************************************/
	/**             CHANGE IN SAMPLING FREQUENCY         **/
	/******************************************************/
	if (int_stat_reg & SAMP) {
		i = BoardReadAudio(PCM_FS ) & 0x3;	// Get Sampling frequency
		switch(i) {
		case 0 :
			BoardAudioSetSamplingFrequency(44100UL);
			AudioSetSTCParameters(44100UL);
			break;
		case 1 :
			BoardAudioSetSamplingFrequency(48000UL);
			AudioSetSTCParameters(48000UL);
			break;
		case 2 :
			BoardAudioSetSamplingFrequency(32000UL);
			AudioSetSTCParameters(32000UL);
			break;
		default :
			break;
		}
		// Disable change in sampling frequency
		pAudio->MaskItAudio = pAudio->MaskItAudio & NSAMP;
	}

	/******************************************************/
	/**                   CRC error                      **/
	/******************************************************/
	if (int_stat_reg & CRC)	{
	}

	/******************************************************/
	/**                   PCM Underflow                  **/
	/******************************************************/
	if (int_stat_reg & PCMU) {
	}

	/******************************************************/
	/**                  Begining of Frame               **/
	/******************************************************/
	if (int_stat_reg & BOF)	{
		DWORD STC = AudioGetVideoSTC();
		static DWORD STCOld;

//		HostDisplay(DISPLAY_FASTEST, "STCBOF = %8lu D = %5ld\r\n", STC, STC - STCOld);
//		STCOld = STC;

		// Check if stepping
		if ((pAudio->AudioState == AUDIO_STEP) && (pAudio->Stepped == FALSE)) {
			BoardWriteAudio(MUTE, 1);
			BoardWriteAudio(PLAY, 0);
			pAudio->Stepped = TRUE;
		}
		// If Slow motion or Fast forward, Mute Audio
		if ( pAudio->DecodeMode != PLAY_MODE ) {
			BoardWriteAudio(MUTE, 1);
			pAudio->mute = TRUE;
			if ((pAudio->FrameCount % 4) && (pAudio->fastForward))
				BoardWriteAudio(SKIP, 1);
			else if ((pAudio->DecodeMode == SLOW_MODE ) &&
							 ((pAudio->FrameCount % (pAudio->decSlowDown + 1)) != 0))
				BoardWriteAudio(REPEAT, 1);
		}

		pAudio->FrameCount++;			   // Increment Frame Count
	}

	/******************************************************/
	/**                   PTS detected                   **/
	/******************************************************/
	if ( int_stat_reg & PTS )	{
		DWORD pts;
//DBG1('p');
/*
		BoardReadAudio(PTS_4);	   // To clear pts interrupt
		pts = (BoardReadAudio(PTS_3) & 0xFFL) << 24;
		pts = pts | ((BoardReadAudio(PTS_2 ) & 0xFFL) << 16);
		pts = pts | ((BoardReadAudio(PTS_1 ) & 0xFFL) << 8);
		pts = pts | ( BoardReadAudio(PTS_0 ) & 0xFFL);
*/
		pts =        (BoardReadAudio(PTS_0) & 0xFFL) << 0;
		pts = pts | ((BoardReadAudio(PTS_1) & 0xFFL) << 8);
		pts = pts | ((BoardReadAudio(PTS_2) & 0xFFL) << 16);
		pts = pts | ((BoardReadAudio(PTS_3) & 0xFFL) << 24);
		BoardReadAudio(PTS_4);	   // To clear pts interrupt

		pAudio->PtsAudio = pts;
		if (pAudio->AudioState == AUDIO_STC_INIT) {
			pAudio->FirstPTS = TRUE;
//yg			BoardWriteAudio(PLAY, 0);
		}
		if (pAudio->AudioState == AUDIO_DECODE)	{
//			HostDirectPutChar('P', BLACK, LIGHTBLUE);
			AudioInitSTC ( pts);
//			DWORD STC = AudioGetVideoSTC();
//			HostDisplay(DISPLAY_FASTEST, "STC = %8lu PTSA = %8lu D = %8ld\r\n", STC, pts, STC - pts);
		}
	}

	return bAudioIntr;
#else
	return FALSE;
#endif	
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\jbs\pnp.c ===
//
// MODULE  : PNP.C
//	PURPOSE : Plug&Play Specific PCI Bios code
//	AUTHOR  : JBS Yadawa
// CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//


#include "stdefs.h"
#include "pnp.h"


//---- PCI BIOS functions
#define PCI_FUNCTION_ID         0xB1
#define PCI_BIOS_PRESENT        0x01
#define FIND_PCI_DEVICE         0x02
#define FIND_PCI_CLASS_CODE     0x03
#define GENERATE_SPECIAL_CYCLE  0x06
#define READ_CONFIG_BYTE        0x08
#define READ_CONFIG_WORD        0x09
#define READ_CONFIG_DWORD       0x0A
#define WRITE_CONFIG_BYTE       0x0B
#define WRITE_CONFIG_WORD       0x0C
#define WRITE_CONFIG_DWORD      0x0D
#define GET_IRQ_ROUTING_OPTIONS 0x0E
#define SET_PCI_IRQ             0x0F

//---- PCI BIOS return codes
#define SUCCESSFUL              0x00
#define NOT_SUCCESSFUL          0x01
#define FUNC_NOT_SUPPORTED      0x81
#define BAD_VENDOR_ID           0x83
#define DEVICE_NOT_FOUND        0x86
#define BAD_REGISTER_NUMBER     0x87
#define SET_FAILED              0x88
#define BUFFER_TOO_SMALL        0x89

static BOOL NEARAPI PCIBIOSPresent(LPBYTE pHardwareMechanism,LPWORD pBIOSVersion, LPBYTE pLastPCIBusNumber);
static int NEARAPI ReadConfigByte(BYTE BusNumber,BYTE DeviceAndFunction,WORD RegNumber,LPBYTE pVal);
static int NEARAPI FindPCIDevice(WORD  DeviceID,WORD  VendorID,WORD  Index,LPBYTE pBusNumber,LPBYTE pDeviceAndFunction);
static int NEARAPI ReadConfigDWORD(BYTE BusNumber,BYTE DeviceAndFunction,WORD RegNumber,LPDWORD lpDwVal);
static int NEARAPI WriteConfigByte(BYTE BusNumber,BYTE DeviceAndFunction,WORD RegNumber,BYTE data);
static BOOL NEARAPI PCIBIOSGetBoardConfig(WORD wDeviceID, WORD wVendorID, LPBYTE pIRQ, LPDWORD Base);




static BOOL NEARAPI PCIBIOSPresent(LPBYTE pHardwareMechanism,LPWORD pBIOSVersion, LPBYTE pLastPCIBusNumber)
{
	BYTE  BIOSPresentStatus = 0;
	BYTE  HWMechanism = 0;
	BYTE  LastPCIBus = 0;
	WORD	Version = 0;
	WORD Signature = 0;

	_asm {
		mov ah, PCI_FUNCTION_ID
		mov al, PCI_BIOS_PRESENT
		int 0x1A
		mov BIOSPresentStatus, ah
		mov HWMechanism, al
		mov Version, bx
		mov LastPCIBus, cl
		mov Signature, dx

	}

	if (BIOSPresentStatus == 0) {
		if ( (((Signature >>  0) & 0xFF) == 'P') &&
				 (((Signature >>  8) & 0xFF) == 'C')) {
			*pHardwareMechanism = HWMechanism;
			*pBIOSVersion       = Version;
			*pLastPCIBusNumber  = LastPCIBus;
			return TRUE;
		}
	}
	return FALSE;
}

static int NEARAPI FindPCIDevice(WORD  DeviceID,WORD  VendorID,WORD  Index,LPBYTE pBusNumber,LPBYTE pDeviceAndFunction)
{
	BYTE ReturnCode;
	BYTE BusNbr;
	BYTE DevAndFunc;

	_asm {
		mov ah, PCI_FUNCTION_ID
		mov al, FIND_PCI_DEVICE
		mov cx, DeviceID
		mov dx, VendorID
		mov si, Index
		int 0x1A

		mov BusNbr, 	 bh
		mov DevAndFunc, bl
		mov ReturnCode, ah

	}
	*pBusNumber = BusNbr;
	*pDeviceAndFunction = DevAndFunc;
	return ReturnCode;
}

static int NEARAPI ReadConfigByte(BYTE BusNumber,BYTE DeviceAndFunction,WORD RegNumber,LPBYTE pVal)
{
	BYTE 	Val = 0;
	BYTE  ReturnCode;

	_asm {
		mov ah, PCI_FUNCTION_ID
		mov al, READ_CONFIG_BYTE
		mov bh, BusNumber
		mov bl, DeviceAndFunction
		mov di, RegNumber
		int 0x1A
		mov ReturnCode, ah
		mov Val, cl
	}
	*pVal = Val;
	return ReturnCode;
}

static int NEARAPI ReadConfigDWORD(BYTE BusNumber,BYTE DeviceAndFunction,WORD RegNumber,LPDWORD lpDwVal)
{
	BYTE fourByte[4];
	ReadConfigByte (BusNumber, DeviceAndFunction, RegNumber, &fourByte[0]);
	ReadConfigByte (BusNumber, DeviceAndFunction, RegNumber+1, &fourByte[1]);
	ReadConfigByte (BusNumber, DeviceAndFunction, RegNumber+2, &fourByte[2]);
	ReadConfigByte (BusNumber, DeviceAndFunction, RegNumber+3, &fourByte[3]);
	*lpDwVal = *((DWORD FAR *)fourByte);
	return 0;
}

static int NEARAPI WriteConfigByte(BYTE BusNumber,BYTE DeviceAndFunction,WORD RegNumber,BYTE data)
{
	BYTE 	Val = data;
	_asm {
		mov ah, PCI_FUNCTION_ID
		mov al, WRITE_CONFIG_BYTE
		mov bh, BusNumber
		mov bl, DeviceAndFunction
		mov di, RegNumber
		mov	cl, Val
		mov	ch, 0
		int 0x1A
	}
	return 0;
}

static BOOL NEARAPI PCIBIOSGetBoardConfig(WORD wDeviceID, WORD wVendorID, LPBYTE pIRQ, LPDWORD Base)
{
	BYTE  HardwareMechanism;
	WORD  BIOSVersion;
	BYTE  LastPCIBusNumber;
	BYTE  BusNumber;
	BYTE  DeviceAndFunction;
	DWORD ReadValue;

	//---- Test PCI BIOS presence
	if (!PCIBIOSPresent(&HardwareMechanism, &BIOSVersion, &LastPCIBusNumber)) {
		return FALSE;
	}
	else {
	}

	//---- Get board information
	if (!FindPCIDevice(wDeviceID, wVendorID, 0, &BusNumber, &DeviceAndFunction) == 0) {
		
		return FALSE;
	}
	//---- Get the base address for PCI9060
	if (ReadConfigDWORD(BusNumber, DeviceAndFunction, 0x10, &ReadValue) == 0) 
	{
		if (ReadValue == 0) {
			return FALSE;
		}
		*Base = ReadValue;
	}
	else {
		return FALSE;
	}


	//---- Get the IRQ line
	if (ReadConfigByte(BusNumber, DeviceAndFunction, 0x3C, pIRQ) != 0) 
	{
		return FALSE;
	}

	// Set the latency
	WriteConfigByte(BusNumber, DeviceAndFunction, 0x0D, 0x80); 

	return TRUE;
}

BOOL FARAPI HostGetBoardConfig(WORD wDeviceID,WORD wVendorID,LPBYTE pIRQ,LPDWORD Base)
{
	if (!PCIBIOSGetBoardConfig(wDeviceID,wVendorID,pIRQ,Base))
	{
		return FALSE;
	}
	return TRUE;
}
#if 0
int main()
{
	BYTE irq;
	DWORD base;

	if(HostGetBoardConfig(0x6120, 0x11de, &irq, &base))
	{
		printf("Irq = %d, Base = %lx\n", irq, base);
	}
	else
	{
		printf("Board not found!!\n");

	}
}

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\jbs\stdefs.h ===
//
// MODULE  : STDEFS.H
//	PURPOSE : Common typedefs
//	AUTHOR  : JBS Yadawa
// CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//

#ifndef __STDEFS_H

#define __STDEFS_H
#define NEARAPI 
#define FARAPI
#define Trace   5
//typedef BOOLEAN BOOL;
typedef ULONG	DWORD;
typedef USHORT	WORD;
//typedef USHORT  UINT;
typedef UCHAR	BYTE;
typedef PUCHAR		LPBYTE;
typedef PUSHORT	LPWORD;
typedef PULONG		LPDWORD;
//#define FAR
//#define NEAR

#define TRAP _asm int 3;
#endif // #ifndef __STDEFS_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\jbs\sti3520a.c ===
//
// MODULE  : STi3520A.C
//	PURPOSE : STi3520A specific code
//	AUTHOR  : JBS Yadawa
// CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//

#include "common.h"
#include "strmini.h"
#include "stdefs.h"
#include "common.h"
#include "debug.h"
#include "board.h"
#include "error.h"
#include "sti3520A.h"

static BYTE DefIntQuant[QUANT_TAB_SIZE] = {
		0x08, 0x10, 0x10, 0x13, 0x10, 0x13, 0x16, 0x16,
		0x16, 0x16, 0x16, 0x16, 0x1A, 0x18, 0x1A, 0x1B,
		0x1B, 0x1B, 0x1A, 0x1A, 0x1A, 0x1A, 0x1B, 0x1B,
		0x1B, 0x1D, 0x1D, 0x1D, 0x22, 0x22, 0x22, 0x1D,
		0x1D, 0x1D, 0x1B, 0x1B, 0x1D, 0x1D, 0x20, 0x20,
		0x22, 0x22, 0x25, 0x26, 0x25, 0x23, 0x23, 0x22,
		0x23, 0x26, 0x26, 0x28, 0x28, 0x28, 0x30, 0x30,
		0x2E, 0x2E, 0x38, 0x38, 0x3A, 0x45, 0x45, 0x53
};
	// Default Non Intra Table
static BYTE DefNonIntQuant[QUANT_TAB_SIZE];
	// Non Default Table
static BYTE QuantTab[QUANT_TAB_SIZE];


BYTE Sequence = 1;
extern WORD synchronizing;
char seq_occured;
PVIDEO pVideo;
extern PCARD pCard;

static void NEARAPI ReadHeaderDataFifo (void);
static void NEARAPI VideoAssociatePTS (void);
static void NEARAPI VideoNextStartCode (WORD i);
static void NEARAPI VideoSequenceHeader(void);
static void NEARAPI VideoExtensionHeader(void);
static void NEARAPI VideoGopHeader(void);
static void NEARAPI VideoPictureHeader(void);
static void NEARAPI VideoPictExtensionHeader(void);
static void NEARAPI VideoUser(void);
static void NEARAPI VideoSetRecons(void);
static void NEARAPI VideoStoreRFBBuf (WORD rfp, WORD ffp, WORD bfp );
static void NEARAPI VideoVsyncRout(void);
static void NEARAPI VideoChooseField(void);
static BOOL NEARAPI IsChipSTi3520(void);
static void NEARAPI VideoSetABStart(WORD abg);
static void NEARAPI VideoSetABStop(WORD abs);
static void NEARAPI VideoSetABThresh(WORD abt) ;
static void NEARAPI VideoSetBBStart(WORD bbg);
static WORD NEARAPI VideoGetBBL(void);
static void NEARAPI VideoSetBBStop(WORD bbs);
static void NEARAPI VideoSetBBThresh(WORD bbt);
static WORD NEARAPI VideoBlockMove(DWORD SrcAddress, DWORD DestAddress, WORD Size);
static void NEARAPI VideoStartBlockMove(DWORD SrcAddress, DWORD DestAddress, DWORD Size);
static void NEARAPI VideoCommandSkip(WORD Nbpicture);
static void NEARAPI VideoSetSRC(WORD SrceSize, WORD DestSize);
static void NEARAPI VideoLoadQuantTables(BOOL Intra,BYTE  * Table );
static void NEARAPI VideoComputeInst(void);
static void NEARAPI VideoWaitDec (void);
static void NEARAPI VideoStoreINS (void);
static DWORD NEARAPI ReadCDCount (void);
static DWORD NEARAPI ReadSCDCount (void);
static void NEARAPI VideoSetMWP(DWORD mwp);
static void NEARAPI VideoSetMRP(DWORD mrp);
static BOOL NEARAPI VideoMemWriteFifoEmpty( void );
static BOOL NEARAPI VideoMemReadFifoFull( void );
static BOOL NEARAPI VideoHeaderFifoEmpty( void );
static BOOL NEARAPI VideoBlockMoveIdle( void );
static void NEARAPI VideoEnableDecoding(BOOL OnOff);
static void NEARAPI VideoEnableErrConc(BOOL OnOff);
static void NEARAPI VideoPipeReset (void);
static void NEARAPI VideoSoftReset (void);
static void NEARAPI VideoEnableInterfaces (BOOL OnOff );
static void NEARAPI VideoPreventOvf(BOOL OnOff );
static void NEARAPI VideoSetFullRes(void);
static void NEARAPI VideoSetHalfRes(void);
static void NEARAPI VideoSelect8M(BOOL OnOff);
static void NEARAPI VideoSetDramRefresh(WORD Refresh);
static void NEARAPI VideoSelect20M(BOOL OnOff);
static void NEARAPI VideoSetDFA(WORD dfa);
static void NEARAPI VideoDisableDisplay(void);
static void NEARAPI VideoEnableDisplay(void);
static void NEARAPI VideoInitVar(STREAMTYPE StreamType);
static void NEARAPI VideoReset35XX(STREAMTYPE StreamType);
static void NEARAPI VideoInitPLL(void);
static void NEARAPI VideoOsdOn(void);
static void NEARAPI VideoOsdOff (void);
static void NEARAPI VideoInitOEP (DWORD point_oep);
static void NEARAPI VideoDisplayCtrl(void);
static void NEARAPI VideoSetPSV(void);
static void NEARAPI VideoSRCOn(void);
static void NEARAPI VideoSRCOff (void);
static void NEARAPI VideoFullOSD (WORD col);
static void NEARAPI VideoSeek(STREAMTYPE StreamType);


BOOL FARAPI VideoOpen(void)
{
	pVideo = pCard->pVideo;
	pVideo->errCode = NO_ERROR;
	pVideo->VideoState = StatePowerup;
	pVideo->ActiveState = StatePowerup;
	return (pVideo->errCode);
}

void FARAPI VideoClose(void)
{
}

void FARAPI VideoInitDecoder(STREAMTYPE StreamType)
{
	VideoInitVar(StreamType);
	VideoReset35XX(StreamType);
	pVideo->VideoState = StateInit;
	pVideo->ActiveState = StateInit;

}


void FARAPI VideoSeekDecoder(STREAMTYPE StreamType)
{
	VideoInitVar(StreamType);
	VideoSeek(StreamType);
	pVideo->VideoState = StateInit;
	pVideo->ActiveState = StateInit;

}

void FARAPI VideoSetMode(WORD Mode, WORD param)
{
	pVideo->DecodeMode = Mode;
	switch(pVideo->DecodeMode) {
	case PlayModeNormal:
		pVideo->fastForward = 0;
		pVideo->decSlowDown = 0;
		break;
	case PlayModeFast:
		pVideo->fastForward = 1;
		pVideo->decSlowDown = 0;
		break;
	case PlayModeSlow:
		pVideo->fastForward = 0;
		pVideo->decSlowDown = param;
		break;
	}
}

void FARAPI VideoDecode(void)
{
	switch (pVideo->VideoState)	{
	case StatePowerup:
		break;					   /* Video chip is not intialized */
	case StateInit:			   /* Starts first Sequence search. */
		HostDisableIT();
		BoardWriteVideo(ITM, 0);
		pVideo->intMask = PSD | HIT | TOP | BOT;
		BoardWriteVideo ( ITM + 1, (BYTE)(pVideo->intMask));
		BoardWriteVideo(ITM1, 0);
		HostEnableIT();

		pVideo->VideoState = StateStartup;
		pVideo->ActiveState = StateStartup;
		break;
	case StateStartup:
	case StateWaitForDTS:
	case StateDecode:
			break;
	case StatePause:
	case StateStep:
		HostDisableIT();
		pVideo->VideoState = pVideo->ActiveState;
		HostEnableIT();
		break;
	}
}

void FARAPI VideoStep(void)
{
	switch(pVideo->VideoState) {
	case StatePowerup:
	case StateInit:
		break;
	case StateStartup:
	case StateWaitForDTS:
	case StateDecode:
		VideoPause();
		VideoStep();	 // Recurse call !
		break;
	case StateStep:
		break;
	case StatePause:
		if ((!pVideo->displaySecondField) && (!(BoardReadVideo(CTL) & 0x4)))
			pVideo->displaySecondField  = 1;
		else
			pVideo->VideoState = StateStep; /* One single picture will be decoded */
			pVideo->perFrame = TRUE;
	}
}

void FARAPI VideoBack(void)
{
	switch (pVideo->VideoState) {
	case StatePowerup:
	case StateInit:
	case StateStep:
		break;
	case StateWaitForDTS:
	case StateStartup:
	case StateDecode:
		VideoPause();
	case StatePause:
		pVideo->displaySecondField = 0;
		break;
	}
}

void FARAPI VideoStop(void)
{
	switch (pVideo->VideoState)	{
	case StatePowerup:
		break;
	case StateInit:
		break;
	case StateStartup:
	case StateWaitForDTS:
	case StateDecode:
	case StateStep:
	case StatePause:
		pVideo->VideoState = StatePowerup;
		VideoInitDecoder(DUAL_PES);
		VideoMaskInt(); 
		break;
	}
}

void FARAPI VideoPause(void)
{
	switch (pVideo->VideoState)	{
	case StatePowerup:	// Not yet decoding
	case StateInit:			// Not yet decoding
	case StatePause:			// already in Pause mode
		break;
	case StateWaitForDTS:
	case StateStartup:
	case StateDecode:
	case StateStep:
		pVideo->VideoState = StatePause;
		break;
	}
/* When the video controller is in PAUSE state, the program will not store
	 any new instruction into the video decoder */
}

BOOL FARAPI AudioIsEnoughPlace(WORD size)
{
	if (VideoGetABL() >= (pVideo->AudioBufferSize - (size >> 8)) - 1)
		return FALSE;
	else
		return TRUE;
}

BOOL FARAPI VideoIsEnoughPlace(WORD size)
{
	if (VideoGetBBL() >= (pVideo->VideoBufferSize - (size >> 8)) - 1)
		return FALSE;
	else
		return TRUE;
}

DWORD FARAPI VideoGetFirstDTS(void)
{
	DWORD Ditiesse;
	WORD lattency = 1500;   /* field duration for 60 Hz video */

	if (pVideo->StreamInfo.displayMode == 0)
		lattency = 1800;	/* field duration for 50 Hz video */
	/* a B picture is displayed 1 field after its decoding starts
		 an I or a P picture is displayed 3 fields after decoding starts */
	if (pVideo->pDecodedPict->pict_type != 2) // I or P picture
		lattency = lattency * 3;
	Ditiesse = pVideo->pDecodedPict->dwPTS;
	Ditiesse = Ditiesse - lattency;

	return Ditiesse;
}

WORD FARAPI VideoGetErrorMsg(void)
{
	return pVideo->errCode;
}

void FARAPI VideoSkip(void)
{
	pVideo->fastForward = 1;
/* the variable will come back to zero when skip instruction is computed */
/* only if pVideo->DecodeMode != VIDEO_FAST */
}

void FARAPI VideoRepeat(void)
{
	pVideo->decSlowDown = 1;
/* The variable will come back to zero when repeat done */
/* only if pVideo->DecodeMode != VIDEO_SLOW */
}

WORD FARAPI VideoGetState(void)
{
	return pVideo->VideoState;
}

DWORD FARAPI VideoGetPTS(void)
{
	return pVideo->pCurrDisplay->dwPTS;
}

BOOL FARAPI VideoIsFirstDTS(void)
{
	return pVideo->FirstDTS;
}

BOOL FARAPI VideoIsFirstField(void)
{
	if ((pVideo->VsyncNumber == 1) && (pVideo->VsyncInterrupt == TRUE))
		return TRUE;
	else
		return FALSE;
}


BOOL FARAPI VideoForceBKC(BOOL bEnable)
{
	if(bEnable)
		pVideo->currDCF = pVideo->currDCF & 0xDF;	// FBC
	else
		pVideo->currDCF = pVideo->currDCF | 0x20;	// Don't FBC

	return TRUE;
}


void FARAPI VideoMaskInt (void)
{
	BoardWriteVideo( ITM, 0 );	    // mask chip interrupts before reading the status
	BoardWriteVideo( ITM + 1, 0 ); // avoids possible gliches on the IRQ line
	BoardWriteVideo( VID_ITM1, 0 );	// mask chip interrupts before
}

void FARAPI VideoRestoreInt (void)
{
	BoardWriteVideo( ITM, (BYTE)( pVideo->intMask >> 8 ) );
	BoardWriteVideo( ITM + 1,(BYTE) ( pVideo->intMask & 0xFF ) );
}

BOOL FARAPI VideoVideoInt(void)
{
	BOOL VideoITOccured = FALSE;
	WORD    compute;

	pVideo->VsyncInterrupt = FALSE;
	pVideo->FirstDTS = FALSE;      
	BoardReadVideo ( ITS1 );
   /* All interrupts except the first one are computed in this area */
	pVideo->intStatus = (WORD)BoardReadVideo ( ITS ) << 8;
   // Reading the interrupt status register
	pVideo->intStatus = BoardReadVideo ( ITS + 1 ) | pVideo->intStatus;
   // All the STI3500 interrupts are cleared */
 
	pVideo->intStatus = pVideo->intStatus & pVideo->intMask;
	// To mask the IT not used */

	while ( pVideo->intStatus )				   
	{
		VideoITOccured = TRUE;

	/******************************************************/
	/**              BOTTOM VSYNC INTERRUPT              **/
	/******************************************************/
	if ( ( pVideo->intStatus & BOT ) != 0x0 )
	{
		pVideo->intStatus = pVideo->intStatus & ~BOT;
		// clear BOT bit
		VideoChooseField ();
		pVideo->currField = BOT;
		if(pVideo->InvertedField)
			pVideo->currField = TOP;
		VideoVsyncRout ();
	}
	/******************************************************/
	/**                TOP VSYNC INTERRUPT               **/
	/******************************************************/
	if ( ( pVideo->intStatus & TOP ) != 0x0 )
	{
		pVideo->intStatus = pVideo->intStatus & ~TOP;
		// clear TOP bit

		VideoChooseField ();
		pVideo->currField = TOP;
		if(pVideo->InvertedField)
				pVideo->currField = BOT;
		VideoVsyncRout ();
	}
	/******************************************************/
	/**                   DSYNC INTERRUPT                **/
	/******************************************************/
	/***************************************************************/
	/* The DSYNC interrupt is generated on each VSYNC (RPT = 0)    */
	/* if the next INStrucztion has the EXE bit set.         */
	/* On each DSYNC a new Header Search is automatically started. */
	/***************************************************************/

	if ( ( pVideo->intStatus & PSD ) != 0x0 )
	{
		pVideo->intStatus = pVideo->intStatus & ~PSD;
		// clear PSD bit
		pVideo->VsyncNumber = 0;		   /* clear software watch-dog */
		/* check if we have reached the first picture with a PTS */


		if ( pVideo->NextInstr.Seq )		   	// first interrupt enabled (Searching Sequence)
		{
			VideoWaitDec ();		   	// put decoder in Wait mode
			pVideo->intMask = 0x1;		   		/* enable header hit interrupt */
			pVideo->NextInstr.Seq = 0;
			pVideo->NextInstr.Exe = 0;
		}
		else
		{
			Sequence = 0;
			if ( VideoGetState () == StateWaitForDTS )
			{
				if ( pVideo->pDecodedPict->validPTS == TRUE )
				{
					pVideo->FirstDTS = TRUE;
					pVideo->VideoState = StateDecode;
				}
			}


			/* Check bit buffer level consistency with pVideo->vbveDelay  */
			/* of the picture that the STi3500 starts to decode   */
			if ( ( pVideo->fieldMode == 0 ) || ( pVideo->fieldMode == 2 ) )
				// frame picture or first field of a field picture
			{
				compute = VideoGetBBL();
				if ( compute < ( 4 * pVideo->vbvDelay / 5) ) // 0.8 is 4/5 ! 
					// bit buffer level is not high enough for the next
					// picture: wait !!!
				{					   // we stop the current decoding
										 // process for two fields
					VideoEnableDecoding(OFF);
					pVideo->needDataInBuff = pVideo->currField;
				}
				
			}


			/********************************************************************/
			/*
			 * We put the decoder in wait mode on DSYNC: EXE bit reset
			 * into INS.
			 */
			/*
			 * In normal case the DSYNC interrupt is quickly followed
			 * by a
			 */
			/*
			 * Header Hit int. during which the next INS is written
			 * with EXE=1.
			 */
			/*
			 * If for any reason the header hit is delayed, the STi3500
			 * will
			 */
			/* see the notEXE and stay in WAIT mode without crashing...         */
			/* this can typically appear if the bit buffer gets empty.          */
			/********************************************************************/
			if ( !pVideo->needDataInBuff )
			{
				VideoWaitDec ();		   // put decoder in Wait mode
				pVideo->NextInstr.Exe = 0;
				// reset EXE bit.
			}

			/* update the display frame pointer for the next VSYNC */
			if ( ( pVideo->fieldMode == 0 ) || ( pVideo->fieldMode == 2 ) )
				// frame picture or first field of a field picture
			{
				pVideo->pCurrDisplay = pVideo->pNextDisplay;
				// preset the VSYNC counter
				pVideo->pictDispIndex = 0 - ( 2 * pVideo->decSlowDown );
				if ( pVideo->DecodeMode != PlayModeSlow)
					pVideo->decSlowDown = 0;		   /* allows to do the repeat
									    * function */
				BoardWriteVideo( DFP, (BYTE)( pVideo->pCurrDisplay->buffer >> 8 ) );
				BoardWriteVideo( DFP + 1, (BYTE)( pVideo->pCurrDisplay->buffer & 0xFF ) );

				pVideo->displaySecondField = 0;
				VideoChooseField ();
			}
			VideoSetPSV ();			   // update the next pan vector
			// frame picture or second field of field picture */
//			if ( ( pVideo->VideoState == StatePause ) && ( pVideo->fieldMode != 2 ) )
//				pVideo->pictureDecoded = 1;
			// to know that in step by step, the picture is decoded
		}
	}
	/******************************************************/
	/**                HEADER HIT INTERRUPT              **/
	/******************************************************/
	if ( ( pVideo->intStatus & HIT ) != 0 )
		// Test Header hit interrupt
	{
		WORD    temp = 0;

		pVideo->intStatus = pVideo->intStatus & ~HIT;
		// clear HIT bit
		while ( VideoHeaderFifoEmpty())
			/* Header fifo not available */
		{
			temp++;
			if ( temp == 0xFFFF )
			{
				if ( !pVideo->errCode )
					pVideo->errCode = BUF_EMPTY;
				SetErrorCode(ERR_HEADER_FIFO_EMPTY);
				break;
			}
		}		
							   /* Waiting... */
		compute = BoardReadVideo(HDF);
		//compute = BoardReadVideo ( HDF );
		/* load MSB */
		pVideo->hdrPos = 0;			   /* start code is MSB */
		if ( compute == 0x01 )
		{
			pVideo->hdrPos = 8;		   /* start code value is in LSB */
			pVideo->hdrNextWord = (WORD)BoardReadVideo(HDF)<<8;//BoardReadVideo ( HDF ) << 8;
			ReadHeaderDataFifo ();
			/* Result in pVideo->hdrFirstWord */
		}
		else
		{
			pVideo->hdrNextWord = 0;
			pVideo->hdrFirstWord = BoardReadVideo(HDF);
			pVideo->hdrFirstWord = pVideo->hdrFirstWord | ( compute << 8 );
		}
		/*
		 * on that point the start code value is always the MSByte of
		 * pVideo->hdrFirstWord
		 */

		switch ( pVideo->hdrFirstWord & 0xFF00 )
		{
				DWORD             buf_control;
				DWORD             size_of_pict;

			case SEQ:
				VideoSequenceHeader ();
				/* Restart Header Search */
				BoardWriteVideo ( VID_HDS, HDS );
				break;
			case EXT:
				VideoExtensionHeader ();
				BoardWriteVideo ( VID_HDS, HDS );
				/* Restart Header Search */
				break;
			case GOP:
				VideoGopHeader ();
				BoardWriteVideo ( VID_HDS, HDS );
				/* Restart Header Search */
				break;
			case PICT:
				VideoPictureHeader ();
				// This part of the code
				// Computes the size of last picture
				// and substracts it to lastbuffer level
				// This allows to track if pipe/scd are misalined
				buf_control = ReadSCDCount ();
				if ( pVideo->LastScdCount > buf_control )
					size_of_pict = ( 0x1000000L - pVideo->LastScdCount ) + buf_control;
				else
					size_of_pict = buf_control - pVideo->LastScdCount;

				pVideo->LastScdCount = buf_control;
				if ( pVideo->fastForward )
					pVideo->LastPipeReset = 3;
				pVideo->LastBufferLevel -= ( WORD ) ( size_of_pict >> 7 );
				//End of misalined pb tracking

				/* don't restart header search !!! */
				if ( pVideo->skipMode )			   // restart search only if we
										 // skip this picture
				{
				BoardWriteVideo ( VID_HDS, HDS );
					/* Restart Header Search */
				}
				break;
			case USER:				   // We don't care about user
										 // fields
				BoardWriteVideo ( VID_HDS, HDS );
				/* Restart Header Search */
				break;
			case SEQ_END:			   // end of sequence code
				compute = (WORD)BoardReadVideo ( ITS ) << 8;
				// this start code can be back to back with next one
				compute = ( compute | BoardReadVideo ( ITS + 1 ) );
				// in such case the HDS bit can be set
				pVideo->intStatus = ( pVideo->intStatus | compute ) & pVideo->intMask;
				if ( !( pVideo->intStatus & HIT ) )
				{
				BoardWriteVideo ( VID_HDS, HDS );
					/* Restart Header Search */
				}
				break;
			case SEQ_ERR:			   // the chip will enter the
										 // automatic error concealment
										 // mode
				compute = (WORD)BoardReadVideo ( ITS ) << 8;
				// this start code can be back to back with next one
				compute = ( compute | BoardReadVideo ( ITS + 1 ) );
				// in such case the HDS bit can be set
				pVideo->intStatus = ( pVideo->intStatus | compute ) & pVideo->intMask;
				if ( !( pVideo->intStatus & HIT ) )
				{
				BoardWriteVideo ( VID_HDS, HDS );
					/* Restart Header Search */
				}
				break;
			default:
				if ( !pVideo->errCode )
					pVideo->errCode = S_C_ERR;
				SetErrorCode(ERR_UNKNOWN_SC);
				// non video start code
				break;
		}

	}								   // end of header hit interrupt


	/******************************************************/
	/**            BIT BUFFER FULL INTERRUPT             **/
	/******************************************************/
	if ( ( pVideo->intStatus & BBF ) != 0x0 )
		/* Bit buffer full */
	{                         
		pVideo->intStatus = pVideo->intStatus & ~BBF;
		// clear BBF bit
		if ( pVideo->vbvReached == 1 )		   /* bit buffer level too high */
		{
			if ( !pVideo->errCode )
				pVideo->errCode = FULL_BUF;	   /* mention of the error */
		    SetErrorCode(ERR_BIT_BUFFER_FULL);
			VideoWaitDec ();			   // put decoder in Wait mode
			pVideo->NextInstr = pVideo->ZeroInstr;
		}
		else
		{
			WORD BitBufferLevel;

			BitBufferLevel = pVideo->VideoBufferSize - 2;
			VideoSetBBThresh(BitBufferLevel);
			pVideo->intMask = PID | SER | PER | PSD | BOT | TOP | BBE | HIT;
			/* enable all interrupts that may be used */
			BoardReadVideo ( ITS );
			BoardReadVideo ( ITS + 1);
			// to clear previous TOP VSYNC flag
			pVideo->NextInstr.Exe = 1;;	// decoding will start on
										// next "good" Vsync */
			pVideo->VsyncNumber = 0;
			pVideo->pictDispIndex = 1;
			pVideo->pCurrDisplay->nb_display_field = 1;
			pVideo->vbvReached = 1;
			pVideo->FistVsyncAfterVbv = NOT_YET_VST;
		}
	}


	//*****************************************************/
	//*                   pipeline ERROR                 **/
	//*****************************************************/
	// The pipeline reset is made here by software     */
	// It is also possible to enable the automatic     */
	// Pipeline reset by setting bit EPR of CTL reg.   */
	// This could be done in the Reset3500 routine    */
	// In this case the pipeline error interrupt is    */
	// only used as a flag for the external micro.     */
	//*****************************************************/
	if ( ( pVideo->intStatus & PER ) != 0x0 )
	{

		pVideo->intStatus = pVideo->intStatus & ~PER;
		// clear PER bit
//		VideoPipeReset ( pVideo );

	}


	/******************************************************/
	/**                   serious ERROR                  **/
	/******************************************************/
	if ( ( pVideo->intStatus & SER ) != 0x0 )
	{

		pVideo->intStatus = pVideo->intStatus & ~SER;
		// clear SER bit
		VideoPipeReset ();
	}

	/********************************/
	/* bit buffer empty interrupt  */
	/********************************/
	if ( ( pVideo->intStatus & BBE ) != 0x0 )
		// bit buffer empty
	{
		pVideo->intStatus = pVideo->intStatus & ~BBE;
		// clear BBE bit
	}


/********************************/
/* pipeline idle interrupt    */
/********************************/
	if ( ( pVideo->intStatus & PID ) != 0x0 )
		// pipeline idle
	{
	//***************************************
	// Check If pipe is misalined with scd
	// and restart header search if it is
	// the case
	//***************************************
		DWORD   NewCd;
		DWORD   EnterBitBuffer;
		WORD   NewBbl;
		WORD   ExpectedBbl;
		// clear PID bit
		pVideo->intStatus = pVideo->intStatus & ~PID;
		/* read BBL level */
		NewBbl = VideoGetBBL();
		/* Read number of compressed data loaded into the chip */
		NewCd = ReadCDCount ();

		if ( NewCd < pVideo->LastCdCount )
			EnterBitBuffer = ( 0x1000000L - pVideo->LastCdCount ) + NewCd;
		else
			EnterBitBuffer = ( NewCd - pVideo->LastCdCount );

		//Expected Bitbuffer level is Old bbl + what enterred - what left
		//pVideo->LastBufferLevel holds Old bbl + what enterred and has been
		// updated in picture hit interrupt.
		ExpectedBbl = (WORD)(pVideo->LastBufferLevel + ( EnterBitBuffer >> 8 ) - 2);
		if ( pVideo->LastPipeReset == 0 )
		{
			/* BBL is lower than it should be !!! */
			if ( NewBbl < ExpectedBbl )
			{
				/* here we force manually a new header search because */
				/* the pipeline is supposed to have skipped a picture */
				/* i.e. the start code detector and the pipeline are  */
				/* not synchronised on the same picture               */
				BoardWriteVideo ( VID_HDS, HDS );
				pVideo->LastPipeReset = 1;
			}
		}
		else
			{
			pVideo->LastPipeReset--;
			}
		pVideo->LastCdCount = NewCd;
		pVideo->LastBufferLevel = NewBbl;
	}

	/******************************************************/
	/**             END OF INTERRUPT ROUTINE             **/
	/******************************************************/
	/* common to all interrupts */
	/* set interrupt mask to the correct value */
}									   // end of while
return VideoITOccured;
}




/****************************************************************************/
/* notations of the bits position in pVideo->hdrFirstWord registers are     */
/* X for a nibble that must be read 			                                  */
/* x for a bit that must be read 			                                      */
/* 0 for a nibble not read 				                                          */
/* o for a bit not read 				                                            */
/* example :   0 X xxoo 0    means: bits 15 to 12 not read,                 */
/* bits 11 to 6 extracted, bits 5 to 0 not read 	                          */
/****************************************************************************/

//----------------------------------------------------------------------------
// Read of the header data fifo
//----------------------------------------------------------------------------
/*
 returns the next word(16 bits) of the
 Header data Fifo into pVideo->hdrFirstWord variable
*/
static void NEARAPI ReadHeaderDataFifo (void)
{
	WORD    i = 0;
	while ( VideoHeaderFifoEmpty()) /* Header fifo not available */
	{
		i++;
		if (i == 0xFFFF) {
			if ( !pVideo->errCode )
				pVideo->errCode = BUF_EMPTY;
			SetErrorCode(ERR_BIT_BUFFER_EMPTY);
			break;
		}
	}							   /* Waiting... */
	pVideo->hdrFirstWord = BoardReadVideo(HDF);
	if (pVideo->hdrPos == 8) {
		pVideo->hdrFirstWord = pVideo->hdrNextWord | pVideo->hdrFirstWord;
		pVideo->hdrNextWord = BoardReadVideo(HDF) << 8;
	}
	else
	{
		pVideo->hdrFirstWord = pVideo->hdrFirstWord << 8;
		pVideo->hdrFirstWord = BoardReadVideo(HDF) | pVideo->hdrFirstWord;
	}
}

//----------------------------------------------------------------------------
// Routine associating the PTS values with each picture
//----------------------------------------------------------------------------
static void NEARAPI VideoAssociatePTS (void)
{
	pVideo->pDecodedPict->validPTS = VideoIsValidPTS( );
	if(pVideo->pDecodedPict->validPTS) {
		pVideo->pDecodedPict->dwPTS = BoardReadVideoPTS( );
	}
}

//----------------------------------------------------------------------------
// Read of the next start code in the bit stream
//----------------------------------------------------------------------------
/*
		This routine is used at the end of the picture header
		when the Start Code Detection mechanism is not used
*/

static void NEARAPI VideoNextStartCode (WORD i)
{
	long temp = 0;

	if ( i )
		temp = pVideo->hdrFirstWord & 0xFF;		   // use LSB of pVideo->hdrFirstWord
	while ( temp == 0 )
	{
		ReadHeaderDataFifo ();	   // read next 16 bits
		if ( pVideo->errCode )
		{
			i = 3;
			break;
		}
		temp = ( temp << 16 ) | pVideo->hdrFirstWord;
		i = i + 2;
	}
	if ( i < 3 ) {					   // A start code is not found: bit stream error !!
		pVideo->errCode = PICT_HEAD;
		SetErrorCode(ERR_PICTURE_HEADER);
	}
	else
	{
		if ( ( temp & 0xFFFFFF00L ) == 0x00000100L )	// this is a start code
		{
			if ( !pVideo->hdrPos )		   // there is nothing into
										 // pVideo->hdrNextWord
			{
				pVideo->hdrPos = 8;
				pVideo->hdrNextWord = ( pVideo->hdrFirstWord & 0xFF ) << 8;
				ReadHeaderDataFifo ();
			}
			else
			{						   // pVideo->hdrPos = 8: the next
										 // byte is into pVideo->hdrNextWord
				pVideo->hdrFirstWord = ( pVideo->hdrFirstWord << 8 ) | ( pVideo->hdrNextWord >> 8 );
				pVideo->hdrPos = 0;
			}
		}
		else if ( ( temp & 0xFFFFFFFFL ) == 0x00000001L )	// this is a start code
		{
			ReadHeaderDataFifo ();
		}
		else {  // temp does not contain a start code : bit stream error !
			if ( !pVideo->errCode )
				pVideo->errCode = PICT_HEAD;
			SetErrorCode(ERR_PICTURE_HEADER);
		}
	}
	i = BoardReadVideo ( ITS ) << 8;   // allows to clear the Header hit bit
	i = ( i | BoardReadVideo ( ITS + 1 ) ) & 0xFFFE;	// allows to clear the
														// Header hit bit
	pVideo->intStatus = ( pVideo->intStatus | i ) & pVideo->intMask;
/* if no bit stream error, we leave the routine with the start code into pVideo->hdrFirstWord as XX00 */
}

//----------------------------------------------------------------------------
// SEQUENCE START CODE
//----------------------------------------------------------------------------
static void NEARAPI VideoSequenceHeader(void)
{
	DWORD compute, i;
	/* default intra quantization matrix */
	// default Non intra quantization matrix, All coefs = 16

	for (i = 0 ; i < QUANT_TAB_SIZE ; i++)
		DefNonIntQuant[i] = 16;

	seq_occured = 1; // mention to the picture header that a sequence has occured
									 // in order to reset the next pan offsets.

	/* Horizontal picture size is 12 bits: 00XX + X000 */
	pVideo->StreamInfo.horSize = ( pVideo->hdrFirstWord << 4 ) & 0xFFF;	// extract 8 MSB
	ReadHeaderDataFifo ();
	pVideo->StreamInfo.horSize = pVideo->StreamInfo.horSize | ( pVideo->hdrFirstWord >> 12 );	// 4 LSB of horizontal
												// size

	/* Vertical picture size is 12 bits: 0XXX */
	pVideo->StreamInfo.verSize = pVideo->hdrFirstWord & 0xFFF;	   // 12 LSB of Vertical picture
										 // size

	/* pixel aspect ratio is 4 bits: X000 */
	ReadHeaderDataFifo ();
	pVideo->StreamInfo.pixelRatio = ( pVideo->hdrFirstWord >> 12 ) & 0xF;

	/* frame rate is 4 bits: 0X00 */
	pVideo->StreamInfo.frameRate = ( pVideo->hdrFirstWord >> 8 ) & 0xF;
	pVideo->StreamInfo.displayMode = 1;					   // 60 Hz interlaced display
	pVideo->BufferA = BUFF_A_NTSC;
	pVideo->BufferB = BUFF_B_NTSC;
	pVideo->BufferC = BUFF_C_NTSC;
	switch ( pVideo->StreamInfo.frameRate )
	{
		case 1:						   // picture rate is 23.976 Hz:
			break;					   // display in 3:2 pull-down at
										 // 59.94 Hz interlaced if MPEG1
		case 2:						   // picture rate is 24 Hz:
			break;					   // display in 3:2 pull-down at
										 // 60 Hz interlaced if MPEG1
		case 3:						   // picture rate is 25 Hz:
										 // display 50 Hz interlaced
			pVideo->StreamInfo.displayMode = 0;
			pVideo->BufferA = BUFF_A_PAL;
			pVideo->BufferB = BUFF_B_PAL;
			pVideo->BufferC = BUFF_C_PAL;
			break;
		case 4:						   // picture rate is 29.97 Hz
			break;
		case 5:						   // picture rate is 30 Hz
			break;
		default:
			SetErrorCode(ERR_FRAME_RATE_NOT_SUPPORTED);
			if ( !pVideo->errCode )
				pVideo->errCode = FRAME_RATE;   /* frame rate not supported by the board */
			break;
	}

	/* bit rate is 18 bits: 00XX + XX xxoo 0  */
	pVideo->StreamInfo.bitRate = (long) pVideo->hdrFirstWord;
	pVideo->StreamInfo.bitRate = ( pVideo->StreamInfo.bitRate << 10 ) & 0x3FC00L;
	ReadHeaderDataFifo();
	pVideo->StreamInfo.bitRate = pVideo->StreamInfo.bitRate | ( pVideo->hdrFirstWord >> 6 );

	/* bit rate is 18 bits only for MPEG1 bit streams */
	if ( !pVideo->StreamInfo.modeMPEG2 )
	{
		long            tota = 400L;
		pVideo->StreamInfo.bitRate = pVideo->StreamInfo.bitRate * tota;	   /* bit rate is a multiple of 400
											* bits/s */
	}
	/*
	 * for MPEG2 bit streams bit rate is 30 bits: 12 more bits in
	 * sequence extension
	 */

	/* marker bit: 00 ooxo 0 : just skipped ... */

	/* pVideo->vbvBufferSize is 10 bits : 00 ooox X + X xooo 00 */
	pVideo->vbvBufferSize = ( pVideo->hdrFirstWord << 5 ) & 0x3E0;
	ReadHeaderDataFifo ();
	pVideo->vbvBufferSize = pVideo->vbvBufferSize | ( pVideo->hdrFirstWord >> 11 );
//	if( (!pVideo->StreamInfo.modeMPEG2) && ((pVideo->vbvBufferSize*8) > BUF_FULL) )
//	if (!pVideo->errCode) pVideo->errCode = SMALL_BUF;                    	/* Buffer size too small to decode the bit stream */
	// for MPEG2 bit streams pVideo->vbvBufferSize is 15 bits: 5 more bits in
	// sequence extension */

	// constrained flag is 1 bit: 0 oxoo 00 : just skipped... */

	// load intra quant table bit : 0 ooxo 00 */
	if ( ( pVideo->hdrFirstWord & 0x200 ) != 0 )   // Test load intra quantizer
										 // matrix */
	{
		// Read Non Default Intra Quant Table
		for ( i = 0; i < (QUANT_TAB_SIZE/2)  ; i++)
			{
			compute = pVideo->hdrFirstWord << 7;
			ReadHeaderDataFifo ();
			compute = compute | ( pVideo->hdrFirstWord >> 9 );
			QuantTab[2*i] = (BYTE)( compute >> 8 );
			QuantTab[2*i+1] = (BYTE)( compute & 0xFF );
			}
		// Load Intra Quant Tables
		VideoLoadQuantTables(TRUE , QuantTab );

		pVideo->defaultTbl = pVideo->defaultTbl & 0xE;	   // bit 0 = 0 : no default table
										 // in the chip */
	}
	else if ( !( pVideo->defaultTbl & 0x1 ) )	   // Load default intra matrix */
	{
		VideoLoadQuantTables(TRUE , DefIntQuant );
		pVideo->defaultTbl++;					   // bit 0 = 1 default intra table
										 // is in the chip */
	}

	// load non intra quant table bit : 0 ooox 00 */
	if ( ( pVideo->hdrFirstWord & 0x100 ) != 0 )   // Test load non intra quantizer
										 // matrix */
	{								   // Load non intra quantizer
										 // matrix */
		for ( i = 0; i < (QUANT_TAB_SIZE/2)  ; i++)
			{
			compute = pVideo->hdrFirstWord & 0xFF;
			QuantTab[2*i] = (BYTE)( compute );
			ReadHeaderDataFifo ();
			compute = ( pVideo->hdrFirstWord >> 8 ) & 0xFF;
			QuantTab[2*i+1] = (BYTE)( compute );
			}
		VideoLoadQuantTables(FALSE , QuantTab );
		pVideo->defaultTbl = pVideo->defaultTbl & 0xD;	   // bit 1 = 0 : no default
										 // non-intra matrix */
	}
	else if ( !( pVideo->defaultTbl & 0x2 ) )	   // default non intra table not
										 // in the chip */
	{
		VideoLoadQuantTables(FALSE , DefNonIntQuant );
		pVideo->defaultTbl = pVideo->defaultTbl | 0x2;	   // bit 1 = 1: default non intra
										 // table into the chip */
	}

	if ( ( !pVideo->StreamInfo.modeMPEG2 ) && ( pVideo->notInitDone ) )	// initialisation of the
											// frame size is only done
											// once
	{
		VideoSetPictureSize ();
//		BoardVideoSetDisplayMode ( (BYTE)(pVideo->StreamInfo.displayMode));
		VideoInitXY ();
		pVideo->notInitDone = 0;
	}
	// in case of MPEG2 bit streams the initialisation can only be done
	// after sequence extension */

	// end of sequence header analysis */
}


//----------------------------------------------------------------------------
// EXTENSION START CODE
//----------------------------------------------------------------------------
// interrupt only enabled after sequence or GOP start code */
static void NEARAPI VideoExtensionHeader(void)
{
	WORD  comput1;
	DWORD  temp;

	// extension field is 4 bits: 00X0  */
	switch ( pVideo->hdrFirstWord & 0xF0 )
	{
		//**********************************************************/
		// SEQUENCE   EXTENSION                      */
		//**********************************************************/
		case SEQ_EXT:				   // sequence extension field
									   // always present in MPEG2
			if ( !pVideo->StreamInfo.modeMPEG2 )			   // automatic detection of the
									   // standard
			{
				DWORD   tota = 400L;
				pVideo->StreamInfo.bitRate = pVideo->StreamInfo.bitRate / tota;	// bit rate was mult. by
											// 400 in sequence header
											// if pVideo->StreamInfo.modeMPEG2 = 0
				pVideo->StreamInfo.modeMPEG2 = 1;
				pVideo->NextInstr.Mp2 = 1;
				pVideo->notInitDone = 1;
			}

			/* one bit reserved for future use : 000xooo */
			/* Profile indication: 000oxxx */
			comput1 = pVideo->hdrFirstWord & 0x7;
			if ( ( comput1 != 4 ) && ( comput1 != 5 ) )	{ // main profile Id =
														// 100, simple profile =
														// 101
				SetErrorCode(ERR_PROFILE_NOT_SUPPORTED);
				if ( !pVideo->errCode )
					pVideo->errCode = MAIN_PROF;// not simple or main profile bitstream
			}
			/* Level indication: X000 */
			ReadHeaderDataFifo ();
			comput1 = pVideo->hdrFirstWord & 0xF000;
			if ( ( comput1 != 0x8000 ) && ( comput1 != 0xA000 ) )	{// main level Id = 1000,
																	// low level = 1010
				if ( !pVideo->errCode )
					pVideo->errCode = MAIN_PROF;// not low or main level bitstream
				SetErrorCode(ERR_LEVEL_NOT_SUPPORTED);
			}
			/* non interlaced sequence bit : 0 xooo 00 */
			pVideo->StreamInfo.progSeq = 0;
			if ( ( pVideo->hdrFirstWord & 0x0800 ) )	// non-interlaced frames
				pVideo->StreamInfo.progSeq = 1;

			/* chroma format is 2 bits: 0 oxxo 00 */
			// test if 4.1.1 chroma format
			if ( ( pVideo->hdrFirstWord & 0x600 ) != 0x200 ) {
				if ( !pVideo->errCode )
					pVideo->errCode = CHROMA;   // chroma format not supported
				SetErrorCode(ERR_CHROMA_FORMAT_NOT_SUPPORTED);
			}
			/* horizontal size extension is 2 bits : 0 ooox xooo 0 */
			comput1 = ( pVideo->hdrFirstWord & 0x180 );	// extract 2 MSb of
											// horizontal picture size
			pVideo->StreamInfo.horSize = pVideo->StreamInfo.horSize | ( comput1 << 3 );
			/* vertical size extension is 2 bits: 00 oxxo 0 */
			comput1 = ( pVideo->hdrFirstWord & 0x60 );	// extract 2 MSb of
											// vertical picture size
			pVideo->StreamInfo.verSize = pVideo->StreamInfo.verSize | ( comput1 << 5 );

			/* bit rate extension is 12 bits: 00 ooox X + X xxxo 00 */
			temp = ( pVideo->hdrFirstWord & 0x1F ) << 25;
			ReadHeaderDataFifo ();
			temp = ( ( pVideo->hdrFirstWord & 0xFE00 ) << 9 ) | temp;
			pVideo->StreamInfo.bitRate = temp | pVideo->StreamInfo.bitRate;
			if ( pVideo->StreamInfo.bitRate > 37500L )   // more than 15 Mbits/s
			{
				if ( !pVideo->errCode )
					pVideo->errCode = HIGH_BIT_RATE;	// put a warning only for the eval board
				SetErrorCode(ERR_BITRATE_TO_HIGH);
			}
			else
			{
				long            tota = 400L;
				pVideo->StreamInfo.bitRate = pVideo->StreamInfo.bitRate * tota;	/* bit rate is a multiple of 400 bits/s */
			}

			/* marker bit: 0 ooox 00 : just skipped */

			/* pVideo->vbvBufferSize_extension is 8 bits : 00 XX */
			pVideo->vbvBufferSize = pVideo->vbvBufferSize | ( ( pVideo->hdrFirstWord & 0xFF ) << 10 );
			// frame rate extension not tested here */
			if ( pVideo->notInitDone )
			{
				VideoSetPictureSize ();
//				BoardVideoSetDisplayMode ( (BYTE)(pVideo->StreamInfo.displayMode) );
				VideoInitXY ();
				pVideo->notInitDone = 0;
			}
			break;
			// end of sequence extension field */


			//**********************************************************/
			// SEQUENCE   DISPLAY   EXTENSION              */
			//**********************************************************/
		case SEQ_DISP:				   // sequence display extension
										 // field
			pVideo->seqDispExt = 1;
			/* video format is 3 bits: 00 0 xxxo : not used... */

			/* colour description is 1 bit : 00 0 ooox */
			if ( pVideo->hdrFirstWord & 0x1 )
			{
				ReadHeaderDataFifo ();
				/* colour primaries is 8 bits: XX 00 : not used... */
				/*
				 * transfer characteristics is 8 bits: 00 XX : not
				 * used...
				 */
				ReadHeaderDataFifo ();
				/* matrix coefficients is 8 bits: XX 00: not used... */

				/*
				 * pan_horizontal_dimension is 14 bits: 00 XX + X xxoo
				 * 00
				 */
				pVideo->StreamInfo.horDimension = ( pVideo->hdrFirstWord & 0xFF ) << 6;
				ReadHeaderDataFifo ();
				pVideo->StreamInfo.horDimension = pVideo->StreamInfo.horDimension | ( ( pVideo->hdrFirstWord & 0xFC00 ) >> 10 );

				/* skip marker bit : 0ooxo 00 */

				/*
				 * pan_vertical_dimension is 14 bits: 0 ooox XX + X
				 * xooo 00
				 */
				pVideo->StreamInfo.verDimension = ( pVideo->hdrFirstWord & 0x1FF ) << 5;
				ReadHeaderDataFifo ();
				pVideo->StreamInfo.verDimension = pVideo->StreamInfo.verDimension | ( ( pVideo->hdrFirstWord & 0xF800 ) >> 11 );
			}
			else
			{
				/* pan_horizontal_dimension is 14 bits: XX X xxoo */
				ReadHeaderDataFifo ();
				pVideo->StreamInfo.horDimension = ( pVideo->hdrFirstWord & 0xFFFC ) >> 2;

				/* skip marker bit : 00 0 ooxo */

				/*
				 * pan_vertical_dimension is 14 bits: 00 0 ooox + XX X
				 * xooo
				 */
				pVideo->StreamInfo.verDimension = ( pVideo->hdrFirstWord & 0x1 ) << 13;
				ReadHeaderDataFifo ();
				pVideo->StreamInfo.verDimension = pVideo->StreamInfo.verDimension | ( ( pVideo->hdrFirstWord & 0xFFF8 ) >> 3 );
			}
			/* pVideo->StreamInfo.horDimension and pVideo->StreamInfo.verDimension represent the area of the decoded       */
			/* picture that will be displayed on the full screen            */
			/*
			 * this area should be interpolated to the size of the
			 * display
			 */
			/*
			 * this is not possible vertically. Horizontally the SRC is
			 * used
			 */
			/* to deliver 720 pixels                                        */
			if ( pVideo->StreamInfo.horDimension < pVideo->StreamInfo.horSize )
			{
				DWORD  lsr;
				BYTE i;
				// lsr = 256 * (pVideo->StreamInfo.horSize-4) / (display size - 1)
				lsr = ( 256 * ( long ) ( pVideo->StreamInfo.horDimension - 4 ) ) / 719;
				if ( lsr < 32 )
					lsr = 32;
				i = BoardReadVideo ( LSO );
				BoardWriteVideo ( LSO, i );	// programmation of the
												// SRC
				BoardWriteVideo ( LSR, (BYTE)lsr );
				i = BoardReadVideo ( CSO );
				BoardWriteVideo ( CSO,i);
				if ( !pVideo->useSRC )	   // flag enabling or not the use of SRC
				{
					VideoSRCOn ();
				}
			}
			break;


		default:					   /* other extension fields are
									    * not tested here */
			break;					   /* extensions related to the
									    * picture are tested at the end
											* of the picture header */
	}
}

//----------------------------------------------------------------------------
// G.O.P. START CODE
//----------------------------------------------------------------------------
/* GOP informations are extracted but not used ! */
static void NEARAPI VideoGopHeader(void)
{
	WORD    compute;

	pVideo->hdrHours = (BYTE) ( pVideo->hdrFirstWord >> 2 ) & 0x1F;   /* Skip drop frame flag */
	compute = ( pVideo->hdrFirstWord << 4 ) & 0x3F;
	ReadHeaderDataFifo ();
	pVideo->hdrMinutes = (BYTE)(( pVideo->hdrFirstWord >> 12 ) | compute);
	pVideo->hdrSeconds = (BYTE)( pVideo->hdrFirstWord >> 5 ) & 0x3F;
	compute = ( pVideo->hdrFirstWord << 1 ) & 0x3F;
	ReadHeaderDataFifo ();
	pVideo->pictTimeCode = (BYTE)(( pVideo->hdrFirstWord >> 15 ) | compute);
	if ( pVideo->StreamInfo.countGOP != 0 )
		pVideo->StreamInfo.countGOP = pVideo->StreamInfo.countGOP | 0x100;   /* Second Gop */
	// to avoid any confusion between gops when testing the pVideo->decSlowDownral
	// ref. for display
	pVideo->GOPindex = pVideo->GOPindex + 0x4000;
}

//----------------------------------------------------------------------------
// PICTURE START CODE
//----------------------------------------------------------------------------
static void NEARAPI VideoPictureHeader(void)
{
	WORD    comput1;
	DWORD   temp;

	// Determine which picture variable can be used to store the next
	// decoding parameters.
	// We use the next variable in pVideo->pictArray table, because the
	// corresponding frame
	// has been already displayed.
	// The decoded picture buffer is not incremented if we are on a
	// second field picture
	// or if we have decided to skip the previous picture.
	// The first_field attribute is not changed on the second field of
	// 2 field pictures.
	if ( ( !pVideo->skipMode ) && ( pVideo->fieldMode < 2 ) )
	{
		WORD	i;						   // increment picture buffer
		for ( i = 0; i < 4; i++ )
			if ( pVideo->pictArray[i].tempRef == 1025 )
			{
				pVideo->pDecodedPict = &pVideo->pictArray[i];
				break;
			}
		// We always initialise first_field to TOP (default for MPEG1).
		// It could be changed in case of 3:2 pull-down in MPEG1
		// or into the picture coding extension for MPEG2 bit stream.
		pVideo->pDecodedPict->first_field = TOP;
	}


	pVideo->currPictCount++;
	if ( pVideo->currPictCount == 6 )
	{
	// Unforce the border color and start displaying
		pVideo->currDCF = pVideo->currDCF | 0x20;
		BoardWriteVideo ( DCF, 0 );
		BoardWriteVideo ( DCF + 1, (BYTE)(pVideo->currDCF));
	}

	// write the latest transmitted pan offsets into the new pVideo->pictArray
	// variable
	// those offsets may be changed in the picture pan and scan
	// extension...
	// for MPEG1 bit stream they remain to zero.
	// if a sequence had occured since the last decoded picture the pan
	// offsets are all reset to 0
	if ( seq_occured )
	{
		pVideo->latestPanHor = 0;
		pVideo->latestPanVer = 0;
	}
	for ( comput1 = 0; comput1 < 3; comput1++ )
	{
		pVideo->pDecodedPict->pan_hor_offset[comput1] = pVideo->latestPanHor;
		pVideo->pDecodedPict->pan_vert_offset[comput1] = pVideo->latestPanVer;
	}
	seq_occured = 0;

	/* start analysis of the picture header */
	comput1 = pVideo->hdrFirstWord << 2;
	ReadHeaderDataFifo ();		   /* read next 16 bits */

	/* picture pVideo->decSlowDownral reference is 10 bits: 00XX + xxoo 000 */
	pVideo->pDecodedPict->tempRef = comput1 | ( pVideo->hdrFirstWord >> 14 ) | pVideo->GOPindex;

	/* picture type is 3 bits : ooxx xooo 00 */
	pVideo->pDecodedPict->pict_type = (BYTE)( pVideo->hdrFirstWord >> 11 ) & 0x7;	// set picture type of
															// decoded picture
	pVideo->NextInstr.Pct =(BYTE) (pVideo->pDecodedPict->pict_type)&0x3; /* Picture type in instruction register */
															// Only 2 bits are stored
	if ( pVideo->skipMode )	// We are on the second picture:
													// the previous one will be
													// skipped
		pVideo->skipMode++;
	else							      // !pVideo->skipMode. We skip a picture if
													// pVideo->fastForward = 1 and on B pictures
													// only
		if ( pVideo->fastForward && ( pVideo->fieldMode < 2 ) )
		{
			pVideo->NotSkipped++;

			if ( ( pVideo->pDecodedPict->pict_type == 3 )	// we are on a B picture
				 || ( ( pVideo->NotSkipped > 5 ) && ( pVideo->pDecodedPict->pict_type == 2 ) ) )	// we are on a P picture
																										// we are on a B
																										// picture
			{
				pVideo->NotSkipped = 0;
				pVideo->skipMode = 1;	// this picture will be skipped
			}
		}
	/* pVideo->vbvDelay is 16 bits: O oxxx XX + X xooo OO */
	comput1 = pVideo->hdrFirstWord << 5;		   /* VBV delay is 16 bits */
	ReadHeaderDataFifo ();		   /* read next 16 bits */
	comput1 = comput1 | ( pVideo->hdrFirstWord >> 11 );
	if (( comput1 == 0 )||( comput1 >= 0x3000 ))
		// 0x0 means that the pVideo->vbvDelay is not compliant with MPEG !
		// 0xFFFF variable bitrate
		comput1 = 0x3000;			   // we force it to an average
										 // pVideo->vbvDelay ...
	temp = ( ( long ) comput1 * ( pVideo->StreamInfo.bitRate / ( 2048 ) ) ) / 90000L;	/* 2048 = 8*256 ! */

	if ( temp < 0x20 )
		temp = 0x20;
	if ( temp > 0x330 )
		temp = 0x330;

	pVideo->vbvDelay = (WORD)temp;
	if ( !pVideo->vbvReached )				   /* BBT set to vbv value for the
										* first picture */
	{
		VideoSetBBThresh((WORD)temp);
		pVideo->intMask = 0x8;			   /* Enable buffer full interrupts */
	}

	temp = 10;						   /* number of bits - 1 not
											* analysed in pVideo->hdrFirstWord */
	if ( pVideo->StreamInfo.countGOP < 0x100 )		   /* To init the GOP structure */
	{								   /* this is only done for display
											* of the GOP structure */
		if ( pVideo->StreamInfo.countGOP < 28 )
		{
			if ( pVideo->pDecodedPict->pict_type == 1 )	/* I picture */
				pVideo->StreamInfo.firstGOP[pVideo->StreamInfo.countGOP] = 'I';
			else if ( pVideo->pDecodedPict->pict_type == 2 )	/* P picture */
				pVideo->StreamInfo.firstGOP[pVideo->StreamInfo.countGOP] = 'P';
			else if ( pVideo->pDecodedPict->pict_type == 3 )	/* B picture *//* B
															 * picture */
				pVideo->StreamInfo.firstGOP[pVideo->StreamInfo.countGOP] = 'B';
			else
				pVideo->StreamInfo.firstGOP[pVideo->StreamInfo.countGOP] = 'D';	/* D picture */
			pVideo->StreamInfo.firstGOP[pVideo->StreamInfo.countGOP + 1] = 0;
		}
		pVideo->StreamInfo.countGOP++;
	}

	/* P or B picture forward vectors extraction */
	if ( ( pVideo->pDecodedPict->pict_type == 2 ) ||
		 ( pVideo->pDecodedPict->pict_type == 3 ) )	/* P or B picture */
	{

		/* full_pixel_forward_vector is one bit: 0 oxoo 00 */
		if ( ( pVideo->hdrFirstWord & 0x400 ) != 0 )
			pVideo->NextInstr.Ffh = 0x8; //Msb of FFH is 1
		else
			pVideo->NextInstr.Ffh = 0;
		/* forward_f_code is 3 bits: 0 ooxx xooo 0 */
		comput1 = ( pVideo->hdrFirstWord >> 7 ) & 0x7;
		pVideo->NextInstr.Ffh = (BYTE)(pVideo->NextInstr.Ffh | comput1);
		temp = 6;					   /* number of bits - 1 not
										* analysed in pVideo->hdrFirstWord */
	}

	/* B picture backward vector extraction */
	if ( pVideo->pDecodedPict->pict_type == 3 )	/* B picture */
	{

		/* full_pixel_backward_vector is one bit: 00 oxoo 0 */
		if ( ( pVideo->hdrFirstWord & 0x40 ) != 0 )
			pVideo->NextInstr.Bfh = 0x8;// Msb of Bfh is 1
		else
			pVideo->NextInstr.Bfh = 0x0;// Msb of Bfh is 0
		/* backward_f_code is 3 bits: 00 ooxx xooo */
		comput1 = ( pVideo->hdrFirstWord >> 3 ) & 0x0007;
		pVideo->NextInstr.Bfh = (BYTE)(pVideo->NextInstr.Bfh | comput1);
		temp = 2;	/* number of bits - 1 not analysed in pVideo->hdrFirstWord */
	}


	/*
	 * If extra informations picture follow they must be extracted from
	 * the header FIFO
	 */
	/*
	 * it is not possible to restart the header search as the next
	 * header may be a picture one
	 */
	/*
	 * the research of the first Slice is made by polling of the header
	 * fifo
	 */
	while ( !pVideo->errCode && ( ( pVideo->hdrFirstWord & ( 1 << temp ) ) != 0 ) )	/* extra bit picture = 1 */
	{	 /* if extra bit picture = 1 , 8 bits follow */
		if ( temp <= 8 )
		{
			ReadHeaderDataFifo ();
			temp = temp + 16;
		}
		temp = temp - 9;			   /* skip 8 bit of extra
											* information picture */
	}								   /* and next extra bit picture
											* bit */

	/*
	 * if extension or user data follow they must be extracted from the
	 * header
	 */
	pVideo->hdrFirstWord = pVideo->hdrFirstWord & ( ( 1 << temp ) - 1 );
	if ( pVideo->hdrFirstWord != 0 ) {/* all remaining bits should be zero */
		if ( !pVideo->errCode ) {
			pVideo->errCode = PICT_HEAD;		   /* picture header should be followed by a start code (at least slice) */
		}
		SetErrorCode(ERR_PICTURE_HEADER);
	}
	if ( temp > 7 )	/* LSbyte of pVideo->hdrFirstWord is part of the next start code */
		VideoNextStartCode (1 );		   // already one byte into
										 // pVideo->hdrFirstWord
	else
		VideoNextStartCode (0 );

	/*
	 * at this point pVideo->hdrFirstWord contains the next start code value in the
	 * MSByte
	 */
	while (!pVideo->errCode) {
		if ( ( pVideo->hdrFirstWord & 0xFF00 ) == 0x0100 )
			break;	// we have reached the slice start code
		else if ( ( pVideo->hdrFirstWord & 0xFF00 ) == USER )
			VideoUser ();
		else if ( ( pVideo->hdrFirstWord & 0xFF00 ) == EXT )	// there can be several
													// extension fields
			VideoPictExtensionHeader ();
		else
			break;
	}
	/*
	 * We have reached the first Slice start code: all parameters are
	 * ready for next decoding
	 */

	/* end of picture header + picture extensions decoding */
	VideoAssociatePTS ();

	if ( ( !pVideo->fieldMode && ( pVideo->skipMode != 1 ) ) || ( pVideo->fieldMode && ( !pVideo->skipMode || ( pVideo->skipMode == 3 ) ) ) )
	{
		VideoSetRecons ();			   // initialise RFP, FFP and BFP
		if ( ( pVideo->fieldMode == 0 ) || ( pVideo->fieldMode == 2 ) )	// we are on a frame
															// picture or the first
															// field of a field
															// picture
			VideoDisplayCtrl ();		   // computes the next frame to
										 // display
	}

	// implementation of 3:2 pull-down functionality on MPEG1 bit
	// streams
	// encoded at 23.97Hz or 24 Hz and displayed at 60 Hz.
	// 3:2 pull-down on MPEG2 bit streams must be controlled with
	// "repeat_first_field" bit
	if ( ( !pVideo->StreamInfo.modeMPEG2 ) && ( ( pVideo->StreamInfo.frameRate == 1 ) || ( pVideo->StreamInfo.frameRate == 2 ) ) )
	{
		if ( pVideo->pCurrDisplay->nb_display_field == 2 )
		{							   /* same field polarity for the
											* next frame */
			pVideo->pNextDisplay->nb_display_field = 3;
			if ( pVideo->pCurrDisplay->first_field == TOP )
				pVideo->pNextDisplay->first_field = TOP;
			else
				pVideo->pNextDisplay->first_field = BOT;
		}
		else
		{							   // previous picture was
										 // displayed 3 times        	//
										 // the first field polarity is
										 // changing
			pVideo->pNextDisplay->nb_display_field = 2;
			if ( pVideo->pCurrDisplay->first_field == TOP )
				pVideo->pNextDisplay->first_field = BOT;
			else
				pVideo->pNextDisplay->first_field = TOP;
		}
	}


	if ( pVideo->vbvReached )					   // enable next instruction if
										 // not skipping a picture
	{
		if ( !pVideo->skipMode )				   // no skipped picture
		{
			pVideo->NextInstr.Exe  = 1;	// enable EXE bit
			pVideo->NextInstr.Skip = 0;
			pVideo->currCommand = 0;			   // reset skip bits
		}
		else if ( ( pVideo->skipMode == 2 ) && !pVideo->fieldMode )
			// skip == 2: We are on the picture following a skipped one
			// the instruction can be stored with associated skip bits
			// in CMD
		{
	//	HostDirectPutChar('1', BLACK, LIGHTGREEN);
			pVideo->currCommand = 0x10;			   // pVideo->skipMode 1 picture
			pVideo->NextInstr.Exe  = 1;	// enable EXE bit
			pVideo->NextInstr.Skip = 1;	// skip 1 picture
			pVideo->skipMode = 0;
			if ( pVideo->DecodeMode != PlayModeFast )
				pVideo->fastForward = 0;			   /* allows to skip only one
										* picture */
		}
		else if ( pVideo->skipMode == 3 )
		{
//	HostDirectPutChar('2', BLACK, LIGHTGREEN);
			// we are on the picture following two skipped fields
			pVideo->currCommand = 0x20;			   // pVideo->skipMode 2 fields
			pVideo->NextInstr.Exe  = 1;	// enable EXE bit
			pVideo->NextInstr.Skip = 2;	// Skip 2 fields
			pVideo->skipMode = 0;
			if ( pVideo->DecodeMode != PlayModeFast)
				pVideo->fastForward = 0;			   /* allows to skip only one
										* picture */
		}

		/*
		 * store the next instruction if we are on the good field to do
		 * it
		 */
		if ( ( ( pVideo->pictDispIndex >= pVideo->pCurrDisplay->nb_display_field - 1 ) && !pVideo->fieldMode )
			 || ( ( pVideo->fieldMode == 2 ) && ( pVideo->pictDispIndex >= pVideo->pCurrDisplay->nb_display_field - 2 ) ) )
		{
			if ( pVideo->pNextDisplay->first_field != pVideo->currField )
				VideoWaitDec ();		   // this is the opposite phase:
										 // put decoder in wait mode
			else
				// store the next instruction that will be taken into
				// account on the next VSYNC
				VideoStoreINS ();		   // store next INS in case where
										 // enough VSYNC already occured
		}
		else if ( pVideo->fieldMode == 1 )
			VideoStoreINS ();
	}

	// clear Header hit flag due to polling of extension or user bits
	// after the picture start code
	// but keep track of possible other interrupt
	comput1 = (WORD)BoardReadVideo ( ITS ) << 8;
	comput1 = ( comput1 | BoardReadVideo ( ITS + 1 ) ) & 0xFFFE;	// allows to clear the
																	// Header hit bit
	pVideo->intStatus = ( pVideo->intStatus | comput1 ) & pVideo->intMask;

}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
/***************************************************************/
/*     This is an extension start code following a picture     */
/*        In MPEG2 bit stream, this start code can be:         */
/*        Picture Coding  (always)                             */
/*        Quant matrix    (optional)                           */
/*        Picture Pan & Scan (optional)                        */
/*        Picture Scalable (optional)   : not tested yet       */
/***************************************************************/
static void NEARAPI VideoPictExtensionHeader(void)
{
	WORD    comput1, i;
	WORD    compute;		   // need to be int!!
	BYTE	   QuantTab[QUANT_TAB_SIZE];

	/* extension Id is 4 bits: 00 X0 */
	comput1 = pVideo->hdrFirstWord & 0xF0;
	switch ( comput1 )
	{
		/******* picture coding extension *******/
		case PICT_COD:
			if ( pVideo->StreamInfo.modeMPEG2 )
			{
				// clear top field first,forward and backward f_code,
				// motion vectors flag
				pVideo->NextInstr.Tff = 0; //pVideo->nextInstr1 & 0x403E;
				pVideo->NextInstr.Bfh = 0;
				pVideo->NextInstr.Ffh = 0;
				pVideo->NextInstr.Cmv = 0;

				pVideo->NextInstr.Pst = 0;
				pVideo->NextInstr.Bfv = 0;
				pVideo->NextInstr.Ffv = 0;
				pVideo->NextInstr.Dcp = 0;
				pVideo->NextInstr.Frm = 0;
				pVideo->NextInstr.Qst = 0;
				pVideo->NextInstr.Azz = 0;
				pVideo->NextInstr.Ivf = 0;

				// forward_horizontal_f_code is 4 bits: 00 0X
				comput1 = pVideo->hdrFirstWord & 0xF;
				pVideo->NextInstr.Ffh = (BYTE)comput1;

				// forward_vertical_f_code is 4 bits: X0 00
				ReadHeaderDataFifo ();
				comput1 = pVideo->hdrFirstWord & 0xF000;
				comput1 = comput1 >> 12;
				pVideo->NextInstr.Ffv =  (BYTE)comput1;

				// backward_horizontal_f_code is 4 bits: 0X 00
				comput1 = pVideo->hdrFirstWord & 0xF00;
				comput1 = comput1 >>8;
				pVideo->NextInstr.Bfh = (BYTE)comput1;

				// backward_vertical_f_code is 4bits: 00 X0
				comput1 = pVideo->hdrFirstWord & 0xF0;
				comput1 = comput1 >> 4;
				pVideo->NextInstr.Bfv =  (BYTE)comput1;

				// intra DC precision is 2 bits: 00 0 xx00
				comput1 = pVideo->hdrFirstWord & 0x0C;
				if ( comput1 == 0xC ) {
					if ( !pVideo->errCode ) {
						pVideo->errCode = DC_PREC;	// 11 bit DC precision
					}
					SetErrorCode(ERR_INTRA_DC_PRECISION);
				}
				pVideo->NextInstr.Dcp = (BYTE)( comput1 >> 2 );

				// picture structure is 2 bits: 00 0 ooxx
				pVideo->pDecodedPict->pict_struc = (BYTE)(pVideo->hdrFirstWord & 0x3);
				pVideo->NextInstr.Pst = pVideo->pDecodedPict->pict_struc ;
				if ( pVideo->pDecodedPict->pict_struc == 3 )	// frame picture
					pVideo->fieldMode = 0;
				else				   // field picture
				if ( pVideo->fieldMode == 2 )
					pVideo->fieldMode = 1;	   // second field
				else
				{
					pVideo->fieldMode = 2;	   // first field
					if ( pVideo->pDecodedPict->pict_struc == 2 )	// bottom field is the
																// first field
						pVideo->pDecodedPict->first_field = BOT;
				}
				ReadHeaderDataFifo ();

				// top_field_first bit is one bit: xooo 0 00
				// first_field is already initialised to TOP (beginning
				// of picture header)
				if ( ( !pVideo->StreamInfo.progSeq ) && ( pVideo->pDecodedPict->pict_struc == 3 ) )
				{					   // this is an interlaced frame
									   // picture
					if ( ( ( pVideo->hdrFirstWord & 0x8000 ) != 0 ) )	// top field first
						pVideo->NextInstr.Tff = 1;	 // set top_field_first
					else			  				 // top_field_first already reset
													 // into pVideo->NextInstr
						pVideo->pDecodedPict->first_field = BOT;	// bottom field is BOT
																// field
				}
				if ( pVideo->vbvReached == 0 )   // pre-initialise for start of
										 // the first decoding task
				{					   // on the good field polarity
					pVideo->pictArray[0].first_field = pVideo->pDecodedPict->first_field;
					pVideo->pictArray[1].first_field = pVideo->pDecodedPict->first_field;
					pVideo->pictArray[2].first_field = pVideo->pDecodedPict->first_field;
					pVideo->pictArray[3].first_field = pVideo->pDecodedPict->first_field;
				}

				// frame_pred_frame_DCT is one bit: oxoo 0 00
				if ( ( pVideo->hdrFirstWord & 0x4000 ) != 0 )
					pVideo->NextInstr.Frm = 1 ;	// frame DCT and 16x16
													// prediction

				// concealment_motion_vectors flag is one bit: ooxo 0
				// 00
				if ( pVideo->hdrFirstWord & 0x2000 )
					pVideo->NextInstr.Cmv = 1;

				// qscale_type is one bit: ooox 0 00
				if ( ( pVideo->hdrFirstWord & 0x1000 ) != 0 )
					pVideo->NextInstr.Qst = 1;	// non linear quantizer
													// scale

				// intra_vlc_format is one bit: 0 xooo 00
				if ( ( pVideo->hdrFirstWord & 0x800 ) != 0 )
					pVideo->NextInstr.Ivf = 1;	// alternative intra VLC
													// table

				// alternate scan bit: 0 oxoo 00
				if ( ( pVideo->hdrFirstWord & 0x400 ) != 0 )
					pVideo->NextInstr.Azz = 1;	// alternative scan

				// repeat_first_field is one bit: 0 ooxo 00
				// A 2 field picture is considered as one picture
				// displayed twice
				pVideo->pDecodedPict->nb_display_field = 2;	// display picture
														// during 2 fields
														// period
				if ( pVideo->pDecodedPict->pict_struc == 3 )	// frame picture
				{
					if ( pVideo->hdrFirstWord & 0x200 )	// repeat first field
						pVideo->pDecodedPict->nb_display_field = 3;	// display picture
																// during 3 fields
																// period
				}

				// chroma_postprocessing_type is one bit: 0 ooox 00
				if ( ( pVideo->hdrFirstWord & 0x100 ) )
				{
					// use the field repeat mode for chroma vertical
					// filter (if enabled)
					pVideo->fullVerFilter = pVideo->fullVerFilter | 0x2;
					pVideo->currDCF = pVideo->currDCF | 0x2;
				}
				else
				{
					// use the line repeat mode for chroma vertical
					// filter (if enabled)
					pVideo->fullVerFilter = pVideo->fullVerFilter & 0xFFFD;
					pVideo->currDCF = pVideo->currDCF & 0xFFFD;
				}
				BoardWriteVideo ( DCF, 0 );
				BoardWriteVideo ( DCF + 1, (BYTE)(pVideo->currDCF));
				// progressive_frame is one bit: 00 xooo 0

				// composite_display_flag is one bit: 00 oxoo 0
				if ( pVideo->hdrFirstWord & 0x40 )
				{
					// v_axis is one bit: 00 ooxo 0
					// field_sequence is 3 bits: 00 ooox xxoo
					// sub_carrier is one bit: 00 0 ooxo
					ReadHeaderDataFifo ();
					// burst_amplitude is 7 bit: 00 0 ooox + X xooo 00
					// sub_carrier_phase is 8 bits: 0 oxxx X xooo
					// check the 3 lsb of pVideo->hdrFirstWord: next info must be a
					// start code
					if ( pVideo->hdrFirstWord & 0x7 ) {
						if ( !pVideo->errCode ) {
							pVideo->errCode = PICT_HEAD;
						}
						SetErrorCode(ERR_PICTURE_HEADER);
					}
					VideoNextStartCode (0 );
				}
				else
				{
					if ( pVideo->hdrFirstWord & 0x3F ) {
						if ( !pVideo->errCode )
							pVideo->errCode = PICT_HEAD;
						SetErrorCode(ERR_PICTURE_HEADER);
					}
					VideoNextStartCode (0 );
				}
			}						   // end of if pVideo->StreamInfo.modeMPEG2
			break;


			/******* Quantization table extension *******/
		case QUANT_EXT:
			/* load_intra_quantizer_matrix is one bit: 00 0 xooo */
			if ( ( pVideo->hdrFirstWord & 0x8 ) != 0 )
			{						   /* Load intra quantizer matrix */
				/* two quant values are 16 bits: 00 0 oxxx + XX X xooo */
			// Read Non Default Intra Quant Table
			for ( i = 0; i < (QUANT_TAB_SIZE/2)  ; i++)
				{
				compute = pVideo->hdrFirstWord << 13;
				ReadHeaderDataFifo ();
				compute = compute | ( pVideo->hdrFirstWord >> 3 );
				QuantTab[2*i] = (BYTE)( compute >> 8 );
				QuantTab[2*i+1] = (BYTE)( compute & 0xFF );
				}
			// Load Intra Quant Tables
			VideoLoadQuantTables(TRUE , QuantTab );
			pVideo->defaultTbl = pVideo->defaultTbl & 0xE;	   // bit 0 = 0 : no default table
										 // in the chip */
			}
			/* load_non_intra_quantizer_matrix is one bit: 00 0 oxoo */
			if ( ( pVideo->hdrFirstWord & 0x4 ) != 0 )
			{						   /* Load non intra quantizer matrix */
				// Read Non Default Non Intra Quant Table
				for ( i = 0; i < (QUANT_TAB_SIZE/2)  ; i++)
					{
					compute = pVideo->hdrFirstWord << 14;
					ReadHeaderDataFifo ();
					compute = compute | ( pVideo->hdrFirstWord >> 2 );
					QuantTab[2*i] = (BYTE)( compute >> 8 );
					QuantTab[2*i+1] = (BYTE)( compute & 0xFF );
					}
				// Load Non Intra Quant Tables
				VideoLoadQuantTables(FALSE , QuantTab );
				pVideo->defaultTbl = pVideo->defaultTbl & 0xD;	/* bit 1 = 0 : no default
											 * non-intra matrix */
			}
			// check the 2 lsb of pVideo->hdrFirstWord: next info must be a start
			// code
			if ( pVideo->hdrFirstWord & 0x3 ) {
				if ( !pVideo->errCode )
					pVideo->errCode = PICT_HEAD;
				SetErrorCode(ERR_PICTURE_HEADER);
			}
			VideoNextStartCode (0 );
			break;


			/******* picture pan and scan extension *******/
		case PICT_PSV:
			/**************************************************************/
			/* The programmation of the STi3500 offsets is given by:      */
			/* PSV = integer part of (pVideo->StreamInfo.horSize/2 - pVideo->StreamInfo.horDimension/2 + offset)    */
			/*
			 * LSO = fractional part of (pVideo->StreamInfo.horSize/2 - pVideo->StreamInfo.horDimension/2 +
			 * offset)
			 */
			/**************************************************************/

			/* pan_horizontal_offset_integer is 12 bits: 00 0X + XX 00 */
			pVideo->latestPanHor = ( pVideo->hdrFirstWord & 0xF ) << 12;
			ReadHeaderDataFifo();
			pVideo->latestPanHor = pVideo->latestPanHor | ( ( pVideo->hdrFirstWord & 0xFF00 ) >> 4 );
			// pan_horizontal_offset has been multiplied by 16
			/* pan_horizontal_offset_sub_pixel is 4 bits: 00 X0 */
			/* that are concatenated with the integer part */
			pVideo->latestPanHor = pVideo->latestPanHor | ( ( pVideo->hdrFirstWord & 0xF0 ) >> 4 );
			// to simplify, the 2 last instructions can be concatenated
			// in:
			// pVideo->latestPanHor = pVideo->latestPanHor | ((pVideo->hdrFirstWord & 0xFFF0)
			// >> 4);
			// note that pVideo->latestPanHor is a signed int

			// marker bit 00 0 xooo: just skipped

			/*
			 * pan_vertical_offset_integer is 12 bits: 00 0oxxx + XX
			 * xooo0
			 */
			pVideo->latestPanVer = ( pVideo->hdrFirstWord & 0x7 ) << 13;
			ReadHeaderDataFifo ();

			/* pan_vertical_offset_sub_pixel is 4 bits: 00 oxxx xooo */
			// they are linked with the integer part
			pVideo->latestPanVer = pVideo->latestPanVer | ( ( pVideo->hdrFirstWord & 0xFFF8 ) >> 3 );

			// write pan vectors into the decoded picture structure
			if ( ( pVideo->fieldMode == 0 ) || ( pVideo->fieldMode == 2 ) )	// frame picture or
																// first field
			{
				pVideo->pDecodedPict->pan_hor_offset[0] = pVideo->latestPanHor;
				pVideo->pDecodedPict->pan_vert_offset[0] = pVideo->latestPanVer;
			}
			else
			{						   // the offset of second field of
									   // a field picture is stored
									   // // on the second offset
									   // position of the same variable
				pVideo->pDecodedPict->pan_hor_offset[1] = pVideo->latestPanHor;
				pVideo->pDecodedPict->pan_vert_offset[1] = pVideo->latestPanVer;
			}

			// marker bit 00 0 oxoo

			if ( pVideo->StreamInfo.progSeq )	   // a progressive sequence is
									   // always displayed with the
										 // same pan and scan offset
			{
				pVideo->pDecodedPict->pan_hor_offset[1] = pVideo->latestPanHor;
				pVideo->pDecodedPict->pan_vert_offset[1] = pVideo->latestPanVer;
				pVideo->pDecodedPict->pan_hor_offset[2] = pVideo->latestPanHor;
				pVideo->pDecodedPict->pan_vert_offset[2] = pVideo->latestPanVer;
				if ( pVideo->hdrFirstWord & 0x3 ) {
					if ( !pVideo->errCode )
						pVideo->errCode = PICT_HEAD;
					SetErrorCode(ERR_PICTURE_HEADER);
				}
				VideoNextStartCode (0);
			}


			else if ( !pVideo->StreamInfo.progSeq && ( pVideo->pDecodedPict->pict_struc == 3 ) )
				// Frame picture, not progressive sequence: 2 or 3 pan
				// offsets
			{
				// extract second pan and scan offset

				/*
				 * pan_horizontal_offset_integer is 12 bits: 00 0ooxx +
				 * XX xxoo0
				 */
				pVideo->latestPanHor = ( pVideo->hdrFirstWord & 0x3 ) << 14;
				ReadHeaderDataFifo ();
				pVideo->latestPanHor = pVideo->latestPanHor | ( ( pVideo->hdrFirstWord & 0xFFC0 ) >> 2 );
				// pan_horizontal_offset has been multiplied by 16
				/*
				 * pan_horizontal_offset_sub_pixel is 4 bits: 00 ooxx
				 * xxoo
				 */
				/* that are concatenated with the integer part */
				pVideo->latestPanHor = pVideo->latestPanHor | ( ( pVideo->hdrFirstWord & 0x3C ) >> 2 );
				pVideo->pDecodedPict->pan_hor_offset[1] = pVideo->latestPanHor;

				// marker bit 00 0 ooxo

				/*
				 * pan_vertical_offset_integer is 12 bits: 00 0ooox +
				 * XX xxxo0
				 */
				pVideo->latestPanVer = ( pVideo->hdrFirstWord & 0x1 ) << 15;
				ReadHeaderDataFifo ();
				/*
				 * pan_vertical_offset_sub_pixel is 4 bits: 00 ooox
				 * xxxo
				 */
				// concatenated with the integer part
				pVideo->latestPanVer = pVideo->latestPanVer | ( ( pVideo->hdrFirstWord & 0xFFFE ) >> 1 );
				pVideo->pDecodedPict->pan_vert_offset[1] = pVideo->latestPanVer;

				// marker bit 00 0 ooox

				if ( pVideo->pDecodedPict->nb_display_field != 3 )
					VideoNextStartCode (0);
				else
				{					   // 3 pan & scan offsets
					/* pan_horizontal_offset_integer is 12 bits: XX X0 */
					/* pan_horizontal_offset_sub_pixel is 4 bits: 00 0X */
					/* they are concatenated in a single word */
					ReadHeaderDataFifo ();
					pVideo->latestPanHor = pVideo->hdrFirstWord;
					pVideo->pDecodedPict->pan_hor_offset[2] = pVideo->latestPanHor;
					ReadHeaderDataFifo ();

					// marker bit xooo0 00

					/*
					 * pan_vertical_offset_integer is 12 bits: oxxx X X
					 * xooo
					 */
					/*
					 * pan_vertical_offset_sub_pixel is 4 bits: 00 0
					 * oxxx + xooo 0 00
					 */
					pVideo->latestPanVer = ( pVideo->hdrFirstWord & 0x7FFF ) << 1;
					ReadHeaderDataFifo ();
					pVideo->latestPanVer = ( pVideo->hdrFirstWord & 0x8000 ) >> 15;
					pVideo->pDecodedPict->pan_vert_offset[2] = pVideo->latestPanVer;

					// marker bit oxoo 0 00

					if ( pVideo->hdrFirstWord & 0x3FFF ) {
						if ( !pVideo->errCode )
							pVideo->errCode = PICT_HEAD;
						SetErrorCode(ERR_PICTURE_HEADER);
					}
					VideoNextStartCode (1);

				}
			}
			break;



			/******* picture scalable extension *******/
		case PICT_SCAL:
			pVideo->hdrFirstWord = 0x0100;		   // not supported: just leave the
										 // test
			break;


			/******* other extension start codes *******/
		default:
			if ( !pVideo->errCode )
				pVideo->errCode = BAD_EXT;	   // extension start code not at the good location !!
			SetErrorCode(ERR_BAD_EXTENSION_SC);
			break;
	}								   // end of switch
}



//----------------------------------------------------------------------------
// USER HEADER routine
//----------------------------------------------------------------------------
/*    this routine just bypasses all the bytes of the user header  */
/*    and is exit with the next start code value into pVideo->hdrFirstWord XX00 */
static void NEARAPI VideoUser(void)
{
	DWORD toto;
	WORD i;

	toto = pVideo->hdrFirstWord << 16;
	ReadHeaderDataFifo ();
	toto = toto | pVideo->hdrFirstWord;
	while ( ( ( toto & 0x00FFFFFFL ) != 0x00000001L ) &&
			( ( toto & 0xFFFFFF00L ) != 0x00000100L ) )
	{
		toto = toto << 16;
		ReadHeaderDataFifo ();
		toto = toto | pVideo->hdrFirstWord;
	}
	if ( ( toto & 0x00FFFFFFL ) == 0x00000001L )
		ReadHeaderDataFifo ();
	else
	{								   // pVideo->hdrFirstWord == 01XX
		if ( !pVideo->hdrPos )	// there is nothing into  pVideo->hdrNextWord
		{
			pVideo->hdrPos = 8;
			pVideo->hdrNextWord = ( pVideo->hdrFirstWord & 0xFF ) << 8;
			ReadHeaderDataFifo ();
		}
		else
		{							   // pVideo->hdrPos = 8: the next
									   // byte is into pVideo->hdrNextWord
			pVideo->hdrFirstWord = ( pVideo->hdrFirstWord << 8 ) | ( pVideo->hdrNextWord >> 8 );
			pVideo->hdrPos = 0;
		}
	}
	i = BoardReadVideo ( ITS ) << 8;   // allows to clear the Header
									   // hit bit
	i = ( i | BoardReadVideo ( ITS + 1 ) ) & 0xFFFE;	// allows to clear the
														// Header hit bit
	pVideo->intStatus = ( pVideo->intStatus | i ) & pVideo->intMask;
}

//----------------------------------------------------------------------------
// Set next reconstructed,forward and backward frame pointer
//----------------------------------------------------------------------------
static void NEARAPI VideoSetRecons(void)
{
	/************************  I or P pictures ****************************/
	if ( pVideo->pDecodedPict->pict_type != 0x3 )
	{
		if ( pVideo->frameStoreAttr == FORWARD_PRED )   /* pVideo->frameStoreAttr is the prediction
									    * attribute of BUFF_A */
		{
			if ( pVideo->fieldMode < 2 )
				pVideo->frameStoreAttr = BACKWARD_PRED;
			/* Change the prediction attribute */

			if ( ( pVideo->fieldMode == 0 ) || ( pVideo->fieldMode == 2 ) )
				// frame picture or first field of 2 field pictures
				VideoStoreRFBBuf (pVideo->BufferA, pVideo->BufferB, pVideo->BufferB );
			// rfp = A, ffp = bfp = B
			else					   // second field of 2 field
										 // pictures
				VideoStoreRFBBuf (pVideo->BufferA, pVideo->BufferB, pVideo->BufferA );
			// rfp = A, ffp = B, bfp = A
		}
		else
		{
			if ( pVideo->fieldMode < 2 )	   // frame picture or 2 field
				pVideo->frameStoreAttr = FORWARD_PRED;/* Change the prediction */

			if ( ( pVideo->fieldMode == 0 ) || ( pVideo->fieldMode == 2 ) )
				// frame picture or first field of 2 field pictures
				VideoStoreRFBBuf (pVideo->BufferB, pVideo->BufferA, pVideo->BufferA );
			// rfp = B, ffp = bfp = A
			else					   // seond field of 2 field
									   // pictures
				VideoStoreRFBBuf (pVideo->BufferB, pVideo->BufferA, pVideo->BufferB );
			// rfp = B, ffp = A, bfp = B
		}
	}

	/************************  B pictures ****************************/
	else
	{								   /* B picture */
		if ( pVideo->frameStoreAttr == FORWARD_PRED )
			VideoStoreRFBBuf (pVideo->BufferC, pVideo->BufferA, pVideo->BufferB );
		else
			VideoStoreRFBBuf ( pVideo->BufferC, pVideo->BufferB, pVideo->BufferA );
	}


	/*********** common for all kind of pictures  *********************/
	/* test if displayed frame = reconstructed frame */
	if ( ( pVideo->pCurrDisplay->buffer == pVideo->pDecodedPict->buffer ) && ( pVideo->currPictCount >= 4 ) && !pVideo->fieldMode )
		pVideo->NextInstr.Ovw = 1;/* overwrite mode */
	else
		pVideo->NextInstr.Ovw = 0;/* not overwite mode */
}


//----------------------------------------------------------------------------
// Store reconstructed,forward and backward frame pointers  	                 */
//----------------------------------------------------------------------------
static void NEARAPI VideoStoreRFBBuf (WORD rfp, WORD ffp, WORD bfp )
{
	BoardWriteVideo ( RFP, (BYTE)((rfp >> 8 )));
	/* Address where to decode the next frame */
	BoardWriteVideo ( RFP + 1, (BYTE)((rfp & 0xFF )));
	pVideo->pDecodedPict->buffer = rfp;
	BoardWriteVideo ( FFP,(BYTE)(( ffp >> 8 )));
	/* Used by P picture */
	BoardWriteVideo ( FFP + 1, (BYTE)((ffp & 0xFF )));
	BoardWriteVideo ( BFP, (BYTE)((bfp >> 8 )));
	/* Used by P picture in case of dual prime */
	BoardWriteVideo ( BFP + 1, (BYTE)(bfp&0xFF));
}

//----------------------------------------------------------------------------
// Routine called on each VSYNC occurence
//----------------------------------------------------------------------------
static void NEARAPI VideoVsyncRout(void)
{
	WORD        i;
	pVideo->VsyncInterrupt = TRUE;
	if ( pVideo->VideoState == StateStartup )
	{
		if ((VideoGetBBL()) > 2)
		{
			pVideo->NextInstr.Exe = 1;
			pVideo->NextInstr.Seq = 1;
			VideoStoreINS();  // Stores Instruction content
			pVideo->VideoState = StateWaitForDTS;
			pVideo->ActiveState = StateWaitForDTS;
		}
		return;
	}

	if ( pVideo->VideoState == StatePause )
		return;

	if ( ( !pVideo->needDataInBuff ) && ( pVideo->vbvReached == 1 ) )
	{
		pVideo->VsyncNumber++;
		if ( pVideo->VsyncNumber > 4 * ( pVideo->decSlowDown + 1 ) )
		{
			VideoPipeReset ();
			// reset_3500();
			pVideo->VsyncNumber = 0;
		}
		BoardWriteVideo ( DCF, 0 );
		BoardWriteVideo ( DCF + 1, (BYTE)(pVideo->currDCF ));
		/*****  bit buffer level is high enough to continue normal decoding and display  ****/
		/*****  count of the number of time the current picture must be displayed        ****/
		if ( pVideo->pictDispIndex != pVideo->pCurrDisplay->nb_display_field )
			pVideo->pictDispIndex++;
		if ( pVideo->pictDispIndex >= pVideo->pCurrDisplay->nb_display_field - 1 )
		{
			// this is the time where the next INS should be stored
			// into the chip
			// We verify if the VSYNC phase (cur_field) is the same
			// than the first field
			// of the next picture to be displayed: if this is VSYNC #
			// n, the next
			// decoding will start on VSYNC # n+1 (opposite phase)
			// while the next frame
			// display will start on VSYNC # n+2 (same phase)
/************* Youss R/2P buffer saving ***************************/
// If First Vsync after vbv is reached is of incorrect polarity,
// Program internal field inversion AND force first field to current
// field
// FistVsyncAfterVbv is a 3 state variable
// before vbv is reached           FistVsyncAfterVbv = NOT_YET_VBV
// between vbv and following vsync FistVsyncAfterVbv = NOT_YET_VST
// after vsync following vbv       FistVsyncAfterVbv = PAST_VBV_AND_VST
 if (pVideo->FistVsyncAfterVbv == NOT_YET_VST)
		{
		if ( pVideo->pNextDisplay->first_field != pVideo->currField )
			{
			pVideo->currField = pVideo->pNextDisplay->first_field;
			BoardWriteVideo(VID_LSRh, 2);// field invertion mechanism.
			pVideo->InvertedField = TRUE;

		 }
		pVideo->FistVsyncAfterVbv = PAST_VBV_AND_VST;
		}
			if ( pVideo->pNextDisplay->first_field != pVideo->currField )
			{						   // this is the opposite phase
				VideoWaitDec ();		   // put decoder in wait mode
				pVideo->pictDispIndex--;		   // we must wait one field for
										 // the good phase
			}
			else
			{						   // this is the good phase for
									   // storage
				// store the next instruction that will be taken into
				// account on the next BOT VSYNC
				VideoStoreINS ();
				if ( pVideo->VideoState == StateStep )	/* store only one
														 * instrcution in step
														 * mode */
					pVideo->VideoState = StatePause;
			}
		}

		// the current frame pointer has not been displayed enough
		// times
		// to start the decoding of the next frame
		else						   // pVideo->pictDispIndex <
			{						   // pVideo->pCurrDisplay->nb_display_fi
									   // eld - 1
			VideoWaitDec ();			   // put decoder in Wait mode
			}


		/* pan & scan vector has to be updated on each new VSYNC */
		VideoSetPSV ();				   // store PSV for next field and
									   // LSO for current one
	}								   // end of if(!empty)


	else
		/***  bit buffer level was not high enough to continue normal decoding *****/
		/***  decoder has been stopped during PSD interrupt. It will be re-enabled */
		/***  on the good VSYNC if the bit buffer level is high enough.         ****/
		/***  Polarity of the VSYNC on which the decoder was stopped is into empty */
	if ( pVideo->needDataInBuff == (WORD)(pVideo->currField))
	{
		/* This is the good VSYNC phase to restart decoding       */
		/* verification of the bit buffer level before restarting */
		/* the decoder has been stopped for at least two VSYNC    */
		i = VideoGetBBL();
		if ( i >= pVideo->vbvDelay )
		{							   
			// BBL is high enough to restart
			// "enable decoding" bit
			VideoEnableDecoding(ON);
			pVideo->needDataInBuff = 0;
		}
	}
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
static void NEARAPI VideoChooseField(void)
{
	BYTE dcf0, dcf1, bfs=0;
	
	// to avoid flicker with slow motion or step by step, the top field is displayed
	// half of the time of the picture, and then the bottom field is displayed
	if ( ( pVideo->decSlowDown ) || ( pVideo->VideoState == StatePause )||(pVideo->perFrame == TRUE ))
	{
		bfs = BoardReadVideo(CFG_BFS)&0x3F;// To check if B frame optimization is on
		dcf0 = BoardReadVideo ( DCF );
		dcf1 = BoardReadVideo ( DCF + 1 );
		if ( pVideo->HalfRes == FALSE )	/* full resolution
													 * picture = 2 fields */
		{                                   
			dcf1 |= 0x80;
			if ( ( ( ( ( pVideo->pictDispIndex + pVideo->decSlowDown ) > 0x7fff ) || ( pVideo->pictDispIndex == 1 ) ) && ( pVideo->VideoState != StatePause ) )
				 || ( ( pVideo->VideoState == StatePause ) && ( !pVideo->displaySecondField ) ) )
			{
				/* display first field in two cases */
				/* - first half of the pVideo->decSlowDownrisation time */
				/* - first step() pVideo->currCommand */
				if ( pVideo->pCurrDisplay->first_field == TOP )
				{					   /* first field = TOP field */
					if(!bfs)
							BoardWriteVideo ( DCF, 0x4 );//FRZ set for STi3520A
					else
							BoardWriteVideo ( DCF, 0x15 );//FRZ set for STi3520A
					BoardWriteVideo ( DCF + 1, dcf1);
				}
				else
				{					   /* first field = BOT field */
					if(!bfs)
							BoardWriteVideo ( DCF, 0x5 );
					else
							BoardWriteVideo ( DCF, 0x14 );//FRZ set for STi3520A
					BoardWriteVideo ( DCF + 1, dcf1);
				}
			}
			else
			{
				/* display second field in two cases */
				/* - second half of the pVideo->decSlowDownrisation time */
				/* - second step() pVideo->currCommand */
				if ( pVideo->pCurrDisplay->first_field == TOP )
				{
					if(!bfs)
							BoardWriteVideo ( DCF, 0x5);
					else
							BoardWriteVideo ( DCF, 0x15 );//FRZ set for STi3520A
					BoardWriteVideo ( DCF + 1, dcf1);
				}
				else
				{
					if(!bfs)
							BoardWriteVideo ( DCF, 0x4);
					else
							BoardWriteVideo ( DCF, 0x14 );//FRZ set for STi3520A
					BoardWriteVideo ( DCF + 1, dcf1);
				}
			}
		}
	}
}


static BOOL NEARAPI IsChipSTi3520(void)
{
	//---- Write STi3520 DCF register to 0
	BoardWriteVideo(0x78, 0);
	BoardWriteVideo(0x79, 0);

	//---- Read back DCF MSByte
	if (BoardReadVideo(0x78) != 0)
		return FALSE; // we have red STi3520A VID_REV register
	else
		return TRUE;  // we have red STi3520 DCF register
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
WORD FARAPI SendAudioIfPossible(LPBYTE pBuffer, WORD Size)
{
	if ( AudioIsEnoughPlace(Size)) {
		BoardSendAudio(pBuffer, Size);
		return Size;
	}
	return 0;
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
WORD FARAPI SendAudioToVideoIfPossible(LPBYTE Buffer, WORD Size)
{
	if ( AudioIsEnoughPlace(Size)) {
                        BoardSendVideo((WORD  *)Buffer, Size);// Here in case of system stream
																			// We send audio through Video Strabe
		return Size;
	}
	return 0;
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
static void NEARAPI VideoSetABStart(WORD abg)
{
	BoardWriteVideo ( AUD_ABG, (BYTE)(abg >> 8));// Initiate Write to Command
	BoardWriteVideo ( AUD_ABG + 1,(BYTE)(abg & 0xFF));
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
WORD FARAPI VideoGetABL(void)  
{
	WORD	i;

	HostDisableIT();
	i = (WORD)( BoardReadVideo ( AUD_ABL ) & 0x3F ) << 8;
	i = i | (WORD)( BoardReadVideo ( AUD_ABL + 1 ) );
	HostEnableIT();
	return ( i );
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
static void NEARAPI VideoSetABStop(WORD abs)
{
	BoardWriteVideo ( AUD_ABS, (BYTE)(abs >> 8 ));// Initiate Write to Command
	BoardWriteVideo ( AUD_ABS + 1,(BYTE)(abs & 0xFF));
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
static void NEARAPI VideoSetABThresh(WORD abt) 
{
	BoardWriteVideo ( AUD_ABT, (BYTE)(abt >> 8));// Initiate Write to Command
	BoardWriteVideo ( AUD_ABT + 1,(BYTE)(abt & 0xFF));
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
WORD FARAPI SendVideoIfPossible(LPBYTE Buffer, WORD Size)
{
	if (VideoIsEnoughPlace(Size)) {
                BoardSendVideo((WORD  *)Buffer, Size);
		return Size;
	}

	return 0;
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
static void NEARAPI VideoSetBBStart(WORD bbg)
{
	pVideo = pVideo;
	BoardWriteVideo ( VID_VBG, (BYTE)(bbg >> 8));// Initiate Write to Command
	BoardWriteVideo ( VID_VBG + 1,(BYTE)(bbg & 0xFF));
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
static WORD  NEARAPI VideoGetBBL(void)
{
	WORD		i;

	HostDisableIT();
	i = (WORD)( BoardReadVideo ( BBL ) & 0x3F ) << 8;
	i = i | (WORD)( BoardReadVideo ( BBL + 1 ) );
	HostEnableIT();
	return ( i );
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
static void NEARAPI VideoSetBBStop(WORD bbs)
{
	BoardWriteVideo ( BBS, (BYTE)(bbs >> 8));// Initiate Write to Command
	BoardWriteVideo ( BBS + 1,(BYTE)(bbs & 0xFF));
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
static void NEARAPI VideoSetBBThresh(WORD bbt)
{
	BoardWriteVideo ( BBT, (BYTE)(bbt >> 8));// Initiate Write to Command
	BoardWriteVideo ( BBT + 1,(BYTE)(bbt & 0xFF));
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
static WORD  NEARAPI VideoBlockMove(DWORD SrcAddress, DWORD DestAddress, WORD Size)
{
	WORD counter;
	// set block move Size
	BoardWriteVideo ( BMS    , (BYTE)((Size >> 8) & 0xFF));
	BoardWriteVideo ( BMS 	,  (BYTE)(Size & 0xFF));
	VideoSetMWP(DestAddress);
	VideoSetMRP(SrcAddress);            // Launches Block Move
	counter = 0;
	while ( ! VideoBlockMoveIdle()  )
		{
		counter ++;
		if(counter == 0xFFFF)
				return ( BAD_MEM_V );
		}
	// wait for the end of the block move
	return ( NO_ERROR );
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
static void NEARAPI VideoStartBlockMove(DWORD SrcAddress, DWORD DestAddress, DWORD Size)
{
	SrcAddress = SrcAddress;
	DestAddress = DestAddress;
	Size = Size;
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
static void NEARAPI VideoCommandSkip(WORD Nbpicture)
{
	if(Nbpicture > 2)
	{
		pVideo->errCode = ERR_SKIP;
	}
	else
	{
	}
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
static void NEARAPI VideoSetSRC(WORD SrceSize, WORD DestSize)
{
	DWORD lsr;
		lsr = ( 256 * ( long ) ( SrceSize - 4 ) ) / (DestSize - 1);
		BoardWriteVideo ( LSO, 0 );   // programmation of the SRC
		BoardWriteVideo ( LSR, (BYTE)lsr );
		if(lsr > 255 )
			{
			 BoardWriteVideo ( VID_LSRh, 1);
			}
		BoardWriteVideo ( CSO, 0 );
		VideoSRCOn ();
}

//----------------------------------------------------------------------------
// Load Quantization Matrix
//----------------------------------------------------------------------------
static void NEARAPI VideoLoadQuantTables(BOOL Intra,BYTE  * Table )
{
	WORD i; // loop counter
	// Select Intra / Non Intra Table
	if(Intra)
		BoardWriteVideo(VID_HDS,QMI);
	else
		BoardWriteVideo(VID_HDS,(0&~QMI));
	// Load Table
	for (i = 0 ; i < QUANT_TAB_SIZE ; i++)
		BoardWriteVideo(VID_QMW,Table[i]);
	// Lock Table Again
	BoardWriteVideo(VID_HDS,0);
}

//----------------------------------------------------------------------------
//  Computes Instruction and stores in Ins1 Ins2 Cmd vars
//----------------------------------------------------------------------------
static void NEARAPI VideoComputeInst(void)
{
	INSTRUCTION  Ins = pVideo->NextInstr;// Local var.
	pVideo->Ppr1 = (Ins.Pct<< 4)|(Ins.Dcp<< 2)|(Ins.Pst );
	pVideo->Ppr2 = (Ins.Tff<< 5)|(Ins.Frm<<4)|(Ins.Cmv<< 3)|(Ins.Qst<< 2)|
				 (Ins.Ivf<< 1)|(Ins.Azz   );
	pVideo->Tis  = (Ins.Mp2<< 6)|(Ins.Skip<< 4)|(Ins.Ovw<< 3)|(Ins.Rpt<< 1)|
				 (Ins.Exe    );
	pVideo->Pfh  = (Ins.Bfh<< 4)|(Ins.Ffh    );
	pVideo->Pfv  = (Ins.Bfv<< 4)|(Ins.Ffv    );
}

//----------------------------------------------------------------------------
// put the decoder into WAIT mode
//----------------------------------------------------------------------------
/* This routine actually clears all bits of INS1/TIS registers

	This is not a problem since the whole registers HAVE to
	be rewritten when storing a new instruction.                 */
static void NEARAPI VideoWaitDec (void)
{
	BoardWriteVideo ( VID_TIS, 0 );
	VideoChooseField();// If Step by step decoding, set freeze bit

}


//----------------------------------------------------------------------------
// Routine storing pVideo->nextInstr1 and 2 into the instruction registers
//----------------------------------------------------------------------------
static void NEARAPI VideoStoreINS (void)
{
	VideoComputeInst() ;
	BoardWriteVideo ( VID_TIS ,  pVideo->Tis  );
	BoardWriteVideo ( VID_PPR1,  pVideo->Ppr1 );
	BoardWriteVideo ( VID_PPR2,  pVideo->Ppr2 );
	BoardWriteVideo ( VID_PFV ,  pVideo->Pfv  );
	BoardWriteVideo ( VID_PFH ,  pVideo->Pfh  );
}

//----------------------------------------------------------------------------
//  Routine reading the number of bytes loaded in the CD_FIFO
//----------------------------------------------------------------------------
static DWORD NEARAPI ReadCDCount (void)
{
	DWORD cd;
	HostDisableIT();

	cd  = ((DWORD)(BoardReadVideo(CDcount)&0xFF))<<16;
	cd |= ((DWORD)(BoardReadVideo(CDcount)&0xFF))<<8;
	cd |=  (DWORD)(BoardReadVideo(CDcount)&0xFF);

	HostEnableIT(  );
	return ( cd );
}

//----------------------------------------------------------------------------
//  Routine reading the number of bytes extracted by the SCD
//----------------------------------------------------------------------------
static DWORD NEARAPI ReadSCDCount (void)
{
	DWORD Scd;
	HostDisableIT (  );

	Scd  = ((DWORD)(BoardReadVideo(SCDcount)&0xFF))<<16;
	Scd |= ((DWORD)(BoardReadVideo(SCDcount)&0xFF))<<8;
	Scd |=  (DWORD)(BoardReadVideo(SCDcount)&0xFF);

	HostEnableIT (  );
	return ( Scd );
}

//----------------------------------------------------------------------------
// DRAM I/O
//----------------------------------------------------------------------------
static void NEARAPI VideoSetMWP(DWORD mwp)
{
	BYTE m0, m1, m2;
	m0 = (BYTE)( (mwp >> 14) & 0xFF );
	m1 = (BYTE)( (mwp >>  6) & 0xFF );
	m2 = (BYTE)( (mwp <<  2) & 0xFF );
	BoardWriteVideo(MWP  , m0);
	BoardWriteVideo(MWP  , m1);
	BoardWriteVideo(MWP  , m2);
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
static void NEARAPI VideoSetMRP(DWORD mrp)
{
	BYTE m0, m1, m2;
	m0 = (BYTE)( (mrp >> 14) & 0xFF );
	m1 = (BYTE)( (mrp >>  6) & 0xFF );
	m2 = (BYTE)( (mrp <<  2) & 0xFF );
	BoardWriteVideo(MRP  , m0);
	BoardWriteVideo(MRP  , m1);
	BoardWriteVideo(MRP  , m2);
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
static BOOL NEARAPI VideoMemWriteFifoEmpty( void )
{
		return ( (BoardReadVideo ( STA ) & 0x4) );
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
static BOOL NEARAPI VideoMemReadFifoFull( void )
{
		return ( (BoardReadVideo ( STA ) & 0x8) );
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
static BOOL NEARAPI VideoHeaderFifoEmpty( void )
{
	BoardReadVideo ( STA );
		return ( (BoardReadVideo ( STA + 1 ) & 0x4) );
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
static BOOL NEARAPI VideoBlockMoveIdle( void )
{
		return ( (BoardReadVideo ( STA  ) & 0x20) );
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
static void NEARAPI VideoEnableDecoding(BOOL OnOff)
{
	if(OnOff)
		pVideo->Ctl |= EDC;
	else
		pVideo->Ctl &= ~EDC;
	BoardWriteVideo(CTL ,  (BYTE)(pVideo->Ctl & 0xFF));
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
static void NEARAPI VideoEnableErrConc(BOOL OnOff)
{
	if(OnOff)
		pVideo->Ctl = (pVideo->Ctl |EPR|ERS|ERU)&~DEC;
	else
		pVideo->Ctl = (pVideo->Ctl&~EPR&~ERS&~ERU)|DEC;
	BoardWriteVideo(CTL , (BYTE)(pVideo->Ctl & 0xFF ));
}

//----------------------------------------------------------------------------
// pipeline RESET
//----------------------------------------------------------------------------
static void NEARAPI VideoPipeReset (void)
{
	pVideo->Ctl |= PRS;
	BoardWriteVideo(CTL ,  (BYTE)(pVideo->Ctl));
	Delay(1000);
	pVideo->Ctl &= ~PRS;
	BoardWriteVideo(CTL ,  (BYTE)(pVideo->Ctl));
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
static void NEARAPI VideoSoftReset (void)
{
	pVideo->Ctl |= SRS;
	BoardWriteVideo(CTL ,  (BYTE)(pVideo->Ctl));
	Delay(1000);
	pVideo->Ctl &= ~SRS;
	BoardWriteVideo(CTL ,  (BYTE)(pVideo->Ctl));
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
static void NEARAPI VideoEnableInterfaces (BOOL OnOff )
{
	if(OnOff)
		pVideo->Ccf = pVideo->Ccf |EVI|EDI|ECK|EC2|EC3;
	else
		pVideo->Ccf = pVideo->Ccf&~EVI&~EDI&~ECK&~EC2&~EC3;
	BoardWriteVideo(CFG_CCF, (BYTE)(pVideo->Ccf));
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
static void NEARAPI VideoPreventOvf(BOOL OnOff )
{
	if(OnOff)
		pVideo->Ccf = pVideo->Ccf |PBO;
	else
		pVideo->Ccf = pVideo->Ccf&~PBO;
	BoardWriteVideo(CFG_CCF,(BYTE)(pVideo->Ccf));
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
static void NEARAPI VideoSetFullRes(void)
{
	pVideo->HalfRes = FALSE;
	pVideo->currDCF = pVideo->currDCF | pVideo->fullVerFilter;
	BoardWriteVideo ( DCF, 0 );
	BoardWriteVideo ( DCF + 1,  (BYTE)(pVideo->currDCF));
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
static void NEARAPI VideoSetHalfRes(void)
{
	pVideo->HalfRes = TRUE;
// No PAL optimization in Half Res
	BoardWriteVideo(CFG_BFS ,  0);
	pVideo->currDCF = pVideo->currDCF | pVideo->halfVerFilter;
	BoardWriteVideo ( DCF, 0 );
	BoardWriteVideo ( DCF + 1, (BYTE)(pVideo->currDCF));
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
static void NEARAPI VideoSelect8M(BOOL OnOff)
{
	if(OnOff)
		pVideo->Ccf = pVideo->Ccf |M32;
	else
		pVideo->Ccf = pVideo->Ccf&~M32;
	BoardWriteVideo(CFG_CCF, (BYTE)(pVideo->Ccf));
}

//----------------------------------------------------------------------------
// GCF1 register Routines
//----------------------------------------------------------------------------
static void NEARAPI VideoSetDramRefresh(WORD Refresh)
{
	pVideo->Gcf = pVideo->Gcf |(Refresh & RFI);
	BoardWriteVideo(CFG_MCF, (BYTE)(pVideo->Gcf));
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
static void NEARAPI VideoSelect20M(BOOL OnOff)
{
	if(OnOff)
		pVideo->Gcf = pVideo->Gcf | M20;
	else
		pVideo->Gcf = pVideo->Gcf &~M20;

	BoardWriteVideo(CFG_MCF, (BYTE)(pVideo->Gcf));
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
static void NEARAPI VideoSetDFA(WORD dfa)
{
	BoardWriteVideo(VID_DFA , (BYTE)(dfa>>8));
	BoardWriteVideo(VID_DFA , (BYTE)(dfa));
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
static void NEARAPI VideoEnableDisplay(void)
{
	pVideo->currDCF = pVideo->currDCF |0x20;
	BoardWriteVideo ( DCF, 0 );
	BoardWriteVideo ( DCF + 1, (BYTE)(pVideo->currDCF));

}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
static void NEARAPI VideoDisableDisplay(void)
{
	pVideo->currDCF = pVideo->currDCF &(~0x20);
	BoardWriteVideo ( DCF, 0 );
	BoardWriteVideo ( DCF + 1, (BYTE)(pVideo->currDCF));

}
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
void FARAPI VideoInitPesParser(STREAMTYPE StreamType )
{
	switch(StreamType)
	{
		case SYSTEM_STREAM:
		case VIDEO_PACKET:
		case AUDIO_PACKET:
		case VIDEO_PES:
		case AUDIO_PES:
                         BoardWriteVideo( PES_VID, 0x30);
			 BoardWriteVideo( PES_AUD, 0x0);
		break;
		case DUAL_PES:
			 BoardWriteVideo( PES_VID, 0xB0 );
			 BoardWriteVideo( PES_AUD, 0X0 );
		break;
		case DUAL_ES:
		case VIDEO_STREAM:
		case AUDIO_STREAM:
			 BoardWriteVideo( PES_VID, 0 );
			 BoardWriteVideo( PES_AUD, 0 );
		break;
	}
}
//----------------------------------------------------------------------------
// reads  PTS value from STi3520A
//----------------------------------------------------------------------------
DWORD FARAPI BoardReadVideoPTS(void)
{
	DWORD  pts;
	pts =       ( (DWORD)BoardReadVideo(PES_TS4 ) & 0xFFL ) << 24;
	pts = pts | ( (DWORD)( BoardReadVideo(PES_TS3 ) & 0xFFL ) << 16);
	pts = pts | ( (DWORD)( BoardReadVideo(PES_TS2 ) & 0xFFL ) << 8);
	pts = pts | ( (DWORD)	BoardReadVideo(PES_TS1 ) & 0xFFL );
	return pts;
}
//----------------------------------------------------------------------------
// Returns TRUE if current PTS is Valid
//----------------------------------------------------------------------------
BOOL FARAPI VideoIsValidPTS(void)
{
	if( BoardReadVideo(PES_TS5 ) & 0x2 ) // read TSA bit
		return TRUE;
}                             

WORD FARAPI VideoTestReg(void)
{
	BoardWriteVideo(MWP , 0x05);
	BoardWriteVideo(MWP , 0x55);
	BoardWriteVideo(MWP , 0xAA);
	if ((BoardReadVideo(MWP) & 0x1F)  != 0x05)
		goto Error;
	if (BoardReadVideo(MWP)  != 0x55)
		goto Error;
	if ((BoardReadVideo(MWP) & 0xFC) != 0xA8)
		goto Error;

	return NO_ERROR;

Error :
        DPF((Trace,"VideoTestReg failed !!"));
	SetErrorCode(ERR_VIDEO_REG_TEST_FAILED);
	return BAD_REG_V;
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
WORD FARAPI VideoTestMemPat(WORD pattern, WORD pattern1)
{
	// Configure memory refresh = 36  
	#define MAXMEM 0x7FF
	WORD i, j;
	WORD counter;

	VideoSetMWP(0L);
	counter = 0;
	for (i = 0; i < MAXMEM; i++) {
		for (j = 0; j < 16; j++)
		{
			while (!(BoardReadVideo ( STA ) & 0x4)) {
			counter ++;
			if (counter == 0xFF0)
				goto Error;
                        DPF((Trace,"Waiting Write Fifo Empty"));
			}

			BoardWriteVideo(MWF, 0);
		}
	}

	VideoSetMWP(0L);
	counter = 0;
	for (i = 0; i < MAXMEM; i++) {
			for(j = 0; j < 8; j++ )
			{
			while (!(BoardReadVideo ( STA ) & 0x4)) {
				counter ++;
				if (counter == 0xFF0)
					goto Error;
                                DPF((Trace,"Waiting Write Fifo Empty"));
			}
			BoardWriteVideo(MWF, (BYTE)pattern);
	}
	counter =  0;

		for(j = 0; j < 8; j++ ){
			while (!VideoMemWriteFifoEmpty())	{		// ACCESS TO MEM FIFO IS SLOWER !!!
                                DPF((Trace,"Waiting Write Fifo Empty"));
				counter ++;
				if (counter == 0xFF0)
					goto Error;
			}
			BoardWriteVideo(MWF, (BYTE)pattern1);
		}
	}

	VideoSetMRP(0L);
	counter = 0;
	// test Read Fifo Full
	for(i = 0; i < MAXMEM; i++) {
		for (j = 0; j < 8; j++)	{
			while (!VideoMemReadFifoFull())	{
                                DPF((Trace,"Waiting Read Fifo Full"));
				counter ++;
				if (counter == 0xFF0)
					goto Error;
			}

			counter = BoardReadVideo(MRF);
			if (counter !=pattern)	{
                                DPF((Trace,"Counter = %x, pattern = %x, j = %x", counter, pattern, j));
				goto Error;
			}
		}

		counter =  0;
		for (j = 0; j < 8; j++) {
			counter = BoardReadVideo(MRF);
			while (!VideoMemReadFifoFull())	{
                                DPF((Trace,"Waiting Read Fifo Full"));
				counter ++;
				if (counter == 0xFF0)
					goto Error;
			}

			
			if ((WORD)counter != pattern1) {
                                DPF((Trace,"Counter = %x, pattern = %x, j = %x", counter, pattern, j));
				goto Error;
			}
		}
	}
	return NO_ERROR;

Error :
        DPF((Trace,"VideoTestMemPat failed !!"));
	SetErrorCode(ERR_TEST_MEMORY_FAILED);
	return BAD_MEM_V;
}



//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
WORD FARAPI VideoTestMem(void)
{
//	if (VideoTestMemPat(0x55, 0xAA) == NO_ERROR)
//		return VideoTestMemPat(0xAA, 0x55);
//	else
//		return BAD_MEM_V;
	return NO_ERROR;
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
static void NEARAPI VideoInitVar(STREAMTYPE StreamType)
{
	Sequence =1;
	pVideo->currDCF = 0x40;					   /* one clock delay + force black
										* background */
	pVideo->LastCdCount = 0;
	pVideo->fullVerFilter = 0x0;
	pVideo->halfVerFilter = 0x4;
	pVideo->Xdo = pCard->OriginX;						   /* pre initialise XDO */
	pVideo->Ydo = pCard->OriginY;						   /* pre initialise YDO */
	pVideo->Xd1 = 0xFFFF;					   /* pre initialise end of video
										* window */
	pVideo->Yd1 = 0xFFFF;					   /* pre initialisa end of video
										* window */
	pVideo->fastForward = 0;						   /* accelerate if set */
	pVideo->decSlowDown = 0;
	pVideo->perFrame = FALSE;
	pVideo->LastPipeReset = 2;
	pVideo->errCode = 0;
	pVideo->StreamInfo.countGOP = 0;
	pVideo->StreamInfo.frameRate = 5;	 // just to avoid erroneous warning
	pVideo->useSRC = 0x0;				   // disable SRC
	pVideo->seqDispExt = 0;
	pVideo->skipMode = 0;
	pVideo->currCommand = 0;
	pVideo->needDataInBuff = 0;
	pVideo->currPictCount = 0;			/* first picture of the bit stream */
	pVideo->defaultTbl = 0;	/* To know if default tables are already into the chip */
	pVideo->GOPindex = 0;
	// initialisation of the picture structures
	pVideo->pictArray[0].tempRef = 1025;
	pVideo->pictArray[1].tempRef = 1023;
	pVideo->pictArray[2].tempRef = 1025;
	pVideo->pictArray[3].tempRef = 1025;
	pVideo->currTempRef = 1022;				   /* display pVideo->decSlowDownral reference */
	pVideo->pNextDisplay = &pVideo->pictArray[3];
	pVideo->pCurrDisplay = &pVideo->pictArray[3];	   // this is only for correct
										 // start up
	pVideo->pictArray[0].nb_display_field = 2;
	// 2 field display time for MPEG1
	pVideo->pictArray[1].nb_display_field = 2;
	pVideo->pictArray[2].nb_display_field = 2;
	pVideo->pictArray[3].nb_display_field = 2;
	pVideo->pictArray[0].first_field = TOP;	   // default for MPEG1 bit streams
	pVideo->pictArray[1].first_field = TOP;	   // top field first
	pVideo->pictArray[2].first_field = TOP;
	pVideo->pictArray[3].first_field = TOP;
	pVideo->fieldMode = 0;					   // indicates frame picture by
									   // default
	pVideo->frameStoreAttr = FORWARD_PRED;
	pVideo->vbvReached = 0;
	pVideo->notInitDone = 1;				   // timing generator,picture size
									   // initialised only once
	pVideo->intMask = 0x0;
	pVideo->Gcf = 0;	// GCF set to 0 by default
	pVideo->Ctl = A35;	// CTL set to 0 by default
	pVideo->InvertedField = FALSE;
	pVideo->FistVsyncAfterVbv = NOT_YET_VBV;
	pVideo->Ccf = 0;	// GCF set to 0 by default
	pVideo->NextInstr.Tff = 1 ;
	pVideo->NextInstr.Seq = 1 ;
	pVideo->NextInstr.Exe = 1 ;
}

static void NEARAPI VideoReset35XX(STREAMTYPE StreamType)
{
	WORD Abg, Abs, Vbg, Vbs;
	pVideo->AudioBufferSize = 0xFF;
	switch(StreamType)
	{
		case SYSTEM_STREAM:
		case AUDIO_PACKET:
		case VIDEO_PACKET:
			pVideo->VideoBufferSize = BUF_FULL/3 - pVideo->AudioBufferSize-1;
		break;

		default:
			pVideo->VideoBufferSize = BUF_FULL - pVideo->AudioBufferSize-1;
		break;
	}

	Vbg = 0;
	Vbs = Vbg + pVideo->VideoBufferSize;
	Abg = Vbs+1;
	Abs = Abg + pVideo->AudioBufferSize;
	pVideo->StreamInfo.modeMPEG2 = 0;

	pVideo->NextInstr = pVideo->ZeroInstr;// Clear Next Instruction
	VideoInitPLL();
	VideoWaitDec();		// put decoder in Wait mode

	VideoSetABStart( Abg);// Set Bit Buffer parameters before Soft Reset
	VideoSetABStop(Abs);
	VideoSetABThresh(pVideo->AudioBufferSize);

	VideoSetBBStart(Vbg);// Set Bit Buffer parameters before Soft Reset
	VideoSetBBStop(Vbs);
	VideoSetBBThresh(pVideo->VideoBufferSize);

	VideoEnableInterfaces(ON);
	VideoEnableErrConc(ON);
	VideoSoftReset();
	VideoEnableDecoding(ON  );
	VideoSetDramRefresh(36);    // Set DRAM refresh to 36 default DRAM ref period

	VideoDisableDisplay();
	VideoMaskInt();
	BoardReadVideo(ITS);		   /* to clear ITS */
	BoardReadVideo(ITS +1);
	BoardReadVideo(ITS1);
}

static void NEARAPI VideoSeek(STREAMTYPE StreamType)
{
	WORD Abg, Abs, Vbg, Vbs;
	pVideo->AudioBufferSize = 0xFF;
	switch(StreamType)
	{
		case SYSTEM_STREAM:
		case AUDIO_PACKET:
		case VIDEO_PACKET:
			pVideo->VideoBufferSize = BUF_FULL/3 - pVideo->AudioBufferSize-1;
		break;

		default:
			pVideo->VideoBufferSize = BUF_FULL - pVideo->AudioBufferSize-1;
		break;
	}

	Vbg = 0;
	Vbs = Vbg + pVideo->VideoBufferSize;
	Abg = Vbs+1;
	Abs = Abg + pVideo->AudioBufferSize;
	pVideo->StreamInfo.modeMPEG2 = 0;

	pVideo->NextInstr = pVideo->ZeroInstr;// Clear Next Instruction
//	VideoInitPLL();
	VideoWaitDec();		// put decoder in Wait mode

//	VideoSetABStart( Abg);// Set Bit Buffer parameters before Soft Reset
//	VideoSetABStop(Abs);
//	VideoSetABThresh(pVideo->AudioBufferSize);

//	VideoSetBBStart(Vbg);// Set Bit Buffer parameters before Soft Reset
//	VideoSetBBStop(Vbs);
//	VideoSetBBThresh(pVideo->VideoBufferSize);

	VideoEnableInterfaces(ON);
	VideoEnableErrConc(ON);
	VideoSoftReset();
	VideoEnableDecoding(ON  );
	VideoSetDramRefresh(36);    // Set DRAM refresh to 36 default DRAM ref period

//	VideoDisableDisplay();
	VideoMaskInt();
	BoardReadVideo(ITS);		   /* to clear ITS */
	BoardReadVideo(ITS +1);
	BoardReadVideo(ITS1);
}


//----------------------------------------------------------------------------
// PLL initialization
//----------------------------------------------------------------------------
static void NEARAPI VideoInitPLL(void)
{
	BoardWriteVideo(CKG_PLL, 0xD9);

	BoardWriteVideo(CKG_VID, 0x22);
	BoardWriteVideo(CKG_VID, 0x08);
	BoardWriteVideo(CKG_VID, 0x5f);
	BoardWriteVideo(CKG_VID, 0x0f);

	BoardWriteVideo(CKG_AUD, 0x2b);
	BoardWriteVideo(CKG_AUD, 0x02);
	BoardWriteVideo(CKG_AUD, 0x5f);
	BoardWriteVideo(CKG_AUD, 0x5f);

	BoardWriteVideo(CKG_CFG, 0x83);
}

#define SIZE_OF_PICT 540

//----------------------------------------------------------------------------
// Enable OSD
//----------------------------------------------------------------------------
static void NEARAPI VideoOsdOn(void)
{
	pVideo->currDCF = pVideo->currDCF | 0x10;
	HostDisableIT();
	BoardWriteVideo(DCF, 0);
	BoardWriteVideo(DCF + 1, (BYTE)pVideo->currDCF);
	HostEnableIT();
}

//----------------------------------------------------------------------------
// Disable OSD
//----------------------------------------------------------------------------
static void NEARAPI VideoOsdOff (void)
{
	pVideo->currDCF = pVideo->currDCF & 0xEF;
	HostDisableIT();
	BoardWriteVideo(DCF, 0);
	BoardWriteVideo(DCF + 1,(BYTE) pVideo->currDCF);
	HostEnableIT();
}

//----------------------------------------------------------------------------
// initialisation of the OSD pointers
//----------------------------------------------------------------------------

static void NEARAPI VideoInitOEP (DWORD point_oep)
{   
	BYTE x;
	// Bugy code!! generates compiler error
	// Needs tp be fixed - JBS
/*	
	x = (BYTE)(point_oep >> 13);
	BoardWriteVideo(VID_OBP,x);
	x = (BYTE)(point_oep >> 5);
	BoardWriteVideo(VID_OBP, x);
	x = (BYTE)(point_oep >> 13);
	BoardWriteVideo(VID_OTP, x);
	x = (BYTE)(point_oep >> 5);
	BoardWriteVideo(VID_OTP, x);
*/
}

//----------------------------------------------------------------------------
// Set video window position and size (top left=X0,Y0) (bottom right=X1,Y1)
//----------------------------------------------------------------------------
void FARAPI VideoSetVideoWindow (WORD a, WORD b, WORD c, WORD d )
{
	a=a|1;
	pVideo->Xdo = a;
	pVideo->Ydo = b;
	pVideo->Xd1 = c;
	pVideo->Yd1 = d;
	VideoInitXY ();
}

//----------------------------------------------------------------------------
//     Initialisation of the horizontal & vertical offsets
//----------------------------------------------------------------------------
void FARAPI VideoInitXY(void)
{
	WORD	yds, xds;

	// set vertical stop position
	if ( pVideo->StreamInfo.verSize <= 288 )			   // half res decoding
		yds = pVideo->StreamInfo.verSize + pVideo->Ydo - 129;
	/* number of lines + offset - 128 - 1 */
	else							   // full resolution decoding
		yds = ( pVideo->StreamInfo.verSize >> 1 ) + pVideo->Ydo - 129;
	/* number of lines + offset - 128 - 1 */
	if ( yds > pVideo->Yd1 )
		yds = pVideo->Yd1;

	// set horizontal stop position: we always display 720 pixels
	// XDS given by the relation: 2*XDO + 40 + 2*L = 2*XDS + 28
	// XDS = XDO + 726 with 720 displayed pixels.
	xds = pVideo->Xdo + 726;
	if ( xds > 800 )					   /* 800 = max number of pels allowed per line */
		xds = 800;
	if ( xds > pVideo->Xd1 )
		xds = pVideo->Xd1;				   /* not bigger than the video window */
	SetXY(xds, yds );
}

//----------------------------------------------------------------------------
// Storage of the horizontal & vertical offsets
//----------------------------------------------------------------------------
void FARAPI SetXY(WORD xds, WORD yds)
{
	BoardWriteVideo ( XDO   , (BYTE)(pVideo->Xdo >> 8 ));
	BoardWriteVideo ( XDO+1 , (BYTE)(pVideo->Xdo & 0xFF ));
	BoardWriteVideo ( YDO   , (BYTE)(pVideo->Ydo ));

	BoardWriteVideo ( XDS   , (BYTE)(xds >> 8 ));
	BoardWriteVideo ( XDS+1 , (BYTE)(xds & 0xFF ));
	BoardWriteVideo ( YDS   , (BYTE)yds );
}

//----------------------------------------------------------------------------
// Set next display frame pointer
//----------------------------------------------------------------------------
/*
	This routine determines which is the next frame pointer that
	must be used for display. It takes care about the fact that
	the temporal references may not be consecutive in case of
	sikipped pictures...
*/
static void NEARAPI VideoDisplayCtrl(void)
{
	WORD  comput1, index;
	WORD  min_temp_ref;
	WORD  cur_ref;

	min_temp_ref = ( pVideo->currTempRef & 0xF000 ) + 1024;
	// keep current pVideo->GOPindex
	index = 5;
	pVideo->currTempRef++; /* increment display temporal ref */

	/************** WARNING ************/
	// this routine will not work properly if GOP size > 1023
	if ( ( pVideo->currTempRef & 0xFFF ) > 1023 )   // 2 msb are used as pVideo->GOPindex
		pVideo->currTempRef = pVideo->currTempRef & 0xF000;   /* max temp ref is 1023: reset to 0 */

	/* search frame store to display */
	for (comput1 = 0; comput1 <= 3; comput1++) {
		cur_ref = pVideo->pictArray[comput1].tempRef & 0xFFF;
		if ( ( ( pVideo->currTempRef & 0xF000 ) == ( pVideo->pictArray[comput1].tempRef & 0xF000 ) )
			 && ( pVideo->currTempRef <= pVideo->pictArray[comput1].tempRef )
			 && ( min_temp_ref > cur_ref ) ) {
			// pVideo->currTempRef and pVideo->pictArray[comput1] refer to the same GOP
			// we want to extract the minimum temporal reference
			min_temp_ref = cur_ref;
			index = comput1;
		}
	}
	if (index == 5) {
		/*
			There is a group of pictures change: reset pVideo->currTempRef and
			increment pVideo->GOPindex
		*/
		pVideo->currTempRef = ( pVideo->currTempRef & 0xF000 ) + 0x4000;
		min_temp_ref = min_temp_ref + 0x4000;
		/* search frame store to display */
		for (comput1 = 0; comput1 <= 3; comput1++) {
			cur_ref = pVideo->pictArray[comput1].tempRef & 0xFFF;
			if ( ( ( pVideo->currTempRef & 0xF000 ) == ( pVideo->pictArray[comput1].tempRef & 0xF000 ) )
				 && ( pVideo->currTempRef <= pVideo->pictArray[comput1].tempRef )
				 && ( min_temp_ref > cur_ref ) ) {
				// pVideo->currTempRef and pVideo->pictArray[comput1] refer to the same GOP
				// we want to extract the minimum temporal reference
				min_temp_ref = cur_ref;
				index = comput1;
			}
		}
	}

	if (index == 5) {
		if (!pVideo->errCode)
			pVideo->errCode = TEMP_REF;	/* No pVideo->currTempRef corresponding to the display one */
		SetErrorCode(ERR_NO_TEMPORAL_REFERENCE);
	}
	else {
		pVideo->pNextDisplay->tempRef = 1025;
		// to release the previous pointer for next decoding
		pVideo->pNextDisplay = &pVideo->pictArray[index];
		if ( pVideo->pNextDisplay->validPTS == FALSE ) {
		/* PTS not available: compute a theoretical value */
			WORD lattency = 3000;	/* two 60Hz fields lattency */
			if ( pVideo->StreamInfo.displayMode == 0 )
				lattency = 3600;	   /* two 50Hz fields lattency */
			pVideo->pNextDisplay->dwPTS = pVideo->pCurrDisplay->dwPTS + lattency;
//			HostDirectPutChar('?', BLACK, LIGHTGREEN);
		}
		else{
//			HostDirectPutChar('G', BLACK, LIGHTGREEN);
		}
		// set next display pointer
		pVideo->currTempRef = pVideo->pictArray[index].tempRef;
		pVideo->pictArray[index].tempRef = 1024;
		/* this pVideo->currTempRef must not interfer on next tests */
	}
}

//----------------------------------------------------------------------------
//               Set parameters related to picture size
//----------------------------------------------------------------------------
/*
	This routine will always program the sample rate converter
	in order to display 720 horizontal pixels
*/
void FARAPI VideoSetPictureSize(void)
{
	WORD compute, comput1;
// If PAL Switch on optimization
	if ( pVideo->StreamInfo.frameRate == 3)
	{
			// Choose B Optimization for PAL for both Luma and Chroma
			BoardWriteVideo(CFG_BFS,NB_ROW_OF_MB);
			// Select Full Res vertical filter without interpolation
			// Interpollation NOT ALLOWED if Optimization
			pVideo->fullVerFilter = 0x01;
	}

	if ( (pVideo->StreamInfo.horSize > 720 ) ||
			 (pVideo->StreamInfo.verSize > 576 ))
	{
		if ( !pVideo->errCode )
			pVideo->errCode = HIGH_CCIR601; // picture size higher than CCIR601 format
    SetErrorCode(ERR_HIGHER_THAN_CCIR601);
		return;
	}

	// set SRC depending on the horizontal size in order to display 720
	// pixels
	if ( pVideo->StreamInfo.horSize < 720 ) {
		// lsr = 256 * (pVideo->StreamInfo.horSize-4) / (display size - 1)
		VideoSetSRC(pVideo->StreamInfo.horSize, 720);
	}
	else {
		VideoSRCOff();
	}

	if ( ( pVideo->StreamInfo.horSize >= 544 ) &&
			 ( ( pVideo->StreamInfo.pixelRatio == 0x3 ) ||
				 ( pVideo->StreamInfo.pixelRatio == 0x6 ) ) )
	{
		// picture size = 720 but pixel aspect ratio is 16/9
		// Program the SRC for display on a 4/3 screen
		// 544 pixels of the decoded picture extended into 720 pixels
		// for display
		VideoSetSRC(544, 720);
	}

	// set vertical filter and half/full resolution depending on the
	// vertical picture size
	if ( pVideo->StreamInfo.verSize > 288 ) {
		// typically 480 or 576 lines
		VideoSetFullRes();
	}
	else {
	// typically 240 or 288 lines
//		VideoSetFullRes(pVideo);
		VideoSetHalfRes();
	}

	// set picture sizes into the decoder
	comput1 = pVideo->StreamInfo.horSize + 15;		   // Horizontal size + 15
	comput1 = ( comput1 >> 4 ) & 0xFF;   // divide by 16
	BoardWriteVideo ( DFW, (BYTE)comput1 );
	// Decoded Frame Width in number of MB
	compute = ( pVideo->StreamInfo.verSize + 15 ) >> 4;
	compute = ( compute * comput1 ) & 0x3FFF;
	BoardWriteVideo ( DFS, (BYTE)( ( compute >> 8 ) & 0xFF ) );
	/* Decoded Frame Size in number of MB */
	BoardWriteVideo ( DFS , (BYTE)( compute & 0xFF ) );

	BoardWriteVideo ( VID_DFA , 0 );
	BoardWriteVideo ( VID_DFA , 0 );
	BoardWriteVideo ( VID_XFW, (BYTE)comput1 );
	BoardWriteVideo ( VID_XFS, (BYTE)( ( compute >> 8 ) & 0xFF ) );
	BoardWriteVideo ( VID_XFS, (BYTE)( compute & 0xFF ) );
	BoardWriteVideo ( VID_XFA , 0 );
	BoardWriteVideo ( VID_XFA , 0 );
}

//----------------------------------------------------------------------------
// store the next pan vector
//----------------------------------------------------------------------------
static void NEARAPI VideoSetPSV(void)
{
}

//----------------------------------------------------------------------------
//  Enable/disable the SRC
//----------------------------------------------------------------------------
void FARAPI VideoSwitchSRC (void)
{
	if (pVideo->useSRC != 0x0) {
		pVideo->currDCF = pVideo->currDCF ^ DSR;	   /* Switch SRC */
		BoardWriteVideo (DCF, 0);
		BoardWriteVideo (DCF + 1, (BYTE)(pVideo->currDCF));
	}
	else {
		// what ?
	}
}

//----------------------------------------------------------------------------
// enable the SRC
//----------------------------------------------------------------------------
static void NEARAPI VideoSRCOn(void)
{
		pVideo->useSRC = 0xFF;
		pVideo->currDCF = pVideo->currDCF & ~DSR ;	   /* Enable SRC */
		BoardWriteVideo ( DCF, 0 );
		BoardWriteVideo ( DCF + 1, (BYTE)(pVideo->currDCF));
}

//----------------------------------------------------------------------------
// Disable the SRC
//----------------------------------------------------------------------------
static void NEARAPI VideoSRCOff (void)
{
		pVideo->useSRC = 0x00;
		pVideo->currDCF = pVideo->currDCF | DSR ;	   /* Enable SRC */
		BoardWriteVideo ( DCF, 0 );
		BoardWriteVideo ( DCF + 1, (BYTE)(pVideo->currDCF));
}

//----------------------------------------------------------------------------
// display a full screen OSD with a uniform color (just as example)         			*/
//----------------------------------------------------------------------------
/*
 color 0 is green
 color 1 is yellow
 color 2 is cyan
 color 3 is magenta

 the OSD area is here defined from address zero
 in normal application this area is reserved for the bit buffer
 and the OSD will be typically defined after the bit buffer.
 Note: The bit buffer is defined in multiple of 256 bytes while
 MWP, OEP and OOP are memory addresses in mulitple of 64 bits
*/
static void NEARAPI VideoFullOSD (WORD col)
{
	long            big;
	WORD counter;
	VideoSetMWP(0L);
	counter = 0;
	while ( !VideoMemWriteFifoEmpty()) {
		counter ++;
		if (counter == 0xFF) {
			pVideo->errCode = BAD_MEM_V;
			SetErrorCode(ERR_MEM_WRITE_FIFO_NEVER_EMPTY);
			return ;
		}
	}
	BoardWriteVideo ( MWF, 19 );	   /* line 19 */

	BoardWriteVideo ( MWF, 0x1 );	   /* stop row */
	BoardWriteVideo ( MWF, 0x02 );   /* 19 + 240 - 1 */
	BoardWriteVideo ( MWF, 0x00 );   /* start column */
	BoardWriteVideo ( MWF, 100 );	   /* column 100 */
	BoardWriteVideo ( MWF, 0x3 );	   /* stop column = 100 + 700 - 1=
											* 31F */
	BoardWriteVideo ( MWF, 0x1F );   /* end init display size and
										* position */
	BoardWriteVideo ( MWF, 0x90 );   /* color 0 = green */
	BoardWriteVideo ( MWF, 0x32 );
	BoardWriteVideo ( MWF, 0xD0 );   /* color 1 = yellow */
	BoardWriteVideo ( MWF, 0x19 );
	BoardWriteVideo ( MWF, 0xA0 );   /* color 2 = cyan */
	BoardWriteVideo ( MWF, 0xA1 );
	BoardWriteVideo ( MWF, 0x60 );   /* color 3 = magenta */
	BoardWriteVideo ( MWF, 0xDE );   // 6/D/E
	if ( col == 1 )
		col = 0x55;
	else if ( col == 2 )
		col = 0xAA;
	else if ( col == 3 )
		col = 0xFF;
	for ( big = 0; big < 42000L; big++ )	// 42000 = 240 * 700 / 4
	{
		BoardWriteVideo ( MWF, (BYTE)col );
		// select color
	}
	for ( big = 0; big < 8; big++ )	   // add a dummy window outside
										 // the display
		BoardWriteVideo ( MWF, 0xFF );
	// to stop OSD
	VideoInitOEP ( 0 );					   // set OEP and OOP to start of
										 // bit map address
	BoardWriteVideo ( DCF, 0 );
	BoardWriteVideo ( DCF + 1, (BYTE)(pVideo->currDCF | 0x30));
	// enable OSD
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\jbs\staudio.h ===
//
// MODULE  : STAUDIO.H
//	PURPOSE : Audio functions
//	AUTHOR  : JBS Yadawa
// CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//

#ifndef __STAUDIO_H
#define __STAUDIO_H
#include "stdefs.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct {
	WORD      AudioState;
	WORD      ErrorMsg;    // Error Message
	WORD      IntAudio;    // Flag positioned when Audio interrupt is detected
	DWORD      PtsAudio;    // Audio PTS
	WORD      StrType;
	BOOL  FirstPTS;    // if First PTS reached FirstPTS=TRUE
	WORD      MaskItAudio; /* Audio Interrupt Mask */
	DWORD      icd[4];
	BOOL  mute;        /* TRUE   if audio is muted */
	BOOL  Stepped;     /* TRUE   if last step command has been executed */
	BOOL  fastForward; /* fast - TRUE = decode fast */
	WORD      decSlowDown; /* If !=0 slow motion decoding */
	WORD      DecodeMode;  /* Is PLAY_MODE, FAST_MODE or SLOW_MODE */
	DWORD      SampFreq;
	DWORD      FrameCount;  /* Frame Number */
} AUDIO,  *PAUDIO;

void AudioOpen(PAUDIO);
void AudioClose(void);
void AudioInitDecoder(WORD StreamType);
WORD AudioTestReg(void);
WORD AudioTest(void);
WORD AudioTestInt(void);
void AudioSetMode(WORD Mode, WORD param);
void AudioDecode(void);
void AudioStep(void);
void AudioStop(void);
void AudioPause(void);
WORD AudioGetState(void);
void AudioSetSTCParameters(DWORD SampFreq);
DWORD AudioGetSTC(void);
DWORD AudioGetVideoSTC(void);
void AudioInitSTC(DWORD stc);
DWORD AudioGetPTS(void);
WORD AudioGetErrorMsg(void);
void AudioSetRightVolume(WORD volume);
void AudioSetLeftVolume(WORD volume);
void AudioMute(void);
BOOL AudioIsFirstPTS(void);
void AudioSetStreamType(WORD StrType);
void AudioMaskInt(void);
void AudioRestoreInt(void);
BOOL AudioAudioInt (void);
void AudioInitPesParser (WORD StreamType);
#ifdef __cplusplus
}
#endif
#endif // #ifndef __STAUDIO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\jbs\sti3520a.h ===
//
// MODULE  : STi3520A.H
//	PURPOSE : STi3520A related unctions
//	AUTHOR  : JBS Yadawa
// CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//

#ifndef __STi3520A_H__
#define __STi3520A_H__
#define QUANT_TAB_SIZE		64

//---- Definition of the STi35xxx memory partitioning
#define NB_ROW_OF_MB 22	// Number of Rows of Macro blocks for B
												// pictures when optimmization is used
#define BUF_FULL 0x480// bit buffer occupies 0x480 * 256 bytes (1.75 Mbits)

//---- PAL
#define PSZ_PAL 0x0980  // Picture size = 720*576*1.5 / 256 = 0x97E
#define BUFF_A_PAL BUF_FULL+1   //
#define BUFF_B_PAL (BUFF_A_PAL+PSZ_PAL)
#define BUFF_C_PAL (BUFF_B_PAL+PSZ_PAL)

//---- NTSC

#define PSZ_NTSC 0x07F0
#define BUFF_A_NTSC BUF_FULL+1
#define BUFF_B_NTSC (BUFF_A_NTSC+PSZ_NTSC)
#define BUFF_C_NTSC (BUFF_B_NTSC+PSZ_NTSC)

//---- OSD
#define OSD_START (BUFF_C + ((NB_ROW_OF_MB*3)/2))*32L

#define FORWARD_PRED 	0
#define	BACKWARD_PRED	1

#define PICT	  0x0000
#define USER	  0xB200
#define SEQ	   	0xB300
#define SEQ_ERR	0xB400
#define EXT		  0xB500
#define SEQ_END 0xB700
#define GOP	   	0xB800
#define SEQ_EXT	 	0x10
#define SEQ_DISP 	0x20
#define QUANT_EXT 0x30
#define SEQ_SCAL 	0x50
#define PICT_PSV 	0x70
#define PICT_COD 	0x80
#define PICT_SCAL 0x90

/***********************************************/
/*   definition of states of FistVsyncAfterVbv */
/***********************************************/
// FistVsyncAfterVbv is a 3 state variable
// before vbv                      FistVsyncAfterVbv = NOT_YET_VBV
// between vbv and following vsync FistVsyncAfterVbv = NOT_YET_VST
// after vsync following vbv       FistVsyncAfterVbv = PAST_VBV_AND_VST
#define NOT_YET_VBV	 	   0
#define NOT_YET_VST	 	   1
#define PAST_VBV_AND_VST 2

#define CFG_MCF			0x00
#define CFG_CCF			0x01
#define VID_CTL			0x02
#define VID_TIS			0x03
#define VID_PFH			0x04
#define VID_PFV			0x05
#define VID_PPR1		0x06
#define VID_PPR2		0x07
#define CFG_MRF			0x08
#define CFG_MWF			0x08
#define CFG_BMS			0x09
#define CFG_MRP			0x0A
#define CFG_MWP			0x0B
#define VID_DFP			0x0C
#define VID_RFP			0x0E
#define VID_FFP			0x10
#define VID_BFP			0x12
#define VID_VBG			0x14
#define VID_VBL			0x16
#define VID_VBS			0x18
#define VID_VBT			0x1A

#define AUD_ABG  		0X1C
#define AUD_ABL			0X1E
#define AUD_ABS			0X20
#define AUD_ABT			0X22

#define VID_DFS			0x24
#define VID_DFW			0x25
#define VID_DFA			0x26
#define VID_XFS			0x27
#define VID_XFW			0x28
#define VID_XFA			0x29
#define VID_OTP			0x2A
#define VID_OBP			0x2B
#define VID_PAN			0x2C
#define VID_SCN			0x2E
#define VID_REV			0x78
#define CKG_PLL			0x30
#define CKG_CFG			0x31
#define CKG_AUD			0x32
#define CKG_VID			0x33
#define CKG_PIX			0x34
#define CKG_PCM			0x35
#define CKG_MCK			0x36
#define CKG_AUX			0x37
#define CKG_DRC			0x38
#define CFG_BFS			0x39
#define PES_AUD			0x40
#define PES_VID			0x41
#define PES_SPF			0x42
#define PES_STA			0x43
#define PES_SC1			0x44
#define PES_SC2			0x45
#define PES_SC3			0x46
#define PES_SC4			0x47
#define PES_SC5			0x48
#define PES_TS1			0x49
#define PES_TS2			0x4A
#define PES_TS3			0x4B
#define PES_TS4			0x4C
#define PES_TS5			0x4D
#define PES_PTS_FIFO 0x68

#define VID_ITM			0x60
#define VID_ITM1		0x3C
#define VID_ITS			0x62
#define VID_ITS1		0x3D
#define VID_STA			0x64
#define VID_STA1		0x3B
#define VID_HDF			0x66
#define CDcount			0x67
#define SCDcount		0x68
#define VID_HDS			0x69
#define VID_LSO			0x6A
#define VID_LSR			0x6B
#define VID_CSO			0x6C
#define VID_LSRh		0x6D
#define VID_YDO			0x6E
#define VID_YDS			0x6F
#define VID_XDO			0x70
#define VID_XDS			0x72
#define VID_DCF			0x74
#define VID_QMW			0x76
#define VID_TST			0x77

/************************************************************/
/*    Definition of STi3520A registers with STi3520 names  */
/************************************************************/
#define HDF 	VID_HDF
#define CTL 	VID_CTL
#define STA 	VID_STA
#define ITM 	VID_ITM
#define ITM1	VID_ITM1
#define ITS 	VID_ITS
#define ITS1 	VID_ITS1
#define MRF 	CFG_MRF
#define MWF 	CFG_MWF
#define BMS 	CFG_BMS
#define MRP		CFG_MRP
#define MWP		CFG_MWP
#define DFP 	VID_DFP
#define RFP		VID_RFP
#define FFP		VID_FFP
#define BFP		VID_BFP
#define FBP		VID_FBP	// shares the same address as BFP
#define BBL		VID_VBL
#define BBS		VID_VBS
#define BBG		VID_VBG
#define BBT		VID_VBT
#define DFW		VID_DFW
#define DFS		VID_DFS
#define YDO		VID_YDO
#define XDO		VID_XDO
#define YDS		VID_YDS
#define XDS		VID_XDS
#define OEP		VID_OBP
#define OOP 	VID_OTP
#define LSO		VID_LSO
#define LSR		VID_LSR
#define CSO		VID_CSO
#define DCF		VID_DCF
#define QMW		VID_QMW
/*********************************************/
/*    Definition of the STi3520A Bit Position*/
/*********************************************/
// CFG_CCF    Register bits
#define M32        0x80
#define M16        0x40
#define PBO        0x20
#define EC3        0x10
#define EC2        0x08
#define ECK        0x04
#define EDI        0x02
#define EVI        0x01
// CFG_DRC    Register bits
#define NPD        0x40
#define MRS        0x20
#define SGR        0x08
#define CLK        0x04
#define HPD        0x02
#define SDR        0x01
// CFG_MCF    Register bits
#define M20        0x80
#define RFI        0x7F
// CTL    Register bits
#define ERU			   0x80
#define ERS	       0x40
#define CBC	       0x20
#define DEC	       0x10
#define EPR	       0x08
#define PRS			   0x04
#define SRS			   0x02
#define EDC        0x01
#define A35        0x8000	// for STi3500A code compatibility

// DCF    Register bits
#define OAD1	0x8000
#define OAD0	0x4000
#define OAM		0x2000
#define XYE		0x1000
#define DAM2	0x0800
#define DAM1	0x0400
#define DAM0	0x0200
#define FLD	  0x0100
#define USR		0x0080
#define PXD	  0x0040
#define EVD	  0x0020
#define EOS	  0x0010
#define DSR	  0x0008
#define VFC2	0x0004
#define VFC1	0x0002
#define VFC0	0x0001
// ITM/ITS/STA   Status Register bits
#define PDE		0x8000
#define SER		0x4000
#define BMI		0x2000
#define HFF		0x1000
#define RFF		0x0800
#define WFE		0x0400
#define PID		0x0200
#define PER		0x0100
#define PSD 	0x0080
#define TOP 	0x0040
#define BOT 	0x0020
#define BBE		0x0010
#define BBF		0x0008
#define HFE		0x0004
#define BFF		0x0002
#define HIT		0x0001

// VID_TIS    Register bits
#define MP2	  0x40
#define SKP1  0x20
#define SKP0  0x10
#define OVW	  0x08
#define FIS	  0x04
#define RPT	  0x02
#define EXE	  0x01

#define SOS		0x08
#define QMN		0x04
#define QMI		0x02
#define HDS   0x01

//ckw start
// AUD		Registers
#define AUD_ANC0	0x86
#define AUD_ANC8	0x87

#define AUD_ANC16	0x88
#define AUD_ANC24	0x89
#define AUD_ESC0	0x8A
#define AUD_ESC8	0x8B
#define AUD_ESC16	0x8C
#define AUD_ESC24	0x8D
#define AUD_ESC32	0x8E
#define AUD_ESCX0	0x8F

#define AUD_LRP		0x91
#define AUD_FFL0	0x94
#define AUD_FFL8	0x95
#define AUD_P18		0x96

#define AUD_CDI0	0x98
#define AUD_FOR		0x99
#define AUD_ITR0	0x9A
#define AUD_ITR8	0x9B
#define AUD_ITM0	0x9C
#define AUD_ITM8	0x9D
#define AUD_LCA		0x9E
#define AUD_EXT		0x9F

#define AUD_RCA		0xA0
#define AUD_SID		0xA2
#define AUD_SYN		0xA3
#define AUD_IDE		0xA4
#define AUD_SCM		0xA5
#define AUD_SYS		0xA6
#define AUD_SYE		0xA7

#define AUD_LCK		0xA8
#define AUD_CRC		0xAA
#define AUD_SEM		0xAC
#define AUD_PLY		0xAE

#define AUD_MUT		0xB0
#define AUD_SKP		0xB2
#define AUD_ISS		0xB6

#define AUD_ORD		0xB8
#define AUD_LAT		0xBC

#define AUD_RES		0xC0
#define AUD_RST		0xC2
#define AUD_SFR		0xC4
#define AUD_DEM		0xC6

#define AUD_IFT		0xD2
#define AUD_SCP		0xD3

#define AUD_ITS		0xDB
#define AUD_IMS		0xDC
#define AUD_HDR0	0xDE
#define AUD_HDR8	0xDF

#define AUD_HDR16	0xE0
#define AUD_HDR24	0xE1
#define AUD_PTS0	0xE2
#define AUD_PTS8	0xE3
#define AUD_PTS16	0xE4
#define AUD_PTS24	0xE5
#define AUD_PTS32	0xE6

#define AUD_ADA		0xEC
#define AUD_REV		0xED
#define AUD_DIV		0xEE
#define AUD_DIF		0xEF

#define AUD_BBE		0xF0
//ckw end

//*************************************************
// STi4500 register definitions
//*************************************************
#define ANC                0x06
#define ANC_AV             0x6C
#define ATTEN_L            0x1E
#define ATTEN_R            0x20
#define AUDIO_ID           0x22
#define AUDIO_ID_EN        0x24
#define BALE_LIM_H         0x69
#define BALF_LIM_H         0x6B
#define CRC_ECM            0x2A
#define DIF                0x6F
#define DMPH               0x46
#define DRAM_EXT           0x3E
#define DUAL_REG           0x1F
#define FIFO_IN_TRESHOLD   0x52
#define FORMAT             0x19
#define FRAME_NUMBER       0x13
#define FRAME_OFFSET       0x12
#define FREE_FORM_H        0x15
#define FREE_FORM_L        0x14
#define HEADER             0x5E
#define INTR               0x1A
#define INTR_EN            0x1C
#define INVERT_LRCLK       0x11
#define INVERT_SCLK        0x53
#define LATENCY            0x3C
#define MUTE               0x30
#define PACKET_SYNC_CHOICE 0x23
#define PCM_DIV            0x6E
#define PCM_FS             0x44
#define PCM_ORD            0x38
#define PCM_18             0x16
#define PLAY               0x2E
#define PTS_0              0x62
#define PTS_1              0x63
#define PTS_2              0x64
#define PTS_3              0x65
#define PTS_4              0x66
#define REPEAT             0x34
#define RESET              0x40
#define RESTART            0x42
#define SIN_EN             0x70
#define SKIP               0x32
#define STC_INC            0x10
#define STC_DIVH           0x49
#define STC_DIVL           0x48
#define STC_CTL            0x21
#define STC_0              0x4A
#define STC_1              0x4B
#define STC_2              0x4C
#define STC_3              0x4D
#define STC_4              0x4E
#define STR_SEL            0x36
#define SYNCHRO_CONFIRM    0x25
#define SYNC_ECM           0x2C
#define SYNC_LCK           0x28
#define SYNC_REG           0x27
#define SYNC_ST            0x26
#define VERSION            0x6D

/* Define Interrupt Masks of the STi4500*/
#define SYNC        0x0001  // Set upon change in synchro status
#define HEAD        0x0002  // Set when a valid header has been registered
#define PTS         0x0004  // Set when PTS detected
#define BALE        0x0008  // Set when under BALE treshold
#define BALF        0x0010  // Set when over BALF treshold
#define CRC         0x0020  // Set when CRC error is detected
#define ANCI        0x0080  // Set when Ancillary buffer is full
#define PCMU        0x0100  // Set on PCM buffer underflow
#define SAMP        0x0200  // Set when sampling frequency has changed
#define DEMP        0x0400  // Set when de-emphasis changed
#define DFUL        0x0800  // Set when DRAM is full
#define FIFT        0x1000  // Set when fifo_in_treshold reached
#define FIFF        0x2000  // Set when fifo is full
#define BOF         0x4000  // Set when Begining of frame

#define NSYNC       0xFFFE  // Set upon change in synchro status
#define NHEAD       0xFFFD  // Set when a valid header has been registered
#define NPTS        0xFFFB  // Set when PTS detected
#define NBALE       0xFFF7  // Set when under BALE treshold
#define NBALF       0xFFEF  // Set when over BALF treshold
#define NCRC        0xFFDF  // Set when CRC error is detected
#define NANC        0xFF7F  // Set when Ancillary buffer is full
#define NPCMU       0xFEFF  // Set on PCM buffer underflow
#define NSAMP       0xFDFF  // Set when sampling frequency has changed
#define NDEMP       0xFBFF  // Set when de-emphasis changed
#define NDFUL       0xF7FF  // Set when DRAM is full
#define NFIFT       0xEFFF  // Set when fifo_in_treshold reached
#define NFIFF       0xDFFF  // Set when fifo is full
#define NBOF        0xBFFF  // Set when Begining of frame


BOOL FARAPI VideoOpen(void);
void FARAPI VideoClose(void);
void FARAPI VideoInitDecoder(STREAMTYPE StreamType);
void FARAPI VideoSetMode(WORD Mode, WORD param);
void FARAPI VideoDecode(void);
void FARAPI VideoStep(void);
void FARAPI VideoBack(void);
void FARAPI VideoStop(void);
void FARAPI VideoPause(void);
BOOL FARAPI AudioIsEnoughPlace(WORD size);
BOOL FARAPI VideoIsEnoughPlace(WORD size);
DWORD FARAPI VideoGetFirstDTS(void);
WORD FARAPI VideoGetErrorMsg(void);
void FARAPI VideoSkip(void);
void FARAPI VideoRepeat(void);
WORD FARAPI VideoGetState(void);
DWORD FARAPI VideoGetPTS(void);
BOOL FARAPI VideoIsFirstDTS(void);
BOOL FARAPI VideoIsFirstField(void);
BOOL FARAPI VideoForceBKC(BOOL bEnable);
void FARAPI VideoMaskInt (void);
void FARAPI VideoRestoreInt (void);
BOOL FARAPI VideoVideoInt(void);
WORD FARAPI SendAudioIfPossible(LPBYTE pBuffer, WORD Size);
WORD FARAPI SendAudioToVideoIfPossible(LPBYTE Buffer, WORD Size);
void FARAPI VideoInitPesParser(STREAMTYPE StreamType );
BOOL FARAPI VideoIsValidPTS(void);
DWORD FARAPI BoardReadVideoPTS(void);
WORD FARAPI VideoTestReg(void);
WORD FARAPI VideoTestMemPat(WORD pattern, WORD pattern1);
WORD FARAPI VideoTestMem(void);
void FARAPI VideoSetVideoWindow (WORD a, WORD b, WORD c, WORD d );
void FARAPI VideoInitXY(void);
void FARAPI SetXY(WORD xds, WORD yds);
void FARAPI VideoSetPictureSize(void);
void FARAPI VideoSwitchSRC (void);
void FARAPI VideoSeekDecoder(STREAMTYPE StreamType);
WORD FARAPI VideoGetABL(void)  ;
#endif // #ifndef __STi3520A_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\jbs\zac3.h ===
//
// MODULE  : ZAC3.H
//	PURPOSE : Zoran AC3 related 
//	AUTHOR  : JBS Yadawa
// CREATED :  7/20/96
//
//	REVISION HISTORY :
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	DATE     :
//
//	COMMENTS :
//

#ifndef __ZAC3_H__
#define __ZAC3_H__

//ckw start
//*************************************************
// ZR38500 Command definitions
//*************************************************
#define	AC3_AC3		0x85
#define AC3_CFG		0x82
#define	AC3_PLAY	0x8A
#define AC3_MUTE	0x8B
#define	AC3_UNMUTE	0x89
#define	AC3_STOP	0x8C
#define	AC3_STOPF	0x8D
#define	AC3_STAT	0x8E
#define	AC3_NOP		0x80
#define	AC3_VER		0x81
//ckw end

BOOL FARAPI InitAC3Decoder(void);
BOOL FARAPI BootAC3(void); //ckw
void FARAPI SendAC3Data(BYTE FAR *Data, DWORD Size);
BYTE FARAPI SPISendSeq(int Num, BYTE FAR *Data);
void FARAPI SPIReadBack(BYTE command, int numresult, BYTE *result); //ckw
void FARAPI AC3Command(BYTE command); //ckw
void FARAPI	AudioTransfer(BOOL flag); //ckw
#endif // __ZAC3_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgs\cpq3520a\board.c ===
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
// 	MODULE  : BOARD.C
//	PURPOSE : Board specific code goes here
//	AUTHOR  : JBS Yadawa
// 	CREATED :  7/20/96
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY:
//	-----------------
//
// 	DATE 			: 	COMMENTS
//	----			: 	--------
//
//	1-8-97		: 	Board structure added
//	1-10-97		:	Added ON/OFF functions for GPIO
//	1-14-97		: 	Added support for audio req bit polling
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

#include "strmini.h"
#include "stdefs.h"
#include "board.h"
#include "i20reg.h"
#include "bt856.h"
#include "memio.h"

#define POSTOFFICEREG 	0x200
#define INCTL			0x01
#define AUXCTL			0x02
#define INTR_CTRL 		0x40
#define INTR_STATUS		0x3C

static BOARD Board;
static PBOARD pBoard;


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : BoardReadAudio
//	PARAMS	: Reg to read
//	RETURNS	: Read value
//
//	PURPOSE	: Read given audio register from the chip
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BYTE FARAPI BoardReadAudio(BYTE Reg)
{
	BYTE 	Adr = Reg & 0x7E;
	DWORD PoReg=0;

	PoReg = Adr | 0x00830000;
	memOutDword(POSTOFFICEREG, PoReg);
	while(memInDword(POSTOFFICEREG)&02000000L);

	if(Reg&0x01)
		PoReg = 0x00150000;
	else
		PoReg = 0x00140000;
	memOutDword(POSTOFFICEREG, PoReg);
	while(memInDword(POSTOFFICEREG)&02000000L);
	
	PoReg = memInDword(POSTOFFICEREG);
	return ((BYTE)PoReg);
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : BoardReadVideo
//	PARAMS	: Reg to read
//	RETURNS	: Read value
//
//	PURPOSE	: Read given Video register from the chip
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BYTE FARAPI BoardReadVideo(BYTE Reg)
{
	BYTE 	Adr = Reg & 0x7E;
	DWORD PoReg=0;

	PoReg = Adr | 0x00830000;
	memOutDword(POSTOFFICEREG, PoReg);
	while(memInDword(POSTOFFICEREG)&02000000L);
	if(Reg&0x01)
		PoReg = 0x00110000;
	else
		PoReg = 0x00100000;
	memOutDword(POSTOFFICEREG, PoReg);
	while(memInDword(POSTOFFICEREG)&02000000L);
	
	PoReg = memInDword(POSTOFFICEREG);
	return ((BYTE)PoReg);
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : BoardWriteAudio
//	PARAMS	: Reg to write and value
//	RETURNS	: None
//
//	PURPOSE	: Write given audio register to the chip
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

void FARAPI BoardWriteAudio(BYTE Reg, BYTE Data)
{
	BYTE 	Adr = Reg & 0x7E;
	DWORD PoReg=0;

	PoReg = Adr | 0x00830000;
	memOutDword(POSTOFFICEREG, PoReg);
	while(memInDword(POSTOFFICEREG)&02000000L);
	if(Reg&0x01)
		PoReg = Data | 0x00970000;
	else
		PoReg = Data | 0x00960000;
	memOutDword(POSTOFFICEREG, PoReg);
	while(memInDword(POSTOFFICEREG)&02000000L);
	
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : BoardWriteVideo
//	PARAMS	: Reg to write and value
//	RETURNS	: None
//
//	PURPOSE	: Write given video register to the chip
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

void FARAPI BoardWriteVideo(BYTE Reg, BYTE Data)
{
	BYTE 	Adr = Reg & 0x7E;
	DWORD PoReg=0;

	PoReg = Adr | 0x00830000;
	memOutDword(POSTOFFICEREG, PoReg);
	while(memInDword(POSTOFFICEREG)&02000000L);
	if(Reg&0x01)
		PoReg = Data | 0x00930000;
	else
		PoReg = Data | 0x00920000;
	memOutDword(POSTOFFICEREG, PoReg);
	while(memInDword(POSTOFFICEREG)&02000000L);
	
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : BoardEnableIRQ
//	PARAMS	: None
//	RETURNS	: None
//
//	PURPOSE	: Enable IRQ on the board
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

void FARAPI BoardEnableIRQ(void)
{
   memOutByte(INTR_CTRL+3,0x71);
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : BoardDisableIRQ
//	PARAMS	: None
//	RETURNS	: None
//
//	PURPOSE	: Disable IRQ on the board
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

void FARAPI BoardDisableIRQ(void)
{
   memOutByte(INTR_CTRL+3,0x00);
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : BoardOpen
//	PARAMS	: Base Adddress
//	RETURNS	: None
//
//	PURPOSE	: Open mem i/o and init the board
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

PBOARD FARAPI BoardOpen(DWORD_PTR Base)
{
	pBoard = &Board;
   DPF(("Allocating Memory Base!!\n"));
	if(!AllocMemoryBase(Base, 0x1000))
	{
      DPF(("Can not covert Physical to Linear"));
		return NULL;
	}
	return pBoard;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : BoardHardReset
//	PARAMS	: none
//	RETURNS	: TRUE on success FALSE otherwise
//
//	PURPOSE	: Hard Reset the board
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL FARAPI BoardHardReset(void)
{
	DPF(("GPIO = %lx", memInDword(I20_GPREG)));
	memOutDword(I20_GPREG, 0x000000ff);
	Delay(100);
	memOutDword(I20_GPREG, 0x010000ff);
	Delay(100);
	memOutDword(I20_GPREG, 0x000000ff);
	Delay(100);
	memOutDword(I20_GPREG, 0x010000ff);
   Delay(100);
	DPF(("GPIO = %lx", memInDword(I20_GPREG)));
	// Gen Purpose Directions
	memOutByte(I20_GPREG,
				DIR(AXREQ,  INPUT) |
				DIR(STIREQ, INPUT) |
				DIR(STIRST, OUTPUT) |
				DIR(SRESET, OUTPUT) |
				DIR(SPIEN,  OUTPUT) |
				DIR(SPICLK, OUTPUT) |
				DIR(SPIDI,  INPUT) |
				DIR(SPIDO,  OUTPUT));

	memOutByte(I20_GBREG+3,
				TURN(AXREQ,  OFF) |
				TURN(STIREQ,  OFF) |
				TURN(STIRST,  OFF) |
				TURN(SRESET,  OFF) |
				TURN(SPIEN,  ON) |
				TURN(SPICLK, ON) |
				TURN(SPIDI,  OFF) |
				TURN(SPIDO,  OFF));
	Delay(100);

	memOutByte(I20_GBREG+3,
				TURN(AXREQ,  OFF) |
				TURN(STIREQ,  OFF) |
				TURN(STIRST,  OFF) |
				TURN(SRESET,  OFF) |
				TURN(SPIEN,  ON) |
				TURN(SPICLK, OFF) |
				TURN(SPIDI,  OFF) |
				TURN(SPIDO,  OFF));

	Delay(100);
	BoardWriteEPLD(INCTL, 0x00);
	Delay(100);
	BoardWriteEPLD(AUXCTL, 0x00);
	Delay(100);
	memOutByte(I20_GBREG+3,
				TURN(AXREQ,  OFF) |
				TURN(STIREQ,  OFF) |
				TURN(STIRST,  ON) |
				TURN(SRESET,  ON) |
				TURN(SPIEN,  ON) |
				TURN(SPICLK, OFF) |
				TURN(SPIDI,  OFF) |
				TURN(SPIDO,  OFF));

	pBoard->gpio =
				TURN(AXREQ,  OFF) |
				TURN(STIREQ,  OFF) |
				TURN(STIRST,  ON) |
				TURN(SRESET,  ON) |
				TURN(SPIEN,  ON) |
				TURN(SPICLK, OFF) |
				TURN(SPIDI,  OFF) |
				TURN(SPIDO,  OFF);
	
	Delay(100);
	memOutByte(I20_GBREG, 0x00);
	Delay(100);
   memOutByte(I20_GBREG+1, 0x00);
	Delay(100);
	
	BoardWriteEPLD(INCTL, 0x00);
	Delay(100);
	BoardWriteEPLD(AUXCTL, 0x00);
	Delay(100);
	BTInitEnc();
	BTSetVideoStandard(NTSC_PLAY);
	BTInitEnc();
	BTSetVideoStandard(NTSC_PLAY);

	return TRUE;
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : BoardClose
//	PARAMS	: Noone
//	RETURNS	: None
//
//	PURPOSE	: Close the board
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL FARAPI BoardClose(void)
{
	FreeMemoryBase();
	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : Delay
//	PARAMS	: Noone
//	RETURNS	: None
//
//	PURPOSE	: delay for n microseconds
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

void FARAPI Delay(DWORD Microseconds)
{
	/*
	DWORD i, d;
	
	for (i = 0; i < Microseconds*2; i++)
		d = inp(0x0070)%2; // the action of reading takes about 1s
	*/
    KeStallExecutionProcessor(Microseconds*2);

}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : BoardWriteEPLD
//	PARAMS	: Reg, Data
//	RETURNS	: None
//
//	PURPOSE	: Write to EPLD
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

void FARAPI BoardWriteEPLD(BYTE Reg, BYTE Data)
{
	DWORD PoReg=0;

	PoReg = Data | 0x00800000 | ((DWORD)(Reg&0x07) << 16);
	memOutDword(POSTOFFICEREG, PoReg);
	while(memInDword(POSTOFFICEREG)&02000000L);
	
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : BoardWriteGPIOReg
//	PARAMS	: Bit to write, and value
//	RETURNS	: None
//
//	PURPOSE	: Write to GPIO
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

void FARAPI BoardWriteGPIOReg(BYTE Bit, BOOL Val)
{
	BYTE x;
	if(Val)
	{
		x = 1 << Bit;
		pBoard->gpio |= x;
		memOutByte(I20_GBREG+3, pBoard->gpio);
	}		
	else
	{
		x = 1 << Bit;
		x = ~x;
		pBoard->gpio &= x;
		memOutByte(I20_GBREG+3, pBoard->gpio);
	}
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : BoardReadGPIOReg
//	PARAMS	: Bit to read
//	RETURNS	: None
//
//	PURPOSE	: Read the value of bit from GPIO
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL FARAPI BoardReadGPIOReg(BYTE Bit)
{
        BYTE b;
		  b = memInByte(I20_GBREG+3);	
        return ((b>>Bit)&0x01);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\jbs\zac3.c ===
//
// MODULE  : ZAC3.C
//	PURPOSE : Zoran AC3 specific code
//	AUTHOR  : JBS Yadawa
// CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//

#include "common.h"
#include "strmini.h"
#include "stdefs.h"
#include "board.h"
#include "debug.h"
#include "i20reg.h"
#include "bt856.h"
#include "memio.h"
#include "zac3.h"
#include "sti3520a.h" //ckw

#define POSTOFFICEREG 		0x200
#define  SPIDO		0x07 //ckw
#define  SPIDI		0x06 //ckw
#define  SPICLK		0x05
#define  SPIENA		0x04
#define PARAMSIZE 9

static void NEARAPI SPIStart(void);
static void NEARAPI SPIStop(void);
static BYTE NEARAPI SPISendByte(BYTE data);

BYTE CfgParams[PARAMSIZE] = {AC3_CFG, 0xD0,0x08,0x89,0x09,0x14,0x02,0x02,0x06}; //ckw
BYTE AC3Params[PARAMSIZE] = {AC3_AC3, 0x10,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF}; //ckw
#define NUMCODE 2501
BYTE AC3MCode[NUMCODE] = {
0x90, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x02, 0x56, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 
0xB8, 0x0C, 0x00, 0x00, 0xB0, 0x3C, 0x38, 0x0D, 0x00, 0x5D, 0x32, 0x10, 0x0F, 0xF5, 0x3B, 
0x80, 0x00, 0x00, 0x34, 0x3D, 0x03, 0xFB, 0x00, 0x03, 0xCD, 0x82, 0x38, 0x8D, 0x00, 0x00, 
0x3A, 0x80, 0x02, 0x52, 0x3A, 0xAD, 0x00, 0x0C, 0x00, 0x03, 0xF0, 0x85, 0x1B, 0x5B, 0xCD, 
0x86, 0x1B, 0x93, 0xF0, 0x85, 0x3B, 0x80, 0x00, 0x01, 0x36, 0xDE, 0x00, 0x42, 0x00, 0x03, 
0xC0, 0xB6, 0x30, 0x3D, 0x03, 0xFB, 0x34, 0x30, 0x0F, 0x8D, 0x2E, 0xCF, 0xFF, 0xFF, 0x3C, 
0x3D, 0x00, 0x17, 0x30, 0x30, 0x0F, 0x8D, 0x00, 0x03, 0xEC, 0x32, 0x00, 0x00, 0xB0, 0x3C, 
0x00, 0x03, 0xF0, 0x2B, 0x00, 0x03, 0xF0, 0x2D, 0x3B, 0x80, 0x00, 0x01, 0x34, 0x30, 0x0F, 
0xCC, 0x34, 0x3D, 0x03, 0xF6, 0x2E, 0xCF, 0xFF, 0xFF, 0x3C, 0x3D, 0x00, 0x43, 0x30, 0x3D, 
0x03, 0xF6, 0xB9, 0x20, 0x00, 0x00, 0x3A, 0xDD, 0x00, 0x43, 0x38, 0x3D, 0x00, 0x23, 0x30, 
0x30, 0x0F, 0xF9, 0x38, 0x4F, 0x87, 0x20, 0x3A, 0xDD, 0x00, 0x43, 0x38, 0x3D, 0x00, 0x27, 
0x30, 0x30, 0x0F, 0xF9, 0x38, 0x44, 0xE1, 0xF0, 0x3A, 0xDD, 0x00, 0x43, 0x38, 0x3D, 0x00, 
0x2B, 0x30, 0x30, 0x0F, 0xF9, 0x34, 0x4D, 0x03, 0xDD, 0x3A, 0xDD, 0x00, 0x43, 0x38, 0x3D, 
0x00, 0x2F, 0x30, 0x30, 0x0F, 0xF9, 0x00, 0x03, 0xEB, 0x01, 0x3B, 0x50, 0x00, 0x00, 0x34, 
0x4D, 0x03, 0xDE, 0x30, 0x4D, 0x03, 0xF6, 0x2F, 0x30, 0x00, 0x08, 0x3A, 0xDD, 0x00, 0x45, 
0x38, 0x3D, 0x00, 0x37, 0x30, 0x30, 0x0F, 0xF9, 0xB6, 0xDB, 0xE3, 0x81, 0x34, 0xED, 0x03, 
0xF3, 0x34, 0x3D, 0x03, 0xF6, 0x14, 0xDB, 0xFC, 0x84, 0x30, 0xED, 0x03, 0xF3, 0x3C, 0x3D, 
0x00, 0x43, 0x00, 0x03, 0xF0, 0x0E, 0x30, 0x3D, 0x03, 0xF6, 0x34, 0x3D, 0x03, 0xDF, 0x30, 
0x3D, 0x03, 0xF6, 0x38, 0x3D, 0x00, 0x1B, 0x30, 0x30, 0x0F, 0xF9, 0x00, 0x03, 0xEB, 0x01, 
0x3B, 0x50, 0x00, 0x00, 0x34, 0x30, 0x0F, 0xC8, 0x0C, 0xE3, 0xFE, 0xB2, 0x00, 0x03, 0xC1, 
0x31, 0x00, 0x00, 0x1E, 0x38, 0x00, 0x03, 0xF0, 0x2C, 0x34, 0x40, 0x0F, 0xCD, 0x00, 0x03, 
0xF0, 0x2B, 0x00, 0x03, 0xF0, 0x2D, 0x3B, 0x80, 0x00, 0x01, 0x34, 0x30, 0x0F, 0xCC, 0x00, 
0x03, 0xEB, 0x01, 0x3B, 0x50, 0x00, 0x00, 0x34, 0x40, 0x0F, 0xC8, 0x00, 0x03, 0xFF, 0x03, 
0x00, 0x03, 0xED, 0x7A, 0x0D, 0x1B, 0xF0, 0x2C, 0x00, 0x03, 0xC0, 0xF1, 0x00, 0x03, 0xC0, 
0xF2, 0x00, 0x03, 0xC0, 0xF3, 0x34, 0x40, 0x0F, 0xCD, 0x00, 0x03, 0xF0, 0x2B, 0x00, 0x03, 
0xF0, 0x2D, 0x3B, 0x80, 0x00, 0x01, 0x34, 0x30, 0x0F, 0xCC, 0x3B, 0x80, 0x00, 0x00, 0x34, 
0x20, 0x0F, 0xFA, 0x00, 0x50, 0x00, 0x00, 0x3C, 0x1D, 0x00, 0x6C, 0x34, 0x00, 0x0F, 0xC5, 
0x2C, 0xB0, 0x00, 0x01, 0x3C, 0x1D, 0x00, 0x71, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x3A, 0xDE, 0x16, 0x12, 0x3A, 0xFD, 0x00, 0x69, 0x00, 0x03, 0xEB, 0xC1, 0x3A, 0xDD, 
0x01, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB2, 0xEC, 0x2C, 0x00, 0x08, 0x00, 0x3A, 
0xDD, 0x00, 0x83, 0x3C, 0x1E, 0x16, 0x12, 0x3B, 0x80, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
0x3A, 0xDE, 0x16, 0x12, 0x3A, 0xFD, 0x00, 0x74, 0x00, 0x03, 0xEB, 0xC1, 0x34, 0x00, 0x0F, 
0xC5, 0x2C, 0x00, 0x08, 0x00, 0x3C, 0x1D, 0x01, 0x91, 0x00, 0x00, 0x00, 0x00, 0x38, 0x0D, 
0x00, 0x11, 0x32, 0x10, 0x0F, 0xF8, 0x00, 0x00, 0xB8, 0x0C, 0x38, 0x00, 0x03, 0x80, 0x30, 
0x00, 0x0D, 0xCB, 0x2E, 0x15, 0x00, 0x00, 0x30, 0x00, 0x0F, 0x8D, 0x00, 0x00, 0xC0, 0x3C, 
0x38, 0x00, 0x06, 0x00, 0x32, 0x10, 0x0F, 0x81, 0x3A, 0xDD, 0x01, 0x91, 0x34, 0x00, 0x0D, 
0xC6, 0x2C, 0x30, 0x00, 0x07, 0x3C, 0x6D, 0x00, 0x89, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 
0x00, 0x00, 0x32, 0x10, 0x0D, 0xCA, 0x34, 0x00, 0x0D, 0xCA, 0x00, 0x40, 0x00, 0x00, 0x3C, 
0x6D, 0x00, 0xCD, 0x00, 0x00, 0xB4, 0x6C, 0x00, 0x00, 0xB4, 0x2C, 0x3A, 0xDD, 0x01, 0xB1, 
0x3A, 0xFD, 0x00, 0x91, 0x00, 0x03, 0xEB, 0xC1, 0x34, 0x00, 0x0D, 0xC6, 0x2C, 0x30, 0x00, 
0x07, 0x3C, 0x1D, 0x00, 0x9C, 0x34, 0x00, 0x0D, 0xCB, 0x2E, 0x3F, 0xFF, 0xFE, 0x34, 0x10, 
0x0F, 0x8D, 0xA2, 0x00, 0x00, 0x00, 0x3C, 0x4D, 0x00, 0x9C, 0x00, 0x00, 0x00, 0x00, 0x30, 
0x00, 0x0F, 0x8D, 0x00, 0x00, 0xC0, 0x3C, 0x3A, 0xDE, 0x18, 0x4E, 0x3A, 0xFD, 0x00, 0x9F, 
0x00, 0x03, 0xEB, 0xC1, 0x3A, 0xDE, 0x18, 0xAC, 0x3A, 0xFD, 0x00, 0xA2, 0x00, 0x03, 0xEB, 
0xC1, 0x3A, 0xDD, 0x01, 0x94, 0x3A, 0xFD, 0x00, 0xA5, 0x00, 0x03, 0xEB, 0xC1, 0x34, 0x00, 
0x0D, 0xC4, 0x00, 0x40, 0x00, 0x00, 0x3C, 0x6D, 0x00, 0xF3, 0x34, 0x10, 0x0D, 0xCB, 0x34, 
0x00, 0x0D, 0xC9, 0x34, 0x80, 0x0D, 0xC1, 0x35, 0x00, 0x0D, 0xFD, 0x34, 0x70, 0x0D, 0xF5, 
0x00, 0x78, 0x00, 0x00, 0x3C, 0x1D, 0x00, 0xB2, 0x32, 0x10, 0x0D, 0xDA, 0xB0, 0x50, 0x60, 
0x00, 0xA0, 0x00, 0x60, 0x00, 0x30, 0x80, 0x0D, 0xD6, 0x14, 0x90, 0x00, 0x00, 0x00, 0x03, 
0xC0, 0x18, 0x30, 0x20, 0x0D, 0xC9, 0x00, 0x00, 0x80, 0x00, 0x30, 0x80, 0x0D, 0xC8, 0x39, 
0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x06, 0x32, 0x10, 0x0D, 0xD5, 0x34, 0x00, 0x0F, 0x88, 
0x32, 0x10, 0x0D, 0xD7, 0x34, 0x00, 0x0D, 0xFD, 0x32, 0x10, 0x0D, 0xD8, 0x34, 0x00, 0x0D, 
0xF2, 0x32, 0x10, 0x0D, 0xD9, 0xB0, 0x03, 0xD0, 0x81, 0x38, 0x80, 0x0D, 0xD5, 0x36, 0xDE, 
0x00, 0x41, 0x3A, 0xFD, 0x00, 0xC6, 0x00, 0x03, 0xEB, 0xC1, 0x00, 0x40, 0x00, 0x00, 0x3C, 
0x1D, 0x00, 0xF3, 0x30, 0x00, 0x0D, 0xC7, 0x34, 0x20, 0x0D, 0xC4, 0x3A, 0xDD, 0x00, 0xF3, 
0x00, 0x00, 0xB0, 0x82, 0x30, 0x20, 0x0D, 0xC4, 0x3A, 0xDE, 0x18, 0xAC, 0x3A, 0xFD, 0x00, 
0xD0, 0x00, 0x03, 0xEB, 0xC1, 0x34, 0x00, 0x0D, 0xCA, 0x38, 0x10, 0x00, 0x02, 0x04, 0x40, 
0x00, 0x00, 0x3C, 0x1D, 0x00, 0xE1, 0x34, 0x00, 0x0D, 0xCA, 0x38, 0x10, 0x00, 0x05, 0x04, 
0x40, 0x00, 0x00, 0x3C, 0x1D, 0x00, 0xF3, 0x34, 0x00, 0x0D, 0xCB, 0x2E, 0x3F, 0xFF, 0xFE, 
0x34, 0x10, 0x0F, 0x8D, 0xA2, 0x00, 0x00, 0x00, 0x3C, 0x4D, 0x00, 0xF3, 0x00, 0x00, 0x00, 
0x00, 0x30, 0x00, 0x0F, 0x8D, 0x3A, 0xDD, 0x00, 0xF3, 0x00, 0x00, 0xC0, 0x3C, 0x34, 0x00, 
0x0D, 0xC4, 0x00, 0x40, 0x00, 0x00, 0x3C, 0x6D, 0x00, 0xF3, 0x34, 0x00, 0x0D, 0xC8, 0x32, 
0x10, 0x0D, 0xD6, 0x34, 0x00, 0x0D, 0xC9, 0x32, 0x10, 0x0D, 0xDA, 0x34, 0x00, 0x0D, 0xC7, 
0x38, 0x10, 0x00, 0x02, 0x38, 0x80, 0x0D, 0xD5, 0x36, 0xDE, 0x00, 0x41, 0x3A, 0xFD, 0x00, 
0xEE, 0x00, 0x03, 0xEB, 0xC1, 0x00, 0x40, 0x00, 0x00, 0x3C, 0x1D, 0x00, 0xF3, 0x34, 0x20, 
0x0D, 0xC4, 0x00, 0x00, 0xB0, 0xC2, 0x30, 0x20, 0x0D, 0xC4, 0x38, 0x00, 0x00, 0x0F, 0x32, 
0x10, 0x0D, 0xDB, 0x34, 0x00, 0x0D, 0xFD, 0x32, 0x10, 0x0D, 0xDE, 0x34, 0x00, 0x0D, 0xF2, 
0x32, 0x10, 0x0D, 0xDF, 0x34, 0x00, 0x0D, 0xF3, 0x2C, 0x00, 0x00, 0x0F, 0x32, 0x10, 0x0D, 
0xE8, 0x38, 0x00, 0x00, 0x00, 0x32, 0x10, 0x0D, 0xE9, 0x38, 0x00, 0x0D, 0xCF, 0x32, 0x10, 
0x0D, 0xE0, 0x34, 0x00, 0x0D, 0xFE, 0x32, 0x10, 0x0D, 0xE1, 0x34, 0x00, 0x0D, 0xFF, 0x32, 
0x10, 0x0D, 0xE2, 0x34, 0x00, 0x0D, 0xF1, 0x32, 0x10, 0x0D, 0xE3, 0x34, 0x00, 0x0F, 0x88, 
0x32, 0x10, 0x0D, 0xDD, 0x34, 0x00, 0x0D, 0xC1, 0x32, 0x10, 0x0D, 0xDC, 0x34, 0x00, 0x0D, 
0xF4, 0x32, 0x10, 0x0D, 0xE7, 0x34, 0x00, 0x0D, 0xCA, 0x32, 0x10, 0x0D, 0xE4, 0x34, 0x00, 
0x0D, 0xCC, 0x32, 0x10, 0x0D, 0xE5, 0x34, 0x00, 0x0D, 0xCD, 0x32, 0x10, 0x0D, 0xE6, 0x34, 
0x0D, 0x03, 0xD9, 0x38, 0x10, 0x00, 0x0C, 0x16, 0x43, 0xD1, 0x01, 0x18, 0x40, 0x00, 0x00, 
0x34, 0x10, 0x0D, 0xCE, 0x16, 0x43, 0xD3, 0x02, 0x3C, 0x1D, 0x01, 0x2C, 0x16, 0x53, 0xD4, 
0x03, 0x30, 0x20, 0x0D, 0xCE, 0x34, 0x0D, 0x03, 0xD8, 0x2C, 0x00, 0x00, 0x07, 0x2C, 0x30, 
0x00, 0x02, 0x3C, 0x3D, 0x01, 0x2C, 0x00, 0x00, 0x00, 0x00, 0x18, 0xD0, 0x00, 0x00, 0x30, 
0x20, 0x0D, 0xCE, 0x38, 0x00, 0x00, 0x02, 0x32, 0x10, 0x0D, 0xE3, 0x38, 0x07, 0xFF, 0xFF, 
0x32, 0x10, 0x0D, 0xE7, 0x38, 0x0E, 0x2B, 0xA9, 0x32, 0x10, 0x0D, 0xE0, 0x38, 0x0E, 0x2B, 
0xAF, 0x32, 0x10, 0x0D, 0xE1, 0x38, 0x0E, 0x2B, 0xB5, 0x32, 0x10, 0x0D, 0xE2, 0x34, 0x00, 
0x0D, 0xE8, 0x00, 0x40, 0x00, 0x00, 0x3C, 0x6D, 0x01, 0x32, 0x34, 0x00, 0x0D, 0xC4, 0x38, 
0x80, 0x0D, 0xDB, 0x06, 0x00, 0x00, 0x00, 0x34, 0x10, 0x0F, 0xFC, 0x00, 0x48, 0x00, 0x00, 
0x3C, 0x6D, 0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x38, 0x10, 0x00, 0x03, 0x38, 0x0F, 0xFF, 
0xFF, 0x34, 0x90, 0x0D, 0xC1, 0x35, 0x10, 0x0D, 0xFD, 0x34, 0x20, 0x0D, 0xCA, 0x00, 0x52, 
0x82, 0x0A, 0x3C, 0x6D, 0x01, 0x40, 0x39, 0x10, 0x00, 0x00, 0x2C, 0xA8, 0x00, 0x00, 0x00, 
0x03, 0xE0, 0x8C, 0x36, 0xD0, 0x0F, 0x8B, 0x3A, 0xFD, 0x01, 0x43, 0x00, 0x03, 0xEB, 0xC1, 
0x36, 0xDE, 0x00, 0x41, 0x3A, 0xFD, 0x01, 0x46, 0x00, 0x03, 0xEB, 0xC1, 0x30, 0x00, 0x0D, 
0xC5, 0x34, 0x00, 0x0D, 0xCE, 0x2C, 0x00, 0x00, 0x10, 0x3C, 0x1D, 0x01, 0x6A, 0x38, 0x00, 
0x00, 0x20, 0x32, 0x10, 0x0D, 0xE4, 0x38, 0x00, 0x00, 0x0B, 0x32, 0x10, 0x0D, 0xDB, 0x38, 
0x0E, 0x2B, 0xA9, 0x32, 0x10, 0x0D, 0xDC, 0x38, 0x0E, 0x2B, 0xAF, 0x32, 0x10, 0x0D, 0xDD, 
0x38, 0x0E, 0x2B, 0xB5, 0x32, 0x10, 0x0D, 0xDE, 0x38, 0x00, 0x00, 0x00, 0x32, 0x10, 0x0D, 
0xDF, 0x38, 0x00, 0x0D, 0xCF, 0x32, 0x10, 0x0D, 0xE0, 0x34, 0x00, 0x0D, 0xFE, 0x32, 0x10, 
0x0D, 0xE1, 0x34, 0x00, 0x0D, 0xFF, 0x32, 0x10, 0x0D, 0xE2, 0x34, 0x00, 0x0D, 0xF4, 0x32, 
0x10, 0x0D, 0xE5, 0x34, 0x0D, 0x03, 0xD8, 0x2C, 0x00, 0xC0, 0x00, 0x2E, 0x3F, 0xFF, 0xFE, 
0x34, 0x10, 0x0D, 0xF1, 0x2C, 0x41, 0xCF, 0xFF, 0x18, 0x08, 0x00, 0x00, 0x32, 0x50, 0x0D, 
0xE3, 0xB0, 0x03, 0xD1, 0x41, 0x38, 0x80, 0x0D, 0xDB, 0x36, 0xDE, 0x00, 0x41, 0x3A, 0xFD, 
0x01, 0x6A, 0x00, 0x03, 0xEB, 0xC1, 0x38, 0x00, 0x00, 0x01, 0x3A, 0xDE, 0x17, 0xC7, 0x3A, 
0xFD, 0x01, 0x6E, 0x00, 0x03, 0xEB, 0xC1, 0x36, 0xD0, 0x0F, 0x8C, 0x3A, 0xFD, 0x01, 0x71, 
0x00, 0x03, 0xEB, 0xC1, 0x3A, 0xDE, 0x18, 0xE5, 0x3A, 0xFD, 0x01, 0x74, 0x00, 0x03, 0xEB, 
0xC1, 0x34, 0x00, 0x0D, 0xCA, 0x2C, 0x30, 0x00, 0x05, 0x3C, 0x5D, 0x01, 0x7A, 0x12, 0x03, 
0xD0, 0x01, 0x30, 0x00, 0x0D, 0xCA, 0x30, 0x10, 0x0D, 0xCA, 0x38, 0x00, 0x00, 0x08, 0x32, 
0x1D, 0x03, 0xD4, 0x34, 0x00, 0x0D, 0xC6, 0x2C, 0x10, 0x05, 0x00, 0x34, 0x20, 0x0D, 0xC5, 
0x34, 0x10, 0x0D, 0xC4, 0x00, 0x4B, 0xD0, 0xC1, 0x3C, 0x1D, 0x01, 0x85, 0x0C, 0x50, 0x00, 
0x00, 0x18, 0x80, 0x00, 0x00, 0x2C, 0x10, 0x40, 0x00, 0x32, 0x1D, 0x03, 0xD5, 0x38, 0x0D, 
0x03, 0xD4, 0x32, 0x10, 0x0F, 0xFB, 0x34, 0x10, 0x0F, 0xC5, 0x2C, 0x40, 0x10, 0x00, 0x3C, 
0x1D, 0x01, 0x91, 0x34, 0x00, 0x0D, 0xC4, 0x00, 0x40, 0x00, 0x00, 0x3C, 0x1D, 0x01, 0x91, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x7C, 0x00, 0x00, 0xB0, 0x7C, 0x00, 0x03, 0xF0, 
0x2D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x00, 0x0F, 0xC5, 0x00, 0x00, 
0xD1, 0x61, 0x3C, 0x1D, 0x01, 0xAE, 0x34, 0x0D, 0x03, 0xD9, 0x2C, 0x00, 0x07, 0x00, 0x2E, 
0x30, 0x00, 0x04, 0x2C, 0x10, 0x00, 0x10, 0x32, 0x1D, 0x03, 0xDD, 0x34, 0x00, 0x0D, 0xC1, 
0x32, 0x1D, 0x03, 0xF3, 0x34, 0x30, 0x0D, 0xCB, 0x30, 0x3D, 0x03, 0xDE, 0x38, 0x20, 0x0B, 
0xFC, 0xB6, 0x90, 0x00, 0x00, 0x30, 0x2D, 0x03, 0xDF, 0x2E, 0xCF, 0xFA, 0x06, 0x2E, 0xDA, 
0xAA, 0xAB, 0x3B, 0x80, 0x00, 0x00, 0x2C, 0xCF, 0xFF, 0xFE, 0x00, 0x00, 0xD0, 0x0F, 0x3C, 
0x1D, 0x01, 0xAC, 0x38, 0x0D, 0x00, 0x1B, 0x32, 0x10, 0x0F, 0xF9, 0x14, 0xD8, 0x00, 0x00, 
0x3B, 0x80, 0x00, 0x01, 0x30, 0x3D, 0x03, 0xF6, 0x00, 0x03, 0xF0, 0x2D, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x00, 0x0F, 0x8D, 0x00, 0x43, 0xC3, 0xC0, 0x3C, 0x4D, 
0x01, 0xBB, 0x34, 0x10, 0x0D, 0xC2, 0x04, 0x08, 0x00, 0x00, 0x3C, 0x6D, 0x01, 0xB1, 0x38, 
0x00, 0x00, 0x07, 0x32, 0x10, 0x0D, 0xC6, 0x3A, 0xDD, 0x02, 0x16, 0x00, 0x00, 0x00, 0x00, 
0x34, 0x00, 0x0D, 0xC0, 0x3A, 0xDD, 0x02, 0x1A, 0x3A, 0xFD, 0x01, 0xBF, 0x00, 0x03, 0xEB, 
0xC1, 0x2E, 0x0F, 0xFF, 0xF6, 0x38, 0x10, 0x00, 0x01, 0x20, 0x40, 0x00, 0x00, 0x30, 0x00, 
0x0D, 0xE1, 0x34, 0x00, 0x0D, 0xC0, 0x32, 0x10, 0x0D, 0xDC, 0x34, 0x00, 0x0F, 0x88, 0x32, 
0x10, 0x0D, 0xDD, 0x31, 0x60, 0x0D, 0xDE, 0x34, 0x00, 0x0D, 0xF2, 0x32, 0x10, 0x0D, 0xDF, 
0x38, 0x00, 0x00, 0x00, 0x32, 0x10, 0x0D, 0xE0, 0x38, 0x80, 0x0D, 0xDB, 0xB0, 0x03, 0xD2, 
0x01, 0x3A, 0xDE, 0x19, 0x92, 0x3A, 0xFD, 0x01, 0xD1, 0x00, 0x03, 0xEB, 0xC1, 0x00, 0x43, 
0xC5, 0x91, 0x34, 0x90, 0x0F, 0x87, 0x3C, 0x6D, 0x02, 0x13, 0x38, 0x00, 0x00, 0x01, 0x32, 
0x10, 0x0D, 0xC6, 0xBD, 0xB0, 0x00, 0x00, 0x30, 0x90, 0x0D, 0xC1, 0x38, 0x00, 0x00, 0x05, 
0x32, 0x10, 0x0D, 0xDB, 0x30, 0x90, 0x0D, 0xDC, 0x34, 0x00, 0x0F, 0x88, 0x32, 0x10, 0x0D, 
0xDD, 0x31, 0x60, 0x0D, 0xDE, 0x34, 0x00, 0x0D, 0xF2, 0x32, 0x10, 0x0D, 0xDF, 0x38, 0x80, 
0x0D, 0xDB, 0xB0, 0x03, 0xD0, 0x41, 0x36, 0xDE, 0x00, 0x41, 0x3A, 0xFD, 0x01, 0xE5, 0x00, 
0x03, 0xEB, 0xC1, 0x39, 0x80, 0x00, 0x02, 0x30, 0x00, 0x0D, 0xC6, 0x00, 0x43, 0x60, 0x02, 
0x3C, 0x6D, 0x02, 0x10, 0x39, 0x80, 0x00, 0x03, 0x34, 0x00, 0x0D, 0xF5, 0x30, 0x20, 0x0D, 
0xCB, 0x00, 0x43, 0xD0, 0x06, 0x3C, 0x1D, 0x01, 0xF1, 0x00, 0x03, 0x60, 0x01, 0x30, 0x10, 
0x0D, 0xC9, 0x13, 0xB0, 0x00, 0x00, 0x39, 0x10, 0x00, 0x00, 0x39, 0x80, 0x00, 0x04, 0x00, 
0x02, 0xA0, 0x07, 0x30, 0x7D, 0x03, 0xD8, 0x00, 0x00, 0x80, 0x00, 0x38, 0x9D, 0x03, 0xD9, 
0x3E, 0x00, 0x00, 0x04, 0x00, 0x06, 0x51, 0xCF, 0x34, 0x00, 0x0D, 0xFD, 0x22, 0x13, 0xC5, 
0x91, 0x34, 0x90, 0x0D, 0xC1, 0x0D, 0x90, 0x00, 0x00, 0x00, 0x03, 0xC0, 0x99, 0x38, 0x15, 
0x00, 0x00, 0x34, 0x20, 0x0D, 0xCB, 0x42, 0x98, 0x80, 0x08, 0x00, 0x00, 0x00, 0x00, 0x30, 
0x90, 0x0D, 0xC0, 0x34, 0x00, 0x0D, 0xC1, 0x3A, 0xDD, 0x02, 0x1A, 0x3A, 0xFD, 0x02, 0x07, 
0x00, 0x03, 0xEB, 0xC1, 0xB0, 0xC0, 0x00, 0x00, 0x3C, 0x4D, 0x02, 0x0C, 0x00, 0x00, 0x00, 
0x00, 0x30, 0x00, 0x0F, 0x8D, 0x00, 0x00, 0xC0, 0x3C, 0x39, 0x10, 0x00, 0x00, 0x00, 0x03, 
0xF0, 0x2D, 0x31, 0x10, 0x0D, 0xC4, 0x30, 0xF0, 0x0D, 0xC3, 0x3A, 0xDD, 0x02, 0x14, 0x34, 
0x00, 0x0D, 0xC1, 0x32, 0x10, 0x0D, 0xC0, 0x30, 0x90, 0x0D, 0xC0, 0x38, 0x00, 0x03, 0x80, 
0x32, 0x10, 0x0D, 0xCB, 0x39, 0x10, 0x00, 0x00, 0x00, 0x03, 0xF0, 0x2D, 0x38, 0x00, 0x00, 
0x01, 0x32, 0x10, 0x0D, 0xC4, 0x00, 0x00, 0xC4, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 
0xC3, 0x81, 0x34, 0x20, 0x0F, 0x8D, 0xB0, 0x40, 0xB4, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x3C, 
0x2D, 0x02, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xC5, 0x81, 0xA2, 0x00, 0x00, 0x00, 
0x00, 0x03, 0xF0, 0x2D, 0xA0, 0x90, 0x00, 0x00, 0xB0, 0x48, 0x00, 0x00, 0x34, 0x3D, 0x03, 
0xF2, 0x00, 0x00, 0xD0, 0x03, 0x3C, 0x6D, 0x02, 0x53, 0x38, 0x20, 0x0F, 0x3B, 0x30, 0x20, 
0x0D, 0xE9, 0x00, 0x00, 0xB0, 0x03, 0x30, 0x3D, 0x03, 0xF2, 0x00, 0x03, 0xE0, 0x01, 0x00, 
0x03, 0xE0, 0x41, 0x38, 0xB0, 0x0F, 0x3B, 0x3A, 0x80, 0x00, 0x12, 0x3A, 0xAD, 0x02, 0x35, 
0x38, 0x30, 0x00, 0x00, 0x00, 0x03, 0xE0, 0xDA, 0x00, 0x03, 0xE0, 0xDA, 0x39, 0xA0, 0x00, 
0x03, 0x38, 0xAD, 0x03, 0xF0, 0x38, 0xCD, 0x03, 0xE3, 0x3A, 0x80, 0x00, 0x03, 0x3A, 0xAD, 
0x02, 0x4F, 0x38, 0xB0, 0x0F, 0x3B, 0x00, 0x03, 0xF8, 0x81, 0x2E, 0x6F, 0xFF, 0xEC, 0x00, 
0x03, 0xCD, 0xA5, 0x00, 0x03, 0xF4, 0x80, 0x2E, 0x2F, 0xFF, 0xEC, 0x00, 0x03, 0xCD, 0xA1, 
0x3A, 0x80, 0x00, 0x04, 0x3A, 0xAD, 0x02, 0x4E, 0x38, 0x4F, 0xF0, 0x00, 0x2E, 0x20, 0x00, 
0x08, 0x00, 0x03, 0xC8, 0x43, 0x17, 0x18, 0x00, 0x00, 0x2E, 0x60, 0x00, 0x08, 0x00, 0x03, 
0xC9, 0x45, 0x17, 0x28, 0x00, 0x00, 0x2F, 0x7F, 0xFF, 0xF4, 0x00, 0x03, 0xC1, 0x5B, 0x38, 
0x50, 0x00, 0x00, 0x00, 0x01, 0xD6, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xD6, 0x1D, 
0x00, 0x03, 0xF0, 0x01, 0x00, 0x03, 0xF0, 0x00, 0x00, 0x03, 0xF0, 0x2D, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x03, 0xE0, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 
0x00, 0x01, 0x2F, 0x2F, 0x00, 0x21, 0x00, 0x00, 0x00, 0x2F, 0x00, 0x2F, 0x21, 0x00, 0x00, 
0x03, 0x04, 0x01, 0x09, 0x0A, 0x07, 0x0E, 0x0F, 0x10, 0x0D, 0x11, 0x00, 0x0D, 0x03, 0xF4, 
0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x91, 0xA2, 0xB3, 0xC5, 0x01, 0x45, 0x67, 
0x00, 0x00, 0x0D, 0x03, 0xFB, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0xE9, 0xEF, 
0xC6, 0x30, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF

};
static void NEARAPI SPIStart(void)
{
	BoardWriteGPIOReg(SPICLK, FALSE);
	Delay(100);
        
    BoardWriteGPIOReg(SPIENA, FALSE);
	Delay(100);
}

static void NEARAPI SPIStop(void)
{
	Delay(100);
	BoardWriteGPIOReg(SPIENA, TRUE);
}


static BYTE NEARAPI SPISendByte(BYTE data)
{
	BYTE Val;
	int i;

	Val = data;
	for(i=0; i<8; i++)
	{
		BoardWriteGPIOReg(SPICLK, TRUE);
		Delay(100); //ckw
		BoardWriteGPIOReg(SPIDO, (Val & 0x80 ? TRUE : FALSE)); //ckw
		Delay(100);
		BoardWriteGPIOReg(SPICLK, FALSE);
		Delay(100);
		if(BoardReadGPIOReg(SPIDI))
			Val = (Val << 1) | 0x01;
		else
			Val = (Val << 1);

	}
	return Val;
}
//ckw start
void FARAPI SPIReadBack(BYTE command, int numresult, BYTE *result)
{   
	int i;

	SPIStart();	
	SPISendByte(0x00);
	SPISendByte(0x00);
	SPISendByte(0x00);
	SPISendByte(command);
	SPISendByte(0x00);
	SPISendByte(0x00);
	for (i=0;i<numresult-1;i++)
		result[i] = SPISendByte(0x00);
	result[i] = SPISendByte(0x80);
	
	SPISendByte(0x80);
	SPISendByte(0x80);
	SPIStop();
	
	return;
}
//ckw end	
BYTE FARAPI SPISendSeq(int Num, BYTE *Data)
{
	int i;
	BYTE b; //ckw

	SPIStart();

	SPISendByte(0x00);
	SPISendByte(0x00);
	SPISendByte(0x00);
    
    SPISendByte(Data[0]); //ckw
	for(i=1; i<Num; i++) //ckw
	{
//ckw start
		b = SPISendByte(Data[i]);
		if ((b  != 0x80) && ((Num-i-1) + 3 != b))
		{
			Delay(100);
			BoardWriteGPIOReg(SPIENA, TRUE);
                        DebugPrint((DebugLevelError, "AC3:Wrong number of args\n"));
		}
//ckw end
	}
	SPISendByte(0x00);
	SPISendByte(0x80);
	b = SPISendByte(0x80); //ckw
	SPIStop();
//ckw start
	switch (b & 3)
		{
		case 1:
                        DebugPrint((DebugLevelError, "AC3:Invalid OPCODE!!\n"));
                        break;
		case 2:
                        DebugPrint((DebugLevelError, "AC3:Invalid Parameters!!\n"));
                        break;
                        DebugPrint((DebugLevelError, "AC3:Device not ready!!\n"));
                        break;
		}
//ckw end
	return TRUE;
}


BOOL FARAPI InitAC3Decoder(void)
{
//ckw start	
	char dbgstr[80];
	BYTE ver[4];
	DWORD version;
    int i;
	BoardWriteAudio(AUD_BBE, 0x01);
	BoardWriteAudio(AUD_DEM, 0x00);
	BoardWriteAudio(AUD_DIF, 0x01);
	BoardWriteAudio(AUD_DIV, 0x02);
	BoardWriteAudio(AUD_EXT, 0x00);
	BoardWriteAudio(AUD_FOR, 0x00);
	BoardWriteAudio(AUD_ISS, 0x03);
	BoardWriteAudio(AUD_LCA, 0x00);
	BoardWriteAudio(AUD_RCA, 0x00);
	BoardWriteAudio(AUD_LRP, 0x00);
	BoardWriteAudio(AUD_ORD, 0x00);
	BoardWriteAudio(AUD_P18, 0x01);
	BoardWriteAudio(AUD_SCP, 0x00);
	BoardWriteAudio(AUD_SEM, 0x00);
	BoardWriteAudio(AUD_SFR, 0x00);
	BoardWriteAudio(AUD_RST, 0x01);
	BoardWriteEPLD(INCTL, 0x01);
	BoardWriteVideo(CTL, 0x02);
	Delay(200);
	BoardWriteVideo(CTL, 0x00);

    BoardWriteEPLD(AUXCTL, 0x08);
	Delay(200);
	i = 0;
	do
	{
		BoardWriteEPLD(AUXCTL, 0x00);
		Delay(200);
		BoardWriteEPLD(AUXCTL, 0x08);
		Delay(200); 
		i++;                                          
		if(i>10)
        {
            DebugPrint((DebugLevelError,"Can not Boot AC3!!!!!!!"));
            break;
        }
    } while (!BootAC3());
	
	BoardWriteEPLD(AUXCTL, 0x08);
	Delay(200);
	SPIReadBack(0x81, 4, ver);	
	version = ((DWORD)(BYTE)(ver[0]) | ((DWORD)(BYTE)(ver[1]) << 8) | ((DWORD)(BYTE)(ver[2]) << 16) | ((DWORD)(BYTE)(ver[3]) << 24));
        DebugPrint((DebugLevelError, "AC3:Version = %lu!!\n",version));
	SPISendSeq(PARAMSIZE, CfgParams);
	SPISendSeq(PARAMSIZE, AC3Params);
	AC3Command(AC3_STOP); //ckw
//ckw end
	return TRUE;
}

//ckw start
void FARAPI AC3Command(BYTE command)
{
	SPISendSeq(1, &command); //ckw
}
//ckw end

void FARAPI SendAC3Data(BYTE *Data, DWORD Size)
{
	DWORD i, PoReg;
	PoReg = 0x00B00000;

	for(i=0; i<Size; i++)
	{
//		HostDisableIT();
		memOutDword(POSTOFFICEREG, PoReg|Data[i]);
//        Delay(10);
		while(memInDword(POSTOFFICEREG)&02000000L);
//		HostEnableIT();
	}               
}

BOOL FARAPI BootAC3(void)
{
	int i,num=0; //ckw
	BYTE Val, b;
	BOOL fail = FALSE; //ckw

 
	SPIStart();
	b=SPISendByte(0);
	b=SPISendByte(0);
	b=SPISendByte(0);
	b=SPISendByte(0);

	num = 0;        

        i = 0;
        while(i < NUMCODE)
	{
                Val = AC3MCode[i];

        Delay(100);
		b = SPISendByte(Val);
		if ((num == 2 ) && (b != 0x05))
		{
			fail = TRUE;
		}
		num++;
                i++;
	}
	SPIStop();
	if(fail)
	{
                DebugPrint((DebugLevelError,"AC3 : Error Loading MicroCode!!\n"));
		return FALSE;
	}
	return TRUE;
}

//ckw start
void FARAPI AudioTransfer(BOOL flag)
{
	BoardWriteAudio(0xAE, (BYTE) flag);
	return;
}
//ckw end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgs\cpq3520a\bt856.h ===
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
// 	MODULE  : BT856.H
//	PURPOSE : Board specific code goes here
//	AUTHOR  : JBS Yadawa
// 	CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

#ifndef __BT856_H__
#define __BT856_H__
typedef enum tagStd {
	NTSC_PLAY = 0,
	NTSC_TEST,
	NTSC_EXT,
	NTSC_CAPT,
	PAL_PLAY,
	PAL_TEST,
	PAL_EXT,
	PAL_CAPT
} VSTANDARD;
void FARAPI BTInitEnc(void);
void FARAPI BTSetVideoStandard(VSTANDARD std);
#endif// __BT856_H__

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgs\cpq3520a\board.h ===
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
// 	MODULE  : BOARD.H
//	PURPOSE : Board specific code goes here
//	AUTHOR  : JBS Yadawa
// 	CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

#ifndef __BOARD_H
#define __BOARD_H
// BOARD.H

#include "stdefs.h"

#ifdef __cplusplus
extern "C" {
#endif

#define AXREQ 	0x00
#define STIREQ 0x01	
#define STIRST 0x02
#define SRESET 0x03
#define SPIEN	0x04
#define SPICLK 0x05
#define SPIDI  0x06
#define SPIDO  0x07


typedef struct tagBoard {
	BYTE 	prevAdr;
	BYTE 	gpio;
	BYTE	itm;
} BOARD, FARPTR *PBOARD;
	
PBOARD FARAPI BoardOpen(DWORD_PTR lLocalIOBaseAddress);
BYTE FARAPI BoardReadAudio(BYTE Register);
BYTE FARAPI BoardReadVideo(BYTE Register);
void FARAPI BoardWriteAudio(BYTE Register, BYTE Value);
void FARAPI BoardWriteVideo(BYTE Register, BYTE Value);
void FARAPI BoardSendAudio(LPBYTE Buffer, WORD Size);
void FARAPI BoardSendVideo(LPWORD Buffer, WORD Size);
void FARAPI BoardAudioSetSamplingFrequency(DWORD Frequency);
void FARAPI BoardVideoSetDisplayMode(BYTE Mode);
void FARAPI BoardEnterInterrupt(void);
void FARAPI BoardLeaveInterrupt(void);
void FARAPI BoardDisableIRQ(void);
void FARAPI BoardEnableIRQ(void);
void FARAPI BoardWriteEPLD(BYTE Reg, BYTE Data);
BOOL FARAPI BoardClose(void);
BOOL FARAPI BoardReadGPIOReg(BYTE Bit);
void FARAPI BoardWriteGPIOReg(BYTE Bit, BOOL Val);
BOOL FARAPI BoardHardReset(void);
void FARAPI Delay(DWORD Microseconds);
void FARAPI HostDisableIT(void);
void FARAPI HostEnableIT(void);
#ifdef __cplusplus
}
#endif
#endif // #ifndef __BOARD_H




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgs\cpq3520a\ddvptype.h ===
// this file includes all the data structures and guids, the minidriver
// needs, which are part of directdraw.

typedef struct _DDVIDEOPORTCONNECT
{
    DWORD dwSize;                               // size of the DDVIDEOPORTCONNECT structure
    GUID  guidTypeID;                   // Description of video port connection
    DWORD dwPortWidth;                  // Width of the video port
    DWORD dwFlags;                              // Connection flags
} DDVIDEOPORTCONNECT, * LPDDVIDEOPORTCONNECT;

/*
 * The FourCC code is valid.
 */
#define DDPF_FOURCC                             0x00000004l


/*
 * DDPIXELFORMAT
 */
typedef struct _DDPIXELFORMAT
{
    DWORD       dwSize;                 // size of structure
    DWORD       dwFlags;                // pixel format flags
    DWORD       dwFourCC;               // (FOURCC code)
    union
    {
	DWORD   dwRGBBitCount;          // how many bits per pixel (BD_1,2,4,8,16,24,32)
	DWORD   dwYUVBitCount;          // how many bits per pixel (BD_4,8,16,24,32)
	DWORD   dwZBufferBitDepth;      // how many bits for z buffers (BD_8,16,24,32)
	DWORD   dwAlphaBitDepth;        // how many bits for alpha channels (BD_1,2,4,8)
    };
    union
    {
	DWORD   dwRBitMask;             // mask for red bit
	DWORD   dwYBitMask;             // mask for Y bits
    };
    union
    {
	DWORD   dwGBitMask;             // mask for green bits
	DWORD   dwUBitMask;             // mask for U bits
    };
    union
    {                                                           
	DWORD   dwBBitMask;             // mask for blue bits
	DWORD   dwVBitMask;             // mask for V bits
    };
    union
    {
	DWORD   dwRGBAlphaBitMask;      // mask for alpha channel
	DWORD   dwYUVAlphaBitMask;      // mask for alpha channel
	DWORD   dwRGBZBitMask;          // mask for Z channel
	DWORD   dwYUVZBitMask;          // mask for Z channel
    };
} DDPIXELFORMAT, * LPDDPIXELFORMAT;

#define DDVPTYPE_E_HREFH_VREFH  \
	0x54F39980L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8

#define DDVPTYPE_E_HREFL_VREFL  \
	0xE09C77E0L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgs\cpq3520a\codedma.h ===
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
// 	MODULE  : CODEDMA.H
//	PURPOSE : Code dma code
//	AUTHOR  : JBS Yadawa
// 	CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

#ifndef __CODEDMA_H__
#define __CODEDMA_H__
#include "stdefs.h"

typedef struct DMADescriptor {
		DWORD			regionSize;
		DWORD			offset;
		WORD			selector;
		WORD			bufferID;
		DWORD			physical;
} DDS,  FARPTR * LPDDS;

typedef struct tagCodeDma {
   BYTE  FARPTR *  lpBuf;
	DWORD 		lpLog;
	DWORD 		CodeCtl;
	BOOL 		TransferCompleted;
	DWORD		WritePtr;
	DWORD		ReadPtr;
        DWORD           Last;
        DWORD           Prev;
        DWORD           Cur;
        BOOL            Transferring;
        BOOL            RefillRequest;

} CODEDMA,  FARPTR *PCODEDMA;

void FARAPI CodeDmaInterrupt(void);
BOOL FARAPI CodeDmaClose(void);
PCODEDMA CodeDmaOpen(BYTE FARPTR *, DWORD);
DWORD FARAPI CodeDmaSendData(BYTE FARPTR *pPacket, DWORD uLen);
void FARAPI CodeDmaStopTransfer(void);
BOOL FARAPI CodeDmaFlush(void);
void FARAPI CodeDmaRefill(void);
DWORD FARAPI CodeDmaSendDummy(void);

#endif //__CODEDMA_H__


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgs\cpq3520a\bt866.c ===
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
// 	MODULE  : BT866.C
//	PURPOSE : BrookTree Initialization code
//	AUTHOR  : JBS Yadawa
// 	CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

#include "strmini.h"
#include "stdefs.h"
#include "i2c.h"
#include "bt856.h"
#define BTI2CADR	0x88
#define I2CBYTECNT	10                         

static BYTE Seq1[3] = {0x60,0,0};
static BYTE Seq2[13] = {0x62,0,0,0,0,0,0,0,0,0,0,0,0};
static BYTE Seq3[3] = {0x80,0,0};
static BYTE Seq4[13] = {0x82,0,0,0,0,0,0,0,0,0,0,0,0};
static BYTE Seq5[3] = {0xa0,0,0};
static BYTE Seq6[13] = {0xa2,0,0,0,0,0,0,0,0,0,0,0,0};
static BYTE Seq7[4] = {0xc2,0,0,0};
static BYTE Seq8[2] = {0xc8,0xcc};
static BYTE Seq9[2] = {0xca,0x91};
static BYTE Seq10[2] = {0xcc,0x20};
static BYTE Seq11[10] = {0xce,0,0,0,0,0x58,0x59,0x3e,0xe0,0x02};
static BYTE Seq12[13] = {0xe0,0,0,0,0,0,0,0,0,0,0,0,0};


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : BTInitEnc
//	PARAMS	: None
//	RETURNS	: None
//
//	PURPOSE	: Initialize Video Encoder
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

void FARAPI BTInitEnc(void)
{
	I2CInitBus();
	I2CSettleBus();
}



//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : BTSetVideoStandard
//	PARAMS	: Stanadrd
//	RETURNS	: None
//
//	PURPOSE	: Program the PAL/NTSC encoder for write freq
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

void FARAPI BTSetVideoStandard(VSTANDARD std)
{                                    
	I2CSendSeq(BTI2CADR,3, Seq1); 
	I2CSendSeq(BTI2CADR,13, Seq2); 
	I2CSendSeq(BTI2CADR,3, Seq3); 
	I2CSendSeq(BTI2CADR,13, Seq4); 
	I2CSendSeq(BTI2CADR,3, Seq5); 
	I2CSendSeq(BTI2CADR,13, Seq6); 
	I2CSendSeq(BTI2CADR,4, Seq7); 
	I2CSendSeq(BTI2CADR,2, Seq8); 
	I2CSendSeq(BTI2CADR,2, Seq9); 
	I2CSendSeq(BTI2CADR,2, Seq10); 
	I2CSendSeq(BTI2CADR,10, Seq11); 
	I2CSendSeq(BTI2CADR,13, Seq12); 
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgs\cpq3520a\copyprot.h ===
void
CopyProtGetProp(PHW_STREAM_REQUEST_BLOCK pSrb);

void
CopyProtSetProp(PHW_STREAM_REQUEST_BLOCK pSrb);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgs\cpq3520a\codedma.c ===
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
// 	MODULE  : CODEDMA.C
//	PURPOSE : Compressed Data DMA Transfer
//	AUTHOR  : JBS Yadawa
// 	CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY: 
//	-----------------
//
// 	DATE 			: 	COMMENTS
//	----			: 	--------
//
//	12-28-96 	: 	Support of a large DMA buffer to do the dma of video
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

#include "strmini.h"
#include "stdefs.h"
#include "i20reg.h"
#include "codedma.h"
#include "sti3520A.h"
#include "board.h"
#include "memio.h"

// Static varables, gloabl to this file and only used here
static CODEDMA CodeDma;
static PCODEDMA lpCodeDma;

#define CODE_STEP_SIZE   8192L
#define DMA_BUFFER_SIZE  8192L

// Static functions 
BOOL NEARAPI InitCodeCtl(DWORD);
void NEARAPI StartTransfer(void);
void NEARAPI StopTransfer(void);
void NEARAPI FlushTransfer(void);
WORD NEARAPI GetTransferLocation(void);
DWORD NEARAPI  GetCodeMemBase(void);
DWORD NEARAPI GetCodeControlReg(void);
BOOL NEARAPI OpenCodeCtrl(void);

BOOL Initialized=FALSE;

BYTE 	RemainingBytes[4];
DWORD 	nRemainingBytes;
BYTE stop = 1;


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : CodeDmaOpen
//	PARAMS	: DMA Buffer and Physical Address of Dma Buffer
//	RETURNS	: Pointer to codedma
//
//	PURPOSE	: Initialise pointers and return the right values
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

PCODEDMA FARAPI CodeDmaOpen(BYTE FARPTR *pDmaBuf, DWORD PhysicalAddress)
{   

   lpCodeDma = &CodeDma;
   lpCodeDma->WritePtr = 0;
   lpCodeDma->ReadPtr = 0;
   lpCodeDma->Transferring = FALSE;
   lpCodeDma->RefillRequest=FALSE;
   lpCodeDma->TransferCompleted = TRUE;
   lpCodeDma->lpBuf = pDmaBuf;
   lpCodeDma->Prev = 0;
   lpCodeDma->Cur = 0;
   lpCodeDma->Last = 0;
   Initialized = TRUE;
	 nRemainingBytes = 0;
   if(InitCodeCtl(PhysicalAddress))
		return lpCodeDma;
	return NULL;

}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : CodeDmaFlush
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Flush any data in the dma buffer
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL FARAPI CodeDmaFlush(void)
{     
	StopTransfer();
	FlushTransfer();             
	lpCodeDma->WritePtr = 0;
	lpCodeDma->ReadPtr = 0;
  lpCodeDma->Prev = 0;
  lpCodeDma->Last = 0;
  lpCodeDma->Cur = 0;
	lpCodeDma->TransferCompleted = TRUE;
  lpCodeDma->Transferring = FALSE;
  lpCodeDma->RefillRequest=FALSE;
	nRemainingBytes = 0;
	return TRUE;
}		                         


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : CodeDmaClose
//	PARAMS	: None
//	RETURNS	: TRUE on success FALSE otherwise
//
//	PURPOSE	: reset state
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


BOOL FARAPI CodeDmaClose(void)
{
  Initialized = FALSE;
	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : InitCodeCtl
//	PARAMS	: Physical address
//	RETURNS	: TRUE on success FALSE otherwise
//
//	PURPOSE	: Program the code memory base pointers
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL NEARAPI InitCodeCtl(DWORD PhysicalAddress)
{
   lpCodeDma->CodeCtl = 0x00200002;
   memOutDword(I20_CODECTL, lpCodeDma->CodeCtl);
   memOutDword(I20_CODEMB, PhysicalAddress);
   memOutDword(I20_CODEMP, 0);
   return TRUE;
}   

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : StartTransfer
//	PARAMS	: None
//	RETURNS	: None
//
//	PURPOSE	: Start transferring the video data
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

void NEARAPI StartTransfer(void)
{
  lpCodeDma->Transferring = TRUE;
	lpCodeDma->CodeCtl |= 0x00000080;
	memOutDword(I20_CODECTL, lpCodeDma->CodeCtl);
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : StopTransfer
//	PARAMS	: None
//	RETURNS	: None
//
//	PURPOSE	: Stop transferring the video data
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

void NEARAPI StopTransfer(void)
{
	lpCodeDma->CodeCtl &= (~(0x00000080L));
	memOutDword(I20_CODECTL, lpCodeDma->CodeCtl);
  lpCodeDma->Transferring = FALSE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : FlushTransfer
//	PARAMS	: None
//	RETURNS	: None
//
//	PURPOSE	: Flush the buffer
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

void NEARAPI FlushTransfer(void)
{                      
	lpCodeDma->CodeCtl |= 0x10000000;
	memOutDword(I20_CODECTL, lpCodeDma->CodeCtl);
	lpCodeDma->CodeCtl &= (~0x10000000);
	memOutDword(I20_CODECTL, lpCodeDma->CodeCtl);
  memOutDword(I20_CODEMP,0);

}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : GetTransferLocation
//	PARAMS	: None
//	RETURNS	: CurrentTransferLocation
//
//	PURPOSE	: Get the codeMP
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

WORD NEARAPI GetTransferLocation(void)
{
	DWORD xx;
	xx = memInDword(I20_CODEMP);
	return (WORD)(xx&0xFFFF);
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : CodeDmaSendData
//	PARAMS	: Data pointer and size to transfer
//	RETURNS	: None
//
//	PURPOSE	: Write size bytes to dma buffer
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

DWORD FARAPI CodeDmaSendData(BYTE FARPTR *lpData, DWORD Size)
{
	DWORD dwBytesToSend;
	DWORD dwBytesNotSent;
	DWORD dwBytesSent;

  if((lpCodeDma->TransferCompleted)) // || ((DWORD)GetTransferLocation()*4L == DMA_BUFFER_SIZE))
	{

		StopTransfer();	
		dwBytesToSend = Size+nRemainingBytes;
		dwBytesNotSent = dwBytesToSend%4;
		dwBytesSent = dwBytesToSend - dwBytesNotSent;
//		DbgPrint("CodeDma : Size = %ld, ToSend=%ld, Sent=%ld, NotSent=%ld, Remaining=%ld\n", Size, dwBytesToSend, dwBytesSent, dwBytesNotSent, nRemainingBytes);
  	memOutDword(I20_CODEMP, (DWORD)(DMA_BUFFER_SIZE-dwBytesSent)/4L);
		if(nRemainingBytes)
			RtlCopyMemory(lpCodeDma->lpBuf+ ((DMA_BUFFER_SIZE) - dwBytesSent),
										RemainingBytes, nRemainingBytes);

		if(dwBytesSent > nRemainingBytes)
			RtlCopyMemory(lpCodeDma->lpBuf+((DMA_BUFFER_SIZE)+nRemainingBytes-dwBytesSent),
										lpData, dwBytesSent-nRemainingBytes);
		if(dwBytesNotSent)
			RtlCopyMemory(RemainingBytes, lpData+Size-dwBytesNotSent, dwBytesNotSent);
		nRemainingBytes = dwBytesNotSent;
		if(dwBytesSent)
		{
    		lpCodeDma->TransferCompleted = FALSE;
			StartTransfer();
		}
		return Size;
	}
	else
	{
		return 0;
	}


}


void FARAPI CodeDmaStopTransfer(void)
{
              StopTransfer();
}

void FARAPI CodeDmaStartTransfer(void)
{
           if(!lpCodeDma->Transferring)
              StartTransfer();
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : CodeDmaInterrupt
//	PARAMS	: None
//	RETURNS	: None
//
//	PURPOSE	: Process the codedma interrupt
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

void FARAPI CodeDmaInterrupt(void)
{
    lpCodeDma->TransferCompleted = TRUE;
	  StopTransfer();
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : CodeDmaRefill
//	PARAMS	: None
//	RETURNS	: None
//
//	PURPOSE	: Refill the dma buffers
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

void FARAPI CodeDmaRefill(void)
{
 	
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgs\cpq3520a\copyprot.c ===
#include "strmini.h"
#include <windef.h>
#include "ks.h"
#include <wingdi.h>
#include "ksmedia.h"
#include "copyprot.h"
#include "stdefs.h"


/*
** CopyProtSetProp ()
**
**   Set property handling routine for the Copy Protection on any pin
**
** Arguments:
**
**   pSrb -> property command block
**   pSrb->CommandData.PropertyInfo describes the requested property
**
** Returns:
**
** Side Effects:
*/

void
CopyProtSetProp(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	switch(pSrb->CommandData.PropertyInfo->Property->Id)
	{
	case KSPROPERTY_DVDCOPY_CHLG_KEY:

		//
		// set property for challenge key.  This provides the dvd drive
		// challenge key for the decoder
		//

		(PKS_DVDCOPY_CHLGKEY)(pSrb->CommandData.PropertyInfo->PropertyInfo);
		break;

	case KSPROPERTY_DVDCOPY_DVD_KEY1:

		//
		// set DVD Key1 provides the dvd drive bus key 1 for the decoer
		//
		(PKS_DVDCOPY_BUSKEY)(pSrb->CommandData.PropertyInfo->PropertyInfo);

		break;

	case KSPROPERTY_DVDCOPY_TITLE_KEY:

		//
		// set DVD title key, provides the dvd drive title key to the decoder
		//

		(PKS_DVDCOPY_TITLEKEY)(pSrb->CommandData.PropertyInfo->PropertyInfo);

		break;

	case KSPROPERTY_DVDCOPY_DISC_KEY:

		//
		// set the DVD disc key.  provides the dvd disc key to the decoder
		//

		(PKS_DVDCOPY_DISCKEY)(pSrb->CommandData.PropertyInfo->PropertyInfo);

		break;

	default:

		pSrb->Status = STATUS_NOT_IMPLEMENTED;
		return;
	}

	pSrb->Status = STATUS_SUCCESS;
}


/*
** CopyProtGetProp ()
**
**   get property handling routine for the CopyProt encoder pin
**
** Arguments:
**
**   pSrb -> property command block
**   pSrb->CommandData.PropertyInfo describes the requested property
**
** Returns:
**
** Side Effects:
*/

void
CopyProtGetProp(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	switch(pSrb->CommandData.PropertyInfo->Property->Id)
	{
	case KSPROPERTY_DVDCOPY_CHLG_KEY:

		//
		// get property for challenge key.  This provides the dvd drive
		// with the challenge key FROM the decoder
		//

		(PKS_DVDCOPY_CHLGKEY)(pSrb->CommandData.PropertyInfo->PropertyInfo);
		break;

	case KSPROPERTY_DVDCOPY_DEC_KEY2:

		//
		// get DVD Key2 provides the dvd drive with bus key 2 from the decoer
		//
		(PKS_DVDCOPY_BUSKEY)(pSrb->CommandData.PropertyInfo->PropertyInfo);

		break;

	case KSPROPERTY_DVDCOPY_REGION:

		//
		// indicate region 1 for US content
		//

		((PKS_DVDCOPY_REGION)(pSrb->CommandData.PropertyInfo->PropertyInfo))->RegionData
			= 0x1;


		pSrb->ActualBytesTransferred = sizeof (KS_DVDCOPY_REGION);

		break;


	default:

		pSrb->Status = STATUS_NOT_IMPLEMENTED;
		return;
	}

	pSrb->Status = STATUS_SUCCESS;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgs\cpq3520a\i2c.h ===
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
// 	MODULE  : I2C.H
//	PURPOSE : I2C Interface
//	AUTHOR  : JBS Yadawa
// 	CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

#ifndef __I2C_H__
#define __I2C_H__
void FARAPI I2CInitBus(void);
void FARAPI I2CSendSeq(WORD unit, WORD num, BYTE  *data);
void FARAPI I2CSettleBus(void);
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgs\cpq3520a\i20reg.h ===
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
// 	MODULE  : I20REG.H
//	PURPOSE : PCI Registers
//	AUTHOR  : JBS Yadawa
// 	CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

#ifndef __I20REG_H__
#define __I20REG_H__

#define ZVENDOR_ID 	0x11de
#define ZDEVICE_ID	0x6120
#define ADRSPACE		0x1000
#define INCTL			0x01
#define AUXCTL			0x02          

#define I20_GPREG	0x28
#define I20_GBREG	0x2C

#define I20_CODECTL	0x34
#define I20_CODEMP	0x38
#define I20_CODEMB	0x30

#define I20_INTRSTATUS  0x3F
#define I20_INTRCTRL    0x40
#define IFLAG_CODEDMA	0x10
#define IFLAG_GIRQ1		0x40
#define IFLAG_GIRQ0		0x20


#endif //__I20REG_H__

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgs\cpq3520a\hwcodec.h ===
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
// 	MODULE  : DMPEG.H
//	PURPOSE : Lowlevel Entry point
//	AUTHOR  : JBS Yadawa
// 	CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

#ifndef __DMPEG_H__
#define __DMPEG_H__
#include "sti3520a.h"
#include "zac3.h"
#include "board.h"
#include "codedma.h"
typedef enum tagCodecState {
	codecPowerUp,
	codecFillData,
	codecPlaying,
	codecPaused,
	codecStopped,
	codecErrorRecover,
	codecStillDecode,
	codecWaitingForLastFrame,
	codecEOS	
} CODECSTATE;

typedef struct tagHwCodec {
	PVIDEO		pVideo;
	PAC3			pAc3;
	PBOARD		pBoard;
	PCODEDMA		pCodeDma;
	CODECSTATE 	state;
	DWORD			codecTimeStamp;
	BOOL 			codecSync;
	BOOL 			codecAudioData;
	BOOL 			codecVideoData;
	BOOL			waitForLastFrame;
} CODEC, FARPTR *PCODEC;
	
BOOL HwCodecOpen(ULONG_PTR,BYTE FARPTR *, DWORD);
BOOL HwCodecClose(VOID);
BOOL HwCodecPlay(VOID);
BOOL HwCodecPause(VOID);
BOOL HwCodecStop(VOID);
UINT HwCodecSendVideo(BYTE FARPTR *pPacket, DWORD uLen);
UINT HwCodecSendAudio(BYTE FARPTR *pPacket, DWORD uLen);
void HwCodecVideoReset(void);
BOOL HwCodecSeek(void);
void HwCodecReset(void);
void HwCodecAudioReset(void);
void HwCodecDisableIRQ();
void HwCodecEnableIRQ();
BOOL HwCodecInterrupt();
void HwCodecSetSixteenByNine();
void HwCodecSetFourByThree();
BOOL HwCodecStillDecode(void);
BOOL HwCodecAc3BypassMode(BOOL on);
BOOL HwCodecDecodeDataInBuffer(void);
BOOL HwCodecProcessDiscontinuity(void);
BOOL HwCodecFlushBuffer(void);
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgs\cpq3520a\i2c.c ===
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
// 	MODULE  : I2C.C
//	PURPOSE : I2C Interface
//	AUTHOR  : JBS Yadawa
// 	CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

#include "strmini.h"
#include "stdefs.h"
#include "memio.h"
#include "i2c.h"
#include "board.h"


#define I2CREG		0x44
#define SCL			0x01
#define SDA			0x02

BYTE i2cShadow;

void NEARAPI I2CSendBit(BOOL Data);
void NEARAPI I2CStart(void);
void NEARAPI I2CStop(void);
void NEARAPI I2CSendByte(BYTE data);
void NEARAPI I2CSendDataByte(BYTE data);
void NEARAPI I2CGetBit(BOOL  * data);
void NEARAPI I2CGetByte(BYTE  *data);
void NEARAPI I2CGetDataByte(BYTE  *data);

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : I2CInitBus
//	PARAMS	: Stanadrd
//	RETURNS	: None
//
//	PURPOSE	: Initailize I2C bus
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

void FARAPI I2CInitBus(void)
{
	i2cShadow = 0;
	i2cShadow = SDA;
	memOutByte(I2CREG, i2cShadow);
	i2cShadow |= SCL;
	memOutByte(I2CREG, i2cShadow);
	
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : I2CSettleBus
//	PARAMS	: Stanadrd
//	RETURNS	: None
//
//	PURPOSE	: Settle I2C bus
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

void FARAPI I2CSettleBus(void)
{
	int i;
	BOOL b;

	i2cShadow &= (~SDA);
	memOutByte(I2CREG, i2cShadow);
	Delay(50);
	i2cShadow &= (~SCL);
	i2cShadow = 0x00;
	memOutByte(I2CREG, i2cShadow);
	Delay(50);
	i2cShadow |= SCL;
	for(i=0; i<100; i++)
	{
		memOutByte(I2CREG, i2cShadow);
		Delay(50);
		memOutByte(I2CREG, i2cShadow);
		Delay(50);
	}
	i2cShadow |= SDA;
	memOutByte(I2CREG, i2cShadow);
	i2cShadow |= SCL;
	memOutByte(I2CREG, i2cShadow);
	Delay(50);
	b = memInByte(I2CREG);
	b = b >> 1;
	i = 0;
	while ((i < 2000) && (!b))
	{
		i2cShadow &= (!SCL);
		memOutByte(I2CREG, i2cShadow);
		i2cShadow |= SDA;
		memOutByte(I2CREG, i2cShadow);
		Delay(50);		
		i2cShadow |= SCL;
		memOutByte(I2CREG, i2cShadow);
		i2cShadow |= SDA;
		memOutByte(I2CREG, i2cShadow);
		Delay(50);		
		i++;
		b = memInByte(I2CREG) >> 1;
	}
	if(i >= 2000)
	{
//		MessageBox(GetFocus(), "I2C Bus is unstable!!","STHal", MB_OK);
	}
}


void NEARAPI I2CSendBit(BOOL Data)
{
	if(Data)
	{
		i2cShadow |= SDA;
		memOutByte(I2CREG, i2cShadow);
	}
	else
	{
		i2cShadow &= SCL;
		memOutByte(I2CREG, i2cShadow);
	}
	Delay(50);

	i2cShadow |= SCL;
	memOutByte(I2CREG, i2cShadow);
	Delay(50);
	i2cShadow &= SDA;
	memOutByte(I2CREG, i2cShadow);
	Delay(50);

}
extern volatile BYTE  *lpBase; 
volatile BYTE *i2cptr;

void NEARAPI I2CStart(void)
{   
	i2cShadow = 0;
	i2cShadow |= SDA;
	memOutByte(I2CREG, i2cShadow);
	i2cShadow |= SCL;
	memOutByte(I2CREG, i2cShadow);
	Delay(50);                           
	
	i2cShadow = memInByte(I2CREG);
	if(!(i2cShadow&(SDA|SCL)))
	{
//		MessageBox(GetFocus(), "I2C Bus Busy", "STHal", MB_OK);
	}
	i2cShadow &= SCL;
	memOutByte(I2CREG, i2cShadow);
	Delay(50);
	i2cShadow = 0x00;
	memOutByte(I2CREG, i2cShadow);
	Delay(50);
		
}

void NEARAPI I2CStop(void)
{
	i2cShadow &= SCL;
	memOutByte(I2CREG, i2cShadow);
	Delay(50);
	i2cShadow |= SCL;
	memOutByte(I2CREG, i2cShadow);
	Delay(50);
	i2cShadow |= SDA;
	memOutByte(I2CREG, i2cShadow);
	Delay(50);

}

void NEARAPI I2CSendByte(BYTE data)
{
	int i;
	for(i=7; i>=0; i--)
	{
		if(data & (1 << i))
			I2CSendBit(TRUE);
		else
			I2CSendBit(FALSE);
	}
}

void NEARAPI I2CSendDataByte(BYTE data)
{
	BOOL ack;
	I2CSendByte(data);
	I2CGetBit(&ack);
	if(ack)
	{
//		MessageBox(GetFocus(), "No Ack after send byte", "sthal", MB_OK);
	}
}

void NEARAPI I2CGetBit(BOOL  * data)
{
	i2cShadow |= SDA;
	memOutByte(I2CREG, i2cShadow);
	Delay(50);
	i2cShadow |= SCL;
	memOutByte(I2CREG, i2cShadow);
	Delay(50);
	i2cShadow = memInByte(I2CREG);
	Delay(50);
	i2cShadow &= SDA;
	memOutByte(I2CREG, i2cShadow);
	Delay(50);
	*data = (i2cShadow >> 1);	

}


void NEARAPI I2CGetByte(BYTE  *data)
{
	int 	i;
	BOOL	b;

	*data = 0x00;
	for (i = 7;  i >= 0;  i--)
	{
		I2CGetBit(&b);
		if(b)
			*data |= (1 << i);
	}
	
}

void NEARAPI I2CGetDataByte(BYTE  *data)
{
	I2CGetByte(data);
	I2CSendBit(TRUE);
}

void FARAPI I2CSendSeq(WORD unit, WORD num, BYTE  *data)
{
	WORD i;

	I2CStart();
	I2CSendDataByte((BYTE)(unit));
	for(i=0; i < num; i++)
	{
		I2CSendDataByte((BYTE)data[i]);
	}
	I2CStop();                                           
	
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgs\cpq3520a\hwcodec.c ===
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
// 	MODULE  : hwcodec.C
// 	PURPOSE : Entry point to lowlevel driver
// 	AUTHOR  : JBS Yadawa
// 	CREATED : 1/8/97
//
//
//	Copyright (C) 1996-1997 SGS-THOMSON Microelectronics
//
//	REVISION HISTORY:
//	-----------------
//
// 	DATE 			: 	COMMENTS
//	----			: 	--------
//
//	1-8-97		: 	Use of Codec Stuctures added - JBS
//	1-10-97		: 	Fixed bug releted to single frame decode - JBS
//	1-14-97		: 	Error Handling done - JBS
//	1-15-97		: 	Programming to 16/9 and 4/3 added - JBS
//	1-15-97		: 	AC3 bypass mode interface added
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

#include "strmini.h"
#include "stdefs.h"
#include "hwcodec.h"
#include "codedma.h"
#include "sti3520A.h"
#include "board.h"
//#include "error.h"
#include "memio.h"
#include "i20reg.h"
#include "zac3.h"
#include "trace.h"
#include "mpaudio.h"
#include "mpinit.h"

// static variables only used in this file
static CODEC Codec;
static PCODEC pCodec = NULL;

static BYTE tBuf[4096];
static BYTE hBuf[4] = {0x00, 0x00, 0x01, 0xB1};
void NEARAPI Ac3SPIReadBack(BYTE command, short numresult, BYTE *result);

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : HwCodecOpen
//	PARAMS	: Base address of the board, pointer to dma
//	RETURNS	: TRUE on success FALSE otherwise
//
//	PURPOSE	: Open video/ac3/audio/board/dma/memio
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


BOOL HwCodecOpen(ULONG_PTR Base, BYTE FARPTR *DmaBuf, DWORD adr1)
{
	BOOL Found=FALSE;
	pCodec = &Codec;
    DbgPrint("'HwCodecOpen:base=%p,dmabuf=%p,adr1=%x",Base,DmaBuf,adr1);//chieh
	
 	pCodec->pBoard = BoardOpen(Base);
	RtlZeroMemory(tBuf, 4096);
	BoardHardReset();
	BoardDisableIRQ();
	pCodec->pVideo = VideoOpen();
	pCodec->pAc3 = Ac3Open();
    pCodec->pCodeDma = CodeDmaOpen(DmaBuf, adr1);
	VideoInitDecoder();
    Ac3InitDecoder();
	BoardEnableIRQ();
	pCodec->state = codecPowerUp;
	pCodec->codecSync = FALSE;
	pCodec->codecAudioData = FALSE;
	pCodec->codecVideoData = FALSE;
	pCodec->waitForLastFrame = FALSE;
	HwCodecSeek();	
	VideoForceBKC(TRUE);
  return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : HwCodecClose
//	PARAMS	: None
//	RETURNS	: TRUE on success FALSE otherwise
//
//	PURPOSE	: Close video/ac3/audio/board/dma/memio
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL HwCodecClose(void)
{
	if(pCodec == NULL)
		return FALSE;

	BoardClose();
	VideoClose();
	Ac3Close();
	CodeDmaClose();
	pCodec = NULL;
	return TRUE;
	
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : HwCodecPlay
//	PARAMS	: Base address of the board, pointer to dma
//	RETURNS	: TRUE on success FALSE otherwise
//
//	PURPOSE	: Play
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL HwCodecPlay()
{
	if(pCodec == NULL)
		return FALSE;

	if (pCodec->state == codecPaused)
		Ac3Play();
		
	VideoPlay();
	pCodec->state = codecPlaying;

	if (fClkPause)
	{

		LastSysTime += GetSystemTime() - PauseTime;

	}

	fClkPause = FALSE;

	return TRUE;

}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : HwCodecReset
//	PARAMS	: None
//	RETURNS	: TRUE on success FALSE otherwise
//
//	PURPOSE	: Reset the codec
//
//
//--chieh use for stop stream (when close graphedit, reset board to clean tv)
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
extern DWORD CDMAadr;
extern BOOL NEARAPI InitCodeCtl(DWORD);
void HwCodecReset(void)
{
	CodeDmaFlush();
	BoardHardReset();
  VideoSeek();
	BoardDisableIRQ();
  InitCodeCtl((DWORD)CDMAadr);
	VideoInitDecoder();
	VideoForceBKC(TRUE);
  Ac3InitDecoder();
	BoardEnableIRQ();
	pCodec->state = codecPowerUp;
	pCodec->codecSync = FALSE;
	pCodec->codecAudioData = FALSE;
	pCodec->codecVideoData = FALSE;
}

void HwCodecAudioReset(void)
{
//	Ac3Reset();
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : HwCodecPause
//	PARAMS	: None
//	RETURNS	: TRUE on success FALSE otherwise
//
//	PURPOSE	: Pause
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL HwCodecPause(void)
{
	if (pCodec->state == codecPowerUp)
		return TRUE;

	VideoPause();
	Ac3Pause();

	fClkPause = TRUE;

	pCodec->state = codecPaused;
	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : HwCodecSeek
//	PARAMS	: None
//	RETURNS	: TRUE on success FALSE otherwise
//
//	PURPOSE	: Seek
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL HwCodecSeek(void)
{
	CodeDmaFlush();
	VideoSeek();
	pCodec->state = codecPowerUp;
	pCodec->codecSync = FALSE;
	pCodec->codecAudioData = FALSE;
	pCodec->codecVideoData = FALSE;
	return TRUE;
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : HwCodecProcessDisc
//	PARAMS	: None
//	RETURNS	: TRUE on success FALSE otherwise
//
//	PURPOSE	: Set the codec in still picture decode
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL HwCodecProcessDiscontinuity(void)
{

		MPTReset();
		MPTrace(mTraceVdisc);
		if(pCodec->state == codecPlaying)
		{
			HwCodecSeek();
			HwCodecPlay();
		}
		else
		{
			HwCodecSeek();
		}

		CCSendDiscontinuity();

		return TRUE;
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : HwCodecProcessDisc
//	PARAMS	: None
//	RETURNS	: TRUE on success FALSE otherwise
//
//	PURPOSE	: Set the codec in still picture decode
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL HwCodecFlushBuffer(void)
{
		MPTrace(mTraceEOS);
		CodeDmaSendData(tBuf, 40);
		return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : HwCodecStop
//	PARAMS	: None
//	RETURNS	: TRUE on success FALSE otherwise
//
//	PURPOSE	: Stop and reset
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL HwCodecStop(void)
{

	TraceDump();
	HwCodecPause();
	HwCodecReset();
	return TRUE;
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : HwCodecSendVideo
//	PARAMS	: None
//	RETURNS	: TRUE on success FALSE otherwise
//
//	PURPOSE	: Send the video data
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

UINT HwCodecSendVideo(BYTE FARPTR *pPacket, DWORD uLen)
{
  UINT ret;

	if(pCodec->pVideo->errorCode != errNoError) //pCodec->pVideo->state == codecErrorRecover)
	{
		CodeDmaFlush();
		VideoSeek();
		VideoPlay();
	}
	if(pCodec->state == codecPowerUp)
	{
	}
	ret = CodeDmaSendData(pPacket, uLen);

	if(!pCodec->codecVideoData)
	{
		pCodec->codecVideoData = TRUE;
	}

	pCodec->pVideo->sync = pCodec->codecSync =
	pCodec->codecVideoData & pCodec->codecAudioData;

	return ret;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : HwCodecSendAudio
//	PARAMS	: None
//	RETURNS	: TRUE on success FALSE otherwise
//
//	PURPOSE	: Send audio data
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

UINT HwCodecSendAudio(BYTE *pPacket, DWORD uLen)
{
	static ULONG lastfree= 0, cFree = 0;

   DWORD Free, Lvl;

	if(!pCodec->codecAudioData)
		pCodec->codecAudioData = TRUE;

	pCodec->pVideo->sync = pCodec->codecSync =
		pCodec->codecVideoData & pCodec->codecAudioData;

	VideoGetABL();
	Lvl = pCodec->pVideo->abl&0xFFF;
	Free = pCodec->pVideo->audioBufferSize - Lvl - 2;
	Free=Free << 8;
   if(Free > uLen)
      Free = uLen;
	 if(Free != 1)
	 {
		// Make it even
		Free = Free&0xFFFFFFFE;
		if(Free)
	   if(!Ac3SendData(pPacket, Free))
		{
        DbgPrint("'HwCodecSendAudio:Ac3SendData Fail\n");
			TRAP
		}
	 }
   return Free;


}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : HwCodecInterrupt
//	PARAMS	: None
//	RETURNS	: TRUE on success FALSE otherwise
//
//	PURPOSE	: Handle interrupts here
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL HwCodecInterrupt(void)
{
	BOOL bRet = FALSE;
	BYTE	I20Intr;

  I20Intr = memInByte(I20_INTRSTATUS);
  memOutByte(I20_INTRSTATUS, I20Intr);

	if(I20Intr & IFLAG_CODEDMA)
	{
		bRet = TRUE;
		CodeDmaInterrupt();
	}

	if(I20Intr & IFLAG_GIRQ1)
	{
		bRet = TRUE;
		VideoInterrupt();
	}
	if(0) //pCodec->pAc3->errorCount > 10)
	{
		DbgPrint("AC-3 Crashed, Hard Reset!!!\n");
		HwCodecPause();
		HwCodecReset();
		HwCodecPlay();
		pCodec->pAc3->errorCount = 0;
	}
	return bRet;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : HwCodecSetFourByThree
//	PARAMS	: None
//	RETURNS	: TRUE on success FALSE otherwise
//
//	PURPOSE	: set SRC for 4/3
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

void FARAPI HwCodecSetFourByThree()
{

	TRAP

	//
	// this should never be called.
	//

	// Maintain the same aspect Ratio
	// But Display 16:9 Image on 4/3
	VideoSetSRC(544, 720);
	VideoSwitchSRC(TRUE);
	VideoConvertSixteenByNineToFourByThree();
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : HwCodecSetSixteenByNine
//	PARAMS	: None
//	RETURNS	: TRUE on success FALSE otherwise
//
//	PURPOSE	: Set SRC for 16/9
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

void FARAPI	HwCodecSetSixteenByNine()
{
	VideoSwitchSRC(FALSE);
	VideoResetPSV();

}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : HwCodecEnableIRQ
//	PARAMS	: None
//	RETURNS	: TRUE on success FALSE otherwise
//
//	PURPOSE	: Enable IRQ on the codec
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

void HwCodecEnableIRQ()
{
   VideoUnmaskInterrupt();
   BoardEnableIRQ();
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : HwCodecDisableIRQ
//	PARAMS	: None
//	RETURNS	: TRUE on success FALSE otherwise
//
//	PURPOSE	: Disable codec interrupt
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

void HwCodecDisableIRQ()
{
   VideoMaskInterrupt();
   BoardDisableIRQ();
}



//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : HwCodecAc3BypasMode
//	PARAMS	: BOOL
//	RETURNS	: TRUE on success FALSE otherwise
//
//	PURPOSE	: Switch on ac3 bypassmode
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL HwCodecAc3BypassMode(BOOL on)
{
	if(on)
		Ac3SetBypassMode();
	else
		Ac3SetNormalMode();
	return TRUE;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgs\cpq3520a\memio.c ===
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
// 	MODULE  : MEMIO.C
//	PURPOSE : Memory mapped IO
//	AUTHOR  : JBS Yadawa
// 	CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


#include "strmini.h"
#include "stdefs.h"
#include <conio.h>
#include "memio.h"
#include "board.h"

volatile PUCHAR   lpBase = NULL;
volatile PUSHORT lpWordPtr = NULL;
volatile PULONG   lpDwordPtr = NULL;


BOOL FARAPI AllocMemoryBase(DWORD_PTR addr, DWORD memsize)
{
	lpBase = (PUCHAR)addr;
	lpWordPtr = (PUSHORT)addr;
	lpDwordPtr = (PULONG)addr;
	return TRUE;
}


BOOL FARAPI FreeMemoryBase(void)
{
	lpBase = NULL;
	return TRUE;
}


void FARAPI memOutByte(WORD reg, BYTE Val)
{
	WORD r;
	BYTE v;
	r = reg;
	v = Val;
	lpBase[r] = v;
}

void FARAPI memOutWord(WORD reg, WORD Val)
{
	lpWordPtr[reg>>1] = Val;
}

void FARAPI memOutDword(WORD reg, DWORD Val)
{
	WORD r;
	DWORD v;
	r = reg>>2;
	v = Val;
	lpDwordPtr[r] = v;
}

BYTE FARAPI memInByte(WORD reg)
{
	WORD r;
	BYTE v;
	r = reg;
	v = lpBase[r];
	return v;
}

WORD FARAPI memInWord(WORD reg)
{
	return lpWordPtr[reg>>1];
}

DWORD FARAPI memInDword(WORD reg)
{
	// Jbs - trying to slow it down
	DWORD v;
	WORD r;
	r = reg>>2;
	v = lpDwordPtr[r];
	return v;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgs\cpq3520a\mpst.h ===
///////////////////////////////////////////////////////////////////////////
//
//						File : mpst.h
//
//		 Prototype for mpst.c
//		 i/f between Miniport Layer and core driver
//
//
///////////////////////////////////////////////////////////////////////////
#ifndef __MPST_H__
#define __MPST_H__
#include "mpinit.h" 
typedef struct tagBusInfo
{
   ULONG 			NumberOfAccessRanges;         
   INTERFACE_TYPE AdapterInterfaceType; 
   USHORT 			VendorIdLength;              //   size in bytes of VendorId
	 PVOID  			VendorId;                    //   points to ASCII byte string identifying
   USHORT 			DeviceIdLength;              //   size in bytes of DeviceId
   PVOID  			DeviceId;                    //   points to ASCII byte string identifying
	 BOOLEAN 			NoDynamicRelocation;        // On dynamically configurable I/O busses, when set
} BUSINFO, *PBUSINFO;

typedef struct tagBoardInfo
{
	PUSHORT	ioBasePCI9060; // Eval3520 PCI Specific address
	PUSHORT	ioBaseLocal;  // Base address
	UCHAR   Irq;
} BOARDINFO, *PBOARDINFO;

BOOLEAN mpstDriverEntry (OUT PBUSINFO pBusInfo);
BOOLEAN mpstHwFindAdaptor (OUT PBOARDINFO pBoardInfo);
BOOLEAN mpstHwInitialize(PHW_DEVICE_EXTENSION pHwDevExt);
BOOLEAN mpstHwUnInitialize(VOID);
BOOLEAN mpstHwInterrupt(VOID);
VOID mpstEnableVideo (BOOLEAN bFlag);
ULONG mpstVideoPacket(PHW_STREAM_REQUEST_BLOCK pMrb);
VOID mpstVideoPause(VOID);
VOID mpstVideoPlay(VOID);
VOID mpstVideoStop(VOID);
ULONG mpstVideoDecoderBufferSize(VOID);
ULONG mpstVideoDecoderBufferFullness(VOID);
VOID mpstVideoReset(VOID);
VOID mpstEnableAudio (BOOLEAN bFlag);
ULONG mpstSendAudio(UCHAR *pData, ULONG uLen);
VOID mpstAudioPause(VOID);
VOID mpstAudioPlay(VOID);
VOID mpstAudioStop(VOID);
ULONG mpstAudioDecoderBufferSize(VOID);
ULONG mpstAudioDecoderBufferFullness(VOID);
VOID mpstAudioReset(VOID);
VOID portWritePortBuffer16(IN PUSHORT Port, IN PUSHORT Data, ULONG Size);
void mpstGetVidLvl(PHW_STREAM_REQUEST_BLOCK pSrb);
#endif // __MPST_H__


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgs\cpq3520a\memio.h ===
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
// 	MODULE  : MEMIO.H
//	PURPOSE : Memory Mapped IO
//	AUTHOR  : JBS Yadawa
// 	CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

#ifndef __MEMIO_H__
#define __MEMIO_H__

BOOL FARAPI AllocMemoryBase(DWORD_PTR addr, DWORD memsize);
BOOL FARAPI FreeMemoryBase(void);
void FARAPI memOutByte(WORD reg, BYTE Val);
void FARAPI memOutWord(WORD reg, WORD Val);
void FARAPI memOutDword(WORD reg, DWORD Val);
BYTE FARAPI memInByte(WORD reg);
BYTE FARAPI memInByte(WORD reg);
WORD FARAPI memInWord(WORD reg);
DWORD FARAPI memInDword(WORD reg);
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgs\cpq3520a\mpaudio.h ===
/*******************************************************************
*
*				 MPAUDIO.H
*
*				 Copyright (C) 1995 SGS-THOMSON Microelectronics.
*
*
*				 Prototypes for NPAUDIO.C
*
*******************************************************************/

#ifndef __MPAUDIO_H__
#define __MPAUDIO_H__
VOID miniPortAudioGetProperty(PHW_STREAM_REQUEST_BLOCK pSrb);
VOID miniPortAudioSetProperty(PHW_STREAM_REQUEST_BLOCK pSrb);
VOID miniPortAudioSetState(PHW_STREAM_REQUEST_BLOCK pSrb);
void mpstCommandComplete(PHW_STREAM_REQUEST_BLOCK pSrb);
VOID mpstCtrlCommandComplete(PHW_STREAM_REQUEST_BLOCK pSrb);
VOID AudioTimerCallBack(PHW_STREAM_OBJECT pstrm);
ULONG mpstAudioPacket(PHW_STREAM_REQUEST_BLOCK pSrb);
//void StubMpegEnableIRQ(PHW_STREAM_OBJECT pstrm);
//ULONG miniPortAudioStop (PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
//ULONG miniPortAudioSetStc(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
//ULONG miniPortAudioReset(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
//ULONG miniPortAudioSetAttribute(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
//ULONG miniPortAudioQueryInfo (PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
//ULONG miniPortAudioPlay(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
//ULONG miniPortAudioPause(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
VOID miniPortAudioPacket(PHW_STREAM_REQUEST_BLOCK pSrb);
//ULONG miniPortAudioGetStc(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
//ULONG miniPortAudioGetAttribute(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
//ULONG miniPortAudioEndOfStream(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
//ULONG miniPortAudioDisable(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
//ULONG miniPortAudioEnable(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
//ULONG miniPortCancelAudio(PHW_STREAM_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG GetStreamPTS(PHW_STREAM_OBJECT strm);
STREAMAPI StreamTimeCB(IN PHW_TIME_CONTEXT tc);
ULONGLONG GetSystemTime();
STREAMAPI StreamClockRtn(IN PHW_TIME_CONTEXT TimeContext);
ULONG ConvertStrmtoPTS(ULONGLONG strm);
ULONGLONG ConvertPTStoStrm(ULONG pts);
STREAMAPI
AudioEvent (PHW_EVENT_DESCRIPTOR pEvent);

extern BOOL fClkPause;
extern ULONGLONG LastSysTime;
extern ULONGLONG PauseTime;

#endif //__MPAUDIO_H__


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgs\cpq3520a\mpaudio.c ===
/*******************************************************************
*
*				 MPAUDIO.C
*
*				 Copyright (C) 1995 SGS-THOMSON Microelectronics.
*
*
*				 PORT/MINIPORT Interface Audio Routines
*
*******************************************************************/
#include "strmini.h"
//#include "mpst.h"
#include "mpinit.h"
#include "mpaudio.h"
#include "hwcodec.h"
#include "mpvideo.h"
#include "trace.h"
#include "copyprot.h"

BOOL fClkPause;
ULONGLONG LastSysTime = 0;
ULONGLONG PauseTime = 0;

static ULONGLONG LastStamp;
static ULONGLONG LastSys;
static BOOLEAN fValid;
extern BOOLEAN fProgrammed;
extern BOOLEAN fStarted;
BOOLEAN fProgrammed;
BOOLEAN fStarted;
static ULONGLONG StartSys;

ULONG miniPortAudioStop (PHW_STREAM_REQUEST_BLOCK pSrb, PHW_DEVICE_EXTENSION pHwDevExt);
void AudioPacketStub(PHW_STREAM_OBJECT pstrm);

//
// default to downmixed stereo output
//

ULONG audiodecoutmode = KSAUDDECOUTMODE_STEREO_ANALOG;

VOID miniPortAudioGetProperty(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	PHW_DEVICE_EXTENSION phwdevext =
		((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);


	switch(pSrb->CommandData.PropertyInfo->PropertySetID)
	{
		case 1:

			//
			// this is a copy protection property go handle it there
			//

			CopyProtGetProp(pSrb);
			break;

		case 0:

			//
			// this is audio decoder output property, handle it
			//

			pSrb->Status = STATUS_SUCCESS;

			switch(pSrb->CommandData.PropertyInfo->Property->Id)
			{
			case KSPROPERTY_AUDDECOUT_MODES:
		
				//
				// enumerate the supported modes
				//
		
				*(PULONG)(pSrb->CommandData.PropertyInfo->PropertyInfo) =
						KSAUDDECOUTMODE_STEREO_ANALOG | KSAUDDECOUTMODE_SPDIFF;
		
				pSrb->ActualBytesTransferred = sizeof (ULONG);
				break;
		
			case KSPROPERTY_AUDDECOUT_CUR_MODE:
		
				TRAP
		
				*(PULONG)(pSrb->CommandData.PropertyInfo->PropertyInfo) = audiodecoutmode;
				pSrb->ActualBytesTransferred = sizeof (ULONG);
			
				break;

			default:

				pSrb->Status = STATUS_NOT_IMPLEMENTED;
		
			}

			break;

		default:
		// invalid property

		TRAP

		pSrb->Status = STATUS_NOT_IMPLEMENTED;

		return;
	}

}

VOID miniPortAudioSetProperty(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	PHW_DEVICE_EXTENSION phwdevext =
		((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);

	pSrb->Status = STATUS_SUCCESS;

	switch(pSrb->CommandData.PropertyInfo->PropertySetID)
	{
	case 0:
		switch(pSrb->CommandData.PropertyInfo->Property->Id)
		{
	
		case KSPROPERTY_AUDDECOUT_CUR_MODE:
	
			if (*(PULONG)(pSrb->CommandData.PropertyInfo->PropertyInfo) != audiodecoutmode)
			{
				if ((*(PULONG)(pSrb->CommandData.PropertyInfo->PropertyInfo)) &    	
					(!(KSAUDDECOUTMODE_STEREO_ANALOG | KSAUDDECOUTMODE_SPDIFF)))
				{
					break;
				}
	
				HwCodecAc3BypassMode(*(PULONG)(pSrb->CommandData.PropertyInfo->PropertyInfo) &
					 KSAUDDECOUTMODE_SPDIFF);
	
				audiodecoutmode = *(PULONG)(pSrb->CommandData.PropertyInfo->PropertyInfo);
	
				return;
			}
		
			break;
	
		}
	
		pSrb->Status = STATUS_NOT_IMPLEMENTED;

	case 1:

		//
		// this is a copy protection property
		//

		CopyProtSetProp(pSrb);
		break;

	default:

		// invalid property

		pSrb->Status = STATUS_NOT_IMPLEMENTED;

		return;
	}


}

VOID miniPortAudioSetState(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	PHW_DEVICE_EXTENSION phwdevext =
		((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    DbgPrint("'miniPortAudioSetState:StreamState=%x\n",pSrb->CommandData.StreamState);

	switch (pSrb->CommandData.StreamState)
	{
	case KSSTATE_STOP:
//	     miniPortAudioStop(pSrb, phwdevext);//pause for now should be stop
//            HwCodecStop();
            phwdevext->AudioDeviceExt.DeviceState = KSSTATE_STOP;
			fProgrammed = fStarted = FALSE;
            break;


	case KSSTATE_PAUSE:
            //HwCodecAudioPause();//chieh
            phwdevext->AudioDeviceExt.DeviceState = KSSTATE_PAUSE;

			PauseTime = GetSystemTime();
			if (!fStarted)
			{
				fStarted = TRUE;
				LastStamp = 0;
				StartSys = LastSysTime = PauseTime;
			}

//			HwCodecPause();
            break;

	case KSSTATE_RUN:
//            HwCodecPlay();

			//
			// if the clock has not been programmed already, and we haven't
			// started the clock already, start it here.
			//

			if (!fStarted && !fProgrammed)
			{
				LastStamp = 0;
				StartSys = LastSysTime = GetSystemTime();
			}

			fStarted = TRUE;
            phwdevext->AudioDeviceExt.DeviceState = KSSTATE_RUN;
            break;

	}

	pSrb->Status = STATUS_SUCCESS;

}

ULONG miniPortAudioStop (PHW_STREAM_REQUEST_BLOCK pSrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;
	// TBC
	if(pHwDevExt->AudioDeviceExt.pCurrentSRB != NULL)
	{
		// Still to send a packet
		pHwDevExt->AudioDeviceExt.pCurrentSRB->Status = STATUS_CANCELLED;

		MPTrace(mTraceRdyAud);

		StreamClassStreamNotification(ReadyForNextStreamDataRequest,
				pHwDevExt->AudioDeviceExt.pCurrentSRB->StreamObject);
	
		StreamClassStreamNotification(StreamRequestComplete,
				pHwDevExt->AudioDeviceExt.pCurrentSRB->StreamObject,
				pHwDevExt->AudioDeviceExt.pCurrentSRB);


		//
		// request a timer callback
		//
	
		StreamClassScheduleTimer(pSrb->StreamObject, pSrb->HwDeviceExtension,
             0, AudioPacketStub, pSrb->StreamObject);


		pHwDevExt->AudioDeviceExt.pCurrentSRB =
		  pHwDevExt->pCurSrb = NULL;

	}

  DbgPrint("'miniPortAudioStop\n");
	pSrb->Status = STATUS_SUCCESS;
	return dwErrCode; 	
}

void AudioPacketStub(PHW_STREAM_OBJECT pstrm)
{
        AudioTimerCallBack(pstrm);
}
VOID miniPortAudioPacket(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	PHW_DEVICE_EXTENSION pHwDevExt =
	 ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);

        PAUDIO_DEVICE_EXTENSION paudex =
         &(((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension)->AudioDeviceExt);

	 //
	 // set up for initial parsing of the scatter gather packet.
	 //

         paudex->cPacket = 0;
         paudex->cOffs = PACK_HEADER_SIZE;
         paudex->pPacket = pSrb->CommandData.DataBufferArray;

         paudex->pCurrentSRB = pSrb;
			 MPTrace(mTraceAudio);

         AudioPacketStub(pSrb->StreamObject);

}


VOID AudioTimerCallBack(PHW_STREAM_OBJECT pstrm)
{
    PHW_DEVICE_EXTENSION pdevext = pstrm->HwDeviceExtension;
    PHW_STREAM_REQUEST_BLOCK pSrb;

	ULONG	uSent;
        PAUDIO_DEVICE_EXTENSION paudex = &(pdevext->AudioDeviceExt);

        pSrb = paudex->pCurrentSRB;

	if (!pSrb)
	{

		return;
	}

	do
	{
		if (paudex->pPacket->DataUsed)
		{
			uSent = mpstAudioPacket(pSrb);

			if (uSent)
			{
				fProgrammed = TRUE;
			}
		}
		else
		{
            if (paudex->pPacket->OptionsFlags &
		        KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY)
			{
              HwCodecAudioReset();
			}
			uSent = 1;
		}

                paudex->cOffs += uSent;

		//
		// check if we finished this packet.  If so, go on to the
		// next packet
		//

                if (paudex->cOffs >=
                        paudex->pPacket->DataUsed)
		{
                        paudex->pPacket++;



			//
			// reset the packet offset
			//

                        paudex->cOffs = PACK_HEADER_SIZE;
                        paudex->cPacket++;

			//
			// if we have finished all the packets, then we are done
			//

                        if (paudex->cPacket >=
				 pSrb->NumberOfBuffers)
			{

				pSrb->Status = STATUS_SUCCESS;
                                paudex->pCurrentSRB = 0;


								MPTrace(mTraceRdyAud);
                                 StreamClassStreamNotification(ReadyForNextStreamDataRequest,
                                         pSrb->StreamObject);

                                 StreamClassStreamNotification(StreamRequestComplete,
                                         pSrb->StreamObject,
                                                 pSrb);
	 			MPTrace(mTraceAudioDone);
				

				return;

			}
		}

	} while (uSent);

   StreamClassScheduleTimer(pstrm, pstrm->HwDeviceExtension,
               1, (PHW_PRIORITY_ROUTINE)AudioTimerCallBack, pstrm);


}



ULONG mpstAudioPacket(PHW_STREAM_REQUEST_BLOCK pSrb)
{
  PAUDIO_DEVICE_EXTENSION paudex =
     &(((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension)->AudioDeviceExt);
	ULONG	uLen;
  ULONG cPacket;
    PUCHAR SizePtr;
    ULONG ExtraBytes;
    ULONG retval;

  #define MAX_SIZE        8192

	//
	// find out how many bytes we can squeeze in
	//

     uLen = MAX_SIZE; //(BUF_FULL - VideoGetBBL()) * 256;

  SizePtr = (PUCHAR) ((ULONG_PTR) paudex->pPacket->Data + PACK_HEADER_SIZE + 4);
  ExtraBytes = paudex->pPacket->DataUsed - PACK_HEADER_SIZE -
             ((ULONG) (SizePtr[0] << 8) + (ULONG) SizePtr[1] + 4 + 2);

     cPacket = paudex->pPacket->DataUsed - paudex->cOffs - ExtraBytes;


	uLen = uLen > cPacket ? cPacket : uLen;

     if(uLen > MAX_SIZE)
              uLen = MAX_SIZE;

// AVSYNC BUG to be fixed here.
// Dont Latch PTS every time.

	if (uLen)
	{

		//
		// send the bytes that we can fit
		//

     retval = HwCodecSendAudio((LPBYTE)(((ULONG_PTR)paudex->pPacket->Data) + paudex->cOffs), uLen);

     if (retval == uLen) {

        return (retval + ExtraBytes);
     } else {

        return(retval);
     }

	}

	return uLen;	
}


STREAMAPI StreamClockRtn(IN PHW_TIME_CONTEXT TimeContext)
{
	ULONGLONG sysTime = GetSystemTime();
	ULONG foo;

	if (TimeContext->Function != TIME_GET_STREAM_TIME)
	{
		TRAP

		//
		// should handle set onboard, and read onboard clock here.
		//

		return (FALSE);
	}

	if (fClkPause)
	{
		TimeContext->Time = LastStamp + PauseTime - LastSysTime;

		return (TRUE);
	}

	//
	// update the clock 4 times a second, or once every 2500000 100 ns ticks
	//

	if (TRUE || (sysTime - LastSysTime) > 2500000 )
	{
		if (fProgrammed)
		{
			foo = Ac3GetPTS();
			LastStamp = ConvertPTStoStrm(2 * foo);
			DbgPrint("'new PTS: %X\n", foo);
		}
		else
		{
			LastStamp = (sysTime - StartSys);
		}

		LastSys = LastSysTime = sysTime;
		fValid = TRUE;
	}

	TimeContext->Time = LastStamp + (sysTime - LastSysTime);
	TimeContext->SystemTime = sysTime;
	DbgPrint("'return PTS: %X\n", TimeContext->Time);
    return (TRUE);
}


ULONGLONG GetSystemTime()
{
	ULONGLONG ticks;
	ULONGLONG rate;

	ticks = (ULONGLONG)KeQueryPerformanceCounter((PLARGE_INTEGER)&rate).QuadPart;

	//
	// convert from ticks to 100ns clock
	//

	ticks = (ticks & 0xFFFFFFFF00000000) / rate * 10000000 +
			(ticks & 0xFFFFFFFF) * 10000000 / rate;

	return(ticks);

}

STREAMAPI StreamTimeCB(IN PHW_TIME_CONTEXT tc)
{
	LastStamp = tc->Time;
	LastSys = tc->SystemTime;

	fValid = TRUE;
}

ULONG GetStreamPTS(PHW_STREAM_OBJECT strm)
{
	ULONG foo;

	if (!hClk)
	{
		return(0);
	}

	StreamClassQueryMasterClock(strm, hClk, TIME_GET_STREAM_TIME , StreamTimeCB);
	if (fValid)
	{
		foo = ConvertStrmtoPTS(LastStamp + GetSystemTime() - LastSys);
		DbgPrint("'STRM PTS: %x\n", foo);
		return(foo);
	}

	else
	{
		DbgPrint("'STRM PTS: 0");
		return(0);
	}
}


/////////////////////////////////////////////////////////////////////////
//
//			  Function : ConvertPTStoStrm
//			  Args : PTS
//			  Returns :
//
//			  Purpose:
//				converts a PTS to a Stream class 100 NS clock
//				
//
//			  Last Modified 10.1.96 by JBS
//
/////////////////////////////////////////////////////////////////////////


ULONGLONG ConvertPTStoStrm(ULONG pts)
{
	ULONGLONG strm;

	strm = (ULONGLONG)pts;
	strm = (strm * 1000) / 9;

	return (strm);

}


/////////////////////////////////////////////////////////////////////////
//
//			  Function : ConvertStrmtoPTS
//			  Args : PTS
//			  Returns :
//
//			  Purpose:
//				converts a stream class clock to a PTS
//				
//
//			  Last Modified 10.1.96 by JBS
//
/////////////////////////////////////////////////////////////////////////


ULONG ConvertStrmtoPTS(ULONGLONG strm)
{
	ULONGLONG temp;
	ULONG pts;

	//
	// we may lose some bits here, but we're only using the 32bit PTS anyway
	//

	temp = (strm * 9) / 1000;

	pts = (ULONG)temp;

	return (pts);

}

/*
** ClockEvents ()
**
**     handle any time event mark events
**
** Arguments:
**
**
**
** Returns:
**
** Side Effects:
*/

void
ClockEvents(PHW_DEVICE_EXTENSION pdevex)
{
PKSEVENT_ENTRY pEvent;

PMYTIME pTim;

LONGLONG MinIntTime;

LONGLONG strmTime;

	if (!pdevex || !pdevex->pstroAud)
	{										  	
		return;
	}

	strmTime = LastStamp + (GetSystemTime() - LastSys);



	//
	// loop through all time_mark events
	//

	pEvent = NULL;

	while(pEvent = StreamClassGetNextEvent(
				pdevex,
				pdevex->pstroAud,
				(GUID *)&KSEVENTSETID_Clock,
				KSEVENT_CLOCK_POSITION_MARK,
				pEvent))
	{
		TRAP

		if (((PKSEVENT_TIME_MARK)(pEvent +1))->MarkTime >= strmTime )
		{
			TRAP

			//
			// signal the event here
			//


			StreamClassStreamNotification(
				SignalStreamEvent,
				pdevex->pstroAud,
				pEvent
				);

			//
			// tell the stream class to disable this event
			//

			StreamClassStreamNotification(
				DeleteStreamEvent,
				pdevex->pstroAud,
				pEvent
				);

		}
	}

	//
	// loop through all time_interval events
	//

	pEvent = NULL;

	while ( pEvent = StreamClassGetNextEvent(
                pdevex,
                pdevex->pstroAud,
                (GUID *)&KSEVENTSETID_Clock,
                KSEVENT_CLOCK_INTERVAL_MARK,
                pEvent))
	{
		

		//
		// check if this event has been used for this interval yet
		//

		pTim = ((PMYTIME)(pEvent + 1));

		if (pTim && pTim->tim.Interval)
		{

			if (pTim->tim.TimeBase <= strmTime)
			{
				MinIntTime = (strmTime - pTim->tim.TimeBase) / pTim->tim.Interval;
				MinIntTime *= pTim->tim.Interval;
				MinIntTime +=  pTim->tim.TimeBase;
	
				if (MinIntTime > pTim->LastTime  )
				{
		
					//
					// signal the event here
					//
		
		
					StreamClassStreamNotification(
						SignalStreamEvent,
						pdevex->pstroAud,
						pEvent
						);
	
					pTim->LastTime = strmTime;
		
				}
			}

		}
		else
		{
			TRAP
		}


	}

}


/*
** AudioEvent ()
**
**    receives notification for audio clock enable / disable events
**
** Arguments:
**
**
**
** Returns:
**
** Side Effects:
*/


STREAMAPI
AudioEvent (PHW_EVENT_DESCRIPTOR pEvent)
{
	PUCHAR pCopy = (PUCHAR)(pEvent->EventEntry +1);
	PUCHAR pSrc = (PUCHAR)pEvent->EventData;
	ULONG cCopy;

	if (pEvent->Enable)
	{
		switch (pEvent->EventEntry->EventItem->EventId)
		{
		case KSEVENT_CLOCK_POSITION_MARK:
			cCopy = sizeof (KSEVENT_TIME_MARK);
			break;

		case KSEVENT_CLOCK_INTERVAL_MARK:
			cCopy = sizeof (KSEVENT_TIME_INTERVAL);
			break;

		default:

			TRAP

			return (STATUS_NOT_IMPLEMENTED);

		}

		if (pEvent->EventEntry->EventItem->DataInput != cCopy)
		{
			TRAP

			return (STATUS_INVALID_BUFFER_SIZE);
		}

		//
		// copy the input buffer
		//

		for (;cCopy > 0; cCopy--)
		{
			*pCopy++ = *pSrc++;
		}
		
		
	}

	return (STATUS_SUCCESS);
}






=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgs\cpq3520a\mpvideo.c ===
/*******************************************************************
*
*				 MPVIDEO.C
*
*				 Copyright (C) 1995 SGS-THOMSON Microelectronics.
*
*
*				 PORT/MINIPORT Interface Video Routines
*
*******************************************************************/

#include "strmini.h"
#include "mpinit.h"
#include <wingdi.h>
#include "ksmedia.h"
#include "mpvideo.h"
#include "hwcodec.h"
#include "ptsfifo.h"
#include "trace.h"
#include "copyprot.h"

extern PVIDEO pVideo;
extern GUID MY_KSEVENTSETID_VPNOTIFY;


KS_MPEGVIDEOINFO2 VidFmt;
KS_AMVPDATAINFO VPFmt;

void mpstCommandComplete(PHW_STREAM_REQUEST_BLOCK pSrb);
VOID AudioTimerCallBack(PHW_STREAM_OBJECT pstrm);
ULONG mpstVideoPacket(PHW_STREAM_REQUEST_BLOCK pSrb);
void AudioPacketStub(PHW_STREAM_OBJECT pstrm);

void VideoPacketStub(PHW_STREAM_OBJECT pstrm)
{

        VideoTimerCallBack(pstrm);

}

ULONG miniPortVideoPause(PHW_STREAM_REQUEST_BLOCK pSrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;
	pSrb = pSrb; // Remove Warning
  HwCodecPause();
	pHwDevExt->VideoDeviceExt.DeviceState = KSSTATE_PAUSE;
	return dwErrCode; 	
}


VOID miniPortVideoPacket(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	ULONG dwErrCode = NO_ERROR;
	ULONG uSent=0;

	PHW_DEVICE_EXTENSION pHwDevExt =
	 ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);

	PVIDEO_DEVICE_EXTENSION pvidex =
	 &(((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension)->VideoDeviceExt);

	 //
	 // set up for initial parsing of the scatter gather packet.
	 //

	 pvidex->cPacket = 0;
     pvidex->cOffs = PACK_HEADER_SIZE;
	 pvidex->pPacket = pSrb->CommandData.DataBufferArray;

	 if (!pvidex->pPacket)
	 {
		 TRAP
	 }

	 pvidex->pCurrentSRB = pSrb;

	 pHwDevExt->VideoDeviceExt.videoSTC =
		 pvidex->pPacket->PresentationTime.Time;
	 MPTrace(mTraceVideo);
	 VideoPacketStub(pSrb->StreamObject);

}

VOID miniPortGetProperty(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	PHW_DEVICE_EXTENSION phwdevext =
		((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);

	pSrb->Status = STATUS_SUCCESS;

	switch (pSrb->CommandData.PropertyInfo->PropertySetID)
	{

	case 1:

		//
		// this is a copy protection property go handle it there
		//

		CopyProtGetProp(pSrb);
		break;

	default:

        break;


	}

}

VOID miniPortSetState(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	PHW_DEVICE_EXTENSION phwdevext =
		((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    DbgPrint("'miniPortSetState:StreamState=%x\n",pSrb->CommandData.StreamState);

	switch (pSrb->CommandData.StreamState)
	{

	case KSSTATE_STOP:
	 	MPTrace(mTraceStop);
		if(phwdevext->VideoDeviceExt.pCurrentSRB != NULL)
		{
	 		MPTrace(mTraceLastVideoDone);
			phwdevext->VideoDeviceExt.pCurrentSRB->Status = STATUS_SUCCESS;

			mpstCommandComplete(phwdevext->VideoDeviceExt.pCurrentSRB);
			phwdevext->VideoDeviceExt.pCurrentSRB = NULL;
			StreamClassScheduleTimer(pSrb->StreamObject, phwdevext,
	     		0, VideoPacketStub, pSrb->StreamObject);
		}

		if(phwdevext->AudioDeviceExt.pCurrentSRB != NULL)
		{
	 		MPTrace(mTraceLastAudioDone);
			phwdevext->AudioDeviceExt.pCurrentSRB->Status = STATUS_SUCCESS;
			mpstCommandComplete(phwdevext->AudioDeviceExt.pCurrentSRB);
			phwdevext->AudioDeviceExt.pCurrentSRB = NULL;
			StreamClassScheduleTimer(pSrb->StreamObject, phwdevext,
		     0, AudioPacketStub, pSrb->StreamObject);
		}
			
//   miniPortVideoStop(pSrb, phwdevext);//pause for now should be stop
		HwCodecStop();
	   phwdevext->VideoDeviceExt.DeviceState = KSSTATE_STOP;
		break;


	case KSSTATE_PAUSE:
	 	MPTrace(mTracePause);
//		miniPortVideoPause(pSrb, phwdevext);
		HwCodecPause();
	   phwdevext->VideoDeviceExt.DeviceState = KSSTATE_PAUSE;
		break;

	case KSSTATE_RUN:
	 	MPTrace(mTracePlay);
		HwCodecPlay();
	   phwdevext->VideoDeviceExt.DeviceState = KSSTATE_RUN;
        break;

	}
	pSrb->Status = STATUS_SUCCESS;

}
ULONG miniPortVideoReset(PHW_STREAM_REQUEST_BLOCK pSrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	TRAP
	// TBC
//        mpstVideoReset();
        HwCodecSeek();
	pHwDevExt->VideoDeviceExt.DeviceState = KSSTATE_PAUSE;
	pSrb->Status = STATUS_SUCCESS;
	return dwErrCode; 	
}

ULONG miniPortVideoSetStc(PHW_STREAM_REQUEST_BLOCK pSrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;
	pHwDevExt = pHwDevExt; // Remove Warning
	pSrb = pSrb; // Remove Warning
	return dwErrCode; 	
}


ULONG miniPortVideoStop (PHW_STREAM_REQUEST_BLOCK pSrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;
	// TBC
	if(pHwDevExt->VideoDeviceExt.pCurrentSRB != NULL)
	{
		// Still to send a packet
		pHwDevExt->VideoDeviceExt.pCurrentSRB->Status = STATUS_SUCCESS;


		MPTrace(mTraceRdyVid);
		StreamClassStreamNotification(ReadyForNextStreamDataRequest,
				pHwDevExt->VideoDeviceExt.pCurrentSRB->StreamObject);
	
		StreamClassStreamNotification(StreamRequestComplete,
				pHwDevExt->VideoDeviceExt.pCurrentSRB->StreamObject,
				pHwDevExt->VideoDeviceExt.pCurrentSRB);


		//
		// request a timer callback
		//
	
		StreamClassScheduleTimer(pSrb->StreamObject, pSrb->HwDeviceExtension,
             0, VideoPacketStub, pSrb->StreamObject);


		pHwDevExt->VideoDeviceExt.pCurrentSRB =
		  pHwDevExt->pCurSrb = NULL;

	}

    DbgPrint("'miniPortVideoStop\n");
    //HwCodecVideoPause();//should be stop use pause for now
	HwCodecStop();
	pSrb->Status = STATUS_SUCCESS;
	return dwErrCode; 	
}

BYTE BogusPacket[8192] = {0};

VOID VideoTimerCallBack(PHW_STREAM_OBJECT pstrm)
{
    PHW_DEVICE_EXTENSION pdevext = pstrm->HwDeviceExtension;
    PHW_STREAM_REQUEST_BLOCK pSrb;

	ULONG	uSent;
	BOOL	fNotVideo;
	PVIDEO_DEVICE_EXTENSION pvidex = &(pdevext->VideoDeviceExt);
	static BOOL fNewVid = FALSE;
    ULONG ExtraBytes;
    PUCHAR SizePtr;

	pSrb = pvidex->pCurrentSRB;

	if (!pSrb)
	{
		return;
	}

	do
	{

		fNotVideo = FALSE;

		if (pvidex->pPacket->OptionsFlags &
			KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY)
		{
				HwCodecProcessDiscontinuity();
		}


		if (pvidex->pPacket->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TYPECHANGED)
		{

			if (pvidex->pPacket->DataUsed >= sizeof(KSDATAFORMAT) + sizeof(KS_MPEGVIDEOINFO2))
			{
				ProcessVideoFormat((PKSDATAFORMAT)pvidex->pPacket->Data, pdevext);
				uSent = pvidex->pPacket->DataUsed + 1;
			}
			else
			{
				TRAP
			}

			fNotVideo = TRUE;
	
		}

		else if (pvidex->pPacket->DataUsed)
		{

			uSent = mpstVideoPacket(pSrb);

			fNewVid= FALSE;
		}
		else
		{
			DbgPrint("'Video Discontinuity\n");

			fNewVid = TRUE;

			uSent = 1;
			fNotVideo = TRUE;
		}

		pvidex->cOffs += uSent;

		//
		// check if we finished this packet.  If so, go on to the
		// next packet
		//

		if (pvidex->cOffs >=
			pvidex->pPacket->DataUsed)
		{


            if (pvidex->pPacket->DataUsed >= 4 && !fNotVideo)
            {

                 SizePtr = (PUCHAR) ((ULONG_PTR) pvidex->pPacket->Data +
                       PACK_HEADER_SIZE + 4);
                 ExtraBytes = pvidex->pPacket->DataUsed - PACK_HEADER_SIZE -
                 ((ULONG) (SizePtr[0] << 8) + (ULONG) SizePtr[1] + 4 + 2);

			    if (*((PULONG)((PBYTE)pvidex->pPacket->Data + pvidex->pPacket->DataUsed - 4 - ExtraBytes)) ==
					    0xb7010000)
			    {
						
				    //
				    // found an end of sequence header
				    //

					 // Flush the buffer
					 HwCodecFlushBuffer();

			    }
            }



			pvidex->pPacket++;



			//
			// reset the packet offset
			//

			pvidex->cOffs = PACK_HEADER_SIZE;
			pvidex->cPacket++;

			//
			// if we have finished all the packets, then we are done
			//

			if (pvidex->cPacket >=
				 pSrb->NumberOfBuffers)
			{

 				pSrb->Status = STATUS_SUCCESS;
           mpstCommandComplete(pSrb);
	 			MPTrace(mTraceVideoDone);
				pvidex->pCurrentSRB = 0;
				return;

			}

		}

	} while (uSent);
  StreamClassScheduleTimer(pstrm, pstrm->HwDeviceExtension,
           1, (PHW_PRIORITY_ROUTINE)VideoTimerCallBack, pstrm);

}

void StubMpegEnableIRQ(PHW_STREAM_OBJECT pstrm)
{
    HwCodecEnableIRQ();

}


ULONG mpstVideoPacket(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	BOOL bPts = FALSE;
	BOOL bLatchPts = FALSE;
	DWORD vPts;
	PVIDEO_DEVICE_EXTENSION pvidex =
	 &(((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension)->VideoDeviceExt);
	ULONG	uLen;
  ULONG cPacket;
  PUCHAR  p;
    PUCHAR SizePtr;
    ULONG ExtraBytes;

  #define MAX_SIZE        8192

	//
	// find out how many bytes we can squeeze in
	//

  uLen = MAX_SIZE; //(BUF_FULL - VideoGetBBL()) * 256;
	if(pvidex->pPacket->OptionsFlags &
		KSSTREAM_HEADER_OPTIONSF_TYPECHANGED)
	{
		TRAP
	}

  if(pvidex -> cOffs == PACK_HEADER_SIZE)
  {

     p = (PUCHAR)((ULONG_PTR) pvidex->pPacket->Data + PACK_HEADER_SIZE);
     if ((p!=NULL) && (pvidex->pPacket->DataUsed > 8 + PACK_HEADER_SIZE))
		{
			int ptsf;

			ptsf = (p[7] >> 6)&0x03;
     	pvidex->cOffs = p[8]+9 + PACK_HEADER_SIZE;
			bLatchPts = TRUE;
			if(ptsf)
			{
				bPts = TRUE;
	      	vPts =((DWORD)(p[9]&0x0E)>>1) << 30 |
					((DWORD)(p[10])) << 22 |
						((DWORD)(p[11])>>1) << 15 |
							((DWORD)(p[12])) << 7 |
								((DWORD)(p[13])>>1) ;

			}
			else
			{
				vPts = 0x0;
			}
		}

		else
		{
			TRAP
		}
  }

  SizePtr = (PUCHAR) ((ULONG_PTR) pvidex->pPacket->Data + PACK_HEADER_SIZE + 4);

  ExtraBytes = pvidex->pPacket->DataUsed - PACK_HEADER_SIZE -
             ((ULONG) (SizePtr[0] << 8) + (ULONG) SizePtr[1] + 4 + 2);

  cPacket = pvidex->pPacket->DataUsed - pvidex->cOffs - ExtraBytes;

  uLen = uLen > cPacket ? cPacket : uLen;

  if(uLen > MAX_SIZE)
           uLen = MAX_SIZE;

	if (uLen)
	{
		ULONG retval;

        retval = HwCodecSendVideo((BYTE *)(((ULONG_PTR)pvidex->pPacket->Data) + pvidex->cOffs), uLen);
		if(bLatchPts)
		{
			FifoPutPTS(vPts, pvidex->pPacket->DataUsed-pvidex->cOffs, bPts);
		}

        if (uLen == retval) {
    		return retval + ExtraBytes;
        } else {
             return retval;
        }

	}

	return uLen;	
}


/////////////////////////////////////////////////////////////////////////
//
//			  Function : mpstCommandComplete
//			  Args : SRB
//			  Returns : none
//
//			  Purpose:
//				Performs a completion callback on a given request,
//				and then dequeues any outstanding requests
//
//			  Last Modified 10.1.96 by JBS
//
/////////////////////////////////////////////////////////////////////////
void mpstCommandComplete(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	PHW_DEVICE_EXTENSION pHwDevExt =
	 ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);

	 //
	 // see if there is a request outstanding on either queue.
	 // if there is, go ahead and start it.
	 //

	 //
	 //  Note: this code cannot be re-entered!
	 //


	 pHwDevExt ->pCurSrb = 0;

	 //
	 // now, go ahead and complete this request
	 //

	
	 MPTrace(mTraceRdyVid);
	 StreamClassStreamNotification(ReadyForNextStreamDataRequest,
			 pSrb->StreamObject);

	 StreamClassStreamNotification(StreamRequestComplete,
			 pSrb->StreamObject,
			 pSrb);

}

void ProcessVideoFormat(PKSDATAFORMAT pfmt, PHW_DEVICE_EXTENSION pdevex)
{
	KS_MPEGVIDEOINFO2 * pblock = (KS_MPEGVIDEOINFO2 *)((ULONG_PTR)pfmt + sizeof  (KSDATAFORMAT));
	ULONG cXOut;

	if (pfmt->FormatSize != sizeof(KSDATAFORMAT) + sizeof(KS_MPEGVIDEOINFO2))
	{
		TRAP

		return;
	}

	//
	// copy the format block
	//

	VidFmt = *pblock;

	//
	// copy the picture aspect ratio for now
	//

	VPFmt.dwPictAspectRatioX = VidFmt.hdr.dwPictAspectRatioX;
	VPFmt.dwPictAspectRatioY = VidFmt.hdr.dwPictAspectRatioY;

	//
	// check for pan scan enabled
	//

	if (VidFmt.dwFlags & KS_MPEG2_DoPanScan)
	{
		//
		// under pan scan for DVD for NTSC, we must be going to a 540 by
		// 480 bit image, from a 720 x 480 (or 704 x 480)  We will
		// use this as the base starting dimensions.  If the Sequence
		// header provides other sizes, then those should be updated,
		// and the Video port connection should be updated when the
		// sequence header is received.
		//

		//
		// change the picture aspect ratio.  Since we will be stretching
		// from 540 to 720 in the horizontal direction, our aspect ratio
		// will
		//

	
		VPFmt.dwPictAspectRatioX = (VidFmt.hdr.dwPictAspectRatioX * (54000 / 72));
		VPFmt.dwPictAspectRatioY = VidFmt.hdr.dwPictAspectRatioY * 1000;

		//
		// set up the X dimensions
		//

		cXOut = 540;


	}
	else // pan scan disabled, just check the format, and use it
	{
		cXOut = VidFmt.hdr.bmiHeader.biWidth;
	}

	//
	// set up the valid regions.
	//

	DbgPrint("CYCLO: FieldX = %d\n", cXOut);
	DbgPrint("CYCLO: FieldY = %d\n", VidFmt.hdr.bmiHeader.biHeight);

	VPFmt.amvpDimInfo.dwFieldWidth    = cXOut + 63;
	VPFmt.amvpDimInfo.dwFieldHeight 	= (VidFmt.hdr.bmiHeader.biHeight /2 )+18;
	VPFmt.amvpDimInfo.dwVBIWidth		= cXOut+63;
	VPFmt.amvpDimInfo.dwVBIHeight		= 0;

	VPFmt.amvpDimInfo.rcValidRegion.left		= 63;
	VPFmt.amvpDimInfo.rcValidRegion.top		= 18;
	VPFmt.amvpDimInfo.rcValidRegion.right		= cXOut + 63;
	VPFmt.amvpDimInfo.rcValidRegion.bottom	= 258;

	VideoSwitchSRC(FALSE);

	//
	// call the IVPConfig interface here
	//

	if (pdevex->pstroYUV &&
			((PSTREAMEX)(pdevex->pstroYUV->HwStreamExtension))->EventCount)
	{
		StreamClassStreamNotification(
	        SignalMultipleStreamEvents,
			pdevex->pstroYUV,
			&MY_KSEVENTSETID_VPNOTIFY,
			KSEVENT_VPNOTIFY_FORMATCHANGE
			);

	}


}

void VideoQueryAccept(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	PKSDATAFORMAT pfmt = pSrb->CommandData.OpenFormat;
	KS_MPEGVIDEOINFO2 * pblock = (KS_MPEGVIDEOINFO2 *)((ULONG_PTR)pfmt + sizeof  (KSDATAFORMAT));

	//
	// pick up the format block and examine it. Default to not implemented
	//

	pSrb->Status = STATUS_NOT_IMPLEMENTED;

	if (pfmt->FormatSize != sizeof(KSDATAFORMAT) + sizeof(KS_MPEGVIDEOINFO2))
	{
		return;
	}

	pSrb->Status = STATUS_SUCCESS;

}





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgs\cpq3520a\mpinit.c ===
/******************************************************************
*******************************************************************
*******************************************************************
*******************************************************************
*******************************************************************

WARNING!!!!!!  READ THIS FIRST!!!

This driver source is useful only as a model for implementing the DVD
specific properties and functions of streaming minidrivers.

There are several things in this driver that do not correspond to the optimal
stream minidriver architecture.   PLEASE DO NOT COPY THESE BAD ELEMENTS
INTO YOUR DVD MINIDRIVER!!!!

The deviations in this driver are:

1) It uses a big DMA buffer to double buffer requests.  DMA hardware should be
designed to support byte aligned scatter/gather DMA.

2) Global variables are used.  This is a big no-no as multiple adapters
won't be supported.

3) This driver has video and audio extensions built into the device extension.
The per stream information should be kept in the stream extension.

4) IMPORTANT: this minidriver does PIO at raised IRQL, rather than calling
StreamClassCallAtNewPriority and switching to dispatch priority.  Any
lengthy processing like PIO should be done at Dispatch priority. Ideally,
only DMA data xfer would be used, which may be set up at raised IRQL.

5) The code is poorly commented.  Please use the commenting and header style
found in the generic sample.

Please see the generic stream minidriver sample code to see the correct way
to do these things.

*******************************************************************
*******************************************************************
*******************************************************************
*******************************************************************
*******************************************************************/


/*******************************************************************
*
*                                MPINIT.C
*
*                                Copyright (C) 1995 SGS-THOMSON Microelectronics.
*
*
*                                PORT/MINIPORT Interface init routines
*
*******************************************************************/

#include "strmini.h"
#include "ks.h"
#include <wingdi.h>
#include "ksmedia.h"
#include "mpinit.h"
#include "hwcodec.h"
#include "mpvideo.h"
#include "mpaudio.h"
//#include "dxapi.h"
#include "trace.h"

extern ULONG    VidRate;
extern KS_AMVPDATAINFO VPFmt;

extern BOOLEAN fProgrammed;
extern BOOLEAN fStarted;

PHW_DEVICE_EXTENSION pDevEx;

//
// We allocate a large DMA buffer for Zoran chip
// in order to make sure that both writing into
// the dma buffer and reading from it for CD input
// can take place simultaniously.
// DO NOT REPLICATE THIS CODE IN OTHER DRIVERS!!!!!
//

#define DMA_BUFFER_SIZE 8192
GUID            g_S3Guid = {DDVPTYPE_E_HREFL_VREFL};

void            AudioPacketStub(PHW_STREAM_OBJECT pstrm);

//
// list of stream types for initialization
//

typedef enum tagStreamType {
    strmVideo = 0,
    strmAc3,
    strmNTSCVideo,
    strmSubpicture,
    strmYUVVideo,
	strmCCOut,
	NUMBER_OF_STREAMS
}               STREAMTYPES;

//
// some external variables
//
// WARNING!!!!   DO NOT REPLICATE THIS IN YOUR DRIVER.   Global variables
// will not work with multiple adapters.
//

PHW_STREAM_OBJECT pVideoStream;
HANDLE          hClk;
HANDLE          hMaster;

//
// define the data formats used by the pins in this minidriver
//

//
// MPEG2 video format definition
//

KSDATAFORMAT    hwfmtiMpeg2Vid = {
    sizeof(KSDATAFORMAT),// + sizeof(KS_MPEGVIDEOINFO2),

    /* NOTE: MPEG2 video streams must support the KS_MPEGVIDEOINFO2 format
     * block. This defines aspect ratios, and other stream properties */

    0,
	0,
	0,
    STATIC_KSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK,
//    STATIC_KSDATAFORMAT_TYPE_MPEG2_PES,
    STATIC_KSDATAFORMAT_SUBTYPE_MPEG2_VIDEO,
    STATIC_KSDATAFORMAT_SPECIFIER_MPEG2_VIDEO
};

//
// define the events associated with the master clock
//

KSEVENT_ITEM ClockEventItm[] =
{
	{
        KSEVENT_CLOCK_POSITION_MARK,		// position mark event supported
		sizeof (KSEVENT_TIME_MARK),			// requires this data as input
		sizeof (KSEVENT_TIME_MARK),			// allocate space to copy the data
		NULL,
		NULL,
		NULL
	},
	{
		KSEVENT_CLOCK_INTERVAL_MARK,		// interval mark event supported
		sizeof (KSEVENT_TIME_INTERVAL),		// requires interval data as input
		sizeof (MYTIME),					// we use an additional workspace of
											// size longlong for processing
											// this event
		NULL,
		NULL,
		NULL
	}
};

KSEVENT_SET ClockEventSet[] =
{
	{
		&KSEVENTSETID_Clock,
		SIZEOF_ARRAY(ClockEventItm),
		ClockEventItm,
	}
};

KSEVENT_ITEM VPEventItm[] =
{
	{
		KSEVENT_VPNOTIFY_FORMATCHANGE,
		0,
		0,
		NULL,
		NULL,
		NULL
	}
};

GUID MY_KSEVENTSETID_VPNOTIFY = {STATIC_KSEVENTSETID_VPNotify};

KSEVENT_SET VPEventSet[] =
{
	{
		&MY_KSEVENTSETID_VPNOTIFY,
		SIZEOF_ARRAY(VPEventItm),
		VPEventItm,
	}
};

//
//  AC3 audio format definition
//

KSDATAFORMAT    hwfmtiMpeg2Aud
= {
    sizeof(KSDATAFORMAT),
    0,
	0,
	0,
    STATIC_KSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK,
//    STATIC_KSDATAFORMAT_TYPE_MPEG2_PES,
    STATIC_KSDATAFORMAT_SUBTYPE_AC3_AUDIO,
    STATIC_KSDATAFORMAT_SPECIFIER_WAVEFORMATEX
};

//
// define the NTSC output format
//

KSDATAFORMAT    hwfmtiNTSCOut
= {
    sizeof(KSDATAFORMAT),
    0,
	0,
	0,
    STATIC_KSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK,
//    STATIC_KSDATAFORMAT_TYPE_MPEG2_PES,
    STATIC_KSDATAFORMAT_SUBTYPE_MPEG2_VIDEO,
    STATIC_KSDATAFORMAT_SPECIFIER_WAVEFORMATEX
};

//
// define the VP output pin format
//

KSDATAFORMAT    hwfmtiVPOut
= {
    sizeof(KSDATAFORMAT),
    0,
	0,
	0,
    STATIC_KSDATAFORMAT_TYPE_VIDEO,
    STATIC_KSDATAFORMAT_TYPE_VIDEO,
    STATIC_KSDATAFORMAT_TYPE_VIDEO
};

//
// define the Close Caption output pin format
//

KSDATAFORMAT    hwfmtiCCOut
= {
    sizeof(KSDATAFORMAT),
    0,
	200,
	0,
    STATIC_KSDATAFORMAT_TYPE_AUXLine21Data,
    STATIC_KSDATAFORMAT_SUBTYPE_Line21_GOPPacket,
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO
};

//
// define the DVD subpicture decoder pin format
//

KSDATAFORMAT    hwfmtiSubPic
= {
    sizeof(KSDATAFORMAT),
    0,
	0,
	0,
    STATIC_KSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK,
//    STATIC_KSDATAFORMAT_TYPE_MPEG2_PES,
    STATIC_KSDATAFORMAT_SUBTYPE_SUBPICTURE,
    STATIC_GUID_NULL
};

//
// define the arrays of supported formats pointers
//

PKSDATAFORMAT   Mpeg2VidInfo[] = {
    &hwfmtiMpeg2Vid             // pointer to the MPEG 2 video format block
};

PKSDATAFORMAT   SubPicInfo[] = {
    &hwfmtiSubPic               // pointer to the subpicture format block
};

PKSDATAFORMAT   AC3AudioInfo[] = {
    &hwfmtiMpeg2Aud             // pointer to the AC-3 format block
};


PKSDATAFORMAT   NtscInfo[] = {  // ntsc output formats array
    &hwfmtiNTSCOut
};

PKSDATAFORMAT   VPInfo[] = {   // VP output formats array
    &hwfmtiVPOut
};

PKSDATAFORMAT   CCInfo[] = {   // CC output formats array
    &hwfmtiCCOut
};

//
// define the Individual property items for the video property sets
//

static const KSPROPERTY_ITEM mpegVidPropItm[] = {
    {KSPROPERTY_DVDSUBPIC_PALETTE,  // subpicture palette property
        FALSE,                  // get palette not supported
        sizeof(KSPROPERTY),
        sizeof(KSPROPERTY_SPPAL),   // minimum size of data requested
        (PFNKSHANDLER) FALSE,   // set palette is supported
        NULL,
        0,
        NULL,
        NULL,
        0
    }
};

//
// define the subpicture property items supported
//

static const KSPROPERTY_ITEM spPropItm[] = {

    {KSPROPERTY_DVDSUBPIC_PALETTE,  // subpicture palette property
        FALSE,                  // get palette not supported
        sizeof(KSPROPERTY),
        sizeof(KSPROPERTY_SPPAL),   // minimum size of data requested
        (PFNKSHANDLER) TRUE,    // set palette is supported
        NULL,
        0,
        NULL,
        NULL,
        0
    },


    {KSPROPERTY_DVDSUBPIC_HLI,  // subpicture highlight property
        FALSE,                  // get highlight not supported
        sizeof(KSPROPERTY),
        sizeof(KSPROPERTY_SPHLI),   // minimum size of data requested
        (PFNKSHANDLER) TRUE,    // set highlight is supported
        NULL,
        0,
        NULL,
        NULL,
        0
    },


    {KSPROPERTY_DVDSUBPIC_COMPOSIT_ON,  // subpicture enable status property
        FALSE,                  // get enable status not supported
        sizeof(KSPROPERTY),
        sizeof(KSPROPERTY_COMPOSIT_ON), // minimum size of data requested
        (PFNKSHANDLER) TRUE,    // set enable status is supported
        NULL,
        0,
        NULL,
        NULL,
        0
    }

};

static const KSPROPERTY_ITEM audPropItm[] = {

    {KSPROPERTY_AUDDECOUT_MODES,// available audio decoder output formats
        // property
        (PFNKSHANDLER) TRUE,    // get available modes is supported
        sizeof(KSPROPERTY),
        sizeof(ULONG),          // minimum size of data requested
        (PFNKSHANDLER) FALSE,   // set available modes is not supported
        NULL,
        0,
        NULL,
        NULL,
        0
    },

    {KSPROPERTY_AUDDECOUT_CUR_MODE, // current audio decoder output format
        // property
        (PFNKSHANDLER) TRUE,    // get current mode is supported
        sizeof(KSPROPERTY),
        sizeof(ULONG),          // minimum size of data requested
        (PFNKSHANDLER) TRUE,    // set current modes is supported
        NULL,
        0,
        NULL,
        NULL,
        0
    }
};

//
// define the copy protection property support
//

static const KSPROPERTY_ITEM CopyProtPropItm[] = {

	{KSPROPERTY_DVDCOPY_CHLG_KEY,// DVD authentication challenge key
        (PFNKSHANDLER)TRUE,      // get property on challenge key requests the
								 // decoder to provide it's challenge key
        sizeof(KSPROPERTY),
        sizeof(KS_DVDCOPY_CHLGKEY), // minimum size of data requested
        (PFNKSHANDLER) TRUE,     // set palette is supported
        NULL,
        0,
        NULL,
        NULL,
        0
    },

	{KSPROPERTY_DVDCOPY_DVD_KEY1,// DVD authentication DVD drive key property
        FALSE,                   // get Key not supported
        sizeof(KSPROPERTY),
        sizeof(KS_DVDCOPY_BUSKEY),// minimum size of data requested
        (PFNKSHANDLER) TRUE,     // set key provides the key for the decoder
        NULL,
        0,
        NULL,
        NULL,
        0
    },

	{KSPROPERTY_DVDCOPY_DEC_KEY2,// DVD authentication DVD decoder key property
        (PFNKSHANDLER)TRUE,      // get Key requests the decoder key, in
								 // response to a previous set challenge key
        sizeof(KSPROPERTY),
        sizeof(KS_DVDCOPY_BUSKEY),	 // minimum size of data requested
        (PFNKSHANDLER)FALSE,     // set key is not valid
        NULL,
        0,
        NULL,
        NULL,
        0
    },


	{KSPROPERTY_DVDCOPY_REGION,  // DVD region request
								 // the minidriver shall fit in exactly
								 // one region bit, corresponding to the region
   								 // that the decoder is currently in
        (PFNKSHANDLER)TRUE,
        sizeof(KSPROPERTY),
        sizeof(KS_DVDCOPY_REGION),	 // minimum size of data requested
        (PFNKSHANDLER)FALSE,     // set key is not valid
        NULL,
        0,
        NULL,
        NULL,
        0
    },
	{KSPROPERTY_DVDCOPY_TITLE_KEY,// DVD authentication DVD title key property
        FALSE,                   // get Key not supported
        sizeof(KSPROPERTY),
        sizeof(KS_DVDCOPY_TITLEKEY),// minimum size of data requested
        (PFNKSHANDLER) TRUE,     // set key provides the key for the decoder
        NULL,
        0,
        NULL,
        NULL,
        0
    },
	{KSPROPERTY_DVDCOPY_DISC_KEY, // DVD authentication DVD disc key property
        FALSE,                   // get Key not supported
        sizeof(KSPROPERTY),
        sizeof(KS_DVDCOPY_BUSKEY),// minimum size of data requested
        (PFNKSHANDLER) TRUE,     // set key provides the key for the decoder
        NULL,
        0,
        NULL,
        NULL,
        0
    }

};


//
// property set for Macrovision support
//

static const KSPROPERTY_ITEM MacroVisionPropItm[] = {
	{
		KSPROPERTY_COPY_MACROVISION,		// support for setting macrovision level
		(PFNKSHANDLER) FALSE, 		// get not supported
		sizeof (KSPROPERTY),
		sizeof (KS_COPY_MACROVISION),
		(PFNKSHANDLER) TRUE,		// set MACROVISION level supported
		NULL,
		0,
		NULL,
		NULL,
		0
	}
};

//
// property set for CC support
//

static const KSPROPERTY_ITEM CCPropItm[] = {
	{
		KSPROPERTY_CONNECTION_ALLOCATORFRAMING,	// support for setting CC buffer size
		(PFNKSHANDLER) TRUE, 					// get supported
		sizeof (KSPROPERTY),
		sizeof (KSALLOCATOR_FRAMING),
		(PFNKSHANDLER) FALSE,					// we only provide the allocator requirments
		NULL,
		0,
		NULL,
		NULL,
		0
	},
	{
		KSPROPERTY_CONNECTION_STATE,			// support for setting CC buffer size
		(PFNKSHANDLER) TRUE, 					// get supported
		sizeof (KSPROPERTY),
		sizeof (KSSTATE),
		(PFNKSHANDLER) FALSE,					// we only provide the allocator requirments
		NULL,
		0,
		NULL,
		NULL,
		0
	}
};

static const KSPROPERTY_ITEM VideoPortPropItm[] = {

    {KSPROPERTY_VPCONFIG_NUMCONNECTINFO,
        (PFNKSHANDLER) TRUE,
        sizeof(KSPROPERTY),
        sizeof(ULONG),
        (PFNKSHANDLER) FALSE,
        NULL,
        0,
        NULL,
        NULL,
        0
    },

    {KSPROPERTY_VPCONFIG_NUMVIDEOFORMAT,
        (PFNKSHANDLER) TRUE,
        sizeof(KSPROPERTY),
        sizeof(ULONG),
        (PFNKSHANDLER) FALSE,
        NULL,
        0,
        NULL,
        NULL,
        0
    },

	{KSPROPERTY_VPCONFIG_GETCONNECTINFO,
	(PFNKSHANDLER) TRUE,
	sizeof (KSMULTIPLE_DATA_PROP),  // minimum property input size
	sizeof (ULONG),    				
	(PFNKSHANDLER)FALSE,
	NULL,
	0,
	NULL,
	NULL,
	0
	},

	{KSPROPERTY_VPCONFIG_SETCONNECTINFO,
	(PFNKSHANDLER) FALSE,
	sizeof (KSPROPERTY),  			// minimum property input size
	sizeof (ULONG),    				// minimum buffer size
	(PFNKSHANDLER)TRUE,
	NULL,
	0,
	NULL,
	NULL,
	0
	},

	{KSPROPERTY_VPCONFIG_VPDATAINFO,
	(PFNKSHANDLER) TRUE,
	sizeof (KSPROPERTY),
	sizeof (KS_AMVPDATAINFO),
	(PFNKSHANDLER)FALSE,
	NULL,
	0,
	NULL,
	NULL,
	0
	},

	{KSPROPERTY_VPCONFIG_MAXPIXELRATE,
	(PFNKSHANDLER) TRUE,
	sizeof (KSVPSIZE_PROP),
	sizeof (KSVPMAXPIXELRATE),
	(PFNKSHANDLER)FALSE,
	NULL,
	0,
	NULL,
	NULL,
	0
	},

	{KSPROPERTY_VPCONFIG_INFORMVPINPUT,
	(PFNKSHANDLER) TRUE,
	sizeof (PKSPROPERTY),
	sizeof (DDPIXELFORMAT),    // could be 0 too
	(PFNKSHANDLER)FALSE,
	NULL,
	0,
	NULL,
	NULL,
	0
	},

	{KSPROPERTY_VPCONFIG_DDRAWHANDLE,
	(PFNKSHANDLER)FALSE,
	sizeof (PKSPROPERTY),
	sizeof (ULONG),    // could be 0 too
	(PFNKSHANDLER) TRUE,
	NULL,
	0,
	NULL,
	NULL,
	0
	},

	{KSPROPERTY_VPCONFIG_VIDEOPORTID,
	(PFNKSHANDLER)FALSE,
	sizeof (PKSPROPERTY),
	sizeof (ULONG),    // could be 0 too
	(PFNKSHANDLER) TRUE,
	NULL,
	0,
	NULL,
	NULL,
	0
	},
	{KSPROPERTY_VPCONFIG_DDRAWSURFACEHANDLE,
	(PFNKSHANDLER)FALSE,
	sizeof (PKSPROPERTY),
	sizeof (ULONG),    // could be 0 too
	(PFNKSHANDLER) TRUE,
	NULL,
	0,
	NULL,
	NULL,
	0
	},

	{KSPROPERTY_VPCONFIG_GETVIDEOFORMAT,
	(PFNKSHANDLER) TRUE,
	sizeof (KSMULTIPLE_DATA_PROP), 		// for _GET; KSPROPERTY for _SET
	sizeof (ULONG),        		// could be 4 or more
	(PFNKSHANDLER)FALSE,
	NULL,
	0,
	NULL,
	NULL,
	0
	},

	{KSPROPERTY_VPCONFIG_SETVIDEOFORMAT,
	(PFNKSHANDLER) FALSE,
	sizeof (KSPROPERTY),  			// minimum property input size
	sizeof (ULONG),    				// minimum buffer size
	(PFNKSHANDLER)TRUE,
	NULL,
	0,
	NULL,
	NULL,
	0
	},


	{KSPROPERTY_VPCONFIG_INVERTPOLARITY,
	(PFNKSHANDLER)TRUE,
	sizeof (KSPROPERTY),
	0,
	(PFNKSHANDLER)FALSE,
	NULL,
	0,
	NULL,
	NULL,
	0
	},

	{KSPROPERTY_VPCONFIG_DECIMATIONCAPABILITY,
	(PFNKSHANDLER)TRUE,
	sizeof (KSPROPERTY),
	sizeof (BOOL),
	(PFNKSHANDLER)FALSE,
	NULL,
	0,
	NULL,
	NULL,
	0
	},

	{KSPROPERTY_VPCONFIG_SCALEFACTOR,
	(PFNKSHANDLER)TRUE,
	sizeof (KSPROPERTY),
	sizeof (KS_AMVPSIZE),
	(PFNKSHANDLER)FALSE,
	NULL,
	0,
	NULL,
	NULL,
	0
	}
};

//
// define the array of video property sets supported
//


static const KSPROPERTY_SET mpegVidPropSet[] = {
	{
		&KSPROPSETID_Mpeg2Vid,
		SIZEOF_ARRAY(mpegVidPropItm),
		(PKSPROPERTY_ITEM) mpegVidPropItm
	},
	{
		&KSPROPSETID_CopyProt,
		SIZEOF_ARRAY(CopyProtPropItm),
		(PKSPROPERTY_ITEM) CopyProtPropItm
	}
};

//
// define the array of subpicture property sets supported
//

static const KSPROPERTY_SET SPPropSet[] = {
	{
		&KSPROPSETID_DvdSubPic,
		SIZEOF_ARRAY(spPropItm),
		(PKSPROPERTY_ITEM) spPropItm
	},

	{
		&KSPROPSETID_CopyProt,
		SIZEOF_ARRAY(CopyProtPropItm),
		(PKSPROPERTY_ITEM) CopyProtPropItm
	}
};

//
// define the array of audio property sets supported
//

static const KSPROPERTY_SET audPropSet[] = {
	{
		&KSPROPSETID_AudioDecoderOut,
		SIZEOF_ARRAY(audPropItm),
		(PKSPROPERTY_ITEM) audPropItm
	},
	{
		&KSPROPSETID_CopyProt,
		SIZEOF_ARRAY(CopyProtPropItm),
		(PKSPROPERTY_ITEM) CopyProtPropItm
	}

};

//
// define the array of property sets for the video port pin
//

GUID            VPPropSetid = {STATIC_KSPROPSETID_VPConfig};

static const KSPROPERTY_SET VideoPortPropSet[] = {
    &VPPropSetid,
    SIZEOF_ARRAY(VideoPortPropItm),
    (PKSPROPERTY_ITEM) VideoPortPropItm
};

static const KSPROPERTY_SET NTSCPropSet[] = {
	&KSPROPSETID_CopyProt,
	SIZEOF_ARRAY(MacroVisionPropItm),
	(PKSPROPERTY_ITEM) MacroVisionPropItm
};

static const KSPROPERTY_SET CCPropSet[] = {
	&KSPROPSETID_Connection,
	SIZEOF_ARRAY(CCPropItm),
	(PKSPROPERTY_ITEM) CCPropItm
};

static const KSTOPOLOGY Topology = {
    1,
    (GUID *) & KSCATEGORY_DATADECOMPRESSOR,
    0,
    NULL,
    0,
    NULL
};

//
// Few globals here, should be put in the
// structure
// WARNING!!!!   DO NOT REPLICATE THIS IN YOUR DRIVER.   It will not work
// with multiple adapters.
//

BOOL            bInitialized = FALSE;
VOID STREAMAPI  StreamReceiveAudioPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID            HwProcessDataIntersection(PHW_STREAM_REQUEST_BLOCK pSrb);

extern PSP_STRM_EX pSPstrmex;


/*
** StreamReceiveFakeDataPacket ()
**
**   dispatch routine for receiving a data packet.  This routine will
**	 dispatch to the appropriate data handler initialized in the stream
**	 extension for this data stream
**
** Arguments:
**
**
**
** Returns:
**
** Side Effects:
*/

VOID            STREAMAPI
                StreamReceiveFakeDataPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PHW_DEVICE_EXTENSION pdevext =
    ((PHW_DEVICE_EXTENSION) pSrb->HwDeviceExtension);


        pSrb->Status = STATUS_SUCCESS;
		pSrb->ActualBytesTransferred = 0;

        StreamClassStreamNotification(ReadyForNextStreamDataRequest,
                                      pSrb->StreamObject);

        StreamClassStreamNotification(StreamRequestComplete,
                                      pSrb->StreamObject,
                                      pSrb);


}


/*
** DriverEntry ()
**
**     Initial load entry point into the driver.  Initializes the key
**	   entry points to the mini driver, and registers with the stream class
**	   driver
**
** Arguments:
**
**     Arg1 and Arg2, corresponding to the Context1 and Context2 arguments
**	   passed from the stream class driver
**
** Returns:
**
**	   The result of the registration call with the Stream Class driver
**     This in turn will be the return from the SRB_INITIALIZE_DEVICE function
**	   call into the AdapterReceivePacket routine
**
** Side Effects:
*/

NTSTATUS
DriverEntry(
            IN PDRIVER_OBJECT DriverObject,
            IN PUNICODE_STRING RegistryPath
)
{

    HW_INITIALIZATION_DATA HwInitData;

    //
    // all unused fields should be zero.
    //

    RtlZeroMemory(&HwInitData, sizeof(HW_INITIALIZATION_DATA));

    MPTrace(mTraceDriverEntry);
    DebugPrint((DebugLevelVerbose, "ST MPEG2 MiniDriver DriverEntry"));

    HwInitData.HwInitializationDataSize = sizeof(HwInitData);

    HwInitData.HwInterrupt = HwInterrupt;

    HwInitData.HwReceivePacket = AdapterReceivePacket;
    HwInitData.HwCancelPacket = AdapterCancelPacket;
    HwInitData.HwRequestTimeoutHandler = AdapterTimeoutPacket;

    HwInitData.DeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);
    HwInitData.PerRequestExtensionSize = sizeof(MRP_EXTENSION);
    HwInitData.FilterInstanceExtensionSize = 0;
    HwInitData.PerStreamExtensionSize = sizeof(STREAMEX);   // random size for code
    // testing
    HwInitData.BusMasterDMA = FALSE;
    HwInitData.Dma24BitAddresses = FALSE;
    HwInitData.BufferAlignment = 3;
    HwInitData.TurnOffSynchronization = FALSE;
    HwInitData.DmaBufferSize = DMA_BUFFER_SIZE;

    DebugPrint((DebugLevelVerbose, "SGS: call to portinitialize"));
    return (StreamClassRegisterAdapter((PVOID)DriverObject,
			(PVOID)RegistryPath, &HwInitData));
}

/*
** AdapterCancelPacket ()
**
**    routine to cancel a packet that may be in progress
**
** Arguments:
**
**   pSrb points to the packet to be cancelled
**
** Returns:
**
** Side Effects:
**   the mini driver must no longer access this packet after this call
**   returns
*/

VOID
AdapterCancelPacket(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PHW_DEVICE_EXTENSION pdevex = (PHW_DEVICE_EXTENSION) pSrb->HwDeviceExtension;

    MPTrace(mTraceCancelPacket);

    //
    // need to find this packet, pull it off our queues, and cancel it
    //

    //
    // check the video queues to see if the packet is there
    //

    if (pdevex->VideoDeviceExt.pCurrentSRB == pSrb) {

        //
        // found the packet on the video queue, so, remove all references
        // from the video processing, and clear any timers used to access
        // this packet
        //

        MPTrace(mTraceLastVideoDone);
        pdevex->VideoDeviceExt.pCurrentSRB = NULL;
        StreamClassScheduleTimer(pSrb->StreamObject, pdevex,
                                 0, VideoPacketStub, pSrb->StreamObject);

    }
    //
    // check the audio queues for the packet
    //

    if (pdevex->AudioDeviceExt.pCurrentSRB == pSrb) {
        TRAP
            MPTrace(mTraceLastAudioDone);
        pdevex->AudioDeviceExt.pCurrentSRB = NULL;
        StreamClassScheduleTimer(pSrb->StreamObject, pdevex,
                                 0, AudioPacketStub, pSrb->StreamObject);

    }
    if (pdevex->pCurSrb == pSrb) {
        pdevex->pCurSrb = NULL;
    }
    pSrb->Status = STATUS_CANCELLED;


        switch (pSrb->Flags & (SRB_HW_FLAGS_DATA_TRANSFER |
                               SRB_HW_FLAGS_STREAM_REQUEST)) {
        //
        // find all stream commands, and do stream notifications
        //

    case SRB_HW_FLAGS_STREAM_REQUEST | SRB_HW_FLAGS_DATA_TRANSFER:
        StreamClassStreamNotification(ReadyForNextStreamDataRequest,
                                      pSrb->StreamObject);


        StreamClassStreamNotification(StreamRequestComplete,
                                      pSrb->StreamObject,
                                      pSrb);

        break;

    case SRB_HW_FLAGS_STREAM_REQUEST:

        mpstCtrlCommandComplete(pSrb);

        break;

    default:


        //
        // must be a device request
        //

        AdapterCB(pSrb);

    }

}

/*
** AdapterTimeoutPacket ()
**
**  When this routine is called, a packet has spent too much time at the
**  mindriver.  Either the device is paused, and data packets are awaiting
**  a play or stop, or something is wrong with the device.  In a pause situation
**  the timer should just be reset.
**
**  If the system is not paused, the device should abort all outstanding
**  requests and reset.
**
** Arguments:
**
**  pSrb - points to the packet that timedout
**
** Returns:
**
** Side Effects:
*/

VOID
AdapterTimeoutPacket(PHW_STREAM_REQUEST_BLOCK pSrb)
{

    PSTREAMEX       strm = (PSTREAMEX) pSrb->StreamObject->HwStreamExtension;
    PHW_DEVICE_EXTENSION pdevex = (PHW_DEVICE_EXTENSION) pSrb->HwDeviceExtension;


    //
    // if we are not playing, and this is a CTRL request, we still
    // need to reset everything
    //

    MPTrace(mTraceTimeOut);

    if (pdevex->VideoDeviceExt.DeviceState == KSSTATE_PAUSE ||
        pdevex->AudioDeviceExt.DeviceState == KSSTATE_PAUSE) {

        //
        // reset the timeout counter, and continue
        //

        pSrb->TimeoutCounter = pSrb->TimeoutOriginal;

        return;
    }

    //
    // this is a catastrophic timeout reset the device and prepare to
    // continue
    //

    //
    // eliminate all device queues
    //

    pdevex->VideoDeviceExt.pCurrentSRB = NULL;
    pdevex->AudioDeviceExt.pCurrentSRB = NULL;
    pSPstrmex->pSrbQ = NULL;
    pdevex->pCurSrb = NULL;

	CleanSPQueue(pSPstrmex);
	CleanCCQueue();

    //
    // clear all pending timeouts on all streams that use them
    //


    if (pdevex->pstroVid) {
        StreamClassScheduleTimer(pdevex->pstroVid, pdevex,
                                 0, NULL, pdevex->pstroVid);

    }
    if (pdevex->pstroAud) {
        StreamClassScheduleTimer(pdevex->pstroAud, pdevex,
                                 0, NULL, pdevex->pstroAud);

    }



    //
    // kill all outstanding requests for the entire device!
    // NOTE: we don't need to call any requests back, they are all aborted
    // at the stream class driver
    //

    StreamClassAbortOutstandingRequests(pSrb->HwDeviceExtension, NULL,
                                        STATUS_CANCELLED);

}

/*
** AdapterOpenStream ()
**
**   process open stream request blocks
**
** Arguments:
**
**   pSrb -> request block for the open stream request
**
** Returns:
**
**  status in the Srb
**
** Side Effects:
*/

VOID
AdapterOpenStream(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PSTREAMEX       strm = (PSTREAMEX) pSrb->StreamObject->HwStreamExtension;
    PHW_DEVICE_EXTENSION pdevex = (PHW_DEVICE_EXTENSION) pSrb->HwDeviceExtension;

    //
    // for now, just return success
    //

    pSrb->Status = STATUS_SUCCESS;

    //
    // set up the sreamobject structure
    //

    //
    // this mindriver uses a generic control routine, and pointers to
    // functions
    // for individual function dispatches.  A minidriver could use an
    // individual control routine for each stream if desired
    //

    pSrb->StreamObject->ReceiveControlPacket = (PVOID) StreamReceiveCtrlPacket;

    //
    // since this adapter double buffers all DMA, we indicate that the
    // streams
    // are PIO, as the minidriver is not interested in the physical dma
    // addresses for the buffers that are passed to it, and the minidriver
    // must read data from the buffer addresses passed in.
    //
    // This minidriver only uses the physical address of the DMA buffer that
    // it allocates at initialization time.
    //
    // For hardware that can support byte aligned DMA, the Pio BOOLEAN should
    // be set to TRUE, only if the minidriver will use the host processor
    // to access the memory pointed to by data buffers passed to the stream
    // Examples would be edge alignment of DMA transfers, or any code that
    // might look for start codes, or end of streams within the data
    //

    pSrb->StreamObject->Pio = TRUE;

    //
    // the DMA BOOLEAN is set to true, only if the minidriver needs to be
    // able to use DMA to DIRECTLY access the memory buffers passed in.
    //

    pSrb->StreamObject->Dma = FALSE;

    //
    // set up stream specific stream extension information
    //

    switch (pSrb->StreamObject->StreamNumber) {
    case strmVideo:

        //
        // this is the video stream
        //

        //
        // set up the control functions for AdapterReceiveCtrlPacket
        //

        strm->pfnWriteData = (PFN_WRITE_DATA) miniPortVideoPacket;
        strm->pfnSetState = (PFN_WRITE_DATA) miniPortSetState;
        strm->pfnGetProp = (PFN_WRITE_DATA) miniPortGetProperty;
        strm->pfnSetProp = (PFN_WRITE_DATA) miniPortGetProperty;
        strm->pfnQueryAccept = (PFN_WRITE_DATA) VideoQueryAccept;

        //
        // set up the receive data packet entry point
        //

        pSrb->StreamObject->ReceiveDataPacket = (PVOID) StreamReceiveDataPacket;

        //
        // set up some ugly globals.
        //

        pVideoStream = pSrb->StreamObject;
        pdevex->pstroVid = pSrb->StreamObject;

        //
        // set up the initial video format, using the DATAFORMAT specifier
        // passed in as part of this open command
        //

        ProcessVideoFormat(pSrb->CommandData.OpenFormat, pdevex);

        EnableIT();

        //
        // call the DXAPI to get the version
        //

//#pragma message ("fix before shipping")
//        DxApiGetVersion();

        break;

    case strmAc3:

        //
        // this is the AC3 audio stream
        //

        //
        // set up the flags indicating that this stream can be a master clock
        // for syncronization purposes, also indicate the routine to call
        // for current master clock value
        //

        pSrb->StreamObject->HwClockObject.HwClockFunction =  StreamClockRtn;
        pSrb->StreamObject->HwClockObject.ClockSupportFlags =
            CLOCK_SUPPORT_CAN_SET_ONBOARD_CLOCK | CLOCK_SUPPORT_CAN_READ_ONBOARD_CLOCK |
            CLOCK_SUPPORT_CAN_RETURN_STREAM_TIME;

        //
        // set up the control functions for AdapterReceiveCtrlPacket
        //

        strm->pfnWriteData = (PFN_WRITE_DATA) miniPortAudioPacket;
        pSrb->StreamObject->ReceiveDataPacket = (PVOID) StreamReceiveDataPacket;
        strm->pfnSetState = (PFN_WRITE_DATA) miniPortAudioSetState;
        strm->pfnGetProp = (PFN_WRITE_DATA) miniPortAudioGetProperty;
        strm->pfnSetProp = (PFN_WRITE_DATA) miniPortAudioSetProperty;

		pSrb->StreamObject->HwEventRoutine = (PHW_EVENT_ROUTINE) AudioEvent;
        //
        // set up some more nasty Global references
        //

        pdevex->pstroAud = pSrb->StreamObject;

		//
		// ininitalise our clock information
		//

		fStarted = fProgrammed = FALSE;

        EnableIT();

        break;

    case strmSubpicture:

        //
        // this is the subpicture stream
        //

        //
        // set up the control functions for AdapterReceiveCtrlPacket
        //

        strm->pfnSetState = (PFN_WRITE_DATA) SPSetState;
        strm->pfnGetProp = (PFN_WRITE_DATA) SPGetProp;
        strm->pfnSetProp = (PFN_WRITE_DATA) SPSetProp;

        //
        // set up the subpicture datapacket routine
        //

        pSrb->StreamObject->ReceiveDataPacket = (PVOID) SPReceiveDataPacket;

        //
        // more cross referenced structures
        //

        strm->spstrmex.phwdevex = (PHW_DEVICE_EXTENSION) pSrb->HwDeviceExtension;
        strm->spstrmex.phstrmo = pSrb->StreamObject;

        EnableIT();

        //
        // the subpicture decoders needs memory buffers to double buffer
        // the incoming data in a coherent form.  Since the incoming call
        // for the open stream is at interrupt priority, we need to allocate
        // the memory at lower priority, so we will schedule a callback to
        // accomplish this
        //

        StreamClassCallAtNewPriority(pSrb->StreamObject,
                                     pSrb->HwDeviceExtension,
                                     Low,
                                     (PHW_PRIORITY_ROUTINE) OpenSubPicAlloc,
                                     pSrb);

        //
        // note: we return without calling back the subpicture open stream
        // SRB.  We will call it back in the OpenSubPicAlloc routine
        //

        return;

    case strmNTSCVideo:

        //
        // this is the anolog NTSC video stream.  Not much to do yet, but
        // it will soon handle NTSC macrovision properties
        //

        strm->pfnGetProp = (PFN_WRITE_DATA) NTSCGetProp;
        strm->pfnSetProp = (PFN_WRITE_DATA) NTSCSetProp;

        break;

    case strmYUVVideo:

        //
        // this is the Video Port YUV Data stream.  This pin only supports
        // get and set properties
        //

        strm->pfnGetProp = (PFN_WRITE_DATA) VPEGetProp;
        strm->pfnSetProp = (PFN_WRITE_DATA) VPESetProp;
        pSrb->StreamObject->ReceiveDataPacket = (PVOID) StreamReceiveFakeDataPacket;

		pdevex->pstroYUV = pSrb->StreamObject;

		pSrb->StreamObject->HwEventRoutine = (PHW_EVENT_ROUTINE) CycEvent;



        break;
    case strmCCOut:

        //
        // this is the close caption stream
        //

        //
        // set up the control functions for AdapterReceiveCtrlPacket
        //

        strm->pfnSetState = (PFN_WRITE_DATA) CCSetState;
		strm->pfnGetProp = CCGetProp;

        //
        // set up the receive data packet entry point
        //

        pSrb->StreamObject->ReceiveDataPacket = (PVOID) CCReceiveDataPacket;

        pdevex->pstroCC = pSrb->StreamObject;

        break;
    default:

        //
        // we should never get a call on a stream type that we didn't
        // report in the first place!
        //

        TRAP

            pSrb->Status = STATUS_NOT_IMPLEMENTED;

    }

    AdapterCB(pSrb);

}


/*
** OpenSubPicAlloc ()
**
**	 Routine to allocate memory for subpicture use
**
** Arguments:
**
**	 pSrb points to the subpicture open stream Srb
**
** Returns:
**
**	 returns status in the Srb
**
** Side Effects:
**
**   the subpicture stream extension data pointer, pdata is initialized if the
**	 memory allocation is successful
*/

void            OpenSubPicAlloc(IN PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PHW_DEVICE_EXTENSION pdevext =
    ((PHW_DEVICE_EXTENSION) pSrb->HwDeviceExtension);

    PSTREAMEX       strm = (PSTREAMEX) pSrb->StreamObject->HwStreamExtension;

    //
    // attempt to allocate the locked memory area
    //

    if (!(strm->spstrmex.pdecctl.pData = (PVOID)
          ExAllocatePool(NonPagedPool, SP_MAX_INPUT_BUF))) {

        //
        // could not allocate the memory, so fail the open
        //

        pSrb->Status = STATUS_NO_MEMORY;
    }
    //
    // set some more ugly globals
    //

    pSPstrmex = &(strm->spstrmex);

    //
    // srb completions cannot be called back at low priority, so we need
    // to change the priority back to high here
    //

    StreamClassCallAtNewPriority(pSrb->StreamObject,
                                 pdevext,
                                 LowToHigh,
                                 (PHW_PRIORITY_ROUTINE) AdapterCB,
                                 pSrb);

}

/*
** AdapterCB ()
**
**   routine to callback adapter srbs
**
** Arguments:
**
**   pSrb - request to callback
**
** Returns:
**
** Side Effects:
*/

void            AdapterCB(IN PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PHW_DEVICE_EXTENSION pdevext =
    ((PHW_DEVICE_EXTENSION) pSrb->HwDeviceExtension);

    StreamClassDeviceNotification(ReadyForNextDeviceRequest,
                                  pSrb->HwDeviceExtension);

    StreamClassDeviceNotification(DeviceRequestComplete,
                                  pSrb->HwDeviceExtension,
                                  pSrb);
}

/*
** AdapterReceivePacket ()
**
**   main entry point for receiving an adapter based SRB
**
** Arguments:
**
**   pSrb
**
** Returns:
**
** Side Effects:
*/

VOID            STREAMAPI
                AdapterReceivePacket(IN PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PHW_DEVICE_EXTENSION pdevext =
    ((PHW_DEVICE_EXTENSION) pSrb->HwDeviceExtension);

    //
    // determine the type of packet.
    //
    // Note:  any command type that may require additional processing
    // asyncronously
    // must deal with the ready for next request, and request complete
    // callbacks
    // individually, and will return from the following case statement.
    // All other cases will be called back automatically following.
    //

    switch (pSrb->Command) {

    case SRB_OPEN_STREAM:

        //
        // this command requests the minidriver to prepare structures
        // and initialize a stream instance
        //

        MPTrace(mTraceOpen);

        AdapterOpenStream(pSrb);

        return;

    case SRB_GET_STREAM_INFO:

        AdapterStreamInfo(pSrb);
        MPTrace(mTraceInfo);
        break;

    case SRB_INITIALIZE_DEVICE:

        MPTrace(mTraceInit);
        HwInitialize(pSrb);

        break;

    case SRB_CLOSE_STREAM:

        MPTrace(mTraceClose);
        AdapterCloseStream(pSrb);

        pSrb->Status = STATUS_SUCCESS;

        break;

	case SRB_CHANGE_POWER_STATE:

        if (pSrb->CommandData.DeviceState == PowerDeviceD0) {

            //
            // bugbug - need to turn power back on here.
            //

        } else {

            //
            // bugbug - need to turn power off here, as well as disabling
            // interrupts.
            //

            DisableIT();
        }

        pSrb->Status = STATUS_SUCCESS;

        break;

    case SRB_PAGING_OUT_DRIVER:

        //
        // ensure that the minidriver cannot receive interrupts while the
        // interrupt handler is paged out!
        //

        DisableIT();

        pSrb->Status = STATUS_SUCCESS;

        break;


    case SRB_GET_DATA_INTERSECTION:

        HwProcessDataIntersection(pSrb);
        break;

    case SRB_UNINITIALIZE_DEVICE:

        MPTrace(mTraceUnInit);
        HwUnInitialize(pSrb->HwDeviceExtension);

        pSrb->Status = STATUS_SUCCESS;

        break;

    default:

        MPTrace(mTraceUnknown);
        pSrb->Status = STATUS_NOT_IMPLEMENTED;

        break;


    }


    //
    // callback the device request
    //


    AdapterCB(pSrb);
}


/*
** AdapterStreamInfo ()
**
**   return the information on the stream types (number of pins) available
**	 in this hardware
**
** Arguments:
**
**   pSrb -> command SRB
**
** Returns:
**
** Side Effects:
*/

VOID
AdapterStreamInfo(PHW_STREAM_REQUEST_BLOCK pSrb)
{

    PHW_DEVICE_EXTENSION pdevext =
    ((PHW_DEVICE_EXTENSION) pSrb->HwDeviceExtension);

    PHW_STREAM_INFORMATION pstrinfo = &(pSrb->CommandData.StreamBuffer->StreamInfo);

    pSrb->CommandData.StreamBuffer->StreamHeader.NumberOfStreams =
        NUMBER_OF_STREAMS;

    pSrb->CommandData.StreamBuffer->StreamHeader.SizeOfHwStreamInformation =
        sizeof(HW_STREAM_INFORMATION);

    //
    // store a pointer to the topology for the device
    //

    pSrb->CommandData.StreamBuffer->StreamHeader.Topology = (PKSTOPOLOGY) & Topology;


    //
    // set up the stream info structures for the MPEG2 video
    //

    pstrinfo->NumberOfPossibleInstances = 1;
    // stream can be opened only once

    pstrinfo->DataFlow = KSPIN_DATAFLOW_IN;
    // indicates data flows into this stream from an external
    // source

    pstrinfo->DataAccessible = TRUE;

    pstrinfo->NumberOfFormatArrayEntries = 1;
    // number of formats supported

    pstrinfo->StreamFormatsArray = Mpeg2VidInfo;

    pstrinfo->NumStreamPropArrayEntries = 2;
    // number of property SETS that are supported (each set
    // may have more than one property supported within it

    pstrinfo->StreamPropertiesArray = (PKSPROPERTY_SET) mpegVidPropSet;

    pstrinfo++;

    //
    // set up the stream info structures for the MPEG2 audio
    //

    pstrinfo->NumberOfPossibleInstances = 1;
    pstrinfo->DataFlow = KSPIN_DATAFLOW_IN;
    pstrinfo->DataAccessible = TRUE;
    pstrinfo->NumberOfFormatArrayEntries = 1;
    pstrinfo->StreamFormatsArray = AC3AudioInfo;
    pstrinfo->NumStreamPropArrayEntries = 2;
    pstrinfo->StreamPropertiesArray = (PKSPROPERTY_SET) audPropSet;

	pstrinfo->StreamEventsArray = ClockEventSet;
	pstrinfo->NumStreamEventArrayEntries = SIZEOF_ARRAY(ClockEventSet);

    pstrinfo++;

    //
    // set up the stream info structures for the MPEG2 NTSC stream
    //

    pstrinfo->NumberOfPossibleInstances = 1;
    pstrinfo->DataFlow = KSPIN_DATAFLOW_OUT;
    pstrinfo->DataAccessible = FALSE;
    pstrinfo->NumberOfFormatArrayEntries = 1;
    pstrinfo->StreamFormatsArray = NtscInfo;
    pstrinfo->NumStreamPropArrayEntries = 0;
    pstrinfo->StreamPropertiesArray = (PKSPROPERTY_SET) NTSCPropSet;

    pstrinfo++;

    //
    // set up the stream info structures for the MPEG2 subpicture
    //

    pstrinfo->NumberOfPossibleInstances = 1;
    pstrinfo->DataFlow = KSPIN_DATAFLOW_IN;
    pstrinfo->DataAccessible = TRUE;
    pstrinfo->NumberOfFormatArrayEntries = 1;
    pstrinfo->StreamFormatsArray = SubPicInfo;
    pstrinfo->NumStreamPropArrayEntries = 2;
    pstrinfo->StreamPropertiesArray = (PKSPROPERTY_SET) SPPropSet;

    pstrinfo++;
    //
    // set up the stream info structures for the Video Port
    //
    pstrinfo->NumberOfPossibleInstances = 1;
    pstrinfo->DataFlow = KSPIN_DATAFLOW_OUT;
    pstrinfo->DataAccessible = TRUE;
    pstrinfo->NumberOfFormatArrayEntries = 1;
    pstrinfo->StreamFormatsArray = VPInfo;
    pstrinfo->NumStreamPropArrayEntries = 1;
    pstrinfo->StreamPropertiesArray = (PKSPROPERTY_SET) VideoPortPropSet;


	pstrinfo->StreamEventsArray = VPEventSet;
	pstrinfo->NumStreamEventArrayEntries = SIZEOF_ARRAY(VPEventSet);

    pstrinfo++;

    //
    // set up the stream info structures for the Close Caption stream
    //

    pstrinfo->NumberOfPossibleInstances = 1;
    pstrinfo->DataFlow = KSPIN_DATAFLOW_OUT;
    pstrinfo->DataAccessible = TRUE;
    pstrinfo->NumberOfFormatArrayEntries = 1;
    pstrinfo->StreamFormatsArray = CCInfo;

    pstrinfo->NumStreamPropArrayEntries = 1;
    pstrinfo->StreamPropertiesArray = (PKSPROPERTY_SET) CCPropSet;

    pSrb->Status = STATUS_SUCCESS;

}

/*
** StreamReceiveDataPacket ()
**
**   dispatch routine for receiving a data packet.  This routine will
**	 dispatch to the appropriate data handler initialized in the stream
**	 extension for this data stream
**
** Arguments:
**
**
**
** Returns:
**
** Side Effects:
*/

VOID            STREAMAPI
                StreamReceiveDataPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PHW_DEVICE_EXTENSION pdevext =
    ((PHW_DEVICE_EXTENSION) pSrb->HwDeviceExtension);


    //
    // determine the type of packet.
    //

    switch (pSrb->Command) {
    case SRB_WRITE_DATA:

        //
        // This is a write data function.  Call the appropriate handler
        // if it exists, otherwise fall through
        //

        if (((PSTREAMEX) pSrb->StreamObject->HwStreamExtension)
            ->pfnWriteData) {
            ((PSTREAMEX) pSrb->StreamObject->HwStreamExtension)
                ->pfnWriteData(pSrb);

            break;
        }
        //
        // NOTE: falls through to default!
        //

    default:

        //
        // invalid / unsupported command. Fail it as such
        //

        TRAP

            pSrb->Status = STATUS_NOT_IMPLEMENTED;

        StreamClassStreamNotification(ReadyForNextStreamDataRequest,
                                      pSrb->StreamObject);

        StreamClassStreamNotification(StreamRequestComplete,
                                      pSrb->StreamObject,
                                      pSrb);


    }
}

/*
** CycEvent ()
**
**    receives notification for stream event enable/ disable
**
** Arguments:}
**
**
**
** Returns:
**
** Side Effects:
*/


STREAMAPI
CycEvent (PHW_EVENT_DESCRIPTOR pEvent)
{
	PSTREAMEX pstrm=(PSTREAMEX)(pEvent->StreamObject->HwStreamExtension);

	if (pEvent->Enable)
	{
		pstrm->EventCount++;
	}
	else
	{
		pstrm->EventCount--;
	}

	return (STATUS_SUCCESS);
}


/*
** StreamReceiveCtrlPacket ()
**
**    main dispatch routine for stream control requests
**
** Arguments:
**
**    pSrb - control request to dispatch
**
** Returns:
**
** Side Effects:
*/

VOID            STREAMAPI
                StreamReceiveCtrlPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PHW_DEVICE_EXTENSION pdevext =
    ((PHW_DEVICE_EXTENSION) pSrb->HwDeviceExtension);
	PSTREAMEX pstrm = (PSTREAMEX) pSrb->StreamObject->HwStreamExtension;

    //
    // set default status
    //

    pSrb->Status = STATUS_SUCCESS;

    //
    // determine the type of packet.  All calls here use the pointers
    // to the individual stream functions initialised at open time
    //

    switch (pSrb->Command) {
    case SRB_SET_STREAM_STATE:

        //
        // change the stream state (i.e.  play or pause)
        //

        if (((PSTREAMEX) pSrb->StreamObject->HwStreamExtension)->pfnSetState) {
            ((PSTREAMEX) pSrb->StreamObject->HwStreamExtension)
                ->pfnSetState(pSrb);
        }
        break;

    case SRB_GET_STREAM_PROPERTY:

        if (((PSTREAMEX) pSrb->StreamObject->HwStreamExtension)->pfnGetProp) {
            ((PSTREAMEX) pSrb->StreamObject->HwStreamExtension)
                ->pfnGetProp(pSrb);
        }
        break;

    case SRB_OPEN_MASTER_CLOCK:
    case SRB_CLOSE_MASTER_CLOCK:

        //
        // BUGBUG - these should be stored individually on a per stream basis,
        // not in a global variable!!

        hMaster = pSrb->CommandData.MasterClockHandle;

        break;

    case SRB_INDICATE_MASTER_CLOCK:

        //
        // BUGBUG - these should be stored individually on a per stream basis,
        // not in a global variable!!
        //

        hClk = pSrb->CommandData.MasterClockHandle;

        break;


    case SRB_SET_STREAM_PROPERTY:

        if (((PSTREAMEX) pSrb->StreamObject->HwStreamExtension)->pfnSetProp) {
            ((PSTREAMEX) pSrb->StreamObject->HwStreamExtension)
                ->pfnSetProp(pSrb);
        }
        break;

    case SRB_PROPOSE_DATA_FORMAT:

        if (((PSTREAMEX) pSrb->StreamObject->HwStreamExtension)->pfnQueryAccept) {
            ((PSTREAMEX) pSrb->StreamObject->HwStreamExtension)
                ->pfnQueryAccept(pSrb);
        }
        break;

/* video rate stuff */
    case SRB_SET_STREAM_RATE:

        //
        // rates should be set on an individual stream basis
        //

            VidRate = 1000;     /* set the rate from the packet here */

        break;
/* end video rate stuff */

    default:

        //
        // invalid / unsupported command. Fail it as such
        //

            pSrb->Status = STATUS_NOT_IMPLEMENTED;

        break;

    }
    mpstCtrlCommandComplete(pSrb);
}

/*
** mpstCtrlCommandComplete ()
**
**    calls back a stream control command, and indicates ready for next
**	  request
**
** Arguments:
**
**    pSrb - Request to commplete
**
** Returns:
**
** Side Effects:
*/

VOID
mpstCtrlCommandComplete(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    StreamClassStreamNotification(
                                  ReadyForNextStreamControlRequest,
                                  pSrb->StreamObject);

    StreamClassStreamNotification(StreamRequestComplete,
                                  pSrb->StreamObject,
                                  pSrb);
}

/*
** AdapterCloseStream ()
**
**    Free up any structures used for a stream, and indicate that it is
**    no longer in use
**
** Arguments:
**
**    pSrb - command for stream to close
**		StreamObject->StreamNumber - indicates the stream number from the
**		    					     streaminfo call to be closed
**		StreamObject->HwStreamExtension - should indicate which instance is
**										  being closed
**
** Returns:
**
** Side Effects:
*/

VOID
AdapterCloseStream(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    extern void     HwCodecReset(void);
    PSTREAMEX       strm = (PSTREAMEX) pSrb->StreamObject->HwStreamExtension;
    PHW_DEVICE_EXTENSION pdevex = (PHW_DEVICE_EXTENSION) pSrb->HwDeviceExtension;

    //
    // NOTE:
    // the whole object will go away, we don't need to clear up any fields
    // from
    // the streamextension, such as all of the pfn functions
    //

    pSrb->Status = STATUS_SUCCESS;

    switch (pSrb->StreamObject->StreamNumber) {
    case strmVideo:

        pdevex->pstroVid = NULL;

        break;

    case strmAc3:

        pdevex->pstroAud = NULL;
        break;

    case strmSubpicture:

        //
        // this is the subpicture stream, free up any allocated buffers
        //

        if (strm->spstrmex.pdecctl.pData) {
            ExFreePool(strm->spstrmex.pdecctl.pData);
        }
        if (strm->spstrmex.pdecctl.pTopWork) {
            ExFreePool(strm->spstrmex.pdecctl.pTopWork);
        }
        strm->spstrmex.pdecctl.cDecod = 0;
        strm->spstrmex.pdecctl.pData = 0;
        strm->spstrmex.pdecctl.pTopWork = 0;

        pSPstrmex = 0;

        break;

	case strmYUVVideo:

		pdevex->pstroYUV = NULL;

		break;
	case strmCCOut:

		CleanCCQueue();
		pdevex->pstroCC = NULL;

		break;

    }

}

DWORD           CDMAadr;

/*
** HwInitialize ()
**
**    Performs all board, IRQ and structure initialization for this instance
**    of the adapter
**
** Arguments:
**
**    pSrb -> command block
**    pSrb->CommandData.ConfigInfo -> points to configuration information structure
**
** Returns:
**	  pSrb->Status set to status of intialization
**
** Side Effects:
*/

NTSTATUS
HwInitialize(
             IN PHW_STREAM_REQUEST_BLOCK pSrb)
{
    STREAM_PHYSICAL_ADDRESS adr;
    ULONG           Size;
    PUCHAR          pDmaBuf;


    PPORT_CONFIGURATION_INFORMATION ConfigInfo = pSrb->CommandData.ConfigInfo;
    PHW_DEVICE_EXTENSION pHwDevExt =
    (PHW_DEVICE_EXTENSION) ConfigInfo->HwDeviceExtension;

	RtlZeroMemory(pHwDevExt, sizeof (PHW_DEVICE_EXTENSION));

    //
    // this board requires at least one memory access range
    //

    if (ConfigInfo->NumberOfAccessRanges < 1) {
        DebugPrint((DebugLevelVerbose, "ST3520: illegal config info"));

        pSrb->Status = STATUS_NO_SUCH_DEVICE;
        return (FALSE);
    }
    DebugPrint((DebugLevelVerbose, "No of access ranges = %lx", ConfigInfo->NumberOfAccessRanges));

    //
    // the first access range according to this boards inf will be the
    // main PIO address base
    //

    pHwDevExt->ioBaseLocal = (PUSHORT) (ULONG_PTR) (ConfigInfo->AccessRanges[0].RangeStart.LowPart);

    DebugPrint((DebugLevelVerbose, "Memory Range = %lx\n", pHwDevExt->ioBaseLocal));
    DebugPrint((DebugLevelVerbose, "IRQ = %lx\n", ConfigInfo->BusInterruptLevel));

    //
    // pick up the irq level
    //

    pHwDevExt->Irq = (USHORT) (ConfigInfo->BusInterruptLevel);

    //
    // intiialize some stuff in the hwdevice extension here
    //

    pHwDevExt->VideoDeviceExt.videoSTC = 0;
    pHwDevExt->AudioDeviceExt.audioSTC = 0;
    pHwDevExt->AudioDeviceExt.pCurrentSRB = NULL;
    pHwDevExt->VideoDeviceExt.pCurrentSRB = NULL;
    pHwDevExt->AudioDeviceExt.pCurrentSRB = NULL;
    pHwDevExt->VideoDeviceExt.pCurrentSRB = NULL;
    pHwDevExt->VideoDeviceExt.pCurrentSRB = NULL;
    pHwDevExt->AudioDeviceExt.pCurrentSRB = NULL;
    pHwDevExt->VideoDeviceExt.DeviceState = KSSTATE_PAUSE;
    pHwDevExt->AudioDeviceExt.DeviceState = KSSTATE_PAUSE;

    //
    // indicate the size of the structure necessary to descrive all streams
    // that are supported by this hardware
    //

    ConfigInfo->StreamDescriptorSize =
        NUMBER_OF_STREAMS * sizeof(HW_STREAM_INFORMATION) +
        sizeof(HW_STREAM_HEADER);

    //
    // allocate the DMA buffer here
    //

    pDmaBuf = StreamClassGetDmaBuffer(pHwDevExt);

    //
    // pick up the physical address for the DMA buffer
    //

    adr = StreamClassGetPhysicalAddress(pHwDevExt, NULL, pDmaBuf, DmaBuffer, &Size);
    CDMAadr = adr.LowPart;      // chieh for HwCodecReset

    bInitialized = TRUE;

    //
    // make sure the hardware seems to be working ...
    //

    if (HwCodecOpen((ULONG_PTR) (pHwDevExt->ioBaseLocal), pDmaBuf, (ULONG) (adr.LowPart)))
	{
        pSrb->Status = STATUS_SUCCESS;

		pDevEx = pHwDevExt;
	}

    else
        pSrb->Status = STATUS_NO_SUCH_DEVICE;

    DebugPrint((DebugLevelVerbose, "Exit : HwInitialize()\n"));

    return TRUE;
}

/*
** HwUnInitialize ()
**
**   prepare this instance of the adapter to be removed by plug and play
**
** Arguments:
**
**
**
** Returns:
**
** Side Effects:
*/

BOOLEAN
HwUnInitialize(IN PVOID DeviceExtension)
{
    HwCodecClose();
    return TRUE;
}

/*
** HwInterrupt ()
**
**   entry point for hardware interrupts
**
** Arguments:
**
**   pointer to the device extension for this instance of the adapter
**
** Returns:
**
**   TRUE if this interrupt was for this adapter, and was handled by this
**		  routine
**	 FALSE if this interrupt was not generated by the device represented
**        by this hardware device extension
**
** Side Effects:
*/

BOOLEAN
HwInterrupt(IN PVOID pDeviceExtension)
{
    BOOLEAN         bRetValue;
    PHW_DEVICE_EXTENSION pdevext = (PHW_DEVICE_EXTENSION) pDeviceExtension;


    if (!bInitialized)
        return FALSE;

    //
    // this hardware needs to ensure that additional interrupts are not
    // generated at the hardware while interrupts are being processed,
    // so it enables and disables interrupts around the processing
    //


    HwCodecDisableIRQ();

    bRetValue = (BOOLEAN)HwCodecInterrupt();
    HwCodecEnableIRQ();

    //
    // NOTE: this next code restarts DMA of Video data if there is any
    // room available.
    //

    if (pdevext->VideoDeviceExt.pCurrentSRB)
        VideoPacketStub(pdevext->VideoDeviceExt.pCurrentSRB->StreamObject);

    if (pdevext->AudioDeviceExt.pCurrentSRB)
        AudioPacketStub(pdevext->AudioDeviceExt.pCurrentSRB->StreamObject);

    return bRetValue;
}

static          fEnabled = FALSE;

/*
** DisableIT ()
**
**    disable board interrupts
**
** Arguments:
**
**
**
** Returns:
**
** Side Effects:
*/

VOID
DisableIT(VOID)
{
    HwCodecDisableIRQ();

    fEnabled = FALSE;
}

/*
** EnableIT ()
**
**   enable board interrupts
**
** Arguments:
**
**
**
** Returns:
**
** Side Effects:
*/

VOID
EnableIT(VOID)
{
    if (!fEnabled) {
        HwCodecEnableIRQ();
    }
    fEnabled = TRUE;

}

/*
** HostDisableIT ()
**
**   null routine at the moment
**
** Arguments:
**
**
**
** Returns:
**
** Side Effects:
*/

VOID
HostDisableIT(VOID)
{
}

/*
** HostEnableIT ()
**
**  equally null routine
**
** Arguments:
**
**
**
** Returns:
**
** Side Effects:
*/

VOID
HostEnableIT(VOID)
{
}

/*
** NTSCSetProp ()
**
**   Set property handling routine for the NTSC encoder pin
**
** Arguments:
**
**   pSrb -> property command block
**   pSrb->CommandData.PropertyInfo describes the requested property
**
** Returns:
**
** Side Effects:
*/

void
NTSCSetProp(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    if (pSrb->CommandData.PropertyInfo->PropertySetID) {
        // invalid property

        pSrb->Status = STATUS_NOT_IMPLEMENTED;
        return;
    }

	switch(pSrb->CommandData.PropertyInfo->Property->Id)
	{
	case KSPROPERTY_COPY_MACROVISION:

		//
		// pick up the macrovision level, and set the level accordingly
		//
		// SetMacroVisionLevel(
		//			pSrb->CommandData.PropertyInfo->PropertyInfo);
		//

		pSrb->Status = STATUS_SUCCESS;
		break;

	default:

		pSrb->Status = STATUS_NOT_IMPLEMENTED;
		break;
	}
}


/*
** NTSCGetProp ()
**
**   get property handling routine for the NTSC encoder pin
**
** Arguments:
**
**   pSrb -> property command block
**   pSrb->CommandData.PropertyInfo describes the requested property
**
** Returns:
**
** Side Effects:
*/

void
NTSCGetProp(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    if (pSrb->CommandData.PropertyInfo->PropertySetID) {
        // invalid property

        pSrb->Status = STATUS_NOT_IMPLEMENTED;
        return;
    }

	pSrb->Status = STATUS_NOT_IMPLEMENTED;

}


/*
** CCGetProp ()
**
**   get property handling routine for the Close caption pin
**
** Arguments:
**
**   pSrb -> property command block
**   pSrb->CommandData.PropertyInfo describes the requested property
**
** Returns:
**
** Side Effects:
*/

void
CCGetProp(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	PHW_DEVICE_EXTENSION pdevex =
		((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);

	PKSALLOCATOR_FRAMING pfrm = (PKSALLOCATOR_FRAMING)
				pSrb->CommandData.PropertyInfo->PropertyInfo;

	PKSSTATE State;

	pSrb->Status = STATUS_NOT_IMPLEMENTED;

    if (pSrb->CommandData.PropertyInfo->PropertySetID) {
        // invalid property

        return;
    }


	switch(pSrb->CommandData.PropertyInfo->Property->Id)
	{
	case KSPROPERTY_CONNECTION_ALLOCATORFRAMING:

		pfrm->OptionsFlags = 0;
		pfrm->PoolType = 0;
		pfrm->Frames = 10;
		pfrm->FrameSize = 200;
		pfrm->FileAlignment = 0;
		pfrm->Reserved = 0;

		pSrb->ActualBytesTransferred = sizeof(KSALLOCATOR_FRAMING);

		pSrb->Status = STATUS_SUCCESS;

		break;

	case KSPROPERTY_CONNECTION_STATE:


		State= (PKSSTATE) pSrb->CommandData.PropertyInfo->PropertyInfo;

		pSrb->ActualBytesTransferred = sizeof (State);
																		
		// A very odd rule:
		// When transitioning from stop to pause, DShow tries to preroll
		// the graph.  Capture sources can't preroll, and indicate this
		// by returning VFW_S_CANT_CUE in user mode.  To indicate this
		// condition from drivers, they must return ERROR_NO_DATA_DETECTED
																		
			*State = ((PSTREAMEX)(pdevex->pstroCC->HwStreamExtension))->state;
		
			if (((PSTREAMEX)pdevex->pstroCC->HwStreamExtension)->state == KSSTATE_PAUSE)
			{
				//
				// wierd stuff for capture type state change.  When you transition
				// from stop to pause, we need to indicate that this device cannot
				// preroll, and has no data to send.
				//
		
				pSrb->Status = STATUS_NO_DATA_DETECTED;
		
				return;
			}
		
				pSrb->Status = STATUS_SUCCESS;


		break;

	default:

		TRAP

		pSrb->Status = STATUS_NOT_IMPLEMENTED;
	}


}



/*
** VPESetProp ()
**
**   Set property handling routine for the Video Port Extensions pin
**
** Arguments:
**
**   pSrb -> property command block
**   pSrb->CommandData.PropertyInfo describes the requested property
**
** Returns:
**
** Side Effects:
*/

void
VPESetProp(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PHW_DEVICE_EXTENSION pdevex = (PHW_DEVICE_EXTENSION) pSrb->HwDeviceExtension;
	DWORD dwInputBufferSize;
	DWORD dwOutputBufferSize;
	DWORD *lpdwOutputBufferSize;

	PKS_AMVPSIZE pDim;

	dwInputBufferSize  = pSrb->CommandData.PropertyInfo->PropertyInputSize;
	dwOutputBufferSize = pSrb->CommandData.PropertyInfo->PropertyOutputSize;
	lpdwOutputBufferSize = &(pSrb->ActualBytesTransferred);

	pSrb->Status = STATUS_SUCCESS;

	switch(pSrb->CommandData.PropertyInfo->Property->Id)
	{
			case KSPROPERTY_VPCONFIG_SETCONNECTINFO:

				//
				// pSrb->CommandData.PropertInfo->PropertyInfo
				// points to a ULONG which is an index into the array of
				// connectinfo structs returned to the caller from the
				// Get call to ConnectInfo.
				//
				// Since the sample only supports one connection type right
				// now, we will ensure that the requested index is 0.
				//

				switch (*(PULONG)pSrb->CommandData.PropertyInfo->PropertyInfo)
				{
				case 0:

					//
					// at this point, we would program the hardware to use
					// the right connection information for the videoport.
					// since we are only supporting one connection, we don't
					// need to do anything, so we will just indicate success
                    //

					break;

				default:

					pSrb->Status = STATUS_NO_MATCH;
					break;
				}

				break;

			case KSPROPERTY_VPCONFIG_DDRAWHANDLE:
		
				pdevex->ddrawHandle =
					 (*(PULONG)pSrb->CommandData.PropertyInfo->PropertyInfo);
		
	

				break;
		
			case KSPROPERTY_VPCONFIG_VIDEOPORTID:

				pdevex->VidPortID =
					 (*(PULONG)pSrb->CommandData.PropertyInfo->PropertyInfo);
		
			
				break;
	case KSPROPERTY_VPCONFIG_DDRAWSURFACEHANDLE:

				pdevex->SurfaceHandle =
					 (*(PULONG)pSrb->CommandData.PropertyInfo->PropertyInfo);
		
			

				break;

			case KSPROPERTY_VPCONFIG_SETVIDEOFORMAT:
		
				//
				// pSrb->CommandData.PropertInfo->PropertyInfo
				// points to a ULONG which is an index into the array of
				// VIDEOFORMAT structs returned to the caller from the
				// Get call to FORMATINFO
				//
				// Since the sample only supports one FORMAT type right
				// now, we will ensure that the requested index is 0.
				//
		
				switch (*(PULONG)pSrb->CommandData.PropertyInfo->PropertyInfo)
				{
				case 0:
		
					//
					// at this point, we would program the hardware to use
					// the right connection information for the videoport.
					// since we are only supporting one connection, we don't
					// need to do anything, so we will just indicate success
					//
		
					break;
		
				default:
		
					pSrb->Status = STATUS_NO_MATCH;
					break;
				}
		
				break;
	
			case KSPROPERTY_VPCONFIG_INFORMVPINPUT:

				//
				// These are the preferred formats for the VPE client
				//
				// they are multiple properties passed in, return success
				//

				pSrb->Status = STATUS_NOT_IMPLEMENTED;

				break;
							
			case KSPROPERTY_VPCONFIG_INVERTPOLARITY:

				//
				// Toggles the global polarity flag, telling the output
				// of the VPE port to be inverted.  Since this hardware
				// does not support this feature, we will just return
				// success for now, although this should be returning not
				// implemented
				//

				break;


			case KSPROPERTY_VPCONFIG_SCALEFACTOR:

				//
				// the sizes for the scaling factor are passed in, and the
				// image dimensions should be scaled appropriately
				//

				//
				// if there is a horizontal scaling available, do it here.
				//

				TRAP

				pDim =(PKS_AMVPSIZE)(pSrb->CommandData.PropertyInfo->PropertyInfo);

				if (pDim->dwWidth != VPFmt.amvpDimInfo.dwFieldWidth - 63)
				{
					TRAP

					DbgPrint("CYCLO: setting scaling to %d, %d\n",
						VPFmt.amvpDimInfo.dwFieldWidth - 63,pDim->dwWidth);

					VideoSetSRC(VPFmt.amvpDimInfo.dwFieldWidth - 63,pDim->dwWidth);

					VideoSwitchSRC(TRUE);
				}
				else
				{
					TRAP

					VideoSwitchSRC(FALSE);
				}



				break;

			default:
				TRAP
				pSrb->Status = STATUS_NOT_IMPLEMENTED;
				break;
	}

}

/*
** VPEGetProp ()
**
**	  function to handle any of the Get property calls for the VPE
**    pin
**
** Arguments:
**
**    pSrb - packet for Getting the property
**	  pSrb->CommandData.PropertyInfo -> describes the property
**
** Returns:
**
** Side Effects:
*/

void            VPEGetProp(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	DWORD dwInputBufferSize;
	DWORD dwOutputBufferSize;
	DWORD dwNumConnectInfo = 1;
	DWORD dwNumVideoFormat = 1;
	unsigned long ulFourCC = MKFOURCC('Y', 'U', 'Y', '2');
	DWORD dwFieldWidth = 783;
	DWORD dwFieldHeight = 258;

	ULONG lc;

	// the pointers to which the input buffer will be cast to
	LPDDVIDEOPORTCONNECT pConnectInfo;
	LPDDPIXELFORMAT pVideoFormat;
	PKSVPMAXPIXELRATE pMaxPixelRate;
	PKS_AMVPDATAINFO pVpdata;

	// LPAMSCALINGINFO pScaleFactor;

	//
	// NOTE:  ABSOLUTELY DO NOT use pmulitem, until it is determined that
	// the stream property descriptor describes a multiple item, or you will
	// pagefault.
	//

    PKSMULTIPLE_ITEM  pmulitem =
		&(((PKSMULTIPLE_DATA_PROP)pSrb->CommandData.PropertyInfo->Property)->MultipleItem);

	//
	// NOTE: same goes for this one as above.
	//

	PKS_AMVPSIZE pdim =
	&(((PKSVPSIZE_PROP)pSrb->CommandData.PropertyInfo->Property)->Size);

	if(pSrb->CommandData.PropertyInfo->PropertySetID)
	{
			// invalid property

			pSrb->Status = STATUS_NOT_IMPLEMENTED;

			return;
	}

	dwInputBufferSize = pSrb->CommandData.PropertyInfo->PropertyInputSize;
	dwOutputBufferSize = pSrb->CommandData.PropertyInfo->PropertyOutputSize;

	pSrb->Status = STATUS_SUCCESS;

	switch(pSrb->CommandData.PropertyInfo->Property->Id)
	{
			case KSPROPERTY_VPCONFIG_NUMCONNECTINFO:
		
				//
				// specify the number of bytes written
				//

				pSrb->ActualBytesTransferred = sizeof(DWORD);
		
				*(PULONG) pSrb->CommandData.PropertyInfo->PropertyInfo
						 = dwNumConnectInfo;
				break;

			case KSPROPERTY_VPCONFIG_NUMVIDEOFORMAT:

				//
				// specify the number of bytes written
				//

				pSrb->ActualBytesTransferred = sizeof(DWORD);
		
				*(PULONG) pSrb->CommandData.PropertyInfo->PropertyInfo
						= dwNumVideoFormat;
				break;
		
			case KSPROPERTY_VPCONFIG_GETCONNECTINFO:

				//
				// check that the size of the output buffer is correct
				//

				if (pmulitem->Count > dwNumConnectInfo ||
					pmulitem->Size != sizeof (DDVIDEOPORTCONNECT) ||
					dwOutputBufferSize <
					(pmulitem->Count * sizeof (DDVIDEOPORTCONNECT)))

				{
					TRAP

					//
					// buffer size is invalid, so error the call
					//

					pSrb->Status = STATUS_INVALID_BUFFER_SIZE;

					return;
				}


				//
				// specify the number of bytes written
				//

				pSrb->ActualBytesTransferred = pmulitem->Count*sizeof(DDVIDEOPORTCONNECT);

				for (lc = 0,
						pConnectInfo = (LPDDVIDEOPORTCONNECT)(pSrb->CommandData.
						PropertyInfo->PropertyInfo);
					 lc <pmulitem->Count;
					 lc++,
						pConnectInfo++)
				{
					//
					// fill in the values
					//

					pConnectInfo->dwSize = sizeof (DDVIDEOPORTCONNECT);
					pConnectInfo->guidTypeID = g_S3Guid; //DDVPTYPE_E_HREFL_VREFL;
					pConnectInfo->dwPortWidth = 8;
					pConnectInfo->dwFlags = 0x3F;
				}


				break;

			case KSPROPERTY_VPCONFIG_VPDATAINFO:

				//
				// specify the number of bytes written
				//

				pSrb->ActualBytesTransferred = sizeof(KS_AMVPDATAINFO);

				//
				// cast the buffer to the porper type
				//
				pVpdata = (PKS_AMVPDATAINFO)pSrb->CommandData.PropertyInfo->PropertyInfo;

				pVpdata->dwSize = sizeof (KS_AMVPDATAINFO);
				//
				// set up the current region
				//

				*pVpdata = VPFmt;


				// fill in the values
				pVpdata->dwMicrosecondsPerField        	= 17;

				pVpdata->bEnableDoubleClock    	       	= FALSE;
				pVpdata->bEnableVACT           	       	= FALSE;
				pVpdata->bDataIsInterlaced             	= TRUE;
				pVpdata->lHalfLinesOdd               	= 1;
				pVpdata->lHalfLinesEven               	= 0;
				pVpdata->bFieldPolarityInverted		   	= FALSE;
				break ;
							
			case KSPROPERTY_VPCONFIG_MAXPIXELRATE:

				//
				// NOTE:
				// this property is special.  And has another different
				// input property!
				//

				if (dwInputBufferSize < sizeof (KSVPSIZE_PROP))
				{
					TRAP

					pSrb->Status = STATUS_INVALID_BUFFER_SIZE;

					return;
				}

				//
				// note: pdim specfies the dimensions requested for
				// the output image pixel rate.  Please use these to
				// determine your real rate.  It's late Sunday night, and
				// we don't have time to actually look at these in this
				// sample code ... :-)
				//

				//
				// specify the number of bytes written
				//

				pSrb->ActualBytesTransferred = sizeof(KSVPMAXPIXELRATE);

				//
				// cast the buffer to the porper type
				//

				pMaxPixelRate = (PKSVPMAXPIXELRATE)pSrb->CommandData.PropertyInfo->PropertyInfo;

				// tell the app that the pixel rate is valid for these dimensions
				pMaxPixelRate->Size.dwWidth  	= dwFieldWidth;
				pMaxPixelRate->Size.dwHeight 	= dwFieldHeight;
				pMaxPixelRate->MaxPixelsPerSecond	= 1300;
				break;
							
			case KSPROPERTY_VPCONFIG_INFORMVPINPUT:

				pSrb->Status = STATUS_NOT_IMPLEMENTED;

				break ;

	case KSPROPERTY_VPCONFIG_GETVIDEOFORMAT:


					//
					// check that the size of the output buffer is correct
					//

					if (pmulitem->Count > dwNumConnectInfo ||
						pmulitem->Size != sizeof (DDPIXELFORMAT) ||
						dwOutputBufferSize <
						(pmulitem->Count * sizeof (DDPIXELFORMAT)))

					{
						TRAP

						//
						// buffer size is invalid, so error the call
						//

						pSrb->Status = STATUS_INVALID_BUFFER_SIZE;

						return;
					}


					//
					// specify the number of bytes written
					//

					pSrb->ActualBytesTransferred = pmulitem->Count*sizeof(DDPIXELFORMAT);

					for (lc = 0,
						    pVideoFormat = (LPDDPIXELFORMAT)(pSrb->CommandData.
							PropertyInfo->PropertyInfo);
						 lc <pmulitem->Count;
						 lc++,
							pVideoFormat++)
					{
						//
						// fill in the values
						//

						pVideoFormat->dwFlags = DDPF_FOURCC;
						pVideoFormat->dwYUVBitCount = 16;
						pVideoFormat->dwSize= sizeof (DDPIXELFORMAT);
						pVideoFormat->dwFourCC = ulFourCC;

					}


				break;

			case KSPROPERTY_VPCONFIG_DECIMATIONCAPABILITY:

				//
				// indicate that we can decimate anything, especially if it's late.
				//

				pSrb->ActualBytesTransferred = sizeof (BOOL);
				*((PBOOL)pSrb->CommandData.PropertyInfo->PropertyInfo) = TRUE;
				break;

			default:
				pSrb->Status = STATUS_NOT_IMPLEMENTED;
            break;
	}
}

/*
** HwProcessDataIntersection ()
**
**
**
** Arguments:
**
**
**
** Returns:
**
** Side Effects:
*/

VOID
HwProcessDataIntersection(PHW_STREAM_REQUEST_BLOCK pSrb)
{

    NTSTATUS        Status = STATUS_SUCCESS;
    PSTREAM_DATA_INTERSECT_INFO IntersectInfo;
    PKSDATARANGE    DataRange;
    PKSDATAFORMAT   pFormat = NULL;
    ULONG           formatSize;

    //
    // BUGBUG - this is a tempory implementation.   We need to compare
    // the data types passed in and error if the ranges don't overlap.
    // we also need to return valid format blocks, not just the data range.
    //

    IntersectInfo = pSrb->CommandData.IntersectInfo;

    switch (IntersectInfo->StreamNumber) {
/*
    case strmVideo:

        pFormat = &hwfmtiMpeg2Vid;
        formatSize = sizeof hwfmtiMpeg2Vid;
        break;

    case strmAc3:

        pFormat = &hwfmtiMpeg2Aud;
        formatSize = sizeof hwfmtiMpeg2Aud;
        break;

    case strmNTSCVideo:

        pFormat = &hwfmtiNTSCOut;
        formatSize = sizeof hwfmtiNTSCOut;
        break;

    case strmSubpicture:

        pFormat = &hwfmtiSubPic;
        formatSize = sizeof hwfmtiSubPic;
        break;
*/
	case strmYUVVideo:

        pFormat = &hwfmtiVPOut;
        formatSize = sizeof hwfmtiVPOut;
        break;

	case strmCCOut:

        pFormat = &hwfmtiCCOut;
        formatSize = sizeof hwfmtiCCOut;
        break;

	default:
			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			return;
        TRAP;

    }                           // end streamnumber switch

    if (pFormat) {

        //
        // do a minimal compare of the dataranges to at least verify
        // that the guids are the same.
        // BUGBUG - this is woefully incomplete.
        //

        DataRange = IntersectInfo->DataRange;

        if (!(IsEqualGUID(&DataRange->MajorFormat,
                          &pFormat->MajorFormat) &&
              IsEqualGUID(&DataRange->Specifier,
                          &pFormat->Specifier))) {

            Status = STATUS_NO_MATCH;

        } else {                // if guids are equal


            //
            // check to see if the size of the passed in buffer is a ULONG.
            // if so, this indicates that we are to return only the size
            // needed, and not return the actual data.
            //

            if (IntersectInfo->SizeOfDataFormatBuffer != sizeof(ULONG)) {

                //
                // we are to copy the data, not just return the size
                //

                if (IntersectInfo->SizeOfDataFormatBuffer < formatSize) {

                    Status = STATUS_BUFFER_TOO_SMALL;

                } else {        // if too small

                    RtlCopyMemory(IntersectInfo->DataFormatBuffer,
                                  pFormat,
                                  formatSize);

                    pSrb->ActualBytesTransferred = formatSize;

					Status = STATUS_SUCCESS;

                }               // if too small

            } else {            // if sizeof ULONG specified

                //
                // caller wants just the size of the buffer.  Get that.
                //

                *(PULONG) IntersectInfo->DataFormatBuffer = formatSize;
                pSrb->ActualBytesTransferred = sizeof(ULONG);

            }                   // if sizeof ULONG

        }                       // if guids are equal

    } else {                    // if pFormat

        Status = STATUS_NOT_SUPPORTED;
    }                           // if pFormat

    pSrb->Status = Status;

    return;
}

/*
** CCReceiveDataPacket ()
**
**    Receive the data packets to send to the close-caption decoder
**
** Arguments:}
**
**
**
** Returns:
**
** Side Effects:
*/

extern ULONG cCCRec;
extern ULONG cCCDeq;
extern ULONG cCCCB;
ULONG cCCRec = 0;
ULONG cCCDeq = 0;
ULONG cCCCB = 0;

VOID STREAMAPI
CCReceiveDataPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PHW_DEVICE_EXTENSION pdevex =
    ((PHW_DEVICE_EXTENSION) pSrb->HwDeviceExtension);


    //
    // determine the type of packet.
    //

    switch (pSrb->Command) {
	case SRB_READ_DATA:

        //
        // This is a write data function.  Call the appropriate handler
        // if it exists, otherwise fall through
        //

			cCCRec++;

			CCEnqueue(pSrb);

			StreamClassStreamNotification(ReadyForNextStreamDataRequest,
					pSrb->StreamObject);
		
			pSrb->TimeoutOriginal = 0;
			pSrb->TimeoutCounter = 0;

            break;


    default:

        //
        // invalid / unsupported command. Fail it as such
        //

        TRAP

            pSrb->Status = STATUS_NOT_IMPLEMENTED;

        StreamClassStreamNotification(ReadyForNextStreamDataRequest,
                                      pSrb->StreamObject);

        StreamClassStreamNotification(StreamRequestComplete,
                                      pSrb->StreamObject,
                                      pSrb);


    }
}

/*
** CCSetState ()
**
**    set up the state for the current stream
**
** Arguments:
**
**
**
** Returns:
**
** Side Effects:
*/

VOID STREAMAPI
CCSetState(IN PHW_STREAM_REQUEST_BLOCK pSrb)
{
	PHW_DEVICE_EXTENSION pdevex =
		((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);

	((PSTREAMEX)(pdevex->pstroCC->HwStreamExtension))->state = pSrb->CommandData.StreamState;

	pSrb->Status = STATUS_SUCCESS;

}

extern ULONG cCCQ;
ULONG cCCQ =0;

void CCEnqueue(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	PHW_STREAM_REQUEST_BLOCK pSrbTmp;
	ULONG cSrb;


	//
	// enqueue the given SRB on the device extension queue
	//

	for (cSrb =0,
		pSrbTmp = CONTAINING_RECORD((&(pDevEx->pSrbQ)),
			HW_STREAM_REQUEST_BLOCK, NextSRB);
			pSrbTmp->NextSRB;
			pSrbTmp = pSrbTmp->NextSRB, cSrb++);

	pSrbTmp->NextSRB = pSrb;
	pSrb->NextSRB = NULL;

	cCCQ++;
	
}

PHW_STREAM_REQUEST_BLOCK CCDequeue(void)
{
	PHW_STREAM_REQUEST_BLOCK pRet = NULL;

	if (pDevEx->pSrbQ)
	{
		cCCDeq++;

		pRet = pDevEx->pSrbQ;
		pDevEx->pSrbQ = pRet->NextSRB;

		cCCQ--;
	}


	return(pRet);
}

void CleanCCQueue()
{
	PHW_STREAM_REQUEST_BLOCK pSrb;

	while (pSrb = CCDequeue())
	{
		CallBackError(pSrb);
	}

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgs\cpq3520a\mpvideo.h ===
/*******************************************************************
*
*				 MPVIDEO.H
*
*				 Copyright (C) 1995 SGS-THOMSON Microelectronics.
*
*
*				 Prototypes for MPVIDEO.C
*
*******************************************************************/

#ifndef __MPVIDEO_H__
#define __MPVIDEO_H__

VOID VideoEnableInterrupts(IN PVOID);
VOID VideoTimerCallBack(PHW_STREAM_OBJECT pstrm);
ULONG miniPortVideoStop (PHW_STREAM_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
//ULONG miniPortVideoSetStc(PHW_STREAM_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
//ULONG miniPortVideoSetAttribute(PHW_STREAM_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
//ULONG miniPortVideoPlay(PHW_STREAM_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
VOID miniPortVideoPacket(PHW_STREAM_REQUEST_BLOCK);
//ULONG miniPortVideoGetStc(PHW_STREAM_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
//ULONG miniPortVideoGetAttribute(PHW_STREAM_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
//ULONG miniPortVideoEndOfStream(PHW_STREAM_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
//ULONG miniPortVideoDisable(PHW_STREAM_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
//ULONG miniPortVideoEnable(PHW_STREAM_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
//ULONG miniPortClearVideoBuffer(PHW_STREAM_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
//ULONG miniPortCancelVideo(PHW_STREAM_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
ULONG miniPortVideoReset(PHW_STREAM_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
VOID miniPortSetState(PHW_STREAM_REQUEST_BLOCK pSrb);
VOID mpstCtrlCommandComplete(PHW_STREAM_REQUEST_BLOCK pSrb);
void VideoPacketStub(PHW_STREAM_OBJECT pstrm);
VOID miniPortGetProperty(PHW_STREAM_REQUEST_BLOCK pSrb);
//void StubMpegEnableIRQ(PHW_STREAM_OBJECT pstrm);
void ProcessVideoFormat(PKSDATAFORMAT pfmt, PHW_DEVICE_EXTENSION pdevex);
void VideoQueryAccept(PHW_STREAM_REQUEST_BLOCK pSrb);

#endif //__MPVIDEO_H__

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgs\cpq3520a\stdefs.h ===
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
// 	MODULE  : STDEFS.H
//	PURPOSE : Common typedefs
//	AUTHOR  : JBS Yadawa
// 	CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

#ifndef __STDEFS_H

#define __STDEFS_H
#define NEARAPI 
#define FARAPI
#define Trace   0
//typedef BOOLEAN BOOL;
typedef ULONG	DWORD;
typedef USHORT	WORD;
//typedef USHORT  UINT;
typedef UCHAR	BYTE;
typedef PUCHAR		LPBYTE;
typedef PUSHORT	LPWORD;
typedef PULONG		LPDWORD;
//#define FAR
//#define NEAR
#define FARPTR
#if DEBUG
#define TRAP DEBUG_BREAKPOINT();
#else
#define TRAP
#define DbgPrint // 
#endif

#define INPUT  0x01
#define OUTPUT 0x00

#define ON		0x01
#define OFF		0x00

#define DIR(x, y) ((y) << (x))
#define TURN(x, y)  ((y) << (x)) 

#define SETVAL(x, y) ((y) << (x))

#define DPF(x) 

#define PACK_HEADER_SIZE 14

#endif // #ifndef __STDEFS_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgs\cpq3520a\mpinit.h ===
/*******************************************************************
*
*				 MPINIT.H
*
*				 Copyright (C) 1995 SGS-THOMSON Microelectronics.
*
*
*				 Prototypes for MPINIT.C
*
*******************************************************************/

#ifndef __MPINIT_H__
#define __MPINIT_H__

#include <ksmedia.h>
#include "subpic.h"

#define NO_ERROR 0
#ifndef NULL
#define NULL 0
#endif
#define ERROR_CARD_NOT_FOUND 		1
#define ERROR_NOT_ENOUGH_MEMORY  2
#define ERROR_COMMAND_NOT_IMPLEMENTED 3
// BGP #define VIDEO_PACKET_TIMER (10*1000)
#define VIDEO_PACKET_TIMER (5*1000)
#define AUDIO_PACKET_TIMER (10*1000)
#define MEM_WINDOW_SIZE (128*1024)
typedef struct _VIDEO_DEVICE_EXTENSION {
   BOOLEAN 						EOSInProgress;      // End Of Stream ha been sent to device
	KSSTATE 		DeviceState;
	STREAM_SYSTEM_TIME			videoSTC;
	PHW_STREAM_REQUEST_BLOCK  	pCurrentSRB;
   ULONG   						StarvationCount;        // number of times device was starved since last reset
	ULONG	cPacket;									// current packet in process
	ULONG	cOffs;										// offset into the current packet
	PKSSTREAM_HEADER pPacket;
	PKSSTREAM_HEADER pPacketSave;
	PVOID pDMABuf;
} VIDEO_DEVICE_EXTENSION, *PVIDEO_DEVICE_EXTENSION;

typedef struct _AUDIO_DEVICE_EXTENSION {
	STREAM_SYSTEM_TIME		audioSTC;
	KSSTATE 	DeviceState;
	PHW_STREAM_REQUEST_BLOCK  pCurrentSRB;
   ULONG   					StarvationCount;        // number of times device was starved since last reset
	ULONG	  					ByteSent;
	ULONG	cPacket;									// current packet in process
	ULONG	cOffs;										// offset into the current packet
	PKSSTREAM_HEADER pPacket;
} AUDIO_DEVICE_EXTENSION, *PAUDIO_DEVICE_EXTENSION;

typedef struct _HW_DEVICE_EXTENSION {
	KSSTATE stState;
	PUSHORT  					ioBaseLocal;
	PUSHORT  					ioBasePCI9060;
	USHORT						Irq;
	BOOLEAN						bVideoInt;
	BOOLEAN						bAudioInt;
	PHW_STREAM_REQUEST_BLOCK	AudioQ;
	PHW_STREAM_REQUEST_BLOCK	VideoQ;
	VIDEO_DEVICE_EXTENSION 	VideoDeviceExt;
	AUDIO_DEVICE_EXTENSION 	AudioDeviceExt;
	PHW_STREAM_REQUEST_BLOCK pCurSrb;
	PHW_STREAM_REQUEST_BLOCK pSrbQ;
	PHW_STREAM_OBJECT pstroVid;
	PHW_STREAM_OBJECT pstroAud;
	PHW_STREAM_OBJECT pstroYUV;
	PHW_STREAM_OBJECT pstroCC;
	ULONG 						ddrawHandle;
	ULONG						VidPortID;
	ULONG						SurfaceHandle;
} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;

typedef VOID (*PFN_WRITE_DATA)  (PHW_STREAM_REQUEST_BLOCK pSrb);

typedef struct _STREAMEX {
	PFN_WRITE_DATA pfnWriteData;
	PFN_WRITE_DATA pfnSetState;
	PFN_WRITE_DATA pfnGetProp;
	PFN_WRITE_DATA pfnSetProp;
	PFN_WRITE_DATA pfnQueryAccept;
	BOOL EventCount; 
	KSSTATE state;
	HANDLE hClk;
	union {
		SP_STRM_EX spstrmex;
		};

} STREAMEX, *PSTREAMEX;

typedef struct _MRP_EXTENSION {

    ULONG           Status;
} MRP_EXTENSION, * PMRP_EXTENSION;

NTSTATUS HwInitialize (IN PHW_STREAM_REQUEST_BLOCK pSrb );
BOOLEAN HwUnInitialize ( IN PVOID DeviceExtension);
BOOLEAN HwInterrupt ( IN PVOID pDeviceExtension );
VOID AudioEnableInterrupts(IN PVOID pHwDeviceExtension);
VOID STEnableInterrupts( IN PVOID pHwDeviceExtension );
VOID STDeferredCallback ( IN PVOID pHwDeviceExtension );
VOID TmpDeferredCallback ( IN PVOID pHwDeviceExtension );
NTSTATUS
DriverEntry(
            IN PDRIVER_OBJECT DriverObject,
            IN PUNICODE_STRING RegistryPath
);

//
// Function Prototype for the locally defined functions
//

void
NTSCSetProp(PHW_STREAM_REQUEST_BLOCK pSrb);

void
NTSCGetProp(PHW_STREAM_REQUEST_BLOCK pSrb);


BOOLEAN HwStartIo (
				IN PVOID DeviceExtension,
				PHW_STREAM_REQUEST_BLOCK pMrb
				);


VOID AdapterOpenStream(PHW_STREAM_REQUEST_BLOCK pSrb);

VOID AdapterCloseStream(PHW_STREAM_REQUEST_BLOCK pSrb);

VOID STREAMAPI AdapterReceivePacket(IN PHW_STREAM_REQUEST_BLOCK Srb);
VOID STREAMAPI AdapterCancelPacket(IN PHW_STREAM_REQUEST_BLOCK Srb);
VOID STREAMAPI AdapterTimeoutPacket(IN PHW_STREAM_REQUEST_BLOCK Srb);
void VPEGetProp (PHW_STREAM_REQUEST_BLOCK pSrb);
void VPESetProp (PHW_STREAM_REQUEST_BLOCK pSrb);

void									   
AdapterCB(IN PHW_STREAM_REQUEST_BLOCK pSrb);

VOID HostDisableIT(VOID);
VOID HostEnableIT(VOID);
VOID DisableIT(VOID);
VOID EnableIT(VOID);


PHW_STREAM_REQUEST_BLOCK Dequeue(PHW_DEVICE_EXTENSION pdevext);

VOID STREAMAPI StreamReceiveDataPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI StreamReceiveCtrlPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);

VOID AdapterStreamInfo(PHW_STREAM_REQUEST_BLOCK pSrb);

VOID StreamStartCommand (PHW_DEVICE_EXTENSION pdevext);

void Enqueue (PHW_STREAM_REQUEST_BLOCK pSrb, PHW_DEVICE_EXTENSION pdevext);

void OpenSubPicAlloc (IN PHW_STREAM_REQUEST_BLOCK pSrb);
void OpenSubPicCB (IN PHW_STREAM_REQUEST_BLOCK pSrb);

VOID STREAMAPI
CCSetState(IN PHW_STREAM_REQUEST_BLOCK pSrb);

VOID STREAMAPI
CCReceiveDataPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);

STREAMAPI
CycEvent (PHW_EVENT_DESCRIPTOR pEvent);
extern PHW_STREAM_OBJECT pVideoStream;
extern HANDLE hClk;
extern HANDLE hMaster;

// define this macro to facilitate giving the pixel format
#define MKFOURCC(ch0, ch1, ch2, ch3)    ((DWORD)(BYTE)(ch0) |           \
					((DWORD)(BYTE)(ch1) << 8) |     \
					((DWORD)(BYTE)(ch2) << 16) |    \
					((DWORD)(BYTE)(ch3) << 24 ))

//
// define our time event structure
//

typedef struct _MYTIME{
	KSEVENT_TIME_INTERVAL tim;
	LONGLONG LastTime;
} MYTIME, *PMYTIME;

void ClockEvents(PHW_DEVICE_EXTENSION pdevex);

void CleanCCQueue();
PHW_STREAM_REQUEST_BLOCK CCDequeue(void);
void CCEnqueue(PHW_STREAM_REQUEST_BLOCK pSrb);
VOID CCSendDiscontinuity(void);

void
CCGetProp(PHW_STREAM_REQUEST_BLOCK pSrb);

#endif //__MPINIT_H__

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgs\cpq3520a\ptsfifo.c ===
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//	MODULE  : PTSFIFO.C
//	PURPOSE : STi3520A specific code
//	AUTHOR  : JBS Yadawa
// 	CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


#include "strmini.h"
#include "stdefs.h"
#include "board.h"
//#include "error.h"
#include "sti3520A.h"
#include "mpinit.h"
#include "ptsfifo.h"

// Local variables only used in this file
static PTSFIFO ptsFifo[FIFO_SIZE];
static WORD fifoHead;
static WORD fifoTail;

static DWORD dwPrevCDCount = 0, dwCDCount;


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : FifoOpen
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Initialise the PTS fifo
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL FifoOpen(void)
{
	fifoHead = 0;
	fifoTail = 0;
	dwPrevCDCount = 0;
	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : FifoPutPTS
//	PARAMS	: PTS, current number of bytes and if pts is valid
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Put the pts in the list and mark it with right CDCount
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL FifoPutPTS(DWORD dwPTS, DWORD dwCDCount, BOOL ValidPTS)
{                          
	if(ValidPTS)
	{
		ptsFifo[fifoHead].dwPTS = dwPTS;
		ptsFifo[fifoHead].dwCDCount = dwPrevCDCount;
		dwPrevCDCount=dwPrevCDCount+dwCDCount;
		fifoHead = (fifoHead+1)%FIFO_SIZE;
	}
	else
	{
		dwPrevCDCount=dwPrevCDCount+dwCDCount;
	}
	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : FifoGetPTS
//	PARAMS	: Pointers to return PTS and CDCount
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Read the next PTS off the list but do not increment the tail
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL FifoGetPTS(DWORD FARPTR *cdcount, DWORD FARPTR *pts)
{
	if(fifoHead == fifoTail)
		return FALSE;
	*cdcount = ptsFifo[fifoTail].dwCDCount;
	*pts		= ptsFifo[fifoTail].dwPTS;
	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : FifoReadPTS
//	PARAMS	: Pointers to return PTS and CDCount
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Read the next PTS off the list and remove it from the list
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL FifoReadPTS(DWORD FARPTR *cdcount, DWORD FARPTR *pts)
{
	if(fifoHead == fifoTail)
		return FALSE;
	*cdcount = ptsFifo[fifoTail].dwCDCount;
	*pts		= ptsFifo[fifoTail].dwPTS;
	fifoTail = (fifoTail+1)%FIFO_SIZE;
	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : FifoReset
//	PARAMS	: None
//	RETURNS	: None
//
//	PURPOSE	: Reset the pts fifo
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

void FifoReset(void)
{
	fifoHead = 0;
	fifoTail = 0;
	dwPrevCDCount = 0;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgs\cpq3520a\ptsfifo.h ===
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
// 	MODULE  : PTSFIFO.H
//	PURPOSE : STi3520A related unctions
//	AUTHOR  : JBS Yadawa
// 	CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY :
//
//	DATE     :
//
//	COMMENTS :
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

#ifndef __PTSFIFO_H__
#define __PTSFIFO_H__

#define FIFO_SIZE 1024
typedef struct _tagFifo
{
	DWORD dwPTS;
	DWORD dwCDCount;
} PTSFIFO, FARPTR *PPTSFIFO;
BOOL FifoOpen(void);
BOOL FifoPutPTS(DWORD dwPTS, DWORD, BOOL);
BOOL FifoGetPTS(DWORD FARPTR *, DWORD FARPTR *);
BOOL FifoReadPTS(DWORD FARPTR *, DWORD FARPTR *);
void FifoReset(void);

#endif // __PTSFIFO_H__

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgs\cpq3520a\sti3520a.c ===
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
// 	MODULE		:	STi3520A.C
// 	PURPOSE		:  STi3520A Control functions
// 	AUTHOR 		:  JBS Yadawa
// 	CREATED		:	12-26-96
//
//	Copyright (C) 1996-1997 SGS-THOMSON microelectronics
//
//
//
//	REVISION HISTORY:
//	-----------------
//
// 	DATE 			: 	COMMENTS
//	----			: 	--------
//
//	12-28-96 	: 	added different way of handling BufABC
//	1-1-97		: 	Added suport of PTS in s/w
//	1-3-97		: 	Implemeted 3:2 Pulldown
//	1-7-97		: 	AVSYNC Re-implemented
//	1-10-97		: 	Still picture support done
//	1-15-97		: 	Programming to 16/9 and 4/3 added - JBS
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

#include "strmini.h"
#include "stdefs.h"
#include "board.h"
#include "sti3520a.h"
#include "ptsfifo.h"
#include "zac3.h"
#include "trace.h"
//#include "subpic2.h"
#include "mpaudio.h"
#include "ksmedia.h"
#include "mpinit.h"

extern PHW_STREAM_OBJECT pVideoStream;
extern HANDLE hClk;
extern HANDLE hMaster;
extern ULONG VidRate;

extern KS_MPEGVIDEOINFO2 VidFmt;
extern KS_AMVPDATAINFO VPFmt;

ULONG VidRate = 1000;

static VIDEO Video;
PVIDEO pVideo;

PSP_STRM_EX pSPstrmex = NULL;
extern PHW_DEVICE_EXTENSION pDevEx;

BOOL VideoProgramDisplayBuffer(void);
#define MINVBL	4
//Default Matrix

extern PAC3 pAc3;

BYTE slowmode=1;

static BYTE	defIntraQuantMatrix[QMSIZE] = {
		0x08, 0x10, 0x10, 0x13, 0x10, 0x13, 0x16, 0x16,
		0x16, 0x16, 0x16, 0x16, 0x1A, 0x18, 0x1A, 0x1B,
		0x1B, 0x1B, 0x1A, 0x1A, 0x1A, 0x1A, 0x1B, 0x1B,
		0x1B, 0x1D, 0x1D, 0x1D, 0x22, 0x22, 0x22, 0x1D,
		0x1D, 0x1D, 0x1B, 0x1B, 0x1D, 0x1D, 0x20, 0x20,
		0x22, 0x22, 0x25, 0x26, 0x25, 0x23, 0x23, 0x22,
		0x23, 0x26, 0x26, 0x28, 0x28, 0x28, 0x30, 0x30,
		0x2E, 0x2E, 0x38, 0x38, 0x3A, 0x45, 0x45, 0x53
};



//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoOpen
//	PARAMS	: None
//	RETURNS	: Pointer to Video Structure
//
//	PURPOSE	: One time initialization of Video
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

PVIDEO VideoOpen(void)
{
	pVideo											= &Video;
	pVideo->pSequence								= &pVideo->sequence;
 	pVideo->pGop									= &pVideo->gop;
	pVideo->pPicture								= &pVideo->picture;
	pVideo->pSequenceExtension					= &pVideo->sequenceExtension;
	pVideo->pSequenceDisplayExtension		= &pVideo->sequenceDisplayExtension;
	pVideo->pPictureCodingExtension			= &pVideo->pictureCodingExtension;
	pVideo->pQuantMatrixExtension				= &pVideo->quantMatrixExtension;
	pVideo->pHeaderParser						= &pVideo->headerParser;
	pVideo->pPictureDisplayExtension			= &pVideo->pictureDisplayExtension;
	pVideo->pDecodedFrame = &pVideo->bufABC[0];
	pVideo->pDisplayedFrame = &pVideo->bufABC[2];

	return	pVideo;
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoInitDecoder
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Initialse Video Decoder Registers
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoInitDecoder(void)
{
	int i;
	for(i=0; i<QMSIZE; i++)
	{
		pVideo->pSequence->intraQuantiserMatrix[i] = defIntraQuantMatrix[i];
		pVideo->pSequence->nonIntraQuantiserMatrix[i] = 16;
	}

	VideoInitialize();
	pVideo->dcf = 0;
	pVideo->tis = 0;
	pVideo->itm = 0;
	pVideo->displayEnabled = FALSE;
	for(i=0; i<3; i++)
	{
		pVideo->bufABC[i].firstField = TOP;
		pVideo->bufABC[i].nTimesDisplayed = 1;
		pVideo->bufABC[i].nTimesToDisplay = 2;
		pVideo->bufABC[i].pts = 0;
	}

	pVideo->state = videoPowerUp;
	VideoInitPLL(); // Initialize different Clocks
	VideoInitPLL(); // Initialize different Clocks
	VideoEnableDramInterface();
	VideoSetBufferSize();
	VideoSoftReset();
	
	HostDisableIT();
	VideoMaskInterrupt();
	HostEnableIT();
	
	BoardReadVideo(VID_ITS0);
	BoardReadVideo(VID_ITS1);
	BoardReadVideo(VID_ITS2);
	
	
	BoardWriteVideo(PES_CF1, 0x00);
	BoardWriteVideo(PES_CF2, 0x00);

	BoardWriteVideo(VID_TIS, 0);
	BoardWriteVideo(VID_CTL, CTL_EDC | CTL_ERP | CTL_ERS | CTL_ERU);
	pVideo->ctl = CTL_EDC | CTL_ERP | CTL_ERS | CTL_ERU;
	pVideo->dcf |= DCF0_PXD;
	pVideo->dcf |= DCF0_DSR;
	BoardWriteVideo(VID_DCF0, (BYTE)(pVideo->dcf&0xFF));
	BoardWriteVideo(VID_DCF1, (BYTE)(pVideo->dcf>>8));
	for(i=0; i<20; i++)
	{
		if(!VideoTestReg())
		{
			DbgPrint("*****ERROR IN VIDEO REG TEST ");
			break;
		}
	}
	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoPause
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Pause the video decoder
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL	VideoPause(void)
{
	DPF(("Video Pause Called!!"));
 //	pVideo->command = cmdPause;
  pVideo->state = videoPaused;
	
	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoPlay
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Play video
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL	VideoPlay(void)
{
	DPF(("Video Play Called!!"));
	if(pVideo->state == videoPowerUp)
	{
		HostDisableIT();
		pVideo->itm = ITM_VSB | ITM_VST | ITM_PSD | ITM_SCH;
		BoardWriteVideo(VID_ITM0, (BYTE)pVideo->itm);
		BoardWriteVideo(VID_ITM1, 0);
		BoardWriteVideo(VID_ITM2, 0);
		HostEnableIT();
		pVideo->command = cmdPlay;
	}
	else if(pVideo->state == videoPaused)
	{
		pVideo->state = videoPlaying;		

	}

	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoStop
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Stop video
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoStop(void)
{
	DPF(("Video Stop Called!!"));
	pVideo->command = cmdStop;
	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoFinishDecoding
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Wait for bit buffer to go empty to decode all pictures
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoFinishDecoding(void)
{
	pVideo->command = cmdEOS;
	DPF(("Video Finish Decoding Called!!"));
	return TRUE;
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoSeek
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: initialize the decoder to restart decoding
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoSeek(void)
{
	DPF(("Video Seek Called!!"));
	BoardWriteVideo(VID_ITM0, 0);
	BoardWriteVideo(VID_ITM1, 0);
	BoardWriteVideo(VID_TIS, 0);
	pVideo->itm = 0;

	BoardWriteVideo(VID_CSO, 0);
	pVideo->dcf = DCF0_PXD | DCF0_DSR | DCF0_EVD;
	BoardWriteVideo(VID_DCF0, (BYTE)(pVideo->dcf&0xFF));
	BoardWriteVideo(VID_DCF1, (BYTE)(pVideo->dcf>>8));
	pVideo->tis = 0;
	BoardWriteVideo(VID_TIS, 0);
	BoardWriteVideo(VID_HDS, 0);
	BoardWriteVideo(VID_LSO, 0);
	BoardWriteVideo(VID_LSR1, 0);
	BoardWriteVideo(VID_LSR0, 0);
	BoardWriteVideo(VID_PAN1, 0);
	BoardWriteVideo(VID_PAN0, 0);
	BoardWriteVideo(VID_PFH, 0);
	BoardWriteVideo(VID_PFV, 0);
	BoardWriteVideo(VID_PPR1, 0);
	BoardWriteVideo(VID_PPR2, 0);
	BoardWriteVideo(VID_SCN1, 0);
	BoardWriteVideo(VID_SCN0, 0);

	VideoSoftReset();
	VideoInitialize();
	VideoResetPSV();
	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoInitialize
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Initialze all the variables to their default state
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL	VideoInitialize(VOID)
{
	int i;
	pVideo->state = videoPowerUp;
	pVideo->nVsyncsWithoutDsyncs = 0;
	pVideo->codingStandard = MPEG1; // Mpeg1 by default
	pVideo->errorCode	= errNoError;
	pVideo->nDecodedFrames	= 0;
	pVideo->nDisplayedFrames = 0;
	pVideo->command = cmdNone;
	pVideo->firstPPictureFound = FALSE;
	pVideo->skipRequest = FALSE;
	pVideo->skipMode = skipNone;
	pVideo->repeatRequest = FALSE;
	pVideo->starving = FALSE;
	pVideo->scdCount = 0;
	pVideo->prevScdCount = 0;
	pVideo->validPTS = FALSE;
	pVideo->displayEnabled = FALSE;
	pVideo->prevBuf				= 1;
	pVideo->sync		= FALSE;
	pVideo->instructionComputed = FALSE;
	pVideo->pPictureDisplayExtension->horOffset = 0;
	pVideo->pPictureDisplayExtension->verOffset = 0;
	pVideo->nTimesDisplayed = 1;
	pVideo->nTimesToDisplay = 2;
	for(i=0; i<3; i++)
	{
		pVideo->bufABC[i].firstField = TOP;
		pVideo->bufABC[i].nTimesDisplayed = 1;
		pVideo->bufABC[i].nTimesToDisplay = 2;
		pVideo->bufABC[i].pts = 0;
	}

	pVideo->firstField = TOP;
	pVideo->curImage = FRM;
	pVideo->panScan = FALSE;
	pVideo->prevPTS = 0;
	pVideo->firstPtsFound = FALSE;
	pVideo->firstFramePTS = 0;
	pVideo->lastFrameDecoded	= FALSE;
	pVideo->resetAndRestart = FALSE;
	pVideo->prevVsyncTop = FALSE;
	TraceReset();
	FifoOpen();
	FifoReset();

	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoEnableDramInterface
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Enable the clocks and memory refresh
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoEnableDramInterface(void)
{
	BoardWriteVideo(CFG_MCF, MCF_REFRESH);
	// Bus width is 64 bits, enable all interfaces
	BoardWriteVideo(CFG_CCF, (BYTE)( CCF_PBO | CCF_EC3 | CCF_EC2 | CCF_ECK | CCF_EDI | CCF_EVI) );
	BoardWriteVideo(CFG_DRC, 0x00);
	return TRUE;
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoSetBufferSize
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Partition the Bit buffer for Audio/Video/OSD/PICT Buffers
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoSetBufferSize (void)
{
	DWORD abg, abs, vbg, vbs, abt, vbt;
	
	pVideo->audioBufferSize = 0x120;
	pVideo->spBufferSize	= 0x152;
	pVideo->videoBufferSize = MEM_SIZE - 3 * PSZ_NTSC -
					pVideo->audioBufferSize - 2 - pVideo->spBufferSize;
	pVideo->bufABC[0].adr = MEM_SIZE - 3*PSZ_NTSC;
	pVideo->bufABC[1].adr = MEM_SIZE - 2*PSZ_NTSC;
	pVideo->bufABC[2].adr = MEM_SIZE - PSZ_NTSC;
	
	vbt = pVideo->videoBufferSize;
	abt = pVideo->audioBufferSize;
	vbg = 0;
	vbs = vbt;
	abg = vbs+1+pVideo->spBufferSize;
	abs = abg+abt;
	
	BoardWriteVideo(VID_ABG1, (BYTE)(abg>>8));
	BoardWriteVideo(VID_ABG0, (BYTE)(abg));
	BoardWriteVideo(VID_ABS1, (BYTE)(abs >> 8));
	BoardWriteVideo(VID_ABS0, (BYTE)(abs));
	BoardWriteVideo(VID_ABT1, (BYTE)(abt >> 8));
	BoardWriteVideo(VID_ABT0, (BYTE)(abt));

	BoardWriteVideo(VID_VBG1, 0);
	BoardWriteVideo(VID_VBG0, 0);
	BoardWriteVideo(VID_VBS1, (BYTE)(vbs >> 8));
	BoardWriteVideo(VID_VBS0, (BYTE)(vbs));
	BoardWriteVideo(VID_VBT1, (BYTE)(vbt >> 8));
	BoardWriteVideo(VID_VBT0, (BYTE)(vbt));
	
	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoInitPLL
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Program the PLL for different clocks
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoInitPLL(void)
{
	// Program the PLL

	// Select PixClock as refence clock and generate other clocks
 	// from PIXCLK
	BoardWriteVideo(CKG_PLL, PLL_SELECT_PIXCLK | PLL_DEVIDE_BY_N | PLL_MULT_FACTOR);

	// Program video clock
	BoardWriteVideo(CKG_VID, 0x22);
	BoardWriteVideo(CKG_VID, 0x08);
	BoardWriteVideo(CKG_VID, 0x5f);
	BoardWriteVideo(CKG_VID, 0x0f);

	//Program audio clock
	BoardWriteVideo(CKG_AUD, 0x2b);
	BoardWriteVideo(CKG_AUD, 0x02);
	BoardWriteVideo(CKG_AUD, 0x5f);
	BoardWriteVideo(CKG_AUD, 0x5f);


	// Select directions for different clocks
	BoardWriteVideo(CKG_CFG,
				CFG_INTERNAL_AUDCLK |
				CFG_INTERNAL_CLK 	  |
				CFG_PIXCLK_INPUT 	  |
				CFG_PCMCLK_INPUT 	  |
				CFG_MEMCLK_INPUT 	  |
				CFG_AUDCLK_OUTPUT	);
	
	return TRUE;
}



//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoWaitTillHDFNotEmpty
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Wait for HDF to have some bytes for decoding
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL	VideoWaitTillHDFNotEmpty (void)
{
	BYTE	b;
	DWORD	cnt = 0;
	// Make sure that HDF is not empty for header processing
	// this could be a problem in case of PIO
	do {
		b = BoardReadVideo(VID_STA1);
		b = BoardReadVideo(VID_STA0);
		cnt++;
		if(cnt > 0xFFFF)
		{
			TRAP
			pVideo->errorCode = errHeaderFifoEmpty;
			return FALSE;
		}
	} while (b & ITM_HFE);

	return TRUE;
}



//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoInitHeaderParser
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Initialise HDF related stuff to do header parsing
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

	BOOL	VideoInitHeaderParser (void)
{
	PHEADERPARSER pHdf;

	if(!VideoWaitTillHDFNotEmpty())
		return FALSE; // Header Fifo is empty
	pHdf = pVideo->pHeaderParser;

	pHdf->b 		= BoardReadVideo(VID_HDF); // First Byte
	pHdf->next 	= BoardReadVideo(VID_HDF); // Next Byte

	pHdf->first = TRUE;
	pHdf->second = (pHdf->b != 0x01);
	// If first byte is not 0x01, then it must be the start
	// code itself.
	return TRUE;
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoInterrupt
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Video Interrupt handling
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoInterrupt(void)
{
	VideoMaskInterrupt();
	do {
		BoardReadVideo(VID_ITS2);
		pVideo->its = (WORD)BoardReadVideo(VID_ITS1) << 8;
		pVideo->its |= BoardReadVideo(VID_ITS0);
		pVideo->its &= pVideo->itm;



		if(pVideo->its & ITM_PSD)
		{
			TraceIntr(dsync, (BYTE)pVideo->tis, (BYTE)pVideo->frameType);
			VideoDsyncInterrupt();
		}

		if(pVideo->its & ITM_SCH)
		{
			VideoHeaderHit();
		}

		if(pVideo->its & ITM_VSB)
		{
//			TraceIntr(vsb, (BYTE)pVideo->tis, (BYTE)pVideo->frameType);
			VideoVsyncInterrupt(FALSE); // Bot Vsync
		}

		if(pVideo->its & ITM_VST)
		{
			SubPicIRQ(pSPstrmex);
//			TraceIntr(vst, (BYTE)pVideo->tis, (BYTE)pVideo->frameType);
			VideoVsyncInterrupt(TRUE); // Top Vsync

			//
			// update any clock activity.
			//
		
			ClockEvents(pDevEx);
		}

		// Error Handling is done here
		if(pVideo->its & ITM_PER)
		{
			DPF(("PIPELINE Error!!!!!!"));
			pVideo->errorCode	= errPipeline;
			pVideo->state = videoErrorRecover;
			TraceIntr(error, (BYTE)pVideo->tis, (BYTE)pVideo->frameType);
		}
		
		if(pVideo->its & ITM_SER)
		{
			DPF(("SERIOUS Error!!!!!!"));
			pVideo->errorCode	= errSerious;
			BoardWriteVideo(VID_CTL, CTL_PRS);
			Delay(1000);
			BoardWriteVideo(VID_CTL, (BYTE)(pVideo->ctl));
			pVideo->state = videoErrorRecover;
			TraceIntr(error, (BYTE)pVideo->tis, (BYTE)pVideo->frameType);
		}


	} while(pVideo->its);


	VideoUnmaskInterrupt();
	return TRUE;
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoDsyncInterrupt
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: DSYNC is done here
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL	VideoDsyncInterrupt(void)
{
static ULONG cSkip = 0;
static ULONG cHold = 0;

	pVideo->nVsyncsWithoutDsyncs = 0;

	if ((pVideo->nDecodedFrames >= 3) &&
		(pVideo->firstPPictureFound))
	{
//		BoardWriteVideo(VID_TIS, 0); // Wait mode
		VideoGetBBL();
		if ((pVideo->bbl < pVideo->videoBufferSize/4) &&
				(pVideo->state == videoPlaying))
		{
			pVideo->starving = TRUE;
			BoardWriteVideo(VID_CTL, 0);
		}
		
//		VideoProgramPanScanVectors();

		if(pVideo->nDecodedFrames>3)
		{
			VideoProgramDisplayBuffer();
			TraceTref(pVideo->pDisplayedFrame->tref, pVideo->pDisplayedFrame->frameType);
		}

		if(pVideo->pDisplayedFrame->pts)
		{
		
			pVideo->validPTS = TRUE;
			pVideo->framePTS = pVideo->pDisplayedFrame->pts;
			pVideo->pDisplayedFrame->pts = 0;
		}
		else
		{
			pVideo->validPTS = FALSE;
			if(pVideo->pDisplayedFrame->curField == FRM)
			{
				pVideo->framePTS = pVideo->prevPTS + FRAME_PERIOD;
			}
			else
			{
				pVideo->framePTS = pVideo->prevPTS + FIELD_PERIOD;
			}
		}		

		pVideo->prevPTS = pVideo->framePTS;
  /* rate changes */
		//if(pVideo->validPTS && pVideo->sync && (slowmode == 1) && hClk)
		if (pVideo->validPTS && hClk && slowmode ==1)
 /* end rate changes */
		{
			DWORD stc;

  			VideoGetBBL();
			VideoGetABL();

			/* rate changes */
	  		stc = (ULONG)((ULONGLONG)GetStreamPTS(pVideoStream) * (ULONGLONG)VidRate / (ULONGLONG)1000);
			/* end rate changes */

			if((pVideo->nDecodedFrames > 20) &&
				(!pVideo->skipRequest) &&
					(!pVideo->repeatRequest))
			{
				if(pVideo->framePTS > stc + 7000)
				{
			 		// Video is Leading
					// Next picture will be repeated
					pVideo->repeatRequest = TRUE;
					cSkip ++;

				}
				else if(stc > pVideo->framePTS + 7000)
				{
				 	// Video is Lagging
					// Next picture will be skipped
					pVideo->skipRequest = TRUE;

					cHold ++;

				}
				else
				{
					cSkip = cHold = 0;
				}
			}
	
 		}
	}
	return TRUE;
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoVsyncInterrupt
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: VSYNC is done here
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL	VideoVsyncInterrupt(BOOL Top)
{

	pVideo->nVsyncsWithoutDsyncs++;
	if(Top)
	{
		pVideo->curField = TOP;
	}
	else
	{
		pVideo->curField = BOT;
	}

	switch(pVideo->state)
	{
		case videoPowerUp :
			if(pVideo->command == cmdPlay)
			{
				VideoGetBBL();
				if( pVideo->bbl > MINVBL)
				{
					pVideo->tis = TIS_EXE;
					BoardWriteVideo(VID_TIS, (BYTE)pVideo->tis);
					pVideo->state = videoStartUp;
					pVideo->command = cmdNone;
				}
			}
		break;

		case videoErrorRecover:
	case videoPlaying:
	
			if(Top&pVideo->prevVsyncTop)
				pVideo->pDisplayedFrame->nTimesDisplayed+=2; // missed one
			else
				pVideo->pDisplayedFrame->nTimesDisplayed++;

			if(pVideo->starving)
			{
				VideoGetBBL();
				if(pVideo->bbl > pVideo->videoBufferSize*3/4)
				{
					pVideo->starving = FALSE;
					BoardWriteVideo(VID_CTL, CTL_EDC | CTL_ERP | CTL_ERS | CTL_ERU);
					if((pVideo->pDisplayedFrame->nTimesDisplayed >=pVideo->pDisplayedFrame
						->nTimesToDisplay) && (pVideo->instructionComputed))
					{
						
							TraceIntr(storevs, (BYTE)pVideo->tis, (BYTE)pVideo->frameType);
							VideoStoreInstruction();
					}

				}
				else
				{
				}
			}
			else
			{
				if((pVideo->pDisplayedFrame->nTimesDisplayed >=pVideo->pDisplayedFrame
					->nTimesToDisplay) && (pVideo->instructionComputed))

				{
					
//					if((pVideo->pDisplayedFrame->firstField == pVideo->curField)
//						|| (pVideo->pDisplayedFrame->curField == FRM))
					{
						VideoStoreInstruction();
					}
				}

			}
			switch(pVideo->command)
			{
				 case cmdPause:
					pVideo->state = videoPaused;
					pVideo->command = cmdNone;
				 break;
				
				 case cmdEOS:
				 	DPF(("End of Stream Encountered!!\n"));
					pVideo->state = videoEOS;
					pVideo->command = cmdNone;

				 break;
				 case cmdNone:
				 default:
				 break;
			
			 }
		break;

		case videoPaused:
		break;

		case videoEOS :
			VideoGetBBL();
			if(pVideo->bbl < 2)
			{
				pVideo->state = videoPaused;
				BoardWriteVideo(VID_TIS, 0);
			 	DPF(("Pausing after EOS!!!\r\n"));
			}
		break;
		
		case videoInit:

				if(pVideo->curField == pVideo->pDecodedFrame->firstField)
				{
					if(pVideo->instructionComputed)
					{
						pVideo->state = videoFirstFrameDecoded;
						// Start Decoding the next Picture
						VideoSetReconstructionBuffer(pVideo->frameType);
						VideoSetDisplayBuffer(pVideo->frameType);
						VideoStoreInstruction();	
						BoardWriteVideo(VID_DFP0, 	(BYTE)(pVideo->pDecodedFrame->adr));
						BoardWriteVideo(VID_DFP1, 	(BYTE)(pVideo->pDecodedFrame->adr >> 8));
						pVideo->displayEnabled = TRUE;
						VideoForceBKC(FALSE);
						Delay(2000);
					}
					else
					{
						TRAP
					}
				}
				break;

		case videoFirstFrameDecoded:
				VideoGetBBL();
				if((pVideo->bbl+ 5 > pVideo->videoBufferSize)
					&& (pVideo->instructionComputed))
				{		
					if(pVideo->curField == pVideo->pDecodedFrame->firstField)
					{
						pVideo->state = videoPlaying;
						// Start Decoding the next Picture
						VideoComputePictureBuffers();
						VideoStoreInstruction();	
						pVideo->itm |= (ITM_PER | ITM_SER);
						if(pAc3->ac3Data)
							Ac3Play();
					}
				}
			break;


	}
	
	VideoDisplaySingleField(Top);
	pVideo->prevVsyncTop = Top;

	return TRUE;
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoErrorInterrupt
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Error Handling
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoErrorInterrupt(void)
{
	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoHeaderHit
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Header analysis is done here
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoHeaderHit (void)
{
	BYTE sc;

	if(!VideoInitHeaderParser())
		return FALSE; // Header Fifo is empty
	VideoNextHeaderByte();
	// Now pVideo->pHeaderParser->b contains the start Code

	sc = pVideo->pHeaderParser->b;

	if ((sc >= SLICESTART_SC) && (sc <= SLICEEND_SC))
		sc = SLICE_SC;

	switch(sc)
	{
		case SEQUENCE_SC 			:
			TraceIntr(seq, (BYTE)pVideo->tis, (BYTE)pVideo->frameType);
			VideoSequenceHeader();
			BoardWriteVideo(VID_HDS, HDS_HDS);
		break;

		case GOP_SC		  			:
			TraceIntr(gop, (BYTE)pVideo->tis, (BYTE)pVideo->frameType);
			VideoGopHeader();
			BoardWriteVideo(VID_HDS, HDS_HDS);
		break;

		case PICTURE_SC 			:
			TraceIntr(pict, (BYTE)pVideo->tis, (BYTE)pVideo->frameType);
			VideoPictureHeader();
			if((pVideo->skipMode == skipOneFrame) ||
			(pVideo->skipMode == skipTwoFields) ||
			(pVideo->skipMode == skipSecondField))
			{
				BoardWriteVideo(VID_HDS, HDS_HDS);
			}
		break;

		case EXTENSION_SC			:
			TraceIntr(ext, (BYTE)pVideo->tis, (BYTE)pVideo->frameType);
			VideoExtensionHeader();
			BoardWriteVideo(VID_HDS, HDS_HDS);
		break;

		case SEQUENCE_END_SC		:
			TraceIntr(seqend, (BYTE)pVideo->tis, (BYTE)pVideo->frameType);
			VideoSequenceEnd();
			BoardWriteVideo(VID_HDS, HDS_HDS);
		break;

		case SEQUENCE_ERROR_SC	:
			VideoSequenceError();
			BoardWriteVideo(VID_HDS, HDS_HDS);
		break;

		case USER_SC				 :
			VideoUserData();
			BoardWriteVideo(VID_HDS, HDS_HDS);
		break;
		
		case SLICE_SC				:
		break;

		case HACKED_SC				:
			pVideo->lastFrameDecoded = TRUE;
		break;
	}
	
	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoNextHeaderByte
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Read the next byte off hdf and put in b
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoNextHeaderByte (void)
{
	PHEADERPARSER pHdf;
	pHdf = pVideo->pHeaderParser;

	if(pHdf->second)
	{
		pHdf->second = FALSE;
	}
	else if (pHdf->first)
	{
		pHdf->first = FALSE;
		pHdf->b = pHdf->next;
	}
	else  // Read next HDF word
	{
		pHdf->b 		= BoardReadVideo(VID_HDF); // First Byte
		pHdf->next 	= BoardReadVideo(VID_HDF); // Next Byte
		pHdf->first = TRUE;
	}
	return TRUE;
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//	FUNCTION : VideoNextSC
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Search the next startCode in the stream
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoNextSC (void)
{
	PHEADERPARSER pHdf;
	int i = 0, j, k;
	pHdf = pVideo->pHeaderParser;
	
    for (j = 1; j < 1000; j++) {

	    for (k = 1; k < 10000; k++)  {

    		if(pHdf->b)
	    		i = 0;
    		else
	    		i++;
		     VideoNextHeaderByte();

             if ((i >= 2) && (pHdf->b == 0x01)) return TRUE;
        }


        KeStallExecutionProcessor(100);

    }

    // bugbug - what do we return in this case??

	return TRUE;
}



//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoSequenceHeader
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Sequence header handling
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoSequenceHeader (void)
{
	PSEQUENCEHEADER	pSeq;
	PHEADERPARSER		pHdf;
	BYTE					b;
	int					i;
    pSeq = pVideo->pSequence;
	pHdf = pVideo->pHeaderParser;
	
//	DPF(("SEQ_SC"));

	VideoNextHeaderByte();
	pSeq->horSize = (DWORD)((DWORD)pHdf->b << 4);
	VideoNextHeaderByte();
	pSeq->horSize |= (DWORD)(pHdf->b >> 4);
	pSeq->verSize = ((DWORD)(pHdf->b << 8) & 0xF00);
	VideoNextHeaderByte();
	pSeq->verSize |= pHdf->b;
	VideoNextHeaderByte();
	pSeq->aspectRatio	= pHdf->b >> 4;
	pSeq->frameRate  	= pHdf->b & 0x0F;
	VideoNextHeaderByte();
	pSeq->bitRate  	= (DWORD)pHdf->b << 10;
	VideoNextHeaderByte();
	pSeq->bitRate  	|= (DWORD)pHdf->b << 2;
	VideoNextHeaderByte();
	pSeq->bitRate  	|= (DWORD)pHdf->b >> 6;
	pSeq->vbvBufferSize = ((DWORD)pHdf->b & 0x01F) << 5;
	VideoNextHeaderByte();
	pSeq->vbvBufferSize |= (DWORD)(pHdf->b >> 3);
	pSeq->constrainedFlag = (DWORD)(pHdf->b >> 2) & 0x01;
	pSeq->loadIntra = (pHdf->b >> 1) & 0x01;
	if(pSeq->loadIntra)
	{
		for(i=0; i<QMSIZE; i++)
		{
			b = pHdf->b;
			VideoNextHeaderByte();
			pSeq->intraQuantiserMatrix[i] = ((b&0x01) << 7) | (pHdf->b >> 1);
		}
		VideoLoadQuantMatrix(TRUE);
	}
	pSeq->loadNonIntra = pHdf->b & 0x01;

	if(pSeq->loadNonIntra)
	{
		for(i=0; i<QMSIZE; i++)
		{
			VideoNextHeaderByte();
			pSeq->nonIntraQuantiserMatrix[i] = pHdf->b;
		}
		VideoLoadQuantMatrix(FALSE);
	}		
/*	if(pVideo->state == videoStartUp)
	{*/
		VideoProgramDisplayWindow();
	//}
	
	return TRUE;
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoGopHeader
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Handle the GOP header
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoGopHeader (void)
{
	PGOPHEADER			pGop;
	PHEADERPARSER		pHdf;
	
//	DPF(("GOP_SC"));
 	pGop = pVideo->pGop;
	pHdf = pVideo->pHeaderParser;

	VideoNextHeaderByte();
	pGop->timeCode = ((DWORD)pHdf->b << 17);
	VideoNextHeaderByte();
	pGop->timeCode |= ((DWORD)pHdf->b << 9);
	VideoNextHeaderByte();
	pGop->timeCode |= ((DWORD)pHdf->b << 1);
	VideoNextHeaderByte();
	pGop->timeCode |= (pHdf->b >> 7);
	pGop->closedGOP = ((pHdf->b >> 6) & 0x01);
	pGop->brokenLink = ((pHdf->b >> 5) & 0x01);
	
	return TRUE;
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoPictureHeader
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Handle PCTURE header
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL  VideoPictureHeader (void)
{
	BYTE sc;
//	DPF(("PICT"));
	VideoAssociatePTS();
	VideoParsePictureHeader();
	VideoNextSC();
	VideoNextHeaderByte();
	sc = pVideo->pHeaderParser->b;
	if ((sc >= SLICESTART_SC) && (sc <= SLICEEND_SC))
	{
		sc = SLICE_SC;
	}
	while (sc != SLICE_SC)
	{
		switch(sc)
		{
			case EXTENSION_SC			:
			TraceIntr(ext, (BYTE)pVideo->tis, (BYTE)pVideo->frameType);
				VideoExtensionHeader();
			break;

			case USER_SC				 :
			TraceIntr(usr, (BYTE)pVideo->tis, (BYTE)pVideo->frameType);
				VideoUserData();
			break;
			default :
			TraceIntr(unknown, (BYTE)pVideo->tis, (BYTE)pVideo->frameType);
			pVideo->errorCode = errStartCode;
			break;
		}
		VideoNextSC();
		VideoNextHeaderByte();
		sc = pVideo->pHeaderParser->b;
		if ((sc >= SLICESTART_SC) && (sc <= SLICEEND_SC))
		{
			sc = SLICE_SC;
		}
	}

	BoardReadVideo(VID_ITS2);
	pVideo->its = (WORD)BoardReadVideo(VID_ITS1) << 8;
	pVideo->its |= (BoardReadVideo(VID_ITS0) &0xFE);
	pVideo->its &= pVideo->itm;

	pVideo->nDecodedFrames++;

	switch(pVideo->state)
	{
		case videoStartUp:
			pVideo->state = videoInit;
			VideoProgramDisplayWindow();
		  	VideoComputeInstruction();
		break;

		case videoFirstFrameDecoded:
		  	VideoComputeInstruction();
		break;
		
		case videoPlaying :		
		case videoPaused 	:		
		case videoEOS 		:		
		case videoStopped :
		
		if ((pVideo->frameType == BFrame) &&
		((pVideo->curImage == FRM) ||
		(pVideo->curImage == pVideo->firstField)) &&
		(pVideo->skipMode == skipNone) &&
		(pVideo->skipRequest))
		{
			// Frame or First Field
			pVideo->skipRequest = FALSE;
			TraceIntr(skips, (BYTE)pVideo->tis, (BYTE)pVideo->frameType);
			if(pVideo->curImage == FRM)	
				pVideo->skipMode = skipOneFrame;
			else
				pVideo->skipMode = skipTwoFields;
		}					
		else
		{
			VideoSkipOrDecode();
		}
		break;
	}		

	return TRUE;

}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoSkipOrDecode
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Skip one or two pictures
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoSkipOrDecode(void)
{
	switch(pVideo->skipMode)
	{
		case skipNone :
			VideoComputePictureBuffers();
		  	VideoComputeInstruction();
			TraceIntr(skipn, (BYTE)pVideo->tis, (BYTE)pVideo->frameType);
  	    break;
				
		case skipOneFrame:
			VideoComputePictureBuffers();
		  	VideoComputeInstruction();
			pVideo->skipMode = skipNone;	
			pVideo->tis |= (TIS_SKIP1P);
			pVideo->nTimesToDisplay = 2;
			TraceIntr(skipf, (BYTE)pVideo->tis, (BYTE)pVideo->frameType);
		break;
				
		case skipTwoFields:
			pVideo->skipMode = skipSecondField;	
			TraceIntr(skip1, (BYTE)pVideo->tis, (BYTE)pVideo->frameType);
		break;
		
		case skipSecondField:
			VideoComputePictureBuffers();
		  	VideoComputeInstruction();
			pVideo->skipMode = skipNone;	
			pVideo->tis |= TIS_SKIP2P;
			TraceIntr(skip2, (BYTE)pVideo->tis, (BYTE)pVideo->frameType);
			VideoStoreInstruction();
		break;
				
		case skipDone:
			// last picture was skipped
			pVideo->skipMode = skipNone;
			VideoComputePictureBuffers();
	  		VideoComputeInstruction();
			TraceIntr(skipd, (BYTE)pVideo->tis, (BYTE)pVideo->frameType);
		break;
	}

	if(pVideo->repeatRequest)
	{
		pVideo->pDecodedFrame->nTimesToDisplay += 2;
		pVideo->repeatRequest = FALSE;
	}

	pVideo->pDecodedFrame->nTimesToDisplay *= slowmode;

	if((pVideo->pDisplayedFrame->nTimesDisplayed >=
		pVideo->pDisplayedFrame->nTimesToDisplay) &&
		(pVideo->instructionComputed))
	{
		TraceIntr(storepi, (BYTE)pVideo->tis, (BYTE)pVideo->frameType);
		VideoStoreInstruction();
	}

	return TRUE;
}
	
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoComputePictureBuffers
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Program RFP,BFP,FFP,DFP
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoComputePictureBuffers(void)
{
//	if((pVideo->curImage == FRM) || (pVideo->curImage == pVideo->firstField))
	{
		VideoSetReconstructionBuffer(pVideo->frameType);
		VideoSetDisplayBuffer(pVideo->frameType);
	}
	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoParsePictureHeader
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Extract parameters off picture header
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoParsePictureHeader (void)
{
	PPICTUREHEADER pPict = pVideo->pPicture;
	PHEADERPARSER pHdf = pVideo->pHeaderParser;
	int i;
	BYTE nextBit;

	VideoNextHeaderByte();
	pPict->temporalReference = ((DWORD)pHdf->b << 2);
	VideoNextHeaderByte();
	pPict->temporalReference |= ((DWORD)pHdf->b >> 6);
	i = (pHdf->b >> 3) & 0x07;

	pPict->pictureCodingType = i;
	switch(i)
	{
		case 1:
			pVideo->frameType = IFrame;
		break;

		case 2:
			if(!pVideo->firstPPictureFound)
				pVideo->firstPPictureFound = TRUE;
			pVideo->frameType = PFrame;
		break;

		case 3:
			pVideo->frameType = BFrame;
		break;

		default:
			pVideo->errorCode = errInvalidPictureType;
		break;
	}
	pPict->vbvDelay = (DWORD)((DWORD)pHdf->b & 0x07) << 13;
	VideoNextHeaderByte();
	pPict->vbvDelay |= ((DWORD)pHdf->b << 5);
	VideoNextHeaderByte();
	pPict->vbvDelay |= ((DWORD)pHdf->b >> 3);
	i = 3; // 3 bits remaining
	if (pVideo->frameType != IFrame)
	{
		pPict->fFcode = (pHdf->b <<1 ) &0x0F;
		VideoNextHeaderByte();
		pPict->fFcode |= (pHdf->b >>7 );
		i = 7; // 7 bits remaining
		if (pVideo->frameType == BFrame)
		{
			pPict->bFcode = (pHdf->b >> 3)&0x0F;
			i = 3; // 3 bits remaining
		}
	}

	nextBit = 0x01 << (i-1);
	while(pHdf->b & nextBit)
	{
		VideoNextHeaderByte();
		i = i-1;
		if(i==0)
			i = 8;
		nextBit = 0x01 << (i-1);
	}

	if( (nextBit-1) & pHdf->b)
	{
		pVideo->errorCode = errStartCode;
		TRAP
		DPF(("ERROR!!!! i=%x ", i));
		DPF(("ERROR!! b=%x ", pHdf->b));
	}

	return TRUE;
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoExtensionHeader
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Program the extension header
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoExtensionHeader (void)
{
	pVideo->codingStandard = MPEG2;
	VideoNextHeaderByte();

	// first 4 bits are ID
//	DPF(("EXT_SC"));

	switch(pVideo->pHeaderParser->b >> 4)
	{
		case SEQUENCE_EXTENSION_ID :
			VideoSequenceExtensionHeader();
		break;

		case SEQUENCE_DISPLAY_EXTENSION_ID :
			VideoSequenceDisplayExtensionHeader();
		break;
		
		case QUANT_MATRIX_EXTENSION_ID :
			VideoQuantMatrixExtensionHeader();
		break;

		case COPYRIGHT_EXTENSION_ID :
			VideoCopyrightExtensionHeader();
		break;

		case SEQUENCE_SCALABLE_EXTENSION_ID :
			VideoSequenceScalableExtensionHeader();
		break;

		case PICTURE_DISPLAY_EXTENSION_ID :
			VideoPictureDisplayExtensionHeader();
		break;

		case PICTURE_CODING_EXTENSION_ID :
			VideoPictureCodingExtensionHeader();
		break;

		case PICTURE_SPATIAL_SCALABLE_EXTENSION_ID :
			VideoPictureSpatialScalableExtensionHeader();
		break;

		case PICTURE_TEMPORAL_SCALABLE_EXTENSION_ID :
			VideoPictureTemporalScalableExtensionHeader();
		break;
	}
	return TRUE;
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoSequenceEnd
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: End of sequence Processing
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoSequenceEnd(void)
{
	return TRUE;
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoSequenceError
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Error Concealment
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoSequenceError(void)
{
	return TRUE;
}


/*
** GetCCTime ()
**
**    find the time for the next cc request
**
** Arguments:}
**
**
**
** Returns:
**
** Side Effects:
*/


ULONGLONG GetCCTime()
{

	if (pVideo->pts)
	{
		return (ConvertPTStoStrm(pVideo->pts));
	}

	return(ConvertPTStoStrm(GetStreamPTS(pVideoStream)));
}

/*
** CCSendDiscontinuity ()
**
**	  Send a DataDiscontinuity to the close caption decoder
**
** Arguments:
**
**
**
** Returns:
**
** Side Effects:
*/


VOID CCSendDiscontinuity(void)
{
PHW_STREAM_REQUEST_BLOCK pSrb;
PKSSTREAM_HEADER   pPacket;

	if (pDevEx->pstroCC && ((PSTREAMEX)(pDevEx->pstroCC->HwStreamExtension))->state
					== KSSTATE_RUN )
	{
		if (pSrb = CCDequeue())
		{
			//
			// we have a request, send a discontinuity
			//

			pSrb->Status = STATUS_SUCCESS;
			pPacket = pSrb->CommandData.DataBufferArray;

			pPacket->OptionsFlags = KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY |
			KSSTREAM_HEADER_OPTIONSF_TIMEVALID | KSSTREAM_HEADER_OPTIONSF_DURATIONVALID;
			pPacket->DataUsed = 0;
			pSrb->NumberOfBuffers = 0;

			pPacket->PresentationTime.Time = GetCCTime();
			pPacket->Duration = 1000;

			StreamClassStreamNotification(StreamRequestComplete,
					pSrb->StreamObject,
					pSrb);

		}
		else
		{
			TRAP
		}
	}

}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoUserData
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Extract User Data
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoUserData(void)
{
	ULONG cCCData;
	PBYTE pDest;
	PHW_STREAM_REQUEST_BLOCK pSrb;
	PHEADERPARSER		pHdf;
PKSSTREAM_HEADER   pPacket;
	pHdf = pVideo->pHeaderParser;

	//
	// check if the close caption pin is open and running, and that
	// we have a data packet avaiable
	//

	if (pDevEx->pstroCC && ((PSTREAMEX)(pDevEx->pstroCC->HwStreamExtension))->state
					== KSSTATE_RUN )
	{
		if (pSrb = CCDequeue())
		{

			//
			// check the SRB to ensure it can take at least the header
			// information from the GOP packet
			//

			if (pSrb->CommandData.DataBufferArray->FrameExtent < sizeof(KSGOP_USERDATA))
			{
				TRAP

				pSrb->Status = STATUS_INVALID_BUFFER_SIZE;

				pSrb->ActualBytesTransferred = 0;

				StreamClassStreamNotification(StreamRequestComplete,
						pSrb->StreamObject,
						pSrb);

				return TRUE;
		
			}

			//
			// fill in the header
			//

			pDest = pSrb->CommandData.DataBufferArray->Data;

			//
			// fill in the start code
			//

			*(PULONG)pDest = 0xB2010000;
			pDest += 4;

			//
			// pick up the next two header bytes
			//

			VideoNextHeaderByte();
			*pDest++= pHdf->b;

			VideoNextHeaderByte();
			*pDest++= pHdf->b;

			VideoNextHeaderByte();
			*pDest++= pHdf->b;
		
			VideoNextHeaderByte();
			*pDest++= pHdf->b;


			//
			// pick up the count field
			//

			VideoNextHeaderByte();
			*pDest++= pHdf->b;

			cCCData = (ULONG)pHdf->b & 0x3f;

			if (pSrb->CommandData.DataBufferArray->FrameExtent <
					(cCCData -1) * 3 + sizeof (KSGOP_USERDATA))
			{
				TRAP

				pSrb->Status = STATUS_INVALID_BUFFER_SIZE;

				pSrb->ActualBytesTransferred = 0;

				StreamClassStreamNotification(StreamRequestComplete,
						pSrb->StreamObject,
						pSrb);

				return TRUE;
		
			}

			//
			// indicate the amount of data transferred
			//

			pSrb->CommandData.DataBufferArray->DataUsed =
				pSrb->ActualBytesTransferred =
					(cCCData -1 ) * 3 + sizeof (KSGOP_USERDATA);

			//
			// copy the bits
			//

			for (;cCCData; cCCData--)
			{
				VideoNextHeaderByte();
				*pDest++= pHdf->b;
	
				VideoNextHeaderByte();
				*pDest++= pHdf->b;
	
				VideoNextHeaderByte();
				*pDest++= pHdf->b;

			}

			pSrb->Status = STATUS_SUCCESS;

			pPacket = pSrb->CommandData.DataBufferArray;

			pPacket->OptionsFlags = KSSTREAM_HEADER_OPTIONSF_TIMEVALID |
						KSSTREAM_HEADER_OPTIONSF_DURATIONVALID;
			pSrb->NumberOfBuffers = 1;

			pPacket->PresentationTime.Time = GetCCTime();
			pPacket->Duration = 1000;

			StreamClassStreamNotification(StreamRequestComplete,
					pSrb->StreamObject,
					pSrb);

			return TRUE;

		}
		else // no SRB!
		{
			TRAP
		}
	}

	return TRUE;
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoSequenceExtensionHeader
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Extract Sequence Extension Parameters
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoSequenceExtensionHeader (void)
{
	PSEQUENCEEXTENSION pExt = pVideo->pSequenceExtension;
	PHEADERPARSER 						 pHdf = pVideo->pHeaderParser;

	pExt->profileAndLevel = ((DWORD)pHdf->b&0x0F) << 4;
	VideoNextHeaderByte();
	pExt->profileAndLevel |= ((DWORD)pHdf->b) >> 4;
	pExt->progressiveSequence = (pHdf->b >> 3) & 0x01;
	pExt->chromaFormat = (pHdf->b >> 1) & 0x03;
	pExt->horSizeExtension = (pHdf->b&0x01 ) << 1;
	VideoNextHeaderByte();
	pExt->horSizeExtension |= (pHdf->b >> 7);
	pVideo->pSequence->horSize |= (pExt->horSizeExtension << 12);
	pExt->verSizeExtension = (pHdf->b >> 5) & 0x03;
	pVideo->pSequence->verSize |= (pExt->verSizeExtension << 12);
	pExt->bitRateExtension = ((DWORD)pHdf->b&0x1F) << 7 ;
	VideoNextHeaderByte();
	pExt->bitRateExtension |= ((DWORD)pHdf->b >> 1);
	pVideo->pSequence->bitRate |= (pExt->bitRateExtension << 18);
	VideoNextHeaderByte();
	pExt->vbvBufSizeExtension = pHdf->b;
	pVideo->pSequence->vbvBufferSize |= (pExt->vbvBufSizeExtension << 10);
	VideoNextHeaderByte();
	pExt->frameRateExtensionN = (pHdf->b >> 5)&0x03;
	pExt->frameRateExtensionD = pHdf->b & 0x1F;
	return TRUE;
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoSequenceDisplayExtension
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Extract sequence display extension parameters
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoSequenceDisplayExtensionHeader(void)
{
	PSEQUENCEDISPLAYEXTENSION	pDispExt = pVideo->pSequenceDisplayExtension;
	PHEADERPARSER 						 pHdf = pVideo->pHeaderParser;

	pDispExt->videoFormat = (pHdf->b >> 1) & 0x07;
	pDispExt->colorDescription = (pHdf->b ) & 0x01;
	if(pDispExt->colorDescription)
	{
		VideoNextHeaderByte();
		pDispExt->colorPrimaries = pHdf->b;
		VideoNextHeaderByte();
		pDispExt->transferCharacteristic = pHdf->b;
		VideoNextHeaderByte();
		pDispExt->matrixCoefficients = pHdf->b;
	}


	//
	// check sizes here
	//

	VideoNextHeaderByte();
	pDispExt->displayHorSize = (DWORD)pHdf->b << 6;
	VideoNextHeaderByte();
	pDispExt->displayHorSize |= ((DWORD)pHdf->b >> 2);
	pDispExt->displayVerSize = ((DWORD)(pHdf->b&0x01) << 13);
	VideoNextHeaderByte();
	pDispExt->displayVerSize |= ((DWORD)pHdf->b << 5);
	VideoNextHeaderByte();
	pDispExt->displayVerSize |= ((DWORD)pHdf->b >> 3);
	//pVideo->panScan = TRUE;
	return TRUE;
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoSequenceScalableExtensionHeader
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Extract the sequence Scalable parameters
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoSequenceScalableExtensionHeader(void)
{
	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoCopyrightExtensionHeader
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Extract copyright extension
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoCopyrightExtensionHeader(void)
{
	return TRUE;
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoQuantMatrixExtension
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Extract Quant Matrices
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoQuantMatrixExtensionHeader(void)
{
	PQUANTMATRIXEXTENSION pQuant = pVideo->pQuantMatrixExtension;
	PSEQUENCEHEADER			 pSeq	  = pVideo->pSequence;
	PHEADERPARSER			 pHdf	  = pVideo->pHeaderParser;
	BYTE b;
	int i;
	
	if(pHdf->b & 0x08)
	{
		for(i=0; i<QMSIZE; i++)
		{
			b = pHdf->b;
			VideoNextHeaderByte();
			pQuant->intraQuantMatrix[i] = pSeq->intraQuantiserMatrix[i] = ((b&0x07) << 5) | (pHdf->b >> 3);
		}
		VideoLoadQuantMatrix(TRUE);
	}

	if(pHdf->b & 0x04)
	{
		for(i=0; i<QMSIZE; i++)
		{
			b = pHdf->b;
			VideoNextHeaderByte();
			pQuant->nonIntraQuantMatrix[i] = pSeq->nonIntraQuantiserMatrix[i] = ((b&0x03) << 6) | (pHdf->b >> 2);
		}
		VideoLoadQuantMatrix(FALSE);
	}
	if(pHdf->b & 0x02)
	{
		for(i=0; i<QMSIZE; i++)
		{
			b = pHdf->b;
			VideoNextHeaderByte();
			pQuant->chromaIntraQuantMatrix[i] = ((b&0x01) << 7) | (pHdf->b >> 1);
		}
	}

	if(pHdf->b & 0x02)
	{
		for(i=0; i<QMSIZE; i++)
		{
			VideoNextHeaderByte();
			pQuant->chromaNonIntraQuantMatrix[i] = pHdf->b;
		}
	}
	return TRUE;
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoPictureCodingExtensionHeader
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Extract picture coding parameters
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoPictureCodingExtensionHeader(void)
{
	PPICTURECODINGEXTENSION pCodingExt =
					pVideo->pPictureCodingExtension;
	PHEADERPARSER			 pHdf	  = pVideo->pHeaderParser;

	pCodingExt->fCode[0][0] = (pHdf->b & 0x0F);
	VideoNextHeaderByte();
	pCodingExt->fCode[0][1] = (pHdf->b >> 4);
	pCodingExt->fCode[1][0] = (pHdf->b & 0x0F);
	VideoNextHeaderByte();
	pCodingExt->fCode[1][1] = (pHdf->b >> 4);
	pCodingExt->intraDCPrecision = (pHdf->b&0xF)>>2;		
	pCodingExt->pictureStructure = (pHdf->b &0x03);		
	VideoNextHeaderByte();
	pCodingExt->topFieldFirst = (pHdf->b >> 7);
	pCodingExt->framePredFrameDCT = (pHdf->b >> 6)&0x01;
	pCodingExt->concealmentMotionVectors = (pHdf->b >> 5)&0x01;
	pCodingExt->qScaleType = (pHdf->b >> 4)&0x01;
	pCodingExt->intraVLCFormat = (pHdf->b >> 3)&0x01;
	pCodingExt->alternateScan = (pHdf->b >> 2)&0x01;
	pCodingExt->repeatFirstField = (pHdf->b >> 1)&0x01;
	pCodingExt->chroma420Type = (pHdf->b)&0x01;
	VideoNextHeaderByte();
	pCodingExt->progressiveFrame = (pHdf->b >> 7)&0x01;
	pCodingExt->compositeDisplayFlag = (pHdf->b >> 6)&0x01;
	if(pCodingExt->compositeDisplayFlag)
	{
		pCodingExt->vAxis = (pHdf->b >> 5)&0x01;
		pCodingExt->fieldSequence = (pHdf->b >> 2)&0x07;
		pCodingExt->subCarrier = (pHdf->b >> 1)&0x01;
		pCodingExt->burstAmplitude = (pHdf->b &0x01 ) << 7;
		VideoNextHeaderByte();
		pCodingExt->burstAmplitude |= (pHdf->b >> 1);
		pCodingExt->subCarrierPhase = (pHdf->b &0x01 );
	}


		// Set to one field by default
	pVideo->nTimesToDisplay = 1;
	pVideo->firstField = TOP;

	if(!pVideo->pSequenceExtension->progressiveSequence)
	{
		if(pVideo->pPictureCodingExtension->pictureStructure == FRAME)
		{
			if(pVideo->pPictureCodingExtension->topFieldFirst)
				pVideo->firstField = TOP;
			else
				pVideo->firstField = BOT;

			if(pVideo->pPictureCodingExtension->repeatFirstField)
				pVideo->nTimesToDisplay = 3;
			else
				pVideo->nTimesToDisplay = 2;
		}
	}

	if(pVideo->pSequenceExtension->progressiveSequence)
	{
		if((!pVideo->pPictureCodingExtension->repeatFirstField) &&
			(!pVideo->pPictureCodingExtension->topFieldFirst))
		{
			pVideo->nTimesToDisplay = 1;
		}
 		else if((pVideo->pPictureCodingExtension->repeatFirstField) &&
			(!pVideo->pPictureCodingExtension->topFieldFirst))
		{
			pVideo->nTimesToDisplay = 2;
				
		}
	 	else if((pVideo->pPictureCodingExtension->repeatFirstField) &&
			(pVideo->pPictureCodingExtension->topFieldFirst))
		{
			pVideo->nTimesToDisplay = 3;
			
		}
		
	}
	//DPF(("Decoded:disp = %ld, todisp = %ld\r\n",pVideo->pDecodedFrame->nTimesDisplayed,pVideo->pDecodedFrame->nTimesToDisplay));

	switch(pVideo->pPictureCodingExtension->pictureStructure)
	{
		case FRAME:
			pVideo->curImage = FRM;
		break;

		case TOP_FIELD :
			pVideo->curImage = TOP;
		break;

		case BOT_FIELD :
			pVideo->curImage = BOT;
		break;
							
	}
			
	TracePictExt((BYTE)pVideo->nTimesToDisplay, (BYTE)pCodingExt->topFieldFirst, (BYTE)pCodingExt->repeatFirstField, (BYTE)pCodingExt->progressiveFrame, (BYTE)pCodingExt->pictureStructure);
	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoPictureDisplayExtensionHeader
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Extract pan and scan vectors
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoPictureDisplayExtensionHeader(void)
{
	PPICTUREDISPLAYEXTENSION pDisp =
					pVideo->pPictureDisplayExtension;
	PHEADERPARSER			 pHdf	  = pVideo->pHeaderParser;

	pDisp->horOffset = ((DWORD)(pHdf->b)&0x0F)<<12;
	VideoNextHeaderByte();
	pDisp->horOffset |= (((DWORD)pHdf->b)<<4);
	VideoNextHeaderByte();
	pDisp->horOffset |= (((DWORD)pHdf->b)>>4);

	pDisp->verOffset = (((DWORD)pHdf->b & 0x07)<<13);
	VideoNextHeaderByte();
	pDisp->verOffset |= (((DWORD)pHdf->b )<<5);
	VideoNextHeaderByte();
	pDisp->verOffset |= (((DWORD)pHdf->b )>>3);

	//
	// if pan / scan is enabled, set the new vectors here
	//

	if (VidFmt.dwFlags & KS_MPEG2_DoPanScan)
	{
		VideoConvertSixteenByNineToFourByThree();
	}
	else
	{
		VideoResetPSV();
	}

	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoPictureSpatialScalableExtensionHeader
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Extract it
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoPictureSpatialScalableExtensionHeader(void)
{
	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoPictureTemporalScalableExtensionHeader
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Extract it
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoPictureTemporalScalableExtensionHeader(void)
{
	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoLoadQuantMatrix
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Load quant matrices
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoLoadQuantMatrix(BOOL intra)
{
	int i;
	if(intra)
	{
		// Load Intra
		BoardWriteVideo(VID_HDS, HDS_QMI_INTRA);
		for(i=0; i<QMSIZE; i++)
			BoardWriteVideo(VID_QMW, pVideo->pSequence->intraQuantiserMatrix[i]);
	}
	else
	{
		// Load nonIntra
		BoardWriteVideo(VID_HDS, HDS_QMI_NON_INTRA);
		for(i=0; i<QMSIZE; i++)
			BoardWriteVideo(VID_QMW, pVideo->pSequence->nonIntraQuantiserMatrix[i]);
	}
	BoardWriteVideo(VID_HDS, 0);
	return TRUE;
}



//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoSetReconstructionBuffer
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Program RFP
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoSetReconstructionBuffer (FRAMETYPE frame)
{

		switch(frame)
		{
			case IFrame :
			case PFrame :
				pVideo->rfp = 1 - pVideo->prevBuf;
				pVideo->bfp = pVideo->prevBuf;
				pVideo->ffp = pVideo->prevBuf;
			break;
	
			case BFrame :
				pVideo->rfp = 2; // B picture always uses BUFF_C
				pVideo->bfp = pVideo->prevBuf;
				pVideo->ffp = 1-pVideo->prevBuf;
			break;
	
			default :
				TRAP
			break;
		}
	
		pVideo->pDecodedFrame = &pVideo->bufABC[pVideo->rfp];
		BoardWriteVideo(VID_RFP1, 	(BYTE)(pVideo->pDecodedFrame->adr >> 8));
		BoardWriteVideo(VID_RFP0, 	(BYTE)(pVideo->pDecodedFrame->adr));
	
		BoardWriteVideo(VID_BFP1, 	(BYTE)(pVideo->bufABC[pVideo->bfp].adr >> 8));
		BoardWriteVideo(VID_BFP0, 	(BYTE)(pVideo->bufABC[pVideo->bfp].adr));
		
		BoardWriteVideo(VID_FFP1, 	(BYTE)(pVideo->bufABC[pVideo->ffp].adr >> 8));
		BoardWriteVideo(VID_FFP0, 	(BYTE)(pVideo->bufABC[pVideo->ffp].adr));

		pVideo->pDecodedFrame->pts = pVideo->pts;

		pVideo->pDecodedFrame->panHor =
					pVideo->pPictureDisplayExtension->horOffset;

		pVideo->pDecodedFrame->panVer =
					pVideo->pPictureDisplayExtension->verOffset;

		if(pVideo->rfp != 2)
			pVideo->prevBuf =  pVideo->rfp;

	pVideo->pDecodedFrame->tref = pVideo->pPicture->temporalReference;
	pVideo->pDecodedFrame->frameType = pVideo->frameType;

	// rr - JBS attempt to fix 3:2 problem
	pVideo->pDecodedFrame->nTimesToDisplay = pVideo->nTimesToDisplay;
	pVideo->pDecodedFrame->nTimesDisplayed = 1;
	pVideo->pDecodedFrame->curField = pVideo->curImage;
	pVideo->pDecodedFrame->firstField = pVideo->firstField;
	// end rr
		
	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoSetDisplayBuffer
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Calculate DFP
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoSetDisplayBuffer (FRAMETYPE frame)
{
	switch(frame)
	{
		case IFrame :
		case PFrame :
				pVideo->dfp = 1 - pVideo->prevBuf;
		break;

		case BFrame :
				pVideo->dfp = 2; // B picture always uses BUFF_C
		break;

		default :
			TRAP
		break;
	}
	pVideo->pDisplayedFrame = &pVideo->bufABC[pVideo->dfp];
	pVideo->nDisplayedFrames++;
	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoProgramDisplayBuffer
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Program DFP
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoProgramDisplayBuffer(void)
{
	BoardWriteVideo(VID_DFP0, 	(BYTE)(pVideo->pDisplayedFrame->adr));
	BoardWriteVideo(VID_DFP1, 	(BYTE)(pVideo->pDisplayedFrame->adr >> 8));
	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoSoftReset
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Soft reset sti3520A
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

extern BOOL fInitSP;

BOOL VideoSoftReset(void)
{

	BoardWriteVideo(VID_CTL, CTL_SRS);
	Delay(1000);
	BoardWriteVideo(VID_CTL, 0);
	BoardWriteVideo(VID_CTL, CTL_PRS);
	Delay(1000);
	BoardWriteVideo(VID_CTL, (BYTE)pVideo->ctl);

	Ac3Stop();
	BoardWriteAudio(AUD_RES, 0x01);
	Delay(1000);
	Ac3Stop();
	BoardWriteAudio(AUD_BBE, 0x01);
	BoardWriteAudio(AUD_DEM, 0x00);
	BoardWriteAudio(AUD_DIF, 0x01);
	BoardWriteAudio(AUD_DIV, 0x02);
	BoardWriteAudio(AUD_EXT, 0x00);
	BoardWriteAudio(AUD_FOR, 0x00);
	BoardWriteAudio(AUD_ISS, 0x03);
	BoardWriteAudio(AUD_LCA, 0x00);
	BoardWriteAudio(AUD_RCA, 0x00);
	BoardWriteAudio(AUD_LRP, 0x00);
	BoardWriteAudio(AUD_ORD, 0x00);
	BoardWriteAudio(AUD_P18, 0x01);
	BoardWriteAudio(AUD_SCP, 0x00);
	BoardWriteAudio(AUD_SEM, 0x00);
	BoardWriteAudio(AUD_SFR, 0x00);
	BoardWriteAudio(AUD_RST, 0x01);
	BoardWriteVideo(VID_CTL, CTL_SRS);
	Delay(1000);
	BoardWriteVideo(VID_CTL, 0);
	BoardWriteVideo(VID_CTL, CTL_PRS);
	Delay(1000);
	pVideo->ctl = CTL_EDC | CTL_ERP | CTL_ERS | CTL_ERU;
	BoardWriteVideo(VID_CTL, (BYTE)pVideo->ctl);
	Ac3Stop();

	Delay(1000);


	BoardWriteVideo(VID_OBP, (BYTE)((pVideo->videoBufferSize + 1) >> 8));
	BoardWriteVideo(VID_OBP, (BYTE)((pVideo->videoBufferSize + 1) & 0xFF));

	Delay(1000);

	BoardWriteVideo(VID_OTP, (BYTE)((pVideo->videoBufferSize + 1) >> 8));
	BoardWriteVideo(VID_OTP, (BYTE)((pVideo->videoBufferSize + 1) & 0xFF));

	fInitSP = FALSE;


	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoSetSRC
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Set SRC
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoSetSRC(DWORD srcSize, DWORD dstSize)
{
	DWORD lsr;
	
	lsr = 256L * (srcSize-4)/(dstSize-1);
	BoardWriteVideo(VID_LSO, 0);
	BoardWriteVideo(VID_LSR0, (BYTE)lsr);
	if(lsr > 255)
		BoardWriteVideo(VID_LSR1, 0x01);
	BoardWriteVideo(VID_CSO, 0x00);
	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoSwitchSRC
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Set src on or off
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoSwitchSRC(BOOL on)
{
	if(on)
		pVideo->dcf &= (~DCF0_DSR);
	else
		pVideo->dcf |= DCF0_DSR;
		
	BoardWriteVideo(VID_DCF0, (BYTE)(pVideo->dcf));
	BoardWriteVideo(VID_DCF1, 0);
	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoProgramDisplayWindow
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Program the display window
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoProgramDisplayWindow(void)
{
	// Program XDO, YDO, XDS,YDS
	BYTE b;
	WORD w;

	BoardWriteVideo(VID_XDO0, (BYTE)(XOFFSET&0xFF));
	BoardWriteVideo(VID_XDO1, (BYTE)(XOFFSET>>8));

	BoardWriteVideo(VID_YDO, (BYTE)(YOFFSET&0xFF));

	BoardWriteVideo(VID_XDS0,  (BYTE)((XOFFSET+VPFmt.amvpDimInfo.dwFieldWidth - 63)&0xFF));
	BoardWriteVideo(VID_XDS1,  (BYTE)((XOFFSET+VPFmt.amvpDimInfo.dwFieldWidth - 63)>>8));


	switch(pVideo->codingStandard)
	{
		case MPEG1:
			BoardWriteVideo(VID_YDS,  (BYTE)((pVideo->pSequence->verSize+YOFFSET-YDS_CONST)&0xFF));
		   pVideo->dcf &= 0xF8;	 // Clear the VCF bits
			pVideo->dcf |= DCF0_VCFHALFRESCI;
			if(pVideo->pSequence->horSize < 720)
			{
				DPF(("Setting SRC!!"));
				VideoSetSRC(pVideo->pSequence->horSize, 720);
				VideoSwitchSRC(TRUE);
			}
		break;

		case MPEG2:
			BoardWriteVideo(VID_YDS,  (BYTE)(((pVideo->pSequence->verSize>>1)+YOFFSET-YDS_CONST)&0xFF));
		   pVideo->dcf &= 0xF8;	 // Clear the VCF bits
			pVideo->dcf |= DCF0_VCFFULLRESLRWI;
/*
	// Commenting it out for debugging
			if(pVideo->pSequence->aspectRatio == 0x03)
			{
				pVideo->panScan = TRUE;
				VideoSetSRC(544, 720);
				VideoSwitchSRC(TRUE);
				VideoConvertSixteenByNineToFourByThree();
			}
			else
*/
				//VideoSwitchSRC(FALSE);
		break;

	}
	
	BoardWriteVideo(VID_DCF0, (BYTE)(pVideo->dcf));
	BoardWriteVideo(VID_DCF1, 0);

	// Program DFW and DFS
	b = (BYTE)((pVideo->pSequence->horSize+15)>>4);
	BoardWriteVideo(VID_DFW, b);
	w = (WORD)((pVideo->pSequence->verSize+15)>>4)*(WORD)b;
	BoardWriteVideo(VID_DFS, (BYTE) ((w>>8) & 0x3F));
	BoardWriteVideo(VID_DFS, (BYTE) (w & 0xFF));

	BoardWriteVideo(VID_DFA, 0);
	BoardWriteVideo(VID_DFA, 0);
	
	BoardWriteVideo(VID_XFW, b);

	BoardWriteVideo(VID_XFS, (BYTE) ((w>>8) & 0x3F));
	BoardWriteVideo(VID_XFS, (BYTE) (w & 0xFF));
	
	BoardWriteVideo(VID_XFA, 0);
	BoardWriteVideo(VID_XFA, 0);
	VideoLoadQuantMatrix(TRUE);
	VideoLoadQuantMatrix(FALSE);
	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoMaskInterrupt
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Mask the interrupt
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoMaskInterrupt(void)
{
	BoardWriteVideo(VID_ITM0, 0);
	BoardWriteVideo(VID_ITM1, 0);
	BoardWriteVideo(VID_ITM2, 0);
	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoUnmaskInterrupt
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Unmask the interrupts
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoUnmaskInterrupt(void)
{
	BoardWriteVideo(VID_ITM0, (BYTE)(pVideo->itm&0xFF));
	BoardWriteVideo(VID_ITM1, (BYTE)(pVideo->itm>>8));
	BoardWriteVideo(VID_ITM2, 0);
	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : Compute the next instruction
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Extract it
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoComputeInstruction(void)
{

	pVideo->tis = TIS_EXE;
	switch(pVideo->codingStandard)
	{
		case MPEG1:
				// Set to one field by default
			pVideo->nTimesToDisplay = 2;
			pVideo->firstField = TOP;

			pVideo->pfh = (pVideo->pPicture->fFcode) | (pVideo->pPicture->bFcode << 4);
			pVideo->pfv = 0;
			pVideo->ppr1 = (pVideo->pPicture->pictureCodingType << 4) & 0x30;
			pVideo->ppr2 = 0;
		break;

	case MPEG2:
			pVideo->pfh =
				(pVideo->pPictureCodingExtension->fCode[1][0] << 4) |
				(pVideo->pPictureCodingExtension->fCode[0][0] );

			pVideo->pfv =
				(pVideo->pPictureCodingExtension->fCode[1][1] << 4) |
				(pVideo->pPictureCodingExtension->fCode[0][1] );

			pVideo->ppr1 =
				((pVideo->pPicture->pictureCodingType << 4) & 0x30) |
				((pVideo->pPictureCodingExtension->intraDCPrecision << 2) & 0x0C) |
				((pVideo->pPictureCodingExtension->pictureStructure ) & 0x03);

			pVideo->ppr2 =
				(pVideo->pPictureCodingExtension->topFieldFirst << 5) |
				(pVideo->pPictureCodingExtension->framePredFrameDCT << 4) |
				(pVideo->pPictureCodingExtension->concealmentMotionVectors << 3) |
				(pVideo->pPictureCodingExtension->qScaleType << 2) |
				(pVideo->pPictureCodingExtension->intraVLCFormat << 1) |
				(pVideo->pPictureCodingExtension->alternateScan);
				pVideo->tis |=  TIS_MP2;
	
		break;
	}

	if(pVideo->frameType == BFrame)
	{
				pVideo->tis |= TIS_OVW;
	}
	
	TraceIntr(comp, (BYTE)pVideo->tis, (BYTE)pVideo->frameType);
  	pVideo->instructionComputed = TRUE;
	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoStoreInstruction
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Store it
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoStoreInstruction(void)
{
	BoardWriteVideo(VID_PFV, (BYTE)(pVideo->pfv));
	BoardWriteVideo(VID_PFH, (BYTE)(pVideo->pfh));
	BoardWriteVideo(VID_PPR1, (BYTE)(pVideo->ppr1));
	BoardWriteVideo(VID_PPR2, (BYTE)(pVideo->ppr2));
	BoardWriteVideo(VID_TIS, (BYTE)(pVideo->tis));
	pVideo->instructionComputed = FALSE;
	pVideo->tis = 0;
	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoGetBBL
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Read BBL and put in pVideo->BBL
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL	VideoGetBBL(void)
{
	pVideo->bbl = BoardReadVideo(VID_VBL1) << 8;
	pVideo->bbl |= BoardReadVideo(VID_VBL0);
	pVideo->bbl &= 0x3FFF;
	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoReadABL
//	PARAMS	: None
//	RETURNS	: Read abl and put it in pVideo->abl
//
//	PURPOSE	: Extract it
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL	VideoGetABL(void)
{
	pVideo->abl = BoardReadVideo(VID_ABL1) << 8;
	pVideo->abl |= BoardReadVideo(VID_ABL0);
	pVideo->abl &= 0x3FFF;
	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoReadSCD
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Get the SCD value
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoReadSCD(void)
{
	DWORD scd, diff;

	scd = ((DWORD)BoardReadVideo(VID_SCD)) << 16;
	scd |= ((DWORD)BoardReadVideo(VID_SCD)) << 8;
	scd |= (DWORD)BoardReadVideo(VID_SCD);
	if(scd < pVideo->prevScdCount)
		diff = 0x1000000 - pVideo->prevScdCount + scd;
	else
		diff = scd - pVideo->prevScdCount;
	pVideo->scdCount += diff;
	pVideo->prevScdCount = scd;
	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoAssociatePTS
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Read the next PTS off the fifo and associate it
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL	VideoAssociatePTS(void)
{
	DWORD cdcount, pts;
	VideoReadSCD();

	if(FifoGetPTS(&cdcount, &pts))
	{
		// Hacking for still picture decode.
		if(!pVideo->firstPtsFound)
		{
		 	pVideo->firstPtsFound = TRUE;
			pVideo->firstFramePTS = pts;
		}

		if(pVideo->scdCount*2L > cdcount)
		{
			
			FifoReadPTS(&cdcount, &pts);
			pVideo->pts = pts;
			// Pts belongs to this frame
		}
		else
		{
			pVideo->pts = 0;
			// Pts does not belong to this frame
		}
	}
	return TRUE;
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoProgramPanScanVectors
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Program the pan scan vectors
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoConvertSixteenByNineToFourByThree(void)
{
	DWORD pan, scan, d1, d2;

	d1 = (pVideo->pSequence->verSize -
			pVideo->pSequenceDisplayExtension->displayVerSize) >> 1;
	d1 = d1 + (pVideo->pDisplayedFrame->panVer >> 4);
	d1 = (d1>>2) &0x1FF;
	scan = d1;

	d1 = (pVideo->pSequence->horSize -
			pVideo->pSequenceDisplayExtension->displayHorSize) >> 1;
	d1 = d1 + (pVideo->pDisplayedFrame->panHor >> 4);

	pan = (d1 >> 2) & 0xFFF;
	// Program the integer part into PSV reg
	BoardWriteVideo(VID_PAN1, (BYTE)(pan>>8));
	BoardWriteVideo(VID_PAN0, (BYTE)(pan));

//		BoardWriteVideo(VID_SCN1, (BYTE)(scan>>8));
//		BoardWriteVideo(VID_SCN0, (BYTE)(scan));

	// Fractional Part in LSO, CSO
	d2 = (d1&0x0F) << 4;
	BoardReadVideo(VID_LSO);
	d1 = BoardReadVideo(VID_LSR1);
	BoardWriteVideo(VID_LSO, (BYTE)d2);
	BoardWriteVideo(VID_LSR1, (BYTE)d1);
	BoardWriteVideo(VID_CSO, (BYTE)(d2>>1));
	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoGetPTS
//	PARAMS	: None
//	RETURNS	: Return the next pts
//
//	PURPOSE	: Get the next video pts
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

DWORD VideoGetPTS(void)
{
	if(pVideo->nDecodedFrames < 5)
		return pVideo->firstFramePTS;
	else
 		return pVideo->framePTS;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : VideoClose
//	PARAMS	: None
//	RETURNS	: TRUE on success, FALSE otherwise
//
//	PURPOSE	: Close Video
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoClose(void)
{
	TraceDump();
	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//	
//
//	FUNCTION	: VideoForceBKC
//	PARAMS	: BOOL
//	RETURNS	: None
//	
//	PURPOSE	: Force the border color
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoForceBKC(BOOL on)
{
	if(!on)
		pVideo->dcf |= DCF0_EVD;
	else
		pVideo->dcf &= (~DCF0_EVD);
	BoardWriteVideo(VID_DCF0, (BYTE)(pVideo->dcf&0xFF));
	BoardWriteVideo(VID_DCF1, (BYTE)(pVideo->dcf>>8));
	return TRUE;

}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//	
//
//	FUNCTION	: VideoResetPSV
//	PARAMS	: BOOL
//	RETURNS	: None
//	
//	PURPOSE	: Reset the value programmed in PSV
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoResetPSV(void)
{
	// Program the integer part into PSV reg
	BoardWriteVideo(VID_PAN1, 0);
	BoardWriteVideo(VID_PAN0, 0);
	BoardWriteVideo(VID_LSR0, 0);
	BoardWriteVideo(VID_LSR1, 0);
	BoardWriteVideo(VID_CSO, 0);
	BoardWriteVideo(VID_LSO, 0);
	return TRUE;
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//	
//
//	FUNCTION	: VideoFreeze
//	PARAMS	: TOP or BOT
//	RETURNS	: None
//	
//	PURPOSE	: Force to display a field
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

void VideoFreeze(BOOL Top)
{
	BYTE dcf1, dcf0;

	dcf1 = (BYTE)((pVideo->dcf >> 8) & 0xFF);
	if(Top)
		dcf1 |= 1;
		
	dcf0 = (BYTE)(pVideo->dcf);
	dcf0 |= DCF0_USR;
	BoardWriteVideo(VID_DCF0, dcf0);
	BoardWriteVideo(VID_DCF1,dcf1);
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//	
//
//	FUNCTION	: VideoUnFreeze
//	PARAMS	: TOP or BOT
//	RETURNS	: None
//	
//	PURPOSE	: UnForce to display a field
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

void VideoUnFreeze(void)
{
	BoardWriteVideo(VID_DCF0, (BYTE)(pVideo->dcf & 0xFF));
	BoardWriteVideo(VID_DCF1, (BYTE)((pVideo->dcf >>8) & 0xFF));
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//	
//
//	FUNCTION	: VideoDisplaySingleField
//	PARAMS	: TOP or BOT
//	RETURNS	: None
//	
//	PURPOSE	: display a field
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

void VideoDisplaySingleField(BOOL Top)
{
	BYTE dcf1, dcf0;

	dcf0 = (BYTE)(pVideo->dcf&0xFF);
	if((pVideo->state == videoPaused) ||
	(pVideo->state == videoFirstFrameDecoded))
	{

 		dcf1 = 4;
		dcf0 |= DCF0_USR;
		BoardWriteVideo(VID_DCF1,dcf1);
	}
	BoardWriteVideo(VID_DCF0, dcf0);
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//	
//
//	FUNCTION	: VideoTestReg
//	PARAMS	: TOP or BOT
//	RETURNS	: None
//	
//	PURPOSE	: Test Video Access
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL VideoTestReg(void)
{
	BoardWriteVideo(CFG_MWP, 0x05);
	BoardWriteVideo(CFG_MWP, 0x55);
	BoardWriteVideo(CFG_MWP, 0xAA);

  if ((BoardReadVideo(CFG_MWP) & 0x1F)  != 0x05)
		return FALSE;
  if (BoardReadVideo(CFG_MWP)  != 0x55)
		return FALSE;
  if ((BoardReadVideo(CFG_MWP) & 0xFC) != 0xA8)
		return FALSE;
	return TRUE;									
}

void VideoTraceDumpReg()
{
		BYTE bh, bl;
		WORD w;
		int i;
		bh = BoardReadVideo(VID_DFP1)&0x3F;
		bl = BoardReadVideo(VID_DFP0);

		w = (WORD)bh<<8 | bl;

		DbgPrint("DFP = %x\n", w);

		for(i=0; i<3; i++)
		{
			 BoardWriteVideo(VID_DFP0, 	(BYTE)(pVideo->bufABC[i].adr));
			 BoardWriteVideo(VID_DFP1, 	(BYTE)(pVideo->bufABC[i].adr >> 8));
			 TRAP
		}

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgs\cpq3520a\sti3520a.h ===
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
// 	MODULE		:	STi3520A.H
// 	PURPOSE		:  STi3520A Register Description
// 	AUTHOR 		:  JBS Yadawa
// 	CREATED		:	12-26-96
//
//	Copyright (C) 1996-1997 SGS-THOMSON microelectronics
//
//	REVISION HISTORY:
//
// 	DATE			:
// 	COMMENTS		:
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


#ifndef __STI3520A_H__
#define __STI3520A_H__

#define 	MEM_SIZE			0x2000L
#define	PSZ_NTSC			0x07E9L
#define	PSZ_PAL				0x097EL
#include "stdefs.h"
//General MPEG2 definitions
#define FRAME_PERIOD	3003
#define FIELD_PERIOD	3003

//Start code found in the video bitstream.

#define SEQUENCE_SC				0xB3
#define GOP_SC					0xB8
#define PICTURE_SC				0x00
#define SLICESTART_SC			0x01
#define SLICEEND_SC				0xAF
#define SLICE_SC					0x58
#define USER_SC					0xB2
#define SEQUENCE_ERROR_SC		0xB4
#define EXTENSION_SC			0xB5
#define SEQUENCE_END_SC		0xB7
#define HACKED_SC				0xB1


//Extension IDS

#define SEQUENCE_EXTENSION_ID						0x01
#define SEQUENCE_DISPLAY_EXTENSION_ID 			0x02
#define QUANT_MATRIX_EXTENSION_ID					0x03	
#define COPYRIGHT_EXTENSION_ID						0x04
#define	SEQUENCE_SCALABLE_EXTENSION_ID			0x05
#define	PICTURE_DISPLAY_EXTENSION_ID				0x07
#define	PICTURE_CODING_EXTENSION_ID				0x08
#define	PICTURE_SPATIAL_SCALABLE_EXTENSION_ID	0x09
#define	PICTURE_TEMPORAL_SCALABLE_EXTENSION_ID	0x0A

typedef enum tagVideoState {
	videoPowerUp = 0,
	videoStartUp,
	videoInit,
	videoPlaying,
	videoPaused,
	videoStopped,
	videoRepeatPlay,
	videoErrorRecover,
	videoFirstFrameDecoded,
	videoEOS
} VIDEOSTATE;

typedef enum tagSkipMode {
	skipNone = 0,
	skipOneFrame,
	skipTwoFields,
	skipSecondField,
	skipDone
} SKIPMODE;
typedef enum tagPictType {
	IFrame = 0,
	PFrame,
	BFrame
} FRAMETYPE;


typedef enum tagPictureStruct {
	TOP_FIELD = 1,
	BOT_FIELD,
	FRAME
} PICTURESTRUCT;


typedef enum tagField {
	TOP = 0,	// Top Field
	BOT,		// Bottom Field
	FRM 		// Frame Picture
} FIELD;

typedef enum tagCommand {
	cmdNone = 0,
	cmdPlay,
	cmdPause,
	cmdStop,
	cmdSeek,
	cmdEOS
} COMMAND;
typedef enum tagErrCode {
	errNoError = 0,
	errHeaderFifoEmpty,
	errPipeline,
	errSerious,
	errStartCode,
	errUnknownInterrupt,
	errInvalidPictureType

}	ERRORCODE;

typedef enum tagCodingStandard {
	MPEG1 = 0,
	MPEG2
} CODINGSTANDARD;
// sequence releted definition

#define QMSIZE			64

typedef struct tagSeqHeader {
	DWORD		horSize;
	DWORD		verSize;
	DWORD		aspectRatio;
	DWORD		frameRate;
	DWORD		bitRate;
	DWORD		vbvBufferSize;
	DWORD		constrainedFlag;
	DWORD		loadIntra;
	BYTE		intraQuantiserMatrix[QMSIZE];
	DWORD		loadNonIntra;
	BYTE		nonIntraQuantiserMatrix[QMSIZE];
	
} SEQUENCEHEADER, FARPTR * PSEQUENCEHEADER;


// gop releted stuff

typedef struct tagGopHeader {
	DWORD		timeCode;
	DWORD		closedGOP;
	DWORD		brokenLink;
}	GOPHEADER, FARPTR	*PGOPHEADER;


//picture releted stuff

typedef struct tagPictureHeader {
	DWORD			temporalReference;
	DWORD			pictureCodingType;
	DWORD			vbvDelay;
	DWORD			fFcode;
	DWORD			bFcode;
}	PICTUREHEADER, FARPTR *PPICTUREHEADER;

//Extension fields

typedef struct tagSequenceExtension {
	DWORD		extensionSCID;
	DWORD		profileAndLevel;
	DWORD		progressiveSequence;
	DWORD		chromaFormat;
	DWORD		horSizeExtension;
	DWORD		verSizeExtension;
	DWORD		bitRateExtension;
	DWORD		vbvBufSizeExtension;
	DWORD		lowDelay;
	DWORD		frameRateExtensionN;
	DWORD		frameRateExtensionD;
	
}	SEQUENCEEXTENSION, FARPTR * PSEQUENCEEXTENSION;


// sequence display extension

typedef struct tagSequnceDisplayExtension {

	DWORD		videoFormat;
	DWORD		colorDescription;
 	DWORD		colorPrimaries;
	DWORD		transferCharacteristic;
	DWORD		matrixCoefficients;
	DWORD		displayHorSize;
	DWORD		displayVerSize;

} SEQUENCEDISPLAYEXTENSION, FARPTR * PSEQUENCEDISPLAYEXTENSION;


// Picture coding extension

typedef struct tagPictureCodingExtension {
	BYTE		fCode[2][2];
	DWORD		intraDCPrecision;
	DWORD		pictureStructure;
	DWORD		topFieldFirst;
	DWORD		framePredFrameDCT;
	DWORD		concealmentMotionVectors;
	DWORD		qScaleType;
	DWORD		intraVLCFormat;
	DWORD		alternateScan;
	DWORD		repeatFirstField;
	DWORD		chroma420Type;
	DWORD		progressiveFrame;
	DWORD		compositeDisplayFlag;
	DWORD		vAxis;
	DWORD		fieldSequence;
	DWORD		subCarrier;
	DWORD		burstAmplitude;
	DWORD		subCarrierPhase;
}	PICTURECODINGEXTENSION, FARPTR * PPICTURECODINGEXTENSION;


// quant matrix
typedef struct tagQuantMatrixExtension {
	DWORD		loadIntraQuantMatrix;
	BYTE		intraQuantMatrix[64];
	DWORD		loadNonIntraQuantMatrix;
	BYTE		nonIntraQuantMatrix[64];
	DWORD		loadChromaIntraQuantMatrix;
	BYTE		chromaIntraQuantMatrix[64];
	DWORD		loadChromaNonIntraQuantMatrix;
	BYTE		chromaNonIntraQuantMatrix[64];
}	QUANTMATRIXEXTENSION, FARPTR * PQUANTMATRIXEXTENSION;

// Pan Scan Vectors
typedef struct tagPictureDisplayExtension {

	DWORD		horOffset;
	DWORD		verOffset;

} PICTUREDISPLAYEXTENSION, FARPTR * PPICTUREDISPLAYEXTENSION;

#define XOFFSET			100
#define YOFFSET			30
#define XDS_CONST			726
#define YDS_CONST			129

// RegisterManual


// VideoRegisters
#define	CFG_MCF							0x00
	#define	MCF_M20								0x00
	#define	MCF_REFRESH							0x24

#define	CFG_CCF							0x01
	#define	CCF_EVI								0x01
	#define	CCF_EDI								0x02
	#define	CCF_ECK								0x04
	#define	CCF_EC2								0x08
	#define	CCF_EC3								0x10
	#define	CCF_PBO								0x20
	#define	CCF_M16								0x40
	#define	CCF_M32								0x80
#define			VID_CTL					0x02
	#define		CTL_EDC							0x01
	#define		CTL_SRS							0x02
	#define		CTL_PRS							0x04
	#define		CTL_ERP							0x08
	#define		CTL_DEC							0x10
	#define		CTL_CFB							0x20
	#define		CTL_ERS							0x40
	#define		CTL_ERU							0x80
#define	VID_TIS							0x03
	#define		TIS_EXE							0x01
	#define		TIS_RPT							0x02
	#define		TIS_FIS							0x04
	#define		TIS_OVW							0x08
	#define		TIS_NO_SKIP						0x00
	#define		TIS_SKIP1P						0x10
	#define		TIS_SKIP2P	 					0x20
	#define		TIS_SKIPSTOP					0x30
	#define		TIS_MP2							0x40
#define	VID_PFH							0x04
#define	VID_PFV							0x05
#define	VID_PPR1							0x06
#define	VID_PPR2							0x07
	#define		PPR2_AZZ							0x01
	#define		PPR2_IVF							0x02
	#define		PPR2_QST							0x04
	#define		PPR2_CMV							0x08
	#define		PPR2_FRM							0x10
	#define		PPR2_TFF							0x20
#define	CFG_MRF							0x08
#define	CFG_MWF							0x08
#define	CFG_BMS							0x09
#define	CFG_MRP							0x0A
#define	CFG_MWP							0x0B
#define	VID_DFP1							0x0C
#define	VID_DFP0							0x0D
#define	VID_RFP1							0x0E
#define	VID_RFP0							0x0F
#define	VID_FFP1							0x10
#define	VID_FFP0							0x11
#define	VID_BFP1							0x12
#define	VID_BFP0							0x13
#define	VID_VBG1							0x14
#define	VID_VBG0							0x15
#define	VID_VBL1							0x16
#define	VID_VBL0							0x17
#define	VID_VBS1							0x18
#define	VID_VBS0							0x19
#define	VID_VBT1							0x1A
#define	VID_VBT0							0x1B
#define	VID_ABG1							0x1C
#define	VID_ABG0							0x1D				
#define	VID_ABL1							0x1E				
#define	VID_ABL0							0x1F
#define	VID_ABS1							0x20				
#define	VID_ABS0							0x21				
#define	VID_ABT1							0x22
#define	VID_ABT0							0x23
#define	VID_DFS							0x24
#define	VID_DFW							0x25
#define	VID_DFA							0x26
#define	VID_XFS							0x27
#define	VID_XFW							0x28
#define	VID_XFA							0x29
#define	VID_OTP							0x2A
#define	VID_OBP							0x2B
#define	VID_PAN1							0x2C
#define	VID_PAN0							0x2D
#define	VID_SCN1							0x2E
#define	VID_SCN0							0x2F
#define	CKG_PLL							0x30
	#define PLL_SELECT_PIXCLK					0xC0
	#define PLL_DEVIDE_BY_N						0x10
	#define PLL_MULT_FACTOR						0x09
#define	CKG_CFG							0x31
	#define CFG_INTERNAL_AUDCLK				0x01
	#define CFG_INTERNAL_CLK					0x02
	#define CFG_PIXCLK_INPUT					0x00
	#define CFG_PCMCLK_INPUT					0x00
	#define CFG_MEMCLK_INPUT					0x00
	#define CFG_AUDCLK_OUTPUT					0x80
#define	CKG_AUD							0x32
#define	CKG_VID							0x33
#define	CKG_PIX							0x34
#define	CKG_PCM							0x35
#define	CKG_MCK							0x36
#define	CKG_AUX							0x37
#define	CFG_DRC							0x38
	#define	DRC_SDR								0x01
	#define	DRC_HPO								0x02
	#define	DRC_CLK								0x04
	#define	DRC_SGR								0x08
	#define	DRC_MRS								0x20
	#define	DRC_NDP								0x40
#define	CFG_BFS							0x39
	#define	BFS_CHR								0x40
#define	VID_SCM							0x3A
#define	VID_STA2							0x3B
#define	VID_ITM2							0x3C
	#define		ITM_ABE							0x01
	#define		ITM_WFN							0x02
	#define		ITM_RFN							0x04
	#define		ITM_ABF							0x08
	#define		ITM_HAF							0x10
	#define		ITM_SCR							0x20
	#define		ITM_ERR							0x40
	#define		ITM_NDP							0x80
#define	VID_ITS2							0x3D
#define	PES_CF1							0x40
	#define 	CF1_IVI								0x20
	#define 	CF1_SDT								0x80
#define	PES_CF2							0x41
	#define 	CF2_IAI								0x10
	#define 	CF2_SS								0x20
	#define 	CF2_AUTO								0x00
	#define 	CF2_MP1SYS							0x40
	#define 	CF2_MP2PES							0x80
	#define 	CF2_MP2SYS							0xC0	
#define	PES_STA							0x43
	#define		STA_MP2							0x80
#define	PES_SC1							0x44
#define	PES_SC2							0x45
#define	PES_SC3							0x46
#define	PES_SC4							0x47
#define	PES_SC5							0x48
#define	PES_TS1							0x49
#define	PES_TS2							0x4A
#define	PES_TS3							0x4B
#define	PES_TS4							0x4C
#define	PES_TS5							0x4D
#define	VID_ITM1							0x60
#define	VID_ITM0							0x61
	#define		ITM_SCH							0x0001
	#define		ITM_BFF							0x0002
	#define		ITM_HFE							0x0004
	#define		ITM_BBF							0x0008
	#define		ITM_BBE							0x0010
	#define		ITM_VSB							0x0020
	#define		ITM_VST							0x0040
	#define		ITM_PSD							0x0080
	#define		ITM_PER							0x0100
	#define		ITM_PID							0x0200
	#define		ITM_WFE							0x0400
	#define		ITM_RFF							0x0800
	#define		ITM_HFF							0x1000
	#define		ITM_BMI							0x2000
	#define		ITM_SER							0x4000
	#define		ITM_PDE							0x8000
#define	VID_ITS1							0x62
#define	VID_ITS0							0x63
#define	VID_STA1							0x64
#define	VID_STA0							0x65
#define	VID_HDF							0x66
#define	VID_CD							0x67
#define	VID_SCD							0x68
#define	VID_HDS							0x69
	#define		HDS_HDS							0x01
	#define		HDS_QMI_INTRA					0x02
	#define		HDS_QMI_NON_INTRA  			0x00
#define	VID_LSO							0x6A
#define	VID_LSR0							0x6B
#define	VID_CSO							0x6C
#define	VID_LSR1							0x6D
	#define		LSR1_BS							0x02
#define	VID_YDO							0x6E
#define	VID_YDS							0x6F
#define	VID_XDO1							0x70
#define	VID_XDO0							0x71
#define	VID_XDS1							0x72
#define	VID_XDS0							0x73
#define			VID_DCF1					0x74
	#define		DCF1_FLD							0x01
	#define		DCF1_DAM							0x0E
	#define		DCF1_FRZ							0x10
	#define		DCF1_OAM							0x20
	#define		DCF1_OAD							0xC0
#define			VID_DCF0							0x75
	#define		DCF0_VCFFULLRESLRWI					0x00
	#define		DCF0_VCFFULLRESLR					0x01
	#define		DCF0_VCFFULLRESFRWI					0x02
	#define		DCF0_VCFFULLRESFR					0x03
	#define		DCF0_VCFHALFRESCI					0x04
	#define		DCF0_VCFHALFRESCR					0x05
	#define		DCF0_VCFHALFRESLI				0x06
	#define		DCF0_DSR							0x08
	#define		DCF0_EOS							0x10
	#define		DCF0_EVD							0x20
	#define		DCF0_PXD							0x40
	#define		DCF0_USR							0x80
#define	VID_QMW							0x76
#define	VID_REV							0x78

//Note - JBS
//Audio Reg is 0x80 + Audio Reg on cpq board

// AUDIO REGISTER DESCRIPTION
#define AUD_ANC0	0x86
#define AUD_ANC8	0x87
#define AUD_ANC16	0x88
#define AUD_ANC24	0x89
#define AUD_ESC0	0x8A
#define AUD_ESC8	0x8B
#define AUD_ESC16	0x8C
#define AUD_ESC24	0x8D
#define AUD_ESC32	0x8E
#define AUD_ESCX0	0x8F
#define AUD_LRP	0x91
#define AUD_FFL0	0x94
#define AUD_FFL8	0x95
#define AUD_P18	0x96
#define AUD_CDI0	0x98
#define AUD_FOR	0x99
#define AUD_ITR0	0x9A
#define AUD_ITR8	0x9B
#define AUD_ITM0	0x9C
#define AUD_ITM8	0x9D
#define AUD_LCA	0x9E
#define AUD_EXT	0x9F
#define AUD_RCA	0xA0
#define AUD_SID	0xA2
#define AUD_SYN	0xA3
#define AUD_IDE	0xA4
#define AUD_SCM	0xA5
#define AUD_SYS	0xA6
#define AUD_SYE	0xA7
#define AUD_LCK	0xA8
#define AUD_CRC	0xAA
#define AUD_SEM	0xAC
#define AUD_PLY	0xAE
#define AUD_MUT	0xB0
#define AUD_SKP	0xB2
#define AUD_ISS	0xB6
#define AUD_ORD	0xB8
#define AUD_LAT	0xBC
#define AUD_RES	0xC0
#define AUD_RST	0xC2
#define AUD_SFR	0xC4
#define AUD_DEM	0xC6
#define AUD_IFT	0xD2
#define AUD_SCP	0xD3
#define AUD_ITS	0xDB
#define AUD_IMS	0xDC
#define AUD_HDR0	0xDE
#define AUD_HDR1	0xDF
#define AUD_HDR2	0xE0
#define AUD_HDR3	0xE1
#define AUD_PTS0	0xE2
#define AUD_PTS1	0xE3
#define AUD_PTS2	0xE4
#define AUD_PTS3	0xE5
#define AUD_PTS4	0xE6
#define AUD_ADA	0xEC
#define AUD_REV	0xED
#define AUD_DIV	0xEE
#define AUD_DIF	0xEF
#define AUD_BBE	0xF0

typedef struct tagHeaderParser {
	BYTE b, next;
	BOOL	first, second;
}	HEADERPARSER, FARPTR *PHEADERPARSER;

typedef struct tagPictureBuffer {
	DWORD			adr;
	DWORD			pts;
	DWORD			tref;
	DWORD			panHor;
	DWORD			panVer;
	DWORD			nTimesDisplayed;
	DWORD			nTimesToDisplay;
	FIELD			curField;
	FIELD			firstField;
	FRAMETYPE	frameType;
	
} PICTUREBUFFER, FARPTR *PPICTUREBUFFER;


typedef struct tagSTi3520A {
//Different registers
	DWORD										itm, its, bbl, abl;
	DWORD										tis, ppr1, ppr2, pfv, pfh;
	DWORD										rfp, bfp, ffp, dfp, dcf, ctl;
	FRAMETYPE									frameType;
// Buffer sizes
	DWORD										videoBufferSize;
	DWORD										audioBufferSize;
	DWORD										spBufferSize;
	DWORD										prevBuf;
	PICTUREBUFFER							bufABC[3];
	FIELD										curImage;
	FIELD										thisField;
	PPICTUREBUFFER							pDecodedFrame;
	PPICTUREBUFFER							pDisplayedFrame;
	PPICTUREBUFFER							pNextFrame;
	DWORD										nTimesDisplayed;
	DWORD										nTimesToDisplay;
// MPEG1 OR MPEG2
	CODINGSTANDARD								codingStandard;

	SEQUENCEHEADER								sequence;
	PSEQUENCEHEADER								pSequence;
	GOPHEADER									gop;
	PGOPHEADER									pGop;
	PICTUREHEADER								picture;
	PPICTUREHEADER								pPicture;
	SEQUENCEEXTENSION							sequenceExtension;
	PSEQUENCEEXTENSION							pSequenceExtension;
	SEQUENCEDISPLAYEXTENSION					sequenceDisplayExtension;
	PSEQUENCEDISPLAYEXTENSION					pSequenceDisplayExtension;
	PICTURECODINGEXTENSION						pictureCodingExtension;
	PPICTURECODINGEXTENSION						pPictureCodingExtension;
	QUANTMATRIXEXTENSION						quantMatrixExtension;	
	PQUANTMATRIXEXTENSION						pQuantMatrixExtension;	
	PICTUREDISPLAYEXTENSION						pictureDisplayExtension;
	PPICTUREDISPLAYEXTENSION					pPictureDisplayExtension;
	HEADERPARSER								headerParser;
	PHEADERPARSER								pHeaderParser;
	ERRORCODE									errorCode;
	VIDEOSTATE									state;
	DWORD										nDecodedFrames;
	DWORD										nDisplayedFrames;
	COMMAND										command;
	BOOL										firstPPictureFound;
	BOOL										displayEnabled;
	BOOL										skipRequest;
	BOOL										repeatRequest;
	DWORD										nRepeat;
	BOOL										starving;
	DWORD										scdCount;
	DWORD										prevScdCount;
	DWORD										cdCount;
	DWORD										prevCdCount;
	BOOL										validPTS;
	DWORD										framePTS;
	DWORD										pts;
	DWORD										prevPTS;
	BOOL										instructionComputed;
	BOOL									 	sync;
	BOOL										swAC3;
	FIELD										curField;
	FIELD										frozenField;
	FIELD										firstField;
	SKIPMODE									skipMode;
	DWORD										skipCount;
	BOOL										panScan;
	BOOL										stillDecode;
	DWORD										firstFramePTS;
	BOOL										firstPtsFound;
	BOOL										lastFrameDecoded;
	DWORD										nVsyncsWithoutDsyncs;
	BOOL										resetAndRestart;
	BOOL										waitForLastFrame;
	BOOL										prevVsyncTop;
}	VIDEO, FARPTR * PVIDEO;


PVIDEO VideoOpen(void);
BOOL	VideoPause(void);
BOOL	VideoPlay(void);
BOOL VideoStop(void);
BOOL VideoSeek(void);
BOOL	VideoInitialize(void);
BOOL VideoEnableDramInterface(void);
BOOL VideoSetBufferSize (void);
BOOL VideoInitPLL(void);
BOOL	VideoWaitTillHDFNotEmpty (void);
BOOL	VideoInitHeaderParser (void);
BOOL VideoInterrupt(void);
BOOL	VideoDsyncInterrupt(void);
BOOL	VideoVsyncInterrupt(BOOL Top);
BOOL VideoErrorInterrupt(void);
BOOL VideoHeaderHit (void);
BOOL VideoNextHeaderByte (void);
BOOL VideoNextSC (void);
BOOL VideoSequenceHeader (void);
BOOL VideoGopHeader (void);
BOOL  VideoPictureHeader (void);
BOOL VideoParsePictureHeader (void);
BOOL VideoExtensionHeader (void);
BOOL VideoSequenceEnd(void);
BOOL VideoSequenceError(void);
BOOL VideoUserData(void);
BOOL VideoSequenceExtensionHeader (void);
BOOL VideoSequenceDisplayExtensionHeader(void);
BOOL VideoSequenceScalableExtensionHeader(void);
BOOL VideoCopyrightExtensionHeader(void);
BOOL VideoQuantMatrixExtensionHeader(void);
BOOL VideoPictureCodingExtensionHeader(void);
BOOL VideoPictureDisplayExtensionHeader(void);
BOOL VideoPictureSpatialScalableExtensionHeader(void);
BOOL VideoPictureTemporalScalableExtensionHeader(void);
BOOL VideoLoadQuantMatrix(BOOL);
BOOL VideoSetReconstructionBuffer (FRAMETYPE frame);
BOOL VideoSetDisplayBuffer (FRAMETYPE frame);
BOOL VideoSoftReset(void);
BOOL VideoProgramDisplayWindow(void);
BOOL VideoMaskInterrupt(void);
BOOL VideoUnmaskInterrupt(void);
BOOL VideoStoreInstruction(void);
BOOL VideoComputeInstruction(void);
BOOL VideoGetBBL(void);
BOOL VideoSwitchSRC(BOOL on);
BOOL VideoSetSRC(DWORD, DWORD);
BOOL VideoFinishDecoding(void);
BOOL	VideoGetABL(void);
BOOL VideoReadSCD(void);
BOOL	VideoAssociatePTS(void);
BOOL VideoProgramPanScanVectors(void);
DWORD VideoGetPTS(void);
BOOL VideoInitDecoder(void);
BOOL VideoClose(void);
BOOL VideoComputePictureBuffers(void);
BOOL VideoSkipOrDecode(void);
BOOL VideoStillDecode(void);
BOOL VideoNormalDecode(void);
BOOL VideoConvertSixteenByNineToFourByThree(void);
BOOL VideoForceBKC(BOOL on);
BOOL VideoResetPSV(void);
void VideoUnFreeze(void);
void VideoFreeze(BOOL Top);
void VideoDisplaySingleField(BOOL Top);
BOOL VideoTestReg(void);
ULONGLONG GetCCTime();
#endif // __STI3520A_H__


























													

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgs\cpq3520a\subpic2.h ===
typedef struct _SP_DCSQ {

	WORD	spdcsq_stm;			// start time in frames
	WORD	spdcsq_sa;			// start address of next sequence cmd
	UCHAR	spdcsq_cmd[];		// commands for this descriptor
} SP_DCSQ, *PSP_DCSQ;

typedef enum _SP_DCCMD {

	FSTA_DSP,  					// forcebly start display of subpicture
	STA_DSP,					// start display of subpicture
	STP_DSP,					// stop display of subpicture
	SET_COLOR,
	SET_CONTR,
	SET_DAREA,
	SET_DSPSTRT,
	CHG_COLCON,					// change color / contrast (mid picture)
	CMD_END = 0xFF

} SP_DCCMD, *PSP_DCCMD;

typedef struct _SPPALLETTE {

	UCHAR color[4];
	UCHAR mix[4];

}SPPALLETTE, * PSPPALLETTE;

typedef struct _YUVPAL {
	UCHAR	ucY[16];
	UCHAR	ucU[16];
	UCHAR	ucV[16];
	UCHAR	ucAlpha[16];
} YUVPAL, *PYUVPAL;

typedef struct _SCOLCON {
	UCHAR emph1col:4;
	UCHAR emph2col:4;
	UCHAR backcol:4;
	UCHAR patcol:4;
	UCHAR emph1con:4;
	UCHAR emph2con:4;
	UCHAR backcon:4;
	UCHAR patcon:4;
	
} SCOLCON, *PSCOLCON;

typedef struct _PXCTLX {
	UCHAR chgpixhi:2;
	UCHAR chgpix;
	SCOLCON colcon;
} PXCTLX, *PPXCTLX;

typedef struct _PXCTLY {
	UCHAR chglinhi:2;
	UCHAR chglin;
	UCHAR chgstophi:2;
	UCHAR chgres:2;
	UCHAR numchg:4;
	UCHAR chgstop;

	PXCTLX xchg[];
} PXCTLY, *PPXCTLY;

typedef struct _SMYCOLCON {

	ULONG	stopx;
	SPPALLETTE chgsppal;
} SMYCOLCON, *PSMYCOLCON;

typedef struct _SPPCKHDR {
	UCHAR phdr_start[3];
	UCHAR phdr_strmid;
	WORD phdr_packet_length;
	UCHAR phdr_flags[2];
	UCHAR phdr_hdr_length;
	UCHAR phdr_PTS[5];
} SPPCKHDR, *PSPPCKHDR;

typedef struct _OSDYUV {
	UCHAR osdV:4;
	UCHAR osdU:4;
	UCHAR osdT:1;
	UCHAR osdres:1;
	UCHAR osdY:6;
} OSDYUV, *POSDYUV;

typedef struct _OSDHEAD {
	USHORT osdhStarty:9;
	USHORT osdhres1:5;
	USHORT osdhMQ:2;
	USHORT osdhStopy:9;
	USHORT osdhres2:3;
	USHORT osdhMix:4;
	USHORT osdhStartx:10;
	USHORT osdhres3:6;
	USHORT osdhStopx:10;
	USHORT osdhres4:6;
	OSDYUV osdhYUV[16];
} OSDHEAD, *POSDHEAD;





typedef struct _SP_DECOD_CTL {

	PPXCTLY ppxcd;				// current pixel control data
	SPPALLETTE sppPal;			// current subpicture pallette
	YUVPAL spYUV;				// current YUV mapping
	ULONG ulDecodStart;			// decode start address for compressed data
	ULONG ulDSAx;				// x coordinate of display area
	ULONG ulDSAy;				// y coordinate of display area
	ULONG ulDSAw;				// width of display area
	ULONG ulDSAh;				// height of display area	

	PBYTE pData;				// data source buffer
	ULONG curData;				// current size of datapacket
	ULONG cData;				// total size of this data packet

	PBYTE pTopWork;				// top field buffer
	PBYTE pBottomWork;			// bottom field buffer
	ULONG cDecod;				// size of the decode buffers

	ULONG cTopDisp;				// top field for display
	ULONG cBottomDisp;			// bottom field for display
	ULONG cDisp;				// size of the display buffers

	ULONG pSPCmds;				// pointer to current set of SPCmds
	ULONG ulFrameCnt;			// number of frames since we started
								// this subpicture

	ULONG decFlags;				// decodeing flags

//	KSSTATE spState;			// subpicture decoding state
	
	ULONG stsPic;				// time to display the current picture
	ULONG stsNextUpd;			// time of next subpicture update
	ULONG cFrames;				// count of frames 

} SP_DECODE_CTL, *PSP_DECODE_CTL;

#define SPDECFL_BUF_IN_USE 			0x0001
#define SPDECFL_SUBP_ON_DISPLAY 	0x0002
#define SPDECFL_LAST_FRAME			0x0004
#define SPDECFL_SUBP_DECODED		0x0008

typedef struct _SP_DECODE_ADDR {
	UCHAR opCode;
	UCHAR wTopAddr[2];
	UCHAR wBottomAddr[2];
} SP_DECODE_ADDR, *PSP_DECODE_ADDR;

typedef struct SP_STRM_EX {
	SP_DECODE_CTL pdecctl;
	//PHW_STREAM_REQUEST_BLOCK pSrbQ;
	ULONG cOffset;
    struct _HW_DEVICE_EXTENSION *phwdevex;
} SP_STRM_EX, *PSP_STRM_EX;


#define DAREA_START_UB_MASK	0x3f	// display area upper bit mask
#define DAREA_END_UB_MASK 0x3		// display area end upper bit mask
#define DAREA_LB_MASK 0xf0

#define DAREA_START_UB_SHIFT 0x4
#define DAREA_END_UB_SHIFT 0x8

#define SP_LCTL_TERM 0xFFFFFF0F
#define SP_MAX_INPUT_BUF	53220	// maximum size of the subpicture input buffer

BOOL UpdateSPConsts(PSP_STRM_EX pspstrmex);

BOOL DecodeRLE(PVOID pdest, ULONG cStart, PSP_STRM_EX pspstrmex);

void StartSPDecode (PSP_STRM_EX pspstrmex);

BOOL BuildSPFields (PSP_STRM_EX pspstrmex);

void DumpPacket(PSP_STRM_EX pspstrmex);

BOOL AllocateSPBufs(PSP_DECODE_CTL pdecctl);

void SubPicIRQ(PSP_STRM_EX pspstrmex);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgs\cpq3520a\trace.c ===
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//	MODULE		:	TRACE.C
// 	PURPOSE		:  Trace the decoding
// 	AUTHOR 		:  JBS Yadawa
// 	CREATED		:	12-26-96
//
//	Copyright (C) 1996-1997 SGS-THOMSON microelectronics
//
//	REVISION HISTORY:
//
// 	DATE			:
// 	COMMENTS		:
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


#include "strmini.h"
#include "stdefs.h"
#include "trace.h"
#include "sti3520a.h"
#define TSIZE 8192

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//	Trace the various things and print them to a file for the 
//	offline analisys
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

static BYTE DummyTrace[TSIZE];
static int dptr = 0;
extern DWORD dwVideoRec, dwVideoRet, dwAudioRec, dwAudioRet, dwSubRec, dwSubRet;
DWORD dwVideoRec=0, dwVideoRet=0, dwAudioRec=0, dwAudioRet=0, dwSubRec = 0, dwSubRet = 0;

extern DWORD RdyVid, RdyAud, RdySub;
DWORD RdyVid = 0, RdyAud = 0, RdySub = 0;

extern PVIDEO pVideo;

#ifdef TRACE_INTR
static TRACEIT TraceAr[TSIZE];
static int tptr = 0;
static char istr[ext+1][20] = {"V-TOP", "V-BOT", "PSD  ", 
									"PICT ", "SEQ  ", "GOP  ",
									"S-END", "USR  ", "P-EXT","SKIPS",
									"SKP-F", "SKP-1", "SKP-2",
									"SKP-N", "SKP-D",	"UNKNW", "ERROR",
									"STORV","STORP","COMP ",
									"EXT  "};
void TraceIntrF(INTR i, BYTE ins, BYTE pt)
{
	TraceAr[tptr].intr = i;
	TraceAr[tptr].ins = ins;
	TraceAr[tptr].pt = pt;
	VideoGetABL();
	VideoGetBBL();
	TraceAr[tptr].abl = pVideo->abl;
	TraceAr[tptr].vbl = pVideo->bbl;
	tptr = (tptr+1)%TSIZE;
	
}

void TraceResetF(void)
{
	tptr = 0;
}


#endif // TRACE_INTR


#ifdef TRACE_PICT_EXT
TRACEPICTEXT TracePict[TSIZE];
int tpict;
void TracePictExtF(BYTE n, BYTE tff, BYTE rff, BYTE pf, BYTE ps)
{
	TracePict[tpict].n 	= n;
	TracePict[tpict].tff = tff;
	TracePict[tpict].rff	= rff;
	TracePict[tpict].pf 	= pf;
	TracePict[tpict].ps 	= ps;
	tpict = (tpict+1)%TSIZE;
}
#endif // TRACE_PICT_EXT

#ifdef TRACE_MP
static char mpTraceStr[mTraceSPDone+1][10]= {
	"PLAY", "PAUSE", "STOP",
	"VDATA", "ADATA", "SPDATA",
	"VDONE", "ADONE", "D-ENTRY",
	"CANCEL", "LASTV", "LASTA", 

	"TIMEOUT", "OPEN",	"INFO", 

	"INIT", "CLOSE", "UNINIT",
	"UNKNOWN","DISC","EOS","STILL",
	"SPDONE"
};

void MPTraceF(int tr)
{
	switch(tr)
	{
		case mTraceVideo:
			dwVideoRec++;
			RdyVid++;
 		break;
		case mTraceVideoDone:
			dwVideoRet++;
 		break;
		case mTraceAudio:
			dwAudioRec++;
			RdyAud++;
 		break;
		case mTraceAudioDone:
			dwAudioRet++;
 		break;
	case mTraceSP:
			dwSubRec++;
			RdySub++;
        break;
	case mTraceSPDone:
			dwSubRet++;
		break;

	case mTraceRdyVid:
		RdyVid--;
		break;

	case mTraceRdyAud:
		RdyAud--;
		break;

	case mTraceRdySub:
		RdySub--;
		break;
	

		default:
			DummyTrace[dptr] = tr;
			dptr = (dptr+1)%TSIZE;
 		break;

	}
}

void MPTResetF(void)
{
	dptr = 0;
}

#endif // TRACE_MP



TRACETREF Tref[256];
int iTref = 0;									

void TraceTref(DWORD tRef, int frame)
{
	Tref[iTref].tRef = tRef;
	Tref[iTref].frametype = frame;
	iTref = (iTref+1)%256;
}

					  

void TraceDump(void)
{
#ifdef TRACE_INTR
	TraceAr[(tptr+1)%TSIZE].ins = 0xFF;
	for(i=0; i<tptr; i++)
	{
		DbgPrint("INTR: %s, INS: %2x, PT=%2x, VBL = %4lx, ABL = %4lx \n",  istr[TraceAr[i].intr], TraceAr[i].ins, TraceAr[i].pt,TraceAr[i].vbl,TraceAr[i].abl );
	}
#endif // TRACE_INTR

#ifdef TRACE_MP
	for(i=0; i<dptr; i++)
	{
		DbgPrint("MPCMD : %s\n", mpTraceStr[DummyTrace[i]]); 
	}
	DbgPrint("Video REC = %ld, Video Ret = %ld, Audio Rec = %ld, Audio Ret = %ld\n", dwVideoRec, dwVideoRet, dwAudioRec, dwAudioRet);
	dptr = 0;
	dwVideoRec = dwVideoRet = dwAudioRec = dwAudioRet =  dwSubRec = dwSubRet = RdyVid = RdyAud = RdySub = 0;
#endif // TRACE_MP

#ifdef TRACE_PICT_EXT
	for(i=0; i<TSIZE; i++)
	{
		DbgPrint("NTimes= %d, TFF= %d, RFF= %d, PF= %d, PS= %d\n", TracePict[i].n, TracePict[i].tff,TracePict[i].rff,TracePict[i].pf,TracePict[i].ps);
	}
	tpict = 0;
#endif
#ifdef TRACE_DUMP_REG
//	VideoTraceDumpReg();
#endif
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgs\cpq3520a\subpic.h ===
typedef struct _SP_DCSQ {

	WORD	spdcsq_stm;			// start time in frames
	WORD	spdcsq_sa;			// start address of next sequence cmd
	UCHAR	spdcsq_cmd[];		// commands for this descriptor
} SP_DCSQ, *PSP_DCSQ;

typedef enum _SP_DCCMD {

	FSTA_DSP,  					// forcebly start display of subpicture
	STA_DSP,					// start display of subpicture
	STP_DSP,					// stop display of subpicture
	SET_COLOR,
	SET_CONTR,
	SET_DAREA,
	SET_DSPSTRT,
	CHG_COLCON,					// change color / contrast (mid picture)
	CMD_END = 0xFF

} SP_DCCMD, *PSP_DCCMD;

typedef struct _SPPALLETTE {

	UCHAR color[4];
	UCHAR mix[4];

}SPPALLETTE, * PSPPALLETTE;


typedef struct _YUVPAL {
	UCHAR	ucY[16];
	UCHAR	ucU[16];
	UCHAR	ucV[16];
} YUVPAL, *PYUVPAL;

typedef struct _MAPPAL {
	UCHAR	yuvMap[16];
	UCHAR	origMap[16];
	UCHAR	ucAlpha[16];
	UCHAR	palFlags[16];
} MAPPAL, *PMAPPAL;

#define fInUse 		0x01
#define fUseAlpha 	0x02

typedef struct _SCOLCON {
	UCHAR emph1col:4;
	UCHAR emph2col:4;
	UCHAR backcol:4;
	UCHAR patcol:4;
	UCHAR emph1con:4;
	UCHAR emph2con:4;
	UCHAR backcon:4;
	UCHAR patcon:4;
	
} SCOLCON, *PSCOLCON;

typedef struct _PXCTLX {
	UCHAR chgpixhi:2;
	UCHAR chgpix;
	SCOLCON colcon;
} PXCTLX, *PPXCTLX;

typedef struct _PXCTLY {
	UCHAR chglinhi:2;
	UCHAR chglin;
	UCHAR chgstophi:2;
	UCHAR chgres:2;
	UCHAR numchg:4;
	UCHAR chgstop;

	PXCTLX xchg[];
} PXCTLY, *PPXCTLY;

typedef struct _SMYCOLCON {

	ULONG	stopx;
	SPPALLETTE chgsppal;
} SMYCOLCON, *PSMYCOLCON;

typedef struct _SPPCKHDR {
	UCHAR phdr_start[3];
	UCHAR phdr_strmid;
	WORD phdr_packet_length;
	UCHAR phdr_flags[2];
	UCHAR phdr_hdr_length;
	UCHAR phdr_PTS[5];
} SPPCKHDR, *PSPPCKHDR;

typedef struct _OSDYUV {
	UCHAR osdV:4;
	UCHAR osdU:4;
	UCHAR osdT:1;
	UCHAR osdres:1;
	UCHAR osdY:6;
} OSDYUV, *POSDYUV;

typedef struct _OSDHEAD {
	USHORT osdhStarty:9;
	USHORT osdhres1:5;
	USHORT osdhMQ:2;
	USHORT osdhStopy:9;
	USHORT osdhres2:3;
	USHORT osdhMix:4;
	USHORT osdhStartx:10;
	USHORT osdhres3:6;
	USHORT osdhStopx:10;
	USHORT osdhres4:6;
	OSDYUV osdhYUV[16];
} OSDHEAD, *POSDHEAD;

typedef struct _SPHLI {
	BOOLEAN fValid;
	BOOLEAN fProcessed;
	BOOLEAN fActive;
	KSPROPERTY_SPHLI hli;
} SPHLI, *PSPHLI;



typedef struct _SP_DECOD_CTL {

	PPXCTLY ppxcd;				// current pixel control data
	SPHLI	HLI;				// current highligh information
	SPPALLETTE sppPal;			// current subpicture pallette
	YUVPAL spYUV;				// current YUV mapping
	MAPPAL	mappal;				// current pallette to YUV mapping
	UCHAR	minCon;				// current minimum contrast level
	UCHAR	minConCol;			// minimum contrast color


	ULONG ulDecodStart;			// decode start address for compressed data
	ULONG ulDSAx;				// x coordinate of display area
	ULONG ulDSAy;				// y coordinate of display area
	ULONG ulDSAw;				// width of display area
	ULONG ulDSAh;				// height of display area	

	PBYTE pData;				// data source buffer
	ULONG curData;				// current size of datapacket
	ULONG cData;				// total size of this data packet

	PBYTE pTopWork;				// top field buffer
	PBYTE pBottomWork;			// bottom field buffer
	ULONG cDecod;				// size of the decode buffers

	ULONG cTopDisp;				// top field for display
	ULONG cBottomDisp;			// bottom field for display
	ULONG cDisp;				// size of the display buffers

	ULONG pSPCmds;				// pointer to current set of SPCmds
	ULONG lastSPCmds;				// pointer to current set of SPCmds
	ULONG ulFrameCnt;			// number of frames since we started
								// this subpicture

	ULONG decFlags;				// decodeing flags
	ULONG nextDispFlags;		// next decoding flags

	KSSTATE spState;			// subpicture decoding state
	
	ULONG stsPic;				// time to display the current picture
	ULONG lastTime;				// previous display time
	ULONG stsNextUpd;			// time of next subpicture update
	ULONG cFrames;				// count of frames

    ULONG numchg;

} SP_DECODE_CTL, *PSP_DECODE_CTL;

#define SPDECFL_BUF_IN_USE 			0x0001
#define SPDECFL_SUBP_ON_DISPLAY 	0x0002
#define SPDECFL_LAST_FRAME			0x0004
#define SPDECFL_SUBP_DECODED		0x0008
#define SPDECFL_NEW_PIC				0x0010
#define SPDECFL_DECODING			0x0020
#define SPDECFL_RESTART				0x0040
#define SPDECFL_DISP_OFF			0x0080
#define SPDECFL_DISP_FORCED			0x0100
#define SPDECFL_USER_DISABLED		0x0200
#define SPDECFL_DISP_LIVE			0x0400
#define SPDECFL_ONE_UNIT			0x0800
#define SPDECFL_USE_STRAIGHT_PAL	0x1000

typedef struct _SP_DECODE_ADDR {
	UCHAR opCode;
	UCHAR wTopAddr[2];
	UCHAR wBottomAddr[2];
} SP_DECODE_ADDR, *PSP_DECODE_ADDR;

typedef struct SP_STRM_EX {
	SP_DECODE_CTL pdecctl;
	PHW_STREAM_REQUEST_BLOCK pSrbQ;
	ULONG cOffset;
    struct _HW_DEVICE_EXTENSION *phwdevex;
    PHW_STREAM_OBJECT phstrmo;
} SP_STRM_EX, *PSP_STRM_EX;


#define DAREA_START_UB_MASK	0x3f	// display area upper bit mask
#define DAREA_END_UB_MASK 0x3		// display area end upper bit mask
#define DAREA_LB_MASK 0xf0

#define DAREA_START_UB_SHIFT 0x4
#define DAREA_END_UB_SHIFT 0x8

#define SP_LCTL_TERM 0xFFFFFF0F
#define SP_MAX_INPUT_BUF	53220	// maximum size of the subpicture input buffer

BOOL UpdateSPConsts(PSP_STRM_EX pspstrmex);

BOOL DecodeRLE(PVOID pdest, ULONG cStart, PSP_STRM_EX pspstrmex);

void StartSPDecode (PSP_STRM_EX pspstrmex);

BOOL BuildSPFields (PSP_STRM_EX pspstrmex);

BOOL UpdateSPConsts(PSP_STRM_EX pspstrmex);

VOID SPReceiveDataPacket(PHW_STREAM_REQUEST_BLOCK pSrb);

void DumpPacket(PSP_STRM_EX pspstrmex);

void SPEnqueue(PHW_STREAM_REQUEST_BLOCK pSrb, PSP_STRM_EX pspstrmex);

PHW_STREAM_REQUEST_BLOCK SPDequeue(PSP_STRM_EX pspstrmex);

void SubPicIRQ(PSP_STRM_EX pspstrmex);

void SPSchedDecode(PSP_STRM_EX pspstrmex);

BOOL WriteBMP(PSP_STRM_EX pspstrmex);
void DumpHLI(PSP_STRM_EX pspstrmex);

void WriteSPBuffer(PBYTE pBuf, ULONG cnt);

void WriteSPData(ULONG ulData);

BOOL AllocateSPBufs(PSP_DECODE_CTL pdecctl);

void SPSetState (PHW_STREAM_REQUEST_BLOCK pSrb);

void SPSetProp (PHW_STREAM_REQUEST_BLOCK pSrb);
void SPGetProp (PHW_STREAM_REQUEST_BLOCK pSrb);

void CallBackError(PHW_STREAM_REQUEST_BLOCK pSrb);
void CleanSPQueue(PSP_STRM_EX pspstrmex);

void SPSetSPEnable();
void SPSetSPDisable();

BOOL SPChooseMap (PSP_DECODE_CTL pdecctl, PUCHAR pcol, UCHAR con );

void AbortSP(PSP_STRM_EX pspstrmex);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgs\cpq3520a\zac3.h ===
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
// 	MODULE  : ZAC3.H
//	PURPOSE : Zoran AC3 related
//	AUTHOR  : JBS Yadawa
// 	CREATED :  7/20/96
//
//	REVISION HISTORY :
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	DATE     :
//
//	COMMENTS :
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


#ifndef __ZAC3_H__
#define __ZAC3_H__

#include "stdefs.h"

#define	AC3_AC3		0x85
#define AC3_CFG		0x82
#define	AC3_PLAY		0x8A
#define AC3_MUTE		0x8B
#define	AC3_UNMUTE	0x89
#define	AC3_STOP		0x8C
#define	AC3_STOPF	0x8D
#define	AC3_STAT		0x8E
#define	AC3_NOP		0x80
#define	AC3_VER		0x81

typedef enum tagAc3State {
	ac3PowerUp = 0,
	ac3Startup,
	ac3Playing,
	ac3Paused,
	ac3Stopped,
	ac3Starving,
	ac3ErrorRecover,
} AC3STATE;

typedef struct tagAc3 {
	AC3STATE state;
	DWORD		pts;
	BOOL		starving;
	DWORD		starvationCount;
	DWORD		status;
	BOOL		ac3Data;
	DWORD		errorCount;
}AC3, FARPTR *PAC3;

PAC3 	Ac3Open(void);
BOOL 	Ac3InitDecoder(void);
BOOL 	Ac3Boot(void);
BOOL 	FARAPI Ac3SendData(BYTE FARPTR *Data, DWORD Size);
DWORD 	Ac3GetPTS(void);
BOOL 	Ac3Pause(void);
BOOL 	Ac3Play(void);
BOOL 	Ac3Close(void);
BOOL 	Ac3SetNormalMode(void);
BOOL 	Ac3SetBypassMode(void);
void 	Ac3Reset(void);
void 	Ac3CheckStatus(void);
BOOL 	Ac3Stop(void);

#endif // __ZAC3_H__


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgs\cpq3520a\trace.h ===
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
// 	MODULE		:	TRACE.H
// 	PURPOSE		:  Trace the decoding
// 	AUTHOR 		:  JBS Yadawa
// 	CREATED		:	12-26-96
//
//	Copyright (C) 1996-1997 SGS-THOMSON microelectronics
//
//	REVISION HISTORY:
//
// 	DATE			:
// 	COMMENTS		:
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

#ifndef __TRACE_H__
#define __TRACE_H__


#ifdef TRACE_MP
typedef enum tagMpCmdTrace {
	mTracePlay=0,
	mTracePause,
	mTraceStop,
	mTraceVideo,
	mTraceAudio,
	mTraceSP,
	mTraceVideoDone,
	mTraceAudioDone,
	mTraceDriverEntry,
	mTraceCancelPacket,
	mTraceLastVideoDone,
	mTraceLastAudioDone,
	mTraceTimeOut,
	mTraceOpen,
	mTraceInfo,
	mTraceInit,
	mTraceClose,
	mTraceUnInit,
	mTraceUnknown,
	mTraceVdisc,
	mTraceEOS,
	mTraceStill,
	mTraceRdyVid,
	mTraceRdyAud,
	mTraceRdySub,
	mTraceSPDone
} MPTRACE;

#endif // TRACE_MP

#ifdef TRACE_INTR
typedef enum tagInterrupt {
	vst=0,
	vsb,
	dsync,
	pict,
	seq,
	gop,
	seqend,
	usr,
	pext,
	skips,
	skipf,
	skip1,
	skip2,
	skipn,
	skipd,
	unknown,
	error,
	storevs,
	storepi,
	comp,
	ext
} INTR;

typedef struct tagTrace {
	INTR	intr;
	BYTE  	ins;
	BYTE  	pt;
	DWORD 	abl;
	DWORD	vbl;
} TRACEIT;

#endif // TRACE_INTR
typedef struct tagTraceTREF {
	DWORD		tRef;
	int 		frametype;
} TRACETREF;

#ifdef TRACE_PICT_EXT
typedef struct tagTracePictExt {
	BYTE n;
	BYTE tff;
	BYTE rff;
	BYTE pf;
	BYTE ps;
} TRACEPICTEXT;
#define TracePictExt(x,y,z,t,w) TracePictExtF(x,y,z,t,w)
void TracePictExtF(BYTE n, BYTE tff, BYTE rff, BYTE pf, BYTE ps);
#else
#define TracePictExt(x,y,z,t,w) {;}
#endif // TRACE_PICT_EXT

// Interrupt Trace
#ifdef TRACE_INTR
void TraceIntrF(INTR i, BYTE ins, BYTE pt);
#define TraceIntr(x,y,z)	TraceIntrF(x, y, z)
void TraceResetF(void);
#define TraceReset() TraceResetF()
#else
#define TraceIntr(x,y,z) {;}
#define TraceReset() {;}
#endif

void TraceTref(DWORD, int);
void TraceDump(void);


// MP Command Trace
#ifdef TRACE_MP
#define MPTrace(x) MPTraceF(x)
#define MPTReset() MPTResetF()
void MPTraceF(int tr);
void MPTResetF(void);
#else
#define MPTrace(x) {;}
#define MPTReset() {;}
#endif

#endif



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgs\cpq3520a\subpic.c ===
#include "strmini.h"
#include "stdefs.h"
#include "mpinit.h"
#include "sti3520a.h"
#include "mpvideo.h"
#include "board.h"
#include "trace.h"
#include "hwcodec.h"
#include "copyprot.h"

void SPVideoOSDOn();
void SPVideoOSDOff();
static ULONG cSPBytes = 0;
extern PVIDEO pVideo;
extern PSP_STRM_EX pSPstrmex;

static ULONG ulRemain = 0;

/*
** DecodeRLE ()
**
**         - decodes a DVD encoded RLE compressed bitmap region into an
**               uncompressed 4 bit per pixel bitmap
**
** Arguments:
**
**
**
** Returns:
**
** Side Effects:
*/

#define GetCurNibble(foo) (((foo) % 2) ? (*((PBYTE)pspstrmex->pdecctl.pData + ((foo) >> 1))\
		& 0x0f) : (((*((PBYTE)pspstrmex->pdecctl.pData + ((foo)  >> 1)))) >> 4))

BOOL DecodeRLE(PBYTE pdest, ULONG cStart, PSP_STRM_EX pspstrmex)
{
	ULONG pOffs;                    // current position in the packet in nibbles
	USHORT cX;
	USHORT cY;
	PSP_DECODE_CTL pdecctl = &(pspstrmex->pdecctl);
	ULONG cDestOffs;                // current pixel in the destination bitmap
	USHORT cPix;
	USHORT cBlt;
	USHORT yBlt;
	UCHAR bPix;
	UCHAR bPltPix;                  // current pallette pixel to draw
	ULONG dbgWord;
	BOOLEAN fLine = FALSE;
	ULONG ulTmp;

	//
	// color pallette locals
	//

	PPXCTLY ppxcd = pdecctl->ppxcd;
	SMYCOLCON linechg[11];          // color control structure
	PSMYCOLCON pchg;
	ULONG cChgs, cTmp;                              // number of color changes in the line

	//
	// clear the pallette mapping
	//

	for (ulTmp = 0; ulTmp < 16; ulTmp++)
	{
		pdecctl->mappal.palFlags[ulTmp] = 0;
	}

	pdecctl->minCon = 0xf;

	pdecctl->decFlags &= ~SPDECFL_USE_STRAIGHT_PAL;
	//
	// find the offset in the packet (in nibbles)
	//

RESTART_DECODE:

	pOffs = cStart << 1;

	//
	// Source bitmap is as follow:
	//
	// (note: this whole thing is based on nibbles)
	//
	// format 1: xxPD                                       - 2 bit count, plus 2 bit PD
	// format 2: 00xxxxPD                           - 2 bit 0 marker, 4 bit count
	// format 3: 0000xxxxxxPD                       - 4 bit 0 marker, 6 bit count
	// format 4: 000000xxxxxxxxPD           - 6 x 0, 8 bit count,
	// format 5: 00000000000000PD           - 14 x0, no count -> end of line
	//

	cY = 0;
	cDestOffs = 0;

	do {

		//
		// set up the default pallette
		//

		linechg[0].chgsppal = pdecctl->sppPal;
		linechg[0].stopx = (pdecctl->ulDSAw);

		cChgs = 1;

		if (pOffs >> 1 >= pdecctl->pSPCmds)
		{
			TRAP

			return(FALSE);
		}

		fLine = (ppxcd && ((*((PDWORD)ppxcd) != SP_LCTL_TERM)));


		if ( fLine || pdecctl->HLI.fActive)
		{

			//
			// we have line control information, OR highlight info
			// let's use it to find the relevant color control information
			//

			//
			// if the current cY < current line control number, and
			// it's less than the highlight information
			// we use standard info, and go to the start of line control
			// or highlight, whichever is first
			//
			// if the current cY = current line control number, or highlight
			// we use current change info, and go to termination
			// line number or highlight, or
			//
			//

			if ( (fLine && ((cY << 1) < ((((USHORT)ppxcd->chglinhi) <<  8) +
		    ((USHORT)ppxcd->chglin))))
						|| (pdecctl->HLI.fActive && (cY <
							(pdecctl->HLI.hli.StartY >> 1))))
			{

				if (fLine)
				{
					yBlt = ((ppxcd->chglinhi << 8) + ppxcd->chglin) >> 1;
				}
				else
				{
					yBlt = pdecctl->HLI.hli.StartY >> 1;
				}


				if (pdecctl->HLI.fActive && (yBlt << 1) > pdecctl->HLI.hli.StartY)
				{
					yBlt = pdecctl->HLI.hli.StartY >> 1;
				}

				pdecctl->numchg = 0;
			}
			else if (ppxcd)
			{

				TRAP

				pdecctl->numchg = ppxcd->numchg;

				if (!pdecctl->numchg)
				{
					TRAP

					return(FALSE);
				}

				yBlt = ((ppxcd->chgstophi << 8) + ppxcd->chgstop) >> 1;

				if (yBlt < cY)
				{
					TRAP

					return (FALSE);
				}

				//
				// define the x changes
				//

				if (ppxcd->numchg > 8)
				{
					TRAP

					return(FALSE);
				}

				for (cChgs = 0; cChgs < pdecctl->numchg; cChgs++)
				{
					linechg[cChgs].stopx =
					   (ppxcd->xchg[cChgs].chgpixhi << 8) +
					   ppxcd->xchg[cChgs].chgpix;

					linechg[cChgs+1].chgsppal.color[0]=
						ppxcd->xchg[cChgs].colcon.backcol;

					linechg[cChgs+1].chgsppal.color[1]=
						ppxcd->xchg[cChgs].colcon.patcol;

					linechg[cChgs+1].chgsppal.color[2]=
						ppxcd->xchg[cChgs].colcon.emph1col;

					linechg[cChgs+1].chgsppal.color[3]=
						ppxcd->xchg[cChgs].colcon.emph2col;

				}

				linechg[cChgs].stopx = pdecctl->ulDSAw;

			} // end else we have change information for this line

			if (pdecctl->HLI.fActive)
			{
				if	((cY < (pdecctl->HLI.hli.StartY >> 1)))
				{
					yBlt = pdecctl->HLI.hli.StartY >> 1;
				}
				else if (cY  < (pdecctl->HLI.hli.StopY) >> 1)
				{
	
				   //
				   // we have highlight information for this period
				   // we need to override any change control information, and
				   // set the end lines appropriately
				   //

				   if (pdecctl->HLI.hli.StopX > pdecctl->ulDSAw)
				   {
					   TRAP
				   }
	
				   //
				   // find the change control that stops after the start of the
				   // Highlight info
				   //
	
				   for (cChgs = 0;
					   cChgs < pdecctl->numchg &&
					   linechg[cChgs].stopx < pdecctl->HLI.hli.StopX;
					   cChgs++)
				   {
				   }
	
				   //
				   // move over to the end after this change
				   //
	
				   for (cTmp = pdecctl->numchg +1;
					   cTmp > cChgs;
					   cTmp--)
				   {
					   linechg[cTmp] = linechg[cTmp - 1];
				   }
	
				   pdecctl->numchg++;
	
				   linechg[cChgs].stopx = pdecctl->HLI.hli.StartX;
	
				   //
				   // if the highlight is in the middle of a change, go ahead
				   // and create another change, starting at the end of the
				   // highlight
				   //
	
				   if (linechg[cChgs + 1].stopx > pdecctl->HLI.hli.StopX)
				   {
					   for (cTmp = pdecctl->numchg +1;
						   cTmp > cChgs + 1;
						   cTmp--)
					   {
						   linechg[cTmp] = linechg[cTmp - 1];
					   }
	
					   pdecctl->numchg++;
	
				   }
	
				   //
				   // now set up the highlight change
				   //
	
				   linechg[cChgs + 1].stopx = pdecctl->HLI.hli.StopX;
				   linechg[cChgs+1].chgsppal.color[0]=
					   pdecctl->HLI.hli.ColCon.backcol;
	
				   linechg[cChgs+1].chgsppal.color[1]=
					   pdecctl->HLI.hli.ColCon.patcol;
	
				   linechg[cChgs+1].chgsppal.color[2]=
					   pdecctl->HLI.hli.ColCon.emph1col;
	
				   linechg[cChgs+1].chgsppal.color[3]=
					   pdecctl->HLI.hli.ColCon.emph2col;
	
				   linechg[cChgs+1].chgsppal.mix[0]=
					   pdecctl->HLI.hli.ColCon.backcon;
	
				   linechg[cChgs+1].chgsppal.mix[1]=
					   pdecctl->HLI.hli.ColCon.patcon;
	
				   linechg[cChgs+1].chgsppal.mix[2]=
					   pdecctl->HLI.hli.ColCon.emph1con;
	
				   linechg[cChgs+1].chgsppal.mix[3]=
					   pdecctl->HLI.hli.ColCon.emph2con;
	
				   //
				   // now search the change information and
				   //
	
				   //
				   // check if the highlight information ends before the end
				   // of the current lines
				   //
	
				   yBlt = pdecctl->HLI.hli.StopY >> 1;
				}
				else
				{
				   yBlt = (USHORT)(pdecctl->ulDSAh / 2);
				}
			} // end if highlight information

		} // end if we have change information

		else // no change information or end of change info

		{
	    yBlt = (USHORT)(pdecctl->ulDSAh / 2);

			ppxcd = NULL;
		}

		for (; cY < yBlt; cY++)
		{

	    //
	    // the start of a line must always be on an even nibble!
	    //

	    if (pOffs & 1)
	    {
		pOffs++;
	    }
	
			for (cX = 0, pchg = &linechg[0]; cX < (pdecctl->ulDSAw);)
			{
				if (GetCurNibble(pOffs) > 0x3)
				{
					//
					// smallest RLE encoding, must have 0-3 pixels
					//
	
					cPix = GetCurNibble(pOffs) >> 2;

				}
				else if (GetCurNibble(pOffs))
				{
	
					//
					// must have a 2 bit 00 indicator code with 4 bit
					// count
					//
	
					cPix = ((GetCurNibble(pOffs)) << 2)
						 + (GetCurNibble(pOffs +1) >> 2);

					dbgWord = (GetCurNibble(pOffs) << 4) +
								(GetCurNibble(pOffs + 1));
	
					pOffs += 1;
	
				}
				else if (GetCurNibble(pOffs + 1) > 3)
				{

					//
					// 4 leading 00s, 6 bit count
					//

					cPix = (GetCurNibble(pOffs + 1) << 2) +
						   ((GetCurNibble(pOffs + 2)) >> 2);

				   dbgWord = (GetCurNibble(pOffs) << 8) +
							   ((GetCurNibble(pOffs + 1)) << 4) +
							   ((GetCurNibble(pOffs + 2)));

					pOffs += 2;
				}
				else if (GetCurNibble(pOffs + 1))
				{
	
					//
					// 6 leading 0s, 8 bit count
					//
	
					cPix = (GetCurNibble(pOffs + 1) << 6) +
						   (GetCurNibble(pOffs + 2) << 2) +
						   (GetCurNibble(pOffs + 3) >> 2);

				   dbgWord = (GetCurNibble(pOffs) << 12) +
							   ((GetCurNibble(pOffs + 1)) << 8) +
							   ((GetCurNibble(pOffs + 2)) << 4);
							   ((GetCurNibble(pOffs + 3)));


	
					pOffs += 3;
				}
				else if (GetCurNibble(pOffs + 2) ||
						(GetCurNibble(pOffs + 3) & 0xc0))
				{
	
					//
					// for the 4 nibble case, we must have a count of
					// at least 64 (nibble 1, bit 1 or 2 is set), or
					// nibbles 1, 2, and top half of 3 must all be 0
					//
					// in this case, nibble 1 is clear and some other
					// part of the count is not.  This is illegal, so
					// error out
					//
	
					TRAP
	
					return(FALSE);
				}
				else
				{
					//
					// this must be the end of the line case
					//
	
					cPix = (USHORT)(pdecctl->ulDSAw) - cX;
	
					dbgWord = (GetCurNibble(pOffs) << 12) +
								((GetCurNibble(pOffs + 1)) << 8) +
								((GetCurNibble(pOffs + 2)) << 4);
								((GetCurNibble(pOffs + 3)));
	
					pOffs += 3;
				}
	
	
				bPix = GetCurNibble(pOffs) & 0x3;

				pOffs++;
	
				if ((cPix + cX > (USHORT)pdecctl->ulDSAw) || !cPix)
				{
	
					//
					// Uh oh!  Overruning the line, something is wrong!
					//
	
					TRAP

					cPix = (USHORT)pdecctl->ulDSAw - cX;
	
					// return(FALSE);
				}

				//
				// set up the starting palette for this line
				//

				for (;cPix>0;)
				{


					//
					// if the current change stop x < cx, we need
					// to move on to the next color
					//

					if (pchg->stopx <= cX)
					{
						pchg++;
					}

					//
					// blt for how many pixels we have, or until
					// the next change
					//

					cBlt = (cPix < ((USHORT)pchg->stopx - cX)) ?
							cPix : ((USHORT)pchg->stopx - cX);

					cPix -= cBlt;

					cX += cBlt;

					bPltPix = pchg->chgsppal.color[bPix];

					if (!(pdecctl->decFlags & SPDECFL_USE_STRAIGHT_PAL))
					{
						if (!SPChooseMap(pdecctl, &bPltPix, pchg->chgsppal.mix[bPix]))
						{
							TRAP

							pdecctl->decFlags |= SPDECFL_USE_STRAIGHT_PAL;

							goto RESTART_DECODE;
						}

					}

					//
					// if we are currently working on an odd pixel, (low
					// nibble) go ahead and re-align on even ...
					//
		
					if (cDestOffs % 2)
					{

						(*(pdest + (cDestOffs >> 1))) &= 0xf0;
						(*(pdest + (cDestOffs >> 1))) |= bPltPix;
		
						cDestOffs++;
						cBlt--;
						
					}
		
					//
					// fill in the byte aligned bytes
					//
		
					bPltPix |= bPltPix << 4;
		
					for (;cBlt > 1; cBlt -= 2, cDestOffs += 2)
					{
						*(pdest + (cDestOffs >> 1)) = bPltPix;
					}
		
					//
					// if we have a nibble left, store it
					//
		
					if (cBlt)
					{
						*(pdest + (cDestOffs >> 1)) = bPltPix;

						cDestOffs++;
					}
		
					// end for pixels until next change

				} // end for number of pixels in this run

			} // end of this horizontal line

			if (pdecctl->ulDSAw & 1)
			{
				cDestOffs--;
			}

		} // end of this vertical line

	} while (cY < (pdecctl->ulDSAh / 2)); // end of this vertical line change region

	return(TRUE);

}


/*
** SPChooseMap ()
**
**         Choose the pallette
**
** Arguments:
**
**
**
** Returns:
**
** Side Effects:
*/

BOOL SPChooseMap (PSP_DECODE_CTL pdecctl, PUCHAR pcol, UCHAR con)
{
ULONG ulTmp;

	//
	// check if this is the 0 color
	//

	if ((con == 0) || (pdecctl->spYUV.ucY[*pcol] == 0))
	{
		pdecctl->mappal.palFlags[0] = fInUse;

		*pcol = 0;

		return (TRUE);
	}

	//
	// see if there is already a contrast less than this one
	//

	if (pdecctl->minCon < con)
	{
		con = 0xf;
	}
	//
	// check if this color is already mapped correctly
	//

	if (((pdecctl->mappal.palFlags[*pcol]) & (fInUse)) &&
		  (pdecctl->mappal.yuvMap[*pcol] == *pcol) &&
		  ((pdecctl->mappal.ucAlpha[*pcol] == con) ||
		  ((pdecctl->mappal.ucAlpha[*pcol] > pdecctl->minCon) &&
		   (con > pdecctl->minCon))))
	{
		return (TRUE);
	}


	//
	// see if there is already a color / con pair that maps to this
	//


	for (ulTmp = 1;ulTmp < 16; ulTmp++)
	{
		if (!(pdecctl->mappal.palFlags[ulTmp] & fInUse))
		{
		}
		else if ((pdecctl->mappal.yuvMap[ulTmp] == *pcol) &&  (pdecctl->mappal.ucAlpha[ulTmp] == con))
		{
			*pcol = (UCHAR)ulTmp;

			return (TRUE);
		}
	}

	if (con < pdecctl->minCon)
	{
		pdecctl->minCon = con;
	}

	//
	// this color does not map to any available colors, try and see if the
	// direct mapping is available
	//

	if ((*pcol) && !(pdecctl->mappal.palFlags[*pcol] & fInUse))
	{
		pdecctl->mappal.palFlags[*pcol] = fInUse;

		pdecctl->mappal.yuvMap[*pcol] = *pcol;

		pdecctl->mappal.ucAlpha[*pcol] = con;

		if (con != 0xf)
		{
			pdecctl->mappal.palFlags[*pcol] |= fUseAlpha;
		}

		return (TRUE);
	}

	//
	// direct mapping is not available, start from 1 and work up
	//

	for (ulTmp = 1; ulTmp < 16; ulTmp++)
	{
		if (!(pdecctl->mappal.palFlags[ulTmp] & fInUse))
		{
			pdecctl->mappal.palFlags[ulTmp] = fInUse;
	
			pdecctl->mappal.yuvMap[ulTmp] = *pcol;
	
			pdecctl->mappal.ucAlpha[ulTmp] = con;

			*pcol = (UCHAR)ulTmp;
	
			if (con != 0xf)
			{
				pdecctl->mappal.palFlags[ulTmp] |= fUseAlpha;
			}
	
			return (TRUE);

		}

	}

	return (FALSE);
}

/*
** StartSPDecode ()
**
**         initialize subpicture decoding for this subpicture unit
**
** Arguments:
**
**
**
** Returns:
**
** Side Effects:
*/

void StartSPDecode (PSP_STRM_EX pspstrmex)
{
PSP_DECODE_CTL pdecctl = &(pspstrmex->pdecctl);

	do {

		pdecctl->decFlags &= ~SPDECFL_RESTART;


		if (!BuildSPFields(pspstrmex))
		{
			//
			// something is horribly wrong.  Just ask for the next packet
			//
	
			pdecctl->decFlags &= ~SPDECFL_BUF_IN_USE;
			pdecctl->decFlags |= SPDECFL_LAST_FRAME;
	
			pdecctl->curData = 0;
			pdecctl->stsPic = 0;

			return;
		}
	

	} while (pdecctl->decFlags & SPDECFL_RESTART);

	pdecctl->stsNextUpd =
		*((WORD *)(pdecctl->pData + pdecctl->pSPCmds));

	pdecctl->stsNextUpd = ((pdecctl->stsNextUpd & 0xFF00) << 2) |
						((pdecctl->stsNextUpd & 0xFF) << 18);

	//SetupSPBuffer(pspstrmex);

	cSPBytes = 0;

	pdecctl->decFlags &= ~SPDECFL_DECODING;
	pdecctl->decFlags |= SPDECFL_SUBP_DECODED;

	
}


/*
** BuildSPFields ()
**
**              Build new SPFields
**
** Arguments:
**
**
**
** Returns:
**
** Side Effects:
*/

BOOL BuildSPFields (PSP_STRM_EX pspstrmex)
{

	//
	// parse the current command set for this time
	//

	if (!UpdateSPConsts(pspstrmex))
	{
		return(FALSE);
	}

	//
	// decode the RLE into the display buffers
	//

	if (!DecodeRLE(
			pspstrmex->pdecctl.pTopWork,
			pspstrmex->pdecctl.cTopDisp,
			pspstrmex))
	{
		return(FALSE);
	}
/*
	if (!DecodeRLE(
			pspstrmex->pdecctl.pBottomWork,
			pspstrmex->pdecctl.cBottomDisp,
			pspstrmex))
	{
		return(FALSE);
	}
*/
	return(TRUE);

}

/*
** UpdateSPConsts() -
**
**     Update the subpicture decode constants
**
** Arguments:
**
**    pSPCmds - pointer to a subpicture command(s) buffer
**        cMax    - counter to the max size of this subpicture command block
**
** Returns:
**
** Side Effects:
**
*/

UCHAR cSpcmd[] = {1, 1, 1, 3, 3, 7, 5, 0};

BOOL UpdateSPConsts(PSP_STRM_EX pspstrmex)
{
	BOOL fDecode = TRUE;
	PSP_DECODE_CTL pdecctl = &(pspstrmex->pdecctl);

	//
	// skip the start time, and the next command
	//

	ULONG cSPCmds = pdecctl->pSPCmds + 4;
	UCHAR bTmp;
	UCHAR bCmd;
	ULONG oldX;
	ULONG oldY;
	ULONG oldW;
	ULONG oldH;


	//
	// loop through until we see the end code
	//

	while (fDecode)
	{
		bCmd = *((PBYTE)pdecctl->pData + cSPCmds);

		if (bCmd >= CMD_END)
		{

			//
			// we hit the end of the command stream, we're done!
			//

			return(TRUE);
		}

		if (cSPCmds + cSpcmd[bCmd] > pdecctl->cData)
		{
			return(FALSE);
		}

		pdecctl->nextDispFlags = pdecctl->decFlags & (SPDECFL_DISP_OFF | SPDECFL_DISP_FORCED);

		//
		// check the function code
		//

		switch (bCmd)
		{

		case FSTA_DSP:

			pdecctl->nextDispFlags |= SPDECFL_DISP_FORCED;
			break;


		case STA_DSP:

			pdecctl->nextDispFlags &= ~SPDECFL_DISP_OFF;
			break;


		case STP_DSP:

			pdecctl->nextDispFlags |= SPDECFL_DISP_OFF;
			break;

		case SET_COLOR:

			bTmp = *((PBYTE)pdecctl->pData + cSPCmds + 1);

			//
			// pick up the emphasis colors
			//

			pdecctl->sppPal.color[3] = (bTmp & 0xf0) >> 4;
			pdecctl->sppPal.color[2] = (bTmp & 0x0f);

			//
			// pick up the background and foreground colors
			//

			bTmp = *(pdecctl->pData + cSPCmds + 2);

			pdecctl->sppPal.color[1] = (bTmp & 0xf0) >> 4;
			pdecctl->sppPal.color[0] = (bTmp & 0x0f);

			break;

		case SET_CONTR:

			bTmp = *((PBYTE)pdecctl->pData + cSPCmds + 1);

			//
			// pick up the emphasis mixs
			//

			pdecctl->sppPal.mix[3] = (bTmp & 0xf0) >> 4;
			pdecctl->sppPal.mix[2] = (bTmp & 0x0f);

			//
			// pick up the background and foreground mixs
			//

			bTmp = *(pdecctl->pData + cSPCmds + 2);

			pdecctl->sppPal.mix[1] = (bTmp & 0xf0) >> 4;
			pdecctl->sppPal.mix[0] = (bTmp & 0x0f);

			break;

		case SET_DAREA:

			//
			// grap the x and y coordinates from the bit soup that defines
			// the display area
			//

			oldX = pdecctl->ulDSAx;
			oldY = pdecctl->ulDSAy;
			oldH = pdecctl->ulDSAh;
			oldW = pdecctl->ulDSAw;


			pdecctl->ulDSAx = ((*(pdecctl->pData + cSPCmds +1)
					& DAREA_START_UB_MASK) << DAREA_START_UB_SHIFT)
					+ (*(pdecctl->pData + cSPCmds + 2) >> DAREA_START_UB_SHIFT);

			pdecctl->ulDSAw = ((*(pdecctl->pData + cSPCmds + 2)
					& DAREA_END_UB_MASK) << DAREA_END_UB_SHIFT) +
					(*(pdecctl->pData + cSPCmds + 3)) -
					pdecctl->ulDSAx + 1;

			pdecctl->ulDSAy = ((*(pdecctl->pData + cSPCmds + 4)
					& DAREA_START_UB_MASK) << DAREA_START_UB_SHIFT)
					+ (*(pdecctl->pData + cSPCmds + 5) >> DAREA_START_UB_SHIFT);
				
			pdecctl->ulDSAh = ((*(pdecctl->pData + cSPCmds + 5)
					& DAREA_END_UB_MASK) << DAREA_END_UB_SHIFT) +
					(*(pdecctl->pData + cSPCmds + 6)) -
					pdecctl->ulDSAy + 1;

			if (oldW != pdecctl->ulDSAw || oldH != pdecctl->ulDSAh)
			{
				pdecctl->decFlags |= SPDECFL_NEW_PIC;
			}

			//
			// if the new bitmap requires more memory than the previous, we
			// need to allocate one here
			//

			if (pdecctl->ulDSAh * pdecctl->ulDSAw / 2 > pdecctl->cDecod)
			{
				pdecctl->cDecod = pdecctl->ulDSAh * pdecctl->ulDSAw / 2;


				if (!(pdecctl->cDecod))
				{
					TRAP
				}

				AllocateSPBufs(pdecctl);
			}

			break;

		case SET_DSPSTRT:

			{
	
				//
				// pick up the offsets of the top and bottom fields in the
				// compressed data
				//
	
				pdecctl->cTopDisp =
					(*(pdecctl->pData + cSPCmds + 1) << 8) +
					*(pdecctl->pData + cSPCmds + 2);
									

				pdecctl->cBottomDisp =
					(*(pdecctl->pData + cSPCmds + 3) << 8) +
					*(pdecctl->pData + cSPCmds + 4);
	
				break;
		
			}
		case CHG_COLCON:

			TRAP

	    pdecctl->ppxcd = (PPXCTLY)(pdecctl->pData + cSPCmds + 3);

			//
			// pick up the next command code
			//

			cSPCmds += (*(pdecctl->pData + cSPCmds + 1) << 8)
					  + *(pdecctl->pData + cSPCmds + 2);

			break;

		default:

			TRAP

			//
			// ACK!  Couldn't handle this subpicture command stream, just bail!
			//

			return(FALSE);


		} // end switch on command code

		//
		// go pick up the next command code
		//

		cSPCmds += cSpcmd[bCmd];

	} // end while something to decode

	return(FALSE);

}

VOID SPReceiveDataPacket(PHW_STREAM_REQUEST_BLOCK pSrb)
{

	PSP_STRM_EX pspstrmex =
		&(((PSTREAMEX)pSrb->StreamObject->HwStreamExtension)->spstrmex);

	PSP_DECODE_CTL pdecctl = &(pspstrmex->pdecctl);

	PKSSTREAM_HEADER   pPacket;

	ULONG cPack;

	MPTrace(mTraceSP);

	MPTrace(mTraceRdySub);
	StreamClassStreamNotification(ReadyForNextStreamDataRequest,
			pSrb ->StreamObject);

	switch (pSrb->Command)
	{
	case SRB_WRITE_DATA:

		//
		// search the packet for discontinuity bits.  If it has any, we need
		// to dump all current subpicture data, and stop the display.
		//

		pPacket = pSrb->CommandData.DataBufferArray;



		for (cPack =0;
			cPack < pSrb->NumberOfBuffers;
			cPack++, pPacket++)
		{

			if (pPacket->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY)
			{

				AbortSP(pspstrmex);
				
				break;

			}
			else if (pPacket->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TIMEDISCONTINUITY &&
					pSrb->NumberOfBuffers <= 1)
			{

				CallBackError(pSrb);

				return;

			}// end if discontinuity bit is set

		} // end loop on packets

		break;

	default:

		CallBackError(pSrb);

		return;

	}

		SPEnqueue(pSrb, pspstrmex);

	if (!(pspstrmex->pdecctl.decFlags & SPDECFL_BUF_IN_USE))
	{
		DumpPacket(pspstrmex);
	}

}

void AbortSP(PSP_STRM_EX pspstrmex)
{
PSP_DECODE_CTL pdecctl = &(pspstrmex->pdecctl);
	
	pdecctl->curData = 0;

	pspstrmex->pdecctl.decFlags = 0;
	SPVideoOSDOff();
	CleanSPQueue(pspstrmex);
	
}

void DumpPacket(PSP_STRM_EX pspstrmex)
{
PHW_STREAM_REQUEST_BLOCK pSrb;
PSP_DECODE_CTL pdecctl = &(pspstrmex->pdecctl);
PKSSTREAM_HEADER   pPacket;
ULONG dataOffset;
ULONG cPacket;
ULONG StartTime;
ULONG ulTmp;
ULONG cPack;
ULONG cMove;
PHW_STREAM_OBJECT phstrmo;
ULONG cSkipped = 0;
WORD	wTmp;
PVOID   Data = (PVOID) - 1;

	do
	{

RESTART_QUEUE:

		if (pSrb = SPDequeue(pspstrmex))
		{

			pPacket = pSrb->CommandData.DataBufferArray;

RESTART_COPY:

				while (((pPacket->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY)
					 || (!pPacket->Data) || (pPacket->DataUsed <
					 sizeof (SPPCKHDR) + PACK_HEADER_SIZE)))
				{

					pPacket++;

					cSkipped++;

					if (cSkipped >= pSrb->NumberOfBuffers)
					{
						//
						// call back this packet
						//
		
						pSrb->Status = STATUS_SUCCESS;
		
						phstrmo = pSrb->StreamObject;


						MPTrace(mTraceSPDone);
						StreamClassStreamNotification(StreamRequestComplete,
								phstrmo,
								pSrb);

						goto RESTART_QUEUE;
					}


				}

			//
			// is this the first packet?
			//

			if (!pdecctl->curData)
			{


				//
				// do we have a valid SP_PCK PES header?
				//

                Data = (PVOID) ((ULONG_PTR) pPacket->Data + PACK_HEADER_SIZE);

				if ((*((PDWORD) Data) & 0xFFFFFF)
						!= 0x010000)
				{
					CallBackError(pSrb);

					return;

				}

				//
				// find the subpicture start
				//

				dataOffset = ((PSPPCKHDR)Data)->
						phdr_hdr_length + sizeof(SPPCKHDR) - 4;

				if ((((PSPPCKHDR)Data)->
						phdr_flags[1] & 0xC0) != 0x80)
				{
					//
					// PTS is invalid on the first start code!
					//

					CallBackError(pSrb);

					return;


				}

				//
				// find the start time
				//

				StartTime = (((PSPPCKHDR)Data)->phdr_PTS[0]
			 & 0xE) << 26;

				StartTime |= (((PSPPCKHDR)Data)->phdr_PTS[1])
			     << 22;

				StartTime |= (((PSPPCKHDR)Data)->phdr_PTS[2]
			     & 0xFE) << 14;

				StartTime |= ((PSPPCKHDR)Data)->phdr_PTS[3] << 7;
				
				StartTime |= ((PSPPCKHDR)Data)->phdr_PTS[4] >> 1;

				if (!StartTime)
				{
					TRAP

					StartTime++;
				}
				
				pdecctl->stsPic = StartTime;
				pdecctl->lastTime = StartTime;


				//
				// y: pick up the size of the subpicture unit
				//

				pdecctl->cData = *((PWORD)((PBYTE) Data
							+ dataOffset));
				pdecctl->cData = (pdecctl->cData >> 8)
								| ((pdecctl->cData & 0xff) <<8);

				if (pdecctl->cData > SP_MAX_INPUT_BUF)
				{
					TRAP

					CallBackError(pSrb);
					return;

					pSrb = NULL;

				}
				else
				{
					ulTmp = *((PWORD) ((PBYTE) Data +
						dataOffset + 2));

					ulTmp = (ulTmp >> 8) | ((ulTmp & 0xff) << 8);
					if (ulTmp < pdecctl->cData >> 1)
					{

						//
						// this is an illegal packet, the command
						// stream is more than half the data
						//

						CallBackError(pSrb);

						return;

						pSrb = NULL;
		    }
				}
	
			}

			if (pSrb)
			{


				//
				// go ahead and start moving the data
				//

				for (cPack = cSkipped;
					cPack < pSrb->NumberOfBuffers;
					cPack++, pPacket++)
				{

				if (pPacket->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY ||
					pPacket->DataUsed < 4)
				{

						//
						// yikes!  We have a discontinuity!  Dump all data
						// up to this point, and start again!
						//

						pdecctl->curData = 0;

						pPacket++;
						cSkipped = cPack + 1;

						goto RESTART_COPY;

					}
                       Data = (PVOID) ((ULONG_PTR) pPacket->Data + PACK_HEADER_SIZE);

					if ((*((PDWORD) Data) & 0xFFFFFF) != 0x010000)
					{
						CallBackError(pSrb);
						return;
					}

					//
					// find the subpicture start
					//
	
					dataOffset = ((PSPPCKHDR)Data)->
							phdr_hdr_length + sizeof(SPPCKHDR) - 4;

					//
					// the count of data bytes in the PES packet is
					// the count of bytes following the packet_length
					// field, so add 6 to the total (the offset)
					//

					cPacket = ((PSPPCKHDR)(Data))->
							phdr_packet_length;

					cPacket = (((cPacket & 0xff) << 8) | (cPacket >> 8)) -
							dataOffset + 6 ;

					if (cPacket > pPacket->DataUsed - PACK_HEADER_SIZE)
					{
						TRAP
						CallBackError(pSrb);
						return;

					}

					if (pdecctl->curData + cPacket > pdecctl->cData)
					{
						cMove = pdecctl->cData - pdecctl->curData;

					}
					else
					{
						cMove = cPacket;
					}

					//
					// move the data
					//

					RtlCopyMemory(pdecctl->pData + pdecctl->curData,
							(PBYTE)Data + dataOffset,
							cMove);

					//
					// have we reached the end of the subpicture unit?
					//

					pdecctl->curData += cMove;

					if (pdecctl->curData == pdecctl->cData)
					{

						cPack= 0xFFFFFFFE;
					}
		
				}
	
				//
				// call back this packet, if we don't have leftover
				//

				pSrb->Status = STATUS_SUCCESS;

				phstrmo = pSrb->StreamObject;

				MPTrace(mTraceSPDone);
				StreamClassStreamNotification(StreamRequestComplete,
					    phstrmo,
					    pSrb);
				
				if (pdecctl->curData == pdecctl->cData)
				{
					//
					// y: indicate that we have a full buffer, and start
					// the initial decoding process
					//
					pdecctl->decFlags |= SPDECFL_BUF_IN_USE | SPDECFL_NEW_PIC;

					pdecctl->ulFrameCnt = 0;

					pdecctl->pSPCmds = *((WORD *)(pdecctl->pData + 2));
				
					pdecctl->pSPCmds = ((pdecctl->pSPCmds & 0xff) << 8) |
									   (pdecctl->pSPCmds) >> 8;

					pdecctl->lastSPCmds = pdecctl->pSPCmds;

					wTmp = *((WORD *)(pdecctl->pData + pdecctl->pSPCmds + 2));
					wTmp = ((wTmp & 0xff) << 8) | (wTmp >> 8);

					if (wTmp == pdecctl->pSPCmds)
					{
						pdecctl->decFlags |= SPDECFL_ONE_UNIT;
					}

					pdecctl->decFlags |= SPDECFL_DECODING;
			//              StartSPDecode(pspstrmex);
					StreamClassCallAtNewPriority(phstrmo,
								pspstrmex->phwdevex,
								Low,
								(PHW_PRIORITY_ROUTINE)StartSPDecode,
								pspstrmex);

					return;

				}
		}
		}
		else
		{
			return;
		}

	} while(TRUE);

}

void CallBackError(PHW_STREAM_REQUEST_BLOCK pSrb)
{
	pSrb->Status = STATUS_SUCCESS;

	if (pSPstrmex)
	{

		pSPstrmex->pdecctl.curData = 0;
		pSPstrmex->pdecctl.decFlags = 0;

	}

	MPTrace(mTraceSPDone);

	StreamClassStreamNotification(StreamRequestComplete,
					pSrb->StreamObject,
					pSrb);

}
void SPEnqueue(PHW_STREAM_REQUEST_BLOCK pSrb, PSP_STRM_EX pspstrmex)
{
	PHW_STREAM_REQUEST_BLOCK pSrbTmp;
	ULONG cSrb;


	//
	// enqueue the given SRB on the device extension queue
	//

	for (cSrb =0,
		pSrbTmp = CONTAINING_RECORD((&(pspstrmex->pSrbQ)),
			HW_STREAM_REQUEST_BLOCK, NextSRB);
			pSrbTmp->NextSRB;
			pSrbTmp = pSrbTmp->NextSRB, cSrb++);

	pSrbTmp->NextSRB = pSrb;
	pSrb->NextSRB = NULL;
	
}

PHW_STREAM_REQUEST_BLOCK SPDequeue(PSP_STRM_EX pspstrmex)
{
	PHW_STREAM_REQUEST_BLOCK pRet = NULL;

	if (pspstrmex->pSrbQ)
	{
		pRet = pspstrmex->pSrbQ;
		pspstrmex->pSrbQ = pRet->NextSRB;
	}

	return(pRet);
}

void SubPicIRQ(PSP_STRM_EX pspstrmex)
{
	PSP_DECODE_CTL pdecctl = &(pspstrmex->pdecctl);
	ULONG StartTime;
	ULONG ulTmp;
	LONG deltaT;
	BOOLEAN fRemoveHLI = FALSE;
	BOOLEAN fNewHLI = FALSE;

	static ULONG cFrames = 0;

	if (pdecctl->spState == KSSTATE_STOP)
	{
		SPVideoOSDOff();

	pdecctl->curData = 0;
	pdecctl->decFlags &= ~SPDECFL_BUF_IN_USE;
		pdecctl->HLI.fValid = FALSE;
		pdecctl->HLI.fActive = FALSE;
		pdecctl->HLI.fProcessed = TRUE;
		cSPBytes = 0;

		cFrames = 0;

		return;
	}

	//
	// if HLI is not processed
	//

 	if (!pdecctl->HLI.fProcessed)
	{

		if (!pdecctl->HLI.fValid)
		{
			fRemoveHLI = TRUE;
			pdecctl->HLI.fValid = pdecctl->HLI.fActive = FALSE;
			pdecctl->HLI.fProcessed = TRUE;
	

			
		} // end if HLI invalid

		else // HLI is valid
		{
			//
			// if the HLI is valid, we need to check the timestamp, if
			// it's time, we need to start using it
			//
			deltaT = (LONG)(VideoGetPTS() - pdecctl->HLI.hli.StartPTM);

			if (pdecctl->HLI.hli.StartPTM == 0xFFFFFFFF ||
				(deltaT > (-3* 3003)))
	//			DbgPrint("'HLI deltaT: %X \n", deltaT);
				//pdecctl->HLI.hli.StartPTM <= VideoGetPTS())
			{
				pdecctl->HLI.fProcessed = TRUE;
				pdecctl->HLI.fActive = TRUE;
				fNewHLI = TRUE;
			}
			
		}
	}

	if (pdecctl->HLI.fActive && (pdecctl->HLI.hli.EndPTM != 0xFFFFFFFF) &&
			(pdecctl->HLI.hli.EndPTM >= VideoGetPTS()))
	{
		pdecctl->HLI.fValid = pdecctl->HLI.fActive = FALSE;
		pdecctl->HLI.fProcessed = TRUE;

		//
		// HLI is ending, so we need to see if the subpicture is also
		// ending
		//

		fRemoveHLI = TRUE;

	}

	if ((pdecctl->decFlags & SPDECFL_LAST_FRAME) &&
		(pdecctl->spState != KSSTATE_PAUSE))
	{
		pdecctl->decFlags &= ~(SPDECFL_LAST_FRAME | SPDECFL_SUBP_ON_DISPLAY |
								SPDECFL_DISP_LIVE);

				cFrames = 0;
		SPVideoOSDOff();

		return;
		
	}


	//
	// if we do not have subpicture data, deal with the HLI here
	//

	if (!(pdecctl->decFlags & SPDECFL_BUF_IN_USE))
	{

		if (fRemoveHLI)
		{
			pdecctl->decFlags |= SPDECFL_LAST_FRAME;

		}

		if (fNewHLI)
		{
			SPVideoOSDOff();

			DumpHLI(pspstrmex);

			SPVideoOSDOn();
		}

		return;
	}


	//
	// check to see if we need to change the existing subpicture
	//

	if (fNewHLI || fRemoveHLI)
	{

		pdecctl->pSPCmds = pdecctl->lastSPCmds;
		pdecctl->stsNextUpd = pdecctl->lastTime;

		pdecctl->decFlags  &= ~(SPDECFL_SUBP_DECODED);

		SPSchedDecode(pspstrmex);

		return;
	}

	
	//
	// have we started this subpicture yet?
	//

	if (!(pdecctl->decFlags & SPDECFL_SUBP_ON_DISPLAY))
	{

		//
		// is videotimestamp >= starting time stamp of subpicture?
		//

		deltaT = (LONG)(VideoGetPTS() - pdecctl->stsPic + 7 * 3003);

		DbgPrint("'Video PTS: %X \n", VideoGetPTS());

		if (deltaT >= 0)
			//pdecctl->stsPic <= VideoGetPTS())
		{
			//
			// y: start the ticks at current frame count
			//

			pdecctl->decFlags |= SPDECFL_SUBP_ON_DISPLAY;

			pdecctl->cFrames = 0;
		
		}
		else
		{
			if (cFrames > 120)
			{
                //
				// this picture is taking too long.  Let's assume
				// we missed the timestamp, and dump it.
				//

				cFrames = 0;
				pdecctl->decFlags &= ~(SPDECFL_BUF_IN_USE | SPDECFL_SUBP_ON_DISPLAY);
				pdecctl->decFlags |= SPDECFL_LAST_FRAME;
		
				pdecctl->curData = 0;
		
				CleanSPQueue(pspstrmex);

				DumpPacket(pspstrmex);
		
				return;

			}

			if (pdecctl->spState == KSSTATE_RUN)
			{
				cFrames++;
			}

			//
			// n: don't do anything!
			//

			return;
		
		}

	}
	else if (pdecctl->spState == KSSTATE_RUN)
	{
		//
		// increment the field counter
		//

		pdecctl->cFrames++;

	}
	if (!(pdecctl->decFlags & (SPDECFL_SUBP_DECODED)))
	{

		//
		// we don't have any data! (so, don't check time stamps)
		//
		//

		return;
	}

	//
	// is current time stamp one behind next update?
	//

	if ((pdecctl->cFrames + 7) * 3003 <= pdecctl->stsNextUpd)
	{

		//
		// we're still too far from the next update, don't do anything
		//
		return;
	}


	//
	// we need to get busy.  Go off and copy the bitmap to the
	// hardware, and then start the next decode
	//

	ulTmp = *((PWORD)(pdecctl->pData + pdecctl->pSPCmds + 2));
	ulTmp = (ulTmp >> 8) | ((ulTmp & 0xff) << 8);


	if ((pdecctl->decFlags & SPDECFL_ONE_UNIT)  || ulTmp != pdecctl->pSPCmds)
	{
		if (pdecctl->decFlags & SPDECFL_NEW_PIC)
		{
			pdecctl->decFlags &=~SPDECFL_DISP_LIVE;
			SPVideoOSDOff();
		}
		//SetupSPBuffer(pspstrmex);
	
		if (!WriteBMP(pspstrmex))
		{
			return;
		}

		pdecctl->decFlags &= ~(SPDECFL_DISP_OFF | SPDECFL_DISP_FORCED);
		pdecctl->decFlags |= pdecctl->nextDispFlags;
	
		if (pdecctl->decFlags & SPDECFL_NEW_PIC)
		{
			pdecctl->decFlags |= SPDECFL_DISP_LIVE;
			SPVideoOSDOn();
		}

		pdecctl->decFlags &= ~(SPDECFL_SUBP_DECODED | SPDECFL_NEW_PIC);

	}

	if (pdecctl->decFlags & SPDECFL_ONE_UNIT)
	{
		return;
	}


	//
	// find the next start time and start address
	//

	ulTmp = pdecctl->pSPCmds;

	pdecctl->pSPCmds = *((PWORD)(pdecctl->pData + pdecctl->pSPCmds + 2));
	pdecctl->pSPCmds = (pdecctl->pSPCmds >> 8) | ((pdecctl->pSPCmds & 0xff) << 8);

	StartTime = *((WORD *)(pdecctl->pData + pdecctl->pSPCmds));
	StartTime = ((StartTime & 0xFF00) << 2) | ((StartTime & 0xFF) << 18);

	if (ulTmp == pdecctl->pSPCmds)
	{

		//
		// we're done with this subpicture!  Flag it and start the
		// next packet
		//


		pdecctl->decFlags &= ~(SPDECFL_BUF_IN_USE | SPDECFL_SUBP_ON_DISPLAY);
		pdecctl->decFlags |= SPDECFL_LAST_FRAME;

		pdecctl->curData = 0;

		DumpPacket(pspstrmex);

		return;
	}

	pdecctl->lastTime = pdecctl->stsNextUpd;

	pdecctl->stsNextUpd = StartTime;

	SPSchedDecode(pspstrmex);

}

void SPSchedDecode(PSP_STRM_EX pspstrmex)
{
PSP_DECODE_CTL pdecctl = &(pspstrmex->pdecctl);

	if (pdecctl->decFlags & SPDECFL_DECODING)
	{
		pdecctl->decFlags |= SPDECFL_RESTART;
	}
	else
	{
		pdecctl->decFlags |= SPDECFL_DECODING;
		
		StreamClassCallAtNewPriority(pspstrmex->phstrmo,
					pspstrmex->phwdevex,
					Low,
					(PHW_PRIORITY_ROUTINE)StartSPDecode,
					pspstrmex);
	}



}

BOOL fInitSP = FALSE;

void InitSP()
{
	UCHAR EndOsd[]= {0xc1, 0xff, 0xff, 0xff};
	ULONG ulTmp;

	ulTmp = (pVideo->videoBufferSize + pVideo->spBufferSize) * 256;

	BoardWriteVideo(CFG_MWP, (BYTE)(ulTmp >> 17));
	BoardWriteVideo(CFG_MWP, (BYTE)((ulTmp >> 9 ) & 0xFF));
	BoardWriteVideo(CFG_MWP, (BYTE)((ulTmp >> 1) & 0xFF));
	
	BoardWriteVideo(CFG_MWF, (UCHAR)((EndOsd[0])));
	BoardWriteVideo(CFG_MWF, (UCHAR)((EndOsd[1])));
	BoardWriteVideo(CFG_MWF, (UCHAR)((EndOsd[2])));
	BoardWriteVideo(CFG_MWF, (UCHAR)((EndOsd[3])));

	BoardWriteVideo(CFG_MWF, (UCHAR)((EndOsd[1])));
	BoardWriteVideo(CFG_MWF, (UCHAR)((EndOsd[1])));
	BoardWriteVideo(CFG_MWF, (UCHAR)((EndOsd[1])));
	BoardWriteVideo(CFG_MWF, (UCHAR)((EndOsd[1])));
	fInitSP = TRUE;
}

void DumpHLI(PSP_STRM_EX pspstrmex)
{
OSDHEAD Header;
ULONG ulTmp;
PBYTE foo;
BYTE bTmp;
ULONG spBytes;

PSP_DECODE_CTL pdecctl = &(pspstrmex->pdecctl);

	if (!fInitSP)
	{
		InitSP();
	}

	for (foo = (PBYTE)(&Header),ulTmp = 0; ulTmp < sizeof (Header); ulTmp++)
	{
		*foo++ = 0;
	}

	//
	// space is open, so set the memory pointer to the top of
	// the video buffer
	//

	ulTmp = (pVideo->videoBufferSize + 1) * 256;

	BoardWriteVideo(CFG_MWP, (BYTE)(ulTmp >> 17));
	BoardWriteVideo(CFG_MWP, (BYTE)((ulTmp >> 9 ) & 0xFF));
	BoardWriteVideo(CFG_MWP, (BYTE)((ulTmp >> 1) & 0xFF));
	
		//
		// set the OSD top and bottom displays
		//
	
	ulTmp = (pVideo->videoBufferSize + pVideo->spBufferSize) * 32;

	Header.osdhres1 = (USHORT)(ulTmp & 0x00008);
	Header.osdhres2 = (USHORT)(ulTmp & 0x00070) >> 4;
	Header.osdhres3 = (USHORT)(ulTmp & 0x01f80) >> 7;
	Header.osdhres4 = (USHORT)(ulTmp & 0x7e000) >> 13;

	Header.osdhStarty = (USHORT)pdecctl->HLI.hli.StartY /2  + 0x1f;

	Header.osdhStartx = (USHORT)pdecctl->HLI.hli.StartX + XOFFSET + 16;
	Header.osdhStopy = (USHORT)pdecctl->HLI.hli.StopY / 2 + 0x20;
	Header.osdhStopx = (USHORT)pdecctl->HLI.hli.StopX + (1 -((pdecctl->HLI.hli.StopX -
			pdecctl->HLI.hli.StartX) & 1)) + XOFFSET + 16;

    spBytes =(((ULONG) Header.osdhStopy - (ULONG)Header.osdhStarty +1) *
			(pdecctl->HLI.hli.StopX - pdecctl->HLI.hli.StartX + 1) / 2);

	if (FALSE && Header.osdhStopy > 239)
	{
		Header.osdhStopy = 239;
	}

	if (Header.osdhStopx > 720)
	{

		Header.osdhStopx = 720;

		if (!(Header.osdhStartx & 1))
		{
			Header.osdhStopx = 719;
		}
	}

	Header.osdhMQ = 2;              // set up 4 bpp bitmap

	for (ulTmp =0; ulTmp < 16
		; ulTmp ++)
	{
		Header.osdhYUV[ulTmp].osdY = pdecctl->spYUV.ucY[pdecctl->HLI.hli.ColCon.emph1col];
		Header.osdhYUV[ulTmp].osdV = pdecctl->spYUV.ucV[pdecctl->HLI.hli.ColCon.emph1col];
		Header.osdhYUV[ulTmp].osdU = pdecctl->spYUV.ucU[pdecctl->HLI.hli.ColCon.emph1col];

		Header.osdhYUV[ulTmp].osdT = 1;
		Header.osdhYUV[ulTmp].osdres = 0;

	}

	Header.osdhMix = pdecctl->HLI.hli.ColCon.emph1con;

	//
	// write over the header
	//

	for (foo = (PBYTE)(&Header),ulTmp = 0; ulTmp < sizeof (Header); ulTmp+=2)
	{
		bTmp = *foo;
		*foo = *(foo +1);
		*(foo + 1) = bTmp;
		foo+=2;
	}

	WriteSPBuffer((PBYTE)&Header, sizeof(Header));

	for (;spBytes >= 4; spBytes -=4)
	{
		WriteSPData(0);
	}

	for (foo = (PBYTE)(&Header),ulTmp = 0; ulTmp < sizeof (Header); ulTmp+=2)
	{
		bTmp = *foo;
		*foo = *(foo +1);
		*(foo + 1) = bTmp;
		foo+=2;
	}


	ulTmp = 0;

	//
	// put down the end header (indicate a line beyond the display
	// region
	//

	Header.osdhStarty = 0x1ff;
	Header.osdhStopy = 0x1ff;
	Header.osdhMQ = 3;              // set up 4 bpp bitmap

	ulTmp = 0;

	for (foo = (PBYTE)(&Header),ulTmp = 0; ulTmp < sizeof (Header); ulTmp+=2)
	{
		bTmp = *foo;
		*foo = *(foo +1);
		*(foo + 1) = bTmp;
		foo+=2;
	}

	//
	// write over the header
	//

	WriteSPBuffer((PBYTE)&Header, sizeof (Header));

	return;


}

BOOL WriteBMP(PSP_STRM_EX pspstrmex)
{
OSDHEAD Header;
ULONG ulTmp;
PBYTE foo;
BYTE bTmp;
ULONG spBytes;
ULONG cBytes = 256;
ULONG ulActualWidth;


	PSP_DECODE_CTL pdecctl = &(pspstrmex->pdecctl);

	if (!fInitSP)
	{
		InitSP();
	}

	for (foo = (PBYTE)(&Header),ulTmp = 0; ulTmp < sizeof (Header); ulTmp++)
	{
		*foo++ = 0;
	}

	//
	// figure out if we have enough place for the bitmap yet
	//
/*
	if (VideoGetBBL() > pVideo->videoBufferSize)
	{
		return (FALSE);
	}
*/
	//
	// space is open, so set the memory pointer to the top of
	// the video buffer
	//

	if (cSPBytes)
	{
		ulTmp = (pVideo->videoBufferSize + 1) * 256 +cSPBytes + sizeof(Header);

	}
	else
	{
		ulTmp = (pVideo->videoBufferSize + 1) * 256;
	}
	BoardWriteVideo(CFG_MWP, (BYTE)(ulTmp >> 17));
	BoardWriteVideo(CFG_MWP, (BYTE)((ulTmp >> 9 ) & 0xFF));
	BoardWriteVideo(CFG_MWP, (BYTE)((ulTmp >> 1) & 0xFF));
	
		//
		// set the OSD top and bottom displays
		//
	if (!cSPBytes)
	{
		/*
		ulTmp = BoardReadVideo(VID_OBP) << 8;
		ulTmp |= BoardReadVideo(VID_OBP);

		ulTmp &= 0x3fff;

		DbgPrint("'OBP: %lx \n", ulTmp);

		ulTmp = BoardReadVideo(VID_OTP) << 8;
		ulTmp |= BoardReadVideo(VID_OTP);

		ulTmp &= 0x3fff;

		DbgPrint("'OTP: %lx \n", ulTmp);
		DbgPrint("'vidbufsize: %lx \n", pVideo->videoBufferSize + 1);
	
		BoardWriteVideo(VID_OBP, (BYTE)((pVideo->videoBufferSize +1) >> 8));
		BoardWriteVideo(VID_OBP, (BYTE)((pVideo->videoBufferSize +1) & 0xFF));
		BoardWriteVideo(VID_OTP, (BYTE)((pVideo->videoBufferSize +1) >> 8));
		BoardWriteVideo(VID_OTP, (BYTE)((pVideo->videoBufferSize +1) & 0xFF));
		*/

	}

	ulTmp = (pVideo->videoBufferSize + pVideo->spBufferSize) * 32;

	Header.osdhres1 = (USHORT)(ulTmp & 0x00008);
	Header.osdhres2 = (USHORT)(ulTmp & 0x00070) >> 4;
	Header.osdhres3 = (USHORT)(ulTmp & 0x01f80) >> 7;
	Header.osdhres4 = (USHORT)(ulTmp & 0x7e000) >> 13;

	Header.osdhStarty = (USHORT)pdecctl->ulDSAy /2 +0x1f;

	Header.osdhStartx = (USHORT)pdecctl->ulDSAx + XOFFSET + 16;
	Header.osdhStopy = Header.osdhStarty + ((USHORT)pdecctl->ulDSAh - 1) /2 -1;

	if (Header.osdhStopy > 249)
	{
		Header.osdhStopy = 249;
	}

	Header.osdhStopx = Header.osdhStartx + (((USHORT)pdecctl->ulDSAw) & 0xFFFE)  - 1;

	if (!(Header.osdhStartx & 1))
	{
		Header.osdhStartx++;
		Header.osdhStopx++;
	}

	if (FALSE && Header.osdhStopx > 720)
	{
		Header.osdhStopx = 720;

		if (!(Header.osdhStartx & 1))
		{
			Header.osdhStopx = 719;
		}
	}

	ulActualWidth = ((ULONG)Header.osdhStopx - (ULONG)Header.osdhStartx + 1) /2;

    spBytes =((ULONG) Header.osdhStopy - (ULONG)Header.osdhStarty +1) * ulActualWidth;

	while (spBytes / cBytes > 6)
	{
		cBytes = cBytes << 1;
	}

	if (pdecctl->ulDSAw >= 719 && pdecctl->ulDSAh >= 440)
	{
		cBytes = spBytes;
	}

	DbgPrint("'width %d, height %d, actual width %d\n", pdecctl->ulDSAw, pdecctl->ulDSAh,
	  ulActualWidth);

	Header.osdhMQ = 2;              // set up 4 bpp bitmap

	if (pdecctl->decFlags & SPDECFL_USE_STRAIGHT_PAL)
	{
		for (ulTmp =0; ulTmp < 16
			; ulTmp ++)
		{
			Header.osdhYUV[ulTmp].osdY = pdecctl->spYUV.ucY[ulTmp];
			Header.osdhYUV[ulTmp].osdV = pdecctl->spYUV.ucV[ulTmp];
			Header.osdhYUV[ulTmp].osdU = pdecctl->spYUV.ucU[ulTmp];
	
			Header.osdhYUV[ulTmp].osdT = 0;
			Header.osdhYUV[ulTmp].osdres = 0;
	
		}
	
		Header.osdhMix = 0xf;
		Header.osdhYUV[0].osdT = 1;
	}
	else
	{
		Header.osdhYUV[0].osdT = 1;
		Header.osdhYUV[0].osdY = 0;
		Header.osdhYUV[0].osdV = 0;
		Header.osdhYUV[0].osdU = 0;

		for (ulTmp =1; ulTmp < 16 ; ulTmp ++)
		{
			Header.osdhYUV[ulTmp].osdY = pdecctl->spYUV.ucY[pdecctl->mappal.yuvMap[ulTmp]];
			Header.osdhYUV[ulTmp].osdV = pdecctl->spYUV.ucV[pdecctl->mappal.yuvMap[ulTmp]];
			Header.osdhYUV[ulTmp].osdU = pdecctl->spYUV.ucU[pdecctl->mappal.yuvMap[ulTmp]];

			if (pdecctl->mappal.ucAlpha[ulTmp] != pdecctl->minCon ||
				(pdecctl->mappal.ucAlpha[ulTmp] == 0xf))
			{
				Header.osdhYUV[ulTmp].osdT = 0;

			}
			else
			{
				Header.osdhYUV[ulTmp].osdT = 1;
			}
			if (pdecctl)

			Header.osdhYUV[ulTmp].osdres = 0;
	
		}

		Header.osdhMix = pdecctl->minCon;
	
	}


	//
	// write over the header
	//

	for (foo = (PBYTE)(&Header),ulTmp = 0; ulTmp < sizeof (Header); ulTmp+=2)
	{
		bTmp = *foo;
		*foo = *(foo +1);
		*(foo + 1) = bTmp;
		foo+=2;
	}

	if (!cSPBytes)
	{
		ulRemain = 0;

		WriteSPBuffer((PBYTE)&Header, sizeof(Header));

		cBytes -= sizeof(Header);

	}


	for (foo = (PBYTE)(&Header),ulTmp = 0; ulTmp < sizeof (Header); ulTmp+=2)
	{
		bTmp = *foo;
		*foo = *(foo +1);
		*(foo + 1) = bTmp;
		foo+=2;
	}

	//
	// now copy the data
	//

	if (spBytes - cSPBytes > cBytes)
	{

		if (ulActualWidth == (pdecctl->ulDSAw / 2))
		{
			DbgPrint("'Writing equal length %X, %u\n", pdecctl->pTopWork +cSPBytes,
					cBytes);

			WriteSPBuffer(pdecctl->pTopWork + cSPBytes, cBytes);
			cSPBytes += cBytes;
		}
		else
		{
			if (cBytes >= (cSPBytes % ulActualWidth) &&  (cSPBytes % ulActualWidth))
			{
				TRAP
				DbgPrint("'Writing start %X, %u\n", pdecctl->pTopWork + ((cSPBytes / ulActualWidth) *
				((pdecctl->ulDSAw + 1)/2)) + (cSPBytes % ulActualWidth), ulActualWidth -
			 (cSPBytes % ulActualWidth));

				WriteSPBuffer(pdecctl->pTopWork + ((cSPBytes / ulActualWidth) *
				   ((pdecctl->ulDSAw + 1)/2)) + (cSPBytes % ulActualWidth), ulActualWidth -
				(cSPBytes % ulActualWidth));

				cBytes -= ulActualWidth - (cSPBytes % ulActualWidth);
				cSPBytes += ulActualWidth - (cSPBytes % ulActualWidth);

			}

			while (cBytes >= ulActualWidth)
			{
				TRAP

				DbgPrint("'Writing even rows %X, %u\n",pdecctl->pTopWork + ((cSPBytes / ulActualWidth) *
				((pdecctl->ulDSAw + 1)/2)) , ulActualWidth );

				WriteSPBuffer(pdecctl->pTopWork + ((cSPBytes / ulActualWidth) *
				   ((pdecctl->ulDSAw + 1)/2)) , ulActualWidth );

				cSPBytes += ulActualWidth;
                cBytes -= ulActualWidth;

			}

			if (cBytes)
			{
				TRAP

				DbgPrint("'writing tail section %ux, %ul\n",pdecctl->pTopWork + ((cSPBytes / ulActualWidth) *
					((pdecctl->ulDSAw + 1)/2)) , cBytes);

				WriteSPBuffer(pdecctl->pTopWork + ((cSPBytes / ulActualWidth) *
				   ((pdecctl->ulDSAw + 1)/2)) , cBytes);

				cSPBytes += cBytes;

			}
		}

		return(FALSE);
	}
	else
	{

		if (ulActualWidth == (pdecctl->ulDSAw)/2)
		{
			WriteSPBuffer(pdecctl->pTopWork + cSPBytes, spBytes - cSPBytes);
		}
		else
		{
			cBytes = spBytes - cSPBytes;

			if ((cSPBytes % ulActualWidth) && (cBytes >= (cSPBytes % ulActualWidth)))
			{
				WriteSPBuffer(pdecctl->pTopWork + ((cSPBytes / ulActualWidth) *
				   (((pdecctl->ulDSAw + 1)/2))) + (cSPBytes % ulActualWidth), ulActualWidth -
				(cSPBytes % ulActualWidth));

				cBytes -= ulActualWidth - (cSPBytes % ulActualWidth);
				cSPBytes += ulActualWidth - (cSPBytes % ulActualWidth);

			}

			while (cBytes >= ulActualWidth)
			{
				WriteSPBuffer(pdecctl->pTopWork + ((cSPBytes / ulActualWidth) *
				   (((pdecctl->ulDSAw + 1)/2))) , ulActualWidth );

                cBytes -= ulActualWidth;
				cSPBytes += ulActualWidth;

			}

			if (cBytes)
			{
				WriteSPBuffer(pdecctl->pTopWork + ((cSPBytes / ulActualWidth) *
				   (((pdecctl->ulDSAw + 1)/2))) , cBytes);

				cSPBytes += cBytes;

			}
		}

		cSPBytes = 0;

	}

//      WriteSPBuffer(pdecctl->pTopWork, 719 * 115);

	ulTmp = 0;

	//
	// put down the end header (indicate a line beyond the display
	// region
	//

	Header.osdhStarty = 0x1ff;
	Header.osdhStopy = 0x1ff;
	Header.osdhMQ = 3;              // set up 4 bpp bitmap

	ulTmp = 0;

	for (foo = (PBYTE)(&Header),ulTmp = 0; ulTmp < sizeof (Header); ulTmp+=2)
	{
		bTmp = *foo;
		*foo = *(foo +1);
		*(foo + 1) = bTmp;
		foo+=2;
	}

	//
	// write over the header
	//

	WriteSPBuffer((PBYTE)&Header, sizeof (Header));

	return(TRUE);


}


void WriteSPBuffer(PBYTE pBuf, ULONG cnt)
{
static ULONG ulTmp = 0;

	if (ulRemain && (cnt + ulRemain >= 4))
	{
		for ( ;ulRemain < 4; ulRemain++)
		{
			((PUCHAR)&ulTmp)[ulRemain] = *pBuf++;
			cnt--;
		}

		WriteSPData(ulTmp);

		ulRemain = 0;
	}

	while (cnt >= 4)
	{
		WriteSPData(*((PULONG)pBuf));

		cnt -= 4;
		pBuf += 4;
	}

	if (cnt)
	{
		for (;cnt > 0;cnt--, ulRemain++)
		{
			((PUCHAR)&ulTmp)[ulRemain] = *pBuf++;
		}
	
	}

}

void WriteSPData(ULONG ulData)
{
ULONG bTmp;

	do {

		BoardReadVideo(VID_STA0);
		bTmp = BoardReadVideo(VID_STA1) << 8;
		BoardReadVideo(VID_STA2);
	
	} while (!(bTmp & ITM_WFE));

	BoardWriteVideo(CFG_MWF, (UCHAR)((ulData & 0xFF)));
	ulData = ulData >> 8;
	BoardWriteVideo(CFG_MWF, (UCHAR)((ulData & 0xFF)));
	ulData = ulData >> 8;
	BoardWriteVideo(CFG_MWF, (UCHAR)((ulData & 0xFF)));
	ulData = ulData >> 8;
	BoardWriteVideo(CFG_MWF, (UCHAR)((ulData & 0xFF)));

}

BOOL AllocateSPBufs(PSP_DECODE_CTL pdecctl)
{
	if (pdecctl->pTopWork)
	{
		ExFreePool(pdecctl->pTopWork);

		pdecctl->pTopWork = NULL;

	}

	if (pdecctl->pTopWork = ExAllocatePool( NonPagedPool, pdecctl->cDecod))
	{
		pdecctl->pBottomWork = pdecctl->pTopWork + pdecctl->cDecod / 2;

		return(TRUE);
	}

	TRAP

	pdecctl->cDecod = 0;

	return(FALSE);
}

void CleanSPQueue(PSP_STRM_EX pspstrmex)
{
	PHW_STREAM_REQUEST_BLOCK pSrb;

	pspstrmex->pdecctl.curData = 0;
	ulRemain = 0;


	while (pSrb = SPDequeue(pspstrmex))
	{
		CallBackError(pSrb);
	}

}

void SPSetState (PHW_STREAM_REQUEST_BLOCK pSrb)
{

	PHW_DEVICE_EXTENSION phwdevext =
		((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);

	PSP_STRM_EX pspstrmex =
		&(((PSTREAMEX)pSrb->StreamObject->HwStreamExtension)->spstrmex);

	pspstrmex->pdecctl.spState = pSrb->CommandData.StreamState;

	switch (pSrb->CommandData.StreamState)
	{
	case KSSTATE_STOP:
/*
		pVideo->videoBufferSize += pVideo->spBufferSize;
		pVideo->spBufferSize = 0;*/

		pspstrmex->pdecctl.decFlags = 0;

		pspstrmex->pdecctl.HLI.fValid = FALSE;
		pspstrmex->pdecctl.HLI.fProcessed = TRUE;
		SPVideoOSDOff();
		CleanSPQueue(pspstrmex);

		break;

	case KSSTATE_PAUSE:
	case KSSTATE_RUN:

		pspstrmex->pdecctl.decFlags |= SPDECFL_NEW_PIC;

		HwCodecEnableIRQ();
		DumpPacket(pspstrmex);

        break;

	default:

		break;
	}

	pSrb->Status = STATUS_SUCCESS;

}

void SPSetProp (PHW_STREAM_REQUEST_BLOCK pSrb)
{
	PSP_STRM_EX pspstrmex =
		&(((PSTREAMEX)pSrb->StreamObject->HwStreamExtension)->spstrmex);

	PSP_DECODE_CTL pdecctl = &(pspstrmex->pdecctl);

	PKSPROPERTY_SPPAL ppal;

	USHORT cPal;

	//
	// make sure it is a valid property set
	//

	if (pSrb->CommandData.PropertyInfo->PropertySetID)
	{
		//
		// invalid property
		//

		pSrb->Status = STATUS_SUCCESS;
		return;
	}

	switch (pSrb->CommandData.PropertyInfo->Property->Id )
	{

		//
		// look for the pallette property
		//
	
	case KSPROPERTY_DVDSUBPIC_PALETTE:

		ppal = (PKSPROPERTY_SPPAL)pSrb->CommandData.PropertyInfo->PropertyInfo;

		for (cPal = 0;cPal < 16; cPal++)
		{
			pdecctl->spYUV.ucY[cPal] = ppal->sppal[cPal].Y >> 2;
			pdecctl->spYUV.ucU[cPal] = ppal->sppal[cPal].U >> 4;
			pdecctl->spYUV.ucV[cPal] = ppal->sppal[cPal].V >> 4;
		}

		pSrb->Status = STATUS_SUCCESS;

		break;




	//
	// look for HLI property
	//

	case KSPROPERTY_DVDSUBPIC_HLI:
		
		//
		// copy the HLI over
		//

		pdecctl->HLI.hli = *((PKSPROPERTY_SPHLI)pSrb->CommandData.PropertyInfo->PropertyInfo);
		pdecctl->HLI.fProcessed = FALSE;

		if (pdecctl->HLI.hli.HLISS)
		{
			pdecctl->HLI.fValid = TRUE;
		}
		else
		{
			if (!pdecctl->HLI.fActive)
			{
				pdecctl->HLI.fProcessed = TRUE;
			}

			pdecctl->HLI.fValid = FALSE;
		}

		//
		// indicate that this HLI has not been processed yet
		//

		pdecctl->HLI.fActive = FALSE;

		pSrb->Status = STATUS_SUCCESS;

		break;

	case KSPROPERTY_DVDSUBPIC_COMPOSIT_ON:

		if (*((PKSPROPERTY_COMPOSIT_ON)pSrb->CommandData.PropertyInfo->PropertyInfo))
		{
			SPSetSPEnable();
		}
		else
		{
			SPSetSPDisable();
		}

		pSrb->Status = STATUS_SUCCESS;
		break;

	default:

	pSrb->Status = STATUS_NOT_IMPLEMENTED;
		break;
	
	}

}

void SPGetProp (PHW_STREAM_REQUEST_BLOCK pSrb)
{
	PHW_DEVICE_EXTENSION phwdevext =
		((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);

	pSrb->Status = STATUS_SUCCESS;

	switch (pSrb->CommandData.PropertyInfo->PropertySetID)
	{

	case 1:

		//
		// this is a copy protection property go handle it there
		//

		CopyProtGetProp(pSrb);
		break;

	default:

        break;


	}

}

//----------------------------------------------------------------------------
// Enable OSD
//----------------------------------------------------------------------------

void SPSetSPEnable()
{
	PSP_DECODE_CTL pdecctl = &(pSPstrmex->pdecctl);

	pdecctl->decFlags &= ~SPDECFL_USER_DISABLED;

	//
	// check if we currently have video in the card.  If so, enable it
	//

	if (pdecctl->decFlags & SPDECFL_DISP_LIVE)
	{
		SPVideoOSDOn();
	}
}

//----------------------------------------------------------------------------
// Disable OSD
//----------------------------------------------------------------------------

void SPSetSPDisable()
{
	PSP_DECODE_CTL pdecctl = &(pSPstrmex->pdecctl);

	pdecctl->decFlags |= SPDECFL_USER_DISABLED;

	//
	// check if we currently have video in the card that we can disable
	//

	if (!(pdecctl->decFlags & SPDECFL_DISP_FORCED))
	{
		SPVideoOSDOff();
	}
}

//----------------------------------------------------------------------------
// Enable OSD
//----------------------------------------------------------------------------
void SPVideoOSDOn()
{
	PSP_DECODE_CTL pdecctl = &(pSPstrmex->pdecctl);

	//
	// check to see if we should enable the display
	//

	if ((pdecctl->decFlags & SPDECFL_DISP_FORCED) ||
		  !(pdecctl->decFlags & (SPDECFL_DISP_OFF | SPDECFL_USER_DISABLED)))
	{
		pVideo->dcf = pVideo->dcf | 0x10;
		BoardWriteVideo(VID_DCF1, (BYTE)(pVideo->dcf >> 8));
		BoardWriteVideo(VID_DCF0, (BYTE)pVideo->dcf);
	}

}

//----------------------------------------------------------------------------
// Disable OSD
//----------------------------------------------------------------------------
void SPVideoOSDOff ()
{
	pVideo->dcf = pVideo->dcf & (~0x10);
	BoardWriteVideo(VID_DCF1, (BYTE)(pVideo->dcf >> 8));
	BoardWriteVideo(VID_DCF0,(BYTE) pVideo->dcf);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgs\cpq3520a\zac3.c ===
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
// 	MODULE  : ZAC3.C
//	PURPOSE : Zoran AC3 specific code
//	AUTHOR  : JBS Yadawa
// 	CREATED :  7/20/96
//
//
//	Copyright (C) 1996 SGS-THOMSON Microelectronics
//
//
//	REVISION HISTORY:
//	-----------------
//
// 	DATE 			: 	COMMENTS
//	----			: 	--------
//
//	12-28-96 	: 	AC3 structure added - JBS
//	1-1-97		: 	use of status bit to figure out access to ABB - JBS
//	1-15-97		: 	Added BypassMode and normal mode - JBS
//	3-18-97		: 	Added Error handling for AC3  - JBS
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

#include "strmini.h"
#include "stdefs.h"
#include "board.h"
#include "i20reg.h"
#include "bt856.h"
#include "memio.h"
#include "zac3.h"
#include "sti3520a.h"
#include "hwcodec.h"
#include "ksmedia.h"

#define POSTOFFICEREG 		0x200
#define  SPIDO		0x07
#define  SPIDI		0x06
#define  SPICLK		0x05
#define  SPIENA		0x04
#define PARAMSIZE 9

//extern PCODEC pCodec;

static void NEARAPI Ac3SPIStart(void);
static void NEARAPI Ac3SPIStop(void);
static BYTE NEARAPI Ac3SPISendByte(BYTE data);
static BYTE NEARAPI Ac3SPISendSeq(short Num, BYTE FAR *Data);
void NEARAPI Ac3SPIReadBack(BYTE command, short numresult, BYTE *result);
static void NEARAPI Ac3Command(BYTE command);

#define MINABL 40

extern ULONG audiodecoutmode;
extern PVIDEO pVideo;
// static variables only used here
static AC3 Ac3;
PAC3 pAc3;

/*
* Only one of the followng two lines must be in at one time
*/

// The next line will give you AC3 decode downmixed to stereo out ...
BYTE CfgParams[PARAMSIZE] = {AC3_CFG, 0xD0,0x08,0x89,0x09,0x14,0x02,0x02,0x06};

BYTE CfgParamsBypass[PARAMSIZE] = {AC3_CFG, 0xD0,0x08,0x89,0x09,0x34,0x02,0x02,0x06};

// The next line will give you SPDIF AC3 undecode pass through
//BYTE CfgParams[PARAMSIZE] = {AC3_CFG, 0xD0,0x08,0x89,0x09,0x34,0x02,0x02,0x06};

BYTE AC3Params[PARAMSIZE] = {AC3_AC3, 0x10,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF};

#define ZCODE_SIZE	3789
static Zcode[ZCODE_SIZE] = {
0x90, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x03, 0x9C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
0xB8, 0x0C, 0x00, 0x00, 0xB0, 0x3C, 0x36, 0xDE, 0x00, 0x42, 0x38, 0x0D, 0x00, 0x05, 0x32,
0x10, 0x0F, 0xF5, 0x34, 0x20, 0x0F, 0xFA, 0x30, 0x2D, 0x03, 0xEC, 0x00, 0x50, 0x00, 0x00,
0x3C, 0x1D, 0x00, 0x35, 0x34, 0x00, 0x0D, 0xC6, 0x2C, 0x30, 0x00, 0x07, 0x38, 0x00, 0x00,
0x02, 0x32, 0x1D, 0x03, 0xEC, 0x34, 0x0D, 0x03, 0xE1, 0x2C, 0x10, 0x00, 0x40, 0x30, 0x0D,
0x03, 0xE1, 0x2C, 0xB0, 0x00, 0x01, 0x3C, 0x6D, 0x00, 0x1A, 0x00, 0x00, 0xCC, 0x4B, 0x00,
0x00, 0xCC, 0x0B, 0x3A, 0xDE, 0x16, 0x12, 0x3A, 0xFD, 0x00, 0x17, 0x00, 0x03, 0xEB, 0xC1,
0x38, 0x00, 0x05, 0x40, 0x32, 0x1D, 0x03, 0xE1, 0x3A, 0xDD, 0x00, 0x1E, 0x38, 0x00, 0x00,
0x02, 0x32, 0x10, 0x0F, 0xFA, 0x2C, 0xB0, 0x00, 0x02, 0x3C, 0x1D, 0x00, 0x39, 0x38, 0x00,
0x06, 0x00, 0x32, 0x10, 0x0F, 0x81, 0xB0, 0x00, 0x00, 0x00, 0x30, 0x0D, 0x03, 0xD8, 0x30,
0x0D, 0x03, 0xD5, 0x30, 0x0D, 0x03, 0xD6, 0x00, 0x03, 0xC8, 0x76, 0x32, 0x0D, 0x03, 0xF6,
0x32, 0x0D, 0x03, 0xF7, 0x34, 0x00, 0x0F, 0xC5, 0x2C, 0x00, 0x08, 0x00, 0x3C, 0x1D, 0x00,
0x32, 0x38, 0x00, 0x00, 0x00, 0x32, 0x10, 0x0F, 0x8D, 0x38, 0x0D, 0x02, 0x39, 0x32, 0x10,
0x0F, 0xF8, 0x00, 0x00, 0xB8, 0x0C, 0x00, 0x00, 0xB0, 0x3C, 0x38, 0x00, 0x03, 0x80, 0x32,
0x10, 0x0D, 0xCB, 0x3A, 0xDD, 0x01, 0x57, 0x38, 0x00, 0x00, 0x02, 0x32, 0x10, 0x0F, 0xFA,
0x3C, 0x6D, 0x00, 0x39, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x32, 0x10, 0x0D,
0xCA, 0x34, 0x00, 0x0D, 0xCA, 0x00, 0x40, 0x00, 0x00, 0x3C, 0x6D, 0x00, 0x7E, 0x00, 0x00,
0xBC, 0x4B, 0x00, 0x00, 0xBC, 0x0B, 0x38, 0x00, 0x00, 0x01, 0x32, 0x10, 0x0D, 0xC4, 0x34,
0x2D, 0x03, 0xEC, 0x2C, 0xB0, 0x00, 0x00, 0x3C, 0x1D, 0x00, 0x47, 0x34, 0x7D, 0x03, 0xD8,
0x00, 0x00, 0xB3, 0x87, 0x3A, 0xDD, 0x00, 0x4B, 0x00, 0x00, 0xC3, 0x87, 0x30, 0x7D, 0x03,
0xD8, 0x3A, 0xDD, 0x01, 0xB1, 0x3A, 0xFD, 0x00, 0x4B, 0x00, 0x03, 0xEB, 0xC1, 0x3A, 0xDE,
0x18, 0x4E, 0x3A, 0xFD, 0x00, 0x4E, 0x00, 0x03, 0xEB, 0xC1, 0x3A, 0xDE, 0x18, 0xAC, 0x3A,
0xFD, 0x00, 0x51, 0x00, 0x03, 0xEB, 0xC1, 0x3A, 0xDD, 0x01, 0x86, 0x3A, 0xFD, 0x00, 0x54,
0x00, 0x03, 0xEB, 0xC1, 0x3A, 0xDD, 0x01, 0x6E, 0x3A, 0xFD, 0x00, 0x57, 0x00, 0x03, 0xEB,
0xC1, 0x3A, 0xDD, 0x01, 0x5A, 0x3A, 0xFD, 0x00, 0x5A, 0x00, 0x03, 0xEB, 0xC1, 0x34, 0x00,
0x0D, 0xC4, 0x00, 0x40, 0x00, 0x00, 0x3C, 0x6D, 0x00, 0xB7, 0x34, 0x10, 0x0D, 0xCB, 0x34,
0x00, 0x0D, 0xC9, 0x34, 0x80, 0x0D, 0xC1, 0x35, 0x00, 0x0D, 0xFD, 0x32, 0x10, 0x0D, 0xDA,
0xB0, 0x50, 0x60, 0x00, 0x30, 0x80, 0x0D, 0xD6, 0x14, 0x90, 0x00, 0x00, 0x00, 0x03, 0xC0,
0x18, 0x30, 0x20, 0x0D, 0xC9, 0x00, 0x00, 0x80, 0x00, 0x30, 0x80, 0x0D, 0xC8, 0x39, 0x00,
0x00, 0x00, 0x38, 0x00, 0x00, 0x06, 0x32, 0x10, 0x0D, 0xD5, 0x34, 0x00, 0x0F, 0x88, 0x32,
0x10, 0x0D, 0xD7, 0x34, 0x00, 0x0D, 0xFD, 0x32, 0x10, 0x0D, 0xD8, 0x34, 0x00, 0x0D, 0xF2,
0x32, 0x10, 0x0D, 0xD9, 0xB0, 0x03, 0xD0, 0x81, 0x38, 0x80, 0x0D, 0xD5, 0x36, 0xDE, 0x00,
0x41, 0x3A, 0xFD, 0x00, 0x77, 0x00, 0x03, 0xEB, 0xC1, 0x00, 0x40, 0x00, 0x00, 0x3C, 0x1D,
0x00, 0xB7, 0x30, 0x00, 0x0D, 0xC7, 0x34, 0x20, 0x0D, 0xC4, 0x3A, 0xDD, 0x00, 0xB7, 0x00,
0x00, 0xB0, 0x82, 0x30, 0x20, 0x0D, 0xC4, 0x3A, 0xDE, 0x18, 0xAC, 0x3A, 0xFD, 0x00, 0x81,
0x00, 0x03, 0xEB, 0xC1, 0x3A, 0xDD, 0x01, 0x6E, 0x3A, 0xFD, 0x00, 0x84, 0x00, 0x03, 0xEB,
0xC1, 0x34, 0x00, 0x0D, 0xCA, 0x38, 0x10, 0x00, 0x02, 0x04, 0x40, 0x00, 0x00, 0x3C, 0x1D,
0x00, 0xA5, 0x34, 0x00, 0x0D, 0xCA, 0x38, 0x10, 0x00, 0x05, 0x04, 0x40, 0x00, 0x00, 0x3C,
0x1D, 0x00, 0xB7, 0x00, 0x00, 0x00, 0x00, 0x2C, 0x30, 0x00, 0x01, 0x3C, 0x1D, 0x00, 0x99,
0x38, 0x23, 0x00, 0x00, 0x34, 0x3D, 0x03, 0xD8, 0x00, 0x00, 0xD4, 0x43, 0x3C, 0x6D, 0x00,
0xB7, 0x00, 0x00, 0x00, 0x00, 0x2C, 0x30, 0x00, 0x04, 0x3C, 0x1D, 0x00, 0x99, 0x00, 0x00,
0x00, 0x00, 0x38, 0x22, 0x55, 0x55, 0x38, 0x22, 0xAA, 0xAB, 0x00, 0x00, 0xD3, 0x83, 0x3C,
0x1D, 0x00, 0xB7, 0x34, 0x00, 0x0D, 0xCB, 0x44, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00,
0x34, 0x10, 0x0F, 0x8D, 0xA2, 0x00, 0x00, 0x00, 0x3C, 0x4D, 0x00, 0xB7, 0x00, 0x00, 0x00,
0x00, 0x32, 0x10, 0x0F, 0x8D, 0x3A, 0xDD, 0x00, 0xB7, 0x00, 0x00, 0xC0, 0x3C, 0x34, 0x00,
0x0D, 0xC4, 0x00, 0x40, 0x00, 0x00, 0x3C, 0x6D, 0x00, 0xB7, 0x34, 0x00, 0x0D, 0xC8, 0x32,
0x10, 0x0D, 0xD6, 0x34, 0x00, 0x0D, 0xC9, 0x32, 0x10, 0x0D, 0xDA, 0x34, 0x00, 0x0D, 0xC7,
0x38, 0x10, 0x00, 0x02, 0x38, 0x80, 0x0D, 0xD5, 0x36, 0xDE, 0x00, 0x41, 0x3A, 0xFD, 0x00,
0xB2, 0x00, 0x03, 0xEB, 0xC1, 0x00, 0x40, 0x00, 0x00, 0x3C, 0x1D, 0x00, 0xB7, 0x34, 0x20,
0x0D, 0xC4, 0x00, 0x00, 0xB0, 0xC2, 0x30, 0x20, 0x0D, 0xC4, 0x38, 0x00, 0x00, 0x0F, 0x32,
0x10, 0x0D, 0xDB, 0x34, 0x00, 0x0D, 0xFD, 0x32, 0x10, 0x0D, 0xDE, 0x34, 0x00, 0x0D, 0xF2,
0x32, 0x10, 0x0D, 0xDF, 0x34, 0x00, 0x0D, 0xF3, 0x2C, 0x00, 0x00, 0x0F, 0x32, 0x10, 0x0D,
0xE8, 0x38, 0x00, 0x00, 0x00, 0x32, 0x10, 0x0D, 0xE9, 0x38, 0x00, 0x0D, 0xCF, 0x32, 0x10,
0x0D, 0xE0, 0x34, 0x00, 0x0D, 0xFE, 0x32, 0x10, 0x0D, 0xE1, 0x34, 0x00, 0x0D, 0xFF, 0x32,
0x10, 0x0D, 0xE2, 0x34, 0x00, 0x0D, 0xF1, 0x32, 0x10, 0x0D, 0xE3, 0x34, 0x00, 0x0F, 0x88,
0x32, 0x10, 0x0D, 0xDD, 0x34, 0x00, 0x0D, 0xC1, 0x32, 0x10, 0x0D, 0xDC, 0x34, 0x00, 0x0D,
0xF4, 0x32, 0x10, 0x0D, 0xE7, 0x34, 0x00, 0x0D, 0xCA, 0x32, 0x10, 0x0D, 0xE4, 0x34, 0x00,
0x0D, 0xCC, 0x32, 0x10, 0x0D, 0xE5, 0x34, 0x00, 0x0D, 0xCD, 0x32, 0x10, 0x0D, 0xE6, 0x34,
0x0D, 0x03, 0xE3, 0x38, 0x10, 0x00, 0x0C, 0x16, 0x43, 0xD1, 0x01, 0x18, 0x40, 0x00, 0x00,
0x34, 0x10, 0x0D, 0xCE, 0x16, 0x43, 0xD3, 0x02, 0x3C, 0x1D, 0x00, 0xF0, 0x16, 0x53, 0xD4,
0x03, 0x30, 0x20, 0x0D, 0xCE, 0x34, 0x0D, 0x03, 0xE2, 0x2C, 0x00, 0x00, 0x07, 0x2C, 0x30,
0x00, 0x02, 0x3C, 0x3D, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x18, 0xD0, 0x00, 0x00, 0x30,
0x20, 0x0D, 0xCE, 0x38, 0x00, 0x00, 0x02, 0x32, 0x10, 0x0D, 0xE3, 0x38, 0x07, 0xFF, 0xFF,
0x32, 0x10, 0x0D, 0xE7, 0x38, 0x0E, 0x2B, 0xA9, 0x32, 0x10, 0x0D, 0xE0, 0x38, 0x0E, 0x2B,
0xAF, 0x32, 0x10, 0x0D, 0xE1, 0x38, 0x0E, 0x2B, 0xB5, 0x32, 0x10, 0x0D, 0xE2, 0x34, 0x00,
0x0D, 0xE8, 0x00, 0x40, 0x00, 0x00, 0x3C, 0x6D, 0x00, 0xF6, 0x34, 0x00, 0x0D, 0xC4, 0x38,
0x80, 0x0D, 0xDB, 0x06, 0x00, 0x00, 0x00, 0x34, 0x7D, 0x03, 0xD8, 0x00, 0x00, 0xD3, 0x87,
0x3C, 0x1D, 0x00, 0xFD, 0x34, 0x10, 0x0F, 0xFC, 0x00, 0x48, 0x00, 0x00, 0x3C, 0x6D, 0x00,
0xFF, 0x00, 0x00, 0x00, 0x00, 0x38, 0x10, 0x00, 0x03, 0x38, 0x0F, 0xFF, 0xFF, 0x36, 0xDE,
0x00, 0x41, 0x3A, 0xFD, 0x01, 0x02, 0x00, 0x03, 0xEB, 0xC1, 0x30, 0x00, 0x0D, 0xC5, 0x34,
0x00, 0x0D, 0xCE, 0x2C, 0x00, 0x00, 0x10, 0x3C, 0x1D, 0x01, 0x26, 0x38, 0x00, 0x00, 0x20,
0x32, 0x10, 0x0D, 0xE4, 0x38, 0x00, 0x00, 0x0B, 0x32, 0x10, 0x0D, 0xDB, 0x38, 0x0E, 0x2B,
0xA9, 0x32, 0x10, 0x0D, 0xDC, 0x38, 0x0E, 0x2B, 0xAF, 0x32, 0x10, 0x0D, 0xDD, 0x38, 0x0E,
0x2B, 0xB5, 0x32, 0x10, 0x0D, 0xDE, 0x38, 0x00, 0x00, 0x00, 0x32, 0x10, 0x0D, 0xDF, 0x38,
0x00, 0x0D, 0xCF, 0x32, 0x10, 0x0D, 0xE0, 0x34, 0x00, 0x0D, 0xFE, 0x32, 0x10, 0x0D, 0xE1,
0x34, 0x00, 0x0D, 0xFF, 0x32, 0x10, 0x0D, 0xE2, 0x34, 0x00, 0x0D, 0xF4, 0x32, 0x10, 0x0D,
0xE5, 0x34, 0x0D, 0x03, 0xE2, 0x2C, 0x00, 0xC0, 0x00, 0x2E, 0x3F, 0xFF, 0xFE, 0x34, 0x10,
0x0D, 0xF1, 0x2C, 0x41, 0xCF, 0xFF, 0x18, 0x08, 0x00, 0x00, 0x32, 0x50, 0x0D, 0xE3, 0xB0,
0x03, 0xD1, 0x41, 0x38, 0x80, 0x0D, 0xDB, 0x36, 0xDE, 0x00, 0x41, 0x3A, 0xFD, 0x01, 0x26,
0x00, 0x03, 0xEB, 0xC1, 0x38, 0x00, 0x00, 0x01, 0x3A, 0xDE, 0x17, 0xC7, 0x3A, 0xFD, 0x01,
0x2A, 0x00, 0x03, 0xEB, 0xC1, 0x36, 0xD0, 0x0F, 0x8C, 0x3A, 0xFD, 0x01, 0x2D, 0x00, 0x03,
0xEB, 0xC1, 0x3A, 0xDE, 0x18, 0xE5, 0x3A, 0xFD, 0x01, 0x30, 0x00, 0x03, 0xEB, 0xC1, 0x34,
0x00, 0x0D, 0xCA, 0x2C, 0x30, 0x00, 0x05, 0x3C, 0x5D, 0x01, 0x36, 0x12, 0x03, 0xD0, 0x01,
0x30, 0x00, 0x0D, 0xCA, 0x30, 0x10, 0x0D, 0xCA, 0x38, 0x00, 0x00, 0x08, 0x32, 0x1D, 0x03,
0xE0, 0x34, 0x0D, 0x03, 0xEC, 0x2C, 0x30, 0x00, 0x00, 0x3C, 0x1D, 0x01, 0x3E, 0x34, 0x00,
0x0D, 0xC6, 0x2C, 0x10, 0x05, 0x00, 0x2C, 0x10, 0x00, 0x40, 0x34, 0x20, 0x0D, 0xC5, 0x34,
0x10, 0x0D, 0xC4, 0x00, 0x4B, 0xD0, 0xC1, 0x3C, 0x1D, 0x01, 0x45, 0x0C, 0x50, 0x00, 0x00,
0x18, 0x80, 0x00, 0x00, 0x2C, 0x10, 0x40, 0x00, 0x32, 0x1D, 0x03, 0xE1, 0x38, 0x0D, 0x03,
0xE0, 0x32, 0x10, 0x0F, 0xFB, 0x34, 0x00, 0x0F, 0xC5, 0x2C, 0x00, 0x10, 0x00, 0x3C, 0x1D,
0x01, 0x57, 0x34, 0x7D, 0x03, 0xD8, 0x00, 0x00, 0xD3, 0x47, 0x3C, 0x1D, 0x01, 0x51, 0x00,
0x00, 0xC8, 0x4C, 0x00, 0x00, 0xC0, 0xBC, 0x00, 0x00, 0xB0, 0xBC, 0x34, 0x00, 0x0D, 0xC4,
0x00, 0x40, 0x00, 0x00, 0x3C, 0x1D, 0x01, 0x57, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0,
0xFC, 0x00, 0x00, 0xB0, 0xFC, 0x00, 0x03, 0xF0, 0x2D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x34, 0x5D, 0x03, 0xD8, 0x00, 0x00, 0xD4, 0xC5, 0x3C, 0x1D, 0x01, 0x6A, 0x34,
0x0D, 0x03, 0xD3, 0x36, 0x0D, 0x03, 0xD4, 0x2C, 0x00, 0xFF, 0xFF, 0x2E, 0x20, 0x00, 0x07,
0x00, 0x03, 0xC8, 0x83, 0x2E, 0x20, 0x00, 0x01, 0x00, 0x03, 0xC0, 0xE2, 0x2E, 0x2F, 0xFF,
0xFC, 0x2E, 0x3F, 0xFF, 0xFF, 0x2E, 0x2F, 0xFF, 0xFA, 0x3A, 0xDD, 0x01, 0x6A, 0x00, 0x03,
0xC8, 0x76, 0x32, 0x0D, 0x03, 0xF7, 0x00, 0x00, 0xC4, 0xC5, 0x00, 0x03, 0xF0, 0x2D, 0x00,
0x00, 0xC4, 0x45, 0x30, 0x5D, 0x03, 0xD8, 0x34, 0x0D, 0x03, 0xD8, 0x00, 0x00, 0xD3, 0xA1,
0x3C, 0x1D, 0x01, 0x74, 0x00, 0x00, 0x00, 0x00, 0xB2, 0x48, 0x00, 0x00, 0x3A, 0x40, 0x00,
0xF0, 0x34, 0x0D, 0x03, 0xD5, 0x36, 0x0D, 0x03, 0xD6, 0xA2, 0x00, 0x00, 0x00, 0x32, 0x1D,
0x03, 0xD5, 0x3B, 0x80, 0x00, 0x00, 0x32, 0x0D, 0x03, 0xD6, 0x00, 0x03, 0xC8, 0x76, 0x32,
0x0D, 0x03, 0xF6, 0x36, 0x0D, 0x03, 0xF7, 0x00, 0x03, 0xCD, 0xA1, 0xA2, 0x03, 0xD0, 0x78,
0x00, 0x03, 0xC0, 0x01, 0x32, 0x4D, 0x03, 0xE8, 0x2E, 0x6F, 0xFF, 0xF0, 0x32, 0x4D, 0x03,
0xE7, 0x00, 0x03, 0xF0, 0x2D, 0x00, 0x03, 0xC8, 0x76, 0x32, 0x0D, 0x03, 0xF7, 0x34, 0x00,
0x0F, 0xC5, 0x00, 0x00, 0xD1, 0x61, 0x3C, 0x1D, 0x01, 0xAE, 0x34, 0x7D, 0x03, 0xD8, 0x00,
0x00, 0xD3, 0x87, 0x00, 0x00, 0xB3, 0x07, 0x3C, 0x1D, 0x01, 0x96, 0x34, 0x00, 0x0F, 0xFC,
0x00, 0x00, 0xD0, 0x21, 0x3C, 0x1D, 0x01, 0x96, 0x34, 0x00, 0x0D, 0xC4, 0x00, 0x40, 0x00,
0x00, 0x3C, 0x6D, 0x01, 0x96, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0xC3, 0x07, 0x30, 0x7D, 0x03, 0xD8, 0x34, 0x0D, 0x03, 0xE3, 0x2C, 0x00, 0x07, 0x00, 0x2E,
0x30, 0x00, 0x04, 0x2C, 0x10, 0x00, 0x10, 0x32, 0x1D, 0x03, 0xED, 0x34, 0x00, 0x0D, 0xC1,
0x32, 0x1D, 0x03, 0xF3, 0x34, 0x30, 0x0D, 0xCB, 0x30, 0x3D, 0x03, 0xEE, 0x38, 0x20, 0x0B,
0xFC, 0xB6, 0x90, 0x00, 0x00, 0x30, 0x2D, 0x03, 0xEF, 0x2E, 0xCF, 0xFA, 0x06, 0x2E, 0xDA,
0xAA, 0xAB, 0x3B, 0x80, 0x00, 0x00, 0x2C, 0xCF, 0xFF, 0xFE, 0x00, 0x00, 0xD0, 0x0F, 0x3C,
0x1D, 0x01, 0xAC, 0x38, 0x0D, 0x03, 0x3B, 0x32, 0x10, 0x0F, 0xF9, 0x14, 0xD8, 0x00, 0x00,
0x3B, 0x80, 0x00, 0x01, 0x30, 0x3D, 0x03, 0xF8, 0x00, 0x03, 0xF0, 0x2D, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x00, 0x0F, 0x8D, 0x00, 0x43, 0xC3, 0xC0, 0x3C, 0x4D,
0x01, 0xBA, 0x34, 0x10, 0x0D, 0xC2, 0x04, 0x08, 0x00, 0x00, 0x3C, 0x6D, 0x01, 0xB1, 0x38,
0x00, 0x00, 0x07, 0x32, 0x10, 0x0D, 0xC6, 0x3A, 0xDD, 0x02, 0x18, 0x34, 0x00, 0x0D, 0xC0,
0x3A, 0xDD, 0x02, 0x2E, 0x3A, 0xFD, 0x01, 0xBE, 0x00, 0x03, 0xEB, 0xC1, 0x2E, 0x0F, 0xFF,
0xF6, 0x3C, 0x3D, 0x01, 0xC5, 0x38, 0x10, 0x00, 0x01, 0x38, 0x20, 0x03, 0x80, 0x3A, 0xDD,
0x02, 0x18, 0x30, 0x20, 0x0F, 0x8D, 0x00, 0x00, 0xC0, 0x3C, 0x20, 0x40, 0x00, 0x00, 0x30,
0x00, 0x0D, 0xE1, 0x34, 0x00, 0x0D, 0xC0, 0x32, 0x10, 0x0D, 0xDC, 0x34, 0x00, 0x0F, 0x88,
0x32, 0x10, 0x0D, 0xDD, 0x31, 0x60, 0x0D, 0xDE, 0x34, 0x00, 0x0D, 0xF2, 0x32, 0x10, 0x0D,
0xDF, 0x38, 0x00, 0x00, 0x00, 0x32, 0x10, 0x0D, 0xE0, 0x38, 0x80, 0x0D, 0xDB, 0xB0, 0x03,
0xD2, 0x01, 0x3A, 0xDE, 0x19, 0x92, 0x3A, 0xFD, 0x01, 0xD5, 0x00, 0x03, 0xEB, 0xC1, 0x00,
0x43, 0xC5, 0x91, 0x34, 0x90, 0x0F, 0x87, 0x3C, 0x6D, 0x02, 0x15, 0x38, 0x00, 0x00, 0x01,
0x32, 0x10, 0x0D, 0xC6, 0x30, 0x90, 0x0D, 0xC1, 0x38, 0x00, 0x00, 0x05, 0x32, 0x10, 0x0D,
0xDB, 0x30, 0x90, 0x0D, 0xDC, 0x34, 0x00, 0x0F, 0x88, 0x32, 0x10, 0x0D, 0xDD, 0x31, 0x60,
0x0D, 0xDE, 0x34, 0x00, 0x0D, 0xF2, 0x32, 0x10, 0x0D, 0xDF, 0x38, 0x80, 0x0D, 0xDB, 0xB0,
0x03, 0xD0, 0x41, 0x36, 0xDE, 0x00, 0x41, 0x3A, 0xFD, 0x01, 0xE8, 0x00, 0x03, 0xEB, 0xC1,
0x39, 0x80, 0x00, 0x02, 0x30, 0x00, 0x0D, 0xC6, 0x00, 0x43, 0x60, 0x02, 0x3C, 0x6D, 0x02,
0x12, 0x39, 0x80, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x60, 0x01, 0x30, 0x20,
0x0D, 0xCB, 0x30, 0x10, 0x0D, 0xC9, 0x39, 0x10, 0x00, 0x00, 0x39, 0x80, 0x00, 0x04, 0x00,
0x02, 0xA0, 0x07, 0x30, 0x7D, 0x03, 0xE2, 0x00, 0x00, 0x80, 0x00, 0x38, 0x9D, 0x03, 0xE3,
0x3E, 0x00, 0x00, 0x04, 0x00, 0x06, 0x51, 0xCF, 0x34, 0x00, 0x0D, 0xFD, 0x22, 0x13, 0xC5,
0x91, 0x34, 0x90, 0x0D, 0xC1, 0x00, 0x03, 0xC0, 0x99, 0x38, 0x15, 0x00, 0x00, 0x34, 0x20,
0x0D, 0xCB, 0x42, 0x98, 0x80, 0x08, 0x2E, 0xC0, 0x00, 0x04, 0x30, 0x90, 0x0D, 0xC0, 0x34,
0x00, 0x0D, 0xC1, 0x3A, 0xDD, 0x02, 0x2E, 0x3A, 0xFD, 0x02, 0x06, 0x00, 0x03, 0xEB, 0xC1,
0xB0, 0xC0, 0x00, 0x00, 0x3C, 0x4D, 0x02, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x0F,
0x8D, 0x00, 0x00, 0xC0, 0x3C, 0x3A, 0xDD, 0x02, 0x1C, 0x3A, 0xFD, 0x02, 0x0E, 0x00, 0x03,
0xEB, 0xC1, 0x39, 0x10, 0x00, 0x00, 0x00, 0x03, 0xF0, 0x2D, 0x31, 0x10, 0x0D, 0xC4, 0x30,
0xF0, 0x0D, 0xC3, 0x3A, 0xDD, 0x02, 0x16, 0x34, 0x00, 0x0D, 0xC1, 0x32, 0x10, 0x0D, 0xC0,
0x30, 0x90, 0x0D, 0xC0, 0x38, 0x00, 0x03, 0x80, 0x32, 0x10, 0x0D, 0xCB, 0x39, 0x10, 0x00,
0x00, 0x00, 0x03, 0xF0, 0x2D, 0x38, 0x00, 0x00, 0x01, 0x32, 0x10, 0x0D, 0xC4, 0x34, 0x3D,
0x03, 0xCB, 0x2E, 0xFF, 0xFF, 0xFC, 0x14, 0xDB, 0xC5, 0x91, 0x2E, 0xFF, 0xFF, 0xFF, 0x00,
0x03, 0xC0, 0xD9, 0x34, 0x9D, 0x03, 0xD7, 0x34, 0x40, 0x0D, 0xC1, 0x00, 0x00, 0x80, 0x08,
0x00, 0x03, 0xC2, 0x43, 0x04, 0xE0, 0x00, 0x00, 0x3C, 0x6D, 0x02, 0x2B, 0x34, 0x5D, 0x03,
0xD8, 0x00, 0x00, 0xC4, 0xC5, 0x00, 0x00, 0xB4, 0xC5, 0x00, 0x00, 0xB2, 0xC5, 0x00, 0x03,
0xF0, 0x2D, 0x00, 0x00, 0x00, 0x00, 0x30, 0x5D, 0x03, 0xD8, 0x00, 0x00, 0xCC, 0x4B, 0x00,
0x03, 0xC3, 0x81, 0x34, 0x20, 0x0F, 0x8D, 0xB0, 0x40, 0xBC, 0x4B, 0x3C, 0x2D, 0x02, 0x36,
0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xC5, 0x81, 0xA2, 0x00, 0x00, 0x00, 0x00, 0x03, 0xF0,
0x2D, 0xA0, 0x90, 0x00, 0x00, 0xB0, 0x48, 0x00, 0x00, 0x38, 0x3D, 0x03, 0x2A, 0x30, 0x3D,
0x03, 0xCE, 0x00, 0x03, 0xCC, 0x03, 0x00, 0x58, 0x00, 0x00, 0x3C, 0x1D, 0x03, 0x37, 0x38,
0x3D, 0x02, 0x46, 0x30, 0x30, 0x0F, 0xF8, 0x38, 0x3D, 0x02, 0x39, 0x30, 0x30, 0x0F, 0xF8,
0x00, 0x03, 0xF0, 0x2B, 0x00, 0x03, 0xF0, 0x2D, 0x3B, 0x80, 0x00, 0x01, 0x34, 0x30, 0x0F,
0xCC, 0x00, 0x03, 0xCC, 0x03, 0x2C, 0xCF, 0xFF, 0xF0, 0x2C, 0xF0, 0x1B, 0xD0, 0x3C, 0x6D,
0x03, 0x36, 0x38, 0x4D, 0x02, 0x39, 0x30, 0x40, 0x0F, 0xF8, 0x00, 0x03, 0xE3, 0x81, 0x00,
0x03, 0xEB, 0x01, 0x3B, 0x50, 0x00, 0x00, 0x3B, 0x70, 0x00, 0x00, 0x38, 0xED, 0x03, 0xBE,
0x2E, 0xF0, 0x00, 0x08, 0x00, 0x03, 0xE0, 0xF4, 0x30, 0xED, 0x03, 0xCF, 0x34, 0x3D, 0x03,
0xD2, 0x2C, 0xC0, 0xFF, 0xFC, 0x30, 0x3D, 0x03, 0xD2, 0x38, 0x30, 0x00, 0x04, 0x30, 0x3D,
0x03, 0xD0, 0x38, 0x3D, 0x02, 0x5E, 0x30, 0x3D, 0x03, 0xD1, 0x3A, 0xDD, 0x03, 0x29, 0x38,
0x3D, 0x03, 0x11, 0x30, 0x30, 0x0F, 0xF8, 0x00, 0x03, 0xE3, 0x81, 0x00, 0x03, 0xEB, 0x01,
0x3B, 0x50, 0x00, 0x00, 0x3B, 0x70, 0x00, 0x00, 0x34, 0xED, 0x03, 0xCF, 0x00, 0x03, 0xCC,
0x03, 0x2E, 0xFF, 0xFF, 0xF8, 0x2C, 0xC0, 0x0F, 0xF0, 0x00, 0x03, 0xFD, 0x04, 0x18, 0xE0,
0x00, 0x00, 0x00, 0x03, 0xE1, 0x32, 0x00, 0x03, 0xCC, 0x04, 0x2F, 0x30, 0x00, 0x08, 0x00,
0x03, 0xE1, 0x34, 0x30, 0xED, 0x03, 0xCF, 0x2E, 0xFF, 0xFF, 0xFC, 0x2C, 0xF0, 0x00, 0x10,
0x3C, 0x3D, 0x03, 0x29, 0x38, 0x4D, 0x02, 0x39, 0x30, 0x40, 0x0F, 0xF8, 0x2E, 0xCF, 0xFF,
0xFF, 0x3C, 0x5D, 0x02, 0x85, 0x00, 0x00, 0xD0, 0x03, 0x30, 0x3D, 0x03, 0xD0, 0x38, 0x4D,
0x03, 0x11, 0x30, 0x40, 0x0F, 0xF8, 0x3C, 0x1D, 0x03, 0x29, 0x38, 0x4D, 0x02, 0xB1, 0x30,
0x4D, 0x03, 0xD1, 0x3A, 0xDD, 0x03, 0x29, 0x38, 0x4D, 0x02, 0x7E, 0x30, 0x4D, 0x03, 0xCE,
0x00, 0x03, 0xEB, 0x01, 0x3B, 0x50, 0x00, 0x00, 0x3B, 0x70, 0x00, 0x00, 0x38, 0x3D, 0x03,
0x2A, 0x30, 0x3D, 0x03, 0xCE, 0x00, 0x03, 0xCC, 0x04, 0x2F, 0x30, 0x00, 0x08, 0x00, 0x03,
0xC1, 0x03, 0x2C, 0xCE, 0x80, 0x00, 0x2C, 0xF8, 0x00, 0x00, 0x38, 0xED, 0x03, 0xCA, 0x3C,
0x6D, 0x03, 0x29, 0x38, 0x3D, 0x02, 0x39, 0x30, 0x30, 0x0F, 0xF8, 0x00, 0x03, 0xE1, 0x34,
0x30, 0xED, 0x03, 0xCF, 0x38, 0x30, 0x00, 0x02, 0x30, 0x3D, 0x03, 0xD0, 0x38, 0x3D, 0x02,
0x95, 0x30, 0x3D, 0x03, 0xD1, 0x3A, 0xDD, 0x03, 0x29, 0x38, 0x3D, 0x03, 0x11, 0x30, 0x30,
0x0F, 0xF8, 0x00, 0x03, 0xEB, 0x01, 0x3B, 0x70, 0x00, 0x00, 0x3B, 0x50, 0x00, 0x00, 0x00,
0x03, 0xE3, 0x81, 0x34, 0xED, 0x03, 0xCF, 0x00, 0x03, 0xCC, 0x03, 0x2E, 0xFF, 0xFF, 0xF8,
0x00, 0x03, 0xFD, 0x04, 0x19, 0x18, 0x00, 0x00, 0x00, 0x03, 0xE0, 0xF4, 0x00, 0x03, 0xF0,
0x0E, 0x34, 0x4D, 0x03, 0xD2, 0x00, 0x00, 0xB0, 0x04, 0x30, 0x4D, 0x03, 0xD2, 0x00, 0x00,
0xD0, 0x84, 0x3C, 0x1D, 0x02, 0xAC, 0x00, 0x03, 0xCC, 0x03, 0x2E, 0xF0, 0x00, 0x08, 0x2E,
0xFF, 0xFF, 0xF8, 0x00, 0x03, 0xFD, 0x04, 0x3A, 0xDD, 0x02, 0xAD, 0x19, 0x18, 0x00, 0x00,
0x00, 0x03, 0xE0, 0xF2, 0x00, 0x03, 0xE0, 0xF4, 0x00, 0x03, 0xF0, 0x2C, 0x3A, 0xDD, 0x02,
0xC5, 0x30, 0xED, 0x03, 0xCF, 0x00, 0x03, 0xE3, 0x81, 0x00, 0x03, 0xE3, 0x81, 0x00, 0x03,
0xCC, 0x03, 0x2C, 0xCE, 0x80, 0x00, 0x2C, 0xF8, 0x00, 0x00, 0x3C, 0x6D, 0x03, 0x2A, 0x38,
0x3D, 0x02, 0x39, 0x30, 0x30, 0x0F, 0xF8, 0x38, 0xED, 0x03, 0xCA, 0x38, 0x3D, 0x02, 0xBE,
0x00, 0x03, 0xEC, 0x32, 0x3A, 0xDD, 0x03, 0x2A, 0x30, 0xED, 0x03, 0xCF, 0x30, 0x30, 0x0F,
0xF8, 0x00, 0x03, 0xC3, 0x84, 0x00, 0x03, 0xE3, 0x81, 0x34, 0xED, 0x03, 0xCF, 0x30, 0x4D,
0x03, 0xCF, 0x00, 0x03, 0xEC, 0x32, 0x00, 0x03, 0xF0, 0x0E, 0x00, 0x03, 0xE3, 0x81, 0x00,
0x03, 0xEB, 0x01, 0x3B, 0x70, 0x00, 0x00, 0x3B, 0x50, 0x00, 0x00, 0x34, 0x3D, 0x03, 0xC0,
0x2C, 0xCC, 0x00, 0x00, 0x2C, 0xF8, 0x00, 0x00, 0x00, 0x03, 0xC3, 0x83, 0x3C, 0x1D, 0x02,
0xD0, 0x34, 0x4D, 0x03, 0xC2, 0x2F, 0x30, 0x00, 0x04, 0x38, 0x30, 0x00, 0x00, 0x30, 0x3D,
0x03, 0xD7, 0x34, 0x3D, 0x03, 0xC3, 0x2E, 0xFF, 0xFF, 0xF4, 0x19, 0x18, 0x00, 0x00, 0x30,
0x3D, 0x03, 0xD4, 0x34, 0x3D, 0x03, 0xC2, 0x2E, 0xFF, 0xFF, 0xF0, 0x34, 0x4D, 0x03, 0xC1,
0x19, 0x18, 0x00, 0x00, 0x30, 0x3D, 0x03, 0xD3, 0x34, 0x3D, 0x03, 0xD2, 0x00, 0x00, 0xB0,
0x43, 0x30, 0x3D, 0x03, 0xD2, 0x34, 0x4D, 0x03, 0xBE, 0x2F, 0x30, 0x00, 0x04, 0x2D, 0x00,
0xFF, 0x00, 0x34, 0x3D, 0x03, 0xBF, 0x2E, 0xFF, 0xFF, 0xF4, 0x2C, 0xC0, 0x00, 0xFF, 0x19,
0x18, 0x00, 0x00, 0x2C, 0xF0, 0x07, 0xEC, 0x3C, 0x3D, 0x03, 0x29, 0x38, 0x4D, 0x02, 0x39,
0x30, 0x40, 0x0F, 0xF8, 0x34, 0x4D, 0x03, 0xC0, 0x2F, 0x3F, 0xFF, 0xFC, 0x2D, 0x00, 0x00,
0xFF, 0xB8, 0xD8, 0x00, 0x00, 0x2E, 0xCF, 0xFF, 0xF9, 0x34, 0x4D, 0x03, 0xD2, 0x2D, 0x00,
0x00, 0x01, 0xB8, 0xD8, 0x00, 0x00, 0x30, 0x3D, 0x03, 0xD0, 0x38, 0x3D, 0x02, 0x39, 0x30,
0x3D, 0x03, 0xD1, 0x34, 0x3D, 0x03, 0xD2, 0x00, 0x00, 0xD0, 0x83, 0x3C, 0x6D, 0x03, 0x01,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0x03, 0x3C, 0x1D, 0x03, 0x29, 0x38, 0x3D, 0x03,
0x0A, 0x30, 0x30, 0x0F, 0xF8, 0x34, 0x3D, 0x03, 0xD2, 0x00, 0x00, 0xB0, 0x83, 0x30, 0x3D,
0x03, 0xD2, 0x3A, 0xDD, 0x03, 0x29, 0x38, 0x3D, 0x03, 0x11, 0x30, 0x30, 0x0F, 0xF8, 0x3C,
0x1D, 0x03, 0x29, 0x38, 0x3D, 0x03, 0x11, 0x30, 0x30, 0x0F, 0xF8, 0x34, 0x3D, 0x03, 0xD2,
0x00, 0x00, 0xC0, 0x83, 0x30, 0x3D, 0x03, 0xD2, 0x3A, 0xDD, 0x03, 0x29, 0x38, 0x3D, 0x03,
0x0A, 0x30, 0x30, 0x0F, 0xF8, 0x00, 0x03, 0xE3, 0x81, 0x00, 0x03, 0xEB, 0x01, 0x3B, 0x70,
0x00, 0x00, 0x3B, 0x50, 0x00, 0x00, 0x3A, 0xDD, 0x03, 0x1F, 0x34, 0xED, 0x03, 0xCF, 0x00,
0x03, 0xCC, 0x03, 0x00, 0x03, 0xE3, 0x81, 0x00, 0x03, 0xEB, 0x01, 0x3B, 0x70, 0x00, 0x00,
0x3B, 0x50, 0x00, 0x00, 0x34, 0xED, 0x03, 0xCF, 0x00, 0x03, 0xCC, 0x03, 0x2E, 0xF0, 0x00,
0x08, 0x00, 0x01, 0x1C, 0x33, 0x00, 0x03, 0xCC, 0x03, 0x2E, 0xFF, 0xFF, 0xF8, 0x2C, 0xC0,
0x0F, 0xF0, 0x00, 0x03, 0xFD, 0x04, 0x2D, 0x0F, 0xF0, 0x00, 0x19, 0x18, 0x00, 0x00, 0x34,
0x4D, 0x03, 0xD0, 0x2F, 0x0F, 0xFF, 0xFE, 0x00, 0x03, 0xE0, 0xF2, 0x3C, 0x3D, 0x03, 0x29,
0x30, 0x4D, 0x03, 0xD0, 0x30, 0xED, 0x03, 0xCF, 0x00, 0x03, 0xF0, 0x2C, 0x36, 0xDD, 0x03,
0xCE, 0x34, 0x4D, 0x03, 0xD1, 0x30, 0x40, 0x0F, 0xF8, 0x00, 0x03, 0xF0, 0x2C, 0x34, 0x3D,
0x03, 0xD2, 0x00, 0x00, 0xD0, 0x43, 0x3C, 0x1D, 0x03, 0x37, 0x34, 0x40, 0x0F, 0xCD, 0x00,
0x03, 0xF0, 0x0E, 0x34, 0xED, 0x03, 0xCF, 0x34, 0x30, 0x0F, 0x8D, 0x2E, 0xCF, 0xFF, 0xFF,
0x3C, 0x3D, 0x03, 0x36, 0x30, 0x30, 0x0F, 0x8D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB0,
0x3C, 0x34, 0x40, 0x0F, 0xCD, 0x00, 0x03, 0xF0, 0x2B, 0x00, 0x03, 0xF0, 0x2D, 0x3B, 0x80,
0x00, 0x01, 0x34, 0x30, 0x0F, 0xCC, 0x34, 0x3D, 0x03, 0xF8, 0x2E, 0xCF, 0xFF, 0xFF, 0x3C,
0x3D, 0x03, 0x7F, 0x30, 0x3D, 0x03, 0xF8, 0xB9, 0x20, 0x00, 0x00, 0x3A, 0xDD, 0x03, 0x7F,
0x38, 0x3D, 0x03, 0x43, 0x30, 0x30, 0x0F, 0xF9, 0x38, 0x4F, 0x87, 0x20, 0x3A, 0xDD, 0x03,
0x7F, 0x38, 0x3D, 0x03, 0x47, 0x30, 0x30, 0x0F, 0xF9, 0x38, 0x44, 0xE1, 0xF0, 0x3A, 0xDD,
0x03, 0x7F, 0x38, 0x3D, 0x03, 0x4B, 0x30, 0x30, 0x0F, 0xF9, 0x34, 0x4D, 0x03, 0xD8, 0x00,
0x00, 0xD3, 0x04, 0x34, 0x4D, 0x03, 0xED, 0x3C, 0x1D, 0x03, 0x7F, 0x38, 0x3D, 0x03, 0x5B,
0x30, 0x30, 0x0F, 0xF9, 0x38, 0x40, 0x10, 0x30, 0x3A, 0xDD, 0x03, 0x7F, 0x38, 0x3D, 0x03,
0x55, 0x30, 0x30, 0x0F, 0xF9, 0x38, 0x30, 0x0B, 0xFC, 0x30, 0x3D, 0x03, 0xF8, 0x38, 0x40,
0x02, 0x00, 0x3A, 0xDD, 0x03, 0x7F, 0x38, 0x3D, 0x03, 0x3B, 0x30, 0x30, 0x0F, 0xF9, 0x00,
0x03, 0xEB, 0x01, 0x34, 0x30, 0x0F, 0x88, 0x00, 0x5B, 0xD0, 0x35, 0x38, 0x3D, 0x03, 0x66,
0x3C, 0x1D, 0x03, 0x63, 0x34, 0x4D, 0x03, 0xEE, 0x30, 0x4D, 0x03, 0xF8, 0x38, 0x3D, 0x03,
0x6D, 0x3A, 0xDD, 0x03, 0x80, 0x30, 0x30, 0x0F, 0xF9, 0x2F, 0x30, 0x00, 0x08, 0xB6, 0xDB,
0xE3, 0x81, 0x34, 0xED, 0x03, 0xF3, 0x34, 0x3D, 0x03, 0xF8, 0x14, 0xDB, 0xFC, 0x84, 0x3A,
0xDD, 0x03, 0x79, 0x30, 0xED, 0x03, 0xF3, 0x00, 0x03, 0xF0, 0x0E, 0x00, 0x03, 0xE3, 0x81,
0x34, 0xED, 0x03, 0xF3, 0x00, 0x03, 0xEB, 0x01, 0xB6, 0xDB, 0xD0, 0x35, 0x00, 0x07, 0x4C,
0xF4, 0x30, 0xED, 0x03, 0xF3, 0x2E, 0xF0, 0x00, 0x08, 0x2C, 0xCF, 0xF0, 0x00, 0x2F, 0x3F,
0xFF, 0xF8, 0x18, 0xE3, 0xF0, 0x2C, 0x34, 0x3D, 0x03, 0xF8, 0x14, 0xDB, 0xF0, 0x0E, 0x3C,
0x3D, 0x03, 0x7F, 0x30, 0x3D, 0x03, 0xF8, 0x34, 0x3D, 0x03, 0xEF, 0x30, 0x3D, 0x03, 0xF8,
0x38, 0x3D, 0x03, 0x3B, 0x30, 0x30, 0x0F, 0xF9, 0x00, 0x03, 0xEB, 0x01, 0x3B, 0x50, 0x00,
0x00, 0x34, 0x30, 0x0F, 0xC8, 0x0C, 0xE0, 0x60, 0x38, 0x00, 0x03, 0xC1, 0x31, 0x00, 0x02,
0xEE, 0x3C, 0x0C, 0xE0, 0x1E, 0x38, 0x00, 0x03, 0xC1, 0x32, 0x00, 0x03, 0xF0, 0x2C, 0x34,
0x40, 0x0F, 0xCD, 0x00, 0x03, 0xF0, 0x2B, 0x00, 0x03, 0xF0, 0x2D, 0x3B, 0x80, 0x00, 0x01,
0x34, 0x30, 0x0F, 0xCC, 0x00, 0x03, 0xEB, 0x01, 0x3B, 0x50, 0x00, 0x00, 0x34, 0x40, 0x0F,
0xC8, 0x00, 0x03, 0xFF, 0x03, 0x00, 0x03, 0xED, 0x7A, 0x0B, 0x1B, 0xF0, 0x2C, 0x00, 0x03,
0xC0, 0xF1, 0x34, 0x40, 0x0F, 0xCD, 0x00, 0x03, 0xF0, 0x2B, 0x00, 0x03, 0xF0, 0x2D, 0x3B,
0x80, 0x00, 0x01, 0x34, 0x30, 0x0F, 0xCC, 0x00, 0x03, 0xF0, 0x2D, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x03, 0xB8, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
0x01, 0x2F, 0x2F, 0x00, 0x21, 0x00, 0x00, 0x00, 0x2F, 0x00, 0x2F, 0x21, 0x00, 0x00, 0x03,
0x04, 0x01, 0x09, 0x0A, 0x07, 0x0E, 0x0F, 0x10, 0x0D, 0x11, 0x00, 0x0D, 0x03, 0xF4, 0x00,
0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x91, 0xA2, 0xB3, 0xC5, 0x01, 0x45, 0x67, 0xC0,
0x00, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

static void NEARAPI Ac3SPIStart(void)
{
	BoardWriteGPIOReg(SPICLK, FALSE);
	Delay(2);
	BoardWriteGPIOReg(SPIENA, FALSE);
	Delay(2);
}

static void NEARAPI Ac3SPIStop(void)
 {
	Delay(2);
	BoardWriteGPIOReg(SPIENA, TRUE);
}


static BYTE NEARAPI Ac3SPISendByte(BYTE data)
{
	BYTE Val;
	short i;

	Val = data;
	for(i=0; i<8; i++)
	{
		BoardWriteGPIOReg(SPICLK, TRUE);
		Delay(2);
		BoardWriteGPIOReg(SPIDO, (Val & 0x80 ? TRUE : FALSE));
		Delay(2);
		BoardWriteGPIOReg(SPICLK, FALSE);
		Delay(2);
		if(BoardReadGPIOReg(SPIDI))
			Val = (Val << 1) | 0x01;
		else
			Val = (Val << 1);

	}
	return Val;
}

void NEARAPI Ac3SPIReadBack(BYTE command, short numresult, BYTE *result)
{
	short i;

	Ac3SPIStart();	
	Ac3SPISendByte(0x00);
	Ac3SPISendByte(0x00);
	Ac3SPISendByte(0x00);
	Ac3SPISendByte(command);
	Ac3SPISendByte(0x00);
	Ac3SPISendByte(0x00);
	for (i=0;i<numresult-1;i++)
		result[i] = Ac3SPISendByte(0x00);
	result[i] = Ac3SPISendByte(0x80);
	
	Ac3SPISendByte(0x80);
	Ac3SPISendByte(0x80);
	Ac3SPIStop();
	
	return;
}
	
static BYTE NEARAPI Ac3SPISendSeq(short Num, BYTE FAR *Data)
{
	short i;
	BYTE b;

	Ac3SPIStart();

	Ac3SPISendByte(0x00);
	Ac3SPISendByte(0x00);
	Ac3SPISendByte(0x00);

   Ac3SPISendByte(Data[0]);
	for(i=1; i<Num; i++)
	{
     	b = Ac3SPISendByte(Data[i]);
		if ((b  != 0x80) && ((Num-i-1) + 3 != b))
		{
			Delay(2);
			BoardWriteGPIOReg(SPIENA, TRUE);
         DebugPrint((DebugLevelError,"ERROR Programming AC3"));
		}
	}
	Ac3SPISendByte(0x00);
	Ac3SPISendByte(0x80);
	b = Ac3SPISendByte(0x80);
	Ac3SPIStop();

	switch (b & 3)
		{
		case 1:
                        DebugPrint((DebugLevelError, "AC3:Invalid OPCODE!!\n"));
                        break;
		case 2:
                        DebugPrint((DebugLevelError, "AC3:Invalid Parameters!!\n"));
                        break;
      case 3:
                        DebugPrint((DebugLevelError, "AC3:Device not ready!!\n"));
                        break;
		}
	return TRUE;
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : Ac3InitDecoder
//	PARAMS	: None
//	RETURNS	: TRUE on success FALSE otherwise
//
//	PURPOSE	: Initalise AC3 decoder
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL FARAPI Ac3InitDecoder(void)
{
	
	BYTE ver[4];
	DWORD version;
   short i;
	BoardWriteAudio(AUD_BBE, 0x01);
	BoardWriteAudio(AUD_DEM, 0x00);
	BoardWriteAudio(AUD_DIF, 0x01);
	BoardWriteAudio(AUD_DIV, 0x02);
	BoardWriteAudio(AUD_EXT, 0x00);
	BoardWriteAudio(AUD_FOR, 0x00);
	BoardWriteAudio(AUD_ISS, 0x03);
	BoardWriteAudio(AUD_LCA, 0x00);
	BoardWriteAudio(AUD_RCA, 0x00);
	BoardWriteAudio(AUD_LRP, 0x00);
	BoardWriteAudio(AUD_ORD, 0x00);
	BoardWriteAudio(AUD_P18, 0x01);
	BoardWriteAudio(AUD_SCP, 0x00);
	BoardWriteAudio(AUD_SEM, 0x00);
	BoardWriteAudio(AUD_SFR, 0x00);
	BoardWriteAudio(AUD_RST, 0x01);
	BoardWriteEPLD(INCTL, 0x00);
	VideoSoftReset();
  BoardWriteEPLD(AUXCTL, 0x08);
	Delay(100);
	i = 0;
	do
	{
		BoardWriteEPLD(AUXCTL, 0x00);
		Delay(100);
		BoardWriteEPLD(AUXCTL, 0x08);
		Delay(100);
		i++;
		if(i>10)
		{
			DbgPrint("`*****ERROR : AC3 Boot Failed!!");
			break;					
		}
	} while (!Ac3Boot());
	
	BoardWriteEPLD(AUXCTL, 0x08);
	Delay(100);
	Ac3SPIReadBack(0x81, 4, ver);	
	version = ((DWORD)(BYTE)(ver[0]) | ((DWORD)(BYTE)(ver[1]) << 8) | ((DWORD)(BYTE)(ver[2]) << 16) | ((DWORD)(BYTE)(ver[3]) << 24));
  DbgPrint("`AC3 Version = %lx\n", version);
	Ac3SPISendSeq(PARAMSIZE, CfgParams);
	Ac3SPISendSeq(PARAMSIZE, AC3Params);
	Ac3Command(AC3_STOP);
	Ac3Command(AC3_UNMUTE);


	HwCodecAc3BypassMode(audiodecoutmode & KSAUDDECOUTMODE_SPDIFF);

 	pAc3->starving = FALSE;
	pAc3->errorCount=0;
	return TRUE;
}



//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : Ac3SetBypassMode
//	PARAMS	: None
//	RETURNS	: TRUE on success FALSE otherwise
//
//	PURPOSE	: Switch on Bypass Mode
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL Ac3SetBypassMode(void)
{
	Ac3SPISendSeq(PARAMSIZE, CfgParamsBypass);
	Ac3SPISendSeq(PARAMSIZE, AC3Params);
	return TRUE;
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : Ac3SetNormalMode
//	PARAMS	: None
//	RETURNS	: TRUE on success FALSE otherwise
//
//	PURPOSE	: Set the normal decoding mode of AC3
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL Ac3SetNormalMode(void)
{
	Ac3SPISendSeq(PARAMSIZE, CfgParams);
	Ac3SPISendSeq(PARAMSIZE, AC3Params);
	return TRUE;
}





//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : Ac3Reset
//	PARAMS	: None
//	RETURNS	: TRUE on success FALSE otherwise
//
//	PURPOSE	: Reset AC3
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

void Ac3Reset(void)
{

	pAc3->ac3Data = FALSE;
	pAc3->errorCount = 0;
	VideoSeek();
	Ac3Command(AC3_STOP);
	VideoPlay();
	pAc3->state = ac3PowerUp;
}


static void NEARAPI Ac3Command(BYTE command)
{
	Ac3SPISendSeq(1, &command);
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : Ac3SendData
//	PARAMS	: None
//	RETURNS	: TRUE on success FALSE otherwise
//
//	PURPOSE	: Send data to ac3 chip
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL FARAPI Ac3SendData(BYTE FARPTR *Data, DWORD Size)
{
	DWORD i, PoReg, j;
	DWORD TimeOut = 0;
  PoReg = 0x00B00000;
	pAc3->ac3Data = TRUE;

	for(i=0; i<Size; i++)
	{
     while(memInDword(POSTOFFICEREG)&02000000L)
		{
			TimeOut++;
			if(TimeOut > 0xFFFF)
			{
				TRAP
				break;
			}
		}
		j=0;
		while(BoardReadGPIOReg(1))
		{
			j++;
			if(j > 0xFFFFF)
			{
				pAc3->state = ac3ErrorRecover;
				TRAP
				return FALSE;
			}
			// Timeout Condition
		}
		memOutDword(POSTOFFICEREG,PoReg|Data[i]);
		TimeOut = 0;
     while(memInDword(POSTOFFICEREG)&02000000L)
		{
			TimeOut++;
			if(TimeOut > 0xFFFF)
			{
				TRAP
				break;
			}
		}
	}
	Ac3CheckStatus();
	return TRUE;
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : Ac3Boot
//	PARAMS	: None
//	RETURNS	: TRUE on success FALSE otherwise
//
//	PURPOSE	: Boot AC3 chip
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL FARAPI Ac3Boot(void)
{
	short i,num=0;
	BYTE Val, b;
	BOOL fail = FALSE;

	Ac3SPIStart();
	b=Ac3SPISendByte(0);
	b=Ac3SPISendByte(0);
	b=Ac3SPISendByte(0);
	b=Ac3SPISendByte(0);

	num = 0;
	i = 0;
	while(i<ZCODE_SIZE)
	{
		Val = (BYTE)Zcode[i];
		b = Ac3SPISendByte(Val);
		if ((num == 2 ) && (b != 0x05))
		{
			fail = TRUE;
		}
		num++;
//		if(fail)
//			break;
		i++;
	}
	Ac3SPIStop();
	if(fail)
	{
		DPF(("Programming AC3 Failed!!"));
		return FALSE;
	}
	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : Ac3Open
//	PARAMS	: None
//	RETURNS	: AC3 Pointer
//
//	PURPOSE	: init ac3 structure
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

PAC3 Ac3Open(void)
{
	pAc3 = &Ac3;
	pAc3->state = ac3PowerUp;
	return pAc3;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : Ac3GetPTS
//	PARAMS	: None
//	RETURNS	: PTS
//
//	PURPOSE	: Read AC3 PTS
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

DWORD Ac3GetPTS(void)
{
	DWORD pts;
	BYTE	buf[16];
	Ac3SPIReadBack(0x8e, 16, buf);
	pts = (DWORD)buf[15] | (DWORD) buf[14] << 8 | (DWORD) buf[13] << 16 | (DWORD) buf[12] << 24;
	pAc3->status = buf[0] >> 5;
	if(pAc3->status == 2)
	{
		pAc3->status = (buf[1] >> 3) & 7;
 		if(pAc3->state == ac3Playing)
		{
			pAc3->errorCount++;
			DbgPrint("`Error in Ac3 decoding Errno : %ld\n",pAc3->status);
//			Ac3Command(AC3_STOPF);
//			Ac3Command(AC3_PLAY);
//			Ac3Command(AC3_UNMUTE);
		}
		
	}
	return pts;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//						
//	FUNCTION : Ac3Play
//	PARAMS	: None
//	RETURNS	: TRUE on success FALSE otherwise
//
//	PURPOSE	: Play AC3
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL Ac3Play(void)
{
	VideoGetABL();
	switch(pAc3->state)
	{
		case ac3Paused:
			BoardWriteAudio(AUD_PLY, 0x01);
			Ac3Command(AC3_UNMUTE);
			Ac3Command(AC3_PLAY);
			pAc3->state = ac3Playing;
		break;

		case ac3Startup:
		if(pVideo->abl > MINABL)
		{
			BoardWriteAudio(AUD_PLY, 0x01);
			Ac3Command(AC3_UNMUTE);
			Ac3Command(AC3_PLAY);
			pAc3->state = ac3Playing;
		}
		break;

		case ac3Playing:
		break;

		default:
			pAc3->state = ac3Startup;
		break;
	}
	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : Ac3CheckStatus
//	PARAMS	: None
//	RETURNS	: TRUE on success FALSE otherwise
//
//	PURPOSE	: Check device status
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

void Ac3CheckStatus(void)
{
	VideoGetABL();
	switch(pAc3->state)
	{
		case ac3Playing:
			if(pVideo->abl < 20)
			{
				pAc3->state = ac3Starving;
				BoardWriteAudio(AUD_PLY, 0x0);
				Ac3Command(AC3_MUTE);
				Ac3Command(AC3_STOP);
			}
		break;
		case ac3Starving:
			if(pVideo->abl > 30)
			{
				pAc3->state = ac3Playing;
				BoardWriteAudio(AUD_PLY, 0x01);
				Ac3Command(AC3_UNMUTE);
				Ac3Command(AC3_PLAY);
			}

		break;

		case ac3Startup:
			if(pVideo->abl > MINABL)
			{
				BoardWriteAudio(AUD_PLY, 0x01);
				Ac3Command(AC3_UNMUTE);
				Ac3Command(AC3_PLAY);
				pAc3->state = ac3Playing;
			}
		break;

		default:
		break;
	}
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : Ac3Pause
//	PARAMS	: None
//	RETURNS	: TRUE on success FALSE otherwise
//
//	PURPOSE	: Pause
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL Ac3Pause(void)
{
	pAc3->state = ac3Paused;

	Ac3Command(AC3_MUTE);
	Ac3Command(AC3_STOP);	
	BoardWriteAudio(AUD_PLY, 0x00);
	return TRUE;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : Ac3Stop
//	PARAMS	: None
//	RETURNS	: TRUE on success FALSE otherwise
//
//	PURPOSE	: Pause
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL Ac3Stop(void)
{
	pAc3->state = ac3Paused;

	Ac3Command(AC3_STOPF);	
	BoardWriteAudio(AUD_PLY, 0x00);
	return TRUE;
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//
//	FUNCTION : Ac3Close
//	PARAMS	: None
//	RETURNS	: TRUE on success FALSE otherwise
//
//	PURPOSE	: Close
//
//
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

BOOL Ac3Close(void)
{
	return TRUE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\board.h ===
#ifndef __BOARD_H
#define __BOARD_H
//----------------------------------------------------------------------------
// BOARD.H
//----------------------------------------------------------------------------
// Description : small description of the goal of the module
//----------------------------------------------------------------------------
// Copyright SGS Thomson Microelectronics  !  Version alpha  !  Jan 1st, 1995
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                               Include files
//----------------------------------------------------------------------------
#include "stdefs.h"

//----------------------------------------------------------------------------
//                               Exported Types
//----------------------------------------------------------------------------
typedef UCHAR  (* FNREAD8)     (PUCHAR  Address);
typedef USHORT (* FNREAD16)    (PUSHORT Address);
typedef ULONG  (* FNREAD32)    (PULONG  Address);
typedef VOID   (* FNWRITE8)    (PUCHAR  Address, UCHAR Value);
typedef VOID   (* FNWRITE16)   (PUSHORT Address, USHORT Value);
typedef VOID   (* FNWRITE32)   (PULONG  Address,  ULONG Value);
typedef VOID   (* FNSENDBLK8)  (PUCHAR  Address,  PUCHAR Buffer,  ULONG Size);
typedef VOID   (* FNSENDBLK16) (PUSHORT Address,  PUSHORT Buffer, ULONG Size);
typedef VOID   (* FNSENDBLK32) (PULONG  Address,  PULONG Buffer,  ULONG Size);
typedef VOID   (* FNWAIT)      (ULONG   Milliseconds);

//----------------------------------------------------------------------------
//                             Exported Variables
//----------------------------------------------------------------------------
extern WORD gLocalIOBaseAddress;
extern WORD gPCI9060IOBaseAddress;

extern FNREAD8     BoardRead8;
extern FNREAD16    BoardRead16;
extern FNREAD32    BoardRead32;
extern FNWRITE8    BoardWrite8;
extern FNWRITE16   BoardWrite16;
extern FNWRITE32   BoardWrite32;
extern FNSENDBLK8  BoardSendBlock8;
extern FNSENDBLK16 BoardSendBlock16;
extern FNSENDBLK32 BoardSendBlock32;
extern FNWAIT      BoardWaitMicroseconds;

//----------------------------------------------------------------------------
//                             Exported Constants
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Exported Functions
//----------------------------------------------------------------------------
#define Read8(Address)                     BoardRead8((PUCHAR)(Address))
#define Read16(Address)                    BoardRead16((PUSHORT)(Address))
#define Read32(Address)                    BoardRead32((PULONG)(Address))
#define Write8(Address,  Value)            BoardWrite8((PUCHAR)(Address),   Value)
#define Write16(Address, Value)            BoardWrite16((PUSHORT)(Address), Value)
#define Write32(Address, Value)            BoardWrite32((PULONG)(Address),  Value)
#define SendBlock8(Address,  Buffer, Size) BoardSendBlock8((PUCHAR)(Address),   (PUCHAR)(Buffer),  (ULONG)(Size))
#define SendBlock16(Address, Buffer, Size) BoardSendBlock16((PUSHORT)(Address), (PUSHORT)(Buffer), (ULONG)(Size))
#define SendBlock32(Address, Buffer, Size) BoardSendBlock32((PULONG)(Address),  (PULONG)(Buffer),  (ULONG)(Size))
#define MicrosecondsDelay(Delay)           BoardWaitMicroseconds(Delay)

//----------------------------------------------------------------------------
// One line function description (same as in .C)
//----------------------------------------------------------------------------
// In     :
// Out    :
// InOut  :
// Global :
// Return :
//----------------------------------------------------------------------------
BOOL BoardInit(WORD 			 lLocalIOBaseAddress,
							 WORD 			 lPCI9060IOBaseAddress,
							 FNREAD8     lRead8,
							 FNREAD16    lRead16,
							 FNREAD32    lRead32,
							 FNWRITE8    lWrite8,
							 FNWRITE16   lWrite16,
							 FNWRITE32   lWrite32,
							 FNSENDBLK8  lSendBlock8,
							 FNSENDBLK16 lSendBlock16,
							 FNSENDBLK32 lSendBlock32,
							 FNWAIT      lWaitMicroseconds);
VOID BoardHardReset(VOID);
BYTE BoardAudioRead(BYTE Register);
VOID BoardAudioWrite(BYTE Register, BYTE Value);
VOID BoardAudioSend(PVOID Buffer, DWORD Size);
VOID BoardAudioSetSamplingFrequency(DWORD Frequency);
BYTE BoardVideoRead(BYTE Register);
VOID BoardVideoWrite(BYTE Register, BYTE Value);
VOID BoardVideoSend(PVOID Buffer, DWORD Size);
VOID BoardVideoSetDisplayMode(BYTE Mode);
VOID BoardEnterInterrupt(VOID);
VOID BoardLeaveInterrupt(VOID);

//------------------------------- End of File --------------------------------
#endif // #ifndef __BOARD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\board.c ===
//----------------------------------------------------------------------------
// MODULENAME.C
//----------------------------------------------------------------------------
// Description : small description of the goal of the module
//----------------------------------------------------------------------------
// Copyright SGS Thomson Microelectronics  !  Version alpha  !  Jan 1st, 1995
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                               Include files
//----------------------------------------------------------------------------
#include "stdefs.h"
#include "board.h"
#include "aal.h"
#include "pci9060.h"
#include "stv0116.h"
#include "icd2051.h"
#include "debug.h"

//----------------------------------------------------------------------------
//                            Private Constants
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                              Private Types
//----------------------------------------------------------------------------
typedef BYTE (* FNAREAD)  (BYTE Register);
typedef BYTE (* FNVREAD)  (BYTE Register);
typedef VOID (* FNAWRITE) (BYTE Register, BYTE Value);
typedef VOID (* FNVWRITE) (BYTE Register, BYTE Value);

//----------------------------------------------------------------------------
//                             GLOBAL Variables
//----------------------------------------------------------------------------
WORD gLocalIOBaseAddress;
WORD gPCI9060IOBaseAddress;

static int DefaultProcessing(int);

//---- Basic i/o functions
FNREAD8     BoardRead8            = (FNREAD8)DefaultProcessing;
FNREAD16    BoardRead16           = (FNREAD16)DefaultProcessing;
FNREAD32    BoardRead32           = (FNREAD32)DefaultProcessing;
FNWRITE8    BoardWrite8           = (FNWRITE8)DefaultProcessing;
FNWRITE16   BoardWrite16          = (FNWRITE16)DefaultProcessing;
FNWRITE32   BoardWrite32          = (FNWRITE32)DefaultProcessing;
FNSENDBLK8  BoardSendBlock8       = (FNSENDBLK8)DefaultProcessing;
FNSENDBLK16 BoardSendBlock16      = (FNSENDBLK16)DefaultProcessing;
FNSENDBLK32 BoardSendBlock32      = (FNSENDBLK32)DefaultProcessing;

//---- delay function
FNWAIT      BoardWaitMicroseconds = (FNWAIT)DefaultProcessing;

//---- Audio/Video registers r/w functions
FNAREAD  STiAudioIn  = (FNAREAD)DefaultProcessing;
FNVREAD  STiVideoIn  = (FNVREAD)DefaultProcessing;
FNAWRITE STiAudioOut = (FNAWRITE)DefaultProcessing;
FNVWRITE STiVideoOut = (FNVWRITE)DefaultProcessing;

//----------------------------------------------------------------------------
//                     Private GLOBAL Variables (static)
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                     Functions (statics one are private)
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
VOID BoardHardReset(VOID)
{
	PCI9060DisableIRQ();
	STV0116HardReset();
	STi3520HardReset();
	ALTERAClearPendingAudioIT();
	PCI9060EnableIRQ();
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
BYTE BoardAudioRead(BYTE Register)
{
	return STiAudioIn(Register);
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
VOID BoardAudioWrite(BYTE Register, BYTE Value)
{
	STiAudioOut(Register, Value);
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
VOID BoardAudioSend(PVOID Buffer, DWORD Size)
{
	DebugAssert(Buffer != NULL);

	STiCDAudioOutBlock((PBYTE)Buffer, Size);
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
VOID BoardAudioSetSamplingFrequency(DWORD Frequency)
{
	switch (Frequency) {
	case 48000U :
		ICD2051SendWord(TRUE, 0x00008CE93UL); // 32 * 48.0KHz = 1.536 MHz
		break;
	case 44100U :
		ICD2051SendWord(TRUE, 0x0000576A6UL); // 32 * 44.1KHz = 1.4112MHz
		break;
	case 32000U :
		ICD2051SendWord(TRUE, 0x000156F19UL); // 32 * 32.0KHz = 1.024 MHz
		break;
	default :
		DebugPrint((DebugLevelFatal, "Unknown case !"));
	}
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
BYTE BoardVideoRead(BYTE Register)
{
	return STiVideoIn(Register);
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
VOID BoardVideoWrite(BYTE Register, BYTE Value)
{
	STiVideoOut(Register, Value);
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
VOID BoardVideoSend(PVOID Buffer, DWORD Size)
{
	const  BYTE MinSendable = 4;    // min nbr of bytes we can send at a time
	static BYTE RemainingBytes = 0; // nbr of bytes not sent last time
	static BYTE RemainingData[4];   // remaining data
	BYTE        ToComplete;         // nbr of bytes needed to have MinSendable bytes
	DWORD       ToSend;             // nbr of bytes we can send
	BYTE        i;

	DebugAssert(Buffer != NULL);

	//---- If there is something not send
	if (RemainingBytes != 0) {
		ToComplete = MinSendable - RemainingBytes;
		//---- Could we complete remaining data to send them
		if (ToComplete < Size) {
			//---- Complete data
			for (i = 0; i < ToComplete; i++)
				RemainingData[RemainingBytes + i] = *(((PBYTE)Buffer)++);

			//---- Send data
			STiCDVideoOutBlock((PDWORD)RemainingData, 1);
			Size = Size - ToComplete;
			RemainingBytes = 0;
		}
	}

	//---- If there is something to send
	if (Size > MinSendable) {
		ToSend = (Size / MinSendable) * MinSendable;
		STiCDVideoOutBlock((PDWORD)Buffer, ToSend / MinSendable);
		Size = Size - ToSend;

		Buffer = ((PBYTE)Buffer) + ToSend;
	}

	//---- If there is something that will remain
	if (Size != 0) {
		for (i = 0; i < Size; i++)
			RemainingData[i] = *(((PBYTE)Buffer)++);
		RemainingBytes = Size;
//		DebugPrint((DebugLevelInfo, "Next CD send will not be aligned on a 32 bit boundary !"));
	}
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
VOID BoardVideoSetDisplayMode(BYTE Mode)
{
	STV0116Init(Mode);
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
VOID BoardEnterInterrupt(VOID)
{
	ALTERAClearPendingAudioIT();
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
VOID BoardLeaveInterrupt(VOID)
{
}

//----------------------------------------------------------------------------
// Default processing for functions pointers
//----------------------------------------------------------------------------
static int DefaultProcessing(int Dummy)
{
	Dummy = Dummy;
	HostDisplay(DISPLAY_FASTEST, "You should call BoardInit() before calling this function !\r\n");

	return 0;
}

//----------------------------------------------------------------------------
// Maps basic i/o functions to the one given by the user
//----------------------------------------------------------------------------
BOOL BoardInit(WORD 			 lLocalIOBaseAddress,
							 WORD 			 lPCI9060IOBaseAddress,
							 FNREAD8     lRead8,
							 FNREAD16    lRead16,
							 FNREAD32    lRead32,
							 FNWRITE8    lWrite8,
							 FNWRITE16   lWrite16,
							 FNWRITE32   lWrite32,
							 FNSENDBLK8  lSendBlock8,
							 FNSENDBLK16 lSendBlock16,
							 FNSENDBLK32 lSendBlock32,
							 FNWAIT      lWaitMicroseconds)
{
	DebugAssert(lLocalIOBaseAddress != 0);
	DebugAssert(lPCI9060IOBaseAddress != 0);
	DebugAssert(lRead8 != NULL);
	DebugAssert(lRead16 != NULL);
	DebugAssert(lRead32 != NULL);
	DebugAssert(lWrite8 != NULL);
	DebugAssert(lWrite16 != NULL);
	DebugAssert(lWrite32 != NULL);
	DebugAssert(lSendBlock8 != NULL);
	DebugAssert(lSendBlock16 != NULL);
	DebugAssert(lSendBlock32 != NULL);
	DebugAssert(lWaitMicroseconds != NULL);
	DebugAssert(STiAudioInV10 != NULL);
	DebugAssert(STiAudioOutV10 != NULL);
	DebugAssert(STiVideoInV10 != NULL);
	DebugAssert(STiVideoOutV10 != NULL);
	DebugAssert(STiAudioInV11M != NULL);
	DebugAssert(STiAudioOutV11M != NULL);
	DebugAssert(STiVideoInV11M != NULL);
	DebugAssert(STiVideoOutV11M != NULL);

	//---- Affect base addresses
	gLocalIOBaseAddress   = lLocalIOBaseAddress;
	gPCI9060IOBaseAddress = lPCI9060IOBaseAddress;

	//---- Init basic i/o functions
	BoardRead8            = lRead8;
	BoardRead16           = lRead16;
	BoardRead32           = lRead32;
	BoardWrite8           = lWrite8;
	BoardWrite16          = lWrite16;
	BoardWrite32          = lWrite32;
	BoardSendBlock8       = lSendBlock8;
	BoardSendBlock16      = lSendBlock16;
	BoardSendBlock32      = lSendBlock32;

	//---- Init delay function
	BoardWaitMicroseconds = lWaitMicroseconds;

	//---- Init audio r/w & video r/w funcs depending on Altera layout revision
	if ((ALTERAGetLayoutRevisionHigh() == 1) &&
			(ALTERAGetLayoutRevisionLow()  == 0)) { // revison 1.0
		STiAudioIn  = STiAudioInV10;
		STiAudioOut = STiAudioOutV10;
		STiVideoIn  = STiVideoInV10;
		STiVideoOut = STiVideoOutV10;
	}
	else { // all others (1.1 and More) inluding alpha (0.0) / beta (0.X)
		STiAudioIn  = STiAudioInV11M;
		STiAudioOut = STiAudioOutV11M;
		STiVideoIn  = STiVideoInV11M;
		STiVideoOut = STiVideoOutV11M;
	}

	//---- To be sure no IRQ's will go to the PC during registers test
	PCI9060DisableIRQ();

	//---- Test PLX registers
	if (!PCI9060TestRegisters()) {
		return FALSE;
	}

	//---- Test Altera
	if (!ALTERATestRegisters()) {
		return FALSE;
	}

	return TRUE;
}

//------------------------------- End of File --------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\aal.h ===
#ifndef __MODULENAME_H
#define __MODULENAME_H
//----------------------------------------------------------------------------
// MODULENAME.H
//----------------------------------------------------------------------------
// Description : small description of the goal of the module
//----------------------------------------------------------------------------
// Copyright SGS Thomson Microelectronics  !  Version alpha  !  Jan 1st, 1995
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                               Include files
//----------------------------------------------------------------------------
#include "stdefs.h"

//----------------------------------------------------------------------------
//                               Exported Types
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Exported Variables
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Exported Constants
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Exported Functions
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// One line function description (same as in .C)
//----------------------------------------------------------------------------
// In     :
// Out    :
// InOut  :
// Global :
// Return :
//----------------------------------------------------------------------------
BYTE ALTERAGetLayoutRevisionHigh(VOID);
BYTE ALTERAGetLayoutRevisionLow(VOID);
BYTE ALTERAGetRevisionHigh(VOID);
BYTE ALTERAGetRevisionLow(VOID);
BOOL ALTERATestRegisters(VOID);
VOID ALTERAClearPendingAudioIT(VOID);

VOID STV0116HardReset(VOID);

VOID ICD2051WriteCMD(BOOL Data, BOOL ClockA, BOOL ClockB);

VOID I2CWriteCMD(BOOL sda, BOOL scl);

VOID STi3520HardReset(VOID);
BYTE STiAudioInV10(BYTE Register);
BYTE STiVideoInV10(BYTE Register);
VOID STiAudioOutV10(BYTE Register, BYTE Value);
VOID STiVideoOutV10(BYTE Register, BYTE Value);
BYTE STiAudioInV11M(BYTE Register);
BYTE STiVideoInV11M(BYTE Register);
VOID STiAudioOutV11M(BYTE Register, BYTE Value);
VOID STiVideoOutV11M(BYTE Register, BYTE Value);
VOID STiCDVideoOut(DWORD Value);
VOID STiCDAudioOut(BYTE Value);
VOID STiCDVideoOutBlock(PDWORD pBuffer, WORD Count);
VOID STiCDAudioOutBlock(PBYTE pBuffer, WORD Count);
VOID STiAudioClearPendingIT(VOID);

VOID PCI9060Out8(WORD Register, BYTE Value);
BYTE PCI9060In8(WORD Register);
VOID PCI9060Out32(WORD Register, DWORD Value);
DWORD PCI9060In32(WORD Register);

VOID FIFOHardReset(VOID);
VOID FIFOSetThreshold(BYTE Threshold);
BYTE FIFOGetStatus(VOID);
VOID FIFOClearPendingIT(VOID);

//------------------------------- End of File --------------------------------
#endif // #ifndef __MODULENAME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\aal.c ===
//----------------------------------------------------------------------------
// AAL.C (Architecture Abstraction Layer)
//----------------------------------------------------------------------------
// Description : make chip access independant of the hardware architecture
//----------------------------------------------------------------------------
// Copyright SGS Thomson Microelectronics  !  Version alpha  !  Jan 1st, 1995
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                               Include files
//----------------------------------------------------------------------------
#include "stdefs.h"
#include "debug.h"
#include "error.h"
#include "board.h"

#pragma inline

//----------------------------------------------------------------------------
//                            Private Constants
//----------------------------------------------------------------------------
//---- Register addresses                                        type  bits
#define VIDEOREG   0x0000 // STi3520 Video register base          RW     8
#define AUDIOREG   0x0400 // STi3520 Audio register base          RW     8
#define CLRITFIFO  0x0800 // ALTERA register to clear pending it   W     8
#define CLRITAUDIO 0x0804 // ALTERA register to clear pending it	 W     8
#define RESETREG   0x0808 // ALTERA register to reset chips       RW     4
#define REVISION   0x080C // ALTERA register to get revision      R      8
#define ICD2051    0x0810 // ALTERA register for ICD2051 access   RW     2
#define I2C        0x0820 // ALTERA register for I2C bus access   RW     2
#define CDVIDEO    0x0830 // STi3520 Video Compress Data input     W     8
#define CDAUDIO    0x0840 // STi3520 Audio Compress Data input     W     8
#define FIFOSTATUS 0x0844 // FIFO flags                            R     4

//---- Register bit description
//---- ICD2051
#define SCLKA      0x01   // SCLKA signal
#define SCLKB      0x02   // SCLKB signal
#define DATA       0x04   // DATA  signal

//---- I2C
#define SDA        0x01   // SDA signal (Data)
#define SCL        0x02   // SCL signal (Clock)

//---- RESET
#define RST3520    0x01   // STi3520 Reset
#define RST9060    0x02   // PCI9060 Reset
#define RST0116    0x04   // STV0116 Reset
#define RSTFIFO    0x08   // FIFO    Reset

//---- FIFOSTATUS
#define AEMPTY     0x01   // Almost Empty flag
#define AFULL      0x02   // Almost Full flag
#define EMPTY      0x04   // Empty flag
#define FULL       0x08   // Full flag

//----------------------------------------------------------------------------
//                              Private Types
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                              GLOBAL Variables
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                     Private GLOBAL Variables (static)
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                     Functions (statics one are private)
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// Get the high value of the Layout revision (for X.Y gives X)
//----------------------------------------------------------------------------
BYTE ALTERAGetLayoutRevisionHigh(VOID)
{
	return (Read8(gLocalIOBaseAddress + REVISION) & 0x0C) >> 2;
}

//----------------------------------------------------------------------------
// Get the low value of the Layout revision (for X.Y gives Y)
//----------------------------------------------------------------------------
BYTE ALTERAGetLayoutRevisionLow(VOID)
{
	return Read8(gLocalIOBaseAddress + REVISION) & 0x03;
}

//----------------------------------------------------------------------------
// Get the high value of the ALTERA revision (for X.Y gives X)
//----------------------------------------------------------------------------
BYTE ALTERAGetRevisionHigh(VOID)
{
	return (Read8(gLocalIOBaseAddress + REVISION) & 0xC0) >> 6;
}

//----------------------------------------------------------------------------
// Get the low value of the ALTERA revision (for X.Y gives Y)
//----------------------------------------------------------------------------
BYTE ALTERAGetRevisionLow(VOID)
{
	return (Read8(gLocalIOBaseAddress + REVISION) & 0x30) >> 4;
}

//----------------------------------------------------------------------------
// Test ALTERA registers
//----------------------------------------------------------------------------
BOOL ALTERATestRegisters(VOID)
{
	//---- Test RESET/ICD2051 registers
	Write8(gLocalIOBaseAddress + RESETREG, 0xAA); // be carefull bit 2 must always be set !
	Write8(gLocalIOBaseAddress + ICD2051, 0x55);
	if ((Read8(gLocalIOBaseAddress + RESETREG) & 0x0F) != 0x0A)
		goto Error;
	if ((Read8(gLocalIOBaseAddress + ICD2051) & 0x07) != 0x05)
		goto Error;

	//---- Test I2C/ICD2051 registers
	Write8(gLocalIOBaseAddress + I2C, 0xAA);
	Write8(gLocalIOBaseAddress + ICD2051, 0x55);
	if ((Read8(gLocalIOBaseAddress + I2C) & 0x03) != 0x02)
		goto Error;
	if ((Read8(gLocalIOBaseAddress + ICD2051) & 0x07) != 0x05)
		goto Error;

	//---- Go back to default values
	Write8(gLocalIOBaseAddress + RESETREG, 0x0F);
	Write8(gLocalIOBaseAddress + ICD2051, 0x00);
	Write8(gLocalIOBaseAddress + I2C, 0x03);

	return TRUE;

Error :
	DebugPrint((DebugLevelError, "Test of Altera registers failed !"));
	SetErrorCode(ERR_ALTERA_REG_TEST_FAILED);
	return FALSE;
}

//----------------------------------------------------------------------------
// Tells ALTERA audio interrupt has been processed
//----------------------------------------------------------------------------
VOID ALTERAClearPendingAudioIT(VOID)
{
	Write8(gLocalIOBaseAddress + CLRITAUDIO, 0);
}
/*
//----------------------------------------------------------------------------
// Tells ALTERA fifo interrupt has been processed
//----------------------------------------------------------------------------
VOID FIFOClearPendingFifoIT(VOID)
{
	Write8(gLocalIOBaseAddress + CLRITFIFO, 0);
}
*/
/****************************************************************************/
/****************************************************************************/
/****************************************************************************/

//----------------------------------------------------------------------------
// Make a hard reset of the digital video encoder
//----------------------------------------------------------------------------
VOID STV0116HardReset(VOID)
{
	BYTE Temp;

	Temp = Read8(gLocalIOBaseAddress + RESETREG);
	Write8(gLocalIOBaseAddress + RESETREG, Temp | RST0116);
	Write8(gLocalIOBaseAddress + RESETREG, Temp & ~RST0116);
	MicrosecondsDelay(1000); // ??????
	Write8(gLocalIOBaseAddress + RESETREG, Temp | RST0116);
}

/****************************************************************************/
/****************************************************************************/
/****************************************************************************/

//----------------------------------------------------------------------------
// Write a command to the external PLL
//----------------------------------------------------------------------------
VOID ICD2051WriteCMD(BOOL Data, BOOL ClockA, BOOL ClockB)
{
	DebugAssert(!(ClockA && ClockB));

	if (ClockA) {
		if (Data)
			Write8(gLocalIOBaseAddress + ICD2051, SCLKA | DATA);
		else
			Write8(gLocalIOBaseAddress + ICD2051, SCLKA);
	}
	else if (ClockB) {
		if (Data)
			Write8(gLocalIOBaseAddress + ICD2051, SCLKB | DATA);
		else
			Write8(gLocalIOBaseAddress + ICD2051, SCLKB);
	}
	else {
		if (Data)
			Write8(gLocalIOBaseAddress + ICD2051, DATA);
		else
			Write8(gLocalIOBaseAddress + ICD2051, 0);
	}
}

/****************************************************************************/
/****************************************************************************/
/****************************************************************************/

//----------------------------------------------------------------------------
// Write a command on the IC bus
//----------------------------------------------------------------------------
VOID I2CWriteCMD(BOOL sda, BOOL scl)
{
	if (sda && scl)
		Write8(gLocalIOBaseAddress + I2C, SDA | SCL); // SDA = 1, SCL = 1
	else if (!sda && !scl)
		Write8(gLocalIOBaseAddress + I2C, 0);         // SDA = 0, SCL = 0
	else if (sda && !scl)
		Write8(gLocalIOBaseAddress + I2C, SDA);       // SDA = 1, SCL = 0
	else if (!sda && scl)
		Write8(gLocalIOBaseAddress + I2C, SCL);       // SDA = 0, SCL = 1
	else
		DebugPrint((DebugLevelFatal, "Case not possible !"));
	MicrosecondsDelay(1000);
}

/****************************************************************************/
/****************************************************************************/
/****************************************************************************/

//----------------------------------------------------------------------------
// Make a hard reset of the STi3520(A)
//----------------------------------------------------------------------------
VOID STi3520HardReset(VOID)
{
	BYTE Temp;

	Temp = Read8(gLocalIOBaseAddress + RESETREG);
	Write8(gLocalIOBaseAddress + RESETREG, Temp | RST3520);
	Write8(gLocalIOBaseAddress + RESETREG, Temp & ~RST3520);
	MicrosecondsDelay(1000); //??????
	Write8(gLocalIOBaseAddress + RESETREG, Temp | RST3520);
}

//----------------------------------------------------------------------------
// Read a byte (8 bits) on audio chip
//----------------------------------------------------------------------------
BYTE STiAudioInV10(BYTE Register)
{
	WORD NewAddress;

	NewAddress = (((WORD)Register & 0x03) << 8) | (WORD)Register;
	return Read8(gLocalIOBaseAddress + AUDIOREG + NewAddress);
}

//----------------------------------------------------------------------------
// Read a byte (8 bits) on audio chip
//----------------------------------------------------------------------------
BYTE STiAudioInV11M(BYTE Register)
{
	return Read8(gLocalIOBaseAddress + AUDIOREG + (Register << 2));
}

//----------------------------------------------------------------------------
// Read a byte (8 bits) on video chip
//----------------------------------------------------------------------------
BYTE STiVideoInV10(BYTE Register)
{
	WORD NewAddress;

	NewAddress = (((WORD)Register & 0x03) << 8) | (WORD)Register;
	return Read8(gLocalIOBaseAddress + VIDEOREG + NewAddress);
}

//----------------------------------------------------------------------------
// Read a byte (8 bits) on video chip
//----------------------------------------------------------------------------
BYTE STiVideoInV11M(BYTE Register)
{
	return Read8(gLocalIOBaseAddress + VIDEOREG + (Register <<2));
}

//----------------------------------------------------------------------------
// Write a byte (8 bits) on audio chip
//----------------------------------------------------------------------------
VOID STiAudioOutV10(BYTE Register, BYTE Value)
{
	WORD NewAddress;

	NewAddress = (((WORD)Register & 0x03) << 8) | (WORD)Register;
	Write8(gLocalIOBaseAddress + AUDIOREG + NewAddress, Value);
}

//----------------------------------------------------------------------------
// Write a byte (8 bits) on audio chip
//----------------------------------------------------------------------------
VOID STiAudioOutV11M(BYTE Register, BYTE Value)
{
	Write8(gLocalIOBaseAddress + AUDIOREG + (Register << 2), Value);
}

//----------------------------------------------------------------------------
// Write a byte (8 bits) on video chip
//----------------------------------------------------------------------------
VOID STiVideoOutV10(BYTE Register, BYTE Value)
{
	WORD NewAddress;

	NewAddress = (((WORD)Register & 0x03) << 8) | (WORD)Register;
	Write8(gLocalIOBaseAddress + VIDEOREG + NewAddress, Value);
}

//----------------------------------------------------------------------------
// Write a byte (8 bits) on video chip
//----------------------------------------------------------------------------
VOID STiVideoOutV11M(BYTE Register, BYTE Value)
{
	Write8(gLocalIOBaseAddress + VIDEOREG + (Register << 2), Value);
}

//----------------------------------------------------------------------------
// Write a dword (32 bits) to the Compressed Data video interface
//----------------------------------------------------------------------------
VOID STiCDVideoOut(DWORD Value)
{
	Write32(gLocalIOBaseAddress + CDVIDEO, Value);
}

//----------------------------------------------------------------------------
// Write a byte (8 bits) to the Compressed Data audio interface
//----------------------------------------------------------------------------
VOID STiCDAudioOut(BYTE Value)
{
	Write8(gLocalIOBaseAddress + CDAUDIO, Value);
}

//----------------------------------------------------------------------------
// Send a block of CD Video using 32 bit writes (Count is in nbr of DWORD)
//----------------------------------------------------------------------------
VOID STiCDVideoOutBlock(PDWORD pBuffer, WORD Count)
{
	DebugAssert(pBuffer != NULL);
	DebugAssert(Count != 0);

	SendBlock32(gLocalIOBaseAddress + CDVIDEO, pBuffer, Count);
}

//----------------------------------------------------------------------------
// Send a block of compressed data audio using 8 bits write
//----------------------------------------------------------------------------
VOID STiCDAudioOutBlock(PBYTE pBuffer, WORD Count)
{
	DebugAssert(pBuffer != NULL);

	SendBlock8(gLocalIOBaseAddress + CDAUDIO, pBuffer, Count);
}

/****************************************************************************/
/****************************************************************************/
/****************************************************************************/

//----------------------------------------------------------------------------
// Make a hard reset of the PLX PCI9060 (be careful -> will reload the eeprom)
//----------------------------------------------------------------------------
VOID PCI9060HardReset(VOID)
{
	BYTE Temp;

	Temp = Read8(gLocalIOBaseAddress + RESETREG);
	Write8(gLocalIOBaseAddress + RESETREG, Temp | RST9060);
	Write8(gLocalIOBaseAddress + RESETREG, Temp & ~RST9060);
	MicrosecondsDelay(1000); //???????????
	Write8(gLocalIOBaseAddress + RESETREG, Temp | RST9060);
}

//----------------------------------------------------------------------------
// Write an 8 bit value to a register
//----------------------------------------------------------------------------
VOID PCI9060Out8(WORD Register, BYTE Value)
{
	Write8(gPCI9060IOBaseAddress + Register, Value);
}

//----------------------------------------------------------------------------
// Read an 8 bit value from a register
//----------------------------------------------------------------------------
BYTE PCI9060In8(WORD Register)
{
	return Read8(gPCI9060IOBaseAddress + Register);
}

//----------------------------------------------------------------------------
// Write a 32 bit value to a register
//----------------------------------------------------------------------------
VOID PCI9060Out32(WORD Register, DWORD Value)
{
	Write32(gPCI9060IOBaseAddress + Register, Value);
}

//----------------------------------------------------------------------------
// Read a 32 bit value from a register
//----------------------------------------------------------------------------
DWORD PCI9060In32(WORD Register)
{
	return Read32(gPCI9060IOBaseAddress + Register);
}

/****************************************************************************/
/****************************************************************************/
/****************************************************************************/
/*
//----------------------------------------------------------------------------
// Make a hard reset of the external audio fifo
//----------------------------------------------------------------------------
VOID FIFOHardReset(VOID)
{
	BYTE Temp;

	Temp = Read8(gLocalIOBaseAddress + RESETREG) | RSTFIFO;
	Write8(gLocalIOBaseAddress + RESETREG, Temp);
	Write8(gLocalIOBaseAddress + RESETREG, Temp & ~RSTFIFO);
//	MicrosecondsDelay(??);
	Write8(gLocalIOBaseAddress + RESETREG, Temp);
}

//----------------------------------------------------------------------------
// Set the thresholds of the fifo
//----------------------------------------------------------------------------
VOID FIFOSetThreshold(BYTE Threshold)
{
	BYTE Temp;

	Temp = Read8(gLocalIOBaseAddress + RESETREG) | RSTFIFO;
	Write8(gLocalIOBaseAddress + RESETREG, Temp);
	Write8(gLocalIOBaseAddress + RESETREG, Temp & ~RSTFIFO);
	Write8(gLocalIOBaseAddress + CDAUDIO, Threshold);
//	MicrosecondsDelay(??);
	Write8(gLocalIOBaseAddress + RESETREG, Temp);
}

//----------------------------------------------------------------------------
// Get the status of the fifo
//----------------------------------------------------------------------------
BYTE FIFOGetStatus(VOID)
{
	return Read8(gLocalIOBaseAddress + FIFOSTATUS);
}
*/

//------------------------------- End of File --------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\demux.h ===
/******************************************/
/*				 AV35DEMU.H               */
/******************************************/
#ifndef	DEMUX_INCLUDED
#define DEMUX_INCLUDED

#include <dir.h> //MAXPATH
#include "stdefs.h"



/* Demux related messages */


typedef struct
{
	U8      Mpeg1or2;          // 0 if not known 1 if Mpeg1 2 if Mpeg2
	char    FileName[MAXPATH];
	U16     ErrorMsg;
	U8      NbZero;            // Number of zeroes found since last detection
	BOOLEAN EndOfFile;         // If True end of file reached
	BOOLEAN EndOfStream;       // If True end of Stream reached
	U16     StreamType;
	U16     StilToSend;        // Number of bytes of current packet still to be sent
	P_U8    Buffer;            // Start address of Cd Buffer
	U16     ByteCounter;       // Byte Counter
	U16     BufferLevel;       // Number of bytes still in buffer
	U16     ParserState;       // Current state of the parsing
	BOOLEAN ValidStream;
/* Following Variables are Only used in Case of dual PES input*/
	char    FirstFileName[MAXPATH];
	char    SecondFileName[MAXPATH];
	PCHAR   VideoFileName;
	PCHAR		AudioFileName;
	WORD	  NbFiles;
	BOOLEAN EndOfAudioFile;         // If True end of Audio file reached
	BOOLEAN EndOfVideoFile;         // If True end of Video file reached
	P_U8    AudioBuffer;            // Start address of Audio Cd Buffer
	U16     AudioByteCounter;       // Audio Counter
	U16     AudioBufferLevel;       // Number of bytes still in Audio buffer
	P_U8    VideoBuffer;            // Start address of Audio Cd Buffer
	U16     VideoByteCounter;       // Video Byte Counter
	U16     VideoBufferLevel;       // Number of bytes still in Video buffer
}DEMUX, FAR *PDEMUX;

typedef struct
{
	P_U8 		CdBuffer;   // Compressed data buffer
	U16 		Counter;    // gives position of buffer to be stored
	U16 		StilToSend; // Amount of data still to be sent to decoder

	P_U8 		AudioCdBuffer;   // Compressed data buffer
	U16 		AudioCounter;    // gives position of buffer to be stored
	U16 		AudioStilToSend; // Amount of data still to be sent to decoder

	P_U8 		VideoCdBuffer;   // Compressed data buffer
	U16 		VideoCounter;    // gives position of buffer to be stored
	U16 		VideoStilToSend; // Amount of data still to be sent to decoder

	U16 		CurStd;     // Current Sustem Target Decoder
	U32 		VidPts;     // holds Video Pts detected in bitstream
	BOOLEAN ValidPts;   // Pts Valid or not
} PARSINFO, FAR *PPARSINFO;  // Information returned by parser


VOID DemuxOpen(PDEMUX, PCHAR Fname1, PCHAR Fname2, WORD NbFiles);//Constructor
VOID DemuxClose(PDEMUX); //Desteuctor

PCHAR   DemuxGetFileName(PDEMUX);
BOOLEAN DemuxSearchStartCode(PDEMUX , U16 data);//Starts Demux
U16	    DemuxGo(PDEMUX , PPARSINFO);
BOOLEAN DemuxDetectStreamType(PDEMUX); //Identiies Stream Type

U16	    DemuxGetErrorMsg(PDEMUX); 	/* returns the decoding errors(if any) */
U16     DemuxGetStreamType(PDEMUX);  // returns stream type
U8      DemuxGetState(PDEMUX);
BOOLEAN DemuxAnalyseHeader(PDEMUX, PPARSINFO);//Process Header Analysis
U16     DemuxParsePacket(PDEMUX, PPARSINFO);
VOID    DemuxRewind(PDEMUX);

// Temp Add
U32 DemuxCurPos(void);
U32 DemuxMediaLength(void);
// Temp Add

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\common.h ===
#ifndef __COMMON_H
#define __COMMON_H
//----------------------------------------------------------------------------
// COMMON.H
//----------------------------------------------------------------------------
// Description : small description of the goal of the module
//----------------------------------------------------------------------------
// Copyright SGS Thomson Microelectronics  !  Version alpha  !  Jan 1st, 1995
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                               Include files
//----------------------------------------------------------------------------
#include "stdefs.h"
#include "board.h"
#include "stfifo.h"
#include "staudio.h"

//----------------------------------------------------------------------------
//                             Exported Constants
//----------------------------------------------------------------------------
#define EVAL3520A
#define ON TRUE
#define OFF FALSE

// Card related definitions
//#define LSB      0x100         // to reach lsb register (A0 = 1)
#define LSB      1         // to reach lsb register (A0 = 1)
#define DATA_IN  0x18

//temp JBS
#define ERROR_CARD_NOT_FOUND 		      1
#define ERROR_NOT_ENOUGH_MEMORY       2
#define ERROR_COMMAND_NOT_IMPLEMENTED 3
#define DEFAULT_BASEIO                0x180
#define ERR_SKIP		                  0x116

// Audio States
#define AUDIO_POWER_UP  0 /* After reset */
#define AUDIO_INIT      1 /* Initialisation + test of the decoders */
#define AUDIO_STC_INIT  2 /* STC of audio decoder initialized */
#define AUDIO_DECODE    3 /* Normal decode */
#define AUDIO_FAST      4 /* "fast forward": use fast variable */
#define AUDIO_SLOW      5 /* Slow down mode: use tempo variable */
#define AUDIO_STEP      6 /* Used fo Step by step decoding */
#define AUDIO_PAUSE     7 /* Audio decoder has been pause  */

#define CTRL_AUDIO      0
#define CTRL_VIDEO      1
#define CTRL_BOTH       2

// STD definitions
#define STAUDIO         45
#define STVIDEO         35
#define STUFF           0
#define BOTH_AV         55

// Buffer Constants
//YOUUSS
//#define MAX_HEAD_SIZE   206  // Maximum Header Size is 206
//#define BUFFER_SIZE     16384 // Buffer Size is 16 kbytes

#define MAX_HEAD_SIZE           206 // Maximum Header Size is 206
#define BUFFER_SIZE           16384 // Buffer Size is 16 kbytes
#define AUDIO_BUFFER_SIZE      4096 // Audio Buffer Size is 4 kbytes
#define VIDEO_BUFFER_SIZE     16384 // Buffer Size is 16 kbytes

#define MAX_BUF_SIZE    BUFFER_SIZE + MAX_HEAD_SIZE // Maximum Buffer Size is 16 kbytes + 206 bytes

/* define the states of the video decoder */
#define VIDEO_POWER_UP     0 /* After reset */
#define VIDEO_INIT         1 /* Initialisation + test of the decoders */
#define VIDEO_START_UP     2 /* This phase includes: Searching first sequence */
														 /* initializing the decoding parameters, start decode on good BBL */
#define VIDEO_PAUSE        3 /* pause */
#define VIDEO_DECODE       4 /* Normal decode */
#define VIDEO_FAST         5 /* "fast forward": use fast variable */
#define VIDEO_SLOW         6 /* Slow down mode: use tempo variable */
#define VIDEO_STEP         7 /* Used fo Step by step decoding */
#define VIDEO_WAIT_FOR_DTS 8
#define SLOW_MODE          0
#define PLAY_MODE          1
#define FAST_MODE          2

// MINIPORT STUFF
#define STOP_KEY           0x1B    // ESC Key
#define DEFAULT_IRQ        7

#define NO_ERROR        0                                  /* No error after the test */
#define NOT_DONE        1                                  /* requested action not done */

// ERRORS
/* Control related messages */
#define NOT_INITIALIZED 0x10  /* Control sequencer not initialized */
#define NO_FILE         0x11  /* No file opened */
#define ERRCLASS        0x12  /* Error for creation of the board class */
#define ERRCONTCLASS    0x13  /* Error for creation of the control class */

/* Video related messages */
#define NEW_ERR_V       0x100 /* Not possible to allocate Video instance */
#define BAD_REG_V       0x101 /* Bad access to video registers */
#define BAD_MEM_V       0x102 /* Bad memory test */
#define NO_IT_V         0x103 /* No video interrupt */
#define SMALL_BUF       0x104
#define TEMP_REF        0x105
#define FRAME_RATE      0x106
#define PICT_HEAD       0x107
#define FULL_BUF        0x108
#define TIME_OUT        0x109
#define BUF_EMPTY       0x10A
#define MAIN_PROF       0x10B
#define CHROMA          0x10C
#define HIGH_CCIR601    0x10D
#define HIGH_BIT_RATE   0x10E
#define DC_PREC         0x10F
#define BAD_EXT         0x110
#define S_C_ERR         0x111
#define DECCRASH        0x112 /* Decoder crashed after time-out */
#define NEW_ERR_FIF     0x113 /* Not possible to allocate Video instance */
#define ERR_FIFO_FULL   0x114
#define ERR_FIFO_EMPTY  0x115

/* Audio related messages */
#define NEW_ERR_A       0x200 /* Not possible to allocate Audio instance */
#define BAD_REG_A       0x201 /* Bad access to audio registers */
#define NO_IT_A         0x202 /* No audio interrupt */

#define NEW_ERR_D       0x300 /* Not possible to allocate Demux instance */
#define FILE_NOT_FOUND  0x301
#define NOT_ENOUGH_RAM  0x302 /* Not enough RAM available to load the bit stream */

/* Demux related messages */
#define VIDEO_STREAM    			0x303 /* bit stream is video only */
#define AUDIO_STREAM    			0x304 /* bit stream is audio only */
#define VIDEO_PACKET    			0x305 /* bit stream is MPEG1 system */
#define AUDIO_PACKET    			0x306 /* bit stream is MPEG1 system */
#define VIDEO_PES   	  			0x307 /* bit stream is MPEG1 system */
#define AUDIO_PES		    			0x308 /* bit stream is MPEG1 system */
#define SYSTEM_STREAM   			0x309 /* bit stream is MPEG1 system */
#define DUAL_PES			  			0x30A /* bit stream is MPEG1 system */
#define DUAL_ES				  			0x30B /* bit stream is MPEG1 system */
#define END_OF_FILE     			0x30C /* all the file has been read */
#define END_OF_AUDIO_FILE     0x340 /* all the audio file has been read */
#define END_OF_VIDEO_FILE     0x380 /* all the video file has been read */
#define OK              			0x30D /* eof not reached            */
#define BAD_STREAM      			0x30E /* Not valid stream detected */

#define TOO_MANY_FILES  			0x30F  /* NbFiles > 2 */
#define TOO_FEW_FILES  				0x310  /* NbFiles < 1 */
#define VIDEO_FILE_NOT_FOUND  0x311  /* Cannot open Video File */
#define AUDIO_FILE_NOT_FOUND  0x312  /* Cannot open Video File */

/* Card related messages */
#define NEW_ERR_CARD    0x400 /* Not possible to allocate Card instance */
#define BAD_CARD_COM    0x401 /* Access to the command reg on board not possible */
#define BAD_CARD_TIME   0x402 /* Access to the time base not possible */
#define BAD_IT_VAL      0x403 /* requested interrupt not supported on this board */

/*MPEG Stream Related messages*/
#define NEW_ERR_M       0x500 /* Not possible to allocate Mpeg instance */

//----------------------------------------------------------------------------
//                               Exported Types
//----------------------------------------------------------------------------
typedef VOID (* FNHARDRESET)    (VOID);
typedef BYTE (* FNVREAD)        (BYTE Register);
typedef VOID (* FNVWRITE)       (BYTE Register, BYTE Value);
typedef VOID (* FNVSEND)        (PVOID Data, DWORD Size);
typedef VOID (* FNVSETDISP)     (BYTE DisplayMode);
typedef BYTE (* FNAREAD)        (BYTE Register);
typedef VOID (* FNAWRITE)       (BYTE Register, BYTE Value);
typedef VOID (* FNASEND)        (PVOID Data, DWORD Size);
typedef VOID (* FNASETSAMPFREQ) (DWORD SamplingFrequency);
typedef VOID (* FNENTERIT)      (VOID);
typedef VOID (* FNLEAVEIT)      (VOID);
typedef VOID (* FNENABLEIT)     (VOID);
typedef VOID (* FNDISABLEIT)    (VOID);
typedef VOID (* FNWAIT)         (ULONG);

typedef ULONG COLORREF;
#ifndef NT
typedef enum _INTERFACE_TYPE {
		InterfaceTypeUndefined = -1,
		Internal,
		Isa,
		Eisa,
		MicroChannel,
		TurboChannel,
		PCIBus,
		VMEBus,
		NuBus,
		PCMCIABus,
		CBus,
		MPIBus,
		MPSABus,
		ProcessorInternal,
		InternalPowerBus,
		MaximumInterfaceType
}INTERFACE_TYPE, FAR *PINTERFACE_TYPE;

typedef enum _DMA_WIDTH {
		Width8Bits,
		Width16Bits,
		Width32Bits,
		MaximumDmaWidth
}DMA_WIDTH, FAR *PDMA_WIDTH;

typedef enum _DMA_SPEED {
		Compatible,
		TypeA,
		TypeB,
		TypeC,
		MaximumDmaSpeed
}DMA_SPEED, FAR *PDMA_SPEED;
#endif

typedef struct bitstream_info
{
	BOOLEAN modeMPEG2;    /* mpeg2 - TRUE = MPEG2 */
	S8      progSeq;      /* progressive_seq */
	S8      firstGOP[30]; /* gop_struct[30] - first GOP structure */
	U16     countGOP;     /* count_gop */
	U16     horSize;      /* hor_size */
	U16     verSize;      /* vert_size */
	U16     horDimension; /* hor_dim */
	U16     verDimension; /* vert_dim */
	U16     pixelRatio;   /* pixel_ratio */
	U16     frameRate;    /* frame_rate */
	U16     displayMode;  /* 1 if NTSC 0 if PAL */
	S32     bitRate;      /* bit_rate - bit rate from sequence header */
} BITSTREAM, FAR *P_BITSTREAM;

typedef struct image
{
	S8      pict_type;
	S8      pict_struc;
	U16     tempRef;
	S8      first_field;
	S8      nb_display_field;
	S16     pan_hor_offset[3];
	S16     pan_vert_offset[3];
	S16     buffer;
	U32     dwPTS;
	BOOLEAN validPTS;
}  PICTURE, FAR *P_PICTURE;

typedef struct
{
	U8 Skip ; // 2 bit field equivalent to CMD.SKP[1.0]
	U8 Cmv;   //1 bit
	U8 Tff;   //1 bit
	U8 Rpt;   //1 bit
	U8 Exe;   //1 bit
	U8 Ovw;   //1 bit
	U8 Ffh;   //4 bits
	U8 Bfh;   //4 bits
	U8 Pct;   //2 bits
	U8 Seq;   //1 bit
	U8 Ivf;
	U8 Azz;
	U8 Qst;
	U8 Frm;
	U8 Dcp;   //2 bits
	U8 Pst;   //2 bits
	U8 Ffv;   //2 bits
	U8 Bfv;   //4 bits
	U8 Mp2;//MP2;
} INSTRUCTION, *PINSTRUCTION;

typedef struct {
	U8	        Ppr1;		   /* VID_PPR1 register value 3520a*/
	U8		      Ppr2;		   /* VID_PPR2 register value 3520a*/
	U8          Tis;		   /* VID_TIS register value 3520a*/
	U8          Pfh;		   /* VID_PFH register value 3520a*/
	U8          Pfv;		   /* VID_PFV register value 3520a*/
	BOOLEAN			InvertedField; /* True when start dec on incorrect pol in to save R/2P in 3520a*/
	U8				  FistVsyncAfterVbv;// State variable gives first vsync to vbv position

	U16         Ccf ;		   /* CTL register value*/
	BOOLEAN			HalfRes;
	U16         Ins1;		   /* INS1 register value*/
	U16         Ins2;		   /* INS2 register value*/
	U16         Cmd ;		   /* CMD register value*/

	INSTRUCTION NextInstr; /* Next Instruction ( contains all fields of instruction) */
	INSTRUCTION ZeroInstr; /* Next Instruction ( contains all fields of instruction) */
	U16         Ctl ;		   /* CTL register value*/
	U16         Gcf ;		   /* GCF register value*/
	U16 				VideoBufferSize;// Size of Video Bit Buffer
	U16 				AudioBufferSize;// Size of Audio Bit Buffer

	U16         VideoState;

	U16         ActiveState;
	U16         DecodeMode;

	BITSTREAM   StreamInfo;
	BOOLEAN     notInitDone;  /* not_init_done - TRUE = still init'ing */
	BOOLEAN     useSRC;       /* switch_SRC - use sample rate converter */
	S8          currField;    /* cur_field */
	S8          fieldMode;    /* field_mode */
	BOOLEAN     displaySecondField; /* change display to second in step by step */
	BOOLEAN     perFrame;           /* indicates step by step decoding */
//	BOOLEAN     pictureDecoded;
	BOOLEAN     fastForward;    /* fast - TRUE = decode fast */
	BOOLEAN     VsyncInterrupt; /* true = Vsync interrupt, FALSE = other interrupt */
	BOOLEAN     FirstDTS;
	U16         VsyncNumber;    /* number of consecutive Vsync without Dsync */
	S8          skipMode;       /* skip - 0, 1, 2, 3 */
	U16         NotSkipped;
	U16         intMask;        /* maskit_3500 - interrupt mask */
	U16         intStatus;      /* int_stat_reg - interrupt status register */
	U16         hdrFirstWord;   /* read_val - Contain the read data fifo */
	U16         hdrNextWord;    /* shift_val -  Special case of header position = 8 */
	U16         GOPindex;       /* gop_index */
	U16         vbvReached;     /* vbv_done */
	U16         vbvDelay;                  /* vbv_delay */
	U16         decSlowDown;    /* tempo - slow down the decoder */
	U16         currTempRef;    /* temp_ref - display temporal reference */
	U16         frameStoreAttr; /* attr_fs */
	U16         Xdo;            /* horizontal origin */
	U16         Ydo;            /* vertical origin */
	U16         Xd1;            /* horizontal end */
	U16         Yd1;            /* vertical end */
	U16         vbvBufferSize;  /* vbv_buffer_size */
	U16         currCommand;    /* command */
	U16         seqDispExt;     /* seq_display */
	S16         currDCF;        /* DCF_val */
	S16         halfVerFilter;  /* DCF_val_Half */
	S16         fullVerFilter;  /* DCF_val_Full */
	U8          hdrHours;       /* hours */
	U8          hdrMinutes;     /* minutes */
	U8          hdrSeconds;     /* seconds */
	U8          pictTimeCode;   /* time_code_picture */
	U8          hdrPos;         /* point_posit - position of header to read */
	U16         decAddr;        /* adcard_dec - decoder board address */
	U16         needDataInBuff; /* empty */
	U16         errCode;        /* err_nu */
	U16         defaultTbl;     /* def_tab */
	U16         nextInstr1;     /* make_ins1 */
	U16         nextInstr2;     /* make_ins2 */
	U16         currPictCount;  /* pict_count */
	U16         latestPanHor;   /* latest_pan_hor */
	U16         latestPanVer;   /* latest_pan_vert */
	S16         pictDispIndex;  /* cnt_display */
	U16         LastPipeReset;  /* last pipe reset in case of error */
	U16         LastBufferLevel;/* last bit buffer level */
	U32         LastCdCount;    /* last CD count read */
	U32         LastScdCount;   /* last SCD count */
	U16					BufferA;        /* 1st frame storage address*/
	U16					BufferB;        /* 2d frame storage address*/
	U16					BufferC;        /* 3d frame storage address*/
	PICTURE     pictArray[4];   /* pict_buf[4] */
	P_PICTURE   pDecodedPict;   /* decoded_pict_ptr */
	P_PICTURE   pCurrDisplay;   /* cur_display_ptr */
	P_PICTURE   pNextDisplay;   /* next_display_ptr */
	PFIFO       pFifo;
	FIFO        Fifo;
} VIDEO, FAR *PVIDEO;

typedef struct
{
	U16             OriginX;
	U16             OriginY;
	U16             EndX;
	U16             EndY;
	BOOLEAN         bAudioDecoding;
	BOOLEAN         bVideoDecoding;
	VIDEO Video;
	AUDIO Audio;
	PVIDEO pVideo;
	PAUDIO pAudio;
}CARD, FAR *PCARD;

//----------------------------------------------------------------------------
//                             Exported Variables
//----------------------------------------------------------------------------
extern FNVREAD        STiVideoRead;
extern FNVWRITE       STiVideoWrite;
extern FNVSEND        STiVideoSend;
extern FNVSETDISP     STiVideoSetDisplayMode;
extern FNAREAD        STiAudioRead;
extern FNAWRITE       STiAudioWrite;
extern FNASEND        STiAudioSend;
extern FNASETSAMPFREQ STiAudioSetSamplingFrequency;
extern FNHARDRESET    STiHardReset;
extern FNENTERIT      STiEnterInterrupt;
extern FNLEAVEIT      STiLeaveInterrupt;
extern FNENABLEIT     STiEnableIT;
extern FNDISABLEIT    STiDisableIT;
extern FNWAIT         STiWaitMicroseconds;

extern PCARD pCard;

//----------------------------------------------------------------------------
//                             Exported Macros
//----------------------------------------------------------------------------
#define VideoRead(Register)                   STiVideoRead(Register)
#define VideoWrite(Register, Value) 	        STiVideoWrite(Register, Value)
#define VideoSend(Buffer, Size)               STiVideoSend(Buffer, Size)
#define VideoSetDisplayMode(Mode)             STiVideoSetDisplayMode(Mode)
#define AudioRead(Register)                   STiAudioRead(Register)
#define AudioWrite(Register, Value)	          STiAudioWrite(Register, Value)
#define AudioSend(Buffer, Size)               STiAudioSend(Buffer, Size)
#define AudioSetSamplingFrequency(Frequency)  STiAudioSetSamplingFrequency(Frequency)
#define HardReset()                           STiHardReset()
#define EnterInterrupt()                      STiEnterInterrupt()
#define LeaveInterrupt()                      STiLeaveInterrupt()
#define EnableIT()                            STiEnableIT()
#define DisableIT()                           STiDisableIT()
#define WaitMicroseconds(Delay)               STiWaitMicroseconds(Delay)

//----------------------------------------------------------------------------
//                             Exported Functions
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// One line function description (same as in .C)
//----------------------------------------------------------------------------
// In     :
// Out    :
// InOut  :
// Global :
// Return :
//----------------------------------------------------------------------------
WORD SendAudioToVideoIfPossible(PVOID Buffer, WORD Size);
WORD SendAudioIfPossible(PVOID Buffer, WORD Size);
WORD SendVideoIfPossible(PVOID Buffer, WORD Size);
VOID STiInit(FNVREAD        lVideoRead,
						 FNVWRITE       lVideoWrite,
						 FNVSEND        lVideoSend,
						 FNVSETDISP     lVideoSetDisplayMode,
						 FNAREAD        lAudioRead,
						 FNAWRITE       lAudioWrite,
						 FNASEND        lAudioSend,
						 FNASETSAMPFREQ lAudioSetSamplingFrequency,
						 FNHARDRESET    lHardReset,
						 FNENTERIT      lEnterInterrupt,
						 FNLEAVEIT      lLeaveInterrupt,
						 FNENABLEIT     lEnableIT,
						 FNDISABLEIT    lDisableIT,
						 FNWAIT         lWaitMicroseconds);

//------------------------------- End of File --------------------------------
#endif // #ifndef __COMMON_H



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\display.h ===
#ifndef __DISPLAY_H
#define __DISPLAY_H
//NT-MOD
#ifndef NT
//----------------------------------------------------------------------------
// DISPLAY.H
//----------------------------------------------------------------------------
// Description : small description of the goal of the module
//----------------------------------------------------------------------------
// Copyright SGS Thomson Microelectronics  !  Version alpha  !  Jan 1st, 1995
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                               Include files
//----------------------------------------------------------------------------
#include "stdefs.h"

//----------------------------------------------------------------------------
//                               Exported Types
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Exported Variables
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Exported Constants
//----------------------------------------------------------------------------
#define DISPLAY_FASTEST 0
#define DISPLAY_FAST    1
#define DISPLAY_NORMAL  2

//----------------------------------------------------------------------------
//                             Exported Functions
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// One line function description (same as in .C)
//----------------------------------------------------------------------------
// In     :
// Out    :
// InOut  :
// Global :
// Return :
//----------------------------------------------------------------------------
VOID HostDisplayEnable(VOID);
VOID HostDisplayDisable(VOID);
VOID HostDisplayPercentage(BYTE NewPercent);
VOID HostDisplayRotatingCursor(VOID);
VOID HostDirectPutChar(char car, BYTE BckGndColor, BYTE ForeGndColor);
VOID HostDisplay(BYTE Mode, PCHAR pFormat, ...);
#else
#define DISPLAY_FASTEST 0
#define DISPLAY_FAST    1
#define DISPLAY_NORMAL  2
#define HostDisplayEnable
#define HostDisplayDisable
#define HostDisplayPercentage
#define HostDisplayRotatingCursor
#define HostDirectPutChar
#define HostDisplay
#endif
//NT-MOD
//------------------------------- End of File --------------------------------
#endif // #ifndef __DISPLAY_H


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\debug.h ===
#ifndef __DEBUG_H
#define __DEBUG_H
//NT-MOD JBS
#ifndef NT
//----------------------------------------------------------------------------
// DEBUG.H
//----------------------------------------------------------------------------
// Description : set of debugging functions
//----------------------------------------------------------------------------
// Copyright SGS Thomson Microelectronics  !  Version alpha  !  Jan 1st, 1995
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                               Include files
//----------------------------------------------------------------------------
#include <conio.h> // color defs
#include "stdefs.h"
#include "display.h"

//----------------------------------------------------------------------------
//                             Exported Variables
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Exported Constants
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                               Exported Types
//----------------------------------------------------------------------------
#ifndef DEBUGLEVEL
#define DEBUGLEVEL
typedef enum {            // Use the given level to indicate:
	DebugLevelFatal = 0,    // * imminent nonrecoverable system failure
	DebugLevelError,        // * serious error, though recoverable
	DebugLevelWarning,      // * warnings of unusual occurances
	DebugLevelInfo,         // * status and other information - normal though
													//   perhaps unusual events. System MUST remain
													//   responsive.
	DebugLevelTrace,        // * trace information - normal events
													//   system need not ramain responsive
	DebugLevelVerbose,      // * verbose trace information
													//   system need not remain responsive
	DebugLevelMaximum
} DEBUG_LEVEL;
#endif

//----------------------------------------------------------------------------
//                             Exported Functions
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
// In     :
// Out    :
// InOut  :
// Global :
// Return :
//----------------------------------------------------------------------------
VOID DbgPrint(IN DEBUG_LEVEL DebugLevel, IN PCHAR szFormat, ...);

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
// In     :
// Out    :
// InOut  :
// Global :
// Return :
//----------------------------------------------------------------------------
VOID DbgAssert(IN PCHAR File, IN ULONG Line, IN PCHAR AsText, IN ULONG AsVal);

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
// In     :
// Out    :
// InOut  :
// Global :
// Return :
//----------------------------------------------------------------------------
//NT-MOD JBS
//		 HostDisplay(DISPLAY_FASTEST, "%c", Car); 
//NT-MOD JBS
#ifdef ITDEBUG
	#define DBG1(Car) { \
		 HostDirectPutChar(Car, LIGHTGRAY, BLUE); \
	}
#else
	#define DBG1(String)
#endif

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
// In     :
// Out    :
// InOut  :
// Global :
// Return :
//----------------------------------------------------------------------------
#ifdef STDEBUG
	#define DebugPrint(x) DbgPrint x
	#define DEBUG_PRINT(x) DbgPrint x
#else
	#define DebugPrint(x)
	#define DEBUG_PRINT(x)
#endif

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
// In     :
// Out    :
// InOut  :
// Global :
// Return :
//----------------------------------------------------------------------------
#ifdef STASSERT
	#define DebugAssert(exp) \
						if (!(exp)) { \
							DbgAssert( __FILE__, __LINE__, #exp, exp); \
						}
	#define DEBUG_ASSERT DebugAssert
#else
	#define DebugAssert(exp)
	#define DebugPrint(x)
#endif

//NT-MOD JBS
#else
#include "display.h"
	#define DebugAssert(exp)
	#define DebugPrint(x)
	#define DBG1(String)
#endif
//NT-MOD JBS

//------------------------------- End of File --------------------------------
#endif // #ifndef __DEBUG_H




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\fntypes.h ===
#ifndef __FNTYPES_H__
#define __FNTYPES_H__
#include "stdefs.h"
//#include "mpegmini.h"

typedef UCHAR  (*FNPTR_READ_PORT_8) (IN PUCHAR);
typedef USHORT (*FNPTR_READ_PORT_16) (IN PUSHORT);
typedef ULONG  (*FNPTR_READ_PORT_32) (IN PULONG);
typedef VOID   (*FNPTR_READ_PORT_BUFFER_8) (IN PUCHAR, IN PUCHAR, IN ULONG );
typedef VOID   (*FNPTR_READ_PORT_BUFFER_16) (IN PUSHORT, IN PUSHORT, IN ULONG);
typedef VOID   (*FNPTR_READ_PORT_BUUFER_32) (IN PULONG, IN PULONG, IN LONG);

typedef UCHAR 	(*FNPTR_READ_REG_8) (IN PUCHAR);
typedef USHORT	(*FNPTR_READ_REG_16) (IN PUSHORT);
typedef ULONG 	(*FNPTR_READ_REG_32) (IN PULONG);
typedef VOID  	(*FNPTR_READ_REG_BUFFER_8) (IN PUCHAR, IN PUCHAR, IN ULONG );
typedef VOID  	(*FNPTR_READ_REG_BUFFER_16) (IN PUSHORT, IN PUSHORT, IN ULONG);
typedef VOID  	(*FNPTR_READ_REG_BUUFER_32) (IN PULONG, IN PULONG, IN LONG);

typedef VOID (*FNPTR_WRITE_PORT_8) (IN PUCHAR, IN UCHAR);
typedef VOID (*FNPTR_WRITE_PORT_16) (IN PUSHORT, IN USHORT);
typedef VOID (*FNPTR_WRITE_PORT_32) (IN PULONG, IN ULONG);
typedef VOID (*FNPTR_WRITE_PORT_BUFFER_8) (IN PUCHAR, IN PUCHAR, IN ULONG);
typedef VOID (*FNPTR_WRITE_PORT_BUFFER_16) (IN PUSHORT, IN PUSHORT, IN ULONG);
typedef VOID (*FNPTR_WRITE_PORT_BUFFER_32) (IN PULONG, IN PULONG, ULONG);

typedef VOID (*FNPTR_WRITE_REG_8) (IN PUCHAR, IN UCHAR);
typedef VOID (*FNPTR_WRITE_REG_16) (IN PUSHORT, IN USHORT);
typedef VOID (*FNPTR_WRITE_REG_32) (IN PULONG, IN ULONG);
typedef VOID (*FNPTR_WRITE_REG_BUFFER_8) (IN PUCHAR, IN PUCHAR, IN ULONG);
typedef VOID (*FNPTR_WRITE_REG_BUFFER_16) (IN PUSHORT, IN PUSHORT, IN ULONG);
typedef VOID (*FNPTR_WRITE_REG_BUFFER_32) (IN PULONG, IN PULONG, ULONG);
typedef VOID (*FNPTR_ENABLE_IT)(VOID);
typedef VOID (*FNPTR_DISABLE_IT)(VOID);
#endif // __FNTYPES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\filestr.h ===
#ifndef __FILESTR_H
#define __FILESTR_H
//----------------------------------------------------------------------------
// FILESTR.H
//----------------------------------------------------------------------------
// Description : small description of the goal of the module
//----------------------------------------------------------------------------
// Copyright SGS Thomson Microelectronics  !  Version alpha  !  Jan 1st, 1995
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                               Include files
//----------------------------------------------------------------------------
#include "stdio.h"
#include "stdefs.h"
#include "error.h"

//----------------------------------------------------------------------------
//                             Exported Constants
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                               Exported Types
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Exported Variables
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Exported Functions
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// One line function description (same as in .C)
//----------------------------------------------------------------------------
// In     :
// Out    :
// InOut  :
// Global :
// Return :
//----------------------------------------------------------------------------
ERRORCODE OpenFile(PCHAR FileName);
U16 ReadBuffer(P_U8 Buffer, U16 Size);
VOID RewindFile(VOID);
VOID CloseFile(VOID);
FILE *GetFilePtr(VOID); // FILE should be redefined !

//------------------------------- End of File --------------------------------
#endif // #ifndef __FILESTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\i2c.h ===
#ifndef __I2C_H
#define __I2C_H
//----------------------------------------------------------------------------
// I2C.H
//----------------------------------------------------------------------------
// I2C peripheral programming
//----------------------------------------------------------------------------
// Copyright SGS Thomson Microelectronics  !  Version alpha  !  Jan 1st, 1995
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                               Include files
//----------------------------------------------------------------------------
#include "stdefs.h"

//----------------------------------------------------------------------------
//                               Exported Types
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Exported Variables
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Exported Constants
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Exported Functions
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// Function to send a byte to an I2C peripheral
//----------------------------------------------------------------------------
// In     :
//   BYTE Address    : address of the I2C peripheral
//   BYTE SubAddress : register address of the peripheral
//   BYTE Data       : 8 bit data to write in the register
// Out    : -
// InOut  : -
// Global : -
// Return :
//   TRUE if no error occurs, FALSE if not
//----------------------------------------------------------------------------
BOOL I2CSend(BYTE Address, BYTE SubAddress, BYTE Data);

//------------------------------- End of File --------------------------------
#endif // #ifndef __I2C_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\error.h ===
#ifndef __ERROR_H
#define __ERROR_H
//----------------------------------------------------------------------------
// ERROR.H
//----------------------------------------------------------------------------
// Description : small description of the goal of the module
//----------------------------------------------------------------------------
// Copyright SGS Thomson Microelectronics  !  Version alpha  !  Jan 1st, 1995
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                               Include files
//----------------------------------------------------------------------------
#include "stdefs.h"

//----------------------------------------------------------------------------
//                             Exported Constants
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                               Exported Types
//----------------------------------------------------------------------------
typedef enum {
	ERR_ERROR = 0,
	ERR_NO_ERROR,
	ERR_CM_NOT_PRESENT,
	ERR_CM_VERSION_NOT_OK,
	ERR_BOARD_NOT_FOUND,
	ERR_PCI_BIOS_NOT_PRESENT,
	ERR_INVALID_ADDRESS,
	ERR_NO_ADDRESS_AFFECTED,
	ERR_ADDRESS_IS_NOT_IO,
	ERR_CANNOT_ACCESS_PCI_CONFIG_DATA,
	ERR_NO_IRQ_AFFECTED,
	ERR_NOT_ENOUGH_MEMORY,
	ERR_NOT_AN_MPEG_STREAM,
	ERR_BAD_STREAM,
	ERR_FILE_NOT_FOUND,
	ERR_NO_TEMPORAL_REFERENCE,
	ERR_HIGHER_THAN_CCIR601,
	ERR_MEM_WRITE_FIFO_NEVER_EMPTY,
	ERR_BIT_BUFFER_EMPTY,
	ERR_PICTURE_HEADER,
	ERR_FRAME_RATE_NOT_SUPPORTED,
	ERR_PROFILE_NOT_SUPPORTED,
	ERR_LEVEL_NOT_SUPPORTED,
	ERR_CHROMA_FORMAT_NOT_SUPPORTED,
	ERR_BITRATE_TO_HIGH,
	ERR_INTRA_DC_PRECISION,
	ERR_BAD_EXTENSION_SC,
	ERR_NO_VIDEO_INTR,
	ERR_NO_AUDIO_INTR,
	ERR_UNKNOWN_SC,
	ERR_BIT_BUFFER_FULL,
	ERR_HEADER_FIFO_EMPTY,
	ERR_PCI9060_REG_TEST_FAILED,
	ERR_ALTERA_REG_TEST_FAILED,
	ERR_VIDEO_REG_TEST_FAILED,
	ERR_AUDIO_REG_TEST_FAILED,
	ERR_TEST_MEMORY_FAILED,
	ERR_LAST_ERROR
} ERRORCODE;

//----------------------------------------------------------------------------
//                             Exported Variables
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Exported Functions
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// Set the error code
//----------------------------------------------------------------------------
// In     : Current error code
// Out    : -
// InOut  : -
// Global : -
// Return : -
//----------------------------------------------------------------------------
VOID SetErrCode(ERRORCODE lErrorCode);
#ifdef ERROR
	#define SetErrorCode(ErrorCode) SetErrCode(ErrorCode)
#else
	#define SetErrorCode(ErrorCode)
#endif

//----------------------------------------------------------------------------
// Get the current error code
//----------------------------------------------------------------------------
// In     : -
// Out    : -
// InOut  : -
// Global : -
// Return : Current error code
//----------------------------------------------------------------------------
ERRORCODE GetErrorCode(VOID);

//----------------------------------------------------------------------------
// Display the error message matching the current error
//----------------------------------------------------------------------------
// In     : -
// Out    : -
// InOut  : -
// Global : -
// Return : -
//----------------------------------------------------------------------------
//NT-MOD - JBS
#ifndef NT
VOID DisplayErrorMessage(VOID);
#else
	#define DisplayErrorMessage()
#endif
//NT-MOD
//------------------------------- End of File --------------------------------
#endif // #ifndef __ERROR_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\i2c.c ===
//----------------------------------------------------------------------------
// I2C.C
//----------------------------------------------------------------------------
// I2C peripheral programming
//----------------------------------------------------------------------------
// Copyright SGS Thomson Microelectronics  !  Version alpha  !  Jan 1st, 1995
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                               Include files
//----------------------------------------------------------------------------
#include "stdefs.h"
#include "aal.h"
#include "debug.h"

//----------------------------------------------------------------------------
//                              Private Types
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                            Private Constants
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                     Private GLOBAL Variables (static)
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                     Functions (statics one are private)
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// Start a transfert
//----------------------------------------------------------------------------
static VOID I2CStart(VOID)
{
	I2CWriteCMD(1, 1);
	I2CWriteCMD(0, 1);
	I2CWriteCMD(0, 0);
}

//----------------------------------------------------------------------------
// Stop a transfert
//----------------------------------------------------------------------------
static VOID I2CStop(VOID)
{
	I2CWriteCMD(0, 0);
	I2CWriteCMD(0, 1);
	I2CWriteCMD(1, 1);
}

//----------------------------------------------------------------------------
// Get the acknowledge from the receiver
//----------------------------------------------------------------------------
static BOOL I2CAcknowledge(VOID)
{
	I2CWriteCMD(1, 0);
	I2CWriteCMD(1, 1);
	I2CWriteCMD(1, 0);

	//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	// Here we should check that the acknowledge signal has arrived, but HW has
	// not been implemented to do this, so we can not !
	//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	return TRUE;
}

//----------------------------------------------------------------------------
// Send a byte on the bus (Most Significant Bit first)
//----------------------------------------------------------------------------
static VOID I2CSendByte(BYTE Data)
{
	BYTE i;

	for (i = 0; i < 8; i++) {
		if ((Data & 0x80) != 0) {
			I2CWriteCMD(1, 0);
			I2CWriteCMD(1, 1);
			I2CWriteCMD(1, 0);
		}
		else {
			I2CWriteCMD(0, 0);
			I2CWriteCMD(0, 1);
			I2CWriteCMD(0, 0);
		}
		Data = Data << 1;
	}
}

//----------------------------------------------------------------------------
// Function to send a byte to an I2C peripheral
//----------------------------------------------------------------------------
BOOL I2CSend(BYTE Address, BYTE SubAddress, BYTE Data)
{
	DebugAssert(Address != 0);

	I2CStart();

	I2CSendByte(Address);
	if (!I2CAcknowledge())
		return FALSE;

	I2CSendByte(SubAddress);
	if (!I2CAcknowledge())
		return FALSE;

	I2CSendByte(Data);
	if (!I2CAcknowledge())
		return FALSE;

	I2CStop();

	return TRUE;
}

//------------------------------- End of File --------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\eeprom.h ===
#ifndef __EEPROM_H
#define __EEPROM_H
//----------------------------------------------------------------------------
// EEPROM.H
//----------------------------------------------------------------------------
// Description : small description of the goal of the module
//----------------------------------------------------------------------------
// Copyright SGS Thomson Microelectronics  !  Version alpha  !  Jan 1st, 1995
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                               Include files
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                               Exported Types
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Exported Variables
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Exported Constants
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Exported Functions
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// One line function description (same as in .C)
//----------------------------------------------------------------------------
// In     :
// Out    :
// InOut  :
// Global :
// Return :
//----------------------------------------------------------------------------
VOID EEPROMInitialize(WORD *ArrayPtr);

//------------------------------- End of File --------------------------------
#endif // #ifndef __EEPROM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\icd2051.c ===
//----------------------------------------------------------------------------
// ICD2051.C
//----------------------------------------------------------------------------
// PLL (Cypress ICD2051) programming
//----------------------------------------------------------------------------
// Copyright SGS Thomson Microelectronics  !  Version alpha  !  Jan 1st, 1995
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                               Include files
//----------------------------------------------------------------------------
#include "stdefs.h"
#include "aal.h"

//----------------------------------------------------------------------------
//                            Private Constants
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                              Private Types
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                     Private GLOBAL Variables (static)
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                     Functions (statics one are private)
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// Send a 22 bit Word (LSB first) to an ICD2051 component
//----------------------------------------------------------------------------
VOID ICD2051SendWord(BOOL PLLA, DWORD Data)
{
	BYTE i;

	for (i = 0; i < 22; i++) {
		if ((Data & 0x01) != 0) {
			ICD2051WriteCMD(1, 0 && PLLA, 0 && !PLLA);
			ICD2051WriteCMD(1, 1 && PLLA, 1 && !PLLA);
			ICD2051WriteCMD(1, 0 && PLLA, 0 && !PLLA);
		}
		else {
			ICD2051WriteCMD(0, 0 && PLLA, 0 && !PLLA);
			ICD2051WriteCMD(0, 1 && PLLA, 1 && !PLLA);
			ICD2051WriteCMD(0, 0 && PLLA, 0 && !PLLA);
		}
		Data = Data >> 1;
	}
}

//------------------------------- End of File --------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\eeprom.c ===
//----------------------------------------------------------------------------
// EEPROM.C
//----------------------------------------------------------------------------
// Description : small description of the goal of the module
//----------------------------------------------------------------------------
// Copyright SGS Thomson Microelectronics  !  Version alpha  !  Jan 1st, 1995
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                               Include files
//----------------------------------------------------------------------------
#include "stdefs.h"
#include "board.h"
#include "pci9060.h"
#include "display.h"

//----------------------------------------------------------------------------
//                            Private Constants
//----------------------------------------------------------------------------
#define WRITEDELAY 1000

static WORD EEPROM[] = {
	0x3520, // PCI9060_DEVICE_ID -> EVAL3520(A)
	0x104A, // PCI9060_VENDOR_ID -> SGS-Thomson Microelectronics ID
	0x0480, // PCI9060_CLASS_BASE / PCI9060_CLASS_SUB
	0x0000, // PCI9060_CLASS_PI / PCI9060_REV_ID
	0x0000, // MSW of PCI9060_LAT_GNT_INTPIN_INTLINE
	0x0100, // LSW of PCI9060_LAT_GNT_INTPIN_INTLINE
	0x0000, // MSW of Mailbox 0
	0x0000, // LSW of Mailbox 0
	0x0000, // MSW of Mailbox 1
	0x0000, // LSW of Mailbox 1

	0xFFFF, // MSW of PCI9060_LOCAL_RANGE
	0xF001, // LSW of PCI9060_LOCAL_RANGE
	0x0000, // MSW of PCI9060_LOCAL_REMAP
	0x0001, // LSW of PCI9060_LOCAL_REMAP
	0x0000, // Reserved
	0x0000, // Reserved
	0x0000, // Reserved
	0x0000, // Reserved
	0xFFFF, // MSW of PCI9060_EXP_RANGE
	0xF000, // LSW of PCI9060_EXP_RANGE
	0x0000, // MSW of PCI9060_EXP_REMAP
	0x0000, // LSW of PCI9060_EXP_REMAP
	0x4900, // MSW of PCI9060_REGIONS
	0x0040, // LSW of PCI9060_REGIONS
	0x0000, // MSW of PCI9060_DM_MASK
	0x0000, // LSW of PCI9060_DM_MASK
	0x0000, // MSW of PCI9060_DM_LOCAL_BASE
	0x0000, // LSW of PCI9060_DM_LOCAL_BASE
	0x0000, // MSW of PCI9060_DM_IO_BASE
	0x0000, // LSW of PCI9060_DM_IO_BASE
	0x0000, // MSW of PCI9060_DM_PCI_REMAP
	0x0000, // LSW of PCI9060_DM_PCI_REMAP
	0x0000, // MSW of PCI9060_DM_IO_CONFIG
	0x0000, // LSW of PCI9060_DM_IO_CONFIG

	0x0000, // Solve bug 4 of rev 2.0
	0x0000  // Solve bug 4 of rev 2.0
	// 28 words more available for applications (EEPROM is 1 Kbit = 128 bytes)
};

//----------------------------------------------------------------------------
//                              Private Types
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                     Private GLOBAL Variables (static)
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                     Functions (statics one are private)
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
static VOID ResetCS(VOID)
{
	PCI9060EEPROMWriteCMD(0, 0, 0);
	MicrosecondsDelay(WRITEDELAY);
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
static VOID SetCS(VOID)
{
	PCI9060EEPROMWriteCMD(0, 1, 0);
	MicrosecondsDelay(WRITEDELAY);
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
static VOID EEPROMWriteBit(BOOL Bit)
{
	PCI9060EEPROMWriteCMD(0, 1, Bit);
	MicrosecondsDelay(WRITEDELAY);
	PCI9060EEPROMWriteCMD(1, 1, Bit);
	MicrosecondsDelay(WRITEDELAY);
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
static VOID EEPROMStartWrite(VOID)
{
	ResetCS();

	//---- Write enable
	EEPROMWriteBit(1);
	EEPROMWriteBit(0);
	EEPROMWriteBit(0);
	EEPROMWriteBit(1);
	EEPROMWriteBit(1);
	EEPROMWriteBit(0);
	EEPROMWriteBit(0);
	EEPROMWriteBit(0);
	EEPROMWriteBit(0);

	ResetCS();
	SetCS();
}

//----------------------------------------------------------------------------
// Write the start write address (6 bits)
//----------------------------------------------------------------------------
static VOID EEPROMWriteAddress(BYTE Address)
{
	BYTE i;

	//---- Write Command
	EEPROMWriteBit(1);
	EEPROMWriteBit(0);
	EEPROMWriteBit(1);

	//---- Write address
	for (i = 0; i < 6; i++) {
		if ((Address & 0x20) != 0)
			EEPROMWriteBit(1);
		else
			EEPROMWriteBit(0);
		Address = Address << 1;
	}
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
static VOID EEPROMWriteWord(WORD Value)
{
	BYTE i;

	for (i = 0; i < 16; i++) {
		if ((Value & 0x8000) != 0)
			EEPROMWriteBit(1);
		else
			EEPROMWriteBit(0);
		Value = Value << 1;
	}
	ResetCS();
	SetCS();

	//---- Wait for the write to complete
	MicrosecondsDelay(11000);
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
static VOID EEPROMFinishWrite(VOID)
{
	//---- Write disable
	EEPROMWriteBit(1);
	EEPROMWriteBit(0);
	EEPROMWriteBit(0);
	EEPROMWriteBit(0);
	EEPROMWriteBit(0);
	EEPROMWriteBit(0);
	EEPROMWriteBit(0);
	EEPROMWriteBit(0);
	EEPROMWriteBit(0);

	ResetCS();
	SetCS();
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
/*
static BOOL EEPROMReadWord()
{
	return ;
}
*/

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
VOID EEPROMInitialize(PWORD ArrayPtr)
{
	PWORD Ptr;
	WORD i;

	//---- If no array specified take the default's one
	if (ArrayPtr == NULL)
		Ptr = &EEPROM[0];
	else
		Ptr = ArrayPtr;

	EEPROMStartWrite();
	HostDisplayPercentage(0xFF);
	for (i = 0; i < 34; i++) {
		HostDisplayPercentage((100 * i) / 34);
		EEPROMWriteAddress(i);
		EEPROMWriteWord(*(Ptr++));
	}
	EEPROMFinishWrite();
}

//------------------------------- End of File --------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\mpovrlay.h ===
/*******************************************************************
*
*				 MPVIDEO.H
*
*				 Copyright (C) 1995 SGS-THOMSON Microelectronics.
*
*
*				 Prototypes for MPVIDEO.C
*
*******************************************************************/

#ifndef __MPOVRLAY_H__
#define __MPOVRLAY_H__

ULONG miniPortOverlayUpdateClut (PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortOverlaySetVgaKey (PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortOverlaySetMode(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortOverlaySetDestination(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortOverlaySetBitMask(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortOverlaySetAttribute(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortOverlaySetAlignment(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortOverlayGetVgaKey(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortOverlayGetMode(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortOverlayGetDestination(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortOverlayGetAttribute(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortOverlayGetAlignment(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
#endif //__MPOVRLAY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\mpinit.h ===
/*******************************************************************
*
*				 MPINIT.H
*
*				 Copyright (C) 1995 SGS-THOMSON Microelectronics.
*
*
*				 Prototypes for MPINIT.C
*
*******************************************************************/
#ifndef __MPINIT_H__
#define __MPINIT_H__
#define NO_ERROR 0
#ifndef NULL
#define NULL 0
#endif
#define ERROR_CARD_NOT_FOUND 		1
#define ERROR_NOT_ENOUGH_MEMORY  2
#define ERROR_COMMAND_NOT_IMPLEMENTED 3
#define VIDEO_PACKET_TIMER (10*1000)
#define AUDIO_PACKET_TIMER (10*1000)
#define MEM_WINDOW_SIZE (128*1024)
typedef struct _VIDEO_DEVICE_EXTENSION {
   BOOLEAN 						EOSInProgress;      // End Of Stream ha been sent to device
	MPEG_DEVICE_STATE 		DeviceState;
	MPEG_SYSTEM_TIME			videoSTC;
	PMPEG_REQUEST_BLOCK  	pCurrentMrb;
   ULONG   						StarvationCount;        // number of times device was starved since last reset
} VIDEO_DEVICE_EXTENSION, *PVIDEO_DEVICE_EXTENSION;

typedef struct _AUDIO_DEVICE_EXTENSION {
	MPEG_SYSTEM_TIME		audioSTC;
	MPEG_DEVICE_STATE 	DeviceState;
	PMPEG_REQUEST_BLOCK  pCurrentMrb;
   ULONG   					StarvationCount;        // number of times device was starved since last reset
	ULONG	  					ByteSent;
} AUDIO_DEVICE_EXTENSION, *PAUDIO_DEVICE_EXTENSION;

typedef struct _HW_DEVICE_EXTENSION {
	MPEG_DEVICE_STATE stState;
	PUSHORT  					ioBaseLocal;
	PUSHORT  					ioBasePCI9060;
	USHORT						Irq;
	BOOLEAN						bVideoInt;
	BOOLEAN						bAudioInt;
	VIDEO_DEVICE_EXTENSION 	VideoDeviceExt;
	AUDIO_DEVICE_EXTENSION 	AudioDeviceExt;
} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;

BOOLEAN HwInitialize (IN PVOID DeviceExtension );
BOOLEAN HwUnInitialize ( IN PVOID DeviceExtension);
BOOLEAN HwInterrupt ( IN PVOID pDeviceExtension );
VOID AudioEnableInterrupts(IN PVOID pHwDeviceExtension);
VOID STEnableInterrupts( IN PVOID pHwDeviceExtension );
VOID STDeferredCallback ( IN PVOID pHwDeviceExtension );
VOID TmpDeferredCallback ( IN PVOID pHwDeviceExtension );
VOID AudioTimerCallBack(IN PHW_DEVICE_EXTENSION pDeviceExtension);
ULONG DriverEntry (PVOID Context1, PVOID Context2);

// Function Prototype for the locally defined functions

BOOLEAN HwStartIo (
				IN PVOID DeviceExtension,
				PMPEG_REQUEST_BLOCK pMrb
				);

MP_RETURN_CODES	HwFindAdapter (
					IN PVOID DeviceExtension,
					IN PVOID HwContext, 
					IN PVOID BusInformation,
					IN PCHAR ArgString, 
					IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
					OUT PBOOLEAN Again
					);
#ifndef DOS
VOID HostDisableIT(VOID);
VOID HostEnableIT(VOID);
#endif
#endif //__MPINIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\mpinit.c ===
/*******************************************************************
*
*				 MPINIT.C
*
*				 Copyright (C) 1995 SGS-THOMSON Microelectronics.
*
*
*				 PORT/MINIPORT Interface init routines
*
*******************************************************************/

#include "common.h"
#include "mpegmini.h"
#include "mpinit.h"
#include "mpst.h"
#include "mpvideo.h"
#include "mpaudio.h"
#include "mpovrlay.h"
#include "debug.h"



/********************************************************************
*		Function Name : DriverEntry
* 		Args : Context1 and Context2
* 		Returns : Return of MpegPortInitialize
*		Purpose : Entry Point into the MINIPORT Driver.
*
*		Revision History : Last modified on 25/8/95 by JBS
********************************************************************/
ULONG DriverEntry ( PVOID Context1, PVOID Context2 )
{

	HW_INITIALIZATION_DATA HwInitData;
	BUSINFO BusInfo;

	 DebugPrint((DebugLevelVerbose,"ST MPEG2 MiniPort DriverEntry"));
	 MpegPortZeroMemory(&HwInitData, sizeof(HwInitData));
	 HwInitData.HwInitializationDataSize = sizeof(HwInitData);

	// Entry points for Port Driver
	HwInitData.HwInitialize 	= HwInitialize;
	HwInitData.HwUnInitialize 	= HwUnInitialize;
	HwInitData.HwStartIo 		= HwStartIo;
	HwInitData.HwFindAdapter 	= HwFindAdapter;
	HwInitData.HwInterrupt[VideoDevice]  = HwInterrupt;

	HwInitData.DeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);
#if 1
   HwInitData.NumberOfAccessRanges = 0x4;
   HwInitData.AdapterInterfaceType = PCIBus;
   HwInitData.VendorIdLength = 4;
   HwInitData.VendorId = "104a";
   HwInitData.DeviceIdLength = 4;
	HwInitData.DeviceId = "3520";
   HwInitData.NoDynamicRelocation = FALSE;
#else
	 mpstDriverEntry(&BusInfo);
	 HwInitData.NumberOfAccessRanges = BusInfo.NumberOfAccessRanges;
	 HwInitData.AdapterInterfaceType = BusInfo.AdapterInterfaceType;
	 HwInitData.VendorIdLength = BusInfo.VendorIdLength;
	 HwInitData.VendorId = BusInfo.VendorId;
	 HwInitData.DeviceIdLength = BusInfo.DeviceIdLength;
	 HwInitData.DeviceId = BusInfo.DeviceId;
   HwInitData.NoDynamicRelocation = BusInfo.NoDynamicRelocation;
#endif
	 DebugPrint((DebugLevelVerbose,"Exit from DriverEntry"));
	return (MpegPortInitialize(Context1, Context2,&HwInitData, NULL));
}
         
/********************************************************************
*		Function Name : HwInitialize
* 		Args : Pointer to Device Ext. 
* 		Returns : TRUE if sucessful, FALSE otherwise
*		Purpose : Initialize the Board, Setup IRQ, Initialize the
* 					 Control and Card structures.
*
*		Revision History : Last modified on 19/8/95 by JBS
********************************************************************/

BOOLEAN HwInitialize (IN PVOID DeviceExtension )
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)DeviceExtension; 		

	DebugPrint((DebugLevelVerbose,"Entry : HwInitialize()"));

	mpstHwInitialize (pHwDevExt);
	pHwDevExt->VideoDeviceExt.pCurrentMrb = NULL;
	pHwDevExt->AudioDeviceExt.pCurrentMrb = NULL;
	pHwDevExt->VideoDeviceExt.DeviceState = MpegStatePaused;
	pHwDevExt->AudioDeviceExt.DeviceState = MpegStatePaused;
	DebugPrint((DebugLevelVerbose,"Exit : HwInitialize()"));
	return TRUE;
}

/********************************************************************
*		Function Name : HwUnInitialize
* 		Args : Pointer to Device Ext. 
* 		Returns : TRUE if sucessful, FALSE otherwise
*		Purpose : Uninitialize the H/W and data initialized 
*	 				 by HwInitialize Function
*
*		Revision History : Last modified on 15/7/95 JBS
********************************************************************/

BOOLEAN HwUnInitialize ( IN PVOID DeviceExtension)
{
	DeviceExtension = DeviceExtension;
	mpstHwUnInitialize ();
	return TRUE;
}

/********************************************************************
*		Function Name : HwFindAdapter
* 		Args : Pointer to Device Ext, Bus Information, ArgString,
*				 port configuration information, Again
* 		Returns : MP_FOUND, NOT FOUND OR ERROR
*		Purpose : Finds the H/W Adapter on the system
*
*		Revision History : Last modified on 15/7/95 by JBS
********************************************************************/
MP_RETURN_CODES	HwFindAdapter (
					IN PVOID DeviceExtension,
					IN PVOID HwContext, 
					IN PVOID BusInformation,
					IN PCHAR ArgString, 
					IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
					OUT PBOOLEAN Again
					)
{
	// Code to find the adapter has to be added.	- JBS

    ULONG   ioAddress;
    ULONG   IrqLevel; // Temp code to be put in HW_DEV_EXT
    PUSHORT  ioBase;
	PHW_DEVICE_EXTENSION	pHwDevExt = (PHW_DEVICE_EXTENSION)DeviceExtension;
#ifdef NT
   *Again = FALSE; // Only one card is allowed in the system
   DEBUG_PRINT((DebugLevelVerbose, "Entry : HwFindAparter()\n"));
	if(ConfigInfo->Length != sizeof(PORT_CONFIGURATION_INFORMATION))
	{
		DEBUG_PRINT((DebugLevelError,"Find Adapter : Different Size!!"));
		return MP_RETURN_BAD_CONFIG;		
	}

	 ConfigInfo->DmaChannels[VideoDevice].DmaChannel = MP_UNINITIALIZED_VALUE;
	 ConfigInfo->DmaChannels[AudioDevice].DmaChannel = MP_UNINITIALIZED_VALUE;
	 ConfigInfo->DmaChannels[OverlayDevice].DmaChannel = MP_UNINITIALIZED_VALUE;

    if(ConfigInfo->AccessRanges[0].RangeLength == 0){
        // IO Base was not specified in the registry
        DEBUG_PRINT((DebugLevelError, "FindAdapter: IO Base not specified\n"));
        return MP_RETURN_INSUFFICIENT_RESOURCES;
    }

//	 DEBUG_PRINT((DebugLevelVerbose,"3520 Address Physical = %lx\n", ConfigInfo->AccessRanges[2].RangeStart));
//	 DEBUG_PRINT((DebugLevelVerbose,"PCI9060 Address Physical = %lx\n", ConfigInfo->AccessRanges[1].RangeStart));

    ioAddress = MPEG_PORT_CONVERT_PHYSICAL_ADDRESS_TO_ULONG(
                                ConfigInfo->AccessRanges[2].RangeStart
                                );
    ConfigInfo->AccessRanges[0].RangeStart = ConfigInfo->AccessRanges[2].RangeStart ;
	 DEBUG_PRINT((DebugLevelVerbose,"3520 Base Address = %lx\n", ioAddress));

    if( (ConfigInfo->Interrupts[VideoDevice].BusInterruptLevel == MP_UNINITIALIZED_VALUE) &&
        (ConfigInfo->Interrupts[AudioDevice].BusInterruptLevel == MP_UNINITIALIZED_VALUE) &&
        (ConfigInfo->Interrupts[OverlayDevice].BusInterruptLevel == MP_UNINITIALIZED_VALUE)){
        DEBUG_PRINT((DebugLevelError, "FindAdapter: Interrupt not specfied correctly\n"));
        return MP_RETURN_INVALID_INTERRUPT;
    }

    IrqLevel = ConfigInfo->Interrupts[VideoDevice].BusInterruptLevel;
	 DEBUG_PRINT((DebugLevelVerbose,"Video Interrupt = %lx\n", IrqLevel));

//    ConfigInfo->Interrupts[AudioDevice].BusInterruptLevel = IrqLevel;
//    ConfigInfo->Interrupts[OverlayDevice].BusInterruptLevel = IrqLevel;
    ioBase = MpegPortGetDeviceBase(
                    pHwDevExt,                  // HwDeviceExtension
                    ConfigInfo->AdapterInterfaceType,   // AdapterInterfaceType
                    ConfigInfo->SystemIoBusNumber,      // SystemIoBusNumber
                    ConfigInfo->AccessRanges[0].RangeStart,
                    0x4,                    // NumberOfBytes
                    TRUE                   // InIoSpace - Memory mapped
                    );

  DEBUG_PRINT((DebugLevelVerbose,"3520 Base Address  = %lx\n", ioBase));
	pHwDevExt->ioBaseLocal		= ioBase;

    ioBase = MpegPortGetDeviceBase(
                    pHwDevExt,                  // HwDeviceExtension
                    ConfigInfo->AdapterInterfaceType,   // AdapterInterfaceType
                    ConfigInfo->SystemIoBusNumber,      // SystemIoBusNumber
                    ConfigInfo->AccessRanges[1].RangeStart,
                    0x4,                    // NumberOfBytes
                    TRUE                               // InIoSpace - Memory mapped
                    );

  DEBUG_PRINT((DebugLevelVerbose,"PCI9060 Address = %lx\n", ioBase));

	pHwDevExt->ioBasePCI9060 = ioBase;
	pHwDevExt->Irq	= IrqLevel;
#else
	BOARDINFO BoardInfo;
	*Again = FALSE;
	DeviceExtension = DeviceExtension;
	ConfigInfo = ConfigInfo;
	HwContext = HwContext;
	BusInformation = BusInformation;
	ArgString = ArgString;

	mpstHwFindAdaptor(&BoardInfo);
	pHwDevExt->ioBaseLocal		= BoardInfo.ioBaseLocal;
	pHwDevExt->ioBasePCI9060	= BoardInfo.ioBasePCI9060;
	pHwDevExt->Irq	= BoardInfo.Irq;
#endif
	pHwDevExt->VideoDeviceExt.videoSTC = 0;
	pHwDevExt->AudioDeviceExt.audioSTC = 0;
	pHwDevExt->AudioDeviceExt.pCurrentMrb = NULL;
	pHwDevExt->VideoDeviceExt.pCurrentMrb = NULL;
	pHwDevExt->VideoDeviceExt.DeviceState = MpegStateStartup;
	pHwDevExt->AudioDeviceExt.DeviceState = MpegStateStartup;
	pHwDevExt->AudioDeviceExt.pCurrentMrb = NULL;
	pHwDevExt->VideoDeviceExt.pCurrentMrb = NULL;
	 DebugPrint((DebugLevelVerbose, "Exit : HwFindAparter()"));

	return MP_RETURN_FOUND;

}


/********************************************************************
*		Function Name : HwInterrupt
* 		Args : Pointer to Device Ext.
* 		Returns : TRUE or FALSE 
*		Purpose : Called by port driver if there is an interrupt
* 					 on the IRQ line. Must return False if it does not
*               Processes the interrupt
*
*		Revision History : Last modified on 15/7/95 by JBS
********************************************************************/
BOOLEAN HwInterrupt ( IN PVOID pDeviceExtension )
{
	// Call the interrupt handler should check if the interrupt belongs to
	BOOLEAN bRetValue;
	pDeviceExtension = pDeviceExtension;
	bRetValue = mpstHwInterrupt ();
	return bRetValue;
}

/********************************************************************
*		Function Name : HwStartIo
* 		Args : Pointer to Device Ext, Mini-Port Request Block (MRB)
* 		Returns : TRUE or FALSE 
*		Purpose : Main fuction which accepts the MRBs from port Driver
*	 				 Port driver calls this function for all the commands
*					 it wants to execute
*
*		Revision History : Last modified on 15/7/95 JBS
********************************************************************/
BOOLEAN	HwStartIo (
				IN PVOID DeviceExtension, 
				PMPEG_REQUEST_BLOCK pMrb
				)
{
	pMrb->Status = MrbStatusSuccess;
	switch (pMrb->Command)
	{
		case MrbCommandAudioCancel :
					miniPortCancelAudio(pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;

		case MrbCommandVideoCancel	:
					miniPortCancelVideo(pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;

		case MrbCommandVideoClearBuffer :
					miniPortClearVideoBuffer(pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
			  break;

		case MrbCommandOverlayEnable	:
					miniPortVideoEnable(pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
			  break;

		case MrbCommandOverlayDisable	:
					miniPortVideoDisable(pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
			  break;

		case MrbCommandAudioEndOfStream	:
					miniPortAudioEndOfStream(pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;
		case MrbCommandVideoEndOfStream	:
					miniPortVideoEndOfStream(pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;

		case MrbCommandAudioGetAttribute			:
					miniPortAudioGetAttribute (pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;
			

		case MrbCommandVideoGetAttribute			:
					miniPortVideoGetAttribute (pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;

		case MrbCommandOverlayGetAttribute		:
					miniPortOverlayGetAttribute (pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;
		case MrbCommandOverlayGetDestination 	:
					miniPortOverlayGetDestination(pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;
		case MrbCommandOverlayGetMode				:
					miniPortOverlayGetMode(pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;
		case MrbCommandAudioGetStc					:
					miniPortAudioGetStc(pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;
		case MrbCommandVideoGetStc					:
					miniPortVideoGetStc(pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;
		case MrbCommandOverlayGetVgaKey			:
					miniPortOverlayGetVgaKey(pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;

		case MrbCommandAudioPacket					:
					miniPortAudioPacket(pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;
		case MrbCommandVideoPacket					:
					miniPortVideoPacket(pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;
		case MrbCommandAudioPause					:
					miniPortAudioPause(pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;

		case MrbCommandVideoPause					:
					miniPortVideoPause(pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;

		case MrbCommandAudioPlay					:
					miniPortAudioPlay(pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;

		case MrbCommandVideoPlay					:
					miniPortVideoPlay(pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;
			
		case MrbCommandAudioQueryInfo				:
					miniPortAudioQueryInfo (pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;

		case MrbCommandVideoQueryInfo				:
					miniPortVideoQueryInfo (pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;
			
		case MrbCommandAudioReset					:
					miniPortAudioReset (pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;

		case MrbCommandVideoReset					:
					miniPortVideoReset (pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;

		case MrbCommandAudioSetAttribute			:
					miniPortAudioSetAttribute ( pMrb , (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;

		case MrbCommandOverlaySetAttribute 		:
					miniPortOverlaySetAttribute ( pMrb , (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;

		case MrbCommandOverlaySetBitMask	 		:
					miniPortOverlaySetBitMask ( pMrb , (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;

		case MrbCommandOverlaySetDestination 	:
					miniPortOverlaySetDestination ( pMrb , (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;
		case MrbCommandOverlaySetMode				:
					miniPortOverlaySetMode ( pMrb , (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;
		case MrbCommandAudioSetStc					:
					miniPortAudioSetStc ( pMrb , (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;
		case MrbCommandVideoSetStc					:
					miniPortVideoSetStc ( pMrb, (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;
		case MrbCommandOverlaySetVgaKey			:
					miniPortOverlaySetVgaKey ( pMrb , (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;

		case MrbCommandAudioStop					:
					miniPortAudioStop( pMrb , (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;

		case MrbCommandVideoStop					:
					miniPortVideoStop( pMrb , (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;

		case MrbCommandOverlayUpdateClut			:
					miniPortOverlayUpdateClut ( pMrb , (PHW_DEVICE_EXTENSION)DeviceExtension);
				break;
	}
	return TRUE;
}
#ifdef NT
VOID HostDisableIT(VOID)
{
		// Has to be implemented !! - JBS
}

VOID HostEnableIT(VOID)
{
		// Has to be implemented !! - JBS

}	
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\icd2051.h ===
#ifndef __ICD2051_H
#define __ICD2051_H
//----------------------------------------------------------------------------
// ICD2051.H
//----------------------------------------------------------------------------
// PLL (Cypress ICD2051) programming
//----------------------------------------------------------------------------
// Copyright SGS Thomson Microelectronics  !  Version alpha  !  Jan 1st, 1995
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                               Include files
//----------------------------------------------------------------------------
#include "stdefs.h"

//----------------------------------------------------------------------------
//                               Exported Types
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Exported Variables
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Exported Constants
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Exported Functions
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// One line function description (same as in .C)
//----------------------------------------------------------------------------
// In     :
//   BOOL PLLA : select PLLA (TRUE) or PLLB (FALSE) to be programmed
//   BOOL Data : data to be send (12 less significant bits)
// Out    : -
// InOut  : -
// Global : -
// Return : -
//----------------------------------------------------------------------------
VOID ICD2051SendWord(BOOL PLLA, DWORD Data);

//------------------------------- End of File --------------------------------
#endif // #ifndef __ICD2051_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\mpaudio.h ===
/*******************************************************************
*
*				 MPAUDIO.H
*
*				 Copyright (C) 1995 SGS-THOMSON Microelectronics.
*
*
*				 Prototypes for NPAUDIO.C
*
*******************************************************************/

#ifndef __MPAUDIO_H__
#define __MPAUDIO_H__
ULONG miniPortAudioStop (PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortAudioSetStc(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortAudioReset(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortAudioSetAttribute(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortAudioQueryInfo (PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortAudioPlay(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortAudioPause(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortAudioPacket(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortAudioGetStc(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortAudioGetAttribute(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortAudioEndOfStream(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortAudioDisable(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortAudioEnable(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
ULONG miniPortCancelAudio(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION);
#endif //__MPAUDIO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\mpaudio.c ===
/*******************************************************************
*
*				 MPAUDIO.C
*
*				 Copyright (C) 1995 SGS-THOMSON Microelectronics.
*
*
*				 PORT/MINIPORT Interface Audio Routines
*
*******************************************************************/
#include "common.h"
#include "mpegmini.h"
#include "mpst.h"
#include "mpinit.h"
#include "mpaudio.h"
#include "debug.h"

ULONG miniPortCancelAudio(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;
	// TBD
	 DEBUG_PRINT((DebugLevelTrace,"mrbCancelAudio"));
	pMrb->Status = MrbStatusSuccess;
	if(pHwDevExt->AudioDeviceExt.pCurrentMrb != NULL)
	{
		// Still to send a packet
		pHwDevExt->AudioDeviceExt.pCurrentMrb->Status = MrbStatusCancelled;
      MpegPortNotification(RequestComplete,AudioDevice,pHwDevExt,
			pHwDevExt->AudioDeviceExt.pCurrentMrb);
      MpegPortNotification(NextRequest,AudioDevice,pHwDevExt);
		// Now kill the timer
      MpegPortNotification(RequestTimerCall, AudioDevice,
                             pHwDevExt, NULL, 0);
		pHwDevExt->AudioDeviceExt.pCurrentMrb = NULL;
	}
	return dwErrCode; 	

}
ULONG miniPortAudioEnable(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;
	pHwDevExt = pHwDevExt;// Remove Warning 
	pMrb = pMrb; // Remove Warning 
	 DEBUG_PRINT((DebugLevelTrace,"mrbAudioEnable"));
	mpstEnableAudio(TRUE);
	return dwErrCode; 	
}

ULONG miniPortAudioDisable(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	pHwDevExt = pHwDevExt;// Remove Warning 
	pMrb = pMrb; // Remove Warning 
	 DEBUG_PRINT((DebugLevelTrace,"mrbAudioDisable"));
	mpstEnableAudio(FALSE);
	return dwErrCode; 	
}


ULONG miniPortAudioEndOfStream(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	// TBD
	 DEBUG_PRINT((DebugLevelTrace,"mrbAudioEOS"));

	if(pHwDevExt->AudioDeviceExt.pCurrentMrb != NULL)
	{
		// Still to send a packet
		pHwDevExt->AudioDeviceExt.pCurrentMrb->Status = MrbStatusCancelled;
      MpegPortNotification(RequestComplete,AudioDevice,pHwDevExt,
			pHwDevExt->AudioDeviceExt.pCurrentMrb);
      MpegPortNotification(NextRequest,AudioDevice,pHwDevExt);
		// Now kill the timer
      MpegPortNotification(RequestTimerCall, AudioDevice,
                             pHwDevExt, NULL, 0);
		pHwDevExt->AudioDeviceExt.pCurrentMrb = NULL;
	}
	pMrb->Status = MrbStatusSuccess;
   MpegPortNotification(RequestComplete,AudioDevice,pHwDevExt,pMrb);
  	MpegPortNotification(NextRequest,AudioDevice,pHwDevExt);

	return dwErrCode; 	
}


ULONG miniPortAudioGetAttribute(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	 DEBUG_PRINT((DebugLevelTrace,"mrbAudioGetAttr"));
	pHwDevExt = pHwDevExt;// Remove Warning 
	switch(pMrb->CommandData.pAttribute->Attribute)
	{
	// STB
		case MpegAttrAudioBass 					:						
		case MpegAttrAudioChannel 				:						
		case MpegAttrAudioMode	 				:						
		case MpegAttrMaximumAudioAttribute 	:						
		case MpegAttrAudioTreble 				:						
	         pMrb->Status = MrbStatusUnsupportedComand;
		break;

	// TBI
		case MpegAttrAudioVolumeLeft 	:						
            pMrb->CommandData.pAttribute->Value = 20;
				break;
		case MpegAttrAudioVolumeRight 	:						
            pMrb->CommandData.pAttribute->Value = 20;
			break;
	}
	return dwErrCode; 	
}


ULONG miniPortAudioGetStc(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;
	pHwDevExt = pHwDevExt; // Remove Warning 
	pMrb = pMrb; // Remove Warning 
#if 0
	// TBI
	 DEBUG_PRINT((DebugLevelTrace,"mrbAudioGetStc"));
   *pMrb->CommandData.pTimestamp = pHwDevExt->AudioDeviceExt.audioSTC;
//   pMrb->Status = MrbStatusUnsupportedComand;
#endif
	return dwErrCode; 	
}


ULONG miniPortAudioPacket(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	ULONG uSent, uLen;
	PUCHAR pPacket;

	pHwDevExt->AudioDeviceExt.audioSTC = pMrb->CommandData.pPacket->PtsValue;
	uLen = (pMrb->CommandData.pPacket->PacketTotalSize); // Send Audio Packet
	pPacket = 	(PUCHAR)(pMrb->CommandData.pPacket->PacketData);
	uSent = mpstSendAudio((PUCHAR)(pPacket),uLen);
	if(uSent != uLen)
	{
		  pHwDevExt->AudioDeviceExt.pCurrentMrb = pMrb;
		  pHwDevExt->AudioDeviceExt.ByteSent = uSent;
	     MpegPortNotification( RequestTimerCall, AudioDevice,
                  pHwDevExt, AudioTimerCallBack,AUDIO_PACKET_TIMER);
   	  MpegPortNotification(StatusPending,AudioDevice, pHwDevExt, pMrb);
	}
	else
	{
		pMrb->Status = MrbStatusSuccess;
   	MpegPortNotification(RequestComplete,AudioDevice,pHwDevExt,pMrb);
  		MpegPortNotification(NextRequest,AudioDevice,pHwDevExt);
		pHwDevExt->AudioDeviceExt.pCurrentMrb = NULL;
	}
	return dwErrCode; 	
}

ULONG miniPortAudioPause(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	pMrb = pMrb; // Remove Warning 
	 DEBUG_PRINT((DebugLevelTrace,"mrbAudioPause"));
	mpstAudioPause();
	pHwDevExt->AudioDeviceExt.DeviceState = MpegStatePaused;
	return dwErrCode; 	
}

ULONG miniPortAudioPlay(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;
	pHwDevExt = pHwDevExt; // Remove Warning
	pMrb = pMrb; 
	 DEBUG_PRINT((DebugLevelTrace,"mrbAudioPlay"));
	pHwDevExt->AudioDeviceExt.DeviceState = MpegStatePlaying;
	return dwErrCode; 	
}


ULONG miniPortAudioQueryInfo (PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	 DEBUG_PRINT((DebugLevelTrace,"mrbAudioInfo"));
	pMrb -> CommandData.pDeviceInfo->DeviceState = 
			pHwDevExt->AudioDeviceExt.DeviceState;
	pMrb -> CommandData.pDeviceInfo->DecoderBufferSize = 
			mpstAudioDecoderBufferSize();
	pMrb -> CommandData.pDeviceInfo->DecoderBufferFullness = 
			mpstAudioDecoderBufferFullness();
	return dwErrCode; 	
}



ULONG miniPortAudioReset(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	// TBC
	 DEBUG_PRINT((DebugLevelTrace,"mrbAudioReset"));
	pHwDevExt->AudioDeviceExt.DeviceState = MpegStatePaused;
	pMrb->Status = MrbStatusSuccess;
	return dwErrCode; 	
}


ULONG miniPortAudioSetAttribute(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	pHwDevExt = pHwDevExt; // Remove Warning 
	 DEBUG_PRINT((DebugLevelTrace,"mrbAudioSetAttr"));
	switch(pMrb->CommandData.pAttribute->Attribute)
	{
		case MpegAttrAudioBass 			:						
		case MpegAttrAudioChannel 		:						
		case MpegAttrAudioMode	 		:						
		case MpegAttrAudioTreble 		:						
			dwErrCode = ERROR_COMMAND_NOT_IMPLEMENTED;
		break;

	// TBI
		case MpegAttrMaximumAudioAttribute 	:						
		case MpegAttrAudioVolumeLeft 	:						
		case MpegAttrAudioVolumeRight	:						
			dwErrCode = ERROR_COMMAND_NOT_IMPLEMENTED;
			break;
	}
	return dwErrCode; 	
}


ULONG miniPortAudioSetStc(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;
	pHwDevExt = pHwDevExt; // Remove Warning 
	pMrb = pMrb; // Remove Warning 
#if 0
	// TBI
	 DEBUG_PRINT((DebugLevelTrace,"mrbAudioSetSTC"));
//   pMrb->Status = MrbStatusUnsupportedComand;
#endif
	return dwErrCode; 	
}


ULONG miniPortAudioStop (PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	// TBC
	 DEBUG_PRINT((DebugLevelTrace,"mrbAudioStop"));
	if(pHwDevExt->AudioDeviceExt.pCurrentMrb != NULL)
	{
		// Still to send a packet
		pHwDevExt->AudioDeviceExt.pCurrentMrb->Status = MrbStatusCancelled;
      MpegPortNotification(RequestComplete,AudioDevice,pHwDevExt,
			pHwDevExt->AudioDeviceExt.pCurrentMrb);
      MpegPortNotification(NextRequest,AudioDevice,pHwDevExt);

		// Now kill the timer
      MpegPortNotification(RequestTimerCall, AudioDevice,
                             pHwDevExt, NULL, 0);
		pHwDevExt->AudioDeviceExt.pCurrentMrb = NULL;
	}

	pHwDevExt->AudioDeviceExt.DeviceState = MpegStatePaused;
	pMrb->Status = MrbStatusSuccess;
	return dwErrCode; 	
}


VOID AudioTimerCallBack(IN PHW_DEVICE_EXTENSION pHwDevExt)
{
	PUCHAR pPacket;
	ULONG	uLen, uSent, byteSent;
	
	PMPEG_REQUEST_BLOCK pMrb;

	pMrb = pHwDevExt->AudioDeviceExt.pCurrentMrb;
	byteSent = pHwDevExt->AudioDeviceExt.ByteSent;
	uLen = pMrb->CommandData.pPacket->PacketTotalSize - byteSent; 
	pPacket = 	(PUCHAR)(pMrb->CommandData.pPacket->PacketData+byteSent);
	uSent = mpstSendAudio((PUCHAR)(pPacket),uLen);
	if(uSent != uLen)
	{
			pHwDevExt->AudioDeviceExt.ByteSent += uSent;
      	MpegPortNotification( RequestTimerCall, AudioDevice,
                 pHwDevExt, AudioTimerCallBack,AUDIO_PACKET_TIMER);
			return;
	}
	else
	{
		pMrb->Status = MrbStatusSuccess;
	   MpegPortNotification(RequestComplete,AudioDevice,pHwDevExt,pMrb);
	  	MpegPortNotification(NextRequest,AudioDevice,pHwDevExt);
		pHwDevExt->AudioDeviceExt.pCurrentMrb = NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\mpst.h ===
///////////////////////////////////////////////////////////////////////////
//
//						File : mpst.h
//
//		 Prototype for mpst.c
//		 i/f between Miniport Layer and core driver
//
//
///////////////////////////////////////////////////////////////////////////
#ifndef __MPST_H__
#define __MPST_H__
#include "mpinit.h" 
typedef struct tagBusInfo
{
   ULONG 			NumberOfAccessRanges;         
   INTERFACE_TYPE AdapterInterfaceType; 
   USHORT 			VendorIdLength;              //   size in bytes of VendorId
	 PVOID  			VendorId;                    //   points to ASCII byte string identifying
   USHORT 			DeviceIdLength;              //   size in bytes of DeviceId
   PVOID  			DeviceId;                    //   points to ASCII byte string identifying
	 BOOLEAN 			NoDynamicRelocation;        // On dynamically configurable I/O busses, when set
} BUSINFO, *PBUSINFO;

typedef struct tagBoardInfo
{
	PUSHORT	ioBasePCI9060; // Eval3520 PCI Specific address
	PUSHORT	ioBaseLocal;  // Base address
	UCHAR   Irq;
} BOARDINFO, *PBOARDINFO;

BOOLEAN mpstDriverEntry (OUT PBUSINFO pBusInfo);
BOOLEAN mpstHwFindAdaptor (OUT PBOARDINFO pBoardInfo);
BOOLEAN mpstHwInitialize(PHW_DEVICE_EXTENSION pHwDevExt);
BOOLEAN mpstHwUnInitialize(VOID);
BOOLEAN mpstHwInterrupt(VOID);
VOID mpstEnableVideo (BOOLEAN bFlag);
ULONG mpstVideoPacket(PMPEG_REQUEST_BLOCK pMrb);
VOID mpstVideoPause(VOID);
VOID mpstVideoPlay(VOID);
VOID mpstVideoStop(VOID);
ULONG mpstVideoDecoderBufferSize(VOID);
ULONG mpstVideoDecoderBufferFullness(VOID);
VOID mpstVideoReset(VOID);
VOID mpstEnableAudio (BOOLEAN bFlag);
ULONG mpstSendAudio(UCHAR *pData, ULONG uLen);
VOID mpstAudioPause(VOID);
VOID mpstAudioPlay(VOID);
VOID mpstAudioStop(VOID);
ULONG mpstAudioDecoderBufferSize(VOID);
ULONG mpstAudioDecoderBufferFullness(VOID);
VOID mpstAudioReset(VOID);
VOID portWritePortBuffer16(IN PUSHORT Port, IN PUSHORT Data, ULONG Size);
#endif // __MPST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\mpst.c ===
///////////////////////////////////////////////////////////////////////////
//
//						File : mpst.c
//
//		 i/f between Miniport Layer and core driver
//
//   	 Copyright  1995 SGS-THOMSON Microelectronics.
//		 All Rights Reserved.
//
///////////////////////////////////////////////////////////////////////////

#ifdef DOS
	#include "pnp.h"
	#include "irq.h"
	#include "basicio.h"
	#include "delay.h"
#endif

#ifdef STi3520A
	#include "sti3520A.h"
#else
	#include "sti3520.h"
#endif

#include "common.h"
#include "mpegmini.h"
#include "stctrl.h"
#include "stvideo.h"
#include "staudio.h"
#include "mpst.h"
#include "stllapi.h"
#include "aal.h" // BoardInit
#include "display.h"
#include "error.h"
#include "debug.h"

static WORD gLocalIOBaseAddress;
static WORD gPCI9060IOBaseAddress;

// Global Variables to access Control and Card
CTRL  FAR *pCtrl, Ctrl;
CARD FAR *pCard, Card;
UCHAR portReadPort8(IN PUCHAR Port);
USHORT portReadPort16(IN PUSHORT Port);
VOID portWritePort16(IN PUSHORT Port, USHORT Data);
VOID portWritePort8(IN PUCHAR Port, UCHAR Data);

/////////////////////////////////////////////////////////////////////////
//
//			  Function : mpstDriverEntry
//			  Args : Pointer to BusInfo struct
//			  Returns : TRUE if success
//
//			  Purpose:
//			  First function to be called into miniport core i/f.
//			  All one time initialization should go here. This is
//			  called only when driver is loaded. It will not be called
//			  again for the current NT session
//
//			  Last Modified 10.1.96 by JBS
//
/////////////////////////////////////////////////////////////////////////

BOOLEAN mpstDriverEntry (OUT PBUSINFO pBusInfo)
{
	// For the time being doing it here
	// Has to be done at low layer once
	// PCI stuff has been put in - JBS
	 pBusInfo->NumberOfAccessRanges = 0x1000;
	 pBusInfo->AdapterInterfaceType = PCIBus;
	 pBusInfo->VendorId = "104A"; //??????????????????????
	 pBusInfo->VendorIdLength = 4;
	 pBusInfo->DeviceId = "3520"; //??????????????????????
	 pBusInfo->DeviceIdLength = 4;
	 pBusInfo->NoDynamicRelocation = TRUE;
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////
//
//			  Function : mpstHwFindAdapter
//			  Args : Pointer to BoardInfo struct
//			  Returns : TRUE if found
//
//			  Purpose:
//	  		  Find the adapter and return the Base Address and IRQ
//
//			  Last Modified 10.1.96 by JBS
//
/////////////////////////////////////////////////////////////////////////
BOOLEAN mpstHwFindAdaptor (OUT PBOARDINFO pBoardInfo)
{
#ifdef DOS
	BOOL BoardFound;

	BoardFound = HostGetBoardConfig(0x3520,
																	0x104A,
																	&(pBoardInfo->Irq),
																	&gPCI9060IOBaseAddress,
																	&gLocalIOBaseAddress);
	pBoardInfo->ioBasePCI9060 = (PUSHORT)gPCI9060IOBaseAddress;
	pBoardInfo->ioBaseLocal   = (PUSHORT)gLocalIOBaseAddress;
	return BoardFound;
//NT-MOD
//#else
//	#error Not implemented for NT !
//NT-MOD
#endif
}

/////////////////////////////////////////////////////////////////////////
//
//			  Function : mpstHwInitialize
//			  Args : Pointer to BoardInfo struct
//			  Returns : TRUE if success
//
//			  Purpose:
//			  Initialize the pointers to different functions
// 		  and also intialize the board, Ctrl class etc
//
//			  Last Modified 10.1.96 by JBS
//
/////////////////////////////////////////////////////////////////////////
BOOLEAN mpstHwInitialize(PHW_DEVICE_EXTENSION pHwDevExt)
{
	// Initialize the pointers to different functions
	// and also intialize the board, Ctrl class etc
	USHORT grab;

	// Initialize the pointers to different functions
	// and also intialize the board, Ctrl class etc
	pCard = &Card;
//	pCard->ioLogBase = pHwDevExt->ioBase;
//	pCard->ioLogRead = pHwDevExt->ioRead;
//	pCard->ioLogWrite = pHwDevExt->ioWrite;
//	pCard->ioLogReadWrite = pHwDevExt->ioReadWrite;
//	pCard->ioLogCDF = pHwDevExt->ioCDF;
//	pCard->fnEnableIT				= HostEnableIT;
//	pCard->fnDisableIT 			= HostDisableIT;

#ifdef NT
	gPCI9060IOBaseAddress = pHwDevExt->ioBasePCI9060;
	gLocalIOBaseAddress = pHwDevExt->ioBaseLocal;

	STiInit(BoardVideoRead,
					BoardVideoWrite,
					BoardVideoSend,
					BoardVideoSetDisplayMode,
					BoardAudioRead,
					BoardAudioWrite,
					BoardAudioSend,
					BoardAudioSetSamplingFrequency,
					BoardHardReset,
					BoardEnterInterrupt,
					BoardLeaveInterrupt,
					HostEnableIT,
					HostDisableIT,
					MpegPortStallExecution);

	if (!BoardInit(gLocalIOBaseAddress,
								 gPCI9060IOBaseAddress,
								 MpegPortReadPortUchar,
								 MpegPortReadPortUshort,
								 MpegPortReadPortUlong,
								 MpegPortWritePortUchar,
								 MpegPortWritePortUshort,
								 MpegPortWritePortUlong,
								 MpegPortWritePortBufferUchar,
								 MpegPortWritePortBufferUshort,
								 MpegPortWritePortBufferUlong,
								 MpegPortStallExecution)) {
		DisplayErrorMessage();
		return FALSE;
	}
#elif defined(DOS)
	STiInit(BoardVideoRead,
					BoardVideoWrite,
					BoardVideoSend,
					BoardVideoSetDisplayMode,
					BoardAudioRead,
					BoardAudioWrite,
					BoardAudioSend,
					BoardAudioSetSamplingFrequency,
					BoardHardReset,
					BoardEnterInterrupt,
					BoardLeaveInterrupt,
					HostEnableIT,
					HostDisableIT,
					HostWaitMicroseconds);
	if (!BoardInit(gLocalIOBaseAddress,
								 gPCI9060IOBaseAddress,
								 HostRead8,
								 HostRead16,
								 HostRead32,
								 HostWrite8,
								 HostWrite16,
								 HostWrite32,
								 HostSendBlock8,
								 HostSendBlock16,
								 HostSendBlock32,
								 HostWaitMicroseconds)) {
		DisplayErrorMessage();
		return FALSE;
	}
#endif
	CardOpen ( );
/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//need to typecast
#ifdef DOS
	if ( CardWriteAdress ((WORD)(pCard->ioLogBase)) != NO_ERROR )
#else
	if ( CardWriteAdress ((pCard->ioLogBase)) != NO_ERROR )
#endif
	{
		DEBUG_PRINT ((DebugLevelFatal, "Error writting to the board !!"));
		if ( pCard != NULL )
			CardClose();
		return ERROR_CARD_NOT_FOUND;
	}
	DEBUG_PRINT ((DebugLevelVerbose, "writting to the board ok."));
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */

	pCtrl = &Ctrl;
	CtrlOpen( pCtrl);

	if ( CtrlGetErrorMsg (pCtrl) == NEW_ERR_V )
	{
		DEBUG_PRINT((DebugLevelError,"Error creating video class"));
		return ERROR_NOT_ENOUGH_MEMORY;
	}
	if ( CtrlGetErrorMsg (pCtrl) == NEW_ERR_A )
	{
		DEBUG_PRINT((DebugLevelError,"Error creating audio class"));
		return ERROR_NOT_ENOUGH_MEMORY;
	}

	grab = CtrlInitDecoder (pCtrl);
	if ( grab != NO_ERROR ) {
		#ifdef STi3520
		if (!IsChipSTi3520()) {
			HostDisplay(DISPLAY_NORMAL, "No STi3520 has been detected, either this board : \n"
																	"- is an EVAL3520A\n"
																	"- is not working\n");
		}
		#elif defined(STi3520A)
		if (IsChipSTi3520()) {
			HostDisplay(DISPLAY_NORMAL, "No STi3520A has been detected, either this board : \n"
																	"- is an EVAL3520\n"
																	"- is not working\n");
		}
		#else
			#error This SW should be compile with either STi3520 or STi3520A defined !
		#endif

		DebugPrint((DebugLevelError, "Error in InitDecoder #%x", grab ));
		if (grab != ERR_NO_ERROR)
			DisplayErrorMessage();
		return ((BOOLEAN)(grab));
	}
	CtrlSetRightVolume ( 0 );	   // Set Audio volume to its
	CtrlSetLeftVolume (0);
	pCard->bVideoDecoding = FALSE;
	pCard->bAudioDecoding = FALSE;
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////
//
//			  Function : mpstHwUnInitialize
//			  Args : Pointer to BoardInfo struct
//			  Returns : TRUE if success
//
//			  Purpose:
//	  		  Uninitialize the board
//
//			  Last Modified 10.1.96 by JBS
//
/////////////////////////////////////////////////////////////////////////
BOOLEAN mpstHwUnInitialize()
{
	CtrlStop (pCtrl, CTRL_BOTH);
	if(pCtrl != NULL)
		CtrlClose(pCtrl);
	if ( pCard != NULL )
		CardClose( );
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////
//
//			  Function : mpstHwInterrupt
//			  Args : none
//			  Returns : TRUE if success	
//
//			  Purpose:
//	  		  Process the interrupt
//
//			  Last Modified 10.1.96 by JBS
//
/////////////////////////////////////////////////////////////////////////
BOOLEAN mpstHwInterrupt(void)
{
	return(IntCtrl());
}

void mpstEnableVideo (BOOLEAN bFlag)
{
	CtrlEnableVideo(pCtrl, bFlag);	
}

ULONG mpstVideoPacket(PMPEG_REQUEST_BLOCK pMrb)
{
	ULONG uSent=0;
	PUCHAR pPacket;
	U16	uLen;

#ifdef DOS
	if(VideoGetErrorMsg(pCard->pVideo) != 0) {
		HostDisplay(DISPLAY_NORMAL, "Error in Video errCode = %x!!", VideoGetErrorMsg(pCard->pVideo));
	}
	if(AudioGetErrorMsg(pCard->pAudio) != 0) {
		HostDisplay(DISPLAY_NORMAL, "Error in Audio !!");
	}
#endif	
	if(pMrb->CommandData.pPacket->PtsValue)
	{
		VideoLatchPTS(pCard->pVideo, (U32)(pMrb->CommandData.pPacket->PtsValue));
		pMrb->CommandData.pPacket->PtsValue = 0;
	}
	// LATCH PTS in FIFO
	uLen = (U16)(pMrb->CommandData.pPacket->PacketPayloadSize);
	pPacket = 	(PUCHAR)(pMrb->CommandData.pPacket->PacketData+
							pMrb->CommandData.pPacket->PacketHeaderSize) ;
// AVSYNC BUG to be fixed here.
// Dont Latch PTS every time.
	uSent = SendVideoIfPossible(pPacket, uLen);
	return uSent;	
}

void mpstVideoPause(void)
{
	CtrlPause(pCtrl, CTRL_BOTH);
}

void mpstVideoPlay(void)
{
	VideoRestoreInt ( pCard->pVideo  );	   // Restore Video interrupt mask
	CtrlPlay(pCtrl, CTRL_BOTH);
}


void mpstVideoStop(void)
{
	CtrlPause(pCtrl, CTRL_BOTH);
	CardOpen ( );
	CtrlOpen ( pCtrl);
	CtrlInitDecoder(pCtrl);
	VideoMaskInt ( pCard->pVideo  );	   
}

ULONG mpstVideoDecoderBufferSize()
{
	//TBI 
	return BUF_FULL;
}

ULONG mpstVideoDecoderBufferFullness()
{
	//TBI 
	return VideoGetBBL();
}
void mpstVideoReset(void)
{
	CardOpen ( );
	CtrlOpen ( pCtrl);
	CtrlInitDecoder(pCtrl);
}

void mpstEnableAudio (BOOLEAN bFlag)
{
	CtrlEnableAudio(pCtrl, bFlag);	
}

ULONG mpstSendAudio(UCHAR *pData, ULONG uLen)
{
	ULONG uSent;
	uSent = SendAudioIfPossible((PVOID)pData, uLen);
	return uSent;
}

void mpstAudioPause()
{
	CtrlPause(pCtrl, CTRL_BOTH);
}

void mpstAudioPlay()
{
	AudioRestoreInt (pCard->pAudio);	   // Restore Audio interrupt mask
	CtrlPlay(pCtrl, CTRL_BOTH);
}

void mpstAudioStop()
{
	AudioMaskInt();
}


ULONG mpstAudioDecoderBufferSize()
{
	//TBI 
	return 100; 
}

ULONG mpstAudioDecoderBufferFullness()
{
	//TBI 
	return AudioRead(FRAME_NUMBER) & 0x7F;
}

void mpstAudioReset(void)
{
	//TBI
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\mpvideo.c ===
/*******************************************************************
*
*				 MPVIDEO.C
*
*				 Copyright (C) 1995 SGS-THOMSON Microelectronics.
*
*
*				 PORT/MINIPORT Interface Video Routines
*
*******************************************************************/

#include "common.h"
#include "mpegmini.h"
#include "mpst.h"
#include "mpinit.h"
#include "mpvideo.h"
#include "debug.h"

ULONG miniPortCancelVideo(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;
	// TBD
	 DEBUG_PRINT((DebugLevelTrace,"mrbCancelVideo"));
	pMrb->Status = MrbStatusSuccess;

	if(pHwDevExt->VideoDeviceExt.pCurrentMrb != NULL)
	{
		// Still to send a packet
		pHwDevExt->VideoDeviceExt.pCurrentMrb->Status = MrbStatusCancelled;
      MpegPortNotification(RequestComplete,VideoDevice,pHwDevExt,
			pHwDevExt->VideoDeviceExt.pCurrentMrb);
      MpegPortNotification(NextRequest,VideoDevice,pHwDevExt);
		// Now kill the timer
      MpegPortNotification(RequestTimerCall, VideoDevice,
                             pHwDevExt, NULL, 0);
		pHwDevExt->VideoDeviceExt.pCurrentMrb = NULL;
	}

	return dwErrCode; 	
}

ULONG miniPortClearVideoBuffer(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	// STB
	 DEBUG_PRINT((DebugLevelTrace,"mrbClearVideoBuffer"));
	pHwDevExt = pHwDevExt; // Remove Warning 
	pMrb = pMrb; // Remove Warning 
	dwErrCode = ERROR_COMMAND_NOT_IMPLEMENTED;
	return dwErrCode; 	
}

ULONG miniPortVideoEnable(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	pHwDevExt = pHwDevExt; // Remove Warning 
	pMrb = pMrb; // Remove Warning 
	DEBUG_PRINT((DebugLevelTrace,"mrbVideoEnable"));
	mpstEnableVideo ( TRUE );
	return dwErrCode; 	
}


ULONG miniPortVideoDisable(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	pHwDevExt = pHwDevExt; // Remove Warning 
	pMrb = pMrb; // Remove Warning 
	 DEBUG_PRINT((DebugLevelTrace,"mrbVideoDisable"));
	mpstEnableVideo(FALSE);
	return dwErrCode; 	
}

ULONG miniPortVideoEndOfStream(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	// TBD
	 DEBUG_PRINT((DebugLevelTrace,"mrbVideoEOS"));
	pHwDevExt->VideoDeviceExt.DeviceState = MpegStatePaused;

	if(pHwDevExt->VideoDeviceExt.pCurrentMrb != NULL)
	{
		// Still to send a packet
		pHwDevExt->VideoDeviceExt.pCurrentMrb->Status = MrbStatusCancelled;
      MpegPortNotification(RequestComplete,VideoDevice,pHwDevExt,
			pHwDevExt->VideoDeviceExt.pCurrentMrb);
      MpegPortNotification(NextRequest,VideoDevice,pHwDevExt);
		// Now kill the timer
      MpegPortNotification(RequestTimerCall, VideoDevice,
                             pHwDevExt, NULL, 0);
		pHwDevExt->VideoDeviceExt.pCurrentMrb = NULL;
	}
	pMrb->Status = MrbStatusSuccess;
   MpegPortNotification(RequestComplete,VideoDevice,pHwDevExt,pMrb);
  	MpegPortNotification(NextRequest,VideoDevice,pHwDevExt);
	pHwDevExt->VideoDeviceExt.pCurrentMrb = NULL;
	return dwErrCode; 	
}


ULONG miniPortVideoGetAttribute(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	pHwDevExt = pHwDevExt; // Remove Warning 
	DEBUG_PRINT((DebugLevelTrace,"mrbVideoGetAttr"));
	switch(pMrb->CommandData.pAttribute->Attribute)
	{
	// STB
		case MpegAttrVideoAGC 			:						
		case MpegAttrVideoChannel 		:						
		case MpegAttrVideoClamp	 		:						
		case MpegAttrVideoCoring 		:						
		case MpegAttrVideoGain	 		:						
		case MpegAttrVideoGenLock 		:						
		case MpegAttrVideoHue	 		:						
		case MpegAttrVideoMode	 		:						
		case MpegAttrVideoSaturation	:						
		case MpegAttrVideoSharpness 	:						
		case MpegAttrVideoSignalType	:						
         pMrb->Status = MrbStatusUnsupportedComand;
		break;
	}
	return dwErrCode; 	
}


ULONG miniPortVideoGetStc(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	pHwDevExt = pHwDevExt; // Remove Warning 
	pMrb = pMrb; // Remove Warning 
#if 0
	// TBI
	 DEBUG_PRINT((DebugLevelTrace,"mrbVideoGetStc"));
   *pMrb->CommandData.pTimestamp = pHwDevExt->VideoDeviceExt.videoSTC;
//   pMrb->Status = MrbStatusUnsupportedComand;
#endif
	return dwErrCode; 	
}

ULONG miniPortVideoPacket(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;
	ULONG uSent=0;

   if(pHwDevExt->VideoDeviceExt.pCurrentMrb != NULL)
	{
		 DEBUG_PRINT((DebugLevelError,"Prev Video Mrb not NULL!!"));
		return 0;
	}
	pHwDevExt->VideoDeviceExt.videoSTC = pMrb->CommandData.pPacket->PtsValue;
	uSent = mpstVideoPacket(pMrb);

	if(uSent == 0)
	{
		  pHwDevExt->VideoDeviceExt.pCurrentMrb = pMrb;
        MpegPortNotification( RequestTimerCall, VideoDevice,
               pHwDevExt, VideoTimerCallBack,VIDEO_PACKET_TIMER);
  	     MpegPortNotification(StatusPending,VideoDevice, pHwDevExt, pMrb);
	}
	else
	{
		pMrb->Status = MrbStatusSuccess;
	   MpegPortNotification(RequestComplete,VideoDevice,pHwDevExt,pMrb);
	  	MpegPortNotification(NextRequest,VideoDevice,pHwDevExt);
		pHwDevExt->VideoDeviceExt.pCurrentMrb = NULL;
	}	
	return dwErrCode; 	
}

ULONG miniPortVideoPause(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;
	 DEBUG_PRINT((DebugLevelTrace,"mrbVideoPause"));
	pMrb = pMrb; // Remove Warning 
	mpstVideoPause ();
	pHwDevExt->VideoDeviceExt.DeviceState = MpegStatePaused;
	return dwErrCode; 	
}

ULONG miniPortVideoPlay(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	DEBUG_PRINT((DebugLevelTrace,"mrbVideoPlay"));
	mpstVideoPlay();
	pHwDevExt->VideoDeviceExt.DeviceState = MpegStatePlaying;
	pMrb = pMrb; // Remove Warning 
	return dwErrCode; 	
}

ULONG miniPortVideoQueryInfo (PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	 DEBUG_PRINT((DebugLevelTrace,"mrbVideoInfo"));
	pMrb -> CommandData.pDeviceInfo->DeviceState = 
				pHwDevExt->VideoDeviceExt.DeviceState;
	pMrb -> CommandData.pDeviceInfo->DecoderBufferSize = mpstVideoDecoderBufferSize();
	pMrb -> CommandData.pDeviceInfo->DecoderBufferFullness = mpstVideoDecoderBufferFullness();
	return dwErrCode; 	
}

ULONG miniPortVideoReset(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	// TBC
	 DEBUG_PRINT((DebugLevelTrace,"mrbVideoReset"));
	mpstVideoReset();
	pHwDevExt->VideoDeviceExt.DeviceState = MpegStatePaused;
	pMrb->Status = MrbStatusSuccess;
	return dwErrCode; 	
}


ULONG miniPortVideoSetAttribute(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	pHwDevExt = pHwDevExt; // Remove Warning 
	 DEBUG_PRINT((DebugLevelTrace,"mrbVideoSetAttr"));
	// STB
	switch(pMrb->CommandData.pAttribute->Attribute)
	{
		case MpegAttrVideoAGC 			:						
		case MpegAttrVideoChannel 		:						
		case MpegAttrVideoClamp	 		:						
		case MpegAttrVideoCoring 		:						
		case MpegAttrVideoGain	 		:						
		case MpegAttrVideoGenLock 		:						
		case MpegAttrVideoHue	 		:						
		case MpegAttrVideoMode	 		:						
		case MpegAttrVideoSaturation	:						
		case MpegAttrVideoSharpness 	:						
		case MpegAttrVideoSignalType	:						
			dwErrCode = ERROR_COMMAND_NOT_IMPLEMENTED;
		break;
	}
	return dwErrCode; 	
}

ULONG miniPortVideoSetStc(PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;
	pHwDevExt = pHwDevExt; // Remove Warning 
	pMrb = pMrb; // Remove Warning 
#if 0
	// TBI
	 DEBUG_PRINT((DebugLevelTrace,"mrbVideoSetSTC"));
//   pMrb->Status = MrbStatusUnsupportedComand;
#endif
	return dwErrCode; 	
}


ULONG miniPortVideoStop (PMPEG_REQUEST_BLOCK pMrb, PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG dwErrCode = NO_ERROR;

	// TBC
	 DEBUG_PRINT((DebugLevelTrace,"mrbVideoStop"));
	pHwDevExt->VideoDeviceExt.DeviceState = MpegStatePaused;
	if(pHwDevExt->VideoDeviceExt.pCurrentMrb != NULL)
	{
		// Still to send a packet
		pHwDevExt->VideoDeviceExt.pCurrentMrb->Status = MrbStatusCancelled;
      MpegPortNotification(RequestComplete,VideoDevice,pHwDevExt,
			pHwDevExt->VideoDeviceExt.pCurrentMrb);
      MpegPortNotification(NextRequest,VideoDevice,pHwDevExt);
		// Now kill the timer
      MpegPortNotification(RequestTimerCall, VideoDevice,
                             pHwDevExt, NULL, 0);
		pHwDevExt->VideoDeviceExt.pCurrentMrb = NULL;
	}
	mpstVideoStop();
	pMrb->Status = MrbStatusSuccess;
	return dwErrCode; 	
}

VOID VideoTimerCallBack(IN PHW_DEVICE_EXTENSION pHwDevExt)
{
	ULONG	uSent;
	
	PMPEG_REQUEST_BLOCK pMrb;

	pMrb = pHwDevExt->VideoDeviceExt.pCurrentMrb;
	uSent = mpstVideoPacket(pMrb);
	// No Space in Video Bit Buffer 
	if(uSent == 0)
	{
        MpegPortNotification( RequestTimerCall, VideoDevice,
                  pHwDevExt, VideoTimerCallBack, VIDEO_PACKET_TIMER);
			return;
	}
	else
	{
			pMrb->Status = MrbStatusSuccess;
		   MpegPortNotification(RequestComplete,VideoDevice,pHwDevExt,pMrb);
		  	MpegPortNotification(NextRequest,VideoDevice,pHwDevExt);
			pHwDevExt->VideoDeviceExt.pCurrentMrb = NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\staudio.c ===
//----------------------------------------------------------------------------
// STAUDIO.C
//----------------------------------------------------------------------------
// Description : small description of the goal of the module
//----------------------------------------------------------------------------
// Copyright SGS Thomson Microelectronics  !  Version alpha  !  Jan 1st, 1995
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Include files
//----------------------------------------------------------------------------
#include "stdefs.h"
#include "common.h"
#include "staudio.h"
#include "debug.h"
#include "error.h"
#ifdef STi3520A
	#include "sti3520A.h"
#else
	#include "sti3520.h"
#endif

//----------------------------------------------------------------------------
//                   GLOBAL Variables (avoid as possible)
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                            Private Constants
//----------------------------------------------------------------------------
#define SLOW_MODE	0
#define PLAY_MODE	1
#define FAST_MODE	2

#define IT_A        0 // interrupt detected

//----------------------------------------------------------------------------
//                              Private Types
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                     Private GLOBAL Variables (static)
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                    Functions (statics one are private)
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// Constructor: Initializes Audio's variables
//----------------------------------------------------------------------------
VOID AudioOpen(PAUDIO pAudio)
{
	pAudio->AudioState = AUDIO_POWER_UP;
	pAudio->IntAudio = NO_IT_A;
	pAudio->MaskItAudio = 0;
	pAudio->EnWrite = TRUE;
	pAudio->ErrorMsg = NO_ERROR;
	pAudio->icd[0] = 0x6FD4EL;		   // 44.1 KHz
	pAudio->icd[1] = 0xBAD58L;		   // 48.0 KHz
	pAudio->icd[2] = 0x17EDC6L;		   // 32.0 KHz
	pAudio->icd[3] = 0x787DAL;		   // 90.0 KHz
	pAudio->FirstPTS = FALSE;			   // First PTS not reached yet
	pAudio->mute = FALSE;
	pAudio->Stepped = FALSE;
	pAudio->FrameCount = 0;
}

//----------------------------------------------------------------------------
// Destructor : Frees space allocated to Audio Class
//----------------------------------------------------------------------------
VOID AudioClose(PAUDIO FAR *pAudio)
{
//	*pAudio = NULL;
}

//----------------------------------------------------------------------------
// Initialize Audio Decoder
//----------------------------------------------------------------------------
VOID AudioInitDecoder(PAUDIO pAudio, U16 StreamType)
{
//	DEBUG_PRINT ((DebugLevelInfo, " Inotializing Audio Decoder...\n" ));
	pAudio->StrType = StreamType;
	switch(pAudio->AudioState) {
	case AUDIO_POWER_UP:
		AudioWrite(RESET, 0x1);	// reset the decoder
		AudioWrite(INTR_EN, 0x0);	// disable all interupts
		AudioWrite(INTR_EN + LSB, 0x0);	// disable all interupts
		AudioWrite(PLAY, 0x0);	// disable play output
		AudioWrite(MUTE, 0x0);	// do not mute output.
		AudioWrite(INVERT_SCLK, 0x0);	// standard
		AudioWrite(INVERT_LRCLK, 0x0);	// standard
		AudioWrite(PCM_DIV, 0x3);	// SCLK=PCMCLK/8 -> PCM_DIV= 3
		AudioWrite(PCM_ORD, 0x0);	// MSB first
		AudioWrite(PCM_18, 0x0);	// 16 bits of PCM data
		AudioWrite(FORMAT, 0x0);	// I2S output format
		AudioWrite(DIF, 0x0);	// Optionnal in 16 bit output
		AudioWrite(STR_SEL, StreamType);	// Select Input Stream Type
		AudioWrite(CRC_ECM, 0x1);	// mute on CRC error correction
		AudioWrite(SYNC_ECM, 0x01);	// mute if Sync lost
		AudioWrite(SYNCHRO_CONFIRM, 0x1);	// synchro confirmation mode
		AudioWrite(SYNC_REG, 0x3F);	// layer, bitrate, fs fields not used
		AudioWrite(PACKET_SYNC_CHOICE, 0x0);	// multiplexed stream
		AudioWrite(SKIP, 0x0);	// don't skip pAudio frame
		AudioWrite(REPEAT, 0x0);	// don't repeat pAudio frame
		AudioWrite(RESTART, 0x0);	// do not perform a restart
		AudioWrite(LATENCY, 0x01);	// high latency (DRAM present)
		AudioWrite(SYNC_LCK, 0x0);	// locked after 2 good Sync
		AudioWrite(SIN_EN, 0x0);	// parrallel data input
		AudioWrite(ATTEN_L, 0x00);  // No attenuation of the left channel
		AudioWrite(ATTEN_R, 0x00);  // No attenuation of the right channel
		AudioWrite(AUDIO_ID_EN, 0x0);	// ignore audio stream ID
		AudioWrite(AUDIO_ID, 0x0);	// audio stream ID ignored
		AudioWrite(FREE_FORM_H, 0x0);	// not free format
		AudioWrite(FREE_FORM_L, 0x0);	// not free format
		AudioWrite(STC_INC, 0x1);	// Count by steps of 1
		AudioWrite(STC_DIVH, 0x0);	// No division on STC (90kHz is input)
		AudioWrite(STC_DIVL, 0x0);	// No division on STC (90kHz is input)
		AudioWrite(STC_CTL, 0x40);	// Load STC_VID on rising edge of VSYNC
		AudioWrite(BALF_LIM_H, 120);	// Buffer almost full limit
		AudioWrite(BALE_LIM_H, 100);	// Buffer almost empty limit

		AudioSetSamplingFrequency(44100UL);
		pAudio->EnWrite = TRUE;
		pAudio->FrameCount = 0;	   // Reset Frame Count.
		pAudio->AudioState = AUDIO_INIT;
		break;

	default:
		break;
	}
}

//----------------------------------------------------------------------------
// Tests if STi4500 registers are correctly accessed
//----------------------------------------------------------------------------
U16 AudioTestReg(VOID)
{
	U16 err = NO_ERROR,val;

	AudioWrite(ATTEN_L, 0x55);
	AudioWrite(ATTEN_R, 0xAA);
	val = AudioRead(ATTEN_L);
	val = val & 0x3F;
	if (val != 0x15)
		err = BAD_REG_A;
	val = AudioRead(ATTEN_R);
	val = val & 0x3F;
	if (val != 0x2A)
		err = BAD_REG_A;
	return ( err);
}

//----------------------------------------------------------------------------
// Test of STi4500 registers and interrupts
//----------------------------------------------------------------------------
U16 AudioTest(PAUDIO pAudio)
{
	U16 TestResult;

	TestResult = AudioTestReg();
	if (TestResult != NO_ERROR)
		return TestResult;
	else {
/*
		if (AudioTestInt(pAudio) == NO_IT_A)
			return NO_IT_A;
		else
*/
			return NO_ERROR;
	}
}

//----------------------------------------------------------------------------
//  Tests Audio interrupts
//----------------------------------------------------------------------------
U16 AudioTestInt(PAUDIO pAudio)
{
	U16 err = NO_ERROR;
	U8  balfsv;
	U16 mask;
	U16 a = 0;

	balfsv = (U8)(AudioRead(BALF_LIM_H));
	mask = AudioRead(INTR_EN);
	mask = (mask << 8) || (AudioRead(INTR_EN + LSB) & 0xFF);

	pAudio->MaskItAudio = BALF;
	AudioWrite(INTR_EN, pAudio->MaskItAudio);	// 0x10
	AudioWrite(BALF_LIM_H, 0);
	// Write 1 byte to DATA_IN in order to produce an INT
	AudioWrite(DATA_IN, 0);

	// wait for occurrence of first audio interrupt
	while (pAudio->IntAudio == NO_IT_A) {
		WaitMicroseconds(1000);
		a++;						  /* incremented every 1 ms */
		if (a >= 1000) {
			SetErrorCode(ERR_NO_AUDIO_INTR);
			err = NO_IT_A; 	/* No interrupt */
			break;
		}
	}

	// Restore Interrupt mask
	pAudio->MaskItAudio = mask;
	AudioWrite(INTR_EN, (U16)(mask & 0xFF));
	AudioWrite(INTR_EN + LSB, (U16)(mask >> 8));
	// Restore BALF_LIM_H value
	AudioWrite(BALF_LIM_H, balfsv);
	AudioRead(INTR);		   /* to clear audio interrupts flags */
	pAudio->EnWrite = TRUE;
	return ( err);
}

//----------------------------------------------------------------------------
// Set the decoding mode and parameters
//----------------------------------------------------------------------------
VOID AudioSetMode(PAUDIO pAudio, U16 Mode, U16 param)
{
	pAudio->DecodeMode = Mode;
	switch (pAudio->DecodeMode) {
	case PLAY_MODE:
		AudioWrite(MUTE, 0);
		pAudio->fastForward = 0;
		pAudio->decSlowDown = 0;
		break;
	case FAST_MODE:
		pAudio->fastForward = 1;
		pAudio->decSlowDown = 0;
		break;
	case SLOW_MODE:
		pAudio->fastForward = 0;
		pAudio->decSlowDown = param;
		break;
	}
}

//----------------------------------------------------------------------------
// Decode
//----------------------------------------------------------------------------
VOID AudioDecode(PAUDIO pAudio)
{
	switch (pAudio->AudioState)	{
	case AUDIO_POWER_UP:
		break;
	case AUDIO_INIT:
		// Change in synchro + buffer over BALF +PTS
		pAudio->MaskItAudio = SYNC | BALF | PTS | BOF;
		AudioWrite(INTR_EN, (U16)(pAudio->MaskItAudio & 0xFF));
		AudioWrite(INTR_EN + LSB, (U16)(pAudio->MaskItAudio >> 8 ));
		AudioWrite(MUTE, 1);	// This Starts SClk and LRClk outputs
		AudioWrite(PLAY, 1);	// Start decoding Output is Mute
		pAudio->AudioState = AUDIO_STC_INIT;
		break;
	case AUDIO_STC_INIT:
		pAudio->AudioState = AUDIO_DECODE;
		AudioWrite(PLAY, 1);	// Restart decoding (decoding had been stopped when first audio PTS detected)
		AudioWrite(MUTE, 0);	// Stop Muting output
		break;
	case AUDIO_DECODE:
		break;
	case AUDIO_PAUSE:
	case AUDIO_STEP:
		AudioWrite(PLAY, 1);
		AudioWrite(MUTE, 0);
		pAudio->AudioState = AUDIO_DECODE;
		break;
	}
}

//----------------------------------------------------------------------------
// Step
//----------------------------------------------------------------------------
VOID AudioStep(PAUDIO pAudio)
{
	AudioWrite(MUTE, 0);
	AudioWrite(PLAY, 1);
	pAudio->AudioState = AUDIO_STEP;
	pAudio->Stepped = FALSE;
}

//----------------------------------------------------------------------------
// Stop
//----------------------------------------------------------------------------
VOID AudioStop(PAUDIO pAudio)
{
	switch(pAudio->AudioState) {
	case AUDIO_POWER_UP:
		break;
	case AUDIO_INIT:
		break;
	case AUDIO_STC_INIT:
	case AUDIO_DECODE:
		pAudio->AudioState = AUDIO_POWER_UP;
		AudioInitDecoder(pAudio, pAudio->StrType);
		break;
	}
}

//----------------------------------------------------------------------------
// Pause
//----------------------------------------------------------------------------
VOID AudioPause(PAUDIO pAudio)
{
	switch(pAudio->AudioState) {
	case AUDIO_POWER_UP: /* After reset */
	case AUDIO_INIT:		 /* Initialisation + test of the decoders */
	case AUDIO_STC_INIT: /* STC of audio decoder initialized */
	case AUDIO_DECODE:	 /* Normal decode */
		AudioWrite(MUTE, 1);
		AudioWrite(PLAY, 0);
		pAudio->AudioState = AUDIO_PAUSE;
		break;
	}
}

//----------------------------------------------------------------------------
// Get Audio State
//----------------------------------------------------------------------------
U16 AudioGetState(PAUDIO pAudio)
{
	return ( pAudio->AudioState);
}

//----------------------------------------------------------------------------
// Get Current STC value
//----------------------------------------------------------------------------
U32 AudioGetSTC(VOID)
{
	U32  stc;
	U16	 j;

	AudioWrite(STC_CTL, 0x44);	// load current STC value to STC
	for ( j = 0; j < 0xF; j++);
	stc = ( AudioRead(STC_3 ) & 0xFFL ) << 24;
	stc = stc | ( ( AudioRead(STC_2 ) & 0xFFL ) << 16);
	stc = stc | ( ( AudioRead(STC_1 ) & 0xFFL ) << 8);
	stc = stc | ( AudioRead(STC_0 ) & 0xFFL);
	return ( stc);
}

//----------------------------------------------------------------------------
// Get STC value latched on VSYNC
//----------------------------------------------------------------------------
U32 AudioGetVideoSTC(VOID)
{
	U32 stc;
	U16	j;

	AudioWrite(STC_CTL, 0x48);	// load STC_VID to STC, Mode 0 mapping
	for ( j = 0; j < 0xF; j++)
		;
	stc = ( AudioRead(STC_3 ) & 0xFFL ) << 24;
	stc = stc | ((AudioRead(STC_2) & 0xFFL ) << 16);
	stc = stc | ((AudioRead(STC_1) & 0xFFL ) << 8);
	stc = stc | ((AudioRead(STC_0) & 0xFFL ));
	return stc;
}

//----------------------------------------------------------------------------
// Initialize STC
//----------------------------------------------------------------------------
VOID AudioInitSTC(U32 stc)
{
	AudioWrite(STC_0, (U8)(stc & 0xFFL));
	stc >>= 8;
	AudioWrite(STC_1, (U8)(stc & 0xFFL));
	stc >>= 8;
	AudioWrite(STC_2, (U8)(stc & 0xFFL));
	stc >>= 8;
	AudioWrite(STC_3, (U8)(stc & 0xFFL));
	AudioWrite(STC_CTL, 0x41);	// load STC to accumulator,
}

//----------------------------------------------------------------------------
// Get Current Audio PTS
//----------------------------------------------------------------------------
U32 AudioGetPTS(PAUDIO pAudio)
{
	return pAudio->PtsAudio;
}

//----------------------------------------------------------------------------
// Get Error Message
//----------------------------------------------------------------------------
U16 AudioGetErrorMsg(PAUDIO pAudio)
{
	return pAudio->ErrorMsg;
}

//----------------------------------------------------------------------------
// Set Right Volume
//----------------------------------------------------------------------------
VOID AudioSetRightVolume(U16 volume)
{
	AudioWrite(ATTEN_R, volume);
}

//----------------------------------------------------------------------------
// Set Left Volume
//----------------------------------------------------------------------------
VOID AudioSetLeftVolume(U16 volume)
{
	AudioWrite(ATTEN_L, volume);
}

//----------------------------------------------------------------------------
// Mute audio output
//----------------------------------------------------------------------------
VOID AudioMute(PAUDIO pAudio)
{
	if (pAudio->mute) {
		AudioWrite(MUTE, 0);
		pAudio->mute = FALSE;
	}
	else {
		AudioWrite(MUTE, 1);
		pAudio->mute = TRUE;
	}
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
BOOLEAN AudioIsFirstPTS(PAUDIO pAudio)
{
	return pAudio->FirstPTS;
}

//----------------------------------------------------------------------------
// Sets Input Stream Type 0:Audio only, 1:Audio Packet
//----------------------------------------------------------------------------
VOID AudioSetStreamType(U16 StrType)
{
	AudioWrite(STR_SEL, StrType);
}

//----------------------------------------------------------------------------
// Mask Audio interrupt
//----------------------------------------------------------------------------
VOID AudioMaskInt(VOID)
{
	AudioWrite(INTR_EN, 0);
	AudioWrite(INTR_EN + LSB, 0);
}

//----------------------------------------------------------------------------
// Restore Audio interrupt Mask
//----------------------------------------------------------------------------
VOID AudioRestoreInt(PAUDIO pAudio)
{
	AudioWrite(INTR_EN, (U16)(pAudio->MaskItAudio & 0xFF));
	AudioWrite(INTR_EN + LSB, (U16)(pAudio->MaskItAudio >> 8));
}

//----------------------------------------------------------------------------
// Audio interrupt routine
//----------------------------------------------------------------------------
BOOLEAN AudioAudioInt(PAUDIO pAudio)
{
	U16     int_stat_reg, i;
	BOOLEAN	bAudioIntr = FALSE;

	// Read the interrupt status register
	int_stat_reg = AudioRead(INTR);
	i = AudioRead(INTR + LSB);
	i = i << 8;
	int_stat_reg = ( int_stat_reg & 0xFF ) | i;
	int_stat_reg = int_stat_reg & pAudio->MaskItAudio;	/* Mask the IT not used */

	if(int_stat_reg)
		bAudioIntr = TRUE;

	/******************************************************/
	/**                   CHANGE SYNCHRO                 **/
	/******************************************************/
	if (int_stat_reg & SYNC) {
		i = AudioRead(SYNC_ST);	// Synchronization status
		if ((i & 0x3) == 3)	{	   // Locked
			// Disable Change in synchro
			pAudio->MaskItAudio = pAudio->MaskItAudio & NSYNC;
			// Next Interrupt should be change in sampling freq
			pAudio->MaskItAudio = pAudio->MaskItAudio | SAMP;
		}
	}

	/******************************************************/
	/**             CHANGE IN SAMPLING FREQUENCY         **/
	/******************************************************/
	if (int_stat_reg & SAMP) {
		i = AudioRead(PCM_FS ) & 0x3;	// Get Sampling frequency
		switch(i) {
		case 0 :
			AudioSetSamplingFrequency(44100UL); break;
		case 1 :
			AudioSetSamplingFrequency(48000UL); break;
		case 2 :
			AudioSetSamplingFrequency(32000UL); break;
		default :
			DebugPrint((DebugLevelFatal, "Unknown case !"));
		}
		// Disable change in sampling frequency
		pAudio->MaskItAudio = pAudio->MaskItAudio & NSAMP;
	}

	/******************************************************/
	/**                   OVER BALF LIMIT                **/
	/******************************************************/
	if (int_stat_reg & BALF) {
		pAudio->IntAudio = IT_A;		   // Audio Interrupt detected.
		pAudio->MaskItAudio = pAudio->MaskItAudio | BALE;	// Enable BALE
		pAudio->EnWrite = FALSE;
	}

	/******************************************************/
	/**                   BELOW BALE LIMIT               **/
	/******************************************************/
	if (int_stat_reg & BALE) {
		pAudio->EnWrite = TRUE;
	}

	/******************************************************/
	/**                   CRC error                      **/
	/******************************************************/
	if (int_stat_reg & CRC)	{
		pAudio->EnWrite = TRUE;
	}

	/******************************************************/
	/**                   PCM Underflow                  **/
	/******************************************************/
	if (int_stat_reg & PCMU) {
		pAudio->EnWrite = TRUE;
	}

	/******************************************************/
	/**                  Begining of Frame               **/
	/******************************************************/
	if (int_stat_reg & BOF)	{
		// Check if stepping
		if ((pAudio->AudioState == AUDIO_STEP) && (pAudio->Stepped == FALSE)) {
			AudioWrite(MUTE, 1);
			AudioWrite(PLAY, 0);
			pAudio->Stepped = TRUE;
		}
		// If Slow motion or Fast forward, Mute Audio
		if ( pAudio->DecodeMode != PLAY_MODE ) {
			AudioWrite(MUTE, 1);
			pAudio->mute = TRUE;
			if ((pAudio->FrameCount % 4) && (pAudio->fastForward))
				AudioWrite(SKIP, 1);
			else if ((pAudio->DecodeMode == SLOW_MODE ) &&
							 ((pAudio->FrameCount % (pAudio->decSlowDown + 1)) != 0))
				AudioWrite(REPEAT, 1);
		}

		pAudio->FrameCount++;			   // Increment Frame Count
	}

	/******************************************************/
	/**                   PTS detected                   **/
	/******************************************************/
	if ( int_stat_reg & PTS )	{
		U32 pts;

		AudioRead(PTS_4);	   // To clear pts interrupt
		pts = (AudioRead(PTS_3) & 0xFFL) << 24;
		pts = pts | ((AudioRead(PTS_2 ) & 0xFFL) << 16);
		pts = pts | ((AudioRead(PTS_1 ) & 0xFFL) << 8);
		pts = pts | ( AudioRead(PTS_0 ) & 0xFFL);

		pAudio->PtsAudio = pts;
		if (pAudio->AudioState == AUDIO_STC_INIT) {
			pAudio->FirstPTS = TRUE;
			AudioWrite(PLAY, 0);
		}
		if (pAudio->AudioState == AUDIO_DECODE)	{
			AudioInitSTC ( pts);
		}
	}

	return bAudioIntr;
}

//------------------------------- End of File --------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\pci9060.c ===
//----------------------------------------------------------------------------
// PCI9060.C
//----------------------------------------------------------------------------
// PCI bridge (PLX PCI9060) programming
//----------------------------------------------------------------------------
// Copyright SGS Thomson Microelectronics  !  Version alpha  !  Jan 1st, 1995
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                               Include files
//----------------------------------------------------------------------------
#include "stdefs.h"
#include "debug.h"
#include "error.h"
#include "aal.h"

//----------------------------------------------------------------------------
//                            Private Constants
//----------------------------------------------------------------------------
//---- RESET address
#define RESET    0x0800

//---- RESET register bit
#define RST9060  0x02

//---- Misc
#define PLX_VENDOR_ID       0x10b5  // not used at all
#define PCI_9060_DEVICE_ID  0x9060  // not used at all

//---- PCI configuration registers               type  bits
#define PCI9060_VENDOR_ID               0x000 //        16
#define PCI9060_DEVICE_ID               0x002 //        16
#define PCI9060_COMMAND                 0x004 //        16
#define PCI9060_STATUS                  0x006 //        16
#define PCI9060_REV_ID                  0x008 //         8
#define PCI9060_CLASS_PI                0x009 //         8
#define PCI9060_CLASS_SUB               0x00A //         8
#define PCI9060_CLASS_BASE              0x00B //         8
#define PCI9060_CACHE_SIZE              0x00C //         8
#define PCI9060_LATENCY_TIMER           0x00D //         8
#define PCI9060_HEADER_TYPE             0x00E //         8
#define PCI9060_BIST                    0x00F //         8
#define PCI9060_RTR_BASE                0x010 //        32
#define PCI9060_RTR_IO_BASE             0x014 //        32
#define PCI9060_LOCAL_BASE              0x018 //        32
#define PCI9060_EXP_BASE                0x030 //        32
#define PCI9060_LAT_GNT_INTPIN_INTLINE  0x03C //        32

//---- PLX registers
#define PCI9060_LOCAL_RANGE             0x000 //        32
#define PCI9060_LOCAL_REMAP             0x004 //        32
#define PCI9060_EXP_RANGE               0x010 //        32
#define PCI9060_EXP_REMAP               0x014 //        32
#define PCI9060_REGIONS                 0x018 //        32
#define PCI9060_DM_MASK                 0x01c //        32
#define PCI9060_DM_LOCAL_BASE           0x020 //        32
#define PCI9060_DM_IO_BASE              0x024 //        32
#define PCI9060_DM_PCI_REMAP            0x028 //        32
#define PCI9060_DM_IO_CONFIG            0x02C //        32
#define PCI9060_MAILBOX                 0x040 //        32
#define PCI9060_LOCAL_DOORBELL          0x060 //        32
#define PCI9060_PCI_DOORBELL            0x064 //        32
#define PCI9060_INT_CONTROL_STATUS      0x068 //        32
#define PCI9060_EEPROM_CONTROL_STATUS   0x06C //        32

//---- Register bits
#define EEPROM_CK 0x01000000UL // EEPROM Clock
#define EEPROM_CS 0x02000000UL // EEPROM Chip Select
#define EEPROM_WR 0x04000000UL // EEPROM input
#define EEPROM_RD 0x08000000UL // EEPROM output

//----------------------------------------------------------------------------
//                              Private Types
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                     Private GLOBAL Variables (static)
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                     Functions (statics one are private)
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// Test of PCI9060 registers
//----------------------------------------------------------------------------
BOOL PCI9060TestRegisters(VOID)
{
	//---- Test PCI9060_MAILBOX
	PCI9060Out32(PCI9060_MAILBOX + 0, 0xAA5555AAUL);
	PCI9060Out32(PCI9060_MAILBOX + 4, 0x55AAAA55UL);
	if (PCI9060In32(PCI9060_MAILBOX + 0) != 0xAA5555AAUL)
		goto Error;
	if (PCI9060In32(PCI9060_MAILBOX + 4) != 0x55AAAA55UL)
		goto Error;

	return TRUE;

Error :
	DebugPrint((DebugLevelError, "PCI9060 register test failed !"));
	SetErrorCode(ERR_PCI9060_REG_TEST_FAILED);
	return FALSE;
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
VOID PCI9060EEPROMWriteCMD(BOOL Clock, BOOL ChipSelect, BOOL Write)
{
	if (ChipSelect) {
		if (Clock && Write)
			PCI9060Out32(PCI9060_EEPROM_CONTROL_STATUS, EEPROM_CS | EEPROM_CK | EEPROM_WR);
		else if (Clock && !Write)
			PCI9060Out32(PCI9060_EEPROM_CONTROL_STATUS, EEPROM_CS | EEPROM_CK);
		else if (!Clock && Write)
			PCI9060Out32(PCI9060_EEPROM_CONTROL_STATUS, EEPROM_CS | EEPROM_WR);
		else if (!Clock && !Write)
			PCI9060Out32(PCI9060_EEPROM_CONTROL_STATUS, EEPROM_CS);
		else
			DebugPrint((DebugLevelFatal, "Case not possible !"));
	}
	else {
		if (Clock && Write)
			PCI9060Out32(PCI9060_EEPROM_CONTROL_STATUS, EEPROM_CK | EEPROM_WR);
		else if (Clock && !Write)
			PCI9060Out32(PCI9060_EEPROM_CONTROL_STATUS, EEPROM_CK);
		else if (!Clock && Write)
			PCI9060Out32(PCI9060_EEPROM_CONTROL_STATUS, EEPROM_WR);
		else if (!Clock && !Write)
			PCI9060Out32(PCI9060_EEPROM_CONTROL_STATUS, 0);
		else
			DebugPrint((DebugLevelFatal, "Case not possible !"));
	}
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
BOOL PCI9060EEPROMRead(VOID)
{
	return (PCI9060In8(PCI9060_EEPROM_CONTROL_STATUS + 2) & EEPROM_RD) != 0;
}

//----------------------------------------------------------------------------
// Enable LINTI# to generate INTA#
//----------------------------------------------------------------------------
VOID PCI9060EnableIRQ(VOID)
{
	PCI9060Out32(PCI9060_INT_CONTROL_STATUS, PCI9060In32(PCI9060_INT_CONTROL_STATUS) | 0x00000800UL);
}

//----------------------------------------------------------------------------
// Disable LINTI# to generate INTA#
//----------------------------------------------------------------------------
VOID PCI9060DisableIRQ(VOID)
{
	PCI9060Out32(PCI9060_INT_CONTROL_STATUS, PCI9060In32(PCI9060_INT_CONTROL_STATUS) & ~0x00000800UL);
}

//------------------------------- End of File --------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\mpvideo.h ===
/*******************************************************************
*
*				 MPVIDEO.H
*
*				 Copyright (C) 1995 SGS-THOMSON Microelectronics.
*
*
*				 Prototypes for MPVIDEO.C
*
*******************************************************************/

#ifndef __MPVIDEO_H__
#define __MPVIDEO_H__

VOID VideoEnableInterrupts(IN PVOID);
VOID VideoTimerCallBack(IN PHW_DEVICE_EXTENSION );
ULONG miniPortVideoStop (PMPEG_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
ULONG miniPortVideoSetStc(PMPEG_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
ULONG miniPortVideoSetAttribute(PMPEG_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
ULONG miniPortVideoQueryInfo (PMPEG_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
ULONG miniPortVideoPlay(PMPEG_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
ULONG miniPortVideoPause(PMPEG_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
ULONG miniPortVideoPacket(PMPEG_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
ULONG miniPortVideoGetStc(PMPEG_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
ULONG miniPortVideoGetAttribute(PMPEG_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
ULONG miniPortVideoEndOfStream(PMPEG_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
ULONG miniPortVideoDisable(PMPEG_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
ULONG miniPortVideoEnable(PMPEG_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
ULONG miniPortClearVideoBuffer(PMPEG_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
ULONG miniPortCancelVideo(PMPEG_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);
ULONG miniPortVideoReset(PMPEG_REQUEST_BLOCK, PHW_DEVICE_EXTENSION);

#endif //__MPVIDEO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\stctrl.c ===
//----------------------------------------------------------------------------
// STCTRL.C
//----------------------------------------------------------------------------
// Description : Highest layer of the driver (interface with the application)
//----------------------------------------------------------------------------
// Copyright SGS Thomson Microelectronics  !  Version alpha  !  Jan 1st, 1995
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Include files
//----------------------------------------------------------------------------
#include <stdlib.h> // labs
#include "stdefs.h"
#include "common.h"
#include "stctrl.h"
#include "stvideo.h"
#include "staudio.h"
#include "stllapi.h"
#include "display.h"
#include "debug.h"
#include "error.h"

//----------------------------------------------------------------------------
//                   GLOBAL Variables (avoid as possible)
//----------------------------------------------------------------------------
extern PCTRL   pCtrl;
static U16     synchronizing = 0;
static BOOLEAN Avsync = FALSE;

//---- Default functions for function pointers
static int DefaultProcessing(int Dummy);

//---- Function pointers to board/host dependencies
FNVREAD        STiVideoRead                 = (FNVREAD)DefaultProcessing;
FNVWRITE       STiVideoWrite                = (FNVWRITE)DefaultProcessing;
FNVSEND        STiVideoSend                 = (FNVSEND)DefaultProcessing;
FNVSETDISP     STiVideoSetDisplayMode       = (FNVSETDISP)DefaultProcessing;
FNAREAD        STiAudioRead                 = (FNAREAD)DefaultProcessing;
FNAWRITE       STiAudioWrite                = (FNAWRITE)DefaultProcessing;
FNASEND        STiAudioSend                 = (FNASEND)DefaultProcessing;
FNASETSAMPFREQ STiAudioSetSamplingFrequency = (FNASETSAMPFREQ)DefaultProcessing;
FNHARDRESET    STiHardReset                 = (FNHARDRESET)DefaultProcessing;
FNENTERIT      STiEnterInterrupt            = (FNENTERIT)DefaultProcessing;
FNLEAVEIT      STiLeaveInterrupt            = (FNLEAVEIT)DefaultProcessing;
FNENABLEIT     STiEnableIT                  = (FNENABLEIT)DefaultProcessing;
FNDISABLEIT    STiDisableIT                 = (FNDISABLEIT)DefaultProcessing;
FNWAIT         STiWaitMicroseconds          = (FNWAIT)DefaultProcessing;

//----------------------------------------------------------------------------
//                            Private Constants
//----------------------------------------------------------------------------
#define CTRL_POWER_UP   0 // After reset
#define CTRL_INIT       1 // Initialisation + test of the decoders
#define CTRL_READY      2 // File openned
#define CTRL_INIT_SYNC  3 // Initial sync.: defines start of audio and video
#define CTRL_DECODE     4 // Normal decode
#define CTRL_IDLE       5 // idle state

#define SLOW_MODE       0
#define PLAY_MODE       1
#define FAST_MODE       2

//----------------------------------------------------------------------------
//                              Private Types
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                     Private GLOBAL Variables (static)
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                    Functions (statics one are private)
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// Default processing for functions pointers
//----------------------------------------------------------------------------
static int DefaultProcessing(int Dummy)
{
	Dummy = Dummy;
	HostDisplay(DISPLAY_FASTEST, "You should call STiInit() before calling this function !\r\n");

	return 0;
}

//----------------------------------------------------------------------------
// Maps specific functions to ST core driver
//----------------------------------------------------------------------------
VOID STiInit(FNVREAD        lVideoRead,
						 FNVWRITE       lVideoWrite,
						 FNVSEND        lVideoSend,
						 FNVSETDISP     lVideoSetDisplayMode,
						 FNAREAD        lAudioRead,
						 FNAWRITE       lAudioWrite,
						 FNASEND        lAudioSend,
						 FNASETSAMPFREQ lAudioSetSamplingFrequency,
						 FNHARDRESET    lHardReset,
						 FNENTERIT      lEnterInterrupt,
						 FNLEAVEIT      lLeaveInterrupt,
						 FNENABLEIT     lEnableIT,
						 FNDISABLEIT    lDisableIT,
						 FNWAIT         lWaitMicroseconds)
{
	STiVideoRead                 = lVideoRead;
	STiVideoWrite                = lVideoWrite;
	STiVideoSend                 = lVideoSend;
	STiVideoSetDisplayMode       = lVideoSetDisplayMode;
	STiAudioRead                 = lAudioRead;
	STiAudioWrite                = lAudioWrite;
	STiAudioSend                 = lAudioSend;
	STiAudioSetSamplingFrequency = lAudioSetSamplingFrequency;
	STiHardReset                 = lHardReset;
	STiEnterInterrupt            = lEnterInterrupt;
	STiLeaveInterrupt            = lLeaveInterrupt;
	STiEnableIT                  = lEnableIT;
	STiDisableIT                 = lDisableIT;
	STiWaitMicroseconds          = lWaitMicroseconds;
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
VOID CardOpen(VOID) // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
{
	DebugPrint((DebugLevelVerbose, "CardOpen"));
	pCard->pVideo = &(pCard->Video);
	VideoOpen(pCard->pVideo);
	pCard->pAudio = &(pCard->Audio);
	AudioOpen(pCard->pAudio);
	pCard->OriginX = 69; // should be tune for your DENC
	pCard->OriginY = 20; // should be tune for your DENC
//	pCard->EndX = 800;
//	pCard->EndY = 254;
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
VOID CardClose(VOID) // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
{
	DebugPrint((DebugLevelVerbose, "CardClose"));
	if (pCard->pVideo != NULL)
	{
		VideoClose(pCard->pVideo);
		pCard->pVideo = NULL;
	}
	if (pCard->pAudio != NULL)
	{
		AudioClose ( &pCard->pAudio );
		pCard->pAudio = NULL;
	}
}

//----------------------------------------------------------------------------
//		Constructor of the decoder
//----------------------------------------------------------------------------
VOID CtrlOpen(PCTRL pCtrl)
{
	DebugPrint((DebugLevelVerbose,"CtrlOpen"));
	pCtrl->ErrorMsg = NO_ERROR;
	pCtrl->CtrlState = CTRL_POWER_UP;
	pCtrl->AudioOn = FALSE;
	pCtrl->VideoOn = FALSE;
	Avsync = FALSE;
}

//----------------------------------------------------------------------------
// Destructor of the decoder
//----------------------------------------------------------------------------
VOID CtrlClose(PCTRL pCtrl)
{
	DebugPrint((DebugLevelVerbose,"CtrlClose"));
}

//----------------------------------------------------------------------------
// Initialization of the decoder
//----------------------------------------------------------------------------
U16 CtrlInitDecoder(PCTRL pCtrl)
{
	DebugPrint((DebugLevelVerbose,"CtrlInitDecoder"));
	switch (pCtrl-> CtrlState) {
		case CTRL_POWER_UP:
			HardReset();
			VideoSetDisplayMode(1);
			VideoInitDecoder(pCard->pVideo);
			AudioInitDecoder (pCard->pAudio, 0 );   // 0/1 Stream Type available

			/* test the access to the decoders */
			pCtrl->ErrorMsg = VideoTest ( pCard->pVideo );
			if ( pCtrl->ErrorMsg == NO_ERROR ) {
				pCtrl->ErrorMsg = AudioTest (pCard->pAudio);
				if ( pCtrl->ErrorMsg == NO_ERROR ) {
					pCtrl->CtrlState = CTRL_INIT_SYNC;
				}
				else {
					DebugPrint((DebugLevelError,"Error in AudioTest : %x",pCtrl->ErrorMsg));
					DisplayErrorMessage();
				}
			}
			else {
				DebugPrint((DebugLevelError,"Error in Video Test : %x", pCtrl->ErrorMsg));
				DebugPrint((DebugLevelError,"Error in initializing Control"));
				DisplayErrorMessage();
			}
			return ( pCtrl->ErrorMsg );

		case CTRL_INIT:
			VideoInitDecoder (pCard->pVideo);
			AudioInitDecoder (pCard->pAudio, 0); // 0/1 Stream Type available
			return ( NO_ERROR );
		default:				// test not possible: decoder is already running
			return ( NOT_DONE );
	}
}

//----------------------------------------------------------------------------
// Pauses the decoding
//----------------------------------------------------------------------------
VOID CtrlPause(PCTRL pCtrl, U8 DecoderType)
{
	DebugPrint((DebugLevelVerbose,"CtrlPause"));
	switch(pCtrl->CtrlState) {
	case CTRL_POWER_UP:
	case CTRL_INIT:
	case CTRL_READY:
		break;
	case CTRL_INIT_SYNC:
		switch(DecoderType) {
		case CTRL_AUDIO :
			AudioPause (pCard->pAudio);
			pCtrl->AudioOn = FALSE;
			break;
		case CTRL_VIDEO :
			VideoPause(pCard->pVideo);
			pCtrl->VideoOn = FALSE;
			break;
		case CTRL_BOTH	 :
			AudioPause(pCard->pAudio);
			VideoPause(pCard->pVideo);
			pCtrl->AudioOn = FALSE;
			pCtrl->VideoOn = FALSE;
			break;
		}
		pCtrl->ActiveState = CTRL_INIT_SYNC;
		pCtrl->CtrlState = CTRL_IDLE;
		break;
	case CTRL_DECODE:
		switch(DecoderType)	{
			case CTRL_AUDIO :
				AudioPause(pCard->pAudio);
				pCtrl->AudioOn = FALSE;
				break;
			case CTRL_VIDEO :
				VideoPause(pCard->pVideo);
				pCtrl->VideoOn = FALSE;
				break;
			case CTRL_BOTH	 :
				AudioPause(pCard->pAudio);
				VideoPause(pCard->pVideo);
				pCtrl->AudioOn = FALSE;
				pCtrl->VideoOn = FALSE;
				break;
		}
		pCtrl->ActiveState = CTRL_DECODE;
		pCtrl->CtrlState = CTRL_IDLE;
		break;
	case CTRL_IDLE:
		break;
	}
}

//----------------------------------------------------------------------------
// Pauses or Enables the decoding
//----------------------------------------------------------------------------
VOID CtrlOnOff(PCTRL pCtrl, U8 DecoderType)
{
	DebugPrint((DebugLevelVerbose,"CtrlOnOff %d", DecoderType));
	switch(pCtrl->CtrlState) {
	case CTRL_IDLE:
		pCtrl->CtrlState = pCtrl->ActiveState;
		CtrlPlay(pCtrl, DecoderType);
		break;
	default:
		CtrlPause(pCtrl, DecoderType);
		break;
	}
}

//----------------------------------------------------------------------------
// Stops decoding
//----------------------------------------------------------------------------
VOID CtrlStop(PCTRL pCtrl, U8 DecoderType)
{
	DebugPrint((DebugLevelVerbose,"Ctrl Stop %d", DecoderType));
	switch (pCtrl->CtrlState)	{
	case CTRL_POWER_UP:
	case CTRL_INIT:
		break;
	case CTRL_READY:
		pCtrl->CtrlState = CTRL_POWER_UP;
		break;
	case CTRL_INIT_SYNC:
	case CTRL_DECODE:
	case CTRL_IDLE:
		if(pCtrl->VideoOn)
			VideoStop(pCard->pVideo);
		if(pCtrl->AudioOn)
			AudioStop(pCard->pAudio);

		pCtrl->VideoOn = FALSE;
		pCtrl->AudioOn = FALSE;
		pCtrl->CtrlState = CTRL_READY;
		CtrlStop (pCtrl, DecoderType); //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		break;
	}
}

//----------------------------------------------------------------------------
// Normal speed decoding
//----------------------------------------------------------------------------
VOID CtrlPlay(PCTRL pCtrl, U8 DecoderType)
{
	DebugPrint((DebugLevelVerbose,"Ctrl Play %d", DecoderType));
	pCtrl->DecodeMode = PLAY_MODE;
	switch(DecoderType) {
	case CTRL_AUDIO :
		AudioSetMode(pCard->pAudio, pCtrl->DecodeMode, 0);
		pCtrl->AudioOn = TRUE;
		break;
	case CTRL_VIDEO :
		VideoSetMode(pCard->pVideo, pCtrl->DecodeMode, 0);
		pCtrl->VideoOn = TRUE;
		break;
	case CTRL_BOTH	 :
		AudioSetMode(pCard->pAudio, pCtrl->DecodeMode, 0);
		pCtrl->AudioOn = TRUE;
		VideoSetMode(pCard->pVideo, pCtrl->DecodeMode, 0);
		pCtrl->VideoOn = TRUE;
//		Avsync = TRUE;
// Avsync is not working - JBS
		break;
	}

	if (pCtrl->CtrlState == CTRL_IDLE)
		pCtrl->CtrlState = CTRL_DECODE;
	VideoDecode(pCard->pVideo);
	AudioDecode(pCard->pAudio);
// temp change - JBS
// Should be removed for AVSYNC
	AudioDecode(pCard->pAudio);
// temp change - JBS
}

//----------------------------------------------------------------------------
// Fast forward decoding
//----------------------------------------------------------------------------
VOID CtrlFast(PCTRL pCtrl, U8 DecoderType)
{
	DebugPrint((DebugLevelVerbose,"CtrlFast %d", DecoderType));
	pCtrl->DecodeMode = FAST_MODE;
	switch(DecoderType) {
	case CTRL_AUDIO :
		AudioSetMode(pCard->pAudio, pCtrl->DecodeMode, 0);
		break;
	case CTRL_VIDEO :
		VideoSetMode(pCard->pVideo, pCtrl->DecodeMode, 0);
		break;
	case CTRL_BOTH	 :
		VideoSetMode(pCard->pVideo, pCtrl->DecodeMode, 0);
		AudioSetMode(pCard->pAudio, pCtrl->DecodeMode, 0);
		break;
	}
}

//----------------------------------------------------------------------------
// Slow Motion decoding
//----------------------------------------------------------------------------
VOID CtrlSlow(PCTRL pCtrl, U16 Ratio, U8 DecoderType)
{
	DebugPrint((DebugLevelVerbose,"CtrlSlow %d", DecoderType));
	pCtrl->DecodeMode = SLOW_MODE;
	pCtrl->SlowRatio = Ratio;
	switch(DecoderType) {
	case CTRL_AUDIO :
		AudioSetMode(pCard->pAudio, pCtrl->DecodeMode, Ratio);
		break;
	case CTRL_VIDEO :
		VideoSetMode(pCard->pVideo, pCtrl->DecodeMode, Ratio);
		break;
	case CTRL_BOTH	 :
		VideoSetMode(pCard->pVideo, pCtrl->DecodeMode, Ratio);
		AudioSetMode(pCard->pAudio, pCtrl->DecodeMode, Ratio);
		break;
	}
}

//----------------------------------------------------------------------------
// Step by step decoding
//----------------------------------------------------------------------------
VOID CtrlStep(PCTRL pCtrl)
{
	DebugPrint((DebugLevelVerbose,"CtrlStep"));
	switch(pCtrl->CtrlState) {
	case CTRL_IDLE:
		VideoStep(pCard->pVideo);
		AudioStep(pCard->pAudio);
		break;
	default:
		break;
	}
}

//----------------------------------------------------------------------------
// Display first field of decoded picture
//----------------------------------------------------------------------------
VOID CtrlBack(PCTRL pCtrl)
{
	DebugPrint((DebugLevelVerbose,"CtrlBack"));
	switch(pCtrl->CtrlState) {
		case CTRL_IDLE:
			VideoBack ( pCard->pVideo  );
			break;
		default:
			break;
	}
}

//----------------------------------------------------------------------------
// Replay a bit stream
//----------------------------------------------------------------------------
VOID CtrlReplay(PCTRL pCtrl)
{
	DebugPrint((DebugLevelVerbose,"CtrlReplay"));
}

//----------------------------------------------------------------------------
// Switch On/Off the horizontal upsampling
//----------------------------------------------------------------------------
VOID CtrlSwitchHorFilter(VOID)
{
	DebugPrint((DebugLevelVerbose,"CtrlSwitchHorFilter"));
	VideoSwitchSRC(pCard->pVideo);
}

//----------------------------------------------------------------------------
//  Set the size and position of the video window on the screen
//----------------------------------------------------------------------------
VOID CtrlSetWindow(U16 OriginX, U16 OriginY, U16 EndX, U16 EndY)
{
	DebugPrint((DebugLevelVerbose,"CtrlSetWindow"));
	VideoSetVideoWindow(pCard->pVideo, OriginX, OriginY, EndX, EndY);
}

//----------------------------------------------------------------------------
// Set the audio volume (right)
//----------------------------------------------------------------------------
VOID CtrlSetRightVolume(U16 vol)
{
	DebugPrint((DebugLevelVerbose,"CtrlSetRightVolume"));
	AudioSetRightVolume(vol);
}

//----------------------------------------------------------------------------
// Set the audio volume (left)
//----------------------------------------------------------------------------
VOID CtrlSetLeftVolume(U16 vol)
{
	DebugPrint((DebugLevelVerbose,"CtrlSetLeftVolume"));
	AudioSetLeftVolume (vol );
}

//----------------------------------------------------------------------------
// Mute the audio output
//----------------------------------------------------------------------------
VOID CtrlMuteOnOff(VOID)
{
	DebugPrint((DebugLevelVerbose,"CtrlMuteOnOff"));
	AudioMute(pCard->pAudio);
}

//----------------------------------------------------------------------------
// Interrupt routine
//----------------------------------------------------------------------------
BOOLEAN IntCtrl(VOID)
{
	S32     diff;
	U16			lattency;
	BOOLEAN	STIntr = FALSE;

	EnterInterrupt();
	VideoMaskInt(pCard->pVideo);
	AudioMaskInt();

	STIntr = VideoVideoInt(pCard->pVideo);
	STIntr|=AudioAudioInt(pCard->pAudio);
	if (Avsync) {
		CtrlInitSync();
		if (VideoIsFirstDTS(pCard->pVideo)) {
			// True only on the start of decode of the first picture with an assoicated valid PTS
			U32 FirstStc;

			FirstStc = VideoGetFirstDTS(pCard->pVideo);
			AudioInitSTC(FirstStc);
			synchronizing = 0;
		}
		synchronizing++;
		if (AudioGetState(pCard->pAudio) == AUDIO_DECODE) {
			if (VideoIsFirstField(pCard->pVideo)) {
				if ( synchronizing >= 10 ) {
					// We must verify the synchronisation of the video on the audio STC
					U32 latchedSTC, videoPTS;
					U16 mode;

					latchedSTC = AudioGetVideoSTC();
					videoPTS = VideoGetPTS(pCard->pVideo);
					mode = VideoGetStreamInfo ( pCard->pVideo )->displayMode;
					lattency = 2200;	 /* 1.5 field duration for 60 Hz video */
					if (mode == 0)
						lattency = 2700; /* 1.5 field duration for 50 Hz video */
					diff = latchedSTC - videoPTS;
					//---- If desynchronized
					if (labs(diff) > (S32)lattency) {
						if (diff < 0)
							VideoRepeat ( pCard->pVideo  );
						else
							VideoSkip ( pCard->pVideo  );
						synchronizing = 0;
					}
				}
			}
		}
	}

	LeaveInterrupt();
	VideoRestoreInt(pCard->pVideo);
	AudioRestoreInt(pCard->pAudio);
	return STIntr;
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
U16 CtrlGetErrorMsg(PCTRL pCtrl)
{
	return pCtrl->ErrorMsg;
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
U16 CtrlGetCtrlStatus(PCTRL pCtrl)
{
	return pCtrl->CtrlState;
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
BOOLEAN	CtrlEnableVideo(PCTRL pCtrl, BOOLEAN bEnable)
{
	pCtrl = pCtrl;
	VideoForceBKC(pCard->pVideo, (U8)(!bEnable));
	return TRUE;
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
BOOLEAN	CtrlEnableAudio(PCTRL pCtrl, BOOLEAN bEnable)
{
	pCtrl = pCtrl;
	if(bEnable) {
		if(pCard->pAudio->mute)
			AudioMute(pCard->pAudio);
	}
	else {
		if(!pCard->pAudio->mute)
			AudioMute(pCard->pAudio);
	}

	return TRUE;
}

//----------------------------------------------------------------------------
// Needed ????????????????????????????????????????????????????????????????????
//----------------------------------------------------------------------------
VOID CtrlEnableAvsync(VOID)
{
	Avsync = TRUE;
}

//----------------------------------------------------------------------------
// Needed ????????????????????????????????????????????????????????????????????
//----------------------------------------------------------------------------
VOID CtrlDisableAvsync(VOID)
{
	Avsync = FALSE;
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
VOID CtrlInitSync(VOID)
{
	switch (pCtrl->CtrlState) {
	case CTRL_INIT_SYNC:
		/*
		Initial synchronisation: the video decoder is always started.
		In case of system stream, the STC is initialised in interrupt with first
		video PTS available the video state becomes VIDEO_DECODE
		When the STC becomes equal (or higher) than the first Audio PTS the audio
		decoding can be enabled
		In case of Audio only bitstreams the video is stopped and audio enabled
		In case of Video only bitstreams, the video decoding continues while
		audio is disabled
		*/
		if (VideoGetState(pCard->pVideo) == VIDEO_DECODE) {
			// the STC is initialized in interrupt with (first video PTS - 3 fields)
			U32             Stc;
			U32             PtsAudio;

			Stc = AudioGetSTC();
			if (AudioIsFirstPTS(pCard->pAudio)) {
				PtsAudio = AudioGetPTS(pCard->pAudio);
				if (Stc >= PtsAudio) {
					DebugPrint((DebugLevelTrace,"Second Audio Decode."));
					AudioDecode(pCard->pAudio);
					pCtrl->CtrlState = CTRL_DECODE;
				}
			}
		}
		pCtrl->ErrorMsg = VideoGetErrorMsg(pCard->pVideo);
		break;

	case CTRL_DECODE:	// Audio and Video decoders are running
		if (pCtrl->ErrorMsg == NO_ERROR)
			pCtrl->ErrorMsg = VideoGetErrorMsg(pCard->pVideo);
		if (pCtrl->ErrorMsg == NO_ERROR)
			pCtrl->ErrorMsg = AudioGetErrorMsg(pCard->pAudio);
		break;

	default :
		break;
	}
}

//------------------------------- End of File --------------------------------

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\stdefs.h ===
#ifndef __STDEFS_H
#define __STDEFS_H
// NT-MOD JBS
#ifndef NT
// NT-MOD JBS
//----------------------------------------------------------------------------
// STDEFS.H
//----------------------------------------------------------------------------
// Description : common used types, constants and macros
//----------------------------------------------------------------------------
// Copyright SGS Thomson Microelectronics  !  Version alpha  !  Jan 1st, 1995
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// Includes
//----------------------------------------------------------------------------
#if defined(WIN31)
	#include <windows.h>
#elif defined(NT)
// NT-MOD JBS
	#include <ntddk.h>
// NT-MOD JBS
#elif defined(DOS)
#else
	#error NT or DOS should be defined !
#endif


//----------------------------------------------------------------------------
// Macros / Constants
//----------------------------------------------------------------------------
//----- Windows like
#ifndef NULL
	#define NULL                0
#endif

#define VOID                void
#if defined(WIN31)
	#define FAR               _far
	#define NEAR              _near
#elif defined(NT) || defined(DOS)
	#define FAR
	#define NEAR
#endif
#define FALSE               0
#define TRUE                1

#define LOBYTE(w)           ((BYTE)(w))
#define HIBYTE(w)           ((BYTE)((UINT)(w) >> 8))

#define LOWORD(l)           ((WORD)(l))
#define HIWORD(l)           ((WORD)((DWORD)(l) >> 16))

#define MAKELONG(low, high) ((LONG)(((WORD)(low)) | (((DWORD)((WORD)(high))) << 16)))

//---- NT like
#define IN
#define INOUT
#define OUT

#define __int64              long

//----------------------------------------------------------------------------
// Standard STDEFS
//----------------------------------------------------------------------------
//---- Windows like
#if !defined(WIN31)
typedef int                 BOOL;
typedef unsigned char       BYTE;
typedef unsigned short      WORD;
typedef unsigned long       DWORD;
typedef unsigned int        UINT;
#endif

//---- Youssef like
typedef BYTE   U8;
typedef WORD   U16;
typedef DWORD  U32;
typedef char   S8;
typedef int    S16;
typedef long   S32;

//---- NT like
#if !defined(NT)
typedef BYTE   UCHAR;
typedef WORD   USHORT;
typedef DWORD  ULONG;
typedef char   CHAR;
typedef short  SHORT;
typedef long   LONG;
#endif

//----------------------------------------------------------------------------
// Pointer STDEFS
//----------------------------------------------------------------------------
//---- Windows like
#if !defined(WIN31)
typedef char  FAR *PSTR;
typedef char  FAR *NPSTR;
typedef BYTE  FAR *PBYTE;
typedef int   FAR *PINT;
typedef WORD  FAR *PWORD;
typedef DWORD FAR *PDWORD;
typedef VOID  FAR *PVOID;
#endif

//---- NT like
#if !defined(NT)
typedef PSTR       PCHAR;
typedef short FAR *PSHORT;
typedef long  FAR *PLONG;
typedef PBYTE      PUCHAR;
typedef PWORD      PUSHORT;
typedef PDWORD     PULONG;
#endif
// NT-MOD JBS
#else
#include <ntddk.h>
#include "mpegmini.h"
#define FAR
//---- Youssef like
typedef unsigned char  * P_U8;
typedef unsigned char  * PBYTE;
typedef unsigned short * P_U16;
typedef unsigned short * PWORD;
typedef unsigned long  * P_U32;
typedef unsigned long  * PDWORD;

typedef char  *  	P_S8;
typedef short * 	P_S16;
typedef short * 	PINT;
typedef long  *  	P_S32;
typedef long  *  	PLONG;
typedef int   *	P_BOOLEAN;

typedef unsigned char  U8, BYTE;
typedef unsigned short U16, WORD;
typedef unsigned long  U32, DWORD;
typedef char   S8;
typedef int    S16;
typedef long   S32;
typedef int   	BOOL;
// NT-MOD JBS
#endif


//------------------------------- End of File --------------------------------
#endif // #ifndef __STDEFS_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\stctrl.h ===
#ifndef __STCTRL_H
#define __STCTRL_H
//----------------------------------------------------------------------------
// STCTRL.H
//----------------------------------------------------------------------------
// Description : small description of the goal of the module
//----------------------------------------------------------------------------
// Copyright SGS Thomson Microelectronics  !  Version alpha  !  Jan 1st, 1995
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                               Include files
//----------------------------------------------------------------------------
#include "stdefs.h"
#include "common.h" // for function pointers

//----------------------------------------------------------------------------
//                               Exported Types
//----------------------------------------------------------------------------
typedef struct {
	U16 CtrlState;
	U16 ErrorMsg;
	U16 DecodeMode;   /* defines the way decoding is performed */
	U16 SlowRatio;    /* defines the slow down ratio (if any) */
	U16 ActiveState;  /* Memorise the active state in case of pause */
	BOOLEAN AudioOn;
	BOOLEAN VideoOn;
} CTRL, FAR *PCTRL;

//----------------------------------------------------------------------------
//                             Exported Variables
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Exported Constants
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Exported Functions
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// One line function description (same as in .C)
//----------------------------------------------------------------------------
// In     :
// Out    :
// InOut  :
// Global :
// Return :
//----------------------------------------------------------------------------
VOID CardOpen(VOID);
VOID CardClose(VOID);

VOID STiInit(FNVREAD        lVideoRead,
						 FNVWRITE       lVideoWrite,
						 FNVSEND        lVideoSend,
						 FNVSETDISP     lVideoSetDisplayMode,
						 FNAREAD        lAudioRead,
						 FNAWRITE       lAudioWrite,
						 FNASEND        lAudioSend,
						 FNASETSAMPFREQ lAudioSetSamplingFrequency,
						 FNHARDRESET    lHardReset,
						 FNENTERIT      lEnterInterrupt,
						 FNLEAVEIT      lLeaveInterrupt,
						 FNENABLEIT     lEnableIT,
						 FNDISABLEIT    lDisableIT,
						 FNWAIT         lWaitMicroseconds);
VOID CtrlOpen(PCTRL pCtrl);
VOID CtrlClose(void);
U16 CtrlInitDecoder(PCTRL pCtrl);
VOID CtrlPause(PCTRL pCtrl, U8 DecoderType);
VOID CtrlOnOff(PCTRL pCtrl, U8 DecoderType);
VOID CtrlStop(PCTRL pCtrl, U8 DecoderType);
VOID CtrlPlay(PCTRL pCtrl, U8 DecoderType);
VOID CtrlFast(PCTRL pCtrl, U8 DecoderType);
VOID CtrlSlow(PCTRL pCtrl, U16 Ratio, U8 DecoderType);
VOID CtrlStep(PCTRL pCtrl);
VOID CtrlBack(PCTRL pCtrl);
VOID CtrlReplay(void);
VOID CtrlSwitchHorFilter(VOID);
VOID CtrlSetWindow(U16 OriginX, U16 OriginY, U16 EndX, U16 EndY);
VOID CtrlSetRightVolume(U16 vol);
VOID CtrlSetLeftVolume(U16 vol);
VOID CtrlMuteOnOff(VOID);
BOOLEAN IntCtrl(VOID);
U16 CtrlGetErrorMsg(PCTRL pCtrl);
U16 CtrlGetCtrlStatus(PCTRL pCtrl);
BOOLEAN	CtrlEnableVideo(PCTRL pCtrl, BOOLEAN bEnable);
BOOLEAN	CtrlEnableAudio(PCTRL pCtrl, BOOLEAN bEnable);
VOID CtrlEnableAvsync(VOID);
VOID CtrlDisableAvsync(VOID);
VOID CtrlInitSync(VOID);
VOID CtrlInitPesParser (U16 StreamType);

//------------------------------- End of File --------------------------------
#endif // #ifndef __STCTRL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\pci9060.h ===
#ifndef __PCI9060_H
#define __PCI9060_H
//----------------------------------------------------------------------------
// PCI9060.H
//----------------------------------------------------------------------------
// PCI bridge (PLX PCI9060) programming
//----------------------------------------------------------------------------
// Copyright SGS Thomson Microelectronics  !  Version alpha  !  Jan 1st, 1995
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                               Include files
//----------------------------------------------------------------------------
#include "stdefs.h"

//----------------------------------------------------------------------------
//                               Exported Types
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Exported Variables
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Exported Constants
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Exported Functions
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// One line function description (same as in .C)
//----------------------------------------------------------------------------
// In     :
// Out    :
// InOut  :
// Global :
// Return :
//----------------------------------------------------------------------------
BOOL PCI9060TestRegisters(VOID);

//----------------------------------------------------------------------------
// One line function description (same as in .C)
//----------------------------------------------------------------------------
// In     :
// Out    :
// InOut  :
// Global :
// Return :
//----------------------------------------------------------------------------
VOID PCI9060EEPROMWriteCMD(BOOL Clock, BOOL ChipSelect, BOOL Write);

//----------------------------------------------------------------------------
// One line function description (same as in .C)
//----------------------------------------------------------------------------
// In     :
// Out    :
// InOut  :
// Global :
// Return :
//----------------------------------------------------------------------------
VOID PCI9060DisableIRQ(VOID);

//----------------------------------------------------------------------------
// One line function description (same as in .C)
//----------------------------------------------------------------------------
// In     :
// Out    :
// InOut  :
// Global :
// Return :
//----------------------------------------------------------------------------
VOID PCI9060EnableIRQ(VOID);

//------------------------------- End of File --------------------------------
#endif // #ifndef __PCI9060_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\staudio.h ===
#ifndef __STAUDIO_H
#define __STAUDIO_H
//----------------------------------------------------------------------------
// STAUDIO.H
//----------------------------------------------------------------------------
// Description : small description of the goal of the module
//----------------------------------------------------------------------------
// Copyright SGS Thomson Microelectronics  !  Version alpha  !  Jan 1st, 1995
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                               Include files
//----------------------------------------------------------------------------
#include "stdefs.h"

//----------------------------------------------------------------------------
//                               Exported Types
//----------------------------------------------------------------------------
typedef struct {
	U16      AudioState;
	U16      ErrorMsg;    // Error Message
	U16      IntAudio;    // Flag positioned when Audio interrupt is detected
	U32      PtsAudio;    // Audio PTS
	U16      StrType;
	BOOLEAN  FirstPTS;    // if First PTS reached FirstPTS=TRUE
	U16      MaskItAudio; /* Audio Interrupt Mask */
	U32      icd[4];
	BOOLEAN  mute;        /* TRUE   if audio is muted */
	BOOLEAN  Stepped;     /* TRUE   if last step command has been executed */
	BOOLEAN  fastForward; /* fast - TRUE = decode fast */
	U16      decSlowDown; /* If !=0 slow motion decoding */
	U16      DecodeMode;  /* Is PLAY_MODE, FAST_MODE or SLOW_MODE */
	U32      SampFreq;
	U32      FrameCount;  /* Frame Number */
} AUDIO, FAR *PAUDIO;

//----------------------------------------------------------------------------
//                             Exported Variables
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Exported Constants
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Exported Functions
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// One line function description (same as in .C)
//----------------------------------------------------------------------------
// In     :
// Out    :
// InOut  :
// Global :
// Return :
//----------------------------------------------------------------------------
VOID AudioOpen(PAUDIO pAudio);
VOID AudioClose(PAUDIO FAR *pAudio);
VOID AudioInitDecoder(PAUDIO pAudio, U16 StreamType);
U16 AudioTestReg(VOID);
U16 AudioTest(PAUDIO pAudio);
U16 AudioTestInt(PAUDIO pAudio);
VOID AudioSetMode(PAUDIO pAudio, U16 Mode, U16 param);
VOID AudioDecode(PAUDIO pAudio);
VOID AudioStep(PAUDIO pAudio);
VOID AudioStop(PAUDIO pAudio);
VOID AudioPause(PAUDIO pAudio);
U16 AudioGetState(PAUDIO pAudio);
VOID AudioSetSTCParameters(U32 SampFreq);
U32 AudioGetSTC(VOID);
U32 AudioGetVideoSTC(VOID);
VOID AudioInitSTC(U32 stc);
U32 AudioGetPTS(PAUDIO pAudio);
U16 AudioGetErrorMsg(PAUDIO pAudio);
VOID AudioSetRightVolume(U16 volume);
VOID AudioSetLeftVolume(U16 volume);
VOID AudioMute(PAUDIO pAudio);
BOOLEAN AudioIsFirstPTS(PAUDIO pAudio);
VOID AudioSetStreamType(U16 StrType);
VOID AudioMaskInt(VOID);
VOID AudioRestoreInt(PAUDIO pAudio);
BOOLEAN AudioAudioInt (PAUDIO pAudio);
VOID AudioInitPesParser (U16 StreamType);

//------------------------------- End of File --------------------------------
#endif // #ifndef __STAUDIO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\stfifo.c ===
//----------------------------------------------------------------------------
// STFIFO.C
//----------------------------------------------------------------------------
// Description : small description of the goal of the module
//----------------------------------------------------------------------------
// Copyright SGS Thomson Microelectronics  !  Version alpha  !  Jan 1st, 1995
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Include files
//----------------------------------------------------------------------------
#include "stdefs.h"
#include "stFifo.h"
#include "common.h" // NO_ERROR, ERR_FIFO_EMPTY, ERR_FIFO_FULL

//----------------------------------------------------------------------------
//                   GLOBAL Variables (avoid as possible)
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                            Private Constants
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                              Private Types
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                     Private GLOBAL Variables (static)
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                    Functions (statics one are private)
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
VOID FifoOpen(PFIFO pFifo)
{
	pFifo->AdInput = 0;
	pFifo->AdOutput = 0;
	pFifo->NbElement = 0;
	pFifo->ErrorMsg = NO_ERROR;
}

//----------------------------------------------------------------------------
// Resets all internal pointers (Empties Fifo)
//----------------------------------------------------------------------------
VOID FifoReset(PFIFO pFifo)
{
	pFifo->AdInput = 0;
	pFifo->AdOutput = 0;
	pFifo->NbElement = 0;
}

//----------------------------------------------------------------------------
// read pts (don't extract from the FIFO) used to compare cd_cnt & scd_cnt before match
//----------------------------------------------------------------------------
U16 FifoReadPts(PFIFO pFifo, PFIFOELT pElt)
{
	if(!pFifo->NbElement)
		return ERR_FIFO_EMPTY;

	pElt->PtsVal = pFifo->FifoTab[(pFifo->AdOutput) % FIFO_SIZE].PtsVal;
	pElt->CdCount = pFifo->FifoTab[(pFifo->AdOutput) % FIFO_SIZE].CdCount;
	return NO_ERROR;
}

//----------------------------------------------------------------------------
// extracts a pts from the fifo (used when comparision matches before storing pts)
//----------------------------------------------------------------------------
U16	FifoGetPts(PFIFO pFifo, PFIFOELT pElt)
{
	if(!pFifo->NbElement)
		return ERR_FIFO_EMPTY;

	pElt->PtsVal = pFifo->FifoTab[(pFifo->AdOutput) % FIFO_SIZE].PtsVal;
	pElt->CdCount = pFifo->FifoTab[(pFifo->AdOutput) % FIFO_SIZE].CdCount;
	pFifo->AdOutput++;
	pFifo->NbElement--;
	return NO_ERROR;
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
U16 FifoPutPts(PFIFO pFifo, PFIFOELT pElt)
{
	if ( pFifo->NbElement >= FIFO_SIZE )
		return ( ERR_FIFO_FULL );

	pFifo->FifoTab[pFifo->AdInput % FIFO_SIZE].PtsVal = pElt->PtsVal;
	pFifo->FifoTab[pFifo->AdInput % FIFO_SIZE].CdCount = pElt->CdCount;
	pFifo->AdInput++;
	pFifo->NbElement++;
	return NO_ERROR;
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
VOID FifoClose(VOID)
{
}

//------------------------------- End of File --------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\sti3520.h ===
#ifndef __STi3520_H
#define __STi3520_H
//----------------------------------------------------------------------------
// STi3520.H
//----------------------------------------------------------------------------
// Description : small description of the goal of the module
//----------------------------------------------------------------------------
// Copyright SGS Thomson Microelectronics  !  Version alpha  !  Jan 1st, 1995
//----------------------------------------------------------------------------

#ifdef STi3520A
	#error This file is only for STi3520/STi3500+STi4500 !
#endif

//----------------------------------------------------------------------------
//                               Include files
//----------------------------------------------------------------------------
#include "stdefs.h"

//----------------------------------------------------------------------------
//                             Exported Constants
//----------------------------------------------------------------------------
/*******************************************************/
/*    Definition of the STi3500A / STi3520 registers   */
/*******************************************************/
#define HDF 	0x00
#define CMD 	0x02
#define GCF 	0x04
#define CTL 	0x06
#define STA 	0x08
#define ITM 	0x0A
#define ITS 	0x0C
#define INS 	0x0E
#define MRF 	0x10
#define MWF 	0x11
#define BMS 	0x10	// shares the same address as MRF and MWF
#define MRP 	0x13
#define MWP 	0x17
#define DFP 	0x1A
#define RFP 	0x1C
#define FFP 	0x1E
#define BFP 	0x20
#define FBP 	0x20	// shares the same address as BFP
#define BBL 	0x22
#define BBS 	0x24
#define BBG 	0x24	// shares the same address as BBS
#define BBT 	0x26
#define DFW 	0x29
#define DFS 	0x2A
#define YDO 	0x2C
#define XDO 	0x2D
#define YDS 	0x2E
#define XDS 	0x2F
#define OEP 	0x30
#define OOP 	0x32
#define LSO 	0x34
#define LSR 	0x35
#define CSO 	0x36
#define CSR 	0x37
#define DCF 	0x38
#define PSV 	0x3A
#define QMW 	0x3C
#define TST 	0x3F
/*********************************************/
/*    Definition of the STi3500A Bit Position*/
/*********************************************/
// CMD    Register bits
#define AVS1		0x0200
#define AVS0    0x0100
#define SBM			0x0080
#define BBGc    0x0040
#define SKP1    0x0020
#define SKP0    0x0010
#define INSc    0x0008
#define QMN			0x0004
#define QMI			0x0002
#define HDS     0x0001
// CTL    Register bits
#define A35			0x8000
#define DEC			0x4000
#define S8M			0x2000
#define PBO			0x1000
#define MP2			0x0800
#define HRD			0x0400
#define EPR			0x0200
#define CBC	    0x0100
#define EC3			0x0080
#define EC2	    0x0040
#define ECK	    0x0020
#define EDI	    0x0010
#define EVI	    0x0008
#define PRS			0x0004
#define SRS			0x0002
#define EDC     0x0001

// DCF    Register bits
#define OAD1		0x8000
#define OAD0		0x4000
#define OAM			0x2000
#define XYE			0x1000
#define DAM2		0x0800
#define DAM1		0x0400
#define DAM0		0x0200
#define FLD	    0x0100
#define USR			0x0080
#define PXD	    0x0040
#define EVD	    0x0020
#define EOS	    0x0010
#define DSR	    0x0008
#define VFC2		0x0004
#define VFC1		0x0002
#define VFC0		0x0001

// GCF1    Register bits
#define DFA			0xFF00      //8 bit mask on DFA location
#define M20			0x0080
#define RFI			0x007F      //7 bit mask on RFI location

// GCF2    Register bits
#define XFA			0xFF00    //8 bit mask on XFA location
#define NPD	    0x0040
#define MRS	    0x0020
#define SQF	    0x0010
#define SGR	    0x0008
#define CLK			0x0004
#define HPD			0x0002
#define SDR			0x0001

// INS1    Register bits
#define TFF			0x8000
#define OVW			0x4000
#define BFH			0x3C00  //4 bit mask on BFH location
#define FFH			0x03C0  //4 bit mask on FFH location
#define PCT	    0x0030  //2 bit mask on PCT location
#define SEQi    0x0008
#define EXE			0x0004
#define RPT			0x0002
#define CMV			0x0001

// INS1    Register bits
#define PST			0xC000  //2 bit mask on PCT location
#define BFV			0x3C00  //4 bit mask on BFV location
#define FFV			0x03C0  //4 bit mask on FFV location
#define DCP	    0x0030  //2 bit mask on DCP location
#define FRM	    0x0008
#define QST			0x0004
#define AZZ			0x0002
#define IVF			0x0001

// STA   Status Register bits
#define PDE		  0x8000
#define SER			0x4000
#define BMI			0x2000
#define HFF			0x1000
#define RFF			0x0800
#define WFE			0x0400
#define PID			0x0200
#define PER			0x0100
#define PSD 		0x0080
#define TOP 		0x0040
#define BOT 		0x0020
#define BBE			0x0010
#define BBF			0x0008
#define HFE			0x0004
#define BFF			0x0002
#define HIT			0x0001
// PSV    Register bits
#define V71			0xFE00  //7 bit mask on V[7.0] location
#define H80			0x01FF  //9 bit mask on H[8.0] location

//*************************************************
// STi4500 register definitions
//*************************************************
#define ANC                0x06
#define ANC_AV             0x6C
#define ATTEN_L            0x1E
#define ATTEN_R            0x20
#define AUDIO_ID           0x22
#define AUDIO_ID_EN        0x24
#define BALE_LIM_H         0x69
#define BALF_LIM_H         0x6B
#define CRC_ECM            0x2A
#define DIF                0x6F
#define DMPH               0x46
#define DRAM_EXT           0x3E
#define DUAL_REG           0x1F // Yann
#define FIFO_IN_TRESHOLD   0x52
#define FORMAT             0x19
#define FRAME_NUMBER       0x13
#define FRAME_OFFSET       0x12
#define FREE_FORM_H        0x15
#define FREE_FORM_L        0x14
#define HEADER             0x5E
#define INTR               0x1A
#define INTR_EN            0x1C
#define INVERT_LRCLK       0x11
#define INVERT_SCLK        0x53
#define LATENCY            0x3C
#define MUTE               0x30
#define PACKET_SYNC_CHOICE 0x23
#define PCM_DIV            0x6E
#define PCM_FS             0x44
#define PCM_ORD            0x38
#define PCM_18             0x16
#define PLAY               0x2E
#define PTS_0              0x62
#define PTS_1              0x63
#define PTS_2              0x64
#define PTS_3              0x65
#define PTS_4              0x66
#define REPEAT             0x34
#define RESET              0x40
#define RESTART            0x42
#define SIN_EN             0x70
#define SKIP               0x32
#define STC_INC            0x10
#define STC_DIVH           0x49
#define STC_DIVL           0x48
#define STC_CTL            0x21
#define STC_0              0x4A
#define STC_1              0x4B
#define STC_2              0x4C
#define STC_3              0x4D
#define STC_4              0x4E
#define STR_SEL            0x36
#define SYNCHRO_CONFIRM    0x25
#define SYNC_ECM           0x2C
#define SYNC_LCK           0x28
#define SYNC_REG           0x27
#define SYNC_ST            0x26
#define VERSION            0x6D

/* Define Interrupt Masks of the STi4500*/
#define SYNC        0x0001  // Set upon change in synchro status
#define HEAD        0x0002  // Set when a valid header has been registered
#define PTS         0x0004  // Set when PTS detected
#define BALE        0x0008  // Set when under BALE treshold
#define BALF        0x0010  // Set when over BALF treshold
#define CRC         0x0020  // Set when CRC error is detected
#define ANCI        0x0080  // Set when Ancillary buffer is full
#define PCMU        0x0100  // Set on PCM buffer underflow
#define SAMP        0x0200  // Set when sampling frequency has changed
#define DEMP        0x0400  // Set when de-emphasis changed
#define DFUL        0x0800  // Set when DRAM is full
#define FIFT        0x1000  // Set when fifo_in_treshold reached
#define FIFF        0x2000  // Set when fifo is full
#define BOF         0x4000  // Set when Begining of frame

#define NSYNC       0xFFFE  // Set upon change in synchro status
#define NHEAD       0xFFFD  // Set when a valid header has been registered
#define NPTS        0xFFFB  // Set when PTS detected
#define NBALE       0xFFF7  // Set when under BALE treshold
#define NBALF       0xFFEF  // Set when over BALF treshold
#define NCRC        0xFFDF  // Set when CRC error is detected
#define NANC        0xFF7F  // Set when Ancillary buffer is full
#define NPCMU       0xFEFF  // Set on PCM buffer underflow
#define NSAMP       0xFDFF  // Set when sampling frequency has changed
#define NDEMP       0xFBFF  // Set when de-emphasis changed
#define NDFUL       0xF7FF  // Set when DRAM is full
#define NFIFT       0xEFFF  // Set when fifo_in_treshold reached
#define NFIFF       0xDFFF  // Set when fifo is full
#define NBOF        0xBFFF  // Set when Begining of frame

//----------------------------------------------------------------------------
//                               Exported Types
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Exported Variables
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Exported Functions
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// One line function description (same as in .C)
//----------------------------------------------------------------------------
// In     :
// Out    :
// InOut  :
// Global :
// Return :
//----------------------------------------------------------------------------

//------------------------------- End of File --------------------------------
#endif // #ifndef __STi3520_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\sthead.c ===
//----------------------------------------------------------------------------
// STHEAD.C
//----------------------------------------------------------------------------
// Description : Header Interrupt Related routines
//----------------------------------------------------------------------------
// Copyright SGS Thomson Microelectronics  !  Version alpha  !  Jan 1st, 1995
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Include files
//----------------------------------------------------------------------------
#include "stdefs.h"
#include <stdlib.h> // labs
#include "common.h"
#include "STllapi.h"
#include "stfifo.h"
#include "debug.h"
#include "error.h"
#ifdef STi3520A
	#include "STi3520A.h"
#else
	#include "STi3520.h"
#endif

//----------------------------------------------------------------------------
//                   GLOBAL Variables (avoid as possible)
//----------------------------------------------------------------------------
char seq_occured;

//----------------------------------------------------------------------------
//                            Private Constants
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                              Private Types
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                     Private GLOBAL Variables (static)
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                    Functions (statics one are private)
//----------------------------------------------------------------------------

/****************************************************************************/
/* notations of the bits position in pVideo->hdrFirstWord registers are     */
/* X for a nibble that must be read 			                                  */
/* x for a bit that must be read 			                                      */
/* 0 for a nibble not read 				                                          */
/* o for a bit not read 				                                            */
/* example :   0 X xxoo 0    means: bits 15 to 12 not read,                 */
/* bits 11 to 6 extracted, bits 5 to 0 not read 	                          */
/****************************************************************************/

//----------------------------------------------------------------------------
// Read of the header data fifo
//----------------------------------------------------------------------------
/*
 returns the next word(16 bits) of the
 Header data Fifo into pVideo->hdrFirstWord variable
*/
void VideoReadHeaderDataFifo ( PVIDEO pVideo )
{
	U16    i = 0;
	while ( VideoHeaderFifoEmpty()) /* Header fifo not available */
	{
		i++;
		if (i == 0xFFFF) {
			if ( !pVideo->errCode )
				pVideo->errCode = BUF_EMPTY;
			SetErrorCode(ERR_BIT_BUFFER_EMPTY);
			break;
		}
	}							   /* Waiting... */
	pVideo->hdrFirstWord = VideoRead(HDF);
	if (pVideo->hdrPos == 8) {
		pVideo->hdrFirstWord = pVideo->hdrNextWord | pVideo->hdrFirstWord;
#ifndef STi3520A
		pVideo->hdrNextWord = VideoRead ( HDF + 1 ) << 8;
#else
		pVideo->hdrNextWord = VideoRead(HDF) << 8;
#endif
	}
	else
	{
		pVideo->hdrFirstWord = pVideo->hdrFirstWord << 8;
#ifndef STi3520A
		pVideo->hdrFirstWord = VideoRead ( HDF + 1 ) | pVideo->hdrFirstWord;
#else
		pVideo->hdrFirstWord = VideoRead(HDF) | pVideo->hdrFirstWord;
#endif
	}
}

//----------------------------------------------------------------------------
// Routine associating the PTS values with each picture
//----------------------------------------------------------------------------
void VideoAssociatePTS ( PVIDEO pVideo )
{
	U32             scd_cnt,
					cd_cnt;			   // cd_count
	FIFOELT		elt;
	U16		wErr;
	S32             sign = 1;

	scd_cnt = VideoReadSCDCount (pVideo);
	pVideo->pDecodedPict->validPTS = FALSE;

	wErr = FifoReadPts ( pVideo->pFifo, &elt);

	if ( wErr == NO_ERROR )	// If at least one ptsin
												// fifo
	{
		cd_cnt = elt.CdCount / 2 + 2;
		/* CD_count / 2 ranges from 0 to 7fffff */
		if ( scd_cnt >= 0x800000UL )	   /* scd_cnt = SCD count */
			scd_cnt = scd_cnt - 0x800000UL;	/* bring scd_cnt in range 0
											 * to 7fffff */
		if ( labs ( cd_cnt - scd_cnt ) >= 0x400000UL )	// Too big difference
														// one of cd or scd has
														// turned
			sign = -1;				   // Comparison changes sign.
		// If cdcount > Scdcount assossiate pts with picture
		if ( ( sign * ( S32 ) ( scd_cnt - cd_cnt ) ) >= 0L )
		{
			// extract pts from fifo and associate with decoded picture
			FifoGetPts (pVideo->pFifo, &elt);
			pVideo->pDecodedPict->dwPTS = elt.PtsVal;
			pVideo->pDecodedPict->validPTS = TRUE;
		}
	}
}

//----------------------------------------------------------------------------
// Read of the next start code in the bit stream
//----------------------------------------------------------------------------
/*
		This routine is used at the end of the picture header
		when the Start Code Detection mechanism is not used
*/
void VideoNextStartCode ( PVIDEO pVideo, S16 i )
{
	long temp = 0;

	if ( i )
		temp = pVideo->hdrFirstWord & 0xFF;		   // use LSB of pVideo->hdrFirstWord
	while ( temp == 0 )
	{
		VideoReadHeaderDataFifo ( pVideo );	   // read next 16 bits
		if ( pVideo->errCode )
		{
			i = 3;
			break;
		}
		temp = ( temp << 16 ) | pVideo->hdrFirstWord;
		i = i + 2;
	}
	if ( i < 3 ) {					   // A start code is not found: bit stream error !!
		pVideo->errCode = PICT_HEAD;
		SetErrorCode(ERR_PICTURE_HEADER);
	}
	else
	{
		if ( ( temp & 0xFFFFFF00L ) == 0x00000100L )	// this is a start code
		{
			if ( !pVideo->hdrPos )		   // there is nothing into
										 // pVideo->hdrNextWord
			{
				pVideo->hdrPos = 8;
				pVideo->hdrNextWord = ( pVideo->hdrFirstWord & 0xFF ) << 8;
				VideoReadHeaderDataFifo ( pVideo );
			}
			else
			{						   // pVideo->hdrPos = 8: the next
										 // byte is into pVideo->hdrNextWord
				pVideo->hdrFirstWord = ( pVideo->hdrFirstWord << 8 ) | ( pVideo->hdrNextWord >> 8 );
				pVideo->hdrPos = 0;
			}
		}
		else if ( ( temp & 0xFFFFFFFFL ) == 0x00000001L )	// this is a start code
		{
			VideoReadHeaderDataFifo ( pVideo );
		}
		else {  // temp does not contain a start code : bit stream error !
			if ( !pVideo->errCode )
				pVideo->errCode = PICT_HEAD;
			SetErrorCode(ERR_PICTURE_HEADER);
		}
	}
	i = VideoRead ( ITS ) << 8;   // allows to clear the Header hit bit
	i = ( i | VideoRead ( ITS + 1 ) ) & 0xFFFE;	// allows to clear the
														// Header hit bit
	pVideo->intStatus = ( pVideo->intStatus | i ) & pVideo->intMask;
/* if no bit stream error, we leave the routine with the start code into pVideo->hdrFirstWord as XX00 */
}

//----------------------------------------------------------------------------
// SEQUENCE START CODE
//----------------------------------------------------------------------------
VOID VideoSequenceHeader(PVIDEO pVideo)
{
	U16 compute, i;
	/* default intra quantization matrix */
	static U8 DefIntQuant[QUANT_TAB_SIZE] = {
		0x08, 0x10, 0x10, 0x13, 0x10, 0x13, 0x16, 0x16,
		0x16, 0x16, 0x16, 0x16, 0x1A, 0x18, 0x1A, 0x1B,
		0x1B, 0x1B, 0x1A, 0x1A, 0x1A, 0x1A, 0x1B, 0x1B,
		0x1B, 0x1D, 0x1D, 0x1D, 0x22, 0x22, 0x22, 0x1D,
		0x1D, 0x1D, 0x1B, 0x1B, 0x1D, 0x1D, 0x20, 0x20,
		0x22, 0x22, 0x25, 0x26, 0x25, 0x23, 0x23, 0x22,
		0x23, 0x26, 0x26, 0x28, 0x28, 0x28, 0x30, 0x30,
		0x2E, 0x2E, 0x38, 0x38, 0x3A, 0x45, 0x45, 0x53
	};
	// Default Non Intra Table
	static U8 DefNonIntQuant[QUANT_TAB_SIZE];
	// Non Default Table
	static U8 QuantTab[QUANT_TAB_SIZE];

	// default Non intra quantization matrix, All coefs = 16
	for (i = 0 ; i < QUANT_TAB_SIZE ; i++)
		DefNonIntQuant[i] = 16;

	seq_occured = 1; // mention to the picture header that a sequence has occured
									 // in order to reset the next pan offsets.

	/* Horizontal picture size is 12 bits: 00XX + X000 */
	pVideo->StreamInfo.horSize = ( pVideo->hdrFirstWord << 4 ) & 0xFFF;	// extract 8 MSB
	VideoReadHeaderDataFifo ( pVideo );
	pVideo->StreamInfo.horSize = pVideo->StreamInfo.horSize | ( pVideo->hdrFirstWord >> 12 );	// 4 LSB of horizontal
												// size

	/* Vertical picture size is 12 bits: 0XXX */
	pVideo->StreamInfo.verSize = pVideo->hdrFirstWord & 0xFFF;	   // 12 LSB of Vertical picture
										 // size

	/* pixel aspect ratio is 4 bits: X000 */
	VideoReadHeaderDataFifo ( pVideo );
	pVideo->StreamInfo.pixelRatio = ( pVideo->hdrFirstWord >> 12 ) & 0xF;

	/* frame rate is 4 bits: 0X00 */
	pVideo->StreamInfo.frameRate = ( pVideo->hdrFirstWord >> 8 ) & 0xF;
	pVideo->StreamInfo.displayMode = 1;					   // 60 Hz interlaced display
	pVideo->BufferA = BUFF_A_NTSC;
	pVideo->BufferB = BUFF_B_NTSC;
	pVideo->BufferC = BUFF_C_NTSC;
	switch ( pVideo->StreamInfo.frameRate )
	{
		case 1:						   // picture rate is 23.976 Hz:
			break;					   // display in 3:2 pull-down at
										 // 59.94 Hz interlaced if MPEG1
		case 2:						   // picture rate is 24 Hz:
			break;					   // display in 3:2 pull-down at
										 // 60 Hz interlaced if MPEG1
		case 3:						   // picture rate is 25 Hz:
										 // display 50 Hz interlaced
			pVideo->StreamInfo.displayMode = 0;
			pVideo->BufferA = BUFF_A_PAL;
			pVideo->BufferB = BUFF_B_PAL;
			pVideo->BufferC = BUFF_C_PAL;
#ifdef STi3520A
			// Choose B Optimization for PAL for both Luma and Chroma
			VideoWrite(CFG_BFS,NB_ROW_OF_MB);
			// Select Full Res vertical filter without interpolation
			// Interpollation NOT ALLOWED if Optimization
			pVideo->fullVerFilter = 0x01;
#endif
			break;
		case 4:						   // picture rate is 29.97 Hz
			break;
		case 5:						   // picture rate is 30 Hz
			break;
		default:
			SetErrorCode(ERR_FRAME_RATE_NOT_SUPPORTED);
			if ( !pVideo->errCode )
				pVideo->errCode = FRAME_RATE;   /* frame rate not supported by the board */
			break;
	}

	/* bit rate is 18 bits: 00XX + XX xxoo 0  */
	pVideo->StreamInfo.bitRate = ( long ) pVideo->hdrFirstWord;
	pVideo->StreamInfo.bitRate = ( pVideo->StreamInfo.bitRate << 10 ) & 0x3FC00L;
	VideoReadHeaderDataFifo ( pVideo );
	pVideo->StreamInfo.bitRate = pVideo->StreamInfo.bitRate | ( pVideo->hdrFirstWord >> 6 );

	/* bit rate is 18 bits only for MPEG1 bit streams */
	if ( !pVideo->StreamInfo.modeMPEG2 )
	{
		long            tota = 400L;
		pVideo->StreamInfo.bitRate = pVideo->StreamInfo.bitRate * tota;	   /* bit rate is a multiple of 400
											* bits/s */
	}
	/*
	 * for MPEG2 bit streams bit rate is 30 bits: 12 more bits in
	 * sequence extension
	 */

	/* marker bit: 00 ooxo 0 : just skipped ... */

	/* pVideo->vbvBufferSize is 10 bits : 00 ooox X + X xooo 00 */
	pVideo->vbvBufferSize = ( pVideo->hdrFirstWord << 5 ) & 0x3E0;
	VideoReadHeaderDataFifo ( pVideo );
	pVideo->vbvBufferSize = pVideo->vbvBufferSize | ( pVideo->hdrFirstWord >> 11 );
//	if( (!pVideo->StreamInfo.modeMPEG2) && ((pVideo->vbvBufferSize*8) > BUF_FULL) )
//	if (!pVideo->errCode) pVideo->errCode = SMALL_BUF;                    	/* Buffer size too small to decode the bit stream */
	// for MPEG2 bit streams pVideo->vbvBufferSize is 15 bits: 5 more bits in
	// sequence extension */

	// constrained flag is 1 bit: 0 oxoo 00 : just skipped... */

	// load intra quant table bit : 0 ooxo 00 */
	if ( ( pVideo->hdrFirstWord & 0x200 ) != 0 )   // Test load intra quantizer
										 // matrix */
	{
		// Read Non Default Intra Quant Table
		for ( i = 0; i < (QUANT_TAB_SIZE/2)  ; i++)
			{
			compute = pVideo->hdrFirstWord << 7;
			VideoReadHeaderDataFifo ( pVideo );
			compute = compute | ( pVideo->hdrFirstWord >> 9 );
			QuantTab[2*i] = (U8)( compute >> 8 );
			QuantTab[2*i+1] = (U8)( compute & 0xFF );
			}
		// Load Intra Quant Tables
		VideoLoadQuantTables(pVideo , TRUE , QuantTab );

		pVideo->defaultTbl = pVideo->defaultTbl & 0xE;	   // bit 0 = 0 : no default table
										 // in the chip */
	}
	else if ( !( pVideo->defaultTbl & 0x1 ) )	   // Load default intra matrix */
	{
		VideoLoadQuantTables(pVideo , TRUE , DefIntQuant );
		pVideo->defaultTbl++;					   // bit 0 = 1 default intra table
										 // is in the chip */
	}

	// load non intra quant table bit : 0 ooox 00 */
	if ( ( pVideo->hdrFirstWord & 0x100 ) != 0 )   // Test load non intra quantizer
										 // matrix */
	{								   // Load non intra quantizer
										 // matrix */
		for ( i = 0; i < (QUANT_TAB_SIZE/2)  ; i++)
			{
			compute = pVideo->hdrFirstWord & 0xFF;
			QuantTab[2*i] = (U8)( compute );
			VideoReadHeaderDataFifo ( pVideo );
			compute = ( pVideo->hdrFirstWord >> 8 ) & 0xFF;
			QuantTab[2*i+1] = (U8)( compute );
			}
		VideoLoadQuantTables(pVideo , FALSE , QuantTab );
		pVideo->defaultTbl = pVideo->defaultTbl & 0xD;	   // bit 1 = 0 : no default
										 // non-intra matrix */
	}
	else if ( !( pVideo->defaultTbl & 0x2 ) )	   // default non intra table not
										 // in the chip */
	{
		VideoLoadQuantTables(pVideo , FALSE , DefNonIntQuant );
		pVideo->defaultTbl = pVideo->defaultTbl | 0x2;	   // bit 1 = 1: default non intra
										 // table into the chip */
	}

	if ( ( !pVideo->StreamInfo.modeMPEG2 ) && ( pVideo->notInitDone ) )	// initialisation of the
											// frame size is only done
											// once
	{
		VideoSetPictureSize ( pVideo);
		VideoSetDisplayMode ( pVideo->StreamInfo.displayMode );
		VideoInitXY (pVideo);
		pVideo->notInitDone = 0;
	}
	// in case of MPEG2 bit streams the initialisation can only be done
	// after sequence extension */

	// end of sequence header analysis */
}


//----------------------------------------------------------------------------
// EXTENSION START CODE
//----------------------------------------------------------------------------
// interrupt only enabled after sequence or GOP start code */
VOID VideoExtensionHeader(PVIDEO pVideo)
{
	U16  comput1;
	U32  temp;

	// extension field is 4 bits: 00X0  */
	switch ( pVideo->hdrFirstWord & 0xF0 )
	{
		//**********************************************************/
		// SEQUENCE   EXTENSION                      */
		//**********************************************************/
		case SEQ_EXT:				   // sequence extension field
									   // always present in MPEG2
			if ( !pVideo->StreamInfo.modeMPEG2 )			   // automatic detection of the
									   // standard
			{
				long            tota = 400L;
				// Select MPEG2 decoding
				VideoSelectMpeg2( pVideo , TRUE);
				pVideo->StreamInfo.bitRate = pVideo->StreamInfo.bitRate / tota;	// bit rate was mult. by
											// 400 in sequence header
											// if pVideo->StreamInfo.modeMPEG2 = 0
				pVideo->StreamInfo.modeMPEG2 = 1;
				pVideo->NextInstr.Mp2 = 1;
				pVideo->notInitDone = 1;
			}

			/* one bit reserved for future use : 000xooo */

			/* Profile indication: 000oxxx */
			comput1 = pVideo->hdrFirstWord & 0x7;
			if ( ( comput1 != 4 ) && ( comput1 != 5 ) )	{ // main profile Id =
														// 100, simple profile =
														// 101
				SetErrorCode(ERR_PROFILE_NOT_SUPPORTED);
				if ( !pVideo->errCode )
					pVideo->errCode = MAIN_PROF;// not simple or main profile bitstream
			}
			/* Level indication: X000 */
			VideoReadHeaderDataFifo ( pVideo );
			comput1 = pVideo->hdrFirstWord & 0xF000;
			if ( ( comput1 != 0x8000 ) && ( comput1 != 0xA000 ) )	{// main level Id = 1000,
																	// low level = 1010
				if ( !pVideo->errCode )
					pVideo->errCode = MAIN_PROF;// not low or main level bitstream
				SetErrorCode(ERR_LEVEL_NOT_SUPPORTED);
			}
			/* non interlaced sequence bit : 0 xooo 00 */
			pVideo->StreamInfo.progSeq = 0;
			if ( ( pVideo->hdrFirstWord & 0x0800 ) )	// non-interlaced frames
				pVideo->StreamInfo.progSeq = 1;

			/* chroma format is 2 bits: 0 oxxo 00 */
			// test if 4.1.1 chroma format
			if ( ( pVideo->hdrFirstWord & 0x600 ) != 0x200 ) {
				if ( !pVideo->errCode )
					pVideo->errCode = CHROMA;   // chroma format not supported
				SetErrorCode(ERR_CHROMA_FORMAT_NOT_SUPPORTED);
			}
			/* horizontal size extension is 2 bits : 0 ooox xooo 0 */
			comput1 = ( pVideo->hdrFirstWord & 0x180 );	// extract 2 MSb of
											// horizontal picture size
			pVideo->StreamInfo.horSize = pVideo->StreamInfo.horSize | ( comput1 << 3 );
			/* vertical size extension is 2 bits: 00 oxxo 0 */
			comput1 = ( pVideo->hdrFirstWord & 0x60 );	// extract 2 MSb of
											// vertical picture size
			pVideo->StreamInfo.verSize = pVideo->StreamInfo.verSize | ( comput1 << 5 );

			/* bit rate extension is 12 bits: 00 ooox X + X xxxo 00 */
			temp = ( pVideo->hdrFirstWord & 0x1F ) << 25;
			VideoReadHeaderDataFifo ( pVideo );
			temp = ( ( pVideo->hdrFirstWord & 0xFE00 ) << 9 ) | temp;
			pVideo->StreamInfo.bitRate = temp | pVideo->StreamInfo.bitRate;
			if ( pVideo->StreamInfo.bitRate > 37500L )   // more than 15 Mbits/s
			{
				if ( !pVideo->errCode )
					pVideo->errCode = HIGH_BIT_RATE;	// put a warning only for the eval board
				SetErrorCode(ERR_BITRATE_TO_HIGH);
			}
			else
			{
				long            tota = 400L;
				pVideo->StreamInfo.bitRate = pVideo->StreamInfo.bitRate * tota;	/* bit rate is a multiple of 400 bits/s */
			}

			/* marker bit: 0 ooox 00 : just skipped */

			/* pVideo->vbvBufferSize_extension is 8 bits : 00 XX */
			pVideo->vbvBufferSize = pVideo->vbvBufferSize | ( ( pVideo->hdrFirstWord & 0xFF ) << 10 );
//		if( pVideo->vbvBufferSize > (BUF_FULL/8) )
//		if (!pVideo->errCode) pVideo->errCode = SMALL_BUF;                	/* Buffer size too small to decode the bit stream */

			// frame rate extension not tested here */
			if ( pVideo->notInitDone )
			{
				VideoSetPictureSize ( pVideo );
				VideoSetDisplayMode ( pVideo->StreamInfo.displayMode );
				VideoInitXY ( pVideo );
				pVideo->notInitDone = 0;
			}
			break;
			// end of sequence extension field */


			//**********************************************************/
			// SEQUENCE   DISPLAY   EXTENSION              */
			//**********************************************************/
		case SEQ_DISP:				   // sequence display extension
										 // field
			pVideo->seqDispExt = 1;
			/* video format is 3 bits: 00 0 xxxo : not used... */

			/* colour description is 1 bit : 00 0 ooox */
			if ( pVideo->hdrFirstWord & 0x1 )
			{
				VideoReadHeaderDataFifo ( pVideo );
				/* colour primaries is 8 bits: XX 00 : not used... */
				/*
				 * transfer characteristics is 8 bits: 00 XX : not
				 * used...
				 */
				VideoReadHeaderDataFifo ( pVideo );
				/* matrix coefficients is 8 bits: XX 00: not used... */

				/*
				 * pan_horizontal_dimension is 14 bits: 00 XX + X xxoo
				 * 00
				 */
				pVideo->StreamInfo.horDimension = ( pVideo->hdrFirstWord & 0xFF ) << 6;
				VideoReadHeaderDataFifo ( pVideo );
				pVideo->StreamInfo.horDimension = pVideo->StreamInfo.horDimension | ( ( pVideo->hdrFirstWord & 0xFC00 ) >> 10 );

				/* skip marker bit : 0ooxo 00 */

				/*
				 * pan_vertical_dimension is 14 bits: 0 ooox XX + X
				 * xooo 00
				 */
				pVideo->StreamInfo.verDimension = ( pVideo->hdrFirstWord & 0x1FF ) << 5;
				VideoReadHeaderDataFifo ( pVideo );
				pVideo->StreamInfo.verDimension = pVideo->StreamInfo.verDimension | ( ( pVideo->hdrFirstWord & 0xF800 ) >> 11 );
			}
			else
			{
				/* pan_horizontal_dimension is 14 bits: XX X xxoo */
				VideoReadHeaderDataFifo ( pVideo );
				pVideo->StreamInfo.horDimension = ( pVideo->hdrFirstWord & 0xFFFC ) >> 2;

				/* skip marker bit : 00 0 ooxo */

				/*
				 * pan_vertical_dimension is 14 bits: 00 0 ooox + XX X
				 * xooo
				 */
				pVideo->StreamInfo.verDimension = ( pVideo->hdrFirstWord & 0x1 ) << 13;
				VideoReadHeaderDataFifo ( pVideo );
				pVideo->StreamInfo.verDimension = pVideo->StreamInfo.verDimension | ( ( pVideo->hdrFirstWord & 0xFFF8 ) >> 3 );
			}
			/* pVideo->StreamInfo.horDimension and pVideo->StreamInfo.verDimension represent the area of the decoded       */
			/* picture that will be displayed on the full screen            */
			/*
			 * this area should be interpolated to the size of the
			 * display
			 */
			/*
			 * this is not possible vertically. Horizontally the SRC is
			 * used
			 */
			/* to deliver 720 pixels                                        */
			if ( pVideo->StreamInfo.horDimension < pVideo->StreamInfo.horSize )
			{
				U32   lsr;
				S16             i;
				// lsr = 256 * (pVideo->StreamInfo.horSize-4) / (display size - 1)
				lsr = ( 256 * ( long ) ( pVideo->StreamInfo.horDimension - 4 ) ) / 719;
				if ( lsr < 32 )
					lsr = 32;
				i = VideoRead ( LSO );
				VideoWrite ( LSO, i );	// programmation of the
												// SRC
				VideoWrite ( LSR, lsr );
				i = VideoRead ( CSO );
				VideoWrite ( CSO, i );
#ifndef STi3520A
				VideoWrite ( CSR, lsr );
#endif
				if ( !pVideo->useSRC )	   // flag enabling or not the use
									   // of SRC
				{
					VideoSRCOn ( pVideo );
				}
			}
			break;


		default:					   /* other extension fields are
									    * not tested here */
			break;					   /* extensions related to the
									    * picture are tested at the end
											* of the picture header */
	}
}

//----------------------------------------------------------------------------
// G.O.P. START CODE
//----------------------------------------------------------------------------
/* GOP informations are extracted but not used ! */
VOID VideoGopHeader(PVIDEO pVideo)
{
	U16    compute;

	pVideo->hdrHours = ( pVideo->hdrFirstWord >> 2 ) & 0x1F;   /* Skip drop frame flag */
	compute = ( pVideo->hdrFirstWord << 4 ) & 0x3F;
	VideoReadHeaderDataFifo ( pVideo );
	pVideo->hdrMinutes = ( pVideo->hdrFirstWord >> 12 ) | compute;
	pVideo->hdrSeconds = ( pVideo->hdrFirstWord >> 5 ) & 0x3F;
	compute = ( pVideo->hdrFirstWord << 1 ) & 0x3F;
	VideoReadHeaderDataFifo ( pVideo );
	pVideo->pictTimeCode = ( pVideo->hdrFirstWord >> 15 ) | compute;
	if ( pVideo->StreamInfo.countGOP != 0 )
		pVideo->StreamInfo.countGOP = pVideo->StreamInfo.countGOP | 0x100;   /* Second Gop */
	// to avoid any confusion between gops when testing the pVideo->decSlowDownral
	// ref. for display
	pVideo->GOPindex = pVideo->GOPindex + 0x4000;
}

//----------------------------------------------------------------------------
// PICTURE START CODE
//----------------------------------------------------------------------------
VOID VideoPictureHeader(PVIDEO pVideo)
{
	U16    comput1;
	U32   temp;

	// Determine which picture variable can be used to store the next
	// decoding parameters.
	// We use the next variable in pVideo->pictArray table, because the
	// corresponding frame
	// has been already displayed.
	// The decoded picture buffer is not incremented if we are on a
	// second field picture
	// or if we have decided to skip the previous picture.
	// The first_field attribute is not changed on the second field of
	// 2 field pictures.
	if ( ( !pVideo->skipMode ) && ( pVideo->fieldMode < 2 ) )
	{
		S16	i;						   // increment picture buffer
		for ( i = 0; i < 4; i++ )
			if ( pVideo->pictArray[i].tempRef == 1025 )
			{
				pVideo->pDecodedPict = &pVideo->pictArray[i];
				break;
			}
		// We always initialise first_field to TOP (default for MPEG1).
		// It could be changed in case of 3:2 pull-down in MPEG1
		// or into the picture coding extension for MPEG2 bit stream.
		pVideo->pDecodedPict->first_field = TOP;
	}

	VideoAssociatePTS ( pVideo );

	pVideo->currPictCount++;
	if ( pVideo->currPictCount == 3 )			   /* don't force black color after
									    * the third decoded picture */
	{								   // first picture is ready for
									   // display
		pVideo->currDCF = pVideo->currDCF | 0x20;
		VideoWrite ( DCF, 0 );
		VideoWrite ( DCF + 1, pVideo->currDCF );
	}

	// write the latest transmitted pan offsets into the new pVideo->pictArray
	// variable
	// those offsets may be changed in the picture pan and scan
	// extension...
	// for MPEG1 bit stream they remain to zero.
	// if a sequence had occured since the last decoded picture the pan
	// offsets are all reset to 0
	if ( seq_occured )
	{
		pVideo->latestPanHor = 0;
		pVideo->latestPanVer = 0;
	}
	for ( comput1 = 0; comput1 < 3; comput1++ )
	{
		pVideo->pDecodedPict->pan_hor_offset[comput1] = pVideo->latestPanHor;
		pVideo->pDecodedPict->pan_vert_offset[comput1] = pVideo->latestPanVer;
	}
	seq_occured = 0;

	/* start analysis of the picture header */
	comput1 = pVideo->hdrFirstWord << 2;
	VideoReadHeaderDataFifo ( pVideo );		   /* read next 16 bits */

	/* picture pVideo->decSlowDownral reference is 10 bits: 00XX + xxoo 000 */
	pVideo->pDecodedPict->tempRef = comput1 | ( pVideo->hdrFirstWord >> 14 ) | pVideo->GOPindex;

	/* picture type is 3 bits : ooxx xooo 00 */
	pVideo->pDecodedPict->pict_type = ( pVideo->hdrFirstWord >> 11 ) & 0x7;	// set picture type of
															// decoded picture
	pVideo->NextInstr.Pct = (pVideo->pDecodedPict->pict_type)&0x3; /* Picture type in instruction register */
															// Only 2 bits are stored
/*
if(pVideo->NextInstr.Pct == 1)
	{
	DBG1('I');
	}
if(pVideo->NextInstr.Pct == 2)
	{
	DBG1('P');
	}
if(pVideo->NextInstr.Pct == 3)
	{
	DBG1('B');
	}
*/
if ( pVideo->skipMode )						   // We are on the second picture:
										 // the previous one will be
										 // skipped
		pVideo->skipMode++;
	else							   // !pVideo->skipMode. We skip a picture if
									   // pVideo->fastForward = 1 and on B pictures
									   // only
	if ( pVideo->fastForward && ( pVideo->fieldMode < 2 ) )
	{
		pVideo->NotSkipped++;

		if ( ( pVideo->pDecodedPict->pict_type == 3 )	// we are on a B picture
			 || ( ( pVideo->NotSkipped > 5 ) && ( pVideo->pDecodedPict->pict_type == 2 ) ) )	// we are on a P picture
																						// // we are on a B
																						// picture
		{
			pVideo->NotSkipped = 0;
			pVideo->skipMode = 1;				   // this picture will be skipped
		}
	}
	/* pVideo->vbvDelay is 16 bits: O oxxx XX + X xooo OO */
	comput1 = pVideo->hdrFirstWord << 5;		   /* VBV delay is 16 bits */
	VideoReadHeaderDataFifo ( pVideo );		   /* read next 16 bits */
	comput1 = comput1 | ( pVideo->hdrFirstWord >> 11 );
	if (( comput1 == 0 )||( comput1 >= 0x3000 ))
		// 0x0 means that the pVideo->vbvDelay is not compliant with MPEG !
		// 0xFFFF variable bitrate
		comput1 = 0x3000;			   // we force it to an average
										 // pVideo->vbvDelay ...
	temp = ( ( long ) comput1 * ( pVideo->StreamInfo.bitRate / ( 2048 ) ) ) / 90000L;	/* 2048 = 8*256 ! */

	if ( temp < 0x20 )
		temp = 0x20;
	if ( temp > 0x330 )
		temp = 0x330;

	pVideo->vbvDelay = (S16) temp;
	if ( !pVideo->vbvReached )				   /* BBT set to vbv value for the
										* first picture */
	{
		VideoSetBBThresh(temp);
		pVideo->intMask = 0x8;			   /* Enable buffer full interrupts */
	}

	temp = 10;						   /* number of bits - 1 not
									    * analysed in pVideo->hdrFirstWord */
	if ( pVideo->StreamInfo.countGOP < 0x100 )		   /* To init the GOP structure */
	{								   /* this is only done for display
									    * of the GOP structure */
		if ( pVideo->StreamInfo.countGOP < 28 )
		{
			if ( pVideo->pDecodedPict->pict_type == 1 )	/* I picture */
				pVideo->StreamInfo.firstGOP[pVideo->StreamInfo.countGOP] = 'I';
			else if ( pVideo->pDecodedPict->pict_type == 2 )	/* P picture */
				pVideo->StreamInfo.firstGOP[pVideo->StreamInfo.countGOP] = 'P';
			else if ( pVideo->pDecodedPict->pict_type == 3 )	/* B picture *//* B
															 * picture */
				pVideo->StreamInfo.firstGOP[pVideo->StreamInfo.countGOP] = 'B';
			else
				pVideo->StreamInfo.firstGOP[pVideo->StreamInfo.countGOP] = 'D';	/* D picture */
			pVideo->StreamInfo.firstGOP[pVideo->StreamInfo.countGOP + 1] = 0;
		}
		pVideo->StreamInfo.countGOP++;
	}

	/* P or B picture forward vectors extraction */
	if ( ( pVideo->pDecodedPict->pict_type == 2 ) ||
		 ( pVideo->pDecodedPict->pict_type == 3 ) )	/* P or B picture */
	{

		/* full_pixel_forward_vector is one bit: 0 oxoo 00 */
		if ( ( pVideo->hdrFirstWord & 0x400 ) != 0 )
			pVideo->NextInstr.Ffh = 0x8; //Msb of FFH is 1
		else
			pVideo->NextInstr.Ffh = 0;
		/* forward_f_code is 3 bits: 0 ooxx xooo 0 */
		comput1 = ( pVideo->hdrFirstWord >> 7 ) & 0x7;
		pVideo->NextInstr.Ffh = pVideo->NextInstr.Ffh | comput1;
		temp = 6;					   /* number of bits - 1 not
										* analysed in pVideo->hdrFirstWord */
	}

	/* B picture backward vector extraction */
	if ( pVideo->pDecodedPict->pict_type == 3 )	/* B picture */
	{

		/* full_pixel_backward_vector is one bit: 00 oxoo 0 */
		if ( ( pVideo->hdrFirstWord & 0x40 ) != 0 )
			pVideo->NextInstr.Bfh = 0x8;// Msb of Bfh is 1
		else
			pVideo->NextInstr.Bfh = 0x0;// Msb of Bfh is 0
		/* backward_f_code is 3 bits: 00 ooxx xooo */
		comput1 = ( pVideo->hdrFirstWord >> 3 ) & 0x0007;
		pVideo->NextInstr.Bfh = pVideo->NextInstr.Bfh | comput1;
		temp = 2;	/* number of bits - 1 not analysed in pVideo->hdrFirstWord */
	}


	/*
	 * If extra informations picture follow they must be extracted from
	 * the header FIFO
	 */
	/*
	 * it is not possible to restart the header search as the next
	 * header may be a picture one
	 */
	/*
	 * the research of the first Slice is made by polling of the header
	 * fifo
	 */
	while ( !pVideo->errCode && ( ( pVideo->hdrFirstWord & ( 1 << temp ) ) != 0 ) )	/* extra bit picture = 1 */
	{	 /* if extra bit picture = 1 , 8 bits follow */
		if ( temp <= 8 )
		{
			VideoReadHeaderDataFifo ( pVideo );
			temp = temp + 16;
		}
		temp = temp - 9;			   /* skip 8 bit of extra
									    * information picture */
	}								   /* and next extra bit picture
									    * bit */

	/*
	 * if extension or user data follow they must be extracted from the
	 * header
	 */
	pVideo->hdrFirstWord = pVideo->hdrFirstWord & ( ( 1 << temp ) - 1 );
	if ( pVideo->hdrFirstWord != 0 ) {/* all remaining bits should be zero */
		if ( !pVideo->errCode ) {
			pVideo->errCode = PICT_HEAD;		   /* picture header should be followed by a start code (at least slice) */
		}
		SetErrorCode(ERR_PICTURE_HEADER);
	}
	if ( temp > 7 )	/* LSbyte of pVideo->hdrFirstWord is part of the next start code */
		VideoNextStartCode (pVideo, 1 );		   // already one byte into
									   // pVideo->hdrFirstWord
	else
		VideoNextStartCode (pVideo, 0 );

	/*
	 * at this point pVideo->hdrFirstWord contains the next start code value in the
	 * MSByte
	 */
	while (!pVideo->errCode) {
		if ( ( pVideo->hdrFirstWord & 0xFF00 ) == 0x0100 )
			break;	// we have reached the slice start code
		else if ( ( pVideo->hdrFirstWord & 0xFF00 ) == USER )
			VideoUser ( pVideo );
		else if ( ( pVideo->hdrFirstWord & 0xFF00 ) == EXT )	// there can be several
													// extension fields
			VideoPictExtensionHeader ( pVideo );
		else
			break;
	}
	/*
	 * We have reached the first Slice start code: all parameters are
	 * ready for next decoding
	 */

	/* end of picture header + picture extensions decoding */
	if ( ( !pVideo->fieldMode && ( pVideo->skipMode != 1 ) ) || ( pVideo->fieldMode && ( !pVideo->skipMode || ( pVideo->skipMode == 3 ) ) ) )
	{
		VideoSetRecons ( pVideo );			   // initialise RFP, FFP and BFP
		if ( ( pVideo->fieldMode == 0 ) || ( pVideo->fieldMode == 2 ) )	// we are on a frame
															// picture or the first
															// field of a field
															// picture
			VideoDisplayCtrl (pVideo);		   // computes the next frame to
									   // display
	}

	// implementation of 3:2 pull-down functionality on MPEG1 bit
	// streams
	// encoded at 23.97Hz or 24 Hz and displayed at 60 Hz.
	// 3:2 pull-down on MPEG2 bit streams must be controlled with
	// "repeat_first_field" bit
	if ( ( !pVideo->StreamInfo.modeMPEG2 ) && ( ( pVideo->StreamInfo.frameRate == 1 ) || ( pVideo->StreamInfo.frameRate == 2 ) ) )
	{
		if ( pVideo->pCurrDisplay->nb_display_field == 2 )
		{							   /* same field polarity for the
									    * next frame */
			pVideo->pNextDisplay->nb_display_field = 3;
			if ( pVideo->pCurrDisplay->first_field == TOP )
				pVideo->pNextDisplay->first_field = TOP;
			else
				pVideo->pNextDisplay->first_field = BOT;
		}
		else
		{							   // previous picture was
									   // displayed 3 times        	//
									   // the first field polarity is
									   // changing
			pVideo->pNextDisplay->nb_display_field = 2;
			if ( pVideo->pCurrDisplay->first_field == TOP )
				pVideo->pNextDisplay->first_field = BOT;
			else
				pVideo->pNextDisplay->first_field = TOP;
		}
	}


	if ( pVideo->vbvReached )					   // enable next instruction if
									   // not skipping a picture
	{
		if ( !pVideo->skipMode )				   // no skipped picture
		{
			pVideo->NextInstr.Exe  = 1;	// enable EXE bit
			pVideo->NextInstr.Skip = 0;
			pVideo->currCommand = 0;			   // reset skip bits
		}
		else if ( ( pVideo->skipMode == 2 ) && !pVideo->fieldMode )
			// skip == 2: We are on the picture following a skipped one
			// the instruction can be stored with associated skip bits
			// in CMD
		{
pVideo->currCommand = 0x10;			   // pVideo->skipMode 1 picture
			pVideo->NextInstr.Exe  = 1;	// enable EXE bit
			pVideo->NextInstr.Skip = 1;	// skip 1 picture
			pVideo->skipMode = 0;
			if ( pVideo->DecodeMode != FAST_MODE )
				pVideo->fastForward = 0;			   /* allows to skip only one
										* picture */
		}
		else if ( pVideo->skipMode == 3 )
		{
			// we are on the picture following two skipped fields
pVideo->currCommand = 0x20;			   // pVideo->skipMode 2 fields
			pVideo->NextInstr.Exe  = 1;	// enable EXE bit
			pVideo->NextInstr.Skip = 2;	// Skip 2 fields
			pVideo->skipMode = 0;
			if ( pVideo->DecodeMode != FAST_MODE )
				pVideo->fastForward = 0;			   /* allows to skip only one
										* picture */
		}

		/*
		 * store the next instruction if we are on the good field to do
		 * it
		 */
		if ( ( ( pVideo->pictDispIndex >= pVideo->pCurrDisplay->nb_display_field - 1 ) && !pVideo->fieldMode )
			 || ( ( pVideo->fieldMode == 2 ) && ( pVideo->pictDispIndex >= pVideo->pCurrDisplay->nb_display_field - 2 ) ) )
		{
			if ( pVideo->pNextDisplay->first_field != pVideo->currField )
				VideoWaitDec (pVideo);		   // this is the opposite phase:
									   // put decoder in wait mode
			else
				// store the next instruction that will be taken into
				// account on the next VSYNC
				VideoStoreINS (pVideo);		   // store next INS in case where
									   // enough VSYNC already occured
		}
		else if ( pVideo->fieldMode == 1 )
			VideoStoreINS ( pVideo );
	}

	// clear Header hit flag due to polling of extension or user bits
	// after the picture start code
	// but keep track of possible other interrupt
	comput1 = VideoRead ( ITS ) << 8;
	comput1 = ( comput1 | VideoRead ( ITS + 1 ) ) & 0xFFFE;	// allows to clear the
																	// Header hit bit
	pVideo->intStatus = ( pVideo->intStatus | comput1 ) & pVideo->intMask;
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
/***************************************************************/
/*     This is an extension start code following a picture     */
/*        In MPEG2 bit stream, this start code can be:         */
/*        Picture Coding  (always)                             */
/*        Quant matrix    (optional)                           */
/*        Picture Pan & Scan (optional)                        */
/*        Picture Scalable (optional)   : not tested yet       */
/***************************************************************/
VOID VideoPictExtensionHeader(PVIDEO pVideo)
{
	U16    comput1, i;
	S16    compute;		   // need to be int!!
	U8	   QuantTab[QUANT_TAB_SIZE];

	/* extension Id is 4 bits: 00 X0 */
	comput1 = pVideo->hdrFirstWord & 0xF0;
	switch ( comput1 )
	{
		/******* picture coding extension *******/
		case PICT_COD:
			if ( pVideo->StreamInfo.modeMPEG2 )
			{
				// clear top field first,forward and backward f_code,
				// motion vectors flag
				pVideo->NextInstr.Tff = 0; //pVideo->nextInstr1 & 0x403E;
				pVideo->NextInstr.Bfh = 0;
				pVideo->NextInstr.Ffh = 0;
				pVideo->NextInstr.Cmv = 0;

				pVideo->NextInstr.Pst = 0;
				pVideo->NextInstr.Bfv = 0;
				pVideo->NextInstr.Ffv = 0;
				pVideo->NextInstr.Dcp = 0;
				pVideo->NextInstr.Frm = 0;
				pVideo->NextInstr.Qst = 0;
				pVideo->NextInstr.Azz = 0;
				pVideo->NextInstr.Ivf = 0;

				// forward_horizontal_f_code is 4 bits: 00 0X
				comput1 = pVideo->hdrFirstWord & 0xF;
				pVideo->NextInstr.Ffh = comput1;

				// forward_vertical_f_code is 4 bits: X0 00
				VideoReadHeaderDataFifo ( pVideo );
				comput1 = pVideo->hdrFirstWord & 0xF000;
				comput1 = comput1 >> 12;
				pVideo->NextInstr.Ffv =  comput1;

				// backward_horizontal_f_code is 4 bits: 0X 00
				comput1 = pVideo->hdrFirstWord & 0xF00;
				comput1 = comput1 >>8;
				pVideo->NextInstr.Bfh = comput1;

				// backward_vertical_f_code is 4bits: 00 X0
				comput1 = pVideo->hdrFirstWord & 0xF0;
				comput1 = comput1 >> 4;
				pVideo->NextInstr.Bfv =  comput1;

				// intra DC precision is 2 bits: 00 0 xx00
				comput1 = pVideo->hdrFirstWord & 0x0C;
				if ( comput1 == 0xC ) {
					if ( !pVideo->errCode ) {
						pVideo->errCode = DC_PREC;	// 11 bit DC precision
					}
					SetErrorCode(ERR_INTRA_DC_PRECISION);
				}
				pVideo->NextInstr.Dcp = ( comput1 >> 2 );

				// picture structure is 2 bits: 00 0 ooxx
				pVideo->pDecodedPict->pict_struc = pVideo->hdrFirstWord & 0x3;
				pVideo->NextInstr.Pst = pVideo->pDecodedPict->pict_struc ;
				if ( pVideo->pDecodedPict->pict_struc == 3 )	// frame picture
					pVideo->fieldMode = 0;
				else				   // field picture
				if ( pVideo->fieldMode == 2 )
					pVideo->fieldMode = 1;	   // second field
				else
				{
					pVideo->fieldMode = 2;	   // first field
					if ( pVideo->pDecodedPict->pict_struc == 2 )	// bottom field is the
																// first field
						pVideo->pDecodedPict->first_field = BOT;
				}
				VideoReadHeaderDataFifo ( pVideo );

				// top_field_first bit is one bit: xooo 0 00
				// first_field is already initialised to TOP (beginning
				// of picture header)
				if ( ( !pVideo->StreamInfo.progSeq ) && ( pVideo->pDecodedPict->pict_struc == 3 ) )
				{					   // this is an interlaced frame
									   // picture
					if ( ( ( pVideo->hdrFirstWord & 0x8000 ) != 0 ) )	// top field first
						pVideo->NextInstr.Tff = 1;	 // set top_field_first
					else			  				 // top_field_first already reset
													 // into pVideo->NextInstr
						pVideo->pDecodedPict->first_field = BOT;	// bottom field is BOT
																// field
				}
				if ( pVideo->vbvReached == 0 )   // pre-initialise for start of
										 // the first decoding task
				{					   // on the good field polarity
					pVideo->pictArray[0].first_field = pVideo->pDecodedPict->first_field;
					pVideo->pictArray[1].first_field = pVideo->pDecodedPict->first_field;
					pVideo->pictArray[2].first_field = pVideo->pDecodedPict->first_field;
					pVideo->pictArray[3].first_field = pVideo->pDecodedPict->first_field;
				}

				// frame_pred_frame_DCT is one bit: oxoo 0 00
				if ( ( pVideo->hdrFirstWord & 0x4000 ) != 0 )
					pVideo->NextInstr.Frm = 1 ;	// frame DCT and 16x16
													// prediction

				// concealment_motion_vectors flag is one bit: ooxo 0
				// 00
				if ( pVideo->hdrFirstWord & 0x2000 )
					pVideo->NextInstr.Cmv = 1;

				// qscale_type is one bit: ooox 0 00
				if ( ( pVideo->hdrFirstWord & 0x1000 ) != 0 )
					pVideo->NextInstr.Qst = 1;	// non linear quantizer
													// scale

				// intra_vlc_format is one bit: 0 xooo 00
				if ( ( pVideo->hdrFirstWord & 0x800 ) != 0 )
					pVideo->NextInstr.Ivf = 1;	// alternative intra VLC
													// table

				// alternate scan bit: 0 oxoo 00
				if ( ( pVideo->hdrFirstWord & 0x400 ) != 0 )
					pVideo->NextInstr.Azz = 1;	// alternative scan

				// repeat_first_field is one bit: 0 ooxo 00
				// A 2 field picture is considered as one picture
				// displayed twice
				pVideo->pDecodedPict->nb_display_field = 2;	// display picture
														// during 2 fields
														// period
				if ( pVideo->pDecodedPict->pict_struc == 3 )	// frame picture
				{
					if ( pVideo->hdrFirstWord & 0x200 )	// repeat first field
						pVideo->pDecodedPict->nb_display_field = 3;	// display picture
																// during 3 fields
																// period
				}

				// chroma_postprocessing_type is one bit: 0 ooox 00
				if ( ( pVideo->hdrFirstWord & 0x100 ) )
				{
					// use the field repeat mode for chroma vertical
					// filter (if enabled)
					pVideo->fullVerFilter = pVideo->fullVerFilter | 0x2;
					pVideo->currDCF = pVideo->currDCF | 0x2;
				}
				else
				{
					// use the line repeat mode for chroma vertical
					// filter (if enabled)
					pVideo->fullVerFilter = pVideo->fullVerFilter & 0xFFFD;
					pVideo->currDCF = pVideo->currDCF & 0xFFFD;
				}
				VideoWrite ( DCF, 0 );
				VideoWrite ( DCF + 1, pVideo->currDCF );
				// progressive_frame is one bit: 00 xooo 0

				// composite_display_flag is one bit: 00 oxoo 0
				if ( pVideo->hdrFirstWord & 0x40 )
				{
					// v_axis is one bit: 00 ooxo 0
					// field_sequence is 3 bits: 00 ooox xxoo
					// sub_carrier is one bit: 00 0 ooxo
					VideoReadHeaderDataFifo ( pVideo );
					// burst_amplitude is 7 bit: 00 0 ooox + X xooo 00
					// sub_carrier_phase is 8 bits: 0 oxxx X xooo
					// check the 3 lsb of pVideo->hdrFirstWord: next info must be a
					// start code
					if ( pVideo->hdrFirstWord & 0x7 ) {
						if ( !pVideo->errCode ) {
							pVideo->errCode = PICT_HEAD;
						}
						SetErrorCode(ERR_PICTURE_HEADER);
					}
					VideoNextStartCode (pVideo, 0 );
				}
				else
				{
					if ( pVideo->hdrFirstWord & 0x3F ) {
						if ( !pVideo->errCode )
							pVideo->errCode = PICT_HEAD;
						SetErrorCode(ERR_PICTURE_HEADER);
					}
					VideoNextStartCode (pVideo, 0 );
				}
			}						   // end of if pVideo->StreamInfo.modeMPEG2
			break;


			/******* Quantization table extension *******/
		case QUANT_EXT:
			/* load_intra_quantizer_matrix is one bit: 00 0 xooo */
			if ( ( pVideo->hdrFirstWord & 0x8 ) != 0 )
			{						   /* Load intra quantizer matrix */
				/* two quant values are 16 bits: 00 0 oxxx + XX X xooo */
			// Read Non Default Intra Quant Table
			for ( i = 0; i < (QUANT_TAB_SIZE/2)  ; i++)
				{
				compute = pVideo->hdrFirstWord << 13;
				VideoReadHeaderDataFifo ( pVideo );
				compute = compute | ( pVideo->hdrFirstWord >> 3 );
				QuantTab[2*i] = (U8)( compute >> 8 );
				QuantTab[2*i+1] = (U8)( compute & 0xFF );
				}
			// Load Intra Quant Tables
			VideoLoadQuantTables(pVideo , TRUE , QuantTab );
			pVideo->defaultTbl = pVideo->defaultTbl & 0xE;	   // bit 0 = 0 : no default table
										 // in the chip */
			}
			/* load_non_intra_quantizer_matrix is one bit: 00 0 oxoo */
			if ( ( pVideo->hdrFirstWord & 0x4 ) != 0 )
			{						   /* Load non intra quantizer matrix */
				// Read Non Default Non Intra Quant Table
				for ( i = 0; i < (QUANT_TAB_SIZE/2)  ; i++)
					{
					compute = pVideo->hdrFirstWord << 14;
					VideoReadHeaderDataFifo ( pVideo );
					compute = compute | ( pVideo->hdrFirstWord >> 2 );
					QuantTab[2*i] = (U8)( compute >> 8 );
					QuantTab[2*i+1] = (U8)( compute & 0xFF );
					}
				// Load Non Intra Quant Tables
				VideoLoadQuantTables(pVideo , FALSE , QuantTab );
				pVideo->defaultTbl = pVideo->defaultTbl & 0xD;	/* bit 1 = 0 : no default
											 * non-intra matrix */
			}
			// check the 2 lsb of pVideo->hdrFirstWord: next info must be a start
			// code
			if ( pVideo->hdrFirstWord & 0x3 ) {
				if ( !pVideo->errCode )
					pVideo->errCode = PICT_HEAD;
				SetErrorCode(ERR_PICTURE_HEADER);
			}
			VideoNextStartCode (pVideo, 0 );
			break;


			/******* picture pan and scan extension *******/
		case PICT_PSV:
			/**************************************************************/
			/* The programmation of the STi3500 offsets is given by:      */
			/* PSV = integer part of (pVideo->StreamInfo.horSize/2 - pVideo->StreamInfo.horDimension/2 + offset)    */
			/*
			 * LSO = fractional part of (pVideo->StreamInfo.horSize/2 - pVideo->StreamInfo.horDimension/2 +
			 * offset)
			 */
			/**************************************************************/

			/* pan_horizontal_offset_integer is 12 bits: 00 0X + XX 00 */
			pVideo->latestPanHor = ( pVideo->hdrFirstWord & 0xF ) << 12;
			VideoReadHeaderDataFifo ( pVideo );
			pVideo->latestPanHor = pVideo->latestPanHor | ( ( pVideo->hdrFirstWord & 0xFF00 ) >> 4 );
			// pan_horizontal_offset has been multiplied by 16
			/* pan_horizontal_offset_sub_pixel is 4 bits: 00 X0 */
			/* that are concatenated with the integer part */
			pVideo->latestPanHor = pVideo->latestPanHor | ( ( pVideo->hdrFirstWord & 0xF0 ) >> 4 );
			// to simplify, the 2 last instructions can be concatenated
			// in:
			// pVideo->latestPanHor = pVideo->latestPanHor | ((pVideo->hdrFirstWord & 0xFFF0)
			// >> 4);
			// note that pVideo->latestPanHor is a signed int

			// marker bit 00 0 xooo: just skipped

			/*
			 * pan_vertical_offset_integer is 12 bits: 00 0oxxx + XX
			 * xooo0
			 */
			pVideo->latestPanVer = ( pVideo->hdrFirstWord & 0x7 ) << 13;
			VideoReadHeaderDataFifo ( pVideo );

			/* pan_vertical_offset_sub_pixel is 4 bits: 00 oxxx xooo */
			// they are linked with the integer part
			pVideo->latestPanVer = pVideo->latestPanVer | ( ( pVideo->hdrFirstWord & 0xFFF8 ) >> 3 );

			// write pan vectors into the decoded picture structure
			if ( ( pVideo->fieldMode == 0 ) || ( pVideo->fieldMode == 2 ) )	// frame picture or
																// first field
			{
				pVideo->pDecodedPict->pan_hor_offset[0] = pVideo->latestPanHor;
				pVideo->pDecodedPict->pan_vert_offset[0] = pVideo->latestPanVer;
			}
			else
			{						   // the offset of second field of
									   // a field picture is stored
									   // // on the second offset
									   // position of the same variable
				pVideo->pDecodedPict->pan_hor_offset[1] = pVideo->latestPanHor;
				pVideo->pDecodedPict->pan_vert_offset[1] = pVideo->latestPanVer;
			}

			// marker bit 00 0 oxoo

			if ( pVideo->StreamInfo.progSeq )	   // a progressive sequence is
									   // always displayed with the
									   // same pan and scan offset
			{
				pVideo->pDecodedPict->pan_hor_offset[1] = pVideo->latestPanHor;
				pVideo->pDecodedPict->pan_vert_offset[1] = pVideo->latestPanVer;
				pVideo->pDecodedPict->pan_hor_offset[2] = pVideo->latestPanHor;
				pVideo->pDecodedPict->pan_vert_offset[2] = pVideo->latestPanVer;
				if ( pVideo->hdrFirstWord & 0x3 ) {
					if ( !pVideo->errCode )
						pVideo->errCode = PICT_HEAD;
					SetErrorCode(ERR_PICTURE_HEADER);
				}
				VideoNextStartCode (pVideo, 0 );
			}


			else if ( !pVideo->StreamInfo.progSeq && ( pVideo->pDecodedPict->pict_struc == 3 ) )
				// Frame picture, not progressive sequence: 2 or 3 pan
				// offsets
			{
				// extract second pan and scan offset

				/*
				 * pan_horizontal_offset_integer is 12 bits: 00 0ooxx +
				 * XX xxoo0
				 */
				pVideo->latestPanHor = ( pVideo->hdrFirstWord & 0x3 ) << 14;
				VideoReadHeaderDataFifo ( pVideo );
				pVideo->latestPanHor = pVideo->latestPanHor | ( ( pVideo->hdrFirstWord & 0xFFC0 ) >> 2 );
				// pan_horizontal_offset has been multiplied by 16
				/*
				 * pan_horizontal_offset_sub_pixel is 4 bits: 00 ooxx
				 * xxoo
				 */
				/* that are concatenated with the integer part */
				pVideo->latestPanHor = pVideo->latestPanHor | ( ( pVideo->hdrFirstWord & 0x3C ) >> 2 );
				pVideo->pDecodedPict->pan_hor_offset[1] = pVideo->latestPanHor;

				// marker bit 00 0 ooxo

				/*
				 * pan_vertical_offset_integer is 12 bits: 00 0ooox +
				 * XX xxxo0
				 */
				pVideo->latestPanVer = ( pVideo->hdrFirstWord & 0x1 ) << 15;
				VideoReadHeaderDataFifo ( pVideo );
				/*
				 * pan_vertical_offset_sub_pixel is 4 bits: 00 ooox
				 * xxxo
				 */
				// concatenated with the integer part
				pVideo->latestPanVer = pVideo->latestPanVer | ( ( pVideo->hdrFirstWord & 0xFFFE ) >> 1 );
				pVideo->pDecodedPict->pan_vert_offset[1] = pVideo->latestPanVer;

				// marker bit 00 0 ooox

				if ( pVideo->pDecodedPict->nb_display_field != 3 )
					VideoNextStartCode (pVideo, 0 );
				else
				{					   // 3 pan & scan offsets
					/* pan_horizontal_offset_integer is 12 bits: XX X0 */
					/* pan_horizontal_offset_sub_pixel is 4 bits: 00 0X */
					/* they are concatenated in a single word */
					VideoReadHeaderDataFifo ( pVideo );
					pVideo->latestPanHor = pVideo->hdrFirstWord;
					pVideo->pDecodedPict->pan_hor_offset[2] = pVideo->latestPanHor;
					VideoReadHeaderDataFifo ( pVideo );

					// marker bit xooo0 00

					/*
					 * pan_vertical_offset_integer is 12 bits: oxxx X X
					 * xooo
					 */
					/*
					 * pan_vertical_offset_sub_pixel is 4 bits: 00 0
					 * oxxx + xooo 0 00
					 */
					pVideo->latestPanVer = ( pVideo->hdrFirstWord & 0x7FFF ) << 1;
					VideoReadHeaderDataFifo ( pVideo );
					pVideo->latestPanVer = ( pVideo->hdrFirstWord & 0x8000 ) >> 15;
					pVideo->pDecodedPict->pan_vert_offset[2] = pVideo->latestPanVer;

					// marker bit oxoo 0 00

					if ( pVideo->hdrFirstWord & 0x3FFF ) {
						if ( !pVideo->errCode )
							pVideo->errCode = PICT_HEAD;
						SetErrorCode(ERR_PICTURE_HEADER);
					}
					VideoNextStartCode (pVideo, 1 );

				}
			}
			break;



			/******* picture scalable extension *******/
		case PICT_SCAL:
			pVideo->hdrFirstWord = 0x0100;		   // not supported: just leave the
										 // test
			break;


			/******* other extension start codes *******/
		default:
			if ( !pVideo->errCode )
				pVideo->errCode = BAD_EXT;	   // extension start code not at the good location !!
			SetErrorCode(ERR_BAD_EXTENSION_SC);
			break;
	}								   // end of switch
}



//----------------------------------------------------------------------------
// USER HEADER routine
//----------------------------------------------------------------------------
/*    this routine just bypasses all the bytes of the user header  */
/*    and is exit with the next start code value into pVideo->hdrFirstWord XX00 */
VOID VideoUser(PVIDEO pVideo)
{
	long toto;
	int  i;

	toto = pVideo->hdrFirstWord << 16;
	VideoReadHeaderDataFifo ( pVideo );
	toto = toto | pVideo->hdrFirstWord;
	while ( ( ( toto & 0x00FFFFFFL ) != 0x00000001L ) &&
			( ( toto & 0xFFFFFF00L ) != 0x00000100L ) )
	{
		toto = toto << 16;
		VideoReadHeaderDataFifo ( pVideo );
		toto = toto | pVideo->hdrFirstWord;
	}
	if ( ( toto & 0x00FFFFFFL ) == 0x00000001L )
		VideoReadHeaderDataFifo ( pVideo );
	else
	{								   // pVideo->hdrFirstWord == 01XX
		if ( !pVideo->hdrPos )	// there is nothing into  pVideo->hdrNextWord
		{
			pVideo->hdrPos = 8;
			pVideo->hdrNextWord = ( pVideo->hdrFirstWord & 0xFF ) << 8;
			VideoReadHeaderDataFifo ( pVideo );
		}
		else
		{							   // pVideo->hdrPos = 8: the next
									   // byte is into pVideo->hdrNextWord
			pVideo->hdrFirstWord = ( pVideo->hdrFirstWord << 8 ) | ( pVideo->hdrNextWord >> 8 );
			pVideo->hdrPos = 0;
		}
	}
	i = VideoRead ( ITS ) << 8;   // allows to clear the Header
									   // hit bit
	i = ( i | VideoRead ( ITS + 1 ) ) & 0xFFFE;	// allows to clear the
														// Header hit bit
	pVideo->intStatus = ( pVideo->intStatus | i ) & pVideo->intMask;
}

//------------------------------- End of File --------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\stfifo.h ===
#ifndef __STFIFO_H
#define __STFIFO_H
//----------------------------------------------------------------------------
// STFIFO.H
//----------------------------------------------------------------------------
// Description : small description of the goal of the module
//----------------------------------------------------------------------------
// Copyright SGS Thomson Microelectronics  !  Version alpha  !  Jan 1st, 1995
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                               Include files
//----------------------------------------------------------------------------
#include "stdefs.h"

//----------------------------------------------------------------------------
//                             Exported Constants
//----------------------------------------------------------------------------
#define FIFO_SIZE 128

//----------------------------------------------------------------------------
//                               Exported Types
//----------------------------------------------------------------------------
typedef struct
{
	U32 PtsVal;
	U32 CdCount;
} FIFOELT, FAR *PFIFOELT;

typedef struct
{
	U16     NbElement; // number of elements in the fifo
	U16     AdInput;   // input address
	U16     AdOutput;  // output address
	FIFOELT FifoTab[FIFO_SIZE];
	U16     ErrorMsg;
}FIFO, FAR *PFIFO;

//----------------------------------------------------------------------------
//                             Exported Variables
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Exported Functions
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// One line function description (same as in .C)
//----------------------------------------------------------------------------
// In     :
// Out    :
// InOut  :
// Global :
// Return :
//----------------------------------------------------------------------------
VOID FifoOpen(PFIFO pFifo);
VOID FifoReset(PFIFO pFifo);
U16 FifoReadPts(PFIFO pFifo, PFIFOELT pElt);
U16	FifoGetPts(PFIFO pFifo, PFIFOELT pElt);
U16 FifoPutPts(PFIFO pFifo, PFIFOELT pElt);
VOID FifoClose(VOID);

//------------------------------- End of File --------------------------------
#endif // #ifndef __STFIFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\sti3520a.h ===
#ifndef __STi3520A_H
#define __STi3520A_H
//----------------------------------------------------------------------------
// STi3520A.H
//----------------------------------------------------------------------------
// Description : small description of the goal of the module
//----------------------------------------------------------------------------
// Copyright SGS Thomson Microelectronics  !  Version alpha  !  Jan 1st, 1995
//----------------------------------------------------------------------------

#if defined(STi3520)
	#error This file is only for STi3520A !
#endif

//----------------------------------------------------------------------------
//                               Include files
//----------------------------------------------------------------------------
#include "stdefs.h"

//----------------------------------------------------------------------------
//                             Exported Constants
//----------------------------------------------------------------------------
/*******************************************************/
/*    Definition of the STi3520A registers   		   */
/*******************************************************/
#define CFG_MCF			0x00
#define CFG_CCF			0x01
#define VID_CTL			0x02
#define VID_TIS			0x03
#define VID_PFH			0x04
#define VID_PFV			0x05
#define VID_PPR1		0x06
#define VID_PPR2		0x07
#define CFG_MRF			0x08
#define CFG_MWF			0x08
#define CFG_BMS			0x09
#define CFG_MRP			0x0A
#define CFG_MWP			0x0B
#define VID_DFP			0x0C
#define VID_RFP			0x0E
#define VID_FFP			0x10
#define VID_BFP			0x12
#define VID_VBG			0x14
#define VID_VBL			0x16
#define VID_VBS			0x18
#define VID_VBT			0x1A

#define AUD_ABG  		0X1C
#define AUD_ABL			0X1E
#define AUD_ABS			0X20
#define AUD_ABT			0X22

#define VID_DFS			0x24
#define VID_DFW			0x25
#define VID_DFA			0x26
#define VID_XFS			0x27
#define VID_XFW			0x28
#define VID_XFA			0x29
#define VID_OTP			0x2A
#define VID_OBP			0x2B
#define VID_PAN			0x2C
#define VID_SCN			0x2E
#define VID_REV			0x78
#define CKG_PLL			0x30
#define CKG_CFG			0x31
#define CKG_AUD			0x32
#define CKG_VID			0x33
#define CKG_PIX			0x34
#define CKG_PCM			0x35
#define CKG_MCK			0x36
#define CKG_AUX			0x37
#define CKG_DRC			0x38
#define CFG_BFS			0x39
#define PES_AUD			0x40
#define PES_VID			0x41
#define PES_SPF			0x42
#define PES_STA			0x43
#define PES_SC1			0x44
#define PES_SC2			0x45
#define PES_SC3			0x46
#define PES_SC4			0x47
#define PES_SC5			0x48
#define PES_TS1			0x49
#define PES_TS2			0x4A
#define PES_TS3			0x4B
#define PES_TS4			0x4C
#define PES_TS5			0x4D
#define PES_PTS_FIFO 0x68

#define VID_ITM			0x60
#define VID_ITM1		0x3C
#define VID_ITS			0x62
#define VID_ITS1		0x3D
#define VID_STA			0x64
#define VID_STA1		0x3B
#define VID_HDF			0x66
#define CDcount			0x67
#define SCDcount		0x68
#define VID_HDS			0x69
#define VID_LSO			0x6A
#define VID_LSR			0x6B
#define VID_CSO			0x6C
#define VID_LSRh		0x6D
#define VID_YDO			0x6E
#define VID_YDS			0x6F
#define VID_XDO			0x70
#define VID_XDS			0x72
#define VID_DCF			0x74
#define VID_QMW			0x76
#define VID_TST			0x77

/************************************************************/
/*    Definition of STi3520A registers with STi3520 names  */
/************************************************************/
#define HDF 	VID_HDF
#define CTL 	VID_CTL
#define STA 	VID_STA
#define ITM 	VID_ITM
#define ITM1	VID_ITM1
#define ITS 	VID_ITS
#define ITS1 	VID_ITS1
#define MRF 	CFG_MRF
#define MWF 	CFG_MWF
#define BMS 	CFG_BMS
#define MRP		CFG_MRP
#define MWP		CFG_MWP
#define DFP 	VID_DFP
#define RFP		VID_RFP
#define FFP		VID_FFP
#define BFP		VID_BFP
#define FBP		VID_FBP	// shares the same address as BFP
#define BBL		VID_VBL
#define BBS		VID_VBS
#define BBG		VID_VBG
#define BBT		VID_VBT
#define DFW		VID_DFW
#define DFS		VID_DFS
#define YDO		VID_YDO
#define XDO		VID_XDO
#define YDS		VID_YDS
#define XDS		VID_XDS
#define OEP		VID_OBP
#define OOP 	VID_OTP
#define LSO		VID_LSO
#define LSR		VID_LSR
#define CSO		VID_CSO
#define DCF		VID_DCF
#define QMW		VID_QMW
/*********************************************/
/*    Definition of the STi3520A Bit Position*/
/*********************************************/
// CFG_CCF    Register bits
#define M32        0x80
#define M16        0x40
#define PBO        0x20
#define EC3        0x10
#define EC2        0x08
#define ECK        0x04
#define EDI        0x02
#define EVI        0x01
// CFG_DRC    Register bits
#define NPD        0x40
#define MRS        0x20
#define SGR        0x08
#define CLK        0x04
#define HPD        0x02
#define SDR        0x01
// CFG_MCF    Register bits
#define M20        0x80
#define RFI        0x7F
// CTL    Register bits
#define ERU			   0x80
#define ERS	       0x40
#define CBC	       0x20
#define DEC	       0x10
#define EPR	       0x08
#define PRS			   0x04
#define SRS			   0x02
#define EDC        0x01
#define A35        0x8000	// for STi3500A code compatibility

// DCF    Register bits
#define OAD1	0x8000
#define OAD0	0x4000
#define OAM		0x2000
#define XYE		0x1000
#define DAM2	0x0800
#define DAM1	0x0400
#define DAM0	0x0200
#define FLD	  0x0100
#define USR		0x0080
#define PXD	  0x0040
#define EVD	  0x0020
#define EOS	  0x0010
#define DSR	  0x0008
#define VFC2	0x0004
#define VFC1	0x0002
#define VFC0	0x0001
// ITM/ITS/STA   Status Register bits
#define PDE		0x8000
#define SER		0x4000
#define BMI		0x2000
#define HFF		0x1000
#define RFF		0x0800
#define WFE		0x0400
#define PID		0x0200
#define PER		0x0100
#define PSD 	0x0080
#define TOP 	0x0040
#define BOT 	0x0020
#define BBE		0x0010
#define BBF		0x0008
#define HFE		0x0004
#define BFF		0x0002
#define HIT		0x0001

// VID_TIS    Register bits
#define MP2	  0x40
#define SKP1  0x20
#define SKP0  0x10
#define OVW	  0x08
#define FIS	  0x04
#define RPT	  0x02
#define EXE	  0x01

#define SOS		0x08
#define QMN		0x04
#define QMI		0x02
#define HDS   0x01

//*************************************************
// STi4500 register definitions
//*************************************************
#define ANC                0x06
#define ANC_AV             0x6C
#define ATTEN_L            0x1E
#define ATTEN_R            0x20
#define AUDIO_ID           0x22
#define AUDIO_ID_EN        0x24
#define BALE_LIM_H         0x69
#define BALF_LIM_H         0x6B
#define CRC_ECM            0x2A
#define DIF                0x6F
#define DMPH               0x46
#define DRAM_EXT           0x3E
#define DUAL_REG           0x1F
#define FIFO_IN_TRESHOLD   0x52
#define FORMAT             0x19
#define FRAME_NUMBER       0x13
#define FRAME_OFFSET       0x12
#define FREE_FORM_H        0x15
#define FREE_FORM_L        0x14
#define HEADER             0x5E
#define INTR               0x1A
#define INTR_EN            0x1C
#define INVERT_LRCLK       0x11
#define INVERT_SCLK        0x53
#define LATENCY            0x3C
#define MUTE               0x30
#define PACKET_SYNC_CHOICE 0x23
#define PCM_DIV            0x6E
#define PCM_FS             0x44
#define PCM_ORD            0x38
#define PCM_18             0x16
#define PLAY               0x2E
#define PTS_0              0x62
#define PTS_1              0x63
#define PTS_2              0x64
#define PTS_3              0x65
#define PTS_4              0x66
#define REPEAT             0x34
#define RESET              0x40
#define RESTART            0x42
#define SIN_EN             0x70
#define SKIP               0x32
#define STC_INC            0x10
#define STC_DIVH           0x49
#define STC_DIVL           0x48
#define STC_CTL            0x21
#define STC_0              0x4A
#define STC_1              0x4B
#define STC_2              0x4C
#define STC_3              0x4D
#define STC_4              0x4E
#define STR_SEL            0x36
#define SYNCHRO_CONFIRM    0x25
#define SYNC_ECM           0x2C
#define SYNC_LCK           0x28
#define SYNC_REG           0x27
#define SYNC_ST            0x26
#define VERSION            0x6D

/* Define Interrupt Masks of the STi4500*/
#define SYNC        0x0001  // Set upon change in synchro status
#define HEAD        0x0002  // Set when a valid header has been registered
#define PTS         0x0004  // Set when PTS detected
#define BALE        0x0008  // Set when under BALE treshold
#define BALF        0x0010  // Set when over BALF treshold
#define CRC         0x0020  // Set when CRC error is detected
#define ANCI        0x0080  // Set when Ancillary buffer is full
#define PCMU        0x0100  // Set on PCM buffer underflow
#define SAMP        0x0200  // Set when sampling frequency has changed
#define DEMP        0x0400  // Set when de-emphasis changed
#define DFUL        0x0800  // Set when DRAM is full
#define FIFT        0x1000  // Set when fifo_in_treshold reached
#define FIFF        0x2000  // Set when fifo is full
#define BOF         0x4000  // Set when Begining of frame

#define NSYNC       0xFFFE  // Set upon change in synchro status
#define NHEAD       0xFFFD  // Set when a valid header has been registered
#define NPTS        0xFFFB  // Set when PTS detected
#define NBALE       0xFFF7  // Set when under BALE treshold
#define NBALF       0xFFEF  // Set when over BALF treshold
#define NCRC        0xFFDF  // Set when CRC error is detected
#define NANC        0xFF7F  // Set when Ancillary buffer is full
#define NPCMU       0xFEFF  // Set on PCM buffer underflow
#define NSAMP       0xFDFF  // Set when sampling frequency has changed
#define NDEMP       0xFBFF  // Set when de-emphasis changed
#define NDFUL       0xF7FF  // Set when DRAM is full
#define NFIFT       0xEFFF  // Set when fifo_in_treshold reached
#define NFIFF       0xDFFF  // Set when fifo is full
#define NBOF        0xBFFF  // Set when Begining of frame

//----------------------------------------------------------------------------
//                               Exported Types
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Exported Variables
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Exported Functions
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// One line function description (same as in .C)
//----------------------------------------------------------------------------
// In     :
// Out    :
// InOut  :
// Global :
// Return :
//----------------------------------------------------------------------------


//------------------------------- End of File --------------------------------
#endif // #ifndef __STi3520A_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\stisr.c ===
//----------------------------------------------------------------------------
// STISR.C
//----------------------------------------------------------------------------
// Description : small description of the goal of the module
//----------------------------------------------------------------------------
// Copyright SGS Thomson Microelectronics  !  Version alpha  !  Jan 1st, 1995
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Include files
//----------------------------------------------------------------------------
#include "stdefs.h"
#include "common.h"
#include "STllapi.h"
#include "stvideo.h"
#include "debug.h"
#include "error.h"
#ifdef STi3520A
	#include "STi3520A.h"
#else
	#include "STi3520.h"
#endif

//----------------------------------------------------------------------------
//                   GLOBAL Variables (avoid as possible)
//----------------------------------------------------------------------------
U8 Sequence = 1;

//----------------------------------------------------------------------------
//                            Private Constants
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                              Private Types
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                     Private GLOBAL Variables (static)
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                    Functions (statics one are private)
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// Mask Video Interrupts
//----------------------------------------------------------------------------
void VideoMaskInt ( PVIDEO pVideo )
{
	VideoWrite( ITM, 0 );	    // mask chip interrupts before reading the status
	VideoWrite( ITM + 1, 0 ); // avoids possible gliches on the IRQ line
#ifdef STi3520A
VideoWrite( VID_ITM1, 0 );	// mask chip interrupts before
#endif
}

//----------------------------------------------------------------------------
// Restore Video Interrupts Mask
//----------------------------------------------------------------------------
void    VideoRestoreInt ( PVIDEO pVideo )
{
	VideoWrite( ITM, ( pVideo->intMask >> 8 ) );
	VideoWrite( ITM + 1, ( pVideo->intMask & 0xFF ) );
}

//----------------------------------------------------------------------------
// Interrupt routine (All the control is made in this routine)
//----------------------------------------------------------------------------
BOOLEAN VideoVideoInt(PVIDEO pVideo)
{
	BOOLEAN VideoITOccured = FALSE;
	U16    compute;
	pVideo->VsyncInterrupt = FALSE;
	pVideo->FirstDTS = FALSE;
#ifdef STi3520A
VideoRead ( ITS1 );
#endif
 /* All interrupts except the first one are computed in this area */
pVideo->intStatus = VideoRead ( ITS ) << 8;
 // Reading the interrupt status register
pVideo->intStatus = VideoRead ( ITS + 1 ) | pVideo->intStatus;
 // All the STI3500 interrupts are cleared */
pVideo->intStatus = pVideo->intStatus & pVideo->intMask;
 // To mask the IT not used */

while ( pVideo->intStatus )				   // stay into interrupt routine
									   // until all the bits have not
									   // been tested
{
	VideoITOccured = TRUE;


	/******************************************************/
	/**              BOTTOM VSYNC INTERRUPT              **/
	/******************************************************/
	if ( ( pVideo->intStatus & BOT ) != 0x0 )
	{
DBG1('B');
		pVideo->intStatus = pVideo->intStatus & ~BOT;
		// clear BOT bit
		VideoChooseField ( pVideo);
		pVideo->currField = BOT;
		if(pVideo->InvertedField)
			pVideo->currField = TOP;
		VideoVsyncRout ( pVideo );
	}
	/******************************************************/
	/**                TOP VSYNC INTERRUPT               **/
	/******************************************************/
	if ( ( pVideo->intStatus & TOP ) != 0x0 )
	{
DBG1('T');
		pVideo->intStatus = pVideo->intStatus & ~TOP;
		// clear TOP bit

		VideoChooseField ( pVideo );
		pVideo->currField = TOP;
		if(pVideo->InvertedField)
				pVideo->currField = BOT;
		VideoVsyncRout ( pVideo );

	}
	/******************************************************/
	/**                   DSYNC INTERRUPT                **/
	/******************************************************/
	/***************************************************************/
	/* The DSYNC interrupt is generated on each VSYNC (RPT = 0)    */
	/* if the next INStrucztion has the EXE bit set.         */
	/* On each DSYNC a new Header Search is automatically started. */
	/***************************************************************/

	if ( ( pVideo->intStatus & PSD ) != 0x0 )
	{
DBG1('d');
		pVideo->intStatus = pVideo->intStatus & ~PSD;
		// clear PSD bit
		pVideo->VsyncNumber = 0;		   /* clear software watch-dog */
		/* check if we have reached the first picture with a PTS */


		if ( pVideo->NextInstr.Seq )		   // first interrupt enabled (Searching Sequence)
		{
			VideoWaitDec ( pVideo );			   // put decoder in Wait mode
			pVideo->intMask = 0x1;		   /* enable header hit interrupt */
			pVideo->NextInstr.Seq = 0;
			pVideo->NextInstr.Exe = 0;
		}
		else
		{
		Sequence = 0;
			if ( VideoGetState ( pVideo ) == VIDEO_START_UP )
			{
				if ( pVideo->pDecodedPict->validPTS == TRUE )
				{
					pVideo->FirstDTS = TRUE;
					pVideo->VideoState = VIDEO_DECODE;
				}
			}


			/* Check bit buffer level consistency with pVideo->vbveDelay  */
			/* of the picture that the STi3500 starts to decode   */
			if ( ( pVideo->fieldMode == 0 ) || ( pVideo->fieldMode == 2 ) )
				// frame picture or first field of a field picture
			{
				compute = VideoGetBBL();
				if ( compute < ( 4 * pVideo->vbvDelay / 5) ) // 0.8 is 4/5 !
					// bit buffer level is not high enough for the next
					// picture: wait !!!
				{					   // we stop the current decoding
										 // process for two fields
					DBG1('<');
					VideoEnableDecoding(pVideo, OFF);
					pVideo->needDataInBuff = pVideo->currField;
				}
			}


			/********************************************************************/
			/*
			 * We put the decoder in wait mode on DSYNC: EXE bit reset
			 * into INS.
			 */
			/*
			 * In normal case the DSYNC interrupt is quickly followed
			 * by a
			 */
			/*
			 * Header Hit int. during which the next INS is written
			 * with EXE=1.
			 */
			/*
			 * If for any reason the header hit is delayed, the STi3500
			 * will
			 */
			/* see the notEXE and stay in WAIT mode without crashing...         */
			/* this can typically appear if the bit buffer gets empty.          */
			/********************************************************************/
			if ( !pVideo->needDataInBuff )
			{
				VideoWaitDec ( pVideo );		   // put decoder in Wait mode
				pVideo->NextInstr.Exe = 0;
				// reset EXE bit.
			}

			/* update the display frame pointer for the next VSYNC */
			if ( ( pVideo->fieldMode == 0 ) || ( pVideo->fieldMode == 2 ) )
				// frame picture or first field of a field picture
			{
				pVideo->pCurrDisplay = pVideo->pNextDisplay;
				// preset the VSYNC counter
				pVideo->pictDispIndex = 0 - ( 2 * pVideo->decSlowDown );
				if ( pVideo->DecodeMode != SLOW_MODE )
					pVideo->decSlowDown = 0;		   /* allows to do the repeat
									    * function */
				VideoWrite( DFP, ( pVideo->pCurrDisplay->buffer >> 8 ) );
				VideoWrite( DFP + 1, ( pVideo->pCurrDisplay->buffer & 0xFF ) );

				pVideo->displaySecondField = 0;
				VideoChooseField ( pVideo );
			}
			VideoSetPSV ( pVideo );			   // update the next pan vector
			// frame picture or second field of field picture */
//			if ( ( pVideo->VideoState == VIDEO_PAUSE ) && ( pVideo->fieldMode != 2 ) )
//				pVideo->pictureDecoded = 1;
			// to know that in step by step, the picture is decoded
		}
	}
	/******************************************************/
	/**                HEADER HIT INTERRUPT              **/
	/******************************************************/
	if ( ( pVideo->intStatus & HIT ) != 0 )
		// Test Header hit interrupt
	{
		U16    temp = 0;

		pVideo->intStatus = pVideo->intStatus & ~HIT;
		// clear HIT bit
		while ( VideoHeaderFifoEmpty())
			/* Header fifo not available */
		{
			temp++;
			if ( temp == 0xFFFF )
			{
				if ( !pVideo->errCode )
					pVideo->errCode = BUF_EMPTY;
				SetErrorCode(ERR_HEADER_FIFO_EMPTY);
				break;
			}
		}							   /* Waiting... */
		compute = VideoRead(HDF);
		//compute = VideoRead ( HDF );
		/* load MSB */
		pVideo->hdrPos = 0;			   /* start code is MSB */
		if ( compute == 0x01 )
		{
			pVideo->hdrPos = 8;		   /* start code value is in LSB */
#ifndef STi3520A
			pVideo->hdrNextWord = VideoRead ( HDF + 1 ) << 8;
#else
			pVideo->hdrNextWord = VideoRead(HDF)<<8;//VideoRead ( HDF ) << 8;
#endif
			VideoReadHeaderDataFifo ( pVideo );
			/* Result in pVideo->hdrFirstWord */
		}
		else
		{
			pVideo->hdrNextWord = 0;
#ifndef STi3520A
			pVideo->hdrFirstWord = VideoRead ( HDF + 1 );
#else
			pVideo->hdrFirstWord = VideoRead(HDF);
#endif
			pVideo->hdrFirstWord = pVideo->hdrFirstWord | ( compute << 8 );
		}
		/*
		 * on that point the start code value is always the MSByte of
		 * pVideo->hdrFirstWord
		 */

		switch ( pVideo->hdrFirstWord & 0xFF00 )
		{
				U32             buf_control;
				U32             size_of_pict;

			case SEQ:
DBG1('s');
				VideoSequenceHeader ( pVideo );
				VideoLaunchHeadSearch ( pVideo );
				/* Restart Header Search */
				break;
			case EXT:
				VideoExtensionHeader ( pVideo );
				VideoLaunchHeadSearch ( pVideo );
				/* Restart Header Search */
				break;
			case GOP:
DBG1('g');
				VideoGopHeader ( pVideo );
				VideoLaunchHeadSearch ( pVideo );
				/* Restart Header Search */
				break;
			case PICT:
DBG1('h');
				VideoPictureHeader ( pVideo );
//**********************************
//* This part of the code
//* Computes the size of last picture
//* and substracts it to lastbuffer level
//* This allows to track if pipe/scd are misalined
//**********************************
				buf_control = VideoReadSCDCount ( pVideo );
				if ( pVideo->LastScdCount > buf_control )
					size_of_pict = ( 0x1000000L - pVideo->LastScdCount ) + buf_control;
				else
					size_of_pict = buf_control - pVideo->LastScdCount;

				pVideo->LastScdCount = buf_control;
				if ( pVideo->fastForward )
					pVideo->LastPipeReset = 3;
				pVideo->LastBufferLevel -= ( U16 ) ( size_of_pict >> 7 );
//******************************
//End of misalined pb tracking
//******************************
				/* don't restart header search !!! */
				if ( pVideo->skipMode )			   // restart search only if we
										 // skip this picture
				{
				VideoLaunchHeadSearch ( pVideo );
					/* Restart Header Search */
				}
				break;
			case USER:				   // We don't care about user
										 // fields
				VideoLaunchHeadSearch ( pVideo );
				/* Restart Header Search */
				break;
			case SEQ_END:			   // end of sequence code
				compute = VideoRead ( ITS ) << 8;
				// this start code can be back to back with next one
				compute = ( compute | VideoRead ( ITS + 1 ) );
				// in such case the HDS bit can be set
				pVideo->intStatus = ( pVideo->intStatus | compute ) & pVideo->intMask;
				if ( !( pVideo->intStatus & HIT ) )
				{
				VideoLaunchHeadSearch ( pVideo );
					/* Restart Header Search */
				}
				break;
			case SEQ_ERR:			   // the chip will enter the
										 // automatic error concealment
										 // mode
				compute = VideoRead ( ITS ) << 8;
				// this start code can be back to back with next one
				compute = ( compute | VideoRead ( ITS + 1 ) );
				// in such case the HDS bit can be set
				pVideo->intStatus = ( pVideo->intStatus | compute ) & pVideo->intMask;
				if ( !( pVideo->intStatus & HIT ) )
				{
				VideoLaunchHeadSearch ( pVideo );
					/* Restart Header Search */
				}
				break;
			default:
				if ( !pVideo->errCode )
					pVideo->errCode = S_C_ERR;
				SetErrorCode(ERR_UNKNOWN_SC);
				// non video start code
				break;
		}

	}								   // end of header hit interrupt


	/******************************************************/
	/**            BIT BUFFER FULL INTERRUPT             **/
	/******************************************************/
	if ( ( pVideo->intStatus & BBF ) != 0x0 )
		/* Bit buffer full */
	{
DBG1('*');
		pVideo->intStatus = pVideo->intStatus & ~BBF;
		// clear BBF bit
		if ( pVideo->vbvReached == 1 )		   /* bit buffer level too high */
		{
			if ( !pVideo->errCode )
				pVideo->errCode = FULL_BUF;	   /* mention of the error */
      SetErrorCode(ERR_BIT_BUFFER_FULL);
			VideoWaitDec ( pVideo );			   // put decoder in Wait mode
			pVideo->NextInstr = pVideo->ZeroInstr;
		}
		else
		{
			S16 BitBufferLevel;

			BitBufferLevel = BUF_FULL - 2;
			VideoSetBBThresh(BitBufferLevel);
			pVideo->intMask = PID | SER | PER | PSD | BOT | TOP | BBE | HIT;
			/* enable all interrupts that may be used */
			VideoRead ( ITS );
#ifdef STi3520A
			VideoRead ( ITS + 1);
#endif
			// to clear previous TOP VSYNC flag
			pVideo->NextInstr.Exe = 1;;	// decoding will start on
										// next "good" Vsync */
			pVideo->VsyncNumber = 0;
			pVideo->pictDispIndex = 1;
			pVideo->pCurrDisplay->nb_display_field = 1;
			pVideo->vbvReached = 1;
		}
	}


	//*****************************************************/
	//*                   pipeline ERROR                 **/
	//*****************************************************/
	// The pipeline reset is made here by software     */
	// It is also possible to enable the automatic     */
	// Pipeline reset by setting bit EPR of CTL reg.   */
	// This could be done in the Reset3500 routine    */
	// In this case the pipeline error interrupt is    */
	// only used as a flag for the external micro.     */
	//*****************************************************/
	if ( ( pVideo->intStatus & PER ) != 0x0 )
	{
DBG1('p');

		pVideo->intStatus = pVideo->intStatus & ~PER;
		// clear PER bit
//		VideoPipeReset ( pVideo );

	}


	/******************************************************/
	/**                   serious ERROR                  **/
	/******************************************************/
	if ( ( pVideo->intStatus & SER ) != 0x0 )
	{
DBG1('s');

		pVideo->intStatus = pVideo->intStatus & ~SER;
		// clear SER bit
		VideoPipeReset ( pVideo );
	}

	/********************************/
	/* bit buffer empty interrupt  */
	/********************************/
	if ( ( pVideo->intStatus & BBE ) != 0x0 )
		// bit buffer empty
	{
		pVideo->intStatus = pVideo->intStatus & ~BBE;
		// clear BBE bit
	}


/********************************/
/* pipeline idle interrupt    */
/********************************/
	if ( ( pVideo->intStatus & PID ) != 0x0 )
		// pipeline idle
	{
	//***************************************
	// Check If pipe is misalined with scd
	// and restart header search if it is
	// the case
	//***************************************
		U32   NewCd;
		U32   EnterBitBuffer;
		U16   NewBbl;
		U16   ExpectedBbl;
		// clear PID bit
		pVideo->intStatus = pVideo->intStatus & ~PID;
		/* read BBL level */
		NewBbl = VideoGetBBL();
		/* Read number of compressed data loaded into the chip */
		NewCd = VideoReadCDCount ( pVideo );

		if ( NewCd < pVideo->LastCdCount )
			EnterBitBuffer = ( 0x1000000L - pVideo->LastCdCount ) + NewCd;
		else
			EnterBitBuffer = ( NewCd - pVideo->LastCdCount );

		//Expected Bitbuffer level is Old bbl + what enterred - what left
		//pVideo->LastBufferLevel holds Old bbl + what enterred and has been
		// updated in picture hit interrupt.
		ExpectedBbl = pVideo->LastBufferLevel + ( EnterBitBuffer >> 8 ) - 2;
		if ( pVideo->LastPipeReset == 0 )
		{
			/* BBL is lower than it should be !!! */
			if ( NewBbl < ExpectedBbl )
			{
				DBG1('#');
				/* here we force manually a new header search because */
				/* the pipeline is supposed to have skipped a picture */
				/* i.e. the start code detector and the pipeline are  */
				/* not synchronised on the same picture               */
				VideoLaunchHeadSearch ( pVideo );
				pVideo->LastPipeReset = 1;
			}
		}
		else
			{
			pVideo->LastPipeReset--;
			}
		pVideo->LastCdCount = NewCd;
		pVideo->LastBufferLevel = NewBbl;
	}

	/******************************************************/
	/**             END OF INTERRUPT ROUTINE             **/
	/******************************************************/
	/* common to all interrupts */
	/* set interrupt mask to the correct value */
}									   // end of while
return VideoITOccured;
}

//------------------------------- End of File --------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\stdisp.c ===
//----------------------------------------------------------------------------
// STDISP.C
//----------------------------------------------------------------------------
// Description : Display management routines
//----------------------------------------------------------------------------
// Copyright SGS Thomson Microelectronics  !  Version alpha  !  Jan 1st, 1995
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Include files
//----------------------------------------------------------------------------
#include "stdefs.h"
#include "common.h"
#include "STvideo.h"
#include "stllapi.h"
#include "error.h"
#ifdef STi3520A
	#include "STi3520A.h"
#else
	#include "STi3520.h"
#endif

//----------------------------------------------------------------------------
//                   GLOBAL Variables (avoid as possible)
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                            Private Constants
//----------------------------------------------------------------------------
#define SIZE_OF_PICT 540

//----------------------------------------------------------------------------
//                              Private Types
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                     Private GLOBAL Variables (static)
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                    Functions (statics one are private)
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// Enable OSD
//----------------------------------------------------------------------------
VOID VideoOsdOn(PVIDEO pVideo)
{
	pVideo->currDCF = pVideo->currDCF | 0x10;
	DisableIT();
	VideoWrite(DCF, 0);
	VideoWrite(DCF + 1, pVideo->currDCF);
	EnableIT();
}

//----------------------------------------------------------------------------
// Disable OSD
//----------------------------------------------------------------------------
VOID VideoOsdOff ( PVIDEO pVideo )
{
	pVideo->currDCF = pVideo->currDCF & 0xEF;
	DisableIT();
	VideoWrite(DCF, 0);
	VideoWrite(DCF + 1, pVideo->currDCF);
	EnableIT();
}

//----------------------------------------------------------------------------
// initialisation of the OSD pointers
//----------------------------------------------------------------------------
void VideoInitOEP (PVIDEO pVideo, U32 point_oep )
{
#ifndef STi3520A
	VideoWrite ( OEP, ( point_oep >> 13 ) & 0xFF );
	VideoWrite ( OEP + 1, ( point_oep >> 5 ) & 0xFF );
	VideoWrite ( OOP, ( point_oep >> 13 ) & 0xFF );
	VideoWrite ( OOP + 1, ( point_oep >> 5 ) & 0xFF );
#else
	VideoWrite ( VID_OBP, ( point_oep >> 13 ) & 0xFF );
	VideoWrite ( VID_OBP, ( point_oep >> 5 ) & 0xFF );
	VideoWrite ( VID_OTP, ( point_oep >> 13 ) & 0xFF );
	VideoWrite ( VID_OTP, ( point_oep >> 5 ) & 0xFF );
#endif
}

//----------------------------------------------------------------------------
// Set video window position and size (top left=X0,Y0) (bottom right=X1,Y1)
//----------------------------------------------------------------------------
void VideoSetVideoWindow (PVIDEO pVideo, U16 a, U16 b, U16 c, U16 d )
{
	pVideo->Xdo = a;
	pVideo->Ydo = b;
	pVideo->Xd1 = c;
	pVideo->Yd1 = d;
	VideoInitXY (pVideo);
}

//----------------------------------------------------------------------------
//     Initialisation of the horizontal & vertical offsets
//----------------------------------------------------------------------------
void VideoInitXY(PVIDEO pVideo)
{
	U16	yds, xds;

	// set vertical stop position
	if ( pVideo->StreamInfo.verSize <= 288 )			   // half res decoding
		yds = pVideo->StreamInfo.verSize + pVideo->Ydo - 129;
	/* number of lines + offset - 128 - 1 */
	else							   // full resolution decoding
		yds = ( pVideo->StreamInfo.verSize >> 1 ) + pVideo->Ydo - 129;
	/* number of lines + offset - 128 - 1 */
	if ( yds > pVideo->Yd1 )
		yds = pVideo->Yd1;

	// set horizontal stop position: we always display 720 pixels
	// XDS given by the relation: 2*XDO + 40 + 2*L = 2*XDS + 28
	// XDS = XDO + 726 with 720 displayed pixels.
	xds = pVideo->Xdo + 726;
	if ( xds > 800 )					   /* 800 = max number of pels allowed per line */
		xds = 800;
	if ( xds > pVideo->Xd1 )
		xds = pVideo->Xd1;				   /* not bigger than the video window */
	SetXY( pVideo, xds, yds );
}

//----------------------------------------------------------------------------
// Storage of the horizontal & vertical offsets
//----------------------------------------------------------------------------
void SetXY(PVIDEO pVideo, U16 xds, U16 yds)
{
#ifndef STi3520A
	U8 dcfh, dcfl;
	VideoWrite ( YDO, pVideo->Ydo );
	VideoWrite ( XDO, pVideo->Xdo & 0xFF );
	VideoWrite ( YDS, yds ); /* stores YDS into tempo internal register */
	VideoWrite ( XDS, xds & 0xFF );
	/* writes YDS and XDS values into the chip */
	// write XDO and XDS MSbits D9 and D8
	dcfh = VideoRead ( DCF );
	VideoWrite ( DCF, dcfh | 0x10 );
	// preset a write to XDO[9:8]
	dcfl = VideoRead ( DCF + 1 );
	VideoWrite ( DCF + 1, dcfl & 0xFF );
	// allows to write DCF.
	VideoWrite ( XDO, (pVideo->Xdo >> 8)&0xFF );
	VideoWrite ( XDS, xds >> 8 );
	VideoWrite ( DCF, dcfh );
	VideoWrite ( DCF + 1, dcfl );
	// allows to write DCF.
#else
//0xds = pVideo->Xdo + SIZE_OF_PICT +6;
	VideoWrite ( XDO   , pVideo->Xdo >> 8 );
	VideoWrite ( XDO+1 , pVideo->Xdo & 0xFF );
	VideoWrite ( YDO   , pVideo->Ydo );

	VideoWrite ( XDS   , xds >> 8 );
	VideoWrite ( XDS+1 , xds & 0xFF );
	VideoWrite ( YDS   , yds );
#endif
}

//----------------------------------------------------------------------------
// Set next display frame pointer
//----------------------------------------------------------------------------
/*
	This routine determines which is the next frame pointer that
	must be used for display. It takes care about the fact that
	the temporal references may not be consecutive in case of
	sikipped pictures...
*/
VOID VideoDisplayCtrl(PVIDEO pVideo)
{
	S16  comput1, index;
	U16  min_temp_ref;
	U16  cur_ref;

	min_temp_ref = ( pVideo->currTempRef & 0xF000 ) + 1024;
	// keep current pVideo->GOPindex
	index = 5;
	pVideo->currTempRef++; /* increment display temporal ref */

	/************** WARNING ************/
	// this routine will not work properly if GOP size > 1023
	if ( ( pVideo->currTempRef & 0xFFF ) > 1023 )   // 2 msb are used as pVideo->GOPindex
		pVideo->currTempRef = pVideo->currTempRef & 0xF000;   /* max temp ref is 1023: reset to 0 */

	/* search frame store to display */
	for (comput1 = 0; comput1 <= 3; comput1++) {
		cur_ref = pVideo->pictArray[comput1].tempRef & 0xFFF;
		if ( ( ( pVideo->currTempRef & 0xF000 ) == ( pVideo->pictArray[comput1].tempRef & 0xF000 ) )
			 && ( pVideo->currTempRef <= pVideo->pictArray[comput1].tempRef )
			 && ( min_temp_ref > cur_ref ) ) {
			// pVideo->currTempRef and pVideo->pictArray[comput1] refer to the same GOP
			// we want to extract the minimum temporal reference
			min_temp_ref = cur_ref;
			index = comput1;
		}
	}
	if (index == 5) {
		/*
			There is a group of pictures change: reset pVideo->currTempRef and
			increment pVideo->GOPindex
		*/
		pVideo->currTempRef = ( pVideo->currTempRef & 0xF000 ) + 0x4000;
		min_temp_ref = min_temp_ref + 0x4000;
		/* search frame store to display */
		for (comput1 = 0; comput1 <= 3; comput1++) {
			cur_ref = pVideo->pictArray[comput1].tempRef & 0xFFF;
			if ( ( ( pVideo->currTempRef & 0xF000 ) == ( pVideo->pictArray[comput1].tempRef & 0xF000 ) )
				 && ( pVideo->currTempRef <= pVideo->pictArray[comput1].tempRef )
				 && ( min_temp_ref > cur_ref ) ) {
				// pVideo->currTempRef and pVideo->pictArray[comput1] refer to the same GOP
				// we want to extract the minimum temporal reference
				min_temp_ref = cur_ref;
				index = comput1;
			}
		}
	}

	if (index == 5) {
		if (!pVideo->errCode)
			pVideo->errCode = TEMP_REF;	/* No pVideo->currTempRef corresponding to the display one */
		SetErrorCode(ERR_NO_TEMPORAL_REFERENCE);
	}
	else {
		pVideo->pNextDisplay->tempRef = 1025;
		// to release the previous pointer for next decoding
		pVideo->pNextDisplay = &pVideo->pictArray[index];
		if ( pVideo->pNextDisplay->validPTS == FALSE ) {
		/* PTS not available: compute a theoretical value */
			U16 lattency = 3000;	/* two 60Hz fields lattency */
			if ( pVideo->StreamInfo.displayMode == 0 )
				lattency = 3600;	   /* two 50Hz fields lattency */
			pVideo->pNextDisplay->dwPTS = pVideo->pCurrDisplay->dwPTS + lattency;
		}
		// set next display pointer
		pVideo->currTempRef = pVideo->pictArray[index].tempRef;
		pVideo->pictArray[index].tempRef = 1024;
		/* this pVideo->currTempRef must not interfer on next tests */
	}
}

//----------------------------------------------------------------------------
//               Set parameters related to picture size
//----------------------------------------------------------------------------
/*
	This routine will always program the sample rate converter
	in order to display 720 horizontal pixels
*/
VOID VideoSetPictureSize(PVIDEO pVideo)
{
	U16 compute, comput1;

	if ( (pVideo->StreamInfo.horSize > 720 ) ||
			 (pVideo->StreamInfo.verSize > 576 ))
	{
		if ( !pVideo->errCode )
			pVideo->errCode = HIGH_CCIR601; // picture size higher than CCIR601 format
    SetErrorCode(ERR_HIGHER_THAN_CCIR601);
		return;
	}

	// set SRC depending on the horizontal size in order to display 720
	// pixels
	if ( pVideo->StreamInfo.horSize < 720 ) {
		// lsr = 256 * (pVideo->StreamInfo.horSize-4) / (display size - 1)
		VideoSetSRC(pVideo, pVideo->StreamInfo.horSize, 720);
	}
	else {
		VideoSRCOff(pVideo);
	}

	if ( ( pVideo->StreamInfo.horSize >= 544 ) &&
			 ( ( pVideo->StreamInfo.pixelRatio == 0x3 ) ||
				 ( pVideo->StreamInfo.pixelRatio == 0x6 ) ) )
	{
		// picture size = 720 but pixel aspect ratio is 16/9
		// Program the SRC for display on a 4/3 screen
		// 544 pixels of the decoded picture extended into 720 pixels
		// for display
		VideoSetSRC(pVideo, 544, 720);
	}

	// set vertical filter and half/full resolution depending on the
	// vertical picture size
	if ( pVideo->StreamInfo.verSize > 288 ) {
		// typically 480 or 576 lines
		VideoSetFullRes(pVideo);
	}
	else {
	// typically 240 or 288 lines
//		VideoSetFullRes(pVideo);
		VideoSetHalfRes(pVideo);
	}

	// set picture sizes into the decoder
	comput1 = pVideo->StreamInfo.horSize + 15;		   // Horizontal size + 15
	comput1 = ( comput1 >> 4 ) & 0xFF;   // divide by 16
	VideoWrite ( DFW, comput1 );
	// Decoded Frame Width in number of MB
	compute = ( pVideo->StreamInfo.verSize + 15 ) >> 4;
	compute = ( compute * comput1 ) & 0x3FFF;
#ifndef STi3520A
	VideoWrite ( DFS, ( ( compute >> 8 ) & 0xFF ) );
	/* Decoded Frame Size in number of MB */
	VideoWrite ( DFS + 1, ( compute & 0xFF ) );
#else
	VideoWrite ( DFS, ( ( compute >> 8 ) & 0xFF ) );
	/* Decoded Frame Size in number of MB */
	VideoWrite ( DFS , ( compute & 0xFF ) );

	VideoWrite ( VID_DFA , 0 );
	VideoWrite ( VID_DFA , 0 );
	VideoWrite ( VID_XFW, comput1 );
	VideoWrite ( VID_XFS, ( ( compute >> 8 ) & 0xFF ) );
	VideoWrite ( VID_XFS, ( compute & 0xFF ) );
	VideoWrite ( VID_XFA , 0 );
	VideoWrite ( VID_XFA , 0 );
#endif
}

//----------------------------------------------------------------------------
// store the next pan vector
//----------------------------------------------------------------------------
void VideoSetPSV(PVIDEO pVideo)
{
	S16 compute, comput1, psv_index, vert_pan;
#ifdef STi3520A
U16 Scan, Pan;
return;
#endif

	//---- If pan/scan not defined in sequence display extension
	if (!pVideo->seqDispExt)
		return;						   // can't be computed !

	/**** point to the next offset ****/
	if ( pVideo->pictDispIndex < 0 )
		psv_index = 0;				   // in case of tempo
	else if ( pVideo->pictDispIndex == pVideo->pCurrDisplay->nb_display_field )
		psv_index = pVideo->pictDispIndex - 1; // when we reach the last VSYNC of display
	else
		psv_index = pVideo->pictDispIndex;

	/**** determine next vertical pan and scan offset ****/
	compute = ( pVideo->StreamInfo.verSize - pVideo->StreamInfo.verDimension ) >> 1;
	compute = compute + ( pVideo->pCurrDisplay->pan_vert_offset[psv_index] >> 4 );
	// discard fractional part
	compute = compute >> 2;	 // vertical offset is multiple of 4 lines
	if ( compute < 0 )
		compute = 0;				   // negative offsets not supported
	if ( compute > 0x7F )
		compute = 0x7F;				 // vertical PSV is 7 bits
	vert_pan = compute << 9; // vert offset in bits 15 to 9 of PSV register

	/**** determine next horizontal pan and scan offset ****/
	// pan&scan = (pVideo->StreamInfo.horSize/2 - pVideo->StreamInfo.horDimension/2 + offset)
	compute = ( pVideo->StreamInfo.horSize - pVideo->StreamInfo.horDimension ) << 3;
	// (pVideo->StreamInfo.horSize/2-pVideo->StreamInfo.horDimension/2) * 16
	compute = compute + pVideo->pCurrDisplay->pan_hor_offset[psv_index];
	if ( compute < 0 )
		compute = 0;				   // negative offsets not supported

	// program the integer part of the pan and scan offset
	// into PSV register that will be taken into account on next VSYNC
	comput1 = compute >> 4;	 // keep integer part only for PSV
	if ( comput1 > 0x1FF )
		comput1 = 0x1FF;
#ifndef STi3520A
	// max PSV is 9 bits on STi3500
	VideoWrite ( PSV, ( comput1 >> 8 ) | vert_pan );
	// store pan & scan vector integer part
	VideoWrite ( PSV + 1, comput1 & 0xFF );
	// store pan & scan vector integer part
#else
	vert_pan = vert_pan;
	Pan  = comput1 & 0x1FF;
	Scan = ((comput1 >> 9)&0x7F)*2;
	VideoWrite ( VID_PAN, ( Pan >> 8 ));
	VideoWrite ( VID_PAN + 1, Pan & 0xFF );
	VideoWrite ( VID_SCN, ( Scan >> 8 ));
	VideoWrite ( VID_SCN + 1, Scan & 0xFF );
#endif
	// program the fractional part of the horizontal offset
	// the fractional part of the pan and scan offset is expressed as
	// 1/256 multiples
	comput1 = ( compute & 0xF ) << 4; // keep fractional part and multiply by 16
	VideoRead ( LSO );
	compute = VideoRead ( LSR );
	VideoWrite ( LSO, comput1 & 0xFF );
	// program luma offset
	VideoWrite ( LSR, compute );
	// divide by 2 chroma offset
	VideoRead ( CSO );
#ifndef STi3520A
	// program chroma offset
	compute = VideoRead ( CSR );
	VideoWrite ( CSO, comput1 >> 1 );
	VideoWrite ( CSR, compute );
#else
	VideoWrite ( CSO, comput1 >> 1 );
#endif
}

//----------------------------------------------------------------------------
//  Enable/disable the SRC
//----------------------------------------------------------------------------
void VideoSwitchSRC ( PVIDEO pVideo )
{
	if (pVideo->useSRC != 0x0) {
		pVideo->currDCF = pVideo->currDCF ^ DSR;	   /* Switch SRC */
		VideoWrite (DCF, 0);
		VideoWrite (DCF + 1, pVideo->currDCF);
	}
	else {
		// what ?
	}
}

//----------------------------------------------------------------------------
// enable the SRC
//----------------------------------------------------------------------------
void VideoSRCOn ( PVIDEO pVideo )
{
		pVideo->useSRC = 0xFF;
		pVideo->currDCF = pVideo->currDCF & ~DSR ;	   /* Enable SRC */
		VideoWrite ( DCF, 0 );
		VideoWrite ( DCF + 1, pVideo->currDCF );
}

//----------------------------------------------------------------------------
// Disable the SRC
//----------------------------------------------------------------------------
void VideoSRCOff ( PVIDEO pVideo )
{
		pVideo->useSRC = 0x00;
		pVideo->currDCF = pVideo->currDCF | DSR ;	   /* Enable SRC */
		VideoWrite ( DCF, 0 );
		VideoWrite ( DCF + 1, pVideo->currDCF );
}

//----------------------------------------------------------------------------
// display a full screen OSD with a uniform color (just as example)         			*/
//----------------------------------------------------------------------------
/*
 color 0 is green
 color 1 is yellow
 color 2 is cyan
 color 3 is magenta

 the OSD area is here defined from address zero
 in normal application this area is reserved for the bit buffer
 and the OSD will be typically defined after the bit buffer.
 Note: The bit buffer is defined in multiple of 256 bytes while
 MWP, OEP and OOP are memory addresses in mulitple of 64 bits
*/
void  VideoFullOSD (PVIDEO pVideo, S16 col )
{
	long            big;
	U16 counter;
	VideoSetMWP(0L);
	counter = 0;
	while ( !VideoMemWriteFifoEmpty()) {
		counter ++;
		if (counter == 0xFF) {
			pVideo->errCode = BAD_MEM_V;
			SetErrorCode(ERR_MEM_WRITE_FIFO_NEVER_EMPTY);
			return ;
		}
	}
	VideoWrite ( MWF, 19 );	   /* line 19 */

	VideoWrite ( MWF, 0x1 );	   /* stop row */
	VideoWrite ( MWF, 0x02 );   /* 19 + 240 - 1 */
	VideoWrite ( MWF, 0x00 );   /* start column */
	VideoWrite ( MWF, 100 );	   /* column 100 */
	VideoWrite ( MWF, 0x3 );	   /* stop column = 100 + 700 - 1=
											* 31F */
	VideoWrite ( MWF, 0x1F );   /* end init display size and
										* position */
	VideoWrite ( MWF, 0x90 );   /* color 0 = green */
	VideoWrite ( MWF, 0x32 );
	VideoWrite ( MWF, 0xD0 );   /* color 1 = yellow */
	VideoWrite ( MWF, 0x19 );
	VideoWrite ( MWF, 0xA0 );   /* color 2 = cyan */
	VideoWrite ( MWF, 0xA1 );
	VideoWrite ( MWF, 0x60 );   /* color 3 = magenta */
	VideoWrite ( MWF, 0xDE );   // 6/D/E
	if ( col == 1 )
		col = 0x55;
	else if ( col == 2 )
		col = 0xAA;
	else if ( col == 3 )
		col = 0xFF;
	for ( big = 0; big < 42000L; big++ )	// 42000 = 240 * 700 / 4
	{
		VideoWrite ( MWF, col );
		// select color
	}
	for ( big = 0; big < 8; big++ )	   // add a dummy window outside
										 // the display
		VideoWrite ( MWF, 0xFF );
	// to stop OSD
	VideoInitOEP ( pVideo, 0 );					   // set OEP and OOP to start of
										 // bit map address
	VideoWrite ( DCF, 0 );
	VideoWrite ( DCF + 1, pVideo->currDCF | 0x30 );
	// enable OSD
}

//------------------------------- End of File --------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\stinit.c ===
//----------------------------------------------------------------------------
// STINIT.C
//----------------------------------------------------------------------------
// Description : Initialization routines (and reset)
//----------------------------------------------------------------------------
// Copyright SGS Thomson Microelectronics  !  Version alpha  !  Jan 1st, 1995
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Include files
//----------------------------------------------------------------------------
#include "stdefs.h"
#include "common.h"
#include "STllapi.h"
#include "error.h"
#ifdef STi3520A
	#include "STi3520A.h"
#else
	#include "STi3520.h"
#endif

//----------------------------------------------------------------------------
//                   GLOBAL Variables (avoid as possible)
//----------------------------------------------------------------------------
extern PCARD pCard;
extern U8 Sequence;

//----------------------------------------------------------------------------
//                            Private Constants
//----------------------------------------------------------------------------
#define PLL
//#define PES

//----------------------------------------------------------------------------
//                              Private Types
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                     Private GLOBAL Variables (static)
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                    Functions (statics one are private)
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
U16 VideoTestReg(PVIDEO pVideo)
{
#ifndef STi3520A
	VideoWrite ( MWP + 1, 0x55 );
	VideoWrite ( MWP + 2, 0x55 );
	if ( VideoRead ( MWP + 1 ) != 0x55 )
		return ( BAD_REG_V );
	if ( VideoRead ( MWP + 2 ) != 0x55 )
		return ( BAD_REG_V );
	VideoWrite ( MWP + 1, 0xAA );
	VideoWrite ( MWP + 2, 0xAA );
	if ( VideoRead ( MWP + 1 ) != 0xAA )
		return ( BAD_REG_V );
	if ( VideoRead ( MWP + 2 ) != 0xAA )
		return ( BAD_REG_V );
	return ( NO_ERROR );
#else
	VideoWrite ( MWP , 0x05 );
	VideoWrite ( MWP , 0x55 );
	VideoWrite ( MWP , 0xAA );
	if ( (VideoRead(MWP) & 0x1F) != 0x05 )
		return ( BAD_REG_V );
	if ( VideoRead(MWP) != 0x55 )
		return ( BAD_REG_V );
	if ( (VideoRead(MWP) & 0xFC) != 0xA8 )
		return ( BAD_REG_V );
return ( NO_ERROR );
#endif
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
static U16 VideoTestMemPat(PVIDEO pVideo, U16 pattern, U16 pattern1)
{
	#define MAXMEM 0x7FF
	U16 i, j;
	S16	counter;

	VideoSetMWP(0L);
	counter = 0;
	for (i = 0; i < MAXMEM; i++) {
		while (!VideoMemWriteFifoEmpty()) {
			counter ++;
			if (counter == 0xFF)
				return BAD_MEM_V;
		}

		for (j = 0; j < 16; j++)
			VideoWrite(MWF, 0);
	}

	VideoSetMWP(0L);
	counter = 0;
	for (i = 0; i < MAXMEM; i++) {
		while (!VideoMemWriteFifoEmpty()) {
			counter ++;
			if (counter == 0xFF)
					return ( BAD_MEM_V );
		}

		for ( j = 0; j < 8; j++ )
			VideoWrite ( MWF, pattern);
		counter =  0;
		while (!VideoMemWriteFifoEmpty())	{		// ACCESS TO MEM FIFO IS SLOWER !!!
			counter ++;
			if (counter == 0xFF)
				return ( BAD_MEM_V );
		}

		for ( j = 0; j < 8; j++ )
			VideoWrite ( MWF, pattern1);
	}

	VideoSetMRP(0L);
	counter = 0;
	// test Read Fifo Full
	for ( i = 0; i < MAXMEM; i++ ) {
		while ( !VideoMemReadFifoFull() )	{
			counter ++;
			if(counter == 0xFF)
					return ( BAD_MEM_V );
		}

		for (j = 0; j < 8; j++)	{
			counter = VideoRead(MRF);
			if (counter != pattern)	{
				return BAD_MEM_V;
			}
		}

		counter =  0;
		while (!VideoMemReadFifoFull())	{
			counter ++;
			if (counter == 0xFF)
				return BAD_MEM_V;
		}

		for (j = 0; j < 8; j++ ) {
			counter = VideoRead (MRF);
			if ( counter != pattern1 ) {
					return BAD_MEM_V;
			}
		}
	}
#if 0			// DO NOT TEST BLOCK MOVE !!!
	/*******************************/
	/* test block move function   */
	/*******************************/
	// initialise a second memory area starting at @ 3000
	VideoSetMWP(0x3000L);
	// 3000 = 98304 bytes = 0x18000
	for ( i = 0; i < 0x1FFF; i++ )	   // write 65528 bytes
	{
	// test Write Fifo Empty
	counter = 0;
	while ( !VideoMemWriteFifoEmpty() )
		{
		counter ++;
		if(counter == 0xFF)
				return ( BAD_MEM_V );
		}
	 for(j = 0 ; j < 4 ; j++)
			{
			VideoWrite ( MWF, 0xBB );
			VideoWrite ( MWF, 0xFF );
			}
	}
	// starts block move and waits for idle
	if(VideoBlockMove(pVideo, 0x3000, 0, 0x1FFF)) //If time out error return error message
		{
		return ( BAD_MEM_V );
		}
	// test result of block move
	VideoSetMRP(0L);

	// test Read Fifo Full
	for ( i = 0; i < 0x1FFF; i++ )
	{
	counter = 0;
	while ( !VideoMemReadFifoFull() )
		{
		counter ++;
		if(counter == 0xFF)
				return ( BAD_MEM_V );
		}
	 for(j = 0 ; j <4; j++);
			{
			counter = VideoRead ( MRF );
			if ( counter != 0xBB )
					return ( BAD_MEM_V );
			counter = VideoRead ( MRF );
			if ( counter != 0xFF )
					return ( BAD_MEM_V );
			}
	}
#endif
	return ( NO_ERROR );
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
U16 VideoTestMem(PVIDEO pVideo)
{
	if (VideoTestMemPat(pVideo, 0x55, 0xAA) == NO_ERROR)
		return VideoTestMemPat(pVideo, 0xAA, 0x55);
	else {
		SetErrorCode(ERR_TEST_MEMORY_FAILED);
		return BAD_MEM_V;
	}
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
U16 VideoTestInt(PVIDEO pVideo)
{
	U16		a = 0;

	pVideo->errCode = NO_ERROR;
	pVideo->VsyncInterrupt = FALSE;
	pVideo->intMask = TOP | BOT;
	DisableIT();
	VideoWrite ( ITM, pVideo->intMask >> 8 );
	VideoWrite ( ITM + 1, pVideo->intMask & 0xFF );
	EnableIT();

	// wait for first VSYNC occurrence
	while ( pVideo->VsyncInterrupt == FALSE )
	{
		WaitMicroseconds(1000);
		a++;						   /* incremented every 1 ms */
		if ( a >= ( 2000 + ( pVideo->decSlowDown * 20 ) ) )
		{
			pVideo->errCode = NO_IT_V;
			SetErrorCode(ERR_NO_VIDEO_INTR);
			break;
		}
	}

	DisableIT();
	VideoWrite ( ITM, 0 );
	VideoWrite ( ITM + 1, 0 );   /* disable Sti3500 interrupts */

#ifdef STi3520A
	VideoWrite ( ITM1, 0 );   /* disable Sti3500 interrupts */
#endif
	EnableIT();

	VideoRead ( ITS );		   /* to clear interrupts flags */
#ifdef STi3520A
	VideoWrite ( ITS + 1, 0 );   /* disable Sti3500 interrupts */
	VideoWrite ( ITS1, 0 );   /* disable Sti3500 interrupts */
#endif
	return ( pVideo->errCode );
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
VOID VideoInitVar(PVIDEO pVideo)
{
Sequence =1;
	pVideo->currDCF = 0x00;					   /* one clock delay + force black
										* background */
	pVideo->LastCdCount = 0;
	pVideo->fullVerFilter = 0x0;
	pVideo->halfVerFilter = 0x4;
	pVideo->Xdo = pCard->OriginX;						   /* pre initialise XDO */
	pVideo->Ydo = pCard->OriginY;						   /* pre initialise YDO */
	pVideo->Xd1 = 0xFFFF;					   /* pre initialise end of video
										* window */
	pVideo->Yd1 = 0xFFFF;					   /* pre initialisa end of video
										* window */
	pVideo->fastForward = 0;						   /* accelerate if set */
	pVideo->decSlowDown = 0;
	pVideo->perFrame = FALSE;
	pVideo->LastPipeReset = 2;
	pVideo->errCode = 0;
	pVideo->StreamInfo.countGOP = 0;
	pVideo->StreamInfo.frameRate = 5;	 // just to avoid erroneous warning
	pVideo->useSRC = 0x0;				   // disable SRC
	pVideo->seqDispExt = 0;
	pVideo->skipMode = 0;
	pVideo->currCommand = 0;
	pVideo->needDataInBuff = 0;
	pVideo->currPictCount = 0;			/* first picture of the bit stream */
	pVideo->defaultTbl = 0;	/* To know if default tables are already into the chip */
	pVideo->GOPindex = 0;
	// initialisation of the picture structures
	pVideo->pictArray[0].tempRef = 1025;
	pVideo->pictArray[1].tempRef = 1023;
	pVideo->pictArray[2].tempRef = 1025;
	pVideo->pictArray[3].tempRef = 1025;
	pVideo->currTempRef = 1022;				   /* display pVideo->decSlowDownral reference */
	pVideo->pNextDisplay = &pVideo->pictArray[3];
	pVideo->pCurrDisplay = &pVideo->pictArray[3];	   // this is only for correct
										 // start up
	pVideo->pictArray[0].nb_display_field = 2;
	// 2 field display time for MPEG1
	pVideo->pictArray[1].nb_display_field = 2;
	pVideo->pictArray[2].nb_display_field = 2;
	pVideo->pictArray[3].nb_display_field = 2;
	pVideo->pictArray[0].first_field = TOP;	   // default for MPEG1 bit streams
	pVideo->pictArray[1].first_field = TOP;	   // top field first
	pVideo->pictArray[2].first_field = TOP;
	pVideo->pictArray[3].first_field = TOP;
	pVideo->fieldMode = 0;					   // indicates frame picture by
									   // default
	pVideo->frameStoreAttr = FORWARD_PRED;
	pVideo->vbvReached = 0;
	pVideo->notInitDone = 1;				   // timing generator,picture size
									   // initialised only once
	pVideo->intMask = 0x0;
	pVideo->Gcf = 0;	// GCF set to 0 by default
	pVideo->Ctl = A35;	// CTL set to 0 by default
	pVideo->InvertedField = FALSE;
#ifdef STi3520A
	pVideo->FistVsyncAfterVbv = NOT_YET_VBV;
	pVideo->Ccf = 0;	// GCF set to 0 by default
#endif
	VideoReset35XX(pVideo);					   // software reset needed before
										 // the SKIP until SEQ is called
// prepare to skipuntil first Seq

	pVideo->NextInstr.Tff = 1 ;
	pVideo->NextInstr.Seq = 1 ;
	pVideo->NextInstr.Exe = 1 ;
	}

//----------------------------------------------------------------------------
// Display susie to test the display
//----------------------------------------------------------------------------
/*
VOID DisplaySusie(PVIDEO pVideo)
	{
#ifdef STi3520A
	FILE *fp; //////////////////////////////////
	U16 i, NbRead;
	U8 data[8];
	fp = fopen("susie.yuv","rb");
	if(fp ==NULL)
	{
		printf("\nCan Not Open Susie.yuv ");
		return (FALSE);
	}
	// Load Susie to mem location 0
	VideoSetMWP(32L);
	NbRead = fread(data, 1, 8, fp);
	while(NbRead)
		{
		while(!VideoMemWriteFifoEmpty());
		for(i = 0; i<8; i++)
				VideoWrite(MWF, data[i]);
		NbRead = fread(data, 8, 1, fp);
		}
	fclose(fp);
	// Initialize Display
	VideoWrite(DFP , 0);
	VideoWrite(DFP + 1 , 1);

	VideoWrite(VID_XFS , 1);
	VideoWrite(VID_XFS , 0x4A);
	VideoWrite(VID_XFW , 0x16);
	VideoWrite(VID_XFA , 0);
	VideoWrite(VID_XFA , 0);
	VideoInitXY(pVideo);
	VideoSetSRC(pVideo, 352, 720);
	VideoSRCOn(pVideo);
	//Enable Display
	VideoSetHalfRes(pVideo);
	VideoEnableDisplay( pVideo );
#endif
}
*/

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
VOID VideoReset35XX(PVIDEO pVideo)
{
	pVideo->StreamInfo.modeMPEG2 = 0;

	pVideo->NextInstr = pVideo->ZeroInstr;// Clear Next Instruction
#ifdef PES
	VideoWrite( PES_VID,0x20 );
	VideoWrite( PES_AUD,0x23 );
#endif

#ifdef PLL
	VideoInitPLL();
#endif
	VideoWaitDec ( pVideo );		// put decoder in Wait mode

	VideoSetBBStart(pVideo, 0);// Set Bit Buffer parameters before Soft Reset
	VideoSetBBStop(BUF_FULL);
	VideoSetBBThresh(BUF_FULL);
	VideoEnableInterfaces ( pVideo, ON );
	VideoEnableErrConc( pVideo, ON);
	VideoSoftReset ( pVideo  );
	VideoEnableDecoding ( pVideo, ON   );
	VideoSetDramRefresh( pVideo, 36 );    // Set DRAM refresh to 36 default DRAM ref period

	VideoDisableDisplay(pVideo);
	VideoMaskInt(pVideo);
	VideoRead ( ITS );		   /* to clear ITS */
#ifdef STi3520A
	VideoRead ( ITS +1 );
	VideoRead ( ITS1);
#endif
}

//----------------------------------------------------------------------------
// PLL initialization
//----------------------------------------------------------------------------
static void VideoInitPLL(void)
	{
#ifdef STi3520A
	VideoWrite(CKG_CFG, 0);
	WaitMicroseconds(1000);
	VideoWrite(CKG_CFG, 0x2);
	VideoWrite(CKG_PLL, 0xC3);
	VideoWrite(CKG_VID, 0x23);
	VideoWrite(CKG_VID, 0x0);
	VideoWrite(CKG_VID, 0x0F);
	VideoWrite(CKG_VID, 0xFE);
WaitMicroseconds(10000);
#endif
/* start added by yann dec 28th, 95 */
#ifndef STi3520A
	//Configure CLK bit
	VideoWrite(CMD,  0x00);
	VideoWrite(CMD+1,  0x40);          /* select second bank of registers */
	VideoWrite(GCF, 0x00);             /* access to GCF2 */
	VideoWrite(GCF+1, 0x00); // Disable ClK 80
#define PLL0 6
	// Program PLL register: PLL clock from VXIN = NotCLK
	VideoWrite(PLL0, 0x00);
	VideoWrite(PLL0+1, 0x44);

	/***************************************/
	/*Read PLL puts PLL in power down mode */
	/***************************************/
	VideoRead(PLL0);
	VideoRead(PLL0+1);
	WaitMicroseconds(10000);

	/***************************************/
	/*Read PLL again to re-initialize      */
	/***************************************/
	VideoRead(PLL0);
	VideoRead(PLL0+1);

	VideoWrite(PLL0, 0x01);
	VideoWrite(PLL0+1, 0x8D);
	WaitMicroseconds(100000UL);
#endif
	}

//------------------------------- End of File --------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\stv0116.c ===
//----------------------------------------------------------------------------
// STV0116.C
//----------------------------------------------------------------------------
// PAL/NSTC encoder (SGS-Thomson STV0116) programming
//----------------------------------------------------------------------------
// Copyright SGS Thomson Microelectronics  !  Version alpha  !  Jan 1st, 1995
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                               Include files
//----------------------------------------------------------------------------
#include "stdefs.h"
#include "STV0116.h"
#include "I2C.h"
#include "debug.h"

//----------------------------------------------------------------------------
//                            Private Constants
//----------------------------------------------------------------------------

//---- I2C addresses
#define STV0116W 0xB0  // Write address
#define STV0116R 0xB1  // Read address

//---- STV0116 registers          Description                 type bits
#define CTRL     0x00  // Control                              RW   8
#define CFG      0x01  // Config                               RW   5
#define DLYMSB   0x02  // Delay Most Significant Byte          RW   8
#define DLYLSB   0x03  // Delay Less Significant Byte          RW   8
#define IDFS0    0x04  // Inc for Digital Freq Synthesizer     RW   6
#define IDFS1    0x05  //                                      RW   8
#define IDFS2    0x06  //                                      RW   8
#define PDFS0    0x07  // Phase offset for Digit Freq Synth    RW   6
#define PDFS1    0x08  //                                      RW   8
#define PDFS2    0x09  //                                      RW   8
#define PALY0    0x0A  //                                      RW	 8/6
#define PALY1    0x0B  //                                      RW	 8/6
#define PALY2    0x0C  //                                      RW	 8/6
#define PALY3    0x0D  //                                      RW	 8/6
#define PALY4    0x0E  //                                      RW	 8/6
#define PALY5    0x0F  //                                      RW	 8/6
#define PALY6    0x10  //                                      RW	 8/6
#define PALY7    0x11  //                                      RW	 8/6
#define PALCR0   0x12  // Cr Palet                             RW	 8/6
#define PALCR1   0x13  //                                      RW	 8/6
#define PALCR2   0x14  //                                      RW	 8/6
#define PALCR3   0x15  //                                      RW	 8/6
#define PALCR4   0x16  //                                      RW	 8/6
#define PALCR5   0x17  //                                      RW	 8/6
#define PALCR6   0x18  //                                      RW	 8/6
#define PALCR7   0x19  //                                      RW	 8/6
#define PALCB0   0x1A  // Cr Palet                             RW	 8/6
#define PALCB1   0x1B  //                                      RW	 8/6
#define PALCB2   0x1C  //                                      RW	 8/6
#define PALCB3   0x1D  //                                      RW	 8/6
#define PALCB4   0x1E  //                                      RW	 8/6
#define PALCB5   0x1F  //                                      RW	 8/6
#define PALCB6   0x20  //                                      RW	 8/6
#define PALCB7   0x21  //                                      RW	 8/6
#define TSTMODE  0x22  // Test register (color bars display)
#define STATUS   0x23  // Status                               R    8
#define COMP0    0x24  // Compression                          RW   8
#define COMP1    0x25  //                                      RW   8
#define COMP2    0x26  //                                      RW   8

//---- Register bits

//---- CTRL
#define STD1 	 	 0x80  // Standard selection
#define STD0 	 	 0x40  // Standard selection
#define SYM1 	 	 0x20  // Free-run
#define SYM0 	 	 0x10  // Frame synchronisation source in slave mode
#define SYS1 	 	 0x08  // Synchro : VCS polarity
#define SYS0 	 	 0x04  // Frame synchro : ODD/EVEN polarity
#define MOD1     0x02  // No Reset / Software reset
#define MOD0     0x01  // Slave/Master

//---- CFG
#define HSNVCS   0x80  // Output signal selection on VCS
#define RSTDDFS  0x40  // Reset of DDFS (DirectDigital Frequency Synthetizer)
#define FLT1     0x20  // Chroma pass band filter
#define SYNCOK   0x10  // Synchro availability in case of no free-run active
#define COKI     0x08  // Color kill

//---- TSTMODE
#define START    0x80  // Display color bars (test mode)
#define STOP     0x00  // Do not display color bars (normal mode)

//----- STATUS
#define HOK      0x80  // Hamming decoding of ODD/EVEN signal from YCRCB
#define ATFR     0x40  // Frame synchronisation flag
#define STD1S    0x20  // Standard selection
#define STD0S    0x10  // Standard selection
#define SYM1S    0x08  // Free-run
#define SYM0S    0x04  // Frame synchronisation source in slave mode
#define SYS1S    0x02  // Synchro : VCS polarity
#define SYS0S    0x01  // Frame synchro : ODD/EVEN polarity

//----------------------------------------------------------------------------
//                              Private Types
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                     Private GLOBAL Variables (static)
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                     Functions (statics one are private)
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// Initialisation of STV0116
//----------------------------------------------------------------------------
BOOL STV0116Init(BYTE DisplayStd)
{
	switch(DisplayStd) {
	case NTSC_M :
		if (!I2CSend(STV0116W, CTRL, STD1 | SYM1 | SYS1 | MOD1 | MOD0))
			return FALSE;
		if (!I2CSend(STV0116W, CFG,  STD1 | SYM1 | SYM0))
			return FALSE;
		break;

	case PAL_M :
		if (!I2CSend(STV0116W, CTRL, SYM1 | SYS1 | MOD1 | MOD0))
			return FALSE;
		if (!I2CSend(STV0116W, CFG,  STD1 | SYM1 | SYM0))
			return FALSE;
		break;

	default :
		DebugPrint((DebugLevelFatal, "Unknown case !"));
		break;
	}

	return TRUE;
}

//----------------------------------------------------------------------------
// Enter test mode (display color bars)
//----------------------------------------------------------------------------
BOOL STV0116EnterTestMode(VOID)
{
	return I2CSend(STV0116W, TSTMODE, START);
}

//----------------------------------------------------------------------------
// Return from test mode
//----------------------------------------------------------------------------
BOOL STV0116NormalMode(VOID)
{
	return I2CSend(STV0116W, TSTMODE, STOP);
}

//------------------------------- End of File --------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\stv0116.h ===
#ifndef __STV0116_H
#define __STV0116_H
//----------------------------------------------------------------------------
// STV0116.H
//----------------------------------------------------------------------------
// PAL/NSTC encoder (SGS-Thomson STV0116) programming
//----------------------------------------------------------------------------
// Copyright SGS Thomson Microelectronics  !  Version alpha  !  Jan 1st, 1995
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                               Include files
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                               Exported Types
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Exported Variables
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Exported Constants
//----------------------------------------------------------------------------
#define NTSC_M 0x01
#define PAL_M  0x00

//----------------------------------------------------------------------------
//                             Exported Functions
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// Initialisation of STV0116
//----------------------------------------------------------------------------
// In     :
//   BYTE DisplayStd : one of the above constant (PAL_M, NTSC_M)
// Out    : -
// InOut  : -
// Global : -
// Return :
//   TRUE if no error, FALSE if not (Acknowledge problem)
//----------------------------------------------------------------------------
BOOL STV0116Init(BYTE DisplayStd);

//----------------------------------------------------------------------------
// Enter test mode (display color bars)
//----------------------------------------------------------------------------
// In     : -
// Out    : -
// InOut  : -
// Global : -
// Return :
//   TRUE if no error, FALSE if not (Acknowledge problem)
//----------------------------------------------------------------------------
BOOL STV0116EnterTestMode(VOID);

//----------------------------------------------------------------------------
// Return from test mode
//----------------------------------------------------------------------------
// In     : -
// Out    : -
// InOut  : -
// Global : -
// Return :
//   TRUE if no error, FALSE if not (Acknowledge problem)
//----------------------------------------------------------------------------
BOOL STV0116NormalMode(VOID);

//------------------------------- End of File --------------------------------
#endif // #ifndef __STV0116_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\stvideo.c ===
//----------------------------------------------------------------------------
// STVIDEO.C
//----------------------------------------------------------------------------
// Description : Main control routines for Video Decoder
//----------------------------------------------------------------------------
// Copyright SGS Thomson Microelectronics  !  Version alpha  !  Jan 1st, 1995
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Include files
//----------------------------------------------------------------------------
#include "stdefs.h"
#include "common.h"
#include "stvideo.h"
#include "stfifo.h"
#include "stllapi.h"
#include "debug.h"
#include "error.h"
#ifdef STi3520A
	#include "sti3520A.h"
#else
	#include "sti3520.h"
#endif

//----------------------------------------------------------------------------
//                   GLOBAL Variables (avoid as possible)
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                            Private Constants
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                              Private Types
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                     Private GLOBAL Variables (static)
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                    Functions (statics one are private)
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
S16 VideoOpen(PVIDEO pVideo)
{
	pVideo->errCode = NO_ERROR;
	pVideo->VideoState = VIDEO_POWER_UP;
	pVideo->ActiveState = VIDEO_POWER_UP;
	pVideo->pFifo = &(pVideo->Fifo);
	FifoOpen(pVideo->pFifo);
	return (pVideo->errCode);
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
VOID VideoClose(PVIDEO pVideo)
{
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
VOID VideoInitDecoder(PVIDEO pVideo)
{
	switch(pVideo->VideoState) {
		 case VIDEO_INIT:	    // Video decoder is reset and pre-initialized
		 case VIDEO_POWER_UP:	// State after declaration of the video instance
			VideoInitVar(pVideo);
			VideoReset35XX(pVideo);
			FifoReset(pVideo->pFifo);
			pVideo->VideoState = VIDEO_INIT;
			pVideo->ActiveState = VIDEO_INIT;
			break;
		case VIDEO_START_UP:
		case VIDEO_WAIT_FOR_DTS:
		case VIDEO_DECODE:
		case VIDEO_STEP: /* Video decodes only one
											* picture : goes back to PAUSE
											* state when done */
			break;
	}
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
U16 VideoTest(PVIDEO pVideo)
{
	U16 TestResult;

	switch(pVideo->VideoState) {
	case VIDEO_POWER_UP:
	case VIDEO_INIT:
		TestResult = VideoTestReg(pVideo);
		if (TestResult != NO_ERROR)	{
			DebugPrint((DebugLevelError,"VideoTestReg failed !!"));
			return TestResult;
		}
		else {
			TestResult = VideoTestMem(pVideo);
			if (TestResult != NO_ERROR)	{
				DebugPrint((DebugLevelError,"VideoTestMem failed !!"));
				return TestResult;
			}
/*
			else if (VideoTestInt(pVideo) == NO_IT_V)	{
				DebugPrint((DebugLevelError,"VideoTestInt failed !!"));
				return NO_IT_V;
			}
			else
*/
				return NO_ERROR;
		}
	case VIDEO_START_UP:
	case VIDEO_WAIT_FOR_DTS:
	case VIDEO_PAUSE:
	case VIDEO_DECODE:
	case VIDEO_STEP:
		return NOT_DONE;
	}

	return NO_ERROR;
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
VOID VideoSetMode(PVIDEO pVideo, U16 Mode, U16 param)
{
	pVideo->DecodeMode = Mode;
	switch(pVideo->DecodeMode) {
	case PLAY_MODE:
		pVideo->fastForward = 0;
		pVideo->decSlowDown = 0;
		break;
	case FAST_MODE:
		pVideo->fastForward = 1;
		pVideo->decSlowDown = 0;
		break;
	case SLOW_MODE:
		pVideo->fastForward = 0;
		pVideo->decSlowDown = param;
		break;
	}
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
VOID VideoDecode(PVIDEO pVideo)
{
	switch (pVideo->VideoState)	{
	case VIDEO_POWER_UP:
		break;					   /* Video chip is not intialized */
	case VIDEO_INIT:			   /* Starts first Sequence search. */
		DisableIT();
		VideoWrite(ITM, 0);
		pVideo->intMask = PSD | HIT | TOP | BOT;
		VideoWrite ( ITM + 1, pVideo->intMask );
		#ifdef STi3520A
		VideoWrite(ITM1, 0);
		#endif
		EnableIT();

		pVideo->VideoState = VIDEO_START_UP;
		pVideo->ActiveState = VIDEO_START_UP;
		break;
	case VIDEO_START_UP:
	case VIDEO_WAIT_FOR_DTS:
	case VIDEO_DECODE:
			break;
	case VIDEO_PAUSE:
	case VIDEO_STEP:
		DisableIT();
		pVideo->VideoState = pVideo->ActiveState;
		EnableIT();
		break;
	}
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
VOID VideoStep(PVIDEO pVideo)
{
	switch(pVideo->VideoState) {
	case VIDEO_POWER_UP:
	case VIDEO_INIT:
		break;
	case VIDEO_START_UP:
	case VIDEO_WAIT_FOR_DTS:
	case VIDEO_DECODE:
		VideoPause(pVideo);
		VideoStep(pVideo);	 // Recurse call !
		break;
	case VIDEO_STEP:
		break;
	case VIDEO_PAUSE:
		if ((!pVideo->displaySecondField) && (!(VideoRead(CTL) & 0x4)))
			pVideo->displaySecondField  = 1;
		else
			pVideo->VideoState = VIDEO_STEP; /* One single picture will be decoded */
			pVideo->perFrame = TRUE;
	}
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
VOID VideoBack(PVIDEO pVideo)
{
	switch (pVideo->VideoState) {
	case VIDEO_POWER_UP:
	case VIDEO_INIT:
	case VIDEO_STEP:
		break;
	case VIDEO_WAIT_FOR_DTS:
	case VIDEO_START_UP:
	case VIDEO_DECODE:
		VideoPause(pVideo);
	case VIDEO_PAUSE:
		pVideo->displaySecondField = 0;
		break;
	}
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
VOID VideoStop(PVIDEO pVideo)
{
	switch (pVideo->VideoState)	{
	case VIDEO_POWER_UP:
		break;
	case VIDEO_INIT:
		break;
	case VIDEO_START_UP:
	case VIDEO_WAIT_FOR_DTS:
	case VIDEO_DECODE:
	case VIDEO_STEP:
	case VIDEO_PAUSE:
		pVideo->VideoState = VIDEO_POWER_UP;
		VideoInitDecoder(pVideo);
		FifoReset(pVideo->pFifo);
		VideoMaskInt(pCard->pVideo); //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		break;
	}
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
VOID VideoPause(PVIDEO pVideo)
{
	switch (pVideo->VideoState)	{
	case VIDEO_POWER_UP:	// Not yet decoding
	case VIDEO_INIT:			// Not yet decoding
	case VIDEO_PAUSE:			// already in Pause mode
		break;
	case VIDEO_WAIT_FOR_DTS:
	case VIDEO_START_UP:
	case VIDEO_DECODE:
	case VIDEO_STEP:
		pVideo->VideoState = VIDEO_PAUSE;
		break;
	}
/* When the video controller is in PAUSE state, the program will not store
	 any new instruction into the video decoder */
}

//----------------------------------------------------------------------------
// Associates PTS value with CD_count value
//----------------------------------------------------------------------------
VOID VideoLatchPTS(PVIDEO pVideo, U32 PTSvalue)
{
	FIFOELT elt;

	switch(pVideo->VideoState) {
	case VIDEO_POWER_UP:
		break;					        // no PTS available yet
	case VIDEO_INIT:
	case VIDEO_WAIT_FOR_DTS:
	case VIDEO_START_UP:
	case VIDEO_DECODE:
	case VIDEO_STEP:
	case VIDEO_PAUSE:
		elt.PtsVal = PTSvalue;
		elt.CdCount = VideoReadCDCount(pVideo);
		if (FifoPutPts(pVideo->pFifo, &elt))
			pVideo->errCode = ERR_FIFO_FULL ;
			 DebugPrint((DebugLevelError, "PTS fifo is full !"));
		break;
	}
}

//----------------------------------------------------------------------------
// tells if there is enough place into the bit buffer
//----------------------------------------------------------------------------
BOOLEAN VideoIsEnoughPlace(PVIDEO pVideo, U16 size)
{
	if (VideoGetBBL() >= (BUF_FULL - (size >> 8)) - 1)
		return FALSE;
	else
		return TRUE;
}

//----------------------------------------------------------------------------
// Returns the first valid DTS value
//----------------------------------------------------------------------------
U32 VideoGetFirstDTS(PVIDEO pVideo)
{
	U32 Ditiesse;
	U16 lattency = 1500;   /* field duration for 60 Hz video */

	if (pVideo->StreamInfo.displayMode == 0)
		lattency = 1800;	/* field duration for 50 Hz video */
	/* a B picture is displayed 1 field after its decoding starts
		 an I or a P picture is displayed 3 fields after decoding starts */
	if (pVideo->pDecodedPict->pict_type != 2) // I or P picture
		lattency = lattency * 3;
	Ditiesse = pVideo->pDecodedPict->dwPTS;
	Ditiesse = Ditiesse - lattency;

	return Ditiesse;
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
U16 VideoGetErrorMsg(PVIDEO pVideo)
{
	return pVideo->errCode;
}

//----------------------------------------------------------------------------
// Function allowing to skip the next picture
//----------------------------------------------------------------------------
VOID VideoSkip(PVIDEO pVideo)
{
	pVideo->fastForward = 1;
/* the variable will come back to zero when skip instruction is computed */
/* only if pVideo->DecodeMode != VIDEO_FAST */
}

//----------------------------------------------------------------------------
// Function allowing to repeat the display of a picture
//----------------------------------------------------------------------------
VOID VideoRepeat(PVIDEO pVideo)
{
	pVideo->decSlowDown = 1;
/* The variable will come back to zero when repeat done */
/* only if pVideo->DecodeMode != VIDEO_SLOW */
}

//----------------------------------------------------------------------------
// returns the video state
//----------------------------------------------------------------------------
U16 VideoGetState(PVIDEO pVideo)
{
	return pVideo->VideoState;
}

//----------------------------------------------------------------------------
// returns the PTS of the displayed picture
//----------------------------------------------------------------------------
U32 VideoGetPTS(PVIDEO pVideo)
{
	return pVideo->pCurrDisplay->dwPTS;
}

//----------------------------------------------------------------------------
// indicates the first valid DTS
//----------------------------------------------------------------------------
BOOLEAN VideoIsFirstDTS(PVIDEO pVideo)
{
	return pVideo->FirstDTS;
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
BOOLEAN VideoIsFirstField(PVIDEO pVideo)
{
	if (pVideo->VsyncNumber == 1)
		return TRUE;
	else
		return FALSE;
}

//----------------------------------------------------------------------------
// Return bitstream info
//----------------------------------------------------------------------------
P_BITSTREAM VideoGetStreamInfo(PVIDEO pVideo)
{
	return &(pVideo->StreamInfo);
}

//----------------------------------------------------------------------------
// Return command variable
//----------------------------------------------------------------------------
U16 VideoGetVarCommand(PVIDEO pVideo)
{
	return ( pVideo->currCommand );
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
BOOLEAN VideoForceBKC(PVIDEO pVideo, BOOLEAN bEnable)
{
	if(bEnable)
		pVideo->currDCF = pVideo->currDCF & 0xDF;	// FBC
	else
		pVideo->currDCF = pVideo->currDCF | 0x20;	// Don't FBC

	return TRUE;
}

//------------------------------- End of File --------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\stvideo.h ===
#ifndef __STVIDEO_H
#define __STVIDEO_H
//----------------------------------------------------------------------------
// STVIDEO.H
//----------------------------------------------------------------------------
// Description : small description of the goal of the module
//----------------------------------------------------------------------------
// Copyright SGS Thomson Microelectronics  !  Version alpha  !  Jan 1st, 1995
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                               Include files
//----------------------------------------------------------------------------
#include "stdefs.h"
#include "common.h" //!!!!!!!!!!!!!!

//----------------------------------------------------------------------------
//                               Exported Types
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Exported Variables
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Exported Constants
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Exported Functions
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// One line function description (same as in .C)
//----------------------------------------------------------------------------
// In     :
// Out    :
// InOut  :
// Global :
// Return :
//----------------------------------------------------------------------------
S16 VideoOpen(PVIDEO pVideo);
VOID VideoClose(PVIDEO pVideo);
VOID VideoInitDecoder(PVIDEO pVideo, U16 StreamType);
U16 VideoTest(PVIDEO pVideo);
VOID VideoSetMode(PVIDEO pVideo, U16 Mode, U16 param);
VOID VideoDecode(PVIDEO pVideo);
VOID VideoStep(PVIDEO pVideo);
VOID VideoBack(PVIDEO pVideo);
VOID VideoStop(PVIDEO pVideo);
VOID VideoPause(PVIDEO pVideo);
VOID VideoLatchPTS(PVIDEO pVideo, U32 PTSvalue);
BOOLEAN VideoIsEnoughPlace(PVIDEO pVideo, U16 size);

BOOLEAN AudioIsEnoughPlace(PVIDEO pVideo, U16 size);

U32 VideoGetFirstDTS(PVIDEO pVideo);
U16 VideoGetErrorMsg(PVIDEO pVideo);
VOID VideoSkip(PVIDEO pVideo);
VOID VideoRepeat(PVIDEO pVideo);
U16 VideoGetState(PVIDEO pVideo);
U32 VideoGetPTS(PVIDEO pVideo);
BOOLEAN VideoIsFirstDTS(PVIDEO pVideo);
BOOLEAN VideoIsFirstField(PVIDEO pVideo);
P_BITSTREAM VideoGetStreamInfo(PVIDEO pVideo);
U16 VideoGetVarCommand(PVIDEO pVideo);
BOOLEAN VideoForceBKC(PVIDEO pVideo, BOOLEAN bEnable);

//------------------------------- End of File --------------------------------
#endif // #ifndef __STVIDEO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\stmisc.c ===
//----------------------------------------------------------------------------
// STMISC.C
//----------------------------------------------------------------------------
// Description :  All Video Register accesses are made in this File
//----------------------------------------------------------------------------
// Copyright SGS Thomson Microelectronics  !  Version alpha  !  Jan 1st, 1995
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Include files
//----------------------------------------------------------------------------
#include "stdefs.h"
#include "common.h"
#include "stvideo.h"
#include "STllapi.h"
#ifdef STi3520A
	#include "STi3520A.h"
#else
	#include "STi3520.h"
#endif
#include "debug.h"

//----------------------------------------------------------------------------
//                   GLOBAL Variables (avoid as possible)
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                            Private Constants
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                              Private Types
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                     Private GLOBAL Variables (static)
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                    Functions (statics one are private)
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
BOOL IsChipSTi3520(VOID)
{
	//---- Write STi3520 DCF register to 0
	VideoWrite(0x78, 0);
	VideoWrite(0x79, 0);

	//---- Read back DCF MSByte
	if (VideoRead(0x78) != 0)
		return FALSE; // we have red STi3520A VID_REV register
	else
		return TRUE;  // we have red STi3520 DCF register
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
WORD SendAudioIfPossible(PVOID Buffer, WORD Size)
{
 DWORD NbSent;
 PAUDIO	pAudio;

 pAudio = pCard->pAudio;
 for(NbSent = 0 ; NbSent < Size ; NbSent++) {
	 if (pAudio->EnWrite)
		 AudioWrite(DATA_IN, *((PBYTE)Buffer)++);
	 else
		 break; // Audio Blocked
 }

 return NbSent;
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
WORD SendVideoIfPossible(PVOID Buffer, WORD Size)
{
	DebugAssert(Buffer != NULL);
	DebugAssert(Size != 0);

	if (VideoIsEnoughPlace(pCard->pVideo, Size)) {
		VideoSend((PDWORD)Buffer, Size);
		return Size;
	}

	return 0;
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
void VideoSetBBStart(PVIDEO pVideo, U16 bbg)
	{
	#ifndef STi3520A
	pVideo->currCommand|=BBGc;
	VideoWrite ( CMD, pVideo->currCommand >> 8 );// Initiate Write to Command
	VideoWrite ( CMD + 1, pVideo->currCommand & 0xFF );

	VideoWrite ( BBG, bbg >> 8 );// Initiate Write to Command
	VideoWrite ( BBG + 1,bbg & 0xFF );

	pVideo->currCommand&=~BBGc;
	VideoWrite ( CMD, pVideo->currCommand >> 8 );// Initiate Write to Command
	VideoWrite ( CMD + 1, pVideo->currCommand & 0xFF );
	#else
	VideoWrite ( VID_VBG, bbg >> 8 );// Initiate Write to Command
	VideoWrite ( VID_VBG + 1,bbg & 0xFF );
	#endif
	}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
U16  VideoGetBBL(void)
	{
	U16		i;

	DisableIT();
	i = ( VideoRead ( BBL ) & 0x3F ) << 8;
	i = i | ( VideoRead ( BBL + 1 ) );
	EnableIT();
	return ( i );
	}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
void VideoSetBBStop(U16 bbs)
	{
	VideoWrite ( BBS, bbs >> 8 );// Initiate Write to Command
	VideoWrite ( BBS + 1,bbs & 0xFF );
	}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
void VideoSetBBThresh(U16 bbt)
	{
	VideoWrite ( BBT, bbt >> 8 );// Initiate Write to Command
	VideoWrite ( BBT + 1,bbt & 0xFF );
	}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
U16  VideoBlockMove(PVIDEO pVideo, U32 SrcAddress, U32 DestAddress, U16 Size)// starts block move and waits for idle
	{
	U16 counter;
	#ifndef STi3520A
		// perform the block move from  SrcAddress area to DestAddress
	VideoWrite ( CMD, pVideo->currCommand >> 8 );
	VideoWrite ( CMD + 1, pVideo->currCommand | SBM );
	// set block move mode
	VideoSetMRP(SrcAddress);  // Set Source Address
	VideoSetMWP(DestAddress); // Set Destination Address
	VideoWrite ( BMS    , (Size >> 8) & 0xFF );   // 7FFC * 2 / 8 = 1FFF
	VideoWrite ( BMS + 1,  Size & 0xFF );
	counter = 0;
	while ( ! VideoBlockMoveIdle()  )
		{
		counter ++;
		if(counter == 0xFFFF)
				return ( BAD_MEM_V );
		}
	// wait for the end of the block move
	VideoWrite ( CMD, pVideo->currCommand >> 8 );
	VideoWrite ( CMD + 1, pVideo->currCommand & ~SBM );
	#else
	// set block move Size
	VideoWrite ( BMS    , (Size >> 8) & 0xFF );
	VideoWrite ( BMS 	,  Size & 0xFF );
	VideoSetMWP(DestAddress);
	VideoSetMRP(SrcAddress);            // Launches Block Move
	counter = 0;
	while ( ! VideoBlockMoveIdle()  )
		{
		counter ++;
		if(counter == 0xFFFF)
				return ( BAD_MEM_V );
		}
	// wait for the end of the block move
	#endif
	return ( NO_ERROR );
	}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
void VideoStartBlockMove(PVIDEO pVideo, U32 SrcAddress, U32 DestAddress, U32 Size)// starts block move and returns
{
	SrcAddress = SrcAddress;
	DestAddress = DestAddress;
	Size = Size;
	#ifndef STi3520A
	#else
	#endif
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
void VideoCommandSkip(PVIDEO pVideo, U16 Nbpicture)// skips 1,or 2 pictures and decodes next
{
	DebugAssert(Nbpicture <= 2);

	if(Nbpicture > 2)
	{
		pVideo->errCode = ERR_SKIP;
	}
	else
	{
		#ifndef STi3520A
		#else
		#endif
	}
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
void VideoSetSRC(PVIDEO pVideo, U16 SrceSize, U16 DestSize)
	{
	U32 lsr;
		lsr = ( 256 * ( long ) ( SrceSize - 4 ) ) / (DestSize - 1);
	#ifndef STi3520A
		if ( lsr < 32 )
			lsr = 32;
		VideoWrite ( LSO, 0 );   // programmation of the SRC
		VideoWrite ( LSR, lsr );
		VideoWrite ( CSO, 0 );
		VideoWrite ( CSR, lsr );

	#else
		VideoWrite ( LSO, 0 );   // programmation of the SRC
		VideoWrite ( LSR, lsr );
		if(lsr > 255 )
			{
			 VideoWrite ( VID_LSRh, 1);
			}
		VideoWrite ( CSO, 0 );
	#endif
		VideoSRCOn ( pVideo );
	}

//----------------------------------------------------------------------------
// Load Quantization Matrix
//----------------------------------------------------------------------------
void VideoLoadQuantTables(PVIDEO pVideo, BOOLEAN Intra, U8 * Table )
	{
	U16 i; // loop counter
	#ifndef STi3520A
	VideoWrite ( CMD, pVideo->currCommand >> 8 );// Initiate Write to Command
	// Select Intra / Non Intra Table
	if(Intra)
		{
		pVideo->currCommand|=QMI;
		pVideo->currCommand&=~QMN;
		VideoWrite ( CMD + 1, pVideo->currCommand & 0xFF );
		}
	else
		{
		pVideo->currCommand|=QMN;
		pVideo->currCommand&=~QMI;
		VideoWrite ( CMD + 1, pVideo->currCommand & 0xFF );
		}
	// Enable Writing to Table
		pVideo->currCommand|=QMN;
		pVideo->currCommand|=QMI;
		VideoWrite ( CMD + 1, pVideo->currCommand & 0xFF );
	// Load Table
	for (i = 0 ; i < (QUANT_TAB_SIZE/2) ; i++) // 2 bytes loaded at each loop
		{
		VideoWrite(QMW , Table[2*i]);
		VideoWrite(QMW+1 , Table[2*i+1]);
		}
	// Lock Table Again
	pVideo->currCommand&=~QMN;
	pVideo->currCommand&=~QMI;
	VideoWrite ( CMD + 1, pVideo->currCommand & 0xFF );
	#else
	// Select Intra / Non Intra Table
	if(Intra)
		VideoWrite(VID_HDS,QMI);
	else
		VideoWrite(VID_HDS,(0&~QMI));
	// Load Table
	for (i = 0 ; i < QUANT_TAB_SIZE ; i++)
		VideoWrite(VID_QMW,Table[i]);
	// Lock Table Again
	VideoWrite(VID_HDS,0);
	#endif
	}

//----------------------------------------------------------------------------
//  Computes Instruction and stores in Ins1 Ins2 Cmd vars
//----------------------------------------------------------------------------
void VideoComputeInst(PVIDEO pVideo)
	{
	INSTRUCTION  Ins = pVideo->NextInstr;// Local var.
#ifndef STi3520A
pVideo->Cmd  = (pVideo->currCommand&0xFCFF)|(Ins.Skip << 4);
pVideo->Ins1 = (Ins.Tff<<15)|(Ins.Ovw<<14)|(Ins.Bfh<<10)|(Ins.Ffh<< 6)|
				 (Ins.Pct<< 4)|(Ins.Seq<< 3)|(Ins.Exe<< 2)|(Ins.Rpt<< 1)|(Ins.Cmv);
pVideo->Ins2 = (Ins.Pst<<14)|(Ins.Bfv<<10)|(Ins.Ffv<< 6)|(Ins.Dcp<< 4)|
				 (Ins.Frm <<3)|(Ins.Qst<< 2)|(Ins.Azz<< 1)|(Ins.Ivf);
#else
pVideo->Ppr1 = (Ins.Pct<< 4)|(Ins.Dcp<< 2)|(Ins.Pst );
pVideo->Ppr2 = (Ins.Tff<< 5)|(Ins.Frm<<4)|(Ins.Cmv<< 3)|(Ins.Qst<< 2)|
				 (Ins.Ivf<< 1)|(Ins.Azz   );
pVideo->Tis  = (Ins.Mp2<< 6)|(Ins.Skip<< 4)|(Ins.Ovw<< 3)|(Ins.Rpt<< 1)|
				 (Ins.Exe    );
pVideo->Pfh  = (Ins.Bfh<< 4)|(Ins.Ffh    );
pVideo->Pfv  = (Ins.Bfv<< 4)|(Ins.Ffv    );
#endif
}

//----------------------------------------------------------------------------
// put the decoder into WAIT mode
//----------------------------------------------------------------------------
/* This routine actually clears all bits of INS1/TIS registers

	This is not a problem since the whole registers HAVE to
	be rewritten when storing a new instruction.                 */
void    VideoWaitDec ( PVIDEO pVideo )
	{
#ifndef STi3520A
	VideoWrite ( CMD, 0 );
	VideoWrite ( CMD + 1, 0);
	// preset a write to INS1
	VideoWrite ( INS, 0 );
	VideoWrite ( INS + 1, 0);
	// not EXE
#else
	VideoWrite ( VID_TIS, 0 );
//if(pVideo->perFrame == TRUE)
//		{
		VideoChooseField(pVideo);// If Step by step decoding, set freeze bit
//		}
#endif

	}

//----------------------------------------------------------------------------
// starts a manual header search
//----------------------------------------------------------------------------
void VideoLaunchHeadSearch ( PVIDEO pVideo )
	{
#ifndef STi3520A
	VideoWrite ( CMD, pVideo->currCommand >> 8 );
	VideoWrite ( CMD + 1, pVideo->currCommand | 0x01 );
#else
	VideoWrite ( VID_HDS, HDS );
#endif
	}

//----------------------------------------------------------------------------
// Routine storing pVideo->nextInstr1 and 2 into the instruction registers
//----------------------------------------------------------------------------
void VideoStoreINS ( PVIDEO pVideo )
{
VideoComputeInst( pVideo) ;
#ifndef STi3520A
	VideoWrite ( CMD, pVideo->Cmd >> 8 );
	if ( pVideo->StreamInfo.modeMPEG2 )
	{
		VideoWrite ( CMD + 1, pVideo->Cmd | 0x8 );
		// preset a write to INS2
		VideoWrite ( INS, ( pVideo->Ins2 >> 8 ) );
		VideoWrite ( INS + 1, ( pVideo->Ins2 & 0xFF ) );
	}
	VideoWrite ( CMD + 1, pVideo->Cmd& 0xF7 );
	// preset a write to INS1
	VideoWrite ( INS, ( pVideo->Ins1 >> 8 ) );
	VideoWrite ( INS + 1, ( pVideo->Ins1 & 0xFF ) );
#else
	VideoWrite ( VID_TIS ,  pVideo->Tis  );
	VideoWrite ( VID_PPR1,  pVideo->Ppr1 );
	VideoWrite ( VID_PPR2,  pVideo->Ppr2 );
	VideoWrite ( VID_PFV ,  pVideo->Pfv  );
	VideoWrite ( VID_PFH ,  pVideo->Pfh  );
#endif
}

//----------------------------------------------------------------------------
//  Routine reading the number of bytes loaded in the CD_FIFO
//----------------------------------------------------------------------------
U32 VideoReadCDCount ( PVIDEO pVideo )
{
#ifndef STi3520A
	unsigned long   counter = 0;
	S16             i;

	DisableIT();

	pVideo->currCommand = pVideo->currCommand & 0xFCFF;		   // reset AVS bits
	VideoWrite ( CMD, ( pVideo->currCommand >> 8 ) | 0x1 );
	// access to CDcount[23:16]
	VideoWrite ( CMD + 1, pVideo->currCommand & 0xFF );
	counter = VideoRead ( CMD );
	i = VideoRead ( CMD + 1 ) & 0xFF;
	counter = ( unsigned long ) ( i ) << 16;	// contains
												// CDcount[23:16]
	VideoWrite ( CMD, pVideo->currCommand >> 8 );
	// access to CDcount[15:0]
	VideoWrite ( CMD + 1, pVideo->currCommand & 0xFF );
	i = ( VideoRead ( CMD ) << 8 ) | ( VideoRead ( CMD + 1 ) & 0xFF );
	counter = counter + ( ( unsigned long ) ( i ) & 0xFFFF );

	EnableIT(  );

	return ( counter );
#else
	U32 cd;
	DisableIT();

	cd  = ((U32)(VideoRead(CDcount)&0xFF))<<16;
	cd |= ((U32)(VideoRead(CDcount)&0xFF))<<8;
	cd |=  (U32)(VideoRead(CDcount)&0xFF);

	EnableIT(  );
	return ( cd );
#endif
}

//----------------------------------------------------------------------------
//  Routine reading the number of bytes extracted by the SCD
//----------------------------------------------------------------------------
U32   VideoReadSCDCount ( PVIDEO pVideo )
{
#ifndef STi3520A
	unsigned long   counter = 0;
	S16             i;

	DisableIT (  );

	pVideo->currCommand = pVideo->currCommand & 0xFCFF;		   // reset AVS bits
	VideoWrite ( CMD, ( pVideo->currCommand >> 8 ) | 0x3 );
	// access to SCDcount[23:16]
	VideoWrite ( CMD + 1, pVideo->currCommand & 0xFF );
	VideoRead ( CMD );
	i = VideoRead ( CMD + 1 ) & 0xFF;
	counter = ( unsigned long ) ( i ) << 16;	// contains
												// SCDcount[23:16]
	VideoWrite ( CMD, ( pVideo->currCommand >> 8 ) | 0x2 );
	// access to SCDcount[15:0]
	VideoWrite ( CMD + 1, pVideo->currCommand & 0xFF );
	i = ( VideoRead ( CMD ) << 8 ) | ( VideoRead ( CMD + 1 ) & 0xFF );
	counter = counter + ( ( unsigned long ) ( i ) & 0xFFFF );

	EnableIT (  );

	return ( counter );
#else
	U32 Scd;
	DisableIT (  );

	Scd  = ((U32)(VideoRead(SCDcount)&0xFF))<<16;
	Scd |= ((U32)(VideoRead(SCDcount)&0xFF))<<8;
	Scd |=  (U32)(VideoRead(SCDcount)&0xFF);

	EnableIT (  );
	return ( Scd );
#endif
}

//----------------------------------------------------------------------------
// DRAM I/O
//----------------------------------------------------------------------------
void VideoSetMWP(U32 mwp)
	{
	U8 m0, m1, m2;
#ifndef STi3520A
	m0 = (U8)( (mwp >> 16) & 0xFF );
	m1 = (U8)( (mwp >>  8) & 0xFF );
	m2 = (U8)(  mwp        & 0xFF );
	VideoWrite(MWP  , m0);
	VideoWrite(MWP+1, m1);
	VideoWrite(MWP+2, m2);
#else
	m0 = (U8)( (mwp >> 14) & 0xFF );
	m1 = (U8)( (mwp >>  6) & 0xFF );
	m2 = (U8)( (mwp <<  2) & 0xFF );
	VideoWrite(MWP  , m0);
	VideoWrite(MWP  , m1);
	VideoWrite(MWP  , m2);
#endif

	}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
void VideoSetMRP(U32 mrp)
	{
	U8 m0, m1, m2;
#ifndef STi3520A
	m0 = (U8)( (mrp >> 16) & 0xFF );
	m1 = (U8)( (mrp >>  8) & 0xFF );
	m2 = (U8)(  mrp        & 0xFF );
	VideoWrite(MRP  , m0);
	VideoWrite(MRP+1, m1);
	VideoWrite(MRP+2, m2);
#else
	m0 = (U8)( (mrp >> 14) & 0xFF );
	m1 = (U8)( (mrp >>  6) & 0xFF );
	m2 = (U8)( (mrp <<  2) & 0xFF );
	VideoWrite(MRP  , m0);
	VideoWrite(MRP  , m1);
	VideoWrite(MRP  , m2);
#endif

	}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
BOOLEAN VideoMemWriteFifoEmpty( void )
	{
		return ( (VideoRead ( STA ) & 0x4) );
	}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
BOOLEAN VideoMemReadFifoFull( void )
	{
		return ( (VideoRead ( STA ) & 0x8) );
	}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
BOOLEAN VideoHeaderFifoEmpty( void )
	{
	VideoRead ( STA );
		return ( (VideoRead ( STA + 1 ) & 0x4) );
	}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
BOOLEAN VideoBlockMoveIdle( void )
	{
		return ( (VideoRead ( STA  ) & 0x20) );
	}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
void VideoEnableDecoding(PVIDEO pVideo, BOOLEAN OnOff)
	{
	if(OnOff)
		pVideo->Ctl |= EDC;
	else
		pVideo->Ctl &= ~EDC;
#ifndef STi3520A
	VideoWrite(CTL    , (pVideo->Ctl>>8) );
	VideoWrite(CTL + 1, pVideo->Ctl & 0xFF );
#else
	VideoWrite(CTL ,  pVideo->Ctl & 0xFF );
//CTL OK
#endif
	}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
void VideoEnableErrConc(PVIDEO pVideo, BOOLEAN OnOff)
	{
#ifndef STi3520A
	if(OnOff)
		pVideo->Ctl = (pVideo->Ctl |EPR)&~EDC;
	else
		pVideo->Ctl = (pVideo->Ctl&~EPR)|EDC;
	VideoWrite(CTL    , (pVideo->Ctl>>8) );
	VideoWrite(CTL + 1,  pVideo->Ctl     );
#else
	if(OnOff)
		pVideo->Ctl = (pVideo->Ctl |EPR|ERS|ERU)&~DEC;
	else
		pVideo->Ctl = (pVideo->Ctl&~EPR&~ERS&~ERU)|DEC;
	VideoWrite(CTL ,  pVideo->Ctl & 0xFF );
#endif
	}

//----------------------------------------------------------------------------
// pipeline RESET
//----------------------------------------------------------------------------
void VideoPipeReset ( PVIDEO pVideo )
	{
#ifndef STi3520A
	pVideo->Ctl |= PRS;
	VideoWrite(CTL    , (pVideo->Ctl>>8) );
	VideoWrite(CTL + 1,  pVideo->Ctl     );
	WaitMicroseconds(1000);
	pVideo->Ctl &= ~PRS;
	VideoWrite(CTL + 1,  pVideo->Ctl     );
#else
	pVideo->Ctl |= PRS;
	VideoWrite(CTL ,  pVideo->Ctl     );
	WaitMicroseconds(1000);
	pVideo->Ctl &= ~PRS;
	VideoWrite(CTL ,  pVideo->Ctl     );
#endif
	}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
void VideoSoftReset ( PVIDEO pVideo  )
	{
#ifndef STi3520A
	pVideo->Ctl |= SRS;
	VideoWrite(CTL    , (pVideo->Ctl>>8) );
	VideoWrite(CTL + 1,  pVideo->Ctl     );
	WaitMicroseconds(1000);
	pVideo->Ctl = pVideo->Ctl&~ECK;
	VideoWrite(CTL + 1,  pVideo->Ctl     );
	pVideo->Ctl = pVideo->Ctl&~SRS;
	VideoWrite(CTL + 1,  pVideo->Ctl     );
	pVideo->Ctl = pVideo->Ctl|ECK;
	VideoWrite(CTL + 1,  pVideo->Ctl     );
#else
	pVideo->Ctl |= SRS;
	VideoWrite(CTL ,  pVideo->Ctl     );
//CTL OK
	WaitMicroseconds(1000);
	pVideo->Ctl &= ~SRS;
	VideoWrite(CTL ,  pVideo->Ctl     );
//CTL OK
#endif
	}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
void VideoEnableInterfaces ( PVIDEO pVideo, BOOLEAN OnOff )
	{
#ifndef STi3520A
	if(OnOff)
		pVideo->Ctl = pVideo->Ctl |EVI|EDI|ECK|EC2|EC3;
	else
		pVideo->Ctl = pVideo->Ctl&~EVI&~EDI&~ECK&~EC2&~EC3;
	VideoWrite(CTL    , (pVideo->Ctl>>8) );
	VideoWrite(CTL + 1,  pVideo->Ctl     );
#else
	if(OnOff)
		pVideo->Ccf = pVideo->Ccf |EVI|EDI|ECK|EC2|EC3;
	else
		pVideo->Ccf = pVideo->Ccf&~EVI&~EDI&~ECK&~EC2&~EC3;
	VideoWrite(CFG_CCF,pVideo->Ccf);
// CCF OK
#endif
	}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
void VideoPreventOvf( PVIDEO pVideo, BOOLEAN OnOff )
	{
#ifndef STi3520A
	if(OnOff)
		pVideo->Ctl = pVideo->Ctl |PBO;
	else
		pVideo->Ctl = pVideo->Ctl&~PBO;
	VideoWrite(CTL    , (pVideo->Ctl>>8) );
	VideoWrite(CTL + 1,  pVideo->Ctl     );
#else
	if(OnOff)
		pVideo->Ccf = pVideo->Ccf |PBO;
	else
		pVideo->Ccf = pVideo->Ccf&~PBO;
	VideoWrite(CFG_CCF,pVideo->Ccf);
#endif
	}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
void VideoSetFullRes( PVIDEO pVideo)
	{
	pVideo->HalfRes = FALSE;
#ifndef STi3520A
	pVideo->Ctl = pVideo->Ctl & ~HRD;
	VideoWrite(CTL    , (pVideo->Ctl>>8) );
	VideoWrite(CTL + 1,  pVideo->Ctl     );
#endif
	pVideo->currDCF = pVideo->currDCF | pVideo->fullVerFilter;
	VideoWrite ( DCF, 0 );
	VideoWrite ( DCF + 1, pVideo->currDCF );
	}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
void VideoSetHalfRes( PVIDEO pVideo)
	{
	pVideo->HalfRes = TRUE;
#ifndef STi3520A
	pVideo->Ctl = pVideo->Ctl |HRD;
	VideoWrite(CTL    , (pVideo->Ctl>>8) );
	VideoWrite(CTL + 1,  pVideo->Ctl     );
#endif
	pVideo->currDCF = pVideo->currDCF | pVideo->halfVerFilter;
	VideoWrite ( DCF, 0 );
	VideoWrite ( DCF + 1, pVideo->currDCF );
	}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
void VideoSelectMpeg2( PVIDEO pVideo , BOOLEAN OnOff)
	{
#ifndef STi3520A
	if(OnOff)
		pVideo->Ctl = pVideo->Ctl |MP2;
	else
		pVideo->Ctl = pVideo->Ctl&~MP2;
	VideoWrite(CTL    , (pVideo->Ctl>>8) );
	VideoWrite(CTL + 1,  pVideo->Ctl     );
#else
	if(OnOff)
		pVideo->NextInstr.Mp2 = 1;
	else
		pVideo->NextInstr.Mp2 = 0;
#endif
	}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
void VideoSelect8M( PVIDEO pVideo , BOOLEAN OnOff)
	{
#ifndef STi3520A
	if(OnOff)
		pVideo->Ctl = pVideo->Ctl |S8M;
	else
		pVideo->Ctl = pVideo->Ctl&~S8M;
	VideoWrite(CTL    , (pVideo->Ctl>>8) );
	VideoWrite(CTL + 1,  pVideo->Ctl     );
#else
	if(OnOff)
		pVideo->Ccf = pVideo->Ccf |M32;
	else
		pVideo->Ccf = pVideo->Ccf&~M32;
	VideoWrite(CFG_CCF,pVideo->Ccf);
#endif
	}

//----------------------------------------------------------------------------
// GCF1 register Routines
//----------------------------------------------------------------------------
void VideoSetDramRefresh( PVIDEO pVideo, U16 Refresh)
	{
	pVideo->Gcf = pVideo->Gcf |(Refresh & RFI);
#ifndef STi3520A
	VideoWrite(GCF    , (pVideo->Gcf>>8) );
	VideoWrite(GCF + 1,  pVideo->Gcf     );
#else
	VideoWrite(CFG_MCF,pVideo->Gcf);
#endif
	}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
void VideoSelect20M( PVIDEO pVideo, BOOLEAN OnOff)
	{
	if(OnOff)
		pVideo->Gcf = pVideo->Gcf | M20;
	else
		pVideo->Gcf = pVideo->Gcf &~M20;

#ifndef STi3520A
	VideoWrite(GCF    , (pVideo->Gcf>>8) );
	VideoWrite(GCF + 1,  pVideo->Gcf     );
#else
	VideoWrite(CFG_MCF,pVideo->Gcf);
#endif
	}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
void VideoSetDFA( PVIDEO pVideo, U16 dfa)
	{
#ifndef STi3520A
	pVideo->Gcf = pVideo->Gcf |(dfa & DFA);
	VideoWrite(GCF    , (pVideo->Gcf>>8) );
	VideoWrite(GCF + 1,  pVideo->Gcf     );
#else
	VideoWrite(VID_DFA , dfa>>8);
	VideoWrite(VID_DFA , dfa);
#endif
	}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
void VideoEnableDisplay( PVIDEO pVideo )
	{
	pVideo->currDCF = pVideo->currDCF |0x20;
	VideoWrite ( DCF, 0 );
	VideoWrite ( DCF + 1, pVideo->currDCF );

	}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
void VideoDisableDisplay( PVIDEO pVideo )
	{
	pVideo->currDCF = pVideo->currDCF &(~0x20);
	VideoWrite ( DCF, 0 );
	VideoWrite ( DCF + 1, pVideo->currDCF );

	}

//------------------------------- End of File --------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\tecra\adv.cpp ===
//***************************************************************************
//
//	FileName:
//		$Workfile: adv.cpp $
//      ADV7170 Interface 
//
//	Author:
//		TOSHIBA [PCS](PSY) Seiichi Nakamura
//		Copyright (c) 1997 TOSHIBA CORPORATION
//
//	Description:
//
//***************************************************************************
// $Header: /DVD Drivers/Sources/ZiVAHAL/adv.cpp 22    98/04/20 7:19p Hero $
// $Modtime: 98/04/20 6:22p $
// $Nokeywords:$
//
// Macrovision  7.01   10/21
//
//***************************************************************************
//     Date    |   Author     |  Description
//  -----------+--------------+--------------------------------------------
//  1997.11.11 |  Hideki Yagi | Modify ADV7175A to ADV7170 for San-Jose
//             |              | Adding SetCgmsType method.
//       12.04 |  Hideki Yagi | Adding WSS support.
//

//---------------------------------------------------------------------------
//	includes
//---------------------------------------------------------------------------

#include "includes.h"

#include "ioif.h"
#include "timeout.h"
#include "adv.h"
#include "zivachip.h"
#include "mixhal.h"
// by oka 
#include "userdata.h"
#include "zivabrd.h"

#define IIC_TIMEOUT		(5000)
#define IIC_SLEEPTIME	(1)

// ADV7175A/ADV7170 Slave Address
#define SLAVE_ADDR		(0x0d4L)

#define		COMPOSITE_OFF	(0x40)
#define		SVIDEO_OFF		(0x38)

// by oka
#define		CLOSED_CAPTION_ON (0x06)

//---------------------------------------------------------------------------
//	CIIC constructor
//---------------------------------------------------------------------------
CIIC::CIIC(void):SubAddr(0),m_pioif(NULL)
{
};

//---------------------------------------------------------------------------
//	CIIC::Init
//---------------------------------------------------------------------------
void    CIIC::Init(IKernelService *pKernelObj, CIOIF *pioif, BYTE addr )
{
	m_pioif = pioif;
	SubAddr = addr;
	m_pKernelObj = pKernelObj;
};

//---------------------------------------------------------------------------
//	CIIC::IICBusyPoll
//---------------------------------------------------------------------------
BOOL    CIIC::IICBusyPoll( void )
{
	BYTE Data;

	CTimeOut TimeOut( IIC_TIMEOUT, IIC_SLEEPTIME , m_pKernelObj );
	
	// following algorithm is very BAD.
	while( TRUE )
	{
		Data = m_pioif->luke2.I2C_CONT.Get(3);	// Get I2C_Cont 31-24 bit
		if( (Data & 0x80 ) == 0 )				// check busy bit.
			return TRUE;

		TimeOut.Sleep();

		// check Time out....... 1 sec
		if( TimeOut.CheckTimeOut() == TRUE )
		{
			DBG_BREAK();
			return FALSE;
		};
	};
//    return FALSE;
};

//---------------------------------------------------------------------------
//	CIIC::set
//---------------------------------------------------------------------------
DWORD   CIIC::Set( BYTE Data )
{
	ASSERT( m_pioif != NULL );
//  DBG_PRINTF( ("CADV7170::CIIC::Set SubAddr = 0x%x Data = 0x%x\n", SubAddr, Data) );

// by oka
//	if( IICBusyPoll() == FALSE )	return FALSE;
	BYTE status = 0x80;
	for( DWORD count = 0;(count < 1000) && (status & 0x80) != 0;count++)
	{
		status = m_pioif->luke2.I2C_CONT.Get(3);	// Get I2C_Cont 31-24 bit
	}
	if (count == 1000){
		return FALSE;
	}
// end
	m_pioif->luke2.I2C_CONT = (DWORD)( ( SLAVE_ADDR << 16 ) | (SubAddr << 8) | Data );

// by oka
//	if( IICBusyPoll() == FALSE )	return FALSE;
	for( count = 0;(count < 1000) && (status & 0x80) != 0;count++)
	{
		status = m_pioif->luke2.I2C_CONT.Get(3);	// Get I2C_Cont 31-24 bit
	}
	if (count == 1000){
		return FALSE;
	}
// end	
//	if( ( m_pioif->luke2.I2C_CONT.Get(3) & 0x01 ) == 0 )		// check ACK bit
//		return FALSE;
	
	return TRUE;
};

//---------------------------------------------------------------------------
//	CIIC::Get
//---------------------------------------------------------------------------
DWORD   CIIC::Get( BYTE *Data )
{
	ASSERT( m_pioif != NULL );
    DBG_PRINTF( ("CADV7170::CIIC::Get SubAddr = 0x%x ", SubAddr) );

	if( IICBusyPoll() == FALSE )	return FALSE;
	m_pioif->luke2.I2C_CONT = ((DWORD)SLAVE_ADDR << 16 ) | 0x06000000L | ((DWORD)SubAddr << 8);
	if( IICBusyPoll() == FALSE )	return FALSE;
	m_pioif->luke2.I2C_CONT = ((DWORD)(SLAVE_ADDR | 1) << 16 ) | 0x08000000L | ((DWORD)SubAddr << 8);
	if( IICBusyPoll() == FALSE )	return FALSE;

	*Data = m_pioif->luke2.I2C_CONT.Get(0);

//	if( ( m_pioif->luke2.I2C_CONT.Get(3) & 0x01 ) == 0 )		// check ACK bit
//		return FALSE;
	
	return TRUE;
};

//***************************************************************************
//	CADV7175A control interfaces
//***************************************************************************
//---------------------------------------------------------------------------
//	CADV7175A constructor
//---------------------------------------------------------------------------
CADV7175A::CADV7175A(void)
{
};

//---------------------------------------------------------------------------
//	CADV7175A::Init
//---------------------------------------------------------------------------
void	CADV7175A::Init(IKernelService *pKernelObj, CIOIF *pioif )
{
	ModeRegister0.Init( 			pKernelObj, pioif, 0x00  );
	ModeRegister1.Init( 			pKernelObj, pioif, 0x01  );
	SubCarrierFreqRegister0.Init( 	pKernelObj, pioif, 0x02  );
	SubCarrierFreqRegister1.Init( 	pKernelObj, pioif, 0x03  );
	SubCarrierFreqRegister2.Init( 	pKernelObj, pioif, 0x04  );
	SubCarrierFreqRegister3.Init( 	pKernelObj, pioif, 0x05  );
	SubCarrierPhaseRegister.Init( 	pKernelObj, pioif, 0x06  );
	TimingRegister.Init( 			pKernelObj, pioif, 0x07  );
	ClosedCapExData0.Init( 			pKernelObj, pioif, 0x08  );
	ClosedCapExData1.Init( 			pKernelObj, pioif, 0x09  );
	ClosedCapData0.Init( 			pKernelObj, pioif, 0x0a  );
	ClosedCapData1.Init( 			pKernelObj, pioif, 0x0b  );
	TimingRegister1.Init( 			pKernelObj, pioif, 0x0c  );
	ModeRegister2.Init( 			pKernelObj, pioif, 0x0d  );
	NTSCTTXRegister0.Init( 			pKernelObj, pioif, 0x0e  );
	NTSCTTXRegister1.Init( 			pKernelObj, pioif, 0x0f  );
	NTSCTTXRegister2.Init( 			pKernelObj, pioif, 0x10  );
	NTSCTTXRegister3.Init( 			pKernelObj, pioif, 0x11  );
	ModeRegister3.Init( 			pKernelObj, pioif, 0x12  );

    for( int i = 0 ; i < 17; i ++ )
        MacrovisionRegister[i].Init(    pKernelObj, pioif, (BYTE)(0x13+i)  );

	TTXRQControlRegister0.Init( 	pKernelObj, pioif, 0x24  );
	TTXRQControlRegister.Init( 	pKernelObj, pioif, 0x37  );

	bCompPower = FALSE;		// Composit Power off
	bSVideoPower = FALSE;	// s-video Power off
// by oka
	bClosedCaption = FALSE; // Closed Caption off

	m_apstype = ApsType_Off;
	m_OutputType = OUTPUT_NTSC;
};

//---------------------------------------------------------------------------
//	CADV7175A::SetNTSC
//---------------------------------------------------------------------------
BOOL	CADV7175A::SetNTSC( void )
{
	BYTE Data;
	
	ModeRegister0				= 0x14;

	Data = 0x20;
// by oka
	if( bClosedCaption == TRUE )	Data |= CLOSED_CAPTION_ON;
	if( bCompPower == FALSE )	Data |= COMPOSITE_OFF;
	if( bSVideoPower == FALSE )	Data |= SVIDEO_OFF;
	ModeRegister1				= Data;

	SubCarrierFreqRegister0		= 0x16;
	SubCarrierFreqRegister1		= 0x7c;
	SubCarrierFreqRegister2		= 0xf0;
	SubCarrierFreqRegister3		= 0x21;
	SubCarrierPhaseRegister		= 0x00;
//	TimingRegister				= 0x0d;
	TimingRegister				= 0x08;
	ClosedCapExData0			= 0x00;
	ClosedCapExData1			= 0x00;
	ClosedCapData0				= 0x00;
	ClosedCapData1				= 0x00;
//	TimingRegister1				= 0x72;
	TimingRegister1				= 0x00;

	if( bCompPower == FALSE && bSVideoPower == FALSE )
		ModeRegister2				= 0xc8;
	else
		ModeRegister2				= 0x48;

	NTSCTTXRegister0			= 0x00;
	NTSCTTXRegister1			= 0x00;
	NTSCTTXRegister2			= 0x00;
	NTSCTTXRegister3			= 0x00;
	ModeRegister3				= 0x02;
	TTXRQControlRegister		= 0x00;

	if( m_OutputType != OUTPUT_NTSC )
		SetMacroVision( m_apstype );

	m_OutputType = OUTPUT_NTSC;

	return TRUE;
};

//---------------------------------------------------------------------------
//	CADV7175A::SetPAL
//---------------------------------------------------------------------------
BOOL	CADV7175A::SetPAL( DWORD Type )
{
	BYTE Data;
	
	switch( Type )
	{
		case 0:			// PAL B,D,G,H,I
			ModeRegister0				= 0x11;
			SubCarrierFreqRegister0		= 0xcb;
			SubCarrierFreqRegister1		= 0x8a;
			SubCarrierFreqRegister2		= 0x09;
			SubCarrierFreqRegister3		= 0x2a;
			SubCarrierPhaseRegister		= 0x00;
			break;

		case 1:			// PAL M
			ModeRegister0				= 0x12;
			SubCarrierFreqRegister0		= 0xa3;
			SubCarrierFreqRegister1		= 0xef;
			SubCarrierFreqRegister2		= 0xe6;
			SubCarrierFreqRegister3		= 0x21;
			SubCarrierPhaseRegister		= 0x00;
			break;

		default:
			DBG_BREAK();
			return FALSE;
	};

	Data = 0x20;
// by oka
	if( bClosedCaption == TRUE )	Data |= CLOSED_CAPTION_ON;
	if( bCompPower == FALSE )	Data |= COMPOSITE_OFF;
	if( bSVideoPower == FALSE )	Data |= SVIDEO_OFF;
	ModeRegister1				= Data;


//	TimingRegister				= 0x0d;
	TimingRegister				= 0x08;
	ClosedCapExData0			= 0x00;
	ClosedCapExData1			= 0x00;
	ClosedCapData0				= 0x00;
	ClosedCapData1				= 0x00;
//	TimingRegister1				= 0x72;
	TimingRegister1				= 0x00;

	if( bCompPower == FALSE && bSVideoPower == FALSE )
		ModeRegister2				= 0xc8;
	else
		ModeRegister2				= 0x48;

	NTSCTTXRegister0			= 0x00;
	NTSCTTXRegister1			= 0x00;
	NTSCTTXRegister2			= 0x00;
	NTSCTTXRegister3			= 0x00;
	ModeRegister3				= 0x00;
	TTXRQControlRegister		= 0x00;

	if( m_OutputType != OUTPUT_PAL )
		SetMacroVision( m_apstype );

	m_OutputType = OUTPUT_PAL;

	return TRUE;
};


//---------------------------------------------------------------------------
//	CADV7175A::SetMacroVision
//---------------------------------------------------------------------------
BOOL	CADV7175A::SetMacroVision( APSTYPE Type )
{
	int i;
	
	switch( m_OutputType )
	{
		case OUTPUT_NTSC:

			switch( Type )
			{
				case ApsType_Off:
					MacrovisionRegister[0] = 0x40;	// 0xc0;
					for( i = 1 ; i < 17; i ++ )
						MacrovisionRegister[i] = 0x00;
					break;
				case ApsType_1:
					MacrovisionRegister[ 0] = 0x76;	// 0xf6
					MacrovisionRegister[ 1] = 0x07;
					MacrovisionRegister[ 2] = 0x95;
					MacrovisionRegister[ 3] = 0x50;
					MacrovisionRegister[ 4] = 0xce;
					MacrovisionRegister[ 5] = 0xb6;
					MacrovisionRegister[ 6] = 0x91;
					MacrovisionRegister[ 7] = 0xf8;
					MacrovisionRegister[ 8] = 0x1f;
					MacrovisionRegister[ 9] = 0x00;	// 0x0c;
					MacrovisionRegister[10] = 0xcc;	// 0xc0;
					MacrovisionRegister[11] = 0x03;
					MacrovisionRegister[12] = 0x00;
					MacrovisionRegister[13] = 0x58;
					MacrovisionRegister[14] = 0x85;
					MacrovisionRegister[15] = 0xca;
					MacrovisionRegister[16] = 0xff;
					break;

				case ApsType_2:
					MacrovisionRegister[ 0] = 0x7e;
					MacrovisionRegister[ 1] = 0x07;
					MacrovisionRegister[ 2] = 0x95;
					MacrovisionRegister[ 3] = 0x50;
					MacrovisionRegister[ 4] = 0xce;
					MacrovisionRegister[ 5] = 0xb6;
					MacrovisionRegister[ 6] = 0x91;
					MacrovisionRegister[ 7] = 0xf8;
					MacrovisionRegister[ 8] = 0x1f;
					MacrovisionRegister[ 9] = 0x00;	// 0x0c;
					MacrovisionRegister[10] = 0xcc;	// 0xc0;
					MacrovisionRegister[11] = 0x03;
					MacrovisionRegister[12] = 0x00;
					MacrovisionRegister[13] = 0x58;
					MacrovisionRegister[14] = 0x85;
					MacrovisionRegister[15] = 0xca;
					MacrovisionRegister[16] = 0xff;
					break;

				case ApsType_3:
					MacrovisionRegister[ 0] = 0xfe;
					MacrovisionRegister[ 1] = 0x45;
					MacrovisionRegister[ 2] = 0x85;
					MacrovisionRegister[ 3] = 0x54;
					MacrovisionRegister[ 4] = 0xeb;
					MacrovisionRegister[ 5] = 0xb6;
					MacrovisionRegister[ 6] = 0x91;
					MacrovisionRegister[ 7] = 0xf8;
					MacrovisionRegister[ 8] = 0x1f;
					MacrovisionRegister[ 9] = 0x00;	// 0x0c;
					MacrovisionRegister[10] = 0xcc;	// 0xc0;
					MacrovisionRegister[11] = 0x03;
					MacrovisionRegister[12] = 0x00;
					MacrovisionRegister[13] = 0x58;
					MacrovisionRegister[14] = 0x85;
					MacrovisionRegister[15] = 0xca;
					MacrovisionRegister[16] = 0xff;
					break;

				default:
					return FALSE;
			};
			break;

		case OUTPUT_PAL:

			switch( Type )
			{
				case ApsType_Off:
					MacrovisionRegister[ 0] = 0x80;
					MacrovisionRegister[ 1] = 0x16;
					MacrovisionRegister[ 2] = 0xaa;
					MacrovisionRegister[ 3] = 0x61;
					MacrovisionRegister[ 4] = 0x05;
					MacrovisionRegister[ 5] = 0xd7;
					MacrovisionRegister[ 6] = 0x53;
					MacrovisionRegister[ 7] = 0xfe;
					MacrovisionRegister[ 8] = 0x03;
					MacrovisionRegister[ 9] = 0xaa;
					MacrovisionRegister[10] = 0x80;
					MacrovisionRegister[11] = 0xbf;
					MacrovisionRegister[12] = 0x1f;
					MacrovisionRegister[13] = 0x18;
					MacrovisionRegister[14] = 0x04;
					MacrovisionRegister[15] = 0x7a;
					MacrovisionRegister[16] = 0x55;
					break;

				case ApsType_1:
				case ApsType_2:
				case ApsType_3:
					MacrovisionRegister[ 0] = 0xb6;
					MacrovisionRegister[ 1] = 0x16;		// 0x26; // 0x16;
					MacrovisionRegister[ 2] = 0xaa;
					MacrovisionRegister[ 3] = 0x61;		// 0x62; // 0x61;
					MacrovisionRegister[ 4] = 0x05;
					MacrovisionRegister[ 5] = 0xd7;
					MacrovisionRegister[ 6] = 0x53;
					MacrovisionRegister[ 7] = 0xfe;	// 0xfc;
					MacrovisionRegister[ 8] = 0x03;
					MacrovisionRegister[ 9] = 0xaa;
					MacrovisionRegister[10] = 0x80;
					MacrovisionRegister[11] = 0xbf;
					MacrovisionRegister[12] = 0x1f;
					MacrovisionRegister[13] = 0x18;
					MacrovisionRegister[14] = 0x04;
					MacrovisionRegister[15] = 0x7a;
					MacrovisionRegister[16] = 0x55;
					break;

				default:
					return FALSE;
			};
			break;

		default:
			return FALSE;
	};

	m_apstype = Type;
	return TRUE;
};

//---------------------------------------------------------------------------
//	CADV7175A::SetCompPowerOn
//---------------------------------------------------------------------------
BOOL	CADV7175A::SetCompPowerOn( BOOL Type )
{
	BYTE Data;

	bCompPower = Type;

	if( bCompPower == FALSE && bSVideoPower == FALSE )
	{
		Data = 0x20;
// by oka
		if( bClosedCaption == TRUE )	Data |= CLOSED_CAPTION_ON;
		if( bCompPower == FALSE )	Data |= COMPOSITE_OFF;
		if( bSVideoPower == FALSE )	Data |= SVIDEO_OFF;
		ModeRegister1				= Data;

		ModeRegister2				= 0xc8;
	}
	else
	{
		ModeRegister2				= 0x48;

		Data = 0x20;
// by oka
		if( bClosedCaption == TRUE )	Data |= CLOSED_CAPTION_ON;
		if( bCompPower == FALSE )	Data |= COMPOSITE_OFF;
		if( bSVideoPower == FALSE )	Data |= SVIDEO_OFF;
		ModeRegister1				= Data;
	};


	return TRUE;
};

//---------------------------------------------------------------------------
//	CADV7175A::SetSvideoPowerOn
//---------------------------------------------------------------------------
BOOL	CADV7175A::SetSVideoPowerOn( BOOL Type )
{
	BYTE Data;

	bSVideoPower = Type;


	if( bCompPower == FALSE && bSVideoPower == FALSE )
	{
		Data = 0x20;
// by oka
		if( bClosedCaption == TRUE )	Data |= CLOSED_CAPTION_ON;
		if( bCompPower == FALSE )	Data |= COMPOSITE_OFF;
		if( bSVideoPower == FALSE )	Data |= SVIDEO_OFF;
		ModeRegister1				= Data;

		ModeRegister2				= 0xc8;
	}
	else
	{
		ModeRegister2				= 0x48;

		Data = 0x20;
// by oka
		if( bClosedCaption == TRUE )	Data |= CLOSED_CAPTION_ON;
		if( bCompPower == FALSE )	Data |= COMPOSITE_OFF;
		if( bSVideoPower == FALSE )	Data |= SVIDEO_OFF;
		ModeRegister1				= Data;
	};


	return TRUE;
};

//---------------------------------------------------------------------------
//  CADV7175A::SetCgmsType
//---------------------------------------------------------------------------
BOOL    CADV7175A::SetCgmsType( CGMSTYPE Type, CVideoPropSet VProp )
{
	return TRUE;
};
// by oka
//---------------------------------------------------------------------------
//	CADV7175A::SetClosedCaptionOn
//---------------------------------------------------------------------------
BOOL	CADV7175A::SetClosedCaptionOn( BOOL fswitch )
{
	if (fswitch)
	{
		bClosedCaption = TRUE;
	} else {
		bClosedCaption = FALSE;
	}
	BYTE Data;
	Data = 0x20;
	if( bClosedCaption == TRUE )	Data |= CLOSED_CAPTION_ON;
	if( bCompPower == FALSE )	Data |= COMPOSITE_OFF;
	if( bSVideoPower == FALSE )	Data |= SVIDEO_OFF;
	ModeRegister1				= Data;
	return TRUE;
}

//---------------------------------------------------------------------------
//	CADV7175A::SetClosedCaption
//---------------------------------------------------------------------------
BOOL	CADV7175A::SetClosedCaptionData( DWORD Data )
{
	ClosedCapData0 =   (BYTE)((Data & 0x0000FF00) >> 8);
	ClosedCapData1 =   (BYTE)(Data &  0x000000FF);
	return TRUE;
}


//***************************************************************************
//  CADV7170 control interfaces
//***************************************************************************
//---------------------------------------------------------------------------
//	CADV7170 constructor
//---------------------------------------------------------------------------
CADV7170::CADV7170(void)
{
};

//---------------------------------------------------------------------------
//  CADV7170::Init
//---------------------------------------------------------------------------
void    CADV7170::Init(IKernelService *pKernelObj, CIOIF *pioif )
{
	ModeRegister0.Init( 			pKernelObj, pioif, 0x00  );
	ModeRegister1.Init( 			pKernelObj, pioif, 0x01  );
    ModeRegister2.Init(             pKernelObj, pioif, 0x02  );
    ModeRegister3.Init(             pKernelObj, pioif, 0x03  );
    ModeRegister4.Init(             pKernelObj, pioif, 0x04  );
    TimingRegister0.Init(           pKernelObj, pioif, 0x07  );
    TimingRegister1.Init(           pKernelObj, pioif, 0x08  );
    SubCarrierFreqRegister0.Init(   pKernelObj, pioif, 0x09  );
    SubCarrierFreqRegister1.Init(   pKernelObj, pioif, 0x0A  );
    SubCarrierFreqRegister2.Init(   pKernelObj, pioif, 0x0B  );
    SubCarrierFreqRegister3.Init(   pKernelObj, pioif, 0x0C  );
    SubCarrierPhaseRegister.Init(   pKernelObj, pioif, 0x0D  );
    ClosedCapExData0.Init(          pKernelObj, pioif, 0x0E  );
    ClosedCapExData1.Init(          pKernelObj, pioif, 0x0F  );
    ClosedCapData0.Init(            pKernelObj, pioif, 0x10  );
    ClosedCapData1.Init(            pKernelObj, pioif, 0x11  );
    NTSCTTXRegister0.Init(          pKernelObj, pioif, 0x12  );
    NTSCTTXRegister1.Init(          pKernelObj, pioif, 0x13  );
    NTSCTTXRegister2.Init(          pKernelObj, pioif, 0x14  );
    NTSCTTXRegister3.Init(          pKernelObj, pioif, 0x15  );
    CgmsWssRegister0.Init(          pKernelObj, pioif, 0x16  );
    CgmsWssRegister1.Init(          pKernelObj, pioif, 0x17  );
    CgmsWssRegister2.Init(          pKernelObj, pioif, 0x18  );
    TTXRQPositionRegister.Init(     pKernelObj, pioif, 0x19  );

    for( int i = 0 ; i < 18; i ++ )
        MacrovisionRegister[i].Init(    pKernelObj, pioif, (BYTE)(0x1E+i)  );

	bCompPower = FALSE;		// Composit Power off
	bSVideoPower = FALSE;	// s-video Power off
// by oka
	bClosedCaption = FALSE; // Closed Caption off

	m_apstype = ApsType_Off;
	m_OutputType = OUTPUT_NTSC;
	m_cgmstype = CgmsType_Off;      // CGMS type setting
};

//---------------------------------------------------------------------------
//  CADV7170::SetNTSC
//---------------------------------------------------------------------------
BOOL    CADV7170::SetNTSC( void )
{
	BYTE Data;
	
    ModeRegister0               = 0x70;         //0x10;

	Data = 0x00;
// by oka
	if( bClosedCaption == TRUE )	Data |= CLOSED_CAPTION_ON;
	if( bCompPower == FALSE )	Data |= COMPOSITE_OFF;
	if( bSVideoPower == FALSE )	Data |= SVIDEO_OFF;
	ModeRegister1				= Data;

	if( bCompPower == FALSE && bSVideoPower == FALSE )
		ModeRegister2				= 0x48;
	else
		ModeRegister2				= 0x08;

	ModeRegister3				= 0x04;
    ModeRegister4               = 0x06;         //0x12;

	TimingRegister0				= 0x08;
	TimingRegister1				= 0x00;

	SubCarrierFreqRegister0		= 0x16;
	SubCarrierFreqRegister1		= 0x7c;
	SubCarrierFreqRegister2		= 0xf0;
	SubCarrierFreqRegister3		= 0x21;
	SubCarrierPhaseRegister		= 0x00;
	ClosedCapExData0			= 0x00;
	ClosedCapExData1			= 0x00;
	ClosedCapData0				= 0x00;
	ClosedCapData1				= 0x00;

	NTSCTTXRegister0			= 0x00;
	NTSCTTXRegister1			= 0x00;
	NTSCTTXRegister2			= 0x00;
	NTSCTTXRegister3			= 0x00;
	TTXRQPositionRegister		= 0x00;

	if( m_OutputType != OUTPUT_NTSC )
		SetMacroVision( m_apstype );

	m_OutputType = OUTPUT_NTSC;

	return TRUE;
};

//---------------------------------------------------------------------------
//  CADV7170::SetPAL
//---------------------------------------------------------------------------
BOOL    CADV7170::SetPAL( DWORD Type )
{
	BYTE Data;
	
	switch( Type )
	{
		case 0:			// PAL B,D,G,H,I
            ModeRegister0               = 0x71;     //0x11;
			SubCarrierFreqRegister0		= 0xcb;
			SubCarrierFreqRegister1		= 0x8a;
			SubCarrierFreqRegister2		= 0x09;
			SubCarrierFreqRegister3		= 0x2a;
			SubCarrierPhaseRegister		= 0x00;
			break;

		case 1:			// PAL M
            ModeRegister0               = 0x72;     //0x12;
			SubCarrierFreqRegister0		= 0xa3;
			SubCarrierFreqRegister1		= 0xef;
			SubCarrierFreqRegister2		= 0xe6;
			SubCarrierFreqRegister3		= 0x21;
			SubCarrierPhaseRegister		= 0x00;
			break;

		default:
			DBG_BREAK();
			return FALSE;
	};

	Data = 0x00;
// by oka
	if( bClosedCaption == TRUE )	Data |= CLOSED_CAPTION_ON;
	if( bCompPower == FALSE )	Data |= COMPOSITE_OFF;
	if( bSVideoPower == FALSE )	Data |= SVIDEO_OFF;
	ModeRegister1				= Data;

	if( bCompPower == FALSE && bSVideoPower == FALSE )
		ModeRegister2				= 0x48;
	else
        ModeRegister2               = 0x08;

    ModeRegister3               = 0x00;     //0x04;
    ModeRegister4               = 0x06;     //0x12;

	TimingRegister0				= 0x08;
	TimingRegister1				= 0x00;

	ClosedCapExData0			= 0x00;
	ClosedCapExData1			= 0x00;
	ClosedCapData0				= 0x00;
	ClosedCapData1				= 0x00;

	NTSCTTXRegister0			= 0x00;
	NTSCTTXRegister1			= 0x00;
	NTSCTTXRegister2			= 0x00;
	NTSCTTXRegister3			= 0x00;
	TTXRQPositionRegister		= 0x00;

	if( m_OutputType != OUTPUT_PAL )
		SetMacroVision( m_apstype );

	m_OutputType = OUTPUT_PAL;

	return TRUE;
};


//---------------------------------------------------------------------------
//  CADV7170::SetMacroVision
//---------------------------------------------------------------------------
BOOL    CADV7170::SetMacroVision( APSTYPE Type )
{
	int i;
	
	switch( m_OutputType )
	{
		case OUTPUT_NTSC:

			switch( Type )
			{
				case ApsType_Off:
					MacrovisionRegister[0] = 0x40;	// 0xc0;
					for( i = 1 ; i < 18; i ++ )
						MacrovisionRegister[i] = 0x00;
					break;
				case ApsType_1:
					MacrovisionRegister[ 0] = 0x76;	// 0xf6
					MacrovisionRegister[ 1] = 0x07;
					MacrovisionRegister[ 2] = 0x95;
					MacrovisionRegister[ 3] = 0x50;
					MacrovisionRegister[ 4] = 0xce;
					MacrovisionRegister[ 5] = 0xb6;
					MacrovisionRegister[ 6] = 0x91;
					MacrovisionRegister[ 7] = 0xf8;
					MacrovisionRegister[ 8] = 0x1f;
					MacrovisionRegister[ 9] = 0x00;	// 0x0c;
					MacrovisionRegister[10] = 0xcc;	// 0xc0;
					MacrovisionRegister[11] = 0x03;
					MacrovisionRegister[12] = 0x00;
					MacrovisionRegister[13] = 0x58;
					MacrovisionRegister[14] = 0x85;
					MacrovisionRegister[15] = 0xca;
					MacrovisionRegister[16] = 0xff;
                    MacrovisionRegister[17] = 0x00;
					break;

				case ApsType_2:
					MacrovisionRegister[ 0] = 0x7e;
					MacrovisionRegister[ 1] = 0x07;
					MacrovisionRegister[ 2] = 0x95;
					MacrovisionRegister[ 3] = 0x50;
					MacrovisionRegister[ 4] = 0xce;
					MacrovisionRegister[ 5] = 0xb6;
					MacrovisionRegister[ 6] = 0x91;
					MacrovisionRegister[ 7] = 0xf8;
					MacrovisionRegister[ 8] = 0x1f;
					MacrovisionRegister[ 9] = 0x00;	// 0x0c;
					MacrovisionRegister[10] = 0xcc;	// 0xc0;
					MacrovisionRegister[11] = 0x03;
					MacrovisionRegister[12] = 0x00;
					MacrovisionRegister[13] = 0x58;
					MacrovisionRegister[14] = 0x85;
					MacrovisionRegister[15] = 0xca;
					MacrovisionRegister[16] = 0xff;
                    MacrovisionRegister[17] = 0x00;
					break;

				case ApsType_3:
					MacrovisionRegister[ 0] = 0xfe;
					MacrovisionRegister[ 1] = 0x45;
					MacrovisionRegister[ 2] = 0x85;
					MacrovisionRegister[ 3] = 0x54;
					MacrovisionRegister[ 4] = 0xeb;
					MacrovisionRegister[ 5] = 0xb6;
					MacrovisionRegister[ 6] = 0x91;
					MacrovisionRegister[ 7] = 0xf8;
					MacrovisionRegister[ 8] = 0x1f;
					MacrovisionRegister[ 9] = 0x00;	// 0x0c;
					MacrovisionRegister[10] = 0xcc;	// 0xc0;
					MacrovisionRegister[11] = 0x03;
					MacrovisionRegister[12] = 0x00;
					MacrovisionRegister[13] = 0x58;
					MacrovisionRegister[14] = 0x85;
					MacrovisionRegister[15] = 0xca;
					MacrovisionRegister[16] = 0xff;
                    MacrovisionRegister[17] = 0x00;
					break;

				default:
					return FALSE;
			};
			break;

		case OUTPUT_PAL:

			switch( Type )
			{
				case ApsType_Off:
					MacrovisionRegister[ 0] = 0x80;
					MacrovisionRegister[ 1] = 0x16;
					MacrovisionRegister[ 2] = 0xaa;
					MacrovisionRegister[ 3] = 0x61;
					MacrovisionRegister[ 4] = 0x05;
					MacrovisionRegister[ 5] = 0xd7;
					MacrovisionRegister[ 6] = 0x53;
					MacrovisionRegister[ 7] = 0xfe;
					MacrovisionRegister[ 8] = 0x03;
					MacrovisionRegister[ 9] = 0xaa;
					MacrovisionRegister[10] = 0x80;
					MacrovisionRegister[11] = 0xbf;
					MacrovisionRegister[12] = 0x1f;
					MacrovisionRegister[13] = 0x18;
					MacrovisionRegister[14] = 0x04;
					MacrovisionRegister[15] = 0x7a;
					MacrovisionRegister[16] = 0x55;
                    MacrovisionRegister[17] = 0x00;
					break;

				case ApsType_1:
				case ApsType_2:
				case ApsType_3:
					MacrovisionRegister[ 0] = 0xb6;
					MacrovisionRegister[ 1] = 0x16;		// 0x26; // 0x16;
					MacrovisionRegister[ 2] = 0xaa;
					MacrovisionRegister[ 3] = 0x61;		// 0x62; // 0x61;
					MacrovisionRegister[ 4] = 0x05;
					MacrovisionRegister[ 5] = 0xd7;
					MacrovisionRegister[ 6] = 0x53;
					MacrovisionRegister[ 7] = 0xfe;	// 0xfc;
					MacrovisionRegister[ 8] = 0x03;
					MacrovisionRegister[ 9] = 0xaa;
					MacrovisionRegister[10] = 0x80;
					MacrovisionRegister[11] = 0xbf;
					MacrovisionRegister[12] = 0x1f;
					MacrovisionRegister[13] = 0x18;
					MacrovisionRegister[14] = 0x04;
					MacrovisionRegister[15] = 0x7a;
					MacrovisionRegister[16] = 0x55;
                    MacrovisionRegister[17] = 0x00;
					break;

				default:
					return FALSE;
			};
			break;

		default:
			return FALSE;
	};

	m_apstype = Type;
	return TRUE;
};

//---------------------------------------------------------------------------
//  CADV7170::SetCompPowerOn
//---------------------------------------------------------------------------
BOOL    CADV7170::SetCompPowerOn( BOOL Type )
{
	BYTE Data;

	bCompPower = Type;

	if( bCompPower == FALSE && bSVideoPower == FALSE )
	{
		Data = 0x00;
		// by oka
		if( bClosedCaption == TRUE )	Data |= CLOSED_CAPTION_ON;
		if( bCompPower == FALSE )	Data |= COMPOSITE_OFF;
		if( bSVideoPower == FALSE )	Data |= SVIDEO_OFF;
		ModeRegister1				= Data;

		ModeRegister2				= 0x48;
	}
	else
	{
		ModeRegister2				= 0x08;

		Data = 0x00;
		// by oka
		if( bClosedCaption == TRUE )	Data |= CLOSED_CAPTION_ON;
		if( bCompPower == FALSE )	Data |= COMPOSITE_OFF;
		if( bSVideoPower == FALSE )	Data |= SVIDEO_OFF;
		ModeRegister1				= Data;
	};

	Data = ModeRegister4;
    if( (bCompPower==TRUE)||(bSVideoPower==TRUE) ){
		Data &= 0xBF;
		ModeRegister4 = Data;
	}else{
		Data |= 0x40;
		ModeRegister4 = Data;
	}

	return TRUE;
};

//---------------------------------------------------------------------------
//  CADV7170::SetSvideoPowerOn
//---------------------------------------------------------------------------
BOOL    CADV7170::SetSVideoPowerOn( BOOL Type )
{
	BYTE Data;

	bSVideoPower = Type;


	if( bCompPower == FALSE && bSVideoPower == FALSE )
	{
		Data = 0x00;
		// by oka
		if( bClosedCaption == TRUE )	Data |= CLOSED_CAPTION_ON;
		if( bCompPower == FALSE )	Data |= COMPOSITE_OFF;
		if( bSVideoPower == FALSE )	Data |= SVIDEO_OFF;
		ModeRegister1				= Data;

		ModeRegister2				= 0x48;
	}
	else
	{
		ModeRegister2				= 0x08;

		Data = 0x00;
		// by oka
		if( bClosedCaption == TRUE )	Data |= CLOSED_CAPTION_ON;
		if( bCompPower == FALSE )	Data |= COMPOSITE_OFF;
		if( bSVideoPower == FALSE )	Data |= SVIDEO_OFF;
		ModeRegister1				= Data;
	};

	Data = ModeRegister4;
    if( (bCompPower==TRUE)||(bSVideoPower==TRUE) ){
		Data &= 0xBF;
		ModeRegister4 = Data;
	}else{
		Data |= 0x40;
		ModeRegister4 = Data;
	}

	return TRUE;
};

//---------------------------------------------------------------------------
//  CADV7170::SetCgmsType
//---------------------------------------------------------------------------
BOOL    CADV7170::SetCgmsType( CGMSTYPE Type, CVideoPropSet VProp )
{
    BYTE    word0, word1, word2, word3;
    word0 = word1 = word2 = word3 = 0x00;

	switch( m_OutputType )
	{
		case OUTPUT_NTSC:
            // WORD-0
            switch( VProp.m_AspectRatio ){
                case  Aspect_04_03:
                    word0 &= 0xFE;
                    break;
                case  Aspect_16_09:
                    word0 |= 0x01;
                    break;
            }

            switch( VProp.m_DisplayMode ){
                case  Display_Original:
                case  Display_PanScan:
                    word0 &= 0xFD;
                    break;
                case  Display_LetterBox:
                    word0 |= 0x02;
                    break;
            }

            // WORD-1
            word1 = 0x00;

            // WORD-2
            switch( Type ){
                case CgmsType_Off:
                    word2 &= 0xFC;
                    break;
                case CgmsType_1:
                    word2 &= 0xFC;
                    word2 |= 0x01;
                    break;
                case CgmsType_On:
                    word2 |= 0x03;
                    break;
            }
            switch( m_apstype ){
                case ApsType_Off:
                    word2 &= 0xF3;
                    break;
				case ApsType_1:
                    word2 &= 0xF3;
                    word2 |= 0x08;
                    break;
				case ApsType_2:
                    word2 &= 0xF3;
                    word2 |= 0x04;
                    break;
				case ApsType_3:
                    word2 |= 0x0C;
                    break;
            }

            CgmsWssRegister0 = 0x7F;            // NTSC(CGMS-A)
            CgmsWssRegister1 = (BYTE)( ( word2>>2 )| 0xC0 );
            CgmsWssRegister2 = (BYTE)( word0|word1|( word2<<6 ) );
            break;

		case OUTPUT_PAL:
            // Group-1
            switch( VProp.m_AspectRatio ){
                case  Aspect_04_03:
                    word0 |= 0x08;
                    break;
                case  Aspect_16_09:
                    word0 = 0x07;
                    break;
            }

            switch( VProp.m_DisplayMode ){
                case  Display_Original:
                case  Display_PanScan:
                    word0 &= 0xF8;
                    break;
                case  Display_LetterBox:
                    word0 |= 0x03;
                    break;
            }

            // Group-2
            switch( VProp.m_FilmCamera ){
                case  Source_Film:
                    word1 |= 0x01;
                    break;
                case  Source_Camera:
                    word1 &= 0xFE;
                    break;
            }

            // Group-4
             switch( Type ){
                case CgmsType_Off:
                    word3 = 0x00;
                    break;
                case CgmsType_1:
                    word3 = 0x02;
                    break;
                case CgmsType_On:
                    word3 = 0x06;
                    break;
            }
            CgmsWssRegister0 = 0x80;                    // PAL(WSS)
            CgmsWssRegister1 = (BYTE)( word2|( word3<<3 ) );
            CgmsWssRegister2 = (BYTE)( word0|( word1<<4 ) );
			break;

		default:
			return FALSE;
	};

	m_cgmstype = Type;
	return TRUE;
};

//---------------------------------------------------------------------------
//	CADV7170::SetClosedCaptionOn
//---------------------------------------------------------------------------
BOOL	CADV7170::SetClosedCaptionOn( BOOL fswitch )
{
	if (fswitch)
	{
		bClosedCaption = TRUE;
	} else {
		bClosedCaption = FALSE;
	}
	BYTE Data;
	Data = 0x00;
	// by oka
	if( bClosedCaption == TRUE )	Data |= CLOSED_CAPTION_ON;
	if( bCompPower == FALSE )	Data |= COMPOSITE_OFF;
	if( bSVideoPower == FALSE )	Data |= SVIDEO_OFF;
	ModeRegister1				= Data;
	return TRUE;
}
//---------------------------------------------------------------------------
//	CADV7170::SetClosedCaptionData
//---------------------------------------------------------------------------
BOOL	CADV7170::SetClosedCaptionData( DWORD Data )
{

	ClosedCapData0 =   (BYTE)((Data & 0x0000FF00) >> 8);
	ClosedCapData1 =   (BYTE)(Data &  0x000000FF);

	return TRUE;

}



//***************************************************************************
//	End of 
//***************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\stllapi.h ===
#ifndef __STLLAPI_H
#define __STLLAPI_H
//----------------------------------------------------------------------------
// STLLAPI.H
//----------------------------------------------------------------------------
// Description : small description of the goal of the module
//----------------------------------------------------------------------------
// Copyright SGS Thomson Microelectronics  !  Version alpha  !  Jan 1st, 1995
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                               Include files
//----------------------------------------------------------------------------
#include "stdefs.h"

//----------------------------------------------------------------------------
//                               Exported Types
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Exported Variables
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Exported Constants
//----------------------------------------------------------------------------
#define QUANT_TAB_SIZE		64

//---- Definition of the STi35xxx memory partitioning
#define NB_ROW_OF_MB 22	// Number of Rows of Macro blocks for B
												// pictures when optimmization is used
#ifdef STi3520A
	#define BUF_FULL 0x480// bit buffer occupies 0x480 * 256 bytes (1.75 Mbits)
#else
	#define BUF_FULL 0x380// bit buffer occupies 0x380 * 256 bytes (1.75 Mbits)
#endif

//---- PAL
#define PSZ_PAL 0x0980  // Picture size = 720*576*1.5 / 256 = 0x97E
#define BUFF_A_PAL BUF_FULL+1   //
#define BUFF_B_PAL (BUFF_A_PAL+PSZ_PAL)
#define BUFF_C_PAL (BUFF_B_PAL+PSZ_PAL)

//---- NTSC
#define PSZ_NTSC 0x07F0
#define BUFF_A_NTSC BUF_FULL+1
#define BUFF_B_NTSC (BUFF_A_NTSC+PSZ_NTSC)
#define BUFF_C_NTSC (BUFF_B_NTSC+PSZ_NTSC)

//---- OSD
#define OSD_START (BUFF_C + ((NB_ROW_OF_MB*3)/2))*32L

#define FORWARD_PRED 	0
#define	BACKWARD_PRED	1

/************************************/
/*  definition of main start codes  */
/************************************/
#define PICT	  0x0000
#define USER	  0xB200
#define SEQ	   	0xB300
#define SEQ_ERR	0xB400
#define EXT		  0xB500
#define SEQ_END 0xB700
#define GOP	   	0xB800

/************************************/
/*   definition of extension codes  */
/************************************/
#define SEQ_EXT	 	0x10
#define SEQ_DISP 	0x20
#define QUANT_EXT 0x30
#define SEQ_SCAL 	0x50
#define PICT_PSV 	0x70
#define PICT_COD 	0x80
#define PICT_SCAL 0x90

/***********************************************/
/*   definition of states of FistVsyncAfterVbv */
/***********************************************/
// FistVsyncAfterVbv is a 3 state variable
// before vbv                      FistVsyncAfterVbv = NOT_YET_VBV
// between vbv and following vsync FistVsyncAfterVbv = NOT_YET_VST
// after vsync following vbv       FistVsyncAfterVbv = PAST_VBV_AND_VST
#define NOT_YET_VBV	 	   0
#define NOT_YET_VST	 	   1
#define PAST_VBV_AND_VST 2

//----------------------------------------------------------------------------
//                             Exported Functions
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// One line function description (same as in .C)
//----------------------------------------------------------------------------
// In     :
// Out    :
// InOut  :
// Global :
// Return :
//----------------------------------------------------------------------------

//---- STINIT
VOID VideoInitVar(PVIDEO pVideo, U16 StreamType);
U16 VideoTestReg(PVIDEO pVideo);
U16 VideoTestMem(PVIDEO pVideo);
U16 VideoTestInt(PVIDEO pVideo);
VOID VideoReset35XX(PVIDEO pVideo, U16 StreamType);

//---- STISR
BOOLEAN VideoVideoInt(PVIDEO pVideo);

//---- STDISP
VOID VideoSetPictureSize(PVIDEO pVideo);
VOID VideoDisplayCtrl(PVIDEO pVideo);

//---- STPIPE
VOID VideoSetRecons(PVIDEO pVideo);
VOID VideoChooseField(PVIDEO pVideo);
VOID VideoVsyncRout(PVIDEO pVideo);

//---- STHEAD
VOID VideoUser(PVIDEO pVideo);
VOID VideoPictExtensionHeader(PVIDEO pVideo);
VOID VideoSequenceHeader(PVIDEO pVideo);
VOID VideoExtensionHeader(PVIDEO pVideo);
VOID VideoGopHeader(PVIDEO pVideo);
VOID VideoPictureHeader(PVIDEO pVideo);

//****************************************
// NEW : Very Low Level Routines
//****************************************
VOID VideoSetBBStart(PVIDEO pVideo, U16);
U16  VideoGetBBL(VOID);
VOID VideoSetBBStop(U16);
VOID VideoSetBBThresh(U16);

VOID VideoSetABStart( U16);
U16  VideoGetABL(VOID);
VOID VideoSetABStop(U16);
VOID VideoSetABThresh(U16);

U16  VideoBlockMove(PVIDEO pVideo, U32 SrcAddress, U32 DestAddress, U16 Size);
VOID VideoStartBlockMove(PVIDEO pVideo, U32 SrcAddress, U32 DestAddress, U32 Size);
VOID VideoCommandSkip(PVIDEO pVideo, U16 Nbpicture);
VOID VideoSetSRC(PVIDEO pVideo, U16 SrceSize, U16 DestSize);
VOID VideoLoadQuantTables(PVIDEO pVideo, BOOLEAN Intra, U8 * Table);

//**************************
// CMD , Write
//**************************
VOID VideoLaunchHeadSearch(PVIDEO pVideo);

//**************************
// CMD , Read
//**************************
U32 VideoReadCDCount(PVIDEO pVideo);
U32 VideoReadSCDCount(PVIDEO pVideo);

//**************************
// CTL register Routines
//**************************
VOID VideoEnableDecoding(PVIDEO pVideo, BOOLEAN OnOff);
VOID VideoEnableErrConc(PVIDEO pVideo, BOOLEAN OnOff);
VOID VideoPipeReset(PVIDEO pVideo);
VOID VideoSoftReset(PVIDEO pVideo );
VOID VideoEnableInterfaces(PVIDEO pVideo, BOOLEAN OnOff);
VOID VideoPreventOvf(PVIDEO pVideo, BOOLEAN OnOff);
VOID VideoSetHalfRes(PVIDEO pVideo);
VOID VideoSetFullRes(PVIDEO pVideo);
VOID VideoSelectMpeg2(PVIDEO pVideo, BOOLEAN OnOff);
VOID VideoSelect8M(PVIDEO pVideo, BOOLEAN OnOff);

//**************************
// DCF registers Routines
//**************************
VOID VideoOsdOn(PVIDEO pVideo);
VOID VideoOsdOff(PVIDEO pVideo);
VOID VideoSwitchSRC(PVIDEO pVideo);
VOID VideoSRCOn(PVIDEO pVideo);
VOID VideoSRCOff(PVIDEO pVideo);

//**************************
// DFA, DFW, DFS registers Routines
//**************************
VOID VideoInitDecodeParam(U16 dfa, U16 dfs, U16 dfw);
//**************************
// DFP registers Routines
//**************************
VOID VideoSetDFP(U16 dfp);
VOID VideoEnableDisplay(PVIDEO pVideo);
VOID VideoDisableDisplay(PVIDEO pVideo);

//**************************
// FFP, BFP, RFP registers Routines
//**************************
VOID VideoStoreRFBBuf(PVIDEO pVideo, U16 rfp, U16 ffp, U16 bfp);

//**************************
// GCF1 register Routines
//**************************
VOID VideoSetDramRefresh(PVIDEO pVideo, U16);
VOID VideoSelect20M(PVIDEO pVideo, BOOLEAN OnOff);
VOID VideoSetDFA(PVIDEO pVideo, U16);
//**************************
// GCF2 register Routines
//**************************
VOID VideoSelectSdram(VOID);
VOID VideoSelectHdram(VOID);
VOID VideoInitDisplayParam(U16 xfa, U16 xfs, U16 xfw);

//**************************
// HDF register Routines
//**************************
VOID VideoReadHeaderDataFifo(PVIDEO pVideo);

//**************************
// INS1,2 register Routines
//**************************
VOID VideoComputeInst(PVIDEO pVideo);
VOID VideoStoreINS(PVIDEO pVideo);
VOID VideoWaitDec(PVIDEO pVideo);
//**************************
// ITM, ITS register Routines
//**************************
VOID VideoMaskInt(PVIDEO pVideo);
VOID VideoRestoreInt(PVIDEO pVideo);
VOID VideoSetMask(U16 mask);
VOID VideoResetMask(U16 mask);
//**************************
// DRAM I/O
//**************************
VOID VideoSetMWP(U32);
VOID VideoSetMRP(U32);
BOOLEAN VideoMemWriteFifoEmpty(VOID);
BOOLEAN VideoMemReadFifoFull(VOID);
BOOLEAN VideoHeaderFifoEmpty(VOID);
BOOLEAN VideoBlockMoveIdle(VOID);
//**************************
// OBP / OTP init
//**************************
VOID VideoInitOEP(PVIDEO pVideo, U32 point_oep);

//**************************
// PSV register
//**************************
VOID VideoSetPSV(PVIDEO pVideo);

//**************************
// XDO, XDS, YDO, YDS
//**************************
VOID VideoSetVideoWindow(PVIDEO, U16 a, U16 b, U16 c, U16 d);
VOID VideoInitXY(PVIDEO pVideo);
VOID SetXY(PVIDEO pVideo, U16 xds, U16 yds);

//**************************
// PLL initialization
//**************************
VOID VideoInitPLL(VOID);
//**************************
// PES initialization
//**************************
VOID VideoInitPesParser(U16 StreamType);
U32 VideoReadPTS(VOID );
BOOLEAN VideoIsValidPTS(VOID );

BOOL IsChipSTi3520(VOID);

//------------------------------- End of File --------------------------------
#endif // #ifndef __STLLAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\sgsorig\stpipe.c ===
//----------------------------------------------------------------------------
// STPIPE.C
//----------------------------------------------------------------------------
// Description : Pipeline Control routines
//----------------------------------------------------------------------------
// Copyright SGS Thomson Microelectronics  !  Version alpha  !  Jan 1st, 1995
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                             Include files
//----------------------------------------------------------------------------
#include "stdefs.h"
#include "common.h"
#include "STllapi.h"
#include "debug.h"
#ifdef STi3520A
	#include "STi3520A.h"
#else
	#include "STi3520.h"
#endif

//----------------------------------------------------------------------------
//                   GLOBAL Variables (avoid as possible)
//----------------------------------------------------------------------------
extern U8 Sequence;

//----------------------------------------------------------------------------
//                            Private Constants
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                              Private Types
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                     Private GLOBAL Variables (static)
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//                    Functions (statics one are private)
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// Set next reconstructed,forward and backward frame pointer
//----------------------------------------------------------------------------
VOID VideoSetRecons(PVIDEO pVideo)
{
	/************************  I or P pictures ****************************/
	if ( pVideo->pDecodedPict->pict_type != 0x3 )
	{
		if ( pVideo->frameStoreAttr == FORWARD_PRED )   /* pVideo->frameStoreAttr is the prediction
									    * attribute of BUFF_A */
		{
			if ( pVideo->fieldMode < 2 )
				pVideo->frameStoreAttr = BACKWARD_PRED;
			/* Change the prediction attribute */

			if ( ( pVideo->fieldMode == 0 ) || ( pVideo->fieldMode == 2 ) )
				// frame picture or first field of 2 field pictures
				VideoStoreRFBBuf ( pVideo, pVideo->BufferA, pVideo->BufferB, pVideo->BufferB );
			// rfp = A, ffp = bfp = B
			else					   // second field of 2 field
										 // pictures
				VideoStoreRFBBuf (pVideo, pVideo->BufferA, pVideo->BufferB, pVideo->BufferA );
			// rfp = A, ffp = B, bfp = A
		}
		else
		{
			if ( pVideo->fieldMode < 2 )	   // frame picture or 2 field
				pVideo->frameStoreAttr = FORWARD_PRED;/* Change the prediction */

			if ( ( pVideo->fieldMode == 0 ) || ( pVideo->fieldMode == 2 ) )
				// frame picture or first field of 2 field pictures
				VideoStoreRFBBuf (pVideo, pVideo->BufferB, pVideo->BufferA, pVideo->BufferA );
			// rfp = B, ffp = bfp = A
			else					   // seond field of 2 field
									   // pictures
				VideoStoreRFBBuf (pVideo, pVideo->BufferB, pVideo->BufferA, pVideo->BufferB );
			// rfp = B, ffp = A, bfp = B
		}
	}

	/************************  B pictures ****************************/
	else
	{								   /* B picture */
		if ( pVideo->frameStoreAttr == FORWARD_PRED )
			VideoStoreRFBBuf (pVideo, pVideo->BufferC, pVideo->BufferA, pVideo->BufferB );
		else
			VideoStoreRFBBuf ( pVideo, pVideo->BufferC, pVideo->BufferB, pVideo->BufferA );
	}


	/*********** common for all kind of pictures  *********************/
	/* test if displayed frame = reconstructed frame */
	if ( ( pVideo->pCurrDisplay->buffer == pVideo->pDecodedPict->buffer ) && ( pVideo->currPictCount >= 4 ) && !pVideo->fieldMode )
		pVideo->NextInstr.Ovw = 1;/* overwrite mode */
	else
		pVideo->NextInstr.Ovw = 0;/* not overwite mode */
}


//----------------------------------------------------------------------------
// Store reconstructed,forward and backward frame pointers  	                 */
//----------------------------------------------------------------------------
void VideoStoreRFBBuf ( PVIDEO pVideo, U16 rfp, U16 ffp, U16 bfp )
{
	VideoWrite ( RFP, ( rfp >> 8 ) );
	/* Address where to decode the next frame */
	VideoWrite ( RFP + 1, ( rfp & 0xFF ) );
	pVideo->pDecodedPict->buffer = rfp;
	VideoWrite ( FFP, ( ffp >> 8 ) );
	/* Used by P picture */
	VideoWrite ( FFP + 1, ( ffp & 0xFF ) );
	VideoWrite ( BFP, ( bfp >> 8 ) );
	/* Used by P picture in case of dual prime */
	VideoWrite ( BFP + 1, ( bfp & 0xFF ) );
}

//----------------------------------------------------------------------------
// Routine called on each VSYNC occurence
//----------------------------------------------------------------------------
VOID VideoVsyncRout(PVIDEO pVideo)
{
	pVideo->VsyncInterrupt = TRUE;
	if ( pVideo->VideoState == VIDEO_START_UP )
	{
		if ((VideoGetBBL()) > 2)
		{
			pVideo->NextInstr.Exe = 1;
			pVideo->NextInstr.Seq = 1;
			VideoStoreINS(pVideo);  // Stores Instruction content
			pVideo->VideoState = VIDEO_WAIT_FOR_DTS;
			pVideo->ActiveState = VIDEO_WAIT_FOR_DTS;
		}
		return;
	}
#if 0
	if ( pVideo->VideoState == VIDEO_INIT )
	{
		pVideo->intMask = 0;
		return;
	}
#endif

	if ( pVideo->VideoState == VIDEO_PAUSE )
		return;

	if ( ( !pVideo->needDataInBuff ) && ( pVideo->vbvReached == 1 ) )
	{
		pVideo->VsyncNumber++;
		if ( pVideo->VsyncNumber > 4 * ( pVideo->decSlowDown + 1 ) )
		{
			VideoPipeReset (pVideo);
			// reset_3500();
			pVideo->VsyncNumber = 0;
		}
		VideoWrite ( DCF, 0 );
		VideoWrite ( DCF + 1, pVideo->currDCF );
		/*****  bit buffer level is high enough to continue normal decoding and display  ****/
		/*****  count of the number of time the current picture must be displayed        ****/
		if ( pVideo->pictDispIndex != pVideo->pCurrDisplay->nb_display_field )
			pVideo->pictDispIndex++;
		if ( pVideo->pictDispIndex >= pVideo->pCurrDisplay->nb_display_field - 1 )
		{
			// this is the time where the next INS should be stored
			// into the chip
			// We verify if the VSYNC phase (cur_field) is the same
			// than the first field
			// of the next picture to be displayed: if this is VSYNC #
			// n, the next
			// decoding will start on VSYNC # n+1 (opposite phase)
			// while the next frame
			// display will start on VSYNC # n+2 (same phase)
#ifdef STi3520A
/************* Youss R/2P buffer saving ***************************/
// If First Vsync after vbv is reached is of incorrect polarity,
// Program internal field inversion AND force first field to current
// field
// FistVsyncAfterVbv is a 3 state variable
// before vbv is reached           FistVsyncAfterVbv = NOT_YET_VBV
// between vbv and following vsync FistVsyncAfterVbv = NOT_YET_VST
// after vsync following vbv       FistVsyncAfterVbv = PAST_VBV_AND_VST
 if (pVideo->FistVsyncAfterVbv == NOT_YET_VST)
		{
		if ( pVideo->pNextDisplay->first_field != pVideo->currField )
			{
			pVideo->currField = pVideo->pNextDisplay->first_field;
			VideoWrite(VID_LSRh, 2);// field invertion mechanism.
			pVideo->InvertedField = TRUE;

		 }
		pVideo->FistVsyncAfterVbv = PAST_VBV_AND_VST;
		}
#endif
			if ( pVideo->pNextDisplay->first_field != pVideo->currField )
			{						   // this is the opposite phase
				VideoWaitDec (pVideo);		   // put decoder in wait mode
				pVideo->pictDispIndex--;		   // we must wait one field for
										 // the good phase
			}
			else
			{						   // this is the good phase for
									   // storage
				// store the next instruction that will be taken into
				// account on the next BOT VSYNC
				VideoStoreINS ( pVideo );
				if ( pVideo->VideoState == VIDEO_STEP )	/* store only one
														 * instrcution in step
														 * mode */
					pVideo->VideoState = VIDEO_PAUSE;
			}
		}

		// the current frame pointer has not been displayed enough
		// times
		// to start the decoding of the next frame
		else						   // pVideo->pictDispIndex <
			{						   // pVideo->pCurrDisplay->nb_display_fi
									   // eld - 1
			VideoWaitDec ( pVideo );			   // put decoder in Wait mode
			}


		/* pan & scan vector has to be updated on each new VSYNC */
		VideoSetPSV ( pVideo );				   // store PSV for next field and
									   // LSO for current one
	}								   // end of if(!empty)


	else
		/***  bit buffer level was not high enough to continue normal decoding *****/
		/***  decoder has been stopped during PSD interrupt. It will be re-enabled */
		/***  on the good VSYNC if the bit buffer level is high enough.         ****/
		/***  Polarity of the VSYNC on which the decoder was stopped is into empty */
	if ( pVideo->needDataInBuff == pVideo->currField )
	{
		/* This is the good VSYNC phase to restart decoding       */
		/* verification of the bit buffer level before restarting */
		/* the decoder has been stopped for at least two VSYNC    */
		S16             i;
		i = VideoGetBBL();
		if ( i >= (S16)pVideo->vbvDelay )
		{							   // BBL is high enough to restart
			// "enable decoding" bit
			DBG1('>');
			VideoEnableDecoding(pVideo, ON);
			pVideo->needDataInBuff = 0;
		}
	}
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
VOID VideoChooseField(PVIDEO pVideo)
{
// to avoid flicker with slow motion or step by step, the top field is displayed
// half of the time of the picture, and then the bottom field is displayed
	if ( ( pVideo->decSlowDown ) || ( pVideo->VideoState == VIDEO_PAUSE )||(pVideo->perFrame == TRUE ))
	{
		S16             no_flicker[2];
		U8 bfs = 0;
#ifdef STi3520A
		bfs = VideoRead(CFG_BFS)&0x3F;// To check if B frame optimization is on
#endif
		no_flicker[0] = VideoRead ( DCF );
		no_flicker[1] = VideoRead ( DCF + 1 );
		if ( pVideo->HalfRes == FALSE )	/* full resolution
													 * picture = 2 fields */
		{
			if ( ( ( ( ( pVideo->pictDispIndex + pVideo->decSlowDown ) > 0x7fff ) || ( pVideo->pictDispIndex == 1 ) ) && ( pVideo->VideoState != VIDEO_PAUSE ) )
				 || ( ( pVideo->VideoState == VIDEO_PAUSE ) && ( !pVideo->displaySecondField ) ) )
			{
				/* display first field in two cases */
				/* - first half of the pVideo->decSlowDownrisation time */
				/* - first step() pVideo->currCommand */
				if ( pVideo->pCurrDisplay->first_field == TOP )
				{					   /* first field = TOP field */
					if(!bfs)
							VideoWrite ( DCF, 0x4 );//FRZ set for STi3520A
					else
							VideoWrite ( DCF, 0x15 );//FRZ set for STi3520A
					VideoWrite ( DCF + 1, no_flicker[1] | 0x80 );
				}
				else
				{					   /* first field = BOT field */
					if(!bfs)
							VideoWrite ( DCF, 0x5 );
					else
							VideoWrite ( DCF, 0x14 );//FRZ set for STi3520A
					VideoWrite ( DCF + 1, no_flicker[1] | 0x80 );
				}
			}
			else
			{
				/* display second field in two cases */
				/* - second half of the pVideo->decSlowDownrisation time */
				/* - second step() pVideo->currCommand */
				if ( pVideo->pCurrDisplay->first_field == TOP )
				{
					if(!bfs)
							VideoWrite ( DCF, 0x5);
					else
							VideoWrite ( DCF, 0x15 );//FRZ set for STi3520A
					VideoWrite ( DCF + 1, no_flicker[1] | 0x80 );
				}
				else
				{
					if(!bfs)
							VideoWrite ( DCF, 0x4);
					else
							VideoWrite ( DCF, 0x14 );//FRZ set for STi3520A
					VideoWrite ( DCF + 1, no_flicker[1] | 0x80 );
				}
			}
		}
	}
}

//------------------------------- End of File --------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\tecra\clibbuff.cpp ===
/*
@NXCuobt@iHALnjNX
@iNP2)@Sachiko Yasukawa
*/
#include "stdafx.h"

#include "includes.h"
#include "classlib.h"

CClassLibBuffer::CClassLibBuffer( void )
{
	m_pNext = NULL;
	m_pStream = NULL;
	m_pMPEGBoardBuffer = NULL;
	m_fEnd = FALSE;
};

CClassLibBuffer::CClassLibBuffer(IMBoardListItem *pBuffer, CBaseStream *pStream, DWORD PageNum)
{
	m_pNext = NULL;
	m_PageNum = PageNum;
	m_pMPEGBoardBuffer = (IMPEGBuffer *)pBuffer;
	m_pStream = pStream;
	m_fEnd = FALSE;
};

CClassLibBuffer::CClassLibBuffer(IMBoardListItem *pBuffer, CBaseStream *pStream, DWORD PageNum, DWORD Size, DWORD Add, DWORD LinAdd, DWORD flag)
{
	m_pNext = NULL;
	m_PageNum = PageNum;
	m_Size = Size;
	m_Add = (UCHAR *)Add;
	m_LinAdd = (UCHAR *)LinAdd;
	m_flag = flag;
	m_pMPEGBoardBuffer = (IMPEGBuffer *)pBuffer;
	m_pStream = pStream;
	m_fEnd = FALSE;
};

void CClassLibBuffer::SetParam(IMBoardListItem *pBuffer, CBaseStream *pStream, DWORD PageNum, DWORD Size, DWORD Add, DWORD LinAdd, DWORD flag)
{
	m_pNext = NULL;
	m_PageNum = PageNum;
	m_Size = Size;
	m_Add = (UCHAR *)Add;
	m_LinAdd = (UCHAR *)LinAdd;
	m_flag = flag;
	m_pMPEGBoardBuffer = (IMPEGBuffer *)pBuffer;
	m_pStream = pStream;
	m_fEnd = FALSE;
};

//TCY
DWORD CClassLibBuffer::GetSize()
{
//	ASSERT(m_pMPEGBoardBuffer);

//	return m_pMPEGBoardBuffer->GetPageSize(m_PageNum);
//	DBG_PRINTF(("CLASSLIB: ClassLibBufSize = %u\n", m_Size));
	return m_Size;
}

//tO
DWORD CClassLibBuffer::Flags()
{
	//ASSERT(m_pMPEGBoardBuffer);

	//return m_pMPEGBoardBuffer->GetBufferFlag();
//	DBG_PRINTF(("CLASSLIB: ClassLibBufFlag = %u\n", m_flag));
	return m_flag;

}

//obt@|C^
BYTE *CClassLibBuffer::GetBuffPointer()
{
	//ASSERT(m_pMPEGBoardBuffer);

	//m_pMPEGBoardBuffer->GetPagePointer(m_PageNum, &pLinear, &pPhys);
	//return (BYTE *)pPhys;

//	DBG_PRINTF(("CLASSLIB: ClassLibBufPointer = 0x%X\n", (DWORD)m_Add));
	return m_Add;
}

//obt@|C^jAAhX
BYTE *CClassLibBuffer::GetLinBuffPointer()
{
	return m_LinAdd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\tecra\ccque.h ===
//**************************************************************************
//
//      Title   : CCQue.h
//
//      Date    : 1998.05.06    1st making
//
//      Author  : Toshiba [PCS](PSY) Hideki Yagi
//
//      Copyright 1997 Toshiba Corporation. All Rights Reserved.
//
// -------------------------------------------------------------------------
//
//      Change log :
//
//      Date       Revision                  Description
//   ------------ ---------- -----------------------------------------------
//    1998.05.06   000.0000   1st making.
//
//**************************************************************************
class   CCQueue
{
public:
        CCQueue( void );
        ~CCQueue( void );
        void                        Init( void );
        void                        put( PHW_STREAM_REQUEST_BLOCK pSrb );
        PHW_STREAM_REQUEST_BLOCK    get( void );
        BOOL                        remove( PHW_STREAM_REQUEST_BLOCK pSrb );

private:
        ULONG                       count;
        PHW_STREAM_REQUEST_BLOCK    top;
        PHW_STREAM_REQUEST_BLOCK    bottom;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\tecra\cclasslb.cpp ===
/*
@NXCuobt@iHALnjNX
@iNP2)@Sachiko Yasukawa
*/
#include "stdafx.h"

#include "includes.h"
#include "classlib.h"

CClassLibBuffer::CClassLibBuffer( void )
{
	m_pNext = NULL;
	m_pStream = NULL;
	m_pMPEGBoardBuffer = NULL;
	m_fEnd = FALSE;
};

CClassLibBuffer::CClassLibBuffer(IMBoardListItem *pBuffer, CBaseStream *pStream, DWORD PageNum)
{
	m_pNext = NULL;
	m_PageNum = PageNum;
	m_pMPEGBoardBuffer = (IMPEGBuffer *)pBuffer;
	m_pStream = pStream;
	m_fEnd = FALSE;
};

CClassLibBuffer::CClassLibBuffer(IMBoardListItem *pBuffer, CBaseStream *pStream, DWORD PageNum, DWORD Size, DWORD Add, DWORD LinAdd, DWORD flag)
{
	m_pNext = NULL;
	m_PageNum = PageNum;
	m_Size = Size;
	m_Add = (UCHAR *)Add;
	m_LinAdd = (UCHAR *)LinAdd;
	m_flag = flag;
	m_pMPEGBoardBuffer = (IMPEGBuffer *)pBuffer;
	m_pStream = pStream;
	m_fEnd = FALSE;
};

void CClassLibBuffer::SetParam(IMBoardListItem *pBuffer, CBaseStream *pStream, DWORD PageNum, DWORD Size, DWORD Add, DWORD LinAdd, DWORD flag)
{
	m_pNext = NULL;
	m_PageNum = PageNum;
	m_Size = Size;
	m_Add = (UCHAR *)Add;
	m_LinAdd = (UCHAR *)LinAdd;
	m_flag = flag;
	m_pMPEGBoardBuffer = (IMPEGBuffer *)pBuffer;
	m_pStream = pStream;
	m_fEnd = FALSE;
};

//TCY
DWORD CClassLibBuffer::GetSize()
{
//	ASSERT(m_pMPEGBoardBuffer);

//	return m_pMPEGBoardBuffer->GetPageSize(m_PageNum);
//	DBG_PRINTF(("CLASSLIB: ClassLibBufSize = %u\n", m_Size));
	return m_Size;
}

//tO
DWORD CClassLibBuffer::Flags()
{
	//ASSERT(m_pMPEGBoardBuffer);

	//return m_pMPEGBoardBuffer->GetBufferFlag();
//	DBG_PRINTF(("CLASSLIB: ClassLibBufFlag = %u\n", m_flag));
	return m_flag;

}

//obt@|C^
BYTE *CClassLibBuffer::GetBuffPointer()
{
	//ASSERT(m_pMPEGBoardBuffer);

	//m_pMPEGBoardBuffer->GetPagePointer(m_PageNum, &pLinear, &pPhys);
	//return (BYTE *)pPhys;

//	DBG_PRINTF(("CLASSLIB: ClassLibBufPointer = 0x%X\n", (DWORD)m_Add));
	return m_Add;
}

//obt@|C^jAAhX
BYTE *CClassLibBuffer::GetLinBuffPointer()
{
	return m_LinAdd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\tecra\ccque.cpp ===
//**************************************************************************
//
//      Title   : CCQue.cpp
//
//      Date    : 1998.05.06    1st making
//
//      Author  : Toshiba [PCS](PSY) Hideki Yagi
//
//      Copyright 1997 Toshiba Corporation. All Rights Reserved.
//
// -------------------------------------------------------------------------
//
//      Change log :
//
//      Date       Revision                  Description
//   ------------ ---------- -----------------------------------------------
//    1998.05.06   000.0000   1st making.
//
//**************************************************************************
#include    "includes.h"
#include    "ccque.h"
#include    "wdmbuff.h"
#include    "dvdinit.h"

CCQueue::CCQueue( void )
{
    count = 0;
    top = bottom = NULL;
}


CCQueue::~CCQueue( void )
{
    count = 0;
    top = bottom = NULL;
}


void CCQueue::Init( void )
{
    count = 0;
    top = bottom = NULL;
}

void CCQueue::put( PHW_STREAM_REQUEST_BLOCK pSrb )
{

    pSrb->NextSRB = NULL;
    if( top == NULL ){
        top = bottom = pSrb;
        count++;
        return;
    }
    
    bottom->NextSRB = pSrb;
    bottom = pSrb;
    count++;

    return;
}

PHW_STREAM_REQUEST_BLOCK CCQueue::get( void )
{
    PHW_STREAM_REQUEST_BLOCK    srb;
    
    if( top == NULL ){
        return( NULL );
    }
    
    srb = top;
    top = top->NextSRB;

    count--;
    if( count==0 ){
        top = bottom = NULL;
    }
    return( srb );
}

        
BOOL CCQueue::remove( PHW_STREAM_REQUEST_BLOCK pSrb )
{
    if( top == NULL ){
        return( FALSE );
    }
    
    if( top == pSrb ){
        top = top->NextSRB;
        count--;
        if( count==0 )
            top = bottom = NULL;

        return( TRUE );
    }
    
    PHW_STREAM_REQUEST_BLOCK    srbPrev;
    PHW_STREAM_REQUEST_BLOCK    srb;
    
    srbPrev = top;
    srb = srbPrev->NextSRB;
    
    while( srb!=NULL ){
        if( srb==pSrb ){
            srbPrev->NextSRB = srb->NextSRB;
            if( srb == bottom ){
                bottom = srbPrev;
            }
            count--;
            return( TRUE );
//            break;
        }
        srbPrev = srb;
        srb = srbPrev->NextSRB;
    }
    return( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\tecra\classlibif.h ===
/*
NXCuC^tF[X
iNP2)@Sachiko Yasukawa
*/
//     Date    |   Author     |  Description
//  -----------+--------------+--------------------------------------------
//  1998.03.27 |  Hideki Yagi | Change the specification about
//             |              | Get***Property().
//

typedef enum {
	PowerOff,
	Stop,
	Pause,
	Play,
	Slow,
	Scan
} LIBSTATE;

class IMPEGBuffer : public IMBoardListItem
{
public:
	virtual DWORD GetPageNum()=0;
	virtual DWORD GetPageSize(DWORD PageNum)=0;
	virtual BOOL GetPagePointer(DWORD PageNum, DWORD *LinearAdd, DWORD *PhyAdd)=0;
	virtual DWORD GetBufferFlag()=0;
};

class IMPEGBoardState
{
public:
	virtual BOOL Init()=0;
};

//class IMPEGBoardLibEvent
//{
//public:
//	virtual void Advice(PVOID)=0;
//	virtual HALEVENTTYPE GetEventType()=0;
//};

class ITransfer
{
public:
	virtual BOOL Init()=0;
	virtual BOOL SetSink(IMPEGBoardEvent *pEvent)=0;
	virtual BOOL UnSetSink(IMPEGBoardEvent *pEvent)=0;
	virtual BOOL SetDMABuffer(DWORD size, BYTE* LinerAdd, BYTE *PhysAdd)=0;
};

class IStateObject;

class IBaseStream
{
public:
	virtual BOOL Init()=0;
	virtual BOOL Play()=0;
	virtual BOOL Stop()=0;
	virtual BOOL Pause()=0;
	virtual BOOL Slow(DWORD)=0;
	virtual BOOL Scan(DWORD)=0;
	virtual BOOL SingleStep()=0;
	virtual LIBSTATE GetState()=0;
	virtual BOOL SendData(IMPEGBuffer *)=0;
 	virtual BOOL SetStateObject(IMPEGBoardState *pState)=0;
	virtual BOOL SetTransferObject(ITransfer *pTransfer)=0;
	virtual BOOL SetTransferMode(HALSTREAMMODE)=0;
	virtual BOOL SetDataDirection( DirectionType type ) = 0;
	virtual BOOL GetDataDirection( DirectionType *ptype ) = 0;
};

class IVideoProperty
{
public:
	virtual BOOL GetVideoProperty(VIDEOPROPTYPE PropertyType, PVOID pProperty)=0;
	virtual BOOL SetVideoProperty(VIDEOPROPTYPE PropetyType, PVOID pProperty)=0;
};

class IAudioProperty
{
public:
	virtual BOOL GetAudioProperty(AUDIOPROPTYPE PropertyType, PVOID pProperty)=0;
	virtual BOOL SetAudioProperty(AUDIOPROPTYPE PropertyType, PVOID pProperty)=0;
};

class ISubpicProperty
{
public:
	virtual BOOL GetSubpicProperty(SUBPICPROPTYPE PropertyType, PVOID pProperty)=0;
	virtual BOOL SetSubpicProperty(SUBPICPROPTYPE PropertyType, PVOID pProperty)=0;
};

class ICopyProtectProperty
{
public:
	virtual BOOL CppInit() =0;
	virtual BOOL SetChlgKey(UCHAR *)=0;
	virtual BOOL GetChlgKey(UCHAR *)=0;
	virtual BOOL SetDVDKey1(UCHAR *)=0;
	virtual BOOL GetDVDKey2(UCHAR *)=0;
	virtual BOOL SetTitleKey(UCHAR *)=0;
	virtual BOOL SetDiscKey(UCHAR *)=0;
};

class IMPEGBoard
{
public:
	virtual BOOL Init()=NULL;
	virtual BOOL AddStreamObjectInterface(IBaseStream *)=NULL;
	virtual BOOL ReleaseStreamObjectInterface(IBaseStream *)=NULL;
	virtual BOOL PowerOn()=NULL;
	virtual BOOL PowerOff()=NULL;
	virtual BOOL SetSTC(DWORD)=NULL;
	virtual BOOL GetSTC(DWORD *)=NULL;
	virtual BOOL SetHALObjectInterface(IClassLibHAL *)=NULL;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\tecra\adv.h ===
//***************************************************************************
//
//	FileName:
//		$Workfile: adv.h $
//		ADV7175A/ADV7170 Interface 
//
//	Author:
//		TOSHIBA [PCS](PSY) Seiichi Nakamura
//		Copyright (c) 1997 TOSHIBA CORPORATION
//
//	Description:
//
//***************************************************************************
// $Header: /DVD Drivers/Sources/ZiVAHAL/adv.h 11    98/04/20 7:19p Hero $
// $Modtime: 98/04/20 5:25p $
// $Nokeywords:$
//***************************************************************************
//     Date    |   Author     |  Description
//  -----------+--------------+--------------------------------------------
//  1997.11.11 |  Hideki Yagi | Add ADV7170 class for San-Jose.
//             |              | Adding SetCgmsType method for ADV7170.
//       12.04 |  Hideki Yagi | Add support WSS.
//

#ifndef _ADV_H_
#define _ADV_H_

class CVideoPropSet;  
class CIOIF;

class CADV
{
    public:
        virtual BOOL    SetNTSC( void ) PURE;
        virtual BOOL    SetPAL( DWORD Type) PURE;
        virtual BOOL    SetMacroVision( APSTYPE Type) PURE;
        virtual BOOL    SetCompPowerOn( BOOL Type ) PURE;
        virtual BOOL    SetSVideoPowerOn( BOOL Type ) PURE;
        virtual BOOL    SetCgmsType( CGMSTYPE Type, CVideoPropSet VProp ) PURE;
// by oka
        virtual BOOL    SetClosedCaptionOn( BOOL Switch ) PURE;
        virtual BOOL    SetClosedCaptionData( DWORD Data ) PURE;
};

class CIIC		// private class for IIC
{
	private:	// private data
		BYTE			SubAddr;
		CIOIF			*m_pioif;
		IKernelService	*m_pKernelObj;
		
	private:	// private function
		BOOL	IICBusyPoll( void );
		
	public:		// public function
		CIIC();

		void	Init(IKernelService *pKernelObj, CIOIF *pioif, BYTE Addr );
		DWORD	Set( BYTE Data );
		DWORD	Get( BYTE *Data );

		CIIC& operator=(const BYTE &Data )
		{
			Set( Data );
			return *this;
		};
		operator BYTE()
		{
			BYTE	Data;
			Get( &Data );
			return Data;
		};

};

class CADV7175A	: public CADV
{
	private:		// datas
		CIIC	ModeRegister0;
		CIIC	ModeRegister1;
		CIIC	SubCarrierFreqRegister0;
		CIIC	SubCarrierFreqRegister1;
		CIIC	SubCarrierFreqRegister2;
		CIIC	SubCarrierFreqRegister3;
		CIIC	SubCarrierPhaseRegister;
		CIIC	TimingRegister;
		CIIC	ClosedCapExData0;
		CIIC	ClosedCapExData1;
		CIIC	ClosedCapData0;
		CIIC	ClosedCapData1;
		CIIC	TimingRegister1;
		CIIC	ModeRegister2;
		CIIC	NTSCTTXRegister0;
		CIIC	NTSCTTXRegister1;
		CIIC	NTSCTTXRegister2;
		CIIC	NTSCTTXRegister3;
		CIIC	ModeRegister3;
		CIIC	MacrovisionRegister[17];
		CIIC	TTXRQControlRegister0;
		CIIC	TTXRQControlRegister;	// ??

		BOOL	bCompPower;
		BOOL	bSVideoPower;
// by oka
		BOOL	bClosedCaption;
		typedef enum
		{
			OUTPUT_NTSC = 0,
			OUTPUT_PAL
		} OUTPUTTYPE;

		OUTPUTTYPE	m_OutputType;
		APSTYPE		m_apstype;

	public:
		CADV7175A( void );

		BOOL	SetNTSC( void );
		BOOL	SetPAL( DWORD Type );
		BOOL	SetMacroVision( APSTYPE Type );
		BOOL	SetCompPowerOn( BOOL Type );
		BOOL	SetSVideoPowerOn( BOOL Type );
        	BOOL    SetCgmsType( CGMSTYPE Type, CVideoPropSet VProp );
// by oka
		BOOL	SetClosedCaptionOn( BOOL Switch );
		BOOL	SetClosedCaptionData( DWORD Data );

	public:		// commands
		void	Init( IKernelService *pKernelObj, CIOIF *pioif );

};

class CADV7170 : public CADV
{
	private:		// datas
		CIIC	ModeRegister0;
		CIIC	ModeRegister1;
		CIIC	ModeRegister2;
		CIIC	ModeRegister3;
		CIIC	ModeRegister4;
		CIIC	TimingRegister0;
		CIIC	TimingRegister1;
		CIIC	SubCarrierFreqRegister0;
		CIIC	SubCarrierFreqRegister1;
		CIIC	SubCarrierFreqRegister2;
		CIIC	SubCarrierFreqRegister3;
		CIIC	SubCarrierPhaseRegister;
		CIIC	ClosedCapExData0;
		CIIC	ClosedCapExData1;
		CIIC	ClosedCapData0;
		CIIC	ClosedCapData1;
		CIIC	NTSCTTXRegister0;
		CIIC	NTSCTTXRegister1;
		CIIC	NTSCTTXRegister2;
		CIIC	NTSCTTXRegister3;
		CIIC    CgmsWssRegister0;
		CIIC    CgmsWssRegister1;
        CIIC    CgmsWssRegister2;
		CIIC    TTXRQPositionRegister;
		CIIC	MacrovisionRegister[18];

		BOOL	bCompPower;
		BOOL	bSVideoPower;
// by oka
		BOOL	bClosedCaption;

		typedef enum
		{
			OUTPUT_NTSC = 0,
			OUTPUT_PAL
		} OUTPUTTYPE;

		OUTPUTTYPE	m_OutputType;
		APSTYPE		m_apstype;
        CGMSTYPE    m_cgmstype;                 // CGMS setting
        
	public:
		CADV7170( void );

		BOOL	SetNTSC( void );
		BOOL	SetPAL( DWORD Type );
		BOOL	SetMacroVision( APSTYPE Type );
		BOOL	SetCompPowerOn( BOOL Type );
		BOOL	SetSVideoPowerOn( BOOL Type );
	        BOOL    SetCgmsType( CGMSTYPE Type, CVideoPropSet VProp );
// by oka
		BOOL	SetClosedCaptionOn( BOOL Switch );
		BOOL	SetClosedCaptionData( DWORD Data );
		
	public:		// commands
		void	Init( IKernelService *pKernelObj, CIOIF *pioif );

};

#endif		// _ADV_H_
//***************************************************************************
//	End of 
//***************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\tecra\brdprop.cpp ===
//***************************************************************************
//
//	FileName:
//		$Workfile: brdprop.cpp $
//
//	Author:
//		TOSHIBA [PCS](PSY) Seiichi Nakamura
//		Copyright (c) 1997 TOSHIBA CORPORATION
//
//	Description:
//
//***************************************************************************
// $Header: /DVD Drivers/ZiVA.WDM/brdprop.cpp 58    98/12/03 6:08p Yagi $
// $Modtime: 98/12/03 4:53p $
// $Nokeywords:$
//***************************************************************************
//     Date    |   Author     |  Description
//  -----------+--------------+--------------------------------------------
//  1998.03.27 |  Hideki Yagi | Buugfix about Digital Palette setting.
//  1998.05.01 |  Hideki Yagi | Add SubpicProperty_FlushBuff.
//

#include	"includes.h"
#include	"timeout.h"
#include	"ioif.h"
#include	"adv.h"
#include	"zivachip.h"
#include	"mixhal.h"
// by oka
#include	"userdata.h"
#include	"zivabrd.h"

//***************************************************************************
//	ZiVA Board Class
//***************************************************************************

//---------------------------------------------------------------------------
//	IClassLibHAL  SetVideoProperty
//---------------------------------------------------------------------------
HALRESULT CMPEGBoardHAL::SetVideoProperty( VIDEOPROPTYPE PropertyType, VOID *pData )
{

	BOOL	rc = FALSE;

	switch( PropertyType )
	{
		case VideoProperty_TVSystem:
				rc = SetVideoProperty_TVSystem( pData );
				break;
		case VideoProperty_AspectRatio:
				rc = SetVideoProperty_AspectRatio( pData );
				break;
		case VideoProperty_DisplayMode:
				rc = SetVideoProperty_DisplayMode( pData );
				break;
		case VideoProperty_Resolution:
				rc = SetVideoProperty_Resolution( pData );
				break;
		case VideoProperty_DigitalOut:
				rc = SetVideoProperty_DigitalOut( pData );
				break;
		case VideoProperty_DigitalPalette:
				rc = SetVideoProperty_DigitalPalette( pData );
				break;
		case VideoProperty_APS:
				rc = SetVideoProperty_APS( pData );
				break;
		case VideoProperty_ClosedCaption:
				rc = SetVideoProperty_ClosedCaption( pData );
				break;
		case VideoProperty_OutputSource:
				rc = SetVideoProperty_OutputSource( pData );
				break;
		case VideoProperty_CompositeOut:
				rc = SetVideoProperty_CompositeOut( pData );
				break;
		case VideoProperty_SVideoOut:
				rc = SetVideoProperty_SVideoOut( pData );
				break;
		case VideoProperty_SkipFieldControl:
				rc = SetVideoProperty_SkipFieldControl( pData );
				break;
		case VideoProperty_FilmCamera:
				rc = SetVideoProperty_FilmCamera( pData );
				break;
// by oka
		case VideoProperty_Digest:
				rc = SetVideoProperty_Digest( pData );
				break;
		case VideoProperty_OSDData:
				rc = SetVideoProperty_OSDData( pData );
				break;
		case VideoProperty_OSDSwitch:
				rc = SetVideoProperty_OSDSwitch( pData );
				break;
		case VideoProperty_Magnify:
				rc = SetVideoProperty_Magnify( pData );
				break;
		case VideoProperty_ClosedCaptionData:
				rc = SetVideoProperty_ClosedCaptionData( pData );
				break;
// end
		default:
			return HAL_INVALID_PARAM;
	};

	if( rc == TRUE )
		return HAL_SUCCESS;

	DBG_BREAK();
	return HAL_ERROR;
};
//---------------------------------------------------------------------------
//	IClassLibHAL  GetVideoProperty
//---------------------------------------------------------------------------
HALRESULT CMPEGBoardHAL::GetVideoProperty( VIDEOPROPTYPE PropertyType, VOID *pData )
{

	BOOL	rc = FALSE;

	switch( PropertyType )
	{
		case VideoProperty_TVSystem:
				rc = GetVideoProperty_TVSystem( pData );
				break;
		case VideoProperty_AspectRatio:
				rc = GetVideoProperty_AspectRatio( pData );
				break;
		case VideoProperty_DisplayMode:
				rc = GetVideoProperty_DisplayMode( pData );
				break;
		case VideoProperty_Resolution:
				rc = GetVideoProperty_Resolution( pData );
				break;
		case VideoProperty_DigitalOut:
				rc = GetVideoProperty_DigitalOut( pData );
				break;
		case VideoProperty_DigitalPalette:
				rc = GetVideoProperty_DigitalPalette( pData );
				break;
		case VideoProperty_APS:
				rc = GetVideoProperty_APS( pData );
				break;
		case VideoProperty_ClosedCaption:
				rc = GetVideoProperty_ClosedCaption( pData );
				break;
		case VideoProperty_OutputSource:
				rc = GetVideoProperty_OutputSource( pData );
				break;
		case VideoProperty_CompositeOut:
				rc = GetVideoProperty_CompositeOut( pData );
				break;
		case VideoProperty_SVideoOut:
				rc = GetVideoProperty_SVideoOut( pData );
				break;
		case VideoProperty_SkipFieldControl:
				rc = GetVideoProperty_SkipFieldControl( pData );
				break;
		case VideoProperty_FilmCamera:
				rc = GetVideoProperty_FilmCamera( pData );
				break;
// by oka
		case VideoProperty_Digest:
				rc = GetVideoProperty_Digest( pData );
				break;
		case VideoProperty_OSDData:
				rc = GetVideoProperty_OSDData( pData );
				break;
		case VideoProperty_OSDSwitch:
				rc = GetVideoProperty_OSDSwitch( pData );
				break;
		case VideoProperty_Magnify:
				rc = GetVideoProperty_Magnify( pData );
				break;
		case VideoProperty_ClosedCaptionData:
				rc = GetVideoProperty_ClosedCaptionData( pData );
				break;
// end
		default:
			return HAL_INVALID_PARAM;
	};

	if( rc == TRUE )
		return HAL_SUCCESS;

	DBG_BREAK();
	return HAL_ERROR;
};
//---------------------------------------------------------------------------
//	IClassLibHAL  SetAudioProperty
//---------------------------------------------------------------------------
HALRESULT CMPEGBoardHAL::SetAudioProperty( AUDIOPROPTYPE PropertyType, VOID *pData )
{

	BOOL rc = FALSE;
	
	switch( PropertyType )
	{
		case AudioProperty_Type:
				rc = SetAudioProperty_Type( pData );
				break;
		case AudioProperty_Number:
				rc = SetAudioProperty_Number( pData );
				break;
		case AudioProperty_Volume:
				rc = SetAudioProperty_Volume( pData );
				break;
		case AudioProperty_Sampling:
				rc = SetAudioProperty_Sampling( pData );
				break;
		case AudioProperty_Channel:
				rc = SetAudioProperty_Channel( pData );
				break;
		case AudioProperty_Quant:
				rc = SetAudioProperty_Quant( pData );
				break;
		case AudioProperty_AudioOut:
				rc = SetAudioProperty_AudioOut( pData );
				break;
		case AudioProperty_Cgms:
				rc = SetAudioProperty_Cgms( pData );
				break;
		case AudioProperty_AnalogOut:
				rc = SetAudioProperty_AnalogOut( pData );
				break;
		case AudioProperty_DigitalOut:
				rc = SetAudioProperty_DigitalOut( pData );
				break;
		case AudioProperty_AC3DRangeLowBoost:
				rc = SetAudioProperty_AC3DRangeLowBoost( pData );
				break;
		case AudioProperty_AC3DRangeHighCut:
				rc = SetAudioProperty_AC3DRangeHighCut( pData );
				break;
		case AudioProperty_AC3OperateMode:
				rc = SetAudioProperty_AC3OperateMode( pData );
				break;
		case AudioProperty_AC3OutputMode:
				rc = SetAudioProperty_AC3OutputMode( pData );
				break;
		default:
			return HAL_INVALID_PARAM;
	};

	if( rc == TRUE )
		return HAL_SUCCESS;

	DBG_BREAK();
	return HAL_ERROR;
};
//---------------------------------------------------------------------------
//	IClassLibHAL  GetAudioProperty
//---------------------------------------------------------------------------
HALRESULT CMPEGBoardHAL::GetAudioProperty( AUDIOPROPTYPE PropertyType, VOID *pData )
{

	BOOL rc = FALSE;
	
	switch( PropertyType )
	{
		case AudioProperty_Type:
				rc = GetAudioProperty_Type( pData );
				break;
		case AudioProperty_Number:
				rc = GetAudioProperty_Number( pData );
				break;
		case AudioProperty_Volume:
				rc = GetAudioProperty_Volume( pData );
				break;
		case AudioProperty_Sampling:
				rc = GetAudioProperty_Sampling( pData );
				break;
		case AudioProperty_Channel:
				rc = GetAudioProperty_Channel( pData );
				break;
		case AudioProperty_Quant:
				rc = GetAudioProperty_Quant( pData );
				break;
		case AudioProperty_AudioOut:
				rc = GetAudioProperty_AudioOut( pData );
				break;
		case AudioProperty_Cgms:
				rc = GetAudioProperty_Cgms( pData );
				break;
		case AudioProperty_AnalogOut:
				rc = GetAudioProperty_AnalogOut( pData );
				break;
		case AudioProperty_DigitalOut:
				rc = GetAudioProperty_DigitalOut( pData );
				break;
		case AudioProperty_AC3DRangeLowBoost:
				rc = GetAudioProperty_AC3DRangeLowBoost( pData );
				break;
		case AudioProperty_AC3DRangeHighCut:
				rc = GetAudioProperty_AC3DRangeHighCut( pData );
				break;
		case AudioProperty_AC3OperateMode:
				rc = GetAudioProperty_AC3OperateMode( pData );
				break;
		case AudioProperty_AC3OutputMode:
				rc = GetAudioProperty_AC3OutputMode( pData );
				break;
		default:
			return HAL_INVALID_PARAM;
	};

	if( rc == TRUE )
		return HAL_SUCCESS;

	DBG_BREAK();
	return HAL_ERROR;
};
//---------------------------------------------------------------------------
//	IClassLibHAL  SetSubpicProperty
//---------------------------------------------------------------------------
HALRESULT CMPEGBoardHAL::SetSubpicProperty( SUBPICPROPTYPE PropertyType, VOID *pData )
{

	BOOL rc = FALSE;
	
	switch( PropertyType )
	{
		case SubpicProperty_Number:
			rc = SetSubpicProperty_Number( pData );
			break;
		case SubpicProperty_Palette:
			rc = SetSubpicProperty_Palette( pData );
			break;
		case SubpicProperty_Hilight:
			rc = SetSubpicProperty_Hilight( pData );
			break;
		case SubpicProperty_State:
			rc = SetSubpicProperty_State( pData );
			break;
// by oka
		case SubpicProperty_HilightButton:
			rc = SetSubpicProperty_HilightButton( pData );
			break;
        case SubpicProperty_FlushBuff:
            rc = SetSubpicProperty_FlushBuff( pData );
            break;
		default:
			return HAL_INVALID_PARAM;
	};

	if( rc == TRUE )
		return HAL_SUCCESS;

	DBG_BREAK();
	return HAL_ERROR;
};
//---------------------------------------------------------------------------
//	IClassLibHAL  GetSubpicProperty
//---------------------------------------------------------------------------
HALRESULT CMPEGBoardHAL::GetSubpicProperty( SUBPICPROPTYPE PropertyType, VOID *pData )
{

	BOOL rc = FALSE;
	
	switch( PropertyType )
	{
		case SubpicProperty_Number:
			rc = GetSubpicProperty_Number( pData );
			break;
		case SubpicProperty_Palette:
			rc = GetSubpicProperty_Palette( pData );
			break;
		case SubpicProperty_Hilight:
			rc = GetSubpicProperty_Hilight( pData );
			break;
		case SubpicProperty_State:
			rc = GetSubpicProperty_State( pData );
			break;
// by oka
		case SubpicProperty_HilightButton:
			rc = GetSubpicProperty_HilightButton( pData );
			break;

        case SubpicProperty_FlushBuff:
            rc = GetSubpicProperty_FlushBuff( pData );
            break;
		default:
			return HAL_INVALID_PARAM;
	};

	if( rc == TRUE )
		return HAL_SUCCESS;

	DBG_BREAK();
	return HAL_ERROR;
};


//***************************************************************************
//	Video Property Functions( Set Series )
//***************************************************************************
BOOL	CMPEGBoardHAL::SetVideoProperty_TVSystem( PVOID pData )
{
	VideoProperty_TVSystem_Value *pValue = (VideoProperty_TVSystem_Value *)pData;

	POWERSTATE PowerState;
	GetPowerState( &PowerState );

	if( PowerState == POWERSTATE_ON )
	{

		if( *pValue != m_VideoProp.m_TVSystem )
		{
// 98.12.03  H.Yagi  start
	        // Abort Command send to ZiVA
        	m_pKernelObj->DisableHwInt();
	        ziva.INT_MASK = ZIVA_INT_ENDC;
        	ClearENDCEvent();
	        m_pKernelObj->EnableHwInt();
        	ziva.Abort( 1 );

	        // WaitENDC interrupt
        	if( WaitENDC() == FALSE ){
	            DBG_PRINTF( ("brdprop: Abort Error\n\r") );
        	    DBG_BREAK();
	            return( FALSE );
        	}
// 98.12.03  H.Yagi  end

			switch( *pValue )
			{
				case TV_NTSC:
                    ziva.VIDEO_ENV_CHANGE = 0x01;       // 98.10.29 H.Yagi
                    m_VideoProp.m_TVSystem = *pValue;   // 98.10.29 H.Yagi
                    break;

				case TV_PALB:	case TV_PALD:	case TV_PALG:
				case TV_PALH:	case TV_PALI:	case TV_PALM:
				DBG_PRINTF( ( "DVDPROP: Change TVSystem from %d to %d\n", m_VideoProp.m_TVSystem, *pValue ));
                    ziva.VIDEO_ENV_CHANGE = 0x02;       // 98.10.29 H.Yagi
                    m_VideoProp.m_TVSystem = *pValue;   // 98.10.29 H.Yagi

//                    SetPowerState( POWERSTATE_OFF );
//                    SetPowerState( POWERSTATE_ON );
					break;

				case TV_PALN:		// NON SUPPORT!
					DBG_BREAK();
					return FALSE;
					
				default:
					DBG_BREAK();
					 return FALSE;
			};
            ziva.NewPlayMode();             // 98.10.29 H.Yagi
		};

		switch( *pValue )
		{
			case TV_NTSC:
                if( adv==NULL )
                {
                    DBG_PRINTF(("DVDPROP:adv object is NULL! LINE=%d\n", __LINE__ ));
                    DBG_BREAK();
                    return( FALSE );
                }
    			adv->SetNTSC();
				break;

			case TV_PALB:	case TV_PALD:	case TV_PALG:
			case TV_PALH:	case TV_PALI:
                if( adv==NULL )
                {
                    DBG_PRINTF(("DVDPROP:adv object is NULL! LINE=%d\n", __LINE__ ));
                    DBG_BREAK();
                    return( FALSE );
                }
				adv->SetPAL( 0 );		// PAL B,D,G,H,I
				break;

			case TV_PALM:
                if( adv==NULL )
                {
                    DBG_PRINTF(("DVDPROP:adv object is NULL! LINE=%d\n", __LINE__ ));
                    DBG_BREAK();
                    return( FALSE );
                }
				adv->SetPAL( 1 );		// PAL M
				break;

			case TV_PALN:		// NON SUPPORT!
				DBG_BREAK();
				return FALSE;

			default:
				DBG_BREAK();
				 return FALSE;
		};
	};

	m_VideoProp.m_TVSystem = *pValue;
	return TRUE;
};

BOOL	CMPEGBoardHAL::SetVideoProperty_AspectRatio( PVOID pData )
{
	VideoProperty_AspectRatio_Value *pValue = (VideoProperty_AspectRatio_Value *)pData;
	
	POWERSTATE PowerState;
	GetPowerState( &PowerState );

	if( PowerState == POWERSTATE_ON )
	{
		switch( *pValue )
		{
			case Aspect_04_03:
				DBG_PRINTF( ( "DVDPROP: Aspect_04_03\n"));
				ziva.FORCE_CODED_ASPECT_RATIO = 2;
				break;
			case Aspect_16_09:
				DBG_PRINTF( ( "DVDPROP: Aspect_16_09\n"));
				ziva.FORCE_CODED_ASPECT_RATIO = 3;
				break;
			default:
				DBG_BREAK();
				return FALSE;
		};
	};
	
	m_VideoProp.m_AspectRatio = *pValue;
	return SetVideoProperty_DisplayMode( (PVOID)&(m_VideoProp.m_DisplayMode) );
};

BOOL	CMPEGBoardHAL::SetVideoProperty_DisplayMode( PVOID pData )
{
	VideoProperty_DisplayMode_Value *pValue = (VideoProperty_DisplayMode_Value *)pData;
	
	POWERSTATE PowerState;
	GetPowerState( &PowerState );

	// p[^`FbN
	if( *pValue != Display_Original && *pValue != Display_PanScan && *pValue != Display_LetterBox )
	{
		DBG_BREAK();
		return FALSE;
	};

	// 1998.8.18 seichan
	// PICVX
/******/
	if( PowerState == POWERSTATE_ON )
	{
		switch( *pValue )
		{
			case Display_Original:
					DBG_PRINTF( ( "DVDPROP: Display Original\n"));
					if( m_VideoProp.m_AspectRatio == Aspect_04_03 )
					{
						ziva.DISPLAY_ASPECT_RATIO		= 0x00;
						ziva.ASPECT_RATIO_MODE          = 0x01;
                        ioif.luke2.AVCONT = (WORD)((ioif.luke2.AVCONT & 0xfcff) | 0x0300);  // S2 = H, S1 = H
					}
					else
					{
                        ziva.DISPLAY_ASPECT_RATIO       = 0x02;
						ziva.ASPECT_RATIO_MODE          = 0x01;
                        ioif.luke2.AVCONT = (WORD)((ioif.luke2.AVCONT & 0xfcff) | 0x0200);  // S2 = H, S1 = L
					};
					break;
			case Display_PanScan:
					DBG_PRINTF( ( "DVDPROP: Display Panscan\n"));
					if( m_VideoProp.m_AspectRatio == Aspect_04_03 )
					{
						ziva.DISPLAY_ASPECT_RATIO		= 0x00;
						ziva.ASPECT_RATIO_MODE          = 0x01;
						ziva.PAN_SCAN_SOURCE            = 0x00;
                        ioif.luke2.AVCONT = (WORD)((ioif.luke2.AVCONT & 0xfcff) | 0x0300);  // S2 = H, S1 = H
					}
					else
					{
						ziva.DISPLAY_ASPECT_RATIO		= 0x00;
						ziva.ASPECT_RATIO_MODE          = 0x01;
						ziva.PAN_SCAN_SOURCE            = 0x00;
                        ioif.luke2.AVCONT = (WORD)((ioif.luke2.AVCONT & 0xfcff) | 0x0300);  // S2 = H, S1 = H
					};

					break;
			case Display_LetterBox:
					DBG_PRINTF( ( "DVDPROP: Display LetterBox\n"));

					if( m_VideoProp.m_AspectRatio == Aspect_04_03 )
					{
						ziva.DISPLAY_ASPECT_RATIO		= 0x00;
						ziva.ASPECT_RATIO_MODE          = 0x01;
                        ioif.luke2.AVCONT = (WORD)((ioif.luke2.AVCONT & 0xfcff) | 0x0300);  // S2 = H, S1 = H
					}
					else
					{
						ziva.DISPLAY_ASPECT_RATIO		= 0x00;
						ziva.ASPECT_RATIO_MODE          = 0x02;
                        ioif.luke2.AVCONT = (WORD)((ioif.luke2.AVCONT & 0xfcff) | 0x0100);  // S2 = L, S1 = H
					};

					break;
			default:
				DBG_BREAK();
				return FALSE;
		};
	};
/*******/

	m_VideoProp.m_DisplayMode = *pValue;

	// 1998.8.18 seichan
	// ZiVAPICVstOZbg
//    m_SetVideoProperty_DisplayMode_Event = TRUE;
	return TRUE;
};

BOOL	CMPEGBoardHAL::SetVideoProperty_Resolution( PVOID pData )
{
	VideoSizeStruc *pValue = (VideoSizeStruc *)pData;
	
	m_VideoProp.m_Size = *pValue;
	return TRUE;
};

BOOL	CMPEGBoardHAL::SetVideoProperty_DigitalOut( PVOID pData )
{
	VideoProperty_DigitalOut_Value *pValue = (VideoProperty_DigitalOut_Value *)pData;

	BYTE Data;

//	if( m_VideoProp.m_DigitalOut != DigitalOut_Off && *pValue != DigitalOut_Off )
//	{
//		return FALSE;
//	};

	POWERSTATE PowerState;
	GetPowerState( &PowerState );

	if( PowerState == POWERSTATE_ON )
	{
		switch( *pValue )
		{
			case DigitalOut_Off:
				// ZV off
				if( m_VideoProp.m_DigitalOut == DigitalOut_ZV )
				{
					m_pKernelObj->GetPCIConfigData( 0x44, &Data );
                    Data = (BYTE)( Data & 0xfe );
					m_pKernelObj->SetPCIConfigData( 0x44, Data );
				};
				ioif.luke2.IO_VMODE = 0x00;
				ioif.luke2.IO_HSCNT = 0x00;
				ioif.luke2.IO_VPCNT = 0x00;
				break;

			case DigitalOut_ZV:
				ioif.luke2.IO_VMODE = 0x00;
				ioif.luke2.IO_HSCNT = 0x00;
				ioif.luke2.IO_VPCNT = 0x00;
				m_pKernelObj->GetPCIConfigData( 0x44, &Data );
                Data = (BYTE)( Data | 0x01 );
				m_pKernelObj->SetPCIConfigData( 0x44, Data );
				break;
				
			case DigitalOut_LPB08:
				ioif.luke2.IO_VMODE = 0x04;
				ioif.luke2.IO_HSCNT = 0x70;
				ioif.luke2.IO_VPCNT = 0x02;
				break;

			case DigitalOut_LPB16:
				ioif.luke2.IO_VMODE = 0x08;
				ioif.luke2.IO_HSCNT = 0x00;
				ioif.luke2.IO_VPCNT = 0x00;
				break;

			case DigitalOut_VMI:
				ioif.luke2.IO_VMODE = 0x06;
				ioif.luke2.IO_HSCNT = 0x00;
				ioif.luke2.IO_VPCNT = 0x00;
				break;

			case DigitalOut_AMCbt:
				ioif.luke2.IO_VMODE = 0x07;
				ioif.luke2.IO_HSCNT = 0x00;
				ioif.luke2.IO_VPCNT = 0x00;
				break;

			case DigitalOut_AMC656:
				ioif.luke2.IO_VMODE = 0x09;
				ioif.luke2.IO_HSCNT = 0x00;
				ioif.luke2.IO_VPCNT = 0x00;
				break;

			case DigitalOut_DAV2:
				ioif.luke2.IO_VMODE = 0x01;
				ioif.luke2.IO_HSCNT = 0x00;
				ioif.luke2.IO_VPCNT = 0x00;
				break;

			case DigitalOut_CIRRUS:
				ioif.luke2.IO_VMODE = 0x05;
				ioif.luke2.IO_HSCNT = 0x00;
				ioif.luke2.IO_VPCNT = 0x00;
				break;

			default:
				DBG_BREAK();
				return FALSE;
		};
	};
	m_VideoProp.m_DigitalOut = *pValue;
	return TRUE;
};

BOOL	CMPEGBoardHAL::SetVideoProperty_DigitalPalette( PVOID pData )
{
	Digital_Palette *pValue = (Digital_Palette *)pData;

	BYTE CpCtl;

    CpCtl = 0x04;                   // 98.03.27 H.Yagi
    ioif.luke2.IO_CPCNT = CpCtl;
	switch( pValue->Select )
	{
        case Palette_Y:     CpCtl = 0x01;   break;
        case Palette_Cb:    CpCtl = 0x02;   break;
        case Palette_Cr:    CpCtl = 0x03;   break;
		default:
			DBG_BREAK();
			return FALSE;
	};

	POWERSTATE PowerState;
	GetPowerState( &PowerState );

	if( PowerState == POWERSTATE_ON )
	{
		// Select Palette and Clear Counter.
		ioif.luke2.IO_CPCNT = CpCtl;

		// Set Palette value
		for ( int i = 0 ; i < 256; i ++ )
			ioif.luke2.IO_CPLT = pValue->pPalette[i];
	};

	for ( int i = 0 ; i < 256; i ++ )
		m_VideoProp.m_DigitalPalette[ pValue->Select ][i] = pValue->pPalette[i];
	
	return TRUE;
};

BOOL	CMPEGBoardHAL::SetVideoProperty_APS( PVOID pData )
{
	VideoAPSStruc *pValue = (VideoAPSStruc *)pData;
	POWERSTATE PowerState;
	GetPowerState( &PowerState );

	if( PowerState == POWERSTATE_ON )
	{
        if( adv==NULL )
        {
            DBG_PRINTF(("DVDPROP:adv object is NULL! LINE=%d\n", __LINE__ ));
            DBG_BREAK();
            return( FALSE );
        }
        BOOL   rc;
        rc = adv->SetMacroVision( pValue->APSType );
		if( rc == FALSE )
			return FALSE;
        rc = adv->SetCgmsType( pValue->CgmsType, m_VideoProp );
		if( rc == FALSE )
			return FALSE;
	};
	
	m_VideoProp.m_APS = *pValue;
	return TRUE;
};

BOOL	CMPEGBoardHAL::SetVideoProperty_ClosedCaption( PVOID pData )
{
	VideoProperty_ClosedCaption_Value *pValue = (VideoProperty_ClosedCaption_Value *)pData;
	
	switch( *pValue )
	{
		case ClosedCaption_On:
// by oka
			m_CCRingBufferStart = 0xFFFFFFFF;
			m_CCDataPoint = m_CCDataNumber = m_CCRingBufferNumber = 0;
			m_CCsend_point = m_CCpending = m_CCnumber = 0;
			adv->SetClosedCaptionOn( TRUE );
			// by oka
			if (!SetEventIntMask( ZIVA_INT_USR | ZIVA_INT_VSYNC ))
			{
				DBG_BREAK();
				return HAL_ERROR;
			}
//            ziva.INT_MASK = GetEventIntMask();        // No need
			break;
		case ClosedCaption_Off:
			// by oka
			if (!UnsetEventIntMask( ZIVA_INT_USR | ZIVA_INT_VSYNC ))
			{
				DBG_BREAK();
				return HAL_ERROR;
			}
//            ziva.INT_MASK = GetEventIntMask();            // No need.
			m_CCRingBufferStart = 0xFFFFFFFF;
			m_CCDataPoint = m_CCDataNumber = m_CCRingBufferNumber = 0;
			m_CCsend_point = m_CCpending = m_CCnumber = 0;
			adv->SetClosedCaptionData( 0x0000942C );
			adv->SetClosedCaptionData( 0x0000942C );
			adv->SetClosedCaptionOn( FALSE );
			break;
		default:
			DBG_BREAK();
			return FALSE;
	};

	m_VideoProp.m_ClosedCaption = *pValue;
	return TRUE;
};

BOOL	CMPEGBoardHAL::SetVideoProperty_OutputSource( PVOID pData )
{
	VideoProperty_OutputSource_Value *pValue = (VideoProperty_OutputSource_Value *)pData;
	
	BYTE	Data;

	switch( *pValue )
	{
		case OutputSource_VGA:
			m_pKernelObj->GetPCIConfigData( 0x44, &Data );
            Data = (BYTE)( Data & 0xfd );
			m_pKernelObj->SetPCIConfigData( 0x44, Data );
			break;

		case OutputSource_DVD:
			m_pKernelObj->GetPCIConfigData( 0x44, &Data );
            Data = (BYTE)( Data | 0x02 );
			m_pKernelObj->SetPCIConfigData( 0x44, Data );
			break;

		default:
			DBG_BREAK();
			return FALSE;
	};

	m_VideoProp.m_OutputSource = *pValue;
	return TRUE;
};

BOOL	CMPEGBoardHAL::SetVideoProperty_CompositeOut( PVOID pData )
{
	VideoProperty_CompositeOut_Value *pValue = (VideoProperty_CompositeOut_Value *)pData;
	
	POWERSTATE PowerState;
	GetPowerState( &PowerState );

	if( PowerState == POWERSTATE_ON )
	{
		switch( *pValue )
		{
			case CompositeOut_On:
                if( adv==NULL )
                {
                    DBG_PRINTF(("DVDPROP:adv object is NULL! LINE=%d\n", __LINE__ ));
                    DBG_BREAK();
                    return( FALSE );
                }
				adv->SetCompPowerOn( TRUE );
				break;
			case CompositeOut_Off:
                if( adv==NULL )
                {
                    DBG_PRINTF(("DVDPROP:adv object is NULL! LINE=%d\n", __LINE__ ));
                    DBG_BREAK();
                    return( FALSE );
                }
				adv->SetCompPowerOn( FALSE );
				break;
			default:
				DBG_BREAK();
				return FALSE;
		};
	};
	
	m_VideoProp.m_CompositeOut = *pValue;
	return TRUE;
};

BOOL	CMPEGBoardHAL::SetVideoProperty_SVideoOut( PVOID pData )
{
	VideoProperty_SVideoOut_Value *pValue = (VideoProperty_SVideoOut_Value *)pData;
	
	POWERSTATE PowerState;
	GetPowerState( &PowerState );

	if( PowerState == POWERSTATE_ON )
	{
		switch( *pValue )
		{
			case SVideoOut_On:
                if( adv==NULL )
                {
                    DBG_PRINTF(("DVDPROP:adv object is NULL! LINE=%d\n", __LINE__ ));
                    DBG_BREAK();
                    return( FALSE );
                }
				adv->SetSVideoPowerOn( TRUE );
				break;
			case SVideoOut_Off:
                if( adv==NULL )
                {
                    DBG_PRINTF(("DVDPROP:adv object is NULL! LINE=%d\n", __LINE__ ));
                    DBG_BREAK();
                    return( FALSE );
                }
				adv->SetSVideoPowerOn( FALSE );
				break;
			default:
				DBG_BREAK();
				return FALSE;
		};
	};
	
	m_VideoProp.m_SVideoOut = *pValue;
	return TRUE;
};

BOOL	CMPEGBoardHAL::SetVideoProperty_SkipFieldControl( PVOID pData )
{
	VideoProperty_SkipFieldControl_Value *pValue = (VideoProperty_SkipFieldControl_Value *)pData;
	
	POWERSTATE PowerState;
	GetPowerState( &PowerState );

	if( PowerState == POWERSTATE_ON )
	{
		switch( *pValue )
		{
			case SkipFieldControl_On:
				ioif.luke2.AVCONT |= 0x04;
				break;
			case SkipFieldControl_Off:
				ioif.luke2.AVCONT &= 0xfffd;
				break;
			default:
				DBG_BREAK();
				return FALSE;
		};
	};

	m_VideoProp.m_SkipFieldControl = *pValue;
	return TRUE;
};

BOOL	CMPEGBoardHAL::SetVideoProperty_FilmCamera( PVOID pData )
{
	VideoProperty_FilmCamera_Value *pValue = (VideoProperty_FilmCamera_Value *)pData;
	
	POWERSTATE PowerState;
	GetPowerState( &PowerState );

	if( PowerState == POWERSTATE_ON )
	{
		switch( *pValue )
		{
			case Source_Camera:
				break;
			case Source_Film:
				break;
			default:
				DBG_BREAK();
				return FALSE;
		};
	};

	m_VideoProp.m_FilmCamera = *pValue;
	return TRUE;
};

// by oka
BOOL	CMPEGBoardHAL::SetVideoProperty_Digest( PVOID pData )
{

    DWORD ret = ZIVARESULT_NOERROR;;
	VideoDigestStruc *pValue = (VideoDigestStruc *)pData;

	POWERSTATE PowerState;
	GetPowerState( &PowerState );

	if( PowerState == POWERSTATE_ON )
	{
		ret = ziva.Digest( pValue->dmX,
								pValue->dmY,
								pValue->dmSkip,
								pValue->dmDecimation,
								pValue->dmThreshold
//								pValue->dmStart
								);
	};
//	m_SubpicProp.m_HlightButton = *pValue;
	
	if (ret == ZIVARESULT_NOERROR)
		return TRUE;
	else
		return FALSE;
};

// by oka
BOOL	CMPEGBoardHAL::SetVideoProperty_OSDData( PVOID pData )
{
	DWORD OSDSize;
	BYTE * OSDData;
    DWORD ret = ZIVARESULT_NOERROR;

	OsdDataStruc *pValue = (OsdDataStruc *)pData;

	POWERSTATE PowerState;
	GetPowerState( &PowerState );

	if( PowerState == POWERSTATE_ON )
	{
		if (m_VideoProp.m_OSDSwitch == Video_OSD_On)
		{
			ziva.OSD_EVEN_FIELD.Set( 0 );
			ziva.OSD_ODD_FIELD.Set( 0 );
		}

		ASSERT((m_OSDStartAddr % 4) == 0);
		if ((m_OSDStartAddr % 4) != 0)
		{
            DBG_BREAK();
		    //RETAILMSG(ZONE_ERROR,(TEXT("OSD_BUFFER_START address Error!!\r\n")));
		    return FALSE;
		}

		DWORD OSDStartAddrPointer, NextDataHeader;
		OSDStartAddrPointer = m_OSDStartAddr;
		NextDataHeader = 0;

		// loop to Next=NULL;

		while (pValue != NULL)
		{
			OSDSize = pValue->dwOsdSize;
			OSDData = (BYTE *)pValue->pData;

			// check data size
			if((m_OSDEndAddr - OSDStartAddrPointer) < OSDSize)
			{
	            DBG_BREAK();
				//RETAILMSG(ZONE_ERROR,(TEXT("OSDSize too big!!\r\n")));
				return FALSE;
			}

			// Next Header Address
			if (pValue->pNextData != NULL)
			{
				NextDataHeader = OSDStartAddrPointer + OSDSize;
				// for 32bit boundary
				NextDataHeader += (NextDataHeader % 4);
				// Even
				OSDData[1] = (BYTE)((NextDataHeader >> 16) & 0xff);
				OSDData[2] = (BYTE)((NextDataHeader >> 8)  & 0xff);
				OSDData[3] = (BYTE)((NextDataHeader)       & 0xff);
				// Odd
				OSDData[1+32] = (BYTE)(((NextDataHeader+32) >> 16) & 0xff);
				OSDData[2+32] = (BYTE)(((NextDataHeader+32) >> 8)  & 0xff);
				OSDData[3+32] = (BYTE)((NextDataHeader+32)       & 0xff);
			} else {
				NextDataHeader = 0;
				// Even
				OSDData[1] = 0;
				OSDData[2] = 0;
				OSDData[3] = 0;
				// Odd
				OSDData[1+32] = 0;
				OSDData[2+32] = 0;
				OSDData[3+32] = 0;
			}

			// change address
			DWORD EvenBmpAddr,OddBmpAddr;
			DWORD EvenPltAddr,OddPltAddr;
			DWORD PelType;
			PelType = (((DWORD)OSDData[18]<<1) & 0x2)
						+ (((DWORD)OSDData[19]>>8) & 0x80);

			EvenBmpAddr = (((DWORD)OSDData[13] << 16) & 0xff0000)
							+ (((DWORD)OSDData[14] << 8 ) & 0xff00)
							+ ((DWORD)OSDData[15] & 0xff);
			OddBmpAddr =  (((DWORD)OSDData[13+32] << 16) & 0xff0000)
							+ (((DWORD)OSDData[14+32] << 8 ) & 0xff00)
							+ ((DWORD)OSDData[15+32] & 0xff);
			EvenPltAddr = (((DWORD)OSDData[29] << 16) & 0xff0000)
							+ (((DWORD)OSDData[30] << 8 ) & 0xff00)
							+ ((DWORD)OSDData[31] & 0xff);
			OddPltAddr = (((DWORD)OSDData[29+32] << 16) & 0xff0000)
							+ (((DWORD)OSDData[30+32] << 8 ) & 0xff00)
							+ ((DWORD)OSDData[31+32] & 0xff);

			// vZPltAddrOSDData[64]nO
			DWORD PltSize;
			if (PelType == 3)
				PltSize = 16;
			else
				PltSize = 64;
			EvenBmpAddr = EvenBmpAddr - EvenPltAddr + OSDStartAddrPointer + PltSize;
			OddBmpAddr  = OddBmpAddr - OddPltAddr + OSDStartAddrPointer + PltSize;
			EvenPltAddr = OSDStartAddrPointer + PltSize;
			OddPltAddr  = OSDStartAddrPointer + PltSize;

			// EvenBmpAddr
			OSDData[13]=(BYTE)((EvenBmpAddr & 0x00ff0000)>>16);
			OSDData[14]=(BYTE)((EvenBmpAddr & 0x0000ff00)>>8);
			OSDData[15]=(BYTE)(EvenBmpAddr & 0x000000fc);
			// OddBmpAddr
			OSDData[13+32]=(BYTE)((OddBmpAddr & 0x00ff0000)>>16);
			OSDData[14+32]=(BYTE)((OddBmpAddr & 0x0000ff00)>>8);
			OSDData[15+32]=(BYTE)(OddBmpAddr & 0x000000fc);
			// EvenPltAddr
			OSDData[29]=(BYTE)((EvenPltAddr & 0x00ff0000)>>16);
			OSDData[30]=(BYTE)((EvenPltAddr & 0x0000ff00)>>8);
			OSDData[31]=(BYTE)(EvenPltAddr & 0x000000fc);
			// OddPltAddr
			OSDData[29+32]=(BYTE)((OddPltAddr & 0x00ff0000)>>16);
			OSDData[30+32]=(BYTE)((OddPltAddr & 0x0000ff00)>>8);
			OSDData[31+32]=(BYTE)(OddPltAddr & 0x000000fc);

			// transfer data
			for( DWORD i = 0 ; i < OSDSize ; i += 4 )
			{
				ret = ziva.ZiVAWriteMemory( OSDStartAddrPointer + i, (DWORD)OSDData[i+0] << 24
												| (DWORD)OSDData[i+1] << 16
												| (DWORD)OSDData[i+2] << 8
												| (DWORD)OSDData[i+3] );
			};

			// Next OSD Data
			pValue = (OsdDataStruc *)pValue->pNextData;
			OSDStartAddrPointer = NextDataHeader;
		}

		if (m_VideoProp.m_OSDSwitch == Video_OSD_On)
		{
			ziva.OSD_EVEN_FIELD.Set( m_OSDStartAddr );
			ziva.OSD_ODD_FIELD.Set( m_OSDStartAddr + 32 );
		}

	};
	
	if (ret == ZIVARESULT_NOERROR)
		return TRUE;
	else
		return FALSE;
};

// by oka
BOOL	CMPEGBoardHAL::SetVideoProperty_OSDSwitch( PVOID pData )
{

	VideoProperty_OSD_Switch_Value *pValue = (VideoProperty_OSD_Switch_Value *)pData;

	POWERSTATE PowerState;
	GetPowerState( &PowerState );

	if( PowerState == POWERSTATE_ON )
	{
		if (*pValue == Video_OSD_On && m_VideoProp.m_OSDSwitch == Video_OSD_Off)
		{
			ziva.OSD_EVEN_FIELD.Set( m_OSDStartAddr );
			ziva.OSD_ODD_FIELD.Set( m_OSDStartAddr + 32 );
			m_VideoProp.m_OSDSwitch = Video_OSD_On;
		}
		if (*pValue == Video_OSD_Off && m_VideoProp.m_OSDSwitch == Video_OSD_On)
		{
			ziva.OSD_EVEN_FIELD.Set( 0 );
			ziva.OSD_ODD_FIELD.Set( 0 );
			m_VideoProp.m_OSDSwitch = Video_OSD_Off;
		}
	};
	
	return TRUE;
};

// by oka
BOOL	CMPEGBoardHAL::SetVideoProperty_Magnify( PVOID pData )
{

	VideoMagnifyStruc *pValue = (VideoMagnifyStruc *)pData;

	POWERSTATE PowerState;
	GetPowerState( &PowerState );

	if( PowerState == POWERSTATE_ON )
	{
		ziva.Magnify(pValue->dwX, pValue->dwY, pValue->dwFactor);
	};
	
	return TRUE;
};
// by oka
BOOL	CMPEGBoardHAL::SetVideoProperty_ClosedCaptionData( PVOID pData )
{
	return FALSE;
}

//***************************************************************************
//	Video Property Functions( Get Series )
//***************************************************************************

BOOL	CMPEGBoardHAL::GetVideoProperty_TVSystem( PVOID pData )
{
	VideoProperty_TVSystem_Value *pValue = (VideoProperty_TVSystem_Value *)pData;
	*pValue = m_VideoProp.m_TVSystem;
	return TRUE;
};

BOOL	CMPEGBoardHAL::GetVideoProperty_AspectRatio( PVOID pData )
{
	VideoProperty_AspectRatio_Value *pValue = (VideoProperty_AspectRatio_Value *)pData;

	POWERSTATE PowerState;
	GetPowerState( &PowerState );

	if( PowerState == POWERSTATE_ON )
	{
		switch( (DWORD)ziva.DISPLAY_ASPECT_RATIO )
		{
			case 0x00:
				*pValue = Aspect_04_03;
				break;
			case 0x01:
				*pValue = Aspect_16_09;
				break;
			default:
				DBG_BREAK();
				return FALSE;
		};
		m_VideoProp.m_AspectRatio = *pValue;
		return TRUE;
	};

	*pValue = m_VideoProp.m_AspectRatio;
	return TRUE;
};

BOOL	CMPEGBoardHAL::GetVideoProperty_DisplayMode( PVOID pData )
{
	VideoProperty_DisplayMode_Value *pValue = (VideoProperty_DisplayMode_Value *)pData;

	POWERSTATE PowerState;
	GetPowerState( &PowerState );

	if( PowerState == POWERSTATE_ON )
	{
		switch( (DWORD)ziva.ASPECT_RATIO_MODE )
		{
			case 0x00:	*pValue = Display_Original;		break;
			case 0x01:	*pValue = Display_PanScan;		break;
			case 0x02:	*pValue = Display_LetterBox;	break;
			default:
				DBG_BREAK();
				return FALSE;
		};
		m_VideoProp.m_DisplayMode = *pValue;
		return TRUE;
	};
	*pValue = m_VideoProp.m_DisplayMode;
	return TRUE;
};

BOOL	CMPEGBoardHAL::GetVideoProperty_Resolution( PVOID pData )
{
	VideoSizeStruc *pValue = (VideoSizeStruc *)pData;
	m_VideoProp.m_Size = *pValue;
	return TRUE;
};

BOOL	CMPEGBoardHAL::GetVideoProperty_DigitalOut( PVOID pData )
{
	VideoProperty_DigitalOut_Value *pValue = (VideoProperty_DigitalOut_Value *)pData;
	*pValue = m_VideoProp.m_DigitalOut;
	return TRUE;
};

BOOL	CMPEGBoardHAL::GetVideoProperty_DigitalPalette( PVOID pData )
{
	Digital_Palette *pValue = (Digital_Palette *)pData;

	BYTE CpCtl;

	switch( pValue->Select )
	{
		case Video_Palette_Y:	CpCtl = 0x05;	break;
		case Video_Palette_Cb:	CpCtl = 0x06;	break;
		case Video_Palette_Cr:	CpCtl = 0x07;	break;
		default:
			DBG_BREAK();
			return FALSE;
	};

	POWERSTATE PowerState;
	GetPowerState( &PowerState );

	if( PowerState == POWERSTATE_ON )
	{
		// Select Palette and Clear Counter.
		ioif.luke2.IO_CPCNT = CpCtl;

		for ( int i = 0 ; i < 256; i ++ )
		{
			// Get Palette value
			pValue->pPalette[i] = ioif.luke2.IO_CPLT;
			m_VideoProp.m_DigitalPalette[ pValue->Select ][i] = pValue->pPalette[i];
		};
		return TRUE;
	};
	
	for ( int i = 0 ; i < 256; i ++ )
		pValue->pPalette[i] = m_VideoProp.m_DigitalPalette[ pValue->Select ][i];

	return TRUE;
};

BOOL	CMPEGBoardHAL::GetVideoProperty_APS( PVOID pData )
{
	VideoAPSStruc *pValue = (VideoAPSStruc *)pData;
	*pValue = m_VideoProp.m_APS;
	return TRUE;
};

BOOL	CMPEGBoardHAL::GetVideoProperty_ClosedCaption( PVOID pData )
{
	VideoProperty_ClosedCaption_Value *pValue = (VideoProperty_ClosedCaption_Value *)pData;
	*pValue = m_VideoProp.m_ClosedCaption;
	return TRUE;
};

BOOL	CMPEGBoardHAL::GetVideoProperty_OutputSource( PVOID pData )
{
	VideoProperty_OutputSource_Value *pValue = (VideoProperty_OutputSource_Value *)pData;
	*pValue = m_VideoProp.m_OutputSource;
	return TRUE;
};

BOOL	CMPEGBoardHAL::GetVideoProperty_CompositeOut( PVOID pData )
{
	VideoProperty_CompositeOut_Value *pValue = (VideoProperty_CompositeOut_Value *)pData;
	*pValue = m_VideoProp.m_CompositeOut;
	return TRUE;
};

BOOL	CMPEGBoardHAL::GetVideoProperty_SVideoOut( PVOID pData )
{
	VideoProperty_SVideoOut_Value *pValue = (VideoProperty_SVideoOut_Value *)pData;
	*pValue = m_VideoProp.m_SVideoOut;
	return TRUE;
};

BOOL	CMPEGBoardHAL::GetVideoProperty_SkipFieldControl( PVOID pData )
{
	VideoProperty_SkipFieldControl_Value *pValue = (VideoProperty_SkipFieldControl_Value *)pData;
	*pValue = m_VideoProp.m_SkipFieldControl;
	return TRUE;
};

BOOL	CMPEGBoardHAL::GetVideoProperty_FilmCamera( PVOID pData )
{
	VideoProperty_FilmCamera_Value *pValue = (VideoProperty_FilmCamera_Value *)pData;
	*pValue = m_VideoProp.m_FilmCamera;
	return TRUE;
};

// by oka
BOOL	CMPEGBoardHAL::GetVideoProperty_Digest( PVOID pData )
{
	return FALSE;
}
// by oka
BOOL	CMPEGBoardHAL::GetVideoProperty_OSDData( PVOID pData )
{
	return FALSE;
}
// by oka
BOOL	CMPEGBoardHAL::GetVideoProperty_OSDSwitch( PVOID pData )
{
	VideoProperty_OSD_Switch_Value *pValue = (VideoProperty_OSD_Switch_Value *)pData;
	*pValue = m_VideoProp.m_OSDSwitch;
	return TRUE;
}
// by oka
BOOL	CMPEGBoardHAL::GetVideoProperty_Magnify( PVOID pData )
{
	return FALSE;
}
// by oka
BOOL	CMPEGBoardHAL::GetVideoProperty_ClosedCaptionData( PVOID pData )
{
	return FALSE;
}

//***************************************************************************
// Audio property private functions( Set series )
//***************************************************************************
BOOL	CMPEGBoardHAL::SetAudioProperty_Type( PVOID pData )
{
	AudioProperty_Type_Value *pValue = (AudioProperty_Type_Value *)pData;

	POWERSTATE PowerState;
	GetPowerState( &PowerState );

	if( PowerState == POWERSTATE_ON )
	{
		switch( *pValue )
		{
			case AudioType_AC3:
				ziva.SelectStream( 2, m_AudioProp.m_StreamNo );	
				break;
			case AudioType_PCM:
				ziva.SelectStream( 4, m_AudioProp.m_StreamNo );
				break;
			case AudioType_MPEG1:
				ziva.SelectStream( 3, m_AudioProp.m_StreamNo );
				break;
			case AudioType_MPEG2:
				ziva.SelectStream( 3, m_AudioProp.m_StreamNo );
				break;
			default:
				DBG_BREAK();
				return FALSE;
		};

		DWORD Quant;
		GetAudioProperty_Quant( (PVOID)&Quant );
		SetAudioProperty_Quant( (PVOID)&Quant );
	};
	m_AudioProp.m_Type = *pValue;
	return TRUE;
};
BOOL	CMPEGBoardHAL::SetAudioProperty_Number( PVOID pData )
{
	DWORD *pValue = (DWORD *)pData;
	
	ASSERT( *pValue <= 7 );

	POWERSTATE PowerState;
	GetPowerState( &PowerState );

	if( PowerState == POWERSTATE_ON )
	{
		switch( m_AudioProp.m_Type )
		{
			case AudioType_AC3:
				ziva.SelectStream( 2, *pValue );	
				break;
			case AudioType_PCM:
				ziva.SelectStream( 4, *pValue );
				break;
			case AudioType_MPEG1:
				ziva.SelectStream( 3, *pValue );
				break;
			case AudioType_MPEG2:
				ziva.SelectStream( 3, *pValue );
				break;
			default:
				DBG_BREAK();
				return FALSE;
		};
	};
	
	m_AudioProp.m_StreamNo = *pValue;
	return TRUE;
};
BOOL	CMPEGBoardHAL::SetAudioProperty_Volume( PVOID pData )
{
	DWORD *pValue = (DWORD *)pData;

	ASSERT( *pValue <= 100 );

	POWERSTATE PowerState;
	GetPowerState( &PowerState );

	if( PowerState == POWERSTATE_ON )
		ziva.AUDIO_ATTENUATION = (9600 - (*pValue) * 96) /100;

	m_AudioProp.m_Volume = *pValue;
	return TRUE;
};
BOOL	CMPEGBoardHAL::SetAudioProperty_Sampling( PVOID pData )
{
	DWORD *pValue = (DWORD *)pData;

	POWERSTATE PowerState;
	GetPowerState( &PowerState );

	if( PowerState == POWERSTATE_ON )
	{
		switch( *pValue )
		{
			case 32000:	/*	ziva.NEW_AUDIO_MODE = 0x7;*/	break;	// 32 kHz
			case 96000:	/*	ziva.NEW_AUDIO_MODE = 0x3;*/	break;	// 96 kHz
			case 48000:	/*	ziva.NEW_AUDIO_MODE = 0x2;*/	break;	// 48 kHz
			case 44100:	/*	ziva.NEW_AUDIO_MODE = 0x1;*/	break;	// 44.1 kHz
			default:
				DBG_BREAK();
				return FALSE;
		};
	};
	
	m_AudioProp.m_Sampling = *pValue;

	return TRUE;
};
BOOL	CMPEGBoardHAL::SetAudioProperty_Channel( PVOID pData )
{
	DWORD *pValue = (DWORD *)pData;

	ASSERT(  1 <= *pValue && *pValue <= 8 );
	
	// ZiVA -DS chip has 2 chanel.
	if( *pValue != 2 )
	{
		DBG_BREAK();
		return FALSE;
	};
	
	m_AudioProp.m_ChannelNo = *pValue;
	return TRUE;
};
BOOL	CMPEGBoardHAL::SetAudioProperty_Quant( PVOID pData )
{
	DWORD *pValue = (DWORD *)pData;

	POWERSTATE PowerState;
	GetPowerState( &PowerState );

	if( PowerState == POWERSTATE_ON )
	{
		ioif.luke2.IO_CONT = (ioif.luke2.IO_CONT & 0xfffff8) | 0x72000000;
	};
	m_AudioProp.m_Quant = *pValue;
	return TRUE;
};
BOOL	CMPEGBoardHAL::SetAudioProperty_AudioOut( PVOID pData )
{
	AudioProperty_AudioOut_Value *pValue = (AudioProperty_AudioOut_Value *)pData;
	
	POWERSTATE PowerState;
	GetPowerState( &PowerState );

	if( *pValue != AudioOut_Encoded && *pValue != AudioOut_Decoded )
	{
		DBG_BREAK();
		return FALSE;
	};

	if( PowerState == POWERSTATE_ON )
	{

		if( ( ziva.AUDIO_CONFIG & 0x02 ) != 0 )
		{
			switch( *pValue )
			{
				case AudioOut_Encoded:
		            ziva.AUDIO_CONFIG &= 0xfffffffe;
		            break;
				case AudioOut_Decoded:
		            ziva.AUDIO_CONFIG |= 0x01;
		            break;
				default:
					DBG_BREAK();
					return FALSE;
			};

			CTimeOut		TimeOut( 1000, 1, m_pKernelObj );   	// wait 1s, sleep 1ms

		    ziva.NEW_AUDIO_CONFIG = 0x01;
			while( TRUE )
			{
				if( 0 ==  ziva.NEW_AUDIO_CONFIG )
					break;
				TimeOut.Sleep();
				if( TimeOut.CheckTimeOut()==TRUE )
				{
					DBG_BREAK();
					return FALSE;
				};
			}
		}
		else	// ziva micro code bug.
		{
			if( *pValue == AudioOut_Encoded )
			{
				ziva.AUDIO_CONFIG = (ziva.AUDIO_CONFIG & 0xfffffffc) | 0x02;
				CTimeOut		TimeOut( 1000, 1, m_pKernelObj );   	// wait 1s, sleep 1ms
			    ziva.NEW_AUDIO_CONFIG = 0x01;
				while( TRUE )
				{
					if( 0 ==  ziva.NEW_AUDIO_CONFIG )
						break;
					TimeOut.Sleep();
					if( TimeOut.CheckTimeOut()==TRUE )
					{
						DBG_BREAK();
						return FALSE;
					};
				}
				ziva.AUDIO_CONFIG = (ziva.AUDIO_CONFIG & 0xfffffffc) | 0x00;
				CTimeOut		TimeOut2( 1000, 1, m_pKernelObj );   	// wait 1s, sleep 1ms
			    ziva.NEW_AUDIO_CONFIG = 0x01;
				while( TRUE )
				{
					if( 0 ==  ziva.NEW_AUDIO_CONFIG )
						break;
					TimeOut2.Sleep();
					if( TimeOut2.CheckTimeOut()==TRUE )
					{
						DBG_BREAK();
						return FALSE;
					};
				}

			};
			if( *pValue == AudioOut_Decoded )
			{
				ziva.AUDIO_CONFIG = (ziva.AUDIO_CONFIG & 0xfffffffc) | 0x03;
				CTimeOut		TimeOut( 1000, 1, m_pKernelObj );   	// wait 1s, sleep 1ms
			    ziva.NEW_AUDIO_CONFIG = 0x01;
				while( TRUE )
				{
					if( 0 ==  ziva.NEW_AUDIO_CONFIG )
						break;
					TimeOut.Sleep();
					if( TimeOut.CheckTimeOut()==TRUE )
					{
						DBG_BREAK();
						return FALSE;
					};
				}
				ziva.AUDIO_CONFIG = (ziva.AUDIO_CONFIG & 0xfffffffc) | 0x01;
				CTimeOut		TimeOut2( 1000, 1, m_pKernelObj );   	// wait 1s, sleep 1ms
			    ziva.NEW_AUDIO_CONFIG = 0x01;
				while( TRUE )
				{
					if( 0 ==  ziva.NEW_AUDIO_CONFIG )
						break;
					TimeOut2.Sleep();
					if( TimeOut2.CheckTimeOut()==TRUE )
					{
						DBG_BREAK();
						return FALSE;
					};
				}
			};
		};
	};
	m_AudioProp.m_OutType = *pValue;
	return TRUE;
};
BOOL	CMPEGBoardHAL::SetAudioProperty_Cgms( PVOID pData )
{
	AudioProperty_Cgms_Value *pValue = (AudioProperty_Cgms_Value *)pData;

	POWERSTATE PowerState;
	GetPowerState( &PowerState );

	if( PowerState == POWERSTATE_ON )
	{
		switch( *pValue )
		{
			case AudioCgms_Off:
				ziva.IEC_958_CHANNEL_STATUS_BITS = ( ziva.IEC_958_CHANNEL_STATUS_BITS & 0xfffffffc ) | 0x01;
	            break;
			case AudioCgms_1:
				ziva.IEC_958_CHANNEL_STATUS_BITS = ( ziva.IEC_958_CHANNEL_STATUS_BITS & 0xfffffffc ) | 0x00;
	            break;
			case AudioCgms_On:
				ziva.IEC_958_CHANNEL_STATUS_BITS = ( ziva.IEC_958_CHANNEL_STATUS_BITS & 0xfffffffc ) | 0x02;
	            break;
			default:
				DBG_BREAK();
				return FALSE;
		};

		CTimeOut		TimeOut( 1000, 1, m_pKernelObj );   	// wait 1s, sleep 1ms

	    ziva.NEW_AUDIO_CONFIG = 0x01;
		while( TRUE )
		{
			if( 0 ==  ziva.NEW_AUDIO_CONFIG )
				break;
			TimeOut.Sleep();
			if( TimeOut.CheckTimeOut()==TRUE )
			{
				DBG_BREAK();
				return FALSE;
			};
		}
	};
	
	m_AudioProp.m_Cgms = *pValue;
	return TRUE;
};

BOOL	CMPEGBoardHAL::SetAudioProperty_AnalogOut( PVOID pData )
{
	AudioProperty_AnalogOut_Value *pValue = (AudioProperty_AnalogOut_Value *)pData;

	m_AudioProp.m_AnalogOut = *pValue;
	return TRUE;
};

BOOL	CMPEGBoardHAL::SetAudioProperty_DigitalOut( PVOID pData )
{
	AudioProperty_DigitalOut_Value *pValue = (AudioProperty_DigitalOut_Value *)pData;

	POWERSTATE PowerState;
	GetPowerState( &PowerState );

	if( PowerState == POWERSTATE_ON )
	{
		switch( *pValue )
		{
			case AudioDigitalOut_On:
				ziva.AUDIO_CONFIG = ziva.AUDIO_CONFIG | 0x02;		// IEC_958 on
                ioif.luke2.IO_CONT = (( ioif.luke2.IO_CONT & 0xfffffff8 ) | 0x40 );   // optical out on only for SanJose
				break;

			case AudioDigitalOut_Off:
				ziva.AUDIO_CONFIG = ziva.AUDIO_CONFIG & 0xfffffffd;		// IEC_958 off
                ioif.luke2.IO_CONT = (( ioif.luke2.IO_CONT & 0xfffffff8 ) &
                                    0xffffffbf);   // optical out off only for SanJose
				break;

			default:
				return FALSE;
		};

		CTimeOut		TimeOut( 1000, 1, m_pKernelObj );   	// wait 1s, sleep 1ms

	    ziva.NEW_AUDIO_CONFIG = 0x01;
		while( TRUE )
		{
			if( 0 ==  ziva.NEW_AUDIO_CONFIG )
				break;
			TimeOut.Sleep();
			if( TimeOut.CheckTimeOut()==TRUE )
			{
				DBG_BREAK();
				return FALSE;
			};
		}
	};

	m_AudioProp.m_DigitalOut = *pValue;
	return TRUE;
};

BOOL	CMPEGBoardHAL::SetAudioProperty_AC3DRangeLowBoost( PVOID pData )
{
	DWORD *pValue = (DWORD *)pData;

	if( *pValue > 128 )
		return FALSE;

	POWERSTATE PowerState;
	GetPowerState( &PowerState );

	if( PowerState == POWERSTATE_ON )
		ziva.AC3_LOW_BOOST = *pValue;

	m_AudioProp.m_AC3DRangeLowBoost = *pValue;
	return TRUE;
};

BOOL	CMPEGBoardHAL::SetAudioProperty_AC3DRangeHighCut( PVOID pData )
{
	DWORD *pValue = (DWORD *)pData;

	if( *pValue > 128 )
		return FALSE;

	POWERSTATE PowerState;
	GetPowerState( &PowerState );

	if( PowerState == POWERSTATE_ON )
		ziva.AC3_HIGH_CUT = *pValue;

	m_AudioProp.m_AC3DRangeHighCut = *pValue;
	return TRUE;
};

BOOL	CMPEGBoardHAL::SetAudioProperty_AC3OperateMode( PVOID pData )
{
	AudioProperty_AC3OperateMode_Value *pValue = (AudioProperty_AC3OperateMode_Value *)pData;

	POWERSTATE PowerState;
	GetPowerState( &PowerState );

	if( PowerState == POWERSTATE_ON )
	{
		switch( *pValue )
		{
			case AC3OperateLine:	ziva.AC3_OPERATIONAL_MODE = 0;	break;
			case AC3OperateRF:		ziva.AC3_OPERATIONAL_MODE = 1;	break;
			case AC3OperateCustom0:	ziva.AC3_OPERATIONAL_MODE = 2;	break;
			case AC3OperateCustom1:	ziva.AC3_OPERATIONAL_MODE = 3;	break;
			default:
				return FALSE;
		};
	};
	m_AudioProp.m_AC3OperateMode = *pValue;
	return TRUE;
};

BOOL	CMPEGBoardHAL::SetAudioProperty_AC3OutputMode( PVOID pData )
{
	AudioProperty_AC3OutputMode_Value *pValue = (AudioProperty_AC3OutputMode_Value *)pData;

	POWERSTATE PowerState;
	GetPowerState( &PowerState );

	if( PowerState == POWERSTATE_ON )
	{
		switch( *pValue )
		{
			case AC3Output_Default:	    ziva.AC3_OUTPUT_MODE = 0;	break;
			case AC3Output_Karaoke:	    ziva.AC3_OUTPUT_MODE = 2;	break;
			case AC3Output_Surround:    ziva.AC3_OUTPUT_MODE = 0;	break;
			default:
				return FALSE;
		};
	};
	m_AudioProp.m_AC3OutputMode = *pValue;
	return TRUE;
};

//***************************************************************************
// Audio property private functions( Get series )
//***************************************************************************
BOOL	CMPEGBoardHAL::GetAudioProperty_Type( PVOID pData )
{
	AudioProperty_Type_Value *pValue = (AudioProperty_Type_Value *)pData;
	*pValue = m_AudioProp.m_Type;
	return TRUE;
};
BOOL	CMPEGBoardHAL::GetAudioProperty_Number( PVOID pData )
{
	DWORD *pValue = (DWORD *)pData;
	*pValue = m_AudioProp.m_StreamNo;
	return TRUE;
};
BOOL	CMPEGBoardHAL::GetAudioProperty_Volume( PVOID pData )
{
	DWORD *pValue = (DWORD *)pData;
	*pValue = m_AudioProp.m_Volume;
	return TRUE;
};
BOOL	CMPEGBoardHAL::GetAudioProperty_Sampling( PVOID pData )
{
	DWORD *pValue = (DWORD *)pData;
	*pValue = m_AudioProp.m_Sampling;
	return TRUE;
};
BOOL	CMPEGBoardHAL::GetAudioProperty_Channel( PVOID pData )
{
	DWORD *pValue = (DWORD *)pData;
	*pValue = m_AudioProp.m_ChannelNo;
	return TRUE;
};
BOOL	CMPEGBoardHAL::GetAudioProperty_Quant( PVOID pData )
{
	DWORD *pValue = (DWORD *)pData;
	*pValue = m_AudioProp.m_Quant;
	return TRUE;
};
BOOL	CMPEGBoardHAL::GetAudioProperty_AudioOut( PVOID pData )
{
	AudioProperty_AudioOut_Value *pValue = (AudioProperty_AudioOut_Value *)pData;
	*pValue = m_AudioProp.m_OutType;
	return TRUE;
};
BOOL	CMPEGBoardHAL::GetAudioProperty_Cgms( PVOID pData )
{
	AudioProperty_Cgms_Value *pValue = (AudioProperty_Cgms_Value *)pData;
	*pValue = m_AudioProp.m_Cgms;
	return TRUE;
};
BOOL	CMPEGBoardHAL::GetAudioProperty_AnalogOut( PVOID pData )
{
	AudioProperty_AnalogOut_Value *pValue = (AudioProperty_AnalogOut_Value *)pData;

	*pValue = m_AudioProp.m_AnalogOut;
	return TRUE;
};

BOOL	CMPEGBoardHAL::GetAudioProperty_DigitalOut( PVOID pData )
{
	AudioProperty_DigitalOut_Value *pValue = (AudioProperty_DigitalOut_Value *)pData;

	*pValue = m_AudioProp.m_DigitalOut;
	return TRUE;
};

BOOL	CMPEGBoardHAL::GetAudioProperty_AC3DRangeLowBoost( PVOID pData )
{
	DWORD *pValue = (DWORD *)pData;

	*pValue = m_AudioProp.m_AC3DRangeLowBoost;
	return TRUE;
};

BOOL	CMPEGBoardHAL::GetAudioProperty_AC3DRangeHighCut( PVOID pData )
{
	DWORD *pValue = (DWORD *)pData;

	*pValue = m_AudioProp.m_AC3DRangeHighCut;
	return TRUE;
};

BOOL	CMPEGBoardHAL::GetAudioProperty_AC3OperateMode( PVOID pData )
{
	AudioProperty_AC3OperateMode_Value *pValue = (AudioProperty_AC3OperateMode_Value *)pData;

	*pValue = m_AudioProp.m_AC3OperateMode;
	return TRUE;
};

BOOL	CMPEGBoardHAL::GetAudioProperty_AC3OutputMode( PVOID pData )
{
	AudioProperty_AC3OutputMode_Value *pValue = (AudioProperty_AC3OutputMode_Value *)pData;

	*pValue = m_AudioProp.m_AC3OutputMode;
	return TRUE;
};

//***************************************************************************
// Subpic property private functions( Set series )
//***************************************************************************
BOOL	CMPEGBoardHAL::SetSubpicProperty_Number( PVOID pData )
{
	DWORD *pValue = (DWORD *)pData;
	ASSERT( *pValue <= 31 );
	
	POWERSTATE PowerState;
	GetPowerState( &PowerState );

	if( PowerState == POWERSTATE_ON )
		ziva.SelectStream( 1, *pValue );

	m_SubpicProp.m_StreamNo = *pValue;
	return TRUE;
};
BOOL	CMPEGBoardHAL::SetSubpicProperty_Palette( PVOID pData )
{
	UCHAR *pValue = (UCHAR *)pData;
	DWORD Addr,Data;
	int i;
	
	POWERSTATE PowerState;
	GetPowerState( &PowerState );

	if( PowerState == POWERSTATE_ON )
	{
		Addr = ziva.SUB_PICTURE_PALETTE_START;

		for( i = 0 ; i < 16 ; i ++ )
		{
			Data = (DWORD)(pValue[i*3]) * 0x10000 + (DWORD)(pValue[i*3 +1]) * 0x100 + (DWORD)(pValue[i*3 +2]);
			ziva.ZiVAWriteMemory( Addr + i*4, Data );
		};

		ziva.NEW_SUBPICTURE_PALETTE = 0x01;
	};
	
	for( i = 0 ; i < sizeof( m_SubpicProp.m_Palette ) ; i ++ )
		m_SubpicProp.m_Palette[ i ] = pValue[ i ];

	return TRUE;
};
BOOL	CMPEGBoardHAL::SetSubpicProperty_Hilight( PVOID pData )
{
	SubpHlightStruc *pValue = (SubpHlightStruc *)pData;

	POWERSTATE PowerState;
	GetPowerState( &PowerState );

	if( PowerState == POWERSTATE_ON )
	{
		switch( pValue->Hlight_Switch )
		{
			case Hlight_On:
//                m_pKernelObj->Sleep( 40 );  // wait 40msec
				ziva.HighLight2( pValue->Hlight_Contrast, pValue->Hlight_Color,
					( pValue->Hlight_StartY << 12 ) | pValue->Hlight_EndY,
					( pValue->Hlight_StartX << 12 ) | pValue->Hlight_EndX );
				break;
			case Hlight_Off:
				ziva.HighLight2( 0, 0, 0, 0 );
				break;
			default:
				DBG_BREAK();
				return FALSE;
		};
	};
	
	m_SubpicProp.m_Hlight = *pValue;
	return TRUE;
};
BOOL	CMPEGBoardHAL::SetSubpicProperty_State( PVOID pData )
{
	SubpicProperty_State_Value *pValue = (SubpicProperty_State_Value *)pData;

	POWERSTATE PowerState;
	GetPowerState( &PowerState );

	if( PowerState == POWERSTATE_ON )
	{
		switch( *pValue )
		{
			case Subpic_On:
				ziva.SUBPICTURE_ENABLE = 0x01;
				break;
			case Subpic_Off:
				ziva.SUBPICTURE_ENABLE = 0x00;
				break;
			default:
				DBG_BREAK();
				return FALSE;
		};
	};
	
	m_SubpicProp.m_OutType = *pValue;
	return TRUE;
};
// by oka
BOOL	CMPEGBoardHAL::SetSubpicProperty_HilightButton( PVOID pData )
{
    DWORD ret = ZIVARESULT_NOERROR;
	SubpHlightButtonStruc *pValue = (SubpHlightButtonStruc *)pData;

	POWERSTATE PowerState;
	GetPowerState( &PowerState );

	if( PowerState == POWERSTATE_ON )
	{
		ret = ziva.HighLight( pValue->Hlight_Button,
								pValue->Hlight_Action );
	};
	m_SubpicProp.m_HlightButton = *pValue;
	
	if (ret == ZIVARESULT_NOERROR)
		return TRUE;
	else
		return FALSE;
};

BOOL    CMPEGBoardHAL::SetSubpicProperty_FlushBuff( PVOID pData )
{
    DWORD   dwValue =  m_SubpicProp.m_StreamNo;
	POWERSTATE PowerState;
	GetPowerState( &PowerState );

    if( PowerState == POWERSTATE_ON ){
        ziva.SelectStream( 1, 0xffff );         // 0xffff : discard
        ziva.SelectStream( 1, dwValue );
    }
    return TRUE;
};

//***************************************************************************
// Subpic property private functions( Get series )
//***************************************************************************
BOOL	CMPEGBoardHAL::GetSubpicProperty_Number( PVOID pData )
{
	DWORD *pValue = (DWORD *)pData;
	*pValue = m_SubpicProp.m_StreamNo;
	return TRUE;
};
BOOL	CMPEGBoardHAL::GetSubpicProperty_Palette( PVOID pData )
{
	UCHAR *pValue = (UCHAR *)pData;
	for( int i = 0 ; i < sizeof( m_SubpicProp.m_Palette ) ; i ++ )
		pValue[ i ] = m_SubpicProp.m_Palette[ i ];

	return TRUE;
};
BOOL	CMPEGBoardHAL::GetSubpicProperty_Hilight( PVOID pData )
{
	SubpHlightStruc *pValue = (SubpHlightStruc *)pData;
	*pValue = m_SubpicProp.m_Hlight;
	return TRUE;
};
BOOL	CMPEGBoardHAL::GetSubpicProperty_State( PVOID pData )
{
	SubpicProperty_State_Value *pValue = (SubpicProperty_State_Value *)pData;
	*pValue = m_SubpicProp.m_OutType;
	return TRUE;
};
// by oka
BOOL	CMPEGBoardHAL::GetSubpicProperty_HilightButton( PVOID pData )
{
	SubpHlightButtonStruc *pValue = (SubpHlightButtonStruc *)pData;
	*pValue = m_SubpicProp.m_HlightButton;
	return TRUE;
};

BOOL    CMPEGBoardHAL::GetSubpicProperty_FlushBuff( PVOID pData )
{
	DWORD *pValue = (DWORD *)pData;
	*pValue = m_SubpicProp.m_StreamNo;
	return TRUE;
};

//***************************************************************************
//	End of
//***************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\tecra\classlib.h ===
/*
NXCuwb_[t@C
iNP2)@Sachiko Yasukawa
*/
//     Date    |   Author     |  Description
//  -----------+--------------+--------------------------------------------
//  1998.03.27 |  Hideki Yagi | Change the specification about GetSTC().
//             |              | Change the specification about
//             |              | Get***Property().
//

#define ISMIXSTREAM(type) ((type == Dvd || type == VideoCD) ? TRUE : FALSE)

typedef enum{
	Video,
	Audio,
	Subpicture,
	Dvd,
	VideoCD,
} STREAMTYPE;

class CBaseStream;

class IMPEGBoardBaseState
{
public:
	virtual BOOL ChangePowerOff(IClassLibHAL *, IHALStreamControl *)=0;
	virtual BOOL ChangeStop(IClassLibHAL *, IHALStreamControl *, CBaseStream *)=0;
	virtual BOOL ChangePlay(IClassLibHAL *, IHALStreamControl *)=0;
	virtual BOOL ChangePause(IClassLibHAL *, IHALStreamControl *)=0;
	virtual BOOL ChangePauseViaSingleStep(IClassLibHAL *, IHALStreamControl *)=0;
	virtual BOOL ChangeSlow(DWORD, IClassLibHAL *, IHALStreamControl *)=0;
	virtual BOOL ChangeScan(DWORD, IClassLibHAL *, IHALStreamControl *)=0;
};

class CPowerOffState : public IMPEGBoardBaseState
{
public:
	void Init(IMPEGBoardState *pMPEGBoardState){m_pMPEGBoardState = pMPEGBoardState;};
	BOOL ChangePowerOff(IClassLibHAL *, IHALStreamControl *);
	BOOL ChangeStop(IClassLibHAL *, IHALStreamControl *, CBaseStream *);
	BOOL ChangePlay(IClassLibHAL *, IHALStreamControl *);
	BOOL ChangePause(IClassLibHAL *, IHALStreamControl *);
	BOOL ChangePauseViaSingleStep(IClassLibHAL *, IHALStreamControl *);
	BOOL ChangeSlow(DWORD, IClassLibHAL *, IHALStreamControl *);
	BOOL ChangeScan(DWORD, IClassLibHAL *, IHALStreamControl *);
	
private:
	IMPEGBoardState *m_pMPEGBoardState;
};

class CStopState : public IMPEGBoardBaseState
{
public:
	void Init(IMPEGBoardState *pMPEGBoardState){m_pMPEGBoardState = pMPEGBoardState;};
	BOOL ChangePowerOff(IClassLibHAL *, IHALStreamControl *);
	BOOL ChangeStop(IClassLibHAL *, IHALStreamControl *, CBaseStream *);
	BOOL ChangePlay(IClassLibHAL *, IHALStreamControl *);
	BOOL ChangePause(IClassLibHAL *, IHALStreamControl *);
	BOOL ChangePauseViaSingleStep(IClassLibHAL *, IHALStreamControl *);
	BOOL ChangeSlow(DWORD, IClassLibHAL *, IHALStreamControl *);
	BOOL ChangeScan(DWORD, IClassLibHAL *, IHALStreamControl *);

private:
	IMPEGBoardState *m_pMPEGBoardState;
};

class CPlayState : public IMPEGBoardBaseState
{
public:
	void Init(IMPEGBoardState *pMPEGBoardState){m_pMPEGBoardState = pMPEGBoardState;};
	BOOL ChangePowerOff(IClassLibHAL *, IHALStreamControl *);
	BOOL ChangeStop(IClassLibHAL *, IHALStreamControl *, CBaseStream *);
	BOOL ChangePlay(IClassLibHAL *, IHALStreamControl *);
	BOOL ChangePause(IClassLibHAL *, IHALStreamControl *);
	BOOL ChangePauseViaSingleStep(IClassLibHAL *, IHALStreamControl *);
	BOOL ChangeSlow(DWORD, IClassLibHAL *, IHALStreamControl *);
	BOOL ChangeScan(DWORD, IClassLibHAL *, IHALStreamControl *);

private:
	IMPEGBoardState *m_pMPEGBoardState;
};

class CPauseState : public IMPEGBoardBaseState
{
public:
	void Init(IMPEGBoardState *pMPEGBoardState){m_pMPEGBoardState = pMPEGBoardState;};
	BOOL ChangePowerOff(IClassLibHAL *, IHALStreamControl *);
	BOOL ChangeStop(IClassLibHAL *, IHALStreamControl *, CBaseStream *);
	BOOL ChangePlay(IClassLibHAL *, IHALStreamControl *);
	BOOL ChangePause(IClassLibHAL *, IHALStreamControl *);
	BOOL ChangePauseViaSingleStep(IClassLibHAL *, IHALStreamControl *);
	BOOL ChangeSlow(DWORD, IClassLibHAL *, IHALStreamControl *);
	BOOL ChangeScan(DWORD, IClassLibHAL *, IHALStreamControl *);

private:
	IMPEGBoardState *m_pMPEGBoardState;
};

class CSlowState : public IMPEGBoardBaseState
{
public:
	void Init(IMPEGBoardState *pMPEGBoardState){m_pMPEGBoardState = pMPEGBoardState;};
	BOOL ChangePowerOff(IClassLibHAL *, IHALStreamControl *);
	BOOL ChangeStop(IClassLibHAL *, IHALStreamControl *, CBaseStream *);
	BOOL ChangePlay(IClassLibHAL *, IHALStreamControl *);
	BOOL ChangePause(IClassLibHAL *, IHALStreamControl *);
	BOOL ChangePauseViaSingleStep(IClassLibHAL *, IHALStreamControl *);
	BOOL ChangeSlow(DWORD, IClassLibHAL *, IHALStreamControl *);
	BOOL ChangeScan(DWORD, IClassLibHAL *, IHALStreamControl *);

private:
	IMPEGBoardState *m_pMPEGBoardState;
};

class CScanState : public IMPEGBoardBaseState
{
public:
	void Init(IMPEGBoardState *pMPEGBoardState){m_pMPEGBoardState = pMPEGBoardState;};
	BOOL ChangePowerOff(IClassLibHAL *, IHALStreamControl *);
	BOOL ChangeStop(IClassLibHAL *, IHALStreamControl *, CBaseStream *);
	BOOL ChangePlay(IClassLibHAL *, IHALStreamControl *);
	BOOL ChangePause(IClassLibHAL *, IHALStreamControl *);
	BOOL ChangePauseViaSingleStep(IClassLibHAL *, IHALStreamControl *);
	BOOL ChangeSlow(DWORD, IClassLibHAL *, IHALStreamControl *);
	BOOL ChangeScan(DWORD, IClassLibHAL *, IHALStreamControl *);

private:
	IMPEGBoardState *m_pMPEGBoardState;
};


class CMPEGBoardState : public IMPEGBoardState
{
	friend class CMPEGBoard;
	friend class CBaseStream;
public:
	BOOL Init(){ m_pStateObject = (IMPEGBoardBaseState *)&m_PowerOffState; m_State = PowerOff; 
				m_PowerOffState.Init(this); m_StopState.Init(this); m_PauseState.Init(this); m_PlayState.Init(this);
				m_ScanState.Init(this); m_SlowState.Init(this); return TRUE;};

//
	CMPEGBoardState(){Init();};
	IMPEGBoardBaseState *GetMPEGBoardState(){return m_pStateObject;};
    LIBSTATE GetState(){ return m_State;};
    void SetState(LIBSTATE);

private:
	//IMPEGBoardState *m_this;
	IMPEGBoardBaseState *m_pStateObject;
	CPowerOffState m_PowerOffState;
	CStopState m_StopState;
	CPauseState m_PauseState;
	CPlayState m_PlayState;
	CSlowState m_SlowState;
	CScanState m_ScanState;
    LIBSTATE m_State;
};

class CTransfer;

class CClassLibEvent : public IMPEGBoardEvent
{
public:
	void Advice(PVOID);
	HALEVENTTYPE GetEventType(){return m_Type;};

	IMBoardListItem* GetNext( void ){ return m_pNextEvent;};
	void SetNext( IMBoardListItem *Item ){ m_pNextEvent = Item;};
	
	CClassLibEvent(){m_pNextEvent = NULL; m_pTransfer = NULL; m_Type = ClassLibEvent_SendData;};
	void SetTransfer(CTransfer *pTransfer){m_pTransfer = pTransfer;};
	void SetEventType(HALEVENTTYPE type){ m_Type = type;};

private:
	HALEVENTTYPE m_Type;
	IMBoardListItem *m_pNextEvent;
	CTransfer *m_pTransfer;
};

class CBaseStream : public IBaseStream 
{
	friend class CMPEGBoard;

public:

	//IBaseStream
	BOOL Init();
	BOOL Play();
	BOOL Stop();
	BOOL Pause();
	BOOL Slow(DWORD);
	BOOL Scan(DWORD);
	BOOL SingleStep();
	LIBSTATE GetState();
	BOOL SendData(IMPEGBuffer *);
 	BOOL SetStateObject(IMPEGBoardState *pMPEGBoardStateObject);
	BOOL SetTransferObject(ITransfer *pTransfer);
	BOOL SetTransferMode(HALSTREAMMODE);
    BOOL SetDataDirection(DirectionType type );
    BOOL GetDataDirection(DirectionType *ptype );
   
//
	CBaseStream();
	IMPEGBoardBaseState *GetStateObject();
	IClassLibHAL *GetClassLibHAL(){return m_pIHAL;};
	IHALStreamControl *GetHALStreamControl(){return m_pIStreamHAL;};
	IMPEGBoardBaseState *GetIMPEGBoardState(){ return (((CMPEGBoardState *)m_pMPEGBoardStateObject)->GetMPEGBoardState());};
	void FlushTransferBuffer();
	IBaseStream *GetNextStream(){return m_pNextStreamObject;};
	IBaseStream *GetPrevStream(){return m_pPrevStreamObject;};
	void SetNextStream(IBaseStream *pNextStreamObject){m_pNextStreamObject = (CBaseStream *)pNextStreamObject;};
	void SetPrevStream(IBaseStream *pPrevStreamObject){m_pPrevStreamObject = (CBaseStream *)pPrevStreamObject;};
	BOOL ISMIXSTREAMTYPE(STREAMTYPE StreamType){return (StreamType == VideoCD) ? TRUE : ((StreamType == Dvd) ? TRUE : FALSE);};

protected:
	CBaseStream *m_pNextStreamObject;
	CBaseStream *m_pPrevStreamObject;
	STREAMTYPE m_StreamType;
	IMPEGBoardState *m_pMPEGBoardStateObject;

	IClassLibHAL *m_pIHAL;
	IHALStreamControl *m_pIStreamHAL;
	ITransfer *m_pTransfer;

	UCHAR m_DriveChlgKey[10];
	UCHAR m_DecoderChlgKey[10];
	UCHAR m_DriveResKey[5];
	UCHAR m_DecoderResKey[5];
};

class CVideoStream : public CBaseStream, public IVideoProperty, public ICopyProtectProperty
{
public:
	BOOL CppInit();
	BOOL GetVideoProperty(VIDEOPROPTYPE PropertyType, PVOID pProperty);
	BOOL SetVideoProperty(VIDEOPROPTYPE PropertyType, PVOID pProperty);
	BOOL SetChlgKey(UCHAR *);
	BOOL GetChlgKey(UCHAR *);
	BOOL SetDVDKey1(UCHAR *);
    BOOL GetDVDKey2(UCHAR *);
	BOOL SetTitleKey(UCHAR *);
	BOOL SetDiscKey(UCHAR *);
	
	CVideoStream(){m_StreamType = Video;};
};

class CAudioStream : public CBaseStream, public IAudioProperty, public ICopyProtectProperty
{
public:
	BOOL CppInit();
	BOOL GetAudioProperty(AUDIOPROPTYPE PropertyType, PVOID pProperty);
	BOOL SetAudioProperty(AUDIOPROPTYPE PropertyType, PVOID pProperty);
	BOOL SetChlgKey(UCHAR *);
	BOOL GetChlgKey(UCHAR *);
	BOOL SetDVDKey1(UCHAR *);
	BOOL GetDVDKey2(UCHAR *);
	BOOL SetTitleKey(UCHAR *);
	BOOL SetDiscKey(UCHAR *);
	
	CAudioStream(){m_StreamType = Audio;};
};

class CSubpicStream : public CBaseStream, public ISubpicProperty,  public ICopyProtectProperty
{
public:
	BOOL CppInit();
	BOOL GetSubpicProperty(SUBPICPROPTYPE PropertyType, PVOID pProperty);
	BOOL SetSubpicProperty(SUBPICPROPTYPE PropertyType, PVOID pProperty);
	BOOL SetChlgKey(UCHAR *);
	BOOL GetChlgKey(UCHAR *);
	BOOL SetDVDKey1(UCHAR *);
	BOOL GetDVDKey2(UCHAR *);
	BOOL SetTitleKey(UCHAR *);
	BOOL SetDiscKey(UCHAR *);
	
	CSubpicStream(){m_StreamType = Subpicture;};
};

class CVideoCDStream : public CBaseStream, public IVideoProperty, public IAudioProperty, public ICopyProtectProperty
{
public:
	BOOL CppInit();
	BOOL GetVideoProperty(VIDEOPROPTYPE PropertyType, PVOID pProperty);
	BOOL SetVideoProperty(VIDEOPROPTYPE PropertyType, PVOID pProperty);
	BOOL GetAudioProperty(AUDIOPROPTYPE PropertyType, PVOID pProperty);
	BOOL SetAudioProperty(AUDIOPROPTYPE PropertyType, PVOID pProperty);
	BOOL SetChlgKey(UCHAR *);
	BOOL GetChlgKey(UCHAR *);
	BOOL SetDVDKey1(UCHAR *);
	BOOL GetDVDKey2(UCHAR *);
	BOOL SetTitleKey(UCHAR *);
	BOOL SetDiscKey(UCHAR *);

	CVideoCDStream(){ m_StreamType = VideoCD;};
};

class CDVDStream : public CBaseStream, public IVideoProperty, public IAudioProperty,public ISubpicProperty, public ICopyProtectProperty
{
public:
	BOOL CppInit();
	BOOL GetVideoProperty(VIDEOPROPTYPE PropertyType, PVOID pProperty);
	BOOL SetVideoProperty(VIDEOPROPTYPE PropertyType, PVOID pProperty);
	BOOL GetAudioProperty(AUDIOPROPTYPE PropertyType, PVOID pProperty);
	BOOL SetAudioProperty(AUDIOPROPTYPE PropertyType, PVOID pProperty);
	BOOL GetSubpicProperty(SUBPICPROPTYPE PropertyType, PVOID pProperty);
	BOOL SetSubpicProperty(SUBPICPROPTYPE PropertyType, PVOID pProperty);
	BOOL SetChlgKey(UCHAR *);
    BOOL GetChlgKey(UCHAR *);
	BOOL SetDVDKey1(UCHAR *);
	BOOL GetDVDKey2(UCHAR *);
	BOOL SetTitleKey(UCHAR *);
	BOOL SetDiscKey(UCHAR *);
    
    BOOL GetCapability( CAPSTYPE PropType, DWORD *pPropType );         // H.Yagi
    
	CDVDStream(){m_StreamType = Dvd;};
};


class CClassLibBuffer : public IHALBuffer
{
public:
	DWORD GetSize();
	DWORD Flags();
	BYTE *GetBuffPointer();
	BYTE *GetLinBuffPointer();

	IMBoardListItem* GetNext(){ return m_pNext; };
	void SetNext( IMBoardListItem *Item ){ m_pNext = Item; };

	PVOID GetIMPEGBuffer(){ return m_pMPEGBoardBuffer;};
	CBaseStream *GetStream(){ return m_pStream;};
	
	CClassLibBuffer( void );
	CClassLibBuffer(IMBoardListItem *pBuffer, CBaseStream *pStream, DWORD PageNum);
	CClassLibBuffer(IMBoardListItem *pBuffer, CBaseStream *pStream, DWORD PageNum, DWORD Size, DWORD Add, DWORD LinAdd, DWORD flag);
	void SetParam(IMBoardListItem *pBuffer, CBaseStream *pStream, DWORD PageNum, DWORD Size, DWORD Add, DWORD LinAdd, DWORD flag);
private:
	IMBoardListItem *m_pNext;

	DWORD m_PageNum;
	DWORD m_Size;
	DWORD m_flag;
	UCHAR *m_Add;
	UCHAR *m_LinAdd;
	CBaseStream *m_pStream;
	IMPEGBuffer *m_pMPEGBoardBuffer;
public:
	BOOL m_fEnd;
};

#define MAXCLIBBUFF		(20)

class CMemoryAllocator
{
private:
	CClassLibBuffer Buff[MAXCLIBBUFF];
	int		TopFreePoint;
	int		LastFreePoint;
	int		FreeBuffNum;

public:
	CMemoryAllocator(){
		TopFreePoint = 0;
		LastFreePoint = 0;
		FreeBuffNum = MAXCLIBBUFF;
		for( int i = 0; i < MAXCLIBBUFF ; i ++ )
			Buff[i].SetNext( NULL );
	};

	~CMemoryAllocator(){
	};

	CClassLibBuffer *Alloc(IMBoardListItem *pBuffer, CBaseStream *pStream, DWORD PageNum, DWORD Size, DWORD Add, DWORD LinAdd, DWORD flag)
	{ 
		CClassLibBuffer *pNewBuffer;

		if( FreeBuffNum == 0 )
			return NULL;

		pNewBuffer = &Buff[TopFreePoint];
		pNewBuffer->SetParam(pBuffer, pStream, PageNum, Size, Add, LinAdd, flag);

		FreeBuffNum--;
		TopFreePoint++;
		if( TopFreePoint == MAXCLIBBUFF )
			TopFreePoint = 0;

		return pNewBuffer;
	};

	void Free(CClassLibBuffer *pBuffer)
	{
		ASSERT( pBuffer == &Buff[LastFreePoint] );
		ASSERT( FreeBuffNum != MAXCLIBBUFF );

		LastFreePoint ++;
		if( LastFreePoint == MAXCLIBBUFF )
			LastFreePoint = 0;
		FreeBuffNum ++;

		pBuffer->SetNext(NULL);
	};

	int GetMaxBuffNum( void )
	{
		return MAXCLIBBUFF;
	};

	void Flush( void )
	{
		TopFreePoint = 0;
		LastFreePoint = 0;
		FreeBuffNum = MAXCLIBBUFF;
		for( int i = 0; i < MAXCLIBBUFF ; i ++ )
			Buff[i].SetNext( NULL );
	};
};

class CTransferStreamList : public IMBoardListItem
{
public:
	CTransferStreamList(){m_pNextItem = NULL; m_pBaseStream = NULL;};
	CTransferStreamList(CBaseStream *pStream){m_pNextItem = NULL; m_pBaseStream = pStream;};

//378742    PNPBOOT: tosdvd03 leaks 1 page of memory on unload.
	void Init(CBaseStream *pStream){m_pNextItem = NULL; m_pBaseStream = pStream;};
//378742

	IMBoardListItem* GetNext( void ){ return (IMBoardListItem *)m_pNextItem;};
	void SetNext( IMBoardListItem *Item ){ m_pNextItem = (CTransferStreamList *)Item;};
	
	CBaseStream *GetBaseStream(void){ return m_pBaseStream;};
	void SetBaseStream (CBaseStream *pStream){ m_pBaseStream = pStream;};

private:
	CBaseStream *m_pBaseStream;
	CTransferStreamList *m_pNextItem;
};

class CTransfer : public ITransfer
{
	friend class CMPEGBoard;
#ifdef TEST
	friend class CMBoardAppDlg;
#endif
public:
	BOOL EnQueue( IMPEGBuffer *Buff);
	BOOL Init();
	BOOL SetSink(IMPEGBoardEvent *pEvent);
	BOOL UnSetSink(IMPEGBoardEvent *pEvent);
	BOOL SetDMABuffer(DWORD size, BYTE* LinerAdd, BYTE *PhysAdd);

//
	CTransfer(){Init();};
	~CTransfer();
	BOOL DeQueue();
	BOOL AddStreamObject(IBaseStream *);
	BOOL ReleaseStreamObject(IBaseStream *);
	BOOL EndOfTransfer(CClassLibBuffer *);
	void Flush();

private:
	CTransferStreamList *m_pStreamObject;

//378742    PNPBOOT: tosdvd03 leaks 1 page of memory on unload.
	CTransferStreamList m_pNewTransferStreamList;
//378742

	IMBoardListItem *m_pTopEventList, *m_pLastEventList;
	BYTE *m_LinerAdd;
	BYTE *m_PhysAdd;
	DWORD m_DMABufferSize;
	CClassLibEvent m_EndOfTransferEvent;
	IClassLibHAL *m_pIHAL;
	CMemoryAllocator m_Mem;

	IMPEGBuffer *m_pTopQueuedMPEGBuffer;
	IMPEGBuffer *m_pLastQueuedMPEGBuffer;
	IMPEGBuffer *m_pNextTransferMPEGBuffer;
	DWORD	m_TopPagePoint;
	DWORD	m_LastPagePoint;

	BOOL	HasQueuedBuffer( void );
	BOOL	GetNextTransferPoint( IMPEGBuffer **Point, DWORD *Page );
	BOOL	FreeTopTransferPoint( IMPEGBuffer **Free );


//fobOp
	int BufCount;
	DWORD StreamCount;
};


class CMPEGBoard : public IMPEGBoard
{
public:
	//IMPEGBoard
	BOOL Init();
	BOOL AddStreamObjectInterface(IBaseStream *);
	BOOL ReleaseStreamObjectInterface(IBaseStream *);
	BOOL PowerOn();
	BOOL PowerOff();
	BOOL SetSTC(DWORD);
	BOOL GetSTC(DWORD *);                       // 98.03.27 H.Yagi
	BOOL SetHALObjectInterface(IClassLibHAL *);

	//
	CMPEGBoard(){Init();};
	BOOL ChangePower(POWERSTATE);
	BOOL ISPOWEROFF();	//HAL
	BOOL SetHALStream(CBaseStream *, IClassLibHAL *);
private:

	CBaseStream *m_pBaseStreamObject;//Xg[`F[
	IClassLibHAL *m_pIHAL;//nC^tF[X|C^
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\tecra\cstate.cpp ===
/*
NXNX
iNP2)@Sachiko Yasukawa
*/
#include "stdafx.h"

#include "includes.h"
#include "classlib.h"

void CMPEGBoardState::SetState(LIBSTATE State)
{
	m_State = State;
	switch(m_State){
	case PowerOff:
		m_pStateObject = &m_PowerOffState;
		DBG_PRINTF(("CLASSLIB: STATE = POWEROFF\n"));
#ifdef TEST
		TRACE("STATE = POWEROFF\n");
#endif
		break;
	case Stop:
		m_pStateObject = &m_StopState;
#ifdef TEST
		TRACE("STATE = STOP\n");
#endif
		DBG_PRINTF(("CLASSLIB: STATE = STOP\n"));
		break;
	case Pause:
		m_pStateObject = &m_PauseState;
#ifdef TEST
		TRACE("STATE = PAUSE\n");
#endif
		DBG_PRINTF(("CLASSLIB: STATE = PAUSE\n"));
		break;
	case Play:
		m_pStateObject = &m_PlayState;
#ifdef TEST
		TRACE("STATE = PLAY\n");
#endif
		DBG_PRINTF(("CLASSLIB: STATE = PLAY\n"));
		break;
	case Slow:
		m_pStateObject = &m_SlowState;
#ifdef TEST
		TRACE("STATE = SLOW\n");
#endif
		DBG_PRINTF(("CLASSLIB: STATE = SLOW\n"));
		break;
	default:
		m_pStateObject = &m_ScanState;
#ifdef TEST
		TRACE("STATE = SCAN\n");
#endif
		DBG_PRINTF(("CLASSLIB: STATE = SCAN\n"));
		break;
	}
}

BOOL CPowerOffState::ChangePowerOff(IClassLibHAL *pCHAL, IHALStreamControl *pSHAL)
{
	return TRUE;
}

BOOL CPowerOffState::ChangeStop(IClassLibHAL *pCHAL, IHALStreamControl *pSHAL,CBaseStream *pStream)
{
	HALRESULT st;
	
	if((st = pCHAL->SetPowerState(POWERSTATE_ON)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "HAL CAN'T CHANGE POWERON\n");
		DBG_PRINTF(("CLASSLIB:CPowerOffState::ChangeStpe:HAL CAN'T CHANGE POWERON\n"));
		DBG_BREAK();
		return FALSE;
	}
	if((st = pSHAL->SetPlayStop()) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "HAL CAN'T CHANGE STOP\n");
		DBG_PRINTF(("CLASSLIB:CPowerOffState::ChangeState:HAL CAN'T CHANGE STOP\n"));
		DBG_BREAK();
		return FALSE;
	}

	((CMPEGBoardState *)m_pMPEGBoardState)->SetState(Stop);
		
	return TRUE;
}

BOOL CPowerOffState::ChangePause(IClassLibHAL *pCHAL, IHALStreamControl *pSHAL)
{
	_RPTF0(_CRT_WARN, "CAN'T CHANGE FROM POWERSTATE TO PAUSE\n");
	DBG_PRINTF(("CLASSLIB:CPowerOffState::ChangeState:CAN'T CHANGE FROM POWERSTATE TO PAUSE\n"));
	DBG_BREAK();
	return FALSE;
}
BOOL CPowerOffState::ChangePlay(IClassLibHAL *pCHAL, IHALStreamControl *pSHAL)
{
	_RPTF0(_CRT_WARN, "CAN'T CHANGE FROM POWERSTATE TO PLAY\n");
	DBG_PRINTF(("CLASSLIB:CPowerOffState::ChangePlay:CAN'T CHANGE FROM POWERSTATE TO PLAY\n"));
	DBG_BREAK();
	return FALSE;
}

BOOL CPowerOffState::ChangePauseViaSingleStep(IClassLibHAL *pCHAL, IHALStreamControl *pSHAL)
{
	_RPTF0(_CRT_WARN, "CAN'T CHANGE FROM POWERSTATE TO PAUSEVIASINGLESTEPE\n");
	DBG_PRINTF(("CLASSLIB:CPowerOffState::ChangePauseViaSingleStep:CAN'T CHANGE FROM POWERSTATE TO PAUSEVIASINGLESTEPE\n"));
	DBG_BREAK();
	return FALSE;
}

BOOL CPowerOffState::ChangeSlow(DWORD Speed, IClassLibHAL *pCHAL, IHALStreamControl *pSHAL)
{
	_RPTF0(_CRT_WARN, "CAN'T CHANGE FROM POWERSTATE TO SLOW\n");
	DBG_PRINTF(("CLASSLIB:CPowerOffState::ChangeSlow:CAN'T CHANGE FROM POWERSTATE TO SLOW\n"));
	DBG_BREAK();
	return FALSE;
}

BOOL CPowerOffState::ChangeScan(DWORD Speed, IClassLibHAL *pCHAL, IHALStreamControl *pSHAL)
{
	_RPTF0(_CRT_WARN, "CAN'T CHANGE FROM POWERSTATE TO SCAN\n");
	DBG_PRINTF(("CLASSLIB:CPowerOffState::ChangeScan:CAN'T CHANGE FROM POWERSTATE TO SCAN\n"));
	DBG_BREAK();
	return FALSE;
}

BOOL CStopState::ChangePowerOff(IClassLibHAL *pCHAL, IHALStreamControl *pSHAL)
{
	BOOL st;
	
	if((st = pCHAL->SetPowerState(POWERSTATE_OFF)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "HAL CAN'T CHANGE POWEROFF\n");
		DBG_PRINTF(("CLASSLIB:CStopState::ChangePowerOff:HAL CAN'T CHANGE POWEROFF\n"));
		DBG_BREAK();
		return FALSE;
	}
	
	((CMPEGBoardState *)m_pMPEGBoardState)->SetState(PowerOff);
	
	return TRUE;

}

BOOL CStopState::ChangeStop(IClassLibHAL *pCHAL, IHALStreamControl *pSHAL,CBaseStream *pStream)
{
	return TRUE;
}

BOOL CStopState::ChangePause(IClassLibHAL *pCHAL, IHALStreamControl *pSHAL)
{
	BOOL st;
	
	if((st = pSHAL->SetPlayPause()) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "HAL CAN'T CHANGE PAUSE\n");
		DBG_PRINTF(("CLASSLIB:CStopState::ChangePause:HAL CAN'T CHANGE PAUSE\n"));
		DBG_BREAK();
		return FALSE;
	}
	
	((CMPEGBoardState *)m_pMPEGBoardState)->SetState(Pause);
	
	return TRUE;
}

BOOL CStopState::ChangePlay(IClassLibHAL *pCHAL, IHALStreamControl *pSHAL)
{
	_RPTF0(_CRT_WARN, "CAN'T CHANGE FROM STOP TO PLAY\n");
	DBG_PRINTF(("CLASSLIB:CStopState::ChangePlay:CAN'T CHANGE FROM STOP TO PLAY\n"));
	DBG_BREAK();
	return FALSE;
}

BOOL CStopState::ChangePauseViaSingleStep(IClassLibHAL *pCHAL, IHALStreamControl *pSHAL)
{
	_RPTF0(_CRT_WARN, "CAN'T CHANGE FROM STOP TO PAUSEVIASINGLESTEP\n");
	DBG_PRINTF(("CLASSLIB:CStopState::ChangePauseViaSingleStep:CAN'T CHANGE FROM STOP TO PAUSEVIASINGLESTEP\n"));
	DBG_BREAK();
	return FALSE;
}

BOOL CStopState::ChangeSlow(DWORD Speed, IClassLibHAL *pCHAL, IHALStreamControl *pSHAL)
{
	_RPTF0(_CRT_WARN, "CAN'T CHANGE FROM STOP TO SLOW\n");
	DBG_PRINTF(("CLASSLIB:CStopState::ChangeSlow:CAN'T CHANGE FROM STOP TO SLOW\n"));
	DBG_BREAK();
	return FALSE;
}

BOOL CStopState::ChangeScan(DWORD Speed, IClassLibHAL *pCHAL, IHALStreamControl *pSHAL)
{
	_RPTF0(_CRT_WARN, "CAN'T CHANGE FROM POWERSTATE TO SCAN\n");
	DBG_PRINTF(("CLASSLIB:CStopState::ChangeScan:CAN'T CHANGE FROM STOP TO SCAN\n"));
	DBG_BREAK();
	return FALSE;
}

BOOL CPauseState::ChangePowerOff(IClassLibHAL *pCHAL, IHALStreamControl *pSHAL)
{
	_RPTF0(_CRT_WARN, "CAN'T CHANGE FROM PAUSE TO POWEROFF\n");
	DBG_PRINTF(("CLASSLIB:CPauseState::ChangePowerOff:CAN'T CHANGE FROM PAUSE TO POWEROFF\n"));
	DBG_BREAK();
	return FALSE;
}

BOOL CPauseState::ChangeStop(IClassLibHAL *pCHAL, IHALStreamControl *pSHAL,CBaseStream *pStream)
{
	HALRESULT st;

	if((st = pSHAL->SetPlayStop()) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "HAL CAN'T CHANGE STOP\n");
		DBG_PRINTF(("CLASSLIB:CPauseState::ChangeStop:HAL CAN'T CHANGE FROM PAUSE TO STOP\n"));
		DBG_BREAK();
		return FALSE;
	}

	((CMPEGBoardState *)m_pMPEGBoardState)->SetState(Stop);
	
	pStream->FlushTransferBuffer();
	
	return TRUE;
}


BOOL CPauseState::ChangePause(IClassLibHAL *pCHAL, IHALStreamControl *pSHAL)
{
	return TRUE;
}

BOOL CPauseState::ChangePlay(IClassLibHAL *pCHAL, IHALStreamControl *pSHAL)
{
	HALRESULT st;
	
	if((st = pSHAL->SetPlayNormal()) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "HAL CAN'T CHANGE PLAY\n");
		DBG_PRINTF(("CLASSLIB:CPauseState::ChangePlay:HAL CAN'T CHANGE FROM PAUSE TO PLAY\n"));
		DBG_BREAK();
		return FALSE;
	}
	
	((CMPEGBoardState *)m_pMPEGBoardState)->SetState(Play);
	
	return TRUE;
}

BOOL CPauseState::ChangePauseViaSingleStep(IClassLibHAL *pCHAL, IHALStreamControl *pSHAL)
{
	HALRESULT st;

	if((st = pSHAL->SetPlaySingleStep()) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "HAL CAN'T CHANGE PAUSEVIASINGLESTEP\n");
		DBG_PRINTF(("CLASSLIB:CPauseState::ChangePauseViaSingleStep:HAL CAN'T CHANGE FROM PAUSE TO SINGLESTEPn"));
		DBG_BREAK();
		return FALSE;
	}
	return TRUE;
}

BOOL CPauseState::ChangeSlow(DWORD Speed, IClassLibHAL *pCHAL, IHALStreamControl *pSHAL)
{
	HALRESULT st;

	if((st = pSHAL->SetPlaySlow(Speed)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "HAL CAN'T CHANGE SLOW\n");
		DBG_PRINTF(("CLASSLIB:CPauseState::ChangeSlow:CAN'T CHANGE FROM PAUSE TO SLOW\n"));
		DBG_BREAK();
		return FALSE;
	}

	((CMPEGBoardState *)m_pMPEGBoardState)->SetState(Slow);
	
	return TRUE;
}

BOOL CPauseState::ChangeScan(DWORD Speed, IClassLibHAL *pCHAL, IHALStreamControl *pSHAL)
{
	HALRESULT st;

	if((st = pSHAL->SetPlayScan(Speed)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "HAL CAN'T CHANGE SCAN\n");
		DBG_PRINTF(("CLASSLIB:CPauseState::ChangeScan:HAL CAN'T CHANGE FROM PAUSE TO SCAN\n"));
		DBG_BREAK();
		return FALSE;
	}

	((CMPEGBoardState *)m_pMPEGBoardState)->SetState(Scan);

	return TRUE;
}

BOOL CPlayState::ChangePowerOff(IClassLibHAL *pCHAL, IHALStreamControl *pSHAL)
{
	_RPTF0(_CRT_WARN, "CAN'T CHANGE FROM PLAY TO POWEROFF\n");
	DBG_PRINTF(("CLASSLIB:CPlayState::ChangePowerOff:CAN'T CHANGE FROM PLAY TO POWEROFF\n"));
	DBG_BREAK();
	return FALSE;
}

BOOL CPlayState::ChangeStop(IClassLibHAL *pCHAL, IHALStreamControl *pSHAL,CBaseStream *pStream)
{
	HALRESULT st;
	
	if((st = pSHAL->SetPlayStop()) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "HAL CAN'T CHANGE PLAY\n");
		DBG_PRINTF(("CLASSLIB:CPlayState::ChangeStop:HAL CAN'T CHANGE FROM PLAY TO STOP\n"));
		DBG_BREAK();
		return FALSE;
	}
	
	((CMPEGBoardState *)m_pMPEGBoardState)->SetState(Stop);
	
	pStream->FlushTransferBuffer();
	
	return TRUE;
}


BOOL CPlayState::ChangePause(IClassLibHAL *pCHAL, IHALStreamControl *pSHAL)
{
	HALRESULT st;
	
	if((st = pSHAL->SetPlayPause()) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "HAL CAN'T CHANGE PAUSE\n");
		DBG_PRINTF(("CLASSLIB:CPlayState::ChangePause:HAL CAN'T CHANGE FROM PLAY TO PAUSE\n"));
		DBG_BREAK();
		return FALSE;
	}
	
	((CMPEGBoardState *)m_pMPEGBoardState)->SetState(Pause);
	
	return TRUE;
}

BOOL CPlayState::ChangePlay(IClassLibHAL *pCHAL, IHALStreamControl *pSHAL)
{
	return TRUE;
}

BOOL CPlayState::ChangePauseViaSingleStep(IClassLibHAL *pCHAL, IHALStreamControl *pSHAL)
{
	HALRESULT st;

	//{JH

	if((st = pSHAL->SetPlaySingleStep()) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "HAL CAN'T CHANGE FROM PAUSE TO \n");
		DBG_PRINTF(("CLASSLIB:CPlayState::ChangePowerOff:HAL CAN'T CHANGE FROM PLAY TO POWEROFF\n"));
		DBG_BREAK();
		return FALSE;
	}

	((CMPEGBoardState *)m_pMPEGBoardState)->SetState(Pause);

	return TRUE;
}

BOOL CPlayState::ChangeSlow(DWORD Speed, IClassLibHAL *pCHAL, IHALStreamControl *pSHAL)
{
	HALRESULT st;
	
	if((st = pSHAL->SetPlaySlow(Speed)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "HAL CAN'T CHANGE SLOW\n");
		DBG_PRINTF(("CLASSLIB:CPlayState::ChangeSlow:HAL CAN'T CHANGE FROM PLAY TO SLOW\n"));
		DBG_BREAK();
		return FALSE;
	}

	((CMPEGBoardState *)m_pMPEGBoardState)->SetState(Slow);
	
	return TRUE;
}

BOOL CPlayState::ChangeScan(DWORD Speed, IClassLibHAL *pCHAL, IHALStreamControl *pSHAL)
{
	HALRESULT st;
	
	if((st = pSHAL->SetPlayScan(Speed)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "HAL CAN'T CHANGE SCAN\n");
		DBG_PRINTF(("CLASSLIB:CPlayState::ChangeScan:HAL CAN'T CHANGE FROM PLAY TO SCAN\n"));
		DBG_BREAK();
		return FALSE;
	}
	
	((CMPEGBoardState *)m_pMPEGBoardState)->SetState(Scan);
	
	return TRUE;
}

BOOL CSlowState::ChangePowerOff(IClassLibHAL *pCHAL, IHALStreamControl *pSHAL)
{
	_RPTF0(_CRT_WARN, "CAN'T CHANGE FROM SLOW TO POWEROFF\n");
	DBG_PRINTF(("CLASSLIB:CSlowState::ChangePowerOff:CAN'T CHANGE FROM STLOW TO POWEROFF\n"));
	DBG_BREAK();
	return FALSE;
}

BOOL CSlowState::ChangeStop(IClassLibHAL *pCHAL, IHALStreamControl *pSHAL,CBaseStream *pStream)
{
	HALRESULT st;
	
	if((st = pSHAL->SetPlayStop()) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "HAL CAN'T CHANGE STOP\n");
		DBG_PRINTF(("CLASSLIB:CSlowState::ChangeStop:HAL CAN'T CHANGE FROM STLOW TO STOP\n"));
		DBG_BREAK();
		return FALSE;
	}
	
	((CMPEGBoardState *)m_pMPEGBoardState)->SetState(Stop);
	
	pStream->FlushTransferBuffer();
	
	return TRUE;
}


BOOL CSlowState::ChangePause(IClassLibHAL *pCHAL, IHALStreamControl *pSHAL)
{
	HALRESULT st;
	
	if((st = pSHAL->SetPlayPause()) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "HAL CAN'T CHANGE PAUSE\n");
		DBG_PRINTF(("CLASSLIB:CSlowState::ChangePause:HAL CAN'T CHANGE FROM STLOW TO PAUSE\n"));
		DBG_BREAK();
		return FALSE;
	}
	
	((CMPEGBoardState *)m_pMPEGBoardState)->SetState(Pause);
	
	return TRUE;
}

BOOL CSlowState::ChangePlay(IClassLibHAL *pCHAL, IHALStreamControl *pSHAL)
{
	HALRESULT st;
	
	if((st = pSHAL->SetPlayNormal()) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "HAL CAN'T CHANGE PLAY\n");
		DBG_PRINTF(("CLASSLIB:CSlowState::ChangePlay:HAL CAN'T CHANGE FROM STLOW TO PLAY\n"));
		DBG_BREAK();
		return FALSE;
	}
	
	((CMPEGBoardState *)m_pMPEGBoardState)->SetState(Play);
	
	return TRUE;
}

BOOL CSlowState::ChangePauseViaSingleStep(IClassLibHAL *pCHAL, IHALStreamControl *pSHAL)
{
	_RPTF0(_CRT_WARN, "CAN'T CHANGE FROM SLOW TO PAUSEVIASINGLESTEP\n");
	DBG_PRINTF(("CLASSLIB:CSlowState::ChangePauseViaSingleStep:CAN'T CHANGE FROM STLOW TO SINGLESTEP\n"));
	DBG_BREAK();
	return FALSE;
}

BOOL CSlowState::ChangeSlow(DWORD Speed, IClassLibHAL *pCHAL, IHALStreamControl *pSHAL)
{
	HALRESULT st;
	
	if((st = pSHAL->SetPlaySlow(Speed)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "HAL CAN'T CHANGE SLOW\n");
		DBG_PRINTF(("CLASSLIB:CSlowState::ChangeSlow:HAL CAN'T CHANGE FROM STLOW TO SLOW\n"));
		DBG_BREAK();
		return FALSE;
	}
	
	return TRUE;
}

BOOL CSlowState::ChangeScan(DWORD Speed, IClassLibHAL *pCHAL, IHALStreamControl *pSHAL)
{
	HALRESULT st;
	
	if((st = pSHAL->SetPlayScan(Speed)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "HAL CAN'T CHANGE SCAN\n");
		DBG_PRINTF(("CLASSLIB:CSlowState::ChangeScan:HAL CAN'T CHANGE FROM STLOW TO SCAN\n"));
		DBG_BREAK();
		return FALSE;
	}
	
	((CMPEGBoardState *)m_pMPEGBoardState)->SetState(Scan);
	
	return TRUE;
}

BOOL CScanState::ChangePowerOff(IClassLibHAL *pCHAL, IHALStreamControl *pSHAL)
{
	_RPTF0(_CRT_WARN, "CAN'T CHANGE FROM SCAN TO POWEROFF\n");
	DBG_PRINTF(("CLASSLIB:CScanState::ChangePowerOff:CAN'T CHANGE FROM SCAN TO POWEROFF\n"));
	DBG_BREAK();
	return FALSE;
}

BOOL CScanState::ChangeStop(IClassLibHAL *pCHAL, IHALStreamControl *pSHAL,CBaseStream *pStream)
{
	HALRESULT st;
	
	if((st = pSHAL->SetPlayStop()) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "HAL CAN'T CHANGE STOP \n");
		DBG_PRINTF(("CLASSLIB:CScanState::ChangeStop:HAL CAN'T CHANGE FROM SCAN TO STOP\n"));
		DBG_BREAK();
		return FALSE;
	}
	
	((CMPEGBoardState *)m_pMPEGBoardState)->SetState(Stop);
	
	pStream->FlushTransferBuffer();
	
	return TRUE;
}


BOOL CScanState::ChangePause(IClassLibHAL *pCHAL, IHALStreamControl *pSHAL)
{
	HALRESULT st;
	
	if((st = pSHAL->SetPlayPause()) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "HAL CAN'T CHANGE PAUSE\n");
		DBG_PRINTF(("CLASSLIB:CScanState::ChangePause:HAL CAN'T CHANGE FROM SCAN TO PAUSE\n"));
		DBG_BREAK();
		return FALSE;
	}
	
	((CMPEGBoardState *)m_pMPEGBoardState)->SetState(Pause);
	
	return TRUE;
}

BOOL CScanState::ChangePlay(IClassLibHAL *pCHAL, IHALStreamControl *pSHAL)
{
	HALRESULT st;
	
	if((st = pSHAL->SetPlayNormal()) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "HAL CAN'T CHANGE PLAY\n");
		DBG_PRINTF(("CLASSLIB:CScanState::ChangePlay:HAL CAN'T CHANGE FROM SCAN TO PLAY\n"));
		DBG_BREAK();
		return FALSE;
	}
	
	((CMPEGBoardState *)m_pMPEGBoardState)->SetState(Play);
	
	return TRUE;
}

BOOL CScanState::ChangePauseViaSingleStep(IClassLibHAL *pCHAL, IHALStreamControl *pSHAL)
{
	_RPTF0(_CRT_WARN, "CAN'T CHANGE FROM SCAN TO PAUSEVIASINGLESTEP\n");
	DBG_PRINTF(("CLASSLIB:CScanState::ChangePauseVidaSingleStep:CAN'T CHANGE FROM SCAN TO SINGLESTEP\n"));
	DBG_BREAK();
	return FALSE;
}

BOOL CScanState::ChangeSlow(DWORD Speed, IClassLibHAL *pCHAL, IHALStreamControl *pSHAL)
{
	HALRESULT st;
	
	if((st = pSHAL->SetPlayScan(Slow)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "HAL CAN'T CHANGE SCAN\n");
		DBG_PRINTF(("CLASSLIB:CScanState::ChangeSlow:HAL CAN'T CHANGE FROM SCAN TO SLOW\n"));
		DBG_BREAK();
		return FALSE;
	}
	
	((CMPEGBoardState *)m_pMPEGBoardState)->SetState(Slow);
	
	return TRUE;
}

BOOL CScanState::ChangeScan(DWORD Speed, IClassLibHAL *pCHAL, IHALStreamControl *pSHAL)
{
	HALRESULT st;
	
	if((st = pSHAL->SetPlayScan(Speed)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "HAL CAN'T CHANGE SCAN\n");
		DBG_PRINTF(("CLASSLIB:CScanState::ChangeScan:HAL CAN'T CHANGE FROM SCAN TO SCAN\n"));
		DBG_BREAK();
		return FALSE;
	}
	
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\tecra\cstream.cpp ===
/*
Xg[NXNX
iNP2)@Sachiko Yasukawa
*/
//     Date    |   Author     |  Description
//  -----------+--------------+--------------------------------------------
//  1998.03.27 |  Hideki Yagi | Change the specification about
//             |              | Get***Property().
//  1998.03.31 |  Hideki Yagi | Change the specification about
//             |              | GetChlgKey() and GetDVDKey2().
//

#include "stdafx.h"

#include "includes.h"
#include "classlib.h"

#define ISENDSTREAMOBJECTINIT ((m_pMPEGBoardStateObject == NULL || m_pIHAL == NULL || m_pTransfer == NULL || m_pIStreamHAL == NULL ) ? TRUE : FALSE)
//RXgN^
CBaseStream::CBaseStream()
{
	m_pNextStreamObject=NULL;
	m_pPrevStreamObject=NULL;
	m_pMPEGBoardStateObject=NULL;
	m_pIHAL=NULL;
	m_pIStreamHAL = NULL;
	m_pTransfer = NULL;
}

//lR[fBO
//
inline BOOL CBaseStream::Init()
{
	m_pNextStreamObject=NULL;
	m_pPrevStreamObject=NULL;
	m_pMPEGBoardStateObject=NULL;
	m_pIHAL=NULL;
	m_pIStreamHAL = NULL;
	m_pTransfer = NULL;

	return TRUE; 
}

//
BOOL CBaseStream::Play()
{
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_PRINTF(("CLASSLIB:CBaseStream::GetMPEGBuffer:NOT INITILIZE CMPEGBoard COLLECTLY\n"));
		DBG_BREAK();
		return FALSE;
	}
	
	return GetIMPEGBoardState()->ChangePlay(m_pIHAL, m_pIStreamHAL);

}

//~
BOOL CBaseStream::Stop()
{
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_PRINTF(("CLASSLIB:CBaseStream::Stop:NOT INITILIZE CMPEGBoard COLLECTLY\n"));
		DBG_BREAK();
		return FALSE;
	}
	
	return GetIMPEGBoardState()->ChangeStop(m_pIHAL, m_pIStreamHAL, this);

}

//~
BOOL CBaseStream::Pause()
{
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_PRINTF(("CLASSLIB:CBaseStream::Pause:NOT INITILIZE CMPEGBoard COLLECTLY\n"));
		DBG_BREAK();
		return FALSE;
	}

	return GetIMPEGBoardState()->ChangePause(m_pIHAL, m_pIStreamHAL);

}

//R}
//VxDgH
BOOL CBaseStream::SingleStep()
{
	//I
	if(ISENDSTREAMOBJECTINIT){
		DBG_PRINTF(("CLASSLIB:CBaseStream::SingleStep:NOT INITILIZE CMPEGBoard COLLECTLY\n"));
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}

	//VxDg
	if(!ISMIXSTREAMTYPE(m_StreamType)){
		_RPTF0(_CRT_WARN, "NOTIMPLEMENTED \n");
		DBG_PRINTF(("CLASSLIB:CBaseStream::SingleStep:CALL ONLY FOR MIXSTREAM\n"));
		DBG_BREAK();
		return FALSE;
	}

	return GetIMPEGBoardState()->ChangePauseViaSingleStep(m_pIHAL, m_pIStreamHAL);
}

//X[
//VxDgH
BOOL CBaseStream::Slow(DWORD speed)
{
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_PRINTF(("CLASSLIB:CBaseStream::Slow:NOT INITILIZE CMPEGBoard COLLECTLY\n"));
		DBG_BREAK();
		return FALSE;
	}

	//VxDg
	if(!ISMIXSTREAMTYPE(m_StreamType)){
		_RPTF0(_CRT_WARN, "NOTIMPLEMENTED \n");
		DBG_PRINTF(("CLASSLIB:CBaseStream::Slow:CALL ONLY FOR MIXSTREAM\n"));
		DBG_BREAK();
		return FALSE;
	}
	
	return GetIMPEGBoardState()->ChangeSlow(speed, m_pIHAL, m_pIStreamHAL);
}

//XL
//VxDgH
BOOL CBaseStream::Scan(DWORD speed)
{
	//I
	if(ISENDSTREAMOBJECTINIT){
		DBG_PRINTF(("CLASSLIB:CBaseStream::Scan:NOT INITILIZE CMPEGBoard COLLECTLY\n"));
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}

	//VxDg
	if(!ISMIXSTREAMTYPE(m_StreamType)){
		_RPTF0(_CRT_WARN, "NOTIMPLEMENTED \n");
		DBG_PRINTF(("CLASSLIB:CBaseStream::Slow:CALL ONLY FOR MIXSTREAM\n"));
		DBG_BREAK();
		return FALSE;
	}
	
	return GetIMPEGBoardState()->ChangeScan(speed, m_pIHAL, m_pIStreamHAL);
}

//Xg[Xe[^X
LIBSTATE CBaseStream::GetState()
{
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_PRINTF(("CLASSLIB:CBaseStream::GetState:NOT INITILIZE CMPEGBoard COLLECTLY\n"));
		return PowerOff;
	}
	return ((CMPEGBoardState *)m_pMPEGBoardStateObject)->GetState();
}
	
//f[^]v
//^[ll
BOOL CBaseStream::SendData(IMPEGBuffer *pBuffer)
{
	ASSERT(pBuffer);
	DBG_PRINTF(("CLASSLIB: CALLED CBaseStream::SendData\n"));

	//I
	if(ISENDSTREAMOBJECTINIT){
		DBG_PRINTF(("CLASSLIB:CBaseStream::SendData:NOT INITILIZE CMPEGBoard COLLECTLY\n"));
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}

	// obt@Next|C^
	pBuffer->SetNext( NULL );

	//gXt@[L[v
	if(!((CTransfer *)m_pTransfer)->EnQueue( pBuffer )){
		_RPTF0(_CRT_WARN, "CAN'T ENQUEUE \n");
		DBG_PRINTF(("CLASSLIB:CBaseStream::SendData:CAN'T ENQUEUE \n"));
		DBG_BREAK();
		return FALSE;
	}

	//gXt@[]v
	if(!((CTransfer *)m_pTransfer)->DeQueue()){
		_RPTF0(_CRT_WARN, "CAN'T DEQUEUE \n");
		DBG_PRINTF(("CLASSLIB:CBaseStream::SendData:CAN'T DEQUEUE \n"));
		DBG_BREAK();
		return FALSE;
	}
	
	return TRUE;
}

//Xg[Xe[gIuWFNgZbg
BOOL CBaseStream::SetStateObject(IMPEGBoardState *pMPEGBoardStateObject)
{
	ASSERT(pMPEGBoardStateObject);

	//Xe[gRg[IuWFNg
	m_pMPEGBoardStateObject = pMPEGBoardStateObject;

	return TRUE;
}

//]IuWFNg
BOOL CBaseStream::SetTransferObject(ITransfer *pTransfer)
{
	ASSERT(pTransfer);
	
	//gXt@[Rg[IuWFNgQx
	if(m_pTransfer){
		_RPTF0(_CRT_WARN, "ALREADY SET TRANSFER OBJECT \n");
		DBG_PRINTF(("CLASSLIB:CBaseStream::SetTransferObject:ALREADY SET TRANSFER OBJECT \n"));
		DBG_BREAK();
		return FALSE;
	}

	//gXt@[Rg[IuWFNg
	m_pTransfer = pTransfer;

	//tgXt@[IuWFNgXg[
	((CTransfer *)m_pTransfer)->AddStreamObject((IBaseStream *)/*(CBuffer *)*/this);

	return TRUE;
}

//][h
BOOL CBaseStream::SetTransferMode(HALSTREAMMODE StreamMode)
{
	HALRESULT st;

	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}
	if((st = m_pIStreamHAL->SetTransferMode(StreamMode)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T SET TRANSFERMODE \n");
		DBG_PRINTF(("CLASSLIB:CBaseStream::SetTransferMode:CAN'T SET TRANSFERMODE\n"));
		DBG_BREAK();
		return FALSE;
	}

	return TRUE;
}

// Set transfer typr & direction                98.03.31 H.Yagi
BOOL CBaseStream::SetDataDirection(DirectionType type)
{
	HALRESULT st;

	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}
	if((st = m_pIStreamHAL->SetDataDirection(type)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T SET DATADIRECTION \n");
		DBG_PRINTF(("CLASSLIB:CBaseStream::SetDataDirection:CAN'T SET DATADIRECTION\n"));
		DBG_BREAK();
		return FALSE;
	}

	return TRUE;
}

// Get transfer typr & direction                98.03.31 H.Yagi
BOOL CBaseStream::GetDataDirection(DirectionType *ptype)
{
	HALRESULT st;

	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}
    if((st = m_pIStreamHAL->GetDataDirection(ptype)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T GET DATADIRECTION \n");
		DBG_PRINTF(("CLASSLIB:CBaseStream::GetDataDirection:CAN'T GET DATADIRECTION\n"));
		DBG_BREAK();
		return FALSE;
	}

	return TRUE;
}


//Rs[veNg
BOOL CVideoStream::CppInit()
{
	HALRESULT st;

	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}
	if((st = m_pIStreamHAL->CPPInit()) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T Initialize CPP\n");
		DBG_BREAK();
		return FALSE;
	}
	return TRUE;
}

//`WL[
BOOL CVideoStream::SetChlgKey(UCHAR *pDecoderChallenge)
{
	HALRESULT st;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}

	if((st = m_pIStreamHAL->SetDecoderChallenge(pDecoderChallenge)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T SET DECORDERCHALLENGE \n");
		DBG_BREAK();
		return FALSE;
	}
	
	return TRUE;
}

//`WL[
//UCHAR *CVideoStream::GetChlgKey()
BOOL CVideoStream::GetChlgKey( UCHAR *ptr )                 // 98.03.31 H.Yagi
{
	HALRESULT st;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}
	if((st = m_pIStreamHAL->CPPInit()) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T Initialize CPP\n");
		DBG_BREAK();
		return FALSE;
	}
	if((st = m_pIStreamHAL->GetDriveChallenge(ptr)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T GET DRIVERCHALLENGE \n");
		DBG_BREAK();
		return FALSE;
	}
	
	return TRUE;
}

//DVDL[
BOOL CVideoStream::SetDVDKey1(UCHAR *pDriveReponse)
{
	HALRESULT st;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}

	if((st = m_pIStreamHAL->SetDriveResponse(pDriveReponse)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T SET DRIVERRESPONSE \n");
		DBG_BREAK();
		return FALSE;
	}
	
	return TRUE;
}

//DVDL[
//UCHAR *CVideoStream::GetDVDKey2()
BOOL CVideoStream::GetDVDKey2(UCHAR *ptr)                   // 98.03.31 H.Yagi
{
	HALRESULT st;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}

	if((st = m_pIStreamHAL->GetDecoderResponse(ptr)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T SET DECORDERRESPONSE \n");
		DBG_BREAK();
		return FALSE;
	}
	
	return TRUE;
}

//^CgL[
BOOL CVideoStream::SetTitleKey(UCHAR *pTitleKey)
{
	HALRESULT st;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}

	if((st = m_pIStreamHAL->SetTitleKey(pTitleKey)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T SET TITLEKEY \n");
		DBG_BREAK();
		return FALSE;
	}
	
	return TRUE;
}	

//fBXNL[
BOOL CVideoStream::SetDiscKey(UCHAR *pDiscKey)
{
	HALRESULT st;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}

	if((st = m_pIStreamHAL->SetDiskKey(pDiscKey)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T SET DISCKEY \n");
		DBG_BREAK();
		return FALSE;
	}
	
	return TRUE;
}

//rfIvpeB
BOOL CVideoStream::GetVideoProperty(VIDEOPROPTYPE PropertyType, PVOID pProperty)
{
	HALRESULT st;
//	PVOID pProperty;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}
	
	if((st = m_pIHAL->GetVideoProperty(PropertyType, pProperty)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T GET PROPERTY \n");
		DBG_BREAK();
		return FALSE;
	}
	
	return TRUE;
}

//rfIvpeB
BOOL CVideoStream::SetVideoProperty(VIDEOPROPTYPE PropertyType, PVOID pProperty)
{
	HALRESULT st;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}
	
	if((st = m_pIHAL->SetVideoProperty(PropertyType, pProperty)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T GET PROPERTY \n");
		DBG_BREAK();
		return FALSE;
	}
	
	return TRUE;
}

//Rs[veNg
BOOL CAudioStream::CppInit()
{
	HALRESULT st;

	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}
	if((st = m_pIStreamHAL->CPPInit()) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T Initialize CPP\n");
		DBG_BREAK();
		return FALSE;
	}
	return TRUE;
}

//`WL[
BOOL CAudioStream::SetChlgKey(UCHAR *pDecoderChallenge)
{
	HALRESULT st;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}

	if((st = m_pIStreamHAL->SetDecoderChallenge(pDecoderChallenge)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T SET DECORDERCHALLENGE \n");
		DBG_BREAK();
		return FALSE;
	}
	
	return TRUE;
}

//`WL[
//UCHAR *CAudioStream::GetChlgKey()
BOOL CAudioStream::GetChlgKey(UCHAR *ptr)
{
	HALRESULT st;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}
	if((st = m_pIStreamHAL->GetDriveChallenge(ptr)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T GET DRIVERCHALLENGE \n");
		DBG_BREAK();
		return FALSE;
	}
	
	return TRUE;
}

//DVDL[
BOOL CAudioStream::SetDVDKey1(UCHAR *pDriveResponse)
{
	HALRESULT st;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}

	if((st = m_pIStreamHAL->SetDriveResponse(pDriveResponse)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T SET DRIVERRESPONSE \n");
		DBG_BREAK();
		return FALSE;
	}
	
	return TRUE;
}

//DVDL[
//UCHAR *CAudioStream::GetDVDKey2()
BOOL CAudioStream::GetDVDKey2(UCHAR *ptr)
{
	HALRESULT st;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK(); 
		return FALSE;
	}

	if((st = m_pIStreamHAL->GetDecoderResponse(ptr)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T SET DECORDERRESPONSE \n");
		DBG_BREAK();
		return FALSE;
	}
	
	return TRUE;
}

//^CgL[
BOOL CAudioStream::SetTitleKey(UCHAR *pTitleKey)
{
	HALRESULT st;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}

	if((st = m_pIStreamHAL->SetTitleKey(pTitleKey)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T SET TITLEKEY \n");
		DBG_BREAK();
		return FALSE;
	}
	
	return TRUE;
}	

//fBXNL[
BOOL CAudioStream::SetDiscKey(UCHAR *pDiscKey)
{
	HALRESULT st;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}

	if((st = m_pIStreamHAL->SetDiskKey(pDiscKey)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T SET DISCKEY \n");
		DBG_BREAK();
		return FALSE;
	}
	
	return TRUE;
}

//I[fBIvpeB
BOOL CAudioStream::GetAudioProperty(AUDIOPROPTYPE PropertyType, PVOID pProperty)
{
	HALRESULT st;
//	PVOID pProperty;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}
	
	if((st = m_pIHAL->GetAudioProperty(PropertyType, pProperty)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T GET PROPERTY \n");
		DBG_BREAK();
		return FALSE;
	}
	
	return TRUE;
}

//I[fBIvpeB
BOOL CAudioStream::SetAudioProperty(AUDIOPROPTYPE PropertyType, PVOID pProperty)
{
	HALRESULT st;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}
	
	if((st = m_pIHAL->SetAudioProperty(PropertyType, pProperty)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T GET PROPERTY \n");
		DBG_BREAK();
		return FALSE;
	}
	
	return TRUE;
}

//Rs[veNg
BOOL CSubpicStream::CppInit()
{
	HALRESULT st;

	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}
	if((st = m_pIStreamHAL->CPPInit()) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T Initialize CPP\n");
		DBG_BREAK();
		return FALSE;
	}
	return TRUE;
}

//`WL[
BOOL CSubpicStream::SetChlgKey(UCHAR *pDecoderChallenge)
{
	HALRESULT st;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}

	if((st = m_pIStreamHAL->SetDecoderChallenge(pDecoderChallenge)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T SET DECORDERCHALLENGE \n");
		DBG_BREAK();
		return FALSE;
	}
	
	return TRUE;
}

//`WL[
//UCHAR *CSubpicStream::GetChlgKey()
BOOL CSubpicStream::GetChlgKey(UCHAR *ptr)              // 98.03.31 H.Yagi
{
	HALRESULT st;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}
	if((st = m_pIStreamHAL->GetDriveChallenge(ptr)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T GET DRIVERCHALLENGE \n");
		DBG_BREAK();
		return FALSE;
	}
	
	return TRUE;
}

//DVDL[
BOOL CSubpicStream::SetDVDKey1(UCHAR *pDriveResponse)
{
	HALRESULT st;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}

	if((st = m_pIStreamHAL->SetDriveResponse(pDriveResponse)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T SET DRIVERRESPONSE \n");
		DBG_BREAK();
		return FALSE;
	}
	
	return TRUE;
}

//DVDL[
//UCHAR *CSubpicStream::GetDVDKey2()
BOOL CSubpicStream::GetDVDKey2(UCHAR *ptr)              // 98.03.31 H.Yagi
{
	HALRESULT st;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}

	if((st = m_pIStreamHAL->GetDecoderResponse(ptr)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T SET DECORDERRESPONSE \n");
		DBG_BREAK();
		return FALSE;
	}
	
	return TRUE;
}

//^CgL[
BOOL CSubpicStream::SetTitleKey(UCHAR *pTitleKey)
{
	HALRESULT st;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}

	if((st = m_pIStreamHAL->SetTitleKey(pTitleKey)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T SET TITLEKEY \n");
		DBG_BREAK();
		return FALSE;
	}
	
	return TRUE;
}	

//fBXNL[
BOOL CSubpicStream::SetDiscKey(UCHAR *pDiscKey)
{
	HALRESULT st;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}

	if((st = m_pIStreamHAL->SetDiskKey(pDiscKey)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T SET DISCKEY \n");
		DBG_BREAK();
		return FALSE;
	}
	
	return TRUE;
}

//TusN`vpeB
BOOL CSubpicStream::GetSubpicProperty(SUBPICPROPTYPE PropertyType, PVOID pProperty)
{
	HALRESULT st;
//	PVOID pProperty;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}
	
	if((st = m_pIHAL->GetSubpicProperty(PropertyType, pProperty)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T GET PROPERTY \n");
		DBG_BREAK();
		return FALSE;
	}
	
	return TRUE;
}

//TusN`vpeB
BOOL CSubpicStream::SetSubpicProperty(SUBPICPROPTYPE PropertyType, PVOID pProperty)
{
	HALRESULT st;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}
	
	if((st = m_pIHAL->SetSubpicProperty(PropertyType, pProperty)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T GET PROPERTY \n");
		DBG_BREAK();
		return FALSE;
	}
	
	return TRUE;
}

//Rs[veNg
BOOL CVideoCDStream::CppInit()
{
	HALRESULT st;

	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}
	if((st = m_pIStreamHAL->CPPInit()) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T Initialize CPP\n");
		DBG_BREAK();
		return FALSE;
	}
	return TRUE;
}

//`WL[
BOOL CVideoCDStream::SetChlgKey(UCHAR *pDecoderChallenge)
{
	HALRESULT st;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}

	if((st = m_pIStreamHAL->SetDecoderChallenge(pDecoderChallenge)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T SET DECORDERCHALLENGE \n");
		DBG_BREAK();
		return FALSE;
	}
	
	return TRUE;
}

//`WL[
//UCHAR *CVideoCDStream::GetChlgKey()
BOOL CVideoCDStream::GetChlgKey(UCHAR *ptr)             // 98.03.31 H.Yagi
{
	HALRESULT st;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}
	if((st = m_pIStreamHAL->GetDriveChallenge(ptr)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T GET DRIVERCHALLENGE \n");
		DBG_BREAK();
		return FALSE;
	}
	
	return TRUE;
}

//DVDL[
BOOL CVideoCDStream::SetDVDKey1(UCHAR *pDriveResponse)
{
	HALRESULT st;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}

	if((st = m_pIStreamHAL->SetDriveResponse(pDriveResponse)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T SET DRIVERRESPONSE \n");
		DBG_BREAK();
		return FALSE;
	}
	
	return TRUE;
}

//DVDL[
//UCHAR *CVideoCDStream::GetDVDKey2()
BOOL CVideoCDStream::GetDVDKey2(UCHAR *ptr)
{
	HALRESULT st;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}

	if((st = m_pIStreamHAL->GetDecoderResponse(ptr)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T SET DECORDERRESPONSE \n");
		DBG_BREAK();
		return FALSE;
	}
	
	return TRUE;
}

//^CgL[
BOOL CVideoCDStream::SetTitleKey(UCHAR *pTitleKey)
{
	HALRESULT st;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}

	if((st = m_pIStreamHAL->SetTitleKey(pTitleKey)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T SET TITLEKEY \n");
		DBG_BREAK();
		return FALSE;
	}
	
	return TRUE;
}	

//fBXNL[
BOOL CVideoCDStream::SetDiscKey(UCHAR *pDiscKey)
{
	HALRESULT st;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}

	if((st = m_pIStreamHAL->SetDiskKey(pDiscKey)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T SET DISCKEY \n");
		DBG_BREAK();
		return FALSE;
	}
	
	return TRUE;
}

//rfIvpeB
BOOL CVideoCDStream::GetVideoProperty(VIDEOPROPTYPE PropertyType, PVOID pProperty)
{
	HALRESULT st;
//	PVOID pProperty;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}
	
	if((st = m_pIHAL->GetVideoProperty(PropertyType, pProperty)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T GET PROPERTY \n");
		DBG_BREAK();
		return FALSE;
	}
	
	return TRUE;
}

//rfIvpeB
BOOL CVideoCDStream::SetVideoProperty(VIDEOPROPTYPE PropertyType, PVOID pProperty)
{
	HALRESULT st;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}
	
	if((st = m_pIHAL->SetVideoProperty(PropertyType, pProperty)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T GET PROPERTY \n");
		DBG_BREAK();
		return FALSE;
	}
	
	return TRUE;
}

//I[fBIvpeB
BOOL CVideoCDStream::GetAudioProperty(AUDIOPROPTYPE PropertyType, PVOID pProperty)
{
	HALRESULT st;
//	PVOID pProperty;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}
	
	if((st = m_pIHAL->GetAudioProperty(PropertyType, pProperty)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T GET PROPERTY \n");
		DBG_BREAK();
		return FALSE;
	}
	
	return TRUE;
}

//I[fBIvpeB
BOOL CVideoCDStream::SetAudioProperty(AUDIOPROPTYPE PropertyType, PVOID pProperty)
{
	HALRESULT st;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}
	
	if((st = m_pIHAL->SetAudioProperty(PropertyType, pProperty)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T GET PROPERTY \n");
		DBG_BREAK();
		return FALSE;
	}
	
	return TRUE;
}

//Rs[veNg
BOOL CDVDStream::CppInit()
{
	HALRESULT st;

	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_BREAK();
		return FALSE;
	}
	if((st = m_pIStreamHAL->CPPInit()) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T Initialize CPP\n");
		DBG_BREAK();
		return FALSE;
	}
	return TRUE;
}

//`WL[
BOOL CDVDStream::SetChlgKey(UCHAR *pDecoderChallenge)
{
	HALRESULT st;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_PRINTF(("CLASSLIB:CDVDStream::SetChlgKey:NOT INITILIZE CMPEGBoard \n"));
		DBG_BREAK();
		return FALSE;
	}

	if((st = m_pIStreamHAL->SetDecoderChallenge(pDecoderChallenge)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T SET DECORDERCHALLENGE \n");
		DBG_PRINTF(("CLASSLIB:CDVDStream::SetChlgKey:CAN'T SET DECORDERCHALLENGE \n"));
		DBG_BREAK();
		return FALSE;
	}
	
	DBG_PRINTF(("CLASSLIB:CDVDStream::SetChlgKey:SUCCESS SetDecoderChallenge\n"));
	return TRUE;
}

//`WL[
//UCHAR CDVDStream::GetChlgKey()
BOOL CDVDStream::GetChlgKey(UCHAR *ptr)                 // 98.03.31 H.Yagi
{
	HALRESULT st;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_PRINTF(("CLASSLIB:CDVDStream::GetChlgKey:NOT INITILIZE CMPEGBoard \n"));
		DBG_BREAK();
		return FALSE;
	}
	if((st = m_pIStreamHAL->GetDriveChallenge(ptr)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T GET DRIVERCHALLENGE \n");
		DBG_PRINTF(("CLASSLIB:CDVDStream::GetChlgKey:CAN'T GET DRIVERCHALLENGE \n"));
		DBG_BREAK();
		return FALSE;
	}
	
	DBG_PRINTF(("CLASSLIB:CDVDStream::GetChlgKey:SUCCESS GetDriveChallenge \n"));
	return TRUE;
}

//DVDL[
BOOL CDVDStream::SetDVDKey1(UCHAR *pDriveResponse)
{
	HALRESULT st;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_PRINTF(("CLASSLIB:CDVDStream::SetDVDKey1:NOT INITILIZE CMPEGBoard \n"));
		DBG_BREAK();
		return FALSE;
	}

	if((st = m_pIStreamHAL->SetDriveResponse(pDriveResponse)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T SET DRIVERRESPONSE \n");
		DBG_PRINTF(("CLASSLIB:CDVDStream::SetDVDKey1:CAN'T SET DRIVERRESPONSE \n"));
		DBG_BREAK();
		return FALSE;
	}
	
	DBG_PRINTF(("CLASSLIB:CDVDStream::GetChlgKey:SUCCESS SetDriveResponse \n"));
	return TRUE;
}

//DVDL[
//UCHAR *CDVDStream::GetDVDKey2()
BOOL CDVDStream::GetDVDKey2(UCHAR *ptr)
{
	HALRESULT st;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_PRINTF(("CLASSLIB:CDVDStream::GetDVDKey2:NOT INITILIZE CMPEGBoard \n"));
		DBG_BREAK();
		return FALSE;
	}

	if((st = m_pIStreamHAL->GetDecoderResponse(ptr)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T GET DECORDERRESPONSE \n");
		DBG_PRINTF(("CLASSLIB:CDVDStream::GetDVDKey2:CAN'T GET DECORDERRESPONSE \n"));
		DBG_BREAK();
		return FALSE;
	}
	
	DBG_PRINTF(("CLASSLIB:CDVDStream::GetChlgKey:SUCCESS GetDecoderResponse \n"));
	return TRUE;
}

//^CgL[
BOOL CDVDStream::SetTitleKey(UCHAR *pTitleKey)
{
	HALRESULT st;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_PRINTF(("CLASSLIB:CDVDStream::SetTitleKey:NOT INITILIZE CMPEGBoard \n"));
		DBG_BREAK();
		return FALSE;
	}

	if((st = m_pIStreamHAL->SetTitleKey(pTitleKey)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T SET TITLEKEY \n");
		DBG_PRINTF(("CLASSLIB:CDVDStream::SetTitleKey:CAN'T SET TITLEKEY \n"));
		DBG_BREAK();
		return FALSE;
	}
	
	DBG_PRINTF(("CLASSLIB:CDVDStream::SetTitleKey:SUCCESS SetTitleKey\n"));
	return TRUE;
}	

//fBXNL[
BOOL CDVDStream::SetDiscKey(UCHAR *pDiscKey)
{
	HALRESULT st;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_PRINTF(("CLASSLIB:CDVDStream::SetDiscKey:NOT INITILIZE CMPEGBoard \n"));
		DBG_BREAK();
		return FALSE;
	}

	if((st = m_pIStreamHAL->SetDiskKey(pDiscKey)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T SET DISCKEY \n");
		DBG_PRINTF(("CLASSLIB:CDVDStream::SetDiskKey:CAN'T SET DISCKEY \n"));
		DBG_BREAK();
		return FALSE;
	}
	
	DBG_PRINTF(("CLASSLIB:CDVDStream::SetDiscKey:SUCCESS SetDiskKey\n"));
	return TRUE;
}

//rfIvpeB
BOOL CDVDStream::GetVideoProperty(VIDEOPROPTYPE PropertyType, PVOID pProperty)
{
	HALRESULT st;
//	PVOID pProperty;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_PRINTF(("CLASSLIB:CDVDStream::GetVideoProperty:NOT INITIALIZE CDVDSTREAM \n"));
		DBG_BREAK();
		return FALSE;
	}
	
	if((st = m_pIHAL->GetVideoProperty(PropertyType, pProperty)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T GET PROPERTY \n");
		DBG_PRINTF(("CLASSLIB:CDVDStream::GetVideoProperty:CAN'T GET VIDEOPROPERTY \n"));
		DBG_BREAK();
		return FALSE;
	}
	
	DBG_PRINTF(("CLASSLIB:SUCCESS GETVIDEOPROPERTY\n"));
	return TRUE;
}

//rfIvpeB
BOOL CDVDStream::SetVideoProperty(VIDEOPROPTYPE PropertyType, PVOID pProperty)
{
	HALRESULT st;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_PRINTF(("CLASSLIB:CDVDStream::SetVideoProperty:NOT INITIALIZE CDVDSTREAM \n"));
		DBG_BREAK();
		return FALSE;
	}
	
	if((st = m_pIHAL->SetVideoProperty(PropertyType, pProperty)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T GET PROPERTY \n");
		DBG_PRINTF(("CLASSLIB:CDVDStream::SetVideoProperty:CAN'T SET VIDEOPROPERTY \n"));
		DBG_BREAK();
		return FALSE;
	}
	
	DBG_PRINTF(("CLASSLIB:SUCCESS SETVIDEOPROPERTY\n"));
	return TRUE;
}

//I[fBIvpeB
BOOL CDVDStream::GetAudioProperty(AUDIOPROPTYPE PropertyType, PVOID pProperty)
{
	HALRESULT st;
//    PVOID pProperty;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_PRINTF(("CLASSLIB:CDVDStream::GetAudioProperty:NOT INITIALIZE CDVDSTREAM \n"));
		DBG_BREAK();
		return FALSE;
	}
	
	if((st = m_pIHAL->GetAudioProperty(PropertyType, pProperty)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T GET PROPERTY \n");
		DBG_PRINTF(("CLASSLIB:CDVDStream::GetAudioProperty:CAN'T GET AUDIOPROPERTY \n"));
		DBG_BREAK();
		return FALSE;
	}
	
	DBG_PRINTF(("CLASSLIB:SUCCESS GETAUDIOPROPERTY\n"));
	return TRUE;
}

//I[fBIvpeB
BOOL CDVDStream::SetAudioProperty(AUDIOPROPTYPE PropertyType, PVOID pProperty)
{
	HALRESULT st;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_PRINTF(("CLASSLIB:CDVDStream::SetAudioProperty:NOT INITIALIZE CDVDSTREAM \n"));
		DBG_BREAK();
		return FALSE;
	}
	
	if((st = m_pIHAL->SetAudioProperty(PropertyType, pProperty)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T GET PROPERTY \n");
		DBG_PRINTF(("CLASSLIB:CDVDStream::SetAudioProperty:CAN'T SET AUDIOPROPERTY \n"));
		DBG_BREAK();
		return FALSE;
	}
	
	DBG_PRINTF(("CLASSLIB:SUCCESS SETAUDIOPROPERTY\n"));
	return TRUE;
}

//TusN`vpeB
BOOL CDVDStream::GetSubpicProperty(SUBPICPROPTYPE PropertyType, PVOID pProperty)
{
	HALRESULT st;
//	PVOID pProperty;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_PRINTF(("CLASSLIB:CDVDStream::GetSubpicProperty:NOT INITIALIZE CDVDSTREAM \n"));
		DBG_BREAK();
		return FALSE;
	}
	
	if((st = m_pIHAL->GetSubpicProperty(PropertyType, pProperty)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T GET PROPERTY \n");
		DBG_PRINTF(("CLASSLIB:CDVDStream::GetSubpicProperty:CAN'T GET SUBPICPROPERTY \n"));
		DBG_BREAK();
		return FALSE;
	}
	
	DBG_PRINTF(("CLASSLIB:SUCCESS GETSUBPICPROPERTY\n"));
	return TRUE;
}

//TusN`vpeB
BOOL CDVDStream::SetSubpicProperty(SUBPICPROPTYPE PropertyType, PVOID pProperty)
{
	HALRESULT st;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_PRINTF(("CLASSLIB:CDVDStream::SetSubpicProperty:NOT INITIALIZE CDVDSTREAM \n"));
		DBG_BREAK();
		return FALSE;
	}
	
	if((st = m_pIHAL->SetSubpicProperty(PropertyType, pProperty)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T GET PROPERTY \n");
		DBG_PRINTF(("CLASSLIB:CDVDStream::SetSubpicProperty:CAN'T SET SUBPICPROPERTY \n"));
		DBG_BREAK();
		return FALSE;
	}
	
	DBG_PRINTF(("CLASSLIB:SUCCESS SETSUBPICPROPERTY\n"));
	return TRUE;
}

//Get Property capability                                 98.04.03 H.Yagi
BOOL CDVDStream::GetCapability( CAPSTYPE PropType, DWORD *pPropType )
{
	HALRESULT st;
	
	//I
	if(ISENDSTREAMOBJECTINIT){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_PRINTF(("CLASSLIB:CDVDStream::GetCapability:NOT INITIALIZE CDVDSTREAM \n"));
		DBG_BREAK();
		return FALSE;
	}
	
	if((st = m_pIHAL->GetCapability( PropType, pPropType)) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T GET PROPERTY \n");
		DBG_PRINTF(("CLASSLIB:CDVDStream::SetSubpicProperty:CAN'T SET SUBPICPROPERTY \n"));
		DBG_BREAK();
		return FALSE;
	}
	
	DBG_PRINTF(("CLASSLIB:SUCCESS GetCapability\n"));
	return TRUE;
}


void CBaseStream::FlushTransferBuffer()
{
	((CTransfer *)m_pTransfer)->Flush();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\tecra\cmboard.cpp ===
/*
@{[hNX
@iNP2)@Sachiko Yasukawa
*/
//     Date    |   Author     |  Description
//  -----------+--------------+--------------------------------------------
//  1998.03.27 |  Hideki Yagi | Change the specification about GetSTC().
//

#include "stdafx.h"

#include "includes.h"
#include "classlib.h"


//
BOOL CMPEGBoard::Init()
{
	m_pBaseStreamObject=NULL;
	m_pIHAL=NULL;
	
	return TRUE;
}

//VXg[
//p[^
//IBaseStream@bp[Xg[NX{NX|C^
BOOL CMPEGBoard::AddStreamObjectInterface(IBaseStream *INewStreamObject)
{
	CBaseStream *pBSt1, *pBSt2;
	
	ASSERT(INewStreamObject);

	//HALG[
	//if(m_pIHAL == NULL){
	//	_RPTF0(_CRT_ERROR, "m_pIHAL = NULL\n");
	//	return FALSE;
	//}

	//Xg[B
	//m_pBaseStreamObject ... Xg[
	if(m_pBaseStreamObject == NULL){
		m_pBaseStreamObject = (CBaseStream *) INewStreamObject;
		pBSt1 = m_pBaseStreamObject;
	
	}
	//VXg[
	else{
		pBSt1 = (CBaseStream *)INewStreamObject;
		//MIX^CvXg[
		if(ISMIXSTREAM(pBSt1->m_StreamType) == TRUE || ISMIXSTREAM(m_pBaseStreamObject->m_StreamType) == TRUE){
			_RPTF0(_CRT_ERROR, "INVALID STREAM\n");
			DBG_PRINTF(("CLASSLIB:CMPEGBOARD::AddStreamObjectInterface:SET INVALID TYPE STREAM\n"));
			DBG_BREAK();
			return FALSE;
		}
		//Xg[XgT
		for(pBSt2 = m_pBaseStreamObject; pBSt2->m_pNextStreamObject != NULL; pBSt2 = pBSt2->m_pNextStreamObject);
		pBSt2->m_pNextStreamObject= pBSt1;//XgNextp[^wXg[
		pBSt1->m_pPrevStreamObject = pBSt2;//p[^wXg[PrevXg
	}

	//Xg[g`kC^tF[X|C^B
	pBSt1->m_pIHAL=m_pIHAL;
	
	//Xg[StreamControlHALC^tF[X|C^B
	if(SetHALStream(pBSt1, m_pIHAL) == FALSE){
		_RPTF0(_CRT_ERROR, "CAN'T GET STREAMCONTROLHAL\n");
		DBG_PRINTF(("CLASSLIB:CMPEGBOARD::AddStreamObjectInterface:CAN'T GET STREAMCONTROLHAL\n"));
		DBG_BREAK();
		return FALSE;
	}

	return TRUE;
}

//Xg[
//p[^
//IBaseStream@bp[Xg[NX{NX|C^
BOOL CMPEGBoard::ReleaseStreamObjectInterface(IBaseStream *IReleaseStreamObject)
{
	CBaseStream *pBSt1;
	
	ASSERT(IReleaseStreamObject);

	//Xg[G[
	if(m_pBaseStreamObject == NULL){
		_RPTF0(_CRT_WARN, "NO ADDED STREAM\n");
		DBG_PRINTF(("CLASSLIB:CMPEGBOARD::ReleaseStreamObjectInterface:NO ADDED STREAM\n"));
		DBG_BREAK();
		return FALSE;
	}
	else{
		pBSt1 = (CBaseStream *)IReleaseStreamObject;
		
		//[XH
		
		//Xg[`F[
		pBSt1->m_pPrevStreamObject->m_pNextStreamObject = pBSt1->m_pNextStreamObject;
		pBSt1->m_pNextStreamObject->m_pPrevStreamObject = pBSt1->m_pPrevStreamObject;

		//TransferIuWFNg[X
		ASSERT(((CBaseStream *)IReleaseStreamObject)->m_pTransfer);
		if(((CTransfer *)((CBaseStream *)IReleaseStreamObject)->m_pTransfer)->ReleaseStreamObject(IReleaseStreamObject) == FALSE){
			_RPTF0(_CRT_WARN, "NO RELEASE STREAM FROM TRANSFER OBJECT\n");
			DBG_PRINTF(("CLASSLIB:CMPEGBOARD::ReleaseStreamObjectInterface:CAN'T RELEASE STREAM FROM TRANSFER OBJECT\n"));
			DBG_BREAK();
			return FALSE;
		}
	}

	return TRUE;
}

//dI
BOOL CMPEGBoard::PowerOn()
{
	 return ChangePower(POWERSTATE_ON);	
}

//dIt
BOOL CMPEGBoard::PowerOff()
{
	return ChangePower(POWERSTATE_OFF);
}

//STClZbg
BOOL CMPEGBoard::SetSTC(DWORD time)
{
	//IB
	if(m_pIHAL == NULL || m_pBaseStreamObject == NULL){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_PRINTF(("CLASSLIB:CMPEGBOARD::SetSTC:NOT BE INITILIZE CMPEGBoard CORRECTLY\n"));
		DBG_BREAK();
		return FALSE;
	}
	if(m_pIHAL->SetSTC(time) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T SETSTC \n");
		DBG_PRINTF(("CLASSLIB:CMPEGBOARD::SetSTC:CAN'T SETSTC \n"));
		DBG_BREAK();
		return FALSE;
	}
	return TRUE;
}

//STClQbg
//^[llB
BOOL CMPEGBoard::GetSTC(DWORD *foo)                    // 98.03.27 H.Yagi
{
	DWORD Time;
	
	//IB
	if(m_pIHAL == NULL || m_pBaseStreamObject == NULL){
		_RPTF0(_CRT_ERROR, "NOT INITILIZE CMPEGBoard \n");
		*foo = 0xffffffff;
		return FALSE;
	}

	//STC
	if(m_pIHAL->GetSTC(&Time) != HAL_SUCCESS){
		_RPTF0(_CRT_WARN, "CAN'T GETSTC \n");
        *foo = 0xffffffff;
		return FALSE;                           // 98.04.21 H.Yagi
	}
	*foo = Time;
	return TRUE;
}

//HALIuWFNgC^tF[X
BOOL CMPEGBoard::SetHALObjectInterface(IClassLibHAL *pILibHAL)
{
	CBaseStream *pStream;

	ASSERT(pILibHAL);
	
	m_pIHAL = pILibHAL;

	//10/14
	for(pStream = m_pBaseStreamObject; pStream; pStream = (CBaseStream *)pStream->GetNextStream()){
		if(SetHALStream(pStream, m_pIHAL) == FALSE){
			_RPTF0(_CRT_ERROR, "CAN'T GET STREAMCONTROLHAL\n");
			DBG_PRINTF(("CLASSLIB:CMPEGBOARD::SetHALInterface:CAN'T GET STREAMCONTROLHAL\n"));
			DBG_BREAK();
			return FALSE;
		}
	}
	return TRUE;
}

//dIIt
BOOL CMPEGBoard::ChangePower(POWERSTATE fOnOff)
{
	CBaseStream *pBSt;
	IMPEGBoardBaseState *pState;
	
	//IB
	if(m_pIHAL == NULL || m_pBaseStreamObject == NULL ){
		_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
		DBG_PRINTF(("CLASSLIB:CMPEGBOARD::ChangePower:NOT INITILIZE CMPEGBoard CRRECTLY\n"));
		DBG_BREAK();
		return FALSE;
	}
	else{
		for(pBSt = m_pBaseStreamObject; pBSt; pBSt = pBSt->m_pNextStreamObject){
			
			ASSERT(pBSt->m_pMPEGBoardStateObject);
			
			//BaseState(CPowerOffState, CStopState etc.{NXj|C^
			pState = pBSt->GetIMPEGBoardState();
			
			//IB
			if(pState == NULL){
				_RPTF0(_CRT_WARN, "NOT INITILIZE CMPEGBoard \n");
				DBG_PRINTF(("CLASSLIB:CMPEGBOARD::ChangePower:NOT INITILIZE CMPEGBoard \n"));
				DBG_BREAK();
				return FALSE;
			}

			//dXe[^XX
			//It
			if(fOnOff == POWERSTATE_ON){
				if(!ISPOWEROFF()){
					//_RPTF0(_CRT_WARN, "STATE CHANGE ERROR From PowerON To PowerON\n");
					return TRUE;//FALSEHHH
				}
				if(pState->ChangeStop(m_pIHAL, pBSt->GetHALStreamControl(), NULL) == FALSE){
					_RPTF0(_CRT_WARN, "CANT CHANGE POWERSTATE\n");
					DBG_PRINTF(("CLASSLIB:CMPEGBOARD::ChangePower:CANT CHANGE POWERSTATE\n"));
					DBG_BREAK();
					return FALSE;
				}
			}
			else{
////                if(ISPOWEROFF()){
////                    //_RPTF0(_CRT_WARN, "STATE CHANGE ERROR From PowerOff To PowerOff\n");
////                    return TRUE;//FALSE???
////                }
				if(pState->ChangePowerOff(m_pIHAL, pBSt->GetHALStreamControl()) == FALSE){
					_RPTF0(_CRT_WARN, "CANT CHANGE POWERSTATE");
					DBG_PRINTF(("CLASSLIB:CMPEGBOARD::ChangePower:CANT CHANGE POWERSTATE\n"));
					DBG_BREAK();
					return FALSE;
				}
			}
		}
	}
	return TRUE;
}

BOOL CMPEGBoard::ISPOWEROFF()
{
	POWERSTATE PowerState;
	ASSERT(m_pIHAL);
	m_pIHAL->GetPowerState(&PowerState);
	if(PowerState == POWERSTATE_ON)
		return POWERSTATE_ON;
	else
		return POWERSTATE_OFF;
}

BOOL CMPEGBoard::SetHALStream(CBaseStream *pStream, IClassLibHAL *pIHAL)
{
	HALRESULT st;

	ASSERT(pStream);

	//MIXXg[p
	if(ISMIXSTREAM(pStream->m_StreamType) == TRUE){
		if((st = pIHAL->GetMixHALStream(&pStream->m_pIStreamHAL)) != HAL_SUCCESS){
			if(st != HAL_NOT_IMPLEMENT){
				_RPTF0(_CRT_WARN, "NOT IMPLEMENT");
			}
			//CvgHHH
			_RPTF0(_CRT_WARN, "CAN'T GET MIXHALSTREAM INTERFACE\n");
			DBG_PRINTF(("CLASSLIB:CMPEGBOARD::ChangePower:CAN'T GET MIXHALSTREAM INTERFACE\n"));
			DBG_BREAK();
			return FALSE;
		}
	}
	//PXg[p
	else{
		switch(pStream->m_StreamType){
		case Video:
			st = pIHAL->GetVideoHALStream(&pStream->m_pIStreamHAL);
			break;
		case Audio:
			st = pIHAL->GetAudioHALStream(&pStream->m_pIStreamHAL);
			break;
		case Subpicture:
			st = pIHAL->GetSubpicHALStream(&pStream->m_pIStreamHAL);
			break;
		default:
			_RPTF0(_CRT_WARN, "INVALID STREAMTYPE\n");
			DBG_PRINTF(("CLASSLIB:CMPEGBOARD::SetHALStream:INVALID STREAMTYPE\n"));
			DBG_BREAK();
			return FALSE;
		}
		if(st != HAL_SUCCESS){
			_RPTF0(_CRT_WARN, "INVALID STREAMTYPE\n");
			DBG_PRINTF(("CLASSLIB:CMPEGBOARD::SetHALStream:INVALID STREAMTYPE\n"));
			DBG_BREAK();
			return FALSE;
		}
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\tecra\ctime.cpp ===
//**************************************************************************
//
//      Title   : ctime.cpp
//
//      Date    : 1998.01.27    1st making
//
//      Author  : Toshiba [PCS](PSY) Hideki Yagi
//
//      Copyright 1997 Toshiba Corporation. All Rights Reserved.
//
// -------------------------------------------------------------------------
//
//      Change log :
//
//      Date       Revision                  Description
//   ------------ ---------- -----------------------------------------------
//    1998.01.27   000.0000   1st making.
//
//**************************************************************************
#include    "includes.h"

#include    "ctime.h"
//--- 98.06.01 S.Watanabe
#ifdef DBG
char * DebugLLConvtoStr( ULONGLONG val, int base );
#endif

CTickTime::CTickTime( void )
{
	m_SamplingTime = m_StreamTime = 0;
	m_TimeState = StopState;
	m_Rate = 10000;
}


CTickTime::~CTickTime( void )
{
	m_SamplingTime = m_StreamTime = 0;
	m_TimeState = StopState;
	m_Rate = 10000;
}

BOOL	CTickTime::Stop( void )
{
	DBG_PRINTF(("CTickTime:: Stop !!!! rate = %d\r\n",m_Rate ));
	m_SamplingTime = 0;
	m_StreamTime = 0;
	m_TimeState = StopState;
	return TRUE;
};

BOOL	CTickTime::Pause( void )
{
	DBG_PRINTF(("CTickTime:: Pause !!!! rate = %d\r\n",m_Rate ));
	switch( m_TimeState )
	{
		case StopState:
			break;
		case PauseState:
			break;
		case RunState:
			CalcDiffTime();
			break;
	};
	m_TimeState = PauseState;
	return TRUE;
};

BOOL	CTickTime::Run( void )
{
	DBG_PRINTF(("CTickTime:: Run !!!!  rate = %d\r\n",m_Rate ));

	switch( m_TimeState )
	{
		case StopState:
			m_SamplingTime = GetSystemTime();
			break;
		case PauseState:
			m_SamplingTime = GetSystemTime();
			break;
		case RunState:
			break;
	};

	m_TimeState = RunState;
	return TRUE;
};

BOOL	CTickTime::GetStreamTime( ULONGLONG *time )
{
	switch( m_TimeState )
	{
		case StopState:
			*time = 0;
			break;
		case PauseState:
			*time = m_StreamTime;
			break;
		case RunState:
			CalcDiffTime();
			*time = m_StreamTime;
			break;
	};
//	DBG_PRINTF(("CTickTime:: GetSteamTime Rate = %d Time = 0x%s  STC=0x%x\r\n", m_Rate, DebugLLConvtoStr( *time, 16 ),(DWORD)(*time * 9 / 1000) ));
	return TRUE;
};


ULONGLONG	CTickTime::GetStreamTime( void )
{
	ULONGLONG	TmpTime;
	GetStreamTime( &TmpTime );
	return TmpTime;
};

BOOL	CTickTime::GetStreamSTC( DWORD *time )
{
	*time = (DWORD)(GetStreamTime() * 9 / 1000);
	return TRUE;
};

DWORD	CTickTime::GetStreamSTC( void )
{
	return (DWORD)(GetStreamTime() * 9 / 1000);
};


ULONGLONG   CTickTime::GetSystemTime( void )
{

    ULONGLONG   ticks;
    ULONGLONG   rate;

    ticks = (ULONGLONG)KeQueryPerformanceCounter((PLARGE_INTEGER)&rate).QuadPart;

    //
    // convert from ticks to 100ns clock
    //
    ticks = (ticks & 0xFFFFFFFF00000000) / rate * 10000000 +
            (ticks & 0xFFFFFFFF) * 10000000 /rate;

//    DBG_PRINTF( ("DVDWDM:System time = %x\n\r", ticks ) );
    return( ticks );
}



BOOL	CTickTime::SetRate( DWORD Rate )
{
	if( m_TimeState == RunState )
	{
		CalcDiffTime();
	};
	m_Rate = Rate;
	DBG_PRINTF(("CTickTime:: New Rate !!!!! %d \r\n", Rate ));
	return TRUE;
};


BOOL	CTickTime::SetStreamTime( ULONGLONG time )
{
	if( m_TimeState == StopState )
		return FALSE;
	
//--- 98.09.17 S.Watanabe
//	DBG_PRINTF(("CTickTime:: Set Stream Time 0x%s \r\n", DebugLLConvtoStr( time, 16 )  ));
	DBG_PRINTF(("CTickTime:: Set Stream Time 0x%x( 0x%s(100ns) )\r\n", (DWORD)(time*9/1000), DebugLLConvtoStr( time, 16 ) ));
//--- End.

	m_StreamTime = time;
	m_SamplingTime = GetSystemTime();
	return TRUE;
};

void	CTickTime::CalcDiffTime( void )
{
	ULONGLONG SysTime = GetSystemTime();
	
	if( m_Rate > 10000 )
	{
		m_StreamTime += (SysTime - m_SamplingTime ) / ( m_Rate / 10000 );
	};

	if( m_Rate < 10000 )
	{
		m_StreamTime += (SysTime - m_SamplingTime ) * ( 10000 / m_Rate );
	}
	if( m_Rate == 10000 )
	{
		m_StreamTime += ( SysTime - m_SamplingTime );
	};

	m_SamplingTime = SysTime;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\tecra\clibif.h ===
/*
NXCuC^tF[X
iNP2)@Sachiko Yasukawa
*/
//     Date    |   Author     |  Description
//  -----------+--------------+--------------------------------------------
//  1998.03.27 |  Hideki Yagi | Change the specification about
//             |              | Get***Property().
//

typedef enum {
	PowerOff,
	Stop,
	Pause,
	Play,
	Slow,
	Scan
} LIBSTATE;

class IMPEGBuffer : public IMBoardListItem
{
public:
	virtual DWORD GetPageNum()=0;
	virtual DWORD GetPageSize(DWORD PageNum)=0;
	virtual BOOL GetPagePointer(DWORD PageNum, DWORD *LinearAdd, DWORD *PhyAdd)=0;
	virtual DWORD GetBufferFlag()=0;
};

class IMPEGBoardState
{
public:
	virtual BOOL Init()=0;
};

//class IMPEGBoardLibEvent
//{
//public:
//	virtual void Advice(PVOID)=0;
//	virtual HALEVENTTYPE GetEventType()=0;
//};

class ITransfer
{
public:
	virtual BOOL Init()=0;
	virtual BOOL SetSink(IMPEGBoardEvent *pEvent)=0;
	virtual BOOL UnSetSink(IMPEGBoardEvent *pEvent)=0;
	virtual BOOL SetDMABuffer(DWORD size, BYTE* LinerAdd, BYTE *PhysAdd)=0;
};

class IStateObject;

class IBaseStream
{
public:
	virtual BOOL Init()=0;
	virtual BOOL Play()=0;
	virtual BOOL Stop()=0;
	virtual BOOL Pause()=0;
	virtual BOOL Slow(DWORD)=0;
	virtual BOOL Scan(DWORD)=0;
	virtual BOOL SingleStep()=0;
	virtual LIBSTATE GetState()=0;
	virtual BOOL SendData(IMPEGBuffer *)=0;
 	virtual BOOL SetStateObject(IMPEGBoardState *pState)=0;
	virtual BOOL SetTransferObject(ITransfer *pTransfer)=0;
	virtual BOOL SetTransferMode(HALSTREAMMODE)=0;
	virtual BOOL SetDataDirection( DirectionType type ) = 0;
	virtual BOOL GetDataDirection( DirectionType *ptype ) = 0;
};

class IVideoProperty
{
public:
	virtual BOOL GetVideoProperty(VIDEOPROPTYPE PropertyType, PVOID pProperty)=0;
	virtual BOOL SetVideoProperty(VIDEOPROPTYPE PropetyType, PVOID pProperty)=0;
};

class IAudioProperty
{
public:
	virtual BOOL GetAudioProperty(AUDIOPROPTYPE PropertyType, PVOID pProperty)=0;
	virtual BOOL SetAudioProperty(AUDIOPROPTYPE PropertyType, PVOID pProperty)=0;
};

class ISubpicProperty
{
public:
	virtual BOOL GetSubpicProperty(SUBPICPROPTYPE PropertyType, PVOID pProperty)=0;
	virtual BOOL SetSubpicProperty(SUBPICPROPTYPE PropertyType, PVOID pProperty)=0;
};

class ICopyProtectProperty
{
public:
	virtual BOOL CppInit() =0;
	virtual BOOL SetChlgKey(UCHAR *)=0;
	virtual BOOL GetChlgKey(UCHAR *)=0;
	virtual BOOL SetDVDKey1(UCHAR *)=0;
	virtual BOOL GetDVDKey2(UCHAR *)=0;
	virtual BOOL SetTitleKey(UCHAR *)=0;
	virtual BOOL SetDiscKey(UCHAR *)=0;
};

class IMPEGBoard
{
public:
	virtual BOOL Init()=NULL;
	virtual BOOL AddStreamObjectInterface(IBaseStream *)=NULL;
	virtual BOOL ReleaseStreamObjectInterface(IBaseStream *)=NULL;
	virtual BOOL PowerOn()=NULL;
	virtual BOOL PowerOff()=NULL;
	virtual BOOL SetSTC(DWORD)=NULL;
	virtual BOOL GetSTC(DWORD *)=NULL;
	virtual BOOL SetHALObjectInterface(IClassLibHAL *)=NULL;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\tecra\ctime.h ===
//**************************************************************************
//
//      Title   : CTime.h
//
//      Date    : 1998.01.27    1st making
//
//      Author  : Toshiba [PCS](PSY) Hideki Yagi
//
//      Copyright 1997 Toshiba Corporation. All Rights Reserved.
//
// -------------------------------------------------------------------------
//
//      Change log :
//
//      Date       Revision                  Description
//   ------------ ---------- -----------------------------------------------
//    1998.01.27   000.0000   1st making.
//
//**************************************************************************
class  CTickTime
{
	enum TimeState
	{
		StopState = 0,
		PauseState,
		RunState
	};

public:
	BOOL		GetStreamTime( ULONGLONG *time );
	ULONGLONG	GetStreamTime( void );
	BOOL		GetStreamSTC( DWORD *time );
	DWORD		GetStreamSTC( void );
	BOOL		SetStreamTime( ULONGLONG time );
	
	BOOL		Stop( void );
	BOOL		Pause( void );
	BOOL		Run( void );
	BOOL		SetRate( DWORD rate );

    CTickTime( void );
    ~CTickTime( void );

    ULONGLONG   GetSystemTime();

private:
	void		CalcDiffTime( void );

	ULONGLONG	m_StreamTime;
	ULONGLONG	m_SamplingTime;
    TimeState	m_TimeState;
	DWORD		m_Rate;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\tecra\ctransfer.cpp ===
/*
]NX
iNP2)@Sachiko Yasukawa
*/
#include "stdafx.h"

#include "includes.h"
#include "classlib.h"

#ifdef TEST
IMBoardListItem *pbuffers1[20];
IMBoardListItem *pbuffers2[20];
#endif 

#define ISSETDMABUFFER (m_LinerAdd == NULL) ? FALSE : ((m_PhysAdd == NULL) ? FALSE : ((m_DMABufferSize == 0) ? FALSE : TRUE))
#define ISENDTRANSFERINIT (m_pStreamObject == NULL) ? FALSE : TRUE

BOOL CTransfer::Init( void )
{
	m_pStreamObject = NULL; 
	m_DMABufferSize = 0;
	m_pTopEventList = NULL; 
	m_pLastEventList = NULL; 

	m_pTopQueuedMPEGBuffer = NULL;
	m_pLastQueuedMPEGBuffer = NULL;
	m_pNextTransferMPEGBuffer = NULL;
	m_TopPagePoint = 1;
	m_LastPagePoint = 1;

	//fobOp
	BufCount = 0;
	StreamCount = 0;
	return TRUE;
};

//fXgN^@obt@c
CTransfer::~CTransfer()
{
	CTransferStreamList *pDeleteStreamList;

	for( ;m_pStreamObject; ){
		pDeleteStreamList = m_pStreamObject;
		m_pStreamObject = (CTransferStreamList *)m_pStreamObject->GetNext();
		delete pDeleteStreamList;
		//fobOp
		StreamCount--;
		ASSERT(StreamCount>=0);
	}
	ASSERT(StreamCount == 0);
//	DBG_PRINTF(("CLASSLIB:StreamCount = %d\n", StreamCount));
}

//CxgIuWFNgZbgB
BOOL CTransfer::SetSink(IMPEGBoardEvent *pEvent)
{
	ASSERT(pEvent);
	
	// CxgIuWFNgNext
	pEvent->SetNext( NULL );

	//B
	//CxgXg
	if(m_pTopEventList == NULL)
		m_pTopEventList = m_pLastEventList = (IMBoardListItem *)pEvent;//LXg
	else{
		m_pLastEventList->SetNext((IMBoardListItem *)pEvent);//LXg
		m_pLastEventList = (IMBoardListItem *)pEvent;//LXg
	}
	
	return TRUE;
}

//CxgIuWFNgBAdd by Nakamura
BOOL CTransfer::UnSetSink(IMPEGBoardEvent *pEvent)
{
	ASSERT(pEvent);
	//CxgXgB

	// CxgXgAG[
	if(m_pTopEventList == NULL || m_pLastEventList == NULL )
		return FALSE;

	// Po^
	if( m_pTopEventList == pEvent && m_pLastEventList == pEvent )
	{
		m_pTopEventList = m_pLastEventList = NULL;
		return TRUE;
	};

	// Qo^AIuWFNggp
	if( m_pTopEventList == pEvent && m_pLastEventList != pEvent )
	{
		m_pTopEventList = m_pTopEventList->GetNext();
		return TRUE;
	};

	// Qo^AQ~
	IMBoardListItem *pTmpEvent;
	for( pTmpEvent = m_pTopEventList; pTmpEvent != NULL; pTmpEvent = pTmpEvent->GetNext() )
	{
		// XgCxgIuWFNgH
		if( pTmpEvent->GetNext() == pEvent )
		{
			// IuWFNgA
			if( pTmpEvent->GetNext() == m_pLastEventList )
				m_pLastEventList = pTmpEvent;
			
			// Xg
			pTmpEvent->SetNext( pTmpEvent->GetNext()->GetNext() );

			return TRUE;
		};
	};

	DBG_PRINTF(("CLASSLIB: CALLED CTransfer::UnSetSinkError!!!\n"));
	DBG_BREAK();
	return FALSE;
}

//DMABufferB
BOOL CTransfer::SetDMABuffer(DWORD size, BYTE* LinerAdd, BYTE *PhysAdd)
{
	ASSERT(LinerAdd);
	ASSERT(PhysAdd);

/*	
	if(!ISENDTRANSFERINIT)
		return MBC_NOTINITIALIZE;
	
	m_LinerAdd = LinerAdd;
	m_PhysAdd = PhysAdd;
	m_DMABufferSize = size;
*/
	return TRUE;
}

//QueueB
BOOL CTransfer::EnQueue( IMPEGBuffer *pBuffer )
{
	ASSERT( pBuffer != NULL );

	pBuffer->SetNext( NULL );

	//]obt@
	if(m_pTopQueuedMPEGBuffer == NULL){
		m_pTopQueuedMPEGBuffer = m_pLastQueuedMPEGBuffer = m_pNextTransferMPEGBuffer = pBuffer;
		m_TopPagePoint = 1;
		m_LastPagePoint = 1;
//		DBG_PRINTF(("CLASSLIB: m_pTopQueuedTOPMPEGBuffer = 0x%X\n", (DWORD)m_pTopQueuedMPEGBuffer));
//		DBG_PRINTF(("CLASSLIB: m_pLastQueuedTOPMPEGBuffer = 0x%X\n", (DWORD)m_pLastQueuedMPEGBuffer));
//		DBG_PRINTF(("CLASSLIB: PageSize = %d\n", pBuffer->GetPageNum()));
	}
	else{
		m_pLastQueuedMPEGBuffer->SetNext(pBuffer);
		m_pLastQueuedMPEGBuffer = pBuffer;
		if( m_pNextTransferMPEGBuffer == NULL )
		{
			m_pNextTransferMPEGBuffer = m_pLastQueuedMPEGBuffer;
			m_LastPagePoint = 1;
		};
//		DBG_PRINTF(("CLASSLIB: m_pTopQueuedTOPMPEGBuffer = 0x%X\n", (DWORD)m_pTopQueuedMPEGBuffer));
//		DBG_PRINTF(("CLASSLIB: m_pLastQueuedTOPMPEGBuffer = 0x%X\n", (DWORD)m_pLastQueuedMPEGBuffer));
//		DBG_PRINTF(("CLASSLIB: PageSize = %d\n", pBuffer->GetPageNum()));
	}

//	DBG_PRINTF(("CLASSLIB: CALLED CTransfer::EnQueue\n"));
	
	if(!ISENDTRANSFERINIT){
		DBG_PRINTF(("CLASSLIB:CTRANSFER::ENQUEUE:NOT INTIALIZE CTRANSFER\n"));
		DBG_BREAK();
		return FALSE;
	}

	return TRUE;
}

//Queue]
BOOL CTransfer::DeQueue()
{
	DWORD PageNum;
	CBaseStream *pStream;
	CTransferStreamList *pStreamList;
	IHALStreamControl *pHALStream;
	DWORD pLinear, pPhys, Flag;
	int BufSize;

//	DBG_PRINTF(("CLASSLIB: CALLED CTransfer::DeQueue\n"));
	
	if(!ISENDTRANSFERINIT){
		DBG_PRINTF(("CLASSLIB:CTRANSFER::DEQUEUE:NOT INTIALIZE CTRANSFER\n"));
		DBG_BREAK();
		return FALSE;
	}

	//pStream = m_pStreamObject->GetBaseStrem();
	//DMAobt@
	if(ISSETDMABUFFER){
		
	}
	//DMAobt@g
	else{
		for(pStreamList = m_pStreamObject; pStreamList; pStreamList = (CTransferStreamList *)pStreamList->GetNext()){
			pStream = pStreamList->GetBaseStream();
			ASSERT(pStream);
			pHALStream = pStream->GetHALStreamControl();
			ASSERT(pHALStream);
			
			DWORD QueueNum;
			HALRESULT st;
			DWORD Count;
			
			//Xgobt@f[^]
			if((st = pHALStream->GetAvailableQueue( &QueueNum )) != HAL_SUCCESS){
				_RPT0(_CRT_WARN, "CAN'T GETAVAILABLEQUEUE\n");
				DBG_PRINTF(("CLASSLIB:CTransfer::DeQueue:CAN'T GETAVAILABLEQUEUE\n"));
				DBG_BREAK();
				return FALSE;
			}
			for(Count = 0; Count < QueueNum ; Count++){
				IMPEGBuffer *pBuffer = NULL;
				if( GetNextTransferPoint( &pBuffer, &PageNum ) == FALSE )
					return TRUE;

				if(!pBuffer->GetPagePointer(PageNum, &pLinear, &pPhys)){
					return FALSE;
				}
				//CClassLibBufferTCY
				BufSize = pBuffer->GetPageSize(PageNum);
				//CClassLibBufferflag
				if(PageNum == 1)
					Flag = pBuffer->GetBufferFlag();
				else
					Flag = 0; //R[fBO
				//Vobt@NX
				CClassLibBuffer *pBuf = m_Mem.Alloc(pBuffer, pStream, PageNum, BufSize, pPhys, pLinear, Flag);//f[^
				
				if(!pBuf){
					_RPTF0(_CRT_WARN, "CAN'T New");
					DBG_PRINTF(("CLASSLIB:CTRANSFER::ENQUEUE:CAN'T NEW\n"));
					DBG_BREAK();
					return FALSE;
				}

		//fobOp
		BufCount++;

//				DBG_PRINTF(("CLASSLIB: Dequeue: Senddata(%d) pBuffer =  0x%X  IMPEGBuff=0x%x\n", BufCount, (DWORD)pBuf,pBuffer ));
				if((st = pHALStream->SendData(pBuf)) != HAL_SUCCESS){
					_RPT0(_CRT_WARN, "CAN'T SENDDATA TO HAL\n");
					DBG_PRINTF(("CLASSLIB:CTransfer::DeQueue:CAN'T SENDDATA TO HAL\n"));
					DBG_BREAK();
					return FALSE;
				}

			}
		}
	}
	return TRUE;
}
//TransferIuWFNgXg[B
BOOL CTransfer::AddStreamObject(IBaseStream *INewStreamObject)
{
	//CBaseStream *pBSt1, *pBSt2;
	CTransferStreamList *pNewTransferStreamList, *pStreamList;

	ASSERT(INewStreamObject);
	
	pNewTransferStreamList = new CTransferStreamList((CBaseStream *)INewStreamObject);
	
	if(!pNewTransferStreamList){
		DBG_PRINTF(("CLASSLIB:CTRANSFER::AddStreamObject:CAN'T NEW\n"));
		DBG_BREAK();
		return FALSE;
	}
	
	//fobOp
	StreamCount++;

	//Xg[B
	if(m_pStreamObject == NULL){
		m_pStreamObject = pNewTransferStreamList;
		//pBSt1 = m_pStreamObject->GetBaseStream();
		//pHALStream = m_pBSt1->GetHALStreamControl();
		m_pIHAL = m_pStreamObject->GetBaseStream()->GetClassLibHAL();
		m_EndOfTransferEvent.SetEventType(ClassLibEvent_SendData);
		m_EndOfTransferEvent.SetTransfer(this);
		m_pIHAL->SetSinkClassLib((IMPEGBoardEvent *)/*(CClassLibEvent *)*/&m_EndOfTransferEvent);
	}
	//VXg[
	else{
		//pBSt1 = pNewTransferStreamList;
		for(pStreamList = m_pStreamObject; pStreamList->GetNext() != NULL; pStreamList = (CTransferStreamList *)pStreamList->GetNext());
		pStreamList->SetNext((IMBoardListItem *)pNewTransferStreamList);
	}
	
	return TRUE;
}
//TransferIuWFNgXg[B
BOOL CTransfer::ReleaseStreamObject(IBaseStream *IStreamObject)
{
	CTransferStreamList *pStreamList, *pNextStreamList;
	CBaseStream *pBaseStream;
	
	ASSERT(IStreamObject);

	//Xg[G[
	if(m_pStreamObject == NULL){
		_RPTF0(_CRT_WARN, "CTransfer:THERE IS NO STREAM WHICH SHOULD BE RELEASED\n");
		DBG_PRINTF(("CLASSLIB:CTRANSFER::ReleaseStreamObject:THERE IS NO STREAM WHICH SHOULD BE RELEASED\n"));
		DBG_BREAK();
		return FALSE;
	}
	else{
		for(pStreamList = m_pStreamObject; ; pStreamList = (CTransferStreamList *)pStreamList->GetNext()){
			if((pNextStreamList = (CTransferStreamList *)pStreamList->GetNext()) == NULL){
				_RPTF0(_CRT_WARN, "CTransfer:THERE IS SUCH A STREAM WHICH SHOULD BE RELEASED\n");
				DBG_PRINTF(("CLASSLIB:CTRANSFER::ReleaseStreamObject:THERE IS SUCH A STREAM WHICH SHOULD BE RELEASED\n"));
				DBG_BREAK();
				return FALSE;
			}
			if((pBaseStream = (CBaseStream *)pNextStreamList->GetBaseStream()) == (CBaseStream *)IStreamObject){
				break;
			}
			ASSERT(pBaseStream);
		}
		pStreamList->SetNext(pNextStreamList->GetNext());
		delete pNextStreamList;
		//fobOp
		StreamCount--;
		ASSERT(StreamCount>=0);
	}
	return TRUE;
}


//QueuetbVB
void CTransfer::Flush()
{
	CTransferStreamList *pStreamList;
	CBaseStream *pBaseStream;
	IMPEGBoardEvent *pEvent;

	DBG_PRINTF(("CLASSLIB:Before flash BufCount = %d\n", BufCount));

	m_Mem.Flush();
	BufCount=0;
	
	for(pStreamList = m_pStreamObject; pStreamList; pStreamList  = (CTransferStreamList *)pStreamList->GetNext()){
		pBaseStream = pStreamList->GetBaseStream();
		DWORD PageNum;
		ASSERT(pBaseStream);

		IMPEGBuffer *pBuffer = NULL;
		BOOL NeedAdvice = FALSE;

		// StreamQueueobt@A]}[NB
		while( TRUE )
		{
			if( GetNextTransferPoint( &pBuffer, &PageNum ) == FALSE )
				break;
		}

		while( HasQueuedBuffer() == TRUE )
		{
			NeedAdvice = FreeTopTransferPoint(&pBuffer);
			if( NeedAdvice == TRUE )
			{
				for(pEvent = (IMPEGBoardEvent *)m_pTopEventList; pEvent != NULL;pEvent = (IMPEGBoardEvent *)((IMBoardListItem *)pEvent)->GetNext())
				{
					if((/*(CClassLibEvent *)*/pEvent)->GetEventType() == ClassLibEvent_SendData){
						//MPEGBuffer
						//WrappergIm
						pEvent->Advice(pBuffer);
					}
				}
			};
		}
	}
	DBG_PRINTF(("CLASSLIB:After flush BufCount = %d\n", BufCount));
	ASSERT( BufCount == 0 );
}

//f[^]I
BOOL CTransfer::EndOfTransfer(CClassLibBuffer *pBuffer)
{
	IMPEGBoardEvent *pEvent;
	CBaseStream *pStream;
	CTransferStreamList *pStreamList;
		
//	DBG_PRINTF(("CLASSLIB: EndOfTransfer(%d) pBuffer =  0x%X\n", BufCount, (DWORD)pBuffer));
//	DBG_PRINTF(("CLASSLIB: pBuffer->GetIMPEGBuffer() = 0x%X\n", (DWORD)pBuffer->GetIMPEGBuffer()));

	ASSERT(pBuffer);
	pStream = pBuffer->GetStream();
	ASSERT(pStream);
	
	IMPEGBuffer *pFree = NULL;
	if( FreeTopTransferPoint(&pFree) == TRUE )
	{
//		DBG_PRINTF(("CLASSLIB: Free IMPEGBuffer() = 0x%X\n", (DWORD)pFree ));
		ASSERT( pFree == pBuffer->GetIMPEGBuffer()  );
		//Wrappernobt@y[Wobt@[J
		for(pEvent = (IMPEGBoardEvent *)m_pTopEventList; pEvent != NULL;pEvent = (IMPEGBoardEvent *)((IMBoardListItem *)pEvent)->GetNext()){
			if(pEvent->GetEventType() == ClassLibEvent_SendData){
				//WrappergIm
//				DBG_PRINTF(("CLASSLIB: EndOfTransfer Advice Buffer =  0x%X\n", pBuffer->GetIMPEGBuffer() ));
				pEvent->Advice(pBuffer->GetIMPEGBuffer());
			}
		}
	}
	//XgCClassLibBuffer
	m_Mem.Free(pBuffer);
	//fobOp
	BufCount--;
	ASSERT(BufCount>=0);

	//STOPHALSendData
	for(pStreamList = m_pStreamObject; pStreamList; pStreamList = (CTransferStreamList *)pStreamList->GetNext()){
			pStream = pStreamList->GetBaseStream();
			ASSERT(pStream);
			if(pStream->GetState() == Stop)
				return TRUE;
	}

	if(DeQueue() == FALSE){
		DBG_PRINTF(("CLASSLIB:CTRANSFER::EndOfTransfer:CAN'T DEQUEUE\n"));
		DBG_BREAK();
		return FALSE;
	}
	
	return TRUE;
}


BOOL	CTransfer::HasQueuedBuffer( void )
{
	if( m_pTopQueuedMPEGBuffer == NULL )
		return FALSE;
	return TRUE;
};


BOOL	CTransfer::GetNextTransferPoint( IMPEGBuffer **Point, DWORD *Page )
{
	if( m_pNextTransferMPEGBuffer == NULL )
	{
		*Point = NULL;
		*Page = 0;
		return FALSE;
	};

	*Point = m_pNextTransferMPEGBuffer;
	*Page = m_LastPagePoint;

	if( m_pNextTransferMPEGBuffer->GetPageNum() == m_LastPagePoint )
	{
		m_pNextTransferMPEGBuffer = (IMPEGBuffer *)m_pNextTransferMPEGBuffer->GetNext();
		m_LastPagePoint = 1;
		return TRUE;
	};

	m_LastPagePoint ++;
	return TRUE;
};

BOOL	CTransfer::FreeTopTransferPoint( IMPEGBuffer **Free )
{
	ASSERT( m_pTopQueuedMPEGBuffer != NULL );

	if( m_pTopQueuedMPEGBuffer == NULL 
		|| ( m_pTopQueuedMPEGBuffer == m_pNextTransferMPEGBuffer && m_LastPagePoint == m_TopPagePoint ) )
	{
		*Free = NULL;
		return FALSE;
	};

	if( m_TopPagePoint == m_pTopQueuedMPEGBuffer->GetPageNum() )
	{
		*Free = m_pTopQueuedMPEGBuffer;
		m_pTopQueuedMPEGBuffer = (IMPEGBuffer *)m_pTopQueuedMPEGBuffer->GetNext();
		m_TopPagePoint = 1;
		return TRUE;		// Need Advice
	};

	*Free = NULL;
	m_TopPagePoint ++;

	return FALSE;		// Not Need Advice
	
};


//HAL
void CClassLibEvent::Advice(PVOID pBuffer)
{
	ASSERT(m_pTransfer);
	m_pTransfer->EndOfTransfer((CClassLibBuffer *)pBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\tecra\ctvctrl.cpp ===
//**************************************************************************
//
//      Title   : CTVCtrl.cpp
//
//      Date    : 1998.06.29    1st making
//
//      Author  : Toshiba [PCS](PSY) Hideki Yagi
//
//      Copyright 1997-1998 Toshiba Corporation. All Rights Reserved.
//
// -------------------------------------------------------------------------
//
//      Change log :
//
//      Date       Revision                  Description
//   ------------ ---------- -----------------------------------------------
//    1998.06.29   000.0000   1st making.
//
//**************************************************************************
#include        "includes.h"
#include        "ctvctrl.h"

//#include <ntddk.h>
//#include <string.h>
//#include <devioctl.h>
//#include <windef.h>
#include "Acpiioct.h"	// ACPI Driver Interface

CTVControl::CTVControl( void )
{
    ;
};


CTVControl::~CTVControl( void )
{
    ;
};


BOOL    CTVControl :: Initialize( void )
{
	PFILE_OBJECT	TvaldFileObject;
	STRING			NameString;
	NTSTATUS		status;

#ifndef	TVALD
    UNICODE_STRING	RegPath;
	STRING			KeyPathString;
	DWORD			DeviceReference, Count;
	char			keyname[512];
#endif

	DBG_PRINTF( ( "CTVControl::Initialize() RtlInitString\n") );
	RtlInitString( &NameString, TVALDDRVR_DEVICE_OPEN_NAME );
	DBG_PRINTF( ( "CTVControl::Initialize() RtlAnsiStringToUnicodeString\n") );
	RtlAnsiStringToUnicodeString( &UNameString, &NameString, TRUE );

	is_init_success = TRUE;	// add by do '98-08-04
	//
	// get the device object for the TVALD.sys
	//
	DBG_PRINTF( ( "CTVControl::Initialize() IoGetDeviceObjectPointer\n") );
	status = IoGetDeviceObjectPointer(
				&UNameString,
				FILE_ANY_ACCESS,
				&TvaldFileObject,
				&TvaldDeviceObject
				);
	if (status != STATUS_SUCCESS){
        DBG_PRINTF( ( "CTVControl::Initialize()   IoGetDeviceObjectPointer Error!!\n") );

#ifndef TVALD
	    RTL_QUERY_REGISTRY_TABLE    Table[2];
	//
	// TVALD Install check
	//
	    RtlInitUnicodeString( &RegPath, L"\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Services\\TVALD\\Enum");
	    RtlZeroMemory( Table, sizeof(Table) );
    	Table[0].Flags         = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
	    Table[0].Name          = L"Count";
    	Table[0].EntryContext  = &Count;
	    Table[0].DefaultType   = REG_DWORD;
    	Table[0].DefaultData   = &RegPath;
	    Table[0].DefaultLength = sizeof(ULONG);
    	DBG_PRINTF( ("DVDINIT:RtlQueryRegistryValues Count\n\r") );

	    status = RtlQueryRegistryValues( RTL_REGISTRY_ABSOLUTE,
    	                                RegPath.Buffer,
        	                            Table,
            	                        NULL,
                	                    NULL );
		if (status != STATUS_SUCCESS){
    	    DBG_PRINTF( ( "CTVControl::Initialize()   RtlQueryRegistryValues Get Count Error!!\n") );
			RtlFreeUnicodeString( &UNameString );
			is_init_success = FALSE;	// add by do '98-08-04
			return( FALSE );
		}
    	DBG_PRINTF( ("DVDINIT:RtlQueryRegistryValues success Count = %x\n\r", Count) );
		if (Count != 1)
		{
    	    DBG_PRINTF( ( "CTVControl::Initialize()   RtlQueryRegistryValues Count != 1!!\n") );
			RtlFreeUnicodeString( &UNameString );
			is_init_success = FALSE;	// add by do '98-08-04
			return( FALSE );
		}

	//
	// Search control-key
	//
	    RtlInitUnicodeString( &RegPath, L"\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Enum\\ACPI\\TOS6200");
		PKEY_BASIC_INFORMATION pControllerKeyInformation;
	    OBJECT_ATTRIBUTES objectAttributes;
		UCHAR keyBuffer[256];                    // Allow for variable length name at end
		ULONG resultLength;
    	HANDLE openKey = NULL;

	    InitializeObjectAttributes(&objectAttributes,
									&RegPath,
									OBJ_CASE_INSENSITIVE,
									NULL,
									NULL);

	    status = ZwOpenKey(&openKey,
    	                   KEY_READ,
        	               &objectAttributes);

		if (status != STATUS_SUCCESS){
    	    DBG_PRINTF( ( "CTVControl::Initialize()   ZwOpenKey Error!!\n") );
			RtlFreeUnicodeString( &UNameString );
			is_init_success = FALSE;	// add by do '98-08-04
			return( FALSE );
		}
		RtlZeroMemory(keyBuffer, sizeof(keyBuffer));
	    pControllerKeyInformation = (PKEY_BASIC_INFORMATION) keyBuffer;
		for(int Index=0; Index < 256; Index++)
		{
			status = ZwEnumerateKey(openKey,
									Index,
    								KeyBasicInformation,
				                    pControllerKeyInformation,
		    	                	sizeof(keyBuffer),
			        	            &resultLength);

			if (status != STATUS_SUCCESS)
			{
    		    DBG_PRINTF( ( "CTVControl::Initialize()   ZwOpenKey Error!!\n") );
				RtlFreeUnicodeString( &UNameString );
				is_init_success = FALSE;	// add by do '98-08-04
				ZwClose(openKey);
				return( FALSE );
			}
			char szSchKey[256];
			for(int schcnt = 0; schcnt < 256; schcnt++)
			{
				szSchKey[schcnt] = (char)pControllerKeyInformation->Name[schcnt];
				if (szSchKey[schcnt] == NULL)
					break;
			}
			memset(keyname,NULL,sizeof(keyname));
		    memcpy( keyname, "\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Enum\\ACPI\\TOS6200\\",61);
			memcpy((&(keyname[61])), szSchKey,(pControllerKeyInformation->NameLength / 2));
			memcpy((&(keyname[61 + (pControllerKeyInformation->NameLength / 2)])),"\\Control",8);
	    	DBG_PRINTF( ("DVDINIT:ZwEnumerateKey NameString = %s\n\r", keyname) );
			break;
		}
		ZwClose(openKey);
	//
	// get the device object for the TVALD.sys
	//
		RtlInitString( &KeyPathString, keyname );
		RtlAnsiStringToUnicodeString( &RegPath, &KeyPathString, TRUE );
	    RtlZeroMemory( Table, sizeof(Table) );
    	Table[0].Flags         = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
	    Table[0].Name          = L"DeviceReference";
    	Table[0].EntryContext  = &DeviceReference;
	    Table[0].DefaultType   = REG_DWORD;
    	Table[0].DefaultData   = &RegPath;
	    Table[0].DefaultLength = sizeof(ULONG);
    	DBG_PRINTF( ("DVDINIT:RtlQueryRegistryValues DeviceReference\n\r") );
    
	    status = RtlQueryRegistryValues( RTL_REGISTRY_ABSOLUTE,
    	                                RegPath.Buffer,
        	                            Table,
            	                        NULL,
                	                    NULL );
		if (status != STATUS_SUCCESS){
    	    DBG_PRINTF( ( "CTVControl::Initialize()   RtlQueryRegistryValues Get DeviceReference Error!!\n") );
			RtlFreeUnicodeString( &UNameString );
			is_init_success = FALSE;	// add by do '98-08-04
			return( FALSE );
		}
    	DBG_PRINTF( ("DVDINIT:RtlQueryRegistryValues success DeviceReference = %x\n\r", DeviceReference) );

		TvaldDeviceObject = (PDEVICE_OBJECT)DeviceReference;
		TvaldDeviceObject = TvaldDeviceObject->AttachedDevice;
#else
		RtlFreeUnicodeString( &UNameString );
		is_init_success = FALSE;	// add by do '98-08-04
		return( FALSE );
#endif	TVALD
	}

	DBG_PRINTF( ( "CTVControl::Initialize() KeInitializeObject\n") );
	KeInitializeEvent(&event, NotificationEvent, FALSE);

	inputreg.GHCI_EAX = 0x0000f100;
	inputreg.GHCI_EBX = inputreg.GHCI_ECX = inputreg.GHCI_EDX = 
	inputreg.GHCI_ESI = inputreg.GHCI_EDI = 0x0;
	if( Tvald_GHCI( &inputreg ) == FALSE ){		// SCI Interface Open
		DBG_PRINTF( ( "CTVControl::Initialize() SCI Interface Open Error! \n") );
		is_init_success = FALSE;	// add by do '98-08-04
		return (FALSE);
	}
	
    return( TRUE );
};


BOOL    CTVControl :: Uninitialize( void )
{
	inputreg.GHCI_EAX = 0x0000f200;
	inputreg.GHCI_EBX = inputreg.GHCI_ECX = inputreg.GHCI_EDX = 
	inputreg.GHCI_ESI = inputreg.GHCI_EDI = 0x0;
	if( Tvald_GHCI( &inputreg ) == FALSE ){		// SCI Interface Close
		DBG_PRINTF( ( "CTVControl::Uninitialize() SCI Interface Close Error!\n") );
		is_init_success = FALSE;	// add by do '98-08-04
		return (FALSE);
	}

	DBG_PRINTF( ( "CTVControl::Uninitialize() RtlFreeUnicodeString\n") );
	RtlFreeUnicodeString( &UNameString );
    return( TRUE );
};


BOOL    CTVControl :: GetDisplayStatus( PVOID status )
{
    DisplayStatusStruc  *pDisplayStat;
    
	DBG_PRINTF( ( "CTVControl::GetDisplayStatus() begin --->\n") );
	if(is_init_success == FALSE){	// add by do '98-08-04
		DBG_PRINTF( ( "CTVControl::GetDisplayStatus() end <--- is_init_success == FALSE\n") );
		return (FALSE);				// add by do '98-08-04
	}

    pDisplayStat = (DisplayStatusStruc *)status;
	// Get Current Display Status from BIOS by using ASl call.
	inputreg.GHCI_EAX = 0x0000fe00;
	inputreg.GHCI_EBX = 0x00000035;
	inputreg.GHCI_ECX = 0x0;
	inputreg.GHCI_EDX = 0x0;
	inputreg.GHCI_ESI = 0x0;
	inputreg.GHCI_EDI = 0x0;
	if( Tvald_GHCI( &inputreg ) == FALSE ){
		DBG_PRINTF( ( "CTVControl::GetDisplayStatus() Tvald_GHCI Error!\n") );
		return (FALSE);
	}

	if( (inputreg.GHCI_EAX & 0x0000ff00) != 0 ){
        DBG_PRINTF( ( "CTVControl::GetDisplayStatus()   Get Display Status Error!!\n") );
		return( FALSE );
	}

	pDisplayStat->SizeofStruc = sizeof(DisplayStatusStruc);
	pDisplayStat->AvailableDisplay = (inputreg.GHCI_EBX & 0x00000700)>>8;
	pDisplayStat->CurrentDisplay = ((inputreg.GHCI_EBX & 0x00000078) << 25)|
									(inputreg.GHCI_EBX & 0x00000007);

	DBG_PRINTF( ( "CTVControl::GetDisplayStatus() end <---\n") );
    return( TRUE );
};


BOOL    CTVControl :: SetDisplayStatus( PVOID status )
{
    DisplayStatusStruc  *pDisplayStat, currStat;
    ULONG	setstatusreg, getstatusreg;
    
	DBG_PRINTF( ( "CTVControl::SetDisplayStatus() begin --->\n") );
	if(is_init_success == FALSE){	// add by do '98-08-04
		DBG_PRINTF( ( "CTVControl::SetDisplayStatus() end <--- is_init_success == FALSE\n") );
		return (FALSE);				// add by do '98-08-04
	}

    pDisplayStat = (DisplayStatusStruc *)status;
	setstatusreg = pDisplayStat->CurrentDisplay;

    // 98.11.17 H.Yagi
    currStat.AvailableDisplay = 0x0;
    currStat.CurrentDisplay = 0x0;
    GetDisplayStatus( &currStat );
    getstatusreg = ( (currStat.CurrentDisplay & 0x0f0000000)>>25 );
    if( (getstatusreg & 0x40)==0x00 ){        	          // single mode
        getstatusreg = (getstatusreg & 0x008) | 0x040;    // keep TV type bit
    }    

//	getstatusreg = ((pDisplayStat->CurrentDisplay & 0x30000000) >> 25) | 0x00000040;

    // Set Current Display Status from BIOS by using ASl call.
	inputreg.GHCI_EAX = 0x0000ff00;
	inputreg.GHCI_EBX = 0x00000035;
	inputreg.GHCI_ECX = (setstatusreg & 0x00000007)|  getstatusreg;
	inputreg.GHCI_EDX = 0x0;
	inputreg.GHCI_ESI = 0x0;
	inputreg.GHCI_EDI = 0x0;
	if( Tvald_GHCI( &inputreg ) == FALSE ){
		DBG_PRINTF( ( "CTVControl::SetDisplayStatus() Tvald_GHCI Error!\n") );
		return (FALSE);
	}

	if( (inputreg.GHCI_EAX & 0x0000ff00) != 0 ){
        DBG_PRINTF( ( "CTVControl::SetDisplayStatus()   Set Display Status Error!!\n") );
		DBG_PRINTF( ( "CTVControl::SetDisplayStatus() end <---\n") );
		return( FALSE );
	}

	DBG_PRINTF( ( "CTVControl::SetDisplayStatus() end <---\n") );
    return( TRUE );
};


BOOL    CTVControl :: SetTVOutput( DWORD status )
{
	DBG_PRINTF( ( "CTVControl::SetTVOutput() begin --->\n") );

	if(is_init_success == FALSE){	// add by do '98-08-04
		DBG_PRINTF( ( "CTVControl::SetTVOutput() end <--- is_init_success == FALSE\n") );
		return (FALSE);				// add by do '98-08-04
	}

    switch( status ){
        case DISABLE_TV:
        	// Set status
        	inputreg.GHCI_ECX = 0x00000001;	// Play back "In progress" copy protected DVD.
            break;

        case ENABLE_TV:
        	// Set status
        	inputreg.GHCI_ECX = 0;	// Play back "Done" copy protected DVD.
            break;

        default:
            break;
    }
	inputreg.GHCI_EAX = 0x0000ff00;
	inputreg.GHCI_EBX = 0x00000036;
	inputreg.GHCI_EDX = 0x0;
	inputreg.GHCI_ESI = 0x0;
	inputreg.GHCI_EDI = 0x0;
	if( Tvald_GHCI( &inputreg ) == FALSE ){
		DBG_PRINTF( ( "CTVControl::SetTVOutput() Tvald_GHCI Error!\n") );
		return (FALSE);
	}

	if( (inputreg.GHCI_EAX & 0x0000ff00) != 0 ){
        DBG_PRINTF( ( "CTVControl::SetTVOutput()   Set Display Status Error!!\n") );
		DBG_PRINTF( ( "CTVControl::SetTVOutput() end <---\n") );
		return( FALSE );
	}

	DBG_PRINTF( ( "CTVControl::SetTVOutput() end <---\n") );
    return( TRUE );
};


//void	CTVControl :: Tvald_GHCI( PGHCI_INTERFACE pinputreg )
BOOL	CTVControl :: Tvald_GHCI( PGHCI_INTERFACE pinputreg )
{
	PIRP			irp;
	NTSTATUS		status;
	IO_STATUS_BLOCK	iostatus;
	USHORT			index;
	PULONG			pUlongTmpInput, pUlongTmpOutput;

	DBG_PRINTF( ( "CTVControl::Tvald_GHCI() begin --->\n") );
	status = STATUS_SUCCESS;

//	KIRQL CurentIrql = KeGetCurrentIrql();
//	DBG_PRINTF( ( "CTVControl::Tvald_GHCI() CurentIrql = %d \n", CurentIrql) );
	
	DBG_PRINTF( ( "CTVControl::Tvald_GHCI() IoBuildDeviceIoControlRequest\n") );
	irp = IoBuildDeviceIoControlRequest(
				IOCTL_TVALD_GHCI,
				TvaldDeviceObject,
				pinputreg,
				sizeof(GHCI_INTERFACE),
				pinputreg,
				sizeof(GHCI_INTERFACE),
				FALSE,
				&event,
				&iostatus
			);
	if(!irp){
        DBG_PRINTF( ( "CTVControl::Tvald_GHCI()   IoBuildDeviceIoControlRequest Error!!\n") );
		iostatus.Status = STATUS_INSUFFICIENT_RESOURCES;
		iostatus.Information = 0;
		DBG_PRINTF( ( "CTVControl::Tvald_GHCI() RtlFreeUnicodeString\n") );
		RtlFreeUnicodeString( &UNameString );
//		return;
		return (FALSE);
	}

	DBG_PRINTF( ( "CTVControl::Tvald_GHCI() IoCallDriver\n") );
	status = IoCallDriver(TvaldDeviceObject, irp);

	if( status == STATUS_PENDING ){
		DBG_PRINTF( ( "CTVControl::Tvald_GHCI() KeWaitForSingleObject\n") );
		KeWaitForSingleObject(&event, Suspended, KernelMode, FALSE, NULL);
	}
	else if ( status != STATUS_SUCCESS )
		return (FALSE);

	pUlongTmpInput = (PULONG)pinputreg;
	pUlongTmpOutput = (PULONG)irp->AssociatedIrp.SystemBuffer;
	for(index = 0;	index < 6; index++){
		*pUlongTmpInput =  *pUlongTmpOutput;
		pUlongTmpInput++;
		pUlongTmpOutput++;
	}
	return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\tecra\ctvctrl.h ===
//**************************************************************************
//
//      Title   : CTVCtrl.h
//
//      Date    : 1998.06.29    1st making
//
//      Author  : Toshiba [PCS](PSY) Hideki Yagi
//
//      Copyright 1997-1998 Toshiba Corporation. All Rights Reserved.
//
// -------------------------------------------------------------------------
//
//      Change log :
//
//      Date       Revision                  Description
//   ------------ ---------- -----------------------------------------------
//    1998.06.29   000.0000   1st making.
//
//**************************************************************************
#define     TVCONTROL_LCD_BIT       0x0001
#define     TVCONTROL_CRT_BIT       0x0002
#define     TVCONTROL_TV_BIT        0x0004

#define     DISABLE_TV              0x0000
#define     ENABLE_TV               0x0001

// add by do '98-07-13 ( from "tvaldctl.h")
//
// Device driver open name
//
//#define TVALDDRVR_DEVICE_OPEN_NAME   "\\\\.\\TVALD"   
//#define TVALDDRVR_DEVICE_OPEN_NAME   "TVALD.SYS"   
#define TVALDDRVR_DEVICE_OPEN_NAME   "\\Device\\TVALD"   

//
// IOCTL Code ...
//
#define IOCTL_TVALD_INFO \
    (ULONG)CTL_CODE( FILE_DEVICE_UNKNOWN, 0xA10, METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TVALD_CANCEL_INFO \
    (ULONG)CTL_CODE( FILE_DEVICE_UNKNOWN, 0xA11, METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TVALD_GHCI \
    (ULONG)CTL_CODE( FILE_DEVICE_UNKNOWN, 0xA20, METHOD_BUFFERED, FILE_ANY_ACCESS )

//
// GHCI Method Interfaces
//
typedef struct _GHCI_INTERFACE {
	ULONG	GHCI_EAX;
	ULONG	GHCI_EBX;
	ULONG	GHCI_ECX;
	ULONG	GHCI_EDX;
	ULONG	GHCI_ESI;
	ULONG	GHCI_EDI;
} GHCI_INTERFACE, *PGHCI_INTERFACE;


//
// notification values
//
#define	HOTKEY_INFO_CHANGE		0x80

//
// hot key methods
//
#define HOTKEY_INFO_METHOD		'OFNI'
#define HOTKEY_GHCI_METHOD		'ICHG'
#define	HOTKEY_ENAB_METHOD		'BANE'

//
// ACPI.SYS control Method stract
//
typedef struct _ACPI_CTL_METHOD {
	union {
		UCHAR	MethodName[4];
		ULONG	MethodNameAsUlong;
	};
} ACPI_CTL_METHOD, *PACPI_CTL_METHOD;

// add end '98-07-13

typedef struct  tag_DisplayStatusStruc
{
    DWORD   SizeofStruc;
    DWORD   AvailableDisplay;
    DWORD   CurrentDisplay;
} DisplayStatusStruc;



class  CTVControl
{
public:
    CTVControl( void );
    ~CTVControl( void );

    BOOL    Initialize( void );
    BOOL    Uninitialize( void );
    BOOL    GetDisplayStatus( PVOID status );
    BOOL    SetDisplayStatus( PVOID status );
    BOOL    SetTVOutput( DWORD status );

private:
	GHCI_INTERFACE	inputreg;	// add by do '98-07-13
	BOOL			is_init_success;	// add by do '98-08-04
	UNICODE_STRING	UNameString;
	KEVENT			event;
	PDEVICE_OBJECT	TvaldDeviceObject;
//	void	Tvald_GHCI( PGHCI_INTERFACE pinputreg );
	BOOL	Tvald_GHCI( PGHCI_INTERFACE pinputreg );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\tecra\dvd1cmd.h ===
/*******************************************************************
 *
 *    DESCRIPTION: DVD-1 Command ID header file.
 *
 *    AUTHOR:	 J Bruce
 *
 *    HISTORY:     1/31/97 First release
 *
 *******************************************************************/

 #define ABORT			0x8120
 #define DIGEST			0x621
 #define DUMPDATA_VCD	0x322
 #define DUMPDATA_DVD	0x136
 #define FADE			0x223
 #define FLUSHBUFFER	0x8124
 #define FREEZE			0x125
 #define HIGHLIGHT      0x226
 #define HIGHLIGHT2     0x427
// #define MEMCOPY()      0x32C
 #define MEMCOPY        0x32C           // Modyfied by H.Yagi
 #define NEWPLAYMODE	0x28
 #define OSDCOPYDATA	0x350
 #define OSDCOPYREGION	0x651
 #define OSDADD_DELTOLIST 0x355
 #define OSDITEMLISTTOBITMAP 0x656
 #define OSDXORDATA		0x357
 #define OSDXORReEGION	0x658  
 #define PAUSE			0x12A
 #define PLAY			0x42B
 #define RESET			0x802D
 #define RESUME			0x12E
 #define SCAN			0x32F
 #define SCREENLOAD		0x330
 #define SELECTSTREAM	0x231
 #define SETFILL		0x532
 #define SETSTREAMS		0x233
 #define SINGLESTEP		0x134
 #define SLOWMOTION		0x235
 #define REVERSE		0x33B		 // by oka
 #define REVSINGLESTEP	0x33C		 // by oka
 #define MAGNIFY		0x329		 // by oka
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\tecra\depend.inc ===
#define TOSDVD_VERSION_STR "1.00.99.1004"
#define TOSDVD_VERSION 1,00,99,1004
#define TOSDVD_DRVNAME_STR "tosdvd02.sys"

#if 0
TARGETNAME=TOSDVD02
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\tecra\dramcfg.h ===
/******************************************************************
 *
 * ZiVA Configuration and Status Area
 * This auto-generated file was created Wed Mar 11 11:08:56 PST 1998
 *
 * Copyright C-Cube Microsystems 1997
 *
 ******************************************************************/
#define ADDR_COMMAND                                 0x40
#define ADDR_PARAMETER_1                             0x44
#define ADDR_PARAMETER_2                             0x48
#define ADDR_PARAMETER_3                             0x4c
#define ADDR_PARAMETER_4                             0x50
#define ADDR_PARAMETER_5                             0x54
#define ADDR_PARAMETER_6                             0x58
#define ADDR_STATUS_ADDRESS                          0x5c
#define ADDR_ROM_INFO                                0x60
#define ADDR_DRAM_INFO                               0x68
#define ADDR_UCODE_MEMORY                            0x6c
#define ADDR_VIDEO_MODE                              0x7c
#define ADDR_DISPLAY_ASPECT_RATIO                    0x80
#define ADDR_ASPECT_RATIO_MODE                       0x84
#define ADDR_PAN_SCAN_SOURCE                         0x88
#define ADDR_PAN_SCAN_HORIZONTAL_OFFSET              0x8c
#define ADDR_TOP_BORDER                              0x94
#define ADDR_BORDER_COLOR                            0x98
#define ADDR_BACKGROUND_COLOR                        0x9c
#define ADDR_OSD_EVEN_FIELD                          0xa0
#define ADDR_OSD_ODD_FIELD                           0xa4
#define ADDR_HOST_OPTIONS                            0xac       // 98.05.29 Yagi
#define ADDR_IC_TYPE                                 0xb0
#define ADDR_ERR_CONCEALMENT_LEVEL                   0xb4
#define ADDR_ERR_HORIZONTAL_SIZE                     0xb8
#define ADDR_ERR_VERTICAL_SIZE                       0xbc
#define ADDR_ERR_ASPECT_RATIO_INFORMATION            0xc0
#define ADDR_ERR_FRAME_RATE_CODE                     0xc4
#define ADDR_FORCE_CODED_ASPECT_RATIO                0xc8
#define ADDR_HLI_VERTICAL_OFFSET                     0xcc
#define ADDR_INTERNAL_CPU_CLOCK_CFG                  0xd0
#define ADDR_ERR_MPEG_VERSION                        0xd4
#define ADDR_AUDIO_CONFIG                            0xe0
#define ADDR_AUDIO_DAC_MODE                          0xe8
#define ADDR_AUDIO_CLOCK_SELECTION                   0xec
#define ADDR_IEC_958_DELAY                           0xf0
#define ADDR_AUDIO_ATTENUATION                       0xf4
#define ADDR_IEC_958_CHANNEL_STATUS_BITS             0xfc
#define ADDR_AC3_OUTPUT_MODE                         0x110
#define ADDR_AC3_OPERATIONAL_MODE                    0x114
#define ADDR_AC3_LOW_BOOST                           0x118
#define ADDR_AC3_HIGH_CUT                            0x11c
#define ADDR_AC3_PCM_SCALE_FACTOR                    0x120
#define ADDR_AC3_LFE_OUTPUT_ENABLE                   0x124
#define ADDR_AC3_VOICE_SELECT                        0x128
#define ADDR_AC3_L_LEVEL                             0x12c
#define ADDR_AC3_C_LEVEL                             0x130
#define ADDR_AC3_R_LEVEL                             0x134
#define ADDR_AC3_SL_LEVEL                            0x138
#define ADDR_AC3_SR_LEVEL                            0x13c
#define ADDR_AC3_CENTER_DELAY                        0x144
#define ADDR_AC3_SURROUND_DELAY                      0x148
#define ADDR_BITSTREAM_TYPE                          0x1a0
#define ADDR_BITSTREAM_SOURCE                        0x1a4
#define ADDR_SD_MODE                                 0x1a8
#define ADDR_CD_MODE                                 0x1ac
#define ADDR_AV_SYNC_MODE                            0x1b0
#define ADDR_VIDEO_PTS_SKIP_INTERVAL                 0x1b8
#define ADDR_VIDEO_PTS_REPEAT_INTERVAL               0x1bc
#define ADDR_AUTOPAUSE_ENABLE                        0x1d4
#define ADDR_VIDEO_ENV_CHANGE                        0x1e0
#define ADDR_MEMCOPY_XFER_BLOCKSIZE                  0x1e4
#define ADDR_IDLE_DELAY                              0x1f0
#define ADDR_VERTICAL_DISPLAYMODE                    0x1f4
#define ADDR_CDDA_OUTPUT_GUARDBAND                   0x1f8
#define ADDR_INT_MASK                                0x200
#define ADDR_AUTO_FLUSH_INTERVAL                     0x204
#define ADDR_RDY_S_THRESHOLD_LOW                     0x208
#define ADDR_MEMORY_MAP                              0x21c
#define ADDR_PCI_BUFFER_START                        0x220
#define ADDR_PCI_BUFFER_END                          0x224
#define ADDR_DSI_BUFFER_START                        0x228
#define ADDR_DSI_BUFFER_END                          0x22c
#define ADDR_OSD_BUFFER_START                        0x240
#define ADDR_OSD_BUFFER_END                          0x244
#define ADDR_OSD_BUFFER_IDLE_START                   0x248
#define ADDR_OSD_BUFFER_IDLE_END                     0x24c
#define ADDR_USER_DATA_BUFFER_START                  0x270
#define ADDR_USER_DATA_BUFFER_END                    0x274
#define ADDR_USER_DATA_READ                          0x278
#define ADDR_USER_DATA_WRITE                         0x27c
#define ADDR_DUMP_DATA_BUFFER_START                  0x280
#define ADDR_DUMP_DATA_BUFFER_END                    0x284
#define ADDR_SUB_PICTURE_PALETTE_START               0x288
#define ADDR_SUB_PICTURE_PALETTE_END                 0x28c
#define ADDR_PROC_STATE                              0x2a0
#define ADDR_MRC_ID                                  0x2a4
#define ADDR_MRC_STATUS                              0x2a8
#define ADDR_INT_STATUS                              0x2ac
#define ADDR_HLI_INT_SRC                             0x2b0
#define ADDR_BUFF_INT_SRC                            0x2b4
#define ADDR_UND_INT_SRC                             0x2b8
#define ADDR_PBT_INT_SRC                             0x2bc
#define ADDR_AOR_INT_SRC                             0x2bc
#define ADDR_AEE_INT_SRC                             0x2c0
#define ADDR_ERR_INT_SRC                             0x2c4
#define ADDR_VIDEO_EMPTINESS                         0x2c8
#define ADDR_AUDIO_EMPTINESS                         0x2cc
#define ADDR_CURR_PIC_DISPLAYED                      0x2d0
#define ADDR_NEXT_PIC_DISPLAYED                      0x2d4
#define ADDR_VIDEO_FIELD                             0x2d8
#define ADDR_OSD_VALID                               0x2e0
#define ADDR_NUM_DECODED                             0x2e4
#define ADDR_NUM_SKIPPED                             0x2e8
#define ADDR_NUM_REPEATED                            0x2ec
#define ADDR_MRC_PIC_PTS                             0x2f0
#define ADDR_MRC_PIC_STC                             0x2f4
#define ADDR_N_AUD_DECODED                           0x2f8
#define ADDR_NEXT_SECTOR_ADDR                        0x314
#define ADDR_N_SYS_ERRORS                            0x318
#define ADDR_N_VID_ERRORS                            0x31c
#define ADDR_N_AUD_ERRORS                            0x320
#define ADDR_DATE_TIME                               0x324
#define ADDR_VERSION                                 0x330
#define ADDR_EXTENDED_VERSION                        0x334
#define ADDR_PIC1_BUFFER_START                       0x340
#define ADDR_PIC1_PTS                                0x344
#define ADDR_PIC1_PAN_SCAN                           0x348
#define ADDR_PIC1_USER_DATA                          0x34c
#define ADDR_PIC1_TREF_PTYP_FLGS                     0x358
#define ADDR_PIC2_BUFFER_START                       0x360
#define ADDR_PIC2_PTS                                0x364
#define ADDR_PIC2_PAN_SCAN                           0x368
#define ADDR_PIC2_USER_DATA                          0x36c
#define ADDR_PIC2_TREF_PTYP_FLGS                     0x378
#define ADDR_PIC3_BUFFER_START                       0x380
#define ADDR_PIC3_PTS                                0x384
#define ADDR_PIC3_PAN_SCAN                           0x388
#define ADDR_PIC3_USER_DATA                          0x38c
#define ADDR_PIC3_TREF_PTYP_FLGS                     0x398
#define ADDR_STREAM_ID                               0x3a0
#define ADDR_PACKET_LEN                              0x3a4
#define ADDR_PES_HEADER                              0x3a8
#define ADDR_SUBPIC_EMPTINESS                        0x3ac
#define ADDR_H_SIZE                                  0x3b0
#define ADDR_V_SIZE                                  0x3b4
#define ADDR_APSECT_RATIO                            0x3b8
#define ADDR_FRAME_RATE                              0x3bc
#define ADDR_BIT_RATE                                0x3c0
#define ADDR_VBV_SIZE                                0x3c4
#define ADDR_SEQ_FLAGS                               0x3c8
#define ADDR_DISP_SIZE_H_V                           0x3cc
#define ADDR_TIME_CODE                               0x3d0
#define ADDR_GOP_FLAGS                               0x3d4
#define ADDR_TEMP_REF                                0x3d8
#define ADDR_PIC_TYPE                                0x3dc
#define ADDR_VBV_DELAY                               0x3e0
#define ADDR_PIC_HEADER                              0x3e4
#define ADDR_AUDIO_TYPE                              0x3f0
#define ADDR_AC3_ENGINE_VERSION                      0x3f4
#define ADDR_MPEG_AUDIO_HEADER1                      0x400
#define ADDR_AC3_FRAME_NUMBER                        0x400
#define ADDR_LPCM_AUDIO_EMPHASIS_FLAG                0x400
#define ADDR_MPEG_AUDIO_HEADER2                      0x404
#define ADDR_LPCM_AUDIO_MUTE_FLAG                    0x404
#define ADDR_AC3_BSI_IS_BEING_READ                   0x404
#define ADDR_LPCM_AUDIO_FRAME_NUMBER                 0x408
#define ADDR_AC3_BSI_VALID                           0x408
#define ADDR_LPCM_AUDIO_QUANTIZATION_WORD_LENGTH     0x40c
#define ADDR_AC3_BSI_FRAME                           0x40c
#define ADDR_LPCM_AUDIO_SAMPLING_FREQUENCY           0x410
#define ADDR_AC3_FSCOD_FRMSIZECOD                    0x410
#define ADDR_LPCM_AUDIO_NUMBER_OF_AUDIO_CHANNELS     0x414
#define ADDR_AC3_BSID_BSMOD                          0x414
#define ADDR_LPCM_AUDIO_DYNAMIC_RANGE_CONTROL        0x418
#define ADDR_AC3_ACMOD_CMIXLEV                       0x418
#define ADDR_VCD_SECTOR_HEADER                       0x41c
#define ADDR_AC3_SURMIXLEV_DSURMOD                   0x41c
#define ADDR_VCD_SECTOR_SUBHEADER                    0x420
#define ADDR_AC3_LFEON_DIALNORM                      0x420
#define ADDR_AC3_COMPR_LANGCOD                       0x424
#define ADDR_AC3_MIXLEV_ROOMTYP                      0x428
#define ADDR_AC3_DIALNORM2_COMPR2                    0x42c
#define ADDR_AC3_LANGCOD2_MIXLEV2                    0x430
#define ADDR_AC3_ROOMTYP2_COPYRIGHTB                 0x434
#define ADDR_AC3_ORIGBS_TIMECOD1                     0x438
#define ADDR_AC3_TIMECOD2_EBITS                      0x43c
#define ADDR_SE_STATUS                               0x444
#define ADDR_NEW_AUDIO_MODE                          0x460
#define ADDR_NEW_SUBPICTURE_PALETTE                  0x464
#define ADDR_NEW_AUDIO_CONFIG                        0x468
#define ADDR_VSYNC_HEARTBEAT                         0x46c
#define ADDR_ML_HEARTBEAT                            0x470
#define ADDR_SUBPICTURE_ENABLE                       0x474
#define ADDR_HIGHLIGHT_ENABLE                        0x478
#define ADDR_CURRENT_BUTTON                          0x47c
#define ADDR_ROM_END_POINTER                         0x4a0
#define ADDR_CURRENT_VOB_CELL_ID                     0x4a4
#define ADDR_PREV_VOBU_VIDEO_RLBN                    0x4a8
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\tecra\cxfer.cpp ===
/*
]NX
iNP2)@Sachiko Yasukawa
*/
#include "stdafx.h"

#include "includes.h"
#include "classlib.h"

#ifdef TEST
IMBoardListItem *pbuffers1[20];
IMBoardListItem *pbuffers2[20];
#endif

#define ISSETDMABUFFER (m_LinerAdd == NULL) ? FALSE : ((m_PhysAdd == NULL) ? FALSE : ((m_DMABufferSize == 0) ? FALSE : TRUE))
#define ISENDTRANSFERINIT (m_pStreamObject == NULL) ? FALSE : TRUE

BOOL CTransfer::Init( void )
{
	m_pStreamObject = NULL;
	m_DMABufferSize = 0;
	m_pTopEventList = NULL;
	m_pLastEventList = NULL;

	m_pTopQueuedMPEGBuffer = NULL;
	m_pLastQueuedMPEGBuffer = NULL;
	m_pNextTransferMPEGBuffer = NULL;
	m_TopPagePoint = 1;
	m_LastPagePoint = 1;

	//fobOp
	BufCount = 0;
	StreamCount = 0;
	return TRUE;
};

//fXgN^@obt@c
CTransfer::~CTransfer()
{
	CTransferStreamList *pDeleteStreamList;

	for( ;m_pStreamObject; ){
		pDeleteStreamList = m_pStreamObject;
		m_pStreamObject = (CTransferStreamList *)m_pStreamObject->GetNext();
		delete pDeleteStreamList;
		//fobOp
		StreamCount--;
	}
	ASSERT(StreamCount == 0);
//	DBG_PRINTF(("CLASSLIB:StreamCount = %d\n", StreamCount));
}

//CxgIuWFNgZbgB
BOOL CTransfer::SetSink(IMPEGBoardEvent *pEvent)
{
	ASSERT(pEvent);
	
	// CxgIuWFNgNext
	pEvent->SetNext( NULL );

	//B
	//CxgXg
	if(m_pTopEventList == NULL)
		m_pTopEventList = m_pLastEventList = (IMBoardListItem *)pEvent;//LXg
	else{
		m_pLastEventList->SetNext((IMBoardListItem *)pEvent);//LXg
		m_pLastEventList = (IMBoardListItem *)pEvent;//LXg
	}
	
	return TRUE;
}

//CxgIuWFNgBAdd by Nakamura
BOOL CTransfer::UnSetSink(IMPEGBoardEvent *pEvent)
{
	ASSERT(pEvent);
	//CxgXgB

	// CxgXgAG[
	if(m_pTopEventList == NULL || m_pLastEventList == NULL )
		return FALSE;

	// Po^
	if( m_pTopEventList == pEvent && m_pLastEventList == pEvent )
	{
		m_pTopEventList = m_pLastEventList = NULL;
		return TRUE;
	};

	// Qo^AIuWFNggp
	if( m_pTopEventList == pEvent && m_pLastEventList != pEvent )
	{
		m_pTopEventList = m_pTopEventList->GetNext();
		return TRUE;
	};

	// Qo^AQ~
	IMBoardListItem *pTmpEvent;
	for( pTmpEvent = m_pTopEventList; pTmpEvent != NULL; pTmpEvent = pTmpEvent->GetNext() )
	{
		// XgCxgIuWFNgH
		if( pTmpEvent->GetNext() == pEvent )
		{
			// IuWFNgA
			if( pTmpEvent->GetNext() == m_pLastEventList )
				m_pLastEventList = pTmpEvent;
			
			// Xg
			pTmpEvent->SetNext( pTmpEvent->GetNext()->GetNext() );

			return TRUE;
		};
	};

	DBG_PRINTF(("CLASSLIB: CALLED CTransfer::UnSetSinkError!!!\n"));
	DBG_BREAK();
	return FALSE;
}

//DMABufferB
BOOL CTransfer::SetDMABuffer(DWORD size, BYTE* LinerAdd, BYTE *PhysAdd)
{
	ASSERT(LinerAdd);
	ASSERT(PhysAdd);

/*	
	if(!ISENDTRANSFERINIT)
		return MBC_NOTINITIALIZE;
	
	m_LinerAdd = LinerAdd;
	m_PhysAdd = PhysAdd;
	m_DMABufferSize = size;
*/
	return TRUE;
}

//QueueB
BOOL CTransfer::EnQueue( IMPEGBuffer *pBuffer )
{
	ASSERT( pBuffer != NULL );

	pBuffer->SetNext( NULL );

	//]obt@
	if(m_pTopQueuedMPEGBuffer == NULL){
		m_pTopQueuedMPEGBuffer = m_pLastQueuedMPEGBuffer = m_pNextTransferMPEGBuffer = pBuffer;
		m_TopPagePoint = 1;
		m_LastPagePoint = 1;
//		DBG_PRINTF(("CLASSLIB: m_pTopQueuedTOPMPEGBuffer = 0x%X\n", (DWORD)m_pTopQueuedMPEGBuffer));
//		DBG_PRINTF(("CLASSLIB: m_pLastQueuedTOPMPEGBuffer = 0x%X\n", (DWORD)m_pLastQueuedMPEGBuffer));
//		DBG_PRINTF(("CLASSLIB: PageSize = %d\n", pBuffer->GetPageNum()));
	}
	else{
		m_pLastQueuedMPEGBuffer->SetNext(pBuffer);
		m_pLastQueuedMPEGBuffer = pBuffer;
		if( m_pNextTransferMPEGBuffer == NULL )
		{
			m_pNextTransferMPEGBuffer = m_pLastQueuedMPEGBuffer;
			m_LastPagePoint = 1;
		};
//		DBG_PRINTF(("CLASSLIB: m_pTopQueuedTOPMPEGBuffer = 0x%X\n", (DWORD)m_pTopQueuedMPEGBuffer));
//		DBG_PRINTF(("CLASSLIB: m_pLastQueuedTOPMPEGBuffer = 0x%X\n", (DWORD)m_pLastQueuedMPEGBuffer));
//		DBG_PRINTF(("CLASSLIB: PageSize = %d\n", pBuffer->GetPageNum()));
	}

//	DBG_PRINTF(("CLASSLIB: CALLED CTransfer::EnQueue\n"));
	
	if(!ISENDTRANSFERINIT){
		DBG_PRINTF(("CLASSLIB:CTRANSFER::ENQUEUE:NOT INTIALIZE CTRANSFER\n"));
		DBG_BREAK();
		return FALSE;
	}

	return TRUE;
}

//Queue]
BOOL CTransfer::DeQueue()
{
	DWORD PageNum;
	CBaseStream *pStream;
	CTransferStreamList *pStreamList;
	IHALStreamControl *pHALStream;
	DWORD pLinear, pPhys, Flag;
	int BufSize;

//	DBG_PRINTF(("CLASSLIB: CALLED CTransfer::DeQueue\n"));
	
	if(!ISENDTRANSFERINIT){
		DBG_PRINTF(("CLASSLIB:CTRANSFER::DEQUEUE:NOT INTIALIZE CTRANSFER\n"));
		DBG_BREAK();
		return FALSE;
	}

	//pStream = m_pStreamObject->GetBaseStrem();
	//DMAobt@
	if(ISSETDMABUFFER){
		
	}
	//DMAobt@g
	else{
		for(pStreamList = m_pStreamObject; pStreamList; pStreamList = (CTransferStreamList *)pStreamList->GetNext()){
			pStream = pStreamList->GetBaseStream();
			ASSERT(pStream);
			pHALStream = pStream->GetHALStreamControl();
			ASSERT(pHALStream);
			
			DWORD QueueNum;
			HALRESULT st;
			DWORD Count;
			
			//Xgobt@f[^]
			if((st = pHALStream->GetAvailableQueue( &QueueNum )) != HAL_SUCCESS){
				_RPT0(_CRT_WARN, "CAN'T GETAVAILABLEQUEUE\n");
				DBG_PRINTF(("CLASSLIB:CTransfer::DeQueue:CAN'T GETAVAILABLEQUEUE\n"));
				DBG_BREAK();
				return FALSE;
			}
			for(Count = 0; Count < QueueNum ; Count++){
				IMPEGBuffer *pBuffer = NULL;
				if( GetNextTransferPoint( &pBuffer, &PageNum ) == FALSE )
					return TRUE;

				if(!pBuffer->GetPagePointer(PageNum, &pLinear, &pPhys)){
					return FALSE;
				}
				//CClassLibBufferTCY
				BufSize = pBuffer->GetPageSize(PageNum);
				//CClassLibBufferflag
				if(PageNum == 1)
					Flag = pBuffer->GetBufferFlag();
				else
					Flag = 0; //R[fBO
				//Vobt@NX
				CClassLibBuffer *pBuf = m_Mem.Alloc(pBuffer, pStream, PageNum, BufSize, pPhys, pLinear, Flag);//f[^
				
				if(!pBuf){
					_RPTF0(_CRT_WARN, "CAN'T New");
					DBG_PRINTF(("CLASSLIB:CTRANSFER::ENQUEUE:CAN'T NEW\n"));
					DBG_BREAK();
					return FALSE;
				}

		//fobOp
		BufCount++;

//				DBG_PRINTF(("CLASSLIB: Dequeue: Senddata(%d) pBuffer =  0x%X  IMPEGBuff=0x%x\n", BufCount, (DWORD)pBuf,pBuffer ));
				if((st = pHALStream->SendData(pBuf)) != HAL_SUCCESS){
					_RPT0(_CRT_WARN, "CAN'T SENDDATA TO HAL\n");
					DBG_PRINTF(("CLASSLIB:CTransfer::DeQueue:CAN'T SENDDATA TO HAL\n"));
					DBG_BREAK();
					return FALSE;
				}

			}
		}
	}
	return TRUE;
}
//TransferIuWFNgXg[B
BOOL CTransfer::AddStreamObject(IBaseStream *INewStreamObject)
{
	//CBaseStream *pBSt1, *pBSt2;
	CTransferStreamList *pNewTransferStreamList, *pStreamList;

	ASSERT(INewStreamObject);
	
//378742    PNPBOOT: tosdvd03 leaks 1 page of memory on unload.
//	pNewTransferStreamList = new CTransferStreamList((CBaseStream *)INewStreamObject);
	m_pNewTransferStreamList.Init( (CBaseStream *)INewStreamObject );
	pNewTransferStreamList = &m_pNewTransferStreamList;
//	
	if(!pNewTransferStreamList){
		DBG_PRINTF(("CLASSLIB:CTRANSFER::AddStreamObject:CAN'T NEW\n"));
		DBG_BREAK();
		return FALSE;
	}
	
	//fobOp
	StreamCount++;

	//Xg[B
	if(m_pStreamObject == NULL){
		m_pStreamObject = pNewTransferStreamList;
		//pBSt1 = m_pStreamObject->GetBaseStream();
		//pHALStream = m_pBSt1->GetHALStreamControl();
		m_pIHAL = m_pStreamObject->GetBaseStream()->GetClassLibHAL();
		m_EndOfTransferEvent.SetEventType(ClassLibEvent_SendData);
		m_EndOfTransferEvent.SetTransfer(this);
		m_pIHAL->SetSinkClassLib((IMPEGBoardEvent *)/*(CClassLibEvent *)*/&m_EndOfTransferEvent);
	}
	//VXg[
	else{
		//pBSt1 = pNewTransferStreamList;
		for(pStreamList = m_pStreamObject; pStreamList->GetNext() != NULL; pStreamList = (CTransferStreamList *)pStreamList->GetNext());
		pStreamList->SetNext((IMBoardListItem *)pNewTransferStreamList);
	}
	
	return TRUE;
}
//TransferIuWFNgXg[B
BOOL CTransfer::ReleaseStreamObject(IBaseStream *IStreamObject)
{
	CTransferStreamList *pStreamList, *pNextStreamList;
	CBaseStream *pBaseStream;
	
	ASSERT(IStreamObject);

	//Xg[G[
	if(m_pStreamObject == NULL){
		_RPTF0(_CRT_WARN, "CTransfer:THERE IS NO STREAM WHICH SHOULD BE RELEASED\n");
		DBG_PRINTF(("CLASSLIB:CTRANSFER::ReleaseStreamObject:THERE IS NO STREAM WHICH SHOULD BE RELEASED\n"));
		DBG_BREAK();
		return FALSE;
	}
	else{
		for(pStreamList = m_pStreamObject; ; pStreamList = (CTransferStreamList *)pStreamList->GetNext()){
			if((pNextStreamList = (CTransferStreamList *)pStreamList->GetNext()) == NULL){
				_RPTF0(_CRT_WARN, "CTransfer:THERE IS SUCH A STREAM WHICH SHOULD BE RELEASED\n");
				DBG_PRINTF(("CLASSLIB:CTRANSFER::ReleaseStreamObject:THERE IS SUCH A STREAM WHICH SHOULD BE RELEASED\n"));
				DBG_BREAK();
				return FALSE;
			}
			if((pBaseStream = (CBaseStream *)pNextStreamList->GetBaseStream()) == (CBaseStream *)IStreamObject){
				break;
			}
			ASSERT(pBaseStream);
		}
		pStreamList->SetNext(pNextStreamList->GetNext());
//378742    PNPBOOT: tosdvd03 leaks 1 page of memory on unload.
//		delete pNextStreamList;
//
		//fobOp
		StreamCount--;
	}
	return TRUE;
}


//QueuetbVB
void CTransfer::Flush()
{
	CTransferStreamList *pStreamList;
	CBaseStream *pBaseStream;
	IMPEGBoardEvent *pEvent;

	DBG_PRINTF(("CLASSLIB:Before flash BufCount = %d\n", BufCount));

	m_Mem.Flush();
	BufCount=0;
	
	for(pStreamList = m_pStreamObject; pStreamList; pStreamList  = (CTransferStreamList *)pStreamList->GetNext()){
		pBaseStream = pStreamList->GetBaseStream();
		DWORD PageNum;
		ASSERT(pBaseStream);

		IMPEGBuffer *pBuffer = NULL;
		BOOL NeedAdvice = FALSE;

		// StreamQueueobt@A]}[NB
		while( TRUE )
		{
			if( GetNextTransferPoint( &pBuffer, &PageNum ) == FALSE )
				break;
		}

		while( HasQueuedBuffer() == TRUE )
		{
			NeedAdvice = FreeTopTransferPoint(&pBuffer);
			if( NeedAdvice == TRUE )
			{
				for(pEvent = (IMPEGBoardEvent *)m_pTopEventList; pEvent != NULL;pEvent = (IMPEGBoardEvent *)((IMBoardListItem *)pEvent)->GetNext())
				{
					if((/*(CClassLibEvent *)*/pEvent)->GetEventType() == ClassLibEvent_SendData){
						//MPEGBuffer
						//WrappergIm
						pEvent->Advice(pBuffer);
					}
				}
			};
		}
	}
	DBG_PRINTF(("CLASSLIB:After flush BufCount = %d\n", BufCount));
	ASSERT( BufCount == 0 );
}

//f[^]I
BOOL CTransfer::EndOfTransfer(CClassLibBuffer *pBuffer)
{
	IMPEGBoardEvent *pEvent;
	CBaseStream *pStream;
	CTransferStreamList *pStreamList;
		
//	DBG_PRINTF(("CLASSLIB: EndOfTransfer(%d) pBuffer =  0x%X\n", BufCount, (DWORD)pBuffer));
//	DBG_PRINTF(("CLASSLIB: pBuffer->GetIMPEGBuffer() = 0x%X\n", (DWORD)pBuffer->GetIMPEGBuffer()));

	ASSERT(pBuffer);
	pStream = pBuffer->GetStream();
	ASSERT(pStream);
	
	IMPEGBuffer *pFree = NULL;
	if( FreeTopTransferPoint(&pFree) == TRUE )
	{
//		DBG_PRINTF(("CLASSLIB: Free IMPEGBuffer() = 0x%X\n", (DWORD)pFree ));
		ASSERT( pFree == pBuffer->GetIMPEGBuffer()  );
		//Wrappernobt@y[Wobt@[J
		for(pEvent = (IMPEGBoardEvent *)m_pTopEventList; pEvent != NULL;pEvent = (IMPEGBoardEvent *)((IMBoardListItem *)pEvent)->GetNext()){
			if(pEvent->GetEventType() == ClassLibEvent_SendData){
				//WrappergIm
//				DBG_PRINTF(("CLASSLIB: EndOfTransfer Advice Buffer =  0x%X\n", pBuffer->GetIMPEGBuffer() ));
				pEvent->Advice(pBuffer->GetIMPEGBuffer());
			}
		}
	}
	//XgCClassLibBuffer
	m_Mem.Free(pBuffer);
	//fobOp
	BufCount--;
	ASSERT(BufCount>=0);

	//STOPHALSendData
	for(pStreamList = m_pStreamObject; pStreamList; pStreamList = (CTransferStreamList *)pStreamList->GetNext()){
			pStream = pStreamList->GetBaseStream();
			ASSERT(pStream);
			if(pStream->GetState() == Stop)
				return TRUE;
	}

	if(DeQueue() == FALSE){
		DBG_PRINTF(("CLASSLIB:CTRANSFER::EndOfTransfer:CAN'T DEQUEUE\n"));
		DBG_BREAK();
		return FALSE;
	}
	
	return TRUE;
}


BOOL	CTransfer::HasQueuedBuffer( void )
{
	if( m_pTopQueuedMPEGBuffer == NULL )
		return FALSE;
	return TRUE;
};


BOOL	CTransfer::GetNextTransferPoint( IMPEGBuffer **Point, DWORD *Page )
{
	if( m_pNextTransferMPEGBuffer == NULL )
	{
		*Point = NULL;
		*Page = 0;
		return FALSE;
	};

	*Point = m_pNextTransferMPEGBuffer;
	*Page = m_LastPagePoint;

	if( m_pNextTransferMPEGBuffer->GetPageNum() == m_LastPagePoint )
	{
		m_pNextTransferMPEGBuffer = (IMPEGBuffer *)m_pNextTransferMPEGBuffer->GetNext();
		m_LastPagePoint = 1;
		return TRUE;
	};

	m_LastPagePoint ++;
	return TRUE;
};

BOOL	CTransfer::FreeTopTransferPoint( IMPEGBuffer **Free )
{
	ASSERT( m_pTopQueuedMPEGBuffer != NULL );

	if( m_pTopQueuedMPEGBuffer == NULL
		|| ( m_pTopQueuedMPEGBuffer == m_pNextTransferMPEGBuffer && m_LastPagePoint == m_TopPagePoint ) )
	{
		*Free = NULL;
		return FALSE;
	};

	if( m_TopPagePoint == m_pTopQueuedMPEGBuffer->GetPageNum() )
	{
		*Free = m_pTopQueuedMPEGBuffer;
		m_pTopQueuedMPEGBuffer = (IMPEGBuffer *)m_pTopQueuedMPEGBuffer->GetNext();
		m_TopPagePoint = 1;
		return TRUE;		// Need Advice
	};

	*Free = NULL;
	m_TopPagePoint ++;

	return FALSE;		// Not Need Advice
	
};


//HAL
void CClassLibEvent::Advice(PVOID pBuffer)
{
	ASSERT(m_pTransfer);
	m_pTransfer->EndOfTransfer((CClassLibBuffer *)pBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\tecra\dvdinit.h ===
//**************************************************************************
//
//      Title   : DVDinit.h
//
//      Date    : 1997.11.28    1st making
//
//      Author  : Toshiba [PCS](PSY) Hideki Yagi
//
//      Copyright 1997 Toshiba Corporation. All Rights Reserved.
//
// -------------------------------------------------------------------------
//
//      Change log :
//
//      Date       Revision                  Description
//   ------------ ---------- -----------------------------------------------
//    1997.11.28   000.0000   1st making.
//
//**************************************************************************
#define     DMASIZE                 (2 * 1024)
#define     VIDEO_MAX_FULL_RATE     (1 * 10000)
#define     AUDIO_MAX_FULL_RATE     (1 * 10000)
#define     SUBPIC_MAX_FULL_RATE    (1 * 10000)

// 1998.9.24  K.Ishizaki
#ifndef	TVALD
#define    NUMBER_OF_REGISTRY_PARAMETERS   6
#else
#define    NUMBER_OF_REGISTRY_PARAMETERS   5
#endif	TVALD
// End

#ifndef		REARRANGEMENT
#define		WDM_BUFFER_MAX		100			//max packet partition
#endif		REARRANGEMENT

//***************** SRB_EXTENSION **********************
typedef struct  _SRB_EXTENSION
{
#ifndef		REARRANGEMENT
    CWDMBuffer      m_wdmbuff[WDM_BUFFER_MAX];		//packet partition buffer
#else
    CWDMBuffer      m_wdmbuff;
#endif		REARRANGEMENT

    // Next SRB pointer for FF/FR Queueing
    PHW_STREAM_REQUEST_BLOCK    pNextSRB;
    
} SRB_EXTENSION, *PSRB_EXTENSION;



//***************** STREAMEX **********************
typedef struct  _STREAMEX
{
    DWORD       EventCount;
    KSSTATE     state;

} STREAMEX, *PSTREAMEX;



//***************** STREAMTYPES **********************
typedef enum    tagStreamType
{
    strmVideo = 0,
    strmAudio,
    strmSubpicture,
//--- 98.06.01 S.Watanabe
//    strmNTSCVideo,
//--- End.
    strmYUVVideo,
    strmCCOut,
//--- 98.05.21 S.Watanabe
	strmSS,
//--- End.
    STREAMNUM
} STREAMTYPES;

/******* for Display Device(TV) type 98.12.23 H.Yagi *******/
enum
{
//--- 99.01.13 S.Watanabe
//	DisplayDevice_Wide = 0,
//	DisplayDevice_Normal
	DisplayDevice_VGA = 0,
	DisplayDevice_NormalTV,
	DisplayDevice_WideTV
//--- End.
};


//////////////////////////////////////////////////////////////////////////
//
//    for only under construction
//
//    MS will provide these difinitions in official release WDM DDK
//
//////////////////////////////////////////////////////////////////////////

typedef struct _MYTIME {
    KSEVENT_TIME_INTERVAL   tim;
    LONGLONG                LastTime;
} MYTIME, *PMYTIME;

//
extern "C" NTSTATUS        DriverEntry( IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING registryPath );
BOOL    GetPCIConfigSpace( IN PHW_STREAM_REQUEST_BLOCK pSrb );
BOOL    SetInitialize( IN PHW_STREAM_REQUEST_BLOCK pSrb );
BOOL    HwInitialize( IN PHW_STREAM_REQUEST_BLOCK pSrb );
BOOL    InitialSetting( IN PHW_STREAM_REQUEST_BLOCK pSrb );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\tecra\dvdinit.cpp ===
//***************************************************************************
//
//	FileName:
//		$Workfile: DVDINIT.CPP $
//
//	Author:
//		TOSHIBA [PCS](PSY) Satoshi Watanabe
//		Copyright (c) 1998 TOSHIBA CORPORATION
//
//	Description:
//		1998.05.27 dvdwdm.cpp 
//
//***************************************************************************
// $Header: /DVD Drivers/ZIVA2PC.WDM/DVDINIT.CPP 29    99/07/14 10:31 K-ogi $
// $Modtime: 99/07/07 13:08 $
// $Nokeywords:$
//***************************************************************************
#include    "includes.h"

#include    "hal.h"
#include    "wdmkserv.h"
#include    "mpevent.h"
#include    "classlib.h"
#include    "ctime.h"
#include    "schdat.h"
#include    "ccque.h"
#include    "ctvctrl.h"
#include	"hlight.h"
#include    "hwdevex.h"
#include    "wdmbuff.h"
#include    "dvdinit.h"
#include    "dvdwdm.h"
#include	"wrapdef.h"
#include    "ssif.h"

//--- 98.05.27 S.Watanabe
BYTE PaletteY[256] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
	0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
	0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
	0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
	0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
	0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
	0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
	0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
	0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfd, 0xfd,
};
BYTE PaletteCb[256] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
	0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x21,
	0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2d, 0x2e, 0x2f, 0x30, 0x31,
	0x32, 0x33, 0x34, 0x35, 0x36, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x43,
	0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52,
	0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x63,
	0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72,
	0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x84,
	0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93,
	0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3,
	0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2,
	0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc3,
	0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2,
	0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2,
	0xe2, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0,
	0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfd, 0xfd,
};
BYTE PaletteCr[256] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
	0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x21,
	0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2d, 0x2e, 0x2f, 0x30, 0x31,
	0x32, 0x33, 0x34, 0x35, 0x36, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x43,
	0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52,
	0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x63,
	0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72,
	0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x84,
	0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93,
	0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3,
	0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2,
	0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc3,
	0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2,
	0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2,
	0xe2, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0,
	0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfd, 0xfd,
};
//--- End.

NTSTATUS GetConfigValue(
	IN PWSTR ValueName,
	IN ULONG ValueType,
	IN PVOID ValueData,
	IN ULONG ValueLength,
	IN PVOID Context,
	IN PVOID EntryContext
    );

////////////////////////////////////////////////////////////////////////////
//
//  Public Functions
//
////////////////////////////////////////////////////////////////////////////
extern "C" NTSTATUS DriverEntry( IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath )
{
//    DBG_BREAK();

    HW_INITIALIZATION_DATA  HwInitData;

	// 1998.9.24  K.Ishizaki
	RTL_QUERY_REGISTRY_TABLE	queryRegistryTable[NUMBER_OF_REGISTRY_PARAMETERS + 1];
	PWSTR	parameterPath = NULL;
	ULONG	lengthOfPath = 0;
	UNICODE_STRING	parameters;
	ULONG	zero = 0;
	ULONG	breakOnEntry = 0;

	RtlInitUnicodeString(&parameters, L"\\Parameters");
	lengthOfPath = RegistryPath->Length + parameters.Length + sizeof(WCHAR);
	parameterPath = (PWSTR)ExAllocatePool(NonPagedPool, lengthOfPath);
	if (parameterPath) {
		// Construct a path string.
		RtlZeroMemory(parameterPath, lengthOfPath);
		RtlCopyMemory(parameterPath, RegistryPath->Buffer, RegistryPath->Length);
		RtlCopyMemory((BYTE *)parameterPath + RegistryPath->Length,
			parameters.Buffer, parameters.Length);

		// Query registry values.
		RtlZeroMemory(queryRegistryTable, sizeof(queryRegistryTable));
		queryRegistryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
		queryRegistryTable[0].Name = L"EnablePrintf";
		queryRegistryTable[0].EntryContext = &Dbg_Printf_Enable;
		queryRegistryTable[0].DefaultType = REG_DWORD;
		queryRegistryTable[0].DefaultData = &zero;
		queryRegistryTable[0].DefaultLength = sizeof(ULONG);
		queryRegistryTable[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
		queryRegistryTable[1].Name = L"EnableBreak";
		queryRegistryTable[1].EntryContext = &Dbg_Break_Enable;
		queryRegistryTable[1].DefaultType = REG_DWORD;
		queryRegistryTable[1].DefaultData = &zero;
		queryRegistryTable[1].DefaultLength = sizeof(ULONG);
		queryRegistryTable[2].Flags = RTL_QUERY_REGISTRY_DIRECT;
		queryRegistryTable[2].Name = L"DebugLevel";
		queryRegistryTable[2].EntryContext = &Dbg_Print_Level;
		queryRegistryTable[2].DefaultType = REG_DWORD;
		queryRegistryTable[2].DefaultData = &zero;
		queryRegistryTable[2].DefaultLength = sizeof(ULONG);
		queryRegistryTable[3].Flags = RTL_QUERY_REGISTRY_DIRECT;
		queryRegistryTable[3].Name = L"DebugFlags";
		queryRegistryTable[3].EntryContext = &Dbg_Print_Flags;
		queryRegistryTable[3].DefaultType = REG_DWORD;
		queryRegistryTable[3].DefaultData = &zero;
		queryRegistryTable[3].DefaultLength = sizeof(ULONG);
		queryRegistryTable[4].Flags = RTL_QUERY_REGISTRY_DIRECT;
		queryRegistryTable[4].Name = L"BreakOnEntry";
		queryRegistryTable[4].EntryContext = &breakOnEntry;
		queryRegistryTable[4].DefaultType = REG_DWORD;
		queryRegistryTable[4].DefaultData = &zero;
		queryRegistryTable[4].DefaultLength = sizeof(ULONG);
#ifndef	TVALD
		queryRegistryTable[5].Flags = RTL_QUERY_REGISTRY_DIRECT;
		queryRegistryTable[5].Name = L"EnableTvald";
		queryRegistryTable[5].EntryContext = &Dbg_Tvald;
		queryRegistryTable[5].DefaultType = REG_DWORD;
		queryRegistryTable[5].DefaultData = &zero;
		queryRegistryTable[5].DefaultLength = sizeof(ULONG);
#endif	TVALD
		RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE, parameterPath,
			queryRegistryTable, NULL, NULL);

		ExFreePool(parameterPath);
	}
	if (breakOnEntry) {
		__asm { int 3 }
	}
	// END

    DBG_PRINTF( ("DVDWDM:TOSDVD02 DriverEntry\n\r") );

    RtlZeroMemory( &HwInitData, sizeof(HW_INITIALIZATION_DATA) );

    HwInitData.HwInitializationDataSize = sizeof( HwInitData );
    HwInitData.HwInterrupt = (PHW_INTERRUPT)HwInterrupt;
    HwInitData.HwReceivePacket = AdapterReceivePacket;
    HwInitData.HwCancelPacket = AdapterCancelPacket;
    HwInitData.HwRequestTimeoutHandler = AdapterTimeoutPacket;
    HwInitData.DeviceExtensionSize = sizeof( HW_DEVICE_EXTENSION );
    HwInitData.PerRequestExtensionSize = sizeof( SRB_EXTENSION );
    HwInitData.PerStreamExtensionSize = sizeof( STREAMEX );
    HwInitData.FilterInstanceExtensionSize = 0;
    HwInitData.BusMasterDMA = TRUE;
    HwInitData.Dma24BitAddresses = FALSE;
    HwInitData.BufferAlignment = 4;
    HwInitData.TurnOffSynchronization = FALSE;
    HwInitData.DmaBufferSize = DMASIZE;

    return( StreamClassRegisterMinidriver( (PVOID)DriverObject,
                                        (PVOID)RegistryPath,
                                        &HwInitData ) );
}

// Quiet compiler on bogus code: should use placement operator new instead
#pragma warning(push)
#pragma warning(disable:4701)

// Set vtbl into HW_DEVICE_EXTENSION.
BOOL    InitialHwDevExt( PHW_DEVICE_EXTENSION pHwDevExt )
{
	CMPEGBoardHAL       temp1;
	CMPEGBoard          temp2;
	CMPEGBoardState     temp3;
	CDVDStream          temp4;
	CTransfer           temp5;
	CWDMKernelService   temp6;
	CDataXferEvent      temp7;
	CTickTime           pttime;
#ifdef		REARRANGEMENT
	CScheduleData       pschd;
#endif		REARRANGEMENT
	CCQueue             temp8;
	CUserDataEvent      temp9;
	CVSyncEvent         tempa;
    CTVControl          tempb;
	HlightControl		tempc;

#ifndef		REARRANGEMENT
	CScheduleData    *pschd = new CScheduleData;
#endif		REARRANGEMENT

    pHwDevExt->m_InitComplete = FALSE;

	RtlCopyMemory( &(pHwDevExt->mphal), &temp1, sizeof(CMPEGBoardHAL) );
	RtlCopyMemory( &(pHwDevExt->mpboard), &temp2, sizeof(CMPEGBoard) );
	RtlCopyMemory( &(pHwDevExt->mpbstate), &temp3, sizeof(CMPEGBoardState) );
	RtlCopyMemory( &(pHwDevExt->dvdstrm), &temp4, sizeof(CDVDStream) );
	RtlCopyMemory( &(pHwDevExt->transfer), &temp5, sizeof(CTransfer) );
	RtlCopyMemory( &(pHwDevExt->kserv), &temp6, sizeof(CWDMKernelService) );
	RtlCopyMemory( &(pHwDevExt->senddata), &temp7, sizeof(CDataXferEvent) );
	RtlCopyMemory( &(pHwDevExt->ticktime), &pttime, sizeof(CTickTime) );
#ifndef		REARRANGEMENT
	RtlCopyMemory( &(pHwDevExt->scheduler), pschd, sizeof(CScheduleData) );
#else
	RtlCopyMemory( &(pHwDevExt->scheduler), &pschd, sizeof(CScheduleData) );
#endif		REARRANGEMENT
	RtlCopyMemory( &(pHwDevExt->ccque), &temp8, sizeof(CCQueue) );
	RtlCopyMemory( &(pHwDevExt->userdata), &temp9, sizeof(CUserDataEvent) );
	RtlCopyMemory( &(pHwDevExt->vsync), &tempa, sizeof(CVSyncEvent) );
    RtlCopyMemory( &(pHwDevExt->tvctrl), &tempb, sizeof(CTVControl) );
    RtlCopyMemory( &(pHwDevExt->m_HlightControl), &tempc, sizeof(HlightControl) );

#ifndef		REARRANGEMENT
	delete pschd;
#endif		REARRANGEMENT

	return TRUE;
}

#pragma warning(pop)

BOOL GetPCIConfigSpace( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
    PPORT_CONFIGURATION_INFORMATION  ConfigInfo = pSrb->CommandData.ConfigInfo;
    PHW_DEVICE_EXTENSION    pHwDevExt = (PHW_DEVICE_EXTENSION)ConfigInfo->HwDeviceExtension;

    DBG_PRINTF( ("DVDWDM:HeDevExt=%08x\n\r", pHwDevExt ) );
    if( !StreamClassReadWriteConfig( pSrb->HwDeviceExtension,
                TRUE, (PVOID)&pHwDevExt->PciConfigSpace, 0, 64 ) ){     // Read
        DBG_PRINTF( ( "DVDWDM:No PCI ConfigArea!!\n\r") );
        DBG_BREAK();
        return( FALSE );
    }else{
        ULONG   i, j;
        for( i=0; i<64; ){
            DBG_PRINTF( ( "DVDWDM:PCI Data: ") );
            for( j=0;j<8 && i<64; j++,i++ ){
                DBG_PRINTF( ( "0x%02x ", (UCHAR)*(((PUCHAR)&pHwDevExt->PciConfigSpace)+i)) );
            }
            DBG_PRINTF( ( "\n\r") );
        }
    }

	DWORD Id = *(DWORD *)(&pHwDevExt->PciConfigSpace);
	pHwDevExt->kserv.InitConfig( Id );
    return( TRUE );

}


BOOL SetInitialize( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
    PPORT_CONFIGURATION_INFORMATION ConfigInfo = pSrb->CommandData.ConfigInfo;
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)(ConfigInfo->HwDeviceExtension);
//    NTSTATUS            Status;
    BOOL                bTVct=FALSE;
    
    if( ConfigInfo->NumberOfAccessRanges<1 ){
        DBG_PRINTF( ( "DVDWDM:Illegal Config info\n\r") );
        DBG_BREAK();
        return( FALSE );
    }

    // Debug Dump ConfigInfo
    DBG_PRINTF( ( "DVDWDM: Port = 0x%04x\n\r", ConfigInfo->AccessRanges[0].RangeStart.LowPart) );
    DBG_PRINTF( ( "DVDWDM: Length = 0x%04x\n\r", ConfigInfo->AccessRanges[0].RangeLength) );
    DBG_PRINTF( ( "DVDWDM: IRQ = 0x%04x\n\r", ConfigInfo->BusInterruptLevel) );
    DBG_PRINTF( ( "DVDWDM: Vector = 0x%04x\n\r", ConfigInfo->BusInterruptVector) );
    DBG_PRINTF( ( "DVDWDM: DMA = 0x%04x\n\r", ConfigInfo->DmaChannel) );

    // Initialize the size of stream descriptor information.
    ConfigInfo->StreamDescriptorSize =
        STREAMNUM * sizeof(HW_STREAM_INFORMATION) + sizeof(HW_STREAM_HEADER);

    pHwDevExt->ioBaseLocal = (PUCHAR)ConfigInfo->AccessRanges[0].RangeStart.LowPart;
    pHwDevExt->Irq = ConfigInfo->BusInterruptLevel;

    DBG_PRINTF( ("DVDWDM:I/O-Base = %08x\n\r", pHwDevExt->ioBaseLocal ) );
    DBG_PRINTF( ("DVDWDM:Irq = %08x\n\r", pHwDevExt->Irq ) );

/********* 98.12.22 H.Yagi
    // Read Machine information from Registry.
    UNICODE_STRING      RegPath;
    UNICODE_STRING      IdString;

    ANSI_STRING         AnsiRegPath;
    ANSI_STRING         AnsiIdString;

//    BYTE    IdByte[100];
    
    RTL_QUERY_REGISTRY_TABLE    Table[2];

//    DBG_BREAK();
    RtlInitUnicodeString( &RegPath, L"\\Registry\\Machine\\Enum\\Root\\*PNP0C01\\0000");
    RtlInitAnsiString( &AnsiRegPath, "\\Registry\\Machine\\Enum\\Root\\*PNP0C01\\0000");

    IdString.Length = 0;
    IdString.MaximumLength = 200;
    IdString.Buffer = (PWSTR)ExAllocatePool( PagedPool, IdString.MaximumLength);
    if( IdString.Buffer==NULL ){
        DBG_PRINTF( ("DVDINIT:Mem Alloc Error\n\r") );
        DBG_BREAK();
    }
    
    AnsiIdString.Length = 0;
    AnsiIdString.MaximumLength = 100;
    AnsiIdString.Buffer = (PCHAR)ExAllocatePool( PagedPool, IdString.MaximumLength);
    if( AnsiIdString.Buffer==NULL ){
        DBG_PRINTF( ("DVDINIT:Mem Alloc Error\n\r") );
        DBG_BREAK();
    }

    RtlZeroMemory( Table, sizeof(Table) );
    Table[0].Flags         = RTL_QUERY_REGISTRY_DIRECT |
                             RTL_QUERY_REGISTRY_REQUIRED;
    Table[0].Name          = L"BIOSVersion";
    Table[0].EntryContext  = &IdString;
    Table[0].DefaultType   = REG_SZ;
    Table[0].DefaultData   = &RegPath;
    Table[0].DefaultLength = 0;
    
    Status = RtlQueryRegistryValues( RTL_REGISTRY_ABSOLUTE,
                                    RegPath.Buffer,
                                    Table,
                                    NULL,
                                    NULL );

    DBG_PRINTF( ("DVDINIT:Machine ID Check Status = 0x%08x\n\r", Status ) );
    if( NT_SUCCESS( Status ) ){
        RtlUnicodeStringToAnsiString( &AnsiIdString, &IdString, FALSE );
//        DBG_PRINTF( ("DVDINIT:Machine ID(Unicode) = %s\n\r", IdString.Buffer ) );
        DBG_PRINTF( ("DVDINIT:Machine ID(Ansi)    = %s\n\r", AnsiIdString.Buffer ) );
    }else{
        // check NT5 Registry
        RtlInitUnicodeString( &RegPath, L"\\Registry\\Machine\\HARDWARE\\DESCRIPTION\\System");

        RtlZeroMemory( Table, sizeof(Table) );
        Table[0].Flags         = RTL_QUERY_REGISTRY_DIRECT |
                                 RTL_QUERY_REGISTRY_REQUIRED;
        Table[0].Name          = L"SystemBiosVersion";
        Table[0].EntryContext  = &IdString;
        Table[0].DefaultType   = REG_MULTI_SZ;
        Table[0].DefaultData   = &RegPath;
        Table[0].DefaultLength = 0;
    
        Status = RtlQueryRegistryValues( RTL_REGISTRY_ABSOLUTE,
                                        RegPath.Buffer,
                                        Table,
                                        NULL,
                                        NULL );
        DBG_PRINTF( ("DVDINIT:Binary Check Status = 0x%08x\n\r", Status ) );
        if( NT_SUCCESS( Status ) ){
            RtlUnicodeStringToAnsiString( &AnsiIdString, &IdString, FALSE );
//            DBG_PRINTF( ("DVDINIT:Machine ID(Unicode) = %s\n\r", IdString.Buffer ) );
            DBG_PRINTF( ("DVDINIT:Machine ID(Ansi)    = %s\n\r", AnsiIdString.Buffer ) );
        }else{
            DBG_PRINTF( ("DVDINIT:Machine ID Read Error!\n\r") );
            DBG_BREAK();
        }
    }
***********/
    // Not checking Registry BIOSVersion, so we deal with Portege7000 as Tecra8000.
    // Pass the string 'TECRA' to KernelService object.
    ANSI_STRING         AnsiIdString;
    AnsiIdString.Buffer="TECRA\0";

    //
    if( !( pHwDevExt->mpboard.Init() ) ||
        !( pHwDevExt->mpbstate.Init() ) ||
        !( pHwDevExt->dvdstrm.Init() ) ||
        !( pHwDevExt->transfer.Init() ) ){
            DBG_PRINTF( ("DVDWDM:Initialize objects error!\n\r") );
//            DBG_BREAK();
            return( FALSE );
    }
        
    pHwDevExt->mphal.Init( WrapperType_WDM );       // WrapperType
    pHwDevExt->kserv.Init( (DWORD)(pHwDevExt->ioBaseLocal), pHwDevExt, AnsiIdString.Buffer );
    
    // Setup kernel service object to hal object.
    pHwDevExt->mphal.SetKernelService( &(pHwDevExt->kserv ) );

    // Setup CMPEGBoard object.
    pHwDevExt->mpboard.SetHALObjectInterface( &(pHwDevExt->mphal) );
    pHwDevExt->mpboard.AddStreamObjectInterface( &(pHwDevExt->dvdstrm) );

    // Setup CBaseStream objects.
    pHwDevExt->dvdstrm.SetStateObject( &(pHwDevExt->mpbstate) );
    pHwDevExt->dvdstrm.SetTransferObject( &(pHwDevExt->transfer) );

    // Register data xfer event object to transfer object.
    pHwDevExt->transfer.SetSink( &(pHwDevExt->senddata) );

    // Register vsync event object to transfer object.
    pHwDevExt->vsync.Init( pHwDevExt );
//    pHwDevExt->mphal.SetSinkWrapper( &(pHwDevExt->vsync) );	// commented out this line,
								// SetsinkWrapper and UnsetSinkWrapper
								// dynamically, cause of MS bug?

	// stream State init
	pHwDevExt->StreamState = StreamState_Off;

	// Clear CppFlagCount   99.01.07 H.Yagi
	pHwDevExt->CppFlagCount = 0;

    // Ask and Set DMA buffer address & size to HAL.
//    DBG_BREAK();
    STREAM_PHYSICAL_ADDRESS adr;
    DWORD   size, flag;
    DWORD   PAdr, LAdr;
    ULONG   Length;
    pHwDevExt->mphal.QueryDMABufferSize( &size, &flag );
    if( size>DMASIZE ){
        DBG_PRINTF( ("DVDWDM:Not enough DMA memory\n\r") );
        DBG_BREAK();
        return( FALSE);
    }
    if( size!=0 ){
        LAdr = (DWORD)StreamClassGetDmaBuffer( pHwDevExt );
        adr = StreamClassGetPhysicalAddress( pHwDevExt, NULL, (PVOID)LAdr, DmaBuffer, &Length );
        PAdr = (DWORD)adr.LowPart;
        pHwDevExt->mphal.SetDMABuffer( LAdr, PAdr );
    }

    bTVct = pHwDevExt->tvctrl.Initialize( );
    pHwDevExt->m_bTVct = bTVct;
	pHwDevExt->m_HlightControl.Init( pHwDevExt );

/************** 98.12.22 H.Yagi
    if( IdString.Buffer!=NULL){
        ExFreePool( IdString.Buffer );
    }
    if( AnsiIdString.Buffer!=NULL){
        ExFreePool( AnsiIdString.Buffer );
    }
*********************/

    pHwDevExt->m_InitComplete = TRUE;

    return( TRUE );
}


BOOL HwInitialize( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
	HALTYPE   HType;		// add by H.Yagi  1999.04.21
	
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)(pSrb->HwDeviceExtension);

    // No procedure in this routine, because I will set PowerOn to ZiVA
    // when Video stream is opend.

    // Now I Check Vendr-ID & Device-ID using kserv method.
    // Vender-ID
    pHwDevExt->kserv.GetPCIConfigData( 0x00, &(pHwDevExt->VenderID) );

    // Device-ID
    pHwDevExt->kserv.GetPCIConfigData( 0x02, &(pHwDevExt->DeviceID) );

    // Sub Vender-ID
    pHwDevExt->kserv.GetPCIConfigData( 0x2C, &(pHwDevExt->SubVenderID) );

    // Sub Device-ID
    pHwDevExt->kserv.GetPCIConfigData( 0x2E, &(pHwDevExt->SubDeviceID) );
    
    DBG_PRINTF( ("DVDWDM:Vender     ID = 0x%04x\n\r", pHwDevExt->VenderID ) );
    DBG_PRINTF( ("DVDWDM:Sub-Vender ID = 0x%04x\n\r", pHwDevExt->SubVenderID ) );
    DBG_PRINTF( ("DVDWDM:Device     ID = 0x%04x\n\r", pHwDevExt->DeviceID ) );
    DBG_PRINTF( ("DVDWDM:Sub-Device ID = 0x%04x\n\r", pHwDevExt->SubDeviceID ) );

    pHwDevExt->m_PCID = PC_TECRA750;

    if( (pHwDevExt->VenderID==0x1179) && (pHwDevExt->DeviceID==0x0407) ){
        switch( pHwDevExt->SubDeviceID ){
            case 0x0001:
                pHwDevExt->m_PCID = PC_TECRA750;
                break;
            case 0x0003:
                pHwDevExt->m_PCID = PC_TECRA780;
                break;
        }
    }else if( (pHwDevExt->VenderID==0x123f) && (pHwDevExt->DeviceID==0x8888) ){
        switch( pHwDevExt->SubDeviceID ){
            case 0x0001:
                pHwDevExt->m_PCID = PC_TECRA8000;
                break;
            case 0x0002:
                pHwDevExt->m_PCID = PC_PORTEGE7000;
                break;
            default:
                pHwDevExt->m_PCID = PC_PORTEGE7000;        // PC_TECRA8000 is also OK.
                break;
        }
    }        

    // check HAL Type & driver itself.
    pHwDevExt->mphal.GetHALType( &HType );
    DBG_PRINTF( ("DVDWDM: HALTYPE = %d\n\r", HType ) );
    // TECRA750/780 == HalType_ZIVA
    if( pHwDevExt->m_PCID==PC_TECRA750 || pHwDevExt->m_PCID==PC_TECRA780 ){
    	    DBG_PRINTF( ("DVDWDM: PC is TECRA750/780\n\r" ) );
            if( HType!=HalType_ZIVA ){
            	return( FALSE );
            }
    }
    // TECRA8000/Portege7000 == HalType_ZIVAPC
    if( pHwDevExt->m_PCID==PC_PORTEGE7000 || pHwDevExt->m_PCID==PC_TECRA8000 ){
    	    DBG_PRINTF( ("DVDWDM: PC is TECRA8000/Portege70000\n\r" ) );
            if( HType!=HalType_ZIVAPC ){
            	return( FALSE );
            }
    }
    
    // This setting is temporary.
    // Note that this informations must be read from registry!!
    // But there is no way to get registry information from minidriver.
    // So, Now I set the default value directry.
    pHwDevExt->m_AC3LowBoost = 0x80;
    pHwDevExt->m_AC3HighCut = 0x80;
    pHwDevExt->m_AC3OperateMode = 0x00;

    if( !InitialSetting( pSrb ) ){          // Initial setting except
        return( FALSE );                    // H/W default value.
    }

//// Check TVALD.sys is available or not( TECRA8000 or PORTEGE7000 only ).
//// If tvald.sys is not available, not start TOSDVD.sys.  99.03.01
#ifndef	TVALD
	if(Dbg_Tvald == 0)
	{
	    if( (pHwDevExt->m_PCID==PC_TECRA8000) || (pHwDevExt->m_PCID==PC_PORTEGE7000) )
		{
    		if( pHwDevExt->m_bTVct==FALSE ){
    			return( FALSE );
	    	}
		}
    }
#endif
    	
    return( TRUE );
}

//--- 98.05.27 S.Watanabe
NTSTATUS GetConfigValue(
	IN PWSTR ValueName,
	IN ULONG ValueType,
	IN PVOID ValueData,
	IN ULONG ValueLength,
	IN PVOID Context,
	IN PVOID EntryContext
	)
{
	NTSTATUS ntStatus = STATUS_SUCCESS;

	DBG_PRINTF(( "Type 0x%x, Length 0x%x\n\r", ValueType, ValueLength ));

	switch( ValueType ) {
		case REG_DWORD:
			*(PVOID*)EntryContext = *(PVOID*)ValueData;
			break;

		case REG_BINARY:
			RtlCopyMemory( EntryContext, ValueData, ValueLength );
			break;

		default:
			ntStatus = STATUS_INVALID_PARAMETER;
	}
	return ntStatus;
}
//--- End.

BOOL InitialSetting( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)(pSrb->HwDeviceExtension);
    
    DWORD   AProp;
    DWORD   dProp1, dProp2, dProp3;

//--- 99.01.13 S.Watanabe
//    // Display Device type
//    // Currently I will set it directly, but I will read this setting
//    // from registry and user will be able to change this setting in the 
//    // near future.  98.12.23 H.Yagi
//    pHwDevExt->m_DisplayDevice = DisplayDevice_Wide;     // LCD output take priority 
//--- End.

    // AC-3 Dynamic Range control
    AProp = pHwDevExt->m_AC3LowBoost;
    if( !pHwDevExt->dvdstrm.SetAudioProperty( AudioProperty_AC3DRangeLowBoost, &AProp ) ){
        DBG_PRINTF( ("DVDWDM:AC3 Low Boost Error\n\r") );
        DBG_BREAK();
        return( FALSE );
    }

    AProp = pHwDevExt->m_AC3HighCut;
    if( !pHwDevExt->dvdstrm.SetAudioProperty( AudioProperty_AC3DRangeHighCut, &AProp ) ){
        DBG_PRINTF( ("DVDWDM:AC3 High Cut Error\n\r") );
        DBG_BREAK();
        return( FALSE );
    }
    
    // AC-3 Operational mode
    AProp = pHwDevExt->m_AC3OperateMode;
    if( !pHwDevExt->dvdstrm.SetAudioProperty( AudioProperty_AC3OperateMode, &AProp ) ){
        DBG_PRINTF( ("DVDWDM:AC3 Operate Mode Error\n\r") );
        DBG_BREAK();
        return( FALSE );
    }

//--- 98.05.27 S.Watanabe

	Digital_Palette dp;

	NTSTATUS status;

//--- 99.01.13 S.Watanabe
//	RTL_QUERY_REGISTRY_TABLE Table[6];
	RTL_QUERY_REGISTRY_TABLE Table[7];
//--- End.

	DWORD TVOut = 0;			// 99.02.03 H.Yagi
	DWORD AudioOut = 0;
//--- 99.01.13 S.Watanabe
	DWORD VOutDev = SSIF_DISPMODE_VGA;
//--- End.

	DWORD defaultTVOut = 0;			// 99.02.03 H.Yagi
	DWORD defaultAudioOut = 0;
//--- 99.01.13 S.Watanabe
	DWORD defaultVOutDev = SSIF_DISPMODE_VGA;
//--- End.

	RtlZeroMemory( Table, sizeof(Table) );

	Table[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
	Table[0].Name = L"AnalogVideoOut";
	Table[0].EntryContext = &TVOut;
	Table[0].DefaultType = REG_DWORD;
	Table[0].DefaultData = &defaultTVOut;
	Table[0].DefaultLength = sizeof(DWORD);

	Table[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
	Table[1].Name = L"DigitalAudioOut";
	Table[1].EntryContext = &AudioOut;
	Table[1].DefaultType = REG_DWORD;
	Table[1].DefaultData = &defaultAudioOut;
	Table[1].DefaultLength = sizeof(DWORD);

// DefaultType = REG_BINARY AFlags = RTL_QUERY_REGISTRY_DIRECT os
// GetConfigValue R[obN[`of[^Rs[s
	Table[2].QueryRoutine = GetConfigValue;
	Table[2].Flags = 0;
	Table[2].Name = L"PaletteY";
	Table[2].EntryContext = PaletteY;
	Table[2].DefaultType = REG_BINARY;
	Table[2].DefaultData = PaletteY;
	Table[2].DefaultLength = sizeof(PaletteY);

	Table[3].QueryRoutine = GetConfigValue;
	Table[3].Flags = 0;
	Table[3].Name = L"PaletteCb";
	Table[3].EntryContext = PaletteCb;
	Table[3].DefaultType = REG_BINARY;
	Table[3].DefaultData = PaletteCb;
	Table[3].DefaultLength = sizeof(PaletteCb);

	Table[4].QueryRoutine = GetConfigValue;
	Table[4].Flags = 0;
	Table[4].Name = L"PaletteCr";
	Table[4].EntryContext = PaletteCr;
	Table[4].DefaultType = REG_BINARY;
	Table[4].DefaultData = PaletteCr;
	Table[4].DefaultLength = sizeof(PaletteCr);

//--- 99.01.13 S.Watanabe
	Table[5].QueryRoutine = GetConfigValue;
	Table[5].Flags = 0;
	Table[5].Name = L"PriorityDisplayMode";
	Table[5].EntryContext = &VOutDev;
	Table[5].DefaultType = REG_DWORD;
	Table[5].DefaultData = &defaultVOutDev;
	Table[5].DefaultLength = sizeof(VOutDev);
//--- End.

	// Table[6]  0AI[

	status = RtlQueryRegistryValues(
		RTL_REGISTRY_SERVICES,
		REGPATH_FOR_WDM,
		Table,
		NULL,
		NULL
	);

	DBG_PRINTF(( "status : 0x%x\n\r", status ));
	DBG_PRINTF(( "TVOut : %d, AudioOut : %d\n\r", TVOut, AudioOut ));

	if( TVOut == 0 )
		dProp1 = OutputSource_VGA;
	else
		dProp1 = OutputSource_DVD;
	if( !pHwDevExt->dvdstrm.SetVideoProperty( VideoProperty_OutputSource, &dProp1 ) ) {
		DBG_PRINTF( ("DVDWDM:Set VideoProperty_OutputSource Error\n\r") );
		DBG_BREAK();
		return( FALSE );
	}
    pHwDevExt->m_OutputSource = dProp1;
    
	if( AudioOut == 2 )
		dProp1 = AudioDigitalOut_On;
	else if( AudioOut == 1 )
		dProp1 = AudioDigitalOut_On;
	else
		dProp1 = AudioDigitalOut_Off;
	if( !pHwDevExt->dvdstrm.SetAudioProperty( AudioProperty_DigitalOut, &dProp1 ) ) {
		DBG_PRINTF( ("DVDWDM:Set AudioProperty_DigitalOut Error\n\r") );
		DBG_BREAK();
		return( FALSE );
	}
    pHwDevExt->m_AudioDigitalOut = dProp1;
    
	if( AudioOut == 2 ) {
		dProp1 = AudioOut_Decoded;
		if( !pHwDevExt->dvdstrm.SetAudioProperty( AudioProperty_AudioOut, &dProp1 ) ) {
			DBG_PRINTF( ("DVDWDM:Set AudioProperty_AudioOut Error\n\r") );
			DBG_BREAK();
			return( FALSE );
		}
	}
	else if( AudioOut == 1 ) {
		dProp1 = AudioOut_Encoded;
		if( !pHwDevExt->dvdstrm.SetAudioProperty( AudioProperty_AudioOut, &dProp1 ) ) {
			DBG_PRINTF( ("DVDWDM:Set AudioProperty_AudioOut Error\n\r") );
			DBG_BREAK();
			return( FALSE );
		}
	}
    pHwDevExt->m_AudioEncode = dProp1;

	dp.Select = Video_Palette_Y;
	dp.pPalette = PaletteY;
	if( !pHwDevExt->dvdstrm.SetVideoProperty( VideoProperty_DigitalPalette, &dp ) ) {
		DBG_PRINTF( ("DVDWDM:Set VideoProperty_DigitalPalette(Y) Error\n\r") );
		DBG_BREAK();
		return( FALSE );
	}

	dp.Select = Video_Palette_Cb;
	dp.pPalette = PaletteCb;
	if( !pHwDevExt->dvdstrm.SetVideoProperty( VideoProperty_DigitalPalette, &dp ) ) {
		DBG_PRINTF( ("DVDWDM:Set VideoProperty_DigitalPalette(Cb) Error\n\r") );
		DBG_BREAK();
		return( FALSE );
	}

	dp.Select = Video_Palette_Cr;
	dp.pPalette = PaletteCr;
	if( !pHwDevExt->dvdstrm.SetVideoProperty( VideoProperty_DigitalPalette, &dp ) ) {
		DBG_PRINTF( ("DVDWDM:Set VideoProperty_DigitalPalette(Cr) Error\n\r") );
		DBG_BREAK();
		return( FALSE );
	}

//--- End.

//--- 99.01.13 S.Watanabe
	if( VOutDev == SSIF_DISPMODE_43TV )
		pHwDevExt->m_DisplayDevice = DisplayDevice_NormalTV;
	else if( VOutDev == SSIF_DISPMODE_169TV )
		pHwDevExt->m_DisplayDevice = DisplayDevice_WideTV;
	else
		pHwDevExt->m_DisplayDevice = DisplayDevice_VGA;
//--- End.

    /////////////////////////////////////////////
//--- 98.05.27 S.Watanabe
//    dProp1 = OutputSource_DVD;
//--- End.
    dProp2 = CompositeOut_On;
    dProp3 = SVideoOut_On;

//--- 98.05.27 S.Watanabe
//    if( !pHwDevExt->dvdstrm.SetVideoProperty( VideoProperty_OutputSource, &dProp1 ) ){
//        DBG_PRINTF( ("DVDWDM:Set Video output Error\n\r") );
//        DBG_BREAK();
//        return( FALSE );
//    }
//--- End.
    if( !pHwDevExt->dvdstrm.SetVideoProperty( VideoProperty_CompositeOut, &dProp2 ) ){
        DBG_PRINTF( ("DVDWDM:Set Composite Video output Error\n\r") );
        DBG_BREAK();
        return( FALSE );
    }
    pHwDevExt->m_CompositeOut = dProp2;
    
    if( !pHwDevExt->dvdstrm.SetVideoProperty( VideoProperty_SVideoOut, &dProp3 ) ){
        DBG_PRINTF( ("DVDWDM:Set S-Video output Error\n\r") );
        DBG_BREAK();
        return( FALSE );
    }
    pHwDevExt->m_SVideoOut = dProp3;
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\tecra\hal.h ===
//***************************************************************************
//
//	FileName:
//		$Workfile: hal.h $
//
//	Author:
//		TOSHIBA [PCS](PSY) Seiichi Nakamura
//		Copyright (c) 1997 TOSHIBA CORPORATION
//
//	Description:
//
//***************************************************************************
// $Header: /DVD Drivers/Sources/ZiVAHAL/hal.h 4     98/04/20 7:45p Hero $
// $Modtime: 98/04/20 5:25p $
// $Nokeywords:$
//***************************************************************************

#ifndef _HAL_H_
#define _HAL_H_

#include "ioif.h"
#include "zivachip.h"
#include "timeout.h"
#include "adv.h"
#include "mixhal.h"
// by oka
#include "userdata.h"
#include "zivabrd.h"

#endif	//  _HAL_H_
//***************************************************************************
//	End of 
//***************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\tecra\dvdwdm.h ===
//**************************************************************************
//
//      Title   : DVDWdm.h
//
//      Date    : 1997.11.28    1st making
//
//      Author  : Toshiba [PCS](PSY) Hideki Yagi
//
//      Copyright 1997 Toshiba Corporation. All Rights Reserved.
//
// -------------------------------------------------------------------------
//
//      Change log :
//
//      Date       Revision                  Description
//   ------------ ---------- -----------------------------------------------
//    1997.11.28   000.0000   1st making.
//
//**************************************************************************

extern "C" VOID STREAMAPI  AdapterReceivePacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
extern "C" VOID STREAMAPI  AdapterCancelPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
extern "C" VOID STREAMAPI  AdapterTimeoutPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );

extern "C" BOOLEAN STREAMAPI   HwInterrupt( IN PHW_DEVICE_EXTENSION pHwDevExt );

extern "C" VOID STREAMAPI  VideoReceiveDataPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
extern "C" VOID STREAMAPI  VideoReceiveCtrlPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
extern "C" VOID STREAMAPI  AudioReceiveDataPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
extern "C" VOID STREAMAPI  AudioReceiveCtrlPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
extern "C" VOID STREAMAPI  SubpicReceiveDataPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
extern "C" VOID STREAMAPI  SubpicReceiveCtrlPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
extern "C" VOID STREAMAPI  NtscReceiveDataPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
extern "C" VOID STREAMAPI  NtscReceiveCtrlPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
extern "C" VOID STREAMAPI  VpeReceiveDataPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
extern "C" VOID STREAMAPI  VpeReceiveCtrlPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
extern "C" VOID STREAMAPI  CcReceiveDataPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
extern "C" VOID STREAMAPI  CcReceiveCtrlPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
extern "C" VOID STREAMAPI  SSReceiveDataPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
extern "C" VOID STREAMAPI  SSReceiveCtrlPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );


NTSTATUS    STREAMAPI   AudioEvent( IN  PHW_EVENT_DESCRIPTOR pEvent );
VOID        STREAMAPI   StreamClockRtn( IN PHW_TIME_CONTEXT TimeContext );

/// Low Priority Routine.
VOID    LowAdapterReceivePacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    LowAdapterCancelPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    LowAdapterTimeoutPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    LowVideoReceiveDataPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    LowVideoReceiveCtrlPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    LowAudioReceiveDataPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    LowAudioReceiveCtrlPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    LowSubpicReceiveDataPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    LowSubpicReceiveCtrlPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    LowNtscReceiveDataPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    LowNtscReceiveCtrlPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    LowVpeReceiveDataPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    LowVpeReceiveCtrlPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    LowCcReceiveDataPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    LowCcReceiveCtrlPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    LowSSReceiveDataPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    LowSSReceiveCtrlPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb );


/// StreamAPI event
NTSTATUS    STREAMAPI   AudioEvent( PHW_EVENT_DESCRIPTOR pEvent );
NTSTATUS    STREAMAPI   CycEvent( PHW_EVENT_DESCRIPTOR pEvent );

/// private functions
void    ErrorStreamNotification( PHW_STREAM_REQUEST_BLOCK pSrb, NTSTATUS );
BOOL    GetStreamInfo( IN PHW_STREAM_REQUEST_BLOCK pSrb );
BOOL    OpenStream( IN PHW_STREAM_REQUEST_BLOCK pSrb );
BOOL    CloseStream( IN PHW_STREAM_REQUEST_BLOCK pSrb );
NTSTATUS    DataIntersection( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    VideoQueryAccept( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    AudioQueryAccept( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    GetVpeProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    SetVpeProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    GetVpeProperty2( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    SetVpeProperty2( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    GetVideoProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    SetVideoProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    GetAudioProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    SetAudioProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    GetSubpicProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    SetSubpicProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    GetNtscProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    SetNtscProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    GetVpeProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    SetVpeProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    GetCCProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    SetCCProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb );
//VOID    ProcessVideoFormat( PKSDATAFORMAT pfmt, PHW_DEVICE_EXTENSION pHwDevExt );
VOID    ProcessVideoFormat( PHW_STREAM_REQUEST_BLOCK pSrb, PKSDATAFORMAT pfmt, PHW_DEVICE_EXTENSION pHwDevExt );
VOID    ProcessAudioFormat( PKSDATAFORMAT pfmt, PHW_DEVICE_EXTENSION pHwDevExt );
VOID    GetCppProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb, LONG strm );
VOID    SetCppProperty( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    SetAudioID( IN PHW_DEVICE_EXTENSION pHwDevExt, PKSSTREAM_HEADER pStruc );
VOID    SetSubpicID( IN PHW_DEVICE_EXTENSION pHwDevExt, PKSSTREAM_HEADER pStruc );
DWORD   GetStreamID( void *pBuff );
VOID    GetVideoRateChange( PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    SetVideoRateChange( PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    GetAudioRateChange( PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    SetAudioRateChange( PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    GetSubpicRateChange( PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    SetSubpicRateChange( PHW_STREAM_REQUEST_BLOCK pSrb );
VOID    SetRateChange( PHW_DEVICE_EXTENSION pHwDevExt, LONG PrevRate );
VOID    SetVideoRateDefault( PHW_DEVICE_EXTENSION pHwDevExt );
VOID    SetAudioRateDefault( PHW_DEVICE_EXTENSION pHwDevExt );
VOID    SetSubpicRateDefault( PHW_DEVICE_EXTENSION pHwDevExt );
ULONGLONG   ConvertPTStoStrm( ULONG pts );
ULONG   ConvertStrmtoPTS( ULONGLONG strm );
VOID    USCC_Discontinuity( PHW_DEVICE_EXTENSION pHwDevExt );

BOOL    ToshibaNotePC( PHW_STREAM_REQUEST_BLOCK pSrb );
void    OpenTVControl( PHW_STREAM_REQUEST_BLOCK pSrb, OsdDataStruc dOsd );
void    CloseTVControl( PHW_STREAM_REQUEST_BLOCK pSrb );
BOOL    VGADVDTVControl( PHW_STREAM_REQUEST_BLOCK pSrb, DWORD stat, OsdDataStruc dOsd );
BOOL    MacroVisionTVControl( PHW_STREAM_REQUEST_BLOCK pSrb, DWORD stat, OsdDataStruc dOsd );

void    CallAtDeviceNextDeviceNotify( PHW_STREAM_REQUEST_BLOCK pSrb, NTSTATUS stat );
void    CallAtDeviceCompleteNotify( PHW_STREAM_REQUEST_BLOCK pSrb, NTSTATUS stat );
void    CallAtStreamNextDataNotify( PHW_STREAM_REQUEST_BLOCK pSrb, NTSTATUS stat );
void    CallAtStreamNextCtrlNotify( PHW_STREAM_REQUEST_BLOCK pSrb, NTSTATUS stat );
void    CallAtStreamCompleteNotify( PHW_STREAM_REQUEST_BLOCK pSrb, NTSTATUS stat );
//void    CallAtStreamSignalMultipleNotify( PHW_DEVICE_EXTENSION pHwDevExt );
void    CallAtStreamSignalMultipleNotify( PHW_STREAM_REQUEST_BLOCK pSrb );
void    DeviceNextDeviceNotify( PHW_STREAM_REQUEST_BLOCK pSrb );
void    DeviceCompleteNotify( PHW_STREAM_REQUEST_BLOCK pSrb );
void    StreamNextDataNotify( PHW_STREAM_REQUEST_BLOCK pSrb );
void    StreamNextCtrlNotify( PHW_STREAM_REQUEST_BLOCK pSrb );
void    StreamCompleteNotify( PHW_STREAM_REQUEST_BLOCK pSrb );
void    StreamSignalMultipleNotify( PHW_DEVICE_EXTENSION pHwDevExt );

void    LowTimerCppReset( PHW_STREAM_REQUEST_BLOCK pSrb );

void    DumpPTSValue( PHW_STREAM_REQUEST_BLOCK pSrb );

#ifndef	REARRANGEMENT
void	FlushQueue( PHW_DEVICE_EXTENSION pHwDevExt);
#endif	REARRANGEMENT

// define
#define IsEqualGUID2(guid1, guid2)  (!memcmp((guid1), (guid2), sizeof(GUID)))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\dvd\mini\tecra\dvdwdm.cpp ===
//**************************************************************************
//
//      Title   : DVDWdm.cpp
//
//      Date    : 1997.11.28    1st making
//
//      Author  : Toshiba [PCS](PSY) Hideki Yagi
//
//      Copyright 1997-1998 Toshiba Corporation. All Rights Reserved.
//
// -------------------------------------------------------------------------
//
//      Change log :
//
//      Date       Revision                  Description
//   ------------ ---------- -----------------------------------------------
//    1997.11.28   000.0000   1st making.
//
//**************************************************************************
// K.Ishizaki
#define     DBG_CTRL
// End
#include    "includes.h"

#include    "hal.h"
#include    "wdmkserv.h"
#include    "mpevent.h"
#include    "classlib.h"
#include    "ctime.h"
#include    "schdat.h"
#include    "ccque.h"
#include    "ctvctrl.h"
#include	"hlight.h"
#include    "hwdevex.h"
#include    "wdmbuff.h"
#include    "dvdinit.h"
#include    "dvdwdm.h"
#include    "wrapdef.h"

//--- 98.06.01 S.Watanabe
#include    <mmsystem.h>
//--- End.

#include    "ssif.h"
#include    "strmid.h"

//--- 98.06.01 S.Watanabe
//#include    <mmsystem.h>
//--- End.

//
// Pin name GUIDs - hopefully some day these will be added to ksmedia.h
//
#define STATIC_PINNAME_DVD_VIDEOIN \
   0x33AD5F43, 0xF1BC, 0x11D1, 0x94, 0xA5, 0x00, 0x00, 0xF8, 0x05, 0x34, 0x84

#define STATIC_PINNAME_DVD_VPEOUT \
   0x33AD5F44, 0xF1BC, 0x11D1, 0x94, 0xA5, 0x00, 0x00, 0xF8, 0x05, 0x34, 0x84

#define STATIC_PINNAME_DVD_AUDIOIN \
   0x33AD5F45, 0xF1BC, 0x11D1, 0x94, 0xA5, 0x00, 0x00, 0xF8, 0x05, 0x34, 0x84

#define STATIC_PINNAME_DVD_CCOUT \
   0x33AD5F46, 0xF1BC, 0x11D1, 0x94, 0xA5, 0x00, 0x00, 0xF8, 0x05, 0x34, 0x84

#define STATIC_PINNAME_DVD_SUBPICIN \
   0x33AD5F47, 0xF1BC, 0x11D1, 0x94, 0xA5, 0x00, 0x00, 0xF8, 0x05, 0x34, 0x84

#define STATIC_PINNAME_DVD_NTSCOUT \
   0x33AD5F48, 0xF1BC, 0x11D1, 0x94, 0xA5, 0x00, 0x00, 0xF8, 0x05, 0x34, 0x84


GUID g_PINNAME_DVD_VIDEOIN = {STATIC_PINNAME_DVD_VIDEOIN};
GUID g_PINNAME_DVD_VPEOUT  = {STATIC_PINNAME_DVD_VPEOUT};
GUID g_PINNAME_DVD_CCOUT = {STATIC_PINNAME_DVD_CCOUT};
GUID g_PINNAME_DVD_AUDIOIN = {STATIC_PINNAME_DVD_AUDIOIN};
GUID g_PINNAME_DVD_SUBPICIN = {STATIC_PINNAME_DVD_SUBPICIN};
GUID g_PINNAME_DVD_NTSCOUT = {STATIC_PINNAME_DVD_NTSCOUT};


//#define LOWSENDDATA

BOOL    InitialHwDevExt( PHW_DEVICE_EXTENSION pHwDevExt );

//--- 98.06.02 S.Watanabe
BOOL SetCppFlag( PHW_DEVICE_EXTENSION pHwDevExt, BOOL NeedNotify );
//--- End.

//--- 98.06.01 S.Watanabe
#ifdef DBG
char * DebugLLConvtoStr( ULONGLONG val, int base );
#endif
//--- End.

//--- 98.09.07 S.Watanabe
VOID TimeoutCancelSrb(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID LowTimeoutCancelSrb(IN PHW_STREAM_REQUEST_BLOCK pSrb);
//--- End.

/**** Test OSD ***/
#include    "erase.h"

////// for only under constructions, MS will provide it in official release.
KSPIN_MEDIUM VPMedium[] = {
	STATIC_KSMEDIUMSETID_VPBus,
	0,
	0
};

BOOL WriteDataChangeHwStreamState( IN PHW_DEVICE_EXTENSION pHwDevExt )
{
	DWORD dProp;

	switch( pHwDevExt->StreamState )
	{
		case StreamState_Off:
			DBG_PRINTF((" Stream State is Off?????\r\n" ));
			DBG_BREAK();
			return FALSE;		// Stream

		case StreamState_Stop:
			if( pHwDevExt->dvdstrm.GetState() != Stop )
			{

#ifndef		REARRANGEMENT
//				FlushQueue(pHwDevExt);
#endif		REARRANGEMENT

				if( pHwDevExt->dvdstrm.Stop() == FALSE )
				{
					DBG_PRINTF(("HwStreamChange Error..... LINE=%d\r\n", __LINE__ ));
					DBG_BREAK();
					return FALSE;
				};
			};
			DBG_BREAK();
			return FALSE;		// Stream

		case StreamState_Pause:
			if( pHwDevExt->dvdstrm.GetState() != Pause )
			{
				if( pHwDevExt->dvdstrm.Pause() == FALSE )
				{
					DBG_PRINTF(("HwStreamChange Error..... LINE=%d\r\n", __LINE__ ));
					DBG_BREAK();
					return FALSE;
				};
			};
			break;

		case StreamState_Play:
			// Normal Play
			if( pHwDevExt->Rate == 10000 )
			{

				switch( pHwDevExt->dvdstrm.GetState() )
				{
					case PowerOff:
						DBG_PRINTF((" Stream State is Off?????\r\n" ));
						DBG_BREAK();
						return FALSE;		// Stream

					case Stop:
						if( pHwDevExt->dvdstrm.Pause() == FALSE )
						{
							DBG_PRINTF(("HwStreamChange Error..... LINE=%d\r\n", __LINE__ ));
							DBG_BREAK();
							return FALSE;
						};
					case Scan:
					case Slow:
					case Pause:
						if( pHwDevExt->dvdstrm.Play() == FALSE )
						{
							DBG_PRINTF(("HwStreamChange Error..... LINE=%d\r\n", __LINE__ ));
							DBG_BREAK();
							return FALSE;
						};
						dProp = pHwDevExt->m_ClosedCaption;
						if( !pHwDevExt->dvdstrm.SetVideoProperty( VideoProperty_ClosedCaption, &dProp ) )
						{
							DBG_PRINTF( ("DVDWDM:   ClosedCaption Error\n\r") );
							DBG_BREAK();
						}
						break;
					case Play:
						break;
				};

			};

			if( pHwDevExt->Rate < 10000 )		// Scan Mode
			{

				switch( pHwDevExt->dvdstrm.GetState() )
				{
					case PowerOff:
						DBG_PRINTF((" Stream State is Off?????\r\n" ));
						DBG_BREAK();
						return FALSE;		// Stream

					case Stop:
						if( pHwDevExt->dvdstrm.Pause() == FALSE )
						{
							DBG_PRINTF(("HwStreamChange Error..... LINE=%d\r\n", __LINE__ ));
							DBG_BREAK();
							return FALSE;
						};
					case Slow:
					case Pause:
					case Play:
						if( pHwDevExt->dvdstrm.Scan( ScanOnlyI ) == FALSE )
						{
							DBG_PRINTF(("HwStreamChange Error..... LINE=%d\r\n", __LINE__ ));
							DBG_BREAK();
							return FALSE;
						};
						dProp = ClosedCaption_Off;
						if( !pHwDevExt->dvdstrm.SetVideoProperty( VideoProperty_ClosedCaption, &dProp ) ){
							DBG_PRINTF( ("DVDWDM:   ClosedCaption Error\n\r") );
							DBG_BREAK();
						}
						break;
					case Scan:
						break;
				};

			}
			
			if( pHwDevExt->Rate > 10000 )	// Slow Mode
			{

				switch( pHwDevExt->dvdstrm.GetState() )
				{
					case PowerOff:
						DBG_PRINTF((" Stream State is Off?????\r\n" ));
						DBG_BREAK();
						return FALSE;		// Stream

					case Stop:
						if( pHwDevExt->dvdstrm.Pause() == FALSE )
						{
							DBG_PRINTF(("HwStreamChange Error..... LINE=%d\r\n", __LINE__ ));
							DBG_BREAK();
							return FALSE;
						};
					case Pause:
					case Play:
					case Scan:
						dProp = pHwDevExt->Rate/10000;
						if( dProp>1 && dProp<16 ){
							if( !pHwDevExt->dvdstrm.Slow( dProp ) ){
								DBG_PRINTF( ("DVDWDM:   dvdstrm.Slow Error\n\r") );
								DBG_BREAK();
							}
						}else{
							DBG_PRINTF( ("DVDWDM:   Slow Speed is invalid 0x%0x\n\r", dProp ) );
							DBG_BREAK();
						}
						dProp = pHwDevExt->m_ClosedCaption;
						if( !pHwDevExt->dvdstrm.SetVideoProperty( VideoProperty_Closed